<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5579 - in trunk/rts: Lua Sim/Misc	Sim/MoveTypes Sim/Units Sim/Units/CommandAI System
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5579%20-%20in%20trunk/rts%3A%20Lua%20Sim/Misc%0A%09Sim/MoveTypes%20Sim/Units%20Sim/Units/CommandAI%20System&In-Reply-To=%3C20080312112131.82CCF45AD%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000359.html">
   <LINK REL="Next"  HREF="000361.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5579 - in trunk/rts: Lua Sim/Misc	Sim/MoveTypes Sim/Units Sim/Units/CommandAI System</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5579%20-%20in%20trunk/rts%3A%20Lua%20Sim/Misc%0A%09Sim/MoveTypes%20Sim/Units%20Sim/Units/CommandAI%20System&In-Reply-To=%3C20080312112131.82CCF45AD%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5579 - in trunk/rts: Lua Sim/Misc	Sim/MoveTypes Sim/Units Sim/Units/CommandAI System">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Mar 12 12:21:31 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000359.html">[Taspring-linux-commit] r5578 - in trunk/tools/springie/Springie: .	autohost
</A></li>
        <LI>Next message: <A HREF="000361.html">[Taspring-linux-commit] r5580 - trunk/rts/build/vstudio8
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#360">[ date ]</a>
              <a href="thread.html#360">[ thread ]</a>
              <a href="subject.html#360">[ subject ]</a>
              <a href="author.html#360">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: przybyjw
Date: 2008-03-12 12:21:30 +0100 (Wed, 12 Mar 2008)
New Revision: 5579

Modified:
   trunk/rts/Lua/LuaSyncedMoveCtrl.cpp
   trunk/rts/Lua/LuaSyncedRead.cpp
   trunk/rts/Sim/Misc/AirBaseHandler.h
   trunk/rts/Sim/MoveTypes/AAirMoveType.cpp
   trunk/rts/Sim/MoveTypes/AAirMoveType.h
   trunk/rts/Sim/MoveTypes/AirMoveType.cpp
   trunk/rts/Sim/MoveTypes/AirMoveType.h
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.h
   trunk/rts/Sim/MoveTypes/MoveType.cpp
   trunk/rts/Sim/MoveTypes/MoveType.h
   trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp
   trunk/rts/Sim/MoveTypes/ScriptMoveType.h
   trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
   trunk/rts/Sim/MoveTypes/TAAirMoveType.h
   trunk/rts/Sim/Units/CommandAI/AirCAI.cpp
   trunk/rts/Sim/Units/CommandAI/AirCAI.h
   trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
   trunk/rts/Sim/Units/CommandAI/MobileCAI.h
   trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp
   trunk/rts/Sim/Units/CommandAI/TransportCAI.h
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/Unit.h
   trunk/rts/System/Object.h
Log:
Refactored MoveTypes to provide a better interface. Modified Some Command AI to better define the boundary between Command AI and MoveType.

Modified: trunk/rts/Lua/LuaSyncedMoveCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedMoveCtrl.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Lua/LuaSyncedMoveCtrl.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -231,19 +231,19 @@
 
 	if (lua_isnumber(L, 2)) {
 		const int state = (int)lua_tonumber(L, 2);
-		if ((state &lt; CMoveType::Done) || (state &gt; CMoveType::Failed)) {
+		if ((state &lt; AMoveType::Done) || (state &gt; AMoveType::Failed)) {
 			luaL_error(L, &quot;SetProgressState(): bad state value (%i)&quot;, state);
 		}
-		moveType-&gt;progressState = (CMoveType::ProgressState) state;
+		moveType-&gt;progressState = (AMoveType::ProgressState) state;
 	}
 	else if (lua_isstring(L, 2)) {
 		const string state = lua_tostring(L, 2);
 		if (state == &quot;done&quot;) {
-			moveType-&gt;progressState = CMoveType::Done;
+			moveType-&gt;progressState = AMoveType::Done;
 		} else if (state == &quot;active&quot;) {
-			moveType-&gt;progressState = CMoveType::Active;
+			moveType-&gt;progressState = AMoveType::Active;
 		} else if (state == &quot;failed&quot;) {
-			moveType-&gt;progressState = CMoveType::Failed;
+			moveType-&gt;progressState = AMoveType::Failed;
 		} else {
 			luaL_error(L, &quot;SetProgressState(): bad state value (%s)&quot;, state.c_str());
 		}

Modified: trunk/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Lua/LuaSyncedRead.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -2236,7 +2236,7 @@
 	HSTR_PUSH_BOOL  (L, &quot;active&quot;,     unit-&gt;activated);
 	HSTR_PUSH_BOOL  (L, &quot;trajectory&quot;, unit-&gt;useHighTrajectory);
 
-	const CMoveType* mt = unit-&gt;moveType;
+	const AMoveType* mt = unit-&gt;moveType;
 	if (mt) {
 		const CTAAirMoveType* taAirMove = dynamic_cast&lt;const CTAAirMoveType*&gt;(mt);
 		if (taAirMove) {

Modified: trunk/rts/Sim/Misc/AirBaseHandler.h
===================================================================
--- trunk/rts/Sim/Misc/AirBaseHandler.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Misc/AirBaseHandler.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -2,6 +2,8 @@
 #define AIRBASEHANDLER_H
 
 #include &quot;Object.h&quot;
+#include &quot;System/float3.h&quot;
+#include &quot;System/GlobalStuff.h&quot;
 #include &lt;list&gt;
 #include &lt;boost/noncopyable.hpp&gt;
 

Modified: trunk/rts/Sim/MoveTypes/AAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AAirMoveType.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/AAirMoveType.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -1,11 +1,11 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;AAirMoveType.h&quot;
+#include &quot;Sim\Units\Unit.h&quot;
 
 
-CR_BIND_DERIVED_INTERFACE(AAirMoveType, CMoveType);
+CR_BIND_DERIVED_INTERFACE(AAirMoveType, AMoveType);
 
 CR_REG_METADATA(AAirMoveType, (
-		CR_MEMBER(goalPos),
 		CR_MEMBER(oldGoalPos),
 		CR_MEMBER(oldpos),
 		CR_MEMBER(reservedLandingPos),
@@ -15,28 +15,21 @@
 		CR_MEMBER(lastColWarningType),
 		CR_MEMBER(collide),
 		
-		CR_MEMBER(repairBelowHealth),
-		CR_MEMBER(reservedPad),
-		CR_MEMBER(padStatus),
 		CR_MEMBER(autoLand),
 		
 		CR_RESERVED(16)
 		));
 
 AAirMoveType::AAirMoveType(CUnit* unit) :
-	CMoveType(unit),
+	AMoveType(unit),
 	aircraftState(AIRCRAFT_LANDED),
 	autoLand(true),
 	collide(true),
-	goalPos(owner? owner-&gt;pos:float3(0, 0, 0)),
 	lastColWarning(0),
 	lastColWarningType(0),
 	oldpos(0,0,0),
 	oldGoalPos(owner? owner-&gt;pos:float3(0, 0, 0)),
-	padStatus(0),
-	repairBelowHealth(0.30f),
 	reservedLandingPos(-1,-1,-1),
-	reservedPad(0),
 	wantedHeight(80)
 {
 }
@@ -48,7 +41,18 @@
 		reservedPad = 0;
 	}
 }
-/*
-void AAirMoveType::SetState(AircraftState state){
-	assert(false);
-}*/
+
+void AAirMoveType::ReservePad(CAirBaseHandler::LandingPad* lp) {
+	oldGoalPos = goalPos;
+	AMoveType::ReservePad(lp);
+	Takeoff();
+}
+
+void AAirMoveType::DependentDied(CObject* o)
+{
+	AMoveType::DependentDied(o);
+	if(o == reservedPad){
+		SetState(AIRCRAFT_FLYING);
+		goalPos=oldGoalPos;
+	}
+}

Modified: trunk/rts/Sim/MoveTypes/AAirMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/AAirMoveType.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/AAirMoveType.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -6,7 +6,7 @@
 
 // Supposed to be an abstract class. Do not create an instance of this class.
 // Use either CTAAirMoveType or CAirMoveType instead.
-class AAirMoveType : public CMoveType
+class AAirMoveType : public AMoveType
 {
 	CR_DECLARE(AAirMoveType);
 public:
@@ -23,7 +23,6 @@
 	AAirMoveType(CUnit* unit);
 	~AAirMoveType();
 	
-	float3 goalPos;
 	float3 oldGoalPos;				//goalpos to resume flying to after landing
 	float3 oldpos;
 	float3 reservedLandingPos;
@@ -34,11 +33,14 @@
 	CUnit* lastColWarning;		//unit found to be dangerously close to our path
 	int lastColWarningType;		//1=generally forward of us,2=directly in path
 	
-	float repairBelowHealth;
-	CAirBaseHandler::LandingPad* reservedPad;
-	int padStatus;						//0 flying toward,1 landing at,2 landed
 	bool autoLand;
 
+	virtual bool IsFighter() = 0;
+	virtual void Takeoff() = 0;
+	void ReservePad(CAirBaseHandler::LandingPad* lp);
+	void DependentDied(CObject* o);
+	
+protected:
 	virtual void SetState(AircraftState state) = 0;
 };
 

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -366,16 +366,7 @@
 	if(aircraftState!=AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel&gt;0)
 		owner-&gt;currentFuel = max (0.f, owner-&gt;currentFuel - (16.f/GAME_SPEED));
 
-	if(!reservedPad &amp;&amp; aircraftState==AIRCRAFT_FLYING &amp;&amp; owner-&gt;health&lt;owner-&gt;maxHealth*repairBelowHealth &amp;&amp; !owner-&gt;crashing){
-		CAirBaseHandler::LandingPad* lp=airBaseHandler-&gt;FindAirBase(owner,owner-&gt;unitDef-&gt;minAirBasePower);
-		if(lp){
-			AddDeathDependence(lp);
-			reservedPad=lp;
-			padStatus=0;
-			oldGoalPos=goalPos;
-		}
-	}
-	if(owner-&gt;pos!=oldSlowUpdatePos){
+	if(owner-&gt;pos!=oldSlowUpdatePos) {
 		oldSlowUpdatePos=owner-&gt;pos;
 		if(owner-&gt;pos.y - ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) &gt; wantedHeight * 5 + 100)	//try to handle aircraft getting unlimited height
 			owner-&gt;pos.y = ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) + wantedHeight * 5  + 100;
@@ -1141,17 +1132,11 @@
 
 void CAirMoveType::DependentDied(CObject* o)
 {
-	if(o==reservedPad){
-		reservedPad=0;
-		SetState(AIRCRAFT_FLYING);
-		goalPos=oldGoalPos;
-	}
-
 	if(o==lastColWarning){
 		lastColWarning=0;
 		lastColWarningType=0;
 	}
-	CMoveType::DependentDied(o);
+	AMoveType::DependentDied(o);
 }
 
 void CAirMoveType::SetMaxSpeed(float speed)
@@ -1162,3 +1147,36 @@
 		invDrag = 1-drag;
 	}
 }
+
+
+void CAirMoveType::KeepPointingTo(float3 pos, float distance, bool aggressive) {
+	
+}
+void CAirMoveType::StartMoving(float3 pos, float goalRadius) {
+	SetGoal(pos);
+}
+void CAirMoveType::StartMoving(float3 pos, float goalRadius, float speed) {
+	SetWantedMaxSpeed(speed);
+	SetGoal(pos);
+}
+void CAirMoveType::StopMoving() {
+	SetGoal(owner-&gt;pos);
+	if((aircraftState == AAirMoveType::AIRCRAFT_FLYING)
+	   &amp;&amp; !owner-&gt;unitDef-&gt;DontLand() &amp;&amp; autoLand) {
+		SetState(AAirMoveType::AIRCRAFT_LANDING);
+	}
+}
+
+void CAirMoveType::Takeoff() {
+	if(aircraftState==AAirMoveType::AIRCRAFT_LANDED) {
+		SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
+	}
+	if (aircraftState == AAirMoveType::AIRCRAFT_LANDING) {
+		SetState(AAirMoveType::AIRCRAFT_FLYING);
+	}
+}
+
+bool CAirMoveType::IsFighter() {
+	return isFighter;
+}
+

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -5,7 +5,9 @@
 #define __AIR_MOVE_TYPE_H__
 
 #include &quot;AAirMoveType.h&quot;
+#include &lt;vector&gt;
 
+
 class CAirMoveType :
 	public AAirMoveType
 {
@@ -34,6 +36,14 @@
 	void CheckForCollision(void);
 	void DependentDied(CObject* o);
 	void SetMaxSpeed(float speed);
+	
+	void KeepPointingTo(float3 pos, float distance, bool aggressive);
+	void StartMoving(float3 pos, float goalRadius);
+	void StartMoving(float3 pos, float goalRadius, float speed);
+	void StopMoving();
+	
+	void Takeoff();
+	bool IsFighter();
 
 	int subState;
 
@@ -87,7 +97,7 @@
 	RudderInfo elevator;
 	RudderInfo aileronRight;
 	RudderInfo aileronLeft;
-	vector&lt;RudderInfo*&gt; rudders;
+	std::vector&lt;RudderInfo*&gt; rudders;
 
 	float lastRudderUpdate;
 	float lastRudderPos;

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -31,7 +31,7 @@
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
-CR_BIND_DERIVED(CGroundMoveType, CMoveType, (NULL));
+CR_BIND_DERIVED(CGroundMoveType, AMoveType, (NULL));
 
 CR_REG_METADATA(CGroundMoveType, (
 		CR_MEMBER(baseTurnRate),
@@ -48,7 +48,6 @@
 		CR_MEMBER(flatFrontDir),
 
 		CR_MEMBER(pathId),
-		CR_MEMBER(goal),
 		CR_MEMBER(goalRadius),
 
 		CR_MEMBER(waypoint),
@@ -119,7 +118,7 @@
 //////////////////////////////////////////////////////////////////////
 
 CGroundMoveType::CGroundMoveType(CUnit* owner)
-:	CMoveType(owner),
+:	AMoveType(owner),
 	accRate(0.01f),
 	turnRate(0.1f),
 	baseTurnRate(0.1f),
@@ -141,7 +140,6 @@
 	skidRotPos2(0),
 
 	pathId(0),
-	goal(0,0,0),
 	goalRadius(0),
 	waypoint(0,0,0),
 	nextWaypoint(0,0,0),
@@ -191,7 +189,7 @@
 {
 	//HACK:Initializing path after load
 	if (pathId) {
-		pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goal, goalRadius,owner);
+		pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goalPos, goalRadius,owner);
 	}
 }
 
@@ -272,7 +270,7 @@
 					logOutput.Print(&quot;eta failure %i %i %i %i %i&quot;, owner-&gt;id, pathId, !atGoal, currentDistanceToWaypoint &lt; MinDistanceToWaypoint(), gs-&gt;frameNum &gt; etaWaypoint);
 			}
 			if (pathId &amp;&amp; !atGoal &amp;&amp; gs-&gt;frameNum &gt; etaWaypoint2) {
-				if (owner-&gt;pos.distance2D(goal) &gt; 200 || CheckGoalFeasability()) {
+				if (owner-&gt;pos.distance2D(goalPos) &gt; 200 || CheckGoalFeasability()) {
 					etaWaypoint2 += 100;
 				} else {
 					if (DEBUG_CONTROLLER)
@@ -379,7 +377,7 @@
 
 	//If got too far away from path, then need to reconsider.
 	if(progressState == Active &amp;&amp; etaFailures&gt;8) {
-		if(owner-&gt;pos.distance2D(goal)&gt;200 || CheckGoalFeasability()){
+		if(owner-&gt;pos.distance2D(goalPos)&gt;200 || CheckGoalFeasability()){
 			if(DEBUG_CONTROLLER)
 				logOutput.Print(&quot;Unit eta failure %i&quot;,owner-&gt;id);
 			StopEngine();
@@ -456,7 +454,7 @@
 	}
 
 	//Sets the new goal.
-	goal = moveGoalPos;
+	goalPos = moveGoalPos;
 	goalRadius = goalRadius;
 	requestedSpeed = min(speed, maxSpeed*2);
 	requestedTurnRate = owner-&gt;mobility-&gt;maxTurnRate;
@@ -976,7 +974,7 @@
 			}
 
 			// now we do the obstacle avoidance proper
-			float currentDistanceToGoal = owner-&gt;pos.distance2D(goal);
+			float currentDistanceToGoal = owner-&gt;pos.distance2D(goalPos);
 			float3 rightOfPath = desiredDir.cross(float3(0,1,0));
 			float3 rightOfAvoid = rightOfPath;
 			float speedf=owner-&gt;speed.Length2D();
@@ -1108,7 +1106,7 @@
 
 	pathManager-&gt;DeletePath(pathId);
 
-	pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goal, goalRadius,owner);
+	pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goalPos, goalRadius,owner);
 
 	nextWaypoint=owner-&gt;pos;
 	//With new path recived, can't be at waypoint.
@@ -1153,8 +1151,8 @@
 			nextWaypoint=waypoint;
 		}
 		//If the waypoint is very close to the goal, then correct it into the goal.
-		if(waypoint.distance2D(goal) &lt; CPathManager::PATH_RESOLUTION){
-			waypoint = goal;
+		if(waypoint.distance2D(goalPos) &lt; CPathManager::PATH_RESOLUTION){
+			waypoint = goalPos;
 			haveFinalWaypoint=true;
 		}
 	}
@@ -1323,7 +1321,7 @@
 				owner-&gt;unitDef-&gt;sounds.cant.getVolume(soundIdx));
 		}
 
-		if (!owner-&gt;commandAI-&gt;unimportantMove &amp;&amp; owner-&gt;pos.distance(goal) &gt; goalRadius + 150) {
+		if (!owner-&gt;commandAI-&gt;unimportantMove &amp;&amp; owner-&gt;pos.distance(goalPos) &gt; goalRadius + 150) {
 			if (gs-&gt;frameNum % (GAME_SPEED * 3) == 0) {
 				logOutput &lt;&lt; owner-&gt;unitDef-&gt;humanName.c_str() &lt;&lt; &quot;: Can't reach destination!\n&quot;;
 				logOutput.SetLastMsgPos(owner-&gt;pos);
@@ -1687,13 +1685,13 @@
 
 bool CGroundMoveType::CheckGoalFeasability(void)
 {
-	float goalDist=goal.distance2D(owner-&gt;pos);
+	float goalDist=goalPos.distance2D(owner-&gt;pos);
 
-	int minx=(int)max(0.f,(goal.x-goalDist)/(SQUARE_SIZE*2));
-	int minz=(int)max(0.f,(goal.z-goalDist)/(SQUARE_SIZE*2));
+	int minx=(int)max(0.f,(goalPos.x-goalDist)/(SQUARE_SIZE*2));
+	int minz=(int)max(0.f,(goalPos.z-goalDist)/(SQUARE_SIZE*2));
 
-	int maxx=(int)min(float(gs-&gt;hmapx-1),(goal.x+goalDist)/(SQUARE_SIZE*2));
-	int maxz=(int)min(float(gs-&gt;hmapy-1),(goal.z+goalDist)/(SQUARE_SIZE*2));
+	int maxx=(int)min(float(gs-&gt;hmapx-1),(goalPos.x+goalDist)/(SQUARE_SIZE*2));
+	int maxz=(int)min(float(gs-&gt;hmapy-1),(goalPos.z+goalDist)/(SQUARE_SIZE*2));
 
 	MoveData* md=owner-&gt;unitDef-&gt;movedata;
 	CMoveMath* mm=md-&gt;moveMath;
@@ -1704,7 +1702,7 @@
 	for(int z=minz;z&lt;=maxz;++z){
 		for(int x=minx;x&lt;=maxx;++x){
 			float3 pos(x*SQUARE_SIZE*2,0,z*SQUARE_SIZE*2);
-			if((pos-goal).SqLength2D()&lt;goalDist*goalDist){
+			if((pos-goalPos).SqLength2D()&lt;goalDist*goalDist){
 				int blockingType=mm-&gt;SquareIsBlocked(*md,x*2,z*2);
 				if((blockingType &amp; CMoveMath::BLOCK_STRUCTURE) || mm-&gt;SpeedMod(*md,x*2,z*2)&lt;0.01f){
 					numBlocked+=0.3f;

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -7,7 +7,7 @@
 struct MoveData;
 
 class CGroundMoveType :
-	public CMoveType
+	public AMoveType
 {
 	CR_DECLARE(CGroundMoveType);
 public:
@@ -49,7 +49,6 @@
 	float3 flatFrontDir;
 
 	unsigned int pathId;
-	float3 goal;
 	float goalRadius;
 
 	float3 waypoint;

Modified: trunk/rts/Sim/MoveTypes/MoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveType.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/MoveType.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -1,71 +1,109 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;MoveType.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;mmgr.h&quot;
 
-CR_BIND_DERIVED(CMoveType, CObject, (NULL));
+CR_BIND_DERIVED_INTERFACE(AMoveType, CObject);
 
-CR_REG_METADATA(CMoveType, (
+CR_REG_METADATA(AMoveType, (
 		CR_MEMBER(forceTurn),
 		CR_MEMBER(forceTurnTo),
 		CR_MEMBER(owner),
 		CR_MEMBER(maxSpeed),
 		CR_MEMBER(maxWantedSpeed),
 		CR_MEMBER(useHeading),
+		CR_MEMBER(goalPos),
+		CR_MEMBER(reservedPad),
+		CR_MEMBER(padStatus),
 		CR_ENUM_MEMBER(progressState),
+		CR_MEMBER(repairBelowHealth),
 		CR_RESERVED(32)
 		));
 
+CR_BIND_DERIVED(CMoveType, AMoveType, (NULL));
 
-CMoveType::CMoveType(CUnit* owner)
+
+CR_REG_METADATA(CMoveType,
+		(
+		CR_RESERVED(63)
+		));
+
+AMoveType::AMoveType(CUnit* owner)
 : owner(owner),
 	forceTurn(0),
 	forceTurnTo(0),
 	maxSpeed(0.2f),
 	maxWantedSpeed(0.2f),
 	useHeading(true),
+	goalPos(owner-&gt;pos),
+	reservedPad(0),
+	padStatus(0),
+	repairBelowHealth(0),
 	progressState(Done)
 {
 }
 
-CMoveType::~CMoveType(void)
+AMoveType::~AMoveType(void)
 {
 }
 
-void CMoveType::SetMaxSpeed(float speed)
+void AMoveType::SetMaxSpeed(float speed)
 {
 	assert(speed &gt; 0);
-	maxSpeed=speed;
+	maxSpeed = speed;
 }
 
-void CMoveType::SetWantedMaxSpeed(float speed)
+void AMoveType::SetWantedMaxSpeed(float speed)
 {
-	if(speed &gt; maxSpeed)
+	if(speed &gt; maxSpeed) {
 		maxWantedSpeed = maxSpeed;
-	else if(speed &lt; 0.001f)
+	} else if(speed &lt; 0.001f) {
 		maxWantedSpeed = 0;
-	else
+	} else {
 		maxWantedSpeed = speed;
+	}
 }
 
-void CMoveType::ImpulseAdded(void)
+void AMoveType::ImpulseAdded(void)
 {
 }
 
-void CMoveType::SlowUpdate()
+void AMoveType::SlowUpdate()
 {
-	owner-&gt;pos.y=ground-&gt;GetHeight2(owner-&gt;pos.x,owner-&gt;pos.z);
-	if(owner-&gt;floatOnWater &amp;&amp; owner-&gt;pos.y&lt;0)
+	owner-&gt;pos.y = ground-&gt;GetHeight2(owner-&gt;pos.x,owner-&gt;pos.z);
+	if(owner-&gt;floatOnWater &amp;&amp; owner-&gt;pos.y&lt; -owner-&gt;unitDef-&gt;waterline) {
 		owner-&gt;pos.y = -owner-&gt;unitDef-&gt;waterline;
+	}
 	owner-&gt;midPos.y=owner-&gt;pos.y+owner-&gt;relMidPos.y;
 };
 
-void CMoveType::LeaveTransport(void)
+void AMoveType::LeaveTransport(void)
 {
 }
 
-void CMoveType::KeepPointingTo(CUnit* unit, float distance, bool aggressive)
+void AMoveType::KeepPointingTo(CUnit* unit, float distance, bool aggressive)
 {
 	KeepPointingTo(float3(unit-&gt;pos), distance, aggressive);
-};
+}
+
+void AMoveType::SetGoal(float3 pos)
+{
+	goalPos = pos;
+}
+
+void AMoveType::DependentDied(CObject* o)
+{
+	if(o == reservedPad){
+		reservedPad=0;
+	}
+}
+
+void AMoveType::ReservePad(CAirBaseHandler::LandingPad* lp)
+{
+	AddDeathDependence(lp);
+	reservedPad = lp;
+	padStatus = 0;
+	SetGoal(lp-&gt;GetUnit()-&gt;pos);
+}

Modified: trunk/rts/Sim/MoveTypes/MoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/MoveType.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/MoveType.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -2,44 +2,51 @@
 #define MOVETYPE_H
 
 #include &quot;Object.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Misc/AirBaseHandler.h&quot;
+#include &quot;System/float3.h&quot;
 
-class CMoveType :
+class CUnit;
+
+class AMoveType :
 	public CObject
 {
-	CR_DECLARE(CMoveType);
+	CR_DECLARE(AMoveType);
 public:
-	CMoveType(CUnit* owner);
-	virtual ~CMoveType(void);
+	AMoveType(CUnit* owner);
+	virtual ~AMoveType(void);
 
-	virtual void StartMoving(float3 pos, float goalRadius){};
-	virtual void StartMoving(float3 pos, float goalRadius, float speed){};
-	virtual void KeepPointingTo(float3 pos, float distance, bool aggressive) {};
+	virtual void StartMoving(float3 pos, float goalRadius) = 0;
+	virtual void StartMoving(float3 pos, float goalRadius, float speed) = 0;
+	virtual void KeepPointingTo(float3 pos, float distance, bool aggressive) = 0;
 	virtual void KeepPointingTo(CUnit* unit, float distance, bool aggressive);
-	virtual void StopMoving(){};
-	virtual void Idle(unsigned int frames){};
-	virtual void Idle(){};
-	virtual void DeIdle(){};
+	virtual void StopMoving() = 0;
 	virtual void ImpulseAdded(void);
+	virtual void ReservePad(CAirBaseHandler::LandingPad* lp);
 
 //	virtual float GetSpeedMod(int square){return 1;};
 //	virtual float GetSpeedMod(float avrHeight, float maxHeight, float maxDepth, float avrSlope, float maxSlope) {return 1;};
 
-	virtual void SetGoal(float3 pos) {};
+	virtual void SetGoal(float3 pos);
 	virtual void SetMaxSpeed(float speed);
 	virtual void SetWantedMaxSpeed(float speed);
 	virtual void LeaveTransport(void);
 
-	virtual void Update(){};
+	virtual void Update() = 0;
 	virtual void SlowUpdate();
 
 	int forceTurn;
 	int forceTurnTo;
 
 	CUnit* owner;
+	
+	float3 goalPos;
 
 	float maxSpeed;
 	float maxWantedSpeed;
+	
+	CAirBaseHandler::LandingPad* reservedPad;
+	int padStatus;						//0 moving toward,1 landing at,2 arrived
+	float repairBelowHealth;
 
 	bool useHeading;		//probably should move the code in cunit that reads this into the movementclasses
 
@@ -49,7 +56,22 @@
 		Failed = 2
 	};
 	ProgressState progressState;
+protected:
+	void DependentDied(CObject* o);
 };
 
+class CMoveType : public AMoveType
+{
+	CR_DECLARE(CMoveType);
+public:
+	CMoveType(CUnit* unit) : AMoveType(unit){};
+	virtual void StartMoving(float3 pos, float goalRadius){};
+	virtual void StartMoving(float3 pos, float goalRadius, float speed){};
+	virtual void KeepPointingTo(float3 pos, float distance, bool aggressive){};
+	virtual void StopMoving(){};
+	virtual void Update(){};
+	
+};
 
+
 #endif /* MOVETYPE_H */

Modified: trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -15,7 +15,7 @@
 #include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
-CR_BIND_DERIVED(CScriptMoveType, CMoveType, (NULL));
+CR_BIND_DERIVED(CScriptMoveType, AMoveType, (NULL));
 
 CR_REG_METADATA(CScriptMoveType, (
 	CR_MEMBER(tag),
@@ -54,7 +54,7 @@
 
 
 CScriptMoveType::CScriptMoveType(CUnit* owner)
-: CMoveType(owner),
+: AMoveType(owner),
 	tag(0),
   extrapolate(true),
 	drag(0.0f),

Modified: trunk/rts/Sim/MoveTypes/ScriptMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/ScriptMoveType.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/ScriptMoveType.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -3,7 +3,7 @@
 
 #include &quot;MoveType.h&quot;
 
-class CScriptMoveType : public CMoveType
+class CScriptMoveType : public AMoveType
 {
 	CR_DECLARE(CScriptMoveType);
 

Modified: trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -1036,5 +1036,20 @@
 		lastColWarningType = 0;
 	}
 
-	CMoveType::DependentDied(o);
+	AMoveType::DependentDied(o);
 }
+
+void CTAAirMoveType::Takeoff()
+{
+	if(aircraftState==AAirMoveType::AIRCRAFT_LANDED) {
+		SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
+	}
+	if (aircraftState == AAirMoveType::AIRCRAFT_LANDING) {
+		SetState(AAirMoveType::AIRCRAFT_FLYING);
+	}
+}
+
+bool CTAAirMoveType::IsFighter()
+{
+	return false;
+}

Modified: trunk/rts/Sim/MoveTypes/TAAirMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/TAAirMoveType.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/MoveTypes/TAAirMoveType.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -88,6 +88,9 @@
 	void SetWantedAltitude(float altitude);
 	void CheckForCollision(void);
 	void DependentDied(CObject* o);
+	
+	void Takeoff();
+	bool IsFighter();
 };
 
 

Modified: trunk/rts/Sim/Units/CommandAI/AirCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -42,35 +42,6 @@
 	cancelDistance = 16000;
 	CommandDescription c;
 
-	// aircraft can always move...
-	/*c.id=CMD_MOVE;
-	c.action=&quot;move&quot;;
-	c.type=CMDTYPE_ICON_MAP;
-	c.name=&quot;Move&quot;;
-	c.mouseicon=c.name;
-	c.tooltip=&quot;Move: Commands the aircraft to fly to the location&quot;;
-	possibleCommands.push_back(c);
-
-	if(owner-&gt;unitDef-&gt;canPatrol){
-		c.id=CMD_PATROL;
-		c.action=&quot;patrol&quot;;
-		c.type=CMDTYPE_ICON_MAP;
-		c.name=&quot;Patrol&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Patrol: Sets the aircraft to patrol a path to one or more waypoints&quot;;
-		possibleCommands.push_back(c);
-	}
-
-	if (owner-&gt;unitDef-&gt;canFight) {
-		c.id = CMD_FIGHT;
-		c.action=&quot;fight&quot;;
-		c.type = CMDTYPE_ICON_MAP;
-		c.name = &quot;Fight&quot;;
-		c.mouseicon=c.name;
-		c.tooltip = &quot;Fight: Order the aircraft to take action while moving to a position&quot;;
-		possibleCommands.push_back(c);
-	}*/
-
 	if(owner-&gt;unitDef-&gt;canAttack){
 		c.id=CMD_AREA_ATTACK;
 		c.action=&quot;areaattack&quot;;
@@ -79,33 +50,8 @@
 		c.mouseicon=c.name;
 		c.tooltip=&quot;Sets the aircraft to attack enemy units within a circle&quot;;
 		possibleCommands.push_back(c);
-	}/*
-
-	if(owner-&gt;unitDef-&gt;canGuard){
-		c.id=CMD_GUARD;
-		c.action=&quot;guard&quot;;
-		c.type=CMDTYPE_ICON_UNIT;
-		c.name=&quot;Guard&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Guard: Order a unit to guard another unit and attack units attacking it&quot;;
-		possibleCommands.push_back(c);
-	}*/
-/*
-	c.params.clear();
-	c.id=CMD_AUTOREPAIRLEVEL;
-	c.action=&quot;autorepairlevel&quot;;
-	c.type=CMDTYPE_ICON_MODE;
-	c.name=&quot;Repair level&quot;;
-	c.mouseicon=c.name;
-	c.params.push_back(&quot;1&quot;);
-	c.params.push_back(&quot;LandAt 0&quot;);
-	c.params.push_back(&quot;LandAt 30&quot;);
-	c.params.push_back(&quot;LandAt 50&quot;);
-	c.params.push_back(&quot;LandAt 80&quot;);
-	c.tooltip=&quot;Repair level: Sets at which health level an aircraft will try to find a repair pad&quot;;
-	possibleCommands.push_back(c);
-	nonQueingCommands.insert(CMD_AUTOREPAIRLEVEL);
-*/
+	}
+	
 	if(owner-&gt;unitDef-&gt;canLoopbackAttack){
 		c.params.clear();
 		c.id=CMD_LOOPBACKATTACK;
@@ -259,21 +205,22 @@
 		return; // avoid the invalid (CAirMoveType*) cast
 	}
 
-	CAirMoveType* myPlane=(CAirMoveType*) owner-&gt;moveType;
+	AAirMoveType* myPlane=(AAirMoveType*) owner-&gt;moveType;
 
 	if(owner-&gt;unitDef-&gt;maxFuel &gt; 0){
-		RefuelIfNeeded(myPlane);
+		RefuelIfNeeded();
 	}
 
 	if(commandQue.empty()){
 		if(myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_FLYING
 			&amp;&amp; !owner-&gt;unitDef-&gt;DontLand() &amp;&amp; myPlane-&gt;autoLand){
-			myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_LANDING);
+			StopMove();
+//			myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_LANDING);
 		}
 
 		if(owner-&gt;unitDef-&gt;canAttack &amp;&amp; owner-&gt;fireState&gt;=2
 				&amp;&amp; owner-&gt;moveState != 0 &amp;&amp; owner-&gt;maxRange &gt; 0){
-			if(myPlane-&gt;isFighter){
+			if(myPlane-&gt;IsFighter()){
 				float testRad=1000 * owner-&gt;moveState;
 				CUnit* enemy=helper-&gt;GetClosestEnemyAircraft(
 					owner-&gt;pos + (owner-&gt;speed * 10), testRad, owner-&gt;allyteam);
@@ -308,18 +255,14 @@
 	if (c.id == CMD_WAIT) {
 		if ((myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_FLYING)
 		    &amp;&amp; !owner-&gt;unitDef-&gt;DontLand() &amp;&amp; myPlane-&gt;autoLand) {
-			myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_LANDING);
+			StopMove(); 
+//			myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_LANDING);
 		}
 		return;
 	}
 
 	if (c.id != CMD_STOP) {
-		if (myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDED) {
-			myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
-		}
-		if (myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDING) {
-			myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_FLYING);
-		}
+		myPlane-&gt;Takeoff();
 	}
 
 	float3 curPos=owner-&gt;pos;
@@ -405,7 +348,7 @@
 void CAirCAI::ExecuteFight(Command &amp;c)
 {
 	assert((c.options &amp; INTERNAL_ORDER) || owner-&gt;unitDef-&gt;canFight);
-	CAirMoveType* myPlane = (CAirMoveType*) owner-&gt;moveType;
+	AAirMoveType* myPlane = (AAirMoveType*) owner-&gt;moveType;
 	if(tempOrder){
 		tempOrder=false;
 		inCommand=true;
@@ -446,7 +389,7 @@
 				owner-&gt;pos + owner-&gt;speed*10);
 		float testRad = 1000 * owner-&gt;moveState;
 		CUnit* enemy = NULL;
-		if(myPlane-&gt;isFighter) {
+		if(myPlane-&gt;IsFighter()) {
 			enemy = helper-&gt;GetClosestEnemyAircraft(curPosOnLine,
 					testRad, owner-&gt;allyteam);
 		}
@@ -487,7 +430,7 @@
 			}
 		}
 	}
-	myPlane-&gt;goalPos=goalPos;
+	myPlane-&gt;goalPos = goalPos;
 
 	if((owner-&gt;pos - goalPos).SqLength2D() &lt; (127 * 127)
 			|| (owner-&gt;pos + owner-&gt;speed*8 - goalPos).SqLength2D() &lt; (127 * 127)) {
@@ -507,21 +450,7 @@
 			FinishCommand();
 			return;
 		}
-	}/* why was this block here? - ILMTitan
-	if(tempOrder &amp;&amp; myPlane-&gt;isFighter &amp;&amp; orderTarget){
-		if(owner-&gt;fireState &gt;= 2 &amp;&amp; owner-&gt;moveState != 0){
-			CUnit* enemy = helper-&gt;GetClosestEnemyAircraft(
-				owner-&gt;pos + (owner-&gt;speed * 50), 800, owner-&gt;allyteam);
-			if(enemy &amp;&amp; (!orderTarget-&gt;unitDef-&gt;canfly
-					|| (orderTarget-&gt;pos-owner-&gt;pos + owner-&gt;speed * 50).
-					Length() + (100 * gs-&gt;randFloat() * 40) - targetAge
-					&lt; (enemy-&gt;pos-owner-&gt;pos + owner-&gt;speed * 50).Length())){
-				c.params.clear();
-				c.params.push_back(enemy-&gt;id);
-				inCommand=false;
-			}
-		}
-	}*/
+	}
 	if(inCommand){
 		if(targetDied || (c.params.size() == 1 &amp;&amp; UpdateTargetLostTimer(int(c.params[0])) == 0)){
 			FinishCommand();
@@ -544,12 +473,6 @@
 				return;
 			}
 		}
-		if(orderTarget){
-//				myPlane-&gt;goalPos=orderTarget-&gt;pos;
-		} else {
-//				float3 pos(c.params[0],c.params[1],c.params[2]);
-//				myPlane-&gt;goalPos=pos;
-		}
 	} else {
 		targetAge=0;
 		owner-&gt;commandShotCount = -1;
@@ -559,6 +482,7 @@
 				owner-&gt;AttackUnit(orderTarget, false);
 				AddDeathDependence(orderTarget);
 				inCommand = true;
+				SetGoal(orderTarget-&gt;pos, owner-&gt;pos, cancelDistance);
 			} else {
 				FinishCommand();
 				return;
@@ -575,7 +499,7 @@
 void CAirCAI::ExecuteAreaAttack(Command &amp;c)
 {
 	assert(owner-&gt;unitDef-&gt;canAttack);
-	CAirMoveType* myPlane = (CAirMoveType*) owner-&gt;moveType;
+	AAirMoveType* myPlane = (AAirMoveType*) owner-&gt;moveType;
 	if(targetDied){
 		targetDied = false;
 		inCommand = false;
@@ -749,15 +673,6 @@
 	lineDrawer.FinishPath();
 }
 
-void CAirCAI::StopMove()
-{
-	CAirMoveType* myPlane = (CAirMoveType*)owner-&gt;moveType;
-	if((myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_FLYING)
-	   &amp;&amp; !owner-&gt;unitDef-&gt;DontLand() &amp;&amp; myPlane-&gt;autoLand) {
-		myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_LANDING);
-	}
-}
-
 void CAirCAI::FinishCommand(void)
 {
 	targetAge=0;
@@ -766,13 +681,15 @@
 
 void CAirCAI::BuggerOff(float3 pos, float radius)
 {
-	CAirMoveType* myPlane=(CAirMoveType*)owner-&gt;moveType;
-	if(myPlane-&gt;aircraftState==AAirMoveType::AIRCRAFT_LANDED){
-		myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
+	AAirMoveType* myPlane = dynamic_cast&lt;AAirMoveType*&gt;(owner-&gt;moveType);
+	if(myPlane) {
+		myPlane-&gt;Takeoff();
+	} else {
+		CMobileCAI::BuggerOff(pos, radius);
 	}
 }
 
 void CAirCAI::SetGoal(const float3 &amp;pos, const float3 &amp;curPos, float goalRadius){
-	((CAirMoveType*) owner-&gt;moveType)-&gt;goalPos = pos;
+	owner-&gt;moveType-&gt;SetGoal(pos);
 	CMobileCAI::SetGoal(pos, curPos, goalRadius);
 }

Modified: trunk/rts/Sim/Units/CommandAI/AirCAI.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/AirCAI.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/AirCAI.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -22,7 +22,7 @@
 	void AddUnit(CUnit* unit);
 	void FinishCommand(void);
 	void BuggerOff(float3 pos, float radius);
-	void StopMove();
+//	void StopMove();
 	
 	void SetGoal(const float3&amp; pos, const float3&amp; curPos, float goalRadius = SQUARE_SIZE);
 	

Modified: trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -401,7 +401,7 @@
 						}
 					}
 				} else {
-					if (owner-&gt;moveType-&gt;progressState == CMoveType::Failed) {
+					if (owner-&gt;moveType-&gt;progressState == AMoveType::Failed) {
 						if (++buildRetries &gt; 5) {
 							StopMove();
 							FinishCommand();
@@ -753,7 +753,7 @@
 					if (f3Dist(goalPos, feature-&gt;pos) &gt; 1) {
 						SetGoal(feature-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance*0.8f+feature-&gt;radius);
 					} else {
-						if(owner-&gt;moveType-&gt;progressState==CMoveType::Failed){
+						if(owner-&gt;moveType-&gt;progressState==AMoveType::Failed){
 							StopMove();
 							FinishCommand();
 						}
@@ -882,9 +882,9 @@
 		FinishCommand();
 		return;
 	}
-	if(owner-&gt;haveTarget &amp;&amp; owner-&gt;moveType-&gt;progressState!=CMoveType::Done){
+	if(owner-&gt;haveTarget &amp;&amp; owner-&gt;moveType-&gt;progressState!=AMoveType::Done){
 		StopMove();
-	} else if(owner-&gt;moveType-&gt;progressState!=CMoveType::Active){
+	} else if(owner-&gt;moveType-&gt;progressState!=AMoveType::Active){
 		owner-&gt;moveType-&gt;StartMoving(goalPos, 8);
 	}
 	return;
@@ -1055,7 +1055,7 @@
 		if (f3Dist(goalPos, object-&gt;pos) &gt; 1) {
 			SetGoal(object-&gt;pos, owner-&gt;pos);
 		} else {
-			if (owner-&gt;moveType-&gt;progressState == CMoveType::Failed) {
+			if (owner-&gt;moveType-&gt;progressState == AMoveType::Failed) {
 				return false;
 			}
 		}

Modified: trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -10,6 +10,7 @@
 #include &quot;Game/UI/CursorIcons.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/MoveTypes/MoveType.h&quot;
 #include &quot;Sim/MoveTypes/TAAirMoveType.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
@@ -259,11 +260,9 @@
 	CCommandAI::GiveAllowedCommand(c);
 }
 
-void CMobileCAI::RefuelIfNeeded(AAirMoveType* myPlane)
+void CMobileCAI::RefuelIfNeeded()
 {
-	if(myPlane-&gt;reservedPad){
-		return;
-	} else {
+	if(!owner-&gt;moveType-&gt;reservedPad) {
 		if(owner-&gt;currentFuel &lt;= 0){
 			StopMove();
 			owner-&gt;userAttackGround=false;
@@ -272,46 +271,35 @@
 			CAirBaseHandler::LandingPad* lp = airBaseHandler-&gt;FindAirBase(
 				owner, owner-&gt;unitDef-&gt;minAirBasePower);
 			if(lp){
-				myPlane-&gt;AddDeathDependence(lp);
-				myPlane-&gt;reservedPad = lp;
-				myPlane-&gt;padStatus = 0;
-				myPlane-&gt;oldGoalPos = myPlane-&gt;goalPos;
-				return;
-			}
-			float3 landingPos = airBaseHandler-&gt;FindClosestAirBasePos(
-				owner, owner-&gt;unitDef-&gt;minAirBasePower);
-			if(landingPos != ZeroVector &amp;&amp; owner-&gt;pos.distance2D(landingPos) &gt; 300){
-				if(myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDED
-						&amp;&amp; owner-&gt;pos.distance2D(landingPos) &gt; 800) {
-					myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
+				owner-&gt;moveType-&gt;ReservePad(lp);
+			} else {
+				float3 landingPos = airBaseHandler-&gt;FindClosestAirBasePos(
+						owner, owner-&gt;unitDef-&gt;minAirBasePower);
+				if(landingPos != ZeroVector &amp;&amp; owner-&gt;pos.distance2D(landingPos) &gt; 800){
+					SetGoal(landingPos,owner-&gt;pos);
+					//myPlane-&gt;goalPos = landingPos;
+				} else {
+					owner-&gt;moveType-&gt;StopMoving();
 				}
+			}
+		} else if(owner-&gt;currentFuel &lt; 
+				(owner-&gt;moveType-&gt;repairBelowHealth * owner-&gt;unitDef-&gt;maxFuel)
+				&amp;&amp; commandQue.empty() || commandQue.front().id == CMD_PATROL
+				|| commandQue.front().id == CMD_FIGHT) {
+			CAirBaseHandler::LandingPad* lp =
+				airBaseHandler-&gt;FindAirBase(owner, owner-&gt;unitDef-&gt;minAirBasePower);
+			if(lp) {
 				StopMove();
-				SetGoal(landingPos,owner-&gt;pos);
-				//myPlane-&gt;goalPos = landingPos;
-			} else {
-				if(myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_FLYING)
-					myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_LANDING);
+				owner-&gt;userAttackGround = false;
+				owner-&gt;userTarget = 0;
+				inCommand = false;
+				owner-&gt;moveType-&gt;ReservePad(lp);
 			}
-			return;
-		}
-		if(owner-&gt;currentFuel &lt; myPlane-&gt;repairBelowHealth * owner-&gt;unitDef-&gt;maxFuel){
-			if(commandQue.empty() || commandQue.front().id == CMD_PATROL){
-				CAirBaseHandler::LandingPad* lp =
-					airBaseHandler-&gt;FindAirBase(owner, owner-&gt;unitDef-&gt;minAirBasePower);
-				if(lp){
-					StopMove();
-					owner-&gt;userAttackGround=false;
-					owner-&gt;userTarget=0;
-					inCommand=false;
-					myPlane-&gt;AddDeathDependence(lp);
-					myPlane-&gt;reservedPad=lp;
-					myPlane-&gt;padStatus=0;
-					myPlane-&gt;oldGoalPos=myPlane-&gt;goalPos;
-					if(myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDED){
-						myPlane-&gt;SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
-					}
-					return;
-				}
+		} else if(owner-&gt;health &lt; owner-&gt;maxHealth*owner-&gt;moveType-&gt;repairBelowHealth) {
+			CAirBaseHandler::LandingPad* lp =
+				airBaseHandler-&gt;FindAirBase(owner, owner-&gt;unitDef-&gt;minAirBasePower);
+			if(lp) {
+				owner-&gt;moveType-&gt;ReservePad(lp);
 			}
 		}
 	}
@@ -320,8 +308,7 @@
 void CMobileCAI::SlowUpdate()
 {
 	if(owner-&gt;unitDef-&gt;maxFuel&gt;0 &amp;&amp; dynamic_cast&lt;AAirMoveType*&gt;(owner-&gt;moveType)){
-		AAirMoveType* myPlane=(AAirMoveType*)owner-&gt;moveType;
-		RefuelIfNeeded(myPlane);
+		RefuelIfNeeded();
 	}
 
 	if(!commandQue.empty() &amp;&amp; commandQue.front().timeOut &lt; gs-&gt;frameNum){
@@ -401,7 +388,7 @@
 		SetGoal(pos, owner-&gt;pos);
 	}
 	if((owner-&gt;pos - goalPos).SqLength2D() &lt; cancelDistance ||
-			owner-&gt;moveType-&gt;progressState == CMoveType::Failed){
+			owner-&gt;moveType-&gt;progressState == AMoveType::Failed){
 		FinishCommand();
 	}
 	return;
@@ -436,7 +423,7 @@
 	if((owner-&gt;pos - goalPos).SqLength2D() &lt; cancelDistance){
 		StopMove();
 	}
-	if(owner-&gt;moveType-&gt;progressState == CMoveType::Failed){
+	if(owner-&gt;moveType-&gt;progressState == AMoveType::Failed){
 	}
 	return;
 }
@@ -545,7 +532,7 @@
 		}
 	}
 	if((owner-&gt;pos - goalPos).SqLength2D() &lt; (64 * 64)
-			|| (owner-&gt;moveType-&gt;progressState == CMoveType::Failed)){
+			|| (owner-&gt;moveType-&gt;progressState == AMoveType::Failed)){
 		FinishCommand();
 	}
 	return;
@@ -773,7 +760,7 @@
 			//assumption is flawed: The unit may be aiming or otherwise unable to shoot
 			else if (owner-&gt;unitDef-&gt;strafeToAttack &amp;&amp; b3 &amp;&amp; diffLength2d &lt; (owner-&gt;maxRange * 0.9f))
 			{
-				moveDir ^= (owner-&gt;moveType-&gt;progressState == CMoveType::Failed);
+				moveDir ^= (owner-&gt;moveType-&gt;progressState == AMoveType::Failed);
 				float sin = moveDir ? 3.0/5 : -3.0/5;
 				float cos = 4.0/5;
 				float3 goalDiff(0, 0, 0);
@@ -891,7 +878,7 @@
 void CMobileCAI::StopMove()
 {
 	owner-&gt;moveType-&gt;StopMoving();
-	goalPos=owner-&gt;pos;
+	goalPos = owner-&gt;pos;
 }
 
 void CMobileCAI::DrawCommands(void)

Modified: trunk/rts/Sim/Units/CommandAI/MobileCAI.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/MobileCAI.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/MobileCAI.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -31,7 +31,7 @@
 	void ExecuteDGun(Command &amp;c);
 	void ExecuteStop(Command &amp;c);
 	
-	void RefuelIfNeeded(AAirMoveType* myPlane);
+	void RefuelIfNeeded();
 
 	virtual void Execute();
 	virtual void ExecuteGuard(Command &amp;c);

Modified: trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -131,7 +131,7 @@
 			} else {
 				Command &amp; currentUnitCommand = unit-&gt;commandAI-&gt;commandQue[0];
 				if(currentUnitCommand.id == CMD_LOAD_ONTO &amp;&amp; currentUnitCommand.params.size() == 1 &amp;&amp; int(currentUnitCommand.params[0]) == owner-&gt;id){
-					if((unit-&gt;moveType-&gt;progressState == CMoveType::Failed) &amp;&amp; (owner-&gt;moveType-&gt;progressState == CMoveType::Failed)){
+					if((unit-&gt;moveType-&gt;progressState == AMoveType::Failed) &amp;&amp; (owner-&gt;moveType-&gt;progressState == AMoveType::Failed)){
 						unit-&gt;commandAI-&gt;FinishCommand();
 						FinishCommand();
 						return;

Modified: trunk/rts/Sim/Units/CommandAI/TransportCAI.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/TransportCAI.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/CommandAI/TransportCAI.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -9,6 +9,8 @@
 #define UNLOAD_LANDFLOOD 2
 #define UNLOAD_CRASHFLOOD 3
 
+class CTransportUnit;
+
 class CTransportCAI :
 	public CMobileCAI
 {

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-03-12 11:21:30 UTC (rev 5579)
@@ -777,7 +777,7 @@
 		}
 	}
 
-	if (moveType-&gt;progressState == CMoveType::Active) {
+	if (moveType-&gt;progressState == AMoveType::Active) {
 		if (seismicSignature) {
 			DoSeismicPing((int)seismicSignature);
 		}

Modified: trunk/rts/Sim/Units/Unit.h
===================================================================
--- trunk/rts/Sim/Units/Unit.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/Sim/Units/Unit.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -18,7 +18,7 @@
 class CGroup;
 class CLoadSaveInterface;
 class CMissileProjectile;
-class CMoveType;
+class AMoveType;
 class CUnitAI;
 class CWeapon;
 struct DamageArray;
@@ -232,8 +232,8 @@
 	int2 oldRadarPos;
 	bool stealth;
 
-	CMoveType* moveType;
-	CMoveType* prevMoveType;
+	AMoveType* moveType;
+	AMoveType* prevMoveType;
 	bool usingScriptMoveType;
 
 	CCommandAI* commandAI;

Modified: trunk/rts/System/Object.h
===================================================================
--- trunk/rts/System/Object.h	2008-03-11 18:18:47 UTC (rev 5578)
+++ trunk/rts/System/Object.h	2008-03-12 11:21:30 UTC (rev 5579)
@@ -35,7 +35,7 @@
 	CObject* GetNext()     const { return next; }
 	CObject* GetPrevious() const { return prev; }
 	bool IsSynchronized()  const { return prev || next; }
-
+	
 	void DeleteDeathDependence(CObject* o);
 	void AddDeathDependence(CObject* o);
 	virtual void DependentDied(CObject* o);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000359.html">[Taspring-linux-commit] r5578 - in trunk/tools/springie/Springie: .	autohost
</A></li>
	<LI>Next message: <A HREF="000361.html">[Taspring-linux-commit] r5580 - trunk/rts/build/vstudio8
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#360">[ date ]</a>
              <a href="thread.html#360">[ thread ]</a>
              <a href="subject.html#360">[ subject ]</a>
              <a href="author.html#360">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
