<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5618 - in trunk/AI/Global/NTai/AI: .	NTai/Agents NTai/Core NTai/Engine NTai/Helpers	NTai/Helpers/Terrain NTai/Helpers/Units NTai/Tasks NTai/Units	NTai/Units/Behaviours
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5618%20-%20in%20trunk/AI/Global/NTai/AI%3A%20.%0A%09NTai/Agents%20NTai/Core%20NTai/Engine%20NTai/Helpers%0A%09NTai/Helpers/Terrain%20NTai/Helpers/Units%20NTai/Tasks%20NTai/Units%0A%09NTai/Units/Behaviours&In-Reply-To=%3C20080329015108.0E536464F%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000398.html">
   <LINK REL="Next"  HREF="000400.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5618 - in trunk/AI/Global/NTai/AI: .	NTai/Agents NTai/Core NTai/Engine NTai/Helpers	NTai/Helpers/Terrain NTai/Helpers/Units NTai/Tasks NTai/Units	NTai/Units/Behaviours</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5618%20-%20in%20trunk/AI/Global/NTai/AI%3A%20.%0A%09NTai/Agents%20NTai/Core%20NTai/Engine%20NTai/Helpers%0A%09NTai/Helpers/Terrain%20NTai/Helpers/Units%20NTai/Tasks%20NTai/Units%0A%09NTai/Units/Behaviours&In-Reply-To=%3C20080329015108.0E536464F%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5618 - in trunk/AI/Global/NTai/AI: .	NTai/Agents NTai/Core NTai/Engine NTai/Helpers	NTai/Helpers/Terrain NTai/Helpers/Units NTai/Tasks NTai/Units	NTai/Units/Behaviours">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Mar 29 02:51:07 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000398.html">[Taspring-linux-commit] r5617 - trunk/AI/Global/KAIK-0.13
</A></li>
        <LI>Next message: <A HREF="000400.html">[Taspring-linux-commit] r5619 - in trunk/AI/Global/NTai/AI: .	NTai/Core NTai/Helpers/Units NTai/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#399">[ date ]</a>
              <a href="thread.html#399">[ thread ]</a>
              <a href="subject.html#399">[ subject ]</a>
              <a href="author.html#399">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tnowell
Date: 2008-03-29 02:51:06 +0100 (Sat, 29 Mar 2008)
New Revision: 5618

Added:
   trunk/AI/Global/NTai/AI/NTai/Units/CConfigTaskManager.h
   trunk/AI/Global/NTai/AI/NTai/Units/ITaskManager.h
   trunk/AI/Global/NTai/AI/NTai/Units/ITaskManagerFactory.h
Modified:
   trunk/AI/Global/NTai/AI/AI.vcproj
   trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp
   trunk/AI/Global/NTai/AI/NTai/Core/CNTai.cpp
   trunk/AI/Global/NTai/AI/NTai/Core/CNTai.h
   trunk/AI/Global/NTai/AI/NTai/Core/Global.h
   trunk/AI/Global/NTai/AI/NTai/Core/IModule.cpp
   trunk/AI/Global/NTai/AI/NTai/Core/Interface.cpp
   trunk/AI/Global/NTai/AI/NTai/Core/include.h
   trunk/AI/Global/NTai/AI/NTai/Engine/COrderRouter.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/CConfigData.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/CEconomy.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Log.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/TdfParser.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/DTHandler.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/Map.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalHandler.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalMap.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/RadarHandler.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/Units/CUnitDefLoader.cpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/tdf_grammar.hpp
   trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp
   trunk/AI/Global/NTai/AI/NTai/Tasks/CConsoleTask.cpp
   trunk/AI/Global/NTai/AI/NTai/Tasks/CKeywordConstructionTask.cpp
   trunk/AI/Global/NTai/AI/NTai/Tasks/CUnitConstructionTask.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/AttackBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CDGunBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CKamikazeBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CMoveFailReclaimBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CRetreatBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CStaticDefenceBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/MetalMakerBehaviour.cpp
   trunk/AI/Global/NTai/AI/NTai/Units/CUnit.h
Log:
- removed using namespace ntai and put namespace ntai{} around all the implementations.
- added headers for two new interfaces for an upcoming refactor of how tasklists are loaded and kept track of.
- some formatting and comment cleanup

Modified: trunk/AI/Global/NTai/AI/AI.vcproj
===================================================================
--- trunk/AI/Global/NTai/AI/AI.vcproj	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/AI.vcproj	2008-03-29 01:51:06 UTC (rev 5618)
@@ -438,6 +438,10 @@
 				Name=&quot;units&quot;
 				&gt;
 				&lt;File
+					RelativePath=&quot;.\NTai\Units\CConfigTaskManager.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;.\NTai\Units\CUnit.h&quot;
 					&gt;
 				&lt;/File&gt;
@@ -449,6 +453,14 @@
 					RelativePath=&quot;.\NTai\Units\CUnitTypeData.h&quot;
 					&gt;
 				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;.\NTai\Units\ITaskManager.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;.\NTai\Units\ITaskManagerFactory.h&quot;
+					&gt;
+				&lt;/File&gt;
 				&lt;Filter
 					Name=&quot;behaviours&quot;
 					&gt;

Modified: trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Agents/CManufacturer.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -6,1700 +6,1707 @@
 
 // CManufacturer
 #include &quot;../Core/include.h&quot;
-map&lt;int,deque&lt;CBPlan* &gt;* &gt; alliedplans;
-uint plancounter=1;
 
 
-uint CManufacturer::getplans(){
-	return plancounter;
-}
+namespace ntai {
+	map&lt;int,deque&lt;CBPlan* &gt;* &gt; alliedplans;
+	uint plancounter=1;
 
-void CManufacturer::AddPlan(){
-	plancounter++;
-}
 
-void CManufacturer::RemovePlan(){
-	plancounter--;
-}
+	uint CManufacturer::getplans(){
+		return plancounter;
+	}
 
-float3 CManufacturer::GetBuildPos(int builder, const UnitDef* target, const UnitDef* builderdef, float3 unitpos){
-	NLOG(&quot;CManufacturer::GetBuildPos&quot;);
-	// Find the least congested sector
-	// skew the new position around the centre of the sector
-	// issue a new call to closestbuildsite()
-	// push the unitpos out so that the commander does not try to build on top of itself leading to stall (especially important for something like nanoblobz)
-	if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
-		G-&gt;L.print(&quot;CManufacturer::GetBuildPos bad position&quot;);
-		return unitpos;
+	void CManufacturer::AddPlan(){
+		plancounter++;
 	}
-	if(!ValidUnitID(builder)) return unitpos;
-	if (target == 0) return unitpos;
-	if (builderdef == 0) return unitpos;
 
-	float3 epos = unitpos;
-	epos.z -= min(max(float(builderdef-&gt;ysize*8+target-&gt;ysize*10),float(builderdef-&gt;xsize*8+target-&gt;xsize*10)),builderdef-&gt;buildDistance*0.7f);
-	//epos.z -= target-&gt;buildDistance*0.6f;
-	float angle = float(G-&gt;mrand()%320);
-	unitpos = G-&gt;Map-&gt;Rotate(epos,angle,unitpos);
-	// move the new position if it's off map
-	if(unitpos.x &gt; G-&gt;cb-&gt;GetMapWidth() * SQUARE_SIZE){
-		unitpos.x = (G-&gt;cb-&gt;GetMapWidth() * SQUARE_SIZE)-(unitpos.x-(G-&gt;cb-&gt;GetMapWidth() * SQUARE_SIZE));
-		unitpos.x -= 500;
+	void CManufacturer::RemovePlan(){
+		plancounter--;
 	}
-	if(unitpos.z &gt; G-&gt;cb-&gt;GetMapHeight() * SQUARE_SIZE){
-		unitpos.z = (G-&gt;cb-&gt;GetMapHeight() * SQUARE_SIZE)-(unitpos.z-(G-&gt;cb-&gt;GetMapHeight() * SQUARE_SIZE));
-		unitpos.z -= 500;
+
+	float3 CManufacturer::GetBuildPos(int builder, const UnitDef* target, const UnitDef* builderdef, float3 unitpos){
+		NLOG(&quot;CManufacturer::GetBuildPos&quot;);
+		// Find the least congested sector
+		// skew the new position around the centre of the sector
+		// issue a new call to closestbuildsite()
+		// push the unitpos out so that the commander does not try to build on top of itself leading to stall (especially important for something like nanoblobz)
+		if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
+			G-&gt;L.print(&quot;CManufacturer::GetBuildPos bad position&quot;);
+			return unitpos;
+		}
+
+		if(!ValidUnitID(builder)) return unitpos;
+		if (target == 0) return unitpos;
+		if (builderdef == 0) return unitpos;
+
+		float3 epos = unitpos;
+		epos.z -= min(max(float(builderdef-&gt;ysize*8+target-&gt;ysize*10),float(builderdef-&gt;xsize*8+target-&gt;xsize*10)),builderdef-&gt;buildDistance*0.7f);
+		//epos.z -= target-&gt;buildDistance*0.6f;
+		float angle = float(G-&gt;mrand()%320);
+		unitpos = G-&gt;Map-&gt;Rotate(epos,angle,unitpos);
+
+		// move the new position if it's off map
+		if(unitpos.x &gt; G-&gt;cb-&gt;GetMapWidth() * SQUARE_SIZE){
+			unitpos.x = (G-&gt;cb-&gt;GetMapWidth() * SQUARE_SIZE)-(unitpos.x-(G-&gt;cb-&gt;GetMapWidth() * SQUARE_SIZE));
+			unitpos.x -= 500;
+		}
+		if(unitpos.z &gt; G-&gt;cb-&gt;GetMapHeight() * SQUARE_SIZE){
+			unitpos.z = (G-&gt;cb-&gt;GetMapHeight() * SQUARE_SIZE)-(unitpos.z-(G-&gt;cb-&gt;GetMapHeight() * SQUARE_SIZE));
+			unitpos.z -= 500;
+		}
+		if(unitpos.x &lt; 0){
+			unitpos.x *= (-1);
+			unitpos.x += 500;
+		}
+		if(unitpos.z &lt;0){
+			unitpos.z *= (-1);
+			unitpos.z += 500;
+		}
+
+		int wc = G-&gt;Map-&gt;WhichCorner(unitpos);
+		if(wc == t_NE){
+			unitpos.z += 40;
+			unitpos.x -= 40;
+		}
+		if(wc == t_NW){
+			unitpos.z += 40;
+			unitpos.x += 40;
+		}
+		if(wc == t_SE){
+			unitpos.z -= 40;
+			unitpos.x -= 40;
+		}
+		if(wc == t_SW){
+			unitpos.z -= 40;
+			unitpos.x += 40;
+		}
+		return unitpos;
 	}
-	if(unitpos.x &lt; 0){
-		unitpos.x *= (-1);
-		unitpos.x += 500;
-	}
-	if(unitpos.z &lt;0){
-		unitpos.z *= (-1);
-		unitpos.z += 500;
-	}
-	int wc = G-&gt;Map-&gt;WhichCorner(unitpos);
-	if(wc == t_NE){
-		unitpos.z += 40;
-		unitpos.x -= 40;
-	}
-	if(wc == t_NW){
-		unitpos.z += 40;
-		unitpos.x += 40;
-	}
-	if(wc == t_SE){
-		unitpos.z -= 40;
-		unitpos.x -= 40;
-	}
-	if(wc == t_SW){
-		unitpos.z -= 40;
-		unitpos.x += 40;
-	}
-	return unitpos;
-}
 
-/*bool CManufacturer::TaskCycle(CBuilder* i){
-	NLOG(&quot;CManufacturer::TaskCycle&quot;);
-	if(i-&gt;tasks.empty()){
-		if(i-&gt;GetRepeat()){
-			//G-&gt;L.print(&quot;CManufacturer::TaskCycle, buildtreecomeptled and now being reloaded!&quot;);
-			if(!LoadTaskList(i)){
-				G-&gt;L.print(&quot;failed loading of task list for &quot; + i-&gt;GetUnitDef()-&gt;name);
+	/*bool CManufacturer::TaskCycle(CBuilder* i){
+		NLOG(&quot;CManufacturer::TaskCycle&quot;);
+		if(i-&gt;tasks.empty()){
+			if(i-&gt;GetRepeat()){
+				//G-&gt;L.print(&quot;CManufacturer::TaskCycle, buildtreecomeptled and now being reloaded!&quot;);
+				if(!LoadTaskList(i)){
+					G-&gt;L.print(&quot;failed loading of task list for &quot; + i-&gt;GetUnitDef()-&gt;name);
+					return false;
+				}
+			}else{
+				//G-&gt;L.print(&quot;CManufacturer::TaskCycle, cycle has no tasks!!!&quot;);
 				return false;
 			}
-		}else{
-			//G-&gt;L.print(&quot;CManufacturer::TaskCycle, cycle has no tasks!!!&quot;);
+		}
+		if(i-&gt;tasks.empty()){ // STILL EMPTY!!!
 			return false;
 		}
-	}
-	if(i-&gt;tasks.empty()){ // STILL EMPTY!!!
-		return false;
-	}
-	// ok first task
-	vector&lt; boost::shared_ptr&lt;ITask&gt; &gt;::iterator k = i-&gt;tasks.begin();
-	boost::shared_ptr&lt;ITask&gt; t = *k;
-	//G-&gt;L.print(&quot;CManufacturer::TaskCycle executing task :: &quot; + GetTaskName(t-&gt;type));
-	if(t-&gt;execute(i-&gt;GetID())==false){
-		//G-&gt;L.print(&quot;CManufacturer::TaskCycle Task returned false&quot;);
-		t-&gt;SetValid(false);
-		i-&gt;tasks.erase(k);
-		return false;
-	}else{
-		//G-&gt;L.print(&quot;CManufacturer::TaskCycle Task executed&quot;);
-		btype j = t-&gt;GetType();
+		// ok first task
+		vector&lt; boost::shared_ptr&lt;ITask&gt; &gt;::iterator k = i-&gt;tasks.begin();
+		boost::shared_ptr&lt;ITask&gt; t = *k;
+		//G-&gt;L.print(&quot;CManufacturer::TaskCycle executing task :: &quot; + GetTaskName(t-&gt;type));
+		if(t-&gt;execute(i-&gt;GetID())==false){
+			//G-&gt;L.print(&quot;CManufacturer::TaskCycle Task returned false&quot;);
+			t-&gt;SetValid(false);
+			i-&gt;tasks.erase(k);
+			return false;
+		}else{
+			//G-&gt;L.print(&quot;CManufacturer::TaskCycle Task executed&quot;);
+			btype j = t-&gt;GetType();
 
-		if(j == B_RULE_EXTREME_CARRY){
-			boost::shared_ptr&lt;ITask&gt; t2 = boost::shared_ptr&lt;ITask&gt;((ITask*)new Task(G, B_RULE_EXTREME_CARRY));
-			if(t2-&gt;IsValid()){
-				i-&gt;tasks.insert(i-&gt;tasks.begin(),t2);
+			if(j == B_RULE_EXTREME_CARRY){
+				boost::shared_ptr&lt;ITask&gt; t2 = boost::shared_ptr&lt;ITask&gt;((ITask*)new Task(G, B_RULE_EXTREME_CARRY));
+				if(t2-&gt;IsValid()){
+					i-&gt;tasks.insert(i-&gt;tasks.begin(),t2);
+				}
 			}
-		}
-		if(j == B_GUARDIAN){
-			boost::shared_ptr&lt;ITask&gt; t2 = boost::shared_ptr&lt;ITask&gt;((ITask*)new Task(G, B_GUARDIAN));
-			//
-			if(t2-&gt;IsValid()){
-				i-&gt;tasks.insert(i-&gt;tasks.begin(),t2);
+			if(j == B_GUARDIAN){
+				boost::shared_ptr&lt;ITask&gt; t2 = boost::shared_ptr&lt;ITask&gt;((ITask*)new Task(G, B_GUARDIAN));
+				//
+				if(t2-&gt;IsValid()){
+					i-&gt;tasks.insert(i-&gt;tasks.begin(),t2);
+				}
 			}
+			i-&gt;tasks.erase(k);
+			return true;
 		}
-		i-&gt;tasks.erase(k);
-		return true;
+	}*/
+	/*creg::Class *UnitDef::GetClass(void){
+		return NULL;
 	}
-}*/
-/*creg::Class *UnitDef::GetClass(void){
-	return NULL;
-}
-UnitDef::~UnitDef(void){
-	//
-}*/
+	UnitDef::~UnitDef(void){
+		//
+	}*/
 
-/*float3 CManufacturer::GetBuildPlacement(int unit,float3 unitpos,const UnitDef* builder, const UnitDef* ud, int spacing){
-	NLOG(&quot;CManufacturer::GetBuildPlacement&quot;);
-	//if(G-&gt;UnitDefHelper-&gt;IsFactory(builder)){
-	//	return unitpos;
-	//}
-	float3 pos = unitpos;
-	//if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
-    //    unitpos.z+= 100;
-	//}
-	if(ud-&gt;type == string(&quot;MetalExtractor&quot;)){
-		pos = G-&gt;M-&gt;getNearestPatch(unitpos,0.7f,ud-&gt;extractsMetal,ud);
-		if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
-			//G-&gt;L.print(&quot;zero mex co-ordinates intercepted&quot;);
-			return UpVector;
-		}
-		int* iunits = new int[10000];
-		int itemp = G-&gt;GetEnemyUnits(iunits,pos,(float)max(ud-&gt;ysize,ud-&gt;xsize)*8);
-		delete [] iunits;
-		if(itemp&gt;0){
-			return UpVector;
-		}
-		if(!BPlans-&gt;empty()){
-			// find any plans for mexes very close to here.... If so change position to match if the same, if its a better mex then cancel existing plan and continue as normal.
-			for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-				//
-				if(G-&gt;UnitDefHelper-&gt;IsMex(i-&gt;ud)){
-					if(i-&gt;pos.distance2D(pos) &lt; (i-&gt;ud-&gt;extractRange+ud-&gt;extractRange)*0.75f){
-						if(i-&gt;ud-&gt;extractsMetal &gt; ud-&gt;extractsMetal){
-							//
-							if(!i-&gt;started){
-								if(i-&gt;builders.empty()==false){
-									for(set&lt;int&gt;::iterator j = i-&gt;builders.begin(); j != i-&gt;builders.end(); ++j){
-										G-&gt;Actions-&gt;ScheduleIdle(*j);
-										WipePlansForBuilder(*j);
+	/*float3 CManufacturer::GetBuildPlacement(int unit,float3 unitpos,const UnitDef* builder, const UnitDef* ud, int spacing){
+		NLOG(&quot;CManufacturer::GetBuildPlacement&quot;);
+		//if(G-&gt;UnitDefHelper-&gt;IsFactory(builder)){
+		//	return unitpos;
+		//}
+		float3 pos = unitpos;
+		//if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
+		//    unitpos.z+= 100;
+		//}
+		if(ud-&gt;type == string(&quot;MetalExtractor&quot;)){
+			pos = G-&gt;M-&gt;getNearestPatch(unitpos,0.7f,ud-&gt;extractsMetal,ud);
+			if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
+				//G-&gt;L.print(&quot;zero mex co-ordinates intercepted&quot;);
+				return UpVector;
+			}
+			int* iunits = new int[10000];
+			int itemp = G-&gt;GetEnemyUnits(iunits,pos,(float)max(ud-&gt;ysize,ud-&gt;xsize)*8);
+			delete [] iunits;
+			if(itemp&gt;0){
+				return UpVector;
+			}
+			if(!BPlans-&gt;empty()){
+				// find any plans for mexes very close to here.... If so change position to match if the same, if its a better mex then cancel existing plan and continue as normal.
+				for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+					//
+					if(G-&gt;UnitDefHelper-&gt;IsMex(i-&gt;ud)){
+						if(i-&gt;pos.distance2D(pos) &lt; (i-&gt;ud-&gt;extractRange+ud-&gt;extractRange)*0.75f){
+							if(i-&gt;ud-&gt;extractsMetal &gt; ud-&gt;extractsMetal){
+								//
+								if(!i-&gt;started){
+									if(i-&gt;builders.empty()==false){
+										for(set&lt;int&gt;::iterator j = i-&gt;builders.begin(); j != i-&gt;builders.end(); ++j){
+											G-&gt;Actions-&gt;ScheduleIdle(*j);
+											WipePlansForBuilder(*j);
+										}
+										i-&gt;builders.erase(i-&gt;builders.begin(),i-&gt;builders.end());
+										i-&gt;builders.clear();
 									}
-									i-&gt;builders.erase(i-&gt;builders.begin(),i-&gt;builders.end());
-									i-&gt;builders.clear();
+									BPlans-&gt;erase(i);
+									return pos;
+								}else{
+									return UpVector;
 								}
-								BPlans-&gt;erase(i);
-								return pos;
 							}else{
+								if(i-&gt;started){
+									G-&gt;Actions-&gt;Repair(unit,i-&gt;subject);
+									i-&gt;builders.insert(unit);
+								}
 								return UpVector;
 							}
-						}else{
-							if(i-&gt;started){
-								G-&gt;Actions-&gt;Repair(unit,i-&gt;subject);
-								i-&gt;builders.insert(unit);
-							}
-							return UpVector;
 						}
 					}
 				}
 			}
-		}
-		return pos;
-	} else if(ud-&gt;isFeature==true){ // dragon teeth for dragon teeth rings
-		pos = G-&gt;DTHandler-&gt;GetDTBuildSite(unit);
-		if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
-			G-&gt;L.print(string(&quot;zero DT co-ordinates intercepted :: &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
-			return UpVector;
-		}
-		return pos;
-	} else if((ud-&gt;type == string(&quot;Building&quot;))&amp;&amp;(ud-&gt;builder == false)&amp;&amp;(ud-&gt;weapons.empty() == true)&amp;&amp;(ud-&gt;radarRadius &gt; 100)){ // Radar!
-		//pos = G-&gt;DTHandler-&gt;GetDTBuildSite(unit);
-		if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
-			pos = G-&gt;RadarHandler-&gt;NextSite(unit,ud,(int)builder-&gt;buildDistance);
+			return pos;
+		} else if(ud-&gt;isFeature==true){ // dragon teeth for dragon teeth rings
+			pos = G-&gt;DTHandler-&gt;GetDTBuildSite(unit);
+			if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
+				G-&gt;L.print(string(&quot;zero DT co-ordinates intercepted :: &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
+				return UpVector;
+			}
+			return pos;
+		} else if((ud-&gt;type == string(&quot;Building&quot;))&amp;&amp;(ud-&gt;builder == false)&amp;&amp;(ud-&gt;weapons.empty() == true)&amp;&amp;(ud-&gt;radarRadius &gt; 100)){ // Radar!
+			//pos = G-&gt;DTHandler-&gt;GetDTBuildSite(unit);
+			if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
+				pos = G-&gt;RadarHandler-&gt;NextSite(unit,ud,(int)builder-&gt;buildDistance);
+			}else{
+				pos = G-&gt;RadarHandler-&gt;NextSite(unit,ud,1200);
+			}
+			if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
+				G-&gt;L.print(string(&quot;zero radar placement co-ordinates intercepted  :: &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
+				return UpVector;
+			}
+			return pos;
 		}else{
-			pos = G-&gt;RadarHandler-&gt;NextSite(unit,ud,1200);
-		}
-		if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
-			G-&gt;L.print(string(&quot;zero radar placement co-ordinates intercepted  :: &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
-			return UpVector;
-		}
-		return pos;
-	}else{
-		/**if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
-			pos = GetBuildPos(unit,ud,builder,pos);
-		}**/
-		//UnitDef* uj = new UnitDef();
-		//*uj = *ud;
-		//uj-&gt;xsize = ud-&gt;xsize + (spacing*2); // add the spacing for either side
-		//uj-&gt;ysize = ud-&gt;ysize + (spacing*2);
-		/*if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
-			pos = G-&gt;cb-&gt;ClosestBuildSite(ud,unitpos,builder-&gt;buildDistance-5,spacing);
-		}else{
-			pos = G-&gt;cb-&gt;ClosestBuildSite(ud,unitpos,max(builder-&gt;buildDistance,400.0f)+1000.0f,spacing);
-		}*/
-		/*pos = G-&gt;BuildingPlacer-&gt;GetBuildPos(unitpos,builder,ud,(float)spacing);
-		//pos = G-&gt;cb-&gt;ClosestBuildSite(ud,unitpos,2000,spacing);
-		//pos = G-&gt;Map-&gt;ClosestBuildSite(ud,pos,float((4000+(G-&gt;cb-&gt;GetCurrentFrame()%940))),spacing);
-		if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
-			//pos = GetBuildPos(unit,ud,unitpos);
-			/*if(G-&gt;UnitDefHelper-&gt;IsHub(builder)==false){
-			    pos = G-&gt;cb-&gt;ClosestBuildSite(ud,pos,max(builder-&gt;buildDistance,400.0f)+2000.0f,spacing);
-            }
+			/**if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
+				pos = GetBuildPos(unit,ud,builder,pos);
+			}**/
+			//UnitDef* uj = new UnitDef();
+			//*uj = *ud;
+			//uj-&gt;xsize = ud-&gt;xsize + (spacing*2); // add the spacing for either side
+			//uj-&gt;ysize = ud-&gt;ysize + (spacing*2);
+			/*if(G-&gt;UnitDefHelper-&gt;IsHub(builder)){
+				pos = G-&gt;cb-&gt;ClosestBuildSite(ud,unitpos,builder-&gt;buildDistance-5,spacing);
+			}else{
+				pos = G-&gt;cb-&gt;ClosestBuildSite(ud,unitpos,max(builder-&gt;buildDistance,400.0f)+1000.0f,spacing);
+			}*/
+			/*pos = G-&gt;BuildingPlacer-&gt;GetBuildPos(unitpos,builder,ud,(float)spacing);
+			//pos = G-&gt;cb-&gt;ClosestBuildSite(ud,unitpos,2000,spacing);
+			//pos = G-&gt;Map-&gt;ClosestBuildSite(ud,pos,float((4000+(G-&gt;cb-&gt;GetCurrentFrame()%940))),spacing);
+			if(G-&gt;Map-&gt;CheckFloat3(pos) == false){
+				//pos = GetBuildPos(unit,ud,unitpos);
+				/*if(G-&gt;UnitDefHelper-&gt;IsHub(builder)==false){
+					pos = G-&gt;cb-&gt;ClosestBuildSite(ud,pos,max(builder-&gt;buildDistance,400.0f)+2000.0f,spacing);
+				}
 
-			//pos = G-&gt;Map-&gt;ClosestBuildSite(ud,pos,9000.0f,spacing);
-			if(G-&gt;Map-&gt;CheckFloat3(pos) == false){*//*
-				G-&gt;L.print(string(&quot;bad vector returned for &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
-				return pos;
-			//}
-		}
-		//delete uj;
-		/*int* en = new int[100];
-        int e = G-&gt;cb-&gt;GetFriendlyUnits(en,pos,10.0f);
-        bool  badg = false;
-        if(e &gt;0){
-            const UnitDef* ed = G-&gt;GetUnitDef(en[0]);
-            if(ed != 0){
-                if(G-&gt;UnitDefHelper-&gt;IsMobile(ed)==false){
-                    badg =true;
-                }
-            }
-        }
-        delete [] en;
-        if(badg) return UpVector;*/
-		/*int* iunits = new int[10000];
-		int itemp = G-&gt;GetEnemyUnits(iunits,pos,(float)max(ud-&gt;ysize,ud-&gt;xsize)*8);
-		delete [] iunits;
-		if(itemp&gt;0){
-			G-&gt;L.print(string(&quot;discarding, enemy units found at  :: &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
-			return UpVector;
-		}
-		// Check single build plans.......
-		string lname = ud-&gt;name;
-		tolowercase(lname);
-		if(G-&gt;Cached-&gt;singlebuilds.find(lname) != G-&gt;Cached-&gt;singlebuilds.end()){
-			if(G-&gt;Cached-&gt;singlebuilds[lname]==false){
-				// check BPlans, and if we find a plan for this, go help build it....
-				if(!BPlans-&gt;empty()){
-					for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-						if(i-&gt;ud-&gt;name == ud-&gt;name){
-							if(i-&gt;started){
-								if(G-&gt;Actions-&gt;Repair(unit,i-&gt;subject)){
-									G-&gt;L.print(&quot;discarding, repairing nearby plan instead&quot;);
-									return UpVector;
+				//pos = G-&gt;Map-&gt;ClosestBuildSite(ud,pos,9000.0f,spacing);
+				if(G-&gt;Map-&gt;CheckFloat3(pos) == false){*//*
+					G-&gt;L.print(string(&quot;bad vector returned for &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
+					return pos;
+				//}
+			}
+			//delete uj;
+			/*int* en = new int[100];
+			int e = G-&gt;cb-&gt;GetFriendlyUnits(en,pos,10.0f);
+			bool  badg = false;
+			if(e &gt;0){
+				const UnitDef* ed = G-&gt;GetUnitDef(en[0]);
+				if(ed != 0){
+					if(G-&gt;UnitDefHelper-&gt;IsMobile(ed)==false){
+						badg =true;
+					}
+				}
+			}
+			delete [] en;
+			if(badg) return UpVector;*/
+			/*int* iunits = new int[10000];
+			int itemp = G-&gt;GetEnemyUnits(iunits,pos,(float)max(ud-&gt;ysize,ud-&gt;xsize)*8);
+			delete [] iunits;
+			if(itemp&gt;0){
+				G-&gt;L.print(string(&quot;discarding, enemy units found at  :: &quot;)+ to_string(pos.x) + string(&quot;,&quot;)+to_string(pos.y)+string(&quot;,&quot;)+to_string(pos.z));
+				return UpVector;
+			}
+			// Check single build plans.......
+			string lname = ud-&gt;name;
+			tolowercase(lname);
+			if(G-&gt;Cached-&gt;singlebuilds.find(lname) != G-&gt;Cached-&gt;singlebuilds.end()){
+				if(G-&gt;Cached-&gt;singlebuilds[lname]==false){
+					// check BPlans, and if we find a plan for this, go help build it....
+					if(!BPlans-&gt;empty()){
+						for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+							if(i-&gt;ud-&gt;name == ud-&gt;name){
+								if(i-&gt;started){
+									if(G-&gt;Actions-&gt;Repair(unit,i-&gt;subject)){
+										G-&gt;L.print(&quot;discarding, repairing nearby plan instead&quot;);
+										return UpVector;
+									}
+								}else{
+									return i-&gt;pos;
 								}
-							}else{
-								return i-&gt;pos;
 							}
 						}
 					}
 				}
 			}
-		}
-		// Check solo build plans.......
-		if(G-&gt;Cached-&gt;solobuilds.find(lname) == G-&gt;Cached-&gt;solobuilds.end()){
-			bool found = false;//tolowercase(ud-&gt;name)
-			if(G-&gt;Cached-&gt;solobuild.empty()==false){
-				for(vector&lt;string&gt;::iterator j = G-&gt;Cached-&gt;solobuild.begin(); j != G-&gt;Cached-&gt;solobuild.end(); ++j){
-					string j2 =*j;
-					tolowercase(j2);
-					if(j2==lname){
-						found=true;
-						break;
+			// Check solo build plans.......
+			if(G-&gt;Cached-&gt;solobuilds.find(lname) == G-&gt;Cached-&gt;solobuilds.end()){
+				bool found = false;//tolowercase(ud-&gt;name)
+				if(G-&gt;Cached-&gt;solobuild.empty()==false){
+					for(vector&lt;string&gt;::iterator j = G-&gt;Cached-&gt;solobuild.begin(); j != G-&gt;Cached-&gt;solobuild.end(); ++j){
+						string j2 =*j;
+						tolowercase(j2);
+						if(j2==lname){
+							found=true;
+							break;
+						}
 					}
 				}
-			}
-			if(found){
-				// check BPlans, and if we find a plan for this, go help build it....
-				if(!BPlans-&gt;empty()){
-					for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-						if(i-&gt;ud-&gt;name == ud-&gt;name){
-							if(i-&gt;started){
-								if(G-&gt;Actions-&gt;Repair(unit,i-&gt;subject)){
-									G-&gt;L.print(&quot;discarding, repairing nearby plan instead(2)&quot;);
-									return UpVector;
+				if(found){
+					// check BPlans, and if we find a plan for this, go help build it....
+					if(!BPlans-&gt;empty()){
+						for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+							if(i-&gt;ud-&gt;name == ud-&gt;name){
+								if(i-&gt;started){
+									if(G-&gt;Actions-&gt;Repair(unit,i-&gt;subject)){
+										G-&gt;L.print(&quot;discarding, repairing nearby plan instead(2)&quot;);
+										return UpVector;
+									}
+								}else{
+									return i-&gt;pos;
 								}
-							}else{
-								return i-&gt;pos;
 							}
 						}
 					}
 				}
 			}
-		}
-		string j = ud-&gt;name;
-		trim(j);
-		tolowercase(j);
-		float rmax = r_ranges[j];
-		if(rmax &gt; 10){
-			if(!BPlans-&gt;empty()){
-				for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-					if(i-&gt;ud-&gt;name == ud-&gt;name){
-						if(unitpos.distance2D(i-&gt;pos) &lt; rmax){
-							if(i-&gt;started){
-								if(G-&gt;Actions-&gt;Repair(unit,i-&gt;subject)){
-									G-&gt;L.print(&quot;discarding, repairing nearby plan instead(3)&quot;);
-									return UpVector;
+			string j = ud-&gt;name;
+			trim(j);
+			tolowercase(j);
+			float rmax = r_ranges[j];
+			if(rmax &gt; 10){
+				if(!BPlans-&gt;empty()){
+					for(deque&lt;CBPlan&gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+						if(i-&gt;ud-&gt;name == ud-&gt;name){
+							if(unitpos.distance2D(i-&gt;pos) &lt; rmax){
+								if(i-&gt;started){
+									if(G-&gt;Actions-&gt;Repair(unit,i-&gt;subject)){
+										G-&gt;L.print(&quot;discarding, repairing nearby plan instead(3)&quot;);
+										return UpVector;
+									}
+								}else{
+									return i-&gt;pos;
 								}
-							}else{
-								return i-&gt;pos;
 							}
 						}
 					}
 				}
 			}
-		}
-		if(OverlappingPlans(pos,ud) != BPlans-&gt;end()){
-			G-&gt;L.print(&quot;discarding, OverlappingPlans(pos,ud) != BPlans-&gt;end()&quot;);
-			return UpVector;
-		}
-		//
-		if((G-&gt;UnitDefHelper-&gt;IsFactory(builder)	&amp;&amp;(!G-&gt;UnitDefHelper-&gt;IsHub(builder))&amp;&amp;(G-&gt;UnitDefHelper-&gt;IsMobile(ud))) == false){
-			if(G-&gt;cb-&gt;CanBuildAt(ud,pos)==false){
-				G-&gt;L.print(&quot;bad result for CanBuildAt returned for &quot; + ud-&gt;name);
+			if(OverlappingPlans(pos,ud) != BPlans-&gt;end()){
+				G-&gt;L.print(&quot;discarding, OverlappingPlans(pos,ud) != BPlans-&gt;end()&quot;);
 				return UpVector;
 			}
+			//
+			if((G-&gt;UnitDefHelper-&gt;IsFactory(builder)	&amp;&amp;(!G-&gt;UnitDefHelper-&gt;IsHub(builder))&amp;&amp;(G-&gt;UnitDefHelper-&gt;IsMobile(ud))) == false){
+				if(G-&gt;cb-&gt;CanBuildAt(ud,pos)==false){
+					G-&gt;L.print(&quot;bad result for CanBuildAt returned for &quot; + ud-&gt;name);
+					return UpVector;
+				}
+			}
+
+			return pos;
 		}
-
 		return pos;
-	}
-	return pos;
-}*/
+	}*/
 
-deque&lt;CBPlan* &gt;::iterator CManufacturer::OverlappingPlans(float3 pos,const UnitDef* ud){
-	NLOG(&quot;CManufacturer::OverlappingPlans&quot;);
-	if(!BPlans-&gt;empty()){
-		for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-			if((*i)-&gt;utd-&gt;GetUnitDef()-&gt;name != ud-&gt;name){
-				if(pos.distance2D((*i)-&gt;pos) &lt; (*i)-&gt;radius+(max(ud-&gt;ysize,ud-&gt;xsize)*8)){
-					return i;
+	deque&lt;CBPlan* &gt;::iterator CManufacturer::OverlappingPlans(float3 pos,const UnitDef* ud){
+		NLOG(&quot;CManufacturer::OverlappingPlans&quot;);
+		if(!BPlans-&gt;empty()){
+			for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+				if((*i)-&gt;utd-&gt;GetUnitDef()-&gt;name != ud-&gt;name){
+					if(pos.distance2D((*i)-&gt;pos) &lt; (*i)-&gt;radius+(max(ud-&gt;ysize,ud-&gt;xsize)*8)){
+						return i;
+					}
 				}
 			}
 		}
+		return BPlans-&gt;end();
 	}
-	return BPlans-&gt;end();
-}
-/*
-bool CManufacturer::CBuild(string name, int unit, int spacing){
-	NLOG(&quot;CManufacturer::CBuild&quot;);
-	G-&gt;L.print(&quot;CBuild() :: &quot; + name);
-	const UnitDef* uda = G-&gt;GetUnitDef(unit);
-	const UnitDef* ud = G-&gt;GetUnitDef(name);
+	/*
+	bool CManufacturer::CBuild(string name, int unit, int spacing){
+		NLOG(&quot;CManufacturer::CBuild&quot;);
+		G-&gt;L.print(&quot;CBuild() :: &quot; + name);
+		const UnitDef* uda = G-&gt;GetUnitDef(unit);
+		const UnitDef* ud = G-&gt;GetUnitDef(name);
 
-	/////////////
+		/////////////
 
-	if(ud == 0){
-		G-&gt;L.print(&quot;Factor::CBuild(3) error: a problem occurred loading this units unit definition : &quot; + name);
-		return false;
-	} else if(uda == 0){
-		G-&gt;L.print(&quot;Factor::CBuild(3) error: a problem occurred loading uda &quot;);
-		return false;
-	}
-	if(G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false){ // Sort out the stuff that's setup to ALWAYS be under the antistall algorithm
-		NLOG(&quot;CManufacturer::CBuild G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false&quot;);
-		for(vector&lt;string&gt;::iterator i = G-&gt;Pl-&gt;AlwaysAntiStall.begin(); i != G-&gt;Pl-&gt;AlwaysAntiStall.end(); ++i){
-			if(*i == name){
-				NLOG(&quot;CManufacturer::CBuild *i == name :: &quot;+name);
-				if(G-&gt;Pl-&gt;feasable(ud,uda) == false){
-					G-&gt;L.print(&quot;Factor::CBuild  unfeasable &quot; + name);
-					return false;
-				}else{
-					NLOG(&quot;CManufacturer::CBuild  &quot;+name+&quot; is feasable&quot;);
-					break;
+		if(ud == 0){
+			G-&gt;L.print(&quot;Factor::CBuild(3) error: a problem occurred loading this units unit definition : &quot; + name);
+			return false;
+		} else if(uda == 0){
+			G-&gt;L.print(&quot;Factor::CBuild(3) error: a problem occurred loading uda &quot;);
+			return false;
+		}
+		if(G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false){ // Sort out the stuff that's setup to ALWAYS be under the antistall algorithm
+			NLOG(&quot;CManufacturer::CBuild G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false&quot;);
+			for(vector&lt;string&gt;::iterator i = G-&gt;Pl-&gt;AlwaysAntiStall.begin(); i != G-&gt;Pl-&gt;AlwaysAntiStall.end(); ++i){
+				if(*i == name){
+					NLOG(&quot;CManufacturer::CBuild *i == name :: &quot;+name);
+					if(G-&gt;Pl-&gt;feasable(ud,uda) == false){
+						G-&gt;L.print(&quot;Factor::CBuild  unfeasable &quot; + name);
+						return false;
+					}else{
+						NLOG(&quot;CManufacturer::CBuild  &quot;+name+&quot; is feasable&quot;);
+						break;
+					}
 				}
 			}
 		}
-	}
-	NLOG(&quot;CManufacturer::CBuild  Resource\\MaxEnergy\\&quot;);
-	float emax=1000000000;
-	string key = &quot;Resource\\MaxEnergy\\&quot;;
-	key += name;
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default
-	if(emax ==0) emax = 30000000;
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
-		G-&gt;L.print(&quot;Factor::CBuild  emax &quot; + name);
-		return false;
-	}
-	NLOG(&quot;CManufacturer::CBuild  Resource\\MinEnergy\\&quot;);
-	float emin=0;
-	key = &quot;Resource\\MinEnergy\\&quot;;
-	key += name;
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
-		G-&gt;L.print(&quot;Factor::CBuild  emin &quot; + name);
-		return false;
-	}
-	// Now sort out stuff that can only be built one at a time
-
-	if(G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()){
-		NLOG(&quot;CManufacturer::CBuild  G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()&quot;);
-		G-&gt;L.print(&quot;Factor::CBuild  solobuild &quot; + name);
-		return G-&gt;Actions-&gt;Repair(unit,G-&gt;Cached-&gt;solobuilds[name]);// One is already being built, change to a repair order to go help it!
-	}
-	// Now sort out if it's one of those things that can only be built once
-	if(G-&gt;Cached-&gt;singlebuilds.find(name) != G-&gt;Cached-&gt;singlebuilds.end()){
-		NLOG(&quot;CManufacturer::CBuild  G-&gt;Cached-&gt;singlebuilds.find(name) != G-&gt;Cached-&gt;singlebuilds.end()&quot;);
-		if(G-&gt;Cached-&gt;singlebuilds[name] == true){
-			G-&gt;L.print(&quot;Factor::CBuild  singlebuild &quot; + name);
+		NLOG(&quot;CManufacturer::CBuild  Resource\\MaxEnergy\\&quot;);
+		float emax=1000000000;
+		string key = &quot;Resource\\MaxEnergy\\&quot;;
+		key += name;
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default
+		if(emax ==0) emax = 30000000;
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
+			G-&gt;L.print(&quot;Factor::CBuild  emax &quot; + name);
 			return false;
 		}
-	}
-	//if(G-&gt;Pl-&gt;feasable(name,unit)==false){
-	//	return false;
-	//}
-	// If Antistall == 2/3 then we always do this
-
-	if(G-&gt;info-&gt;antistall&gt;1){
-		NLOG(&quot;CManufacturer::CBuild  G-&gt;info-&gt;antistall&gt;1&quot;);
-		bool fk = G-&gt;Pl-&gt;feasable(ud,uda);
-		NLOG(&quot;CManufacturer::CBuild  feasable called&quot;);
-		if(fk == false){
-			G-&gt;L.print(&quot;Factor::CBuild  unfeasable &quot; + name);
+		NLOG(&quot;CManufacturer::CBuild  Resource\\MinEnergy\\&quot;);
+		float emin=0;
+		key = &quot;Resource\\MinEnergy\\&quot;;
+		key += name;
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
+			G-&gt;L.print(&quot;Factor::CBuild  emin &quot; + name);
 			return false;
 		}
-	}
+		// Now sort out stuff that can only be built one at a time
 
-	NLOG(&quot;CManufacturer::CBuild  mark 1#&quot;);
+		if(G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()){
+			NLOG(&quot;CManufacturer::CBuild  G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()&quot;);
+			G-&gt;L.print(&quot;Factor::CBuild  solobuild &quot; + name);
+			return G-&gt;Actions-&gt;Repair(unit,G-&gt;Cached-&gt;solobuilds[name]);// One is already being built, change to a repair order to go help it!
+		}
+		// Now sort out if it's one of those things that can only be built once
+		if(G-&gt;Cached-&gt;singlebuilds.find(name) != G-&gt;Cached-&gt;singlebuilds.end()){
+			NLOG(&quot;CManufacturer::CBuild  G-&gt;Cached-&gt;singlebuilds.find(name) != G-&gt;Cached-&gt;singlebuilds.end()&quot;);
+			if(G-&gt;Cached-&gt;singlebuilds[name] == true){
+				G-&gt;L.print(&quot;Factor::CBuild  singlebuild &quot; + name);
+				return false;
+			}
+		}
+		//if(G-&gt;Pl-&gt;feasable(name,unit)==false){
+		//	return false;
+		//}
+		// If Antistall == 2/3 then we always do this
 
-	TCommand tc(unit,&quot;CBuild&quot;);
-	tc.ID(-ud-&gt;id);
-	NLOG(&quot;CManufacturer::CBuild  mark 2#&quot;);
-	float3 unitpos = G-&gt;GetUnitPos(unit);
-	float3 pos=unitpos;
-	if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
-		NLOG(&quot;CManufacturer::CBuild  mark 2# bad float exit&quot;);
-		return false;
-	}
-	string hj = name;
-	trim(hj);
-	tolowercase(hj);
-	float rmax = r_ranges[hj];
-	if(rmax &gt; 10){
-		NLOG(&quot;CManufacturer::CBuild  rmax &gt; 10&quot;);
-		int* funits = new int[10000];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,rmax);
-		if(fnum &gt; 1){
-			//
-			for(int i = 0; i &lt; fnum; i++){
-				const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
-				if(udf == 0) continue;
-				if(udf-&gt;name == name){
-					NLOG(&quot;CManufacturer::CBuild  mark 2b#&quot;);
-					if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; rmax){
-						if(G-&gt;cb-&gt;UnitBeingBuilt(funits[i])==true){
-							delete [] funits;
-							NLOG(&quot;CManufacturer::CBuild  exit on repair&quot;);
-							return G-&gt;Actions-&gt;Repair(unit,funits[i]);
+		if(G-&gt;info-&gt;antistall&gt;1){
+			NLOG(&quot;CManufacturer::CBuild  G-&gt;info-&gt;antistall&gt;1&quot;);
+			bool fk = G-&gt;Pl-&gt;feasable(ud,uda);
+			NLOG(&quot;CManufacturer::CBuild  feasable called&quot;);
+			if(fk == false){
+				G-&gt;L.print(&quot;Factor::CBuild  unfeasable &quot; + name);
+				return false;
+			}
+		}
+
+		NLOG(&quot;CManufacturer::CBuild  mark 1#&quot;);
+
+		TCommand tc(unit,&quot;CBuild&quot;);
+		tc.ID(-ud-&gt;id);
+		NLOG(&quot;CManufacturer::CBuild  mark 2#&quot;);
+		float3 unitpos = G-&gt;GetUnitPos(unit);
+		float3 pos=unitpos;
+		if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
+			NLOG(&quot;CManufacturer::CBuild  mark 2# bad float exit&quot;);
+			return false;
+		}
+		string hj = name;
+		trim(hj);
+		tolowercase(hj);
+		float rmax = r_ranges[hj];
+		if(rmax &gt; 10){
+			NLOG(&quot;CManufacturer::CBuild  rmax &gt; 10&quot;);
+			int* funits = new int[10000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,rmax);
+			if(fnum &gt; 1){
+				//
+				for(int i = 0; i &lt; fnum; i++){
+					const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
+					if(udf == 0) continue;
+					if(udf-&gt;name == name){
+						NLOG(&quot;CManufacturer::CBuild  mark 2b#&quot;);
+						if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; rmax){
+							if(G-&gt;cb-&gt;UnitBeingBuilt(funits[i])==true){
+								delete [] funits;
+								NLOG(&quot;CManufacturer::CBuild  exit on repair&quot;);
+								return G-&gt;Actions-&gt;Repair(unit,funits[i]);
+							}
 						}
 					}
 				}
 			}
+			delete [] funits;
 		}
-		delete [] funits;
-	}
-	NLOG(&quot;CManufacturer::CBuild  mark 3#&quot;);
-	////////
-	float exrange = exclusion_ranges[hj];
-	if(exrange &gt; 10){
-		int* funits = new int[10000];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,rmax);
-		if(fnum &gt; 1){
-			//
-			for(int i = 0; i &lt; fnum; i++){
-				const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
-				if(udf == 0) continue;
-				if(udf-&gt;name == name){
-					NLOG(&quot;CManufacturer::CBuild  mark 3a#&quot;);
-					if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; exrange){
-					    int kj = funits[i];
-					    delete [] funits;
-						if(G-&gt;cb-&gt;UnitBeingBuilt(kj)==true){
-							NLOG(&quot;CManufacturer::CBuild  exit on repair&quot;);
-							return G-&gt;Actions-&gt;Repair(unit,kj);
-						}else{
-							NLOG(&quot;CManufacturer::CBuild  return false&quot;);
-							return false;
+		NLOG(&quot;CManufacturer::CBuild  mark 3#&quot;);
+		////////
+		float exrange = exclusion_ranges[hj];
+		if(exrange &gt; 10){
+			int* funits = new int[10000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,rmax);
+			if(fnum &gt; 1){
+				//
+				for(int i = 0; i &lt; fnum; i++){
+					const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
+					if(udf == 0) continue;
+					if(udf-&gt;name == name){
+						NLOG(&quot;CManufacturer::CBuild  mark 3a#&quot;);
+						if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; exrange){
+							int kj = funits[i];
+							delete [] funits;
+							if(G-&gt;cb-&gt;UnitBeingBuilt(kj)==true){
+								NLOG(&quot;CManufacturer::CBuild  exit on repair&quot;);
+								return G-&gt;Actions-&gt;Repair(unit,kj);
+							}else{
+								NLOG(&quot;CManufacturer::CBuild  return false&quot;);
+								return false;
+							}
 						}
 					}
 				}
 			}
+			delete [] funits;
 		}
-		delete [] funits;
-	}
-	//if(ud-&gt;type != string(&quot;MetalExtractor&quot;)){
-	//	unitpos = GetBuildPos(unit,ud,unitpos);
-	//}
-	NLOG(&quot;CManufacturer::CBuild  mark 4#&quot;);
-//	pos = GetBuildPlacement(unit,unitpos,uda,ud,spacing);
-	//if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
-    if(pos==UpVector){
-		G-&gt;L.print(&quot;GetBuildPlacement returned UpVector or some other nasty position&quot;);
-		return false;
-	}
-	pos.y = G-&gt;cb-&gt;GetElevation(pos.x,pos.z);
-	deque&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud);
-	if(qi != BPlans-&gt;end()){
-		NLOG(&quot;vector&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud); :: WipePlansForBuilder&quot;);
-		if(qi-&gt;started){
-			G-&gt;L.print(&quot;::Cbuild overlapping plans issuing repair instead&quot;);
-			if(G-&gt;Actions-&gt;Repair(unit,qi-&gt;subject)){
-				WipePlansForBuilder(unit);
-				qi-&gt;builders.insert(unit);
+		//if(ud-&gt;type != string(&quot;MetalExtractor&quot;)){
+		//	unitpos = GetBuildPos(unit,ud,unitpos);
+		//}
+		NLOG(&quot;CManufacturer::CBuild  mark 4#&quot;);
+	//	pos = GetBuildPlacement(unit,unitpos,uda,ud,spacing);
+		//if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+		if(pos==UpVector){
+			G-&gt;L.print(&quot;GetBuildPlacement returned UpVector or some other nasty position&quot;);
+			return false;
+		}
+		pos.y = G-&gt;cb-&gt;GetElevation(pos.x,pos.z);
+		deque&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud);
+		if(qi != BPlans-&gt;end()){
+			NLOG(&quot;vector&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud); :: WipePlansForBuilder&quot;);
+			if(qi-&gt;started){
+				G-&gt;L.print(&quot;::Cbuild overlapping plans issuing repair instead&quot;);
+				if(G-&gt;Actions-&gt;Repair(unit,qi-&gt;subject)){
+					WipePlansForBuilder(unit);
+					qi-&gt;builders.insert(unit);
+					return false;
+				}
+			}else if (qi-&gt;ud == ud){
+				G-&gt;L.print(&quot;::Cbuild overlapping plans that're the same item but not started, moving pos to make it build quicker&quot;);
+				pos = qi-&gt;pos;
+			}else{
+				G-&gt;L.print(&quot;::Cbuild overlapping plans that are not the same item, no alternative action, cancelling task&quot;);
 				return false;
 			}
-		}else if (qi-&gt;ud == ud){
-			G-&gt;L.print(&quot;::Cbuild overlapping plans that're the same item but not started, moving pos to make it build quicker&quot;);
-			pos = qi-&gt;pos;
+		}
+		tc.PushFloat3(pos);
+		tc.Push(0);
+		tc.c.timeOut = int(ud-&gt;buildTime/5) + G-&gt;cb-&gt;GetCurrentFrame();
+		tc.created = G-&gt;cb-&gt;GetCurrentFrame();
+		tc.delay=0;
+		if(G-&gt;OrderRouter-&gt;GiveOrder(tc)== false){
+			G-&gt;L.print(&quot;Error::Cbuild Failed Order G-&gt;OrderRouter-&gt;GiveOrder(tc)== false:: &quot; + name);
+			return false;
 		}else{
-			G-&gt;L.print(&quot;::Cbuild overlapping plans that are not the same item, no alternative action, cancelling task&quot;);
-			return false;
+			// create a plan
+			G-&gt;L.print(&quot;Error::Cbuild G-&gt;OrderRouter-&gt;GiveOrder(tc)== true :: &quot; + name);
+			if(qi == BPlans-&gt;end()){
+				NLOG(&quot;CBuild :: WipePlansForBuilder&quot;);
+				G-&gt;L.print(&quot;Error::Cbuild wiping and creaiing the plan :: &quot; + name);
+				WipePlansForBuilder(unit);
+				CBPlan Bplan;
+				Bplan.started = false;
+				Bplan.builders.insert(unit);
+				Bplan.subject = -1;
+				Bplan.pos = pos;
+				Bplan.ud=ud;
+				plancounter++;
+				Bplan.id = plancounter;
+				Bplan.radius = (float)max(ud-&gt;xsize,ud-&gt;ysize)*8.0f;
+				Bplan.inFactory = G-&gt;UnitDefHelper-&gt;IsFactory(uda);
+				BPlans-&gt;push_back(Bplan);
+				G-&gt;BuildingPlacer-&gt;Block(pos,ud);
+				//G-&gt;BuildingPlacer-&gt;UnBlock(G-&gt;GetUnitPos(uid),ud);
+				//builders[unit].curplan = plancounter;
+				//builders[unit].doingplan = true;
+			}
+			return true;
 		}
 	}
-	tc.PushFloat3(pos);
-	tc.Push(0);
-	tc.c.timeOut = int(ud-&gt;buildTime/5) + G-&gt;cb-&gt;GetCurrentFrame();
-	tc.created = G-&gt;cb-&gt;GetCurrentFrame();
-	tc.delay=0;
-	if(G-&gt;OrderRouter-&gt;GiveOrder(tc)== false){
-		G-&gt;L.print(&quot;Error::Cbuild Failed Order G-&gt;OrderRouter-&gt;GiveOrder(tc)== false:: &quot; + name);
-		return false;
-	}else{
-		// create a plan
-		G-&gt;L.print(&quot;Error::Cbuild G-&gt;OrderRouter-&gt;GiveOrder(tc)== true :: &quot; + name);
-		if(qi == BPlans-&gt;end()){
-			NLOG(&quot;CBuild :: WipePlansForBuilder&quot;);
-			G-&gt;L.print(&quot;Error::Cbuild wiping and creaiing the plan :: &quot; + name);
-			WipePlansForBuilder(unit);
-			CBPlan Bplan;
-			Bplan.started = false;
-			Bplan.builders.insert(unit);
-			Bplan.subject = -1;
-			Bplan.pos = pos;
-			Bplan.ud=ud;
-			plancounter++;
-			Bplan.id = plancounter;
-			Bplan.radius = (float)max(ud-&gt;xsize,ud-&gt;ysize)*8.0f;
-			Bplan.inFactory = G-&gt;UnitDefHelper-&gt;IsFactory(uda);
-			BPlans-&gt;push_back(Bplan);
-			G-&gt;BuildingPlacer-&gt;Block(pos,ud);
-			//G-&gt;BuildingPlacer-&gt;UnBlock(G-&gt;GetUnitPos(uid),ud);
-			//builders[unit].curplan = plancounter;
-			//builders[unit].doingplan = true;
-		}
-		return true;
+	*/
+
+	CManufacturer::CManufacturer(Global* GL){
+		G = GL;
+		initialized = false;
+		valid = true;
+		//G-&gt;RegisterMessageHandler(&quot;update&quot;,this);
 	}
-}
-*/
 
-CManufacturer::CManufacturer(Global* GL){
-	G = GL;
-	initialized = false;
-	valid = true;
-	//G-&gt;RegisterMessageHandler(&quot;update&quot;,this);
-}
+	CManufacturer::~CManufacturer(){
+		G = 0;
+	}
 
-CManufacturer::~CManufacturer(){
-	G = 0;
-}
-
-void CManufacturer::RecieveMessage(CMessage &amp;message){
-	//G-&gt;L.iprint(&quot;RecievedMessage&quot;);
-	if(message.GetType() == string(&quot;update&quot;)){
-		Update();
-	}else if(message.GetType() == string(&quot;unitidle&quot;)){
-		//G-&gt;L.iprint(&quot;RecievedupdateMessage&quot;);
-		UnitIdle((int)message.GetParameter(0));
+	void CManufacturer::RecieveMessage(CMessage &amp;message){
+		//G-&gt;L.iprint(&quot;RecievedMessage&quot;);
+		if(message.GetType() == string(&quot;update&quot;)){
+			Update();
+		}else if(message.GetType() == string(&quot;unitidle&quot;)){
+			//G-&gt;L.iprint(&quot;RecievedupdateMessage&quot;);
+			UnitIdle((int)message.GetParameter(0));
+		}
 	}
-}
 
-bool CManufacturer::Init(){
-	NLOG(&quot;CManufacturer::Init&quot;);
-	NLOG(&quot;Loading MetaTags&quot;);
+	bool CManufacturer::Init(){
+		NLOG(&quot;CManufacturer::Init&quot;);
+		NLOG(&quot;Loading MetaTags&quot;);
 
-	BPlans = new deque&lt;CBPlan* &gt;();
+		BPlans = new deque&lt;CBPlan* &gt;();
 
-	NLOG(&quot;Registering TaskTypes&quot;);
-	RegisterTaskTypes();
+		NLOG(&quot;Registering TaskTypes&quot;);
+		RegisterTaskTypes();
 
 
-	initialized = true;
-	NLOG(&quot;Manufacturer Init Done&quot;);
-	return true;
+		initialized = true;
+		NLOG(&quot;Manufacturer Init Done&quot;);
+		return true;
 
-}
+	}
 
-void CManufacturer::UnitCreated(int uid){
-	NLOG(&quot;CManufacturer::UnitCreated&quot;);
-	// sort out the plans
-	if(BPlans-&gt;empty() == false){
-		//
-		float3 upos = G-&gt;GetUnitPos(uid);
-		if(upos != UpVector){
-			for(deque&lt;CBPlan* &gt;::iterator k = BPlans-&gt;begin(); k != BPlans-&gt;end();++k){
-				CBPlan* i = *k;
-				if(i-&gt;pos.distance2D(upos)&lt;i-&gt;radius*1.5f){
-					const UnitDef* ud = G-&gt;GetUnitDef(uid);
-					if(ud==i-&gt;utd-&gt;GetUnitDef()){
-						i-&gt;pos = upos;
-						i-&gt;subject = uid;
-						i-&gt;started = true;
-						break;
+	void CManufacturer::UnitCreated(int uid){
+		NLOG(&quot;CManufacturer::UnitCreated&quot;);
+		// sort out the plans
+		if(BPlans-&gt;empty() == false){
+			//
+			float3 upos = G-&gt;GetUnitPos(uid);
+			if(upos != UpVector){
+				for(deque&lt;CBPlan* &gt;::iterator k = BPlans-&gt;begin(); k != BPlans-&gt;end();++k){
+					CBPlan* i = *k;
+					if(i-&gt;pos.distance2D(upos)&lt;i-&gt;radius*1.5f){
+						const UnitDef* ud = G-&gt;GetUnitDef(uid);
+						if(ud==i-&gt;utd-&gt;GetUnitDef()){
+							i-&gt;pos = upos;
+							i-&gt;subject = uid;
+							i-&gt;started = true;
+							break;
+						}
 					}
 				}
 			}
 		}
+		G-&gt;RadarHandler-&gt;Change(uid,true);
 	}
-	G-&gt;RadarHandler-&gt;Change(uid,true);
-}
 
-void CManufacturer::UnitFinished(int uid){
-	NLOG(&quot;CManufacturer::UnitFinished&quot;);
-	if(initialized == false){
-		G-&gt;L.print(&quot;CManufacturer::UnitFinished Initialized == false&quot;);
-		return;
-	}
+	void CManufacturer::UnitFinished(int uid){
+		NLOG(&quot;CManufacturer::UnitFinished&quot;);
+		if(initialized == false){
+			G-&gt;L.print(&quot;CManufacturer::UnitFinished Initialized == false&quot;);
+			return;
+		}
 
-	if(BPlans-&gt;empty() == false){
-		for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-			if((*i)-&gt;subject == uid){
-				if(!(*i)-&gt;inFactory){
-					G-&gt;Actions-&gt;ScheduleIdle(uid);
+		if(BPlans-&gt;empty() == false){
+			for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+				if((*i)-&gt;subject == uid){
+					if(!(*i)-&gt;inFactory){
+						G-&gt;Actions-&gt;ScheduleIdle(uid);
+					}
+					delete (*i);
+					BPlans-&gt;erase(i);
+					break;
 				}
-				delete (*i);
-				BPlans-&gt;erase(i);
-				break;
 			}
 		}
-	}
-	// create a new CBuilder struct
-	/*CBuilder b(G,uid);
-	if(b.IsValid() == true){
-		const UnitDef* ud = b.GetUnitDef();
-		if(ud){
-			//
-			if(ud-&gt;builder == true){
-				bool setback = false;
-				b.SetRepeat(true);
-				if(G-&gt;UnitDefHelper-&gt;IsFactory(ud)){
-					b.SetRole(R_FACTORY); // Factory
-					setback = true;
-				}else if(G-&gt;UnitDefHelper-&gt;IsHub(ud)){
-					b.SetRole(R_BUILDER); // Hub
-					setback = true;
-				}else{
-					b.SetRole(R_BUILDER); // builder!
-					setback = true;
+		// create a new CBuilder struct
+		/*CBuilder b(G,uid);
+		if(b.IsValid() == true){
+			const UnitDef* ud = b.GetUnitDef();
+			if(ud){
+				//
+				if(ud-&gt;builder == true){
+					bool setback = false;
+					b.SetRepeat(true);
+					if(G-&gt;UnitDefHelper-&gt;IsFactory(ud)){
+						b.SetRole(R_FACTORY); // Factory
+						setback = true;
+					}else if(G-&gt;UnitDefHelper-&gt;IsHub(ud)){
+						b.SetRole(R_BUILDER); // Hub
+						setback = true;
+					}else{
+						b.SetRole(R_BUILDER); // builder!
+						setback = true;
+					}
+					G-&gt;L.print(&quot;CManufacturer::UnitFinished role set&quot;);
+					LoadTaskList(&amp;b);
+					G-&gt;L.print(&quot;CManufacturer::UnitFinished buildtree loaded&quot;);
+					builders[uid]=b;
+					G-&gt;L.print(&quot;CManufacturer::UnitFinished builder pushed back&quot;);
+					//	if (setback == true){
+					if(G-&gt;cb-&gt;GetCurrentFrame() &gt; 10) G-&gt;Actions-&gt;ScheduleIdle(uid);
+					//	}
 				}
-				G-&gt;L.print(&quot;CManufacturer::UnitFinished role set&quot;);
-				LoadTaskList(&amp;b);
-				G-&gt;L.print(&quot;CManufacturer::UnitFinished buildtree loaded&quot;);
-				builders[uid]=b;
-				G-&gt;L.print(&quot;CManufacturer::UnitFinished builder pushed back&quot;);
-				//	if (setback == true){
-				if(G-&gt;cb-&gt;GetCurrentFrame() &gt; 10) G-&gt;Actions-&gt;ScheduleIdle(uid);
-				//	}
 			}
-		}
-	}else{
-		G-&gt;L.print(&quot;cbuilder-&gt;valid() == false&quot;);
-	}*/
-}
+		}else{
+			G-&gt;L.print(&quot;cbuilder-&gt;valid() == false&quot;);
+		}*/
+	}
 
-CBPlan::CBPlan(){
-	//plan_mutex = new boost::mutex();
-	bcount = 0;
-}
+	CBPlan::CBPlan(){
+		//plan_mutex = new boost::mutex();
+		bcount = 0;
+	}
 
-CBPlan::~CBPlan(){
-	//delete plan_mutex;
-}
+	CBPlan::~CBPlan(){
+		//delete plan_mutex;
+	}
 
-void CBPlan::AddBuilder(int i){
-	//boost::mutex::scoped_lock lock(plan_mutex);
-	bcount++;
-}
+	void CBPlan::AddBuilder(int i){
+		//boost::mutex::scoped_lock lock(plan_mutex);
+		bcount++;
+	}
 
-bool CBPlan::HasBuilders(){
-	//boost::mutex::scoped_lock lock(plan_mutex);
-	return bcount &gt;0;
-}
+	bool CBPlan::HasBuilders(){
+		//boost::mutex::scoped_lock lock(plan_mutex);
+		return bcount &gt;0;
+	}
 
-void CBPlan::RemoveBuilder(int i){
-	//boost::mutex::scoped_lock lock(plan_mutex);
-	bcount--;
-}
+	void CBPlan::RemoveBuilder(int i){
+		//boost::mutex::scoped_lock lock(plan_mutex);
+		bcount--;
+	}
 
-void CBPlan::RemoveAllBuilders(){
-	//boost::mutex::scoped_lock lock(plan_mutex);
-	bcount = 0;
-}
+	void CBPlan::RemoveAllBuilders(){
+		//boost::mutex::scoped_lock lock(plan_mutex);
+		bcount = 0;
+	}
 
-int CBPlan::GetBuilderCount(){
-	//boost::mutex::scoped_lock lock(plan_mutex);
-	return bcount;
-}
+	int CBPlan::GetBuilderCount(){
+		//boost::mutex::scoped_lock lock(plan_mutex);
+		return bcount;
+	}
 
-void CManufacturer::UnitIdle(int uid){
-	NLOG(&quot;CManufacturer::UnitIdle&quot;);
-	if(!ValidUnitID(uid)) return;
-	//if(builders.empty() == false){
-		/*bool idle = false;
-		for(map&lt;int,CBuilder&gt;::iterator i = builders.begin(); i != builders.end(); ++i){
-			if(i-&gt;second.GetID() == uid){
-				/*if(G-&gt;Actions-&gt;DGunNearby(uid)==true){
-				idle = false;
-				break;
-				}*/
-				//G-&gt;L.print(&quot;CManufacturer::TaskCycle has found the unitID, issuing TaskCycle&quot;);
-				/*bool result = TaskCycle(&amp;i-&gt;second);
-				idle = (!result);
-				break;
+	void CManufacturer::UnitIdle(int uid){
+		NLOG(&quot;CManufacturer::UnitIdle&quot;);
+		if(!ValidUnitID(uid)) return;
+		//if(builders.empty() == false){
+			/*bool idle = false;
+			for(map&lt;int,CBuilder&gt;::iterator i = builders.begin(); i != builders.end(); ++i){
+				if(i-&gt;second.GetID() == uid){
+					/*if(G-&gt;Actions-&gt;DGunNearby(uid)==true){
+					idle = false;
+					break;
+					}*/
+					//G-&gt;L.print(&quot;CManufacturer::TaskCycle has found the unitID, issuing TaskCycle&quot;);
+					/*bool result = TaskCycle(&amp;i-&gt;second);
+					idle = (!result);
+					break;
+				}
 			}
-		}
-		if(idle){
-			G-&gt;Actions-&gt;ScheduleIdle(uid);
-		}
-		return;
-	}*/
-}
+			if(idle){
+				G-&gt;Actions-&gt;ScheduleIdle(uid);
+			}
+			return;
+		}*/
+	}
 
-void CManufacturer::UnitDestroyed(int uid){
-	NLOG(&quot;CManufacturer::UnitDestroyed&quot;);
-	//get rid of CBuilder, destroy plans needing this unit
-	if(BPlans-&gt;empty() == false){
-		for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-			if((*i)-&gt;subject == uid){
-				delete (*i);
-				BPlans-&gt;erase(i);
-				break;
+	void CManufacturer::UnitDestroyed(int uid){
+		NLOG(&quot;CManufacturer::UnitDestroyed&quot;);
+		//get rid of CBuilder, destroy plans needing this unit
+		if(BPlans-&gt;empty() == false){
+			for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+				if((*i)-&gt;subject == uid){
+					delete (*i);
+					BPlans-&gt;erase(i);
+					break;
+				}
 			}
 		}
+		//builders.erase(uid);
+		G-&gt;RadarHandler-&gt;Change(uid,false);
 	}
-	//builders.erase(uid);
-	G-&gt;RadarHandler-&gt;Change(uid,false);
-}
 
-void CManufacturer::Update(){
-	NLOG(&quot;CManufacturer::Update&quot;);
-	/*if(G-&gt;cb-&gt;GetCurrentFrame() == 30){ // kick start the commander and any other starting units
-		if(builders.empty() == false){
-			for(map&lt;int,CBuilder&gt;::iterator i = builders.begin();i != builders.end(); ++i){
-				UnitIdle(i-&gt;second.GetID());
+	void CManufacturer::Update(){
+		NLOG(&quot;CManufacturer::Update&quot;);
+		/*if(G-&gt;cb-&gt;GetCurrentFrame() == 30){ // kick start the commander and any other starting units
+			if(builders.empty() == false){
+				for(map&lt;int,CBuilder&gt;::iterator i = builders.begin();i != builders.end(); ++i){
+					UnitIdle(i-&gt;second.GetID());
+				}
 			}
-		}
-	}*/
+		}*/
 
 
-	if(!G-&gt;L.IsVerbose()==false){
-		return;
-	}
-	if EVERY_SECOND{
-		// iterate through all the plans and print out their positions and helping builders to verify that the plan system is actually working
-		// and keeping track of construction....
-		if(!BPlans-&gt;empty() &amp;&amp; G-&gt;L.IsVerbose()){
-			for(deque&lt;CBPlan* &gt;::iterator i =  BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-				if((*i)-&gt;HasBuilders()){
-					//for(set&lt;int&gt;::iterator j = i-&gt;builders.begin(); j != i-&gt;builders.end(); ++j){
-						float3 bpos = (*i)-&gt;pos;//G-&gt;GetUnitPos(*j);
-						float3 upos = bpos + float3(0,100,0);
-						int q = G-&gt;cb-&gt;CreateLineFigure(upos,(*i)-&gt;pos,15,1,30,0);
-						string s = &quot;GAME\\TEAM&quot; + to_string(G-&gt;Cached-&gt;team) + &quot;\\RGBColor&quot;;
-						//char ck[60];
-						//sprintf(ck,&quot;GAME\\TEAM%i\\RGBColor&quot;,G-&gt;Cached-&gt;team);
-						float3 r = G-&gt;L.startupscript-&gt;GetFloat3(ZeroVector,s.c_str());
-						G-&gt;cb-&gt;SetFigureColor(q,r.x,r.y,r.z,0.3f);
-						G-&gt;cb-&gt;DrawUnit((*i)-&gt;utd-&gt;GetUnitDef()-&gt;name.c_str(),(*i)-&gt;pos,0,30,G-&gt;Cached-&gt;team,true,true);
-						int w = (*i)-&gt;GetBuilderCount();
-						SkyWrite k(G-&gt;cb);
-						float3 jpos = (*i)-&gt;pos;
-						jpos.x+= (*i)-&gt;radius/2 +10;
-						string v = to_string(w)+&quot;::&quot;+to_string((*i)-&gt;started);
-						k.Write(v,jpos,15,10,30,r.x,r.y,r.z);
-					//}
+		if(!G-&gt;L.IsVerbose()==false){
+			return;
+		}
+		if EVERY_SECOND{
+			// iterate through all the plans and print out their positions and helping builders to verify that the plan system is actually working
+			// and keeping track of construction....
+			if(!BPlans-&gt;empty() &amp;&amp; G-&gt;L.IsVerbose()){
+				for(deque&lt;CBPlan* &gt;::iterator i =  BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+					if((*i)-&gt;HasBuilders()){
+						//for(set&lt;int&gt;::iterator j = i-&gt;builders.begin(); j != i-&gt;builders.end(); ++j){
+							float3 bpos = (*i)-&gt;pos;//G-&gt;GetUnitPos(*j);
+							float3 upos = bpos + float3(0,100,0);
+							int q = G-&gt;cb-&gt;CreateLineFigure(upos,(*i)-&gt;pos,15,1,30,0);
+							string s = &quot;GAME\\TEAM&quot; + to_string(G-&gt;Cached-&gt;team) + &quot;\\RGBColor&quot;;
+							//char ck[60];
+							//sprintf(ck,&quot;GAME\\TEAM%i\\RGBColor&quot;,G-&gt;Cached-&gt;team);
+							float3 r = G-&gt;L.startupscript-&gt;GetFloat3(ZeroVector,s.c_str());
+							G-&gt;cb-&gt;SetFigureColor(q,r.x,r.y,r.z,0.3f);
+							G-&gt;cb-&gt;DrawUnit((*i)-&gt;utd-&gt;GetUnitDef()-&gt;name.c_str(),(*i)-&gt;pos,0,30,G-&gt;Cached-&gt;team,true,true);
+							int w = (*i)-&gt;GetBuilderCount();
+							SkyWrite k(G-&gt;cb);
+							float3 jpos = (*i)-&gt;pos;
+							jpos.x+= (*i)-&gt;radius/2 +10;
+							string v = to_string(w)+&quot;::&quot;+to_string((*i)-&gt;started);
+							k.Write(v,jpos,15,10,30,r.x,r.y,r.z);
+						//}
+					}
 				}
 			}
 		}
-	}
 
 
-}
+	}
 
-//af CManufacturer::RegisterTaskPair
-void CManufacturer::RegisterTaskPair(string name, btype type){
-	types[name] = type;
-	typenames[type] = name;
-}
-
-void CManufacturer::RegisterTaskTypes(){
-	NLOG(&quot;CManufacturer::RegisterTaskTypes&quot;);
-	if(types.empty()){
-
-		RegisterTaskPair(&quot;b_metatag_failed&quot;, B_METAFAILED);
-		RegisterTaskPair(&quot;b_solar&quot;, B_POWER);
-		RegisterTaskPair(&quot;b_power&quot;,B_POWER);
-		RegisterTaskPair(&quot;b_mex&quot;, B_MEX);
-		RegisterTaskPair(&quot;b_rand_assault&quot;, B_RAND_ASSAULT);
-		RegisterTaskPair(&quot;b_assault&quot;, B_ASSAULT);
-		RegisterTaskPair(&quot;b_factory_cheap&quot;, B_FACTORY_CHEAP);
-		RegisterTaskPair(&quot;b_factory&quot;, B_FACTORY);
-		RegisterTaskPair(&quot;b_builder&quot;, B_BUILDER);
-		RegisterTaskPair(&quot;b_geo&quot;, B_GEO);
-		RegisterTaskPair(&quot;b_scout&quot;, B_SCOUT);
-		RegisterTaskPair(&quot;b_random&quot;, B_RANDOM);
-		RegisterTaskPair(&quot;b_defence&quot;, B_DEFENCE);
-		RegisterTaskPair(&quot;b_defense&quot;, B_DEFENCE);
-		RegisterTaskPair(&quot;b_radar&quot;, B_RADAR);
-		RegisterTaskPair(&quot;b_estore&quot;, B_ESTORE);
-		RegisterTaskPair(&quot;b_targ&quot;, B_TARG);
-		RegisterTaskPair(&quot;b_mstore&quot;, B_MSTORE);
-		RegisterTaskPair(&quot;b_silo&quot;, B_SILO);
-		RegisterTaskPair(&quot;b_jammer&quot;, B_JAMMER);
-		RegisterTaskPair(&quot;b_sonar&quot;, B_SONAR);
-		RegisterTaskPair(&quot;b_antimissile&quot;, B_ANTIMISSILE);
-		RegisterTaskPair(&quot;b_artillery&quot;, B_ARTILLERY);
-		RegisterTaskPair(&quot;b_focal_mine&quot;, B_FOCAL_MINE);
-		RegisterTaskPair(&quot;b_sub&quot;, B_SUB);
-		RegisterTaskPair(&quot;b_amphib&quot;, B_AMPHIB);
-		RegisterTaskPair(&quot;b_mine&quot;, B_MINE);
-		RegisterTaskPair(&quot;b_carrier&quot;, B_CARRIER);
-		RegisterTaskPair(&quot;b_metal_maker&quot;, B_METAL_MAKER);
-		RegisterTaskPair(&quot;b_fortification&quot;, B_FORTIFICATION);
-		RegisterTaskPair(&quot;b_dgun&quot;, B_DGUN);
-		RegisterTaskPair(&quot;b_repair&quot;, B_REPAIR);
-		RegisterTaskPair(&quot;repair&quot;, B_REPAIR);
-		RegisterTaskPair(&quot;reclaim&quot;, B_RECLAIM);
-		RegisterTaskPair(&quot;retreat&quot;, B_RETREAT);
-		RegisterTaskPair(&quot;b_idle&quot;, B_IDLE);
-		RegisterTaskPair(&quot;b_cmd&quot;, B_CMD);
-		RegisterTaskPair(&quot;b_randmove&quot;, B_RANDMOVE);
-		RegisterTaskPair(&quot;b_resurrect&quot;, B_RESURECT);
-		RegisterTaskPair(&quot;b_ressurect&quot;, B_RESURECT);
-		RegisterTaskPair(&quot;b_resurect&quot;, B_RESURECT);
-		RegisterTaskPair(&quot;b_global&quot;, B_RULE);
-		RegisterTaskPair(&quot;b_rule&quot;, B_RULE);
-		RegisterTaskPair(&quot;b_rule_extreme&quot;, B_RULE_EXTREME);
-		RegisterTaskPair(&quot;b_rule_extreme_nofact&quot;, B_RULE_EXTREME_NOFACT);
-		RegisterTaskPair(&quot;b_rule_extreme_carry&quot;, B_RULE_EXTREME_CARRY);
-		RegisterTaskPair(&quot;b_rule_carry&quot;, B_RULE_EXTREME_CARRY);
-		RegisterTaskPair(&quot;b_retreat&quot;, B_RETREAT);
-		RegisterTaskPair(&quot;b_guardian&quot;, B_GUARDIAN);
-		RegisterTaskPair(&quot;b_bomber&quot;, B_BOMBER);
-		RegisterTaskPair(&quot;b_gunship&quot;, B_GUNSHIP);
-		RegisterTaskPair(&quot;b_plasma_repulsor&quot;, B_SHIELD);
-		RegisterTaskPair(&quot;b_plasma_repulser&quot;, B_SHIELD);
-		RegisterTaskPair(&quot;b_shield&quot;, B_SHIELD);
-		RegisterTaskPair(&quot;b_missile_unit&quot;, B_MISSILE_UNIT);
-		RegisterTaskPair(&quot;b_na&quot;, B_NA);
-		RegisterTaskPair(&quot;b_fighter&quot;, B_FIGHTER);
-		RegisterTaskPair(&quot;b_guard_factory&quot;, B_GUARD_FACTORY);
-		RegisterTaskPair(&quot;b_guard_like_con&quot;, B_GUARD_LIKE_CON);
-		RegisterTaskPair(&quot;b_reclaim&quot;, B_RECLAIM);
-		RegisterTaskPair(&quot;b_wait&quot;, B_WAIT);
-		RegisterTaskPair(&quot;b_hub&quot;, B_HUB);
-		RegisterTaskPair(&quot;b_airsupport&quot;, B_AIRSUPPORT);
-		RegisterTaskPair(&quot;b_offensive_repair_retreat&quot;, B_OFFENSIVE_REPAIR_RETREAT);
-		RegisterTaskPair(&quot;b_guardian_mobiles&quot;, B_GUARDIAN_MOBILES);
+	//af CManufacturer::RegisterTaskPair
+	void CManufacturer::RegisterTaskPair(string name, btype type){
+		types[name] = type;
+		typenames[type] = name;
 	}
-}
 
-btype CManufacturer::GetTaskType(string s){
-	NLOG(&quot;CManufacturer::GetTaskType&quot;);
-	trim(s);
-	tolowercase(s);
+	void CManufacturer::RegisterTaskTypes(){
+		NLOG(&quot;CManufacturer::RegisterTaskTypes&quot;);
+		if(types.empty()){
 
-	if(types.empty()==false){
-		if(types.find(s) != types.end()){
-			return types[s];
+			RegisterTaskPair(&quot;b_metatag_failed&quot;, B_METAFAILED);
+			RegisterTaskPair(&quot;b_solar&quot;, B_POWER);
+			RegisterTaskPair(&quot;b_power&quot;,B_POWER);
+			RegisterTaskPair(&quot;b_mex&quot;, B_MEX);
+			RegisterTaskPair(&quot;b_rand_assault&quot;, B_RAND_ASSAULT);
+			RegisterTaskPair(&quot;b_assault&quot;, B_ASSAULT);
+			RegisterTaskPair(&quot;b_factory_cheap&quot;, B_FACTORY_CHEAP);
+			RegisterTaskPair(&quot;b_factory&quot;, B_FACTORY);
+			RegisterTaskPair(&quot;b_builder&quot;, B_BUILDER);
+			RegisterTaskPair(&quot;b_geo&quot;, B_GEO);
+			RegisterTaskPair(&quot;b_scout&quot;, B_SCOUT);
+			RegisterTaskPair(&quot;b_random&quot;, B_RANDOM);
+			RegisterTaskPair(&quot;b_defence&quot;, B_DEFENCE);
+			RegisterTaskPair(&quot;b_defense&quot;, B_DEFENCE);
+			RegisterTaskPair(&quot;b_radar&quot;, B_RADAR);
+			RegisterTaskPair(&quot;b_estore&quot;, B_ESTORE);
+			RegisterTaskPair(&quot;b_targ&quot;, B_TARG);
+			RegisterTaskPair(&quot;b_mstore&quot;, B_MSTORE);
+			RegisterTaskPair(&quot;b_silo&quot;, B_SILO);
+			RegisterTaskPair(&quot;b_jammer&quot;, B_JAMMER);
+			RegisterTaskPair(&quot;b_sonar&quot;, B_SONAR);
+			RegisterTaskPair(&quot;b_antimissile&quot;, B_ANTIMISSILE);
+			RegisterTaskPair(&quot;b_artillery&quot;, B_ARTILLERY);
+			RegisterTaskPair(&quot;b_focal_mine&quot;, B_FOCAL_MINE);
+			RegisterTaskPair(&quot;b_sub&quot;, B_SUB);
+			RegisterTaskPair(&quot;b_amphib&quot;, B_AMPHIB);
+			RegisterTaskPair(&quot;b_mine&quot;, B_MINE);
+			RegisterTaskPair(&quot;b_carrier&quot;, B_CARRIER);
+			RegisterTaskPair(&quot;b_metal_maker&quot;, B_METAL_MAKER);
+			RegisterTaskPair(&quot;b_fortification&quot;, B_FORTIFICATION);
+			RegisterTaskPair(&quot;b_dgun&quot;, B_DGUN);
+			RegisterTaskPair(&quot;b_repair&quot;, B_REPAIR);
+			RegisterTaskPair(&quot;repair&quot;, B_REPAIR);
+			RegisterTaskPair(&quot;reclaim&quot;, B_RECLAIM);
+			RegisterTaskPair(&quot;retreat&quot;, B_RETREAT);
+			RegisterTaskPair(&quot;b_idle&quot;, B_IDLE);
+			RegisterTaskPair(&quot;b_cmd&quot;, B_CMD);
+			RegisterTaskPair(&quot;b_randmove&quot;, B_RANDMOVE);
+			RegisterTaskPair(&quot;b_resurrect&quot;, B_RESURECT);
+			RegisterTaskPair(&quot;b_ressurect&quot;, B_RESURECT);
+			RegisterTaskPair(&quot;b_resurect&quot;, B_RESURECT);
+			RegisterTaskPair(&quot;b_global&quot;, B_RULE);
+			RegisterTaskPair(&quot;b_rule&quot;, B_RULE);
+			RegisterTaskPair(&quot;b_rule_extreme&quot;, B_RULE_EXTREME);
+			RegisterTaskPair(&quot;b_rule_extreme_nofact&quot;, B_RULE_EXTREME_NOFACT);
+			RegisterTaskPair(&quot;b_rule_extreme_carry&quot;, B_RULE_EXTREME_CARRY);
+			RegisterTaskPair(&quot;b_rule_carry&quot;, B_RULE_EXTREME_CARRY);
+			RegisterTaskPair(&quot;b_retreat&quot;, B_RETREAT);
+			RegisterTaskPair(&quot;b_guardian&quot;, B_GUARDIAN);
+			RegisterTaskPair(&quot;b_bomber&quot;, B_BOMBER);
+			RegisterTaskPair(&quot;b_gunship&quot;, B_GUNSHIP);
+			RegisterTaskPair(&quot;b_plasma_repulsor&quot;, B_SHIELD);
+			RegisterTaskPair(&quot;b_plasma_repulser&quot;, B_SHIELD);
+			RegisterTaskPair(&quot;b_shield&quot;, B_SHIELD);
+			RegisterTaskPair(&quot;b_missile_unit&quot;, B_MISSILE_UNIT);
+			RegisterTaskPair(&quot;b_na&quot;, B_NA);
+			RegisterTaskPair(&quot;b_fighter&quot;, B_FIGHTER);
+			RegisterTaskPair(&quot;b_guard_factory&quot;, B_GUARD_FACTORY);
+			RegisterTaskPair(&quot;b_guard_like_con&quot;, B_GUARD_LIKE_CON);
+			RegisterTaskPair(&quot;b_reclaim&quot;, B_RECLAIM);
+			RegisterTaskPair(&quot;b_wait&quot;, B_WAIT);
+			RegisterTaskPair(&quot;b_hub&quot;, B_HUB);
+			RegisterTaskPair(&quot;b_airsupport&quot;, B_AIRSUPPORT);
+			RegisterTaskPair(&quot;b_offensive_repair_retreat&quot;, B_OFFENSIVE_REPAIR_RETREAT);
+			RegisterTaskPair(&quot;b_guardian_mobiles&quot;, B_GUARDIAN_MOBILES);
 		}
 	}
-	return B_NA;
-}
 
-string CManufacturer::GetTaskName(btype type){
-	NLOG(&quot;CManufacturer::GetTaskName&quot;);
-	if(typenames.empty()==false){
-		if(typenames.find(type) != typenames.end()){
-			return typenames[type];
+	btype CManufacturer::GetTaskType(string s){
+		NLOG(&quot;CManufacturer::GetTaskType&quot;);
+		trim(s);
+		tolowercase(s);
+
+		if(types.empty()==false){
+			if(types.find(s) != types.end()){
+				return types[s];
+			}
 		}
+		return B_NA;
 	}
-	return &quot;&quot;;
-}
 
-bool CManufacturer::CanBuild(int uid, const UnitDef* ud, string name){
-	NLOG(&quot;CManufacturer::CanBuild&quot;);
-	string n = name;
-	tolowercase(n);
-	trim(n);
-	if(ud == 0){
-		G-&gt;L &lt;&lt;&quot;CManufacturer::CanBuild(&quot; &lt;&lt;uid &lt;&lt; &quot;,const UnitDef* ud,&quot; &lt;&lt;  name &lt;&lt; &quot;) gave false because ud == 0&quot; &lt;&lt; endline;
-		return false;
-	}
-	if(ud-&gt;buildOptions.empty()){
-		G-&gt;L &lt;&lt; &quot;CManufacturer::CanBuild(&quot; &lt;&lt;uid &lt;&lt; &quot;,const UnitDef* ud,&quot; &lt;&lt;  name &lt;&lt; &quot;) gave false because ud-&gt;buildOptions.empty() == true&quot; &lt;&lt; endline;
-		return false;
-	}else{
-		for(map&lt;int,string&gt;::const_iterator i = ud-&gt;buildOptions.begin(); i !=ud-&gt;buildOptions.end(); ++i){
-			string k = i-&gt;second;
-			tolowercase(k);
-			trim(k);
-			if(k==n){
-				return true;
+	string CManufacturer::GetTaskName(btype type){
+		NLOG(&quot;CManufacturer::GetTaskName&quot;);
+		if(typenames.empty()==false){
+			if(typenames.find(type) != typenames.end()){
+				return typenames[type];
 			}
 		}
-		return false;
+		return &quot;&quot;;
 	}
-}
 
-/*bool CManufacturer::LoadTaskList(CBuilder* ui){
-	NLOG(&quot;CManufacturer::LoadTaskList&quot;);
-	if((ui-&gt;GetUnitDef()-&gt;canfly ||ui-&gt;GetUnitDef()-&gt;movedata) &amp;&amp;  (ui-&gt;GetAge() &lt; (5 SECONDS))){
-		G-&gt;Actions-&gt;ScheduleIdle(ui-&gt;GetID());
-		return true;
-	}
-	const UnitDef* ud = ui-&gt;GetUnitDef();
-	G-&gt;L.print(&quot;loading buildtree for &quot;+ud-&gt;name);
-	// get the list of filenames
-	vector&lt;string&gt; vl;
-	string sl;
-	if(G-&gt;Cached-&gt;cheating){
-		sl= G-&gt;Get_mod_tdf()-&gt;SGetValueMSG(string(&quot;TASKLISTS\\CHEAT\\&quot;)+ud-&gt;name);
-	}else{
-		sl = G-&gt;Get_mod_tdf()-&gt;SGetValueMSG(string(&quot;TASKLISTS\\NORMAL\\&quot;)+ud-&gt;name);
-	}
-	tolowercase(sl);
-	trim(sl);
-	string u = ud-&gt;name;
-	if(sl != string(&quot;&quot;)){
-		vl = bds::set_cont(vl,sl.c_str());
-		if(vl.empty() == false){
-			int randnum = G-&gt;mrand()%vl.size();
-			u = vl.at(min(randnum,max(int(vl.size()-1),1)));
+	bool CManufacturer::CanBuild(int uid, const UnitDef* ud, string name){
+		NLOG(&quot;CManufacturer::CanBuild&quot;);
+		string n = name;
+		tolowercase(n);
+		trim(n);
+		if(ud == 0){
+			G-&gt;L &lt;&lt;&quot;CManufacturer::CanBuild(&quot; &lt;&lt;uid &lt;&lt; &quot;,const UnitDef* ud,&quot; &lt;&lt;  name &lt;&lt; &quot;) gave false because ud == 0&quot; &lt;&lt; endline;
+			return false;
 		}
+		if(ud-&gt;buildOptions.empty()){
+			G-&gt;L &lt;&lt; &quot;CManufacturer::CanBuild(&quot; &lt;&lt;uid &lt;&lt; &quot;,const UnitDef* ud,&quot; &lt;&lt;  name &lt;&lt; &quot;) gave false because ud-&gt;buildOptions.empty() == true&quot; &lt;&lt; endline;
+			return false;
+		}else{
+			for(map&lt;int,string&gt;::const_iterator i = ud-&gt;buildOptions.begin(); i !=ud-&gt;buildOptions.end(); ++i){
+				string k = i-&gt;second;
+				tolowercase(k);
+				trim(k);
+				if(k==n){
+					return true;
+				}
+			}
+			return false;
+		}
 	}
-	string s = G-&gt;Get_mod_tdf()-&gt;SGetValueMSG(string(&quot;TASKLISTS\\LISTS\\&quot;)+u);
-	vector&lt;string&gt; v;
-	//string s = *buffer;
-	if(s.empty() == true){
-		G-&gt;L.print(&quot; error loading tasklist :: &quot; + u + &quot; :: buffer empty, most likely because of an empty list&quot;);
-		return false;
-	}
 
-	tolowercase(s);
-	trim(s);
-	v = bds::set_cont(v,s.c_str());
-
-	if(v.empty() == false){
-		G-&gt;L.print(&quot;loading contents of  tasklist :: &quot; + u + &quot; :: filling tasklist with #&quot; + to_string(v.size()) + &quot; items&quot;);
-		bool polate=false;
-		bool polation = G-&gt;info-&gt;rule_extreme_interpolate;
-		btype bt = GetTaskType(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;b_rule_extreme_nofact&quot;,&quot;AI\\interpolate_tag&quot;));
-		if(ui-&gt;GetRole() == R_FACTORY){
-			polation = false;
+	/*bool CManufacturer::LoadTaskList(CBuilder* ui){
+		NLOG(&quot;CManufacturer::LoadTaskList&quot;);
+		if((ui-&gt;GetUnitDef()-&gt;canfly ||ui-&gt;GetUnitDef()-&gt;movedata) &amp;&amp;  (ui-&gt;GetAge() &lt; (5 SECONDS))){
+			G-&gt;Actions-&gt;ScheduleIdle(ui-&gt;GetID());
+			return true;
 		}
-		if(bt == B_NA){
-			polation = false;
+		const UnitDef* ud = ui-&gt;GetUnitDef();
+		G-&gt;L.print(&quot;loading buildtree for &quot;+ud-&gt;name);
+		// get the list of filenames
+		vector&lt;string&gt; vl;
+		string sl;
+		if(G-&gt;Cached-&gt;cheating){
+			sl= G-&gt;Get_mod_tdf()-&gt;SGetValueMSG(string(&quot;TASKLISTS\\CHEAT\\&quot;)+ud-&gt;name);
+		}else{
+			sl = G-&gt;Get_mod_tdf()-&gt;SGetValueMSG(string(&quot;TASKLISTS\\NORMAL\\&quot;)+ud-&gt;name);
 		}
-		for(vector&lt;string&gt;::iterator vi = v.begin(); vi != v.end(); ++vi){
-			if(polation==true){
-				if(polate==true){
-					ui-&gt;AddTask(bt);
-					polate = false;
-				}else{
-					polate=true;
-				}
+		tolowercase(sl);
+		trim(sl);
+		string u = ud-&gt;name;
+		if(sl != string(&quot;&quot;)){
+			vl = bds::set_cont(vl,sl.c_str());
+			if(vl.empty() == false){
+				int randnum = G-&gt;mrand()%vl.size();
+				u = vl.at(min(randnum,max(int(vl.size()-1),1)));
 			}
-			string q = *vi;
-			trim(q);
-			tolowercase(q);
-			if(metatags.empty() ==false){
-				if (metatags.find(q) != metatags.end()){
-					string s = &quot;&quot;;
-					s = GetBuild(ui-&gt;GetID(),q,true);
-					if((s != q)&amp;&amp;(s != string(&quot;&quot;))&amp;&amp;(s != string(&quot;b_metatag_failed&quot;))){
-						ui-&gt;AddTask(s,false);
+		}
+		string s = G-&gt;Get_mod_tdf()-&gt;SGetValueMSG(string(&quot;TASKLISTS\\LISTS\\&quot;)+u);
+		vector&lt;string&gt; v;
+		//string s = *buffer;
+		if(s.empty() == true){
+			G-&gt;L.print(&quot; error loading tasklist :: &quot; + u + &quot; :: buffer empty, most likely because of an empty list&quot;);
+			return false;
+		}
+
+		tolowercase(s);
+		trim(s);
+		v = bds::set_cont(v,s.c_str());
+
+		if(v.empty() == false){
+			G-&gt;L.print(&quot;loading contents of  tasklist :: &quot; + u + &quot; :: filling tasklist with #&quot; + to_string(v.size()) + &quot; items&quot;);
+			bool polate=false;
+			bool polation = G-&gt;info-&gt;rule_extreme_interpolate;
+			btype bt = GetTaskType(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;b_rule_extreme_nofact&quot;,&quot;AI\\interpolate_tag&quot;));
+			if(ui-&gt;GetRole() == R_FACTORY){
+				polation = false;
+			}
+			if(bt == B_NA){
+				polation = false;
+			}
+			for(vector&lt;string&gt;::iterator vi = v.begin(); vi != v.end(); ++vi){
+				if(polation==true){
+					if(polate==true){
+						ui-&gt;AddTask(bt);
+						polate = false;
 					}else{
-						G-&gt;L.print(&quot; error with metatag!!!!!!! ::  &quot;+ s + &quot; :: &quot; + *vi);
+						polate=true;
 					}
+				}
+				string q = *vi;
+				trim(q);
+				tolowercase(q);
+				if(metatags.empty() ==false){
+					if (metatags.find(q) != metatags.end()){
+						string s = &quot;&quot;;
+						s = GetBuild(ui-&gt;GetID(),q,true);
+						if((s != q)&amp;&amp;(s != string(&quot;&quot;))&amp;&amp;(s != string(&quot;b_metatag_failed&quot;))){
+							ui-&gt;AddTask(s,false);
+						}else{
+							G-&gt;L.print(&quot; error with metatag!!!!!!! ::  &quot;+ s + &quot; :: &quot; + *vi);
+						}
+						continue;
+					}
+				}
+				const UnitDef* uj = G-&gt;GetUnitDef(*vi);
+				if(uj != 0){
+					ui-&gt;AddTask(q,false);
+					if(v.size() == 1) ui-&gt;AddTask(q,false);
+				}else if(q == string(&quot;&quot;)){
 					continue;
+				} else if(q == string(&quot;is_factory&quot;)){
+					ui-&gt;SetRole(R_FACTORY);
+				} else if(q == string(&quot;is_builder&quot;)){
+					ui-&gt;SetRole(R_BUILDER);
+				} else if(q == string(&quot;repeat&quot;)){
+					ui-&gt;SetRepeat(true);
+				} else if(q == string(&quot;no_rule_interpolation&quot;)){
+					polation=false;
+				} else if(q == string(&quot;rule_interpolate&quot;)){
+					polation=true;
+				} else if(q == string(&quot;dont_repeat&quot;)){
+					ui-&gt;SetRepeat(false);
+				}else if(q == string(&quot;base_pos&quot;)){
+					G-&gt;Map-&gt;base_positions.push_back(G-&gt;GetUnitPos(ui-&gt;GetID()));
+				} else if(q == string(&quot;gaia&quot;)){
+					G-&gt;info-&gt;gaia = true;
+				} else if(q == string(&quot;not_gaia&quot;)){
+					G-&gt;info-&gt;gaia = false;
+				} else if(q == string(&quot;switch_gaia&quot;)){
+					G-&gt;info-&gt;gaia = !G-&gt;info-&gt;gaia;
+				} else{
+					btype x = GetTaskType(q);
+					if( x != B_NA){
+						ui-&gt;AddTask(x);
+					}else{
+						G-&gt;L.iprint(&quot;error :: a value :: &quot; + *vi +&quot; :: was parsed in :: &quot;+u + &quot; :: this does not have a valid UnitDef according to the engine, and is not a Task keyword such as repair or b_mex&quot;);
+					}
 				}
 			}
-			const UnitDef* uj = G-&gt;GetUnitDef(*vi);
-			if(uj != 0){
-				ui-&gt;AddTask(q,false);
-				if(v.size() == 1) ui-&gt;AddTask(q,false);
-			}else if(q == string(&quot;&quot;)){
-				continue;
-			} else if(q == string(&quot;is_factory&quot;)){
-				ui-&gt;SetRole(R_FACTORY);
-			} else if(q == string(&quot;is_builder&quot;)){
-				ui-&gt;SetRole(R_BUILDER);
-			} else if(q == string(&quot;repeat&quot;)){
-				ui-&gt;SetRepeat(true);
-			} else if(q == string(&quot;no_rule_interpolation&quot;)){
-				polation=false;
-			} else if(q == string(&quot;rule_interpolate&quot;)){
-				polation=true;
-			} else if(q == string(&quot;dont_repeat&quot;)){
-				ui-&gt;SetRepeat(false);
-			}else if(q == string(&quot;base_pos&quot;)){
-				G-&gt;Map-&gt;base_positions.push_back(G-&gt;GetUnitPos(ui-&gt;GetID()));
-			} else if(q == string(&quot;gaia&quot;)){
-				G-&gt;info-&gt;gaia = true;
-			} else if(q == string(&quot;not_gaia&quot;)){
-				G-&gt;info-&gt;gaia = false;
-			} else if(q == string(&quot;switch_gaia&quot;)){
-				G-&gt;info-&gt;gaia = !G-&gt;info-&gt;gaia;
-			} else{
-				btype x = GetTaskType(q);
-				if( x != B_NA){
-					ui-&gt;AddTask(x);
-				}else{
-					G-&gt;L.iprint(&quot;error :: a value :: &quot; + *vi +&quot; :: was parsed in :: &quot;+u + &quot; :: this does not have a valid UnitDef according to the engine, and is not a Task keyword such as repair or b_mex&quot;);
-				}
-			}
+			if(ud-&gt;isCommander == true)	G-&gt;Map-&gt;basepos = G-&gt;GetUnitPos(ui-&gt;GetID());
+			if((ud-&gt;isCommander== true)||(ui-&gt;GetRole() == R_FACTORY))	G-&gt;Map-&gt;base_positions.push_back(G-&gt;GetUnitPos(ui-&gt;GetID()));
+			G-&gt;L.print(&quot;loaded contents of  tasklist :: &quot; + u + &quot; :: loaded tasklist at &quot; + to_string(ui-&gt;tasks.size()) + &quot; items&quot;);
+			return true;
+			//G-&gt;Actions-&gt;ScheduleIdle(ui-&gt;GetID());
+		} else{
+			G-&gt;L.print(&quot; error loading contents of  tasklist :: &quot; + u + &quot; :: buffer empty, most likely because of an empty tasklist&quot;);
+			return false;
 		}
-		if(ud-&gt;isCommander == true)	G-&gt;Map-&gt;basepos = G-&gt;GetUnitPos(ui-&gt;GetID());
-		if((ud-&gt;isCommander== true)||(ui-&gt;GetRole() == R_FACTORY))	G-&gt;Map-&gt;base_positions.push_back(G-&gt;GetUnitPos(ui-&gt;GetID()));
-		G-&gt;L.print(&quot;loaded contents of  tasklist :: &quot; + u + &quot; :: loaded tasklist at &quot; + to_string(ui-&gt;tasks.size()) + &quot; items&quot;);
-		return true;
-		//G-&gt;Actions-&gt;ScheduleIdle(ui-&gt;GetID());
-	} else{
-		G-&gt;L.print(&quot; error loading contents of  tasklist :: &quot; + u + &quot; :: buffer empty, most likely because of an empty tasklist&quot;);
-		return false;
-	}
-}*/
+	}*/
 
-/*int CManufacturer::WhatIsUnitBuilding(int builder){
-	NLOG(&quot;WhatIsUnitBuilding&quot;);
-	if(builder &lt; 0) return -1;
-	if (BPlans-&gt;empty()) return -1;
+	/*int CManufacturer::WhatIsUnitBuilding(int builder){
+		NLOG(&quot;WhatIsUnitBuilding&quot;);
+		if(builder &lt; 0) return -1;
+		if (BPlans-&gt;empty()) return -1;
 
-	for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-		if((*i)-&gt;HasBuilder(builder)){
-			return (*i)-&gt;subject;
+		for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+			if((*i)-&gt;HasBuilder(builder)){
+				return (*i)-&gt;subject;
+			}
 		}
+		return -1;
 	}
-	return -1;
-}
 
-bool CManufacturer::UnitTargetStartedBuilding(int builder){
-	NLOG(&quot;UnitTargetStartedBuilding&quot;);
-	if(builder &lt; 0) return false;
-	if (BPlans-&gt;empty()) return false;
-	for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
-		if((*i)-&gt;HasBuilder(builder)){
-			return (*i)-&gt;started;
+	bool CManufacturer::UnitTargetStartedBuilding(int builder){
+		NLOG(&quot;UnitTargetStartedBuilding&quot;);
+		if(builder &lt; 0) return false;
+		if (BPlans-&gt;empty()) return false;
+		for(deque&lt;CBPlan* &gt;::iterator i = BPlans-&gt;begin(); i != BPlans-&gt;end(); ++i){
+			if((*i)-&gt;HasBuilder(builder)){
+				return (*i)-&gt;started;
+			}
 		}
+		return false;
+	}*/
+
+	SkyWrite::SkyWrite(IAICallback *_GS):
+	GS(_GS){
 	}
-	return false;
-}*/
-
-SkyWrite::SkyWrite(IAICallback *_GS):
-GS(_GS){
+	// TODO: HIKLMNOPQRSTUVWXYZ,/&amp;%!_-+=
+	SkyWrite::~SkyWrite(){
+	}
+	void SkyWrite::Write(string Text, float3 loc, float Height, float Width, int Duration, float Red, float Green, float Blue, float Alpha){
+		int Group = 0;
+		int bGroup = 0;
+		float pos = 0;
+		// loc = bottom, left hand corner
+		const char* c = Text.c_str();
+		for(int n=0; n &lt; (int)strlen(c); n++)
+			switch(Text[n])	{
+				case 'A':
+					{
+						// Upward, downward, center
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos + Width/2, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos + Width/2, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos + Width/2, loc.y, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y, loc.z),
+							3, 0, Duration, Group);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos + Width/2, loc.y-10, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y-10, loc.z),
+							5, 0, Duration, bGroup);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos + Width/4, loc.y, loc.z+Height/2),
+							float3(loc.x + pos + Width*3/4, loc.y, loc.z+Height/2),
+							3, 0, Duration, Group);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos + Width/4, loc.y-10, loc.z+Height/2),
+							float3(loc.x + pos + Width*3/4, loc.y-10, loc.z+Height/2),
+							5, 0, Duration, bGroup);
+						//
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						pos += Width * 0.7f;
+						break;
+					}
+				case 'B':
+					{
+						// Left Side, Top Bubble, Bottom Bubble
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos, loc.y+Height, loc.z),
+							float3(loc.x + pos + Width, loc.y, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y, loc.z+Height/2),
+							float3(loc.x + pos, loc.y, loc.z+Height/2),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos, loc.y, loc.z+Height/2),
+							float3(loc.x + pos + Width, loc.y, loc.z+Height/2),
+							float3(loc.x + pos + Width, loc.y, loc.z),
+							float3(loc.x + pos, loc.y, loc.z),
+							3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height/2),
+							float3(loc.x + pos, loc.y-10, loc.z+Height/2),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height/2),
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height/2),
+							float3(loc.x + pos + Width, loc.y-10, loc.z),
+							float3(loc.x + pos, loc.y-10, loc.z),
+							5, 0, Duration, bGroup);
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						pos += Width * 0.7f;
+						break;
+					}
+				case 'C':
+					{
+						Group = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos + Width, loc.y, loc.z+Height),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos + Width, loc.y, loc.z),
+							3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos + Width, loc.y-10, loc.z),
+							5, 0, Duration, bGroup);
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						pos += Width * 0.7f;
+						break;
+					}
+				case 'D':
+					{
+						// Left Side, Bubble
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos + Width, loc.y, loc.z),
+							float3(loc.x + pos + Width, loc.y, loc.z+Height),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos + Width, loc.y-10, loc.z),
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case 'E':
+					{
+						// Left, Top, Middle, Bottom
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z+Height/2),
+							float3(loc.x + pos + Width*3/4, loc.y, loc.z+Height/2),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos + Width, loc.y, loc.z),
+							3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height/2),
+							float3(loc.x + pos + Width*3/4, loc.y-10, loc.z+Height/2),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos + Width, loc.y-10, loc.z),
+							5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case 'F':
+					{
+						// Left, Top, Middle
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y, loc.z+Height),
+							3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z+Height/2),
+							float3(loc.x + pos + Width*3/4, loc.y, loc.z+Height/2),
+							3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
+							5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height/2),
+							float3(loc.x + pos + Width*3/4, loc.y-10, loc.z+Height/2),
+							5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case 'G':
+					{
+						Group = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos + Width, loc.y, loc.z+Height),
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y, loc.z),
+							float3(loc.x + pos + Width, loc.y , loc.z+ Height/2),
+							3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateSplineFigure(
+							float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							float3(loc.x + pos + Width, loc.y-10, loc.z),
+							float3(loc.x + pos + Width, loc.y-10 , loc.z+ Height/2),
+							5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case 'I':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y, loc.z+Height),
+							float3(loc.x + pos,loc.y, loc.z), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos, loc.y-10, loc.z+Height),
+							float3(loc.x + pos,loc.y-10, loc.z), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '1':
+					{
+						// Left, Top, Middle
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.5f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.5f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '2':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*1.0f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*1.0f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '3':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*1.0f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*1.0f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '4':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '5':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '6':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '7':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '8':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '9':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '0':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
+							float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case ':':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.4f)),
+							float3(loc.x + pos+(Width*0.5f),loc.y, loc.z+(Height*0.5f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.7f)),
+							float3(loc.x + pos+(Width*0.5f),loc.y, loc.z+(Height*0.8f)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.4f)),
+							float3(loc.x + pos+(Width*0.5f),loc.y-10, loc.z+(Height*0.5f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.7f)),
+							float3(loc.x + pos+(Width*0.5f),loc.y-10, loc.z+(Height*0.8f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '&#172;':// the lightning power symbol
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.8f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.8f), loc.y, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.6f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.6f), loc.y, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.2f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
+						//
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.8f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.8f), loc.y-10, loc.z+(Height*0.1f)),
+							float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.6f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.6f), loc.y-10, loc.z+(Height*0.6f)),
+							float3(loc.x + pos+(Width*0.2f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case '.':
+					{
+						Group = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.9f)),
+							float3(loc.x + pos+(Width*0.6f),loc.y, loc.z+(Height*0.9f)), 3, 0, Duration, Group);
+						bGroup = GS-&gt;CreateLineFigure(
+							float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.9f)),
+							float3(loc.x + pos+(Width*0.6f),loc.y-10, loc.z+(Height*0.9f)), 5, 0, Duration, bGroup);
+						pos += Width * 0.7f;
+						GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
+						GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
+						break;
+					}
+				case ' ':
+					{
+						pos += Width * 0.7f;
+						break;
+					}
+				default:
+					{
+						pos += Width * 0.7f;
+						break;
+					}
+			}
+	}
 }
-// TODO: HIKLMNOPQRSTUVWXYZ,/&amp;%!_-+=
-SkyWrite::~SkyWrite(){
-}
-void SkyWrite::Write(string Text, float3 loc, float Height, float Width, int Duration, float Red, float Green, float Blue, float Alpha){
-	int Group = 0;
-	int bGroup = 0;
-	float pos = 0;
-	// loc = bottom, left hand corner
-	const char* c = Text.c_str();
-	for(int n=0; n &lt; (int)strlen(c); n++)
-		switch(Text[n])	{
-			case 'A':
-				{
-					// Upward, downward, center
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos + Width/2, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos + Width/2, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos + Width/2, loc.y, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y, loc.z),
-						3, 0, Duration, Group);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos + Width/2, loc.y-10, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y-10, loc.z),
-						5, 0, Duration, bGroup);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos + Width/4, loc.y, loc.z+Height/2),
-						float3(loc.x + pos + Width*3/4, loc.y, loc.z+Height/2),
-						3, 0, Duration, Group);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos + Width/4, loc.y-10, loc.z+Height/2),
-						float3(loc.x + pos + Width*3/4, loc.y-10, loc.z+Height/2),
-						5, 0, Duration, bGroup);
-					//
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					pos += Width * 0.7f;
-					break;
-				}
-			case 'B':
-				{
-					// Left Side, Top Bubble, Bottom Bubble
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos, loc.y+Height, loc.z),
-						float3(loc.x + pos + Width, loc.y, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y, loc.z+Height/2),
-						float3(loc.x + pos, loc.y, loc.z+Height/2),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos, loc.y, loc.z+Height/2),
-						float3(loc.x + pos + Width, loc.y, loc.z+Height/2),
-						float3(loc.x + pos + Width, loc.y, loc.z),
-						float3(loc.x + pos, loc.y, loc.z),
-						3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height/2),
-						float3(loc.x + pos, loc.y-10, loc.z+Height/2),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height/2),
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height/2),
-						float3(loc.x + pos + Width, loc.y-10, loc.z),
-						float3(loc.x + pos, loc.y-10, loc.z),
-						5, 0, Duration, bGroup);
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					pos += Width * 0.7f;
-					break;
-				}
-			case 'C':
-				{
-					Group = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos + Width, loc.y, loc.z+Height),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos + Width, loc.y, loc.z),
-						3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos + Width, loc.y-10, loc.z),
-						5, 0, Duration, bGroup);
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					pos += Width * 0.7f;
-					break;
-				}
-			case 'D':
-				{
-					// Left Side, Bubble
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos + Width, loc.y, loc.z),
-						float3(loc.x + pos + Width, loc.y, loc.z+Height),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos + Width, loc.y-10, loc.z),
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case 'E':
-				{
-					// Left, Top, Middle, Bottom
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z+Height/2),
-						float3(loc.x + pos + Width*3/4, loc.y, loc.z+Height/2),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos + Width, loc.y, loc.z),
-						3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height/2),
-						float3(loc.x + pos + Width*3/4, loc.y-10, loc.z+Height/2),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos + Width, loc.y-10, loc.z),
-						5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case 'F':
-				{
-					// Left, Top, Middle
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y, loc.z+Height),
-						3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z+Height/2),
-						float3(loc.x + pos + Width*3/4, loc.y, loc.z+Height/2),
-						3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
-						5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height/2),
-						float3(loc.x + pos + Width*3/4, loc.y-10, loc.z+Height/2),
-						5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case 'G':
-				{
-					Group = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos + Width, loc.y, loc.z+Height),
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y, loc.z),
-						float3(loc.x + pos + Width, loc.y , loc.z+ Height/2),
-						3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateSplineFigure(
-						float3(loc.x + pos + Width, loc.y-10, loc.z+Height),
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						float3(loc.x + pos + Width, loc.y-10, loc.z),
-						float3(loc.x + pos + Width, loc.y-10 , loc.z+ Height/2),
-						5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case 'I':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y, loc.z+Height),
-						float3(loc.x + pos,loc.y, loc.z), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos, loc.y-10, loc.z+Height),
-						float3(loc.x + pos,loc.y-10, loc.z), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '1':
-				{
-					// Left, Top, Middle
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.5f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.5f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '2':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*1.0f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*1.0f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '3':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*1.0f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*1.0f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*1.0f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*1.0f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '4':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '5':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '6':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '7':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '8':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '9':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '0':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.7f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height)),
-						float3(loc.x + pos+(Width*0.7f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case ':':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.4f)),
-						float3(loc.x + pos+(Width*0.5f),loc.y, loc.z+(Height*0.5f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.7f)),
-						float3(loc.x + pos+(Width*0.5f),loc.y, loc.z+(Height*0.8f)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.4f)),
-						float3(loc.x + pos+(Width*0.5f),loc.y-10, loc.z+(Height*0.5f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.7f)),
-						float3(loc.x + pos+(Width*0.5f),loc.y-10, loc.z+(Height*0.8f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '&#172;':// the lightning power symbol
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.8f),loc.y, loc.z+(Height*0.1f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.8f), loc.y, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.6f),loc.y, loc.z+(Height*0.6f)), 3, 0, Duration, Group);
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.6f), loc.y, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.2f),loc.y, loc.z+(Height)), 3, 0, Duration, Group);
-					//
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.8f),loc.y-10, loc.z+(Height*0.1f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.8f), loc.y-10, loc.z+(Height*0.1f)),
-						float3(loc.x + pos+(Width*0.3f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.3f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.6f),loc.y-10, loc.z+(Height*0.6f)), 5, 0, Duration, bGroup);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.6f), loc.y-10, loc.z+(Height*0.6f)),
-						float3(loc.x + pos+(Width*0.2f),loc.y-10, loc.z+(Height)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case '.':
-				{
-					Group = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y, loc.z+(Height*0.9f)),
-						float3(loc.x + pos+(Width*0.6f),loc.y, loc.z+(Height*0.9f)), 3, 0, Duration, Group);
-					bGroup = GS-&gt;CreateLineFigure(
-						float3(loc.x + pos+(Width*0.5f), loc.y-10, loc.z+(Height*0.9f)),
-						float3(loc.x + pos+(Width*0.6f),loc.y-10, loc.z+(Height*0.9f)), 5, 0, Duration, bGroup);
-					pos += Width * 0.7f;
-					GS-&gt;SetFigureColor(Group,Red,Green,Blue,Alpha);
-					GS-&gt;SetFigureColor(bGroup,0,0,0,0.5f);
-					break;
-				}
-			case ' ':
-				{
-					pos += Width * 0.7f;
-					break;
-				}
-			default:
-				{
-					pos += Width * 0.7f;
-					break;
-				}
-		}
-}
 
 /** unitdef-&gt;type
 MetalExtractor

Modified: trunk/AI/Global/NTai/AI/NTai/Core/CNTai.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Core/CNTai.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Core/CNTai.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -13,350 +13,348 @@
 
 #include &quot;CNTai.h&quot;
 
+namespace ntai {
+	 // ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// CNTai class
 
- // ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-// CNTai class
+	//// Constructor/Destructor/Initialisation
 
-//// Constructor/Destructor/Initialisation
+	CNTai::CNTai(){
+		G = 0;
+	}
 
-CNTai::CNTai(){
-	G = 0;
-}
+	CNTai::~CNTai(){
+		delete G;
+	}
 
-CNTai::~CNTai(){
-	delete G;
-}
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-void CNTai::InitAI(IGlobalAICallback* callback, int team){
-	cg = callback;
-	acallback = cg-&gt;GetAICallback();
-	Good = true;
-#ifdef EXCEPTION
-	try{
-		G = new Global(callback);
-		G-&gt;Cached-&gt;team = team;
-	}catch(exception&amp; e){
-		Good = false;
-		acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
-		acallback-&gt;SendTextMsg(e.what(),1);
-	}catch(exception* e){
-		Good = false;
-		acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
-		acallback-&gt;SendTextMsg(e-&gt;what(),1);
-	}catch(string s){
-		Good = false;
-		acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
-		acallback-&gt;SendTextMsg(s.c_str(),1);
-	}catch(...){
-		Good = false;
-		acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
-	}
-	if(Good == true){
+	void CNTai::InitAI(IGlobalAICallback* callback, int team){
+		cg = callback;
+		acallback = cg-&gt;GetAICallback();
+		Good = true;
+	#ifdef EXCEPTION
 		try{
-			G-&gt;InitAI(acallback,team);
+			G = new Global(callback);
+			G-&gt;Cached-&gt;team = team;
 		}catch(exception&amp; e){
 			Good = false;
-			G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
-			G-&gt;L.eprint(e.what());
+			acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
+			acallback-&gt;SendTextMsg(e.what(),1);
 		}catch(exception* e){
 			Good = false;
-			G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
-			G-&gt;L.eprint(e-&gt;what());
+			acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
+			acallback-&gt;SendTextMsg(e-&gt;what(),1);
 		}catch(string s){
 			Good = false;
-			G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
-			G-&gt;L.eprint(s);
+			acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
+			acallback-&gt;SendTextMsg(s.c_str(),1);
 		}catch(...){
 			Good = false;
-			G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
+			acallback-&gt;SendTextMsg(&quot;error in Global constructor, cannot continue&quot;,1);
 		}
+		if(Good == true){
+			try{
+				G-&gt;InitAI(acallback,team);
+			}catch(exception&amp; e){
+				Good = false;
+				G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
+				G-&gt;L.eprint(e.what());
+			}catch(exception* e){
+				Good = false;
+				G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
+				G-&gt;L.eprint(e-&gt;what());
+			}catch(string s){
+				Good = false;
+				G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
+				G-&gt;L.eprint(s);
+			}catch(...){
+				Good = false;
+				G-&gt;L.eprint(&quot;error in Global InitAI, cannot continue&quot;);
+			}
+		}
+	#else
+		G = new Global(callback);
+		G-&gt;Cached-&gt;team = team;
+		G-&gt;InitAI(acallback,tteam);
+	#endif
 	}
-#else
-	G = new Global(callback);
-	G-&gt;Cached-&gt;team = team;
-	G-&gt;InitAI(acallback,tteam);
-#endif
-}
 
 
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-// Engine Interface
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// Engine Interface
 
-void CNTai::Update(){
-	if(Good == false){
-		if(acallback-&gt;GetCurrentFrame() == (6 SECONDS)){
-			//
-			acallback-&gt;SendTextMsg(&quot;Error :: InitAI() in XE9.79 failed, please notify AF at once&quot;,1);
-			acallback-&gt;SendTextMsg(&quot;Error :: www.darkstars.co.uk&quot;,1);
+	void CNTai::Update(){
+		if(Good == false){
+			if(acallback-&gt;GetCurrentFrame() == (6 SECONDS)){
+				//
+				acallback-&gt;SendTextMsg(&quot;Error :: InitAI() in XE9.79 failed, please notify AF at once&quot;,1);
+				acallback-&gt;SendTextMsg(&quot;Error :: www.darkstars.co.uk&quot;,1);
+			}
+			return;
 		}
-		return;
+		// No need for exception handling here as it's done internally by the Global object
+		G-&gt;Update();
 	}
-	// No need for exception handling here as it's done internally by the Global object
-	G-&gt;Update();
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::UnitCreated(int unit){
-	if(Good == false) return;
-	G-&gt;UnitCreated(unit);
-}
+	void CNTai::UnitCreated(int unit){
+		if(Good == false) return;
+		G-&gt;UnitCreated(unit);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::UnitFinished(int unit){
-	if(Good == false) return;
-	G-&gt;UnitFinished(unit);
-}
+	void CNTai::UnitFinished(int unit){
+		if(Good == false) return;
+		G-&gt;UnitFinished(unit);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::UnitDestroyed(int unit, int attacker){
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::UnitDestroyed(int unit, int attacker){
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;UnitDestroyed(unit,attacker);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;G-&gt;unitdestroyed exception&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;G-&gt;unitdestroyed exception&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;G-&gt;unitdestroyed exception&quot;);
+		}
+	#else
 		G-&gt;UnitDestroyed(unit,attacker);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;G-&gt;unitdestroyed exception&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;G-&gt;unitdestroyed exception&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;G-&gt;unitdestroyed exception&quot;);
+	#endif
 	}
-#else
-	G-&gt;UnitDestroyed(unit,attacker);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::EnemyEnterLOS(int enemy){
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::EnemyEnterLOS(int enemy){
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;EnemyEnterLOS(enemy);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;enemy enter LOS exception&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;enemy enter LOS exception&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;enemy enter LOS exception&quot;);
+		}
+	#else
 		G-&gt;EnemyEnterLOS(enemy);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;enemy enter LOS exception&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;enemy enter LOS exception&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;enemy enter LOS exception&quot;);
+	#endif
 	}
-#else
-	G-&gt;EnemyEnterLOS(enemy);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::EnemyLeaveLOS(int enemy){
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::EnemyLeaveLOS(int enemy){
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;EnemyLeaveLOS(enemy);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;eception in G-&gt;enemyleaveLOS&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;eception in G-&gt;enemyleaveLOS&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;eception in G-&gt;enemyleaveLOS&quot;);
+		}
+	#else
 		G-&gt;EnemyLeaveLOS(enemy);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;eception in G-&gt;enemyleaveLOS&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;eception in G-&gt;enemyleaveLOS&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;eception in G-&gt;enemyleaveLOS&quot;);
+	#endif
 	}
-#else
-	G-&gt;EnemyLeaveLOS(enemy);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::EnemyEnterRadar(int enemy){
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::EnemyEnterRadar(int enemy){
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;EnemyEnterRadar(enemy);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;exception G-&gt;enemyenterRadar&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;exception G-&gt;enemyenterRadar&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;exception G-&gt;enemyenterRadar&quot;);
+		}
+	#else
 		G-&gt;EnemyEnterRadar(enemy);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;exception G-&gt;enemyenterRadar&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;exception G-&gt;enemyenterRadar&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;exception G-&gt;enemyenterRadar&quot;);
+	#endif
 	}
-#else
-	G-&gt;EnemyEnterRadar(enemy);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::EnemyLeaveRadar(int enemy){
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::EnemyLeaveRadar(int enemy){
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;EnemyLeaveRadar(enemy);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;exception G-&gt;enemyleaveradar&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;exception G-&gt;enemyleaveradar&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;exception G-&gt;enemyleaveradar&quot;);
+		}
+	#else
 		G-&gt;EnemyLeaveRadar(enemy);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;exception G-&gt;enemyleaveradar&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;exception G-&gt;enemyleaveradar&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;exception G-&gt;enemyleaveradar&quot;);
+	#endif
 	}
-#else
-	G-&gt;EnemyLeaveRadar(enemy);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::EnemyDamaged(int damaged,int attacker,float damage,float3 dir) {
-	if(Good == false) return;
-//START_EXCEPTION_HANDLING
-		G-&gt;EnemyDamaged(damaged,attacker,damage,dir);
-//END_EXCEPTION_HANDLING(&quot;G-&gt;enemyleaveradar&quot;)
-}
+	void CNTai::EnemyDamaged(int damaged,int attacker,float damage,float3 dir) {
+		if(Good == false) return;
+	//START_EXCEPTION_HANDLING
+			G-&gt;EnemyDamaged(damaged,attacker,damage,dir);
+	//END_EXCEPTION_HANDLING(&quot;G-&gt;enemyleaveradar&quot;)
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::EnemyDestroyed(int enemy,int attacker){
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::EnemyDestroyed(int enemy,int attacker){
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;EnemyDestroyed(enemy,attacker);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;exception G-&gt;EnemyDestroyed&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;exception G-&gt;EnemyDestroyed&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;exception G-&gt;EnemyDestroyed&quot;);
+		}
+	#else
 		G-&gt;EnemyDestroyed(enemy,attacker);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;exception G-&gt;EnemyDestroyed&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;exception G-&gt;EnemyDestroyed&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;exception G-&gt;EnemyDestroyed&quot;);
+	#endif
 	}
-#else
-	G-&gt;EnemyDestroyed(enemy,attacker);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::UnitIdle(int unit){
-	if(Good == false) return;
-	G-&gt;UnitIdle(unit);
-}
+	void CNTai::UnitIdle(int unit){
+		if(Good == false) return;
+		G-&gt;UnitIdle(unit);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::GotChatMsg(const char* msg,int player){
-	if(string(msg) == string(&quot;.freeze&quot;)){
-		Good=false;
-		return;
-	}else if(string(msg)==string(&quot;.unfreeze&quot;)){
-		Good=true;
-	}
-	if(Good == false) return;
-#ifdef EXCEPTION
-	try{
+	void CNTai::GotChatMsg(const char* msg,int player){
+		if(string(msg) == string(&quot;.freeze&quot;)){
+			Good=false;
+			return;
+		}else if(string(msg)==string(&quot;.unfreeze&quot;)){
+			Good=true;
+		}
+		if(Good == false) return;
+	#ifdef EXCEPTION
+		try{
+			G-&gt;GotChatMsg(msg,player);
+		}catch(exception&amp; e){
+			G-&gt;L.eprint(&quot;exception G-&gt;GotChatMsg&quot;);
+			G-&gt;L.eprint(e.what());
+		}catch(exception* e){
+			G-&gt;L.eprint(&quot;exception G-&gt;GotChatMsg&quot;);
+			G-&gt;L.eprint(e-&gt;what());
+		} catch (...) {
+			G-&gt;L.print(&quot;exception G-&gt;GotChatMsg&quot;);
+		}
+	#else
 		G-&gt;GotChatMsg(msg,player);
-	}catch(exception&amp; e){
-		G-&gt;L.eprint(&quot;exception G-&gt;GotChatMsg&quot;);
-		G-&gt;L.eprint(e.what());
-	}catch(exception* e){
-		G-&gt;L.eprint(&quot;exception G-&gt;GotChatMsg&quot;);
-		G-&gt;L.eprint(e-&gt;what());
-	} catch (...) {
-		G-&gt;L.print(&quot;exception G-&gt;GotChatMsg&quot;);
+	#endif
 	}
-#else
-	G-&gt;GotChatMsg(msg,player);
-#endif
-}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::UnitDamaged(int damaged,int attacker,float damage,float3 dir){
-	if(Good == false) return;
-	G-&gt;UnitDamaged(damaged,attacker,damage,dir);
-}
+	void CNTai::UnitDamaged(int damaged,int attacker,float damage,float3 dir){
+		if(Good == false) return;
+		G-&gt;UnitDamaged(damaged,attacker,damage,dir);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CNTai::UnitMoveFailed(int unit){
-	if(Good == false) return;
-	G-&gt;UnitMoveFailed(unit);
-}
+	void CNTai::UnitMoveFailed(int unit){
+		if(Good == false) return;
+		G-&gt;UnitMoveFailed(unit);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-int CNTai::HandleEvent (int msg, const void *data){
-	if(Good == false) return 0;
-	switch (msg) {
-		case AI_EVENT_UNITGIVEN: {
-			ChangeTeamEvent* cte=(ChangeTeamEvent *)data;
-#ifdef EXCEPTION
-			try{
+	int CNTai::HandleEvent (int msg, const void *data){
+		if(Good == false) return 0;
+		switch (msg) {
+			case AI_EVENT_UNITGIVEN: {
+				ChangeTeamEvent* cte=(ChangeTeamEvent *)data;
+	#ifdef EXCEPTION
+				try{
+					G-&gt;UnitCreated(cte-&gt;unit);
+				}catch(exception&amp; e){
+					G-&gt;L.eprint(&quot;exception G-&gt;UnitCreated&quot;);
+					G-&gt;L.eprint(e.what());
+				}catch(exception* e){
+					G-&gt;L.eprint(&quot;exception G-&gt;UnitCreated&quot;);
+					G-&gt;L.eprint(e-&gt;what());
+				} catch (...) {
+					G-&gt;L.print(&quot;exception G-&gt;UnitCreated&quot;);
+				}
+	#else
 				G-&gt;UnitCreated(cte-&gt;unit);
-			}catch(exception&amp; e){
-				G-&gt;L.eprint(&quot;exception G-&gt;UnitCreated&quot;);
-				G-&gt;L.eprint(e.what());
-			}catch(exception* e){
-				G-&gt;L.eprint(&quot;exception G-&gt;UnitCreated&quot;);
-				G-&gt;L.eprint(e-&gt;what());
-			} catch (...) {
-				G-&gt;L.print(&quot;exception G-&gt;UnitCreated&quot;);
-			}
-#else
-			G-&gt;UnitCreated(cte-&gt;unit);
-#endif
-#ifdef EXCEPTION
-			try{
+	#endif
+	#ifdef EXCEPTION
+				try{
+					G-&gt;UnitFinished(cte-&gt;unit);
+				}catch(exception&amp; e){
+					G-&gt;L.eprint(&quot;exception G-&gt;UnitFinished&quot;);
+					G-&gt;L.eprint(e.what());
+				}catch(exception* e){
+					G-&gt;L.eprint(&quot;exception G-&gt;UnitFinished&quot;);
+					G-&gt;L.eprint(e-&gt;what());
+				} catch (...) {
+					G-&gt;L.print(&quot;exception G-&gt;UnitFinished&quot;);
+				}
+	#else
 				G-&gt;UnitFinished(cte-&gt;unit);
-			}catch(exception&amp; e){
-				G-&gt;L.eprint(&quot;exception G-&gt;UnitFinished&quot;);
-				G-&gt;L.eprint(e.what());
-			}catch(exception* e){
-				G-&gt;L.eprint(&quot;exception G-&gt;UnitFinished&quot;);
-				G-&gt;L.eprint(e-&gt;what());
-			} catch (...) {
-				G-&gt;L.print(&quot;exception G-&gt;UnitFinished&quot;);
+	#endif
+				break;
 			}
-#else
-			G-&gt;UnitFinished(cte-&gt;unit);
-#endif
-			break;
-		}
-		case AI_EVENT_UNITCAPTURED:{
-			ChangeTeamEvent* cte=(ChangeTeamEvent *)data;
-#ifdef EXCEPTION
-			try{
+			case AI_EVENT_UNITCAPTURED:{
+				ChangeTeamEvent* cte=(ChangeTeamEvent *)data;
+	#ifdef EXCEPTION
+				try{
+					G-&gt;UnitDestroyed(cte-&gt;unit,0);
+				}catch(exception&amp; e){
+					G-&gt;L.eprint(&quot;exception G-&gt;UnitDestroyed&quot;);
+					G-&gt;L.eprint(e.what());
+				}catch(exception* e){
+					G-&gt;L.eprint(&quot;exception G-&gt;UnitDestroyed&quot;);
+					G-&gt;L.eprint(e-&gt;what());
+				} catch (...) {
+					G-&gt;L.print(&quot;exception G-&gt;UnitDestroyed&quot;);
+				}
+	#else
 				G-&gt;UnitDestroyed(cte-&gt;unit,0);
-			}catch(exception&amp; e){
-				G-&gt;L.eprint(&quot;exception G-&gt;UnitDestroyed&quot;);
-				G-&gt;L.eprint(e.what());
-			}catch(exception* e){
-				G-&gt;L.eprint(&quot;exception G-&gt;UnitDestroyed&quot;);
-				G-&gt;L.eprint(e-&gt;what());
-			} catch (...) {
-				G-&gt;L.print(&quot;exception G-&gt;UnitDestroyed&quot;);
+	#endif
+				break;
 			}
-#else
-			G-&gt;UnitDestroyed(cte-&gt;unit,0);
-#endif
-			break;
 		}
+		return 0;
 	}
-	return 0;
 }
 
-//////////////////////////////////////////////////////////////////////////////////////////
-//// END OF CODE
-//////////////////////////////////////////////////////////////////////////////////////////

Modified: trunk/AI/Global/NTai/AI/NTai/Core/CNTai.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Core/CNTai.h	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Core/CNTai.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -2,42 +2,45 @@
 #define AFX_GroupAI_H__10718E36_5CDF_4CD4_8D90_F41311DD2694__INCLUDED_
 //-------------------------------------------------------------------------
 // NTai
-// Copyright 2004-2007 AF
+// Copyright 2004-2008 AF
 // Released under GPL 2 license
 //-------------------------------------------------------------------------
 
 #include &quot;include.h&quot;
 
+namespace ntai {
 
-class CNTai : public IGlobalAI{
-public:
-	CNTai();
-	virtual ~CNTai();
-	void InitAI(IGlobalAICallback* callback, int team);
-	void UnitCreated(int unit);
-	void UnitFinished(int unit);
-	void UnitDestroyed(int unit, int attacker);
-	void EnemyEnterLOS(int enemy);
-	void EnemyLeaveLOS(int enemy);
-	void EnemyEnterRadar(int enemy);
-	void EnemyLeaveRadar(int enemy);
-	void EnemyDamaged(int damaged,int attacker,float damage,float3 dir);
-	void EnemyDestroyed(int enemy,int attacker);
-	void UnitIdle(int unit);
-	void GotChatMsg(const char* msg,int player);
-	void UnitDamaged(int damaged,int attacker,float damage,float3 dir);
-	void UnitMoveFailed(int unit);
-	void Update();
-    void Load(IGlobalAICallback* callback,std::istream *s){}
-	void Save(std::ostream *s){}
-	int HandleEvent (int msg, const void *data);
-	int tteam;
-	int team;
-	Global* G;
-	IGlobalAICallback* cg;
-	IAICallback* acallback;
+	class CNTai : public IGlobalAI{
+	public:
+		CNTai();
+		virtual ~CNTai();
+		void InitAI(IGlobalAICallback* callback, int team);
+		void UnitCreated(int unit);
+		void UnitFinished(int unit);
+		void UnitDestroyed(int unit, int attacker);
+		void EnemyEnterLOS(int enemy);
+		void EnemyLeaveLOS(int enemy);
+		void EnemyEnterRadar(int enemy);
+		void EnemyLeaveRadar(int enemy);
+		void EnemyDamaged(int damaged,int attacker,float damage,float3 dir);
+		void EnemyDestroyed(int enemy,int attacker);
+		void UnitIdle(int unit);
+		void GotChatMsg(const char* msg,int player);
+		void UnitDamaged(int damaged,int attacker,float damage,float3 dir);
+		void UnitMoveFailed(int unit);
+		void Update();
+		void Load(IGlobalAICallback* callback,std::istream *s){}
+		void Save(std::ostream *s){}
+		int HandleEvent (int msg, const void *data);
+		int tteam;
+		int team;
+		Global* G;
+		IGlobalAICallback* cg;
+		IAICallback* acallback;
 
-	bool Good;
-};
+		bool Good;
+	};
 
+}
+
 #endif // !defined(AFX_GroupAI_H__10718E36_5CDF_4CD4_8D90_F41311DD2694__INCLUDED_)

Modified: trunk/AI/Global/NTai/AI/NTai/Core/Global.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Core/Global.h	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Core/Global.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,9 +1,8 @@
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-// Global class implementation.
+/*
+AF 2004+
+LGPL 2
+*/
 
-
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-//using namespace std;
 namespace ntai {
 
 	void trim(string &amp;str);
@@ -11,7 +10,7 @@
 	bool ValidUnitID(int id);
 
 
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// Global class implementation.
 
 	class Global{
 	public:

Modified: trunk/AI/Global/NTai/AI/NTai/Core/IModule.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Core/IModule.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Core/IModule.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,14 +1,17 @@
 #include &quot;include.h&quot;
 
-IModule::IModule(Global* GL){
-	G=GL;
-	valid=false;
-}
+namespace ntai {
 
-IModule::~IModule(){
-}
+	IModule::IModule(Global* GL){
+		G=GL;
+		valid=false;
+	}
 
-void IModule::DestroyModule(){
-	valid=false;
-	//G-&gt;RemoveHandler(me);
+	IModule::~IModule(){
+	}
+
+	void IModule::DestroyModule(){
+		valid=false;
+		//G-&gt;RemoveHandler(me);
+	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Core/Interface.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Core/Interface.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Core/Interface.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -11,11 +11,11 @@
 }
 
 DLL_EXPORT void GetAiName(char* name){
-	strcpy(name,AI_NAME);
+	strcpy(name,ntai::AI_NAME);
 }
 
 DLL_EXPORT IGlobalAI* GetNewAI(){
-	return new CNTai();
+	return new ntai::CNTai();
 }
 
 DLL_EXPORT void ReleaseAI(IGlobalAI* i){

Modified: trunk/AI/Global/NTai/AI/NTai/Core/include.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Core/include.h	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Core/include.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -7,14 +7,17 @@
 #endif
 
 namespace ntai{
+	// Prototype the Global class
 	class Global;
+	
+	// The name NTAI gives to the spring engine.
+	const char AI_NAME[]= {&quot;NTai XE9.79+&quot;};
 }
 
-using namespace ntai;
+//using namespace ntai;
 
 // C++ headers
 
-
 // enumerations
 #include &quot;enums.h&quot;
 
@@ -51,7 +54,7 @@
 typedef boost::mutex mutex;
 typedef boost::mutex::scoped_lock scoped_lock;
 
-using namespace std;
+//using namespace std;
 
 
 // engine includes
@@ -68,6 +71,8 @@
 #include &quot;../Core/IModule.h&quot;								// Base class for AI objects
 #include &quot;../Units/IBehaviour.h&quot;							// Behaviour base class
 
+#include &quot;../Units/ITaskManager.h&quot;					// Attack nearby enemies
+#include &quot;../Units/ITaskManagerFactory.h&quot;					// Attack nearby enemies
 #include &quot;../Units/CUnit.h&quot;
 #include &quot;../Helpers/Log.h&quot;									// Logging class
 #include &quot;../Helpers/Units/CUnitDefLoader.h&quot;				// Loads unitdefs
@@ -119,6 +124,5 @@
 
 #include &quot;Global.h&quot;											// (the root object representing the AI itself)
 
-// The name NTAI gives to the spring engine.
-const char AI_NAME[]= {&quot;NTai XE9.79+&quot;};
+	
 

Modified: trunk/AI/Global/NTai/AI/NTai/Engine/COrderRouter.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Engine/COrderRouter.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Engine/COrderRouter.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,227 +1,229 @@
 // COrderRouter
 #include &quot;../Core/include.h&quot;
 
-int a;
+namespace ntai {
+	int a;
 
-COrderRouter::COrderRouter(Global* GL){
-    G = GL;
-}
+	COrderRouter::COrderRouter(Global* GL){
+		G = GL;
+	}
 
-bool COrderRouter::GiveOrder(TCommand c, bool newer){
-    NLOG(&quot;Global::GiveOrder&quot;);
-    if(!ValidUnitID(c.unit)){
-        G-&gt;L.print(&quot;ValidUnitID(c.unit)==false :: c.unit = &quot; + to_string((c.unit))+&quot; MAXUNITS = &quot;+to_string(MAX_UNITS));
-        return false;
-    }
-    if(c.clear == true){
-        G-&gt;L.print(&quot;c.clear == true&quot;);
-        return false;
-    }
-    //if(c.c.timeOut &gt; 1){
-    //	if(G-&gt;cb-&gt;GetCurrentFrame() &gt; c.c.timeOut)return -1;
-    //}
-    //G-&gt;idlenextframe.erase(c.unit);
-    if(c.type == B_CMD){
-        if((c.c.params.empty()==true) || (c.c.params.size()==0)){
-            if ((c.c.id == CMD_ATTACK)||(c.c.id == CMD_MOVE)||(c.c.id == CMD_DGUN)||(c.c.id == CMD_ONOFF)||(c.c.id == CMD_RECLAIM)||(c.c.id == CMD_GUARD)||(c.c.id == CMD_MOVE_STATE)||(c.c.id == CMD_FIRE_STATE)||(c.c.id == CMD_REPAIR)){
-#ifdef TC_SOURCE
-                G-&gt;L.print(&quot;empty params?!?!?!? :: &quot; + c.source);
-#else
-G-&gt;L.print(&quot;empty params?!?!?!? :: &quot;);
-#endif
-return false;
-            }
-        }else if(((c.c.params.size()==3)||(c.c.params.size()&gt;3))&amp;&amp;(c.c.id &gt; 0)){
-            float3 p(c.c.params.at(0), c.c.params.at(1), c.c.params.at(2));
-            if(G-&gt;Map-&gt;CheckFloat3(p)==false){
-                G-&gt;L.print(&quot;intercepted erroneous float3 in a command&quot;);
-                return false;
-            }
-        }else if ((c.c.params.size()==1)&amp;&amp;(c.c.id==CMD_DGUN)){
-            if(c.c.params.at(0)&lt;0){
-                G-&gt;L.print(&quot;c.c.params.at(0)&lt;0 in CMD_DGUN&quot;);
-                return false;
-            }
-        }
-        
-    }
-    if(newer == true){
-        if(CommandCache.empty() == false){
-            for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin(); i != CommandCache.end();++i){
-                if(i-&gt;clear == true) continue;
-                if(i-&gt;unit == c.unit){
-                    i-&gt;clear = true;
-                }
-            }
-        }
-    }
-    if (c.type == B_IDLE){
-        if(!ValidUnitID(c.unit)){
-            G-&gt;L.print(&quot;!ValidUnitID(c.unit) :: c.unit = &quot; + to_string((c.unit))+&quot; MAXUNITS = &quot;+to_string(MAX_UNITS));
-            return false;
-        }else{
-            G-&gt;idlenextframe.insert(c.unit);
-            return true;
-        }
-    }else if(c.type == B_CMD){
-        G-&gt;idlenextframe.erase(c.unit);
-        CommandCache.push_back(c);
-        return true;
-    }else{
-        G-&gt;L.print(&quot;bad command type&quot;);
-        return false;
-    }
-}
+	bool COrderRouter::GiveOrder(TCommand c, bool newer){
+		NLOG(&quot;Global::GiveOrder&quot;);
+		if(!ValidUnitID(c.unit)){
+			G-&gt;L.print(&quot;ValidUnitID(c.unit)==false :: c.unit = &quot; + to_string((c.unit))+&quot; MAXUNITS = &quot;+to_string(MAX_UNITS));
+			return false;
+		}
+		if(c.clear == true){
+			G-&gt;L.print(&quot;c.clear == true&quot;);
+			return false;
+		}
+		//if(c.c.timeOut &gt; 1){
+		//	if(G-&gt;cb-&gt;GetCurrentFrame() &gt; c.c.timeOut)return -1;
+		//}
+		//G-&gt;idlenextframe.erase(c.unit);
+		if(c.type == B_CMD){
+			if((c.c.params.empty()==true) || (c.c.params.size()==0)){
+				if ((c.c.id == CMD_ATTACK)||(c.c.id == CMD_MOVE)||(c.c.id == CMD_DGUN)||(c.c.id == CMD_ONOFF)||(c.c.id == CMD_RECLAIM)||(c.c.id == CMD_GUARD)||(c.c.id == CMD_MOVE_STATE)||(c.c.id == CMD_FIRE_STATE)||(c.c.id == CMD_REPAIR)){
+	#ifdef TC_SOURCE
+					G-&gt;L.print(&quot;empty params?!?!?!? :: &quot; + c.source);
+	#else
+	G-&gt;L.print(&quot;empty params?!?!?!? :: &quot;);
+	#endif
+	return false;
+				}
+			}else if(((c.c.params.size()==3)||(c.c.params.size()&gt;3))&amp;&amp;(c.c.id &gt; 0)){
+				float3 p(c.c.params.at(0), c.c.params.at(1), c.c.params.at(2));
+				if(G-&gt;Map-&gt;CheckFloat3(p)==false){
+					G-&gt;L.print(&quot;intercepted erroneous float3 in a command&quot;);
+					return false;
+				}
+			}else if ((c.c.params.size()==1)&amp;&amp;(c.c.id==CMD_DGUN)){
+				if(c.c.params.at(0)&lt;0){
+					G-&gt;L.print(&quot;c.c.params.at(0)&lt;0 in CMD_DGUN&quot;);
+					return false;
+				}
+			}
+	        
+		}
+		if(newer == true){
+			if(CommandCache.empty() == false){
+				for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin(); i != CommandCache.end();++i){
+					if(i-&gt;clear == true) continue;
+					if(i-&gt;unit == c.unit){
+						i-&gt;clear = true;
+					}
+				}
+			}
+		}
+		if (c.type == B_IDLE){
+			if(!ValidUnitID(c.unit)){
+				G-&gt;L.print(&quot;!ValidUnitID(c.unit) :: c.unit = &quot; + to_string((c.unit))+&quot; MAXUNITS = &quot;+to_string(MAX_UNITS));
+				return false;
+			}else{
+				G-&gt;idlenextframe.insert(c.unit);
+				return true;
+			}
+		}else if(c.type == B_CMD){
+			G-&gt;idlenextframe.erase(c.unit);
+			CommandCache.push_back(c);
+			return true;
+		}else{
+			G-&gt;L.print(&quot;bad command type&quot;);
+			return false;
+		}
+	}
 
-void COrderRouter::CleanUpOrders(){
-    NLOG(&quot;COrderRouter::CleanUpOrders()&quot;);
-    if(CommandCache.empty() == false){
-        int hg = CommandCache.size();
-        if( hg &gt;20){
-            for(int j = 2;  j &lt;(hg/2) ; j++){
-                if(CommandCache.empty() == false){
-                    for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin(); i != CommandCache.end();++i){
-                        if(i-&gt;clear == true){
-                            CommandCache.erase(i);
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-    }
-}
+	void COrderRouter::CleanUpOrders(){
+		NLOG(&quot;COrderRouter::CleanUpOrders()&quot;);
+		if(CommandCache.empty() == false){
+			int hg = CommandCache.size();
+			if( hg &gt;20){
+				for(int j = 2;  j &lt;(hg/2) ; j++){
+					if(CommandCache.empty() == false){
+						for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin(); i != CommandCache.end();++i){
+							if(i-&gt;clear == true){
+								CommandCache.erase(i);
+								break;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
 
-void COrderRouter::IssueOrders(){
-    NLOG(&quot;COrderRouter::IssueOrders()&quot;);
-    if(G-&gt;L.FirstInstance() == true){
-        a=0;
-    }else if (a == BUFFERMAX){
-        a -= 4;
-    }
-    if(CommandCache.empty() == false){
-        set&lt;int&gt; timed_out_units;
-        for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin();i != CommandCache.end();++i){
-            if(i-&gt;clear == true) continue;
-            switch(i-&gt;type)	{
-                case B_CMD :{
-                    if(a == BUFFERMAX){
-                        continue;
-                    }
-                    G-&gt;L.print(&quot;issuing command in update()&quot;);
-                    // print out the command!
-                    G-&gt;L.print(i-&gt;toString());
-                    if(G-&gt;cb-&gt;GiveOrder(i-&gt;unit, &amp;i-&gt;c) == -1){
-                        G-&gt;L.print(&quot;hmm failed task update()&quot;);
-                        i-&gt;clear = true;
-                        timed_out_units.insert(i-&gt;unit);
-                        continue;
-                    }else{
-                        G-&gt;L.print(&quot;issuing command in update() succeeded&quot;);
-                        timed_out_units.erase(i-&gt;unit);
-                        G-&gt;idlenextframe.erase(i-&gt;unit);
-                        i-&gt;clear = true;
-                        a++;
-                        continue;
-                    }
-                }case B_IDLE : {
-                    G-&gt;L.print(&quot;idle task issuing&quot;);
-                    timed_out_units.erase(i-&gt;unit);
-                    i-&gt;clear = true;
-                    //UnitIdle(i-&gt;unit);
-                    continue;
-                }case B_NA :{
-                    G-&gt;L.print(&quot;hmm failed task update() B_NA found&quot;);
-                    i-&gt;clear = true;
-                    timed_out_units.insert(i-&gt;unit);
-                    continue;
-                }default:{
-                    G-&gt;L.print(&quot;hmm failed task update() default????&quot;);
-                    i-&gt;clear = true;
-                    timed_out_units.insert(i-&gt;unit);
-                    continue;
-                }
-            }
-        }
-        if(timed_out_units.empty()== false){
-            for(set&lt;int&gt;::iterator i = timed_out_units.begin(); i != timed_out_units.end(); i++){
-                G-&gt;Actions-&gt;ScheduleIdle(*i);
-            }
-        }
-    }
-}
+	void COrderRouter::IssueOrders(){
+		NLOG(&quot;COrderRouter::IssueOrders()&quot;);
+		if(G-&gt;L.FirstInstance() == true){
+			a=0;
+		}else if (a == BUFFERMAX){
+			a -= 4;
+		}
+		if(CommandCache.empty() == false){
+			set&lt;int&gt; timed_out_units;
+			for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin();i != CommandCache.end();++i){
+				if(i-&gt;clear == true) continue;
+				switch(i-&gt;type)	{
+					case B_CMD :{
+						if(a == BUFFERMAX){
+							continue;
+						}
+						G-&gt;L.print(&quot;issuing command in update()&quot;);
+						// print out the command!
+						G-&gt;L.print(i-&gt;toString());
+						if(G-&gt;cb-&gt;GiveOrder(i-&gt;unit, &amp;i-&gt;c) == -1){
+							G-&gt;L.print(&quot;hmm failed task update()&quot;);
+							i-&gt;clear = true;
+							timed_out_units.insert(i-&gt;unit);
+							continue;
+						}else{
+							G-&gt;L.print(&quot;issuing command in update() succeeded&quot;);
+							timed_out_units.erase(i-&gt;unit);
+							G-&gt;idlenextframe.erase(i-&gt;unit);
+							i-&gt;clear = true;
+							a++;
+							continue;
+						}
+					}case B_IDLE : {
+						G-&gt;L.print(&quot;idle task issuing&quot;);
+						timed_out_units.erase(i-&gt;unit);
+						i-&gt;clear = true;
+						//UnitIdle(i-&gt;unit);
+						continue;
+					}case B_NA :{
+						G-&gt;L.print(&quot;hmm failed task update() B_NA found&quot;);
+						i-&gt;clear = true;
+						timed_out_units.insert(i-&gt;unit);
+						continue;
+					}default:{
+						G-&gt;L.print(&quot;hmm failed task update() default????&quot;);
+						i-&gt;clear = true;
+						timed_out_units.insert(i-&gt;unit);
+						continue;
+					}
+				}
+			}
+			if(timed_out_units.empty()== false){
+				for(set&lt;int&gt;::iterator i = timed_out_units.begin(); i != timed_out_units.end(); i++){
+					G-&gt;Actions-&gt;ScheduleIdle(*i);
+				}
+			}
+		}
+	}
 
-void COrderRouter::UnitDestroyed(int uid){
-    if((-1&lt;uid)&amp;&amp;(uid&lt;MAX_UNITS-1)){
-        if(CommandCache.empty() == false){
-            for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin(); i != CommandCache.end();++i){
-                if(i-&gt;unit == uid){
-                    i-&gt;clear = true;
-                }else if(SubjectOf(*i, uid)){
-                    i-&gt;clear = true;
-                }
-            }
-        }
-    }
-}
+	void COrderRouter::UnitDestroyed(int uid){
+		if((-1&lt;uid)&amp;&amp;(uid&lt;MAX_UNITS-1)){
+			if(CommandCache.empty() == false){
+				for(vector&lt;TCommand&gt;::iterator i = CommandCache.begin(); i != CommandCache.end();++i){
+					if(i-&gt;unit == uid){
+						i-&gt;clear = true;
+					}else if(SubjectOf(*i, uid)){
+						i-&gt;clear = true;
+					}
+				}
+			}
+		}
+	}
 
-bool COrderRouter::SubjectiveCommand(int cmd){
-    bool rv = false;
-    switch(cmd){
-        case CMD_ATTACK: {
-            rv = true;
-            break;
-        }case CMD_GUARD :{
-            rv = true;
-            break;
-        }case CMD_REPAIR :{
-            rv = true;
-            break;
-        }case CMD_RECLAIM : {
-            rv = true;
-            break;
-        }case CMD_DGUN :{
-            rv = true;
-            break;
-        }default:{
-            rv = false;
-            break;
-        }
-    }
-    return rv;
-}
+	bool COrderRouter::SubjectiveCommand(int cmd){
+		bool rv = false;
+		switch(cmd){
+			case CMD_ATTACK: {
+				rv = true;
+				break;
+			}case CMD_GUARD :{
+				rv = true;
+				break;
+			}case CMD_REPAIR :{
+				rv = true;
+				break;
+			}case CMD_RECLAIM : {
+				rv = true;
+				break;
+			}case CMD_DGUN :{
+				rv = true;
+				break;
+			}default:{
+				rv = false;
+				break;
+			}
+		}
+		return rv;
+	}
 
-bool COrderRouter::SubjectiveCommand(TCommand&amp; cmd){
-    if(cmd.type = B_CMD){
-        if(cmd.c.params.empty()){
-            return false;
-        }else{
-            if(cmd.c.params.size()==1){
-                return SubjectiveCommand(cmd.c.id);
-            }else{
-                return false;
-            }
-        }
-    }else{
-        return false;
-    }
-}
+	bool COrderRouter::SubjectiveCommand(TCommand&amp; cmd){
+		if(cmd.type = B_CMD){
+			if(cmd.c.params.empty()){
+				return false;
+			}else{
+				if(cmd.c.params.size()==1){
+					return SubjectiveCommand(cmd.c.id);
+				}else{
+					return false;
+				}
+			}
+		}else{
+			return false;
+		}
+	}
 
-bool COrderRouter::SubjectOf(TCommand c, int unit){
-    if (SubjectiveCommand(c)){
-        if(c.c.params.at(0)==unit){
-            return true;
-        }
-    }
-    return false;
-}
+	bool COrderRouter::SubjectOf(TCommand c, int unit){
+		if (SubjectiveCommand(c)){
+			if(c.c.params.at(0)==unit){
+				return true;
+			}
+		}
+		return false;
+	}
 
-void COrderRouter::Update(){
-    //
-    if(EVERY_((5 FRAMES))){
-        CleanUpOrders();
-    }
-    if(EVERY_((3 FRAMES) /*+ team*/)){
-        IssueOrders();
-    }
+	void COrderRouter::Update(){
+		//
+		if(EVERY_((5 FRAMES))){
+			CleanUpOrders();
+		}
+		if(EVERY_((3 FRAMES) /*+ team*/)){
+			IssueOrders();
+		}
+	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/CConfigData.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/CConfigData.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/CConfigData.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,50 +1,52 @@
 #include &quot;../Core/include.h&quot;
 
-CConfigData::CConfigData(Global* G){
-	_abstract = true;
-	gaia = false;
-	spacemod = false;
-	dynamic_selection = true;
-	use_modabstracts = false;
-	absent_abstract = false;
-	fire_state_commanders = 0;
-	move_state_commanders = 0;
-	scout_speed = 60;
-	rule_extreme_interpolate= true;
-	mod_tdf = new TdfParser(G);
-}
+namespace ntai {
+	CConfigData::CConfigData(Global* G){
+		_abstract = true;
+		gaia = false;
+		spacemod = false;
+		dynamic_selection = true;
+		use_modabstracts = false;
+		absent_abstract = false;
+		fire_state_commanders = 0;
+		move_state_commanders = 0;
+		scout_speed = 60;
+		rule_extreme_interpolate= true;
+		mod_tdf = new TdfParser(G);
+	}
 
-CConfigData::~CConfigData(){
-	//
-	delete mod_tdf;
-}
+	CConfigData::~CConfigData(){
+		//
+		delete mod_tdf;
+	}
 
-void CConfigData::Load(){
-	//
-	mod_tdf-&gt;GetDef(_abstract, &quot;1&quot;, &quot;AI\\abstract&quot;);
-    mod_tdf-&gt;GetDef(gaia, &quot;0&quot;, &quot;AI\\GAIA&quot;);
-    mod_tdf-&gt;GetDef(spacemod, &quot;0&quot;, &quot;AI\\spacemod&quot;);
-    mod_tdf-&gt;GetDef(mexfirst, &quot;0&quot;, &quot;AI\\first_attack_mexraid&quot;);
-    mod_tdf-&gt;GetDef(hardtarget, &quot;0&quot;, &quot;AI\\hard_target&quot;);
-    mod_tdf-&gt;GetDef(mexscouting, &quot;1&quot;, &quot;AI\\mexscouting&quot;);
-    mod_tdf-&gt;GetDef(dynamic_selection, &quot;1&quot;, &quot;AI\\dynamic_selection&quot;);
-    mod_tdf-&gt;GetDef(use_modabstracts, &quot;0&quot;, &quot;AI\\use_mod_default&quot;);
-    mod_tdf-&gt;GetDef(absent_abstract, &quot;1&quot;, &quot;AI\\use_mod_default_if_absent&quot;);
-    mod_tdf-&gt;GetDef(rule_extreme_interpolate, &quot;1&quot;, &quot;AI\\rule_extreme_interpolate&quot;);
-    antistall = atoi(mod_tdf-&gt;SGetValueDef(&quot;4&quot;, &quot;AI\\antistall&quot;).c_str());
-    Max_Stall_TimeMobile = (float)atof(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\MaxStallTime&quot;).c_str());
-    Max_Stall_TimeIMMobile = (float)atof(mod_tdf-&gt;SGetValueDef(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\MaxStallTime&quot;), &quot;AI\\MaxStallTimeimmobile&quot;).c_str());
+	void CConfigData::Load(){
+		//
+		mod_tdf-&gt;GetDef(_abstract, &quot;1&quot;, &quot;AI\\abstract&quot;);
+		mod_tdf-&gt;GetDef(gaia, &quot;0&quot;, &quot;AI\\GAIA&quot;);
+		mod_tdf-&gt;GetDef(spacemod, &quot;0&quot;, &quot;AI\\spacemod&quot;);
+		mod_tdf-&gt;GetDef(mexfirst, &quot;0&quot;, &quot;AI\\first_attack_mexraid&quot;);
+		mod_tdf-&gt;GetDef(hardtarget, &quot;0&quot;, &quot;AI\\hard_target&quot;);
+		mod_tdf-&gt;GetDef(mexscouting, &quot;1&quot;, &quot;AI\\mexscouting&quot;);
+		mod_tdf-&gt;GetDef(dynamic_selection, &quot;1&quot;, &quot;AI\\dynamic_selection&quot;);
+		mod_tdf-&gt;GetDef(use_modabstracts, &quot;0&quot;, &quot;AI\\use_mod_default&quot;);
+		mod_tdf-&gt;GetDef(absent_abstract, &quot;1&quot;, &quot;AI\\use_mod_default_if_absent&quot;);
+		mod_tdf-&gt;GetDef(rule_extreme_interpolate, &quot;1&quot;, &quot;AI\\rule_extreme_interpolate&quot;);
+		antistall = atoi(mod_tdf-&gt;SGetValueDef(&quot;4&quot;, &quot;AI\\antistall&quot;).c_str());
+		Max_Stall_TimeMobile = (float)atof(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\MaxStallTime&quot;).c_str());
+		Max_Stall_TimeIMMobile = (float)atof(mod_tdf-&gt;SGetValueDef(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\MaxStallTime&quot;), &quot;AI\\MaxStallTimeimmobile&quot;).c_str());
 
-	fire_state_commanders = atoi(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\fire_state_commanders&quot;).c_str());
-    move_state_commanders = atoi(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\move_state_commanders&quot;).c_str());
-    scout_speed = (float)atof(mod_tdf-&gt;SGetValueDef(&quot;50&quot;, &quot;AI\\scout_speed&quot;).c_str());
+		fire_state_commanders = atoi(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\fire_state_commanders&quot;).c_str());
+		move_state_commanders = atoi(mod_tdf-&gt;SGetValueDef(&quot;0&quot;, &quot;AI\\move_state_commanders&quot;).c_str());
+		scout_speed = (float)atof(mod_tdf-&gt;SGetValueDef(&quot;50&quot;, &quot;AI\\scout_speed&quot;).c_str());
 
-	if(_abstract == true){
-		dynamic_selection = true;
-	}
+		if(_abstract == true){
+			dynamic_selection = true;
+		}
 
-	if(use_modabstracts == true){
-		_abstract = false;
+		if(use_modabstracts == true){
+			_abstract = false;
+		}
+	    
 	}
-    
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/CEconomy.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/CEconomy.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/CEconomy.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,194 +1,231 @@
-//////////////////////////////////////////////////////////////////////////
 #include &quot;../Core/include.h&quot;
 
-CEconomy::CEconomy(Global* GL){
-	G = GL;
-}
+/*
+AF 2004+
+LGPL 2
+*/
 
-btype CEconomy::Get(bool extreme,bool factory){
-	if(BuildMaker(extreme)==true){
-		return B_METAL_MAKER;
+namespace ntai {
+
+
+	CEconomy::CEconomy(Global* GL){
+		G = GL;
 	}
-	if(BuildMex(extreme)==true){
-		return B_MEX;
-	}
-	if(BuildPower(extreme)==true){
-		return B_POWER;
-	}
-	if(factory){
-		if(BuildFactory(extreme)==true){
-			return B_FACTORY;
+
+	btype CEconomy::Get(bool extreme,bool factory){
+
+		if(BuildMaker(extreme)){
+			return B_METAL_MAKER;
 		}
-		if (BuildEnergyStorage(extreme)==true){
-			return B_ESTORE;
+		if(BuildMex(extreme)){
+			return B_MEX;
 		}
-		if(BuildMetalStorage(extreme)==true){
-			return B_MSTORE;
+		if(BuildPower(extreme)){
+			return B_POWER;
 		}
+		if(factory){
+			if(BuildFactory(extreme)){
+				return B_FACTORY;
+			}
+			if (BuildEnergyStorage(extreme)){
+				return B_ESTORE;
+			}
+			if(BuildMetalStorage(extreme)){
+				return B_MSTORE;
+			}
+		}
+		return B_NA;
 	}
-	return B_NA;
-}
 
-bool CEconomy::BuildFactory(bool extreme){
-	NLOG(&quot;CEconomy::BuildFactory&quot;);
-	if(extreme == true){
-		float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\EXTREME\\factorymetal&quot;).c_str());
-		float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\EXTREME\\factoryenergy&quot;).c_str());
-		if(G-&gt;cb-&gt;GetMetal() &gt; G-&gt;cb-&gt;GetMetalStorage()*a){
-			if(G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b){
-				return true;
+	bool CEconomy::BuildFactory(bool extreme){
+		NLOG(&quot;CEconomy::BuildFactory&quot;);
+
+		if(extreme){
+			float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\EXTREME\\factorymetal&quot;).c_str());
+			float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\EXTREME\\factoryenergy&quot;).c_str());
+
+			if(G-&gt;cb-&gt;GetMetal() &gt; G-&gt;cb-&gt;GetMetalStorage()*a){
+				if(G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b){
+					return true;
+				}else{
+					return false;
+				}
 			}else{
 				return false;
 			}
 		}else{
-			return false;
-		}
-	}else{
-		float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\factorymetal&quot;).c_str());
-		float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\factoryenergy&quot;).c_str());
-		float c = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;7&quot;,&quot;ECONOMY\\RULES\\factorymetalgap&quot;).c_str());
-		if(G-&gt;cb-&gt;GetMetal() &gt; G-&gt;cb-&gt;GetMetalStorage()*a){
-			if(G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b){
+			float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\factorymetal&quot;).c_str());
+			float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\factoryenergy&quot;).c_str());
+			float c = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;7&quot;,&quot;ECONOMY\\RULES\\factorymetalgap&quot;).c_str());
+
+			if(G-&gt;cb-&gt;GetMetal() &gt; G-&gt;cb-&gt;GetMetalStorage()*a){
+				if(G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b){
+					return true;
+				}else{
+					return false;
+				}
+			}else if(G-&gt;Pl-&gt;GetMetalIncome() - G-&gt;cb-&gt;GetMetalUsage()*1.2f &gt; c){
 				return true;
 			}else{
 				return false;
 			}
-		}else if(G-&gt;Pl-&gt;GetMetalIncome() - G-&gt;cb-&gt;GetMetalUsage()*1.2f &gt; c){
-			return true;
-		}else{
-			return false;
 		}
+		return false;
 	}
-	return false;
-}
 
-bool CEconomy::BuildPower(bool extreme){
-	NLOG(&quot;CEconomy::BuildPower&quot;);
-	if(extreme == true){
-		float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.3&quot;,&quot;ECONOMY\\RULES\\EXTREME\\power&quot;).c_str());
-		if(G-&gt;cb-&gt;GetEnergy() &lt; G-&gt;cb-&gt;GetEnergyStorage()*x){ 
-			return true;
-		}else{
-			if(G-&gt;cb-&gt;GetEnergy()&lt;400.0f){
+	bool CEconomy::BuildPower(bool extreme){
+		NLOG(&quot;CEconomy::BuildPower&quot;);
+
+		if(extreme){
+			float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.3&quot;,&quot;ECONOMY\\RULES\\EXTREME\\power&quot;).c_str());
+			if(G-&gt;cb-&gt;GetEnergy() &lt; G-&gt;cb-&gt;GetEnergyStorage()*x){ 
 				return true;
+			}else{
+				if(G-&gt;cb-&gt;GetEnergy()&lt;400.0f){
+					return true;
+				}
+				if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; G-&gt;cb-&gt;GetEnergyUsage()*(1-x)){
+					return true;
+				}
+				return false;
 			}
-			if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; G-&gt;cb-&gt;GetEnergyUsage()*(1-x)){
-				return true;
-			}
-			return false;
-		}
-	}else{
-		float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.4&quot;,&quot;ECONOMY\\RULES\\power&quot;).c_str());
-		if(G-&gt;cb-&gt;GetEnergy() &lt; G-&gt;cb-&gt;GetEnergyStorage()*x){
-			return true;
 		}else{
-			if(G-&gt;cb-&gt;GetEnergy()&lt;500.0f){
+			float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.4&quot;,&quot;ECONOMY\\RULES\\power&quot;).c_str());
+			if(G-&gt;cb-&gt;GetEnergy() &lt; G-&gt;cb-&gt;GetEnergyStorage()*x){
 				return true;
+			}else{
+				if(G-&gt;cb-&gt;GetEnergy()&lt;500.0f){
+					return true;
+				}
+				if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; G-&gt;cb-&gt;GetEnergyUsage()*(1-x)){
+					return true;
+				}
+				return false;
 			}
-			if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; G-&gt;cb-&gt;GetEnergyUsage()*(1-x)){
-				return true;
-			}
-			return false;
 		}
 	}
-}
 
-bool CEconomy::BuildMex(bool extreme){
-	NLOG(&quot;CEconomy::BuildMex&quot;);
-	if(extreme == true){
-		float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.4&quot;,&quot;ECONOMY\\RULES\\EXTREME\\mex&quot;).c_str());
-		if(G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*x){ // if below 20% metal stored then yah we need mexes!!
-			return true;
-		}else{
-			if(G-&gt;cb-&gt;GetMetal() &lt; 400.0f){
+	bool CEconomy::BuildMex(bool extreme){
+		NLOG(&quot;CEconomy::BuildMex&quot;);
+
+		if(extreme){
+			float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.4&quot;,&quot;ECONOMY\\RULES\\EXTREME\\mex&quot;).c_str());
+			
+			// if below 20% metal stored then yah we need mexes!!
+			if(G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*x){
 				return true;
+			}else{
+				if(G-&gt;cb-&gt;GetMetal() &lt; 400.0f){
+					return true;
+				}
+				if(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage()*(1-x)){
+					return true;
+				}
+				return false;
 			}
-			if(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage()*(1-x)){
-				return true;
-			}
-			return false;
-		}
-	}else{
-		float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.5&quot;,&quot;ECONOMY\\RULES\\mex&quot;).c_str());
-		if(G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*x){ // if below 50% metal stored then yah we need mexes!!
-			return true;
 		}else{
-			if(G-&gt;cb-&gt;GetMetal() &lt; 500.0f){
+
+			float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.5&quot;,&quot;ECONOMY\\RULES\\mex&quot;).c_str());
+			
+			// if below 50% metal stored then yah we need mexes!!
+			if(G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*x){ 
 				return true;
+			}else{
+				if(G-&gt;cb-&gt;GetMetal() &lt; 500.0f){
+					return true;
+				}
+				if(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage()*(1-x)){
+					return true;
+				}
+				return false;
 			}
-			if(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage()*(1-x)){
-				return true;
-			}
-			return false;
 		}
+		return false;
 	}
-	return false;
-}
 
-bool CEconomy::BuildEnergyStorage(bool extreme){
-	NLOG(&quot;CEconomy::BuildEnergyStorage&quot;);
-	float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\energystorage&quot;).c_str());
-	if(G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage () * x){
-		// randomly do this so there's a 1/3 chance
-		int randnum = G-&gt;mrand()%4;
-		randnum = max(randnum,1);
-		if(G-&gt;cb-&gt;GetCurrentFrame()%randnum == 0){
-			return true;
+	bool CEconomy::BuildEnergyStorage(bool extreme){
+		NLOG(&quot;CEconomy::BuildEnergyStorage&quot;);
+		
+		/* for now I've used a half fudged rule I took from JCAI
+		 erm, take the amount of energy currently being used, then
+		 see how long it would take to drain away to zero if there
+		 was no energy income and if it's smaller than a threshold
+		 then say yes, else say no */
+		
+		float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\energystorage&quot;).c_str());
+		
+		if(G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage () * x){
+
+			// randomly do this so there's a 1/3 chance
+			int randnum = G-&gt;mrand()%4;
+			randnum = max(randnum,1);
+			return (G-&gt;cb-&gt;GetCurrentFrame()%randnum == 0);
+
 		}else{
 			return false;
 		}
-	}else{
-		return false;
+
 	}
-	// for now I've used a half fudged rule I took from JCAI
-	// erm, take the amount of energy currently being used, then see how long ti would take to drain away to zero if there was no energy income and if it's smaller than a threshold then say yes, else say no
-}
 
-bool CEconomy::BuildMetalStorage(bool extreme){
-	NLOG(&quot;CEconomy::BuildMetalStorage&quot;);
-	float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\metalstorage&quot;).c_str());
-	x = max(x,0.01f);
-	if(G-&gt;cb-&gt;GetMetal() &gt;G-&gt;cb-&gt;GetMetalStorage () * x){
-		int randnum = G-&gt;mrand()%4;
-		randnum = max(1,randnum);
-		if(G-&gt;cb-&gt;GetCurrentFrame()%randnum == 0){
-			return true;
+	bool CEconomy::BuildMetalStorage(bool extreme){
+		NLOG(&quot;CEconomy::BuildMetalStorage&quot;);
+
+		/* for now I've used a half fudged rule I took from JCAI
+		 erm, take the amount of metal currently being used, then
+		 see how long it would take to drain away to zero if there
+		 was no metal income and if it's smaller than a threshold
+		 then say yes, else say no */
+
+		float x = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\metalstorage&quot;).c_str());
+		x = max(x,0.01f);
+
+		if(G-&gt;cb-&gt;GetMetal() &gt;G-&gt;cb-&gt;GetMetalStorage () * x){
+			
+			// randomly do this so there's a 1/3 chance
+			int randnum = G-&gt;mrand()%4;
+			randnum = max(1,randnum);
+			return (G-&gt;cb-&gt;GetCurrentFrame()%randnum == 0);
+
 		}else{
 			return false;
 		}
-	}else{
-		return false;
+		
 	}
-	// for now I've used a half fudged rule I took from JCAI
-	// erm, take the amount of metal currently being used, then see how long it would take to drain away to zero if there was no metal income and if it's smaller than a threshold then say yes, else say no
-}
 
-bool CEconomy::BuildMaker(bool extreme){
-	NLOG(&quot;CEconomy::BuildMaker&quot;);
-	if(extreme == true){
-		float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.1&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makermetal&quot;).c_str());
-		float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makerenergy&quot;).c_str());
-		if((G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*a)&amp;&amp;(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage())){ // if below 10% metal stored then yah we need makers
-			if((G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b)&amp;&amp;(G-&gt;Pl-&gt;GetEnergyIncome() &gt; G-&gt;max_energy_use)){ // we need the energy to do this else we'll be even worse off with no metal or energy...
-				return true;
+	bool CEconomy::BuildMaker(bool extreme){
+		NLOG(&quot;CEconomy::BuildMaker&quot;);
+
+		if(extreme){
+			float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.1&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makermetal&quot;).c_str());
+			float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.8&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makerenergy&quot;).c_str());
+
+			// if below 10% metal stored then yah we need makers
+			if( (G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*a) &amp;&amp; (G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage()) ){
+				
+				// we need the energy to do this else we'll be even worse off with no metal or energy...
+				bool r = (G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b)&amp;&amp;(G-&gt;Pl-&gt;GetEnergyIncome() &gt; G-&gt;max_energy_use);
+				return r;
+
 			}else{
 				return false;
 			}
 		}else{
-			return false;
-		}
-	}else{
-		float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.3&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makermetal&quot;).c_str());
-		float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.75&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makerenergy&quot;).c_str());
-		if((G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*a)&amp;&amp;(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage())){ // if below 30% metal stored then yah we need makers
-			if((G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b)&amp;&amp;(G-&gt;Pl-&gt;GetEnergyIncome() &gt; G-&gt;cb-&gt;GetEnergyUsage())){ // we need the energy to do this else we'll be even worse off with no metal or energy...
-				return true;
+
+			float a = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.3&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makermetal&quot;).c_str());
+			float b = (float)atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;0.75&quot;,&quot;ECONOMY\\RULES\\EXTREME\\makerenergy&quot;).c_str());
+
+			// if below 30% metal stored then yah we need makers
+			if((G-&gt;cb-&gt;GetMetal() &lt; G-&gt;cb-&gt;GetMetalStorage()*a)&amp;&amp;(G-&gt;Pl-&gt;GetMetalIncome() &lt; G-&gt;cb-&gt;GetMetalUsage())){
+
+				// we need the energy to do this else we'll be even worse off with no metal or energy...
+				bool r = (G-&gt;cb-&gt;GetEnergy() &gt; G-&gt;cb-&gt;GetEnergyStorage()*b)&amp;&amp; (G-&gt;Pl-&gt;GetEnergyIncome() &gt; G-&gt;cb-&gt;GetEnergyUsage());
+				return r;
+
 			}else{
 				return false;
 			}
-		}else{
-			return false;
 		}
+		return false;
 	}
-	return false;
+
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Log.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Log.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Log.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,287 +1,289 @@
 #include &quot;../Core/include.h&quot;
 
-int Lmagic;
+namespace ntai {
+	int Lmagic;
 
-Log::Log(){
-    verbose = false;
-    First = false;
-}
+	Log::Log(){
+		verbose = false;
+		First = false;
+	}
 
-Log::~Log(){
-    G = 0;
-}
+	Log::~Log(){
+		G = 0;
+	}
 
-void Log::Set(Global* GL){
-    G = GL;
-    if(GL ==0){
-        int jk = 3;
-    }
-    if(G ==0){
-        int jk = 3;
-    }
-}
+	void Log::Set(Global* GL){
+		G = GL;
+		if(GL ==0){
+			int jk = 3;
+		}
+		if(G ==0){
+			int jk = 3;
+		}
+	}
 
-string Log::FrameTime(){
-    return &quot; &lt; Frame: &quot; + to_string(G-&gt;cb-&gt;GetCurrentFrame()) + &quot; &gt;&quot;;
-}
+	string Log::FrameTime(){
+		return &quot; &lt; Frame: &quot; + to_string(G-&gt;cb-&gt;GetCurrentFrame()) + &quot; &gt;&quot;;
+	}
 
-string Log::GameTime(){
-    int Time = G-&gt;cb-&gt;GetCurrentFrame();
-    Time = Time/30;
-    int Seconds = Time%60;
-    int Minutes = (Time/60)%60;
-    int hours = 0;
-    if(Time&gt;3600) hours = (Time-(Time%3600))/3600;
-    if(Seconds+Minutes+hours == 0){
-        return &quot;[-]&quot;;
-    }
-    string stime=&quot;[&quot;;
-    if(hours&gt;0){
-        if(hours&lt;10) stime += &quot;0&quot;;
-        stime += to_string(hours);
-        stime += &quot;:&quot;;
-    }
-    if(Minutes&lt;10){
-        stime += &quot;0&quot;;
-    }
-    stime += to_string(Minutes);
-    stime += &quot;:&quot;;
-    if(Seconds &lt;10){
-        stime += &quot;0&quot;;
-    }
-    stime += to_string(Seconds);
-    stime += &quot;]&quot;;
+	string Log::GameTime(){
+		int Time = G-&gt;cb-&gt;GetCurrentFrame();
+		Time = Time/30;
+		int Seconds = Time%60;
+		int Minutes = (Time/60)%60;
+		int hours = 0;
+		if(Time&gt;3600) hours = (Time-(Time%3600))/3600;
+		if(Seconds+Minutes+hours == 0){
+			return &quot;[-]&quot;;
+		}
+		string stime=&quot;[&quot;;
+		if(hours&gt;0){
+			if(hours&lt;10) stime += &quot;0&quot;;
+			stime += to_string(hours);
+			stime += &quot;:&quot;;
+		}
+		if(Minutes&lt;10){
+			stime += &quot;0&quot;;
+		}
+		stime += to_string(Minutes);
+		stime += &quot;:&quot;;
+		if(Seconds &lt;10){
+			stime += &quot;0&quot;;
+		}
+		stime += to_string(Seconds);
+		stime += &quot;]&quot;;
 
-    return stime;
-}
+		return stime;
+	}
 
-bool Log::FirstInstance(){
-    return First;
-}
+	bool Log::FirstInstance(){
+		return First;
+	}
 
-string GetSysTime(){
-    time_t now1;
-    time(&amp;now1);//struct
-    tm *now2;
-    now2 = localtime(&amp;now1);
-    string s = string(&quot;|&quot;)+to_string(now2-&gt;tm_hour)+ string(&quot;:&quot;)+ to_string(now2-&gt;tm_min)+string(&quot;:&quot;)+ to_string(now2-&gt;tm_sec)+string(&quot;|&quot;);
-    return s;
-}
+	string GetSysTime(){
+		time_t now1;
+		time(&amp;now1);//struct
+		tm *now2;
+		now2 = localtime(&amp;now1);
+		string s = string(&quot;|&quot;)+to_string(now2-&gt;tm_hour)+ string(&quot;:&quot;)+ to_string(now2-&gt;tm_min)+string(&quot;:&quot;)+ to_string(now2-&gt;tm_sec)+string(&quot;|&quot;);
+		return s;
+	}
 
-void Log::Open(bool plain){
-    char buffer[1000];
-    if( Lmagic != 95768){
-        Lmagic = 95768;
-        First = true;
-    }
-    if(plain == true){ // Textfile Logging
-        plaintext = true;
-        //		char c[400];
-        time_t now1;
-        time(&amp;now1);
-        struct tm *now2;
-        now2 = localtime(&amp;now1);
-        string filename = G-&gt;info-&gt;datapath + slash + &quot;Logs&quot; + slash;
+	void Log::Open(bool plain){
+		char buffer[1000];
+		if( Lmagic != 95768){
+			Lmagic = 95768;
+			First = true;
+		}
+		if(plain == true){ // Textfile Logging
+			plaintext = true;
+			//		char c[400];
+			time_t now1;
+			time(&amp;now1);
+			struct tm *now2;
+			now2 = localtime(&amp;now1);
+			string filename = G-&gt;info-&gt;datapath + slash + &quot;Logs&quot; + slash;
 
-        //             DDD MMM DD HH:MM:SS YYYY_X - NTAI.log
-        filename += to_string(now2-&gt;tm_mon+1)+&quot;-&quot; +to_string(now2-&gt;tm_mday) + &quot;-&quot; +to_string(now2-&gt;tm_year + 1900) +&quot;-&quot; +to_string(now2-&gt;tm_hour) +&quot;_&quot; +to_string(now2-&gt;tm_min) +&quot;[&quot;+to_string(G-&gt;Cached-&gt;team)+&quot;]XE9.79.log&quot;;
-        //sprintf(c, &quot;%2.2d-%2.2d-%4.4d %2.2d%2.2d [%d]XE9.79.log&quot;,
-        //		now2-&gt;tm_mon+1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour,
-        //		now2-&gt;tm_min, G-&gt;Cached-&gt;team);
-        //filename += c;
-        strcpy(buffer, filename.c_str());
-        G-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
-        logFile.open(buffer);
-        if(logFile.is_open() == false){
-            logFile.close();
-            logFile.open(buffer);
-            if(logFile.is_open() == false){
-                iprint(string(&quot;Error!!! &quot;) + filename + string(&quot; refused to open!&quot;));
-                verbose = true;
-                return;
-            }
-        }
-        header(&quot; :: NTAI XE9.79 Log File \n :: Programmed and maintained by AF/T.Nowell \n :: Copyright (C) 2004-7 Tom Nowell/AF \n&quot;);
-        logFile &lt;&lt; &quot; :: Game started: &quot; &lt;&lt; now2-&gt;tm_mday &lt;&lt; &quot;.&quot; &lt;&lt; now2-&gt;tm_mon &lt;&lt; &quot;.&quot; &lt;&lt; 1900 + now2-&gt;tm_year &lt;&lt; &quot;  &quot; &lt;&lt; now2-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; now2-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; now2-&gt;tm_sec &lt;&lt; endl &lt;&lt; endl &lt;&lt;  flush;
-        TdfParser cp(G);
-        cp.LoadFile(&quot;modinfo.tdf&quot;);
-        logFile &lt;&lt; &quot; :: &quot; &lt;&lt; cp.SGetValueMSG(&quot;MOD\\Name&quot;) &lt;&lt; endl &lt;&lt;  flush;
-        logFile &lt;&lt; &quot; :: &quot; &lt;&lt; cp.SGetValueMSG(&quot;MOD\\Description&quot;) &lt;&lt; endl &lt;&lt;  flush;
-        if(First == true) logFile &lt;&lt; &quot; :: First instance of NTAI&quot; &lt;&lt; endl;
-        startupscript = new TdfParser(G);
-        startupscript-&gt;LoadFile(&quot;script.txt&quot;);
-        vector&lt;string&gt; names;
-        for(int n=0; n&lt;MAX_TEAMS; n++){
-            string s = startupscript-&gt;SGetValueDef(&quot;&quot;, string(&quot;GAME\\PLAYER&quot;) + to_string(n) + &quot;\\name&quot;);
-            if(s != string(&quot;&quot;)){
-                names.push_back(s + &quot; : player :: &quot; + to_string(n));
-                PlayerNames[n] = s;
-            } else{
-                PlayerNames[n] = &quot;spring_engine&quot;;
-            }
-            logFile &lt;&lt; &quot; :: &quot; &lt;&lt; PlayerNames[n] &lt;&lt; endl;
-        }
-        logFile &lt;&lt; &quot; :: AI DLL's in game&quot; &lt;&lt; endl &lt;&lt;  flush;
-        vector&lt;string&gt; AInames;
-        for(int n=0; n&lt;MAX_TEAMS; n++){
-            string s = startupscript-&gt;SGetValueDef(&quot;&quot;, string(&quot;GAME\\TEAM&quot;) + to_string(n) + &quot;\\AIDLL&quot;);
-            if(s != string(&quot;&quot;)){
-                AInames.push_back(s + &quot; : AI :: &quot; + to_string(n));
-                logFile &lt;&lt; &quot; :: &quot;&lt;&lt;s &lt;&lt; &quot; : AI :: &quot; &lt;&lt; to_string(n) &lt;&lt; endl &lt;&lt;  flush;
-            }
-        }
-        logFile &lt;&lt; endl &lt;&lt;  flush;
-    }else{ // HTML logging
-        char c[400];
-        time_t now1;
-        time(&amp;now1);
-        struct tm *now2;
-        now2 = localtime(&amp;now1);
-        string filename = G-&gt;info-&gt;tdfpath;
-        filename += slash;
-        filename += &quot;Logs&quot;;
-        filename += slash;
-        //                                      DDD MMM DD HH:MM:SS YYYY_X - NTAI.htm
-        sprintf(c, &quot;%2.2d-%2.2d-%4.4d %2.2d%2.2d [%d] - NTAIXE9.79.htm&quot;,
-        now2-&gt;tm_mon+1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour,
-        now2-&gt;tm_min, G-&gt;Cached-&gt;team);
-        filename += c;
-        strcpy(buffer, filename.c_str());
-        G-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
-        logFile.open(buffer);
-        plaintext = false;
-        string mu =&quot;&lt;/table&gt;&lt;style type='text/css'&gt;\n&lt;!--\nbody,td,th {\n	font-family: sans-serif;\n	color: #111111;\nfont-size: 12px;\n\n}\nbody {\n	background-color: #FFFFFF;\n\n}\n.c {color: #FF2222}\n.e {color: #FFCC11}\n--&gt;\n&lt;/style&gt;\n&quot;;
-        mu+= &quot;&lt;b&gt;&lt;br&gt;&lt;br&gt;NTAI XE Log File &lt;br&gt;\n&lt;span class='c'&gt;Programmed and maintained by AF Copyright (C) 2006 AF&lt;br&gt;\nReleased under the GPL 2.0 Liscence &lt;/p&gt;&lt;/span&gt;&lt;/b&gt;&lt;br&gt; \n&lt;table width='98%'border='0' cellpadding='0' cellspacing='0' bordercolor='#999999'&gt;\n&quot;;
-        header(mu);
-        time_t tval;
-        char buf[128];
-        tval = time(NULL);
-        tm* now = localtime(&amp;tval);
-        strftime(buf, sizeof(buf), &quot;&lt;b&gt;&lt;p&gt;Game started: &lt;span class='c'&gt; %B %d %Y %I:%M %p.&lt;/p&gt;&lt;/span&gt;&lt;/b&gt;&quot;, now);
-        print(buf);
-        TdfParser cp(G);
-        cp.LoadFile(&quot;modinfo.tdf&quot;);
-        logFile &lt;&lt; &quot; :: &quot; &lt;&lt; cp.SGetValueMSG(&quot;MOD\\Name&quot;) &lt;&lt; endl &lt;&lt;  flush;
-        if(First == true) logFile &lt;&lt; &quot; :: First instance of NTAI&quot; &lt;&lt; endl &lt;&lt;  flush;
-    }
-}
+			//             DDD MMM DD HH:MM:SS YYYY_X - NTAI.log
+			filename += to_string(now2-&gt;tm_mon+1)+&quot;-&quot; +to_string(now2-&gt;tm_mday) + &quot;-&quot; +to_string(now2-&gt;tm_year + 1900) +&quot;-&quot; +to_string(now2-&gt;tm_hour) +&quot;_&quot; +to_string(now2-&gt;tm_min) +&quot;[&quot;+to_string(G-&gt;Cached-&gt;team)+&quot;]XE9.79.log&quot;;
+			//sprintf(c, &quot;%2.2d-%2.2d-%4.4d %2.2d%2.2d [%d]XE9.79.log&quot;,
+			//		now2-&gt;tm_mon+1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour,
+			//		now2-&gt;tm_min, G-&gt;Cached-&gt;team);
+			//filename += c;
+			strcpy(buffer, filename.c_str());
+			G-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
+			logFile.open(buffer);
+			if(logFile.is_open() == false){
+				logFile.close();
+				logFile.open(buffer);
+				if(logFile.is_open() == false){
+					iprint(string(&quot;Error!!! &quot;) + filename + string(&quot; refused to open!&quot;));
+					verbose = true;
+					return;
+				}
+			}
+			header(&quot; :: NTAI XE9.79 Log File \n :: Programmed and maintained by AF/T.Nowell \n :: Copyright (C) 2004-7 Tom Nowell/AF \n&quot;);
+			logFile &lt;&lt; &quot; :: Game started: &quot; &lt;&lt; now2-&gt;tm_mday &lt;&lt; &quot;.&quot; &lt;&lt; now2-&gt;tm_mon &lt;&lt; &quot;.&quot; &lt;&lt; 1900 + now2-&gt;tm_year &lt;&lt; &quot;  &quot; &lt;&lt; now2-&gt;tm_hour &lt;&lt; &quot;:&quot; &lt;&lt; now2-&gt;tm_min &lt;&lt; &quot;:&quot; &lt;&lt; now2-&gt;tm_sec &lt;&lt; endl &lt;&lt; endl &lt;&lt;  flush;
+			TdfParser cp(G);
+			cp.LoadFile(&quot;modinfo.tdf&quot;);
+			logFile &lt;&lt; &quot; :: &quot; &lt;&lt; cp.SGetValueMSG(&quot;MOD\\Name&quot;) &lt;&lt; endl &lt;&lt;  flush;
+			logFile &lt;&lt; &quot; :: &quot; &lt;&lt; cp.SGetValueMSG(&quot;MOD\\Description&quot;) &lt;&lt; endl &lt;&lt;  flush;
+			if(First == true) logFile &lt;&lt; &quot; :: First instance of NTAI&quot; &lt;&lt; endl;
+			startupscript = new TdfParser(G);
+			startupscript-&gt;LoadFile(&quot;script.txt&quot;);
+			vector&lt;string&gt; names;
+			for(int n=0; n&lt;MAX_TEAMS; n++){
+				string s = startupscript-&gt;SGetValueDef(&quot;&quot;, string(&quot;GAME\\PLAYER&quot;) + to_string(n) + &quot;\\name&quot;);
+				if(s != string(&quot;&quot;)){
+					names.push_back(s + &quot; : player :: &quot; + to_string(n));
+					PlayerNames[n] = s;
+				} else{
+					PlayerNames[n] = &quot;spring_engine&quot;;
+				}
+				logFile &lt;&lt; &quot; :: &quot; &lt;&lt; PlayerNames[n] &lt;&lt; endl;
+			}
+			logFile &lt;&lt; &quot; :: AI DLL's in game&quot; &lt;&lt; endl &lt;&lt;  flush;
+			vector&lt;string&gt; AInames;
+			for(int n=0; n&lt;MAX_TEAMS; n++){
+				string s = startupscript-&gt;SGetValueDef(&quot;&quot;, string(&quot;GAME\\TEAM&quot;) + to_string(n) + &quot;\\AIDLL&quot;);
+				if(s != string(&quot;&quot;)){
+					AInames.push_back(s + &quot; : AI :: &quot; + to_string(n));
+					logFile &lt;&lt; &quot; :: &quot;&lt;&lt;s &lt;&lt; &quot; : AI :: &quot; &lt;&lt; to_string(n) &lt;&lt; endl &lt;&lt;  flush;
+				}
+			}
+			logFile &lt;&lt; endl &lt;&lt;  flush;
+		}else{ // HTML logging
+			char c[400];
+			time_t now1;
+			time(&amp;now1);
+			struct tm *now2;
+			now2 = localtime(&amp;now1);
+			string filename = G-&gt;info-&gt;tdfpath;
+			filename += slash;
+			filename += &quot;Logs&quot;;
+			filename += slash;
+			//                                      DDD MMM DD HH:MM:SS YYYY_X - NTAI.htm
+			sprintf(c, &quot;%2.2d-%2.2d-%4.4d %2.2d%2.2d [%d] - NTAIXE9.79.htm&quot;,
+			now2-&gt;tm_mon+1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour,
+			now2-&gt;tm_min, G-&gt;Cached-&gt;team);
+			filename += c;
+			strcpy(buffer, filename.c_str());
+			G-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
+			logFile.open(buffer);
+			plaintext = false;
+			string mu =&quot;&lt;/table&gt;&lt;style type='text/css'&gt;\n&lt;!--\nbody,td,th {\n	font-family: sans-serif;\n	color: #111111;\nfont-size: 12px;\n\n}\nbody {\n	background-color: #FFFFFF;\n\n}\n.c {color: #FF2222}\n.e {color: #FFCC11}\n--&gt;\n&lt;/style&gt;\n&quot;;
+			mu+= &quot;&lt;b&gt;&lt;br&gt;&lt;br&gt;NTAI XE Log File &lt;br&gt;\n&lt;span class='c'&gt;Programmed and maintained by AF Copyright (C) 2006 AF&lt;br&gt;\nReleased under the GPL 2.0 Liscence &lt;/p&gt;&lt;/span&gt;&lt;/b&gt;&lt;br&gt; \n&lt;table width='98%'border='0' cellpadding='0' cellspacing='0' bordercolor='#999999'&gt;\n&quot;;
+			header(mu);
+			time_t tval;
+			char buf[128];
+			tval = time(NULL);
+			tm* now = localtime(&amp;tval);
+			strftime(buf, sizeof(buf), &quot;&lt;b&gt;&lt;p&gt;Game started: &lt;span class='c'&gt; %B %d %Y %I:%M %p.&lt;/p&gt;&lt;/span&gt;&lt;/b&gt;&quot;, now);
+			print(buf);
+			TdfParser cp(G);
+			cp.LoadFile(&quot;modinfo.tdf&quot;);
+			logFile &lt;&lt; &quot; :: &quot; &lt;&lt; cp.SGetValueMSG(&quot;MOD\\Name&quot;) &lt;&lt; endl &lt;&lt;  flush;
+			if(First == true) logFile &lt;&lt; &quot; :: First instance of NTAI&quot; &lt;&lt; endl &lt;&lt;  flush;
+		}
+	}
 
-void Log::print(string message){
-    if(message.empty() == true) return;
-    string gtime;
-    if(plaintext == true){
-        gtime = GameTime() + GetSysTime() +FrameTime() + message + &quot;\n&quot;;
-    }else{
-        gtime = &quot;\n&lt;tr&gt;&lt;th width='8%' scope='row'&gt;&lt;b&gt;&quot; + GameTime() + FrameTime() +&quot;&lt;/b&gt;&lt;/th&gt;\n&lt;td width='92%'&gt;&quot; + message + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;;
-    }
-    header(gtime);
-}
+	void Log::print(string message){
+		if(message.empty() == true) return;
+		string gtime;
+		if(plaintext == true){
+			gtime = GameTime() + GetSysTime() +FrameTime() + message + &quot;\n&quot;;
+		}else{
+			gtime = &quot;\n&lt;tr&gt;&lt;th width='8%' scope='row'&gt;&lt;b&gt;&quot; + GameTime() + FrameTime() +&quot;&lt;/b&gt;&lt;/th&gt;\n&lt;td width='92%'&gt;&quot; + message + &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;;
+		}
+		header(gtime);
+	}
 
-void Log::header(string message){
-    if(message.empty() == true) return;
-    if(verbose == true){
-        G-&gt;cb-&gt;SendTextMsg(message.c_str(), 1);
-    }
-    string gtime=&quot;&quot;;
-    if(plaintext == true){
-        gtime = message;
-    }else{
-        gtime = string(&quot;\n&lt;tr&gt;&lt;th width='100%' scope='row'&gt;&lt;b&gt;&quot;) + message + string(&quot;&lt;/th&gt;&lt;/tr&gt;\n&quot;);
-    }
-    if (logFile.is_open() == true){
-#ifdef TNLOG
-        cout &lt;&lt; gtime &lt;&lt; endl&lt;&lt; flush;
-#endif
-logFile &lt;&lt; gtime &lt;&lt; flush;
-    }
-}
+	void Log::header(string message){
+		if(message.empty() == true) return;
+		if(verbose == true){
+			G-&gt;cb-&gt;SendTextMsg(message.c_str(), 1);
+		}
+		string gtime=&quot;&quot;;
+		if(plaintext == true){
+			gtime = message;
+		}else{
+			gtime = string(&quot;\n&lt;tr&gt;&lt;th width='100%' scope='row'&gt;&lt;b&gt;&quot;) + message + string(&quot;&lt;/th&gt;&lt;/tr&gt;\n&quot;);
+		}
+		if (logFile.is_open() == true){
+	#ifdef TNLOG
+			cout &lt;&lt; gtime &lt;&lt; endl&lt;&lt; flush;
+	#endif
+	logFile &lt;&lt; gtime &lt;&lt; flush;
+		}
+	}
 
-void Log::iprint(string message){
-    string gtime = GameTime() + message;
-    G-&gt;cb-&gt;SendTextMsg(gtime.c_str(), 1);
-    print(message);
-}
+	void Log::iprint(string message){
+		string gtime = GameTime() + message;
+		G-&gt;cb-&gt;SendTextMsg(gtime.c_str(), 1);
+		print(message);
+	}
 
-void Log::Close(){
-    if(logFile.is_open() == true){
-        if(plaintext){
-            header(&quot; :: Closing LogFile...\n&quot;);
-        }else{
-            print(&quot;&lt;b&gt;&lt;span class='c'&gt;Closing logfile...&lt;/b&gt;&lt;/span&gt;&quot;);
-            header(&quot;\n&lt;/table&gt;&quot;);
-        }
-        logFile.close();
-    }
-}
+	void Log::Close(){
+		if(logFile.is_open() == true){
+			if(plaintext){
+				header(&quot; :: Closing LogFile...\n&quot;);
+			}else{
+				print(&quot;&lt;b&gt;&lt;span class='c'&gt;Closing logfile...&lt;/b&gt;&lt;/span&gt;&quot;);
+				header(&quot;\n&lt;/table&gt;&quot;);
+			}
+			logFile.close();
+		}
+	}
 
-void Log::Flush(){
-    if(logFile.is_open() == true){
-        logFile.flush();
-    }
-}
+	void Log::Flush(){
+		if(logFile.is_open() == true){
+			logFile.flush();
+		}
+	}
 
-void Log::Message(string msg, int player){
-    if(plaintext == true){
-        string m = &quot;[&quot; + PlayerNames[player] + &quot;] &quot; + GameTime() + FrameTime() +  &quot; :: &quot; + msg + &quot;\n&quot;;
-        header(m);
-        return;
-    }else{
-        print(&quot;&lt;span class='c'&gt;&quot; + msg + &quot;&lt;/span&gt;&quot;);
-    }
-}
+	void Log::Message(string msg, int player){
+		if(plaintext == true){
+			string m = &quot;[&quot; + PlayerNames[player] + &quot;] &quot; + GameTime() + FrameTime() +  &quot; :: &quot; + msg + &quot;\n&quot;;
+			header(m);
+			return;
+		}else{
+			print(&quot;&lt;span class='c'&gt;&quot; + msg + &quot;&lt;/span&gt;&quot;);
+		}
+	}
 
-void Log::eprint(string message){
-    if(plaintext == true){
-        G-&gt;cb-&gt;SendTextMsg(message.c_str(), 3);
-        print(message);
-        return;
-    } else{
-        G-&gt;cb-&gt;SendTextMsg(message.c_str(), 1000);
-        string msg = &quot;&lt;span class='e'&gt;&quot; + message + &quot;&lt;/span&gt;&quot;;
-        print(msg);
-    }
-}
+	void Log::eprint(string message){
+		if(plaintext == true){
+			G-&gt;cb-&gt;SendTextMsg(message.c_str(), 3);
+			print(message);
+			return;
+		} else{
+			G-&gt;cb-&gt;SendTextMsg(message.c_str(), 1000);
+			string msg = &quot;&lt;span class='e'&gt;&quot; + message + &quot;&lt;/span&gt;&quot;;
+			print(msg);
+		}
+	}
 
-Log&amp; Log::operator&lt;&lt; (const char* c){
-    this-&gt;header(c);
-    return *this;
-}
+	Log&amp; Log::operator&lt;&lt; (const char* c){
+		this-&gt;header(c);
+		return *this;
+	}
 
-Log&amp; Log::operator&lt;&lt; (string s){
-    this-&gt;header(s);
-    return *this;
-}
+	Log&amp; Log::operator&lt;&lt; (string s){
+		this-&gt;header(s);
+		return *this;
+	}
 
-Log&amp; Log::operator&lt;&lt; (int i){
-    string s = to_string(i);
-    header(s);
-    return *this;
-}
-Log&amp; Log::operator&lt;&lt; (uint i){
-    string s = to_string(i);
-    header(s);
-    return *this;
-}
+	Log&amp; Log::operator&lt;&lt; (int i){
+		string s = to_string(i);
+		header(s);
+		return *this;
+	}
+	Log&amp; Log::operator&lt;&lt; (uint i){
+		string s = to_string(i);
+		header(s);
+		return *this;
+	}
 
-Log&amp; Log::operator&lt;&lt; (float f){
-    header(to_string(f));
-    return *this;
-}
+	Log&amp; Log::operator&lt;&lt; (float f){
+		header(to_string(f));
+		return *this;
+	}
 
-Log&amp; Log::operator&lt;&lt; (float3 f){
-    header(to_string(f.x)+&quot;,&quot;+to_string(f.y)+&quot;,&quot;+to_string(f.z));
-    return *this;
-}
+	Log&amp; Log::operator&lt;&lt; (float3 f){
+		header(to_string(f.x)+&quot;,&quot;+to_string(f.y)+&quot;,&quot;+to_string(f.z));
+		return *this;
+	}
 
-bool Log::Verbose(){
-	if(verbose == true){
-		verbose = false;
-	}else{
-		verbose = true;
+	bool Log::Verbose(){
+		if(verbose == true){
+			verbose = false;
+		}else{
+			verbose = true;
+		}
+		return verbose;
 	}
-	return verbose;
-}
 
-bool Log::IsVerbose(){
-	return verbose;
-}
+	bool Log::IsVerbose(){
+		return verbose;
+	}
+}
\ No newline at end of file

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/TdfParser.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/TdfParser.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/TdfParser.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -20,369 +20,371 @@
 using boost::spirit::comment_p;
 using boost::spirit::parse_info;
 
-void TdfParser::TdfSection::print( std::ostream &amp; out )  const{
-  for( std::map&lt;std::string,TdfSection*&gt;::const_iterator it = sections.begin(), e=sections.end(); it != e; ++it ) {
-    out &lt;&lt; &quot;[&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;] {\n&quot;;
-    it-&gt;second-&gt;print(out);
-    out &lt;&lt; &quot;};&quot;;
-  }
-  for( std::map&lt;std::string,std::string&gt;::const_iterator it = values.begin(), e=values.end(); it != e; ++it ) {
-    out &lt;&lt; it-&gt;first  &lt;&lt; &quot;=&quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;;\n&quot;;
-  }
-}
+namespace ntai {
+	void TdfParser::TdfSection::print( std::ostream &amp; out )  const{
+	  for( std::map&lt;std::string,TdfSection*&gt;::const_iterator it = sections.begin(), e=sections.end(); it != e; ++it ) {
+		out &lt;&lt; &quot;[&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;] {\n&quot;;
+		it-&gt;second-&gt;print(out);
+		out &lt;&lt; &quot;};&quot;;
+	  }
+	  for( std::map&lt;std::string,std::string&gt;::const_iterator it = values.begin(), e=values.end(); it != e; ++it ) {
+		out &lt;&lt; it-&gt;first  &lt;&lt; &quot;=&quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;;\n&quot;;
+	  }
+	}
 
-TdfParser::TdfSection* TdfParser::TdfSection::construct_subsection( std::string const&amp; name )
-{
-  std::string lowerd_name = name;
-	std::transform(lowerd_name.begin(), lowerd_name.end(), lowerd_name.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-  std::map&lt;std::string,TdfSection*&gt;::iterator it = sections.find(lowerd_name);
-  if( it != sections.end() )
-    return it-&gt;second;
-  else {
-    TdfSection* ret = new TdfSection;
-    sections[lowerd_name] = ret;
-    return ret;
-  }
-}
+	TdfParser::TdfSection* TdfParser::TdfSection::construct_subsection( std::string const&amp; name )
+	{
+	  std::string lowerd_name = name;
+		std::transform(lowerd_name.begin(), lowerd_name.end(), lowerd_name.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+	  std::map&lt;std::string,TdfSection*&gt;::iterator it = sections.find(lowerd_name);
+	  if( it != sections.end() )
+		return it-&gt;second;
+	  else {
+		TdfSection* ret = new TdfSection;
+		sections[lowerd_name] = ret;
+		return ret;
+	  }
+	}
 
-void TdfParser::TdfSection::add_name_value(std::string const&amp; name, std::string&amp; value )
-{
-  std::string lowerd_name = name;
-	std::transform(lowerd_name.begin(), lowerd_name.end(), lowerd_name.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-  values[lowerd_name] = value;
-}
+	void TdfParser::TdfSection::add_name_value(std::string const&amp; name, std::string&amp; value )
+	{
+	  std::string lowerd_name = name;
+		std::transform(lowerd_name.begin(), lowerd_name.end(), lowerd_name.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+	  values[lowerd_name] = value;
+	}
 
 
 
-TdfParser::~TdfParser()
-{
-}
+	TdfParser::~TdfParser()
+	{
+	}
 
-TdfParser::TdfSection::~TdfSection()
-{
-  for( std::map&lt;std::string,TdfSection*&gt;::iterator it = sections.begin(), e=sections.end(); it != e; ++it )
-    delete it-&gt;second;
-}
+	TdfParser::TdfSection::~TdfSection()
+	{
+	  for( std::map&lt;std::string,TdfSection*&gt;::iterator it = sections.begin(), e=sections.end(); it != e; ++it )
+		delete it-&gt;second;
+	}
 
-TdfParser::TdfParser(Global* G) {
-	this-&gt;G = G;
-}
+	TdfParser::TdfParser(Global* G) {
+		this-&gt;G = G;
+	}
 
-void TdfParser::print( std::ostream &amp; out ) const {
-	root_section.print( out );
-}
+	void TdfParser::print( std::ostream &amp; out ) const {
+		root_section.print( out );
+	}
 
-TdfParser::TdfParser(Global* G,std::string const&amp; filename){
-	this-&gt;G = G;
-	LoadFile( filename );
-}
+	TdfParser::TdfParser(Global* G,std::string const&amp; filename){
+		this-&gt;G = G;
+		LoadFile( filename );
+	}
 
-void TdfParser::LoadFile(std::string const&amp; filename){
-	this-&gt;filename = filename;
-	int size = G-&gt;cb-&gt;GetFileSize(filename.c_str());
-	if(size == -1){
-		G-&gt;L.print(&quot;file &quot; + filename + &quot; not found&quot;);
+	void TdfParser::LoadFile(std::string const&amp; filename){
+		this-&gt;filename = filename;
+		int size = G-&gt;cb-&gt;GetFileSize(filename.c_str());
+		if(size == -1){
+			G-&gt;L.print(&quot;file &quot; + filename + &quot; not found&quot;);
+			return;
+		}
+		char* c = new char[size];
+		G-&gt;cb-&gt;ReadFile(filename.c_str(),c,size);
+		LoadBuffer(c,(std::size_t)size);
 		return;
 	}
-	char* c = new char[size];
-	G-&gt;cb-&gt;ReadFile(filename.c_str(),c,size);
-	LoadBuffer(c,(std::size_t)size);
-	return;
-}
 
-void TdfParser::LoadVirtualFile(std::string const&amp; filename){
-	this-&gt;filename = filename;
-	int size = G-&gt;cb-&gt;GetFileSize(filename.c_str());
-	if(size == -1){
-		G-&gt;L.print(&quot;file &quot; + filename + &quot; not found&quot;);
+	void TdfParser::LoadVirtualFile(std::string const&amp; filename){
+		this-&gt;filename = filename;
+		int size = G-&gt;cb-&gt;GetFileSize(filename.c_str());
+		if(size == -1){
+			G-&gt;L.print(&quot;file &quot; + filename + &quot; not found&quot;);
+			return;
+		}
+		char* c = new char[size];
+		G-&gt;cb-&gt;ReadFile(filename.c_str(),c,size);
+		LoadBuffer(c,(std::size_t)size);
 		return;
 	}
-	char* c = new char[size];
-	G-&gt;cb-&gt;ReadFile(filename.c_str(),c,size);
-	LoadBuffer(c,(std::size_t)size);
-	return;
-}
 
-TdfParser::TdfParser(Global* G, char const* buf, std::size_t size) {
-	this-&gt;G = G;
-	LoadBuffer( buf, size );
-}
+	TdfParser::TdfParser(Global* G, char const* buf, std::size_t size) {
+		this-&gt;G = G;
+		LoadBuffer( buf, size );
+	}
 
-void TdfParser::LoadBuffer( char const* buf, std::size_t size){
-	this-&gt;filename = &quot;buffer&quot;;
-	std::list&lt;std::string&gt; junk_data;
-	tdf_grammar grammar( &amp;root_section, &amp;junk_data );
+	void TdfParser::LoadBuffer( char const* buf, std::size_t size){
+		this-&gt;filename = &quot;buffer&quot;;
+		std::list&lt;std::string&gt; junk_data;
+		tdf_grammar grammar( &amp;root_section, &amp;junk_data );
 
-	std::string message;
+		std::string message;
 
-	boost::spirit::position_iterator2&lt;char const*&gt; error_it( buf, buf + size, filename );
+		boost::spirit::position_iterator2&lt;char const*&gt; error_it( buf, buf + size, filename );
 
-	boost::spirit::parse_info&lt;char const*&gt; info;
-	try {
-		info = parse(
-			buf
-			, buf + size
-			, grammar
-			, space_p
-			|  comment_p(&quot;/*&quot;, &quot;*/&quot;)           // rule for C-comments
-			|  comment_p(&quot;//&quot;)
-			) ;
-	}catch( boost::spirit::parser_error&lt;tdf_grammar::Errors, char *&gt; &amp; e ) {
-		// thrown by assertion parsers in tdf_grammar
+		boost::spirit::parse_info&lt;char const*&gt; info;
+		try {
+			info = parse(
+				buf
+				, buf + size
+				, grammar
+				, space_p
+				|  comment_p(&quot;/*&quot;, &quot;*/&quot;)           // rule for C-comments
+				|  comment_p(&quot;//&quot;)
+				) ;
+		}catch( boost::spirit::parser_error&lt;tdf_grammar::Errors, char *&gt; &amp; e ) {
+			// thrown by assertion parsers in tdf_grammar
 
-		switch(e.descriptor) {
-			case tdf_grammar::semicolon_expected: message = &quot;semicolon expected&quot;; break;
-			case tdf_grammar::equals_sign_expected: message = &quot;equals sign in name value pair expected&quot;; break;
-			case tdf_grammar::square_bracket_expected: message = &quot;square bracket to close section name expected&quot;; break;
-			case tdf_grammar::brace_expected: message = &quot;brace or further name value pairs expected&quot;; break;
-		};
+			switch(e.descriptor) {
+				case tdf_grammar::semicolon_expected: message = &quot;semicolon expected&quot;; break;
+				case tdf_grammar::equals_sign_expected: message = &quot;equals sign in name value pair expected&quot;; break;
+				case tdf_grammar::square_bracket_expected: message = &quot;square bracket to close section name expected&quot;; break;
+				case tdf_grammar::brace_expected: message = &quot;brace or further name value pairs expected&quot;; break;
+			};
 
 
-		for( size_t  i = 0;i != size;  ++i,++error_it );
+			for( size_t  i = 0;i != size;  ++i,++error_it );
 
-	}
+		}
 
 
-	for(list&lt;string&gt;::const_iterator it = junk_data.begin(), e = junk_data.end(); it !=e ; ++it ){
-		std::string temp = boost::trim_copy( *it );
-		if( ! temp.empty() ) {
-			G-&gt;L.eprint(&quot;Junk in &quot;+ filename +  &quot; :&quot; + temp);
+		for(list&lt;string&gt;::const_iterator it = junk_data.begin(), e = junk_data.end(); it !=e ; ++it ){
+			std::string temp = boost::trim_copy( *it );
+			if( ! temp.empty() ) {
+				G-&gt;L.eprint(&quot;Junk in &quot;+ filename +  &quot; :&quot; + temp);
+			}
 		}
-	}
 
-	if(!message.empty())
-	G-&gt;L.eprint(message + &quot; in &quot; +filename);
-	//throw parse_error( , error_it.get_currentline(), error_it.get_position().line, error_it.get_position().column, filename );
-	
-	if(!info.full){
-		boost::spirit::position_iterator2&lt;char const*&gt; error_it( buf, buf + size, filename );
-		for( size_t i = 0; i != size; ++i,++error_it );
-		G-&gt;L.eprint(&quot;error in &quot; +filename);
-	//	throw parse_error( error_it.get_currentline(), error_it.get_position().line, error_it.get_position().column, filename );
+		if(!message.empty())
+		G-&gt;L.eprint(message + &quot; in &quot; +filename);
+		//throw parse_error( , error_it.get_currentline(), error_it.get_position().line, error_it.get_position().column, filename );
+		
+		if(!info.full){
+			boost::spirit::position_iterator2&lt;char const*&gt; error_it( buf, buf + size, filename );
+			for( size_t i = 0; i != size; ++i,++error_it );
+			G-&gt;L.eprint(&quot;error in &quot; +filename);
+		//	throw parse_error( error_it.get_currentline(), error_it.get_position().line, error_it.get_position().column, filename );
+		}
 	}
-}
 
-//find value, display messagebox if no such value found
-std::string TdfParser::SGetValueMSG(std::string const&amp; location){
-  std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::string value=&quot;&quot;;
-	bool found = SGetValue(value, lowerd);
-	if(!found){
-		G-&gt;L.print(value);
-		return string(&quot;&quot;);
+	//find value, display messagebox if no such value found
+	std::string TdfParser::SGetValueMSG(std::string const&amp; location){
+	  std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::string value=&quot;&quot;;
+		bool found = SGetValue(value, lowerd);
+		if(!found){
+			G-&gt;L.print(value);
+			return string(&quot;&quot;);
+		}
+		return value;
 	}
-	return value;
-}
 
-//find value, return default value if no such value found
-std::string TdfParser::SGetValueDef(std::string const&amp; defaultvalue, std::string const&amp; location){
-  std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::string value;
-	bool found = SGetValue(value, lowerd);
-	if(!found){
-		value = defaultvalue;
+	//find value, return default value if no such value found
+	std::string TdfParser::SGetValueDef(std::string const&amp; defaultvalue, std::string const&amp; location){
+	  std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::string value;
+		bool found = SGetValue(value, lowerd);
+		if(!found){
+			value = defaultvalue;
+		}
+		return value;
 	}
-	return value;
-}
 
-//finds a value in the file, if not found returns false, and errormessages is returned in value
-/*bool TdfParser::GetValue(std::string &amp;value, ...)
-{
-	std::string searchpath; //for errormessages
-	va_list loc;
-	va_start(loc, value);
-	int numargs=0;
-	while(va_arg(loc, char*)) //determine number of arguments
-		numargs++;
-	va_start(loc, value);
-	TdfSection *sectionptr;
-	for(int i=0; i&lt;numargs-1; i++)
+	//finds a value in the file, if not found returns false, and errormessages is returned in value
+	/*bool TdfParser::GetValue(std::string &amp;value, ...)
 	{
+		std::string searchpath; //for errormessages
+		va_list loc;
+		va_start(loc, value);
+		int numargs=0;
+		while(va_arg(loc, char*)) //determine number of arguments
+			numargs++;
+		va_start(loc, value);
+		TdfSection *sectionptr;
+		for(int i=0; i&lt;numargs-1; i++)
+		{
+			char *arg = va_arg(loc, char*);
+			searchpath += '\\';
+			searchpath += arg;
+			sectionptr = sections[arg];
+			if(sectionptr==NULL)
+			{
+				value = &quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename;
+				return false;
+			}
+		}
 		char *arg = va_arg(loc, char*);
+		std::string svalue = sectionptr-&gt;values[arg];
 		searchpath += '\\';
 		searchpath += arg;
-		sectionptr = sections[arg];
-		if(sectionptr==NULL)
+		if(svalue == &quot;&quot;)
 		{
-			value = &quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename;
+			value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
 			return false;
 		}
-	}
-	char *arg = va_arg(loc, char*);
-	std::string svalue = sectionptr-&gt;values[arg];
-	searchpath += '\\';
-	searchpath += arg;
-	if(svalue == &quot;&quot;)
+		value = svalue;
+		return true;
+	}*/
+
+	/*void TdfParser::Test()
 	{
-		value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
-		return false;
-	}
-	value = svalue;
-	return true;
-}*/
+		TdfSection *unitinfo = sections[&quot;UNITINFO&quot;];
+		TdfSection *weapons = unitinfo-&gt;sections[&quot;WEAPONS&quot;];
+		std::string mo = weapons-&gt;values[&quot;weapon1&quot;];
+	}*/
 
-/*void TdfParser::Test()
-{
-	TdfSection *unitinfo = sections[&quot;UNITINFO&quot;];
-	TdfSection *weapons = unitinfo-&gt;sections[&quot;WEAPONS&quot;];
-	std::string mo = weapons-&gt;values[&quot;weapon1&quot;];
-}*/
+	//finds a value in the file , if not found returns false, and errormessages is returned in value
+	//location of value is sent as a string &quot;section\section\value&quot;
+	bool TdfParser::SGetValue(std::string &amp;value, std::string const&amp; location){
+		std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::string searchpath; //for errormessages
 
-//finds a value in the file , if not found returns false, and errormessages is returned in value
-//location of value is sent as a string &quot;section\section\value&quot;
-bool TdfParser::SGetValue(std::string &amp;value, std::string const&amp; location){
-	std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::string searchpath; //for errormessages
-
-	//split the location string
-	std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
-	if(root_section.sections.find(loclist[0]) == root_section.sections.end()){
-		value = &quot;&quot;;
-		//G-&gt;L.print(&quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename);
-		return false;
-	}
-	TdfSection *sectionptr = root_section.sections[loclist[0]];
-	searchpath = loclist[0];
-	for(unsigned int i=1; i&lt;loclist.size()-1; i++){
-		//const char *arg = loclist[i].c_str();
-		searchpath += '\\';
-		searchpath += loclist[i];
-		if(sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()){
+		//split the location string
+		std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
+		if(root_section.sections.find(loclist[0]) == root_section.sections.end()){
 			value = &quot;&quot;;
-			//G-&gt;L.print(&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename);
+			//G-&gt;L.print(&quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename);
 			return false;
 		}
-		sectionptr = sectionptr-&gt;sections[loclist[i]];
+		TdfSection *sectionptr = root_section.sections[loclist[0]];
+		searchpath = loclist[0];
+		for(unsigned int i=1; i&lt;loclist.size()-1; i++){
+			//const char *arg = loclist[i].c_str();
+			searchpath += '\\';
+			searchpath += loclist[i];
+			if(sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()){
+				value = &quot;&quot;;
+				//G-&gt;L.print(&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename);
+				return false;
+			}
+			sectionptr = sectionptr-&gt;sections[loclist[i]];
+		}
+		searchpath += '\\';
+		searchpath += loclist[loclist.size()-1];
+		if(sectionptr-&gt;values.find(loclist[loclist.size()-1]) == sectionptr-&gt;values.end()){
+			value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
+			return false;
+		}
+			std::string svalue = sectionptr-&gt;values[loclist[loclist.size()-1]];
+		value = svalue;
+		return true;
 	}
-	searchpath += '\\';
-	searchpath += loclist[loclist.size()-1];
-	if(sectionptr-&gt;values.find(loclist[loclist.size()-1]) == sectionptr-&gt;values.end()){
-		value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
-		return false;
-	}
-        std::string svalue = sectionptr-&gt;values[loclist[loclist.size()-1]];
-	value = svalue;
-	return true;
-}
 
-//return a map with all values in section
-const std::map&lt;std::string, std::string&gt; TdfParser::GetAllValues(std::string const&amp; location){
-  std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::map&lt;std::string, std::string&gt; emptymap;
-	std::string searchpath; //for errormessages
-	std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
-	if(root_section.sections.find(loclist[0]) == root_section.sections.end()){
-//		handleerror(hWnd, (&quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename).c_str(), &quot;Sun parsing error&quot;, MBF_OK);
-	//	info-&gt;AddLine (&quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename);
-		return emptymap;
-	}
-	TdfSection *sectionptr = root_section.sections[loclist[0]];
-	searchpath = loclist[0];
-	for(unsigned int i=1; i&lt;loclist.size(); i++){
-		searchpath += '\\';
-		searchpath += loclist[i];
-		if(sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()){
-//			handleerror(hWnd, (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename).c_str(), &quot;Sun parsing error&quot;, MBF_OK);
-			//info-&gt;AddLine (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename);
+	//return a map with all values in section
+	const std::map&lt;std::string, std::string&gt; TdfParser::GetAllValues(std::string const&amp; location){
+	  std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::map&lt;std::string, std::string&gt; emptymap;
+		std::string searchpath; //for errormessages
+		std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
+		if(root_section.sections.find(loclist[0]) == root_section.sections.end()){
+	//		handleerror(hWnd, (&quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename).c_str(), &quot;Sun parsing error&quot;, MBF_OK);
+		//	info-&gt;AddLine (&quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename);
 			return emptymap;
 		}
-		sectionptr = sectionptr-&gt;sections[loclist[i]];
+		TdfSection *sectionptr = root_section.sections[loclist[0]];
+		searchpath = loclist[0];
+		for(unsigned int i=1; i&lt;loclist.size(); i++){
+			searchpath += '\\';
+			searchpath += loclist[i];
+			if(sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()){
+	//			handleerror(hWnd, (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename).c_str(), &quot;Sun parsing error&quot;, MBF_OK);
+				//info-&gt;AddLine (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename);
+				return emptymap;
+			}
+			sectionptr = sectionptr-&gt;sections[loclist[i]];
+		}
+		return sectionptr-&gt;values;
 	}
-	return sectionptr-&gt;values;
-}
 
-//return vector with all section names in it
-std::vector&lt;std::string&gt; TdfParser::GetSectionList(std::string const&amp; location){
-  std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
-	std::vector&lt;std::string&gt; returnvec;
-	std::map&lt;std::string,TdfSection*&gt; *sectionsptr = &amp;root_section.sections;
-	if(loclist[0].compare(&quot;&quot;)!=0)	{
- 		std::string searchpath;// = loclist[0];
-		for(unsigned int i=0; i&lt;loclist.size(); i++){
-			searchpath += loclist[i];
-			if(sectionsptr-&gt;find(loclist[i]) == sectionsptr-&gt;end()){
-//				handleerror(hWnd, (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename).c_str(), &quot;Sun parsing error&quot;, MBF_OK);
-			//	info-&gt;AddLine (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename);
-        		return returnvec;
+	//return vector with all section names in it
+	std::vector&lt;std::string&gt; TdfParser::GetSectionList(std::string const&amp; location){
+	  std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
+		std::vector&lt;std::string&gt; returnvec;
+		std::map&lt;std::string,TdfSection*&gt; *sectionsptr = &amp;root_section.sections;
+		if(loclist[0].compare(&quot;&quot;)!=0)	{
+ 			std::string searchpath;// = loclist[0];
+			for(unsigned int i=0; i&lt;loclist.size(); i++){
+				searchpath += loclist[i];
+				if(sectionsptr-&gt;find(loclist[i]) == sectionsptr-&gt;end()){
+	//				handleerror(hWnd, (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename).c_str(), &quot;Sun parsing error&quot;, MBF_OK);
+				//	info-&gt;AddLine (&quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename);
+        			return returnvec;
+				}
+				sectionsptr = &amp;sectionsptr-&gt;find(loclist[i])-&gt;second-&gt;sections;
+        			searchpath += '\\';
 			}
-			sectionsptr = &amp;sectionsptr-&gt;find(loclist[i])-&gt;second-&gt;sections;
-        		searchpath += '\\';
 		}
+		std::map&lt;std::string,TdfSection*&gt;::iterator it;
+		for(it=sectionsptr-&gt;begin(); it!=sectionsptr-&gt;end(); it++){
+			returnvec.push_back(it-&gt;first);
+			std::transform(returnvec.back().begin(), returnvec.back().end(), returnvec.back().begin(), (int (*)(int))std::tolower);
+		}
+		return returnvec;
 	}
-	std::map&lt;std::string,TdfSection*&gt;::iterator it;
-	for(it=sectionsptr-&gt;begin(); it!=sectionsptr-&gt;end(); it++){
-		returnvec.push_back(it-&gt;first);
-		std::transform(returnvec.back().begin(), returnvec.back().end(), returnvec.back().begin(), (int (*)(int))std::tolower);
-	}
-	return returnvec;
-}
 
-bool TdfParser::SectionExist(std::string const&amp; location){
-  std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
-	if(root_section.sections.find(loclist[0]) == root_section.sections.end()){
-		return false;
-	}
-	TdfSection *sectionptr = root_section.sections[loclist[0]];
-	for(unsigned int i=1; i&lt;loclist.size(); i++){
-		if(sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()){
+	bool TdfParser::SectionExist(std::string const&amp; location){
+	  std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::vector&lt;std::string&gt; loclist = GetLocationVector(lowerd);
+		if(root_section.sections.find(loclist[0]) == root_section.sections.end()){
 			return false;
 		}
-		sectionptr = sectionptr-&gt;sections[loclist[i]];
+		TdfSection *sectionptr = root_section.sections[loclist[0]];
+		for(unsigned int i=1; i&lt;loclist.size(); i++){
+			if(sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()){
+				return false;
+			}
+			sectionptr = sectionptr-&gt;sections[loclist[i]];
+		}
+		return true;
 	}
-	return true;
-}
 
-std::vector&lt;std::string&gt; TdfParser::GetLocationVector(std::string const&amp; location){
-  std::string lowerd = location;
-	std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
-	std::vector&lt;std::string&gt; loclist;
-	int start = 0;
-	int next = 0;
+	std::vector&lt;std::string&gt; TdfParser::GetLocationVector(std::string const&amp; location){
+	  std::string lowerd = location;
+		std::transform(lowerd.begin(), lowerd.end(), lowerd.begin(), static_cast&lt;int (*)(int)&gt;(std::tolower));
+		std::vector&lt;std::string&gt; loclist;
+		int start = 0;
+		int next = 0;
 
-	while((next = lowerd.find_first_of(&quot;\\&quot;, start)) != (int)std::string::npos){
-		loclist.push_back(lowerd.substr(start, next-start));
-		start = next+1;
+		while((next = lowerd.find_first_of(&quot;\\&quot;, start)) != (int)std::string::npos){
+			loclist.push_back(lowerd.substr(start, next-start));
+			start = next+1;
+		}
+		loclist.push_back(lowerd.substr(start));
+
+	  return loclist;
 	}
-	loclist.push_back(lowerd.substr(start));
 
-  return loclist;
-}
+	/*
+	template&lt;typename T&gt;
+	void TdfParser::GetMsg(T&amp; value, const std::string&amp; key)
+	{
+		std::string str;
+		str = SGetValueMSG(key);
+		std::stringstream stream;
+		stream &lt;&lt; str;
+		stream &gt;&gt; value;
+	}
 
-/*
-template&lt;typename T&gt;
-void TdfParser::GetMsg(T&amp; value, const std::string&amp; key)
-{
-	std::string str;
-	str = SGetValueMSG(key);
-	std::stringstream stream;
-	stream &lt;&lt; str;
-	stream &gt;&gt; value;
-}
+	template&lt;typename T&gt;
+	void TdfParser::GetDef(T&amp; value, const std::string&amp; key, const std::string&amp; defvalue)
+	{
+		std::string str;
+		str = SGetValueDef(key, defvalue);
+		std::stringstream stream;
+		stream &lt;&lt; str;
+		stream &gt;&gt; value;
+	}*/
 
-template&lt;typename T&gt;
-void TdfParser::GetDef(T&amp; value, const std::string&amp; key, const std::string&amp; defvalue)
-{
-	std::string str;
-	str = SGetValueDef(key, defvalue);
-	std::stringstream stream;
-	stream &lt;&lt; str;
-	stream &gt;&gt; value;
-}*/
-
-float3 TdfParser::GetFloat3(float3 def, std::string const&amp; location){
-	std::string s=SGetValueDef(&quot;&quot;,location);
-	if(s.empty()){
-		return def;
+	float3 TdfParser::GetFloat3(float3 def, std::string const&amp; location){
+		std::string s=SGetValueDef(&quot;&quot;,location);
+		if(s.empty()){
+			return def;
+		}
+		float3 ret;
+		ParseArray(s,&amp;ret.x,3);
+		return ret;
 	}
-	float3 ret;
-	ParseArray(s,&amp;ret.x,3);
-	return ret;
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/DTHandler.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/DTHandler.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/DTHandler.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,150 +1,149 @@
 #include &quot;../../Core/include.h&quot;
 
-//bool CDTHandler::NoDT = false;
+namespace ntai {
 
-float3 CDTHandler::GetDTBuildSite(float3 pos){
-	if(DTRings.empty() == true) return UpVector;
-	if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
-		return UpVector;
+	float3 CDTHandler::GetDTBuildSite(float3 pos){
+		if(DTRings.empty() == true) return UpVector;
+		if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+			return UpVector;
+		}
+		vector&lt;float3&gt; locations;
+		for(vector&lt;DTRing&gt;::iterator i = this-&gt;DTRings.begin(); i != DTRings.end(); ++i){
+			// go through DT Rings and add all locations without a DT on them to the locations container;
+			for(vector&lt;float3&gt;::iterator d = i-&gt;DTPos.begin(); d != i-&gt;DTPos.end(); ++d){
+				int* f = new int[3];
+				int h = G-&gt;cb-&gt;GetFeatures(f,2,*d,40);
+				delete [] f;
+				if(h == 0) locations.push_back(*d);
+			}
+		}
+		if(locations.empty()==true) return UpVector;
+		float3 closest = locations.front();
+		
+		float distance = pos.distance2D(closest);
+		float tempdist=0;
+		for(vector&lt;float3&gt;::iterator j = locations.begin(); j != locations.end(); ++j){
+			tempdist = j-&gt;distance2D(pos);
+			if(tempdist &lt; distance){
+				distance = tempdist;
+				closest = *j;
+			}
+		}
+		
+		return closest;
 	}
-	vector&lt;float3&gt; locations;
-	for(vector&lt;DTRing&gt;::iterator i = this-&gt;DTRings.begin(); i != DTRings.end(); ++i){
-		// go through DT Rings and add all locations without a DT on them to the locations container;
-		for(vector&lt;float3&gt;::iterator d = i-&gt;DTPos.begin(); d != i-&gt;DTPos.end(); ++d){
-			int* f = new int[3];
-			int h = G-&gt;cb-&gt;GetFeatures(f,2,*d,40);
-			delete [] f;
-			if(h == 0) locations.push_back(*d);
+
+	CDTHandler::CDTHandler(Global* GL){
+		//NLOG(&quot;CDTHandler::CDTHandler()&quot;);
+		G = GL;
+		// Find ID of DT
+		/*string filename = G-&gt;info-&gt;datapath + slash + &quot;DTBuildData&quot; + slash + G-&gt;info-&gt;tdfpath + string(&quot;.DTBuildData&quot;);
+		ofstream DTBuildDataOut(filename.c_str(), ios::binary);
+		int unum = G-&gt;cb-&gt;GetNumUnitDefs();
+		const UnitDef** UnitDefList = new const UnitDef*[unum];
+		G-&gt;cb-&gt;GetUnitDefList(UnitDefList);
+		for(int n=0; n &lt; unum; n++){
+			const UnitDef* pud = UnitDefList[n];
+			if(pud-&gt;buildSpeed &gt; 0.0f){
+				for(map&lt;int, string&gt;::const_iterator bit = pud-&gt;buildOptions.begin(); bit != pud-&gt;buildOptions.end(); bit++){
+            		const UnitDef* pud2 = G-&gt;cb-&gt;GetUnitDef(bit-&gt;second.c_str());
+					if(pud2-&gt;isFeature &amp;&amp; !pud2-&gt;floater){
+						DTBuilds.insert(map&lt;int, int&gt;::value_type(n, pud2-&gt;id));
+						DTBuildDataOut &lt;&lt; n &lt;&lt; pud2-&gt;id;
+						break;
+					}
+				}
+			}
 		}
+		DTBuildDataOut.close();*/
 	}
-	if(locations.empty()==true) return UpVector;
-	float3 closest = locations.front();
-	
-	float distance = pos.distance2D(closest);
-	float tempdist=0;
-	for(vector&lt;float3&gt;::iterator j = locations.begin(); j != locations.end(); ++j){
-		tempdist = j-&gt;distance2D(pos);
-		if(tempdist &lt; distance){
-			distance = tempdist;
-			closest = *j;
+
+	void CDTHandler::AddRing(float3 _loc, float _Radius , float _Twist){
+		NLOG(&quot;CDTHandler::AddRing()&quot;);
+		// Setup Dragon's Teeth
+		//Setting up DT Positions...
+		float Angle = 0.0f;
+		const float maxx = G-&gt;cb-&gt;GetMapWidth()*8.0f;
+		const float maxz = G-&gt;cb-&gt;GetMapHeight()*8.0f;
+		int CurDT = 0;
+		// Find direction to start, and start with 90 Degrees from that.
+		float Rotate = (float)atan((maxz/2 - _loc.z) / (maxx/2 - _loc.x)) - (float)PI_2;
+		int NumSteps = ((int)(PIx2 * _Radius / DT_SIZE));
+		const float AngleDelta = (1 / (_Radius / DT_SIZE));
+		int LastX = 0, LastY = 0;
+		DTRing NewRing;
+		for(int n=0; n &lt; NumSteps; n++){
+			Angle += AngleDelta;
+			if(Angle &gt; PIx2){
+				break;
+			}
+			if(n % (NumSteps / DT_NUM_GAPS) &lt; DT_GAP_WIDTH){
+				continue;
+			}
+			float3 pos;
+			pos.x = _Radius * sin(Angle+Rotate+_Twist) + _loc.x;
+			pos.z = _Radius * -cos(Angle+Rotate+_Twist) + _loc.z;
+			pos.x = float((int)(pos.x / 8) * 8);
+			pos.z = float((int)(pos.z / 8) * 8);
+			while(G-&gt;Map-&gt;Overlap(pos.x - DT_SIZE/2, pos.z - DT_SIZE/2, DT_SIZE, DT_SIZE, (float)LastX, (float)LastY, DT_SIZE, DT_SIZE)){
+				float A = Angle+Rotate+_Twist;
+				while(A &lt; 0)
+					A+= (float)PIx2;
+				while(A &gt; PIx2)
+					A-= (float)PIx2;
+				// Nudging
+				if(A &lt; PI_4){
+					pos.x+=8;//Nudge Right
+				}else if(A &lt; 3.0f * PI_4){
+					pos.z+=8;//Nudge Down
+				}else if(A &lt; 5.0f * PI_4){
+					pos.x-=8;//Nudge Left
+				}else if(A &lt; 7.0f * PI_4){
+					pos.z-=8;//Nudge Up
+				}else{
+					pos.x+=8;//Nudge Right
+				}
+			}
+			if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+				continue;
+			}
+			if(G-&gt;cb-&gt;GetElevation(pos.x, pos.z) &lt; 0){
+				continue;
+			}
+			pos.y = G-&gt;cb-&gt;GetElevation(pos.x, pos.z);
+			NewRing.DTPos.push_back(pos);
+			LastX = int(pos.x) - DT_SIZE/2;
+			LastY = int(pos.z) - DT_SIZE/2;
+			Angle = atan2f(pos.z - _loc.z, pos.x - _loc.x);
+			CurDT++;
 		}
+		//LOG(&quot;Number of Dragon's Teeth Needed: &quot; &lt;&lt; CurDT &lt;&lt; endl);
+		DTRings.push_back(NewRing);
+		NLOG(&quot;AddRing() ended&quot;);
 	}
-	
-	return closest;
-}
 
-CDTHandler::CDTHandler(Global* GL){
-	//NLOG(&quot;CDTHandler::CDTHandler()&quot;);
-	G = GL;
-    // Find ID of DT
-    /*string filename = G-&gt;info-&gt;datapath + slash + &quot;DTBuildData&quot; + slash + G-&gt;info-&gt;tdfpath + string(&quot;.DTBuildData&quot;);
-    ofstream DTBuildDataOut(filename.c_str(), ios::binary);
-	int unum = G-&gt;cb-&gt;GetNumUnitDefs();
-	const UnitDef** UnitDefList = new const UnitDef*[unum];
-	G-&gt;cb-&gt;GetUnitDefList(UnitDefList);
-    for(int n=0; n &lt; unum; n++){
-        const UnitDef* pud = UnitDefList[n];
-        if(pud-&gt;buildSpeed &gt; 0.0f){
-            for(map&lt;int, string&gt;::const_iterator bit = pud-&gt;buildOptions.begin(); bit != pud-&gt;buildOptions.end(); bit++){
-            	const UnitDef* pud2 = G-&gt;cb-&gt;GetUnitDef(bit-&gt;second.c_str());
-                if(pud2-&gt;isFeature &amp;&amp; !pud2-&gt;floater){
-                    DTBuilds.insert(map&lt;int, int&gt;::value_type(n, pud2-&gt;id));
-                    DTBuildDataOut &lt;&lt; n &lt;&lt; pud2-&gt;id;
-                    break;
-                }
-            }
-        }
-    }
-    DTBuildDataOut.close();*/
-}
+	CDTHandler::~CDTHandler(){
+	}
 
-void CDTHandler::AddRing(float3 _loc, float _Radius , float _Twist){
-    NLOG(&quot;CDTHandler::AddRing()&quot;);
-    // Setup Dragon's Teeth
-	//Setting up DT Positions...
-    float Angle = 0.0f;
-    const float maxx = G-&gt;cb-&gt;GetMapWidth()*8.0f;
-    const float maxz = G-&gt;cb-&gt;GetMapHeight()*8.0f;
-    int CurDT = 0;
-    // Find direction to start, and start with 90 Degrees from that.
-    float Rotate = (float)atan((maxz/2 - _loc.z) / (maxx/2 - _loc.x)) - (float)PI_2;
-    int NumSteps = ((int)(PIx2 * _Radius / DT_SIZE));
-    const float AngleDelta = (1 / (_Radius / DT_SIZE));
-    int LastX = 0, LastY = 0;
-    DTRing NewRing;
-    for(int n=0; n &lt; NumSteps; n++){
-        Angle += AngleDelta;
-        if(Angle &gt; PIx2){
-            break;
-        }
-        if(n % (NumSteps / DT_NUM_GAPS) &lt; DT_GAP_WIDTH){
-            continue;
-        }
-        float3 pos;
-        pos.x = _Radius * sin(Angle+Rotate+_Twist) + _loc.x;
-        pos.z = _Radius * -cos(Angle+Rotate+_Twist) + _loc.z;
-        pos.x = float((int)(pos.x / 8) * 8);
-        pos.z = float((int)(pos.z / 8) * 8);
-        while(G-&gt;Map-&gt;Overlap(pos.x - DT_SIZE/2, pos.z - DT_SIZE/2, DT_SIZE, DT_SIZE, (float)LastX, (float)LastY, DT_SIZE, DT_SIZE)){
-            float A = Angle+Rotate+_Twist;
-            while(A &lt; 0)
-                A+= (float)PIx2;
-            while(A &gt; PIx2)
-                A-= (float)PIx2;
-            // Nudging
-            if(A &lt; PI_4){
-                pos.x+=8;//Nudge Right
-            }else if(A &lt; 3.0f * PI_4){
-                pos.z+=8;//Nudge Down
-            }else if(A &lt; 5.0f * PI_4){
-                pos.x-=8;//Nudge Left
-            }else if(A &lt; 7.0f * PI_4){
-                pos.z-=8;//Nudge Up
-            }else{
-                pos.x+=8;//Nudge Right
-            }
-        }
-		if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
-			continue;
-		}
-        if(G-&gt;cb-&gt;GetElevation(pos.x, pos.z) &lt; 0){
-            continue;
-        }
-        pos.y = G-&gt;cb-&gt;GetElevation(pos.x, pos.z);
-        NewRing.DTPos.push_back(pos);
-        LastX = int(pos.x) - DT_SIZE/2;
-        LastY = int(pos.z) - DT_SIZE/2;
-        Angle = atan2f(pos.z - _loc.z, pos.x - _loc.x);
-        CurDT++;
-    }
-    //LOG(&quot;Number of Dragon's Teeth Needed: &quot; &lt;&lt; CurDT &lt;&lt; endl);
-    DTRings.push_back(NewRing);
-    NLOG(&quot;AddRing() ended&quot;);
-}
+	bool CDTHandler::DTNeeded(){
+		//if(NoDT)
+	   //     return false;
+		return (!DTRings.empty());
+	//	return true;
+	}
 
-CDTHandler::~CDTHandler(){
-}
 
-bool CDTHandler::DTNeeded(){
-	//if(NoDT)
-   //     return false;
-	return (!DTRings.empty());
-//	return true;
-}
 
-// bool CDTHandler::IsDragonsTeeth(const int Feature){
-// 	return IsDragonsTeeth(G-&gt;cb-&gt;GetFeatureDef(Feature)-&gt;myName);
-//}
+	bool CDTHandler::IsDragonsTeeth(const char* FeatureName){
+		return IsDragonsTeeth(string(FeatureName));
+	}
 
-bool CDTHandler::IsDragonsTeeth(const char* FeatureName){
-	return IsDragonsTeeth(string(FeatureName));
+	bool CDTHandler::IsDragonsTeeth(const string FeatureName){
+		CUnitTypeData* ud = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(FeatureName);
+		return IsDragonsTeeth(ud-&gt;GetUnitDef());
+	}
+	bool CDTHandler::IsDragonsTeeth(const UnitDef* ud){
+		if(ud == 0) return false;
+		return ud-&gt;isFeature;
+	}
 }
-
-bool CDTHandler::IsDragonsTeeth(const string FeatureName){
-	CUnitTypeData* ud = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(FeatureName);
-    return IsDragonsTeeth(ud-&gt;GetUnitDef());
-}
-bool CDTHandler::IsDragonsTeeth(const UnitDef* ud){
-	if(ud == 0) return false;
-	return ud-&gt;isFeature;
-}

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/Map.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/Map.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/Map.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,261 +1,263 @@
 // Map
 #include &quot;../../Core/include.h&quot;
 
-CMap::CMap(Global* GL){
-	G = GL;
-}
+namespace ntai {
+	CMap::CMap(Global* GL){
+		G = GL;
+	}
 
-float3 CMap::distfrom(float3 Start, float3 Target, float distance){
-	NLOG(&quot;CMap::distfrom&quot;);
+	float3 CMap::distfrom(float3 Start, float3 Target, float distance){
+		NLOG(&quot;CMap::distfrom&quot;);
 
-	if(!CheckFloat3(Start)){
-		return UpVector;
-	}
+		if(!CheckFloat3(Start)){
+			return UpVector;
+		}
 
-	if(!CheckFloat3(Target)){
-		return UpVector;
-	}
+		if(!CheckFloat3(Target)){
+			return UpVector;
+		}
 
-	float p = distance/Start.distance2D(Target);
-	if(p &lt; 0) p *= -1;
+		float p = distance/Start.distance2D(Target);
+		if(p &lt; 0) p *= -1;
 
-	float dx = Start.x-Target.x;
-	if(dx &lt; 0) dx *= -1;
+		float dx = Start.x-Target.x;
+		if(dx &lt; 0) dx *= -1;
 
-	float dz = Start.z-Target.z;
-	if(dz &lt; 0) dz *= -1;
+		float dz = Start.z-Target.z;
+		if(dz &lt; 0) dz *= -1;
 
-	dz *= p;
-	dx *= p;
+		dz *= p;
+		dx *= p;
 
-	float x = Target.x;
+		float x = Target.x;
 
-	if(Start.x &gt; Target.x){
-		x += dx;
-	} else{
-		x -= dx;
-	}
+		if(Start.x &gt; Target.x){
+			x += dx;
+		} else{
+			x -= dx;
+		}
 
-	float z = Target.z;
+		float z = Target.z;
 
-	if(Start.z &gt; Target.z){
-		z += dz;
-	}else{
-		z -= dz;
+		if(Start.z &gt; Target.z){
+			z += dz;
+		}else{
+			z -= dz;
+		}
+
+		return float3(x,0,z);
+
 	}
 
-	return float3(x,0,z);
+	t_direction CMap::WhichCorner(float3 pos){
+		NLOG(&quot;CMap::WhichCorner&quot;);
 
-}
+		if ((pos.x&lt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&lt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
+			return t_NW;
+		}
 
-t_direction CMap::WhichCorner(float3 pos){
-	NLOG(&quot;CMap::WhichCorner&quot;);
+		if ((pos.x&gt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&lt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
+			return t_NE;
+		}
 
-	if ((pos.x&lt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&lt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
-		return t_NW;
-	}
+		if ((pos.x&lt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&gt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
+			return t_SW;
+		}
 
-	if ((pos.x&gt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&lt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
-		return t_NE;
-	}
+		if ((pos.x&gt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&gt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
+			return t_SE;
+		}
 
-	if ((pos.x&lt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&gt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
-		return t_SW;
+		return t_NA;
 	}
 
-	if ((pos.x&gt;(G-&gt;cb-&gt;GetMapWidth()*4))&amp;&amp;(pos.z&gt;(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE*4))){
-		return t_SE;
-	}
-
-	return t_NA;
-}
-
-/* returns the base position nearest to the given float3*/
-float3 CMap::nbasepos(float3 pos){
-	NLOG(&quot;CMap::nbasepos&quot;);
-	if(base_positions.empty() == false){
-		float3 best;
-		float best_score = 20000000;
-		for(vector&lt;float3&gt;::iterator i = base_positions.begin(); i != base_positions.end(); ++i){
-			if( i-&gt;distance2D(pos) &lt; best_score){
-				best = *i;
-				best_score = i-&gt;distance2D(pos);
+	/* returns the base position nearest to the given float3*/
+	float3 CMap::nbasepos(float3 pos){
+		NLOG(&quot;CMap::nbasepos&quot;);
+		if(base_positions.empty() == false){
+			float3 best;
+			float best_score = 20000000;
+			for(vector&lt;float3&gt;::iterator i = base_positions.begin(); i != base_positions.end(); ++i){
+				if( i-&gt;distance2D(pos) &lt; best_score){
+					best = *i;
+					best_score = i-&gt;distance2D(pos);
+				}
 			}
+			return best;
+		}else{
+			return basepos;
 		}
-		return best;
-	}else{
-		return basepos;
 	}
-}
 
-/*vector&lt;float3&gt; CMap::GetSurroundings(float3 pos){
-	NLOG(&quot;CMap::GetSurroundings&quot;);
-	vector&lt;float3&gt; s;
-	float3 ss = pos;
-	s.push_back(ss);
-	ss.z = ss.z - 1;
-	s.push_back(ss);
-	ss.z = ss.z +2;
-	s.push_back(ss);
-	ss.z = ss.z -1;
-	ss.x = ss.x - 1;
-	s.push_back(ss);
-	ss.z = ss.z - 1;
-	s.push_back(ss);
-	ss.z = ss.z +2;
-	s.push_back(ss);
-	ss.z = ss.z - 1;
-	ss.x = ss.x + 2;
-	s.push_back(ss);
-	ss.z = ss.z - 1;
-	s.push_back(ss);
-	ss.z = ss.z +2;
-	s.push_back(ss);
-	return s;
-}*/
+	/*vector&lt;float3&gt; CMap::GetSurroundings(float3 pos){
+		NLOG(&quot;CMap::GetSurroundings&quot;);
+		vector&lt;float3&gt; s;
+		float3 ss = pos;
+		s.push_back(ss);
+		ss.z = ss.z - 1;
+		s.push_back(ss);
+		ss.z = ss.z +2;
+		s.push_back(ss);
+		ss.z = ss.z -1;
+		ss.x = ss.x - 1;
+		s.push_back(ss);
+		ss.z = ss.z - 1;
+		s.push_back(ss);
+		ss.z = ss.z +2;
+		s.push_back(ss);
+		ss.z = ss.z - 1;
+		ss.x = ss.x + 2;
+		s.push_back(ss);
+		ss.z = ss.z - 1;
+		s.push_back(ss);
+		ss.z = ss.z +2;
+		s.push_back(ss);
+		return s;
+	}*/
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-float3 CMap::Rotate(float3 pos, float angle, float3 origin){
-	NLOG(&quot;CMap::Rotate&quot;);
-	float3 newpos;
-	newpos.x = (pos.x-origin.x)*cos(angle) - (pos.z-origin.z)*sin(angle);
-	newpos.z = (pos.x-origin.x)*sin(angle) + (pos.z-origin.z)*cos(angle);
-	newpos.x += origin.x;
-	newpos.z += origin.z;
-	newpos.y = pos.y;
-	return newpos;
-}
+	float3 CMap::Rotate(float3 pos, float angle, float3 origin){
+		NLOG(&quot;CMap::Rotate&quot;);
+		float3 newpos;
+		newpos.x = (pos.x-origin.x)*cos(angle) - (pos.z-origin.z)*sin(angle);
+		newpos.z = (pos.x-origin.x)*sin(angle) + (pos.z-origin.z)*cos(angle);
+		newpos.x += origin.x;
+		newpos.z += origin.z;
+		newpos.y = pos.y;
+		return newpos;
+	}
 
-bool CMap::Overlap(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2){
-	NLOG(&quot;CMap::Overlap&quot;);
-	// A below B
-	if(y1 + h1 &lt;= y2)
-		return false;
-	// B below A
-	if(y2 + h2 &lt;= y1)
-		return false;
-	// A left of B
-	if(x1 + w1 &lt;= x2)
-		return false;
-	// B left of A
-	if(x2 + w2 &lt;= x1)
-		return false;
-	return true;
-}
+	bool CMap::Overlap(float x1, float y1, float w1, float h1, float x2, float y2, float w2, float h2){
+		NLOG(&quot;CMap::Overlap&quot;);
+		// A below B
+		if(y1 + h1 &lt;= y2)
+			return false;
+		// B below A
+		if(y2 + h2 &lt;= y1)
+			return false;
+		// A left of B
+		if(x1 + w1 &lt;= x2)
+			return false;
+		// B left of A
+		if(x2 + w2 &lt;= x1)
+			return false;
+		return true;
+	}
 
-float CMap::GetBuildHeight(float3 pos, const UnitDef* unitdef){
-	NLOG(&quot;CMap::GetBuildHeight&quot;);
-	float minh=-5000;
-	float maxh=5000;
-	int numBorder=0;
-	float borderh=0;
+	float CMap::GetBuildHeight(float3 pos, const UnitDef* unitdef){
+		NLOG(&quot;CMap::GetBuildHeight&quot;);
+		float minh=-5000;
+		float maxh=5000;
+		int numBorder=0;
+		float borderh=0;
 
-	float maxDif=unitdef-&gt;maxHeightDif;
-	int x1 = (int)max(0.f,(pos.x-(unitdef-&gt;xsize*0.5f*SQUARE_SIZE))/SQUARE_SIZE);
-	int x2 = min(G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE,x1+unitdef-&gt;xsize);
-	int z1 = (int)max(0.f,(pos.z-(unitdef-&gt;ysize*0.5f*SQUARE_SIZE))/SQUARE_SIZE);
-	int z2 = min(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE,z1+unitdef-&gt;ysize);
+		float maxDif=unitdef-&gt;maxHeightDif;
+		int x1 = (int)max(0.f,(pos.x-(unitdef-&gt;xsize*0.5f*SQUARE_SIZE))/SQUARE_SIZE);
+		int x2 = min(G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE,x1+unitdef-&gt;xsize);
+		int z1 = (int)max(0.f,(pos.z-(unitdef-&gt;ysize*0.5f*SQUARE_SIZE))/SQUARE_SIZE);
+		int z2 = min(G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE,z1+unitdef-&gt;ysize);
 
-	if (x1 &gt; G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE) x1 = G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE;
-	if (x2 &lt; 0) x2 = 0;
-	if (z1 &gt; G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE) z1 = G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE;
-	if (z2 &lt; 0) z2 = 0;
+		if (x1 &gt; G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE) x1 = G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE;
+		if (x2 &lt; 0) x2 = 0;
+		if (z1 &gt; G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE) z1 = G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE;
+		if (z2 &lt; 0) z2 = 0;
 
-	const float* heightmap = G-&gt;cb-&gt;GetHeightMap();
-	for(int x=x1; x&lt;=x2; x++){
-		for(int z=z1; z&lt;=z2; z++){
-			float orgh=heightmap[z*(G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE+1)+x];
-			float h=heightmap[z*(G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE+1)+x];
-			if(x==x1 || x==x2 || z==z1 || z==z2){
-				numBorder++;
-				borderh+=h;
+		const float* heightmap = G-&gt;cb-&gt;GetHeightMap();
+		for(int x=x1; x&lt;=x2; x++){
+			for(int z=z1; z&lt;=z2; z++){
+				float orgh=heightmap[z*(G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE+1)+x];
+				float h=heightmap[z*(G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE+1)+x];
+				if(x==x1 || x==x2 || z==z1 || z==z2){
+					numBorder++;
+					borderh+=h;
+				}
+				if(minh&lt;min(h,orgh)-maxDif)
+					minh=min(h,orgh)-maxDif;
+				if(maxh&gt;max(h,orgh)+maxDif)
+					maxh=max(h,orgh)+maxDif;
 			}
-			if(minh&lt;min(h,orgh)-maxDif)
-				minh=min(h,orgh)-maxDif;
-			if(maxh&gt;max(h,orgh)+maxDif)
-				maxh=max(h,orgh)+maxDif;
 		}
-	}
-	float h=borderh/numBorder;
+		float h=borderh/numBorder;
 
-	if(h&lt;minh &amp;&amp; minh&lt;maxh)
-		h=minh+0.01f;
-	if(h&gt;maxh &amp;&amp; maxh&gt;minh)
-		h=maxh-0.01f;
+		if(h&lt;minh &amp;&amp; minh&lt;maxh)
+			h=minh+0.01f;
+		if(h&gt;maxh &amp;&amp; maxh&gt;minh)
+			h=maxh-0.01f;
 
-	return h;
-}
+		return h;
+	}
 
-float3 CMap::Pos2BuildPos(float3 pos, const UnitDef* ud){
-	NLOG(&quot;CMap::Pos2BuildPos&quot;);
-	if(ud-&gt;xsize&amp;2)
-		pos.x=floor((pos.x)/(SQUARE_SIZE*2))*SQUARE_SIZE*2+8;
-	else
-		pos.x=floor((pos.x+8)/(SQUARE_SIZE*2))*SQUARE_SIZE*2;
+	float3 CMap::Pos2BuildPos(float3 pos, const UnitDef* ud){
+		NLOG(&quot;CMap::Pos2BuildPos&quot;);
+		if(ud-&gt;xsize&amp;2)
+			pos.x=floor((pos.x)/(SQUARE_SIZE*2))*SQUARE_SIZE*2+8;
+		else
+			pos.x=floor((pos.x+8)/(SQUARE_SIZE*2))*SQUARE_SIZE*2;
 
-	if(ud-&gt;ysize&amp;2)
-		pos.z=floor((pos.z)/(SQUARE_SIZE*2))*SQUARE_SIZE*2+8;
-	else
-		pos.z=floor((pos.z+8)/(SQUARE_SIZE*2))*SQUARE_SIZE*2;
+		if(ud-&gt;ysize&amp;2)
+			pos.z=floor((pos.z)/(SQUARE_SIZE*2))*SQUARE_SIZE*2+8;
+		else
+			pos.z=floor((pos.z+8)/(SQUARE_SIZE*2))*SQUARE_SIZE*2;
 
-	pos.y=GetBuildHeight(pos,ud);
-	if(ud-&gt;floater &amp;&amp; pos.y&lt;0)
-		pos.y = -ud-&gt;waterline;
+		pos.y=GetBuildHeight(pos,ud);
+		if(ud-&gt;floater &amp;&amp; pos.y&lt;0)
+			pos.y = -ud-&gt;waterline;
 
-	return pos;
-}
+		return pos;
+	}
 
-bool SearchOffsetComparator (const SearchOffset&amp; a, const SearchOffset&amp; b){
-	return a.qdist &lt; b.qdist;
-}
+	bool SearchOffsetComparator (const SearchOffset&amp; a, const SearchOffset&amp; b){
+		return a.qdist &lt; b.qdist;
+	}
 
-vector&lt;SearchOffset&gt; CMap::GetSearchOffsetTable(int radius){
-	NLOG(&quot;CMap::GetSearchOffsetTable&quot;);
-	vector &lt;SearchOffset&gt; searchOffsets;
-	int size = radius*radius*4;
-	if (size &gt; (int)searchOffsets.size()) {
-		searchOffsets.resize (size);
-		for (int y=0;y&lt;radius*2;y++)
-			for (int x=0;x&lt;radius*2;x++){
-				SearchOffset&amp; i = searchOffsets[y*radius*2+x];
-				i.dx = x-radius;
-				i.dy = y-radius;
-				i.qdist = i.dx*i.dx+i.dy*i.dy;
-			}
-			sort(searchOffsets.begin(), searchOffsets.end(), SearchOffsetComparator);
+	vector&lt;SearchOffset&gt; CMap::GetSearchOffsetTable(int radius){
+		NLOG(&quot;CMap::GetSearchOffsetTable&quot;);
+		vector &lt;SearchOffset&gt; searchOffsets;
+		int size = radius*radius*4;
+		if (size &gt; (int)searchOffsets.size()) {
+			searchOffsets.resize (size);
+			for (int y=0;y&lt;radius*2;y++)
+				for (int x=0;x&lt;radius*2;x++){
+					SearchOffset&amp; i = searchOffsets[y*radius*2+x];
+					i.dx = x-radius;
+					i.dy = y-radius;
+					i.qdist = i.dx*i.dx+i.dy*i.dy;
+				}
+				sort(searchOffsets.begin(), searchOffsets.end(), SearchOffsetComparator);
+		}
+		return searchOffsets;
 	}
-	return searchOffsets;
-}
 
 
-bool CMap::CheckFloat3(float3 pos){
-	NLOG(&quot;CMap::CheckFloat3&quot;);
-	if(pos == UpVector){ //error codes
-		return false;
-	}else if(pos == ZeroVector){ //error codes
-		return false;
-	}else if(pos == float3(-1,0,0)){ //error codes
-		return false;
-	}else if(pos.distance2D(UpVector) &lt;50){ // top corner!!!!!
-		return false;
-	}/*else if(pos.x &gt; G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE){ // offmap
-		return false;
-	}else if(pos.z &gt; G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE){ // offmap
-		return false;
-	}else if(pos.x &lt; 0){ // offmap
-		return false;
-	}else if(pos.z &lt; 0){ // offmap
-		return false;
-	}*/else{
-		return true;
+	bool CMap::CheckFloat3(float3 pos){
+		NLOG(&quot;CMap::CheckFloat3&quot;);
+		if(pos == UpVector){ //error codes
+			return false;
+		}else if(pos == ZeroVector){ //error codes
+			return false;
+		}else if(pos == float3(-1,0,0)){ //error codes
+			return false;
+		}else if(pos.distance2D(UpVector) &lt;50){ // top corner!!!!!
+			return false;
+		}/*else if(pos.x &gt; G-&gt;cb-&gt;GetMapWidth()*SQUARE_SIZE){ // offmap
+			return false;
+		}else if(pos.z &gt; G-&gt;cb-&gt;GetMapHeight()*SQUARE_SIZE){ // offmap
+			return false;
+		}else if(pos.x &lt; 0){ // offmap
+			return false;
+		}else if(pos.z &lt; 0){ // offmap
+			return false;
+		}*/else{
+			return true;
+		}
 	}
-}
 
-float CMap::GetAngle(float3 origin, float3 a, float3 b){
-	float3 c = a-origin;
-	float3 d = b-origin;
-	c.Normalize();
-	d.Normalize();
-	return (float)abs( (long)acos( c.dot(d) ) );
+	float CMap::GetAngle(float3 origin, float3 a, float3 b){
+		float3 c = a-origin;
+		float3 d = b-origin;
+		c.Normalize();
+		d.Normalize();
+		return (float)abs( (long)acos( c.dot(d) ) );
+	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalHandler.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalHandler.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalHandler.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -5,193 +5,195 @@
 
 #define HOT_SPOT_RADIUS_MULTIPLYER	1.3f
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+namespace ntai {
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-CMetalHandler::CMetalHandler(Global* GLI){
-	G = GLI;
-	cb=G-&gt;cb;
-	m = new CMetalMap(G);
-}
+	CMetalHandler::CMetalHandler(Global* GLI){
+		G = GLI;
+		cb=G-&gt;cb;
+		m = new CMetalMap(G);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-CMetalHandler::~CMetalHandler(){
-	delete m;
-}
+	CMetalHandler::~CMetalHandler(){
+		delete m;
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-bool metalcmp(float3 a, float3 b) {
-	return a.y &gt; b.y;
-}
+	bool metalcmp(float3 a, float3 b) {
+		return a.y &gt; b.y;
+	}
 
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-void CMetalHandler::loadState() {
-	m-&gt;Init();
-	hotspot = m-&gt;VectoredSpots;
-	metalpatch = m-&gt;VectoredSpots;
-}
+	void CMetalHandler::loadState() {
+		m-&gt;Init();
+		hotspot = m-&gt;VectoredSpots;
+		metalpatch = m-&gt;VectoredSpots;
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-float CMetalHandler::getExtractionRanged(float x, float z) {
-	float x1=x/16.0f;
-	float z1=z/16.0f;
-	
-	float rad=cb-&gt;GetExtractorRadius()/16.0f;
-	rad=rad*0.866f;
-	
-	float count=0.0f;
-	float total=0.0f;
+	float CMetalHandler::getExtractionRanged(float x, float z) {
+		float x1=x/16.0f;
+		float z1=z/16.0f;
+		
+		float rad=cb-&gt;GetExtractorRadius()/16.0f;
+		rad=rad*0.866f;
+		
+		float count=0.0f;
+		float total=0.0f;
 
-	for (float i=-rad;i&lt;rad;i++){
-		for (float j=-rad;j&lt;rad;j++){
-			total+=getMetalAmount((int)(x1+i),(int)(z1+j));
-			++count;
+		for (float i=-rad;i&lt;rad;i++){
+			for (float j=-rad;j&lt;rad;j++){
+				total+=getMetalAmount((int)(x1+i),(int)(z1+j));
+				++count;
+			}
 		}
-	}
 
-	if (count==0){
-		return 0.0f;
+		if (count==0){
+			return 0.0f;
+		}
+
+		float ret=total/count;
+		return ret;
 	}
 
-	float ret=total/count;
-	return ret;
-}
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	float CMetalHandler::getMetalAmount(int x, int z) {
 
-float CMetalHandler::getMetalAmount(int x, int z) {
+		int sizex=(int)(cb-&gt;GetMapWidth()/2.0);
+		int sizez=(int)(cb-&gt;GetMapHeight()/2.0);
 
-	int sizex=(int)(cb-&gt;GetMapWidth()/2.0);
-	int sizez=(int)(cb-&gt;GetMapHeight()/2.0);
+		if(x&lt;0){
+			x=0;
+		}else if(x&gt;=sizex){
+			x=sizex-1;
+		}
+		
+		if(z&lt;0){
+			z=0;
+		}else if(z&gt;=sizez){
+			z=sizez-1;
+		}
 
-	if(x&lt;0){
-		x=0;
-	}else if(x&gt;=sizex){
-		x=sizex-1;
+		float val = (cb-&gt;GetMetalMap()[x + z*sizex]);
+
+		return val;
 	}
-	
-	if(z&lt;0){
-		z=0;
-	}else if(z&gt;=sizez){
-		z=sizez-1;
-	}
 
-	float val = (cb-&gt;GetMetalMap()[x + z*sizex]);
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-	return val;
-}
+	std::vector&lt;float3&gt; *CMetalHandler::getHotSpots(){
+		return &amp;(this-&gt;hotspot);
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 
-std::vector&lt;float3&gt; *CMetalHandler::getHotSpots(){
-	return &amp;(this-&gt;hotspot);
-}
+	std::vector&lt;float3&gt; *CMetalHandler::getMetalPatch(float3 pos, float minMetal,/*float radius,*/ float depth){
+		std::vector&lt;float3&gt; *v=new std::vector&lt;float3&gt;();
+		unsigned int i;
+		float mrad=cb-&gt;GetExtractorRadius() + 0.1f;
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+		mrad=3.0f*mrad*mrad;
 
-std::vector&lt;float3&gt; *CMetalHandler::getMetalPatch(float3 pos, float minMetal,/*float radius,*/ float depth){
-	std::vector&lt;float3&gt; *v=new std::vector&lt;float3&gt;();
-	unsigned int i;
-	float mrad=cb-&gt;GetExtractorRadius() + 0.1f;
+		bool valid;
+		for (i=0;i&lt;this-&gt;metalpatch.size();i++){
+			valid=true;
 
-	mrad=3.0f*mrad*mrad;
+			float3 t1=metalpatch.at(i);
 
-	bool valid;
-	for (i=0;i&lt;this-&gt;metalpatch.size();i++){
-		valid=true;
+			if (t1.y&lt;minMetal){
+				continue;
+			}
 
-		float3 t1=metalpatch.at(i);
+			for(std::vector&lt;int&gt;::iterator it=mex.begin();it!=mex.end();++it){
+				if (const UnitDef *def=cb-&gt;GetUnitDef(*it)){
+					if (def-&gt;extractsMetal&lt;depth)	continue;
+				}
 
-		if (t1.y&lt;minMetal){
-			continue;
-		}
-
-		for(std::vector&lt;int&gt;::iterator it=mex.begin();it!=mex.end();++it){
-			if (const UnitDef *def=cb-&gt;GetUnitDef(*it)){
-				if (def-&gt;extractsMetal&lt;depth)	continue;
+				float3 t2=cb-&gt;GetUnitPos((*it));
+				float d1=(t1.x-t2.x)*(t1.x-t2.x)+(t1.z-t2.z)*(t1.z-t2.z);
+				
+				if (d1&lt;mrad){
+					valid=false;
+					break;
+				}
 			}
-
-			float3 t2=cb-&gt;GetUnitPos((*it));
-			float d1=(t1.x-t2.x)*(t1.x-t2.x)+(t1.z-t2.z)*(t1.z-t2.z);
 			
-			if (d1&lt;mrad){
-				valid=false;
-				break;
+			float3 secpos = G-&gt;Ch-&gt;Grid.MaptoGrid(t1);
+			
+			if (valid){
+				v-&gt;push_back(t1);
 			}
 		}
-		
-		float3 secpos = G-&gt;Ch-&gt;Grid.MaptoGrid(t1);
-		
-		if (valid){
-			v-&gt;push_back(t1);
-		}
+		return v;
 	}
-	return v;
-}
 
-bool CMetalHandler::Viable(){
-	return true;
-}
+	bool CMetalHandler::Viable(){
+		return true;
+	}
 
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-// Cycle through each getting an array. If an array is returned with
-// a value then return teh first value in the array. If the array
-// returned is empty, wident eh search parameters and try again.
-// If after 6 tries no spots have been found still, then return an error
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	// Cycle through each getting an array. If an array is returned with
+	// a value then return teh first value in the array. If the array
+	// returned is empty, wident eh search parameters and try again.
+	// If after 6 tries no spots have been found still, then return an error
 
-float3 CMetalHandler::getNearestPatch(float3 pos, float minMetal, float depth, const UnitDef* ud) {
-	std::vector&lt;float3&gt; *v=getMetalPatch(pos,minMetal,/*NEAR_RADIUS,*/depth);
+	float3 CMetalHandler::getNearestPatch(float3 pos, float minMetal, float depth, const UnitDef* ud) {
+		std::vector&lt;float3&gt; *v=getMetalPatch(pos,minMetal,/*NEAR_RADIUS,*/depth);
 
-	float3 posx = UpVector;
+		float3 posx = UpVector;
 
-	float d = 6000.0f;
-	float temp = 999999999.0f;
-	float e_rad;
+		float d = 6000.0f;
+		float temp = 999999999.0f;
+		float e_rad;
 
-	G-&gt;Get_mod_tdf()-&gt;GetDef(e_rad,&quot;900&quot;,&quot;AI\\mexnoweaponradius&quot;);
+		G-&gt;Get_mod_tdf()-&gt;GetDef(e_rad,&quot;900&quot;,&quot;AI\\mexnoweaponradius&quot;);
 
-	if(v-&gt;empty() == false){
-		posx = v-&gt;front();
+		if(v-&gt;empty() == false){
+			posx = v-&gt;front();
 
-		for(vector&lt;float3&gt;::iterator vi = v-&gt;begin(); vi != v-&gt;end(); ++vi){
+			for(vector&lt;float3&gt;::iterator vi = v-&gt;begin(); vi != v-&gt;end(); ++vi){
 
-			temp = vi-&gt;distance2D(pos);
+				temp = vi-&gt;distance2D(pos);
 
-			if((temp &lt; d)&amp;&amp;(cb-&gt;CanBuildAt(ud,*vi) == true)){
+				if((temp &lt; d)&amp;&amp;(cb-&gt;CanBuildAt(ud,*vi) == true)){
 
-				// check to see if this is in range of an enemy..............
-				int* e = new int[2000];
-				int en = G-&gt;GetEnemyUnits(e,*vi,e_rad);
+					// check to see if this is in range of an enemy..............
+					int* e = new int[2000];
+					int en = G-&gt;GetEnemyUnits(e,*vi,e_rad);
 
-				if( en &gt; 0){
-					for(int i = 0; i &lt; en; i++){
-						const UnitDef* ud = G-&gt;GetEnemyDef(e[i]);
-						if(ud == 0){
-							continue;
-						}else{
-							if(ud-&gt;weapons.empty()==false){
+					if( en &gt; 0){
+						for(int i = 0; i &lt; en; i++){
+							const UnitDef* ud = G-&gt;GetEnemyDef(e[i]);
+							if(ud == 0){
 								continue;
+							}else{
+								if(ud-&gt;weapons.empty()==false){
+									continue;
+								}
 							}
+							//
 						}
-						//
 					}
-				}
 
-				delete [] e;
+					delete [] e;
 
-				// ok add it
-				posx = *vi;
-				d = temp;
-				temp = 999999999.0f;
+					// ok add it
+					posx = *vi;
+					d = temp;
+					temp = 999999999.0f;
+				}
 			}
 		}
+		delete(v);
+		return posx;
 	}
-	delete(v);
-	return posx;
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
 }
-
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalMap.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalMap.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/MetalMap.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -5,482 +5,484 @@
 // Adapted for general use under GPL V2
 // Slightly Modified by AF
 
-CMetalMap::CMetalMap(Global* ai){
-	this-&gt;ai=ai;
+namespace ntai {
+	CMetalMap::CMetalMap(Global* ai){
+		this-&gt;ai=ai;
 
-	// from 0-255, the minimum percentage of metal a spot needs to have
-	//from the maximum to be saved. Prevents crappier spots in between taken spaces.
-	//They are still perfectly valid and will generate metal mind you!
-	MinMetalForSpot = 30;	
-							
-							
+		// from 0-255, the minimum percentage of metal a spot needs to have
+		//from the maximum to be saved. Prevents crappier spots in between taken spaces.
+		//They are still perfectly valid and will generate metal mind you!
+		MinMetalForSpot = 30;	
+								
+								
 
-	MaxSpots = 5000;		//If more spots than that are found the map is considered a metalmap, tweak this as needed
+		MaxSpots = 5000;		//If more spots than that are found the map is considered a metalmap, tweak this as needed
 
 
-	MetalMapHeight =ai-&gt;cb-&gt;GetMapHeight() / 2; //metal map has 1/2 resolution of normal map
-	MetalMapWidth =ai-&gt;cb-&gt;GetMapWidth() / 2;
-	TotalCells = MetalMapHeight * MetalMapWidth;
-	XtractorRadius =(int)ai-&gt;cb-&gt;GetExtractorRadius()/ 16;
-	DoubleRadius = XtractorRadius * 2;
-	SquareRadius = XtractorRadius * XtractorRadius; //used to speed up loops so no recalculation needed
-	DoubleSquareRadius = DoubleRadius * DoubleRadius; // same as above
-	MexArrayA = new unsigned char [TotalCells];
-	MexArrayB = new unsigned char [TotalCells];
-	MexArrayC = new unsigned char [TotalCells]; //used for drawing the TGA, not really needed with a couple of changes
-	TempAverage = new int [TotalCells];
-	TotalMetal = MaxMetal = NumSpotsFound = 0; //clear variables just in case!
-	Stopme = false;
-	//L(&quot;Metal class logging works!&quot;);
-}
+		MetalMapHeight =ai-&gt;cb-&gt;GetMapHeight() / 2; //metal map has 1/2 resolution of normal map
+		MetalMapWidth =ai-&gt;cb-&gt;GetMapWidth() / 2;
+		TotalCells = MetalMapHeight * MetalMapWidth;
+		XtractorRadius =(int)ai-&gt;cb-&gt;GetExtractorRadius()/ 16;
+		DoubleRadius = XtractorRadius * 2;
+		SquareRadius = XtractorRadius * XtractorRadius; //used to speed up loops so no recalculation needed
+		DoubleSquareRadius = DoubleRadius * DoubleRadius; // same as above
+		MexArrayA = new unsigned char [TotalCells];
+		MexArrayB = new unsigned char [TotalCells];
+		MexArrayC = new unsigned char [TotalCells]; //used for drawing the TGA, not really needed with a couple of changes
+		TempAverage = new int [TotalCells];
+		TotalMetal = MaxMetal = NumSpotsFound = 0; //clear variables just in case!
+		Stopme = false;
+		//L(&quot;Metal class logging works!&quot;);
+	}
 
-CMetalMap::~CMetalMap()
-{
-	delete [] MexArrayA;
-	delete [] MexArrayB;
-	delete [] MexArrayC;
-	delete [] TempAverage;
-}
+	CMetalMap::~CMetalMap()
+	{
+		delete [] MexArrayA;
+		delete [] MexArrayB;
+		delete [] MexArrayC;
+		delete [] TempAverage;
+	}
 
-void CMetalMap::Init(){
-	ai-&gt;L &lt;&lt;&quot;KAI Metal Class by Krogothe&quot; &lt;&lt; endline; // Leave this line if you want to use this class in your AI
-	if(!LoadMetalMap()){ //if theres no available load file, create one and save it
-		GetMetalPoints();
-		SaveMetalMap();
+	void CMetalMap::Init(){
+		ai-&gt;L &lt;&lt;&quot;KAI Metal Class by Krogothe&quot; &lt;&lt; endline; // Leave this line if you want to use this class in your AI
+		if(!LoadMetalMap()){ //if theres no available load file, create one and save it
+			GetMetalPoints();
+			SaveMetalMap();
+		}
+		ai-&gt;L &lt;&lt; &quot;Metal Spots Found &quot; &lt;&lt; NumSpotsFound &lt;&lt; endline;
 	}
-	ai-&gt;L &lt;&lt; &quot;Metal Spots Found &quot; &lt;&lt; NumSpotsFound &lt;&lt; endline;
-}
 
-float3 CMetalMap::GetNearestMetalSpot(int builderid, const UnitDef* extractor)
-{
-	return UpVector;
-	/*
-	if (extractor == 0x00000000) {
-		//L(&quot;CMetalMap::GetNearestMetalSpot called with parameters builderid:&quot;&lt;&lt;builderid&lt;&lt;&quot; extractor:&quot;&lt;&lt;extractor);
-		return ERRORVECTOR;
-	}
-	float Tempscore = 0;
-	float MaxDivergence = 16;
-	float distance;
-	float3 spotcoords = ERRORVECTOR;
-	float3 bestspot = ERRORVECTOR;
-	//L(&quot;Getting Metal spot. Ave threat = &quot; &lt;&lt; ai-&gt;tm-&gt;GetAverageThreat());
-	if(VectoredSpots.size()){
-		int* temparray = new int [MAXUNITS];
-		for (int i = 0; i != VectoredSpots.size(); i++){
-			spotcoords = ai-&gt;cb-&gt;ClosestBuildSite(extractor, VectoredSpots[i],MaxDivergence,2);
-			if (spotcoords.x != -1){
-				distance = spotcoords.distance2D(ai-&gt;cb-&gt;GetUnitPos(builderid)) + 150;
-				//float mythreat = ai-&gt;tm-&gt;ThreatAtThisPoint(VectoredSpots[i]);
-				//L(&quot;Spot number &quot; &lt;&lt; i &lt;&lt; &quot; Threat: &quot; &lt;&lt; mythreat);
-				float spotscore = VectoredSpots[i].y / distance  / (mythreat + 10);
-				if(Tempscore &lt; spotscore){
-					//&amp;&amp; !ai-&gt;cheat-&gt;GetEnemyUnits(temparray, VectoredSpots[i],XtractorRadius)
-					//&amp;&amp; mythreat &lt;= ai-&gt;tm-&gt;GetAverageThreat() * 1.3
-					//&amp;&amp; !ai-&gt;uh-&gt;TaskPlanExist(spotcoords,extractor)){
-						Tempscore = spotscore;
-						bestspot = spotcoords;
-						bestspot.y = VectoredSpots[i].y;
-					}
+	float3 CMetalMap::GetNearestMetalSpot(int builderid, const UnitDef* extractor)
+	{
+		return UpVector;
+		/*
+		if (extractor == 0x00000000) {
+			//L(&quot;CMetalMap::GetNearestMetalSpot called with parameters builderid:&quot;&lt;&lt;builderid&lt;&lt;&quot; extractor:&quot;&lt;&lt;extractor);
+			return ERRORVECTOR;
+		}
+		float Tempscore = 0;
+		float MaxDivergence = 16;
+		float distance;
+		float3 spotcoords = ERRORVECTOR;
+		float3 bestspot = ERRORVECTOR;
+		//L(&quot;Getting Metal spot. Ave threat = &quot; &lt;&lt; ai-&gt;tm-&gt;GetAverageThreat());
+		if(VectoredSpots.size()){
+			int* temparray = new int [MAXUNITS];
+			for (int i = 0; i != VectoredSpots.size(); i++){
+				spotcoords = ai-&gt;cb-&gt;ClosestBuildSite(extractor, VectoredSpots[i],MaxDivergence,2);
+				if (spotcoords.x != -1){
+					distance = spotcoords.distance2D(ai-&gt;cb-&gt;GetUnitPos(builderid)) + 150;
+					//float mythreat = ai-&gt;tm-&gt;ThreatAtThisPoint(VectoredSpots[i]);
+					//L(&quot;Spot number &quot; &lt;&lt; i &lt;&lt; &quot; Threat: &quot; &lt;&lt; mythreat);
+					float spotscore = VectoredSpots[i].y / distance  / (mythreat + 10);
+					if(Tempscore &lt; spotscore){
+						//&amp;&amp; !ai-&gt;cheat-&gt;GetEnemyUnits(temparray, VectoredSpots[i],XtractorRadius)
+						//&amp;&amp; mythreat &lt;= ai-&gt;tm-&gt;GetAverageThreat() * 1.3
+						//&amp;&amp; !ai-&gt;uh-&gt;TaskPlanExist(spotcoords,extractor)){
+							Tempscore = spotscore;
+							bestspot = spotcoords;
+							bestspot.y = VectoredSpots[i].y;
+						}
+				}
 			}
+			delete [] temparray;
+		}else if (AverageMetal &gt; 0){
+			spotcoords = ai-&gt;cb-&gt;ClosestBuildSite(extractor, ai-&gt;cb-&gt;GetUnitPos(builderid),DEFCBS_RADIUS,DEFCBS_SEPARATION);
 		}
-		delete [] temparray;
-	}else if (AverageMetal &gt; 0){
-		spotcoords = ai-&gt;cb-&gt;ClosestBuildSite(extractor, ai-&gt;cb-&gt;GetUnitPos(builderid),DEFCBS_RADIUS,DEFCBS_SEPARATION);
+		if(Tempscore == 0)
+			L(&quot;No spot found&quot;);
+		return bestspot;*/
 	}
-	if(Tempscore == 0)
-		L(&quot;No spot found&quot;);
-	return bestspot;*/
-}
 
-int CMetalMap::FindMetalSpotUpgrade(int builderid, const UnitDef* extractor)
-{
-	return -1;
-	/*float Tempscore = 0;
-	float distance;
-	float3 spotcoords = ERRORVECTOR;
-	int bestspot = -1;
-	float bestfreemetal = GetNearestMetalSpot(builderid,extractor).y;
-	if(VectoredSpots.size()){
-		int* temparray = new int [MAXUNITS];
-		for(list&lt;int&gt;::iterator i = ai-&gt;uh-&gt;AllUnitsByCat[CAT_MEX]-&gt;begin(); i != ai-&gt;uh-&gt;AllUnitsByCat[CAT_MEX]-&gt;end(); i++){
-			spotcoords = ai-&gt;MyUnits[*i]-&gt;pos();
-			if (spotcoords.x != -1){
-				distance = sqrt(spotcoords.distance2D(ai-&gt;cb-&gt;GetUnitPos(builderid)) + 150);
-				//L(&quot;Spot number &quot; &lt;&lt; i &lt;&lt; &quot; Threat: &quot; &lt;&lt; mythreat);
-				float metaldifference = extractor-&gt;extractsMetal - ai-&gt;cb-&gt;GetUnitDef(*i)-&gt;extractsMetal;
-				float spotscore = (GetMetalAtThisPoint(spotcoords) * metaldifference) / sqrt(distance+500);
-				if(Tempscore &lt; spotscore
-					&amp;&amp; !ai-&gt;uh-&gt;TaskPlanExist(spotcoords,extractor)
-					&amp;&amp; bestfreemetal &lt; GetMetalAtThisPoint(spotcoords) * (metaldifference / extractor-&gt;extractsMetal)){
-						Tempscore = spotscore;
-						bestspot = *i;
-					}
+	int CMetalMap::FindMetalSpotUpgrade(int builderid, const UnitDef* extractor)
+	{
+		return -1;
+		/*float Tempscore = 0;
+		float distance;
+		float3 spotcoords = ERRORVECTOR;
+		int bestspot = -1;
+		float bestfreemetal = GetNearestMetalSpot(builderid,extractor).y;
+		if(VectoredSpots.size()){
+			int* temparray = new int [MAXUNITS];
+			for(list&lt;int&gt;::iterator i = ai-&gt;uh-&gt;AllUnitsByCat[CAT_MEX]-&gt;begin(); i != ai-&gt;uh-&gt;AllUnitsByCat[CAT_MEX]-&gt;end(); i++){
+				spotcoords = ai-&gt;MyUnits[*i]-&gt;pos();
+				if (spotcoords.x != -1){
+					distance = sqrt(spotcoords.distance2D(ai-&gt;cb-&gt;GetUnitPos(builderid)) + 150);
+					//L(&quot;Spot number &quot; &lt;&lt; i &lt;&lt; &quot; Threat: &quot; &lt;&lt; mythreat);
+					float metaldifference = extractor-&gt;extractsMetal - ai-&gt;cb-&gt;GetUnitDef(*i)-&gt;extractsMetal;
+					float spotscore = (GetMetalAtThisPoint(spotcoords) * metaldifference) / sqrt(distance+500);
+					if(Tempscore &lt; spotscore
+						&amp;&amp; !ai-&gt;uh-&gt;TaskPlanExist(spotcoords,extractor)
+						&amp;&amp; bestfreemetal &lt; GetMetalAtThisPoint(spotcoords) * (metaldifference / extractor-&gt;extractsMetal)){
+							Tempscore = spotscore;
+							bestspot = *i;
+						}
+				}
 			}
+			delete [] temparray;
 		}
-		delete [] temparray;
+		if(Tempscore &lt;= 0)
+			L(&quot;No spot found for upgrade&quot;);
+		else{
+			spotcoords = ai-&gt;cb-&gt;GetUnitPos(bestspot);
+			ai-&gt;cb-&gt;CreateLineFigure(spotcoords,float3(spotcoords.x,spotcoords.y + 100,spotcoords.z),10,1,10000,98);
+		}
+		return bestspot;*/
 	}
-	if(Tempscore &lt;= 0)
-		L(&quot;No spot found for upgrade&quot;);
-	else{
-		spotcoords = ai-&gt;cb-&gt;GetUnitPos(bestspot);
-		ai-&gt;cb-&gt;CreateLineFigure(spotcoords,float3(spotcoords.x,spotcoords.y + 100,spotcoords.z),10,1,10000,98);
-	}
-	return bestspot;*/
-}
 
-void CMetalMap::GetMetalPoints(){
-	// Time stuff:
-	int timetaken = clock();
+	void CMetalMap::GetMetalPoints(){
+		// Time stuff:
+		int timetaken = clock();
 
-	int* xend = new int[DoubleRadius+1];
-	for (int a=0;a&lt;DoubleRadius+1;a++){
-		float z=(float)a-XtractorRadius;
-		float floatsqrradius = (float)SquareRadius;
-		xend[a]=(int)sqrt(floatsqrradius-z*z);
-	}
-	//Load up the metal Values in each pixel
-	const unsigned char *metalMapArray = ai-&gt;cb-&gt;GetMetalMap();
-	double TotalMetalDouble  = 0;
-	for (int i = 0; i &lt; TotalCells; i++){
-		TotalMetalDouble +=  MexArrayA[i] = metalMapArray[i];		// Count the total metal so you can work out an average of the whole map
-	}
-	AverageMetal = (float)TotalMetalDouble / TotalCells;  //do the average
+		int* xend = new int[DoubleRadius+1];
+		for (int a=0;a&lt;DoubleRadius+1;a++){
+			float z=(float)a-XtractorRadius;
+			float floatsqrradius = (float)SquareRadius;
+			xend[a]=(int)sqrt(floatsqrradius-z*z);
+		}
+		//Load up the metal Values in each pixel
+		const unsigned char *metalMapArray = ai-&gt;cb-&gt;GetMetalMap();
+		double TotalMetalDouble  = 0;
+		for (int i = 0; i &lt; TotalCells; i++){
+			TotalMetalDouble +=  MexArrayA[i] = metalMapArray[i];		// Count the total metal so you can work out an average of the whole map
+		}
+		AverageMetal = (float)TotalMetalDouble / TotalCells;  //do the average
 
-	// Quick test for no metal map:
-	if(TotalMetalDouble &lt; 0.9){
-		// The map dont have any metal, just stop.
-		NumSpotsFound = 0;
-		delete[] xend;
-		timetaken = (int)time (NULL) - timetaken;
-		ai-&gt;L &lt;&lt; &quot;Time taken to generate spots: &quot; &lt;&lt; timetaken &lt;&lt; &quot; seconds.&quot; &lt;&lt; endline;
-		return;
-	}
-	// Now work out how much metal each spot can make by adding up the metal from nearby spots
-	for (int y = 0; y &lt; MetalMapHeight; y++){
-		for (int x = 0; x &lt; MetalMapWidth; x++){
-			TotalMetal = 0;
-			if(x == 0 &amp;&amp; y == 0) // First Spot needs full calculation
-			for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
-				if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
-					for (int sx=x-xend[a];sx&lt;=x+xend[a];sx++){
-						if (sx &gt;= 0 &amp;&amp; sx &lt; MetalMapWidth){
-							TotalMetal += MexArrayA[sy * MetalMapWidth + sx]; //get the metal from all pixels around the extractor radius
-						}
-					}
-				}
-			}
-			// Quick calc test:
-			if(x &gt; 0){
-				TotalMetal = TempAverage[y * MetalMapWidth + x -1];
+		// Quick test for no metal map:
+		if(TotalMetalDouble &lt; 0.9){
+			// The map dont have any metal, just stop.
+			NumSpotsFound = 0;
+			delete[] xend;
+			timetaken = (int)time (NULL) - timetaken;
+			ai-&gt;L &lt;&lt; &quot;Time taken to generate spots: &quot; &lt;&lt; timetaken &lt;&lt; &quot; seconds.&quot; &lt;&lt; endline;
+			return;
+		}
+		// Now work out how much metal each spot can make by adding up the metal from nearby spots
+		for (int y = 0; y &lt; MetalMapHeight; y++){
+			for (int x = 0; x &lt; MetalMapWidth; x++){
+				TotalMetal = 0;
+				if(x == 0 &amp;&amp; y == 0) // First Spot needs full calculation
 				for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
 					if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
-						int addX = x+xend[a];
-						int remX = x-xend[a] -1;
-						if(addX &lt; MetalMapWidth)
-							TotalMetal += MexArrayA[sy * MetalMapWidth + addX];
-						if(remX &gt;= 0)
-							TotalMetal -= MexArrayA[sy * MetalMapWidth + remX];
+						for (int sx=x-xend[a];sx&lt;=x+xend[a];sx++){
+							if (sx &gt;= 0 &amp;&amp; sx &lt; MetalMapWidth){
+								TotalMetal += MexArrayA[sy * MetalMapWidth + sx]; //get the metal from all pixels around the extractor radius
+							}
+						}
 					}
 				}
-			} else if(y &gt; 0){
-				// x == 0 here
-				TotalMetal = TempAverage[(y-1) * MetalMapWidth];
-				// Remove the top half:
-				int a = XtractorRadius;
-				for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
-					if (sx &lt; MetalMapWidth){
-						int remY = y-xend[a] -1;
-						if(remY &gt;= 0)
-							TotalMetal -= MexArrayA[remY * MetalMapWidth + sx];
+				// Quick calc test:
+				if(x &gt; 0){
+					TotalMetal = TempAverage[y * MetalMapWidth + x -1];
+					for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+						if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+							int addX = x+xend[a];
+							int remX = x-xend[a] -1;
+							if(addX &lt; MetalMapWidth)
+								TotalMetal += MexArrayA[sy * MetalMapWidth + addX];
+							if(remX &gt;= 0)
+								TotalMetal -= MexArrayA[sy * MetalMapWidth + remX];
+						}
 					}
-				}
-				// Add the bottom half:
-				a = XtractorRadius;
-				for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
-					if (sx &lt; MetalMapWidth){
-						int addY = y+xend[a];
-						if(addY &lt; MetalMapHeight)
-							TotalMetal += MexArrayA[addY * MetalMapWidth + sx];
+				} else if(y &gt; 0){
+					// x == 0 here
+					TotalMetal = TempAverage[(y-1) * MetalMapWidth];
+					// Remove the top half:
+					int a = XtractorRadius;
+					for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+						if (sx &lt; MetalMapWidth){
+							int remY = y-xend[a] -1;
+							if(remY &gt;= 0)
+								TotalMetal -= MexArrayA[remY * MetalMapWidth + sx];
+						}
 					}
+					// Add the bottom half:
+					a = XtractorRadius;
+					for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+						if (sx &lt; MetalMapWidth){
+							int addY = y+xend[a];
+							if(addY &lt; MetalMapHeight)
+								TotalMetal += MexArrayA[addY * MetalMapWidth + sx];
+						}
+					}
+
+					 //TotalMetal = TotalMetal; // Comment out for debug
 				}
-
-				 //TotalMetal = TotalMetal; // Comment out for debug
+				TempAverage[y * MetalMapWidth + x] = TotalMetal; //set that spots metal making ability (divide by cells to values are small)
+				if (MaxMetal &lt; TotalMetal)
+					MaxMetal = TotalMetal;  //find the spot with the highest metal to set as the map's max
 			}
-			TempAverage[y * MetalMapWidth + x] = TotalMetal; //set that spots metal making ability (divide by cells to values are small)
-			if (MaxMetal &lt; TotalMetal)
-				MaxMetal = TotalMetal;  //find the spot with the highest metal to set as the map's max
 		}
-	}
-	// Make a list for the distribution of values
-	int * valueDist = new int[256];
-	for (int i = 0; i &lt; 256; i++){ // Clear the array (useless?)
-		valueDist[i] = 0;
-	}
+		// Make a list for the distribution of values
+		int * valueDist = new int[256];
+		for (int i = 0; i &lt; 256; i++){ // Clear the array (useless?)
+			valueDist[i] = 0;
+		}
 
-	for (int i = 0; i &lt; TotalCells; i++){ // this will get the total metal a mex placed at each spot would make
-		MexArrayB[i] = TempAverage[i] * 255 / MaxMetal;  //scale the metal so any map will have values 0-255, no matter how much metal it has
-		MexArrayC[i] = 0; // clear out the array since its never been used.
-		int value = MexArrayB[i];
-		valueDist[value]++;
-	}
-
-	// Find the current best value
-	int bestValue = 0;
-	int numberOfValues = 0;
-	int usedSpots = 0;
-	for (int i = 255; i &gt;= 0; i--){
-		if(valueDist[i] != 0){
-			bestValue = i;
-			numberOfValues = valueDist[i];
-			break;
+		for (int i = 0; i &lt; TotalCells; i++){ // this will get the total metal a mex placed at each spot would make
+			MexArrayB[i] = TempAverage[i] * 255 / MaxMetal;  //scale the metal so any map will have values 0-255, no matter how much metal it has
+			MexArrayC[i] = 0; // clear out the array since its never been used.
+			int value = MexArrayB[i];
+			valueDist[value]++;
 		}
-	}
 
-	// Make a list of the indexes of the best spots
-	if(numberOfValues &gt; 256) // Make shure that the list wont be too big
-		numberOfValues = 256;
-	int *bestSpotList = new int[numberOfValues];
-	for (int i = 0; i &lt; TotalCells; i++){
-		if (MexArrayB[i] == bestValue){
-			// Add the index of this spot to the list.
-			bestSpotList[usedSpots] = i;
-			usedSpots++;
-			if(usedSpots == numberOfValues){
-				// The list is filled, stop the loop.
-				usedSpots = 0;
+		// Find the current best value
+		int bestValue = 0;
+		int numberOfValues = 0;
+		int usedSpots = 0;
+		for (int i = 255; i &gt;= 0; i--){
+			if(valueDist[i] != 0){
+				bestValue = i;
+				numberOfValues = valueDist[i];
 				break;
 			}
 		}
-	}
 
-	int printDebug1 = 100;
-	for (int a = 0; a &lt; MaxSpots; a++){
-		if(!Stopme){
-			TempMetal = 0; //reset tempmetal so it can find new spots
-			// Take the first spot
-			int speedTempMetal_x = 0;
-			int speedTempMetal_y = 0;
-			int speedTempMetal = 0;
-			bool found = false;
-			while(!found){
+		// Make a list of the indexes of the best spots
+		if(numberOfValues &gt; 256) // Make shure that the list wont be too big
+			numberOfValues = 256;
+		int *bestSpotList = new int[numberOfValues];
+		for (int i = 0; i &lt; TotalCells; i++){
+			if (MexArrayB[i] == bestValue){
+				// Add the index of this spot to the list.
+				bestSpotList[usedSpots] = i;
+				usedSpots++;
 				if(usedSpots == numberOfValues){
-					// The list is empty now, refill it:
-					// Make a list of all the best spots:
-					for (int i = 0; i &lt; 256; i++){ // Clear the array
-						valueDist[i] = 0;
-					}
-					// Find the metal distribution
-					for (int i = 0; i &lt; TotalCells; i++){
-						int value = MexArrayB[i];
-						valueDist[value]++;
-					}
-					// Find the current best value
-					bestValue = 0;
-					numberOfValues = 0;
+					// The list is filled, stop the loop.
 					usedSpots = 0;
-					for (int i = 255; i &gt;= 0; i--){
-						if(valueDist[i] != 0){
-							bestValue = i;
-							numberOfValues = valueDist[i];
-							break;
+					break;
+				}
+			}
+		}
+
+		int printDebug1 = 100;
+		for (int a = 0; a &lt; MaxSpots; a++){
+			if(!Stopme){
+				TempMetal = 0; //reset tempmetal so it can find new spots
+				// Take the first spot
+				int speedTempMetal_x = 0;
+				int speedTempMetal_y = 0;
+				int speedTempMetal = 0;
+				bool found = false;
+				while(!found){
+					if(usedSpots == numberOfValues){
+						// The list is empty now, refill it:
+						// Make a list of all the best spots:
+						for (int i = 0; i &lt; 256; i++){ // Clear the array
+							valueDist[i] = 0;
 						}
-					}
-					// Make a list of the indexes of the best spots
-					if(numberOfValues &gt; 256) // Make sure that the list wont be too big
-						numberOfValues = 256;
-					delete[] bestSpotList;
-					bestSpotList = new int[numberOfValues];
-
-					for (int i = 0; i &lt; TotalCells; i++){
-						if (MexArrayB[i] == bestValue){
-							// Add the index of this spot to the list.
-							bestSpotList[usedSpots] = i;
-							usedSpots++;
-							if(usedSpots == numberOfValues){
-								// The list is filled, stop the loop.
-								usedSpots = 0;
+						// Find the metal distribution
+						for (int i = 0; i &lt; TotalCells; i++){
+							int value = MexArrayB[i];
+							valueDist[value]++;
+						}
+						// Find the current best value
+						bestValue = 0;
+						numberOfValues = 0;
+						usedSpots = 0;
+						for (int i = 255; i &gt;= 0; i--){
+							if(valueDist[i] != 0){
+								bestValue = i;
+								numberOfValues = valueDist[i];
 								break;
 							}
 						}
+						// Make a list of the indexes of the best spots
+						if(numberOfValues &gt; 256) // Make sure that the list wont be too big
+							numberOfValues = 256;
+						delete[] bestSpotList;
+						bestSpotList = new int[numberOfValues];
+
+						for (int i = 0; i &lt; TotalCells; i++){
+							if (MexArrayB[i] == bestValue){
+								// Add the index of this spot to the list.
+								bestSpotList[usedSpots] = i;
+								usedSpots++;
+								if(usedSpots == numberOfValues){
+									// The list is filled, stop the loop.
+									usedSpots = 0;
+									break;
+								}
+							}
+						}
 					}
+					// The list is not empty now.
+					int spotIndex = bestSpotList[usedSpots];
+					if(MexArrayB[spotIndex] == bestValue){
+						// The spot is still valid, so use it
+						speedTempMetal_x = spotIndex%MetalMapWidth;
+						speedTempMetal_y = spotIndex/MetalMapWidth;
+						speedTempMetal = bestValue;
+						found = true;
+					}
+					// Update the bestSpotList index
+					usedSpots++;
 				}
-				// The list is not empty now.
-				int spotIndex = bestSpotList[usedSpots];
-				if(MexArrayB[spotIndex] == bestValue){
-					// The spot is still valid, so use it
-					speedTempMetal_x = spotIndex%MetalMapWidth;
-					speedTempMetal_y = spotIndex/MetalMapWidth;
-					speedTempMetal = bestValue;
-					found = true;
-				}
-				// Update the bestSpotList index
-				usedSpots++;
+				coordx = speedTempMetal_x;
+				coordy = speedTempMetal_y;
+				TempMetal = speedTempMetal;
 			}
-			coordx = speedTempMetal_x;
-			coordy = speedTempMetal_y;
-			TempMetal = speedTempMetal;
-		}
-		if (TempMetal &lt; MinMetalForSpot)
-			Stopme = 1; // if the spots get too crappy it will stop running the loops to speed it all up
+			if (TempMetal &lt; MinMetalForSpot)
+				Stopme = 1; // if the spots get too crappy it will stop running the loops to speed it all up
 
-		if (!Stopme){
+			if (!Stopme){
 
-			BufferSpot.x=(float)coordx * 16 + 8; // format metal coords to game-coords
-			BufferSpot.z=(float)coordy * 16 + 8;
-			BufferSpot.y=(float)TempMetal *ai-&gt;cb-&gt;GetMaxMetal() * (float)MaxMetal / 255; //Gets the actual amount of metal an extractor can make
-			VectoredSpots.push_back(BufferSpot);
-			MexArrayC[coordy * MetalMapWidth + coordx] = TempMetal; //plot TGA array (not necessary) for debug
-			NumSpotsFound += 1;
+				BufferSpot.x=(float)coordx * 16 + 8; // format metal coords to game-coords
+				BufferSpot.z=(float)coordy * 16 + 8;
+				BufferSpot.y=(float)TempMetal *ai-&gt;cb-&gt;GetMaxMetal() * (float)MaxMetal / 255; //Gets the actual amount of metal an extractor can make
+				VectoredSpots.push_back(BufferSpot);
+				MexArrayC[coordy * MetalMapWidth + coordx] = TempMetal; //plot TGA array (not necessary) for debug
+				NumSpotsFound += 1;
 
-			// Small speedup of &quot;wipes the metal around the spot so its not counted twice&quot;:
-			for (int sy=coordy-XtractorRadius,a=0;sy&lt;=coordy+XtractorRadius;sy++,a++){
-				if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
-					int clearXStart = coordx-xend[a];
-					int clearXEnd = coordx+xend[a];
-					if(clearXStart &lt; 0)
-						clearXStart = 0;
-					if(clearXEnd &gt;= MetalMapWidth)
-						clearXEnd = MetalMapWidth -1;
-					for(int xClear = clearXStart; xClear &lt;= clearXEnd; xClear++){
-						MexArrayA[sy * MetalMapWidth + xClear] = 0; //wipes the metal around the spot so its not counted twice
-						MexArrayB[sy * MetalMapWidth + xClear] = 0;
-						TempAverage[sy * MetalMapWidth + xClear] = 0;
+				// Small speedup of &quot;wipes the metal around the spot so its not counted twice&quot;:
+				for (int sy=coordy-XtractorRadius,a=0;sy&lt;=coordy+XtractorRadius;sy++,a++){
+					if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+						int clearXStart = coordx-xend[a];
+						int clearXEnd = coordx+xend[a];
+						if(clearXStart &lt; 0)
+							clearXStart = 0;
+						if(clearXEnd &gt;= MetalMapWidth)
+							clearXEnd = MetalMapWidth -1;
+						for(int xClear = clearXStart; xClear &lt;= clearXEnd; xClear++){
+							MexArrayA[sy * MetalMapWidth + xClear] = 0; //wipes the metal around the spot so its not counted twice
+							MexArrayB[sy * MetalMapWidth + xClear] = 0;
+							TempAverage[sy * MetalMapWidth + xClear] = 0;
+						}
 					}
 				}
-			}
 
-			// Redo the whole averaging process around the picked spot so other spots can be found around it
-			for (int y = coordy - DoubleRadius; y &lt;= coordy + DoubleRadius; y++){
-				if(y &gt;=0 &amp;&amp; y &lt; MetalMapHeight){
-					for (int x = coordx - DoubleRadius; x &lt;= coordx + DoubleRadius; x++){
-						if(x &gt;=0 &amp;&amp; x &lt; MetalMapWidth){
-							TotalMetal = 0;
-							if(x == 0 &amp;&amp; y == 0) // Comment out for debug
-								for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
-									if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
-										for (int sx=x-xend[a];sx&lt;=x+xend[a];sx++){
-											if (sx &gt;= 0 &amp;&amp; sx &lt; MetalMapWidth){
-												TotalMetal += MexArrayA[sy * MetalMapWidth + sx]; //get the metal from all pixels around the extractor radius
+				// Redo the whole averaging process around the picked spot so other spots can be found around it
+				for (int y = coordy - DoubleRadius; y &lt;= coordy + DoubleRadius; y++){
+					if(y &gt;=0 &amp;&amp; y &lt; MetalMapHeight){
+						for (int x = coordx - DoubleRadius; x &lt;= coordx + DoubleRadius; x++){
+							if(x &gt;=0 &amp;&amp; x &lt; MetalMapWidth){
+								TotalMetal = 0;
+								if(x == 0 &amp;&amp; y == 0) // Comment out for debug
+									for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+										if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+											for (int sx=x-xend[a];sx&lt;=x+xend[a];sx++){
+												if (sx &gt;= 0 &amp;&amp; sx &lt; MetalMapWidth){
+													TotalMetal += MexArrayA[sy * MetalMapWidth + sx]; //get the metal from all pixels around the extractor radius
+												}
 											}
 										}
 									}
-								}
 
-							// Quick calc test:
-							if(x &gt; 0){
-								TotalMetal = TempAverage[y * MetalMapWidth + x -1];
-								for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
-									if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
-										int addX = x+xend[a];
-										int remX = x-xend[a] -1;
-										if(addX &lt; MetalMapWidth)
-											TotalMetal += MexArrayA[sy * MetalMapWidth + addX];
-										if(remX &gt;= 0)
-											TotalMetal -= MexArrayA[sy * MetalMapWidth + remX];
+								// Quick calc test:
+								if(x &gt; 0){
+									TotalMetal = TempAverage[y * MetalMapWidth + x -1];
+									for (int sy=y-XtractorRadius,a=0;sy&lt;=y+XtractorRadius;sy++,a++){
+										if (sy &gt;= 0 &amp;&amp; sy &lt; MetalMapHeight){
+											int addX = x+xend[a];
+											int remX = x-xend[a] -1;
+											if(addX &lt; MetalMapWidth)
+												TotalMetal += MexArrayA[sy * MetalMapWidth + addX];
+											if(remX &gt;= 0)
+												TotalMetal -= MexArrayA[sy * MetalMapWidth + remX];
+										}
 									}
 								}
-							}
-							else if(y &gt; 0){
-								// x == 0 here
-								TotalMetal = TempAverage[(y-1) * MetalMapWidth];
-								// Remove the top half:
-								int a = XtractorRadius;
-								for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
-									if (sx &lt; MetalMapWidth){
-										int remY = y-xend[a] -1;
-										if(remY &gt;= 0)
-											TotalMetal -= MexArrayA[remY * MetalMapWidth + sx];
+								else if(y &gt; 0){
+									// x == 0 here
+									TotalMetal = TempAverage[(y-1) * MetalMapWidth];
+									// Remove the top half:
+									int a = XtractorRadius;
+									for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+										if (sx &lt; MetalMapWidth){
+											int remY = y-xend[a] -1;
+											if(remY &gt;= 0)
+												TotalMetal -= MexArrayA[remY * MetalMapWidth + sx];
+										}
 									}
-								}
-								// Add the bottom half:
-								a = XtractorRadius;
-								for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
-									if (sx &lt; MetalMapWidth){
-										int addY = y+xend[a];
-										if(addY &lt; MetalMapHeight)
-											TotalMetal += MexArrayA[addY * MetalMapWidth + sx];
+									// Add the bottom half:
+									a = XtractorRadius;
+									for (int sx=0;sx&lt;=XtractorRadius;sx++,a++){
+										if (sx &lt; MetalMapWidth){
+											int addY = y+xend[a];
+											if(addY &lt; MetalMapHeight)
+												TotalMetal += MexArrayA[addY * MetalMapWidth + sx];
+										}
 									}
 								}
+								TempAverage[y * MetalMapWidth + x] = TotalMetal;
+								MexArrayB[y * MetalMapWidth + x] = TotalMetal * 255 / MaxMetal; //set that spots metal amount
+								// end
 							}
-							TempAverage[y * MetalMapWidth + x] = TotalMetal;
-							MexArrayB[y * MetalMapWidth + x] = TotalMetal * 255 / MaxMetal; //set that spots metal amount
-							// end
 						}
 					}
 				}
-			}
 
 
 
 
+			}
 		}
+		// Kill the lists:
+		delete[] bestSpotList;
+		delete[] valueDist;
+		delete[] xend;
+		if (NumSpotsFound &gt; MaxSpots * 0.95){ // 0.95 used for for reliability, fucking with is bad juju
+			ai-&gt;L &lt;&lt; &quot;Metal Map Found&quot; &lt;&lt; endline;
+			NumSpotsFound = 0; //no point in saving spots if the map is a metalmap
+		}
+		timetaken = clock() - timetaken;
+		ai-&gt;L &lt;&lt; &quot;Time taken to generate spots: &quot; &lt;&lt; timetaken &lt;&lt; &quot;ms.&quot; &lt;&lt; endline;
+
 	}
-	// Kill the lists:
-	delete[] bestSpotList;
-	delete[] valueDist;
-	delete[] xend;
-	if (NumSpotsFound &gt; MaxSpots * 0.95){ // 0.95 used for for reliability, fucking with is bad juju
-		ai-&gt;L &lt;&lt; &quot;Metal Map Found&quot; &lt;&lt; endline;
-		NumSpotsFound = 0; //no point in saving spots if the map is a metalmap
-	}
-	timetaken = clock() - timetaken;
-	ai-&gt;L &lt;&lt; &quot;Time taken to generate spots: &quot; &lt;&lt; timetaken &lt;&lt; &quot;ms.&quot; &lt;&lt; endline;
 
-}
+	void CMetalMap::SaveMetalMap(){
+		char buffer[1000];
+		string filename = ai-&gt;info-&gt;datapath + string(&quot;/MexData/&quot;) + string(ai-&gt;cb-&gt;GetMapName());
+		filename.resize(filename.size()-3);
+		filename += string(&quot;Mv&quot;);
+		filename += string(M_CLASS_VERSION);
 
-void CMetalMap::SaveMetalMap(){
-	char buffer[1000];
-	string filename = ai-&gt;info-&gt;datapath + string(&quot;/MexData/&quot;) + string(ai-&gt;cb-&gt;GetMapName());
-	filename.resize(filename.size()-3);
-	filename += string(&quot;Mv&quot;);
-	filename += string(M_CLASS_VERSION);
+		strcpy(buffer, filename.c_str());
+		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
 
-	strcpy(buffer, filename.c_str());
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
-
-	FILE *save_file = fopen(buffer, &quot;wb&quot;);
-	if(save_file){
-		fwrite(&amp;NumSpotsFound, sizeof(int), 1, save_file);
-		//L(&quot;Spots found: &quot; &lt;&lt; NumSpotsFound &lt;&lt; &quot; AverageMetal: &quot; &lt;&lt; AverageMetal);
-		fwrite(&amp;AverageMetal, sizeof(float), 1, save_file);
-		for(int i = 0; i &lt; NumSpotsFound; i++){
-			////L(&quot;Loaded i: &quot; &lt;&lt; i &lt;&lt; &quot;, x; &quot; &lt;&lt; VectoredSpots[i].x &lt;&lt; &quot;, y; &quot; &lt;&lt; VectoredSpots[i].z &lt;&lt; &quot;, value: &quot; &lt;&lt; VectoredSpots[i].y );
-			fwrite(&amp;VectoredSpots[i], sizeof(float3), 1, save_file);
+		FILE *save_file = fopen(buffer, &quot;wb&quot;);
+		if(save_file){
+			fwrite(&amp;NumSpotsFound, sizeof(int), 1, save_file);
+			//L(&quot;Spots found: &quot; &lt;&lt; NumSpotsFound &lt;&lt; &quot; AverageMetal: &quot; &lt;&lt; AverageMetal);
+			fwrite(&amp;AverageMetal, sizeof(float), 1, save_file);
+			for(int i = 0; i &lt; NumSpotsFound; i++){
+				////L(&quot;Loaded i: &quot; &lt;&lt; i &lt;&lt; &quot;, x; &quot; &lt;&lt; VectoredSpots[i].x &lt;&lt; &quot;, y; &quot; &lt;&lt; VectoredSpots[i].z &lt;&lt; &quot;, value: &quot; &lt;&lt; VectoredSpots[i].y );
+				fwrite(&amp;VectoredSpots[i], sizeof(float3), 1, save_file);
+			}
+			fclose(save_file);
+			ai-&gt;L &lt;&lt; &quot;Metal Spots created and saved!&quot; &lt;&lt; endline;
+		}else{
+			ai-&gt;L &lt;&lt; &quot;Metal Spots couldnt be saved! to &quot;&lt;&lt; filename &lt;&lt; endline;
 		}
-		fclose(save_file);
-		ai-&gt;L &lt;&lt; &quot;Metal Spots created and saved!&quot; &lt;&lt; endline;
-	}else{
-		ai-&gt;L &lt;&lt; &quot;Metal Spots couldnt be saved! to &quot;&lt;&lt; filename &lt;&lt; endline;
 	}
-}
 
-bool CMetalMap::LoadMetalMap(){
-	char buffer[1000];
-	string filename = ai-&gt;info-&gt;datapath + string(&quot;/MexData/&quot;) + string(ai-&gt;cb-&gt;GetMapName());
-	filename.resize(filename.size()-3);
-	filename += string(&quot;Mv&quot;);
-	filename += string(M_CLASS_VERSION);
+	bool CMetalMap::LoadMetalMap(){
+		char buffer[1000];
+		string filename = ai-&gt;info-&gt;datapath + string(&quot;/MexData/&quot;) + string(ai-&gt;cb-&gt;GetMapName());
+		filename.resize(filename.size()-3);
+		filename += string(&quot;Mv&quot;);
+		filename += string(M_CLASS_VERSION);
 
-	strcpy(buffer, filename.c_str());
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buffer);
+		strcpy(buffer, filename.c_str());
+		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buffer);
 
-	FILE *load_file;
-	// load Spots if file exists
-	if(load_file = fopen(buffer, &quot;rb&quot;)){
-		fread(&amp;NumSpotsFound, sizeof(int), 1, load_file);
-		VectoredSpots.resize(NumSpotsFound);
-		fread(&amp;AverageMetal, sizeof(float), 1, load_file);
-		for(int i = 0; i &lt; NumSpotsFound; i++){
-			fread(&amp;VectoredSpots[i], sizeof(float3), 1, load_file);
-			////L(&quot;Loaded i: &quot; &lt;&lt; i &lt;&lt; &quot;, x; &quot; &lt;&lt; VectoredSpots[i].x &lt;&lt; &quot;, y; &quot; &lt;&lt; VectoredSpots[i].z &lt;&lt; &quot;, value: &quot; &lt;&lt; VectoredSpots[i].y );
+		FILE *load_file;
+		// load Spots if file exists
+		if(load_file = fopen(buffer, &quot;rb&quot;)){
+			fread(&amp;NumSpotsFound, sizeof(int), 1, load_file);
+			VectoredSpots.resize(NumSpotsFound);
+			fread(&amp;AverageMetal, sizeof(float), 1, load_file);
+			for(int i = 0; i &lt; NumSpotsFound; i++){
+				fread(&amp;VectoredSpots[i], sizeof(float3), 1, load_file);
+				////L(&quot;Loaded i: &quot; &lt;&lt; i &lt;&lt; &quot;, x; &quot; &lt;&lt; VectoredSpots[i].x &lt;&lt; &quot;, y; &quot; &lt;&lt; VectoredSpots[i].z &lt;&lt; &quot;, value: &quot; &lt;&lt; VectoredSpots[i].y );
+			}
+			fclose(load_file);
+			ai-&gt;L &lt;&lt; &quot;Metal Spots loaded from file&quot; &lt;&lt; endline;
+			return true;
+		}else{
+			ai-&gt;L &lt;&lt; &quot;Metal Spots couldnt be loaded from file &quot; &lt;&lt; filename &lt;&lt; endline;
+			return false;
 		}
-		fclose(load_file);
-		ai-&gt;L &lt;&lt; &quot;Metal Spots loaded from file&quot; &lt;&lt; endline;
-		return true;
-	}else{
-		ai-&gt;L &lt;&lt; &quot;Metal Spots couldnt be loaded from file &quot; &lt;&lt; filename &lt;&lt; endline;
-		return false;
+
 	}
-
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/RadarHandler.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/RadarHandler.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Terrain/RadarHandler.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,96 +1,98 @@
 #include &quot;../../Core/include.h&quot;
 
+
 // this class is courtesy fo the OTAI project.
 // Written by Veylon, slightly modified by AF.
 // Distributed under GPL V2
+namespace ntai {
+	int mandist(int x1, int y1, int x2, int y2){
+		return abs(x1 - x2) + abs(y1 - y2);
+	}
 
-int mandist(int x1, int y1, int x2, int y2){
-	return abs(x1 - x2) + abs(y1 - y2);
-}
+	int RevDist(int X1, int Y1, int X2, int Y2, int Max, int Increment){
+		int dist = mandist(X1, Y1, X2, Y2);
+		if(dist * Increment &gt; Max)
+			return 0;
+		else
+			return Max - dist * Increment;
+	}
 
-int RevDist(int X1, int Y1, int X2, int Y2, int Max, int Increment){
-	int dist = mandist(X1, Y1, X2, Y2);
-	if(dist * Increment &gt; Max)
-		return 0;
-	else
-		return Max - dist * Increment;
-}
+	float Dist(float x1, float y1, float x2, float y2){
+		return (float)hypot(fabs(x1 - x2), fabs(y1-y2));
+	}
 
-float Dist(float x1, float y1, float x2, float y2){
-	return (float)hypot(fabs(x1 - x2), fabs(y1-y2));
-}
+	float F3Dist(float3 A, float3 B){
+		return A.distance2D(B);
+	}
 
-float F3Dist(float3 A, float3 B){
-	return A.distance2D(B);
-}
+	CRadarHandler::CRadarHandler(Global*_gs):
+	G(_gs),
+	RadMap(NULL){
+		RadMap = new unsigned char[(G-&gt;cb-&gt;GetMapWidth() / 8) * (G-&gt;cb-&gt;GetMapHeight() / 8)];
+		if(RadMap == NULL)
+		for(int n=0; n&lt;G-&gt;cb-&gt;GetMapHeight()/8 * G-&gt;cb-&gt;GetMapWidth()/8; n++)
+			RadMap[n] = 0;
+	}
 
-CRadarHandler::CRadarHandler(Global*_gs):
-G(_gs),
-RadMap(NULL){
-    RadMap = new unsigned char[(G-&gt;cb-&gt;GetMapWidth() / 8) * (G-&gt;cb-&gt;GetMapHeight() / 8)];
-    if(RadMap == NULL)
-    for(int n=0; n&lt;G-&gt;cb-&gt;GetMapHeight()/8 * G-&gt;cb-&gt;GetMapWidth()/8; n++)
-        RadMap[n] = 0;
-}
+	CRadarHandler::~CRadarHandler(){
+		if(RadMap != NULL)
+			delete [] RadMap;
+	}
 
-CRadarHandler::~CRadarHandler(){
-	if(RadMap != NULL)
-        delete [] RadMap;
-}
+	void CRadarHandler::Change(int unit, bool Removed){
+		int w = int(G-&gt;cb-&gt;GetMapWidth() / 8);
+		int h = int(G-&gt;cb-&gt;GetMapHeight() / 8);
+		int ux = int(G-&gt;cb-&gt;GetUnitPos(unit).x / 64);
+		int uy = int(G-&gt;cb-&gt;GetUnitPos(unit).z / 64);
+		int r = int(G-&gt;cb-&gt;GetUnitDef(unit)-&gt;radarRadius / 8.0f);
+		int minx = ux - r &lt; 0 ? 0 : ux - r;
+		int maxx = ux + r &gt;= w ? w-1 : ux + r;
+		int miny = uy - r &lt; 0 ? 0 : ux - r;
+		int maxy = uy + r &gt;= h ? h-1 : uy + r;
+		int x,y;
+		if(!Removed)    // New Radar
+			for(y = miny; y &lt;= maxy; y++)
+				for(x = minx; x &lt;= maxx; x++)
+					if(Dist((float)x,(float)y,(float)ux,(float)uy) &lt;= r)
+						RadMap[y * w + x]++;
+		else            // Lost Radar
+			for(y = miny; y &lt;= maxy; y++)
+				for(x = minx; x &lt;= maxx; x++)
+					if(Dist((float)x,(float)y,(float)ux,(float)uy) &lt;= r)
+						RadMap[y * w + x]--;
+	}
 
-void CRadarHandler::Change(int unit, bool Removed){
-    int w = int(G-&gt;cb-&gt;GetMapWidth() / 8);
-    int h = int(G-&gt;cb-&gt;GetMapHeight() / 8);
-    int ux = int(G-&gt;cb-&gt;GetUnitPos(unit).x / 64);
-    int uy = int(G-&gt;cb-&gt;GetUnitPos(unit).z / 64);
-    int r = int(G-&gt;cb-&gt;GetUnitDef(unit)-&gt;radarRadius / 8.0f);
-    int minx = ux - r &lt; 0 ? 0 : ux - r;
-    int maxx = ux + r &gt;= w ? w-1 : ux + r;
-    int miny = uy - r &lt; 0 ? 0 : ux - r;
-    int maxy = uy + r &gt;= h ? h-1 : uy + r;
-    int x,y;
-    if(!Removed)    // New Radar
-        for(y = miny; y &lt;= maxy; y++)
-            for(x = minx; x &lt;= maxx; x++)
-                if(Dist((float)x,(float)y,(float)ux,(float)uy) &lt;= r)
-                    RadMap[y * w + x]++;
-    else            // Lost Radar
-        for(y = miny; y &lt;= maxy; y++)
-            for(x = minx; x &lt;= maxx; x++)
-                if(Dist((float)x,(float)y,(float)ux,(float)uy) &lt;= r)
-                    RadMap[y * w + x]--;
-}
-
-float3 CRadarHandler::NextSite(float3 builderpos, const UnitDef* unit, int MaxDist){
-    int w = int(G-&gt;cb-&gt;GetMapWidth() / 8);
-    int h = int(G-&gt;cb-&gt;GetMapHeight() / 8);
-    int bx = int(builderpos.x / 64.0f);
-    int by = int(builderpos.z / 64.0f);
-    int r = int(MaxDist / 64.0f);
-    int minx = bx - r &lt; 0 ? 0 : bx - r;
-    int maxx = bx + r &gt;= w ? w-1 : bx + r;
-    int miny = by - r &lt; 0 ? 0 : bx - r;
-    int maxy = by + r &gt;= h ? h-1 : by + r;
-    int bestvalue = 0;
-    int bestx = 0;
-    int besty = 0;
-    const unsigned short *RMap = G-&gt;cb-&gt;GetRadarMap();
-	for(int y=miny; y&lt;=maxy; y++){
-        for(int x=minx; x&lt;=maxx; x++){
-            float height = G-&gt;cb-&gt;GetElevation(y * 64.0f, x * 64.0f);
-            if(height &gt; 0 &amp;&amp; !RMap[y * w + x]){
-                int value = int(height / 10.0f) - int(mandist(bx,by,x,y)/2.0f);
-                if(value &gt; bestvalue){
-                        bestvalue = value;
-                        bestx = x;
-                        besty = y;
-                }
-            }
-        }
+	float3 CRadarHandler::NextSite(float3 builderpos, const UnitDef* unit, int MaxDist){
+		int w = int(G-&gt;cb-&gt;GetMapWidth() / 8);
+		int h = int(G-&gt;cb-&gt;GetMapHeight() / 8);
+		int bx = int(builderpos.x / 64.0f);
+		int by = int(builderpos.z / 64.0f);
+		int r = int(MaxDist / 64.0f);
+		int minx = bx - r &lt; 0 ? 0 : bx - r;
+		int maxx = bx + r &gt;= w ? w-1 : bx + r;
+		int miny = by - r &lt; 0 ? 0 : bx - r;
+		int maxy = by + r &gt;= h ? h-1 : by + r;
+		int bestvalue = 0;
+		int bestx = 0;
+		int besty = 0;
+		const unsigned short *RMap = G-&gt;cb-&gt;GetRadarMap();
+		for(int y=miny; y&lt;=maxy; y++){
+			for(int x=minx; x&lt;=maxx; x++){
+				float height = G-&gt;cb-&gt;GetElevation(y * 64.0f, x * 64.0f);
+				if(height &gt; 0 &amp;&amp; !RMap[y * w + x]){
+					int value = int(height / 10.0f) - int(mandist(bx,by,x,y)/2.0f);
+					if(value &gt; bestvalue){
+							bestvalue = value;
+							bestx = x;
+							besty = y;
+					}
+				}
+			}
+		}
+		if(bestvalue == 0){
+			return UpVector;
+		}else{
+			return float3(bestx * 64.0f, 0.0f, besty * 64.0f);
+		}
 	}
-	if(bestvalue == 0){
-		return UpVector;
-	}else{
-		return float3(bestx * 64.0f, 0.0f, besty * 64.0f);
-	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/Units/CUnitDefLoader.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/Units/CUnitDefLoader.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/Units/CUnitDefLoader.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,142 +1,144 @@
 #include &quot;../../Core/include.h&quot;
 
-CUnitDefLoader::CUnitDefLoader(Global* GL){
+namespace ntai {
+	CUnitDefLoader::CUnitDefLoader(Global* GL){
 
-	// Initialize pointer to the Global class
-	G = GL;
-	
-	// retrieve the number of unit definitions
-	unum = G-&gt;cb-&gt;GetNumUnitDefs();
+		// Initialize pointer to the Global class
+		G = GL;
+		
+		// retrieve the number of unit definitions
+		unum = G-&gt;cb-&gt;GetNumUnitDefs();
 
-	// for debugging purposes:
-	//G-&gt;L.iprint(&quot;AI interface says this mod has this many units! :: &quot;+to_string(unum));
-	
-	// Check if a horrific error has occured
-	if(unum &lt; 1){
-		// omgwtf this should never happen!
-		G-&gt;L.eprint(&quot;URGENT! GetNumUnitDefs returned ZERO!! This means that there are no unit definitions of any kind!!! Unrecoverable error!&quot;);
+		// for debugging purposes:
+		//G-&gt;L.iprint(&quot;AI interface says this mod has this many units! :: &quot;+to_string(unum));
+		
+		// Check if a horrific error has occured
+		if(unum &lt; 1){
+			// omgwtf this should never happen!
+			G-&gt;L.eprint(&quot;URGENT! GetNumUnitDefs returned ZERO!! This means that there are no unit definitions of any kind!!! Unrecoverable error!&quot;);
 
-		// A horrible event has occurred somewhere in the spring engine for this to have happened.
-		// Even if the AI could recover from this, the engine could not.
-		// Exit this method immediatly. A crash is likely but if the crash was fixed, the engine
-		// or another AI, would crash afterwards anyway.
-		return;
+			// A horrible event has occurred somewhere in the spring engine for this to have happened.
+			// Even if the AI could recover from this, the engine could not.
+			// Exit this method immediatly. A crash is likely but if the crash was fixed, the engine
+			// or another AI, would crash afterwards anyway.
+			return;
 
-		
-	}
+			
+		}
 
-	// initialize arrays
+		// initialize arrays
 
-	// The unitdeflist array will be passed to the engine where it will be filled with pointers
-	UnitDefList = new const UnitDef*[unum];
+		// The unitdeflist array will be passed to the engine where it will be filled with pointers
+		UnitDefList = new const UnitDef*[unum];
 
-	// retrieve the list of unit definition pointers from the engine
-	G-&gt;cb-&gt;GetUnitDefList(UnitDefList);
+		// retrieve the list of unit definition pointers from the engine
+		G-&gt;cb-&gt;GetUnitDefList(UnitDefList);
 
-	// for each definition
-	for(int n=0; n &lt; unum; n++){
+		// for each definition
+		for(int n=0; n &lt; unum; n++){
 
-		// retrieve the units definition
-		const UnitDef* pud = UnitDefList[n];
+			// retrieve the units definition
+			const UnitDef* pud = UnitDefList[n];
 
-		// initialize a UnitTypeData object
-		CUnitTypeData* cutd = new CUnitTypeData();
-		
-		// now initialize the newly added object with the unit definition
-		cutd-&gt;Init(G,pud);
+			// initialize a UnitTypeData object
+			CUnitTypeData* cutd = new CUnitTypeData();
+			
+			// now initialize the newly added object with the unit definition
+			cutd-&gt;Init(G,pud);
 
-		
-		
+			
+			
 
-		// add it into the main array
-		type_data[pud-&gt;id] = cutd;
+			// add it into the main array
+			type_data[pud-&gt;id] = cutd;
 
 
-		// check if the unit definition is zero, if so skip
-		//if(pud == 0) continue;
+			// check if the unit definition is zero, if so skip
+			//if(pud == 0) continue;
 
-		// make sure the name is in the correct format and add it to the map container
-		string na = pud-&gt;name;
-		trim(na);
-		tolowercase(na);
-		defs[na] = pud-&gt;id;
+			// make sure the name is in the correct format and add it to the map container
+			string na = pud-&gt;name;
+			trim(na);
+			tolowercase(na);
+			defs[na] = pud-&gt;id;
+		}
 	}
-}
 
-CUnitDefLoader::~CUnitDefLoader(){
-	delete[] UnitDefList;
-}
+	CUnitDefLoader::~CUnitDefLoader(){
+		delete[] UnitDefList;
+	}
 
-void CUnitDefLoader::Init(){
-	
-}
+	void CUnitDefLoader::Init(){
+		
+	}
 
-const UnitDef* CUnitDefLoader::GetUnitDefByIndex(int i){
-	if(i &gt; unum) return 0;
-	if(i &lt;0) return 0;
-	return UnitDefList[i];
-}
-
-const UnitDef* CUnitDefLoader::GetUnitDef(string name){
-	string n = name;
-	trim(n);
-	tolowercase(n);
-	if(defs.find(n) != defs.end()){
-		const UnitDef* u = GetUnitDefByIndex(defs[n]);
-		return u;
+	const UnitDef* CUnitDefLoader::GetUnitDefByIndex(int i){
+		if(i &gt; unum) return 0;
+		if(i &lt;0) return 0;
+		return UnitDefList[i];
 	}
-	return 0;
-}
 
-CUnitTypeData* CUnitDefLoader::GetUnitTypeDataByUnitId(int uid){
-
-	if(!ValidUnitID(uid)){
+	const UnitDef* CUnitDefLoader::GetUnitDef(string name){
+		string n = name;
+		trim(n);
+		tolowercase(n);
+		if(defs.find(n) != defs.end()){
+			const UnitDef* u = GetUnitDefByIndex(defs[n]);
+			return u;
+		}
 		return 0;
 	}
 
-	const UnitDef* ud = G-&gt;GetUnitDef(uid);
-	if(ud == 0){
-		return 0;
-	}else{
-		return this-&gt;GetUnitTypeDataById(ud-&gt;id);
+	CUnitTypeData* CUnitDefLoader::GetUnitTypeDataByUnitId(int uid){
+
+		if(!ValidUnitID(uid)){
+			return 0;
+		}
+
+		const UnitDef* ud = G-&gt;GetUnitDef(uid);
+		if(ud == 0){
+			return 0;
+		}else{
+			return this-&gt;GetUnitTypeDataById(ud-&gt;id);
+		}
 	}
-}
 
-CUnitTypeData* CUnitDefLoader::GetUnitTypeDataById(int id){
-	//
-	if((id &lt;0)||(id &gt; unum)){
-		return 0;
-	}else{
-		return this-&gt;type_data[id];
+	CUnitTypeData* CUnitDefLoader::GetUnitTypeDataById(int id){
+		//
+		if((id &lt;0)||(id &gt; unum)){
+			return 0;
+		}else{
+			return this-&gt;type_data[id];
+		}
 	}
-}
 
-CUnitTypeData* CUnitDefLoader::GetUnitTypeDataByName(string name){
+	CUnitTypeData* CUnitDefLoader::GetUnitTypeDataByName(string name){
 
-	//
+		//
 
-	int id = GetIdByName(name);
-	return GetUnitTypeDataById(id);
+		int id = GetIdByName(name);
+		return GetUnitTypeDataById(id);
 
 
-}
+	}
 
-int CUnitDefLoader::GetIdByName(string name){
-	//
-	string n = name;
-	trim(n);
-	tolowercase(n);
-	if(defs.find(n) != defs.end()){
-		return defs[n];
-	}else{
-		return -1;
+	int CUnitDefLoader::GetIdByName(string name){
+		//
+		string n = name;
+		trim(n);
+		tolowercase(n);
+		if(defs.find(n) != defs.end()){
+			return defs[n];
+		}else{
+			return -1;
+		}
 	}
-}
 
-bool CUnitDefLoader::HasUnit(string name){
-	//
-	string n = name;
-	trim(n);
-	tolowercase(n);
-	return (defs.find(n) != defs.end());
+	bool CUnitDefLoader::HasUnit(string name){
+		//
+		string n = name;
+		trim(n);
+		tolowercase(n);
+		return (defs.find(n) != defs.end());
+	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/tdf_grammar.hpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/tdf_grammar.hpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/tdf_grammar.hpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -17,131 +17,132 @@
 #include &lt;boost/spirit/error_handling/exceptions.hpp&gt;
 //#include &quot;TdfParser.h&quot;
 
+namespace ntai {
+	/**
+	 * \brief Simple std::ostream Actor, with fixed prefix or suffix. 
+	 * This actor prints the item parsed using the ostream, enclosed
+	 * by suffix and prefix string. 
+	 */
+	class ostream_actor
+	{
+	  private:
+		std::ostream &amp; ref;
+		std::string prefix, suffix;
 
-/**
- * \brief Simple std::ostream Actor, with fixed prefix or suffix. 
- * This actor prints the item parsed using the ostream, enclosed
- * by suffix and prefix string. 
- */
-class ostream_actor
-{
-  private:
-    std::ostream &amp; ref;
-    std::string prefix, suffix;
+	  public:
+		ostream_actor( std::ostream &amp; ref_, std::string const&amp; addition = &quot;&quot; ) 
+		  : ref( ref_ ), suffix(addition) {};
+		ostream_actor( std::string prefix, std::ostream &amp; ref_, std::string const&amp; addition = &quot;&quot; ) 
+		  : ref( ref_ ), prefix(prefix), suffix(addition) {};
+	 
+		template&lt;typename T2&gt; void operator()(T2 const&amp; val ) const { ref &lt;&lt; prefix &lt;&lt; val &lt;&lt; suffix; }
 
-  public:
-    ostream_actor( std::ostream &amp; ref_, std::string const&amp; addition = &quot;&quot; ) 
-      : ref( ref_ ), suffix(addition) {};
-    ostream_actor( std::string prefix, std::ostream &amp; ref_, std::string const&amp; addition = &quot;&quot; ) 
-      : ref( ref_ ), prefix(prefix), suffix(addition) {};
- 
-    template&lt;typename T2&gt; void operator()(T2 const&amp; val ) const { ref &lt;&lt; prefix &lt;&lt; val &lt;&lt; suffix; }
+		template&lt;typename IteratorT&gt;
+		void operator()( IteratorT const&amp; first, IteratorT const&amp; last ) const { ref &lt;&lt; prefix &lt;&lt; std::string(first, last) &lt;&lt; suffix; }
+	};
 
-    template&lt;typename IteratorT&gt;
-    void operator()( IteratorT const&amp; first, IteratorT const&amp; last ) const { ref &lt;&lt; prefix &lt;&lt; std::string(first, last) &lt;&lt; suffix; }
-};
+	/**
+	 * \name Actor functions
+	 * uese these two functions to create a semantic action with ostream_actor. 
+	 * \{
+	 */
+	inline ostream_actor ostream_a( std::string const&amp; prefix, std::ostream &amp; ref, std::string const&amp; suffix =&quot;&quot; ) 
+	{ return ostream_actor(prefix, ref, suffix); }
+	inline ostream_actor ostream_a( std::ostream &amp; ref, std::string const&amp; suffix= &quot;&quot;  ) 
+	{ return ostream_actor(ref, suffix ); }
+	/**
+	 * \}
+	 */
 
-/**
- * \name Actor functions
- * uese these two functions to create a semantic action with ostream_actor. 
- * \{
- */
-inline ostream_actor ostream_a( std::string const&amp; prefix, std::ostream &amp; ref, std::string const&amp; suffix =&quot;&quot; ) 
-{ return ostream_actor(prefix, ref, suffix); }
-inline ostream_actor ostream_a( std::ostream &amp; ref, std::string const&amp; suffix= &quot;&quot;  ) 
-{ return ostream_actor(ref, suffix ); }
-/**
- * \}
- */
 
+	struct tdf_grammar : public boost::spirit::grammar&lt;tdf_grammar&gt; {
+	  enum Errors {
+		semicolon_expected
+		  , equals_sign_expected
+		  , square_bracket_expected
+		  , brace_expected 
+	  };
+	  typedef std::map&lt;std::string,std::string&gt; map_type;
+	  typedef map_type::value_type value_t;
+	  typedef std::pair&lt;map_type::iterator,bool&gt; insert_ret;
 
-struct tdf_grammar : public boost::spirit::grammar&lt;tdf_grammar&gt; {
-  enum Errors {
-    semicolon_expected
-      , equals_sign_expected
-      , square_bracket_expected
-      , brace_expected 
-  };
-  typedef std::map&lt;std::string,std::string&gt; map_type;
-  typedef map_type::value_type value_t;
-  typedef std::pair&lt;map_type::iterator,bool&gt; insert_ret;
+	  struct section_closure : boost::spirit::closure&lt;section_closure, TdfParser::TdfSection *&gt;{ member1 context; };
 
-  struct section_closure : boost::spirit::closure&lt;section_closure, TdfParser::TdfSection *&gt;{ member1 context; };
+	  struct string_closure : boost::spirit::closure&lt;string_closure, std::string&gt;{ member1 name; };
 
-  struct string_closure : boost::spirit::closure&lt;string_closure, std::string&gt;{ member1 name; };
+	  TdfParser::TdfSection *section;
+	  mutable std::list&lt;std::string&gt;  *junk;
+	  tdf_grammar( TdfParser::TdfSection* sec, std::list&lt;std::string&gt; * junk_data )
+		: section(sec), junk(junk_data)
+		{ }
+	  template&lt;typename ScannerT&gt;
+	  struct definition {
 
-  TdfParser::TdfSection *section;
-  mutable std::list&lt;std::string&gt;  *junk;
-  tdf_grammar( TdfParser::TdfSection* sec, std::list&lt;std::string&gt; * junk_data )
-    : section(sec), junk(junk_data)
-    { }
-  template&lt;typename ScannerT&gt;
-  struct definition {
+		boost::spirit::rule&lt;ScannerT&gt;  tdf, gather_junk_line;
+		boost::spirit::rule&lt;ScannerT, string_closure::context_t&gt; name;
+		boost::spirit::rule&lt;ScannerT, section_closure::context_t&gt; section;
 
-    boost::spirit::rule&lt;ScannerT&gt;  tdf, gather_junk_line;
-    boost::spirit::rule&lt;ScannerT, string_closure::context_t&gt; name;
-    boost::spirit::rule&lt;ScannerT, section_closure::context_t&gt; section;
+		boost::spirit::assertion&lt;Errors&gt; expect_semicolon, expect_equals_sign, expect_square_bracket, expect_brace;
 
-    boost::spirit::assertion&lt;Errors&gt; expect_semicolon, expect_equals_sign, expect_square_bracket, expect_brace;
+		std::string temp1;
 
-    std::string temp1;
+		definition(tdf_grammar const&amp; self) 
+		  : expect_semicolon(semicolon_expected)
+		  , expect_equals_sign(equals_sign_expected)
+		  , expect_square_bracket(square_bracket_expected)
+		  , expect_brace(brace_expected)
+		{ 
+		  using namespace boost::spirit;
+		  using namespace phoenix;
+		  tdf = 
+			*( 
+				section(self.section) 
+				| gather_junk_line  // if this rule gets hit then section did not consume everything,
+			 ) 
+			;
 
-    definition(tdf_grammar const&amp; self) 
-      : expect_semicolon(semicolon_expected)
-      , expect_equals_sign(equals_sign_expected)
-      , expect_square_bracket(square_bracket_expected)
-      , expect_brace(brace_expected)
-    { 
-      using namespace boost::spirit;
-      using namespace phoenix;
-      tdf = 
-        *( 
-            section(self.section) 
-            | gather_junk_line  // if this rule gets hit then section did not consume everything,
-         ) 
-        ;
+		  gather_junk_line = 
+			lexeme_d[
+			(+(~chset&lt;&gt;(&quot;}[\n&quot;)))
+			[ push_back_a( * self.junk  ) ]
+	//         [ ostream_a( &quot;Junk detected:&quot;, std::cout, &quot;\n&quot; ) ] // debug printouts
+			]
+			;
 
-      gather_junk_line = 
-        lexeme_d[
-        (+(~chset&lt;&gt;(&quot;}[\n&quot;)))
-        [ push_back_a( * self.junk  ) ]
-//         [ ostream_a( &quot;Junk detected:&quot;, std::cout, &quot;\n&quot; ) ] // debug printouts
-        ]
-        ;
+		  name =  
+			//(+chset&lt;&gt;(&quot;a-zA-Z0-9_+,-&quot;)) 
+			(+(~chset&lt;&gt;(&quot;;{[]}=\n&quot;))) // allows pretty much everything that isnt already used
+			[ name.name = construct_&lt;std::string&gt;(arg1, arg2) ] 
+			;
 
-      name =  
-        //(+chset&lt;&gt;(&quot;a-zA-Z0-9_+,-&quot;)) 
-        (+(~chset&lt;&gt;(&quot;;{[]}=\n&quot;))) // allows pretty much everything that isnt already used
-        [ name.name = construct_&lt;std::string&gt;(arg1, arg2) ] 
-        ;
+		  section = 
+			'[' 
+			&gt;&gt; name
+	   //     [ ostream_a( &quot;Just parsed a section: &quot;, std::cout, &quot;\n&quot;) ] // prints section name
+			[ section.context = bind( &amp;TdfParser::TdfSection::construct_subsection )(section.context, arg1)  ]
+			&gt;&gt; expect_square_bracket( ch_p(']') )
+			&gt;&gt; expect_brace (ch_p('{') )
+			&gt;&gt; *
+			(
+			 (
+			  name
+			  [var(temp1) = arg1] 
+			  &gt;&gt; ch_p('=') // turn this into expect_equals_sign( ch_p('=') ) if you want more strict parsing
+			  &gt;&gt; lexeme_d[ (*~ch_p(';')) // might be empty too!
+			  [ bind( &amp;TdfParser::TdfSection::add_name_value)(section.context, var(temp1), construct_&lt;std::string&gt;(arg1,arg2) ) ]
+			  ]
+			  &gt;&gt; expect_semicolon( ch_p(';') )
+			 )
+			 | section(section.context)
+			 | gather_junk_line  // if this rule gets touched we either hit a closing section } or there really is junk
+			)
+			&gt;&gt; expect_brace( ch_p('}') )
+			;
+		}
+		boost::spirit::rule&lt;ScannerT&gt; const&amp; start() const { return tdf; }
+	  };
+	};
 
-      section = 
-        '[' 
-        &gt;&gt; name
-   //     [ ostream_a( &quot;Just parsed a section: &quot;, std::cout, &quot;\n&quot;) ] // prints section name
-        [ section.context = bind( &amp;TdfParser::TdfSection::construct_subsection )(section.context, arg1)  ]
-        &gt;&gt; expect_square_bracket( ch_p(']') )
-        &gt;&gt; expect_brace (ch_p('{') )
-        &gt;&gt; *
-        (
-         (
-          name
-          [var(temp1) = arg1] 
-          &gt;&gt; ch_p('=') // turn this into expect_equals_sign( ch_p('=') ) if you want more strict parsing
-          &gt;&gt; lexeme_d[ (*~ch_p(';')) // might be empty too!
-          [ bind( &amp;TdfParser::TdfSection::add_name_value)(section.context, var(temp1), construct_&lt;std::string&gt;(arg1,arg2) ) ]
-          ]
-          &gt;&gt; expect_semicolon( ch_p(';') )
-         )
-         | section(section.context)
-         | gather_junk_line  // if this rule gets touched we either hit a closing section } or there really is junk
-        )
-        &gt;&gt; expect_brace( ch_p('}') )
-        ;
-    }
-    boost::spirit::rule&lt;ScannerT&gt; const&amp; start() const { return tdf; }
-  };
-};
-
+}
 #endif
 

Modified: trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Helpers/ubuild.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,1470 +1,1473 @@
 // Universal build .cpp
 #include &quot;../Core/include.h&quot;
-CUBuild::CUBuild(){
-}
 
-void CUBuild::Init(Global* GL, CUnitTypeData* wu, int uid){
-	G = GL;
-	utd = wu;
-	water = utd-&gt;GetUnitDef()-&gt;floater;
-	this-&gt;uid = uid;
-}
+namespace ntai {
+	CUBuild::CUBuild(){
+	}
 
-CUBuild::~CUBuild(){
-}
+	void CUBuild::Init(Global* GL, CUnitTypeData* wu, int uid){
+		G = GL;
+		utd = wu;
+		water = utd-&gt;GetUnitDef()-&gt;floater;
+		this-&gt;uid = uid;
+	}
 
-bool CUBuild::OkBuildSelection(string name){
+	CUBuild::~CUBuild(){
+	}
 
-	CUnitTypeData* u =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(name);
+	bool CUBuild::OkBuildSelection(string name){
 
+		CUnitTypeData* u =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(name);
 
-	float emax=1000000000;
-	string key = &quot;Resource\\MaxEnergy\\&quot;;
-	key += u-&gt;GetName();
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default/**/
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
-		//G-&gt;L.print(&quot;Factor::CBuild  emax &quot; + name);
-		return false;
-	}
-	//NLOG(&quot;CManufacturer::CBuild  Resource\\MinEnergy\\&quot;);
-	float emin=1;
-	key = &quot;Resource\\MinEnergy\\&quot;;
-	key += u-&gt;GetName();
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default/**/
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
-		//G-&gt;L.print(&quot;Factor::CBuild  emin &quot; + name);
-		return false;
-	}
-	// Now sort out stuff that can only be built one at a time
 
-	if(u-&gt;GetSoloBuild()){
-		if(u-&gt;GetSoloBuildActive()){
-			// One is already being built! We're not supposed to build more than one at any one time.
+		float emax=1000000000;
+		string key = &quot;Resource\\MaxEnergy\\&quot;;
+		key += u-&gt;GetName();
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default/**/
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
+			//G-&gt;L.print(&quot;Factor::CBuild  emax &quot; + name);
 			return false;
 		}
-		deque&lt;CBPlan* &gt;* b = G-&gt;Manufacturer-&gt;BPlans;
-		if(b-&gt;empty() == false){
-			//
-			for(deque&lt;CBPlan* &gt;::iterator i = b-&gt;begin(); i != b-&gt;end(); ++i){
-				string s = (*i)-&gt;utd-&gt;GetName();
-				if(s == u-&gt;GetName()){
-					return false;
+		//NLOG(&quot;CManufacturer::CBuild  Resource\\MinEnergy\\&quot;);
+		float emin=1;
+		key = &quot;Resource\\MinEnergy\\&quot;;
+		key += u-&gt;GetName();
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default/**/
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
+			//G-&gt;L.print(&quot;Factor::CBuild  emin &quot; + name);
+			return false;
+		}
+		// Now sort out stuff that can only be built one at a time
+
+		if(u-&gt;GetSoloBuild()){
+			if(u-&gt;GetSoloBuildActive()){
+				// One is already being built! We're not supposed to build more than one at any one time.
+				return false;
+			}
+			deque&lt;CBPlan* &gt;* b = G-&gt;Manufacturer-&gt;BPlans;
+			if(b-&gt;empty() == false){
+				//
+				for(deque&lt;CBPlan* &gt;::iterator i = b-&gt;begin(); i != b-&gt;end(); ++i){
+					string s = (*i)-&gt;utd-&gt;GetName();
+					if(s == u-&gt;GetName()){
+						return false;
+					}
 				}
 			}
 		}
-	}
 
-	// Now sort out if it's one of those things that can only be built once
-	if(u-&gt;GetSingleBuild()){
+		// Now sort out if it's one of those things that can only be built once
+		if(u-&gt;GetSingleBuild()){
 
-		if(u-&gt;GetSingleBuildActive()){
-			return false;
-		}
+			if(u-&gt;GetSingleBuildActive()){
+				return false;
+			}
 
-		deque&lt;CBPlan* &gt;* b = G-&gt;Manufacturer-&gt;BPlans;
-		if(b-&gt;empty() == false){
-			//
-			for(deque&lt;CBPlan* &gt;::iterator i = b-&gt;begin(); i != b-&gt;end(); ++i){
-				string s = (*i)-&gt;utd-&gt;GetName();
-				if(s == name){
-					return false;
+			deque&lt;CBPlan* &gt;* b = G-&gt;Manufacturer-&gt;BPlans;
+			if(b-&gt;empty() == false){
+				//
+				for(deque&lt;CBPlan* &gt;::iterator i = b-&gt;begin(); i != b-&gt;end(); ++i){
+					string s = (*i)-&gt;utd-&gt;GetName();
+					if(s == name){
+						return false;
+					}
 				}
 			}
 		}
+
+		return true;
 	}
 
-	return true;
-}
+	bool CUBuild::Useless(CUnitTypeData* u){
+		NLOG(&quot;CUBuild::Useless&quot;);
 
-bool CUBuild::Useless(CUnitTypeData* u){
-	NLOG(&quot;CUBuild::Useless&quot;);
 
+		//TODO: Finish CUBuild::Useless()
+		if(G-&gt;Pl-&gt;feasable(utd,u)==false){
+			return false;
+		}
 
-	//TODO: Finish CUBuild::Useless()
-	if(G-&gt;Pl-&gt;feasable(utd,u)==false){
-		return false;
-	}
-
-	if(u != 0){
-		if(!OkBuildSelection(u-&gt;GetName())) return false;
-		if(water){
-			if (u-&gt;GetUnitDef()-&gt;minWaterDepth &lt;= 0) {
-				//it is a ground unit or building
-				if ((u-&gt;GetUnitDef()-&gt;floater==false)&amp;&amp;(u-&gt;GetUnitDef()-&gt;maxWaterDepth &lt; 30)){
-					//unit is ground only
+		if(u != 0){
+			if(!OkBuildSelection(u-&gt;GetName())) return false;
+			if(water){
+				if (u-&gt;GetUnitDef()-&gt;minWaterDepth &lt;= 0) {
+					//it is a ground unit or building
+					if ((u-&gt;GetUnitDef()-&gt;floater==false)&amp;&amp;(u-&gt;GetUnitDef()-&gt;maxWaterDepth &lt; 30)){
+						//unit is ground only
+						return true;
+					}
+				}
+			}else{
+				if (u-&gt;GetUnitDef()-&gt;minWaterDepth &gt; 0) {
+					//it is a water-only unit or building
 					return true;
 				}
 			}
-		}else{
-			if (u-&gt;GetUnitDef()-&gt;minWaterDepth &gt; 0) {
-				//it is a water-only unit or building
-				return true;
+			// do stuff to determine if there is no use for this unit
+			if(u-&gt;GetUnitDef()-&gt;extractRange &gt; 0) return false;
+			if(u-&gt;GetUnitDef()-&gt;radarRadius &gt; 1) return false;
+			if(u-&gt;GetUnitDef()-&gt;sonarJamRadius&gt; 1) return false;
+			
+			if(u-&gt;GetUnitDef()-&gt;sonarRadius &gt; 1){
+				return false;
 			}
+
+			if(u-&gt;GetUnitDef()-&gt;builder == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;weapons.empty() == false) return false;
+			if(u-&gt;GetUnitDef()-&gt;canmove == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;canfly == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;canhover == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;canCapture == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;canDGun == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;canKamikaze == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;canResurrect == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;energyMake &gt; 10) return false;
+			if(u-&gt;GetUnitDef()-&gt;type == string(&quot;MetalExtractor&quot;)) return false;
+			if(u-&gt;GetUnitDef()-&gt;isMetalMaker == true) return false;
+			//if(udt-&gt;isFeature == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;jammerRadius &gt; 10) return false;
+			if(u-&gt;GetUnitDef()-&gt;metalMake &gt; 0) return false;
+			if(u-&gt;GetUnitDef()-&gt;needGeo == true) return false;
+			if(u-&gt;GetUnitDef()-&gt;tidalGenerator &gt; 0) return false;
+			if(u-&gt;GetUnitDef()-&gt;windGenerator &gt; 0) return false;
+			if(u-&gt;GetUnitDef()-&gt;transportCapacity &gt; 0) return false;
+			return true;
 		}
-		// do stuff to determine if there is no use for this unit
-		if(u-&gt;GetUnitDef()-&gt;extractRange &gt; 0) return false;
-		if(u-&gt;GetUnitDef()-&gt;radarRadius &gt; 1) return false;
-		if(u-&gt;GetUnitDef()-&gt;sonarJamRadius&gt; 1) return false;
-		
-		if(u-&gt;GetUnitDef()-&gt;sonarRadius &gt; 1){
-			return false;
-		}
+		return false;
+	}
 
-		if(u-&gt;GetUnitDef()-&gt;builder == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;weapons.empty() == false) return false;
-		if(u-&gt;GetUnitDef()-&gt;canmove == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;canfly == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;canhover == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;canCapture == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;canDGun == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;canKamikaze == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;canResurrect == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;energyMake &gt; 10) return false;
-		if(u-&gt;GetUnitDef()-&gt;type == string(&quot;MetalExtractor&quot;)) return false;
-		if(u-&gt;GetUnitDef()-&gt;isMetalMaker == true) return false;
-		//if(udt-&gt;isFeature == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;jammerRadius &gt; 10) return false;
-		if(u-&gt;GetUnitDef()-&gt;metalMake &gt; 0) return false;
-		if(u-&gt;GetUnitDef()-&gt;needGeo == true) return false;
-		if(u-&gt;GetUnitDef()-&gt;tidalGenerator &gt; 0) return false;
-		if(u-&gt;GetUnitDef()-&gt;windGenerator &gt; 0) return false;
-		if(u-&gt;GetUnitDef()-&gt;transportCapacity &gt; 0) return false;
-		return true;
+	void CUBuild::SetWater(bool w){
+		NLOG(&quot;CUBuild::SetWater&quot;);
+		water =w;
 	}
-	return false;
-}
 
-void CUBuild::SetWater(bool w){
-	NLOG(&quot;CUBuild::SetWater&quot;);
-	water =w;
-}
-
-string CUBuild::operator() (btype build,float3 pos){// CBuild c; string s = c(btype build);
-	NLOG(&quot;CUBuild::operator()&quot;);
-	string s = &quot;&quot;;
-	if(utd-&gt;GetUnitDef()-&gt;buildOptions.empty()){
-		s;
+	string CUBuild::operator() (btype build,float3 pos){// CBuild c; string s = c(btype build);
+		NLOG(&quot;CUBuild::operator()&quot;);
+		string s = &quot;&quot;;
+		if(utd-&gt;GetUnitDef()-&gt;buildOptions.empty()){
+			s;
+		}
+		switch(build){
+			case B_MEX :{
+				s = GetMEX();
+				break;
+			}case B_POWER:{
+				s = GetPOWER();
+				break;
+			}case B_RAND_ASSAULT:{
+				s = GetRAND_ASSAULT();
+				break;
+			}case B_ASSAULT:{
+				s = GetASSAULT();
+				break;
+			}case B_FACTORY:{
+				s = GetFACTORY();
+				break;
+			}case B_BUILDER:{
+				s = GetBUILDER();
+				break;
+			}case B_GEO:{
+				s = GetGEO();
+				break;
+			}case B_SCOUT:{
+				s = GetSCOUT();
+				break;
+			}case B_RANDOM:{
+				s = GetRANDOM();
+				break;
+			}case B_DEFENCE:{
+				s = GetDEFENCE();
+				break;
+			}case B_RADAR:{
+				s = GetRADAR();
+				break;
+			}case B_ESTORE:{
+				s = GetESTORE();
+				break;
+			}case B_MSTORE:{
+				s = GetMSTORE();
+				break;
+			}case B_SILO:{
+				s = GetSILO();
+				break;
+			}case B_JAMMER:{
+				s = GetJAMMER();
+				break;
+			}case B_SONAR:{
+				s = GetSONAR();
+				break;
+			}case B_ANTIMISSILE:{
+				s = GetANTIMISSILE();
+				break;
+			}case B_ARTILLERY:{
+				s = GetARTILLERY();
+				break;
+			}case B_FOCAL_MINE:{
+				s = GetFOCAL_MINE();
+				break;
+			}case B_SUB : {
+				s = GetSUB();
+				break;
+			}case B_AMPHIB: {
+				s = GetAMPHIB();
+				break;
+			}case B_MINE:{
+				s = GetMINE();
+				break;
+			}case B_CARRIER:{
+				s = GetCARRIER();
+				break;
+			}case B_METAL_MAKER:{
+				s = GetMETAL_MAKER();
+				break;
+			}case B_FORTIFICATION:{
+				s = GetFORTIFICATION();
+				break;
+			}case B_BOMBER:{
+				s = GetBOMBER();
+				break;
+			}case B_FIGHTER:{
+				s = GetFIGHTER();
+				break;
+			}case B_GUNSHIP:{
+				s = GetGUNSHIP();
+				break;
+			}case B_SHIELD:{
+				s = GetSHIELD();
+				break;
+			}case B_MISSILE_UNIT:{
+				s = GetMISSILE_UNIT();
+				break;
+			}case B_HUB:{
+				s = GetHUB();
+				break;
+			}case B_AIRSUPPORT:{
+				s = GetAIRSUPPORT();
+				break;
+			}/*default:{
+				return string(&quot;&quot;);
+				break;
+			}*/
+		}
+		return s;
 	}
-	switch(build){
-		case B_MEX :{
-			s = GetMEX();
-			break;
-		}case B_POWER:{
-			s = GetPOWER();
-			break;
-		}case B_RAND_ASSAULT:{
-			s = GetRAND_ASSAULT();
-			break;
-		}case B_ASSAULT:{
-			s = GetASSAULT();
-			break;
-		}case B_FACTORY:{
-			s = GetFACTORY();
-			break;
-		}case B_BUILDER:{
-			s = GetBUILDER();
-			break;
-		}case B_GEO:{
-			s = GetGEO();
-			break;
-		}case B_SCOUT:{
-			s = GetSCOUT();
-			break;
-		}case B_RANDOM:{
-			s = GetRANDOM();
-			break;
-		}case B_DEFENCE:{
-			s = GetDEFENCE();
-            break;
-		}case B_RADAR:{
-			s = GetRADAR();
-			break;
-		}case B_ESTORE:{
-			s = GetESTORE();
-			break;
-		}case B_MSTORE:{
-			s = GetMSTORE();
-			break;
-		}case B_SILO:{
-			s = GetSILO();
-			break;
-		}case B_JAMMER:{
-			s = GetJAMMER();
-			break;
-		}case B_SONAR:{
-			s = GetSONAR();
-			break;
-		}case B_ANTIMISSILE:{
-			s = GetANTIMISSILE();
-			break;
-		}case B_ARTILLERY:{
-			s = GetARTILLERY();
-			break;
-		}case B_FOCAL_MINE:{
-			s = GetFOCAL_MINE();
-			break;
-		}case B_SUB : {
-			s = GetSUB();
-			break;
-		}case B_AMPHIB: {
-			s = GetAMPHIB();
-			break;
-		}case B_MINE:{
-			s = GetMINE();
-			break;
-		}case B_CARRIER:{
-			s = GetCARRIER();
-			break;
-		}case B_METAL_MAKER:{
-			s = GetMETAL_MAKER();
-			break;
-		}case B_FORTIFICATION:{
-			s = GetFORTIFICATION();
-			break;
-		}case B_BOMBER:{
-			s = GetBOMBER();
-			break;
-		}case B_FIGHTER:{
-			s = GetFIGHTER();
-			break;
-		}case B_GUNSHIP:{
-			s = GetGUNSHIP();
-			break;
-		}case B_SHIELD:{
-			s = GetSHIELD();
-			break;
-		}case B_MISSILE_UNIT:{
-			s = GetMISSILE_UNIT();
-			break;
-		}case B_HUB:{
-			s = GetHUB();
-			break;
-		}case B_AIRSUPPORT:{
-			s = GetAIRSUPPORT();
-			break;
-		}/*default:{
-			return string(&quot;&quot;);
-			break;
-		}*/
-	}
-	return s;
-}
 
-string CUBuild::GetMEX(){
-	NLOG(&quot;CUBuild::GetMEX&quot;);
-	// Find all metal extractors this unit can build and add them to a list.
-	float highscore= 0;
-	string highest=&quot;&quot;;
-	for(map&lt;int,string&gt;::const_iterator is = utd-&gt;GetUnitDef()-&gt;buildOptions.begin(); is != utd-&gt;GetUnitDef()-&gt;buildOptions.end();++is){
+	string CUBuild::GetMEX(){
+		NLOG(&quot;CUBuild::GetMEX&quot;);
+		// Find all metal extractors this unit can build and add them to a list.
+		float highscore= 0;
+		string highest=&quot;&quot;;
+		for(map&lt;int,string&gt;::const_iterator is = utd-&gt;GetUnitDef()-&gt;buildOptions.begin(); is != utd-&gt;GetUnitDef()-&gt;buildOptions.end();++is){
 
-		CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;second);
+			CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;second);
 
-		if(p-&gt;IsMex()){
-			if(Useless(p)){
-				continue;
-			}
+			if(p-&gt;IsMex()){
+				if(Useless(p)){
+					continue;
+				}
 
-			float score = (p-&gt;GetUnitDef()-&gt;extractsMetal+1)*1000;
-			if(p-&gt;GetUnitDef()-&gt;weapons.empty()==false){
-				score *= 1.2f;
-			}
+				float score = (p-&gt;GetUnitDef()-&gt;extractsMetal+1)*1000;
+				if(p-&gt;GetUnitDef()-&gt;weapons.empty()==false){
+					score *= 1.2f;
+				}
 
-			if(p-&gt;GetUnitDef()-&gt;canCloak==true){
-				score *= 1.2f;
-			}
+				if(p-&gt;GetUnitDef()-&gt;canCloak==true){
+					score *= 1.2f;
+				}
 
-			score /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-			if(score &gt; highscore){
-				highscore = score;
-				highest = p-&gt;GetUnitDef()-&gt;name;
+				score /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+				if(score &gt; highscore){
+					highscore = score;
+					highest = p-&gt;GetUnitDef()-&gt;name;
+				}
+
+				continue;
 			}
 
-			continue;
-		}
-
-		if((p-&gt;GetUnitDef()-&gt;metalMake &gt; 5)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;movedata == 0 )&amp;&amp;(p-&gt;GetUnitDef()-&gt;canfly == false)){
-			float score = p-&gt;GetUnitDef()-&gt;metalMake;
-			if(p-&gt;GetUnitDef()-&gt;weapons.empty()==false){
-				score *= 1.2f;
+			if((p-&gt;GetUnitDef()-&gt;metalMake &gt; 5)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;movedata == 0 )&amp;&amp;(p-&gt;GetUnitDef()-&gt;canfly == false)){
+				float score = p-&gt;GetUnitDef()-&gt;metalMake;
+				if(p-&gt;GetUnitDef()-&gt;weapons.empty()==false){
+					score *= 1.2f;
+				}
+				if(p-&gt;GetUnitDef()-&gt;canCloak==true){
+					score *= 1.2f;
+				}
+				score /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+				if(score &gt; highscore){
+					highscore = score;
+					highest = p-&gt;GetUnitDef()-&gt;name;
+				}
+				continue;
 			}
-			if(p-&gt;GetUnitDef()-&gt;canCloak==true){
-				score *= 1.2f;
-			}
-			score /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-			if(score &gt; highscore){
-				highscore = score;
-				highest = p-&gt;GetUnitDef()-&gt;name;
-			}
-			continue;
 		}
+		return highest;
 	}
-	return highest;
-}
 
-string CUBuild::GetPOWER(){
-	NLOG(&quot;CUBuild::GetPOWER&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	// Find all energy generators this unit can build and add them to a list.
-	list&lt;const UnitDef*&gt; possibles_u;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			if(p-&gt;IsEnergy()) possibles_u.push_back(p-&gt;GetUnitDef());
+	string CUBuild::GetPOWER(){
+		NLOG(&quot;CUBuild::GetPOWER&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		// Find all energy generators this unit can build and add them to a list.
+		list&lt;const UnitDef*&gt; possibles_u;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				if(p-&gt;IsEnergy()) possibles_u.push_back(p-&gt;GetUnitDef());
+			}
 		}
-	}
 
-	string best_energy = &quot;&quot;;
-	if(possibles_u.empty() == false){
-		float bestpoint = 0;
-		for(list&lt;const UnitDef*&gt;::iterator pd = possibles_u.begin();pd != possibles_u.end(); ++pd){
-			float temp_energy = 0;
-			if((*pd)-&gt;energyUpkeep &lt;0) temp_energy += -(*pd)-&gt;energyUpkeep;
-			if((*pd)-&gt;windGenerator&gt;1) temp_energy += (G-&gt;cb-&gt;GetMaxWind()+G-&gt;cb-&gt;GetMinWind())/2;
-			if((*pd)-&gt;energyMake &gt; 1) temp_energy += (*pd)-&gt;energyMake;
-			if((*pd)-&gt;tidalGenerator &gt;0) temp_energy += G-&gt;cb-&gt;GetTidalStrength();
-			temp_energy /= ((*pd)-&gt;energyCost+((*pd)-&gt;metalCost*45));
-			if(temp_energy/(((*pd)-&gt;metalCost+(*pd)-&gt;energyCost)/2) &gt; bestpoint){
-				bestpoint = temp_energy;
-				best_energy = (*pd)-&gt;name;
+		string best_energy = &quot;&quot;;
+		if(possibles_u.empty() == false){
+			float bestpoint = 0;
+			for(list&lt;const UnitDef*&gt;::iterator pd = possibles_u.begin();pd != possibles_u.end(); ++pd){
+				float temp_energy = 0;
+				if((*pd)-&gt;energyUpkeep &lt;0) temp_energy += -(*pd)-&gt;energyUpkeep;
+				if((*pd)-&gt;windGenerator&gt;1) temp_energy += (G-&gt;cb-&gt;GetMaxWind()+G-&gt;cb-&gt;GetMinWind())/2;
+				if((*pd)-&gt;energyMake &gt; 1) temp_energy += (*pd)-&gt;energyMake;
+				if((*pd)-&gt;tidalGenerator &gt;0) temp_energy += G-&gt;cb-&gt;GetTidalStrength();
+				temp_energy /= ((*pd)-&gt;energyCost+((*pd)-&gt;metalCost*45));
+				if(temp_energy/(((*pd)-&gt;metalCost+(*pd)-&gt;energyCost)/2) &gt; bestpoint){
+					bestpoint = temp_energy;
+					best_energy = (*pd)-&gt;name;
+				}
 			}
 		}
+		
+		return best_energy;
+		//return string(&quot;&quot;);
 	}
-	
-	return best_energy;
-	//return string(&quot;&quot;);
-}
 
-string CUBuild::GetRAND_ASSAULT(){
-	NLOG(&quot;CUBuild::GetRAND_ASSAULT&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	int defnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+	string CUBuild::GetRAND_ASSAULT(){
+		NLOG(&quot;CUBuild::GetRAND_ASSAULT&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		int defnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-			if(p-&gt;IsAttacker()){
-				possibles.push_back(p-&gt;GetName());
-				defnum++;
+				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+				if(p-&gt;IsAttacker()){
+					possibles.push_back(p-&gt;GetName());
+					defnum++;
+				}
 			}
 		}
-	}
-	if(possibles.empty() == false){
-		defnum = G-&gt;mrand()%defnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == defnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			defnum = G-&gt;mrand()%defnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == defnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
+		}else{
+			return string(&quot;&quot;);
 		}
-		return possibles.front();
-	}else{
-		return string(&quot;&quot;);
 	}
-}
 
-string CUBuild::GetASSAULT(){
-	NLOG(&quot;CUBuild::GetASSAULT&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+	string CUBuild::GetASSAULT(){
+		NLOG(&quot;CUBuild::GetASSAULT&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)==false){
-				continue;
-			}
-			if(p-&gt;IsAttacker()){
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				temp -= (G-&gt;mrand()%max(int(temp/4),1));
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(G-&gt;Pl-&gt;feasable(p,utd)==false){
+					continue;
 				}
+				if(p-&gt;IsAttacker()){
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					temp -= (G-&gt;mrand()%max(int(temp/4),1));
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
+				}
 			}
 		}
+		if(best_score &lt; 30){
+			return GetRAND_ASSAULT();
+		}
+		return best;
 	}
-	if(best_score &lt; 30){
-		return GetRAND_ASSAULT();
-	}
-	return best;
-}
 
 
-string CUBuild::GetBOMBER(){
-	NLOG(&quot;CUBuild::GetBOMBER&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+	string CUBuild::GetBOMBER(){
+		NLOG(&quot;CUBuild::GetBOMBER&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-			if(p-&gt;IsBomber()){
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				temp = temp - G-&gt;mrand()%max(int(temp/4),1);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+				if(p-&gt;IsBomber()){
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					temp = temp - G-&gt;mrand()%max(int(temp/4),1);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetFIGHTER(){
-	NLOG(&quot;CUBuild::GetFIGHTER&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+	string CUBuild::GetFIGHTER(){
+		NLOG(&quot;CUBuild::GetFIGHTER&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-			if(p-&gt;IsFighter()){
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				temp = temp - G-&gt;mrand()%max(int(temp/4),1);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+				if(p-&gt;IsFighter()){
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					temp = temp - G-&gt;mrand()%max(int(temp/4),1);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetGUNSHIP(){
-	NLOG(&quot;CUBuild::GetGUNSHIP&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+	string CUBuild::GetGUNSHIP(){
+		NLOG(&quot;CUBuild::GetGUNSHIP&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-			if(p-&gt;IsGunship()){
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				temp = temp - G-&gt;mrand()%max(int(temp/4),1);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+				if(p-&gt;IsGunship()){
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					temp = temp - G-&gt;mrand()%max(int(temp/4),1);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetMISSILE_UNIT(){
-	NLOG(&quot;CUBuild::GetMISSILE_UNIT&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+	string CUBuild::GetMISSILE_UNIT(){
+		NLOG(&quot;CUBuild::GetMISSILE_UNIT&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &gt; (G-&gt;cb-&gt;GetEnergyStorage()+G-&gt;cb-&gt;GetMetalStorage())*atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;2.1&quot;, &quot;AI\\cheap_multiplier&quot;).c_str())) continue;
-			bool good = true;
-			if(p-&gt;GetUnitDef()-&gt;canfly ==false) good = false;
-			if(p-&gt;GetUnitDef()-&gt;weapons.empty() == true) good = false;
-			if(p-&gt;GetUnitDef()-&gt;builder == true) good = false;
-			if(p-&gt;GetUnitDef()-&gt;transportCapacity &gt; 0) good = false;
-			bool found = false;
-			for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = p-&gt;GetUnitDef()-&gt;weapons.begin(); i != p-&gt;GetUnitDef()-&gt;weapons.end(); ++i){
-				if(i-&gt;def-&gt;interceptor &gt; 0){
-					continue;
+				if(p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &gt; (G-&gt;cb-&gt;GetEnergyStorage()+G-&gt;cb-&gt;GetMetalStorage())*atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;2.1&quot;, &quot;AI\\cheap_multiplier&quot;).c_str())) continue;
+				bool good = true;
+				if(p-&gt;GetUnitDef()-&gt;canfly ==false) good = false;
+				if(p-&gt;GetUnitDef()-&gt;weapons.empty() == true) good = false;
+				if(p-&gt;GetUnitDef()-&gt;builder == true) good = false;
+				if(p-&gt;GetUnitDef()-&gt;transportCapacity &gt; 0) good = false;
+				bool found = false;
+				for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = p-&gt;GetUnitDef()-&gt;weapons.begin(); i != p-&gt;GetUnitDef()-&gt;weapons.end(); ++i){
+					if(i-&gt;def-&gt;interceptor &gt; 0){
+						continue;
+					}
+					if(i-&gt;def-&gt;vlaunch == true){
+						found = true;
+						break;
+					}
 				}
-				if(i-&gt;def-&gt;vlaunch == true){
-					found = true;
-					break;
+				if(found == false) good = false;
+				if(good == true){
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					temp = temp - G-&gt;mrand()%min((int)(temp/3),1);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
-			if(found == false) good = false;
-			if(good == true){
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				temp = temp - G-&gt;mrand()%min((int)(temp/3),1);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
-				}
-			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetSHIELD(){
-	NLOG(&quot;CUBuild::GetSHIELD&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+	string CUBuild::GetSHIELD(){
+		NLOG(&quot;CUBuild::GetSHIELD&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)) continue;
+				if(G-&gt;Pl-&gt;feasable(p,utd)) continue;
 
-			if(p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &gt; (G-&gt;cb-&gt;GetEnergyStorage()+G-&gt;cb-&gt;GetMetalStorage())*atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;2.1&quot;, &quot;AI\\cheap_multiplier&quot;).c_str())) continue;
+				if(p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &gt; (G-&gt;cb-&gt;GetEnergyStorage()+G-&gt;cb-&gt;GetMetalStorage())*atof(G-&gt;Get_mod_tdf()-&gt;SGetValueDef(&quot;2.1&quot;, &quot;AI\\cheap_multiplier&quot;).c_str())) continue;
 
-			bool found = false;
-			if(p-&gt;GetUnitDef()-&gt;weapons.empty() == false){
-				for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = p-&gt;GetUnitDef()-&gt;weapons.begin(); i != p-&gt;GetUnitDef()-&gt;weapons.end(); ++i){
-					if(i-&gt;def-&gt;isShield){
-						found = true;
-						break;
+				bool found = false;
+				if(p-&gt;GetUnitDef()-&gt;weapons.empty() == false){
+					for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = p-&gt;GetUnitDef()-&gt;weapons.begin(); i != p-&gt;GetUnitDef()-&gt;weapons.end(); ++i){
+						if(i-&gt;def-&gt;isShield){
+							found = true;
+							break;
+						}
 					}
 				}
-			}
-			if(found == true){
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				temp = temp - G-&gt;mrand()%max(int(temp/4),1);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(found == true){
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					temp = temp - G-&gt;mrand()%max(int(temp/4),1);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetFACTORY(){
-	NLOG(&quot;CUBuild::GetFACTORY&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+	string CUBuild::GetFACTORY(){
+		NLOG(&quot;CUBuild::GetFACTORY&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			
-			if(p-&gt;IsFactory()){
+				CUnitTypeData* p = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				
+				if(p-&gt;IsFactory()){
 
-				if(!G-&gt;Pl-&gt;feasable(p,utd)) continue;
-				if(p-&gt;IsUWStructure()!=(water||G-&gt;info-&gt;spacemod)) continue;
+					if(!G-&gt;Pl-&gt;feasable(p,utd)) continue;
+					if(p-&gt;IsUWStructure()!=(water||G-&gt;info-&gt;spacemod)) continue;
 
-				float temp = G-&gt;GetEfficiency(p-&gt;GetName());
-				temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-				int r = G-&gt;mrand()%max(int(temp/4),1)+1;
-				temp += (float)abs(r);
+					float temp = G-&gt;GetEfficiency(p-&gt;GetName());
+					temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+					int r = G-&gt;mrand()%max(int(temp/4),1)+1;
+					temp += (float)abs(r);
 
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetBUILDER(){
-	NLOG(&quot;CUBuild::GetBUILDER&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+	string CUBuild::GetBUILDER(){
+		NLOG(&quot;CUBuild::GetBUILDER&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
 
-			if(p-&gt;GetUnitDef()-&gt;builder&amp;&amp;((p-&gt;GetUnitDef()-&gt;movedata !=0)||p-&gt;GetUnitDef()-&gt;canfly)){
-				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-				if(p-&gt;GetUnitDef()-&gt;floater){
-					if(G-&gt;info-&gt;spacemod||water){
-						float temp = G-&gt;GetEfficiency(p-&gt;GetUnitDef()-&gt;name);
-						if(!p-&gt;GetUnitDef()-&gt;buildOptions.empty()){
-							for(map&lt;int,std::string&gt;::const_iterator i = p-&gt;GetUnitDef()-&gt;buildOptions.begin(); i != p-&gt;GetUnitDef()-&gt;buildOptions.end(); ++i){
-								temp += G-&gt;GetEfficiency(i-&gt;second);
+				if(p-&gt;GetUnitDef()-&gt;builder&amp;&amp;((p-&gt;GetUnitDef()-&gt;movedata !=0)||p-&gt;GetUnitDef()-&gt;canfly)){
+					if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+					if(p-&gt;GetUnitDef()-&gt;floater){
+						if(G-&gt;info-&gt;spacemod||water){
+							float temp = G-&gt;GetEfficiency(p-&gt;GetUnitDef()-&gt;name);
+							if(!p-&gt;GetUnitDef()-&gt;buildOptions.empty()){
+								for(map&lt;int,std::string&gt;::const_iterator i = p-&gt;GetUnitDef()-&gt;buildOptions.begin(); i != p-&gt;GetUnitDef()-&gt;buildOptions.end(); ++i){
+									temp += G-&gt;GetEfficiency(i-&gt;second);
+								}
 							}
+							temp*=p-&gt;GetUnitDef()-&gt;buildSpeed;
+							temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
+							temp = temp - G-&gt;mrand()%max(int(temp/4),1);
+							if(temp &gt; best_score){
+								best_score = temp;
+								best = p-&gt;GetName();
+							}
 						}
-						temp*=p-&gt;GetUnitDef()-&gt;buildSpeed;
-						temp /= (p-&gt;GetUnitDef()-&gt;energyCost+(p-&gt;GetUnitDef()-&gt;metalCost*45));
-						temp = temp - G-&gt;mrand()%max(int(temp/4),1);
-						if(temp &gt; best_score){
-							best_score = temp;
-							best = p-&gt;GetName();
-						}
 					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetGEO(){
-	NLOG(&quot;CUBuild::GetGEO&quot;);
+	string CUBuild::GetGEO(){
+		NLOG(&quot;CUBuild::GetGEO&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
 
-	if(di == 0) return string(&quot;&quot;);
+		if(di == 0) return string(&quot;&quot;);
 
-	list&lt;string&gt; possibles;
+		list&lt;string&gt; possibles;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-			if(p-&gt;GetUnitDef()-&gt;needGeo&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false)) possibles.push_back(p-&gt;GetName());
+				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+				if(p-&gt;GetUnitDef()-&gt;needGeo&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false)) possibles.push_back(p-&gt;GetName());
+			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		return possibles.front();
+		if(possibles.empty() == false){
+			return possibles.front();
+		}
+
+		return string(&quot;&quot;);
 	}
 
-	return string(&quot;&quot;);
-}
+	string CUBuild::GetSCOUT(){
+		NLOG(&quot;CUBuild::GetSCOUT&quot;);
 
-string CUBuild::GetSCOUT(){
-	NLOG(&quot;CUBuild::GetSCOUT&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
 
-	list&lt;string&gt; possibles;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-
-			//if(Useless(ud)) continue;
-			if((p-&gt;GetUnitDef()-&gt;speed &gt; G-&gt;info-&gt;scout_speed)&amp;&amp;(p-&gt;GetUnitDef()-&gt;movedata != 0)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canfly == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;transportCapacity == 0)&amp;&amp;(p-&gt;GetUnitDef()-&gt;isCommander == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false))  possibles.push_back(p-&gt;GetName());
-			if((p-&gt;GetUnitDef()-&gt;weapons.empty() == true)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canfly == true)&amp;&amp;(p-&gt;GetUnitDef()-&gt;transportCapacity == 0)&amp;&amp;(p-&gt;GetUnitDef()-&gt;isCommander == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false))  possibles.push_back(p-&gt;GetName());
-			if((p-&gt;GetUnitDef()-&gt;weapons.empty()==true)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canResurrect == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canCapture == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false)&amp;&amp; ((p-&gt;GetUnitDef()-&gt;canfly==true)||(p-&gt;GetUnitDef()-&gt;movedata != 0)) &amp;&amp;((p-&gt;GetUnitDef()-&gt;radarRadius &gt; 10)||(p-&gt;GetUnitDef()-&gt;sonarRadius &gt; 10)))  possibles.push_back(p-&gt;GetName());
+				//if(Useless(ud)) continue;
+				if((p-&gt;GetUnitDef()-&gt;speed &gt; G-&gt;info-&gt;scout_speed)&amp;&amp;(p-&gt;GetUnitDef()-&gt;movedata != 0)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canfly == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;transportCapacity == 0)&amp;&amp;(p-&gt;GetUnitDef()-&gt;isCommander == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false))  possibles.push_back(p-&gt;GetName());
+				if((p-&gt;GetUnitDef()-&gt;weapons.empty() == true)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canfly == true)&amp;&amp;(p-&gt;GetUnitDef()-&gt;transportCapacity == 0)&amp;&amp;(p-&gt;GetUnitDef()-&gt;isCommander == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false))  possibles.push_back(p-&gt;GetName());
+				if((p-&gt;GetUnitDef()-&gt;weapons.empty()==true)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canResurrect == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;canCapture == false)&amp;&amp;(p-&gt;GetUnitDef()-&gt;builder == false)&amp;&amp; ((p-&gt;GetUnitDef()-&gt;canfly==true)||(p-&gt;GetUnitDef()-&gt;movedata != 0)) &amp;&amp;((p-&gt;GetUnitDef()-&gt;radarRadius &gt; 10)||(p-&gt;GetUnitDef()-&gt;sonarRadius &gt; 10)))  possibles.push_back(p-&gt;GetName());
+			}
 		}
+		if(possibles.empty() == false) return possibles.front();
+		return string(&quot;&quot;);
 	}
-	if(possibles.empty() == false) return possibles.front();
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetRANDOM(){
-	NLOG(&quot;CUBuild::GetRANDOM&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	int randnum = 0;
+	string CUBuild::GetRANDOM(){
+		NLOG(&quot;CUBuild::GetRANDOM&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		int randnum = 0;
 
-	// for each possible build command the unit could do
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+		// for each possible build command the unit could do
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
 
-		if(is-&gt;id&lt;0){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			
-			// no mine fields
-			if(p-&gt;GetUnitDef()-&gt;canKamikaze &amp;&amp;((!p-&gt;GetUnitDef()-&gt;canfly)&amp;&amp;(p-&gt;GetUnitDef()-&gt;movedata == 0))){
-				// IT'S AN EXPLOSIVE MINE!!!!
-				// We dont want nonblocking mines built ontop of eachother next to the factory!!!!!!!!!!!
-				continue;
-			}
-			
-			// no radar towers!!!!
-			if((p-&gt;GetUnitDef() -&gt;radarRadius &gt; 10)&amp;&amp;((!p-&gt;GetUnitDef()-&gt;builder)||p-&gt;GetUnitDef()-&gt;isAirBase)){
-				continue;
-			}
-			
-			// no resource storage!!!!!!!!
-			if((p-&gt;GetUnitDef()-&gt;energyStorage &gt; 100)||(p-&gt;GetUnitDef()-&gt;metalStorage &gt; 100)){
-				continue;
-			}
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				
+				// no mine fields
+				if(p-&gt;GetUnitDef()-&gt;canKamikaze &amp;&amp;((!p-&gt;GetUnitDef()-&gt;canfly)&amp;&amp;(p-&gt;GetUnitDef()-&gt;movedata == 0))){
+					// IT'S AN EXPLOSIVE MINE!!!!
+					// We dont want nonblocking mines built ontop of eachother next to the factory!!!!!!!!!!!
+					continue;
+				}
+				
+				// no radar towers!!!!
+				if((p-&gt;GetUnitDef() -&gt;radarRadius &gt; 10)&amp;&amp;((!p-&gt;GetUnitDef()-&gt;builder)||p-&gt;GetUnitDef()-&gt;isAirBase)){
+					continue;
+				}
+				
+				// no resource storage!!!!!!!!
+				if((p-&gt;GetUnitDef()-&gt;energyStorage &gt; 100)||(p-&gt;GetUnitDef()-&gt;metalStorage &gt; 100)){
+					continue;
+				}
 
-			// no metal makers
-			if(p-&gt;GetUnitDef()-&gt;isMetalMaker){
-				continue;
-			}
-			
-			// remove 'useless' or 'irrelevant' items
-			if(Useless(p)){
-				continue;
-			}
-			
-			if((p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &lt; (G-&gt;cb-&gt;GetEnergy()+G-&gt;cb-&gt;GetMetal())*0.9)&amp;&amp;(((!p-&gt;GetUnitDef()-&gt;floater)&amp;&amp;(!water)&amp;&amp;(!G-&gt;info-&gt;spacemod))||(G-&gt;info-&gt;spacemod||water))){
+				// no metal makers
+				if(p-&gt;GetUnitDef()-&gt;isMetalMaker){
+					continue;
+				}
 				
-				// check the antistall algorithm if it's ok
-				if(!G-&gt;Pl-&gt;feasable(p,utd)){
+				// remove 'useless' or 'irrelevant' items
+				if(Useless(p)){
 					continue;
 				}
 				
-				possibles.push_back(p-&gt;GetName());
-				randnum++;
+				if((p-&gt;GetUnitDef()-&gt;metalCost+p-&gt;GetUnitDef()-&gt;energyCost &lt; (G-&gt;cb-&gt;GetEnergy()+G-&gt;cb-&gt;GetMetal())*0.9)&amp;&amp;(((!p-&gt;GetUnitDef()-&gt;floater)&amp;&amp;(!water)&amp;&amp;(!G-&gt;info-&gt;spacemod))||(G-&gt;info-&gt;spacemod||water))){
+					
+					// check the antistall algorithm if it's ok
+					if(!G-&gt;Pl-&gt;feasable(p,utd)){
+						continue;
+					}
+					
+					possibles.push_back(p-&gt;GetName());
+					randnum++;
+				}
 			}
 		}
-	}
 
-	// if potential items where found
-	if(!possibles.empty()){
+		// if potential items where found
+		if(!possibles.empty()){
 
-		// randomly pick one of the
-		randnum = G-&gt;mrand()%randnum;
+			// randomly pick one of the
+			randnum = G-&gt;mrand()%randnum;
 
-		// remove entries from the beginning of the list of potential items
-		// so that the randnum'th entry is at the begining of the list
-		while(randnum &gt; 0){
-			possibles.pop_front();
+			// remove entries from the beginning of the list of potential items
+			// so that the randnum'th entry is at the begining of the list
+			while(randnum &gt; 0){
+				possibles.pop_front();
+			}
+			
+			// now that we've removed all those entries our random selection
+			// is at the front of the list, so lets return it
+			return possibles.front();
 		}
-		
-		// now that we've removed all those entries our random selection
-		// is at the front of the list, so lets return it
-		return possibles.front();
+
+		return string(&quot;&quot;);
 	}
 
-	return string(&quot;&quot;);
-}
+	string CUBuild::GetDEFENCE(){
+		NLOG(&quot;CUBuild::GetDEFENCE&quot;);
 
-string CUBuild::GetDEFENCE(){
-	NLOG(&quot;CUBuild::GetDEFENCE&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
 
-	list&lt;string&gt; possibles;
+		int defnum = 0;
 
-	int defnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-		if(is-&gt;id&lt;0){
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				if(Useless(p)) continue;
 
-			if(Useless(p)) continue;
-
-			if((p-&gt;GetUnitDef()-&gt;weapons.empty() == false)&amp;&amp;(!p-&gt;GetUnitDef()-&gt;isFeature)&amp;&amp;(!p-&gt;IsMobile())){
-				if((G-&gt;info-&gt;spacemod == true)||(water == true)){
-					if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-					possibles.push_back(p-&gt;GetName());
-					defnum++;
-				} else if (pd-&gt;floater == false){
-					if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-					possibles.push_back(p-&gt;GetName());
-					defnum++;
+				if((p-&gt;GetUnitDef()-&gt;weapons.empty() == false)&amp;&amp;(!p-&gt;GetUnitDef()-&gt;isFeature)&amp;&amp;(!p-&gt;IsMobile())){
+					if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+						if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+						possibles.push_back(p-&gt;GetName());
+						defnum++;
+					} else if (pd-&gt;floater == false){
+						if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+						possibles.push_back(p-&gt;GetName());
+						defnum++;
+					}
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		defnum = G-&gt;mrand()%defnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == defnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			defnum = G-&gt;mrand()%defnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == defnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		
+		return string(&quot;&quot;);
 	}
-	
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetRADAR(){
-	NLOG(&quot;CUBuild::GetRADAR&quot;);
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
+	string CUBuild::GetRADAR(){
+		NLOG(&quot;CUBuild::GetRADAR&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
 
-	int randnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(pd == 0) continue;
-			if(Useless(p)) continue;
-			if((pd-&gt;radarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)){
-				possibles.push_back(pd-&gt;name);
-				randnum++;
-			}else if((pd-&gt;radarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
-				possibles.push_back(pd-&gt;name);
-				randnum++;
+				if(pd == 0) continue;
+				if(Useless(p)) continue;
+				if((pd-&gt;radarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)){
+					possibles.push_back(pd-&gt;name);
+					randnum++;
+				}else if((pd-&gt;radarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
+					possibles.push_back(pd-&gt;name);
+					randnum++;
+				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetESTORE(){
-	NLOG(&quot;CUBuild::GetESTORE&quot;);
-	list&lt;string&gt; possibles;
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
+	string CUBuild::GetESTORE(){
+		NLOG(&quot;CUBuild::GetESTORE&quot;);
+		list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	int randnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(pd-&gt;energyStorage &gt;100){
-				if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
-				if(pd-&gt;floater == true){
-					if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+				if(pd-&gt;energyStorage &gt;100){
+					if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+					if(pd-&gt;floater == true){
+						if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+						}
+					} else{
 						possibles.push_back(pd-&gt;name);
 						randnum++;
 					}
-				} else{
-					possibles.push_back(pd-&gt;name);
-					randnum++;
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+
+		return string(&quot;&quot;);
 	}
 
-	return string(&quot;&quot;);
-}
+	string CUBuild::GetMSTORE(){
+		NLOG(&quot;CUBuild::GetMSTORE&quot;);
+		list&lt;string&gt; possibles;
 
-string CUBuild::GetMSTORE(){
-	NLOG(&quot;CUBuild::GetMSTORE&quot;);
-	list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	if(di == 0) return string(&quot;&quot;);
+		int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-	int randnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				if(pd-&gt;metalStorage &gt;100){
 
-			if(pd-&gt;metalStorage &gt;100){
+					if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
 
-				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-
-				if(pd-&gt;floater){
-					if(G-&gt;info-&gt;spacemod||water){
+					if(pd-&gt;floater){
+						if(G-&gt;info-&gt;spacemod||water){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+						}
+					} else {
 						possibles.push_back(pd-&gt;name);
 						randnum++;
 					}
-				} else {
-					possibles.push_back(pd-&gt;name);
-					randnum++;
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+
+		return string(&quot;&quot;);
 	}
 
-	return string(&quot;&quot;);
-}
+	string CUBuild::GetSILO(){
+		NLOG(&quot;CUBuild::GetSILO&quot;);
 
-string CUBuild::GetSILO(){
-	NLOG(&quot;CUBuild::GetSILO&quot;);
+		list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		int randnum = 0;
 
-	list&lt;string&gt; possibles;
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
-
-			if(pd-&gt;weapons.empty() != true){
-				for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = pd-&gt;weapons.begin(); i != pd-&gt;weapons.end(); ++i){
-					if((i-&gt;def-&gt;stockpile == true)&amp;&amp;(i-&gt;def-&gt;targetable &gt; 0)){
-						if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
-						possibles.push_back(pd-&gt;name);
-						randnum++;
-						break;
+				if(pd-&gt;weapons.empty() != true){
+					for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = pd-&gt;weapons.begin(); i != pd-&gt;weapons.end(); ++i){
+						if((i-&gt;def-&gt;stockpile == true)&amp;&amp;(i-&gt;def-&gt;targetable &gt; 0)){
+							if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+							break;
+						}
 					}
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetJAMMER(){
-	NLOG(&quot;CUBuild::GetJAMMER&quot;);
+	string CUBuild::GetJAMMER(){
+		NLOG(&quot;CUBuild::GetJAMMER&quot;);
 
-	list&lt;string&gt; possibles;
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	int randnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+		int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if((pd-&gt;jammerRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)){
-				possibles.push_back(pd-&gt;name);
-				randnum++;
-			}else if((pd-&gt;jammerRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
-				possibles.push_back(pd-&gt;name);
-				randnum++;
+				if((pd-&gt;jammerRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)){
+					possibles.push_back(pd-&gt;name);
+					randnum++;
+				}else if((pd-&gt;jammerRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
+					possibles.push_back(pd-&gt;name);
+					randnum++;
+				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetSONAR(){
-	NLOG(&quot;CUBuild::GetSONAR&quot;);
+	string CUBuild::GetSONAR(){
+		NLOG(&quot;CUBuild::GetSONAR&quot;);
 
-	list&lt;string&gt; possibles;
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	int randnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if((pd-&gt;sonarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)){
-				possibles.push_back(pd-&gt;name);
-				randnum++;
-			}else if((pd-&gt;sonarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
-				possibles.push_back(pd-&gt;name);
-				randnum++;
+				if((pd-&gt;sonarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)){
+					possibles.push_back(pd-&gt;name);
+					randnum++;
+				}else if((pd-&gt;sonarRadius &gt;10)&amp;&amp;(pd-&gt;floater == false)&amp;&amp;(pd-&gt;builder == false)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
+					possibles.push_back(pd-&gt;name);
+					randnum++;
+				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetANTIMISSILE(){
-	NLOG(&quot;CUBuild::GetANTIMISSILE&quot;);
+	string CUBuild::GetANTIMISSILE(){
+		NLOG(&quot;CUBuild::GetANTIMISSILE&quot;);
 
-	list&lt;string&gt; possibles;
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	int randnum = 0;
+		list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		int randnum = 0;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(pd-&gt;weapons.empty() != true){
-				if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
-				for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = pd-&gt;weapons.begin(); i != pd-&gt;weapons.end(); ++i){
-					//
-					if(i-&gt;def-&gt;interceptor == 1){
-						possibles.push_back(pd-&gt;name);
-						randnum++;
-						break;
+				if(pd-&gt;weapons.empty() != true){
+					if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+					for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = pd-&gt;weapons.begin(); i != pd-&gt;weapons.end(); ++i){
+						//
+						if(i-&gt;def-&gt;interceptor == 1){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+							break;
+						}
 					}
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetARTILLERY(){
-	NLOG(&quot;CUBuild::GetARTILLERY&quot;);
-	return string(&quot;&quot;);
-	//list&lt;string&gt; possibles;
-	//const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	//if(di == 0) return string(&quot;&quot;);
-}
+	string CUBuild::GetARTILLERY(){
+		NLOG(&quot;CUBuild::GetARTILLERY&quot;);
+		return string(&quot;&quot;);
+		//list&lt;string&gt; possibles;
+		//const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		//if(di == 0) return string(&quot;&quot;);
+	}
 
-string CUBuild::GetTARG(){
-	NLOG(&quot;CUBuild::GetTARG&quot;);
-	list&lt;string&gt; possibles;
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	int randnum = 0;
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
-			
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+	string CUBuild::GetTARG(){
+		NLOG(&quot;CUBuild::GetTARG&quot;);
+		list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		int randnum = 0;
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
+				
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(pd-&gt;targfac == true){
-				if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
-				if(pd-&gt;floater == true){
-					if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+				if(pd-&gt;targfac == true){
+					if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+					if(pd-&gt;floater == true){
+						if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+						}
+					} else{
 						possibles.push_back(pd-&gt;name);
 						randnum++;
 					}
-				} else{
-					possibles.push_back(pd-&gt;name);
-					randnum++;
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetFOCAL_MINE(){
-	NLOG(&quot;CUBuild::GetFOCAL_MINE&quot;);
+	string CUBuild::GetFOCAL_MINE(){
+		NLOG(&quot;CUBuild::GetFOCAL_MINE&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	list&lt;string&gt; possibles;
-	int randnum = 0;
+		list&lt;string&gt; possibles;
+		int randnum = 0;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(pd-&gt;canKamikaze&amp;&amp;((pd-&gt;canfly == false)&amp;&amp;(pd-&gt;movedata == 0))){
+				if(pd-&gt;canKamikaze&amp;&amp;((pd-&gt;canfly == false)&amp;&amp;(pd-&gt;movedata == 0))){
 
-				if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+					if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
 
-				if(pd-&gt;floater){
-					if(G-&gt;info-&gt;spacemod||water){
+					if(pd-&gt;floater){
+						if(G-&gt;info-&gt;spacemod||water){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+						}
+					} else{
 						possibles.push_back(pd-&gt;name);
 						randnum++;
 					}
-				} else{
-					possibles.push_back(pd-&gt;name);
-					randnum++;
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetSUB(){
-	NLOG(&quot;CUBuild::GetSUB&quot;);
-	return string(&quot;&quot;);
-// 	water=true;
-// 	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-// 	if(di == 0) return string(&quot;&quot;);
-// 	list&lt;string&gt; possibles;
+	string CUBuild::GetSUB(){
+		NLOG(&quot;CUBuild::GetSUB&quot;);
+		return string(&quot;&quot;);
+	// 	water=true;
+	// 	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+	// 	if(di == 0) return string(&quot;&quot;);
+	// 	list&lt;string&gt; possibles;
 
-}
+	}
 
-string CUBuild::GetAMPHIB(){
-	NLOG(&quot;CUBuild::GetAMPHIB&quot;);
+	string CUBuild::GetAMPHIB(){
+		NLOG(&quot;CUBuild::GetAMPHIB&quot;);
 
-	return string(&quot;&quot;);
-// 	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-// 	if(di == 0) return string(&quot;&quot;);
-// 	list&lt;string&gt; possibles;
+		return string(&quot;&quot;);
+	// 	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+	// 	if(di == 0) return string(&quot;&quot;);
+	// 	list&lt;string&gt; possibles;
 
-}
+	}
 
-string CUBuild::GetMINE(){
-	NLOG(&quot;CUBuild::GetMINE&quot;);
+	string CUBuild::GetMINE(){
+		NLOG(&quot;CUBuild::GetMINE&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	int randnum = 0;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		int randnum = 0;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
 
-			if((pd-&gt;canKamikaze)&amp;&amp;((pd-&gt;canfly == false)&amp;&amp;(pd-&gt;movedata == 0))){
-				if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
-				if(pd-&gt;floater == true){
-					if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+				if((pd-&gt;canKamikaze)&amp;&amp;((pd-&gt;canfly == false)&amp;&amp;(pd-&gt;movedata == 0))){
+					if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+					if(pd-&gt;floater == true){
+						if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+						}
+					} else{
 						possibles.push_back(pd-&gt;name);
 						randnum++;
 					}
-				} else{
-					possibles.push_back(pd-&gt;name);
-					randnum++;
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetCARRIER(){
-	NLOG(&quot;CUBuild::GetCARRIER&quot;);
+	string CUBuild::GetCARRIER(){
+		NLOG(&quot;CUBuild::GetCARRIER&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	int randnum = 0;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		int randnum = 0;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(pd-&gt;isAirBase == true){
-				if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
-				if(pd-&gt;floater == true){
-					if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+				if(pd-&gt;isAirBase == true){
+					if(G-&gt;Pl-&gt;feasable(pd-&gt;name,uid)==false) continue;
+					if(pd-&gt;floater == true){
+						if((G-&gt;info-&gt;spacemod == true)||(water == true)){
+							possibles.push_back(pd-&gt;name);
+							randnum++;
+						}
+					} else{
 						possibles.push_back(pd-&gt;name);
 						randnum++;
 					}
-				} else{
-					possibles.push_back(pd-&gt;name);
-					randnum++;
 				}
 			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		randnum = G-&gt;mrand()%randnum;
-		int j = 0;
+		if(possibles.empty() == false){
+			randnum = G-&gt;mrand()%randnum;
+			int j = 0;
 
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetMETAL_MAKER(){
-	NLOG(&quot;CUBuild::GetMETAL_MAKER&quot;);
+	string CUBuild::GetMETAL_MAKER(){
+		NLOG(&quot;CUBuild::GetMETAL_MAKER&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if((pd-&gt;isMetalMaker == true)&amp;&amp;(pd-&gt;floater == false)){
-				possibles.push_back(pd-&gt;name);
+				if((pd-&gt;isMetalMaker == true)&amp;&amp;(pd-&gt;floater == false)){
+					possibles.push_back(pd-&gt;name);
+				}
+				if((pd-&gt;isMetalMaker == true)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
+					possibles.push_back(pd-&gt;name);
+				}
 			}
-			if((pd-&gt;isMetalMaker == true)&amp;&amp;(pd-&gt;floater == true)&amp;&amp;((G-&gt;info-&gt;spacemod == true)||(water == true))){
-				possibles.push_back(pd-&gt;name);
-			}
 		}
-	}
 
-	if(possibles.empty() == false){
-		int randnum = G-&gt;mrand()%possibles.size();
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(0 == randnum){
-				return *k;
-			}else{
-				randnum--;
+		if(possibles.empty() == false){
+			int randnum = G-&gt;mrand()%possibles.size();
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(0 == randnum){
+					return *k;
+				}else{
+					randnum--;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetFORTIFICATION(){
-	NLOG(&quot;CUBuild::GetFORTIFICATION&quot;);
+	string CUBuild::GetFORTIFICATION(){
+		NLOG(&quot;CUBuild::GetFORTIFICATION&quot;);
 
-	if(G-&gt;DTHandler-&gt;DTNeeded() == false) return string(&quot;&quot;);
+		if(G-&gt;DTHandler-&gt;DTNeeded() == false) return string(&quot;&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
 
-	list&lt;string&gt; possibles;
+		list&lt;string&gt; possibles;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(G-&gt;DTHandler-&gt;IsDragonsTeeth(pd)){
-				possibles.push_back(pd-&gt;name);
+				if(G-&gt;DTHandler-&gt;IsDragonsTeeth(pd)){
+					possibles.push_back(pd-&gt;name);
+				}
+
 			}
-
 		}
-	}
 
-	if(possibles.empty() == false){
-		int randnum = G-&gt;mrand()%possibles.size();
-		int j = 0;
-		for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
-			if(j == randnum){
-				return *k;
-			}else{
-				j++;
+		if(possibles.empty() == false){
+			int randnum = G-&gt;mrand()%possibles.size();
+			int j = 0;
+			for(list&lt;string&gt;::iterator k = possibles.begin(); k != possibles.end(); ++k){
+				if(j == randnum){
+					return *k;
+				}else{
+					j++;
+				}
 			}
+			return possibles.front();
 		}
-		return possibles.front();
+		return string(&quot;&quot;);
 	}
-	return string(&quot;&quot;);
-}
 
-string CUBuild::GetHUB(){
-	NLOG(&quot;CUBuild::GetHUB&quot;);
+	string CUBuild::GetHUB(){
+		NLOG(&quot;CUBuild::GetHUB&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
 
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(p-&gt;IsHub()==true){
-				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-				if(p-&gt;IsUWStructure()!=(water||G-&gt;info-&gt;spacemod)) continue;
-				float temp = G-&gt;GetEfficiency(pd-&gt;name);
-				temp /= (pd-&gt;energyCost+(pd-&gt;metalCost*45));
-				int r = G-&gt;mrand()%max(int(temp/4),1)+1;
-				temp += (float)abs(r);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(p-&gt;IsHub()==true){
+					if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+					if(p-&gt;IsUWStructure()!=(water||G-&gt;info-&gt;spacemod)) continue;
+					float temp = G-&gt;GetEfficiency(pd-&gt;name);
+					temp /= (pd-&gt;energyCost+(pd-&gt;metalCost*45));
+					int r = G-&gt;mrand()%max(int(temp/4),1)+1;
+					temp += (float)abs(r);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
-}
 
-string CUBuild::GetAIRSUPPORT(){
-	NLOG(&quot;CUBuild::GetAIRSUPPORT&quot;);
+	string CUBuild::GetAIRSUPPORT(){
+		NLOG(&quot;CUBuild::GetAIRSUPPORT&quot;);
 
-	const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
-	if(di == 0) return string(&quot;&quot;);
-	list&lt;string&gt; possibles;
-	float best_score = 0;
-	string best = &quot;&quot;;
+		const vector&lt;CommandDescription&gt;* di = G-&gt;cb-&gt;GetUnitCommands(uid);
+		if(di == 0) return string(&quot;&quot;);
+		list&lt;string&gt; possibles;
+		float best_score = 0;
+		string best = &quot;&quot;;
 
-	for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
-		if(is-&gt;id&lt;0){
+		for(vector&lt;CommandDescription&gt;::const_iterator is = di-&gt;begin(); is != di-&gt;end();++is){
+			if(is-&gt;id&lt;0){
 
-			// retrieve the unit type information
-			CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
-			const UnitDef* pd = p-&gt;GetUnitDef();
+				// retrieve the unit type information
+				CUnitTypeData* p =G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(is-&gt;name);
+				const UnitDef* pd = p-&gt;GetUnitDef();
 
-			if(p-&gt;IsHub()){
-				if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
-				if(p-&gt;IsUWStructure()!=(water||G-&gt;info-&gt;spacemod)) continue;
-				float temp = G-&gt;GetEfficiency(pd-&gt;name);
-				temp /= (pd-&gt;energyCost+(pd-&gt;metalCost*45));
-				int r = G-&gt;mrand()%max(int(temp/4),1)+1;
-				temp += (float)abs(r);
-				if(temp &gt; best_score){
-					best_score = temp;
-					best = p-&gt;GetName();
+				if(p-&gt;IsHub()){
+					if(G-&gt;Pl-&gt;feasable(p,utd)==false) continue;
+					if(p-&gt;IsUWStructure()!=(water||G-&gt;info-&gt;spacemod)) continue;
+					float temp = G-&gt;GetEfficiency(pd-&gt;name);
+					temp /= (pd-&gt;energyCost+(pd-&gt;metalCost*45));
+					int r = G-&gt;mrand()%max(int(temp/4),1)+1;
+					temp += (float)abs(r);
+					if(temp &gt; best_score){
+						best_score = temp;
+						best = p-&gt;GetName();
+					}
 				}
 			}
 		}
+		return best;
 	}
-	return best;
+
 }
-

Modified: trunk/AI/Global/NTai/AI/NTai/Tasks/CConsoleTask.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Tasks/CConsoleTask.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Tasks/CConsoleTask.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,26 +1,29 @@
 #include &quot;../Core/include.h&quot;
 
-CConsoleTask::CConsoleTask(Global* GL){
-	//
-	valid = false;
-}
+namespace ntai {
+	CConsoleTask::CConsoleTask(Global* GL){
+		//
+		valid = false;
+	}
 
-CConsoleTask::CConsoleTask(Global* GL, string message){
-	valid=true;
-	G = GL;
-	mymessage=message;
-}
+	CConsoleTask::CConsoleTask(Global* GL, string message){
+		valid=true;
+		G = GL;
+		mymessage=message;
+	}
 
-void CConsoleTask::RecieveMessage(CMessage &amp;message){
-}
+	void CConsoleTask::RecieveMessage(CMessage &amp;message){
+	}
 
-bool CConsoleTask::Init(){
-	
-	if(!valid){
-		return false;
+	bool CConsoleTask::Init(){
+		
+		if(!valid){
+			return false;
+		}
+
+		G-&gt;L.iprint(mymessage);
+		End();
+		return true;
 	}
 
-	G-&gt;L.iprint(mymessage);
-	End();
-	return true;
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Tasks/CKeywordConstructionTask.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Tasks/CKeywordConstructionTask.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Tasks/CKeywordConstructionTask.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,521 +1,523 @@
 #include &quot;../Core/include.h&quot;
 
+namespace ntai {
 
-CKeywordConstructionTask::CKeywordConstructionTask(Global* GL, int unit, btype type){
-	valid=true;
-	G = GL;
-	this-&gt;unit=unit;
-	this-&gt;type = type;
-	this-&gt;utd = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
-	if(utd == 0){
-		valid = false;
+	CKeywordConstructionTask::CKeywordConstructionTask(Global* GL, int unit, btype type){
+		valid=true;
+		G = GL;
+		this-&gt;unit=unit;
+		this-&gt;type = type;
+		this-&gt;utd = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
+		if(utd == 0){
+			valid = false;
+		}
 	}
-}
 
-void CKeywordConstructionTask::RecieveMessage(CMessage &amp;message){
-	NLOG(&quot;CKeywordConstructionTask::RecieveMessage&quot;);
-	if (!valid) return;
+	void CKeywordConstructionTask::RecieveMessage(CMessage &amp;message){
+		NLOG(&quot;CKeywordConstructionTask::RecieveMessage&quot;);
+		if (!valid) return;
 
-	if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0) == unit){
-			if((type == B_GUARDIAN)
-				||(type == B_GUARDIAN_MOBILES)
-				||(type == B_RULE_EXTREME_CARRY)){
-					Init();
-			}else{
+		if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0) == unit){
+				if((type == B_GUARDIAN)
+					||(type == B_GUARDIAN_MOBILES)
+					||(type == B_RULE_EXTREME_CARRY)){
+						Init();
+				}else{
+					End();
+					return;
+				}
+			}
+		}else if(message.GetType() == string(&quot;type?&quot;)){
+			message.SetType(&quot; keywordtask: &quot;+G-&gt;Manufacturer-&gt;GetTaskName(this-&gt;type));
+		}else	if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0) == unit){
 				End();
 				return;
 			}
-		}
-	}else if(message.GetType() == string(&quot;type?&quot;)){
-		message.SetType(&quot; keywordtask: &quot;+G-&gt;Manufacturer-&gt;GetTaskName(this-&gt;type));
-	}else	if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0) == unit){
-			End();
-			return;
-		}
-	}else	if(message.GetType() == string(&quot;buildposition&quot;)){
-		// continue construction
-		//
+		}else	if(message.GetType() == string(&quot;buildposition&quot;)){
+			// continue construction
+			//
 
-		TCommand tc(unit,&quot;CBuild&quot;);
-		tc.ID(-building-&gt;GetUnitDef()-&gt;id);
-		float3 pos = message.GetFloat3();
+			TCommand tc(unit,&quot;CBuild&quot;);
+			tc.ID(-building-&gt;GetUnitDef()-&gt;id);
+			float3 pos = message.GetFloat3();
 
-		if(building-&gt;IsMobile()==false){
-			if(pos==UpVector){
-				G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage BuildPlacement returned UpVector or some other nasty position&quot;);
-				End();
-				return;
-			}else if (G-&gt;cb-&gt;CanBuildAt(building-&gt;GetUnitDef(),pos,0)==false){
-				G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage BuildPlacement returned a position that cant eb built upon&quot;);
-				End();
-				return;
+			if(building-&gt;IsMobile()==false){
+				if(pos==UpVector){
+					G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage BuildPlacement returned UpVector or some other nasty position&quot;);
+					End();
+					return;
+				}else if (G-&gt;cb-&gt;CanBuildAt(building-&gt;GetUnitDef(),pos,0)==false){
+					G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage BuildPlacement returned a position that cant eb built upon&quot;);
+					End();
+					return;
+				}
 			}
-		}
 
-		pos.y = G-&gt;cb-&gt;GetElevation(pos.x,pos.z);
+			pos.y = G-&gt;cb-&gt;GetElevation(pos.x,pos.z);
 
-		deque&lt;CBPlan* &gt;::iterator qi = G-&gt;Manufacturer-&gt;OverlappingPlans(pos,building-&gt;GetUnitDef());
-		if(qi != G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
-			NLOG(&quot;vector&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud); :: WipePlansForBuilder&quot;);
-			/*if(qi-&gt;started){
-			G-&gt;L.print(&quot;::Cbuild overlapping plans issuing repair instead&quot;);
-			if(G-&gt;Actions-&gt;Repair(unit,qi-&gt;subject)){
-			WipePlansForBuilder(unit);
-			qi-&gt;builders.insert(unit);
-			return false;
+			deque&lt;CBPlan* &gt;::iterator qi = G-&gt;Manufacturer-&gt;OverlappingPlans(pos,building-&gt;GetUnitDef());
+			if(qi != G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
+				NLOG(&quot;vector&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud); :: WipePlansForBuilder&quot;);
+				/*if(qi-&gt;started){
+				G-&gt;L.print(&quot;::Cbuild overlapping plans issuing repair instead&quot;);
+				if(G-&gt;Actions-&gt;Repair(unit,qi-&gt;subject)){
+				WipePlansForBuilder(unit);
+				qi-&gt;builders.insert(unit);
+				return false;
+				}
+				}else*/ if ((*qi)-&gt;utd == building){
+				G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage overlapping plans that're the same item but not started, moving pos to make it build quicker&quot;);
+				pos = (*qi)-&gt;pos;
+				}
 			}
-			}else*/ if ((*qi)-&gt;utd == building){
-			G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage overlapping plans that're the same item but not started, moving pos to make it build quicker&quot;);
-			pos = (*qi)-&gt;pos;
-			}
-		}
 
-		tc.PushFloat3(pos);
-		tc.Push(0);
-		tc.c.timeOut = int(building-&gt;GetUnitDef()-&gt;buildTime/5) + G-&gt;cb-&gt;GetCurrentFrame();
-		tc.created = G-&gt;cb-&gt;GetCurrentFrame();
-		tc.delay=0;
+			tc.PushFloat3(pos);
+			tc.Push(0);
+			tc.c.timeOut = int(building-&gt;GetUnitDef()-&gt;buildTime/5) + G-&gt;cb-&gt;GetCurrentFrame();
+			tc.created = G-&gt;cb-&gt;GetCurrentFrame();
+			tc.delay=0;
 
-		if(!G-&gt;OrderRouter-&gt;GiveOrder(tc)){
-			G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage Failed Order G-&gt;OrderRouter-&gt;GiveOrder(tc)== false:: &quot; + building-&gt;GetUnitDef()-&gt;name);
-			End();
-			return;
+			if(!G-&gt;OrderRouter-&gt;GiveOrder(tc)){
+				G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage Failed Order G-&gt;OrderRouter-&gt;GiveOrder(tc)== false:: &quot; + building-&gt;GetUnitDef()-&gt;name);
+				End();
+				return;
 
-		}else{
-			// create a plan
-			G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage G-&gt;OrderRouter-&gt;GiveOrder(tc)== true :: &quot; + building-&gt;GetUnitDef()-&gt;name);
+			}else{
+				// create a plan
+				G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage G-&gt;OrderRouter-&gt;GiveOrder(tc)== true :: &quot; + building-&gt;GetUnitDef()-&gt;name);
 
-			if(qi == G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
-				NLOG(&quot;CKeywordConstructionTask::RecieveMessage :: WipePlansForBuilder&quot;);
-				G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage wiping and creaiing the plan :: &quot; + building-&gt;GetUnitDef()-&gt;name);
+				if(qi == G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
+					NLOG(&quot;CKeywordConstructionTask::RecieveMessage :: WipePlansForBuilder&quot;);
+					G-&gt;L.print(&quot;CKeywordConstructionTask::RecieveMessage wiping and creaiing the plan :: &quot; + building-&gt;GetUnitDef()-&gt;name);
 
 
-				CBPlan* Bplan = new CBPlan();
-				Bplan-&gt;started = false;
-				Bplan-&gt;AddBuilder(unit);
-				Bplan-&gt;subject = -1;
-				Bplan-&gt;pos = pos;
-				Bplan-&gt;utd=building;
-				G-&gt;Manufacturer-&gt;AddPlan();
-				Bplan-&gt;id = G-&gt;Manufacturer-&gt;getplans();
-				Bplan-&gt;radius = (float)max(building-&gt;GetUnitDef()-&gt;xsize,building-&gt;GetUnitDef()-&gt;ysize)*8.0f;
-				Bplan-&gt;inFactory = building-&gt;IsFactory();
+					CBPlan* Bplan = new CBPlan();
+					Bplan-&gt;started = false;
+					Bplan-&gt;AddBuilder(unit);
+					Bplan-&gt;subject = -1;
+					Bplan-&gt;pos = pos;
+					Bplan-&gt;utd=building;
+					G-&gt;Manufacturer-&gt;AddPlan();
+					Bplan-&gt;id = G-&gt;Manufacturer-&gt;getplans();
+					Bplan-&gt;radius = (float)max(building-&gt;GetUnitDef()-&gt;xsize,building-&gt;GetUnitDef()-&gt;ysize)*8.0f;
+					Bplan-&gt;inFactory = building-&gt;IsFactory();
 
-				G-&gt;Manufacturer-&gt;BPlans-&gt;push_back(Bplan);
-				G-&gt;BuildingPlacer-&gt;Block(pos,building);
+					G-&gt;Manufacturer-&gt;BPlans-&gt;push_back(Bplan);
+					G-&gt;BuildingPlacer-&gt;Block(pos,building);
 
-				//G-&gt;BuildingPlacer-&gt;UnBlock(G-&gt;GetUnitPos(uid),ud);
-				//builders[unit].curplan = plancounter;
-				//builders[unit].doingplan = true;
+					//G-&gt;BuildingPlacer-&gt;UnBlock(G-&gt;GetUnitPos(uid),ud);
+					//builders[unit].curplan = plancounter;
+					//builders[unit].doingplan = true;
+				}
+				return;
 			}
-			return;
 		}
 	}
-}
 
-void CKeywordConstructionTask::Build(){
-	G-&gt;L.print(&quot;CKeywordConstructionTask::Build() :: &quot; + building-&gt;GetUnitDef()-&gt;name);
+	void CKeywordConstructionTask::Build(){
+		G-&gt;L.print(&quot;CKeywordConstructionTask::Build() :: &quot; + building-&gt;GetUnitDef()-&gt;name);
 
 
-	if(G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false){ // Sort out the stuff that's setup to ALWAYS be under the antistall algorithm
-		NLOG(&quot;CKeywordConstructionTask::Build G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false&quot;);
-		for(vector&lt;string&gt;::iterator i = G-&gt;Pl-&gt;AlwaysAntiStall.begin(); i != G-&gt;Pl-&gt;AlwaysAntiStall.end(); ++i){
-			if(*i == building-&gt;GetName()){
-				NLOG(&quot;CKeywordConstructionTask::Build *i == name :: &quot;+building-&gt;GetUnitDef()-&gt;name);
-				if(!G-&gt;Pl-&gt;feasable(building,utd)){
-					G-&gt;L.print(&quot;unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
-					End();
-					return;
-				}else{
-					NLOG(&quot;CKeywordConstructionTask::Build  &quot;+building-&gt;GetUnitDef()-&gt;name+&quot; is feasable&quot;);
-					break;
+		if(G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false){ // Sort out the stuff that's setup to ALWAYS be under the antistall algorithm
+			NLOG(&quot;CKeywordConstructionTask::Build G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false&quot;);
+			for(vector&lt;string&gt;::iterator i = G-&gt;Pl-&gt;AlwaysAntiStall.begin(); i != G-&gt;Pl-&gt;AlwaysAntiStall.end(); ++i){
+				if(*i == building-&gt;GetName()){
+					NLOG(&quot;CKeywordConstructionTask::Build *i == name :: &quot;+building-&gt;GetUnitDef()-&gt;name);
+					if(!G-&gt;Pl-&gt;feasable(building,utd)){
+						G-&gt;L.print(&quot;unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
+						End();
+						return;
+					}else{
+						NLOG(&quot;CKeywordConstructionTask::Build  &quot;+building-&gt;GetUnitDef()-&gt;name+&quot; is feasable&quot;);
+						break;
+					}
 				}
 			}
 		}
-	}
 
 
-	NLOG(&quot;CKeywordConstructionTask::Build  Resource\\MaxEnergy\\&quot;);
-	float emax=1000000000;
+		NLOG(&quot;CKeywordConstructionTask::Build  Resource\\MaxEnergy\\&quot;);
+		float emax=1000000000;
 
-	string key = &quot;Resource\\MaxEnergy\\&quot;;
-	key += building-&gt;GetName();
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default/**/
+		string key = &quot;Resource\\MaxEnergy\\&quot;;
+		key += building-&gt;GetName();
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default/**/
 
-	if(emax ==0){
-		emax = 30000000;
-	}
+		if(emax ==0){
+			emax = 30000000;
+		}
 
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
-		G-&gt;L.print(&quot;CKeywordConstructionTask::Build  emax &quot; + building-&gt;GetUnitDef()-&gt;name);
-		End();
-		return;
-	}
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
+			G-&gt;L.print(&quot;CKeywordConstructionTask::Build  emax &quot; + building-&gt;GetUnitDef()-&gt;name);
+			End();
+			return;
+		}
 
-	NLOG(&quot;CKeywordConstructionTask::Build  Resource\\MinEnergy\\&quot;);
-	float emin=0;
+		NLOG(&quot;CKeywordConstructionTask::Build  Resource\\MinEnergy\\&quot;);
+		float emin=0;
 
-	key = &quot;Resource\\MinEnergy\\&quot;;
-	key += building-&gt;GetName();
+		key = &quot;Resource\\MinEnergy\\&quot;;
+		key += building-&gt;GetName();
 
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default/**/
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default/**/
 
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
-		G-&gt;L.print(&quot;CKeywordConstructionTask::Build  emin &quot; + building-&gt;GetUnitDef()-&gt;name);
-		End();
-		return;
-	}
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
+			G-&gt;L.print(&quot;CKeywordConstructionTask::Build  emin &quot; + building-&gt;GetUnitDef()-&gt;name);
+			End();
+			return;
+		}
 
 
-	// Now sort out stuff that can only be built one at a time
+		// Now sort out stuff that can only be built one at a time
 
-	if(building-&gt;GetSoloBuildActive()){
-		NLOG(&quot;CKeywordConstructionTask::Build  G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()&quot;);
-		End();
-		return;
-	}
+		if(building-&gt;GetSoloBuildActive()){
+			NLOG(&quot;CKeywordConstructionTask::Build  G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()&quot;);
+			End();
+			return;
+		}
 
-	// Now sort out if it's one of those things that can only be built once
-	if(building-&gt;GetSingleBuildActive()){
-		G-&gt;L.print(&quot;CKeywordConstructionTask::Build  singlebuild &quot; + building-&gt;GetUnitDef()-&gt;name);
-		End();
-		return;
-	}
+		// Now sort out if it's one of those things that can only be built once
+		if(building-&gt;GetSingleBuildActive()){
+			G-&gt;L.print(&quot;CKeywordConstructionTask::Build  singlebuild &quot; + building-&gt;GetUnitDef()-&gt;name);
+			End();
+			return;
+		}
 
-	if(G-&gt;info-&gt;antistall&gt;1){
-		NLOG(&quot;CKeywordConstructionTask::Build  G-&gt;info-&gt;antistall&gt;1&quot;);
+		if(G-&gt;info-&gt;antistall&gt;1){
+			NLOG(&quot;CKeywordConstructionTask::Build  G-&gt;info-&gt;antistall&gt;1&quot;);
 
-		bool fk = G-&gt;Pl-&gt;feasable(building,utd);
+			bool fk = G-&gt;Pl-&gt;feasable(building,utd);
 
-		NLOG(&quot;CKeywordConstructionTask::Build  feasable called&quot;);
+			NLOG(&quot;CKeywordConstructionTask::Build  feasable called&quot;);
 
-		if(!fk){
-			G-&gt;L.print(&quot;CKeywordConstructionTask::Build  unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
+			if(!fk){
+				G-&gt;L.print(&quot;CKeywordConstructionTask::Build  unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
+				End();
+				return;
+			}
+		}
+
+		float3 unitpos = G-&gt;GetUnitPos(unit);
+		float3 pos=unitpos;
+
+		if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
+			NLOG(&quot;CKeywordConstructionTask::Build  mark 2# bad float exit&quot;);
 			End();
 			return;
 		}
-	}
+		
 
-	float3 unitpos = G-&gt;GetUnitPos(unit);
-	float3 pos=unitpos;
 
-	if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
-		NLOG(&quot;CKeywordConstructionTask::Build  mark 2# bad float exit&quot;);
-		End();
-		return;
-	}
-	
+		if(building-&gt;GetDeferRepairRange() &gt; 10){
+			NLOG(&quot;CKeywordConstructionTask::Build  rmax &gt; 10&quot;);
 
+			int* funits = new int[10000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,building-&gt;GetDeferRepairRange());
 
-	if(building-&gt;GetDeferRepairRange() &gt; 10){
-		NLOG(&quot;CKeywordConstructionTask::Build  rmax &gt; 10&quot;);
+			if(fnum &gt; 1){
+				//
+				for(int i = 0; i &lt; fnum; i++){
+					CUnitTypeData* ufdt = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(funits[i]);
 
-		int* funits = new int[10000];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,building-&gt;GetDeferRepairRange());
+					if(ufdt == building){
+						NLOG(&quot;CKeywordConstructionTask::Build  mark 2b#&quot;);
 
-		if(fnum &gt; 1){
-			//
-			for(int i = 0; i &lt; fnum; i++){
-				CUnitTypeData* ufdt = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(funits[i]);
-
-				if(ufdt == building){
-					NLOG(&quot;CKeywordConstructionTask::Build  mark 2b#&quot;);
-
-					if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetDeferRepairRange()){
-						if(G-&gt;cb-&gt;UnitBeingBuilt(funits[i])==true){
-							delete [] funits;
-							NLOG(&quot;CKeywordConstructionTask::Build  exit on repair&quot;);
-							G-&gt;Actions-&gt;Repair(unit,funits[i]);
-							End();
-							return;
+						if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetDeferRepairRange()){
+							if(G-&gt;cb-&gt;UnitBeingBuilt(funits[i])==true){
+								delete [] funits;
+								NLOG(&quot;CKeywordConstructionTask::Build  exit on repair&quot;);
+								G-&gt;Actions-&gt;Repair(unit,funits[i]);
+								End();
+								return;
+							}
 						}
 					}
+
 				}
+			}
 
-			}
+			delete [] funits;
 		}
 
-		delete [] funits;
-	}
+		NLOG(&quot;CKeywordConstructionTask::Build  mark 3#&quot;);
+		////////
 
-	NLOG(&quot;CKeywordConstructionTask::Build  mark 3#&quot;);
-	////////
+		if(building-&gt;GetExclusionRange() &gt; 10){
 
-	if(building-&gt;GetExclusionRange() &gt; 10){
+			int* funits = new int[10000];
 
-		int* funits = new int[10000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,(float)building-&gt;GetExclusionRange());
 
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,(float)building-&gt;GetExclusionRange());
+			if(fnum &gt; 1){
+				//
+				for(int i = 0; i &lt; fnum; i++){
+					CUnitTypeData* ufdt = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(funits[i]);
 
-		if(fnum &gt; 1){
-			//
-			for(int i = 0; i &lt; fnum; i++){
-				CUnitTypeData* ufdt = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(funits[i]);
+					if(ufdt == building){
 
-				if(ufdt == building){
+						NLOG(&quot;CKeywordConstructionTask::Build  mark 3a#&quot;);
 
-					NLOG(&quot;CKeywordConstructionTask::Build  mark 3a#&quot;);
+						if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetExclusionRange()){
+							int kj = funits[i];
+							delete [] funits;
 
-					if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetExclusionRange()){
-						int kj = funits[i];
-						delete [] funits;
-
-						if(G-&gt;cb-&gt;UnitBeingBuilt(kj)==true){
-							NLOG(&quot;CKeywordConstructionTask::Build  exit on repair&quot;);
-							if(!G-&gt;Actions-&gt;Repair(unit,kj)){
+							if(G-&gt;cb-&gt;UnitBeingBuilt(kj)==true){
+								NLOG(&quot;CKeywordConstructionTask::Build  exit on repair&quot;);
+								if(!G-&gt;Actions-&gt;Repair(unit,kj)){
+									End();
+								}
+								return;
+							}else{
+								NLOG(&quot;CKeywordConstructionTask::Build  return false&quot;);
 								End();
+								return;
 							}
-							return;
-						}else{
-							NLOG(&quot;CKeywordConstructionTask::Build  return false&quot;);
-							End();
-							return;
+
 						}
 
 					}
-
 				}
 			}
+			delete [] funits;
 		}
-		delete [] funits;
-	}
 
-    NLOG(&quot;CKeywordConstructionTask::Build  mark 4&quot;);
+		NLOG(&quot;CKeywordConstructionTask::Build  mark 4&quot;);
 
-	G-&gt;BuildingPlacer-&gt;GetBuildPosMessage(this,unit,unitpos,utd,building,building-&gt;GetSpacing()*1.4f);
+		G-&gt;BuildingPlacer-&gt;GetBuildPosMessage(this,unit,unitpos,utd,building,building-&gt;GetSpacing()*1.4f);
 
-    NLOG(&quot;CKeywordConstructionTask::Build  mark 5&quot;);
-}
-
-bool CKeywordConstructionTask::Init(){
-	
-	if(!valid){
-		return false;
+		NLOG(&quot;CKeywordConstructionTask::Build  mark 5&quot;);
 	}
 
-	NLOG((&quot;CKeywordConstructionTask::Init&quot;+G-&gt;Manufacturer-&gt;GetTaskName(type)));
-	G-&gt;L.print(&quot;CKeywordConstructionTask::Init &quot;+G-&gt;Manufacturer-&gt;GetTaskName(type));
+	bool CKeywordConstructionTask::Init(){
+		
+		if(!valid){
+			return false;
+		}
 
-	//G-&gt;L.print(&quot;CKeywordConstructionTask::Init&quot;);
+		NLOG((&quot;CKeywordConstructionTask::Init&quot;+G-&gt;Manufacturer-&gt;GetTaskName(type)));
+		G-&gt;L.print(&quot;CKeywordConstructionTask::Init &quot;+G-&gt;Manufacturer-&gt;GetTaskName(type));
 
-    NLOG(&quot;1&quot;);
-    NLOG((string(&quot;tasktype: &quot;)+G-&gt;Manufacturer-&gt;GetTaskName(type)));
+		//G-&gt;L.print(&quot;CKeywordConstructionTask::Init&quot;);
 
-	// register this modules listeners
-	//G-&gt;RegisterMessageHandler(&quot;unitidle&quot;,me);
-	//G-&gt;RegisterMessageHandler(&quot;unitdestroyed&quot;,me);
+		NLOG(&quot;1&quot;);
+		NLOG((string(&quot;tasktype: &quot;)+G-&gt;Manufacturer-&gt;GetTaskName(type)));
 
-	if(type == B_RANDMOVE){
-		if(G-&gt;Actions-&gt;RandomSpiral(unit)==false){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	} else if(type == B_RETREAT){
-		if(!G-&gt;Actions-&gt;Retreat(unit)){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	} else if(type == B_GUARDIAN){
-		if(!G-&gt;Actions-&gt;RepairNearby(unit,1200)){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	} else if(type == B_GUARDIAN_MOBILES){
-		if(!G-&gt;Actions-&gt;RepairNearbyUnfinishedMobileUnits(unit,1200)){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	} else if(type == B_RESURECT){
-		if(!G-&gt;Actions-&gt;RessurectNearby(unit)){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	}else if((type == B_RULE)||(type == B_RULE_EXTREME)||(type == B_RULE_EXTREME_NOFACT)||(type == B_RULE_EXTREME_CARRY)){//////////////////////////////
+		// register this modules listeners
+		//G-&gt;RegisterMessageHandler(&quot;unitidle&quot;,me);
+		//G-&gt;RegisterMessageHandler(&quot;unitdestroyed&quot;,me);
 
-		type = G-&gt;Economy-&gt;Get(!(type == B_RULE),!(B_RULE_EXTREME_NOFACT == type));
-		if(type == B_NA){
-			valid = false;
-			End();
-			return false;
-		}
+		if(type == B_RANDMOVE){
+			if(G-&gt;Actions-&gt;RandomSpiral(unit)==false){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		} else if(type == B_RETREAT){
+			if(!G-&gt;Actions-&gt;Retreat(unit)){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		} else if(type == B_GUARDIAN){
+			if(!G-&gt;Actions-&gt;RepairNearby(unit,1200)){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		} else if(type == B_GUARDIAN_MOBILES){
+			if(!G-&gt;Actions-&gt;RepairNearbyUnfinishedMobileUnits(unit,1200)){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		} else if(type == B_RESURECT){
+			if(!G-&gt;Actions-&gt;RessurectNearby(unit)){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		}else if((type == B_RULE)||(type == B_RULE_EXTREME)||(type == B_RULE_EXTREME_NOFACT)||(type == B_RULE_EXTREME_CARRY)){//////////////////////////////
 
-		CUBuild b;
-		b.Init(G,utd,unit);
-		string targ = b(type);
-		G-&gt;L.print(&quot;gotten targ value of &quot; + targ + &quot; for RULE&quot;);
-		if (targ != string(&quot;&quot;)){
+			type = G-&gt;Economy-&gt;Get(!(type == B_RULE),!(B_RULE_EXTREME_NOFACT == type));
+			if(type == B_NA){
+				valid = false;
+				End();
+				return false;
+			}
 
-			building = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(targ);
-			Build();
-			return true;
-		}else{
-			G-&gt;L.print(&quot;B_RULE_EXTREME skipped bad return&quot;);
-			End();
-			return false;
-		}
-	}else if(type  == B_OFFENSIVE_REPAIR_RETREAT){
-		if(G-&gt;Actions-&gt;OffensiveRepairRetreat(unit,800)==false){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	}else if(type  == B_REPAIR){
-		if(G-&gt;Actions-&gt;RepairNearby(unit,500)==false){
-			if(G-&gt;Actions-&gt;RepairNearby(unit,1000)==false){
-				if(G-&gt;Actions-&gt;RepairNearby(unit,2600)==false){
-					End();
-					return false;
+			CUBuild b;
+			b.Init(G,utd,unit);
+			string targ = b(type);
+			G-&gt;L.print(&quot;gotten targ value of &quot; + targ + &quot; for RULE&quot;);
+			if (targ != string(&quot;&quot;)){
+
+				building = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(targ);
+				Build();
+				return true;
+			}else{
+				G-&gt;L.print(&quot;B_RULE_EXTREME skipped bad return&quot;);
+				End();
+				return false;
+			}
+		}else if(type  == B_OFFENSIVE_REPAIR_RETREAT){
+			if(G-&gt;Actions-&gt;OffensiveRepairRetreat(unit,800)==false){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		}else if(type  == B_REPAIR){
+			if(G-&gt;Actions-&gt;RepairNearby(unit,500)==false){
+				if(G-&gt;Actions-&gt;RepairNearby(unit,1000)==false){
+					if(G-&gt;Actions-&gt;RepairNearby(unit,2600)==false){
+						End();
+						return false;
+					}else{
+						return true;
+					}
 				}else{
 					return true;
 				}
 			}else{
 				return true;
 			}
-		}else{
-			return true;
-		}
-		return valid;
-	}else if(type  == B_RECLAIM){
-		if(!G-&gt;Actions-&gt;ReclaimNearby(unit,400)){
-			End();
-			return false;
-		}else{
-			return true;
-		}
-	}else if(type  == B_GUARD_FACTORY){
-		float3 upos = G-&gt;GetUnitPos(unit);
-		if(G-&gt;Map-&gt;CheckFloat3(upos)==false){
-			End();
-			return false;
-		}
-		int* funits = new int[6000];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,upos,2000);
-		if(fnum &gt; 0){
-			int closest=0;
-			float d = 2500;
-			for(int  i = 0; i &lt; fnum; i++){
-				if(funits[i] == unit) continue;
-				float3 rpos = G-&gt;GetUnitPos(funits[i]);
-				if(G-&gt;Map-&gt;CheckFloat3(rpos)==false){
-					continue;
-				}else{
-					float q = upos.distance2D(rpos);
-					if(q &lt; d){
-						const UnitDef* rd = G-&gt;GetUnitDef(funits[i]);
-						if(rd == 0){
-							continue;
-						}else{
-							if(rd-&gt;builder &amp;&amp; (rd-&gt;movedata == 0) &amp;&amp; (rd-&gt;buildOptions.empty()==false)){
-								d = q;
-								closest = funits[i];
+			return valid;
+		}else if(type  == B_RECLAIM){
+			if(!G-&gt;Actions-&gt;ReclaimNearby(unit,400)){
+				End();
+				return false;
+			}else{
+				return true;
+			}
+		}else if(type  == B_GUARD_FACTORY){
+			float3 upos = G-&gt;GetUnitPos(unit);
+			if(G-&gt;Map-&gt;CheckFloat3(upos)==false){
+				End();
+				return false;
+			}
+			int* funits = new int[6000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,upos,2000);
+			if(fnum &gt; 0){
+				int closest=0;
+				float d = 2500;
+				for(int  i = 0; i &lt; fnum; i++){
+					if(funits[i] == unit) continue;
+					float3 rpos = G-&gt;GetUnitPos(funits[i]);
+					if(G-&gt;Map-&gt;CheckFloat3(rpos)==false){
+						continue;
+					}else{
+						float q = upos.distance2D(rpos);
+						if(q &lt; d){
+							const UnitDef* rd = G-&gt;GetUnitDef(funits[i]);
+							if(rd == 0){
 								continue;
 							}else{
-								continue;
+								if(rd-&gt;builder &amp;&amp; (rd-&gt;movedata == 0) &amp;&amp; (rd-&gt;buildOptions.empty()==false)){
+									d = q;
+									closest = funits[i];
+									continue;
+								}else{
+									continue;
+								}
 							}
 						}
 					}
 				}
-			}
-			if(ValidUnitID(closest)){
-				delete [] funits;
-				if(!G-&gt;Actions-&gt;Guard(unit,closest)){
+				if(ValidUnitID(closest)){
+					delete [] funits;
+					if(!G-&gt;Actions-&gt;Guard(unit,closest)){
+						End();
+						return false;
+					}else{
+						return true;
+					}
+				}else{
+					delete [] funits;
 					End();
 					return false;
-				}else{
-					return true;
 				}
-			}else{
-				delete [] funits;
+			}
+			delete [] funits;
+			End();
+			return false;
+		}else if(type  == B_GUARD_LIKE_CON){
+			float3 upos = G-&gt;GetUnitPos(unit);
+			if(G-&gt;Map-&gt;CheckFloat3(upos)==false){
 				End();
 				return false;
 			}
-		}
-		delete [] funits;
-		End();
-		return false;
-	}else if(type  == B_GUARD_LIKE_CON){
-		float3 upos = G-&gt;GetUnitPos(unit);
-		if(G-&gt;Map-&gt;CheckFloat3(upos)==false){
-			End();
-			return false;
-		}
-		int* funits = new int[5005];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,upos,2000);
-		if(fnum &gt; 0){
-			int closest=-1;
-			float d = 2500;
-			for(int  i = 0; i &lt; fnum; i++){
-				if(funits[i] == unit) continue;
-				float3 rpos = G-&gt;GetUnitPos(funits[i]);
-				if(G-&gt;Map-&gt;CheckFloat3(rpos)==false){
-					continue;
-				}else{
-					float q = upos.distance2D(rpos);
-					if(q &lt; d){
-						CUnitTypeData* rd = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(funits[i]);
-						if(rd == building){
-							d = q;
-							closest = funits[i];
+			int* funits = new int[5005];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,upos,2000);
+			if(fnum &gt; 0){
+				int closest=-1;
+				float d = 2500;
+				for(int  i = 0; i &lt; fnum; i++){
+					if(funits[i] == unit) continue;
+					float3 rpos = G-&gt;GetUnitPos(funits[i]);
+					if(G-&gt;Map-&gt;CheckFloat3(rpos)==false){
+						continue;
+					}else{
+						float q = upos.distance2D(rpos);
+						if(q &lt; d){
+							CUnitTypeData* rd = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(funits[i]);
+							if(rd == building){
+								d = q;
+								closest = funits[i];
+							}
+							continue;
 						}
-						continue;
 					}
 				}
-			}
-			if(ValidUnitID(closest)){
-				delete [] funits;
-				if(!G-&gt;Actions-&gt;Guard(unit,closest)){
+				if(ValidUnitID(closest)){
+					delete [] funits;
+					if(!G-&gt;Actions-&gt;Guard(unit,closest)){
+						End();
+						return false;
+					}else{
+						return true;
+					}
+				}else{
+					delete [] funits;
 					End();
 					return false;
-				}else{
-					return true;
 				}
-			}else{
-				delete [] funits;
+			}
+			delete [] funits;
+		}else{// if(type != B_NA){
+			CUBuild b;
+			b.Init(G,utd,unit);
+			b.SetWater(G-&gt;info-&gt;spacemod);
+			//if(b.ud-&gt;floater==true){
+			//	b.SetWater(true);
+			//}
+			string targ = b(type);
+			if(targ == string(&quot;&quot;)){
+				G-&gt;L &lt;&lt; &quot;if(targ == string(\&quot;\&quot;)) for &quot;&lt;&lt; G-&gt;Manufacturer-&gt;GetTaskName(type)&lt;&lt; endline;
 				End();
 				return false;
+			}else{
+				CUnitTypeData* udk = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(targ);
+				building = udk;
+				Build();
+				return true;
 			}
 		}
-		delete [] funits;
-	}else{// if(type != B_NA){
-		CUBuild b;
-		b.Init(G,utd,unit);
-		b.SetWater(G-&gt;info-&gt;spacemod);
-		//if(b.ud-&gt;floater==true){
-		//	b.SetWater(true);
-		//}
-		string targ = b(type);
-		if(targ == string(&quot;&quot;)){
-			G-&gt;L &lt;&lt; &quot;if(targ == string(\&quot;\&quot;)) for &quot;&lt;&lt; G-&gt;Manufacturer-&gt;GetTaskName(type)&lt;&lt; endline;
-			End();
-			return false;
-		}else{
-			CUnitTypeData* udk = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(targ);
-			building = udk;
-			Build();
-			return true;
-		}
+		End();
+		return false;
 	}
-	End();
-	return false;
-}
 
-void CKeywordConstructionTask::End(){
-	NLOG(&quot;CKeywordConstructionTask::End&quot;);
-	valid = false;
-	//CMessage message(string(&quot;taskfinished&quot;));
-	//FireEventListener(message);
-//	G-&gt;RemoveHandler(me);
+	void CKeywordConstructionTask::End(){
+		NLOG(&quot;CKeywordConstructionTask::End&quot;);
+		valid = false;
+		//CMessage message(string(&quot;taskfinished&quot;));
+		//FireEventListener(message);
+	//	G-&gt;RemoveHandler(me);
+	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Tasks/CUnitConstructionTask.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Tasks/CUnitConstructionTask.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Tasks/CUnitConstructionTask.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,309 +1,318 @@
 #include &quot;../Core/include.h&quot;
 
-CUnitConstructionTask::CUnitConstructionTask(Global* GL, int unit,CUnitTypeData* builder, CUnitTypeData* building){
-	valid=ValidUnitID(unit);
-	if(!valid){
-		End();
-		return;
-	}
+/*
+AF 2004+
+LGPL 2
+*/
 
-	G = GL;
-	this-&gt;unit=unit;
-	this-&gt;builder = builder;
-	this-&gt;building = building;
+namespace ntai {
 
-	if( builder == 0){
-		valid = false;
-	}else if(building == 0){
-		valid = false;
-	}
+	CUnitConstructionTask::CUnitConstructionTask(Global* GL, int unit,CUnitTypeData* builder, CUnitTypeData* building){
+		valid=ValidUnitID(unit);
+		if(!valid){
+			End();
+			return;
+		}
 
-	G-&gt;L.print(&quot;CUnitConstructionTask::CUnitConstructionTask object created | params: building :: &quot;+this-&gt;building-&gt;GetUnitDef()-&gt;name+&quot; using builder::&quot;+ this-&gt;builder-&gt;GetUnitDef()-&gt;name);
-}
+		G = GL;
+		this-&gt;unit=unit;
+		this-&gt;builder = builder;
+		this-&gt;building = building;
 
-CUnitConstructionTask::~CUnitConstructionTask(){
-	G-&gt;L.print(&quot;CUnitConstructionTask::~CUnitConstructionTask :: &quot;+building-&gt;GetUnitDef()-&gt;name);
-}
+		if( builder == 0){
+			valid = false;
+		}else if(building == 0){
+			valid = false;
+		}
 
-void CUnitConstructionTask::RecieveMessage(CMessage &amp;message){
-	if(!valid){
-		return;// false;
+		G-&gt;L.print(&quot;CUnitConstructionTask::CUnitConstructionTask object created | params: building :: &quot;+this-&gt;building-&gt;GetUnitDef()-&gt;name+&quot; using builder::&quot;+ this-&gt;builder-&gt;GetUnitDef()-&gt;name);
 	}
 
-	NLOG(&quot;CUnitConstructionTask::RecieveMessage&quot;);
-	if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0) == unit){
-			End();
-			return;
+	CUnitConstructionTask::~CUnitConstructionTask(){
+		G-&gt;L.print(&quot;CUnitConstructionTask::~CUnitConstructionTask :: &quot;+building-&gt;GetUnitDef()-&gt;name);
+	}
+
+	void CUnitConstructionTask::RecieveMessage(CMessage &amp;message){
+		if(!valid){
+			return;// false;
 		}
-	} else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0) == unit){
-			End();
-			return;
-		}
-	}else if(message.GetType() == string(&quot;type?&quot;)){
-		message.SetType(&quot; build:&quot;+building-&gt;GetUnitDef()-&gt;name);
-	}else if(message.GetType() == string(&quot;buildposition&quot;)){
-		// continue construction
-		//
-		TCommand tc(unit,&quot;CBuild&quot;);
-		tc.ID(-building-&gt;GetUnitDef()-&gt;id);
-		float3 pos = message.GetFloat3();
-		if(!building-&gt;IsMobile()){
-			if(pos==UpVector){
-				G-&gt;L.print(&quot;BuildPlacement returned UpVector or some other nasty position, a build location wasn't found!&quot;);
+
+		NLOG(&quot;CUnitConstructionTask::RecieveMessage&quot;);
+		if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0) == unit){
 				End();
 				return;
-			} else if (G-&gt;cb-&gt;CanBuildAt(building-&gt;GetUnitDef(),pos,0)==false){
-				G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage BuildPlacement returned a position that cant be built upon&quot;);
+			}
+		} else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0) == unit){
 				End();
 				return;
 			}
-		}
-		pos.y = G-&gt;cb-&gt;GetElevation(pos.x,pos.z);
+		}else if(message.GetType() == string(&quot;type?&quot;)){
+			message.SetType(&quot; build:&quot;+building-&gt;GetUnitDef()-&gt;name);
+		}else if(message.GetType() == string(&quot;buildposition&quot;)){
+			// continue construction
+			//
+			TCommand tc(unit,&quot;CBuild&quot;);
+			tc.ID(-building-&gt;GetUnitDef()-&gt;id);
+			float3 pos = message.GetFloat3();
+			if(!building-&gt;IsMobile()){
+				if(pos==UpVector){
+					G-&gt;L.print(&quot;BuildPlacement returned UpVector or some other nasty position, a build location wasn't found!&quot;);
+					End();
+					return;
+				} else if (G-&gt;cb-&gt;CanBuildAt(building-&gt;GetUnitDef(),pos,0)==false){
+					G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage BuildPlacement returned a position that cant be built upon&quot;);
+					End();
+					return;
+				}
+			}
+			pos.y = G-&gt;cb-&gt;GetElevation(pos.x,pos.z);
 
-		deque&lt;CBPlan* &gt;::iterator qi = G-&gt;Manufacturer-&gt;OverlappingPlans(pos,building-&gt;GetUnitDef());
-		if(qi != G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
-			NLOG(&quot;vector&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud); :: WipePlansForBuilder&quot;);
-			/*if(qi-&gt;started){
-				G-&gt;L.print(&quot;::Cbuild overlapping plans issuing repair instead&quot;);
-				if(G-&gt;Actions-&gt;Repair(unit,qi-&gt;subject)){
-					WipePlansForBuilder(unit);
-					qi-&gt;builders.insert(unit);
-					return false;
+			deque&lt;CBPlan* &gt;::iterator qi = G-&gt;Manufacturer-&gt;OverlappingPlans(pos,building-&gt;GetUnitDef());
+			if(qi != G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
+				NLOG(&quot;vector&lt;CBPlan&gt;::iterator qi = OverlappingPlans(pos,ud); :: WipePlansForBuilder&quot;);
+				/*if(qi-&gt;started){
+					G-&gt;L.print(&quot;::Cbuild overlapping plans issuing repair instead&quot;);
+					if(G-&gt;Actions-&gt;Repair(unit,qi-&gt;subject)){
+						WipePlansForBuilder(unit);
+						qi-&gt;builders.insert(unit);
+						return false;
+					}
+				}else*/
+				if ((*qi)-&gt;utd == building){
+					G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage overlapping plans that're the same item but not started, moving pos to make it build quicker&quot;);
+					pos = (*qi)-&gt;pos;
 				}
-			}else*/
-			if ((*qi)-&gt;utd == building){
-				G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage overlapping plans that're the same item but not started, moving pos to make it build quicker&quot;);
-				pos = (*qi)-&gt;pos;
+				/*else{
+					G-&gt;L.print(&quot;::Cbuild overlapping plans that are not the same item, no alternative action, cancelling task&quot;);
+					CMessage message(string(&quot;taskfinished&quot;));
+					FireEventListener(message);
+					return;
+				}*/
 			}
-			/*else{
-				G-&gt;L.print(&quot;::Cbuild overlapping plans that are not the same item, no alternative action, cancelling task&quot;);
-				CMessage message(string(&quot;taskfinished&quot;));
-				FireEventListener(message);
+			tc.PushFloat3(pos);
+			tc.Push(0);
+			tc.c.timeOut = int(building-&gt;GetUnitDef()-&gt;buildTime/5) + G-&gt;cb-&gt;GetCurrentFrame();
+			tc.created = G-&gt;cb-&gt;GetCurrentFrame();
+			tc.delay=0;
+
+			if(G-&gt;OrderRouter-&gt;GiveOrder(tc)== false){
+				G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage Failed Order G-&gt;OrderRouter-&gt;GiveOrder(tc)== false:: &quot; + builder-&gt;GetUnitDef()-&gt;name);
+				End();
 				return;
-			}*/
-		}
-		tc.PushFloat3(pos);
-		tc.Push(0);
-		tc.c.timeOut = int(building-&gt;GetUnitDef()-&gt;buildTime/5) + G-&gt;cb-&gt;GetCurrentFrame();
-		tc.created = G-&gt;cb-&gt;GetCurrentFrame();
-		tc.delay=0;
+			}else{
 
-		if(G-&gt;OrderRouter-&gt;GiveOrder(tc)== false){
-			G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage Failed Order G-&gt;OrderRouter-&gt;GiveOrder(tc)== false:: &quot; + builder-&gt;GetUnitDef()-&gt;name);
-			End();
-			return;
-		}else{
+				// create a plan
+				G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage G-&gt;OrderRouter-&gt;GiveOrder(tc)== true :: &quot; + builder-&gt;GetUnitDef()-&gt;name);
+				if(qi == G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
+					NLOG(&quot;CUnitConstructionTask::RecieveMessage :: WipePlansForBuilder&quot;);
+					G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage wiping and creaiing the plan :: &quot; + builder-&gt;GetUnitDef()-&gt;name);
 
-			// create a plan
-			G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage G-&gt;OrderRouter-&gt;GiveOrder(tc)== true :: &quot; + builder-&gt;GetUnitDef()-&gt;name);
-			if(qi == G-&gt;Manufacturer-&gt;BPlans-&gt;end()){
-				NLOG(&quot;CUnitConstructionTask::RecieveMessage :: WipePlansForBuilder&quot;);
-				G-&gt;L.print(&quot;CUnitConstructionTask::RecieveMessage wiping and creaiing the plan :: &quot; + builder-&gt;GetUnitDef()-&gt;name);
+					CBPlan* Bplan = new CBPlan();
+					Bplan-&gt;started = false;
+					Bplan-&gt;AddBuilder(unit);
+					Bplan-&gt;subject = -1;
+					Bplan-&gt;pos = pos;
+					Bplan-&gt;utd=building;
+					G-&gt;Manufacturer-&gt;AddPlan();
 
-				CBPlan* Bplan = new CBPlan();
-				Bplan-&gt;started = false;
-				Bplan-&gt;AddBuilder(unit);
-				Bplan-&gt;subject = -1;
-				Bplan-&gt;pos = pos;
-				Bplan-&gt;utd=building;
-				G-&gt;Manufacturer-&gt;AddPlan();
+					Bplan-&gt;id = G-&gt;Manufacturer-&gt;getplans();
+					Bplan-&gt;radius = (float)max(building-&gt;GetUnitDef()-&gt;xsize,building-&gt;GetUnitDef()-&gt;ysize)*8.0f;
+					Bplan-&gt;inFactory = builder-&gt;IsFactory();
+					G-&gt;Manufacturer-&gt;BPlans-&gt;push_back(Bplan);
+					if((builder-&gt;IsFactory()&amp;&amp;building-&gt;IsMobile())==false){
+						G-&gt;BuildingPlacer-&gt;Block(pos,building);
+					}
 
-				Bplan-&gt;id = G-&gt;Manufacturer-&gt;getplans();
-				Bplan-&gt;radius = (float)max(building-&gt;GetUnitDef()-&gt;xsize,building-&gt;GetUnitDef()-&gt;ysize)*8.0f;
-				Bplan-&gt;inFactory = builder-&gt;IsFactory();
-				G-&gt;Manufacturer-&gt;BPlans-&gt;push_back(Bplan);
-				if((builder-&gt;IsFactory()&amp;&amp;building-&gt;IsMobile())==false){
-					G-&gt;BuildingPlacer-&gt;Block(pos,building);
 				}
-
+				return;
 			}
-			return;
 		}
 	}
-}
 
-bool CUnitConstructionTask::Init(){
+	bool CUnitConstructionTask::Init(){
 
 
-	G-&gt;L.print(&quot;CUnitConstructionTask::Init :: &quot;+building-&gt;GetUnitDef()-&gt;name);
+		G-&gt;L.print(&quot;CUnitConstructionTask::Init :: &quot;+building-&gt;GetUnitDef()-&gt;name);
 
-	/////////////
-	// Sort out the stuff that's setup to ALWAYS be under the antistall algorithm
-	if(!G-&gt;Pl-&gt;AlwaysAntiStall.empty()){
+		/////////////
+		// Sort out the stuff that's setup to ALWAYS be under the antistall algorithm
+		if(!G-&gt;Pl-&gt;AlwaysAntiStall.empty()){
 
-		NLOG(&quot;CUnitConstructionTask::Init G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false&quot;);
-		for(vector&lt;string&gt;::iterator i = G-&gt;Pl-&gt;AlwaysAntiStall.begin(); i != G-&gt;Pl-&gt;AlwaysAntiStall.end(); ++i){
+			NLOG(&quot;CUnitConstructionTask::Init G-&gt;Pl-&gt;AlwaysAntiStall.empty() == false&quot;);
+			for(vector&lt;string&gt;::iterator i = G-&gt;Pl-&gt;AlwaysAntiStall.begin(); i != G-&gt;Pl-&gt;AlwaysAntiStall.end(); ++i){
 
-			if(*i == building-&gt;GetUnitDef()-&gt;name){
+				if(*i == building-&gt;GetUnitDef()-&gt;name){
 
-				NLOG(&quot;CUnitConstructionTask::Init *i == name :: &quot;+building-&gt;GetUnitDef()-&gt;name);
+					NLOG(&quot;CUnitConstructionTask::Init *i == name :: &quot;+building-&gt;GetUnitDef()-&gt;name);
 
-				if(G-&gt;Pl-&gt;feasable(building,builder) == false){
-					
-					G-&gt;L.print(&quot;CUnitConstructionTask::Init  unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
-					
-					End();
-					return false;
-				}else{
+					if(G-&gt;Pl-&gt;feasable(building,builder) == false){
+						
+						G-&gt;L.print(&quot;CUnitConstructionTask::Init  unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
+						
+						End();
+						return false;
+					}else{
 
-					NLOG(&quot;CUnitConstructionTask::Init  &quot;+building-&gt;GetUnitDef()-&gt;name+&quot; is feasable&quot;);
-					break;
+						NLOG(&quot;CUnitConstructionTask::Init  &quot;+building-&gt;GetUnitDef()-&gt;name+&quot; is feasable&quot;);
+						break;
+					}
+
 				}
-
 			}
 		}
-	}
 
-	string t = &quot;&quot;;
-	
-	NLOG(&quot;CUnitConstructionTask::Init  Resource\\MaxEnergy\\&quot;);
-	
-	float emax=1000000000;
-	string key = &quot;Resource\\MaxEnergy\\&quot;;
-	key += building-&gt;GetName();
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default/**/
-	
-	if(emax ==0){
-		emax = 30000000;
-	}
+		string t = &quot;&quot;;
+		
+		NLOG(&quot;CUnitConstructionTask::Init  Resource\\MaxEnergy\\&quot;);
+		
+		float emax=1000000000;
+		string key = &quot;Resource\\MaxEnergy\\&quot;;
+		key += building-&gt;GetName();
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emax,&quot;3000000&quot;,key);// +300k energy per tick by default/**/
+		
+		if(emax ==0){
+			emax = 30000000;
+		}
 
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
-		G-&gt;L.print(&quot;CUnitConstructionTask::Init  emax &quot; + building-&gt;GetUnitDef()-&gt;name);
-		End();
-		return false;
-	}
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &gt; emax){
+			G-&gt;L.print(&quot;CUnitConstructionTask::Init  emax &quot; + building-&gt;GetUnitDef()-&gt;name);
+			End();
+			return false;
+		}
 
-	NLOG(&quot;CUnitConstructionTask::Init  Resource\\MinEnergy\\&quot;);
-	
-	float emin=0;
-	key = &quot;Resource\\MinEnergy\\&quot;;
-	key += building-&gt;GetName();
+		NLOG(&quot;CUnitConstructionTask::Init  Resource\\MinEnergy\\&quot;);
+		
+		float emin=0;
+		key = &quot;Resource\\MinEnergy\\&quot;;
+		key += building-&gt;GetName();
 
-	G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default/**/
+		G-&gt;Get_mod_tdf()-&gt;GetDef(emin,&quot;0&quot;,key);// +0k energy per tick by default/**/
 
-	if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
-		G-&gt;L.print(&quot;CUnitConstructionTask::Init  emin &quot; + building-&gt;GetUnitDef()-&gt;name);
-		End();
-		return false;
-	}
+		if(G-&gt;Pl-&gt;GetEnergyIncome() &lt; emin){
+			G-&gt;L.print(&quot;CUnitConstructionTask::Init  emin &quot; + building-&gt;GetUnitDef()-&gt;name);
+			End();
+			return false;
+		}
 
 
 
-	// Now sort out stuff that can only be built one at a time
-	if(building-&gt;GetSoloBuildActive()){
-		NLOG(&quot;CUnitConstructionTask::Build  G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()&quot;);
-		End();
-		return false;
-	}
+		// Now sort out stuff that can only be built one at a time
+		if(building-&gt;GetSoloBuildActive()){
+			NLOG(&quot;CUnitConstructionTask::Build  G-&gt;Cached-&gt;solobuilds.find(name)!= G-&gt;Cached-&gt;solobuilds.end()&quot;);
+			End();
+			return false;
+		}
 
-	// Now sort out if it's one of those things that can only be built once
-	if(building-&gt;GetSingleBuildActive()){
-		G-&gt;L.print(&quot;CUnitConstructionTask::Build  singlebuild &quot; + building-&gt;GetUnitDef()-&gt;name);
-		End();
-		return true;
-	}
+		// Now sort out if it's one of those things that can only be built once
+		if(building-&gt;GetSingleBuildActive()){
+			G-&gt;L.print(&quot;CUnitConstructionTask::Build  singlebuild &quot; + building-&gt;GetUnitDef()-&gt;name);
+			End();
+			return true;
+		}
 
 
-	//if(G-&gt;Pl-&gt;feasable(name,unit)==false){
-	//	return false;
-	//}
-	// If Antistall == 2/3 then we always do this
+		//if(G-&gt;Pl-&gt;feasable(name,unit)==false){
+		//	return false;
+		//}
+		// If Antistall == 2/3 then we always do this
 
-	if(G-&gt;info-&gt;antistall&gt;1){
-		NLOG(&quot;CUnitConstructionTask::Init  G-&gt;info-&gt;antistall&gt;1&quot;);
-		bool fk = G-&gt;Pl-&gt;feasable(building,builder);
-		NLOG(&quot;CUnitConstructionTask::Init  feasable called&quot;);
-		if(fk == false){
-			G-&gt;L.print(&quot;CUnitConstructionTask::Init  unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
+		if(G-&gt;info-&gt;antistall&gt;1){
+			NLOG(&quot;CUnitConstructionTask::Init  G-&gt;info-&gt;antistall&gt;1&quot;);
+			bool fk = G-&gt;Pl-&gt;feasable(building,builder);
+			NLOG(&quot;CUnitConstructionTask::Init  feasable called&quot;);
+			if(fk == false){
+				G-&gt;L.print(&quot;CUnitConstructionTask::Init  unfeasable &quot; + building-&gt;GetUnitDef()-&gt;name);
+				End();
+				return false;
+			}
+		}
+
+		float3 unitpos = G-&gt;GetUnitPos(unit);
+		float3 pos=unitpos;
+		if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
+			NLOG(&quot;CUnitConstructionTask::Init  mark 2# bad float exit&quot;);
 			End();
 			return false;
 		}
-	}
 
-	float3 unitpos = G-&gt;GetUnitPos(unit);
-	float3 pos=unitpos;
-	if(G-&gt;Map-&gt;CheckFloat3(unitpos) == false){
-		NLOG(&quot;CUnitConstructionTask::Init  mark 2# bad float exit&quot;);
-		End();
-		return false;
-	}
-
-	if(building-&gt;GetDeferRepairRange() &gt; 10){
-		NLOG(&quot;CUnitConstructionTask::Init  rmax &gt; 10&quot;);
-		int* funits = new int[10000];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,building-&gt;GetDeferRepairRange());
-		if(fnum &gt; 1){
-			//
-			for(int i = 0; i &lt; fnum; i++){
-				const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
-				if(udf == 0) continue;
-				if(udf == building-&gt;GetUnitDef()){
-					NLOG(&quot;CUnitConstructionTask::Init  mark 2b#&quot;);
-					if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetDeferRepairRange()){
-						if(G-&gt;cb-&gt;UnitBeingBuilt(funits[i])){
-							delete [] funits;
-							NLOG(&quot;CUnitConstructionTask::Init  exit on repair&quot;);
-							if(!G-&gt;Actions-&gt;Repair(unit,funits[i])){
-								End();
-								return false;
-							}else{
-								End();
-								return true;
+		if(building-&gt;GetDeferRepairRange() &gt; 10){
+			NLOG(&quot;CUnitConstructionTask::Init  rmax &gt; 10&quot;);
+			int* funits = new int[10000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,building-&gt;GetDeferRepairRange());
+			if(fnum &gt; 1){
+				//
+				for(int i = 0; i &lt; fnum; i++){
+					const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
+					if(udf == 0) continue;
+					if(udf == building-&gt;GetUnitDef()){
+						NLOG(&quot;CUnitConstructionTask::Init  mark 2b#&quot;);
+						if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetDeferRepairRange()){
+							if(G-&gt;cb-&gt;UnitBeingBuilt(funits[i])){
+								delete [] funits;
+								NLOG(&quot;CUnitConstructionTask::Init  exit on repair&quot;);
+								if(!G-&gt;Actions-&gt;Repair(unit,funits[i])){
+									End();
+									return false;
+								}else{
+									End();
+									return true;
+								}
 							}
 						}
 					}
 				}
 			}
+			delete [] funits;
 		}
-		delete [] funits;
-	}
 
-	NLOG(&quot;CUnitConstructionTask::Init  mark 3#&quot;);
-	////////
+		NLOG(&quot;CUnitConstructionTask::Init  mark 3#&quot;);
+		////////
 
-	if(building-&gt;GetExclusionRange() &gt; 10){
-		int* funits = new int[10000];
-		int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,building-&gt;GetDeferRepairRange());
-		if(fnum &gt; 1){
-			//
-			for(int i = 0; i &lt; fnum; i++){
-				const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
-				if(udf == 0){
-					continue;
-				}
-				if(udf == building-&gt;GetUnitDef()){
-					NLOG(&quot;CUnitConstructionTask::Init  mark 3a#&quot;);
-					if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetExclusionRange()){
-						int kj = funits[i];
-						delete [] funits;
-						if(G-&gt;cb-&gt;UnitBeingBuilt(kj)==true){
-							NLOG(&quot;CUnitConstructionTask::Init  exit on repair&quot;);
-							if(!G-&gt;Actions-&gt;Repair(unit,kj)){
-								End();
-								return true;
+		if(building-&gt;GetExclusionRange() &gt; 10){
+			int* funits = new int[10000];
+			int fnum = G-&gt;cb-&gt;GetFriendlyUnits(funits,unitpos,building-&gt;GetDeferRepairRange());
+			if(fnum &gt; 1){
+				//
+				for(int i = 0; i &lt; fnum; i++){
+					const UnitDef* udf = G-&gt;GetUnitDef(funits[i]);
+					if(udf == 0){
+						continue;
+					}
+					if(udf == building-&gt;GetUnitDef()){
+						NLOG(&quot;CUnitConstructionTask::Init  mark 3a#&quot;);
+						if(G-&gt;GetUnitPos(funits[i]).distance2D(unitpos) &lt; building-&gt;GetExclusionRange()){
+							int kj = funits[i];
+							delete [] funits;
+							if(G-&gt;cb-&gt;UnitBeingBuilt(kj)==true){
+								NLOG(&quot;CUnitConstructionTask::Init  exit on repair&quot;);
+								if(!G-&gt;Actions-&gt;Repair(unit,kj)){
+									End();
+									return true;
+								}else{
+									End();
+									return true;
+								}
 							}else{
+								NLOG(&quot;CUnitConstructionTask::Init  return false&quot;);
 								End();
-								return true;
+								return false;
 							}
-						}else{
-							NLOG(&quot;CUnitConstructionTask::Init  return false&quot;);
-							End();
-							return false;
 						}
 					}
 				}
 			}
+			delete [] funits;
 		}
-		delete [] funits;
+
+		G-&gt;BuildingPlacer-&gt;GetBuildPosMessage(this,unit,unitpos,builder,building,building-&gt;GetSpacing()*1.4f);
+		return true;
 	}
 
-	G-&gt;BuildingPlacer-&gt;GetBuildPosMessage(this,unit,unitpos,builder,building,building-&gt;GetSpacing()*1.4f);
-	return true;
-}
+	void CUnitConstructionTask::End(){
+		NLOG(&quot;CUnitConstructionTask::End&quot;);
+		valid = false;
+	}
 
-void CUnitConstructionTask::End(){
-	NLOG(&quot;CUnitConstructionTask::End&quot;);
-	valid = false;
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/AttackBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/AttackBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/AttackBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,43 +1,45 @@
 #include &quot;../../Core/include.h&quot;
 
-CAttackBehaviour::CAttackBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	engaged = false;
-	unit = G-&gt;GetUnit(uid);
-	uid = ((CUnit*)unit.get())-&gt;GetID();
-}
+namespace ntai {
+	CAttackBehaviour::CAttackBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		engaged = false;
+		unit = G-&gt;GetUnit(uid);
+		uid = ((CUnit*)unit.get())-&gt;GetID();
+	}
 
-CAttackBehaviour::~CAttackBehaviour(){
-	//
-}
+	CAttackBehaviour::~CAttackBehaviour(){
+		//
+	}
 
-bool CAttackBehaviour::Init(){
-	return true;
-}
+	bool CAttackBehaviour::Init(){
+		return true;
+	}
 
-void CAttackBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;update&quot;)){
-		if(engaged){
-			return;
-		}
-		if(EVERY_(120 FRAMES)){
-			
-			float3 pos = G-&gt;GetUnitPos(uid);
-			if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+	void CAttackBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;update&quot;)){
+			if(engaged){
 				return;
 			}
+			if(EVERY_(120 FRAMES)){
+				
+				float3 pos = G-&gt;GetUnitPos(uid);
+				if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+					return;
+				}
 
-			engaged = G-&gt;Actions-&gt;AttackNear(uid, 3.5f);
+				engaged = G-&gt;Actions-&gt;AttackNear(uid, 3.5f);
+			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0)== uid){
+				End();
+			}
+		}else if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0)== uid){
+				engaged=false;
+			}
 		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0)== uid){
-			End();
-		}
-	}else if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0)== uid){
-			engaged=false;
-		}
 	}
+
 }
-

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CDGunBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CDGunBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CDGunBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,36 +1,38 @@
 #include &quot;../../Core/include.h&quot;
 
-CDGunBehaviour::CDGunBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	unit = G-&gt;GetUnit(uid);
-	uid = ((CUnit*)unit.get())-&gt;GetID();
-	active = false;
-}
+namespace ntai {
+	CDGunBehaviour::CDGunBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		unit = G-&gt;GetUnit(uid);
+		uid = ((CUnit*)unit.get())-&gt;GetID();
+		active = false;
+	}
 
-CDGunBehaviour::~CDGunBehaviour(){
-	//
-}
+	CDGunBehaviour::~CDGunBehaviour(){
+		//
+	}
 
-bool CDGunBehaviour::Init(){
-	return true;
-}
+	bool CDGunBehaviour::Init(){
+		return true;
+	}
 
-void CDGunBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;update&quot;)){
-		if(message.GetFrame() % (64) == 0){
-			if(!active){
-				active = G-&gt;Actions-&gt;DGunNearby(uid);
+	void CDGunBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;update&quot;)){
+			if(message.GetFrame() % (64) == 0){
+				if(!active){
+					active = G-&gt;Actions-&gt;DGunNearby(uid);
+				}
 			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0)== uid){
+				End();
+				return;
+			}
+		}else if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0)== uid){
+				active=false;
+			}
 		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0)== uid){
-			End();
-			return;
-		}
-	}else if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0)== uid){
-			active=false;
-		}
 	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CKamikazeBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CKamikazeBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CKamikazeBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,45 +1,47 @@
 #include &quot;../../Core/include.h&quot;
 
-CKamikazeBehaviour::CKamikazeBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	engaged = false;
-	unit = G-&gt;GetUnit(uid);
-	uid = ((CUnit*)unit.get())-&gt;GetID();
-	maxrange = G-&gt;cb-&gt;GetUnitMaxRange(uid);
-}
+namespace ntai {
+	CKamikazeBehaviour::CKamikazeBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		engaged = false;
+		unit = G-&gt;GetUnit(uid);
+		uid = ((CUnit*)unit.get())-&gt;GetID();
+		maxrange = G-&gt;cb-&gt;GetUnitMaxRange(uid);
+	}
 
-CKamikazeBehaviour::~CKamikazeBehaviour(){
-	//
-}
+	CKamikazeBehaviour::~CKamikazeBehaviour(){
+		//
+	}
 
-bool CKamikazeBehaviour::Init(){
-	return true;
-}
+	bool CKamikazeBehaviour::Init(){
+		return true;
+	}
 
-void CKamikazeBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;update&quot;)){
-		if(engaged){
-			return;
+	void CKamikazeBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;update&quot;)){
+			if(engaged){
+				return;
+			}
+			if(EVERY_(120 FRAMES)){
+				
+				int* funits = new int [G-&gt;Cached-&gt;enemies.size()];
+				int fu = G-&gt;GetEnemyUnits(funits, G-&gt;GetUnitPos(uid), maxrange);
+				if(fu &gt; 0 ){
+					TCommand tc(uid, &quot;CKamikazeBehaviour::RecieveMessage selfd&quot;);
+					tc.ID(CMD_SELFD);
+					engaged = G-&gt;OrderRouter-&gt;GiveOrder(tc);
+				}
+				delete [] funits;
+			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0) == uid){
+				End();
+			}
+		}else if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0) == uid){
+				engaged=false;
+			}
 		}
-		if(EVERY_(120 FRAMES)){
-			
-			int* funits = new int [G-&gt;Cached-&gt;enemies.size()];
-            int fu = G-&gt;GetEnemyUnits(funits, G-&gt;GetUnitPos(uid), maxrange);
-            if(fu &gt; 0 ){
-                TCommand tc(uid, &quot;CKamikazeBehaviour::RecieveMessage selfd&quot;);
-                tc.ID(CMD_SELFD);
-                engaged = G-&gt;OrderRouter-&gt;GiveOrder(tc);
-            }
-            delete [] funits;
-		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0) == uid){
-			End();
-		}
-	}else if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0) == uid){
-			engaged=false;
-		}
 	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CMoveFailReclaimBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CMoveFailReclaimBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CMoveFailReclaimBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,33 +1,35 @@
 #include &quot;../../Core/include.h&quot;
 
-CMoveFailReclaimBehaviour::CMoveFailReclaimBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	unit = G-&gt;GetUnit(uid);
-	this-&gt;uid = ((CUnit*)unit.get())-&gt;GetID();
-}
+namespace ntai {
+	CMoveFailReclaimBehaviour::CMoveFailReclaimBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		unit = G-&gt;GetUnit(uid);
+		this-&gt;uid = ((CUnit*)unit.get())-&gt;GetID();
+	}
 
-CMoveFailReclaimBehaviour::~CMoveFailReclaimBehaviour(){
-	//
-}
+	CMoveFailReclaimBehaviour::~CMoveFailReclaimBehaviour(){
+		//
+	}
 
-bool CMoveFailReclaimBehaviour::Init(){
-	return true;
-}
+	bool CMoveFailReclaimBehaviour::Init(){
+		return true;
+	}
 
-void CMoveFailReclaimBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;unitmovefailed&quot;)){
-		if(message.GetParameter(0) == uid){
-			int* f = new int[2];
-			int i = G-&gt;cb-&gt;GetFeatures(f,1,G-&gt;GetUnitPos(uid),100.0f);
-			delete [] f;
-			if(i &gt; 0){
-				G-&gt;Actions-&gt;AreaReclaim(uid,G-&gt;GetUnitPos(uid),100);
+	void CMoveFailReclaimBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;unitmovefailed&quot;)){
+			if(message.GetParameter(0) == uid){
+				int* f = new int[2];
+				int i = G-&gt;cb-&gt;GetFeatures(f,1,G-&gt;GetUnitPos(uid),100.0f);
+				delete [] f;
+				if(i &gt; 0){
+					G-&gt;Actions-&gt;AreaReclaim(uid,G-&gt;GetUnitPos(uid),100);
+				}
 			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0)== uid){
+				End();
+			}
 		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0)== uid){
-			End();
-		}
 	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CRetreatBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CRetreatBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CRetreatBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,63 +1,65 @@
 #include &quot;../../Core/include.h&quot;
 
-CRetreatBehaviour::CRetreatBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	unit = G-&gt;GetUnit(uid);
-	uid = ((CUnit*)unit.get())-&gt;GetID();
-	active = false;
-}
+namespace ntai {
+	CRetreatBehaviour::CRetreatBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		unit = G-&gt;GetUnit(uid);
+		uid = ((CUnit*)unit.get())-&gt;GetID();
+		active = false;
+	}
 
-CRetreatBehaviour::~CRetreatBehaviour(){
-	//
-}
+	CRetreatBehaviour::~CRetreatBehaviour(){
+		//
+	}
 
-bool CRetreatBehaviour::Init(){
-	return true;
-}
+	bool CRetreatBehaviour::Init(){
+		return true;
+	}
 
-void CRetreatBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;unitdamaged&quot;)){
-		if(message.GetParameter(0) == uid){
-			damage += message.GetParameter(2);
-		}
-	}else if(message.GetType() == string(&quot;update&quot;)){
-		if(G-&gt;GetCurrentFrame() % (64) == 0){
-			float d = damage;
-			damage = 0;
+	void CRetreatBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;unitdamaged&quot;)){
+			if(message.GetParameter(0) == uid){
+				damage += message.GetParameter(2);
+			}
+		}else if(message.GetType() == string(&quot;update&quot;)){
+			if(G-&gt;GetCurrentFrame() % (64) == 0){
+				float d = damage;
+				damage = 0;
 
-			if(!active){
-				float3 dpos = G-&gt;GetUnitPos(uid);
-				if(G-&gt;Map-&gt;CheckFloat3(dpos) == false){
-					return;
-				}
+				if(!active){
+					float3 dpos = G-&gt;GetUnitPos(uid);
+					if(G-&gt;Map-&gt;CheckFloat3(dpos) == false){
+						return;
+					}
 
-				int* garbage = new int[1000];
-				int n =G-&gt;cb-&gt;GetFriendlyUnits(garbage,dpos,400);
-				delete[] garbage;
+					int* garbage = new int[1000];
+					int n =G-&gt;cb-&gt;GetFriendlyUnits(garbage,dpos,400);
+					delete[] garbage;
 
-				if(n &gt; 4){
-					float mhealth = G-&gt;cb-&gt;GetUnitMaxHealth(uid);
-					float chealth = G-&gt;cb-&gt;GetUnitHealth(uid);
-					if((mhealth != 0)&amp;&amp;(chealth != 0)){
-						if((chealth &lt; mhealth*0.45f)||(d &gt; mhealth*0.7f)){
-							// ahk ahk unit is low on health run away! run away!
-							// Or unit is being attacked by a weapon that's going to blow it up very quickly
-							// Units will want to stay alive!!!
-							active = G-&gt;Actions-&gt;Retreat(uid);
+					if(n &gt; 4){
+						float mhealth = G-&gt;cb-&gt;GetUnitMaxHealth(uid);
+						float chealth = G-&gt;cb-&gt;GetUnitHealth(uid);
+						if((mhealth != 0)&amp;&amp;(chealth != 0)){
+							if((chealth &lt; mhealth*0.45f)||(d &gt; mhealth*0.7f)){
+								// ahk ahk unit is low on health run away! run away!
+								// Or unit is being attacked by a weapon that's going to blow it up very quickly
+								// Units will want to stay alive!!!
+								active = G-&gt;Actions-&gt;Retreat(uid);
+							}
 						}
 					}
 				}
 			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0)== uid){
+				End();
+				return;
+			}
+		}else if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0)== uid){
+				active=false;
+			}
 		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0)== uid){
-			End();
-			return;
-		}
-	}else if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0)== uid){
-			active=false;
-		}
 	}
 }

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CStaticDefenceBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CStaticDefenceBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/CStaticDefenceBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,43 +1,45 @@
 #include &quot;../../Core/include.h&quot;
 
-CStaticDefenceBehaviour::CStaticDefenceBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	engaged = false;
-	unit = G-&gt;GetUnit(uid);
-	uid = ((CUnit*)unit.get())-&gt;GetID();
-}
+namespace ntai {
+	CStaticDefenceBehaviour::CStaticDefenceBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		engaged = false;
+		unit = G-&gt;GetUnit(uid);
+		uid = ((CUnit*)unit.get())-&gt;GetID();
+	}
 
-CStaticDefenceBehaviour::~CStaticDefenceBehaviour(){
-	//
-}
+	CStaticDefenceBehaviour::~CStaticDefenceBehaviour(){
+		//
+	}
 
-bool CStaticDefenceBehaviour::Init(){
-	return true;
-}
+	bool CStaticDefenceBehaviour::Init(){
+		return true;
+	}
 
-void CStaticDefenceBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;update&quot;)){
-		if(engaged){
-			return;
-		}
-		if(EVERY_(120 FRAMES)){
-			
-			float3 pos = G-&gt;GetUnitPos(uid);
-			if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+	void CStaticDefenceBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;update&quot;)){
+			if(engaged){
 				return;
 			}
+			if(EVERY_(120 FRAMES)){
+				
+				float3 pos = G-&gt;GetUnitPos(uid);
+				if(G-&gt;Map-&gt;CheckFloat3(pos)==false){
+					return;
+				}
 
-			engaged = G-&gt;Actions-&gt;AttackNear(uid, 1.0f);
+				engaged = G-&gt;Actions-&gt;AttackNear(uid, 1.0f);
+			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0)== uid){
+				End();
+			}
+		}else if(message.GetType() == string(&quot;unitidle&quot;)){
+			if(message.GetParameter(0)== uid){
+				engaged=false;
+			}
 		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0)== uid){
-			End();
-		}
-	}else if(message.GetType() == string(&quot;unitidle&quot;)){
-		if(message.GetParameter(0)== uid){
-			engaged=false;
-		}
 	}
+
 }
-

Modified: trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/MetalMakerBehaviour.cpp
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/MetalMakerBehaviour.cpp	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/Behaviours/MetalMakerBehaviour.cpp	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,51 +1,53 @@
 #include &quot;../../Core/include.h&quot;
 
-CMetalMakerBehaviour::CMetalMakerBehaviour(Global* GL, int uid){
-	//
-	G = GL;
-	unit = G-&gt;GetUnit(uid);
-	turnedOn = false;
-}
+namespace ntai {
+	CMetalMakerBehaviour::CMetalMakerBehaviour(Global* GL, int uid){
+		//
+		G = GL;
+		unit = G-&gt;GetUnit(uid);
+		turnedOn = false;
+	}
 
-CMetalMakerBehaviour::~CMetalMakerBehaviour(){
-	//
-}
+	CMetalMakerBehaviour::~CMetalMakerBehaviour(){
+		//
+	}
 
-bool CMetalMakerBehaviour::Init(){
-	//
+	bool CMetalMakerBehaviour::Init(){
+		//
 
-	turnedOn = G-&gt;cb-&gt;IsUnitActivated(((CUnit*)unit.get())-&gt;GetID());
-	energyUse=min(((CUnit*)unit.get())-&gt;GetUnitDataType()-&gt;GetUnitDef()-&gt;energyUpkeep,1.0f);
-	return true;
-}
+		turnedOn = G-&gt;cb-&gt;IsUnitActivated(((CUnit*)unit.get())-&gt;GetID());
+		energyUse=min(((CUnit*)unit.get())-&gt;GetUnitDataType()-&gt;GetUnitDef()-&gt;energyUpkeep,1.0f);
+		return true;
+	}
 
-void CMetalMakerBehaviour::RecieveMessage(CMessage &amp;message){
-	if(message.GetType() == string(&quot;update&quot;)){
-		if(EVERY_((1 SECONDS))){
-			float energy=G-&gt;cb-&gt;GetEnergy();
-			float estore=G-&gt;cb-&gt;GetEnergyStorage();
-			if(energy&lt;estore*0.3f){
-				if(turnedOn){
-					TCommand tc(((CUnit*)unit.get())-&gt;GetID(),&quot;assigner:: turnoff&quot;);
-					tc.ID(CMD_ONOFF);
-					tc.Push(0);
-					G-&gt;OrderRouter-&gt;GiveOrder(tc);
-					turnedOn=false;
+	void CMetalMakerBehaviour::RecieveMessage(CMessage &amp;message){
+		if(message.GetType() == string(&quot;update&quot;)){
+			if(EVERY_((1 SECONDS))){
+				float energy=G-&gt;cb-&gt;GetEnergy();
+				float estore=G-&gt;cb-&gt;GetEnergyStorage();
+				if(energy&lt;estore*0.3f){
+					if(turnedOn){
+						TCommand tc(((CUnit*)unit.get())-&gt;GetID(),&quot;assigner:: turnoff&quot;);
+						tc.ID(CMD_ONOFF);
+						tc.Push(0);
+						G-&gt;OrderRouter-&gt;GiveOrder(tc);
+						turnedOn=false;
+					}
+				} else if(energy&gt;estore*0.6f){
+					if(!turnedOn){
+						TCommand tc(((CUnit*)unit.get())-&gt;GetID(),&quot;assigner:: turnon&quot;);
+						tc.ID(CMD_ONOFF);
+						tc.Push(1);
+						G-&gt;OrderRouter-&gt;GiveOrder(tc);
+						turnedOn=true;
+					}
 				}
-			} else if(energy&gt;estore*0.6f){
-				if(!turnedOn){
-					TCommand tc(((CUnit*)unit.get())-&gt;GetID(),&quot;assigner:: turnon&quot;);
-					tc.ID(CMD_ONOFF);
-					tc.Push(1);
-					G-&gt;OrderRouter-&gt;GiveOrder(tc);
-					turnedOn=true;
-				}
 			}
+		}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
+			if(message.GetParameter(0)== ((CUnit*)unit.get())-&gt;GetID()){
+				End();
+			}
 		}
-	}else if(message.GetType() == string(&quot;unitdestroyed&quot;)){
-		if(message.GetParameter(0)== ((CUnit*)unit.get())-&gt;GetID()){
-			End();
-		}
 	}
+
 }
-

Added: trunk/AI/Global/NTai/AI/NTai/Units/CConfigTaskManager.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/CConfigTaskManager.h	                        (rev 0)
+++ trunk/AI/Global/NTai/AI/NTai/Units/CConfigTaskManager.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -0,0 +1,11 @@
+/*
+AF 2004+
+LGPL 2
+*/
+
+namespace ntai {
+	class CConfigTaskManager : public ITaskManager {
+	public:
+		virtual boost::shared_ptr&lt;IModule&gt; GetNextTask();
+	};
+}

Modified: trunk/AI/Global/NTai/AI/NTai/Units/CUnit.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/CUnit.h	2008-03-28 17:49:21 UTC (rev 5617)
+++ trunk/AI/Global/NTai/AI/NTai/Units/CUnit.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -1,5 +1,6 @@
 /*
-AF 2007
+AF 2004+
+LGPL 2
 */
 
 namespace ntai {

Added: trunk/AI/Global/NTai/AI/NTai/Units/ITaskManager.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/ITaskManager.h	                        (rev 0)
+++ trunk/AI/Global/NTai/AI/NTai/Units/ITaskManager.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -0,0 +1,11 @@
+/*
+AF 2004+
+LGPL 2
+*/
+
+namespace ntai {
+	class ITaskManager : public IModule {
+	public:
+		virtual boost::shared_ptr&lt;IModule&gt; GetNextTask() = 0;
+	};
+}

Added: trunk/AI/Global/NTai/AI/NTai/Units/ITaskManagerFactory.h
===================================================================
--- trunk/AI/Global/NTai/AI/NTai/Units/ITaskManagerFactory.h	                        (rev 0)
+++ trunk/AI/Global/NTai/AI/NTai/Units/ITaskManagerFactory.h	2008-03-29 01:51:06 UTC (rev 5618)
@@ -0,0 +1,11 @@
+/*
+AF 2004+
+LGPL 2
+*/
+
+namespace ntai {
+	class ITaskManagerFactory : public IModule {
+	public:
+		virtual boost::shared_ptr&lt;ITaskManager&gt; GetTaskManager(boost::shared_ptr&lt;IModule&gt; unit) = 0;
+	};
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000398.html">[Taspring-linux-commit] r5617 - trunk/AI/Global/KAIK-0.13
</A></li>
	<LI>Next message: <A HREF="000400.html">[Taspring-linux-commit] r5619 - in trunk/AI/Global/NTai/AI: .	NTai/Core NTai/Helpers/Units NTai/Units
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#399">[ date ]</a>
              <a href="thread.html#399">[ thread ]</a>
              <a href="subject.html#399">[ subject ]</a>
              <a href="author.html#399">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
