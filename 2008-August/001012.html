<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6232 - in trunk/rts: Lua Map Map/SM3	Map/SMF Rendering Rendering/Env Sim/Units Sim/Units/UnitTypes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6232%20-%20in%20trunk/rts%3A%20Lua%20Map%20Map/SM3%0A%09Map/SMF%20Rendering%20Rendering/Env%20Sim/Units%20Sim/Units/UnitTypes&In-Reply-To=%3C20080804181920.6F8C64970%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001011.html">
   <LINK REL="Next"  HREF="001013.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6232 - in trunk/rts: Lua Map Map/SM3	Map/SMF Rendering Rendering/Env Sim/Units Sim/Units/UnitTypes</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6232%20-%20in%20trunk/rts%3A%20Lua%20Map%20Map/SM3%0A%09Map/SMF%20Rendering%20Rendering/Env%20Sim/Units%20Sim/Units/UnitTypes&In-Reply-To=%3C20080804181920.6F8C64970%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6232 - in trunk/rts: Lua Map Map/SM3	Map/SMF Rendering Rendering/Env Sim/Units Sim/Units/UnitTypes">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon Aug  4 20:19:20 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001011.html">[Taspring-linux-commit] r6231 - trunk/rts/Map/SMF
</A></li>
        <LI>Next message: <A HREF="001013.html">[Taspring-linux-commit] r6233 - in branches/0.77-branch:	Lobby/TASClient Lobby/TASClient/Python	Lobby/TASClient/Python/scripts rts/Lua	rts/Sim/Units/CommandAI rts/System/Platform/Linux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1012">[ date ]</a>
              <a href="thread.html#1012">[ thread ]</a>
              <a href="subject.html#1012">[ subject ]</a>
              <a href="author.html#1012">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-08-04 20:19:19 +0200 (Mon, 04 Aug 2008)
New Revision: 6232

Modified:
   trunk/rts/Lua/LuaSyncedCtrl.cpp
   trunk/rts/Map/BasicMapDamage.cpp
   trunk/rts/Map/Ground.cpp
   trunk/rts/Map/ReadMap.cpp
   trunk/rts/Map/ReadMap.h
   trunk/rts/Map/SM3/Sm3Map.cpp
   trunk/rts/Map/SM3/Sm3Map.h
   trunk/rts/Map/SMF/SmfReadMap.h
   trunk/rts/Rendering/Env/AdvWater.cpp
   trunk/rts/Rendering/Env/BasicWater.cpp
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/Env/RefractWater.cpp
   trunk/rts/Rendering/GroundDecalHandler.cpp
   trunk/rts/Sim/Units/UnitHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/Sim/Units/UnitTypes/Builder.cpp
Log:
redirect all heightmap writes through SetHeight() and AddHeight() (makes it easier to track the current map height extremes for the water renderers, which use the minheight as an update criterium)

Modified: trunk/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -2562,13 +2562,13 @@
 	int x1, x2, z1, z2;
 	ParseMapParams(L, __FUNCTION__, height, x1, z1, x2, z2);
 
-	float* heightMap = readmap-&gt;GetHeightmap();
 	for (int z = z1; z &lt;= z2; z++) {
 		for (int x = x1; x &lt;= x2; x++) {
 			const int index = (z * (gs-&gt;mapx + 1)) + x;
-			heightMap[index] = height;
+			readmap-&gt;SetHeight(index, height);
 		}
 	}
+
 	mapDamage-&gt;RecalcArea(x1, x2, z1, z2);
 	return 0;
 }
@@ -2583,13 +2583,13 @@
 	int x1, x2, z1, z2;
 	ParseMapParams(L, __FUNCTION__, height, x1, z1, x2, z2);
 
-	float* heightMap = readmap-&gt;GetHeightmap();
 	for (int z = z1; z &lt;= z2; z++) {
 		for (int x = x1; x &lt;= x2; x++) {
 			const int index = (z * (gs-&gt;mapx + 1)) + x;
-			heightMap[index] += height;
+			readmap-&gt;AddHeight(index, height);
 		}
 	}
+
 	mapDamage-&gt;RecalcArea(x1, x2, z1, z2);
 	return 0;
 }
@@ -2604,13 +2604,15 @@
 	int x1, x2, z1, z2;
 	ParseMapParams(L, __FUNCTION__, origFactor, x1, z1, x2, z2);
 
-	float* origMap = readmap-&gt;orgheightmap;
-	float* currMap = readmap-&gt;GetHeightmap();
+	const float* origMap = readmap-&gt;orgheightmap;
+	const float* currMap = readmap-&gt;GetHeightmap();
+
 	if (origFactor == 1.0f) {
 		for (int z = z1; z &lt;= z2; z++) {
 			for (int x = x1; x &lt;= x2; x++) {
-				const int index = (z * (gs-&gt;mapx + 1)) + x;
-				currMap[index] = origMap[index];
+				const int idx = (z * (gs-&gt;mapx + 1)) + x;
+
+				readmap-&gt;SetHeight(idx, origMap[idx]);
 			}
 		}
 	}
@@ -2619,11 +2621,13 @@
 		for (int z = z1; z &lt;= z2; z++) {
 			for (int x = x1; x &lt;= x2; x++) {
 				const int index = (z * (gs-&gt;mapx + 1)) + x;
-				currMap[index] = (origFactor * origMap[index]) +
-				                 (currFactor * currMap[index]);
+				const float ofh = origFactor * origMap[index];
+				const float cfh = currFactor * currMap[index];
+				readmap-&gt;SetHeight(index, ofh + cfh);
 			}
 		}
 	}
+
 	mapDamage-&gt;RecalcArea(x1, x2, z1, z2);
 	return 0;
 }
@@ -2652,8 +2656,7 @@
 	}
 
 	const int index = (z * (gs-&gt;mapx + 1)) + x;
-	float&amp; heightMap = readmap-&gt;GetHeightmap()[index];
-	heightMap += h;
+	const float oldHeight = readmap-&gt;GetHeightmap()[index];
 	heightMapAmountChanged += streflop::fabsf(h);
 
 	// update RecalcArea()
@@ -2662,7 +2665,9 @@
 	if (z &lt; heightMapz1) { heightMapz1 = z; }
 	if (z &gt; heightMapz2) { heightMapz2 = z; }
 
-	lua_pushnumber(L, heightMap);
+	readmap-&gt;AddHeight(index, h);
+	// push the new height
+	lua_pushnumber(L, oldHeight + h);
 	return 1;
 }
 
@@ -2688,17 +2693,17 @@
 	}
 
 	const int index = (z * (gs-&gt;mapx + 1)) + x;
-	float&amp; heightMap = readmap-&gt;GetHeightmap()[index];
-	const float oldHeight = heightMap;
+	const float oldHeight = readmap-&gt;GetHeightmap()[index];
+	float height = oldHeight;
 
 	if (lua_israwnumber(L, 4)) {
 		const float t = lua_tofloat(L, 4);
-		heightMap += (h - heightMap) * t;
+		height += (h - oldHeight) * t;
 	} else{
-		heightMap = h;
+		height = h;
 	}
 
-	const float heightDiff = (heightMap - oldHeight);
+	const float heightDiff = (height - oldHeight);
 	heightMapAmountChanged += streflop::fabsf(heightDiff);
 
 	// update RecalcArea()
@@ -2707,6 +2712,7 @@
 	if (z &lt; heightMapz1) { heightMapz1 = z; }
 	if (z &gt; heightMapz2) { heightMapz2 = z; }
 
+	readmap-&gt;SetHeight(index, height);
 	lua_pushnumber(L, heightDiff);
 	return 1;
 }

Modified: trunk/rts/Map/BasicMapDamage.cpp
===================================================================
--- trunk/rts/Map/BasicMapDamage.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/BasicMapDamage.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -55,96 +55,108 @@
 	delete[] inRelosQue;
 }
 
-void CBasicMapDamage::Explosion(const float3&amp; pos, float strength,float radius)
+void CBasicMapDamage::Explosion(const float3&amp; pos, float strength, float radius)
 {
-	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
-//		logOutput.Print(&quot;Map damage explosion outside map %.0f %.0f&quot;,pos.x,pos.z);
+	if (pos.x &lt; 0.0f || pos.z &lt; 0.0f || pos.x &gt; gs-&gt;mapx * SQUARE_SIZE || pos.z &gt; gs-&gt;mapy * SQUARE_SIZE) {
 		return;
 	}
-	if(strength&lt;10 || radius&lt;8)
+
+	if (strength &lt; 10.0f || radius &lt; 8.0f)
 		return;
 
-	radius*=1.5f;
+	radius *= 1.5f;
 
-	Explo* e=SAFE_NEW Explo;
-	e-&gt;pos=pos;
-	e-&gt;strength=strength;
-	e-&gt;ttl=10;
-	e-&gt;x1=std::max((int)(pos.x-radius)/SQUARE_SIZE,2);
-	e-&gt;x2=std::min((int)(pos.x+radius)/SQUARE_SIZE,gs-&gt;mapx-3);
-	e-&gt;y1=std::max((int)(pos.z-radius)/SQUARE_SIZE,2);
-	e-&gt;y2=std::min((int)(pos.z+radius)/SQUARE_SIZE,gs-&gt;mapy-3);
-	e-&gt;squares.reserve((e-&gt;y2-e-&gt;y1+1)*(e-&gt;x2-e-&gt;x1+1));
+	Explo* e = SAFE_NEW Explo;
+	e-&gt;pos = pos;
+	e-&gt;strength = strength;
+	e-&gt;ttl = 10;
+	e-&gt;x1 = std::max((int) (pos.x - radius) / SQUARE_SIZE,            2);
+	e-&gt;x2 = std::min((int) (pos.x + radius) / SQUARE_SIZE, gs-&gt;mapx - 3);
+	e-&gt;y1 = std::max((int) (pos.z - radius) / SQUARE_SIZE,            2);
+	e-&gt;y2 = std::min((int) (pos.z + radius) / SQUARE_SIZE, gs-&gt;mapy - 3);
+	e-&gt;squares.reserve((e-&gt;y2 - e-&gt;y1 + 1) * (e-&gt;x2 - e-&gt;x1 + 1));
 
-	float* heightmap = readmap-&gt;GetHeightmap();
-	float baseStrength=-pow(strength,0.6f)*3/mapHardness;
-	float invRadius=1.0f/radius;
-	for(int y=e-&gt;y1;y&lt;=e-&gt;y2;++y){
-		for(int x=e-&gt;x1;x&lt;=e-&gt;x2;++x){
+	const float* heightmap = readmap-&gt;GetHeightmap();
+	float baseStrength = -pow(strength, 0.6f) * 3 / mapHardness;
+	float invRadius = 1.0f / radius;
+
+	for (int y = e-&gt;y1; y &lt;= e-&gt;y2; ++y) {
+		for (int x = e-&gt;x1; x &lt;= e-&gt;x2; ++x) {
 			CSolidObject* so = groundBlockingObjectMap-&gt;GroundBlockedUnsafe(y * gs-&gt;mapx + x);
-			// don't change squares with building on them here
+			// don't change squares with buildings on them here
 			if (so &amp;&amp; so-&gt;blockHeightChanges) {
 				e-&gt;squares.push_back(0);
 				continue;
 			}
-			float dist=pos.distance2D(float3(x*SQUARE_SIZE,0,y*SQUARE_SIZE));	//calculate the distance
-			float relDist=dist*invRadius;	//normalize distance
-			float dif=baseStrength*craterTable[int(relDist*200)]*invHardness[readmap-&gt;typemap[(y/2)*gs-&gt;hmapx+x/2]];
 
-			float prevDif=heightmap[y*(gs-&gt;mapx+1)+x]-readmap-&gt;orgheightmap[y*(gs-&gt;mapx+1)+x];
+			// calculate the distance and normalize it
+			float dist = pos.distance2D(float3(x * SQUARE_SIZE, 0, y * SQUARE_SIZE));
+			float relDist = dist * invRadius;
+			float dif =
+				baseStrength * craterTable[int(relDist * 200)] *
+				invHardness[readmap-&gt;typemap[(y / 2) * gs-&gt;hmapx + x / 2]];
 
-//			prevDif+=dif*5;
+			float prevDif = heightmap[y * (gs-&gt;mapx + 1) + x] - readmap-&gt;orgheightmap[y * (gs-&gt;mapx + 1) + x];
 
-			if(prevDif*dif&gt;0)
-				dif/=fabs(prevDif)*0.1f+1;
+			if (prevDif * dif &gt; 0)
+				dif /= fabs(prevDif) * 0.1f + 1;
+
 			e-&gt;squares.push_back(dif);
-			if(dif&lt;-0.3f &amp;&amp; strength&gt;200)
-				treeDrawer-&gt;RemoveGrass(x,y);
+
+			if (dif &lt; -0.3f &amp;&amp; strength &gt; 200)
+				treeDrawer-&gt;RemoveGrass(x, y);
 		}
 	}
+
 	// calculate how much to offset the buildings in the explosion radius with
 	// (while still keeping the ground under them flat)
-	std::vector&lt;CUnit*&gt; units=qf-&gt;GetUnitsExact(pos,radius);
-	for(std::vector&lt;CUnit*&gt;::iterator ui=units.begin();ui!=units.end();++ui){
-		if((*ui)-&gt;blockHeightChanges &amp;&amp; (*ui)-&gt;isMarkedOnBlockingMap){
-			CUnit* unit=*ui;
+	std::vector&lt;CUnit*&gt; units = qf-&gt;GetUnitsExact(pos, radius);
+	for (std::vector&lt;CUnit*&gt;::iterator ui = units.begin(); ui != units.end(); ++ui) {
+		if ((*ui)-&gt;blockHeightChanges &amp;&amp; (*ui)-&gt;isMarkedOnBlockingMap) {
+			CUnit* unit = *ui;
+			float totalDif = 0.0f;
 
-			float totalDif=0;
-			for(int z=unit-&gt;mapPos.y; z&lt;unit-&gt;mapPos.y+unit-&gt;ysize; z++){
-				for(int x=unit-&gt;mapPos.x; x&lt;unit-&gt;mapPos.x+unit-&gt;xsize; x++){
-					float dist=pos.distance2D(float3(x*SQUARE_SIZE,0,z*SQUARE_SIZE));							//calculate the distance
-					float relDist=dist*invRadius;																					//normalize distance
-					float dif=baseStrength*craterTable[int(relDist*200)]*invHardness[readmap-&gt;typemap[(z/2)*gs-&gt;hmapx+x/2]];
-					float prevDif=heightmap[z*(gs-&gt;mapx+1)+x]-readmap-&gt;orgheightmap[z*(gs-&gt;mapx+1)+x];
+			for (int z = unit-&gt;mapPos.y; z &lt; unit-&gt;mapPos.y + unit-&gt;ysize; z++) {
+				for (int x = unit-&gt;mapPos.x; x &lt; unit-&gt;mapPos.x + unit-&gt;xsize; x++) {
+					// calculate the distance and normalize it
+					float dist = pos.distance2D(float3(x * SQUARE_SIZE, 0, z * SQUARE_SIZE));
+					float relDist = dist * invRadius;
+					float dif =
+						baseStrength * craterTable[int(relDist * 200)] *
+						invHardness[readmap-&gt;typemap[(z / 2) * gs-&gt;hmapx + x / 2]];
+					float prevDif = heightmap[z * (gs-&gt;mapx + 1) + x] - readmap-&gt;orgheightmap[z * (gs-&gt;mapx + 1) + x];
 
-					if(prevDif*dif&gt;0)
-						dif/=fabs(prevDif)*0.1f+1;
-					totalDif+=dif;
+					if (prevDif * dif &gt; 0)
+						dif /= fabs(prevDif) * 0.1f + 1;
+
+					totalDif += dif;
 				}
 			}
-			totalDif/=unit-&gt;xsize*unit-&gt;ysize;
-			if(totalDif!=0){
+
+			totalDif /= unit-&gt;xsize * unit-&gt;ysize;
+			if (totalDif != 0) {
 				ExploBuilding eb;
-				eb.id=(*ui)-&gt;id;
-				eb.dif=totalDif;
-				eb.tx1=unit-&gt;mapPos.x;
-				eb.tx2=unit-&gt;mapPos.x+unit-&gt;xsize;
-				eb.tz1=unit-&gt;mapPos.y;
-				eb.tz2=unit-&gt;mapPos.y+unit-&gt;ysize;
+				eb.id = (*ui)-&gt;id;
+				eb.dif = totalDif;
+				eb.tx1 = unit-&gt;mapPos.x;
+				eb.tx2 = unit-&gt;mapPos.x + unit-&gt;xsize;
+				eb.tz1 = unit-&gt;mapPos.y;
+				eb.tz2 = unit-&gt;mapPos.y + unit-&gt;ysize;
 				e-&gt;buildings.push_back(eb);
 			}
 		}
 	}
 
 	explosions.push_back(e);
-
-	readmap-&gt;Explosion(pos.x,pos.z,strength);
+	readmap-&gt;Explosion(pos.x, pos.z, strength);
 }
 
 void CBasicMapDamage::RecalcArea(int x1, int x2, int y1, int y2)
 {
-	float* heightmap = readmap-&gt;GetHeightmap();
+	const float* heightmap = readmap-&gt;GetHeightmap();
 	float* centerheightmap = readmap-&gt;centerheightmap;
+
+	// reads from heightmap, writes to centerheightmap
 	for (int y = y1; y &lt; y2; y++) {
 		for (int x = x1; x &lt; x2; x++) {
 			const float height = heightmap[((y)     * (gs-&gt;mapx + 1)) + (x)    ]
@@ -157,84 +169,91 @@
 
 	float numHeightMipMaps = readmap-&gt;numHeightMipMaps - 1;
 	float** mipHeightmap = readmap-&gt;mipHeightmap;
+
+	// reads from mipHeightmap[i], writes to mipHeightmap[i + 1]
 	for (int i = 0; i &lt; numHeightMipMaps; i++) {
 		int hmapx = gs-&gt;mapx &gt;&gt; i;
 		for (int y = ((y1 &gt;&gt; i) &amp; (~1)); y &lt; (y2 &gt;&gt; i); y += 2) {
 			for (int x = ((x1 &gt;&gt; i) &amp; (~1)); x &lt; (x2 &gt;&gt; i); x += 2) {
-				float height = mipHeightmap[i][(x)+(y)*hmapx];
-				height += mipHeightmap[i][(x)  +(y+1)*hmapx];
-				height += mipHeightmap[i][(x+1)+(y)  *hmapx];
-				height += mipHeightmap[i][(x+1)+(y+1)*hmapx];
-				mipHeightmap[i+1][(x+(y*hmapx)/2)/2] = height * 0.25f;
+				float height = mipHeightmap[i][(x    ) + (y    ) * hmapx];
+				height +=      mipHeightmap[i][(x    ) + (y + 1) * hmapx];
+				height +=      mipHeightmap[i][(x + 1) + (y    ) * hmapx];
+				height +=      mipHeightmap[i][(x + 1) + (y + 1) * hmapx];
+				mipHeightmap[i + 1][(x + (y * hmapx) / 2) / 2] = height * 0.25f;
 			}
 		}
 	}
 
-	int decy=std::max(0,y1-1);
-	int incy=std::min(gs-&gt;mapy-1,y2+1);
-	int decx=std::max(0,x1-1);
-	int incx=std::min(gs-&gt;mapx-1,x2+1);
+	int decy = std::max(           0, y1 - 1);
+	int incy = std::min(gs-&gt;mapy - 1, y2 + 1);
+	int decx = std::max(           0, x1 - 1);
+	int incx = std::min(gs-&gt;mapx - 1, x2 + 1);
 
 	float3* facenormals = readmap-&gt;facenormals;
+
+	// update the normals
 	for (int y = decy; y &lt;= incy; y++) {
 		for (int x = decx; x &lt;= incx; x++) {
-			float3 e1(-SQUARE_SIZE,heightmap[y*(gs-&gt;mapx+1)+x]-heightmap[y*(gs-&gt;mapx+1)+x+1],0);
-			float3 e2( 0,heightmap[y*(gs-&gt;mapx+1)+x]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],-SQUARE_SIZE);
+			float3 e1(-SQUARE_SIZE, heightmap[y * (gs-&gt;mapx + 1) + x] - heightmap[ y      * (gs-&gt;mapx + 1) + x + 1],            0);
+			float3 e2(           0, heightmap[y * (gs-&gt;mapx + 1) + x] - heightmap[(y + 1) * (gs-&gt;mapx + 1) + x    ], -SQUARE_SIZE);
 
-			float3 n=e2.cross(e1);
+			float3 n = e2.cross(e1);
 			n.Normalize();
 
-			facenormals[(y*gs-&gt;mapx+x)*2] = n;
+			facenormals[(y * gs-&gt;mapx + x) * 2] = n;
 
-			e1 = float3( SQUARE_SIZE,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],0);
-			e2 = float3( 0,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y)*(gs-&gt;mapx+1)+x+1],SQUARE_SIZE);
+			e1 = float3( SQUARE_SIZE, heightmap[(y + 1) * (gs-&gt;mapx + 1) + x + 1] - heightmap[(y + 1) * (gs-&gt;mapx + 1) + x    ],           0);
+			e2 = float3(           0, heightmap[(y + 1) * (gs-&gt;mapx + 1) + x + 1] - heightmap[(y    ) * (gs-&gt;mapx + 1) + x + 1], SQUARE_SIZE);
 
 			n = e2.cross(e1);
 			n.Normalize();
 
-			facenormals[(y*gs-&gt;mapx+x)*2+1] = n;
+			facenormals[(y * gs-&gt;mapx + x) * 2 + 1] = n;
 		}
 	}
 
+	// update the slopes
+	const int ss4 = SQUARE_SIZE * 4;
 	float* slopemap = readmap-&gt;slopemap;
-	for(int y = std::max(2,(y1&amp;0xfffffe)); y &lt;= std::min(gs-&gt;mapy-3,y2); y += 2) {
-		for(int x = std::max(2,(x1&amp;0xfffffe)); x &lt;= std::min(gs-&gt;mapx-3,x2); x += 2) {
-			float3 e1(-SQUARE_SIZE*4,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],0);
-			float3 e2( 0,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],-SQUARE_SIZE*4);
+	for (int y = std::max(2, (y1 &amp; 0xfffffe)); y &lt;= std::min(gs-&gt;mapy - 3, y2); y += 2) {
+		for (int x = std::max(2, (x1 &amp; 0xfffffe)); x &lt;= std::min(gs-&gt;mapx - 3, x2); x += 2) {
+			float3 e1(-ss4, heightmap[(y - 1) * (gs-&gt;mapx + 1) + x - 1] - heightmap[(y - 1) * (gs-&gt;mapx + 1) + x + 3],    0);
+			float3 e2(   0, heightmap[(y - 1) * (gs-&gt;mapx + 1) + x - 1] - heightmap[(y + 3) * (gs-&gt;mapx + 1) + x - 1], -ss4);
 
 			float3 n = e2.cross(e1);
 			n.Normalize();
 
-			e1 = float3( SQUARE_SIZE*4,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],0);
-			e2 = float3( 0,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],SQUARE_SIZE*4);
+			e1 = float3(ss4, heightmap[(y + 3) * (gs-&gt;mapx + 1) + x + 3] - heightmap[(y + 3) * (gs-&gt;mapx + 1) + x - 1],   0);
+			e2 = float3(  0, heightmap[(y + 3) * (gs-&gt;mapx + 1) + x + 3] - heightmap[(y - 1) * (gs-&gt;mapx + 1) + x + 3], ss4);
 
 			float3 n2 = e2.cross(e1);
 			n2.Normalize();
 
-			slopemap[(y/2)*gs-&gt;hmapx+(x/2)] = 1-(n.y+n2.y)*0.5f;
+			slopemap[(y / 2) * gs-&gt;hmapx + (x / 2)] = 1.0f - (n.y + n2.y) * 0.5f;
 		}
 	}
 
-	decy = std::max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incy = std::min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
-	decx = std::max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incx = std::min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	decy = std::max(                     0, (y1 * SQUARE_SIZE - QUAD_SIZE / 2) / QUAD_SIZE);
+	incy = std::min(qf-&gt;GetNumQuadsZ() - 1, (y2 * SQUARE_SIZE + QUAD_SIZE / 2) / QUAD_SIZE);
+	decx = std::max(                     0, (x1 * SQUARE_SIZE - QUAD_SIZE / 2) / QUAD_SIZE);
+	incx = std::min(qf-&gt;GetNumQuadsX() - 1, (x2 * SQUARE_SIZE + QUAD_SIZE / 2) / QUAD_SIZE);
 
 	const int numQuadsX = qf-&gt;GetNumQuadsX();
 	const int frameNum  = gs-&gt;frameNum;
 
 	for (int y = decy; y &lt;= incy; y++) {
 		for (int x = decx; x &lt;= incx; x++) {
-			if (inRelosQue[y*numQuadsX+x]) {
+			if (inRelosQue[y * numQuadsX + x]) {
 				continue;
 			}
+
 			RelosSquare rs;
 			rs.x = x;
 			rs.y = y;
 			rs.neededUpdate = frameNum;
 			rs.numUnits = qf-&gt;GetQuadAt(x, y).units.size();
 			relosSize += rs.numUnits;
-			inRelosQue[y*numQuadsX+x] = true;
+			inRelosQue[y * numQuadsX + x] = true;
 			relosQue.push_back(rs);
 		}
 	}
@@ -252,80 +271,88 @@
 	SCOPED_TIMER(&quot;Map damage&quot;);
 
 	std::deque&lt;Explo*&gt;::iterator ei;
-	float* heightmap=readmap-&gt;GetHeightmap();
 
-	for(ei=explosions.begin();ei!=explosions.end();++ei){
-		Explo* e=*ei;
-		if (e-&gt;ttl&lt;=0) continue;
+	for (ei = explosions.begin(); ei != explosions.end(); ++ei) {
+		Explo* e = *ei;
+		if (e-&gt;ttl &lt;= 0) continue;
 		--e-&gt;ttl;
 
-		int x1=e-&gt;x1;
-		int x2=e-&gt;x2;
-		int y1=e-&gt;y1;
-		int y2=e-&gt;y2;
-		std::vector&lt;float&gt;::iterator si=e-&gt;squares.begin();
-		for(int y=y1;y&lt;=y2;++y){
-			for(int x=x1;x&lt;=x2;++x){
-				float dif=*(si++);
-				heightmap[y*(gs-&gt;mapx+1)+x]+=dif;
+		int x1 = e-&gt;x1;
+		int x2 = e-&gt;x2;
+		int y1 = e-&gt;y1;
+		int y2 = e-&gt;y2;
+		std::vector&lt;float&gt;::iterator si = e-&gt;squares.begin();
+
+		for (int y = y1; y &lt;= y2; ++y) {
+			for (int x = x1; x&lt;= x2; ++x) {
+				float dif = *(si++);
+
+				readmap-&gt;AddHeight(y * (gs-&gt;mapx + 1) + x, dif);
 			}
 		}
-		for(std::vector&lt;ExploBuilding&gt;::iterator bi=e-&gt;buildings.begin();bi!=e-&gt;buildings.end();++bi){
-			float dif=bi-&gt;dif;
+		for (std::vector&lt;ExploBuilding&gt;::iterator bi = e-&gt;buildings.begin(); bi != e-&gt;buildings.end(); ++bi) {
+			float dif = bi-&gt;dif;
 			int tx1 = bi-&gt;tx1;
 			int tx2 = bi-&gt;tx2;
 			int tz1 = bi-&gt;tz1;
 			int tz2 = bi-&gt;tz2;
 
-			for(int z=tz1; z&lt;tz2; z++){
-				for(int x=tx1; x&lt;tx2; x++){
-					heightmap[z*(gs-&gt;mapx+1)+x]+=dif;
+			for (int z = tz1; z &lt; tz2; z++) {
+				for (int x = tx1; x &lt; tx2; x++) {
+					readmap-&gt;AddHeight(z * (gs-&gt;mapx + 1) + x, dif);
 				}
 			}
-			CUnit* unit=uh-&gt;units[bi-&gt;id];
-			if(unit){
-				unit-&gt;pos.y+=dif;
-				unit-&gt;midPos.y+=dif;
+
+			CUnit* unit = uh-&gt;units[bi-&gt;id];
+			if (unit) {
+				unit-&gt;pos.y += dif;
+				unit-&gt;midPos.y += dif;
 			}
 		}
-		if(e-&gt;ttl==0){
-			RecalcArea(x1-2,x2+2,y1-2,y2+2);
+		if (e-&gt;ttl == 0) {
+			RecalcArea(x1 - 2, x2 + 2, y1 - 2, y2 + 2);
 		}
 	}
-	while(!explosions.empty() &amp;&amp; explosions.front()-&gt;ttl==0){
+
+	while (!explosions.empty() &amp;&amp; explosions.front()-&gt;ttl == 0) {
 		delete explosions.front();
 		explosions.pop_front();
 	}
+
 	UpdateLos();
 }
 
 void CBasicMapDamage::UpdateLos(void)
 {
-	int updateSpeed=(int)(relosSize*0.01f)+1;
+	int updateSpeed = (int) (relosSize * 0.01f) + 1;
 
-	if(relosUnits.empty()){
-		if(relosQue.empty())
+	if (relosUnits.empty()) {
+		if (relosQue.empty())
 			return;
-		RelosSquare* rs=&amp;relosQue.front();
 
+		RelosSquare* rs = &amp;relosQue.front();
 		const std::list&lt;CUnit*&gt;&amp; units = qf-&gt;GetQuadAt(rs-&gt;x, rs-&gt;y).units;
+
 		for (std::list&lt;CUnit*&gt;::const_iterator ui = units.begin(); ui != units.end(); ++ui) {
 			relosUnits.push_back((*ui)-&gt;id);
 		}
-		relosSize-=rs-&gt;numUnits;
-		neededLosUpdate=rs-&gt;neededUpdate;
-		inRelosQue[rs-&gt;y*qf-&gt;GetNumQuadsX()+rs-&gt;x]=false;
+		relosSize -= rs-&gt;numUnits;
+		neededLosUpdate = rs-&gt;neededUpdate;
+		inRelosQue[rs-&gt;y * qf-&gt;GetNumQuadsX() + rs-&gt;x] = false;
 		relosQue.pop_front();
 	}
-	for(int a=0;a&lt;updateSpeed;++a){
-		if(relosUnits.empty())
+
+	for (int a = 0; a &lt; updateSpeed; ++a) {
+		if (relosUnits.empty())
 			return;
-		CUnit* u=uh-&gt;units[relosUnits.front()];
+
+		CUnit* u = uh-&gt;units[relosUnits.front()];
 		relosUnits.pop_front();
 
-		if(u==0 || u-&gt;lastLosUpdate&gt;=neededLosUpdate){
+		if (u == 0 || u-&gt;lastLosUpdate &gt;= neededLosUpdate) {
 			continue;
 		}
-		loshandler-&gt;MoveUnit(u,true);
+
+		loshandler-&gt;MoveUnit(u, true);
 	}
 }

Modified: trunk/rts/Map/Ground.cpp
===================================================================
--- trunk/rts/Map/Ground.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/Ground.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -29,69 +29,88 @@
 void CGround::CheckCol(CProjectileHandler* ph)
 {
 	Projectile_List::iterator psi;
-//	int x,y;
-	for(psi=ph-&gt;ps.begin();psi != ph-&gt;ps.end();++psi){
-		CProjectile* p=*psi;
-		if(p-&gt;checkCol){
-			if(GetHeight(p-&gt;pos.x,p-&gt;pos.z) &gt; p-&gt;pos.y/*-p-&gt;radius*/)		//too many projectiles seems to hit the ground before hitting so remove the radius till a better fix is done
+
+	for (psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
+		CProjectile* p = *psi;
+		if (p-&gt;checkCol) {
+			if (GetHeight(p-&gt;pos.x, p-&gt;pos.z) &gt; p-&gt;pos.y /* - p-&gt;radius*/) {
+				// too many projectiles seem to hit the ground before hitting
+				// so remove the radius till a better fix is done
 				p-&gt;Collision();
-/*			x=(int)floor((*psi)-&gt;pos.x*1.0f/SQUARE_SIZE);
-			y=(int)floor((*psi)-&gt;pos.z*1.0f/SQUARE_SIZE);
-			CheckColSquare(*psi,x,y);
-*/		}
+			}
+		}
 	}
 }
 
-void CGround::CheckColSquare(CProjectile* p,int x,int y)
+void CGround::CheckColSquare(CProjectile* p, int x, int y)
 {
-	if(!(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; x&lt;gs-&gt;mapx &amp;&amp; y&lt;gs-&gt;mapy))
+	if (!(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; gs-&gt;mapx &amp;&amp; y &lt; gs-&gt;mapy))
 		return;
-	float xp=p-&gt;pos.x;
-	float yp=p-&gt;pos.y;
-	float zp=p-&gt;pos.z;
 
-	float* hm = readmap-&gt;GetHeightmap();
-	float xt=x*SQUARE_SIZE;
-	float yt=y*SQUARE_SIZE;
-	if (((xp-xt)*readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2].x+(yp-hm[y*(gs-&gt;mapx+1)+x])*readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2].y+(zp-yt)*readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2].z&lt;=p-&gt;radius) &amp;&amp;
-		/*(xp-xt+p-&gt;radius&gt;0) &amp;&amp; (zp-yt+p-&gt;radius&gt;0) &amp;&amp;*/ (xp+zp-xt-yt-p-&gt;radius&lt;SQUARE_SIZE)){
+	float xp = p-&gt;pos.x;
+	float yp = p-&gt;pos.y;
+	float zp = p-&gt;pos.z;
+
+	const float* hm = readmap-&gt;GetHeightmap();
+	const float3* fn = readmap-&gt;facenormals;
+	const int hmIdx = (y * gs-&gt;mapx + x);
+	const float xt = x * SQUARE_SIZE;
+	const float yt0 = hm[ y      * (gs-&gt;mapx + 1) + x    ];
+	const float yt1 = hm[(y + 1) * (gs-&gt;mapx + 1) + x + 1];
+	const float zt = y * SQUARE_SIZE;
+
+	const float dx0 = (xp -  xt     ), fnx0 = fn[hmIdx * 2    ].x;
+	const float dy0 = (yp -  yt0    ), fny0 = fn[hmIdx * 2    ].y;
+	const float dz0 = (zp -  zt     ), fnz0 = fn[hmIdx * 2    ].z;
+	const float dx1 = (xp - (xt + 2)), fnx1 = fn[hmIdx * 2 + 1].x;
+	const float dy1 = (yp -  yt1    ), fny1 = fn[hmIdx * 2 + 1].y;
+	const float dz1 = (zp - (zt + 2)), fnz1 = fn[hmIdx * 2 + 1].z;
+	const float d0 = dx0 * fnx0 + dy0 * fny0 + dz0 * fnz0;
+	const float d1 = dx1 * fnx1 + dy1 * fny1 + dz1 * fnz1;
+	const float s0 = xp + zp - xt - zt - p-&gt;radius;
+	const float s1 = xp + zp - xt - zt - SQUARE_SIZE * 2 + p-&gt;radius;
+
+	if ((d0 &lt;= p-&gt;radius) &amp;&amp; (s0 &lt; SQUARE_SIZE)) {
 		p-&gt;Collision();
 	}
-	if (((xp-(xt+2))*readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2+1].x+(yp-hm[(y+1)*(gs-&gt;mapx+1)+x+1])*readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2+1].y+(zp-(yt+2))*readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2+1].z&lt;=p-&gt;radius) &amp;&amp;
-		/*(xp-(xt+2)-p-&gt;radius&lt;0) &amp;&amp; (zp-(yt+2)-p-&gt;radius&lt;0) &amp;&amp;*/ (xp+zp-xt-yt-SQUARE_SIZE*2+p-&gt;radius&gt;-SQUARE_SIZE)){
+	if ((d1 &lt;= p-&gt;radius) &amp;&amp; (s1 &gt; -SQUARE_SIZE)) {
 		p-&gt;Collision();
 	}
+
 	return;
 }
+
 float CGround::LineGroundCol(float3 from, float3 to)
 {
-	float savedLength=0;
-	if(from.z&gt;float3::maxzpos &amp;&amp; to.z&lt;float3::maxzpos){		//a special case since the camera in overhead mode can often do this
-		float3 dir=to-from;
-		float maxLength=dir.Length();
-		dir/=maxLength;
+	float savedLength = 0.0f;
 
-		savedLength=-(from.z-float3::maxzpos)/dir.z;
+	if (from.z &gt; float3::maxzpos &amp;&amp; to.z &lt; float3::maxzpos) {
+		// a special case since the camera in overhead mode can often do this
+		float3 dir = to - from;
+		float maxLength = dir.Length();
+		dir /= maxLength;
 
-		from+=dir*savedLength;
+		savedLength = -(from.z - float3::maxzpos) / dir.z;
+		from += dir * savedLength;
 	}
+
 	from.CheckInBounds();
 
-	float3 dir=to-from;
-	float maxLength=dir.Length();
-	dir/=maxLength;
+	float3 dir = to - from;
+	float maxLength = dir.Length();
+	dir /= maxLength;
 
-	if(from.x+dir.x*maxLength&lt;1)
-		maxLength=(1-from.x)/dir.x;
-	else if(from.x+dir.x*maxLength&gt;float3::maxxpos)
-		maxLength=(float3::maxxpos-from.x)/dir.x;
+	if (from.x + dir.x * maxLength &lt; 1.0f)
+		maxLength = (1.0f - from.x) / dir.x;
+	else if (from.x + dir.x * maxLength &gt; float3::maxxpos)
+		maxLength = (float3::maxxpos - from.x) / dir.x;
 
-	if(from.z+dir.z*maxLength&lt;1)
-		maxLength=(1-from.z)/dir.z;
-	else if(from.z+dir.z*maxLength&gt;float3::maxzpos)
-		maxLength=(float3::maxzpos-from.z)/dir.z;
+	if (from.z + dir.z * maxLength &lt; 1.0f)
+		maxLength = (1.0f - from.z) / dir.z;
+	else if (from.z + dir.z * maxLength &gt; float3::maxzpos)
+		maxLength = (float3::maxzpos - from.z) / dir.z;
 
-	to=from+dir*maxLength;
+	to = from + dir * maxLength;
 
 	const float dx=to.x-from.x;
 	const float dz=to.z-from.z;
@@ -184,50 +203,56 @@
 	return -1;
 }
 
-float CGround::LineGroundSquareCol(const float3 &amp;from,const float3 &amp;to,int xs,int ys)
+float CGround::LineGroundSquareCol(const float3&amp; from, const float3&amp; to, int xs, int ys)
 {
-	if((xs&lt;0) || (ys&lt;0) || (xs&gt;=gs-&gt;mapx-1) || (ys&gt;=gs-&gt;mapy-1))
+	if ((xs &lt; 0) || (ys &lt; 0) || (xs &gt;= gs-&gt;mapx - 1) || (ys &gt;= gs-&gt;mapy - 1))
 		return -1;
 
-	float3 dir=to-from;
+	float3 dir = to - from;
 	float3 tri;
-	//triangel 1
-	tri.x=xs*SQUARE_SIZE;
-	tri.z=ys*SQUARE_SIZE;
-	float* heightmap=readmap-&gt;GetHeightmap();
-	tri.y=heightmap[ys*(gs-&gt;mapx+1)+xs];
 
-	float3 norm=readmap-&gt;facenormals[(ys*gs-&gt;mapx+xs)*2];
-	float side1=(from-tri).dot(norm);
-	float side2=(to-tri).dot(norm);
+	// triangle 1
+	tri.x = xs * SQUARE_SIZE;
+	tri.z = ys * SQUARE_SIZE;
+	const float* heightmap = readmap-&gt;GetHeightmap();
+	tri.y = heightmap[ys * (gs-&gt;mapx + 1) + xs];
 
-	if(side2&lt;=0){				//linjen passerar triangelns plan?
-		float dif=side1-side2;
-		if(dif!=0){
-			float frontpart=side1/dif;
-			float3 col=from+(dir*frontpart);
+	float3 norm = readmap-&gt;facenormals[(ys * gs-&gt;mapx + xs) * 2];
+	float side1 = (from - tri).dot(norm);
+	float side2 = (to - tri).dot(norm);
 
-			if((col.x&gt;=tri.x) &amp;&amp; (col.z&gt;=tri.z) &amp;&amp; (col.x+col.z&lt;=tri.x+tri.z+SQUARE_SIZE)){	//kollision inuti triangeln (utnyttja trianglarnas &quot;2d aktighet&quot;)
+	if (side2 &lt;= 0) {
+		// linjen passerar triangelns plan?
+		float dif = side1 - side2;
+		if (dif != 0) {
+			float frontpart = side1 / dif;
+			float3 col = from + (dir * frontpart);
+
+			if ((col.x &gt;= tri.x) &amp;&amp; (col.z &gt;= tri.z) &amp;&amp; (col.x + col.z &lt;= tri.x + tri.z + SQUARE_SIZE)) {
+				// kollision inuti triangeln (utnyttja trianglarnas &quot;2d aktighet&quot;)
 				return col.distance(from);
 			}
 		}
 	}
-	//triangel 2
-	tri.x=(xs+1)*SQUARE_SIZE;
-	tri.z=(ys+1)*SQUARE_SIZE;
-	tri.y=heightmap[(ys+1)*(gs-&gt;mapx+1)+xs+1];
 
-	norm=readmap-&gt;facenormals[(ys*gs-&gt;mapx+xs)*2+1];
-	side1=(from-tri).dot(norm);
-	side2=(to-tri).dot(norm);
+	// triangle 2
+	tri.x = (xs + 1) * SQUARE_SIZE;
+	tri.z = (ys + 1) * SQUARE_SIZE;
+	tri.y = heightmap[(ys + 1) * (gs-&gt;mapx + 1) + xs + 1];
 
-	if(side2&lt;=0){				//linjen passerar triangelns plan?
-		float dif=side1-side2;
-		if(dif!=0){
-			float frontpart=side1/dif;
-			float3 col=from+(dir*frontpart);
+	norm = readmap-&gt;facenormals[(ys * gs-&gt;mapx + xs) * 2 + 1];
+	side1 = (from - tri).dot(norm);
+	side2 = (to - tri).dot(norm);
 
-			if((col.x&lt;=tri.x) &amp;&amp; (col.z&lt;=tri.z) &amp;&amp; (col.x+col.z&gt;=tri.x+tri.z-SQUARE_SIZE)){	//kollision inuti triangeln (utntri.ytja trianglarnas &quot;2d aktighet&quot;)
+	if (side2 &lt;= 0) {
+		// linjen passerar triangelns plan?
+		float dif = side1 - side2;
+		if (dif != 0) {
+			float frontpart = side1 / dif;
+			float3 col = from + (dir * frontpart);
+
+			if ((col.x &lt;= tri.x) &amp;&amp; (col.z &lt;= tri.z) &amp;&amp; (col.x + col.z &gt;= tri.x + tri.z - SQUARE_SIZE)) {
+				// kollision inuti triangeln (utntri.ytja trianglarnas &quot;2d aktighet&quot;)
 				return col.distance(from);
 			}
 		}
@@ -235,104 +260,106 @@
 	return -2;
 }
 
-float CGround::GetApproximateHeight(float x,float y)
+float CGround::GetApproximateHeight(float x, float y)
 {
-	int xsquare=int(x)/SQUARE_SIZE;
-	int ysquare=int(y)/SQUARE_SIZE;
-	if(xsquare&lt;0)
-		xsquare=0;
-	else if(xsquare&gt;gs-&gt;mapx-1)
-		xsquare=gs-&gt;mapx-1;
-	if(ysquare&lt;0)
-		ysquare=0;
-	else if(ysquare&gt;gs-&gt;mapy-1)
-		ysquare=gs-&gt;mapy-1;
-	return readmap-&gt;centerheightmap[xsquare+ysquare*gs-&gt;mapx];
+	int xsquare = int(x) / SQUARE_SIZE;
+	int ysquare = int(y) / SQUARE_SIZE;
+
+	if (xsquare &lt; 0)
+		xsquare = 0;
+	else if (xsquare &gt; gs-&gt;mapx - 1)
+		xsquare = gs-&gt;mapx - 1;
+	if (ysquare &lt; 0)
+		ysquare = 0;
+	else if (ysquare &gt; gs-&gt;mapy - 1)
+		ysquare = gs-&gt;mapy - 1;
+
+	return readmap-&gt;centerheightmap[xsquare + ysquare * gs-&gt;mapx];
 }
 
 float CGround::GetHeight(float x, float y)
 {
 	float r = GetHeight2(x, y);
-	if(r&lt;0)
-		r=0;
-	return r;
+	return (r &lt; 0.0f? 0.0f: r);
 }
 
 float CGround::GetHeight2(float x, float y)
 {
-	if(x&lt;1)
-		x=1;
-	else if(x&gt;float3::maxxpos)
-		x=float3::maxxpos;
+	if (x &lt; 1)
+		x = 1;
+	else if (x &gt; float3::maxxpos)
+		x = float3::maxxpos;
 
-	if(y&lt;1)
-		y=1;
-	else if(y&gt;float3::maxzpos)
-		y=float3::maxzpos;
+	if (y &lt; 1)
+		y = 1;
+	else if (y &gt; float3::maxzpos)
+		y = float3::maxzpos;
 
-	float r;
-	int sx=(int) (x/SQUARE_SIZE);
-	int sy=(int) (y/SQUARE_SIZE);
-	float dx=(x-sx*SQUARE_SIZE)*(1.0f/SQUARE_SIZE);
-	float dy=(y-sy*SQUARE_SIZE)*(1.0f/SQUARE_SIZE);
-	int hs=sx+sy*(gs-&gt;mapx+1);
-	float* heightmap = readmap-&gt;GetHeightmap();
-	if(dx+dy&lt;1){
-		float xdif=(dx)*(heightmap[hs+1]-heightmap[hs]);
-		float ydif=(dy)*(heightmap[hs+gs-&gt;mapx+1]-heightmap[hs]);
-		r=heightmap[hs]+xdif+ydif;
+	float r = 0.0f;
+	int sx = (int) (x / SQUARE_SIZE);
+	int sy = (int) (y / SQUARE_SIZE);
+	float dx = (x - sx * SQUARE_SIZE) * (1.0f / SQUARE_SIZE);
+	float dy = (y - sy * SQUARE_SIZE) * (1.0f / SQUARE_SIZE);
+	int hs = sx + sy * (gs-&gt;mapx + 1);
+	const float* heightmap = readmap-&gt;GetHeightmap();
+
+	if (dx + dy &lt; 1) {
+		float xdif = (dx) * (heightmap[hs +            1] - heightmap[hs]);
+		float ydif = (dy) * (heightmap[hs + gs-&gt;mapx + 1] - heightmap[hs]);
+		r = heightmap[hs] + xdif + ydif;
 	} else {
-		float xdif=(1-dx)*(heightmap[hs+gs-&gt;mapx+1]-heightmap[hs+1+1+gs-&gt;mapx]);
-		float ydif=(1-dy)*(heightmap[hs+1]-heightmap[hs+1+1+gs-&gt;mapx]);
-		r=heightmap[hs+1+1+gs-&gt;mapx]+xdif+ydif;
+		float xdif = (1.0f - dx) * (heightmap[hs + gs-&gt;mapx + 1] - heightmap[hs + 1 + 1 + gs-&gt;mapx]);
+		float ydif = (1.0f - dy) * (heightmap[hs            + 1] - heightmap[hs + 1 + 1 + gs-&gt;mapx]);
+		r = heightmap[hs + 1 + 1 + gs-&gt;mapx] + xdif + ydif;
 	}
 	return r;
 }
 
 float CGround::GetOrigHeight(float x, float y)
 {
-	if(x&lt;1)
-		x=1;
-	else if(x&gt;float3::maxxpos)
-		x=float3::maxxpos;
+	if (x &lt; 1)
+		x = 1;
+	else if (x &gt; float3::maxxpos)
+		x = float3::maxxpos;
 
-	if(y&lt;1)
-		y=1;
-	else if(y&gt;float3::maxzpos)
-		y=float3::maxzpos;
+	if (y &lt; 1)
+		y = 1;
+	else if (y &gt; float3::maxzpos)
+		y = float3::maxzpos;
 
-	float r;
-	int sx=(int) (x/SQUARE_SIZE);
-	int sy=(int) (y/SQUARE_SIZE);
-	float dx=(x-sx*SQUARE_SIZE)*(1.0f/SQUARE_SIZE);
-	float dy=(y-sy*SQUARE_SIZE)*(1.0f/SQUARE_SIZE);
-	int hs=sx+sy*(gs-&gt;mapx+1);
-	float* heightmap = readmap-&gt;orgheightmap;
-	if(dx+dy&lt;1){
-		float xdif=(dx)*(heightmap[hs+1]-heightmap[hs]);
-		float ydif=(dy)*(heightmap[hs+gs-&gt;mapx+1]-heightmap[hs]);
-		r=heightmap[hs]+xdif+ydif;
+	float r = 0.0f;
+	int sx = (int) (x / SQUARE_SIZE);
+	int sy = (int) (y / SQUARE_SIZE);
+	float dx = (x - sx * SQUARE_SIZE) * (1.0f / SQUARE_SIZE);
+	float dy = (y - sy * SQUARE_SIZE) * (1.0f / SQUARE_SIZE);
+	int hs = sx + sy * (gs-&gt;mapx + 1);
+	const float* orgheightmap = readmap-&gt;orgheightmap;
+
+	if (dx + dy &lt; 1) {
+		float xdif = (dx) * (orgheightmap[hs +            1] - orgheightmap[hs]);
+		float ydif = (dy) * (orgheightmap[hs + gs-&gt;mapx + 1] - orgheightmap[hs]);
+		r = orgheightmap[hs] + xdif + ydif;
 	} else {
-		float xdif=(1-dx)*(heightmap[hs+gs-&gt;mapx+1]-heightmap[hs+1+1+gs-&gt;mapx]);
-		float ydif=(1-dy)*(heightmap[hs+1]-heightmap[hs+1+1+gs-&gt;mapx]);
-		r=heightmap[hs+1+1+gs-&gt;mapx]+xdif+ydif;
+		float xdif = (1 - dx) * (orgheightmap[hs + gs-&gt;mapx + 1] - orgheightmap[hs + 1 + 1 + gs-&gt;mapx]);
+		float ydif = (1 - dy) * (orgheightmap[hs +            1] - orgheightmap[hs + 1 + 1 + gs-&gt;mapx]);
+		r = orgheightmap[hs + 1 + 1 + gs-&gt;mapx] + xdif + ydif;
 	}
 	return r;
 }
 
 float3&amp; CGround::GetNormal(float x, float y)
 {
-	if(x&lt;1)
-		x=1;
-	else if(x&gt;float3::maxxpos)
-		x=float3::maxxpos;
+	if (x &lt; 1.0f)
+		x = 1.0f;
+	else if (x &gt; float3::maxxpos)
+		x = float3::maxxpos;
 
-	if(y&lt;1)
-		y=1;
-	else if(y&gt;float3::maxzpos)
-		y=float3::maxzpos;
+	if (y &lt; 1.0f)
+		y = 1.0f;
+	else if (y &gt; float3::maxzpos)
+		y = float3::maxzpos;
 
-	return readmap-&gt;facenormals[(int(x)/SQUARE_SIZE+int(y)/SQUARE_SIZE*gs-&gt;mapx)*2];
+	return readmap-&gt;facenormals[(int(x) / SQUARE_SIZE + int(y) / SQUARE_SIZE * gs-&gt;mapx) * 2];
 }
 /*
 float CGround::GetApproximateHeight(float x, float y)
@@ -344,65 +371,68 @@
 */
 float CGround::GetSlope(float x, float y)
 {
-	if(x&lt;1)
-		x=1;
-	else if(x&gt;float3::maxxpos)
-		x=float3::maxxpos;
+	if (x &lt; 1.0f)
+		x = 1.0f;
+	else if (x &gt; float3::maxxpos)
+		x = float3::maxxpos;
 
-	if(y&lt;1)
-		y=1;
-	else if(y&gt;float3::maxzpos)
-		y=float3::maxzpos;
+	if (y &lt; 1.0f)
+		y = 1.0f;
+	else if (y &gt; float3::maxzpos)
+		y = float3::maxzpos;
 
-	return 1-readmap-&gt;facenormals[(int(x)/SQUARE_SIZE+int(y)/SQUARE_SIZE*gs-&gt;mapx)*2].y;
+	return (1.0f - readmap-&gt;facenormals[(int(x) / SQUARE_SIZE + int(y) / SQUARE_SIZE * gs-&gt;mapx) * 2].y);
 }
 
 
 float3 CGround::GetSmoothNormal(float x, float y)
 {
-	int sx=(int)floor(x/SQUARE_SIZE);
-	int sy=(int)floor(y/SQUARE_SIZE);
+	int sx = (int) floor(x / SQUARE_SIZE);
+	int sy = (int) floor(y / SQUARE_SIZE);
 
-	if(sy&lt;1)
-		sy=1;
-	if(sx&lt;1)
-		sx=1;
-	if(sy&gt;=gs-&gt;mapy-1)
-		sy=gs-&gt;mapy-2;
-	if(sx&gt;=gs-&gt;mapx-1)
-		sx=gs-&gt;mapx-2;
+	if (sy &lt; 1)
+		sy = 1;
+	if (sx &lt; 1)
+		sx = 1;
+	if (sy &gt;= gs-&gt;mapy - 1)
+		sy = gs-&gt;mapy - 2;
+	if (sx &gt;= gs-&gt;mapx - 1)
+		sx = gs-&gt;mapx - 2;
 
-	float dx=(x-sx*SQUARE_SIZE)/SQUARE_SIZE;
-	float dy=(y-sy*SQUARE_SIZE)/SQUARE_SIZE;
+	float dx = (x - sx * SQUARE_SIZE) / SQUARE_SIZE;
+	float dy = (y - sy * SQUARE_SIZE) / SQUARE_SIZE;
 
 	int sy2;
 	float fy;
-	if(dy&gt;0.5f){
-		sy2=sy+1;
-		fy=dy-0.5f;
+
+	if (dy &gt; 0.5f) {
+		sy2 = sy + 1;
+		fy = dy - 0.5f;
 	} else {
-		sy2=sy-1;
-		fy=0.5f-dy;
+		sy2 = sy - 1;
+		fy = 0.5f - dy;
 	}
+
 	int sx2;
 	float fx;
-	if(dx&gt;0.5f){
-		sx2=sx+1;
-		fx=dx-0.5f;
+
+	if (dx &gt; 0.5f) {
+		sx2 = sx + 1;
+		fx = dx - 0.5f;
 	} else {
-		sx2=sx-1;
-		fx=0.5f-dx;
+		sx2 = sx - 1;
+		fx = 0.5f - dx;
 	}
 
-	float ify=1-fy;
-	float ifx=1-fx;
+	float ify = 1.0f - fy;
+	float ifx = 1.0f - fx;
 
-	float3 n1=(readmap-&gt;facenormals[(sy*gs-&gt;mapx+sx)*2]+readmap-&gt;facenormals[(sy*gs-&gt;mapx+sx)*2+1])*ifx*ify;
-	float3 n2=(readmap-&gt;facenormals[(sy*gs-&gt;mapx+sx2)*2]+readmap-&gt;facenormals[(sy*gs-&gt;mapx+sx2)*2+1])*fx*ify;
-	float3 n3=(readmap-&gt;facenormals[((sy2)*gs-&gt;mapx+sx)*2]+readmap-&gt;facenormals[((sy2)*gs-&gt;mapx+sx)*2+1])*ifx*fy;
-	float3 n4=(readmap-&gt;facenormals[((sy2)*gs-&gt;mapx+sx2)*2]+readmap-&gt;facenormals[((sy2)*gs-&gt;mapx+sx2)*2+1])*fx*fy;
+	float3 n1 = (readmap-&gt;facenormals[ (sy   * gs-&gt;mapx + sx ) * 2] + readmap-&gt;facenormals[( sy   * gs-&gt;mapx + sx ) * 2 + 1]) * ifx * ify;
+	float3 n2 = (readmap-&gt;facenormals[ (sy   * gs-&gt;mapx + sx2) * 2] + readmap-&gt;facenormals[( sy   * gs-&gt;mapx + sx2) * 2 + 1]) *  fx * ify;
+	float3 n3 = (readmap-&gt;facenormals[((sy2) * gs-&gt;mapx + sx ) * 2] + readmap-&gt;facenormals[((sy2) * gs-&gt;mapx + sx ) * 2 + 1]) * ifx * fy;
+	float3 n4 = (readmap-&gt;facenormals[((sy2) * gs-&gt;mapx + sx2) * 2] + readmap-&gt;facenormals[((sy2) * gs-&gt;mapx + sx2) * 2 + 1]) *  fx * fy;
 
-	float3 norm1=n1+n2+n3+n4;
+	float3 norm1 = n1 + n2 + n3 + n4;
 	norm1.Normalize();
 
 	return norm1;
@@ -412,16 +442,15 @@
 {
 	from.CheckInBounds();
 
-	float3 dir(flatdir.x,linear,flatdir.z);
-//	float3 oldpos=from;
-	for(float l=0;l&lt;length;l+=8){
-		float3 pos(from+dir*l);
-		pos.y+=quadratic*l*l;
-		if(GetApproximateHeight(pos.x,pos.z)&gt;pos.y){
+	float3 dir(flatdir.x, linear, flatdir.z);
+
+	for (float l = 0.0f; l &lt; length; l += 8.0f) {
+		float3 pos(from + dir * l);
+		pos.y += quadratic * l * l;
+
+		if (GetApproximateHeight(pos.x, pos.z) &gt; pos.y) {
 			return l;
 		}
-//		geometricObjects-&gt;AddLine(pos,oldpos,3,0,16);
-//		oldpos=pos;
 	}
 	return -1;
 }

Modified: trunk/rts/Map/ReadMap.cpp
===================================================================
--- trunk/rts/Map/ReadMap.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/ReadMap.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -115,11 +115,12 @@
 
 void CReadMap::Serialize(creg::ISerializer&amp; s)
 {
-	float *hm = GetHeightmap();
-	s.Serialize(hm, 4 * (gs-&gt;mapx+1) * (gs-&gt;mapy+1));
+	// remove the const
+	float* hm = (float*) GetHeightmap();
+	s.Serialize(hm, 4 * (gs-&gt;mapx + 1) * (gs-&gt;mapy + 1));
 
 	if (!s.IsWriting())
-		mapDamage-&gt;RecalcArea(2,gs-&gt;mapx-3,2,gs-&gt;mapy-3);
+		mapDamage-&gt;RecalcArea(2, gs-&gt;mapx - 3, 2, gs-&gt;mapy - 3);
 }
 
 void CReadMap::Initialize()
@@ -143,7 +144,7 @@
 
 void CReadMap::CalcHeightfieldData()
 {
-	float* heightmap = GetHeightmap();
+	const float* heightmap = GetHeightmap();
 
 	minheight = +123456.0f;
 	maxheight = -123456.0f;
@@ -153,78 +154,87 @@
 		orgheightmap[y] = heightmap[y];
 		if (heightmap[y] &lt; minheight) { minheight = heightmap[y]; }
 		if (heightmap[y] &gt; maxheight) { maxheight = heightmap[y]; }
-		mapChecksum +=  (unsigned int)(heightmap[y] * 100);
-		mapChecksum ^= *(unsigned int*)&amp;heightmap[y];
+		mapChecksum +=  (unsigned int) (heightmap[y] * 100);
+		mapChecksum ^= *(unsigned int*) &amp;heightmap[y];
 	}
 
-//	PrintLoadMsg(&quot;Creating surface normals&quot;);
+	currMinHeight = minheight;
+	currMaxHeight = maxheight;
 
-	for(int y=0;y&lt;(gs-&gt;mapy);y++){
-		for(int x=0;x&lt;(gs-&gt;mapx);x++){
-			float height=heightmap[(y)*(gs-&gt;mapx+1)+x];
-			height+=heightmap[(y)*(gs-&gt;mapx+1)+x+1];
-			height+=heightmap[(y+1)*(gs-&gt;mapx+1)+x];
-			height+=heightmap[(y+1)*(gs-&gt;mapx+1)+x+1];
-			centerheightmap[y*gs-&gt;mapx+x]=height/4;
+	for (int y = 0; y &lt; (gs-&gt;mapy); y++) {
+		for (int x = 0; x &lt; (gs-&gt;mapx); x++) {
+			float height = heightmap[(y) * (gs-&gt;mapx + 1) + x];
+			height += heightmap[(y    ) * (gs-&gt;mapx + 1) + x + 1];
+			height += heightmap[(y + 1) * (gs-&gt;mapx + 1) + x    ];
+			height += heightmap[(y + 1) * (gs-&gt;mapx + 1) + x + 1];
+			centerheightmap[y * gs-&gt;mapx + x] = height * 0.25f;
 		}
 	}
 
-	for(int i=0; i&lt;numHeightMipMaps-1; i++){
-		int hmapx = gs-&gt;mapx&gt;&gt;i;
-		int hmapy = gs-&gt;mapy&gt;&gt;i;
-		for(int y=0;y&lt;hmapy;y+=2){
-			for(int x=0;x&lt;hmapx;x+=2){
-				float height = mipHeightmap[i][(x)+(y)*hmapx];
-				height += mipHeightmap[i][(x)+(y+1)*hmapx];
-				height += mipHeightmap[i][(x+1)+(y)*hmapx];
-				height += mipHeightmap[i][(x+1)+(y+1)*hmapx];
-				mipHeightmap[i+1][(x/2)+(y/2)*hmapx/2] = height/4.0f;
+	for (int i = 0; i &lt; numHeightMipMaps - 1; i++) {
+		int hmapx = gs-&gt;mapx &gt;&gt; i;
+		int hmapy = gs-&gt;mapy &gt;&gt; i;
+
+		for (int y = 0; y &lt; hmapy; y += 2) {
+			for (int x = 0; x &lt; hmapx; x += 2) {
+				float height = mipHeightmap[i][(x) + (y) * hmapx];
+				height += mipHeightmap[i][(x    ) + (y + 1) * hmapx];
+				height += mipHeightmap[i][(x + 1) + (y    ) * hmapx];
+				height += mipHeightmap[i][(x + 1) + (y + 1) * hmapx];
+				mipHeightmap[i + 1][(x / 2) + (y / 2) * hmapx / 2] = height * 0.25f;
 			}
 		}
 	}
 
-	for(int y=0;y&lt;gs-&gt;mapy;y++){
-		for(int x=0;x&lt;gs-&gt;mapx;x++){
+	// create the surface normals
+	for (int y = 0; y &lt; gs-&gt;mapy; y++) {
+		for (int x = 0; x &lt; gs-&gt;mapx; x++) {
+			int idx0 = (y    ) * (gs-&gt;mapx + 1) + x;
+			int idx1 = (y + 1) * (gs-&gt;mapx + 1) + x;
 
-			float3 e1(-SQUARE_SIZE,heightmap[y*(gs-&gt;mapx+1)+x]-heightmap[y*(gs-&gt;mapx+1)+x+1],0);
-			float3 e2( 0,heightmap[y*(gs-&gt;mapx+1)+x]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],-SQUARE_SIZE);
+			float3 e1(-SQUARE_SIZE, heightmap[idx0] - heightmap[idx0 + 1],            0);
+			float3 e2(           0, heightmap[idx0] - heightmap[idx1    ], -SQUARE_SIZE);
 
-			float3 n=e2.cross(e1);
+			float3 n = e2.cross(e1);
 			n.Normalize();
 
-			facenormals[(y*gs-&gt;mapx+x)*2]=n;
+			facenormals[(y * gs-&gt;mapx + x) * 2] = n;
 
-			e1=float3( SQUARE_SIZE,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],0);
-			e2=float3( 0,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y)*(gs-&gt;mapx+1)+x+1],SQUARE_SIZE);
+			e1 = float3( SQUARE_SIZE, heightmap[idx1 + 1] - heightmap[idx1    ],           0);
+			e2 = float3(           0, heightmap[idx1 + 1] - heightmap[idx0 + 1], SQUARE_SIZE);
 
-			n=e2.cross(e1);
+			n = e2.cross(e1);
 			n.Normalize();
 
-			facenormals[(y*gs-&gt;mapx+x)*2+1]=n;
+			facenormals[(y * gs-&gt;mapx + x) * 2 + 1] = n;
 		}
 	}
 
-	for(int y=0;y&lt;gs-&gt;hmapy;y++){
-		for(int x=0;x&lt;gs-&gt;hmapx;x++){
-			slopemap[y*gs-&gt;hmapx+x]=1;
+	for (int y = 0; y &lt; gs-&gt;hmapy; y++) {
+		for (int x = 0; x &lt; gs-&gt;hmapx; x++) {
+			slopemap[y * gs-&gt;hmapx + x] = 1;
 		}
 	}
 
-	for(int y=2;y&lt;gs-&gt;mapy-2;y+=2){
-		for(int x=2;x&lt;gs-&gt;mapx-2;x+=2){
-			float3 e1(-SQUARE_SIZE*4,heightmap[(y-1)*(gs-&gt;mapx+1)+(x-1)]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],0);
-			float3 e2( 0,heightmap[(y-1)*(gs-&gt;mapx+1)+(x-1)]-heightmap[(y+3)*(gs-&gt;mapx+1)+(x-1)],-SQUARE_SIZE*4);
+	const int ss4 = SQUARE_SIZE * 4;
+	for (int y = 2; y &lt; gs-&gt;mapy - 2; y += 2) {
+		for (int x = 2; x &lt; gs-&gt;mapx - 2; x += 2) {
+			int idx0 = (y - 1) * (gs-&gt;mapx + 1);
+			int idx1 = (y + 3) * (gs-&gt;mapx + 1);
 
-			float3 n=e2.cross(e1);
+			float3 e1(-ss4, heightmap[idx0 + (x - 1)] - heightmap[idx0 +  x + 3 ],    0);
+			float3 e2(   0, heightmap[idx0 + (x - 1)] - heightmap[idx1 + (x - 1)], -ss4);
+
+			float3 n = e2.cross(e1);
 			n.Normalize();
 
-			e1=float3( SQUARE_SIZE*4,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],0);
-			e2=float3( 0,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],SQUARE_SIZE*4);
+			e1 = float3(ss4, heightmap[idx1 + x + 3] - heightmap[idx1 + (x - 1)],   0);
+			e2 = float3(  0, heightmap[idx1 + x + 3] - heightmap[idx0 +  x + 3 ], ss4);
 
-			float3 n2=e2.cross(e1);
+			float3 n2 = e2.cross(e1);
 			n2.Normalize();
 
-			slopemap[(y/2)*gs-&gt;hmapx+(x/2)]=1-(n.y+n2.y)*0.5f;
+			slopemap[(y / 2) * gs-&gt;hmapx + (x / 2)] = 1.0f - (n.y + n2.y) * 0.5f;
 		}
 	}
 }

Modified: trunk/rts/Map/ReadMap.h
===================================================================
--- trunk/rts/Map/ReadMap.h	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/ReadMap.h	2008-08-04 18:19:19 UTC (rev 6232)
@@ -44,9 +44,14 @@
 protected:
 	void Initialize(); // called by implementations of CReadMap
 public:
-	void CalcHeightfieldData(); /// Calculates derived heightmap information such as normals, centerheightmap and slopemap
+	// calculates derived heightmap information such as normals, centerheightmap and slopemap
+	void CalcHeightfieldData();
 
-	virtual float* GetHeightmap() = 0; // if you modify the heightmap, call HeightmapUpdated
+	virtual const float* GetHeightmap() = 0;
+	// if you modify the heightmap, call HeightmapUpdated
+	virtual void SetHeight(int idx, float h) = 0;
+	virtual void AddHeight(int idx, float a) = 0;
+
 	float* orgheightmap;
 	float* centerheightmap;
 	static const int numHeightMipMaps = 7;	//number of heightmap mipmaps, including full resolution
@@ -96,6 +101,7 @@
 	virtual void GridVisibility(CCamera *cam, int quadSize, float maxdist, IQuadDrawer *cb, int extraSize=0) = 0;
 
 	float minheight, maxheight;
+	float currMinHeight, currMaxHeight;
 };
 
 extern CReadMap* readmap;

Modified: trunk/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- trunk/rts/Map/SM3/Sm3Map.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/SM3/Sm3Map.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -173,12 +173,6 @@
 	renderer-&gt;HeightmapUpdated(x1,y1,x2-x1,y2-y1);
 }
 
-float* CSm3ReadMap::GetHeightmap()
-{
-	return renderer-&gt;GetHeightmap();
-}
-
-
 void CSm3ReadMap::Update() {}
 void CSm3ReadMap::Explosion(float x,float y,float strength) {}
 GLuint CSm3ReadMap::GetShadingTexture () { return 0; } // a texture with RGB for shading and A for height

Modified: trunk/rts/Map/SM3/Sm3Map.h
===================================================================
--- trunk/rts/Map/SM3/Sm3Map.h	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/SM3/Sm3Map.h	2008-08-04 18:19:19 UTC (rev 6232)
@@ -18,21 +18,33 @@
 
 	CSm3ReadMap();
 	~CSm3ReadMap();
-	void Initialize (const char *mapname); // throws std::runtime_exception on errors
+	void Initialize(const char* mapname); // throws std::runtime_exception on errors
 
-	CBaseGroundDrawer *GetGroundDrawer ();
+	CBaseGroundDrawer* GetGroundDrawer();
 	void HeightmapUpdated(int x1, int x2, int y1, int y2);
-	float* GetHeightmap();
+	const float* GetHeightmap() { return renderer-&gt;GetHeightmap(); }
+
+	inline void SetHeight(int idx, float h) {
+		renderer-&gt;GetHeightmap()[idx] = h;
+		currMinHeight = std::min(h, currMinHeight);
+		currMaxHeight = std::max(h, currMaxHeight);
+	}
+	inline void AddHeight(int idx, float a) {
+		renderer-&gt;GetHeightmap()[idx] += a;
+		currMinHeight = std::min(renderer-&gt;GetHeightmap()[idx], currMinHeight);
+		currMaxHeight = std::max(renderer-&gt;GetHeightmap()[idx], currMaxHeight);
+	}
+
 	void Update();
-	void Explosion(float x,float y,float strength);
-	GLuint GetShadingTexture (); // a texture with RGB for shading and A for height
-	void DrawMinimap (); // draw the minimap in a quad (with extends: (0,0)-(1,1))
+	void Explosion(float x, float y, float strength);
+	GLuint GetShadingTexture(); // a texture with RGB for shading and A for height
+	void DrawMinimap(); // draw the minimap in a quad (with extends: (0,0)-(1,1))
 
 	// Feature creation
-	int GetNumFeatures ();
-	int GetNumFeatureTypes ();
-	void GetFeatureInfo (MapFeatureInfo* f); // returns MapFeatureInfo[GetNumFeatures()]
-	const char *GetFeatureType (int typeID);
+	int GetNumFeatures();
+	int GetNumFeatureTypes();
+	void GetFeatureInfo(MapFeatureInfo* f); // returns MapFeatureInfo[GetNumFeatures()]
+	const char* GetFeatureType(int typeID);
 
 	// Bitmaps (such as metal map, grass map, ...), handling them with a string as type seems flexible...
 	// Some map types:

Modified: trunk/rts/Map/SMF/SmfReadMap.h
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.h	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Map/SMF/SmfReadMap.h	2008-08-04 18:19:19 UTC (rev 6232)
@@ -21,8 +21,19 @@
 	void DrawMinimap ();
 	void GridVisibility(CCamera *cam, int quadSize, float maxdist, IQuadDrawer *cb, int extraSize);
 	CBaseGroundDrawer* GetGroundDrawer();
-	float* GetHeightmap() { return heightmap; }
-	
+	const float* GetHeightmap() { return heightmap; }
+
+	inline void SetHeight(int idx, float h) {
+		heightmap[idx] = h;
+		currMinHeight = std::min(h, currMinHeight);
+		currMaxHeight = std::max(h, currMaxHeight);
+	}
+	inline void AddHeight(int idx, float a) {
+		heightmap[idx] += a;
+		currMinHeight = std::min(heightmap[idx], currMinHeight);
+		currMaxHeight = std::max(heightmap[idx], currMaxHeight);
+	}
+
 	int GetNumFeatureTypes ();
 	int GetNumFeatures ();
 	void GetFeatureInfo (MapFeatureInfo* f);// returns all feature info in MapFeatureInfo[NumFeatures]

Modified: trunk/rts/Rendering/Env/AdvWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvWater.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Rendering/Env/AdvWater.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -119,8 +119,9 @@
 
 void CAdvWater::Draw(bool useBlending)
 {
-	if(readmap-&gt;minheight&gt;10)
+	if (readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
+
 	float3 dir,zpos;
 	float3 base=camera-&gt;CalcPixelDir(gu-&gt;viewPosX,gu-&gt;viewSizeY);
 	float3 dv=camera-&gt;CalcPixelDir(gu-&gt;viewPosX,0)-camera-&gt;CalcPixelDir(gu-&gt;viewPosX,gu-&gt;viewSizeY);
@@ -226,7 +227,7 @@
 
 void CAdvWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
+	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
 		return;
 
 	glViewport(0,0,128,128);

Modified: trunk/rts/Rendering/Env/BasicWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicWater.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Rendering/Env/BasicWater.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -41,7 +41,7 @@
 
 void CBasicWater::Draw()
 {
-	if(readmap-&gt;minheight &gt; 10)
+	if (readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	if(displist == 0) {

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -568,7 +568,7 @@
 
 void CBumpWater::Update()
 {
-	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
+	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
 		return;
 
 	float3 w = wind.GetCurrentWind();
@@ -611,7 +611,7 @@
 
 void CBumpWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
+	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
 		return;
 
 	if (refraction&gt;1) DrawRefraction(game);
@@ -904,7 +904,7 @@
 
 void CBumpWater::Draw()
 {
-	if(readmap-&gt;minheight&gt;1)
+	if (readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	if (refraction == 1) {

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -264,7 +264,7 @@
 
 void CDynWater::Draw()
 {
-	if(readmap-&gt;minheight&gt;10)
+	if (readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	glDisable(GL_BLEND);
@@ -354,7 +354,7 @@
 
 void CDynWater::UpdateWater(CGame* game)
 {
-	if (readmap-&gt;minheight &gt; 10 || mapInfo-&gt;map.voidWater)
+	if (readmap-&gt;currMinHeight &gt; 1.0f || mapInfo-&gt;map.voidWater)
 		return;
 
 	glDisable(GL_DEPTH_TEST);
@@ -377,7 +377,7 @@
 
 void CDynWater::Update()
 {
-	if(readmap-&gt;minheight&gt;10)
+	if (readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	oldCamPosBig=camPosBig;

Modified: trunk/rts/Rendering/Env/RefractWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/RefractWater.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Rendering/Env/RefractWater.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -40,7 +40,7 @@
 
 void CRefractWater::Draw()
 {
-	if(readmap-&gt;minheight&gt;10)
+	if (readmap-&gt;currMinHeight &gt; 1.0f)
 		return;
 
 	glActiveTextureARB(GL_TEXTURE2_ARB);

Modified: trunk/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- trunk/rts/Rendering/GroundDecalHandler.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Rendering/GroundDecalHandler.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -194,7 +194,7 @@
 				if (camera-&gt;InView(decal-&gt;pos, decal-&gt;radius) &amp;&amp;
 					(!decal-&gt;owner || (decal-&gt;owner-&gt;losStatus[gu-&gt;myAllyTeam] &amp; (LOS_INLOS | LOS_PREVLOS)) || gu-&gt;spectatingFullView)) {
 					color[3] = int(decal-&gt;alpha * 255);
-					float* heightmap = readmap-&gt;GetHeightmap();
+					const float* heightmap = readmap-&gt;GetHeightmap();
 					float xts = 1.0f / decal-&gt;xsize;
 					float yts = 1.0f / decal-&gt;ysize;
 
@@ -400,7 +400,7 @@
 				int ex = (int) min(float(gs-&gt;hmapx - 1), (pos.x + radius) / 16.0f);
 				int sz = (int) max(0.f,                  (pos.z - radius) / 16.0f);
 				int ez = (int) min(float(gs-&gt;hmapy - 1), (pos.z + radius) / 16.0f);
-				float* heightmap = readmap-&gt;GetHeightmap();
+				const float* heightmap = readmap-&gt;GetHeightmap();
 
 				// create the scar texture-quads
 				for (int x = sx; x &lt;= ex; ++x) {

Modified: trunk/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Sim/Units/UnitHandler.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -302,7 +302,7 @@
 	float maxh=5000;
 	int numBorder=0;
 	float borderh=0;
-	float* heightmap=readmap-&gt;GetHeightmap();
+	const float* heightmap=readmap-&gt;GetHeightmap();
 
 	int xsize=1;
 	int ysize=1;
@@ -412,7 +412,7 @@
 	}
 
 	if (!unitdef-&gt;floater) {
-		float* heightmap = readmap-&gt;GetHeightmap();
+		const float* heightmap = readmap-&gt;GetHeightmap();
 		int x = (int) (pos.x / SQUARE_SIZE);
 		int z = (int) (pos.z / SQUARE_SIZE);
 		float orgh = readmap-&gt;orgheightmap[z * (gs-&gt;mapx + 1) + x];

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -302,6 +302,8 @@
 		unit-&gt;energyTickMake += ud-&gt;tidalGenerator * mapInfo-&gt;map.tidalStrength;
 
 
+
+
 	unit-&gt;model = ud-&gt;LoadModel(team);
 	unit-&gt;SetRadius(unit-&gt;model-&gt;radius);
 
@@ -327,9 +329,11 @@
 		unit-&gt;pos.y = ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z);
 	}
 
+
 	unit-&gt;cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + name + &quot;.cob&quot;), unit);
 	unit-&gt;localmodel = modelParser-&gt;CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
 
+
 	for (unsigned int i = 0; i &lt; ud-&gt;weapons.size(); i++) {
 		unit-&gt;weapons.push_back(LoadWeapon(ud-&gt;weapons[i].def, unit, &amp;ud-&gt;weapons[i]));
 	}
@@ -507,12 +511,13 @@
 		const int tz1 = (int) std::max(0.0f ,(bi.pos.z - (bi.GetYSize() * hss)) / SQUARE_SIZE);
 		const int tx2 = std::min(gs-&gt;mapx, tx1 + bi.GetXSize());
 		const int tz2 = std::min(gs-&gt;mapy, tz1 + bi.GetYSize());
-		float* heightmap = readmap-&gt;GetHeightmap();
-		for(int z = tz1; z &lt;= tz2; z++){
-			for(int x = tx1; x &lt;= tx2; x++){
-				heightmap[z * (gs-&gt;mapx + 1) + x] = bi.pos.y;
+
+		for (int z = tz1; z &lt;= tz2; z++) {
+			for (int x = tx1; x &lt;= tx2; x++) {
+				readmap-&gt;SetHeight(z * (gs-&gt;mapx + 1) + x, bi.pos.y);
 			}
 		}
+
 		mapDamage-&gt;RecalcArea(tx1, tx2, tz1, tz2);
 	}
 }

Modified: trunk/rts/Sim/Units/UnitTypes/Builder.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-08-03 19:05:40 UTC (rev 6231)
+++ trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-08-04 18:19:19 UTC (rev 6232)
@@ -136,26 +136,33 @@
 		return;
 	}
 
-	if(terraforming &amp;&amp; inBuildStance){
-		float* heightmap = readmap-&gt;GetHeightmap();
+	if (terraforming &amp;&amp; inBuildStance) {
+		const float* heightmap = readmap-&gt;GetHeightmap();
 		assert(!mapDamage-&gt;disabled); // The map should not be deformed in the first place.
 		float terraformScale = 0.1;
-		switch(terraformType) {
+
+		switch (terraformType) {
 		    case Terraform_Building:
-				if(curBuild) {
+				if (curBuild) {
 					terraformScale = (terraformSpeed + terraformHelp) / curBuild-&gt;terraformLeft;
 					curBuild-&gt;terraformLeft -= (terraformSpeed + terraformHelp);
 					terraformHelp = 0;
+
 					if (terraformScale &gt; 1.0f) {
 						terraformScale = 1.0f;
 					}
-					curBuild-&gt;AddBuildPower(0.0f,this); //prevent building from timing out while terraforming for it
-					for(int z=tz1; z&lt;=tz2; z++){
-						for(int x=tx1; x&lt;=tx2; x++){
-							float ch=heightmap[z*(gs-&gt;mapx+1)+x];
-							heightmap[z*(gs-&gt;mapx+1)+x] += (curBuild-&gt;pos.y - ch) * terraformScale;
+
+					// prevent building from timing out while terraforming for it
+					curBuild-&gt;AddBuildPower(0.0f, this);
+					for (int z = tz1; z &lt;= tz2; z++) {
+						for (int x = tx1; x &lt;= tx2; x++) {
+							int idx = z * (gs-&gt;mapx + 1) + x;
+							float ch = heightmap[idx];
+
+							readmap-&gt;AddHeight(idx, (curBuild-&gt;pos.y - ch) * terraformScale);
 						}
 					}
+
 					if(curBuild-&gt;terraformLeft&lt;=0){
 						terraforming=false;
 						mapDamage-&gt;RecalcArea(tx1,tx2,tz1,tz2);
@@ -170,53 +177,70 @@
 				terraformScale = (terraformSpeed + terraformHelp) / myTerraformLeft;
 				myTerraformLeft -= (terraformSpeed + terraformHelp);
 				terraformHelp = 0;
+
 				if (terraformScale &gt; 1.0f) {
 					terraformScale = 1.0f;
 				}
-				for(int z=tz1; z&lt;=tz2; z++){
-					for(int x=tx1; x&lt;=tx2; x++){
-						float ch=heightmap[z*(gs-&gt;mapx+1)+x];
-						float oh=readmap-&gt;orgheightmap[z*(gs-&gt;mapx+1)+x];
-						heightmap[z*(gs-&gt;mapx+1)+x] += (oh-ch) * terraformScale;
+
+				for (int z = tz1; z &lt;= tz2; z++) {
+					for (int x = tx1; x &lt;= tx2; x++) {
+						int idx = z * (gs-&gt;mapx + 1) + x;
+						float ch = heightmap[idx];
+						float oh = readmap-&gt;orgheightmap[idx];
+
+						readmap-&gt;AddHeight(idx, (oh - ch) * terraformScale);
 					}
 				}
-				if(myTerraformLeft&lt;=0){
+
+				if (myTerraformLeft &lt;= 0) {
 					terraforming=false;
 					mapDamage-&gt;RecalcArea(tx1,tx2,tz1,tz2);
 					StopBuild();
 				}
 				break;
 		}
+
 		CreateNanoParticle(terraformCenter,terraformRadius*0.5f,false);
-		for(int z=tz1; z&lt;=tz2; z++){		//smooth the borders x
-			for(int x=1; x&lt;=3; x++){
-				if(tx1-3&gt;=0){
-					float ch3=heightmap[z*(gs-&gt;mapx+1)+tx1];
-					float ch=heightmap[z*(gs-&gt;mapx+1)+tx1-x];
-					float ch2=heightmap[z*(gs-&gt;mapx+1)+tx1-3];
-					heightmap[z*(gs-&gt;mapx+1)+tx1-x] += ((ch3*(3-x)+ch2*x)/3-ch) * terraformScale;
+
+		for (int z = tz1; z &lt;= tz2; z++) {
+			// smooth the borders x
+			for (int x = 1; x &lt;= 3; x++) {
+				if (tx1 - 3 &gt;= 0) {
+					float ch3 = heightmap[z * (gs-&gt;mapx + 1) + tx1    ];
+					float ch  = heightmap[z * (gs-&gt;mapx + 1) + tx1 - x];
+					float ch2 = heightmap[z * (gs-&gt;mapx + 1) + tx1 - 3];
+					float amount = ((ch3 * (3 - x) + ch2 * x) / 3 - ch) * terraformScale;
+
+					readmap-&gt;AddHeight(z * (gs-&gt;mapx + 1) + tx1 - x, amount);
 				}
-				if(tx2+3&lt;gs-&gt;mapx){
-					float ch3=heightmap[z*(gs-&gt;mapx+1)+tx2];
-					float ch=heightmap[z*(gs-&gt;mapx+1)+tx2+x];
-					float ch2=heightmap[z*(gs-&gt;mapx+1)+tx2+3];
-					heightmap[z*(gs-&gt;mapx+1)+tx2+x] += ((ch3*(3-x)+ch2*x)/3-ch) * terraformScale;
+				if (tx2 + 3 &lt; gs-&gt;mapx) {
+					float ch3 = heightmap[z * (gs-&gt;mapx + 1) + tx2    ];
+					float ch  = heightmap[z * (gs-&gt;mapx + 1) + tx2 + x];
+					float ch2 = heightmap[z * (gs-&gt;mapx + 1) + tx2 + 3];
+					float amount = ((ch3 * (3 - x) + ch2 * x) / 3 - ch) * terraformScale;
+
+					readmap-&gt;AddHeight(z * (gs-&gt;mapx + 1) + tx2 + x, amount);
 				}
 			}
 		}
-		for(int z=1; z&lt;=3; z++){		//smooth the borders z
-			for(int x=tx1; x&lt;=tx2; x++){
-				if(tz1-3&gt;=0){
-					float ch3=heightmap[(tz1)*(gs-&gt;mapx+1)+x];
-					float ch=heightmap[(tz1-z)*(gs-&gt;mapx+1)+x];
-					float ch2=heightmap[(tz1-3)*(gs-&gt;mapx+1)+x];
-					heightmap[(tz1-z)*(gs-&gt;mapx+1)+x] += ((ch3*(3-z)+ch2*z)/3-ch) * terraformScale;
+		for (int z = 1; z &lt;= 3; z++) {
+			// smooth the borders z
+			for (int x = tx1; x &lt;= tx2; x++) {
+				if (tz1 - 3 &gt;= 0) {
+					float ch3 = heightmap[(tz1    ) * (gs-&gt;mapx + 1) + x];
+					float ch  = heightmap[(tz1 - z) * (gs-&gt;mapx + 1) + x];
+					float ch2 = heightmap[(tz1 - 3) * (gs-&gt;mapx + 1) + x];
+					float adjust = ((ch3 * (3 - z) + ch2 * z) / 3 - ch) * terraformScale;
+
+					readmap-&gt;AddHeight((tz1 - z) * (gs-&gt;mapx + 1) + x, adjust);
 				}
-				if(tz2+3&lt;gs-&gt;mapy){
-					float ch3=heightmap[(tz2)*(gs-&gt;mapx+1)+x];
-					float ch=heightmap[(tz2+z)*(gs-&gt;mapx+1)+x];
-					float ch2=heightmap[(tz2+3)*(gs-&gt;mapx+1)+x];
-					heightmap[(tz2+z)*(gs-&gt;mapx+1)+x] += ((ch3*(3-z)+ch2*z)/3-ch) * terraformScale;
+				if (tz2 + 3 &lt; gs-&gt;mapy) {
+					float ch3 = heightmap[(tz2    ) * (gs-&gt;mapx + 1) + x];
+					float ch  = heightmap[(tz2 + z) * (gs-&gt;mapx + 1) + x];
+					float ch2 = heightmap[(tz2 + 3) * (gs-&gt;mapx + 1) + x];
+					float adjust = ((ch3 * (3 - z) + ch2 * z) / 3 - ch) * terraformScale;
+
+					readmap-&gt;AddHeight((tz2 + z) * (gs-&gt;mapx + 1) + x, adjust);
 				}
 			}
 		}
@@ -460,12 +484,13 @@
 	tz1 = (int)max((float)0,(centerPos.z-radius)/SQUARE_SIZE);
 	tz2 = (int)min((float)gs-&gt;mapy,(centerPos.z+radius)/SQUARE_SIZE);
 
-	float tcost=0;
-	float* heightmap = readmap-&gt;GetHeightmap();
-	for(int z=tz1; z&lt;=tz2; z++){
-		for(int x=tx1; x&lt;=tx2; x++){
-			float delta=readmap-&gt;orgheightmap[z*(gs-&gt;mapx+1)+x]-heightmap[z*(gs-&gt;mapx+1)+x];
-			tcost+=fabs(delta);
+	float tcost = 0.0f;
+	const float* heightmap = readmap-&gt;GetHeightmap();
+
+	for (int z = tz1; z &lt;= tz2; z++) {
+		for (int x = tx1; x &lt;= tx2; x++) {
+			float delta = readmap-&gt;orgheightmap[z * (gs-&gt;mapx + 1) + x] - heightmap[z * (gs-&gt;mapx + 1) + x];
+			tcost += fabs(delta);
 		}
 	}
 	myTerraformLeft=tcost;
@@ -589,18 +614,20 @@
 {
 	float3&amp; buildPos=buildInfo.pos;
 
-	float tcost=0;
-	float* heightmap = readmap-&gt;GetHeightmap();
-	for(int z=tz1; z&lt;=tz2; z++){
-		for(int x=tx1; x&lt;=tx2; x++){
-			float delta=buildPos.y-heightmap[z*(gs-&gt;mapx+1)+x];
+	float tcost = 0.0f;
+	const float* heightmap = readmap-&gt;GetHeightmap();
+
+	for (int z = tz1; z &lt;= tz2; z++) {
+		for (int x = tx1; x &lt;= tx2; x++) {
+			int idx = z * (gs-&gt;mapx + 1) + x;
+			float delta = buildPos.y - heightmap[idx];
 			float cost;
-			if(delta&gt;0){
-				cost=max(3.f,heightmap[z*(gs-&gt;mapx+1)+x]-readmap-&gt;orgheightmap[z*(gs-&gt;mapx+1)+x]+delta*0.5f);
+			if (delta &gt; 0) {
+				cost = max(3.0f, heightmap[idx]-readmap-&gt;orgheightmap[idx] + delta * 0.5f);
 			} else {
-				cost=max(3.f,readmap-&gt;orgheightmap[z*(gs-&gt;mapx+1)+x]-heightmap[z*(gs-&gt;mapx+1)+x]-delta*0.5f);
+				cost = max(3.0f, readmap-&gt;orgheightmap[idx] - heightmap[idx] - delta * 0.5f);
 			}
-			tcost+=fabs(delta)*cost;
+			tcost += fabs(delta) * cost;
 		}
 	}
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001011.html">[Taspring-linux-commit] r6231 - trunk/rts/Map/SMF
</A></li>
	<LI>Next message: <A HREF="001013.html">[Taspring-linux-commit] r6233 - in branches/0.77-branch:	Lobby/TASClient Lobby/TASClient/Python	Lobby/TASClient/Python/scripts rts/Lua	rts/Sim/Units/CommandAI rts/System/Platform/Linux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1012">[ date ]</a>
              <a href="thread.html#1012">[ thread ]</a>
              <a href="subject.html#1012">[ subject ]</a>
              <a href="author.html#1012">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
