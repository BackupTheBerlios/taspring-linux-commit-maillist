<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6230 - in trunk:	installer/builddata/bitmaps/bitmaps	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SM3 rts/Map/SM3/terrain rts/Map/SMF	rts/Rendering rts/Rendering/Env rts/Rendering/GL rts/Sim/MoveTypes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6230%20-%20in%20trunk%3A%0A%09installer/builddata/bitmaps/bitmaps%0A%09installer/builddata/springcontent/shaders%20rts/Game%20rts/Lua%0A%09rts/Map%20rts/Map/SM3%20rts/Map/SM3/terrain%20rts/Map/SMF%0A%09rts/Rendering%20rts/Rendering/Env%20rts/Rendering/GL%20rts/Sim/MoveTypes&In-Reply-To=%3C20080803185612.8BBBA495D%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001009.html">
   <LINK REL="Next"  HREF="001011.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6230 - in trunk:	installer/builddata/bitmaps/bitmaps	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SM3 rts/Map/SM3/terrain rts/Map/SMF	rts/Rendering rts/Rendering/Env rts/Rendering/GL rts/Sim/MoveTypes</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6230%20-%20in%20trunk%3A%0A%09installer/builddata/bitmaps/bitmaps%0A%09installer/builddata/springcontent/shaders%20rts/Game%20rts/Lua%0A%09rts/Map%20rts/Map/SM3%20rts/Map/SM3/terrain%20rts/Map/SMF%0A%09rts/Rendering%20rts/Rendering/Env%20rts/Rendering/GL%20rts/Sim/MoveTypes&In-Reply-To=%3C20080803185612.8BBBA495D%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6230 - in trunk:	installer/builddata/bitmaps/bitmaps	installer/builddata/springcontent/shaders rts/Game rts/Lua	rts/Map rts/Map/SM3 rts/Map/SM3/terrain rts/Map/SMF	rts/Rendering rts/Rendering/Env rts/Rendering/GL rts/Sim/MoveTypes">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sun Aug  3 20:56:12 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001009.html">[Taspring-linux-commit] r6229 - trunk/Lobby/TASClient
</A></li>
        <LI>Next message: <A HREF="001011.html">[Taspring-linux-commit] r6231 - trunk/rts/Map/SMF
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1010">[ date ]</a>
              <a href="thread.html#1010">[ thread ]</a>
              <a href="subject.html#1010">[ subject ]</a>
              <a href="author.html#1010">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-08-03 20:56:10 +0200 (Sun, 03 Aug 2008)
New Revision: 6230

Modified:
   trunk/installer/builddata/bitmaps/bitmaps/waterbump.png
   trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl
   trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
   trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
   trunk/rts/Game/Game.cpp
   trunk/rts/Lua/LuaConstGame.cpp
   trunk/rts/Lua/LuaUnitDefs.cpp
   trunk/rts/Map/BaseGroundDrawer.cpp
   trunk/rts/Map/BaseGroundDrawer.h
   trunk/rts/Map/BasicMapDamage.cpp
   trunk/rts/Map/BasicMapDamage.h
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Map/ReadMap.h
   trunk/rts/Map/SM3/Sm3GroundDrawer.cpp
   trunk/rts/Map/SM3/Sm3Map.cpp
   trunk/rts/Map/SM3/Sm3Map.h
   trunk/rts/Map/SM3/terrain/Terrain.cpp
   trunk/rts/Map/SMF/BFGroundDrawer.cpp
   trunk/rts/Map/SMF/BFGroundDrawer.h
   trunk/rts/Rendering/Env/BaseWater.h
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/BumpWater.h
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/Env/RefractWater.cpp
   trunk/rts/Rendering/GL/VertexArray.h
   trunk/rts/Rendering/InMapDraw.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
Log:
BumpWater
* finished compability with cards that don't support GL_TEXTURE_RECTANGLE (in glsl shaders)
* update coastmap now on map damage
* mappers can now turn off shorewaves (tag is shoreWaves)
* added endless water (user can turn it off and the mapper needs to define a waterPlaneColor to get it working)
* added dynamic waves (don't confuse with DynWater!)
  * it uses a NoiseTileSet based water bump texture to reduce the repetition artifacts (next step would be WangTiles)
  * the new waterbump.png uses a 3x3 tileset
  * there is a new tag &quot;numTiles&quot;, the default texture uses &quot;3&quot;, if the mapper/modder defines a different bumptexture the default is &quot;1&quot; to not break backward compability (also only a few ppl would have the software to generate TileSets)

Engine
* fixed &quot;cloaked units were invisble underwater&quot; with DynWater and BumpWater(refraction=2)
* smoothed InMapDraw markers
* sm3 drawer respects /wireframe now
* cleaned up BasicMapDamage.cpp and fixed a bug (&quot;&lt;&quot; -&gt; &quot;&lt;=&quot;)

SMF Map Drawer
* cleaned up some code
* added detail factors for the different drawpasses. The new .springrc tags are (all should be in 0&lt;x&lt;=1 range):
 * GroundLODScaleReflection
 * GroundLODScaleUnitReflection
 (* GroundLODScaleRefraction unused atm)
* changed WaterPlane into a radial disc which blends into the fog color (BumpWater uses the same disc algorithm to render endless water)

LuaAPI
*fixed s3o recognition in LuaUnitDefs
*added the new reclaim/repair/capture/resurrect energyCosts values to the Game. table

Modified: trunk/installer/builddata/bitmaps/bitmaps/waterbump.png
===================================================================
(Binary files differ)

Modified: trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterCoastBlurFS.glsl	2008-08-03 18:56:10 UTC (rev 6230)
@@ -10,73 +10,74 @@
  * GNU GPL, v2 or later.
  */
 
-uniform sampler2D tex0;
+uniform sampler2D texture;
 uniform vec2 blurDir;
+uniform int blurTextureID;
 
 const float kernel = 1.0/10.0;
 
 void main(void) {
+  vec4 blur,blur2,blur3,blur4;
+  float d1=0.0,d2,d3;
+
   vec2 texCoord = gl_TexCoord[0].st;
 
   const vec2 texel = vec2(dFdx(gl_TexCoord[0].s),dFdy(gl_TexCoord[0].t));
 
   // 0 distance
-  gl_FragColor  = texture2D(tex0, texCoord );
+  gl_FragColor  = texture2D(texture, texCoord );
+
   if (gl_FragColor.r&gt;0.0) {
-    vec4 blur;
-    blur.x = texture2D(tex0, texCoord+vec2(texel.x,0.0) ).r;
-    blur.y = texture2D(tex0, texCoord+vec2(0.0,texel.y) ).r;
-    blur.z = texture2D(tex0, texCoord+vec2(-texel.x,0.0) ).r;
-    blur.w = texture2D(tex0, texCoord+vec2(0.0,-texel.y) ).r;
-    gl_FragColor.r = dot(blur,vec4(0.2))+gl_FragColor.r*0.2;
-    return;
+    blur.x = texture2D(texture, texCoord+vec2(texel.x,0.0) ).r;
+    blur.y = texture2D(texture, texCoord+vec2(0.0,texel.y) ).r;
+    blur.z = texture2D(texture, texCoord+vec2(-texel.x,0.0) ).r;
+    blur.w = texture2D(texture, texCoord+vec2(0.0,-texel.y) ).r;
+    d1 = dot(blur,vec4(0.2))+gl_FragColor.r*0.2;
   }
 
   // 1 texel distance
-  vec4 blur;
-  blur.x = texture2D(tex0, texCoord-texel ).r;
-  blur.y = texture2D(tex0, texCoord-vec2(0.0,texel.y) ).r;
-  blur.z = texture2D(tex0, texCoord-vec2(-texel.x,texel.y) ).r;
-  blur.w = texture2D(tex0, texCoord-vec2(texel.x,0.0) ).r;
+  blur.x = texture2D(texture, texCoord-texel ).r;
+  blur.y = texture2D(texture, texCoord-vec2(0.0,texel.y) ).r;
+  blur.z = texture2D(texture, texCoord-vec2(-texel.x,texel.y) ).r;
+  blur.w = texture2D(texture, texCoord-vec2(texel.x,0.0) ).r;
 
-  vec4 blur2;
-  blur2.x = texture2D(tex0, texCoord+texel ).r;
-  blur2.y = texture2D(tex0, texCoord+vec2(0.0,texel.y) ).r;
-  blur2.z = texture2D(tex0, texCoord+vec2(-texel.x,texel.y) ).r;
-  blur2.w = texture2D(tex0, texCoord+vec2(texel.x,0.0) ).r;
+  blur2.x = texture2D(texture, texCoord+texel ).r;
+  blur2.y = texture2D(texture, texCoord+vec2(0.0,texel.y) ).r;
+  blur2.z = texture2D(texture, texCoord+vec2(-texel.x,texel.y) ).r;
+  blur2.w = texture2D(texture, texCoord+vec2(texel.x,0.0) ).r;
 
   blur = max(blur,blur2);
   blur.xy = max(blur.xy,blur.zw);
   blur.x  = max(blur.x,blur.y);
-  if (blur.x&gt;0.0) { gl_FragColor.r=blur.x-kernel; return;}
+  d2 = blur.x-kernel;
 
   // 2 texel distance
-  blur.x = 0.0;// texture2D(tex0, texCoord-2.0*texel ).r;
-  blur.y = texture2D(tex0, texCoord-vec2(texel.x,2.0*texel.y) ).r;
-  blur.z = texture2D(tex0, texCoord-vec2(0.0,2.0*texel.y) ).r;
-  blur.w = texture2D(tex0, texCoord-vec2(-texel.x,2.0*texel.y) ).r;
+  blur.x = 0.0;// texture2D(texture, texCoord-2.0*texel ).r;
+  blur.y = texture2D(texture, texCoord-vec2(texel.x,2.0*texel.y) ).r;
+  blur.z = texture2D(texture, texCoord-vec2(0.0,2.0*texel.y) ).r;
+  blur.w = texture2D(texture, texCoord-vec2(-texel.x,2.0*texel.y) ).r;
 
-  blur2.x = 0.0;// texture2D(tex0, texCoord+vec2(2.0*texel.x,-2.0*texel.y) ).r;
-  blur2.y = texture2D(tex0, texCoord+vec2(2.0*texel.x,-texel.y) ).r;
-  blur2.z = texture2D(tex0, texCoord+vec2(2.0*texel.x,0.0) ).r;
-  blur2.w = texture2D(tex0, texCoord+vec2(2.0*texel.x,texel.y) ).r;
+  blur2.x = 0.0;// texture2D(texture, texCoord+vec2(2.0*texel.x,-2.0*texel.y) ).r;
+  blur2.y = texture2D(texture, texCoord+vec2(2.0*texel.x,-texel.y) ).r;
+  blur2.z = texture2D(texture, texCoord+vec2(2.0*texel.x,0.0) ).r;
+  blur2.w = texture2D(texture, texCoord+vec2(2.0*texel.x,texel.y) ).r;
 
-  vec4 blur3;
-  blur3.x = 0.0;// texture2D(tex0, texCoord+2.0*texel ).r;
-  blur3.y = texture2D(tex0, texCoord+vec2(texel.x,2.0*texel.y) ).r;
-  blur3.z = texture2D(tex0, texCoord+vec2(0.0,2.0*texel.y) ).r;
-  blur3.w = texture2D(tex0, texCoord+vec2(-texel.x,2.0*texel.y) ).r;
+  blur3.x = 0.0;// texture2D(texture, texCoord+2.0*texel ).r;
+  blur3.y = texture2D(texture, texCoord+vec2(texel.x,2.0*texel.y) ).r;
+  blur3.z = texture2D(texture, texCoord+vec2(0.0,2.0*texel.y) ).r;
+  blur3.w = texture2D(texture, texCoord+vec2(-texel.x,2.0*texel.y) ).r;
 
-  vec4 blur4;
-  blur4.x = 0.0;// texture2D(tex0, texCoord-vec2(2.0*texel.x,-2.0*texel.y) ).r;
-  blur4.y = texture2D(tex0, texCoord-vec2(2.0*texel.x,-texel.y) ).r;
-  blur4.z = texture2D(tex0, texCoord-vec2(2.0*texel.x,0.0) ).r;
-  blur4.w = texture2D(tex0, texCoord-vec2(2.0*texel.x,texel.y) ).r;
+  blur4.x = 0.0;// texture2D(texture, texCoord-vec2(2.0*texel.x,-2.0*texel.y) ).r;
+  blur4.y = texture2D(texture, texCoord-vec2(2.0*texel.x,-texel.y) ).r;
+  blur4.z = texture2D(texture, texCoord-vec2(2.0*texel.x,0.0) ).r;
+  blur4.w = texture2D(texture, texCoord-vec2(2.0*texel.x,texel.y) ).r;
 
   blur = max(blur,blur2);
   blur = max(blur,blur3);
   blur = max(blur,blur4);
   blur.xy = max(blur.xy,blur.zw);
   blur.x  = max(blur.x,blur.y);
-  if (blur.x&gt;0.0) { gl_FragColor.r=blur.x-kernel-kernel; return;}
+  d3 = blur.x-kernel-kernel;
+
+  gl_FragColor.r = max(d1,max(d2,d3));
 }

Modified: trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-08-03 18:56:10 UTC (rev 6230)
@@ -8,13 +8,14 @@
  * GNU GPL, v2 or later.
  */
 
+
 //////////////////////////////////////////////////
 // runtime defined constants are:
 // #define SurfaceColor     vec4
 // #define DiffuseColor     vec3
 // #define PlaneColor       vec4  (unused)
 // #define AmbientFactor    float
-// #define DiffuseFactor    float   (note: it is the map defined value multipled with 15x!)
+// #define DiffuseFactor    float (note: it is the map defined value multipled with 15x!)
 // #define SpecularColor    vec3
 // #define SpecularPower    float
 // #define SpecularFactor   float
@@ -36,6 +37,11 @@
 // #define PerlinLacunarity float
 // #define PerlinAmp        float
 
+#define CausticDepth 0.5
+#define CausticRange 0.45
+#define WavesLength  0.15
+
+
 //////////////////////////////////////////////////
 // possible flags are:
 // //#define use_heightmap
@@ -44,12 +50,15 @@
 // #define use_shorewaves
 // #define use_depth
 // #define blur_reflection
+// #define use_texrect
 
-#extension GL_ARB_texture_rectangle : enable
+#ifdef use_texrect
+  #extension GL_ARB_texture_rectangle : enable
+#else
+  #define texture2DRect texture2D
+  #define sampler2DRect sampler2D
+#endif
 
-#define CausticDepth 0.5
-#define CausticRange 0.45
-#define WavesLength  0.15
 
 //////////////////////////////////////////////////
 // Uniforms + Varyings
@@ -69,18 +78,32 @@
   varying vec3 eyeVec;
   varying vec3 ligVec;
 
+
 //////////////////////////////////////////////////
+// Screen Coordinates (normalized and screen dimensions)
+
+#ifdef use_texrect
+  vec2 screencoord = (gl_FragCoord.xy - ViewPos);
+  vec2 reftexcoord = (screencoord*ScreenInverse);
+#else
+  vec2 screencoord = (gl_FragCoord.xy - ViewPos)*ScreenInverse;
+  vec2 reftexcoord = screencoord;
+#endif
+
+
+//////////////////////////////////////////////////
 // Depth conversion
-
+#ifdef use_depth
   float pm15 = gl_ProjectionMatrix[2][3];
   float pm11 = gl_ProjectionMatrix[2][3];
   float convertDepthToZ(float d) {
     return pm15 / (((d * 2.0) - 1.0) + pm11);
   }
+#endif
 
-
 //////////////////////////////////////////////////
 // shorewaves functions
+#ifdef use_shorewaves
 const float InvWavesLength = 1.0/WavesLength;
 
 float smoothlimit(const float x, const float step) {
@@ -100,6 +123,7 @@
   else
     return front;
 }
+#endif
 
 //////////////////////////////////////////////////
 // MAIN()
@@ -110,13 +134,21 @@
     float waterdepth = -texture2D(heightmap,gl_TexCoord[0].st).r;
     if (waterdepth&lt;0.0) discard;
 #else
-    float waterdepth = 1.0-texture2D(heightmap,gl_TexCoord[0].pq).a; //heightmap in alpha channel
-    if (waterdepth==0.0) discard;
-    //float invwaterdepth = 1.0-waterdepth;
+    float waterdepth;
+    if ( any(greaterThanEqual(gl_TexCoord[0].pq,vec2(1.0,1.0))) ||
+         any(lessThanEqual(gl_TexCoord[0].pq,vec2(0.0,0.0)))
+       )
+    {
+      waterdepth = 1.0;
+    }else{
+      waterdepth = 1.0 - texture2D(heightmap,gl_TexCoord[0].pq).a; //heightmap in alpha channel
+      if (waterdepth==0.0) discard;
+    }
+    //float invwaterdepth = 1.0 - waterdepth;
 #endif
 
 #ifdef use_depth
-    float tz = texture2DRect(depthmap, gl_FragCoord.xy-ViewPos ).r;
+    float tz = texture2DRect(depthmap, screencoord ).r;
     float shallowScale = clamp( abs( convertDepthToZ(tz) - convertDepthToZ(gl_FragCoord.z) )/3.0, 0.0,1.0);
 #else
     float shallowScale = waterdepth;
@@ -139,14 +171,14 @@
     vec3 normal = octave1+octave2+octave3+octave4;
     normal = normalize( normal ).xzy;
 
-    vec3 eVec   = normalize(eyeVec); // wait for texture fetches
+    vec3 eVec   = normalize(eyeVec);
     float eyeNormalCos = dot(-eVec, normal);
     float angle = (1.0-abs(eyeNormalCos));
 
 
 // AMBIENT &amp; DIFFUSE
     vec3 reflectDir   = reflect(normalize(-ligVec), normal);
-    float specular    = SpecularFactor * angle * pow( max(dot(reflectDir,eVec), 0.0) , SpecularPower) * shallowScale;
+    float specular    = angle * pow( max(dot(reflectDir,eVec), 0.0) , SpecularPower) * SpecularFactor * shallowScale;
     const vec3 SunLow = SunDir * vec3(1.0,0.1,1.0);
     float diffuse     = pow( max( dot(normal,SunLow) ,0.0 ) ,3.0)*DiffuseFactor;
     float ambient     = smoothstep(-1.3,0.0,eyeNormalCos)*AmbientFactor;
@@ -163,7 +195,7 @@
 
 // REFRACTION
 #ifdef use_refraction
-    vec3 refrColor = texture2DRect(refraction, gl_FragCoord.xy-ViewPos + normal.xz*refractDistortion ).rgb;
+    vec3 refrColor = texture2DRect(refraction, screencoord + normal.xz*refractDistortion ).rgb;
     gl_FragColor.rgb = mix(refrColor,waterSurface, 0.1+surfaceMix);
 #else
     gl_FragColor.rgb = waterSurface;
@@ -196,20 +228,25 @@
     vec3 shorewavesColor = vec3(0.0);
     float inwaterdepth = 1.0-waterdepth;
     //if (waterdepth&lt;1.0) {
-      float coastdist = texture2D(coastmap, gl_TexCoord[0].st ).r;
+      float coastdist = texture2D(coastmap, gl_TexCoord[0].st ).r + octave3.x*0.1; //FIXME
       //if (coastdist&gt;0.0 &amp;&amp; coastdist&lt;0.25) {
         vec3 wavefoam  = texture2D(foam, gl_TexCoord[0].st*160.0+frame ).rgb;
         wavefoam += texture2D(foam, gl_TexCoord[0].st*90.0+frame ).rgb;
         wavefoam *= 0.5;
 
+        vec2 wrcoord = gl_TexCoord[0].st*2.0;
+
         float fframe = fract(frame);
-        for (float i=0.0; i&lt;1.0; i+=1.0) {
-          float frac = fract(i+fframe*40.0)*1.4-0.2;
+        for (float i=0.0; i&lt;1.0; i+=0.25) {
+          float wave  = i+fframe*50.0;
+          float wavef = fract(wave);
+                wave -= wavef;
+          float frac  = wavef*1.4-0.2;
           float f = frac-coastdist;
           if (abs(f)&gt;WavesLength) continue;
-          float rand = texture2D(waverand, gl_TexCoord[0].st*2.0+frame+i ).r;
-          float f2 = waveIntensity( min(1.0,(WavesLength-f)*InvWavesLength) ,0.93);
-          shorewavesColor += wavefoam*f2*rand*rand;
+          float rand = texture2D(waverand, wrcoord+wave*0.37+i ).r;
+          float f2   = waveIntensity( min(1.0,(WavesLength-f)*InvWavesLength) ,0.85);
+          shorewavesColor += wavefoam*f2*rand;
         }
 
         shorewavesColor *= coastdist;
@@ -222,27 +259,34 @@
 
 // REFLECTION
 #ifdef use_reflection
-    float fresnel    = FresnelMin + FresnelMax * pow(angle,FresnelPower);
-    vec2 reftexcoord = vec2(0.0,1.0) - (gl_FragCoord.xy-ViewPos)*ScreenInverse + vec2(0.0,3.0*ScreenInverse.y) + normal.xz*0.09*ReflDistortion;
-    vec3 reflColor   = texture2D(reflection,reftexcoord.st).rgb;
+    //we have to mirror the Y-axis
+    reftexcoord  = vec2(reftexcoord.x,1.0 - reftexcoord.y);
+    reftexcoord += vec2(0.0,3.0*ScreenInverse.y) + normal.xz*0.09*ReflDistortion;
 
+    vec3 reflColor = texture2D(reflection,reftexcoord).rgb;
+
   #ifdef blur_reflection
     const vec2  v = BlurBase;
     const float s = BlurExponent;
-    reflColor   += texture2D(reflection,reftexcoord.st+v).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s*s).rgb;
-    reflColor   *= 0.125;
+    reflColor += texture2D(reflection,reftexcoord.st+v).rgb;
+    reflColor += texture2D(reflection,reftexcoord.st+v*s).rgb;
+    reflColor += texture2D(reflection,reftexcoord.st+v*s*s).rgb;
+    reflColor += texture2D(reflection,reftexcoord.st+v*s*s*s).rgb;
+    reflColor += texture2D(reflection,reftexcoord.st+v*s*s*s*s).rgb;
+    reflColor += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s).rgb;
+    reflColor += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s*s).rgb;
+    reflColor *= 0.125;
   #endif
 
+    float fresnel    = FresnelMin + FresnelMax * pow(angle,FresnelPower);
     gl_FragColor.rgb = mix(gl_FragColor.rgb, reflColor, fresnel*shallowScale);
 #endif
 
 
 // SPECULAR
     gl_FragColor.rgb += specular*SpecularColor;
+
+// FOG
+    float fog = clamp( (gl_Fog.end - abs(gl_FogFragCoord)) * gl_Fog.scale ,0.0,1.0);
+    gl_FragColor.rgb = mix(gl_Fog.color.rgb, gl_FragColor.rgb, fog );
   }
\ No newline at end of file

Modified: trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl
===================================================================
--- trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/installer/builddata/springcontent/shaders/bumpWaterVS.glsl	2008-08-03 18:56:10 UTC (rev 6230)
@@ -10,12 +10,42 @@
 
 //////////////////////////////////////////////////
 // runtime defined constants are:
+// #define SurfaceColor     vec4
+// #define DiffuseColor     vec3
+// #define PlaneColor       vec4  (unused)
+// #define AmbientFactor    float
+// #define DiffuseFactor    float   (note: it is the map defined value multipled with 15x!)
+// #define SpecularColor    vec3
+// #define SpecularPower    float
+// #define SpecularFactor   float
+// #define PerlinStartFreq  float
+// #define PerlinFreq       float
+// #define PerlinAmp        float
+// #define Speed            float
+// #define FresnelMin       float
+// #define FresnelMax       float
+// #define FresnelPower     float
+// #define ScreenInverse    vec2
+// #define ViewPos          vec2
 // #define MapMid           vec3
 // #define SunDir           vec3
+// #define ReflDistortion   float
+// #define BlurBase         vec2
+// #define BlurExponent     float
 // #define PerlinStartFreq  float
 // #define PerlinLacunarity float
 // #define PerlinAmp        float
 
+//////////////////////////////////////////////////
+// possible flags are:
+// //#define use_heightmap
+// #define use_reflection
+// #define use_refraction
+// #define use_shorewaves
+// #define use_depth
+// #define blur_reflection
+// #define use_texrect
+
 #define Speed 12.0
 
 uniform float frame;
@@ -27,14 +57,24 @@
 {
 	gl_Position = ftransform();
 
+	// COMPUTE TEXCOORDS
+	vec4 planes        = vec4(gl_ObjectPlaneS[0].x,gl_ObjectPlaneT[0].z,
+	                          gl_ObjectPlaneR[0].x,gl_ObjectPlaneQ[0].z);
+	gl_TexCoord[0]     = planes*gl_Vertex.xzxz;
+
+	// COMPUTE WAVE TEXTURE COORDS
 	const float fstart = PerlinStartFreq;
 	const float f      = PerlinLacunarity;
-	gl_TexCoord[0]     = gl_MultiTexCoord0;
-	gl_TexCoord[1].st = (vec2(-1.0,-1.0)+gl_MultiTexCoord0.st+0.75)*fstart      +frame*Speed;
-	gl_TexCoord[1].pq = (vec2(-1.0, 1.0)+gl_MultiTexCoord0.st+0.50)*fstart*f    -frame*Speed;
-	gl_TexCoord[2].st = (vec2( 1.0,-1.0)+gl_MultiTexCoord0.st+0.25)*fstart*f*f  +frame*Speed*vec2(1.0,-1.0);
-	gl_TexCoord[2].pq = (vec2( 1.0, 1.0)+gl_MultiTexCoord0.st+0.00)*fstart*f*f*f+frame*Speed*vec2(-1.0,1.0);
+	gl_TexCoord[1].st = (vec2(-1.0,-1.0)+gl_TexCoord[0].st+0.75)*fstart      +frame*Speed;
+	gl_TexCoord[1].pq = (vec2(-1.0, 1.0)+gl_TexCoord[0].st+0.50)*fstart*f    -frame*Speed;
+	gl_TexCoord[2].st = (vec2( 1.0,-1.0)+gl_TexCoord[0].st+0.25)*fstart*f*f  +frame*Speed*vec2(1.0,-1.0);
+	gl_TexCoord[2].pq = (vec2( 1.0, 1.0)+gl_TexCoord[0].st+0.00)*fstart*f*f*f+frame*Speed*vec2(-1.0,1.0);
 
+	// COMPUTE LIGHT VECTORS
 	eyeVec = eyePos - gl_Vertex.xyz;
 	ligVec = normalize(SunDir*20000.0 + MapMid - gl_Vertex.xyz);
+
+	// FOG
+	gl_FogFragCoord = (gl_ModelViewMatrix*gl_Vertex).z;
+
 }

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Game/Game.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -2731,7 +2731,7 @@
 		}
 	}
 
-	camera-&gt;Update(false);
+	camera-&gt;Update(false); //FIXME: after UpdateWater?
 
 	glClearColor(mapInfo-&gt;atmosphere.fogColor[0], mapInfo-&gt;atmosphere.fogColor[1], mapInfo-&gt;atmosphere.fogColor[2], 0);
 

Modified: trunk/rts/Lua/LuaConstGame.cpp
===================================================================
--- trunk/rts/Lua/LuaConstGame.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Lua/LuaConstGame.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -126,8 +126,23 @@
 	LuaPushNamedString(L, &quot;modDesc&quot;,         modInfo.description);
 
 	LuaPushNamedBool(L,   &quot;allowTeamColors&quot;, modInfo.allowTeamColors);
-	LuaPushNamedNumber(L, &quot;multiReclaim&quot;,    modInfo.multiReclaim);
-	LuaPushNamedNumber(L, &quot;reclaimMethod&quot;,   modInfo.reclaimMethod);
+
+	LuaPushNamedBool(L,   &quot;constructionDecay&quot;,      modInfo.constructionDecay);
+	LuaPushNamedNumber(L, &quot;constructionDecayTime&quot;,  modInfo.constructionDecayTime);
+	LuaPushNamedNumber(L, &quot;constructionDecaySpeed&quot;, modInfo.constructionDecaySpeed);
+
+	LuaPushNamedNumber(L, &quot;multiReclaim&quot;,                   modInfo.multiReclaim);
+	LuaPushNamedNumber(L, &quot;reclaimMethod&quot;,                  modInfo.reclaimMethod);
+	LuaPushNamedNumber(L, &quot;reclaimUnitMethod&quot;,              modInfo.reclaimUnitMethod);
+	LuaPushNamedNumber(L, &quot;reclaimUnitEnergyCostFactor&quot;,    modInfo.reclaimUnitEnergyCostFactor);
+	LuaPushNamedNumber(L, &quot;reclaimUnitEfficiency&quot;,          modInfo.reclaimUnitEfficiency);
+	LuaPushNamedNumber(L, &quot;reclaimFeatureEnergyCostFactor&quot;, modInfo.reclaimFeatureEnergyCostFactor);
+	LuaPushNamedBool(L,   &quot;reclaimAllowEnemies&quot;,            modInfo.reclaimAllowEnemies);
+	LuaPushNamedBool(L,   &quot;reclaimAllowAllies&quot;,             modInfo.reclaimAllowAllies);
+	LuaPushNamedNumber(L, &quot;repairEnergyCostFactor&quot;,         modInfo.repairEnergyCostFactor);
+	LuaPushNamedNumber(L, &quot;resurrectEnergyCostFactor&quot;,      modInfo.resurrectEnergyCostFactor);
+	LuaPushNamedNumber(L, &quot;captureEnergyCostFactor&quot;,        modInfo.captureEnergyCostFactor);
+
 	LuaPushNamedNumber(L, &quot;transportAir&quot;,    modInfo.transportAir);
 	LuaPushNamedNumber(L, &quot;transportShip&quot;,   modInfo.transportShip);
 	LuaPushNamedNumber(L, &quot;transportHover&quot;,  modInfo.transportHover);

Modified: trunk/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitDefs.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Lua/LuaUnitDefs.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -473,7 +473,7 @@
 static int ModelDefTable(lua_State* L, const void* data) {
 	const UnitModelDef&amp; md = *((const UnitModelDef*) data);
 	const char* type;
-	if (md.modelpath.find(&quot;.s3o&quot;) != string::npos) {
+	if (StringToLower(md.modelpath).find(&quot;.s3o&quot;) != string::npos) {
 		type = &quot;s3o&quot;;
 	} else {
 		type = &quot;3do&quot;;

Modified: trunk/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/BaseGroundDrawer.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -18,6 +18,7 @@
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
+#include &quot;System/FastMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 
@@ -25,7 +26,9 @@
 {
 	updateFov = true;
 
-	striptype = GL_TRIANGLE_STRIP;
+	LODScaleReflection = configHandler.GetFloat(&quot;GroundLODScaleReflection&quot;, 1.0f);
+	LODScaleRefraction = configHandler.GetFloat(&quot;GroundLODScaleRefraction&quot;, 1.0f);
+	LODScaleUnitReflection = configHandler.GetFloat(&quot;GroundLODScaleUnitReflection&quot;, 1.0f);
 
 	infoTexAlpha = 0.25f;
 	infoTex = 0;
@@ -295,7 +298,7 @@
 						if (myAirLos[alx + (aly * loshandler-&gt;airSizeX)]) {
 							float extractDepth = extractDepthMap[(y * gs-&gt;hmapx) + x];
 							// a single pow(x, 0.25) call would be faster?
-							infoTexMem[a*4]=(unsigned char)std::min(255.0f,(float)sqrt(sqrt(extractDepth))*900);
+							infoTexMem[a*4]=(unsigned char)std::min(255.0f,(float)fastmath::sqrt(fastmath::sqrt(extractDepth))*900);
 						} else {
 							infoTexMem[a*4]=0;
 						}

Modified: trunk/rts/Map/BaseGroundDrawer.h
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/BaseGroundDrawer.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -53,7 +53,10 @@
 	bool drawLineOfSight;
 	bool wireframe;
 
-	int striptype;
+	float LODScaleReflection;
+	float LODScaleRefraction;
+	float LODScaleUnitReflection;
+
 	GLuint infoTex;
 
 	unsigned char* infoTexMem;
@@ -66,16 +69,16 @@
 
 	int updateTextureState;
 
+	DrawMode drawMode;
+
 	float infoTexAlpha;
 
-	DrawMode drawMode;
-
 	int jamColor[3];
 	int losColor[3];
 	int radarColor[3];
 	int alwaysColor[3];
 	static const int losColorScale = 10000;
-	
+
 	bool highResLosTex;
 // 	bool smoothLosTex;
 

Modified: trunk/rts/Map/BasicMapDamage.cpp
===================================================================
--- trunk/rts/Map/BasicMapDamage.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/BasicMapDamage.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -5,6 +5,7 @@
 #include &quot;BaseGroundDrawer.h&quot;
 #include &quot;HeightMapTexture.h&quot;
 #include &quot;Rendering/Env/BaseTreeDrawer.h&quot;
+#include &quot;Rendering/Env/BaseWater.h&quot;
 #include &quot;TimeProfiler.h&quot;
 #include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -18,6 +19,7 @@
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 CBasicMapDamage::CBasicMapDamage(void)
 {
 	const int numQuads = qf-&gt;GetNumQuadsX() * qf-&gt;GetNumQuadsZ();
@@ -72,6 +74,7 @@
 	e-&gt;x2=std::min((int)(pos.x+radius)/SQUARE_SIZE,gs-&gt;mapx-3);
 	e-&gt;y1=std::max((int)(pos.z-radius)/SQUARE_SIZE,2);
 	e-&gt;y2=std::min((int)(pos.z+radius)/SQUARE_SIZE,gs-&gt;mapy-3);
+	e-&gt;squares.reserve((e-&gt;y2-e-&gt;y1+1)*(e-&gt;x2-e-&gt;x1+1));
 
 	float* heightmap = readmap-&gt;GetHeightmap();
 	float baseStrength=-pow(strength,0.6f)*3/mapHardness;
@@ -84,8 +87,8 @@
 				e-&gt;squares.push_back(0);
 				continue;
 			}
-			float dist=pos.distance2D(float3(x*SQUARE_SIZE,0,y*SQUARE_SIZE));							//calculate the distance
-			float relDist=dist*invRadius;																					//normalize distance
+			float dist=pos.distance2D(float3(x*SQUARE_SIZE,0,y*SQUARE_SIZE));	//calculate the distance
+			float relDist=dist*invRadius;	//normalize distance
 			float dif=baseStrength*craterTable[int(relDist*200)]*invHardness[readmap-&gt;typemap[(y/2)*gs-&gt;hmapx+x/2]];
 
 			float prevDif=heightmap[y*(gs-&gt;mapx+1)+x]-readmap-&gt;orgheightmap[y*(gs-&gt;mapx+1)+x];
@@ -152,12 +155,6 @@
 		}
 	}
 
-	/*int hy2=min(gs-&gt;hmapy-1,y2/2);
-	int hx2=min(gs-&gt;hmapx-1,x2/2);
-	for(int y=y1/2;y&lt;=hy2;y++)
-		for(int x=x1/2;x&lt;=hx2;x++)
-			readmap-&gt;mipHeightmap[1][y*gs-&gt;hmapx+x]=heightmap[(y*2+1)*(gs-&gt;mapx+1)+(x*2+1)];*/
-
 	float numHeightMipMaps = readmap-&gt;numHeightMipMaps - 1;
 	float** mipHeightmap = readmap-&gt;mipHeightmap;
 	for (int i = 0; i &lt; numHeightMipMaps; i++) {
@@ -168,12 +165,11 @@
 				height += mipHeightmap[i][(x)  +(y+1)*hmapx];
 				height += mipHeightmap[i][(x+1)+(y)  *hmapx];
 				height += mipHeightmap[i][(x+1)+(y+1)*hmapx];
-				mipHeightmap[i+1][(x/2)+(y/2)*hmapx/2] = height * 0.25f;
+				mipHeightmap[i+1][(x+(y*hmapx)/2)/2] = height * 0.25f;
 			}
 		}
 	}
 
-	float3 n1,n2,n3,n4;
 	int decy=std::max(0,y1-1);
 	int incy=std::min(gs-&gt;mapy-1,y2+1);
 	int decx=std::max(0,x1-1);
@@ -200,6 +196,7 @@
 		}
 	}
 
+	float* slopemap = readmap-&gt;slopemap;
 	for(int y = std::max(2,(y1&amp;0xfffffe)); y &lt;= std::min(gs-&gt;mapy-3,y2); y += 2) {
 		for(int x = std::max(2,(x1&amp;0xfffffe)); x &lt;= std::min(gs-&gt;mapx-3,x2); x += 2) {
 			float3 e1(-SQUARE_SIZE*4,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],0);
@@ -214,34 +211,38 @@
 			float3 n2 = e2.cross(e1);
 			n2.Normalize();
 
-			readmap-&gt;slopemap[(y/2)*gs-&gt;hmapx+(x/2)] = 1-(n.y+n2.y)*0.5f;
+			slopemap[(y/2)*gs-&gt;hmapx+(x/2)] = 1-(n.y+n2.y)*0.5f;
 		}
 	}
 
-	pathManager-&gt;TerrainChange(x1, y1, x2, y2);
-	featureHandler-&gt;TerrainChanged(x1, y1, x2, y2);
-	readmap-&gt;HeightmapUpdated(x1, x2, y1, y2);
-
 	decy = std::max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
 	incy = std::min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
 	decx = std::max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
 	incx = std::min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
 
+	const int numQuadsX = qf-&gt;GetNumQuadsX();
+	const int frameNum  = gs-&gt;frameNum;
+
 	for (int y = decy; y &lt;= incy; y++) {
 		for (int x = decx; x &lt;= incx; x++) {
-			if (inRelosQue[y*qf-&gt;GetNumQuadsX()+x]) {
+			if (inRelosQue[y*numQuadsX+x]) {
 				continue;
 			}
 			RelosSquare rs;
 			rs.x = x;
 			rs.y = y;
-			rs.neededUpdate = gs-&gt;frameNum;
+			rs.neededUpdate = frameNum;
 			rs.numUnits = qf-&gt;GetQuadAt(x, y).units.size();
 			relosSize += rs.numUnits;
-			inRelosQue[y*qf-&gt;GetNumQuadsX()+x] = true;
+			inRelosQue[y*numQuadsX+x] = true;
 			relosQue.push_back(rs);
 		}
 	}
+
+	pathManager-&gt;TerrainChange(x1, y1, x2, y2);
+	featureHandler-&gt;TerrainChanged(x1, y1, x2, y2);
+	readmap-&gt;HeightmapUpdated(x1, x2, y1, y2);
+	water-&gt;HeightmapChanged(x1, y1, x2, y2);
 	heightMapTexture.UpdateArea(x1, y1, x2, y2);
 }
 
@@ -255,7 +256,7 @@
 
 	for(ei=explosions.begin();ei!=explosions.end();++ei){
 		Explo* e=*ei;
-		if (e-&gt;ttl&lt;0) continue;
+		if (e-&gt;ttl&lt;=0) continue;
 		--e-&gt;ttl;
 
 		int x1=e-&gt;x1;
@@ -287,63 +288,14 @@
 				unit-&gt;midPos.y+=dif;
 			}
 		}
-		readmap-&gt;ExplosionUpdate(e-&gt;x1,e-&gt;x2,e-&gt;y1,e-&gt;y2);
 		if(e-&gt;ttl==0){
-			float3 pos=e-&gt;pos;
 			RecalcArea(x1-2,x2+2,y1-2,y2+2);
-	/*		for(int y=y1&gt;&gt;3;y&lt;=y2&gt;&gt;3;++y){
-				for(int x=x1&gt;&gt;3;x&lt;=x2&gt;&gt;3;++x){
-					if(!inRejuvQue[y][x]){
-						RejuvSquare rs;
-						rs.x=x;
-						rs.y=y;
-						rejuvQue.push_back(rs);
-						inRejuvQue[y][x]=true;
-					}
-				}
-			}*/
 		}
 	}
 	while(!explosions.empty() &amp;&amp; explosions.front()-&gt;ttl==0){
 		delete explosions.front();
 		explosions.pop_front();
 	}
-
-/*
-	nextRejuv+=rejuvQue.size()/300.0f;
-	while(nextRejuv&gt;0){
-		nextRejuv-=1;
-		int bx=rejuvQue.front().x;
-		int by=rejuvQue.front().y;
-		bool damaged=false;
-
-		for(int y=by*16;y&lt;by*16+16;++y){
-			for(int x=bx*16;x&lt;bx*16+16;++x){
-				if(readmap-&gt;damagemap[y*1024+x]!=0){
-					damaged=true;
-					if(readmap-&gt;damagemap[y*1024+x]&gt;5){
-						int hsquare=((y+1)/2)*(gs-&gt;mapx+1)+(x+1)/2;
-						readmap-&gt;heightmap[hsquare]-=(readmap-&gt;heightmap[hsquare]-readmap-&gt;orgheightmap[hsquare])*0.003f;
-						readmap-&gt;damagemap[y*1024+x]-=4;
-					} else {
-						readmap-&gt;damagemap[y*1024+x]=0;
-						if(readmap-&gt;typemap[(y/2)*512+x/2]&amp;128){
-							readmap-&gt;typemap[(y/2)*512+x/2]&amp;=127;
-							treeDrawer-&gt;ResetPos(float3(x*4,0,y*4));
-						}
-					}
-				}
-			}
-		}
-		if(damaged){
-			rejuvQue.push_back(rejuvQue.front());
-			RecalcArea(bx*8,bx*8+8,by*8,by*8+8);
-			readmap-&gt;RecalcTexture(bx*8,bx*8+8,by*8,by*8+8);
-		} else {
-			inRejuvQue[by][bx]=false;
-		}
-		rejuvQue.pop_front();
-	}*/
 	UpdateLos();
 }
 

Modified: trunk/rts/Map/BasicMapDamage.h
===================================================================
--- trunk/rts/Map/BasicMapDamage.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/BasicMapDamage.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -40,7 +40,7 @@
 	};
 	std::deque&lt;RelosSquare&gt; relosQue;
 
-	bool* inRelosQue;//todo supposes 512*512 map
+	bool* inRelosQue;
 	int relosSize;
 	int neededLosUpdate;
 	std::deque&lt;int&gt; relosUnits;

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/MapInfo.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -150,7 +150,7 @@
 	                                                float3(0.4f, 0.4f, 0.4f));
 	light.unitSunColor      = lightTable.GetFloat3(&quot;unitDiffuseColor&quot;,
 	                                                float3(0.7f, 0.7f, 0.7f));
-	light.specularSunColor = lightTable.GetFloat3(&quot;unitSpecularColor&quot;,
+	light.specularSunColor  = lightTable.GetFloat3(&quot;unitSpecularColor&quot;,
 	                                               light.unitSunColor);
 	light.unitShadowDensity = lightTable.GetFloat(&quot;unitShadowDensity&quot;, 0.8f);
 }
@@ -182,7 +182,7 @@
 	water.specularColor = wt.GetFloat3(&quot;specularColor&quot;, light.groundSunColor);
 
 	water.fresnelMin   = wt.GetFloat(&quot;fresnelMin&quot;,   0.2f);
-	water.fresnelMax   = wt.GetFloat(&quot;fresnelMax&quot;,   0.7f);
+	water.fresnelMax   = wt.GetFloat(&quot;fresnelMax&quot;,   0.8f);
 	water.fresnelPower = wt.GetFloat(&quot;fresnelPower&quot;, 4.0f);
 
 	water.reflDistortion = wt.GetFloat(&quot;reflectionDistortion&quot;, 1.0f);
@@ -198,6 +198,8 @@
 	water.foamTexture   = wt.GetString(&quot;foamTexture&quot;,   &quot;&quot;);
 	water.normalTexture = wt.GetString(&quot;normalTexture&quot;, &quot;&quot;);
 
+	water.shoreWaves = wt.GetBool(&quot;shoreWaves&quot;, true);
+
 	// use 'resources.lua' for missing fields  (our the engine defaults)
 	const LuaTable resGfxMaps = resRoot-&gt;SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
 
@@ -215,8 +217,16 @@
 
 	if (!water.normalTexture.empty()) {
 		water.normalTexture = &quot;maps/&quot; + water.normalTexture;
+		water.numTiles    = std::min(16,std::max(1,wt.GetInt(&quot;numTiles&quot;,1)));
 	} else {
 		water.normalTexture = &quot;bitmaps/&quot; + resGfxMaps.GetString(&quot;waternormaltex&quot;, &quot;waterbump.png&quot;);
+		if (resGfxMaps.KeyExists(&quot;waternormaltex&quot;)) {
+			water.numTiles = std::min(16,std::max(1,resGfxMaps.GetInt(&quot;numTiles&quot;,1)));
+		}else{
+			// default texture is a TileSet of 3x3
+			// user-defined textures are expected to be 1x1 (no DynWaves possible)
+			water.numTiles = 3;
+		}
 	}
 
 	// water caustic textures

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/MapInfo.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -116,7 +116,7 @@
 		float3 minColor;
 		float3 surfaceColor;
 		float  surfaceAlpha;
-		float3 planeColor;
+		float4 planeColor;
 		float3 diffuseColor;
 		float3 specularColor;
 		float  ambientFactor;
@@ -132,6 +132,8 @@
 		float  perlinStartFreq;
 		float  perlinLacunarity;
 		float  perlinAmplitude;
+		bool   shoreWaves;
+		unsigned char numTiles;
 		std::string texture;
 		std::string foamTexture;
 		std::string normalTexture;

Modified: trunk/rts/Map/ReadMap.h
===================================================================
--- trunk/rts/Map/ReadMap.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/ReadMap.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -67,7 +67,6 @@
 	virtual void HeightmapUpdated(int x1, int x2, int y1, int y2)=0;
 	virtual void Update(){};
 	virtual void Explosion(float x,float y,float strength){};
-	virtual void ExplosionUpdate(int x1,int x2,int y1,int y2){};
 	virtual GLuint GetShadingTexture () = 0; // a texture with RGB for shading and A for height
 	static inline unsigned char EncodeHeight(float h) { return std::max(0, (int)(255+10.0f*h)); }
 

Modified: trunk/rts/Map/SM3/Sm3GroundDrawer.cpp
===================================================================
--- trunk/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -69,8 +69,9 @@
 
 void CSm3GroundDrawer::Draw(bool drawWaterReflection,bool drawUnitReflection,unsigned int overrideVP)
 {
-	if(drawUnitReflection || drawWaterReflection)
-		return;
+	if (wireframe) {
+		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+	}
 
 	terrain::RenderContext *currc = rc;
 
@@ -136,6 +137,9 @@
 	glDisable(GL_LIGHT0);
 	glDisable(GL_LIGHTING);
 
+	if (wireframe) {
+		glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+	}
 
 	if (drawMode != drawNormal)
 	{

Modified: trunk/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- trunk/rts/Map/SM3/Sm3Map.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/SM3/Sm3Map.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -181,7 +181,6 @@
 
 void CSm3ReadMap::Update() {}
 void CSm3ReadMap::Explosion(float x,float y,float strength) {}
-void CSm3ReadMap::ExplosionUpdate(int x1,int x2,int y1,int y2) {}
 GLuint CSm3ReadMap::GetShadingTexture () { return 0; } // a texture with RGB for shading and A for height
 void CSm3ReadMap::DrawMinimap ()
 {

Modified: trunk/rts/Map/SM3/Sm3Map.h
===================================================================
--- trunk/rts/Map/SM3/Sm3Map.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/SM3/Sm3Map.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -25,7 +25,6 @@
 	float* GetHeightmap();
 	void Update();
 	void Explosion(float x,float y,float strength);
-	void ExplosionUpdate(int x1,int x2,int y1,int y2);
 	GLuint GetShadingTexture (); // a texture with RGB for shading and A for height
 	void DrawMinimap (); // draw the minimap in a quad (with extends: (0,0)-(1,1))
 

Modified: trunk/rts/Map/SM3/terrain/Terrain.cpp
===================================================================
--- trunk/rts/Map/SM3/terrain/Terrain.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/SM3/terrain/Terrain.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -51,9 +51,6 @@
 
 	using namespace std;
 
-	// debug stuff
-	bool fill=true;
-
 	Config::Config()
 	{
 		cacheTextures=false;
@@ -592,14 +589,9 @@
 
 	void Terrain::Draw ()
 	{
-		if (!fill)
-			glPolygonMode (GL_FRONT_AND_BACK,GL_LINE);
-		else {
-			glPolygonMode (GL_FRONT_AND_BACK,GL_FILL);
+		const float diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f };
+		glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, diffuse);
 
-			const float diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f };
-			glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, diffuse);
-		}
 		glEnable(GL_CULL_FACE);
 		glColor3f(1.0f,1.0f,1.0f);
 
@@ -647,23 +639,21 @@
 
 			glEnable(GL_DEPTH_TEST);
 
-			if (fill) texturing-&gt;BeginTexturing();
+			texturing-&gt;BeginTexturing();
 
-			if (!fill) numPasses=1;
+			numPasses=1;
 			for (int pass=0;pass&lt;numPasses;pass++)
 			{
 				bool skipNodes=false;
 
-				if (fill)
-					texturing-&gt;BeginPass(pass);
+				texturing-&gt;BeginPass(pass);
 
 				for (int a=0;a&lt;activeRC-&gt;quads.size();a++)
 				{
 					TQuad *q = activeRC-&gt;quads[a].quad;
 
 					// Setup node texturing
-					if (fill)
-						skipNodes = !texturing-&gt;SetupNode (q, pass);
+					skipNodes = !texturing-&gt;SetupNode (q, pass);
 
 					assert (q-&gt;renderData);
 
@@ -673,20 +663,17 @@
 					}
 				}
 
-				if (fill) texturing-&gt;EndPass();
+				texturing-&gt;EndPass();
 			}
 
 			glDisable (GL_BLEND);
 			glDepthMask (GL_TRUE);
 
-			if (fill)
-				texturing-&gt;EndTexturing ();
+			texturing-&gt;EndTexturing ();
 		}
 
 		if (debugQuad)
 			DrawNormals (debugQuad, lowdetailhm-&gt;GetLevel (debugQuad-&gt;depth));
-
-		glPolygonMode (GL_FRONT_AND_BACK,GL_FILL);
 	}
 
 	void Terrain::CalcRenderStats (RenderStats&amp; stats, RenderContext *ctx)
@@ -840,10 +827,6 @@
 
 	void Terrain::DebugEvent (const std::string&amp; event)
 	{
-		if (event == &quot;t_toggle_fill&quot;) {
-			fill=!fill;
-			return;
-		}
 		if (event == &quot;t_detail_inc&quot;)
 			config.detailMod *= 1.2f;
 		if (event == &quot;t_detail_dec&quot;)

Modified: trunk/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/SMF/BFGroundDrawer.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/SMF/BFGroundDrawer.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -12,6 +12,7 @@
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
+#include &quot;System/FastMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 #ifdef USE_GML
@@ -26,7 +27,8 @@
 	bigSquareSize(128),
 	numBigTexX(gs-&gt;mapx / bigSquareSize),
 	numBigTexY(gs-&gt;mapy / bigSquareSize),
-	heightDataX(gs-&gt;mapx + 1)
+	heightDataX(gs-&gt;mapx + 1),
+	maxIdx(((gs-&gt;mapx + 1) * (gs-&gt;mapy + 1)) - 1)
 {
 	map = rm;
 
@@ -66,31 +68,61 @@
 }
 
 
+inline void CBFGroundDrawer::DrawWaterPlane(bool drawWaterReflection) {
+	if (!drawWaterReflection) {
+		glDisable(GL_TEXTURE_2D);
 
-inline void CBFGroundDrawer::DrawVertexA(int x, int y)
-{
-	float height = heightData[y * heightDataX + x];
-	if (waterDrawn &amp;&amp; height &lt; 0) {
-		height *= 2;
-	}
+		const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
+		const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
+		const bool  camOutMap = (camera-&gt;pos.x &lt; 0 || camera-&gt;pos.z &lt; 0 || camera-&gt;pos.x &gt; float3::maxxpos || camera-&gt;pos.z &gt; float3::maxzpos);
 
-	va-&gt;AddVertex0(float3(x * SQUARE_SIZE, height, y * SQUARE_SIZE));
-}
+		CVertexArray *va = GetVertexArray();
+		va-&gt;Initialize();
 
-inline void CBFGroundDrawer::DrawVertexA(int x, int y, float height)
-{
-	if (waterDrawn &amp;&amp; height &lt; 0) {
-		height *= 2;
+		unsigned char fogColor[4] = {
+		  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[0]),
+		  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[1]),
+		  (unsigned char)(255 * mapInfo-&gt;atmosphere.fogColor[2]),
+		  255
+		};
+
+		unsigned char planeColor[4] = {
+		  (unsigned char)(255 * mapInfo-&gt;water.planeColor[0]),
+		  (unsigned char)(255 * mapInfo-&gt;water.planeColor[1]),
+		  (unsigned char)(255 * mapInfo-&gt;water.planeColor[2]),
+		   255
+		};
+
+		const float alphainc = fastmath::PI2 / 32;
+		float alpha,r1,r2;
+		float3 p(0.0f,-200.0f,0.0f);
+		const float size = std::min(xsize,ysize);
+		for (int n = (camOutMap) ? 0 : 1; n &lt; 4 ; ++n) {
+			if ((n==1) &amp;&amp; !camOutMap) {
+				r1 = 2 * size;
+			}else{
+				r1 = n*n * size;
+			}
+			if (n==3) {
+				r2 = (n+0.5)*(n+0.5) * size;
+			}else{
+				r2 = (n+1)*(n+1) * size;
+			}
+			for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
+				p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
+				p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
+				va-&gt;AddVertexC(p, planeColor );
+				p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
+				p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
+				va-&gt;AddVertexC(p, (n==3) ? fogColor : planeColor);
+			}
+		}
+
+		va-&gt;DrawArrayC(GL_TRIANGLE_STRIP);
 	}
-	va-&gt;AddVertex0(float3(x * SQUARE_SIZE, height, y * SQUARE_SIZE));
 }
 
-inline void CBFGroundDrawer::EndStrip()
-{
-	va-&gt;EndStrip();
-}
 
-
 inline void CBFGroundDrawer::DrawVertexAQ(CVertexArray *ma, int x, int y)
 {
 	float height = heightData[y * heightDataX + x];
@@ -114,12 +146,13 @@
 	ma-&gt;EndStripQ();
 }
 
+
 inline bool CBFGroundDrawer::BigTexSquareRowVisible(int bty) {
 	static int mapWidth = (gs-&gt;mapx &lt;&lt; 3);
 	static int bigTexH = (gs-&gt;mapy &lt;&lt; 3) / numBigTexY;
 
-	const int minx =                   0;
-	const int maxx =            mapWidth;
+	const int minx =             0;
+	const int maxx =      mapWidth;
 	const int minz = bty * bigTexH;
 	const int maxz = minz + bigTexH;
 	const float miny = readmap-&gt;minheight;
@@ -132,68 +165,30 @@
 }
 
 
-
-inline void CBFGroundDrawer::DrawWaterPlane(bool drawWaterReflection) {
-	if (!drawWaterReflection) {
-		glDisable(GL_TEXTURE_2D);
-		glColor3f(mapInfo-&gt;water.planeColor.x, mapInfo-&gt;water.planeColor.y, mapInfo-&gt;water.planeColor.z);
-		glBegin(GL_QUADS);
-
-		static const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
-		static const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
-		const bool camOutMap = (camera-&gt;pos.x &lt; 0 || camera-&gt;pos.z &lt; 0 || camera-&gt;pos.x &gt; float3::maxxpos || camera-&gt;pos.z &gt; float3::maxzpos);
-
-		for (int y = -4; y &lt; 8; ++y) {
-			for (int x = -4; x &lt; 8; ++x) {
-				if (x &gt; 3 || x &lt; 0 || y &gt; 3 || y &lt; 0 || camOutMap) {
-					glVertex3f( x      * xsize, -200,  y      * ysize);
-					glVertex3f((x + 1) * xsize, -200,  y      * ysize);
-					glVertex3f((x + 1) * xsize, -200, (y + 1) * ysize);
-					glVertex3f( x      * xsize, -200, (y + 1) * ysize);
-				}
-			}
-		}
-		glEnd();
-	}
-}
-
-inline void CBFGroundDrawer::DrawGroundVertexArray()
-{
-	va-&gt;DrawArray0(GL_TRIANGLE_STRIP);
-	va = GetVertexArray();
-	va-&gt;Initialize();
-}
-
-
 inline void CBFGroundDrawer::DrawGroundVertexArrayQ(CVertexArray * &amp;ma)
 {
 	ma-&gt;DrawArray0(GL_TRIANGLE_STRIP);
 	ma = GetVertexArray();
-	ma-&gt;Initialize();
 }
 
-int neededLod=0;
-int maxIdx=0;
+#define CLAMP(i) std::max(0, std::min((i), maxIdx))
 
 inline void CBFGroundDrawer::DoDrawGroundRow(int bty, unsigned int overrideVP) {
-#define CLAMP(i) std::max(0, std::min((i), maxIdx))
 	if (!BigTexSquareRowVisible(bty)) {
 		// skip this entire row of squares if we can't see it
 		return;
 	}
 
 	CVertexArray *ma = GetVertexArray();
-	ma-&gt;Initialize();
 
 	bool inStrip = false;
+	float x0, x1;
 	int x,y;
-	// only process the necessary big squares in the x direction
 	int sx = 0;
 	int ex = numBigTexX;
-	float x0, x1;
 	std::vector&lt;fline&gt;::iterator fli;
 
-
+	// only process the necessary big squares in the x direction
 	for (fli = left.begin(); fli != left.end(); fli++) {
 		x0 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir *  (bty * bigSquareSize)                 ));
 		x1 = ((fli-&gt;base / SQUARE_SIZE + fli-&gt;dir * ((bty * bigSquareSize) + bigSquareSize)));
@@ -234,6 +229,8 @@
 			glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 11, -btx, -bty, 0, 0);
 		}
 
+		ma-&gt;Initialize();
+
 		for (int lod = 1; lod &lt; neededLod; lod &lt;&lt;= 1) {
 			float cx2 = (cam2-&gt;pos.x / (SQUARE_SIZE));
 			float cy2 = (cam2-&gt;pos.z / (SQUARE_SIZE));
@@ -318,7 +315,7 @@
 							DrawVertexAQ(ma, x + lod, y      );
 							DrawVertexAQ(ma, x + lod, y + lod);
 					} else {
-						// inre begr&#65533;sning mot f&#65533;eg&#65533;nde lod
+						// inre begr?sning mot f?eg?nde lod
 						if ((x &gt;= (cx) + viewRadius * hlod)) {
 							int idx1 = CLAMP((y       ) * heightDataX + x), idx1LOD = CLAMP(idx1 + lod), idx1HLOD = CLAMP(idx1 + hlod);
 							int idx2 = CLAMP((y +  lod) * heightDataX + x), idx2LOD = CLAMP(idx2 + lod), idx2HLOD = CLAMP(idx2 + hlod);
@@ -451,7 +448,7 @@
 			int nloop=(yed-yst)/lod+1;
 			ma-&gt;EnlargeArrays(8*nloop, 2*nloop);
 
-			// rita yttre begr&#65533;snings yta mot n&#65533;ta lod
+			// rita yttre begr?snings yta mot n?ta lod
 			if (maxlx &lt; maxtx &amp;&amp; maxlx &gt;= mintx) {
 				x = maxlx;
 				for (y = yst; y &lt; yed; y += lod) {
@@ -653,18 +650,20 @@
 	int baseViewRadius = max(4, viewRadius);
 
 	if (drawUnitReflection) {
-		viewRadius = (viewRadius &gt;&gt; 1) &amp; 0xfffffe;
+		viewRadius = ((int)(viewRadius * LODScaleUnitReflection)) &amp; 0xfffffe;
 	}
+	if (drawWaterReflection) {
+		viewRadius = ((int)(viewRadius * LODScaleReflection)) &amp; 0xfffffe;
+	}
+	//if (drawWaterRefraction) {
+	//	viewRadius = ((int)(viewRadius * LODScaleRefraction)) &amp; 0xfffffe;
+	//}
 
 	float zoom = 45.0f / camera-&gt;GetFov();
 	viewRadius = (int) (viewRadius * sqrt(zoom));
 	viewRadius += (viewRadius &amp; 1);
 
-	va = GetVertexArray();
-	va-&gt;Initialize();
-
 	neededLod = int((gu-&gt;viewRange * 0.125f) / viewRadius) &lt;&lt; 1;
-	maxIdx = ((gs-&gt;mapx + 1) * (gs-&gt;mapy + 1)) - 1;
 
 	UpdateCamRestraints();
 
@@ -703,7 +702,7 @@
 		glDisable(GL_ALPHA_TEST);
 	}
 
-	if (mapInfo-&gt;hasWaterPlane) {
+	if (mapInfo-&gt;hasWaterPlane &amp;&amp; waterplane) {
 		DrawWaterPlane(drawWaterReflection);
 	}
 
@@ -828,7 +827,7 @@
 					}
 					DrawVertexAQ(ma, x + lod, y      );
 					DrawVertexAQ(ma, x + lod, y + lod);
-			} else {  //inre begr&#65533;sning mot f&#65533;eg&#65533;nde lod
+			} else {  //inre begr?sning mot f?eg?nde lod
 				if((x&gt;=(cx)+viewRadius*hlod)){
 					float h1=(heightData[(y)*heightDataX+x]+heightData[(y+lod)*heightDataX+x])*0.5f*(1-oldcamxpart)+heightData[(y+hlod)*heightDataX+x]*(oldcamxpart);
 					float h2=(heightData[(y)*heightDataX+x]+heightData[(y)*heightDataX+x+lod])*0.5f*(1-oldcamxpart)+heightData[(y)*heightDataX+x+hlod]*(oldcamxpart);
@@ -943,7 +942,7 @@
 	int yed=min(yend + lod, maxty);
 	int nloop=(yed-yst)/lod+1;
 	ma-&gt;EnlargeArrays(8*nloop, 2*nloop);
-	//rita yttre begr&#65533;snings yta mot n&#65533;ta lod
+	//rita yttre begr?snings yta mot n?ta lod
 	if(maxlx&lt;maxtx &amp;&amp; maxlx&gt;=mintx){
 		x=maxlx;
 		for(y=yst;y&lt;yed;y+=lod){
@@ -1043,20 +1042,12 @@
 
 void CBFGroundDrawer::DrawShadowPass(void)
 {
-	va = GetVertexArray();
-	va-&gt;Initialize();
-
 //	glEnable(GL_CULL_FACE);
-	bool inStrip = false;
 	const int NUM_LODS = 4;
 
 	glPolygonOffset(1, 1);
 	glEnable(GL_POLYGON_OFFSET_FILL);
 
-	int x,y;
-	float camxpart = 0.0f, oldcamxpart;
-	float camypart = 0.0f, oldcamypart;
-
 	glBindProgramARB(GL_VERTEX_PROGRAM_ARB, groundShadowVP);
 	glEnable(GL_VERTEX_PROGRAM_ARB);
 
@@ -1256,9 +1247,9 @@
 		b.z = 0.0001f;
 
 	{
-		temp.dir = b.x / b.z;				// set direction to that
-		float3 c = b.cross(side);			// get vector from camera to collision line
-		float3 colpoint;					// a point on the collision line
+		temp.dir = b.x / b.z;      // set direction to that
+		float3 c = b.cross(side);  // get vector from camera to collision line
+		float3 colpoint;           // a point on the collision line
 
 		if (side.y &gt; 0)
 			colpoint = cam2-&gt;pos - c * ((cam2-&gt;pos.y - (readmap-&gt;minheight - 100)) / c.y);
@@ -1298,9 +1289,9 @@
 	float3 b = up.cross(camHorizontal);
 
 	if (fabs(b.z) &gt; 0.0001f) {
-		temp.dir = b.x / b.z;					// set direction to that
-		float3 c = b.cross(camHorizontal);		// get vector from camera to collision line
-		float3 colpoint;						// a point on the collision line
+		temp.dir = b.x / b.z;               // set direction to that
+		float3 c = b.cross(camHorizontal);  // get vector from camera to collision line
+		float3 colpoint;                    // a point on the collision line
 
 		if (side.y &gt; 0)
 			colpoint = cam2-&gt;pos + camHorizontal * gu-&gt;viewRange * 1.05f - c * (cam2-&gt;pos.y / c.y);

Modified: trunk/rts/Map/SMF/BFGroundDrawer.h
===================================================================
--- trunk/rts/Map/SMF/BFGroundDrawer.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Map/SMF/BFGroundDrawer.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -36,12 +36,13 @@
 	const int bigSquareSize;
 	const int numBigTexX;
 	const int numBigTexY;
+	const int maxIdx;
 
+	int neededLod;
+
 	float* heightData;
 	const int heightDataX;
 
-	CVertexArray* va;
-
 	struct fline {
 		float base;
 		float dir;
@@ -66,12 +67,8 @@
 	void DoDrawGroundShadowLOD(int nlod);
 	static void DoDrawGroundShadowLODMT(void *c,int nlod) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundShadowLOD(nlod);}
 
-	inline void DrawVertexA(int x, int y);
-	inline void DrawVertexA(int x, int y, float height);
-	inline void EndStrip();
 	inline void DrawWaterPlane(bool);
 	inline bool BigTexSquareRowVisible(int);
-	inline void DrawGroundVertexArray();
 	void SetupTextureUnits(bool drawReflection, unsigned int overrideVP);
 	void ResetTextureUnits(bool drawReflection, unsigned int overrideVP);
 
@@ -80,3 +77,4 @@
 };
 
 #endif // __BF_GROUND_DRAWER_H__
+

Modified: trunk/rts/Rendering/Env/BaseWater.h
===================================================================
--- trunk/rts/Rendering/Env/BaseWater.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/Env/BaseWater.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -12,6 +12,7 @@
 	virtual void Draw()=0;
 	virtual void Update(){};
 	virtual void UpdateWater(CGame* game)=0;
+	virtual void HeightmapChanged(const int x1, const int y1, const int x2, const int y2){};
 	virtual void AddExplosion(const float3&amp; pos, float strength, float size){};
 	virtual int  GetID() const { return -1; }
 

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -9,45 +9,49 @@
 
 #include &quot;StdAfx.h&quot;
 #include &quot;bitops.h&quot;
-#include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;BumpWater.h&quot;
+#include &quot;BaseSky.h&quot;
 #include &quot;Game/Game.h&quot;
+#include &quot;Game/Camera.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;Game/Camera.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
-#include &quot;LogOutput.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
-#include &quot;BaseSky.h&quot;
-#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;System/FastMath.h&quot;
 #include &quot;System/EventHandler.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
+#include &quot;TimeProfiler.h&quot;
+#include &quot;LogOutput.h&quot;
 #include &lt;boost/format.hpp&gt;
 
 using std::string;
 using std::vector;
+using std::min;
+using std::max;
 
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/// HELPER FUNCTIONS
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 static void PrintShaderLog(GLuint obj, const string&amp; type)
 {
-	// WAS COMPILATION SUCCESSFUL ?
+	/** WAS COMPILATION SUCCESSFUL ? **/
 	GLint compiled;
 	if(glIsShader(obj))
 		glGetShaderiv(obj,GL_COMPILE_STATUS,&amp;compiled);
 	else
-		glGetProgramiv(obj,GL_COMPILE_STATUS,&amp;compiled);
+		glGetProgramiv(obj,GL_LINK_STATUS,&amp;compiled);
 
 	if (compiled) return;
 
-	// GET INFOLOG
+	/** GET INFOLOG **/
 	int infologLength = 0;
 	int maxLength;
 
@@ -66,7 +70,7 @@
 	if (infologLength &gt; 0) {
 		string str(infoLog, infologLength);
 		delete[] infoLog;
-		// string size is limited with content_error()
+		//! string size is limited with content_error()
 		logOutput.Print(&quot;BumpWater shader error (&quot; + type  + &quot;): &quot; + str);
 		throw content_error(string(&quot;BumpWater shader error!&quot;));
 	}
@@ -106,6 +110,7 @@
 	}
 }
 
+
 static string LoadShaderSource(const string&amp; file)
 {
 	CFileHandler fh(file);
@@ -117,27 +122,32 @@
 	return text;
 }
 
+
 static void GLSLDefineConstf4(string&amp; str, const string&amp; name, const float3&amp; v, const float&amp; alpha)
 {
 	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec4(%1$.12f,%2$.12f,%3$.12f,%4$.12f)\n&quot;) % (v.x) % (v.y) % (v.z) % (alpha));
 }
 
+
 static void GLSLDefineConstf3(string&amp; str, const string&amp; name, const float3&amp; v)
 {
 	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec3(%1$.12f,%2$.12f,%3$.12f)\n&quot;) % (v.x) % (v.y) % (v.z));
 }
 
+
 static void GLSLDefineConstf2(string&amp; str, const string&amp; name, const float&amp; x, const float&amp; y)
 {
 	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; vec2(%1$.12f,%2$.12f)\n&quot;) % x % y);
 }
 
+
 static void GLSLDefineConstf1(string&amp; str, const string&amp; name, const float&amp; x)
 {
 	str += boost::str(boost::format(string(&quot;#define &quot;)+name+&quot; %1$.12f\n&quot;) % x);
 }
 
-static GLuint LoadTexture(const string&amp; filename, const float anisotropy = 0.0f)
+
+static GLuint LoadTexture(const string&amp; filename, const float anisotropy = 0.0f, int* sizeX = NULL, int* sizeY = NULL)
 {
 	GLuint texID;
 	CBitmap bm;
@@ -146,25 +156,39 @@
 
 	glGenTextures(1, &amp;texID);
 	glBindTexture(GL_TEXTURE_2D, texID);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
 	if (anisotropy &gt; 0.0f)
 		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
-	glBuildMipmaps(GL_TEXTURE_2D, GLEW_ARB_texture_compression?GL_COMPRESSED_RGBA_ARB:GL_RGBA8, bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+	glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, bm.xsize, bm.ysize, GL_RGBA, GL_UNSIGNED_BYTE, bm.mem);
+
+	if (sizeY != NULL) {
+		*sizeX = bm.xsize;
+		*sizeY = bm.ysize;
+	}
+
 	return texID;
 }
 
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/// (DE-)CONSTRUCTOR
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
 CBumpWater::CBumpWater()
 {
 	/** LOAD USER CONFIGS **/
-	reflTexSize = next_power_of_2(configHandler.GetInt(&quot;BumpWaterTexSizeReflection&quot;, 256));
-	reflection  = !!configHandler.GetInt(&quot;BumpWaterReflection&quot;, 1);
-	refraction  = configHandler.GetInt(&quot;BumpWaterRefraction&quot;, 1);  //0:=off, 1:=screencopy, 2:=own rendering cycle
-	shorewaves  = !!configHandler.GetInt(&quot;BumpWaterShoreWaves&quot;, 0);
-	anisotropy  = atof(configHandler.GetString(&quot;BumpWaterAnisotropy&quot;, &quot;0.0&quot;).c_str());
-	depthCopy   = !!configHandler.GetInt(&quot;BumpWaterUseDepthTexture&quot;, 1);
-	depthBits   = configHandler.GetInt(&quot;BumpWaterDepthBits&quot;, 24);
-	blurRefl    = !!configHandler.GetInt(&quot;BumpWaterBlurReflection&quot;, 0);
+	reflTexSize  = next_power_of_2(configHandler.GetInt(&quot;BumpWaterTexSizeReflection&quot;, 512));
+	reflection   = !!configHandler.GetInt(&quot;BumpWaterReflection&quot;, 1);
+	refraction   = configHandler.GetInt(&quot;BumpWaterRefraction&quot;, 1);  /// 0:=off, 1:=screencopy, 2:=own rendering cycle
+	anisotropy   = atof(configHandler.GetString(&quot;BumpWaterAnisotropy&quot;, &quot;0.0&quot;).c_str());
+	depthCopy    = !!configHandler.GetInt(&quot;BumpWaterUseDepthTexture&quot;, 1);
+	depthBits    = configHandler.GetInt(&quot;BumpWaterDepthBits&quot;, 24);
+	blurRefl     = !!configHandler.GetInt(&quot;BumpWaterBlurReflection&quot;, 0);
+	shoreWaves   = (!!configHandler.GetInt(&quot;BumpWaterShoreWaves&quot;, 1)) &amp;&amp; mapInfo-&gt;water.shoreWaves;
+	endlessOcean = (!!configHandler.GetInt(&quot;BumpWaterEndlessOcean&quot;, 1)) &amp;&amp; mapInfo-&gt;hasWaterPlane;
+	dynWaves     = (!!configHandler.GetInt(&quot;BumpWaterDynamicWaves&quot;, 1)) &amp;&amp; (mapInfo-&gt;water.numTiles&gt;1);
 
 	if (refraction&gt;1)
 		drawSolid = true;
@@ -174,15 +198,86 @@
 	if (!GL_ARB_shading_language_100)
 		throw content_error(&quot;BumpWater: your hardware/driver setup does not support GLSL.&quot;);
 
-	if (!(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle))
-		refraction = 0;
+	shoreWaves = shoreWaves &amp;&amp; (GLEW_EXT_framebuffer_object);
+	dynWaves   = dynWaves &amp;&amp; (GLEW_EXT_framebuffer_object &amp;&amp; GLEW_ARB_imaging);
 
-	shorewaves = shorewaves &amp;&amp; (GLEW_EXT_framebuffer_object);
 
+	/** LOAD TEXTURES **/
+	foamTexture     = LoadTexture( mapInfo-&gt;water.foamTexture );
+	normalTexture   = LoadTexture( mapInfo-&gt;water.normalTexture , anisotropy , &amp;normalTextureX, &amp;normalTextureY);
 
+	//! caustic textures
+	const vector&lt;string&gt;&amp; causticNames = mapInfo-&gt;water.causticTextures;
+	if (causticNames.size() &lt;= 0) {
+		throw content_error(&quot;no caustic textures&quot;);
+	}
+	for (int i = 0; i &lt; (int)causticNames.size(); ++i) {
+		caustTextures.push_back(LoadTexture(causticNames[i]));
+	}
+
+
+	/** SHOREWAVES **/
+	if (shoreWaves) {
+		pboID = 0;
+		if (GLEW_EXT_pixel_buffer_object) {
+			glGenBuffers(1, &amp;pboID);
+		}
+
+		coastmapNeedUpload=false;
+		coastmapNeedUpdate=false;
+		coastUploadX1 = (int)1e9;
+		coastUploadX2 = -1;
+		coastUploadZ1 = (int)1e9;
+		coastUploadZ2 = -1;
+
+		waveRandTexture = LoadTexture( &quot;bitmaps/shorewaverand.bmp&quot; );
+
+		glGenTextures(2, coastTexture);
+		glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, NULL);
+		glGenerateMipmapEXT(GL_TEXTURE_2D);
+
+		glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, NULL);
+
+		const string fsSource = LoadShaderSource(&quot;shaders/bumpWaterCoastBlurFS.glsl&quot;);
+		const GLchar* fsSourceStr = fsSource.c_str();
+		blurFP = glCreateShader(GL_FRAGMENT_SHADER);
+		glShaderSource(blurFP, 1, &amp;fsSourceStr, NULL);
+		glCompileShader(blurFP);
+		PrintShaderLog(blurFP, &quot;blurFP&quot;);
+
+		blurShader = glCreateProgram();
+		glAttachShader(blurShader, blurFP);
+		glLinkProgram(blurShader);
+		PrintShaderLog(blurShader, &quot;blurShader&quot;);
+		blurDirLoc = glGetUniformLocation(blurShader, &quot;blurDir&quot;);
+		blurTexLoc = glGetUniformLocation(blurShader, &quot;texture&quot;);
+
+		glGenFramebuffersEXT(1,&amp;coastFBO);
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coastTexture[0], 0);
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, coastTexture[1], 0);
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+		//! initialize
+		UploadCoastline(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+		UpdateCoastmap(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+	}
+
+
 	/** CREATE TEXTURES **/
-	if (refraction&gt;0 || depthCopy) {
-		if(GLEW_ARB_texture_rectangle || GLEW_EXT_texture_rectangle) {
+	if ((refraction&gt;0) || depthCopy) {
+		//! ati's don't have glsl support for texrects
+		if (GLEW_ARB_texture_rectangle &amp;&amp; !GLEW_ATI_envmap_bumpmap) {
 			target = GL_TEXTURE_RECTANGLE_ARB;
 			screenTextureX = gu-&gt;viewSizeX;
 			screenTextureY = gu-&gt;viewSizeY;
@@ -194,23 +289,23 @@
 	}
 
 	if (refraction&gt;0) {
-		// CREATE REFRACTION TEXTURE
+		//! CREATE REFRACTION TEXTURE
 		glGenTextures(1, &amp;refractTexture);
 		glBindTexture(target, refractTexture);
 		glTexParameteri(target,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
 		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
 		if (GLEW_EXT_texture_edge_clamp) {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+			glTexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+			glTexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 		} else {
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+			glTexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP);
+			glTexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP);
 		}
 		glTexImage2D(target, 0, GL_RGBA8, screenTextureX, screenTextureY, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
 	}
 
 	if (reflection) {
-		// CREATE REFLECTION TEXTURE
+		//! CREATE REFLECTION TEXTURE
 		glGenTextures(1, &amp;reflectTexture);
 		glBindTexture(GL_TEXTURE_2D, reflectTexture);
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
@@ -226,12 +321,13 @@
 	}
 
 	if (depthCopy) {
+		//! CREATE DEPTH TEXTURE
 		glGenTextures(1, &amp;depthTexture);
 		glBindTexture(target, depthTexture);
 		glTexParameteri(target,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
 		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
-		GLuint depthFormat = GL_DEPTH_COMPONENT;
-		switch (gu-&gt;depthBufferBits) {
+		GLuint depthFormat = GL_DEPTH_COMPONENT; 
+		switch (gu-&gt;depthBufferBits) { /// use same depth as screen framebuffer
 			case 16: depthFormat = GL_DEPTH_COMPONENT16; break;
 			case 24: depthFormat = GL_DEPTH_COMPONENT24; break;
 			case 32: depthFormat = GL_DEPTH_COMPONENT32; break;
@@ -239,7 +335,26 @@
 		glTexImage2D(target, 0, depthFormat, screenTextureX, screenTextureY, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
 	}
 
+	if (dynWaves) {
+		//! SETUP DYNAMIC WAVES
+		tileOffsets = SAFE_NEW unsigned char[mapInfo-&gt;water.numTiles * mapInfo-&gt;water.numTiles];
 
+		normalTexture2 = normalTexture;
+		glBindTexture(target, normalTexture2);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, 0.0);
+
+		glGenTextures(1, &amp;normalTexture);
+		glBindTexture(GL_TEXTURE_2D, normalTexture);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		if (anisotropy&gt;0.0f)
+			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anisotropy);
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, normalTextureX, normalTextureY, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+		glGenerateMipmapEXT(GL_TEXTURE_2D);
+	}
+
 	/** CREATE FBOs **/
 	if (GLEW_EXT_framebuffer_object) {
 		GLuint depthRBOFormat = GL_DEPTH_COMPONENT;
@@ -287,52 +402,32 @@
 			}
 		}
 
-	}
+		if (dynWaves) {
+			glGenFramebuffersEXT(1,&amp;dynWavesFBO);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
+			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, normalTexture, 0);
+			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
+				PrintFboError(&quot;dynamicWaves&quot;,status);
+				glDeleteFramebuffersEXT(1,  &amp;dynWavesFBO);
+				dynWavesFBO = 0;
+			}else{
+				UpdateDynWaves(true); //! initialize
+			}
+		}
 
-
-	/** LOAD TEXTURES **/
-	foamTexture     = LoadTexture( mapInfo-&gt;water.foamTexture );
-	normalTexture   = LoadTexture( mapInfo-&gt;water.normalTexture , anisotropy );
-
-	// caustic textures
-	const vector&lt;string&gt;&amp; causticNames = mapInfo-&gt;water.causticTextures;
-	if (causticNames.size() &lt;= 0) {
-		throw content_error(&quot;no caustic textures&quot;);
 	}
-	for (int i = 0; i &lt; (int)causticNames.size(); i++) {
-		caustTextures.push_back(LoadTexture(causticNames[i]));
-	}
 
-	if (shorewaves) {
-		waveRandTexture = LoadTexture( &quot;bitmaps/shorewaverand.bmp&quot; );
 
-		const string fsSource = LoadShaderSource(&quot;shaders/bumpWaterCoastBlurFS.glsl&quot;);
-		const GLchar* fsSourceStr = fsSource.c_str();
-		blurFP = glCreateShader(GL_FRAGMENT_SHADER);
-		glShaderSource(blurFP, 1, &amp;fsSourceStr, NULL);
-		glCompileShader(blurFP);
-		PrintShaderLog(blurFP, &quot;blurFP&quot;);
-
-		blurShader = glCreateProgram();
-		glAttachShader(blurShader, blurFP);
-		glLinkProgram(blurShader);
-		PrintShaderLog(blurShader, &quot;blurShader&quot;);
-		blurDirLoc    = glGetUniformLocation(blurShader, &quot;blurDir&quot;);
-		GLuint texLoc = glGetUniformLocation(blurShader, &quot;tex0&quot;);
-		glUniform1i(texLoc, 0);
-
-		glGenFramebuffersEXT(1,&amp;coastFBO);
-		GenerateCoastMap();
-	}
-
-
 	/** DEFINE SOME SHADER RUNTIME CONSTANTS (I don't use Uniforms for that, because the glsl compiler can't optimize those!) **/
 	string definitions;
 	if (reflection)   definitions += &quot;#define use_reflection\n&quot;;
 	if (refraction&gt;0) definitions += &quot;#define use_refraction\n&quot;;
-	if (shorewaves)   definitions += &quot;#define use_shorewaves\n&quot;;
+	if (shoreWaves)   definitions += &quot;#define use_shorewaves\n&quot;;
 	if (depthCopy)    definitions += &quot;#define use_depth\n&quot;;
 	if (blurRefl)     definitions += &quot;#define blur_reflection\n&quot;;
+	if (target==GL_TEXTURE_RECTANGLE_ARB) definitions += &quot;#define use_texrect\n&quot;;
 	GLSLDefineConstf4(definitions, &quot;SurfaceColor&quot;,   mapInfo-&gt;water.surfaceColor*0.4, mapInfo-&gt;water.surfaceAlpha );
 	GLSLDefineConstf4(definitions, &quot;PlaneColor&quot;,     mapInfo-&gt;water.planeColor*0.4, mapInfo-&gt;water.surfaceAlpha );
 	GLSLDefineConstf3(definitions, &quot;DiffuseColor&quot;,   mapInfo-&gt;water.diffuseColor );
@@ -343,7 +438,7 @@
 	GLSLDefineConstf1(definitions, &quot;DiffuseFactor&quot;,  mapInfo-&gt;water.diffuseFactor*15.0f );
 	GLSLDefineConstf3(definitions, &quot;SunDir&quot;,         mapInfo-&gt;light.sunDir );
 	GLSLDefineConstf3(definitions, &quot;MapMid&quot;,         float3(readmap-&gt;width*SQUARE_SIZE*0.5f,0.0f,readmap-&gt;height*SQUARE_SIZE*0.5f) );
-	GLSLDefineConstf2(definitions, &quot;ScreenInverse&quot;,  -1.0f/gu-&gt;viewSizeX, 1.0f/gu-&gt;viewSizeY );
+	GLSLDefineConstf2(definitions, &quot;ScreenInverse&quot;,  1.0f/gu-&gt;viewSizeX, 1.0f/gu-&gt;viewSizeY );
 	GLSLDefineConstf2(definitions, &quot;ViewPos&quot;,        gu-&gt;viewPosX,gu-&gt;viewPosY );
 	GLSLDefineConstf1(definitions, &quot;FresnelMin&quot;,     mapInfo-&gt;water.fresnelMin);
 	GLSLDefineConstf1(definitions, &quot;FresnelMax&quot;,     mapInfo-&gt;water.fresnelMax);
@@ -412,6 +507,7 @@
 	glUseProgram(0);
 }
 
+
 CBumpWater::~CBumpWater()
 {
 	if (reflection)
@@ -433,7 +529,7 @@
 
 	glDeleteTextures(1, &amp;foamTexture);
 	glDeleteTextures(1, &amp;normalTexture);
-	for (int i = 0; i &lt; (int)caustTextures.size(); i++) {
+	for (int i = 0; i &lt; (int)caustTextures.size(); ++i) {
 		glDeleteTextures(1, &amp;caustTextures[i]);
 	}
 
@@ -441,23 +537,124 @@
 	glDeleteShader(waterFP);
 	glDeleteProgram(waterShader);
 
-	if (shorewaves) {
-		glDeleteTextures(1, &amp;coastTexture);
+	if (shoreWaves) {
+		glDeleteTextures(2, coastTexture);
 		glDeleteTextures(1, &amp;waveRandTexture);
 
+		if (pboID)
+			glDeleteBuffers(1, &amp;pboID);
+
 		if (coastFBO)
-			glDeleteFramebuffersEXT(1,  &amp;coastFBO);
+			glDeleteFramebuffersEXT(1, &amp;coastFBO);
 
 		glDeleteShader(blurFP);
 		glDeleteProgram(blurShader);
 	}
+
+	if (dynWaves) {
+		glDeleteTextures(1, &amp;normalTexture2);
+
+		delete[] tileOffsets;
+
+		if (dynWavesFBO)
+			glDeleteFramebuffersEXT(1, &amp;dynWavesFBO);
+	}
 }
 
 
-void CBumpWater::GenerateCoastMap()
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///  UPDATE
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+void CBumpWater::Update()
 {
-	/*GLfloat* normalmap = SAFE_NEW GLfloat[gs-&gt;mapx*gs-&gt;mapy*4];
-	for (int y = 0; y &lt; gs-&gt;mapy; y++) {
+	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
+		return;
+
+	float3 w = wind.GetCurrentWind();
+	texcoord1.x += w.x*0.001f;
+	texcoord1.y += w.z*0.001f;
+
+	if (dynWaves)
+		UpdateDynWaves();
+
+	if (!shoreWaves)
+		return;
+
+	SCOPED_TIMER(&quot;Coastmap&quot;);
+
+	if (coastmapNeedUpload &amp;&amp; ((gs-&gt;frameNum + 1) % 15)==0)
+	{
+		UploadCoastline(coastUploadX1, coastUploadZ1, coastUploadX2, coastUploadZ2);
+
+		coastUpdateX1 = coastUploadX1;
+		coastUpdateX2 = coastUploadX2;
+		coastUpdateZ1 = coastUploadZ1;
+		coastUpdateZ2 = coastUploadZ2;
+		coastmapNeedUpdate = true;
+
+		coastUploadX1 = gs-&gt;mapx+1;
+		coastUploadX2 = -1;
+		coastUploadZ1 = gs-&gt;mapy+1;
+		coastUploadZ2 = -1;
+		coastmapNeedUpload = false;
+
+	}
+
+	if (coastmapNeedUpdate &amp;&amp; ((gs-&gt;frameNum + 14) % 15)==0)
+	{
+		UpdateCoastmap(coastUpdateX1, coastUpdateZ1, coastUpdateX2, coastUpdateZ2);
+		coastmapNeedUpdate = false;
+	}
+}
+
+
+void CBumpWater::UpdateWater(CGame* game)
+{
+	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
+		return;
+
+	if (refraction&gt;1) DrawRefraction(game);
+	if (reflection)   DrawReflection(game);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///  SHOREWAVES/COASTMAP
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+void CBumpWater::HeightmapChanged(const int x1, const int y1, const int x2, const int y2)
+{
+	if (!shoreWaves)
+		return;
+
+	if (x1&lt;coastUploadX1) coastUploadX1=x1;
+	if (x2&gt;coastUploadX2) coastUploadX2=x2;
+	if (y1&lt;coastUploadZ1) coastUploadZ1=y1;
+	if (y2&gt;coastUploadZ2) coastUploadZ2=y2;
+
+	coastmapNeedUpload = true;
+}
+
+
+void CBumpWater::UploadCoastline(const int x1, const int y1, const int x2, const int y2)
+{
+	GLfloat* coastmap=NULL;
+	bool usedPBO = false;
+
+	if (pboID) {
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pboID);
+		glBufferData(GL_PIXEL_UNPACK_BUFFER, gs-&gt;mapx*gs-&gt;mapy*4*4, 0, GL_STREAM_DRAW);
+		coastmap = (GLfloat*)glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
+		usedPBO = true;
+	}
+
+	if(coastmap == NULL) {
+		coastmap = SAFE_NEW GLfloat[gs-&gt;mapx*gs-&gt;mapy*4];
+		usedPBO = false;
+	}
+
+	/*for (int y = 0; y &lt; gs-&gt;mapy; y++) {
 		for (int x = 0; x &lt; gs-&gt;mapx; x++) {
 			float3&amp; normal = readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2];
 			normalmap[(y*gs-&gt;mapx+x)*4]   = normal.x;
@@ -467,101 +664,251 @@
 		}
 	}*/
 
+	int xmin = max(x1 - 10*2,0);
+	int xmax = min(x2 + 10*2,gs-&gt;mapx);
+	int ymin = max(y1 - 10*2,0);
+	int ymax = min(y2 + 10*2,gs-&gt;mapy);
+	int xsize = xmax - xmin;
+	int ysize = ymax - ymin;
+
 	const float* heightMap = readmap-&gt;GetHeightmap();
-	GLfloat* coastmap = SAFE_NEW GLfloat[gs-&gt;mapx*gs-&gt;mapy*4];
-	for (int y = 0; y &lt; gs-&gt;mapy; y++) {
-		for (int x = 0; x &lt; gs-&gt;mapx; x++) {
-			const float&amp; height = heightMap[(y*(gs-&gt;mapx+1)+x)];
-			coastmap[(y*gs-&gt;mapx+x)*4]   = (height&gt;0.0f)?1:0;
-			coastmap[(y*gs-&gt;mapx+x)*4+1] = (height&gt;0.0f)?1:0;
-			coastmap[(y*gs-&gt;mapx+x)*4+2] = (height&gt;0.0f)?1:0;
-			coastmap[(y*gs-&gt;mapx+x)*4+3] = height;
+	for (int y = ymin; y &lt; ymax; ++y) {
+		int yindex  = y*(gs-&gt;mapx + 1);
+		int yindex2 = (y-ymin)*xsize;
+		for (int x = xmin; x &lt; xmax; ++x) {
+			int index  = yindex + x;
+			int index2 = (yindex2 + (x-xmin)) &lt;&lt; 2;
+			const float&amp; height = heightMap[index];
+			coastmap[index2]   = (height&gt;0.0f)?1:0;
+			coastmap[index2+1] = (height&gt;0.0f)?1:0;
+			coastmap[index2+2] = (height&gt;0.0f)?1:0;
+			coastmap[index2+3] = height;
 		}
 	}
-	
-	glGenTextures(1, &amp;coastTexture);
-	glBindTexture(GL_TEXTURE_2D, coastTexture);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
-	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, coastmap);
-	glGenerateMipmapEXT(GL_TEXTURE_2D);
-	delete[] coastmap;
 
-	GLuint coast2Texture;
-	glGenTextures(1, &amp;coast2Texture);
-	glBindTexture(GL_TEXTURE_2D, coast2Texture);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
-	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F_ARB, gs-&gt;mapx, gs-&gt;mapy, 0, GL_RGBA, GL_FLOAT, NULL);
 
+	if (usedPBO) {
+		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+		glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
+		glTexSubImage2D(GL_TEXTURE_2D, 0, xmin, ymin, xsize,ysize, GL_RGBA, GL_FLOAT, 0);
+		glBufferData(GL_PIXEL_UNPACK_BUFFER, 0, 0, GL_STREAM_DRAW); //free it
+		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+	}else{
+		glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
+		glTexSubImage2D(GL_TEXTURE_2D, 0, xmin, ymin, xsize,ysize, GL_RGBA, GL_FLOAT, coastmap);
+		delete[] coastmap;
+	}
+}
+
+
+void CBumpWater::UpdateCoastmap(const int x1, const int y1, const int x2, const int y2)
+{
 	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
-	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coast2Texture, 0);
 	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-		
 	if (status == GL_FRAMEBUFFER_COMPLETE_EXT) {
-		glActiveTexture(GL_TEXTURE0);
 		glDisable(GL_DEPTH_TEST);
 		glDepthMask(GL_FALSE);
 		glDisable(GL_BLEND);
 
+		glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
+		glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+		glMatrixMode(GL_TEXTURE);
+			glPushMatrix();
+			glLoadIdentity();
+			glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
 		glMatrixMode(GL_PROJECTION);
-		glLoadIdentity();
-		glOrtho(0,1,0,1,-1,1);
+			glPushMatrix();
+			glLoadIdentity();
+			glOrtho(0,1,0,1,-1,1);
 		glMatrixMode(GL_MODELVIEW);
-		glLoadIdentity();
+			glPushMatrix();
+			glLoadIdentity();
+			glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
 
 		glViewport(0,0,gs-&gt;mapx, gs-&gt;mapy);
 		glUseProgram(blurShader);
 
-		for (int i=0; i&lt;10; ++i){
-			glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coast2Texture, 0);
+		int xmin = max(x1 - 10*2,0);
+		int xmax = min(x2 + 10*2,gs-&gt;mapx);
+		int ymin = max(y1 - 10*2,0);
+		int ymax = min(y2 + 10*2,gs-&gt;mapy);
+		int xsize = xmax - xmin;
+		int ysize = ymax - ymin;
 
-			glBindTexture(GL_TEXTURE_2D, coastTexture);
+		glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
+		glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+		glUniform1i(blurTexLoc,1);
+
+		glBegin(GL_QUADS);
+			glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+			glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+			glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+			glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
+		glEnd();
+
+		for (int i=0; i&lt;5; ++i){
+			glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
+			glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
+			glUniform1i(blurTexLoc,0);
+
 			glBegin(GL_QUADS);
-			glTexCoord2f(0,0); glVertex2f(0,0);
-			glTexCoord2f(0,1); glVertex2f(0,1);
-			glTexCoord2f(1,1); glVertex2f(1,1);
-			glTexCoord2f(1,0); glVertex2f(1,0);
+				glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+				glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+				glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+				glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
 			glEnd();
 
-			glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coastTexture, 0);
+			glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
+			glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+			glUniform1i(blurTexLoc,1);
 
-			glBindTexture(GL_TEXTURE_2D, coast2Texture);
 			glBegin(GL_QUADS);
-			glTexCoord2f(0,0); glVertex2f(0,0);
-			glTexCoord2f(0,1); glVertex2f(0,1);
-			glTexCoord2f(1,1); glVertex2f(1,1);
-			glTexCoord2f(1,0); glVertex2f(1,0);
+				glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+				glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+				glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+				glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
 			glEnd();
 		}
 
+		glMatrixMode(GL_TEXTURE);
+			glPopMatrix();
+		glMatrixMode(GL_PROJECTION);
+			glPopMatrix();
+		glMatrixMode(GL_MODELVIEW);
+			glPopMatrix();
+
+		//glActiveTexture(GL_TEXTURE0);
+		//glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+		glGenerateMipmapEXT(GL_TEXTURE_2D);
+
 		glUseProgram(0);
 		glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 	}else PrintFboError(&quot;coast&quot;,status);
 
 	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-	glDeleteTextures(1, &amp;coast2Texture);
+}
 
-	glBindTexture(GL_TEXTURE_2D, coastTexture);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///  DYNAMIC WAVES
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+void CBumpWater::UpdateDynWaves(const bool initialize)
+{
+	if (!dynWaves || !dynWavesFBO)
+		return;
+
+	static const unsigned char tiles  = mapInfo-&gt;water.numTiles; //! (numTiles &lt;= 16)
+	static const unsigned char ntiles = mapInfo-&gt;water.numTiles * mapInfo-&gt;water.numTiles;
+	static const float tilesize = 1.0f/mapInfo-&gt;water.numTiles;
+
+	const int f = (gs-&gt;frameNum+1) % 60;
+
+	if ( f == 0) {
+		for (unsigned char i=0; i&lt;ntiles; ++i) {
+			do {
+				tileOffsets[i] = (unsigned char)(gu-&gt;usRandFloat()*ntiles);
+			} while(tileOffsets[i] == i);
+		}
+	}
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
+	glBindTexture(GL_TEXTURE_2D, normalTexture2);
+	glBlendFunc(GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA);
+	glBlendColor(1.0f,1.0f,1.0f, (initialize) ? 1.0f : (f + 1)/600.0f );
+	glColor4f(1.0f,1.0f,1.0f,1.0f);
+
+	glViewport(0,0, normalTextureX, normalTextureY);
+	glMatrixMode(GL_MODELVIEW);
+		glPushMatrix();
+		glLoadIdentity();
+	glMatrixMode(GL_PROJECTION);
+		glPushMatrix();
+		glLoadIdentity();
+		glOrtho(0,1,0,1,-1,1);
+	glMatrixMode(GL_TEXTURE);
+		glPushMatrix();
+		glLoadIdentity();
+
+	glBegin(GL_QUADS);
+		unsigned char offset,tx,ty;
+		for (unsigned char y=0; y&lt;tiles; ++y) {
+			for (unsigned char x=0; x&lt;tiles; ++x) {
+				offset = tileOffsets[y * tiles + x];
+				tx = offset % tiles;
+				ty = (offset - tx)/tiles;
+				glTexCoord2f(     tx * tilesize,     ty * tilesize ); glVertex2f(     x * tilesize,     y * tilesize );
+				glTexCoord2f(     tx * tilesize, (ty+1) * tilesize ); glVertex2f(     x * tilesize, (y+1) * tilesize );
+				glTexCoord2f( (tx+1) * tilesize, (ty+1) * tilesize ); glVertex2f( (x+1) * tilesize, (y+1) * tilesize );
+				glTexCoord2f( (tx+1) * tilesize,     ty * tilesize ); glVertex2f( (x+1) * tilesize,     y * tilesize );
+			}
+		}
+	glEnd();
+
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+
+		glPopMatrix();
+	glMatrixMode(GL_PROJECTION);
+		glPopMatrix();
+	glMatrixMode(GL_MODELVIEW);
+		glPopMatrix();
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
+
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+
+	glBindTexture(GL_TEXTURE_2D, normalTexture);
 	glGenerateMipmapEXT(GL_TEXTURE_2D);
 }
 
 
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+///  DRAW FUNCTIONS
+///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+static void DrawRadialDisc()
+{
+	//! SAME ALGORITHM AS FOR WATERPLANE IN BFGroundDrawer.cpp!
+	const float xsize = (gs-&gt;mapx * SQUARE_SIZE) &gt;&gt; 2;
+	const float ysize = (gs-&gt;mapy * SQUARE_SIZE) &gt;&gt; 2;
+
+	CVertexArray *va = GetVertexArray();
+	va-&gt;Initialize();
+
+	const float alphainc = fastmath::PI2 / 32;
+	float alpha,r1,r2;
+	float3 p(0.0f,0.0f,0.0f);
+	const float size = std::min(xsize,ysize);
+	for (int n = 0; n &lt; 4 ; ++n) {
+		r1 = n*n * size;
+		if (n==3) {
+			r2 = (n+0.5)*(n+0.5) * size;
+		}else{
+			r2 = (n+1)*(n+1) * size;
+		}
+		for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
+			p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
+			p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
+			va-&gt;AddVertex0(p);
+			p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
+			p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
+			va-&gt;AddVertex0(p);
+		}
+	}
+
+	va-&gt;DrawArray0(GL_TRIANGLE_STRIP);
+}
+
 void CBumpWater::Draw()
 {
 	if(readmap-&gt;minheight&gt;1)
 		return;
 
 	if (refraction == 1) {
-		// _SCREENCOPY_ REFRACT TEXTURE
+		//! _SCREENCOPY_ REFRACT TEXTURE
 		glBindTexture(target, refractTexture);
 		glEnable(target);
 		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
@@ -569,7 +916,7 @@
 	}
 
 	if (depthCopy) {
-		// _SCREENCOPY_ DEPTH TEXTURE
+		//! _SCREENCOPY_ DEPTH TEXTURE
 		glBindTexture(target, depthTexture);
 		glEnable(target);
 		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
@@ -588,7 +935,7 @@
 	glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, foamTexture);
 	glActiveTexture(GL_TEXTURE4); glBindTexture(GL_TEXTURE_2D, reflectTexture);
 	glActiveTexture(GL_TEXTURE5); glBindTexture(target,        refractTexture);
-	glActiveTexture(GL_TEXTURE6); glBindTexture(GL_TEXTURE_2D, coastTexture);
+	glActiveTexture(GL_TEXTURE6); glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
 	glActiveTexture(GL_TEXTURE7); glBindTexture(target,        depthTexture);
 	glActiveTexture(GL_TEXTURE8); glBindTexture(GL_TEXTURE_2D, waveRandTexture);
 	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, normalTexture);
@@ -597,17 +944,33 @@
 	glUniform1f(frameLoc, gs-&gt;frameNum / 15000.0f);
 	glUniformf3(eyePosLoc, camera-&gt;pos);
 
-	glBegin(GL_QUADS);
-		glTexCoord4f(0.0f,0.0f,0.0f,0.0f);
-			glVertex3i(0,0,0);
-		glTexCoord4f(0.0f,1.0f,0.0f,(float)gs-&gt;mapy/gs-&gt;pwr2mapy);
-			glVertex3i(0,0,readmap-&gt;height*SQUARE_SIZE);
-		glTexCoord4f(1.0f,1.0f,(float)gs-&gt;mapx/gs-&gt;pwr2mapx,(float)gs-&gt;mapy/gs-&gt;pwr2mapy);
-			glVertex3i(readmap-&gt;width*SQUARE_SIZE,0,readmap-&gt;height*SQUARE_SIZE);
-		glTexCoord4f(1.0f,0.0f,(float)gs-&gt;mapx/gs-&gt;pwr2mapx,0.0f);
-			glVertex3i(readmap-&gt;width*SQUARE_SIZE,0,0);
-	glEnd();
 
+	const int mapX = readmap-&gt;width *SQUARE_SIZE;
+	const int mapZ = readmap-&gt;height*SQUARE_SIZE;
+	const float shadingX = (float)gs-&gt;mapx/gs-&gt;pwr2mapx;
+	const float shadingZ = (float)gs-&gt;mapy/gs-&gt;pwr2mapy;
+
+	const GLfloat planeS[4] = {1.0f/mapX,0,0,0};
+	const GLfloat planeT[4] = {0,0,1.0f/mapZ,0};
+	const GLfloat planeR[4] = {shadingX/mapX,0,0,0};
+	const GLfloat planeQ[4] = {0,0,shadingZ/mapZ,0};
+	glTexGenfv(GL_S,GL_OBJECT_PLANE,planeS);
+	glTexGenfv(GL_T,GL_OBJECT_PLANE,planeT);
+	glTexGenfv(GL_R,GL_OBJECT_PLANE,planeR);
+	glTexGenfv(GL_Q,GL_OBJECT_PLANE,planeQ);
+
+	
+	if (endlessOcean) {
+		DrawRadialDisc();
+	}else{
+		glBegin(GL_QUADS);
+		glVertex3i(   0, 0, 0);
+		glVertex3i(   0, 0, mapZ);
+		glVertex3i(mapX, 0, mapZ);
+		glVertex3i(mapX, 0, 0);
+		glEnd();
+	}
+
 	glUseProgram(0);
 
 	if (refraction&lt;2)
@@ -616,38 +979,10 @@
 		glEnable(GL_BLEND);
 }
 
-void CBumpWater::Update()
-{
-	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
-		return;
 
-	float3 w = wind.GetCurrentWind();
-	texcoord1.x += w.x*0.001f;
-	texcoord1.y += w.z*0.001f;
-/*
-	texcoord1.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord2.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord3.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord4.x += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord1.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord2.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord3.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-	texcoord4.y += (gu-&gt;usRandFloat()-0.5f)*0.0002f;
-*/
-}
-
-void CBumpWater::UpdateWater(CGame* game)
-{
-	if (readmap-&gt;minheight&gt;1 || mapInfo-&gt;map.voidWater)
-		return;
-
-	if (refraction&gt;1) DrawRefraction(game);
-	if (reflection)   DrawReflection(game);
-}
-
 void CBumpWater::DrawRefraction(CGame* game)
 {
-	// _RENDER_ REFRACTION TEXTURE
+	//! _RENDER_ REFRACTION TEXTURE
 	if (refractFBO)
 		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
 
@@ -667,13 +1002,13 @@
 	drawRefraction=true;
 
 	glEnable(GL_CLIP_PLANE2);
-	static double plane[4]={0,-1,0,5};
+	const double plane[4]={0,-1,0,5};
 	glClipPlane(GL_CLIP_PLANE2 ,plane);
 
 	readmap-&gt;GetGroundDrawer()-&gt;Draw();
 	unitDrawer-&gt;Draw(false,true);
 	featureHandler-&gt;Draw();
-	drawReflection=false;
+	unitDrawer-&gt;DrawCloakedUnits();
 	ph-&gt;Draw(false,true);
 	eventHandler.DrawWorldRefraction();
 
@@ -697,9 +1032,10 @@
 	unitDrawer-&gt;unitAmbientColor=oldambient;
 }
 
+
 void CBumpWater::DrawReflection(CGame* game)
 {
-	// CREATE REFLECTION TEXTURE
+	//! CREATE REFLECTION TEXTURE
 	if (reflectFBO)
 		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
 
@@ -719,7 +1055,7 @@
 	sky-&gt;Draw();
 
 	glEnable(GL_CLIP_PLANE2);
-	static double plane[4]={0,1,0,1};
+	const double plane[4]={0,1,0,1};
 	glClipPlane(GL_CLIP_PLANE2 ,plane);
 	drawReflection=true;
 

Modified: trunk/rts/Rendering/Env/BumpWater.h
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/Env/BumpWater.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -13,63 +13,77 @@
 public:
 	void Update();
 	void UpdateWater(CGame* game);
+	void HeightmapChanged(const int x1, const int y1, const int x2, const int y2);
 	void DrawReflection(CGame* game);
 	void DrawRefraction(CGame* game);
 	void Draw();
 	CBumpWater();
-	virtual ~CBumpWater();
-	virtual int GetID() const { return 4; }
+	~CBumpWater();
+	int GetID() const { return 4; }
 
 private:
-	void GenerateCoastMap();
-	
-	// user options
+	void UploadCoastline(const int x1, const int y1, const int x2, const int y2);
+	void UpdateCoastmap(const int x1, const int y1, const int x2, const int y2);
+	void UpdateDynWaves(const bool initialize = false);
+
+	//! user options
 	bool  reflection;
-	char  refraction; // 0:=off, 1:=screencopy, 2:=own rendering cycle
+	char  refraction;   //! 0:=off, 1:=screencopy, 2:=own rendering cycle
 	int   reflTexSize;
-	bool  shorewaves;
-	bool  depthCopy;  // uses a screen depth copy, which allows a nicer interpolation between deep sea and shallow water
+	bool  depthCopy;    //! uses a screen depth copy, which allows a nicer interpolation between deep sea and shallow water
 	float anisotropy;
-	char  depthBits;  // depthBits for reflection/refraction RBO
+	char  depthBits;    //! depthBits for reflection/refraction RBO
 	bool  blurRefl;
+	bool  shoreWaves;
+	bool  endlessOcean; //! render the water around the whole map
+	bool  dynWaves;     //! only usable if bumpmap/normal texture is a TileSet
 
-	
-	unsigned int target; // for screen copies (color/depth)
+	unsigned char* tileOffsets; //! used to randomize the wave/bumpmap/normal texture
+	int  normalTextureX; //! needed for dynamic waves
+	int  normalTextureY;
+
+	unsigned int target; //! for screen copies (color/depth), can be GL_TEXTURE_RECTANGLE (nvidia) or GL_TEXTURE_2D (others)
 	int  screenTextureX;
 	int  screenTextureY;
-	
-	GLuint refractTexture;
-	GLuint reflectTexture;
+
 	GLuint reflectRBO;
 	GLuint refractRBO;
 	GLuint reflectFBO;
 	GLuint refractFBO;
 	GLuint coastFBO;
-	
-	GLuint  waveRandTexture;
-	GLuint  foamTexture;
-	GLuint  normalTexture;
-	GLuint  coastTexture;
-	GLuint  depthTexture; // screen depth copy
-	GLuint* heightTexture;
+	GLuint dynWavesFBO;
+
+	//! coastmap
+	bool coastmapNeedUpload;
+	bool coastmapNeedUpdate;
+	int  coastUploadX1,coastUploadX2,coastUploadZ1,coastUploadZ2;
+	int  coastUpdateX1,coastUpdateX2,coastUpdateZ1,coastUpdateZ2;
+	GLuint pboID;
+
+	GLuint refractTexture;
+	GLuint reflectTexture;
+	GLuint depthTexture;   //! screen depth copy
+	GLuint waveRandTexture;
+	GLuint foamTexture;
+	GLuint normalTexture;  //! final used
+	GLuint normalTexture2; //! updates normalTexture with dynamic waves turned on
+	GLuint coastTexture[2];
 	std::vector&lt;GLuint&gt; caustTextures;
 
 	GLuint waterFP;
 	GLuint waterVP;
 	GLuint waterShader;
-	
+
 	GLuint blurFP;
 	GLuint blurShader;
 	GLuint blurDirLoc;
+	GLuint blurTexLoc;
 
 	GLuint frameLoc;
 	GLuint midPosLoc;
 	GLuint eyePosLoc;
 
 	float3 texcoord1;
-	float3 texcoord2;
-	float3 texcoord3;
-	float3 texcoord4;
 };
 
 #endif // __BUMP_WATER_H__

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -500,6 +500,7 @@
 	drawReflection=true;
 	unitDrawer-&gt;Draw(false,true);
 	featureHandler-&gt;Draw();
+	unitDrawer-&gt;DrawCloakedUnits();
 	drawReflection=false;
 	ph-&gt;Draw(false,true);
 	eventHandler.DrawWorldRefraction();

Modified: trunk/rts/Rendering/Env/RefractWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/RefractWater.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/Env/RefractWater.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -67,6 +67,8 @@
 
 	glActiveTextureARB(GL_TEXTURE3_ARB);
 	glDisable(GL_TEXTURE_2D);
+	glDisable(GL_TEXTURE_GEN_S);
+	glDisable(GL_TEXTURE_GEN_T);
 
 	glActiveTextureARB(GL_TEXTURE2_ARB);
 	glDisable(target);

Modified: trunk/rts/Rendering/GL/VertexArray.h
===================================================================
--- trunk/rts/Rendering/GL/VertexArray.h	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/GL/VertexArray.h	2008-08-03 18:56:10 UTC (rev 6230)
@@ -23,18 +23,17 @@
 	void DrawArray0(int drawType,int stride=12);
 	inline void AddVertexC(const float3&amp; pos,unsigned char* color);
 	void DrawArrayC(int drawType,int stride=16);
-	void EnlargeStripArray();
-	void EnlargeDrawArray();
-	void EndStrip();
-	bool IsReady();
-  inline void CheckEnlargeDrawArray();
-	void CheckEndStrip();
-  void DrawArrays(int drawType, int stride);
-  void EnlargeArrays(int vertexes, int strips, int stripsize=3);
-	void EndStripQ();
+
+	//! same as AddVertex0, but without autmated CheckEnlargeDrawArray
 	inline void AddVertexQ0(float x, float y, float z);
 
+	//! same as EndStrip, but without autmated EnlargeStripArray
+	void EndStripQ();
+
+	bool IsReady();
 	int drawIndex();
+	void EndStrip();
+	void EnlargeArrays(int vertexes, int strips, int stripsize=3);
 
 	float* drawArray;
 	float* drawArrayPos;
@@ -43,6 +42,13 @@
 	int* stripArray;
 	int* stripArrayPos;
 	int* stripArraySize;
+
+protected:
+	void DrawArrays(int drawType, int stride);
+	inline void CheckEnlargeDrawArray();
+	void EnlargeStripArray();
+	void EnlargeDrawArray();
+	void CheckEndStrip();
 };
 
 inline void CVertexArray::CheckEnlargeDrawArray() {

Modified: trunk/rts/Rendering/InMapDraw.cpp
===================================================================
--- trunk/rts/Rendering/InMapDraw.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Rendering/InMapDraw.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -89,15 +89,29 @@
 			tex[y][x][3] = 0;
 		}
 	}
+
+	#define SMOOTHSTEP(x,y,a) (unsigned char)(x * (1.0f - a) + y * a)
+
 	for (int y = 0; y &lt; 64; y++) {
 		// circular thingy
 		for (int x = 0; x &lt; 64; x++) {
 			float dist = sqrt((float)(x - 32) * (x - 32) + (y - 32) * (y - 32));
-			if (dist &gt; 31.875f) {
+			if (dist &gt; 31.0f) {
 				// do nothing - leave transparent
-			} else if (dist &gt; 24.5f) {
+			} else if (dist &gt; 30.0f) {
+				// interpolate (outline -&gt; nothing)
+				float a = (dist - 30.0f);
+				tex[y][x][3] = SMOOTHSTEP(255,0,a);
+			} else if (dist &gt; 24.0f) {
 				// black outline
 				tex[y][x][3] = 255;
+			} else if (dist &gt; 23.0f) {
+				// interpolate (inner -&gt; outline)
+				float a = (dist - 23.0f);
+				tex[y][x][0] = SMOOTHSTEP(255,0,a);
+				tex[y][x][1] = SMOOTHSTEP(255,0,a);
+				tex[y][x][2] = SMOOTHSTEP(255,0,a);
+				tex[y][x][3] = SMOOTHSTEP(200,255,a);
 			} else {
 				tex[y][x][0] = 255;
 				tex[y][x][1] = 255;
@@ -108,16 +122,29 @@
 	}
 	for (int y = 0; y &lt; 64; y++) {
 		// linear falloff
-		for (int x = 0; x &lt; 64; x++) {
+		for (int x = 64; x &lt; 128; x++) {
 			float dist = abs(y - 32);
-			if (dist &gt; 24.5f) {
+			if (dist &gt; 31.0f) {
+				// do nothing - leave transparent
+			} else if (dist &gt; 30.0f) {
+				// interpolate (outline -&gt; nothing)
+				float a = (dist - 30.0f);
+				tex[y][x][3] = SMOOTHSTEP(255,0,a);
+			} else if (dist &gt; 24.0f) {
 				// black outline
-				tex[y][x + 64][3] = 255;
+				tex[y][x][3] = 255;
+			} else if (dist &gt; 23.0f) {
+				// interpolate (inner -&gt; outline)
+				float a = (dist - 23.0f);
+				tex[y][x][0] = SMOOTHSTEP(255,0,a);
+				tex[y][x][1] = SMOOTHSTEP(255,0,a);
+				tex[y][x][2] = SMOOTHSTEP(255,0,a);
+				tex[y][x][3] = SMOOTHSTEP(200,255,a);
 			} else {
-				tex[y][x + 64][0] = 255;
-				tex[y][x + 64][1] = 255;
-				tex[y][x + 64][2] = 255;
-				tex[y][x + 64][3] = 200;
+				tex[y][x][0] = 255;
+				tex[y][x][1] = 255;
+				tex[y][x][2] = 255;
+				tex[y][x][3] = 200;
 			}
 		}
 	}
@@ -126,6 +153,8 @@
 	glBindTexture(GL_TEXTURE_2D, texture);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 	glBuildMipmaps(GL_TEXTURE_2D, GL_RGBA8, 128, 64, GL_RGBA, GL_UNSIGNED_BYTE, tex[0]);
 
 	blippSound=sound-&gt;GetWaveId(&quot;sounds/beep6.wav&quot;);
@@ -253,7 +282,6 @@
 				glColor4ub(pi-&gt;color[0], pi-&gt;color[1], pi-&gt;color[2], 250);
 				font-&gt;glWorldPrint(pi-&gt;label.c_str());
 				glPopMatrix();
-				glBindTexture(GL_TEXTURE_2D, texture);
 			}
 		}
 	}
@@ -266,8 +294,8 @@
 		const bool maySee = (gu-&gt;spectating || (!spec &amp;&amp; allied) || imd-&gt;drawAll);
 
 		if (maySee) {
-			lineva-&gt;AddVertexC(li-&gt;pos - (li-&gt;pos - camera-&gt;pos).Normalize() * 26, li-&gt;color);
-			lineva-&gt;AddVertexC(li-&gt;pos2 - (li-&gt;pos2 - camera-&gt;pos).Normalize() * 26, li-&gt;color);
+			lineva-&gt;AddVertexC(li-&gt;pos - (li-&gt;pos - camera-&gt;pos).ANormalize() * 26, li-&gt;color);
+			lineva-&gt;AddVertexC(li-&gt;pos2 - (li-&gt;pos2 - camera-&gt;pos).ANormalize() * 26, li-&gt;color);
 		}
 	}
 }
@@ -284,10 +312,9 @@
 	CVertexArray* lineva = GetVertexArray();
 	lineva-&gt;Initialize();
 
+	glEnable(GL_TEXTURE_2D);
 	glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
-	glEnable(GL_TEXTURE_2D);
 	glEnable(GL_BLEND);
-	glBindTexture(GL_TEXTURE_2D, texture);
 
 	InMapDraw_QuadDrawer drawer;
 	drawer.imd = this;
@@ -302,7 +329,9 @@
 	lineva-&gt;DrawArrayC(GL_LINES);
 	glLineWidth(1);
 	glEnable(GL_TEXTURE_2D);
+	glBindTexture(GL_TEXTURE_2D, texture);
 	va-&gt;DrawArrayTC(GL_QUADS);
+
 	glDepthMask(1);
 }
 

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-08-03 16:52:00 UTC (rev 6229)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-08-03 18:56:10 UTC (rev 6230)
@@ -31,6 +31,7 @@
 #include &quot;System/EventHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Sound.h&quot;
+#include &quot;System/FastMath.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -307,7 +308,7 @@
 				// If arriving at waypoint, then need to slow down, or may pass it.
 				if (!owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
 					currentDistanceToWaypoint &lt; BreakingDistance(currentSpeed) + SQUARE_SIZE) {
-					wantedSpeed = std::min((float) wantedSpeed, (float) (sqrt(currentDistanceToWaypoint * -owner-&gt;mobility-&gt;maxBreaking)));
+					wantedSpeed = std::min((float) wantedSpeed, (float) (fastmath::sqrt(currentDistanceToWaypoint * -owner-&gt;mobility-&gt;maxBreaking)));
 				}
 				wantedSpeed *= std::max(0.0f, std::min(1.0f, desiredVelocity.dot(owner-&gt;frontdir) + 0.1f));
 				SetDeltaSpeed();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001009.html">[Taspring-linux-commit] r6229 - trunk/Lobby/TASClient
</A></li>
	<LI>Next message: <A HREF="001011.html">[Taspring-linux-commit] r6231 - trunk/rts/Map/SMF
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1010">[ date ]</a>
              <a href="thread.html#1010">[ thread ]</a>
              <a href="subject.html#1010">[ subject ]</a>
              <a href="author.html#1010">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
