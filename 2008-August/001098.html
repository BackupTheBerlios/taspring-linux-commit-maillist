<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6328 - in branches/0.77-branch/rts:	Rendering/GL System System/Platform build/vstudio8 lib/gml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-August/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6328%20-%20in%20branches/0.77-branch/rts%3A%0A%09Rendering/GL%20System%20System/Platform%20build/vstudio8%20lib/gml&In-Reply-To=%3C20080828202516.5498649AF%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001097.html">
   <LINK REL="Next"  HREF="001099.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6328 - in branches/0.77-branch/rts:	Rendering/GL System System/Platform build/vstudio8 lib/gml</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6328%20-%20in%20branches/0.77-branch/rts%3A%0A%09Rendering/GL%20System%20System/Platform%20build/vstudio8%20lib/gml&In-Reply-To=%3C20080828202516.5498649AF%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6328 - in branches/0.77-branch/rts:	Rendering/GL System System/Platform build/vstudio8 lib/gml">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Aug 28 22:25:15 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001097.html">[Taspring-linux-commit] r6327 - in trunk: . installer	installer/freedesktop installer/freedesktop/applications	installer/freedesktop/mime installer/freedesktop/pixmaps rts
</A></li>
        <LI>Next message: <A HREF="001099.html">[Taspring-linux-commit] r6329 - trunk/rts/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1098">[ date ]</a>
              <a href="thread.html#1098">[ thread ]</a>
              <a href="subject.html#1098">[ subject ]</a>
              <a href="author.html#1098">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-08-28 22:25:15 +0200 (Thu, 28 Aug 2008)
New Revision: 6328

Modified:
   branches/0.77-branch/rts/Rendering/GL/VertexArray.cpp
   branches/0.77-branch/rts/Rendering/GL/VertexArray.h
   branches/0.77-branch/rts/System/DemoRecorder.cpp
   branches/0.77-branch/rts/System/Platform/ConfigHandler.cpp
   branches/0.77-branch/rts/build/vstudio8/rts.vcproj
   branches/0.77-branch/rts/lib/gml/gml.cpp
   branches/0.77-branch/rts/lib/gml/gml.h
   branches/0.77-branch/rts/lib/gml/gmlcls.h
   branches/0.77-branch/rts/lib/gml/gmldef.h
   branches/0.77-branch/rts/lib/gml/gmlfun.h
   branches/0.77-branch/rts/lib/gml/gmlimp.h
   branches/0.77-branch/rts/lib/gml/gmlsrv.h
Log:
Updated GML to latest version
Define USE_GML to compile with multithreading

Modified: branches/0.77-branch/rts/Rendering/GL/VertexArray.cpp
===================================================================
--- branches/0.77-branch/rts/Rendering/GL/VertexArray.cpp	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/Rendering/GL/VertexArray.cpp	2008-08-28 20:25:15 UTC (rev 6328)
@@ -29,10 +29,6 @@
 	stripArrayPos=stripArray;
 }
 
-int CVertexArray::drawIndex() {
-	return drawArrayPos-drawArray;
-}
-
 bool CVertexArray::IsReady() {
 	return true;
 }
@@ -52,10 +48,6 @@
 		EnlargeStripArray();
 }
 
-void CVertexArray::EndStripQ() {
-	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
-}
-
 void CVertexArray::DrawArrays(int drawType, int stride) {
 	int newIndex,oldIndex=0;
 	int *stripArrayPtr=stripArray;

Modified: branches/0.77-branch/rts/Rendering/GL/VertexArray.h
===================================================================
--- branches/0.77-branch/rts/Rendering/GL/VertexArray.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/Rendering/GL/VertexArray.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -28,10 +28,10 @@
 	inline void AddVertexQ0(float x, float y, float z);
 
 	//! same as EndStrip, but without autmated EnlargeStripArray
-	void EndStripQ();
+	inline void EndStripQ();
 
 	bool IsReady();
-	int drawIndex();
+	inline int drawIndex();
 	void EndStrip();
 	void EnlargeArrays(int vertexes, int strips, int stripsize=3);
 
@@ -51,6 +51,14 @@
 	void CheckEndStrip();
 };
 
+inline int CVertexArray::drawIndex() {
+	return drawArrayPos-drawArray;
+}
+
+inline void CVertexArray::EndStripQ() {
+	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
+}
+
 inline void CVertexArray::CheckEnlargeDrawArray() {
 	if((char *)drawArrayPos&gt;(char *)drawArraySize-10*sizeof(float))
 		EnlargeDrawArray();

Modified: branches/0.77-branch/rts/System/DemoRecorder.cpp
===================================================================
--- branches/0.77-branch/rts/System/DemoRecorder.cpp	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/System/DemoRecorder.cpp	2008-08-28 20:25:15 UTC (rev 6328)
@@ -102,7 +102,7 @@
 	newtime = _localtime64(&amp;long_time); /* Convert to local time. */
 
 	char buf[1000];
-	snprintf(buf, sizeof(buf), &quot;%04i%02i%02i_%02i%02i%02i&quot;, newtime-&gt;tm_year+1900, newtime-&gt;tm_mon + 1, newtime-&gt;tm_mday,
+	SNPRINTF(buf, sizeof(buf), &quot;%04i%02i%02i_%02i%02i%02i&quot;, newtime-&gt;tm_year+1900, newtime-&gt;tm_mon + 1, newtime-&gt;tm_mday,
         newtime-&gt;tm_hour, newtime-&gt;tm_min, newtime-&gt;tm_sec);
 	std::string name = std::string(buf) + &quot;_&quot; + mapname.substr(0, mapname.find_first_of(&quot;.&quot;));
 	name += std::string(&quot;_&quot;) + VERSION_STRING;
@@ -111,11 +111,11 @@
 	    name = &quot;local_&quot; + name;
 	}
 
-	snprintf(buf, sizeof(buf), &quot;demos/%s.sdf&quot;, name.c_str());
+	SNPRINTF(buf, sizeof(buf), &quot;demos/%s.sdf&quot;, name.c_str());
 	CFileHandler ifs(buf);
 	if (ifs.FileExists()) {
 		for (int a = 0; a &lt; 9999; ++a) {
-			snprintf(buf, sizeof(buf), &quot;demos/%s_(%i).sdf&quot;, name.c_str(), a);
+			SNPRINTF(buf, sizeof(buf), &quot;demos/%s_(%i).sdf&quot;, name.c_str(), a);
 			CFileHandler ifs(buf);
 			if (!ifs.FileExists())
 				break;

Modified: branches/0.77-branch/rts/System/Platform/ConfigHandler.cpp
===================================================================
--- branches/0.77-branch/rts/System/Platform/ConfigHandler.cpp	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/System/Platform/ConfigHandler.cpp	2008-08-28 20:25:15 UTC (rev 6328)
@@ -30,7 +30,7 @@
 
 
 std::string ConfigHandler::configSource;
-extern const char* VERSION_STRING;
+extern const char* const VERSION_STRING;
 
 
 /**

Modified: branches/0.77-branch/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/0.77-branch/rts/build/vstudio8/rts.vcproj	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/build/vstudio8/rts.vcproj	2008-08-28 20:25:15 UTC (rev 6328)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
 &lt;VisualStudioProject
 	ProjectType=&quot;Visual C++&quot;
-	Version=&quot;8,00&quot;
+	Version=&quot;8.00&quot;
 	Name=&quot;rts&quot;
 	ProjectGUID=&quot;{A0F70264-A7B7-4FE7-A5BE-298CD3A0758F}&quot;
 	RootNamespace=&quot;rts&quot;
@@ -419,7 +419,7 @@
 				EnableIntrinsicFunctions=&quot;true&quot;
 				FavorSizeOrSpeed=&quot;1&quot;
 				AdditionalIncludeDirectories=&quot;../../;../../System;../../lib/streflop;../../lib/crashrpt/include;&quot;../../../vclibs/freetype-2.1.10/include&quot;;../../../vclibs/DevIL/include;../../../vclibs/boost/Include;../../../vclibs/OpenAL/include;../../../vclibs/glew/include;../../../vclibs/zlibwapi/include;&quot;../../../vclibs/SDL-1.2.9/include&quot;;&quot;../../../vclibs/libjpeg/libjpeg-include&quot;;../../lib/lua/include;../../lib/luabind;../../../vclibs/ogg_vorbis/include&quot;
-				PreprocessorDefinitions=&quot;_CMATH_;_WIN32;WIN32;NDEBUG;_WINDOWS;ZLIB_WINAPI;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;SYNCCHECK;_GML_&quot;
+				PreprocessorDefinitions=&quot;_CMATH_;_WIN32;WIN32;NDEBUG;_WINDOWS;ZLIB_WINAPI;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;SYNCCHECK;USE_GML&quot;
 				StringPooling=&quot;true&quot;
 				ExceptionHandling=&quot;2&quot;
 				RuntimeLibrary=&quot;2&quot;

Modified: branches/0.77-branch/rts/lib/gml/gml.cpp
===================================================================
--- branches/0.77-branch/rts/lib/gml/gml.cpp	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gml.cpp	2008-08-28 20:25:15 UTC (rev 6328)
@@ -34,7 +34,6 @@
 #ifdef USE_GML
 
 #include &quot;gmlcls.h&quot;
-#include &quot;gml.h&quot;
 
 #define EXEC_RUN (BYTE *)NULL
 #define EXEC_SYNC (BYTE *)-1
@@ -142,33 +141,17 @@
 boost::thread *gmlThreads[GML_MAX_NUM_THREADS];
 
 // Item server instances
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3) &amp;&amp; (__GNUC_PATCHLEVEL__ == 0)
-
-gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlProgramServer(&amp;glCreateProgram, 2, 0);
-gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlProgramObjectARBServer(&amp;glCreateProgramObjectARB, 2, 0);
-
-gmlSingleItemServer&lt;GLUquadric *, GLUquadric *(*)(void)&gt; gmlQuadricServer(&amp;gluNewQuadric, 100, 25);
-
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei,GLuint *)&gt; gmlTextureServer(&amp;glGenTextures, 100, 25);
-
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlBufferARBServer(&amp;glGenBuffersARB, 2, 0);
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlFencesNVServer(&amp;glGenFencesNV, 2, 0);
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlProgramsARBServer(&amp;glGenProgramsARB, 2, 0);
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlRenderbuffersEXTServer(&amp;glGenRenderbuffersEXT, 2, 0);
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlFramebuffersEXTServer(&amp;glGenFramebuffersEXT, 2, 0);
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlQueryServer(&amp;glGenQueries, 20, 5);
-gmlMultiItemServer&lt;GLuint, GLsizei, void (*)(GLsizei, GLuint*)&gt; gmlBufferServer(&amp;glGenBuffers, 2, 0);
-
-//
-#else
-
 gmlSingleItemServer&lt;GLhandleARB, PFNGLCREATEPROGRAMPROC *&gt; gmlProgramServer(&amp;glCreateProgram, 2, 0);
 gmlSingleItemServer&lt;GLhandleARB, PFNGLCREATEPROGRAMOBJECTARBPROC *&gt; gmlProgramObjectARBServer(&amp;glCreateProgramObjectARB, 2, 0);
 
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderServer_VERTEX(&amp;glCreateShader_VERTEX, 2, 0);
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderServer_FRAGMENT(&amp;glCreateShader_FRAGMENT, 2, 0);
+
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderObjectARBServer_VERTEX(&amp;glCreateShaderObjectARB_VERTEX, 2, 0);
+gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderObjectARBServer_FRAGMENT(&amp;glCreateShaderObjectARB_FRAGMENT, 2, 0);
 gmlSingleItemServer&lt;GLUquadric *, GLUquadric *(GML_GLAPIENTRY *)(void)&gt; gmlQuadricServer(&amp;gluNewQuadric, 100, 25);
 
 gmlMultiItemServer&lt;GLuint, GLsizei, void (GML_GLAPIENTRY *)(GLsizei,GLuint *)&gt; gmlTextureServer(&amp;glGenTextures, 100, 25);
-
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSARBPROC *&gt; gmlBufferARBServer(&amp;glGenBuffersARB, 2, 0);
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFENCESNVPROC *&gt; gmlFencesNVServer(&amp;glGenFencesNV, 2, 0);
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENPROGRAMSARBPROC *&gt; gmlProgramsARBServer(&amp;glGenProgramsARB, 2, 0);
@@ -176,24 +159,16 @@
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENFRAMEBUFFERSEXTPROC *&gt; gmlFramebuffersEXTServer(&amp;glGenFramebuffersEXT, 2, 0);
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENQUERIESPROC *&gt; gmlQueryServer(&amp;glGenQueries, 20, 5);
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSPROC *&gt; gmlBufferServer(&amp;glGenBuffers, 2, 0);
-#endif
 
-gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderServer_VERTEX(&amp;glCreateShader_VERTEX, 2, 0);
-gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderServer_FRAGMENT(&amp;glCreateShader_FRAGMENT, 2, 0);
 
-gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderObjectARBServer_VERTEX(&amp;glCreateShaderObjectARB_VERTEX, 2, 0);
-gmlSingleItemServer&lt;GLhandleARB, GLhandleARB (*)(void)&gt; gmlShaderObjectARBServer_FRAGMENT(&amp;glCreateShaderObjectARB_FRAGMENT, 2, 0);
-
-
-
 // GMLqueue implementation
 gmlQueue::gmlQueue():
 ReadPos(0),WritePos(0),WriteSize(0),Read(0),Write(0),Locked1(FALSE),Locked2(FALSE),Reloc(FALSE),Sync(EXEC_RUN),WasSynced(FALSE),
 ClientState(0),
-CPsize(0), CPtype(0), CPstride(0), CPpointer(NULL),
-EFPstride(0), EFPpointer(NULL),
-IPtype(0), IPstride(0), IPpointer(NULL),
-NPtype(0), NPstride(0), NPpointer(NULL),
+CPsize(0), CPtype(0), CPstride(0), CPpointer(NULL), 
+EFPstride(0), EFPpointer(NULL), 
+IPtype(0), IPstride(0), IPpointer(NULL), 
+NPtype(0), NPstride(0), NPpointer(NULL), 
 TCPsize(0), TCPtype(0), TCPstride(0), TCPpointer(NULL),
 ArrayBuffer(0), ElementArrayBuffer(0), PixelPackBuffer(0),PixelUnpackBuffer(0)
 {
@@ -219,7 +194,7 @@
 	else {
 		*(BYTE * volatile *)&amp;Write=Queue2=(BYTE *)realloc(Queue2,newsize);
 		Size2=Queue2+newsize;
-	}
+	}  
 	*(BYTE * volatile *)&amp;WritePos=Write+oldpos;
 	*(BYTE * volatile *)&amp;WriteSize=Write+newsize;
 
@@ -351,7 +326,7 @@
 		if(!critical)
 			return FALSE;
 		boost::thread::yield();
-	}
+	} 
 }
 
 void gmlQueue::ReleaseRead() {
@@ -435,485 +410,508 @@
 #endif
 }
 
+#define GML_DT(name) ((gml##name##Data *)p)
+#define GML_D(name,x) (GML_DT(name)-&gt;x)
+#define GML_NEXT(name) p+=sizeof(gml##name##Data);
 
 // Handler definition macros
 // These handlers execute GL commands from the queues
 #define GML_MAKEHANDLER0(name) case gml##name##Enum:\
 	gl##name();\
-        p+=sizeof(gml##name##Data);\
-        break;
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER0R(name) case gml##name##Enum:\
-	((gml##name##Data *)p)-&gt;ret=gl##name();\
-        p+=sizeof(gml##name##Data);\
-        break;
+	GML_D(name,ret)=gl##name();\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER1(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER1R(name) case gml##name##Enum:\
-	((gml##name##Data *)p)-&gt;ret=gl##name(((gml##name##Data *)p)-&gt;A);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	GML_D(name,ret)=gl##name(GML_D(name,A));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER2(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER2R(name) case gml##name##Enum:\
-	((gml##name##Data *)p)-&gt;ret=gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	GML_D(name,ret)=gl##name(GML_D(name,A),GML_D(name,B));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER3(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER4(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER5(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER6(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER7(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER8(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER9(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER9R(name) case gml##name##Enum:\
-	((gml##name##Data *)p)-&gt;ret=gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	GML_D(name,ret)=gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I));\
+	GML_NEXT(name)\
+	break;
 
 #define GML_MAKEHANDLER10(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I,((gml##name##Data *)p)-&gt;J);\
-        p+=sizeof(gml##name##Data);\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I),GML_D(name,J));\
+	GML_NEXT(name)\
+	break;
 //glTexImage1D
 #define GML_MAKEHANDLER8S(name) case gml##name##Enum:\
-  gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H?((BYTE *)(((gml##name##Data *)p)-&gt;H))-1:(BYTE *)(((gml##name##Data *)p)+1));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H)?((BYTE *)(GML_D(name,H)))-1:(BYTE *)(GML_DT(name)+1));\
+	p+=GML_D(name,size);\
+	break;
 //glTexImage2D
 #define GML_MAKEHANDLER9S(name) case gml##name##Enum:\
-  gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I?((BYTE *)(((gml##name##Data *)p)-&gt;I))-1:(BYTE *)(((gml##name##Data *)p)+1));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I)?((BYTE *)(GML_D(name,I)))-1:(BYTE *)(GML_DT(name)+1));\
+	p+=GML_D(name,size);\
+	break;
 //glTexImage3D
 #define GML_MAKEHANDLER10S(name) case gml##name##Enum:\
-  gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I,((gml##name##Data *)p)-&gt;J?((BYTE *)(((gml##name##Data *)p)-&gt;J))-1:(BYTE *)(((gml##name##Data *)p)+1));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I),GML_D(name,J)?((BYTE *)(GML_D(name,J)))-1:(BYTE *)(GML_DT(name)+1));\
+	p+=GML_D(name,size);\
+	break;
 //glColor4fv
 #define GML_MAKEHANDLER1V(name) case gml##name##Enum:\
-	gl##name((&amp;((gml##name##Data *)p)-&gt;A));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(&amp;(GML_D(name,A)));\
+	p+=GML_D(name,size);\
+	break;
 //glFogfv
 #define GML_MAKEHANDLER2V(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,(&amp;((gml##name##Data *)p)-&gt;B));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),&amp;(GML_D(name,B)));\
+	p+=GML_D(name,size);\
+	break;
 //glLight
 #define GML_MAKEHANDLER3V(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,(&amp;((gml##name##Data *)p)-&gt;C));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),&amp;(GML_D(name,C)));\
+	p+=GML_D(name,size);\
+	break;
 //glUniformMatrix4fv
 #define GML_MAKEHANDLER4V(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,(&amp;((gml##name##Data *)p)-&gt;D));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),&amp;(GML_D(name,D)));\
+	p+=GML_D(name,size);\
+	break;
 //glBufferDataARB
 #define GML_MAKEHANDLER4VS(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,(&amp;((gml##name##Data *)p)-&gt;C),((gml##name##Data *)p)-&gt;D);\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),&amp;(GML_D(name,C)),GML_D(name,D));\
+	p+=GML_D(name,size);\
+	break;
 //glShaderSource
 #define GML_MAKEHANDLER4VSS(name,type) case gml##name##Enum:\
-	ptr=(BYTE *)((gml##name##Data *)p)+((gml##name##Data *)p)-&gt;lensize;\
-	for(int i=0; i&lt;((gml##name##Data *)p)-&gt;B; ++i) {\
-		GLint j=((intptr_t *)&amp;((gml##name##Data *)p)-&gt;C)[i];\
-		(&amp;((gml##name##Data *)p)-&gt;C)[i]=(type *)ptr;\
+	ptr=(BYTE *)GML_DT(name)+GML_D(name,lensize);\
+	for(int i=0; i&lt;GML_D(name,B); ++i) {\
+		GLint j=((intptr_t *)&amp;GML_D(name,C))[i];\
+		(&amp;(GML_D(name,C)))[i]=(type *)ptr;\
 		ptr+=j;\
 	}\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,(&amp;((gml##name##Data *)p)-&gt;C),NULL);\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),&amp;(GML_D(name,C)),NULL);\
+	p+=GML_D(name,size);\
+	break;
+//glMap1
+#define GML_MAKEHANDLER6V(name) case gml##name##Enum:\
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),&amp;(GML_D(name,F)));\
+	p+=GML_D(name,size);\
+	break;
+//glMap2
+#define GML_MAKEHANDLER10V(name) case gml##name##Enum:\
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I),&amp;(GML_D(name,J)));\
+	p+=GML_D(name,size);\
+	break;
 //glCompressedTexImage1DARB
 #define GML_MAKEHANDLER7VP(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;GP?((gml##name##Data *)p)-&gt;GP-1:(&amp;((gml##name##Data *)p)-&gt;G));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,GP)?GML_D(name,GP)-1:&amp;(GML_D(name,G)));\
+	p+=GML_D(name,size);\
+	break;
 //glCompressedTexImage2DARB
 #define GML_MAKEHANDLER8VP(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;HP?((gml##name##Data *)p)-&gt;HP-1:(&amp;((gml##name##Data *)p)-&gt;H));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,HP)?GML_D(name,HP)-1:&amp;(GML_D(name,H)));\
+	p+=GML_D(name,size);\
+	break;
 //glCompressedTexImage3DARB
 #define GML_MAKEHANDLER9VP(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;IP?((gml##name##Data *)p)-&gt;IP-1:(&amp;((gml##name##Data *)p)-&gt;I));\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,IP)?GML_D(name,IP)-1:&amp;(GML_D(name,I)));\
+	p+=GML_D(name,size);\
+	break;
 //gluBuild2DMipmaps
 #define GML_MAKEHANDLER7S(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)+1);\
-        p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_DT(name)+1);\
+	p+=GML_D(name,size);\
+	break;
 //glLight
-#define GMLMAKESUBHANDLER2(flag,fun,arg,name)\
-	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
- 	  fun(0,(GLboolean*)((((gml##name##Data *)p)-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)?((gml##name##Data *)p)-&gt;arg##pointer:ptr));\
-	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
+#define GML_MAKESUBHANDLER2(flag,fun,arg,name)\
+	if(GML_D(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+ 		fun(0,(GLboolean *)((GML_D(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_D(name,arg##pointer):ptr));\
+		ptr+=GML_D(name,arg##totalsize);\
 	}
-#define GMLMAKESUBHANDLER3(flag,fun,arg,name)\
-	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
- 	  fun(((gml##name##Data *)p)-&gt;arg##type,0,(((gml##name##Data *)p)-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)?((gml##name##Data *)p)-&gt;arg##pointer:ptr);\
-	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
+#define GML_MAKESUBHANDLER3(flag,fun,arg,name)\
+	if(GML_D(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+ 		fun(GML_D(name,arg##type),0,(GML_D(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_D(name,arg##pointer):ptr);\
+		ptr+=GML_D(name,arg##totalsize);\
 	}
-#define GMLMAKESUBHANDLER4(flag,fun,arg,name)\
-	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
- 	  fun(((gml##name##Data *)p)-&gt;arg##size,((gml##name##Data *)p)-&gt;arg##type,0,(((gml##name##Data *)p)-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)?((gml##name##Data *)p)-&gt;arg##pointer:ptr);\
-	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
+#define GML_MAKESUBHANDLER4(flag,fun,arg,name)\
+	if(GML_D(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+ 		fun(GML_D(name,arg##size),GML_D(name,arg##type),0,(GML_D(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_D(name,arg##pointer):ptr);\
+		ptr+=GML_D(name,arg##totalsize);\
 	}
-#define GMLMAKESUBHANDLERVA(name)\
-  for(int i=0; i&lt;((gml##name##Data *)p)-&gt;VAcount; ++i) {\
-    VAstruct *va=(VAstruct *)ptr;\
- 	  glVertexAttribPointer(va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,va-&gt;buffer?va-&gt;pointer:(ptr+sizeof(VAstruct)));\
-    ptr+=va-&gt;totalsize;\
-  }
+#define GML_MAKESUBHANDLERVA(name)\
+	for(int i=0; i&lt;GML_D(name,VAcount); ++i) {\
+		VAstruct *va=(VAstruct *)ptr;\
+ 		glVertexAttribPointer(va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,va-&gt;buffer?va-&gt;pointer:(ptr+sizeof(VAstruct)));\
+		ptr+=va-&gt;totalsize;\
+	}
 
 
 #define GML_MAKEHANDLER3VDA(name) case gml##name##Enum:\
-	ptr=(BYTE *)(((gml##name##Data *)p)+1);\
-	GMLMAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
-	GMLMAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
-	GMLMAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
-	GMLMAKESUBHANDLER3(GL_INDEX_ARRAY,glIndexPointer,IP,name)\
-	GMLMAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
-	GMLMAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
-	GMLMAKESUBHANDLERVA(name)\
-	gl##name(((gml##name##Data *)p)-&gt;A,0,((gml##name##Data *)p)-&gt;C);\
-  p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	ptr=(BYTE *)(GML_DT(name)+1);\
+	GML_MAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
+	GML_MAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
+	GML_MAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
+	GML_MAKESUBHANDLER3(GL_INDEX_ARRAY,glIndexPointer,IP,name)\
+	GML_MAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
+	GML_MAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
+	GML_MAKESUBHANDLERVA(name)\
+	gl##name(GML_D(name,A),0,GML_D(name,C));\
+	p+=GML_D(name,size);\
+	break;
 
 #define GML_MAKEHANDLER4VDE(name) case gml##name##Enum:\
-	ptr=(BYTE *)(((gml##name##Data *)p)+1);\
-	GMLMAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
-	GMLMAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
-	GMLMAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
-	GMLMAKESUBHANDLER3(GL_INDEX_ARRAY,glIndexPointer,IP,name)\
-	GMLMAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
-	GMLMAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
-	GMLMAKESUBHANDLERVA(name)\
-  if(((gml##name##Data *)p)-&gt;ClientState &amp; GML_ELEMENT_ARRAY_BUFFER)\
-  	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,\
-	           ((gml##name##Data *)p)-&gt;D);\
-  else\
-    glDrawArrays(((gml##name##Data *)p)-&gt;A,0,((gml##name##Data *)p)-&gt;B);\
-  p+=((gml##name##Data *)p)-&gt;size;\
-        break;
+	ptr=(BYTE *)(GML_DT(name)+1);\
+	GML_MAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
+	GML_MAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
+	GML_MAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
+	GML_MAKESUBHANDLER3(GL_INDEX_ARRAY,glIndexPointer,IP,name)\
+	GML_MAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
+	GML_MAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
+	GML_MAKESUBHANDLERVA(name)\
+	if(GML_D(name,ClientState) &amp; GML_ELEMENT_ARRAY_BUFFER)\
+		gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D));\
+	else\
+		glDrawArrays(GML_D(name,A),0,GML_D(name,B));\
+	p+=GML_D(name,size);\
+	break;
 
 
 #include &quot;gmlfun.h&quot;
 // this item server instance needs gmlDeleteLists from gmlfun.h, that is why it is declared down here
-
-#if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4) &amp;&amp; (__GNUC_MINOR__ &gt;= 3)
-gmlItemSequenceServer&lt;GLuint, GLsizei,GLuint (*)(GLsizei)&gt; gmlListServer(&amp;glGenLists, &amp;gmlDeleteLists, 100, 25, 20, 5);
-#else
 gmlItemSequenceServer&lt;GLuint, GLsizei,GLuint (GML_GLAPIENTRY *)(GLsizei)&gt; gmlListServer(&amp;glGenLists, &amp;gmlDeleteLists, 100, 25, 20, 5);
-#endif
 
 // queue handler - exequtes one GL command from queue (pointed to by p)
 // ptr is a temporary variable used inside the handlers
 inline void QueueHandler(BYTE *&amp;p, BYTE *&amp;ptr) {
-		switch(*(int *)p) {
+	switch(*(int *)p) {
 #if GML_ALTERNATE_SYNCMODE
-			  case 0: p+=sizeof(int); break;
+		case 0: p+=sizeof(int); break;
 #endif
-  			GML_MAKEHANDLER1(Disable)
-				GML_MAKEHANDLER1(Enable)
-				GML_MAKEHANDLER2(BindTexture)
-				GML_MAKEHANDLER3(TexParameteri)
-				GML_MAKEHANDLER1(ActiveTextureARB)
-				GML_MAKEHANDLER4(Color4f)
-				GML_MAKEHANDLER3(Vertex3f)
-				GML_MAKEHANDLER3(TexEnvi)
-				GML_MAKEHANDLER2(TexCoord2f)
-				GML_MAKEHANDLER6(ProgramEnvParameter4fARB)
-				GML_MAKEHANDLER0(End)
-				GML_MAKEHANDLER1(Begin)
-				GML_MAKEHANDLER1(MatrixMode)
-				GML_MAKEHANDLER2(Vertex2f)
-				GML_MAKEHANDLER0(PopMatrix)
-				GML_MAKEHANDLER0(PushMatrix)
-				GML_MAKEHANDLER0(LoadIdentity)
-				GML_MAKEHANDLER3(Translatef)
-				GML_MAKEHANDLER2(BlendFunc)
-				GML_MAKEHANDLER1(CallList)
-				GML_MAKEHANDLER3(Color3f)
-				GML_MAKEHANDLER9S(TexImage2D)
-				GML_MAKEHANDLER1V(Color4fv)
-				GML_MAKEHANDLER2(BindProgramARB)
-				GML_MAKEHANDLER3(Scalef)
-				GML_MAKEHANDLER4(Viewport)
-				GML_MAKEHANDLER2V(DeleteTextures)
-				GML_MAKEHANDLER3(MultiTexCoord2fARB)
-				GML_MAKEHANDLER2(AlphaFunc)
-				GML_MAKEHANDLER1(DepthMask)
-				GML_MAKEHANDLER1(LineWidth)
-				GML_MAKEHANDLER2(BindFramebufferEXT)
-				GML_MAKEHANDLER4(Rotatef)
-				GML_MAKEHANDLER2(DeleteLists)
-				GML_MAKEHANDLER1(DisableClientState)
-				GML_MAKEHANDLER1(EnableClientState)
-				GML_MAKEHANDLER4(Rectf)
-				GML_MAKEHANDLER3V(Lightfv)
-				GML_MAKEHANDLER7S(uBuild2DMipmaps)
-				GML_MAKEHANDLER1(Clear)
-				GML_MAKEHANDLER0(EndList)
-				GML_MAKEHANDLER2(NewList)
-				GML_MAKEHANDLER4(ClearColor)
-				GML_MAKEHANDLER2(PolygonMode)
-				GML_MAKEHANDLER1(ActiveTexture)
-				GML_MAKEHANDLER2(Fogf)
-				GML_MAKEHANDLER1V(MultMatrixf)
-				GML_MAKEHANDLER6(Ortho)
-				GML_MAKEHANDLER0(PopAttrib)
-				GML_MAKEHANDLER3V(Materialfv)
-				GML_MAKEHANDLER2(PolygonOffset)
-				GML_MAKEHANDLER1(PushAttrib)
-				GML_MAKEHANDLER1(CullFace)
-				GML_MAKEHANDLER4(ColorMask)
-				GML_MAKEHANDLER1V(Vertex3fv)
-				GML_MAKEHANDLER3V(TexGenfv)
-				GML_MAKEHANDLER2(Vertex2d)
-				GML_MAKEHANDLER4(VertexPointer)
-				GML_MAKEHANDLER3VDA(DrawArrays)
-				GML_MAKEHANDLER2V(Fogfv)
-				GML_MAKEHANDLER5(FramebufferTexture2DEXT)
-				GML_MAKEHANDLER4(TexCoordPointer)
-				GML_MAKEHANDLER9S(TexSubImage2D)
-				GML_MAKEHANDLER2V(ClipPlane)
-				GML_MAKEHANDLER4(Color4d)
-				GML_MAKEHANDLER2(LightModeli)
-				GML_MAKEHANDLER3(TexGeni)
-				GML_MAKEHANDLER3(TexParameterf)
-				GML_MAKEHANDLER8(CopyTexSubImage2D)
-				GML_MAKEHANDLER2V(DeleteFramebuffersEXT)
-				GML_MAKEHANDLER1V(LoadMatrixf)
-				GML_MAKEHANDLER1(ShadeModel)
-				GML_MAKEHANDLER1(UseProgram)
-				GML_MAKEHANDLER1(ClientActiveTextureARB)
-				GML_MAKEHANDLER2V(DeleteRenderbuffersEXT)
-				GML_MAKEHANDLER0(Flush)
-				GML_MAKEHANDLER3(Normal3f)
-				GML_MAKEHANDLER1(UseProgramObjectARB)
-				GML_MAKEHANDLER8VP(CompressedTexImage2DARB)
-				GML_MAKEHANDLER1(DeleteObjectARB)
-				GML_MAKEHANDLER2(Fogi)
-				GML_MAKEHANDLER1V(MultMatrixd)
-				GML_MAKEHANDLER2(PixelStorei)
-				GML_MAKEHANDLER2(PointParameterf)
-				GML_MAKEHANDLER3(TexCoord3f)
-				GML_MAKEHANDLER2(Uniform1i)
-				GML_MAKEHANDLER2(BindRenderbufferEXT)
-				GML_MAKEHANDLER1V(Color3fv)
-				GML_MAKEHANDLER1(DepthFunc)
-				GML_MAKEHANDLER2(Hint)
-				GML_MAKEHANDLER1(LogicOp)
-				GML_MAKEHANDLER3(StencilOp)
-				GML_MAKEHANDLER3V(TexEnvfv)
-				GML_MAKEHANDLER4V(UniformMatrix4fv)
-				GML_MAKEHANDLER4(uOrtho2D)
-				GML_MAKEHANDLER2(AttachObjectARB)
-				GML_MAKEHANDLER2(BindBufferARB)
-				GML_MAKEHANDLER1V(Color3ubv)
-				GML_MAKEHANDLER2(DetachObjectARB)
-				GML_MAKEHANDLER4(FramebufferRenderbufferEXT)
-				GML_MAKEHANDLER2(LineStipple)
-				GML_MAKEHANDLER1V(LoadMatrixd)
-				GML_MAKEHANDLER2(SetFenceNV)
-				GML_MAKEHANDLER3(StencilFunc)
-				GML_MAKEHANDLER10S(TexImage3D)
-				GML_MAKEHANDLER2(Uniform1f)
-				GML_MAKEHANDLER1(ClearStencil)
-				GML_MAKEHANDLER4(ColorPointer)
-				GML_MAKEHANDLER1(DeleteShader)
-				GML_MAKEHANDLER4VDE(DrawElements)
-				GML_MAKEHANDLER1(GenerateMipmapEXT)
-				GML_MAKEHANDLER3(Materialf)
-				GML_MAKEHANDLER3(NormalPointer)
-				GML_MAKEHANDLER3V(ProgramEnvParameter4fvARB)
-				GML_MAKEHANDLER4(RenderbufferStorageEXT)
-				GML_MAKEHANDLER1(StencilMask)
-				GML_MAKEHANDLER4(Uniform3f)
-				GML_MAKEHANDLER4(uPerspective)
-				GML_MAKEHANDLER1(ActiveStencilFaceEXT)
-				GML_MAKEHANDLER2(AttachShader)
-				GML_MAKEHANDLER10(BlitFramebufferEXT)
-				GML_MAKEHANDLER4VS(BufferDataARB)
-				GML_MAKEHANDLER1(ClearDepth)
-				GML_MAKEHANDLER3(Color3ub)
-				GML_MAKEHANDLER7VP(CompressedTexImage1DARB)
-				GML_MAKEHANDLER9VP(CompressedTexImage3DARB)
-				GML_MAKEHANDLER1(DrawBuffer)
-				GML_MAKEHANDLER1(FrontFace)
-				GML_MAKEHANDLER6(Frustum)
-				GML_MAKEHANDLER1(LinkProgramARB)
-				GML_MAKEHANDLER2(MultiTexCoord1f)
-				GML_MAKEHANDLER3(MultiTexCoord2f)
-				GML_MAKEHANDLER4(MultiTexCoord3f)
-				GML_MAKEHANDLER5(MultiTexCoord4f)
-				GML_MAKEHANDLER2V(PointParameterfv)
-				GML_MAKEHANDLER1(PointSize)
-				GML_MAKEHANDLER4V(ProgramStringARB)
-				GML_MAKEHANDLER3(SecondaryColor3f)
-				GML_MAKEHANDLER1(TexCoord1f)
-				GML_MAKEHANDLER4(TexCoord4f)
-				GML_MAKEHANDLER3(TexEnvf)
-				GML_MAKEHANDLER3(TexGenf)
-				GML_MAKEHANDLER8S(TexImage1D)
-				GML_MAKEHANDLER2(Uniform1iARB)
-				GML_MAKEHANDLER3(Uniform2f)
-				GML_MAKEHANDLER3(Uniform2fARB)
-				GML_MAKEHANDLER3(Uniform2i)
-				GML_MAKEHANDLER4(Uniform3fARB)
-				GML_MAKEHANDLER4(Uniform3i)
-				GML_MAKEHANDLER5(Uniform4f)
-				GML_MAKEHANDLER5(Uniform4i)
-				GML_MAKEHANDLER4V(UniformMatrix2fv)
-				GML_MAKEHANDLER4V(UniformMatrix3fv)
-				GML_MAKEHANDLER4(Vertex4f)
-				GML_MAKEHANDLER1(uDeleteQuadric)
-				GML_MAKEHANDLER2(uQuadricDrawStyle)
-				GML_MAKEHANDLER4(uSphere)
-				GML_MAKEHANDLER4(ClearAccum)
-				GML_MAKEHANDLER4(Color4ub)
-				GML_MAKEHANDLER1V(Color4ubv)
-				GML_MAKEHANDLER1(CompileShader)
-				GML_MAKEHANDLER1(CompileShaderARB)
-				GML_MAKEHANDLER8(CopyTexImage2D)
-				GML_MAKEHANDLER2V(DeleteBuffersARB)
-				GML_MAKEHANDLER2V(DeleteFencesNV)
-				GML_MAKEHANDLER1(DeleteProgram)
-				GML_MAKEHANDLER2V(DeleteProgramsARB)
-				GML_MAKEHANDLER2(DetachShader)
-				GML_MAKEHANDLER1(DisableVertexAttribArrayARB)
-				GML_MAKEHANDLER2V(DrawBuffersARB)
-				GML_MAKEHANDLER1(EdgeFlag)
-				GML_MAKEHANDLER1(EnableVertexAttribArrayARB)
-				GML_MAKEHANDLER0(Finish)
-				GML_MAKEHANDLER1(FinishFenceNV)
-				GML_MAKEHANDLER1(FogCoordf)
-				GML_MAKEHANDLER3(Lightf)
-				GML_MAKEHANDLER1(LinkProgram)
-				GML_MAKEHANDLER1V(Normal3fv)
-				GML_MAKEHANDLER2(RasterPos2i)
-				GML_MAKEHANDLER1(ReadBuffer)
-				GML_MAKEHANDLER4(Scissor)
-				GML_MAKEHANDLER4VSS(ShaderSource,GLchar)
-				GML_MAKEHANDLER4VSS(ShaderSourceARB,GLcharARB)
-				GML_MAKEHANDLER1V(TexCoord2fv)
-				GML_MAKEHANDLER3V(TexParameterfv)
-				GML_MAKEHANDLER3(Translated)
-				GML_MAKEHANDLER3V(Uniform1fv)
-				GML_MAKEHANDLER5(Uniform4fARB)
-				GML_MAKEHANDLER4V(UniformMatrix4fvARB)
-				GML_MAKEHANDLER6(VertexAttribPointerARB)
-				GML_MAKEHANDLER9(uLookAt)
-				GML_MAKEHANDLER2V(LightModelfv)
-
-				GML_MAKEHANDLER2V(DeleteQueries)
-				GML_MAKEHANDLER1(BlendEquation)
-				GML_MAKEHANDLER2(StencilMaskSeparate)
-				GML_MAKEHANDLER4(StencilFuncSeparate)
-				GML_MAKEHANDLER4(StencilOpSeparate)
-				GML_MAKEHANDLER2(BeginQuery)
-				GML_MAKEHANDLER1(EndQuery)
-				GML_MAKEHANDLER3(GetQueryObjectuiv)
-				GML_MAKEHANDLER2(BlendEquationSeparate)
-				GML_MAKEHANDLER4(BlendFuncSeparate)
-				GML_MAKEHANDLER6(uCylinder)
-
-				GML_MAKEHANDLER2V(DeleteBuffers)
-				GML_MAKEHANDLER2(BindBuffer)
-				GML_MAKEHANDLER4VS(BufferData)
-				GML_MAKEHANDLER2R(MapBuffer)
-				GML_MAKEHANDLER1R(UnmapBuffer)
-				GML_MAKEHANDLER8VP(CompressedTexImage2D)
-				GML_MAKEHANDLER1R(IsShader)
-				GML_MAKEHANDLER3(Vertex3i)
-
-				GML_MAKEHANDLER2(GetIntegerv)
-				GML_MAKEHANDLER1R(CheckFramebufferStatusEXT)
-				GML_MAKEHANDLER2(GetFloatv)
-				GML_MAKEHANDLER1R(GetString)
-				GML_MAKEHANDLER2R(GetUniformLocationARB)
-				GML_MAKEHANDLER7(ReadPixels)
-				GML_MAKEHANDLER0R(GetError)
-				GML_MAKEHANDLER3(GetObjectParameterivARB)
-				GML_MAKEHANDLER2R(GetUniformLocation)
-				GML_MAKEHANDLER2(GetDoublev)
-				GML_MAKEHANDLER3(GetProgramiv)
-				GML_MAKEHANDLER7(GetActiveUniform)
-				GML_MAKEHANDLER2R(GetAttribLocationARB)
-				GML_MAKEHANDLER4(GetInfoLogARB)
-				GML_MAKEHANDLER4(GetProgramInfoLog)
-				GML_MAKEHANDLER3(GetProgramivARB)
-				GML_MAKEHANDLER4(GetShaderInfoLog)
-				GML_MAKEHANDLER3(GetShaderiv)
-				GML_MAKEHANDLER1R(IsRenderbufferEXT)
-				GML_MAKEHANDLER2R(MapBufferARB)
-				GML_MAKEHANDLER9R(uProject)
-				GML_MAKEHANDLER9R(uScaleImage)
-				GML_MAKEHANDLER1R(TestFenceNV)
-
-				GML_MAKEHANDLER3(IndexPointer)
-				GML_MAKEHANDLER2(EdgeFlagPointer)
-				GML_MAKEHANDLER4(TrackMatrixNV)
-		}
+		GML_MAKEHANDLER1(Disable)
+		GML_MAKEHANDLER1(Enable)
+		GML_MAKEHANDLER2(BindTexture)
+		GML_MAKEHANDLER3(TexParameteri)
+		GML_MAKEHANDLER1(ActiveTextureARB)
+		GML_MAKEHANDLER4(Color4f)
+		GML_MAKEHANDLER3(Vertex3f)
+		GML_MAKEHANDLER3(TexEnvi)
+		GML_MAKEHANDLER2(TexCoord2f)
+		GML_MAKEHANDLER6(ProgramEnvParameter4fARB)
+		GML_MAKEHANDLER0(End)
+		GML_MAKEHANDLER1(Begin)
+		GML_MAKEHANDLER1(MatrixMode)
+		GML_MAKEHANDLER2(Vertex2f)
+		GML_MAKEHANDLER0(PopMatrix)
+		GML_MAKEHANDLER0(PushMatrix)
+		GML_MAKEHANDLER0(LoadIdentity)
+		GML_MAKEHANDLER3(Translatef)
+		GML_MAKEHANDLER2(BlendFunc)
+		GML_MAKEHANDLER1(CallList)
+		GML_MAKEHANDLER3(Color3f)
+		GML_MAKEHANDLER9S(TexImage2D)
+		GML_MAKEHANDLER1V(Color4fv)
+		GML_MAKEHANDLER2(BindProgramARB)
+		GML_MAKEHANDLER3(Scalef)
+		GML_MAKEHANDLER4(Viewport)
+		GML_MAKEHANDLER2V(DeleteTextures)
+		GML_MAKEHANDLER3(MultiTexCoord2fARB)
+		GML_MAKEHANDLER2(AlphaFunc)
+		GML_MAKEHANDLER1(DepthMask)
+		GML_MAKEHANDLER1(LineWidth)
+		GML_MAKEHANDLER2(BindFramebufferEXT)
+		GML_MAKEHANDLER4(Rotatef)
+		GML_MAKEHANDLER2(DeleteLists)
+		GML_MAKEHANDLER1(DisableClientState)
+		GML_MAKEHANDLER1(EnableClientState)
+		GML_MAKEHANDLER4(Rectf)
+		GML_MAKEHANDLER3V(Lightfv)
+		GML_MAKEHANDLER7S(uBuild2DMipmaps)
+		GML_MAKEHANDLER1(Clear)
+		GML_MAKEHANDLER0(EndList)
+		GML_MAKEHANDLER2(NewList)
+		GML_MAKEHANDLER4(ClearColor)
+		GML_MAKEHANDLER2(PolygonMode)
+		GML_MAKEHANDLER1(ActiveTexture)
+		GML_MAKEHANDLER2(Fogf)
+		GML_MAKEHANDLER1V(MultMatrixf)
+		GML_MAKEHANDLER6(Ortho)
+		GML_MAKEHANDLER0(PopAttrib)
+		GML_MAKEHANDLER3V(Materialfv)
+		GML_MAKEHANDLER2(PolygonOffset)
+		GML_MAKEHANDLER1(PushAttrib)
+		GML_MAKEHANDLER1(CullFace)
+		GML_MAKEHANDLER4(ColorMask)
+		GML_MAKEHANDLER1V(Vertex3fv)
+		GML_MAKEHANDLER3V(TexGenfv)
+		GML_MAKEHANDLER2(Vertex2d)
+		GML_MAKEHANDLER4(VertexPointer)
+		GML_MAKEHANDLER3VDA(DrawArrays)
+		GML_MAKEHANDLER2V(Fogfv)
+		GML_MAKEHANDLER5(FramebufferTexture2DEXT)
+		GML_MAKEHANDLER4(TexCoordPointer)
+		GML_MAKEHANDLER9S(TexSubImage2D)
+		GML_MAKEHANDLER2V(ClipPlane)
+		GML_MAKEHANDLER4(Color4d)
+		GML_MAKEHANDLER2(LightModeli)
+		GML_MAKEHANDLER3(TexGeni)
+		GML_MAKEHANDLER3(TexParameterf)
+		GML_MAKEHANDLER8(CopyTexSubImage2D)
+		GML_MAKEHANDLER2V(DeleteFramebuffersEXT)
+		GML_MAKEHANDLER1V(LoadMatrixf)
+		GML_MAKEHANDLER1(ShadeModel)
+		GML_MAKEHANDLER1(UseProgram)
+		GML_MAKEHANDLER1(ClientActiveTextureARB)
+		GML_MAKEHANDLER2V(DeleteRenderbuffersEXT)
+		GML_MAKEHANDLER0(Flush)
+		GML_MAKEHANDLER3(Normal3f)
+		GML_MAKEHANDLER1(UseProgramObjectARB)
+		GML_MAKEHANDLER8VP(CompressedTexImage2DARB)
+		GML_MAKEHANDLER1(DeleteObjectARB)
+		GML_MAKEHANDLER2(Fogi)
+		GML_MAKEHANDLER1V(MultMatrixd)
+		GML_MAKEHANDLER2(PixelStorei)
+		GML_MAKEHANDLER2(PointParameterf)
+		GML_MAKEHANDLER3(TexCoord3f)
+		GML_MAKEHANDLER2(Uniform1i)
+		GML_MAKEHANDLER2(BindRenderbufferEXT)
+		GML_MAKEHANDLER1V(Color3fv)
+		GML_MAKEHANDLER1(DepthFunc)
+		GML_MAKEHANDLER2(Hint)
+		GML_MAKEHANDLER1(LogicOp)
+		GML_MAKEHANDLER3(StencilOp)
+		GML_MAKEHANDLER3V(TexEnvfv)
+		GML_MAKEHANDLER4V(UniformMatrix4fv)
+		GML_MAKEHANDLER4(uOrtho2D)
+		GML_MAKEHANDLER2(AttachObjectARB)
+		GML_MAKEHANDLER2(BindBufferARB)
+		GML_MAKEHANDLER1V(Color3ubv)
+		GML_MAKEHANDLER2(DetachObjectARB)
+		GML_MAKEHANDLER4(FramebufferRenderbufferEXT)
+		GML_MAKEHANDLER2(LineStipple)
+		GML_MAKEHANDLER1V(LoadMatrixd)
+		GML_MAKEHANDLER2(SetFenceNV)
+		GML_MAKEHANDLER3(StencilFunc)
+		GML_MAKEHANDLER10S(TexImage3D)
+		GML_MAKEHANDLER2(Uniform1f)
+		GML_MAKEHANDLER1(ClearStencil)
+		GML_MAKEHANDLER4(ColorPointer)
+		GML_MAKEHANDLER1(DeleteShader)
+		GML_MAKEHANDLER4VDE(DrawElements)
+		GML_MAKEHANDLER1(GenerateMipmapEXT)
+		GML_MAKEHANDLER3(Materialf)
+		GML_MAKEHANDLER3(NormalPointer)
+		GML_MAKEHANDLER3V(ProgramEnvParameter4fvARB)
+		GML_MAKEHANDLER4(RenderbufferStorageEXT)
+		GML_MAKEHANDLER1(StencilMask)
+		GML_MAKEHANDLER4(Uniform3f)
+		GML_MAKEHANDLER4(uPerspective)
+		GML_MAKEHANDLER1(ActiveStencilFaceEXT)
+		GML_MAKEHANDLER2(AttachShader)
+		GML_MAKEHANDLER10(BlitFramebufferEXT)
+		GML_MAKEHANDLER4VS(BufferDataARB)
+		GML_MAKEHANDLER1(ClearDepth)
+		GML_MAKEHANDLER3(Color3ub)
+		GML_MAKEHANDLER7VP(CompressedTexImage1DARB)
+		GML_MAKEHANDLER9VP(CompressedTexImage3DARB)
+		GML_MAKEHANDLER1(DrawBuffer)
+		GML_MAKEHANDLER1(FrontFace)
+		GML_MAKEHANDLER6(Frustum)
+		GML_MAKEHANDLER1(LinkProgramARB)
+		GML_MAKEHANDLER2(MultiTexCoord1f)
+		GML_MAKEHANDLER3(MultiTexCoord2f)
+		GML_MAKEHANDLER4(MultiTexCoord3f)
+		GML_MAKEHANDLER5(MultiTexCoord4f)
+		GML_MAKEHANDLER2V(PointParameterfv)
+		GML_MAKEHANDLER1(PointSize)
+		GML_MAKEHANDLER4V(ProgramStringARB)
+		GML_MAKEHANDLER3(SecondaryColor3f)
+		GML_MAKEHANDLER1(TexCoord1f)
+		GML_MAKEHANDLER4(TexCoord4f)
+		GML_MAKEHANDLER3(TexEnvf)
+		GML_MAKEHANDLER3(TexGenf)
+		GML_MAKEHANDLER8S(TexImage1D)
+		GML_MAKEHANDLER2(Uniform1iARB)
+		GML_MAKEHANDLER3(Uniform2f)
+		GML_MAKEHANDLER3(Uniform2fARB)
+		GML_MAKEHANDLER3(Uniform2i)
+		GML_MAKEHANDLER4(Uniform3fARB)
+		GML_MAKEHANDLER4(Uniform3i)
+		GML_MAKEHANDLER5(Uniform4f)
+		GML_MAKEHANDLER5(Uniform4i)
+		GML_MAKEHANDLER4V(UniformMatrix2fv)
+		GML_MAKEHANDLER4V(UniformMatrix3fv)
+		GML_MAKEHANDLER4(Vertex4f)
+		GML_MAKEHANDLER1(uDeleteQuadric)
+		GML_MAKEHANDLER2(uQuadricDrawStyle)
+		GML_MAKEHANDLER4(uSphere)
+		GML_MAKEHANDLER4(ClearAccum)
+		GML_MAKEHANDLER4(Color4ub)
+		GML_MAKEHANDLER1V(Color4ubv)
+		GML_MAKEHANDLER1(CompileShader)
+		GML_MAKEHANDLER1(CompileShaderARB)
+		GML_MAKEHANDLER8(CopyTexImage2D)
+		GML_MAKEHANDLER2V(DeleteBuffersARB)
+		GML_MAKEHANDLER2V(DeleteFencesNV)
+		GML_MAKEHANDLER1(DeleteProgram)
+		GML_MAKEHANDLER2V(DeleteProgramsARB)
+		GML_MAKEHANDLER2(DetachShader)
+		GML_MAKEHANDLER1(DisableVertexAttribArrayARB)
+		GML_MAKEHANDLER2V(DrawBuffersARB)
+		GML_MAKEHANDLER1(EdgeFlag)
+		GML_MAKEHANDLER1(EnableVertexAttribArrayARB)
+		GML_MAKEHANDLER0(Finish)
+		GML_MAKEHANDLER1(FinishFenceNV)
+		GML_MAKEHANDLER1(FogCoordf)
+		GML_MAKEHANDLER3(Lightf)
+		GML_MAKEHANDLER1(LinkProgram)
+		GML_MAKEHANDLER1V(Normal3fv)
+		GML_MAKEHANDLER2(RasterPos2i)
+		GML_MAKEHANDLER1(ReadBuffer)
+		GML_MAKEHANDLER4(Scissor)
+		GML_MAKEHANDLER4VSS(ShaderSource,GLchar)
+		GML_MAKEHANDLER4VSS(ShaderSourceARB,GLcharARB)
+		GML_MAKEHANDLER1V(TexCoord2fv)
+		GML_MAKEHANDLER3V(TexParameterfv)
+		GML_MAKEHANDLER3(Translated)
+		GML_MAKEHANDLER3V(Uniform1fv)
+		GML_MAKEHANDLER5(Uniform4fARB)
+		GML_MAKEHANDLER4V(UniformMatrix4fvARB)
+		GML_MAKEHANDLER6(VertexAttribPointerARB)
+		GML_MAKEHANDLER9(uLookAt)
+		GML_MAKEHANDLER2V(LightModelfv)//
+		GML_MAKEHANDLER2V(DeleteQueries)
+		GML_MAKEHANDLER1(BlendEquation)
+		GML_MAKEHANDLER2(StencilMaskSeparate)
+		GML_MAKEHANDLER4(StencilFuncSeparate)
+		GML_MAKEHANDLER4(StencilOpSeparate)
+		GML_MAKEHANDLER2(BeginQuery)
+		GML_MAKEHANDLER1(EndQuery)
+		GML_MAKEHANDLER3(GetQueryObjectuiv)
+		GML_MAKEHANDLER2(BlendEquationSeparate)
+		GML_MAKEHANDLER4(BlendFuncSeparate)
+		GML_MAKEHANDLER6(uCylinder)
+		GML_MAKEHANDLER2V(DeleteBuffers)//
+		GML_MAKEHANDLER2(BindBuffer)
+		GML_MAKEHANDLER4VS(BufferData)
+		GML_MAKEHANDLER2R(MapBuffer)
+		GML_MAKEHANDLER1R(UnmapBuffer)
+		GML_MAKEHANDLER8VP(CompressedTexImage2D)
+		GML_MAKEHANDLER1R(IsShader)
+		GML_MAKEHANDLER3(Vertex3i)
+		GML_MAKEHANDLER2(GetIntegerv)//
+		GML_MAKEHANDLER1R(CheckFramebufferStatusEXT)
+		GML_MAKEHANDLER2(GetFloatv)
+		GML_MAKEHANDLER1R(GetString)
+		GML_MAKEHANDLER2R(GetUniformLocationARB)
+		GML_MAKEHANDLER7(ReadPixels)
+		GML_MAKEHANDLER0R(GetError)
+		GML_MAKEHANDLER3(GetObjectParameterivARB)
+		GML_MAKEHANDLER2R(GetUniformLocation)
+		GML_MAKEHANDLER2(GetDoublev)
+		GML_MAKEHANDLER3(GetProgramiv)
+		GML_MAKEHANDLER7(GetActiveUniform)
+		GML_MAKEHANDLER2R(GetAttribLocationARB)
+		GML_MAKEHANDLER4(GetInfoLogARB)
+		GML_MAKEHANDLER4(GetProgramInfoLog)
+		GML_MAKEHANDLER3(GetProgramivARB)
+		GML_MAKEHANDLER4(GetShaderInfoLog)
+		GML_MAKEHANDLER3(GetShaderiv)
+		GML_MAKEHANDLER1R(IsRenderbufferEXT)
+		GML_MAKEHANDLER2R(MapBufferARB)
+		GML_MAKEHANDLER9R(uProject)
+		GML_MAKEHANDLER9R(uScaleImage)
+		GML_MAKEHANDLER1R(TestFenceNV)
+		GML_MAKEHANDLER3(IndexPointer)//
+		GML_MAKEHANDLER2(EdgeFlagPointer)
+		GML_MAKEHANDLER4(TrackMatrixNV)
+		GML_MAKEHANDLER3(ProgramParameteriEXT)
+		GML_MAKEHANDLER4(BlendColor)
+		GML_MAKEHANDLER6V(Map1f)
+		GML_MAKEHANDLER10V(Map2f)
+		GML_MAKEHANDLER3(MapGrid1f)
+		GML_MAKEHANDLER6(MapGrid2f)
+		GML_MAKEHANDLER3(EvalMesh1)
+		GML_MAKEHANDLER5(EvalMesh2)
+		GML_MAKEHANDLER1(EvalCoord1f)
+		GML_MAKEHANDLER2(EvalCoord2f)
+		GML_MAKEHANDLER1(EvalPoint1)
+		GML_MAKEHANDLER2(EvalPoint2)
+		GML_MAKEHANDLER1R(RenderMode)
+		GML_MAKEHANDLER2(SelectBuffer)
+		GML_MAKEHANDLER0(InitNames)
+		GML_MAKEHANDLER1(LoadName)
+		GML_MAKEHANDLER1(PushName)
+		GML_MAKEHANDLER0(PopName)
+	}
 }
 
 // Execute - executes all GL commands in the current read queue.
 // Execution is non-synced
 void gmlQueue::Execute() {
 //	int procs=0;
-  BYTE *p=Read;
-  BYTE *e=ReadPos;
-  BYTE *ptr=NULL;
+	BYTE *p=Read;
+	BYTE *e=ReadPos;
+	BYTE *ptr=NULL;
 
-  while(p&lt;e) {
-//   	GML_DEBUG(&quot;Cmd &quot;,*(int *)p);
-    QueueHandler(p,ptr);
+	while(p&lt;e) {
+//	 	GML_DEBUG(&quot;Cmd &quot;,*(int *)p);
+		QueueHandler(p,ptr);
 //		++procs;
 	}
 //	GML_DEBUG(&quot;Execute &quot;,procs);
 }
 
+extern void gmlUpdateServers();
+
 // Execute - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points
 // to return values to the worker thread)
@@ -922,15 +920,15 @@
 #if GML_ALTERNATE_SYNCMODE
 	BYTE *s;
 	while(1) {
-  	int updsrv=0;
+		int updsrv=0;
 		while((s=(BYTE *)Sync)==EXEC_RUN) {
 			if(Reloc)
 				Realloc();
-      if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
-			  gmlUpdateServers();
+			if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
+				gmlUpdateServers();
 			if(GetRead()) {
-  			Execute();
-	  		ReleaseRead();
+				Execute();
+				ReleaseRead();
 			}
 			boost::thread::yield();
 		}
@@ -953,31 +951,31 @@
 			boost::thread::yield();
 	}
 #else
-  BYTE *p=Write;
-  BYTE *e=WritePos;
-  BYTE *ptr=NULL;
+	BYTE *p=Write;
+	BYTE *e=WritePos;
+	BYTE *ptr=NULL;
 	BOOL_ isq1=Write==Queue1;
 	BOOL_ end=FALSE;
-  int updsrv=0;
+	int updsrv=0;
 
-  while(TRUE) {
+	while(TRUE) {
 		if(!end) {
 			while(TRUE) {
-  			if(Reloc)
-	  			e=Realloc(&amp;p);
+				if(Reloc)
+					e=Realloc(&amp;p);
 //				if(((++updsrv)%GML_UPDSRV_INTERVAL)==0)
-        if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
+				if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 					gmlUpdateServers();
 				BYTE *s=(BYTE *)Sync;
 				if(s!=EXEC_RUN) {
-  				if(s!=EXEC_SYNC) { // end addr ready
-	  				end=TRUE;
-		  			e=s;
-     	  		Sync=EXEC_RUN;
+					if(s!=EXEC_SYNC) { // end addr ready
+						end=TRUE;
+						e=s;
+		 				Sync=EXEC_RUN;
 						break;
 					}
-    			if(p==*(BYTE * volatile *)&amp;WritePos) // reached sync point
-    	  		Sync=EXEC_RUN;
+					if(p==*(BYTE * volatile *)&amp;WritePos) // reached sync point
+						Sync=EXEC_RUN;
 				}
 				if(p&lt;*(BYTE * volatile *)&amp;WritePos)
 					break;
@@ -987,7 +985,7 @@
 			if(p==e)
 				break;
 		}
-//   	GML_DEBUG(&quot;CmdSync &quot;,*(int *)p);
+//	 	GML_DEBUG(&quot;CmdSync &quot;,*(int *)p);
 		QueueHandler(p,ptr);
 //		++procs;
 	}
@@ -1002,7 +1000,7 @@
 		Pos2=Queue2;
 	}
 #endif
-//  GML_DEBUG(&quot;ExecuteSync &quot;,procs);
+//	GML_DEBUG(&quot;ExecuteSync &quot;,procs);
 }
 
-#endif // USE_GML
+#endif

Modified: branches/0.77-branch/rts/lib/gml/gml.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gml.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gml.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -83,16 +83,16 @@
 }
 EXTERN inline GLhandleARB gmlCreateShader(GLenum type) {
 	if(type==GL_VERTEX_SHADER)
-  	  return gmlShaderServer_VERTEX.GetItems();
+		return gmlShaderServer_VERTEX.GetItems();
 	if(type==GL_FRAGMENT_SHADER)
-  	  return gmlShaderServer_FRAGMENT.GetItems();
+		return gmlShaderServer_FRAGMENT.GetItems();
 	return 0;
 }
 EXTERN inline GLhandleARB gmlCreateShaderObjectARB(GLenum type) {
 	if(type==GL_VERTEX_SHADER_ARB)
-  	  return gmlShaderObjectARBServer_VERTEX.GetItems();
+		return gmlShaderObjectARBServer_VERTEX.GetItems();
 	if(type==GL_FRAGMENT_SHADER_ARB)
-  	  return gmlShaderObjectARBServer_FRAGMENT.GetItems();
+		return gmlShaderObjectARBServer_FRAGMENT.GetItems();
 	return 0;
 }
 EXTERN inline GLUquadric *gmluNewQuadric() {
@@ -126,7 +126,7 @@
 }
 
 EXTERN inline GLuint gmlGenLists(GLsizei items) {
-  return gmlListServer.GetItems(items);
+	return gmlListServer.GetItems(items);
 }
 
 EXTERN inline void gmlUpdateServers() {

Modified: branches/0.77-branch/rts/lib/gml/gmlcls.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmlcls.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gmlcls.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -19,7 +19,7 @@
 #include &lt;map&gt;
 #include &lt;set&gt;
 
-#ifdef _GML_
+#ifdef USE_GML
 #define GML_ENABLE 1
 #else
 #define GML_ENABLE 0 // manually enable opengl multithreading here
@@ -86,8 +86,8 @@
 #define GML_IF_SERVER_THREAD() if(GML_SERVER_GLCALL &amp;&amp; (!GML_ENABLE || gmlThreadNumber==0))
 extern int gmlItemsConsumed;
 
-typedef unsigned char       BYTE;
-typedef int                 BOOL_;
+typedef unsigned char BYTE;
+typedef int BOOL_;
 
 #define TRUE 1
 #define FALSE 0
@@ -101,57 +101,57 @@
 #define GML_ELEMENT_ARRAY_BUFFER (1&lt;&lt;29)
 
 #if defined(_WIN32)
-#  if defined(__MINGW32__)
-#    define GML_APIENTRY __stdcall
-#  elif (_MSC_VER &gt;= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__)
-#    define GML_APIENTRY __stdcall
-#  else
-#    define GML_APIENTRY
-#  endif
-#  ifndef GML_GLAPIENTRY
-#    define GML_GLAPIENTRY GML_APIENTRY
-#  endif
+#	if defined(__MINGW32__)
+#		define GML_APIENTRY __stdcall
+#	elif (_MSC_VER &gt;= 800) || defined(_STDCALL_SUPPORTED) || defined(__BORLANDC__)
+#		define GML_APIENTRY __stdcall
+#	else
+#		define GML_APIENTRY
+#	endif
+#	ifndef GML_GLAPIENTRY
+#		define GML_GLAPIENTRY GML_APIENTRY
+#	endif
 #else /* _UNIX */
-#  define GML_APIENTRY
-#  ifndef GML_GLAPIENTRY
-#    define GML_GLAPIENTRY
-#  endif
+#	define GML_APIENTRY
+#	ifndef GML_GLAPIENTRY
+#		define GML_GLAPIENTRY
+#	endif
 #endif /* _WIN32 */
 
 #define GML_ERROR(str,val)\
-  FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
-  if(f) {\
-    fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-    fclose(f);\
-  }\
+	FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
+	if(f) {\
+		fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+		fclose(f);\
+	}\
 Sleep(1000);
 
 #define GML_DEBUG(str,val)\
-  FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
-  if(f) {\
-    fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-    fclose(f);\
-  }
+	FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
+	if(f) {\
+		fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+		fclose(f);\
+	}
 
 // gmlMutex - exploits the boost mutex to get direct access to the Lock/Unlock methods
 class gmlMutex {
-  boost::mutex sl_mutex;
-  BYTE sl_lock[sizeof(boost::mutex::scoped_lock)*GML_MAX_NUM_THREADS];
+	boost::mutex sl_mutex;
+	BYTE sl_lock[sizeof(boost::mutex::scoped_lock)*GML_MAX_NUM_THREADS];
 public:
-  gmlMutex() {
-  }
-  virtual ~gmlMutex() {
-  }
-  void Lock() {
-    new (((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber) boost::mutex::scoped_lock(sl_mutex);
-  }
-  void Unlock() {
+	gmlMutex() {
+	}
+	virtual ~gmlMutex() {
+	}
+	void Lock() {
+		new (((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber) boost::mutex::scoped_lock(sl_mutex);
+	}
+	void Unlock() {
 #if (BOOST_VERSION &gt;= 103500)
-    (((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber)-&gt;~unique_lock();
+		(((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber)-&gt;~unique_lock();
 #else
-    (((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber)-&gt;~scoped_lock();
+		(((boost::mutex::scoped_lock *)sl_lock)+gmlThreadNumber)-&gt;~scoped_lock();
 #endif
-  }
+	}
 };
 
 #if !defined(BOOST_HAS_THREADS) || (!defined(BOOST_AC_USE_PTHREADS) &amp;&amp; (BOOST_VERSION&lt;103500 || !(defined(__GNUC__) &amp;&amp; (defined(__i386__) || defined(__x86_64__)))) &amp;&amp; (defined(WIN32) || defined(_WIN32) || defined(__WIN32__)))
@@ -165,27 +165,27 @@
 	virtual ~gmlCount() {}
 
 	long operator++() {
-  #if defined(BOOST_AC_USE_PTHREADS)
-  	scoped_lock lock(mutex_);
-  	return ++value_;
-  #elif (BOOST_VERSION&gt;=103500) &amp;&amp; (defined(__GNUC__) &amp;&amp; (defined(__i386__) || defined(__x86_64__)))
-    return atomic_exchange_and_add(&amp;value_, 1)+1;
-//  #elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
-//    return BOOST_INTERLOCKED_INCREMENT(&amp;value_);
-  #elif (BOOST_VERSION&gt;=103500) &amp;&amp; (defined(__GNUC__) &amp;&amp; (__GNUC__*100+__GNUC_MINOR__&gt;=401))
-    return __sync_add_and_fetch(&amp;value_, 1);
-  #elif defined(__GLIBCXX__)
-    return __gnu_cxx::__exchange_and_add(&amp;value_, 1)+1;
-  #elif defined(__GLIBCPP__)
-    return __exchange_and_add(&amp;value_, 1)+1;
-  #elif defined(BOOST_HAS_PTHREADS)
-    #define BOOST_AC_USE_PTHREADS
-    scoped_lock lock(mutex_);
-    return ++value_;
-  #else
-    #error Unrecognized threading platform
-  #endif
-  }
+	#if defined(BOOST_AC_USE_PTHREADS)
+		scoped_lock lock(mutex_);
+		return ++value_;
+	#elif (BOOST_VERSION&gt;=103500) &amp;&amp; (defined(__GNUC__) &amp;&amp; (defined(__i386__) || defined(__x86_64__)))
+		return atomic_exchange_and_add(&amp;value_, 1)+1;
+//	#elif defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
+//		return BOOST_INTERLOCKED_INCREMENT(&amp;value_);
+	#elif (BOOST_VERSION&gt;=103500) &amp;&amp; (defined(__GNUC__) &amp;&amp; (__GNUC__*100+__GNUC_MINOR__&gt;=401))
+		return __sync_add_and_fetch(&amp;value_, 1);
+	#elif defined(__GLIBCXX__)
+		return __gnu_cxx::__exchange_and_add(&amp;value_, 1)+1;
+	#elif defined(__GLIBCPP__)
+		return __exchange_and_add(&amp;value_, 1)+1;
+	#elif defined(BOOST_HAS_PTHREADS)
+		#define BOOST_AC_USE_PTHREADS
+		scoped_lock lock(mutex_);
+		return ++value_;
+	#else
+		#error Unrecognized threading platform
+	#endif
+	}
 };
 #endif
 
@@ -193,9 +193,9 @@
 inline void operator%=(gmlCount&amp; a, long val) {
 	a.value_=val;
 /*#ifdef BOOST_AC_USE_PTHREADS
-  a.~gmlCount();
+	a.~gmlCount();
 #endif
-  new (&amp;a) gmlCount(val);*/
+	new (&amp;a) gmlCount(val);*/
 }
 
 #include &lt;iterator&gt;
@@ -203,28 +203,28 @@
 template&lt;class T&gt;
 class gmlVectorIter {
 public:
-  T *p; 
-  gmlVectorIter() {} 
-  gmlVectorIter(T *d) {p=d;} 
-  void operator=(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) {p=i.p;}
-  GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;operator++() {++p; return *this;} 
-  GML_TYPENAME gmlVectorIter&lt;T&gt; operator++(int) {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p++);} 
-  int operator!=(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p!=i.p;}
-  
-  ptrdiff_t operator-(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p-i.p;}
-  int operator&lt;(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p&lt;i.p;}
-  GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;operator--() {--p; return *this;} 
-  GML_TYPENAME gmlVectorIter&lt;T&gt; operator--(int) {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p--);} 
-  GML_TYPENAME gmlVectorIter&lt;T&gt; operator+(int i) const {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p+i);}
-  GML_TYPENAME gmlVectorIter&lt;T&gt; operator-(int i) const {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p-i);}
-  int operator==(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p==i.p;}
-  T &amp;operator*() {return *p;}
-  
-  typedef std::random_access_iterator_tag iterator_category;
-  typedef T value_type;
-  typedef ptrdiff_t difference_type;
-  typedef T* pointer;
-  typedef T&amp; reference;
+	T *p; 
+	gmlVectorIter() {} 
+	gmlVectorIter(T *d) {p=d;} 
+	void operator=(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) {p=i.p;}
+	GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;operator++() {++p; return *this;} 
+	GML_TYPENAME gmlVectorIter&lt;T&gt; operator++(int) {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p++);} 
+	int operator!=(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p!=i.p;}
+	
+	ptrdiff_t operator-(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p-i.p;}
+	int operator&lt;(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p&lt;i.p;}
+	GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;operator--() {--p; return *this;} 
+	GML_TYPENAME gmlVectorIter&lt;T&gt; operator--(int) {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p--);} 
+	GML_TYPENAME gmlVectorIter&lt;T&gt; operator+(int i) const {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p+i);}
+	GML_TYPENAME gmlVectorIter&lt;T&gt; operator-(int i) const {return GML_TYPENAME gmlVectorIter&lt;T&gt;(p-i);}
+	int operator==(const GML_TYPENAME gmlVectorIter&lt;T&gt; &amp;i) const {return p==i.p;}
+	T &amp;operator*() {return *p;}
+	
+	typedef std::random_access_iterator_tag iterator_category;
+	typedef T value_type;
+	typedef ptrdiff_t difference_type;
+	typedef T* pointer;
+	typedef T&amp; reference;
 };
 
 // gmlClassVector - partially thread safe vector class for storing advanced types (classes etc.)
@@ -233,190 +233,190 @@
 // high load will make &quot;volatile&quot; optimizations run about 3 times slower compared to mutex
 template&lt;class T&gt;
 class gmlClassVector {
-  T *data;
+	T *data;
 #if GML_ORDERED_VOLATILE
-  gmlCount count;
-  volatile long added;
+	gmlCount count;
+	volatile long added;
 #else
-  gmlMutex mutex;
-  long added;
+	gmlMutex mutex;
+	long added;
 #endif
-  int maxsize;
-  int doshrink;
-  int shrinksize;
-  int nalloc;
-  
+	int maxsize;
+	int doshrink;
+	int shrinksize;
+	int nalloc;
+	
 public:
-  gmlClassVector():doshrink(0),shrinksize(0),nalloc(0),
+	gmlClassVector():doshrink(0),shrinksize(0),nalloc(0),
 #if GML_ORDERED_VOLATILE
-    count(0),
+		count(0),
 #endif
-    added(0) {
-    data=(T *)malloc(1*sizeof(T));
-    maxsize=1;
-  }
-  
-  ~gmlClassVector() {
-    if(added&gt;nalloc)
-      nalloc=added;
-    for(int i=0; i&lt;nalloc; ++i)
-      data[i].~T();
-    free(data);
-  }
-  
-  typedef GML_TYPENAME gmlVectorIter&lt;T&gt; iterator;
-  
-  iterator begin() {
-    return iterator(data);
-  }
-  
-  iterator end() {
-    return iterator(data+added);
-  }
-  
-  long size() const {
-    return added;
-  }
-  
-  const T &amp;operator[](int i) const {
-    return data[i];
-  }
-  
-  T &amp;operator[](int i) {
-    return data[i];
-  }
-  
-  T &amp;acquire(int i) { // thread safe
+		added(0) {
+		data=(T *)malloc(1*sizeof(T));
+		maxsize=1;
+	}
+	
+	~gmlClassVector() {
+		if(added&gt;nalloc)
+			nalloc=added;
+		for(int i=0; i&lt;nalloc; ++i)
+			data[i].~T();
+		free(data);
+	}
+	
+	typedef GML_TYPENAME gmlVectorIter&lt;T&gt; iterator;
+	
+	iterator begin() {
+		return iterator(data);
+	}
+	
+	iterator end() {
+		return iterator(data+added);
+	}
+	
+	long size() const {
+		return added;
+	}
+	
+	const T &amp;operator[](int i) const {
+		return data[i];
+	}
+	
+	T &amp;operator[](int i) {
+		return data[i];
+	}
+	
+	T &amp;acquire(int i) { // thread safe
 #if GML_ORDERED_VOLATILE
-    long sz;
-    while(TRUE) {
-      if(added&lt;=i) {
-        if(count&lt;=i) {
-          if((sz=++count)&lt;=i+1) {
-            if(added==sz-1) {
+		long sz;
+		while(TRUE) {
+			if(added&lt;=i) {
+				if(count&lt;=i) {
+					if((sz=++count)&lt;=i+1) {
+						if(added==sz-1) {
 							T *da=GML_VOLATILE(T *) data;
 							int ms;
 							if(sz==(ms=GML_VOLATILE(int) maxsize))
 								Expand(da,ms);
-              new (da+sz-1) T();
-              ++added;
-            }
-            else {
-              --count;
-              while(count!=added)
-                boost::thread::yield();
-            }
-          }
-          else {
-            --count;
-          }
-        }
-      }
-      else {
-        long sz=++count;
-        if(added==sz-1) {
-          return (GML_VOLATILE(T *)data)[i];
-        }
-        --count;
-        while(count!=added)
-          boost::thread::yield();
-      }
-    }
+							new (da+sz-1) T();
+							++added;
+						}
+						else {
+							--count;
+							while(count!=added)
+								boost::thread::yield();
+						}
+					}
+					else {
+						--count;
+					}
+				}
+			}
+			else {
+				long sz=++count;
+				if(added==sz-1) {
+					return (GML_VOLATILE(T *)data)[i];
+				}
+				--count;
+				while(count!=added)
+					boost::thread::yield();
+			}
+		}
 #else
-    mutex.Lock();
-    while(added&lt;=i) {
-      long sz=++added;
-      if(sz==maxsize)
-        Expand(data,maxsize);
-      new (data+sz-1) T();
-    }
-    return data[i];
+		mutex.Lock();
+		while(added&lt;=i) {
+			long sz=++added;
+			if(sz==maxsize)
+				Expand(data,maxsize);
+			new (data+sz-1) T();
+		}
+		return data[i];
 #endif
-  }
-  
-  void release() { // thread safe
+	}
+	
+	void release() { // thread safe
 #if GML_ORDERED_VOLATILE
-    --count;
+		--count;
 #else
-    mutex.Unlock();
+		mutex.Unlock();
 #endif
-  }
-  
-  void push_back(const T &amp;d) { // thread safe
+	}
+	
+	void push_back(const T &amp;d) { // thread safe
 #if GML_ORDERED_VOLATILE
-    while(TRUE) {
-      long sz=++count;
-      if(added==sz-1) {
-        T *da=GML_VOLATILE(T *) data;
+		while(TRUE) {
+			long sz=++count;
+			if(added==sz-1) {
+				T *da=GML_VOLATILE(T *) data;
 				int ms;
-        if(sz==(ms=GML_VOLATILE(int) maxsize))
-          Expand(da,ms);
-        new (da+sz-1) T(d);
-        ++added;
-        return;
-      }
-      else {
-        --count;
-        while(count!=added)
-          boost::thread::yield();
-      }
-    }
+				if(sz==(ms=GML_VOLATILE(int) maxsize))
+					Expand(da,ms);
+				new (da+sz-1) T(d);
+				++added;
+				return;
+			}
+			else {
+				--count;
+				while(count!=added)
+					boost::thread::yield();
+			}
+		}
 #else
-    mutex.Lock();
-    long sz=++added;
-    if(sz==maxsize)
-      Expand(data,maxsize);
-    new (data+sz-1) T(d);
-    mutex.Unlock();
+		mutex.Lock();
+		long sz=++added;
+		if(sz==maxsize)
+			Expand(data,maxsize);
+		new (data+sz-1) T(d);
+		mutex.Unlock();
 #endif
-  }
-  
-  // this is probably overkill since realloced memory will never be cached in registers anyway
-  BYTE *volatile_realloc(BYTE *dt, const int osz, const int sz) {
+	}
+	
+	// this is probably overkill since realloced memory will never be cached in registers anyway
+	BYTE *volatile_realloc(BYTE *dt, const int osz, const int sz) {
 #if GML_ORDERED_VOLATILE 
-    BYTE *dtn=(BYTE *)malloc(sz);
-    for(int i=0; i&lt;osz; ++i)
-      *(volatile BYTE *)dtn++=*(volatile BYTE *)dt++;
-    free(dt-osz);
-    return dtn-osz;
+		BYTE *dtn=(BYTE *)malloc(sz);
+		for(int i=0; i&lt;osz; ++i)
+			*(volatile BYTE *)dtn++=*(volatile BYTE *)dt++;
+		free(dt-osz);
+		return dtn-osz;
 #else
-    return (BYTE *)realloc(dt,sz);
+		return (BYTE *)realloc(dt,sz);
 #endif
-  }
+	}
 
-  void Expand(T *&amp;da, const int ms) {
-    shrinksize=ms;
-    int ms2=ms&lt;&lt;1;
-    da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
-    GML_VOLATILE(T *) data=da; 
-    GML_VOLATILE(int) maxsize=ms2;
-  }
-  
-  void Shrink() {
-    int ms=shrinksize;
-    shrinksize=ms&gt;&gt;1;
-    doshrink=0;
-    for(int i=ms; i&lt;nalloc; ++i)
-      data[i].~T();
-    if(ms&lt;nalloc)
-      nalloc=ms;
-    data=(T *)realloc(data,ms*sizeof(T));
-    maxsize=ms;
-  }
-  
-  void clear() {
-    if(added&gt;nalloc)
-      nalloc=added;
-    long sz=added;
+	void Expand(T *&amp;da, const int ms) {
+		shrinksize=ms;
+		int ms2=ms&lt;&lt;1;
+		da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
+		GML_VOLATILE(T *) data=da; 
+		GML_VOLATILE(int) maxsize=ms2;
+	}
+	
+	void Shrink() {
+		int ms=shrinksize;
+		shrinksize=ms&gt;&gt;1;
+		doshrink=0;
+		for(int i=ms; i&lt;nalloc; ++i)
+			data[i].~T();
+		if(ms&lt;nalloc)
+			nalloc=ms;
+		data=(T *)realloc(data,ms*sizeof(T));
+		maxsize=ms;
+	}
+	
+	void clear() {
+		if(added&gt;nalloc)
+			nalloc=added;
+		long sz=added;
 #if GML_ORDERED_VOLATILE
-    count%=0;
+		count%=0;
 #endif
-    added=0;
-    if(sz&gt;=shrinksize)
-      doshrink=0;
-    else if(++doshrink&gt;=10)
-      Shrink();
-  }
+		added=0;
+		if(sz&gt;=shrinksize)
+			doshrink=0;
+		else if(++doshrink&gt;=10)
+			Shrink();
+	}
 };
 
 // gmlVector - partially thread safe vector class for storing simple types (int, pointer etc)
@@ -424,145 +424,145 @@
 // high load will make &quot;volatile&quot; optimizations run about 3 times slower compared to mutex
 template&lt;class T&gt;
 class gmlVector {
-  T *data;
+	T *data;
 #if GML_ORDERED_VOLATILE
-  gmlCount count;
-  volatile long added;
+	gmlCount count;
+	volatile long added;
 #else
-  gmlMutex mutex;
-  long added;
+	gmlMutex mutex;
+	long added;
 #endif
-  int maxsize;
-  int doshrink;
-  int shrinksize;
-  
+	int maxsize;
+	int doshrink;
+	int shrinksize;
+	
 public:
-  gmlVector():doshrink(0),shrinksize(0),
+	gmlVector():doshrink(0),shrinksize(0),
 #if GML_ORDERED_VOLATILE
-    count(0),
+		count(0),
 #endif
-    added(0) {
-    data=(T *)malloc(1*sizeof(T));
-    maxsize=1;
-  }
-  gmlVector(const GML_TYPENAME gmlVector&lt;T&gt; &amp;vec):
+		added(0) {
+		data=(T *)malloc(1*sizeof(T));
+		maxsize=1;
+	}
+	gmlVector(const GML_TYPENAME gmlVector&lt;T&gt; &amp;vec):
 #if GML_ORDERED_VOLATILE
-    count(0),
+		count(0),
 #endif
-    added(0) {
-    memcpy(this,&amp;vec,sizeof(GML_TYPENAME gmlVector&lt;T&gt;));
-    data=(T *)malloc(vec.maxsize*sizeof(T));
-    memcpy(data,vec.data,vec.maxsize*sizeof(T));
-  }
-  
-  gmlVector&lt;T&gt; &amp;operator=(const GML_TYPENAME gmlVector&lt;T&gt; &amp;vec) {
-    free(data);
-    memcpy(this,&amp;vec,sizeof(GML_TYPENAME gmlVector&lt;T&gt;));
-    data=(T *)malloc(vec.maxsize*sizeof(T));
-    memcpy(data,vec.data,vec.maxsize*sizeof(T));
-    return *this;
-  }
-  
-  ~gmlVector() {
-    free(data);
-  }
-  
-  typedef GML_TYPENAME gmlVectorIter&lt;T&gt; iterator;
-  
-  iterator begin() const {
-    return iterator(data);
-  }
-  
-  iterator end() const {
-    return iterator(data+added);
-  }
-  
-  const long size() const {
-    return added;
-  }
-  
-  const T &amp;operator[](const int i) const {
-    return data[i];
-  }
-  
-  T &amp;operator[](const int i) {
-    return data[i];
-  }
-  
-  void push_back(const T &amp;d) { // thread safe
+		added(0) {
+		memcpy(this,&amp;vec,sizeof(GML_TYPENAME gmlVector&lt;T&gt;));
+		data=(T *)malloc(vec.maxsize*sizeof(T));
+		memcpy(data,vec.data,vec.maxsize*sizeof(T));
+	}
+	
+	gmlVector&lt;T&gt; &amp;operator=(const GML_TYPENAME gmlVector&lt;T&gt; &amp;vec) {
+		free(data);
+		memcpy(this,&amp;vec,sizeof(GML_TYPENAME gmlVector&lt;T&gt;));
+		data=(T *)malloc(vec.maxsize*sizeof(T));
+		memcpy(data,vec.data,vec.maxsize*sizeof(T));
+		return *this;
+	}
+	
+	~gmlVector() {
+		free(data);
+	}
+	
+	typedef GML_TYPENAME gmlVectorIter&lt;T&gt; iterator;
+	
+	iterator begin() const {
+		return iterator(data);
+	}
+	
+	iterator end() const {
+		return iterator(data+added);
+	}
+	
+	const long size() const {
+		return added;
+	}
+	
+	const T &amp;operator[](const int i) const {
+		return data[i];
+	}
+	
+	T &amp;operator[](const int i) {
+		return data[i];
+	}
+	
+	void push_back(const T &amp;d) { // thread safe
 #if GML_ORDERED_VOLATILE
-    long sz=++count;
-    while(added!=sz-1)
-      boost::thread::yield();
-    T *da=GML_VOLATILE(T *) data;
+		long sz=++count;
+		while(added!=sz-1)
+			boost::thread::yield();
+		T *da=GML_VOLATILE(T *) data;
 		int ms;
-    if(sz==(ms=GML_VOLATILE(int) maxsize))
-      Expand(da,ms);
-    *(volatile T *)(da+sz-1)=d;
-    ++added;
+		if(sz==(ms=GML_VOLATILE(int) maxsize))
+			Expand(da,ms);
+		*(volatile T *)(da+sz-1)=d;
+		++added;
 #else
-    mutex.Lock();
-    long sz=++added;
-    if(sz==maxsize)
-      Expand(data,maxsize);
-    data[sz-1]=d;
-    mutex.Unlock();
+		mutex.Lock();
+		long sz=++added;
+		if(sz==maxsize)
+			Expand(data,maxsize);
+		data[sz-1]=d;
+		mutex.Unlock();
 #endif
-  }
-  
-  // this is probably overkill since realloced memory will never be cached in registers anyway
-  BYTE *volatile_realloc(BYTE *dt, const int osz, const int sz) {
+	}
+	
+	// this is probably overkill since realloced memory will never be cached in registers anyway
+	BYTE *volatile_realloc(BYTE *dt, const int osz, const int sz) {
 #if GML_ORDERED_VOLATILE 
-    BYTE *dtn=(BYTE *)malloc(sz);
-    for(int i=0; i&lt;osz; ++i)
-      *(volatile BYTE *)dtn++=*(volatile BYTE *)dt++;
-    free(dt-osz);
-    return dtn-osz;
+		BYTE *dtn=(BYTE *)malloc(sz);
+		for(int i=0; i&lt;osz; ++i)
+			*(volatile BYTE *)dtn++=*(volatile BYTE *)dt++;
+		free(dt-osz);
+		return dtn-osz;
 #else
-    return (BYTE *)realloc(dt,sz);
+		return (BYTE *)realloc(dt,sz);
 #endif
-  }
-  
-  void Expand(T *&amp;da, const int ms) {
-    shrinksize=ms;
-    int ms2=ms&lt;&lt;1;
-    da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
-    GML_VOLATILE(T *) data=da; 
-    GML_VOLATILE(int) maxsize=ms2;
-  }
-  
-  void Shrink() {
-    int ms=shrinksize;
-    shrinksize=ms&gt;&gt;1;
-    doshrink=0;
-    data=(T *)realloc(data,ms*sizeof(T));
-    maxsize=ms;
-  }
-  
-  void clear() {
-    long sz=added;
+	}
+	
+	void Expand(T *&amp;da, const int ms) {
+		shrinksize=ms;
+		int ms2=ms&lt;&lt;1;
+		da=(T *)volatile_realloc((BYTE *)da,ms*sizeof(T),ms2*sizeof(T));
+		GML_VOLATILE(T *) data=da; 
+		GML_VOLATILE(int) maxsize=ms2;
+	}
+	
+	void Shrink() {
+		int ms=shrinksize;
+		shrinksize=ms&gt;&gt;1;
+		doshrink=0;
+		data=(T *)realloc(data,ms*sizeof(T));
+		maxsize=ms;
+	}
+	
+	void clear() {
+		long sz=added;
 #if GML_ORDERED_VOLATILE
-    count%=0;
+		count%=0;
 #endif
-    added=0;
-    if(sz&gt;=shrinksize)
-      doshrink=0;
-    else if(++doshrink&gt;=10)
-      Shrink();
-  }
+		added=0;
+		if(sz&gt;=shrinksize)
+			doshrink=0;
+		else if(++doshrink&gt;=10)
+			Shrink();
+	}
 };
 
 // gmlLock - combines boost mutex+lock into one covenient package
 class gmlLock {
-  boost::try_mutex sl_mutex;
-  BYTE sl_lock[sizeof(boost::try_mutex::scoped_try_lock)*GML_MAX_NUM_THREADS];
-  
+	boost::try_mutex sl_mutex;
+	BYTE sl_lock[sizeof(boost::try_mutex::scoped_try_lock)*GML_MAX_NUM_THREADS];
+	
 public:
-  gmlLock() {
-  }
-  virtual ~gmlLock() {
-  }
-  bool Lock() {
+	gmlLock() {
+	}
+	virtual ~gmlLock() {
+	}
+	bool Lock() {
 		boost::try_mutex::scoped_try_lock *lock=((boost::try_mutex::scoped_try_lock *)sl_lock)+gmlThreadNumber;
 #if (BOOST_VERSION &gt;= 103500)
 		new (lock) boost::try_mutex::scoped_try_lock(sl_mutex,boost::try_to_lock);
@@ -575,324 +575,324 @@
 #if (BOOST_VERSION &gt;= 103500)
 		lock-&gt;~unique_lock();
 #else
-	  lock-&gt;~scoped_try_lock();
+		lock-&gt;~scoped_try_lock();
 #endif
 		return false;
-  }
-  void Unlock() {
+	}
+	void Unlock() {
 #if (BOOST_VERSION &gt;= 103500)
 		(((boost::try_mutex::scoped_try_lock *)sl_lock)+gmlThreadNumber)-&gt;~unique_lock();
 #else
 		(((boost::try_mutex::scoped_try_lock *)sl_lock)+gmlThreadNumber)-&gt;~scoped_try_lock();
 #endif
-  }
+	}
 };
 
 
 struct VAdata {
-  GLint size;
-  GLenum type;
-  GLboolean normalized;
-  GLsizei stride;
-  const GLvoid *pointer;
-  GLuint buffer;
-  VAdata(){}
-  VAdata(GLint si, GLenum ty, GLboolean no, GLsizei st, const GLvoid *po, GLuint buf):
-  size(si),type(ty),normalized(no),stride(st),pointer(po),buffer(buf) {}
+	GLint size;
+	GLenum type;
+	GLboolean normalized;
+	GLsizei stride;
+	const GLvoid *pointer;
+	GLuint buffer;
+	VAdata(){}
+	VAdata(GLint si, GLenum ty, GLboolean no, GLsizei st, const GLvoid *po, GLuint buf):
+	size(si),type(ty),normalized(no),stride(st),pointer(po),buffer(buf) {}
 };
 
 struct VAstruct {
-  GLuint target;
-  GLint size;
-  GLenum type;
-  GLboolean normalized;
-  GLvoid * pointer;
-  GLuint buffer;
-  int totalsize;
+	GLuint target;
+	GLint size;
+	GLenum type;
+	GLboolean normalized;
+	GLvoid * pointer;
+	GLuint buffer;
+	int totalsize;
 };
 
 
 struct gmlQueue {
-  std::map&lt;GLuint,VAdata&gt; VAmap;
-  std::set&lt;GLuint&gt; VAset;
-  
-  BYTE *ReadPos;
-  BYTE *WritePos;
-  BYTE *Pos1;
-  BYTE *Pos2;
-  
-  BYTE *WriteSize;
-  BYTE *Size1;
-  BYTE *Size2;
-  
-  BYTE *Read;
-  BYTE *Write;
-  BYTE *Queue1;
-  BYTE *Queue2;
-  
-  gmlLock Locks1;
-  gmlLock Locks2;
-  volatile BOOL_ Locked1;
-  volatile BOOL_ Locked2;
-  
-  volatile BOOL_ Reloc;
-  BYTE * volatile Sync;
-  BOOL_ WasSynced;
-  
-  GLenum ClientState;
-  // VertexPointer
-  GLint VPsize;
-  GLenum VPtype;
-  GLsizei VPstride;
-  GLvoid *VPpointer;
-  // ColorPointer
-  GLint CPsize;
-  GLenum CPtype;
-  GLsizei CPstride;
-  GLvoid *CPpointer;
-  // EdgeFlagPointer
-  GLsizei EFPstride;
-  GLboolean *EFPpointer;
-  // IndexPointer
-  GLenum IPtype;
-  GLsizei IPstride;
-  GLvoid *IPpointer;
-  // NormalPointer
-  GLenum NPtype;
-  GLsizei NPstride;
-  GLvoid *NPpointer;
-  // TexCoordPointer
-  GLint TCPsize;
-  GLenum TCPtype;
-  GLsizei TCPstride;
-  GLvoid *TCPpointer;
+	std::map&lt;GLuint,VAdata&gt; VAmap;
+	std::set&lt;GLuint&gt; VAset;
+	
+	BYTE *ReadPos;
+	BYTE *WritePos;
+	BYTE *Pos1;
+	BYTE *Pos2;
+	
+	BYTE *WriteSize;
+	BYTE *Size1;
+	BYTE *Size2;
+	
+	BYTE *Read;
+	BYTE *Write;
+	BYTE *Queue1;
+	BYTE *Queue2;
+	
+	gmlLock Locks1;
+	gmlLock Locks2;
+	volatile BOOL_ Locked1;
+	volatile BOOL_ Locked2;
+	
+	volatile BOOL_ Reloc;
+	BYTE * volatile Sync;
+	BOOL_ WasSynced;
+	
+	GLenum ClientState;
+	// VertexPointer
+	GLint VPsize;
+	GLenum VPtype;
+	GLsizei VPstride;
+	GLvoid *VPpointer;
+	// ColorPointer
+	GLint CPsize;
+	GLenum CPtype;
+	GLsizei CPstride;
+	GLvoid *CPpointer;
+	// EdgeFlagPointer
+	GLsizei EFPstride;
+	GLboolean *EFPpointer;
+	// IndexPointer
+	GLenum IPtype;
+	GLsizei IPstride;
+	GLvoid *IPpointer;
+	// NormalPointer
+	GLenum NPtype;
+	GLsizei NPstride;
+	GLvoid *NPpointer;
+	// TexCoordPointer
+	GLint TCPsize;
+	GLenum TCPtype;
+	GLsizei TCPstride;
+	GLvoid *TCPpointer;
 
 	GLuint ArrayBuffer;
 	GLuint ElementArrayBuffer;
 	GLuint PixelPackBuffer;
 	GLuint PixelUnpackBuffer;
-  
-  gmlQueue();
-  
-  BYTE *Realloc(BYTE **e=NULL);
-  BYTE *WaitRealloc(BYTE **e=NULL);
-  void ReleaseWrite(BOOL_ final=TRUE);
-  BOOL_ GetWrite(BOOL_ critical);
-  void ReleaseRead();
-  BOOL_ GetRead(BOOL_ critical=FALSE);
-  void SyncRequest();
-  void Execute();
-  void ExecuteSynced();
+	
+	gmlQueue();
+	
+	BYTE *Realloc(BYTE **e=NULL);
+	BYTE *WaitRealloc(BYTE **e=NULL);
+	void ReleaseWrite(BOOL_ final=TRUE);
+	BOOL_ GetWrite(BOOL_ critical);
+	void ReleaseRead();
+	BOOL_ GetRead(BOOL_ critical=FALSE);
+	void SyncRequest();
+	void Execute();
+	void ExecuteSynced();
 };
 
 
 template&lt;class T,class S, class C&gt;
 class gmlItemSequenceServer {
-  typedef void (*delitemseqfun)(T, S);
-  C genfun;
-  delitemseqfun delfun;
-  gmlCount req;
-  gmlCount avail;
-  int pregen;
-  int arr_size;
-  T *item_arr;
-  gmlCount req_large;
-  gmlCount avail_large;
-  gmlCount size_large;
-  int pregen_large;	
-  int large_arr_size;
-  T *large_item_arr;
-  T *large_size_arr;
+	typedef void (*delitemseqfun)(T, S);
+	C genfun;
+	delitemseqfun delfun;
+	gmlCount req;
+	gmlCount avail;
+	int pregen;
+	int arr_size;
+	T *item_arr;
+	gmlCount req_large;
+	gmlCount avail_large;
+	gmlCount size_large;
+	int pregen_large;	
+	int large_arr_size;
+	T *large_item_arr;
+	T *large_size_arr;
 	GML_MUTEX;
-  
+	
 public:
-  gmlItemSequenceServer(C gf, delitemseqfun df, int sz, int pg, int sz_l, int pg_l):
-    req(0),avail(0),req_large(0),avail_large(0),size_large(2) {
-    genfun=gf;
-    delfun=df;
-    pregen=pg;
-    arr_size=sz;
-    item_arr=new T[arr_size];
-    memset(item_arr,0,arr_size*sizeof(T));
-    pregen_large=pg_l;
-    large_arr_size=sz_l;
-    large_item_arr=new T[large_arr_size];
-    large_size_arr=new T[large_arr_size];
-    memset(large_item_arr,0,large_arr_size*sizeof(T));
-    memset(large_size_arr,0,large_arr_size*sizeof(T));
-  }
-  
-  virtual ~gmlItemSequenceServer() {
-    delete [] item_arr;
-    delete [] large_item_arr;
-    delete [] large_size_arr;
-  }
-  
-  inline void GenerateItems() {
-    // small
-    int i;    
-    while(avail&lt;req+pregen &amp;&amp; item_arr[i=(avail%arr_size)]==0) {
+	gmlItemSequenceServer(C gf, delitemseqfun df, int sz, int pg, int sz_l, int pg_l):
+		req(0),avail(0),req_large(0),avail_large(0),size_large(2) {
+		genfun=gf;
+		delfun=df;
+		pregen=pg;
+		arr_size=sz;
+		item_arr=new T[arr_size];
+		memset(item_arr,0,arr_size*sizeof(T));
+		pregen_large=pg_l;
+		large_arr_size=sz_l;
+		large_item_arr=new T[large_arr_size];
+		large_size_arr=new T[large_arr_size];
+		memset(large_item_arr,0,large_arr_size*sizeof(T));
+		memset(large_size_arr,0,large_arr_size*sizeof(T));
+	}
+	
+	virtual ~gmlItemSequenceServer() {
+		delete [] item_arr;
+		delete [] large_item_arr;
+		delete [] large_size_arr;
+	}
+	
+	inline void GenerateItems() {
+		// small
+		int i;		
+		while(avail&lt;req+pregen &amp;&amp; item_arr[i=(avail%arr_size)]==0) {
 			GML_MUTEX_LOCK();
-      *(volatile T *)(item_arr+i)=(*genfun)(1);
+			*(volatile T *)(item_arr+i)=(*genfun)(1);
 			GML_MUTEX_UNLOCK();
-      ++avail;
-    }
-    // large
-    while(avail_large&lt;req_large+pregen_large &amp;&amp; large_size_arr[i=(avail_large%large_arr_size)]==0) {
-      int gensize=size_large;
+			++avail;
+		}
+		// large
+		while(avail_large&lt;req_large+pregen_large &amp;&amp; large_size_arr[i=(avail_large%large_arr_size)]==0) {
+			int gensize=size_large;
 			GML_MUTEX_LOCK();
-      *(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
-      *(volatile T *)(large_size_arr+i)=gensize;
+			*(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
+			*(volatile T *)(large_size_arr+i)=gensize;
 			GML_MUTEX_UNLOCK();
-      ++avail_large;
-    }
-  }
-  
-  inline T GetItems(S n) {
-    GML_IF_SERVER_THREAD() {
-      return (*genfun)(n);
-    }
-  	++gmlItemsConsumed;
-    if(n==1) {
-      long num=++req;
-      while(avail&lt;num) // waiting
-        boost::thread::yield();
-      T *ip=item_arr+(num-1)%arr_size;
+			++avail_large;
+		}
+	}
+	
+	inline T GetItems(S n) {
+		GML_IF_SERVER_THREAD() {
+			return (*genfun)(n);
+		}
+		++gmlItemsConsumed;
+		if(n==1) {
+			long num=++req;
+			while(avail&lt;num) // waiting
+				boost::thread::yield();
+			T *ip=item_arr+(num-1)%arr_size;
 			GML_MUTEX_LOCK();
-      T ipv=*(volatile T *)ip;
-      *(volatile T *)ip=0;
+			T ipv=*(volatile T *)ip;
+			*(volatile T *)ip=0;
 			GML_MUTEX_UNLOCK();
-      return ipv;
-    }
-    if(n==0)
-      return 0;
-    while(size_large&lt;n)
-      ++size_large;
-    while(TRUE) {
-      long num=++req_large;
-      while(avail_large&lt;num) // waiting
-        boost::thread::yield();
-      int idx=(num-1)%large_arr_size;
+			return ipv;
+		}
+		if(n==0)
+			return 0;
+		while(size_large&lt;n)
+			++size_large;
+		while(TRUE) {
+			long num=++req_large;
+			while(avail_large&lt;num) // waiting
+				boost::thread::yield();
+			int idx=(num-1)%large_arr_size;
 			GML_MUTEX_LOCK();
-      T ip=*(volatile T *)(large_item_arr+idx);
-      T *sz=large_size_arr+idx;
-      T szv=*(volatile T *)sz;
-      *(volatile T *)sz=0;
+			T ip=*(volatile T *)(large_item_arr+idx);
+			T *sz=large_size_arr+idx;
+			T szv=*(volatile T *)sz;
+			*(volatile T *)sz=0;
 			GML_MUTEX_UNLOCK();
-      if(szv&gt;static_cast&lt;T&gt;(n))
-        (*delfun)(ip+szv,szv-n); // del excessive
-	  if(szv&lt;static_cast&lt;T&gt;(n))
-        (*delfun)(ip,szv); // del all
-	  if(szv&gt;=static_cast&lt;T&gt;(n))
-        return ip;
-    }
-  }
+			if(szv&gt;static_cast&lt;T&gt;(n))
+				(*delfun)(ip+szv,szv-n); // del excessive
+			if(szv&lt;static_cast&lt;T&gt;(n))
+				(*delfun)(ip,szv); // del all
+			if(szv&gt;=static_cast&lt;T&gt;(n))
+				return ip;
+		}
+	}
 };
 
 
 template&lt;class T, class C&gt;
 class gmlSingleItemServer {
-  C genfun;
-  gmlCount req;
-  gmlCount avail;
-  int pregen;
-  int arr_size;
-  T *arr;
+	C genfun;
+	gmlCount req;
+	gmlCount avail;
+	int pregen;
+	int arr_size;
+	T *arr;
 	GML_MUTEX;
-  
+	
 public:
-  gmlSingleItemServer(C gf, int sz, int pg):req(0),avail(0) {
-    genfun=gf;
-    pregen=pg;
-    arr_size=sz;
-    arr=new T[arr_size];
-    memset(arr,0,arr_size*sizeof(T));
-  }
-  
-  virtual ~gmlSingleItemServer() {
-    delete [] arr;
-  }
-  
-  inline void GenerateItems() {
-    int i;    
-    while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
+	gmlSingleItemServer(C gf, int sz, int pg):req(0),avail(0) {
+		genfun=gf;
+		pregen=pg;
+		arr_size=sz;
+		arr=new T[arr_size];
+		memset(arr,0,arr_size*sizeof(T));
+	}
+	
+	virtual ~gmlSingleItemServer() {
+		delete [] arr;
+	}
+	
+	inline void GenerateItems() {
+		int i;		
+		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
 			GML_MUTEX_LOCK();
-      *(volatile T *)(arr+i)=(*genfun)();
+			*(volatile T *)(arr+i)=(*genfun)();
 			GML_MUTEX_UNLOCK();
-      ++avail;
-    }
-  }
-  
-  inline T GetItems() {
-    GML_IF_SERVER_THREAD() {
-      return (*genfun)();
-    }
-  	++gmlItemsConsumed;
-    long num=++req;
-    while(avail&lt;num) // waiting
-      boost::thread::yield();
-    T *ip=arr+(num-1)%arr_size;
+			++avail;
+		}
+	}
+	
+	inline T GetItems() {
+		GML_IF_SERVER_THREAD() {
+			return (*genfun)();
+		}
+		++gmlItemsConsumed;
+		long num=++req;
+		while(avail&lt;num) // waiting
+			boost::thread::yield();
+		T *ip=arr+(num-1)%arr_size;
 		GML_MUTEX_LOCK();
-    T ret=*(volatile T *)ip;
-    *(volatile T *)ip=0;
+		T ret=*(volatile T *)ip;
+		*(volatile T *)ip=0;
 		GML_MUTEX_UNLOCK();
-    return ret;
-  }
+		return ret;
+	}
 };
 
 
 template&lt;class T, class S, class C&gt;
 class gmlMultiItemServer {
-  C genfun;
-  gmlCount req;
-  gmlCount avail;
-  int pregen;
-  int arr_size;
-  T *arr;
+	C genfun;
+	gmlCount req;
+	gmlCount avail;
+	int pregen;
+	int arr_size;
+	T *arr;
 	GML_MUTEX;
-  
+	
 public:
-  gmlMultiItemServer(C gf, int sz, int pg):req(0),avail(0) {
-    genfun=gf;
-    pregen=pg;
-    arr_size=sz;
-    arr=new T[arr_size];
-    memset(arr,0,arr_size*sizeof(T));
-  }
-  
-  virtual ~gmlMultiItemServer() {
-    delete [] arr;
-  }
-  
-  inline void GenerateItems() {
-    int i;    
-    while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
-      T val;
-      (*genfun)(1,&amp;val);
+	gmlMultiItemServer(C gf, int sz, int pg):req(0),avail(0) {
+		genfun=gf;
+		pregen=pg;
+		arr_size=sz;
+		arr=new T[arr_size];
+		memset(arr,0,arr_size*sizeof(T));
+	}
+	
+	virtual ~gmlMultiItemServer() {
+		delete [] arr;
+	}
+	
+	inline void GenerateItems() {
+		int i;		
+		while(avail&lt;req+pregen &amp;&amp; arr[i=(avail%arr_size)]==0) {
+			T val;
+			(*genfun)(1,&amp;val);
 			GML_MUTEX_LOCK();
-      *(volatile T *)(arr+i)=val;
+			*(volatile T *)(arr+i)=val;
 			GML_MUTEX_UNLOCK();
-      ++avail;
-    }
-  }
-  
-  inline void GetItems(S n, T *data) {
-    GML_IF_SERVER_THREAD() {
-      (*genfun)(n,data);
-      return;
-    }
+			++avail;
+		}
+	}
+	
+	inline void GetItems(S n, T *data) {
+		GML_IF_SERVER_THREAD() {
+			(*genfun)(n,data);
+			return;
+		}
 		gmlItemsConsumed+=n;
-    for(int i=0; i&lt;n; ++i) {
-      long num=++req;
-      while(avail&lt;num) // waiting
-        boost::thread::yield();
-      T *ip=arr+(num-1)%arr_size;
+		for(int i=0; i&lt;n; ++i) {
+			long num=++req;
+			while(avail&lt;num) // waiting
+				boost::thread::yield();
+			T *ip=arr+(num-1)%arr_size;
 			GML_MUTEX_LOCK();
-      data[i]=*(volatile T *)ip;
-      *(volatile T *)ip=0;
+			data[i]=*(volatile T *)ip;
+			*(volatile T *)ip=0;
 			GML_MUTEX_UNLOCK();
-    }
-  }
+		}
+	}
 };
 
 #endif

Modified: branches/0.77-branch/rts/lib/gml/gmldef.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmldef.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gmldef.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -198,7 +198,6 @@
 #undef glVertexAttribPointerARB
 #undef gluLookAt
 #undef glLightModelfv
-
 #undef glDeleteQueries
 #undef glBlendEquation
 #undef glStencilMaskSeparate
@@ -210,7 +209,6 @@
 #undef glBlendEquationSeparate
 #undef glBlendFuncSeparate
 #undef gluCylinder
-
 #undef glGenBuffers
 #undef glDeleteBuffers
 #undef glBindBuffer
@@ -220,7 +218,6 @@
 #undef glCompressedTexImage2D
 #undef glIsShader
 #undef glVertex3i
-
 #undef glGetIntegerv
 #undef glCheckFramebufferStatusEXT
 #undef glGetFloatv
@@ -247,13 +244,11 @@
 #undef glEdgeFlagPointer
 #undef glTrackMatrixNV
 #undef glTestFenceNV
-
 #undef glCreateProgram
 #undef glCreateProgramObjectARB
 #undef glCreateShader
 #undef glCreateShaderObjectARB
 #undef gluNewQuadric
-
 #undef glGenTextures
 #undef glGenBuffersARB
 #undef glGenFencesNV
@@ -261,14 +256,28 @@
 #undef glGenRenderbuffersEXT
 #undef glGenFramebuffersEXT
 #undef glGenQueries
-
 #undef glGenLists
+#undef glProgramParameteriEXT
+#undef glBlendColor
+#undef glMap1f
+#undef glMap2f
+#undef glMapGrid1f
+#undef glMapGrid2f
+#undef glEvalMesh1
+#undef glEvalMesh2
+#undef glEvalCoord1f
+#undef glEvalCoord2f
+#undef glEvalPoint1
+#undef glEvalPoint2
+#undef glRenderMode
+#undef glSelectBuffer
+#undef glInitNames
+#undef glLoadName
+#undef glPushName
+#undef glPopName
 
 
 
-
-
-
 #define glDisable gmlDisable
 #define glEnable gmlEnable
 #define glBindTexture gmlBindTexture
@@ -461,7 +470,6 @@
 #define glVertexAttribPointerARB gmlVertexAttribPointerARB
 #define gluLookAt gmluLookAt
 #define glLightModelfv gmlLightModelfv
-
 #define glDeleteQueries gmlDeleteQueries
 #define glBlendEquation gmlBlendEquation
 #define glStencilMaskSeparate gmlStencilMaskSeparate
@@ -473,7 +481,6 @@
 #define glBlendEquationSeparate gmlBlendEquationSeparate
 #define glBlendFuncSeparate gmlBlendFuncSeparate
 #define gluCylinder gmluCylinder
-
 #define glGenBuffers gmlGenBuffers
 #define glDeleteBuffers gmlDeleteBuffers
 #define glBindBuffer gmlBindBuffer
@@ -483,7 +490,6 @@
 #define glCompressedTexImage2D gmlCompressedTexImage2D
 #define glIsShader gmlIsShader
 #define glVertex3i gmlVertex3i
-
 #define glGetIntegerv gmlGetIntegerv
 #define glCheckFramebufferStatusEXT gmlCheckFramebufferStatusEXT
 #define glGetFloatv gmlGetFloatv
@@ -510,13 +516,11 @@
 #define glEdgeFlagPointer gmlEdgeFlagPointer
 #define glTrackMatrixNV gmlTrackMatrixNV
 #define glTestFenceNV gmlTestFenceNV
-
 #define glCreateProgram gmlCreateProgram
 #define glCreateProgramObjectARB gmlCreateProgramObjectARB
 #define glCreateShader gmlCreateShader
 #define glCreateShaderObjectARB gmlCreateShaderObjectARB
 #define gluNewQuadric gmluNewQuadric
-
 #define glGenTextures gmlGenTextures
 #define glGenBuffersARB gmlGenBuffersARB
 #define glGenFencesNV gmlGenFencesNV
@@ -524,5 +528,22 @@
 #define glGenRenderbuffersEXT gmlGenRenderbuffersEXT
 #define glGenFramebuffersEXT gmlGenFramebuffersEXT
 #define glGenQueries gmlGenQueries
-
 #define glGenLists gmlGenLists
+#define glProgramParameteriEXT gmlProgramParameteriEXT
+#define glBlendColor gmlBlendColor
+#define glMap1f gmlMap1f
+#define glMap2f gmlMap2f
+#define glMapGrid1f gmlMapGrid1f
+#define glMapGrid2f gmlMapGrid2f
+#define glEvalMesh1 gmlEvalMesh1
+#define glEvalMesh2 gmlEvalMesh2
+#define glEvalCoord1f gmlEvalCoord1f
+#define glEvalCoord2f gmlEvalCoord2f
+#define glEvalPoint1 gmlEvalPoint1
+#define glEvalPoint2 gmlEvalPoint2
+#define glRenderMode gmlRenderMode
+#define glSelectBuffer gmlSelectBuffer
+#define glInitNames gmlInitNames
+#define glLoadName gmlLoadName
+#define glPushName gmlPushName
+#define glPopName gmlPopName

Modified: branches/0.77-branch/rts/lib/gml/gmlfun.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmlfun.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gmlfun.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -12,27 +12,20 @@
 #include &lt;set&gt;
 #include &lt;map&gt;
 
+#define DEBUG_GML 0 // enable debugging
 
-#define GML_NERROR_FUN(str,val)\
-f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
-if(f) {\
-	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-	fclose(f);\
-}
-
-#define GML_ERROR_FUN(str,val)\
-FILE *f=fopen(&quot;C:\\GMLERR.TXT&quot;,&quot;a&quot;);\
-if(f) {\
-	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-	fclose(f);\
-}
-
+#if DEBUG_GML
 #define GML_DEBUG_FUN(str,val)\
-FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
-if(f) {\
-	fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
-	fclose(f);\
+{\
+	FILE *f=fopen(&quot;C:\\GMLDBG.TXT&quot;,&quot;a&quot;);\
+	if(f) {\
+		fprintf(f,&quot;%s line %d: %s %d\n&quot;,__FILE__,__LINE__,str,val);\
+		fclose(f);\
+	}\
 }
+#else
+#define GML_DEBUG_FUN(str,val)
+#endif
 
 extern std::map&lt;GLenum,GLint&gt; gmlGetIntegervCache;
 extern std::map&lt;GLenum,GLfloat&gt; gmlGetFloatvCache;
@@ -43,10 +36,9 @@
 #define GML_DEFAULT_RET(c,r) if(GML_USE_DEFAULT &amp;&amp; (c)) {return r;}
 #define GML_DEFAULT_ERROR() if(GML_USE_NO_ERROR) return GL_NO_ERROR;
 
+//teximage, build2dmip
 EXTERN inline int gmlNumArgsTexImage(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-		//teximage, build2dmip
 		case GL_COLOR_INDEX:
 		case GL_RED:
 		case GL_GREEN:
@@ -64,15 +56,14 @@
 		case GL_BGRA_EXT:
 			return 4;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsTexImage&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsTexImage&quot;, datatype)
 			return 0;
 	}
 }
 
+// glLight, glMaterial
 EXTERN inline int gmlNumArgsLightMat(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-// glLight, glMaterial
 		case GL_AMBIENT:
 		case GL_DIFFUSE:
 		case GL_SPECULAR:
@@ -91,15 +82,14 @@
 		case GL_QUADRATIC_ATTENUATION:
 			return 1;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsLightMat&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsLightMat&quot;, datatype)
 			return 0;
 	}
 }
 
+//glFog
 EXTERN inline int gmlNumArgsFog(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-//glFog
 		case GL_FOG_MODE:
 		case GL_FOG_DENSITY:
 		case GL_FOG_START:
@@ -109,44 +99,41 @@
 		case GL_FOG_COLOR:
 			return 4;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsFog&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsFog&quot;, datatype)
 			return 0;
 	}
 }
 
+//glTexGen
 EXTERN inline int gmlNumArgsTexGen(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-//glTexGen
 		case GL_TEXTURE_GEN_MODE:
 			return 1;
 		case GL_OBJECT_PLANE:
 		case GL_EYE_PLANE:
 			return 4;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsTexGen&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsTexGen&quot;, datatype)
 			return 0;
 	}
 }
 
+//glTexEnv
 EXTERN inline int gmlNumArgsTexEnv(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-//glTexEnv
 		case GL_TEXTURE_ENV_MODE:
 			return 1;
 		case GL_TEXTURE_ENV_COLOR:
 			return 4;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsTexEnv&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsTexEnv&quot;, datatype)
 			return 0;
 	}
 }
 
+//glPointParametefv
 EXTERN inline int gmlNumArgsPointParam(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-//glPointParametefv
 		case GL_POINT_SIZE_MIN:
 		case GL_POINT_SIZE_MAX:
 		case GL_POINT_FADE_THRESHOLD_SIZE:
@@ -155,15 +142,14 @@
 		case GL_POINT_DISTANCE_ATTENUATION:
 			return 3;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsPointParam&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsPointParam&quot;, datatype)
 			return 0;
 	}
 }
 
+//glTexParameterfv
 EXTERN inline int gmlNumArgsTexParam(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-//glTexParameterfv
 		case GL_TEXTURE_MIN_FILTER:
 		case GL_TEXTURE_MAG_FILTER:
 		case GL_TEXTURE_WRAP_S:
@@ -173,28 +159,70 @@
 		case GL_TEXTURE_BORDER_COLOR:
 			return 4;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsTexParam&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsTexParam&quot;, datatype)
 			return 0;
 	}
 }
 
+//glLightModelfv
 EXTERN inline int gmlNumArgsLightModel(int datatype) {
-//	FILE *f;
 	switch(datatype) {
-//glLightModelfv
 		case GL_LIGHT_MODEL_LOCAL_VIEWER:
 		case GL_LIGHT_MODEL_TWO_SIDE:
 			return 1;
 		case GL_LIGHT_MODEL_AMBIENT:
 			return 4;
 		default:
-//      GML_NERROR_FUN(&quot;gmlNumArgsLightModel&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlNumArgsLightModel&quot;, datatype)
 			return 0;
 	}
 }
 
+//glMap1f
+EXTERN inline int gmlNumArgsMap1(int datatype) {
+	switch(datatype) {
+		case GL_MAP1_INDEX:
+		case GL_MAP1_TEXTURE_COORD_1:
+			return 1;
+		case GL_MAP1_TEXTURE_COORD_2:
+			return 2;
+		case GL_MAP1_VERTEX_3:
+		case GL_MAP1_NORMAL:
+		case GL_MAP1_TEXTURE_COORD_3:
+			return 3;
+		case GL_MAP1_VERTEX_4:
+		case GL_MAP1_COLOR_4:
+		case GL_MAP1_TEXTURE_COORD_4:
+			return 4;
+		default:
+			GML_DEBUG_FUN(&quot;gmlNumArgsMap1&quot;, datatype)
+			return 0;
+	}
+}
+
+//glMap2f
+EXTERN inline int gmlNumArgsMap2(int datatype) {
+	switch(datatype) {
+		case GL_MAP2_INDEX:
+		case GL_MAP2_TEXTURE_COORD_1:
+			return 1;
+		case GL_MAP2_TEXTURE_COORD_2:
+			return 2;
+		case GL_MAP2_VERTEX_3:
+		case GL_MAP2_NORMAL:
+		case GL_MAP2_TEXTURE_COORD_3:
+			return 3;
+		case GL_MAP2_VERTEX_4:
+		case GL_MAP2_COLOR_4:
+		case GL_MAP2_TEXTURE_COORD_4:
+			return 4;
+		default:
+			GML_DEBUG_FUN(&quot;gmlNumArgsMap2&quot;, datatype)
+			return 0;
+	}
+}
+
 EXTERN inline int gmlSizeOf(int datatype) {
-//	FILE *f;
 	switch(datatype) {
 		case GL_UNSIGNED_BYTE:
 			return sizeof(GLubyte);
@@ -215,7 +243,7 @@
 		case GL_DOUBLE:
 			return sizeof(GLdouble);
 		default:
-//      GML_NERROR_FUN(&quot;gmlSizeOf&quot;, datatype)
+			GML_DEBUG_FUN(&quot;gmlSizeOf&quot;, datatype)
 			return 0;
 	}
 }
@@ -249,44 +277,44 @@
 #define GML_RETVAL(ft) return (ft)*(volatile ft *)&amp;(p-&gt;ret);
 
 #define GML_RELOC()\
-     while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-       qd-&gt;WaitRealloc();
+	while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+		qd-&gt;WaitRealloc();
 
 #define GML_PREP_FIXED(name)\
-     gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];\
-     int datasize=sizeof(gml##name##Data);\
-     GML_RELOC()\
-     gml##name##Data *p=(gml##name##Data *)qd-&gt;WritePos;\
-	 p-&gt;type=gml##name##Enum;
+	gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];\
+	int datasize=sizeof(gml##name##Data);\
+	GML_RELOC()\
+	gml##name##Data *p=(gml##name##Data *)qd-&gt;WritePos;\
+	p-&gt;type=gml##name##Enum;
 
 #define GML_UPD_POS()\
-     qd-&gt;WritePos+=datasize;
+	qd-&gt;WritePos+=datasize;
 
 #define GML_UPD_SIZE()\
-  	 p-&gt;size=datasize;\
+	p-&gt;size=datasize;\
 
 #define GML_PREP_VAR(name,sizefun)\
-     gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];\
-	 int size=sizefun;\
-     int datasize=sizeof(gml##name##Data)+size;\
-     GML_RELOC()\
-     gml##name##Data *p=(gml##name##Data *)qd-&gt;WritePos;\
-     p-&gt;type=gml##name##Enum;
+	gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];\
+	int size=sizefun;\
+	int datasize=sizeof(gml##name##Data)+size;\
+	GML_RELOC()\
+	gml##name##Data *p=(gml##name##Data *)qd-&gt;WritePos;\
+	p-&gt;type=gml##name##Enum;
 
 #define GML_PREP_VAR_SIZE(name,sizefun)\
- 	 GML_PREP_VAR(name,sizefun)\
-	 GML_UPD_SIZE()
+	GML_PREP_VAR(name,sizefun)\
+	GML_UPD_SIZE()
 
 #define GML_COND(stmt)\
-  GML_IF_SERVER_THREAD() {\
-    stmt;\
-	return;\
-  }
+	GML_IF_SERVER_THREAD() {\
+		stmt;\
+		return;\
+	}
 
 #define GML_COND_RET(stmt)\
-  GML_IF_SERVER_THREAD() {\
-    return stmt;\
-  }
+	GML_IF_SERVER_THREAD() {\
+		return stmt;\
+	}
 
 EXTERN inline void gmlSync(gmlQueue *qd) {
 	qd-&gt;SyncRequest();
@@ -296,692 +324,713 @@
 
 #define GML_SYNC() gmlSync(qd)
 
+#define GML_FUN(name,ftype) EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+	EXTERN inline ftype gml##name
+
+#define GML_RETFUN(name,ftr) EXTERN inline ftr gml##name
+
 #define GML_MAKEFUN0(name) struct gml##name##Data {\
-  GML_MAKEVAR()\
+	GML_MAKEVAR()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name() {\
-  GML_COND(gl##name())\
-  GML_PREP_FIXED(name)\
-  GML_UPD_POS()\
+GML_FUN(name,void)() {\
+	GML_COND(gl##name())\
+	GML_PREP_FIXED(name)\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN0R(name,ftypeR,cache) struct gml##name##Data {\
-  GML_MAKEVAR()\
-  GML_MAKEVAR_RET(ftypeR)\
+	GML_MAKEVAR()\
+	GML_MAKEVAR_RET(ftypeR)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline ftypeR gml##name() {\
-  GML_COND_RET(gl##name())\
+GML_FUN(name,ftypeR)() {\
+	GML_COND_RET(gl##name())\
 	cache\
-  GML_PREP_FIXED(name)\
-  GML_UPD_POS()\
-  GML_SYNC();\
-  GML_RETVAL(ftypeR)\
+	GML_PREP_FIXED(name)\
+	GML_UPD_POS()\
+	GML_SYNC();\
+	GML_RETVAL(ftypeR)\
 }
 
 #define GML_MAKEFUN1(name,ftype1) struct gml##name##Data {\
-  GML_MAKEVAR_A(ftype1)\
+	GML_MAKEVAR_A(ftype1)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A) {\
-  GML_COND(gl##name(A))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_A()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A) {\
+	GML_COND(gl##name(A))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_A()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN1R(name,ftype1,ftypeR,cache) struct gml##name##Data {\
-  GML_MAKEVAR_A(ftype1)\
-  GML_MAKEVAR_RET(ftypeR)\
+	GML_MAKEVAR_A(ftype1)\
+	GML_MAKEVAR_RET(ftypeR)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline ftypeR gml##name(ftype1 A) {\
-  GML_COND_RET(gl##name(A))\
+GML_FUN(name,ftypeR)(ftype1 A) {\
+	GML_COND_RET(gl##name(A))\
 	cache\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_A()\
-  GML_UPD_POS()\
-  GML_SYNC();\
-  GML_RETVAL(ftypeR)\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_A()\
+	GML_UPD_POS()\
+	GML_SYNC();\
+	GML_RETVAL(ftypeR)\
 }
 
 #define GML_MAKEFUN2(name,ftype1,ftype2,cache,...) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
+	GML_MAKEVAR_B(ftype1,ftype2)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B) {\
-  GML_COND(gl##name(A,B))\
+GML_FUN(name,void)(ftype1 A, ftype2 B) {\
+	GML_COND(gl##name(A,B))\
 	cache\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_B()\
-  GML_UPD_POS()\
-  GML_SYNC_COND(__VA_ARGS__,)\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_B()\
+	GML_UPD_POS()\
+	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
 #define GML_MAKEFUN2B(name,ftype1,ftype2) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
+	GML_MAKEVAR_B(ftype1,ftype2)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B) {\
-  GML_COND(gl##name(A,B))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_B()\
+GML_FUN(name,void)(ftype1 A, ftype2 B) {\
+	GML_COND(gl##name(A,B))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_B()\
 	switch(A) {\
-	  case GL_ARRAY_BUFFER:\
-		  qd-&gt;ArrayBuffer=B; break;\
-	  case GL_ELEMENT_ARRAY_BUFFER:\
-      qd-&gt;ElementArrayBuffer=B; break;\
-	  case GL_PIXEL_PACK_BUFFER:\
-      qd-&gt;PixelPackBuffer=B; break;\
-	  case GL_PIXEL_UNPACK_BUFFER:\
-      qd-&gt;PixelUnpackBuffer=B; break;\
-  }\
-  GML_UPD_POS()\
+		case GL_ARRAY_BUFFER:\
+			qd-&gt;ArrayBuffer=B; break;\
+		case GL_ELEMENT_ARRAY_BUFFER:\
+			qd-&gt;ElementArrayBuffer=B; break;\
+		case GL_PIXEL_PACK_BUFFER:\
+			qd-&gt;PixelPackBuffer=B; break;\
+		case GL_PIXEL_UNPACK_BUFFER:\
+			qd-&gt;PixelUnpackBuffer=B; break;\
+	}\
+	GML_UPD_POS()\
 }
 
 
 #define GML_MAKEFUN2R(name,ftype1,ftype2,ftypeR) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
-  GML_MAKEVAR_RET(ftypeR)\
+	GML_MAKEVAR_B(ftype1,ftype2)\
+	GML_MAKEVAR_RET(ftypeR)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline ftypeR gml##name(ftype1 A,ftype2 B) {\
-  GML_COND_RET(gl##name(A,B))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_B()\
-  GML_UPD_POS()\
-  GML_SYNC();\
-  GML_RETVAL(ftypeR)\
+GML_FUN(name,ftypeR)(ftype1 A,ftype2 B) {\
+	GML_COND_RET(gl##name(A,B))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_B()\
+	GML_UPD_POS()\
+	GML_SYNC();\
+	GML_RETVAL(ftypeR)\
 }
 
 #define GML_MAKEFUN3(name,ftype1,ftype2,ftype3,cache,...) struct gml##name##Data {\
-  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+	GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
-  GML_COND(gl##name(A,B,C))\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C) {\
+	GML_COND(gl##name(A,B,C))\
 	cache\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_C()\
-  GML_UPD_POS()\
-  GML_SYNC_COND(__VA_ARGS__,)\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_C()\
+	GML_UPD_POS()\
+	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
 #define GML_MAKEFUN4(name,ftype1,ftype2,ftype3,ftype4,...) struct gml##name##Data {\
-  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4)\
+	GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
-  GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_D()\
-  GML_UPD_POS()\
-  GML_SYNC_COND(__VA_ARGS__,)\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
+	GML_COND(gl##name(A,B,C,D))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_D()\
+	GML_UPD_POS()\
+	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
 #define GML_MAKEFUN5(name,ftype1,ftype2,ftype3,ftype4,ftype5) struct gml##name##Data {\
-  GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5)\
+	GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E) {\
-  GML_COND(gl##name(A,B,C,D,E))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_E()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E) {\
+	GML_COND(gl##name(A,B,C,D,E))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_E()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN6(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) struct gml##name##Data {\
-  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F) {\
-  GML_COND(gl##name(A,B,C,D,E,F))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_F()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F) {\
+	GML_COND(gl##name(A,B,C,D,E,F))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_F()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN7(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,...) struct gml##name##Data {\
-  GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+	GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_G()\
-  GML_UPD_POS()\
-  GML_SYNC_COND(__VA_ARGS__,)\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_G()\
+	GML_UPD_POS()\
+	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
 #define GML_MAKEFUN8(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) struct gml##name##Data {\
-  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+	GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_H()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_H()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN9(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) struct gml##name##Data {\
-  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_I()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_I()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN9R(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftypeR) struct gml##name##Data {\
-  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
-  GML_MAKEVAR_RET(ftypeR)\
+	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+	GML_MAKEVAR_RET(ftypeR)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline ftypeR gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
-  GML_COND_RET(gl##name(A,B,C,D,E,F,G,H,I))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_I()\
-  GML_UPD_POS()\
-  GML_SYNC();\
-  GML_RETVAL(ftypeR)\
+GML_FUN(name,ftypeR)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
+	GML_COND_RET(gl##name(A,B,C,D,E,F,G,H,I))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_I()\
+	GML_UPD_POS()\
+	GML_SYNC();\
+	GML_RETVAL(ftypeR)\
 }
 
 
 #define GML_MAKEFUN10(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10) struct gml##name##Data {\
-  GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10)\
+	GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 J) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_J()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 J) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_J()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN7S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,sizefun) struct gml##name##Data {\
-  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
-  GML_MAKEVAR_SIZE()\
+	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+	GML_MAKEVAR_SIZE()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G))\
-  GML_PREP_VAR_SIZE(name,sizefun)\
-  GML_MAKEASS_F()\
-  memcpy(p+1,G,size);\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G))\
+	GML_PREP_VAR_SIZE(name,sizefun)\
+	GML_MAKEASS_F()\
+	memcpy(p+1,G,size);\
+	GML_UPD_POS()\
 }
 
 #define GML_PUB_COPY(name,var,ftype)\
 	p-&gt;var=NULL;\
 	if(qd-&gt;PixelUnpackBuffer) {\
-	  datasize=sizeof(gml##name##Data);\
+		datasize=sizeof(gml##name##Data);\
 		p-&gt;var=(ftype)((BYTE *)var+1);\
 	}\
 	else if(var!=NULL)\
-    memcpy(p+1,var,size);
+		memcpy(p+1,var,size);
 
 #define GML_MAKEFUN8S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,sizefun) struct gml##name##Data {\
-  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8 *)\
-  GML_MAKEVAR_SIZE()\
+	GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8 *)\
+	GML_MAKEVAR_SIZE()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H))\
-  GML_PREP_VAR(name,sizefun)\
-  GML_MAKEASS_G()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+	GML_PREP_VAR(name,sizefun)\
+	GML_MAKEASS_G()\
 	GML_PUB_COPY(name,H,ftype8 *)\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN9S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,sizefun) struct gml##name##Data {\
-  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9 *)\
-  GML_MAKEVAR_SIZE()\
+	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9 *)\
+	GML_MAKEVAR_SIZE()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
-  GML_PREP_VAR(name,sizefun)\
-  GML_MAKEASS_H()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+	GML_PREP_VAR(name,sizefun)\
+	GML_MAKEASS_H()\
 	GML_PUB_COPY(name,I,ftype9 *)\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN10S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10,sizefun) struct gml##name##Data {\
-  GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10 *)\
-  GML_MAKEVAR_SIZE()\
+	GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10 *)\
+	GML_MAKEVAR_SIZE()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 *J) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
-  GML_PREP_VAR(name,sizefun)\
-  GML_MAKEASS_I()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 *J) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+	GML_PREP_VAR(name,sizefun)\
+	GML_MAKEASS_I()\
 	GML_PUB_COPY(name,J,ftype10 *)\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN1V(name,ftype1,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR()\
-  GML_MAKEVAR_SIZE()\
-  ftypeX A;\
+	GML_MAKEVAR()\
+	GML_MAKEVAR_SIZE()\
+	ftypeX A;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1* A) {\
-  GML_COND(gl##name(A))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
-  memcpy(&amp;(p-&gt;A),A,size+sizeof(ftypeX));\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1* A) {\
+	GML_COND(gl##name(A))\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	memcpy(&amp;(p-&gt;A),A,size+sizeof(ftypeX));\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN2V(name,ftype1,ftype2,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_A(ftype1)\
-  GML_MAKEVAR_SIZE()\
-  ftypeX B;\
+	GML_MAKEVAR_A(ftype1)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX B;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2* B) {\
-  GML_COND(gl##name(A,B))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_A()\
-  memcpy(&amp;(p-&gt;B),B,size+sizeof(ftypeX));\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2* B) {\
+	GML_COND(gl##name(A,B))\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_A()\
+	memcpy(&amp;(p-&gt;B),B,size+sizeof(ftypeX));\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN3V(name,ftype1,ftype2,ftype3,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
-  GML_MAKEVAR_SIZE()\
-  ftypeX C;\
+	GML_MAKEVAR_B(ftype1,ftype2)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX C;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3* C) {\
-  GML_COND(gl##name(A,B,C))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_B()\
-  memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3* C) {\
+	GML_COND(gl##name(A,B,C))\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_B()\
+	memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN4V(name,ftype1,ftype2,ftype3,ftype4,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
-  GML_MAKEVAR_SIZE()\
-  ftypeX D;\
+	GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX D;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
-  GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_C()\
-  memcpy(&amp;(p-&gt;D),D,size+sizeof(ftypeX));\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
+	GML_COND(gl##name(A,B,C,D))\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_C()\
+	memcpy(&amp;(p-&gt;D),D,size+sizeof(ftypeX));\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN4VS(name,ftype1,ftype2,ftype3,ftype4,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
-  ftype4 D;\
-  GML_MAKEVAR_SIZE()\
-  ftypeX C;\
+	GML_MAKEVAR_B(ftype1,ftype2)\
+	ftype4 D;\
+	GML_MAKEVAR_SIZE()\
+	ftypeX C;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C, ftype4 D) {\
-  GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_B()\
-  p-&gt;D=D;\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 *C, ftype4 D) {\
+	GML_COND(gl##name(A,B,C,D))\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_B()\
+	p-&gt;D=D;\
 	if(C!=NULL)\
-    memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
-  GML_UPD_POS()\
+		memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN4VSS(name,ftype1,ftype2,ftype3,ftype4,count) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
-  int lensize;\
-  GML_MAKEVAR_SIZE()\
-  ftype3 *C;\
+	GML_MAKEVAR_B(ftype1,ftype2)\
+	int lensize;\
+	GML_MAKEVAR_SIZE()\
+	ftype3 *C;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 **C, ftype4 *D) {\
-  GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR(name,(count-1)*sizeof(ftype3 *))\
-  GML_MAKEASS_B()\
-  p-&gt;lensize=datasize;\
-  BYTE *e=(BYTE *)p+datasize;\
-  for(int i=0; i&lt;B; ++i) {\
-	  BOOL_ len=!D || D[i]&lt;0;\
-	  GLint sl=(len?strlen(C[i]):D[i])+1;\
-	  datasize+=sl;\
-	  ((intptr_t *)&amp;(p-&gt;C))[i]=sl;\
-      --sl;\
-    while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-      p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
-    memcpy(e,C[i],sl);\
-	  e+=sl;\
-	  *e='\0';\
-    ++e;\
-  }\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 **C, ftype4 *D) {\
+	GML_COND(gl##name(A,B,C,D))\
+	GML_PREP_VAR(name,(count-1)*sizeof(ftype3 *))\
+	GML_MAKEASS_B()\
+	p-&gt;lensize=datasize;\
+	BYTE *e=(BYTE *)p+datasize;\
+	for(int i=0; i&lt;B; ++i) {\
+		BOOL_ len=!D || D[i]&lt;0;\
+		GLint sl=(len?strlen(C[i]):D[i])+1;\
+		datasize+=sl;\
+		((intptr_t *)&amp;(p-&gt;C))[i]=sl;\
+			--sl;\
+		while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+			p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+		memcpy(e,C[i],sl);\
+		e+=sl;\
+		*e='\0';\
+		++e;\
+	}\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_PUB_PCOPY(name,var,pvar,ftype)\
 	p-&gt;pvar=NULL;\
 	if(qd-&gt;PixelUnpackBuffer) {\
-	  datasize=sizeof(gml##name##Data);\
+		datasize=sizeof(gml##name##Data);\
 		p-&gt;pvar=(ftype *)var+1;\
 	}\
 	else if(var!=NULL)\
-    memcpy(&amp;(p-&gt;var),var,size+sizeof(ftype));
+		memcpy(&amp;(p-&gt;var),var,size+sizeof(ftype));
 
+#define GML_STDCOPY1(type,count,stride,nargs)\
+	for(int i=0; i&lt;count; ++i) {\
+		type *v2=v;\
+		for(int j=0; j&lt;nargs; ++j) {\
+			*e=*v2;\
+			++e;\
+			++v2;\
+		}\
+		v+=stride;\
+	}
+
+#define GML_MAKEFUN6VST(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftypeX,count,stride,numargs) struct gml##name##Data {\
+	GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX F;\
+};\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 *F) {\
+	GML_COND(gl##name(A,B,C,D,E,F))\
+	int nargs=numargs;\
+	GML_PREP_VAR_SIZE(name,(nargs*count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_E()\
+	p-&gt;stride=nargs;\
+	ftypeX *e=&amp;(p-&gt;F);\
+	ftype6 *v=F;\
+	GML_STDCOPY1(ftype6,count,stride,nargs)\
+	GML_UPD_POS()\
+}
+
+#define GML_STDCOPY2(type,count1,stride1,count2,stride2,nargs)\
+	for(int i=0; i&lt;count1; ++i) {\
+		type *v2=v;\
+		for(int j=0; j&lt;count2; ++j) {\
+			type *v3=v2;\
+			for(int k=0; k&lt;nargs; ++k) {\
+				*e=*v3;\
+				++e;\
+				++v3;\
+			}\
+			v2+=stride2;\
+		}\
+		v+=stride1;\
+	}
+
+#define GML_MAKEFUN10VST(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10,ftypeX,count1,stride1,count2,stride2,numargs) struct gml##name##Data {\
+	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX J;\
+};\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 *J) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+	int nargs=numargs;\
+	GML_PREP_VAR_SIZE(name,(nargs*count1*count2-1)*sizeof(ftypeX))\
+	GML_MAKEASS_I()\
+	p-&gt;stride1=nargs*count2;\
+	p-&gt;stride2=nargs;\
+	ftypeX *e=&amp;(p-&gt;J);\
+	ftype10 *v=J;\
+	GML_STDCOPY2(ftype10,count1,stride1,count2,stride2,nargs)\
+	GML_UPD_POS()\
+}
+
 #define GML_MAKEFUN7VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
-  GML_MAKEVAR_SIZE()\
-  ftypeX *GP;\
-  ftypeX G;\
+	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX *GP;\
+	ftypeX G;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G))\
-  GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_F()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G))\
+	GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_F()\
 	GML_PUB_PCOPY(name,G,GP,ftypeX)\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN8VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
-  GML_MAKEVAR_SIZE()\
-  ftypeX *HP;\
-  ftypeX H;\
+	GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX *HP;\
+	ftypeX H;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H))\
-  GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_G()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+	GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_G()\
 	GML_PUB_PCOPY(name,H,HP,ftypeX)\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN9VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftypeX,count) struct gml##name##Data {\
-  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
-  GML_MAKEVAR_SIZE()\
-  ftypeX *IP;\
-  ftypeX I;\
+	GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+	GML_MAKEVAR_SIZE()\
+	ftypeX *IP;\
+	ftypeX I;\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
-  GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
-  GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
-  GML_MAKEASS_H()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
+	GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+	GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
+	GML_MAKEASS_H()\
 	GML_PUB_PCOPY(name,I,IP,ftypeX)\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN1CS(name,ftype1,arg) struct gml##name##Data {\
-  GML_MAKEVAR_A(ftype1)\
+	GML_MAKEVAR_A(ftype1)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A) {\
-  GML_COND(gl##name(A))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_A()\
-  qd-&gt;ClientState arg (1&lt;&lt;(A-GL_VERTEX_ARRAY));\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A) {\
+	GML_COND(gl##name(A))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_A()\
+	qd-&gt;ClientState arg (1&lt;&lt;(A-GL_VERTEX_ARRAY));\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN1VA(name,ftype1,arg,fun) struct gml##name##Data {\
-  GML_MAKEVAR_A(ftype1)\
+	GML_MAKEVAR_A(ftype1)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A) {\
-  GML_COND(gl##name(A))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_A()\
-  qd-&gt;arg##set.fun(A);\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A) {\
+	GML_COND(gl##name(A))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_A()\
+	qd-&gt;arg##set.fun(A);\
+	GML_UPD_POS()\
 }
 
 #define GML_UPD_CS(arg)\
 	if(qd-&gt;ArrayBuffer)\
-  	qd-&gt;ClientState |= GML_##arg##_ARRAY_BUFFER;\
+		qd-&gt;ClientState |= GML_##arg##_ARRAY_BUFFER;\
 	else\
-  	qd-&gt;ClientState &amp;= ~GML_##arg##_ARRAY_BUFFER;
+		qd-&gt;ClientState &amp;= ~GML_##arg##_ARRAY_BUFFER;
 
 #define GML_MAKEFUN2P(name,ftype1,ftype2,arg) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2 *)\
+	GML_MAKEVAR_B(ftype1,ftype2 *)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 *B) {\
-  GML_COND(gl##name(A,B))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_B()\
-  qd-&gt;arg##stride=A;\
-  qd-&gt;arg##pointer=B;\
+GML_FUN(name,void)(ftype1 A, ftype2 *B) {\
+	GML_COND(gl##name(A,B))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_B()\
+	qd-&gt;arg##stride=A;\
+	qd-&gt;arg##pointer=B;\
 	GML_UPD_CS(arg)\
-  GML_UPD_POS()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN3P(name,ftype1,ftype2,ftype3,arg) struct gml##name##Data {\
-  GML_MAKEVAR_C(ftype1,ftype2,ftype3 *)\
+	GML_MAKEVAR_C(ftype1,ftype2,ftype3 *)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C) {\
-  GML_COND(gl##name(A,B,C))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_C()\
-  qd-&gt;arg##type=A;\
-  qd-&gt;arg##stride=B;\
-  qd-&gt;arg##pointer=C;\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 *C) {\
+	GML_COND(gl##name(A,B,C))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_C()\
+	qd-&gt;arg##type=A;\
+	qd-&gt;arg##stride=B;\
+	qd-&gt;arg##pointer=C;\
 	GML_UPD_CS(arg)\
-  GML_UPD_POS()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN4P(name,ftype1,ftype2,ftype3,ftype4,arg) struct gml##name##Data {\
-  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
+	GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
-  GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_D()\
-  qd-&gt;arg##size=A;\
-  qd-&gt;arg##type=B;\
-  qd-&gt;arg##stride=C;\
-  qd-&gt;arg##pointer=D;\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
+	GML_COND(gl##name(A,B,C,D))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_D()\
+	qd-&gt;arg##size=A;\
+	qd-&gt;arg##type=B;\
+	qd-&gt;arg##stride=C;\
+	qd-&gt;arg##pointer=D;\
 	GML_UPD_CS(arg)\
-  GML_UPD_POS()\
+	GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN6P(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,arg) struct gml##name##Data {\
-  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6 *)\
+	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6 *)\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 *F) {\
-  GML_COND(gl##name(A,B,C,D,E,F))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_F()\
-  qd-&gt;arg##map[A]=arg##data(B,C,D,E,F,qd-&gt;ArrayBuffer);\
-  GML_UPD_POS()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 *F) {\
+	GML_COND(gl##name(A,B,C,D,E,F))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_F()\
+	qd-&gt;arg##map[A]=arg##data(B,C,D,E,F,qd-&gt;ArrayBuffer);\
+	GML_UPD_POS()\
 }
 
 #define GML_MEMCOPY()\
 	for(int i=0; i&lt;C; ++i) {\
-  	BYTE *e2=e;\
-  	BYTE *v2=v;\
-	  for(int j=0; j&lt;itemsize; ++j) {\
-	    *e2=*v2;\
-		  ++e2;\
-		  ++v2;\
-	  }\
-	  e+=itemsize;\
-	  v+=itemstride;\
-  }\
+		BYTE *v2=v;\
+		for(int j=0; j&lt;itemsize; ++j) {\
+			*e=*v2;\
+			++e;\
+			++v2;\
+		}\
+		v+=itemstride;\
+	}
 
 #define GML_IDXLOOP(ltype)\
 	for(int i=0; i&lt;B; ++i) {\
-  	BYTE *e2=e;\
-  	BYTE *v2=v+(*(ltype *)dt)*itemstride;\
+		BYTE *v2=v+(*(ltype *)dt)*itemstride;\
 		dt+=sizeof(ltype);\
-	  for(int j=0; j&lt;itemsize; ++j) {\
-	    *e2=*v2;\
-		  ++e2;\
-		  ++v2;\
-	  }\
-	  e+=itemsize;\
-  }
+		for(int j=0; j&lt;itemsize; ++j) {\
+			*e=*v2;\
+			++e;\
+			++v2;\
+		}\
+	}
 
 #define GML_IDXCOPY()\
 	BYTE *dt=(BYTE *)D;\
-  switch(C) {\
-    case GL_UNSIGNED_INT:\
-      GML_IDXLOOP(GLuint)\
-      break;\
-    case GL_UNSIGNED_SHORT:\
-	    GML_IDXLOOP(GLushort)\
-	    break;\
-    case GL_UNSIGNED_BYTE:\
-	    GML_IDXLOOP(GLubyte)\
-	    break;\
-  }
+	switch(C) {\
+		case GL_UNSIGNED_INT:\
+			GML_IDXLOOP(GLuint)\
+			break;\
+		case GL_UNSIGNED_SHORT:\
+			GML_IDXLOOP(GLushort)\
+			break;\
+		case GL_UNSIGNED_BYTE:\
+			GML_IDXLOOP(GLubyte)\
+			break;\
+	}
 
 #define GML_MAKESUBFUNDA(name,pre,arg,sizefun,sizeass,typeass,first,count,copyfun)\
 	if(clientstate &amp; (1&lt;&lt;(pre-GL_VERTEX_ARRAY))) {\
-  	int itemsize=sizefun;\
-	  int itemstride=qd-&gt;arg##stride;\
-    if(itemstride==0)\
-      itemstride=itemsize;\
-  	p-&gt;arg##totalsize=0;\
-    p-&gt;arg##pointer=(GLvoid *)((BYTE *)qd-&gt;arg##pointer+first*itemstride);\
-    sizeass;\
-    typeass;\
-	  if(!(qd-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)) {\
-	    p-&gt;arg##totalsize=itemsize*count;\
-      datasize+=p-&gt;arg##totalsize;\
-      while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-        p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
-      BYTE *v=(BYTE *)p-&gt;arg##pointer;\
-	    copyfun\
-    }\
+		int itemsize=sizefun;\
+		int itemstride=qd-&gt;arg##stride;\
+		if(itemstride==0)\
+			itemstride=itemsize;\
+		p-&gt;arg##totalsize=0;\
+		p-&gt;arg##pointer=(GLvoid *)((BYTE *)qd-&gt;arg##pointer+first*itemstride);\
+		sizeass;\
+		typeass;\
+		if(!(qd-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)) {\
+			p-&gt;arg##totalsize=itemsize*count;\
+			datasize+=p-&gt;arg##totalsize;\
+			while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+				p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+			BYTE *v=(BYTE *)p-&gt;arg##pointer;\
+			copyfun\
+		}\
 	}
 
 #define GML_MAKEPOINTERDATA()\
-  GLenum ClientState;\
-  GLint VPsize;\
-  GLenum VPtype;\
-  GLvoid * VPpointer;\
-  int VPtotalsize;\
-  GLint CPsize;\
-  GLenum CPtype;\
-  GLvoid * CPpointer;\
-  int CPtotalsize;\
-  GLint TCPsize;\
-  GLenum TCPtype;\
-  GLvoid * TCPpointer;\
-  int TCPtotalsize;\
-  GLenum IPtype;\
-  GLvoid * IPpointer;\
-  int IPtotalsize;\
-  GLenum NPtype;\
-  GLvoid *NPpointer;\
-  int NPtotalsize;\
-  GLvoid * EFPpointer;\
-  int EFPtotalsize;\
-  int VAcount;
+	GLenum ClientState;\
+	GLint VPsize;\
+	GLenum VPtype;\
+	GLvoid * VPpointer;\
+	int VPtotalsize;\
+	GLint CPsize;\
+	GLenum CPtype;\
+	GLvoid * CPpointer;\
+	int CPtotalsize;\
+	GLint TCPsize;\
+	GLenum TCPtype;\
+	GLvoid * TCPpointer;\
+	int TCPtotalsize;\
+	GLenum IPtype;\
+	GLvoid * IPpointer;\
+	int IPtotalsize;\
+	GLenum NPtype;\
+	GLvoid *NPpointer;\
+	int NPtotalsize;\
+	GLvoid * EFPpointer;\
+	int EFPtotalsize;\
+	int VAcount;
 
 #define GML_MAKESUBFUNVA(name,first,count,copyfun)\
 	p-&gt;VAcount=qd-&gt;VAset.size();\
-  std::set&lt;GLuint&gt;::iterator si=qd-&gt;VAset.begin();\
-  while(si!=qd-&gt;VAset.end()) {\
-    std::map&lt;GLuint,VAdata&gt;::iterator mi=qd-&gt;VAmap.find(*si);\
-\
-    VAdata *vd=&amp;(mi-&gt;second);\
-	  int itemstride=vd-&gt;stride;\
- 	  int itemsize=vd-&gt;size*gmlSizeOf(vd-&gt;type);\
+	std::set&lt;GLuint&gt;::iterator si=qd-&gt;VAset.begin();\
+	while(si!=qd-&gt;VAset.end()) {\
+		std::map&lt;GLuint,VAdata&gt;::iterator mi=qd-&gt;VAmap.find(*si);\
+		VAdata *vd=&amp;(mi-&gt;second);\
+		int itemstride=vd-&gt;stride;\
+ 		int itemsize=vd-&gt;size*gmlSizeOf(vd-&gt;type);\
 		if(itemstride==0)\
-      itemstride=itemsize;\
+			itemstride=itemsize;\
 		if(vd-&gt;buffer)\
-      itemsize=0;\
-	  int totalsize=itemsize*count+sizeof(VAstruct);\
-    datasize+=totalsize;\
-	  while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-      p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
-\
-    VAstruct *vs=(VAstruct *)e;\
-    e+=sizeof(VAstruct);\
-    vs-&gt;target=*si;\
-    vs-&gt;size=vd-&gt;size;\
-    vs-&gt;type=vd-&gt;type;\
-    vs-&gt;normalized=vd-&gt;normalized;\
-    vs-&gt;totalsize=totalsize;\
-    vs-&gt;pointer=(GLvoid *)((BYTE *)vd-&gt;pointer+first*itemstride);\
+			itemsize=0;\
+		int totalsize=itemsize*count+sizeof(VAstruct);\
+		datasize+=totalsize;\
+		while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+			p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+		VAstruct *vs=(VAstruct *)e;\
+		e+=sizeof(VAstruct);\
+		vs-&gt;target=*si;\
+		vs-&gt;size=vd-&gt;size;\
+		vs-&gt;type=vd-&gt;type;\
+		vs-&gt;normalized=vd-&gt;normalized;\
+		vs-&gt;totalsize=totalsize;\
+		vs-&gt;pointer=(GLvoid *)((BYTE *)vd-&gt;pointer+first*itemstride);\
 		vs-&gt;buffer=vd-&gt;buffer;\
-\
-	  if(!vd-&gt;buffer) {\
-      BYTE *v=(BYTE *)vs-&gt;pointer;\
-  	  copyfun\
-	  }\
-\
-    ++si;\
-  }
+		if(!vd-&gt;buffer) {\
+			BYTE *v=(BYTE *)vs-&gt;pointer;\
+			copyfun\
+		}\
+		++si;\
+	}
 
 
 #define GML_MAKEFUN3VDA(name,ftype1,ftype2,ftype3) struct gml##name##Data {\
-  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
-  GML_MAKEPOINTERDATA()\
-  GML_MAKEVAR_SIZE()\
+	GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+	GML_MAKEPOINTERDATA()\
+	GML_MAKEVAR_SIZE()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
-  GML_COND(gl##name(A,B,C))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_C()\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C) {\
+	GML_COND(gl##name(A,B,C))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_C()\
 	GLenum clientstate=qd-&gt;ClientState &amp; ~(qd-&gt;ClientState&gt;&gt;16);\
-  p-&gt;ClientState=qd-&gt;ClientState;\
-  BYTE *e=(BYTE *)(p+1);\
-  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype,B,C,GML_MEMCOPY())\
-  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype,B,C,GML_MEMCOPY())\
-  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype,B,C,GML_MEMCOPY())\
-  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype,B,C,GML_MEMCOPY())\
-  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype,B,C,GML_MEMCOPY())\
-  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,,B,C,GML_MEMCOPY())\
-  GML_MAKESUBFUNVA(name,B,C,GML_MEMCOPY())\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+	p-&gt;ClientState=qd-&gt;ClientState;\
+	BYTE *e=(BYTE *)(p+1);\
+	GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype,B,C,GML_MEMCOPY())\
+	GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype,B,C,GML_MEMCOPY())\
+	GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype,B,C,GML_MEMCOPY())\
+	GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype,B,C,GML_MEMCOPY())\
+	GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype,B,C,GML_MEMCOPY())\
+	GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,,B,C,GML_MEMCOPY())\
+	GML_MAKESUBFUNVA(name,B,C,GML_MEMCOPY())\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 
 #define GML_MAKEFUN4VDE(name,ftype1,ftype2,ftype3,ftype4) struct gml##name##Data {\
-  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
-  GML_MAKEPOINTERDATA()\
-  GML_MAKEVAR_SIZE()\
+	GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
+	GML_MAKEPOINTERDATA()\
+	GML_MAKEVAR_SIZE()\
 };\
-EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
-  GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_FIXED(name)\
-  GML_MAKEASS_D()\
-  BYTE *e=(BYTE *)(p+1);\
+GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
+	GML_COND(gl##name(A,B,C,D))\
+	GML_PREP_FIXED(name)\
+	GML_MAKEASS_D()\
+	BYTE *e=(BYTE *)(p+1);\
 	GLenum clientstate=qd-&gt;ClientState &amp; ~(qd-&gt;ClientState&gt;&gt;16);\
-  p-&gt;ClientState=qd-&gt;ClientState;\
+	p-&gt;ClientState=qd-&gt;ClientState;\
 	if(qd-&gt;ElementArrayBuffer)\
-	  p-&gt;ClientState |= GML_ELEMENT_ARRAY_BUFFER;\
-  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype,0,B,GML_IDXCOPY())\
-  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype,0,B,GML_IDXCOPY())\
-  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype,0,B,GML_IDXCOPY())\
-  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype,0,B,GML_IDXCOPY())\
-  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype,0,B,GML_IDXCOPY())\
-  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,,0,B,GML_IDXCOPY())\
-  GML_MAKESUBFUNVA(name,0,B,GML_IDXCOPY())\
-  GML_UPD_SIZE()\
-  GML_UPD_POS()\
+		p-&gt;ClientState |= GML_ELEMENT_ARRAY_BUFFER;\
+	GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype,0,B,GML_IDXCOPY())\
+	GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype,0,B,GML_IDXCOPY())\
+	GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype,0,B,GML_IDXCOPY())\
+	GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype,0,B,GML_IDXCOPY())\
+	GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype,0,B,GML_IDXCOPY())\
+	GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,,0,B,GML_IDXCOPY())\
+	GML_MAKESUBFUNVA(name,0,B,GML_IDXCOPY())\
+	GML_UPD_SIZE()\
+	GML_UPD_POS()\
 }
 
 
@@ -1224,5 +1273,23 @@
 GML_MAKEFUN3P(IndexPointer,GLenum,GLsizei,GLvoid, IP)//
 GML_MAKEFUN2P(EdgeFlagPointer,GLsizei,GLboolean, EFP)
 GML_MAKEFUN4(TrackMatrixNV,GLenum,GLuint,GLenum,GLenum)
+GML_MAKEFUN3(ProgramParameteriEXT,GLuint,GLenum,GLint,)
+GML_MAKEFUN4(BlendColor,GLclampf,GLclampf,GLclampf,GLclampf)
+GML_MAKEFUN6VST(Map1f,GLenum,GLfloat,GLfloat,GLint,GLint,const GLfloat,GLfloat,E,D,gmlNumArgsMap1(A))
+GML_MAKEFUN10VST(Map2f,GLenum,GLfloat,GLfloat,GLint,GLint,GLfloat,GLfloat,GLint,GLint,const GLfloat,GLfloat,E,D,I,H,gmlNumArgsMap2(A))
+GML_MAKEFUN3(MapGrid1f,GLint,GLfloat,GLfloat,)
+GML_MAKEFUN6(MapGrid2f,GLint,GLfloat,GLfloat,GLint,GLfloat,GLfloat)
+GML_MAKEFUN3(EvalMesh1,GLenum,GLint,GLint,)
+GML_MAKEFUN5(EvalMesh2,GLenum,GLint,GLint,GLint,GLint)
+GML_MAKEFUN1(EvalCoord1f,GLfloat)
+GML_MAKEFUN2(EvalCoord2f,GLfloat,GLfloat,)
+GML_MAKEFUN1(EvalPoint1,GLint)
+GML_MAKEFUN2(EvalPoint2,GLint,GLint,)
+GML_MAKEFUN1R(RenderMode,GLenum,GLint,)
+GML_MAKEFUN2(SelectBuffer,GLsizei,GLuint *,,GML_SYNC())
+GML_MAKEFUN0(InitNames)
+GML_MAKEFUN1(LoadName,GLuint)
+GML_MAKEFUN1(PushName,GLuint)
+GML_MAKEFUN0(PopName)
 
 #endif

Modified: branches/0.77-branch/rts/lib/gml/gmlimp.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmlimp.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gmlimp.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -1,10 +1,10 @@
 // GML - OpenGL Multithreading Library
+// for Spring <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
 // Author: Mattias &quot;zerver&quot; Radeskog
 // (C) Ware Zerver Tech. <A HREF="http://zerver.net">http://zerver.net</A>
-// Ware Zerver Tech. licenses this library to
-// be used freely, for any purpose, within the
-// Spring project <A HREF="http://spring.clan-sy.com">http://spring.clan-sy.com</A>
-// as long as this notice remains unchanged
+// Ware Zerver Tech. licenses this library
+// to be used freely for any purpose, as
+// long as this notice remains unchanged
 
 #undef glAccum
 #undef glActiveStencilFaceEXT
@@ -1563,6 +1563,9 @@
 #undef gluUnProject
 
 
+///////////////////////////////////////////////////////////////////////////////////////
+// Definitions below
+///////////////////////////////////////////////////////////////////////////////////////
 
 
 #define glAccum GML_FUNCTION_NOT_IMPLEMENTED

Modified: branches/0.77-branch/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/0.77-branch/rts/lib/gml/gmlsrv.h	2008-08-28 19:23:48 UTC (rev 6327)
+++ branches/0.77-branch/rts/lib/gml/gmlsrv.h	2008-08-28 20:25:15 UTC (rev 6328)
@@ -12,7 +12,7 @@
 #ifdef USE_GML
 
 #include &lt;boost/thread/barrier.hpp&gt;
-#include  &lt;boost/bind.hpp&gt;
+#include &lt;boost/bind.hpp&gt;
 
 #define GML_MAX_EXEC_DEPTH 4
 
@@ -40,7 +40,7 @@
 
 	void ExecServerFun() {
 		if(serverfun)
-		  (*serverfun)(workerclass);
+			(*serverfun)(workerclass);
 	}
 
 	void ExecAll(int &amp;pos, typename std::list&lt;U&gt;::iterator &amp;it) {
@@ -49,20 +49,20 @@
 			return;
 		if(workeriter) {
 			while(++i&lt;num_units) {
-  			(*workeriter)(workerclass,*it);
+				(*workeriter)(workerclass,*it);
 				++it;
 				++pos;
 			}
 		}
 		else if(worker) {
 			while(++i&lt;num_units)
-  			(*worker)(workerclass);
+				(*worker)(workerclass);
 		}
 		else if(workerarg) {
 			while(++i&lt;num_units)
-  			(*workerarg)(workerclass,i);
+				(*workerarg)(workerclass,i);
 		}
-    UnitCounter%=num_units;
+		UnitCounter%=num_units;
 	}
 
 	BOOL_ Exec(int &amp;pos, typename std::list&lt;U&gt;::iterator &amp;it) {
@@ -92,7 +92,7 @@
 public:
 	int ExecDepth;
 	GML_TYPENAME gmlExecState&lt;R,A,U&gt; ExecState[GML_MAX_EXEC_DEPTH];
-  boost::barrier Barrier; 
+	boost::barrier Barrier; 
 	boost::thread *threads[GML_MAX_NUM_THREADS];
 	BOOL_ inited;
 	gmlCount threadcnt;
@@ -119,20 +119,20 @@
 			newwork=0;
 
 			Barrier.wait();
-      
+			
 			if(execswf)
-			  ex-&gt;ExecServerFun();
+				ex-&gt;ExecServerFun();
 
 			typename std::list&lt;U&gt;::iterator it;
 			if(ex-&gt;workeriter)
 				it=ex-&gt;iter-&gt;begin();
 			int pos=0;
-//      int nproc=0;
+//			int nproc=0;
 			int updsrv=0;
 			if(gmlThreadCount&gt;1) {
 				while(ClientsReady&lt;=gmlThreadCount+1) {
 					if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
-  					gmlUpdateServers();
+						gmlUpdateServers();
 					BOOL_ processed=FALSE;
 					for(int i=1; i&lt;gmlThreadCount; ++i) {
 						gmlQueue *qd=&amp;gmlQueues[i];
@@ -171,7 +171,7 @@
 
 	void WorkInit() {
 		if(!inited) {
-  		gmlInit();
+			gmlInit();
 			for(int i=1; i&lt;gmlThreadCount; ++i)
 				threads[i]=new boost::thread(boost::bind&lt;void, gmlClientServer, gmlClientServer*&gt;(&amp;gmlClientServer::gmlClient, this));
 			inited=TRUE;
@@ -183,7 +183,7 @@
 			NewWork(wrk,wrka,wrkit,cls,mt,sm,it,nu,l1,l2,sw,swf);
 			return;
 		}
-  	GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState;
+		GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState;
 		new (ex) GML_TYPENAME gmlExecState&lt;R,A,U&gt;(wrk,wrka,wrkit,cls,mt,sm,nu,it,l1,l2,sw,swf);
 		if(!inited)
 			WorkInit();
@@ -194,7 +194,7 @@
 		gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];
 		qd-&gt;ReleaseWrite();
 
-  	GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
+		GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
 		new (ex+1) GML_TYPENAME gmlExecState&lt;R,A,U&gt;(wrk,wrka,wrkit,cls,mt,sm,nu,it,l1,l2,sw,swf);
 		newwork=TRUE;
 
@@ -213,10 +213,10 @@
 		Barrier.wait();
 
 		GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
-    
+		
 		int thread=gmlThreadNumber;
 		if(thread&gt;=ex-&gt;maxthreads) {
-  		++ClientsReady;	
+			++ClientsReady;	
 			return;
 		}
 
@@ -257,7 +257,7 @@
 		gmlThreadNumber=++threadcnt;
 		streflop_init&lt;streflop::Simple&gt;();
 		while(1) {
-      gmlClientSub();
+			gmlClientSub();
 		}
 	}
 };


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001097.html">[Taspring-linux-commit] r6327 - in trunk: . installer	installer/freedesktop installer/freedesktop/applications	installer/freedesktop/mime installer/freedesktop/pixmaps rts
</A></li>
	<LI>Next message: <A HREF="001099.html">[Taspring-linux-commit] r6329 - trunk/rts/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1098">[ date ]</a>
              <a href="thread.html#1098">[ thread ]</a>
              <a href="subject.html#1098">[ subject ]</a>
              <a href="author.html#1098">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
