<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6858 - in trunk/rts: ExternalAI Game	Game/UI Lua Map Map/SMF Rendering/Env Rendering/UnitModels	Sim/MoveTypes Sim/Path Sim/Units Sim/Units/CommandAI System	System/FileSystem System/Platform System/Script build/scons	build/vstudio8 lib/gml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6858%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%0A%09Game/UI%20Lua%20Map%20Map/SMF%20Rendering/Env%20Rendering/UnitModels%0A%09Sim/MoveTypes%20Sim/Path%20Sim/Units%20Sim/Units/CommandAI%20System%0A%09System/FileSystem%20System/Platform%20System/Script%20build/scons%0A%09build/vstudio8%20lib/gml&In-Reply-To=%3C20081023200202.D7CB84743%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001626.html">
   <LINK REL="Next"  HREF="001628.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6858 - in trunk/rts: ExternalAI Game	Game/UI Lua Map Map/SMF Rendering/Env Rendering/UnitModels	Sim/MoveTypes Sim/Path Sim/Units Sim/Units/CommandAI System	System/FileSystem System/Platform System/Script build/scons	build/vstudio8 lib/gml</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6858%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%0A%09Game/UI%20Lua%20Map%20Map/SMF%20Rendering/Env%20Rendering/UnitModels%0A%09Sim/MoveTypes%20Sim/Path%20Sim/Units%20Sim/Units/CommandAI%20System%0A%09System/FileSystem%20System/Platform%20System/Script%20build/scons%0A%09build/vstudio8%20lib/gml&In-Reply-To=%3C20081023200202.D7CB84743%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6858 - in trunk/rts: ExternalAI Game	Game/UI Lua Map Map/SMF Rendering/Env Rendering/UnitModels	Sim/MoveTypes Sim/Path Sim/Units Sim/Units/CommandAI System	System/FileSystem System/Platform System/Script build/scons	build/vstudio8 lib/gml">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Oct 23 22:02:02 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001626.html">[Taspring-linux-commit] r6857 - in Lobby/springie: ModInfoBuilder	Springie Springie/UnitSync Springie/autohost Springie/client	Springie/doc Springie/spring
</A></li>
        <LI>Next message: <A HREF="001628.html">[Taspring-linux-commit] r6859 - in Lobby/TASClient: . Python/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1627">[ date ]</a>
              <a href="thread.html#1627">[ thread ]</a>
              <a href="subject.html#1627">[ subject ]</a>
              <a href="author.html#1627">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-10-23 22:02:01 +0200 (Thu, 23 Oct 2008)
New Revision: 6858

Modified:
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/ExternalAI/GroupHandler.cpp
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/Game.h
   trunk/rts/Game/GlobalSynced.cpp
   trunk/rts/Game/SelectedUnits.cpp
   trunk/rts/Game/UI/GuiHandler.cpp
   trunk/rts/Game/UI/InputReceiver.cpp
   trunk/rts/Game/UI/MiniMap.cpp
   trunk/rts/Game/UI/MouseHandler.cpp
   trunk/rts/Game/UI/SelectionKeyHandler.cpp
   trunk/rts/Game/WaitCommandsAI.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.cpp
   trunk/rts/Lua/LuaUnsyncedRead.cpp
   trunk/rts/Map/BaseGroundDrawer.cpp
   trunk/rts/Map/BaseGroundDrawer.h
   trunk/rts/Map/SMF/BFGroundDrawer.h
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Sim/MoveTypes/AirMoveType.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Units/CommandAI/CommandQueue.h
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitHandler.cpp
   trunk/rts/Sim/Units/UnitHandler.h
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/Sim/Units/UnitTracker.cpp
   trunk/rts/System/FileSystem/FileHandler.cpp
   trunk/rts/System/Platform/ConfigHandler.cpp
   trunk/rts/System/Script/LuaFunctions.cpp
   trunk/rts/System/SpringApp.cpp
   trunk/rts/System/SpringApp.h
   trunk/rts/build/scons/rts.py
   trunk/rts/build/vstudio8/rts.vcproj
   trunk/rts/lib/gml/gml.cpp
   trunk/rts/lib/gml/gml.h
   trunk/rts/lib/gml/gmlcls.h
   trunk/rts/lib/gml/gmlfun.h
   trunk/rts/lib/gml/gmlsrv.h
Log:
Further work on parallel Sim/Draw

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -988,7 +988,7 @@
 	CUnitDrawer::TempDrawUnit tdu;
 	tdu.unitdef=unitDefHandler-&gt;GetUnitByName(unitName);
 	if(!tdu.unitdef){
-		logOutput.Print(&quot;Uknown unit in CAICallback::DrawUnit %s&quot;,unitName);
+		logOutput.Print(&quot;Unknown unit in CAICallback::DrawUnit %s&quot;,unitName);
 		return;
 	}
 	tdu.pos=pos;
@@ -1528,6 +1528,7 @@
 	verify();
 	int a = 0;
 
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnit
 	// check if the allyteam of the player running
 	// the AI lib matches the AI's actual allyteam
 	if (gu-&gt;myAllyTeam == gs-&gt;AllyTeam(team)) {

Modified: trunk/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- trunk/rts/ExternalAI/GroupHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/ExternalAI/GroupHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -87,7 +87,7 @@
 
 void CGroupHandler::DrawCommands()
 {
-	GML_STDMUTEX_LOCK(cai);
+//	GML_STDMUTEX_LOCK(cai); // not needed, protected via SelectedUnits::DrawCommands
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)!=0)
 			(*ai)-&gt;DrawCommands();
@@ -153,6 +153,9 @@
 
 void CGroupHandler::GroupCommand(int num)
 {
+	GML_RECMUTEX_LOCK(sel); // GroupCommand
+	GML_STDMUTEX_LOCK(group); // GroupCommand
+
 	if (keys[SDLK_LCTRL]) {
 		if (!keys[SDLK_LSHIFT]) {
 			groups[num]-&gt;ClearUnits();
@@ -199,6 +202,9 @@
 
 void CGroupHandler::GroupCommand(int num, const std::string&amp; cmd)
 {
+	GML_RECMUTEX_LOCK(sel); // GroupCommand
+	GML_STDMUTEX_LOCK(group); // GroupCommand
+
 	if ((cmd == &quot;set&quot;) || (cmd == &quot;add&quot;)) {
 		if (cmd == &quot;set&quot;) {
 			groups[num]-&gt;ClearUnits();
@@ -263,6 +269,8 @@
 
 CGroup* CGroupHandler::CreateNewGroup(AIKey aiKey)
 {
+	GML_STDMUTEX_LOCK(group); // GroupCommand
+
 	if(freeGroups.empty()){
 		CGroup* group=SAFE_NEW CGroup(aiKey,firstUnusedGroup++,this);
 		groups.push_back(group);
@@ -281,6 +289,9 @@
 
 void CGroupHandler::RemoveGroup(CGroup* group)
 {
+	GML_RECMUTEX_LOCK(sel); // RemoveGroup
+	GML_STDMUTEX_LOCK(group); // RemoveGroup
+
 	if(group-&gt;id&lt;10){
 		logOutput.Print(&quot;Warning trying to remove hotkey group %i&quot;,group-&gt;id);
 		return;
@@ -294,6 +305,8 @@
 
 std::map&lt;AIKey, std::string&gt; CGroupHandler::GetSuitedAis(const CUnitSet&amp; units)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSuitedAis
+
 	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
 	ISUNITSUITED IsUnitSuited;
 

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/Game.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -160,7 +160,7 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 #endif
 
 extern Uint8 *keys;
@@ -250,6 +250,8 @@
 	thisFps = 0;
 	totalGameTime = 0;
 
+	lastSimFrame=-1;
+
 	creatingVideo = false;
 
 	playing  = false;
@@ -840,7 +842,8 @@
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
-		if ((*ri) &amp;&amp; (*ri)-&gt;KeyPressed(k, isRepeat)) {
+		CInputReceiver* recv=*ri;
+		if (recv &amp;&amp; recv-&gt;KeyPressed(k, isRepeat)) {
 			return 0;
 		}
 	}
@@ -869,7 +872,8 @@
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
-		if ((*ri) &amp;&amp; (*ri)-&gt;KeyReleased(k)) {
+		CInputReceiver* recv=*ri;
+		if (recv &amp;&amp; recv-&gt;KeyReleased(k)) {
 			return 0;
 		}
 	}
@@ -1033,6 +1037,8 @@
 		mouse-&gt;MousePress (mouse-&gt;lastx, mouse-&gt;lasty, 5);
 	}
 	else if (cmd == &quot;viewselection&quot;) {
+		GML_RECMUTEX_LOCK(sel); // ActionPressed
+
 		const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 		if (!selUnits.empty()) {
 			float3 pos(0.0f, 0.0f, 0.0f);
@@ -1321,6 +1327,60 @@
 			sky-&gt;dynamicSky = !!atoi(action.extra.c_str());
 		}
 	}
+#ifdef USE_GML
+	else if (cmd == &quot;multithreaddrawground&quot;) {
+		if (action.extra.empty()) {
+			gd-&gt;multiThreadDrawGround = !gd-&gt;multiThreadDrawGround;
+		} else {
+			gd-&gt;multiThreadDrawGround = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithreaddrawgroundshadow&quot;) {
+		if (action.extra.empty()) {
+			gd-&gt;multiThreadDrawGroundShadow = !gd-&gt;multiThreadDrawGroundShadow;
+		} else {
+			gd-&gt;multiThreadDrawGroundShadow = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithreaddrawunit&quot;) {
+		if (action.extra.empty()) {
+			unitDrawer-&gt;multiThreadDrawUnit = !unitDrawer-&gt;multiThreadDrawUnit;
+		} else {
+			unitDrawer-&gt;multiThreadDrawUnit = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithreaddrawunitshadow&quot;) {
+		if (action.extra.empty()) {
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !unitDrawer-&gt;multiThreadDrawUnitShadow;
+		} else {
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithread&quot;) {
+		if (action.extra.empty()) {
+			int mtenabled=gd-&gt;multiThreadDrawGround + unitDrawer-&gt;multiThreadDrawUnit + unitDrawer-&gt;multiThreadDrawUnitShadow &gt; 1;
+			gd-&gt;multiThreadDrawGround = !mtenabled;
+			unitDrawer-&gt;multiThreadDrawUnit = !mtenabled;
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !mtenabled;
+		} else {
+			gd-&gt;multiThreadDrawGround = !!atoi(action.extra.c_str());
+			unitDrawer-&gt;multiThreadDrawUnit = !!atoi(action.extra.c_str());
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !!atoi(action.extra.c_str());
+		}
+	}
+#endif
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	else if (cmd == &quot;multithreadsim&quot;) {
+		extern volatile int multiThreadSim;
+		extern volatile int startsim;
+		if (action.extra.empty()) {
+			multiThreadSim = !multiThreadSim;
+		} else {
+			multiThreadSim = !!atoi(action.extra.c_str());
+		}
+		startsim=1;
+	}
+#endif
 	else if (!isRepeat &amp;&amp; (cmd == &quot;gameinfo&quot;)) {
 		if (!CGameInfo::IsActive()) {
 			CGameInfo::Enable();
@@ -2399,8 +2459,6 @@
 {
 	good_fpu_control_registers(&quot;CGame::Update&quot;);
 
-	mouse-&gt;EmptyMsgQueUpdate();
-
 	unsigned timeNow = SDL_GetTicks();
 
 	const unsigned difTime = (timeNow - lastModGameTimeMeasure);
@@ -2439,12 +2497,10 @@
 		tracefile.DeleteInterval();
 		tracefile.NewInterval();
 #endif
-		CInputReceiver::CollectGarbage();
 	}
 
-	if (!skipping) {
-		UpdateUI();
-	}
+	if (!skipping)
+		UpdateUI(false);
 
 	net-&gt;Update();
 
@@ -2644,6 +2700,10 @@
 bool CGame::Draw() {
 #endif
 
+	mouse-&gt;EmptyMsgQueUpdate();
+	if(!skipping)
+		UpdateUI(true);
+
 	thisFps++;
 
 	ASSERT_UNSYNCED_MODE;
@@ -2750,6 +2810,11 @@
 
 	{
 		SCOPED_TIMER(&quot;Water&quot;);
+		if(lastSimFrame!=gs-&gt;frameNum) {
+			CInputReceiver::CollectGarbage();
+			water-&gt;Update();
+			lastSimFrame=gs-&gt;frameNum;
+		}
 		water-&gt;UpdateWater(this);
 	}
 
@@ -3152,7 +3217,6 @@
 			}
 		}
 #endif
-		water-&gt;Update();
 	}
 
 	ENTER_SYNCED;
@@ -4027,13 +4091,17 @@
 	return;
 }
 
+#ifdef DIRECT_CONTROL_ALLOWED
+float3 lastDCpos;
+float3 *plastDCpos=NULL;
+#endif
 
-void CGame::UpdateUI()
+void CGame::UpdateUI(bool cam)
 {
 	ASSERT_UNSYNCED_MODE;
 	//move camera if arrow keys pressed
 #ifdef DIRECT_CONTROL_ALLOWED
-	if (gu-&gt;directControl) {
+	if (gu-&gt;directControl &amp;&amp; !cam) {
 		CUnit* owner = gu-&gt;directControl;
 
 		std::vector&lt;int&gt; args;
@@ -4041,12 +4109,22 @@
 		owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary/*/COBFN_QueryPrimary+weaponNum/ **/,args);
 		float3 relPos = owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
 		float3 pos = owner-&gt;pos + owner-&gt;frontdir * relPos.z
-		                        + owner-&gt;updir    * relPos.y
-		                        + owner-&gt;rightdir * relPos.x;
+			+ owner-&gt;updir    * relPos.y
+			+ owner-&gt;rightdir * relPos.x;
 		pos += UpVector * 7;
-
-		camHandler-&gt;GetCurrentController().SetPos(pos);
-	} else
+		//camHandler-&gt;GetCurrentController().SetPos(pos); // in case of multithreading, avoid setting the cam from sim thread
+		GML_STDMUTEX_LOCK(pos); // UpdateUI
+		lastDCpos=pos;
+		plastDCpos=&lastDCpos;
+	}
+	if (plastDCpos &amp;&amp; cam) {
+		GML_STDMUTEX_LOCK(pos); // UpdateUI
+		if(plastDCpos) {
+			camHandler-&gt;GetCurrentController().SetPos(*plastDCpos);
+			plastDCpos=NULL;
+		}
+	}
+	if (!gu-&gt;directControl)
 #endif
 	{
 		float cameraSpeed=1;
@@ -4076,73 +4154,82 @@
 			disableTracker = true;
 		}
 
-		if (disableTracker &amp;&amp; camHandler-&gt;GetCurrentController().DisableTrackingByKey()) {
+		if (!cam &amp;&amp; disableTracker &amp;&amp; camHandler-&gt;GetCurrentController().DisableTrackingByKey()) {
 			unitTracker.Disable();
 		}
-		movement.z = cameraSpeed;
-		camHandler-&gt;GetCurrentController().KeyMove(movement);
-
+		if(cam) {
+			movement.z = cameraSpeed;
+			camHandler-&gt;GetCurrentController().KeyMove(movement);
+		}
 		movement=float3(0,0,0);
 
 		if (( fullscreen &amp;&amp; fullscreenEdgeMove) ||
 		    (!fullscreen &amp;&amp; windowedEdgeMove)) {
 			int screenW = gu-&gt;dualScreenMode ? gu-&gt;viewSizeX*2 : gu-&gt;viewSizeX;
+			disableTracker = false;
 			if (mouse-&gt;lasty &lt; 2){
 				movement.y+=gu-&gt;lastFrameTime;
-				unitTracker.Disable();
+				disableTracker = true;
 			}
 			if (mouse-&gt;lasty &gt; (gu-&gt;viewSizeY - 2)){
 				movement.y-=gu-&gt;lastFrameTime;
-				unitTracker.Disable();
+				disableTracker = true;
 			}
 			if (mouse-&gt;lastx &gt; (screenW - 2)){
 				movement.x+=gu-&gt;lastFrameTime;
-				unitTracker.Disable();
+				disableTracker = true;
 			}
 			if (mouse-&gt;lastx &lt; 2){
 				movement.x-=gu-&gt;lastFrameTime;
+				disableTracker = true;
+			}
+			if (!cam &amp;&amp; disableTracker) {
 				unitTracker.Disable();
 			}
 		}
-		movement.z=cameraSpeed;
-		camHandler-&gt;GetCurrentController().ScreenEdgeMove(movement);
-
-		if(camMove[4])
-			camHandler-&gt;GetCurrentController().MouseWheelMove(gu-&gt;lastFrameTime*200*cameraSpeed);
-		if(camMove[5])
-			camHandler-&gt;GetCurrentController().MouseWheelMove(-gu-&gt;lastFrameTime*200*cameraSpeed);
+		if(cam) {
+			movement.z=cameraSpeed;
+			camHandler-&gt;GetCurrentController().ScreenEdgeMove(movement);
+			if(camMove[4])
+				camHandler-&gt;GetCurrentController().MouseWheelMove(gu-&gt;lastFrameTime*200*cameraSpeed);
+			if(camMove[5])
+				camHandler-&gt;GetCurrentController().MouseWheelMove(-gu-&gt;lastFrameTime*200*cameraSpeed);
+		}
 	}
 
-	camHandler-&gt;GetCurrentController().Update();
+	if(cam)
+		camHandler-&gt;GetCurrentController().Update();
 
-	if (chatting &amp;&amp; !userWriting) {
-		consoleHistory-&gt;AddLine(userInput);
-		string msg = userInput;
-		string pfx = &quot;&quot;;
-		if ((userInput.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (userInput[1] == ':')) {
-			pfx = userInput.substr(0, 2);
-			msg = userInput.substr(2);
+	if(!cam) {
+		if (chatting &amp;&amp; !userWriting) {
+			consoleHistory-&gt;AddLine(userInput);
+			string msg = userInput;
+			string pfx = &quot;&quot;;
+			if ((userInput.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (userInput[1] == ':')) {
+				pfx = userInput.substr(0, 2);
+				msg = userInput.substr(2);
+			}
+			if ((msg[0] == '/') &amp;&amp; (msg[1] == '/')) {
+				msg = msg.substr(1);
+			}
+			userInput = pfx + msg;
+			SendNetChat(userInput);
+			chatting=false;
+			userInput=&quot;&quot;;
+			writingPos = 0;
 		}
-		if ((msg[0] == '/') &amp;&amp; (msg[1] == '/')) {
-			msg = msg.substr(1);
-		}
-		userInput = pfx + msg;
-		SendNetChat(userInput);
-		chatting=false;
-		userInput=&quot;&quot;;
-		writingPos = 0;
-	}
 
-	if (inMapDrawer-&gt;wantLabel &amp;&amp; !userWriting) {
-		if (userInput.size() &gt; 200) {	//avoid troubles with to long lines
-			userInput = userInput.substr(0, 200);
-			writingPos = (int)userInput.length();
+		if (inMapDrawer-&gt;wantLabel &amp;&amp; !userWriting) {
+			if (userInput.size() &gt; 200) {	//avoid troubles with to long lines
+				userInput = userInput.substr(0, 200);
+				writingPos = (int)userInput.length();
+			}
+			inMapDrawer-&gt;SendPoint(inMapDrawer-&gt;waitingPoint, userInput);
+			inMapDrawer-&gt;wantLabel = false;
+			userInput = &quot;&quot;;
+			writingPos = 0;
+			ignoreChar = 0;
 		}
-		inMapDrawer-&gt;SendPoint(inMapDrawer-&gt;waitingPoint, userInput);
-		inMapDrawer-&gt;wantLabel = false;
-		userInput = &quot;&quot;;
-		writingPos = 0;
-		ignoreChar = 0;
 	}
 }
 
@@ -4694,6 +4781,8 @@
 	static set&lt;int&gt; unitIDs;
 	static int lastID = -1;
 
+	GML_RECMUTEX_LOCK(sel); // SelectCycle
+
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 
 	if (command == &quot;restore&quot;) {

Modified: trunk/rts/Game/Game.h
===================================================================
--- trunk/rts/Game/Game.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/Game.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -71,6 +71,8 @@
 	unsigned int fps;
 	unsigned int thisFps;
 
+	int lastSimFrame;
+
 	time_t fpstimer, starttime;
 	unsigned lastUpdate;
 	unsigned lastMoveUpdate;
@@ -181,7 +183,7 @@
 
 private:
 	void ClientReadNet();
-	void UpdateUI();
+	void UpdateUI(bool cam);
 	bool DrawWorld();
 	
 	void SimFrame();

Modified: trunk/rts/Game/GlobalSynced.cpp
===================================================================
--- trunk/rts/Game/GlobalSynced.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/GlobalSynced.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -1,3 +1,4 @@
+#include &quot;StdAfx.h&quot;
 #include &quot;GlobalSynced.h&quot;
 
 #include &lt;assert.h&gt;

Modified: trunk/rts/Game/SelectedUnits.cpp
===================================================================
--- trunk/rts/Game/SelectedUnits.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/SelectedUnits.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -78,6 +78,9 @@
 
 CSelectedUnits::AvailableCommandsStruct CSelectedUnits::GetAvailableCommands()
 {
+	GML_RECMUTEX_LOCK(sel); // GetAvailableCommands
+	GML_STDMUTEX_LOCK(group); // GetAvailableCommands
+
 	possibleCommandsChanged = false;
 
 	if (selectedGroup != -1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
@@ -248,6 +251,9 @@
 
 void CSelectedUnits::GiveCommand(Command c, bool fromUser)
 {
+	GML_RECMUTEX_LOCK(sel); // GiveCommand
+	GML_STDMUTEX_LOCK(group); // GiveCommand
+
 //	logOutput.Print(&quot;Command given %i&quot;,c.id);
 	if ((gu-&gt;spectating &amp;&amp; !gs-&gt;godMode) || selectedUnits.empty()) {
 		return;
@@ -360,7 +366,8 @@
 {
 	// if unit is being transported by eg. Hulk or Atlas
 	// then we should not be able to select it
-	if (unit-&gt;transporter != NULL &amp;&amp; !unit-&gt;transporter-&gt;unitDef-&gt;isFirePlatform) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (trans != NULL &amp;&amp; !trans-&gt;unitDef-&gt;isFirePlatform) {
 		return;
 	}
 
@@ -423,7 +430,7 @@
 void CSelectedUnits::SelectGroup(int num)
 {
 	GML_RECMUTEX_LOCK(sel); // SelectGroup
-//	GML_STDMUTEX_LOCK(group); // SelectGroup. not needed? only reading group
+	GML_STDMUTEX_LOCK(group); // SelectGroup. not needed? only reading group
 
 	ClearSelected();
 	selectedGroup=num;
@@ -483,6 +490,7 @@
 	// highlight queued build sites if we are about to build something
 	// (or old-style, whenever the shift key is being held down)
 	if (cmdColors.buildBox[3] &gt; 0.0f) {
+		//GML_RECMUTEX_LOCK(gui); // Draw. Not needed because of draw thread.
 		if (!selectedUnits.empty() &amp;&amp;
 				((cmdColors.BuildBoxesOnShift() &amp;&amp; keys[SDLK_LSHIFT]) ||
 				 ((guihandler-&gt;inCommand &gt;= 0) &amp;&amp;
@@ -683,6 +691,8 @@
 
 void CSelectedUnits::PossibleCommandChange(CUnit* sender)
 {
+	GML_RECMUTEX_LOCK(sel); // PossibleCommandChange
+
 	if (sender == NULL || selectedUnits.find(sender) != selectedUnits.end())
 		possibleCommandsChanged = true;
 }
@@ -742,6 +752,7 @@
 {
 	GML_RECMUTEX_LOCK(sel); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
 	GML_STDMUTEX_LOCK(group); // GetTooltip
+
 	std::string s;
 	if ((selectedGroup != -1) &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
 		s = &quot;Group selected&quot;;
@@ -819,6 +830,7 @@
 {
 	GML_RECMUTEX_LOCK(sel); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc --&gt; SetCommandPage
 	GML_STDMUTEX_LOCK(group); // SetCommandPage
+
 	if(selectedGroup!=-1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai){
 		grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;lastCommandPage=page;
 	}
@@ -832,6 +844,8 @@
 
 void CSelectedUnits::SendSelection(void)
 {
+	GML_RECMUTEX_LOCK(sel); // SendSelection
+
 	// first, convert CUnit* to unit IDs.
 	std::vector&lt;short&gt; selectedUnitIDs(selectedUnits.size());
 	std::vector&lt;short&gt;::iterator i = selectedUnitIDs.begin();

Modified: trunk/rts/Game/UI/GuiHandler.cpp
===================================================================
--- trunk/rts/Game/UI/GuiHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/UI/GuiHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -451,7 +451,7 @@
 
 int CGuiHandler::FindInCommandPage()
 {
-	GML_RECMUTEX_LOCK(gui); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; FindInCommandPage
+//	GML_RECMUTEX_LOCK(gui); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; FindInCommandPage. Not needed, Draw thread.
 
 	if ((inCommand &lt; 0) || (inCommand &gt;= commands.size())) {
 		return -1;
@@ -469,7 +469,7 @@
 void CGuiHandler::RevertToCmdDesc(const CommandDescription&amp; cmdDesc,
                                   bool defaultCommand, bool samePage)
 {
-	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc
+//	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc. Not needed, protected via other func.
 
 	for (int a = 0; a &lt; commands.size(); ++a) {
 		if (commands[a].id == cmdDesc.id) {
@@ -966,6 +966,7 @@
 
 void CGuiHandler::SetCursorIcon() const
 {
+//	GML_RECMUTEX_LOCK(gui); // SetCursorIcon. Not needed, protected via Update
 	string newCursor = &quot;cursornormal&quot;;
 	mouse-&gt;cursorScale = 1.0f;
 
@@ -1081,6 +1082,7 @@
 
 void CGuiHandler::MouseRelease(int x, int y, int button, float3&amp; camerapos, float3&amp; mousedir)
 {
+//	GML_RECMUTEX_LOCK(gui); // not needed, draw thread + read only
 	int iconCmd = -1;
 
 	if (activeMousePress) {
@@ -1398,6 +1400,8 @@
 
 void CGuiHandler::RunCustomCommands(const std::vector&lt;std::string&gt;&amp; cmds, bool rmb)
 {
+	GML_RECMUTEX_LOCK(gui); // LuaUnsyncedCtrl::SendCommands --&gt; RunCustomCommands
+
 	static int depth = 0;
 	if (depth &gt; 8) {
 		return; // recursion protection
@@ -1513,6 +1517,7 @@
 		return -1;
 	}
 
+	GML_RECMUTEX_LOCK(sel); // anti deadlock
 	GML_RECMUTEX_LOCK(quad); // GetDefaultCommand
 	CUnit* unit = NULL;
 //	GML_RECMUTEX_LOCK(unit); // GetDefaultCommand
@@ -1560,6 +1565,7 @@
 
 bool CGuiHandler::ProcessLocalActions(const Action&amp; action)
 {
+//	GML_RECMUTEX_LOCK(gui); // not needed, protected via other functions
 	// do not process these actions if the control panel is not visible
 	if (iconsCount &lt;= 0) {
 		return false;
@@ -1817,7 +1823,7 @@
 bool CGuiHandler::SetActiveCommand(const Action&amp; action,
                                    const CKeySet&amp; ks, int actionIndex)
 {
-	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand
+	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand, called by LuaUnsyncedCtrl
 
 	if (ProcessLocalActions(action)) {
 		return true;
@@ -2092,7 +2098,7 @@
 
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
-	GML_RECMUTEX_LOCK(gui); // GetTooltip
+	GML_RECMUTEX_LOCK(gui); // LuaUnsyncedRead::GetCurrentTooltip --&gt; CMouseHandler::GetCurrentTooltip --&gt; GetTooltip
 
 	std::string s;
 
@@ -2119,11 +2125,13 @@
 }
 
 // CALLINFO:
-// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
-// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; CMiniMap::gettooltip --&gt; GetBuildTooltip
+// luaunsyncedread::getcurrenttooltip --&gt; mousehandler::getcurrenttooltip
+// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
+// mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+// mousehandler::getcurrenttooltip --&gt; CMiniMap::gettooltip --&gt; GetBuildTooltip
 std::string CGuiHandler::GetBuildTooltip() const
 {
-	GML_RECMUTEX_LOCK(gui); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+	GML_RECMUTEX_LOCK(gui); // luaunsyncedread::getcurrenttooltip --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
 
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size()) &amp;&amp;
 	    (commands[inCommand].type == CMDTYPE_ICON_BUILDING)) {
@@ -2133,7 +2141,7 @@
 }
 
 
-Command CGuiHandler::GetOrderPreview(void)
+Command CGuiHandler::GetOrderPreview(void) // Called from GroupAICallback
 {
 	return GetCommand(mouse-&gt;lastx, mouse-&gt;lasty, -1, true);
 }
@@ -2426,9 +2434,10 @@
 
 
 static bool WouldCancelAnyQueued(const BuildInfo&amp; b) {
+	GML_RECMUTEX_LOCK(sel); //drawmapstuff -&gt; getbuildpos --&gt; fillrowofbuildpos -&gt; wouldcancelanyqueued
+
 	Command c;
 	b.FillCmd(c);
-	GML_RECMUTEX_LOCK(sel); //drawmapstuff -&gt; getbuildpos --&gt; fillrowofbuildpos -&gt; wouldcancelanyqueued
 	CUnitSet::iterator ui = selectedUnits.selectedUnits.begin();
 	for(;ui != selectedUnits.selectedUnits.end(); ++ui){
 		if((*ui)-&gt;commandAI-&gt;WillCancelQueued(c))
@@ -2462,7 +2471,9 @@
 	if(GetQueueKeystate() &amp;&amp; keys[SDLK_LCTRL])
 	{
 		CUnit* unit=0;
-		GML_RECMUTEX_LOCK(unit); // GetBuildCommand accesses activeunits. drawmapstuff -&gt; getbuildpos
+
+		GML_RECMUTEX_LOCK(quad); //unit); // GetBuildCommand accesses activeunits. drawmapstuff -&gt; getbuildpos
+
 		helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 		if(unit){
 			other.def = unit-&gt;unitDef;
@@ -2562,7 +2573,7 @@
 
 void CGuiHandler::Draw()
 {
-	GML_RECMUTEX_LOCK(gui); // accesses iconsCount. Draw
+//	GML_RECMUTEX_LOCK(gui); // accesses iconsCount. Draw
 //	GML_RECMUTEX_LOCK(quad); // update accesses setcursoricon-&gt;getdefaultcommand-&gt;guitraceray which accesses the quadfield
 
 	Update();
@@ -3232,7 +3243,8 @@
 
 void CGuiHandler::DrawNumberInput() // Only called by drawbuttons
 {
-	GML_RECMUTEX_LOCK(gui); // DrawNumberInput
+//	GML_RECMUTEX_LOCK(gui); // DrawNumberInput
+
 	// draw the value for CMDTYPE_NUMBER commands
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		const CommandDescription&amp; cd = commands[inCommand];
@@ -3456,7 +3468,7 @@
 
 void CGuiHandler::DrawMapStuff(int onMinimap)
 {
-	GML_RECMUTEX_LOCK(gui); // DrawMapStuff
+//	GML_RECMUTEX_LOCK(gui); // DrawMapStuff
 
 	if (!onMinimap) {
 		glEnable(GL_DEPTH_TEST);
@@ -3804,7 +3816,9 @@
 
 					std::vector&lt;Command&gt; cv;
 					if (GetQueueKeystate()) {
+
 						GML_RECMUTEX_LOCK(sel); // DrawMapStuff
+
 						Command c;
 						bpi-&gt;FillCmd(c);
 						std::vector&lt;Command&gt; temp;
@@ -3839,7 +3853,9 @@
 	int defcmd = GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty, camerapos, mousedir);
 	if ((inCommand&gt;=0 &amp;&amp; inCommand&lt;commands.size() &amp;&amp; commands[inCommand].id==CMD_ATTACK) ||
 	    (inCommand==-1 &amp;&amp; defcmd&gt;0 &amp;&amp; commands[defcmd].id==CMD_ATTACK)){
+
 		GML_RECMUTEX_LOCK(sel); // DrawMapStuff
+
 		for(CUnitSet::iterator si=selectedUnits.selectedUnits.begin(); si!=selectedUnits.selectedUnits.end(); ++si) {
 			CUnit* unit = *si;
 			if (unit == pointedAt) {
@@ -3923,12 +3939,14 @@
 void CGuiHandler::DrawCentroidCursor()
 {
 	GML_RECMUTEX_LOCK(sel); // CMouseHandler::DrawCursor --&gt; DrawCentroidCursor
+
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 	if (selUnits.size() &lt; 2) {
 		return;
 	}
 
-	GML_RECMUTEX_LOCK(gui); // DrawCentroidCursor
+//	GML_RECMUTEX_LOCK(gui); // DrawCentroidCursor. Not needed, Draw thread.
+
 	int cmd = -1;
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		cmd = commands[inCommand].id;

Modified: trunk/rts/Game/UI/InputReceiver.cpp
===================================================================
--- trunk/rts/Game/UI/InputReceiver.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/UI/InputReceiver.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -62,8 +62,9 @@
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for(ri=inputReceivers.begin();ri!=inputReceivers.end();++ri){
-		if((*ri) &amp;&amp; (*ri)-&gt;IsAbove(x,y))
-			return *ri;
+		CInputReceiver* recv= *ri;
+		if(recv &amp;&amp; recv-&gt;IsAbove(x,y))
+			return recv;
 	}
 	return 0;
 }

Modified: trunk/rts/Game/UI/MiniMap.cpp
===================================================================
--- trunk/rts/Game/UI/MiniMap.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/UI/MiniMap.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -662,6 +662,8 @@
 
 void CMiniMap::SelectUnits(int x, int y) const
 {
+	GML_RECMUTEX_LOCK(sel); // SelectUnits
+
 	if (!keys[SDLK_LSHIFT] &amp;&amp; !keys[SDLK_LCTRL]) {
 		selectedUnits.ClearSelected();
 	}
@@ -913,7 +915,7 @@
 		return buildTip;
 	}
 
-	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
+	GML_RECMUTEX_LOCK(quad); //unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
 
 	const CUnit* unit = GetSelectUnit(GetMapPosition(x, y));
 	if (unit) {
@@ -1044,7 +1046,7 @@
 	GML_RECMUTEX_LOCK(unit); // DrawForReal
 	// draw the units
 	std::list&lt;CUnit*&gt;::iterator ui;
-	for (ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ui++) {
+	for (ui = uh-&gt;renderUnits.begin(); ui != uh-&gt;renderUnits.end(); ui++) {
 		DrawUnit(*ui);
 	}
 //	GML_RECMUTEX_LOCK(quad);  // getselectunit accesses quadfield

Modified: trunk/rts/Game/UI/MouseHandler.cpp
===================================================================
--- trunk/rts/Game/UI/MouseHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/UI/MouseHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -287,6 +287,8 @@
 
 void CMouseHandler::MouseRelease(int x, int y, int button)
 {
+	GML_RECMUTEX_LOCK(sel); // MouseRelease
+
 	if (button &gt; NUM_BUTTONS)
 		return;
 
@@ -571,7 +573,9 @@
 	}
 }
 
-
+// CALLINFO:
+// LuaUnsyncedRead::GetCurrentTooltip
+// CTooltipConsole::Draw --&gt; CMouseHandler::GetCurrentTooltip
 std::string CMouseHandler::GetCurrentTooltip(void)
 {
 	std::string s;
@@ -591,7 +595,9 @@
 		return buildTip;
 	}
 
+	GML_RECMUTEX_LOCK(sel); // anti deadlock
 	GML_RECMUTEX_LOCK(quad); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
+
 	const float range = (gu-&gt;viewRange * 1.4f);
 	CUnit* unit = NULL;
 //	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip

Modified: trunk/rts/Game/UI/SelectionKeyHandler.cpp
===================================================================
--- trunk/rts/Game/UI/SelectionKeyHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/UI/SelectionKeyHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -140,6 +140,8 @@
 
 void CSelectionKeyHandler::DoSelection(std::string selectString)
 {
+	GML_RECMUTEX_LOCK(sel); // DoSelection
+
 	std::list&lt;CUnit*&gt; selection;
 
 //	guicontroller-&gt;AddText(selectString.c_str());

Modified: trunk/rts/Game/WaitCommandsAI.cpp
===================================================================
--- trunk/rts/Game/WaitCommandsAI.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Game/WaitCommandsAI.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -159,6 +159,8 @@
 
 void CWaitCommandsAI::AddTimeWait(const Command&amp; cmd)
 {
+	GML_RECMUTEX_LOCK(sel); // AddTimeWait
+
 	// save the current selection
 	const CUnitSet tmpSet = selectedUnits.selectedUnits;
 	CUnitSet::const_iterator it;
@@ -464,6 +466,8 @@
 void CWaitCommandsAI::Wait::SendCommand(const Command&amp; cmd,
 																				const CUnitSet&amp; unitSet)
 {
+	GML_RECMUTEX_LOCK(sel); // SendCommand
+
 	if (unitSet.empty()) {
 		return;
 	}
@@ -694,6 +698,8 @@
 CWaitCommandsAI::DeathWait::DeathWait(const Command&amp; cmd)
 : Wait(CMD_WAITCODE_DEATHWAIT)
 {
+	GML_RECMUTEX_LOCK(sel); // DeathWait
+
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 
 	if (cmd.params.size() == 1) {
@@ -922,6 +928,8 @@
 CWaitCommandsAI::SquadWait::SquadWait(const Command&amp; cmd)
 : Wait(CMD_WAITCODE_SQUADWAIT)
 {
+	GML_RECMUTEX_LOCK(sel); // SquadWait
+
 	if (cmd.params.size() != 1) {
 		return;
 	}
@@ -1093,6 +1101,8 @@
 CWaitCommandsAI::GatherWait::GatherWait(const Command&amp; cmd)
 : Wait(CMD_WAITCODE_GATHERWAIT)
 {
+	GML_RECMUTEX_LOCK(sel); // GatherWait
+
 	if (cmd.params.size() != 0) {
 		return;
 	}

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -333,7 +333,8 @@
 
 	glLineWidth(cmdColors.QueuedLineWidth());
 
-	GML_STDMUTEX_LOCK(cai);
+	GML_STDMUTEX_LOCK(cai); // DrawUnitCommandQueues
+
 	const CUnitSet&amp; units = drawCmdQueueUnits;
 	CUnitSet::const_iterator ui;
 	for (ui = units.begin(); ui != units.end(); ++ui) {
@@ -979,6 +980,8 @@
 
 int LuaUnsyncedCtrl::SetUnitNoSelect(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // SetUnitNoSelect
+
 	if (CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
 		return 0;
 	}
@@ -1590,6 +1593,8 @@
 
 int LuaUnsyncedCtrl::SetUnitGroup(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // SetUnitGroup
+
 	if (!CheckModUICtrl()) {
 		return 0;
 	}

Modified: trunk/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -499,6 +499,8 @@
 
 int LuaUnsyncedRead::IsUnitSelected(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // IsUnitSelected
+
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
 	if (unit == NULL) {
 		return 0;
@@ -729,6 +731,8 @@
 
 int LuaUnsyncedRead::GetSelectedUnits(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnits
+
 	CheckNoArgs(L, __FUNCTION__);
 	lua_newtable(L);
 	int count = 0;
@@ -747,6 +751,8 @@
 
 int LuaUnsyncedRead::GetSelectedUnitsSorted(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnitsSorted
+
 	CheckNoArgs(L, __FUNCTION__);
 
 	map&lt;int, vector&lt;CUnit*&gt; &gt; unitDefMap;
@@ -780,6 +786,8 @@
 
 int LuaUnsyncedRead::GetSelectedUnitsCounts(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnitsCounts
+
 	CheckNoArgs(L, __FUNCTION__);
 
 	// tally the types
@@ -1235,6 +1243,8 @@
 
 int LuaUnsyncedRead::GetActiveCommand(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetActiveCommand
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1257,6 +1267,8 @@
 
 int LuaUnsyncedRead::GetDefaultCommand(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetDefaultCommand
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1309,6 +1321,8 @@
 
 int LuaUnsyncedRead::GetActiveCmdDescs(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetActiveCmdDescs
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1328,6 +1342,8 @@
 
 int LuaUnsyncedRead::GetActiveCmdDesc(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetActiveCmdDesc
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1349,6 +1365,8 @@
 
 int LuaUnsyncedRead::GetCmdDescIndex(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetCmdDescIndex
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1659,6 +1677,8 @@
 
 int LuaUnsyncedRead::GetGroupList(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupList
+
 	CheckNoArgs(L, __FUNCTION__);
 	if (grouphandlers[gu-&gt;myTeam] == NULL) {
 		return 0;
@@ -1691,6 +1711,8 @@
 
 int LuaUnsyncedRead::GetGroupAIList(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupAIList
+
 	CheckNoArgs(L, __FUNCTION__);
 	lua_newtable(L);
 	const map&lt;AIKey, string&gt;&amp; availableAI = grouphandlers[gu-&gt;myTeam]-&gt;availableAI;
@@ -1711,6 +1733,8 @@
 
 int LuaUnsyncedRead::GetGroupAIName(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupAIName
+
 	const int args = lua_gettop(L); // number of arguments
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to GetGroupAIName(groupID)&quot;);
@@ -1757,6 +1781,8 @@
 
 int LuaUnsyncedRead::GetGroupUnits(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnits
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1782,6 +1808,8 @@
 
 int LuaUnsyncedRead::GetGroupUnitsSorted(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnitsSorted
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1821,6 +1849,8 @@
 
 int LuaUnsyncedRead::GetGroupUnitsCounts(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnitsCounts
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1857,6 +1887,8 @@
 
 int LuaUnsyncedRead::GetGroupUnitsCount(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnitsCount
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||

Modified: trunk/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Map/BaseGroundDrawer.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -235,7 +235,9 @@
 
 		switch(drawMode) {
 			case drawPath: {
-				GML_RECMUTEX_LOCK(gui); // UpdateExtraTexture
+
+//				GML_RECMUTEX_LOCK(gui); // UpdateExtraTexture. Not needed in draw thread
+
 				if (guihandler-&gt;inCommand &gt; 0 &amp;&amp; guihandler-&gt;inCommand &lt; guihandler-&gt;commands.size() &amp;&amp;
 						guihandler-&gt;commands[guihandler-&gt;inCommand].type == CMDTYPE_ICON_BUILDING) {
 					// use the current build order
@@ -267,7 +269,9 @@
 				}
 				else {
 					// use the first selected unit
+
 					GML_RECMUTEX_LOCK(sel); // UpdateExtraTexture
+
 					if (selectedUnits.selectedUnits.empty()) {
 						return true;
 					}

Modified: trunk/rts/Map/BaseGroundDrawer.h
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Map/BaseGroundDrawer.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -24,6 +24,11 @@
 	virtual void IncreaseDetail()=0;
 	virtual void DecreaseDetail()=0;
 
+#ifdef USE_GML
+	int multiThreadDrawGround;
+	int multiThreadDrawGroundShadow;
+#endif
+
 	enum DrawMode
 	{
 		drawNormal,

Modified: trunk/rts/Map/SMF/BFGroundDrawer.h
===================================================================
--- trunk/rts/Map/SMF/BFGroundDrawer.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Map/SMF/BFGroundDrawer.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -60,9 +60,6 @@
 	bool waterDrawn;
 
 #ifdef USE_GML
-	int multiThreadDrawGround;
-	int multiThreadDrawGroundShadow;
-
 	volatile unsigned int mt_overrideVP;
 	static void DoDrawGroundRowMT(void *c,int bty) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundRow(bty,((CBFGroundDrawer *)c)-&gt;mt_overrideVP);}
 	static void DoDrawGroundShadowLODMT(void *c,int nlod) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundShadowLOD(nlod);}

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -1123,11 +1123,13 @@
 	CVertexArray* va2=GetVertexArray();		//never try to get more than 2 at once
 	va2-&gt;Initialize();
 
-	int nadd=uh-&gt;activeUnits.size()*4;
+	GML_STDMUTEX_LOCK(render);
+
+	int nadd=uh-&gt;renderUnits.size()*4;
 	va-&gt;EnlargeArrays(nadd,0,VA_SIZE_TN);
 	va2-&gt;EnlargeArrays(nadd,0,VA_SIZE_TN);
 
-	for(std::list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin(); ui!=uh-&gt;activeUnits.end();++ui){
+	for(std::list&lt;CUnit*&gt;::iterator ui=uh-&gt;renderUnits.begin(); ui!=uh-&gt;renderUnits.end();++ui){
 		CUnit* unit=*ui;
 		if(unit-&gt;moveType &amp;&amp; unit-&gt;mobility) {
 			if(unit-&gt;unitDef-&gt;canhover){	//hover

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -224,6 +224,12 @@
 	while (!tempTransparentDrawUnits.empty() &amp;&amp; tempTransparentDrawUnits.begin()-&gt;first &lt;= gs-&gt;frameNum) {
 		tempTransparentDrawUnits.erase(tempTransparentDrawUnits.begin());
 	}
+
+	GML_STDMUTEX_LOCK(render);
+
+	for(std::set&lt;CUnit *&gt;::iterator ui=uh-&gt;toBeAdded.begin(); ui!=uh-&gt;toBeAdded.end(); ++ui)
+		uh-&gt;renderUnits.push_back(*ui);
+	uh-&gt;toBeAdded.clear();
 }
 
 
@@ -418,11 +424,11 @@
 	#ifdef DIRECT_CONTROL_ALLOWED
 		mt_excludeUnit=excludeUnit;
 	#endif
-		gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
+		gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;renderUnits,uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
 	else {
 #endif
-		for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
+		for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;renderUnits.begin(); usi != uh-&gt;renderUnits.end(); ++usi) {
 			CUnit* unit = *usi;
 			DoDrawUnit(unit,drawReflection,drawRefraction,
 		#ifdef DIRECT_CONTROL_ALLOWED
@@ -693,12 +699,12 @@
 #ifdef USE_GML
 	if(multiThreadDrawUnitShadow) {
 		gmlProcessor.Work(NULL, NULL, &amp;CUnitDrawer::DoDrawUnitShadowMT, this, gmlThreadCount, FALSE,
-		  &amp;uh-&gt;activeUnits, uh-&gt;activeUnits.size(),50,100,TRUE);
+		  &amp;uh-&gt;renderUnits, uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
 	else {
 #endif
 		std::list&lt;CUnit*&gt;::iterator usi;
-		for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
+		for (usi = uh-&gt;renderUnits.begin(); usi != uh-&gt;renderUnits.end(); ++usi) {
 			CUnit* unit = *usi;
 			DoDrawUnitShadow(unit);
 		}

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -249,6 +249,8 @@
 	switch (aircraftState) {
 		case AIRCRAFT_FLYING: {
 	#ifdef DEBUG_AIRCRAFT
+			GML_RECMUTEX_LOCK(sel); // Update
+
 			if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
 				logOutput.Print(&quot;Flying %i %i %.1f %i&quot;, moveState, fireState, inefficientAttackTime, (int) isFighter);
 			}
@@ -437,6 +439,8 @@
 void CAirMoveType::UpdateManeuver(void)
 {
 #ifdef DEBUG_AIRCRAFT
+	GML_RECMUTEX_LOCK(sel); // UpdateManuever
+
 	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
 		logOutput.Print(&quot;UpdataMan %i %i&quot;, maneuver, maneuverSubState);
 	}
@@ -658,6 +662,8 @@
 			elevator = minPitch * upside;
 	}
 #ifdef DEBUG_AIRCRAFT
+	GML_RECMUTEX_LOCK(sel); // UpdateFighterAttack
+
 	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()){
 		logOutput.Print(&quot;FAttack %.1f %.1f %.2f&quot;, pos.y - gHeight, goalLength, goalDir.dot(frontdir));
 	}
@@ -1084,6 +1090,8 @@
 	owner-&gt;UpdateMidPos();
 
 #ifdef DEBUG_AIRCRAFT
+	GML_RECMUTEX_LOCK(sel); // UpdateAirPhysics
+
 	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
 		logOutput.Print(&quot;UpdataAP %.1f %.1f %.1f %.1f&quot;, speedf, pos.x, pos.y, pos.z);
 		// logOutput.Print(&quot;Rudders %.1f %.1f %.1f %.1f&quot;, rudder, aileron, elevator, engine);

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -1091,9 +1091,12 @@
 							(o-&gt;mobility || Distance2D(owner, o) &gt;= 0)) {
 							// Avoid collision by turning the heading to left or right.
 							// Using the object thats needs the most adjustment.
-							if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end())
+#if DEBUG_CONTROLLER
+							GML_RECMUTEX_LOCK(sel); // ObstacleAvoidance
+
+							if (selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end())
 								geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, o-&gt;pos + UpVector * 20, 3, 1, 4);
-
+#endif
 							if (objectDistToAvoidDirCenter &gt; 0.0f) {
 								avoidRight += (radiusSum - objectDistToAvoidDirCenter) * AVOIDANCE_STRENGTH / distanceToObject;
 								avoidanceDir += (rightOfAvoid * avoidRight);
@@ -1116,13 +1119,18 @@
 
 			// Sum up avoidance.
 			avoidanceVec = (desiredDir.cross(float3(0.0f, 1.0f, 0.0f)) * (avoidRight - avoidLeft));
-			if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end()) {
+
+#if DEBUG_CONTROLLER
+			GML_RECMUTEX_LOCK(sel); //ObstacleAvoidance
+
+			if (selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end()) {
 				int a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + avoidanceVec * 40, 7, 1, 4);
 				geometricObjects-&gt;SetColor(a, 1, 0.3f, 0.3f, 0.6f);
 
 				a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + desiredDir * 40, 7, 1, 4);
 				geometricObjects-&gt;SetColor(a, 0.3f, 0.3f, 1, 0.6f);
 			}
+#endif
 		}
 
 		// Return the resulting recommended velocity.

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -911,7 +911,8 @@
 
 void CPathEstimator::Draw(void)
 {
-//	GML_RECMUTEX_LOCK(sel); // Draw
+	GML_RECMUTEX_LOCK(sel); // Draw
+
 	MoveData* md = moveinfo-&gt;GetMoveDataFromName(&quot;TANKSH2&quot;);
 	if (!selectedUnits.selectedUnits.empty() &amp;&amp; (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata)
 		md = (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata;

Modified: trunk/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/CommandQueue.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Units/CommandAI/CommandQueue.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -44,18 +44,27 @@
 
 		inline iterator insert(iterator pos, const Command&amp; cmd);
 
-		inline void pop_back()  { GML_STDMUTEX_LOCK(cai); queue.pop_back(); }
-		inline void pop_front() { GML_STDMUTEX_LOCK(cai); queue.pop_front(); }
+		inline void pop_back()  { 
+			GML_STDMUTEX_LOCK(cai); // pop_back
+			queue.pop_back(); 
+		}
+		inline void pop_front() { 
+			GML_STDMUTEX_LOCK(cai); // pop_front
+			queue.pop_front(); 
+		}
 
 		inline iterator erase(iterator pos) {
-			GML_STDMUTEX_LOCK(cai); // Erase
+			GML_STDMUTEX_LOCK(cai); // erase
 			return queue.erase(pos);
 		}
 		inline iterator erase(iterator first, iterator last) {
-			GML_STDMUTEX_LOCK(cai); // Erase
+			GML_STDMUTEX_LOCK(cai); // erase
 			return queue.erase(first, last);
 		}
-		inline void clear() { GML_STDMUTEX_LOCK(cai); queue.clear(); }
+		inline void clear() { 
+			GML_STDMUTEX_LOCK(cai); // clear 
+			queue.clear(); 
+		}
 
 		inline iterator       end()         { return queue.end(); }
 		inline const_iterator end()   const { return queue.end(); }

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -1660,6 +1660,8 @@
 			group=0;									//group ai didnt accept us
 			return false;
 		} else { // add us to selected units if group is selected
+			GML_RECMUTEX_LOCK(sel); // SetGroup
+
 			if(selectedUnits.selectedGroup == group-&gt;id)
 				selectedUnits.AddUnit(this);
 		}

Modified: trunk/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Units/UnitHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -103,7 +103,6 @@
 	CR_MEMBER(metalMakerEfficiency),
 	CR_MEMBER(toBeRemoved),
 	CR_MEMBER(morphUnitToFeature),
-	CR_MEMBER(toBeRemoved),
 	CR_MEMBER(builderCAIs),
 	CR_MEMBER(unitsByDefs),
 	CR_POSTLOAD(PostLoad),
@@ -186,7 +185,8 @@
 
 int CUnitHandler::AddUnit(CUnit *unit)
 {
-	GML_RECMUTEX_LOCK(unit); // AddUnit
+//	GML_RECMUTEX_LOCK(unit); // AddUnit. Not needed, protected via LoadUnit. 
+
 	ASSERT_SYNCED_MODE;
 	int num = (int)(gs-&gt;randFloat()) * ((int)activeUnits.size() - 1);
 	std::list&lt;CUnit*&gt;::iterator ui = activeUnits.begin();
@@ -213,6 +213,10 @@
 
 	maxUnitRadius = max(unit-&gt;radius, maxUnitRadius);
 
+	GML_STDMUTEX_LOCK(render);
+
+	toBeAdded.insert(unit);
+
 	return unit-&gt;id;
 }
 
@@ -257,6 +261,16 @@
 			++usi;
 		}
 	}
+
+	GML_STDMUTEX_LOCK(render);
+
+	for(usi=renderUnits.begin(); usi!=renderUnits.end(); ++usi) {
+		if(*usi==delUnit) {
+			renderUnits.erase(usi);
+			break;
+		}
+	}
+	toBeAdded.erase(delUnit);
 }
 
 
@@ -266,9 +280,9 @@
 	SCOPED_TIMER(&quot;Unit handler&quot;);
 
 	if(!toBeRemoved.empty()) {
-		GML_RECMUTEX_LOCK(unit); // Update. Possibly not needed, activeUnits.erase is synchronized.
+		GML_RECMUTEX_LOCK(unit); // Update. For anti-deadlock purposes.
+		GML_RECMUTEX_LOCK(sel); // Update. Unit is removed from selectedUnits in ~CObject, which is too late.
 		GML_RECMUTEX_LOCK(quad); // Update. Make sure unit does not get partially deleted before before being removed from the quadfield
-		GML_RECMUTEX_LOCK(sel); // Update. Unit is removed from selectedUnits in ~CObject, which is too late.
 
 		while (!toBeRemoved.empty()) {
 			CUnit* delUnit = toBeRemoved.back();

Modified: trunk/rts/Sim/Units/UnitHandler.h
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Units/UnitHandler.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -61,6 +61,9 @@
 
 	std::vector&lt;CUnit*&gt; toBeRemoved;			//units that will be removed at start of next update
 
+	std::set&lt;CUnit*&gt; toBeAdded;			//rendering units that will be added at start of next draw
+	std::list&lt;CUnit*&gt; renderUnits;				//units being rendered
+
 	std::list&lt;CUnit*&gt;::iterator slowUpdateIterator;
 
 	std::list&lt;CBuilderCAI*&gt; builderCAIs;

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -74,7 +74,8 @@
 CUnit* CUnitLoader::LoadUnit(const string&amp; name, float3 pos, int team,
                              bool build, int facing, const CUnit* builder)
 {
-	GML_RECMUTEX_LOCK(unit); // LoadUnit. Unitinit puts unit in the quadfield and activeUnits -
+//	GML_RECMUTEX_LOCK(unit); // LoadUnit. Unitinit puts unit in the quadfield and activeUnits -
+	GML_RECMUTEX_LOCK(sel); // LoadUnit. For anti deadlock purposes.
 	GML_RECMUTEX_LOCK(quad); // LoadUnit. - make sure other threads cannot access an incomplete unit
 
 	CUnit* unit;

Modified: trunk/rts/Sim/Units/UnitTracker.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTracker.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/Sim/Units/UnitTracker.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -85,6 +85,8 @@
 
 void CUnitTracker::Track()
 {
+	GML_RECMUTEX_LOCK(sel); // Track
+
 	CUnitSet&amp; units = selectedUnits.selectedUnits;
 
 	CleanTrackGroup();
@@ -119,6 +121,8 @@
 
 void CUnitTracker::MakeTrackGroup()
 {
+	GML_RECMUTEX_LOCK(sel); // MakeTrackGroup
+
 	trackGroup.clear();
 	CUnitSet&amp; units = selectedUnits.selectedUnits;
 	CUnitSet::const_iterator it;

Modified: trunk/rts/System/FileSystem/FileHandler.cpp
===================================================================
--- trunk/rts/System/FileSystem/FileHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/System/FileSystem/FileHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;fstream&gt;
 #include &lt;algorithm&gt;
 #include &lt;cctype&gt;
@@ -21,6 +22,8 @@
 CFileHandler::CFileHandler(const char* filename, const char* modes)
 : ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	Init(filename, modes);
 }
 
@@ -28,12 +31,16 @@
 CFileHandler::CFileHandler(const string&amp; filename, const string&amp; modes)
 : ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	Init(filename, modes);
 }
 
 
 CFileHandler::~CFileHandler(void)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		delete ifs;
 	}
@@ -120,6 +127,8 @@
 
 int CFileHandler::Read(void* buf,int length)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		ifs-&gt;read((char*)buf, length);
 		return ifs-&gt;gcount ();
@@ -141,6 +150,8 @@
 
 void CFileHandler::Seek(int length)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		ifs-&gt;seekg(length);
 	} else if (hpiFileBuffer){
@@ -151,6 +162,8 @@
 
 int CFileHandler::Peek() const
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		return ifs-&gt;peek();
 	}
@@ -167,6 +180,8 @@
 
 bool CFileHandler::Eof() const
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		return ifs-&gt;eof();
 	}
@@ -185,6 +200,8 @@
 
 int CFileHandler::GetPos() const
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		return ifs-&gt;tellg();
 	} else {
@@ -195,6 +212,8 @@
 
 bool CFileHandler::LoadStringData(string&amp; data)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (!FileExists()) {
 		return false;
 	}
@@ -211,6 +230,8 @@
 vector&lt;string&gt; CFileHandler::FindFiles(const string&amp; path,
                                        const string&amp; pattern)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	vector&lt;string&gt; found = filesystem.FindFiles(path, pattern);
 	boost::regex regexpattern(filesystem.glob_to_regex(pattern),
 	                          boost::regex::icase);
@@ -235,6 +256,8 @@
                                      const string&amp; pattern,
                                      const string&amp; modes)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	const string pat = pattern.empty() ? &quot;*&quot; : pattern;
 
 	set&lt;string&gt; fileSet;
@@ -323,6 +346,8 @@
                                      const string&amp; pattern,
                                      const string&amp; modes)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	const string pat = pattern.empty() ? &quot;*&quot; : pattern;
 
 	set&lt;string&gt; dirSet;

Modified: trunk/rts/System/Platform/ConfigHandler.cpp
===================================================================
--- trunk/rts/System/Platform/ConfigHandler.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/System/Platform/ConfigHandler.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -27,10 +27,10 @@
  * Default instantiation of ConfigHandler instance
  * is NULL.
  */
-ConfigHandler* ConfigHandler::instance = NULL;
+//ConfigHandler* ConfigHandler::instance = NULL;
 
 
-std::string ConfigHandler::configSource;
+//std::string ConfigHandler::configSource;
 
 
 /**

Modified: trunk/rts/System/Script/LuaFunctions.cpp
===================================================================
--- trunk/rts/System/Script/LuaFunctions.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/System/Script/LuaFunctions.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -168,6 +168,8 @@
 
 	void SendSelectedUnits()
 	{
+		GML_RECMUTEX_LOCK(sel); // SendSelectedUnits
+
 		if (selectedUnits.selectionChanged)
 			selectedUnits.SendSelection();
 	}

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/System/SpringApp.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -104,6 +104,10 @@
 	FSAA = false;
 
 	signal(SIGABRT, SigAbrtHandler);
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	extern volatile int multiThreadSim;
+	multiThreadSim=configHandler.GetInt(&quot;MultiThreadSim&quot;, 1);
+#endif
 }
 
 /**
@@ -860,6 +864,45 @@
 	}
 }
 
+
+
+
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+volatile int multiThreadSim;
+volatile int startsim;
+
+int SpringApp::Sim() {
+	while(keeprunning &amp;&amp; !startsim)
+		SDL_Delay(100);
+//		boost::thread::yield();
+	while(keeprunning) {
+		if(!multiThreadSim) {
+//			startsim=0;
+			while(!multiThreadSim &amp;&amp; keeprunning)
+				SDL_Delay(100);
+//			simBarrier.wait();
+//			startsim=1;
+		}
+		else if (activeController) {
+			GML_STDMUTEX_LOCK(sim);
+
+			gmlProcessor.ExpandAuxQueue();
+			if (!activeController-&gt;Update()) {
+				return 0;
+			}
+			gmlProcessor.GetQueue();
+		}
+//		while(!startsim)
+//			SDL_Delay(100);
+		boost::thread::yield();
+	}
+	return 1;
+}
+#endif
+
+
+
+
 /**
  * @return return code of activecontroller draw function
  *
@@ -871,9 +914,8 @@
 	if (FSAA)
 		glEnable(GL_MULTISAMPLE_ARB);
 
-#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
 	mouseInput-&gt;Update();
-#endif
+
 	int ret = 1;
 	if (activeController) {
 #if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
@@ -887,11 +929,19 @@
 			if(frame==gu-&gt;drawFrame) { // only draw if it was not done in parallel with sim
 #	endif
 #else
-				if(!gs-&gt;frameNum) {
-					mouseInput-&gt;Update();
+				if(multiThreadSim) {
+					if(!gs-&gt;frameNum) {
+						GML_STDMUTEX_LOCK(sim);
+
+						activeController-&gt;Update();
+						if(gs-&gt;frameNum)
+							startsim=1;
+					}
+				}
+				else {
+					GML_STDMUTEX_LOCK(sim);
+
 					activeController-&gt;Update();
-					if(gs-&gt;frameNum)
-						startsim=1;
 				}
 #endif
 				gu-&gt;drawFrame++;
@@ -919,27 +969,6 @@
 	return ret;
 }
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-int SpringApp::Sim() {
-	while(keeprunning &amp;&amp; !startsim)
-		boost::thread::yield();
-	unsigned lastSim = SDL_GetTicks();
-	while(keeprunning) {
-		mouseInput-&gt;Update();
-		if (activeController) {
-			if (!activeController-&gt;Update()) {
-				return 0;
-			}
-			gmlProcessor.GetQueue();
-		}
-		unsigned lastSimDiff=SDL_GetTicks()-lastSim;
-		if(lastSimDiff&lt;=10)
-			SDL_Delay(10-lastSimDiff);
-		lastSim = SDL_GetTicks();
-	}
-	return 1;
-}
-#endif
 
 /**
  * Tests SDL keystates and sets values
@@ -1002,6 +1031,8 @@
 		while (SDL_PollEvent(&amp;event)) {
 			switch (event.type) {
 				case SDL_VIDEORESIZE: {
+					GML_STDMUTEX_LOCK(sim);
+
 					screenWidth = event.resize.w;
 					screenHeight = event.resize.h;
 #ifndef WIN32
@@ -1015,6 +1046,8 @@
 					break;
 				}
 				case SDL_VIDEOEXPOSE: {
+					GML_STDMUTEX_LOCK(sim);
+
 					// re-initialize the stencil
 					glClearStencil(0);
 					glClear(GL_STENCIL_BUFFER_BIT); SDL_GL_SwapBuffers();

Modified: trunk/rts/System/SpringApp.h
===================================================================
--- trunk/rts/System/SpringApp.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/System/SpringApp.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -37,7 +37,6 @@
 	int Sim (); 					//!&lt; Simulation  loop
 	static void Simcb(void *c) {((SpringApp *)c)-&gt;Sim();}
 	volatile int keeprunning;
-	volatile int startsim;
 #endif
 	void UpdateSDLKeys (); 				//!&lt; Update SDL key array
 	bool GetDisplayGeometry();

Modified: trunk/rts/build/scons/rts.py
===================================================================
--- trunk/rts/build/scons/rts.py	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/build/scons/rts.py	2008-10-23 20:02:01 UTC (rev 6858)
@@ -87,7 +87,8 @@
 	usropts.AddOptions(
 		#permanent options
 		('platform',          'Set to linux, freebsd or windows', None),
-		('gml',               'Set to false to disable OpenGL thread library', False),
+		('gml',               'Set to yes to enable the OpenGL Multithreading Library', False),
+		('gmlsim',            'Set to yes to enable parallel threads for Sim/Draw', False),
 		('debug',             'Set to yes to produce a binary with debug information', 0),
 		('debugdefines',      'Set to no to suppress DEBUG and _DEBUG preprocessor #defines (use to add symbols to release build)', True),
 		('syncdebug',         'Set to yes to enable the sync debugger', False),
@@ -152,7 +153,7 @@
 	if 'configure' in sys.argv:
 
 		# be paranoid, unset existing variables
-		for key in ['platform', 'gml', 'debug', 'optimize', 'profile', 'profile_use', 'profile_generate', 'cpppath',
+		for key in ['platform', 'gml', 'gmlsim', 'debug', 'optimize', 'profile', 'profile_use', 'profile_generate', 'cpppath',
 			'libpath', 'prefix', 'installprefix', 'datadir', 'bindir', 'libdir', 'cachedir', 'strip',
 			'disable_avi', 'use_tcmalloc', 'use_mmgr', 'use_gch', 'LINKFLAGS', 'LIBPATH', 'LIBS', 'CCFLAGS',
 			'CXXFLAGS', 'CPPDEFINES', 'CPPPATH', 'CC', 'CXX', 'is_configured', 'spring_defines', 'arch']:
@@ -371,6 +372,7 @@
 			#	env['CXXFLAGS'] = env['CCFLAGS']
 
 		bool_opt('gml', False)
+		bool_opt('gmlsim', False)
 		bool_opt('strip', False)
 		bool_opt('disable_avi', env['platform'] != 'windows')
 		bool_opt('use_tcmalloc', False)
@@ -399,9 +401,14 @@
 		if env['gml']:
 			env.AppendUnique(CCFLAGS = ['-mno-tls-direct-seg-refs'], CXXFLAGS = ['-mno-tls-direct-seg-refs'], LINKFLAGS = ['-mno-tls-direct-seg-refs'])		
 			spring_defines += ['USE_GML']
-			print 'GML OpenGL thread library is enabled'
+			print 'OpenGL Multithreading Library is enabled'
+			if env['gmlsim']:
+				spring_defines += ['USE_GML_SIM']
+				print 'Parallel threads for Sim/Draw is enabled'
+			else:
+				print 'Parallel threads for Sim/Draw is NOT enabled'
 		else:
-			print 'GML OpenGL thread library NOT enabled'
+			print 'OpenGL Multithreading Library and parallel threads for Sim/Draw are NOT enabled'
 
 		# Add define specifying type of floating point math to use.
 		if env['fpmath']:

Modified: trunk/rts/build/vstudio8/rts.vcproj
===================================================================
--- trunk/rts/build/vstudio8/rts.vcproj	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/build/vstudio8/rts.vcproj	2008-10-23 20:02:01 UTC (rev 6858)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
 &lt;VisualStudioProject
 	ProjectType=&quot;Visual C++&quot;
-	Version=&quot;8,00&quot;
+	Version=&quot;8.00&quot;
 	Name=&quot;rts&quot;
 	ProjectGUID=&quot;{A0F70264-A7B7-4FE7-A5BE-298CD3A0758F}&quot;
 	RootNamespace=&quot;rts&quot;
@@ -419,7 +419,7 @@
 				EnableIntrinsicFunctions=&quot;true&quot;
 				FavorSizeOrSpeed=&quot;1&quot;
 				AdditionalIncludeDirectories=&quot;../../;../../System;../../lib/streflop;../../lib/crashrpt/include;&quot;../../../vclibs/freetype-2.1.10/include&quot;;../../../vclibs/DevIL/include;../../../vclibs/boost/Include;../../../vclibs/OpenAL/include;../../../vclibs/glew/include;../../../vclibs/zlibwapi/include;&quot;../../../vclibs/SDL-1.2.9/include&quot;;&quot;../../../vclibs/libjpeg/libjpeg-include&quot;;../../lib/lua/include;../../lib/luabind;../../../vclibs/ogg_vorbis/include&quot;
-				PreprocessorDefinitions=&quot;_CMATH_;_WIN32;WIN32;NDEBUG;_WINDOWS;ZLIB_WINAPI;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;SYNCCHECK;USE_GML&quot;
+				PreprocessorDefinitions=&quot;_CMATH_;_WIN32;WIN32;NDEBUG;_WINDOWS;ZLIB_WINAPI;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;SYNCCHECK;USE_GML;USE_GML_SIM&quot;
 				StringPooling=&quot;true&quot;
 				ExceptionHandling=&quot;2&quot;
 				RuntimeLibrary=&quot;2&quot;
@@ -514,7 +514,7 @@
 				AdditionalOptions=&quot;/vmg&quot;
 				Optimization=&quot;0&quot;
 				AdditionalIncludeDirectories=&quot;../../;../../System;../../lib/streflop;../../lib/crashrpt/include;&quot;../../../vclibs/freetype-2.1.10/include&quot;;../../../vclibs/DevIL/include;../../../vclibs/boost/Include;../../../vclibs/OpenAL/include;../../../vclibs/glew/include;../../../vclibs/zlibwapi/include;&quot;../../../vclibs/SDL-1.2.9/include&quot;;&quot;../../../vclibs/libjpeg/libjpeg-include&quot;;../../lib/lua/include;../../lib/luabind;../../../vclibs/ogg_vorbis/include&quot;
-				PreprocessorDefinitions=&quot;_CMATH_;NO_CATCH_EXCEPTIONS;_WIN32;WIN32;_DEBUG;_WINDOWS;ZLIB_WINAPI;_SZ_ONE_DIRECTORY;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;USE_GML&quot;
+				PreprocessorDefinitions=&quot;_CMATH_;NO_CATCH_EXCEPTIONS;_WIN32;WIN32;_DEBUG;_WINDOWS;ZLIB_WINAPI;_SZ_ONE_DIRECTORY;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;USE_GML;USE_GML_SIM&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
 				RuntimeLibrary=&quot;3&quot;

Modified: trunk/rts/lib/gml/gml.cpp
===================================================================
--- trunk/rts/lib/gml/gml.cpp	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/lib/gml/gml.cpp	2008-10-23 20:02:01 UTC (rev 6858)
@@ -32,10 +32,13 @@
 // If a function is not yet supported by GML, a compile error pointing to 'GML_FUNCTION_NOT_IMPLEMENTED' will occur
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
+ConfigHandler* ConfigHandler::instance = NULL;
+std::string ConfigHandler::configSource;
+
 #ifdef USE_GML
 #include &quot;gmlcls.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;Platform/ConfigHandler.h&quot;
 
 #define EXEC_RUN (BYTE *)NULL
 #define EXEC_SYNC (BYTE *)-1
@@ -55,8 +58,9 @@
 #else
 int gmlThreadNumber=0;
 #endif
+//ConfigHandler *dummyConfigHandler=ConfigHandler::instance = NULL;
+int gmlThreadCountOverride=configHandler.GetInt(&quot;HardwareThreadCount&quot;, 0); // number of threads to use (can be manually overridden here)
 int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
-int gmlThreadCountOverride=0; //configHandler.GetInt(&quot;HardwareThreadCount&quot;, 0); // number of threads to use (can be manually overridden here)
 int gmlItemsConsumed=0;
 
 // gmlCPUCount returns the number of CPU cores
@@ -97,6 +101,14 @@
 #endif
 }
 
+const char *gmlFunctionNames[512];
+inline int gmlResetNames() {
+    for(int i=0; i&lt;512; ++i)
+        gmlFunctionNames[i]=&quot;&quot;;
+    return 0;
+}
+int gmlNamesDummy=gmlResetNames();
+
 // cache maps for gmlInit
 std::map&lt;GLenum,GLint&gt; gmlGetIntegervCache;
 std::map&lt;GLenum,GLfloat&gt; gmlGetFloatvCache;
@@ -186,16 +198,20 @@
 boost::mutex groupmutex;
 boost::mutex inmapmutex;
 boost::mutex tempmutex;
+boost::mutex posmutex;
+boost::mutex rendermutex;
+boost::mutex simmutex;
 
 #include &lt;boost/thread/recursive_mutex.hpp&gt;
 boost::recursive_mutex unitmutex;
+boost::recursive_mutex selmutex;
+boost::recursive_mutex &amp;luamutex=selmutex;
 boost::recursive_mutex quadmutex;
-boost::recursive_mutex selmutex;
-boost::recursive_mutex luamutex;
 boost::recursive_mutex featmutex;
 boost::recursive_mutex projmutex;
 boost::recursive_mutex grassmutex;
 boost::recursive_mutex guimutex;
+boost::recursive_mutex filemutex;
 #endif
 
 // GMLqueue implementation
@@ -630,7 +646,9 @@
 		glDrawArrays(GML_D(name,A),0,GML_D(name,B));\
 	GML_NEXT_SIZE(name)
 
-
+const char *gmlNOPDummy=(gmlFunctionNames[0]=&quot;gmlNOP&quot;);
+#define GML_QUOTE(x) #x
+#define GML_MAKENAME(name) EXTERN const char *gml##name##Dummy=(gmlFunctionNames[gml##name##Enum]=GML_QUOTE(gml##name));
 #include &quot;gmlfun.h&quot;
 // this item server instance needs gmlDeleteLists from gmlfun.h, that is why it is declared down here
 gmlItemSequenceServer&lt;GLuint, GLsizei,GLuint (GML_GLAPIENTRY *)(GLsizei)&gt; gmlListServer(&amp;glGenLists, &amp;gmlDeleteLists, 100, 25, 20, 5);
@@ -916,22 +934,24 @@
 }
 
 void gmlQueue::ExecuteDebug() {
-	int procs=0;
+//	int procs=0;
 	BYTE *p=Read;
 	BYTE *e=ReadPos;
 	BYTE *ptr=NULL;
 
 	while(p&lt;e) {
 		if(*(int *)p!=0)
-			logOutput.Print(&quot;GML error: OpenGL call #%d in SimFrame()&quot;,*(int *)p);
+			logOutput.Print(&quot;GML error: Sim thread called %s&quot;,gmlFunctionNames[*(int *)p]);
 		QueueHandler(p,ptr);
-		++procs;
+//		++procs;
 	}
-	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
-		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
+//	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
+//		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
 }
 
 #include &quot;gmlsrv.h&quot;
+class CUnit;
+gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 
 // ExecuteSynced - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points

Modified: trunk/rts/lib/gml/gml.h
===================================================================
--- trunk/rts/lib/gml/gml.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/lib/gml/gml.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -74,12 +74,15 @@
 extern void gmlInit();
 
 EXTERN inline GLhandleARB gmlCreateProgram() {
+	GML_ITEMSERVER_CHECK();
 	return gmlProgramServer.GetItems();
 }
 EXTERN inline GLhandleARB gmlCreateProgramObjectARB() {
+	GML_ITEMSERVER_CHECK();
 	return gmlProgramObjectARBServer.GetItems();
 }
 EXTERN inline GLhandleARB gmlCreateShader(GLenum type) {
+	GML_ITEMSERVER_CHECK();
 	if(type==GL_VERTEX_SHADER)
 		return gmlShaderServer_VERTEX.GetItems();
 	if(type==GL_FRAGMENT_SHADER)
@@ -89,6 +92,7 @@
 	return 0;
 }
 EXTERN inline GLhandleARB gmlCreateShaderObjectARB(GLenum type) {
+	GML_ITEMSERVER_CHECK();
 	if(type==GL_VERTEX_SHADER_ARB)
 		return gmlShaderObjectARBServer_VERTEX.GetItems();
 	if(type==GL_FRAGMENT_SHADER_ARB)
@@ -98,36 +102,46 @@
 	return 0;
 }
 EXTERN inline GLUquadric *gmluNewQuadric() {
+	GML_ITEMSERVER_CHECK();
 	return gmlQuadricServer.GetItems();
 }
 
 
 EXTERN inline void gmlGenTextures(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlTextureServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenBuffersARB(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlBufferARBServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenFencesNV(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlFencesNVServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenProgramsARB(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlProgramsARBServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenRenderbuffersEXT(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlRenderbuffersEXTServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenFramebuffersEXT(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlFramebuffersEXTServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenQueries(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlQueryServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenBuffers(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlBufferServer.GetItems(n, items);
 }
 
 EXTERN inline GLuint gmlGenLists(GLsizei items) {
+	GML_ITEMSERVER_CHECK();
 	return gmlListServer.GetItems(items);
 }
 
@@ -148,16 +162,20 @@
 extern boost::mutex groupmutex;
 extern boost::mutex inmapmutex;
 extern boost::mutex tempmutex;
+extern boost::mutex posmutex;
+extern boost::mutex rendermutex;
+extern boost::mutex simmutex;
 
 #include &lt;boost/thread/recursive_mutex.hpp&gt;
 extern boost::recursive_mutex unitmutex;
 extern boost::recursive_mutex quadmutex;
 extern boost::recursive_mutex selmutex;
-extern boost::recursive_mutex luamutex;
+extern boost::recursive_mutex &luamutex;
 extern boost::recursive_mutex featmutex;
 extern boost::recursive_mutex projmutex;
 extern boost::recursive_mutex grassmutex;
 extern boost::recursive_mutex guimutex;
+extern boost::recursive_mutex filemutex;
 
 #define GML_STDMUTEX_LOCK(name) boost::mutex::scoped_lock name##lock(name##mutex)
 #define GML_RECMUTEX_LOCK(name) boost::recursive_mutex::scoped_lock name##lock(name##mutex)

Modified: trunk/rts/lib/gml/gmlcls.h
===================================================================
--- trunk/rts/lib/gml/gmlcls.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/lib/gml/gmlcls.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -33,9 +33,15 @@
 #	define GML_ENABLE 0 // manually enable opengl multithreading here
 #endif
 
+#ifdef USE_GML_SIM
+#	define GML_ENABLE_LOOP 1
+#else
+#	define GML_ENABLE_LOOP 0
+#endif
+
 #define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
-#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; 0) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
-#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; 0) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
+#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; GML_ENABLE_LOOP) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
+#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; GML_ENABLE_LOOP) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
 
 #define GML_ENABLE_DRAW (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
 #define GML_SERVER_GLCALL 1 // allows the server thread (0) to make direct GL calls
@@ -44,6 +50,8 @@
 #define GML_USE_DEFAULT 1// compile/link/buffer status always returns TRUE/COMPLETE (to improve performance)
 #define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
 //#define GML_USE_QUADRIC_SERVER 1 // use server thread to create/delete quadrics
+#define GML_AUX_PREALLOC 128*1024 // preallocation size for aux queue to reduce risk for hang if gl calls happen to be made from Sim thread
+#define GML_ENABLE_ITEMSERVER_CHECK (GML_ENABLE_SIMDRAW &amp;&amp; 1) // if calls to itemserver are made from Sim, output errors to log
 #define GML_UPDSRV_INTERVAL 10
 #define GML_ALTERNATE_SYNCMODE 1 // mutex-protected synced execution, slower but more portable
 #define GML_ENABLE_TLS_CHECK 1 // check if Thread Local Storage appears to be working

Modified: trunk/rts/lib/gml/gmlfun.h
===================================================================
--- trunk/rts/lib/gml/gmlfun.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/lib/gml/gmlfun.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -11,6 +11,7 @@
 
 #include &lt;set&gt;
 #include &lt;map&gt;
+#include &quot;LogOutput.h&quot;
 
 #define GML_ENABLE_DEBUG 0
 
@@ -324,11 +325,28 @@
 
 #define GML_SYNC() gmlSync(qd)
 
-#define GML_FUN(name,ftype) EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+#ifndef GML_MAKENAME
+#	define GML_MAKENAME(name)
+#endif
+#define GML_FUN(name,ftype) EXTERN const int gml##name##Enum=(__LINE__-__FIRSTLINE__);\
+	GML_MAKENAME(name)\
 	EXTERN inline ftype gml##name
 
-#define GML_RETFUN(name,ftr) EXTERN inline ftr gml##name
+#ifdef _MSC_VER
+#define GML_FUNCTION __FUNCTION__
+#else
+#define GML_FUNCTION __func__
+#endif
 
+#if GML_ENABLE_ITEMSERVER_CHECK
+#define GML_ITEMSERVER_CHECK()\
+    if(gmlThreadNumber==gmlThreadCount)\
+        logOutput.Print(&quot;GML error: Sim thread called %s&quot;,GML_FUNCTION);
+#else
+#define GML_ITEMSERVER_CHECK()
+#endif
+//#define GML_RETFUN(name,ftr) EXTERN inline ftr gml##name
+
 #define GML_MAKEFUN0(name) struct gml##name##Data {\
 	GML_MAKEVAR()\
 };\

Modified: trunk/rts/lib/gml/gmlsrv.h
===================================================================
--- trunk/rts/lib/gml/gmlsrv.h	2008-10-23 18:33:20 UTC (rev 6857)
+++ trunk/rts/lib/gml/gmlsrv.h	2008-10-23 20:02:01 UTC (rev 6858)
@@ -407,6 +407,12 @@
 		}
 	}
 
+	void ExpandAuxQueue() {
+		gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];
+		while(qd-&gt;WriteSize&lt;qd-&gt;Write+GML_AUX_PREALLOC)
+			qd-&gt;WaitRealloc();
+	}
+
 };
 
 #endif // USE_GML


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001626.html">[Taspring-linux-commit] r6857 - in Lobby/springie: ModInfoBuilder	Springie Springie/UnitSync Springie/autohost Springie/client	Springie/doc Springie/spring
</A></li>
	<LI>Next message: <A HREF="001628.html">[Taspring-linux-commit] r6859 - in Lobby/TASClient: . Python/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1627">[ date ]</a>
              <a href="thread.html#1627">[ thread ]</a>
              <a href="subject.html#1627">[ subject ]</a>
              <a href="author.html#1627">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
