<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6697 - in branches/caiinterface: .	AI/Interfaces AI/Interfaces/C AI/Skirmish AI/Skirmish/KAI	AI/Skirmish/KAIK AI/Skirmish/NullAI	AI/Skirmish/NullLegacyCppAI AI/Skirmish/RAI	AI/Skirmish/RAI/CodeBlocks AI/Skirmish/RAI/DevC	AI/Skirmish/RAI/VS2008 rts/ExternalAI rts/Game
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6697%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Interfaces%20AI/Interfaces/C%20AI/Skirmish%20AI/Skirmish/KAI%0A%09AI/Skirmish/KAIK%20AI/Skirmish/NullAI%0A%09AI/Skirmish/NullLegacyCppAI%20AI/Skirmish/RAI%0A%09AI/Skirmish/RAI/CodeBlocks%20AI/Skirmish/RAI/DevC%0A%09AI/Skirmish/RAI/VS2008%20rts/ExternalAI%20rts/Game&In-Reply-To=%3C20081013175706.494414730%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001465.html">
   <LINK REL="Next"  HREF="001467.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6697 - in branches/caiinterface: .	AI/Interfaces AI/Interfaces/C AI/Skirmish AI/Skirmish/KAI	AI/Skirmish/KAIK AI/Skirmish/NullAI	AI/Skirmish/NullLegacyCppAI AI/Skirmish/RAI	AI/Skirmish/RAI/CodeBlocks AI/Skirmish/RAI/DevC	AI/Skirmish/RAI/VS2008 rts/ExternalAI rts/Game</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6697%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Interfaces%20AI/Interfaces/C%20AI/Skirmish%20AI/Skirmish/KAI%0A%09AI/Skirmish/KAIK%20AI/Skirmish/NullAI%0A%09AI/Skirmish/NullLegacyCppAI%20AI/Skirmish/RAI%0A%09AI/Skirmish/RAI/CodeBlocks%20AI/Skirmish/RAI/DevC%0A%09AI/Skirmish/RAI/VS2008%20rts/ExternalAI%20rts/Game&In-Reply-To=%3C20081013175706.494414730%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6697 - in branches/caiinterface: .	AI/Interfaces AI/Interfaces/C AI/Skirmish AI/Skirmish/KAI	AI/Skirmish/KAIK AI/Skirmish/NullAI	AI/Skirmish/NullLegacyCppAI AI/Skirmish/RAI	AI/Skirmish/RAI/CodeBlocks AI/Skirmish/RAI/DevC	AI/Skirmish/RAI/VS2008 rts/ExternalAI rts/Game">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon Oct 13 19:57:04 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001465.html">[Taspring-linux-commit] r6696 - trunk/rts
</A></li>
        <LI>Next message: <A HREF="001467.html">[Taspring-linux-commit] r6698 - in trunk/rts: Game System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1466">[ date ]</a>
              <a href="thread.html#1466">[ thread ]</a>
              <a href="subject.html#1466">[ subject ]</a>
              <a href="author.html#1466">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-10-13 19:57:00 +0200 (Mon, 13 Oct 2008)
New Revision: 6697

Added:
   branches/caiinterface/AI/Skirmish/KAI/
   branches/caiinterface/AI/Skirmish/KAI/VERSION
   branches/caiinterface/AI/Skirmish/KAIK/
   branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp
   branches/caiinterface/AI/Skirmish/KAIK/AIExport.h
   branches/caiinterface/AI/Skirmish/KAIK/VERSION
   branches/caiinterface/AI/Skirmish/RAI/
   branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp
   branches/caiinterface/AI/Skirmish/RAI/AIExport.h
   branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua
   branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua
   branches/caiinterface/AI/Skirmish/RAI/BasicArray.h
   branches/caiinterface/AI/Skirmish/RAI/Builder.cpp
   branches/caiinterface/AI/Skirmish/RAI/Builder.h
   branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.cpp
   branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.h
   branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/
   branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.cbp
   branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.workspace
   branches/caiinterface/AI/Skirmish/RAI/CombatManager.cpp
   branches/caiinterface/AI/Skirmish/RAI/CombatManager.h
   branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp
   branches/caiinterface/AI/Skirmish/RAI/DevC/
   branches/caiinterface/AI/Skirmish/RAI/DevC/RAI.dev
   branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp
   branches/caiinterface/AI/Skirmish/RAI/GResourceMap.h
   branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp
   branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.h
   branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp
   branches/caiinterface/AI/Skirmish/RAI/LogFile.h
   branches/caiinterface/AI/Skirmish/RAI/PowerManager.cpp
   branches/caiinterface/AI/Skirmish/RAI/PowerManager.h
   branches/caiinterface/AI/Skirmish/RAI/RAI.cpp
   branches/caiinterface/AI/Skirmish/RAI/RAI.h
   branches/caiinterface/AI/Skirmish/RAI/README
   branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.cpp
   branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.h
   branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.cpp
   branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.h
   branches/caiinterface/AI/Skirmish/RAI/UnitManager.cpp
   branches/caiinterface/AI/Skirmish/RAI/UnitManager.h
   branches/caiinterface/AI/Skirmish/RAI/VERSION
   branches/caiinterface/AI/Skirmish/RAI/VS2008/
   branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.sln
   branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.vcproj
Removed:
   branches/caiinterface/AI/Skirmish/KAI-0.2/
   branches/caiinterface/AI/Skirmish/KAIK-0.13/
   branches/caiinterface/AI/Skirmish/KAIK/AIExport.h
   branches/caiinterface/AI/Skirmish/KAIK/AIExports.cpp
   branches/caiinterface/AI/Skirmish/RAI-0.553/
Modified:
   branches/caiinterface/AI/Interfaces/C/Interface.cpp
   branches/caiinterface/AI/Interfaces/CMakeLists.txt
   branches/caiinterface/AI/Skirmish/CMakeLists.txt
   branches/caiinterface/AI/Skirmish/NullAI/VERSION
   branches/caiinterface/AI/Skirmish/NullLegacyCppAI/VERSION
   branches/caiinterface/CMakeLists.txt
   branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp
   branches/caiinterface/rts/Game/GameSetup.cpp
Log:
- renamed dir KAIK-0.13 to KAIK
- renamed dir KAI-0.2 to KAI
- renamed dir RAI-0.553 to RAI
- upgrading RAI with Reths source ot v0.601
- cleanup of CMake AI Interface and AI build scrips

Modified: branches/caiinterface/AI/Interfaces/C/Interface.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -308,6 +308,7 @@
 SharedLib* CInterface::LoadGroupAILib(const std::string&amp; libFilePath,
 		SGAILibrary* groupAILibrary) {
 	
+	simpleLog_log(&quot;LoadGroupAILib: %s&quot;, libFilePath);
 	SharedLib* sharedLib = SharedLib::Instantiate(libFilePath);
 	
 	if (sharedLib == NULL) {
@@ -317,6 +318,7 @@
 	// initialize the AI library
 	std::string funcName;
 	
+	simpleLog_log(&quot;getInfo...&quot;);
 	funcName = &quot;getInfo&quot;;
 	groupAILibrary-&gt;getInfo = (unsigned int (CALLING_CONV_FUNC_POINTER *)(InfoItem[], unsigned int max)) sharedLib-&gt;FindAddress(funcName.c_str());
 	if (groupAILibrary-&gt;getInfo == NULL) {
@@ -324,6 +326,7 @@
 		//reportInterfaceFunctionError(libFilePath, funcName);
 	}
 	
+	simpleLog_log(&quot;getLevelOfSupportFor...&quot;);
 	funcName = &quot;getLevelOfSupportFor&quot;;
 	groupAILibrary-&gt;getLevelOfSupportFor = (LevelOfSupport (CALLING_CONV_FUNC_POINTER *)(const char*, int, const char*, const char*)) sharedLib-&gt;FindAddress(funcName.c_str());
 	if (groupAILibrary-&gt;getLevelOfSupportFor == NULL) {
@@ -331,6 +334,7 @@
 		//reportInterfaceFunctionError(libFilePath, funcName);
 	}
 	
+	simpleLog_log(&quot;getOptions...&quot;);
 	funcName = &quot;getOptions&quot;;
 	groupAILibrary-&gt;getOptions = (unsigned int (CALLING_CONV_FUNC_POINTER *)(Option[], unsigned int max)) sharedLib-&gt;FindAddress(funcName.c_str());
 	if (groupAILibrary-&gt;getOptions == NULL) {
@@ -338,6 +342,7 @@
 		//reportInterfaceFunctionError(libFilePath, funcName);
 	}
 	
+	simpleLog_log(&quot;init...&quot;);
 	funcName = &quot;init&quot;;
 	groupAILibrary-&gt;init = (int (CALLING_CONV_FUNC_POINTER *)(int, int)) sharedLib-&gt;FindAddress(funcName.c_str());
 	if (groupAILibrary-&gt;init == NULL) {
@@ -346,6 +351,7 @@
 		//reportInterfaceFunctionError(libFilePath, funcName);
 	}
 	
+	simpleLog_log(&quot;release...&quot;);
 	funcName = &quot;release&quot;;
 	groupAILibrary-&gt;release = (int (CALLING_CONV_FUNC_POINTER *)(int, int)) sharedLib-&gt;FindAddress(funcName.c_str());
 	if (groupAILibrary-&gt;release == NULL) {
@@ -354,6 +360,7 @@
 		//reportInterfaceFunctionError(libFilePath, funcName);
 	}
 	
+	simpleLog_log(&quot;handleEvent...&quot;);
 	funcName = &quot;handleEvent&quot;;
 	groupAILibrary-&gt;handleEvent = (int (CALLING_CONV_FUNC_POINTER *)(int, int, int, const void*)) sharedLib-&gt;FindAddress(funcName.c_str());
 	if (groupAILibrary-&gt;handleEvent == NULL) {

Modified: branches/caiinterface/AI/Interfaces/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-10-13 17:57:00 UTC (rev 6697)
@@ -5,17 +5,30 @@
 #add_definitions(-DBUILDING_AI_INTERFACE -DSTREFLOP_X87)
 add_definitions(-DBUILDING_AI_INTERFACE)
 
-file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Interfaces/C/VERSION&quot; C_AIINTERFACE_VERSION LIMIT_COUNT 1)
-message(&quot;C AI Interface version is: ${C_AIINTERFACE_VERSION}&quot;)
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Interfaces/C cAIInterface)
-list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/SharedLib)
-if (UNIX)
-	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Linux/SoLib)
-else (UNIX)
-	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Win/DllLib)
-endif (UNIX)
-add_library(&quot;C-${C_AIINTERFACE_VERSION}&quot; MODULE ${cAIInterface} ${aienv}) # ${errorhandler})
-install (FILES &quot;${CMAKE_SOURCE_DIR}/AI/Interfaces/C/InterfaceInfo.lua&quot; DESTINATION &quot;${DATADIR}/AI/Interfaces/data/C-${C_AIINTERFACE_VERSION}&quot;)
+set(AI_INTERFACES_SRC &quot;${CMAKE_SOURCE_DIR}/AI/Interfaces&quot;)
+set(AI_INTERFACES_LIBS &quot;${DATADIR}/AI/Interfaces/impls&quot;)
+set(AI_INTERFACES_DATA &quot;${DATADIR}/AI/Interfaces/data&quot;)
 
-install (TARGETS &quot;C-${C_AIINTERFACE_VERSION}&quot; DESTINATION ${DATADIR}/AI/Interfaces/impls)
 
+# C &amp; C++ AI Interface
+set(C_AIINTERFACE_SRC &quot;${AI_INTERFACES_SRC}/C&quot;)
+if (EXISTS ${C_AIINTERFACE_SRC})
+	set(C_AIINTERFACE_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${C_AIINTERFACE_SRC}/VERSION)
+		file(STRINGS &quot;${C_AIINTERFACE_SRC}/VERSION&quot; C_AIINTERFACE_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${C_AIINTERFACE_SRC}/VERSION)
+	set(C_AIINTERFACE_TARGET &quot;C-${C_AIINTERFACE_VERS}&quot;)
+	message(&quot;${C_AIINTERFACE_VERS}\t(C AI Interface Version)&quot;)
+
+	aux_source_directory(${C_AIINTERFACE_SRC} cAIInterface)
+	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/SharedLib)
+	if (UNIX)
+		list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Linux/SoLib)
+	else (UNIX)
+		list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Win/DllLib)
+	endif (UNIX)
+	add_library(${C_AIINTERFACE_TARGET} MODULE ${cAIInterface} ${aienv}) # ${errorhandler})
+	install (FILES ${C_AIINTERFACE_SRC}/InterfaceInfo.lua DESTINATION ${AI_INTERFACES_DATA}/C/${C_AIINTERFACE_VERS})
+	install (TARGETS ${C_AIINTERFACE_TARGET} DESTINATION ${AI_INTERFACES_LIBS})
+endif (EXISTS ${C_AIINTERFACE_SRC})
+

Modified: branches/caiinterface/AI/Skirmish/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-10-13 17:57:00 UTC (rev 6697)
@@ -1,125 +1,167 @@
 ### Skirmish AIs
 add_definitions(-DBUILDING_AI)
 
+set(SKIRMISH_SRC &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish&quot;)
+set(SKIRMISH_LIBS &quot;${DATADIR}/AI/Skirmish/impls&quot;)
+set(SKIRMISH_DATA &quot;${DATADIR}/AI/Skirmish/data&quot;)
 
+
 ## KAI
-set(KAI_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAI/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/KAI/VERSION&quot; KAI_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAI/VERSION)
-message(&quot;${KAI_VERS}\t(KAI Version)&quot;)
+set(KAI_SRC &quot;${SKIRMISH_SRC}/KAI&quot;)
+if (EXISTS ${KAI_SRC})
+	set(KAI_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${KAI_SRC}/VERSION)
+		file(STRINGS &quot;${KAI_SRC}/VERSION&quot; KAI_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${KAI_SRC}/VERSION)
+	set(KAI_TARGET &quot;KAI-${KAI_VERS}&quot;)
+	message(&quot;${KAI_VERS}\t(KAI Version)&quot;)
 
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Skirmish/KAI-0.2 kai02)
-#add_library(KAI-${KAI_VERS} MODULE ${kai02} ${legacycppaienv} ${creg})
-#set_target_properties(KAI-${KAI_VERS} PROPERTIES COMPILE_FLAGS &quot;-DUSING_CREG&quot;)
+	aux_source_directory(${KAI_SRC} kai)
+	#add_library(${KAI_TARGET} MODULE ${kai} ${legacycppaienv} ${creg})
+	#install (FILES ${KAI_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/KAI/${KAI_VERS})
+	#install (FILES ${KAI_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/KAI/${KAI_VERS})
+	#set_target_properties(${KAI_TARGET} PROPERTIES COMPILE_FLAGS &quot;-DUSING_CREG&quot;)
+	#install (TARGETS ${KAI_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${KAI_SRC})
 
 
 ## KAIK
-set(KAIK_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/VERSION&quot; KAIK_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/VERSION)
-message(&quot;${KAIK_VERS}\t(KAIK Version)&quot;)
+set(KAIK_SRC &quot;${SKIRMISH_SRC}/KAIK&quot;)
+if (EXISTS ${KAIK_SRC})
+	set(KAIK_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${KAIK_SRC}/VERSION)
+		file(STRINGS &quot;${KAIK_SRC}/VERSION&quot; KAIK_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${KAIK_SRC}/VERSION)
+	set(KAIK_TARGET &quot;KAIK-${KAIK_VERS}&quot;)
+	message(&quot;${KAIK_VERS}\t(KAIK Version)&quot;)
 
-add_library(&quot;KAIK-${KAIK_VERS}&quot; MODULE ${kaik013} ${legacycppaienv} ${creg})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/KAIK-${KAIK_VERS})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/KAIK-${KAIK_VERS})
-set_target_properties(&quot;KAIK-${KAIK_VERS}&quot; PROPERTIES COMPILE_FLAGS &quot;-DUSING_CREG&quot;)
+	aux_source_directory(${KAIK_SRC} kaik)
+	add_library(${KAIK_TARGET} MODULE ${kaik} ${legacycppaienv} ${creg})
+	install (FILES ${KAIK_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/KAIK/${KAIK_VERS})
+	install (FILES ${KAIK_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/KAIK/${KAIK_VERS})
+	set_target_properties(${KAIK_TARGET} PROPERTIES COMPILE_FLAGS &quot;-DUSING_CREG&quot;)
+	install (TARGETS ${KAIK_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${KAIK_SRC})
 
 
 ## RAI
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553)
-set(RAI_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/VERSION&quot; RAI_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/VERSION)
-message(&quot;${RAI_VERS}\t(RAI Version)&quot;)
+set(RAI_SRC &quot;${SKIRMISH_SRC}/RAI&quot;)
+if (EXISTS ${RAI_SRC})
+	set(RAI_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${RAI_SRC}/VERSION)
+		file(STRINGS &quot;${RAI_SRC}/VERSION&quot; RAI_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${RAI_SRC}/VERSION)
+	set(RAI_TARGET &quot;RAI-${RAI_VERS}&quot;)
+	message(&quot;${RAI_VERS}\t(RAI Version)&quot;)
 
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553 rai)
-add_library(RAI-${RAI_VERS} MODULE ${rai} ${legacycppaienv} RAI-0.553/KrogsMetalClass/MetalMap)
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/RAI-${RAI_VERS})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/RAI-${RAI_VERS})
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553)
+	aux_source_directory(${RAI_SRC} rai)
+	add_library(${RAI_TARGET} MODULE ${rai} ${legacycppaienv})
+	install (FILES ${RAI_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/RAI/${RAI_VERS})
+	install (FILES ${RAI_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/RAI/${RAI_VERS})
+	install (TARGETS ${RAI_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${RAI_SRC})
 
 
 ## AAI
-set(AAI_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/AAI/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/AAI/VERSION&quot; AAI_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/AAI/VERSION)
-message(&quot;${AAI_VERS}\t(AAI Version)&quot;)
+set(AAI_SRC &quot;${SKIRMISH_SRC}/AAI&quot;)
+if (EXISTS ${AAI_SRC})
+	set(AAI_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${AAI_SRC}/VERSION)
+		file(STRINGS &quot;${AAI_SRC}/VERSION&quot; AAI_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${AAI_SRC}/VERSION)
+	set(AAI_TARGET &quot;AAI-${AAI_VERS}&quot;)
+	message(&quot;${AAI_VERS}\t(AAI Version)&quot;)
 
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Skirmish/AAI aai)
-#add_library(AAI-${AAI_VERS} MODULE ${aai} ${legacycppaienv})
-#install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/AAI/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/AAI-${AAI_VERS})
-#install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/AAI/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/AAI-${AAI_VERS})
+	aux_source_directory(${AAI_SRC} aai)
+	#add_library(${AAI_TARGET} MODULE ${aai} ${legacycppaienv})
+	#install (FILES ${AAI_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/AAI/${AAI_VERS})
+	#install (FILES ${AAI_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/AAI/${AAI_VERS})
+	#install (TARGETS ${AAI_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${AAI_SRC})
 
 
 ## NTai
-set(NTai_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/NTai/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/NTai/VERSION&quot; NTai_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/NTai/VERSION)
-message(&quot;${NTai_VERS}\t(NTai Version)&quot;)
+set(NTai_SRC &quot;${SKIRMISH_SRC}/NTai&quot;)
+if (EXISTS ${NTai_SRC})
+	set(NTai_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${NTai_SRC}/VERSION)
+		file(STRINGS &quot;${NTai_SRC}/VERSION&quot; NTai_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${NTai_SRC}/VERSION)
+	set(NTai_TARGET &quot;NTai-${NTai_VERS}&quot;)
+	message(&quot;${NTai_VERS}\t(NTai Version)&quot;)
 
-aux_source_directory(NTai/AI/NTai/Units ntai)
-aux_source_directory(NTai/AI/NTai/Units/Behaviours ntai)
-aux_source_directory(NTai/AI/NTai/Tasks ntai)
-aux_source_directory(NTai/AI/NTai/Helpers ntai)
-aux_source_directory(NTai/AI/NTai/Helpers/grid ntai)
-aux_source_directory(NTai/AI/NTai/Helpers/Terrain ntai)
-aux_source_directory(NTai/AI/NTai/Helpers/Units ntai)
-aux_source_directory(NTai/AI/NTai/Engine ntai)
-aux_source_directory(NTai/AI/NTai/Core ntai)
-aux_source_directory(NTai/AI/NTai/Agents ntai)
-#add_library(NTai SHARED ${ntai} ${legacycppaienv})
-#target_link_libraries(NTai-${NTai_VERS} boost_thread-mt)
-#install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NTai/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NTai-${NTai_VERS})
-#install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NTai/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NTai-${NTai_VERS})
+	aux_source_directory(${NTai_SRC} ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Units ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Units/Behaviours ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Tasks ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Helpers ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Helpers/grid ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Helpers/Terrain ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Helpers/Units ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Engine ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Core ntai)
+	aux_source_directory(${NTai_SRC}/AI/NTai/Agents ntai)
+	#add_library(${NTai_TARGET} MODULE ${ntai} ${legacycppaienv})
+	#target_link_libraries(${NTai_TARGET} boost_thread-mt)
+	#install (FILES ${NTai_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/NTai/${NTai_VERS})
+	#install (FILES ${NTai_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/NTai/${NTai_VERS})
+	#install (TARGETS ${NTai_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${NTai_SRC})
 
 
 ## Null Legacy C++ AI
-set(NullLegacyCppAI_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullLegacyCppAI/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/NullLegacyCppAI/VERSION&quot; NullLegacyCppAI_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullLegacyCppAI/VERSION)
-message(&quot;${NullLegacyCppAI_VERS}\t(NullLegacyCppAI Version)&quot;)
+set(NullLegacyCppAI_SRC &quot;${SKIRMISH_SRC}/NullLegacyCppAI&quot;)
+if (EXISTS ${NullLegacyCppAI_SRC})
+	set(NullLegacyCppAI_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${NullLegacyCppAI_SRC}/VERSION)
+		file(STRINGS &quot;${NullLegacyCppAI_SRC}/VERSION&quot; NullLegacyCppAI_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${NullLegacyCppAI_SRC}/VERSION)
+	set(NullLegacyCppAI_TARGET &quot;NullLegacyCppAI-${NullLegacyCppAI_VERS}&quot;)
+	message(&quot;${NullLegacyCppAI_VERS}\t(NullLegacyCppAI Version)&quot;)
 
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Skirmish/NullLegacyCppAI nullLegacyCppAI)
-add_library(NullLegacyCppAI-${NullLegacyCppAI_VERS} MODULE ${nullLegacyCppAI} ${legacycppaienv})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullLegacyCppAI/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NullLegacyCppAI-${NullLegacyCppAI_VERS})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullLegacyCppAI/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NullLegacyCppAI-${NullLegacyCppAI_VERS})
+	aux_source_directory(${NullLegacyCppAI_SRC} nulllegacycppai)
+	add_library(${NullLegacyCppAI_TARGET} MODULE ${nulllegacycppai} ${legacycppaienv})
+	install (FILES ${NullLegacyCppAI_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/NullLegacyCppAI/${NullLegacyCppAI_VERS})
+	install (FILES ${NullLegacyCppAI_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/NullLegacyCppAI/${NullLegacyCppAI_VERS})
+	install (TARGETS ${NullLegacyCppAI_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${NullLegacyCppAI_SRC})
 
 
 ## Null C AI
-set(NullAI_VERS &quot;UNKNOWN_VERSION&quot;)
-if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/VERSION)
-	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/VERSION&quot; NullAI_VERS LIMIT_COUNT 1)
-endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/VERSION)
-message(&quot;${NullAI_VERS}\t(NullAI Version)&quot;)
+set(NullAI_SRC &quot;${SKIRMISH_SRC}/NullAI&quot;)
+if (EXISTS ${NullAI_SRC})
+	set(NullAI_VERS &quot;UNKNOWN_VERSION&quot;)
+	if (EXISTS ${NullAI_SRC}/VERSION)
+		file(STRINGS &quot;${NullAI_SRC}/VERSION&quot; NullAI_VERS LIMIT_COUNT 1)
+	endif (EXISTS ${NullAI_SRC}/VERSION)
+	set(NullAI_TARGET &quot;NullAI-${NullAI_VERS}&quot;)
+	message(&quot;${NullAI_VERS}\t(NullAI Version)&quot;)
 
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI nullAI)
-add_library(NullAI-${NullAI_VERS} MODULE ${nullAI} ${aienv})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NullAI-${NullAI_VERS})
-install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NullAI-${NullAI_VERS})
+	aux_source_directory(${NullAI_SRC} nullai)
+	add_library(${NullAI_TARGET} MODULE ${mySrc} ${nullai})
+	install (FILES ${NullAI_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/NullAI/${NullAI_VERS})
+	install (FILES ${NullAI_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/NullAI/${NullAI_VERS})
+	install (TARGETS ${NullAI_TARGET} DESTINATION ${SKIRMISH_LIBS})
+endif (EXISTS ${NullAI_SRC})
 
+
 ## JCAI
+# does currently not build in win32
 if (UNIX)
-	# doesn't build in win32currently
-	set(JCAI_VERS &quot;UNKNOWN_VERSION&quot;)
-	if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/JCAI/VERSION)
-		file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/JCAI/VERSION&quot; JCAI_VERS LIMIT_COUNT 1)
-	endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/JCAI/VERSION)
-	message(&quot;${JCAI_VERS}\t(JCAI version)&quot;)
-	
-	aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Skirmish/JCAI jcai)
-#	add_library(JCAI-${JCAI_VERS} MODULE ${jcai} ${legacycppaienv})
+	set(JCAI_SRC &quot;${SKIRMISH_SRC}/JCAI&quot;)
+	if (EXISTS ${JCAI_SRC})
+		set(JCAI_VERS &quot;UNKNOWN_VERSION&quot;)
+		if (EXISTS ${JCAI_SRC}/VERSION)
+			file(STRINGS &quot;${JCAI_SRC}/VERSION&quot; JCAI_VERS LIMIT_COUNT 1)
+		endif (EXISTS ${JCAI_SRC}/VERSION)
+		set(JCAI_TARGET &quot;JCAI-${JCAI_VERS}&quot;)
+		message(&quot;${JCAI_VERS}\t(JCAI Version)&quot;)
+
+		aux_source_directory(${JCAI_SRC} jcai)
+		#add_library(${JCAI_TARGET} MODULE ${jcai} ${legacycppaienv})
+		#install (FILES ${JCAI_SRC}/AIInfo.lua DESTINATION ${SKIRMISH_DATA}/JCAI/${JCAI_VERS})
+		#install (FILES ${JCAI_SRC}/AIOptions.lua DESTINATION ${SKIRMISH_DATA}/JCAI/${JCAI_VERS})
+		#install (TARGETS ${JCAI_TARGET} DESTINATION ${SKIRMISH_LIBS})
+	endif (EXISTS ${JCAI_SRC})
 endif (UNIX)
 
-
-## Instal all AIs
-install (TARGETS KAIK-${KAIK_VERS} RAI-${RAI_VERS} NullLegacyCppAI-${NullLegacyCppAI_VERS} NullAI-${NullAI_VERS} DESTINATION ${DATADIR}/AI/Skirmish/impls)
-#install (TARGETS KAI-${KAI_VERS} AAI-${AAI_VERS} NTai-${NTai_VERS} DESTINATION ${DATADIR}/AI/Skirmish/impls)
-#if (UNIX)
-#	install (TARGETS JCAI-${JCAI_VERS} DESTINATION ${DATADIR}/AI/Skirmish/impls)
-#endif (UNIX)

Copied: branches/caiinterface/AI/Skirmish/KAI (from rev 6609, branches/caiinterface/AI/Skirmish/KAI-0.2)

Added: branches/caiinterface/AI/Skirmish/KAI/VERSION
===================================================================
--- branches/caiinterface/AI/Skirmish/KAI/VERSION	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAI/VERSION	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1 @@
+0.2
\ No newline at end of file


Property changes on: branches/caiinterface/AI/Skirmish/KAI/VERSION
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/KAIK (from rev 6609, branches/caiinterface/AI/Skirmish/KAIK-0.13)

Copied: branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp (from rev 6609, branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExports.cpp)
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,123 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#include &quot;AIExport.h&quot;
+
+#include &lt;map&gt;
+
+// AI interface stuff
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AI.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h&quot;
+
+// KAIK stuff
+#include &quot;GlobalAI.h&quot;
+
+
+std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
+std::vector&lt;InfoItem&gt; myInfos;
+
+
+Export(unsigned int) getInfos(InfoItem infos[], unsigned int max) {
+	
+	unsigned int i = 0;
+	
+	// initialize the myInfos
+	if (myInfos.empty()) {
+		InfoItem ii_0 = {SKIRMISH_AI_PROPERTY_SHORT_NAME, &quot;KAIK&quot;, NULL}; myInfos.push_back(ii_0);
+		InfoItem ii_1 = {SKIRMISH_AI_PROPERTY_VERSION, &quot;0.13&quot;, NULL}; myInfos.push_back(ii_1);
+		InfoItem ii_2 = {SKIRMISH_AI_PROPERTY_NAME, &quot;Kloots Skirmish AI&quot;, NULL}; myInfos.push_back(ii_2);
+		InfoItem ii_3 = {SKIRMISH_AI_PROPERTY_DESCRIPTION, &quot;This Skirmish AI supports most TA based mods and plays decently.&quot;, NULL}; myInfos.push_back(ii_3);
+		InfoItem ii_4 = {SKIRMISH_AI_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AI:KAIK">http://spring.clan-sy.com/wiki/AI:KAIK</A>&quot;, NULL}; myInfos.push_back(ii_4);
+		InfoItem ii_5 = {SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED, &quot;no&quot;, NULL}; myInfos.push_back(ii_5);
+	}
+	
+	// copy myInfos to the argument container infos
+	std::vector&lt;InfoItem&gt;::const_iterator inf;
+	for (inf=myInfos.begin(); inf!=myInfos.end() &amp;&amp; i &lt; max; inf++) {
+		infos[i] = *inf;
+		i++;
+	}
+
+	// return the number of elements copied to infos 
+	return i;
+}
+
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
+	
+	if (strcmp(engineVersionString, ENGINE_VERSION_STRING) == 0 &amp;&amp;
+			engineVersionNumber &lt;= ENGINE_VERSION_NUMBER) {
+		return LOS_Working;
+	}
+	
+	return LOS_None;
+}
+
+Export(unsigned int) getOptions(struct Option options[], unsigned int max) {
+	return 0;
+}
+
+Export(int) init(int teamId) {
+	
+    if (myAIs.count(teamId) &gt; 0) {
+		// the map already has an AI for this team.
+		// raise an error, since it's probably a mistake if we're trying
+		// to reinitialise a team that already had init() called on it.
+        return -1;
+    }
+	
+    // CAIGlobalAI is the Legacy C++ wrapper, CGlobalAI is KAIK
+    myAIs[teamId] = new CAIGlobalAI(teamId, new CGlobalAI());
+	
+	// signal: everything went ok
+	return 0;
+}
+
+Export(int) release(int teamId) {
+	
+    if (myAIs.count(teamId) == 0) {
+		// the map has no AI for this team.
+		// raise an error, since it's probably a mistake if we're trying to
+		// release a team that's not initialized.
+        return -1;
+    }
+	
+    delete myAIs[teamId];
+	myAIs.erase(teamId);
+	
+	// signal: everything went ok
+	return 0;
+}
+
+Export(int) handleEvent(int teamId, int topic, const void* data) {
+	
+    if (teamId &lt; 0) {
+		// events sent to team -1 will always be to the AI object itself,
+		// not to a particular team.
+	} else if (myAIs.count(teamId) &gt; 0) {
+        // allow the AI instance to handle the event.
+        return myAIs[teamId]-&gt;handleEvent(topic, data);
+	}
+	
+	// no AI for that team, so return error.
+	return -1;
+}


Property changes on: branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: branches/caiinterface/AI/Skirmish/KAIK/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h	2008-10-08 12:06:09 UTC (rev 6609)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIExport.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -1,54 +0,0 @@
-/*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-	
-	@author Nicolas Wu
-	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-*/
-
-#ifndef _AIEXPORT_H
-#define _AIEXPORT_H
-
-// check if build system uses correct defines
-#if	!defined BUILDING_AI
-	#error BUILDING_AI should be defined when building AIs
-#endif
-#if	defined BUILDING_AI_INTERFACE
-	#error BUILDING_AI_INTERFACE should not be defined when building AIs
-#endif
-
-#include &quot;ExternalAI/Interface/aidefines.h&quot;
-#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
-
-struct InfoItem;
-struct Option;
-
-// for a list of the functions that have to be exported,
-// see struct SSAILibrary in &quot;ExternalAI/Interface/SSAILibrary.h&quot;
-
-// static AI library methods (optional to implement)
-Export(unsigned int) getInfos(InfoItem infos[], unsigned int max);
-Export(enum LevelOfSupport) getLevelOfSupportFor(
-		const char* engineVersionString, int engineVersionNumber,
-		const char* aiInterfaceShortName, const char* aiInterfaceVersion);
-Export(unsigned int) getOptions(struct Option options[], unsigned int max);
-
-// team instance functions
-Export(int) init(int teamId);
-Export(int) release(int teamId);
-Export(int) handleEvent(int teamId, int topic, const void* data);
-
-#endif /* _AIEXPORT_H */
-

Copied: branches/caiinterface/AI/Skirmish/KAIK/AIExport.h (from rev 6665, branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h)
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIExport.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,55 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#ifndef _AIEXPORT_H
+#define _AIEXPORT_H
+
+// check if build system uses correct defines
+#if	!defined BUILDING_AI
+	#error BUILDING_AI should be defined when building AIs
+#endif
+#if	defined BUILDING_AI_INTERFACE
+	#error BUILDING_AI_INTERFACE should not be defined when building AIs
+#endif
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+
+struct InfoItem;
+struct Option;
+
+// for a list of the functions that have to be exported,
+// see struct SSAILibrary in &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+// static AI library methods (optional to implement)
+Export(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems);
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+Export(unsigned int) getOptions(struct Option options[],
+		unsigned int maxOptions);
+
+// team instance functions
+Export(int) init(int teamId);
+Export(int) release(int teamId);
+Export(int) handleEvent(int teamId, int topic, const void* data);
+
+#endif /* _AIEXPORT_H */
+

Deleted: branches/caiinterface/AI/Skirmish/KAIK/AIExports.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExports.cpp	2008-10-08 12:06:09 UTC (rev 6609)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIExports.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -1,123 +0,0 @@
-/*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-	
-	@author Nicolas Wu
-	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-*/
-
-#include &quot;AIExport.h&quot;
-
-#include &lt;map&gt;
-
-// AI interface stuff
-#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
-#include &quot;ExternalAI/Interface/LegacyCppWrapper/AI.h&quot;
-#include &quot;ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h&quot;
-
-// KAIK stuff
-#include &quot;GlobalAI.h&quot;
-
-
-std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
-std::vector&lt;InfoItem&gt; myInfos;
-
-
-Export(unsigned int) getInfos(InfoItem infos[], unsigned int max) {
-	
-	unsigned int i = 0;
-	
-	// initialize the myInfos
-	if (myInfos.empty()) {
-		InfoItem ii_0 = {SKIRMISH_AI_PROPERTY_SHORT_NAME, &quot;KAIK&quot;, NULL}; myInfos.push_back(ii_0);
-		InfoItem ii_1 = {SKIRMISH_AI_PROPERTY_VERSION, &quot;0.13&quot;, NULL}; myInfos.push_back(ii_1);
-		InfoItem ii_2 = {SKIRMISH_AI_PROPERTY_NAME, &quot;Kloots Skirmish AI&quot;, NULL}; myInfos.push_back(ii_2);
-		InfoItem ii_3 = {SKIRMISH_AI_PROPERTY_DESCRIPTION, &quot;This Skirmish AI supports most TA based mods and plays decently.&quot;, NULL}; myInfos.push_back(ii_3);
-		InfoItem ii_4 = {SKIRMISH_AI_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AI:KAIK">http://spring.clan-sy.com/wiki/AI:KAIK</A>&quot;, NULL}; myInfos.push_back(ii_4);
-		InfoItem ii_5 = {SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED, &quot;no&quot;, NULL}; myInfos.push_back(ii_5);
-	}
-	
-	// copy myInfos to the argument container infos
-	std::vector&lt;InfoItem&gt;::const_iterator inf;
-	for (inf=myInfos.begin(); inf!=myInfos.end() &amp;&amp; i &lt; max; inf++) {
-		infos[i] = *inf;
-		i++;
-	}
-
-	// return the number of elements copied to infos 
-	return i;
-}
-
-Export(enum LevelOfSupport) getLevelOfSupportFor(
-		const char* engineVersionString, int engineVersionNumber,
-		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
-	
-	if (strcmp(engineVersionString, ENGINE_VERSION_STRING) == 0 &amp;&amp;
-			engineVersionNumber &lt;= ENGINE_VERSION_NUMBER) {
-		return LOS_Working;
-	}
-	
-	return LOS_None;
-}
-
-Export(unsigned int) getOptions(struct Option options[], unsigned int max) {
-	return 0;
-}
-
-Export(int) init(int teamId) {
-	
-    if (myAIs.count(teamId) &gt; 0) {
-		// the map already has an AI for this team.
-		// raise an error, since it's probably a mistake if we're trying
-		// to reinitialise a team that already had init() called on it.
-        return -1;
-    }
-	
-    // CAIGlobalAI is the Legacy C++ wrapper, CGlobalAI is KAIK
-    myAIs[teamId] = new CAIGlobalAI(teamId, new CGlobalAI());
-	
-	// signal: everything went ok
-	return 0;
-}
-
-Export(int) release(int teamId) {
-	
-    if (myAIs.count(teamId) == 0) {
-		// the map has no AI for this team.
-		// raise an error, since it's probably a mistake if we're trying to
-		// release a team that's not initialized.
-        return -1;
-    }
-	
-    delete myAIs[teamId];
-	myAIs.erase(teamId);
-	
-	// signal: everything went ok
-	return 0;
-}
-
-Export(int) handleEvent(int teamId, int topic, const void* data) {
-	
-    if (teamId &lt; 0) {
-		// events sent to team -1 will always be to the AI object itself,
-		// not to a particular team.
-	} else if (myAIs.count(teamId) &gt; 0) {
-        // allow the AI instance to handle the event.
-        return myAIs[teamId]-&gt;handleEvent(topic, data);
-	}
-	
-	// no AI for that team, so return error.
-	return -1;
-}

Copied: branches/caiinterface/AI/Skirmish/KAIK/VERSION (from rev 6638, branches/caiinterface/AI/Skirmish/KAIK-0.13/VERSION)
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/VERSION	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK/VERSION	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1 @@
+0.13
\ No newline at end of file

Modified: branches/caiinterface/AI/Skirmish/NullAI/VERSION
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/VERSION	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/AI/Skirmish/NullAI/VERSION	2008-10-13 17:57:00 UTC (rev 6697)
@@ -1 +1 @@
-0.1
+0.1
\ No newline at end of file

Modified: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/VERSION
===================================================================
--- branches/caiinterface/AI/Skirmish/NullLegacyCppAI/VERSION	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/AI/Skirmish/NullLegacyCppAI/VERSION	2008-10-13 17:57:00 UTC (rev 6697)
@@ -1 +1 @@
-0.1
+0.1
\ No newline at end of file

Added: branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,137 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#include &quot;AIExport.h&quot;
+
+#include &lt;map&gt;
+
+// AI interface stuff
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AI.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h&quot;
+
+// RAI stuff
+#include &quot;RAI.h&quot;
+
+#define MY_SHORT_NAME &quot;RAI&quot;
+#define MY_VERSION &quot;0.601&quot;
+
+std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
+
+Export(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems) {
+
+	unsigned int i = 0;
+
+	if (i &lt; maxInfoItems) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_SHORT_NAME, MY_SHORT_NAME, NULL};
+		info[i] = ii;
+		i++;
+	}
+	if (i &lt; maxInfoItems) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_VERSION, MY_VERSION, NULL};
+		info[i] = ii;
+		i++;
+	}
+	if (i &lt; maxInfoItems) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_NAME, &quot;Reths Skirmish AI&quot;, NULL};
+		info[i] = ii;
+		i++;
+	}
+	if (i &lt; maxInfoItems) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_DESCRIPTION, &quot;This Skirmish AI supports most mods and plays decently.&quot;, NULL};
+		info[i] = ii;
+		i++;
+	}
+	if (i &lt; maxInfoItems) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AI:RAI">http://spring.clan-sy.com/wiki/AI:RAI</A>&quot;, NULL};
+		info[i] = ii;
+		i++;
+	}
+	if (i &lt; maxInfoItems) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED, &quot;no&quot;, NULL};
+		info[i] = ii;
+		i++;
+	}
+
+	// return the number of elements copied to info
+	return i;
+}
+
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
+
+	if (strcmp(engineVersionString, ENGINE_VERSION_STRING) == 0 &amp;&amp;
+			engineVersionNumber &lt;= ENGINE_VERSION_NUMBER) {
+		return LOS_Working;
+	}
+
+	return LOS_None;
+}
+
+Export(unsigned int) getOptions(struct Option options[], unsigned int max) {
+	return 0;
+}
+
+Export(int) init(int teamId) {
+
+	if (myAIs.count(teamId) &gt; 0) {
+		// the map already has an AI for this team.
+		// raise an error, since it's probably a mistake if we're trying
+		// to reinitialise a team that already had init() called on it.
+		return -1;
+	}
+
+	// CAIGlobalAI is the Legacy C++ wrapper, cRAI is RAI
+	myAIs[teamId] = new CAIGlobalAI(teamId, new cRAI());
+
+	// signal: everything went ok
+	return 0;
+}
+
+Export(int) release(int teamId) {
+
+	if (myAIs.count(teamId) == 0) {
+		// the map has no AI for this team.
+		// raise an error, since it's probably a mistake if we're trying to
+		// release a team that's not initialized.
+		return -1;
+	}
+
+	delete myAIs[teamId];
+	myAIs.erase(teamId);
+
+	// signal: everything went ok
+	return 0;
+}
+
+Export(int) handleEvent(int teamId, int topic, const void* data) {
+
+	if (teamId &lt; 0) {
+		// events sent to team -1 will always be to the AI object itself,
+		// not to a particular team.
+	} else if (myAIs.count(teamId) &gt; 0) {
+		// allow the AI instance to handle the event.
+		return myAIs[teamId]-&gt;handleEvent(topic, data);
+	}
+
+	// no AI for that team, so return error.
+	return -1;
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/AIExport.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,54 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#ifndef _AIEXPORT_H
+#define _AIEXPORT_H
+
+// check if build system uses correct defines
+#if	!defined BUILDING_AI
+	#error BUILDING_AI should be defined when building AIs
+#endif
+#if	defined BUILDING_AI_INTERFACE
+	#error BUILDING_AI_INTERFACE should not be defined when building AIs
+#endif
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+
+struct InfoItem;
+struct Option;
+
+// for a list of the functions that have to be exported,
+// see struct SSAILibrary in &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+// static AI library methods (optional to implement)
+Export(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems);
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+Export(unsigned int) getOptions(struct Option options[], unsigned int maxOptions);
+
+// team instance functions
+Export(int) init(int teamId);
+Export(int) release(int teamId);
+Export(int) handleEvent(int teamId, int topic, const void* data);
+
+#endif /* _AIEXPORT_H */
+


Property changes on: branches/caiinterface/AI/Skirmish/RAI/AIExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'RAI-0.601',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'RAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.601',
+	},
+	{
+		key    = 'name',
+		value  = 'Reths Skirmish AI (RAI)',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'Competetive AI that supports most Mods, also non TA ones.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:RAI">http://spring.clan-sy.com/wiki/AI:RAI</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/BasicArray.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/BasicArray.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/BasicArray.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,61 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_BASIC_ARRAY_H
+#define RAI_BASIC_ARRAY_H
+
+template &lt;typename basicArrayType&gt;
+
+struct basicArray
+{
+	basicArray()
+	{	elementList = 0;
+		elementSize = 0;
+	};
+	void setSize(const int &amp;size) { elementList = new basicArrayType[size]; };
+	basicArray(const int &amp;size)
+	{	elementList = new basicArrayType[size];
+		elementSize = 0;
+	};
+	~basicArray()
+	{	if( elementList != 0 )
+			delete [] elementList;
+	};
+	basicArrayType* operator[] (int index) { return &amp;elementList[index]; };
+	void begin() { elementIndex = -1; };
+	bool nextE(basicArrayType *&amp;nextElement)
+	{	elementIndex++;
+		if( elementIndex &gt;= elementSize )
+			return false;
+		nextElement = &amp;elementList[elementIndex];
+		return true;
+	};
+	bool nextE(basicArrayType &amp;nextElement)
+	{	elementIndex++;
+		if( elementIndex &gt;= elementSize )
+			return false;
+		nextElement = elementList[elementIndex];
+		return true;
+	};
+	basicArrayType* push_back() { return &amp;elementList[elementSize++]; };
+	void push_back(const basicArrayType &amp;element) { elementList[elementSize++] = element; };
+	void removeE() { elementList[elementIndex--] = elementList[--elementSize]; };
+	void removeE(const int &amp;index) { elementList[index] = elementList[--elementSize]; }
+	// use deleteE() instead of removeE() if using push_back(new *)
+	void deleteE() { delete elementList[elementIndex]; removeE(); }
+	void swap(const int &amp;index, const int &amp;index2)
+	{	basicArrayType temp = elementList[index];
+		elementList[index] = elementList[index2];
+		elementList[index2] = temp;
+	}
+
+	basicArrayType *elementList;
+	int elementIndex;	// essentially a built-in iterator
+	int size() { return elementSize; };
+	int elementSize;	// the amount of elements in use
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/BasicArray.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/Builder.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/Builder.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/Builder.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,1537 @@
+#include &quot;Builder.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//struct WeaponDef;
+//#include &lt;set&gt;
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+
+sBuildQuarry::sBuildQuarry(sRAIBuildList *buildlist)
+{
+	BL=buildlist;
+	if( BL != 0 )
+		BL-&gt;unitsActive++;
+	builderID=-1;
+	RS=0;
+	tryCount=0;
+};
+
+sBuildQuarry::~sBuildQuarry()
+{
+	if( BL != 0 )
+		BL-&gt;unitsActive--;
+};
+
+bool sBuildQuarry::IsValid(int frame)
+{
+	if( int(creationID.size()) == 0 &amp;&amp; builderID == -1 &amp;&amp; frame &gt;= deletionFrame )
+		return false;
+	return true;
+};
+
+void sBuildQuarry::SetRS(ResourceSiteExt* rs)
+{
+	if( RS != 0 )
+		RS-&gt;builderID=-1;
+	RS = rs;
+	if( RS != 0 )
+		RS-&gt;builderID=builderID;
+};
+// ------------------------------------------------------------------------------------------------
+
+cBuilder::cBuilder(IAICallback* callback, cRAI* global)
+{
+	cb = callback;
+	G = global;
+	UDR = G-&gt;UDH;
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR-&gt;UDR.begin(); iU!=UDR-&gt;UDR.end(); iU++ )
+		if( int(iU-&gt;second.ud-&gt;wreckName.size()) &gt; 0 )
+			UDRResurrect.insert(srPair(iU-&gt;second.ud-&gt;wreckName,&amp;iU-&gt;second));
+
+	l=G-&gt;l;
+	bInitiated=false;
+	LastBuildOrder=0;
+	BuilderIDDebug=0;
+	BuilderFrameDebug=0;
+	ConEnergyLost=0;
+	ConMetalLost=0;
+	ConEnergyDrain=0;
+	ConMetalDrain=0;
+	ConEnergyRate=0;
+	ConMetalRate=0;
+	ConEnergyStorage=0;
+	ConMetalStorage=0;
+
+	for( int i=0; i&lt;8; i++ )
+		BQSize[i]=0;
+	Prerequisite=0;
+
+	PM = new cPowerManager(cb,G);
+	BP = 0;
+}
+
+cBuilder::~cBuilder()
+{
+	if( RAIDEBUGGING )
+	{
+		*l&lt;&lt;&quot;\n cBuilder Debug:&quot;;
+		*l&lt;&lt;&quot;\n  clearing Build Quarry ...&quot;;
+	}
+	while( BQSize[0] &gt; 0 )
+		BQRemove(0);
+	if( RAIDEBUGGING )
+	{
+		*l&lt;&lt;&quot;\n  Builders Active      = &quot;&lt;&lt;int(UBuilder.size());
+		*l&lt;&lt;&quot;\n  Constructions Active = &quot;&lt;&lt;int(UConstruction.size());
+		*l&lt;&lt;&quot;\n  Metal Cost Limit     = &quot;&lt;&lt;MCostLimit;
+		*l&lt;&lt;&quot;\n  Energy Cost Limit    = &quot;&lt;&lt;ECostLimit;
+		*l&lt;&lt;&quot;\n  Const Energy Drain   = &quot;&lt;&lt;ConEnergyDrain;
+		*l&lt;&lt;&quot;\n  Const Metal Drain    = &quot;&lt;&lt;ConMetalDrain;
+		*l&lt;&lt;&quot;\n  Const Energy Rate    = &quot;&lt;&lt;ConEnergyRate;
+		*l&lt;&lt;&quot;\n  Const Metal Rate     = &quot;&lt;&lt;ConMetalRate;
+		*l&lt;&lt;&quot;\n  Const Energy Storage = &quot;&lt;&lt;ConEnergyStorage;
+		*l&lt;&lt;&quot;\n  Const Metal Storage  = &quot;&lt;&lt;ConMetalStorage;
+//		if( ConEnergyRate != 0 || ConMetalRate != 0 || ConEnergyStorage != 0 || ConMetalStorage != 0 )
+//			*l&lt;&lt;&quot;\n ERROR!&quot;;
+	}
+
+	if( BP != 0 )
+		delete BP;
+	delete PM;
+}
+
+void cBuilder::UnitCreated(const int&amp; unit, UnitInfo *U)
+{
+	if( BP == 0 )
+		BP = new cBuilderPlacement(cb,G);
+
+	// Attempts to identify which Build Quarry this new unit belongs to.
+	int iBQIndex=-1;
+	for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+	{
+		if(	BQ[iBQ]-&gt;creationUDID==U-&gt;ud-&gt;id &amp;&amp; BQ[iBQ]-&gt;builderID &gt; -1 &amp;&amp; G-&gt;ValidateUnit(BQ[iBQ]-&gt;builderID) &amp;&amp; int(cb-&gt;GetCurrentUnitCommands(BQ[iBQ]-&gt;builderID)-&gt;size())&gt;0 )
+		{
+			const Command *c=&amp;cb-&gt;GetCurrentUnitCommands(BQ[iBQ]-&gt;builderID)-&gt;front();
+			if( c-&gt;id == -U-&gt;ud-&gt;id )
+			{
+				if( int(c-&gt;params.size()) &gt;= 3 ) // (0.73b1): for some reason human issued build commands do not have params
+				{
+					float fx = cb-&gt;GetUnitPos(unit).x - c-&gt;params.at(0);
+					float fz = cb-&gt;GetUnitPos(unit).z - c-&gt;params.at(2);
+					float fx2 = cb-&gt;GetUnitPos(unit).x - cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).x;
+					float fz2 = cb-&gt;GetUnitPos(unit).z - cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).z;
+					float fMarginOfError=BQ[iBQ]-&gt;builderUI-&gt;ud-&gt;buildDistance + 50;
+					if( fMarginOfError &lt; 300 )
+						fMarginOfError = 300;
+
+					// The margin of error in position can be quite large, the size of units can distort their intended build positions
+					// Thus constructors, which are set to build at a certain position, can build at a distance that even exceeds their build distance (or at least, that is what these variables have told me during testing)
+					if( (fx &lt; fMarginOfError &amp;&amp; fx &gt; -fMarginOfError &amp;&amp; fz &lt; fMarginOfError &amp;&amp; fz &gt; -fMarginOfError) ||
+						(fx2 &lt; fMarginOfError &amp;&amp; fx2 &gt; -fMarginOfError &amp;&amp; fz2 &lt; fMarginOfError &amp;&amp; fz2 &gt; -fMarginOfError) )
+					{
+//						*l&lt;&lt;&quot;\n\nUnit position:  x=&quot;&lt;&lt;cb-&gt;GetUnitPos(unit).x&lt;&lt;&quot; z=&quot;&lt;&lt;cb-&gt;GetUnitPos(unit).z;
+//						*l&lt;&lt;&quot;\nBuilder position: x=&quot;&lt;&lt;cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).x&lt;&lt;&quot; z=&quot;&lt;&lt;cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID).z;
+//						*l&lt;&lt;&quot;\nBOrder position:  x=&quot;&lt;&lt;c-&gt;params.at(0)&lt;&lt;&quot; z=&quot;&lt;&lt;c-&gt;params.at(2);
+//						*l&lt;&lt;&quot;\nMarginOfError: &quot;&lt;&lt;fMarginOfError&lt;&lt;&quot;\n\n&quot;;
+						if( iBQIndex &gt; -1 ) // It found more than 1 possible Build Quarry match
+						{
+							if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nWARNING: Creation Def Conflict, code needs works&quot;;
+						}
+						iBQIndex=iBQ;
+					}
+				}
+			}
+		}
+	}
+	int humanCreated=-1;
+	if( iBQIndex == -1 ) // This is a bit more thorough check for a human builder
+	{
+		G-&gt;ValidateAllUnits();
+		for(map&lt;int,UnitInfo&gt;::iterator iU=G-&gt;Units.begin(); iU!=G-&gt;Units.end(); iU++)
+		{
+			if(	cb-&gt;GetCurrentUnitCommands(iU-&gt;first)-&gt;size() &gt; 0 )
+			{
+				const Command *c=&amp;cb-&gt;GetCurrentUnitCommands(iU-&gt;first)-&gt;front();
+				if( c-&gt;id == -U-&gt;ud-&gt;id &amp;&amp; int(c-&gt;params.size()) == 0 )
+				{
+					float fx2 = cb-&gt;GetUnitPos(unit).x - cb-&gt;GetUnitPos(iU-&gt;first).x;
+					float fz2 = cb-&gt;GetUnitPos(unit).z - cb-&gt;GetUnitPos(iU-&gt;first).z;
+					float fMarginOfError=iU-&gt;second.ud-&gt;buildDistance + 150;
+					if( fMarginOfError &lt; 300 )
+						fMarginOfError = 300;
+
+					if( fx2 &lt; fMarginOfError &amp;&amp; fx2 &gt; -fMarginOfError &amp;&amp; fz2 &lt; fMarginOfError &amp;&amp; fz2 &gt; -fMarginOfError )
+					{
+						humanCreated = iU-&gt;first;
+					}
+				}
+			}
+		}
+	}
+	if( iBQIndex &gt;= 0 )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;(b=&quot;&lt;&lt;BQ[iBQIndex]-&gt;builderID&lt;&lt;&quot;)&quot;;
+		typedef pair&lt;int,UnitConstructionInfo&gt; iuPair;
+		UConstruction.insert(iuPair(unit,UnitConstructionInfo(BQ[iBQIndex],unit,U)));
+		U-&gt;AIDisabled=false;
+	}
+	else if( humanCreated &gt;= 0 &amp;&amp; (U-&gt;ud-&gt;speed &gt; 0 || int(U-&gt;udr-&gt;BuildOptions.size()) == 0) )
+	{
+		U-&gt;AIDisabled = true;
+	}
+	else
+	{
+		// This case can occur 4 ways: 1) starting units 2) resurrected units 3) RAI failed to identify it's builder 4) factory built by human player
+		U-&gt;AIDisabled = false;
+	}
+	if( !U-&gt;AIDisabled )
+		U-&gt;udr-&gt;UnitConstructsActive.insert(unit);
+}
+
+void cBuilder::UnitFinished(const int&amp; unit, UnitInfo *U)
+{
+	if( bInitiated &amp;&amp; UConstruction.find(unit) != UConstruction.end() )
+	{
+		UnitConstructionInfo *pUCQ=&amp;UConstruction.find(unit)-&gt;second;
+		if( pUCQ-&gt;BQAbandoned )
+		{
+			UConstruction.erase(unit); // Remove from list of units being built
+		}
+		else
+		{
+			if( int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) == 0 &amp;&amp; UBuilder.find(pUCQ-&gt;BQ-&gt;builderID) != UBuilder.end() )
+			{
+				if( pUCQ-&gt;BQ-&gt;builderUI-&gt;ud-&gt;speed == 0 )
+				{
+					Command c;
+					c.id=CMD_MOVE;
+					float3 fPos=cb-&gt;GetUnitPos(unit);
+					fPos.x+=-100+rand()%201;
+					if( cb-&gt;GetBuildingFacing(pUCQ-&gt;BQ-&gt;builderID) == 2 )
+						fPos.z-=150+rand()%201;
+					else
+						fPos.z+=150+rand()%201;
+					fPos.y=cb-&gt;GetElevation(fPos.x,fPos.z);
+					c.params.push_back(fPos.x);
+					c.params.push_back(fPos.y);
+					c.params.push_back(fPos.z);
+					cb-&gt;GiveOrder(unit,&amp;c);
+					G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+150,unit,U);
+				}
+			}
+			if( RAIDEBUGGING ) *l&lt;&lt;&quot;(b=&quot;&lt;&lt;pUCQ-&gt;BQ-&gt;builderID&lt;&lt;&quot;)&quot;;
+			BQRemove(pUCQ-&gt;BQ-&gt;index); // Remove from global build instructions
+		}
+	}
+	U-&gt;udr-&gt;UnitsActive.insert(unit);
+	U-&gt;udr-&gt;UnitConstructsActive.erase(unit);
+	UnitAssignBuildList(unit,U);
+	U-&gt;udr-&gt;CheckUnitLimit();
+	U-&gt;udr-&gt;CheckBuildOptions();
+	if( U-&gt;ud-&gt;speed == 0 )
+	{
+		for(map&lt;int,UnitInfo*&gt;::iterator i=UNanos.begin(); i!=UNanos.end(); i++ )
+		{
+			if( cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; i-&gt;second-&gt;ud-&gt;buildDistance )
+			{
+				i-&gt;second-&gt;UGuarding.insert(cRAI::iupPair(unit,U));
+				U-&gt;UGuards.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+//				if( U-&gt;pBOL != 0 &amp;&amp; U-&gt;udrBL-&gt;task == TASK_CONSTRUCT &amp;&amp; int(U-&gt;udr-&gt;BuildOptions.size()) &gt; 0 )
+//					i-&gt;second-&gt;UAssist.insert(cRAI::iupPair(unit,U));
+			}
+		}
+		if( U-&gt;udr-&gt;IsNano() )
+		{
+			UNanos.insert(cRAI::iupPair(unit,U));
+			for(map&lt;int,UnitInfo*&gt;::iterator i=G-&gt;UImmobile.begin(); i!=G-&gt;UImmobile.end(); i++ )
+			{
+				if( i-&gt;first != unit &amp;&amp; !i-&gt;second-&gt;unitBeingBuilt &amp;&amp; cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; U-&gt;ud-&gt;buildDistance )
+				{
+					U-&gt;UGuarding.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+					i-&gt;second-&gt;UGuards.insert(cRAI::iupPair(unit,U));
+//					if( i-&gt;second-&gt;udrBL-&gt;task == TASK_CONSTRUCT &amp;&amp; int(i-&gt;second-&gt;udr-&gt;BuildOptions.size()) &gt; 0 )
+//						U-&gt;UAssist.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				}
+			}
+		}
+	}
+}
+
+void cBuilder::UnitDestroyed(const int&amp; unit, UnitInfo* U)
+{
+	if( U-&gt;unitBeingBuilt )
+	{
+		if( UConstruction.find(unit) != UConstruction.end() )
+		{
+			if( !UConstruction.find(unit)-&gt;second.BQAbandoned )
+			{
+				UConstruction.find(unit)-&gt;second.BQ-&gt;creationID.remove(unit);
+			}
+			UConstruction.erase(unit);
+		}
+		U-&gt;udr-&gt;UnitConstructsActive.erase(unit);
+	}
+	else
+	{
+		U-&gt;udr-&gt;UnitsActive.erase(unit);
+		U-&gt;udrBL-&gt;RBL-&gt;unitsActive--;
+		U-&gt;udr-&gt;CheckUnitLimit();
+		U-&gt;udr-&gt;CheckBuildOptions();
+		if( U-&gt;ud-&gt;speed == 0 )
+		{
+			if( U-&gt;udr-&gt;IsNano() )
+			{
+				UNanos.erase(unit);
+				for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UGuarding.begin(); i!=U-&gt;UGuarding.end(); i++ )
+					i-&gt;second-&gt;UGuards.erase(unit);
+			}
+			for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UGuards.begin(); i!=U-&gt;UGuards.end(); i++ )
+			{
+				i-&gt;second-&gt;UGuarding.erase(unit);
+//				i-&gt;second-&gt;UAssist.erase(unit);
+			}
+		}
+	}
+}
+
+void cBuilder::UnitAssignBuildList(const int&amp; unit, UnitInfo *U, bool bInitialized)
+{
+	if( bInitialized )
+		U-&gt;udrBL-&gt;RBL-&gt;unitsActive--;
+	float fBestV=-1;	// Value
+	int iBestI=-1;		// Index
+	for(int i=0; i&lt;U-&gt;udr-&gt;ListSize; i++ )
+	{
+		sRAIBuildList* BL=U-&gt;udr-&gt;List[i]-&gt;RBL;
+		if( BL-&gt;unitsActive &lt; BL-&gt;minUnits &amp;&amp; (iBestI == -1 || U-&gt;udr-&gt;List[iBestI]-&gt;RBL-&gt;minUnits == 0 || float(BL-&gt;unitsActive)/float(BL-&gt;minUnits) &lt; fBestV) )
+		{
+			iBestI = i;
+			fBestV = float(BL-&gt;unitsActive)/float(BL-&gt;minUnits);
+		}
+		else if( fBestV == -1 || ( BL-&gt;priority &gt; 0 &amp;&amp; U-&gt;udr-&gt;List[iBestI]-&gt;RBL-&gt;unitsActive &gt;= U-&gt;udr-&gt;List[iBestI]-&gt;RBL-&gt;minUnits &amp;&amp; float(1+BL-&gt;unitsActive)/float(BL-&gt;priority) &lt; fBestV ) )
+		{
+			iBestI = i;
+			fBestV = float(1+BL-&gt;unitsActive)/float(BL-&gt;priority);
+		}
+	}
+
+	if( iBestI == -1 )
+	{
+		cb-&gt;SendTextMsg(&quot;unknown unit type in use&quot;,0);
+		*l&lt;&lt;&quot;\n\nWARNING: unknown unit type in use: (&quot;&lt;&lt;U-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;U-&gt;ud-&gt;humanName;
+		U-&gt;udr-&gt;UnitsActive.erase(unit);
+		U-&gt;AIDisabled = true;
+		return;
+	}
+	U-&gt;udrBL=U-&gt;udr-&gt;List[iBestI];
+	U-&gt;udrBL-&gt;RBL-&gt;unitsActive++;
+}
+
+void cBuilder::UBuilderFinished(const int&amp; unit, UnitInfo *U)
+{
+	UBuilder.insert(cRAI::iupPair(unit,U));
+	if( int(U-&gt;udr-&gt;UnitsActive.size()) == 1 )
+		UpdateUDRCost();
+}
+
+void cBuilder::UBuilderDestroyed(const int&amp; unit, UnitInfo *U)
+{
+	if( U-&gt;BuildQ != 0 )
+		BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0);
+
+	UBuilder.erase(unit);
+	if( int(U-&gt;udr-&gt;UnitsActive.size()) == 0 )
+		UpdateUDRCost();
+}
+
+void cBuilder::UBuilderIdle(const int&amp; unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; UBuilderIdle:&quot;;
+	int iFrame = cb-&gt;GetCurrentFrame();
+	float OnOffPower = -PM-&gt;OffEnergyDifference;
+	if( OnOffPower &gt; 0.25*cb-&gt;GetEnergyIncome() )
+		OnOffPower = 0.25*cb-&gt;GetEnergyIncome();
+	float fWeaponPower = -PM-&gt;WeaponEnergyNeeded;
+	if( fWeaponPower &gt; 0.25*cb-&gt;GetEnergyIncome() )
+		fWeaponPower = 0.25*cb-&gt;GetEnergyIncome();
+	float MRatio;
+	if( cb-&gt;GetMetalIncome() == 0 || cb-&gt;GetMetalUsage() == 0 )
+		MRatio=1;
+	else
+		MRatio=0.5*(cb-&gt;GetMetalUsage()/cb-&gt;GetMetalIncome());
+	float ERatio;
+	if( cb-&gt;GetEnergyIncome() == 0 || cb-&gt;GetEnergyUsage() == 0 )
+		ERatio=1;
+	else
+		ERatio=0.5*(cb-&gt;GetEnergyUsage()/cb-&gt;GetEnergyIncome());
+	float MetalRate=cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage()+PM-&gt;EtoMIncome+0.75*ConMetalRate;
+	float EnergyRate=cb-&gt;GetEnergyIncome()-cb-&gt;GetEnergyUsage()-OnOffPower-fWeaponPower+0.75*ConEnergyRate;
+
+	// This is a small attempt to correct the values reported by callback, however having this makes a big difference when the commander is building it's first few units
+	if( BuilderFrameDebug+30 &gt;= cb-&gt;GetCurrentFrame() &amp;&amp; G-&gt;Units.find(BuilderIDDebug) != G-&gt;Units.end() &amp;&amp; G-&gt;ValidateUnit(BuilderIDDebug) )
+	{
+//		*l&lt;&lt;&quot;\n\n CF:&quot;&lt;&lt;cb-&gt;GetCurrentFrame()&lt;&lt;&quot; DF:&quot;&lt;&lt;BuilderFrameDebug&lt;&lt;&quot; Dif:&quot;&lt;&lt;cb-&gt;GetCurrentFrame()- BuilderFrameDebug;
+		UnitInfo *B = &amp;G-&gt;Units.find(BuilderIDDebug)-&gt;second;
+		UnitResourceInfo URI;
+		cb-&gt;GetUnitResourceInfo(BuilderIDDebug,&amp;URI);
+		BuilderEnergyDebug = URI.energyUse;
+		BuilderMetalDebug = URI.metalUse;
+		if( B-&gt;ud-&gt;onoffable &amp;&amp; cb-&gt;IsUnitActivated(BuilderIDDebug) )
+		{
+			BuilderEnergyDebug -= B-&gt;ud-&gt;energyUpkeep;
+			BuilderMetalDebug -= B-&gt;ud-&gt;metalUpkeep;
+		}
+		if( B-&gt;ud-&gt;canCloak &amp;&amp; cb-&gt;IsUnitCloaked(BuilderIDDebug) )
+			BuilderEnergyDebug += B-&gt;udr-&gt;CloakMaxEnergyDifference;
+		// Testing on Spring-Version(0.76b1) XTA V9.44 has shown GetUnitResourceInfo to be about 90%-100% accurate depending on the frame
+//		*l&lt;&lt;&quot;\n Metal/Energy Usage: &quot;&lt;&lt;cb-&gt;GetMetalUsage()&lt;&lt;&quot;/&quot;&lt;&lt;cb-&gt;GetEnergyUsage();
+//		*l&lt;&lt;&quot;\n Debugging Metal/Energy Rates: &quot;&lt;&lt;BuilderMetalDebug&lt;&lt;&quot;/&quot;&lt;&lt;BuilderEnergyDebug;
+		MetalRate+=BuilderMetalDebug;
+		EnergyRate+=BuilderEnergyDebug;
+	}
+	else
+	{
+		BuilderMetalDebug=0;
+		BuilderEnergyDebug=0;
+	}
+	Command c;
+	bool HaveOrders;
+	if( U-&gt;BuildQ != 0 )
+	{
+		if( int(U-&gt;BuildQ-&gt;creationID.size())&gt;0 &amp;&amp; cb-&gt;GetUnitHealth(U-&gt;BuildQ-&gt;creationID.front()) &lt;= 0 )
+			U-&gt;BuildQ-&gt;creationID.pop_front();
+		if( int(U-&gt;BuildQ-&gt;creationID.size()) == 0 )
+			U-&gt;BuildQ-&gt;tryCount++;
+
+		if( !U-&gt;BuildQ-&gt;IsValid(iFrame) || U-&gt;BuildQ-&gt;tryCount &gt; 4 )
+		{
+			BQRemove(U-&gt;BuildQ-&gt;index);
+			HaveOrders=false;
+		}
+		else
+		{
+			c.id=-U-&gt;BuildQ-&gt;creationUDID;
+			HaveOrders=true;
+		}
+	}
+	else
+		HaveOrders=false;
+	if( !HaveOrders &amp;&amp; int(U-&gt;udr-&gt;BuildOptions.size()) &gt; 0 )
+	{
+		for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++) // Checking old build orders
+		{
+			if( !BQ[iBQ]-&gt;IsValid(iFrame) || 
+				(iFrame &gt; BQ[iBQ]-&gt;deletionFrame+5400 &amp;&amp; // 5400f = 3mins
+				 int(BQ[iBQ]-&gt;creationID.size()) &gt; 0 &amp;&amp;
+				 cb-&gt;GetUnitHealth(BQ[iBQ]-&gt;creationID.front()) &lt; 0.02*cb-&gt;GetUnitMaxHealth(BQ[iBQ]-&gt;creationID.front()) ) )
+			{
+				if( BQ[iBQ]-&gt;builderID &gt; -1 )
+					G-&gt;UpdateEventAdd(1,0,BQ[iBQ]-&gt;builderID,BQ[iBQ]-&gt;builderUI);
+				BQRemove(iBQ--);
+			}
+		}
+		if( BQSize[0] &lt; 30 &amp;&amp; BQSize[0] &lt; int(UBuilder.size())+1 &amp;&amp; UDR-&gt;BLActive &gt; 0 )
+		{
+			G-&gt;ValidateUnitList(&amp;UBuilder);
+			BP-&gt;CheckBlockedRList();
+			if( UDR-&gt;RBMobile.size() &gt; 0 )
+			{
+				float3 position = cb-&gt;GetUnitPos(unit);
+				G-&gt;CorrectPosition(position);
+				int iS = G-&gt;TM-&gt;GetSectorIndex(position);
+				set&lt;TerrainMapMobileType*&gt; deletion;
+				for(set&lt;TerrainMapMobileType*&gt;::iterator iM=UDR-&gt;RBMobile.begin(); iM!=UDR-&gt;RBMobile.end(); iM++)
+					if( G-&gt;TM-&gt;GetAlternativeSector(U-&gt;area,iS,*iM)-&gt;S-&gt;position.distance2D(G-&gt;TM-&gt;sector[iS].position) &lt; 700.0 )
+						deletion.insert(*iM);
+				while( deletion.size() &gt; 0 )
+				{
+					UDR-&gt;RBMobile.erase(*deletion.begin());
+					deletion.erase(*deletion.begin());
+				}
+			}
+			if( UDR-&gt;RBImmobile.size() &gt; 0 )
+			{
+				float3 position = cb-&gt;GetUnitPos(unit);
+				G-&gt;CorrectPosition(position);
+				int iS = G-&gt;TM-&gt;GetSectorIndex(position);
+				set&lt;TerrainMapImmobileType*&gt; deletion;
+				for(set&lt;TerrainMapImmobileType*&gt;::iterator iM=UDR-&gt;RBImmobile.begin(); iM!=UDR-&gt;RBImmobile.end(); iM++)
+					if( G-&gt;TM-&gt;GetClosestSector(*iM,iS)-&gt;position.distance2D(G-&gt;TM-&gt;sector[iS].position) &lt; 700.0 )
+						deletion.insert(*iM);
+				while( deletion.size() &gt; 0 )
+				{
+					UDR-&gt;RBImmobile.erase(*deletion.begin());
+					deletion.erase(*deletion.begin());
+				}
+			}
+			for(int i=0; i&lt;UDR-&gt;BLSize; i++ )
+				UDR-&gt;BL[i]-&gt;UDefActiveTemp = UDR-&gt;BL[i]-&gt;UDefActive;
+			for(int i=0; i&lt;UDR-&gt;BLActive; i++ )
+			{	// If a list is unimportant, then make sure this list can build something that already has a prerequisite
+				if( UDR-&gt;BL[i]-&gt;minUnits == 0 )
+					for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+						if( !UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;HasPrerequisite )
+							UDR-&gt;BL[i]-&gt;UDefSwitch(iud,--UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+				// Restrict unit types that would require moving too far away
+				if( UDR-&gt;RBMobile.size() &gt; 0 )
+					for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+						if( UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;mobileType != 0 &amp;&amp; UDR-&gt;RBMobile.find(UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;mobileType) != UDR-&gt;RBMobile.end() )
+							UDR-&gt;BL[i]-&gt;UDefSwitch(iud,--UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+				if( UDR-&gt;RBImmobile.size() &gt; 0 )
+					for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+						if( UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;immobileType != 0 )
+							if( UDR-&gt;RBImmobile.find(UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;immobileType) != UDR-&gt;RBImmobile.end() ||
+								(UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;mobileType != 0 &amp;&amp; UDR-&gt;RBMobile.find(UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;mobileType) != UDR-&gt;RBMobile.end()) )
+								UDR-&gt;BL[i]-&gt;UDefSwitch(iud,--UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+				// make sure the first few extractors are built at the closest Metal-Sites available by restricting the wrong types
+				if( UDR-&gt;BL[i] == UDR-&gt;BLMetalL &amp;&amp; UDR-&gt;BL[i]-&gt;unitsActive &lt; UDR-&gt;BL[i]-&gt;minUnits )
+				{
+					float3 Pos = cb-&gt;GetUnitPos(unit);
+					set&lt;int&gt; best;
+					ResourceSiteExt* RSbest;
+					for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+					{
+						ResourceSiteExt* RS = BP-&gt;FindResourceSite(Pos,UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;ud,U-&gt;area);
+						if( RS != 0 )
+						{
+							if( int(best.size()) == 0 || RS == RSbest )
+							{
+								best.insert(iud);
+								RSbest = RS;
+							}
+							else if( Pos.distance2D(RS-&gt;S-&gt;position) &lt; Pos.distance2D(RSbest-&gt;S-&gt;position) )
+							{
+								best.clear();
+								best.insert(iud);
+								RSbest = RS;
+							}
+						}
+					}
+					if( int(best.size()) &gt; 0 )
+						for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+							if( best.find(iud) == best.end() )
+							{
+								UDR-&gt;BL[i]-&gt;UDefActiveTemp--;
+								UDR-&gt;BL[i]-&gt;UDefSwitch(iud,UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+							}
+				}
+			}
+		}
+		while( BQSize[0] &lt; 30 &amp;&amp; BQSize[0] &lt; int(UBuilder.size())+1 &amp;&amp; UDR-&gt;BLActive &gt; 0 )
+		{
+//			*l&lt;&lt;&quot;\n\n(NBO)&quot;; if( Prerequisite != 0 ) *l&lt;&lt;&quot;(Prerequisite: &quot;&lt;&lt;Prerequisite-&gt;creationUD-&gt;ud-&gt;humanName&lt;&lt;&quot;) &quot;;
+			CreateBuildOrders();// UNFINISHED
+			float fBestV=-1;	// Value
+			int iBestI=-1;		// Index
+			for(int i=0; i&lt;UDR-&gt;BLActive; i++ )
+			{	// If a prerequisite is being built, then make sure this list can build something that already has a prerequisite
+				if( Prerequisite != 0 )
+					for( int iud=UDR-&gt;BL[i]-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+						if( !UDR-&gt;BL[i]-&gt;UDef[iud]-&gt;RUD-&gt;HasPrerequisite )
+							UDR-&gt;BL[i]-&gt;UDefSwitch(iud,--UDR-&gt;BL[i]-&gt;UDefActiveTemp);
+//				*l&lt;&lt;&quot;\n&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;Name&lt;&lt;&quot; Build-List &quot;&lt;&lt;UDR-&gt;BL[i]-&gt;unitsActive&lt;&lt;&quot;/&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;priority&lt;&lt;&quot;: Min=&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;minUnits&lt;&lt;&quot; UDefActiveTemp=&quot;&lt;&lt;UDR-&gt;BL[i]-&gt;UDefActiveTemp;
+				if( UDR-&gt;BL[i]-&gt;UDefActiveTemp &gt; 0 )
+				{
+					if( UDR-&gt;BL[i]-&gt;unitsActive &lt; UDR-&gt;BL[i]-&gt;minUnits &amp;&amp; (fBestV&lt;0 || UDR-&gt;BL[iBestI]-&gt;minUnits == 0 || float(UDR-&gt;BL[i]-&gt;unitsActive)/float(UDR-&gt;BL[i]-&gt;minUnits) &lt; fBestV) )
+					{
+						iBestI = i;
+						fBestV = float(UDR-&gt;BL[iBestI]-&gt;unitsActive)/float(UDR-&gt;BL[iBestI]-&gt;minUnits);
+					}
+					else if( fBestV&lt;0 || (UDR-&gt;BL[i]-&gt;priority &gt; 0 &amp;&amp; UDR-&gt;BL[iBestI]-&gt;unitsActive &gt;= UDR-&gt;BL[iBestI]-&gt;minUnits &amp;&amp; float(1+UDR-&gt;BL[i]-&gt;unitsActive)/float(UDR-&gt;BL[i]-&gt;priority) &lt; fBestV ) )
+					{
+						iBestI = i;
+						fBestV = float(1+UDR-&gt;BL[i]-&gt;unitsActive)/float(UDR-&gt;BL[i]-&gt;priority);
+					}
+				}
+			}
+			if( iBestI == -1 ) // ? hopefully won't ever happen again
+			{
+				cb-&gt;SendTextMsg(&quot;ERROR: No Build-List Choice Available.&quot;,5);
+				*l&lt;&lt;&quot;\n\nERROR: No Build-List Choice Available.&quot;;
+				break;
+			}
+
+			sRAIBuildList *BL = UDR-&gt;BL[iBestI];
+			if( BL-&gt;unitsActive &lt; BL-&gt;minUnits )
+			{
+				int temp = BL-&gt;UDefActiveTemp;
+				for( int iud=BL-&gt;UDefActiveTemp-1; iud&gt;=0; iud-- )
+					if( !BL-&gt;UDef[iud]-&gt;RUD-&gt;HasPrerequisite )
+						BL-&gt;UDefSwitch(iud,--BL-&gt;UDefActiveTemp);
+				if( BL-&gt;UDefActiveTemp == 0 )
+					BL-&gt;UDefActiveTemp = temp;
+			}
+
+			int iBuildType=1;
+			if( BL == UDR-&gt;BLEnergy || BL == UDR-&gt;BLEnergyL )
+				iBuildType=2;
+			else if( BL == UDR-&gt;BLMetal || BL == UDR-&gt;BLMetalL )
+				iBuildType=3;
+			else if( BL == UDR-&gt;BLBuilder )
+				iBuildType=4;
+
+			iBestI = rand()%BL-&gt;UDefActiveTemp;
+			sRAIUnitDef *udr = BL-&gt;UDef[iBestI]-&gt;RUD;
+//			*l&lt;&lt;&quot;\n Option Seleted: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+
+			if( !udr-&gt;HasPrerequisite &amp;&amp; BQSize[4] &lt; 5 )
+			{
+				int oldID=udr-&gt;ud-&gt;id;
+				udr=&amp;UDR-&gt;UDR.find(udr-&gt;GetPrerequisite())-&gt;second;
+				if( udr-&gt;ud-&gt;id != oldID )
+				{
+					iBuildType=7;
+//					*l&lt;&lt;&quot;\n Prerequisite Seleted: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				}
+			}
+
+			float fBuildTime=udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed;
+			float EnergyDemand = -1;
+			float MetalDemand = -1;
+			float ConstructorDemand = -1;
+			float EnergyStorageDemand = -1;
+			float MetalStorageDemand = -1;
+
+			if( BL-&gt;unitsActive &gt;= BL-&gt;minUnits &amp;&amp; BL != UDR-&gt;BLEnergy &amp;&amp; BL != UDR-&gt;BLMetal &amp;&amp; BL != UDR-&gt;BLMetalL )
+			{
+				if( (UDR-&gt;BLEnergyL-&gt;UDefActiveTemp &gt; 0 || UDR-&gt;BLEnergy-&gt;UDefActiveTemp &gt; 0) &amp;&amp; BQSize[2] &lt; 5 &amp;&amp; BQSize[2] &lt; 0.4*BQSize[0] )
+					EnergyDemand = -(fBuildTime*EnergyRate+cb-&gt;GetEnergy()-0.1*ConEnergyLost-udr-&gt;ud-&gt;energyCost)*ERatio/UDR-&gt;EnergyToMetalRatio;
+				if( (UDR-&gt;BLMetalL-&gt;UDefActiveTemp &gt; 0 || UDR-&gt;BLMetal-&gt;UDefActiveTemp &gt; 0) &amp;&amp; BQSize[3] &lt; 5 &amp;&amp; BQSize[3] &lt; 0.4*BQSize[0] &amp;&amp; !( EnergyDemand&gt;0 &amp;&amp; udr-&gt;HighEnergyDemand ) )
+				{
+					MetalDemand = -(fBuildTime*MetalRate+cb-&gt;GetMetal()-0.1*ConMetalLost-udr-&gt;ud-&gt;metalCost)*MRatio;
+					if( MetalDemand &lt;= 0 &amp;&amp; UDR-&gt;BLMetalL-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[3] == 0 )
+						MetalDemand = 3;
+				}
+				if( UDR-&gt;BLBuilder-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[4] &lt; 2 &amp;&amp; BQSize[4] &lt; 0.3*BQSize[0] )
+				{
+					if( EnergyRate &gt; 0 &amp;&amp; MetalRate &gt; 0 &amp;&amp; 30.0*EnergyRate+cb-&gt;GetEnergy()-(0.6+0.1*BQSize[4])*cb-&gt;GetEnergyStorage() &gt; 0 &amp;&amp; 30.0*MetalRate+cb-&gt;GetMetal()-(0.6+0.1*BQSize[4])*cb-&gt;GetMetalStorage() &gt; 0 )
+						ConstructorDemand = 2;
+				}
+				if( UDR-&gt;BLEnergyStorage-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[5] &lt; 1 )
+				{
+					if( (cb-&gt;GetEnergyStorage()+ConEnergyStorage &lt; 2.5*cb-&gt;GetEnergyUsage()) ||
+						(cb-&gt;GetEnergyStorage()+ConEnergyStorage &lt; udr-&gt;WeaponMaxEnergyCost) )
+						EnergyStorageDemand = 1;
+				}
+				if( UDR-&gt;BLMetalStorage-&gt;UDefActiveTemp &gt; 0 &amp;&amp; BQSize[6] &lt; 1 )
+				{
+					if( cb-&gt;GetMetalStorage()+ConMetalStorage &lt; 2.5*cb-&gt;GetMetalUsage() )
+						MetalStorageDemand = 1;
+				}
+			}
+/*
+*l&lt;&lt;&quot;\n CB&quot;;
+*l&lt;&lt;&quot;\n   Metal  =&quot;&lt;&lt;cb-&gt;GetMetal();
+*l&lt;&lt;&quot;   Metal Income  =&quot;&lt;&lt;cb-&gt;GetMetalIncome();
+*l&lt;&lt;&quot;   Metal Usage  =&quot;&lt;&lt;cb-&gt;GetMetalUsage();
+*l&lt;&lt;&quot;   Metal Storage  =&quot;&lt;&lt;cb-&gt;GetMetalStorage();
+*l&lt;&lt;&quot;\n   Energy =&quot;&lt;&lt;cb-&gt;GetEnergy();
+*l&lt;&lt;&quot;   Energy Income =&quot;&lt;&lt;cb-&gt;GetEnergyIncome();
+*l&lt;&lt;&quot;   Energy Usage =&quot;&lt;&lt;cb-&gt;GetEnergyUsage();
+*l&lt;&lt;&quot;   Energy Storage =&quot;&lt;&lt;cb-&gt;GetEnergyStorage();
+*l&lt;&lt;&quot;\n Con Energy Lost =&quot;&lt;&lt;ConEnergyLost;
+*l&lt;&lt;&quot;\n Metal Energy Lost =&quot;&lt;&lt;ConMetalLost;
+*l&lt;&lt;&quot;\n EtoMEnergyNeeded=&quot;&lt;&lt;PM-&gt;EtoMEnergyNeeded;
+*l&lt;&lt;&quot;\n EtoMMetalIncome=&quot;&lt;&lt;PM-&gt;EtoMIncome;
+*l&lt;&lt;&quot;\n OnOffPower=&quot;&lt;&lt;OnOffPower;
+*l&lt;&lt;&quot;\n fWeaponPower=&quot;&lt;&lt;fWeaponPower;
+*l&lt;&lt;&quot;\n Build Time=&quot;&lt;&lt;fBuildTime;
+*l&lt;&lt;&quot;\n Name=&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+*l&lt;&lt;&quot;\n   metalCost=&quot;&lt;&lt;udr-&gt;ud-&gt;metalCost;
+*l&lt;&lt;&quot;\n   energyCost=&quot;&lt;&lt;udr-&gt;ud-&gt;energyCost;
+*l&lt;&lt;&quot;\n   metalUpkeep=&quot;&lt;&lt;udr-&gt;ud-&gt;metalUpkeep;
+*l&lt;&lt;&quot;\n   metalMake=&quot;&lt;&lt;udr-&gt;ud-&gt;metalMake;
+*l&lt;&lt;&quot;\n   energyUpkeep=&quot;&lt;&lt;udr-&gt;ud-&gt;energyUpkeep;
+*l&lt;&lt;&quot;\n   energyMake=&quot;&lt;&lt;udr-&gt;ud-&gt;energyMake;
+*l&lt;&lt;&quot;\n   HighEnergyDemand=&quot;&lt;&lt;udr-&gt;HighEnergyDemand;
+*l&lt;&lt;&quot;\n   extractsMetal=&quot;&lt;&lt;udr-&gt;ud-&gt;extractsMetal;
+*l&lt;&lt;&quot;\n BQSize&quot;; for( int i=0; i&lt;8; i++ ) *l&lt;&lt;&quot; [&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;BQSize[i];
+*l&lt;&lt;&quot;\n EnergyDemand=&quot;&lt;&lt;EnergyDemand;
+*l&lt;&lt;&quot;\n MetalDemand=&quot;&lt;&lt;MetalDemand;
+*l&lt;&lt;&quot;\n EnergyStorageDemand=&quot;&lt;&lt;EnergyStorageDemand;
+*l&lt;&lt;&quot;\n MetalStorageDemand=&quot;&lt;&lt;MetalStorageDemand;
+*l&lt;&lt;&quot;\n ConstructorDemand=&quot;&lt;&lt;ConstructorDemand;
+*/
+			float fHigh=0;
+			if( EnergyDemand &gt; fHigh )
+			{
+				fHigh=EnergyDemand;
+				iBuildType=2;
+				if( UDR-&gt;BLEnergyL-&gt;UDefActiveTemp &gt; 0 )
+					BL=UDR-&gt;BLEnergyL;
+				else
+					BL=UDR-&gt;BLEnergy;
+			}
+			if( MetalDemand &gt; fHigh )
+			{
+				fHigh=MetalDemand;
+				iBuildType=3;
+
+				if( UDR-&gt;BLMetalL-&gt;UDefActiveTemp &gt; 0 )
+					BL=UDR-&gt;BLMetalL;
+				else
+				{
+					BL=UDR-&gt;BLMetal;
+				}
+			}
+			if( ConstructorDemand &gt; fHigh )
+			{
+				fHigh=ConstructorDemand;
+				iBuildType=4;
+				BL=UDR-&gt;BLBuilder;
+			}
+			if( EnergyStorageDemand &gt; fHigh )
+			{
+				fHigh=EnergyStorageDemand;
+				iBuildType=5;
+				BL=UDR-&gt;BLEnergyStorage;
+			}
+			if( MetalStorageDemand &gt; fHigh )
+			{
+				fHigh=MetalStorageDemand;
+				iBuildType=6;
+				BL=UDR-&gt;BLMetalStorage;
+			}
+			if( fHigh &gt; 0 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+BL-&gt;Name+&quot;(a=&quot;&lt;&lt;BL-&gt;UDefActiveTemp&lt;&lt;&quot;) Build Type=&quot;&lt;&lt;iBuildType;
+				int iIndex=rand()%BL-&gt;UDefActiveTemp;
+//				*l&lt;&lt;&quot; BL Index=&quot;&lt;&lt;iIndex;
+				udr = BL-&gt;UDef[iIndex]-&gt;RUD;
+				if( iBuildType == 3 &amp;&amp; udr-&gt;HighEnergyDemand &amp;&amp; PM-&gt;EtoMNeeded &lt; 0 )
+				{
+					iBuildType=2;
+					if( UDR-&gt;BLEnergyL-&gt;UDefActiveTemp &gt; 0 )
+						BL=UDR-&gt;BLEnergyL;
+					else
+						BL=UDR-&gt;BLEnergy;
+					iIndex=rand()%BL-&gt;UDefActiveTemp;
+//					*l&lt;&lt;&quot; BL Index=&quot;&lt;&lt;iIndex;
+					udr = BL-&gt;UDef[iIndex]-&gt;RUD;
+				}
+//				*l&lt;&lt;&quot;\n  2-6 Demand Alternative Selected: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				if( !udr-&gt;HasPrerequisite &amp;&amp; BQSize[4] &lt; 5 &amp;&amp; BQSize[4] &lt;= 0.5*BQSize[0] )
+				{
+					int oldID=udr-&gt;ud-&gt;id;
+					udr=&amp;UDR-&gt;UDR.find(udr-&gt;GetPrerequisite())-&gt;second;
+					if( udr-&gt;ud-&gt;id != oldID )
+					{
+						iBuildType=7;
+//						*l&lt;&lt;&quot;\n Prerequisite Seleted: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					}
+				}
+			}
+
+			bool bPrerequisiteOptionsChecked=false;
+			int iBest=-1;
+			int Count=0;
+			for(map&lt;int,sRAIUnitDef*&gt;::iterator iP=udr-&gt;PrerequisiteOptions.begin(); iP!=udr-&gt;PrerequisiteOptions.end() &amp;&amp; !bPrerequisiteOptionsChecked; iP++)
+			{
+				for(set&lt;int&gt;::iterator iU=iP-&gt;second-&gt;UnitsActive.begin(); iU!=iP-&gt;second-&gt;UnitsActive.end() &amp;&amp; !bPrerequisiteOptionsChecked; iU++ )
+					if( UBuilder.find(*iU) != UBuilder.end() &amp;&amp; UBuilder.find(*iU)-&gt;second-&gt;BuildQ == 0 &amp;&amp; *iU != unit )
+					{
+						if( int(cb-&gt;GetCurrentUnitCommands(*iU)-&gt;size()) == 0 || cb-&gt;GetCurrentUnitCommands(*iU)-&gt;front().id == CMD_WAIT )
+							G-&gt;UpdateEventAdd(1,0,*iU,UBuilder.find(*iU)-&gt;second);
+						bPrerequisiteOptionsChecked=true;
+					}
+			}
+			if( !bPrerequisiteOptionsChecked &amp;&amp; BQSize[4] &lt; 3 &amp;&amp; BQSize[4] &lt;= 0.3*BQSize[0] &amp;&amp; Prerequisite == 0 &amp;&amp; rand()%5 == 0 )
+			{
+				int oldID=udr-&gt;ud-&gt;id;
+				udr=&amp;UDR-&gt;UDR.find(udr-&gt;GetPrerequisiteNewBuilder())-&gt;second;
+				if( udr-&gt;ud-&gt;id != oldID )
+				{
+					if( udr-&gt;UnitConstructs == 0 &amp;&amp;
+						((UDR-&gt;BLMetalL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLMetal-&gt;UDefSize == 0) || 0.25*cb-&gt;GetMetalIncome() &gt; udr-&gt;ud-&gt;metalCost/UDR-&gt;AverageConstructSpeed ) &amp;&amp;
+						((UDR-&gt;BLEnergyL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLEnergy-&gt;UDefSize == 0) || 0.25*cb-&gt;GetEnergyIncome() &gt; udr-&gt;ud-&gt;energyCost/UDR-&gt;AverageConstructSpeed) )
+					{
+//						*l&lt;&lt;&quot;\n New Builder Selected: &quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+						iBuildType=4;
+					}
+					else
+						udr=&amp;UDR-&gt;UDR.find(oldID)-&gt;second;
+				}
+			}
+			BQAdd(udr,BL,iBuildType);
+			if( Prerequisite == 0 &amp;&amp; iBuildType == 7 &amp;&amp; int(udr-&gt;UnitsActive.size()) == 0 )
+			{
+				Prerequisite = BQ[BQSize[0]-1];
+			}
+			MetalRate=cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage()+0.1*PM-&gt;EtoMIncome+0.75*ConMetalRate; //+0.75*PM-&gt;MetalProduction
+			EnergyRate=cb-&gt;GetEnergyIncome()-cb-&gt;GetEnergyUsage()-OnOffPower-fWeaponPower+0.75*ConEnergyRate;
+		}
+		// Search existing build orders
+		float Demand[8]; // index = type, higher value mean that type should be built first
+		Demand[1] = 0;
+		Demand[2] = 3;
+		Demand[3] = 3;
+		if( cb-&gt;GetEnergy()*(cb-&gt;GetEnergyIncome()/cb-&gt;GetEnergyUsage()) &lt; cb-&gt;GetMetal()*(cb-&gt;GetMetalIncome()/cb-&gt;GetMetalUsage()) )
+			Demand[2]++;
+		else
+			Demand[3]++;
+		Demand[4] = 2;
+		if( MetalIsFavorable(0.75f) &amp;&amp; EnergyIsFavorable(0.75f) &amp;&amp; int(G-&gt;Units.size()) &gt;= 5 )
+			Demand[4]+=3;
+		Demand[5] = 1;
+		Demand[6] = 1;
+		Demand[7] = 6;
+		int iBest=-1;
+		for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+			if( BQ[iBQ]-&gt;builderID == -1 &amp;&amp; U-&gt;udr-&gt;BuildOptions.find(BQ[iBQ]-&gt;creationUDID) != U-&gt;udr-&gt;BuildOptions.end() )
+				if( iBest == -1 || BQ[iBQ]==Prerequisite || (BQ[iBest]!=Prerequisite &amp;&amp; (Demand[BQ[iBQ]-&gt;type] &gt; Demand[BQ[iBest]-&gt;type] || (BQ[iBest]-&gt;type==BQ[iBQ]-&gt;type &amp;&amp; BQ[iBest]-&gt;creationUD-&gt;HighEnergyDemand &amp;&amp; !BQ[iBQ]-&gt;creationUD-&gt;HighEnergyDemand) ) ) )
+					iBest=iBQ;
+		if( iBest &gt;= 0 )
+		{
+			BQAssignBuilder(iBest,unit,U);
+			HaveOrders=true;
+			c.id=-U-&gt;BuildQ-&gt;creationUDID;
+		}
+	}
+/*
+	for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++) // Build Quarry Debug
+	{
+		*l&lt;&lt;&quot;\nBQ #&quot;&lt;&lt;iBQ+1;
+		*l&lt;&lt;&quot;:  BID=&quot;&lt;&lt;BQ[iBQ]-&gt;builderID;
+		if( int(BQ[iBQ]-&gt;creationID.size()) &gt; 0 )
+		{
+			*l&lt;&lt;&quot; CID=&quot;&lt;&lt;BQ[iBQ]-&gt;creationID.front();
+		}
+		*l&lt;&lt;&quot; CUDID=&quot;&lt;&lt;BQ[iBQ]-&gt;creationUDID;
+	}
+*/
+	if( int(U-&gt;URepair.size()) &gt; 0 )
+	{
+		while( int(U-&gt;URepair.size()) &gt; 0 &amp;&amp; ( cb-&gt;GetUnitDef(U-&gt;URepair.begin()-&gt;first) == 0 || cb-&gt;GetUnitHealth(U-&gt;URepair.begin()-&gt;first) == cb-&gt;GetUnitMaxHealth(U-&gt;URepair.begin()-&gt;first) ) )
+			U-&gt;URepair.erase(U-&gt;URepair.begin()-&gt;first);
+
+		if( int(U-&gt;URepair.size()) &gt; 0 )
+		{
+			c.id = CMD_REPAIR;
+			c.params.push_back(U-&gt;URepair.begin()-&gt;first);
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+	}
+	if( !HaveOrders &amp;&amp; U-&gt;ud-&gt;canResurrect &amp;&amp; U-&gt;ud-&gt;speed &gt; 0 )
+	{
+		UpdateKnownFeatures(unit,U);
+		if( int(ResDebris.size()) &gt; 0 )
+		{
+			int iBest=-1;
+			float3 Pos = cb-&gt;GetUnitPos(unit);
+			float3 debPos;
+			for( map&lt;int,float3&gt;::iterator iR=ResDebris.begin(); iR!=ResDebris.end(); iR++ )
+			{
+				if( (iBest == -1 || Pos.distance(debPos) &gt; Pos.distance(iR-&gt;second)) &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,iR-&gt;second) )
+				{
+					iBest = iR-&gt;first;
+					debPos= ResDebris.find(iBest)-&gt;second;
+				}
+			}
+			if( iBest != -1 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is resurrecting.&quot;;
+				c.id=CMD_RESURRECT;
+//				c.params.push_back(iBest);
+				c.params.push_back(debPos.x); // ! Work Around:  Spring-Version(v0.74b3)
+				c.params.push_back(debPos.y);
+				c.params.push_back(debPos.z);
+				c.params.push_back(25.0f);
+				cb-&gt;GiveOrder(unit, &amp;c);
+				float fTime=Pos.distance(debPos)/(U-&gt;ud-&gt;speed/3.0);
+				G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+1500+30*int(fTime),unit,U);
+				ResDebris.erase(iBest);
+				return;
+			}
+		}
+	}
+	if( !HaveOrders &amp;&amp; U-&gt;ud-&gt;canReclaim &amp;&amp; U-&gt;ud-&gt;speed &gt; 0 &amp;&amp; !U-&gt;ud-&gt;isCommander )
+	{
+		while( int(Decomission.size()) &gt; 0 &amp;&amp; cb-&gt;GetUnitDef(*Decomission.begin()) == 0 )
+		{
+			Decomission.erase(*Decomission.begin());
+		}
+		if( int(Decomission.size()) &gt; 0 &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,cb-&gt;GetUnitPos(*Decomission.begin())) )
+		{
+//			*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Decomissioning.&quot;;
+			c.id=CMD_RECLAIM;
+			c.params.push_back(*Decomission.begin());
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+		if( int(FeatureDebris.size()) &gt; 0 &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,FeatureDebris.begin()-&gt;second) )
+		{
+			map&lt;int,float3&gt;::iterator i=FeatureDebris.begin();
+			float3 fPos = i-&gt;second;
+
+			int *F = new int[1];
+			if( cb-&gt;GetFeatures(F,1,i-&gt;second,20.0) == 1 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Clearing.&quot;;
+				c.id=CMD_RECLAIM;
+				c.params.push_back(fPos.x); // ! Work Around:  Spring-Version(v0.74b3)
+				c.params.push_back(fPos.y);
+				c.params.push_back(fPos.z);
+				c.params.push_back(80.0);
+				cb-&gt;GiveOrder(unit, &amp;c);
+
+				float fTime=cb-&gt;GetUnitPos(unit).distance(fPos)/(U-&gt;ud-&gt;speed/3.0);
+				G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+150+30*int(fTime),unit,U);
+				FeatureDebris.erase(i-&gt;first);
+				delete [] F;
+				return;
+			}
+			delete [] F;
+			FeatureDebris.erase(i-&gt;first);
+		}
+		if( cb-&gt;GetMetal() &lt; 0.15*cb-&gt;GetMetalStorage() || !MetalIsFavorable(0.5f) )
+		{
+			UpdateKnownFeatures(unit,U);
+			if( int(MetalDebris.size()) &gt; 0 )
+			{
+				int iBest=-1;
+				float3 Pos = cb-&gt;GetUnitPos(unit);
+				float3 debPos;
+				for( map&lt;int,float3&gt;::iterator iM=MetalDebris.begin(); iM!=MetalDebris.end(); iM++ )
+				{
+					if( (iBest == -1 || Pos.distance(debPos) &gt; Pos.distance(iM-&gt;second)) &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,iM-&gt;second) )
+					{
+						iBest = iM-&gt;first;
+						debPos = iM-&gt;second;
+					}
+				}
+				if( iBest != -1 )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/E Gathering.&quot;;
+					c.id=CMD_RECLAIM;
+//					c.params.push_back(iBest);
+					c.params.push_back(debPos.x); // ! Work Around:  Spring-Version(v0.74b3)
+					c.params.push_back(debPos.y);
+					c.params.push_back(debPos.z);
+					c.params.push_back(25.0f);
+					cb-&gt;GiveOrder(unit, &amp;c);
+
+					float fTime=Pos.distance(debPos)/(U-&gt;ud-&gt;speed/3.0);
+					G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+1500+30*int(fTime),unit,U);
+					MetalDebris.erase(iBest);
+					return;
+				}
+			}
+		}
+		if( cb-&gt;GetEnergy() &lt; 0.15*cb-&gt;GetEnergyStorage() || !EnergyIsFavorable(0.5f) )
+		{
+			UpdateKnownFeatures(unit,U);
+			if( int(EnergyDebris.size()) &gt; 0 )
+			{
+				int iBest=-1;
+				float3 Pos = cb-&gt;GetUnitPos(unit);
+				float3 debPos;
+				for( map&lt;int,float3&gt;::iterator iE=EnergyDebris.begin(); iE!=EnergyDebris.end(); iE++ )
+				{
+					if( (iBest == -1 || Pos.distance(debPos) &gt; Pos.distance(iE-&gt;second)) &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,iE-&gt;second) )
+					{
+						iBest = iE-&gt;first;
+						debPos = iE-&gt;second;
+					}
+				}
+				if( iBest != -1 )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/M Gathering.&quot;;
+					c.id=CMD_RECLAIM;
+					c.params.push_back(debPos.x); // ! Work Around:  Spring-Version(v0.74b3)
+					c.params.push_back(debPos.y);
+					c.params.push_back(debPos.z);
+					c.params.push_back(25.0f);
+					cb-&gt;GiveOrder(unit, &amp;c);
+					float fTime=Pos.distance(debPos)/(U-&gt;ud-&gt;speed/3.0);
+					G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+1500+30*int(fTime),unit,U);
+					EnergyDebris.erase(iBest);
+					return;
+				}
+			}
+		}
+	}
+	// If this unit has nothing else to do, and resources are favorable, continuously build military units
+	if( !HaveOrders &amp;&amp; BQSize[0]&lt;40 &amp;&amp; MetalIsFavorable(0.35f,0.94f) &amp;&amp; EnergyIsFavorable(0.70f,0.94f) )
+	{
+		vector&lt;int&gt; build;
+		float3 position = cb-&gt;GetUnitPos(unit);
+		G-&gt;CorrectPosition(position);
+		for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=U-&gt;udr-&gt;BuildOptions.begin(); iB!=U-&gt;udr-&gt;BuildOptions.end(); iB++ )
+			if( iB-&gt;second-&gt;CanBeBuilt &amp;&amp; BP-&gt;CanBeBuiltAt(iB-&gt;second,position) )
+				for( int iL=0; iL&lt;iB-&gt;second-&gt;ListSize; iL++ )
+					if( iB-&gt;second-&gt;List[iL]-&gt;RBL-&gt;Name == &quot;Mobile Anti-Land/Air&quot; ||
+						(iB-&gt;second-&gt;List[iL]-&gt;RBL-&gt;Name == &quot;Mobile Anti-Naval&quot; &amp;&amp; iB-&gt;second-&gt;List[iL]-&gt;RBL-&gt;priority &gt; 0 ) )
+					{
+						build.push_back(iB-&gt;first);
+						break;
+					}
+		if( int(build.size()) &gt; 0 )
+		{
+			int iRan=rand()%int(build.size());
+			BQAdd(U-&gt;udr-&gt;BuildOptions.find(build.at(iRan))-&gt;second,0,1);
+			BQAssignBuilder(BQSize[0]-1,unit,U);
+			c.id=-U-&gt;BuildQ-&gt;creationUDID;
+			HaveOrders=true;
+		}
+	}
+	if( HaveOrders &amp;&amp; c.id &lt; 0 ) // Has Build Orders
+	{
+		if( int(U-&gt;BuildQ-&gt;creationID.size()) &gt; 0 )
+		{	// Resuming a construction
+//			*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Repair/Building&quot;;
+			c.id = CMD_REPAIR;
+			c.params.push_back(U-&gt;BuildQ-&gt;creationID.front());
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+
+		const UnitDef *bd=U-&gt;BuildQ-&gt;creationUD-&gt;ud;
+		if( U-&gt;BuildQ-&gt;RS != 0 )
+		{
+			if( U-&gt;BuildQ-&gt;RS-&gt;unitID &gt; -1 &amp;&amp; U-&gt;BuildQ-&gt;RS-&gt;enemy )
+			{
+				if( U-&gt;ud-&gt;canCapture )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Capture/Building.&quot;;
+					c.id = CMD_CAPTURE;
+					c.params.push_back(U-&gt;BuildQ-&gt;RS-&gt;unitID);
+					cb-&gt;GiveOrder(unit, &amp;c);
+				}
+				else if( U-&gt;ud-&gt;canReclaim )
+				{
+//					*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Building.&quot;;
+					c.id = CMD_RECLAIM;
+					c.params.push_back(U-&gt;BuildQ-&gt;RS-&gt;unitID);
+					cb-&gt;GiveOrder(unit, &amp;c);
+				}
+				else
+				{
+					*l&lt;&lt;&quot;\nWARNING: Can Not Reclaim/Capture Enemy&quot;;
+					BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0); // unassign builder
+				}
+				return;
+			}
+			if( U-&gt;BuildQ-&gt;RS-&gt;BuildOptions.find(bd-&gt;id)-&gt;second.RBRanked )
+			{
+				BQRemove(U-&gt;BuildQ-&gt;index);
+				return;
+			}
+		}
+		float3 position = BP-&gt;FindBuildPosition(U-&gt;BuildQ);
+		if( !cb-&gt;CanBuildAt(bd,position) )
+		{	// FindBuildPosition() most likely returned an error position (-[1-3],-1,-1)
+//			*l&lt;&lt;&quot;\n FindBuildPosition() failed:&quot;&lt;&lt;position.x;
+			if( U-&gt;ud-&gt;speed==0.0 &amp;&amp; bd-&gt;speed&gt;0.0 )
+			{	// Fix for the mod gundam v1.1-v1.11 ( cb-&gt;CanBuildAt() &amp; cb-&gt;ClosestBuildSite() will almost always fails).
+				// In addition to this, cb-&gt;GiveOrder() will fail if the position is invalid, even though the position doesn't matter
+				// this condition unfortunately assumes that all immobile constructors build mobile units at their center
+				position=cb-&gt;GetUnitPos(unit);
+			}
+			else if( U-&gt;BuildQ-&gt;RS != 0 &amp;&amp; U-&gt;BuildQ-&gt;RS-&gt;unitID &gt; -1 &amp;&amp; cb-&gt;GetUnitTeam(U-&gt;BuildQ-&gt;RS-&gt;builderID) == cb-&gt;GetUnitTeam(U-&gt;BuildQ-&gt;RS-&gt;unitID) &amp;&amp; U-&gt;ud-&gt;canReclaim )
+			{	// removing an old extractor while upgrading it
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Reclaim/Upgrade/Building.&quot;;
+				c.id = CMD_RECLAIM;
+				c.params.push_back(U-&gt;BuildQ-&gt;RS-&gt;unitID);
+				cb-&gt;GiveOrder(unit, &amp;c);
+				return;
+			}
+			else
+			{
+				if( !U-&gt;BuildQ-&gt;creationUD-&gt;CanBeBuilt )
+				{	// usually this means an intended resource is no longer available
+					BQRemove(U-&gt;BuildQ-&gt;index);
+				}
+				else
+				{
+					*l&lt;&lt;&quot;\nWARNING: (&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;&lt;&lt;U-&gt;ud-&gt;humanName&lt;&lt;&quot; can not build a '&quot;&lt;&lt;bd-&gt;humanName&lt;&lt;&quot;' at selected position: x=&quot;&lt;&lt;position.x&lt;&lt;&quot; y=&quot;&lt;&lt;position.y&lt;&lt;&quot; z=&quot;&lt;&lt;position.z;
+					BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0); // unassign builder
+				}
+				G-&gt;UpdateEventAdd(1,0,unit,U);
+				return;
+			}
+		}
+//		*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Building a &quot;+bd-&gt;humanName+&quot;(&quot;&lt;&lt;-c.id&lt;&lt;&quot;) at (x&quot;&lt;&lt;position.x&lt;&lt;&quot;,z&quot;&lt;&lt;position.z&lt;&lt;&quot;,y&quot;&lt;&lt;position.y&lt;&lt;&quot;)&quot;;
+		c.params.push_back(position.x);
+		c.params.push_back(position.y);
+		c.params.push_back(position.z);
+
+		if( U-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;movedata == 0 &amp;&amp; int(U-&gt;BuildQ-&gt;creationUD-&gt;BuildOptions.size()) &gt; 0 )
+		{	// decides if a factory should face the opposite direction due to bad terrain
+			float3 positionH = position;
+			positionH.z+=48.0f;
+//			positionH.y=cb-&gt;GetElevation(positionH.x,positionH.z);
+			float3 positionL = position;
+			positionL.z-=48.0f;
+//			positionL.y=cb-&gt;GetElevation(positionL.x,positionL.z);
+			if( position.z/8 &gt;= cb-&gt;GetMapHeight()-5-(U-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;ysize/2) ||
+				(cb-&gt;CanBuildAt(bd,positionL) &amp;&amp; !cb-&gt;CanBuildAt(bd,positionH) ) )
+				c.params.push_back(2);
+		}
+		if( U-&gt;ud-&gt;buildSpeed == 0 )
+		{	// Work-Around for the mod: fibre v13.1
+			// This is more experimental than anything meaningful
+			if( c.params.size() == 3 )
+				c.params.push_back(0);
+			G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+300,unit,U);
+		}
+		cb-&gt;GiveOrder(unit, &amp;c);
+		return;
+	}
+	if( !HaveOrders &amp;&amp; U-&gt;ud-&gt;canAssist ) // Assist Build
+	{
+		if( U-&gt;ud-&gt;speed &gt; 0 )
+		{
+			int BestIndex=-1;
+			float3 fPos=cb-&gt;GetUnitPos(unit);
+			float BestDis;
+			for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+			{
+				if( BQ[iBQ]-&gt;builderID &gt;= 0 &amp;&amp; G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID)) )
+				{	
+					float Dis=fPos.distance(cb-&gt;GetUnitPos(BQ[iBQ]-&gt;builderID));
+					if( BestIndex == -1 || Dis &lt; BestDis )
+					{
+						BestIndex=iBQ;
+						BestDis=Dis;
+					}
+				}
+			}
+
+			if( BestIndex &gt; 0 )
+			{
+//				*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Assisting &quot;&lt;&lt;BQ[BestIndex]-&gt;builderUI-&gt;ud-&gt;humanName;
+				c.id = CMD_GUARD;
+				c.params.push_back(BQ[BestIndex]-&gt;builderID);
+				//c.timeOut=cb-&gt;GetCurrentFrame()+360;
+				G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+600,unit,U);
+				cb-&gt;GiveOrder(unit, &amp;c);
+				return;
+			}
+		}
+		else if( U-&gt;group != 0 )
+		{
+			for( map&lt;int,UnitInfo*&gt;::iterator i = U-&gt;group-&gt;Units.begin(); i != U-&gt;group-&gt;Units.end(); i++ )
+			{
+				if( i-&gt;second-&gt;BuildQ != 0 )
+				{
+					c.id = CMD_GUARD;
+					c.params.push_back(i-&gt;first);
+					G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+600,unit,U);
+					cb-&gt;GiveOrder(unit, &amp;c);
+					return;
+				}
+			}
+		}
+	}
+
+//	*l&lt;&lt;&quot;\n &quot;+U-&gt;ud-&gt;humanName+&quot; is Waiting&quot;;
+//	G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+600,unit,U);
+	c.id = CMD_WAIT;
+	c.timeOut=cb-&gt;GetCurrentFrame()+600;
+
+	// Wait commands are usually issued so that I know a unit that is doing nothing
+	// is suppose to be doing nothing, but eventually this command broke the factories.
+	// If factories are given wait orders they will stop responding to all future commands
+	// cb-&gt;cb-&gt;GetCurrentUnitCommands()-&gt;size() will always = 0 from that point on
+	if( U-&gt;ud-&gt;movedata == 0 ) // Work Around:  Spring-Version(v0.74b1-0.76b1)
+	{
+		G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+600,unit,U);
+		return;
+	}
+	cb-&gt;GiveOrder(unit, &amp;c);
+}
+
+bool cBuilder::UBuilderMoveFailed(const int&amp; unit, UnitInfo *U)
+{
+	int iF;
+	int *F = new int[10];
+	int FSize = cb-&gt;GetFeatures(F,10,cb-&gt;GetUnitPos(unit),90);
+	for( iF=0; iF &lt; FSize; iF++ )
+		if( cb-&gt;GetFeatureDef(F[iF])-&gt;destructable )
+			break;
+	if( iF &lt; FSize )
+	{
+		if( U-&gt;ud-&gt;canReclaim )
+		{
+//			*l&lt;&lt;&quot; &quot;+UBuilder.find(unit)-&gt;second.ud-&gt;name+&quot; is Reclaiming &quot;;
+			Command c;
+			c.id=CMD_RECLAIM;
+			float3 fPos = cb-&gt;GetUnitPos(unit);
+			c.params.push_back(fPos.x); // ! Work Around:  Spring-Version(v0.74b3)
+			c.params.push_back(fPos.y);
+			c.params.push_back(fPos.z);
+			c.params.push_back(90.0);
+			//c.params.push_back(F[0]);
+
+			G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+1200,unit,U);
+			cb-&gt;GiveOrder(unit, &amp;c);
+
+			fPos = cb-&gt;GetFeaturePos(F[iF]);
+			delete [] F;
+			return true;
+		}
+		else
+		{
+			if( FeatureDebris.find(F[iF]) == FeatureDebris.end() ) // Add to reclaim list
+			{
+				FeatureDebris.insert(ifPair(F[iF],cb-&gt;GetUnitPos(unit)));
+			}
+		}
+	}
+	delete [] F;
+	return false;
+}
+
+void cBuilder::HandleEvent(const IGlobalAI::PlayerCommandEvent *pce)
+{
+	for( vector&lt;int&gt;::const_iterator i=pce-&gt;units.begin(); i!=pce-&gt;units.end(); i++ )
+	{
+		if( UBuilder.find(*i) != UBuilder.end() )
+		{
+			UnitInfo* U = UBuilder.find(*i)-&gt;second;
+			if( U-&gt;BuildQ != 0 )
+			{
+				if( pce-&gt;command.options == RIGHT_MOUSE_KEY &amp;&amp; pce-&gt;command.id &lt; 0 )
+				{
+					if( int(U-&gt;BuildQ-&gt;creationID.size())&gt;0 &amp;&amp; U-&gt;BuildQ-&gt;creationUDID == -pce-&gt;command.id )
+					{
+						G-&gt;UnitDestroyed(U-&gt;BuildQ-&gt;creationID.front(),-1);
+					}
+				}
+				else if( pce-&gt;command.options != SHIFT_KEY )
+					BQAssignBuilder(U-&gt;BuildQ-&gt;index,-1,0);
+			}
+		}
+	}
+}
+
+void cBuilder::UpdateUDRCost()
+{
+//	if( MCostUpdate &lt; 0.2*MCostLimit &amp;&amp; MCostUpdate &gt; -0.2*MCostLimit &amp;&amp;
+//		ECostUpdate &lt; 0.2*ECostLimit &amp;&amp; ECostUpdate &gt; -0.2*ECostLimit )
+//		return;
+	MCostLimit = cb-&gt;GetMetalIncome()+PM-&gt;EtoMIncome;
+	ECostLimit = cb-&gt;GetEnergyIncome();
+	if( MCostLimit &gt; 110.0 || (UDR-&gt;BLMetal-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLMetalL-&gt;UDefSize == 0) )
+		MCostLimit=9.9e8;
+	if( ECostLimit &gt; 110.0*UDR-&gt;EnergyToMetalRatio || (UDR-&gt;BLEnergy-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLEnergyL-&gt;UDefSize == 0) )
+		ECostLimit=9.9e8;
+
+//	*l&lt;&lt;&quot;\n Rechecking Unit Costs and Determining Active BL Options ...&quot;;
+	for( map&lt;int,sRAIUnitDef&gt;::iterator i=UDR-&gt;UDR.begin(); i!=UDR-&gt;UDR.end(); i++ )
+	{
+		sRAIUnitDef *udr = &amp;i-&gt;second;
+		if( udr-&gt;MetalPCost &lt; MCostLimit &amp;&amp; udr-&gt;EnergyPCost &lt; ECostLimit )
+		{
+			if( udr-&gt;RBCost )
+			{	// enabling
+				udr-&gt;RBCost = false;
+				udr-&gt;CheckBuildOptions();
+			}
+		}
+		else if( udr-&gt;MetalPCost &gt; 1.5*MCostLimit || udr-&gt;EnergyPCost &gt; 1.5*ECostLimit )
+		{
+			if( !udr-&gt;RBCost )
+			{	// disabling
+				udr-&gt;RBCost = true;
+				udr-&gt;CheckBuildOptions();
+			}
+		}
+	}
+	for(int iBL=0; iBL&lt;UDR-&gt;BLSize; iBL++)
+		if( UDR-&gt;BL[iBL]-&gt;minUnits &gt; 0 &amp;&amp; UDR-&gt;BL[iBL]-&gt;UDefSize &gt; 0 &amp;&amp; UDR-&gt;BL[iBL]-&gt;UDefSize &gt; UDR-&gt;BL[iBL]-&gt;UDefActive )
+		{
+//			*l&lt;&lt;&quot;\n Determining Cheapest for '&quot;&lt;&lt;UDR-&gt;BL[iBL]-&gt;Name&lt;&lt;&quot;' Build-List ...&quot;;
+			sRAIUnitDef *BestLandudr=0,*BestWaterudr=0; // NOTE: the same udr may be selected for both, may also already be enabled
+			float BestLandCost,BestWaterCost;
+			bool BestLandCanBuildConstructors,BestWaterCanBuildConstructors; // only used in determining the cheapest constructor
+			for(int iU=0; iU&lt;UDR-&gt;BL[iBL]-&gt;UDefSize; iU++)
+			{
+				sRAIUnitDef *udr = UDR-&gt;BL[iBL]-&gt;UDef[iU]-&gt;RUD;
+				if( !udr-&gt;Disabled &amp;&amp; udr-&gt;HasPrerequisite &amp;&amp; !udr-&gt;RBUnitLimit )
+				{
+					bool CanBuildConstructors = false; // only used in determining the cheapest constructor
+					for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=udr-&gt;BuildOptions.begin(); iB!=udr-&gt;BuildOptions.end(); iB++)
+						if( !iB-&gt;second-&gt;Disabled &amp;&amp; int(iB-&gt;second-&gt;BuildOptions.size()) &gt; 0 )
+						{
+							CanBuildConstructors = true;
+							break;
+						}
+					float Cost = udr-&gt;MetalPCost + udr-&gt;EnergyPCost*UDR-&gt;EnergyToMetalRatio;
+					if( udr-&gt;ud-&gt;minWaterDepth &lt; 0 )
+					{
+						if( BestLandudr == 0 ||
+							(CanBuildConstructors &amp;&amp; !BestLandCanBuildConstructors) ||
+							(Cost &lt; BestLandCost &amp;&amp; (CanBuildConstructors || !BestLandCanBuildConstructors) ) )
+						{
+							BestLandudr = udr;
+							BestLandCost = Cost;
+							BestLandCanBuildConstructors = CanBuildConstructors;
+						}
+					}
+					if( udr-&gt;ud-&gt;maxWaterDepth &gt; -G-&gt;TM-&gt;minElevation || udr-&gt;ud-&gt;floater )
+					{
+						if( BestWaterudr == 0 ||
+							(CanBuildConstructors &amp;&amp; !BestWaterCanBuildConstructors) ||
+							(Cost &lt; BestWaterCost &amp;&amp; (CanBuildConstructors || !BestWaterCanBuildConstructors) ) )
+						{
+							BestWaterudr = udr;
+							BestWaterCost = Cost;
+							BestWaterCanBuildConstructors = CanBuildConstructors;
+						}
+					}
+				}
+			}
+			if( BestLandudr != 0 &amp;&amp; (BestWaterudr == 0 || BestLandCost &lt; 3*BestWaterCost) )
+			{
+//				*l&lt;&lt;&quot;\nBestLandudr=&quot;&lt;&lt;BestLandudr-&gt;ud-&gt;humanName;
+				if( BestLandudr-&gt;RBCost )
+				{
+					BestLandudr-&gt;RBCost = false;
+					BestLandudr-&gt;CheckBuildOptions();
+				}
+			}
+			if( BestWaterudr != 0 &amp;&amp; (BestLandudr == 0 || BestWaterCost &lt; 3*BestLandCost) )
+			{
+//				*l&lt;&lt;&quot;\nBestWaterudr=&quot;&lt;&lt;BestWaterudr-&gt;ud-&gt;humanName;
+				if( BestWaterudr-&gt;RBCost )
+				{
+					BestWaterudr-&gt;RBCost = false;
+					BestWaterudr-&gt;CheckBuildOptions();
+				}
+			}
+		}
+	for(int iBQ=0; iBQ&lt;BQSize[0]; iBQ++)
+	{
+		if( BQ[iBQ]-&gt;creationUD-&gt;RBCost )
+		{
+			*l&lt;&lt;&quot;\n(Low Resources) Abandoning Construction: &quot;&lt;&lt;BQ[iBQ]-&gt;creationUD-&gt;ud-&gt;humanName;
+			BQRemove(iBQ--);
+		}
+	}
+/*
+	*l&lt;&lt;&quot;\n\n Displaying Active Build-List Options ...&quot;;
+	for(int iBL=0; iBL&lt;UDR-&gt;BLActive; iBL++ )
+	{
+		*l&lt;&lt;&quot;\n  &quot;&lt;&lt;UDR-&gt;BL[iBL]-&gt;Name&lt;&lt;&quot; Build-List(a=&quot;&lt;&lt;UDR-&gt;BL[iBL]-&gt;UDefActiveTemp&lt;&lt;&quot;): &quot;;
+		for(int iBO=0; iBO&lt;UDR-&gt;BL[iBL]-&gt;UDefActive; iBO++)
+			*l&lt;&lt;&quot; &quot;+UDR-&gt;BL[iBL]-&gt;UDef[iBO]-&gt;RUD-&gt;ud-&gt;humanName+&quot; &quot;;
+	}
+	*l&lt;&lt;&quot;\n\n&quot;;
+*/
+}
+
+void cBuilder::UpdateKnownFeatures(const int&amp; unit, UnitInfo *U)
+{
+/*
+	*l&lt;&lt;&quot;\nUpdate: M&quot;;
+	set&lt;int&gt; deletion;
+	for( map&lt;int,FeatureDef*&gt;::iterator iM=MetalDebris.begin(); iM!=MetalDebris.end(); iM++ )
+	{
+		if( cb-&gt;GetFeatureDef(iM-&gt;first) == 0 )
+			deletion.insert(iM-&gt;first);
+	}
+	*l&lt;&lt;&quot;s=&quot;&lt;&lt;deletion.size();
+	for( set&lt;int&gt;::iterator iM=deletion.begin(); iM!=deletion.end(); iM++ )
+	{
+		MetalDebris.erase(*iM);
+	}
+	deletion.clear();
+	*l&lt;&lt;&quot;\nUpdate: E&quot;;
+	for( map&lt;int,FeatureDef*&gt;::iterator iE=EnergyDebris.begin(); iE!=EnergyDebris.end(); iE++ )
+	{
+		if( cb-&gt;GetFeatureHealth(iE-&gt;first) == 0.0f )
+			deletion.insert(iE-&gt;first);
+	}
+	*l&lt;&lt;&quot;s=&quot;&lt;&lt;deletion.size();
+	for( set&lt;int&gt;::iterator iE=deletion.begin(); iE!=deletion.end(); iE++ )
+	{
+		EnergyDebris.erase(*iE);
+	}
+*/
+	int *F = new int[15];
+	int FeatureSize = cb-&gt;GetFeatures(F,15,cb-&gt;GetUnitPos(unit),750);
+	for( int iF=0; iF&lt;FeatureSize; iF++ )
+	{
+		const FeatureDef* fd = cb-&gt;GetFeatureDef(F[iF]);
+		if( fd-&gt;reclaimable )
+		{
+			if( fd-&gt;metal &gt;= 40 )
+			{
+				if( MetalDebris.find(F[iF]) == MetalDebris.end() )
+					MetalDebris.insert(ifPair(F[iF],cb-&gt;GetFeaturePos(F[iF])));
+			}
+			if( fd-&gt;energy &gt;= 40 )
+			{
+				if( EnergyDebris.find(F[iF]) == EnergyDebris.end() )
+					EnergyDebris.insert(ifPair(F[iF],cb-&gt;GetFeaturePos(F[iF])));
+			}
+			if( UDRResurrect.find(fd-&gt;myName) != UDRResurrect.end() )
+			{
+				if( ResDebris.find(F[iF]) == ResDebris.end() )
+					ResDebris.insert(ifPair(F[iF],cb-&gt;GetFeaturePos(F[iF])));
+			}
+		}
+	}
+	delete [] F;
+}
+
+void cBuilder::CreateBuildOrders()
+{
+
+}
+/*
+void cBuilder::UpdateResourceUsage()
+{
+	MetalUsage=0;
+	EnergyUsage=0;
+	for( int i=0; i &lt; BQSize[0]; i++ )
+	{
+		if( BQ[i]-&gt;builderID &gt; 0 &amp;&amp; BQ[i]-&gt;creationID.size() &gt; 0 )
+		{
+			if( BQ[i]-&gt;creationUD-&gt;ud-&gt;metalCost &gt; 0 )
+				MetalUsage+=BQ[i]-&gt;builderUI-&gt;ud-&gt;buildSpeed/BQ[i]-&gt;creationUD-&gt;ud-&gt;metalCost;
+			if( BQ[i]-&gt;creationUD-&gt;ud-&gt;energyCost &gt; 0 )
+				EnergyUsage+=BQ[i]-&gt;builderUI-&gt;ud-&gt;buildSpeed/BQ[i]-&gt;creationUD-&gt;ud-&gt;energyCost;
+		}
+	}
+}
+*/
+bool cBuilder::MetalIsFavorable(float storage,float production)
+{
+	if( UDR-&gt;BLMetalL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLMetal-&gt;UDefSize == 0 )
+		return true;
+	if( cb-&gt;GetMetalIncome() &gt; 5.0*(cb-&gt;GetMetalUsage()-BuilderMetalDebug) )
+		return true;
+	if( (cb-&gt;GetMetal() &gt; storage*cb-&gt;GetMetalStorage() || cb-&gt;GetMetalIncome() &gt; 0.33*cb-&gt;GetMetalStorage() ) &amp;&amp; cb-&gt;GetMetalIncome() &gt; production*(cb-&gt;GetMetalUsage()-BuilderMetalDebug) )
+		return true;
+	return false;
+}
+
+bool cBuilder::EnergyIsFavorable(float storage,float production)
+{
+	if( UDR-&gt;BLEnergyL-&gt;UDefSize == 0 &amp;&amp; UDR-&gt;BLEnergy-&gt;UDefSize == 0 )
+		return true;
+	if( (cb-&gt;GetEnergy() &gt; storage*cb-&gt;GetEnergyStorage() || cb-&gt;GetEnergyIncome() &gt; 0.33*cb-&gt;GetEnergyStorage() ) &amp;&amp; cb-&gt;GetEnergyIncome() &gt; production*(cb-&gt;GetEnergyUsage()-BuilderEnergyDebug) )
+		return true;
+	return false;
+}
+
+void cBuilder::BQAssignBuilder(int index, const int&amp; unit, UnitInfo* U)
+{
+//	*l&lt;&lt;&quot;\nBQAssignBuilder(&quot;&lt;&lt;BQ[index]-&gt;creationUD-&gt;ud-&gt;humanName&lt;&lt;&quot;,&quot;&lt;&lt;unit&lt;&lt;&quot;,&quot;&lt;&lt;(U==0?&quot;-&quot;:U-&gt;ud-&gt;humanName)&lt;&lt;&quot;)&quot;;
+	if( BQ[index]-&gt;builderID &gt;= 0 )
+	{
+		const UnitDef* ud=BQ[index]-&gt;builderUI-&gt;ud;
+		ConEnergyLost+=int(ud-&gt;energyCost);
+		ConMetalLost+=int(ud-&gt;metalCost);
+		ConEnergyDrain+=int(ud-&gt;energyCost/(ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+		ConMetalDrain+=int(ud-&gt;metalCost/(ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+
+		BQ[index]-&gt;builderUI-&gt;BuildQ=0;
+		if( U!= 0 &amp;&amp; U-&gt;BuildQ != 0 )
+			U-&gt;BuildQ-&gt;builderID=-1;
+		if( BQ[index]-&gt;RS != 0 )
+		{
+			BQ[index]-&gt;RS-&gt;builderID = -1;
+			BQ[index]-&gt;SetRS(0);
+		}
+	}
+	BQ[index]-&gt;builderID=unit;
+	BQ[index]-&gt;builderUI=U;
+	if( unit &gt;= 0 )
+	{
+		BQ[index]-&gt;deletionFrame=1200+cb-&gt;GetCurrentFrame();
+		ConEnergyLost-=int(U-&gt;ud-&gt;energyCost);
+		ConMetalLost-=int(U-&gt;ud-&gt;metalCost);
+		ConEnergyDrain-=int(U-&gt;ud-&gt;energyCost/(U-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+		ConMetalDrain-=int(U-&gt;ud-&gt;metalCost/(U-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+		BQ[index]-&gt;builderUI-&gt;BuildQ=BQ[index];
+		float3 pos = cb-&gt;GetUnitPos(unit);
+		if( BP-&gt;NeedResourceSite(BQ[index]-&gt;creationUD-&gt;ud) )
+		{
+			ResourceSiteExt* RS = BP-&gt;FindResourceSite(pos,BQ[index]-&gt;creationUD-&gt;ud,U-&gt;area);
+			BQ[index]-&gt;SetRS(RS);
+			if( RS != 0 )
+			{
+				BQ[index]-&gt;RS-&gt;builderID = unit;
+				BQ[index]-&gt;RS-&gt;builderUI = U;
+			}
+		}
+	}
+}
+/*
+void cBuilder::BQAssignConstruct(int index, const int&amp; unit, sRAIUnitDef *udr)
+{
+
+}
+*/
+void cBuilder::BQAdd(sRAIUnitDef *udr, sRAIBuildList *BL, int type)
+{
+//	*l&lt;&lt;&quot;\n (New Build Order Added): &quot;+udr-&gt;ud-&gt;humanName;
+	BQ[BQSize[0]] = new sBuildQuarry(BL);
+	BQ[BQSize[0]]-&gt;index = BQSize[0];
+	BQ[BQSize[0]]-&gt;creationUD=udr;
+	BQ[BQSize[0]]-&gt;creationUDID=udr-&gt;ud-&gt;id;
+	BQ[BQSize[0]]-&gt;type = type;
+	BQ[BQSize[0]]-&gt;deletionFrame=1200+cb-&gt;GetCurrentFrame();
+	BQSize[0]++;
+	BQSize[type]++;
+	udr-&gt;UnitConstructs++;
+	udr-&gt;CheckUnitLimit();
+	ConEnergyLost+=int(udr-&gt;ud-&gt;energyCost);
+	ConMetalLost+=int(udr-&gt;ud-&gt;metalCost);
+	ConEnergyDrain+=int(udr-&gt;ud-&gt;energyCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+	ConMetalDrain+=int(udr-&gt;ud-&gt;metalCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+	ConEnergyRate+=int(udr-&gt;EnergyDifference);
+	ConMetalRate+=int(udr-&gt;MetalDifference);
+	ConEnergyStorage+=int(udr-&gt;ud-&gt;energyStorage);
+	ConMetalStorage+=int(udr-&gt;ud-&gt;metalStorage);
+}
+
+void cBuilder::BQRemove(int index)
+{
+	if( BQ[index] == Prerequisite )
+	{
+		Prerequisite = 0;
+	}
+
+	sRAIUnitDef *udr=BQ[index]-&gt;creationUD;
+	if( BQ[index]-&gt;builderID &gt;= 0 )
+	{
+		BuilderIDDebug = BQ[index]-&gt;builderID;
+		BuilderFrameDebug = cb-&gt;GetCurrentFrame();
+	}
+
+	BQAssignBuilder(index,-1,0);
+	BQSize[0]--;
+	BQSize[BQ[index]-&gt;type]--;
+	udr-&gt;UnitConstructs--;
+	udr-&gt;CheckUnitLimit();
+
+	ConEnergyLost-=int(udr-&gt;ud-&gt;energyCost);
+	ConMetalLost-=int(udr-&gt;ud-&gt;metalCost);
+	ConEnergyDrain-=int(udr-&gt;ud-&gt;energyCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+	ConMetalDrain-=int(udr-&gt;ud-&gt;metalCost/(udr-&gt;ud-&gt;buildTime/UDR-&gt;AverageConstructSpeed));
+
+	ConEnergyRate-=int(udr-&gt;EnergyDifference);
+	ConMetalRate-=int(udr-&gt;MetalDifference);
+	ConEnergyStorage-=int(udr-&gt;ud-&gt;energyStorage);
+	ConMetalStorage-=int(udr-&gt;ud-&gt;metalStorage);
+
+	sBuildQuarry *sTemp=BQ[index];
+	BQ[index]=BQ[BQSize[0]];
+	BQ[BQSize[0]]=sTemp;
+	BQ[index]-&gt;index=index;
+
+	for( list&lt;int&gt;::iterator i=BQ[BQSize[0]]-&gt;creationID.begin(); i!=BQ[BQSize[0]]-&gt;creationID.end(); i++ )
+		if( UConstruction.find(*i) != UConstruction.end() )
+		{
+			if( cb-&gt;UnitBeingBuilt(*i) )
+				UConstruction.find(*i)-&gt;second.BQAbandoned=true;
+			else
+				UConstruction.erase(*i); // Remove from construction list
+		}
+
+	delete BQ[BQSize[0]];
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/Builder.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/Builder.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/Builder.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/Builder.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,145 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_BUILDER_H
+#define RAI_BUILDER_H
+
+struct sBuildQuarry;
+class cBuilder;
+
+#include &quot;RAI.h&quot;
+#include &quot;PowerManager.h&quot;
+//#include &lt;map&gt;
+//#include &lt;set&gt;
+#include &lt;deque&gt;
+#include &lt;list&gt;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+
+struct sBuildQuarry
+{
+	sBuildQuarry(sRAIBuildList *buildlist);
+	~sBuildQuarry();
+	bool IsValid(int frame);
+	void SetRS(ResourceSiteExt *rs);
+
+	int builderID;			// ID of the assigned builder, otherwise -1
+	UnitInfo *builderUI;	// valid if 'builderID' is set
+	list&lt;int&gt; creationID;   // ID of who is being built, I defined this as an array to work around a bug involving misordered calls of UnitDestroyed, UnitCreated - in other words at rare temporary moments this list will hold 2 unit ids.   Spring-Version(v0.72b1-0.73b1)
+	int creationUDID;		// ID of what is being built
+	sRAIUnitDef *creationUD;// always valid
+	ResourceSiteExt *RS;		// The resource this must be built at
+	sRAIBuildList *BL;		// used to update unitsActive
+
+	int index;				// stores the index value of its own array
+	int type;				// 1=Normal,2=Energy,3=Metal,4=Constructor,5=Energy Storage,6=Metal Storage,7=prerequisite
+	int deletionFrame;		// If a unit does not choose to build the option by this frame, then delete the Build Quarry
+	int tryCount;			// failed to build, probably due to enemy attacks
+};
+
+class cBuilder
+{
+public:
+	cBuilder(IAICallback *callback, cRAI *global);
+	virtual ~cBuilder();
+
+	void UnitCreated(const int&amp; unit, UnitInfo *U);
+	void UnitFinished(const int&amp; unit, UnitInfo *U);
+	void UnitDestroyed(const int&amp; unit, UnitInfo *U);
+	void UnitAssignBuildList(const int&amp; unit, UnitInfo *U, bool bInitialized=false); // bInitialized is unused, was ment to support a unit changing tasks
+
+	void UBuilderFinished(const int&amp; unit, UnitInfo *U);
+	void UBuilderDestroyed(const int&amp; unit, UnitInfo *U);
+	void UBuilderIdle(const int&amp; unit, UnitInfo *U);
+//	void UBuilderDamaged(const int&amp; unit,int attacker,float3 dir);
+	bool UBuilderMoveFailed(const int&amp; unit, UnitInfo *U); // returns true if a solution was found
+	void HandleEvent(const IGlobalAI::PlayerCommandEvent *pce);
+	void UpdateUDRCost();
+	void UpdateKnownFeatures(const int&amp; unit, UnitInfo *U);
+
+	bool bInitiated;	// initialized as false, set to true after set conditions have been meet, usually about 30-60 frames into the game
+	cPowerManager *PM;
+	cBuilderPlacement *BP;
+
+	map&lt;int,UnitInfo*&gt; UBuilder;	// List of builders, key value = unit ID
+	map&lt;int,UnitInfo*&gt; UNanos;
+	set&lt;int&gt; Decomission;			// Builders will reclaim these units in there free time
+private:
+	cRAI *G;
+	cRAIUnitDefHandler *UDR;// G-&gt;UDH
+	cLogFile *l;			// G-&gt;l
+	IAICallback *cb;		// G-&gt;cb
+
+	void CreateBuildOrders();
+	int LastBuildOrder;
+
+	float MCostLimit;
+	float ECostLimit;
+//	float MCostUpdate;
+//	float ECostUpdate;
+
+	// Work-Around for bugs functions GetMetalUsage() &amp; GetEnergyUsage()
+	// spring does not update the values by the time build idle is called, as a result the
+	// economy would think that the resources are more strained than they really are.
+	float BuilderEnergyDebug;	// updated at the beginning of UBuilderIdle
+	float BuilderMetalDebug;	// updated at the beginning of UBuilderIdle
+	int BuilderIDDebug;			// ID of the last builder to finish a task
+	int BuilderFrameDebug;		// the frame that 'BuilderIDDebug' was last changed
+//	double ConstructMetalUsage;
+//	double ConstructEnergyUsage;
+
+	int ConEnergyLost;
+	int ConMetalLost;
+	int ConEnergyDrain;		// How much Energy will be drained when all constructions have started, positive value, does not include contructions that have already begun
+	int ConMetalDrain;		// How much Metal will be drained when all constructions have started, positive value, does not include contructions that have already begun
+	int ConEnergyRate;		// How much extra Energy will be produced when all constructions have completed 
+	int ConMetalRate;		// How much extra Metal will be produced when all constructions have completed
+	int ConEnergyStorage;	// How much extra Energy Storage will there be when all constructions have completed
+	int ConMetalStorage;	// How much extra Metal Storage will there be when all constructions have completed
+	bool MetalIsFavorable(float storage=0.50f,float production=1.0f); // returns true if there is no metal production or the ratio of both is met
+	bool EnergyIsFavorable(float storage=0.50f,float production=1.0f); // returns true if there is no energy production or the ratio of both is met
+
+	sBuildQuarry *BQ[40];
+	sBuildQuarry *Prerequisite; // Limits RAI from building more than one at a time
+	int BQSize[8]; // index 0 = total, other indexs accessed by iType.  Value of index is equal to counter
+	void BQAssignBuilder(int index, const int&amp; unit, UnitInfo* U);
+//	void BQAssignConstruct(int index, const int&amp; unit, sRAIUnitDef *udr);
+	void BQAdd(sRAIUnitDef *udr, sRAIBuildList *BL, int type);
+	void BQRemove(int index);
+
+	struct UnitConstructionInfo
+	{
+		UnitConstructionInfo(sBuildQuarry *BuildQuarry, const int&amp; unit, UnitInfo* UI)
+		{
+			U=UI;
+			unitID = unit;
+			BQ = BuildQuarry;
+			BQ-&gt;creationID.push_front(unit);
+			BQAbandoned=false;
+		};
+		~UnitConstructionInfo()
+		{
+		};
+
+		bool BQAbandoned;
+		sBuildQuarry *BQ; // valid if BQAbandoned=false
+		UnitInfo *U;	// Always valid
+		int unitID;
+	};
+	map&lt;int,UnitConstructionInfo&gt; UConstruction;	// List of what is being built, key value = unit ID
+
+	// due to crash bugs in spring 0.74b3, the position is about the only safe information that could be gathered and stored.
+	typedef pair&lt;int,float3&gt; ifPair;
+	map&lt;int,float3&gt; FeatureDebris;			// List of features that are blocking the paths of our units
+	typedef pair&lt;int,FeatureDef*&gt; ifdPair;
+	map&lt;int,float3&gt; MetalDebris;			// List of metal reclaimables found
+	map&lt;int,float3&gt; EnergyDebris;			// List of energy reclaimables found
+	map&lt;int,float3&gt; ResDebris;				// List of resurrectables found
+	typedef pair&lt;string,sRAIUnitDef*&gt; srPair;
+	map&lt;string,sRAIUnitDef*&gt; UDRResurrect;	// List of what can be resurrected
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/Builder.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,1365 @@
+#include &quot;BuilderPlacement.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+#include &lt;set&gt;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+#include &lt;time.h&gt;
+
+ResourceSiteExtBO::ResourceSiteExtBO(sRAIUnitDef* UDR )
+{
+	udr=UDR;
+	CanBuild=false;
+	RBRanged=true;
+	RBBlocked=false;
+	RBRanked=false;
+}
+
+void ResourceSiteExtBO::CheckBuild()
+{
+	if( RBBlocked || RBRanked || RBRanged )
+	{
+		if( CanBuild )
+		{
+			CanBuild=false;
+			udr-&gt;SetULConstructs(udr-&gt;UnitLimit[1]-1);
+		}
+	}
+	else
+	{
+		if( !CanBuild )
+		{
+			CanBuild=true;
+			udr-&gt;SetULConstructs(udr-&gt;UnitLimit[1]+1);
+		}
+	}
+}
+
+ResourceSiteExt::ResourceSiteExt(ResourceSite *RSite, IAICallback* callback)
+{
+	cb=callback;
+	S=RSite;
+	unitID=-1;
+	builderID=-1;
+	ally=false;
+	enemy=false;
+	if( S-&gt;featureID == -1 ) // Metal-Site
+	{
+		searchRadius=cb-&gt;GetExtractorRadius()/2.0f;
+		if( searchRadius &lt; 16.0f )
+			searchRadius = 16.0f;
+	}
+	else // Geo-Site
+	{
+		searchRadius=48.0f;
+	}
+	disApart=3;
+};
+
+void ResourceSiteExt::CheckBlocked()
+{
+	for( map&lt;int,ResourceSiteExtBO&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+	{
+		float3 fBuildSite=cb-&gt;ClosestBuildSite(iB-&gt;second.udr-&gt;ud,S-&gt;position,searchRadius,disApart);
+		if( !cb-&gt;CanBuildAt(iB-&gt;second.udr-&gt;ud,fBuildSite) &amp;&amp; (unitID == -1 || enemy || ally ) )
+			iB-&gt;second.RBBlocked=true;
+		else
+			iB-&gt;second.RBBlocked=false;
+		iB-&gt;second.CheckBuild();
+	}
+}
+
+void ResourceSiteExt::CheckRanked()
+{
+	for( map&lt;int,ResourceSiteExtBO&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+	{
+		if( unitID == -1 ||
+			( S-&gt;type == 0 &amp;&amp; iB-&gt;second.udr-&gt;ud-&gt;extractsMetal &gt;= 1.5*unitUD-&gt;ud-&gt;extractsMetal ) ||
+			( S-&gt;type == 1 &amp;&amp; iB-&gt;second.udr-&gt;ud-&gt;metalCost &gt;= 1.85*unitUD-&gt;ud-&gt;metalCost &amp;&amp; (unitUD-&gt;ud-&gt;techLevel &lt;= 0 || iB-&gt;second.udr-&gt;ud-&gt;techLevel &gt; unitUD-&gt;ud-&gt;techLevel ) ) )
+		{
+			iB-&gt;second.RBRanked = false;
+		}
+		else
+		{
+			iB-&gt;second.RBRanked = true;
+		}
+		iB-&gt;second.CheckBuild();
+	}
+}
+
+void ResourceSiteExt::SetRanged(bool inRange)
+{
+	for( map&lt;int,ResourceSiteExtBO&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+	{
+		iB-&gt;second.RBRanged = !inRange;
+		iB-&gt;second.CheckBuild();
+	}
+}
+
+cBuilderPlacement::cBuilderPlacement(IAICallback* callback, cRAI* global)
+{
+	G=global;
+	l=global-&gt;l;
+	cb=callback;
+	*l&lt;&lt;&quot;\nLoading Build-Placement ...&quot;;
+	const double SecondAlgorithmTimeLimit = 2.5; // seconds per RAI
+
+	double clockStart = clock();
+
+	if( int(G-&gt;Units.size()) == 0 )
+		*l&lt;&lt;&quot;\nERROR: G-&gt;Units&quot;;
+
+	int unitLimit;
+	cb-&gt;GetValue(AIVAL_UNIT_LIMIT,&amp;unitLimit);
+	if( unitLimit &gt; 500 ) // Can't think of a reason to ever have this higher, but resource linking could take really long
+		unitLimit = 500;
+	float3 StartPosition=cb-&gt;GetUnitPos(G-&gt;Units.begin()-&gt;first);
+	int MetalSiteLimit = G-&gt;RM-&gt;RSize[0];
+	if( MetalSiteLimit &gt; unitLimit/6 )
+		MetalSiteLimit = unitLimit/6;
+	int GeoSiteLimit = G-&gt;RM-&gt;RSize[1];
+	if( GeoSiteLimit &gt; unitLimit/6 )
+		GeoSiteLimit = unitLimit/6;
+	Resources = new ResourceSiteExt*[MetalSiteLimit+GeoSiteLimit];
+	ResourceSize = 0;
+
+	*l&lt;&lt;&quot;\n Metal-Site limit : &quot;&lt;&lt;MetalSiteLimit;
+	*l&lt;&lt;&quot;\n Geo-Site limit : &quot;&lt;&lt;GeoSiteLimit;
+
+	// Finding and using the Nearest Metal-Sites
+	set&lt;int&gt; Seleted;
+	for( int iM=0; iM&lt;MetalSiteLimit &amp;&amp; iM&lt;G-&gt;RM-&gt;RSize[0]; iM++ )
+	{
+		int iBest=-1;
+		float fBest;
+		for( int iR=0; iR&lt;G-&gt;RM-&gt;RSize[0]; iR++ )
+		{	// Cycles through only metal-sites
+			if( Seleted.find(iR) == Seleted.end() )
+				if( iBest == -1 || StartPosition.distance2D(G-&gt;RM-&gt;R[0][iR]-&gt;position) &lt; fBest )
+				{
+					iBest=iR;
+					fBest=StartPosition.distance2D(G-&gt;RM-&gt;R[0][iR]-&gt;position);
+				}
+		}
+		Seleted.insert(iBest);
+		Resources[ResourceSize++] = new ResourceSiteExt(G-&gt;RM-&gt;R[0][iBest],cb);
+	}
+
+	// Finding and using the Nearest Geo-Sites
+	Seleted.clear();
+	for( int iG=0; iG&lt;GeoSiteLimit &amp;&amp; iG&lt;G-&gt;RM-&gt;RSize[1]; iG++ )
+	{
+		int iBest=-1;
+		float fBest;
+		for( int iR=0; iR&lt;G-&gt;RM-&gt;RSize[1]; iR++ )
+		{	// Cycles through only geo-sites
+			if( Seleted.find(iR) == Seleted.end() )
+				if( iBest == -1 || StartPosition.distance2D(G-&gt;RM-&gt;R[1][iR]-&gt;position) &lt; fBest )
+				{
+					iBest=iR;
+					fBest=StartPosition.distance2D(G-&gt;RM-&gt;R[1][iR]-&gt;position);
+				}
+		}
+		Seleted.insert(iBest);
+		Resources[ResourceSize++] = new ResourceSiteExt(G-&gt;RM-&gt;R[1][iBest],cb);
+	}
+
+	// Updating BuildOptions and Resources, some units may have been disabled
+	typedef pair&lt;int,ResourceSiteExtBO&gt; irbPair;
+	typedef pair&lt;ResourceSite*,ResourceSiteDistance&gt; rrPair;
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+	{
+		if( Resources[iR]-&gt;S-&gt;type == 0 )
+		{
+			sRAIBuildList *BL = G-&gt;UDH-&gt;BLMetalL;
+			for( int i=0; i&lt;BL-&gt;UDefSize; i++ )
+			{
+				sRAIUnitDef* udr=BL-&gt;UDef[i]-&gt;RUD;
+				if( Resources[iR]-&gt;S-&gt;options.find(udr-&gt;ud-&gt;id) != Resources[iR]-&gt;S-&gt;options.end() )
+					Resources[iR]-&gt;BuildOptions.insert(irbPair(udr-&gt;ud-&gt;id,ResourceSiteExtBO(udr)));
+			}
+		}
+		else if( Resources[iR]-&gt;S-&gt;type == 1 )
+		{
+			// Units using Geo-Sites can be found in any number of build lists
+			for( map&lt;int,sRAIUnitDef&gt;::iterator iUD=G-&gt;UDH-&gt;UDR.begin(); iUD!=G-&gt;UDH-&gt;UDR.end(); iUD++ )
+			{
+				if( iUD-&gt;second.ud-&gt;needGeo &amp;&amp; !iUD-&gt;second.Disabled &amp;&amp; int(iUD-&gt;second.PrerequisiteOptions.size()) &gt; 0 )
+				{
+					if( Resources[iR]-&gt;S-&gt;options.find(iUD-&gt;second.ud-&gt;id) != Resources[iR]-&gt;S-&gt;options.end() )
+						Resources[iR]-&gt;BuildOptions.insert(irbPair(iUD-&gt;second.ud-&gt;id,ResourceSiteExtBO(&amp;iUD-&gt;second)));
+				}
+			}
+		}
+
+		if( int(Resources[iR]-&gt;S-&gt;siteDistance.size()) == 0 || int(Resources[iR]-&gt;S-&gt;siteDistance.size()) &lt; G-&gt;RM-&gt;RSize[0]+G-&gt;RM-&gt;RSize[1] )
+		{
+			// Cheap distance calculations, although this is still too much to calculate for all map resources
+			for( int iR2=0; iR2&lt;ResourceSize; iR2++ )
+				if( Resources[iR]-&gt;S-&gt;siteDistance.find(Resources[iR2]-&gt;S) == Resources[iR]-&gt;S-&gt;siteDistance.end() )
+					Resources[iR]-&gt;S-&gt;siteDistance.insert(rrPair(Resources[iR2]-&gt;S,ResourceSiteDistance(Resources[iR]-&gt;S-&gt;position.distance2D(Resources[iR2]-&gt;S-&gt;position))));
+		}
+
+		// Old Code, Unneeded?  Caused by: the old RAI style's handling of a Metal-Map
+		if( int(Resources[iR]-&gt;BuildOptions.size()) == 0 )
+		{
+			float3* p = &amp;Resources[iR]-&gt;S-&gt;position;
+			*l&lt;&lt;&quot;\nERROR: &quot;&lt;&lt;(Resources[iR]-&gt;S-&gt;type==0?&quot;Metal&quot;:&quot;Energy&quot;)&lt;&lt;&quot; Resource located at (x&quot;&lt;&lt;p-&gt;x;
+			*l&lt;&lt;&quot; z&quot;&lt;&lt;p-&gt;z&lt;&lt;&quot; y&quot;&lt;&lt;p-&gt;y&lt;&lt;&quot;) can not be built at.&quot;;
+			*l&lt;&lt;&quot; size=&quot;&lt;&lt;Resources[iR]-&gt;S-&gt;options.size();
+			delete Resources[iR];
+			Resources[iR] = Resources[ResourceSize-1];
+			ResourceSize--;
+			iR--;
+		}
+		else
+			RSRemaining.insert(irPair(iR,Resources[iR]));
+	}
+	*l&lt;&lt;&quot;\n Resources in use : &quot;&lt;&lt;ResourceSize;
+
+	if( ResourceSize == 0 )
+		return;
+
+	// Read all movetypes
+	int arraySize = G-&gt;TM-&gt;mobileType.size();
+	basicArray&lt;TerrainMapMobileType*&gt; MobileTypes(arraySize);
+	for( list&lt;TerrainMapMobileType&gt;::iterator iM=G-&gt;TM-&gt;mobileType.begin(); iM!=G-&gt;TM-&gt;mobileType.end(); iM++ )
+		MobileTypes.push_back(&amp;*iM);
+
+	// Sort them by worst to best, remove unusable movetypes
+	for( int iM=0; iM&lt;MobileTypes.size()-1; iM++)
+	{
+		if( (*MobileTypes[iM])-&gt;areaLargest == 0 )
+		{
+			MobileTypes.removeE(iM);
+			iM--;
+		}
+		else if( (*MobileTypes[iM+1])-&gt;areaLargest == 0 )
+		{
+			MobileTypes.removeE(iM+1);
+			iM--;
+		}
+		else if( (*MobileTypes[iM])-&gt;areaLargest-&gt;percentOfMap &gt; (*MobileTypes[iM+1])-&gt;areaLargest-&gt;percentOfMap ||
+				((*MobileTypes[iM])-&gt;areaLargest-&gt;percentOfMap == (*MobileTypes[iM+1])-&gt;areaLargest-&gt;percentOfMap &amp;&amp; (*MobileTypes[iM])-&gt;maxSlope &gt; (*MobileTypes[iM+1])-&gt;maxSlope) )
+		{
+//*l&lt;&lt;&quot;\n  MT(&quot;&lt;&lt;(*MobileTypes[iM])-&gt;MD-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;iM&lt;&lt;&quot;&lt;-&gt;&quot;&lt;&lt;iM+1&lt;&lt;&quot; &quot;&lt;&lt;(*MobileTypes[iM+1])-&gt;MD-&gt;name&lt;&lt;&quot;)&quot;;
+			MobileTypes.swap(iM,iM+1);
+			iM--;
+			if( iM != -1 )
+				iM --;
+		}
+	}
+
+	TerrainMapMobileType* MT;
+//	for( MobileTypes.begin(); MobileTypes.nextE(MT); )
+//		*l&lt;&lt;&quot;\n  MoveType=&quot;&lt;&lt;MT-&gt;MD-&gt;name&lt;&lt;&quot; pathType=&quot;&lt;&lt;MT-&gt;MD-&gt;pathType;
+
+	// First Link Algorithm
+	double linkStartClock = clock();
+	TerrainMapArea* Area;
+	for( int iR1=0; iR1&lt;ResourceSize; iR1++ )
+		for( int iR2=iR1+1; iR2&lt;ResourceSize; iR2++ )
+			for( MobileTypes.begin(); MobileTypes.nextE(MT); )
+				if( (Area = MT-&gt;sector[G-&gt;TM-&gt;GetSectorIndex(Resources[iR1]-&gt;S-&gt;position)].area) == 0 ||
+					Area != MT-&gt;sector[G-&gt;TM-&gt;GetSectorIndex(Resources[iR2]-&gt;S-&gt;position)].area )
+				{
+					Resources[iR1]-&gt;S-&gt;siteDistance.find(Resources[iR2]-&gt;S)-&gt;second.distance.insert(ifPair(MT-&gt;MD-&gt;pathType,-2.0));
+					Resources[iR2]-&gt;S-&gt;siteDistance.find(Resources[iR1]-&gt;S)-&gt;second.distance.insert(ifPair(MT-&gt;MD-&gt;pathType,-2.0));
+				}
+	set&lt;int&gt; RSList1; // sites that are so far connected
+	set&lt;int&gt; RSList2; // sites that have yet to be connected
+	RSList1.insert(0);
+	for( int i=1; i&lt;ResourceSize; i++ )
+		RSList2.insert(i);
+	int iM = 0; // current moveType index
+	while( int(RSList2.size()) &gt; 0 )
+	{
+		if( iM &gt;= MobileTypes.size() )
+			iM = -1; // None of the moveTypes worked, just ignore terrain this time around
+		int bestI1;
+		int bestI2;
+		int pathType;
+		float dis; // temp
+		bestI1 = -1;
+		if( iM == -1 )
+			pathType = -1;
+		else
+		{
+			MT = (*MobileTypes[iM]);
+			pathType = MT-&gt;MD-&gt;pathType;
+		}
+//*l&lt;&lt;&quot;\n RSL2size=&quot;&lt;&lt;RSList2.size()&lt;&lt;&quot; iM=&quot;&lt;&lt;iM;
+		for( set&lt;int&gt;::iterator iR1=RSList1.begin(); iR1!=RSList1.end(); iR1++ )
+			if( iM == -1 || MT-&gt;sector[G-&gt;TM-&gt;GetSectorIndex(Resources[*iR1]-&gt;S-&gt;position)].area != 0 )
+			{
+//*l&lt;&lt;&quot; r1=&quot;&lt;&lt;*iR1;
+				for( set&lt;int&gt;::iterator iR2=RSList2.begin(); iR2!=RSList2.end(); iR2++ )
+				{
+//*l&lt;&lt;&quot; r2=&quot;&lt;&lt;*iR2;
+					dis = Resources[*iR1]-&gt;S-&gt;GetResourceDistance(Resources[*iR2]-&gt;S,pathType);
+					if( dis &gt; 0 &amp;&amp; (bestI1 == -1 || Resources[bestI1]-&gt;S-&gt;GetResourceDistance(Resources[bestI2]-&gt;S,pathType) &gt; dis) )
+					{
+						bestI1=*iR1;
+						bestI2=*iR2;
+					}
+				}
+			}
+		if( bestI1 == -1 )
+		{	// Nothing selected, try again with a different moveType
+//*l&lt;&lt;&quot;m&quot;;
+			iM++;
+		}
+		else if( iM &gt;= 0 &amp;&amp; Resources[bestI1]-&gt;S-&gt;siteDistance.find(Resources[bestI2]-&gt;S)-&gt;second.bestDistance == 0 )
+		{	// The best choice distance has yet to be calculated
+//*l&lt;&lt;&quot;r&quot;;
+			FindResourceDistance(Resources[bestI1]-&gt;S,Resources[bestI2]-&gt;S,MT-&gt;MD-&gt;pathType);
+		}
+		else
+		{
+//*l&lt;&lt;&quot;s&quot;;
+			RSList1.insert(bestI2);
+			RSList2.erase(bestI2);
+			Resources[bestI1]-&gt;Linked.insert(irPair(bestI2,Resources[bestI2]));
+			Resources[bestI2]-&gt;Linked.insert(irPair(bestI1,Resources[bestI1]));
+			if( iM == -1 )
+			{
+				Resources[bestI1]-&gt;S-&gt;siteDistance.find(Resources[bestI2]-&gt;S)-&gt;second.bestDistance = &amp;Resources[bestI1]-&gt;S-&gt;siteDistance.find(Resources[bestI2]-&gt;S)-&gt;second.minDistance;
+				Resources[bestI2]-&gt;S-&gt;siteDistance.find(Resources[bestI1]-&gt;S)-&gt;second.bestDistance = &amp;Resources[bestI2]-&gt;S-&gt;siteDistance.find(Resources[bestI1]-&gt;S)-&gt;second.minDistance;
+			}
+			iM = 0;
+		}
+	}
+	*l&lt;&lt;&quot;\n First Link Algorithm Loading Time: &quot;&lt;&lt;(clock()-linkStartClock)/CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+
+	// Second Link Algorithm
+	linkStartClock = clock();
+	float *MTPenalty; // the moveData*-&gt;pathType is the index to MTPenalty
+	int MTPenaltySize = 0;
+	for( MobileTypes.begin(); MobileTypes.nextE(MT); )
+	{
+		if( MTPenaltySize &lt; MT-&gt;MD-&gt;pathType+1 )
+			MTPenaltySize = MT-&gt;MD-&gt;pathType+1;
+	}
+	MTPenalty = new float[MTPenaltySize+1]; // the last index is for the flying movetype
+	for( int iMP=0; iMP&lt;MTPenaltySize; iMP++)
+		MTPenalty[iMP] = -1.0;
+	int linkCount = 0;
+	for( MobileTypes.begin(); MobileTypes.nextE(MT); )
+//	for( vector&lt;TerrainMapMobileType*&gt;::iterator iMT=MobileTypes.begin(); iMT!=MobileTypes.end(); iMT++ )
+	{
+		MTPenalty[MT-&gt;MD-&gt;pathType] = linkCount;
+
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+			for(map&lt;int,ResourceSiteExt*&gt;::iterator iRL = Resources[iR]-&gt;Linked.begin(); iRL != Resources[iR]-&gt;Linked.end(); iRL++ )
+				if( iRL-&gt;second-&gt;S-&gt;siteDistance.find(Resources[iR]-&gt;S)-&gt;second.bestPathType == MT-&gt;MD-&gt;pathType )
+					linkCount++;
+	}
+	for( int iMP=0; iMP&lt;MTPenaltySize; iMP++)
+		if( MTPenalty[iMP] &gt;= 0.0 )
+		{
+//*l&lt;&lt;&quot;\n &quot;&lt;&lt;MTPenalty[iMP]&lt;&lt;&quot;/&quot;&lt;&lt;linkCount;
+			MTPenalty[iMP] = linkCount/(1+linkCount*1.10-MTPenalty[iMP]);
+			if( MTPenalty[iMP] &lt; 1.0 )
+				MTPenalty[iMP] = 1.0;
+			else if( MTPenalty[iMP] &gt; 5.0 )
+				MTPenalty[iMP] = 5.0;
+//*l&lt;&lt;&quot; MTPenalty[&quot;&lt;&lt;iMP&lt;&lt;&quot;]=&quot;&lt;&lt;MTPenalty[iMP];
+		}
+	MTPenalty[MTPenaltySize] = 20.0;
+
+	int **RMT = new int*[ResourceSize]; // Resource MoveType, 2 dimensional array
+	float **RD = new float*[ResourceSize]; // Resource Distances, Local Copy, 2 dimensional array
+	ResourceSiteDistance* RSD;
+	for( int iR1=0; iR1&lt;ResourceSize; iR1++ )
+	{
+		RMT[iR1] = new int[ResourceSize];
+		RD[iR1] = new float[ResourceSize];
+		for( int iR2=0; iR2&lt;ResourceSize; iR2++ )
+			RD[iR1][iR2] = -1.0;
+	}
+	for( int iR1=0; iR1&lt;ResourceSize; iR1++ )
+		for( int iR2=iR1+1; iR2&lt;ResourceSize; iR2++ )
+		{
+			RMT[iR1][iR2] = MTPenaltySize;
+			RMT[iR2][iR1] = MTPenaltySize;
+			RSD = &amp;Resources[iR1]-&gt;S-&gt;siteDistance.find(Resources[iR2]-&gt;S)-&gt;second;
+			if( RSD-&gt;bestDistance != 0 )
+			{
+				if( RSD-&gt;bestPathType &gt;= 0 )
+				{
+					RMT[iR1][iR2] = RSD-&gt;bestPathType;
+					RMT[iR2][iR1] = RSD-&gt;bestPathType;
+				}
+			}
+			else
+				for( MobileTypes.begin(); MobileTypes.nextE(MT); )
+					if( RSD-&gt;distance.find(MT-&gt;MD-&gt;pathType) == RSD-&gt;distance.end() )
+					{
+						RMT[iR1][iR2] = MT-&gt;MD-&gt;pathType;
+						RMT[iR2][iR1] = MT-&gt;MD-&gt;pathType;
+						break;
+					}
+		}
+
+	basicArray&lt;ResourceLinkInfo&gt; RLIList(ResourceSize);
+	ResourceLinkInfo *RLI;
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+		if( Resources[iR]-&gt;Linked.size() &lt; 3 )
+		{
+			RLI = RLIList.push_back();
+			RLI-&gt;index = iR;
+			RLI-&gt;bestI = -1;
+			RLI-&gt;restrictedR.insert(iR);
+			for(map&lt;int,ResourceSiteExt*&gt;::iterator iRL = Resources[iR]-&gt;Linked.begin(); iRL != Resources[iR]-&gt;Linked.end(); iRL++ )
+				RLI-&gt;restrictedR.insert(iRL-&gt;first);
+		}
+//	*l&lt;&lt;&quot;\n   Second Link Loading Time 0: &quot;&lt;&lt;(clock()-linkStartClock)/(double)CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+
+//	double linkClock1 = 0;
+//	double linkClock2 = 0;
+//	double linkClock3 = 0;
+//	double linkClock4 = 0;
+//	double linkClockTemp;
+	while( RLIList.elementSize &gt; 0 &amp;&amp; (clock()-linkStartClock)/(double)CLOCKS_PER_SEC &lt;= SecondAlgorithmTimeLimit )
+	{
+//*l&lt;&lt;&quot;\n&quot;;
+		// Cycle through RLIList to find the closest resource pair available (with consideration to other factors)
+		bool resetLink,acceptLink;
+		ResourceLinkInfo *bestRLI = 0;
+//		linkClockTemp = clock();
+		for( RLIList.begin(); RLIList.nextE(RLI); )
+		{
+			if( RLI-&gt;bestI == -2 ) // The best link was found &amp; rejected in latter code
+				RLIList.removeE();
+			else
+			{
+				if( RLI-&gt;bestI == -1 ) // has not been found yet
+				{
+					for( int iR2=0; iR2&lt;ResourceSize; iR2++ )
+						if( RLI-&gt;restrictedR.find(iR2) == RLI-&gt;restrictedR.end() )
+						{
+//*l&lt;&lt;&quot;\n  r1=&quot;&lt;&lt;RLI-&gt;index&lt;&lt;&quot; r2=&quot;&lt;&lt;iR2;
+							if( RD[RLI-&gt;index][iR2] &lt; 0.0 )
+							{
+								RSD = &amp;Resources[RLI-&gt;index]-&gt;S-&gt;siteDistance.find(Resources[iR2]-&gt;S)-&gt;second;
+//*l&lt;&lt;&quot; BPT:&quot;&lt;&lt;RSD-&gt;bestPathType;
+								RD[RLI-&gt;index][iR2] = Resources[RLI-&gt;index]-&gt;S-&gt;GetResourceDistance(Resources[iR2]-&gt;S,RSD-&gt;bestPathType);
+//*l&lt;&lt;&quot; *:&quot;&lt;&lt;RD[RLI-&gt;index][iR2];
+								RD[RLI-&gt;index][iR2] *= MTPenalty[RMT[RLI-&gt;index][iR2]];
+								RD[iR2][RLI-&gt;index] = RD[RLI-&gt;index][iR2];
+							}
+//*l&lt;&lt;&quot; d(1-2):&quot;&lt;&lt;RD[RLI-&gt;index][iR2];
+
+							if( RLI-&gt;bestI &lt; 0 || RD[RLI-&gt;index][iR2] &lt; RD[RLI-&gt;index][RLI-&gt;bestI] )
+							{
+								acceptLink = true;
+								for(map&lt;int,ResourceSiteExt*&gt;::iterator iRL1 = Resources[RLI-&gt;index]-&gt;Linked.begin(); iRL1 != Resources[RLI-&gt;index]-&gt;Linked.end(); iRL1++ )
+								{
+									RSD = &amp;Resources[iR2]-&gt;S-&gt;siteDistance.find(iRL1-&gt;second-&gt;S)-&gt;second;
+									if( RSD-&gt;bestDistance != 0 )
+									{
+										if( RD[iR2][iRL1-&gt;first] &lt; 0.0 )
+										{
+											RD[iR2][iRL1-&gt;first] = Resources[iR2]-&gt;S-&gt;GetResourceDistance(iRL1-&gt;second-&gt;S,RSD-&gt;bestPathType) * MTPenalty[RMT[iR2][iRL1-&gt;first]];
+											RD[iRL1-&gt;first][iR2] = RD[iR2][iRL1-&gt;first];
+										}
+										if( RD[RLI-&gt;index][iRL1-&gt;first] &lt; 0.0 )
+										{
+											RD[RLI-&gt;index][iRL1-&gt;first] = Resources[RLI-&gt;index]-&gt;S-&gt;GetResourceDistance(iRL1-&gt;second-&gt;S,Resources[RLI-&gt;index]-&gt;S-&gt;siteDistance.find(iRL1-&gt;second-&gt;S)-&gt;second.bestPathType) * MTPenalty[RMT[RLI-&gt;index][iRL1-&gt;first]];
+											RD[iRL1-&gt;first][RLI-&gt;index] = RD[RLI-&gt;index][iRL1-&gt;first];
+										}
+//*l&lt;&lt;&quot; d(L1-2):&quot;&lt;&lt;RD[iR2][iRL1-&gt;first];
+//*l&lt;&lt;&quot;+&quot;&lt;&lt;0.35*RD[RLI-&gt;index][iRL1-&gt;first];
+										if( RD[iR2][iRL1-&gt;first]+0.35*RD[RLI-&gt;index][iRL1-&gt;first] &lt; RD[RLI-&gt;index][iR2] )
+										{
+//*l&lt;&lt;&quot; rejected(&quot;&lt;&lt;iRL1-&gt;first&lt;&lt;&quot;)&quot;;
+											acceptLink = false;
+											break;
+										}
+									}
+								}
+
+								if( acceptLink )
+								{
+//*l&lt;&lt;&quot; *acceptLink*&quot;;
+									RLI-&gt;bestI = iR2;
+								}
+							}
+						}
+				}
+//if( RLI-&gt;bestI &gt;= 0 ) *l&lt;&lt;&quot;\n  dis[&quot;&lt;&lt;RLI-&gt;index&lt;&lt;&quot;][&quot;&lt;&lt;RLI-&gt;bestI&lt;&lt;&quot;]=&quot;&lt;&lt;RD[RLI-&gt;index][RLI-&gt;bestI];
+				if( RLI-&gt;bestI == -1 )
+					RLIList.removeE();
+				else if( bestRLI == 0 || RD[RLI-&gt;index][RLI-&gt;bestI] &lt; RD[bestRLI-&gt;index][bestRLI-&gt;bestI] )
+					bestRLI = RLI;
+			}
+		}
+//		linkClock1 += clock()-linkClockTemp;
+
+		if( bestRLI == 0 )
+			break; // the loop would have ended anyway, this just jumps over the next area of code
+
+//		linkClockTemp = clock();
+		resetLink = false;
+		RSD = &amp;Resources[bestRLI-&gt;index]-&gt;S-&gt;siteDistance.find(Resources[bestRLI-&gt;bestI]-&gt;S)-&gt;second;
+		if( RSD-&gt;bestDistance == 0 )
+		{	// The best choice distance has yet to be calculated
+//*l&lt;&lt;&quot; r-1-2&quot;;
+			for( MobileTypes.begin(); RSD-&gt;bestDistance == 0 &amp;&amp; MobileTypes.nextE(MT); )
+				if( RSD-&gt;distance.find(MT-&gt;MD-&gt;pathType) == RSD-&gt;distance.end() )
+				{
+					FindResourceDistance(Resources[bestRLI-&gt;index]-&gt;S,Resources[bestRLI-&gt;bestI]-&gt;S,MT-&gt;MD-&gt;pathType);
+					RMT[bestRLI-&gt;index][bestRLI-&gt;bestI] = RSD-&gt;bestPathType;
+					RMT[bestRLI-&gt;bestI][bestRLI-&gt;index] = RSD-&gt;bestPathType;
+				}
+			if( RSD-&gt;bestDistance == 0 )
+			{
+				RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+				RSD = &amp;Resources[bestRLI-&gt;bestI]-&gt;S-&gt;siteDistance.find(Resources[bestRLI-&gt;index]-&gt;S)-&gt;second;
+				RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+				RMT[bestRLI-&gt;index][bestRLI-&gt;bestI] = MTPenaltySize;
+				RMT[bestRLI-&gt;bestI][bestRLI-&gt;index] = MTPenaltySize;
+			}
+			RD[bestRLI-&gt;index][bestRLI-&gt;bestI] = -1.0;
+			RD[bestRLI-&gt;bestI][bestRLI-&gt;index] = -1.0;
+			resetLink = true;
+		}
+//		linkClock2 += clock()-linkClockTemp;
+//		linkClockTemp = clock();
+		for(map&lt;int,ResourceSiteExt*&gt;::iterator iRL1 = Resources[bestRLI-&gt;index]-&gt;Linked.begin(); iRL1 != Resources[bestRLI-&gt;index]-&gt;Linked.end(); iRL1++ )
+		{
+			RSD = &amp;iRL1-&gt;second-&gt;S-&gt;siteDistance.find(Resources[bestRLI-&gt;bestI]-&gt;S)-&gt;second;
+			if( RSD-&gt;bestDistance == 0 )
+			{	// An additionally needed set of calculations
+//*l&lt;&lt;&quot; r-L1-2&quot;;
+				for( MobileTypes.begin(); RSD-&gt;bestDistance == 0 &amp;&amp; MobileTypes.nextE(MT); )
+					if( RSD-&gt;distance.find(MT-&gt;MD-&gt;pathType) == RSD-&gt;distance.end() )
+					{
+						FindResourceDistance(iRL1-&gt;second-&gt;S,Resources[bestRLI-&gt;bestI]-&gt;S,MT-&gt;MD-&gt;pathType);
+						RMT[iRL1-&gt;first][bestRLI-&gt;bestI] = RSD-&gt;bestPathType;
+						RMT[bestRLI-&gt;bestI][iRL1-&gt;first] = RSD-&gt;bestPathType;
+					}
+				if( RSD-&gt;bestDistance == 0 )
+				{
+					RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+					RSD = &amp;Resources[bestRLI-&gt;bestI]-&gt;S-&gt;siteDistance.find(iRL1-&gt;second-&gt;S)-&gt;second;
+					RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+					RMT[iRL1-&gt;first][bestRLI-&gt;bestI] = MTPenaltySize;
+					RMT[bestRLI-&gt;bestI][iRL1-&gt;first] = MTPenaltySize;
+				}
+				RD[iRL1-&gt;first][bestRLI-&gt;bestI] = -1.0;
+				RD[bestRLI-&gt;bestI][iRL1-&gt;first] = -1.0;
+				resetLink = true;
+			}
+		}
+//		linkClock3 += clock()-linkClockTemp;
+//		linkClockTemp = clock();
+		if( resetLink )
+		{	// New calculations have been made, distances should be reconsidered
+			for( RLIList.begin(); RLIList.nextE(RLI); )
+				if( (RLI-&gt;index == bestRLI-&gt;bestI &amp;&amp; bestRLI-&gt;restrictedR.find(RLI-&gt;bestI) != bestRLI-&gt;restrictedR.end() ) ||
+					(Resources[bestRLI-&gt;index]-&gt;Linked.find(RLI-&gt;index) != Resources[bestRLI-&gt;index]-&gt;Linked.end() &amp;&amp; RLI-&gt;bestI == bestRLI-&gt;bestI) )
+					RLI-&gt;bestI = -1;
+			bestRLI-&gt;bestI = -1;
+			bestRLI = 0;
+		}
+		else
+		{
+//*l&lt;&lt;&quot; size1:&quot;&lt;&lt;Resources[bestRLI-&gt;index]-&gt;Linked.size();
+			// These are an additional sets of conditions that are not checked until the best has been found
+			for(map&lt;int,ResourceSiteExt*&gt;::iterator iRL1 = Resources[bestRLI-&gt;index]-&gt;Linked.begin(); iRL1 != Resources[bestRLI-&gt;index]-&gt;Linked.end(); iRL1++ )
+			{
+//*l&lt;&lt;&quot; d(L1-B):&quot;&lt;&lt;RD[bestRLI-&gt;bestI][iRL1-&gt;first];
+				if( RD[bestRLI-&gt;bestI][iRL1-&gt;first] &lt; RD[bestRLI-&gt;bestI][bestRLI-&gt;index] )
+				{	// The best choose didn't work out
+//*l&lt;&lt;&quot; *no good*&quot;;
+					bestRLI-&gt;bestI = -2; // this will end the search for this paticular resource
+					bestRLI = 0;
+					break;
+				}
+			}
+			if( bestRLI != 0 )
+			{
+//*l&lt;&lt;&quot; size2:&quot;&lt;&lt;Resources[bestRLI-&gt;bestI]-&gt;Linked.size();
+				for(map&lt;int,ResourceSiteExt*&gt;::iterator iRLB = Resources[bestRLI-&gt;bestI]-&gt;Linked.begin(); iRLB != Resources[bestRLI-&gt;bestI]-&gt;Linked.end(); iRLB++ )
+				{
+					RSD = &amp;Resources[bestRLI-&gt;index]-&gt;S-&gt;siteDistance.find(iRLB-&gt;second-&gt;S)-&gt;second;
+					if( RSD-&gt;bestDistance == 0 )
+					{	// An additionally needed set of calculations
+						for( MobileTypes.begin(); RSD-&gt;bestDistance == 0 &amp;&amp; MobileTypes.nextE(MT); )
+							if( RSD-&gt;distance.find(MT-&gt;MD-&gt;pathType) == RSD-&gt;distance.end() )
+							{
+								FindResourceDistance(Resources[bestRLI-&gt;index]-&gt;S,iRLB-&gt;second-&gt;S,MT-&gt;MD-&gt;pathType);
+								RMT[bestRLI-&gt;index][iRLB-&gt;first] = RSD-&gt;bestPathType;
+								RMT[iRLB-&gt;first][bestRLI-&gt;index] = RSD-&gt;bestPathType;
+							}
+						if( RSD-&gt;bestDistance == 0 )
+						{
+							RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+							RSD = &amp;iRLB-&gt;second-&gt;S-&gt;siteDistance.find(Resources[bestRLI-&gt;index]-&gt;S)-&gt;second;
+							RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+							RMT[bestRLI-&gt;index][iRLB-&gt;first] = MTPenaltySize;
+							RMT[iRLB-&gt;first][bestRLI-&gt;index] = MTPenaltySize;
+						}
+						RD[bestRLI-&gt;index][iRLB-&gt;first] = -1.0;
+						RD[iRLB-&gt;first][bestRLI-&gt;index] = -1.0;
+					}
+					if( RD[bestRLI-&gt;index][iRLB-&gt;first] &lt; 0.0 )
+					{
+						RD[bestRLI-&gt;index][iRLB-&gt;first] = Resources[bestRLI-&gt;index]-&gt;S-&gt;GetResourceDistance(iRLB-&gt;second-&gt;S,RSD-&gt;bestPathType) * MTPenalty[RMT[bestRLI-&gt;index][iRLB-&gt;first]];
+						RD[iRLB-&gt;first][bestRLI-&gt;index] = RD[bestRLI-&gt;index][iRLB-&gt;first];
+					}
+//*l&lt;&lt;&quot; d(LB-1):&quot;&lt;&lt;RD[bestRLI-&gt;index][iRLB-&gt;first];
+					if( RD[bestRLI-&gt;index][iRLB-&gt;first] &lt; RD[bestRLI-&gt;index][bestRLI-&gt;bestI] )
+					{
+//						float3 Pos1=Resources[bestRLI-&gt;index]-&gt;S-&gt;position;
+//						float3 Pos2=Resources[bestRLI-&gt;bestI]-&gt;S-&gt;position;
+//						Pos1.y+=515.0;
+//						Pos2.y+=755.0;
+//						cb-&gt;CreateLineFigure(Pos1,Pos2,30,0,900000,0);
+//*l&lt;&lt;&quot; *no good*&quot;;
+						// The best choose didn't work out
+						bestRLI-&gt;bestI = -2; // this will end the search for this paticular resource
+						bestRLI = 0;
+						break;
+					}
+				}
+			}
+			if( bestRLI != 0 )
+			{
+				RSD = &amp;Resources[bestRLI-&gt;index]-&gt;S-&gt;siteDistance.find(Resources[bestRLI-&gt;bestI]-&gt;S)-&gt;second;
+//*l&lt;&lt;&quot;\n*Best* R(&quot;&lt;&lt;bestRLI-&gt;index&lt;&lt;&quot;&lt;-&gt;&quot;&lt;&lt;bestRLI-&gt;bestI&lt;&lt;&quot;) dis=&quot;;
+//*l&lt;&lt;Resources[bestRLI-&gt;index]-&gt;S-&gt;GetResourceDistance(Resources[bestRLI-&gt;bestI]-&gt;S,RSD-&gt;bestPathType);
+//*l&lt;&lt;&quot; p=&quot;&lt;&lt;MTPenalty[RMT[bestRLI-&gt;index][bestRLI-&gt;bestI]];
+//*l&lt;&lt;&quot; d=&quot;&lt;&lt;RD[bestRLI-&gt;bestI][bestRLI-&gt;index];
+//*l&lt;&lt;&quot; d=&quot;&lt;&lt;RD[bestRLI-&gt;index][bestRLI-&gt;bestI];
+				if( RAIDEBUGGING &amp;&amp; cb-&gt;GetMyTeam() == 0 ) // Debug Lines
+				{
+					vector&lt;float3&gt; *path = &amp;RSD-&gt;pathDebug;
+					if( path-&gt;size() == 0 )
+					{
+						path-&gt;push_back(Resources[bestRLI-&gt;index]-&gt;S-&gt;position);
+						path-&gt;push_back(Resources[bestRLI-&gt;bestI]-&gt;S-&gt;position);
+					}
+					for( int i=0; i&lt;int(path-&gt;size())-1; i++ )
+					{
+						float3 Pos1=path-&gt;at(i);
+						float3 Pos2=path-&gt;at(i+1);
+						Pos1.y+=45.0;
+						if( i == 0 )
+							Pos1.y+=35.0;
+						Pos2.y+=45.0;
+						if( i == path-&gt;size()-2 )
+							Pos2.y-=75.0;
+						cb-&gt;CreateLineFigure(Pos1,Pos2,30,0,900000,0);
+					}
+				}
+
+				Resources[bestRLI-&gt;index]-&gt;Linked.insert(irPair(bestRLI-&gt;bestI,Resources[bestRLI-&gt;bestI]));
+				Resources[bestRLI-&gt;bestI]-&gt;Linked.insert(irPair(bestRLI-&gt;index,Resources[bestRLI-&gt;index]));
+				for( RLIList.begin(); RLIList.nextE(RLI); )
+					if( RLI-&gt;restrictedR.find(bestRLI-&gt;bestI) != RLI-&gt;restrictedR.end() )
+					{
+						RLI-&gt;bestI = -1;
+						if( RLI-&gt;index == bestRLI-&gt;bestI )
+							RLI-&gt;restrictedR.insert(bestRLI-&gt;index);
+					}
+				bestRLI-&gt;restrictedR.insert(bestRLI-&gt;bestI);
+				bestRLI-&gt;bestI = -1;
+				for( RLIList.begin(); RLIList.nextE(RLI); )
+					if( Resources[RLI-&gt;index]-&gt;Linked.size() &gt;= 3 )
+						RLIList.removeE();
+				bestRLI = 0;
+			}
+		}
+//		linkClock4 += clock()-linkClockTemp;
+	}
+	if( RLIList.elementSize &gt; 0 )
+		*l&lt;&lt;&quot;\n Second Linking Algorithm Aborted (was running for more than &quot;&lt;&lt;SecondAlgorithmTimeLimit&lt;&lt;&quot; seconds)&quot;;
+
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+	{
+		delete [] RMT[iR];
+		delete [] RD[iR];
+	}
+	delete [] RMT;
+	delete [] RD;
+	delete [] MTPenalty;
+//	*l&lt;&lt;&quot;\n   Second Link Loading Time 1: &quot;&lt;&lt;linkClock1/(double)CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+//	*l&lt;&lt;&quot;\n   Second Link Loading Time 2: &quot;&lt;&lt;linkClock2/(double)CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+//	*l&lt;&lt;&quot;\n   Second Link Loading Time 3: &quot;&lt;&lt;linkClock3/(double)CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+//	*l&lt;&lt;&quot;\n   Second Link Loading Time 4: &quot;&lt;&lt;linkClock4/(double)CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+	*l&lt;&lt;&quot;\n   Second Link Algorithm Loading Time: &quot;&lt;&lt;(clock()-linkStartClock)/CLOCKS_PER_SEC&lt;&lt;&quot;s&quot;;
+
+	// Setting Linked Distance 2
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+	{
+		for( map&lt;int,ResourceSiteExt*&gt;::iterator iRL=Resources[iR]-&gt;Linked.begin(); iRL!=Resources[iR]-&gt;Linked.end(); iRL++ )
+		{
+			if( Resources[iR]-&gt;LinkedD2.find(iRL-&gt;first) == Resources[iR]-&gt;LinkedD2.end() )
+				Resources[iR]-&gt;LinkedD2.insert(irPair(iRL-&gt;first,Resources[iRL-&gt;first]));
+			for( map&lt;int,ResourceSiteExt*&gt;::iterator iRL2=Resources[iRL-&gt;first]-&gt;Linked.begin(); iRL2!=Resources[iRL-&gt;first]-&gt;Linked.end(); iRL2++ )
+			{
+				if( iRL2-&gt;first != iR &amp;&amp; Resources[iR]-&gt;LinkedD2.find(iRL2-&gt;first) == Resources[iR]-&gt;LinkedD2.end() )
+					Resources[iR]-&gt;LinkedD2.insert(irPair(iRL2-&gt;first,Resources[iRL2-&gt;first]));
+			}
+		}
+	}
+
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+		Resources[iR]-&gt;SetRanged();
+
+	// Debug Lines
+	if( RAIDEBUGGING &amp;&amp; cb-&gt;GetMyTeam() == 0 )
+		for( int iR1=0; iR1&lt;ResourceSize; iR1++ )
+		{
+			for( int iR2=iR1+1; iR2&lt;ResourceSize; iR2++ )
+			{
+				if( Resources[iR1]-&gt;Linked.find(iR2) != Resources[iR1]-&gt;Linked.end() )
+				{
+					vector&lt;float3&gt; *path = &amp;Resources[iR1]-&gt;S-&gt;siteDistance.find(Resources[iR2]-&gt;S)-&gt;second.pathDebug;
+					if( path-&gt;size() == 0 )
+					{
+						path-&gt;push_back(Resources[iR1]-&gt;S-&gt;position);
+						path-&gt;push_back(Resources[iR2]-&gt;S-&gt;position);
+					}
+					for( int i=0; i&lt;int(path-&gt;size())-1; i++ )
+					{
+						float3 Pos1=path-&gt;at(i);
+						float3 Pos2=path-&gt;at(i+1);
+						Pos1.y+=15.0;
+						Pos2.y+=15.0;
+						cb-&gt;CreateLineFigure(Pos1,Pos2,10,0,900000,0);
+					}
+				}
+			}
+
+			*l&lt;&lt;&quot;\n R(&quot;&lt;&lt;iR1&lt;&lt;&quot;) type=&quot;&lt;&lt;Resources[iR1]-&gt;S-&gt;type&lt;&lt;&quot; Pos(x&quot;&lt;&lt;Resources[iR1]-&gt;S-&gt;position.x&lt;&lt;&quot;,z&quot;&lt;&lt;Resources[iR1]-&gt;S-&gt;position.z&lt;&lt;&quot;) L(&quot;&lt;&lt;Resources[iR1]-&gt;Linked.size()&lt;&lt;&quot;):&quot;;
+			for( map&lt;int,ResourceSiteExt*&gt;::iterator RL=Resources[iR1]-&gt;Linked.begin(); RL!=Resources[iR1]-&gt;Linked.end(); RL++ )
+				*l&lt;&lt;&quot; &quot;&lt;&lt;RL-&gt;first;
+			*l&lt;&lt;&quot;\t B(&quot;&lt;&lt;Resources[iR1]-&gt;BuildOptions.size()&lt;&lt;&quot;):&quot;;
+			for( map&lt;int,ResourceSiteExtBO&gt;::iterator RS=Resources[iR1]-&gt;BuildOptions.begin(); RS!=Resources[iR1]-&gt;BuildOptions.end(); RS++ )
+				*l&lt;&lt;&quot; &quot;&lt;&lt;RS-&gt;first;
+		}
+}
+
+cBuilderPlacement::~cBuilderPlacement()
+{
+	for( int i=0; i&lt;ResourceSize; i++ )
+		delete Resources[i];
+//	delete [] Sector;
+}
+
+void cBuilderPlacement::UResourceCreated(int unit, UnitInfo *U)
+{
+	if( !NeedResourceSite(U-&gt;ud) )
+		return;
+
+	if( U-&gt;ud-&gt;extractsMetal &gt; 0.0f )
+		UExtractor.insert(cRAI::iupPair(unit,U));
+	else if( U-&gt;ud-&gt;needGeo )
+		UGeoPlant.insert(cRAI::iupPair(unit,U));
+
+	int iR=GetResourceIndex(unit,U-&gt;ud);
+	if( iR == -1 )
+	{
+//		cb-&gt;SendTextMsg(&quot;TEST: Decomission: iR = -1&quot;,0);
+//		G-&gt;B-&gt;Decomission.insert(unit); // broken
+		return;
+	}
+
+	if( Resources[iR]-&gt;unitID == -1 || !Resources[iR]-&gt;BuildOptions.find(U-&gt;ud-&gt;id)-&gt;second.RBRanked )
+	{
+		SetResourceOwner(iR,Resources[iR],unit,U-&gt;udr);
+		U-&gt;RS = Resources[iR];
+	}
+	else if( !U-&gt;AIDisabled )
+	{
+//		cb-&gt;SendTextMsg(&quot;TEST: Decomission: ranked&quot;,0);
+		G-&gt;B-&gt;Decomission.insert(unit);
+	}
+}
+
+void cBuilderPlacement::UResourceDestroyed(int unit, UnitInfo *U)
+{
+	if( !NeedResourceSite(U-&gt;ud) )
+		return;
+
+	if( U-&gt;ud-&gt;extractsMetal &gt; 0.0f )
+		UExtractor.erase(unit);
+	else if( U-&gt;ud-&gt;needGeo )
+		UGeoPlant.erase(unit);
+
+	if( U-&gt;RS != 0 &amp;&amp; U-&gt;RS-&gt;unitID == unit )
+	{
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+		{
+			if(	Resources[iR]-&gt;unitID == unit )
+			{
+				SetResourceOwner(iR,U-&gt;RS,-1);
+				break;
+			}
+		}
+	}
+}
+
+void cBuilderPlacement::EResourceEnterLOS(int enemy, EnemyInfo *E)
+{
+	if( !NeedResourceSite(E-&gt;ud) )
+		return;
+
+	int iR=GetResourceIndex(enemy,E-&gt;ud);
+	if( iR == -1 )
+		return;
+
+	if( Resources[iR]-&gt;unitID == -1 || !Resources[iR]-&gt;BuildOptions.find(E-&gt;ud-&gt;id)-&gt;second.RBRanked )
+	{
+		Resources[iR]-&gt;unitID=enemy;
+		Resources[iR]-&gt;unitUD=E-&gt;udr;
+		Resources[iR]-&gt;enemy = true;
+		E-&gt;RS = Resources[iR];
+
+		if( Resources[iR]-&gt;builderID &gt; -1 &amp;&amp; G-&gt;ValidateUnit(Resources[iR]-&gt;builderID) &amp;&amp; int(cb-&gt;GetCurrentUnitCommands(Resources[iR]-&gt;builderID)-&gt;size())&gt;0 &amp;&amp; Resources[iR]-&gt;BuildOptions.find(-cb-&gt;GetCurrentUnitCommands(Resources[iR]-&gt;builderID)-&gt;begin()-&gt;id) != Resources[iR]-&gt;BuildOptions.end() )
+		{
+			if( Resources[iR]-&gt;builderUI-&gt;ud-&gt;canCapture )
+			{
+				Command c;
+				c.id = CMD_CAPTURE;
+				c.params.push_back(enemy);
+				cb-&gt;GiveOrder(Resources[iR]-&gt;builderID, &amp;c);
+			}
+			else if ( Resources[iR]-&gt;builderUI-&gt;ud-&gt;canReclaim )
+			{
+				Command c;
+				c.id = CMD_RECLAIM;
+				c.params.push_back(enemy);
+				cb-&gt;GiveOrder(Resources[iR]-&gt;builderID, &amp;c);
+			}
+		}
+	}
+}
+
+bool cBuilderPlacement::NeedResourceSite(const UnitDef* bd)
+{
+	if( !bd-&gt;needGeo &amp;&amp; bd-&gt;extractsMetal==0 )
+		return false;
+	if( bd-&gt;extractsMetal&gt;0 &amp;&amp; G-&gt;RM-&gt;isMetalMap )
+		return false;
+	return true;
+}
+
+ResourceSiteExt* cBuilderPlacement::FindResourceSite(float3&amp; pos, const UnitDef* bd, TerrainMapArea* BuilderMA)
+{
+//	*l&lt;&lt;&quot;\nFindResourceSite(x&quot;&lt;&lt;pos.x&lt;&lt;&quot; z&quot;&lt;&lt;pos.z&lt;&lt;&quot; y&quot;&lt;&lt;pos.y&lt;&lt;&quot;,&quot;&lt;&lt;bd-&gt;humanName&lt;&lt;&quot;,&quot;&lt;&lt;(BuilderMA==0?&quot;-&quot;:&quot;*&quot;)&lt;&lt;&quot;)&quot;;
+	if( !NeedResourceSite(bd) )
+		return 0;
+	UpdateAllyResources();
+	map&lt;int,ResourceSiteExt*&gt;* RL;
+	if( int(UExtractor.size()) == 0 &amp;&amp; int(UGeoPlant.size()) == 0 &amp;&amp; int(RSRemaining.size()) &gt; 0 )
+	{
+//		*l&lt;&lt;&quot;\n\n(No Resources) - Alternative Search&quot;;
+		RL=&RSRemaining;
+		CheckBlockedRList(RL);
+	}
+	else
+		RL=&RSAvailable;
+	float fBest=0;
+	int iBest=-1;
+	float distance;
+	for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=RL-&gt;begin(); iR!=RL-&gt;end(); iR++ )
+	{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+		if( iR-&gt;second-&gt;builderID == -1 &amp;&amp;
+			iR-&gt;second-&gt;BuildOptions.find(bd-&gt;id) != iR-&gt;second-&gt;BuildOptions.end() &amp;&amp;
+			!iR-&gt;second-&gt;BuildOptions.find(bd-&gt;id)-&gt;second.RBBlocked &amp;&amp;
+			!iR-&gt;second-&gt;BuildOptions.find(bd-&gt;id)-&gt;second.RBRanked)
+		{
+			if( G-&gt;TM-&gt;CanMoveToPos(BuilderMA,iR-&gt;second-&gt;S-&gt;position) )
+			{
+				distance = pos.distance(iR-&gt;second-&gt;S-&gt;position);
+				if( iBest==-1 || distance &lt; fBest )
+				{
+					iBest=iR-&gt;first;
+					fBest=distance;
+				}
+			}
+		}
+	}
+	if( iBest == -1 )
+	{
+		*l&lt;&lt;&quot;\nWARNING: FindResourceSite() has failed: builder = &quot;&lt;&lt;bd-&gt;humanName;
+		return 0;
+	}
+
+	return Resources[iBest];
+}
+
+float3 cBuilderPlacement::FindBuildPosition(sBuildQuarry *BQ)
+{
+	const UnitDef* bd = BQ-&gt;creationUD-&gt;ud;
+	if( BQ-&gt;RS != 0 ) // Resource is set
+		return cb-&gt;ClosestBuildSite(bd,BQ-&gt;RS-&gt;S-&gt;position,BQ-&gt;RS-&gt;searchRadius,BQ-&gt;RS-&gt;disApart);
+
+	float3 cPosition = cb-&gt;GetUnitPos(BQ-&gt;builderID); // Construction Position
+	if( NeedResourceSite(BQ-&gt;creationUD-&gt;ud) )
+	{
+		cPosition.x = -2;
+		cPosition.z = -1;
+		cPosition.y = -1;
+		return cPosition;
+	}
+
+	G-&gt;CorrectPosition(cPosition);
+	float3 bPosition = cPosition; // Builder Position
+	if( FindWeaponPlacement(BQ-&gt;builderUI,cPosition) )
+	{
+		cPosition.x+=rand()%81-40;
+		cPosition.z+=rand()%81-40;
+		G-&gt;CorrectPosition(cPosition);
+	}
+	else if( BQ-&gt;builderUI-&gt;ud-&gt;speed == 0.0 )
+	{
+		cPosition.x+=rand()%int(1.8*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		cPosition.z+=rand()%int(1.8*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		G-&gt;CorrectPosition(cPosition);
+	}
+	else
+	{
+		cPosition.x+=rand()%int(0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.45*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		cPosition.z+=rand()%int(0.9*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance)-0.45*BQ-&gt;builderUI-&gt;ud-&gt;buildDistance;
+		G-&gt;CorrectPosition(cPosition);
+	}
+
+	int iS;
+	if( !CanBuildAt(BQ-&gt;builderUI,bPosition,cPosition) || !CanBeBuiltAt(BQ-&gt;creationUD,cPosition) )
+	{
+		iS = G-&gt;TM-&gt;GetSectorIndex(cPosition);
+		if( BQ-&gt;creationUD-&gt;mobileType != 0 ) // a factory or mobile unit
+		{
+			TerrainMapAreaSector *AS = G-&gt;TM-&gt;GetAlternativeSector(BQ-&gt;builderUI-&gt;area,iS,BQ-&gt;creationUD-&gt;mobileType);
+			if( BQ-&gt;creationUD-&gt;immobileType != 0 ) // a factory
+			{
+				TerrainMapSector *S = G-&gt;TM-&gt;GetAlternativeSector(AS-&gt;area,iS,BQ-&gt;creationUD-&gt;immobileType);
+				if( S != 0 )
+					cPosition = S-&gt;position;
+				else
+				{
+					cPosition.x = -3;
+					cPosition.z = -1;
+					cPosition.y = -1;
+					return cPosition;
+				}
+			}
+			else
+				cPosition = AS-&gt;S-&gt;position;
+		}
+		else if( BQ-&gt;creationUD-&gt;immobileType != 0 ) // buildings
+			cPosition = G-&gt;TM-&gt;GetClosestSector(BQ-&gt;creationUD-&gt;immobileType,iS)-&gt;position;
+	}
+	if( BQ-&gt;builderUI-&gt;ud-&gt;speed == 0.0 )
+	{
+		float3 cPosition2 = cb-&gt;ClosestBuildSite(bd,cPosition,BQ-&gt;builderUI-&gt;ud-&gt;buildDistance,5);
+		if( cPosition2.x &lt;= 0 &amp;&amp; cPosition2.y &lt;= 0 &amp;&amp; cPosition2.z &lt;= 0 )
+			cPosition2 = cb-&gt;ClosestBuildSite(bd,cPosition,BQ-&gt;builderUI-&gt;ud-&gt;buildDistance+25,1);
+		return cPosition2;
+	}
+
+	iS = G-&gt;TM-&gt;GetSectorIndex(cPosition);
+	float fSearchRadius=1000.0f;
+	int iDisApart=10;
+	if( G-&gt;TM-&gt;sector[iS].isWater )
+		iDisApart=15;
+	else if( bd-&gt;speed &gt; 0 )
+		iDisApart=5;
+	else if( int(bd-&gt;buildOptions.size())&gt;0 )
+		iDisApart=15;
+	if( iDisApart &lt; int(bd-&gt;kamikazeDist/8.0) )
+		iDisApart = int(bd-&gt;kamikazeDist/8.0);
+
+	float3 cPosition2 = cb-&gt;ClosestBuildSite(bd,cPosition,fSearchRadius,iDisApart);
+	if( cPosition2.x == -1 )
+	{
+		cPosition2 = cb-&gt;ClosestBuildSite(bd,cPosition,2500.0f,iDisApart);
+		if( cPosition2.x == -1 )
+			return bPosition;
+	}
+	return cPosition2;
+}
+
+bool cBuilderPlacement::CanBeBuiltAt(sRAIUnitDef *udr, float3&amp; position, const float&amp; range)
+{
+	int iS = G-&gt;TM-&gt;GetSectorIndex(position);
+	TerrainMapSector* sector;
+	if( udr-&gt;mobileType != 0 ) // a factory or mobile unit
+	{
+		TerrainMapAreaSector* AS = G-&gt;TM-&gt;GetAlternativeSector(0,iS,udr-&gt;mobileType);
+		if( udr-&gt;immobileType != 0 ) // a factory
+		{
+			sector = G-&gt;TM-&gt;GetAlternativeSector(AS-&gt;area,iS,udr-&gt;immobileType);
+			if( sector == 0 )
+				return false;
+		}
+		else
+			sector = AS-&gt;S;
+	}
+	else if( udr-&gt;immobileType != 0 ) // buildings
+		sector = G-&gt;TM-&gt;GetClosestSector(udr-&gt;immobileType,iS);
+	else
+		return true; // flying units
+
+	if( sector == &amp;G-&gt;TM-&gt;sector[iS] ) // the current sector is the best sector
+		return true;
+	return sector-&gt;position.distance2D(G-&gt;TM-&gt;sector[iS].position) &lt; range;
+}
+
+bool cBuilderPlacement::CanBuildAt(UnitInfo *U, const float3&amp; position, const float3&amp; destination)
+{
+	if( U-&gt;udr-&gt;immobileType != 0 ) // A hub or factory
+		return position.distance2D(destination) &lt; U-&gt;ud-&gt;buildDistance;
+	if( U-&gt;area == 0 ) // A flying unit
+		return true;
+	int iS = G-&gt;TM-&gt;GetSectorIndex(destination);
+	if( U-&gt;area-&gt;sector.find(iS) != U-&gt;area-&gt;sector.end() )
+		return true;
+	if( G-&gt;TM-&gt;GetClosestSector(U-&gt;area,iS)-&gt;S-&gt;position.distance2D(destination) &lt; U-&gt;ud-&gt;buildDistance - G-&gt;TM-&gt;convertStoP )
+		return true;
+	return false;
+}
+/*
+// Callback Clone Functions
+const int SQUARE_SIZE = 8;
+#include &lt;algorithm&gt;
+// Stolen directly from ALCallback.cpp
+struct SearchOffset {
+	int dx,dy;
+	int qdist; // dx*dx+dy*dy
+};
+// Stolen directly from ALCallback.cpp
+bool SearchOffsetComparator (const SearchOffset&amp; a, const SearchOffset&amp; b)
+{	return a.qdist &lt; b.qdist;	}
+// Stolen directly from ALCallback.cpp
+const vector&lt;SearchOffset&gt;&amp; GetSearchOffsetTable (int radius)
+{	static vector &lt;SearchOffset&gt; searchOffsets;
+	int size = radius*radius*4;
+	if (size &gt; searchOffsets.size()) {
+		searchOffsets.resize (size);
+		for (int y=0;y&lt;radius*2;y++)
+			for (int x=0;x&lt;radius*2;x++)
+			{	SearchOffset&amp; i = searchOffsets[y*radius*2+x];
+				i.dx = x-radius;
+				i.dy = y-radius;
+				i.qdist = i.dx*i.dx+i.dy*i.dy;
+			}
+		sort (searchOffsets.begin(), searchOffsets.end(), SearchOffsetComparator);
+	}
+	return searchOffsets;
+}
+float3 cBuilderPlacement::ClosestBuildSite(const UnitDef* ud, float3 p, float sRadius, int facing)
+{
+	if (!ud) return float3(-1.0f,0.0f,0.0f);
+	int endr = (int)(sRadius/(SQUARE_SIZE*2));
+	const vector&lt;SearchOffset&gt;&amp; ofs = GetSearchOffsetTable (endr);
+	for(int so=0;so&lt;endr*endr*4;so++)
+	{
+		float x = p.x+ofs[so].dx*SQUARE_SIZE*2;
+		float z = p.z+ofs[so].dy*SQUARE_SIZE*2;
+		if( cb-&gt;CanBuildAt(ud,float3(x,0,z),facing) )
+		{
+			return float3(x,0,z);
+		}
+	}
+	return float3(-1.0f,0.0f,0.0f);
+}
+*/
+bool cBuilderPlacement::FindWeaponPlacement(UnitInfo *U, float3&amp; position)
+{
+	if( U-&gt;BuildQ-&gt;creationUD-&gt;WeaponGuardRange == 0 )
+		return false;
+
+	if( U-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; U-&gt;BuildQ-&gt;creationUD-&gt;WeaponSeaEff.BestRange &gt; 0 )
+	{
+		int iS = G-&gt;TM-&gt;GetSectorIndex(position);
+		if( !G-&gt;TM-&gt;sector[iS].isWater )
+			position = G-&gt;TM-&gt;GetClosestSector(G-&gt;TM-&gt;waterSectorType,iS)-&gt;position;
+		return true;
+	}
+
+	int BID = -1;
+	float3 buildPosition;
+	for(map&lt;int,UnitInfo*&gt;::iterator i=G-&gt;UImmobile.begin(); i!=G-&gt;UImmobile.end(); i++ )
+	{
+		buildPosition = cb-&gt;GetUnitPos(i-&gt;first);
+		if( i-&gt;second-&gt;udr-&gt;WeaponGuardRange == 0 &amp;&amp; int(i-&gt;second-&gt;UDefences.size()) == 0 &amp;&amp;
+			CanBuildAt(U,position,buildPosition) &amp;&amp; CanBeBuiltAt(U-&gt;BuildQ-&gt;creationUD,buildPosition,i-&gt;second-&gt;udr-&gt;WeaponGuardRange) )
+			if( BID == -1 || position.distance2D(buildPosition) &lt; position.distance2D(cb-&gt;GetUnitPos(BID)) )
+				BID = i-&gt;first;
+	}
+
+	if( BID &gt; 0 )
+	{
+		position = cb-&gt;GetUnitPos(BID);
+		return true;
+	}
+
+	return false;
+}
+
+void cBuilderPlacement::CheckBlockedRList( map&lt;int,ResourceSiteExt*&gt; *RL )
+{
+	if( RL == 0 )
+		RL = &RSAvailable;
+	set&lt;int&gt; deletion;
+	for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=RL-&gt;begin(); iR!=RL-&gt;end(); iR++ )
+	{
+		if( iR-&gt;second-&gt;unitID == -1 )
+			iR-&gt;second-&gt;CheckBlocked();
+		else if( cb-&gt;GetUnitHealth(iR-&gt;second-&gt;unitID) &lt;= 0 )
+		{
+			deletion.insert(iR-&gt;first);
+		}
+	}
+	while( int(deletion.size()) &gt; 0 )
+	{
+		if( RL-&gt;find(*deletion.begin()) != RL-&gt;end() )
+		{
+			ResourceSiteExt* RS = RL-&gt;find(*deletion.begin())-&gt;second;
+			SetResourceOwner(*deletion.begin(),RS,-1);
+			RS-&gt;CheckBlocked();
+		}
+		deletion.erase(deletion.begin());
+	}
+}
+
+void cBuilderPlacement::UpdateAllyResources()
+{
+	int *Units = new int[5000];
+	int UnitsSize;
+	try
+	{
+		UnitsSize = cb-&gt;GetFriendlyUnits(Units);
+	}
+	catch(...)
+	{
+		cb-&gt;SendTextMsg(&quot;ERROR: more than 5000 Friendly Units, increase limit.&quot;,0);
+		*l&lt;&lt;&quot;\n\nERROR: more than 5000 Friendly Units, increase limit.\n&quot;;
+		delete [] Units;
+		return;
+	}
+
+	for( int iU=0; iU&lt;UnitsSize; iU++ )
+	{
+		const UnitDef* ud=cb-&gt;GetUnitDef(Units[iU]);
+		if( !NeedResourceSite(ud) || G-&gt;Units.find(Units[iU]) != G-&gt;Units.end() )
+		{
+			Units[iU--]=Units[--UnitsSize];
+		}
+		else
+		{
+			int iR=GetResourceIndex(Units[iU],ud);
+			if( iR &gt; -1 )
+			{
+				if( Resources[iR]-&gt;unitID == -1 || !Resources[iR]-&gt;BuildOptions.find(ud-&gt;id)-&gt;second.RBRanked )
+				{
+					SetResourceOwner(iR,Resources[iR],Units[iU],&amp;G-&gt;UDH-&gt;UDR.find(ud-&gt;id)-&gt;second);
+				}
+			}
+		}
+	}
+
+	delete [] Units;
+}
+
+int cBuilderPlacement::GetResourceIndex(const int &amp;unit, const UnitDef* ud)
+{
+	int iBest=-1;
+	float fBest;
+	for( int iR=0; iR&lt;ResourceSize; iR++ )
+	{
+		if(	Resources[iR]-&gt;unitID == unit )
+			return iR;
+		if( (Resources[iR]-&gt;S-&gt;type == 0 &amp;&amp; ud-&gt;extractsMetal&gt;0.0 ) ||
+			(Resources[iR]-&gt;S-&gt;type == 1 &amp;&amp; ud-&gt;needGeo ) )
+		{
+			float dis=Resources[iR]-&gt;S-&gt;position.distance2D(cb-&gt;GetUnitPos(unit));
+			if( dis &lt;= Resources[iR]-&gt;searchRadius &amp;&amp; Resources[iR]-&gt;BuildOptions.find(ud-&gt;id) != Resources[iR]-&gt;BuildOptions.end() &amp;&amp; (iBest==-1 || dis &lt; fBest) )
+			{
+				iBest = iR;
+				fBest = dis;
+			}
+		}
+	}
+	return iBest;
+}
+
+void cBuilderPlacement::SetResourceOwner(int RSindex, ResourceSiteExt* RS, int unit, sRAIUnitDef* udr)
+{
+	if( int(RSAvailable.size()) == 0 &amp;&amp; unit &gt;= 0 )
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+			Resources[iR]-&gt;SetRanged(false);
+
+/*	*l&lt;&lt;&quot;\n\nSetResourceOwner(&quot;&lt;&lt;RSindex&lt;&lt;&quot;,_,&quot;&lt;&lt;unit&lt;&lt;&quot;,{&quot;&lt;&lt;(udr==0?&quot;0&quot;:udr-&gt;ud-&gt;humanName)&lt;&lt;&quot;})&quot;;
+	*l&lt;&lt;&quot;\n - Resources Available (&quot;&lt;&lt;Resource.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=Resource.begin(); iR!=Resource.end(); iR++ )
+		*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+*/
+	int oldunit = RS-&gt;unitID;
+	RS-&gt;unitID=unit;
+	RS-&gt;unitUD=udr;
+	RS-&gt;enemy = false;
+	if( unit &gt;= 0 &amp;&amp; cb-&gt;GetUnitAllyTeam(unit) != cb-&gt;GetMyAllyTeam() )
+		RS-&gt;ally = true;
+	else
+		RS-&gt;ally = false;
+	sRAIBuildList *BL;
+	if( RS-&gt;S-&gt;type == 0 )
+		BL=G-&gt;UDH-&gt;BLMetalL;
+	else
+		BL=G-&gt;UDH-&gt;BLEnergyL;
+	if( unit &gt;= 0 &amp;&amp; oldunit == -1 )
+	{
+		if( RSAvailable.find( RSindex ) == RSAvailable.end() )
+		{
+			RS-&gt;SetRanged();
+			RSAvailable.insert(irPair(RSindex,RS));
+			RSRemaining.erase(RSindex);
+		}
+		for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=RS-&gt;Linked.begin(); iR!=RS-&gt;Linked.end(); iR++ )
+		{
+			if( RSAvailable.find(iR-&gt;first) == RSAvailable.end() )
+			{
+				iR-&gt;second-&gt;SetRanged();
+				RSAvailable.insert(irPair(iR-&gt;first,iR-&gt;second));
+				RSRemaining.erase(iR-&gt;first);
+			}
+			for( map&lt;int,ResourceSiteExt*&gt;::iterator iR2=iR-&gt;second-&gt;Linked.begin(); iR2!=iR-&gt;second-&gt;Linked.end(); iR2++ )
+			{
+				if( RSAvailable.find(iR2-&gt;first) == RSAvailable.end() )
+				{
+					iR2-&gt;second-&gt;SetRanged();
+					RSAvailable.insert(irPair(iR2-&gt;first,iR2-&gt;second));
+					RSRemaining.erase(iR2-&gt;first);
+				}
+			}
+		}
+	}
+	else if( unit == -1 )
+	{
+		set&lt;int&gt; RSL;
+		RSL.insert(RSindex);
+		for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=RS-&gt;LinkedD2.begin(); iR!=RS-&gt;LinkedD2.end(); iR++ )
+		{
+			if( RSAvailable.find(iR-&gt;first) != RSAvailable.end() &amp;&amp; ( iR-&gt;second-&gt;unitID == -1 || iR-&gt;second-&gt;enemy ) )
+				RSL.insert(iR-&gt;first);
+		}
+		bool found;
+		while( int(RSL.size()) &gt; 0 )
+		{
+			found=false;
+			for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=Resources[*RSL.begin()]-&gt;LinkedD2.begin(); iR!=Resources[*RSL.begin()]-&gt;LinkedD2.end(); iR++ )
+			{
+				if( Resources[iR-&gt;first]-&gt;unitID &gt; -1 &amp;&amp; !Resources[iR-&gt;first]-&gt;enemy )
+				{
+					found = true;
+					break;
+				}
+			}
+
+			if( !found )
+			{
+				Resources[*RSL.begin()]-&gt;SetRanged(false);
+				RSRemaining.insert(irPair(*RSL.begin(),Resources[*RSL.begin()]));
+				RSAvailable.erase(*RSL.begin());
+			}
+			RSL.erase(RSL.begin());
+		}
+	}
+	RS-&gt;CheckRanked();
+	if( int(RSAvailable.size()) == 0 )
+		for( int iR=0; iR&lt;ResourceSize; iR++ )
+			Resources[iR]-&gt;SetRanged(true);
+/*
+	*l&lt;&lt;&quot;\n - Resources Available (&quot;&lt;&lt;Resource.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=Resource.begin(); iR!=Resource.end(); iR++ )
+		*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+
+	BL=G-&gt;UDH-&gt;BLMetalL;
+	for( int i=0; i&lt;BL-&gt;UDefSize; i++ )
+	{
+		sRAIUnitDef* udrTemp=BL-&gt;UDef[i]-&gt;RUD;
+		if( !udrTemp-&gt;Disabled )
+		{
+			*l&lt;&lt;&quot;\n&quot;+udrTemp-&gt;ud-&gt;humanName;
+			if( udrTemp-&gt;RBPrereq )
+				*l&lt;&lt;&quot;(RBPrereq)&quot;;
+			if( udrTemp-&gt;RBCost )
+				*l&lt;&lt;&quot;(RBCost)&quot;;
+			if( udrTemp-&gt;RBUnitLimit )
+				*l&lt;&lt;&quot;(RBUnitLimit)&quot;;
+			*l&lt;&lt;&quot;: &quot;&lt;&lt;udrTemp-&gt;UnitsActive.size()&lt;&lt;&quot;+&quot;&lt;&lt;udrTemp-&gt;UnitConstructs&lt;&lt;&quot;/&quot;&lt;&lt;udrTemp-&gt;UnitLimit[0];
+		}
+	}
+	BL=G-&gt;UDH-&gt;BLEnergyL;
+	for( int i=0; i&lt;BL-&gt;UDefSize; i++ )
+	{
+		sRAIUnitDef* udrTemp=BL-&gt;UDef[i]-&gt;RUD;
+		if( !udrTemp-&gt;Disabled )
+		{
+			*l&lt;&lt;&quot;\n&quot;+udrTemp-&gt;ud-&gt;humanName;
+			if( udrTemp-&gt;RBPrereq )
+				*l&lt;&lt;&quot;(RBPrereq)&quot;;
+			if( udrTemp-&gt;RBCost )
+				*l&lt;&lt;&quot;(RBCost)&quot;;
+			if( udrTemp-&gt;RBUnitLimit )
+				*l&lt;&lt;&quot;(RBUnitLimit)&quot;;
+			*l&lt;&lt;&quot;: &quot;&lt;&lt;udrTemp-&gt;UnitsActive.size()&lt;&lt;&quot;+&quot;&lt;&lt;udrTemp-&gt;UnitConstructs&lt;&lt;&quot;/&quot;&lt;&lt;udrTemp-&gt;UnitLimit[0];
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Empty Resources Available:&quot;;
+	for( map&lt;int,ResourceSiteExt*&gt;::iterator iR=Resource.begin(); iR!=Resource.end(); iR++ )
+		if( iR-&gt;second-&gt;unitID == -1 || iR-&gt;second-&gt;enemy )
+			*l&lt;&lt;&quot; &quot;&lt;&lt;iR-&gt;first;
+	*l&lt;&lt;&quot;\n\n&quot;;
+*/
+}
+
+float cBuilderPlacement::FindResourceDistance(ResourceSite* R1, ResourceSite* R2, const int &amp;pathType)
+{
+	ResourceSiteDistance* RSD = &amp;R1-&gt;siteDistance.find(R2)-&gt;second;
+	if( RSD-&gt;distance.find(pathType) != RSD-&gt;distance.end() )
+		return RSD-&gt;distance.find(pathType)-&gt;second;
+	if( RSD-&gt;bestDistance != 0 )
+		*l&lt;&lt;&quot;\nERROR: RSD-&gt;bestDistance has already been set.&quot;;
+	RSD-&gt;distance.insert(ifPair(pathType,0.0));
+	float *distance = &amp;RSD-&gt;distance.find(pathType)-&gt;second;
+	int pathID = cb-&gt;InitPath(R1-&gt;position,R2-&gt;position,pathType);
+	RSD-&gt;pathDebug.push_back(R1-&gt;position);
+	do
+	{
+		RSD-&gt;pathDebug.push_back(cb-&gt;GetNextWaypoint(pathID));
+		*distance += RSD-&gt;pathDebug.back().distance(RSD-&gt;pathDebug.at(RSD-&gt;pathDebug.size()-2));
+//		*l&lt;&lt;&quot; x&quot;&lt;&lt;RSD-&gt;pathDebug.back().x&lt;&lt;&quot; z&quot;&lt;&lt;RSD-&gt;pathDebug.back().z&lt;&lt;&quot; &quot;&lt;&lt;*distance&lt;&lt;&quot; &quot;;
+		if( RSD-&gt;pathDebug.back() == RSD-&gt;pathDebug.at(RSD-&gt;pathDebug.size()-2) )
+		{	// The last two points were identical, the pathfinder has failed
+			*distance = -1.0;
+			break;
+		}
+	}
+	while( RSD-&gt;pathDebug.back() != R2-&gt;position ); // the end position has been reached
+	cb-&gt;FreePath(pathID);
+	ResourceSiteDistance* RSD2 = &amp;R2-&gt;siteDistance.find(R1)-&gt;second;
+	RSD2-&gt;distance.insert(ifPair(pathType,*distance));
+	if( *distance &gt; 0 &amp;&amp; RSD-&gt;bestDistance == 0 )
+	{
+		RSD-&gt;bestPathType = pathType;
+		RSD-&gt;bestDistance = distance;
+		RSD2-&gt;bestPathType = pathType;
+		RSD2-&gt;bestDistance = &amp;RSD2-&gt;distance.find(pathType)-&gt;second;
+		if( RAIDEBUGGING )
+			RSD2-&gt;pathDebug = RSD-&gt;pathDebug;
+		else
+			RSD-&gt;pathDebug.clear();
+	}
+	else
+		RSD-&gt;pathDebug.clear();
+	return *distance;
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,147 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_BUILDER_PLACEMENT_H
+#define RAI_BUILDER_PLACEMENT_H
+
+struct ResourceSiteExt;
+class cBuilderPlacement;
+
+#include &quot;RAI.h&quot;
+#include &quot;Builder.h&quot;
+using std::map;
+using std::pair;
+using std::set;
+//#include &quot;Sim/Misc/FeatureDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+
+struct ResourceSiteExtBO
+{
+	ResourceSiteExtBO(sRAIUnitDef* UDR );
+	void CheckBuild();
+	sRAIUnitDef *udr;	// This is the unit in question
+	bool RBBlocked;
+	bool RBRanked;
+	bool RBRanged;
+	bool CanBuild;	// not blocked, not outranked, not outranged - used to adjust SetULConstructs()
+};
+
+struct ResourceSiteExt
+{
+	ResourceSiteExt(ResourceSite *RSite, IAICallback* callback);
+	void CheckBlocked();	// Note: this will not work in a UnitDestroyed Event, since the dead extractor still exists at that moment
+	void CheckRanked();		// For the moment, only called from SetResourceOwner()
+	void SetRanged(bool inRange=true);
+
+	int unitID;					// Valid if a unit is occupying this site, otherwise -1
+	sRAIUnitDef *unitUD;		// Valid if 'UnitID' is set
+	int builderID;				// Valid if a builder has been assigned to this site, otherwise -1
+	UnitInfo *builderUI;		// Valid if 'BuilderID' is set
+	bool enemy;
+	bool ally;
+
+	float searchRadius;	// distance from resource a unit is willing to be built
+	int disApart;		// distance from structures when building a unit
+	ResourceSite *S;	// Basic resource site data
+
+	map&lt;int,ResourceSiteExtBO&gt; BuildOptions;	// The posible units that can be build at this position
+	map&lt;int,ResourceSiteExt*&gt; Linked;		// key value = Resources[] index
+	map&lt;int,ResourceSiteExt*&gt; LinkedD2;	// key value = Resources[] index, All 'Linked' Resources as well as their Linked Resources
+//	int unitLostFrame;
+	IAICallback* cb;	// used in CheckBlocked()
+};
+
+class cBuilderPlacement
+{
+public:
+	cBuilderPlacement(IAICallback* callback, cRAI* global);
+	~cBuilderPlacement();
+	void UResourceCreated(int unit, UnitInfo *U);
+	void UResourceDestroyed(int unit, UnitInfo *U);
+	void EResourceEnterLOS(int enemy, EnemyInfo *E);
+
+	bool NeedResourceSite(const UnitDef* bd);
+	ResourceSiteExt* FindResourceSite(float3&amp; pos, const UnitDef* bd, TerrainMapArea* BuilderMA); // called when a builder has been assigned
+	float3 FindBuildPosition(sBuildQuarry *BQ);
+	void CheckBlockedRList( map&lt;int,ResourceSiteExt*&gt; *RL = 0 ); // CheckBlocked for all resource sites on this list
+
+	// position must be valid
+	bool CanBeBuiltAt(sRAIUnitDef *udr, float3&amp; position, const float&amp; range=0.0); // NOTE: returns false if the area was too small to be recorded
+	bool CanBuildAt(UnitInfo *U, const float3&amp; position, const float3&amp; destination);
+
+	// modified version of ALCallback.cpp's ClosestBuildSite
+//	float3 ClosestBuildSite(const UnitDef* ud, float3 p, float sRadius, int facing=0);
+private:
+	bool FindWeaponPlacement(UnitInfo *U, float3&amp; position);
+	void UpdateAllyResources(); // determines what resources allies have gained or lost
+	int GetResourceIndex(const int &amp;unit, const UnitDef* ud);
+	void SetResourceOwner(int RSindex, ResourceSiteExt *RS, int unit, sRAIUnitDef *udr=0);
+
+	cLogFile *l;
+	cRAI *G;
+	IAICallback *cb;
+	map&lt;int,UnitInfo*&gt; UExtractor;
+	map&lt;int,UnitInfo*&gt; UGeoPlant;
+
+	ResourceSiteExt **Resources; // List of all limited resources (metal,geo)
+	int ResourceSize;
+	typedef pair&lt;int,ResourceSiteExt*&gt; irPair;
+	// A ResourceSiteExt is only on one list at a given time
+	map&lt;int,ResourceSiteExt*&gt; RSAvailable;	// Resources a unit is willing to build at
+	map&lt;int,ResourceSiteExt*&gt; RSRemaining;	// Resources that can not be reached
+/*
+	struct BuildGroup
+	{
+		BuildGroup(int unit)
+		{
+			RS=0;
+			units.insert(unit);
+		};
+		BuildGroup(ResourceSiteExt *Resource)
+		{
+			RS=Resource;
+			position=RS-&gt;position;
+			x=32.0;
+			z=32.0;
+		};
+		float3 position;
+		float x;
+		float z;
+		int type; // 
+		ResourceSiteExt *RS;
+		set&lt;int&gt; units;
+	};
+	struct BuildSector
+	{
+		BuildSector() {};
+		set&lt;BuildGroup&gt; LocalGroup;
+		set&lt;BuildGroup*&gt; Group;
+	};
+	set&lt;BuildGroup*&gt; BorderResource; // Hostile Bordering resource
+	set&lt;BuildGroup*&gt; DefenceDemand; // Possible groups to built a defence into
+	set&lt;BuildGroup*&gt; JammerDemand; // Possible groups to built a radar/sonar jammer into
+	void GroupAdd(BuildGroup *G);
+	void GroupRemove(BuildGroup *G);
+	BuildSector *Sector;
+	int sectorXSize;
+	int sectorZSize;
+	float MapW;	// x
+	float MapH;	// z
+*/
+	// Only used on loading
+
+	// only used during initialization
+	float FindResourceDistance(ResourceSite* R1, ResourceSite* R2, const int &amp;pathType);
+	typedef pair&lt;int,float&gt; ifPair; // used for ResourceSiteDistance.distance
+	struct ResourceLinkInfo
+	{
+		int index;
+		int bestI;				// closest resource not currently linked
+		set&lt;int&gt; restrictedR;	// which indexes should the resource not be compared to
+	};
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/BuilderPlacement.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.cbp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.cbp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.cbp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,55 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
+&lt;CodeBlocks_project_file&gt;
+	&lt;FileVersion major=&quot;1&quot; minor=&quot;6&quot; /&gt;
+	&lt;Project&gt;
+		&lt;Option title=&quot;RAI DLL&quot; /&gt;
+		&lt;Option pch_mode=&quot;0&quot; /&gt;
+		&lt;Option compiler=&quot;gcc&quot; /&gt;
+		&lt;Build&gt;
+			&lt;Target title=&quot;default&quot;&gt;
+				&lt;Option output=&quot;RAI.dll&quot; prefix_auto=&quot;0&quot; extension_auto=&quot;0&quot; /&gt;
+				&lt;Option type=&quot;3&quot; /&gt;
+				&lt;Option compiler=&quot;gcc&quot; /&gt;
+				&lt;Option createStaticLib=&quot;1&quot; /&gt;
+			&lt;/Target&gt;
+		&lt;/Build&gt;
+		&lt;VirtualTargets&gt;
+			&lt;Add alias=&quot;All&quot; targets=&quot;default;&quot; /&gt;
+		&lt;/VirtualTargets&gt;
+		&lt;Compiler&gt;
+			&lt;Add option=&quot;-O3&quot; /&gt;
+			&lt;Add option=&quot;-DBUILD_DLL&quot; /&gt;
+			&lt;Add directory=&quot;..\..\..\..\rts&quot; /&gt;
+			&lt;Add directory=&quot;..\..\..\..\rts\System&quot; /&gt;
+			&lt;Add directory=&quot;..\..\..\..\..\mingwlibs\include&quot; /&gt;
+		&lt;/Compiler&gt;
+		&lt;Unit filename=&quot;..\BasicArray.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\Builder.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\Builder.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\BuilderPlacement.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\BuilderPlacement.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\CombatManager.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\CombatManager.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\DLLExportRAI.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\GResourceMap.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\GResourceMap.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\GTerrainMap.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\GTerrainMap.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\LogFile.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\LogFile.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\PowerManager.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\PowerManager.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\RAI.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\RAI.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\SWeaponManager.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\SWeaponManager.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\UnitDefHandler.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\UnitDefHandler.h&quot; /&gt;
+		&lt;Unit filename=&quot;..\UnitManager.cpp&quot; /&gt;
+		&lt;Unit filename=&quot;..\UnitManager.h&quot; /&gt;
+		&lt;Extensions&gt;
+			&lt;code_completion /&gt;
+			&lt;debugger /&gt;
+		&lt;/Extensions&gt;
+	&lt;/Project&gt;
+&lt;/CodeBlocks_project_file&gt;


Property changes on: branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.cbp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.workspace
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.workspace	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.workspace	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,6 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
+&lt;CodeBlocks_workspace_file&gt;
+	&lt;Workspace title=&quot;Workspace&quot;&gt;
+		&lt;Project filename=&quot;RAI.cbp&quot; active=&quot;1&quot; /&gt;
+	&lt;/Workspace&gt;
+&lt;/CodeBlocks_workspace_file&gt;


Property changes on: branches/caiinterface/AI/Skirmish/RAI/CodeBlocks/RAI.workspace
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/CombatManager.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/CombatManager.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/CombatManager.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,407 @@
+#include &quot;CombatManager.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+
+cCombatManager::cCombatManager(IAICallback* callback, cRAI* Global)
+{
+	cb=callback;
+	G=Global;
+	l=G-&gt;l;
+}
+
+cCombatManager::~cCombatManager()
+{
+}
+
+void cCombatManager::UnitIdle(const int&amp; unit, UnitInfo *U)
+{
+//*l&lt;&lt;&quot;(cui) -eID=&quot;&lt;&lt;U-&gt;enemyID;
+	if( ValidateEnemy(unit,U) &amp;&amp; CanAttack(U,U-&gt;E,GetEnemyPosition(U-&gt;enemyID,U-&gt;E)) == 0 )
+		U-&gt;enemyID=-1;
+	float3 fPos=cb-&gt;GetUnitPos(unit);
+	if( U-&gt;enemyID == -1 )
+		while( (U-&gt;enemyID=GetClosestEnemy(fPos,U)) &gt; 0 &amp;&amp; !ValidateEnemy(unit,U) ) {}
+	float distance = -1;
+	if( U-&gt;enemyID &gt;= 0 )
+	{
+		distance = fPos.distance(GetEnemyPosition(U-&gt;enemyID,U-&gt;E));
+		if( distance == 0 )
+			distance = 1;
+	}
+	if( U-&gt;enemyID == -1 || (U-&gt;udrBL-&gt;task != TASK_ASSAULT &amp;&amp; distance &gt; 2.5*8*U-&gt;ud-&gt;losRadius) )
+	{
+		U-&gt;inCombat=false;
+		G-&gt;UpdateEventAdd(1,0,unit,U);
+		return;
+	}
+	else if( CommandDGun(unit,U) )
+		return;
+	else if( U-&gt;enemyEff == 0 || (U-&gt;udrBL-&gt;task != TASK_ASSAULT &amp;&amp; distance &gt; 1.75*U-&gt;enemyEff-&gt;BestRange ) || (U-&gt;ud-&gt;isCommander &amp;&amp; cb-&gt;GetUnitHealth(unit)/U-&gt;ud-&gt;health &lt;= 0.66 ) ) // || G-&gt;Enemies.find(U-&gt;enemyID)-&gt;second.ud-&gt;kamikazeDist &gt; distance
+	{
+		float3 EPos = GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+		CommandRun(unit,U,EPos);
+		return;
+	}
+	else if( CommandCapture(unit,U,distance) || CommandManeuver(unit,U,distance) )
+		return;
+	else
+	{
+		float3 EPos = GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+		Command c;
+		if( U-&gt;ud-&gt;canAttack &amp;&amp; (U-&gt;E-&gt;inLOS || U-&gt;E-&gt;inRadar) )
+		{
+			c.id = CMD_ATTACK;
+			c.params.push_back(U-&gt;enemyID);
+		}
+		else if( U-&gt;ud-&gt;canAttack &amp;&amp; (U-&gt;udr-&gt;IsBomber &amp;&amp; U-&gt;E-&gt;posLocked) )
+		{
+			c.id = CMD_ATTACK;
+			c.params.push_back(EPos.x);
+			c.params.push_back(EPos.y);
+			c.params.push_back(EPos.z);
+		}
+		else // cant see enemy or Mod Workaround: Combat Lords - cant be given attack orders
+		{
+			c.id = CMD_MOVE;
+			c.params.push_back(EPos.x -100.0 +rand()%201 );
+			c.params.push_back(EPos.y);
+			c.params.push_back(EPos.z -100.0 +rand()%201 );
+		}
+
+		cb-&gt;GiveOrder(unit, &amp;c);
+		G-&gt;UpdateEventAdd(1,int(GetNextUpdate(distance,U)),unit,U);
+	}
+}
+
+void cCombatManager::UnitDamaged(const int&amp; unitID, UnitInfo* U, const int&amp; attackerID, EnemyInfo* A, float3&amp; dir)
+{
+	ValidateEnemy(unitID,U,false);
+	if( attackerID &gt;= 0 &amp;&amp; attackerID != U-&gt;enemyID )
+	{
+		float3 Pos = cb-&gt;GetUnitPos(unitID);
+		float3 APos = GetEnemyPosition(attackerID,A);
+		if( U-&gt;enemyID == -1 || Pos.distance(APos) &lt; Pos.distance(GetEnemyPosition(U-&gt;enemyID,U-&gt;E)) )
+			if( CanAttack(U, A, APos) != 0 &amp;&amp; (U-&gt;group == 0 || U-&gt;group-&gt;Enemies.find(attackerID) != U-&gt;group-&gt;Enemies.end()) )
+			{
+				U-&gt;enemyID=attackerID;
+				U-&gt;E = A;
+				U-&gt;enemyEff = CanAttack(U, A, APos);
+			}
+	}
+	if( U-&gt;inCombat )
+	{
+		if( U-&gt;ud-&gt;isCommander )
+		{
+			if( int(cb-&gt;GetCurrentUnitCommands(unitID)-&gt;size()) == 0 )
+				UnitIdle(unitID,U);
+			else if( cb-&gt;GetCurrentUnitCommands(unitID)-&gt;front().id != CMD_MOVE )
+			{
+				if( cb-&gt;GetUnitHealth(unitID)/U-&gt;ud-&gt;health &lt;= 0.66 || 
+					(cb-&gt;GetUnitHealth(unitID)/U-&gt;ud-&gt;health &lt;= 0.9 &amp;&amp; cb-&gt;GetCurrentUnitCommands(unitID)-&gt;front().id == CMD_CAPTURE) )
+					UnitIdle(unitID,U);
+			}
+		}
+		return;
+	}
+	if( U-&gt;BuildQ != 0 &amp;&amp; U-&gt;BuildQ-&gt;RS != 0 )
+		U-&gt;BuildQ-&gt;tryCount = 4; // If the project is destroyed too many times, give up on it
+	U-&gt;inCombat=true;
+	if( U-&gt;enemyID == -1 )
+	{
+		if( attackerID &gt;= 0 )
+		{
+			float3 APos = GetEnemyPosition(attackerID,A);
+			CommandRun(unitID,U,APos);
+		}
+		else
+		{
+			float3 EPos = cb-&gt;GetUnitPos(unitID);
+			EPos.x += dir.x*700;
+			EPos.z += dir.z*700;
+			EPos.y = cb-&gt;GetElevation(EPos.x,EPos.z);
+			CommandRun(unitID,U,EPos);
+		}
+	}
+	else
+		UnitIdle(unitID,U);
+}
+
+bool cCombatManager::CommandDGun(const int&amp; unitID, UnitInfo *U)
+{
+	if( U-&gt;udr-&gt;DGun == 0 || cb-&gt;GetEnergy() &lt; U-&gt;udr-&gt;DGun-&gt;energycost )
+		return false;
+
+	float3 EPos = GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+	float EDis = EPos.distance(cb-&gt;GetUnitPos(unitID));
+	if( EDis &gt; 1.05*U-&gt;udr-&gt;DGun-&gt;range )
+		return false;
+
+	if( U-&gt;ud-&gt;isCommander )
+	{
+		if( U-&gt;E-&gt;ud != 0 &amp;&amp; U-&gt;E-&gt;ud-&gt;isCommander )
+		{
+			CommandRun(unitID,U,EPos);
+			return true;
+		}
+	}
+	Command c;
+	c.id=CMD_DGUN;
+	c.params.push_back(EPos.x);
+	c.params.push_back(EPos.y);
+	c.params.push_back(EPos.z);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+5,unitID,U);
+	return true;
+}
+
+bool cCombatManager::CommandCapture(const int&amp; unitID, UnitInfo* U, const float&amp; EDis)
+{
+	if( !U-&gt;ud-&gt;canCapture ) //|| EDis &gt; 1.5*U-&gt;ud-&gt;buildDistance )
+		return false;
+
+	if( U-&gt;ud-&gt;isCommander &amp;&amp; cb-&gt;GetUnitHealth(unitID)/U-&gt;ud-&gt;health &lt;= 0.9 )
+		return false;
+
+	if( !U-&gt;E-&gt;inLOS || (!cb-&gt;IsUnitParalyzed(U-&gt;enemyID) &amp;&amp; 1.5*U-&gt;ud-&gt;speed &lt; U-&gt;E-&gt;ud-&gt;speed) )
+		return false;
+
+	Command c;
+	c.id = CMD_CAPTURE;
+	c.params.push_back(U-&gt;enemyID);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	return true;
+}
+/*
+bool cCombatManager::CommandTrap(const int&amp; unitID, UnitInfo* U, const float&amp; EDis)
+{
+	if( !U-&gt;E-&gt;inLOS || U-&gt;ud-&gt;transportMass &lt; U-&gt;E-&gt;ud-&gt;mass )
+		return false;
+	if( U-&gt;ud-&gt;transportCapacity == 0 )
+		return false;
+
+	Command c;
+	c.id = CMD_LOAD_UNITS;
+	c.params.push_back(U-&gt;enemyID);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	return true;
+}
+*/
+bool cCombatManager::CommandManeuver(const int&amp; unitID, UnitInfo *U, const float&amp; EDis)
+{
+	if( U-&gt;ud-&gt;canfly || U-&gt;E-&gt;ud == 0 || !U-&gt;E-&gt;inLOS || U-&gt;enemyEff-&gt;BestRange &lt;= 1.15*cb-&gt;GetUnitMaxRange(U-&gt;enemyID) || EDis &gt; 3500.0 || int(G-&gt;UMobile.size()) &gt; 60 )
+		return false;
+
+	float3 Pos=cb-&gt;GetUnitPos(unitID);
+	float3 EPos=GetEnemyPosition(U-&gt;enemyID,U-&gt;E);
+
+	if( U-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; Pos.y &lt;= 0 &amp;&amp; U-&gt;udr-&gt;WeaponSeaEff.BestRange == 0 )
+	{
+		int iS=G-&gt;TM-&gt;GetSectorIndex(EPos);
+		if( G-&gt;TM-&gt;IsSectorValid(iS) )
+		{
+			Pos = G-&gt;TM-&gt;GetClosestSector(G-&gt;TM-&gt;landSectorType,iS)-&gt;position;
+			Pos.x+=128-rand()%256;
+			Pos.z+=128-rand()%256;
+			G-&gt;CorrectPosition(Pos);
+			Command c;
+			c.id = CMD_MOVE;
+			c.params.push_back(Pos.x);
+			c.params.push_back(Pos.y);
+			c.params.push_back(Pos.z);
+			cb-&gt;GiveOrder(unitID, &amp;c);
+			G-&gt;UpdateEventAdd(1,int(GetNextUpdate(EDis,U)),unitID,U);
+			return true;
+		}
+	}
+	if( EDis &lt; 0.70*U-&gt;enemyEff-&gt;BestRange || EDis &gt; U-&gt;enemyEff-&gt;BestRange )
+	{
+		float distanceAway=(0.87*U-&gt;enemyEff-&gt;BestRange-EDis);
+		Pos.x+=(Pos.x-EPos.x)*(distanceAway/EDis);
+		Pos.z+=(Pos.z-EPos.z)*(distanceAway/EDis);
+
+		if( !G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,Pos) )
+			return false;
+
+		Command c;
+		c.id = CMD_MOVE;
+		c.params.push_back(Pos.x);
+		c.params.push_back(cb-&gt;GetElevation(Pos.x,Pos.z));
+		c.params.push_back(Pos.z);
+		cb-&gt;GiveOrder(unitID, &amp;c);
+		G-&gt;UpdateEventAdd(1,int(GetNextUpdate(EDis,U)),unitID,U);
+		return true;
+	}
+	return false;
+}
+
+void cCombatManager::CommandRun(const int&amp; unitID, UnitInfo *U, float3&amp; EPos)
+{
+	float3 Pos=cb-&gt;GetUnitPos(unitID);
+	Pos.x+=Pos.x-EPos.x;
+	Pos.z+=Pos.z-EPos.z;
+	G-&gt;CorrectPosition(Pos);
+	Command c;
+	c.id = CMD_MOVE;
+	c.params.push_back(Pos.x);
+	c.params.push_back(cb-&gt;GetElevation(Pos.x,Pos.z));
+	c.params.push_back(Pos.z);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+	G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+210,unitID,U);
+}
+
+int cCombatManager::GetClosestEnemy(float3 Pos, UnitInfo* U)
+{
+	U-&gt;enemyID=-1;
+	// these two function need improvement, for now I'll just use a short cut
+	if( !G-&gt;UM-&gt;ActiveAttackOrders() &amp;&amp; U-&gt;udrBL-&gt;task != TASK_SUICIDE )
+		return GetClosestThreat(Pos, U);
+	sWeaponEfficiency* weTemp;
+	float distance,fTemp;
+	float3 fE;
+	for( map&lt;int,EnemyInfo&gt;::iterator E=G-&gt;Enemies.begin(); E!=G-&gt;Enemies.end(); E++ )
+	{
+		fE=GetEnemyPosition(E-&gt;first,&amp;E-&gt;second);
+		if( (weTemp = CanAttack(U,&amp;E-&gt;second,fE)) != 0 )
+		{
+			fTemp=Pos.distance(fE);
+			if( U-&gt;enemyID == -1 || fTemp &lt; distance )
+			{
+				U-&gt;enemyID=E-&gt;first;
+				U-&gt;E = &amp;E-&gt;second;
+				U-&gt;enemyEff = weTemp;
+				distance=fTemp;
+			}
+		}
+	}
+	if( U-&gt;enemyID != -1 &amp;&amp; U-&gt;group != 0 )
+		G-&gt;UM-&gt;GroupAddEnemy(U-&gt;enemyID,U-&gt;E,U-&gt;group);
+	return U-&gt;enemyID;
+}
+
+int cCombatManager::GetClosestThreat(float3 Pos, UnitInfo* U)
+{
+	sWeaponEfficiency* weTemp;
+	float distance,fTemp;
+	float3 fE;
+	set&lt;int&gt; deletion;
+	for( map&lt;int,EnemyInfo*&gt;::iterator E=G-&gt;EThreat.begin(); E!=G-&gt;EThreat.end(); E++ )
+	{
+		fE=GetEnemyPosition(E-&gt;first,E-&gt;second);
+		if( E-&gt;second-&gt;baseThreatFrame &gt; cb-&gt;GetCurrentFrame()+3600 ||
+			(E-&gt;second-&gt;baseThreatFrame &gt; cb-&gt;GetCurrentFrame()+1200 &amp;&amp; G-&gt;UImmobile.find(E-&gt;second-&gt;baseThreatID) == G-&gt;UImmobile.end() ) ||
+			(E-&gt;second-&gt;ud != 0 &amp;&amp; G-&gt;UImmobile.find(E-&gt;second-&gt;baseThreatID) != G-&gt;UImmobile.end() &amp;&amp; 1.3*E-&gt;second-&gt;ud-&gt;maxWeaponRange &lt; fE.distance(cb-&gt;GetUnitPos(E-&gt;second-&gt;baseThreatID)) ) )
+		{
+			E-&gt;second-&gt;baseThreatID = -1;
+			E-&gt;second-&gt;baseThreatFrame = -1;
+			deletion.insert(E-&gt;first);
+		}
+		else if( (weTemp = CanAttack(U,E-&gt;second,fE)) != 0 )
+		{
+			fTemp=Pos.distance(fE);
+			if( U-&gt;enemyID == -1 || fTemp &lt; distance )
+			{
+				U-&gt;enemyID=E-&gt;first;
+				U-&gt;E = E-&gt;second;
+				U-&gt;enemyEff = weTemp;
+				distance=fTemp;
+			}
+		}
+	}
+	while( int(deletion.size()) &gt; 0 )
+	{
+		if( !G-&gt;UM-&gt;ActiveAttackOrders() )
+		{
+			EnemyInfo* E = G-&gt;EThreat.find(*deletion.begin())-&gt;second;
+			while( int(E-&gt;attackGroups.size()) &gt; 0 )
+				G-&gt;UM-&gt;GroupRemoveEnemy(*deletion.begin(),E,*E-&gt;attackGroups.begin());
+		}
+		G-&gt;EThreat.erase(*deletion.begin());
+		deletion.erase(*deletion.begin());
+	}
+	if( U-&gt;enemyID != -1 &amp;&amp; U-&gt;group != 0 )
+		G-&gt;UM-&gt;GroupAddEnemy(U-&gt;enemyID,U-&gt;E,U-&gt;group);
+	return U-&gt;enemyID;
+}
+
+float3 cCombatManager::GetEnemyPosition(const int&amp; enemyID, EnemyInfo* E)
+{
+	if( E-&gt;posLocked || (!E-&gt;inLOS &amp;&amp; !E-&gt;inRadar) )
+		return E-&gt;position;
+	return cb-&gt;GetUnitPos(enemyID);
+}
+
+float cCombatManager::GetNextUpdate(const float &amp;Distance, UnitInfo* U)
+{
+	if( U-&gt;ud-&gt;speed == 0.0 )
+		return cb-&gt;GetCurrentFrame()+90.0;
+	float fFrame=30.0*((Distance-U-&gt;enemyEff-&gt;BestRange)/(5.0*U-&gt;ud-&gt;speed));
+	if( int(G-&gt;UMobile.size()) &gt; 45 )
+		fFrame*=3;
+	if( fFrame &gt; 90.0 )
+		return cb-&gt;GetCurrentFrame()+fFrame;
+	return cb-&gt;GetCurrentFrame()+90.0;
+}
+
+sWeaponEfficiency* cCombatManager::CanAttack(UnitInfo* U, EnemyInfo *E, const float3&amp; EPos)
+{
+	if( !G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,EPos) )
+		return 0;
+	float fElevation=cb-&gt;GetElevation(EPos.x,EPos.z);
+	if( EPos.y &lt; 0.0 &amp;&amp; U-&gt;udr-&gt;WeaponSeaEff.BestRange &gt; 0 )
+		return &amp;U-&gt;udr-&gt;WeaponSeaEff;
+	if( EPos.y-fElevation&gt;50.0 &amp;&amp; U-&gt;udr-&gt;WeaponAirEff.BestRange &gt; 0 )
+		return &amp;U-&gt;udr-&gt;WeaponAirEff;
+	if( EPos.y-fElevation&lt;=50.0 &amp;&amp; EPos.y &gt;= -15.0 &amp;&amp; U-&gt;udr-&gt;WeaponLandEff.BestRange &gt; 0 )
+		return &amp;U-&gt;udr-&gt;WeaponLandEff;
+	return 0;
+}
+
+bool cCombatManager::ValidateEnemy(const int&amp; unitID, UnitInfo* U, bool IdleIfInvalid)
+{
+	if( U-&gt;enemyID == -1 || G-&gt;Enemies.find(U-&gt;enemyID) == G-&gt;Enemies.end() )
+	{	// old enemy target that doesn't exist
+		U-&gt;enemyID=-1;
+		if( IdleIfInvalid )
+			G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+90,unitID,U);
+		return false;
+	}
+	float3 EPos = cb-&gt;GetUnitPos(U-&gt;enemyID);
+	if( U-&gt;group == 0 )
+	{	// keeping variables up-to-date, this is event-driven for groups
+		U-&gt;E = &amp;G-&gt;Enemies.find(U-&gt;enemyID)-&gt;second;
+		U-&gt;enemyEff = CanAttack(U,U-&gt;E,EPos);
+	}
+	if( cb-&gt;GetUnitDef(U-&gt;enemyID) != 0 &amp;&amp; cb-&gt;GetUnitAllyTeam(unitID) == cb-&gt;GetUnitAllyTeam(U-&gt;enemyID) )
+	{	// an enemy ID was reused by an ally team
+		if( U-&gt;E-&gt;inLOS || U-&gt;E-&gt;inRadar ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+		{	// OR an ally captures an enemy unit &amp; no events were sent
+			*l&lt;&lt;&quot;\nWARNING: ValidateEnemy(eID=&quot;&lt;&lt;U-&gt;enemyID&lt;&lt;&quot;): an ally has captured an enemy unit&quot;;
+		}
+		G-&gt;EnemyDestroyed(U-&gt;enemyID,-1);
+		U-&gt;enemyID=-1;
+		return false;
+	}
+	if( EPos.x &gt; 0 || EPos.z &gt; 0 || EPos.y &gt; 0 ) // Position is valid
+	{
+		if( !U-&gt;E-&gt;inLOS &amp;&amp; !U-&gt;E-&gt;inRadar ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+		{
+			if( cb-&gt;GetUnitDef(U-&gt;enemyID) != 0 )
+			{
+				*l&lt;&lt;&quot;\nWARNING: ValidateEnemy(eID=&quot;&lt;&lt;U-&gt;enemyID&lt;&lt;&quot;): incorrect LOS status&quot;;
+				G-&gt;EnemyEnterLOS(U-&gt;enemyID);
+			}
+			else
+			{
+				*l&lt;&lt;&quot;\nWARNING: ValidateEnemy(eID=&quot;&lt;&lt;U-&gt;enemyID&lt;&lt;&quot;): incorrect radar status&quot;;
+				G-&gt;EnemyEnterRadar(U-&gt;enemyID);
+			}
+		}
+		return true;
+	}
+	if( !U-&gt;E-&gt;inLOS &amp;&amp; !U-&gt;E-&gt;inRadar &amp;&amp; cb-&gt;GetUnitPos(unitID).distance2D(U-&gt;E-&gt;position) &gt; 300.0f )
+		return true;
+	G-&gt;EnemyRemove(U-&gt;enemyID,U-&gt;E);
+	U-&gt;enemyID=-1;
+	if( IdleIfInvalid )
+		G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+90,unitID,U);
+	return false;
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/CombatManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/CombatManager.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/CombatManager.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/CombatManager.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,42 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_COMBAT_MANAGER_H
+#define RAI_COMBAT_MANAGER_H
+
+class cCombatManager;
+
+#include &quot;RAI.h&quot;
+//#include &quot;LogFile.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+
+class cCombatManager
+{
+public:
+	cCombatManager(IAICallback* callback, cRAI* Global);
+	~cCombatManager();
+
+	void UnitIdle(const int&amp; unit, UnitInfo *U);
+	void UnitDamaged(const int&amp; unitID, UnitInfo* U, const int&amp; attackerID, EnemyInfo* A, float3&amp; dir);
+	bool CommandDGun(const int&amp; unitID, UnitInfo* U);
+	bool CommandCapture(const int&amp; unitID, UnitInfo* U, const float&amp; EDis);
+//	bool CommandTrap(const int&amp; unitID, UnitInfo* U, const float&amp; EDis);
+	bool CommandManeuver(const int&amp; unitID, UnitInfo* U, const float&amp; EDis);
+	void CommandRun(const int&amp; unitID, UnitInfo* U, float3&amp; EPos);
+	int GetClosestEnemy(float3 Pos, UnitInfo* U);
+	float3 GetEnemyPosition(const int&amp; enemyID, EnemyInfo* E);
+	float GetNextUpdate(const float&amp; Distance, UnitInfo* U);
+	sWeaponEfficiency* CanAttack(UnitInfo* U, EnemyInfo* E, const float3&amp; EPos);
+	bool ValidateEnemy(const int&amp; unitID, UnitInfo* U, bool IdleIfInvalid=true);
+
+private:
+	int GetClosestThreat(float3 Pos, UnitInfo* U);
+	cLogFile *l;
+	IAICallback* cb;
+	cRAI* G;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/CombatManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,30 @@
+#include &quot;RAI.h&quot;
+#include &quot;ExternalAI/aibase.h&quot;
+//#include &lt;set&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+
+std::set&lt;IGlobalAI*&gt; ais;
+
+DLL_EXPORT int GetGlobalAiVersion()
+{
+	return GLOBAL_AI_INTERFACE_VERSION;
+}
+
+DLL_EXPORT void GetAiName(char* name)
+{
+	strcpy(name,AI_NAME);
+}
+
+DLL_EXPORT IGlobalAI* GetNewAI()
+{
+	cRAI* ai=new cRAI;
+	ais.insert(ai);
+	return ai;
+}
+
+DLL_EXPORT void ReleaseAI(IGlobalAI* i)
+{
+	delete (cRAI*)i;
+	ais.erase(i);
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/DevC/RAI.dev
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/DevC/RAI.dev	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/DevC/RAI.dev	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,389 @@
+[Project]
+FileName=RAI.dev
+Name=RAI
+UnitCount=24
+Type=3
+Ver=1
+ObjFiles=
+Includes=..\..\..\..\rts;..\..\..\..\rts\system;..\..\..\..\..\mingwlibs\include
+Libs=
+PrivateResource=
+ResourceIncludes=
+MakeIncludes=
+Compiler=-DBUILDING_DLL=1_@@_
+CppCompiler=-DBUILDING_DLL=1_@@_
+Linker=--no-export-all-symbols --add-stdcall-alias_@@_C:/Dev-Cpp/lib/libgdi32.a_@@_
+IsCpp=1
+Icon=
+ExeOutput=
+ObjectOutput=Ming
+OverrideOutput=1
+OverrideOutputName=RAI.dll
+HostApplication=
+Folders=Header,Source
+CommandLine=
+UseCustomMakefile=0
+CustomMakefile=
+IncludeVersionInfo=0
+SupportXPThemes=0
+CompilerSet=0
+CompilerSettings=0011000000010000010100
+
+[Unit11]
+FileName=..\PowerManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit13]
+FileName=..\RAI.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit15]
+FileName=..\SWeaponManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit20]
+FileName=..\GResourceMap.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit21]
+FileName=..\DLLExportRAI.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit22]
+FileName=..\BasicArray.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit23]
+FileName=..\UnitDefHandler.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit28]
+FileName=..\Krogs Metal Class v0.4\MetalMap.cpp
+CompileCpp=1
+Folder=RAI
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit29]
+FileName=..\Krogs Metal Class v0.4\MetalMap.h
+CompileCpp=1
+Folder=RAI
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[VersionInfo]
+Major=0
+Minor=1
+Release=1
+Build=1
+LanguageID=1033
+CharsetID=1252
+CompanyName=
+FileVersion=
+FileDescription=Developed using the Dev-C++ IDE
+InternalName=
+LegalCopyright=
+LegalTrademarks=
+OriginalFilename=
+ProductName=
+ProductVersion=
+AutoIncBuildNr=0
+
+[Unit31]
+FileName=..\TaskTransport.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit32]
+FileName=..\TaskTransport.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit34]
+FileName=..\Krogs Metal Class v0.4\MetalMap.h
+CompileCpp=1
+Folder=Krogs Metal Class v0.4
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit33]
+FileName=..\Krogs Metal Class v0.4\MetalMap.cpp
+CompileCpp=1
+Folder=Krogs Metal Class v0.4
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit14]
+FileName=..\RAI.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit1]
+FileName=..\Builder.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit2]
+FileName=..\Builder.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit3]
+FileName=..\BuilderPlacement.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit4]
+FileName=..\BuilderPlacement.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit5]
+FileName=..\CombatManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit6]
+FileName=..\CombatManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit7]
+FileName=..\GTerrainMap.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit8]
+FileName=..\GTerrainMap.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit9]
+FileName=..\LogFile.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit10]
+FileName=..\LogFile.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit12]
+FileName=..\PowerManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit16]
+FileName=..\SWeaponManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit17]
+FileName=..\UnitManager.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit18]
+FileName=..\UnitManager.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit19]
+FileName=..\GResourceMap.cpp
+CompileCpp=1
+Folder=Source
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit26]
+FileName=..\KrogsMetalClass-v0.4\MetalMap.h
+CompileCpp=1
+Folder=RAI
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit27]
+FileName=..\GPathfinder.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit30]
+FileName=..\BasicArray.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit24]
+FileName=..\UnitDefHandler.h
+CompileCpp=1
+Folder=Header
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit25]
+FileName=..\KrogsMetalClass-v0.4\MetalMap.cpp
+CompileCpp=1
+Folder=RAI
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+


Property changes on: branches/caiinterface/AI/Skirmish/RAI/DevC/RAI.dev
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,876 @@
+#include &quot;GResourceMap.h&quot;
+#include &lt;set&gt;
+#include &quot;Sim/Features/FeatureDef.h&quot;
+//#include &lt;time.h&gt;
+#include &lt;stdio.h&gt;
+
+// a metal map block is 0-255 * cb-&gt;GetMaxMetal(), extractors are normally built on several
+const int RAI_MinimalMetalSite = 500; // (this * ud-&gt;extractsMetal = the predicted income)
+
+ResourceSite::ResourceSite(float3&amp; rsPosition, int rsFeatureID, const FeatureDef* fd)
+{
+	featureID = rsFeatureID;
+	featureD = fd;
+	if( featureID &gt;= 0 )
+	{
+		type = 1;
+		amount = 1.0;
+	}
+	else
+	{
+		type = 0;
+		amount = 0.0;
+	}
+	position = rsPosition;
+}
+
+float ResourceSite::GetResourceDistance(ResourceSite* RS, const int&amp; pathType)
+{
+	ResourceSiteDistance* RSD = &amp;siteDistance.find(RS)-&gt;second;
+	if( RSD-&gt;distance.find(pathType) != RSD-&gt;distance.end() )
+		return RSD-&gt;distance.find(pathType)-&gt;second;
+	if( RSD-&gt;bestDistance != 0 )
+		return *RSD-&gt;bestDistance;
+	return RSD-&gt;minDistance;
+}
+
+GlobalResourceMap::GlobalResourceMap(IAICallback* cb, cLogFile* l, GlobalTerrainMap* TM)
+{
+//	l = logfile;
+	*l&lt;&lt;&quot;\n Loading the Resource-Map ...&quot;;
+
+	const int RAI_MaxMetalSites = 1500;
+	const int RAI_MaxGeoSites = 500;
+
+	for( int iT=0; iT&lt;2; iT++ )
+		RSize[iT] = 0;
+	R[0] = new ResourceSite*[RAI_MaxMetalSites];
+	R[1] = new ResourceSite*[RAI_MaxGeoSites];
+	sector = 0;
+
+	bool UDMetalResources = false;
+	bool UDGeoResource = false;
+	int udSize=cb-&gt;GetNumUnitDefs();
+	const UnitDef **udList = new const UnitDef*[udSize];
+	cb-&gt;GetUnitDefList(udList);
+	for( int iud=udSize-1; iud&gt;=0; iud-- )
+	{
+		if( udList[iud] == 0 ) // Work-Around(Several Mods):  Spring-Version(v0.72b1-0.76b1)
+		{
+			cb-&gt;SendTextMsg(&quot;WARNING: Mod Unit Definition Invalid.&quot;,0);
+			*l&lt;&lt;&quot;\n  WARNING: (unitdef-&gt;id=&quot;&lt;&lt;iud+1&lt;&lt;&quot;) Mod UnitDefList[&quot;&lt;&lt;iud&lt;&lt;&quot;] = 0&quot;;
+			udSize--;
+			udList[iud] = udList[udSize];
+		}
+		else if( udList[iud]-&gt;extractsMetal &gt; 0 )
+			UDMetalResources = true;
+		else if( udList[iud]-&gt;needGeo )
+			UDGeoResource = true;
+		else
+		{
+			udSize--;
+			udList[iud] = udList[udSize];
+		}
+	}
+
+	if( !UDGeoResource &amp;&amp; !UDMetalResources )
+	{
+		saveResourceFile = false;
+		delete [] udList;
+		*l&lt;&lt;&quot;\n  No resource units were detected for this mod.&quot;;
+		return;
+	}
+
+	int *fList;
+	int fSize = 0;
+	if( UDGeoResource )
+	{
+		fList = new int[10000]; // Feature List
+//		int fSize = cb-&gt;GetFeatures(fList,10000); // Crashes:  Spring-Version(v0.75b2-v0.76b1)
+		fSize = cb-&gt;GetFeatures(fList,10000,float3(1,1,1),999999); // Crash Work-Around
+		if( fSize == 10000 )
+		{
+			cb-&gt;SendTextMsg(&quot;WARNING: not all features will be searched for Geo Build Options&quot;,0);
+			*l&lt;&lt;&quot;\nWARNING: not all features will be searched for Geo Build Options&quot;;
+		}
+		for(int i=0; i&lt;fSize; i++)
+			if( !cb-&gt;GetFeatureDef(fList[i])-&gt;geoThermal )
+				fList[i] = fList[--fSize];
+	}
+
+	resourceFileName = RAIDirectory + &quot;cache/&quot; + string(cb-&gt;GetModName());
+	resourceFileName.resize(resourceFileName.size()-4);
+	resourceFileName += &quot;-&quot; + string(cb-&gt;GetMapName());
+	resourceFileName.resize(resourceFileName.size()-3);
+	resourceFileName += &quot;res&quot;;
+	FILE *resourceFile = fopen(resourceFileName.c_str(),&quot;rb&quot;);
+	bool useResourceFile = false;
+	if( resourceFile )
+	{
+		useResourceFile = true;
+		*l&lt;&lt;&quot;\n  Loading Resource-Site Data ...&quot;;
+		int udL2Size;
+		fread(&amp;udL2Size, sizeof(int), 1, resourceFile);
+		if( udSize != udL2Size )
+			useResourceFile = false;
+		else
+		{	// Checks if the unit-Def list have changed
+			int ID;
+			for( int i=0; i&lt;udSize; i++ )
+			{
+				fread(&amp;ID, sizeof(int), 1, resourceFile);
+				if( udList[i]-&gt;id != ID )
+				{	// The order or types of definitions have changed
+					useResourceFile = false;
+					break;
+				}
+			}
+			if( useResourceFile )
+			{
+				int featureSites;
+				fread(&amp;featureSites, sizeof(int), 1, resourceFile);
+				if( fSize != featureSites )
+					useResourceFile = false;
+				else
+				{	// Checks if the feature resource list has changed
+					for( int i=0; i&lt;fSize; i++ )
+					{
+						fread(&amp;ID, sizeof(int), 1, resourceFile);
+						if( fList[i] != ID )
+						{	// The order or types of features have changed
+							useResourceFile = false;
+							break;
+						}
+					}
+					if( useResourceFile )
+					{	// The actual loading starts here
+						typedef pair&lt;ResourceSite*,ResourceSiteDistance&gt; rrPair;
+						typedef pair&lt;int,float&gt; ifPair;
+						float3 position;
+						float distance;
+						int featureID;
+						int size,dSize;
+						int iT2,iR2;
+						int optionID;
+						for( int iT=0; iT&lt;2; iT++ )
+						{
+							fread(&amp;RSize[iT], sizeof(int), 1, resourceFile);
+							for( int iR=0; iR&lt;RSize[iT]; iR++ )
+							{
+								fread(&amp;featureID, sizeof(int), 1, resourceFile);
+								fread(&amp;position, sizeof(float3), 1, resourceFile);
+								if( featureID &gt;= 0 )
+									R[iT][iR] = new ResourceSite(position,featureID,cb-&gt;GetFeatureDef(featureID));
+								else
+									R[iT][iR] = new ResourceSite(position);
+								fread(&amp;R[iT][iR]-&gt;amount, sizeof(float), 1, resourceFile);
+								fread(&amp;size, sizeof(int), 1, resourceFile);
+								for( int i=0; i&lt;size; i++ )
+								{
+									fread(&amp;optionID, sizeof(int), 1, resourceFile);
+									R[iT][iR]-&gt;options.insert(optionID);
+								}
+							}
+						}
+						for( int iT=0; iT&lt;2; iT++ )
+							for( int iR=0; iR&lt;RSize[iT]; iR++ )
+							{
+								fread(&amp;size, sizeof(int), 1, resourceFile);
+								for( int i=0; i&lt;size; i++ )
+								{
+									fread(&amp;iT2, sizeof(int), 1, resourceFile);
+									fread(&amp;iR2, sizeof(int), 1, resourceFile);
+									R[iT][iR]-&gt;siteDistance.insert(rrPair(R[iT2][iR2],ResourceSiteDistance(0.0)));
+									ResourceSiteDistance* RSD = &amp;R[iT][iR]-&gt;siteDistance.find(R[iT2][iR2])-&gt;second;
+									fread(&amp;RSD-&gt;minDistance, sizeof(float), 1, resourceFile);
+									fread(&amp;RSD-&gt;bestPathType, sizeof(int), 1, resourceFile);
+									fread(&amp;dSize, sizeof(int), 1, resourceFile);
+									for( int i=0; i&lt;dSize; i++ )
+									{
+										fread(&amp;optionID, sizeof(int), 1, resourceFile);
+										fread(&amp;distance, sizeof(float), 1, resourceFile);
+										RSD-&gt;distance.insert(ifPair(optionID,distance));
+									}
+									fread(&amp;dSize, sizeof(int), 1, resourceFile);
+									for( int i=0; i&lt;dSize; i++ )
+									{
+										fread(&amp;position, sizeof(float3), 1, resourceFile);
+										RSD-&gt;pathDebug.push_back(position);
+									}
+									if( RSD-&gt;bestPathType == -2 )
+										RSD-&gt;bestDistance = &amp;RSD-&gt;minDistance;
+									else if( RSD-&gt;bestPathType &gt;= 0 )
+										RSD-&gt;bestDistance = &amp;RSD-&gt;distance.find(RSD-&gt;bestPathType)-&gt;second;
+								}
+							}
+						fread(&amp;averageMetalSite, sizeof(float), 1, resourceFile);
+						fread(&amp;isMetalMap, sizeof(bool), 1, resourceFile);
+						if( isMetalMap )
+						{
+							sector = new MetalMapSector[TM-&gt;sectorXSize*TM-&gt;sectorZSize];
+							for( int iS=0; iS&lt;TM-&gt;sectorXSize*TM-&gt;sectorZSize; iS++ )
+							{
+								fread(&amp;sector[iS].isMetalSector, sizeof(bool), 1, resourceFile);
+								sector[iS].S = &amp;TM-&gt;sector[iS];
+							}
+						}
+					}
+				}
+			}
+		}
+		fclose(resourceFile);
+		if( !useResourceFile )
+			*l&lt;&lt;&quot;\n  A change has been detected in the map/mod, the resource data will be reloaded.&quot;;
+	}
+
+	if( useResourceFile || cb-&gt;GetCurrentFrame() == 0 )
+	{	// only save the data if it was created at the beginning of a game
+		saveResourceFile = true;
+		for( int i=0; i&lt;udSize; i++ )
+			saveUD.push_back(udList[i]-&gt;id);
+		for( int i=0; i&lt;fSize; i++ )
+			saveF.push_back(fList[i]);
+		saveSectorSize = TM-&gt;sectorXSize*TM-&gt;sectorZSize;
+	}
+	else
+		saveResourceFile = false;
+
+	if( !UDGeoResource )
+		*l&lt;&lt;&quot;\n  No geo-resource units were detected for this mod.&quot;;
+	else if( !useResourceFile )
+	{
+		*l&lt;&lt;&quot;\n  Finding Geo-Sites ...&quot;;
+		float3 position;
+		float3 buildPosition;
+		for(int i=0; i&lt;fSize; i++)
+		{
+			const FeatureDef *fd = cb-&gt;GetFeatureDef(fList[i]);
+			if( fd-&gt;geoThermal )
+			{
+				position = cb-&gt;GetFeaturePos(fList[i]);
+				if( !TM-&gt;waterIsHarmful || cb-&gt;GetElevation(position.x,position.z) &gt;= 0 )
+				{
+					ResourceSite *RS = new ResourceSite(position,fList[i],fd);
+					for( int iud=0; iud&lt;udSize; iud++ )
+					{
+						const UnitDef* ud = udList[iud];
+						if( ud-&gt;needGeo )
+						{
+							buildPosition = cb-&gt;ClosestBuildSite(ud,RS-&gt;position,48.0f,0);
+							if( cb-&gt;CanBuildAt(ud,buildPosition) )
+								RS-&gt;options.insert(ud-&gt;id);
+						}
+					}
+					if( RS-&gt;options.size() == 0 )
+					{
+						*l&lt;&lt;&quot;\n  Energy Resource located at (x&quot;&lt;&lt;RS-&gt;position.x&lt;&lt;&quot; z&quot;&lt;&lt;RS-&gt;position.z&lt;&lt;&quot; y&quot;&lt;&lt;RS-&gt;position.y&lt;&lt;&quot;) is unusable in this mod.&quot;;
+						delete RS;
+					}
+					else
+						R[1][RSize[1]++] = RS;
+				}
+			}
+		}
+		delete [] fList;
+		*l&lt;&lt;&quot;\n   Geo-Sites Found: &quot;&lt;&lt;RSize[1];
+	}
+	else
+	{
+		delete [] fList;
+		*l&lt;&lt;&quot;\n   Geo-Sites Loaded: &quot;&lt;&lt;RSize[1];
+	}
+
+	if( !UDMetalResources )
+	{
+		*l&lt;&lt;&quot;\n  No metal-resource units were detected for this mod.&quot;;
+		isMetalMap = false;
+		averageMetalSite = 0.0;
+	}
+	else if( !useResourceFile )
+	{
+		*l&lt;&lt;&quot;\n  Determining the available amount of metal ...&quot;;
+		*l&lt;&lt;&quot;\n   GetMaxMetal(): &quot;&lt;&lt;cb-&gt;GetMaxMetal();
+		// Calculate the radius distances &amp; ranges
+		const float MMExtractorRadius = cb-&gt;GetExtractorRadius()/16.0;
+		MMExtractorRadiusI = MMExtractorRadius;
+		*l&lt;&lt;&quot;\n   Metal-Map Extractor Radius: &quot;&lt;&lt;MMExtractorRadius;
+		const int MMRSSize = MMExtractorRadiusI*2+1;
+		MMRS = new sMMRadiusSquare*[MMRSSize];
+		for( int x=0; x&lt;MMRSSize; x++ )
+		{
+			MMRS[x] = new sMMRadiusSquare[MMRSSize];
+			for(int z=0; z&lt;MMRSSize; z++)
+			{
+				MMRS[x][z].distance = float3(x,0,z).distance2D(float3(MMExtractorRadiusI,0,MMExtractorRadiusI));
+				if( MMRS[x][z].distance &lt;= MMExtractorRadius )
+					MMRS[x][z].inRange = true;
+				else
+					MMRS[x][z].inRange = false;
+			}
+		}
+
+		if( cb-&gt;GetExtractorRadius() &lt;= 70.0 )
+		{
+			int inRange = 0;
+			for(int z=0; z&lt;MMRSSize; z++)
+				for(int x=0; x&lt;MMRSSize; x++)
+					if( MMRS[x][z].inRange )
+						inRange++;
+			const float minimalMetalSquare = RAI_MinimalMetalSite/(inRange*cb-&gt;GetMaxMetal());
+			*l&lt;&lt;&quot;\n   Metal-Squares per Site: &quot;&lt;&lt;inRange;
+			*l&lt;&lt;&quot;\n   Minimal Metal-Square Value: &quot;&lt;&lt;minimalMetalSquare;
+
+			sector = new MetalMapSector[TM-&gt;sectorXSize*TM-&gt;sectorZSize];
+			const unsigned char *standardMetalMap = cb-&gt;GetMetalMap();
+			const int convertStoMM = TM-&gt;convertStoP/16; // * for conversion, / for reverse conversion
+			const int metalMapXSize = TM-&gt;sectorXSize*convertStoMM;
+			int uselessSectors = 0;
+			int metalSectors = 0;
+			float totalMetal = 0.0;
+//			*l&lt;&lt;&quot;\n   Sector to Metal-Map Conversion: &quot;&lt;&lt;convertStoMM;
+			for(int z=0; z &lt; TM-&gt;sectorZSize; z++)
+				for(int x=0; x &lt; TM-&gt;sectorXSize; x++)
+				{
+//if( x == 0 ) *l&lt;&lt;&quot;\n &quot;;
+					float sectorMetal = 0.0;
+					int i=(z*TM-&gt;sectorXSize)+x;
+					sector[i].S = &amp;TM-&gt;sector[i];
+					if( sector[i].S-&gt;maxElevation &lt; 0 &amp;&amp; TM-&gt;waterIsHarmful )
+						uselessSectors++;
+					else
+					{
+						int iMap = ((z*convertStoMM)*metalMapXSize)+x*convertStoMM;
+//*l&lt;&lt;&quot;\t&quot;&lt;&lt;standardMetalMap[iMap];
+						for(int zM=0; zM&lt;convertStoMM; zM++)
+							for(int xM=0,iM=iMap+zM*metalMapXSize+xM; xM&lt;convertStoMM; xM++,iM=iMap+zM*metalMapXSize+xM )
+								if( (float)standardMetalMap[iM] &gt; 2.0*minimalMetalSquare )
+								{
+									sector[i].percentMetal++;
+									sectorMetal += standardMetalMap[iM];
+								}
+						sector[i].percentMetal *= 100.0/(convertStoMM*convertStoMM);
+						if( sector[i].percentMetal &gt;= 75.0 )//&amp;&amp; sector[i].totalMetal &gt; 2*RAI_MinimalMetalSite )
+						{
+							sector[i].isMetalSector = true;
+							metalSectors++;
+							totalMetal += sectorMetal;
+						}
+//*l&lt;&lt;&quot;\t(&quot;&lt;&lt;sector[i].totalMetal&lt;&lt;&quot;/&quot;&lt;&lt;sector[i].percentMetal&lt;&lt;&quot;%)&quot;;
+					}
+				}
+			*l&lt;&lt;&quot;\n   Metal-Sector Percent: &quot;&lt;&lt;(100.0*metalSectors)/(TM-&gt;sectorXSize*TM-&gt;sectorZSize-uselessSectors)&lt;&lt;&quot;%&quot;;
+			if( (100.0*metalSectors)/(TM-&gt;sectorXSize*TM-&gt;sectorZSize-uselessSectors) &gt; 40.0 ) // 40% of the sectors are metal
+			{
+				isMetalMap = true;
+				*l&lt;&lt;&quot; (Metal-Map Detected)&quot;;
+				averageMetalSite = (inRange*cb-&gt;GetMaxMetal()*totalMetal)/(metalSectors*convertStoMM*convertStoMM);
+			}
+			else
+			{
+				isMetalMap = false;
+				delete [] sector;
+				sector = 0;
+			}
+		}
+		else
+			isMetalMap = false;
+
+		if( !isMetalMap )
+		{
+			*l&lt;&lt;&quot;\n  Finding Metal-Sites ...&quot;;
+			averageMetalSite = 0.0;
+			MMZSize = cb-&gt;GetMapHeight()/2;
+			MMXSize = cb-&gt;GetMapWidth()/2;
+			*l&lt;&lt;&quot;\n   Metal-Map Size: &quot;&lt;&lt;MMXSize*MMZSize&lt;&lt;&quot; (x&quot;&lt;&lt;MMXSize&lt;&lt;&quot;,z&quot;&lt;&lt;MMZSize&lt;&lt;&quot;)&quot;;
+			const float MBtoBB = 2.0; // Metal-Block to Build-Block, * for Conversion, / for the reverse
+			const float MMMinExtractorRadius = sqrt(pow(float(udList[0]-&gt;xsize)/MBtoBB,2)+pow(float(udList[0]-&gt;ysize)/MBtoBB,2)); // If less then this value then sites could overlap
+			*l&lt;&lt;&quot;\n   Minimal Metal-Map Extractor Radius: &quot;&lt;&lt;MMMinExtractorRadius;
+
+			// sorts the list so that the most unique size extractors are first
+			int uniqueExtractors = 0;
+			for( int iudU=0; iudU&lt;=uniqueExtractors; iudU++ )
+			{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;iudU;
+				int uniqueExtractorIndex=-1;
+				for( int iud=iudU; iud&lt;udSize &amp;&amp; uniqueExtractorIndex==-1; iud++ )
+					if( udList[iud]-&gt;extractsMetal &gt; 0 )
+					{
+						uniqueExtractorIndex = iud;
+						for( int iud2=0; iud2&lt;uniqueExtractors; iud2++ )
+							if( udList[iud]-&gt;xsize == udList[iud2]-&gt;xsize &amp;&amp; udList[iud]-&gt;ysize == udList[iud2]-&gt;ysize &amp;&amp;
+								udList[iud]-&gt;minWaterDepth == udList[iud2]-&gt;minWaterDepth &amp;&amp; udList[iud]-&gt;maxWaterDepth == udList[iud2]-&gt;maxWaterDepth )
+							{
+								uniqueExtractorIndex = -1;
+								break;
+							}
+					}
+				if( uniqueExtractorIndex &gt;=0 )
+				{
+//*l&lt;&lt;&quot; +&quot;&lt;&lt;uniqueExtractorIndex;
+					const UnitDef* ud = udList[uniqueExtractors];
+					udList[uniqueExtractors] = udList[uniqueExtractorIndex];
+					udList[uniqueExtractorIndex] = ud;
+					uniqueExtractors++;
+
+					// make udList[0] = the smallest extractor
+					for( int i=uniqueExtractors-1; i&gt;0 &amp;&amp; udList[i]-&gt;xsize*udList[i]-&gt;ysize &lt; udList[i-1]-&gt;xsize*udList[i-1]-&gt;ysize; i-- )
+					{
+						const UnitDef* ud = udList[i-1];
+						udList[i-1] = udList[i];
+						udList[i] = ud;
+					}
+				}
+			}
+			*l&lt;&lt;&quot;\n   Minimal Unit-Definition Size: (x&quot;&lt;&lt;udList[0]-&gt;xsize&lt;&lt;&quot;,z&quot;&lt;&lt;udList[0]-&gt;ysize&lt;&lt;&quot;)&quot;;
+			*l&lt;&lt;&quot;\n   Unique Extractor Unit-Definitions: &quot;&lt;&lt;uniqueExtractors;
+
+			// Calculate the offsets
+			edgeOffset = new int[MMRSSize];
+			for( int x=0; x&lt;MMRSSize; x++ )
+				for(int z=0; z&lt;MMRSSize; z++)
+					if( MMRS[x][z].inRange )
+					{
+						edgeOffset[x] = MMExtractorRadiusI-z;
+						break;
+					}
+
+			// Initailizing MMS(.metal .assessing .x .z)
+			int SMindex;	// temp variable
+			float percentMetal = 0.0;
+			const unsigned char *StandardMetalMap = cb-&gt;GetMetalMap();
+			MMS = new sMetalMapSquare*[MMXSize];
+			for( int x=0; x&lt;MMXSize; x++ )
+			{
+//*l&lt;&lt;&quot;\n&quot;;
+				MMS[x] = new sMetalMapSquare[MMZSize];
+				for(int z=0; z&lt;MMZSize; z++)
+				{
+					SMindex = z*MMXSize + x;
+					if( (int)StandardMetalMap[SMindex] &gt; 0 )
+					{
+						MMS[x][z].metal = (float)StandardMetalMap[SMindex]*cb-&gt;GetMaxMetal();
+						percentMetal++;
+					}
+					else
+						MMS[x][z].metal = 0.0;
+//*l&lt;&lt;MMS[x][z].metal&lt;&lt;&quot;\t&quot;;
+					MMS[x][z].x = x;
+					MMS[x][z].z = z;
+					MMS[x][z].assessing = true;
+					MMS[x][z].inaccuracy = -1.0;
+				}
+			}
+			percentMetal *= 100.0/(MMXSize*MMZSize);
+			*l&lt;&lt;&quot;\n   Percent Metal: &quot;&lt;&lt;percentMetal&lt;&lt;&quot;%&quot;;
+			bool valueAccuracy = false;
+			if( percentMetal &lt; 1.0 )
+			{
+				valueAccuracy = true;
+				*l&lt;&lt;&quot; (metal-site accuracy will be considered important)&quot;;
+			}
+
+//			double MSTimerTemp = clock();
+			// Updates MMS(.totalMetal .assessing)
+			FindMMSTotalMetal(0,MMXSize-1,0,MMZSize-1);
+//			*l&lt;&lt;&quot;\n    Metal-Site Init FindMMSTotalMetal Loading:\t&quot;&lt;&lt;(clock()-MSTimerTemp)/(double)CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+
+			// Updates MMS(.assessing), checks for area occupied by Geo-Sites
+			if( UDGeoResource )
+			{
+				// Find the smallest Geo UnitDef
+				const UnitDef *ud = 0;
+				for( int iud=0; iud&lt;udSize; iud++ )
+					if( udList[iud]-&gt;needGeo )
+						if( ud == 0 || udList[iud]-&gt;xsize*udList[iud]-&gt;ysize &lt; ud-&gt;xsize*ud-&gt;ysize )
+							ud = udList[iud];
+
+				const int MMtoMP = 16; // Metal-Map to Map-Position, * for conversion, / for the reverse
+				int xMin,xMax,zMin,zMax; // temp variables
+				for( int iR=0; iR&lt;RSize[1]; iR++ )
+				{
+					xMin = int(R[1][iR]-&gt;position.x)/MMtoMP;
+					zMin = int(R[1][iR]-&gt;position.z)/MMtoMP;
+					SetLimitBoundary(xMin,xMax,ud-&gt;xsize/MBtoBB-1,zMin,zMax,ud-&gt;ysize/MBtoBB-1);
+					for(int z=zMin; z&lt;=zMax; z++)
+						for(int x=xMin; x&lt;=xMax; x++)
+							if( MMS[x][z].assessing )
+								MMS[x][z].assessing = false;
+				}
+			}
+
+			// Updates MMS(.assessing), checks the elevation and water type
+			const float *StandardHeightMap = cb-&gt;GetHeightMap();
+			const int HeightMapXSize = cb-&gt;GetMapWidth();
+			const int MMapToHMap = HeightMapXSize/MMXSize;
+			MMSAssessingSize = 0;
+			float3 position;// temp variable
+			for( int x=0; x&lt;MMXSize; x++ )
+				for(int z=0; z&lt;MMZSize; z++)
+					if( MMS[x][z].assessing )
+						if( TM-&gt;waterIsHarmful &amp;&amp; StandardHeightMap[(z*MMapToHMap+MMapToHMap/2)*HeightMapXSize+(x*MMapToHMap+MMapToHMap/2)] &lt; 0 )
+							MMS[x][z].assessing = false;
+						else
+							MMSAssessingSize++;
+
+			// try cutting it down a little more, if needed
+			if( MMSAssessingSize &gt; 250000 )
+			{
+				*l&lt;&lt;&quot;\n   Assessing &quot;&lt;&lt;MMSAssessingSize&lt;&lt;&quot; possible metal-sites.&quot;;
+				*l&lt;&lt;&quot;\n    Reducing Assessment ... &quot;;
+				for( int x=0; x&lt;MMXSize; x++ )
+					for(int z=0; z&lt;MMZSize; z++)
+						if( MMS[x][z].assessing &amp;&amp; MMS[x][z].totalMetal &lt; 1.75*RAI_MinimalMetalSite )
+							MMS[x][z].assessing = false;
+			}
+
+//			MSTimerTemp = clock();
+			// Updates MMS(.assessing), checks if the positions can be built at
+			MMSAssessingSize = 0;
+			MMSAssessing = new sMetalMapSquare*[MMXSize*MMZSize];
+			for( int x=0; x&lt;MMXSize; x++ )
+				for(int z=0; z&lt;MMZSize; z++)
+					if( MMS[x][z].assessing )
+					{	// Long Calculation: (cause: cb-&gt;CanBuildAt - probably can't be improved)
+						MMS[x][z].assessing = false;
+						position = float3(x*16.0+8.0, 0.0, z*16.0+8.0);
+						for( int iud=0; iud&lt;uniqueExtractors; iud++ )
+							if( udList[iud]-&gt;extractsMetal &gt; 0 &amp;&amp; cb-&gt;CanBuildAt(udList[iud],position) )
+							{
+								MMS[x][z].assessing = true;
+								MMSAssessing[MMSAssessingSize++] = &amp;MMS[x][z];
+								break;
+							}
+					}
+//			*l&lt;&lt;&quot;\n    Metal-Site Init CanBuildAt Loading:\t&quot;&lt;&lt;(clock()-MSTimerTemp)/(double)CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+			*l&lt;&lt;&quot;\n   Assessing &quot;&lt;&lt;MMSAssessingSize&lt;&lt;&quot; possible metal-sites.&quot;;
+//			double MSTimer1 = 0;
+//			double MSTimer2 = 0;
+//			double MSTimer3 = 0;
+			float searchDis = cb-&gt;GetExtractorRadius()/2.0;
+			if( searchDis &lt; 16.0 )
+				searchDis = 16.0; // Needs to be at least this high to work with ClosestBuildSite
+			sMetalMapSquare *mms;	// temp variable
+			int xMin,xMax,zMin,zMax,xOffset,zOffset; // temp variables
+			while( MMSAssessingSize &gt; 0 &amp;&amp; RSize[0] &lt; RAI_MaxMetalSites )
+			{
+//*l&lt;&lt;&quot;\nMMSRemaining.size()=&quot;&lt;&lt;MMSRemaining.size();
+//				MSTimerTemp = clock();
+				// Setting mms as the best metal-site available
+				// Sorted by high totalMetal and then by low inaccuracy
+				mms = MMSAssessing[0]; // [0] always has assessing = true
+				if( valueAccuracy )
+				{
+					float bestMetal = 0;
+					for( int i=0; i&lt;MMSAssessingSize; i++ )
+						if( !MMSAssessing[i]-&gt;assessing )
+							MMSAssessing[i--] = MMSAssessing[--MMSAssessingSize];
+						else if( MMSAssessing[i]-&gt;totalMetal &lt; 0.5*bestMetal )
+						{}	// nothing
+						else
+						{	// slow calculations
+							if( MMSAssessing[i]-&gt;totalMetal &gt; bestMetal )
+							{
+								bestMetal = MMSAssessing[i]-&gt;totalMetal;
+								if( mms-&gt;totalMetal &lt; 0.51*bestMetal )
+									mms = MMSAssessing[i];
+							}
+							if( MMSAssessing[i]-&gt;inaccuracy &lt;= 0.0 )
+								FindMMSInaccuracy(MMSAssessing[i]-&gt;x,MMSAssessing[i]-&gt;z);
+							if( mms-&gt;inaccuracy &lt;= 0.0 )
+								FindMMSInaccuracy(mms-&gt;x,mms-&gt;z);
+//							*l&lt;&lt;&quot;\n m=&quot;&lt;&lt;MMSAssessing[i]-&gt;totalMetal&lt;&lt;&quot; ia=&quot;&lt;&lt;MMSAssessing[i]-&gt;inaccuracy&lt;&lt;&quot; r=&quot;&lt;&lt;MMSAssessing[i]-&gt;totalMetal*(MMSAssessing[i]-&gt;totalMetal/MMSAssessing[i]-&gt;inaccuracy);
+							if( MMSAssessing[i]-&gt;totalMetal*(MMSAssessing[i]-&gt;totalMetal/MMSAssessing[i]-&gt;inaccuracy) &gt; mms-&gt;totalMetal*(mms-&gt;totalMetal/mms-&gt;inaccuracy) )
+								mms = MMSAssessing[i];
+						}
+				}
+				else
+				{
+					for( int i=0; i&lt;MMSAssessingSize; i++ )
+						if( !MMSAssessing[i]-&gt;assessing )
+							MMSAssessing[i--] = MMSAssessing[--MMSAssessingSize];
+						else if( MMSAssessing[i]-&gt;totalMetal &gt; 1.001*mms-&gt;totalMetal )
+							mms = MMSAssessing[i];
+						else if( MMSAssessing[i]-&gt;totalMetal &lt; 0.999*mms-&gt;totalMetal )
+						{}	// nothing
+						else
+						{	// 0.999-1.001: fixes float rounding errors, cb-&gt;GetMaxMetal() was not a whole number
+							// inaccuracy can take a long time to calculate so it won't be until it's needed
+							if( MMSAssessing[i]-&gt;inaccuracy &lt;= 0.0 )
+								FindMMSInaccuracy(MMSAssessing[i]-&gt;x,MMSAssessing[i]-&gt;z);
+							if( mms-&gt;inaccuracy &lt;= 0.0 )
+								FindMMSInaccuracy(mms-&gt;x,mms-&gt;z);
+							if( MMSAssessing[i]-&gt;inaccuracy &lt; mms-&gt;inaccuracy )//0.999*mms-&gt;inaccuracy )
+								mms = MMSAssessing[i];
+						}
+				}
+				if( mms-&gt;totalMetal &lt; RAI_MinimalMetalSite )
+					break;
+//				MSTimer1 += clock()-MSTimerTemp;
+//				MSTimerTemp = clock();
+
+				// Create the metal-site
+				position = float3(mms-&gt;x*16.0+8.0, 0.0, mms-&gt;z*16.0+8.0);
+				ResourceSite *RS = new ResourceSite(position);
+				RS-&gt;position.y = StandardHeightMap[(mms-&gt;z*MMapToHMap+MMapToHMap/2)*HeightMapXSize+(mms-&gt;x*MMapToHMap+MMapToHMap/2)];
+				RS-&gt;amount = mms-&gt;totalMetal;
+				averageMetalSite += RS-&gt;amount;
+				for( int iud=0; iud&lt;udSize; iud++ )
+					if( udList[iud]-&gt;extractsMetal &gt; 0.0 )
+					{
+						position = cb-&gt;ClosestBuildSite(udList[iud],RS-&gt;position,searchDis,0);
+						if( cb-&gt;CanBuildAt(udList[iud],position) &amp;&amp; (!TM-&gt;waterIsHarmful || position.y &gt;= 0) )
+							RS-&gt;options.insert(udList[iud]-&gt;id);
+					}
+				R[0][RSize[0]++] = RS;
+//				MSTimer2 += clock()-MSTimerTemp;
+//				*l&lt;&lt;&quot;\n mms-&gt;(x&quot;&lt;&lt;mms-&gt;x&lt;&lt;&quot;,z&quot;&lt;&lt;mms-&gt;z&lt;&lt;&quot;)&quot;;
+
+				// The Extractor Radius is small enough that Sites will overlap, remove the nearby indexes being assessed
+//				if( MMExtractorRadius &lt; MMMinExtractorRadius )
+//				{
+				SetLimitBoundary((xMin=mms-&gt;x),xMax,udList[0]-&gt;xsize/MBtoBB -1,(zMin=mms-&gt;z),zMax,udList[0]-&gt;ysize/MBtoBB -1);
+				for(int z=zMin; z&lt;=zMax; z++)
+					for(int x=xMin; x&lt;=xMax; x++)
+						if( MMS[x][z].assessing )
+							MMS[x][z].assessing = false;
+//				}
+
+				// Update nearby Metal-Map positions
+				SetLimitBoundary((xMin=mms-&gt;x),xMax,xOffset,(zMin=mms-&gt;z),zMax,zOffset,MMExtractorRadiusI);
+				for(int z=zMin,zMMRS=zOffset; z&lt;=zMax; z++,zMMRS++)
+					for(int x=xMin,xMMRS=xOffset; x&lt;=xMax; x++,xMMRS++)
+						if( MMRS[xMMRS][zMMRS].inRange )
+						{
+//							*l&lt;&lt;&quot;\n  (x&quot;&lt;&lt;x&lt;&lt;&quot;,z&quot;&lt;&lt;z&lt;&lt;&quot;) i=&quot;&lt;&lt;index&lt;&lt;&quot; MMSRsize=&quot;&lt;&lt;MMSRemaining.size();
+							MMS[x][z].metal = 0.0;
+						}
+
+//				MSTimerTemp = clock();
+				// Recalculate the affected MetalMapSquares
+				SetLimitBoundary((xMin=mms-&gt;x),xMax,xOffset,(zMin=mms-&gt;z),zMax,zOffset,2*MMExtractorRadiusI);
+				FindMMSTotalMetal(xMin,xMax,zMin,zMax);
+//				MSTimer3 += clock()-MSTimerTemp;
+
+				// Ensures that the first element is being assessed
+				while( MMSAssessingSize &gt; 0 &amp;&amp; !MMSAssessing[0]-&gt;assessing )
+					MMSAssessing[0] = MMSAssessing[--MMSAssessingSize];
+			}
+//			*l&lt;&lt;&quot;\n    Metal-Site Search Loading:            &quot;&lt;&lt;MSTimer1/CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+//			*l&lt;&lt;&quot;\n    Metal-Site CanBuildAt Loading:        &quot;&lt;&lt;MSTimer2/CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+//			*l&lt;&lt;&quot;\n    Metal-Site FindMMSTotalMetal Loading: &quot;&lt;&lt;MSTimer3/CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+			delete [] edgeOffset;
+			delete [] MMSAssessing;
+			for( int x=0; x&lt;MMXSize; x++ )
+				delete [] MMS[x];
+			delete [] MMS;
+			if( RSize[0] &gt; 0 )
+			{
+				averageMetalSite /= RSize[0];
+				*l&lt;&lt;&quot;\n    Minimal Metal-Site Value: &quot;&lt;&lt;RAI_MinimalMetalSite;
+			}
+		}
+		for( int x=0; x&lt;MMRSSize; x++ )
+			delete [] MMRS[x];
+		delete [] MMRS;
+		*l&lt;&lt;&quot;\n    Average Metal-Site Value: &quot;&lt;&lt;averageMetalSite;
+		*l&lt;&lt;&quot;\n    Metal-Sites Found: &quot;&lt;&lt;RSize[0];
+	}
+	else
+		*l&lt;&lt;&quot;\n    Metal-Sites Loaded: &quot;&lt;&lt;RSize[0];
+	delete [] udList;
+/*
+	// debugging
+	for( int iT=0; iT&lt;2; iT++ )
+		for( int iR=0; iR&lt;RSize[iT]; iR++ )
+		{
+			*l&lt;&lt;&quot;\n    R[&quot;&lt;&lt;iT&lt;&lt;&quot;][&quot;&lt;&lt;iR&lt;&lt;&quot;] \tamount: &quot;&lt;&lt;R[iT][iR]-&gt;amount&lt;&lt;&quot; \tlocation(x&quot;&lt;&lt;R[iT][iR]-&gt;position.x&lt;&lt;&quot;,z&quot;&lt;&lt;R[iT][iR]-&gt;position.z&lt;&lt;&quot;):&quot;;
+			*l&lt;&lt;&quot;\t B(&quot;&lt;&lt;R[iT][iR]-&gt;options.size()&lt;&lt;&quot;):&quot;;
+			for( set&lt;int&gt;::iterator RS=R[iT][iR]-&gt;options.begin(); RS!=R[iT][iR]-&gt;options.end(); RS++ )
+				*l&lt;&lt;&quot; &quot;&lt;&lt;*RS;
+		}
+*/
+}
+
+GlobalResourceMap::~GlobalResourceMap()
+{
+	if( saveResourceFile )
+	{
+		FILE *resourceFile = fopen(resourceFileName.c_str(),&quot;wb&quot;);
+		int size;
+		fwrite(&amp;(size=saveUD.size()), sizeof(int), 1, resourceFile);
+		for(vector&lt;int&gt;::iterator i=saveUD.begin(); i!=saveUD.end(); i++)
+			fwrite(&amp;*i, sizeof(int), 1, resourceFile);
+		fwrite(&amp;(size=saveF.size()), sizeof(int), 1, resourceFile);
+		for(vector&lt;int&gt;::iterator i=saveF.begin(); i!=saveF.end(); i++)
+			fwrite(&amp;*i, sizeof(int), 1, resourceFile);
+		for( int iT=0; iT&lt;2; iT++ )
+		{
+			fwrite(&amp;RSize[iT], sizeof(int), 1, resourceFile);
+			for( int iR=0; iR&lt;RSize[iT]; iR++ )
+			{
+				fwrite(&amp;R[iT][iR]-&gt;featureID, sizeof(int), 1, resourceFile);
+				fwrite(&amp;R[iT][iR]-&gt;position, sizeof(float3), 1, resourceFile);
+				fwrite(&amp;R[iT][iR]-&gt;amount, sizeof(float), 1, resourceFile);
+				fwrite(&amp;(size=R[iT][iR]-&gt;options.size()), sizeof(int), 1, resourceFile);
+				for( set&lt;int&gt;::iterator i=R[iT][iR]-&gt;options.begin(); i!=R[iT][iR]-&gt;options.end(); i++ )
+					fwrite(&amp;*i, sizeof(int), 1, resourceFile);
+			}
+		}
+		for( int iT=0; iT&lt;2; iT++ )
+			for( int iR=0; iR&lt;RSize[iT]; iR++ )
+			{
+				fwrite(&amp;(size=R[iT][iR]-&gt;siteDistance.size()), sizeof(int), 1, resourceFile);
+				for( map&lt;ResourceSite*,ResourceSiteDistance&gt;::iterator iRS=R[iT][iR]-&gt;siteDistance.begin(); iRS!=R[iT][iR]-&gt;siteDistance.end(); iRS++ )
+				{
+					fwrite(&amp;iRS-&gt;first-&gt;type, sizeof(int), 1, resourceFile);
+					ResourceSiteDistance* RSD = &amp;iRS-&gt;second;
+					for(int i=0; i&lt;RSize[iRS-&gt;first-&gt;type]; i++)
+						if( R[iRS-&gt;first-&gt;type][i] == iRS-&gt;first )
+						{
+							fwrite(&amp;i, sizeof(int), 1, resourceFile);
+							break;
+						}
+					fwrite(&amp;RSD-&gt;minDistance, sizeof(float), 1, resourceFile);
+					if( RSD-&gt;bestPathType == -1 &amp;&amp; RSD-&gt;bestDistance != 0 )
+						RSD-&gt;bestPathType = -2;
+					fwrite(&amp;RSD-&gt;bestPathType, sizeof(int), 1, resourceFile);
+					fwrite(&amp;(size=RSD-&gt;distance.size()), sizeof(int), 1, resourceFile);
+					for( map&lt;int,float&gt;::iterator i=RSD-&gt;distance.begin(); i!=RSD-&gt;distance.end(); i++ )
+					{
+						fwrite(&amp;i-&gt;first, sizeof(int), 1, resourceFile);
+						fwrite(&amp;i-&gt;second, sizeof(float), 1, resourceFile);
+					}
+					fwrite(&amp;(size=RSD-&gt;pathDebug.size()), sizeof(int), 1, resourceFile);
+					for( vector&lt;float3&gt;::iterator i=RSD-&gt;pathDebug.begin(); i!=RSD-&gt;pathDebug.end(); i++ )
+						fwrite(&amp;*i, sizeof(float3), 1, resourceFile);
+				}
+			}
+		fwrite(&amp;averageMetalSite, sizeof(float), 1, resourceFile);
+		fwrite(&amp;isMetalMap, sizeof(bool), 1, resourceFile);
+		if( isMetalMap )
+			for( int iS=0; iS&lt;saveSectorSize; iS++ )
+				fwrite(&amp;sector[iS].isMetalSector, sizeof(bool), 1, resourceFile);
+		fclose(resourceFile);
+	}
+
+	if( sector != 0 )
+		delete [] sector;
+	for( int iT=0; iT&lt;2; iT++ )
+	{
+		for(int iR=0; iR&lt;RSize[iT]; iR++)
+			delete R[iT][iR];
+		delete [] R[iT];
+	}
+}
+
+float3 GlobalResourceMap::GetMetalMapPosition(const float3&amp; position)
+{	// UNFINISHED
+	return position;
+}
+
+void GlobalResourceMap::SetLimitBoundary(int &amp;xMin, int &amp;xMax, int &amp;xMMRS, int &amp;zMin, int &amp;zMax, int &amp;zMMRS, const int &amp;increment)
+{
+	xMax = xMin + increment;
+	if( xMax &gt; MMXSize-1 )
+		xMax = MMXSize-1;
+	xMin -= increment;
+	if( xMin &lt; 0 )
+	{
+		xMMRS = -xMin;
+		xMin = 0;
+	}
+	else
+		xMMRS = 0;
+
+	zMax = zMin + increment;
+	if( zMax &gt; MMZSize-1 )
+		zMax = MMZSize-1;
+	zMin -= increment;
+	if( zMin &lt; 0 )
+	{
+		zMMRS = -zMin;
+		zMin = 0;
+	}
+	else
+		zMMRS = 0;
+}
+
+void GlobalResourceMap::SetLimitBoundary(int &amp;xMin, int &amp;xMax, const int &amp;xIncrement, int &amp;zMin, int &amp;zMax, const int &amp;zIncrement)
+{
+	xMax = xMin + xIncrement;
+	if( xMax &gt; MMXSize-1 )
+		xMax = MMXSize-1;
+	xMin -= xIncrement;
+	if( xMin &lt; 0 )
+		xMin = 0;
+
+	zMax = zMin + zIncrement;
+	if( zMax &gt; MMZSize-1 )
+		zMax = MMZSize-1;
+	zMin -= zIncrement;
+	if( zMin &lt; 0 )
+		zMin = 0;
+}
+
+void GlobalResourceMap::FindMMSTotalMetal(const int &amp;xMMin, const int &amp;xMMax, const int &amp;zMMin, const int &amp;zMMax)
+{	// Updating MMS (.totalMetal .assessing)
+	int xMin,xMax,zMin,zMax,xOffset,zOffset,xMMRS,zMMRS,x,z; // temp variables
+	for(int xM=xMMin; xM&lt;=xMMax; xM++)
+		for(int zM=zMMin; zM&lt;=zMMax; zM++)
+			if( MMS[xM][zM].assessing )
+			{
+				MMS[xM][zM].totalMetal = 0.0;
+				MMS[xM][zM].inaccuracy = -1.0; // reset
+				SetLimitBoundary((xMin=xM),xMax,xOffset,(zMin=zM),zMax,zOffset,MMExtractorRadiusI);
+				if( xM &gt; xMMin &amp;&amp; MMS[xM-1][zM].assessing )
+				{	// Shifting right from a previous calculation
+					MMS[xM][zM].totalMetal = MMS[xM-1][zM].totalMetal;
+					for(z=zMin; z&lt;=zMax; z++,zOffset++)
+					{
+						xMax = xM+edgeOffset[zOffset];
+						if( xMax &lt; MMXSize )
+							MMS[xM][zM].totalMetal += MMS[xMax][z].metal;
+						xMin = xM-edgeOffset[zOffset]-1;
+						if( xMin &gt;= 0 )
+							MMS[xM][zM].totalMetal -= MMS[xMin][z].metal;
+					}
+				}
+				else if( zM &gt; zMMin &amp;&amp; MMS[xM][zM-1].assessing )
+				{	// Shifting down from a previous calculation
+					MMS[xM][zM].totalMetal = MMS[xM][zM-1].totalMetal;
+					for(x=xMin; x&lt;=xMax; x++,xOffset++)
+					{
+						zMax = zM+edgeOffset[xOffset];
+						if( zMax &lt; MMZSize )
+							MMS[xM][zM].totalMetal += MMS[x][zMax].metal;
+						zMin = zM-edgeOffset[xOffset]-1;
+						if( zMin &gt;= 0 )
+							MMS[xM][zM].totalMetal -= MMS[x][zMin].metal;
+					}
+				}
+				else
+				{	// Default Calculation, depending on the extractor radius this can be 30x slower
+					for(z=zMin,zMMRS=zOffset; z&lt;=zMax; z++,zMMRS++)
+						for(x=xMin,xMMRS=xOffset; x&lt;=xMax; x++,xMMRS++)
+							if( MMRS[xMMRS][zMMRS].inRange )
+								MMS[xM][zM].totalMetal += MMS[x][z].metal;
+				}
+//*l&lt;&lt;&quot; MMS[xM][zM].totalMetal=&quot;&lt;&lt;MMS[xM][zM].totalMetal;
+			}
+	// .assessing is checked afterwards because assessing=true can help with it's calculations
+	for(int xM=xMMin; xM&lt;=xMMax; xM++)
+		for(int zM=zMMin; zM&lt;=zMMax; zM++)
+			if( MMS[xM][zM].assessing &amp;&amp; MMS[xM][zM].totalMetal &lt; RAI_MinimalMetalSite )
+				MMS[xM][zM].assessing = false;
+}
+
+void GlobalResourceMap::FindMMSInaccuracy(const int &amp;xM, const int &amp;zM)
+{
+	// Very Long Calculation: (cause: a map with a large extractor radius - needs some improvement in the future)
+	int xMin,xMax,zMin,zMax,xOffset,zOffset; // temp variables
+	SetLimitBoundary((xMin=xM),xMax,xOffset,(zMin=zM),zMax,zOffset,MMExtractorRadiusI);
+	for(int z=zMin,zMMRS=zOffset; z&lt;=zMax; z++,zMMRS++)
+		for(int x=xMin,xMMRS=xOffset; x&lt;=xMax; x++,xMMRS++)
+			if( MMRS[xMMRS][zMMRS].inRange )
+				MMS[xM][zM].inaccuracy += MMS[x][z].metal * (1.0+MMRS[xMMRS][zMMRS].distance/3.0);
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/GResourceMap.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/GResourceMap.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/GResourceMap.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,118 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAIG_RESOURCE_MAP_H
+#define RAIG_RESOURCE_MAP_H
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+#include &quot;GTerrainMap.h&quot;
+#include &lt;set&gt;
+using std::map;
+using std::set;
+using std::vector;
+
+struct ResourceSiteDistance
+{
+	ResourceSiteDistance(float minimalDistance)
+	{
+		minDistance = minimalDistance;
+		bestDistance = 0;
+		bestPathType = -1;
+	};
+	float minDistance;
+	int bestPathType; // set only once, the first time a pathType distance is found successfully
+	float *bestDistance; // set only once (= distance-&gt;second), the first time a pathType distance is found
+	map&lt;int,float&gt; distance; // key = pathType
+	vector&lt;float3&gt; pathDebug; // Only used for temporary storage &amp; debugging
+};
+
+struct ResourceSite
+{
+	ResourceSite(float3&amp; rsPosition, int rsFeatureID=-1, const FeatureDef* fd=0);
+	float GetResourceDistance(ResourceSite* RS, const int&amp; pathType);
+
+	int type;		// 0=metal/Non-Feature, 1=geo/Feature
+	float amount;	// For metal-sites (this * ud-&gt;extractsMetal = the predicted income)
+	int featureID;	// Valid if it's a Geo-Site, otherwise -1
+	const FeatureDef *featureD;	// Valid if 'featureID' is set
+	float3 position;
+	set&lt;int&gt; options; // key = ud-&gt;id, a list of posible units to be built at the site
+	map&lt;ResourceSite*,ResourceSiteDistance&gt; siteDistance;
+};
+
+class GlobalResourceMap
+{
+public:
+	GlobalResourceMap(IAICallback* cb, cLogFile* logfile, GlobalTerrainMap* TM);
+	~GlobalResourceMap();
+	float3 GetMetalMapPosition(const float3&amp; position);
+
+	ResourceSite** R[2];	// a list of each resource type
+	int RSize[2];			// # of each resource type
+	float averageMetalSite; // (this * ud-&gt;extractsMetal = the predicted income)
+	bool isMetalMap;		// if true then RSize[0] will = 0, use UNFINISHED
+
+private:
+	struct MetalMapSector
+	{
+		MetalMapSector()
+		{
+			isMetalSector = false;
+			closestMetalSector = 0;
+			percentMetal = 0.0;
+//			totalMetal = 0.0;
+		};
+
+		bool isMetalSector;	// There is enough metal in and around the sector that metal extractors can be built randomly
+		MetalMapSector* closestMetalSector; // not initialized, the closest sector with isMetalSector
+		TerrainMapSector* S;
+
+		// only used during initialization
+		float percentMetal; // 0-100
+//		float totalMetal;
+	};
+	MetalMapSector *sector;
+
+	// only used during initialization
+	struct sMetalMapSquare
+	{
+		bool assessing;		// 
+		float metal;		// unused metal at this square
+		float totalMetal;	// (this * ud-&gt;extractsMetal = the predicted income)
+		float inaccuracy;	// a high value means the totalMetal is not near the center of the x,z position
+		int x;
+		int z;
+	};
+	struct sMMRadiusSquare
+	{
+		bool inRange;		// true if it is within the extractor radius, a little faster for calculations
+		float distance;		// the distance between this square and the center
+	};
+	void SetLimitBoundary(int &amp;xMin, int &amp;xMax, int &amp;xMMRS, int &amp;zMin, int &amp;zMax, int &amp;zMMRS, const int &amp;increment);
+	void SetLimitBoundary(int &amp;xMin, int &amp;xMax, const int &amp;xIncrement, int &amp;zMin, int &amp;zMax, const int &amp;zIncrement);
+	void FindMMSTotalMetal(const int &amp;xMMin, const int &amp;xMMax, const int &amp;zMMin, const int &amp;zMMax);
+	void FindMMSInaccuracy(const int &amp;xM, const int &amp;zM);
+
+	int *edgeOffset;		// Same dimension size as MMRS
+	sMMRadiusSquare **MMRS;	// 2 Dimensionial Array [ExtractorDiameter][ExtractorDiameter]
+	sMetalMapSquare **MMS;	// 2 Dimensionial Array [GetMapWidth()/2][GetMapHeight()/2]
+	sMetalMapSquare **MMSAssessing;	// 1 Dimensionial Array of pointers
+	int MMSAssessingSize;
+	int MMZSize;
+	int MMXSize;
+	int MMExtractorRadiusI;
+
+	// needed to save the file
+	string resourceFileName;
+	bool saveResourceFile;
+	vector&lt;int&gt; saveUD;
+	vector&lt;int&gt; saveF;
+	int saveSectorSize;
+
+//	cLogFile *l; // Debugging only
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/GResourceMap.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,640 @@
+#include &quot;GTerrainMap.h&quot;
+#include &lt;set&gt;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+//#include &lt;time.h&gt;
+using std::deque;
+using std::set;
+
+GlobalTerrainMap::GlobalTerrainMap(IAICallback* cb, cLogFile* l)
+{
+//	l = logfile;
+	*l&lt;&lt;&quot;\n Loading the Terrain-Map ...&quot;;
+
+	// Reading the WaterDamage entry from the map file
+	const int mapFileVersion = 2;
+	waterIsHarmful = false;
+	string mapFileName = cb-&gt;GetMapName();
+	mapFileName = RAIDirectory + &quot;cache/&quot; + mapFileName.substr(0,int(mapFileName.size())-3) + &quot;res&quot;;
+	FILE *mapFile = fopen(mapFileName.c_str(),&quot;rb&quot;);
+	bool mapFileLoaded = false;
+	if( mapFile )
+	{
+		int version;
+		fread(&amp;version, sizeof(int), 1, mapFile);
+		if( version == mapFileVersion )
+		{
+			fread(&amp;waterIsHarmful, sizeof(bool), 1, mapFile);
+			fread(&amp;waterIsAVoid, sizeof(bool), 1, mapFile);
+			mapFileLoaded = true;
+		}
+		else
+			*l&lt;&lt;&quot;\n  The cashed map-file is using a different version format, reloading...&quot;;
+		fclose(mapFile);
+	}
+	if( !mapFileLoaded )
+	{
+//		double mapArchiveTimer = clock();
+		string mapArchiveFileName = cb-&gt;GetMapName();
+		mapArchiveFileName = &quot;maps\\&quot;+mapArchiveFileName.substr(0,int(mapArchiveFileName.size())-3)+&quot;smd&quot;;
+		int mapArchiveFileSize = cb-&gt;GetFileSize(mapArchiveFileName.c_str());
+		if( mapArchiveFileSize &gt; 0 )
+		{
+			*l&lt;&lt;&quot;\n  Searching the Map-Archive File: '&quot;&lt;&lt;mapArchiveFileName&lt;&lt;&quot;'  File Size: &quot;&lt;&lt;mapArchiveFileSize;
+			char *archiveFile = new char[mapArchiveFileSize];
+			cb-&gt;ReadFile(mapArchiveFileName.c_str(),archiveFile,mapArchiveFileSize);
+			int waterDamage = GetFileValue(mapArchiveFileSize,archiveFile,&quot;WaterDamage&quot;);
+			waterIsAVoid = GetFileValue(mapArchiveFileSize,archiveFile,&quot;VoidWater&quot;) &gt; 0;
+			*l&lt;&lt;&quot;\n   Void Water: &quot;&lt;&lt;waterIsAVoid;
+			if( waterIsAVoid )
+				*l&lt;&lt;&quot; (This map has no water)&quot;;
+			*l&lt;&lt;&quot;\n   Water Damage: &quot;&lt;&lt;waterDamage;
+			if( waterDamage &gt; 0 )
+			{
+				waterIsHarmful = true;
+				*l&lt;&lt;&quot; (This map's water is harmful to land units&quot;;
+				if( waterDamage &gt; 10000 )
+				{
+					waterIsAVoid = true; // UNTESTED
+					*l&lt;&lt;&quot; as well as hovercraft&quot;;
+				}
+				*l&lt;&lt;&quot;)&quot;;
+			}
+			delete [] archiveFile;
+		}
+//		*l&lt;&lt;&quot;\n  Map-Archive Timer: &quot;&lt;&lt;(clock()-mapArchiveTimer)/CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+
+		mapFile = fopen(mapFileName.c_str(),&quot;wb&quot;);
+		fwrite(&amp;mapFileVersion,sizeof(int),1,mapFile);
+		fwrite(&amp;waterIsHarmful,sizeof(bool),1,mapFile);
+		fwrite(&amp;waterIsAVoid,sizeof(bool),1,mapFile);
+		fclose(mapFile);
+	}
+
+	convertStoP = 64; // = 2^x, should not be less than 16
+	if( (cb-&gt;GetMapWidth()/64)*(cb-&gt;GetMapHeight()/64) &lt; 8*8 )
+		convertStoP /= 2; // Smaller Sectors, more detailed analysis
+//	else if( (cb-&gt;GetMapWidth()/16)*(cb-&gt;GetMapHeight()/16) &gt; 20*20 )
+//		convertStoP *= 2; // Larger Sectors, less detailed analysis
+	sectorXSize = (8*cb-&gt;GetMapWidth())/convertStoP;
+	sectorZSize = (8*cb-&gt;GetMapHeight())/convertStoP;
+	sectorAirType = new TerrainMapAreaSector[sectorXSize*sectorZSize];
+	*l&lt;&lt;&quot;\n  Sector-Map Block Size: &quot;&lt;&lt;convertStoP;
+	*l&lt;&lt;&quot;\n  Sector-Map Size: &quot;&lt;&lt;sectorXSize*sectorZSize&lt;&lt;&quot; (x&quot;&lt;&lt;sectorXSize&lt;&lt;&quot;,z&quot;&lt;&lt;sectorZSize&lt;&lt;&quot;)&quot;;
+
+	// MoveType Detection and TerrainMapMobileType Initialization
+	const UnitDef **udList = new const UnitDef*[cb-&gt;GetNumUnitDefs()];
+	cb-&gt;GetUnitDefList(udList);
+	int udSize=cb-&gt;GetNumUnitDefs();
+	typedef pair&lt;int,TerrainMapMobileType*&gt; itmPair; // used to access mobileType
+	typedef pair&lt;int,TerrainMapImmobileType*&gt; itiPair; // used to access immobileType
+
+	for( int iud=0; iud&lt;udSize; iud++ )
+		if( udList[iud] != 0 )
+		{
+			if( udList[iud]-&gt;canfly )
+				udMobileType.insert(itmPair(udList[iud]-&gt;id,0));
+			else if( udList[iud]-&gt;movedata == 0 )
+			{
+				TerrainMapImmobileType* IT = 0;
+				for(list&lt;TerrainMapImmobileType&gt;::iterator iIT = immobileType.begin(); iIT != immobileType.end(); iIT++ )
+					if( iIT-&gt;maxElevation == -udList[iud]-&gt;minWaterDepth &amp;&amp; iIT-&gt;canHover == udList[iud]-&gt;canhover &amp;&amp; iIT-&gt;canFloat == udList[iud]-&gt;floater )
+						if( iIT-&gt;minElevation == -udList[iud]-&gt;maxWaterDepth ||
+							((iIT-&gt;canHover || iIT-&gt;canFloat) &amp;&amp; iIT-&gt;minElevation &lt;= 0 &amp;&amp; -udList[iud]-&gt;maxWaterDepth &lt;= 0) )
+						{
+							IT = &amp;*iIT;
+							break;
+						}
+				if( IT == 0 )
+				{
+					TerrainMapImmobileType IT2;
+					immobileType.push_back(IT2);
+					IT = &amp;immobileType.back();
+					IT-&gt;maxElevation = -udList[iud]-&gt;minWaterDepth;
+					IT-&gt;minElevation = -udList[iud]-&gt;maxWaterDepth;
+					IT-&gt;canHover = udList[iud]-&gt;canhover;
+					IT-&gt;canFloat = udList[iud]-&gt;floater;
+				}
+				IT-&gt;udSize++;
+				udImmobileType.insert(itiPair(udList[iud]-&gt;id,IT));
+			}
+			else
+			{
+				MoveData* md = udList[iud]-&gt;movedata;
+				TerrainMapMobileType* MT = 0;
+				for( list&lt;TerrainMapMobileType&gt;::iterator iMT=mobileType.begin(); iMT!=mobileType.end(); iMT++ )
+					if( iMT-&gt;maxElevation == -udList[iud]-&gt;minWaterDepth &amp;&amp; iMT-&gt;maxSlope == md-&gt;maxSlope &amp;&amp;
+						iMT-&gt;canHover == udList[iud]-&gt;canhover &amp;&amp; iMT-&gt;canFloat == udList[iud]-&gt;floater )
+						if( iMT-&gt;minElevation == -md-&gt;depth ||
+							((iMT-&gt;canHover || iMT-&gt;canFloat) &amp;&amp; iMT-&gt;minElevation &lt;= 0 &amp;&amp; -udList[iud]-&gt;maxWaterDepth &lt;= 0) )
+						{
+							MT = &amp;*iMT;
+							break;
+						}
+				if( MT == 0 )
+				{
+					TerrainMapMobileType MT2;
+					mobileType.push_back(MT2);
+					MT = &amp;mobileType.back();
+					MT-&gt;maxSlope = md-&gt;maxSlope;
+					MT-&gt;maxElevation = -udList[iud]-&gt;minWaterDepth;
+					MT-&gt;minElevation = -md-&gt;depth;
+					MT-&gt;canHover = udList[iud]-&gt;canhover;
+					MT-&gt;canFloat = udList[iud]-&gt;floater;
+					MT-&gt;sector = new TerrainMapAreaSector[sectorXSize*sectorZSize];
+					MT-&gt;MD = md;
+//					MT-&gt;PF = new GlobalPathfinder();
+//					MT-&gt;PF-&gt;Init(cb,l,MT-&gt;maxElevation,-md-&gt;depth,md-&gt;maxSlope,MT-&gt;canHover,MT-&gt;canFloat,waterIsHarmful);
+//					vector&lt;float3&gt; path;
+//					float3 start = float3(20.0,0,20.0);
+//					float3 end = float3(80.0,0,80.0);
+//					*l&lt;&lt;&quot; distance=&quot;; *l&lt;&lt;MT-&gt;PF-&gt;FindPath(path,start,end);
+				}
+				MT-&gt;udSize++;
+				udMobileType.insert(itmPair(udList[iud]-&gt;id,MT));
+				if( MT-&gt;MD-&gt;crushStrength &lt; udList[iud]-&gt;movedata-&gt;crushStrength )
+					MT-&gt;MD = udList[iud]-&gt;movedata; // figured it would be easier on the pathfinder
+			}
+		}
+	delete [] udList;
+
+	if( waterIsAVoid )
+	{
+		if( mobileType.size() == 0 ) // Work-Around(Mod FF): buildings use canFloat instead of canFly to represent their ability to fly in space
+			waterIsAVoid = false;
+		else
+			waterIsHarmful = true; // If there is no water then this will prevent water units from being used
+	}
+
+	// Special types
+	landSectorType = 0;
+	waterSectorType = 0;
+	for(list&lt;TerrainMapImmobileType&gt;::iterator iMT = immobileType.begin(); iMT != immobileType.end(); iMT++ )
+		if( !iMT-&gt;canFloat &amp;&amp; !iMT-&gt;canHover )
+		{
+			if( iMT-&gt;minElevation == 0 &amp;&amp; (landSectorType == 0 || iMT-&gt;maxElevation &gt; landSectorType-&gt;maxElevation ) )
+				landSectorType = &amp;*iMT;
+			if( iMT-&gt;maxElevation == 0 &amp;&amp; (waterSectorType == 0 || iMT-&gt;minElevation &lt; waterSectorType-&gt;minElevation ) )
+				waterSectorType = &amp;*iMT;
+		}
+	if( landSectorType == 0 )
+	{
+		immobileType.push_back(TerrainMapImmobileType());
+		landSectorType = &amp;immobileType.back();
+		immobileType.back().maxElevation = 1e7;
+		immobileType.back().minElevation = 0;
+		immobileType.back().canFloat = false;
+		immobileType.back().canHover = false;
+	}
+	if( waterSectorType == 0 )
+	{
+		immobileType.push_back(TerrainMapImmobileType());
+		waterSectorType = &amp;immobileType.back();
+		immobileType.back().maxElevation = 0;
+		immobileType.back().minElevation = -1e7;
+		immobileType.back().canFloat = false;
+		immobileType.back().canHover = false;
+	}
+
+	*l&lt;&lt;&quot;\n  Determining Usable Terrain for all units ...&quot;;
+	// Setting sector &amp; determining sectors for immobileType
+	sector = new TerrainMapSector[sectorXSize*sectorZSize];
+	const float *standardSlopeMap = cb-&gt;GetSlopeMap();
+	const float *standardHeightMap = cb-&gt;GetHeightMap();
+	const int convertStoSM = convertStoP/16; // * for conversion, / for reverse conversion
+	const int convertStoHM = convertStoP/8; // * for conversion, / for reverse conversion
+	const int slopeMapXSize = sectorXSize*convertStoSM;
+	const int heightMapXSize = sectorXSize*convertStoHM;
+	typedef pair&lt;int,TerrainMapSector*&gt; itdPair;
+	minElevation=0;
+	percentLand=0.0;
+	for(int z=0; z &lt; sectorZSize; z++)
+		for(int x=0; x &lt; sectorXSize; x++)
+		{
+			int i=(z*sectorXSize)+x;
+			sector[i].position.x = x*convertStoP+convertStoP/2; // Center position of the Block
+			sector[i].position.z = z*convertStoP+convertStoP/2; //
+			sector[i].position.y = cb-&gt;GetElevation(sector[i].position.x,sector[i].position.z);
+			sectorAirType[i].S = &amp;sector[i];
+			for(list&lt;TerrainMapMobileType&gt;::iterator iMT = mobileType.begin(); iMT != mobileType.end(); iMT++ )
+				iMT-&gt;sector[i].S = &amp;sector[i];
+
+			int iMap = ((z*convertStoSM)*slopeMapXSize)+x*convertStoSM;
+			for(int zS=0; zS&lt;convertStoSM; zS++)
+				for(int xS=0,iS=iMap+zS*slopeMapXSize+xS; xS&lt;convertStoSM; xS++,iS=iMap+zS*slopeMapXSize+xS )
+					if( sector[i].maxSlope &lt; standardSlopeMap[iS] )
+						sector[i].maxSlope = standardSlopeMap[iS];
+
+			iMap = ((z*convertStoHM)*heightMapXSize)+x*convertStoHM;
+			sector[i].minElevation = standardHeightMap[iMap];
+			sector[i].maxElevation = standardHeightMap[iMap];
+			for(int zH=0; zH&lt;convertStoHM; zH++)
+				for(int xH=0,iH=iMap+zH*heightMapXSize+xH; xH&lt;convertStoHM; xH++,iH=iMap+zH*heightMapXSize+xH )
+				{
+					if( standardHeightMap[iH] &gt;= 0 )
+					{
+						sector[i].percentLand++;
+						percentLand++;
+					}
+					if( sector[i].minElevation &gt; standardHeightMap[iH] )
+					{
+						sector[i].minElevation = standardHeightMap[iH];
+						if( minElevation &gt; standardHeightMap[i] )
+							minElevation = standardHeightMap[i];
+					}
+					else if( sector[i].maxElevation &lt; standardHeightMap[iH] )
+						sector[i].maxElevation = standardHeightMap[iH];
+				}
+			sector[i].percentLand *= 100.0/(convertStoHM*convertStoHM);
+			if( sector[i].percentLand &gt; 50.0 )
+				sector[i].isWater = false;
+			else
+				sector[i].isWater = true;
+
+			for(list&lt;TerrainMapImmobileType&gt;::iterator iMT = immobileType.begin(); iMT != immobileType.end(); iMT++ )
+				if( (iMT-&gt;canHover &amp;&amp; iMT-&gt;maxElevation &gt;= sector[i].maxElevation &amp;&amp; !waterIsAVoid ) ||
+					(iMT-&gt;canFloat &amp;&amp; iMT-&gt;maxElevation &gt;= sector[i].maxElevation &amp;&amp; !waterIsHarmful ) ||
+					(iMT-&gt;minElevation &lt;= sector[i].minElevation &amp;&amp; iMT-&gt;maxElevation &gt;= sector[i].maxElevation &amp;&amp; (!waterIsHarmful || sector[i].minElevation &gt;=0 ) ) )
+					iMT-&gt;sector.insert(itdPair(i,&amp;sector[i]));
+		}
+	percentLand *= 100.0/(sectorXSize*convertStoHM*sectorZSize*convertStoHM);
+
+	for(list&lt;TerrainMapImmobileType&gt;::iterator iMT = immobileType.begin(); iMT != immobileType.end(); iMT++ )
+		if( (100.0*iMT-&gt;sector.size())/float(sectorXSize*sectorZSize) &gt;= 20.0 || (double)convertStoP*convertStoP*iMT-&gt;sector.size() &gt;= 1.8e7 )
+			iMT-&gt;typeUsable = true;
+		else
+			iMT-&gt;typeUsable = false;
+
+	*l&lt;&lt;&quot;\n   Map Land Percent: &quot;&lt;&lt;percentLand&lt;&lt;&quot;%&quot;;
+	*l&lt;&lt;&quot;\n   Minimum Elevation: &quot;&lt;&lt;minElevation;
+
+	for(list&lt;TerrainMapImmobileType&gt;::iterator iMT = immobileType.begin(); iMT != immobileType.end(); iMT++ )
+	{
+		*l&lt;&lt;&quot;\n   Immobile-Type: Min/Max Elevation=(&quot;;
+		if( iMT-&gt;canHover )
+			*l&lt;&lt;&quot;hover&quot;;
+		else if( iMT-&gt;canFloat || iMT-&gt;minElevation &lt; -10000 )
+			*l&lt;&lt;&quot;any&quot;;
+		else
+			*l&lt;&lt;iMT-&gt;minElevation;
+		*l&lt;&lt;&quot; / &quot;;
+		if( iMT-&gt;maxElevation &lt; 10000 )
+			*l&lt;&lt;iMT-&gt;maxElevation;
+		else
+			*l&lt;&lt;&quot;any&quot;;
+		*l&lt;&lt;&quot;)   \tIs buildable across &quot;&lt;&lt;(100.0*iMT-&gt;sector.size())/(sectorXSize*sectorZSize)&lt;&lt;&quot;% of the map. (used by &quot;&lt;&lt;iMT-&gt;udSize&lt;&lt;&quot; unit-defs)&quot;; //&lt;&lt;&quot; &quot;&lt;&lt;iMT-&gt;sector.size()&lt;&lt;&quot; sector(s)&quot;;
+	}
+/*
+	*l&lt;&lt;&quot;\n  Displaying the Standard Land/Water Area(s) ...&quot;;
+	for( int i=0; i&lt;areaIUSize; i++ )
+	{
+		*l&lt;&lt;&quot;\n   &quot;;
+		*l&lt;&lt;&quot;(&quot;&lt;&lt;i+1&lt;&lt;&quot;), occupying &quot;&lt;&lt;areaIU[i]-&gt;percentOfMap&lt;&lt;&quot;% of the map (&quot;&lt;&lt;areaIU[i]-&gt;percentMetal&lt;&lt;&quot;% Metal) &quot;;
+		if( areaIU[i]-&gt;isMetalMap ) *l&lt;&lt;&quot;(MetalMap)&quot;;
+		*l&lt;&lt;&quot;, has been detected with &quot;&lt;&lt;areaIU[i]-&gt;sector.size()&lt;&lt;&quot; sectors.&quot;;
+	}
+*/
+	const int MAMinimalSectors = 8;				// Minimal # of sector for a valid MapArea
+	const float MAMinimalSectorPercent = 0.5;	// Minimal % of map for a valid MapArea
+	for( list&lt;TerrainMapMobileType&gt;::iterator iMT=mobileType.begin(); iMT!=mobileType.end(); iMT++ )
+	{
+		*l&lt;&lt;&quot;\n   Mobile-Type: Min/Max Elevation=(&quot;;
+		if( iMT-&gt;canFloat )
+			*l&lt;&lt;&quot;any&quot;;
+		else if( iMT-&gt;canHover )
+			*l&lt;&lt;&quot;hover&quot;;
+		else
+			*l&lt;&lt;iMT-&gt;minElevation;
+		*l&lt;&lt;&quot; / &quot;;
+		if( iMT-&gt;maxElevation &lt; 10000 )
+			*l&lt;&lt;iMT-&gt;maxElevation;
+		else
+			*l&lt;&lt;&quot;any&quot;;
+		*l&lt;&lt;&quot;)\tMax Slope=(&quot;&lt;&lt;iMT-&gt;maxSlope;
+		*l&lt;&lt;&quot;)   \tMove-Data used:'&quot;&lt;&lt;iMT-&gt;MD-&gt;name&lt;&lt;&quot;'&quot;;
+
+		deque&lt;int&gt; sectorSearch;
+		set&lt;int&gt; sectorsRemaining;
+		for(int iS=0; iS&lt;sectorZSize*sectorXSize; iS++)
+			if( (iMT-&gt;canHover &amp;&amp; iMT-&gt;maxElevation &gt;= sector[iS].maxElevation &amp;&amp; !waterIsAVoid &amp;&amp; (sector[iS].maxElevation &lt;= 0 || iMT-&gt;maxSlope &gt;= sector[iS].maxSlope) ) ||
+				(iMT-&gt;canFloat &amp;&amp; iMT-&gt;maxElevation &gt;= sector[iS].maxElevation &amp;&amp; !waterIsHarmful &amp;&amp; (sector[iS].maxElevation &lt;= 0 || iMT-&gt;maxSlope &gt;= sector[iS].maxSlope) ) ||
+				(iMT-&gt;maxSlope &gt;= sector[iS].maxSlope &amp;&amp; iMT-&gt;minElevation &lt;= sector[iS].minElevation &amp;&amp; iMT-&gt;maxElevation &gt;= sector[iS].maxElevation &amp;&amp; (!waterIsHarmful || sector[iS].minElevation &gt;=0 ) ) )
+				sectorsRemaining.insert(iS);
+		int i,iX,iZ,aIndex; // Temp Var.
+		while( int(sectorsRemaining.size())&gt;0 || int(sectorSearch.size())&gt;0 )
+		{
+			if( int(sectorSearch.size()) &gt; 0 )
+			{
+				i = sectorSearch.front();
+				iMT-&gt;area[aIndex]-&gt;sector.insert(iasPair(i,&amp;iMT-&gt;sector[i]));
+				iX = i%sectorXSize;
+				iZ = i/sectorXSize;
+				if( sectorsRemaining.find(i-1)!=sectorsRemaining.end() &amp;&amp; iX &gt; 0 ) // Search left
+				{
+					sectorSearch.push_back(i-1);
+					sectorsRemaining.erase(i-1);
+				}
+				if( sectorsRemaining.find(i+1)!=sectorsRemaining.end() &amp;&amp; iX &lt; sectorXSize-1 ) // Search right
+				{
+					sectorSearch.push_back(i+1);
+					sectorsRemaining.erase(i+1);
+				}
+				if( sectorsRemaining.find(i-sectorXSize)!=sectorsRemaining.end() &amp;&amp; iZ &gt; 0 ) // Search up
+				{
+					sectorSearch.push_back(i-sectorXSize);
+					sectorsRemaining.erase(i-sectorXSize);
+				}
+				if( sectorsRemaining.find(i+sectorXSize)!=sectorsRemaining.end() &amp;&amp; iZ &lt; sectorZSize-1 ) // Search down
+				{
+					sectorSearch.push_back(i+sectorXSize);
+					sectorsRemaining.erase(i+sectorXSize);
+				}
+				sectorSearch.pop_front();
+			}
+			else
+			{
+				if( iMT-&gt;areaSize &gt; 0 &amp;&amp;
+					( iMT-&gt;areaSize == 50 ||
+					  iMT-&gt;area[iMT-&gt;areaSize-1]-&gt;sector.size() &lt;= MAMinimalSectors ||
+					  100.*float(iMT-&gt;area[iMT-&gt;areaSize-1]-&gt;sector.size())/float(sectorXSize*sectorZSize) &lt;= MAMinimalSectorPercent ) )
+				{
+					// Too mand areas detected.  Find, erase &amp; ignore the smallest one that was found so far
+					if( iMT-&gt;areaSize == 50 )
+						*l&lt;&lt;&quot;\nWARNING: The MapArea limit has been reached (possible error).&quot;;
+					aIndex=0;
+					for( int iA=1; iA&lt;iMT-&gt;areaSize; iA++ )
+						if( iMT-&gt;area[iA]-&gt;sector.size() &lt; iMT-&gt;area[aIndex]-&gt;sector.size() )
+							aIndex = iA;
+					delete iMT-&gt;area[aIndex];
+					iMT-&gt;areaSize--;
+				}
+				else
+					aIndex=iMT-&gt;areaSize;
+
+				i=*sectorsRemaining.begin();
+				sectorSearch.push_back(i);
+				sectorsRemaining.erase(i);
+				iMT-&gt;area[aIndex] = new TerrainMapArea(aIndex,&amp;*iMT);
+				iMT-&gt;areaSize++;
+			}
+		}
+		if( iMT-&gt;areaSize &gt; 0 &amp;&amp;
+			( iMT-&gt;area[iMT-&gt;areaSize-1]-&gt;sector.size() &lt;= MAMinimalSectors ||
+			  100.0*float(iMT-&gt;area[iMT-&gt;areaSize-1]-&gt;sector.size())/float(sectorXSize*sectorZSize) &lt;= MAMinimalSectorPercent ) )
+		{
+			iMT-&gt;areaSize--;
+			delete iMT-&gt;area[iMT-&gt;areaSize];
+		}
+
+		// Calculations
+		float percentOfMap = 0.0;
+		for( int iA=0; iA&lt;iMT-&gt;areaSize; iA++ )
+		{
+			for( map&lt;int,TerrainMapAreaSector*&gt;::iterator iS=iMT-&gt;area[iA]-&gt;sector.begin(); iS!=iMT-&gt;area[iA]-&gt;sector.end(); iS++ )
+				iS-&gt;second-&gt;area = iMT-&gt;area[iA];
+			iMT-&gt;area[iA]-&gt;percentOfMap = (100.0*iMT-&gt;area[iA]-&gt;sector.size())/(sectorXSize*sectorZSize);
+			if( iMT-&gt;area[iA]-&gt;percentOfMap &gt;= 20.0 ) // A map area occupying 20% of the map
+			{
+				iMT-&gt;area[iA]-&gt;areaUsable = true;
+				iMT-&gt;typeUsable = true;
+			}
+			else
+				iMT-&gt;area[iA]-&gt;areaUsable = false;
+			if( iMT-&gt;areaLargest == 0 || iMT-&gt;areaLargest-&gt;percentOfMap &lt; iMT-&gt;area[iA]-&gt;percentOfMap )
+				iMT-&gt;areaLargest = iMT-&gt;area[iA];
+
+			percentOfMap += iMT-&gt;area[iA]-&gt;percentOfMap;
+		}
+		*l&lt;&lt;&quot;  \tHas &quot;&lt;&lt;iMT-&gt;areaSize&lt;&lt;&quot; Map-Area(s) occupying &quot;&lt;&lt;percentOfMap&lt;&lt;&quot;% of the map. (used by &quot;&lt;&lt;iMT-&gt;udSize&lt;&lt;&quot; unit-defs)&quot;;
+	}
+/*
+	// Debugging
+	l = new cLogFile(&quot;TerrainMapDebug.log&quot;,false);
+	for( int iS=0; iS&lt;sectorXSize*sectorZSize; iS++ )
+	{
+		if( iS % sectorXSize == 0 ) *l&lt;&lt;&quot;\n&quot;;
+		if( sector[iS].maxElevation &lt; 0.0 ) *l&lt;&lt;&quot;~&quot;;
+		else if( sector[iS].maxSlope &gt; 0.5 ) *l&lt;&lt;&quot;^&quot;;
+		else if( sector[iS].maxSlope &gt; 0.25 ) *l&lt;&lt;&quot;#&quot;;
+		else *l&lt;&lt;&quot;x&quot;;
+	}
+	for( list&lt;TerrainMapMobileType&gt;::iterator iM=mobileType.begin(); iM!=mobileType.end(); iM++ )
+	{
+		*l&lt;&lt;&quot;\n\n &quot;&lt;&lt;iM-&gt;MD-&gt;name&lt;&lt;&quot; h=&quot;&lt;&lt;iM-&gt;canHover&lt;&lt;&quot; f=&quot;&lt;&lt;iM-&gt;canFloat&lt;&lt;&quot; mb=&quot;&lt;&lt;iM-&gt;areaSize;
+		for( int iS=0; iS&lt;sectorXSize*sectorZSize; iS++ )
+		{
+			if( iS % sectorXSize == 0 ) *l&lt;&lt;&quot;\n&quot;;
+			if( iM-&gt;sector[iS].area != 0 ) *l&lt;&lt;&quot;*&quot;;
+			else if( sector[iS].maxElevation &lt; 0.0 ) *l&lt;&lt;&quot;~&quot;;
+			else if( sector[iS].maxSlope &gt; 0.5 ) *l&lt;&lt;&quot;^&quot;;
+			else *l&lt;&lt;&quot;x&quot;;
+		}
+	}
+	*l&lt;&lt;&quot;\n&quot;;
+*/
+}
+
+GlobalTerrainMap::~GlobalTerrainMap()
+{
+	delete [] sector;
+	delete [] sectorAirType;
+}
+
+bool GlobalTerrainMap::CanMoveToPos(TerrainMapArea *area, const float3&amp; destination)
+{
+	int iS = GetSectorIndex(destination);
+	if( !IsSectorValid(iS) )
+		return false;
+	if( area == 0 ) // either a flying unit or a unit was somehow created at an impossible position
+		return true;
+	if( area == GetSectorList(area)[iS].area )
+		return true;
+	return false;
+}
+
+TerrainMapAreaSector* GlobalTerrainMap::GetSectorList(TerrainMapArea* sourceArea)
+{
+	if( sourceArea == 0 || sourceArea-&gt;mobileType == 0 ) // It flies or it's immobile
+		return sectorAirType;
+	return sourceArea-&gt;mobileType-&gt;sector;
+}
+
+TerrainMapAreaSector* GlobalTerrainMap::GetClosestSector(TerrainMapArea* sourceArea, const int&amp; destinationSIndex)
+{
+	map&lt;int,TerrainMapAreaSector*&gt;::iterator iAS = sourceArea-&gt;sectorClosest.find(destinationSIndex);
+	if( iAS != sourceArea-&gt;sectorClosest.end() ) // It's already been determined
+		return iAS-&gt;second;
+//*l&lt;&lt;&quot;\n GCAS&quot;;
+	TerrainMapAreaSector* TMSectors = GetSectorList(sourceArea);
+	if( sourceArea == TMSectors[destinationSIndex].area )
+	{
+		sourceArea-&gt;sectorClosest.insert(iasPair(destinationSIndex,&amp;TMSectors[destinationSIndex]));
+//*l&lt;&lt;&quot;1(#)&quot;;
+		return &amp;TMSectors[destinationSIndex];
+	}
+
+	float3 *destination = &amp;TMSectors[destinationSIndex].S-&gt;position;
+	TerrainMapAreaSector* SClosest = 0;
+	float DisClosest;
+	for( map&lt;int,TerrainMapAreaSector*&gt;::iterator iS=sourceArea-&gt;sector.begin(); iS!=sourceArea-&gt;sector.end(); iS++ )
+		if( SClosest == 0 || iS-&gt;second-&gt;S-&gt;position.distance(*destination) &lt; DisClosest )
+		{
+			SClosest = iS-&gt;second;
+			DisClosest = iS-&gt;second-&gt;S-&gt;position.distance(*destination);
+		}
+	sourceArea-&gt;sectorClosest.insert(iasPair(destinationSIndex,SClosest));
+//*l&lt;&lt;&quot;2(#)&quot;;
+	return SClosest;
+}
+
+TerrainMapSector* GlobalTerrainMap::GetClosestSector(TerrainMapImmobileType* sourceIT, const int&amp; destinationSIndex)
+{
+	map&lt;int,TerrainMapSector*&gt;::iterator iS = sourceIT-&gt;sectorClosest.find(destinationSIndex);
+	if( iS != sourceIT-&gt;sectorClosest.end() ) // It's already been determined
+		return iS-&gt;second;
+//*l&lt;&lt;&quot;\n GCS&quot;;
+	if( sourceIT-&gt;sector.find(destinationSIndex) != sourceIT-&gt;sector.end() )
+	{
+		sourceIT-&gt;sectorClosest.insert(isdPair(destinationSIndex,&amp;sector[destinationSIndex]));
+//*l&lt;&lt;&quot;1(#)&quot;;
+		return &amp;sector[destinationSIndex];
+	}
+
+	const float3 *destination = &amp;sector[destinationSIndex].position;
+	TerrainMapSector* SClosest = 0;
+	float DisClosest;
+	for( map&lt;int,TerrainMapSector*&gt;::iterator iS=sourceIT-&gt;sector.begin(); iS!=sourceIT-&gt;sector.end(); iS++ )
+		if( SClosest == 0 || iS-&gt;second-&gt;position.distance(*destination) &lt; DisClosest )
+		{
+			SClosest = iS-&gt;second;
+			DisClosest = iS-&gt;second-&gt;position.distance(*destination);
+		}
+	sourceIT-&gt;sectorClosest.insert(isdPair(destinationSIndex,SClosest));
+//*l&lt;&lt;&quot;2(#)&quot;;
+	return SClosest;
+}
+
+TerrainMapAreaSector* GlobalTerrainMap::GetAlternativeSector(TerrainMapArea* sourceArea, const int&amp; sourceSIndex, TerrainMapMobileType* destinationMT)
+{
+	TerrainMapAreaSector* TMSectors = GetSectorList(sourceArea);
+	map&lt;TerrainMapMobileType*,TerrainMapAreaSector*&gt;::iterator iMS = TMSectors[sourceSIndex].sectorAlternativeM.find(destinationMT);
+	if( iMS != TMSectors[sourceSIndex].sectorAlternativeM.end() ) // It's already been determined
+		return iMS-&gt;second;
+//*l&lt;&lt;&quot;\nGSAM&quot;;
+	if( destinationMT == 0 ) // flying unit movetype
+	{
+//		*l&lt;&lt;&quot;(2#)&quot;;
+		return &amp;TMSectors[sourceSIndex];
+	}
+
+	if( sourceArea != 0 &amp;&amp; sourceArea != TMSectors[sourceSIndex].area )
+	{
+//		*l&lt;&lt;&quot;(3#)&quot;;
+		return GetAlternativeSector(sourceArea, GetSectorIndex(GetClosestSector(sourceArea,sourceSIndex)-&gt;S-&gt;position), destinationMT);
+	}
+
+	const float3* position = &amp;TMSectors[sourceSIndex].S-&gt;position;
+	TerrainMapAreaSector* bestAS = 0;
+	TerrainMapArea* largestArea = 0;
+	float bestDistance = -1.0;
+	float bestMidDistance = -1.0;
+	TerrainMapArea **TMAreas = destinationMT-&gt;area;
+	const int *TMAreaSize = &amp;destinationMT-&gt;areaSize;
+	for( int iA=0; iA&lt;*TMAreaSize; iA++ )
+		if( largestArea == 0 || largestArea-&gt;percentOfMap &lt; TMAreas[iA]-&gt;percentOfMap )
+			largestArea = TMAreas[iA];
+	for( int iA=0; iA&lt;*TMAreaSize; iA++ )
+		if( TMAreas[iA]-&gt;areaUsable || !largestArea-&gt;areaUsable )
+		{
+			TerrainMapAreaSector* CAS = GetClosestSector(TMAreas[iA],sourceSIndex);
+			float midDistance; // how much of a gap exists between the two areas (source &amp; destination)
+			if( sourceArea == 0 || sourceArea == TMSectors[GetSectorIndex(CAS-&gt;S-&gt;position)].area )
+				midDistance = 0.0;
+			else
+				midDistance = CAS-&gt;S-&gt;position.distance2D(GetClosestSector(sourceArea,GetSectorIndex(CAS-&gt;S-&gt;position))-&gt;S-&gt;position);
+			if( bestMidDistance &lt; 0 || midDistance &lt; bestMidDistance )
+			{
+				bestMidDistance = midDistance;
+				bestAS = 0;
+				bestDistance = -1.0;
+			}
+			if( midDistance == bestMidDistance )
+			{
+				float distance = position-&gt;distance2D(CAS-&gt;S-&gt;position);
+				if( bestAS == 0 || distance*TMAreas[iA]-&gt;percentOfMap &lt; bestDistance*bestAS-&gt;area-&gt;percentOfMap )
+				{
+					bestAS = CAS;
+					bestDistance = distance;
+				}
+			}
+		}
+	TMSectors[sourceSIndex].sectorAlternativeM.insert(msPair(destinationMT,bestAS));
+//	*l&lt;&lt;&quot;(!#)&quot;;
+	return bestAS;
+}
+
+TerrainMapSector* GlobalTerrainMap::GetAlternativeSector(TerrainMapArea* destinationArea, const int&amp; sourceSIndex, TerrainMapImmobileType* destinationIT)
+{
+	TerrainMapAreaSector* TMSectors = GetSectorList(destinationArea);
+	map&lt;TerrainMapImmobileType*,TerrainMapSector*&gt;::iterator iMS = TMSectors[sourceSIndex].sectorAlternativeI.find(destinationIT);
+	if( iMS != TMSectors[sourceSIndex].sectorAlternativeI.end() ) // It's already been determined
+		return iMS-&gt;second;
+
+//*l&lt;&lt;&quot;\nGSAI&quot;;
+	TerrainMapSector* closestS = 0;
+	if( destinationArea != 0 &amp;&amp; destinationArea != TMSectors[sourceSIndex].area )
+	{
+//		*l&lt;&lt;&quot;(3#)&quot;;
+		closestS = GetAlternativeSector(destinationArea, GetSectorIndex(GetClosestSector(destinationArea,sourceSIndex)-&gt;S-&gt;position), destinationIT);
+		TMSectors[sourceSIndex].sectorAlternativeI.insert(isPair(destinationIT,closestS));
+		return closestS;
+	}
+
+	const float3 *position = &amp;sector[sourceSIndex].position;
+	float closestDistance = -1.0;
+	for( map&lt;int,TerrainMapAreaSector*&gt;::iterator iS=destinationArea-&gt;sector.begin(); iS!=destinationArea-&gt;sector.end(); iS++ )
+		if( closestS == 0 || iS-&gt;second-&gt;S-&gt;position.distance(*position) &lt; closestDistance )
+		{
+			closestS = iS-&gt;second-&gt;S;
+			closestDistance = iS-&gt;second-&gt;S-&gt;position.distance(*position);
+		}
+
+	TMSectors[sourceSIndex].sectorAlternativeI.insert(isPair(destinationIT,closestS));
+//	*l&lt;&lt;&quot;(!#)&quot;;
+	return closestS;
+}
+
+int GlobalTerrainMap::GetSectorIndex(const float3&amp; position)
+{
+	return sectorXSize*(int(position.z)/convertStoP) + int(position.x)/convertStoP;
+}
+
+bool GlobalTerrainMap::IsSectorValid(const int&amp; sIndex)
+{
+	if( sIndex &lt; 0 || sIndex &gt;= sectorXSize*sectorZSize )
+		return false;
+	return true;
+}
+
+int GlobalTerrainMap::GetFileValue(int &amp;fileSize, char *&amp;file, string entry)
+{
+	for(int i=0; i&lt;entry.size(); i++)
+		if( !islower(entry[i]) )
+			entry[i] = tolower(entry[i]);
+	int entryIndex = 0;
+	string entryValue = &quot;&quot;;
+	for(int i=0; i&lt;fileSize; i++)
+	{
+		if( entryIndex &gt;= entry.size() )
+		{	// Entry Found: Reading the value
+			if( file[i] &gt;= '0' &amp;&amp; file[i] &lt;= '9' )
+				entryValue += file[i];
+			else if( file[i] == ';' )
+				return atoi(entryValue.c_str());
+		}
+		else if( entry[entryIndex] == file[i] || (!islower(file[i]) &amp;&amp; entry[entryIndex] == tolower(file[i]) ) ) // the current letter matches
+			entryIndex++;
+		else
+			entryIndex = 0;
+	}
+	return 0;
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,180 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+// NOTES:
+// &quot;position blocks&quot; refers to the in-game units of meaturement
+// A Map Preivew Block is 512x512 position blocks
+// GetMapWidth(),GetMapHeight(),GetHeightMap() uses 8x8 position blocks
+// GetMetalMap(),GetSlopeMap() uses 16x16 position blocks
+
+#ifndef RAI_GLOBAL_TERRAIN_MAP_H
+#define RAI_GLOBAL_TERRAIN_MAP_H
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;LogFile.h&quot;
+#include &lt;map&gt;
+#include &lt;list&gt;
+#include &lt;set&gt;
+using std::list;
+using std::map;
+using std::pair;
+
+//#include &quot;GPathfinder.h&quot;
+
+struct TerrainMapArea;
+struct TerrainMapAreaSector;
+struct TerrainMapMobileType;
+struct TerrainMapImmobileType;
+struct TerrainMapSector;
+
+struct TerrainMapAreaSector
+{
+	TerrainMapAreaSector()
+	{
+		area=0;
+		areaClosest=0;
+	};
+	// NOTE: some of these values are loaded as they become needed, use GlobalTerrainMap functions
+	TerrainMapSector *S;	// always valid
+	TerrainMapArea* area;		// The TerrainMapArea this sector belongs to, otherwise = 0 until
+	TerrainMapArea* areaClosest;// uninitalized, = the TerrainMapArea closest to this sector
+	// Use this to find the closest sector useable by a unit with a different MoveType, the 0 pointer may be valid as a key index
+	map&lt;TerrainMapMobileType*,TerrainMapAreaSector*&gt; sectorAlternativeM; // uninitalized
+	map&lt;TerrainMapImmobileType*,TerrainMapSector*&gt; sectorAlternativeI; // uninitalized
+};
+
+struct TerrainMapArea
+{
+	TerrainMapArea(int areaIUSize, TerrainMapMobileType* TMMobileType)
+	{
+		index=areaIUSize;
+		mobileType = TMMobileType;
+		percentOfMap=0.0;
+	};
+	bool areaUsable; // Should units of this type be used in this area
+	int index;
+	TerrainMapMobileType* mobileType;
+	map&lt;int,TerrainMapAreaSector*&gt; sector;			// key = sector index, a list of all sectors belonging to it
+	map&lt;int,TerrainMapAreaSector*&gt; sectorClosest;	// key = sector indexes not in &quot;sector&quot;, indicates the sector belonging to this map-area with the closest distance
+												// NOTE: use GlobalTerrainMap-&gt;GetClosestSector: these values are not initalized but are instead loaded as they become needed
+	float percentOfMap; // 0-100
+};
+
+struct TerrainMapMobileType
+{
+	TerrainMapMobileType()
+	{
+		typeUsable = false;
+		sector = 0;
+		areaSize = 0;
+		areaLargest = 0;
+//		PF = 0;
+		udSize = 0;
+	};
+	~TerrainMapMobileType()
+	{
+//		if( PF != 0 )
+//			delete PF;
+		if( sector != 0 )
+			delete [] sector;
+		for(int i=0; i&lt;areaSize; i++)
+			delete area[i];
+	};
+	bool typeUsable; // Should units of this type be used on this map
+	TerrainMapAreaSector *sector;	// Each MoveType has it's own sector list, GlobalTerrainMap-&gt;GetSectorIndex() gives an index
+	TerrainMapArea *area[50];	// Each MoveType has it's own MapArea list
+	TerrainMapArea *areaLargest;// Largest area usable by this type, otherwise = 0
+	int areaSize;
+
+	float maxSlope;		// = MoveData*-&gt;maxSlope
+	float maxElevation; // = -ud-&gt;minWaterDepth
+	float minElevation; // = -MoveData*-&gt;depth
+	bool canHover;
+	bool canFloat;
+	MoveData* MD;
+	int udSize;
+//	GlobalPathfinder *PF; // unused
+};
+
+struct TerrainMapSector
+{
+	TerrainMapSector()
+	{
+		percentLand = 0.0;
+		maxSlope = 0.0;
+	};
+
+	bool isWater;		// (Water = true) (Land = false)
+	float3 position;	// center of the sector, same as unit positions
+
+	// only used during initialization
+	float percentLand; // 0-100
+	float minElevation; // 0 or less for water
+	float maxElevation;
+	float maxSlope;		// 0 or higher
+};
+
+struct TerrainMapImmobileType
+{
+	TerrainMapImmobileType()
+	{
+		udSize = 0;
+	};
+
+	bool typeUsable; // Should units of this type be used on this map
+	map&lt;int,TerrainMapSector*&gt; sector;			// a list of sectors useable by these units
+	map&lt;int,TerrainMapSector*&gt; sectorClosest;	// key = sector indexes not in &quot;sector&quot;, indicates the closest sector in &quot;sector&quot;
+	float minElevation;
+	float maxElevation;
+	bool canHover;
+	bool canFloat;
+	int udSize;
+};
+
+class GlobalTerrainMap
+{
+public:
+	GlobalTerrainMap(IAICallback* cb, cLogFile* logfile);
+	~GlobalTerrainMap();
+
+	bool CanMoveToPos(TerrainMapArea *area, const float3&amp; destination);
+	TerrainMapAreaSector* GetSectorList(TerrainMapArea* sourceArea=0);
+	TerrainMapAreaSector* GetClosestSector(TerrainMapArea* sourceArea, const int&amp; destinationSIndex);
+	TerrainMapSector* GetClosestSector(TerrainMapImmobileType* sourceIT, const int&amp; destinationSIndex);
+	TerrainMapAreaSector* GetAlternativeSector(TerrainMapArea* sourceArea, const int&amp; sourceSIndex, TerrainMapMobileType* destinationMT);
+	TerrainMapSector* GetAlternativeSector(TerrainMapArea* destinationArea, const int&amp; sourceSIndex, TerrainMapImmobileType* destinationIT); // can return 0
+	int GetSectorIndex(const float3&amp; position); // use IsSectorValid() to insure the index is valid
+	bool IsSectorValid(const int&amp; sIndex);
+
+	list&lt;TerrainMapMobileType&gt; mobileType;			// Used for mobile units, not all movedatas are used
+	map&lt;int,TerrainMapMobileType*&gt; udMobileType;	// key = ud-&gt;id, Used to find a TerrainMapMobileType for a unit
+	list&lt;TerrainMapImmobileType&gt; immobileType;		// Used for immobile units
+	map&lt;int,TerrainMapImmobileType*&gt; udImmobileType;// key = ud-&gt;id, Used to find a TerrainMapImmobileType for a unit
+	TerrainMapAreaSector *sectorAirType;	// used for flying units, GetSectorIndex gives an index
+	TerrainMapSector *sector;				// global sector data, GetSectorIndex gives an index
+	TerrainMapImmobileType *landSectorType;	// 0 to the sky
+	TerrainMapImmobileType *waterSectorType;// minElevation to 0
+
+	bool waterIsHarmful;	// Units are damaged by it (Lava/Acid map)
+	bool waterIsAVoid;		// (Space map)
+	float minElevation;		// 0 or less (used by cRAIUnitDefHandler, builder start selecter)
+	float percentLand;		// 0 to 100 (used by cRAIUnitDefHandler)
+
+	int sectorXSize;
+	int sectorZSize;
+	int convertStoP; // Sector to Position: times this value for convertion, divide for the reverse
+
+private:
+	int GetFileValue(int &amp;fileSize, char *&amp;file, string entry);
+	typedef pair&lt;int,TerrainMapAreaSector*&gt; iasPair;
+	typedef pair&lt;int,TerrainMapSector*&gt; isdPair;
+	typedef pair&lt;TerrainMapMobileType*,TerrainMapAreaSector*&gt; msPair;
+	typedef pair&lt;TerrainMapImmobileType*,TerrainMapSector*&gt; isPair;
+//	cLogFile *l; // Debugging only
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,85 @@
+#include &quot;LogFile.h&quot;
+
+//#include &lt;fstream&gt;
+//#include &lt;stdlib.h&gt;
+//#include &lt;iostream&gt;
+#include &lt;stdio.h&gt;
+
+using namespace std;
+
+cLogFile::cLogFile(string sFilename, bool bAppend)
+{
+	logFileName=RAIDirectory+sFilename;
+	if( bAppend )
+		logFile = fopen(logFileName.c_str(),&quot;a&quot;);
+//		logFile = new ofstream();
+//		logFile-&gt;open( logFileName.c_str(), ios::app );
+	else
+		logFile = fopen(logFileName.c_str(),&quot;w&quot;);
+//		ofstream oLog( logFileName.c_str() );
+//		oLog.close();
+
+/*
+		pFile = fopen(logFileName.c_str(),&quot;wt&quot;);
+		fclose(pFile);
+*/
+}
+
+cLogFile::~cLogFile()
+{
+	fclose(logFile);
+//	logFile-&gt;close();
+//	delete logFile;
+}
+
+cLogFile&amp; cLogFile::operator&lt;&lt;(float message)
+{
+	if( message - int(message) &gt; 0.0 )
+	{
+		if( message &lt; 1.0 &amp;&amp; message &gt; 0.0 )
+			fprintf(logFile, &quot;%1.3f&quot;, message);
+		else
+			fprintf(logFile, &quot;%1.2f&quot;, message);
+	}
+	else
+		fprintf(logFile, &quot;%1.0f&quot;, message);
+	return *this;
+}
+/*
+cLogFile&amp; cLogFile::operator&lt;&lt;(int message)
+{
+	fprintf(logFile, &quot;%i&quot;, message);
+	return *this;
+}
+*/
+cLogFile&amp; cLogFile::operator&lt;&lt;(string message)
+{
+	fprintf(logFile, &quot;%s&quot;, message.c_str());
+	return *this;
+}
+
+/*
+void cLogFile::Write(string message)
+{
+	fprintf(logFile, &quot;%s&quot;, message.c_str());
+//  fputs(message.c_str(),logFile);
+//  *logFile&lt;&lt;message.c_str();
+//	logFile-&gt;flush();
+}
+
+void cLogFile::Write(float message)
+{
+	if( message - int(message) &gt; 0.0 )
+		fprintf(logFile, &quot;%1.2f&quot;, message);
+	else
+		fprintf(logFile, &quot;%1.0f&quot;, message);
+//	*logFile&lt;&lt;message;
+//	logFile-&gt;flush();
+}
+
+void cLogFile::Write(int message)
+{
+//	*logFile&lt;&lt;message;
+//	logFile-&gt;flush();
+}
+*/


Property changes on: branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/LogFile.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/LogFile.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/LogFile.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,29 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_LOGFILE_H
+#define RAI_LOGFILE_H
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+using std::string;
+
+const string RAIDirectory = &quot;AI/RAI/&quot;;
+
+class cLogFile
+{
+public:
+	cLogFile(string sFilename, bool bAppend=true);
+	~cLogFile();
+
+	cLogFile&amp; operator&lt;&lt;(float message);
+	cLogFile&amp; operator&lt;&lt;(string message);
+
+private:
+	string logFileName;
+	FILE *logFile;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/LogFile.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/PowerManager.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/PowerManager.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/PowerManager.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,532 @@
+#include &quot;PowerManager.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;LogFile.h&quot;
+
+UnitInfoPower::UnitInfoPower(int UID, UnitInfo *UI, bool isActive, int listType)
+{
+	unitID = UID;
+	U = UI;
+	active = isActive;
+	importance = 1.0;
+	type = listType;
+}
+
+cPowerManager::cPowerManager(IAICallback* callback, cRAI* global)
+{
+	G=global;
+	l=G-&gt;l;
+	cb=callback;
+
+	*l&lt;&lt;&quot;\n Loading cPowerManager ...&quot;;
+
+	MetalDifference = 0;
+	EnergyDifference = 0;
+	WeaponEnergyNeeded = 0;
+
+	OffEnergyDifference = 0;
+	OnEnergyDifference = 0;
+
+	EtoMNeeded = 0.0;
+	MtoENeeded = 0.0;
+	EtoMIncome = 0.0;
+	MtoEIncome = 0.0;
+	ExMMetalDifference = 0;
+	ExMEnergyDifference = 0;
+
+	EDrainSize = 0;
+	EDrainActive = 0;
+	EtoMSize = 0;
+	EtoMActive = 0;
+	MtoESize = 0;
+	MtoEActive = 0;
+
+	cb-&gt;GetValue(AIVAL_UNIT_LIMIT,&amp;UIPLimit);
+	EDrain = new UnitInfoPower*[UIPLimit];
+	EtoM = new UnitInfoPower*[UIPLimit];
+	MtoE = new UnitInfoPower*[UIPLimit];
+
+	DebugUnitFinished = 0;
+	DebugUnitDestroyed = 0;
+}
+
+cPowerManager::~cPowerManager()
+{
+	if( RAIDEBUGGING )
+	{
+		*l&lt;&lt;&quot;\n cPowerManager Debug:&quot;;
+		*l&lt;&lt;&quot;\n  MetalDifference = &quot;&lt;&lt;MetalDifference;
+		*l&lt;&lt;&quot;\n  EnergyDifference = &quot;&lt;&lt;EnergyDifference;
+		*l&lt;&lt;&quot;\n  WeaponEnergyNeeded = &quot;&lt;&lt;WeaponEnergyNeeded;
+		*l&lt;&lt;&quot;\n  OffEnergyDifference = &quot;&lt;&lt;OffEnergyDifference;
+		*l&lt;&lt;&quot;\n  OnEnergyDifference = &quot;&lt;&lt;OnEnergyDifference;
+		*l&lt;&lt;&quot;\n  ExMMetalDifference = &quot;&lt;&lt;ExMMetalDifference;
+		*l&lt;&lt;&quot;\n  ExMEnergyDifference = &quot;&lt;&lt;ExMEnergyDifference;
+		*l&lt;&lt;&quot;\n  EtoMNeeded = &quot;&lt;&lt;EtoMNeeded;
+		*l&lt;&lt;&quot;\n  EtoMIncome = &quot;&lt;&lt;EtoMIncome;
+		*l&lt;&lt;&quot;\n  MtoEIncome = &quot;&lt;&lt;MtoEIncome;
+		*l&lt;&lt;&quot;\n  MtoENeeded = &quot;&lt;&lt;MtoENeeded;
+		*l&lt;&lt;&quot;\n  EDrain/EtoM/MtoE Size = &quot;&lt;&lt;EDrainSize&lt;&lt;&quot;/&quot;&lt;&lt;EtoMSize&lt;&lt;&quot;/&quot;&lt;&lt;MtoESize;
+		*l&lt;&lt;&quot;\n  Debug-Units: Finished(&quot;&lt;&lt;DebugUnitFinished&lt;&lt;&quot;) - Destroyed(&quot;&lt;&lt;DebugUnitDestroyed&lt;&lt;&quot;) = &quot;&lt;&lt;DebugUnitFinished-DebugUnitDestroyed;
+
+		if( (int)MetalDifference != 0 || (int)EnergyDifference != 0 || (int)WeaponEnergyNeeded != 0
+		 || (int)OffEnergyDifference != 0 || (int)OnEnergyDifference != 0 || (int)ExMMetalDifference != 0 || (int)ExMEnergyDifference != 0
+		 || (int)EtoMNeeded != 0 || (int)EtoMIncome != 0 || (int)MtoEIncome != 0 || (int)MtoENeeded != 0
+		 || EDrainSize != 0 || EtoMSize != 0 || MtoESize != 0 )
+			*l&lt;&lt;&quot;\n  (ERROR)&quot;;
+	}
+
+	// These should be empty at this point
+	delete [] EDrain;
+	delete [] EtoM;
+	delete [] MtoE;
+}
+
+void cPowerManager::UnitFinished(int unit, UnitInfo *U)
+{
+	DebugUnitFinished++;
+	EnergyDifference += U-&gt;ud-&gt;energyMake;
+	MetalDifference += U-&gt;ud-&gt;metalMake;
+	WeaponEnergyNeeded += U-&gt;udr-&gt;WeaponEnergyDifference;
+	if( U-&gt;ud-&gt;canCloak &amp;&amp; EDrainSize &lt; UIPLimit )
+	{
+		if( U-&gt;udr-&gt;CloakMaxEnergyDifference &lt; 0 )
+		{
+			U-&gt;CloakUI = new UnitInfoPower(unit,U,cb-&gt;IsUnitCloaked(unit),0);
+			U-&gt;CloakUI-&gt;importance = 100/-U-&gt;udr-&gt;CloakMaxEnergyDifference;
+			if( U-&gt;ud-&gt;isCommander )
+				U-&gt;CloakUI-&gt;importance *= 3;
+			InsertPI(EDrain,EDrainSize,U-&gt;CloakUI);
+			if( U-&gt;CloakUI-&gt;index &lt; EDrainActive )
+			{
+				EDrainActive++;
+				if( !U-&gt;CloakUI-&gt;active )
+					GiveCloakOrder(unit,U,true);
+				OnEnergyDifference += U-&gt;udr-&gt;CloakMaxEnergyDifference;
+			}
+			else
+			{
+				if( U-&gt;CloakUI-&gt;active )
+					GiveCloakOrder(unit,U,false);
+				OffEnergyDifference += U-&gt;udr-&gt;CloakMaxEnergyDifference;
+			}
+		}
+		else if( !cb-&gt;IsUnitCloaked(unit) ) // 0 cost cloak? always use it
+			GiveCloakOrder(unit);
+	}
+	if( U-&gt;ud-&gt;onoffable )
+	{
+		if( U-&gt;udr-&gt;OnOffEnergyDifference &lt; 0 &amp;&amp; U-&gt;udr-&gt;OnOffMetalDifference &gt; 0 &amp;&amp; U-&gt;udr-&gt;MetalDifference &lt; -U-&gt;udr-&gt;EnergyDifference*G-&gt;UDH-&gt;EnergyToMetalRatio &amp;&amp; EtoMSize &lt; UIPLimit )
+		{	// Metal Maker
+			U-&gt;OnOffUI = new UnitInfoPower(unit,U,cb-&gt;IsUnitActivated(unit),3);
+			U-&gt;OnOffUI-&gt;importance = U-&gt;udr-&gt;OnOffMetalDifference/-U-&gt;udr-&gt;OnOffEnergyDifference;
+			InsertPI(EtoM,EtoMSize,U-&gt;OnOffUI);
+			if( U-&gt;OnOffUI-&gt;index &lt;= EtoMActive )
+			{
+				EtoMActive++;
+				if( !U-&gt;OnOffUI-&gt;active )
+					GiveOnOffOrder(unit,U,true);
+				ExMMetalDifference += U-&gt;udr-&gt;OnOffMetalDifference;
+				ExMEnergyDifference += U-&gt;udr-&gt;OnOffEnergyDifference;
+			}
+			else
+			{
+				if( U-&gt;OnOffUI-&gt;active )
+					GiveOnOffOrder(unit,U,false);
+				EtoMIncome += U-&gt;udr-&gt;OnOffMetalDifference;
+				EtoMNeeded += U-&gt;udr-&gt;OnOffEnergyDifference;
+			}
+		}
+		else if( U-&gt;udr-&gt;OnOffEnergyDifference &gt; 0 &amp;&amp; U-&gt;udr-&gt;OnOffMetalDifference &lt; 0 &amp;&amp; U-&gt;udr-&gt;EnergyDifference*G-&gt;UDH-&gt;EnergyToMetalRatio &lt; -U-&gt;udr-&gt;MetalDifference &amp;&amp; EtoMSize &lt; UIPLimit )
+		{	// Energy Maker
+			U-&gt;OnOffUI = new UnitInfoPower(unit,U,cb-&gt;IsUnitActivated(unit),4);
+			U-&gt;OnOffUI-&gt;importance = U-&gt;udr-&gt;OnOffEnergyDifference/-U-&gt;udr-&gt;OnOffMetalDifference;
+			InsertPI(MtoE,MtoESize,U-&gt;OnOffUI);
+			if( U-&gt;OnOffUI-&gt;index &lt;= MtoEActive )
+			{
+				MtoEActive++;
+				if( !U-&gt;OnOffUI-&gt;active )
+					GiveOnOffOrder(unit,U,true);
+				ExMMetalDifference += U-&gt;udr-&gt;OnOffMetalDifference;
+				ExMEnergyDifference += U-&gt;udr-&gt;OnOffEnergyDifference;
+			}
+			else
+			{
+				if( U-&gt;OnOffUI-&gt;active )
+					GiveOnOffOrder(unit,U,false);
+				MtoEIncome += U-&gt;udr-&gt;OnOffEnergyDifference;
+				MtoENeeded += U-&gt;udr-&gt;OnOffMetalDifference;
+			}
+		}
+		else if( U-&gt;ud-&gt;energyUpkeep &gt; 0 &amp;&amp; EDrainSize &lt; UIPLimit )
+		{	// On/Off units that require energy
+			U-&gt;OnOffUI = new UnitInfoPower(unit,U,cb-&gt;IsUnitActivated(unit),1);
+			U-&gt;OnOffUI-&gt;importance = 100/-U-&gt;udr-&gt;OnOffEnergyDifference;
+			if( U-&gt;ud-&gt;isCommander || U-&gt;ud-&gt;extractsMetal &gt; 0 )
+				U-&gt;OnOffUI-&gt;importance *= 3;
+			InsertPI(EDrain,EDrainSize,U-&gt;OnOffUI);
+			if( U-&gt;OnOffUI-&gt;index &lt;= EDrainActive )
+			{
+				EDrainActive++;
+				if( !U-&gt;OnOffUI-&gt;active )
+					GiveOnOffOrder(unit,U,true);
+				OnEnergyDifference += U-&gt;udr-&gt;OnOffEnergyDifference;
+			}
+			else
+			{
+				if( U-&gt;OnOffUI-&gt;active )
+					GiveOnOffOrder(unit,U,false);
+				OffEnergyDifference += U-&gt;udr-&gt;OnOffEnergyDifference;
+			}
+		}
+		else
+		{	// On/Off units that do not require energy
+			EnergyDifference += U-&gt;udr-&gt;OnOffEnergyDifference;
+			MetalDifference += U-&gt;udr-&gt;OnOffMetalDifference;
+			if( !cb-&gt;IsUnitActivated(unit) ) // solar panals are turned off when given, RAI does not manage their states
+				GiveOnOffOrder(unit);
+		}
+	}
+}
+
+void cPowerManager::UnitDestroyed(int unit, UnitInfo *U)
+{
+	DebugUnitDestroyed++;
+	EnergyDifference -= U-&gt;ud-&gt;energyMake;
+	MetalDifference -= U-&gt;ud-&gt;metalMake;
+	WeaponEnergyNeeded -= U-&gt;udr-&gt;WeaponEnergyDifference;
+
+	if( U-&gt;CloakUI != 0 )
+	{
+		if( U-&gt;CloakUI-&gt;active )
+		{
+			OnEnergyDifference -= U-&gt;udr-&gt;CloakMaxEnergyDifference;
+			EDrainActive--;
+		}
+		else
+			OffEnergyDifference -= U-&gt;udr-&gt;CloakMaxEnergyDifference;
+		RemovePI(EDrain,EDrainSize,U-&gt;CloakUI);
+		delete U-&gt;CloakUI;
+	}
+
+	if( U-&gt;OnOffUI != 0 )
+	{
+		if( U-&gt;OnOffUI-&gt;type == 3 )
+		{
+			if( U-&gt;OnOffUI-&gt;active )
+			{
+				ExMMetalDifference -= U-&gt;udr-&gt;OnOffMetalDifference;
+				ExMEnergyDifference -= U-&gt;udr-&gt;OnOffEnergyDifference;
+				EtoMActive--;
+			}
+			else
+			{
+				EtoMIncome -= U-&gt;udr-&gt;OnOffMetalDifference;
+				EtoMNeeded -= U-&gt;udr-&gt;OnOffEnergyDifference;
+			}
+			RemovePI(EtoM,EtoMSize,U-&gt;OnOffUI);
+		}
+		else if( U-&gt;OnOffUI-&gt;type == 4 )
+		{
+			if( U-&gt;OnOffUI-&gt;active )
+			{
+				ExMMetalDifference -= U-&gt;udr-&gt;OnOffMetalDifference;
+				ExMEnergyDifference -= U-&gt;udr-&gt;OnOffEnergyDifference;
+				MtoEActive--;
+			}
+			else
+			{
+				MtoEIncome -= U-&gt;udr-&gt;OnOffEnergyDifference;
+				MtoENeeded -= U-&gt;udr-&gt;OnOffMetalDifference;
+			}
+			RemovePI(MtoE,MtoESize,U-&gt;OnOffUI);
+		}
+		else if( U-&gt;OnOffUI-&gt;type == 1 )
+		{
+			if( U-&gt;OnOffUI-&gt;active )
+			{
+				OnEnergyDifference -= U-&gt;udr-&gt;OnOffEnergyDifference;
+				EDrainActive--;
+			}
+			else
+				OffEnergyDifference -= U-&gt;udr-&gt;OnOffEnergyDifference;
+			RemovePI(EDrain,EDrainSize,U-&gt;OnOffUI);
+		}
+		delete U-&gt;OnOffUI;
+	}
+	else if( U-&gt;ud-&gt;onoffable )
+	{
+		EnergyDifference -= U-&gt;udr-&gt;OnOffEnergyDifference;
+		MetalDifference -= U-&gt;udr-&gt;OnOffMetalDifference;
+	}
+}
+
+void cPowerManager::Update()
+{
+	sRAIUnitDef* udr;
+	float factor = (FUPDATE_POWER/30.0);
+	float energyDif = cb-&gt;GetEnergyIncome()-cb-&gt;GetEnergyUsage();
+	float metalDif = cb-&gt;GetMetalIncome()-cb-&gt;GetMetalUsage();
+	float energyCurrent = cb-&gt;GetEnergy() + energyDif*2*factor;
+	float metalCurrent = cb-&gt;GetMetal() + metalDif*2*factor;
+	float metalNext,energyNext;
+	bool ConvertEtoM;
+	bool ShiftEtoM = G-&gt;UDH-&gt;EnergyToMetalRatio*metalDif &lt; energyDif;
+	if( EtoMActive &gt; 0 )
+		ConvertEtoM = true;
+	else if( MtoEActive &gt; 0 )
+		ConvertEtoM = false;
+	else
+		ConvertEtoM = ShiftEtoM;
+	float energyLimit = 0.8*cb-&gt;GetEnergyStorage();
+	float metalLimit = 0.8*cb-&gt;GetMetalStorage();
+
+	energyDif -= ExMEnergyDifference;
+	bool ShiftPowerON = energyDif &gt; 0 &amp;&amp; cb-&gt;GetEnergy() &gt; 0;
+//	*l&lt;&lt;&quot;\n ShiftPowerON=&quot;&lt;&lt;ShiftPowerON;
+//	*l&lt;&lt;&quot;\n ShiftEtoM=&quot;&lt;&lt;ShiftEtoM;
+//	*l&lt;&lt;&quot;\n energy=&quot;&lt;&lt;cb-&gt;GetEnergyIncome()&lt;&lt;&quot;-&quot;&lt;&lt;cb-&gt;GetEnergyUsage()&lt;&lt;&quot;-&quot;&lt;&lt;ExMEnergyDifference&lt;&lt;&quot;=&quot;&lt;&lt;energyDif;
+//	*l&lt;&lt;&quot;\n energyCurrent = &quot;&lt;&lt;energyCurrent&lt;&lt;&quot; of &quot;&lt;&lt;energyLimit;
+//	*l&lt;&lt;&quot;\n cb-&gt;GetEnergy()=&quot;&lt;&lt;cb-&gt;GetEnergy();
+//	*l&lt;&lt;&quot;\n metalDif=&quot;&lt;&lt;metalDif;
+//	*l&lt;&lt;&quot;\n metalCurrent = &quot;&lt;&lt;metalCurrent&lt;&lt;&quot; of &quot;&lt;&lt;metalLimit;
+	if( ShiftPowerON )
+	{
+//*l&lt;&lt;&quot; (P-ON)=&quot;&lt;&lt;EDrainActive&lt;&lt;&quot; of &quot;&lt;&lt;EDrainSize&lt;&lt;&quot;:&quot;;
+		while( EDrainActive &lt; EDrainSize &amp;&amp; energyCurrent &gt; 0 )
+		{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;EDrainActive;
+			udr = EDrain[EDrainActive]-&gt;U-&gt;udr;
+			if( EDrain[EDrainActive]-&gt;type == 0 )
+				energyNext = energyCurrent + udr-&gt;CloakMaxEnergyDifference*2*factor;
+			else
+				energyNext = energyCurrent + udr-&gt;OnOffEnergyDifference*2*factor;
+			if( energyNext &gt; 0 )
+			{	// Turn ON
+				if( EDrain[EDrainActive]-&gt;type == 0 )
+				{
+					GiveCloakOrder(EDrain[EDrainActive]-&gt;unitID,EDrain[EDrainActive]-&gt;U,true);
+					OffEnergyDifference -= udr-&gt;CloakMaxEnergyDifference;
+					OnEnergyDifference += udr-&gt;CloakMaxEnergyDifference;
+					energyCurrent += udr-&gt;CloakMaxEnergyDifference*factor;
+				}
+				else
+				{
+					GiveOnOffOrder(EDrain[EDrainActive]-&gt;unitID,EDrain[EDrainActive]-&gt;U,true);
+					OffEnergyDifference -= udr-&gt;OnOffEnergyDifference;
+					OnEnergyDifference += udr-&gt;OnOffEnergyDifference;
+					energyCurrent += udr-&gt;OnOffEnergyDifference*factor;
+					metalCurrent += udr-&gt;OnOffMetalDifference*factor;
+				}
+				EDrainActive++;
+			}
+			else
+				break;
+		}
+	}
+	else
+	{
+//*l&lt;&lt;&quot; (P-OFF)=&quot;&lt;&lt;EDrainActive&lt;&lt;&quot; of &quot;&lt;&lt;EDrainSize&lt;&lt;&quot;:&quot;;
+		while( EDrainActive &gt; 0 &amp;&amp; energyCurrent &lt; 0 )
+		{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;EDrainActive;
+			udr = EDrain[EDrainActive-1]-&gt;U-&gt;udr;
+			if( EDrain[EDrainActive-1]-&gt;type != 0 || udr-&gt;OnOffMetalDifference &lt;= 0 || metalCurrent-udr-&gt;OnOffMetalDifference*factor &gt; 0.5*cb-&gt;GetMetalStorage() )
+			{	// Turn OFF
+				EDrainActive--;
+				if( EDrain[EDrainActive]-&gt;type == 0 )
+				{
+					GiveCloakOrder(EDrain[EDrainActive]-&gt;unitID,EDrain[EDrainActive]-&gt;U,false);
+					OffEnergyDifference += udr-&gt;CloakMaxEnergyDifference;
+					OnEnergyDifference -= udr-&gt;CloakMaxEnergyDifference;
+					energyCurrent -= udr-&gt;CloakMaxEnergyDifference*factor;
+				}
+				else
+				{
+					GiveOnOffOrder(EDrain[EDrainActive]-&gt;unitID,EDrain[EDrainActive]-&gt;U,false);
+					OffEnergyDifference += udr-&gt;OnOffEnergyDifference;
+					OnEnergyDifference -= udr-&gt;OnOffEnergyDifference;
+					energyCurrent -= udr-&gt;OnOffEnergyDifference*factor;
+					metalCurrent -= udr-&gt;OnOffMetalDifference*factor;
+				}
+			}
+			else
+				break;
+		}
+	}
+	if( ConvertEtoM )
+	{
+		if( ShiftEtoM )
+		{
+//*l&lt;&lt;&quot; (EM-ON)=&quot;&lt;&lt;EtoMActive&lt;&lt;&quot; of &quot;&lt;&lt;EtoMSize&lt;&lt;&quot;:&quot;;
+			while( EtoMActive &lt; EtoMSize &amp;&amp; energyCurrent &gt; energyLimit )
+			{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;EtoMActive;
+				udr = EtoM[EtoMActive]-&gt;U-&gt;udr;
+				energyNext = energyCurrent + udr-&gt;OnOffEnergyDifference*factor;
+				if( energyNext &gt; energyLimit )
+					energyNext = energyLimit;
+				metalNext = metalCurrent + udr-&gt;OnOffMetalDifference*factor;
+				if( metalNext &gt; metalLimit )
+					metalNext = metalLimit;
+//*l&lt;&lt;&quot;\n  energyNext=&quot;&lt;&lt;energyNext;
+//*l&lt;&lt;&quot;\n  metalNext=&quot;&lt;&lt;metalNext;
+				if( G-&gt;UDH-&gt;EnergyToMetalRatio*metalNext+energyNext &gt; G-&gt;UDH-&gt;EnergyToMetalRatio*metalCurrent+energyLimit )
+				{	// Turn ON
+					GiveOnOffOrder(EtoM[EtoMActive]-&gt;unitID,EtoM[EtoMActive]-&gt;U,true);
+					EtoMActive++;
+
+					EtoMIncome -= udr-&gt;OnOffMetalDifference;
+					EtoMNeeded -= udr-&gt;OnOffEnergyDifference;
+					ExMMetalDifference += udr-&gt;OnOffMetalDifference;
+					ExMEnergyDifference += udr-&gt;OnOffEnergyDifference;
+
+					metalCurrent += udr-&gt;OnOffMetalDifference*factor;
+					energyCurrent += udr-&gt;OnOffEnergyDifference*factor;
+				}
+				else
+					break;
+			}
+		}
+		else
+		{
+//*l&lt;&lt;&quot; (EM-OFF)=&quot;&lt;&lt;EtoMActive&lt;&lt;&quot; of &quot;&lt;&lt;EtoMSize&lt;&lt;&quot;:&quot;;
+			while( EtoMActive &gt; 0 &amp;&amp; energyCurrent &lt; 0.1*cb-&gt;GetEnergyStorage() )
+			{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;EtoMActive;
+				udr = EtoM[EtoMActive-1]-&gt;U-&gt;udr;
+				energyNext = energyCurrent - udr-&gt;OnOffEnergyDifference*factor;
+				if( energyNext &gt; energyLimit )
+					energyNext = energyLimit;
+				metalNext = metalCurrent - udr-&gt;OnOffMetalDifference*factor;
+				if( metalNext &gt; metalLimit )
+					metalNext = metalLimit;
+				if( G-&gt;UDH-&gt;EnergyToMetalRatio*metalNext+energyNext &gt; G-&gt;UDH-&gt;EnergyToMetalRatio*metalCurrent+energyCurrent )
+				{	// Turn OFF
+					EtoMActive--;
+					GiveOnOffOrder(EtoM[EtoMActive]-&gt;unitID,EtoM[EtoMActive]-&gt;U,false);
+
+					EtoMIncome += udr-&gt;OnOffMetalDifference;
+					EtoMNeeded += udr-&gt;OnOffEnergyDifference;
+					ExMMetalDifference -= udr-&gt;OnOffMetalDifference;
+					ExMEnergyDifference -= udr-&gt;OnOffEnergyDifference;
+
+					metalCurrent -= udr-&gt;OnOffMetalDifference*factor;
+					energyCurrent -= udr-&gt;OnOffEnergyDifference*factor;
+				}
+				else
+					break;
+			}
+		}
+	}
+	else
+	{
+		if( !ShiftEtoM )
+		{
+//*l&lt;&lt;&quot; (ME-ON)=&quot;&lt;&lt;MtoEActive&lt;&lt;&quot; of &quot;&lt;&lt;MtoESize&lt;&lt;&quot;:&quot;;
+			while( MtoEActive &lt; MtoESize &amp;&amp; metalCurrent &gt; metalLimit )
+			{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;MtoEActive;
+				udr = MtoE[MtoEActive]-&gt;U-&gt;udr;
+				energyNext = energyCurrent + udr-&gt;OnOffEnergyDifference*factor;
+				if( energyNext &gt; energyLimit )
+					energyNext = energyLimit;
+				metalNext = metalCurrent + udr-&gt;OnOffMetalDifference*factor;
+				if( metalNext &gt; metalLimit )
+					metalNext = metalLimit;
+//*l&lt;&lt;&quot;\n  energyNext=&quot;&lt;&lt;energyNext;
+//*l&lt;&lt;&quot;\n  metalNext=&quot;&lt;&lt;metalNext;
+				if( G-&gt;UDH-&gt;EnergyToMetalRatio*metalNext+energyNext &gt; G-&gt;UDH-&gt;EnergyToMetalRatio*metalLimit+energyCurrent )
+				{	// Turn ON
+					GiveOnOffOrder(MtoE[MtoEActive]-&gt;unitID,MtoE[MtoEActive]-&gt;U,true);
+					MtoEActive++;
+
+					MtoEIncome -= udr-&gt;OnOffEnergyDifference;
+					MtoENeeded -= udr-&gt;OnOffMetalDifference;
+					ExMMetalDifference += udr-&gt;OnOffMetalDifference;
+					ExMEnergyDifference += udr-&gt;OnOffEnergyDifference;
+
+					metalCurrent += udr-&gt;OnOffMetalDifference*factor;
+					energyCurrent += udr-&gt;OnOffEnergyDifference*factor;
+				}
+				else
+					break;
+			}
+		}
+		else
+		{
+//*l&lt;&lt;&quot; (ME-OFF)=&quot;&lt;&lt;MtoEActive&lt;&lt;&quot; of &quot;&lt;&lt;MtoESize&lt;&lt;&quot;:&quot;;
+			while( MtoEActive &gt; 0 &amp;&amp; metalCurrent &lt; 0.1*cb-&gt;GetMetalStorage() )
+			{
+//*l&lt;&lt;&quot; &quot;&lt;&lt;MtoEActive;
+				udr = MtoE[MtoEActive-1]-&gt;U-&gt;udr;
+				energyNext = energyCurrent - udr-&gt;OnOffEnergyDifference*factor;
+				if( energyNext &gt; energyLimit )
+					energyNext = energyLimit;
+				metalNext = metalCurrent - udr-&gt;OnOffMetalDifference*factor;
+				if( metalNext &gt; metalLimit )
+					metalNext = metalLimit;
+				if( G-&gt;UDH-&gt;EnergyToMetalRatio*metalNext+energyNext &gt; G-&gt;UDH-&gt;EnergyToMetalRatio*metalCurrent+energyCurrent )
+				{	// Turn OFF
+					MtoEActive--;
+					GiveOnOffOrder(MtoE[MtoEActive]-&gt;unitID,MtoE[MtoEActive]-&gt;U,false);
+
+					MtoEIncome += udr-&gt;OnOffEnergyDifference;
+					MtoENeeded += udr-&gt;OnOffMetalDifference;
+					ExMMetalDifference -= udr-&gt;OnOffMetalDifference;
+					ExMEnergyDifference -= udr-&gt;OnOffEnergyDifference;
+
+					metalCurrent -= udr-&gt;OnOffMetalDifference*factor;
+					energyCurrent -= udr-&gt;OnOffEnergyDifference*factor;
+				}
+				else
+					break;
+			}
+		}
+	}
+}
+
+void cPowerManager::InsertPI(UnitInfoPower **PIA, int &amp;PIASize, UnitInfoPower *P)
+{
+	for(P-&gt;index = PIASize; P-&gt;index&gt;0; P-&gt;index-- )
+		if( P-&gt;importance &gt; PIA[P-&gt;index-1]-&gt;importance )
+		{
+			PIA[P-&gt;index] = PIA[P-&gt;index-1];
+			PIA[P-&gt;index]-&gt;index = P-&gt;index;
+		}
+		else
+			break;
+
+	PIA[P-&gt;index] = P;
+	PIASize++;
+}
+
+void cPowerManager::RemovePI(UnitInfoPower **PIA, int &amp;PIASize, UnitInfoPower *P)
+{
+	for(int i=P-&gt;index; i&lt;PIASize-1; i++ )
+	{
+		PIA[i] = PIA[i+1];
+		PIA[i]-&gt;index = i;
+	}
+	PIASize--;
+}
+
+void cPowerManager::GiveCloakOrder(const int &amp;unitID, UnitInfo *U, bool state )
+{
+	if( U != 0 )
+		U-&gt;CloakUI-&gt;active = state;
+	Command c;
+	c.id=CMD_CLOAK;
+	c.params.push_back(state);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+}
+
+void cPowerManager::GiveOnOffOrder(const int &amp;unitID, UnitInfo *U, bool state )
+{
+	if( U != 0 )
+		U-&gt;OnOffUI-&gt;active = state;
+	Command c;
+	c.id=CMD_ONOFF;
+	c.params.push_back(state);
+	cb-&gt;GiveOrder(unitID, &amp;c);
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/PowerManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/PowerManager.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/PowerManager.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/PowerManager.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,80 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_POWERMANAGER_H
+#define RAI_POWERMANAGER_H
+
+struct UnitInfoPower;
+class cPowerManager;
+
+//#include &quot;LogFile.h&quot;
+#include &quot;RAI.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+
+struct UnitInfoPower
+{
+	UnitInfoPower(int UID, UnitInfo *UI, bool isActive, int listType);
+
+	int unitID;
+	UnitInfo *U;
+	bool active;		// used to keep track of the main class variables
+	float importance;	// determines array order, negative for reverse converters
+	int index;			// within its array
+	int type;			// 0=EDrain(cloak),1=EDrain(on/off),2=MDrain(unused),3=EtoM,4=MtoE
+};
+
+class cPowerManager
+{
+public:
+	cPowerManager(IAICallback *callback, cRAI* global);
+	~cPowerManager();
+
+	void UnitFinished(int unit, UnitInfo *U);	// called by all units
+	void UnitDestroyed(int unit, UnitInfo *U);	// called by all units
+	void Update();
+
+	// these variables are used to aid the build class in it's decisions
+	double EnergyDifference;	// Energy Income &amp; Usage of all units that can not be turned off or are not managed by this class
+	double MetalDifference;		// Metal Income &amp; Usage of all units that can not be turned off or are not managed by this class
+	double WeaponEnergyNeeded;	// - value, Amount of energy drain from all unit weapons passed through this class, per 30 frames
+
+	double OffEnergyDifference;	// - value, EnergyUsage of off units &amp; uncloaked units, excluding ExM
+	double OnEnergyDifference;	// - value, EnergyUsage of on units &amp; cloaked units, excluding ExM
+
+	double ExMMetalDifference;	// Metal Income/Usage of all turned on ExM
+	double ExMEnergyDifference;	// Energy Income/Usage of all turned on ExM
+	double EtoMIncome;			// + value, Amount of [Metal/Energy] that would be produced if all [Energy/Metal] to [Metal/Energy] converters were on, does not include units already on
+	double EtoMNeeded;			// - value, [Energy/Metal]-Usage if all [Energy/Metal] to [Metal/Energy] converters were turned on, does not include units already on
+	double MtoEIncome;			// + value
+	double MtoENeeded;			// - value
+
+private:
+	void InsertPI(UnitInfoPower **PIA, int &amp;PIASize, UnitInfoPower *P);
+	void RemovePI(UnitInfoPower **PIA, int &amp;PIASize, UnitInfoPower *P);
+	void GiveCloakOrder(const int &amp;unitID, UnitInfo *U = 0, bool state = true );
+	void GiveOnOffOrder(const int &amp;unitID, UnitInfo *U = 0, bool state = true );
+
+	cLogFile *l;
+	IAICallback *cb;
+	cRAI *G;
+
+	UnitInfoPower **EDrain;
+	int EDrainSize;	// the number of on/off units managed by this class (not including ExM)
+	int EDrainActive;
+	UnitInfoPower **EtoM;
+	int EtoMSize;	// the number of metal makers
+	int EtoMActive;
+	UnitInfoPower **MtoE;
+	int MtoESize;	// the number of energy makers
+	int MtoEActive;
+
+	int UIPLimit;	// unit limit, the max size of the lists above
+	int DebugUnitFinished;
+	int DebugUnitDestroyed;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/PowerManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/RAI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/RAI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/RAI.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,1113 @@
+#include &quot;RAI.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+//#include &quot;ExternalAI/IAICheats.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+//#include &lt;vector&gt;
+//#include &lt;iostream&gt;
+#include &lt;stdio.h&gt;
+//#include &lt;direct.h&gt;	// mkdir function (windows)
+//#include &lt;sys/stat.h&gt;	// mkdir function (linux)
+#include &lt;time.h&gt;		// time(NULL)
+//#include &quot;KrogsMetalClass-v0.4/MetalMap.h&quot;
+
+
+namespace std
+{
+	void _xlen(){};
+}
+
+UnitInfo::UnitInfo(sRAIUnitDef* rUnitDef)
+{
+	udr=rUnitDef;
+	ud=rUnitDef-&gt;ud;
+
+	AIDisabled=false;
+	humanCommand=false;
+	unitBeingBuilt=true;
+	inCombat=false;
+	lastUnitIdleFrame=0;
+	lastUnitDamagedFrame=0;
+	enemyID=-1;
+	area=0;
+	E=0;
+	enemyEff=0;
+	udrBL=0;
+	RS=0;
+	BuildQ=0;
+	CloakUI=0;
+	OnOffUI=0;
+	SWeaponUI=0;
+	group=0;
+	UE = 0;
+}
+
+EnemyInfo::EnemyInfo()
+{
+	inLOS=false;
+	inRadar=false;
+	baseThreatFrame=-1;
+	baseThreatID=-1;
+	ud=0;
+	udr=0;
+	RS=0;
+	posLocked=false;
+}
+
+cRAI::cRAI()
+{
+	DebugEnemyEnterLOS=0;
+	DebugEnemyLeaveLOS=0;
+	DebugEnemyEnterRadar=0;
+	DebugEnemyLeaveRadar=0;
+	DebugEnemyDestroyedLOS=0;
+	DebugEnemyDestroyedRadar=0;
+	DebugEnemyEnterLOSError=0;
+	DebugEnemyLeaveLOSError=0;
+	DebugEnemyEnterRadarError=0;
+	DebugEnemyLeaveRadarError=0;
+	eventSize = 0;
+}
+
+cRAI::~cRAI()
+{
+	*l&lt;&lt;&quot;\n\nShutting Down ...&quot;;
+	if( RAIDEBUGGING )
+	{
+		*l&lt;&lt;&quot;\n cRAI Debug:&quot;;
+		*l&lt;&lt;&quot;\n  clearing Units size=&quot;&lt;&lt;int(Units.size())&lt;&lt;&quot;: &quot;;
+		*l&lt;&lt;&quot;\n  clearing Enemies size=&quot;&lt;&lt;Enemies.size()&lt;&lt;&quot;: &quot;;
+	}
+
+	while( int(Units.size()) &gt; 0 )
+		UnitDestroyed(Units.begin()-&gt;first,-1);
+	while( int(Enemies.size()) &gt; 0 )
+		EnemyDestroyed(Enemies.begin()-&gt;first,-1);
+
+	if( RAIDEBUGGING )
+	{
+		int ERadar,ELOS;
+		*l&lt;&lt;&quot;\n Enemys (Enter LOS - Errors)                        = &quot;&lt;&lt;DebugEnemyEnterLOS&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyEnterLOS+DebugEnemyEnterLOSError&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyEnterLOSError;
+		*l&lt;&lt;&quot;\n Enemys (Leave LOS + Destroyed in LOS - Errors)     = &quot;&lt;&lt;DebugEnemyLeaveLOS+DebugEnemyDestroyedLOS&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyLeaveLOS+DebugEnemyLeaveLOSError&lt;&lt;&quot;+&quot;&lt;&lt;DebugEnemyDestroyedLOS&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyLeaveLOSError;
+		*l&lt;&lt;&quot;\n Enemies Remaining in LOS                           = &quot;&lt;&lt;(ELOS=DebugEnemyEnterLOS-DebugEnemyLeaveLOS-DebugEnemyDestroyedLOS);
+		*l&lt;&lt;&quot;\n Enemys (Enter Radar - Errors)                      = &quot;&lt;&lt;DebugEnemyEnterRadar&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyEnterRadar+DebugEnemyEnterRadarError&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyEnterRadarError;
+		*l&lt;&lt;&quot;\n Enemys (Leave Radar + Destroyed in Radar - Errors) = &quot;&lt;&lt;DebugEnemyLeaveRadar+DebugEnemyDestroyedRadar&lt;&lt;&quot; = &quot;&lt;&lt;DebugEnemyLeaveRadar+DebugEnemyLeaveRadarError&lt;&lt;&quot;+&quot;&lt;&lt;DebugEnemyDestroyedRadar&lt;&lt;&quot;-&quot;&lt;&lt;DebugEnemyLeaveRadarError;
+		*l&lt;&lt;&quot;\n Enemies Remaining in Radar                         = &quot;&lt;&lt;(ERadar=DebugEnemyEnterRadar-DebugEnemyLeaveRadar-DebugEnemyDestroyedRadar);
+		*l&lt;&lt;&quot;\n Enemies Remaining                                  = &quot;&lt;&lt;int(Enemies.size());
+		*l&lt;&lt;&quot;\n Units Remaining                                    = &quot;&lt;&lt;UM-&gt;GroupSize;
+		*l&lt;&lt;&quot;\n Groups Remaining                                   = &quot;&lt;&lt;UM-&gt;GroupSize;
+		if( UM-&gt;GroupSize != 0 || ELOS != 0 || ERadar != 0 )
+			*l&lt;&lt;&quot;\n  (ERROR)&quot;;
+	}
+
+	delete UM;
+	delete B;
+	delete SWM;
+	delete CM;
+	delete UDH;
+
+	RAIs--;
+	if( RAIs == 0 )
+	{
+		*l&lt;&lt;&quot;\n Global RAI Shutting Down&quot;;
+//		double closingTimer = clock();
+		delete RM;
+		RM = 0;
+//		*l&lt;&lt;&quot;\n Resource-Map Closing Time: &quot;&lt;&lt;(clock()-closingTimer)/(double)CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+		delete TM;
+		TM = 0;
+		*l&lt;&lt;&quot;\n Global RAI Shutdown Complete.&quot;;
+	}
+
+	*l&lt;&lt;&quot;\nShutdown Complete.&quot;;
+	delete l;
+}
+
+void cRAI::InitAI(IGlobalAICallback* callback, int team)
+{
+	cb = callback-&gt;GetAICallback();
+	if( GRMap == 0 )
+		ClearLogFiles();
+	char c[2];
+	sprintf(c, &quot;%i&quot;, cb-&gt;GetMyTeam());
+	l = new cLogFile(&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;,false);
+
+/*	string test = (char*)cb-&gt;GetMyTeam(); // Crashes Spring?  Spring-Version(v0.76b1)
+	*l&lt;&lt;&quot;cb-&gt;GetMyTeam()=&quot;&lt;&lt;test&lt;&lt;&quot;\n&quot;;
+*/
+	if( GRMap == 0 )
+	{
+		ClearLogFiles();
+		*l&lt;&lt;&quot;Loading Global RAI...&quot;;
+		*l&lt;&lt;&quot;\n Mod = &quot;&lt;&lt;cb-&gt;GetModName();
+		*l&lt;&lt;&quot;\n Map = &quot;&lt;&lt;cb-&gt;GetMapName();
+		int seed = time(NULL);
+		srand(seed);
+		RAIs=0;
+		double loadingTimer = clock();
+		GTMap = new GlobalTerrainMap(cb,l);
+		*l&lt;&lt;&quot;\n  Terrain-Map Loading Time: &quot;&lt;&lt;(clock()-loadingTimer)/(double)CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+		loadingTimer = clock();
+		GRMap = new GlobalResourceMap(cb,l,GTMap);
+		*l&lt;&lt;&quot;\n  Resource-Map Loading Time: &quot;&lt;&lt;(clock()-loadingTimer)/(double)CLOCKS_PER_SEC&lt;&lt;&quot; seconds\n&quot;;
+/*
+		loadingTimer = clock();
+		CMetalMap* KMM;
+		KMM = new CMetalMap(cb);
+		KMM-&gt;Init();
+		*l&lt;&lt;&quot;  KAI Metal-Map Loading Time: &quot;&lt;&lt;(clock()-loadingTimer)/(double)CLOCKS_PER_SEC&lt;&lt;&quot; seconds&quot;;
+		*l&lt;&lt;&quot;\n   KAI Metal-Sites Found: &quot;&lt;&lt;KMM-&gt;NumSpotsFound;
+		delete KMM;
+*/
+		*l&lt;&lt;&quot;\nGlobal RAI Loading Complete.\n\n&quot;;
+	}
+	RM = GRMap;
+	TM = GTMap;
+	RAIs++;
+
+	*l&lt;&lt;&quot;Loading ...&quot;;
+	*l&lt;&lt;&quot;\n Team = &quot;&lt;&lt;cb-&gt;GetMyTeam();
+	*l&lt;&lt;&quot;\n Ally Team = &quot;&lt;&lt;cb-&gt;GetMyAllyTeam();
+
+	*l&lt;&lt;&quot;\nLoading cRAIUnitDefHandler ...&quot;;
+	UDH = new cRAIUnitDefHandler(cb,RM,TM,l);
+
+	UM = new cUnitManager(cb,this);
+	B = new cBuilder(cb,this);
+	UpdateEventAdd(3,cb-&gt;GetCurrentFrame()-1);
+	SWM = new cSWeaponManager(cb,this);
+	CM = new cCombatManager(cb,this);
+	*l&lt;&lt;&quot;\nLoading Complete.\n&quot;;
+/*
+	if( cb-&gt;GetUnitDef(&quot;arm_retaliator&quot;) != 0 ) // XTA Cheat Nuke Test
+	{
+		IAICheats* cheat=callback-&gt;GetCheatInterface();
+		float3 pos =*cb-&gt;GetStartPos();
+		float3 pos2 =*cb-&gt;GetStartPos();
+		float3 pos3 =*cb-&gt;GetStartPos();
+		if( pos.x &lt; 8*cb-&gt;GetMapWidth() - pos.x )
+		{
+			pos.x = 1;
+			pos2.x = 200;
+			pos3.x = 1;
+		}
+		else
+		{
+			pos.x = 8*cb-&gt;GetMapWidth();
+			pos2.x = pos.x - 200;
+			pos3.x = pos.x;
+		}
+		if( pos.z &lt; 8*cb-&gt;GetMapHeight() - pos.z )
+		{
+			pos.z = 1;
+			pos2.z = 1;
+			pos3.z = 200;
+		}
+		else
+		{
+			pos.z = 8*cb-&gt;GetMapHeight();
+			pos2.z = pos.z;
+			pos3.z = pos.z - 200;
+		}
+
+		pos = cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_retaliator&quot;),pos,1500,0);
+		cheat-&gt;CreateUnit(&quot;arm_retaliator&quot;,pos);
+		cheat-&gt;CreateUnit(&quot;arm_moho_metal_maker&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_moho_metal_maker&quot;),pos,1500,3));
+		cheat-&gt;CreateUnit(&quot;arm_fusion_reactor&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_fusion_reactor&quot;),pos,1500,3));
+		cheat-&gt;CreateUnit(&quot;arm_energy_storage&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_energy_storage&quot;),pos,1500,3));
+		cheat-&gt;CreateUnit(&quot;arm_annihilator&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_annihilator&quot;),pos,1500,10));
+		cheat-&gt;CreateUnit(&quot;arm_annihilator&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_annihilator&quot;),pos,1500,10));
+		cheat-&gt;CreateUnit(&quot;arm_annihilator&quot;,cb-&gt;ClosestBuildSite(cb-&gt;GetUnitDef(&quot;arm_annihilator&quot;),pos,1500,10));
+	}
+*/
+}
+
+void cRAI::UnitCreated(int unit)
+{
+	const UnitDef* ud=cb-&gt;GetUnitDef(unit);
+	if( RAIDEBUGGING ) { *l&lt;&lt;&quot;\nUnitCreated(&quot;&lt;&lt;unit; *l&lt;&lt;&quot;)[&quot;+ud-&gt;humanName+&quot;]&quot;; }
+	Units.insert(iuPair(unit,UnitInfo(&amp;UDH-&gt;UDR.find(ud-&gt;id)-&gt;second)));
+	UnitInfo* U = &amp;Units.find(unit)-&gt;second;
+	float3 position = cb-&gt;GetUnitPos(unit);
+	U-&gt;area = GetCurrentMapArea(U-&gt;udr,position);
+
+	if( ud-&gt;speed == 0 )
+	{
+		for(map&lt;int,UnitInfo*&gt;::iterator i=UImmobile.begin(); i!=UImmobile.end(); i++ )
+		{
+			if( U-&gt;udr-&gt;WeaponGuardRange &gt; 0 &amp;&amp; i-&gt;second-&gt;udr-&gt;WeaponGuardRange == 0 &amp;&amp; position.distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; U-&gt;udr-&gt;WeaponGuardRange )
+			{
+				U-&gt;UDefending.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				i-&gt;second-&gt;UDefences.insert(cRAI::iupPair(unit,U));
+			}
+			else if( U-&gt;udr-&gt;WeaponGuardRange == 0 &amp;&amp; i-&gt;second-&gt;udr-&gt;WeaponGuardRange &gt; 0 &amp;&amp; position.distance2D(cb-&gt;GetUnitPos(i-&gt;first)) &lt; i-&gt;second-&gt;udr-&gt;WeaponGuardRange )
+			{
+				U-&gt;UDefences.insert(cRAI::iupPair(i-&gt;first,i-&gt;second));
+				i-&gt;second-&gt;UDefending.insert(cRAI::iupPair(unit,U));
+			}
+		}
+		UImmobile.insert(iupPair(unit,U));
+	}
+	else
+		UMobile.insert(iupPair(unit,U));
+
+	B-&gt;UnitCreated(unit,U);
+	B-&gt;BP-&gt;UResourceCreated(unit,U);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::UnitFinished(int unit)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nUnitFinished(&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;;
+	if( Units.find(unit) == Units.end() ) // Occurs if a player canceled a build order with more than one quaried and something still finished
+		UnitCreated(unit);
+
+	UnitInfo* U = &amp;Units.find(unit)-&gt;second;
+	U-&gt;unitBeingBuilt = false;
+	if( U-&gt;AIDisabled )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+
+	B-&gt;UnitFinished(unit,U);
+	if( U-&gt;AIDisabled )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+	B-&gt;PM-&gt;UnitFinished(unit,U);
+	SWM-&gt;UnitFinished(unit,U-&gt;udr);
+	UM-&gt;UnitFinished(unit,U);
+	if( U-&gt;ud-&gt;highTrajectoryType == 2 &amp;&amp; rand()%4 == 0 )
+	{	// Nothing too meanful, just a degree of randomness
+		Command c;
+		c.id = CMD_TRAJECTORY;
+		c.params.push_back(1);
+		cb-&gt;GiveOrder(unit,&amp;c);
+	}
+	if( U-&gt;ud-&gt;speed == 0 )
+		UnitIdle(unit);
+		
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::UnitDestroyed(int unit,int attacker)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nUnitDestroyed(&quot;&lt;&lt;unit&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;)&quot;;
+	if( Units.find(unit) == Units.end() ) // Occurs if a player canceled a build order with more than one quaried and something was still being worked on
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+	if( U-&gt;UE != 0 )
+		UpdateEventRemove(U-&gt;UE);
+	if( !U-&gt;AIDisabled )
+	{
+		B-&gt;UnitDestroyed(unit,U);
+		if( !U-&gt;unitBeingBuilt )
+		{
+			B-&gt;PM-&gt;UnitDestroyed(unit,U);
+			SWM-&gt;UnitDestroyed(unit);
+			UM-&gt;UnitDestroyed(unit,U);
+		}
+	}
+	B-&gt;BP-&gt;UResourceDestroyed(unit,U);
+	if( U-&gt;ud-&gt;speed == 0 )
+	{
+		for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UDefending.begin(); i!=U-&gt;UDefending.end(); i++ )
+			i-&gt;second-&gt;UDefences.erase(unit);
+		for(map&lt;int,UnitInfo*&gt;::iterator i=U-&gt;UDefences.begin(); i!=U-&gt;UDefences.end(); i++ )
+			i-&gt;second-&gt;UDefending.erase(unit);
+		UImmobile.erase(unit);
+	}
+	else
+		UMobile.erase(unit);
+	Units.erase(unit);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::EnemyEnterLOS(int enemy)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nEnemyEnterLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( cb-&gt;GetUnitHealth(enemy) &lt;= 0 ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		DebugEnemyEnterLOSError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyEnterLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;): enemy is either dead or not in LOS&quot;;
+		return;
+	}
+	DebugEnemyEnterLOS++;
+	if( Enemies.find(enemy) == Enemies.end() )
+		Enemies.insert(iePair(enemy,EnemyInfo()));
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	E-&gt;inLOS=true;
+	E-&gt;ud=cb-&gt;GetUnitDef(enemy);
+	E-&gt;udr=&amp;UDH-&gt;UDR.find(E-&gt;ud-&gt;id)-&gt;second;
+	if( E-&gt;ud-&gt;speed == 0 )
+	{
+		E-&gt;position = cb-&gt;GetUnitPos(enemy);
+		E-&gt;posLocked = true;
+	}
+	else if( E-&gt;posLocked )
+	{	// just in case the id is being reused
+		E-&gt;posLocked = false;
+	}
+
+	UM-&gt;EnemyEnterLOS(enemy,E);
+	B-&gt;BP-&gt;EResourceEnterLOS(enemy,E);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::EnemyLeaveLOS(int enemy)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nEnemyLeaveLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( Enemies.find(enemy) == Enemies.end() ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		DebugEnemyLeaveLOSError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;): unknown unit id&quot;;
+		return;
+	}
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	if( !E-&gt;inLOS ) // Work Around:  Spring-Version(v0.76b1)
+	{
+		DebugEnemyLeaveLOSError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveLOS(&quot;&lt;&lt;enemy&lt;&lt;&quot;): not in LOS&quot;;
+		return;
+	}
+
+	DebugEnemyLeaveLOS++;
+	E-&gt;inLOS=false;
+	if( !E-&gt;inRadar )
+	{
+		if( !E-&gt;posLocked )
+			E-&gt;position = cb-&gt;GetUnitPos(enemy);
+		if( !TM-&gt;IsSectorValid(TM-&gt;GetSectorIndex(E-&gt;position)) )
+			EnemyRemove(enemy,E);
+	}
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::EnemyEnterRadar(int enemy)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nEnemyEnterRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( cb-&gt;GetUnitPos(enemy).x &lt;= 0 &amp;&amp; cb-&gt;GetUnitPos(enemy).y &lt;= 0 &amp;&amp; cb-&gt;GetUnitPos(enemy).z &lt;= 0 ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		DebugEnemyEnterRadarError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyEnterRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;): enemy position is invalid&quot;;
+		return;
+	}
+	DebugEnemyEnterRadar++;
+	if( Enemies.find(enemy) == Enemies.end() )
+		Enemies.insert(iePair(enemy,EnemyInfo()));
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	E-&gt;inRadar=true;
+	UM-&gt;EnemyEnterRadar(enemy,E);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::EnemyLeaveRadar(int enemy)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nEnemyLeaveRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;)&quot;;
+	if( Enemies.find(enemy) == Enemies.end() ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		DebugEnemyLeaveRadarError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;): unknown unit id&quot;;
+		return;
+	}
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	if( !E-&gt;inRadar ) // Work Around:  Spring-Version(v0.76b1)
+	{
+		DebugEnemyLeaveRadarError++;
+		*l&lt;&lt;&quot;\nWARNING: EnemyLeaveRadar(&quot;&lt;&lt;enemy&lt;&lt;&quot;): not in radar&quot;;
+		return;
+	}
+
+	DebugEnemyLeaveRadar++;
+	E-&gt;inRadar=false;
+	if( !E-&gt;inLOS )
+	{
+		if( !E-&gt;posLocked )
+			E-&gt;position = cb-&gt;GetUnitPos(enemy);
+		if( !TM-&gt;IsSectorValid(TM-&gt;GetSectorIndex(E-&gt;position)) )
+			EnemyRemove(enemy,E);
+	}
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::EnemyDestroyed(int enemy,int attacker)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nEnemyDestroyed(&quot;&lt;&lt;enemy&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;)&quot;;
+	if( Enemies.find(enemy) == Enemies.end() ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		*l&lt;&lt;&quot;\nWARNING: EnemyDestroyed(&quot;&lt;&lt;enemy&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;): unknown unit id&quot;;
+		return;
+	}
+
+	EnemyInfo *E = &amp;Enemies.find(enemy)-&gt;second;
+	if( E-&gt;inLOS )
+		DebugEnemyDestroyedLOS++;
+	if( E-&gt;inRadar )
+		DebugEnemyDestroyedRadar++;
+	EnemyRemove(enemy,E);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::EnemyRemove(int enemy, EnemyInfo *E)
+{
+	if( E-&gt;RS != 0 &amp;&amp; E-&gt;RS-&gt;unitID == enemy )
+	{
+		E-&gt;RS-&gt;unitID=-1;
+		E-&gt;RS-&gt;unitUD=0;
+		E-&gt;RS-&gt;enemy = false;
+	}
+	if( E-&gt;baseThreatID != -1 )
+		EThreat.erase(enemy);
+	while( int(E-&gt;attackGroups.size()) &gt; 0 )
+		UM-&gt;GroupRemoveEnemy(enemy,E,*E-&gt;attackGroups.begin());
+	Enemies.erase(enemy);
+}
+
+void cRAI::EnemyDamaged(int damaged,int attacker,float damage,float3 dir)
+{
+
+}
+
+void cRAI::UnitIdle(int unit)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nUI(&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;;
+	if( Units.find(unit) == Units.end() ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		*l&lt;&lt;&quot;\nWARNING: UnitIdle(&quot;&lt;&lt;unit&lt;&lt;&quot;): unknown unit id&quot;;
+		return;
+	}
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+	if( U-&gt;AIDisabled || cb-&gt;UnitBeingBuilt(unit) || cb-&gt;IsUnitParalyzed(unit) || int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) &gt; 0 )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+	U-&gt;humanCommand=false;
+	if( cb-&gt;GetCurrentFrame() &lt;= U-&gt;lastUnitIdleFrame+15 ) // !! Occurs if enemy attack order fails/...possibly some other reason
+	{
+		UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+15,unit,U);
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+	U-&gt;lastUnitIdleFrame=cb-&gt;GetCurrentFrame();
+	if( U-&gt;UE != 0 &amp;&amp; U-&gt;UE-&gt;type == 1 )
+		UpdateEventRemove(U-&gt;UE);
+	if( U-&gt;inCombat )
+	{
+		CM-&gt;UnitIdle(unit,U);
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+	UM-&gt;UnitIdle(unit,U);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::GotChatMsg(const char* msg,int player)
+{
+
+}
+
+void cRAI::UnitDamaged(int unit,int attacker,float damage,float3 dir)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nUnitDamaged(&quot;&lt;&lt;unit&lt;&lt;&quot;,&quot;&lt;&lt;attacker&lt;&lt;&quot;,&quot;&lt;&lt;damage&lt;&lt;&quot;,x&quot;&lt;&lt;dir.x&lt;&lt;&quot; z&quot;&lt;&lt;dir.z&lt;&lt;&quot; y&quot;&lt;&lt;dir.y&lt;&lt;&quot;)&quot;;
+	if( cb-&gt;UnitBeingBuilt(unit) || cb-&gt;IsUnitParalyzed(unit) || cb-&gt;GetUnitHealth(unit) &lt;= 0.0 )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+
+	UnitInfo *U = &amp;Units.find(unit)-&gt;second;
+	if( cb-&gt;GetCurrentFrame() &lt;= U-&gt;lastUnitDamagedFrame+15 )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+
+	U-&gt;lastUnitDamagedFrame=cb-&gt;GetCurrentFrame();
+
+	EnemyInfo *E=0;
+	if( Enemies.find(attacker) != Enemies.end() )
+		E = &amp;Enemies.find(attacker)-&gt;second;
+	else
+		attacker = -1;
+
+	if( U-&gt;ud-&gt;speed==0 )
+	{
+		if( E != 0 )
+		{
+			E-&gt;baseThreatFrame=cb-&gt;GetCurrentFrame();
+			E-&gt;baseThreatID=unit;
+			if( EThreat.find(attacker) == EThreat.end() )
+			{
+				EThreat.insert(iepPair(attacker,E));
+				for( int i=0; i&lt;UM-&gt;GroupSize; i++ )
+					if( int(UM-&gt;Group[i]-&gt;Enemies.size()) == 0 &amp;&amp; !UM-&gt;Group[i]-&gt;Units.begin()-&gt;second-&gt;ud-&gt;canLoopbackAttack )
+						CM-&gt;GetClosestEnemy(cb-&gt;GetUnitPos(UM-&gt;Group[i]-&gt;Units.begin()-&gt;first),UM-&gt;Group[i]-&gt;Units.begin()-&gt;second);
+			}
+		}
+		ValidateUnitList(&amp;U-&gt;UGuards);
+		for( map&lt;int,UnitInfo*&gt;::iterator i = U-&gt;UGuards.begin(); i != U-&gt;UGuards.end(); i++ )
+		{
+			if( int(i-&gt;second-&gt;URepair.size()) == 0 &amp;&amp; !IsHumanControled(i-&gt;first,i-&gt;second) )
+			{
+				Command c;
+				c.id = CMD_REPAIR;
+				c.params.push_back(unit);
+				cb-&gt;GiveOrder(i-&gt;first, &amp;c);
+			}
+			if( i-&gt;second-&gt;URepair.find(unit) == i-&gt;second-&gt;URepair.end() )
+				i-&gt;second-&gt;URepair.insert(iupPair(unit,U));
+		}
+		if( U-&gt;ud-&gt;canReclaim &amp;&amp; attacker &gt; -1 &amp;&amp; U-&gt;udr-&gt;IsNano() &amp;&amp; cb-&gt;GetUnitPos(unit).distance2D(cb-&gt;GetUnitPos(attacker)) &lt; U-&gt;ud-&gt;buildDistance &amp;&amp; !IsHumanControled(unit,U) )
+		{
+			if( cb-&gt;GetCurrentUnitCommands(unit)-&gt;size() == 0 || (cb-&gt;GetCurrentUnitCommands(unit)-&gt;front().id != CMD_REPAIR &amp;&amp; cb-&gt;GetCurrentUnitCommands(unit)-&gt;front().id != CMD_RECLAIM) )
+			{
+				Command c;
+				c.id = CMD_RECLAIM;
+				c.params.push_back(attacker);
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+		}
+	}
+	if( U-&gt;AIDisabled || U-&gt;udrBL-&gt;task&lt;=0 || U-&gt;ud-&gt;speed==0 )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+
+	if( E != 0 &amp;&amp; U-&gt;group != 0 &amp;&amp; U-&gt;group-&gt;Enemies.find(attacker) == U-&gt;group-&gt;Enemies.end() )
+	{
+		if( E-&gt;baseThreatID != -1 || UM-&gt;ActiveAttackOrders() )
+			UM-&gt;GroupAddEnemy(attacker,E,U-&gt;group);
+	}
+
+	if( !IsHumanControled(unit,U) )
+		CM-&gt;UnitDamaged(unit,U,attacker,E,dir);
+
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::UnitMoveFailed(int unit)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nUnitMoveFailed(&quot;&lt;&lt;unit&lt;&lt;&quot;)&quot;;
+	if( UMobile.find(unit) == UMobile.end() ) // ! Work Around:  Spring-Version(v0.72b1-0.76b1)
+	{
+		*l&lt;&lt;&quot;\nWARNING: UnitMoveFailed(&quot;&lt;&lt;unit&lt;&lt;&quot;): unknown unit id&quot;;
+		return;
+	}
+
+	UnitInfo *U = UMobile.find(unit)-&gt;second;
+	if( U-&gt;AIDisabled || cb-&gt;IsUnitParalyzed(unit) ||
+		B-&gt;UBuilderMoveFailed(unit,U) || UM-&gt;UnitMoveFailed(unit,U) ||
+		int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) &gt; 0 )
+	{
+		if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+		return;
+	}
+
+	Command c;
+	c.id=CMD_WAIT;
+	//c.timeOut=cb-&gt;GetCurrentFrame()+120;
+	cb-&gt;GiveOrder(unit,&amp;c);
+	UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+90,unit,U);
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+int cRAI::HandleEvent(int msg,const void* data)
+{
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nHandleEvent(&quot;&lt;&lt;msg&lt;&lt;&quot;,&quot;&lt;&lt;&quot;~&quot;&lt;&lt;&quot;)&quot;;
+	switch (msg)
+	{
+	case AI_EVENT_UNITGIVEN:
+		{
+			const IGlobalAI::ChangeTeamEvent* cte = (const IGlobalAI::ChangeTeamEvent*) data;
+			if( cte-&gt;newteam != cb-&gt;GetMyTeam() )
+			{
+				cb-&gt;SendTextMsg(&quot;cRAI::HandleEvent(AI_EVENT_UNITGIVEN): This AI is out of date, check for a more recent one.&quot;,0);
+				*l&lt;&lt;&quot;\nERROR: cRAI::HandleEvent(AI_EVENT_UNITGIVEN): This AI is out of date, check for a more recent one.\n&quot;;
+			}
+
+			if( Enemies.find(cte-&gt;unit) != Enemies.end() )
+				EnemyDestroyed(cte-&gt;unit,-1);
+
+			if( cb-&gt;GetUnitHealth(cte-&gt;unit) &lt;= 0 ) // ! Work Around:  Spring-Version(v0.74b1-0.75b2)
+			{
+				*l&lt;&lt;&quot;\nERROR: HandleEvent(AI_EVENT_UNITGIVEN): given unit is dead or does not exist&quot;;
+				return 0;
+			}
+
+			UnitCreated(cte-&gt;unit);
+			Units.find(cte-&gt;unit)-&gt;second.AIDisabled=false;
+			if( !cb-&gt;UnitBeingBuilt(cte-&gt;unit) )
+			{
+				UnitFinished(cte-&gt;unit);
+				UnitIdle(cte-&gt;unit);
+			}
+		}
+		break;
+	case AI_EVENT_UNITCAPTURED:
+		{
+			const IGlobalAI::ChangeTeamEvent* cte = (const IGlobalAI::ChangeTeamEvent*) data;
+			if( cte-&gt;oldteam != cb-&gt;GetMyTeam() )
+			{
+				cb-&gt;SendTextMsg(&quot;cRAI::HandleEvent(AI_EVENT_UNITCAPTURED): This AI is out of date, check for a more recent one.&quot;,0);
+				*l&lt;&lt;&quot;\nERROR: cRAI::HandleEvent(AI_EVENT_UNITCAPTURED): This AI is out of date, check for a more recent one.\n&quot;;
+			}
+
+			UnitDestroyed(cte-&gt;unit,-1);
+		}
+		break;
+	case AI_EVENT_PLAYER_COMMAND:
+		{
+			const IGlobalAI::PlayerCommandEvent* pce = (const IGlobalAI::PlayerCommandEvent*) data;
+			bool ImportantCommand=false;
+			if( pce-&gt;command.id &lt; 0 )
+				ImportantCommand = true;
+			switch( pce-&gt;command.id )
+			{
+			case CMD_MOVE:
+			case CMD_PATROL:
+			case CMD_FIGHT:
+			case CMD_ATTACK:
+			case CMD_AREA_ATTACK:
+			case CMD_GUARD:
+			case CMD_REPAIR:
+			case CMD_LOAD_UNITS:
+			case CMD_UNLOAD_UNITS:
+			case CMD_UNLOAD_UNIT:
+			case CMD_RECLAIM:
+			case CMD_DGUN:
+			case CMD_RESTORE:
+			case CMD_RESURRECT:
+			case CMD_CAPTURE:
+				ImportantCommand = true;
+			}
+
+			for( int i=0; i&lt;int(pce-&gt;units.size()); i++ )
+			{
+				if( Units.find(pce-&gt;units.at(i)) == Units.end() ) // ! Work Around:  Spring-Version(v0.75b2)
+				{
+					*l&lt;&lt;&quot;\nERROR: HandleEvent(AI_EVENT_PLAYER_COMMAND): unknown unit id=&quot;&lt;&lt;pce-&gt;units.at(i);
+//					pce-&gt;units.erase(pce-&gt;units.begin()+i);
+//					i--;
+				}
+				else if( ImportantCommand )
+					Units.find(pce-&gt;units.at(i))-&gt;second.humanCommand = true;
+			}
+			if( ImportantCommand )
+			{
+				B-&gt;HandleEvent(pce);
+			}
+			else if( pce-&gt;command.id == CMD_SELFD )
+			{
+				for( vector&lt;int&gt;::const_iterator i=pce-&gt;units.begin(); i!=pce-&gt;units.end(); i++ )
+					UnitDestroyed(*i,-1);
+			}
+		}
+		break;
+	}
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+	return 0;
+}
+
+void cRAI::Update()
+{
+	frame=cb-&gt;GetCurrentFrame();
+	if(frame%FUPDATE_MINIMAL)
+		return;
+
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;\nUpdate(&quot;&lt;&lt;frame&lt;&lt;&quot;)&quot;;
+
+	if(!(frame%FUPDATE_POWER))
+	{	// Old Code, ensures a unit won't just go permanently idle, hopefully unnecessary in the future
+		ValidateAllUnits();
+		for(map&lt;int,UnitInfo&gt;::iterator iU=Units.begin(); iU!=Units.end(); iU++)
+			if( !cb-&gt;UnitBeingBuilt(iU-&gt;first) &amp;&amp; !iU-&gt;second.AIDisabled &amp;&amp; iU-&gt;second.udrBL-&gt;task &gt; 1 &amp;&amp;
+				frame &gt; iU-&gt;second.lastUnitIdleFrame+FUPDATE_UNITS &amp;&amp; iU-&gt;second.UE == 0 &amp;&amp; cb-&gt;GetCurrentUnitCommands(iU-&gt;first)-&gt;size() == 0 )
+			{
+//				*l&lt;&lt;&quot;\nWARNING: Unit was Idle  Name=&quot;&lt;&lt;iU-&gt;second.ud-&gt;humanName&lt;&lt;&quot;(&quot;&lt;&lt;iU-&gt;first&lt;&lt;&quot;)&quot;;
+				UnitIdle(iU-&gt;first);
+			}
+	}
+
+	while( eventSize &gt; 0 &amp;&amp; eventList[0]-&gt;frame &lt;= frame )
+	{
+		switch( eventList[0]-&gt;type )
+		{
+		case 1: // Checks for idleness
+//			*l&lt;&lt;&quot;\n(u1)&quot;;
+			if( ValidateUnit(eventList[0]-&gt;unitID) ) // if false, the event will be removed elsewhere
+			{
+				if( !IsHumanControled(eventList[0]-&gt;unitID,eventList[0]-&gt;unitI) )
+				{
+//					*l&lt;&lt;&quot; Stopping &quot;&lt;&lt;eventList[0]-&gt;unitI-&gt;ud-&gt;humanName&lt;&lt;&quot;(&quot;&lt;&lt;eventList[0]-&gt;unitID&lt;&lt;&quot;)&quot;;
+					eventList[0]-&gt;unitI-&gt;lastUnitIdleFrame = -1;
+					if( eventList[0]-&gt;unitI-&gt;ud-&gt;speed == 0 )
+					{
+						int unit = eventList[0]-&gt;unitID;
+						UpdateEventRemove(eventList[0]);
+						UnitIdle(unit);
+					}
+					else
+					{	// doesn't seem to work for factories  Spring-Version(v0.76b1)
+						Command c;
+						c.id=CMD_STOP;
+						cb-&gt;GiveOrder(eventList[0]-&gt;unitID, &amp;c);
+						UpdateEventRemove(eventList[0]);
+					}
+				}
+				else
+				{
+					eventList[0]-&gt;frame = frame;
+					UpdateEventReorderFirst();
+				}
+			}
+			break;
+		case 2: // Few Unit Monitoring
+//			*l&lt;&lt;&quot;\n(u2)&quot;;
+			if( ValidateUnit(eventList[0]-&gt;unitID) ) // if false, the event will be removed elsewhere
+			{
+				if( !eventList[0]-&gt;unitI-&gt;inCombat &amp;&amp;
+					!IsHumanControled(eventList[0]-&gt;unitID,eventList[0]-&gt;unitI) &amp;&amp;
+					eventList[0]-&gt;unitI-&gt;BuildQ != 0 &amp;&amp;
+					cb-&gt;GetCurrentUnitCommands(eventList[0]-&gt;unitID)-&gt;front().id &lt; 0 )
+				{
+					if( eventList[0]-&gt;lastPosition == 0 )
+						eventList[0]-&gt;lastPosition = new float3;
+					float3 position = cb-&gt;GetUnitPos(eventList[0]-&gt;unitID);
+					if( eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationID.size() &gt; 0 )
+					{
+						eventList[0]-&gt;lastPosition-&gt;x = -1.0;
+						float3 conPosition = cb-&gt;GetUnitPos(eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationID.front());
+						if( abs(int(position.x-conPosition.x)) + 4.0 &lt; 8.0*eventList[0]-&gt;unitI-&gt;ud-&gt;xsize/2.0 + 8.0*eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;xsize/2.0 &amp;&amp;
+							abs(int(position.z-conPosition.z)) + 4.0 &lt; 8.0*eventList[0]-&gt;unitI-&gt;ud-&gt;ysize/2.0 + 8.0*eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;ysize/2.0 )
+						{	// most likely, the commander built something on top of himself
+							Command c;
+							c.id = CMD_RECLAIM;
+							c.params.push_back(eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationID.front());
+							cb-&gt;GiveOrder(eventList[0]-&gt;unitID,&amp;c);
+							if( B-&gt;BP-&gt;NeedResourceSite(eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud) )
+							{
+								c.params.clear();
+								c.id = CMD_MOVE;
+								c.options = SHIFT_KEY;
+								if( position.x &lt; conPosition.x )
+									c.params.push_back(position.x - ((position.x-conPosition.x)/position.distance2D(conPosition))*(8.0*eventList[0]-&gt;unitI-&gt;ud-&gt;xsize/2.0 +8.0*eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;xsize/2.0) );
+								else
+									c.params.push_back(position.x + ((position.x-conPosition.x)/position.distance2D(conPosition))*(8.0*eventList[0]-&gt;unitI-&gt;ud-&gt;xsize/2.0 +8.0*eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;xsize/2.0) );
+								c.params.push_back(position.y);
+								if( position.z &lt; conPosition.z )
+									c.params.push_back(position.z - ((position.z-conPosition.z)/position.distance2D(conPosition))*(8.0*eventList[0]-&gt;unitI-&gt;ud-&gt;ysize/2.0 +8.0*eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;ysize/2.0) );
+								else
+									c.params.push_back(position.z + ((position.z-conPosition.z)/position.distance2D(conPosition))*(8.0*eventList[0]-&gt;unitI-&gt;ud-&gt;ysize/2.0 +8.0*eventList[0]-&gt;unitI-&gt;BuildQ-&gt;creationUD-&gt;ud-&gt;ysize/2.0) );
+								cb-&gt;GiveOrder(eventList[0]-&gt;unitID,&amp;c);
+							}
+						}
+					}
+					else if( position == *eventList[0]-&gt;lastPosition )
+					{	// most likely, the commander is stuck at the starting point
+//						if( eventList[0]-&gt;unitI-&gt;area == 0 &amp;&amp; TM-&gt;udMobileType.find(eventList[0]-&gt;unitI-&gt;ud-&gt;id)-&gt;second != 0 )
+//						{} // trapped forever
+						eventList[0]-&gt;unitI-&gt;lastUnitIdleFrame = -1;
+						Command c;
+						c.id = CMD_MOVE;
+						float f = (40.0+(rand()%401)/10.0);
+						if( rand()%2 == 0 )
+							c.params.push_back(position.x + f );
+						else
+							c.params.push_back(position.x - f );
+						c.params.push_back(position.y);
+						f = (40.0+(rand()%401)/10.0);
+						if( rand()%2 == 0 )
+							c.params.push_back(position.z + f );
+						else
+							c.params.push_back(position.z - f );
+						cb-&gt;GiveOrder(eventList[0]-&gt;unitID,&amp;c);
+						*eventList[0]-&gt;lastPosition = position;
+					}
+					else
+						*eventList[0]-&gt;lastPosition = position;
+				}
+				if( Units.size() &gt;= 10 )
+				{
+					if( eventList[0]-&gt;lastPosition != 0 )
+						delete eventList[0]-&gt;lastPosition;
+					UpdateEventRemove(eventList[0]);
+				}
+				else
+					UpdateEventReorderFirst();
+			}
+			break;
+		case 3: // Initiatization
+//			*l&lt;&lt;&quot;\n(u3)&quot;;
+			if( frame &gt;= 210 || ( cb-&gt;GetMetalIncome()&gt;0 &amp;&amp; cb-&gt;GetMetalIncome()&lt;0.9*cb-&gt;GetMetalStorage() ) || ( cb-&gt;GetEnergyIncome()&gt;0 &amp;&amp; cb-&gt;GetEnergyIncome()&lt;0.9*cb-&gt;GetEnergyStorage() ) )
+			{
+				*l&lt;&lt;&quot;\nInitiated=true  Frame=&quot;&lt;&lt;frame&lt;&lt;&quot; Metal-Income=&quot;&lt;&lt;cb-&gt;GetMetalIncome()&lt;&lt;&quot; Energy-Income=&quot;&lt;&lt;cb-&gt;GetEnergyIncome()&lt;&lt;&quot;\n&quot;;
+				UpdateEventRemove(eventList[0]);
+				B-&gt;UpdateUDRCost();
+				for(map&lt;int,UnitInfo&gt;::iterator i=Units.begin(); i!=Units.end(); i++ )
+					if( !i-&gt;second.AIDisabled  )
+					{
+						if( Units.size() &lt; 10 &amp;&amp; i-&gt;second.ud-&gt;movedata != 0 )
+							UpdateEventAdd(2,frame+FUPDATE_MINIMAL,i-&gt;first,&amp;i-&gt;second);
+						if( cb-&gt;GetCurrentUnitCommands(i-&gt;first)-&gt;size() == 0 )
+							UnitIdle(i-&gt;first);
+					}
+				B-&gt;bInitiated=true;
+			}
+			else
+				UpdateEventReorderFirst();
+			break;
+		default:
+			*l&lt;&lt;&quot;(ERROR)&quot;;
+			UpdateEventRemove(eventList[0]);
+			break;
+		}
+	}
+
+	if(!(frame%FUPDATE_POWER))
+	{
+		B-&gt;PM-&gt;Update();
+		SWM-&gt;Update();
+		if(!(frame%FUPDATE_BUILDLIST))
+			B-&gt;UpdateUDRCost();
+	}
+	if( RAIDEBUGGING ) *l&lt;&lt;&quot;#&quot;;
+}
+
+void cRAI::UpdateEventAdd(const int &amp;eventType, const int &amp;eventFrame, int uID, UnitInfo* uI)
+{
+	if( eventSize == 10000 )
+	{
+		*l&lt;&lt;&quot;\nERROR: Event Maximum Reached.&quot;;
+		return;
+	}
+
+	UpdateEvent* e = new UpdateEvent;
+	if( uI != 0 )
+	{
+		if( uI-&gt;UE != 0 ) // The unit already has an event
+		{
+			if( eventType &gt;= uI-&gt;UE-&gt;type ) // more or equally important
+				UpdateEventRemove(uI-&gt;UE);	// remove the old
+			else
+			{
+				delete e;
+				return;
+			}
+		}
+		uI-&gt;UE = e;
+	}
+
+	e-&gt;type = eventType;
+	e-&gt;frame = eventFrame;
+	e-&gt;unitID = uID;
+	e-&gt;unitI = uI;
+	e-&gt;lastPosition = 0;
+
+	for(e-&gt;index = eventSize; e-&gt;index&gt;0; e-&gt;index-- )
+		if( e-&gt;frame &lt; eventList[e-&gt;index-1]-&gt;frame )
+		{
+			eventList[e-&gt;index] = eventList[e-&gt;index-1];
+			eventList[e-&gt;index]-&gt;index = e-&gt;index;
+		}
+		else
+			break;
+
+	eventList[e-&gt;index] = e;
+	eventSize++;
+}
+
+void cRAI::UpdateEventReorderFirst()
+{
+	UpdateEvent* e = eventList[0];
+	e-&gt;frame += FUPDATE_MINIMAL;
+	while( e-&gt;index &lt; eventSize-1 &amp;&amp; eventList[e-&gt;index+1]-&gt;frame &lt; e-&gt;frame )
+	{
+		eventList[e-&gt;index] = eventList[e-&gt;index+1];
+		eventList[e-&gt;index]-&gt;index = e-&gt;index;
+		e-&gt;index++;
+	}
+	eventList[e-&gt;index] = e;
+}
+
+void cRAI::UpdateEventRemove(UpdateEvent* e)
+{
+	if( e-&gt;unitI != 0 )
+		e-&gt;unitI-&gt;UE = 0;
+	eventSize--;
+	while( e-&gt;index &lt; eventSize )
+	{
+		eventList[e-&gt;index] = eventList[e-&gt;index+1];
+		eventList[e-&gt;index]-&gt;index = e-&gt;index;
+		e-&gt;index++;
+	}
+	delete e;
+}
+
+void cRAI::CorrectPosition(float3&amp; position)
+{
+	if( position.x &lt; 1 )
+		position.x = 1;
+	else if( position.x &gt; 8*cb-&gt;GetMapWidth()-1 )
+		position.x = 8*cb-&gt;GetMapWidth()-1;
+	if( position.z &lt; 1 )
+		position.z = 1;
+	else if( position.z &gt; 8*cb-&gt;GetMapHeight()-1 )
+		position.z = 8*cb-&gt;GetMapHeight()-1;
+	position.y = cb-&gt;GetElevation(position.x,position.z);
+}
+
+TerrainMapArea* cRAI::GetCurrentMapArea(sRAIUnitDef* udr, float3&amp; position)
+{
+	if( udr-&gt;mobileType == 0 ) // flying units &amp; buildings
+		return 0;
+
+	// other mobile units &amp; their factories
+	int iS = TM-&gt;GetSectorIndex(position);
+	if( !TM-&gt;IsSectorValid(iS) )
+	{
+		CorrectPosition(position);
+		iS = TM-&gt;GetSectorIndex(position);
+	}
+	return udr-&gt;mobileType-&gt;sector[iS].area;
+}
+
+float3 cRAI::GetRandomPosition(TerrainMapArea* area)
+{
+	float3 Pos;
+	if( area == 0 )
+	{
+		Pos.x=1.0 + rand()%7 + 8.0*(rand()%cb-&gt;GetMapWidth());
+		Pos.z=1.0 + rand()%7 + 8.0*(rand()%cb-&gt;GetMapHeight());
+		Pos.y=cb-&gt;GetElevation(Pos.x,Pos.z);
+		return Pos;
+	}
+
+	vector&lt;int&gt; Temp;
+	for( map&lt;int,TerrainMapAreaSector*&gt;::iterator iS=area-&gt;sector.begin(); iS!=area-&gt;sector.end(); iS++ )
+		Temp.push_back(iS-&gt;first);
+	int iS=Temp.at(rand()%int(Temp.size()));
+	Pos.x=TM-&gt;sector[iS].position.x - TM-&gt;convertStoP/2-1.0 + rand()%(TM-&gt;convertStoP-1);
+	Pos.z=TM-&gt;sector[iS].position.z - TM-&gt;convertStoP/2-1.0 + rand()%(TM-&gt;convertStoP-1);
+	Pos.y=cb-&gt;GetElevation(Pos.x,Pos.z);
+	return Pos;
+}
+
+bool cRAI::IsHumanControled(const int&amp; unit,UnitInfo* U)
+{
+	if( int(cb-&gt;GetCurrentUnitCommands(unit)-&gt;size()) == 0 )
+		return false;
+	if( U-&gt;humanCommand )
+		return true;
+	return false;
+}
+
+bool cRAI::ValidateUnit(const int&amp; unitID)
+{
+	if( cb-&gt;GetUnitDef(unitID) == 0 ) // ! Work Around:  Spring-Version(v0.74b1-0.75b2)
+	{
+		*l&lt;&lt;&quot;\nERROR: ValidateUnit(): iU-&gt;first=&quot;&lt;&lt;unitID;
+		UnitDestroyed(unitID,-1);
+		return false;
+	}
+	return true;
+}
+
+bool cRAI::ValidateUnitList(map&lt;int,UnitInfo*&gt;* UL)
+{
+	int ULsize = UL-&gt;size();
+	for(map&lt;int,UnitInfo*&gt;::iterator iU=UL-&gt;begin(); iU!=UL-&gt;end(); iU++)
+	{
+		if( !ValidateUnit(iU-&gt;first) )
+		{
+			// The iterator has becomes invalid at this point
+			if( ULsize == 1 ) // if true then the list is now empty, and may have been deleted (UL is invalid)
+				return false;
+			else
+				return ValidateUnitList(UL);
+		}
+	}
+	return true;
+}
+
+void cRAI::ValidateAllUnits()
+{
+	for(map&lt;int,UnitInfo&gt;::iterator iU=Units.begin(); iU!=Units.end(); iU++)
+	{
+		if( !ValidateUnit(iU-&gt;first) )
+		{
+			// The iterator has becomes invalid at this point
+			ValidateAllUnits();
+			return;
+		}
+	}
+}
+
+void cRAI::DebugDrawLine(float3 StartPos, float distance, int direction, float xposoffset, float zposoffset, float yposoffset, int lifetime, int arrow, float width, int group)
+{
+	StartPos.x+=xposoffset;
+	StartPos.z+=zposoffset;
+	StartPos.y+=yposoffset;
+	float3 EndPos=StartPos;
+	switch( direction )
+	{
+	case 0:
+			EndPos.x+=distance;
+		break;
+	case 1:
+			EndPos.z+=distance;
+		break;
+	case 2:
+			EndPos.x-=distance;
+		break;
+	case 3:
+			EndPos.z-=distance;
+		break;
+	}
+	cb-&gt;CreateLineFigure(StartPos,EndPos,width,arrow,lifetime,group);
+}
+
+void cRAI::DebugDrawShape(float3 CenterPos, float linelength, float width, int arrow, float yposoffset, int lifetime, int sides, int group)
+{
+	DebugDrawLine(CenterPos,linelength,0,-linelength/2,linelength/2,yposoffset,lifetime,arrow,width,group);
+	DebugDrawLine(CenterPos,linelength,1,-linelength/2,-linelength/2,yposoffset,lifetime,arrow,width,group);
+	DebugDrawLine(CenterPos,linelength,2,linelength/2,-linelength/2,yposoffset,lifetime,arrow,width,group);
+	DebugDrawLine(CenterPos,linelength,3,linelength/2,linelength/2,yposoffset,lifetime,arrow,width,group);
+}
+
+void cRAI::ClearLogFiles()
+{
+	const string dataDirectory = RAIDirectory + &quot;cache/&quot;;
+	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)RAIDirectory.c_str() );
+	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)dataDirectory.c_str() );
+
+	string logFileName;
+	for( int i=0; i&lt;16; i++ )
+	{	
+		char c[2];
+		sprintf(c, &quot;%i&quot;,i);
+		logFileName = RAIDirectory+&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;;
+		remove(logFileName.c_str());
+	}
+
+	logFileName=RAIDirectory+&quot;RAIGlobal_LastGame.log&quot;;
+	remove(logFileName.c_str());
+	logFileName=RAIDirectory+&quot;TerrainMapDebug.log&quot;;
+	remove(logFileName.c_str());
+//	logFileName=RAIDirectory+&quot;PathfinderDebug.log&quot;;
+//	remove(logFileName.c_str());
+//	logFileName=RAIDirectory+&quot;PathFinderAPNDebug.log&quot;;
+//	remove(logFileName.c_str());
+//	logFileName=RAIDirectory+&quot;PathFinderNPNDebug.log&quot;;
+//	remove(logFileName.c_str());
+//	logFileName=RAIDirectory+&quot;Prerequisite.log&quot;;
+//	remove(logFileName.c_str());
+//	logFileName=RAIDirectory+&quot;Debug.log&quot;;
+//	remove(logFileName.c_str());
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/RAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/RAI.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/RAI.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/RAI.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,191 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_IGLOBALAI_H
+#define RAI_IGLOBALAI_H
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif
+
+struct UnitInfo;
+struct EnemyInfo;
+class cRAI;
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+using std::map;
+#include &quot;BasicArray.h&quot;
+#include &quot;UnitDefHandler.h&quot;
+#include &quot;BuilderPlacement.h&quot;
+#include &quot;Builder.h&quot;
+#include &quot;UnitManager.h&quot;
+#include &quot;SWeaponManager.h&quot;
+#include &quot;PowerManager.h&quot;
+#include &quot;CombatManager.h&quot;
+using std::set;
+
+const char AI_NAME[]=&quot;RAI v0.601&quot;;
+const bool RAIDEBUGGING = false;
+
+// These are for anything that can occur in Update() but not on a regular basis
+struct UpdateEvent
+{
+	int type;	// (1=unit-time-out,2=unit-monitoring,3=initialize), also used as a ranking of importance
+	int frame;	// when the event will trigger
+	int index;
+	int unitID;
+	UnitInfo* unitI;
+	float3* lastPosition; // only used by unit-monitoring
+};
+
+struct UnitInfo
+{
+	UnitInfo(sRAIUnitDef* rUnitDef);
+
+	const UnitDef* ud;		// Always valid
+	sRAIUnitDef* udr;		// Always valid
+	sRAIUnitDefBL* udrBL;	// Valid if AIDisabled=false
+	TerrainMapArea* area;	// Not always valid, but definitely = 0 if a unit flies
+	sBuildQuarry* BuildQ;	// Valid if building something, otherwise = 0
+	UnitInfoPower* CloakUI; // I can not rely on cb-&gt;IsUnitCloaked(unit), since I need to keep track of power variables.
+	UnitInfoPower* OnOffUI; // I can not rely on cb-&gt;IsUnitActivated(unit), same reason
+	sSWeaponUnitInfo* SWeaponUI; // Valid if the unit has a stock weapon, otherwise = 0
+	sRAIGroup* group;
+	EnemyInfo* E;	// valid if 'enemyID' &amp; 'Group' are set, otherwise this must be updated before used
+	sWeaponEfficiency* enemyEff;
+	UpdateEvent* UE;
+	bool AIDisabled;
+	bool humanCommand;	// Set true if a unit receives an order through HandleEvent(), set false on UnitIdle()
+	bool unitBeingBuilt;// Work Around: for cb-&gt;UnitBeingBuilt(), which will not work if UnitDestroyed() fails to trigger immediately after a unit's death   Spring-Version(v0.74b3)
+	bool inCombat;
+	int lastUnitIdleFrame;		// Guard: Prevent UnitIdle from executing too many times in rapid succession
+	int lastUnitDamagedFrame;	// Guard: Prevent UnitDamaged from executing too many times in rapid succession
+
+	// Buildings Only
+	ResourceSiteExt* RS;			// Extractor/Geo, otherwise = 0
+	map&lt;int,UnitInfo*&gt; UGuards;		// Hubs/Nanos guarding this unit
+	map&lt;int,UnitInfo*&gt; UGuarding;	// Hubs/Nanos only, Units being guarded
+//	map&lt;int,UnitInfo*&gt; UAssist;		// Hubs/Nanos only, Units it will assist with building
+	map&lt;int,UnitInfo*&gt; URepair;		// Hubs/Nanos only, Units that are in need of repairs
+	map&lt;int,UnitInfo*&gt; UDefences;	// Defences build near this unit
+	map&lt;int,UnitInfo*&gt; UDefending;	// Defences Only, buildings near this unit
+//	map&lt;int,ResourceSiteExt*&gt; Resources;	// Hubs only, the only resources this unit can build at
+
+	// old
+//	int commandTimeOut;			// Work Around: for the currently broken command.timeout   Spring-Version(v0.72b1)
+	int enemyID;
+};
+
+struct EnemyInfo
+{
+	EnemyInfo();
+
+	bool inLOS;
+	bool inRadar;
+	int baseThreatFrame;// last frame it attacked one of our immobile units
+	int baseThreatID;	// what unit of ours did it last attack
+	const UnitDef* ud;	// valid if the enemy was in LOS at least once, otherwise = 0
+	sRAIUnitDef* udr;	// same as above
+	ResourceSiteExt* RS;	// Enemy Extractor/Geo, otherwise = 0
+	set&lt;sRAIGroup*&gt; attackGroups;
+
+	float3 position;	// last known position, used if not in LOS or Radar
+	bool posLocked;		// This unit does not move and its 'position' was saved while in LOS
+};
+
+using namespace std;
+
+#include &quot;GTerrainMap.h&quot;
+#include &quot;GResourceMap.h&quot;
+static GlobalResourceMap* GRMap=0;
+static GlobalTerrainMap* GTMap=0;
+static int RAIs=0;
+
+// how often lists are updated by frame interval.  NOTE: this is different from in-game graphics frames and will always be trigger 30x per second (assuming the game speed is 1.00)
+#define FUPDATE_MINIMAL 90		// 3 seconds, the minimal time for an update.  NOTE: excluding FUPDATE_UNITS, this value needs to be 'a factor' of the other FUPDATE values
+#define FUPDATE_UNITS 900		// 60 seconds, unit is checked for idleness - should never happen, but it does.
+#define FUPDATE_POWER 450		// 15 seconds, all units are checked for on/off or cloak/uncloak tasks
+#define FUPDATE_BUILDLIST 1800	// 600 seconds, redetermines the available build options - half unnecessary since this is also called by events, hence the longer delay
+
+class cRAI : public IGlobalAI
+{
+public:
+	cRAI();
+	virtual ~cRAI();
+	void InitAI(IGlobalAICallback* callback, int team);
+	void UnitCreated(int unit);						// called when a new unit is created on an ai team
+	void UnitFinished(int unit);					// called when a unit has finished being build
+	void UnitDestroyed(int unit,int attacker);		// called when a unit is destroyed
+	void EnemyEnterLOS(int enemy);					// called when an enemy unit enters the &quot;line of sight&quot; of you or your ally
+	void EnemyLeaveLOS(int enemy);					// called when an enemy unit exits the &quot;line of sight&quot; of you and your ally
+	void EnemyEnterRadar(int enemy);				// called when an enemy unit enters the radar of you or your ally
+	void EnemyLeaveRadar(int enemy);				// called when an enemy unit exits the radar of you and your ally
+	void EnemyDestroyed(int enemy,int attacker);	// called if an enemy inside los or radar dies
+	void EnemyRemove(int enemy, EnemyInfo* E);
+	void EnemyDamaged(int damaged,int attacker,float damage,float3 dir); // called when an enemy inside los or radar is damaged
+	void UnitIdle(int unit);						// called when a unit go idle and is not assigned to any group
+	void GotChatMsg(const char* msg,int player);	// called when someone writes a chat msg
+	void UnitDamaged(int damaged,int attacker,float damage,float3 dir); // called when one of your units are damaged
+	void UnitMoveFailed(int unit);
+	int HandleEvent(int msg,const void* data);
+	void Update();			// called every frame
+	void UpdateEventAdd(const int &amp;eventType, const int &amp;eventFrame, int uID=0, UnitInfo* uI=0);
+	void CorrectPosition(float3&amp; position);
+	TerrainMapArea* GetCurrentMapArea(sRAIUnitDef* udr, float3&amp; position); // returns MapB index if &gt;=0, -1 = any mb, -2 = error(unit can not exist at this position)
+	float3 GetRandomPosition(TerrainMapArea* area);
+	bool IsHumanControled(const int&amp; unit,UnitInfo* U); // this function will crash if the 'unit' id is invalid
+
+	// used to check if the UnitDestroyed() event failed to trigger properly for units,  Work Around:  Spring-Version(v0.74b3-0.75b2)
+	bool ValidateUnit(const int&amp; unitID); // returns true if the unitID exists in-game, unitID is assumed to have been valid up to this point
+	bool ValidateUnitList(map&lt;int,UnitInfo*&gt;* UL); // returns true if at least one unit on the list is valid
+	void ValidateAllUnits();
+
+	map&lt;int,UnitInfo&gt; Units;	// Complete record of all owned units, key value = unit id
+	map&lt;int,UnitInfo*&gt; UImmobile;
+	map&lt;int,UnitInfo*&gt; UMobile;
+	map&lt;int,EnemyInfo&gt; Enemies;
+	map&lt;int,EnemyInfo*&gt; EThreat;	// These enemies have attacked our immobile units
+
+	cLogFile* l;
+	cBuilder* B;
+	cCombatManager* CM;
+	cRAIUnitDefHandler* UDH;
+	cUnitManager* UM;
+	GlobalResourceMap* RM; // = static RM
+	GlobalTerrainMap* TM; // = static TM
+
+	void DebugDrawLine(float3 StartPos, float distance, int direction, float xposoffset=0, float zposoffset=0, float yposoffset=50, int lifetime=9000, int arrow=0, float width=5.0, int group=1); // direction 0-3, counter-clock wise, 0=right
+	void DebugDrawShape(float3 CenterPos, float linelength, float width=5.0, int arrow=0, float yposoffset=50, int lifetime=9000, int sides=4, int group=1); // incomplete, sides is always 4
+
+	typedef pair&lt;int,UnitInfo*&gt; iupPair;	// used to access UImmobile,UMobile, also used by different classes
+	typedef pair&lt;int,EnemyInfo*&gt; iepPair;
+
+private:
+	void UpdateEventRemove(UpdateEvent* e);
+	void UpdateEventReorderFirst();
+	UpdateEvent* eventList[10000];
+	int eventSize;
+
+	int DebugEnemyEnterLOS;
+	int DebugEnemyLeaveLOS;
+	int DebugEnemyEnterRadar;
+	int DebugEnemyLeaveRadar;
+	int DebugEnemyDestroyedLOS;
+	int DebugEnemyDestroyedRadar;
+	int DebugEnemyEnterLOSError;
+	int DebugEnemyLeaveLOSError;
+	int DebugEnemyEnterRadarError;
+	int DebugEnemyLeaveRadarError;
+	int frame;
+
+	typedef pair&lt;int,UnitInfo&gt; iuPair;		// used to access Units
+	typedef pair&lt;int,EnemyInfo&gt; iePair;
+	void ClearLogFiles();
+	IAICallback* cb;
+	cSWeaponManager* SWM;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/RAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/README
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/README	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/README	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,42 @@
+_____________________________________________________
+
+RAI - Skirmish AI for the Spring Game Engine
+Author: Reth / Michael Vadovszki
+_____________________________________________________
+
+Forum Link:
+  <A HREF="http://spring.clan-sy.com/phpbb/viewtopic.php?t=7924">http://spring.clan-sy.com/phpbb/viewtopic.php?t=7924</A>
+
+Compiling:
+ - as of v0.76b1, the mingwlibs dependency is needed to compile an AI.
+    - <A HREF="http://spring.clan-sy.com/wiki/Engine_Development#SCONS.2FMinGW">http://spring.clan-sy.com/wiki/Engine_Development#SCONS.2FMinGW</A>
+    - <A HREF="http://spring.clan-sy.com/dl/spring-mingwlibs-v10.exe">http://spring.clan-sy.com/dl/spring-mingwlibs-v10.exe</A>
+ - while compiling,
+    - the RAI source folder was located in {spring source}/AI/Global/
+    - the mingwlibs folder was in the same directory as the
+      {spring source} directory
+
+ - CodeBlocks - I barely used this one but it should be able to compile
+   a working dll.
+    - website: <A HREF="http://www.codeblocks.org/">http://www.codeblocks.org/</A>
+ - Visual Studios 2005 - The dlls that it compiles will not work with
+   spring at this point, I now only use it as a writing aid.
+    - The project configuration starts on debug, switch it to release.
+ - DevC - the last few RAIs were compiled using this project
+   (DevC v4.9.9.2 with WinPorts GCC for Windows v4.1.1 incorporated
+   into it)
+    - website: <A HREF="http://www.bloodshed.net/devcpp.html">http://www.bloodshed.net/devcpp.html</A>
+    - updating GCC to 4.1.1 isn't a necessary step
+    - I had DevC installed on the default C directory, a dll in the
+      DevC directory was included in the project file.
+    (the following issues might have been fixed in recent windows patches)
+        - The .o files in the DevC project directory were copied directly
+          from the DevC directories to resolve a Vista/DevC bug.
+        - (Windows Vista): Compiler Options &gt; Directories &gt; Libraries:
+          Add &quot;{DevC directory}\lib\gcc\mingw32\{version#}&quot;
+
+Copyright: GPL
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License or
+    any later version.
\ No newline at end of file


Property changes on: branches/caiinterface/AI/Skirmish/RAI/README
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,109 @@
+#include &quot;SWeaponManager.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+
+cSWeaponManager::cSWeaponManager(IAICallback* callback, cRAI* global)
+{
+	G=global;
+	l=global-&gt;l;
+	cb=callback;
+}
+
+cSWeaponManager::~cSWeaponManager()
+{
+
+}
+
+void cSWeaponManager::UnitFinished(int unit, sRAIUnitDef* udr)
+{
+	if( udr-&gt;SWeapon == 0 )
+		return;
+
+	mWeapon.insert(irPair(unit,udr));
+}
+
+void cSWeaponManager::UnitDestroyed(int unit)
+{
+	if( mWeapon.find(unit) != mWeapon.end() )
+		mWeapon.erase(unit);
+}
+
+void cSWeaponManager::UnitIdle(int unit, sRAIUnitDef* udr)
+{
+	int stockPile;
+	int stockQued;
+	cb-&gt;GetProperty(unit,AIVAL_STOCKPILED,&amp;stockPile);
+	cb-&gt;GetProperty(unit,AIVAL_STOCKPILE_QUED,&amp;stockQued);
+	if( stockPile &gt; 0 &amp;&amp; udr-&gt;SWeapon-&gt;manualfire &amp;&amp; int(G-&gt;Enemies.size()) &gt;= 1+(G-&gt;UMobile.size()/25) )
+	{
+		set&lt;int&gt; Targets;
+		set&lt;int&gt; ImmobileTargets;
+		for( map&lt;int,EnemyInfo&gt;::iterator iE=G-&gt;Enemies.begin(); iE!=G-&gt;Enemies.end(); iE++ )
+		{
+			if( cb-&gt;GetUnitPos(unit).distance(G-&gt;CM-&gt;GetEnemyPosition(iE-&gt;first,&amp;iE-&gt;second)) &lt;= udr-&gt;SWeapon-&gt;range )
+			{
+				if( iE-&gt;second.ud != 0 &amp;&amp; iE-&gt;second.ud-&gt;speed == 0 )
+					ImmobileTargets.insert(iE-&gt;first);
+				else if( iE-&gt;second.inLOS || iE-&gt;second.inRadar )
+					Targets.insert(iE-&gt;first);
+			}
+		}
+
+		if( int(ImmobileTargets.size()) &gt; 0 || int(Targets.size()) &gt; 0 )
+		{
+			set&lt;int&gt;::iterator iE;
+			if( int(ImmobileTargets.size()) &gt; 0 )
+			{
+				iE = ImmobileTargets.begin();
+				for( int i=0; i &lt; rand()%int(ImmobileTargets.size()); i++ )
+					iE++;
+			}
+			else
+			{
+				iE = Targets.begin();
+				for( int i=0; i &lt; rand()%int(Targets.size()); i++ )
+					iE++;
+			}
+
+			EnemyInfo *E = &amp;G-&gt;Enemies.find(*iE)-&gt;second;
+			Command c;
+			c.id = CMD_ATTACK;
+			if( E-&gt;inLOS || E-&gt;inRadar )
+				c.params.push_back(*iE);
+			else
+			{
+				float3 Pos = G-&gt;CM-&gt;GetEnemyPosition(*iE,E);
+				c.params.push_back(Pos.x);
+				c.params.push_back(Pos.y);
+				c.params.push_back(Pos.z);
+			}
+			cb-&gt;GiveOrder(unit,&amp;c);
+			return;
+		}
+	}
+	else if( stockPile+stockQued &lt; 5 || (!udr-&gt;SWeapon-&gt;manualfire &amp;&amp; stockPile+stockQued &lt; 10) )
+	{
+		if( (G-&gt;UDH-&gt;BLMetal-&gt;UDefActive == 0 &amp;&amp; G-&gt;UDH-&gt;BLMetalL-&gt;UDefActive == 0) || 0.66*cb-&gt;GetMetalIncome() &gt; udr-&gt;SWeapon-&gt;metalcost/udr-&gt;SWeapon-&gt;reload &amp;&amp;
+			(G-&gt;UDH-&gt;BLEnergy-&gt;UDefActive == 0 &amp;&amp; G-&gt;UDH-&gt;BLEnergyL-&gt;UDefActive == 0) || 0.66*cb-&gt;GetEnergyIncome() &gt; udr-&gt;SWeapon-&gt;energycost/udr-&gt;SWeapon-&gt;reload )
+		{
+			Command c;
+			c.id = CMD_STOCKPILE;
+			cb-&gt;GiveOrder(unit, &amp;c);
+			return;
+		}
+	}
+
+	UnitInfo *UI = &amp;G-&gt;Units.find(unit)-&gt;second;
+	if( UI-&gt;udrBL-&gt;task &lt;= 1 )
+	{
+		Command c;
+		c.id = CMD_WAIT;
+		cb-&gt;GiveOrder(unit, &amp;c);
+	}
+}
+
+void cSWeaponManager::Update()
+{
+	for( map&lt;int,sRAIUnitDef*&gt;::iterator iU = mWeapon.begin(); iU!=mWeapon.end(); iU++ )
+		if( !G-&gt;IsHumanControled(iU-&gt;first,&amp;G-&gt;Units.find(iU-&gt;first)-&gt;second) )
+			UnitIdle(iU-&gt;first,iU-&gt;second);
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,38 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_STOCKWEAPON_MANAGER_H
+#define RAI_STOCKWEAPON_MANAGER_H
+
+struct sSWeaponUnitInfo;
+class cSWeaponManager;
+
+#include &quot;Builder.h&quot;
+using std::pair;
+//#include &quot;LogFile.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+
+class cSWeaponManager
+{
+public:
+	cSWeaponManager(IAICallback *callback, cRAI* global);
+	~cSWeaponManager();
+
+	void UnitFinished(int unit, sRAIUnitDef* udr);
+	void UnitDestroyed(int unit);
+	void UnitIdle(int unit, sRAIUnitDef* udr);
+	void Update();
+
+private:
+	cLogFile *l;
+	IAICallback* cb;
+	cRAI* G;
+	map&lt;int,sRAIUnitDef*&gt; mWeapon;
+	typedef pair&lt;int,sRAIUnitDef*&gt; irPair;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/SWeaponManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,1814 @@
+#include &quot;UnitDefHandler.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+
+// ------------------------------------------------------------------------------------------------
+
+sRAIUnitDefBL::sRAIUnitDefBL(sRAIUnitDef* RAIud, sRAIBuildList* BuildList, float Efficiency, int Task)
+{
+	RUD=RAIud;
+	RUD-&gt;List[RUD-&gt;ListSize++]=this;
+	RBL=BuildList;
+	RBL-&gt;UDef[RBL-&gt;UDefSize++]=this;
+	if( Efficiency &gt; 0 )
+		efficiency = Efficiency;
+	else
+		efficiency = -1;
+	if( Task &gt; 0 )
+		task = Task;
+	else
+		task = -1;
+};
+sRAIUnitDefBL::~sRAIUnitDefBL()
+{
+	for(int iUD=0; iUD&lt;RBL-&gt;UDefSize; iUD++ )
+	{
+		if( RBL-&gt;UDef[iUD] == this )
+		{
+			RBL-&gt;UDefSize--;
+			if( iUD &lt; RBL-&gt;UDefSize )
+				RBL-&gt;UDef[iUD]=RBL-&gt;UDef[RBL-&gt;UDefSize];
+			iUD=RBL-&gt;UDefSize; // end loop
+		}
+	}
+	for(int iBL=0; iBL&lt;RUD-&gt;ListSize; iBL++ )
+	{
+		if( RUD-&gt;List[iBL] == this )
+		{
+			RUD-&gt;ListSize--;
+			if( iBL &lt; RUD-&gt;ListSize )
+				RUD-&gt;List[iBL]=RUD-&gt;List[RUD-&gt;ListSize];
+			iBL=RUD-&gt;ListSize; // end loop
+		}
+	}
+};
+
+// ------------------------------------------------------------------------------------------------
+
+sRAIUnitDef::sRAIUnitDef(const UnitDef *unitdef, IAICallback* cb, GlobalResourceMap* RM, GlobalTerrainMap* TM, float EnergyToMetalRatio, cLogFile *l, float MaxFiringRange)
+{
+	ud=unitdef;
+//*l&lt;&lt;&quot;\n   &quot;+ud-&gt;humanName+&quot;(&quot;+ud-&gt;name+&quot;)(&quot;&lt;&lt;ud-&gt;id&lt;&lt;&quot;)&quot;;
+//	if( ud-&gt;canAssist ) *l&lt;&lt;&quot; (ud-&gt;canAssist)&quot;;
+//	if( ud-&gt;canBuild ) *l&lt;&lt;&quot; (ud-&gt;canBuild)&quot;;
+//	if( ud-&gt;canReclaim ) *l&lt;&lt;&quot; (ud-&gt;canReclaim)&quot;;
+//	if( ud-&gt;canResurrect ) *l&lt;&lt;&quot; (ud-&gt;canResurrect)&quot;;
+//	if( ud-&gt;canRepair ) *l&lt;&lt;&quot; (ud-&gt;canRepair)&quot;;
+//	if( ud-&gt;buildSpeed &gt; 0 ) { *l&lt;&lt;&quot; ud-&gt;buildSpeed=&quot;&lt;&lt;ud-&gt;buildSpeed; }
+//	if( ud-&gt;buildDistance &gt; 0 ) { *l&lt;&lt;&quot; ud-&gt;buildDistance=&quot;&lt;&lt;ud-&gt;buildDistance; }
+//	if( ud-&gt;buildOptions.size() &gt; 0) { *l&lt;&lt;&quot; ud-&gt;buildOptions.size()=&quot;&lt;&lt;ud-&gt;buildOptions.size(); }
+//	if( ud-&gt;stealth ) *l&lt;&lt;&quot; (ud-&gt;stealth)&quot;;
+//	if( ud-&gt;canKamikaze ) *l&lt;&lt;&quot; (ud-&gt;canKamikaze)&quot;;
+//	if( ud-&gt;turnRate &gt; 0 ) *l&lt;&lt;&quot; ud-&gt;turnRate=&quot;&lt;&lt;ud-&gt;turnRate;
+//	*l&lt;&lt;&quot; ud-&gt;armorType=&quot;&lt;&lt;ud-&gt;armorType;
+//	if( ud-&gt;extractsMetal &gt; 0) { *l&lt;&lt;&quot; extractsMetal=&quot;&lt;&lt;ud-&gt;extractsMetal; }
+//	if( ud-&gt;extractRange &gt; 0) { *l&lt;&lt;&quot; extractRange=&quot;&lt;&lt;ud-&gt;extractRange; }
+//	*l&lt;&lt;&quot; ud-&gt;windGenerator=&quot;&lt;&lt;ud-&gt;windGenerator;
+//	*l&lt;&lt;&quot; ud-&gt;tidalGenerator=&quot;&lt;&lt;ud-&gt;tidalGenerator;
+//	*l&lt;&lt;&quot; ud-&gt;energyUpkeep=&quot;&lt;&lt;ud-&gt;energyUpkeep;
+//	*l&lt;&lt;&quot; ud-&gt;ysize=&quot;&lt;&lt;ud-&gt;ysize;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalDecaySpeed=&quot;&lt;&lt;ud-&gt;buildingDecalDecaySpeed;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalSizeX=&quot;&lt;&lt;ud-&gt;buildingDecalSizeX;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalSizeY=&quot;&lt;&lt;ud-&gt;buildingDecalSizeY;
+//	*l&lt;&lt;&quot; ud-&gt;buildingDecalType=&quot;&lt;&lt;ud-&gt;buildingDecalType;
+//	*l&lt;&lt;&quot; ud-&gt;aihint=&quot;&lt;&lt;ud-&gt;aihint;
+//	*l&lt;&lt;&quot; ud-&gt;category=&quot;&lt;&lt;ud-&gt;category;
+//	*l&lt;&lt;&quot; ud-&gt;categoryString=&quot;&lt;&lt;ud-&gt;categoryString;
+//	*l&lt;&lt;&quot; ud-&gt;wantedHeight=&quot;&lt;&lt;ud-&gt;wantedHeight;
+//	*l&lt;&lt;&quot; ud-&gt;speed=&quot;&lt;&lt;ud-&gt;speed;
+//	*l&lt;&lt;&quot; ud-&gt;mass=&quot;&lt;&lt;ud-&gt;mass;
+//	*l&lt;&lt;&quot; ud-&gt;transportMass=&quot;&lt;&lt;ud-&gt;transportMass;
+// What is ud-&gt;transportSize?
+//	*l&lt;&lt;&quot; xsize=&quot;&lt;&lt;ud-&gt;xsize;
+//	*l&lt;&lt;&quot; ysize=&quot;&lt;&lt;ud-&gt;ysize;
+//	*l&lt;&lt;&quot; ud-&gt;canhover=&quot;&lt;&lt;ud-&gt;canhover;
+//	*l&lt;&lt;&quot; ud-&gt;canfly=&quot;&lt;&lt;ud-&gt;canfly;
+//	*l&lt;&lt;&quot; cb-&gt;GetUnitDefHeight(ud-&gt;id)=&quot;&lt;&lt;cb-&gt;GetUnitDefHeight(ud-&gt;id);
+//	if( ud-&gt;canSubmerge ) *l&lt;&lt;&quot; (canSubmerge)&quot;;
+//	*l&lt;&lt;&quot; maxSlope=&quot;&lt;&lt;ud-&gt;maxSlope;
+//if( ud-&gt;movedata != 0 ) *l&lt;&lt;&quot; pathType=&quot;&lt;&lt;ud-&gt;movedata-&gt;pathType&lt;&lt;&quot; maxSlope=&quot;&lt;&lt;ud-&gt;movedata-&gt;maxSlope&lt;&lt;&quot; depth=&quot;&lt;&lt;ud-&gt;movedata-&gt;depth&lt;&lt;&quot; depthMod=&quot;&lt;&lt;ud-&gt;movedata-&gt;depthMod;
+//	*l&lt;&lt;&quot; maxWaterDepth=&quot;&lt;&lt;ud-&gt;maxWaterDepth;
+//	*l&lt;&lt;&quot; minWaterDepth=&quot;&lt;&lt;ud-&gt;minWaterDepth;
+//	*l&lt;&lt;&quot; deathExplosion=&quot;&lt;&lt;ud-&gt;deathExplosion;
+//	*l&lt;&lt;&quot; energyStorage=&quot;&lt;&lt;ud-&gt;energyStorage;
+//	*l&lt;&lt;&quot; ud-&gt;maxThisUnit=&quot;&lt;&lt;ud-&gt;maxThisUnit;
+//	*l&lt;&lt;&quot; ud-&gt;losRadius=&quot;&lt;&lt;ud-&gt;losRadius;
+//	*l&lt;&lt;&quot; ud-&gt;health=&quot;&lt;&lt;ud-&gt;health;
+//	*l&lt;&lt;&quot; ud-&gt;energyCost=&quot;&lt;&lt;ud-&gt;energyCost;
+//	*l&lt;&lt;&quot; ud-&gt;metalCost=&quot;&lt;&lt;ud-&gt;metalCost;
+//	*l&lt;&lt;&quot; ud-&gt;buildTime=&quot;&lt;&lt;ud-&gt;buildTime;
+//	*l&lt;&lt;&quot; ud-&gt;maxThisUnit=&quot;&lt;&lt;ud-&gt;maxThisUnit;
+	ListSize=0;
+	SetUnitLimit(ud-&gt;maxThisUnit);
+	CanBuild=false;
+	CanBeBuilt=false;
+	HasPrerequisite=false;
+	Disabled=false;
+	RBUnitLimit=false;
+	RBCost=true;
+	RBPrereq=true;
+	DGun=0;
+	SWeapon=0;
+	UnitConstructs=0;
+	IsBomber=false;
+	OnOffMetalDifference= -ud-&gt;metalUpkeep+ud-&gt;makesMetal;
+	OnOffEnergyDifference= -ud-&gt;energyUpkeep;
+	if( ud-&gt;extractsMetal &gt; 0 )
+		OnOffMetalDifference += RM-&gt;averageMetalSite*ud-&gt;extractsMetal;
+	if( ud-&gt;tidalGenerator &gt; 0 )
+		OnOffEnergyDifference += ud-&gt;tidalGenerator*cb-&gt;GetTidalStrength();
+	if( ud-&gt;windGenerator &gt; 0 &amp;&amp; (cb-&gt;GetMaxWind()-cb-&gt;GetMinWind())/2 + cb-&gt;GetMinWind() &gt;= 11 )
+		OnOffEnergyDifference += (cb-&gt;GetMaxWind()-cb-&gt;GetMinWind())/2 + cb-&gt;GetMinWind();
+	MetalDifference= OnOffMetalDifference +ud-&gt;metalMake;
+	EnergyDifference=OnOffEnergyDifference+ud-&gt;energyMake;
+	if( EnergyDifference &lt; 0 &amp;&amp; EnergyToMetalRatio*MetalDifference+EnergyDifference &lt; 0 )
+		HighEnergyDemand=true;
+	else
+		HighEnergyDemand=false;
+//	*l&lt;&lt;&quot; EnergyDifference=&quot;&lt;&lt;EnergyDifference;
+//	*l&lt;&lt;&quot; MetalDifference=&quot;&lt;&lt;MetalDifference;
+
+	MetalPCost  =  0.0080f*ud-&gt;metalCost  + 0.00080f*ud-&gt;metalCost *0.01f*float(rand()%101);
+	if( MetalPCost &lt; MetalDifference &amp;&amp; MetalPCost &gt; 0 )
+		MetalPCost = MetalDifference;
+	EnergyPCost = (0.0022f*ud-&gt;energyCost + 0.00022f*ud-&gt;energyCost*0.01f*float(rand()%101))*EnergyToMetalRatio;
+	if( EnergyPCost &lt; EnergyDifference &amp;&amp; ud-&gt;energyCost &gt; EnergyDifference )
+		EnergyPCost = EnergyDifference;
+	if( EnergyPCost &lt; 1.5*-EnergyDifference )
+		EnergyPCost = 1.5*-EnergyDifference;
+//	*l&lt;&lt;&quot; EnergyPCost=&quot;&lt;&lt;EnergyPCost;
+//	*l&lt;&lt;&quot; MetalPCost=&quot;&lt;&lt;MetalPCost;
+
+	if( ud-&gt;speed &gt; 0 )
+		CloakMaxEnergyDifference = -ud-&gt;cloakCostMoving;
+	else
+		CloakMaxEnergyDifference = -ud-&gt;cloakCost;
+
+	WeaponGuardRange = 0;
+	WeaponEnergyDifference = 0;
+	WeaponMaxEnergyCost = 0;
+	for(std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW=ud-&gt;weapons.begin(); iW!=ud-&gt;weapons.end(); iW++)
+	{
+		if( iW-&gt;def-&gt;reload!=0 )
+		{
+			WeaponEnergyDifference -= int(iW-&gt;def-&gt;energycost/iW-&gt;def-&gt;reload);
+			if( WeaponMaxEnergyCost &lt; iW-&gt;def-&gt;energycost )
+				WeaponMaxEnergyCost = iW-&gt;def-&gt;energycost;
+		}
+//		*l&lt;&lt;&quot; W=&quot;&lt;&lt;iW-&gt;def-&gt;name;
+//		*l&lt;&lt;&quot; def-&gt;onlyTarget=&quot;&lt;&lt;iW-&gt;def-&gt;onlyTargetCategory;
+//		*l&lt;&lt;&quot; onlyTarget=&quot;&lt;&lt;iW-&gt;onlyTargetCat;
+//		*l&lt;&lt;&quot; badTarget=&quot;&lt;&lt;iW-&gt;badTargetCat;
+//		if( iW-&gt;def-&gt;waterweapon ) *l&lt;&lt;&quot;(Water)&quot;;
+//		if( iW-&gt;def-&gt;stockpile ) *l&lt;&lt;&quot;(Stock)&quot;;
+//		if( iW-&gt;def-&gt;manualfire ) *l&lt;&lt;&quot;(Manual)&quot;;
+//		if( iW-&gt;def-&gt;coverageRange &gt; 0 ) *l&lt;&lt;&quot;(c=&quot;&lt;&lt;iW-&gt;def-&gt;coverageRange&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;shieldRadius &gt; 0 ) *l&lt;&lt;&quot;(sh=&quot;&lt;&lt;iW-&gt;def-&gt;shieldRadius&lt;&lt;&quot;)&quot;;
+//		if( *iW-&gt;def-&gt;damages.GetDefaultDamage() &gt; 0 ) *l&lt;&lt;&quot;(d=&quot;&lt;&lt;*iW-&gt;def-&gt;damages.GetDefaultDamage()&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;salvosize &gt; 0 ) *l&lt;&lt;&quot;(sa=&quot;&lt;&lt;iW-&gt;def-&gt;salvosize&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;reload &gt; 0 ) *l&lt;&lt;&quot;(re=&quot;&lt;&lt;iW-&gt;def-&gt;reload&lt;&lt;&quot;)&quot;;
+//		if( iW-&gt;def-&gt;range &gt; 0 ) *l&lt;&lt;&quot;(ra=&quot;&lt;&lt;iW-&gt;def-&gt;range&lt;&lt;&quot;)&quot;;
+//		*l&lt;&lt;&quot; s=&quot;&lt;&lt;iW-&gt;def-&gt;salvosize;
+//		*l&lt;&lt;&quot; selfExplode=&quot;&lt;&lt;iW-&gt;def-&gt;selfExplode;
+//		*l&lt;&lt;&quot; areaOfEffect=&quot;&lt;&lt;iW-&gt;def-&gt;areaOfEffect;
+		if( ud-&gt;canDGun &amp;&amp; iW-&gt;def-&gt;manualfire )
+		{
+			DGun=iW-&gt;def;
+//			*l&lt;&lt;&quot;(DGun)&quot;;
+		}
+		if( iW-&gt;def-&gt;stockpile )
+		{
+			SWeapon=iW-&gt;def;
+//			*l&lt;&lt;&quot;(SWeapon)&quot;;
+		}
+		if( iW-&gt;def-&gt;dropped )
+			IsBomber = true;
+
+		if( ud-&gt;speed == 0 &amp;&amp; iW-&gt;def-&gt;range &gt; 250 &amp;&amp; iW-&gt;def-&gt;coverageRange == 0 &amp;&amp; (!iW-&gt;def-&gt;manualfire || iW-&gt;def-&gt;range &lt; MaxFiringRange ) )
+		{
+			float NewGuardRange = iW-&gt;def-&gt;range;
+			if( iW-&gt;def-&gt;range &gt; 550 )
+			{
+				NewGuardRange = 550.0f + 0.25*(iW-&gt;def-&gt;range-550.0f);
+				if( NewGuardRange &gt; 1100.0f )
+					NewGuardRange = 1100.0f;
+			}
+			if( WeaponGuardRange &lt; NewGuardRange )
+				WeaponGuardRange = NewGuardRange;
+		}
+//		if( iW-&gt;def-&gt;selfExplode )
+//			Destruct=iW-&gt;def;
+	}
+
+	SetBestWeaponEff(&amp;WeaponLandEff,1,MaxFiringRange);
+	SetBestWeaponEff(&amp;WeaponAirEff,2,MaxFiringRange);
+	SetBestWeaponEff(&amp;WeaponSeaEff,3,MaxFiringRange);
+	if( ud-&gt;kamikazeDist &gt; 0 )
+	{
+		if( ud-&gt;minWaterDepth &lt; 0 &amp;&amp; WeaponLandEff.BestRange &lt; ud-&gt;kamikazeDist )
+			WeaponLandEff.BestRange = ud-&gt;kamikazeDist;
+		if( ud-&gt;movedata != 0 &amp;&amp; -ud-&gt;movedata-&gt;depth &lt; 0 &amp;&amp; WeaponSeaEff.BestRange &lt; ud-&gt;kamikazeDist )
+			WeaponSeaEff.BestRange = ud-&gt;kamikazeDist;
+	}
+
+//	*l&lt;&lt;&quot;(&quot;);
+//	if( WeaponLandEff.BestRange &gt; 0 ) *l&lt;&lt;&quot;L&quot;;
+//	if( WeaponAirEff.BestRange &gt; 0 ) *l&lt;&lt;&quot;A&quot;;
+//	if( WeaponSeaEff.BestRange &gt; 0 ) *l&lt;&lt;&quot;S&quot;;
+//	*l&lt;&lt;&quot; WeaponGuardRange=&quot;&lt;&lt;WeaponGuardRange;
+//	*l&lt;&lt;&quot; BestWeaponRange=&quot;&lt;&lt;BestWeaponRange&lt;&lt;&quot; &quot;;
+//	*l&lt;&lt;&quot;)&quot;;
+
+	mobileType = 0;
+	immobileType = 0;
+
+	if( ud-&gt;canfly ) {}
+	else if( ud-&gt;movedata == 0 ) // for immobile units
+	{
+		immobileType = TM-&gt;udImmobileType.find(ud-&gt;id)-&gt;second;
+		if( ud-&gt;needGeo )
+		{
+			int NewUnitLimit=0;
+			for( int i=0; i&lt;RM-&gt;RSize[1]; i++ )
+				if( RM-&gt;R[1][i]-&gt;options.find(ud-&gt;id) != RM-&gt;R[1][i]-&gt;options.end() )
+					NewUnitLimit++;
+			if( NewUnitLimit == 0 )
+			{
+				Disabled = true;
+				CheckBuildOptions();
+			}
+		}
+		else if( ud-&gt;extractsMetal &gt; 0 &amp;&amp; !RM-&gt;isMetalMap )
+		{
+			int NewUnitLimit=0;
+			for( int i=0; i&lt;RM-&gt;RSize[0]; i++ )
+				if( RM-&gt;R[0][i]-&gt;options.find(ud-&gt;id) != RM-&gt;R[0][i]-&gt;options.end() )
+					NewUnitLimit++;
+			if( NewUnitLimit == 0 )
+			{
+				Disabled = true;
+				CheckBuildOptions();
+			}
+		}
+		else
+		{
+			// If a unit can build mobile units then it will inherit mobileType from it's options
+			map&lt;TerrainMapMobileType*,int&gt; MTcount;
+			typedef pair&lt;TerrainMapMobileType*,int&gt; MTpair;
+			for( map&lt;int,string&gt;::const_iterator iB=ud-&gt;buildOptions.begin(); iB!=ud-&gt;buildOptions.end(); iB++ )
+			{
+				if( cb-&gt;GetUnitDef(iB-&gt;second.c_str()) == 0 ) // Work-Around(Mod: ? Don't Remember):  Spring-Version(?)
+				{
+					cb-&gt;SendTextMsg(&quot;WARNING: Mod Unit Definition Missing.&quot;,0);
+					*l&lt;&lt;&quot;\nWARNING: No Unit Definition was found for '&quot;&lt;&lt;iB-&gt;second.c_str()&lt;&lt;&quot;'. &quot;;
+				}
+				else
+				{
+					const UnitDef* ud = cb-&gt;GetUnitDef(iB-&gt;second.c_str());
+					if( ud-&gt;movedata != 0 &amp;&amp; TM-&gt;udMobileType.find(ud-&gt;id)-&gt;second-&gt;areaSize &gt; 0 )
+					{
+						TerrainMapMobileType *MT = TM-&gt;udMobileType.find(ud-&gt;id)-&gt;second;
+						if( MTcount.find(MT) != MTcount.end() )
+							MTcount.find(MT)-&gt;second++;
+						else
+							MTcount.insert(MTpair(MT,1));
+					}
+				}
+			}
+			int iMost = 0;
+			for( map&lt;TerrainMapMobileType*,int&gt;::iterator iM=MTcount.begin(); iM!=MTcount.end(); iM++ )
+				if( mobileType == 0 || iM-&gt;second &gt; iMost )
+				{
+					mobileType = iM-&gt;first;
+					iMost = iM-&gt;second;
+				}
+			if( (mobileType!=0 &amp;&amp; !mobileType-&gt;typeUsable) ||
+				(!immobileType-&gt;typeUsable &amp;&amp; (mobileType==0 || immobileType-&gt;sector.size()&lt;100)) )
+			{
+				Disabled = true;
+				CheckBuildOptions();
+			}
+		}
+	}
+	else // for mobile units
+	{
+		mobileType = TM-&gt;udMobileType.find(ud-&gt;id)-&gt;second;
+		if( !mobileType-&gt;typeUsable )
+		{
+			Disabled = true;
+			CheckBuildOptions();
+		}
+	}
+}
+
+int sRAIUnitDef::GetPrerequisite()
+{
+	int iBest=-1;
+	vector&lt;int&gt; vTempIDList; // Unit ID
+	set&lt;int&gt; sTemp; // searchable record of vTempIDList contents
+	for( map&lt;int,sRAIPrerequisite&gt;::iterator iP=AllPrerequisiteOptions.begin(); iP!=AllPrerequisiteOptions.end(); iP++ )
+		if( int(iP-&gt;second.udr-&gt;UnitsActive.size()) &gt; 0 )
+		{
+			if( iBest == -1 || iBest &gt; iP-&gt;second.buildLine ) // New or Better buildline was found
+			{
+				iBest = iP-&gt;second.buildLine;
+				vTempIDList.clear();
+				sTemp.clear();
+			}
+			if( iBest == iP-&gt;second.buildLine )
+			{
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=iP-&gt;second.udr-&gt;BuildOptions.begin(); iB!=iP-&gt;second.udr-&gt;BuildOptions.end(); iB++ )
+					if( iB-&gt;second-&gt;CanBeBuilt &amp;&amp; AllPrerequisiteOptions.find(iB-&gt;first) != AllPrerequisiteOptions.end() &amp;&amp; AllPrerequisiteOptions.find(iB-&gt;first)-&gt;second.buildLine == iBest-1 &amp;&amp; sTemp.find(iB-&gt;first)==sTemp.end() &amp;&amp; iB-&gt;second-&gt;GetBuildList(&quot;Constructor&quot;) != 0 &amp;&amp; iB-&gt;second-&gt;GetBuildList(&quot;Constructor&quot;)-&gt;udIndex &lt; iB-&gt;second-&gt;GetBuildList(&quot;Constructor&quot;)-&gt;RBL-&gt;UDefActiveTemp )
+					{
+						vTempIDList.push_back(iB-&gt;first);
+						sTemp.insert(iB-&gt;first);
+					}
+			}
+		}
+
+	if( int(vTempIDList.size()) &gt; 0 )
+	{
+		int i=rand()%int(vTempIDList.size());
+		return AllPrerequisiteOptions.find(vTempIDList.at(i))-&gt;first;
+	}
+
+	return ud-&gt;id;
+};
+
+int sRAIUnitDef::GetPrerequisiteNewBuilder()
+{
+	vector&lt;int&gt; vTempIDList;
+	for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=PrerequisiteOptions.begin(); iP!=PrerequisiteOptions.end(); iP++ )
+	{
+		if( iP-&gt;second-&gt;CanBeBuilt &amp;&amp; (iP-&gt;second-&gt;ListSize &gt; 1 || iP-&gt;second-&gt;List[0]-&gt;efficiency &gt;= 0.5 || PrerequisiteOptions.size() == 1 ) )
+		{
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iP2=iP-&gt;second-&gt;PrerequisiteOptions.begin(); iP2!=iP-&gt;second-&gt;PrerequisiteOptions.end(); iP2++ )
+			{
+				if( int(iP2-&gt;second-&gt;UnitsActive.size()) &gt; 0 )
+				{
+					vTempIDList.push_back(iP-&gt;first);
+					break;
+				}
+			}
+		}
+	}
+	if( int(vTempIDList.size()) &gt; 0 )
+	{
+		int i=rand()%int(vTempIDList.size());
+		return PrerequisiteOptions.find(vTempIDList.at(i))-&gt;first;
+	}
+
+	return GetPrerequisite();
+}
+
+void sRAIUnitDef::SetUnitLimit(int num)
+{
+	UnitLimit[0]=num;
+	if( UnitLimit[0] &gt; ud-&gt;maxThisUnit )
+		UnitLimit[0] = ud-&gt;maxThisUnit;
+	CheckUnitLimit();
+}
+
+void sRAIUnitDef::SetULConstructs(int num)
+{
+	UnitLimit[1] = num;
+	UnitLimit[0] = UnitLimit[1] + int(UnitsActive.size()) + int(UnitConstructsActive.size());
+	SetUnitLimit(UnitLimit[0]);
+}
+
+sRAIUnitDefBL* sRAIUnitDef::GetBuildList(string Name)
+{
+	for( int iBL=0; iBL&lt;ListSize; iBL++ )
+		if( List[iBL]-&gt;RBL-&gt;Name == Name )
+			return List[iBL];
+	return 0;
+}
+
+void sRAIUnitDef::CheckUnitLimit()
+{
+	if( int(UnitsActive.size())+UnitConstructs &gt;= UnitLimit[0] )
+	{
+		if( !RBUnitLimit )
+		{
+			RBUnitLimit = true;
+			CheckBuildOptions();
+		}
+	}
+	else
+	{
+		if( RBUnitLimit )
+		{
+			RBUnitLimit = false;
+			CheckBuildOptions();
+		}
+	}
+}
+
+void sRAIUnitDef::CheckBuildOptions()
+{
+	bool CouldBuild = CanBuild;
+	CanBuild = int(UnitsActive.size()) &gt; 0;
+	if( CouldBuild != CanBuild )
+	{
+		if( CanBuild )
+		{
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+				if( !iB-&gt;second-&gt;HasPrerequisite )
+					iB-&gt;second-&gt;HasPrerequisite = true;
+		}
+		else
+		{
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+			{
+				bool StillHasPrereq = false;
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=iB-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=iB-&gt;second-&gt;PrerequisiteOptions.end(); iP++ )
+				{
+					if( iP-&gt;second-&gt;CanBuild )
+					{
+						StillHasPrereq = true;
+						break;
+					}
+				}
+				if( !StillHasPrereq )
+				{
+					iB-&gt;second-&gt;HasPrerequisite = false;
+				}
+			}
+		}
+	}
+
+	bool CouldBeBuilt = CanBeBuilt;
+	CanBeBuilt = !(Disabled || RBUnitLimit || RBCost || RBPrereq);
+	if( CouldBeBuilt != CanBeBuilt )
+	{
+		for( int i=0; i&lt;ListSize; i++ )
+		{
+			if( CanBeBuilt )
+			{
+				// Enabling
+				List[i]-&gt;RBL-&gt;Disable(List[i]-&gt;udIndex,false);
+			}
+			else
+			{
+				// Disabling
+				List[i]-&gt;RBL-&gt;Disable(List[i]-&gt;udIndex);
+			}
+		}
+	}
+
+	if( CouldBuild || CouldBeBuilt != CanBuild || CanBeBuilt )
+	{
+		if( CanBuild || CanBeBuilt )
+		{
+			// Enabling
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+			{
+				if( iB-&gt;second-&gt;RBPrereq )
+				{
+					iB-&gt;second-&gt;RBPrereq = false;
+					iB-&gt;second-&gt;CheckBuildOptions();
+				}
+			}
+		}
+		else
+		{
+			// Disabling
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=BuildOptions.begin(); iB!=BuildOptions.end(); iB++ )
+			{
+				if( !iB-&gt;second-&gt;RBPrereq )
+				{
+					bool prereq = false;
+					for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=iB-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=iB-&gt;second-&gt;PrerequisiteOptions.end(); iP++ )
+					{
+						if( iP-&gt;second-&gt;CanBuild || iP-&gt;second-&gt;CanBeBuilt )
+						{
+							prereq = true;
+							break;
+						}
+					}
+					if( !prereq )
+					{
+						iB-&gt;second-&gt;RBPrereq = true;
+						iB-&gt;second-&gt;CheckBuildOptions();
+					}
+				}
+			}
+		}
+	}
+}
+
+bool sRAIUnitDef::IsCategory(string category)
+{
+	for( int i=0; i&lt;=int(ud-&gt;categoryString.size()-category.size()); i++ )
+	{
+		bool found = true;
+		for( int c = 0; c &lt; int(category.size()); c++ )
+			if( ud-&gt;categoryString.at(i+c) != category.at(c) )
+			{
+				found = false;
+				i = int(ud-&gt;categoryString.size()); // end loop
+				c = int(category.size()); // end loop
+			}
+		if( found )
+			return true;
+	}
+	return false;
+}
+
+bool sRAIUnitDef::IsNano()
+{
+	if( int(BuildOptions.size()) == 0 &amp;&amp; ud-&gt;buildDistance &gt; 0 &amp;&amp; ud-&gt;buildSpeed &gt; 0 )
+		return true;
+	return false;
+}
+
+bool sRAIUnitDef::CheckWeaponType(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator udw, int type)
+{
+	switch( type )
+	{
+	case 1: // Land
+		{
+			if( udw-&gt;def-&gt;waterweapon )
+				return false;
+		}
+		break;
+	case 2: // Air
+		{
+			if( udw-&gt;def-&gt;waterweapon )
+				return false;
+		}
+		break;
+	case 3: // Sea
+		{
+			if( !udw-&gt;def-&gt;waterweapon )
+				return false;
+		}
+		break;
+	}
+	return true;
+}
+
+void sRAIUnitDef::SetBestWeaponEff(sWeaponEfficiency *we, int type, float MaxFiringRange)
+{
+	float fRange=-1;
+	float fVal=0;
+	for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW=ud-&gt;weapons.begin(); iW!=ud-&gt;weapons.end(); iW++)
+	{
+		if( CheckWeaponType(iW,type) )
+		{
+			float fRangeTemp=iW-&gt;def-&gt;range;
+			if( fRangeTemp &gt; MaxFiringRange )
+				fRangeTemp = MaxFiringRange;
+
+			float fValTemp=0;
+			for(std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW2=ud-&gt;weapons.begin(); iW2!=ud-&gt;weapons.end(); iW2++)
+			{
+				if( CheckWeaponType(iW,type) )
+				{
+					float fRange=iW2-&gt;def-&gt;range;
+					if( fRange &gt; MaxFiringRange )
+						fRange = MaxFiringRange;
+					if( fRange &gt;= fRangeTemp )
+						fValTemp+=iW2-&gt;def-&gt;damages.GetDefaultDamage()*fRangeTemp/iW2-&gt;def-&gt;reload;
+					if( fRangeTemp &gt; ud-&gt;losRadius )
+						fValTemp*=0.5;
+				}
+			}
+
+			if( fRange == -1 || fValTemp&gt;fVal )
+			{
+				fRange=fRangeTemp;
+				fVal=fValTemp;
+			}
+		}
+	}
+
+	we-&gt;BestRange = fRange;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+sRAIBuildList::sRAIBuildList(int MaxDefSize, cRAIUnitDefHandler *UDRHandler)
+{
+	UDR = UDRHandler;
+	index = UDR-&gt;BLSize;
+	UDef = new sRAIUnitDefBL*[MaxDefSize];
+	UDefSize=0;
+	UDefActive=0;
+	UDefActiveTemp=0;
+	priority=-1;
+	minUnits=0;
+	minEfficiency=1.0;
+	unitsActive=0;
+	Name = &quot;Undefined&quot;;
+}
+
+sRAIBuildList::~sRAIBuildList()
+{
+	for(int i=0; i&lt;UDefSize; i++)
+		delete UDef[i];
+	delete [] UDef;
+}
+
+void sRAIBuildList::Disable(int udIndex, bool value)
+{
+	if( value == true )
+	{
+		UDefActive--;
+		if( UDefActive == 0 )
+		{
+			UDR-&gt;BLActive--;
+			UDR-&gt;BLSwitch(index,UDR-&gt;BLActive);
+		}
+	}
+	UDefSwitch(udIndex,UDefActive);
+	if( value == false )
+	{
+		UDefActive++;
+		if( UDefActive == 1 )
+		{
+			UDR-&gt;BLSwitch(index,UDR-&gt;BLActive);
+			UDR-&gt;BLActive++;
+		}
+	}
+}
+
+void sRAIBuildList::UDefSwitch(int index1, int index2)
+{
+	sRAIUnitDefBL *pRUD = UDef[index1];
+	UDef[index1] = UDef[index2];
+	UDef[index2] = pRUD;
+	UDef[index1]-&gt;udIndex=index1;
+	UDef[index2]-&gt;udIndex=index2;
+}
+
+// ------------------------------------------------------------------------------------------------
+
+cRAIUnitDefHandler::cRAIUnitDefHandler(IAICallback* cb, GlobalResourceMap *RM, GlobalTerrainMap* TM, cLogFile *log)
+{
+	l=log;
+	const UnitDef **udList = new const UnitDef*[cb-&gt;GetNumUnitDefs()];
+	cb-&gt;GetUnitDefList(udList);
+	int udSize=cb-&gt;GetNumUnitDefs();
+
+	*l&lt;&lt;&quot;\n Reading All Unit Definitions (Frame=&quot;&lt;&lt;cb-&gt;GetCurrentFrame()&lt;&lt;&quot;) ...&quot;;
+	for( int iud=cb-&gt;GetNumUnitDefs()-1; iud&gt;=0; iud-- )
+	{
+		if( udList[iud] == 0 ) // Work-around: War Alien VS Human v1.0 (as well as other possible mods)
+		{
+			*l&lt;&lt;&quot;\n  WARNING: (unitdef-&gt;id=&quot;&lt;&lt;iud+1&lt;&lt;&quot;) Mod UnitDefList[&quot;&lt;&lt;iud&lt;&lt;&quot;] = 0&quot;;
+			udSize--;
+			udList[iud] = udList[udSize];
+		}
+	}
+
+	AverageConstructSpeed=0;
+	float fMetalCostTotal=0;
+	float fEnergyCostTotal=0;
+	int Constructs=0;
+	for( int iud=0; iud&lt;udSize; iud++ )
+	{
+		const UnitDef* ud=udList[iud];
+		fMetalCostTotal+=ud-&gt;metalCost;
+		fEnergyCostTotal+=ud-&gt;energyCost;
+		if( ud-&gt;canBuild )
+		{
+			AverageConstructSpeed+=ud-&gt;buildSpeed;
+			Constructs++;
+		}
+	}
+	if( fMetalCostTotal == 0 )
+	{
+		fMetalCostTotal = 1;
+		*l&lt;&lt;&quot;\n  No Metal Usage.&quot;;
+	}
+	if( fEnergyCostTotal == 0 )
+	{
+		fEnergyCostTotal = 1;
+		*l&lt;&lt;&quot;\n  No Energy Usage.&quot;;
+	}
+	EnergyToMetalRatio = fEnergyCostTotal/fMetalCostTotal;
+	if( EnergyToMetalRatio &gt; 40.0f ) // having this too high only causes problems with the cost limits
+		EnergyToMetalRatio = 40.0f;
+
+	*l&lt;&lt;&quot;\n  Average Metal Cost = &quot;&lt;&lt;fMetalCostTotal/udSize;
+	*l&lt;&lt;&quot;\n  Average Energy Cost = &quot;&lt;&lt;fEnergyCostTotal/udSize;
+	*l&lt;&lt;&quot;\n  Energy to Metal Ratio = &quot;&lt;&lt;EnergyToMetalRatio;
+
+	if( Constructs == 0 )
+	{
+		AverageConstructSpeed = 1;
+		*l&lt;&lt;&quot;\n  No Constructors Detected ...&quot;;
+	}
+	else
+	{
+		AverageConstructSpeed/=Constructs;
+		*l&lt;&lt;&quot;\n  Average Construction Speed = &quot;&lt;&lt;AverageConstructSpeed;
+	}
+
+	float MaxFiringRange=8.0*(cb-&gt;GetMapWidth()-1.0+cb-&gt;GetMapHeight()-1.0)/2.0;
+	typedef pair&lt;int,sRAIUnitDef&gt; iuPair;
+	for( int iud=0; iud&lt;udSize; iud++ )
+	{
+		const UnitDef* ud=udList[iud];
+		UDR.insert(iuPair(ud-&gt;id,*new sRAIUnitDef(ud,cb,RM,TM,EnergyToMetalRatio,l,MaxFiringRange)));
+	}
+	delete [] udList;
+
+	*l&lt;&lt;&quot;\n Reading UnitDef Build Options ...&quot;;
+	typedef pair&lt;int,sRAIUnitDef*&gt; iupPair; // used to access UDR-&gt;BuildOptions &amp; UDR-&gt;PrerequisiteOptions
+	typedef pair&lt;int,sRAIPrerequisite&gt; ipPair; // used to access UDR-&gt;AllPrerequisiteOptions
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR.begin(); iU!=UDR.end(); iU++ )
+	{
+		const UnitDef* ud = iU-&gt;second.ud;
+		for(map&lt;int,string&gt;::const_iterator iBO=ud-&gt;buildOptions.begin(); iBO!=ud-&gt;buildOptions.end(); iBO++ )
+		{
+			const UnitDef* bd = cb-&gt;GetUnitDef(iBO-&gt;second.c_str());
+			if( bd == 0 )
+			{
+				cb-&gt;SendTextMsg(&quot;WARNING: Mod Unit Definition Invalid.&quot;,0);
+				*l&lt;&lt;&quot;\n  WARNING: (unitdef-&gt;id=&quot;&lt;&lt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;ud-&gt;humanName&lt;&lt;&quot; has an invalid unitdef-&gt;buildOption '&quot;&lt;&lt;iBO-&gt;second.c_str()&lt;&lt;&quot;'&quot;;
+			}
+			else
+			{
+				sRAIUnitDef *U=&amp;UDR.find(bd-&gt;id)-&gt;second;
+				iU-&gt;second.BuildOptions.insert(iupPair(bd-&gt;id,U));
+				U-&gt;PrerequisiteOptions.insert(iupPair(ud-&gt;id,&amp;iU-&gt;second));
+			}
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Determining All Build Options and Prerequisites ...&quot;;
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR.begin(); iU!=UDR.end(); iU++ )
+	{
+		vector&lt;sBuildLine&gt; vTemp;
+		vTemp.clear();
+		for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=iU-&gt;second.PrerequisiteOptions.begin(); iB!=iU-&gt;second.PrerequisiteOptions.end(); iB++ )
+			vTemp.push_back(sBuildLine(iB-&gt;first,1));
+		for(int iT=0; iT&lt;int(vTemp.size()); iT++ )
+		{
+			if( iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID) == iU-&gt;second.AllPrerequisiteOptions.end() )
+			{
+				for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=UDR.find(vTemp[iT].ID)-&gt;second.PrerequisiteOptions.begin(); iB!=UDR.find(vTemp[iT].ID)-&gt;second.PrerequisiteOptions.end(); iB++ )
+					vTemp.push_back(sBuildLine(iB-&gt;first,vTemp[iT].BL+1));
+				iU-&gt;second.AllPrerequisiteOptions.insert(ipPair(vTemp[iT].ID,sRAIPrerequisite(&amp;UDR.find(vTemp[iT].ID)-&gt;second)));
+				iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID)-&gt;second.buildLine=vTemp[iT].BL;
+			}
+			else if( iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID)-&gt;second.buildLine &gt; vTemp[iT].BL )
+				iU-&gt;second.AllPrerequisiteOptions.find(vTemp[iT].ID)-&gt;second.buildLine=vTemp[iT].BL;
+		}
+		if( !iU-&gt;second.ud-&gt;isCommander &amp;&amp; int(iU-&gt;second.AllPrerequisiteOptions.size()) == 0 )
+			*l&lt;&lt;&quot;\n  WARNING: (&quot;&lt;&lt;iU-&gt;first&lt;&lt;&quot;)&quot;&lt;&lt;iU-&gt;second.ud-&gt;humanName&lt;&lt;&quot; is a non-commander unit that can not be built.&quot;;
+	}
+
+	for( list&lt;TerrainMapMobileType&gt;::iterator i=TM-&gt;mobileType.begin(); i!=TM-&gt;mobileType.end(); i++)
+		if( i-&gt;typeUsable )
+			RBMobile.insert(&amp;*i);
+	for( list&lt;TerrainMapImmobileType&gt;::iterator i=TM-&gt;immobileType.begin(); i!=TM-&gt;immobileType.end(); i++)
+		if( i-&gt;typeUsable )
+			RBImmobile.insert(&amp;*i);
+/*
+*l&lt;&lt;&quot;\n\nDisplaying All Build Options &amp; All Prerequisite Options for All Units ...&quot;;
+for(map&lt;int,sRAIUnitDef&gt;::iterator iU=UDR.begin(); iU!=UDR.end(); iU++ )
+{
+	*l&lt;&lt;&quot;\n(&quot;&lt;&lt;iU-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;+iU-&gt;second.ud-&gt;humanName+&quot; (size=&quot;&lt;&lt;iU-&gt;second.BuildOptions.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.BuildOptions.begin(); iB!=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.BuildOptions.end(); iB++ )
+		*l&lt;&lt;&quot;  &quot;+iB-&gt;second-&gt;ud-&gt;humanName;
+	*l&lt;&lt;&quot;\n(&quot;&lt;&lt;iU-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;+iU-&gt;second.ud-&gt;humanName+&quot; (size=&quot;&lt;&lt;iU-&gt;second.AllPrerequisiteOptions.size()&lt;&lt;&quot;):&quot;;
+	for( map&lt;int,sRAIPrerequisite&gt;::iterator iP=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.AllPrerequisiteOptions.begin(); iP!=UDR.find(iU-&gt;second.ud-&gt;id)-&gt;second.AllPrerequisiteOptions.end(); iP++ )
+		*l&lt;&lt;&quot; &quot;+iP-&gt;second.udr-&gt;ud-&gt;humanName&lt;&lt;&quot;(&quot;&lt;&lt;iP-&gt;second.buildLine&lt;&lt;&quot;)&quot;;
+}
+*l&lt;&lt;&quot;\n&quot;;
+*/
+	*l&lt;&lt;&quot;\n Determining Unit Efficiencies ...&quot;;
+	const int ARMOR		=0;
+	const int SPEED		=1;
+	const int MANUVER	=2;
+	const int BUILD		=3;
+	const int BUILDOPT	=4;
+	const int ENERGYP	=5;
+	const int ENERGYS	=6;
+	const int METALP	=7;
+	const int METALS	=8;
+	const int AIRBASE	=9;
+	const int RADAR		=10;
+	const int RADARJAM	=11;
+	const int SONAR		=12;
+	const int SONARJAM	=13;
+	const int TRANSPORT	=14;
+	const int TARGETING	=15;
+	const int BOMB		=16;
+	const int STOCKW	=17;
+	const int ANTIMIS	=18;
+	const int SHIELD	=19;
+	const int WEAPON	=20;
+	const int WEAPONSEA	=21;
+	const int UPGRADE	=22;
+	const int COST		=23;
+	const int ESIZE		=24;
+
+//	double UE[cb-&gt;GetNumUnitDefs()][ESIZE]; // Unit Efficency
+	double UE[5000][ESIZE]; // required for Visual Studios
+	for( map&lt;int,sRAIUnitDef&gt;::iterator iUD=UDR.begin(); iUD!=UDR.end(); iUD++ )
+	{
+		sRAIUnitDef *udr=&amp;iUD-&gt;second;
+		const UnitDef* ud=iUD-&gt;second.ud;
+		int i=iUD-&gt;first-1;
+		float cost=ud-&gt;energyCost+(ud-&gt;metalCost*EnergyToMetalRatio);
+		if( cost == 0 ) cost=1;
+
+		UE[i][COST]=cost;
+		UE[i][ARMOR]=ud-&gt;health/cost;
+		UE[i][SPEED]=ud-&gt;speed;
+
+		UE[i][BUILD]=(ud-&gt;buildSpeed*ud-&gt;buildDistance)/cost;
+		UE[i][BUILDOPT]=int(ud-&gt;buildOptions.size()) + 8.0*ud-&gt;canResurrect;
+		for( map&lt;int,sRAIUnitDef*&gt;::iterator iB=udr-&gt;BuildOptions.begin(); iB!=udr-&gt;BuildOptions.end(); iB++ )
+			if( (iB-&gt;second-&gt;PrerequisiteOptions.size()) == 1 )
+			{
+				UE[i][BUILDOPT] += 2;
+				if( UE[i][BUILDOPT] &lt; 15 )
+					UE[i][BUILDOPT] = 15;
+			}
+		if( UE[i][BUILDOPT] == 0 )
+		{
+			if( !ud-&gt;canRepair || ud-&gt;isAirBase )
+				UE[i][BUILD]=0;
+		}
+		else
+		{
+			if( ud-&gt;buildSpeed == 0 ) // Work-Around for the mod: fibre v13.1
+				UE[i][BUILD]=(AverageConstructSpeed*ud-&gt;buildDistance)/cost;
+			if( ud-&gt;isCommander )
+				UE[i][BUILD]*=2;
+		}
+
+		UE[i][MANUVER]=1.5*ud-&gt;canfly + 1.0*ud-&gt;canCloak + 0.5*ud-&gt;canhover + 0.5*ud-&gt;stealth + 0.5*(ud-&gt;minWaterDepth&lt;0 &amp;&amp; ud-&gt;maxWaterDepth &gt; TM-&gt;minElevation);
+
+		UE[i][ENERGYS]=ud-&gt;energyStorage/cost;
+		if( 10*ud-&gt;energyStorage &lt; fEnergyCostTotal/udSize || ud-&gt;energyStorage &lt; 500 )
+			UE[i][ENERGYS] = 0;
+
+		UE[i][ENERGYP]=udr-&gt;EnergyDifference/cost;
+		if( 1000*udr-&gt;EnergyDifference &lt; ud-&gt;energyCost )
+			UE[i][ENERGYP]=0;
+
+		if( fEnergyCostTotal == 1 )
+		{
+			UE[i][ENERGYP]=0;
+			UE[i][ENERGYS]=0;
+		}
+
+		UE[i][METALS]=ud-&gt;metalStorage/cost;
+		if( 2.5*ud-&gt;metalStorage &lt; fMetalCostTotal/udSize || ud-&gt;metalStorage &lt; 500 )
+			UE[i][METALS]=0;
+
+		UE[i][METALP]=udr-&gt;MetalDifference/cost;
+		if( 1000*udr-&gt;MetalDifference &lt; ud-&gt;metalCost )
+			UE[i][METALP]=0;
+
+		UE[i][RADAR]=ud-&gt;radarRadius + 0.20*ud-&gt;losRadius;
+		UE[i][RADARJAM]=ud-&gt;jammerRadius;
+		UE[i][SONAR]=ud-&gt;sonarRadius + 0.20*ud-&gt;losRadius;
+		UE[i][SONARJAM]=ud-&gt;sonarJamRadius;
+		UE[i][AIRBASE]=(ud-&gt;buildSpeed*ud-&gt;isAirBase);
+
+		UE[i][TRANSPORT]=ud-&gt;transportMass+(0.1*ud-&gt;transportCapacity*ud-&gt;transportMass);
+		if( ud-&gt;transportCapacity == 0 )
+			UE[i][TRANSPORT] = 0;
+		UE[i][TARGETING]=float(ud-&gt;targfac)/cost;
+		UE[i][BOMB]=ud-&gt;canKamikaze + ud-&gt;kamikazeDist;
+		UE[i][STOCKW]=0;
+		UE[i][ANTIMIS]=0;
+		UE[i][SHIELD]=0;
+		UE[i][WEAPON]=0;
+		UE[i][WEAPONSEA]=0;
+		for(std::vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator iW=ud-&gt;weapons.begin(); iW!=ud-&gt;weapons.end(); iW++)
+		{
+			float reload=iW-&gt;def-&gt;reload;
+			if( reload == 0 )
+			{
+				*l&lt;&lt;&quot;\n  WARNING: the weapon '&quot;&lt;&lt;iW-&gt;name&lt;&lt;&quot;' belonging to (&quot;&lt;&lt;iUD-&gt;first&lt;&lt;&quot;)&quot;&lt;&lt;iUD-&gt;second.ud-&gt;humanName&lt;&lt;&quot; has a 0 reload time.&quot;;
+				reload = 10;
+			}
+			float range=iW-&gt;def-&gt;range;
+			if( range &gt; MaxFiringRange )
+				range = MaxFiringRange;
+
+			if( iW-&gt;def-&gt;stockpile )
+			{
+				if( iW-&gt;def-&gt;manualfire )
+				{
+					UE[i][STOCKW] = iW-&gt;def-&gt;damages.GetDefaultDamage()*range/reload;
+					float fWCost=(iW-&gt;def-&gt;metalcost*EnergyToMetalRatio)+iW-&gt;def-&gt;energycost;
+					if(fWCost==0)
+						fWCost=1;
+					UE[i][STOCKW]/=fWCost;
+				}
+				else if( iW-&gt;def-&gt;coverageRange &gt; 0 )
+				{
+					float rangeC=iW-&gt;def-&gt;coverageRange;
+					if( rangeC &gt; MaxFiringRange )
+						rangeC = MaxFiringRange;
+
+					UE[i][ANTIMIS] = rangeC/reload;
+					float fWCost=(iW-&gt;def-&gt;metalcost*EnergyToMetalRatio)+iW-&gt;def-&gt;energycost;
+					if(fWCost==0)
+						fWCost=1;
+					UE[i][ANTIMIS]/=fWCost;
+				}
+			}
+			else if( iW-&gt;def-&gt;shieldRadius &gt; 0 )
+			{
+				UE[i][SHIELD]=iW-&gt;def-&gt;shieldPower*iW-&gt;def-&gt;shieldRadius*iW-&gt;def-&gt;shieldPowerRegen;
+			}
+			else if( iW-&gt;def-&gt;damages.GetDefaultDamage() &gt; 0 )
+			{
+				if( iW-&gt;def-&gt;waterweapon )
+					UE[i][WEAPONSEA]=iW-&gt;def-&gt;salvosize*iW-&gt;def-&gt;damages.GetDefaultDamage()*range/reload;
+				else
+				{
+					UE[i][WEAPON]=iW-&gt;def-&gt;salvosize*iW-&gt;def-&gt;damages.GetDefaultDamage()*range/reload;
+				}
+			}
+		}
+
+		if( udr-&gt;IsCategory(&quot;UPGRADE&quot;) ) // mod(CvC 0.4), change this if a more standard upgrade system is added
+		{
+			*l&lt;&lt;&quot;\n  Upgrade Category Tag found: &quot;&lt;&lt;ud-&gt;humanName;
+			UE[i][BUILD]=0;
+			UE[i][RADAR]=0;
+			UE[i][TARGETING]=0;
+			UE[i][WEAPON]=0;
+			UE[i][UPGRADE]=1.0f;
+		}
+		else
+			UE[i][UPGRADE]=0;
+
+		if( udr-&gt;IsCategory(&quot;NOTARGET&quot;) ) // Just used in mod(Kernal Panic), Hopefully...
+		{
+			*l&lt;&lt;&quot;\n  NoTarget Category Tag found: &quot;&lt;&lt;ud-&gt;humanName;
+			UE[i][WEAPON]=0;
+		}
+
+		if( int(udr-&gt;PrerequisiteOptions.size()) == 0 || ud-&gt;isFeature )
+		{
+			UE[i][ENERGYP]=0;
+			UE[i][ENERGYS]=0;
+			UE[i][METALP]=0;
+			UE[i][METALS]=0;
+			UE[i][RADAR]=0;
+			UE[i][RADARJAM]=0;
+			UE[i][SONAR]=0;
+			UE[i][SONARJAM]=0;
+			UE[i][UPGRADE]=0;
+		}
+	}
+
+	for( int e=0; e&lt;ESIZE; e++ )
+	{
+		sRAIUnitDef *udr;
+		double Max=0;
+		for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ )
+			if( UDR.find(i+1) != UDR.end() )
+			{
+				udr = &amp;UDR.find(i+1)-&gt;second;
+				if( Max&lt;UE[i][e] &amp;&amp; udr-&gt;ud-&gt;maxThisUnit &gt; 1 &amp;&amp; int(udr-&gt;PrerequisiteOptions.size()) &gt; 0 &amp;&amp; ( int(udr-&gt;PrerequisiteOptions.size()) &gt; 1 || udr-&gt;PrerequisiteOptions.begin()-&gt;first != i+1 ) )
+					Max=UE[i][e];
+			}
+		if( Max == 0 )
+		{
+			for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ )
+				if( UDR.find(i+1) != UDR.end() &amp;&amp; UE[i][e]&gt;Max )
+					Max=UE[i][e];
+		}
+		if( Max &gt; 0 )
+			for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ )
+			{
+				if( UDR.find(i+1) != UDR.end() )
+				{
+					udr = &amp;UDR.find(i+1)-&gt;second;
+					UE[i][e]/=Max;
+					if( int(udr-&gt;PrerequisiteOptions.size()) == 0 || udr-&gt;ud-&gt;maxThisUnit == 1 || (udr-&gt;PrerequisiteOptions.size() == 1 &amp;&amp; udr-&gt;PrerequisiteOptions.begin()-&gt;first == i+1) )
+					{
+						if( UE[i][e] &gt; 1.01f )
+							UE[i][e] = 1.01f;
+						else if( UE[i][e] &gt; 0.0f &amp;&amp; UE[i][e] &lt; 0.1f )
+							UE[i][e] = 0.1f;
+					}
+				}
+			}
+	}
+/*
+	*l&lt;&lt;&quot;\n\nDisplaying Unit Efficency Table ...&quot;;
+	for( int i=0; i&lt;cb-&gt;GetNumUnitDefs(); i++ ) // Unit Efficency Debug
+		if( UDR.find(i+1) != UDR.end() )
+		{
+			*l&lt;&lt;&quot;\n(&quot;&lt;&lt;i+1&lt;&lt;&quot;) &quot;+UDR.find(i+1)-&gt;second.ud-&gt;humanName;
+			for( int e=0; e&lt;ESIZE; e++ )
+				if( UE[i][e] != 0 )
+					*l&lt;&lt;&quot; [&quot;&lt;&lt;e&lt;&lt;&quot;]:&quot;&lt;&lt;100*UE[i][e]&lt;&lt;&quot;%&quot;;
+		}
+	*l&lt;&lt;&quot;\n&quot;;
+*/
+	*l&lt;&lt;&quot;\n Creating the Build-Lists ...&quot;;
+	BLSize=0;
+	BLActive=0;
+	for(int iBL=0; iBL&lt;35; iBL++)
+	{
+		BL[BLSize] = new sRAIBuildList(cb-&gt;GetNumUnitDefs(),this);
+		float fAverageTaskEfficiency=0;
+		for( map&lt;int,sRAIUnitDef&gt;::iterator iUD=UDR.begin(); iUD!=UDR.end(); iUD++ )
+		{
+			int i=iUD-&gt;first-1;
+			sRAIUnitDef *udr=&amp;iUD-&gt;second;
+			const UnitDef* ud=iUD-&gt;second.ud;
+			float fCost=ud-&gt;energyCost+(ud-&gt;metalCost*EnergyToMetalRatio);
+			float fValue=0;
+			int iTask=-1;
+			switch(iBL)
+			{
+			case 0:
+				BLBuilder = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Constructor&quot;;
+				if( UE[i][BUILD] == 0 || ( UE[i][BUILDOPT] == 0 &amp;&amp; ud-&gt;speed == 0) ) break;
+
+				// BuildOption Var
+				fValue+=0.7*UE[i][BUILD] + 0.7*UE[i][BUILDOPT] + 0.2*UE[i][MANUVER] + 0.1*UE[i][SPEED] + 0.1*UE[i][ARMOR] + 0.1*UE[i][ENERGYP] + 0.1*UE[i][METALP];
+				iTask=TASK_CONSTRUCT;
+
+				// BuildList Var.
+				BL[BLSize]-&gt;priority=10;
+				BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=0.5f;
+
+				break;
+			case 1:
+				BL[BLSize]-&gt;Name= &quot;Immobile Assist Constructor&quot;;
+				if( ud-&gt;speed &gt; 0 || UE[i][BUILDOPT] &gt; 0 || UE[i][BUILD] == 0 ) break;
+
+				fValue=UE[i][BUILD];
+				iTask=TASK_CONSTRUCT;
+
+				BL[BLSize]-&gt;priority=5;
+				BL[BLSize]-&gt;minEfficiency=2.0f;
+				break;
+			case 2:
+				BLEnergyL = BL[BLSize];
+				BL[BLSize]-&gt;Name= &quot;Energy Production (Geothermal)&quot;;
+				if( UE[i][ENERGYP] &lt;= 0 || !ud-&gt;needGeo ) break;
+
+				fValue=2.0*UE[i][ENERGYP] + 0.2*UE[i][ARMOR];
+
+				BL[BLSize]-&gt;minEfficiency=0.5f;
+				break;
+			case 3:
+				BLEnergy = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Energy Production&quot;;
+				if( UE[i][ENERGYP] &lt;= 0.0 || ud-&gt;needGeo || ud-&gt;extractsMetal &gt; 0 ) break;
+
+				fValue=2.0*UE[i][ENERGYP] + 0.2*UE[i][ARMOR];
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=1.01f;
+				break;
+			case 4:
+				BLMetalL = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Metal Production (Extractor)&quot;;
+				if( ud-&gt;extractsMetal &lt;= 0 || RM-&gt;isMetalMap ) break;
+
+				fValue=2.0*UE[i][METALP] + 0.1*UE[i][ARMOR]*UE[i][METALP];
+
+				BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=0.5f;
+				break;
+			case 5:
+				BLMetal = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Metal Production&quot;;
+				if( UE[i][METALP] &lt;= 0.0 || ud-&gt;needGeo || (ud-&gt;extractsMetal &gt; 0.0 &amp;&amp; !RM-&gt;isMetalMap) ) break;
+
+				fValue=2.0*UE[i][METALP] + 0.1*UE[i][ARMOR]*UE[i][METALP];
+				if( UE[i][ENERGYP] &lt; 0.0f )
+					fValue+=0.1*UE[i][ENERGYP];
+
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				if( ud-&gt;extractsMetal &gt; 0 )
+					BL[BLSize]-&gt;minUnits=2;
+				BL[BLSize]-&gt;minEfficiency=1.01f;
+				break;
+			case 6:
+				BLEnergyStorage = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Energy Storage&quot;;
+				if( UE[i][ENERGYS] &lt;= 0.0 ) break;
+
+				fValue=2.0*UE[i][ENERGYS] + 0.2*UE[i][ARMOR];
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minEfficiency=2.0f;
+				break;
+			case 7:
+				BLMetalStorage = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Metal Storage&quot;;
+				if( UE[i][METALS] &lt;= 0.0 ) break;
+
+				fValue=2.0*UE[i][METALS] + 0.2*UE[i][ARMOR];
+				if( ud-&gt;speed &gt; 0 )
+					iTask=TASK_NONE;
+
+				BL[BLSize]-&gt;minEfficiency=2.0f;
+				break;
+			case 8:
+				BLMobileRadar = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Mobile Radar&quot;;
+				if( ud-&gt;radarRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][RADAR] / UE[i][COST];
+				iTask=TASK_SCOUT;
+
+				BL[BLSize]-&gt;priority=2+(TM-&gt;percentLand/100.0)*3.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 9:
+				BL[BLSize]-&gt;Name=&quot;Immobile Radar&quot;;
+				if( ud-&gt;radarRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][RADAR] / UE[i][COST];
+
+				BL[BLSize]-&gt;priority=3+(TM-&gt;percentLand/100.0)*5.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 10:
+				BL[BLSize]-&gt;Name=&quot;Mobile Radar Jammer&quot;;
+				if( ud-&gt;jammerRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][RADARJAM] / UE[i][COST];
+				iTask=TASK_SUPPORT;
+
+				BL[BLSize]-&gt;priority=1+(TM-&gt;percentLand/100.0)*1.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 11:
+				BL[BLSize]-&gt;Name=&quot;Immobile Radar Jammer&quot;;
+				if( ud-&gt;jammerRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][RADARJAM] / UE[i][COST];
+				fValue/=fCost;
+
+				BL[BLSize]-&gt;priority=2+(TM-&gt;percentLand/100.0)*5.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 12:
+				BL[BLSize]-&gt;Name=&quot;Mobile Sonar&quot;;
+				if( ud-&gt;sonarRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][SONAR] / UE[i][COST];
+				iTask=TASK_SCOUT;
+
+				if( TM-&gt;percentLand &lt; 97.0 )
+					BL[BLSize]-&gt;priority=1.0+((100.0-TM-&gt;percentLand)/100.0)*3.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 13:
+				BL[BLSize]-&gt;Name=&quot;Immobile Sonar&quot;;
+				if( ud-&gt;sonarRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][SONAR] / UE[i][COST];
+
+				BL[BLSize]-&gt;priority=((100.0-TM-&gt;percentLand)/100.0)*5.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 14:
+				BL[BLSize]-&gt;Name=&quot;Mobile Sonar Jammer&quot;;
+				if( ud-&gt;sonarJamRadius &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][SONARJAM] / UE[i][COST];
+				iTask=TASK_SUPPORT;
+
+				BL[BLSize]-&gt;priority=((100.0-TM-&gt;percentLand)/100.0)*2.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 15:
+				BL[BLSize]-&gt;Name=&quot;Immobile Sonar Jammer&quot;;
+				if( ud-&gt;sonarJamRadius &lt;= 0 || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][SONARJAM] / UE[i][COST];
+
+				BL[BLSize]-&gt;priority=((100.0-TM-&gt;percentLand)/100.0)*5.0;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+/*
+			case 16: // Check for immobile scouts
+				BL[BLSize]-&gt;Name=&quot;Immobile Recon&quot;;
+				break;
+			case 17: // Check for scouts
+				BL[BLSize]-&gt;Name=&quot;Mobile Recon&quot;;
+				break;
+*/
+			case 18:
+				BL[BLSize]-&gt;Name=&quot;Mobile Bomb&quot;;
+				if( !ud-&gt;canKamikaze || ud-&gt;speed == 0.0 ) break;
+
+				fValue=UE[i][BOMB];
+				iTask=TASK_SUICIDE;
+
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				BL[BLSize]-&gt;priority=2;
+				break;
+			case 19:
+				BL[BLSize]-&gt;Name=&quot;Immobile Bomb&quot;;
+				if( !ud-&gt;canKamikaze || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=UE[i][BOMB];
+
+//				BL[BLSize]-&gt;priority=2;
+				break;
+			case 20:
+				BL[BLSize]-&gt;Name=&quot;Transport&quot;;
+				if( ud-&gt;transportCapacity &lt;= 0 ) break;
+
+				fValue=UE[i][TRANSPORT] + UE[i][MANUVER];
+				iTask=TASK_TRANSPORT;
+
+				BL[BLSize]-&gt;minEfficiency=0.15f;
+				break;
+			case 21:
+				BL[BLSize]-&gt;Name=&quot;Targeting Facility&quot;;
+				if( !ud-&gt;targfac ) break;
+
+				fValue=UE[i][TARGETING];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+/*
+			case 22:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Air&quot;;
+				break;
+			case 23:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Air&quot;;
+				break;
+			case 24:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Land&quot;;
+				break;
+			case 25:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Land&quot;;
+				break;
+*/
+			case 24:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Land/Air&quot;;
+				if( UE[i][WEAPON] &lt;= 0 || ud-&gt;canKamikaze || ud-&gt;speed &gt; 0.0 || int(udr-&gt;BuildOptions.size()) &gt; 0 ) break;
+
+				fValue=1.3*UE[i][WEAPON] + 0.7*UE[i][ARMOR];
+
+				BL[BLSize]-&gt;priority=int(15.0+(TM-&gt;percentLand/100.0)*15.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 25:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Land/Air&quot;;
+				if( UE[i][WEAPON] &lt;= 0 || ud-&gt;canKamikaze || ud-&gt;speed == 0.0 || int(udr-&gt;BuildOptions.size()) &gt; 0 ) break;
+
+				fValue=1.3*UE[i][WEAPON] + 0.5*UE[i][ARMOR] + 0.1*UE[i][MANUVER] + 0.1*UE[i][SPEED];
+				iTask=TASK_ASSAULT;
+
+				BL[BLSize]-&gt;priority=int(18.0+(TM-&gt;percentLand/100.0)*18.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 26:
+				BL[BLSize]-&gt;Name=&quot;Immobile Anti-Naval&quot;;
+				if( UE[i][WEAPONSEA] &lt;= 0 || ud-&gt;canKamikaze || ud-&gt;speed &gt; 0.0 ) break;
+
+				fValue=1.3*UE[i][WEAPONSEA] + 0.7*UE[i][ARMOR];
+
+				if( !TM-&gt;waterIsHarmful )
+					BL[BLSize]-&gt;priority=int(((100.0-TM-&gt;percentLand)/100.0)*12.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 27:
+				BL[BLSize]-&gt;Name=&quot;Mobile Anti-Naval&quot;;
+				if( UE[i][WEAPONSEA] &lt;= 0 || ud-&gt;speed == 0.0 ) break;
+
+				fValue=1.3*UE[i][WEAPONSEA] + 0.5*UE[i][ARMOR] + 0.1*UE[i][MANUVER] + 0.1*UE[i][SPEED];
+				iTask=TASK_ASSAULT;
+
+				if( !TM-&gt;waterIsHarmful )
+					BL[BLSize]-&gt;priority=int(((100.0-TM-&gt;percentLand)/100.0)*18.0);
+				BL[BLSize]-&gt;minEfficiency=0.99f;
+				break;
+			case 28:
+				BL[BLSize]-&gt;Name=&quot;Anti-Missile&quot;;
+				if( UE[i][ANTIMIS] &lt;= 0 ) break;
+
+				fValue=UE[i][ANTIMIS];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 29:
+				BL[BLSize]-&gt;Name=&quot;Stockpile Weapon&quot;;
+				if( UE[i][STOCKW] &lt;= 0 ) break;
+
+				fValue=UE[i][STOCKW];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 30:
+				BL[BLSize]-&gt;Name=&quot;Anti-Weapon(Shields)&quot;;
+				if( UE[i][SHIELD] &lt;= 0 ) break;
+			
+				fValue=UE[i][SHIELD];
+
+				BL[BLSize]-&gt;priority=1;
+				BL[BLSize]-&gt;minEfficiency=3.0f;
+				break;
+			case 31:
+				BLAirBase = BL[BLSize];
+				BL[BLSize]-&gt;Name=&quot;Air Base&quot;;
+				if( !ud-&gt;isAirBase || UE[i][BUILDOPT] &gt; 0 ) break;
+
+				fValue=UE[i][AIRBASE];
+
+				BL[BLSize]-&gt;priority=2;
+				BL[BLSize]-&gt;minEfficiency=0.75f;
+				break;
+			case 32:
+				BL[BLSize]-&gt;Name=&quot;Wall&quot;;
+				if( int(udr-&gt;PrerequisiteOptions.size()) == 0 || !ud-&gt;isFeature ) break;
+
+				fValue=1;
+
+				break;
+			case 33:
+				BL[BLSize]-&gt;Name=&quot;Upgrade&quot;;
+				if( UE[i][UPGRADE] == 0 ) break;
+
+				fValue = 1;
+
+				BL[BLSize]-&gt;priority=10;
+				break;
+			}
+
+			if( fValue &gt; 0.0 )
+			{
+				fAverageTaskEfficiency=((fAverageTaskEfficiency*BL[BLSize]-&gt;UDefSize) + fValue)/(BL[BLSize]-&gt;UDefSize+1);
+				new sRAIUnitDefBL(&amp;iUD-&gt;second,BL[BLSize],fValue,iTask);
+			}
+		}
+
+		if( BL[BLSize]-&gt;Name == &quot;Undefined&quot; )
+		{
+			delete BL[BLSize];
+			BLSize--;
+		}
+		else if( BL[BLSize]-&gt;UDefSize == 0 )
+		{
+			BL[BLSize]-&gt;minUnits=0;
+			BL[BLSize]-&gt;priority=-1;
+		}
+		else
+		{
+			if( BL[BLSize]-&gt;priority == 0 ) // SafeGuard
+				BL[BLSize]-&gt;priority = -1;
+
+			for(int iud=0; iud&lt;BL[BLSize]-&gt;UDefSize; iud++)
+			{
+				if( BL[BLSize]-&gt;UDef[iud]-&gt;efficiency/fAverageTaskEfficiency &gt;= 8.0 ) // Check for absurdly unbalanced units, needed for Gundam v1.1
+				{
+					float fEffDecrease=BL[BLSize]-&gt;UDef[iud]-&gt;efficiency-(7.75*fAverageTaskEfficiency);
+					BL[BLSize]-&gt;UDef[iud]-&gt;efficiency-=fEffDecrease;
+					fAverageTaskEfficiency-=fEffDecrease/BL[BLSize]-&gt;UDefSize;
+					iud=-1; // Start Over
+				}
+			}
+			float max=0;
+			for(int iud=0; iud&lt;BL[BLSize]-&gt;UDefSize; iud++)
+			{
+				BL[BLSize]-&gt;UDef[iud]-&gt;efficiency/=fAverageTaskEfficiency;
+				if( max == 0 || max &lt; BL[BLSize]-&gt;UDef[iud]-&gt;efficiency )
+					max = BL[BLSize]-&gt;UDef[iud]-&gt;efficiency;
+			}
+			if( BL[BLSize]-&gt;minEfficiency &gt; 1 &amp;&amp; BL[BLSize]-&gt;minEfficiency &lt;= max/3.0f )
+			{
+				BL[BLSize]-&gt;minEfficiency = max/2.5f;
+				*l&lt;&lt;&quot;\n  Setting &quot;&lt;&lt;BL[BLSize]-&gt;Name&lt;&lt;&quot; Min. Efficiency to '&quot;&lt;&lt;BL[BLSize]-&gt;minEfficiency&lt;&lt;&quot;'.&quot;;
+			}
+		}
+		BLSize++;
+	}
+/*
+*l&lt;&lt;&quot;\n\nDEBUGGING: Build-List&quot;;
+for(int iBL=0; iBL&lt;BLSize; iBL++ )
+{
+	*l&lt;&lt;&quot;\n&quot;+BL[iBL]-&gt;Name+&quot; Build-List #&quot;&lt;&lt;iBL+1&lt;&lt;&quot; (size=&quot;&lt;&lt;BL[iBL]-&gt;UDefSize&lt;&lt;&quot;):&quot;;
+	for(int iud=0; iud&lt;BL[iBL]-&gt;UDefSize; iud++)
+		*l&lt;&lt;&quot;  (&quot;&lt;&lt;BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;+BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;ud-&gt;name+&quot; &quot;&lt;&lt;BL[iBL]-&gt;UDef[iud]-&gt;efficiency;
+}
+*l&lt;&lt;&quot;\nUndefined Build-List:&quot;;
+for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+	if( iud-&gt;second.ListSize == 0 )
+		*l&lt;&lt;&quot;  (&quot;&lt;&lt;iud-&gt;second.ud-&gt;id&lt;&lt;&quot;)&quot;+iud-&gt;second.ud-&gt;name;
+*l&lt;&lt;&quot;\n&quot;;
+*/
+/*
+*l&lt;&lt;&quot;\n\nDEBUGGING: Build Options ...&quot;;
+	for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+	{
+		*l&lt;&lt;&quot;\n(&quot;&lt;&lt;iud-&gt;second.ud-&gt;id&lt;&lt;&quot;) Name=&quot;+iud-&gt;second.ud-&gt;humanName+&quot; &quot;;
+		*l&lt;&lt;&quot; LS=&quot;&lt;&lt;iud-&gt;second.ListSize;
+		for(int iBL=0; iBL&lt;iud-&gt;second.ListSize; iBL++)
+		{
+			sRAIUnitDefBL *udrBL=iud-&gt;second.List[iBL];
+			*l&lt;&lt;&quot;\n  LN=&quot;&lt;&lt; udrBL-&gt;RBL-&gt;Name;
+			*l&lt;&lt;&quot; iBL=&quot;&lt;&lt;iBL;
+			*l&lt;&lt;&quot; UDefSize=&quot;&lt;&lt; udrBL-&gt;RBL-&gt;UDefSize;
+			*l&lt;&lt;&quot; priority=&quot;&lt;&lt; udrBL-&gt;RBL-&gt;priority;
+			*l&lt;&lt;&quot; fEfficiency=&quot;&lt;&lt;udrBL-&gt;efficiency;
+			*l&lt;&lt;&quot; iTask=&quot;&lt;&lt;udrBL-&gt;task;
+		}
+		*l&lt;&lt;&quot;\n&quot;;
+	}
+*l&lt;&lt;&quot;\n&quot;;
+*/
+	*l&lt;&lt;&quot;\n Removing inappropriate build options ...&quot;;
+	for(int iud=0; iud&lt;BLBuilder-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr=BLBuilder-&gt;UDef[iud]-&gt;RUD;
+		if( int(udr-&gt;BuildOptions.size()) == 0 &amp;&amp; udr-&gt;ListSize &gt; 1 )
+		{
+			if( UE[udr-&gt;ud-&gt;id-1][BUILDOPT] == 0 ) // BUILDOPT includes 'resurrect' ability
+			{
+//				*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLBuilder-&gt;Name&lt;&lt;&quot; Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				delete BLBuilder-&gt;UDef[iud--];
+			}
+			else
+			{
+//				*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLBuilder-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+				BLBuilder-&gt;UDef[iud]-&gt;efficiency /= 5.0f; // This will discourage using certain units as constructors, was needed for MOD: Blox
+			}
+		}
+		else if( udr-&gt;ud-&gt;isCommander )
+		{
+			sRAIUnitDefBL* bestEP = 0;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator iB = udr-&gt;BuildOptions.begin(); iB != udr-&gt;BuildOptions.end(); iB++ )
+				for(int iL=0; iL&lt;iB-&gt;second-&gt;ListSize; iL++)
+					if( iB-&gt;second-&gt;List[iL]-&gt;RBL == BLEnergy &amp;&amp; (bestEP == 0 || bestEP-&gt;efficiency &lt; iB-&gt;second-&gt;List[iL]-&gt;efficiency) )
+						bestEP = iB-&gt;second-&gt;List[iL];
+			if( bestEP != 0 &amp;&amp; bestEP-&gt;RUD-&gt;ListSize &gt; 1 &amp;&amp; bestEP-&gt;efficiency &lt; BLEnergy-&gt;minEfficiency )
+			{
+//				*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLEnergy-&gt;Name&lt;&lt;&quot; Increased ... (&quot;&lt;&lt;bestEP-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;bestEP-&gt;RUD-&gt;ud-&gt;humanName;
+				bestEP-&gt;efficiency *= 3.0f; // This will encourage using certain units as Energy Production, was needed for MOD: Epic Legions
+			}
+		}
+	}
+
+	// Adjusts the buildlist for useage on a metalmap
+	if( RM-&gt;isMetalMap )
+	{
+		*l&lt;&lt;&quot;\n Check '&quot;+BLMetal-&gt;Name+&quot; Build-List' for usage on a metal map.&quot;;
+		float Low=-1.0;
+		for(int i=0; i&lt;BLMetal-&gt;UDefSize; i++ ) // Find lowest extractor efficiency
+			if( (Low == -1.0 || Low &gt; BLMetal-&gt;UDef[i]-&gt;efficiency) &amp;&amp; BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;extractsMetal &gt; 0.0 )
+				Low = BLMetal-&gt;UDef[i]-&gt;efficiency;
+		if( Low &gt; 0 )
+		{
+			// Disable metal makers below this efficiency, most likely all of them
+			for(int i=0; i&lt;BLMetal-&gt;UDefSize; i++ )
+				if( BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;extractsMetal &lt;= 0.0 ) // Low &gt; BLMetal-&gt;UDef[i]-&gt;efficiency &amp;&amp;
+				{
+					if( BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ListSize == 1 )
+					{
+						BLMetal-&gt;UDef[i]-&gt;RUD-&gt;Disabled = true;
+						BLMetal-&gt;UDef[i]-&gt;RUD-&gt;CheckBuildOptions();
+//						*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetal-&gt;Name&lt;&lt;&quot; Disabled ... (&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;humanName;
+					}
+					else
+					{
+//						*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetal-&gt;Name&lt;&lt;&quot; Removed ... (&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;BLMetal-&gt;UDef[i]-&gt;RUD-&gt;ud-&gt;humanName;
+						delete BLMetal-&gt;UDef[i--];
+					}
+				}
+		}
+	}
+
+	// If an &quot;extractor&quot; can be used for some other task, remove it from &quot;Metal Production&quot; and discourage its useage as anything but an extractor, was needed for MOD: FF
+	for(int iud=0; iud&lt;BLMetalL-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLMetalL-&gt;UDef[iud]-&gt;RUD;
+		if( udr-&gt;ListSize &gt; 1 )
+		{
+			for( int i=0; i&lt;udr-&gt;ListSize; i++ )
+				if( udr-&gt;List[i]-&gt;RBL == BLMetal )
+				{
+//					*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetalL-&gt;Name&lt;&lt;&quot; Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					delete BLMetalL-&gt;UDef[iud--];
+					break;
+				}
+				else if( udr-&gt;List[i]-&gt;RBL != BLMetalL )
+				{
+//					*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;udr-&gt;List[i]-&gt;RBL-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					udr-&gt;List[i]-&gt;efficiency /= 2.0f;
+				}
+		}
+	}
+
+	// If a &quot;geo-energy plant&quot; can be used for some other task, discourage its useage as anything but an &quot;geo-energy plant&quot;, was needed for MOD: FF
+	for(int iud=0; iud&lt;BLEnergyL-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLEnergyL-&gt;UDef[iud]-&gt;RUD;
+		if( udr-&gt;ListSize &gt; 1 )
+		{
+			for( int i=0; i&lt;udr-&gt;ListSize; i++ )
+				if( udr-&gt;List[i]-&gt;RBL != BLEnergyL )
+				{
+//					*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;udr-&gt;List[i]-&gt;RBL-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+					udr-&gt;List[i]-&gt;efficiency /= 2.0f;
+				}
+		}
+	}
+
+	// If a low efficiency &quot;metal producer&quot; can be used for some other task, discourage its use as a &quot;metal producer&quot;, was needed for MOD: CvC
+	for(int iud=0; iud&lt;BLMetal-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLMetal-&gt;UDef[iud]-&gt;RUD;
+		if( UE[udr-&gt;ud-&gt;id-1][METALP] &lt; 0.15 &amp;&amp; udr-&gt;ListSize &gt; 1 )
+		{
+//			*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLMetal-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+			BLMetal-&gt;UDef[iud]-&gt;efficiency /= 5.0f;
+		}
+	}
+
+	// If a low efficiency &quot;energy producer&quot; can be used for some other task, discourage its use as a &quot;energy producer&quot;, was needed for MOD: FF
+	for(int iud=0; iud&lt;BLEnergy-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLEnergy-&gt;UDef[iud]-&gt;RUD;
+		if( UE[udr-&gt;ud-&gt;id-1][ENERGYP] &lt; 0.15 &amp;&amp; udr-&gt;ListSize &gt; 1 )
+		{
+//			*l&lt;&lt;&quot;\n  (Special Rule) &quot;&lt;&lt;BLEnergy-&gt;Name&lt;&lt;&quot; Reduced ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName;
+			BLEnergy-&gt;UDef[iud]-&gt;efficiency /= 5.0f;
+		}
+	}
+
+	for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+		if( iud-&gt;second.ListSize &gt; 1 )
+		{
+			int bestTIndex=0; // best task-index
+			for(int iT=0; iT&lt;iud-&gt;second.ListSize; iT++) // Finds the task this unit is best at
+				if( iud-&gt;second.List[iT]-&gt;efficiency/iud-&gt;second.List[iT]-&gt;RBL-&gt;minEfficiency &gt; iud-&gt;second.List[bestTIndex]-&gt;efficiency/iud-&gt;second.List[bestTIndex]-&gt;RBL-&gt;minEfficiency )
+					bestTIndex=iT;
+			// Remove inappropriate tasks based off of the estimated efficiency
+			for(int iT=0; iT&lt;iud-&gt;second.ListSize; iT++)
+			{
+				sRAIBuildList *RBL = iud-&gt;second.List[iT]-&gt;RBL;
+				if( iT != bestTIndex &amp;&amp; iud-&gt;second.List[iT]-&gt;efficiency &lt; RBL-&gt;minEfficiency )
+				{
+					int bestLIndex = -1; // best list-index
+					for(int i=0; i&lt;RBL-&gt;UDefSize; i++)
+					{
+						if( RBL-&gt;UDef[i]-&gt;RUD-&gt;Disabled ) {}
+						else if( bestLIndex == -1 || RBL-&gt;UDef[bestLIndex]-&gt;efficiency &lt; RBL-&gt;UDef[i]-&gt;efficiency )
+							bestLIndex = i;
+					}
+					if( iT != bestLIndex || 3*iud-&gt;second.List[iT]-&gt;efficiency &lt; RBL-&gt;minEfficiency )
+					{
+//						*l&lt;&lt;&quot;\nRemoving &quot;+iud-&gt;second.ud-&gt;humanName+&quot; from buildlist: &quot;+iud-&gt;second.List[iT]-&gt;RBL-&gt;Name&lt;&lt;&quot; Eff=&quot;&lt;&lt;iud-&gt;second.List[iT]-&gt;efficiency;
+						delete iud-&gt;second.List[iT];
+						if( bestTIndex == iud-&gt;second.ListSize )
+							bestTIndex = iT;
+						iT--;
+					}
+				}
+			}
+		}
+
+	for( int iL=0; iL&lt;BLSize; iL++)
+	{
+		int bestLIndex = -1; // best list-index
+		for(int iU=0; iU&lt;BL[iL]-&gt;UDefSize; iU++)
+		{
+			if( BL[iL]-&gt;UDef[iU]-&gt;RUD-&gt;Disabled ) {}
+			else if( bestLIndex == -1 || BL[iL]-&gt;UDef[bestLIndex]-&gt;efficiency &lt; BL[iL]-&gt;UDef[iU]-&gt;efficiency )
+				bestLIndex = iU;
+		}
+		if( bestLIndex &gt;= 0 )
+		{
+			if( BL[iL]-&gt;UDef[bestLIndex]-&gt;efficiency &lt; 0.25 &amp;&amp; BL[iL]-&gt;minEfficiency &lt; 0.25 )
+			{
+				*l&lt;&lt;&quot;\n  Setting the unit limit to one for the '&quot;&lt;&lt;BL[iL]-&gt;Name&lt;&lt;&quot;' Build-List units. (due to all of it's units having low efficiencies)&quot;;
+				BL[iL]-&gt;priority = -1;
+				for(int iU=0; iU&lt;BL[iL]-&gt;UDefSize; iU++)
+					BL[iL]-&gt;UDef[iU]-&gt;RUD-&gt;SetUnitLimit(1);
+			}
+			else
+				for(int iU=0; iU&lt;BL[iL]-&gt;UDefSize; iU++)
+					if( BL[iL]-&gt;UDef[iU]-&gt;efficiency &lt;= 0.05 )
+					{
+						BL[iL]-&gt;UDef[iU]-&gt;RUD-&gt;SetUnitLimit(1);
+						*l&lt;&lt;&quot;\n  Setting the unit limit to one for (&quot;&lt;&lt;BL[iL]-&gt;UDef[iU]-&gt;RUD-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;BL[iL]-&gt;UDef[iU]-&gt;RUD-&gt;ud-&gt;humanName&lt;&lt;&quot;, this unit had a very low efficiency rating for all known tasks.&quot;;
+					}
+		}
+	}
+
+	// Restrict all HoverCraft from land or water maps but only if they are not needed for unique build options or tasks
+	if( TM-&gt;percentLand &gt; 85 || TM-&gt;percentLand &lt; 15 )
+	{
+		bool UseHoverCraft=false;
+		set&lt;int&gt; HoverCraftFactory;
+		for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end() &amp;&amp; !UseHoverCraft; iud++ )
+		{
+			if( iud-&gt;second.immobileType != 0 &amp;&amp; iud-&gt;second.mobileType != 0 &amp;&amp; iud-&gt;second.mobileType-&gt;canHover )
+				HoverCraftFactory.insert(iud-&gt;first);
+			if( !iud-&gt;second.Disabled &amp;&amp; iud-&gt;second.ud-&gt;canhover )
+			{
+				// check if it is needed for a unique task
+				for(int iT=0; iT&lt;iud-&gt;second.ListSize; iT++)
+				{
+					sRAIBuildList *BL = iud-&gt;second.List[iT]-&gt;RBL;
+					bool alternative=false;
+					for(int iud2=0; iud2&lt;BL-&gt;UDefSize; iud2++)
+						if( !BL-&gt;UDef[iud2]-&gt;RUD-&gt;Disabled &amp;&amp; !BL-&gt;UDef[iud2]-&gt;RUD-&gt;ud-&gt;canhover &amp;&amp; !BL-&gt;UDef[iud2]-&gt;RUD-&gt;ud-&gt;canfly )
+						{
+							alternative=true;
+							break;
+						}
+					if( !alternative )
+					{
+						UseHoverCraft = true;
+						break;
+					}
+				}
+			}
+		}
+		if( !UseHoverCraft )
+		{
+			for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end() &amp;&amp; !UseHoverCraft; iud++ )
+				if( !iud-&gt;second.ud-&gt;canhover &amp;&amp; !iud-&gt;second.Disabled &amp;&amp; HoverCraftFactory.find(iud-&gt;first) == HoverCraftFactory.end() )
+					// known defect (unlikely, has yet to occur):
+					// for every iud, all prerequisites are capable of building other prerequisites but at the same time a buildline doesn't exist
+					for(map&lt;int,sRAIPrerequisite&gt;::iterator iP=iud-&gt;second.AllPrerequisiteOptions.begin(); iP!=iud-&gt;second.AllPrerequisiteOptions.end(); iP++)
+						if( !iP-&gt;second.udr-&gt;ud-&gt;canhover &amp;&amp; !iP-&gt;second.udr-&gt;Disabled &amp;&amp; HoverCraftFactory.find(iP-&gt;first) == HoverCraftFactory.end() )
+						{
+							bool alternative=false;
+							for(map&lt;int,sRAIUnitDef*&gt;::iterator iB=iP-&gt;second.udr-&gt;BuildOptions.begin(); iB!=iP-&gt;second.udr-&gt;BuildOptions.end(); iB++)
+								if( !iB-&gt;second-&gt;ud-&gt;canhover &amp;&amp; !iB-&gt;second-&gt;Disabled &amp;&amp; HoverCraftFactory.find(iB-&gt;first) == HoverCraftFactory.end() )
+									if( iB-&gt;first == iud-&gt;first || iud-&gt;second.AllPrerequisiteOptions.find(iB-&gt;first) != iud-&gt;second.AllPrerequisiteOptions.end() )
+									{
+										alternative = true;
+										break;
+									}
+							if( !alternative )
+							{
+//								*l&lt;&lt;&quot;\n  No alternative found: &quot;&lt;&lt;iP-&gt;second.udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; &quot;&lt;&lt;iud-&gt;second.ud-&gt;humanName;
+								UseHoverCraft = true;
+								break;
+							}
+						}
+		}
+
+		if( !UseHoverCraft )
+		{
+			*l&lt;&lt;&quot;\n Disabling all hovercraft &amp; their factories ...&quot;;
+			for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end() &amp;&amp; !UseHoverCraft; iud++ )
+			{
+				if( iud-&gt;second.ud-&gt;canhover || HoverCraftFactory.find(iud-&gt;first) != HoverCraftFactory.end() )
+				{
+//					*l&lt;&lt;&quot;\n  Disabling '&quot;&lt;&lt;iud-&gt;second.ud-&gt;humanName&lt;&lt;&quot;'&quot;;
+					iud-&gt;second.Disabled = true;
+					iud-&gt;second.CheckBuildOptions();
+				}
+			}
+		}
+	}
+
+	for(int iud=0; iud&lt;BLBuilder-&gt;UDefSize; iud++)
+	{
+		sRAIUnitDef *udr = BLBuilder-&gt;UDef[iud]-&gt;RUD;
+
+		// TEMPORARY, limits hubs from building extractors/geos/metalmakers - but only if something else can build it
+		if( udr-&gt;ud-&gt;speed == 0 )
+		{
+			set&lt;int&gt; deletion;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator i=udr-&gt;BuildOptions.begin(); i!=udr-&gt;BuildOptions.end(); i++ )
+			{
+				if( i-&gt;second-&gt;ud-&gt;speed == 0 )
+					if( i-&gt;second-&gt;ud-&gt;needGeo || i-&gt;second-&gt;ud-&gt;extractsMetal &gt; 0 || i-&gt;second-&gt;HighEnergyDemand )
+					{
+						bool alternative=false;
+						for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=i-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=i-&gt;second-&gt;PrerequisiteOptions.end(); iP++)
+							if( iP-&gt;second-&gt;ud-&gt;speed &gt; 0 &amp;&amp; !iP-&gt;second-&gt;Disabled )
+								alternative = true;
+						if( alternative )
+							deletion.insert(i-&gt;first);
+					}
+			}
+			for( set&lt;int&gt;::iterator i=deletion.begin(); i!=deletion.end(); i++ )
+			{
+				sRAIUnitDef *udr2 = udr-&gt;BuildOptions.find(*i)-&gt;second;
+//				*l&lt;&lt;&quot;\n  (Special Rule) Resource Build Option Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; (&quot;&lt;&lt;udr2-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr2-&gt;ud-&gt;humanName;
+				udr-&gt;BuildOptions.erase(udr2-&gt;ud-&gt;id);
+				udr2-&gt;PrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+				udr2-&gt;AllPrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+			}
+		}
+
+		// Unnecessary?: limit boat constructors from building land defences - but only if something else can build it
+		if( udr-&gt;ud-&gt;speed &gt; 0 &amp;&amp; udr-&gt;ud-&gt;minWaterDepth &gt;= 0 )
+		{
+			set&lt;int&gt; deletion;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator i=udr-&gt;BuildOptions.begin(); i!=udr-&gt;BuildOptions.end(); i++ )
+			{
+				if( i-&gt;second-&gt;ud-&gt;speed == 0 &amp;&amp; i-&gt;second-&gt;WeaponGuardRange &gt; 0 &amp;&amp; i-&gt;second-&gt;ud-&gt;minWaterDepth &lt; 0 )
+				{
+					bool alternative=false;
+					for( map&lt;int,sRAIUnitDef*&gt;::iterator iP=i-&gt;second-&gt;PrerequisiteOptions.begin(); iP!=i-&gt;second-&gt;PrerequisiteOptions.end(); iP++)
+						if( iP-&gt;second-&gt;ud-&gt;speed &gt; 0 &amp;&amp; !iP-&gt;second-&gt;Disabled &amp;&amp; iP-&gt;second-&gt;ud-&gt;minWaterDepth &lt; 0 )
+							alternative = true;
+					if( alternative )
+						deletion.insert(i-&gt;first);
+				}
+			}
+			for( set&lt;int&gt;::iterator i=deletion.begin(); i!=deletion.end(); i++ )
+			{
+				sRAIUnitDef *udr2 = udr-&gt;BuildOptions.find(*i)-&gt;second;
+//				*l&lt;&lt;&quot;\n  (Special Rule) Defence Build Option Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; (&quot;&lt;&lt;udr2-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr2-&gt;ud-&gt;humanName;
+				udr-&gt;BuildOptions.erase(udr2-&gt;ud-&gt;id);
+				udr2-&gt;PrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+				udr2-&gt;AllPrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+			}
+		}
+
+		// Unnecessary?: limit mobile land constructors from build underwater extractors
+		if( udr-&gt;ud-&gt;movedata != 0 &amp;&amp; !udr-&gt;ud-&gt;canfly &amp;&amp; !udr-&gt;ud-&gt;canhover &amp;&amp; udr-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; -udr-&gt;ud-&gt;movedata-&gt;depth &gt; TM-&gt;minElevation )
+		{
+			set&lt;int&gt; deletion;
+			for( map&lt;int,sRAIUnitDef*&gt;::iterator i=udr-&gt;BuildOptions.begin(); i!=udr-&gt;BuildOptions.end(); i++ )
+				if( -i-&gt;second-&gt;ud-&gt;minWaterDepth &lt; 0 &amp;&amp; i-&gt;second-&gt;ud-&gt;extractsMetal &gt; 0 )
+					deletion.insert(i-&gt;first);
+			for( set&lt;int&gt;::iterator i=deletion.begin(); i!=deletion.end(); i++ )
+			{
+				sRAIUnitDef *udr2 = udr-&gt;BuildOptions.find(*i)-&gt;second;
+//				*l&lt;&lt;&quot;\n  (Special Rule) Extractor Build Option Removed ... (&quot;&lt;&lt;udr-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr-&gt;ud-&gt;humanName&lt;&lt;&quot; -&gt; (&quot;&lt;&lt;udr2-&gt;ud-&gt;id&lt;&lt;&quot;)&quot;&lt;&lt;udr2-&gt;ud-&gt;humanName;
+				udr-&gt;BuildOptions.erase(udr2-&gt;ud-&gt;id);
+				udr2-&gt;PrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+				udr2-&gt;AllPrerequisiteOptions.erase(udr-&gt;ud-&gt;id);
+			}
+		}
+	}
+
+	*l&lt;&lt;&quot;\n Updating Unit Limits for Metal/Geo build options ...&quot;;
+	for( int i=0; i&lt;BLMetalL-&gt;UDefSize; i++ )
+		BLMetalL-&gt;UDef[i]-&gt;RUD-&gt;SetULConstructs(0);
+	if( BLMetalL-&gt;UDefSize == 0 &amp;&amp; BLMetal-&gt;UDefSize &gt; 0 )
+		BLMetal-&gt;minUnits = 1;
+	if( BLMetalL-&gt;UDefSize == 0 &amp;&amp; BLEnergyL-&gt;minUnits == 0 &amp;&amp; RM-&gt;RSize[1] &gt; 0 )
+		BLEnergyL-&gt;minUnits = 1;
+	for( int i=0; i&lt;BLEnergyL-&gt;UDefSize; i++ )
+		BLEnergyL-&gt;UDef[i]-&gt;RUD-&gt;SetULConstructs(0);
+
+	for(int ib=0; ib&lt;BLSize; ib++ )
+		for(int iu=0; iu&lt;BL[ib]-&gt;UDefSize; iu++)
+			BL[ib]-&gt;UDef[iu]-&gt;udIndex = iu;
+
+	*l&lt;&lt;&quot;\n Build-List Result ...&quot;;
+	for(int iBL=0; iBL&lt;BLSize; iBL++ )
+	{
+		*l&lt;&lt;&quot;\n  &quot;+BL[iBL]-&gt;Name+&quot; Build-List&quot;;
+		if( BL[iBL]-&gt;UDefSize==0 ||
+			(BL[iBL]-&gt;priority &lt;= 0 &amp;&amp; BL[iBL]!=BLBuilder &amp;&amp; BL[iBL]!=BLEnergyL &amp;&amp; BL[iBL]!=BLEnergy &amp;&amp; BL[iBL]!=BLMetalL
+			 &amp;&amp; BL[iBL]!=BLMetal &amp;&amp; BL[iBL]!=BLEnergyStorage &amp;&amp; BL[iBL]!=BLMetalStorage ) )
+			 *l&lt;&lt;&quot; (disabled)&quot;;
+		*l&lt;&lt;&quot;:  &quot;;
+		for(int iud=0; iud&lt;BL[iBL]-&gt;UDefSize; iud++)
+		{
+			*l&lt;&lt;&quot; &quot;+BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;ud-&gt;humanName+&quot;(&quot;;
+			if( BL[iBL]-&gt;UDef[iud]-&gt;RUD-&gt;Disabled )
+				*l&lt;&lt;&quot;disabled&quot;;
+			else
+				*l&lt;&lt;BL[iBL]-&gt;UDef[iud]-&gt;efficiency;
+			*l&lt;&lt;&quot;)&quot;;
+		}
+	}
+	*l&lt;&lt;&quot;\n  List of Undefined Units:&quot;;
+	for(map&lt;int,sRAIUnitDef&gt;::iterator iud=UDR.begin(); iud!=UDR.end(); iud++ )
+		if( iud-&gt;second.ListSize == 0 )
+			*l&lt;&lt;&quot;  &quot;+iud-&gt;second.ud-&gt;humanName;
+}
+
+cRAIUnitDefHandler::~cRAIUnitDefHandler()
+{
+	for(int i=0; i&lt;BLSize; i++)
+		delete BL[i];
+}
+
+void cRAIUnitDefHandler::BLSwitch(int index1, int index2)
+{
+	sRAIBuildList *pRBL = BL[index1];
+	BL[index1] = BL[index2];
+	BL[index2] = pRBL;
+	BL[index1]-&gt;index=index1;
+	BL[index2]-&gt;index=index2;
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,187 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_UNITDEF_H
+#define RAI_UNITDEF_H
+
+struct sRAIUnitDefBL;
+struct sRAIUnitDef;
+struct sRAIBuildList;
+class cRAIUnitDefHandler;
+
+//#include &quot;LogFile.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &lt;map&gt;
+//#include &lt;set&gt;
+#include &quot;GResourceMap.h&quot;
+#include &quot;GTerrainMap.h&quot;
+using std::map;
+using std::set;
+
+const int TASK_NONE = 1; // uses default combat behaviors
+const int TASK_CONSTRUCT = 2;
+const int TASK_ASSAULT = 3;
+const int TASK_SCOUT = 4;
+const int TASK_SUICIDE = 5;
+const int TASK_SUPPORT = 6;
+const int TASK_TRANSPORT = 7;
+
+struct sWeaponEfficiency
+{
+	float BestRange;	// Best range for fighting this enemy
+	float rate;			// unused
+};
+
+struct sRAIPrerequisite
+{
+	sRAIPrerequisite(sRAIUnitDef* RAIud)
+	{
+		udr=RAIud;
+		buildLine=0;
+	};
+	sRAIUnitDef *udr;
+	int buildLine;		// This refers to how many other builders must be build to reach this option
+};
+
+struct sRAIUnitDefBL
+{
+	sRAIUnitDefBL(sRAIUnitDef* RAIud, sRAIBuildList* BuildList, float Efficiency=-1.0, int Task=-1);
+	~sRAIUnitDefBL();
+
+	sRAIUnitDef* RUD;
+	sRAIBuildList* RBL;
+
+	int udIndex;
+//	int listIndex;
+	float efficiency;
+	int task;
+};
+
+struct sRAIUnitDef
+{
+	sRAIUnitDef(const UnitDef *unitdef, IAICallback* callback, GlobalResourceMap* RM, GlobalTerrainMap* TM, float EnergyToMetalRatio, cLogFile *l, float MaxFiringRange=3000.0);
+	int GetPrerequisite(); // returns UnitDef ID
+	int GetPrerequisiteNewBuilder();
+	void SetUnitLimit(int num);
+	void SetULConstructs(int num); // sets the number of units that can be built excluding 'UnitsActive' &amp;&amp; 'UnitConstructsActive'
+	void CheckUnitLimit();		// called after 'UnitsActive' or 'UnitConstructs' is modified, updates 'RBUnitLimit'
+	void CheckBuildOptions();	// called after 'RBUnitLimit','RBCost','RBPrereq','Disabled' or 'UnitsActive' is modified, updates 'CanBuild','CanBeBuilt','RBPrereq', and 'HasPrerequisite' for all 'BuildOptions'
+	bool IsNano();
+	bool IsCategory(string category); // only used during initialization
+	sRAIUnitDefBL* GetBuildList(string Name);
+
+	sRAIUnitDefBL *List[35];	// possible lists a unit may be assigned to
+	int ListSize;				// 'List' array size in use
+	map&lt;int,sRAIUnitDef*&gt; BuildOptions;					// key value = UnitDef ID, You could think of this as an improved version of UnitDef-&gt;buildOptions
+	map&lt;int,sRAIUnitDef*&gt; PrerequisiteOptions;			// key value = UnitDef ID, a list of the types of units can build this unit
+	map&lt;int,sRAIPrerequisite&gt; AllPrerequisiteOptions;	// key value = UnitDef ID, a list of anything that can build this unit, or somthing that can build a unit that can build this unit, or so on..
+//	map&lt;int,sWeaponEfficiency&gt; WeaponEff;				// UNFINISHED: key value = Enemy UnitDef ID
+	TerrainMapMobileType *mobileType;		// which Terrain-Map to use for building placement, immobile factories inherent this from it's build options
+	TerrainMapImmobileType *immobileType;	// which Terrain-Map to use for building placement
+	const UnitDef* ud;			// Always valid
+	bool HighEnergyDemand;		// This unit requires an unbalanced amount of energy to remain active, EX: metal makers, moho-mines in XTA
+	float MetalDifference;		// How much metal will this produce/cost
+	float EnergyDifference;		// How much energy will this produce/cost
+	float OnOffMetalDifference;	// How much metal will this produce/cost when turned on
+	float OnOffEnergyDifference;// How much energy will this produce/cost when turned on, does not consider cloaks
+	float CloakMaxEnergyDifference;	// - value, = to moving cloaking cost for units that can move or = to normal cost for units that can not
+	float MetalPCost;			// How much metal production is needed to consider building this
+	float EnergyPCost;			// How much energy production is needed to consider building this
+	bool IsBomber;
+	sWeaponEfficiency WeaponLandEff;	// used if enemy unitdef is unknown
+	sWeaponEfficiency WeaponAirEff;		// used if enemy unitdef is unknown
+	sWeaponEfficiency WeaponSeaEff;		// used if enemy unitdef is unknown
+	const WeaponDef *DGun;		// valid if ud-&gt;canDGun=true &amp;&amp; a dgun was found, otherwise 0
+	const WeaponDef *SWeapon;	// valid if a weapon is iW-&gt;def-&gt;stockpile &amp;&amp; iW-&gt;def-&gt;manualfire, otherwise 0
+	int WeaponEnergyDifference;	// - value, energy drain per second if firing all weapons continuously
+	float WeaponMaxEnergyCost;	// the highest amount of energy storage needed to fire any of it's indiviual weapons
+	float WeaponGuardRange;		// Base Defences only, distance for nearby structures to be considered 'guarded'
+//	set&lt;int&gt; WeaponDamageType;	// UNFINISHED: types of armors that this unit can damage
+
+	// This variables will change during the course of a game
+	set&lt;int&gt; UnitsActive;			// existing units of this type, used to determine active build options
+	set&lt;int&gt; UnitConstructsActive;	// existing constructions of this type
+	int UnitLimit[2];		// [0]: virtual unit limit, max units RAI is willing to build, ud-&gt;maxThisUnit is considered  [1]: remaining geo-sites/metal-sites, basicly a construction unit limit
+	int UnitConstructs;		// units of this type being built, used to help determine active build options
+	bool CanBuild;			// 'UnitsActive' is &gt; 0
+	bool CanBeBuilt;		// reverse result of (Disabled, RBUnitLimit, RBCost, RBPrereq) - in other words, RAI is willing to build this
+	bool HasPrerequisite;	// A unit in 'PrerequisiteOptions' has 'CanBuild' enabled
+	bool Disabled;			// RAI will not build this unit, however it may still use the unit if gained through given,captured,resurrected
+	bool RBUnitLimit;		// (R)estrict (B)uilding: the Max of this Unit has been built
+	bool RBCost;			// (R)estrict (B)uilding: the Cost is too high to build right now
+	bool RBPrereq;			// (R)estrict (B)uilding: No buildline of units in &quot;AllPrerequisiteOptions&quot; has 'CanBuild or CanBeBuilt' enabled
+private:
+	// only used during initialization
+	bool CheckWeaponType(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator udw, int type); // type = 1-3 (land,air,sea)
+	void SetBestWeaponEff(sWeaponEfficiency *we, int type, float MaxFiringRange);
+};
+
+struct sRAIBuildList
+{
+	sRAIBuildList(int MaxDefSize, cRAIUnitDefHandler *UDRHandler);
+	~sRAIBuildList();
+	void Disable(int udIndex, bool value=true);
+	void UDefSwitch(int index1, int index2);
+
+	string Name;			// for debugging
+	cRAIUnitDefHandler *UDR;
+	sRAIUnitDefBL **UDef;	// Possible Units to Build on this list, index is valid if &lt; UDefSize
+	int UDefActive;			// 'UDef' indexes below this value have 'CanBeBuilt=true', for later entries 'CanBeBuilt=false'
+	int UDefActiveTemp;		// Same as UDefActive, but may be moddifed to temperaryly disable some units within 'UDefActive'
+	int UDefSize;
+	int priority;			// Amount to build compared to other build lists, if this = -1 then these units are only built based on the needs of a different system
+	int minUnits;			// (Old) build at least this many before building anything else, however build demands will take presidence.  This is also used to rate the importantance of the buildlist
+	int unitsActive;		// The amount of units build from this list, used to keep track of the ratio of build options
+	int index;
+
+	// only used during initialization
+	float minEfficiency;	// The minimal efficiency a unit needs to be accepted for use in this build list.  Note: 1.0 = average value (default)
+							// Remember that it is not uncommon for there to be a unit this is bad at everything, such units are assigned to the task they are least bad at in respect to MinEfficiency
+};
+
+class cRAIUnitDefHandler
+{
+public:
+	cRAIUnitDefHandler(IAICallback* callback, GlobalResourceMap *RM, GlobalTerrainMap* TM, cLogFile *log);
+	~cRAIUnitDefHandler();
+
+	map&lt;int,sRAIUnitDef&gt; UDR;	// complete record of all unit definitions found, key value = Unit Def ID
+	sRAIBuildList *BL[35];
+	int BLSize;
+	int BLActive;
+	void BLSwitch(int index1, int index2);
+
+	// special buildlists
+	sRAIBuildList *BLBuilder;
+	sRAIBuildList *BLEnergy;
+	sRAIBuildList *BLEnergyL;
+	sRAIBuildList *BLMetal;
+	sRAIBuildList *BLMetalL;
+	sRAIBuildList *BLEnergyStorage;
+	sRAIBuildList *BLMetalStorage;
+	sRAIBuildList *BLMobileRadar;
+	sRAIBuildList *BLAirBase;
+
+	set&lt;TerrainMapMobileType*&gt; RBMobile;	// Restricts the building of certain units until a useable area has been reached
+	set&lt;TerrainMapImmobileType*&gt; RBImmobile;// Restricts the building of certain units until a useable area has been reached
+	float EnergyToMetalRatio;
+	float AverageConstructSpeed;
+private:
+	struct sBuildLine
+	{
+		sBuildLine(int id, int bl)
+		{
+			ID=id;
+			BL=bl;
+		};
+		int ID;	// UnitDef ID
+		int BL;	// BuildLine, the amount of prerequisites that need to be build to reach this option
+	};
+	cLogFile *l;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/UnitDefHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/UnitManager.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/UnitManager.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/UnitManager.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,523 @@
+#include &quot;UnitManager.h&quot;
+//#include &quot;LogFile.h&quot;
+
+sRAIGroup::sRAIGroup(int Index)
+{
+	index = Index;
+	M = 0;
+	C = 0;
+}
+
+sRAIGroup::~sRAIGroup()
+{
+	for( map&lt;int,EnemyInfo*&gt;::iterator i=Enemies.begin(); i!=Enemies.end(); i++ )
+	{
+		i-&gt;second-&gt;attackGroups.erase(this);
+	}
+}
+
+cUnitManager::cUnitManager(IAICallback* callback, cRAI* Global)
+{
+	cb=callback;
+	G=Global;
+	l=G-&gt;l;
+	GroupSize=0;
+	AttackOrders=false;
+	SLSize=0;
+}
+
+void cUnitManager::UnitFinished(int unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; (t=&quot;&lt;&lt;U-&gt;udrBL-&gt;task&lt;&lt;&quot;)&quot;;
+	switch( U-&gt;udrBL-&gt;task )
+	{
+	case TASK_CONSTRUCT:
+		G-&gt;B-&gt;UBuilderFinished(unit,U);
+		break;
+	case TASK_ASSAULT:
+		{
+			UAssault.insert(cRAI::iupPair(unit,U));
+			UpdateGroupSize();
+			Assign(unit,U);
+			if( ActiveAttackOrders() )
+				SendattackGroups();
+		}
+		break;
+	case TASK_SCOUT:
+		{
+			UScout.insert(isPair(unit,sScoutUnitInfo()));
+		}
+		break;
+	case TASK_SUICIDE:
+		{
+			USuicide.insert(cRAI::iupPair(unit,U));
+		}
+		break;
+	case TASK_SUPPORT:
+		{
+			USupport.insert(unit);
+		}
+		break;
+	case TASK_TRANSPORT:
+		{
+			UTrans.insert(itPair(unit,sTransportUnitInfo(U-&gt;ud)));
+		}
+		break;
+	}
+}
+
+void cUnitManager::UnitDestroyed(int unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; (t=&quot;&lt;&lt;U-&gt;udrBL-&gt;task&lt;&lt;&quot;)&quot;;
+	switch( U-&gt;udrBL-&gt;task )
+	{
+	case TASK_CONSTRUCT:
+		G-&gt;B-&gt;UBuilderDestroyed(unit,U);
+		break;
+	case TASK_ASSAULT:
+		{
+			UAssault.erase(unit);
+			GroupRemoveUnit(unit,U);
+		}
+		break;
+	case TASK_SCOUT:
+		{
+			UScout.erase(unit);
+		}
+		break;
+	case TASK_SUICIDE:
+		{
+			USuicide.erase(unit);
+		}
+		break;
+	case TASK_SUPPORT:
+		{
+			USupport.erase(unit);
+		}
+		break;
+	case TASK_TRANSPORT:
+		{
+			UTrans.erase(unit);
+		}
+		break;
+	}
+}
+
+void cUnitManager::UnitIdle(int unit,UnitInfo *U)
+{
+//	*l&lt;&lt;&quot; (t=&quot;&lt;&lt;U-&gt;udrBL-&gt;task&lt;&lt;&quot;)&quot;;
+	switch( U-&gt;udrBL-&gt;task )
+	{
+	case TASK_CONSTRUCT:
+		G-&gt;B-&gt;UBuilderIdle(unit,U);
+		break;
+	case TASK_ASSAULT:
+		{
+			if( int(U-&gt;group-&gt;Enemies.size()) &gt; 0 )
+			{
+				U-&gt;inCombat = true;
+				G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+90,unit,U);
+			}
+			if( G-&gt;Enemies.size() == 0 &amp;&amp; (UAssault.size() &gt; 50 || (G-&gt;UDH-&gt;BLMobileRadar-&gt;UDefActiveTemp == 0)) )
+			{
+				int num=0;
+				for( map&lt;int,UnitInfo*&gt;::iterator iU = U-&gt;group-&gt;Units.begin(); iU != U-&gt;group-&gt;Units.end(); iU++ )
+				{
+					if( cb-&gt;GetUnitPos(iU-&gt;first).distance2D(U-&gt;group-&gt;M-&gt;ScoutPoint) &lt; 350.0f )
+						num++;
+				}
+				if( num &gt;= 1+int(U-&gt;group-&gt;Units.size())/2 )
+				{
+					U-&gt;group-&gt;M-&gt;ScoutPoint = G-&gt;GetRandomPosition(U-&gt;area);
+					for( map&lt;int,UnitInfo*&gt;::iterator iU = U-&gt;group-&gt;Units.begin(); iU != U-&gt;group-&gt;Units.end(); iU++ )
+						G-&gt;UpdateEventAdd(1,0,iU-&gt;first,iU-&gt;second);
+				}
+
+				Command c;
+				if( cb-&gt;GetUnitPos(unit).distance2D(U-&gt;group-&gt;M-&gt;ScoutPoint) &lt; 400.0f )
+				{
+					c.id = CMD_WAIT;
+					c.timeOut = cb-&gt;GetCurrentFrame()+900;
+//					G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+300,unit,U);
+				}
+				else
+				{
+					c.id = CMD_MOVE;
+					c.params.push_back(U-&gt;group-&gt;M-&gt;ScoutPoint.x);
+					c.params.push_back(U-&gt;group-&gt;M-&gt;ScoutPoint.y);
+					c.params.push_back(U-&gt;group-&gt;M-&gt;ScoutPoint.z);
+				}
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+			else
+			{
+				Command c;
+				if( cb-&gt;GetUnitPos(unit).distance2D(U-&gt;group-&gt;M-&gt;RallyPoint) &lt; 400.0f )
+				{
+					c.id = CMD_WAIT;
+					c.timeOut = cb-&gt;GetCurrentFrame()+900;
+//					G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+900,unit,U);
+				}
+				else
+				{
+					c.id = CMD_MOVE;
+					c.params.push_back(U-&gt;group-&gt;M-&gt;RallyPoint.x);
+					c.params.push_back(U-&gt;group-&gt;M-&gt;RallyPoint.y);
+					c.params.push_back(U-&gt;group-&gt;M-&gt;RallyPoint.z);
+				}
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+		}
+		break;
+	case TASK_SCOUT:
+		{
+			sScoutUnitInfo *S = &amp;UScout.find(unit)-&gt;second;
+			if( S-&gt;ScoutLocAssigned )
+			{
+				float3 Pos=cb-&gt;GetUnitPos(unit);
+				const UnitDef* ud = cb-&gt;GetUnitDef(unit);
+
+				if( Pos.x - S-&gt;SL-&gt;position.x &gt; 100 || Pos.x - S-&gt;SL-&gt;position.x &lt; -100 || Pos.z - S-&gt;SL-&gt;position.z &gt; 100 || Pos.z - S-&gt;SL-&gt;position.z &lt; -100 )
+				{
+					Command c;
+					c.id = CMD_MOVE;
+					c.params.push_back(S-&gt;SL-&gt;position.x);
+					c.params.push_back(S-&gt;SL-&gt;position.y);
+					c.params.push_back(S-&gt;SL-&gt;position.z);
+					cb-&gt;GiveOrder(unit, &amp;c);
+				}
+				return;
+			}
+			if( SLSize&gt;0 )
+			{
+				S-&gt;SL= SL[0];
+				SL[0]=SL[--SLSize];
+				UnitIdle(unit,U);
+				return;
+			}
+			Command c;
+			c.id = CMD_MOVE;
+			float3 movePos=G-&gt;GetRandomPosition(U-&gt;area);
+			c.params.push_back(movePos.x);
+			c.params.push_back(movePos.y);
+			c.params.push_back(movePos.z);
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		break;
+	case TASK_SUICIDE:
+		{
+			Command c;
+			if( int(G-&gt;Enemies.size()) &gt; 0 &amp;&amp; G-&gt;CM-&gt;GetClosestEnemy(cb-&gt;GetUnitPos(unit), U) &gt;= 0 )
+			{
+				set&lt;int&gt; Targets;
+				for( map&lt;int,EnemyInfo&gt;::iterator iE=G-&gt;Enemies.begin(); iE!=G-&gt;Enemies.end(); iE++ )
+					if( G-&gt;TM-&gt;CanMoveToPos(U-&gt;area,G-&gt;CM-&gt;GetEnemyPosition(iE-&gt;first,&amp;iE-&gt;second)) )
+						Targets.insert(iE-&gt;first);
+
+				int iT=rand()%int(Targets.size());
+				set&lt;int&gt;::iterator enemyID = Targets.begin();
+				for( int i=0; i&lt;iT; i++,enemyID++ ) {}
+
+				U-&gt;inCombat=true;
+				U-&gt;enemyID = *enemyID;
+				U-&gt;E = &amp;G-&gt;Enemies.find(U-&gt;enemyID)-&gt;second;
+				U-&gt;enemyEff = G-&gt;CM-&gt;CanAttack(U,U-&gt;E,G-&gt;CM-&gt;GetEnemyPosition(U-&gt;enemyID,U-&gt;E));
+
+				c.id = CMD_ATTACK;
+				c.params.push_back(U-&gt;enemyID);
+				cb-&gt;GiveOrder(unit,&amp;c);
+				return;
+			}
+
+			c.id = CMD_MOVE;
+			float3 movePos=G-&gt;GetRandomPosition(U-&gt;area);
+			c.params.push_back(movePos.x);
+			c.params.push_back(movePos.y);
+			c.params.push_back(movePos.z);
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		break;
+	case TASK_SUPPORT:
+		{
+			Command c;
+			c.id = CMD_WAIT;
+			cb-&gt;GiveOrder(unit, &amp;c);
+		}
+		break;
+	case TASK_TRANSPORT:
+		{
+			sTransportUnitInfo *T = &amp;UTrans.find(unit)-&gt;second;
+			if( T-&gt;AssistID == -1 )
+			{
+				Command c;
+				c.id = CMD_WAIT;
+				cb-&gt;GiveOrder(unit, &amp;c);
+
+				G-&gt;UpdateEventAdd(1,cb-&gt;GetCurrentFrame()+450,unit,U);
+			}
+		}
+		break;
+	}
+}
+
+void cUnitManager::EnemyEnterLOS(int enemy,EnemyInfo *E)
+{
+	EnemyEnterRadar(enemy,E);
+}
+
+void cUnitManager::EnemyEnterRadar(int enemy,EnemyInfo *E)
+{
+	if( ActiveAttackOrders() )
+		SendattackGroups();
+}
+
+bool cUnitManager::UnitMoveFailed(int unit, UnitInfo *U)
+{
+	if( int(UTrans.size()) == 0 )
+		return false;
+	for( map&lt;int,sTransportUnitInfo&gt;::iterator iT=UTrans.begin(); iT!=UTrans.end(); iT++ )
+	{
+		if( iT-&gt;second.AssistID == -1 &amp;&amp; iT-&gt;second.ud-&gt;transportMass &gt;= U-&gt;ud-&gt;mass )
+		{
+			iT-&gt;second.AssistID=unit;
+			//return true;
+		}
+	}
+	return false;
+}
+
+void cUnitManager::UpdateGroupSize()
+{
+	MaxGroupMSize=5+int(UAssault.size())/4;
+}
+
+bool cUnitManager::ActiveAttackOrders()
+{
+	if( int(G-&gt;Enemies.size()) == 0 )
+	{
+//		if( AttackOrders ) cb-&gt;SendTextMsg(&quot;Defending&quot;,5);
+		AttackOrders=false;
+	}
+	else if( int(UAssault.size()) &gt;= 60 || (int(UAssault.size()) &gt;= 6 &amp;&amp; int(UAssault.size()) &gt; 0.8*G-&gt;Enemies.size()) || G-&gt;UDH-&gt;BLBuilder-&gt;UDefActive == 0 )
+	{
+//		if( !AttackOrders ) cb-&gt;SendTextMsg(&quot;Attacking&quot;,5);
+		AttackOrders=true;
+	}
+	else if( int(UAssault.size()) &lt;= 4 || (int(UAssault.size()) &lt;= 40 &amp;&amp; int(UAssault.size()) &lt; 0.533*G-&gt;Enemies.size()) )
+	{
+		if( AttackOrders )
+		{
+//			cb-&gt;SendTextMsg(&quot;Defending&quot;,5);
+			AttackOrders=false;
+			for( int i=0; i&lt;GroupSize; i++ ) // TEMP
+			{
+				set&lt;int&gt; deletion;
+				for( map&lt;int,EnemyInfo*&gt;::iterator iE = Group[i]-&gt;Enemies.begin(); iE != Group[i]-&gt;Enemies.end(); iE++ )
+					if( iE-&gt;second-&gt;baseThreatID == -1 )
+						deletion.insert(iE-&gt;first);
+				while( int(deletion.size()) &gt; 0 )
+				{
+					GroupRemoveEnemy(*deletion.begin(),Group[i]-&gt;Enemies.find(*deletion.begin())-&gt;second,Group[i]);
+					deletion.erase(*deletion.begin());
+				}
+			}
+		}
+	}
+
+	return AttackOrders;
+}
+
+void cUnitManager::GroupAddUnit(int unit, UnitInfo* U, sRAIGroup* group)
+{
+	group-&gt;Units.insert(cRAI::iupPair(unit,U));
+	U-&gt;group = group;
+	if( int(group-&gt;Enemies.size()) &gt; 0 )
+		U-&gt;inCombat = true;
+
+	if( U-&gt;udrBL-&gt;task == TASK_ASSAULT )
+	{
+		if( group-&gt;M == 0 )
+			group-&gt;M = new sRAIGroupMilitary;
+		group-&gt;M-&gt;count++;
+	}
+	else if( U-&gt;udrBL-&gt;task == TASK_CONSTRUCT )
+	{
+		if( group-&gt;C == 0 )
+			group-&gt;C = new sRAIGroupConstruct;
+		group-&gt;C-&gt;count++;
+	}
+}
+
+void cUnitManager::GroupRemoveUnit(int unit, UnitInfo* U)
+{
+	UpdateGroupSize();
+	U-&gt;group-&gt;Units.erase(unit);
+
+	if( U-&gt;udrBL-&gt;task == TASK_ASSAULT )
+	{
+		U-&gt;group-&gt;M-&gt;count--;
+		if( U-&gt;group-&gt;M-&gt;count == 0 )
+		{
+			delete U-&gt;group-&gt;M;
+			U-&gt;group-&gt;M = 0;
+		}
+	}
+	else if( U-&gt;udrBL-&gt;task == TASK_CONSTRUCT )
+	{
+		U-&gt;group-&gt;C-&gt;count--;
+		if( U-&gt;group-&gt;C-&gt;count == 0 )
+		{
+			delete U-&gt;group-&gt;C;
+			U-&gt;group-&gt;C = 0;
+		}
+	}
+
+	if( int(U-&gt;group-&gt;Units.size()) == 0 )
+	{
+		GroupSize--;
+		sRAIGroup* RGroup=Group[U-&gt;group-&gt;index];
+		Group[U-&gt;group-&gt;index]=Group[GroupSize];
+		Group[U-&gt;group-&gt;index]-&gt;index = U-&gt;group-&gt;index;
+		delete RGroup;
+	}
+}
+
+void cUnitManager::GroupAddEnemy(int enemy, EnemyInfo *E, sRAIGroup* group)
+{
+	if( !G-&gt;ValidateUnitList(&amp;group-&gt;Units) )
+		return;
+
+	group-&gt;Enemies.insert(cRAI::iepPair(enemy,E));
+	E-&gt;attackGroups.insert(group);
+	if( group-&gt;Enemies.size() == 1 )
+	{
+		for( map&lt;int,UnitInfo*&gt;::iterator iU = group-&gt;Units.begin(); iU != group-&gt;Units.end(); iU++ )
+		{
+			iU-&gt;second-&gt;inCombat=true;
+			if( !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+				G-&gt;UpdateEventAdd(1,-1,iU-&gt;first,iU-&gt;second);
+		}
+	}
+}
+
+void cUnitManager::GroupRemoveEnemy(int enemy, EnemyInfo *E, sRAIGroup* group)
+{
+	if( !G-&gt;ValidateUnitList(&amp;group-&gt;Units) )
+		return;
+
+	group-&gt;Enemies.erase(enemy);
+	E-&gt;attackGroups.erase(group);
+	for( map&lt;int,UnitInfo*&gt;::iterator iU = group-&gt;Units.begin(); iU != group-&gt;Units.end(); iU++ )
+	{
+		if( iU-&gt;second-&gt;enemyID == enemy )
+		{
+			iU-&gt;second-&gt;enemyID = -1;
+			if( !G-&gt;IsHumanControled(iU-&gt;first,iU-&gt;second) )
+				G-&gt;UpdateEventAdd(1,0,iU-&gt;first,iU-&gt;second);
+		}
+	}
+	if( int(group-&gt;Enemies.size()) == 0 &amp;&amp; int(G-&gt;EThreat.size()) == 0 &amp;&amp; !ActiveAttackOrders() )
+	{
+		GroupResetRallyPoint(group);
+		group-&gt;M-&gt;ScoutPoint = G-&gt;GetRandomPosition(group-&gt;Units.begin()-&gt;second-&gt;area);
+	}
+}
+
+void cUnitManager::GroupResetRallyPoint(sRAIGroup* group)
+{
+	float3 GPos = cb-&gt;GetUnitPos(group-&gt;Units.begin()-&gt;first);
+	UnitInfo* GU = group-&gt;Units.begin()-&gt;second;
+	int iBest=-1;
+	UnitInfo* uBest;
+
+	G-&gt;ValidateUnitList(&amp;G-&gt;UImmobile);
+	for(map&lt;int,UnitInfo*&gt;::iterator iU=G-&gt;UImmobile.begin(); iU!=G-&gt;UImmobile.end(); iU++)
+	{
+		if( G-&gt;TM-&gt;CanMoveToPos(GU-&gt;area,cb-&gt;GetUnitPos(iU-&gt;first)) &amp;&amp; GPos.distance2D(cb-&gt;GetUnitPos(iU-&gt;first)) &lt; GPos.distance2D(cb-&gt;GetUnitPos(iBest)) )
+		{
+			iBest = iU-&gt;first;
+			uBest = iU-&gt;second;
+		}
+	}
+
+	if( iBest != -1 )
+		group-&gt;M-&gt;RallyPoint = cb-&gt;GetUnitPos(iBest);
+	else
+		group-&gt;M-&gt;RallyPoint = GPos;
+//	G-&gt;DebugDrawShape(group-&gt;M-&gt;RallyPoint,100.0f,50,0,50,900);
+
+	if( group-&gt;M-&gt;RallyPoint.x &lt; 8*cb-&gt;GetMapWidth() - group-&gt;M-&gt;RallyPoint.x )
+		group-&gt;M-&gt;RallyPoint.x -= 300;
+	else
+		group-&gt;M-&gt;RallyPoint.x += 300;
+	if( group-&gt;M-&gt;RallyPoint.z &lt; 8*cb-&gt;GetMapHeight() - group-&gt;M-&gt;RallyPoint.z )
+		group-&gt;M-&gt;RallyPoint.z -= 300;
+	else
+		group-&gt;M-&gt;RallyPoint.z += 300;
+
+	group-&gt;M-&gt;RallyPoint.x += -250.0f + rand()%501;
+	group-&gt;M-&gt;RallyPoint.z += -250.0f + rand()%501;
+	G-&gt;CorrectPosition(group-&gt;M-&gt;RallyPoint);
+//	G-&gt;DebugDrawShape(group-&gt;M-&gt;RallyPoint,100.0f,25,0,50,900);
+
+	float3 pos = cb-&gt;ClosestBuildSite(GU-&gt;ud,group-&gt;M-&gt;RallyPoint,800,15);
+	if( pos.x &lt;= 0 &amp;&amp; pos.y &lt;= 0 &amp;&amp; pos.z &lt;= 0 )
+		pos = cb-&gt;ClosestBuildSite(GU-&gt;ud,group-&gt;M-&gt;RallyPoint,800,3);
+	if( pos.x &lt;= 0 &amp;&amp; pos.y &lt;= 0 &amp;&amp; pos.z &lt;= 0 )
+		group-&gt;M-&gt;RallyPoint = GPos;
+	else
+		group-&gt;M-&gt;RallyPoint = pos;
+
+//	G-&gt;DebugDrawShape(group-&gt;M-&gt;RallyPoint,100.0f,5,0,50,900);
+}
+
+void cUnitManager::Assign(int unit,UnitInfo *U)
+{
+	set&lt;int&gt; Grs;
+	for( int i=0; i&lt;GroupSize; i++ )
+	{
+		if( U-&gt;area == Group[i]-&gt;Units.begin()-&gt;second-&gt;area &amp;&amp;
+			U-&gt;ud-&gt;canLoopbackAttack == Group[i]-&gt;Units.begin()-&gt;second-&gt;udr-&gt;ud-&gt;canLoopbackAttack &amp;&amp;
+			int(Group[i]-&gt;Units.size()) &lt; MaxGroupMSize )
+		{
+			Grs.insert(i);
+			for(map&lt;int,UnitInfo*&gt;::iterator GM=Group[i]-&gt;Units.begin(); GM!=Group[i]-&gt;Units.end(); GM++)
+			{
+				sRAIUnitDef* udr = GM-&gt;second-&gt;udr;
+				if( U-&gt;ud-&gt;speed &gt; 1.5*udr-&gt;ud-&gt;speed || 1.5*U-&gt;ud-&gt;speed &lt; udr-&gt;ud-&gt;speed )
+				{
+					Grs.erase(i);
+					break;
+				}
+			}
+		}
+	}
+
+	if( GroupSize == 25 &amp;&amp; int(Grs.size()) == 0 )
+	{
+		*l&lt;&lt;&quot;\nWARNING: Maximum number of groups reached&quot;;
+		Grs.insert(24);
+	}
+
+	if( int(Grs.size()) &gt; 0 )
+	{
+		GroupAddUnit(unit,U,Group[*Grs.begin()]);
+	}
+	else
+	{
+		Group[GroupSize] = new sRAIGroup(GroupSize);
+		sRAIGroup* group = Group[GroupSize];
+		GroupSize++;
+
+		GroupAddUnit(unit,U,group);
+		group-&gt;M-&gt;ScoutPoint = G-&gt;GetRandomPosition(U-&gt;area);
+		GroupResetRallyPoint(group);
+	}
+}
+
+void cUnitManager::SendattackGroups()
+{
+	for( int i=0; i&lt;GroupSize; i++ )
+		if( int(Group[i]-&gt;Enemies.size()) == 0 &amp;&amp; (int(Group[i]-&gt;Units.size()) &gt;= 4 || G-&gt;UDH-&gt;BLBuilder-&gt;UDefActive == 0) )
+			int enemyID = G-&gt;CM-&gt;GetClosestEnemy(cb-&gt;GetUnitPos(Group[i]-&gt;Units.begin()-&gt;first),Group[i]-&gt;Units.begin()-&gt;second);
+}


Property changes on: branches/caiinterface/AI/Skirmish/RAI/UnitManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/UnitManager.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/UnitManager.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/UnitManager.h	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,130 @@
+// _____________________________________________________
+//
+// RAI - Skirmish AI for TA Spring
+// Author: Reth / Michael Vadovszki
+// _____________________________________________________
+
+#ifndef RAI_UNIT_MANAGER_H
+#define RAI_UNIT_MANAGER_H
+
+struct sRAIGroup;
+class cUnitManager;
+
+#include &quot;RAI.h&quot;
+using std::map;
+using std::set;
+//#include &quot;LogFile.h&quot;
+//#include &quot;ExternalAI/IAICallback.h&quot;
+//#include &quot;Sim/Units/UnitDef.h&quot;
+//#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+//#include &lt;map&gt;
+
+struct sRAIGroupMilitary
+{
+	sRAIGroupMilitary()
+	{
+		count=0;
+	};
+
+	float3 RallyPoint;
+	float3 ScoutPoint;
+	int count;
+};
+
+struct sRAIGroupConstruct
+{
+	sRAIGroupConstruct()
+	{
+		BuildSpeed=0.0f;
+		count=0;
+	};
+
+	float BuildSpeed;
+	int count;
+};
+
+struct sRAIGroup
+{
+	sRAIGroup(int Index);
+	~sRAIGroup();
+
+	int index;
+	map&lt;int,UnitInfo*&gt; Units;
+	map&lt;int,EnemyInfo*&gt; Enemies;
+
+	sRAIGroupMilitary* M;
+	sRAIGroupConstruct* C;
+//	UnitInfo* Radar;
+//	UnitInfo* Jammer;
+//	UnitInfo* AntiMis;
+//	UnitInfo* Engineer;
+};
+
+class cUnitManager
+{
+public:
+	cUnitManager(IAICallback* callback, cRAI* Global);
+	~cUnitManager() {};
+
+	void UnitFinished(int unit,UnitInfo *U);
+	void UnitDestroyed(int unit,UnitInfo *U);
+	void UnitIdle(int unit,UnitInfo *U);
+	void EnemyEnterLOS(int enemy,EnemyInfo *E);
+	void EnemyEnterRadar(int enemy,EnemyInfo *E);
+	bool UnitMoveFailed(int unit,UnitInfo *U);
+	void UpdateGroupSize();
+	bool ActiveAttackOrders();
+	void GroupAddUnit(int unit, UnitInfo* U, sRAIGroup* group);
+	void GroupRemoveUnit(int unit, UnitInfo* U);
+	void GroupAddEnemy(int enemy, EnemyInfo *E, sRAIGroup* group);
+	void GroupRemoveEnemy(int enemy, EnemyInfo *E, sRAIGroup* group);
+	void GroupResetRallyPoint(sRAIGroup* group);
+
+//	bool AssaultScouts;
+
+	sRAIGroup* Group[25];
+//	sRAIGroup* Commander;
+	int GroupSize;
+private:
+
+	bool AttackOrders;
+
+	int MaxGroupMSize;
+	void Assign(int unit,UnitInfo *U);
+	void SendattackGroups();
+
+	map&lt;int,UnitInfo*&gt; UAssault;	// key = unit id
+	map&lt;int,UnitInfo*&gt; USuicide;
+	set&lt;int&gt; USupport;
+
+	struct sTransportUnitInfo
+	{
+		sTransportUnitInfo(const UnitDef *unitdef) { ud=unitdef; AssistID=-1; };
+		const UnitDef *ud;
+		int AssistID;
+	};
+	typedef pair&lt;int,sTransportUnitInfo&gt; itPair;
+	map&lt;int,sTransportUnitInfo&gt; UTrans;
+
+	struct sScoutPosition
+	{
+		int ScoutID;
+		float3 position;
+	};
+	sScoutPosition *SL[20];
+	int SLSize;
+	struct sScoutUnitInfo
+	{
+		sScoutUnitInfo() { ScoutLocAssigned=false; };
+		sScoutPosition *SL;
+		bool ScoutLocAssigned;
+	};
+	typedef pair&lt;int,sScoutUnitInfo&gt; isPair;
+	map&lt;int,sScoutUnitInfo&gt; UScout;
+
+	IAICallback *cb;
+	cRAI* G;
+	cLogFile *l;
+};
+
+#endif


Property changes on: branches/caiinterface/AI/Skirmish/RAI/UnitManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/VERSION
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/VERSION	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/VERSION	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1 @@
+0.601
\ No newline at end of file


Property changes on: branches/caiinterface/AI/Skirmish/RAI/VERSION
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.sln
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.sln	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.sln	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,19 @@
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RAI&quot;, &quot;RAI.vcproj&quot;, &quot;{A3E41465-AFF9-484D-A4D4-694DBAE7285D}&quot;
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Debug|Win32.Build.0 = Debug|Win32
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Release|Win32.ActiveCfg = Release|Win32
+		{A3E41465-AFF9-484D-A4D4-694DBAE7285D}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal


Property changes on: branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.sln
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.vcproj
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.vcproj	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.vcproj	2008-10-13 17:57:00 UTC (rev 6697)
@@ -0,0 +1,297 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
+&lt;VisualStudioProject
+	ProjectType=&quot;Visual C++&quot;
+	Version=&quot;9.00&quot;
+	Name=&quot;RAI&quot;
+	ProjectGUID=&quot;{A3E41465-AFF9-484D-A4D4-694DBAE7285D}&quot;
+	RootNamespace=&quot;NewAI&quot;
+	Keyword=&quot;Win32Proj&quot;
+	TargetFrameworkVersion=&quot;131072&quot;
+	&gt;
+	&lt;Platforms&gt;
+		&lt;Platform
+			Name=&quot;Win32&quot;
+		/&gt;
+	&lt;/Platforms&gt;
+	&lt;ToolFiles&gt;
+	&lt;/ToolFiles&gt;
+	&lt;Configurations&gt;
+		&lt;Configuration
+			Name=&quot;Debug|Win32&quot;
+			OutputDirectory=&quot;$(ConfigurationName)&quot;
+			IntermediateDirectory=&quot;$(ConfigurationName)&quot;
+			ConfigurationType=&quot;2&quot;
+			CharacterSet=&quot;2&quot;
+			WholeProgramOptimization=&quot;1&quot;
+			&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				Optimization=&quot;0&quot;
+				FavorSizeOrSpeed=&quot;0&quot;
+				AdditionalIncludeDirectories=&quot;../../../../rts;../../../../rts/system&quot;
+				PreprocessorDefinitions=&quot;WIN32;_DEBUG;_WINDOWS;_USRDLL;NEWAI_EXPORTS&quot;
+				MinimalRebuild=&quot;true&quot;
+				BasicRuntimeChecks=&quot;3&quot;
+				RuntimeLibrary=&quot;3&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;true&quot;
+				DebugInformationFormat=&quot;4&quot;
+				DisableSpecificWarnings=&quot;4244;4996;4800;4018;4267&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				Version=&quot;0.55&quot;
+				LinkIncremental=&quot;2&quot;
+				GenerateDebugInformation=&quot;true&quot;
+				SubSystem=&quot;2&quot;
+				RandomizedBaseAddress=&quot;1&quot;
+				DataExecutionPrevention=&quot;0&quot;
+				TargetMachine=&quot;1&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCALinkTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManifestTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXDCMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCBscMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCFxCopTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCAppVerifierTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;
+			/&gt;
+		&lt;/Configuration&gt;
+		&lt;Configuration
+			Name=&quot;Release|Win32&quot;
+			OutputDirectory=&quot;$(ConfigurationName)&quot;
+			IntermediateDirectory=&quot;$(ConfigurationName)&quot;
+			ConfigurationType=&quot;2&quot;
+			CharacterSet=&quot;1&quot;
+			WholeProgramOptimization=&quot;1&quot;
+			&gt;
+			&lt;Tool
+				Name=&quot;VCPreBuildEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCustomBuildTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXMLDataGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCWebServiceProxyGeneratorTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCMIDLTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCCLCompilerTool&quot;
+				FavorSizeOrSpeed=&quot;1&quot;
+				AdditionalIncludeDirectories=&quot;../../../../rts;../../../../rts/system;../../../../../mingwlibs/include&quot;
+				PreprocessorDefinitions=&quot;WIN32;NDEBUG;_WINDOWS;_USRDLL;NEWAI_EXPORTS&quot;
+				RuntimeLibrary=&quot;2&quot;
+				UsePrecompiledHeader=&quot;0&quot;
+				WarningLevel=&quot;3&quot;
+				Detect64BitPortabilityProblems=&quot;false&quot;
+				DebugInformationFormat=&quot;3&quot;
+				DisableSpecificWarnings=&quot;4244;4996;4018;4267;4311;4312&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManagedResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCResourceCompilerTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPreLinkEventTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCLinkerTool&quot;
+				Version=&quot;0.55&quot;
+				LinkIncremental=&quot;1&quot;
+				GenerateDebugInformation=&quot;true&quot;
+				SubSystem=&quot;2&quot;
+				OptimizeReferences=&quot;2&quot;
+				EnableCOMDATFolding=&quot;2&quot;
+				RandomizedBaseAddress=&quot;1&quot;
+				DataExecutionPrevention=&quot;0&quot;
+				TargetMachine=&quot;1&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCALinkTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCManifestTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCXDCMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCBscMakeTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCFxCopTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCAppVerifierTool&quot;
+			/&gt;
+			&lt;Tool
+				Name=&quot;VCPostBuildEventTool&quot;
+			/&gt;
+		&lt;/Configuration&gt;
+	&lt;/Configurations&gt;
+	&lt;References&gt;
+	&lt;/References&gt;
+	&lt;Files&gt;
+		&lt;Filter
+			Name=&quot;Source Files&quot;
+			Filter=&quot;cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx&quot;
+			UniqueIdentifier=&quot;{4FC737F1-C7A5-4376-A066-2A32D752A2FF}&quot;
+			&gt;
+			&lt;File
+				RelativePath=&quot;..\Builder.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\BuilderPlacement.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\CombatManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GResourceMap.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GTerrainMap.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\LogFile.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\PowerManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\RAI.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\SWeaponManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitDefHandler.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Resource Files&quot;
+			Filter=&quot;rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav&quot;
+			UniqueIdentifier=&quot;{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}&quot;
+			&gt;
+			&lt;File
+				RelativePath=&quot;..\DLLExportRAI.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+		&lt;Filter
+			Name=&quot;Header Files&quot;
+			Filter=&quot;h;hpp;hxx;hm;inl;inc;xsd&quot;
+			UniqueIdentifier=&quot;{93995380-89BD-4b04-88EB-625FBE52EBFB}&quot;
+			&gt;
+			&lt;File
+				RelativePath=&quot;..\BasicArray.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\Builder.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\BuilderPlacement.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\CombatManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GResourceMap.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\GTerrainMap.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\LogFile.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\PowerManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\RAI.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\SWeaponManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitDefHandler.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\UnitManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+		&lt;/Filter&gt;
+	&lt;/Files&gt;
+	&lt;Globals&gt;
+	&lt;/Globals&gt;
+&lt;/VisualStudioProject&gt;


Property changes on: branches/caiinterface/AI/Skirmish/RAI/VS2008/RAI.vcproj
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/CMakeLists.txt
===================================================================
--- branches/caiinterface/CMakeLists.txt	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/CMakeLists.txt	2008-10-13 17:57:00 UTC (rev 6697)
@@ -49,12 +49,20 @@
 	SET(MINGWLIBS ${CMAKE_SOURCE_DIR}/mingwlibs CACHE PATH &quot;Location of the mingwlibs (you can't build windows executables without them)&quot;)
 	include_directories(${MINGWLIBS}/include ${MINGWLIBS}/include/SDL)
 	LINK_DIRECTORIES(${MINGWLIBS}/lib ${MINGWLIBS}/dll)
+	set (SDL_LIBRARY SDL)
+	set (Boost_REGEX_LIBRARY boost_regex-mt)
+	set (Boost_THREAD_LIBRARY boost_thread-mt)
+	set (IL_ILU_LIBRARY ILU)
+	set (DEVIL_LIBRARIES &quot;devil ${IL_ILU_LIBRARY}&quot;)
 else (MINGW)
 	# AIs need it
 	FIND_PACKAGE(SDL REQUIRED)
 	INCLUDE_DIRECTORIES(${SDL_INCLUDE_DIR})
 
 	FIND_PACKAGE(Boost 1.34.0 COMPONENTS thread regex REQUIRED)
+	INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIR})
+	
+	FIND_PACKAGE(Devil REQUIRED)
 endif (MINGW)
 
 ### Compiler flags and defines based on build type
@@ -75,10 +83,10 @@
 IF (UNIX)
 	SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot;)
 ENDIF (UNIX)
-SET(CMAKE_CXX_FLAGS_DEBUG   &quot;${BASE_FLAGS} ${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
-SET(CMAKE_CXX_FLAGS_DEBUG2  &quot;${BASE_FLAGS} ${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
-SET(CMAKE_CXX_FLAGS_DEBUG3  &quot;${BASE_FLAGS} ${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
-SET(CMAKE_CXX_FLAGS_RELEASE &quot;${BASE_FLAGS} ${VISIBILITY_HIDDEN} -O2 -DNDEBUG -fomit-frame-pointer&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG   &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG2  &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG3  &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
+SET(CMAKE_CXX_FLAGS_RELEASE &quot;-O2 -DNDEBUG -fomit-frame-pointer&quot;)
 SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-g -O2 -DNDEBUG&quot;)
 SET(CMAKE_CXX_FLAGS_PROFILE   &quot;-O2 -pg -Wall -DNDEBUG&quot;)
 if (NOT MINGW)

Modified: branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -650,15 +650,18 @@
 std::vector&lt;std::string&gt; CAILibraryManager::FindDirsAndDirectSubDirs(
 		const std::string&amp; path) {
 	
+	std::vector&lt;std::string&gt; found;
+	
 	 std::string pattern = &quot;*&quot;;
 	
 	// find dirs
-	std::vector&lt;std::string&gt; found = CFileHandler::SubDirs(path, pattern,
+	std::vector&lt;std::string&gt; mainDirs = CFileHandler::SubDirs(path, pattern,
 			SPRING_VFS_RAW);
+	found = mainDirs;
 	
 	// find sub-dirs
-	for (std::vector&lt;std::string&gt;::iterator dir = found.begin();
-			dir != found.end(); ++dir) {
+	for (std::vector&lt;std::string&gt;::iterator dir = mainDirs.begin();
+			dir != mainDirs.end(); ++dir) {
 		std::vector&lt;std::string&gt; sub_dirs = CFileHandler::SubDirs(*dir, pattern,
 				SPRING_VFS_RAW);
 		found.insert(found.end(), sub_dirs.begin(), sub_dirs.end());

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -71,11 +71,6 @@
 		} else throw;						\
 	}
 
-/*
-CSkirmishAIWrapper::CSkirmishAIWrapper() {
-    
-}
-*/
 
 CSkirmishAIWrapper::CSkirmishAIWrapper(int teamId, const SSAIKey&amp; skirmishAIKey)
 		: teamId(teamId), cheatEvents(false), skirmishAIKey(skirmishAIKey) {
@@ -93,14 +88,6 @@
 	
 	if (ai) {
 		Release();
-/*
-		if (!IsCInterface) {
-			try {
-				_ReleaseAIFunc(ai);
-			} HANDLE_EXCEPTION;
-		}
-*/
-
 		delete c_callback;
 		delete callback;
 		delete ai;
@@ -110,22 +97,24 @@
 void CSkirmishAIWrapper::Serialize(creg::ISerializer* s) {}
 
 
-
-
 void CSkirmishAIWrapper::PostLoad() {
 	LoadSkirmishAI(teamId, skirmishAIKey, true);
 }
 
 
 
-void CSkirmishAIWrapper::LoadSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey, bool postLoad) {
+void CSkirmishAIWrapper::LoadSkirmishAI(int teamId,
+		const SSAIKey&amp; skirmishAIKey, bool postLoad) {
 	
 	ai = SAFE_NEW CSkirmishAI(teamId, skirmishAIKey);
 	
-	const ISkirmishAILibrary* skirmishAILibrary = IAILibraryManager::GetInstance()-&gt;FetchSkirmishAILibrary(skirmishAIKey);
-	//bool loadSupported = std::string(skirmishAILibrary-&gt;GetInfo()[SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED].value) == &quot;yes&quot;;
-	bool loadSupported = IAILibraryManager::GetInstance()-&gt;GetSkirmishAIInfos()-&gt;at(skirmishAIKey)-&gt;GetInfo(SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED) == &quot;yes&quot;;
-	IAILibraryManager::GetInstance()-&gt;ReleaseSkirmishAILibrary(skirmishAIKey);
+	IAILibraryManager* libManager = IAILibraryManager::GetInstance();
+	libManager-&gt;FetchSkirmishAILibrary(skirmishAIKey);
+	const CSkirmishAILibraryInfo* infos =
+			libManager-&gt;GetSkirmishAIInfos()-&gt;at(skirmishAIKey);
+	bool loadSupported =
+			infos-&gt;GetInfo(SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED) == &quot;yes&quot;;
+	libManager-&gt;ReleaseSkirmishAILibrary(skirmishAIKey);
 
 	if (postLoad &amp;&amp; !loadSupported) {
 		// fallback code to help the AI if it
@@ -143,8 +132,9 @@
 						UnitFinished(a);
 					} HANDLE_EXCEPTION;
 			} else {
-				if ((uh-&gt;units[a]-&gt;allyteam == gs-&gt;AllyTeam(teamId)) || gs-&gt;Ally(gs-&gt;AllyTeam(teamId), uh-&gt;units[a]-&gt;allyteam)) {
-					/* do nothing */
+				if ((uh-&gt;units[a]-&gt;allyteam == gs-&gt;AllyTeam(teamId))
+						|| gs-&gt;Ally(gs-&gt;AllyTeam(teamId), uh-&gt;units[a]-&gt;allyteam)) {
+					// do nothing
 				} else {
 					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(teamId)] &amp; (LOS_INRADAR | LOS_INLOS)) {
 						try {
@@ -161,99 +151,7 @@
 		}
 	}
 }
-/*
 
-void CSkirmishAIWrapper::LoadCPPAI(int team, const char* botLibName, bool postLoad, bool loadSupported, bool isJavaAI)
-{
-	if (isJavaAI) {
-		logOutput &lt;&lt; botLibName &lt;&lt; &quot; is a Java archive\n&quot;;
-	} else {
-		logOutput &lt;&lt; botLibName &lt;&lt; &quot; has a C++ interface\n&quot;;
-	}
-
-	_GetGlobalAiVersionFunc = (GETGLOBALAIVERSION) lib-&gt;FindAddress(&quot;GetGlobalAiVersion&quot;);
-
-	if (_GetGlobalAiVersionFunc == 0) {
-		char msg[512];
-		SNPRINTF(msg, 511, &quot;Incorrect GlobalAI library \&quot;%s\&quot; (no \&quot;GetGlobalAiVersion\&quot; function exported)&quot;, botLibName);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-	const int botInterfaceVersion = _GetGlobalAiVersionFunc();
-
-	if (botInterfaceVersion != GLOBAL_AI_INTERFACE_VERSION) {
-		char msg[1024];
-		SNPRINTF(msg, 1023,
-			&quot;Incorrect GlobalAI library \&quot;%s\&quot;\n&quot;
-			&quot;(lib interface version %d, engine interface version %d)&quot;,
-			botLibName, botInterfaceVersion, GLOBAL_AI_INTERFACE_VERSION);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-
-	if (isJavaAI) {
-		// we want to load a Java AI inside a jar,
-		// pass the name of the actual .jar to the
-		// proxy library so it can spawn a JVM for
-		// that AI
-		_GetNewAIByNameFunc = (GETNEWAIBYNAME) lib-&gt;FindAddress(&quot;GetNewAIByName&quot;);
-
-		if (_GetNewAIByNameFunc == 0) {
-			throw std::runtime_error(&quot;JAI proxy does not export \&quot;GetNewAIByName\&quot;&quot;);
-		}
-
-		// note: team parameter is unnecessary
-		ai = _GetNewAIByNameFunc(botLibName, team);
-	} else {
-		_GetNewAIFunc = (GETNEWAI) lib-&gt;FindAddress(&quot;GetNewAI&quot;);
-
-		if (_GetNewAIFunc == 0) {
-			char msg[512];
-			SNPRINTF(msg, 511, &quot;GlobalAI library \&quot;%s\&quot; does not export \&quot;GetNewAI\&quot;&quot;, botLibName);
-			throw std::runtime_error(msg);
-		}
-
-		ai = _GetNewAIFunc();
-	}
-
-	// note: verify that this is really exported too?
-	_ReleaseAIFunc = (RELEASEAI) lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
-	callback = SAFE_NEW CGlobalAICallback(this);
-
-	if (!postLoad || (postLoad &amp;&amp; !loadSupported)) {
-		try {
-			ai-&gt;InitAI(callback, team);
-		} HANDLE_EXCEPTION;
-	}
-}
-
-
-void CSkirmishAIWrapper::LoadJavaProxyAI()
-{
-	// TODO: Mac support? non-hardcoded proxy?
-	#ifdef WIN32
-	const char* javaProxyAI = &quot;AI\\Skirmish\\impls\\JAI\\JAI.dll&quot;;
-	#else
-	const char* javaProxyAI = &quot;AI/Skirmish/impls/JAI/JAI.so&quot;;
-	#endif
-
-	if (!filesystem.GetFilesize(javaProxyAI)) {
-		char msg[512];
-		SNPRINTF(msg, 511, &quot;Could not find Java GlobalAI proxy library \&quot;%s\&quot;&quot;, javaProxyAI);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-	lib = SharedLib::Instantiate(javaProxyAI);
-}
-*/
-
-
-
-
-
 void CSkirmishAIWrapper::Init() {
 	
 	callback = SAFE_NEW CGlobalAICallback(this);
@@ -312,9 +210,11 @@
 	ai-&gt;HandleEvent(EVENT_UNIT_DESTROYED, &amp;evtData);
 }
 
-void CSkirmishAIWrapper::UnitDamaged(int unitId, int attackerUnitId, float damage, const float3&amp; dir) {
+void CSkirmishAIWrapper::UnitDamaged(int unitId, int attackerUnitId,
+		float damage, const float3&amp; dir) {
 	
-	SUnitDamagedEvent evtData = {unitId, attackerUnitId, damage, dir.toSAIFloat3()};
+	SUnitDamagedEvent evtData = {unitId, attackerUnitId, damage,
+			dir.toSAIFloat3()};
 	ai-&gt;HandleEvent(EVENT_UNIT_DAMAGED, &amp;evtData);
 }
 
@@ -366,9 +266,11 @@
 	ai-&gt;HandleEvent(EVENT_ENEMY_DESTROYED, &amp;evtData);
 }
 
-void CSkirmishAIWrapper::EnemyDamaged(int enemyUnitId, int attackerUnitId, float damage, const float3&amp; dir) {
+void CSkirmishAIWrapper::EnemyDamaged(int enemyUnitId, int attackerUnitId,
+		float damage, const float3&amp; dir) {
 	
-	SEnemyDamagedEvent evtData = {enemyUnitId, attackerUnitId, damage, dir.toSAIFloat3()};
+	SEnemyDamagedEvent evtData = {enemyUnitId, attackerUnitId, damage,
+			dir.toSAIFloat3()};
 	ai-&gt;HandleEvent(EVENT_ENEMY_DAMAGED, &amp;evtData);
 }
 
@@ -390,40 +292,30 @@
 	ai-&gt;HandleEvent(EVENT_WEAPON_FIRED, &amp;evtData);
 }
 
-void CSkirmishAIWrapper::PlayerCommandGiven(const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId) {
+void CSkirmishAIWrapper::PlayerCommandGiven(
+		const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId) {
 	
-	int numUnits = selectedUnits.size();
+	unsigned int numUnits = selectedUnits.size();
 	int unitIds[numUnits];
-	int i;
-	for (i=0; i &lt; numUnits; ++i) {
+	for (unsigned int i=0; i &lt; numUnits; ++i) {
 		unitIds[i] = selectedUnits.at(i);
 	}
 	int sCommandId;
 	void* sCommandData = mallocSUnitCommand(-1, -1, &amp;c, &amp;sCommandId);
 	
-	SPlayerCommandEvent evtData = {unitIds, numUnits, sCommandId, sCommandData, playerId};
+	SPlayerCommandEvent evtData = {unitIds, numUnits, sCommandId, sCommandData,
+			playerId};
 	ai-&gt;HandleEvent(EVENT_PLAYER_COMMAND, &amp;evtData);
 }
 
-void CSkirmishAIWrapper::SeismicPing(int allyTeam, int unitId, const float3&amp; pos, float strength) {
+void CSkirmishAIWrapper::SeismicPing(int allyTeam, int unitId,
+		const float3&amp; pos, float strength) {
 	
 	SSeismicPingEvent evtData = {pos.toSAIFloat3(), strength};
 	ai-&gt;HandleEvent(EVENT_SEISMIC_PING, &amp;evtData);
 }
 
 
-
-
-
-
-
-
-
-
-
-
-
-
 int CSkirmishAIWrapper::GetTeamId() const {
 	return teamId;
 }
@@ -440,4 +332,3 @@
 	return ai-&gt;HandleEvent(topic, data);
 }
 
-//IMPLEMENT_PURE_VIRTUAL(CSkirmishAIWrapper::~CSkirmishAIWrapper())

Modified: branches/caiinterface/rts/Game/GameSetup.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.cpp	2008-10-13 16:38:48 UTC (rev 6696)
+++ branches/caiinterface/rts/Game/GameSetup.cpp	2008-10-13 17:57:00 UTC (rev 6697)
@@ -122,7 +122,7 @@
 		for (int i = 0; i &lt; MAX_TEAMS; ++i)
 			teamStartNum[i] = i;
 		std::random_shuffle(&amp;teamStartNum[0], &amp;teamStartNum[numTeams], rng);
-		for (int i = 0; i &lt; teamStartingData.size(); ++i)
+		for (unsigned int i = 0; i &lt; teamStartingData.size(); ++i)
 			teamStartingData[i].teamStartNum = teamStartNum[i];
 	}
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001465.html">[Taspring-linux-commit] r6696 - trunk/rts
</A></li>
	<LI>Next message: <A HREF="001467.html">[Taspring-linux-commit] r6698 - in trunk/rts: Game System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1466">[ date ]</a>
              <a href="thread.html#1466">[ thread ]</a>
              <a href="subject.html#1466">[ subject ]</a>
              <a href="author.html#1466">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
