<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6694 - in branches/caiinterface:	AI/Interfaces/C rts/ExternalAI rts/ExternalAI/Interface
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6694%20-%20in%20branches/caiinterface%3A%0A%09AI/Interfaces/C%20rts/ExternalAI%20rts/ExternalAI/Interface&In-Reply-To=%3C20081013142059.3FE65472A%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001462.html">
   <LINK REL="Next"  HREF="001464.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6694 - in branches/caiinterface:	AI/Interfaces/C rts/ExternalAI rts/ExternalAI/Interface</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6694%20-%20in%20branches/caiinterface%3A%0A%09AI/Interfaces/C%20rts/ExternalAI%20rts/ExternalAI/Interface&In-Reply-To=%3C20081013142059.3FE65472A%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6694 - in branches/caiinterface:	AI/Interfaces/C rts/ExternalAI rts/ExternalAI/Interface">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon Oct 13 16:20:59 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001462.html">[Taspring-linux-commit] r6693 - trunk/AI/Global
</A></li>
        <LI>Next message: <A HREF="001464.html">[Taspring-linux-commit] r6695 - in trunk/rts/Sim: MoveTypes	Units/CommandAI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1463">[ date ]</a>
              <a href="thread.html#1463">[ thread ]</a>
              <a href="subject.html#1463">[ subject ]</a>
              <a href="author.html#1463">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-10-13 16:20:58 +0200 (Mon, 13 Oct 2008)
New Revision: 6694

Modified:
   branches/caiinterface/AI/Interfaces/C/Interface.cpp
   branches/caiinterface/AI/Interfaces/C/Interface.h
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
   branches/caiinterface/AI/Interfaces/C/Log.cpp
   branches/caiinterface/AI/Interfaces/C/Log.h
   branches/caiinterface/rts/ExternalAI/AICallback.cpp
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
   branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
   branches/caiinterface/rts/ExternalAI/AILibraryManager.h
   branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
   branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/SStaticGlobalData.h
   branches/caiinterface/rts/ExternalAI/SStaticGlobalData.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
Log:
- AI Interfaces and AIs will now be loaded from all data-directories, not just the primary one.
- some code beautifications

Modified: branches/caiinterface/AI/Interfaces/C/Interface.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -22,36 +22,62 @@
 #include &quot;ExternalAI/Interface/aidefines.h&quot;
 #include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 #include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot;
+
 #include &quot;System/Platform/SharedLib.h&quot;
+#include &quot;System/Util.h&quot;
 
+#include &lt;sys/stat.h&gt;	// used for check if a file exists
+#ifdef	WIN32
+#include &lt;direct.h&gt;	// mkdir()
+#else	// WIN32
+#include &lt;sys/stat.h&gt;	// mkdir()
+#include &lt;sys/types.h&gt;	// mkdir()
+#endif	// WIN32
+
 #define MY_SHORT_NAME &quot;C&quot;
 #define MY_VERSION &quot;0.1&quot;
+#define MY_NAME &quot;C &amp; C++ AI Interface&quot;
 
-CInterface::CInterface(const SStaticGlobalData* _staticGlobalData)
-		: staticGlobalData(_staticGlobalData) {
+#define MAX_INFOS 128
+
+std::string CInterface::relSkirmishAIImplsDir =
+		std::string(SKIRMISH_AI_IMPLS_DIR) + PS;
+std::string CInterface::relGroupAIImplsDir =
+		std::string(GROUP_AI_IMPLS_DIR) + PS;
 	
-	std::string mainLibDir = std::string(staticGlobalData-&gt;libDir);
-	if (!mainLibDir.empty()) {
-		mainLibDir = mainLibDir + '/';
+CInterface::CInterface(const SStaticGlobalData* staticGlobalData) {
+	
+	for (unsigned int i=0; i &lt; staticGlobalData-&gt;numDataDirs; ++i) {
+		springDataDirs.push_back(staticGlobalData-&gt;dataDirs[i]);
 	}
 	
-	// will look about like this: &quot;C:/Games/spring/AI/Interfaces/impls&quot;
-	//std::string myLibDir = mainLibDir + AI_INTERFACES_IMPLS_DIR;
-	// will look about like this: &quot;C:/Games/spring/AI/Skirmish/impls&quot;
-	skirmishAIsLibDir = mainLibDir + SKIRMISH_AI_IMPLS_DIR;
-	// will look about like this: &quot;C:/Games/spring/AI/Skirmish/impls&quot;
-	groupAIsLibDir = mainLibDir + GROUP_AI_IMPLS_DIR;
+	// example: &quot;AI/Interfaces/data/C&quot;
+	std::string myDataDirRelative =
+			std::string(AI_INTERFACES_DATA_DIR) + PS + MY_SHORT_NAME;
+	// example: &quot;AI/Interfaces/data/C/0.1&quot;
+	std::string myDataDirVersRelative = myDataDirRelative + PS + MY_VERSION;
 	
-	std::string mainDataDir = &quot;&quot;;
-	if (staticGlobalData-&gt;numDataDirs &gt;= 1) {
-		mainDataDir = std::string(staticGlobalData-&gt;dataDirs[0]) + '/';
+	// &quot;C:/Games/spring/AI/Interfaces/data/C&quot;
+	myDataDir = FindDir(myDataDirRelative, true, true);
+	if (!FileExists(myDataDir)) {
+		MakeDirRecursive(myDataDir);
 	}
-	// will look about like this: &quot;C:/Games/spring/AI/Interfaces/data/C/0.1&quot;
-	std::string myDataDir = mainDataDir + AI_INTERFACES_DATA_DIR&quot;/&quot;MY_SHORT_NAME&quot;/&quot;MY_VERSION;
+	// &quot;C:/Games/spring/AI/Interfaces/data/C/0.1&quot;
+	myDataDirVers = FindDir(myDataDirVersRelative, true, true);
+	if (!FileExists(myDataDirVers)) {
+		MakeDirRecursive(myDataDirVers);
+	}
 	
-	std::string logFileName = myDataDir + &quot;/log.txt&quot;;
+	std::string logFileName = myDataDirVers + PS + &quot;log.txt&quot;;
+	simpleLog_init(logFileName.c_str(), true);
 	
-	initLog(logFileName.c_str());
+	simpleLog_log(&quot;This is the log-file of the %s version %s&quot;, MY_NAME,
+			MY_VERSION);
+	simpleLog_log(&quot;Using data-directory (version-less): %s&quot;,
+			myDataDir.c_str());
+	simpleLog_log(&quot;Using data-directory (version specific): %s&quot;,
+			myDataDirVers.c_str());
+	simpleLog_log(&quot;Using log file: %s&quot;, logFileName.c_str());
 }
 
 unsigned int CInterface::GetInfo(InfoItem info[], unsigned int maxInfoItems) {
@@ -61,8 +87,8 @@
 	if (myInfo.empty()) {
 		InfoItem ii_0 = {AI_INTERFACE_PROPERTY_SHORT_NAME, MY_SHORT_NAME, NULL}; myInfo.push_back(ii_0);
 		InfoItem ii_1 = {AI_INTERFACE_PROPERTY_VERSION, MY_VERSION, NULL}; myInfo.push_back(ii_1);
-		InfoItem ii_2 = {AI_INTERFACE_PROPERTY_NAME, &quot;default C &amp; C++ (legacy and new)&quot;, NULL}; myInfo.push_back(ii_2);
-		InfoItem ii_3 = {AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in C or C++.&quot;, NULL}; myInfo.push_back(ii_3);
+		InfoItem ii_2 = {AI_INTERFACE_PROPERTY_NAME, MY_NAME, NULL}; myInfo.push_back(ii_2);
+		InfoItem ii_3 = {AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in C or C++. It is neded for legacy C++ AIs as well.&quot;, NULL}; myInfo.push_back(ii_3);
 		InfoItem ii_4 = {AI_INTERFACE_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AIInterface:C">http://spring.clan-sy.com/wiki/AIInterface:C</A>&quot;, NULL}; myInfo.push_back(ii_4);
 		InfoItem ii_5 = {AI_INTERFACE_PROPERTY_SUPPORTED_LANGUAGES, &quot;C, C++&quot;, NULL}; myInfo.push_back(ii_5);
 	}
@@ -81,13 +107,15 @@
 	return LOS_Working;
 }
 
-void copyToInfoMap(std::map&lt;std::string, InfoItem&gt;&amp; infoMap, const InfoItem info[], unsigned int numInfoItems) {
+void copyToInfoMap(std::map&lt;std::string, InfoItem&gt;&amp; infoMap,
+		const InfoItem info[], unsigned int numInfoItems) {
 
 	for (unsigned int i=0; i &lt; numInfoItems; ++i) {
 		infoMap[info[i].key] = copyInfoItem(&amp;(info[i]));
 	}
 }
-SSAISpecifier extractSSAISpecifier(const std::map&lt;std::string, InfoItem&gt;&amp; infoMap) {
+SSAISpecifier extractSSAISpecifier(
+		const std::map&lt;std::string, InfoItem&gt;&amp; infoMap) {
 
 	const char* sn = infoMap.find(SKIRMISH_AI_PROPERTY_SHORT_NAME)-&gt;second.value;
 	const char* v = infoMap.find(SKIRMISH_AI_PROPERTY_VERSION)-&gt;second.value;
@@ -96,7 +124,8 @@
 
 	return specifier;
 }
-SGAISpecifier extractSGAISpecifier(const std::map&lt;std::string, InfoItem&gt;&amp; infoMap) {
+SGAISpecifier extractSGAISpecifier(
+		const std::map&lt;std::string, InfoItem&gt;&amp; infoMap) {
 
 	const char* sn = infoMap.find(GROUP_AI_PROPERTY_SHORT_NAME)-&gt;second.value;
 	const char* v = infoMap.find(GROUP_AI_PROPERTY_VERSION)-&gt;second.value;
@@ -132,8 +161,10 @@
 }
 int CInterface::UnloadSkirmishAILibrary(const SSAISpecifier* const sAISpecifier) {
 
-	T_skirmishAIs::iterator skirmishAI = myLoadedSkirmishAIs.find(*sAISpecifier);
-	T_skirmishAILibs::iterator skirmishAILib = myLoadedSkirmishAILibs.find(*sAISpecifier);
+	T_skirmishAIs::iterator skirmishAI =
+			myLoadedSkirmishAIs.find(*sAISpecifier);
+	T_skirmishAILibs::iterator skirmishAILib =
+			myLoadedSkirmishAILibs.find(*sAISpecifier);
 	if (skirmishAI == myLoadedSkirmishAIs.end()) {
 		// to unload AI is not loaded -&gt; no problem, do nothing
 	} else {
@@ -156,7 +187,8 @@
 
 
 
-const SGAILibrary* CInterface::LoadGroupAILibrary(const struct InfoItem info[], unsigned int numInfoItems) {
+const SGAILibrary* CInterface::LoadGroupAILibrary(const struct InfoItem info[],
+		unsigned int numInfoItems) {
 
 	SGAILibrary* ai = NULL;
 
@@ -182,7 +214,8 @@
 int CInterface::UnloadGroupAILibrary(const SGAISpecifier* const gAISpecifier) {
 
 	T_groupAIs::iterator groupAI = myLoadedGroupAIs.find(*gAISpecifier);
-	T_groupAILibs::iterator groupAILib = myLoadedGroupAILibs.find(*gAISpecifier);
+	T_groupAILibs::iterator groupAILib =
+			myLoadedGroupAILibs.find(*gAISpecifier);
 	if (groupAI == myLoadedGroupAIs.end()) {
 		// to unload AI is not loaded -&gt; no problem, do nothing
 	} else {
@@ -205,10 +238,12 @@
 
 // private functions following
 
-SharedLib* CInterface::Load(const SSAISpecifier* const sAISpecifier, SSAILibrary* skirmishAILibrary) {
-	return LoadSkirmishAILib(GenerateLibFilePath(*sAISpecifier), skirmishAILibrary);
+SharedLib* CInterface::Load(const SSAISpecifier* const sAISpecifier,
+		SSAILibrary* skirmishAILibrary) {
+	return LoadSkirmishAILib(FindLibFile(*sAISpecifier), skirmishAILibrary);
 }
-SharedLib* CInterface::LoadSkirmishAILib(const std::string&amp; libFilePath, SSAILibrary* skirmishAILibrary) {
+SharedLib* CInterface::LoadSkirmishAILib(const std::string&amp; libFilePath,
+		SSAILibrary* skirmishAILibrary) {
 
 	SharedLib* sharedLib = SharedLib::Instantiate(libFilePath);
 
@@ -266,13 +301,19 @@
 }
 
 
-SharedLib* CInterface::Load(const SGAISpecifier* const gAISpecifier, SGAILibrary* groupAILibrary) {
-	return LoadGroupAILib(GenerateLibFilePath(*gAISpecifier), groupAILibrary);
+SharedLib* CInterface::Load(const SGAISpecifier* const gAISpecifier,
+		SGAILibrary* groupAILibrary) {
+	return LoadGroupAILib(FindLibFile(*gAISpecifier), groupAILibrary);
 }
-SharedLib* CInterface::LoadGroupAILib(const std::string&amp; libFilePath, SGAILibrary* groupAILibrary) {
+SharedLib* CInterface::LoadGroupAILib(const std::string&amp; libFilePath,
+		SGAILibrary* groupAILibrary) {
 	
 	SharedLib* sharedLib = SharedLib::Instantiate(libFilePath);
 	
+	if (sharedLib == NULL) {
+		reportError(std::string(&quot;Failed loading shared library: &quot;) + libFilePath);
+	}
+	
 	// initialize the AI library
 	std::string funcName;
 	
@@ -323,7 +364,8 @@
 }
 
 
-void CInterface::reportInterfaceFunctionError(const std::string&amp; libFilePath, const std::string&amp; functionName) {
+void CInterface::reportInterfaceFunctionError(const std::string&amp; libFilePath,
+		const std::string&amp; functionName) {
 	
 	std::string msg(&quot;Failed loading AI Library from file \&quot;&quot;);
 	msg += libFilePath + &quot;\&quot;: no \&quot;&quot; + functionName + &quot;\&quot; function exported&quot;;
@@ -332,21 +374,25 @@
 
 void CInterface::reportError(const std::string&amp; msg) {
 	///handleerror(NULL, msg.c_str(), &quot;C AI Interface Error&quot;, MBF_OK | MBF_EXCL);
-	logFatalError(msg.c_str());
+	simpleLog_error(-1, msg.c_str());
 }
 
 
-std::string CInterface::GenerateLibFilePath(const SSAISpecifier&amp; sAISpecifier) {
+std::string CInterface::FindLibFile(const SSAISpecifier&amp; sAISpecifier) {
 	
 	// fetch the file from the info about this interface
 	// which were supplied to us by the engine
-	T_skirmishAIInfos::const_iterator info = mySkirmishAIInfos.find(sAISpecifier);
+	T_skirmishAIInfos::const_iterator info =
+			mySkirmishAIInfos.find(sAISpecifier);
 	if (info == mySkirmishAIInfos.end()) {
-		reportError(std::string(&quot;Missing Skirmish-AI info for &quot;) + sAISpecifier.shortName + &quot; &quot; + sAISpecifier.version);
+		reportError(std::string(&quot;Missing Skirmish-AI info for &quot;)
+				+ sAISpecifier.shortName + &quot; &quot; + sAISpecifier.version);
 	}
-	std::map&lt;std::string, InfoItem&gt;::const_iterator fileName = info-&gt;second.find(SKIRMISH_AI_PROPERTY_FILE_NAME);
+	std::map&lt;std::string, InfoItem&gt;::const_iterator fileName =
+			info-&gt;second.find(SKIRMISH_AI_PROPERTY_FILE_NAME);
 	if (fileName == info-&gt;second.end()) {
-		reportError(std::string(&quot;Missing Skirmish-AI file name for &quot;) + sAISpecifier.shortName + &quot; &quot; + sAISpecifier.version);
+		reportError(std::string(&quot;Missing Skirmish-AI file name for &quot;)
+				+ sAISpecifier.shortName + &quot; &quot; + sAISpecifier.version);
 	}
 	
 	std::string libFileName = fileName-&gt;second.value; // eg. RAI-0.600
@@ -354,22 +400,26 @@
 		libFileName = &quot;lib&quot; + libFileName; // eg. libRAI-0.600
 	#endif
 	
-	libFileName = libFileName + &quot;.&quot; + SharedLib::GetLibExtension(); // eg. libRAI-0.600.so
+	// eg. libRAI-0.600.so
+	libFileName = libFileName + &quot;.&quot; + SharedLib::GetLibExtension();
 	
-	return skirmishAIsLibDir + &quot;/&quot; + libFileName;
+	return FindFile(relSkirmishAIImplsDir + libFileName);
 }
 
-std::string CInterface::GenerateLibFilePath(const SGAISpecifier&amp; gAISpecifier) {
+std::string CInterface::FindLibFile(const SGAISpecifier&amp; gAISpecifier) {
 	
 	// fetch the file from the info about this interface
 	// which were supplied to us by the engine
 	T_groupAIInfos::const_iterator info = myGroupAIInfos.find(gAISpecifier);
 	if (info == myGroupAIInfos.end()) {
-		reportError(std::string(&quot;Missing Group-AI info for &quot;) + gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
+		reportError(std::string(&quot;Missing Group-AI info for &quot;)
+				+ gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
 	}
-	std::map&lt;std::string, InfoItem&gt;::const_iterator fileName = info-&gt;second.find(GROUP_AI_PROPERTY_FILE_NAME);
+	std::map&lt;std::string, InfoItem&gt;::const_iterator fileName =
+			info-&gt;second.find(GROUP_AI_PROPERTY_FILE_NAME);
 	if (fileName == info-&gt;second.end()) {
-		reportError(std::string(&quot;Missing Group-AI file name for &quot;) + gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
+		reportError(std::string(&quot;Missing Group-AI file name for &quot;)
+				+ gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
 	}
 	
 	std::string libFileName = fileName-&gt;second.value; // eg. MetalMaker-1.0
@@ -377,13 +427,119 @@
 		libFileName = &quot;lib&quot; + libFileName; // eg. libMetalMaker-1.0
 	#endif
 	
-	libFileName = libFileName + &quot;.&quot; + SharedLib::GetLibExtension(); // eg. libMetalMaker-1.0.so
+	// eg. libMetalMaker-1.0.so
+	libFileName = libFileName + &quot;.&quot; + SharedLib::GetLibExtension();
 	
-	return groupAIsLibDir + &quot;/&quot; + libFileName;
+	return FindFile(relGroupAIImplsDir + libFileName);
 }
 
-SSAISpecifier CInterface::extractSpecifier(const SSAILibrary&amp; skirmishAILib) {
+bool CInterface::FileExists(const std::string&amp; filePath) {
 	
+	struct stat fileInfo;
+	bool exists;
+	int intStat;
+
+	// Attempt to get the file attributes 
+	intStat = stat(filePath.c_str(), &amp;fileInfo);
+	if (intStat == 0) {
+		// We were able to get the file attributes 
+		// so the file obviously exists. 
+		exists = true;
+	} else {
+		// We were not able to get the file attributes. 
+		// This may mean that we don't have permission to 
+		// access the folder which contains this file. If you 
+		// need to do that level of checking, lookup the 
+		// return values of stat which will give you 
+		// more details on why stat failed. 
+		exists = false;
+	}
+
+	return exists;
+}
+
+bool CInterface::MakeDir(const std::string&amp; dirPath) {
+	
+	#ifdef	WIN32
+	int mkStat = _mkdir(dirPath.c_str());
+	if (mkStat == 0) {
+		return true;
+	} else {
+		return false;
+	}
+	#else	// WIN32
+	// with read/write/search permissions for owner and group,
+	// and with read/search permissions for others
+	int mkStat = mkdir(dirPath.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+	if (mkStat == 0) {
+		return true;
+	} else {
+		return false;
+	}
+	#endif	// WIN32
+}
+
+bool CInterface::MakeDirRecursive(const std::string&amp; dirPath) {
+	
+	if (!FileExists(dirPath)) {
+		std::string::size_type pos = dirPath.find_last_of(&quot;/\\&quot;);
+		if (pos != std::string::npos) {
+			std::string parentDir = dirPath.substr(0, pos);
+			bool parentExists = MakeDirRecursive(parentDir);
+			if (parentExists) {
+				return MakeDir(dirPath);
+			}
+		}
+		return false;
+	}
+	
+	return true;
+}
+
+std::string CInterface::FindFile(const std::string&amp; relativeFilePath) {
+	
+	std::string path = relativeFilePath;
+	
+	for (unsigned int i=0; i &lt; springDataDirs.size(); ++i) {
+		std::string tmpPath = springDataDirs.at(i);
+		tmpPath += PS + relativeFilePath;
+		if (FileExists(tmpPath)) {
+			path = tmpPath;
+			break;
+		}
+	}
+	
+	return path;
+}
+std::string CInterface::FindDir(const std::string&amp; relativeDirPath,
+		bool searchOnlyWriteable, bool pretendAvailable) {
+	
+	std::string path = relativeDirPath;
+	
+	unsigned int numDds = springDataDirs.size();
+	if (searchOnlyWriteable &amp;&amp; numDds &gt; 1) {
+		numDds = 1;
+	}
+	
+	bool found = false;
+	for (unsigned int i=0; i &lt; numDds; ++i) {
+		std::string tmpPath = springDataDirs.at(i) + PS + relativeDirPath;
+		if (FileExists(tmpPath)) {
+			path = tmpPath;
+			found = true;
+			break;
+		}
+	}
+	
+	if (!found &amp;&amp; pretendAvailable &amp;&amp; numDds &gt;= 1) {
+		path = springDataDirs.at(0) + PS + relativeDirPath;
+	}
+	
+	return path;
+}
+
+SSAISpecifier CInterface::ExtractSpecifier(const SSAILibrary&amp; skirmishAILib) {
+	
 	SSAISpecifier skirmishAISpecifier;
 	
 	InfoItem info[MAX_INFOS];
@@ -403,7 +559,7 @@
 	return skirmishAISpecifier;
 }
 
-SGAISpecifier CInterface::extractSpecifier(const SGAILibrary&amp; groupAILib) {
+SGAISpecifier CInterface::ExtractSpecifier(const SGAILibrary&amp; groupAILib) {
 	
 	SGAISpecifier groupAISpecifier;
 	
@@ -424,7 +580,8 @@
 	return groupAISpecifier;
 }
 
-bool CInterface::FitsThisInterface(const std::string&amp; requestedShortName, const std::string&amp; requestedVersion) {
+bool CInterface::FitsThisInterface(const std::string&amp; requestedShortName,
+		const std::string&amp; requestedVersion) {
 	
 	bool shortNameFits = false;
 	bool versionFits = false;

Modified: branches/caiinterface/AI/Interfaces/C/Interface.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/AI/Interfaces/C/Interface.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -40,40 +40,85 @@
 			const char* engineVersion, int engineAIInterfaceGeneratedVersion);
 
 	// skirmish AI methods
-	const SSAILibrary* LoadSkirmishAILibrary(const struct InfoItem info[], unsigned int numInfoItems);
+	const SSAILibrary* LoadSkirmishAILibrary(const struct InfoItem info[],
+			unsigned int numInfoItems);
 	int UnloadSkirmishAILibrary(const SSAISpecifier* const sAISpecifier);
 	int UnloadAllSkirmishAILibraries();
 
 	// group AI methods
-	const SGAILibrary* LoadGroupAILibrary(const struct InfoItem info[], unsigned int numInfoItems);
+	const SGAILibrary* LoadGroupAILibrary(const struct InfoItem info[],
+			unsigned int numInfoItems);
 	int UnloadGroupAILibrary(const SGAISpecifier* const gAISpecifier);
 	int UnloadAllGroupAILibraries();
 
 private:
 	// these functions actually load and unload the libraries
 	SharedLib* Load(const SSAISpecifier* const sAISpecifier, SSAILibrary* ai);
-	SharedLib* LoadSkirmishAILib(const std::string&amp; libFilePath, SSAILibrary* ai);
+	SharedLib* LoadSkirmishAILib(const std::string&amp; libFilePath,
+			SSAILibrary* ai);
 
 	SharedLib* Load(const SGAISpecifier* const gAISpecifier, SGAILibrary* ai);
 	SharedLib* LoadGroupAILib(const std::string&amp; libFilePath, SGAILibrary* ai);
 
-	static void reportInterfaceFunctionError(const std::string&amp; libFileName, const std::string&amp; functionName);
+	static void reportInterfaceFunctionError(const std::string&amp; libFileName,
+			const std::string&amp; functionName);
 	static void reportError(const std::string&amp; msg);
-	std::string GenerateLibFilePath(const SSAISpecifier&amp; sAISpecifier);
-	std::string GenerateLibFilePath(const SGAISpecifier&amp; gAISpecifier);
-	#define MAX_INFOS 128
-	static SSAISpecifier extractSpecifier(const SSAILibrary&amp; skirmishAILib);
-	static SGAISpecifier extractSpecifier(const SGAILibrary&amp; groupAILib);
+	std::string FindLibFile(const SSAISpecifier&amp; sAISpecifier);
+	std::string FindLibFile(const SGAISpecifier&amp; gAISpecifier);
+	/**
+	 * Searches for a file in all data-dirs.
+	 * If not found, the input param relativeFilePath is returned.
+	 */
+	std::string FindFile(const std::string&amp; relativeFilePath);
+	/**
+	 * Searches for a dir in all data-dirs.
+	 * @param	create	if true, and the dir can not be found, it is created
+	 */
+	std::string FindDir(const std::string&amp; relativeDirPath,
+			bool searchOnlyWriteable, bool pretendAvailable);
+	/**
+	 * Returns true if the file or directory exists.
+	 */
+	static bool FileExists(const std::string&amp; filePath);
+	/**
+	 * Creates the directory if it does not yet exist.
+	 * 
+	 * @return	true if the directory was created or already existed
+	 */
+	static bool MakeDir(const std::string&amp; dirPath);
+	/**
+	 * Creates the directory and all parent directories that do not yet exist.
+	 * 
+	 * @return	true if the directory was created or already existed
+	 */
+	static bool MakeDirRecursive(const std::string&amp; dirPath);
+	static SSAISpecifier ExtractSpecifier(const SSAILibrary&amp; skirmishAILib);
+	static SGAISpecifier ExtractSpecifier(const SGAILibrary&amp; groupAILib);
 
-	bool FitsThisInterface(const std::string&amp; requestedShortName, const std::string&amp; requestedVersion);
+	bool FitsThisInterface(const std::string&amp; requestedShortName,
+			const std::string&amp; requestedVersion);
 private:
-	const SStaticGlobalData* staticGlobalData;
-	std::string skirmishAIsLibDir;
-	std::string groupAIsLibDir;
+	static std::string relSkirmishAIImplsDir;
+	static std::string relGroupAIImplsDir;
+	
+	std::vector&lt;std::string&gt; springDataDirs;
+	/**
+	 * All accompanying data for this interface that is not version specifc
+	 * should go in here.
+	 */
+	std::string myDataDir;
+	/**
+	 * All accompanying data for this interface that is version specifc
+	 * should go in here.
+	 */
+	std::string myDataDirVers;
+	//const SStaticGlobalData* staticGlobalData;
+	//std::string skirmishAIsLibDir;
+	//std::string groupAIsLibDir;
 	std::vector&lt;InfoItem&gt; myInfo;
 
 	std::vector&lt;SSAISpecifier&gt; mySkirmishAISpecifiers;
-	typedef std::map&lt;SSAISpecifier, std::map&lt;std::string, InfoItem&gt;, SSAISpecifier_Comparator&gt; T_skirmishAIInfos;
+	typedef std::map&lt;SSAISpecifier, std::map&lt;std::string, InfoItem&gt;,SSAISpecifier_Comparator&gt; T_skirmishAIInfos;
 	T_skirmishAIInfos mySkirmishAIInfos;
 	typedef std::map&lt;SSAISpecifier, SSAILibrary*, SSAISpecifier_Comparator&gt; T_skirmishAIs;
 	T_skirmishAIs myLoadedSkirmishAIs;

Modified: branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -57,7 +57,7 @@
 }
 */
 Export(const struct SSAILibrary*) loadSkirmishAILibrary(
-const struct InfoItem info[], unsigned int numInfoItems) {
+		const struct InfoItem info[], unsigned int numInfoItems) {
 	return myInterface-&gt;LoadSkirmishAILibrary(info, numInfoItems);
 }
 Export(int) unloadSkirmishAILibrary(const struct SSAISpecifier* const sAISpecifier) {

Modified: branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -43,8 +43,10 @@
 struct SStaticGlobalData;
 
 // for a list of the functions that have to be exported,
-// see struct SAIInterfaceLibrary in &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+// see struct SAIInterfaceLibrary in:
+// &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 
+
 // static AI interface library functions
 
 Export(int) initStatic(const SStaticGlobalData* staticGlobalData);
@@ -52,21 +54,30 @@
 Export(enum LevelOfSupport) getLevelOfSupportFor(
 		const char* engineVersion, int engineAIInterfaceGeneratedVersion);
 Export(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems);
-	
-// skirmish AI methods
+
+
+// skirmish AI related methods
+
 //Export(int) getSkirmishAISpecifiers(struct SSAISpecifier* sAISpecifiers, int max);
 //Export(const struct SSAILibrary*) loadSkirmishAILibrary(const struct SSAISpecifier* const sAISpecifier);
-Export(const struct SSAILibrary*) loadSkirmishAILibrary(const struct InfoItem info[], unsigned int numInfoItems);
-Export(int) unloadSkirmishAILibrary(const struct SSAISpecifier* const sAISpecifier);
+Export(const struct SSAILibrary*) loadSkirmishAILibrary(
+		const struct InfoItem info[], unsigned int numInfoItems);
+Export(int) unloadSkirmishAILibrary(
+		const struct SSAISpecifier* const sAISpecifier);
 Export(int) unloadAllSkirmishAILibraries();
-	
-// group AI methods
+
+
+// group AI related methods
+
 //Export(int) getGroupAISpecifiers(struct SGAISpecifier* gAISpecifiers, int max);
 //Export(const struct SGAILibrary*) loadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier);
-Export(const struct SGAILibrary*) loadGroupAILibrary(const struct InfoItem info[], unsigned int numInfoItems);
-Export(int) unloadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier);
+Export(const struct SGAILibrary*) loadGroupAILibrary(
+		const struct InfoItem info[], unsigned int numInfoItems);
+Export(int) unloadGroupAILibrary(
+		const struct SGAISpecifier* const gAISpecifier);
 Export(int) unloadAllGroupAILibraries();
 
+
 #ifdef	__cplusplus
 }
 #endif

Modified: branches/caiinterface/AI/Interfaces/C/Log.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Log.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/AI/Interfaces/C/Log.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -13,41 +13,98 @@
 
 	You should have received a copy of the GNU General Public License
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
+ */
 
 #include &quot;Log.h&quot;
 
 #include &lt;stdio.h&gt;	// for file IO
 #include &lt;stdlib.h&gt;	// calloc(), exit()
 #include &lt;string.h&gt;	// strlen(), strcpy()
+#include &lt;time.h&gt;	// for fetching current time
+#include &lt;stdarg.h&gt;	// var-arg support
+#ifdef _MSC_VER
+#if _MSC_VER &gt; 1310
+#define VSNPRINTF _vsnprintf_s
+#else
+#define VSNPRINTF _vsnprintf
+#endif
+#else
+#define VSNPRINTF vsnprintf
+#endif
 
+static const unsigned int bufferSize = 2048;
+
 const char* myLogFileName = NULL;
+bool useTimeStamps = NULL;
 
-void initLog(const char* _logFileName) {
-	
+void simpleLog_init(const char* _logFileName, bool _useTimeStamps) {
+
 	// NOTE: causeing a memory leack, as it is never freed.
 	// but it is used till the end of the applications runtime anyway
 	// -&gt; no problem
-	char* logFileName = (char*) calloc(strlen(_logFileName) + 1, sizeof(char));
+	char* logFileName = (char*) calloc(strlen(_logFileName) + 1, sizeof (char));
 	strcpy(logFileName, _logFileName);
 	myLogFileName = logFileName;
-	
-	log(&quot;\nlog initialized&quot;);
+
+	useTimeStamps = _useTimeStamps;
+
+	simpleLog_log(&quot;\n\n[logging started]&quot;);
 }
 
-void log(const char* msg) {
-	
+char* simpleLog_createTimeStamp() {
+
+	time_t now;
+	now = time(&amp;now);
+	struct tm* myTime = localtime(&amp;now);
+	unsigned int maxTimeStampSize = 32;
+	char* timeStamp = (char*) calloc(maxTimeStampSize + 1, sizeof (char));
+	strftime(timeStamp, maxTimeStampSize, &quot;%c&quot;, myTime);
+
+	return timeStamp;
+}
+
+void simpleLog_out(const char* msg) {
+
 	if (myLogFileName != NULL) {
 		FILE* file = fopen(myLogFileName, &quot;a&quot;);
-		fprintf(file, &quot;%s\n&quot;, msg);
+		if (useTimeStamps) {
+			char* timeStamp = simpleLog_createTimeStamp();
+			fprintf(file, &quot;%s: %s\n&quot;, timeStamp, msg);
+			free(timeStamp);
+		} else {
+			fprintf(file, &quot;%s\n&quot;, msg);
+		}
 		fclose(file);
 	} else {
+		// fallback method: write to stdout
 		printf(msg);
 	}
 }
 
-void logFatalError(const char* msg, int error) {
+void simpleLog_logv(const char* fmt, va_list argp) {
 	
-	log(msg);
+	char text[bufferSize];
+
+	VSNPRINTF(text, sizeof(text), fmt, argp);
+	simpleLog_out(text);
+}
+
+void simpleLog_log(const char* fmt, ...) {
+
+	va_list argp;
+
+	va_start(argp, fmt);
+	simpleLog_logv(fmt, argp);
+	va_end(argp);
+}
+
+void simpleLog_error(int error, const char* fmt, ...) {
+
+	va_list argp;
+
+	va_start(argp, fmt);
+	simpleLog_logv(fmt, argp);
+	va_end(argp);
+
 	exit(error);
 }

Modified: branches/caiinterface/AI/Interfaces/C/Log.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Log.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/AI/Interfaces/C/Log.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -27,17 +27,17 @@
 /**
  * Initializes the log.
  */
-void initLog(const char* logFileName);
+void simpleLog_init(const char* logFileName, bool useTimeStamps);
 
 /**
- * Logs a text message.
+ * Logs a text message. Works like printf(fmt, ...)
  */
-void log(const char* msg);
+void simpleLog_log(const char* fmt, ...);
 
 /**
- * Logs a text message and exits.
+ * Logs a text message and exits. Works like printf(fmt, ...)
  */
-void logFatalError(const char* msg, int error = -1);
+void simpleLog_error(int error, const char* msg, ...);
 
 #ifdef	__cplusplus
 }

Modified: branches/caiinterface/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -1045,7 +1045,7 @@
 const vector&lt;SearchOffset&gt;&amp; GetSearchOffsetTable (int radius)
 {
 	static vector &lt;SearchOffset&gt; searchOffsets;
-	int size = radius*radius*4;
+	unsigned int size = radius*radius*4;
 	if (size &gt; searchOffsets.size()) {
 		searchOffsets.resize (size);
 
@@ -1220,7 +1220,7 @@
 	int allyteam = gs-&gt;AllyTeam(team);
 	int n = 0;
 
-	for (int a=0;a&lt;ft.size();a++)
+	for (unsigned int a=0;a&lt;ft.size();a++)
 	{
 		CFeature *f = ft[a];
 

Modified: branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -28,10 +28,8 @@
 
 #include &quot;System/Util.h&quot;
 #include &quot;System/Platform/errorhandler.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
 
-#include &lt;string&gt;
-
-
 /*
 CAIInterfaceLibrary::CAIInterfaceLibrary(
 		const SAIInterfaceSpecifier&amp; interfaceSpecifier,
@@ -41,16 +39,6 @@
 CAIInterfaceLibrary::CAIInterfaceLibrary(const CAIInterfaceLibraryInfo* _info)
 		: info(_info) {
 	
-	staticGlobalData = createStaticGlobalData();
-	
-	std::string mainLibDir = std::string(staticGlobalData-&gt;libDir);
-	if (!mainLibDir.empty()) {
-		mainLibDir = mainLibDir + '/';
-	}
-	
-	// will look about like this: &quot;C:/Games/spring/AI/Interfaces/impls&quot;
-	aiInterfacesLibDir = mainLibDir + AI_INTERFACES_IMPLS_DIR;
-	
 	std::string libFilePath;
 
 	std::string libFileName = info-&gt;GetFileName();
@@ -59,7 +47,7 @@
 				&quot; No file name specified in AIInterface.lua&quot;,
 				&quot;AI Interface Error&quot;, MBF_OK | MBF_EXCL);
 	}
-	libFilePath = GenerateLibFilePath(libFileName, aiInterfacesLibDir);
+	libFilePath = FindLibFile(libFileName);
 	
 	sharedLib = SharedLib::Instantiate(libFilePath);
 	if (sharedLib == NULL) {
@@ -79,14 +67,16 @@
 CAIInterfaceLibrary::~CAIInterfaceLibrary() {
 	
 	ReleaseStatic();
-	freeStaticGlobalData(staticGlobalData);
 	delete sharedLib;
 }
 
 void CAIInterfaceLibrary::InitStatic() {
 	
 	if (sAIInterfaceLibrary.initStatic != NULL) {
+		staticGlobalData = createStaticGlobalData();
 		sAIInterfaceLibrary.initStatic(staticGlobalData);
+	} else {
+		staticGlobalData = NULL;
 	}
 }
 void CAIInterfaceLibrary::ReleaseStatic() {
@@ -94,6 +84,9 @@
 	if (sAIInterfaceLibrary.releaseStatic != NULL) {
 		sAIInterfaceLibrary.releaseStatic();
 	}
+	if (staticGlobalData != NULL) {
+		freeStaticGlobalData(staticGlobalData);
+	}
 }
 
 SAIInterfaceSpecifier CAIInterfaceLibrary::GetSpecifier() const {
@@ -393,9 +386,8 @@
 }
 
 
-std::string CAIInterfaceLibrary::GenerateLibFilePath(
-		const std::string&amp; fileNameMainPart,
-		const std::string&amp; aiInterfacesLibDir) {
+std::string CAIInterfaceLibrary::FindLibFile(
+		const std::string&amp; fileNameMainPart) {
 	
 	std::string libFileName = fileNameMainPart + &quot;.&quot; + SharedLib::GetLibExtension();
 	#ifndef _WIN32
@@ -403,8 +395,21 @@
 	#endif
 	// libFileName should now look about like this: libJava-0.600.so or Java-0.600.dll
 	
+	std::vector&lt;std::string&gt; libFile =
+			CFileHandler::FindFiles(AI_INTERFACES_IMPLS_DIR, libFileName);
+	
 	// generate a path like this: &quot;C:/Games/spring/AI/Interfaces/impls/Java-0.600.dll&quot;
-	return aiInterfacesLibDir + &quot;/&quot; + libFileName;
+	std::string path = &quot;&quot;;
+	if (libFile.size() &gt;= 1) {
+		path = libFile.at(0);
+	} else {
+		// though the file is not available, we still return the relative path
+		// when trying ot load the lib, the user will see through
+		// the error message, which file is missing where
+		path = std::string(AI_INTERFACES_IMPLS_DIR) + &quot;/&quot; + libFileName;
+	}
+	
+	return path;
 }
 
 /*

Modified: branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -23,6 +23,9 @@
 #include &quot;Platform/SharedLib.h&quot;
 #include &quot;Interface/SAIInterfaceLibrary.h&quot;
 
+#include &lt;string&gt;
+#include &lt;map&gt;
+
 class CAIInterfaceLibraryInfo;
 class CSkirmishAILibraryInfo;
 class CGroupAILibraryInfo;
@@ -71,7 +74,7 @@
 	void ReleaseStatic();
 	
 private:
-	std::string aiInterfacesLibDir;
+	//std::string aiInterfacesLibDir;
 	SharedLib* sharedLib;
 	SAIInterfaceLibrary sAIInterfaceLibrary;
 	//SAIInterfaceSpecifier specifier;
@@ -88,10 +91,7 @@
 			const std::string* functionName);
 	int InitializeFromLib(const std::string&amp; libFilePath);
 	
-	//static std::string GenerateLibFilePath(const SAIInterfaceSpecifier&amp; interfaceSpecifier, const std::string&amp; libPathPrefix = &quot;&quot;);
-	//static std::string GenerateLibFilePath(const InfoItem&amp; interfaceSpecifier, const std::string&amp; libPathPrefix = &quot;&quot;);
-	static std::string GenerateLibFilePath(const std::string&amp; fileNameMainPart,
-			const std::string&amp; aiInterfacesLibDir);
+	static std::string FindLibFile(const std::string&amp; fileNameMainPart);
 };
 
 #endif	/* _AIINTERFACELIBRARY_H */

Modified: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -17,13 +17,13 @@
 
 #include &quot;AIInterfaceLibraryInfo.h&quot;
 
-#include &quot;Platform/errorhandler.h&quot;
 #include &quot;IAIInterfaceLibrary.h&quot;
 #include &quot;Interface/aidefines.h&quot;
 #include &quot;Interface/SInfo.h&quot;
-#include &quot;Util.h&quot;
-#include &quot;LogOutput.h&quot;
 
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;FileSystem/VFSModes.h&quot;
+
 CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
 		const IAIInterfaceLibrary&amp; interface) {
 	
@@ -42,13 +42,11 @@
 }
 
 CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
-		const std::string&amp; interfaceInfoFile,
-		const std::string&amp; fileModes,
-		const std::string&amp; accessModes) {
+		const std::string&amp; interfaceInfoFile) {
 	
 	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(interfaceInfoFile.c_str(), fileModes.c_str(),
-			accessModes.c_str(), tmpInfo, MAX_INFOS);
+	unsigned int num = ParseInfo(interfaceInfoFile.c_str(), SPRING_VFS_RAW,
+			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
     for (unsigned int i=0; i &lt; num; ++i) {
 /*
 		logOutput.Print(&quot;info %i: %s / %s / %s&quot;, i, tmpInfo[i].key,

Modified: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -30,9 +30,7 @@
 public:
 	CAIInterfaceLibraryInfo(const IAIInterfaceLibrary&amp; interface);
 	CAIInterfaceLibraryInfo(const CAIInterfaceLibraryInfo&amp; interfaceInfo);
-	CAIInterfaceLibraryInfo(const std::string&amp; interfaceInfoFile,
-			const std::string&amp; fileModes,
-			const std::string&amp; accessModes);
+	CAIInterfaceLibraryInfo(const std::string&amp; interfaceInfoFile);
     
     //virtual LevelOfSupport GetLevelOfSupportForCurrentEngine() const;
 	

Modified: branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -160,45 +160,41 @@
 */
 
 void CAILibraryManager::GetAllInfosFromCache() {
-	//reportError(&quot;NOT YET IMPLEMENTED&quot;, &quot;CAILibraryManager::GetAllInfosFromCache() is not yet implemented.&quot;);
 	
 	ClearAllInfos();
 	
-	// look for AI data files (AIInfo.lua &amp; AIOptions.lua)
-	//int GetSkirmishAICount() {
-	
 /*
 	if (!(vfsHandler)) {
-		reportError(&quot;Initialization Error&quot;, Call InitArchiveScanner before GetSkirmishAICount.&quot;);
+		reportError(&quot;Initialization Error&quot;, Call InitArchiveScanner before GetAllInfosFromCache.&quot;);
 	}
 */
+	typedef std::vector&lt;std::string&gt; T_dirs;
 	
+	// cause we use CFileHandler for searching files,
+	// we are automatically searching in all data-dirs
+	
 	// Read from AI Interface info files
-	std::vector&lt;std::string&gt; aiInterfaceDataDirs = CFileHandler::SubDirs(AI_INTERFACES_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
-	for (std::vector&lt;std::string&gt;::iterator dir = aiInterfaceDataDirs.begin(); dir != aiInterfaceDataDirs.end(); ++dir) {
+	// we are looking for:
+	// AI/Interfaces/data/ * /InterfaceInfo.lua
+	// AI/Interfaces/data/ * / * /InterfaceInfo.lua
+	T_dirs aiInterfaceDataDirs =
+			FindDirsAndDirectSubDirs(AI_INTERFACES_DATA_DIR);
+	for (T_dirs::iterator dir = aiInterfaceDataDirs.begin();
+			dir != aiInterfaceDataDirs.end(); ++dir) {
 		const std::string&amp; possibleDataDir = *dir;
-		std::vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;InterfaceInfo.lua&quot;);
+		T_dirs infoFile =
+				CFileHandler::FindFiles(possibleDataDir, &quot;InterfaceInfo.lua&quot;);
 		if (infoFile.size() &gt; 0) { // interface info is available
-			//aiInterfaceDataDirs.erase(dir);
 			
 			// generate and store the interface info
-			CAIInterfaceLibraryInfo* interfaceInfo = new CAIInterfaceLibraryInfo(infoFile.at(0), SPRING_VFS_RAW, SPRING_VFS_RAW);
+			CAIInterfaceLibraryInfo* interfaceInfo =
+					new CAIInterfaceLibraryInfo(infoFile.at(0));
 			
-			//std::vector&lt;InfoItem&gt; infos = ParseInfos(infoFile.at(0), SPRING_VFS_RAW, SPRING_VFS_RAW);
-			//options = ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
-			
 			std::string sn = interfaceInfo-&gt;GetShortName();
 			std::string v = interfaceInfo-&gt;GetVersion();
 			SAIInterfaceSpecifier interfaceSpecifier = {sn.c_str(), v.c_str()};
 			interfaceSpecifier = copySAIInterfaceSpecifier(&amp;interfaceSpecifier);
-			//interfaceSpecifier = copySAIInterfaceSpecifier(&amp;interfaceSpecifier);
 			interfaceSpecifiers.push_back(interfaceSpecifier);
-/*
-
-			// generate and store the pure file name
-			std::string fileName = std::string(extractFileName(*libFile, false));
-			interfaceFileNames[interfaceSpecifier] = fileName;
-*/
 			interfaceInfos[interfaceSpecifier] = interfaceInfo;
 		}
 	}
@@ -206,28 +202,38 @@
 	
 	
 	// Read from Skirmish AI info and option files
-	std::vector&lt;std::string&gt; skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
-	for (std::vector&lt;std::string&gt;::iterator dir = skirmishAIDataDirs.begin(); dir != skirmishAIDataDirs.end(); ++dir) {
+	// we are looking for:
+	// AI/Skirmish/data/ * /AIInfo.lua
+	// AI/Skirmish/data/ * / * /AIInfo.lua
+	T_dirs skirmishAIDataDirs = FindDirsAndDirectSubDirs(SKIRMISH_AI_DATA_DIR);
+	for (T_dirs::iterator dir = skirmishAIDataDirs.begin();
+			dir != skirmishAIDataDirs.end(); ++dir) {
 		const std::string&amp; possibleDataDir = *dir;
-		std::vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+		T_dirs infoFile = CFileHandler::FindFiles(possibleDataDir,
+				&quot;AIInfo.lua&quot;);
 		if (infoFile.size() &gt; 0) { // skirmish AI info is available
 			std::string optionFileName = &quot;&quot;;
-			std::vector&lt;std::string&gt; optionFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIOptions.lua&quot;);
+			T_dirs optionFile = CFileHandler::FindFiles(possibleDataDir,
+					&quot;AIOptions.lua&quot;);
 			if (optionFile.size() &gt; 0) {
 				optionFileName = optionFile.at(0);
 			}
 			// generate and store the ai info
-			CSkirmishAILibraryInfo* skirmishAIInfo = new CSkirmishAILibraryInfo(infoFile.at(0), optionFileName, SPRING_VFS_RAW, SPRING_VFS_RAW);
+			CSkirmishAILibraryInfo* skirmishAIInfo =
+					new CSkirmishAILibraryInfo(infoFile.at(0), optionFileName);
 			
 			std::string sn = skirmishAIInfo-&gt;GetShortName();
 			std::string v = skirmishAIInfo-&gt;GetVersion();
-			SSAISpecifier skirmishAISpecifier = {sn.c_str(), v.c_str()};
-			SAIInterfaceSpecifier interfaceSpecifier = findFittingInterfaceSpecifier(skirmishAIInfo-&gt;GetInterfaceShortName(), skirmishAIInfo-&gt;GetInterfaceVersion(), interfaceSpecifiers);
+			SSAISpecifier aiSpecifier = {sn.c_str(), v.c_str()};
+			SAIInterfaceSpecifier interfaceSpecifier =
+					FindFittingInterfaceSpecifier(
+							skirmishAIInfo-&gt;GetInterfaceShortName(),
+							skirmishAIInfo-&gt;GetInterfaceVersion(),
+							interfaceSpecifiers);
 			if (interfaceSpecifier.shortName != NULL) {
-				skirmishAISpecifier = copySSAISpecifier(&amp;skirmishAISpecifier);
-				SSAIKey skirmishAIKey = {interfaceSpecifier, skirmishAISpecifier};
+				aiSpecifier = copySSAISpecifier(&amp;aiSpecifier);
+				SSAIKey skirmishAIKey = {interfaceSpecifier, aiSpecifier};
 				skirmishAIKeys.push_back(skirmishAIKey);
-
 				skirmishAIInfos[skirmishAIKey] = skirmishAIInfo;
 			}
 		}
@@ -235,28 +241,38 @@
 	
 	
 	// Read from Group AI info and option files
-	std::vector&lt;std::string&gt; groupAIDataDirs = CFileHandler::SubDirs(GROUP_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
-	for (std::vector&lt;std::string&gt;::iterator dir = groupAIDataDirs.begin(); dir != groupAIDataDirs.end(); ++dir) {
+	// we are looking for:
+	// AI/Group/data/ * /AIInfo.lua
+	// AI/Group/data/ * / * /AIInfo.lua
+	T_dirs groupAIDataDirs = FindDirsAndDirectSubDirs(GROUP_AI_DATA_DIR);
+	for (T_dirs::iterator dir = groupAIDataDirs.begin();
+			dir != groupAIDataDirs.end(); ++dir) {
 		const std::string&amp; possibleDataDir = *dir;
-		std::vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+		T_dirs infoFile = CFileHandler::FindFiles(possibleDataDir,
+				&quot;AIInfo.lua&quot;);
 		if (infoFile.size() &gt; 0) { // group AI info is available
 			std::string optionFileName = &quot;&quot;;
-			std::vector&lt;std::string&gt; optionFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIOptions.lua&quot;);
+			T_dirs optionFile = CFileHandler::FindFiles(possibleDataDir,
+					&quot;AIOptions.lua&quot;);
 			if (optionFile.size() &gt; 0) {
 				optionFileName = optionFile.at(0);
 			}
 			// generate and store the ai info
-			CGroupAILibraryInfo* groupAIInfo = new CGroupAILibraryInfo(infoFile.at(0), optionFileName, SPRING_VFS_RAW, SPRING_VFS_RAW);
+			CGroupAILibraryInfo* groupAIInfo =
+					new CGroupAILibraryInfo(infoFile.at(0), optionFileName);
 			
 			std::string sn = groupAIInfo-&gt;GetShortName();
 			std::string v = groupAIInfo-&gt;GetVersion();
-			SGAISpecifier groupAISpecifier = {sn.c_str(), v.c_str()};
-			SAIInterfaceSpecifier interfaceSpecifier = findFittingInterfaceSpecifier(groupAIInfo-&gt;GetInterfaceShortName(), groupAIInfo-&gt;GetInterfaceVersion(), interfaceSpecifiers);
+			SGAISpecifier aiSpecifier = {sn.c_str(), v.c_str()};
+			SAIInterfaceSpecifier interfaceSpecifier =
+					FindFittingInterfaceSpecifier(
+							groupAIInfo-&gt;GetInterfaceShortName(),
+							groupAIInfo-&gt;GetInterfaceVersion(),
+							interfaceSpecifiers);
 			if (interfaceSpecifier.shortName != NULL) {
-				groupAISpecifier = copySGAISpecifier(&amp;groupAISpecifier);
-				SGAIKey groupAIKey = {interfaceSpecifier, groupAISpecifier};
+				aiSpecifier = copySGAISpecifier(&amp;aiSpecifier);
+				SGAIKey groupAIKey = {interfaceSpecifier, aiSpecifier};
 				groupAIKeys.push_back(groupAIKey);
-
 				groupAIInfos[groupAIKey] = groupAIInfo;
 			}
 		}
@@ -631,7 +647,27 @@
 	return found;
 }
 
-SAIInterfaceSpecifier CAILibraryManager::findFittingInterfaceSpecifier(
+std::vector&lt;std::string&gt; CAILibraryManager::FindDirsAndDirectSubDirs(
+		const std::string&amp; path) {
+	
+	 std::string pattern = &quot;*&quot;;
+	
+	// find dirs
+	std::vector&lt;std::string&gt; found = CFileHandler::SubDirs(path, pattern,
+			SPRING_VFS_RAW);
+	
+	// find sub-dirs
+	for (std::vector&lt;std::string&gt;::iterator dir = found.begin();
+			dir != found.end(); ++dir) {
+		std::vector&lt;std::string&gt; sub_dirs = CFileHandler::SubDirs(*dir, pattern,
+				SPRING_VFS_RAW);
+		found.insert(found.end(), sub_dirs.begin(), sub_dirs.end());
+	}
+	
+	return found;
+}
+
+SAIInterfaceSpecifier CAILibraryManager::FindFittingInterfaceSpecifier(
 		const std::string&amp; shortName,
 		const std::string&amp; minVersion,
 		const std::vector&lt;SAIInterfaceSpecifier&gt;&amp; specs) {

Modified: branches/caiinterface/rts/ExternalAI/AILibraryManager.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryManager.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/AILibraryManager.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -133,8 +133,21 @@
 	 */
 	//void GetAllInfosFromLibraries();
 	/**
-	 * Loads info about available AIs from cached LUA files.
+	 * Loads info about available AI Interfaces and AIs from LUA Info files.
 	 * -&gt; interface and AI libraries can not corrupt the engines memory
+	 *
+	 * The files are searched in all data-dirs (see fs.GetDataDirectories())
+	 * in the following sub-dirs:
+	 * AI/Interfaces/data/ * /InterfaceInfo.lua
+	 * AI/Interfaces/data/ * / * /InterfaceInfo.lua
+	 * AI/Skirmish/data/ * /AIInfo.lua
+	 * AI/Skirmish/data/ * / * /AIInfo.lua
+	 * AI/Group/data/ * /AIInfo.lua
+	 * AI/Group/data/ * / * /AIInfo.lua
+	 *
+	 * examples:
+	 * AI/Skirmish/data/KAIK-0.13/AIInfo.lua
+	 * AI/Skirmish/data/RAI/0.601/AIInfo.lua
 	 */
 	void GetAllInfosFromCache();
 	/**
@@ -150,6 +163,7 @@
 	static void reportInterfaceFunctionError(const std::string* libFileName, const std::string* functionName);
 	static std::string extractFileName(const std::string&amp; libFile, bool includeExtension);
 	static std::vector&lt;std::string&gt; FindFiles(const std::string&amp; path, const std::string&amp; fileExtension);
+	static std::vector&lt;std::string&gt; FindDirsAndDirectSubDirs(const std::string&amp; path);
 	/**
 	 * Finds the best fitting interface.
 	 * The  short name has to fit perfectly, and the version of the interface
@@ -160,7 +174,7 @@
 	 * available: 0.1, 0.3, 0.5
 	 * chosen: 0.3
 	 */
-	static SAIInterfaceSpecifier findFittingInterfaceSpecifier(
+	static SAIInterfaceSpecifier FindFittingInterfaceSpecifier(
 			const std::string&amp; shortName,
 			const std::string&amp; minVersion,
 			const std::vector&lt;SAIInterfaceSpecifier&gt;&amp; specs);

Modified: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -23,8 +23,10 @@
 #include &quot;IGroupAILibrary.h&quot;
 
 #include &quot;Platform/errorhandler.h&quot;
+#include &quot;FileSystem/VFSModes.h&quot;
 
-CGroupAILibraryInfo::CGroupAILibraryInfo(const IGroupAILibrary&amp; ai, const SAIInterfaceSpecifier&amp; interfaceSpecifier) {
+CGroupAILibraryInfo::CGroupAILibraryInfo(const IGroupAILibrary&amp; ai,
+		const SAIInterfaceSpecifier&amp; interfaceSpecifier) {
 	info = ai.GetInfo();
 	options = ai.GetOptions();
 	//levelOfSupport = ai.GetLevelOfSupportFor(std::string(ENGINE_VERSION_STRING),
@@ -43,19 +45,19 @@
 
 CGroupAILibraryInfo::CGroupAILibraryInfo(
 		const std::string&amp; aiInfoFile,
-		const std::string&amp; aiOptionFile,
-		const std::string&amp; fileModes,
-		const std::string&amp; accessModes) {
+		const std::string&amp; aiOptionFile) {
 	
 	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(aiInfoFile.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfo, MAX_INFOS);
+	unsigned int num = ParseInfo(aiInfoFile.c_str(), SPRING_VFS_RAW,
+			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
     for (unsigned int i=0; i &lt; num; ++i) {
 		info[std::string(tmpInfo[i].key)] = tmpInfo[i];
     }
 	
 	if (!aiOptionFile.empty()) {
 		Option tmpOptions[MAX_OPTIONS];
-		num = ParseOptions(aiOptionFile.c_str(), fileModes.c_str(), accessModes.c_str(), &quot;&quot;, tmpOptions, MAX_OPTIONS);
+		num = ParseOptions(aiOptionFile.c_str(), SPRING_VFS_RAW, SPRING_VFS_RAW,
+				&quot;&quot;, tmpOptions, MAX_OPTIONS);
 		for (unsigned int i=0; i &lt; num; ++i) {
 			options.push_back(tmpOptions[i]);
 		}
@@ -112,7 +114,8 @@
 }
 
 
-unsigned int CGroupAILibraryInfo::GetInfoCReference(InfoItem cInfo[], unsigned int maxInfoItems) const {
+unsigned int CGroupAILibraryInfo::GetInfoCReference(InfoItem cInfo[],
+		unsigned int maxInfoItems) const {
 	
 	unsigned int i=0;
 	
@@ -123,12 +126,13 @@
 	
 	return i;
 }
-unsigned int CGroupAILibraryInfo::GetOptionsCReference(Option cOptions[], unsigned int max) const {
+unsigned int CGroupAILibraryInfo::GetOptionsCReference(Option cOptions[],
+		unsigned int maxOptions) const {
 	
 	unsigned int i=0;
 	
 	std::vector&lt;Option&gt;::const_iterator ops;
-	for (ops=options.begin(); ops != options.end() &amp;&amp; i &lt; max; ++ops) {
+	for (ops=options.begin(); ops != options.end() &amp;&amp; i &lt; maxOptions; ++ops) {
 		cOptions[i++] = *ops;
     }
 	
@@ -154,18 +158,24 @@
 void CGroupAILibraryInfo::SetURL(const std::string&amp; url) {
 	SetInfo(GROUP_AI_PROPERTY_URL, url);
 }
-void CGroupAILibraryInfo::SetInterfaceShortName(const std::string&amp; interfaceShortName) {
+void CGroupAILibraryInfo::SetInterfaceShortName(
+		const std::string&amp; interfaceShortName) {
 	SetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME, interfaceShortName);
 }
-void CGroupAILibraryInfo::SetInterfaceVersion(const std::string&amp; interfaceVersion) {
+void CGroupAILibraryInfo::SetInterfaceVersion(
+		const std::string&amp; interfaceVersion) {
 	SetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION, interfaceVersion);
 }
-bool CGroupAILibraryInfo::SetInfo(const std::string&amp; key, const std::string&amp; value) {
+bool CGroupAILibraryInfo::SetInfo(const std::string&amp; key,
+		const std::string&amp; value) {
 	
 	if (key == GROUP_AI_PROPERTY_SHORT_NAME ||
 			key == GROUP_AI_PROPERTY_VERSION) {
 		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
-			handleerror(NULL, &quot;Error&quot;, &quot;Group AI info (shortName or version) contains illegal characters ('_', '#' or white spaces)&quot;, MBF_OK | MBF_EXCL);
+			handleerror(NULL, &quot;Error&quot;,
+					&quot;Group AI info (shortName or version) contains&quot;
+					&quot; illegal characters ('_', '#' or white spaces)&quot;,
+					MBF_OK | MBF_EXCL);
 			return false;
 		}
 	}
@@ -176,5 +186,6 @@
 }
 
 void CGroupAILibraryInfo::SetOptions(const std::vector&lt;Option&gt;&amp; _options) {
-	options = std::vector&lt;Option&gt;(_options.begin(), _options.end()); // implicit convertible types -&gt; range-ctor can be used
+	// implicit convertible types -&gt; range-ctor can be used
+	options = std::vector&lt;Option&gt;(_options.begin(), _options.end());
 }

Modified: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -33,13 +33,11 @@
 
 class CGroupAILibraryInfo {
 public:
-	CGroupAILibraryInfo(const IGroupAILibrary&amp; ai, const SAIInterfaceSpecifier&amp; interfaceSpecifier);
+	CGroupAILibraryInfo(const IGroupAILibrary&amp; ai,
+			const SAIInterfaceSpecifier&amp; interfaceSpecifier);
 	CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo);
-	CGroupAILibraryInfo(
-			const std::string&amp; aiInfoFile,
-			const std::string&amp; aiOptionFile,
-			const std::string&amp; fileModes,
-			const std::string&amp; accessModes);
+	CGroupAILibraryInfo(const std::string&amp; aiInfoFile,
+			const std::string&amp; aiOptionFile);
     
     virtual SGAISpecifier GetSpecifier() const;
 	
@@ -53,8 +51,10 @@
     virtual std::string GetInterfaceVersion() const;
     virtual std::string GetInfo(const std::string&amp; key) const;
     virtual const std::map&lt;std::string, InfoItem&gt;* GetInfo() const;
-	virtual unsigned int GetInfoCReference(InfoItem cInfo[], unsigned int maxInfoItems) const;
-	virtual unsigned int GetOptionsCReference(Option cOptions[], unsigned int maxOptions) const;
+	virtual unsigned int GetInfoCReference(InfoItem cInfo[],
+			unsigned int maxInfoItems) const;
+	virtual unsigned int GetOptionsCReference(Option cOptions[],
+			unsigned int maxOptions) const;
 	
 	virtual const std::vector&lt;Option&gt;* GetOptions() const;
 	

Modified: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -124,11 +124,17 @@
 	 * This function is called right after the library is dynamically loaded.
 	 * It can be used to initialize variables and to check or prepare
 	 * the environment (os, engine, filesystem, ...).
+	 *
+	 * CAUTION: param staticGlobalData is only guaranteed to be valid
+	 * during the runtime of this function!
+	 *
 	 * See also releaseStatic().
 	 *
 	 * NOTE: this method is optional. An AI Interface not exporting this
 	 * function is still valid.
 	 *
+	 * @param	staticGlobalData	contains global data about hte engine
+	 *								and the environment
 	 * @return	init ok: 0, on error: != 0
 	 */
 	int (CALLING_CONV *initStatic)(const SStaticGlobalData* staticGlobalData);
@@ -137,6 +143,7 @@
 	 * This function is called right right before the library is unloaded.
 	 * It can be used to deinitialize variables and to cleanup the environment,
 	 * for example the filesystem.
+	 *
 	 * See also initStatic().
 	 *
 	 * NOTE: this method is optional. An AI Interface not exporting this

Modified: branches/caiinterface/rts/ExternalAI/Interface/SStaticGlobalData.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SStaticGlobalData.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/Interface/SStaticGlobalData.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -29,11 +29,18 @@
 struct SStaticGlobalData {
 	unsigned int maxTeams;
 	const char* springVersion;
-	const char* libDir;
+	/** The first entry is the writeable data-dir */
 	unsigned int numDataDirs;
 	const char** dataDirs;
 };
 
+// define the OS specific path separator
+#ifdef WIN32
+#define PS '\\'
+#else	/* WIN32 */
+#define PS '/'
+#endif	/* WIN32 */
+
 #ifdef	__cplusplus
 }		/* extern &quot;C&quot; */
 #endif	/* __cplusplus */

Modified: branches/caiinterface/rts/ExternalAI/SStaticGlobalData.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SStaticGlobalData.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/SStaticGlobalData.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -15,53 +15,23 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#include &lt;string&gt;
-
-
 #include &quot;Interface/SStaticGlobalData.h&quot;
 
-#if defined	__cplusplus &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
-#include &quot;System/GlobalStuff.h&quot; // for MAX_TEAMS
-#include &quot;System/Platform/FileSystem.h&quot; // for data directories
-#include &quot;Game/GameVersion.h&quot; // for VERSION_STRING
-
-#ifdef WIN32
-//#include &lt;windows.h&gt;	// filesystem operations
-#include &lt;direct.h&gt;	// filesystem operations
-#else
-#include &lt;unistd.h&gt;	// filesystem operations
-#endif
 #include &lt;stdlib.h&gt;	// malloc, calloc, free
 #include &lt;string.h&gt;	// strcpy
 
-bool getCWD(char* cwdPath, unsigned int maxLength) {
+#if defined	__cplusplus &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
+#include &quot;System/GlobalStuff.h&quot;			// for MAX_TEAMS
+#include &quot;System/Platform/FileSystem.h&quot;	// for data directories
+#include &quot;Game/GameVersion.h&quot;			// for VERSION_STRING
 
-	bool success = false;
-	//#ifdef WIN32
-	//	unsigned int cwdLength = GetCurrentDirectory(maxLength, cwdPath);
-	//	if (cwdLength &gt; 0 &amp;&amp; cwdLength &lt;= maxLength) {
-	//		success = true;
-	//	}
-	//#else	/* WIN32 */
-		const char* ret = getcwd(cwdPath, maxLength);
-		if (ret != NULL) {
-			success = true;
-		}
-	//#endif	/* WIN32 */
+#include &lt;string&gt;
 
-	if (!success) {
-		cwdPath[0] = '\0'; // make the path an empty string
-		//cwdPath = &quot;./&quot;;
-	}
-
-	return success;
-}
-
 /**
  * Appends '/' to inPath if it is not empty and does not yet have a '/'
  * or a '\\'at the end.
  */
-std::string ensurePathHasNoSlashAtTail(const std::string&amp; inPath) {
+std::string ensureNoPathSeparatorAtTail(const std::string&amp; inPath) {
 	
 	std::string outPath = inPath;
 	
@@ -75,30 +45,28 @@
 	return outPath;
 }
 
+#include &lt;stdio.h&gt;	// for file IO
 SStaticGlobalData* createStaticGlobalData() {
 	
-	char tmpPath[1024];
-	getCWD(tmpPath, sizeof(tmpPath));
-	std::string cleanCWD = ensurePathHasNoSlashAtTail(tmpPath);
-	char* cwdPath = (char*) calloc(cleanCWD.size()+1, sizeof(char));
-	strcpy(cwdPath, cleanCWD.c_str());
-
-	const std::vector&lt;std::string&gt; dds = FileSystemHandler::GetInstance().GetDataDirectories();
+	const std::vector&lt;std::string&gt; dds =
+			FileSystemHandler::GetInstance().GetDataDirectories();
 	unsigned int numDataDirs = dds.size();
+	
+	// converting the data-dirs vector to a C strings array (char*[])
 	char** dataDirs = (char**) calloc(numDataDirs, sizeof(char*));
 	for (unsigned int i=0; i &lt; numDataDirs; ++i) {
-		std::string cleanPath = ensurePathHasNoSlashAtTail(dds.at(i));
+		std::string cleanPath = ensureNoPathSeparatorAtTail(dds.at(i));
 		dataDirs[i] = (char*) calloc(cleanPath.size()+1, sizeof(char));
 		strcpy(dataDirs[i], cleanPath.c_str());
 	}
-
+	
 	const SStaticGlobalData sgd = {
 		MAX_TEAMS,
 		VERSION_STRING,	// spring version string
-		cwdPath,		// libDir
 		numDataDirs,
 		(const char**) dataDirs};
-	SStaticGlobalData* staticGlobalData = (struct SStaticGlobalData*) malloc(sizeof(struct SStaticGlobalData));
+	SStaticGlobalData* staticGlobalData = (struct SStaticGlobalData*)
+			malloc(sizeof(struct SStaticGlobalData));
 	*staticGlobalData = sgd;
 	
 	return staticGlobalData;
@@ -107,7 +75,6 @@
 void freeStaticGlobalData(SStaticGlobalData* staticGlobalData) {
 	
 	free(const_cast&lt;char*&gt;(staticGlobalData-&gt;springVersion));
-	free(const_cast&lt;char*&gt;(staticGlobalData-&gt;libDir));
 	for(unsigned int i=0; i &lt; staticGlobalData-&gt;numDataDirs; ++i)
 		free(const_cast&lt;char*&gt;(staticGlobalData-&gt;dataDirs[i]));
 	free(const_cast&lt;char**&gt;(staticGlobalData-&gt;dataDirs));

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp	2008-10-13 14:20:58 UTC (rev 6694)
@@ -23,9 +23,7 @@
 #include &quot;ISkirmishAILibrary.h&quot;
 
 #include &quot;Platform/errorhandler.h&quot;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;map&gt;
+#include &quot;FileSystem/VFSModes.h&quot;
 
 CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(const ISkirmishAILibrary&amp; ai,
 		const SAIInterfaceSpecifier&amp; interfaceSpecifier) {
@@ -35,7 +33,8 @@
 	//		ENGINE_VERSION_NUMBER, interfaceSpecifier);
 }
 
-CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(const CSkirmishAILibraryInfo&amp; aiInfo) {
+CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(
+		const CSkirmishAILibraryInfo&amp; aiInfo) {
 	info = std::map&lt;std::string, InfoItem&gt;(
 			aiInfo.info.begin(),
 			aiInfo.info.end());
@@ -47,19 +46,19 @@
 
 CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(
 		const std::string&amp; aiInfoFile,
-		const std::string&amp; aiOptionFile,
-		const std::string&amp; fileModes,
-		const std::string&amp; accessModes) {
+		const std::string&amp; aiOptionFile) {
 	
 	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(aiInfoFile.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfo, MAX_INFOS);
+	unsigned int num = ParseInfo(aiInfoFile.c_str(), SPRING_VFS_RAW,
+			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
     for (unsigned int i=0; i &lt; num; ++i) {
 		info[std::string(tmpInfo[i].key)] = tmpInfo[i];
     }
 	
 	if (!aiOptionFile.empty()) {
 		Option tmpOptions[MAX_OPTIONS];
-		num = ParseOptions(aiOptionFile.c_str(), fileModes.c_str(), accessModes.c_str(), &quot;&quot;, tmpOptions, MAX_OPTIONS);
+		num = ParseOptions(aiOptionFile.c_str(), SPRING_VFS_RAW, SPRING_VFS_RAW,
+				&quot;&quot;, tmpOptions, MAX_OPTIONS);
 		for (unsigned int i=0; i &lt; num; ++i) {
 			options.push_back(tmpOptions[i]);
 		}
@@ -117,7 +116,8 @@
 }
 
 
-unsigned int CSkirmishAILibraryInfo::GetInfoCReference(InfoItem cInfo[], unsigned int maxInfoItems) const {
+unsigned int CSkirmishAILibraryInfo::GetInfoCReference(InfoItem cInfo[],
+		unsigned int maxInfoItems) const {
 	
 	unsigned int i=0;
 	
@@ -128,7 +128,8 @@
 	
 	return i;
 }
-unsigned int CSkirmishAILibraryInfo::GetOptionsCReference(Option cOptions[], unsigned int maxOptions) const {
+unsigned int CSkirmishAILibraryInfo::GetOptionsCReference(Option cOptions[],
+		unsigned int maxOptions) const {
 	
 	unsigned int i=0;
 	

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h	2008-10-13 10:02:43 UTC (rev 6693)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h	2008-10-13 14:20:58 UTC (rev 6694)
@@ -19,8 +19,6 @@
 #define	_SKIRMISHAILIBRARYINFO_H
 
 #include &quot;Interface/ELevelOfSupport.h&quot;
-//#include &quot;Interface/SAIInfo.h&quot;
-//#include &quot;Interface/SAIOption.h&quot;
 
 #include &lt;vector&gt;
 #include &lt;map&gt;
@@ -34,13 +32,11 @@
 
 class CSkirmishAILibraryInfo {
 public:
-	CSkirmishAILibraryInfo(const ISkirmishAILibrary&amp; ai, const SAIInterfaceSpecifier&amp; interfaceSpecifier);
+	CSkirmishAILibraryInfo(const ISkirmishAILibrary&amp; ai,
+			const SAIInterfaceSpecifier&amp; interfaceSpecifier);
 	CSkirmishAILibraryInfo(const CSkirmishAILibraryInfo&amp; aiInfo);
-	CSkirmishAILibraryInfo(
-			const std::string&amp; aiInfoFile,
-			const std::string&amp; aiOptionFile,
-			const std::string&amp; fileModes,
-			const std::string&amp; accessModes);
+	CSkirmishAILibraryInfo(const std::string&amp; aiInfoFile,
+			const std::string&amp; aiOptionFile);
     
 //    virtual LevelOfSupport GetLevelOfSupportForCurrentEngineAndSetInterface() const;
 //    virtual LevelOfSupport GetLevelOfSupportForCurrentEngine(SAIInterfaceSpecifier interfaceSpecifier) const;
@@ -58,8 +54,10 @@
     virtual std::string GetInfo(const std::string&amp; key) const;
     virtual const std::map&lt;std::string, InfoItem&gt;* GetInfo() const;
 //    virtual std::vector&lt;std::string&gt; GetPropertyNames() const;
-	virtual unsigned int GetInfoCReference(InfoItem cInfo[], unsigned int maxInfoItems) const;
-	virtual unsigned int GetOptionsCReference(Option cOptions[], unsigned int maxOptions) const;
+	virtual unsigned int GetInfoCReference(InfoItem cInfo[],
+			unsigned int maxInfoItems) const;
+	virtual unsigned int GetOptionsCReference(Option cOptions[],
+			unsigned int maxOptions) const;
 	
 	virtual const std::vector&lt;Option&gt;* GetOptions() const;
 	
@@ -83,5 +81,5 @@
 	//LevelOfSupport levelOfSupport;
 };
 
-#endif	/* _SKIRMISHAILIBRARYINFO_H */
+#endif	// _SKIRMISHAILIBRARYINFO_H
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001462.html">[Taspring-linux-commit] r6693 - trunk/AI/Global
</A></li>
	<LI>Next message: <A HREF="001464.html">[Taspring-linux-commit] r6695 - in trunk/rts/Sim: MoveTypes	Units/CommandAI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1463">[ date ]</a>
              <a href="thread.html#1463">[ thread ]</a>
              <a href="subject.html#1463">[ subject ]</a>
              <a href="author.html#1463">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
