<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6639 - in branches/caiinterface: .	AI/Skirmish Documentation installer	installer/freedesktop/applications installer/freedesktop/mime	installer/sections rts/Game rts/Game/Camera rts/Game/UI	rts/Rendering rts/Rendering/Env rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Weapons tools/DedicatedServer	tools/springie tools/springie/Springie	tools/springie/Springie/Properties tools/springie/Springie/autohost	tools/springie/Springie/client tools/springie/Springie/doc	tools/springie/Springie/spring tools/springie/Springie/utils	tools/springie/libs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6639%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Skirmish%20Documentation%20installer%0A%09installer/freedesktop/applications%20installer/freedesktop/mime%0A%09installer/sections%20rts/Game%20rts/Game/Camera%20rts/Game/UI%0A%09rts/Rendering%20rts/Rendering/Env%20rts/Sim/Misc%0A%09rts/Sim/MoveTypes%20rts/Sim/Weapons%20tools/DedicatedServer%0A%09tools/springie%20tools/springie/Springie%0A%09tools/springie/Springie/Properties%20tools/springie/Springie/autohost%0A%09tools/springie/Springie/client%20tools/springie/Springie/doc%0A%09tools/springie/Springie/spring%20tools/springie/Springie/utils%0A%09tools/springie/libs&In-Reply-To=%3C20081009185524.2EE3446EB%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001407.html">
   <LINK REL="Next"  HREF="001409.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6639 - in branches/caiinterface: .	AI/Skirmish Documentation installer	installer/freedesktop/applications installer/freedesktop/mime	installer/sections rts/Game rts/Game/Camera rts/Game/UI	rts/Rendering rts/Rendering/Env rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Weapons tools/DedicatedServer	tools/springie tools/springie/Springie	tools/springie/Springie/Properties tools/springie/Springie/autohost	tools/springie/Springie/client tools/springie/Springie/doc	tools/springie/Springie/spring tools/springie/Springie/utils	tools/springie/libs</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6639%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Skirmish%20Documentation%20installer%0A%09installer/freedesktop/applications%20installer/freedesktop/mime%0A%09installer/sections%20rts/Game%20rts/Game/Camera%20rts/Game/UI%0A%09rts/Rendering%20rts/Rendering/Env%20rts/Sim/Misc%0A%09rts/Sim/MoveTypes%20rts/Sim/Weapons%20tools/DedicatedServer%0A%09tools/springie%20tools/springie/Springie%0A%09tools/springie/Springie/Properties%20tools/springie/Springie/autohost%0A%09tools/springie/Springie/client%20tools/springie/Springie/doc%0A%09tools/springie/Springie/spring%20tools/springie/Springie/utils%0A%09tools/springie/libs&In-Reply-To=%3C20081009185524.2EE3446EB%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6639 - in branches/caiinterface: .	AI/Skirmish Documentation installer	installer/freedesktop/applications installer/freedesktop/mime	installer/sections rts/Game rts/Game/Camera rts/Game/UI	rts/Rendering rts/Rendering/Env rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Weapons tools/DedicatedServer	tools/springie tools/springie/Springie	tools/springie/Springie/Properties tools/springie/Springie/autohost	tools/springie/Springie/client tools/springie/Springie/doc	tools/springie/Springie/spring tools/springie/Springie/utils	tools/springie/libs">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Oct  9 20:55:23 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001407.html">[Taspring-linux-commit] r6638 - in branches/caiinterface: . AI	AI/Interfaces AI/Interfaces/C AI/Skirmish AI/Skirmish/AAI	AI/Skirmish/KAIK-0.13 AI/Skirmish/NullAI	AI/Skirmish/NullLegacyCppAI AI/Skirmish/RAI-0.553	rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper rts/Game	rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Units	rts/Sim/Units/CommandAI rts/System rts/System/Platform	rts/System/Platform/Win rts/System/creg rts/build/scons
</A></li>
        <LI>Next message: <A HREF="001409.html">[Taspring-linux-commit] r6640 - trunk/rts/Game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1408">[ date ]</a>
              <a href="thread.html#1408">[ thread ]</a>
              <a href="subject.html#1408">[ subject ]</a>
              <a href="author.html#1408">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-10-09 20:55:21 +0200 (Thu, 09 Oct 2008)
New Revision: 6639

Added:
   branches/caiinterface/rts/Game/Camera/OrbitController.cpp
   branches/caiinterface/rts/Game/Camera/OrbitController.h
   branches/caiinterface/tools/springie/libs/
   branches/caiinterface/tools/springie/libs/PlanetWarsShared.dll
Removed:
   branches/caiinterface/tools/springie/libs/PlanetWarsShared.dll
Modified:
   branches/caiinterface/AI/Skirmish/CMakeLists.txt
   branches/caiinterface/CMakeLists.txt
   branches/caiinterface/Documentation/changelog.txt
   branches/caiinterface/Documentation/releasechecklist.txt
   branches/caiinterface/installer/freedesktop/applications/spring.desktop
   branches/caiinterface/installer/freedesktop/mime/spring.xml
   branches/caiinterface/installer/make_source_package.sh
   branches/caiinterface/installer/sections/shortcuts.nsh
   branches/caiinterface/installer/springsettings.nsh
   branches/caiinterface/rts/Game/Camera/CameraController.h
   branches/caiinterface/rts/Game/Camera/FPSController.h
   branches/caiinterface/rts/Game/Camera/FreeController.h
   branches/caiinterface/rts/Game/Camera/LuaCameraCtrl.h
   branches/caiinterface/rts/Game/Camera/OverheadController.h
   branches/caiinterface/rts/Game/Camera/OverviewController.h
   branches/caiinterface/rts/Game/Camera/RotOverheadController.h
   branches/caiinterface/rts/Game/Camera/SmoothController.cpp
   branches/caiinterface/rts/Game/Camera/SmoothController.h
   branches/caiinterface/rts/Game/Camera/TWController.h
   branches/caiinterface/rts/Game/CameraHandler.cpp
   branches/caiinterface/rts/Game/GameServer.cpp
   branches/caiinterface/rts/Game/GameVersion.cpp
   branches/caiinterface/rts/Game/Player.cpp
   branches/caiinterface/rts/Game/Team.cpp
   branches/caiinterface/rts/Game/UI/MouseHandler.cpp
   branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
   branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp
   branches/caiinterface/rts/Sim/Misc/QuadField.h
   branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp
   branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp
   branches/caiinterface/rts/Sim/Weapons/LaserCannon.cpp
   branches/caiinterface/rts/Sim/Weapons/Weapon.cpp
   branches/caiinterface/tools/DedicatedServer/CMakeLists.txt
   branches/caiinterface/tools/springie/
   branches/caiinterface/tools/springie/Springie.sln
   branches/caiinterface/tools/springie/Springie/ErrorHandling.cs
   branches/caiinterface/tools/springie/Springie/FormAccount.cs
   branches/caiinterface/tools/springie/Springie/FormCurrentBattle.cs
   branches/caiinterface/tools/springie/Springie/FormMain.Designer.cs
   branches/caiinterface/tools/springie/Springie/FormMain.cs
   branches/caiinterface/tools/springie/Springie/FormSettings.cs
   branches/caiinterface/tools/springie/Springie/Main.cs
   branches/caiinterface/tools/springie/Springie/MainConfig.cs
   branches/caiinterface/tools/springie/Springie/Program.cs
   branches/caiinterface/tools/springie/Springie/Properties/AssemblyInfo.cs
   branches/caiinterface/tools/springie/Springie/Springie.csproj
   branches/caiinterface/tools/springie/Springie/autohost/AutoHost.cs
   branches/caiinterface/tools/springie/Springie/autohost/AutoHostConfig.cs
   branches/caiinterface/tools/springie/Springie/autohost/AutoHost_commands.cs
   branches/caiinterface/tools/springie/Springie/autohost/AutoManager.cs
   branches/caiinterface/tools/springie/Springie/autohost/BanList.cs
   branches/caiinterface/tools/springie/Springie/autohost/BannedUser.cs
   branches/caiinterface/tools/springie/Springie/autohost/CommandConfig.cs
   branches/caiinterface/tools/springie/Springie/autohost/Ladder.cs
   branches/caiinterface/tools/springie/Springie/autohost/Polls.cs
   branches/caiinterface/tools/springie/Springie/autohost/Preset.cs
   branches/caiinterface/tools/springie/Springie/autohost/PrivilegedUser.cs
   branches/caiinterface/tools/springie/Springie/client/Battle.cs
   branches/caiinterface/tools/springie/Springie/client/BattleDetails.cs
   branches/caiinterface/tools/springie/Springie/client/BattleRect.cs
   branches/caiinterface/tools/springie/Springie/client/BotBattleStatus.cs
   branches/caiinterface/tools/springie/Springie/client/ServerConnection.cs
   branches/caiinterface/tools/springie/Springie/client/TasClient.cs
   branches/caiinterface/tools/springie/Springie/client/TasClient_structures.cs
   branches/caiinterface/tools/springie/Springie/client/UserBattleStatus.cs
   branches/caiinterface/tools/springie/Springie/doc/devlog.txt
   branches/caiinterface/tools/springie/Springie/spring/ConfigMaker.cs
   branches/caiinterface/tools/springie/Springie/spring/Spring.cs
   branches/caiinterface/tools/springie/Springie/spring/Talker.cs
   branches/caiinterface/tools/springie/Springie/spring/UnitSync.cs
   branches/caiinterface/tools/springie/Springie/utils/AutoUpdater.cs
   branches/caiinterface/tools/springie/Springie/utils/FileDownloader.cs
   branches/caiinterface/tools/springie/Springie/utils/MyCol.cs
   branches/caiinterface/tools/springie/Springie/utils/Stats.cs
   branches/caiinterface/tools/springie/Springie/utils/UnknownFilesLinker.cs
   branches/caiinterface/tools/springie/Springie/utils/Utils.cs
Log:
reintegrated trunk (last integration till HEAD)

Modified: branches/caiinterface/AI/Skirmish/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-10-09 18:55:21 UTC (rev 6639)
@@ -28,6 +28,7 @@
 
 
 ## RAI
+if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553)
 set(RAI_VERS &quot;UNKNOWN_VERSION&quot;)
 if (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/VERSION)
 	file(STRINGS &quot;${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/VERSION&quot; RAI_VERS LIMIT_COUNT 1)
@@ -38,6 +39,7 @@
 add_library(RAI-${RAI_VERS} MODULE ${rai} ${legacycppaienv} RAI-0.553/KrogsMetalClass/MetalMap)
 install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/RAI-${RAI_VERS})
 install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/RAI-${RAI_VERS})
+endif (EXISTS ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553)
 
 
 ## AAI

Modified: branches/caiinterface/CMakeLists.txt
===================================================================
--- branches/caiinterface/CMakeLists.txt	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/CMakeLists.txt	2008-10-09 18:55:21 UTC (rev 6639)
@@ -60,17 +60,21 @@
 ### Compiler flags and defines based on build type
 INCLUDE(TestCXXAcceptsVisibilityFlag)
 set (MARCH_FLAG native CACHE STRING &quot;CPU optimization (use i686 for generic optimization)&quot;)
-SET(CMAKE_CXX_FLAGS &quot;-fsingle-precision-constant -frounding-math -fsignaling-nans -mieee-fp -pipe -fno-strict-aliasing ${VISIBILITY_HIDDEN} ${VISIBILITY_INLINES_HIDDEN}&quot;)
+if (MARCH_FLAG)
+	set (CMAKE_CXX_FLAGS &quot;-march=${MARCH_FLAG} -mfpmath=387&quot;)
+endif (MARCH_FLAG)
+
+# intel C compiler fix (does not support these flags: -march -mfpmath -ggdb)
+IF ($ENV{CXX} MATCHES &quot;icpc&quot;)
+	SET(CMAKE_CXX_FLAGS &quot;&quot;)
+	SET(CXX_FLAGS_DEBUG_ADDITIONAL &quot;-g -debug full&quot;)
+ENDIF ($ENV{CXX} MATCHES &quot;icpc&quot;)
+
+SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsingle-precision-constant -frounding-math -fsignaling-nans -mieee-fp -pipe -fno-strict-aliasing ${VISIBILITY_HIDDEN} ${VISIBILITY_INLINES_HIDDEN}&quot;)
 # ADD_DEFINITIONS(-DSTREFLOP_X87) breaks AI compiling
-IF (NOT $ENV{CXX} MATCHES &quot;icpc&quot;)
-	SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -march=${MARCH_FLAG} -mfpmath=387&quot;)
-ENDIF (NOT $ENV{CXX} MATCHES &quot;icpc&quot;)
 IF (UNIX)
 	SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot;)
 ENDIF (UNIX)
-IF ($ENV{CXX} MATCHES &quot;icpc&quot;)
-	SET(CXX_FLAGS_DEBUG_ADDITIONAL &quot;-g -debug full&quot;)
-ENDIF ($ENV{CXX} MATCHES &quot;icpc&quot;)
 SET(CMAKE_CXX_FLAGS_DEBUG   &quot;${BASE_FLAGS} ${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
 SET(CMAKE_CXX_FLAGS_DEBUG2  &quot;${BASE_FLAGS} ${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
 SET(CMAKE_CXX_FLAGS_DEBUG3  &quot;${BASE_FLAGS} ${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
@@ -86,8 +90,8 @@
 Add_Subdirectory(AI)
 Add_Subdirectory(tools/DedicatedServer)
 Add_Subdirectory(tools/unitsync)
-Add_Subdirectory(tools/DemoAnalyser)
-Add_Subdirectory(tools/DemoDumper)
+#Add_Subdirectory(tools/DemoAnalyser)
+#Add_Subdirectory(tools/DemoDumper)
 
 ### make the basefiles (aka sdz's)
 if (UNIX OR CMAKE_CROSSCOMPILING)

Modified: branches/caiinterface/Documentation/changelog.txt
===================================================================
--- branches/caiinterface/Documentation/changelog.txt	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/Documentation/changelog.txt	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,16 +1,25 @@
 Spring change log
 
-0.76b2
+0.next
 
+User Interface
+  - added a simple Orbit-Camera controller
+       META-key + LMB + drag ==&gt; alter elevation, rotation
+       META-key + MMB + drag ==&gt; pan up/down/left/right
+       META-key + RMB + drag ==&gt; zoom
+
+
+
+0.77b1, 0.77b2
+
 User Interface:
- - FIXME: .cheat -&gt; /cheat
+ - all commands are prefixed with '/' instead of '.' (&quot;.cheat&quot; becomes &quot;/cheat&quot;, etc.)
  - Added /mapmarks [0|1]
  - Added /allmapmarks [0|1]
  - Added /forcestart command
  - Added /ally teamID [0|1] (Ingame alliances)
- - multithreaded avi-generator
  - Adde /commands (shows all registered commands in the console)
- - FIXME: whisper chat (w:?)
+ - whisper private messages to any other player ingame (excluding spectators) by typing &quot;/w Playername Your secret message&quot;
  - Added new camera controller: SmoothCamera
    behaves like overview controller, but feels much smoother
  - Added possibility to specify files that should be excluded from Spring's
@@ -42,12 +51,12 @@
    new texture mipmap generation.
  - You can now cycle through the last 10 message positions with F3.
 
-
 Spring Engine:
- (- FIXME: GML)
- - FIXME: Overall speed up (fastmath,SMF render code, minimap renderer, ..)
- - FIXME: Network code optimizations
- - FIXME: Functionality of Sensors.tdf and Particles.tdf moved to modrules. removed Sensors.tdf or Particles.tdf
+ - multithreaded avi-generator
+ - new water renderer: bumpwater (&quot;/water 4&quot;), pretty and fast 
+ - the usual speedups and performance improvements
+ - Font rendering system overhaul 
+ - Functionality of Sensors.tdf and Particles.tdf moved to modrules. removed Sensors.tdf or Particles.tdf
    Transfers resources.tdf to resources.lua, and resources_map.tdf to resources_map.lua.
    Sidedata.tdf -&gt; sidedata.lua
    icontypes.lua
@@ -55,25 +64,43 @@
    Replaced 'messages.tdf' with 'messages.lua'
    modinfo.tdf --&gt; modinfo.lua
    ArchiveCacheV6.txt --&gt; ArchiveCacheV7.lua
- - FIXME: Custom collision volumes (collisionVolumeTest..)
- - FIXME: Ingame alliances.
- - FIXME: Multithreaded Pathing.
- - FIXME: new bumpwater shader (/water 4).
+ - Add 'springcontent.sdz' as the last dependency for all primary mod archives
+ - Custom collision volumes for Units and Features
+ - you can ally / unally other teams ingame using the &quot;/ally [teamnumber] [0|1]&quot; command (needs to be activated in lobby)
+ - Made the groundplate decals follow their parent building's facing.
+ - Allow modnames (e.g. &quot;OTA Content&quot;) in dependX tag (modinfo).
+ - Removed 50% capture progress after an unit got captured.
+ - Made units transfer their speed to their wrecks.
+ - submarines can now travel directly underneath surface vessels and floating obstacles
+   (and conversely; ships can move across underwater objects), EDIT your mod's MoveInfo
+   entries so that the classes used by submarine-style units have &quot;subMarine=1;&quot; set if
+   you want to enable this fully
+ - Increased weapon limit per unit to 32.
+ - Added the following new tags to modrules.{lua,tdf}
+   - repair.energyCostFactor
+   - capture.energyCostFactor
+   - resurrect.energyCostFactor
+   - reclaim.unitEnergyCostFactor
+   - reclaim.featureEnergyCostFactor
+   - reclaim.unitMethod
+   - reclaim.unitEfficiency
+   - reclaim.allowEnemies
+   - reclaim.allowAllies
+ - Allow any key binding to a CMDTYPE_ICON command to use the 'queued' keyword
+   (except for build and stockpile commands, which already have special handling)
  - Keep units in various situations from deciding to attack units they 
    shouldn't (noChaseCatagory, neutral, under water without water weapons).
+   
+
+Units &amp; Weapons:
  - Added canFireControl unitdef tag.
- - Fixed the stop-turn-move-stop-turn behavior for ground units (new udef tag, turnInPlace)
- - Made MeleeWeapon obey impulseFactor.
- - Font rendering system overhaul, 
+ - Fixed the stop-turn-move-stop-turn behavior for ground units (new udef tag, turnInPlace) 
  - Added maxRepairSpeed tag for builders. Limits the rate a con swarm of any
    size can repair a single target.
  - Made accuracy, sprayangle and similar tags work for starburst missiles.
    The inaccuracy is applied when the missile turns toward its target.
  - Added capturable tag.
- - Allow any key binding to a CMDTYPE_ICON command to use the 'queued' keyword
-   (except for build and stockpile commands, which already have special handling)
  - Implemented 'y' value for yardmaps which means this square is not blocked.
- - Made the groundplate decals follow their parent building's facing.
  - Have fighting, patrolling and guarding aircraft and guarding ground units
    follow noChaseCatagory.
  - Added per-weapon highTrajectory tag (int, default 2). It acts like the unit
@@ -83,6 +110,12 @@
    by colliding with units instead of causing an explosion (the CEG will still run)
    to avoid the shortcomings of small AOEs. It's only implemented for projectile weapons
    so far.
+ - Custom collision volumes:
+   - collisionVolumeType (either: &quot;ellipsoid&quot;,&quot;cylT&quot; where 'T' is one of {X, Y, Z}, &quot;box&quot;)
+   - collisionVolumeScales (float3)
+   - collisionVolumeOffsets (float3)
+   - collisionVolumeTest (0: per-frame hit detection, 1: raytraced)
+   - all these tags are the same for Features
  - Added shieldRechargeDelay weapon tag (float, default 0). The delay is the number
    of seconds the shield won't charge after being hit (kinda like the idle autoheal
    for hitpoints)
@@ -95,32 +128,14 @@
    behaviour, the behaviour fails if the unit just takes its time for aiming (or
    cannot shoot at all) or has any other reason not to shoot.
  - Added avoidNeutral (targetting) and collideNeutral (projectiles) weapon tags.
- - Added unit FBI tag verticalSpeed (float, default: 3.0) for non-fighter/bomber
+ - Added verticalSpeed (float, default: 3.0) unitDef tag  for non-fighter/bomber
    planes to define the speed of takeoff and landing (or loading).
- - Removed 50% capture progress after an unit got captured.
- - Allow modnames (e.g. &quot;OTA Content&quot;) in dependX tag (modinfo).
- - Made units transfer their speed to their wrecks.
- - submarines can now travel directly underneath surface vessels and floating obstacles
-   (and conversely; ships can move across underwater objects), EDIT your mod's MoveInfo
-   entries so that the classes used by submarine-style units have &quot;subMarine=1;&quot; set if
-   you want to enable this fully
  - Made missiles obey burnblow=1 (existing tag), the missile will explode in midair
    instead of turning away or falling down when its flighttime expires if the tag is set.
- - Increased weapon limit per unit to 32.
  - Added the 'customParams' table to both featureDefs and weaponDefs
    (accessible via the lua FeatureDefs and WeaponDefs' tables).
- - Added the following new tags to modrules.{lua,tdf}
-   - repair.energyCostFactor
-   - capture.energyCostFactor
-   - resurrect.energyCostFactor
-   - reclaim.unitEnergyCostFactor
-   - reclaim.featureEnergyCostFactor
-   - reclaim.unitMethod
-   - reclaim.unitEfficiency
-   - reclaim.allowEnemies
-   - reclaim.allowAllies
- - add 'springcontent.sdz' as the last dependency for all primary mod archives
  - only add &quot;.wav&quot; extension for unitdef sounds if it is missing
+ - Made MeleeWeapon obey impulseFactor.
 
 Maps:
  - converted map config scripts to lua format (LuaParser / MapParser)
@@ -135,16 +150,34 @@
       maxheight =  200.0f,
     }
    (note:  these values can be changed by MapOptions)
+ - new water tags (mostly used by the BumpWater renderer):
+  - shoreWaves           (true)
+  - forceRendering       (false)
+  - ambientFactor        (1.0)
+  - diffuseFactor        (1.0)
+  - specularFactor       (1.0)
+  - specularPower        (20.0)
+  - diffuseColor         float3(1.0, 1.0, 1.0)
+  - specularColor        float3(light.groundSunColor)
+  - fresnelMin           (0.2)
+  - fresnelMax           (0.8)
+  - fresnelPower         (4.0)
+  - reflectionDistortion (1.0)
+  - blurBase             (2.0)
+  - blurExponent         (1.5)
+  - perlinStartFreq      (8.0)
+  - perlinLacunarity     (3.0)
+  - perlinAmplitude      (0.9)
+  - foamTexture
+  - normalTexture
+  - numTiles
+  - caustics (texture table)
 
 COB:
  - Added new COB get constants MIN (131), MAX(132) and ABS(133).
  - Added the SONAR_STEALTH (108) COB get/set parameter
 
 LUA changes:
- - FIXME (r5960): added some untested code for proxied gadget events
-  (KeyPress, KeyRelease, etc...)  there's also a little widget
-  that goes along with this so that the user can control whether
-  or not the gadget code can steal their clicks
  - Added 'teamcolors.lua' to the installers
  - Renamed 'gui.lua' to 'luaui.lua'
  - Removed LuaCob, and redirected Cob2Lua calls to LuaRules
@@ -158,112 +191,112 @@
     LUA_COMPAT_OPENLIB
  - Moved most of the LuaUI call-outs into LuaUnsyncedRead
    and LuaUnsyncedCtrl. The LuaUnsyncedCtrl call-outs require
-   that the modUICtrl variable be enabled for non-user scripts
+   that the modUICtrl variable be enabled for gadget scripts
    to use them.
  - Moved most of the LuaUI call-ins into LuaCallInHandler and
    LuaHandle. The moved call-ins require that the modUICtrl
-   variable be enabled for non-user scripts to receive them.
- - Added UnitEnteredWater(unitID, unitDefID, unitTeam) call-in
- - Added UnitEnteredAir(unitID, unitDefID, unitTeam) call-in
- - Added UnitLeftWater(unitID, unitDefID, unitTeam) call-in
- - Added UnitLeftAir(unitID, unitDefID, unitTeam) call-in
- - Added the new call-ins:
+   variable be enabled for gadget scripts to receive them.
+ - Updated included gadgetHandler
+ - Removed unwanted/confusing widgets.
+ - fonts.lua can load fonts from the VFS
+   (and will create LuaUI/Fonts/ if it does not exist)
+ - Removed the unused CommandDesc 'hotkey' member
+ - Renamed CommandDescription's  'onlyKey'  to  'hidden'
+ - lua scripts now get first crack at all mouse events
+ - Treat SDD file sizes as dynamic, so that lua scripts can
+   be reloaded while dev'ing without having file size mismatches
+   (LuaRules, LuaGaia, mod widgets, etc...)
+ - Added some new constants to the lua Game{} table.
+ - Added the dynamic HeightMapTexture
+  - FLOAT32/LUMINANCE format, NEAREST/NEAREST filtering
+  - can be accessed by lua scripts using '$heightmap'
+  - can be disable by clients with 'HeightMapTex=0' (config parameter)
+ - Added multiple new callins:
+   - UnitEnteredWater(unitID, unitDefID, unitTeam)
+   - UnitEnteredAir(unitID, unitDefID, unitTeam)
+   - UnitLeftWater(unitID, unitDefID, unitTeam)
+   - UnitLeftAir(unitID, unitDefID, unitTeam)
    - PlayerChanged(playerID)  (player changed team or spectating state)
    - TeamChanged(teamID)      (team changed allyteam, not useful yet)
-   - UnitCommand(unitID, unitDefID, unitTeam, cmdID, cmdOpts, cmdParams)
-     (note that cmdOpts is a number)
+   - UnitCommand(unitID, unitDefID, unitTeam, cmdID, cmdOpts, cmdParams) (note that cmdOpts is a number)
+   - UnitMoveFailed()
+   - MoveCtrlNotify(unitID, unitDefID, unitTeam, data)
+     - currently called with data = 1 if the unit hits the ground and stops
+     - return true to disable the unit's MoveCtrl
+   - ProjectileCreated(projectileID, projectileOwnerID) (arg #2 is -1 if no owner)
+   - ProjectileDestroyed(projectileID)
+   - GamePreload() (Called at the end of the loading process)
+   - GameStart()   (Called when the game is about to start)
+   - TerraformComplete(UnitID, UnitDefID, UnitTeam, BuildUnitID, BuildUnitDefID, BuildUnitTeam)
+     (it gets called after the terraforming for a construction is complete (once
+      per terraforming builder), the return value is whether the con should stop
+      building.)
+   - DrawGenesis()
+     - called immediately following Update()
+     - called even when the game window is minimized
+     - modelview and projection matrices are identities
+     - can be used to update GPU-side physics simulation
+     textures and custom per-unit textures
+   - a real ViewResize() call-in
+ - Added the unicode values to the lua KeyPress() and KeyRelease() call-ins
+ - Replaced Spring.GetMouseMiniMapState() with:
+    Spring.GetMiniMapGeometry() -&gt;
+      posX, posY, sizeX, sizeY, minimized, maximized, &lt;false | &quot;left&quot; | &quot;right&quot;&gt;
+ - Changed the GetUnitNearestEnemy() lua call-out to:
+               GetUnitNearestEnemy(number unitID[, number range[, boolean useLos=true]])
+ - Added geometry shader support to LuaOpenGL
  - Added Spring.ValidUnitID(number id)    -&gt; boolean
  - Added Spring.ValidFeatureID(number id) -&gt; boolean
- - Added a real ViewResize() call-in
+ - Added Spring.GetUnitIsDead()
  - Added Spring.GetModUICtrl()
  - Added Spring.GetViewGeometry()   -&gt; sizeX, sizeY, posX, posY
  - Added Spring.GetWindowGeometry() -&gt; sizeX, sizeY, posX, posY
  - Added Spring.GetScreenGeometry() -&gt; sizeX, sizeY, posX, posY
- - Modified Spring.GetVisibleUnits() so that the team specifier can
-   use the ALL_UNITS, ALLY_UNITS, ENEMY_UNITS, and MY_UNITS values.
- - Replaced Spring.GetMouseMiniMapState() with:
-    Spring.GetMiniMapGeometry() -&gt;
-      posX, posY, sizeX, sizeY, minimized, maximized, &lt;false | &quot;left&quot; | &quot;right&quot;&gt;
  - Added Spring.IsAboveMiniMap(x, y) -&gt; boolean
- - Added LuaSyncedRead Spring.GetUnitLastAttacker()
- - Added LuaSyncedRead Spring.GetUnitFuel()
- - Added LuaSyncedCtrl Spring.SetUnitFuel()
- - Added LuaSyncedRead Spring.GetUnitSensorRadius(unitID, &lt;type&gt;)
- - Added LuaSyncedCtrl Spring.SetUnitSensorRadius(unitID, &lt;type&gt;, radius)
- - lua unit 'facing' parameters can now use long strings:
-    'north', 'south', 'east', 'west'
- - the Spring.UnitCreated() call-out now accepts unitDef names and unitDef IDs
- - Added the UnitMoveFailed() call-in
- - new call-ins:
-     ProjectileCreated(projectileID, projectileOwnerID) (arg #2 is -1 if no owner)
-     ProjectileDestroyed(projectileID)
- - new call-outs:
-     GetProjectilePosition(projectileID) -&gt; px, py, pz
-     GetProjectileVelocity(projectileID) -&gt; vx, vy, vz
-     SetProjectilePosition(projectileID, px, py, pz) -&gt; nil
-     SetProjectileVelocity(projectileID, vx, vy, vz) -&gt; nil
-     SetProjectileDetonate(projectileID) -&gt; nil
+ - Added Spring.GetUnitLastAttacker()
+ - Added Spring.GetUnitFuel()
+ - Added Spring.SetUnitFuel()
+ - Added Spring.GetUnitSensorRadius(unitID, &lt;type&gt;)
+ - Added Spring.SetUnitSensorRadius(unitID, &lt;type&gt;, radius)
+ - new projectile call-outs:
+     Spring.GetProjectilePosition(projectileID) -&gt; px, py, pz
+     Spring.GetProjectileVelocity(projectileID) -&gt; vx, vy, vz
+     Spring.SetProjectilePosition(projectileID, px, py, pz) -&gt; nil
+     Spring.SetProjectileVelocity(projectileID, vx, vy, vz) -&gt; nil
+     Spring.SetProjectileDetonate(projectileID) -&gt; nil
  - added the GL evaluator functions to the lua GL interface
    (note the gl.EvalEnable() and gl.EvalDisable() can only be
    called in a gl.Eval(func) block).
- - Removed the unused CommandDesc 'hotkey' member
- - Renamed CommandDescription's  onlyKey  to  hidden
- - lua scripts now get first crack at all mouse events
- - Treat SDD file sizes as dynamic, so that lua scripts can
-   be reloaded while dev'ing without having file size mismatches
-   (LuaRules, LuaGaia, mod widgets, etc...)
- - Added the Spring.GetUnitIsDead() call-out
- - Added 2 new lua callins:
-   - GamePreload: Called at the end of the loading process
-   - GameStart:   Called when the game is about to start
- - Added the unicode values to the lua KeyPress() and KeyRelease() call-ins
- - Changed the GetUnitNearestEnemy() lua call-out to:
-               GetUnitNearestEnemy(number unitID[, number range[, boolean useLos=true]])
- - Added two Lua synced callouts for controlling the collision volume properties:
-   SetUnitCollisionVolumeData(id, xs, ys, zs, xo, yo, zo, vtype, ptype, paxis)
-   and SetFeatureCollisionVolumeData() (same args)
- - Added new luaRules callin:
-   TerraformComplete(UnitID, UnitDefID, UnitTeam, BuildUnitID, BuildUnitDefID, BuildUnitTeam)
-   it gets called after the terraforming for a construction is complete (once
-   per terraforming builder), the return value is whether the con should stop
-   building.
+ - Added Spring.SetUnitCollisionVolumeData(id, xs, ys, zs, xo, yo, zo, vtype, ptype, paxis)
+     and Spring.SetFeatureCollisionVolumeData() (same args)
  - Added Spring.SetLastMessagePosition(x,y,z)
- - Added new LuaRules  MoveCtrlNotify(unitID, unitDefID, unitTeam, data)  call-in
-  - currently called with data = 1 if the unit hits the ground and stops
-  - return true to disable the unit's MoveCtrl
- - Added the dynamic HeightMapTexture
-  - FLOAT32/LUMINANCE format, NEAREST/NEAREST filtering
-  - can be accessed by lua scripts using '$heightmap'
-  - can be disable by clients with 'HeightMapTex=0' (config parameter)
- - Added the following LuaSyncedCtrl call-outs:
-    - SetUnitLosMask(unitID, allyTeamID, number | table) -&gt; nil
-    - SetUnitLosState(unitID, allyTeamID, number | table) -&gt; nil
- - Added Spring.FixedAllies() -&gt; bool
- - Reverted the GetPositionLosState() to its original configuration (no air los),
-  (and made it faster)
- - Added the  IsPosInLos()    call-out
- - Added the  IsPosInRadar()  call-out
- - Added the  IsPosInAirLos() call-out
- - New PauseSoundStream(), GetSoundStreamTime() (how long it has been playing, 
-   SetSoundStreamVolume(number) call-outs
- - Added burst, burstRate and projectiles to SetUnitWeaponState
- - Added the DrawGenesis() call-in
-   - called immediately following Update()
-   - called even when the game window is minimized
-   - modelview and projection matrices are identities
-   - can be used to update GPU-side physics simulation
-    textures and custom per-unit textures
- - Updated included gadgetHandler
- - fonts.lua can load fonts from the VFS
-   (and will create LuaUI/Fonts/ if it does not exist)
- - added the following LuaUnsyncedCtrl call-outs:
-    AddUnitIcon(string name, string texture
-                [, number size[, number distance[, bool radiusAdjust]]])
-    FreeUnitIcon(string name)
- - Added gl.ActiveShader(shaderID, function(), ...)
-   - safe way to set shader uniforms in non-drawing code
- - Added the  gl.DepthClamp(bool)      call-out  (not always available)
- - Added the  gl.UnsafeState(number, [bool reverse, ] function, ...)  call-out
+ - Added Spring.SetUnitLosMask(unitID, allyTeamID, number | table) -&gt; nil
+     and Spring.SetUnitLosState(unitID, allyTeamID, number | table) -&gt; nil
+ - Added Spring.FixedAllies()
+ - Reverted the GetPositionLosState() to its original configuration (no air los)
+ - Added Spring.IsPosInLos()
+ - Added Spring.IsPosInRadar()
+ - Added Spring.IsPosInAirLos()
+ - Added Spring.PauseSoundStream(), Spring.GetSoundStreamTime(),
+         Spring.SetSoundStreamVolume(number)
+ - Added burst, burstRate and projectiles to Spring.SetUnitWeaponState
+ - Added Spring.AddUnitIcon(string name, string texture
+                            [, number size[, number distance[, bool radiusAdjust]]])
+         Spring.FreeUnitIcon(string name)
+ - Added Spring.SetUnitSonarStealth()
+ - Added Spring.SpawnCEG(tag, px, py, pz, dx, dy, dz, rad, dmg) synced callout
+ - Added Spring.SetHeightMapFunc(lua_func,arg1,arg2,..),
+         Spring.AddHeightMap(x, y, h) -&gt; `final height`
+         Spring.SetHeightMap(x, y, h [,t]) -&gt; `absolute value changed`
+ - Added Spring.ExtractModArchiveFile(path) callout
+   For example, Spring.ExtractModArchiveFile(&quot;sounds/boom.wav&quot;)
+   will create a directory &quot;sounds/&quot; and extract &quot;boom.wav&quot; to it.
+ - Added Spring.GetUnitPiecePosDir(unitID, piece) -&gt; posx,posy,posz, dirx,diry,dirz
+ - Added Spring.GetUnitVectors(unitID) -&gt; {front_x,front_y,front_z},{up_x,up_y,up_z},{right_x,right_y,right_z}
+ - Added Spring.GetUnitWeaponVectors(unitID,weaponNum) -&gt; wpos_x,wpos_y,wpos_z, wdir_x,wdir_y,wdir_z
+ - Added gl.ActiveShader(shaderID, function(), ...) (safe way to set shader uniforms in non-drawing code)
+ - Added gl.DepthClamp(bool)  (not always available)
+ - Added gl.UnsafeState(number, [bool reverse, ] function, ...)
    (glEnable() / glDisable() for unknown states; considered 'unsafe')
  - Added Occlusion Queries:
    - Added gl.CreateQuery() -&gt; query
@@ -275,7 +308,6 @@
    - Spring.GetUnitNoDraw()  
    - Spring.GetUnitNoMinimap()
    - Spring.GetUnitNoSelect()
- - Added geometry shader support to LuaOpenGL
  - Added the fbo 'readbuffer' parameter
  - Added gl.ReadPixels(x, y, w, h [,format])
  - Added StencilTests:
@@ -289,11 +321,11 @@
    - Added gl.StencilMaskSeparate()
    - Added gl.StencilFuncSeparate()
    - Added gl.StencilOpSeparate()
- - Added  gl.BlendEquation()
- - Added  gl.BlendEquationSeparate()
- - Added  gl.BlendFunc()  -- redundant
- - Added  gl.BlendFuncSeparate()
- - Added  gl.Blending() convenience names:
+ - Added gl.BlendEquation()
+ - Added gl.BlendEquationSeparate()
+ - Added gl.BlendFunc()  -- redundant
+ - Added gl.BlendFuncSeparate()
+ - Added gl.Blending() convenience names:
     name           blend_src    blend_dst             enabled
     &quot;add&quot;          ONE          ONE                   true
     &quot;add_alpha&quot;    SRC_ALPHA    ONE                   true
@@ -310,30 +342,14 @@
      gl.PushName()
      gl.PopName()
      gl.LoadName()
- - Added GL evaluator functions to the lua GL interface.
- - If Spring.SetDrawSky(false) is set, do not draw the sun.
+ - Added gl.Texture($shading) &amp; gl.Texture($grass)
+ - Allowed to use gl.CopyToTexture with non GL_TEXTURE2D, i.e. GL_TEXTURE_RECTANGLE
+ - Modified Spring.GetVisibleUnits() so that the team specifier can
+   use the ALL_UNITS, ALLY_UNITS, ENEMY_UNITS, and MY_UNITS values.
+ - 'facing' parameters can now use long strings: 'north', 'south', 'east', 'west'
+ - Spring.UnitCreated() call-out now accepts unitDef names and unitDef IDs
  - Spring.SendCommands() can use a bunch of string arguments as well as the old
    table format. e.g Spring.SendCommands('echo aoeu', 'info 2', 'specteam 0')
- - Added some new constants to the lua Game{} table.
- - Added gl.ActiveShader(shaderID, function(), ...) safe way to set shader 
-   uniforms in non-drawing code
- - Added the Spring.SetUnitSonarStealth() lua call-out
- - Added SpawnCEG(tag, px, py, pz, dx, dy, dz, rad, dmg) synced callout
- - Added Spring.SetHeightMapFunc(lua_func,arg1,arg2,..),
-     Spring.AddHeightMap(x, y, h) -&gt; `final height`
-     Spring.SetHeightMap(x, y, h [,t]) -&gt; `absolute value changed`
- - Added an unsynced ExtractModArchiveFile(path) callout to enable LuaUI
-   widgets to extract files from mod archives.
-   For example, Spring.ExtractModArchiveFile(&quot;sounds/boom.wav&quot;)
-   will create a directory &quot;sounds/&quot; and extract &quot;boom.wav&quot; to it.
- - Added SyncedRead call-out GetUnitPiecePosDir(unitID, piece), this returns
-   the global position and forward vector of the given piece (6 return values
-   in total). The emphasis is on global, the previous call-outs only deliver 
-   relative values.
- - Added Spring.GetUnitVectors(unitID) -&gt; {front_x,front_y,front_z},{up_x,up_y,up_z},{right_x,right_y,right_z}
- - Added Spring.GetUnitWeaponVectors(unitID,weaponNum) -&gt; wpos_x,wpos_y,wpos_z, wdir_x,wdir_y,wdir_z
- - Added gl.Texture($shading) &amp; gl.Texture($grass)
- - Allowed to use gl.CopyToTexture with non GL_TEXTURE2D, i.e. GL_TEXTURE_RECTANGLE
  - Fixed Spring.UnitRendering interface to make it possible to emulate the default 3do/s3o shaders
    - fixed $shadows texture params (you can now use shadow2DProj() in glsl)
    - fixed wrong (!=0) check if uniform locations are set (they begin with 0!)
@@ -348,8 +364,8 @@
  - Fixed full-view spectators get all LuaUI  RecvLuaMsg()  messages now.
  - Fixed Spring.SetFeaturePosition().
  - Fixed Spring.SetFeatureDirection().
+ - If Spring.SetDrawSky(false) is set, do not draw the sun.
  - Fixed s3o recognition in LuaUnitDefs
- - Removed unwanted/confusing widgets.
 
 AI:
  - Added new ai value AIVAL_SCRIPT returning start script text.

Modified: branches/caiinterface/Documentation/releasechecklist.txt
===================================================================
--- branches/caiinterface/Documentation/releasechecklist.txt	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/Documentation/releasechecklist.txt	2008-10-09 18:55:21 UTC (rev 6639)
@@ -11,8 +11,8 @@
 - test source package windows (ditto)
 - test installer (NEVER EVER SKIP THIS NO MATTER HOW SMALL THE CHANGES)
 - upload installer to fnord.clan-sy.com
-- upload installer to unknown files (watch out for notification bots, it can
-  create chaos if you upload early in release process and the upload gets
+- upload installer to the big Spring file sites (watch out for notification bots,
+  it can create chaos if you upload early in release process and the upload gets
   widely announced already.)
 - upload spring_X.XXbX_src.tar.bz2 to fnord.clan-sy.com
 - upload spring_X.XXbX_src.zip to fnord.clan-sy.com
@@ -24,12 +24,11 @@
 - enable automatic builds in buildbot again
 
 TASServer (when only spring update):
-- NOTE: this section is still &quot;untested&quot;
 - update updates.xml with OFFERFILE entries for current Spring version.
 - as admin, do &quot;reloadupdateproperties&quot; in TASServer ($Local in TASClient)
 - as admin, do &quot;setlatestspringversion 0.76b1&quot;  (replace version!)
 - as admin, &quot;broadcast&quot; a message that everyone will be kicked due to upgrade
-- as admin, kick all users from the server (I forgot the command for this)
+- as admin, kick all users from the server (&quot;killall [reason]&quot;)
 - set correct Spring version in the shell script that starts server, so it
   won't boot people if it ever gets restarted (e.g. power outage)
 

Modified: branches/caiinterface/installer/freedesktop/applications/spring.desktop
===================================================================
--- branches/caiinterface/installer/freedesktop/applications/spring.desktop	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/installer/freedesktop/applications/spring.desktop	2008-10-09 18:55:21 UTC (rev 6639)
@@ -9,3 +9,4 @@
 Terminal=false
 Type=Application
 Categories=Application;Game;StrategyGame;
+NoDisplay=true

Modified: branches/caiinterface/installer/freedesktop/mime/spring.xml
===================================================================
--- branches/caiinterface/installer/freedesktop/mime/spring.xml	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/installer/freedesktop/mime/spring.xml	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,5 +1,5 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;mime-info xmlns=&quot;<A HREF="http://www.freedesktop.org/standards/shared-mime-info">http://www.freedesktop.org/standards/shared-mime-info</A>&quot;&gt;
+	&lt;mime-info xmlns=&quot;<A HREF="http://www.freedesktop.org/standards/shared-mime-info">http://www.freedesktop.org/standards/shared-mime-info</A>&quot;&gt;
 	&lt;mime-type type=&quot;application/x-spring-demo&quot;&gt;
 		&lt;comment&gt;Spring demofile&lt;/comment&gt;
 		&lt;glob pattern=&quot;*.sdf&quot;/&gt;
@@ -7,9 +7,17 @@
 			&lt;match value=&quot;spring demofile&quot; type=&quot;string&quot; offset=&quot;0:16&quot;/&gt;
 		&lt;/magic&gt;
 	&lt;/mime-type&gt;
-	&lt;mime-type type=&quot;application/x-spring-data&quot;&gt;
-		&lt;comment&gt;Spring data file (map or mod)&lt;/comment&gt;
+
+	&lt;mime-type type=&quot;application/x-spring-sdz&quot;&gt;
+		&lt;sub-class-of type=&quot;application/zip&quot;/&gt;
+		&lt;comment&gt;Spring Archive&lt;/comment&gt;
 		&lt;glob pattern=&quot;*.sdz&quot;/&gt;
+	&lt;/mime-type&gt;
+
+	&lt;mime-type type=&quot;application/x-spring-sd7&quot;&gt;
+		&lt;sub-class-of type=&quot;application/x-7z-compressed&quot;/&gt;
+		&lt;comment&gt;Spring Archive&lt;/comment&gt;
 		&lt;glob pattern=&quot;*.sd7&quot;/&gt;
-		&lt;/mime-type&gt;
+	&lt;/mime-type&gt;
+
 &lt;/mime-info&gt;

Modified: branches/caiinterface/installer/make_source_package.sh
===================================================================
--- branches/caiinterface/installer/make_source_package.sh	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/installer/make_source_package.sh	2008-10-09 18:55:21 UTC (rev 6639)
@@ -67,9 +67,9 @@
 cd lf
 /usr/bin/svn export .. &quot;$dir&quot; --native-eol LF
 [ -n &quot;$linux_exclude&quot; ] &amp;&amp; rm -rf $linux_exclude
-[ -n &quot;$tbz&quot; ] &amp;&amp; echo 'Creating .tar.bz2 archive' &amp;&amp; \
+[ -n &quot;$tbz&quot; ] &amp;&amp; echo &quot;Creating .tar.bz2 archive ($tbz)&quot; &amp;&amp; \
 	tar cfj &quot;../$tbz&quot; $include $linux_include
-[ -n &quot;$tgz&quot; ] &amp;&amp; echo 'Creating .tar.gz archive' &amp;&amp; \
+[ -n &quot;$tgz&quot; ] &amp;&amp; echo &quot;Creating .tar.gz archive ($tgz)&quot; &amp;&amp; \
 	tar cfz &quot;../$tgz&quot; $include $linux_include
 cd ..
 echo 'Cleaning'
@@ -81,9 +81,9 @@
 cd crlf
 /usr/bin/svn export .. &quot;$dir&quot; --native-eol CRLF
 [ -n &quot;$windows_exclude&quot; ] &amp;&amp; rm -rf $windows_exclude
-[ -n &quot;$zip&quot; ] &amp;&amp; [ -x /usr/bin/zip ] &amp;&amp; echo 'Creating .zip archive' &amp;&amp; \
+[ -n &quot;$zip&quot; ] &amp;&amp; [ -x /usr/bin/zip ] &amp;&amp; echo &quot;Creating .zip archive ($zip)&quot; &amp;&amp; \
 	/usr/bin/zip -q -r -u -9 &quot;../$zip&quot; $include $windows_include
-[ -n &quot;$seven_zip&quot; ] &amp;&amp; [ -x /usr/bin/7z ] &amp;&amp; echo 'Creating .7z archive' &amp;&amp; \
+[ -n &quot;$seven_zip&quot; ] &amp;&amp; [ -x /usr/bin/7z ] &amp;&amp; echo &quot;Creating .7z archive ($seven_zip)&quot; &amp;&amp; \
 	/usr/bin/7z a -t7z -m0=lzma -mx=9 -mfb=64 -md=32m -ms=on &quot;../$seven_zip&quot; $include &gt;/dev/null
 cd ..
 echo 'Cleaning'

Modified: branches/caiinterface/installer/sections/shortcuts.nsh
===================================================================
--- branches/caiinterface/installer/sections/shortcuts.nsh	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/installer/sections/shortcuts.nsh	2008-10-09 18:55:21 UTC (rev 6639)
@@ -5,7 +5,7 @@
   CreateDirectory &quot;$SMPROGRAMS\${PRODUCT_NAME}&quot;
   ${If} ${SectionIsSelected} ${SEC_TASCLIENT}
     CreateDirectory &quot;$SMPROGRAMS\${PRODUCT_NAME}\Multiplayer&quot;
-    CreateShortCut &quot;$SMPROGRAMS\${PRODUCT_NAME}\Multiplayer\TASClient.lnk&quot; &quot;$INSTDIR\TASClient.exe -server 82.239.138.44:8300&quot;
+    CreateShortCut &quot;$SMPROGRAMS\${PRODUCT_NAME}\Multiplayer\TASClient.lnk&quot; &quot;$INSTDIR\TASClient.exe&quot;
   ${EndIf}
   ${If} ${SectionIsSelected} ${SEC_CA}
     CreateShortCut &quot;$SMPROGRAMS\${PRODUCT_NAME}\Update CA.lnk&quot; &quot;$INSTDIR\CaDownloader.exe&quot;

Modified: branches/caiinterface/installer/springsettings.nsh
===================================================================
--- branches/caiinterface/installer/springsettings.nsh	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/installer/springsettings.nsh	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,10 +1,10 @@
 !ifdef TEST_BUILD
  !define PRODUCT_NAME &quot;Spring - Test Build&quot;
- !define PRODUCT_VERSION &quot;0.76b1+svn${REVISION}&quot;
+ !define PRODUCT_VERSION &quot;0.77b2+svn${REVISION}&quot;
  !define SP_BASENAME &quot;spring_${PRODUCT_VERSION}&quot;
 !else
  !define PRODUCT_NAME &quot;Spring&quot;
- !define PRODUCT_VERSION &quot;0.76b1&quot;
+ !define PRODUCT_VERSION &quot;0.77b2&quot;
  !define SP_BASENAME &quot;spring_${PRODUCT_VERSION}&quot;
 !endif
 

Modified: branches/caiinterface/rts/Game/Camera/CameraController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/CameraController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/CameraController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -19,23 +19,26 @@
 
 	virtual const std::string GetName() const = 0;
 
-	virtual void KeyMove(float3 move)=0;
-	virtual void MouseMove(float3 move)=0;
-	virtual void ScreenEdgeMove(float3 move)=0;
-	virtual void MouseWheelMove(float move)=0;
+	virtual void KeyMove(float3 move) = 0;
+	virtual void MousePress(int x, int y, int button) = 0;
+	virtual void MouseRelease(int x, int y, int button) = 0;
+	virtual void MouseMove(float3 move) = 0;
+	virtual void ScreenEdgeMove(float3 move) = 0;
+	virtual void MouseWheelMove(float move) = 0;
 
 	virtual void Update() {}
 
-	virtual float3 GetPos()=0;
-	virtual float3 GetDir()=0;
+	virtual float3 GetPos() = 0;
+	virtual float3 GetDir() = 0;
 
 	float GetFOV() const { return fov; };
 
 	virtual void SetPos(const float3&amp; newPos) { pos = newPos; };
 	virtual bool DisableTrackingByKey() { return true; }
 
-	virtual float3 SwitchFrom() const =0;			//return pos that to send to new controllers SetPos
-	virtual void SwitchTo(bool showText=true)=0;
+	// return the position to send to new controllers SetPos
+	virtual float3 SwitchFrom() const = 0;
+	virtual void SwitchTo(bool showText = true) = 0;
 	
 	virtual void GetState(StateMap&amp; sm) const = 0;
 	virtual bool SetState(const StateMap&amp; sm) = 0;

Modified: branches/caiinterface/rts/Game/Camera/FPSController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/FPSController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/FPSController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -13,6 +13,8 @@
 	const std::string GetName() const { return &quot;fps&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/Camera/FreeController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/FreeController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/FreeController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -14,6 +14,8 @@
 	void Move(const float3&amp; move, bool tilt, bool strafe, bool upDown);
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/Camera/LuaCameraCtrl.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/LuaCameraCtrl.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/LuaCameraCtrl.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -12,6 +12,8 @@
 	const std::string GetName() const { return &quot;lua&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Copied: branches/caiinterface/rts/Game/Camera/OrbitController.cpp (from rev 6638, trunk/rts/Game/Camera/OrbitController.cpp)
===================================================================
--- branches/caiinterface/rts/Game/Camera/OrbitController.cpp	                        (rev 0)
+++ branches/caiinterface/rts/Game/Camera/OrbitController.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -0,0 +1,270 @@
+#include &quot;StdAfx.h&quot;
+
+#include &lt;SDL_mouse.h&gt;
+#include &lt;SDL_keysym.h&gt;
+
+#include &quot;OrbitController.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Game/UI/MouseHandler.h&quot;
+#include &quot;Map/Ground.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
+
+extern Uint8* keys;
+
+#define DEG2RAD(a) ((a) * (3.141592653f / 180.0f))
+#define RAD2DEG(a) ((a) * (180.0f / 3.141592653f))
+static const float3 YVEC(0.0f, 1.0f, 0.0f);
+
+COrbitController::COrbitController():
+	lastMousePressX(0), lastMousePressY(0),
+	lastMouseMoveX(0), lastMouseMoveY(0),
+	lastMouseButton(-1),
+	currentState(Orbiting),
+	distance(512.0f), cDistance(512.0f),
+	rotation(0.0f), cRotation(0.0f),
+	elevation(0.0f), cElevation(0.0f)
+{
+	enabled = !!configHandler.GetInt(&quot;OrbitControllerEnabled&quot;, 1);
+}
+
+void COrbitController::Init(const float3&amp; p, const float3&amp; tar)
+{
+	CCamera* cam = camera;
+
+	const float l = (tar == ZeroVector)?
+		std::max(ground-&gt;LineGroundCol(p, p + cam-&gt;forward * 1024.0f), 512.0f):
+		(p - tar).Length();
+
+	const float3 t = (tar == ZeroVector)? (p + cam-&gt;forward * l): tar;
+	const float3 v = (t - p);
+	const float3 w = (v / v.Length()); // do not normalize v in-place
+
+	const float d = v.Length();
+	const float e = RAD2DEG(acosf(v.Length2D() / d));
+	const float r = RAD2DEG(acosf(w.x));
+
+	distance  = cDistance = d;
+	elevation = cElevation = e;
+	rotation  = cRotation = (v.z &gt; 0.0f)? 180.0f + r: 180.0f - r;
+	cen       = t;
+}
+
+
+
+void COrbitController::Update()
+{
+	if (!keys[SDLK_LMETA]) {
+		return;
+	}
+
+	// can't use mouse-&gt;last{x, y}, since they
+	// have already been updated to the current
+	// pos at this point
+	int x = 0;
+	int y = 0;
+
+	SDL_GetMouseState(&amp;x, &amp;y);
+
+	const int pdx = lastMousePressX - x;
+	const int pdy = lastMousePressY - y;
+	const int rdx = lastMouseMoveX - x;
+	const int rdy = lastMouseMoveY - y;
+
+	lastMouseMoveX = x;
+	lastMouseMoveY = y;
+
+	MyMouseMove(pdx, pdy, rdx, rdy, lastMouseButton);
+}
+
+void COrbitController::KeyMove(float3 move)
+{
+}
+
+
+void COrbitController::MousePress(int x, int y, int button)
+{
+	lastMousePressX = x;
+	lastMousePressY = y;
+	lastMouseButton = button;
+	cDistance = distance;
+	cRotation = rotation;
+	cElevation = elevation;
+
+	switch (button) {
+		case SDL_BUTTON_LEFT: { currentState = Orbiting; } break;
+		case SDL_BUTTON_MIDDLE: { currentState = Panning; } break;
+		case SDL_BUTTON_RIGHT: { currentState = Zooming; } break;
+	}
+}
+
+void COrbitController::MouseRelease(int x, int y, int button)
+{
+	lastMousePressX = x;
+	lastMousePressY = y;
+	lastMouseButton = -1;
+	currentState = None;
+}
+
+
+void COrbitController::MouseMove(float3 move)
+{
+	// only triggers on SDL_BUTTON_MIDDLE (see CMouseHandler::MouseMove())
+}
+
+void COrbitController::MyMouseMove(int dx, int dy, int rdx, int rdy, int button)
+{
+	CCamera* cam = camera;
+
+	switch (button) {
+		case SDL_BUTTON_LEFT: {
+			rotation = cRotation - (dx * 0.25f);
+			elevation = cElevation - (dy * 0.25f);
+		} break;
+
+		case SDL_BUTTON_RIGHT: {
+			distance = cDistance - (dy * 0.5f * 10.0f);
+		} break;
+	}
+
+	if (elevation &gt;  89.0f) elevation =  89.0f;
+	if (elevation &lt; -89.0f) elevation = -89.0f;
+	if (distance  &lt;   1.0f) distance  =   1.0f;
+
+	switch (button) {
+		case SDL_BUTTON_LEFT: {
+			cam-&gt;pos = cen + GetOrbitPos();
+			cam-&gt;pos.y = std::max(cam-&gt;pos.y, ground-&gt;GetHeight2(cam-&gt;pos.x, cam-&gt;pos.z));
+			cam-&gt;forward = (cen - cam-&gt;pos).Normalize();
+			cam-&gt;up = YVEC;
+		} break;
+
+		case SDL_BUTTON_RIGHT: {
+			cam-&gt;pos = cen - (cam-&gt;forward * distance);
+		} break;
+
+		case SDL_BUTTON_MIDDLE: {
+			// horizontal pan
+			cam-&gt;pos += (cam-&gt;right * -rdx * 2);
+			cen += (cam-&gt;right * -rdx * 2);
+
+			// vertical pan
+			cam-&gt;pos += (cam-&gt;up * rdy * 2);
+			cen += (cam-&gt;up * rdy * 2);
+
+
+			// don't allow orbit center or ourselves to drop below the terrain
+			const float camGH = ground-&gt;GetHeight2(cam-&gt;pos.x, cam-&gt;pos.z);
+			const float cenGH = ground-&gt;GetHeight2(cen.x, cen.z);
+
+			if (cam-&gt;pos.y &lt; camGH) {
+				cam-&gt;pos.y = camGH;
+			}
+
+			if (cen.y &lt; cenGH) {
+				cen.y = cenGH;
+				cam-&gt;forward = (cen - cam-&gt;pos).Normalize();
+
+				Init(cam-&gt;pos, cen);
+			}
+		} break;
+	}
+}
+
+void COrbitController::ScreenEdgeMove(float3 move)
+{
+}
+
+void COrbitController::MouseWheelMove(float move)
+{
+}
+
+
+
+float3 COrbitController::GetPos()
+{
+	return camera-&gt;pos;
+}
+
+void COrbitController::SetPos(const float3&amp; newPos)
+{
+	if (keys[SDLK_LMETA]) {
+		return;
+	}
+
+	CCamera* cam = camera;
+
+	// support minimap position hopping
+	cen = newPos;
+	cen.y = ground-&gt;GetHeight2(cen.x, cen.z);
+	cam-&gt;pos = cen - (cam-&gt;forward * (cam-&gt;pos - cen).Length());
+
+	Init(cam-&gt;pos, cen);
+}
+
+float3 COrbitController::GetDir()
+{
+	return (cen - camera-&gt;pos).Normalize();
+}
+
+float3 COrbitController::GetOrbitPos() const
+{
+	const float beta = DEG2RAD(elevation);
+	const float gamma = DEG2RAD(rotation);
+
+	float cx = distance;
+	float cy = 0.0f;
+	float cz = 0.0f;
+	float tx = cx;
+
+	tx = cx;
+	cx = cx * cosf(beta) + cy * sinf(beta);
+	cy = tx * sinf(beta) + cy * cosf(beta);
+
+	tx = cx;
+	cx = cx * cosf(gamma) - cz * sinf(gamma);
+	cz = tx * sinf(gamma) + cz * cosf(gamma);
+
+	return float3(cx, cy, cz);
+}
+
+
+
+float3 COrbitController::SwitchFrom() const
+{
+	return camera-&gt;pos;
+}
+
+void COrbitController::SwitchTo(bool showText)
+{
+	if (showText) {
+		logOutput.Print(&quot;Switching to Orbit style camera&quot;);
+	}
+
+	Init(camera-&gt;pos, ZeroVector);
+}
+
+
+
+void COrbitController::GetState(StateMap&amp; sm) const
+{
+	sm[&quot;px&quot;] = camera-&gt;pos.x;
+	sm[&quot;py&quot;] = camera-&gt;pos.y;
+	sm[&quot;pz&quot;] = camera-&gt;pos.z;
+
+	sm[&quot;tx&quot;] = cen.x;
+	sm[&quot;ty&quot;] = cen.y;
+	sm[&quot;tz&quot;] = cen.z;
+}
+
+bool COrbitController::SetState(const StateMap&amp; sm)
+{
+	SetStateFloat(sm, &quot;px&quot;, camera-&gt;pos.x);
+	SetStateFloat(sm, &quot;py&quot;, camera-&gt;pos.y);
+	SetStateFloat(sm, &quot;pz&quot;, camera-&gt;pos.z);
+
+	SetStateFloat(sm, &quot;tx&quot;, cen.x);
+	SetStateFloat(sm, &quot;ty&quot;, cen.y);
+	SetStateFloat(sm, &quot;tz&quot;, cen.z);
+	return true;
+}

Copied: branches/caiinterface/rts/Game/Camera/OrbitController.h (from rev 6638, trunk/rts/Game/Camera/OrbitController.h)
===================================================================
--- branches/caiinterface/rts/Game/Camera/OrbitController.h	                        (rev 0)
+++ branches/caiinterface/rts/Game/Camera/OrbitController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -0,0 +1,51 @@
+#ifndef __ORBIT_CONTROLLER_H__
+#define __ORBIT_CONTROLLER_H__
+
+#include &quot;CameraController.h&quot;
+#include &quot;GlobalStuff.h&quot;
+
+class COrbitController: public CCameraController {
+	public:
+		COrbitController();
+
+		void Init(const float3&amp; p, const float3&amp; tar = ZeroVector);
+		void Update();
+
+		const std::string GetName() const { return &quot;OrbitController&quot;; }
+
+		void KeyMove(float3 move);
+		void MousePress(int, int, int);
+		void MouseRelease(int, int, int);
+		void MouseMove(float3 move);
+		void ScreenEdgeMove(float3 move);
+		void MouseWheelMove(float move);
+
+		float3 GetPos();
+		float3 GetDir();
+
+		void SetPos(const float3&amp; newPos);
+		float3 SwitchFrom() const;
+		void SwitchTo(bool showText);
+
+		void GetState(StateMap&amp; sm) const;
+		bool SetState(const StateMap&amp; sm);
+
+	private:
+		void MyMouseMove(int, int, int, int, int);
+		float3 GetOrbitPos() const;
+
+		int lastMouseMoveX;
+		int lastMouseMoveY;
+		int lastMousePressX; // x-coor of last button press
+		int lastMousePressY; // y-coor of last button-press
+		int lastMouseButton; // button that was last pressed
+		int currentState;
+		float distance, cDistance;
+		float rotation, cRotation;
+		float elevation, cElevation;
+		float3 cen;
+
+		enum States {None, Orbiting, Zooming, Panning};
+};
+
+#endif

Modified: branches/caiinterface/rts/Game/Camera/OverheadController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/OverheadController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/OverheadController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -12,6 +12,8 @@
 	const std::string GetName() const { return &quot;ta&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/Camera/OverviewController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/OverviewController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/OverviewController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -13,6 +13,8 @@
 	const std::string GetName() const { return &quot;ov&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/Camera/RotOverheadController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/RotOverheadController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/RotOverheadController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -13,6 +13,8 @@
 	const std::string GetName() const { return &quot;rot&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/Camera/SmoothController.cpp
===================================================================
--- branches/caiinterface/rts/Game/Camera/SmoothController.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/SmoothController.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -206,7 +206,7 @@
 void SmoothController::SwitchTo(bool showText)
 {
 	if(showText)
-		logOutput.Print(&quot;Switching to smooth camera&quot;);
+		logOutput.Print(&quot;Switching to Smooth style camera&quot;);
 }
 
 

Modified: branches/caiinterface/rts/Game/Camera/SmoothController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/SmoothController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/SmoothController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -17,6 +17,8 @@
 	const std::string GetName() const { return &quot;sm&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/Camera/TWController.h
===================================================================
--- branches/caiinterface/rts/Game/Camera/TWController.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Camera/TWController.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -12,6 +12,8 @@
 	const std::string GetName() const { return &quot;tw&quot;; }
 
 	void KeyMove(float3 move);
+	void MousePress(int, int, int) { /* empty */ }
+	void MouseRelease(int, int, int) { /* empty */ }
 	void MouseMove(float3 move);
 	void ScreenEdgeMove(float3 move);
 	void MouseWheelMove(float move);

Modified: branches/caiinterface/rts/Game/CameraHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/CameraHandler.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/CameraHandler.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -15,6 +15,7 @@
 #include &quot;Game/Camera/FreeController.h&quot;
 #include &quot;Game/Camera/OverviewController.h&quot;
 #include &quot;Game/Camera/TWController.h&quot;
+#include &quot;Game/Camera/OrbitController.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;GlobalStuff.h&quot;
@@ -37,6 +38,7 @@
 	camCtrls.push_back(new CFreeController());        // 4
 	camCtrls.push_back(new SmoothController());       // 5
 	camCtrls.push_back(new COverviewController());    // 6
+	camCtrls.push_back(new COrbitController());       // 7
 
 	for (unsigned int i = 0; i &lt; camCtrls.size(); i++) {
 		nameMap[camCtrls[i]-&gt;GetName()] = i;
@@ -65,6 +67,7 @@
 	RegisterAction(&quot;viewfree&quot;);
 	RegisterAction(&quot;viewov&quot;);
 	RegisterAction(&quot;viewlua&quot;);
+	RegisterAction(&quot;vieworbit&quot;);
 
 	RegisterAction(&quot;viewtaflip&quot;);
 
@@ -296,6 +299,7 @@
 void CCameraHandler::PushAction(const Action&amp; action)
 {
 	const std::string cmd = action.command;
+
 	if (cmd == &quot;viewfps&quot;) {
 		SetCameraMode(0);
 	}
@@ -317,6 +321,10 @@
 	else if (cmd == &quot;viewlua&quot;) {
 		SetCameraMode(6);
 	}
+	else if (cmd == &quot;vieworbit&quot;) {
+		SetCameraMode(7);
+	}
+
 	else if (cmd == &quot;viewtaflip&quot;) {
 		COverheadController* taCam =
 				dynamic_cast&lt;COverheadController*&gt;(camControllers[1]);

Modified: branches/caiinterface/rts/Game/GameServer.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameServer.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/GameServer.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -780,6 +780,7 @@
 							teams[fromTeam].reset();
 						}
 						players[player]-&gt;team = 0;
+						players[player]-&gt;spectator = true;
 						break;
 					}
 					case TEAMMSG_GIVEAWAY: {
@@ -790,11 +791,13 @@
 							teams[fromTeam].reset();
 						}
 						players[player]-&gt;team = 0;
+						players[player]-&gt;spectator = true;
 						break;
 					}
 					case TEAMMSG_RESIGN: {
 						Broadcast(CBaseNetProtocol::Get().SendResign(player));
 						players[player]-&gt;team = 0;
+						players[player]-&gt;spectator = true;
 						break;
 					}
 					case TEAMMSG_JOIN_TEAM: {
@@ -826,6 +829,7 @@
 								if (players[i] &amp;&amp; players[i]-&gt;team == team)
 								{
 									players[i]-&gt;team = 0;
+									players[player]-&gt;spectator = true;
 								}
 							}
 						}

Modified: branches/caiinterface/rts/Game/GameVersion.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameVersion.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/GameVersion.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -7,4 +7,4 @@
 #include &quot;GameVersion.h&quot;
 
 /** The game version. */
-const char* const VERSION_STRING = &quot;0.76b1+&quot;;
+const char* const VERSION_STRING = &quot;0.77b2+&quot;;

Modified: branches/caiinterface/rts/Game/Player.cpp
===================================================================
--- branches/caiinterface/rts/Game/Player.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Player.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -117,7 +117,7 @@
 
 void CPlayer::UpdateControlledTeams()
 {
-	for (int p = 0; p &lt; gs-&gt;activeTeams; p++) {
+	for (int p = 0; p &lt; gs-&gt;activePlayers; p++) {
 		CPlayer* player = gs-&gt;players[p];
 		if (player) {
 			player-&gt;SetControlledTeams();

Modified: branches/caiinterface/rts/Game/Team.cpp
===================================================================
--- branches/caiinterface/rts/Game/Team.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/Team.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -252,9 +252,11 @@
 		energy = 0;
 	}
 	
-	for (CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui) {
+	for (CUnitSet::iterator ui = units.begin(); ui != units.end(); ) {
 		// must pass the normal checks, isDead, unit count restrictions, luaRules, etc...
+		CUnitSet::iterator next = ui; ++next;
 		(*ui)-&gt;ChangeTeam(toTeam, CUnit::ChangeGiven);
+		ui = next;
 	}
 
 	Died();

Modified: branches/caiinterface/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -205,6 +205,8 @@
 	if (button &gt; NUM_BUTTONS)
 		return;
 
+	camHandler-&gt;GetCurrentController().MousePress(x, y, button);
+
 	dir = hide? camera-&gt;forward: camera-&gt;CalcPixelDir(x, y);
 
 	if (!game-&gt;gameOver)
@@ -288,6 +290,8 @@
 	if (button &gt; NUM_BUTTONS)
 		return;
 
+	camHandler-&gt;GetCurrentController().MouseRelease(x, y, button);
+
 	dir = hide ? camera-&gt;forward: camera-&gt;CalcPixelDir(x, y);
 	buttons[button].pressed = false;
 

Modified: branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -190,10 +190,8 @@
 
 	CVertexArray *va = GetVertexArray();
 	va-&gt;Initialize();
-	va-&gt;CheckInitSize(4*34*2*VA_SIZE_0);
 
 	const float alphainc = fastmath::PI2 / 32;
-	const float alphaincpi2 = alphainc + fastmath::PI2;	
 	float alpha,r1,r2;
 	float3 p(0.0f,0.0f,0.0f);
 	const float size = std::min(xsize,ysize);
@@ -204,13 +202,13 @@
 		}else{
 			r2 = (n+1)*(n+1) * size;
 		}
-		for (alpha = 0.0f; alpha &lt; alphaincpi2 ; alpha+=alphainc) {
+		for (alpha = 0.0f; (alpha - fastmath::PI2) &lt; alphainc ; alpha+=alphainc) {
 			p.x = r1 * fastmath::sin(alpha) + 2 * xsize;
 			p.z = r1 * fastmath::cos(alpha) + 2 * ysize;
-			va-&gt;AddVertexQ0(p.x,p.y,p.z);
+			va-&gt;AddVertex0(p);
 			p.x = r2 * fastmath::sin(alpha) + 2 * xsize;
 			p.z = r2 * fastmath::cos(alpha) + 2 * ysize;
-			va-&gt;AddVertexQ0(p.x,p.y,p.z);
+			va-&gt;AddVertex0(p);
 		}
 	}
 
@@ -812,8 +810,8 @@
 		int xmax = min(x2 + 10*2,gs-&gt;mapx);
 		int ymin = max(y1 - 10*2,0);
 		int ymax = min(y2 + 10*2,gs-&gt;mapy);
-		//int xsize = xmax - xmin;
-		//int ysize = ymax - ymin;
+		int xsize = xmax - xmin;
+		int ysize = ymax - ymin;
 
 		glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
 		glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
@@ -902,37 +900,29 @@
 
 	glViewport(0,0, normalTextureX, normalTextureY);
 	glMatrixMode(GL_MODELVIEW);
-	glPushMatrix();
-	glLoadIdentity();
+		glPushMatrix();
+		glLoadIdentity();
 	glMatrixMode(GL_PROJECTION);
-	glPushMatrix();
-	glLoadIdentity();
-	glOrtho(0,1,0,1,-1,1);
+		glPushMatrix();
+		glLoadIdentity();
+		glOrtho(0,1,0,1,-1,1);
 	glMatrixMode(GL_TEXTURE);
-	glPushMatrix();
-	glLoadIdentity();
+		glPushMatrix();
+		glLoadIdentity();
 
 	glBegin(GL_QUADS);
-	unsigned char offset,tx,ty;
-	unsigned char *to=tileOffsets;
-	unsigned char yts=0;
-	for (unsigned char y=0; y&lt;tiles; ++y) {
-		unsigned char yts1=yts+tilesize;
-		unsigned char xts=0;
-		for (unsigned char x=0; x&lt;tiles; ++x) {
-			unsigned char xts1=xts+tilesize;
-			offset = *to++;
-			tx = offset % tiles;
-			ty = ((offset - tx)/tiles)*tilesize;
-			tx*=tilesize;
-			glTexCoord2f(tx,          ty         ); glVertex2f(xts,  yts );
-			glTexCoord2f(tx,          ty+tilesize); glVertex2f(xts,  yts1);
-			glTexCoord2f(tx+tilesize, ty+tilesize); glVertex2f(xts1, yts1);
-			glTexCoord2f(tx+tilesize, ty         ); glVertex2f(xts1, yts );
-			xts=xts1;
+		unsigned char offset,tx,ty;
+		for (unsigned char y=0; y&lt;tiles; ++y) {
+			for (unsigned char x=0; x&lt;tiles; ++x) {
+				offset = tileOffsets[y * tiles + x];
+				tx = offset % tiles;
+				ty = (offset - tx)/tiles;
+				glTexCoord2f(     tx * tilesize,     ty * tilesize ); glVertex2f(     x * tilesize,     y * tilesize );
+				glTexCoord2f(     tx * tilesize, (ty+1) * tilesize ); glVertex2f(     x * tilesize, (y+1) * tilesize );
+				glTexCoord2f( (tx+1) * tilesize, (ty+1) * tilesize ); glVertex2f( (x+1) * tilesize, (y+1) * tilesize );
+				glTexCoord2f( (tx+1) * tilesize,     ty * tilesize ); glVertex2f( (x+1) * tilesize,     y * tilesize );
+			}
 		}
-		yts=yts1;
-	}
 	glEnd();
 
 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

Modified: branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -282,7 +282,6 @@
 	const float* hm = readmap-&gt;GetHeightmap();
 	const int gsmx = gs-&gt;mapx;
 	const int gsmx1 = gsmx + 1;
-	const int gsmx12 = (gs-&gt;mapx + 1) * 2;
 
 	unsigned char color[4] = {255, 255, 255, 255};
 

Modified: branches/caiinterface/rts/Sim/Misc/QuadField.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/QuadField.h	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Sim/Misc/QuadField.h	2008-10-09 18:55:21 UTC (rev 6639)
@@ -55,7 +55,7 @@
 		std::list&lt;CFeature*&gt; features;
 	};
 
-	const Quad&amp; GetQuad(int i) const { return baseQuads[i]; }
+	const Quad&amp; GetQuad(int i) const { assert(static_cast&lt;unsigned&gt;(i) &lt; baseQuads.size()); return baseQuads[i]; }
 	const Quad&amp; GetQuadAt(int x, int z) const { return baseQuads[numQuadsX * z + x]; }
 	int GetNumQuadsX() const { return numQuadsX; }
 	int GetNumQuadsZ() const { return numQuadsZ; }

Modified: branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -301,8 +301,11 @@
 				if (sqDist &lt; totRad * totRad &amp;&amp; sqDist != 0) {
 					float dist = sqrt(sqDist);
 					float3 dif = pos - (*ui)-&gt;pos;
-					dif /= dist;
 
+					if (dist &gt; 0.0f) {
+						dif /= dist;
+					}
+
 					if ((*ui)-&gt;immobile) {
 						pos -= dif * (dist - totRad);
 						owner-&gt;UpdateMidPos();

Modified: branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -593,33 +593,37 @@
 	}
 
 	float yspeed = speed.y;
-	speed.y = 0;
+	speed.y = 0.0f;
 
 	float3 delta = wantedSpeed - speed;
 	float dl = delta.Length();
 
-	if (delta.dot(speed) &gt; 0) {
+	if (delta.dot(speed) &gt; 0.0f) {
 		// accelerate
 		if (dl &lt; accRate) {
 			speed = wantedSpeed;
 		} else {
-			speed += delta / dl * accRate;
+			if (dl &gt; 0.0f) {
+				speed += delta / dl * accRate;
+			}
 		}
 	} else {
 		// break
 		if (dl &lt; decRate) {
 			speed = wantedSpeed;
 		} else {
-			speed += delta / dl * decRate;
+			if (dl &gt; 0.0f) {
+				speed += delta / dl * decRate;
+			}
 		}
 	}
 
 	speed.y = yspeed;
 	float h = pos.y - std::max(
 		ground-&gt;GetHeight(pos.x, pos.z),
-		ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40));
+		ground-&gt;GetHeight(pos.x + speed.x * 40.0f, pos.z + speed.z * 40.0f));
 
-	if (h &lt; 4) {
+	if (h &lt; 4.0f) {
 		speed.x *= 0.95f;
 		speed.z *= 0.95f;
 	}
@@ -632,29 +636,31 @@
 
 		if (speed.dot(dir + sdir * 20.0f) &lt; 0.0f) {
 			if (lastColWarning-&gt;midPos.y &gt; owner-&gt;pos.y) {
-				wh -= 30;
+				wh -= 30.0f;
 			} else {
-				wh += 50;
+				wh += 50.0f;
 			}
 		}
 	}
 
-	float ws;
+
+	float ws = 0.0f;
+
 	if (h &lt; wh) {
 		ws = altitudeRate;
-		if (speed.y &gt; 0 &amp;&amp; (wh - h) / speed.y * accRate * 1.5f &lt; speed.y)
-			ws = 0;
+		if (speed.y &gt; 0.0f &amp;&amp; (wh - h) / speed.y * accRate * 1.5f &lt; speed.y)
+			ws = 0.0f;
 	} else {
 		ws = -altitudeRate;
-		if (speed.y &lt; 0 &amp;&amp; (wh - h) / speed.y * accRate * 0.7f &lt; -speed.y)
-			ws = 0;
+		if (speed.y &lt; 0.0f &amp;&amp; (wh - h) / speed.y * accRate * 0.7f &lt; -speed.y)
+			ws = 0.0f;
 	}
 
 	if (speed.y &gt; ws) {
 		speed.y = std::max(ws, speed.y - accRate * 1.5f);
 	} else {
 		// let them accelerate upward faster if close to ground
-		speed.y = std::min(ws, speed.y + accRate * (h &lt; 20? 2.0f: 0.7f));
+		speed.y = std::min(ws, speed.y + accRate * (h &lt; 20.0f? 2.0f: 0.7f));
 	}
 
 	pos += speed;
@@ -838,8 +844,11 @@
 				if (sqDist &lt; totRad * totRad &amp;&amp; sqDist != 0) {
 					float dist = sqrt(sqDist);
 					float3 dif = pos - (*ui)-&gt;pos;
-					dif /= dist;
 
+					if (dist &gt; 0.0f) {
+						dif /= dist;
+					}
+
 					if ((*ui)-&gt;mass &gt;= 100000 || (*ui)-&gt;immobile) {
 						pos -= dif * (dist - totRad);
 						owner-&gt;UpdateMidPos();

Modified: branches/caiinterface/rts/Sim/Weapons/LaserCannon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/LaserCannon.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Sim/Weapons/LaserCannon.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -53,7 +53,7 @@
 	}
 
 	float3 dir = pos - weaponMuzzlePos;
-	float length = dir.Length();
+	const float length = dir.Length();
 	if (length == 0)
 		return true;
 
@@ -66,7 +66,7 @@
 			return false;
 	}
 
-	float spread = (accuracy + sprayAngle) * (1 - owner-&gt;limExperience * 0.7f);
+	const float spread = (accuracy + sprayAngle) * (1 - owner-&gt;limExperience * 0.7f);
 
 	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
 		return false;

Modified: branches/caiinterface/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/Weapon.cpp	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/rts/Sim/Weapons/Weapon.cpp	2008-10-09 18:55:21 UTC (rev 6639)
@@ -264,30 +264,33 @@
 			/* to prevent runaway prediction (happens sometimes when a missile is moving *away* from it's target), we may need to disable missiles in case they fly around too long */
 			predict = 50000;
 		}
-		float3 lead = targetUnit-&gt;speed*(weaponDef-&gt;predictBoost+predictSpeedMod*(1.0f - weaponDef-&gt;predictBoost))*predict;
-		if (weaponDef-&gt;leadLimit &gt;= 0.0f &amp;&amp; lead.Length() &gt; weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus*owner-&gt;experience) {
-			lead *= (weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus*owner-&gt;experience) / lead.Length();
+
+		float3 lead = targetUnit-&gt;speed * (weaponDef-&gt;predictBoost+predictSpeedMod * (1.0f - weaponDef-&gt;predictBoost)) * predict;
+
+		if (weaponDef-&gt;leadLimit &gt;= 0.0f &amp;&amp; lead.Length() &gt; weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus * owner-&gt;experience) {
+			lead *= (weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus*owner-&gt;experience) / (lead.Length() + 0.01f);
 		}
 
-		targetPos=helper-&gt;GetUnitErrorPos(targetUnit,owner-&gt;allyteam)+lead;
-		targetPos+=errorVector*(weaponDef-&gt;targetMoveError*30*targetUnit-&gt;speed.Length()*(1.0f-owner-&gt;limExperience));
-		float appHeight=ground-&gt;GetApproximateHeight(targetPos.x,targetPos.z)+2;
-		if(targetPos.y &lt; appHeight)
-			targetPos.y=appHeight;
+		targetPos = helper-&gt;GetUnitErrorPos(targetUnit, owner-&gt;allyteam) + lead;
+		targetPos += errorVector * (weaponDef-&gt;targetMoveError * 30 * targetUnit-&gt;speed.Length() * (1.0f - owner-&gt;limExperience));
+		float appHeight = ground-&gt;GetApproximateHeight(targetPos.x, targetPos.z) + 2;
 
-		if(!weaponDef-&gt;waterweapon &amp;&amp; targetPos.y&lt;1)
-			targetPos.y=1;
+		if (targetPos.y &lt; appHeight)
+			targetPos.y = appHeight;
+
+		if (!weaponDef-&gt;waterweapon &amp;&amp; targetPos.y &lt; 1.0f)
+			targetPos.y = 1.0f;
 	}
 
-	if(weaponDef-&gt;interceptor) {
+	if (weaponDef-&gt;interceptor) {
 		CheckIntercept();
 	}
-	if(targetType!=Target_None){
-		if(onlyForward){
-			float3 goaldir=targetPos-owner-&gt;pos;
+	if (targetType != Target_None){
+		if (onlyForward) {
+			float3 goaldir = targetPos - owner-&gt;pos;
 			goaldir.Normalize();
-			angleGood=owner-&gt;frontdir.dot(goaldir) &gt; maxAngleDif;
-		} else if(lastRequestedDir.dot(wantedDir)&lt;maxAngleDif || lastRequest+15&lt;gs-&gt;frameNum){
+			angleGood = (owner-&gt;frontdir.dot(goaldir) &gt; maxAngleDif);
+		} else if (lastRequestedDir.dot(wantedDir) &lt; maxAngleDif || lastRequest + 15 &lt; gs-&gt;frameNum) {
 			angleGood=false;
 			lastRequestedDir=wantedDir;
 			lastRequest=gs-&gt;frameNum;

Modified: branches/caiinterface/tools/DedicatedServer/CMakeLists.txt
===================================================================
--- branches/caiinterface/tools/DedicatedServer/CMakeLists.txt	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/DedicatedServer/CMakeLists.txt	2008-10-09 18:55:21 UTC (rev 6639)
@@ -33,7 +33,7 @@
 	../../rts/System/UnsyncedRNG )
 
 AUX_SOURCE_DIRECTORY(../../rts/Game/Server serverfiles)
-ADD_LIBRARY(server SHARED
+ADD_LIBRARY(springserver SHARED
 	${system_files}
 	${serverfiles}
 	../../rts/Game/GameServer
@@ -50,15 +50,15 @@
 	../../rts/Lua/LuaUtils
 	../../rts/Map/MapParser
 	../../rts/Rendering/Textures/TAPalette)
-TARGET_LINK_LIBRARIES(server SDL hpiutil2 7zip minizip lua)
+TARGET_LINK_LIBRARIES(springserver SDL hpiutil2 7zip minizip lua)
 if (MINGW)
-	TARGET_LINK_LIBRARIES (server ws2_32 boost_thread-mt boost_regex-mt)
+	TARGET_LINK_LIBRARIES (springserver ws2_32 boost_thread-mt boost_regex-mt)
 else (MINGW)
-	TARGET_LINK_LIBRARIES (server ${Boost_REGEX_LIBRARY} ${Boost_THREAD_LIBRARY})
+	TARGET_LINK_LIBRARIES (springserver ${Boost_REGEX_LIBRARY} ${Boost_THREAD_LIBRARY})
 	ADD_DEFINITIONS (-fvisibility=default ) #overwrite hidden visibility
 endif (MINGW)
 
-ADD_EXECUTABLE(dedicated main)
-TARGET_LINK_LIBRARIES(dedicated server)
+ADD_EXECUTABLE(spring-dedicated main)
+TARGET_LINK_LIBRARIES(spring-dedicated springserver)
 
-install (TARGETS server dedicated RUNTIME DESTINATION ${BINDIR} LIBRARY DESTINATION ${LIBDIR})
+install (TARGETS springserver spring-dedicated RUNTIME DESTINATION ${BINDIR} LIBRARY DESTINATION ${LIBDIR})


Property changes on: branches/caiinterface/tools/springie
___________________________________________________________________
Name: svn:ignore
   - *.suo
Ankh.Load
!zaloha
!runs
!resources
_ReSharper.Springie
Springie.resharper
Springie.4.0.resharper
Springie.4.0.resharper.user

   + *.suo
Ankh.Load
!zaloha
!runs
!resources
_ReSharper.Springie
Springie.resharper
Springie.4.0.resharper
Springie.4.0.resharper.user
bin
Springie.4.1.resharper.user


Modified: branches/caiinterface/tools/springie/Springie/ErrorHandling.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/ErrorHandling.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/ErrorHandling.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.IO;
 using System.Net;
@@ -3,39 +5,49 @@
 using System.Windows.Forms;
 
+#endregion
+
 namespace Springie
 {
-  public class ErrorHandling
-  {
-    private const string LogFile = &quot;springie_errors.txt&quot;;
-    private const string ReportUrl = &quot;<A HREF="http://springie.licho.eu/error.php">http://springie.licho.eu/error.php</A>&quot;;
+	public class ErrorHandling
+	{
+		#region Constants
 
-    /// &lt;summary&gt;
-    /// Handles one exception (saves to log file and sends to website)
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;e&quot;&gt;exception to be handled&lt;/param&gt;
-    /// &lt;param name=&quot;moreInfo&quot;&gt;additional information&lt;/param&gt;
-    /// &lt;returns&gt;returns true if exception was handled, false if called should rethrow&lt;/returns&gt;
-    public static bool HandleException(Exception e, string moreInfo)
-    {
-      try {
-        // write to error log
-        StreamWriter s = File.AppendText(Application.StartupPath + '/' + LogFile);
-        s.WriteLine(&quot;===============\r\n{0}\r\n{1}\r\n{2}\r\n&quot;, DateTime.Now.ToString(&quot;g&quot;), moreInfo, e);
-        s.Close();
+		private const string LogFile = &quot;springie_errors.txt&quot;;
+		private const string ReportUrl = &quot;<A HREF="http://springie.licho.eu/error.php">http://springie.licho.eu/error.php</A>&quot;;
 
-        // send to error gathering site
-        WebClient wc = new WebClient();
-        string urtext = string.Format(&quot;{0}?username={1}&amp;springie={2}&amp;moreinfo={3}&amp;exception={4}&quot;, ReportUrl, Program.main.config.AccountName, MainConfig.SpringieVersion, moreInfo + &quot;&quot;, e);
-        wc.DownloadString(new Uri(urtext));
-      } catch {}
+		#endregion
 
-      try {
-        // optionally display messagebox
-        if (Program.main.config.ErrorHandlingMode == MainConfig.ErrorHandlingModes.MessageBox) MessageBox.Show(e.ToString(), moreInfo);
-      } catch {}
+		#region Public methods
 
-      if (Program.main.config.ErrorHandlingMode == MainConfig.ErrorHandlingModes.Debug) return false;
-      else return true;
-    }
-  }
+		/// &lt;summary&gt;
+		/// Handles one exception (saves to log file and sends to website)
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;e&quot;&gt;exception to be handled&lt;/param&gt;
+		/// &lt;param name=&quot;moreInfo&quot;&gt;additional information&lt;/param&gt;
+		/// &lt;returns&gt;returns true if exception was handled, false if called should rethrow&lt;/returns&gt;
+		public static bool HandleException(Exception e, string moreInfo)
+		{
+			try {
+				// write to error log
+				var s = File.AppendText(Application.StartupPath + '/' + LogFile);
+				s.WriteLine(&quot;===============\r\n{0}\r\n{1}\r\n{2}\r\n&quot;, DateTime.Now.ToString(&quot;g&quot;), moreInfo, e);
+				s.Close();
+
+				// send to error gathering site
+				var wc = new WebClient();
+				string urtext = string.Format(&quot;{0}?username={1}&amp;springie={2}&amp;moreinfo={3}&amp;exception={4}&quot;, ReportUrl, Program.main.config.AccountName, MainConfig.SpringieVersion, moreInfo + &quot;&quot;, e);
+				wc.DownloadString(new Uri(urtext));
+			} catch {}
+
+			try {
+				// optionally display messagebox
+				if (Program.main.config.ErrorHandlingMode == MainConfig.ErrorHandlingModes.MessageBox) MessageBox.Show(e.ToString(), moreInfo);
+			} catch {}
+
+			if (Program.main.config.ErrorHandlingMode == MainConfig.ErrorHandlingModes.Debug) return false;
+			else return true;
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/FormAccount.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/FormAccount.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/FormAccount.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,54 +1,79 @@
+#region using
+
 using System;
 using System.Windows.Forms;
 
+#endregion
+
 namespace Springie
 {
-  public partial class FormAccount : Form
-  {
-    private const int CountDown = 60;
-    private int countValue = CountDown;
+	public partial class FormAccount : Form
+	{
+		#region Constants
 
-    public FormAccount()
-    {
-      InitializeComponent();
-    }
+		private const int CountDown = 60;
 
-    public string Login
-    {
-      get { return textBox1.Text; }
-      set { textBox1.Text = value; }
-    }
+		#endregion
 
-    public string Password
-    {
-      get { return textBox2.Text; }
-      set { textBox2.Text = value; }
-    }
+		#region Fields
 
-    private void button1_Click(object sender, EventArgs e)
-    {
-      timer1.Stop();
-      DialogResult = DialogResult.OK;
-    }
+		private int countValue = CountDown;
 
-    private void FormAccount_Shown(object sender, EventArgs e)
-    {
-      Login = Program.main.config.AccountName;
-      Password = Program.main.config.AccountPassword;
-      timer1.Interval = 1000;
-      timer1.Start();
-    }
+		#endregion
 
-    private void timer1_Tick(object sender, EventArgs e)
-    {
-      countValue--;
-      button1.Text = &quot;Apply (&quot; + countValue + &quot;)&quot;;
-      if (countValue == 0) button1.PerformClick();
-    }
+		#region Properties
 
-    private void FormAccount_FormClosing(object sender, FormClosingEventArgs e)
-    {
-      timer1.Stop();
-    }
-  }
+		public string Login
+		{
+			get { return textBox1.Text; }
+			set { textBox1.Text = value; }
+		}
+
+		public string Password
+		{
+			get { return textBox2.Text; }
+			set { textBox2.Text = value; }
+		}
+
+		#endregion
+
+		#region Constructors
+
+		public FormAccount()
+		{
+			InitializeComponent();
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void button1_Click(object sender, EventArgs e)
+		{
+			timer1.Stop();
+			DialogResult = DialogResult.OK;
+		}
+
+		private void FormAccount_FormClosing(object sender, FormClosingEventArgs e)
+		{
+			timer1.Stop();
+		}
+
+		private void FormAccount_Shown(object sender, EventArgs e)
+		{
+			Login = Program.main.config.AccountName;
+			Password = Program.main.config.AccountPassword;
+			timer1.Interval = 1000;
+			timer1.Start();
+		}
+
+		private void timer1_Tick(object sender, EventArgs e)
+		{
+			countValue--;
+			button1.Text = &quot;Apply (&quot; + countValue + &quot;)&quot;;
+			if (countValue == 0) button1.PerformClick();
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/FormCurrentBattle.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/FormCurrentBattle.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/FormCurrentBattle.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.ComponentModel;
 using System.Windows.Forms;
@@ -5,100 +7,102 @@
 using Springie.Client;
 using Springie.SpringNamespace;
 
+#endregion
+
 namespace Springie
 {
-  public partial class FormCurrentBattle : Form
-  {
-    private CurrentBattle bat = new CurrentBattle();
+	public partial class FormCurrentBattle : Form
+	{
+		#region Fields
 
-    public FormCurrentBattle()
-    {
-      InitializeComponent();
-    }
+		private CurrentBattle bat = new CurrentBattle();
 
-    private void LoadCurrentData()
-    {
-      Battle b = Program.main.Tas.GetBattle();
-      if (b != null) {
-        bat.BattleDetails = b.Details;
-        bat.Map = b.Map.Name;
-        bat.Locked = b.IsLocked;
+		#endregion
 
-        bat.DisabledUnits = UnitInfo.FromStringList(b.DisabledUnits.ToArray(), b.Mod);
-      }
-    }
+		#region Constructors
 
-    private void SaveCurrentData()
-    {
-      Battle b = Program.main.Tas.GetBattle();
-      if (b != null) {
-        Program.main.Tas.UpdateBattleDetails(bat.BattleDetails);
-        Program.main.Tas.ChangeLock(bat.Locked);
-        Program.main.Tas.ChangeMap(Program.main.Spring.UnitSync.GetMapInfo(bat.Map));
-        Program.main.Tas.EnableAllUnits();
+		public FormCurrentBattle()
+		{
+			InitializeComponent();
+		}
 
-        Program.main.Tas.DisableUnits(UnitInfo.ToStringList(bat.DisabledUnits));
-      }
-    }
+		#endregion
 
-    private void FormCurrentBattle_Load(object sender, EventArgs e)
-    {
-      LoadCurrentData();
-      propertyGrid1.SelectedObject = bat;
-    }
+		#region Other methods
 
-    private void Tas_Changed(object sender, TasEventArgs e)
-    {
-      LoadCurrentData();
-    }
+		private void LoadCurrentData()
+		{
+			var b = Program.main.Tas.GetBattle();
+			if (b != null) {
+				bat.BattleDetails = b.Details;
+				bat.Map = b.Map.Name;
+				bat.Locked = b.IsLocked;
 
-    private void button1_Click(object sender, EventArgs e)
-    {
-      SaveCurrentData();
-    }
+				bat.DisabledUnits = UnitInfo.FromStringList(b.DisabledUnits.ToArray(), b.Mod);
+			}
+		}
 
-    #region Nested type: CurrentBattle
-    protected class CurrentBattle
-    {
-      private BattleDetails battleDetails;
-      private UnitInfo[] disabledUnits;
-      private bool locked;
-      private string map;
+		private void SaveCurrentData()
+		{
+			var b = Program.main.Tas.GetBattle();
+			if (b != null) {
+				Program.main.Tas.UpdateBattleDetails(bat.BattleDetails);
+				Program.main.Tas.ChangeLock(bat.Locked);
+				Program.main.Tas.ChangeMap(Program.main.Spring.UnitSync.GetMapInfo(bat.Map));
+				Program.main.Tas.EnableAllUnits();
 
-      [Category(&quot;Basic&quot;)]
-      [Description(&quot;Current map&quot;)]
-      [TypeConverter(typeof(AutoHostConfig.MapConverter))]
-      public string Map
-      {
-        get { return map; }
-        set { map = value; }
-      }
+				Program.main.Tas.DisableUnits(UnitInfo.ToStringList(bat.DisabledUnits));
+			}
+		}
 
-      [Category(&quot;Basic&quot;)]
-      [Description(&quot;Is game locked?&quot;)]
-      public bool Locked
-      {
-        get { return locked; }
-        set { locked = value; }
-      }
+		private void Tas_Changed(object sender, TasEventArgs e)
+		{
+			LoadCurrentData();
+		}
 
+		#endregion
 
-      [Category(&quot;Details&quot;)]
-      [Description(&quot;Battle details&quot;)]
-      public BattleDetails BattleDetails
-      {
-        get { return battleDetails; }
-        set { battleDetails = value; }
-      }
+		#region Event Handlers
 
-      [Category(&quot;Disabled units&quot;)]
-      [Description(&quot;List of currently disabled units&quot;)]
-      public UnitInfo[] DisabledUnits
-      {
-        get { return disabledUnits; }
-        set { disabledUnits = value; }
-      }
-    } ;
-    #endregion
-  }
+		private void button1_Click(object sender, EventArgs e)
+		{
+			SaveCurrentData();
+		}
+
+		private void FormCurrentBattle_Load(object sender, EventArgs e)
+		{
+			LoadCurrentData();
+			propertyGrid1.SelectedObject = bat;
+		}
+
+		#endregion
+
+		#region Nested type: CurrentBattle
+
+		protected class CurrentBattle
+		{
+			#region Properties
+
+			[Category(&quot;Details&quot;)]
+			[Description(&quot;Battle details&quot;)]
+			public BattleDetails BattleDetails { get; set; }
+
+			[Category(&quot;Disabled units&quot;)]
+			[Description(&quot;List of currently disabled units&quot;)]
+			public UnitInfo[] DisabledUnits { get; set; }
+
+			[Category(&quot;Basic&quot;)]
+			[Description(&quot;Is game locked?&quot;)]
+			public bool Locked { get; set; }
+
+			[Category(&quot;Basic&quot;)]
+			[Description(&quot;Current map&quot;)]
+			[TypeConverter(typeof (AutoHostConfig.MapConverter))]
+			public string Map { get; set; }
+
+			#endregion
+		} ;
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/FormMain.Designer.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/FormMain.Designer.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/FormMain.Designer.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -27,349 +27,345 @@
     /// &lt;/summary&gt;
     private void InitializeComponent()
     {
-      this.components = new System.ComponentModel.Container();
-      System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormMain));
-      this.groupBox2 = new System.Windows.Forms.GroupBox();
-      this.listBoxChannel = new System.Windows.Forms.ListBox();
-      this.groupBox1 = new System.Windows.Forms.GroupBox();
-      this.listBoxBattle = new System.Windows.Forms.ListBox();
-      this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);
-      this.menuStrip1 = new System.Windows.Forms.MenuStrip();
-      this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.settingsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.currentBattleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.actionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.rehostToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.reloadModsMapsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.springToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.showhideHostingWindowToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
-      this.tabControl = new System.Windows.Forms.TabControl();
-      this.tabPage1 = new System.Windows.Forms.TabPage();
-      this.tabPage2 = new System.Windows.Forms.TabPage();
-      this.splitContainer1 = new System.Windows.Forms.SplitContainer();
-      this.textBox = new System.Windows.Forms.TextBox();
-      this.splitContainer2 = new System.Windows.Forms.SplitContainer();
-      this.statusStrip1 = new System.Windows.Forms.StatusStrip();
-      this.toolStripStatusLabel1 = new System.Windows.Forms.ToolStripStatusLabel();
-      this.toolStripStatusLabel2 = new System.Windows.Forms.ToolStripStatusLabel();
-      this.toolStripStatusLabel3 = new System.Windows.Forms.ToolStripStatusLabel();
-      this.toolStripStatusLabel4 = new System.Windows.Forms.ToolStripStatusLabel();
-      this.toolStripStatusLabel5 = new System.Windows.Forms.ToolStripStatusLabel();
-      this.button1 = new System.Windows.Forms.Button();
-      this.groupBox2.SuspendLayout();
-      this.groupBox1.SuspendLayout();
-      this.menuStrip1.SuspendLayout();
-      this.tabControl.SuspendLayout();
-      this.tabPage1.SuspendLayout();
-      this.splitContainer1.Panel1.SuspendLayout();
-      this.splitContainer1.Panel2.SuspendLayout();
-      this.splitContainer1.SuspendLayout();
-      this.splitContainer2.Panel1.SuspendLayout();
-      this.splitContainer2.Panel2.SuspendLayout();
-      this.splitContainer2.SuspendLayout();
-      this.statusStrip1.SuspendLayout();
-      this.SuspendLayout();
-      // 
-      // groupBox2
-      // 
-      this.groupBox2.Controls.Add(this.listBoxChannel);
-      this.groupBox2.Dock = System.Windows.Forms.DockStyle.Fill;
-      this.groupBox2.Location = new System.Drawing.Point(0, 0);
-      this.groupBox2.Name = &quot;groupBox2&quot;;
-      this.groupBox2.Size = new System.Drawing.Size(176, 351);
-      this.groupBox2.TabIndex = 7;
-      this.groupBox2.TabStop = false;
-      this.groupBox2.Text = &quot;Users&quot;;
-      // 
-      // listBoxChannel
-      // 
-      this.listBoxChannel.Dock = System.Windows.Forms.DockStyle.Fill;
-      this.listBoxChannel.FormattingEnabled = true;
-      this.listBoxChannel.Location = new System.Drawing.Point(3, 16);
-      this.listBoxChannel.Name = &quot;listBoxChannel&quot;;
-      this.listBoxChannel.Size = new System.Drawing.Size(170, 329);
-      this.listBoxChannel.TabIndex = 0;
-      this.listBoxChannel.SelectedIndexChanged += new System.EventHandler(this.listBox_SelectedIndexChanged);
-      // 
-      // groupBox1
-      // 
-      this.groupBox1.Controls.Add(this.listBoxBattle);
-      this.groupBox1.Dock = System.Windows.Forms.DockStyle.Fill;
-      this.groupBox1.Location = new System.Drawing.Point(0, 0);
-      this.groupBox1.Name = &quot;groupBox1&quot;;
-      this.groupBox1.Size = new System.Drawing.Size(176, 218);
-      this.groupBox1.TabIndex = 6;
-      this.groupBox1.TabStop = false;
-      this.groupBox1.Text = &quot;Battle&quot;;
-      // 
-      // listBoxBattle
-      // 
-      this.listBoxBattle.Dock = System.Windows.Forms.DockStyle.Fill;
-      this.listBoxBattle.FormattingEnabled = true;
-      this.listBoxBattle.Location = new System.Drawing.Point(3, 16);
-      this.listBoxBattle.Name = &quot;listBoxBattle&quot;;
-      this.listBoxBattle.Size = new System.Drawing.Size(170, 199);
-      this.listBoxBattle.TabIndex = 0;
-      this.listBoxBattle.SelectedIndexChanged += new System.EventHandler(this.listBox_SelectedIndexChanged);
-      // 
-      // notifyIcon1
-      // 
-      this.notifyIcon1.Text = &quot;Springie&quot;;
-      this.notifyIcon1.Visible = true;
-      this.notifyIcon1.Click += new System.EventHandler(this.notifyIcon1_Click);
-      // 
-      // menuStrip1
-      // 
-      this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
+			this.components = new System.ComponentModel.Container();
+			System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(FormMain));
+			this.groupBox2 = new System.Windows.Forms.GroupBox();
+			this.listBoxChannel = new System.Windows.Forms.ListBox();
+			this.groupBox1 = new System.Windows.Forms.GroupBox();
+			this.listBoxBattle = new System.Windows.Forms.ListBox();
+			this.notifyIcon1 = new System.Windows.Forms.NotifyIcon(this.components);
+			this.menuStrip1 = new System.Windows.Forms.MenuStrip();
+			this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.settingsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.currentBattleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.actionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.rehostToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.reloadModsMapsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.springToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
+			this.tabControl = new System.Windows.Forms.TabControl();
+			this.tabPage1 = new System.Windows.Forms.TabPage();
+			this.button1 = new System.Windows.Forms.Button();
+			this.tabPage2 = new System.Windows.Forms.TabPage();
+			this.splitContainer1 = new System.Windows.Forms.SplitContainer();
+			this.textBox = new System.Windows.Forms.TextBox();
+			this.splitContainer2 = new System.Windows.Forms.SplitContainer();
+			this.statusStrip1 = new System.Windows.Forms.StatusStrip();
+			this.toolStripStatusLabel1 = new System.Windows.Forms.ToolStripStatusLabel();
+			this.toolStripStatusLabel2 = new System.Windows.Forms.ToolStripStatusLabel();
+			this.toolStripStatusLabel3 = new System.Windows.Forms.ToolStripStatusLabel();
+			this.toolStripStatusLabel4 = new System.Windows.Forms.ToolStripStatusLabel();
+			this.toolStripStatusLabel5 = new System.Windows.Forms.ToolStripStatusLabel();
+			this.groupBox2.SuspendLayout();
+			this.groupBox1.SuspendLayout();
+			this.menuStrip1.SuspendLayout();
+			this.tabControl.SuspendLayout();
+			this.tabPage1.SuspendLayout();
+			this.splitContainer1.Panel1.SuspendLayout();
+			this.splitContainer1.Panel2.SuspendLayout();
+			this.splitContainer1.SuspendLayout();
+			this.splitContainer2.Panel1.SuspendLayout();
+			this.splitContainer2.Panel2.SuspendLayout();
+			this.splitContainer2.SuspendLayout();
+			this.statusStrip1.SuspendLayout();
+			this.SuspendLayout();
+			// 
+			// groupBox2
+			// 
+			this.groupBox2.Controls.Add(this.listBoxChannel);
+			this.groupBox2.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.groupBox2.Location = new System.Drawing.Point(0, 0);
+			this.groupBox2.Name = &quot;groupBox2&quot;;
+			this.groupBox2.Size = new System.Drawing.Size(176, 350);
+			this.groupBox2.TabIndex = 7;
+			this.groupBox2.TabStop = false;
+			this.groupBox2.Text = &quot;Users&quot;;
+			// 
+			// listBoxChannel
+			// 
+			this.listBoxChannel.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.listBoxChannel.FormattingEnabled = true;
+			this.listBoxChannel.Location = new System.Drawing.Point(3, 16);
+			this.listBoxChannel.Name = &quot;listBoxChannel&quot;;
+			this.listBoxChannel.Size = new System.Drawing.Size(170, 329);
+			this.listBoxChannel.TabIndex = 0;
+			this.listBoxChannel.SelectedIndexChanged += new System.EventHandler(this.listBox_SelectedIndexChanged);
+			// 
+			// groupBox1
+			// 
+			this.groupBox1.Controls.Add(this.listBoxBattle);
+			this.groupBox1.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.groupBox1.Location = new System.Drawing.Point(0, 0);
+			this.groupBox1.Name = &quot;groupBox1&quot;;
+			this.groupBox1.Size = new System.Drawing.Size(176, 217);
+			this.groupBox1.TabIndex = 6;
+			this.groupBox1.TabStop = false;
+			this.groupBox1.Text = &quot;Battle&quot;;
+			// 
+			// listBoxBattle
+			// 
+			this.listBoxBattle.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.listBoxBattle.FormattingEnabled = true;
+			this.listBoxBattle.Location = new System.Drawing.Point(3, 16);
+			this.listBoxBattle.Name = &quot;listBoxBattle&quot;;
+			this.listBoxBattle.Size = new System.Drawing.Size(170, 186);
+			this.listBoxBattle.TabIndex = 0;
+			this.listBoxBattle.SelectedIndexChanged += new System.EventHandler(this.listBox_SelectedIndexChanged);
+			// 
+			// notifyIcon1
+			// 
+			this.notifyIcon1.Text = &quot;Springie&quot;;
+			this.notifyIcon1.Visible = true;
+			this.notifyIcon1.Click += new System.EventHandler(this.notifyIcon1_Click);
+			// 
+			// menuStrip1
+			// 
+			this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.optionsToolStripMenuItem,
             this.actionsToolStripMenuItem,
             this.springToolStripMenuItem});
-      this.menuStrip1.Location = new System.Drawing.Point(0, 0);
-      this.menuStrip1.Name = &quot;menuStrip1&quot;;
-      this.menuStrip1.Size = new System.Drawing.Size(702, 24);
-      this.menuStrip1.TabIndex = 7;
-      this.menuStrip1.Text = &quot;Options&quot;;
-      // 
-      // optionsToolStripMenuItem
-      // 
-      this.optionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
+			this.menuStrip1.Location = new System.Drawing.Point(0, 0);
+			this.menuStrip1.Name = &quot;menuStrip1&quot;;
+			this.menuStrip1.Size = new System.Drawing.Size(702, 24);
+			this.menuStrip1.TabIndex = 7;
+			this.menuStrip1.Text = &quot;Options&quot;;
+			// 
+			// optionsToolStripMenuItem
+			// 
+			this.optionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.settingsToolStripMenuItem,
             this.currentBattleToolStripMenuItem});
-      this.optionsToolStripMenuItem.Name = &quot;optionsToolStripMenuItem&quot;;
-      this.optionsToolStripMenuItem.Size = new System.Drawing.Size(55, 20);
-      this.optionsToolStripMenuItem.Text = &quot;Options&quot;;
-      // 
-      // settingsToolStripMenuItem
-      // 
-      this.settingsToolStripMenuItem.Name = &quot;settingsToolStripMenuItem&quot;;
-      this.settingsToolStripMenuItem.Size = new System.Drawing.Size(140, 22);
-      this.settingsToolStripMenuItem.Text = &quot;Settings&quot;;
-      this.settingsToolStripMenuItem.Click += new System.EventHandler(this.settingsToolStripMenuItem_Click);
-      // 
-      // currentBattleToolStripMenuItem
-      // 
-      this.currentBattleToolStripMenuItem.Name = &quot;currentBattleToolStripMenuItem&quot;;
-      this.currentBattleToolStripMenuItem.Size = new System.Drawing.Size(140, 22);
-      this.currentBattleToolStripMenuItem.Text = &quot;Current battle&quot;;
-      this.currentBattleToolStripMenuItem.Click += new System.EventHandler(this.currentBattleToolStripMenuItem_Click);
-      // 
-      // actionsToolStripMenuItem
-      // 
-      this.actionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
+			this.optionsToolStripMenuItem.Name = &quot;optionsToolStripMenuItem&quot;;
+			this.optionsToolStripMenuItem.Size = new System.Drawing.Size(61, 20);
+			this.optionsToolStripMenuItem.Text = &quot;Options&quot;;
+			// 
+			// settingsToolStripMenuItem
+			// 
+			this.settingsToolStripMenuItem.Name = &quot;settingsToolStripMenuItem&quot;;
+			this.settingsToolStripMenuItem.Size = new System.Drawing.Size(147, 22);
+			this.settingsToolStripMenuItem.Text = &quot;Settings&quot;;
+			this.settingsToolStripMenuItem.Click += new System.EventHandler(this.settingsToolStripMenuItem_Click);
+			// 
+			// currentBattleToolStripMenuItem
+			// 
+			this.currentBattleToolStripMenuItem.Name = &quot;currentBattleToolStripMenuItem&quot;;
+			this.currentBattleToolStripMenuItem.Size = new System.Drawing.Size(147, 22);
+			this.currentBattleToolStripMenuItem.Text = &quot;Current battle&quot;;
+			this.currentBattleToolStripMenuItem.Click += new System.EventHandler(this.currentBattleToolStripMenuItem_Click);
+			// 
+			// actionsToolStripMenuItem
+			// 
+			this.actionsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.rehostToolStripMenuItem,
             this.reloadModsMapsToolStripMenuItem});
-      this.actionsToolStripMenuItem.Name = &quot;actionsToolStripMenuItem&quot;;
-      this.actionsToolStripMenuItem.Size = new System.Drawing.Size(54, 20);
-      this.actionsToolStripMenuItem.Text = &quot;Actions&quot;;
-      // 
-      // rehostToolStripMenuItem
-      // 
-      this.rehostToolStripMenuItem.Enabled = false;
-      this.rehostToolStripMenuItem.Name = &quot;rehostToolStripMenuItem&quot;;
-      this.rehostToolStripMenuItem.Size = new System.Drawing.Size(171, 22);
-      this.rehostToolStripMenuItem.Text = &quot;Rehost&quot;;
-      this.rehostToolStripMenuItem.Click += new System.EventHandler(this.rehostToolStripMenuItem_Click);
-      // 
-      // reloadModsMapsToolStripMenuItem
-      // 
-      this.reloadModsMapsToolStripMenuItem.Name = &quot;reloadModsMapsToolStripMenuItem&quot;;
-      this.reloadModsMapsToolStripMenuItem.Size = new System.Drawing.Size(171, 22);
-      this.reloadModsMapsToolStripMenuItem.Text = &quot;Reload Mods/Maps&quot;;
-      this.reloadModsMapsToolStripMenuItem.Click += new System.EventHandler(this.reloadModsMapsToolStripMenuItem_Click);
-      // 
-      // springToolStripMenuItem
-      // 
-      this.springToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
-            this.showhideHostingWindowToolStripMenuItem});
-      this.springToolStripMenuItem.Name = &quot;springToolStripMenuItem&quot;;
-      this.springToolStripMenuItem.Size = new System.Drawing.Size(49, 20);
-      this.springToolStripMenuItem.Text = &quot;Spring&quot;;
-      // 
-      // showhideHostingWindowToolStripMenuItem
-      // 
-      this.showhideHostingWindowToolStripMenuItem.Enabled = false;
-      this.showhideHostingWindowToolStripMenuItem.Name = &quot;showhideHostingWindowToolStripMenuItem&quot;;
-      this.showhideHostingWindowToolStripMenuItem.Size = new System.Drawing.Size(175, 22);
-      this.showhideHostingWindowToolStripMenuItem.Text = &quot;Hide hosting window&quot;;
-      // 
-      // tabControl
-      // 
-      this.tabControl.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
-                  | System.Windows.Forms.AnchorStyles.Left)
-                  | System.Windows.Forms.AnchorStyles.Right)));
-      this.tabControl.Controls.Add(this.tabPage1);
-      this.tabControl.Controls.Add(this.tabPage2);
-      this.tabControl.Location = new System.Drawing.Point(0, 0);
-      this.tabControl.Name = &quot;tabControl&quot;;
-      this.tabControl.SelectedIndex = 0;
-      this.tabControl.Size = new System.Drawing.Size(522, 551);
-      this.tabControl.TabIndex = 0;
-      this.tabControl.MouseDown += new System.Windows.Forms.MouseEventHandler(this.tabControl_MouseDown);
-      // 
-      // tabPage1
-      // 
-      this.tabPage1.Controls.Add(this.button1);
-      this.tabPage1.Location = new System.Drawing.Point(4, 22);
-      this.tabPage1.Name = &quot;tabPage1&quot;;
-      this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
-      this.tabPage1.Size = new System.Drawing.Size(514, 525);
-      this.tabPage1.TabIndex = 0;
-      this.tabPage1.Text = &quot;tabPage1&quot;;
-      this.tabPage1.UseVisualStyleBackColor = true;
-      // 
-      // tabPage2
-      // 
-      this.tabPage2.Location = new System.Drawing.Point(4, 22);
-      this.tabPage2.Name = &quot;tabPage2&quot;;
-      this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
-      this.tabPage2.Size = new System.Drawing.Size(514, 525);
-      this.tabPage2.TabIndex = 1;
-      this.tabPage2.Text = &quot;tabPage2&quot;;
-      this.tabPage2.UseVisualStyleBackColor = true;
-      // 
-      // splitContainer1
-      // 
-      this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
-      this.splitContainer1.Location = new System.Drawing.Point(0, 24);
-      this.splitContainer1.Name = &quot;splitContainer1&quot;;
-      // 
-      // splitContainer1.Panel1
-      // 
-      this.splitContainer1.Panel1.Controls.Add(this.textBox);
-      this.splitContainer1.Panel1.Controls.Add(this.tabControl);
-      // 
-      // splitContainer1.Panel2
-      // 
-      this.splitContainer1.Panel2.Controls.Add(this.splitContainer2);
-      this.splitContainer1.Size = new System.Drawing.Size(702, 573);
-      this.splitContainer1.SplitterDistance = 522;
-      this.splitContainer1.TabIndex = 8;
-      // 
-      // textBox
-      // 
-      this.textBox.Dock = System.Windows.Forms.DockStyle.Bottom;
-      this.textBox.Location = new System.Drawing.Point(0, 553);
-      this.textBox.Name = &quot;textBox&quot;;
-      this.textBox.Size = new System.Drawing.Size(522, 20);
-      this.textBox.TabIndex = 1;
-      this.textBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.textBox_KeyDown);
-      // 
-      // splitContainer2
-      // 
-      this.splitContainer2.Dock = System.Windows.Forms.DockStyle.Fill;
-      this.splitContainer2.Location = new System.Drawing.Point(0, 0);
-      this.splitContainer2.Name = &quot;splitContainer2&quot;;
-      this.splitContainer2.Orientation = System.Windows.Forms.Orientation.Horizontal;
-      // 
-      // splitContainer2.Panel1
-      // 
-      this.splitContainer2.Panel1.Controls.Add(this.groupBox1);
-      // 
-      // splitContainer2.Panel2
-      // 
-      this.splitContainer2.Panel2.Controls.Add(this.groupBox2);
-      this.splitContainer2.Size = new System.Drawing.Size(176, 573);
-      this.splitContainer2.SplitterDistance = 218;
-      this.splitContainer2.TabIndex = 0;
-      // 
-      // statusStrip1
-      // 
-      this.statusStrip1.GripStyle = System.Windows.Forms.ToolStripGripStyle.Visible;
-      this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
+			this.actionsToolStripMenuItem.Name = &quot;actionsToolStripMenuItem&quot;;
+			this.actionsToolStripMenuItem.Size = new System.Drawing.Size(59, 20);
+			this.actionsToolStripMenuItem.Text = &quot;Actions&quot;;
+			// 
+			// rehostToolStripMenuItem
+			// 
+			this.rehostToolStripMenuItem.Enabled = false;
+			this.rehostToolStripMenuItem.Name = &quot;rehostToolStripMenuItem&quot;;
+			this.rehostToolStripMenuItem.Size = new System.Drawing.Size(177, 22);
+			this.rehostToolStripMenuItem.Text = &quot;Rehost&quot;;
+			this.rehostToolStripMenuItem.Click += new System.EventHandler(this.rehostToolStripMenuItem_Click);
+			// 
+			// reloadModsMapsToolStripMenuItem
+			// 
+			this.reloadModsMapsToolStripMenuItem.Name = &quot;reloadModsMapsToolStripMenuItem&quot;;
+			this.reloadModsMapsToolStripMenuItem.Size = new System.Drawing.Size(177, 22);
+			this.reloadModsMapsToolStripMenuItem.Text = &quot;Reload Mods/Maps&quot;;
+			this.reloadModsMapsToolStripMenuItem.Click += new System.EventHandler(this.reloadModsMapsToolStripMenuItem_Click);
+			// 
+			// springToolStripMenuItem
+			// 
+			this.springToolStripMenuItem.Name = &quot;springToolStripMenuItem&quot;;
+			this.springToolStripMenuItem.Size = new System.Drawing.Size(53, 20);
+			this.springToolStripMenuItem.Text = &quot;Spring&quot;;
+			// 
+			// tabControl
+			// 
+			this.tabControl.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
+									| System.Windows.Forms.AnchorStyles.Left)
+									| System.Windows.Forms.AnchorStyles.Right)));
+			this.tabControl.Controls.Add(this.tabPage1);
+			this.tabControl.Controls.Add(this.tabPage2);
+			this.tabControl.Location = new System.Drawing.Point(0, 0);
+			this.tabControl.Name = &quot;tabControl&quot;;
+			this.tabControl.SelectedIndex = 0;
+			this.tabControl.Size = new System.Drawing.Size(522, 549);
+			this.tabControl.TabIndex = 0;
+			this.tabControl.MouseDown += new System.Windows.Forms.MouseEventHandler(this.tabControl_MouseDown);
+			// 
+			// tabPage1
+			// 
+			this.tabPage1.Controls.Add(this.button1);
+			this.tabPage1.Location = new System.Drawing.Point(4, 22);
+			this.tabPage1.Name = &quot;tabPage1&quot;;
+			this.tabPage1.Padding = new System.Windows.Forms.Padding(3);
+			this.tabPage1.Size = new System.Drawing.Size(514, 523);
+			this.tabPage1.TabIndex = 0;
+			this.tabPage1.Text = &quot;tabPage1&quot;;
+			this.tabPage1.UseVisualStyleBackColor = true;
+			// 
+			// button1
+			// 
+			this.button1.Location = new System.Drawing.Point(0, 0);
+			this.button1.Name = &quot;button1&quot;;
+			this.button1.Size = new System.Drawing.Size(75, 23);
+			this.button1.TabIndex = 0;
+			// 
+			// tabPage2
+			// 
+			this.tabPage2.Location = new System.Drawing.Point(4, 22);
+			this.tabPage2.Name = &quot;tabPage2&quot;;
+			this.tabPage2.Padding = new System.Windows.Forms.Padding(3);
+			this.tabPage2.Size = new System.Drawing.Size(514, 525);
+			this.tabPage2.TabIndex = 1;
+			this.tabPage2.Text = &quot;tabPage2&quot;;
+			this.tabPage2.UseVisualStyleBackColor = true;
+			// 
+			// splitContainer1
+			// 
+			this.splitContainer1.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.splitContainer1.Location = new System.Drawing.Point(0, 24);
+			this.splitContainer1.Name = &quot;splitContainer1&quot;;
+			// 
+			// splitContainer1.Panel1
+			// 
+			this.splitContainer1.Panel1.Controls.Add(this.textBox);
+			this.splitContainer1.Panel1.Controls.Add(this.tabControl);
+			// 
+			// splitContainer1.Panel2
+			// 
+			this.splitContainer1.Panel2.Controls.Add(this.splitContainer2);
+			this.splitContainer1.Size = new System.Drawing.Size(702, 571);
+			this.splitContainer1.SplitterDistance = 522;
+			this.splitContainer1.TabIndex = 8;
+			// 
+			// textBox
+			// 
+			this.textBox.Dock = System.Windows.Forms.DockStyle.Bottom;
+			this.textBox.Location = new System.Drawing.Point(0, 551);
+			this.textBox.Name = &quot;textBox&quot;;
+			this.textBox.Size = new System.Drawing.Size(522, 20);
+			this.textBox.TabIndex = 1;
+			this.textBox.KeyDown += new System.Windows.Forms.KeyEventHandler(this.textBox_KeyDown);
+			// 
+			// splitContainer2
+			// 
+			this.splitContainer2.Dock = System.Windows.Forms.DockStyle.Fill;
+			this.splitContainer2.Location = new System.Drawing.Point(0, 0);
+			this.splitContainer2.Name = &quot;splitContainer2&quot;;
+			this.splitContainer2.Orientation = System.Windows.Forms.Orientation.Horizontal;
+			// 
+			// splitContainer2.Panel1
+			// 
+			this.splitContainer2.Panel1.Controls.Add(this.groupBox1);
+			// 
+			// splitContainer2.Panel2
+			// 
+			this.splitContainer2.Panel2.Controls.Add(this.groupBox2);
+			this.splitContainer2.Size = new System.Drawing.Size(176, 571);
+			this.splitContainer2.SplitterDistance = 217;
+			this.splitContainer2.TabIndex = 0;
+			// 
+			// statusStrip1
+			// 
+			this.statusStrip1.GripStyle = System.Windows.Forms.ToolStripGripStyle.Visible;
+			this.statusStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.toolStripStatusLabel1,
             this.toolStripStatusLabel2,
             this.toolStripStatusLabel3,
             this.toolStripStatusLabel4,
             this.toolStripStatusLabel5});
-      this.statusStrip1.Location = new System.Drawing.Point(0, 597);
-      this.statusStrip1.Name = &quot;statusStrip1&quot;;
-      this.statusStrip1.Size = new System.Drawing.Size(702, 22);
-      this.statusStrip1.TabIndex = 9;
-      // 
-      // toolStripStatusLabel1
-      // 
-      this.toolStripStatusLabel1.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
-      this.toolStripStatusLabel1.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
-      this.toolStripStatusLabel1.Name = &quot;toolStripStatusLabel1&quot;;
-      this.toolStripStatusLabel1.Size = new System.Drawing.Size(20, 17);
-      this.toolStripStatusLabel1.Text = &quot;   &quot;;
-      // 
-      // toolStripStatusLabel2
-      // 
-      this.toolStripStatusLabel2.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
-      this.toolStripStatusLabel2.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
-      this.toolStripStatusLabel2.Name = &quot;toolStripStatusLabel2&quot;;
-      this.toolStripStatusLabel2.Size = new System.Drawing.Size(20, 17);
-      this.toolStripStatusLabel2.Text = &quot;   &quot;;
-      // 
-      // toolStripStatusLabel3
-      // 
-      this.toolStripStatusLabel3.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
-      this.toolStripStatusLabel3.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
-      this.toolStripStatusLabel3.Name = &quot;toolStripStatusLabel3&quot;;
-      this.toolStripStatusLabel3.Size = new System.Drawing.Size(20, 17);
-      this.toolStripStatusLabel3.Text = &quot;   &quot;;
-      // 
-      // toolStripStatusLabel4
-      // 
-      this.toolStripStatusLabel4.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
-      this.toolStripStatusLabel4.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
-      this.toolStripStatusLabel4.Name = &quot;toolStripStatusLabel4&quot;;
-      this.toolStripStatusLabel4.Size = new System.Drawing.Size(20, 17);
-      this.toolStripStatusLabel4.Text = &quot;   &quot;;
-      // 
-      // toolStripStatusLabel5
-      // 
-      this.toolStripStatusLabel5.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
-                  | System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
-      this.toolStripStatusLabel5.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
-      this.toolStripStatusLabel5.Name = &quot;toolStripStatusLabel5&quot;;
-      this.toolStripStatusLabel5.Size = new System.Drawing.Size(20, 17);
-      this.toolStripStatusLabel5.Text = &quot;   &quot;;
-      
-      // 
-      // FormMain
-      // 
-      this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
-      this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
-      this.ClientSize = new System.Drawing.Size(702, 619);
-      this.Controls.Add(this.splitContainer1);
-      this.Controls.Add(this.menuStrip1);
-      this.Controls.Add(this.statusStrip1);
-      this.Icon = ((System.Drawing.Icon)(resources.GetObject(&quot;$this.Icon&quot;)));
-      this.MainMenuStrip = this.menuStrip1;
-      this.MinimumSize = new System.Drawing.Size(500, 499);
-      this.Name = &quot;FormMain&quot;;
-      this.Text = &quot;Springie&quot;;
-      this.SizeChanged += new System.EventHandler(this.Form1_SizeChanged);
-      this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.FormMain_FormClosing);
-      this.Load += new System.EventHandler(this.Form1_Load);
-      this.groupBox2.ResumeLayout(false);
-      this.groupBox1.ResumeLayout(false);
-      this.menuStrip1.ResumeLayout(false);
-      this.menuStrip1.PerformLayout();
-      this.tabControl.ResumeLayout(false);
-      this.tabPage1.ResumeLayout(false);
-      this.splitContainer1.Panel1.ResumeLayout(false);
-      this.splitContainer1.Panel1.PerformLayout();
-      this.splitContainer1.Panel2.ResumeLayout(false);
-      this.splitContainer1.ResumeLayout(false);
-      this.splitContainer2.Panel1.ResumeLayout(false);
-      this.splitContainer2.Panel2.ResumeLayout(false);
-      this.splitContainer2.ResumeLayout(false);
-      this.statusStrip1.ResumeLayout(false);
-      this.statusStrip1.PerformLayout();
-      this.ResumeLayout(false);
-      this.PerformLayout();
+			this.statusStrip1.Location = new System.Drawing.Point(0, 595);
+			this.statusStrip1.Name = &quot;statusStrip1&quot;;
+			this.statusStrip1.Size = new System.Drawing.Size(702, 24);
+			this.statusStrip1.TabIndex = 9;
+			// 
+			// toolStripStatusLabel1
+			// 
+			this.toolStripStatusLabel1.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
+			this.toolStripStatusLabel1.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
+			this.toolStripStatusLabel1.Name = &quot;toolStripStatusLabel1&quot;;
+			this.toolStripStatusLabel1.Size = new System.Drawing.Size(20, 19);
+			this.toolStripStatusLabel1.Text = &quot;   &quot;;
+			// 
+			// toolStripStatusLabel2
+			// 
+			this.toolStripStatusLabel2.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
+			this.toolStripStatusLabel2.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
+			this.toolStripStatusLabel2.Name = &quot;toolStripStatusLabel2&quot;;
+			this.toolStripStatusLabel2.Size = new System.Drawing.Size(20, 19);
+			this.toolStripStatusLabel2.Text = &quot;   &quot;;
+			// 
+			// toolStripStatusLabel3
+			// 
+			this.toolStripStatusLabel3.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
+			this.toolStripStatusLabel3.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
+			this.toolStripStatusLabel3.Name = &quot;toolStripStatusLabel3&quot;;
+			this.toolStripStatusLabel3.Size = new System.Drawing.Size(20, 19);
+			this.toolStripStatusLabel3.Text = &quot;   &quot;;
+			// 
+			// toolStripStatusLabel4
+			// 
+			this.toolStripStatusLabel4.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
+			this.toolStripStatusLabel4.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
+			this.toolStripStatusLabel4.Name = &quot;toolStripStatusLabel4&quot;;
+			this.toolStripStatusLabel4.Size = new System.Drawing.Size(20, 19);
+			this.toolStripStatusLabel4.Text = &quot;   &quot;;
+			// 
+			// toolStripStatusLabel5
+			// 
+			this.toolStripStatusLabel5.BorderSides = ((System.Windows.Forms.ToolStripStatusLabelBorderSides)((((System.Windows.Forms.ToolStripStatusLabelBorderSides.Left | System.Windows.Forms.ToolStripStatusLabelBorderSides.Top)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Right)
+									| System.Windows.Forms.ToolStripStatusLabelBorderSides.Bottom)));
+			this.toolStripStatusLabel5.BorderStyle = System.Windows.Forms.Border3DStyle.SunkenOuter;
+			this.toolStripStatusLabel5.Name = &quot;toolStripStatusLabel5&quot;;
+			this.toolStripStatusLabel5.Size = new System.Drawing.Size(20, 19);
+			this.toolStripStatusLabel5.Text = &quot;   &quot;;
+			// 
+			// FormMain
+			// 
+			this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
+			this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
+			this.ClientSize = new System.Drawing.Size(702, 619);
+			this.Controls.Add(this.splitContainer1);
+			this.Controls.Add(this.menuStrip1);
+			this.Controls.Add(this.statusStrip1);
+			this.Icon = ((System.Drawing.Icon)(resources.GetObject(&quot;$this.Icon&quot;)));
+			this.MainMenuStrip = this.menuStrip1;
+			this.MinimumSize = new System.Drawing.Size(500, 499);
+			this.Name = &quot;FormMain&quot;;
+			this.Text = &quot;Springie&quot;;
+			this.Load += new System.EventHandler(this.Form1_Load);
+			this.SizeChanged += new System.EventHandler(this.Form1_SizeChanged);
+			this.FormClosing += new System.Windows.Forms.FormClosingEventHandler(this.FormMain_FormClosing);
+			this.groupBox2.ResumeLayout(false);
+			this.groupBox1.ResumeLayout(false);
+			this.menuStrip1.ResumeLayout(false);
+			this.menuStrip1.PerformLayout();
+			this.tabControl.ResumeLayout(false);
+			this.tabPage1.ResumeLayout(false);
+			this.splitContainer1.Panel1.ResumeLayout(false);
+			this.splitContainer1.Panel1.PerformLayout();
+			this.splitContainer1.Panel2.ResumeLayout(false);
+			this.splitContainer1.ResumeLayout(false);
+			this.splitContainer2.Panel1.ResumeLayout(false);
+			this.splitContainer2.Panel2.ResumeLayout(false);
+			this.splitContainer2.ResumeLayout(false);
+			this.statusStrip1.ResumeLayout(false);
+			this.statusStrip1.PerformLayout();
+			this.ResumeLayout(false);
+			this.PerformLayout();
 
     }
 
@@ -392,8 +388,7 @@
     private System.Windows.Forms.ToolStripMenuItem actionsToolStripMenuItem;
     private System.Windows.Forms.ToolStripMenuItem rehostToolStripMenuItem;
     private System.Windows.Forms.ToolStripMenuItem springToolStripMenuItem;
-    private System.Windows.Forms.ToolStripMenuItem reloadModsMapsToolStripMenuItem;
-    private System.Windows.Forms.ToolStripMenuItem showhideHostingWindowToolStripMenuItem;
+		private System.Windows.Forms.ToolStripMenuItem reloadModsMapsToolStripMenuItem;
     private System.Windows.Forms.StatusStrip statusStrip1;
     private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel1;
     private System.Windows.Forms.ToolStripStatusLabel toolStripStatusLabel2;

Modified: branches/caiinterface/tools/springie/Springie/FormMain.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/FormMain.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/FormMain.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Diagnostics;
 using System.Drawing;
@@ -6,482 +8,503 @@
 using Springie.Client;
 using Springie.Properties;
 
+#endregion
+
 namespace Springie
 {
-  public partial class FormMain : Form
-  {
-    private bool exitOnSpringExit = false;
-    private ToolStripMenuItem hostingPriorityMenu;
-    private Main main = Program.main;
-    private RichTextBox tBattle;
-    private RichTextBox tServer;
+	public partial class FormMain : Form
+	{
+		#region Fields
 
-    public FormMain()
-    {
-      Program.formMain = this;
-      InitializeComponent();
-    }
+		private bool exitOnSpringExit;
+		private ToolStripMenuItem hostingPriorityMenu;
+		private Main main = Program.main;
+		private RichTextBox tBattle;
+		private RichTextBox tServer;
 
-    public void OnFailure(object sender, TasEventArgs args)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(OnFailure), sender, args);
-      else {
-        string mes = &quot;Command failed:&quot;;
-        tServer.AppendText(mes + Utils.Glue(args.ServerParams.ToArray()) + &quot;\r\n&quot;);
-      }
-    }
+		#endregion
 
+		#region Constructors
 
-    public void OnSaid(object sender, TasSayEventArgs args)
-    {
-      if (InvokeRequired) Invoke(new SayEvent(OnSaid), sender, args);
-      else {
-        switch (args.Place) {
-          case TasSayEventArgs.Places.Broadcast:
-          case TasSayEventArgs.Places.MessageBox:
-          case TasSayEventArgs.Places.Motd:
-            tServer.AppendText(&quot;[&quot; + DateTime.Now.ToString(&quot;T&quot;) + &quot;] &quot; + args.Text + &quot;\r\n&quot;);
-            break;
+		public FormMain()
+		{
+			Program.formMain = this;
+			InitializeComponent();
+		}
 
-          case TasSayEventArgs.Places.Channel:
-            RichTextBox t = GetTab(&quot;#&quot; + args.Channel);
-            t.AppendText(String.Format(&quot;[{0}] &lt;{1}&gt; {2}\r\n&quot;, DateTime.Now.ToString(&quot;T&quot;), args.UserName, args.Text));
-            break;
+		#endregion
 
-          case TasSayEventArgs.Places.Normal:
-            t = GetTab(args.Channel);
-            t.AppendText(String.Format(&quot;[{0}] &lt;{1}&gt; {2}\r\n&quot;, DateTime.Now.ToString(&quot;T&quot;), args.UserName, args.Text));
-            break;
+		#region Public methods
 
-          case TasSayEventArgs.Places.Battle:
-            tBattle.AppendText(String.Format(&quot;[{0}] &lt;{1}&gt; {2}\r\n&quot;, DateTime.Now.ToString(&quot;T&quot;), args.UserName, args.Text));
-            break;
-        }
-      }
-    }
+		public void GetNewLogPass()
+		{
+			if (InvokeRequired) Invoke(new DelegEmpty(GetNewLogPass));
+			else {
+				var p = new FormAccount();
+				p.ShowDialog();
+				if (p.DialogResult == DialogResult.OK) {
+					main.config.AccountName = p.Login;
+					main.config.AccountPassword = p.Password;
+					main.SaveConfig();
+					main.AutoHost.config.PrivilegedUsers.Add(new PrivilegedUser(p.Login, 4));
+					main.AutoHost.SaveConfig();
+					main.ReLogin();
+				}
+			}
+		}
 
+		#endregion
 
-    private RichTextBox GetTab(string name)
-    {
-      if (tabControl.TabPages.ContainsKey(name)) return (RichTextBox)tabControl.TabPages[name].Controls[0];
-      tabControl.TabPages.Add(name, name);
-      RichTextBox rt = new RichTextBox();
-      rt.ForeColor = Color.Black;
-      rt.ReadOnly = true;
-      rt.BackColor = Color.White;
-      rt.Dock = DockStyle.Fill;
-      rt.TextChanged += new EventHandler(rt_TextChanged);
-      tabControl.TabPages[tabControl.TabPages.Count - 1].Controls.Add(rt);
-      return rt;
-    }
+		#region Other methods
 
-    private void rt_TextChanged(object sender, EventArgs e)
-    {
-      RichTextBox rt = (RichTextBox)sender;
-      rt.ScrollToCaret();
-    }
+		private RichTextBox GetTab(string name)
+		{
+			if (tabControl.TabPages.ContainsKey(name)) return (RichTextBox) tabControl.TabPages[name].Controls[0];
+			tabControl.TabPages.Add(name, name);
+			var rt = new RichTextBox();
+			rt.ForeColor = Color.Black;
+			rt.ReadOnly = true;
+			rt.BackColor = Color.White;
+			rt.Dock = DockStyle.Fill;
+			rt.TextChanged += rt_TextChanged;
+			tabControl.TabPages[tabControl.TabPages.Count - 1].Controls.Add(rt);
+			return rt;
+		}
 
-    private void Form1_Load(object sender, EventArgs e)
-    {
-      notifyIcon1.Icon = Resources.err;
-      if (!Program.main.Start()) return;
+		private int GetUserIndex(ListBox lb, string name)
+		{
+			for (int i = 0; i &lt; lb.Items.Count; ++i) if (lb.Items[i].ToString().StartsWith(name + &quot; &quot;)) return i;
+			return -1;
+		}
 
-      main.Tas.Failure += OnFailure;
-      main.Tas.Said += OnSaid;
-      main.Tas.Connected += new EventHandler&lt;TasEventArgs&gt;(Tas_Connected);
-      main.Tas.ConnectionLost += new EventHandler&lt;TasEventArgs&gt;(Tas_ConnectionLost);
-      main.Tas.UserAdded += new EventHandler&lt;TasEventArgs&gt;(Tas_UserAdded);
-      main.Tas.UserRemoved += new EventHandler&lt;TasEventArgs&gt;(Tas_UserRemoved);
-      main.Tas.BattleUserJoined += new EventHandler&lt;TasEventArgs&gt;(Tas_BattleUserJoined);
-      main.Tas.BattleUserStatusChanged += new EventHandler&lt;TasEventArgs&gt;(Tas_BattleUserStatusChanged);
-      main.Tas.UserStatusChanged += new EventHandler&lt;TasEventArgs&gt;(Tas_UserStatusChanged);
+		private string UpdateNameWithCountryAfkAndGame(string name)
+		{
+			User u;
+			if (main.Tas.GetExistingUser(name, out u)) return name + &quot; &lt;&quot; + u.country + &quot;&gt;{&quot; + (u.isAway ? &quot;A&quot; : &quot;&quot;) + (u.isInGame ? &quot;G&quot; : &quot;&quot;) + &quot;}&quot;;
+			else return name + &quot; &quot;;
+		}
 
-      main.Tas.BattleUserLeft += new EventHandler&lt;TasEventArgs&gt;(Tas_BattleUserLeft);
-      main.Tas.ChannelJoined += new EventHandler&lt;TasEventArgs&gt;(Tas_ChannelJoined);
-      main.Tas.ChannelLeft += new EventHandler&lt;TasEventArgs&gt;(Tas_ChannelLeft);
-      main.Tas.BattleClosed += new EventHandler&lt;TasEventArgs&gt;(Tas_BattleClosed);
-      main.Tas.BattleOpened += new EventHandler&lt;TasEventArgs&gt;(Tas_BattleOpened);
-      main.Tas.BattleMapChanged += new EventHandler&lt;TasEventArgs&gt;(Tas_BattleMapChanged);
-      main.Spring.SpringStarted += new EventHandler(Spring_SpringStarted);
-      main.Spring.SpringExited += new EventHandler(Spring_SpringExited);
+		private void UpdateSpringPriorityMenu(ToolStripMenuItem menu, ProcessPriorityClass priority)
+		{
+			foreach (ToolStripMenuItem c in menu.DropDownItems) {
+				// list through priorities
+				if (c.Text == priority.ToString()) {
+					// we found priority, set it up
+					c.Checked = true;
+				} else c.Checked = false;
+			}
+		}
 
-      // hosting priority submenu
-      hostingPriorityMenu = new ToolStripMenuItem(&quot;Hosting priority&quot;);
-      springToolStripMenuItem.DropDownItems.Add(hostingPriorityMenu);
-      foreach (ProcessPriorityClass p in Enum.GetValues((typeof(ProcessPriorityClass)))) {
-        ToolStripMenuItem ts = new ToolStripMenuItem(p.ToString());
-        ts.Click += new EventHandler(ts_PriorityChangeClick);
-        if (p == main.config.HostingProcessPriority) ts.Checked = true;
-        hostingPriorityMenu.DropDownItems.Add(ts);
-      }
-      hostingPriorityMenu.Enabled = false;
+		private void UpdateStatusInfo()
+		{
+			if (InvokeRequired) Invoke(new DelegEmpty(UpdateStatusInfo));
+			else {
+				try {
+					if (!main.Tas.IsLoggedIn) return;
+					var b = main.Tas.GetBattle();
+					if (b == null) return;
 
-      // tabs
-      tabControl.TabPages.Clear();
-      tServer = GetTab(&quot;$server&quot;);
-      tBattle = GetTab(&quot;@battle&quot;);
-    }
+					int players = b.Users.Count - b.CountSpectators();
 
-    private void Tas_BattleUserStatusChanged(object sender, TasEventArgs e)
-    {
-      UpdateStatusInfo();
-    }
+					toolStripStatusLabel1.Text = &quot;on since: &quot; + Program.startupTime.ToString(&quot;g&quot;);
+					toolStripStatusLabel2.Text = &quot;players: &quot; + players + &quot;/&quot; + b.MaxPlayers;
+					toolStripStatusLabel3.Text = &quot;mod: &quot; + b.Mod.Name;
+					toolStripStatusLabel4.Text = &quot;map: &quot; + b.Map.Name;
+					toolStripStatusLabel5.Text = &quot;last game: &quot; + (main.Spring.GameStarted != DateTime.MinValue ? main.Spring.GameStarted.ToString(&quot;g&quot;) : &quot;never&quot;);
 
-    private void Tas_BattleMapChanged(object sender, TasEventArgs e)
-    {
-      UpdateStatusInfo();
-    }
+					if (!main.Spring.IsRunning) {
+						if (players &gt; 0) {
+							if (notifyIcon1.Icon != Resources.joined) notifyIcon1.Icon = Resources.joined;
+						} else if (notifyIcon1.Icon != Resources.ok) notifyIcon1.Icon = Resources.ok;
+					}
 
-    private void Tas_BattleOpened(object sender, TasEventArgs e)
-    {
-      UpdateStatusInfo();
-    }
+					notifyIcon1.Text = players + &quot;/&quot; + b.MaxPlayers + &quot;\r\n&quot; + b.Map.Name + &quot;\r\n&quot; + (main.Spring.GameStarted != DateTime.MinValue ? main.Spring.GameStarted.ToString(&quot;g&quot;) : &quot;never&quot;);
+				} catch {}
+			}
+		}
 
+		#endregion
 
-    private void ts_PriorityChangeClick(object sender, EventArgs e)
-    {
-      ToolStripMenuItem i = sender as ToolStripMenuItem;
-      if (i != null) {
-        ToolStripMenuItem parent = i.OwnerItem as ToolStripMenuItem; // get parent
-        if (parent != null) {
-          ProcessPriorityClass prio = (ProcessPriorityClass)Enum.Parse(typeof(ProcessPriorityClass), i.Text);
-          UpdateSpringPriorityMenu(parent, prio);
-          main.Spring.ProcessPriority = prio;
-        }
-      }
-    }
+		#region Event Handlers
 
-    private void Tas_BattleClosed(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_BattleClosed), sender, e);
-      else listBoxBattle.Items.Clear();
-    }
+		private void currentBattleToolStripMenuItem_Click(object sender, EventArgs e)
+		{
+			var s = new FormCurrentBattle();
+			s.ShowDialog();
+		}
 
-    private void Tas_UserStatusChanged(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_UserStatusChanged), sender, e);
-      else {
-        string nam = e.ServerParams[0];
-        int i = GetUserIndex(listBoxChannel, nam);
-        if (i != -1) listBoxChannel.Items[i] = UpdateNameWithCountryAfkAndGame(nam);
+		private void Form1_Load(object sender, EventArgs e)
+		{
+			notifyIcon1.Icon = Resources.err;
+			if (!Program.main.Start()) return;
 
-        i = GetUserIndex(listBoxBattle, nam);
-        if (i != -1) listBoxBattle.Items[i] = UpdateNameWithCountryAfkAndGame(nam);
-      }
-    }
+			main.Tas.Failure += OnFailure;
+			main.Tas.Said += OnSaid;
+			main.Tas.Connected += Tas_Connected;
+			main.Tas.ConnectionLost += Tas_ConnectionLost;
+			main.Tas.UserAdded += Tas_UserAdded;
+			main.Tas.UserRemoved += Tas_UserRemoved;
+			main.Tas.BattleUserJoined += Tas_BattleUserJoined;
+			main.Tas.BattleUserStatusChanged += Tas_BattleUserStatusChanged;
+			main.Tas.UserStatusChanged += Tas_UserStatusChanged;
 
-    private int GetUserIndex(ListBox lb, string name)
-    {
-      for (int i = 0; i &lt; lb.Items.Count; ++i) if (lb.Items[i].ToString().StartsWith(name + &quot; &quot;)) return i;
-      return -1;
-    }
+			main.Tas.BattleUserLeft += Tas_BattleUserLeft;
+			main.Tas.ChannelJoined += Tas_ChannelJoined;
+			main.Tas.ChannelLeft += Tas_ChannelLeft;
+			main.Tas.BattleClosed += Tas_BattleClosed;
+			main.Tas.BattleOpened += Tas_BattleOpened;
+			main.Tas.BattleMapChanged += Tas_BattleMapChanged;
+			main.Spring.SpringStarted += Spring_SpringStarted;
+			main.Spring.SpringExited += Spring_SpringExited;
 
-    private void Tas_ChannelLeft(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_ChannelLeft), sender, e);
-      else tabControl.TabPages.RemoveByKey(&quot;#&quot; + e.ServerParams[0]);
-    }
+			// hosting priority submenu
+			hostingPriorityMenu = new ToolStripMenuItem(&quot;Hosting priority&quot;);
+			springToolStripMenuItem.DropDownItems.Add(hostingPriorityMenu);
+			foreach (ProcessPriorityClass p in Enum.GetValues((typeof (ProcessPriorityClass)))) {
+				var ts = new ToolStripMenuItem(p.ToString());
+				ts.Click += ts_PriorityChangeClick;
+				if (p == main.config.HostingProcessPriority) ts.Checked = true;
+				hostingPriorityMenu.DropDownItems.Add(ts);
+			}
+			hostingPriorityMenu.Enabled = false;
 
-    private void Tas_ChannelJoined(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_ChannelJoined), sender, e);
-      else GetTab(&quot;#&quot; + e.ServerParams[0]);
-    }
+			// tabs
+			tabControl.TabPages.Clear();
+			tServer = GetTab(&quot;$server&quot;);
+			tBattle = GetTab(&quot;@battle&quot;);
+		}
 
-    private void Tas_ConnectionLost(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_ConnectionLost), sender, e);
-      else {
-        notifyIcon1.Icon = Resources.err;
-        listBoxBattle.Items.Clear();
-        listBoxChannel.Items.Clear();
-        rehostToolStripMenuItem.Enabled = false;
-      }
-    }
+		private void Form1_SizeChanged(object sender, EventArgs e)
+		{
+			if (WindowState == FormWindowState.Minimized) Visible = false;
+		}
 
-    private void Spring_SpringExited(object sender, EventArgs e)
-    {
-      if (InvokeRequired) Invoke(new Event(Spring_SpringExited), sender, e);
-      else {
-        notifyIcon1.Icon = Resources.ok;
-        foreach (ToolStripMenuItem t in springToolStripMenuItem.DropDownItems) t.Enabled = false;
-        if (exitOnSpringExit) Close();
+		private void FormMain_FormClosing(object sender, FormClosingEventArgs e)
+		{
+			try {
+				if (e.CloseReason == CloseReason.UserClosing &amp;&amp; main.Spring.IsRunning) {
+					var res = MessageBox.Show(&quot;You are currently hosting a game, do you want to wait till game end and then exit springie?&quot;, &quot;Game in progress&quot;, MessageBoxButtons.YesNoCancel);
+					exitOnSpringExit = false;
+					if (res == DialogResult.No) main.Stop();
+					else if (res == DialogResult.Cancel) {
+						e.Cancel = true;
+						return;
+					} else if (res == DialogResult.Yes) {
+						exitOnSpringExit = true;
+						e.Cancel = true;
+						return;
+					}
+				} else main.Stop();
+			} catch {}
+		}
 
-        UpdateStatusInfo();
-      }
-    }
+		private void listBox_SelectedIndexChanged(object sender, EventArgs e)
+		{
+			var l = (ListBox) sender;
+			string name = l.SelectedItem as string;
+			if (string.IsNullOrEmpty(name)) return;
+			name = (name.Split(' '))[0];
+			GetTab(name);
+			tabControl.SelectedTab = tabControl.TabPages[name];
+		}
 
-    private void Spring_SpringStarted(object sender, EventArgs e)
-    {
-      if (InvokeRequired) Invoke(new Event(Spring_SpringStarted), sender, e);
-      else {
-        notifyIcon1.Icon = Resources.run;
+		private void notifyIcon1_Click(object sender, EventArgs e)
+		{
+			if (WindowState == FormWindowState.Minimized) {
+				Visible = true;
+				WindowState = FormWindowState.Normal;
+			} else {
+				WindowState = FormWindowState.Minimized;
+				Visible = false;
+			}
+		}
 
-        foreach (ToolStripMenuItem t in springToolStripMenuItem.DropDownItems) t.Enabled = true;
-        UpdateSpringPriorityMenu(hostingPriorityMenu, main.config.HostingProcessPriority);
+		public void OnFailure(object sender, TasEventArgs args)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(OnFailure), sender, args);
+			else {
+				string mes = &quot;Command failed:&quot;;
+				tServer.AppendText(mes + Utils.Glue(args.ServerParams.ToArray()) + &quot;\r\n&quot;);
+			}
+		}
 
-        UpdateStatusInfo();
-      }
-    }
 
+		public void OnSaid(object sender, TasSayEventArgs args)
+		{
+			if (InvokeRequired) Invoke(new SayEvent(OnSaid), sender, args);
+			else {
+				switch (args.Place) {
+					case TasSayEventArgs.Places.Broadcast:
+					case TasSayEventArgs.Places.MessageBox:
+					case TasSayEventArgs.Places.Motd:
+						tServer.AppendText(&quot;[&quot; + DateTime.Now.ToString(&quot;T&quot;) + &quot;] &quot; + args.Text + &quot;\r\n&quot;);
+						break;
 
-    private void UpdateSpringPriorityMenu(ToolStripMenuItem menu, ProcessPriorityClass priority)
-    {
-      foreach (ToolStripMenuItem c in menu.DropDownItems) {
-        // list through priorities
-        if (c.Text == priority.ToString()) {
-          // we found priority, set it up
-          c.Checked = true;
-        } else c.Checked = false;
-      }
-    }
+					case TasSayEventArgs.Places.Channel:
+						var t = GetTab(&quot;#&quot; + args.Channel);
+						t.AppendText(String.Format(&quot;[{0}] &lt;{1}&gt; {2}\r\n&quot;, DateTime.Now.ToString(&quot;T&quot;), args.UserName, args.Text));
+						break;
 
-    private void Tas_BattleUserLeft(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_BattleUserLeft), sender, e);
-      else {
-        UpdateStatusInfo();
-        int i = GetUserIndex(listBoxBattle, e.ServerParams[0]);
-        if (i != -1) listBoxBattle.Items.RemoveAt(i);
-      }
-    }
+					case TasSayEventArgs.Places.Normal:
+						t = GetTab(args.Channel);
+						t.AppendText(String.Format(&quot;[{0}] &lt;{1}&gt; {2}\r\n&quot;, DateTime.Now.ToString(&quot;T&quot;), args.UserName, args.Text));
+						break;
 
-    private void Tas_BattleUserJoined(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_BattleUserJoined), sender, e);
-      else {
-        UpdateStatusInfo();
-        string nam = e.ServerParams[0];
-        for (int i = 0; i &lt; listBoxBattle.Items.Count; ++i) {
-          if (nam.CompareTo(listBoxBattle.Items[i].ToString()) == -1) {
-            listBoxBattle.Items.Insert(i, UpdateNameWithCountryAfkAndGame(nam));
-            return;
-          }
-        }
-        listBoxBattle.Items.Add(UpdateNameWithCountryAfkAndGame(nam));
-      }
-    }
+					case TasSayEventArgs.Places.Battle:
+						tBattle.AppendText(String.Format(&quot;[{0}] &lt;{1}&gt; {2}\r\n&quot;, DateTime.Now.ToString(&quot;T&quot;), args.UserName, args.Text));
+						break;
+				}
+			}
+		}
 
-    private void Tas_UserRemoved(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_UserRemoved), sender, e);
-      else {
-        int i = GetUserIndex(listBoxChannel, e.ServerParams[0]);
-        if (i != -1) listBoxChannel.Items.RemoveAt(i);
-      }
-    }
+		private void rehostToolStripMenuItem_Click(object sender, EventArgs e)
+		{
+			if (!main.Tas.IsConnected || !main.Tas.IsLoggedIn) main.ReLogin();
+			else main.AutoHost.ComRehost(TasSayEventArgs.Default, new string[] {});
+		}
 
+		private void reloadModsMapsToolStripMenuItem_Click(object sender, EventArgs e)
+		{
+			main.Spring.Reload(true, true);
+		}
 
-    private string UpdateNameWithCountryAfkAndGame(string name)
-    {
-      User u;
-      if (main.Tas.GetExistingUser(name, out u)) return name + &quot; &lt;&quot; + u.country + &quot;&gt;{&quot; + (u.isAway ? &quot;A&quot; : &quot;&quot;) + (u.isInGame ? &quot;G&quot; : &quot;&quot;) + &quot;}&quot;;
-      else return name + &quot; &quot;;
-    }
 
+		private void rt_TextChanged(object sender, EventArgs e)
+		{
+			var rt = (RichTextBox) sender;
+			rt.ScrollToCaret();
+		}
 
-    private void Tas_UserAdded(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_UserAdded), sender, e);
-      else {
-        string nam = e.ServerParams[0];
-        for (int i = 0; i &lt; listBoxChannel.Items.Count; ++i) {
-          if (nam.CompareTo(listBoxChannel.Items[i].ToString()) == -1) {
-            listBoxChannel.Items.Insert(i, UpdateNameWithCountryAfkAndGame(nam));
-            return;
-          }
-        }
-        listBoxChannel.Items.Add(UpdateNameWithCountryAfkAndGame(nam));
-      }
-    }
+		private void settingsToolStripMenuItem_Click(object sender, EventArgs e)
+		{
+			var s = new FormSettings();
+			if (s.ShowDialog() == DialogResult.OK) {
+				main.SaveConfig();
+				main.AutoHost.SaveConfig();
+			}
+		}
 
+		private void Spring_SpringExited(object sender, EventArgs e)
+		{
+			if (InvokeRequired) Invoke(new Event(Spring_SpringExited), sender, e);
+			else {
+				notifyIcon1.Icon = Resources.ok;
+				foreach (ToolStripMenuItem t in springToolStripMenuItem.DropDownItems) t.Enabled = false;
+				if (exitOnSpringExit) Close();
 
-    private void Tas_Connected(object sender, TasEventArgs e)
-    {
-      if (InvokeRequired) Invoke(new TasEvent(Tas_Connected), sender, e);
-      else {
-        tServer.AppendText(&quot;Connected to server\r\n&quot;);
-        notifyIcon1.Icon = Resources.ok;
-        rehostToolStripMenuItem.Enabled = true;
-      }
-    }
+				UpdateStatusInfo();
+			}
+		}
 
+		private void Spring_SpringStarted(object sender, EventArgs e)
+		{
+			if (InvokeRequired) Invoke(new Event(Spring_SpringStarted), sender, e);
+			else {
+				notifyIcon1.Icon = Resources.run;
 
-    private void textBox_KeyDown(object sender, KeyEventArgs e)
-    {
-      if (e.KeyCode == Keys.Enter &amp;&amp; textBox.Text.Length &gt; 0) {
-        if (!main.Tas.IsConnected) return;
-        string tab = tabControl.SelectedTab.Name;
-        switch (tab[0]) {
-          case '@':
-            main.Tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, textBox.Text, false);
-            if (main.config.RedirectGameChat) main.Spring.SayGame(textBox.Text);
-            break;
-          case '#':
-            main.Tas.Say(TasClient.SayPlace.Channel, tab.Substring(1), textBox.Text, false);
-            break;
-          case '$':
-            return;
-          default:
-            User u;
-            if (!main.Tas.GetExistingUser(tab, out u)) GetTab(tab).AppendText(&quot;ERROR: user left\r\n&quot;);
-            else main.Tas.Say(TasClient.SayPlace.User, tab, textBox.Text, false);
-            break;
-        }
-        textBox.Text = &quot;&quot;;
-      }
-    }
+				foreach (ToolStripMenuItem t in springToolStripMenuItem.DropDownItems) t.Enabled = true;
+				UpdateSpringPriorityMenu(hostingPriorityMenu, main.config.HostingProcessPriority);
 
-    private void listBox_SelectedIndexChanged(object sender, EventArgs e)
-    {
-      ListBox l = (ListBox)sender;
-      string name = l.SelectedItem as string;
-      if (string.IsNullOrEmpty(name)) return;
-      name = (name.Split(' '))[0];
-      GetTab(name);
-      tabControl.SelectedTab = tabControl.TabPages[name];
-    }
+				UpdateStatusInfo();
+			}
+		}
 
+		private void tabControl_MouseDown(object sender, MouseEventArgs e)
+		{
+			if (e.Button == MouseButtons.Right) {
+				int ind = 0;
+				for (int i = 0; i &lt; tabControl.TabPages.Count; i++) {
+					if (tabControl.GetTabRect(i).Contains(e.Location)) {
+						ind = i;
+						break;
+					}
+				}
+				if (ind &gt; 1 &amp;&amp; ind &lt; tabControl.TabCount) if (tabControl.TabPages[ind].Name[0] != '#') tabControl.TabPages.RemoveAt(ind);
+			}
+		}
 
-    private void tabControl_MouseDown(object sender, MouseEventArgs e)
-    {
-      if (e.Button == MouseButtons.Right) {
-        int ind = 0;
-        for (int i = 0; i &lt; tabControl.TabPages.Count; i++) {
-          if (tabControl.GetTabRect(i).Contains(e.Location)) {
-            ind = i;
-            break;
-          }
-        }
-        if (ind &gt; 1 &amp;&amp; ind &lt; tabControl.TabCount) if (tabControl.TabPages[ind].Name[0] != '#') tabControl.TabPages.RemoveAt(ind);
-      }
-    }
+		private void Tas_BattleClosed(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_BattleClosed), sender, e);
+			else listBoxBattle.Items.Clear();
+		}
 
-    private void notifyIcon1_Click(object sender, EventArgs e)
-    {
-      if (WindowState == FormWindowState.Minimized) {
-        Visible = true;
-        WindowState = FormWindowState.Normal;
-      } else {
-        WindowState = FormWindowState.Minimized;
-        Visible = false;
-      }
-    }
+		private void Tas_BattleMapChanged(object sender, TasEventArgs e)
+		{
+			UpdateStatusInfo();
+		}
 
+		private void Tas_BattleOpened(object sender, TasEventArgs e)
+		{
+			UpdateStatusInfo();
+		}
 
-    private void Form1_SizeChanged(object sender, EventArgs e)
-    {
-      if (WindowState == FormWindowState.Minimized) Visible = false;
-    }
+		private void Tas_BattleUserJoined(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_BattleUserJoined), sender, e);
+			else {
+				UpdateStatusInfo();
+				string nam = e.ServerParams[0];
+				for (int i = 0; i &lt; listBoxBattle.Items.Count; ++i) {
+					if (nam.CompareTo(listBoxBattle.Items[i].ToString()) == -1) {
+						listBoxBattle.Items.Insert(i, UpdateNameWithCountryAfkAndGame(nam));
+						return;
+					}
+				}
+				listBoxBattle.Items.Add(UpdateNameWithCountryAfkAndGame(nam));
+			}
+		}
 
+		private void Tas_BattleUserLeft(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_BattleUserLeft), sender, e);
+			else {
+				UpdateStatusInfo();
+				int i = GetUserIndex(listBoxBattle, e.ServerParams[0]);
+				if (i != -1) listBoxBattle.Items.RemoveAt(i);
+			}
+		}
 
-    public void GetNewLogPass()
-    {
-      if (InvokeRequired) Invoke(new DelegEmpty(GetNewLogPass));
-      else {
-        FormAccount p = new FormAccount();
-        p.ShowDialog();
-        if (p.DialogResult == DialogResult.OK) {
-          main.config.AccountName = p.Login;
-          main.config.AccountPassword = p.Password;
-          main.SaveConfig();
-          main.AutoHost.config.PrivilegedUsers.Add(new PrivilegedUser(p.Login, 4));
-          main.AutoHost.SaveConfig();
-          main.ReLogin();
-        }
-      }
-    }
+		private void Tas_BattleUserStatusChanged(object sender, TasEventArgs e)
+		{
+			UpdateStatusInfo();
+		}
 
-    private void FormMain_FormClosing(object sender, FormClosingEventArgs e)
-    {
-      try {
-        if (e.CloseReason == CloseReason.UserClosing &amp;&amp; main.Spring.IsRunning) {
-          DialogResult res = MessageBox.Show(&quot;You are currently hosting a game, do you want to wait till game end and then exit springie?&quot;, &quot;Game in progress&quot;, MessageBoxButtons.YesNoCancel);
-          exitOnSpringExit = false;
-          if (res == DialogResult.No) main.Stop();
-          else if (res == DialogResult.Cancel) {
-            e.Cancel = true;
-            return;
-          } else if (res == DialogResult.Yes) {
-            exitOnSpringExit = true;
-            e.Cancel = true;
-            return;
-          }
-        } else main.Stop();
-      } catch {}
-    }
 
+		private void Tas_ChannelJoined(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_ChannelJoined), sender, e);
+			else GetTab(&quot;#&quot; + e.ServerParams[0]);
+		}
 
-    private void settingsToolStripMenuItem_Click(object sender, EventArgs e)
-    {
-      FormSettings s = new FormSettings();
-      if (s.ShowDialog() == DialogResult.OK) {
-        main.SaveConfig();
-        main.AutoHost.SaveConfig();
-      }
-    }
+		private void Tas_ChannelLeft(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_ChannelLeft), sender, e);
+			else tabControl.TabPages.RemoveByKey(&quot;#&quot; + e.ServerParams[0]);
+		}
 
-    private void rehostToolStripMenuItem_Click(object sender, EventArgs e)
-    {
-      if (!main.Tas.IsConnected || !main.Tas.IsLoggedIn) main.ReLogin();
-      else main.AutoHost.ComRehost(TasSayEventArgs.Default, new string[] {});
-    }
+		private void Tas_Connected(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_Connected), sender, e);
+			else {
+				tServer.AppendText(&quot;Connected to server\r\n&quot;);
+				notifyIcon1.Icon = Resources.ok;
+				rehostToolStripMenuItem.Enabled = true;
+			}
+		}
 
-    private void reloadModsMapsToolStripMenuItem_Click(object sender, EventArgs e)
-    {
-      main.Spring.Reload(true, true);
-    }
+		private void Tas_ConnectionLost(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_ConnectionLost), sender, e);
+			else {
+				notifyIcon1.Icon = Resources.err;
+				listBoxBattle.Items.Clear();
+				listBoxChannel.Items.Clear();
+				rehostToolStripMenuItem.Enabled = false;
+			}
+		}
 
 
+		private void Tas_UserAdded(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_UserAdded), sender, e);
+			else {
+				string nam = e.ServerParams[0];
+				for (int i = 0; i &lt; listBoxChannel.Items.Count; ++i) {
+					if (nam.CompareTo(listBoxChannel.Items[i].ToString()) == -1) {
+						listBoxChannel.Items.Insert(i, UpdateNameWithCountryAfkAndGame(nam));
+						return;
+					}
+				}
+				listBoxChannel.Items.Add(UpdateNameWithCountryAfkAndGame(nam));
+			}
+		}
 
-    private void UpdateStatusInfo()
-    {
-      if (InvokeRequired) Invoke(new DelegEmpty(UpdateStatusInfo));
-      else {
-        try {
-          if (!main.Tas.IsLoggedIn) return;
-          Battle b = main.Tas.GetBattle();
-          if (b == null) return;
+		private void Tas_UserRemoved(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_UserRemoved), sender, e);
+			else {
+				int i = GetUserIndex(listBoxChannel, e.ServerParams[0]);
+				if (i != -1) listBoxChannel.Items.RemoveAt(i);
+			}
+		}
 
-          int players = b.Users.Count - b.CountSpectators();
+		private void Tas_UserStatusChanged(object sender, TasEventArgs e)
+		{
+			if (InvokeRequired) Invoke(new TasEvent(Tas_UserStatusChanged), sender, e);
+			else {
+				string nam = e.ServerParams[0];
+				int i = GetUserIndex(listBoxChannel, nam);
+				if (i != -1) listBoxChannel.Items[i] = UpdateNameWithCountryAfkAndGame(nam);
 
-          toolStripStatusLabel1.Text = &quot;on since: &quot; + Program.startupTime.ToString(&quot;g&quot;);
-          toolStripStatusLabel2.Text = &quot;players: &quot; + players + &quot;/&quot; + b.MaxPlayers;
-          toolStripStatusLabel3.Text = &quot;mod: &quot; + b.Mod.Name;
-          toolStripStatusLabel4.Text = &quot;map: &quot; + b.Map.Name;
-          toolStripStatusLabel5.Text = &quot;last game: &quot; + (main.Spring.GameStarted != DateTime.MinValue ? main.Spring.GameStarted.ToString(&quot;g&quot;) : &quot;never&quot;);
+				i = GetUserIndex(listBoxBattle, nam);
+				if (i != -1) listBoxBattle.Items[i] = UpdateNameWithCountryAfkAndGame(nam);
+			}
+		}
 
-          if (!main.Spring.IsRunning) {
-            if (players &gt; 0) {
-              if (notifyIcon1.Icon != Resources.joined) notifyIcon1.Icon = Resources.joined;
-            } else if (notifyIcon1.Icon != Resources.ok) notifyIcon1.Icon = Resources.ok;
-          }
 
-          notifyIcon1.Text = players + &quot;/&quot; + b.MaxPlayers + &quot;\r\n&quot; + b.Map.Name + &quot;\r\n&quot; + (main.Spring.GameStarted != DateTime.MinValue ? main.Spring.GameStarted.ToString(&quot;g&quot;) : &quot;never&quot;);
-        } catch {}
-      }
-    }
+		private void textBox_KeyDown(object sender, KeyEventArgs e)
+		{
+			if (e.KeyCode == Keys.Enter &amp;&amp; textBox.Text.Length &gt; 0) {
+				if (!main.Tas.IsConnected) return;
+				string tab = tabControl.SelectedTab.Name;
+				switch (tab[0]) {
+					case '@':
+						main.Tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, textBox.Text, false);
+						if (main.config.RedirectGameChat) main.Spring.SayGame(textBox.Text);
+						break;
+					case '#':
+						main.Tas.Say(TasClient.SayPlace.Channel, tab.Substring(1), textBox.Text, false);
+						break;
+					case '$':
+						return;
+					default:
+						User u;
+						if (!main.Tas.GetExistingUser(tab, out u)) GetTab(tab).AppendText(&quot;ERROR: user left\r\n&quot;);
+						else main.Tas.Say(TasClient.SayPlace.User, tab, textBox.Text, false);
+						break;
+				}
+				textBox.Text = &quot;&quot;;
+			}
+		}
 
-    private void currentBattleToolStripMenuItem_Click(object sender, EventArgs e)
-    {
-      FormCurrentBattle s = new FormCurrentBattle();
-      s.ShowDialog();
-    }
+		private void ts_PriorityChangeClick(object sender, EventArgs e)
+		{
+			var i = sender as ToolStripMenuItem;
+			if (i != null) {
+				var parent = i.OwnerItem as ToolStripMenuItem; // get parent
+				if (parent != null) {
+					var prio = (ProcessPriorityClass) Enum.Parse(typeof (ProcessPriorityClass), i.Text);
+					UpdateSpringPriorityMenu(parent, prio);
+					main.Spring.ProcessPriority = prio;
+				}
+			}
+		}
 
-    #region Nested type: DelegEmpty
-    private delegate void DelegEmpty();
-    #endregion
+		#endregion
 
-    #region Nested type: Event
-    private delegate void Event(object sender, EventArgs args);
-    #endregion
+		#region Nested type: DelegEmpty
 
-    #region Nested type: SayEvent
-    private delegate void SayEvent(object sender, TasSayEventArgs args);
-    #endregion
+		private delegate void DelegEmpty();
 
-    #region Nested type: TasEvent
-    private delegate void TasEvent(object sender, TasEventArgs args);
-    #endregion
-  }
+		#endregion
+
+		#region Nested type: Event
+
+		private delegate void Event(object sender, EventArgs args);
+
+		#endregion
+
+		#region Nested type: SayEvent
+
+		private delegate void SayEvent(object sender, TasSayEventArgs args);
+
+		#endregion
+
+		#region Nested type: TasEvent
+
+		private delegate void TasEvent(object sender, TasEventArgs args);
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/FormSettings.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/FormSettings.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/FormSettings.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Windows.Forms;
 using Springie.autohost;
@@ -2,128 +4,138 @@
 
+#endregion
+
 namespace Springie
 {
-  public partial class FormSettings : Form
-  {
-    public FormSettings()
-    {
-      InitializeComponent();
-    }
+	public partial class FormSettings : Form
+	{
+		#region Constructors
 
-    private void FormSettings_Load(object sender, EventArgs e)
-    {
-      propertyGrid1.SelectedObject = Program.main.config;
-      propertyGrid2.SelectedObject = Program.main.AutoHost.config;
+		public FormSettings()
+		{
+			InitializeComponent();
+		}
 
-      foreach (CommandConfig c in Program.main.AutoHost.config.Commands) listBox1.Items.Add(c.Name);
+		#endregion
 
-      propertyGrid5.TextChanged += new EventHandler(propertyGrid5_TextChanged);
-      LoadAdmins();
-      LoadPresets();
-    }
+		/************************************************************************/
+		/*      ADMINS                                                          */
+		/************************************************************************/
 
-    private void propertyGrid5_TextChanged(object sender, EventArgs e)
-    {
-      LoadAdmins();
-    }
+		#region Other methods
 
+		private void LoadAdmins()
+		{
+			listBoxAdmins.Items.Clear();
+			listBoxAdmins.Items.Add(&quot;[ Add new admin... ]&quot;);
+			foreach (var p in Program.main.AutoHost.config.PrivilegedUsers) listBoxAdmins.Items.Add(p.Name);
+		}
 
-    private void listBox1_SelectedIndexChanged(object sender, EventArgs e)
-    {
-      propertyGrid4.SelectedObject = Program.main.AutoHost.config.Commands[listBox1.SelectedIndex];
-    }
+		private void LoadPresets()
+		{
+			listBoxPresets.Items.Clear();
+			listBoxPresets.Items.Add(&quot;[ Add new preset... ]&quot;);
+			foreach (var p in Program.main.AutoHost.presets) listBoxPresets.Items.Add(p.Name);
+		}
 
+		#endregion
 
-    /************************************************************************/
-    /*      ADMINS                                                          */
-    /************************************************************************/
+		#region Event Handlers
 
-    private void LoadAdmins()
-    {
-      listBoxAdmins.Items.Clear();
-      listBoxAdmins.Items.Add(&quot;[ Add new admin... ]&quot;);
-      foreach (PrivilegedUser p in Program.main.AutoHost.config.PrivilegedUsers) listBoxAdmins.Items.Add(p.Name);
-    }
+		private void buttonAdd_Click(object sender, EventArgs e)
+		{
+			var pu = propertyGrid5.SelectedObject as PrivilegedUser;
+			if (!String.IsNullOrEmpty(pu.Name)) {
+				Program.main.AutoHost.config.PrivilegedUsers.Add((PrivilegedUser) propertyGrid5.SelectedObject);
+				propertyGrid5.SelectedObject = new PrivilegedUser();
+				LoadAdmins();
+				buttonAdd.Visible = false;
+			}
+		}
 
+		private void buttonDelete_Click(object sender, EventArgs e)
+		{
+			if (listBoxAdmins.SelectedIndex &gt; 0) {
+				Program.main.AutoHost.config.PrivilegedUsers.RemoveAt(listBoxAdmins.SelectedIndex - 1);
+				LoadAdmins();
+				buttonDelete.Visible = false;
+			}
+		}
 
-    private void listBoxAdmins_SelectedIndexChanged(object sender, EventArgs e)
-    {
-      if (listBoxAdmins.SelectedIndex == -1) return;
-      if (listBoxAdmins.SelectedIndex == 0) {
-        propertyGrid5.SelectedObject = new PrivilegedUser();
-        buttonDelete.Visible = false;
-        buttonAdd.Visible = true;
-      } else {
-        propertyGrid5.SelectedObject = Program.main.AutoHost.config.PrivilegedUsers[listBoxAdmins.SelectedIndex - 1];
-        buttonDelete.Visible = true;
-        buttonAdd.Visible = false;
-      }
-    }
 
-    private void buttonAdd_Click(object sender, EventArgs e)
-    {
-      PrivilegedUser pu = propertyGrid5.SelectedObject as PrivilegedUser;
-      if (!String.IsNullOrEmpty(pu.Name)) {
-        Program.main.AutoHost.config.PrivilegedUsers.Add((PrivilegedUser)propertyGrid5.SelectedObject);
-        propertyGrid5.SelectedObject = new PrivilegedUser();
-        LoadAdmins();
-        buttonAdd.Visible = false;
-      }
-    }
+		/************************************************************************/
+		/*    PRESETS                                                           */
+		/************************************************************************/
 
-    private void buttonDelete_Click(object sender, EventArgs e)
-    {
-      if (listBoxAdmins.SelectedIndex &gt; 0) {
-        Program.main.AutoHost.config.PrivilegedUsers.RemoveAt(listBoxAdmins.SelectedIndex - 1);
-        LoadAdmins();
-        buttonDelete.Visible = false;
-      }
-    }
+		private void buttonPresetAdd_Click(object sender, EventArgs e)
+		{
+			var pu = propertyPreset.SelectedObject as Preset;
+			if (!String.IsNullOrEmpty(pu.Name)) {
+				Program.main.AutoHost.presets.Add((Preset) propertyPreset.SelectedObject);
+				propertyPreset.SelectedObject = new Preset();
+				LoadPresets();
+				buttonPresetAdd.Visible = false;
+			}
+		}
 
+		private void buttonPresetDelete_Click(object sender, EventArgs e)
+		{
+			if (listBoxPresets.SelectedIndex &gt; 0) {
+				Program.main.AutoHost.presets.RemoveAt(listBoxPresets.SelectedIndex - 1);
+				LoadPresets();
+				buttonPresetDelete.Visible = false;
+			}
+		}
 
-    /************************************************************************/
-    /*    PRESETS                                                           */
-    /************************************************************************/
+		private void FormSettings_Load(object sender, EventArgs e)
+		{
+			propertyGrid1.SelectedObject = Program.main.config;
+			propertyGrid2.SelectedObject = Program.main.AutoHost.config;
 
-    private void LoadPresets()
-    {
-      listBoxPresets.Items.Clear();
-      listBoxPresets.Items.Add(&quot;[ Add new preset... ]&quot;);
-      foreach (Preset p in Program.main.AutoHost.presets) listBoxPresets.Items.Add(p.Name);
-    }
+			foreach (var c in Program.main.AutoHost.config.Commands) listBox1.Items.Add(c.Name);
 
+			propertyGrid5.TextChanged += propertyGrid5_TextChanged;
+			LoadAdmins();
+			LoadPresets();
+		}
 
-    private void listBoxPresets_SelectedIndexChanged(object sender, EventArgs e)
-    {
-      if (listBoxPresets.SelectedIndex == -1) return;
-      if (listBoxPresets.SelectedIndex == 0) {
-        propertyPreset.SelectedObject = new Preset();
-        buttonPresetDelete.Visible = false;
-        buttonPresetAdd.Visible = true;
-      } else {
-        propertyPreset.SelectedObject = Program.main.AutoHost.presets[listBoxPresets.SelectedIndex - 1];
-        buttonPresetDelete.Visible = true;
-        buttonPresetAdd.Visible = false;
-      }
-    }
+		private void listBox1_SelectedIndexChanged(object sender, EventArgs e)
+		{
+			propertyGrid4.SelectedObject = Program.main.AutoHost.config.Commands[listBox1.SelectedIndex];
+		}
 
-    private void buttonPresetAdd_Click(object sender, EventArgs e)
-    {
-      Preset pu = propertyPreset.SelectedObject as Preset;
-      if (!String.IsNullOrEmpty(pu.Name)) {
-        Program.main.AutoHost.presets.Add((Preset)propertyPreset.SelectedObject);
-        propertyPreset.SelectedObject = new Preset();
-        LoadPresets();
-        buttonPresetAdd.Visible = false;
-      }
-    }
+		private void listBoxAdmins_SelectedIndexChanged(object sender, EventArgs e)
+		{
+			if (listBoxAdmins.SelectedIndex == -1) return;
+			if (listBoxAdmins.SelectedIndex == 0) {
+				propertyGrid5.SelectedObject = new PrivilegedUser();
+				buttonDelete.Visible = false;
+				buttonAdd.Visible = true;
+			} else {
+				propertyGrid5.SelectedObject = Program.main.AutoHost.config.PrivilegedUsers[listBoxAdmins.SelectedIndex - 1];
+				buttonDelete.Visible = true;
+				buttonAdd.Visible = false;
+			}
+		}
 
-    private void buttonPresetDelete_Click(object sender, EventArgs e)
-    {
-      if (listBoxPresets.SelectedIndex &gt; 0) {
-        Program.main.AutoHost.presets.RemoveAt(listBoxPresets.SelectedIndex - 1);
-        LoadPresets();
-        buttonPresetDelete.Visible = false;
-      }
-    }
-  }
+		private void listBoxPresets_SelectedIndexChanged(object sender, EventArgs e)
+		{
+			if (listBoxPresets.SelectedIndex == -1) return;
+			if (listBoxPresets.SelectedIndex == 0) {
+				propertyPreset.SelectedObject = new Preset();
+				buttonPresetDelete.Visible = false;
+				buttonPresetAdd.Visible = true;
+			} else {
+				propertyPreset.SelectedObject = Program.main.AutoHost.presets[listBoxPresets.SelectedIndex - 1];
+				buttonPresetDelete.Visible = true;
+				buttonPresetAdd.Visible = false;
+			}
+		}
+
+		private void propertyGrid5_TextChanged(object sender, EventArgs e)
+		{
+			LoadAdmins();
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/Main.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/Main.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/Main.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.IO;
 using System.Timers;
@@ -3,213 +5,254 @@
 using System.Windows.Forms;
 using System.Xml.Serialization;
+using PlanetWarsShared.Springie;
 using Springie.autohost;
 using Springie.Client;
 using Springie.SpringNamespace;
 using Timer=System.Timers.Timer;
 
+#endregion
+
 namespace Springie
 {
-  public class Main
-  {
-    public const string ConfigMain = &quot;main.xml&quot;;
-    private AutoHost autoHost;
-    private AutoUpdater autoUpdater;
-    public MainConfig config;
-    private Timer recon;
-    private Spring spring;
+	public class Main
+	{
+		#region Constants
 
-    private Stats stats;
+		public const string ConfigMain = &quot;main.xml&quot;;
 
-    private TasClient tas;
+		#endregion
 
-    public Main()
-    {
-      LoadConfig();
-      SaveConfig();
-    }
+		#region Fields
 
-    public Stats Stats
-    {
-      get { return stats; }
-    }
+		private AutoHost autoHost;
+		private AutoUpdater autoUpdater;
+		private Timer recon;
+		private Spring spring;
 
-    public TasClient Tas
-    {
-      get { return tas; }
-    }
+		private Stats stats;
 
-    public Spring Spring
-    {
-      get { return spring; }
-    }
+		private TasClient tas;
 
-    public AutoHost AutoHost
-    {
-      get { return autoHost; }
-    }
+		#endregion
 
-    public void LoadConfig()
-    {
-      config = new MainConfig();
-      if (File.Exists(Application.StartupPath + '/' + ConfigMain)) {
-        XmlSerializer s = new XmlSerializer(config.GetType());
-        StreamReader r = File.OpenText(Application.StartupPath + '/' + ConfigMain);
-        config = (MainConfig)s.Deserialize(r);
-        r.Close();
-      }
-    }
+		#region Properties
 
-    public void SaveConfig()
-    {
-      XmlSerializer s = new XmlSerializer(config.GetType());
-      FileStream f = File.OpenWrite(Application.StartupPath + '/' + ConfigMain);
-      f.SetLength(0);
-      s.Serialize(f, config);
-      f.Close();
-    }
+		public AutoHost AutoHost
+		{
+			get { return autoHost; }
+		}
 
-    public bool Start()
-    {
-      if (config.AttemptToRecconnect) {
-        recon = new Timer(config.AttemptReconnectInterval*1000);
-        recon.Elapsed += new ElapsedEventHandler(recon_Elapsed);
-      }
+		public MainConfig config;
+		public ISpringieServer PlanetWars;
 
-      recon.Enabled = false;
+		public Spring Spring
+		{
+			get { return spring; }
+		}
 
-      try {
-        spring = new Spring(config.SpringPath);
-      } catch {
-        MessageBox.Show(&quot;Spring not found in &quot; + config.SpringPath, &quot;error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
-        OpenFileDialog od = new OpenFileDialog();
-        od.FileName = Spring.ExecutableName;
-        od.DefaultExt = Path.GetExtension(Spring.ExecutableName);
-        od.InitialDirectory = config.SpringPath;
-        od.Title = &quot;Please select your spring installation&quot;;
-        od.RestoreDirectory = true;
-        od.CheckFileExists = true;
-        od.CheckPathExists = true;
-        od.AddExtension = true;
-        od.Filter = &quot;Executable (*.exe)|*.exe&quot;;
-        DialogResult dr = od.ShowDialog();
-        if (dr == DialogResult.OK) {
-          config.SpringPath = Path.GetDirectoryName(od.FileName);
-          SaveConfig();
-          try {
-            spring = new Spring(config.SpringPath);
-          } catch (Exception e) {
-            MessageBox.Show(e.ToString(), &quot;Error while checking spring, exiting&quot;);
-            Application.Exit();
-            return false;
-          }
-        } else {
-          MessageBox.Show(&quot;Spring not found, exiting&quot;);
-          Application.Exit();
-          return false;
-        }
-      }
+		public Stats Stats
+		{
+			get { return stats; }
+		}
 
-      tas = new TasClient();
-      tas.ConnectionLost += new EventHandler&lt;TasEventArgs&gt;(tas_ConnectionLost);
-      tas.Connected += new EventHandler&lt;TasEventArgs&gt;(tas_Connected);
-      tas.LoginDenied += new EventHandler&lt;TasEventArgs&gt;(tas_LoginDenied);
-      tas.LoginAccepted += new EventHandler&lt;TasEventArgs&gt;(tas_LoginAccepted);
-      tas.Said += new EventHandler&lt;TasSayEventArgs&gt;(tas_Said);
-      tas.MyStatusChangedToInGame += new EventHandler&lt;TasEventArgs&gt;(tas_MyStatusChangedToInGame);
-      spring.SpringExited += new EventHandler(spring_SpringExited);
-      spring.SpringStarted += new EventHandler(spring_SpringStarted);
-      spring.PlayerSaid += new EventHandler&lt;SpringLogEventArgs&gt;(spring_PlayerSaid);
-      autoHost = new AutoHost(tas, spring, null);
-      autoUpdater = new AutoUpdater(spring, tas);
+		public TasClient Tas
+		{
+			get { return tas; }
+		}
 
-      if (config.StatsEnabledReal) stats = new Stats(tas, spring);
-      try {
-        tas.Connect(config.ServerHost, config.ServerPort);
-      } catch {
-        recon.Start();
-      }
-      return true;
-    }
+		#endregion
 
-    private void spring_SpringStarted(object sender, EventArgs e)
-    {
-      if (Program.main.config.AllowInGameJoin) {
-        tas.ChangeMyStatus(false, false);
-        tas.ChangeLock(false);
-      }
-    }
+		#region Constructors
 
+		public Main()
+		{
+			LoadConfig();
+			SaveConfig();
+		}
 
-    public void Stop()
-    {
-      tas.ConnectionLost -= tas_ConnectionLost;
-      tas.Disconnect();
-    }
+		#endregion
 
-    private void tas_MyStatusChangedToInGame(object sender, TasEventArgs e)
-    {
-      spring.StartGame(tas.GetBattle());
-    }
+		#region Public methods
 
-    private void tas_Said(object sender, TasSayEventArgs e)
-    {
-      if (config.RedirectGameChat &amp;&amp; e.Place == TasSayEventArgs.Places.Battle &amp;&amp; e.Origin == TasSayEventArgs.Origins.Player &amp;&amp; e.UserName != tas.UserName &amp;&amp; e.IsEmote == false &amp;&amp; !Program.main.config.AllowInGameJoin) {
-        // TODO disable disabled redirect for allow ingame joins
-        spring.SayGame(&quot;[&quot; + e.UserName + &quot;]&quot; + e.Text);
-      }
-    }
+		public void InitializePlanetWarsServer()
+		{
+			try {
+				PlanetWars = (ISpringieServer) Activator.GetObject(typeof (ISpringieServer), String.Format(&quot;<A HREF="tcp://{0">tcp://{0</A>}:1666/IServer&quot;, config.PlanetWarsServer));
+			} catch (Exception ex) {}
+		}
 
-    private void spring_PlayerSaid(object sender, SpringLogEventArgs e)
-    {
-      tas.GameSaid(e.Username, e.Line);
-      if (config.RedirectGameChat &amp;&amp; e.Username != tas.UserName &amp;&amp; !e.Line.StartsWith(&quot;Allies:&quot;) &amp;&amp; !e.Line.StartsWith(&quot;Spectators:&quot;)) tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;[&quot; + e.Username + &quot;]&quot; + e.Line, false);
-    }
+		public void LoadConfig()
+		{
+			config = new MainConfig();
+			if (File.Exists(Application.StartupPath + '/' + ConfigMain)) {
+				var s = new XmlSerializer(config.GetType());
+				var r = File.OpenText(Application.StartupPath + '/' + ConfigMain);
+				config = (MainConfig) s.Deserialize(r);
+				r.Close();
+			}
+		}
 
-    public void ReLogin()
-    {
-      tas_Connected(this, new TasEventArgs());
-    }
+		public void ReLogin()
+		{
+			tas_Connected(this, new TasEventArgs());
+		}
 
-    private void tas_LoginDenied(object sender, TasEventArgs e)
-    {
-      //MessageBox.Show(e.ServerParams[0], &quot;Login failed&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
-      Program.formMain.GetNewLogPass();
-    }
+		public void SaveConfig()
+		{
+			var s = new XmlSerializer(config.GetType());
+			var f = File.OpenWrite(Application.StartupPath + '/' + ConfigMain);
+			f.SetLength(0);
+			s.Serialize(f, config);
+			f.Close();
+		}
 
-    private void spring_SpringExited(object sender, EventArgs e)
-    {
-      if (tas != null) tas.ChangeMyStatus(false, false);
-    }
 
+		public bool Start()
+		{
+			if (config.AttemptToRecconnect) {
+				recon = new Timer(config.AttemptReconnectInterval*1000);
+				recon.Elapsed += recon_Elapsed;
+			}
 
-    // login accepted - join channels
-    private void tas_LoginAccepted(object sender, TasEventArgs e)
-    {
-      for (int i = 0; i &lt; config.JoinChannels.Length; ++i) tas.JoinChannel(config.JoinChannels[i]);
-      autoHost.Start(null, null);
-    }
+			recon.Enabled = false;
 
-    // im connected, let's login
-    private void tas_Connected(object sender, TasEventArgs e)
-    {
-      tas.Login(config.AccountName, config.AccountPassword, MainConfig.SpringieVersion);
-    }
+			try {
+				spring = new Spring(config.SpringPath);
+			} catch {
+				MessageBox.Show(&quot;Spring not found in &quot; + config.SpringPath, &quot;error&quot;, MessageBoxButtons.OK, MessageBoxIcon.Error);
+				var od = new OpenFileDialog();
+				od.FileName = Spring.ExecutableName;
+				od.DefaultExt = Path.GetExtension(Spring.ExecutableName);
+				od.InitialDirectory = config.SpringPath;
+				od.Title = &quot;Please select your spring installation&quot;;
+				od.RestoreDirectory = true;
+				od.CheckFileExists = true;
+				od.CheckPathExists = true;
+				od.AddExtension = true;
+				od.Filter = &quot;Executable (*.exe)|*.exe&quot;;
+				var dr = od.ShowDialog();
+				if (dr == DialogResult.OK) {
+					config.SpringPath = Path.GetDirectoryName(od.FileName);
+					SaveConfig();
+					try {
+						spring = new Spring(config.SpringPath);
+					} catch (Exception e) {
+						MessageBox.Show(e.ToString(), &quot;Error while checking spring, exiting&quot;);
+						Application.Exit();
+						return false;
+					}
+				} else {
+					MessageBox.Show(&quot;Spring not found, exiting&quot;);
+					Application.Exit();
+					return false;
+				}
+			}
 
+			if (config.PlanetWarsEnabled) InitializePlanetWarsServer();
 
-    private void recon_Elapsed(object sender, ElapsedEventArgs e)
-    {
-      recon.Stop();
-      try {
-        tas.Connect(config.ServerHost, config.ServerPort);
-      } catch {
-        recon.Start();
-      }
-    }
+			tas = new TasClient();
+			tas.ConnectionLost += tas_ConnectionLost;
+			tas.Connected += tas_Connected;
+			tas.LoginDenied += tas_LoginDenied;
+			tas.LoginAccepted += tas_LoginAccepted;
+			tas.Said += tas_Said;
+			tas.MyStatusChangedToInGame += tas_MyStatusChangedToInGame;
+			spring.SpringExited += spring_SpringExited;
+			spring.SpringStarted += spring_SpringStarted;
+			spring.PlayerSaid += spring_PlayerSaid;
+			autoHost = new AutoHost(tas, spring, null);
+			autoUpdater = new AutoUpdater(spring, tas);
 
-    private void tas_ConnectionLost(object sender, TasEventArgs e)
-    {
-      autoHost.Stop();
-      recon.Start();
-    }
-  }
+			if (config.StatsEnabledReal) stats = new Stats(tas, spring);
+			try {
+				tas.Connect(config.ServerHost, config.ServerPort);
+			} catch {
+				recon.Start();
+			}
+			return true;
+		}
+
+
+		public void Stop()
+		{
+			tas.ConnectionLost -= tas_ConnectionLost;
+			tas.Disconnect();
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void recon_Elapsed(object sender, ElapsedEventArgs e)
+		{
+			recon.Stop();
+			try {
+				tas.Connect(config.ServerHost, config.ServerPort);
+			} catch {
+				recon.Start();
+			}
+		}
+
+		private void spring_PlayerSaid(object sender, SpringLogEventArgs e)
+		{
+			tas.GameSaid(e.Username, e.Line);
+			if (config.RedirectGameChat &amp;&amp; e.Username != tas.UserName &amp;&amp; !e.Line.StartsWith(&quot;Allies:&quot;) &amp;&amp; !e.Line.StartsWith(&quot;Spectators:&quot;)) tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;[&quot; + e.Username + &quot;]&quot; + e.Line, false);
+		}
+
+		private void spring_SpringExited(object sender, EventArgs e)
+		{
+			if (tas != null) tas.ChangeMyStatus(false, false);
+		}
+
+		private void spring_SpringStarted(object sender, EventArgs e)
+		{
+			if (Program.main.config.AllowInGameJoin) {
+				tas.ChangeMyStatus(false, false);
+				tas.ChangeLock(false);
+			}
+		}
+
+
+		// login accepted - join channels
+
+		// im connected, let's login
+		private void tas_Connected(object sender, TasEventArgs e)
+		{
+			tas.Login(config.AccountName, config.AccountPassword, MainConfig.SpringieVersion);
+		}
+
+
+		private void tas_ConnectionLost(object sender, TasEventArgs e)
+		{
+			autoHost.Stop();
+			recon.Start();
+		}
+
+		private void tas_LoginAccepted(object sender, TasEventArgs e)
+		{
+			for (int i = 0; i &lt; config.JoinChannels.Length; ++i) tas.JoinChannel(config.JoinChannels[i]);
+			autoHost.Start(null, null);
+		}
+
+		private void tas_LoginDenied(object sender, TasEventArgs e)
+		{
+			//MessageBox.Show(e.ServerParams[0], &quot;Login failed&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
+			Program.formMain.GetNewLogPass();
+		}
+
+		private void tas_MyStatusChangedToInGame(object sender, TasEventArgs e)
+		{
+			spring.StartGame(tas.GetBattle());
+		}
+
+		private void tas_Said(object sender, TasSayEventArgs e)
+		{
+			if (config.RedirectGameChat &amp;&amp; e.Place == TasSayEventArgs.Places.Battle &amp;&amp; e.Origin == TasSayEventArgs.Origins.Player &amp;&amp; e.UserName != tas.UserName &amp;&amp; e.IsEmote == false &amp;&amp; !Program.main.config.AllowInGameJoin) {
+				// TODO disable disabled redirect for allow ingame joins
+				spring.SayGame(&quot;[&quot; + e.UserName + &quot;]&quot; + e.Text);
+			}
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/MainConfig.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/MainConfig.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/MainConfig.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,249 +1,273 @@
+#region using
+
 using System.ComponentModel;
 using System.Diagnostics;
 
+#endregion
+
 namespace Springie
 {
-  public class MainConfig
-  {
-    #region CaUpdateMode enum
-    public enum CaUpdateMode
-    {
-      None,
-      Stable,
-      Latest
-    } ;
-    #endregion
+	public class MainConfig
+	{
+		#region Constants
 
-    #region ErrorHandlingModes enum
-    public enum ErrorHandlingModes : int
-    {
-      Debug,
-      Suppress,
-      MessageBox
-    }
-    #endregion
+		public const string SpringieVersion = &quot;Springie 1.19&quot;;
 
-    public const string SpringieVersion = &quot;Springie 1.18&quot;;
-    private string accountName = &quot;login&quot;;
-    private string accountPassword = &quot;pass&quot;;
-    private bool allowInGameJoin = false;
-    private int attemptReconnectInterval = 60;
-    private bool attemptToRecconnect = true;
+		#endregion
 
-    private bool autoUpdate = true;
-    private CaUpdateMode caUpdating;
-    private ErrorHandlingModes errorHandlingMode = ErrorHandlingModes.Suppress;
-    private bool gargamelMode = true;
-    private ProcessPriorityClass hostingProcessPriority = ProcessPriorityClass.AboveNormal;
-    private string[] joinChannels = new string[] {&quot;main&quot;};
-    private bool redirectGameChat = true;
-    private string serverHost = &quot;taspringmaster.clan-sy.com&quot;;
-    private int serverPort = 8200;
-    private bool springFullscreen = false;
-    private string springPath = &quot;./&quot;;
-    private int springResolutionX = 40;
-    private int springResolutionY = 40;
-    private bool springStartsHidden = true;
-    private bool springStartsMinimized = true;
-    private bool statsEnabledReal = true;
-    private string statsUrlAddressReal = &quot;<A HREF="http://springie.licho.eu/">http://springie.licho.eu/</A>&quot;;
-    private int springCoreAffinity = 1;
+		#region CaUpdateMode enum
 
-    [Description(&quot;Should Springie automatically update itself to latest version?&quot;)]
-    [Category(&quot;Springie&quot;)]
-    public bool AutoUpdate
-    {
-      get { return autoUpdate; }
-      set { autoUpdate = value; }
-    }
+		public enum CaUpdateMode
+		{
+			None,
+			Stable,
+			Latest
+		} ;
 
-    [Description(&quot;If you run CA updater on the server Springie can autorehost for stable or latest version of it&quot;)]
-    [Category(&quot;Springie&quot;)]
-    public CaUpdateMode CaUpdating
-    {
-      get { return caUpdating; }
-      set { caUpdating = value; }
-    }
+		#endregion
 
+		#region ErrorHandlingModes enum
 
-    [Description(&quot;Should attempt to reconnect to server in case of failure?&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public bool AttemptToRecconnect
-    {
-      get { return attemptToRecconnect; }
-      set { attemptToRecconnect = value; }
-    }
+		public enum ErrorHandlingModes
+		{
+			Debug,
+			Suppress,
+			MessageBox
+		}
 
+		#endregion
 
-    [Description(&quot;Time interval before reconnection attempt in seconds&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public int AttemptReconnectInterval
-    {
-      get { return attemptReconnectInterval; }
-      set { attemptReconnectInterval = value; }
-    }
+		#region Fields
 
-    [Description(&quot;Lobby server hostname&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public string ServerHost
-    {
-      get { return serverHost; }
-      set { serverHost = value; }
-    }
+		private string accountName = &quot;login&quot;;
+		private string accountPassword = &quot;pass&quot;;
+		private int attemptReconnectInterval = 60;
+		private bool attemptToRecconnect = true;
 
-    [Description(&quot;Lobby server port&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public int ServerPort
-    {
-      get { return serverPort; }
-      set { serverPort = value; }
-    }
+		private bool autoUpdate = true;
+		private ErrorHandlingModes errorHandlingMode = ErrorHandlingModes.Suppress;
+		private bool gargamelMode = true;
+		private ProcessPriorityClass hostingProcessPriority = ProcessPriorityClass.AboveNormal;
+		private string[] joinChannels = new[] {&quot;main&quot;};
+		private string planetWarsServer = &quot;<A HREF="tcp://licho.eu:1666/IServer">tcp://licho.eu:1666/IServer</A>&quot;;
+		private bool redirectGameChat = true;
+		private string serverHost = &quot;taspringmaster.clan-sy.com&quot;;
+		private int serverPort = 8200;
+		private int springCoreAffinity = 1;
+		private string springPath = &quot;./&quot;;
+		private int springResolutionX = 40;
+		private int springResolutionY = 40;
+		private bool springStartsHidden = true;
+		private bool springStartsMinimized = true;
+		private bool statsEnabledReal = true;
+		private string statsUrlAddressReal = &quot;<A HREF="http://springie.licho.eu/">http://springie.licho.eu/</A>&quot;;
 
+		#endregion
 
-    [Description(&quot;Url of stats data gathering service&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public string StatsUrlAddressReal
-    {
-      get { return statsUrlAddressReal; }
-      set
-      {
-        if (!value.EndsWith(&quot;/&quot;)) value += &quot;/&quot;;
-        statsUrlAddressReal = value;
-      }
-    }
+		#region Properties
 
+		[Description(&quot;Login name&quot;)]
+		[Category(&quot;Account&quot;)]
+		public string AccountName
+		{
+			get { return accountName; }
+			set { accountName = value; }
+		}
 
-    [Description(&quot;Should this autohost work in gargamel mode (catch smurfs)&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public bool GargamelMode
-    {
-      get { return gargamelMode; }
-      set { gargamelMode = value; }
-    }
+		[Description(&quot;Your login password&quot;)]
+		[Category(&quot;Account&quot;)]
+		public string AccountPassword
+		{
+			get { return accountPassword; }
+			set { accountPassword = value; }
+		}
 
+		[Description(&quot;Should Springie allow people to join it while game is in progress?&quot;)]
+		[Category(&quot;Spring&quot;)]
+		public bool AllowInGameJoin { get; set; }
 
-    [Description(&quot;Should this server report data to stats server?&quot;)]
-    [Category(&quot;Server connection&quot;)]
-    public bool StatsEnabledReal
-    {
-      get { return statsEnabledReal; }
-      set { statsEnabledReal = value; }
-    }
+		[Description(&quot;Time interval before reconnection attempt in seconds&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public int AttemptReconnectInterval
+		{
+			get { return attemptReconnectInterval; }
+			set { attemptReconnectInterval = value; }
+		}
 
-    [Description(&quot;Login name&quot;)]
-    [Category(&quot;Account&quot;)]
-    public string AccountName
-    {
-      get { return accountName; }
-      set { accountName = value; }
-    }
+		[Description(&quot;Should attempt to reconnect to server in case of failure?&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public bool AttemptToRecconnect
+		{
+			get { return attemptToRecconnect; }
+			set { attemptToRecconnect = value; }
+		}
 
-    [Description(&quot;Your login password&quot;)]
-    [Category(&quot;Account&quot;)]
-    public string AccountPassword
-    {
-      get { return accountPassword; }
-      set { accountPassword = value; }
-    }
+		[Description(&quot;Should Springie automatically update itself to latest version?&quot;)]
+		[Category(&quot;Springie&quot;)]
+		public bool AutoUpdate
+		{
+			get { return autoUpdate; }
+			set { autoUpdate = value; }
+		}
 
-    [Description(&quot;Path to your spring directory folder&quot;)]
-    [Category(&quot;Spring&quot;)]
-    public string SpringPath
-    {
-      get { return springPath; }
-      set { springPath = value; }
-    }
+		[Description(&quot;If you run CA updater on the server Springie can autorehost for stable or latest version of it&quot;)]
+		[Category(&quot;Springie&quot;)]
+		public CaUpdateMode CaUpdating { get; set; }
 
-    [Description(&quot;Which channels to join on startup&quot;)]
-    [Category(&quot;Spring&quot;)]
-    public string[] JoinChannels
-    {
-      get { return joinChannels; }
-      set { joinChannels = value; }
-    }
+		[Category(&quot;Springie&quot;)]
+		[Description(&quot;Determines the way in which Springie handles unexpected errors. For general purpose use Suppress, for instant notification and stop on error use MessageBox mode and for debugging use Debug&quot;)]
+		public ErrorHandlingModes ErrorHandlingMode
+		{
+			get { return errorHandlingMode; }
+			set { errorHandlingMode = value; }
+		}
 
+		[Description(&quot;Should this autohost work in gargamel mode (catch smurfs)&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public bool GargamelMode
+		{
+			get { return gargamelMode; }
+			set { gargamelMode = value; }
+		}
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Default hosting spring window width&quot;)]
-    public int SpringResolutionX
-    {
-      get { return springResolutionX; }
-      set { springResolutionX = value; }
-    }
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Sets the priority of spring hosting process&quot;)]
+		public ProcessPriorityClass HostingProcessPriority
+		{
+			get { return hostingProcessPriority; }
+			set { hostingProcessPriority = value; }
+		}
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Default hosting spring window height&quot;)]
-    public int SpringResolutionY
-    {
-      get { return springResolutionY; }
-      set { springResolutionY = value; }
-    }
+		[Description(&quot;Which channels to join on startup&quot;)]
+		[Category(&quot;Spring&quot;)]
+		public string[] JoinChannels
+		{
+			get { return joinChannels; }
+			set { joinChannels = value; }
+		}
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Should hosting spring start as fullscreen&quot;)]
-    public bool SpringFullscreen
-    {
-      get { return springFullscreen; }
-      set { springFullscreen = value; }
-    }
+		[Description(&quot;Enable PlanetWars? Needs stats enabled to work properly&quot;)]
+		[Category(&quot;PlanetWars&quot;)]
+		public bool PlanetWarsEnabled { get; set; }
 
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Should hosting spring start hidden by default&quot;)]
-    public bool SpringStartsHidden
-    {
-      get { return springStartsHidden; }
-      set { springStartsHidden = value; }
-    }
+		[Description(&quot;Location of PlanetWars server&quot;)]
+		[Category(&quot;PlanetWars&quot;)]
+		public string PlanetWarsServer
+		{
+			get { return planetWarsServer; }
+			set { planetWarsServer = value; }
+		}
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Should hosting spring start minimized by default&quot;)]
-    public bool SpringStartsMinimized
-    {
-      get { return springStartsMinimized; }
-      set { springStartsMinimized = value; }
-    }
+		[Description(&quot;Login into PlanetWars system for this springie&quot;)]
+		[Category(&quot;PlanetWars&quot;)]
+		public string PlanetWarsServerLogin { get; set; }
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Should springie redirect global game chat to lobby?&quot;)]
-    public bool RedirectGameChat
-    {
-      get { return redirectGameChat; }
-      set { redirectGameChat = value; }
-    }
 
+		[Description(&quot;Password into PlanetWars system for this springie&quot;)]
+		[Category(&quot;PlanetWars&quot;)]
+		public string PlanetWarsServerPassword { get; set; }
 
-    [Category(&quot;Spring&quot;)]
-    [Description(&quot;Sets the priority of spring hosting process&quot;)]
-    public ProcessPriorityClass HostingProcessPriority
-    {
-      get { return hostingProcessPriority; }
-      set { hostingProcessPriority = value; }
-    }
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Should springie redirect global game chat to lobby?&quot;)]
+		public bool RedirectGameChat
+		{
+			get { return redirectGameChat; }
+			set { redirectGameChat = value; }
+		}
 
-    [Description(&quot;Should Springie allow people to join it while game is in progress?&quot;)]
-    [Category(&quot;Spring&quot;)]
-    public bool AllowInGameJoin
-    {
-      get { return allowInGameJoin; }
-      set { allowInGameJoin = value; }
-    }
 
+		[Description(&quot;Lobby server hostname&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public string ServerHost
+		{
+			get { return serverHost; }
+			set { serverHost = value; }
+		}
 
-    [Category(&quot;Springie&quot;)]
-    [Description(&quot;Determines the way in which Springie handles unexpected errors. For general purpose use Suppress, for instant notification and stop on error use MessageBox mode and for debugging use Debug&quot;)]
-    public ErrorHandlingModes ErrorHandlingMode
-    {
-      get { return errorHandlingMode; }
-      set { errorHandlingMode = value; }
-    }
+		[Description(&quot;Lobby server port&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public int ServerPort
+		{
+			get { return serverPort; }
+			set { serverPort = value; }
+		}
 
-    [Description(&quot;Which cores/CPUs to use 1= first, 2= second, 4= third, 8 = fourth&quot;)]
-    [Category(&quot;Spring&quot;)]
-    public int SpringCoreAffinity
-    {
-      get { return springCoreAffinity; }
-      set { springCoreAffinity = value; }
-    }
-  } ;
+		[Description(&quot;Which cores/CPUs to use 1= first, 2= second, 4= third, 8 = fourth&quot;)]
+		[Category(&quot;Spring&quot;)]
+		public int SpringCoreAffinity
+		{
+			get { return springCoreAffinity; }
+			set { springCoreAffinity = value; }
+		}
+
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Should hosting spring start as fullscreen&quot;)]
+		public bool SpringFullscreen { get; set; }
+
+
+		[Description(&quot;Path to your spring directory folder&quot;)]
+		[Category(&quot;Spring&quot;)]
+		public string SpringPath
+		{
+			get { return springPath; }
+			set { springPath = value; }
+		}
+
+
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Default hosting spring window width&quot;)]
+		public int SpringResolutionX
+		{
+			get { return springResolutionX; }
+			set { springResolutionX = value; }
+		}
+
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Default hosting spring window height&quot;)]
+		public int SpringResolutionY
+		{
+			get { return springResolutionY; }
+			set { springResolutionY = value; }
+		}
+
+
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Should hosting spring start hidden by default&quot;)]
+		public bool SpringStartsHidden
+		{
+			get { return springStartsHidden; }
+			set { springStartsHidden = value; }
+		}
+
+		[Category(&quot;Spring&quot;)]
+		[Description(&quot;Should hosting spring start minimized by default&quot;)]
+		public bool SpringStartsMinimized
+		{
+			get { return springStartsMinimized; }
+			set { springStartsMinimized = value; }
+		}
+
+		[Description(&quot;Should this server report data to stats server?&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public bool StatsEnabledReal
+		{
+			get { return statsEnabledReal; }
+			set { statsEnabledReal = value; }
+		}
+
+		[Description(&quot;Url of stats data gathering service&quot;)]
+		[Category(&quot;Server connection&quot;)]
+		public string StatsUrlAddressReal
+		{
+			get { return statsUrlAddressReal; }
+			set
+			{
+				if (!value.EndsWith(&quot;/&quot;)) value += &quot;/&quot;;
+				statsUrlAddressReal = value;
+			}
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/Program.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/Program.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/Program.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Globalization;
 using System.Threading;
@@ -3,50 +5,67 @@
 using System.Windows.Forms;
 
+#endregion
+
 namespace Springie
 {
-  internal static class Program
-  {
-    public static FormMain formMain = null;
+	internal static class Program
+	{
+		#region Properties
 
-    /// &lt;summary&gt;
-    /// The main entry point for the application.
-    /// &lt;/summary&gt;
-    public static Main main = new Main();
+		public static FormMain formMain;
 
-    public static DateTime startupTime = DateTime.Now;
+		/// &lt;summary&gt;
+		/// The main entry point for the application.
+		/// &lt;/summary&gt;
+		public static Main main = new Main();
 
-    [STAThread]
-    private static void Main()
-    {
-      // setup unhandled exception handlers
-      Application.ThreadException += new ThreadExceptionEventHandler(Application_ThreadException);
-      AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);
-      Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);
+		public static DateTime startupTime = DateTime.Now;
 
-      Application.CurrentCulture = CultureInfo.InvariantCulture;
-      Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+		#endregion
 
-      try {
-        Application.EnableVisualStyles();
-        Application.SetCompatibleTextRenderingDefault(false);
-        Application.Run(new FormMain());
-      } catch (Exception e) {
-        if (!ErrorHandling.HandleException(e, &quot;Application exception&quot;)) throw;
-      }
-    }
+		#region Other methods
 
+		[STAThread]
+		private static void Main()
+		{
+			// setup unhandled exception handlers
+			Application.ThreadException += Application_ThreadException;
+			AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
+			Application.SetUnhandledExceptionMode(UnhandledExceptionMode.CatchException);
 
-    // unhandled exception in non-ui thread
-    private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
-    {
-      Exception ex = (Exception)e.ExceptionObject;
-      if (!ErrorHandling.HandleException(ex, &quot;Secondary thread unhandled exception&quot;)) throw ex;
-    }
+			Application.CurrentCulture = CultureInfo.InvariantCulture;
+			Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
 
-    // unhandled exception in gui thread
-    private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e)
-    {
-      if (!ErrorHandling.HandleException(e.Exception, &quot;Main thread unhandled exception&quot;)) throw e.Exception;
-    }
-  }
+			//if (!main.Start()) return;
+			//while (true) Thread.Sleep(2000);
+			try {
+				Application.EnableVisualStyles();
+				Application.SetCompatibleTextRenderingDefault(false);
+				Application.Run(new FormMain());
+			} catch (Exception e) {
+				if (!ErrorHandling.HandleException(e, &quot;Application exception&quot;)) throw;
+			}
+		}
+
+		#endregion
+
+		// unhandled exception in non-ui thread
+
+		// unhandled exception in gui thread
+
+		#region Event Handlers
+
+		private static void Application_ThreadException(object sender, ThreadExceptionEventArgs e)
+		{
+			if (!ErrorHandling.HandleException(e.Exception, &quot;Main thread unhandled exception&quot;)) throw e.Exception;
+		}
+
+		private static void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
+		{
+			var ex = (Exception) e.ExceptionObject;
+			if (!ErrorHandling.HandleException(ex, &quot;Secondary thread unhandled exception&quot;)) throw ex;
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/Properties/AssemblyInfo.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/Properties/AssemblyInfo.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/Properties/AssemblyInfo.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,29 +1,33 @@
-&#65279;using System.Reflection;
+&#65279;#region using
+
+using System.Reflection;
 using System.Resources;
 using System.Runtime.InteropServices;
 
+#endregion
+
 // General Information about an assembly is controlled through the following 
 // set of attributes. Change these attribute values to modify the information
 // associated with an assembly.
 
-[assembly : AssemblyTitle(&quot;Springie&quot;)]
-[assembly : AssemblyDescription(&quot;Springie AutoHost&quot;)]
-[assembly : AssemblyConfiguration(&quot;&quot;)]
-[assembly : AssemblyCompany(&quot;Licho&quot;)]
-[assembly : AssemblyProduct(&quot;Springie&quot;)]
-[assembly : AssemblyCopyright(&quot;Copyright &#169; Licho&quot;)]
-[assembly : AssemblyTrademark(&quot;&quot;)]
-[assembly : AssemblyCulture(&quot;&quot;)]
+[assembly: AssemblyTitle(&quot;Springie&quot;)]
+[assembly: AssemblyDescription(&quot;Springie AutoHost&quot;)]
+[assembly: AssemblyConfiguration(&quot;&quot;)]
+[assembly: AssemblyCompany(&quot;Licho&quot;)]
+[assembly: AssemblyProduct(&quot;Springie&quot;)]
+[assembly: AssemblyCopyright(&quot;Copyright &#169; Licho&quot;)]
+[assembly: AssemblyTrademark(&quot;&quot;)]
+[assembly: AssemblyCulture(&quot;&quot;)]
 
 // Setting ComVisible to false makes the types in this assembly not visible 
 // to COM components.  If you need to access a type in this assembly from 
 // COM, set the ComVisible attribute to true on that type.
 
-[assembly : ComVisible(false)]
+[assembly: ComVisible(false)]
 
 // The following GUID is for the ID of the typelib if this project is exposed to COM
 
-[assembly : Guid(&quot;42c2f4e5-69ea-4dfe-9bda-5a97c8ba3b23&quot;)]
+[assembly: Guid(&quot;42c2f4e5-69ea-4dfe-9bda-5a97c8ba3b23&quot;)]
 
 // Version information for an assembly consists of the following four values:
 //
@@ -33,7 +37,7 @@
 //      Revision
 //
 
-[assembly : AssemblyVersion(&quot;0.99.*&quot;)]
+[assembly: AssemblyVersion(&quot;0.99.*&quot;)]
 //[assembly: AssemblyFileVersion(&quot;0.97.0.0&quot;)]
 
-[assembly : NeutralResourcesLanguage(&quot;en&quot;)]
\ No newline at end of file
+[assembly: NeutralResourcesLanguage(&quot;en&quot;)]
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/Springie.csproj
===================================================================
--- branches/caiinterface/tools/springie/Springie/Springie.csproj	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/Springie.csproj	2008-10-09 18:55:21 UTC (rev 6639)
@@ -2,7 +2,7 @@
   &lt;PropertyGroup&gt;
     &lt;Configuration Condition=&quot; '$(Configuration)' == '' &quot;&gt;Debug&lt;/Configuration&gt;
     &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;AnyCPU&lt;/Platform&gt;
-    &lt;ProductVersion&gt;9.0.21022&lt;/ProductVersion&gt;
+    &lt;ProductVersion&gt;9.0.30729&lt;/ProductVersion&gt;
     &lt;SchemaVersion&gt;2.0&lt;/SchemaVersion&gt;
     &lt;ProjectGuid&gt;{DD5A4F64-6C82-4F75-9EED-992378EC65FC}&lt;/ProjectGuid&gt;
     &lt;OutputType&gt;WinExe&lt;/OutputType&gt;
@@ -77,7 +77,7 @@
   &lt;/PropertyGroup&gt;
   &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Debug|x86' &quot;&gt;
     &lt;DebugSymbols&gt;true&lt;/DebugSymbols&gt;
-    &lt;OutputPath&gt;bin\x86\Debug\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\bin\&lt;/OutputPath&gt;
     &lt;DefineConstants&gt;DEBUG;TRACE&lt;/DefineConstants&gt;
     &lt;DebugType&gt;Full&lt;/DebugType&gt;
     &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;
@@ -87,7 +87,7 @@
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
   &lt;/PropertyGroup&gt;
   &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|x86' &quot;&gt;
-    &lt;OutputPath&gt;bin\x86\Release\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\bin\&lt;/OutputPath&gt;
     &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
     &lt;Optimize&gt;true&lt;/Optimize&gt;
     &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
@@ -98,6 +98,10 @@
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
   &lt;/PropertyGroup&gt;
   &lt;ItemGroup&gt;
+    &lt;Reference Include=&quot;PlanetWarsShared, Version=1.0.0.0, Culture=neutral, processorArchitecture=MSIL&quot;&gt;
+      &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt;
+      &lt;HintPath&gt;..\libs\PlanetWarsShared.dll&lt;/HintPath&gt;
+    &lt;/Reference&gt;
     &lt;Reference Include=&quot;System&quot; /&gt;
     &lt;Reference Include=&quot;System.Data&quot; /&gt;
     &lt;Reference Include=&quot;System.Drawing&quot; /&gt;

Modified: branches/caiinterface/tools/springie/Springie/autohost/AutoHost.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/AutoHost.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/AutoHost.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.Globalization;
@@ -12,883 +14,990 @@
 using Springie.SpringNamespace;
 using Timer=System.Timers.Timer;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public partial class AutoHost
-  {
-    public const string BoxesName = &quot;boxes.bin&quot;;
-    public const string ConfigName = &quot;autohost.xml&quot;;
+	public partial class AutoHost
+	{
+		#region Constants
 
-    public const int PollTimeout = 60;
-    public const string PresetsName = &quot;presets.xml&quot;;
+		public const string BoxesName = &quot;boxes.bin&quot;;
+		public const string ConfigName = &quot;autohost.xml&quot;;
 
-    private IVotable activePoll = null;
-    private int autoLock = 0;
-    private BanList banList;
-    private string bossName = &quot;&quot;;
-    public AutoHostConfig config = new AutoHostConfig();
+		public const int PollTimeout = 60;
+		public const string PresetsName = &quot;presets.xml&quot;;
 
+		#endregion
 
-    private FileDownloader fileDownloader;
+		#region Fields
 
-    private bool kickMinRank = false;
-    private bool kickSpectators = false;
-    public Ladder ladder;
-    private UnknownFilesLinker linker;
-    private bool lockedByKickSpec = false;
+		private IVotable activePoll;
+		private int autoLock;
+		private BanList banList;
+		private string bossName = &quot;&quot;;
 
-    private AutoManager manager;
-    public Dictionary&lt;string, Dictionary&lt;int, BattleRect&gt;&gt; MapBoxes = new Dictionary&lt;string, Dictionary&lt;int, BattleRect&gt;&gt;();
-    private int mapCycleIndex = 0;
 
+		private FileDownloader fileDownloader;
 
-    private double minCpuSpeed = 0;
-    private Timer pollTimer = null;
-    public List&lt;Preset&gt; presets = new List&lt;Preset&gt;();
-    private object savLock = new object();
-    private Spring spring;
-    private TasClient tas;
+		private bool kickMinRank;
+		private bool kickSpectators;
+		private UnknownFilesLinker linker;
+		private bool lockedByKickSpec;
 
-    public AutoHost(TasClient tas, Spring spring, AutoHostConfig conf)
-    {
-      banList = new BanList(this, tas);
+		private AutoManager manager;
+		private int mapCycleIndex;
 
-      if (conf == null) LoadConfig();
-      else config = conf;
-      SaveConfig();
 
-      this.tas = tas;
-      this.spring = spring;
+		private double minCpuSpeed;
+		private Timer pollTimer;
+		private object savLock = new object();
+		private Spring spring;
+		private TasClient tas;
 
-      tas.Said += new EventHandler&lt;TasSayEventArgs&gt;(tas_Said);
+		#endregion
 
-      pollTimer = new Timer(PollTimeout*1000);
-      pollTimer.Enabled = false;
-      pollTimer.AutoReset = false;
-      pollTimer.Elapsed += new ElapsedEventHandler(pollTimer_Elapsed);
+		#region Properties
 
-      spring.SpringExited += new EventHandler(spring_SpringExited);
-      spring.GameOver += new EventHandler&lt;SpringLogEventArgs&gt;(spring_GameOver);
+		public string BossName
+		{
+			get { return bossName; }
+			set { bossName = value; }
+		}
 
-      tas.BattleUserLeft += new EventHandler&lt;TasEventArgs&gt;(tas_BattleUserLeft);
-      tas.UserStatusChanged += new EventHandler&lt;TasEventArgs&gt;(tas_UserStatusChanged);
-      tas.BattleUserJoined += new EventHandler&lt;TasEventArgs&gt;(tas_BattleUserJoined);
-      tas.BattleMapChanged += new EventHandler&lt;TasEventArgs&gt;(tas_BattleMapChanged);
-      tas.BattleUserStatusChanged += new EventHandler&lt;TasEventArgs&gt;(tas_BattleUserStatusChanged);
-      tas.BattleLockChanged += new EventHandler&lt;TasEventArgs&gt;(tas_BattleLockChanged);
-      tas.BattleOpened += new EventHandler&lt;TasEventArgs&gt;(tas_BattleOpened);
+		public AutoHostConfig config = new AutoHostConfig();
 
-      linker = new UnknownFilesLinker(spring);
-      fileDownloader = new FileDownloader(spring);
-      fileDownloader.DownloadCompleted += new EventHandler&lt;FileDownloader.DownloadEventArgs&gt;(fileDownloader_DownloadCompleted);
-      //fileDownloader.DownloadProgressChanged += new EventHandler&lt;TasEventArgs&gt;(fileDownloader_DownloadProgressChanged);
+		public bool KickSpectators
+		{
+			get { return kickSpectators; }
+		}
 
-      tas.BattleFound += new EventHandler&lt;TasEventArgs&gt;(tas_BattleFound);
-    }
+		public Ladder ladder;
+		public Dictionary&lt;string, Dictionary&lt;int, BattleRect&gt;&gt; MapBoxes = new Dictionary&lt;string, Dictionary&lt;int, BattleRect&gt;&gt;();
 
-    public string BossName
-    {
-      get { return bossName; }
-      set { bossName = value; }
-    }
+		public double MinCpuSpeed
+		{
+			get { return minCpuSpeed; }
+		}
 
-    public bool KickSpectators
-    {
-      get { return kickSpectators; }
-    }
+		public List&lt;Preset&gt; presets = new List&lt;Preset&gt;();
 
-    public double MinCpuSpeed
-    {
-      get { return minCpuSpeed; }
-    }
+		#endregion
 
-    /*void fileDownloader_DownloadProgressChanged(object sender, TasEventArgs e)
+		#region Constructors
+
+		public AutoHost(TasClient tas, Spring spring, AutoHostConfig conf)
+		{
+			banList = new BanList(this, tas);
+
+			if (conf == null) LoadConfig();
+			else config = conf;
+			SaveConfig();
+
+			this.tas = tas;
+			this.spring = spring;
+
+			tas.Said += tas_Said;
+
+			pollTimer = new Timer(PollTimeout*1000);
+			pollTimer.Enabled = false;
+			pollTimer.AutoReset = false;
+			pollTimer.Elapsed += pollTimer_Elapsed;
+
+			spring.SpringExited += spring_SpringExited;
+			spring.GameOver += spring_GameOver;
+
+			tas.BattleUserLeft += tas_BattleUserLeft;
+			tas.UserStatusChanged += tas_UserStatusChanged;
+			tas.BattleUserJoined += tas_BattleUserJoined;
+			tas.BattleMapChanged += tas_BattleMapChanged;
+			tas.BattleUserStatusChanged += tas_BattleUserStatusChanged;
+			tas.BattleLockChanged += tas_BattleLockChanged;
+			tas.BattleOpened += tas_BattleOpened;
+
+			linker = new UnknownFilesLinker(spring);
+			fileDownloader = new FileDownloader(spring);
+			fileDownloader.DownloadCompleted += fileDownloader_DownloadCompleted;
+			//fileDownloader.DownloadProgressChanged += new EventHandler&lt;TasEventArgs&gt;(fileDownloader_DownloadProgressChanged);
+
+			tas.BattleFound += tas_BattleFound;
+		}
+
+		#endregion
+
+		/*void fileDownloader_DownloadProgressChanged(object sender, TasEventArgs e)
     {
       if (tas.IsConnected) {
         SayBattle(e.ServerParams[0] + &quot; &quot; + e.ServerParams[1] + &quot;% done&quot;);
       }
     }*/
 
-    private void fileDownloader_DownloadCompleted(object sender, FileDownloader.DownloadEventArgs e)
-    {
-      string mes;
-      if (e.Status == FileDownloader.Status.Failed) mes = e.DownloadItem.fileName + &quot; download failed: &quot; + e.Message;
-      else {
-        mes = e.DownloadItem.fileName + &quot; download finished!&quot;;
-        spring.Reload(true, true);
-      }
-      if (tas.IsConnected) SayBattle(mes);
-      if (e.DownloadItem.fileType == FileDownloader.FileType.Mod &amp;&amp; !spring.IsRunning) Start(e.DownloadItem.fileName, null);
-    }
+		#region Public methods
 
+		public int GetUserLevel(TasSayEventArgs e)
+		{
+			return GetUserLevel(e.UserName);
+		}
 
-    private void tas_BattleOpened(object sender, TasEventArgs e)
-    {
-      tas.DisableUnits(UnitInfo.ToStringList(config.DisabledUnits));
-    }
+		public int GetUserLevel(string name)
+		{
+			foreach (var pu in config.PrivilegedUsers) if (pu.Name == name) return pu.Level;
+			User u;
+			if (tas.GetExistingUser(name, out u)) if (u.isAdmin) return config.DefaulRightsLevelForLobbyAdmins;
+			return config.DefaulRightsLevel;
+		}
 
-    private void tas_BattleFound(object sender, TasEventArgs e)
-    {
-      string map = Utils.Glue(e.ServerParams.ToArray(), 10).Split('\t')[0];
-      if (config.AutoDownloadNewMaps &amp;&amp; !spring.IsRunning &amp;&amp; !spring.UnitSync.MapList.ContainsKey(map)) fileDownloader.DownloadMap(map);
-    }
 
+		public bool HasRights(string command, TasSayEventArgs e)
+		{
+			if (banList.IsBanned(e.UserName)) {
+				Respond(e, &quot;tough luck, you are banned&quot;);
+				return false;
+			}
+			foreach (var c in config.Commands) {
+				if (c.Name == command) {
+					if (c.Throttling &gt; 0) {
+						int diff = (int) DateTime.Now.Subtract(c.lastCall).TotalSeconds;
+						if (diff &lt; c.Throttling) {
+							Respond(e, &quot;AntiSpam - please wait &quot; + (c.Throttling - diff) + &quot; more seconds&quot;);
+							return false;
+						}
+					}
 
-    private void spring_GameOver(object sender, SpringLogEventArgs e)
-    {
-      Thread.Sleep(3000); // wait for stats
-      SayBattle(&quot;Game over, exiting&quot;);
-      spring.ExitGame();
+					for (int i = 0; i &lt; c.ListenTo.Length; i++) {
+						if (c.ListenTo[i] == e.Place) {
+							int reqLevel = c.Level;
+							int ulevel = GetUserLevel(e);
 
-      if (config.MapCycle.Length &gt; 0) {
-        mapCycleIndex = mapCycleIndex%config.MapCycle.Length;
-        SayBattle(&quot;changing to another map in mapcycle&quot;);
-        ComMap(TasSayEventArgs.Default, config.MapCycle[mapCycleIndex].Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries));
-        mapCycleIndex++;
-      }
-    }
+							if (ulevel &gt;= reqLevel) {
+								// boss stuff
+								if (bossName != &quot;&quot; &amp;&amp; ulevel &lt;= config.DefaulRightsLevel &amp;&amp; e.UserName != bossName &amp;&amp; config.DefaultRightsLevelWithBoss &lt; reqLevel) {
+									Respond(e, &quot;Sorry, you cannot do this right now, ask boss admin &quot; + bossName);
+									return false;
+								} else {
+									c.lastCall = DateTime.Now;
+									return true; // ALL OK
+								}
+							} else {
+								Respond(e, &quot;Sorry, you do not have rights to execute &quot; + command);
+								return false;
+							}
+						}
+					}
+					return false; // place not allowed for this command = ignore command
+				}
+			}
+			if (e.Place != TasSayEventArgs.Places.Channel) Respond(e, &quot;Sorry, I don't know command '&quot; + command + &quot;'&quot;);
+			return false;
+		}
 
-    public void LoadConfig()
-    {
-      if (File.Exists(Application.StartupPath + '/' + ConfigName)) {
-        XmlSerializer s = new XmlSerializer(config.GetType());
-        StreamReader r = File.OpenText(Application.StartupPath + '/' + ConfigName);
-        config = (AutoHostConfig)s.Deserialize(r);
-        r.Close();
-        config.AddMissingCommands();
-      } else config.Defaults();
+		public void LoadConfig()
+		{
+			if (File.Exists(Application.StartupPath + '/' + ConfigName)) {
+				var s = new XmlSerializer(config.GetType());
+				var r = File.OpenText(Application.StartupPath + '/' + ConfigName);
+				config = (AutoHostConfig) s.Deserialize(r);
+				r.Close();
+				config.AddMissingCommands();
+			} else config.Defaults();
 
-      if (File.Exists(Application.StartupPath + '/' + PresetsName)) {
-        XmlSerializer s = new XmlSerializer(presets.GetType());
-        using (StreamReader r = File.OpenText(Application.StartupPath + '/' + PresetsName)) {
-          presets = (List&lt;Preset&gt;)s.Deserialize(r);
-          r.Close();
-        }
-      }
+			if (File.Exists(Application.StartupPath + '/' + PresetsName)) {
+				var s = new XmlSerializer(presets.GetType());
+				using (var r = File.OpenText(Application.StartupPath + '/' + PresetsName)) {
+					presets = (List&lt;Preset&gt;) s.Deserialize(r);
+					r.Close();
+				}
+			}
 
-      if (File.Exists(Application.StartupPath + '/' + BoxesName)) {
-        BinaryFormatter frm = new BinaryFormatter();
-        using (FileStream r = new FileStream(Application.StartupPath + '/' + BoxesName, FileMode.Open)) {
-          MapBoxes = (Dictionary&lt;string, Dictionary&lt;int, BattleRect&gt;&gt;)frm.Deserialize(r);
-          r.Close();
-        }
-      }
+			if (File.Exists(Application.StartupPath + '/' + BoxesName)) {
+				var frm = new BinaryFormatter();
+				using (var r = new FileStream(Application.StartupPath + '/' + BoxesName, FileMode.Open)) {
+					MapBoxes = (Dictionary&lt;string, Dictionary&lt;int, BattleRect&gt;&gt;) frm.Deserialize(r);
+					r.Close();
+				}
+			}
 
-      banList.Load();
-    }
+			banList.Load();
+		}
 
+		public void RegisterVote(TasSayEventArgs e, string[] words)
+		{
+			if (activePoll != null) {
+				if (activePoll.Vote(e, words)) StopVote();
+			} else Respond(e, &quot;There is no poll going on, start some first&quot;);
+		}
 
-    public void SaveConfig()
-    {
-      lock (savLock) {
-        config.Commands.Sort(AutoHostConfig.CommandComparer);
+		public void Respond(TasSayEventArgs e, string text)
+		{
+			Respond(tas, spring, e, text);
+		}
 
-        // remove duplicated admins
-        List&lt;PrivilegedUser&gt; l = new List&lt;PrivilegedUser&gt;();
-        foreach (PrivilegedUser p in config.PrivilegedUsers) if (l.Find(delegate(PrivilegedUser u) { return u.Name == p.Name; }) == null) l.Add(p);
-        ;
-        config.PrivilegedUsers = l;
-        config.PrivilegedUsers.Sort(AutoHostConfig.UserComparer);
+		public static void Respond(TasClient tas, Spring spring, TasSayEventArgs e, string text)
+		{
+			var p = TasClient.SayPlace.User;
+			bool emote = false;
+			if (e.Place == TasSayEventArgs.Places.Battle) {
+				p = TasClient.SayPlace.Battle;
+				emote = true;
+			}
+			if (e.Place == TasSayEventArgs.Places.Game &amp;&amp; spring.IsRunning) spring.SayGame(text);
+			else tas.Say(p, e.UserName, text, emote);
+		}
 
-        presets.Sort(delegate(Preset a, Preset b) { return a.Name.CompareTo(b.Name); });
+		public void SaveConfig()
+		{
+			lock (savLock) {
+				config.Commands.Sort(AutoHostConfig.CommandComparer);
 
-        XmlSerializer s = new XmlSerializer(config.GetType());
-        FileStream f = File.OpenWrite(Application.StartupPath + '/' + ConfigName);
-        f.SetLength(0);
-        s.Serialize(f, config);
-        f.Close();
+				// remove duplicated admins
+				var l = new List&lt;PrivilegedUser&gt;();
+				foreach (var p in config.PrivilegedUsers) if (l.Find(delegate(PrivilegedUser u) { return u.Name == p.Name; }) == null) l.Add(p);
+				;
+				config.PrivilegedUsers = l;
+				config.PrivilegedUsers.Sort(AutoHostConfig.UserComparer);
 
-        s = new XmlSerializer(presets.GetType());
-        f = File.OpenWrite(Application.StartupPath + '/' + PresetsName);
-        f.SetLength(0);
-        s.Serialize(f, presets);
-        f.Close();
+				presets.Sort(delegate(Preset a, Preset b) { return a.Name.CompareTo(b.Name); });
 
-        banList.Save();
+				var s = new XmlSerializer(config.GetType());
+				var f = File.OpenWrite(Application.StartupPath + '/' + ConfigName);
+				f.SetLength(0);
+				s.Serialize(f, config);
+				f.Close();
 
-        BinaryFormatter fm = new BinaryFormatter();
-        using (FileStream fs = new FileStream(Application.StartupPath + '/' + BoxesName, FileMode.Create)) {
-          fm.Serialize(fs, MapBoxes);
-          fs.Close();
-        }
-      }
-    }
+				s = new XmlSerializer(presets.GetType());
+				f = File.OpenWrite(Application.StartupPath + '/' + PresetsName);
+				f.SetLength(0);
+				s.Serialize(f, presets);
+				f.Close();
 
+				banList.Save();
 
-    public void Start(string modname, string mapname)
-    {
-      Stop();
+				var fm = new BinaryFormatter();
+				using (var fs = new FileStream(Application.StartupPath + '/' + BoxesName, FileMode.Create)) {
+					fm.Serialize(fs, MapBoxes);
+					fs.Close();
+				}
+			}
+		}
 
-      manager = new AutoManager(this, tas, spring);
-      lockedByKickSpec = false;
-      autoLock = 0;
-      kickSpectators = config.KickSpectators;
-      minCpuSpeed = config.MinCpuSpeed;
-      kickMinRank = config.KickMinRank;
 
-      if (config.LadderId &gt; 0) ladder = new Ladder(config.LadderId);
-      else ladder = null;
+		public void SayBattle(string text)
+		{
+			SayBattle(text, true);
+		}
 
-      config.BattleDetails.Validate();
-      if (String.IsNullOrEmpty(modname)) modname = config.DefaultMod;
-      if (String.IsNullOrEmpty(mapname)) mapname = config.DefaultMap;
+		public void SayBattle(string text, bool ingame)
+		{
+			SayBattle(tas, spring, text, ingame);
+		}
 
-      if (!spring.UnitSync.HasMap(mapname)) {
-        IEnumerator&lt;MapInfo&gt; enu = spring.UnitSync.MapList.Values.GetEnumerator();
-        enu.MoveNext();
-        mapname = enu.Current.Name;
-      }
-      if (!spring.UnitSync.HasMod(modname)) {
-        IEnumerator&lt;ModInfo&gt; enu = spring.UnitSync.ModList.Values.GetEnumerator();
-        enu.MoveNext();
-        modname = enu.Current.Name;
-      }
 
-      int mint, maxt;
-      Battle b = new Battle((ladder == null ? config.Password : &quot;ladderlock2&quot;), config.HostingPort, config.MaxPlayers, config.MinRank, spring.UnitSync.GetMapInfo(mapname), (ladder != null ? &quot;(ladder &quot; + ladder.Id + &quot;) &quot; : &quot;&quot;) + config.GameTitle.Replace(&quot;%1&quot;, MainConfig.SpringieVersion), spring.UnitSync.GetModInfo(modname), (ladder != null ? ladder.CheckBattleDetails(config.BattleDetails, out mint, out maxt) : config.BattleDetails));
-      // if hole punching enabled then we use it
-      if (config.UseHolePunching) b.Nat = Battle.NatMode.HolePunching;
-      else if (Program.main.config.GargamelMode &amp;&amp; Program.main.Stats != null) b.Nat = Battle.NatMode.FixedPorts;
-      else b.Nat = Battle.NatMode.None; // else either no nat or fixed ports (for gargamel fake - to get client IPs)
+		public static void SayBattle(TasClient tas, Spring spring, string text, bool ingame)
+		{
+			tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, text, true);
+			if (spring.IsRunning &amp;&amp; ingame) spring.SayGame(text);
+		}
 
-      for (int i = 0; i &lt; config.DefaultRectangles.Count; ++i) b.Rectangles.Add(i, config.DefaultRectangles[i]);
-      tas.OpenBattle(b);
-    }
+		public void Start(string modname, string mapname)
+		{
+			Stop();
 
+			manager = new AutoManager(this, tas, spring);
+			lockedByKickSpec = false;
+			autoLock = 0;
+			kickSpectators = config.KickSpectators;
+			minCpuSpeed = config.MinCpuSpeed;
+			kickMinRank = config.KickMinRank;
 
-    private void tas_BattleLockChanged(object sender, TasEventArgs e)
-    {
-      SayBattle(&quot;game &quot; + (tas.GetBattle().IsLocked ? &quot;locked&quot; : &quot;unlocked&quot;), false);
-    }
+			if (config.LadderId &gt; 0) ladder = new Ladder(config.LadderId);
+			else ladder = null;
 
-    private void tas_BattleUserStatusChanged(object sender, TasEventArgs e)
-    {
-      UserBattleStatus u;
-      Battle b = tas.GetBattle();
+			config.BattleDetails.Validate();
+			if (String.IsNullOrEmpty(modname)) modname = config.DefaultMod;
+			if (String.IsNullOrEmpty(mapname)) mapname = config.DefaultMap;
 
-      if (b != null &amp;&amp; b.ContainsUser(e.ServerParams[0], out u)) {
-        /*if (u.SyncStatus == SyncStatuses.Unsynced) {
-          SayBattle(&quot;kicking &quot; + u.name + &quot; - has incorrect spring or mod version&quot;);
-          tas.Kick(u.name);
-        }*/
+			if (!spring.UnitSync.HasMap(mapname)) {
+				IEnumerator&lt;MapInfo&gt; enu = spring.UnitSync.MapList.Values.GetEnumerator();
+				enu.MoveNext();
+				mapname = enu.Current.Name;
+			}
+			if (!spring.UnitSync.HasMod(modname)) {
+				IEnumerator&lt;ModInfo&gt; enu = spring.UnitSync.ModList.Values.GetEnumerator();
+				enu.MoveNext();
+				modname = enu.Current.Name;
+			}
 
-        if (KickSpectators &amp;&amp; u.IsSpectator == true &amp;&amp; u.name != tas.UserName) {
-          SayBattle(config.KickSpectatorText);
-          ComKick(TasSayEventArgs.Default, new string[] {u.name});
-        }
-        HandleAutoLocking();
+			int mint, maxt;
+			var b = new Battle((ladder == null ? config.Password : &quot;ladderlock2&quot;), config.HostingPort, config.MaxPlayers, config.MinRank, spring.UnitSync.GetMapInfo(mapname), (ladder != null ? &quot;(ladder &quot; + ladder.Id + &quot;) &quot; : &quot;&quot;) + config.GameTitle.Replace(&quot;%1&quot;, MainConfig.SpringieVersion), spring.UnitSync.GetModInfo(modname), (ladder != null ? ladder.CheckBattleDetails(config.BattleDetails, out mint, out maxt) : config.BattleDetails));
+			// if hole punching enabled then we use it
+			if (config.UseHolePunching) b.Nat = Battle.NatMode.HolePunching;
+			else if (Program.main.config.GargamelMode &amp;&amp; Program.main.Stats != null) b.Nat = Battle.NatMode.FixedPorts;
+			else b.Nat = Battle.NatMode.None; // else either no nat or fixed ports (for gargamel fake - to get client IPs)
 
-        int cnt = 0;
-        foreach (UserBattleStatus ubs in b.Users) if (!ubs.IsSpectator &amp;&amp; ubs.IsReady) cnt++;
-        string usname;
-        int allyno;
-        if (!manager.Enabled) {
-          if ((cnt == config.MaxPlayers || (autoLock &gt; 0 &amp;&amp; autoLock == cnt)) &amp;&amp; AllReadyAndSynced(out usname) &amp;&amp; AllUniqueTeams(out usname) &amp;&amp; BalancedTeams(out allyno)) {
-            SayBattle(&quot;server is full, starting&quot;);
-            Thread.Sleep(1000); // just to make sure that other clients update their game info and balance ends
-            ComStart(TasSayEventArgs.Default, new string[] {});
-          }
-        }
-      }
-    }
+			for (int i = 0; i &lt; config.DefaultRectangles.Count; ++i) b.Rectangles.Add(i, config.DefaultRectangles[i]);
+			tas.OpenBattle(b);
+		}
 
-    private void tas_BattleMapChanged(object sender, TasEventArgs e)
-    {
-      if (config.DisplayMapLink) SayBattle(&quot;maplink: &quot; + linker.GetMapBounceLink(tas.GetBattle().Map.Name));
-      foreach (UserBattleStatus p in tas.GetBattle().Users) {
-        //ring all people that host changed the map
-        tas.Ring(p.name);
-      }
-      Battle b = tas.GetBattle();
-      string mapName = b.Map.ArchiveName.ToLower();
-      if (MapBoxes.ContainsKey(mapName)) {
-        for (int i = 0; i &lt; b.Rectangles.Count; ++i) tas.RemoveBattleRectangle(i);
-        Dictionary&lt;int, BattleRect&gt; dict = MapBoxes[mapName];
-        foreach (KeyValuePair&lt;int, BattleRect&gt; v in dict) tas.AddBattleRectangle(v.Key, v.Value);
-      }
-    }
 
+		public void StartVote(IVotable vote, TasSayEventArgs e, string[] words)
+		{
+			if (vote != null) {
+				if (activePoll != null) {
+					Respond(e, &quot;Another poll already in progress, please wait&quot;);
+					return;
+				}
+				if (vote.Init(e, words)) {
+					activePoll = vote;
+					pollTimer.Interval = PollTimeout*1000;
+					pollTimer.Enabled = true;
+				}
+			}
+		}
 
-    private void HandleKickSpecServerLocking()
-    {
-      if (!spring.IsRunning &amp;&amp; (KickSpectators || lockedByKickSpec)) {
-        Battle b = tas.GetBattle();
-        int cnt = b.CountPlayers();
-        if (KickSpectators &amp;&amp; cnt &gt;= b.MaxPlayers) {
-          lockedByKickSpec = true;
-          tas.ChangeLock(true);
-        }
 
-        if (lockedByKickSpec &amp;&amp; cnt &lt; b.MaxPlayers) {
-          lockedByKickSpec = false;
-          tas.ChangeLock(false);
-        }
-      }
-    }
+		public void Stop()
+		{
+			if (manager != null) manager.Stop();
+			StopVote();
+			spring.ExitGame();
+			tas.ChangeMyStatus(false, false);
+			tas.LeaveBattle();
+		}
 
-    private void HandleAutoLocking()
-    {
-      if (autoLock &gt; 0 &amp;&amp; (!spring.IsRunning || !Program.main.config.AllowInGameJoin)) {
-        Battle b = tas.GetBattle();
-        int cnt = b.CountPlayers();
-        if (cnt &gt;= autoLock) tas.ChangeLock(true);
+		public void StopVote()
+		{
+			pollTimer.Enabled = false;
+			activePoll = null;
+		}
 
-        if (cnt &lt; autoLock) tas.ChangeLock(false);
-      }
-    }
+		#endregion
 
-    private void HandleMinRankKicking()
-    {
-      if (kickMinRank &amp;&amp; config.MinRank &gt; 0) {
-        Battle b = tas.GetBattle();
-        if (b != null) {
-          foreach (UserBattleStatus u in b.Users) {
-            User x;
-            tas.GetExistingUser(u.name, out x);
-            if (u.name != tas.UserName &amp;&amp; x.rank &lt; config.MinRank) {
-              SayBattle(x.name + &quot;, your rank is too low, rank kicking is enabled here&quot;);
-              ComKick(TasSayEventArgs.Default, new string[] {u.name});
-            }
-          }
-        }
-      }
-    }
+		#region Other methods
 
+		private void CheckForBattleExit()
+		{
+			if ((DateTime.Now - spring.GameStarted) &gt; TimeSpan.FromSeconds(20)) {
+				if (spring.IsRunning) {
+					var b = tas.GetBattle();
+					int count = 0;
+					foreach (var p in b.Users) {
+						if (p.IsSpectator) continue;
 
-    private void tas_BattleUserJoined(object sender, TasEventArgs e)
-    {
-      string name = e.ServerParams[0];
-      string welc = config.Welcome;
-      if (welc != &quot;&quot;) {
-        welc = welc.Replace(&quot;%1&quot;, name);
-        welc = welc.Replace(&quot;%2&quot;, GetUserLevel(name).ToString());
-        welc = welc.Replace(&quot;%3&quot;, MainConfig.SpringieVersion);
-        SayBattle(welc, false);
-      }
-      if (Program.main.config.AllowInGameJoin &amp;&amp; spring.IsRunning) {
-        SayBattle(&quot;GAME IS CURRENTLY IN PROGRESS, PLEASE WAIT TILL IT ENDS!&quot;, false);
-        SayBattle(&quot;If you say !notify, I will PM you when game ends.&quot;, false);
-      }
-      if (config.DisplayMapLink) SayBattle(&quot;maplink: &quot; + linker.GetMapBounceLink(tas.GetBattle().Map.Name), false);
+						User u;
+						if (!tas.GetExistingUser(p.name, out u)) continue;
+						if (u.isInGame) count++;
+					}
+					if (count &lt; 1) {
+						SayBattle(&quot;closing game, &quot; + count + &quot; active player left in game&quot;);
+						spring.ExitGame();
+					}
+				}
+				// kontrola pro pripad ze by se nevypl spring
+				User us;
+				if (!spring.IsRunning &amp;&amp; tas.GetExistingUser(tas.UserName, out us) &amp;&amp; us.isInGame) tas.ChangeMyStatus(false, false);
+			}
+		}
 
-      HandleKickSpecServerLocking();
-      HandleAutoLocking();
-      HandleMinRankKicking();
+		private void HandleAutoLocking()
+		{
+			if (autoLock &gt; 0 &amp;&amp; (!spring.IsRunning || !Program.main.config.AllowInGameJoin)) {
+				var b = tas.GetBattle();
+				int cnt = b.CountPlayers();
+				if (cnt &gt;= autoLock) tas.ChangeLock(true);
 
-      if (minCpuSpeed &gt; 0) {
-        User u;
-        if (tas.GetExistingUser(name, out u)) {
-          if (u.cpu != 0 &amp;&amp; u.cpu &lt; minCpuSpeed*1000) {
-            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
-            SayBattle(name + &quot;, your CPU speed is below minimum set for this server:&quot; + minCpuSpeed + &quot;GHz - sorry&quot;);
-            ComKick(TasSayEventArgs.Default, new string[] {u.name});
-          }
-        }
-      }
-    }
+				if (cnt &lt; autoLock) tas.ChangeLock(false);
+			}
+		}
 
+		private void HandleKickSpecServerLocking()
+		{
+			if (!spring.IsRunning &amp;&amp; (KickSpectators || lockedByKickSpec)) {
+				var b = tas.GetBattle();
+				int cnt = b.CountPlayers();
+				if (KickSpectators &amp;&amp; cnt &gt;= b.MaxPlayers) {
+					lockedByKickSpec = true;
+					tas.ChangeLock(true);
+				}
 
-    private void CheckForBattleExit()
-    {
-      if ((DateTime.Now - spring.GameStarted) &gt; TimeSpan.FromSeconds(20)) {
-        if (spring.IsRunning) {
-          Battle b = tas.GetBattle();
-          int count = 0;
-          foreach (UserBattleStatus p in b.Users) {
-            if (p.IsSpectator) continue;
+				if (lockedByKickSpec &amp;&amp; cnt &lt; b.MaxPlayers) {
+					lockedByKickSpec = false;
+					tas.ChangeLock(false);
+				}
+			}
+		}
 
-            User u;
-            if (!tas.GetExistingUser(p.name, out u)) continue;
-            if (u.isInGame) count++;
-          }
-          if (count &lt; 1) {
-            SayBattle(&quot;closing game, &quot; + count + &quot; active player left in game&quot;);
-            spring.ExitGame();
-          }
-        }
-        // kontrola pro pripad ze by se nevypl spring
-        User us;
-        if (!spring.IsRunning &amp;&amp; tas.GetExistingUser(tas.UserName, out us) &amp;&amp; us.isInGame) tas.ChangeMyStatus(false, false);
-      }
-    }
+		private void HandleMinRankKicking()
+		{
+			if (kickMinRank &amp;&amp; config.MinRank &gt; 0) {
+				var b = tas.GetBattle();
+				if (b != null) {
+					foreach (var u in b.Users) {
+						User x;
+						tas.GetExistingUser(u.name, out x);
+						if (u.name != tas.UserName &amp;&amp; x.rank &lt; config.MinRank) {
+							SayBattle(x.name + &quot;, your rank is too low, rank kicking is enabled here&quot;);
+							ComKick(TasSayEventArgs.Default, new[] {u.name});
+						}
+					}
+				}
+			}
+		}
 
+		#endregion
 
-    private void tas_UserStatusChanged(object sender, TasEventArgs e)
-    {
-      if (spring.IsRunning) {
-        Battle b = tas.GetBattle();
-        if (e.ServerParams[0] != tas.UserName &amp;&amp; b.ContainsUser(e.ServerParams[0])) CheckForBattleExit();
-      }
-    }
+		#region Event Handlers
 
-    private void tas_BattleUserLeft(object sender, TasEventArgs e)
-    {
-      CheckForBattleExit();
-      HandleKickSpecServerLocking();
-      HandleAutoLocking();
+		private void fileDownloader_DownloadCompleted(object sender, FileDownloader.DownloadEventArgs e)
+		{
+			string mes;
+			if (e.Status == FileDownloader.Status.Failed) mes = e.DownloadItem.fileName + &quot; download failed: &quot; + e.Message;
+			else {
+				mes = e.DownloadItem.fileName + &quot; download finished!&quot;;
+				spring.Reload(true, true);
+			}
+			if (tas.IsConnected) SayBattle(mes);
+			if (e.DownloadItem.fileType == FileDownloader.FileType.Mod &amp;&amp; !spring.IsRunning) Start(e.DownloadItem.fileName, null);
+		}
 
-      if (spring.IsRunning) spring.SayGame(e.ServerParams[0] + &quot; has left lobby&quot;);
+		private void pollTimer_Elapsed(object sender, ElapsedEventArgs e)
+		{
+			if (activePoll != null) activePoll.TimeEnd();
+			StopVote();
+		}
 
-      if (e.ServerParams[0] == bossName) {
-        SayBattle(&quot;boss has left the battle&quot;);
-        bossName = &quot;&quot;;
-      }
+		private void spring_GameOver(object sender, SpringLogEventArgs e)
+		{
+			Thread.Sleep(3000); // wait for stats
+			SayBattle(&quot;Game over, exiting&quot;);
+			spring.ExitGame();
 
-      if (tas.GetBattle().IsLocked &amp;&amp; tas.GetBattle().Users.Count &lt; 2) {
-        // player left and only 2 remaining (springie itself + some noob) -&gt; unlock
-        tas.ChangeLock(false);
-      }
-    }
+			if (config.MapCycle.Length &gt; 0) {
+				mapCycleIndex = mapCycleIndex%config.MapCycle.Length;
+				SayBattle(&quot;changing to another map in mapcycle&quot;);
+				ComMap(TasSayEventArgs.Default, config.MapCycle[mapCycleIndex].Split(new[] {' '}, StringSplitOptions.RemoveEmptyEntries));
+				mapCycleIndex++;
+			}
+		}
 
-    private void spring_SpringExited(object sender, EventArgs e)
-    {
-      tas.ChangeLock(false);
-      Battle b = tas.GetBattle();
-      foreach (string s in toNotify) {
-        if (b != null &amp;&amp; b.ContainsUser(s)) tas.Ring(s);
-        tas.Say(TasClient.SayPlace.User, s, &quot;** Game just ended, join me! **&quot;, false);
-      }
-      toNotify.Clear();
-    }
+		private void spring_SpringExited(object sender, EventArgs e)
+		{
+			tas.ChangeLock(false);
+			var b = tas.GetBattle();
+			foreach (var s in toNotify) {
+				if (b != null &amp;&amp; b.ContainsUser(s)) tas.Ring(s);
+				tas.Say(TasClient.SayPlace.User, s, &quot;** Game just ended, join me! **&quot;, false);
+			}
+			toNotify.Clear();
+		}
 
+		private void tas_BattleFound(object sender, TasEventArgs e)
+		{
+			string map = Utils.Glue(e.ServerParams.ToArray(), 10).Split('\t')[0];
+			if (config.AutoDownloadNewMaps &amp;&amp; !spring.IsRunning &amp;&amp; !spring.UnitSync.MapList.ContainsKey(map)) fileDownloader.DownloadMap(map);
+		}
 
-    public int GetUserLevel(TasSayEventArgs e)
-    {
-      return GetUserLevel(e.UserName);
-    }
+		private void tas_BattleLockChanged(object sender, TasEventArgs e)
+		{
+			SayBattle(&quot;game &quot; + (tas.GetBattle().IsLocked ? &quot;locked&quot; : &quot;unlocked&quot;), false);
+		}
 
-    public int GetUserLevel(string name)
-    {
-      foreach (PrivilegedUser pu in config.PrivilegedUsers) if (pu.Name == name) return pu.Level;
-      User u;
-      if (tas.GetExistingUser(name, out u)) if (u.isAdmin) return config.DefaulRightsLevelForLobbyAdmins;
-      return config.DefaulRightsLevel;
-    }
+		private void tas_BattleMapChanged(object sender, TasEventArgs e)
+		{
+			if (config.DisplayMapLink) SayBattle(&quot;maplink: &quot; + linker.GetMapBounceLink(tas.GetBattle().Map.Name));
 
+			var b = tas.GetBattle();
+			string mapName = b.Map.ArchiveName.ToLower();
+			if (MapBoxes.ContainsKey(mapName)) {
+				for (int i = 0; i &lt; b.Rectangles.Count; ++i) tas.RemoveBattleRectangle(i);
+				var dict = MapBoxes[mapName];
+				foreach (var v in dict) tas.AddBattleRectangle(v.Key, v.Value);
+			}
 
-    public bool HasRights(string command, TasSayEventArgs e)
-    {
-      if (banList.IsBanned(e.UserName)) {
-        Respond(e, &quot;tough luck, you are banned&quot;);
-        return false;
-      }
-      foreach (CommandConfig c in config.Commands) {
-        if (c.Name == command) {
-          if (c.Throttling &gt; 0) {
-            int diff = (int)DateTime.Now.Subtract(c.lastCall).TotalSeconds;
-            if (diff &lt; c.Throttling) {
-              Respond(e, &quot;AntiSpam - please wait &quot; + (c.Throttling - diff).ToString() + &quot; more seconds&quot;);
-              return false;
-            }
-          }
 
-          for (int i = 0; i &lt; c.ListenTo.Length; i++) {
-            if (c.ListenTo[i] == e.Place) {
-              int reqLevel = c.Level;
-              int ulevel = GetUserLevel(e);
+			if (Program.main.config.PlanetWarsEnabled) {
+				try {
+					var pw = Program.main.PlanetWars;
 
-              if (ulevel &gt;= reqLevel) {
-                // boss stuff
-                if (bossName != &quot;&quot; &amp;&amp; ulevel &lt;= config.DefaulRightsLevel &amp;&amp; e.UserName != bossName &amp;&amp; config.DefaultRightsLevelWithBoss &lt; reqLevel) {
-                  Respond(e, &quot;Sorry, you cannot do this right now, ask boss admin &quot; + bossName);
-                  return false;
-                } else {
-                  c.lastCall = DateTime.Now;
-                  return true; // ALL OK
-                }
-              } else {
-                Respond(e, &quot;Sorry, you do not have rights to execute &quot; + command);
-                return false;
-              }
-            }
-          }
-          return false; // place not allowed for this command = ignore command
-        }
-      }
-      if (e.Place != TasSayEventArgs.Places.Channel) Respond(e, &quot;Sorry, I don't know command '&quot; + command + &quot;'&quot;);
-      return false;
-    }
+					string name = tas.GetBattle().Map.Name;
+					var mapInfo = pw.GetAttackOptions().Find(m =&gt; m.MapName == name);
+					if (mapInfo.StartBoxes != null &amp;&amp; mapInfo.StartBoxes.Count &gt; 0) {
+						int rectangles = tas.GetBattle().Rectangles.Count;
+						for (int i = 0; i &lt; rectangles; ++i) tas.RemoveBattleRectangle(i);
+						for (int i = 0; i &lt; mapInfo.StartBoxes.Count; ++i) {
+							var mi = mapInfo.StartBoxes[i];
+							tas.AddBattleRectangle(i, new BattleRect(mi.Left, mi.Top, mi.Right, mi.Bottom));
+						}
+					}
 
-    public void Respond(TasSayEventArgs e, string text)
-    {
-      Respond(tas, spring, e, text);
-    }
+					foreach (var command in mapInfo.AutohostCommands) tas.Say(TasClient.SayPlace.Channel, tas.UserName, command, false);
 
-    public static void Respond(TasClient tas, Spring spring, TasSayEventArgs e, string text)
-    {
-      TasClient.SayPlace p = TasClient.SayPlace.User;
-      bool emote = false;
-      if (e.Place == TasSayEventArgs.Places.Battle) {
-        p = TasClient.SayPlace.Battle;
-        emote = true;
-      }
-      if (e.Place == TasSayEventArgs.Places.Game &amp;&amp; spring.IsRunning) spring.SayGame(text);
-      else tas.Say(p, e.UserName, text, emote);
-    }
+					SayBattle(&quot;Planet changed succesfully!&quot;);
 
+					var notifyList = pw.GetPlayersToNotify(name);
+					notifyList.ForEach(userName =&gt; tas.Say(TasClient.SayPlace.User, userName, string.Format(&quot;Your planet {0} is under attack! Come defend it!&quot;, mapInfo.Name), false));
+				} catch (Exception ex) {
+					SayBattle(string.Format(&quot;Error setting planet starting boxes: {0}&quot;, ex.Message));
+				}
+			}
+		}
 
-    public void SayBattle(string text)
-    {
-      SayBattle(text, true);
-    }
+		private void tas_BattleOpened(object sender, TasEventArgs e)
+		{
+			tas.DisableUnits(UnitInfo.ToStringList(config.DisabledUnits));
+		}
 
-    public void SayBattle(string text, bool ingame)
-    {
-      SayBattle(tas, spring, text, ingame);
-    }
+		private void tas_BattleUserJoined(object sender, TasEventArgs e)
+		{
+			string name = e.ServerParams[0];
+			string welc = config.Welcome;
+			if (welc != &quot;&quot;) {
+				welc = welc.Replace(&quot;%1&quot;, name);
+				welc = welc.Replace(&quot;%2&quot;, GetUserLevel(name).ToString());
+				welc = welc.Replace(&quot;%3&quot;, MainConfig.SpringieVersion);
+				SayBattle(welc, false);
+			}
+			if (Program.main.config.AllowInGameJoin &amp;&amp; spring.IsRunning) {
+				var started = DateTime.Now.Subtract(spring.GameStarted);
+				started = new TimeSpan((int) started.TotalHours, started.Minutes, started.Seconds);
+				SayBattle(string.Format(&quot;GAME IS CURRENTLY IN PROGRESS, PLEASE WAIT TILL IT ENDS! Running for {0}&quot;, started), false);
+				SayBattle(&quot;If you say !notify, I will PM you when game ends.&quot;, false);
+			}
+			if (config.DisplayMapLink) SayBattle(&quot;maplink: &quot; + linker.GetMapBounceLink(tas.GetBattle().Map.Name), false);
 
+			HandleKickSpecServerLocking();
+			HandleAutoLocking();
+			HandleMinRankKicking();
 
-    public static void SayBattle(TasClient tas, Spring spring, string text, bool ingame)
-    {
-      tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, text, true);
-      if (spring.IsRunning &amp;&amp; ingame) spring.SayGame(text);
-    }
+			if (minCpuSpeed &gt; 0) {
+				User u;
+				if (tas.GetExistingUser(name, out u)) {
+					if (u.cpu != 0 &amp;&amp; u.cpu &lt; minCpuSpeed*1000) {
+						Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+						SayBattle(name + &quot;, your CPU speed is below minimum set for this server:&quot; + minCpuSpeed + &quot;GHz - sorry&quot;);
+						ComKick(TasSayEventArgs.Default, new[] {u.name});
+					}
+				}
+			}
 
+			if (Program.main.config.PlanetWarsEnabled) {
+				var current = Program.main.PlanetWars.GetOffensiveFaction();
+				var info = Program.main.PlanetWars.GetPlayerInfo(name);
+				SayBattle(string.Format(&quot;{0} {1} {2}. Attacking faction is {3}&quot;, info.IsCommanderInChief ? &quot;All hail to&quot; : &quot;Greetings, &quot;, info.RankText, name, current.Name), false);
+			}
+		}
 
-    private void tas_Said(object sender, TasSayEventArgs e)
-    {
-      // check if it's command
-      if (e.Origin == TasSayEventArgs.Origins.Player &amp;&amp; !e.IsEmote &amp;&amp; e.Text.StartsWith(&quot;!&quot;)) {
-        if (e.Text.Length &lt; 2) return;
-        string[] allwords = e.Text.Substring(1).Split(new char[] {' '}, StringSplitOptions.RemoveEmptyEntries);
-        if (allwords.Length &lt; 1) return;
-        string com = allwords[0];
+		private void tas_BattleUserLeft(object sender, TasEventArgs e)
+		{
+			CheckForBattleExit();
+			HandleKickSpecServerLocking();
+			HandleAutoLocking();
 
-        // remove first word (command)
-        string[] words = Utils.ShiftArray(allwords, -1);
+			if (spring.IsRunning) spring.SayGame(e.ServerParams[0] + &quot; has left lobby&quot;);
 
-        if (!HasRights(com, e)) return;
-        switch (com) {
-          case &quot;listmaps&quot;:
-            ComListMaps(e, words);
-            break;
+			if (e.ServerParams[0] == bossName) {
+				SayBattle(&quot;boss has left the battle&quot;);
+				bossName = &quot;&quot;;
+			}
 
-          case &quot;listmods&quot;:
-            ComListMods(e, words);
-            break;
+			if (tas.GetBattle().IsLocked &amp;&amp; tas.GetBattle().Users.Count &lt; 2) {
+				// player left and only 2 remaining (springie itself + some noob) -&gt; unlock
+				tas.ChangeLock(false);
+			}
+		}
 
-          case &quot;help&quot;:
-            ComHelp(e, words);
-            break;
+		private void tas_BattleUserStatusChanged(object sender, TasEventArgs e)
+		{
+			UserBattleStatus u;
+			var b = tas.GetBattle();
 
-          case &quot;map&quot;:
-            ComMap(e, words);
-            break;
+			if (b != null &amp;&amp; b.ContainsUser(e.ServerParams[0], out u)) {
+				/*if (u.SyncStatus == SyncStatuses.Unsynced) {
+          SayBattle(&quot;kicking &quot; + u.name + &quot; - has incorrect spring or mod version&quot;);
+          tas.Kick(u.name);
+        }*/
 
-          case &quot;admins&quot;:
-            ComAdmins(e, words);
-            break;
 
-          case &quot;start&quot;:
-            ComStart(e, words);
-            break;
+				if (Program.main.config.PlanetWarsEnabled &amp;&amp; u.name != tas.UserName) {
+					try {
+						var pw = Program.main.PlanetWars;
+						var info = pw.GetPlayerInfo(u.name);
+						var factions = pw.GetFactions();
+						if (info == null) {
+							if (!u.IsSpectator) {
+								tas.ForceSpectator(u.name);
+								SayBattle(string.Format(&quot;{0} cannot play, (s)he is not registered, register using PlanetWars client or !register command&quot;, u.name), false);
+								return;
+							}
+						} else {
+							int hisFaction = factions.IndexOf(factions.Find((f) =&gt; f.Name == info.FactionName));
+							if (u.AllyNumber != hisFaction) {
+								tas.ForceAlly(u.name, hisFaction);
+								SayBattle(string.Format(&quot;{0} must play in team {1}&quot;, u.name, hisFaction + 1), false);
+								return;
+							}
+						}
+					} catch (Exception ex) {
+						SayBattle(string.Format(&quot;Warning, PlanetWars problem: {0} &quot;, ex.Message), false);
+					}
+				}
 
-          case &quot;forcestart&quot;:
-            ComForceStart(e, words);
-            break;
 
-          case &quot;force&quot;:
-            ComForce(e, words);
-            break;
+				if (KickSpectators &amp;&amp; u.IsSpectator &amp;&amp; u.name != tas.UserName) {
+					SayBattle(config.KickSpectatorText);
+					ComKick(TasSayEventArgs.Default, new[] {u.name});
+				}
+				HandleAutoLocking();
 
-          case &quot;split&quot;:
-            ComSplit(e, words);
-            break;
+				int cnt = 0;
+				foreach (var ubs in b.Users) if (!ubs.IsSpectator &amp;&amp; ubs.IsReady) cnt++;
+				List&lt;string&gt; usname;
+				int allyno;
+				if (!manager.Enabled) {
+					if ((cnt == config.MaxPlayers || (autoLock &gt; 0 &amp;&amp; autoLock == cnt)) &amp;&amp; AllReadyAndSynced(out usname) &amp;&amp; AllUniqueTeams(out usname) &amp;&amp; BalancedTeams(out allyno)) {
+						SayBattle(&quot;server is full, starting&quot;);
+						Thread.Sleep(1000); // just to make sure that other clients update their game info and balance ends
+						ComStart(TasSayEventArgs.Default, new string[] {});
+					}
+				}
+			}
+		}
 
-          case &quot;corners&quot;:
-            ComCorners(e, words);
-            break;
+		private void tas_Said(object sender, TasSayEventArgs e)
+		{
+			// check if it's command
+			if (e.Origin == TasSayEventArgs.Origins.Player &amp;&amp; !e.IsEmote &amp;&amp; e.Text.StartsWith(&quot;!&quot;)) {
+				if (e.Text.Length &lt; 2) return;
+				var allwords = e.Text.Substring(1).Split(new[] {' '}, StringSplitOptions.RemoveEmptyEntries);
+				if (allwords.Length &lt; 1) return;
+				string com = allwords[0];
 
-          case &quot;maplink&quot;:
-            linker.SayResults(Utils.Glue(words), UnknownFilesLinker.FileType.Map, tas, e);
-            break;
+				// remove first word (command)
+				var words = Utils.ShiftArray(allwords, -1);
 
-          case &quot;modlink&quot;:
-            linker.SayResults(Utils.Glue(words), UnknownFilesLinker.FileType.Mod, tas, e);
-            break;
+				if (!HasRights(com, e)) return;
+				switch (com) {
+					case &quot;listmaps&quot;:
+						ComListMaps(e, words);
+						break;
 
-          case &quot;ring&quot;:
-            ComRing(e, words);
-            break;
+					case &quot;listmods&quot;:
+						ComListMods(e, words);
+						break;
 
-          case &quot;kick&quot;:
-            ComKick(e, words);
-            break;
+					case &quot;help&quot;:
+						ComHelp(e, words);
+						break;
 
-          case &quot;exit&quot;:
-            ComExit(e, words);
-            break;
+					case &quot;map&quot;:
+						ComMap(e, words);
+						break;
 
-          case &quot;lock&quot;:
-            tas.ChangeLock(true);
-            break;
+					case &quot;admins&quot;:
+						ComAdmins(e, words);
+						break;
 
-          case &quot;unlock&quot;:
-            tas.ChangeLock(false);
-            break;
+					case &quot;start&quot;:
+						ComStart(e, words);
+						break;
 
-          case &quot;vote&quot;:
-            RegisterVote(e, words);
-            break;
+					case &quot;forcestart&quot;:
+						ComForceStart(e, words);
+						break;
 
-          case &quot;votemap&quot;:
-            StartVote(new VoteMap(tas, spring, this), e, words);
-            break;
+					case &quot;force&quot;:
+						ComForce(e, words);
+						break;
 
-          case &quot;votekick&quot;:
-            StartVote(new VoteKick(tas, spring, this), e, words);
-            break;
+					case &quot;split&quot;:
+						ComSplit(e, words);
+						break;
 
-          case &quot;voteforcestart&quot;:
-            StartVote(new VoteForceStart(tas, spring, this), e, words);
-            break;
+					case &quot;corners&quot;:
+						ComCorners(e, words);
+						break;
 
-          case &quot;voteforce&quot;:
-            StartVote(new VoteForce(tas, spring, this), e, words);
-            break;
+					case &quot;maplink&quot;:
+						linker.SayResults(Utils.Glue(words), UnknownFilesLinker.FileType.Map, tas, e);
+						break;
 
-          case &quot;voteexit&quot;:
-            StartVote(new VoteExit(tas, spring, this), e, words);
-            break;
+					case &quot;modlink&quot;:
+						linker.SayResults(Utils.Glue(words), UnknownFilesLinker.FileType.Mod, tas, e);
+						break;
 
-          case &quot;votepreset&quot;:
-            StartVote(new VotePreset(tas, spring, this), e, words);
-            break;
+					case &quot;ring&quot;:
+						ComRing(e, words);
+						break;
 
-          case &quot;fix&quot;:
-            ComFix(e, words);
-            break;
+					case &quot;kick&quot;:
+						ComKick(e, words);
+						break;
 
-          case &quot;rehost&quot;:
-            ComRehost(e, words);
-            break;
+					case &quot;exit&quot;:
+						ComExit(e, words);
+						break;
 
-          case &quot;voterehost&quot;:
-            StartVote(new VoteRehost(tas, spring, this), e, words);
-            break;
+					case &quot;lock&quot;:
+						tas.ChangeLock(true);
+						break;
 
-          case &quot;random&quot;:
-            ComRandom(e, words);
-            break;
+					case &quot;unlock&quot;:
+						tas.ChangeLock(false);
+						break;
 
-          case &quot;balance&quot;:
-            ComBalance(e, words);
-            break;
+					case &quot;vote&quot;:
+						RegisterVote(e, words);
+						break;
 
-          case &quot;setlevel&quot;:
-            ComSetLevel(e, words);
-            break;
+					case &quot;votemap&quot;:
+						StartVote(new VoteMap(tas, spring, this), e, words);
+						break;
 
-          case &quot;say&quot;:
-            ComSay(e, words);
-            break;
+					case &quot;votekick&quot;:
+						StartVote(new VoteKick(tas, spring, this), e, words);
+						break;
 
-          case &quot;dlmap&quot;:
-            ComDlMap(e, words);
-            break;
+					case &quot;voteforcestart&quot;:
+						StartVote(new VoteForceStart(tas, spring, this), e, words);
+						break;
 
-          case &quot;dlmod&quot;:
-            ComDlMod(e, words);
-            break;
+					case &quot;voteforce&quot;:
+						StartVote(new VoteForce(tas, spring, this), e, words);
+						break;
 
-          case &quot;reload&quot;:
-            Respond(e, &quot;reloading mod and map list&quot;);
-            spring.Reload(true, true);
-            Respond(e, &quot;reload finished&quot;);
-            break;
+					case &quot;voteexit&quot;:
+						StartVote(new VoteExit(tas, spring, this), e, words);
+						break;
 
-          case &quot;team&quot;:
-            ComTeam(e, words);
-            break;
+					case &quot;votepreset&quot;:
+						StartVote(new VotePreset(tas, spring, this), e, words);
+						break;
 
-          case &quot;ally&quot;:
-            ComAlly(e, words);
-            break;
+					case &quot;fix&quot;:
+						ComFix(e, words);
+						break;
 
-          case &quot;helpall&quot;:
-            ComHelpAll(e, words);
-            break;
+					case &quot;rehost&quot;:
+						ComRehost(e, words);
+						break;
 
-          case &quot;fixcolors&quot;:
-            ComFixColors(e, words);
-            break;
+					case &quot;voterehost&quot;:
+						StartVote(new VoteRehost(tas, spring, this), e, words);
+						break;
 
-          case &quot;springie&quot;:
-            ComSpringie(e, words);
-            break;
+					case &quot;random&quot;:
+						ComRandom(e, words);
+						break;
 
-          case &quot;endvote&quot;:
-            StopVote();
-            SayBattle(&quot;poll cancelled&quot;);
-            break;
+					case &quot;balance&quot;:
+						ComBalance(e, words);
+						break;
 
-          case &quot;addbox&quot;:
-            ComAddBox(e, words);
-            break;
+					case &quot;setlevel&quot;:
+						ComSetLevel(e, words);
+						break;
 
-          case &quot;clearbox&quot;:
-            ComClearBox(e, words);
-            break;
+					case &quot;say&quot;:
+						ComSay(e, words);
+						break;
 
-          case &quot;listpresets&quot;:
-            ComListPresets(e, words);
-            break;
+					case &quot;dlmap&quot;:
+						ComDlMap(e, words);
+						break;
 
-          case &quot;presetdetails&quot;:
-            ComPresetDetails(e, words);
-            break;
+					case &quot;dlmod&quot;:
+						ComDlMod(e, words);
+						break;
 
-          case &quot;preset&quot;:
-            ComPreset(e, words);
-            break;
+					case &quot;reload&quot;:
+						Respond(e, &quot;reloading mod and map list&quot;);
+						spring.Reload(true, true);
+						Respond(e, &quot;reload finished&quot;);
+						break;
 
-          case &quot;cbalance&quot;:
-            ComCBalance(e, words);
-            break;
+					case &quot;id&quot;:
+						ComTeam(e, words);
+						break;
 
-          case &quot;listbans&quot;:
-            banList.ComListBans(e, words);
-            break;
+					case &quot;team&quot;:
+						ComAlly(e, words);
+						break;
 
-          case &quot;ban&quot;:
-            banList.ComBan(e, words);
-            break;
+					case &quot;helpall&quot;:
+						ComHelpAll(e, words);
+						break;
 
-          case &quot;unban&quot;:
-            banList.ComUnban(e, words);
-            break;
+					case &quot;fixcolors&quot;:
+						ComFixColors(e, words);
+						break;
 
-          case &quot;smurfs&quot;:
-            RemoteCommand(Stats.smurfScript, e, words);
-            break;
+					case &quot;springie&quot;:
+						ComSpringie(e, words);
+						break;
 
-          case &quot;stats&quot;:
-            RemoteCommand(Stats.statsScript, e, words);
-            break;
+					case &quot;endvote&quot;:
+						StopVote();
+						SayBattle(&quot;poll cancelled&quot;);
+						break;
 
-          case &quot;kickspec&quot;:
-            ComKickSpec(e, words);
-            break;
+					case &quot;addbox&quot;:
+						ComAddBox(e, words);
+						break;
 
-          case &quot;manage&quot;:
-            ComManage(e, words);
-            break;
+					case &quot;clearbox&quot;:
+						ComClearBox(e, words);
+						break;
 
-          case &quot;notify&quot;:
-            ComNotify(e, words);
-            break;
+					case &quot;listpresets&quot;:
+						ComListPresets(e, words);
+						break;
 
-          case &quot;votekickspec&quot;:
-            StartVote(new VoteKickSpec(tas, spring, this), e, words);
-            break;
+					case &quot;presetdetails&quot;:
+						ComPresetDetails(e, words);
+						break;
 
-          case &quot;boss&quot;:
-            ComBoss(e, words);
-            break;
+					case &quot;preset&quot;:
+						ComPreset(e, words);
+						break;
 
-          case &quot;voteboss&quot;:
-            StartVote(new VoteBoss(tas, spring, this), e, words);
-            break;
+					case &quot;cbalance&quot;:
+						ComCBalance(e, words);
+						break;
 
-          case &quot;setpassword&quot;:
-            ComSetPassword(e, words);
-            break;
+					case &quot;listbans&quot;:
+						banList.ComListBans(e, words);
+						break;
 
-          case &quot;setgametitle&quot;:
-            ComSetGameTitle(e, words);
-            break;
+					case &quot;ban&quot;:
+						banList.ComBan(e, words);
+						break;
 
-          case &quot;setminrank&quot;:
-            ComSetMinRank(e, words);
-            break;
+					case &quot;unban&quot;:
+						banList.ComUnban(e, words);
+						break;
 
-          case &quot;setmaxplayers&quot;:
-            ComSetMaxPlayers(e, words);
-            break;
+					case &quot;smurfs&quot;:
+						RemoteCommand(Stats.smurfScript, e, words);
+						break;
 
-          case &quot;mincpuspeed&quot;:
-            ComSetMinCpuSpeed(e, words);
-            break;
+					case &quot;stats&quot;:
+						RemoteCommand(Stats.statsScript, e, words);
+						break;
 
-          case &quot;autolock&quot;:
-            ComAutoLock(e, words);
-            break;
+					case &quot;kickspec&quot;:
+						ComKickSpec(e, words);
+						break;
 
-          case &quot;spec&quot;:
-            ComForceSpectator(e, words);
-            break;
+					case &quot;manage&quot;:
+						ComManage(e, words);
+						break;
 
-          case &quot;specafk&quot;:
-            ComForceSpectatorAfk(e, words);
-            break;
+					case &quot;notify&quot;:
+						ComNotify(e, words);
+						break;
 
-          case &quot;kickminrank&quot;:
-            ComKickMinRank(e, words);
-            break;
+					case &quot;votekickspec&quot;:
+						StartVote(new VoteKickSpec(tas, spring, this), e, words);
+						break;
 
-          case &quot;cheats&quot;:
-            if (spring.IsRunning) spring.SayGame(&quot;.cheats&quot;);
-            break;
+					case &quot;boss&quot;:
+						ComBoss(e, words);
+						break;
 
-          case &quot;listoptions&quot;:
-            ComListOptions(e, words);
-            break;
+					case &quot;voteboss&quot;:
+						StartVote(new VoteBoss(tas, spring, this), e, words);
+						break;
 
-          case &quot;setoptions&quot;:
-            ComSetOption(e, words);
-            break;
+					case &quot;setpassword&quot;:
+						ComSetPassword(e, words);
+						break;
 
-          case &quot;votesetoptions&quot;:
-            StartVote(new VoteSetOptions(tas, spring, this), e, words);
-            break;
-        }
-      }
-    }
+					case &quot;setgametitle&quot;:
+						ComSetGameTitle(e, words);
+						break;
 
+					case &quot;setminrank&quot;:
+						ComSetMinRank(e, words);
+						break;
 
-    public void StopVote()
-    {
-      pollTimer.Enabled = false;
-      activePoll = null;
-    }
+					case &quot;setmaxplayers&quot;:
+						ComSetMaxPlayers(e, words);
+						break;
 
-    public void StartVote(IVotable vote, TasSayEventArgs e, string[] words)
-    {
-      if (vote != null) {
-        if (activePoll != null) {
-          Respond(e, &quot;Another poll already in progress, please wait&quot;);
-          return;
-        }
-        if (vote.Init(e, words)) {
-          activePoll = vote;
-          pollTimer.Interval = PollTimeout*1000;
-          pollTimer.Enabled = true;
-        }
-      }
-    }
+					case &quot;mincpuspeed&quot;:
+						ComSetMinCpuSpeed(e, words);
+						break;
 
-    public void RegisterVote(TasSayEventArgs e, string[] words)
-    {
-      if (activePoll != null) {
-        if (activePoll.Vote(e, words)) StopVote();
-      } else Respond(e, &quot;There is no poll going on, start some first&quot;);
-    }
+					case &quot;autolock&quot;:
+						ComAutoLock(e, words);
+						break;
 
+					case &quot;spec&quot;:
+						ComForceSpectator(e, words);
+						break;
 
-    private void pollTimer_Elapsed(object sender, ElapsedEventArgs e)
-    {
-      if (activePoll != null) activePoll.TimeEnd();
-      StopVote();
-    }
+					case &quot;specafk&quot;:
+						ComForceSpectatorAfk(e, words);
+						break;
 
+					case &quot;kickminrank&quot;:
+						ComKickMinRank(e, words);
+						break;
 
-    public void Stop()
-    {
-      if (manager != null) manager.Stop();
-      StopVote();
-      spring.ExitGame();
-      tas.ChangeMyStatus(false, false);
-      tas.LeaveBattle();
-    }
-  }
+					case &quot;cheats&quot;:
+						if (spring.IsRunning) spring.SayGame(&quot;.cheats&quot;);
+						break;
+
+					case &quot;listoptions&quot;:
+						ComListOptions(e, words);
+						break;
+
+					case &quot;setoptions&quot;:
+						ComSetOption(e, words);
+						break;
+
+					case &quot;votesetoptions&quot;:
+						StartVote(new VoteSetOptions(tas, spring, this), e, words);
+						break;
+
+					case &quot;listplanets&quot;:
+						ComListPlanets(e, words);
+						break;
+
+					case &quot;register&quot;:
+						ComRegister(e, words);
+						break;
+
+
+					case &quot;planet&quot;:
+						ComPlanet(e, words);
+						break;
+
+					case &quot;setpwserver&quot;:
+						if (words.Length &lt; 1) Respond(e, &quot;Specify address&quot;);
+						else {
+							// hack this is just debug, remove this later
+							Program.main.config.PlanetWarsServer = words[0];
+							Program.main.InitializePlanetWarsServer();
+							Respond(e, &quot;Planetwars server changed to &quot; + words[0]);
+						}
+						break;
+
+					case &quot;voteplanet&quot;:
+						if (Program.main.config.PlanetWarsEnabled) StartVote(new VotePlanet(tas, spring, this), e, words);
+						else Respond(e, &quot;PlanetWars not enabled on this host&quot;);
+						break;
+				}
+			}
+		}
+
+		private void tas_UserStatusChanged(object sender, TasEventArgs e)
+		{
+			if (spring.IsRunning) {
+				var b = tas.GetBattle();
+				if (e.ServerParams[0] != tas.UserName &amp;&amp; b.ContainsUser(e.ServerParams[0])) CheckForBattleExit();
+			}
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/AutoHostConfig.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/AutoHostConfig.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/AutoHostConfig.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System.Collections.Generic;
 using System.ComponentModel;
 using Springie.Client;
@@ -3,475 +5,458 @@
 using Springie.SpringNamespace;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public class AutoHostConfig
-  {
-    private bool autoDownloadNewMaps = false;
-    private int autoLockMinPlayers = 2;
-    private BattleDetails battleDetails = new BattleDetails();
-    public List&lt;CommandConfig&gt; Commands = new List&lt;CommandConfig&gt;();
-    private int defaulRightsLevel = 1;
-    private int defaulRightsLevelForLobbyAdmins = 4;
-    private string defaultMap = &quot;SmallDivide.smf&quot;;
-    private string defaultMod = &quot;XTA v8&quot;;
-    public List&lt;BattleRect&gt; DefaultRectangles = new List&lt;BattleRect&gt;();
-    private int defaultRightsLevelWithBoss = 0;
-    private UnitInfo[] disabledUnits = new UnitInfo[] {};
-    private bool displayMapLink = true;
-    private string gameTitle = &quot;AutoHost (%1)&quot;;
-    private int hostingPort = 8452;
-    private bool kickMinRank = false;
-    private bool kickSpectators = false;
-    private string kickSpectatorText = &quot;spectators not allowed here at this time, sorry&quot;;
-    private int ladderId = 0;
-    private string[] limitMaps;
-    private string[] limitMods;
-    private string[] mapCycle = new string[] {};
-    private int maxPlayers = 10;
-    private double minCpuSpeed = 0;
-    private int minRank = 0;
-    private string password = &quot;*&quot;;
-    public List&lt;PrivilegedUser&gt; PrivilegedUsers = new List&lt;PrivilegedUser&gt;();
-    private bool useHolePunching = false;
-    private string welcome = &quot;Hi %1 (rights:%2), welcome to %3, automated host. For help say !help&quot;;
+	public class AutoHostConfig
+	{
+		#region Fields
 
-    public AutoHostConfig() {}
+		private int autoLockMinPlayers = 2;
+		private BattleDetails battleDetails = new BattleDetails();
+		private int defaulRightsLevel = 1;
+		private int defaulRightsLevelForLobbyAdmins = 4;
+		private string defaultMap = &quot;SmallDivide.smf&quot;;
+		private string defaultMod = &quot;XTA v8&quot;;
+		private UnitInfo[] disabledUnits = new UnitInfo[] {};
+		private bool displayMapLink = true;
+		private string gameTitle = &quot;AutoHost (%1)&quot;;
+		private int hostingPort = 8452;
+		private string kickSpectatorText = &quot;spectators not allowed here at this time, sorry&quot;;
+		private string[] mapCycle = new string[] {};
+		private int maxPlayers = 10;
+		private string password = &quot;*&quot;;
+		private string welcome = &quot;Hi %1 (rights:%2), welcome to %3, automated host. For help say !help&quot;;
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Game password&quot;)]
-    public string Password
-    {
-      get { return password; }
-      set { password = value; }
-    }
+		#endregion
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Hosting port number&quot;)]
-    public int HostingPort
-    {
-      get { return hostingPort; }
-      set { hostingPort = value; }
-    }
+		#region Properties
 
+		[Category(&quot;Mod and map&quot;)]
+		[Description(&quot;Should springie redirect global game chat to lobby?&quot;)]
+		public bool AutoDownloadNewMaps { get; set; }
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Should Springie use hole punching NAT traversal method? - Incompatible with gargamel mode&quot;)]
-    public bool UseHolePunching
-    {
-      get { return useHolePunching; }
-      set { useHolePunching = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Minimum number of players for autolocking&quot;)]
+		public int AutoLockMinPlayers
+		{
+			get { return autoLockMinPlayers; }
+			set { autoLockMinPlayers = value; }
+		}
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Maximum number of players&quot;)]
-    public int MaxPlayers
-    {
-      get { return maxPlayers; }
-      set { maxPlayers = value; }
-    }
+		[Category(&quot;Default battle settings&quot;)]
+		[Description(&quot;Defines battle details to use by default&quot;)]
+		public BattleDetails BattleDetails
+		{
+			get { return battleDetails; }
+			set { battleDetails = value; }
+		}
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Minimum rank to be allowed to join&quot;)]
-    public int MinRank
-    {
-      get { return minRank; }
-      set { minRank = value; }
-    }
+		public List&lt;CommandConfig&gt; Commands = new List&lt;CommandConfig&gt;();
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Should autohost kick people below min rank?&quot;)]
-    public bool KickMinRank
-    {
-      get { return kickMinRank; }
-      set { kickMinRank = value; }
-    }
+		[Category(&quot;Rights&quot;)]
+		[Description(&quot;Default rights level for non-privileged users&quot;)]
+		public int DefaulRightsLevel
+		{
+			get { return defaulRightsLevel; }
+			set { defaulRightsLevel = value; }
+		}
 
+		[Category(&quot;Rights&quot;)]
+		[Description(&quot;Default rights level for lobby admins (mod admins)&quot;)]
+		public int DefaulRightsLevelForLobbyAdmins
+		{
+			get { return defaulRightsLevelForLobbyAdmins; }
+			set { defaulRightsLevelForLobbyAdmins = value; }
+		}
 
-    [Category(&quot;Mod and map&quot;)]
-    [Description(&quot;Default game mod&quot;)]
-    [TypeConverter(typeof(ModConverter))]
-    public string DefaultMod
-    {
-      get { return defaultMod; }
-      set { defaultMod = value; }
-    }
+		[Category(&quot;Mod and map&quot;)]
+		[Description(&quot;Default game map&quot;)]
+		[TypeConverter(typeof (MapConverter))]
+		public string DefaultMap
+		{
+			get { return defaultMap; }
+			set { defaultMap = value; }
+		}
 
+		[Category(&quot;Mod and map&quot;)]
+		[Description(&quot;Default game mod&quot;)]
+		[TypeConverter(typeof (ModConverter))]
+		public string DefaultMod
+		{
+			get { return defaultMod; }
+			set { defaultMod = value; }
+		}
 
-    [Category(&quot;Mod and map&quot;)]
-    [Description(&quot;Limit map selection to this list&quot;)]
-    public string[] LimitMaps
-    {
-      get { return limitMaps; }
-      set { limitMaps = value; }
-    }
+		public List&lt;BattleRect&gt; DefaultRectangles = new List&lt;BattleRect&gt;();
 
-    [Category(&quot;Mod and map&quot;)]
-    [Description(&quot;Limit mod selection to this list&quot;)]
-    public string[] LimitMods
-    {
-      get { return limitMods; }
-      set { limitMods = value; }
-    }
+		[Category(&quot;Rights&quot;)]
+		[Description(&quot;Default rights level for non-privileged users when there is a boss in game&quot;)]
+		public int DefaultRightsLevelWithBoss { get; set; }
 
-    [Category(&quot;Mod and map&quot;)]
-    [Description(&quot;Default game map&quot;)]
-    [TypeConverter(typeof(MapConverter))]
-    public string DefaultMap
-    {
-      get { return defaultMap; }
-      set { defaultMap = value; }
-    }
+		[Category(&quot;Default battle settings&quot;)]
+		[Description(&quot;List of units disabled by default&quot;)]
+		public UnitInfo[] DisabledUnits
+		{
+			get { return disabledUnits; }
+			set { disabledUnits = value; }
+		}
 
-    [Category(&quot;Mod and map&quot;)]
-    [Description(&quot;Should springie redirect global game chat to lobby?&quot;)]
-    public bool AutoDownloadNewMaps
-    {
-      get { return autoDownloadNewMaps; }
-      set { autoDownloadNewMaps = value; }
-    }
+		[Category(&quot;Texts&quot;)]
+		[Description(&quot;Should Springie advertise a maplink to new joiners and after map change?&quot;)]
+		public bool DisplayMapLink
+		{
+			get { return displayMapLink; }
+			set { displayMapLink = value; }
+		}
 
+		[Category(&quot;Texts&quot;)]
+		[Description(&quot;Game title - appears in open game list, %1 = springie version&quot;)]
+		public string GameTitle
+		{
+			get { return gameTitle; }
+			set { gameTitle = value; }
+		}
 
-    [Category(&quot;Mod and map&quot;)]
-    [Description(&quot;Optional mapcycle - when game ends, another map is from this list is picked. You don't have to specify exact names here, springie is using filtering capabilities to find entered maps.&quot;)]
-    public string[] MapCycle
-    {
-      get { return mapCycle; }
-      set { mapCycle = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Hosting port number&quot;)]
+		public int HostingPort
+		{
+			get { return hostingPort; }
+			set { hostingPort = value; }
+		}
 
 
-    [Category(&quot;Texts&quot;)]
-    [Description(&quot;Game title - appears in open game list, %1 = springie version&quot;)]
-    public string GameTitle
-    {
-      get { return gameTitle; }
-      set { gameTitle = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Should autohost kick people below min rank?&quot;)]
+		public bool KickMinRank { get; set; }
 
+		[Category(&quot;Default battle settings&quot;)]
+		[Description(&quot;Do you want to automatically kick spectators&quot;)]
+		public bool KickSpectators { get; set; }
 
-    [Category(&quot;Default battle settings&quot;)]
-    [Description(&quot;Do you want to automatically kick spectators&quot;)]
-    public bool KickSpectators
-    {
-      get { return kickSpectators; }
-      set { kickSpectators = value; }
-    }
+		[Category(&quot;Texts&quot;)]
+		[Description(&quot;Message used when kicking spectator&quot;)]
+		public string KickSpectatorText
+		{
+			get { return kickSpectatorText; }
+			set { kickSpectatorText = value; }
+		}
 
-    [Category(&quot;Default battle settings&quot;)]
-    [Description(&quot;Players with CPU speed (in GHz) below this value will be autokicked - 0 no kicking&quot;)]
-    public double MinCpuSpeed
-    {
-      get { return minCpuSpeed; }
-      set { minCpuSpeed = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Should Springie host ladder map? Pick ladder id&quot;)]
+		public int LadderId { get; set; }
 
 
-    [Category(&quot;Default battle settings&quot;)]
-    [Description(&quot;Defines battle details to use by default&quot;)]
-    public BattleDetails BattleDetails
-    {
-      get { return battleDetails; }
-      set { battleDetails = value; }
-    }
+		[Category(&quot;Mod and map&quot;)]
+		[Description(&quot;Limit map selection to this list&quot;)]
+		public string[] LimitMaps { get; set; }
 
-    [Category(&quot;Default battle settings&quot;)]
-    [Description(&quot;List of units disabled by default&quot;)]
-    public UnitInfo[] DisabledUnits
-    {
-      get { return disabledUnits; }
-      set { disabledUnits = value; }
-    }
+		[Category(&quot;Mod and map&quot;)]
+		[Description(&quot;Limit mod selection to this list&quot;)]
+		public string[] LimitMods { get; set; }
 
-    [Category(&quot;Rights&quot;)]
-    [Description(&quot;Default rights level for lobby admins (mod admins)&quot;)]
-    public int DefaulRightsLevelForLobbyAdmins
-    {
-      get { return defaulRightsLevelForLobbyAdmins; }
-      set { defaulRightsLevelForLobbyAdmins = value; }
-    }
 
+		[Category(&quot;Mod and map&quot;)]
+		[Description(&quot;Optional mapcycle - when game ends, another map is from this list is picked. You don't have to specify exact names here, springie is using filtering capabilities to find entered maps.&quot;)]
+		public string[] MapCycle
+		{
+			get { return mapCycle; }
+			set { mapCycle = value; }
+		}
 
-    [Category(&quot;Rights&quot;)]
-    [Description(&quot;Default rights level for non-privileged users&quot;)]
-    public int DefaulRightsLevel
-    {
-      get { return defaulRightsLevel; }
-      set { defaulRightsLevel = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Maximum number of players&quot;)]
+		public int MaxPlayers
+		{
+			get { return maxPlayers; }
+			set { maxPlayers = value; }
+		}
 
-    [Category(&quot;Rights&quot;)]
-    [Description(&quot;Default rights level for non-privileged users when there is a boss in game&quot;)]
-    public int DefaultRightsLevelWithBoss
-    {
-      get { return defaultRightsLevelWithBoss; }
-      set { defaultRightsLevelWithBoss = value; }
-    }
 
+		[Category(&quot;Default battle settings&quot;)]
+		[Description(&quot;Players with CPU speed (in GHz) below this value will be autokicked - 0 no kicking&quot;)]
+		public double MinCpuSpeed { get; set; }
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Minimum number of players for autolocking&quot;)]
-    public int AutoLockMinPlayers
-    {
-      get { return autoLockMinPlayers; }
-      set { autoLockMinPlayers = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Minimum rank to be allowed to join&quot;)]
+		public int MinRank { get; set; }
 
-    [Category(&quot;Texts&quot;)]
-    [Description(&quot;Welcome message - server says this when users joins. %1 = user name, %2 = user rights level, %3 = springie version&quot;)]
-    public string Welcome
-    {
-      get { return welcome; }
-      set { welcome = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Game password&quot;)]
+		public string Password
+		{
+			get { return password; }
+			set { password = value; }
+		}
 
+		public List&lt;PrivilegedUser&gt; PrivilegedUsers = new List&lt;PrivilegedUser&gt;();
 
-    [Category(&quot;Texts&quot;)]
-    [Description(&quot;Message used when kicking spectator&quot;)]
-    public string KickSpectatorText
-    {
-      get { return kickSpectatorText; }
-      set { kickSpectatorText = value; }
-    }
+		[Category(&quot;Basic options&quot;)]
+		[Description(&quot;Should Springie use hole punching NAT traversal method? - Incompatible with gargamel mode&quot;)]
+		public bool UseHolePunching { get; set; }
 
 
-    [Category(&quot;Texts&quot;)]
-    [Description(&quot;Should Springie advertise a maplink to new joiners and after map change?&quot;)]
-    public bool DisplayMapLink
-    {
-      get { return displayMapLink; }
-      set { displayMapLink = value; }
-    }
+		[Category(&quot;Texts&quot;)]
+		[Description(&quot;Welcome message - server says this when users joins. %1 = user name, %2 = user rights level, %3 = springie version&quot;)]
+		public string Welcome
+		{
+			get { return welcome; }
+			set { welcome = value; }
+		}
 
-    [Category(&quot;Basic options&quot;)]
-    [Description(&quot;Should Springie host ladder map? Pick ladder id&quot;)]
-    public int LadderId
-    {
-      get { return ladderId; }
-      set { ladderId = value; }
-    }
+		#endregion
 
+		#region Public methods
 
-    public void SetPrivilegedUser(string name, int level)
-    {
-      for (int i = 0; i &lt; PrivilegedUsers.Count; ++i) {
-        if (PrivilegedUsers[i].Name == name) {
-          if (level == 0) {
-            PrivilegedUsers.RemoveAt(i);
-            return;
-          } else {
-            PrivilegedUsers[i].Level = level;
-            return;
-          }
-        }
-      }
-      if (level &gt; 0) PrivilegedUsers.Add(new PrivilegedUser(name, level));
-    }
+		public void AddMissingCommands()
+		{
+			var addedCommands = new List&lt;CommandConfig&gt;();
 
-    private void AddMissing(CommandConfig command, List&lt;CommandConfig&gt; addedCommands)
-    {
-      foreach (CommandConfig c in Commands) {
-        if (c.Name == command.Name) {
-          addedCommands.Add(c);
-          return;
-        }
-      }
-      Commands.Add(command);
-      addedCommands.Add(command);
-    }
+			AddMissing(new CommandConfig(&quot;help&quot;, 0, &quot; - lists all commands available specifically to you&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;setpwserver&quot;, 0, &quot; &lt;address&gt; - sets PlanetWars server&quot;, 5), addedCommands);
 
-    public void AddMissingCommands()
-    {
-      List&lt;CommandConfig&gt; addedCommands = new List&lt;CommandConfig&gt;();
+			AddMissing(new CommandConfig(&quot;random&quot;, 1, &quot;&lt;allycount&gt; - assigns people to &lt;allycount&gt; random alliances, e.g. !random - makes 2 random alliances&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;help&quot;, 0, &quot; - lists all commands available specifically to you&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;register&quot;, 5, &quot;&lt;side&gt; &lt;password&gt; - registers player for PlanetWars, e.g. !register arm secretPassword&quot;, 1), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;random&quot;, 1, &quot;&lt;allycount&gt; - assigns people to &lt;allycount&gt; random alliances, e.g. !random - makes 2 random alliances&quot;, 10), addedCommands);
+			AddMissing(new CommandConfig(&quot;balance&quot;, 1, &quot;&lt;allycount&gt; - assigns people to &lt;allycount&gt; rank balanced alliances, e.g. !balance - makes 2 random but balanced alliances&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;balance&quot;, 1, &quot;&lt;allycount&gt; - assigns people to &lt;allycount&gt; rank balanced alliances, e.g. !balance - makes 2 random but balanced alliances&quot;, 10), addedCommands);
+			AddMissing(new CommandConfig(&quot;start&quot;, 1, &quot; - starts game&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;start&quot;, 1, &quot; - starts game&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;ring&quot;, 0, &quot;[&lt;filters&gt;..] - rings all unready or specific player(s), e.g. !ring - rings unready, !ring icho - rings Licho&quot;, 5, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;ring&quot;, 0, &quot;[&lt;filters&gt;..] - rings all unready or specific player(s), e.g. !ring - rings unready, !ring icho - rings Licho&quot;, 5, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;listmaps&quot;, 0, &quot;[&lt;filters&gt;..] - lists maps on server, e.g. !listmaps altor div&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;listmaps&quot;, 0, &quot;[&lt;filters&gt;..] - lists maps on server, e.g. !listmaps altor div&quot;, 10), addedCommands);
-      AddMissing(new CommandConfig(&quot;listmods&quot;, 0, &quot;[&lt;filters&gt;..] - lists mods on server, e.g. !listmods absolute 2.23&quot;, 5), addedCommands);
-      AddMissing(new CommandConfig(&quot;map&quot;, 2, &quot;[&lt;filters&gt;..] - changes server map, eg. !map altor div&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;listplanets&quot;, 5, &quot;[&lt;filters&gt;..] - lists planets open for attack !listmaps quantumia&quot;, 1), addedCommands);
+			AddMissing(new CommandConfig(&quot;planet&quot;, 5, &quot;[&lt;filters&gt;..] - picks a planet (you must be commander-in-chief)&quot;, 1), addedCommands);
+			AddMissing(new CommandConfig(&quot;voteplanet&quot;, 5, &quot;[&lt;filters&gt;..] - starts a vote for new planet&quot;, 1), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;manage&quot;, 1, &quot;&lt;minaplayer&gt; [&lt;maxplayers&gt;] - auto manage server for min to max players&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;forcestart&quot;, 2, &quot; - starts game forcibly (ignoring warnings)&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;listmods&quot;, 0, &quot;[&lt;filters&gt;..] - lists mods on server, e.g. !listmods absolute 2.23&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;map&quot;, 2, &quot;[&lt;filters&gt;..] - changes server map, eg. !map altor div&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;say&quot;, 0, &quot;&lt;text&gt; - says something in game&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;manage&quot;, 1, &quot;&lt;minaplayer&gt; [&lt;maxplayers&gt;] - auto manage server for min to max players&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;force&quot;, 2, &quot; - forces game start inside game&quot;, 8, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
-      AddMissing(new CommandConfig(&quot;kick&quot;, 3, &quot;[&lt;filters&gt;..] - kicks a player&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;forcestart&quot;, 2, &quot; - starts game forcibly (ignoring warnings)&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;split&quot;, 1, &quot;&lt;\&quot;h\&quot;/\&quot;v\&quot;&gt; &lt;percent&gt; - draws with given direction and percentual size, e.g. !split h 15&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;say&quot;, 0, &quot;&lt;text&gt; - says something in game&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;corners&quot;, 1, &quot;&lt;\&quot;a\&quot;/\&quot;b\&quot;&gt; &lt;percent&gt; - draws corners (a or b mode differ in ordering), e.g. !corners a 15&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;force&quot;, 2, &quot; - forces game start inside game&quot;, 8, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;kick&quot;, 3, &quot;[&lt;filters&gt;..] - kicks a player&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;exit&quot;, 3, &quot; - exits the game&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;split&quot;, 1, &quot;&lt;\&quot;h\&quot;/\&quot;v\&quot;&gt; &lt;percent&gt; - draws with given direction and percentual size, e.g. !split h 15&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;lock&quot;, 1, &quot; - locks the game&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;corners&quot;, 1, &quot;&lt;\&quot;a\&quot;/\&quot;b\&quot;&gt; &lt;percent&gt; - draws corners (a or b mode differ in ordering), e.g. !corners a 15&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;unlock&quot;, 1, &quot; - unlocks the game&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;exit&quot;, 3, &quot; - exits the game&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;fix&quot;, 1, &quot; - fixes teamnumbers&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;lock&quot;, 1, &quot; - locks the game&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;votemap&quot;, 0, &quot;[&lt;mapname&gt;..] - starts vote for new map, e.g. !votemap altored div&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;unlock&quot;, 1, &quot; - unlocks the game&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;votekick&quot;, 0, &quot;[&lt;mapname&gt;..] - starts vote to kick a player, e.g. !votekick Licho&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;fix&quot;, 1, &quot; - fixes teamnumbers&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;voteforcestart&quot;, 0, &quot; - starts vote to force game to start in lobby&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;votemap&quot;, 0, &quot;[&lt;mapname&gt;..] - starts vote for new map, e.g. !votemap altored div&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;voteforce&quot;, 0, &quot; - starts vote to force game to start from game&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;votekick&quot;, 0, &quot;[&lt;mapname&gt;..] - starts vote to kick a player, e.g. !votekick Licho&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;voteexit&quot;, 0, &quot; - starts vote to exit game&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;voteforcestart&quot;, 0, &quot; - starts vote to force game to start in lobby&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;vote&quot;, 0, &quot;&lt;number&gt; - votes for given option (works from battle only), e.g. !vote 1&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;voteforce&quot;, 0, &quot; - starts vote to force game to start from game&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;rehost&quot;, 3, &quot;[&lt;modname&gt;..] - rehosts game, e.g. !rehost abosol 2.23 - rehosts AA2.23&quot;), addedCommands);
-      AddMissing(new CommandConfig(&quot;voterehost&quot;, 0, &quot;[&lt;modname&gt;..] - votes to rehost game, e.g. !rehost abosol 2.23 - rehosts AA2.23&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;voteexit&quot;, 0, &quot; - starts vote to exit game&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;admins&quot;, 0, &quot; - lists admins&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;vote&quot;, 0, &quot;&lt;number&gt; - votes for given option (works from battle only), e.g. !vote 1&quot;, 0, new[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;setlevel&quot;, 4, &quot;&lt;level&gt; &lt;playername&gt; - set's rights level for player.Setting to 0 deletes players.&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;rehost&quot;, 3, &quot;[&lt;modname&gt;..] - rehosts game, e.g. !rehost abosol 2.23 - rehosts AA2.23&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;voterehost&quot;, 0, &quot;[&lt;modname&gt;..] - votes to rehost game, e.g. !rehost abosol 2.23 - rehosts AA2.23&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;maplink&quot;, 0, &quot;[&lt;mapname&gt;..] - looks for maplinks at unknown-files&quot;, 5, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Normal}), addedCommands);
+			AddMissing(new CommandConfig(&quot;admins&quot;, 0, &quot; - lists admins&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;modlink&quot;, 0, &quot;[&lt;modname&gt;..] - looks for modlinks at unknown-files&quot;, 5, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Normal}), addedCommands);
+			AddMissing(new CommandConfig(&quot;setlevel&quot;, 4, &quot;&lt;level&gt; &lt;playername&gt; - set's rights level for player.Setting to 0 deletes players.&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;dlmap&quot;, 1, &quot;[&lt;mapname/dllid/url&gt;..] - downloads map to server. You can either specify map name or map id (from unknown files) or map URL&quot;, 10), addedCommands);
+			AddMissing(new CommandConfig(&quot;maplink&quot;, 0, &quot;[&lt;mapname&gt;..] - looks for maplinks at unknown-files&quot;, 5, new[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Normal}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;dlmod&quot;, 1, &quot;[&lt;modname/dllid/url&gt;..] - downloads mod to server. You must specify mod file id (from unknown files) or mod URL&quot;, 10), addedCommands);
+			AddMissing(new CommandConfig(&quot;modlink&quot;, 0, &quot;[&lt;modname&gt;..] - looks for modlinks at unknown-files&quot;, 5, new[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Normal}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;reload&quot;, 2, &quot; - reloads mod and map list (can take long time)&quot;, 30), addedCommands);
+			AddMissing(new CommandConfig(&quot;dlmap&quot;, 1, &quot;[&lt;mapname/dllid/url&gt;..] - downloads map to server. You can either specify map name or map id (from unknown files) or map URL&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;team&quot;, 2, &quot;&lt;teamnumber&gt; [&lt;playername&gt;..] - forces given player to a team&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;dlmod&quot;, 1, &quot;[&lt;modname/dllid/url&gt;..] - downloads mod to server. You must specify mod file id (from unknown files) or mod URL&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;ally&quot;, 2, &quot;&lt;allynumber&gt; [&lt;playername&gt;..] - forces given player to an alliance&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;reload&quot;, 2, &quot; - reloads mod and map list (can take long time)&quot;, 30), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;helpall&quot;, 0, &quot;- lists all commands known to Springie (sorted by command level)&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;id&quot;, 2, &quot;&lt;idnumber&gt; [&lt;playername&gt;..] - forces given player to an id&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;fixcolors&quot;, 1, &quot;- changes too similar colors to more different (note that color difference is highly subjective and impossible to model mathematically, so it won't always produce results satisfying for all)&quot;, 10), addedCommands);
+			AddMissing(new CommandConfig(&quot;team&quot;, 2, &quot;&lt;teamnumber&gt; [&lt;playername&gt;..] - forces given player to a team&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;springie&quot;, 0, &quot;- responds with basic springie information&quot;, 5, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Channel}), addedCommands);
+			AddMissing(new CommandConfig(&quot;helpall&quot;, 0, &quot;- lists all commands known to Springie (sorted by command level)&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;endvote&quot;, 2, &quot;- ends current poll&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;fixcolors&quot;, 1, &quot;- changes too similar colors to more different (note that color difference is highly subjective and impossible to model mathematically, so it won't always produce results satisfying for all)&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;addbox&quot;, 1, &quot;&lt;left&gt; &lt;top&gt; &lt;width&gt; &lt;height&gt; [&lt;number&gt;] - adds a new box rectangle&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;springie&quot;, 0, &quot;- responds with basic springie information&quot;, 5, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Channel}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;clearbox&quot;, 1, &quot;[&lt;number&gt;] - removes a box (or removes all boxes if number not specified)&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;endvote&quot;, 2, &quot;- ends current poll&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;listpresets&quot;, 0, &quot;[&lt;presetname&gt;..] - lists all presets this server has (with name filtering)&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;addbox&quot;, 1, &quot;&lt;left&gt; &lt;top&gt; &lt;width&gt; &lt;height&gt; [&lt;number&gt;] - adds a new box rectangle&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;listoptions&quot;, 1, &quot; - lists all mod/map options&quot;, 5), addedCommands);
+			AddMissing(new CommandConfig(&quot;clearbox&quot;, 1, &quot;[&lt;number&gt;] - removes a box (or removes all boxes if number not specified)&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;setoptions&quot;, 1, &quot;&lt;name&gt;=&lt;value&gt;[,&lt;name&gt;=&lt;value&gt;] - applies mod/map options&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;listpresets&quot;, 0, &quot;[&lt;presetname&gt;..] - lists all presets this server has (with name filtering)&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;votesetoptions&quot;, 1, &quot;&lt;name&gt;=&lt;value&gt;[,&lt;name&gt;=&lt;value&gt;] - starts a vote to apply mod/map options&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;listoptions&quot;, 1, &quot; - lists all mod/map options&quot;, 5), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;preset&quot;, 2, &quot;[&lt;presetname&gt;..] - applies given preset to current battle&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;setoptions&quot;, 1, &quot;&lt;name&gt;=&lt;value&gt;[,&lt;name&gt;=&lt;value&gt;] - applies mod/map options&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;votepreset&quot;, 0, &quot;[&lt;presetname&gt;..] - starts a vote to apply given preset&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;votesetoptions&quot;, 1, &quot;&lt;name&gt;=&lt;value&gt;[,&lt;name&gt;=&lt;value&gt;] - starts a vote to apply mod/map options&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;presetdetails&quot;, 0, &quot;[&lt;presetname&gt;..] - shows details of given preset&quot;, 2), addedCommands);
+			AddMissing(new CommandConfig(&quot;preset&quot;, 2, &quot;[&lt;presetname&gt;..] - applies given preset to current battle&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;cbalance&quot;, 1, &quot;[&lt;allycount&gt;] - assigns people to allycount random balanced alliances but attempts to put clanmates to same teams&quot;, 10), addedCommands);
+			AddMissing(new CommandConfig(&quot;votepreset&quot;, 0, &quot;[&lt;presetname&gt;..] - starts a vote to apply given preset&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;ban&quot;, 4, &quot;&lt;username&gt; [&lt;duration&gt;] [&lt;reason&gt;...] - bans user username for duration (in minutes) with given reason. Duration 0 = ban for 1000 years&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;presetdetails&quot;, 0, &quot;[&lt;presetname&gt;..] - shows details of given preset&quot;, 2), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;unban&quot;, 4, &quot;&lt;username&gt; - unbans user&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;cbalance&quot;, 1, &quot;[&lt;allycount&gt;] - assigns people to allycount random balanced alliances but attempts to put clanmates to same teams&quot;, 10), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;listbans&quot;, 0, &quot;- lists currently banned users&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;ban&quot;, 4, &quot;&lt;username&gt; [&lt;duration&gt;] [&lt;reason&gt;...] - bans user username for duration (in minutes) with given reason. Duration 0 = ban for 1000 years&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;smurfs&quot;, 0, &quot;- finds smurfs, use this command to get more help&quot;, 5, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Channel}), addedCommands);
+			AddMissing(new CommandConfig(&quot;unban&quot;, 4, &quot;&lt;username&gt; - unbans user&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;stats&quot;, 0, &quot;- displays statistics, use this command to get more help&quot;, 5, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Channel}), addedCommands);
+			AddMissing(new CommandConfig(&quot;listbans&quot;, 0, &quot;- lists currently banned users&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;kickspec&quot;, 2, &quot;[0|1] - enables or disables automatic spectator kicking&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game, TasSayEventArgs.Places.Normal}), addedCommands);
+			AddMissing(new CommandConfig(&quot;smurfs&quot;, 0, &quot;- finds smurfs, use this command to get more help&quot;, 5, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Channel}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;votekickspec&quot;, 0, &quot;- starts a vote to enables or disable automatic spectator kicking&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;stats&quot;, 0, &quot;- displays statistics, use this command to get more help&quot;, 5, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Channel}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;setpassword&quot;, 4, &quot;&lt;newpassword&gt; - sets server password (needs !rehost to apply)&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;kickspec&quot;, 2, &quot;[0|1] - enables or disables automatic spectator kicking&quot;, 0, new[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game, TasSayEventArgs.Places.Normal}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;setminrank&quot;, 4, &quot;&lt;minrank&gt; - sets server minimum rank (needs !rehost to apply)&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;votekickspec&quot;, 0, &quot;- starts a vote to enables or disable automatic spectator kicking&quot;, 0, new[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;setmaxplayers&quot;, 4, &quot;&lt;maxplayers&gt; - sets server size (needs !rehost to apply)&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;setpassword&quot;, 4, &quot;&lt;newpassword&gt; - sets server password (needs !rehost to apply)&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;setgametitle&quot;, 4, &quot;&lt;new title&gt; - sets server game title (needs !rehost to apply)&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;setminrank&quot;, 4, &quot;&lt;minrank&gt; - sets server minimum rank (needs !rehost to apply)&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;mincpuspeed&quot;, 4, &quot;&lt;GHz&gt; - sets minimum CPU for this host - players with CPU speed below this value are auto-kicked, 0 = no limit&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;setmaxplayers&quot;, 4, &quot;&lt;maxplayers&gt; - sets server size (needs !rehost to apply)&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;boss&quot;, 2, &quot;&lt;name&gt; - sets &lt;name&gt; as a new boss, use without parameter to remove any current boss. If there is a boss on server, other non-admin people have their rights reduced&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;setgametitle&quot;, 4, &quot;&lt;new title&gt; - sets server game title (needs !rehost to apply)&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;voteboss&quot;, 0, &quot;&lt;name&gt; - sets &lt;name&gt; as a new boss, use without parameter to remove any current boss. If there is a boss on server, other non-admin people have their rights reduced&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;mincpuspeed&quot;, 4, &quot;&lt;GHz&gt; - sets minimum CPU for this host - players with CPU speed below this value are auto-kicked, 0 = no limit&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;autolock&quot;, 1, &quot;&lt;players&gt; - sets desired number of players in game. If this number is reached, server will autolock itself, if someone leaves, it will autounlock again. !autolock without parameter disables auto locking&quot;), addedCommands);
+			AddMissing(new CommandConfig(&quot;boss&quot;, 2, &quot;&lt;name&gt; - sets &lt;name&gt; as a new boss, use without parameter to remove any current boss. If there is a boss on server, other non-admin people have their rights reduced&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;spec&quot;, 2, &quot;&lt;username&gt; - forces player to become spectator&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;voteboss&quot;, 0, &quot;&lt;name&gt; - sets &lt;name&gt; as a new boss, use without parameter to remove any current boss. If there is a boss on server, other non-admin people have their rights reduced&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;specafk&quot;, 1, &quot;forces all AFK player to become spectators&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;autolock&quot;, 1, &quot;&lt;players&gt; - sets desired number of players in game. If this number is reached, server will autolock itself, if someone leaves, it will autounlock again. !autolock without parameter disables auto locking&quot;), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;kickminrank&quot;, 4, &quot;[0/1] enables or disables automatic kicking of people based upon their rank&quot;, 0), addedCommands);
+			AddMissing(new CommandConfig(&quot;spec&quot;, 2, &quot;&lt;username&gt; - forces player to become spectator&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;cheats&quot;, 3, &quot;enables/disables .cheats in game&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
+			AddMissing(new CommandConfig(&quot;specafk&quot;, 1, &quot;forces all AFK player to become spectators&quot;, 0), addedCommands);
 
-      AddMissing(new CommandConfig(&quot;notify&quot;, 0, &quot;springie notifies you when game ends&quot;, 0, new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game, TasSayEventArgs.Places.Channel}), addedCommands);
+			AddMissing(new CommandConfig(&quot;kickminrank&quot;, 4, &quot;[0/1] enables or disables automatic kicking of people based upon their rank&quot;, 0), addedCommands);
 
-      Commands.RemoveAll(delegate(CommandConfig c) { return !addedCommands.Contains(c); });
-    }
+			AddMissing(new CommandConfig(&quot;cheats&quot;, 3, &quot;enables/disables .cheats in game&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game}), addedCommands);
 
+			AddMissing(new CommandConfig(&quot;notify&quot;, 0, &quot;springie notifies you when game ends&quot;, 0, new[] {TasSayEventArgs.Places.Normal, TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Game, TasSayEventArgs.Places.Channel}), addedCommands);
 
-    public static int CommandComparer(CommandConfig a, CommandConfig b)
-    {
-      return a.Name.CompareTo(b.Name);
-    }
+			Commands.RemoveAll(delegate(CommandConfig c) { return !addedCommands.Contains(c); });
+		}
 
-    public static int UserComparer(PrivilegedUser a, PrivilegedUser b)
-    {
-      return a.Name.CompareTo(b.Name);
-    }
 
-    public void Defaults()
-    {
-      DefaultRectangles.Add(new BattleRect(0.0, 0.0, 1.0, 0.15));
-      DefaultRectangles.Add(new BattleRect(0.0, 0.85, 1.0, 1.0));
-      AddMissingCommands();
-    }
+		public static int CommandComparer(CommandConfig a, CommandConfig b)
+		{
+			return a.Name.CompareTo(b.Name);
+		}
 
-    #region Nested type: MapConverter
-    public class MapConverter : StringConverter
-    {
-      public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
-      {
-        return true;
-      }
+		public void Defaults()
+		{
+			DefaultRectangles.Add(new BattleRect(0.0, 0.0, 1.0, 0.15));
+			DefaultRectangles.Add(new BattleRect(0.0, 0.85, 1.0, 1.0));
+			AddMissingCommands();
+		}
 
-      public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
-      {
-        List&lt;string&gt; maps = new List&lt;string&gt;();
-        foreach (KeyValuePair&lt;string, MapInfo&gt; p in Program.main.Spring.UnitSync.MapList) maps.Add(p.Value.Name);
-        return new StandardValuesCollection(maps);
-      }
-    } ;
-    #endregion
+		public void SetPrivilegedUser(string name, int level)
+		{
+			for (int i = 0; i &lt; PrivilegedUsers.Count; ++i) {
+				if (PrivilegedUsers[i].Name == name) {
+					if (level == 0) {
+						PrivilegedUsers.RemoveAt(i);
+						return;
+					} else {
+						PrivilegedUsers[i].Level = level;
+						return;
+					}
+				}
+			}
+			if (level &gt; 0) PrivilegedUsers.Add(new PrivilegedUser(name, level));
+		}
 
-    #region Nested type: ModConverter
-    public class ModConverter : StringConverter
-    {
-      public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
-      {
-        return true;
-      }
+		public static int UserComparer(PrivilegedUser a, PrivilegedUser b)
+		{
+			return a.Name.CompareTo(b.Name);
+		}
 
-      public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
-      {
-        List&lt;string&gt; mods = new List&lt;string&gt;();
-        foreach (KeyValuePair&lt;string, ModInfo&gt; p in Program.main.Spring.UnitSync.ModList) mods.Add(p.Value.Name);
-        return new StandardValuesCollection(mods);
-      }
-    } ;
-    #endregion
-  }
+		#endregion
+
+		#region Other methods
+
+		private void AddMissing(CommandConfig command, List&lt;CommandConfig&gt; addedCommands)
+		{
+			foreach (var c in Commands) {
+				if (c.Name == command.Name) {
+					addedCommands.Add(c);
+					return;
+				}
+			}
+			Commands.Add(command);
+			addedCommands.Add(command);
+		}
+
+		#endregion
+
+		#region Nested type: MapConverter
+
+		public class MapConverter : StringConverter
+		{
+			#region Overrides
+
+			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
+			{
+				var maps = new List&lt;string&gt;();
+				foreach (var p in Program.main.Spring.UnitSync.MapList) maps.Add(p.Value.Name);
+				return new StandardValuesCollection(maps);
+			}
+
+			public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
+			{
+				return true;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+
+		#region Nested type: ModConverter
+
+		public class ModConverter : StringConverter
+		{
+			#region Overrides
+
+			public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
+			{
+				var mods = new List&lt;string&gt;();
+				foreach (var p in Program.main.Spring.UnitSync.ModList) mods.Add(p.Value.Name);
+				return new StandardValuesCollection(mods);
+			}
+
+			public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
+			{
+				return true;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/AutoHost_commands.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/AutoHost_commands.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/AutoHost_commands.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.Globalization;
@@ -3,1220 +5,1355 @@
 using System.Text.RegularExpressions;
 using System.Threading;
+using PlanetWarsShared;
+using PlanetWarsShared.Springie;
 using Springie.Client;
 using Springie.SpringNamespace;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public partial class AutoHost
-  {
-    private List&lt;string&gt; toNotify = new List&lt;string&gt;();
+	public partial class AutoHost
+	{
+		#region Fields
 
-    internal static int Filter(string[] source, string[] words, out string[] resultVals, out int[] resultIndexes)
-    {
-      int i;
+		private List&lt;string&gt; toNotify = new List&lt;string&gt;();
 
-      // search by direct index
-      if (words.Length == 1) {
-        if (int.TryParse(words[0], out i)) {
-          if (i &gt;= 0 &amp;&amp; i &lt; source.Length) {
-            resultVals = new string[] {source[i]};
-            resultIndexes = new int[] {i};
-            return 1;
-          }
-        }
+		#endregion
 
-        // search by direct word
-        string glued = Utils.Glue(words);
-        for (i = 0; i &lt; source.Length; ++i) {
-          if (source[i] == glued) {
-            resultVals = new string[] {source[i]};
-            resultIndexes = new int[] {i};
-            return 1;
-          }
-        }
-      }
+		#region Public methods
 
-      List&lt;string&gt; res = new List&lt;string&gt;();
-      List&lt;int&gt; resi = new List&lt;int&gt;();
+		public bool AllReadyAndSynced(out List&lt;string&gt; usname)
+		{
+			usname = new List&lt;string&gt;();
+			foreach (var p in tas.GetBattle().Users) {
+				if (p.IsSpectator) continue;
+				if (p.SyncStatus != SyncStatuses.Synced || !p.IsReady) usname.Add(p.name);
+			}
+			return usname.Count == 0;
+		}
 
-      for (i = 0; i &lt; words.Length; ++i) words[i] = words[i].ToLower();
-      for (i = 0; i &lt; source.Length; ++i) {
-        if (source[i] + &quot;&quot; == &quot;&quot;) continue;
-        string item = source[i];
-        bool isok = true;
-        for (int j = 0; j &lt; words.Length; ++j) {
-          if (!item.ToLower().Contains(words[j])) {
-            isok = false;
-            break;
-          }
-        }
-        if (isok) {
-          res.Add(item);
-          resi.Add(i);
-        }
-      }
+		public bool AllUniqueTeams(out List&lt;string&gt; username)
+		{
+			var teams = new List&lt;int&gt;();
+			username = new List&lt;string&gt;();
+			foreach (var p in tas.GetBattle().Users) {
+				if (p.IsSpectator) continue;
+				if (teams.Contains(p.TeamNumber)) username.Add(p.name);
+				else teams.Add(p.TeamNumber);
+			}
+			return username.Count == 0;
+		}
 
-      resultVals = res.ToArray();
-      resultIndexes = resi.ToArray();
 
-      return res.Count;
-    }
+		public bool BalancedTeams(out int allyno)
+		{
+			var counts = new int[16];
+			allyno = 0;
 
 
-    private static int FilterMaps(string[] words, TasClient tas, Spring spring, Ladder ladder, out string[] vals, out int[] indexes)
-    {
-      string[] temp = new string[spring.UnitSync.MapList.Keys.Count];
-      int cnt = 0;
-      foreach (string s in spring.UnitSync.MapList.Keys) {
-        if (ladder != null) {
-          if (ladder.Maps.Contains(s.ToLower())) temp[cnt++] = s;
-        } else {
-          string[] limit = Program.main.AutoHost.config.LimitMaps;
-          if (limit != null &amp;&amp; limit.Length &gt; 0) {
-            bool allowed = false;
-            for (int i = 0; i &lt; limit.Length; ++i) {
-              if (s.ToLower().Contains(limit[i].ToLower())) {
-                allowed = true;
-                break;
-              }
-            }
-            if (allowed) temp[cnt++] = s;
-          } else temp[cnt++] = s;
-        }
-      }
-      return Filter(temp, words, out vals, out indexes);
-    }
+			foreach (var p in tas.GetBattle().Users) {
+				if (p.IsSpectator) continue;
+				counts[p.AllyNumber]++;
+			}
 
-    public int FilterMaps(string[] words, out string[] vals, out int[] indexes)
-    {
-      return FilterMaps(words, tas, spring, ladder, out vals, out indexes);
-    }
+			int tsize = 0;
+			for (int i = 0; i &lt; counts.Length; ++i) {
+				if (counts[i] != 0) {
+					if (tsize == 0) tsize = counts[i];
+					else if (tsize != counts[i]) {
+						allyno = i;
+						return false;
+					}
+				}
+			}
+			if (ladder != null) {
+				int mint, maxt;
+				ladder.CheckBattleDetails(null, out mint, out maxt);
+				if (tsize &lt; mint || tsize &gt; maxt) {
+					SayBattle(&quot;Ladder only allows team sizes &quot; + mint + &quot; - &quot; + maxt);
+					return false;
+				}
+			}
+			return true;
+		}
 
+		public void BalanceTeams(int teamCount, bool clanwise)
+		{
+			var actUsers = new List&lt;UserBattleStatus&gt;();
+			var ranker = new List&lt;UsRank&gt;();
+			var b = tas.GetBattle();
 
-    internal static int FilterPresets(string[] words, AutoHost autohost, out string[] vals, out int[] indexes)
-    {
-      string[] temp = new string[autohost.presets.Count];
-      int cnt = 0;
-      foreach (Preset p in autohost.presets) temp[cnt++] = p.Name + &quot; --&gt; &quot; + p.Description;
-      return Filter(temp, words, out vals, out indexes);
-    }
+			foreach (var u in b.Users) {
+				if (!u.IsSpectator) {
+					actUsers.Add(u);
+					User p;
+					if (tas.GetExistingUser(u.name, out p)) ranker.Add(new UsRank(ranker.Count, p.rank, GetClan(u.name)));
+					else ranker.Add(new UsRank(ranker.Count, 0, GetClan(u.name))); // cannot find user, assume rank 0
+				}
+			}
 
-    private int FilterPresets(string[] words, out string[] vals, out int[] indexes)
-    {
-      return FilterPresets(words, this, out vals, out indexes);
-    }
+			var rand = new Random();
 
-    internal static int FilterUsers(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
-    {
-      Battle b = tas.GetBattle();
-      string[] temp = new string[b.Users.Count];
-      int i = 0;
-      foreach (UserBattleStatus u in b.Users) temp[i++] = u.name;
-      return Filter(temp, words, out vals, out indexes);
-    }
+			var tempList = new List&lt;UsRank&gt;(ranker);
+			ranker.Clear();
+			while (tempList.Count &gt; 0) {
+				// find max rank value
+				int maxval = int.MinValue;
+				foreach (var u in tempList) if (u.rank &gt; maxval) maxval = u.rank;
 
-    private int FilterUsers(string[] words, out string[] vals, out int[] indexes)
-    {
-      return FilterUsers(words, tas, spring, out vals, out indexes);
-    }
+				var l2 = new List&lt;UsRank&gt;(); // pick pieces with max rank to l2
+				int j = 0;
+				while (j &lt; tempList.Count) {
+					if (tempList[j].rank == maxval) {
+						l2.Add(tempList[j]);
+						tempList.RemoveAt(j);
+						j = 0;
+					}
+					j++;
+				}
 
+				while (l2.Count &gt; 0) {
+					// randomly add pieces from l2 to ranker
+					int ind = rand.Next(l2.Count);
+					ranker.Add(l2[ind]);
+					l2.RemoveAt(ind);
+				}
+			}
 
-    internal static int FilterMods(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
-    {
-      string[] temp = new string[spring.UnitSync.ModList.Keys.Count];
-      int cnt = 0;
-      foreach (string s in spring.UnitSync.ModList.Keys) {
-        string[] limit = Program.main.AutoHost.config.LimitMods;
-        if (limit != null &amp;&amp; limit.Length &gt; 0) {
-          bool allowed = false;
-          for (int i = 0; i &lt; limit.Length; ++i) {
-            if (s.ToLower().Contains(limit[i].ToLower())) {
-              allowed = true;
-              break;
-            }
-          }
-          if (allowed) temp[cnt++] = s;
-        } else temp[cnt++] = s;
-      }
+			if (teamCount &lt; 2 || teamCount &gt; ranker.Count) teamCount = 2;
 
-      return Filter(temp, words, out vals, out indexes);
-    }
+			var teamUsers = new List&lt;UsRank&gt;[teamCount];
+			for (int i = 0; i &lt; teamUsers.Length; ++i) teamUsers[i] = new List&lt;UsRank&gt;();
+			var teamSums = new int[teamCount];
 
-    private int FilterMods(string[] words, out string[] vals, out int[] indexes)
-    {
-      return FilterMods(words, tas, spring, out vals, out indexes);
-    }
+			var teamClans = new List&lt;string&gt;[teamCount];
+			for (int i = 0; i &lt; teamClans.Length; ++i) teamClans[i] = new List&lt;string&gt;();
 
-    private void ComListMaps(TasSayEventArgs e, string[] words)
-    {
-      string[] vals;
-      int[] indexes;
-      if (FilterMaps(words, out vals, out indexes) &gt; 0) {
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-        for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      } else Respond(e, &quot;no such map found&quot;);
-    }
+			if (clanwise) {
+				string clans = &quot;&quot;;
+				// remove clans that have less than 2 members - those are irelevant
+				foreach (var u in ranker) {
+					if (u.clan != &quot;&quot;) {
+						if (ranker.FindAll(delegate(UsRank x) { return x.clan == u.clan; }).Count &lt; 2) u.clan = &quot;&quot;;
+						else clans += u.clan + &quot;, &quot;;
+					}
+				}
+				if (clans != &quot;&quot;) SayBattle(&quot;those clan are being balanced: &quot; + clans);
+			}
 
+			// this cycle performs actual user adding to teams
+			int cnt = 0;
+			while (ranker.Count &gt; 0) {
+				int minsum = int.MaxValue;
+				int minid = 0;
+				for (int i = 0; i &lt; teamCount; ++i) {
+					var l = teamUsers[i];
+					// pick only current &quot;row&quot; and find the one with least sum
+					if (l.Count == cnt/teamCount) {
+						if (teamSums[i] &lt; minsum) {
+							minid = i;
+							minsum = teamSums[i];
+						}
+					}
+				}
 
-    private void ComListMods(TasSayEventArgs e, string[] words)
-    {
-      string[] vals;
-      int[] indexes;
-      if (FilterMods(words, out vals, out indexes) &gt; 0) {
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-        for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      } else Respond(e, &quot;no such mod found&quot;);
-    }
+				int picked_user = 0;
+				if (clanwise) {
+					// clanwise balancing - attempt to pick someone with same clan
+					// selected team already has some clan
+					int rank = ranker[0].rank;
+					var temp = new List&lt;int&gt;();
 
-    private void ComListPresets(TasSayEventArgs e, string[] words)
-    {
-      string[] vals;
-      int[] indexes;
+					// get list of clans assigned to other teams
+					var assignedClans = new List&lt;string&gt;();
+					for (int i = 0; i &lt; teamClans.Length; ++i) if (i != minid) foreach (var clanName in teamClans[i]) assignedClans.Add(clanName);
 
-      if (FilterPresets(words, out vals, out indexes) &gt; 0) {
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-        for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      } else Respond(e, &quot;no such preset found&quot;);
-    }
+					// first try to get some with same clan
+					if (teamClans[minid].Count &gt; 0) {
+						for (int i = 0; i &lt; ranker.Count; ++i) {
+							if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
+							if (ranker[i].clan != &quot;&quot; &amp;&amp; teamClans[minid].Contains(ranker[i].clan)) temp.Add(i);
+						}
+					}
 
+					if (temp.Count == 0) {
+						// we dont have any candidates try to get clanner from unassigned clan
+						for (int i = 0; i &lt; ranker.Count; ++i) {
+							if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
+							if (ranker[i].clan != &quot;&quot; &amp;&amp; !assignedClans.Contains(ranker[i].clan)) temp.Add(i);
+						}
+					}
 
-    private void ComHelp(TasSayEventArgs e, string[] words)
-    {
-      int ulevel = GetUserLevel(e);
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      foreach (CommandConfig c in config.Commands) if (c.Level &lt;= ulevel) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-    }
+					if (temp.Count == 0) {
+						// we still dont have any candidates try to get non-clanner
+						for (int i = 0; i &lt; ranker.Count; ++i) {
+							if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
+							if (ranker[i].clan == &quot;&quot;) temp.Add(i);
+						}
+					}
 
+					// if we have some candidates pick one randomly
+					if (temp.Count &gt; 0) picked_user = temp[rand.Next(temp.Count)];
+					;
+				}
 
-    private void ComHelpAll(TasSayEventArgs e, string[] words)
-    {
-      List&lt;CommandConfig&gt; copy = new List&lt;CommandConfig&gt;(config.Commands);
-      copy.Sort(delegate(CommandConfig a, CommandConfig b)
-                  {
-                    if (a.Level != b.Level) return a.Level.CompareTo(b.Level);
-                    else return a.Name.CompareTo(b.Name);
-                  });
+				var usr = ranker[picked_user];
+				teamUsers[minid].Add(usr);
+				teamSums[minid] += usr.rank;
 
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      foreach (CommandConfig c in copy) tas.Say(TasClient.SayPlace.User, e.UserName, &quot;Level &quot; + c.Level + &quot; --&gt; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-    }
+				if (clanwise &amp;&amp; usr.clan != &quot;&quot;) {
+					// if we work with clans add user's clan to clan list for his team
+					if (!teamClans[minid].Contains(usr.clan)) teamClans[minid].Add(usr.clan);
+				}
 
+				ranker.RemoveAt(picked_user);
 
-    private void ComAdmins(TasSayEventArgs e, string[] words)
-    {
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      foreach (PrivilegedUser u in config.PrivilegedUsers) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; &quot; + u.Name + &quot; (level &quot; + u.Level.ToString() + &quot;)&quot;, false);
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-    }
+				cnt++;
+			}
 
+			// alliances for allinace permutations
+			var allys = new List&lt;int&gt;();
+			for (int i = 0; i &lt; teamCount; ++i) allys.Add(i);
 
-    private void ComMap(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Respond(e, &quot;You must specify a map name&quot;);
-        return;
-      }
-      string[] vals;
-      int[] indexes;
-      if (FilterMaps(words, out vals, out indexes) &gt; 0) {
-        SayBattle(&quot;changing map to &quot; + vals[0]);
-        tas.ChangeMap(spring.UnitSync.MapList[vals[0]]);
-      } else Respond(e, &quot;Cannot find such map.&quot;);
-    }
+			for (int i = 0; i &lt; teamCount; ++i) {
+				// permute one alliance
+				int rdindex = rand.Next(allys.Count);
+				int allynum = allys[rdindex];
+				allys.RemoveAt(rdindex);
 
+				foreach (var u in teamUsers[i]) tas.ForceAlly(actUsers[u.id].name, allynum);
+			}
 
-    public bool AllReadyAndSynced(out string usname)
-    {
-      usname = &quot;&quot;;
-      int cnt = 0;
-      foreach (UserBattleStatus p in tas.GetBattle().Users) {
-        if (p.IsSpectator) continue;
-        else cnt++;
-        if (p.SyncStatus != SyncStatuses.Synced || !p.IsReady) {
-          usname = p.name;
-          return false;
-        }
-      }
-      if (cnt == 0) return false;
-      else return true;
-    }
+			string t = string.Format(&quot;{0} players balanced to {1} teams (ranks &quot;, actUsers.Count, teamCount);
+			for (int i = 0; i &lt; teamSums.Length; ++i) {
+				if (i &gt; 0) t += &quot;:&quot;;
+				t += teamSums[i].ToString();
+			}
+			t += &quot;)&quot;;
+			if (clanwise) t += &quot; respecting clans&quot;;
+			SayBattle(t);
+		}
 
-    public bool AllUniqueTeams(out string username)
-    {
-      List&lt;int&gt; teams = new List&lt;int&gt;();
-      username = &quot;&quot;;
-      foreach (UserBattleStatus p in tas.GetBattle().Users) {
-        if (p.IsSpectator) continue;
-        if (teams.Contains(p.TeamNumber)) {
-          username = p.name;
-          return false;
-        } else teams.Add(p.TeamNumber);
-      }
-      return true;
-    }
 
-    public bool BalancedTeams(out int allyno)
-    {
-      int[] counts = new int[16];
-      allyno = 0;
+		public void ComAddBox(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length &lt; 4) {
+				Respond(e, &quot;This command needs at least 4 parameters&quot;);
+				return;
+			}
+			int x, y, w, h;
+			if (!int.TryParse(words[0], out x) || !int.TryParse(words[1], out y) || !int.TryParse(words[2], out w) || !int.TryParse(words[3], out h)) {
+				Respond(e, &quot;All parameters must be numbers&quot;);
+				return;
+			}
+			int numrect = 0;
+			if (words.Length &gt; 4) int.TryParse(words[4], out numrect);
 
-      foreach (UserBattleStatus p in tas.GetBattle().Users) {
-        if (p.IsSpectator) continue;
-        counts[p.AllyNumber]++;
-      }
+			if (numrect == 0) {
+				numrect = tas.GetBattle().GetFirstEmptyRectangle();
+				if (numrect == -1) {
+					Respond(e, &quot;Cannot add more boxes&quot;);
+					return;
+				}
+				numrect++;
+			}
+			tas.AddBattleRectangle(numrect - 1, new BattleRect(x*2, y*2, (x + w)*2, (y + h)*2));
+		}
 
-      int tsize = 0;
-      for (int i = 0; i &lt; counts.Length; ++i) {
-        if (counts[i] != 0) {
-          if (tsize == 0) tsize = counts[i];
-          else if (tsize != counts[i]) {
-            allyno = i;
-            return false;
-          }
-        }
-      }
-      if (ladder != null) {
-        int mint, maxt;
-        ladder.CheckBattleDetails(null, out mint, out maxt);
-        if (tsize &lt; mint || tsize &gt; maxt) {
-          SayBattle(&quot;Ladder only allows team sizes &quot; + mint + &quot; - &quot; + maxt);
-          return false;
-        }
-      }
-      return true;
-    }
+		public void ComAlly(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length &lt; 2) {
+				Respond(e, &quot;this command needs 2 parameters (ally number and player name)&quot;);
+				return;
+			}
+			int allyno = 0;
+			if (!int.TryParse(words[0], out allyno) || --allyno &lt; 0 || allyno &gt;= Spring.MaxAllies) {
+				Respond(e, &quot;invalid ally number&quot;);
+				return;
+			}
+			string[] usrs;
+			int[] idx;
+			if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
+			else {
+				SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to alliance &quot; + (allyno + 1));
+				tas.ForceAlly(usrs[0], allyno);
+			}
+		}
 
-    public void ComStart(TasSayEventArgs e, string[] words)
-    {
-      string usname;
-      if (!AllReadyAndSynced(out usname)) {
-        SayBattle(&quot;cannot start, &quot; + usname + &quot; not ready and synced&quot;);
-        return;
-      }
+		public void ComAutoLock(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				autoLock = 0;
+				Respond(e, &quot;AutoLocking disabled&quot;);
+				return;
+			}
+			int num = 0;
+			int.TryParse(words[0], out num);
+			int maxp = tas.GetBattle().MaxPlayers;
+			if (num &lt; config.AutoLockMinPlayers || num &gt; maxp) {
+				autoLock = 0;
+				Respond(e, &quot;number of players must be between &quot; + config.AutoLockMinPlayers + &quot; and &quot; + maxp + &quot;, AutoLocking disabled&quot;);
+				return;
+			}
+			autoLock = num;
+			HandleAutoLocking();
+			Respond(e, &quot;AutoLock set to &quot; + autoLock + &quot; players&quot;);
+		}
 
-      if (!AllUniqueTeams(out usname)) {
-        SayBattle(&quot;cannot start, &quot; + usname + &quot; is sharing teams. Use !forcestart to override&quot;);
-        return;
-      }
+		public void ComBalance(TasSayEventArgs e, string[] words)
+		{
+			int teamCount = 2;
+			if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
+			else teamCount = 2;
+			ComFix(e, words);
+			BalanceTeams(teamCount, false);
+		}
 
-      int allyno;
-      if (!BalancedTeams(out allyno)) {
-        SayBattle(&quot;cannot start, alliance &quot; + (allyno + 1).ToString() + &quot; not fair. Use !forcestart to override&quot;);
-        return;
-      }
-      SayBattle(&quot;please wait, game is about to start&quot;);
+		public void ComBoss(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				if (bossName == &quot;&quot;) {
+					Respond(e, &quot;there is currently no active boss&quot;);
+					return;
+				}
+				SayBattle(&quot;boss &quot; + bossName + &quot; removed&quot;);
+				bossName = &quot;&quot;;
+				return;
+			} else {
+				string[] usrs;
+				int[] idx;
+				if (FilterUsers(words, out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
+				else {
+					SayBattle(&quot;New boss is &quot; + usrs[0]);
+					bossName = usrs[0];
+				}
+			}
+		}
 
-      StopVote();
+		public void ComCBalance(TasSayEventArgs e, string[] words)
+		{
+			int teamCount = 2;
+			if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
+			else teamCount = 2;
+			ComFix(e, words);
+			BalanceTeams(teamCount, true);
+		}
 
-      Battle b = tas.GetBattle();
-      if (b != null) {
-        string curMap = b.Map.ArchiveName.ToLower();
+		public void ComClearBox(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) foreach (var i in tas.GetBattle().Rectangles.Keys) tas.RemoveBattleRectangle(i);
+			else {
+				int numrect = 0;
+				if (!int.TryParse(words[0], out numrect)) Respond(e, &quot;paramater must by a number of rectangle&quot;);
+				tas.RemoveBattleRectangle(numrect - 1);
+			}
+		}
 
-        Dictionary&lt;int, BattleRect&gt; nd = new Dictionary&lt;int, BattleRect&gt;();
-        foreach (KeyValuePair&lt;int, BattleRect&gt; v in b.Rectangles) nd.Add(v.Key, v.Value);
+		public void ComCorners(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length != 2) {
+				Respond(e, &quot;This command needs 2 parameters&quot;);
+				return;
+			}
+			if (words[0] != &quot;a&quot; &amp;&amp; words[0] != &quot;b&quot;) Respond(e, &quot;first parameter must be 'a' or 'b'&quot;);
+			else {
+				int perc;
+				int.TryParse(words[1], out perc);
+				if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
+				else {
+					double p = perc/100.0;
+					if (words[0] == &quot;a&quot;) {
+						tas.AddBattleRectangle(0, new BattleRect(0, 0, p, p));
+						tas.AddBattleRectangle(1, new BattleRect(1 - p, 1 - p, 1, 1));
+						tas.AddBattleRectangle(2, new BattleRect(1 - p, 0, 1, p));
+						tas.AddBattleRectangle(3, new BattleRect(0, 1 - p, p, 1));
+					} else {
+						tas.AddBattleRectangle(0, new BattleRect(1 - p, 0, 1, p));
+						tas.AddBattleRectangle(1, new BattleRect(0, 1 - p, p, 1));
+						tas.AddBattleRectangle(2, new BattleRect(0, 0, p, p));
+						tas.AddBattleRectangle(3, new BattleRect(1 - p, 1 - p, 1, 1));
+					}
+				}
+			}
+		}
 
-        if (MapBoxes.ContainsKey(curMap)) MapBoxes[curMap] = nd;
-        else MapBoxes.Add(curMap, nd);
-        SaveConfig();
-      }
-      tas.ChangeLock(true);
-      tas.StartGame();
-    }
+		public void ComDlMap(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Respond(e, &quot;This command needs 1 parameter (map name)&quot;);
+				return;
+			}
+			string str = Utils.Glue(words);
+			string dump;
+			int dumpi;
+			string res = str;
 
-    public void ComForceStart(TasSayEventArgs e, string[] words)
-    {
-      /*string usname;
-      if (!AllReadyAndSynced(out usname)) {
-        SayBattle(&quot;cannot start, &quot; + usname + &quot; not ready and synced&quot;);
-        return;
-      }*/
-      SayBattle(&quot;please wait, game is about to start&quot;);
+			if (!int.TryParse(str, out dumpi) &amp;&amp; !FileDownloader.IsFileUrl(str, out dump)) {
+				res = &quot;&quot;;
+				try {
+					dump = linker.GetResults(str, UnknownFilesLinker.FileType.Map);
+					res = Regex.Match(dump, &quot;file/([0-9]*)&quot;).Groups[1].Value;
+				} catch {}
+			}
 
-      StopVote();
-      tas.ChangeLock(true);
-      tas.StartGame();
-    }
+			if (res != &quot;&quot;) {
+				Respond(e, &quot;Starting map download&quot;);
+				fileDownloader.DownloadMap(res);
+			} else Respond(e, &quot;I cannot find such map&quot;);
+		}
 
-    public void ComForce(TasSayEventArgs e, string[] words)
-    {
-      if (spring.IsRunning) {
-        SayBattle(&quot;forcing game start by &quot; + e.UserName);
-        spring.ForceStart();
-      } else Respond(e, &quot;cannot force, game not started&quot;);
-    }
 
-    public void ComSplit(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length != 2) {
-        Respond(e, &quot;This command needs 2 parameters&quot;);
-        return;
-      }
-      if (words[0] != &quot;h&quot; &amp;&amp; words[0] != &quot;v&quot;) Respond(e, &quot;first parameter must be 'h' or 'v'&quot;);
-      else {
-        int perc;
-        int.TryParse(words[1], out perc);
-        if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
-        else {
-          if (words[0] == &quot;h&quot;) {
-            tas.AddBattleRectangle(0, new BattleRect(0, 0, 1.0, perc/100.0));
-            tas.AddBattleRectangle(1, new BattleRect(0, 1.0 - perc/100.0, 1.0, 1.0));
-          } else {
-            tas.AddBattleRectangle(0, new BattleRect(0, 0, perc/100.0, 1.0));
-            tas.AddBattleRectangle(1, new BattleRect(1.0 - perc/100.0, 0, 1.0, 1.0));
-          }
-          tas.RemoveBattleRectangle(2);
-          tas.RemoveBattleRectangle(3);
-        }
-      }
-    }
+		public void ComDlMod(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Respond(e, &quot;This command needs 1 parameter (mod name or id)&quot;);
+				return;
+			}
+			string str = Utils.Glue(words);
+			string dump;
+			int dumpi;
+			string res = str;
 
+			if (!int.TryParse(str, out dumpi) &amp;&amp; !FileDownloader.IsFileUrl(str, out dump)) {
+				res = &quot;&quot;;
+				try {
+					dump = linker.GetResults(str, UnknownFilesLinker.FileType.Mod);
+					res = Regex.Match(dump, &quot;file/([0-9]*)&quot;).Groups[1].Value;
+				} catch {}
+			}
 
-    public void ComCorners(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length != 2) {
-        Respond(e, &quot;This command needs 2 parameters&quot;);
-        return;
-      }
-      if (words[0] != &quot;a&quot; &amp;&amp; words[0] != &quot;b&quot;) Respond(e, &quot;first parameter must be 'a' or 'b'&quot;);
-      else {
-        int perc;
-        int.TryParse(words[1], out perc);
-        if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
-        else {
-          double p = perc/100.0;
-          if (words[0] == &quot;a&quot;) {
-            tas.AddBattleRectangle(0, new BattleRect(0, 0, p, p));
-            tas.AddBattleRectangle(1, new BattleRect(1 - p, 1 - p, 1, 1));
-            tas.AddBattleRectangle(2, new BattleRect(1 - p, 0, 1, p));
-            tas.AddBattleRectangle(3, new BattleRect(0, 1 - p, p, 1));
-          } else {
-            tas.AddBattleRectangle(0, new BattleRect(1 - p, 0, 1, p));
-            tas.AddBattleRectangle(1, new BattleRect(0, 1 - p, p, 1));
-            tas.AddBattleRectangle(2, new BattleRect(0, 0, p, p));
-            tas.AddBattleRectangle(3, new BattleRect(1 - p, 1 - p, 1, 1));
-          }
-        }
-      }
-    }
+			if (res != &quot;&quot;) {
+				Respond(e, &quot;Starting mod download&quot;);
+				fileDownloader.DownloadMod(res);
+			} else Respond(e, &quot;I cannot find such mod&quot;);
+		}
 
 
-    public void ComAddBox(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length &lt; 4) {
-        Respond(e, &quot;This command needs at least 4 parameters&quot;);
-        return;
-      }
-      int x, y, w, h;
-      if (!int.TryParse(words[0], out x) || !int.TryParse(words[1], out y) || !int.TryParse(words[2], out w) || !int.TryParse(words[3], out h)) {
-        Respond(e, &quot;All parameters must be numbers&quot;);
-        return;
-      }
-      int numrect = 0;
-      if (words.Length &gt; 4) int.TryParse(words[4], out numrect);
+		public void ComExit(TasSayEventArgs e, string[] words)
+		{
+			if (spring.IsRunning) SayBattle(&quot;exiting game&quot;);
+			else Respond(e, &quot;cannot exit, not in game&quot;);
+			spring.ExitGame();
+		}
 
-      if (numrect == 0) {
-        numrect = tas.GetBattle().GetFirstEmptyRectangle();
-        if (numrect == -1) {
-          Respond(e, &quot;Cannot add more boxes&quot;);
-          return;
-        }
-        numrect++;
-      }
-      tas.AddBattleRectangle(numrect - 1, new BattleRect(x*2, y*2, (x + w)*2, (y + h)*2));
-    }
 
-    public void ComClearBox(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) foreach (int i in tas.GetBattle().Rectangles.Keys) tas.RemoveBattleRectangle(i);
-      else {
-        int numrect = 0;
-        if (!int.TryParse(words[0], out numrect)) Respond(e, &quot;paramater must by a number of rectangle&quot;);
-        tas.RemoveBattleRectangle(numrect - 1);
-      }
-    }
+		public void ComFix(TasSayEventArgs e, string[] words)
+		{
+			var b = tas.GetBattle();
+			int cnt = 0;
+			foreach (var u in b.Users) {
+				if (!u.IsSpectator) {
+					tas.ForceTeam(u.name, cnt);
+					cnt++;
+				}
+			}
+			SayBattle(&quot;team numbers fixed&quot;);
+		}
 
-    public void ComRing(TasSayEventArgs e, string[] words)
-    {
-      List&lt;string&gt; usrlist = new List&lt;string&gt;();
 
-      if (words.Length == 0) {
-        // ringing idle
-        foreach (UserBattleStatus p in tas.GetBattle().Users) {
-          if (p.IsSpectator) continue;
-          if (!p.IsReady) usrlist.Add(p.name);
-        }
-      } else {
-        string[] vals;
-        int[] indexes;
-        FilterUsers(words, out vals, out indexes);
-        usrlist = new List&lt;string&gt;(vals);
-      }
+		public void ComFixColors(TasSayEventArgs e, string[] words)
+		{
+			var cols = new List&lt;MyCol&gt;();
+			var b = tas.GetBattle();
 
-      string rang = &quot;&quot;;
-      foreach (string s in usrlist) {
-        tas.Ring(s);
-        rang += s + &quot;, &quot;;
-      }
+			foreach (var u in b.Users) if (!u.IsSpectator) cols.Add((MyCol) u.TeamColor);
+			var arcols = cols.ToArray();
 
-      if (words.Length == 0 &amp;&amp; usrlist.Count &gt; 7) SayBattle(&quot;ringing all unready&quot;);
-      else SayBattle(&quot;ringing &quot; + rang);
-    }
+			MyCol.FixColors(arcols, 30000);
 
+			bool changed = false;
+			int cnt = 0;
+			foreach (var u in b.Users) {
+				if (!u.IsSpectator) {
+					if (u.TeamColor != (int) arcols[cnt]) {
+						tas.ForceColor(u.name, (int) arcols[cnt]);
+						changed = true;
+					}
+					cnt++;
+				}
+			}
+			if (changed) SayBattle(&quot;colors fixed&quot;);
+		}
 
-    public void ComKick(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Respond(e, &quot;You must specify player name&quot;);
-        return;
-      }
+		public void ComForce(TasSayEventArgs e, string[] words)
+		{
+			if (spring.IsRunning) {
+				SayBattle(&quot;forcing game start by &quot; + e.UserName);
+				spring.ForceStart();
+			} else Respond(e, &quot;cannot force, game not started&quot;);
+		}
 
-      int[] indexes;
-      string[] usrlist;
-      if (FilterUsers(words, out usrlist, out indexes) == 0) {
-        Respond(e, &quot;Cannot find such player&quot;);
-        return;
-      }
+		public void ComForceSpectator(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Respond(e, &quot;You must specify player name&quot;);
+				return;
+			}
 
-      if (usrlist[0] == tas.UserName) {
-        Respond(e, &quot;won't kick myself, not in suicidal mood today&quot;);
-        return;
-      }
+			int[] indexes;
+			string[] usrlist;
+			if (FilterUsers(words, out usrlist, out indexes) == 0) {
+				Respond(e, &quot;Cannot find such player&quot;);
+				return;
+			}
 
-      if (spring.IsRunning) spring.Kick(usrlist[0]);
-      tas.Kick(usrlist[0]);
-    }
+			tas.ForceSpectator(usrlist[0]);
+			Respond(e, &quot;Forcing &quot; + usrlist[0] + &quot; to spectator&quot;);
+		}
 
+		public void ComForceSpectatorAfk(TasSayEventArgs e, string[] words)
+		{
+			var b = tas.GetBattle();
+			if (b != null) {
+				foreach (var u in b.Users) {
+					User u2;
+					if (u.name != tas.UserName &amp;&amp; !u.IsSpectator &amp;&amp; !u.IsReady &amp;&amp; tas.GetExistingUser(u.name, out u2)) if (u2.isAway) ComForceSpectator(e, new[] {u.name});
+				}
+			}
+		}
 
-    public void ComForceSpectator(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Respond(e, &quot;You must specify player name&quot;);
+		public void ComForceStart(TasSayEventArgs e, string[] words)
+		{
+			/*string usname;
+      if (!AllReadyAndSynced(out usname)) {
+        SayBattle(&quot;cannot start, &quot; + usname + &quot; not ready and synced&quot;);
         return;
-      }
+      }*/
+			if (CheckAndSendPlanetWarsStart(e)) {
+				SayBattle(&quot;please wait, game is about to start&quot;);
 
-      int[] indexes;
-      string[] usrlist;
-      if (FilterUsers(words, out usrlist, out indexes) == 0) {
-        Respond(e, &quot;Cannot find such player&quot;);
-        return;
-      }
+				StopVote();
+				tas.ChangeLock(true);
+				tas.StartGame();
+			}
+		}
 
-      tas.ForceSpectator(usrlist[0]);
-      Respond(e, &quot;Forcing &quot; + usrlist[0] + &quot; to spectator&quot;);
-    }
+		public void ComKick(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Respond(e, &quot;You must specify player name&quot;);
+				return;
+			}
 
+			int[] indexes;
+			string[] usrlist;
+			if (FilterUsers(words, out usrlist, out indexes) == 0) {
+				Respond(e, &quot;Cannot find such player&quot;);
+				return;
+			}
 
-    public void ComExit(TasSayEventArgs e, string[] words)
-    {
-      if (spring.IsRunning) SayBattle(&quot;exiting game&quot;);
-      else Respond(e, &quot;cannot exit, not in game&quot;);
-      spring.ExitGame();
-    }
+			if (usrlist[0] == tas.UserName) {
+				Respond(e, &quot;won't kick myself, not in suicidal mood today&quot;);
+				return;
+			}
 
+			if (spring.IsRunning) spring.Kick(usrlist[0]);
+			tas.Kick(usrlist[0]);
+		}
 
-    public void ComFix(TasSayEventArgs e, string[] words)
-    {
-      Battle b = tas.GetBattle();
-      int cnt = 0;
-      foreach (UserBattleStatus u in b.Users) {
-        if (!u.IsSpectator) {
-          tas.ForceTeam(u.name, cnt);
-          cnt++;
-        }
-      }
-      SayBattle(&quot;team numbers fixed&quot;);
-    }
+		public void ComKickMinRank(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickMinRank = (words[0] == &quot;1&quot;);
+			else kickMinRank = !kickMinRank;
 
+			if (kickMinRank) SayBattle(&quot;automatic minrank kicking is now ENABLED&quot;);
+			else SayBattle(&quot;automatic minrank kicking is now DISABLED&quot;);
 
-    public void ComFixColors(TasSayEventArgs e, string[] words)
-    {
-      List&lt;MyCol&gt; cols = new List&lt;MyCol&gt;();
-      Battle b = tas.GetBattle();
+			HandleMinRankKicking();
+		}
 
-      foreach (UserBattleStatus u in b.Users) if (!u.IsSpectator) cols.Add((MyCol)u.TeamColor);
-      MyCol[] arcols = cols.ToArray();
+		public void ComKickSpec(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickSpectators = (words[0] == &quot;1&quot;);
+			else kickSpectators = !kickSpectators;
 
-      MyCol.FixColors(arcols, 30000);
+			if (kickSpectators) SayBattle(&quot;automatic spectator kicking is now ENABLED&quot;);
+			else SayBattle(&quot;automatic spectator kicking is now DISABLED&quot;);
 
-      bool changed = false;
-      int cnt = 0;
-      foreach (UserBattleStatus u in b.Users) {
-        if (!u.IsSpectator) {
-          if (u.TeamColor != (int)arcols[cnt]) {
-            tas.ForceColor(u.name, (int)arcols[cnt]);
-            changed = true;
-          }
-          cnt++;
-        }
-      }
-      if (changed) SayBattle(&quot;colors fixed&quot;);
-    }
+			if (kickSpectators) {
+				SayBattle(config.KickSpectatorText);
+				var b = tas.GetBattle();
+				if (b != null) foreach (var u in b.Users) if (u.name != tas.UserName &amp;&amp; u.IsSpectator) ComKick(e, new[] {u.name});
+			}
+		}
 
+		public void ComManage(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length &lt; 1) {
+				Respond(e, &quot;this command needs 1 parameters (minimum number of players to manage for)&quot;);
+				return;
+			}
+			int min = 0;
+			int.TryParse(words[0], out min);
+			int max = min;
+			if (words.Length &gt; 1) int.TryParse(words[1], out max);
+			if (min == 0) Respond(e, &quot;managing disabled&quot;);
+			else Respond(e, &quot;auto managing for &quot; + min + &quot; to &quot; + max + &quot; players&quot;);
+			manager.Manage(min, max);
+		}
 
-    public void ComRehost(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) Start(null, null);
-      else {
-        string[] mods;
-        int[] indexes;
-        if (FilterMods(words, out mods, out indexes) == 0) Respond(e, &quot;cannot find such mod&quot;);
-        else Start(mods[0], null);
-      }
-    }
+		public void ComPreset(TasSayEventArgs e, string[] words)
+		{
+			string[] vals;
+			int[] indexes;
+			if (FilterPresets(words, out vals, out indexes) &gt; 0) {
+				var p = presets[indexes[0]];
+				Respond(e, &quot;applying preset &quot; + p.Name + &quot; (&quot; + p.Description + &quot;)&quot;);
+				p.Apply(tas, ladder);
+			} else Respond(e, &quot;no such preset found&quot;);
+		}
 
-    public void ComRandom(TasSayEventArgs e, string[] words)
-    {
-      ComFix(e, words);
-      Battle b = tas.GetBattle();
+		public void ComPresetDetails(TasSayEventArgs e, string[] words)
+		{
+			string[] vals;
+			int[] indexes;
+			if (FilterPresets(words, out vals, out indexes) &gt; 0) {
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+				foreach (var line in presets[indexes[0]].ToString().Split(new[] {'\n'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			} else Respond(e, &quot;no such preset found&quot;);
+		}
 
-      List&lt;UserBattleStatus&gt; actUsers = new List&lt;UserBattleStatus&gt;();
-      foreach (UserBattleStatus u in b.Users) if (!u.IsSpectator) actUsers.Add(u);
 
-      int teamCount = 0;
-      if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
-      else teamCount = 2;
-      if (teamCount &lt; 2) teamCount = 2;
-      if (teamCount &gt; actUsers.Count) teamCount = 2;
-      Random r = new Random();
+		public void ComRandom(TasSayEventArgs e, string[] words)
+		{
+			ComFix(e, words);
+			var b = tas.GetBattle();
 
-      int al = 0;
-      while (actUsers.Count &gt; 0) {
-        int index = r.Next(actUsers.Count);
-        tas.ForceAlly(actUsers[index].name, al);
-        actUsers.RemoveAt(index);
-        al++;
-        al = al%teamCount;
-      }
-      SayBattle(&quot;players assigned to &quot; + teamCount + &quot; random teams&quot;);
-    }
+			var actUsers = new List&lt;UserBattleStatus&gt;();
+			foreach (var u in b.Users) if (!u.IsSpectator) actUsers.Add(u);
 
+			int teamCount = 0;
+			if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
+			else teamCount = 2;
+			if (teamCount &lt; 2) teamCount = 2;
+			if (teamCount &gt; actUsers.Count) teamCount = 2;
+			var r = new Random();
 
-    // user and rank info
+			int al = 0;
+			while (actUsers.Count &gt; 0) {
+				int index = r.Next(actUsers.Count);
+				tas.ForceAlly(actUsers[index].name, al);
+				actUsers.RemoveAt(index);
+				al++;
+				al = al%teamCount;
+			}
+			SayBattle(&quot;players assigned to &quot; + teamCount + &quot; random teams&quot;);
+		}
 
+		public void ComRehost(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) Start(null, null);
+			else {
+				string[] mods;
+				int[] indexes;
+				if (FilterMods(words, out mods, out indexes) == 0) Respond(e, &quot;cannot find such mod&quot;);
+				else Start(mods[0], null);
+			}
+		}
 
-    private static string GetClan(string name)
-    {
-      foreach (Match m in Regex.Matches(name, &quot;\\[([^\\]]+)\\]&quot;)) return m.Groups[1].Value;
-      return &quot;&quot;;
-    }
+		public void ComRing(TasSayEventArgs e, string[] words)
+		{
+			var usrlist = new List&lt;string&gt;();
 
-    public void BalanceTeams(int teamCount, bool clanwise)
-    {
-      List&lt;UserBattleStatus&gt; actUsers = new List&lt;UserBattleStatus&gt;();
-      List&lt;UsRank&gt; ranker = new List&lt;UsRank&gt;();
-      Battle b = tas.GetBattle();
+			if (words.Length == 0) {
+				// ringing idle
+				foreach (var p in tas.GetBattle().Users) {
+					if (p.IsSpectator) continue;
+					if (!p.IsReady) usrlist.Add(p.name);
+				}
+			} else {
+				string[] vals;
+				int[] indexes;
+				FilterUsers(words, out vals, out indexes);
+				usrlist = new List&lt;string&gt;(vals);
+			}
 
-      foreach (UserBattleStatus u in b.Users) {
-        if (!u.IsSpectator) {
-          actUsers.Add(u);
-          User p;
-          if (tas.GetExistingUser(u.name, out p)) ranker.Add(new UsRank(ranker.Count, p.rank, GetClan(u.name)));
-          else ranker.Add(new UsRank(ranker.Count, 0, GetClan(u.name))); // cannot find user, assume rank 0
-        }
-      }
+			string rang = &quot;&quot;;
+			foreach (var s in usrlist) {
+				tas.Ring(s);
+				rang += s + &quot;, &quot;;
+			}
 
-      Random rand = new Random();
+			if (words.Length == 0 &amp;&amp; usrlist.Count &gt; 7) SayBattle(&quot;ringing all unready&quot;);
+			else SayBattle(&quot;ringing &quot; + rang);
+		}
 
-      List&lt;UsRank&gt; tempList = new List&lt;UsRank&gt;(ranker);
-      ranker.Clear();
-      while (tempList.Count &gt; 0) {
-        // find max rank value
-        int maxval = int.MinValue;
-        foreach (UsRank u in tempList) if (u.rank &gt; maxval) maxval = u.rank;
 
-        List&lt;UsRank&gt; l2 = new List&lt;UsRank&gt;(); // pick pieces with max rank to l2
-        int j = 0;
-        while (j &lt; tempList.Count) {
-          if (tempList[j].rank == maxval) {
-            l2.Add(tempList[j]);
-            tempList.RemoveAt(j);
-            j = 0;
-          }
-          j++;
-        }
+		// user and rank info
 
-        while (l2.Count &gt; 0) {
-          // randomly add pieces from l2 to ranker
-          int ind = rand.Next(l2.Count);
-          ranker.Add(l2[ind]);
-          l2.RemoveAt(ind);
-        }
-      }
 
-      if (teamCount &lt; 2 || teamCount &gt; ranker.Count) teamCount = 2;
+		public void ComSay(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Respond(e, &quot;This command needs 1 parameter (say text)&quot;);
+				return;
+			}
+			SayBattle(&quot;[&quot; + e.UserName + &quot;]&quot; + Utils.Glue(words));
+		}
 
-      List&lt;UsRank&gt;[] teamUsers = new List&lt;UsRank&gt;[teamCount];
-      for (int i = 0; i &lt; teamUsers.Length; ++i) teamUsers[i] = new List&lt;UsRank&gt;();
-      int[] teamSums = new int[teamCount];
+		public void ComSetLevel(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length != 2) {
+				Respond(e, &quot;This command needs 2 parameters&quot;);
+				return;
+			}
+			int lvl;
+			int.TryParse(words[0], out lvl);
+			config.SetPrivilegedUser(words[1], lvl);
+			SaveConfig();
+			Respond(e, words[1] + &quot; has rights level &quot; + lvl);
+		}
 
-      List&lt;string&gt;[] teamClans = new List&lt;string&gt;[teamCount];
-      for (int i = 0; i &lt; teamClans.Length; ++i) teamClans[i] = new List&lt;string&gt;();
+		public void ComSplit(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length != 2) {
+				Respond(e, &quot;This command needs 2 parameters&quot;);
+				return;
+			}
+			if (words[0] != &quot;h&quot; &amp;&amp; words[0] != &quot;v&quot;) Respond(e, &quot;first parameter must be 'h' or 'v'&quot;);
+			else {
+				int perc;
+				int.TryParse(words[1], out perc);
+				if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
+				else {
+					if (words[0] == &quot;h&quot;) {
+						tas.AddBattleRectangle(0, new BattleRect(0, 0, 1.0, perc/100.0));
+						tas.AddBattleRectangle(1, new BattleRect(0, 1.0 - perc/100.0, 1.0, 1.0));
+					} else {
+						tas.AddBattleRectangle(0, new BattleRect(0, 0, perc/100.0, 1.0));
+						tas.AddBattleRectangle(1, new BattleRect(1.0 - perc/100.0, 0, 1.0, 1.0));
+					}
+					tas.RemoveBattleRectangle(2);
+					tas.RemoveBattleRectangle(3);
+				}
+			}
+		}
 
-      if (clanwise) {
-        string clans = &quot;&quot;;
-        // remove clans that have less than 2 members - those are irelevant
-        foreach (UsRank u in ranker) {
-          if (u.clan != &quot;&quot;) {
-            if (ranker.FindAll(delegate(UsRank x) { return x.clan == u.clan; }).Count &lt; 2) u.clan = &quot;&quot;;
-            else clans += u.clan + &quot;, &quot;;
-          }
-        }
-        if (clans != &quot;&quot;) SayBattle(&quot;those clan are being balanced: &quot; + clans);
-      }
 
-      // this cycle performs actual user adding to teams
-      int cnt = 0;
-      while (ranker.Count &gt; 0) {
-        int minsum = int.MaxValue;
-        int minid = 0;
-        for (int i = 0; i &lt; teamCount; ++i) {
-          List&lt;UsRank&gt; l = teamUsers[i];
-          // pick only current &quot;row&quot; and find the one with least sum
-          if (l.Count == cnt/teamCount) {
-            if (teamSums[i] &lt; minsum) {
-              minid = i;
-              minsum = teamSums[i];
-            }
-          }
-        }
+		public void ComSpringie(TasSayEventArgs e, string[] words)
+		{
+			var b = tas.GetBattle();
 
-        int picked_user = 0;
-        if (clanwise) {
-          // clanwise balancing - attempt to pick someone with same clan
-          // selected team already has some clan
-          int rank = ranker[0].rank;
-          List&lt;int&gt; temp = new List&lt;int&gt;();
+			var running = DateTime.Now.Subtract(Program.startupTime);
+			running = new TimeSpan((int) running.TotalHours, running.Minutes, running.Seconds);
 
-          // get list of clans assigned to other teams
-          List&lt;string&gt; assignedClans = new List&lt;string&gt;();
-          for (int i = 0; i &lt; teamClans.Length; ++i) if (i != minid) foreach (string clanName in teamClans[i]) assignedClans.Add(clanName);
+			var started = DateTime.Now.Subtract(spring.GameStarted);
+			started = new TimeSpan((int) started.TotalHours, started.Minutes, started.Seconds);
 
-          // first try to get some with same clan
-          if (teamClans[minid].Count &gt; 0) {
-            for (int i = 0; i &lt; ranker.Count; ++i) {
-              if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
-              if (ranker[i].clan != &quot;&quot; &amp;&amp; teamClans[minid].Contains(ranker[i].clan)) temp.Add(i);
-            }
-          }
+			Respond(e, tas.UserName + &quot; (&quot; + MainConfig.SpringieVersion + &quot;) running for &quot; + running);
+			Respond(e, &quot;players: &quot; + (b.Users.Count - b.CountSpectators()) + &quot;/&quot; + b.MaxPlayers);
+			Respond(e, &quot;mod: &quot; + b.Mod.Name);
+			Respond(e, &quot;map: &quot; + b.Map.Name);
+			Respond(e, &quot;game &quot; + (spring.IsRunning ? &quot;running since &quot; : &quot;not running, last started &quot;) + (spring.GameStarted != DateTime.MinValue ? started + &quot; ago&quot; : &quot;never&quot;));
+		}
 
-          if (temp.Count == 0) {
-            // we dont have any candidates try to get clanner from unassigned clan
-            for (int i = 0; i &lt; ranker.Count; ++i) {
-              if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
-              if (ranker[i].clan != &quot;&quot; &amp;&amp; !assignedClans.Contains(ranker[i].clan)) temp.Add(i);
-            }
-          }
+		public void ComStart(TasSayEventArgs e, string[] words)
+		{
+			List&lt;string&gt; usname;
+			if (!AllReadyAndSynced(out usname)) {
+				SayBattle(&quot;cannot start, &quot; + Utils.Glue(usname.ToArray()) + &quot; not ready and synced&quot;);
+				return;
+			}
 
-          if (temp.Count == 0) {
-            // we still dont have any candidates try to get non-clanner
-            for (int i = 0; i &lt; ranker.Count; ++i) {
-              if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
-              if (ranker[i].clan == &quot;&quot;) temp.Add(i);
-            }
-          }
+			if (!AllUniqueTeams(out usname)) {
+				SayBattle(&quot;cannot start, &quot; + Utils.Glue(usname.ToArray()) + &quot; is sharing teams. Use !forcestart to override&quot;);
+				return;
+			}
 
-          // if we have some candidates pick one randomly
-          if (temp.Count &gt; 0) picked_user = temp[rand.Next(temp.Count)];
-          ;
-        }
+			int allyno;
+			if (!BalancedTeams(out allyno)) {
+				SayBattle(&quot;cannot start, alliance &quot; + (allyno + 1) + &quot; not fair. Use !forcestart to override&quot;);
+				return;
+			}
 
-        UsRank usr = ranker[picked_user];
-        teamUsers[minid].Add(usr);
-        teamSums[minid] += usr.rank;
+			if (CheckAndSendPlanetWarsStart(e)) {
+				SayBattle(&quot;please wait, game is about to start&quot;);
 
-        if (clanwise &amp;&amp; usr.clan != &quot;&quot;) {
-          // if we work with clans add user's clan to clan list for his team
-          if (!teamClans[minid].Contains(usr.clan)) teamClans[minid].Add(usr.clan);
-        }
+				StopVote();
 
-        ranker.RemoveAt(picked_user);
+				var b = tas.GetBattle();
+				if (b != null) {
+					string curMap = b.Map.ArchiveName.ToLower();
 
-        cnt++;
-      }
+					var nd = new Dictionary&lt;int, BattleRect&gt;();
+					foreach (var v in b.Rectangles) nd.Add(v.Key, v.Value);
 
-      // alliances for allinace permutations
-      List&lt;int&gt; allys = new List&lt;int&gt;();
-      for (int i = 0; i &lt; teamCount; ++i) allys.Add(i);
+					if (MapBoxes.ContainsKey(curMap)) MapBoxes[curMap] = nd;
+					else MapBoxes.Add(curMap, nd);
+					SaveConfig();
+				}
+				tas.ChangeLock(true);
+				tas.StartGame();
+			}
+		}
 
-      for (int i = 0; i &lt; teamCount; ++i) {
-        // permute one alliance
-        int rdindex = rand.Next(allys.Count);
-        int allynum = allys[rdindex];
-        allys.RemoveAt(rdindex);
+		public void ComTeam(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length &lt; 2) {
+				Respond(e, &quot;this command needs 2 parameters (team number and player name)&quot;);
+				return;
+			}
+			int teamno = 0;
+			if (!int.TryParse(words[0], out teamno) || --teamno &lt; 0 || teamno &gt;= Spring.MaxTeams) {
+				Respond(e, &quot;invalid team number&quot;);
+				return;
+			}
+			string[] usrs;
+			int[] idx;
+			if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
+			else {
+				SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to team &quot; + (teamno + 1));
+				tas.ForceTeam(usrs[0], teamno);
+			}
+		}
 
-        foreach (UsRank u in teamUsers[i]) tas.ForceAlly(actUsers[u.id].name, allynum);
-      }
+		internal static int Filter(string[] source, string[] words, out string[] resultVals, out int[] resultIndexes)
+		{
+			int i;
 
-      string t = string.Format(&quot;{0} players balanced to {1} teams (ranks &quot;, actUsers.Count, teamCount);
-      for (int i = 0; i &lt; teamSums.Length; ++i) {
-        if (i &gt; 0) t += &quot;:&quot;;
-        t += teamSums[i].ToString();
-      }
-      t += &quot;)&quot;;
-      if (clanwise) t += &quot; respecting clans&quot;;
-      SayBattle(t);
-    }
+			// search by direct index
+			if (words.Length == 1) {
+				if (int.TryParse(words[0], out i)) {
+					if (i &gt;= 0 &amp;&amp; i &lt; source.Length) {
+						resultVals = new[] {source[i]};
+						resultIndexes = new[] {i};
+						return 1;
+					}
+				}
 
+				// search by direct word
+				string glued = Utils.Glue(words);
+				for (i = 0; i &lt; source.Length; ++i) {
+					if (source[i] == glued) {
+						resultVals = new[] {source[i]};
+						resultIndexes = new[] {i};
+						return 1;
+					}
+				}
+			}
 
-    public void ComBalance(TasSayEventArgs e, string[] words)
-    {
-      int teamCount = 2;
-      if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
-      else teamCount = 2;
-      ComFix(e, words);
-      BalanceTeams(teamCount, false);
-    }
+			var res = new List&lt;string&gt;();
+			var resi = new List&lt;int&gt;();
 
-    public void ComCBalance(TasSayEventArgs e, string[] words)
-    {
-      int teamCount = 2;
-      if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
-      else teamCount = 2;
-      ComFix(e, words);
-      BalanceTeams(teamCount, true);
-    }
+			for (i = 0; i &lt; words.Length; ++i) words[i] = words[i].ToLower();
+			for (i = 0; i &lt; source.Length; ++i) {
+				if (source[i] + &quot;&quot; == &quot;&quot;) continue;
+				string item = source[i];
+				bool isok = true;
+				for (int j = 0; j &lt; words.Length; ++j) {
+					if (!item.ToLower().Contains(words[j])) {
+						isok = false;
+						break;
+					}
+				}
+				if (isok) {
+					res.Add(item);
+					resi.Add(i);
+				}
+			}
 
+			resultVals = res.ToArray();
+			resultIndexes = resi.ToArray();
 
-    public void ComSetLevel(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length != 2) {
-        Respond(e, &quot;This command needs 2 parameters&quot;);
-        return;
-      }
-      int lvl;
-      int.TryParse(words[0], out lvl);
-      config.SetPrivilegedUser(words[1], lvl);
-      SaveConfig();
-      Respond(e, words[1] + &quot; has rights level &quot; + lvl.ToString());
-    }
+			return res.Count;
+		}
 
+		public int FilterMaps(string[] words, out string[] vals, out int[] indexes)
+		{
+			return FilterMaps(words, tas, spring, ladder, out vals, out indexes);
+		}
 
-    public void ComSay(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Respond(e, &quot;This command needs 1 parameter (say text)&quot;);
-        return;
-      }
-      SayBattle(&quot;[&quot; + e.UserName + &quot;]&quot; + Utils.Glue(words));
-    }
+		internal static int FilterMods(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
+		{
+			var temp = new string[spring.UnitSync.ModList.Keys.Count];
+			int cnt = 0;
+			foreach (var s in spring.UnitSync.ModList.Keys) {
+				var limit = Program.main.AutoHost.config.LimitMods;
+				if (limit != null &amp;&amp; limit.Length &gt; 0) {
+					bool allowed = false;
+					for (int i = 0; i &lt; limit.Length; ++i) {
+						if (s.ToLower().Contains(limit[i].ToLower())) {
+							allowed = true;
+							break;
+						}
+					}
+					if (allowed) temp[cnt++] = s;
+				} else temp[cnt++] = s;
+			}
 
-    public void ComDlMap(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Respond(e, &quot;This command needs 1 parameter (map name)&quot;);
-        return;
-      }
-      string str = Utils.Glue(words);
-      string dump;
-      int dumpi;
-      string res = str;
+			return Filter(temp, words, out vals, out indexes);
+		}
 
-      if (!int.TryParse(str, out dumpi) &amp;&amp; !FileDownloader.IsFileUrl(str, out dump)) {
-        res = &quot;&quot;;
-        try {
-          dump = linker.GetResults(str, UnknownFilesLinker.FileType.Map);
-          res = Regex.Match(dump, &quot;file/([0-9]*)&quot;).Groups[1].Value;
-        } catch {}
-      }
+		public int FilterPlanets(string[] words, out string[] vals, out int[] indexes)
+		{
+			var pw = Program.main.PlanetWars;
+			var options = pw.GetAttackOptions();
 
-      if (res != &quot;&quot;) {
-        Respond(e, &quot;Starting map download&quot;);
-        fileDownloader.DownloadMap(res);
-      } else Respond(e, &quot;I cannot find such map&quot;);
-    }
+			var temp = new string[options.Count];
+			int cnt = 0;
+			foreach (var planet in options) temp[cnt++] = planet.Name;
+			return Filter(temp, words, out vals, out indexes);
+		}
 
 
-    public void ComDlMod(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Respond(e, &quot;This command needs 1 parameter (mod name or id)&quot;);
-        return;
-      }
-      string str = Utils.Glue(words);
-      string dump;
-      int dumpi;
-      string res = str;
+		internal static int FilterPresets(string[] words, AutoHost autohost, out string[] vals, out int[] indexes)
+		{
+			var temp = new string[autohost.presets.Count];
+			int cnt = 0;
+			foreach (var p in autohost.presets) temp[cnt++] = p.Name + &quot; --&gt; &quot; + p.Description;
+			return Filter(temp, words, out vals, out indexes);
+		}
 
-      if (!int.TryParse(str, out dumpi) &amp;&amp; !FileDownloader.IsFileUrl(str, out dump)) {
-        res = &quot;&quot;;
-        try {
-          dump = linker.GetResults(str, UnknownFilesLinker.FileType.Mod);
-          res = Regex.Match(dump, &quot;file/([0-9]*)&quot;).Groups[1].Value;
-        } catch {}
-      }
+		internal static int FilterUsers(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
+		{
+			var b = tas.GetBattle();
+			var temp = new string[b.Users.Count];
+			int i = 0;
+			foreach (var u in b.Users) temp[i++] = u.name;
+			return Filter(temp, words, out vals, out indexes);
+		}
 
-      if (res != &quot;&quot;) {
-        Respond(e, &quot;Starting mod download&quot;);
-        fileDownloader.DownloadMod(res);
-      } else Respond(e, &quot;I cannot find such mod&quot;);
-    }
 
+		public string GetOptionsString(TasSayEventArgs e, string[] words)
+		{
+			string s = Utils.Glue(words);
+			string result = &quot;&quot;;
+			var pairs = s.Split(new[] {','});
+			if (pairs.Length == 0 || pairs[0].Length == 0) {
+				Respond(e, &quot;requires key=value format&quot;);
+				return &quot;&quot;;
+			}
+			foreach (var pair in pairs) {
+				var parts = pair.Split(new[] {'='}, 2);
+				if (parts.Length != 2) {
+					Respond(e, &quot;requires key=value format&quot;);
+					return &quot;&quot;;
+				}
+				var b = tas.GetBattle();
+				string key = parts[0];
+				string val = parts[1];
 
-    public void ComTeam(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length &lt; 2) {
-        Respond(e, &quot;this command needs 2 parameters (team number and player name)&quot;);
-        return;
-      }
-      int teamno = 0;
-      if (!int.TryParse(words[0], out teamno) || --teamno &lt; 0 || teamno &gt;= Spring.MaxTeams) {
-        Respond(e, &quot;invalid team number&quot;);
-        return;
-      }
-      string[] usrs;
-      int[] idx;
-      if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
-      else {
-        SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to team &quot; + (teamno + 1));
-        tas.ForceTeam(usrs[0], teamno);
-      }
-    }
+				bool found = false;
+				foreach (var o in b.Mod.Options) {
+					if (o.Key == key) {
+						found = true;
+						string res;
+						if (o.GetPair(val, out res)) {
+							if (result != &quot;&quot;) result += &quot;\t&quot;;
+							result += res;
+						} else Respond(e, &quot;Value &quot; + val + &quot; is not valid for this option&quot;);
 
-    public void ComManage(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length &lt; 1) {
-        Respond(e, &quot;this command needs 1 parameters (minimum number of players to manage for)&quot;);
-        return;
-      }
-      int min = 0;
-      int.TryParse(words[0], out min);
-      int max = min;
-      if (words.Length &gt; 1) int.TryParse(words[1], out max);
-      if (min == 0) Respond(e, &quot;managing disabled&quot;);
-      else Respond(e, &quot;auto managing for &quot; + min + &quot; to &quot; + max + &quot; players&quot;);
-      manager.Manage(min, max);
-    }
+						break;
+					}
+				}
+				if (!found) {
+					Respond(e, &quot;No option called &quot; + key + &quot; found&quot;);
+					return &quot;&quot;;
+				}
+			}
+			return result;
+		}
 
-    public void ComAlly(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length &lt; 2) {
-        Respond(e, &quot;this command needs 2 parameters (ally number and player name)&quot;);
-        return;
-      }
-      int allyno = 0;
-      if (!int.TryParse(words[0], out allyno) || --allyno &lt; 0 || allyno &gt;= Spring.MaxAllies) {
-        Respond(e, &quot;invalid ally number&quot;);
-        return;
-      }
-      string[] usrs;
-      int[] idx;
-      if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
-      else {
-        SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to alliance &quot; + (allyno + 1));
-        tas.ForceAlly(usrs[0], allyno);
-      }
-    }
+		#endregion
 
+		#region Other methods
 
-    public void ComSpringie(TasSayEventArgs e, string[] words)
-    {
-      Battle b = tas.GetBattle();
+		private bool CheckAndSendPlanetWarsStart(TasSayEventArgs e)
+		{
+			if (Program.main.config.PlanetWarsEnabled) {
+				try {
+					bool ok = true;
+					var pw = Program.main.PlanetWars;
+					string currentMapName = tas.GetBattle().Map.Name;
+					var fmap = pw.GetAttackOptions().Find(p =&gt; p.MapName == currentMapName);
+					if (fmap == null) {
+						SayBattle(&quot;This planet is not currently allowed, select another one&quot;);
+						return false;
+					}
 
-      TimeSpan running = DateTime.Now.Subtract(Program.startupTime);
-      running = new TimeSpan((int)running.TotalHours, running.Minutes, running.Seconds);
+					var factions = pw.GetFactions();
 
-      TimeSpan started = DateTime.Now.Subtract(spring.GameStarted);
-      started = new TimeSpan((int)started.TotalHours, started.Minutes, started.Seconds);
+					var actual = new List&lt;IPlayer&gt;();
+					foreach (var user in tas.GetBattle().Users) {
+						if (!user.IsSpectator) {
+							var info = pw.GetPlayerInfo(user.name);
+							actual.Add(info);
+							string side = tas.GetBattle().Mod.Sides[user.Side];
+							string hisSide = factions.Find(f =&gt; f.Name == info.FactionName).SpringSide;
 
-      Respond(e, tas.UserName + &quot; (&quot; + MainConfig.SpringieVersion + &quot;) running for &quot; + running);
-      Respond(e, &quot;players: &quot; + (b.Users.Count - b.CountSpectators()) + &quot;/&quot; + b.MaxPlayers);
-      Respond(e, &quot;mod: &quot; + b.Mod.Name);
-      Respond(e, &quot;map: &quot; + b.Map.Name);
-      Respond(e, &quot;game &quot; + (spring.IsRunning ? &quot;running since &quot; : &quot;not running, last started &quot;) + (spring.GameStarted != DateTime.MinValue ? started.ToString() + &quot; ago&quot; : &quot;never&quot;));
-    }
+							if (!string.Equals(side, hisSide, StringComparison.InvariantCultureIgnoreCase)) {
+								SayBattle(string.Format(&quot;{0} must switch to {1}&quot;, user.name, hisSide), false);
+								ok = false;
+							}
+						}
+					}
+					if (ok) {
+						string options = pw.GetStartupModOptions(tas.GetBattle().Map.Name, actual);
+						var b = tas.GetBattle();
+						foreach (var o in b.Mod.Options) {
+							if (o.Key == &quot;planetwars&quot;) {
+								string res;
+								if (o.GetPair(options, out res)) {
+									tas.SetScriptTag(res);
+									return ok;
+								} else {
+									Respond(e, &quot;Eror setting script tag&quot;);
+									return false;
+								}
+							}
+						}
+						Respond(e, &quot;This mod does not support PlanetWars&quot;);
+						return false;
+					}
 
-    public void ComPresetDetails(TasSayEventArgs e, string[] words)
-    {
-      string[] vals;
-      int[] indexes;
-      if (FilterPresets(words, out vals, out indexes) &gt; 0) {
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-        foreach (string line in presets[indexes[0]].ToString().Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
-        tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      } else Respond(e, &quot;no such preset found&quot;);
-    }
+					return ok;
+				} catch (Exception ex) {
+					SayBattle(string.Format(&quot;Error when checking PlanetWars teams: {0}&quot;, ex.Message), false);
+					return false;
+				}
+			} else return true;
+		}
 
+		private void ComAdmins(TasSayEventArgs e, string[] words)
+		{
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			foreach (var u in config.PrivilegedUsers) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; &quot; + u.Name + &quot; (level &quot; + u.Level + &quot;)&quot;, false);
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+		}
 
-    public void ComPreset(TasSayEventArgs e, string[] words)
-    {
-      string[] vals;
-      int[] indexes;
-      if (FilterPresets(words, out vals, out indexes) &gt; 0) {
-        Preset p = presets[indexes[0]];
-        Respond(e, &quot;applying preset &quot; + p.Name + &quot; (&quot; + p.Description + &quot;)&quot;);
-        p.Apply(tas, ladder);
-      } else Respond(e, &quot;no such preset found&quot;);
-    }
+		private void ComHelp(TasSayEventArgs e, string[] words)
+		{
+			int ulevel = GetUserLevel(e);
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			foreach (var c in config.Commands) if (c.Level &lt;= ulevel) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+		}
 
 
-    private void SayLines(TasSayEventArgs e, string what)
-    {
-      foreach (string line in what.Split(new char[] {'\n', '\r'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
-    }
+		private void ComHelpAll(TasSayEventArgs e, string[] words)
+		{
+			var copy = new List&lt;CommandConfig&gt;(config.Commands);
+			copy.Sort(delegate(CommandConfig a, CommandConfig b)
+			          	{
+			          		if (a.Level != b.Level) return a.Level.CompareTo(b.Level);
+			          		else return a.Name.CompareTo(b.Name);
+			          	});
 
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			foreach (var c in copy) tas.Say(TasClient.SayPlace.User, e.UserName, &quot;Level &quot; + c.Level + &quot; --&gt; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+		}
 
-    private void RemoteCommand(string scriptName, TasSayEventArgs e, string[] words)
-    {
-      if (Program.main.Stats == null) {
-        Respond(e, &quot;Stats system is disabled on this autohost.&quot;);
-        return;
-      }
-      Battle b = tas.GetBattle();
-      if (b != null) {
-        string query = string.Format(&quot;user={0}&amp;map={1}&amp;mod={2}&amp;p={3}&quot;, e.UserName, b.Map.Name, b.Mod.Name, Utils.Glue(words));
-        foreach (UserBattleStatus u in b.Users) if (u.name != tas.UserName) query += string.Format(&quot;&amp;users[]={0}|{1}|{2}&quot;, u.name, (u.IsSpectator ? &quot;1&quot; : &quot;0&quot;), u.AllyNumber);
-        string[] response = Program.main.Stats.SendCommand(scriptName, query, false, true).Split(new char[] {'\r', '\n'}, StringSplitOptions.RemoveEmptyEntries);
+		private void ComListMaps(TasSayEventArgs e, string[] words)
+		{
+			string[] vals;
+			int[] indexes;
+			if (FilterMaps(words, out vals, out indexes) &gt; 0) {
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+				for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			} else Respond(e, &quot;no such map found&quot;);
+		}
 
-        if (response.Length == 0) {
-          Respond(e, &quot;error accessing stats server&quot;);
-          return;
-        }
+		private void ComListMods(TasSayEventArgs e, string[] words)
+		{
+			string[] vals;
+			int[] indexes;
+			if (FilterMods(words, out vals, out indexes) &gt; 0) {
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+				for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			} else Respond(e, &quot;no such mod found&quot;);
+		}
 
-        if (response[0].StartsWith(&quot;RESPOND&quot;)) for (int i = 1; i &lt; response.Length; ++i) Respond(e, response[i]);
-        else foreach (string line in response) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
-      }
-    }
+		private void ComListOptions(TasSayEventArgs e, string[] words)
+		{
+			var b = tas.GetBattle();
+			if (b.Mod.Options.Count == 0) Respond(e, &quot;this mod has no options&quot;);
+			else foreach (var opt in b.Mod.Options) Respond(e, opt.ToString());
+		}
 
+		private void ComListPlanets(TasSayEventArgs e, string[] words)
+		{
+			string[] vals;
+			int[] indexes;
+			if (!Program.main.config.PlanetWarsEnabled) {
+				Respond(e, &quot;This is not PlanetWars host&quot;);
+				return;
+			}
+			try {
+				if (FilterPlanets(words, out vals, out indexes) &gt; 0) {
+					Respond(e, &quot;Planets available for attack are:&quot;);
+					for (int i = 0; i &lt; vals.Length; ++i) Respond(e, string.Format(&quot;{0}: {1}&quot;, indexes[i], vals[i]));
+				} else Respond(e, &quot;no such planet found&quot;);
+			} catch (Exception ex) {
+				Respond(e, string.Format(&quot;Error getting planets: {0}&quot;, ex.Message));
+			}
+		}
 
-    public void ComForceSpectatorAfk(TasSayEventArgs e, string[] words)
-    {
-      Battle b = tas.GetBattle();
-      if (b != null) {
-        foreach (UserBattleStatus u in b.Users) {
-          User u2;
-          if (u.name != tas.UserName &amp;&amp; !u.IsSpectator &amp;&amp; !u.IsReady &amp;&amp; tas.GetExistingUser(u.name, out u2)) if (u2.isAway) ComForceSpectator(e, new string[] {u.name});
-        }
-      }
-    }
+		private void ComListPresets(TasSayEventArgs e, string[] words)
+		{
+			string[] vals;
+			int[] indexes;
 
+			if (FilterPresets(words, out vals, out indexes) &gt; 0) {
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+				for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
+				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			} else Respond(e, &quot;no such preset found&quot;);
+		}
 
-    public void ComKickSpec(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickSpectators = (words[0] == &quot;1&quot;);
-      else kickSpectators = !kickSpectators;
+		private void ComMap(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Respond(e, &quot;You must specify a map name&quot;);
+				return;
+			}
+			string[] vals;
+			int[] indexes;
+			if (FilterMaps(words, out vals, out indexes) &gt; 0) {
+				SayBattle(&quot;changing map to &quot; + vals[0]);
+				tas.ChangeMap(spring.UnitSync.MapList[vals[0]]);
+			} else Respond(e, &quot;Cannot find such map.&quot;);
+		}
 
-      if (kickSpectators) SayBattle(&quot;automatic spectator kicking is now ENABLED&quot;);
-      else SayBattle(&quot;automatic spectator kicking is now DISABLED&quot;);
 
-      if (kickSpectators) {
-        SayBattle(config.KickSpectatorText);
-        Battle b = tas.GetBattle();
-        if (b != null) foreach (UserBattleStatus u in b.Users) if (u.name != tas.UserName &amp;&amp; u.IsSpectator) ComKick(e, new string[] {u.name});
-      }
-    }
+		private void ComNotify(TasSayEventArgs e, string[] words)
+		{
+			if (!toNotify.Contains(e.UserName)) toNotify.Add(e.UserName);
+			Respond(e, &quot;I will notify you when game ends&quot;);
+		}
 
-    public void ComKickMinRank(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickMinRank = (words[0] == &quot;1&quot;);
-      else kickMinRank = !kickMinRank;
+		private void ComPlanet(TasSayEventArgs e, string[] words)
+		{
+			if (!Program.main.config.PlanetWarsEnabled) {
+				Respond(e, &quot;This is not a PlanetWars host&quot;);
+				return;
+			}
 
-      if (kickMinRank) SayBattle(&quot;automatic minrank kicking is now ENABLED&quot;);
-      else SayBattle(&quot;automatic minrank kicking is now DISABLED&quot;);
+			if (words.Length == 0) {
+				Respond(e, &quot;You must specify planet name&quot;);
+				return;
+			}
+			string[] vals;
+			int[] indexes;
+			if (FilterPlanets(words, out vals, out indexes) &gt; 0) {
+				var pw = Program.main.PlanetWars;
+				var info = pw.GetPlayerInfo(e.UserName);
+				var fact = pw.GetOffensiveFaction();
+				if (info != null &amp;&amp; info.IsCommanderInChief) {
+					if (info.FactionName == fact.Name) {
+						SayBattle(string.Format(&quot;changing planet to {0} by {1}&quot;, vals[0], e.UserName));
+						var planet = pw.GetAttackOptions().Find((m) =&gt; m.Name == vals[0]);
+						tas.ChangeMap(spring.UnitSync.MapList[planet.MapName]);
+					} else Respond(e, string.Format(&quot;It's currently {0} turn&quot;, fact.Name));
+				} else Respond(e, &quot;You are not a commander-in-chief&quot;);
+			} else Respond(e, &quot;Cannot find such planet.&quot;);
+		}
 
-      HandleMinRankKicking();
-    }
+		private void ComRegister(TasSayEventArgs e, string[] words)
+		{
+			if (!Program.main.config.PlanetWarsEnabled) {
+				Respond(e, &quot;This is not PlanetWars host&quot;);
+				return;
+			}
+			if (words.Length &lt; 2) {
+				Respond(e, &quot;This command needs 2-3 parameters - side and password and optional planet name (you can PM it to me)&quot;);
+				return;
+			}
 
 
-    public void ComBoss(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        if (bossName == &quot;&quot;) {
-          Respond(e, &quot;there is currently no active boss&quot;);
-          return;
-        }
-        SayBattle(&quot;boss &quot; + bossName + &quot; removed&quot;);
-        bossName = &quot;&quot;;
-        return;
-      } else {
-        string[] usrs;
-        int[] idx;
-        if (FilterUsers(words, out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
-        else {
-          SayBattle(&quot;New boss is &quot; + usrs[0]);
-          bossName = usrs[0];
-        }
-      }
-    }
+			try {
+				var pw = Program.main.PlanetWars;
+				string response = pw.Register(new AuthInfo {Login = e.UserName, Password = words[1]}, words[0], words.Length &gt; 2 ? Utils.Glue(words, 2) : null);
+				Respond(e, string.Format(response));
+			} catch (Exception ex) {
+				Respond(e, string.Format(&quot;Error when registering: {0}&quot;, ex.Message));
+			}
+		}
 
+		private void ComSetGameTitle(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - new game title&quot;);
+			else {
+				Program.main.AutoHost.config.GameTitle = Utils.Glue(words);
+				SaveConfig();
+				Respond(e, &quot;game title changed&quot;);
+			}
+		}
 
-    private void ComSetMinRank(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) Respond(e, &quot;this command needs one parameter - rank number&quot;);
-      else {
-        int rank;
-        int.TryParse(words[0], out rank);
-        if (rank &lt; TasClient.MinRank) rank = TasClient.MinRank;
-        if (rank &gt; TasClient.MaxRank) rank = TasClient.MaxRank;
-        Program.main.AutoHost.config.MinRank = rank;
-        SaveConfig();
-        Respond(e, &quot;server rank changed&quot;);
-        HandleMinRankKicking();
-      }
-    }
+		private void ComSetMaxPlayers(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - number of players&quot;);
+			else {
+				int plr;
+				int.TryParse(words[0], out plr);
+				if (plr &lt; 1) plr = 1;
+				if (plr &gt; Spring.MaxTeams) plr = Spring.MaxTeams;
+				Program.main.AutoHost.config.MaxPlayers = plr;
+				SaveConfig();
+				Respond(e, &quot;server size changed&quot;);
+			}
+		}
 
-    private void ComSetMinCpuSpeed(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) Respond(e, &quot;this command needs one parameter - minimal CPU speed&quot;);
-      else {
-        Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
-        double minCpu;
-        double.TryParse(words[0], out minCpu);
-        minCpuSpeed = minCpu;
-        SayBattle(&quot;minimal CPU speed is now &quot; + minCpuSpeed + &quot;GHz&quot;);
-        if (minCpuSpeed &gt; 0) {
-          Battle b = tas.GetBattle();
-          if (b != null) {
-            foreach (UserBattleStatus ubs in b.Users) {
-              User u;
-              if (ubs.name != tas.UserName &amp;&amp; tas.GetExistingUser(ubs.name, out u)) if (u.cpu &gt; 0 &amp;&amp; u.cpu &lt; minCpuSpeed*1000) ComKick(e, new string[] {u.name});
-            }
-          }
-        }
-      }
-    }
+		private void ComSetMinCpuSpeed(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - minimal CPU speed&quot;);
+			else {
+				Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+				double minCpu;
+				double.TryParse(words[0], out minCpu);
+				minCpuSpeed = minCpu;
+				SayBattle(&quot;minimal CPU speed is now &quot; + minCpuSpeed + &quot;GHz&quot;);
+				if (minCpuSpeed &gt; 0) {
+					var b = tas.GetBattle();
+					if (b != null) {
+						foreach (var ubs in b.Users) {
+							User u;
+							if (ubs.name != tas.UserName &amp;&amp; tas.GetExistingUser(ubs.name, out u)) if (u.cpu &gt; 0 &amp;&amp; u.cpu &lt; minCpuSpeed*1000) ComKick(e, new[] {u.name});
+						}
+					}
+				}
+			}
+		}
 
-    private void ComSetMaxPlayers(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) Respond(e, &quot;this command needs one parameter - number of players&quot;);
-      else {
-        int plr;
-        int.TryParse(words[0], out plr);
-        if (plr &lt; 1) plr = 1;
-        if (plr &gt; Spring.MaxTeams) plr = Spring.MaxTeams;
-        Program.main.AutoHost.config.MaxPlayers = plr;
-        SaveConfig();
-        Respond(e, &quot;server size changed&quot;);
-      }
-    }
+		private void ComSetMinRank(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - rank number&quot;);
+			else {
+				int rank;
+				int.TryParse(words[0], out rank);
+				if (rank &lt; TasClient.MinRank) rank = TasClient.MinRank;
+				if (rank &gt; TasClient.MaxRank) rank = TasClient.MaxRank;
+				Program.main.AutoHost.config.MinRank = rank;
+				SaveConfig();
+				Respond(e, &quot;server rank changed&quot;);
+				HandleMinRankKicking();
+			}
+		}
 
-    private void ComSetGameTitle(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) Respond(e, &quot;this command needs one parameter - new game title&quot;);
-      else {
-        Program.main.AutoHost.config.GameTitle = Utils.Glue(words);
-        SaveConfig();
-        Respond(e, &quot;game title changed&quot;);
-      }
-    }
 
-    private void ComSetPassword(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        Program.main.AutoHost.config.Password = &quot;&quot;;
-        Respond(e, &quot;password remoded&quot;);
-      } else {
-        Program.main.AutoHost.config.Password = words[0];
-        SaveConfig();
-        Respond(e, &quot;password changed&quot;);
-      }
-    }
+		private void ComSetOption(TasSayEventArgs e, string[] words)
+		{
+			string ret = GetOptionsString(e, words);
+			if (ret != &quot;&quot;) {
+				tas.SetScriptTag(ret);
+				Respond(e, &quot;Options set&quot;);
+			}
+		}
 
+		private void ComSetPassword(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				Program.main.AutoHost.config.Password = &quot;&quot;;
+				Respond(e, &quot;password remoded&quot;);
+			} else {
+				Program.main.AutoHost.config.Password = words[0];
+				SaveConfig();
+				Respond(e, &quot;password changed&quot;);
+			}
+		}
 
-    public void ComAutoLock(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        autoLock = 0;
-        Respond(e, &quot;AutoLocking disabled&quot;);
-        return;
-      }
-      int num = 0;
-      int.TryParse(words[0], out num);
-      int maxp = tas.GetBattle().MaxPlayers;
-      if (num &lt; config.AutoLockMinPlayers || num &gt; maxp) {
-        autoLock = 0;
-        Respond(e, &quot;number of players must be between &quot; + config.AutoLockMinPlayers + &quot; and &quot; + maxp + &quot;, AutoLocking disabled&quot;);
-        return;
-      }
-      autoLock = num;
-      HandleAutoLocking();
-      Respond(e, &quot;AutoLock set to &quot; + autoLock + &quot; players&quot;);
-    }
+		private static int FilterMaps(string[] words, TasClient tas, Spring spring, Ladder ladder, out string[] vals, out int[] indexes)
+		{
+			var temp = new string[spring.UnitSync.MapList.Keys.Count];
+			int cnt = 0;
+			foreach (var s in spring.UnitSync.MapList.Keys) {
+				if (ladder != null) {
+					if (ladder.Maps.Contains(s.ToLower())) temp[cnt++] = s;
+				} else {
+					var limit = Program.main.AutoHost.config.LimitMaps;
+					if (limit != null &amp;&amp; limit.Length &gt; 0) {
+						bool allowed = false;
+						for (int i = 0; i &lt; limit.Length; ++i) {
+							if (s.ToLower().Contains(limit[i].ToLower())) {
+								allowed = true;
+								break;
+							}
+						}
+						if (allowed) temp[cnt++] = s;
+					} else temp[cnt++] = s;
+				}
+			}
+			return Filter(temp, words, out vals, out indexes);
+		}
 
+		private int FilterMods(string[] words, out string[] vals, out int[] indexes)
+		{
+			return FilterMods(words, tas, spring, out vals, out indexes);
+		}
 
-    private void ComListOptions(TasSayEventArgs e, string[] words)
-    {
-      Battle b = tas.GetBattle();
-      if (b.Mod.Options.Count == 0) Respond(e, &quot;this mod has no options&quot;);
-      else foreach (UnitSync.Option opt in b.Mod.Options) Respond(e, opt.ToString());
-    }
+		private int FilterPresets(string[] words, out string[] vals, out int[] indexes)
+		{
+			return FilterPresets(words, this, out vals, out indexes);
+		}
 
+		private int FilterUsers(string[] words, out string[] vals, out int[] indexes)
+		{
+			return FilterUsers(words, tas, spring, out vals, out indexes);
+		}
 
-    public string GetOptionsString(TasSayEventArgs e, string[] words)
-    {
-      string s = Utils.Glue(words);
-      string result = &quot;&quot;;
-      string[] pairs = s.Split(new char[] {','});
-      if (pairs.Length == 0 || pairs[0].Length == 0) {
-        Respond(e, &quot;requires key=value format&quot;);
-        return &quot;&quot;;
-      }
-      foreach (string pair in pairs) {
-        string[] parts = pair.Split(new char[] {'='}, 2);
-        if (parts.Length != 2) {
-          Respond(e, &quot;requires key=value format&quot;);
-          return &quot;&quot;;
-        }
-        Battle b = tas.GetBattle();
-        string key = parts[0];
-        string val = parts[1];
+		private static string GetClan(string name)
+		{
+			foreach (Match m in Regex.Matches(name, &quot;\\[([^\\]]+)\\]&quot;)) return m.Groups[1].Value;
+			return &quot;&quot;;
+		}
 
-        bool found = false;
-        foreach (UnitSync.Option o in b.Mod.Options) {
-          if (o.Key == key) {
-            found = true;
-            string res;
-            if (o.GetPair(val, out res)) {
-              if (result != &quot;&quot;) result += &quot;\t&quot;;
-              result += res;
-            } else Respond(e, &quot;Value &quot; + val + &quot; is not valid for this option&quot;);
+		private void RemoteCommand(string scriptName, TasSayEventArgs e, string[] words)
+		{
+			if (Program.main.Stats == null) {
+				Respond(e, &quot;Stats system is disabled on this autohost.&quot;);
+				return;
+			}
+			var b = tas.GetBattle();
+			if (b != null) {
+				string query = string.Format(&quot;user={0}&amp;map={1}&amp;mod={2}&amp;p={3}&quot;, e.UserName, b.Map.Name, b.Mod.Name, Utils.Glue(words));
+				foreach (var u in b.Users) if (u.name != tas.UserName) query += string.Format(&quot;&amp;users[]={0}|{1}|{2}&quot;, u.name, (u.IsSpectator ? &quot;1&quot; : &quot;0&quot;), u.AllyNumber);
+				var response = Program.main.Stats.SendCommand(scriptName, query, false, true).Split(new[] {'\r', '\n'}, StringSplitOptions.RemoveEmptyEntries);
 
-            break;
-          }
-        }
-        if (!found) {
-          Respond(e, &quot;No option called &quot; + key + &quot; found&quot;);
-          return &quot;&quot;;
-        }
-      }
-      return result;
-    }
+				if (response.Length == 0) {
+					Respond(e, &quot;error accessing stats server&quot;);
+					return;
+				}
 
+				if (response[0].StartsWith(&quot;RESPOND&quot;)) for (int i = 1; i &lt; response.Length; ++i) Respond(e, response[i]);
+				else foreach (var line in response) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
+			}
+		}
 
-    private void ComNotify(TasSayEventArgs e, string[] words)
-    {
-      if (!toNotify.Contains(e.UserName)) toNotify.Add(e.UserName);
-      Respond(e, &quot;I will notify you when game ends&quot;);
-    }
+		private void SayLines(TasSayEventArgs e, string what)
+		{
+			foreach (var line in what.Split(new[] {'\n', '\r'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
+		}
 
+		#endregion
 
-    private void ComSetOption(TasSayEventArgs e, string[] words)
-    {
-      string ret = GetOptionsString(e, words);
-      if (ret != &quot;&quot;) {
-        tas.SetScriptTag(ret);
-        Respond(e, &quot;Options set&quot;);
-      }
-    }
+		#region Nested type: UsRank
 
-    #region Nested type: UsRank
-    private class UsRank
-    {
-      public string clan;
-      public int id;
-      public int rank;
+		private class UsRank
+		{
+			#region Properties
 
-      public UsRank(int id, int rank, string clan)
-      {
-        this.id = id;
-        this.rank = rank;
-        this.clan = clan;
-      }
-    }
-    #endregion
-  }
+			public string clan;
+			public int id;
+			public int rank;
+
+			#endregion
+
+			#region Constructors
+
+			public UsRank(int id, int rank, string clan)
+			{
+				this.id = id;
+				this.rank = rank;
+				this.clan = clan;
+			}
+
+			#endregion
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/AutoManager.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/AutoManager.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/AutoManager.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,4 +1,7 @@
-&#65279;using System;
+&#65279;#region using
+
+using System;
+using System.Collections.Generic;
 using System.Threading;
 using System.Timers;
 using Springie.autohost;
@@ -6,117 +9,164 @@
 using Springie.SpringNamespace;
 using Timer=System.Timers.Timer;
 
+#endregion
+
 namespace Springie.AutoHostNamespace
 {
-  public class AutoManager
-  {
-    private const int KickAfter = 300;
-    private const int RingEvery = 60;
-    private const int SpecAfkAfter = 60;
-    private const int SpecForceAfter = 120;
+	public class AutoManager
+	{
+		#region Constants
 
-    private AutoHost ah;
-    private int from;
-    private DateTime lastRing = DateTime.Now;
-    private Spring spring;
-    private TasClient tas;
-    private Timer timer = new Timer(5000);
+		private const int KickAfter = 300;
+		private const int RingEvery = 60;
+		private const int SpecForceAfter = 120;
 
-    private int to;
+		#endregion
 
-    private DateTime waitForReadySince = DateTime.Now;
-    private bool waitReady = false;
+		#region Fields
 
-    public AutoManager(AutoHost ah, TasClient tas, Spring spring)
-    {
-      this.ah = ah;
-      this.tas = tas;
-      this.spring = spring;
-      timer.Elapsed += new ElapsedEventHandler(timer_Elapsed);
-      timer.Start();
-    }
+		private AutoHost ah;
+		private int from;
+		private DateTime lastRing = DateTime.Now;
+		private Dictionary&lt;string, DateTime&gt; problemSince = new Dictionary&lt;string, DateTime&gt;();
+		private Spring spring;
+		private TasClient tas;
+		private Timer timer = new Timer(5000);
 
-    public bool Enabled
-    {
-      get { return from &gt; 0; }
-    }
+		private int to;
 
+		#endregion
 
-    private void timer_Elapsed(object sender, ElapsedEventArgs e)
-    {
-      lock (timer) {
-        timer.Stop();
-        try {
-          if (from &gt; 0 &amp;&amp; !spring.IsRunning) {
-            Battle b = tas.GetBattle();
-            if (b != null) {
-              int plrCnt = b.CountPlayers();
-              if (plrCnt &gt;= from &amp;&amp; plrCnt &lt;= to) {
-                string notReady;
-                bool isReady = ah.AllReadyAndSynced(out notReady);
-                if (plrCnt%2 == 0) {
-                  int allyno;
-                  if (!ah.BalancedTeams(out allyno)) {
-                    ah.ComFix(TasSayEventArgs.Default, new string[] {});
-                    ah.ComFixColors(TasSayEventArgs.Default, new string[] {});
-                    ah.BalanceTeams(2, false);
-                  }
-                }
-                if (isReady) {
-                  Thread.Sleep(1000);
-                  if (!spring.IsRunning) ah.ComStart(TasSayEventArgs.Default, new string[] {});
-                } else {
-                  DateTime now = DateTime.Now;
-                  if (!waitReady) {
-                    waitReady = true;
-                    waitForReadySince = now;
-                  }
-                  if (plrCnt &gt; from &amp;&amp; plrCnt%2 == 1 &amp;&amp; b.IsLocked) ah.ComAutoLock(TasSayEventArgs.Default, new string[] {(plrCnt + 1).ToString()});
+		#region Properties
 
-                  if (now.Subtract(lastRing).TotalSeconds &gt; RingEvery) {
-                    lastRing = now;
-                    ah.ComRing(TasSayEventArgs.Default, new string[] {});
-                  }
+		public bool Enabled
+		{
+			get { return from &gt; 0; }
+		}
 
-                  if (plrCnt &gt; from &amp;&amp; now.Subtract(waitForReadySince).TotalSeconds &gt; SpecForceAfter) ah.ComForceSpectator(TasSayEventArgs.Default, new string[] {notReady});
+		#endregion
 
-                  if (now.Subtract(waitForReadySince).TotalSeconds &gt; SpecAfkAfter) ah.ComForceSpectatorAfk(TasSayEventArgs.Default, new string[] {});
-                  if (now.Subtract(waitForReadySince).TotalSeconds &gt; KickAfter) ah.ComKick(TasSayEventArgs.Default, new string[] {notReady});
-                }
-              } else {
-                if (b.IsLocked &amp;&amp; plrCnt &lt; from) ah.ComAutoLock(TasSayEventArgs.Default, new string[] {to.ToString()});
-                else if (plrCnt &gt; to) {
-                  string notready;
-                  if (!ah.AllReadyAndSynced(out notready)) ah.ComForceSpectator(TasSayEventArgs.Default, new string[] {notready});
-                }
-                waitReady = false;
-              }
-            }
-          } else {
-            lastRing = DateTime.Now;
-            waitReady = false;
-          }
-        } finally {
-          timer.Start();
-        }
-      }
-    }
+		#region Constructors
 
-    public void Manage(int from, int to)
-    {
-      if (to &lt; from) to = from;
-      this.from = from;
-      this.to = to;
-      timer.Start();
-    }
+		public AutoManager(AutoHost ah, TasClient tas, Spring spring)
+		{
+			this.ah = ah;
+			this.tas = tas;
+			this.spring = spring;
+			timer.Elapsed += timer_Elapsed;
+			timer.Start();
+		}
 
-    public void Stop()
-    {
-      from = 0;
-      to = 0;
-      lock (timer) {
-        timer.Stop();
-      }
-    }
-  }
+		#endregion
+
+		#region Public methods
+
+		public void Manage(int from, int to)
+		{
+			if (to &lt; from) to = from;
+			this.from = from;
+			this.to = to;
+			timer.Start();
+		}
+
+		public void Stop()
+		{
+			from = 0;
+			to = 0;
+			lock (timer) {
+				timer.Stop();
+			}
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void timer_Elapsed(object sender, ElapsedEventArgs e)
+		{
+			lock (timer) {
+				timer.Stop();
+				try {
+					if (from &gt; 0 &amp;&amp; !spring.IsRunning) {
+						var b = tas.GetBattle();
+						if (b != null) {
+							int plrCnt = b.CountPlayers();
+							if (plrCnt &gt;= from) {
+								List&lt;string&gt; notReady;
+
+								if (!ah.AllUniqueTeams(out notReady)) {
+									ah.ComFix(TasSayEventArgs.Default, new string[] {});
+									return;
+								}
+
+								bool isReady = ah.AllReadyAndSynced(out notReady);
+								if (plrCnt%2 == 0) {
+									int allyno;
+									if (!ah.BalancedTeams(out allyno)) {
+										//teams are not balanced but even number - fix colors and balance
+										ah.ComFixColors(TasSayEventArgs.Default, new string[] {});
+										ah.BalanceTeams(2, false);
+									}
+								}
+								if (isReady) {
+									Thread.Sleep(1000);
+									if (!spring.IsRunning) ah.ComStart(TasSayEventArgs.Default, new string[] {});
+								} else {
+									var now = DateTime.Now;
+
+									// we have enough people, but its odd number and server locked = unlock for more
+									if (plrCnt &gt; from &amp;&amp; plrCnt%2 == 1 &amp;&amp; b.IsLocked) ah.ComAutoLock(TasSayEventArgs.Default, new[] {(plrCnt + 1).ToString()});
+
+
+									if (plrCnt%2 == 0) {
+										// even number of players
+
+										if (now.Subtract(lastRing).TotalSeconds &gt; RingEvery) {
+											// we ring them
+											lastRing = now;
+											ah.ComRing(TasSayEventArgs.Default, new string[] {});
+										}
+
+										var worstTime = DateTime.MaxValue;
+										String worstName = &quot;&quot;;
+										foreach (var s in notReady) {
+											// find longest offending player
+											if (!problemSince.ContainsKey(s)) problemSince[s] = DateTime.Now;
+											if (problemSince[s] &lt; worstTime) {
+												worstTime = problemSince[s];
+												worstName = s;
+											}
+										}
+										foreach (var s in new List&lt;string&gt;(problemSince.Keys)) {
+											// delete not offending plaeyrs
+											if (!notReady.Contains(s)) problemSince.Remove(s);
+										}
+
+
+										if (now.Subtract(worstTime).TotalSeconds &gt; SpecForceAfter) ah.ComForceSpectator(TasSayEventArgs.Default, new[] {worstName}); // spec longest offending person
+										if (now.Subtract(worstTime).TotalSeconds &gt; KickAfter) ah.ComKick(TasSayEventArgs.Default, new[] {worstName}); // kick longest offending
+									} else {
+										// teams are not even delet offender list
+										problemSince.Clear();
+									}
+								}
+							} else {
+								// not enough players, make sure we unlock and clear offenders
+								if (b.IsLocked &amp;&amp; plrCnt &lt; from) ah.ComAutoLock(TasSayEventArgs.Default, new[] {to.ToString()});
+								problemSince.Clear();
+							}
+						}
+					} else {
+						// spring running, reset timer and delete offenders
+						lastRing = DateTime.Now;
+						problemSince.Clear();
+					}
+				} finally {
+					timer.Start();
+				}
+			}
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/BanList.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/BanList.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/BanList.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -6,211 +8,237 @@
 using System.Xml.Serialization;
 using Springie.Client;
 
+#endregion
+
 namespace Springie.autohost
 {
-  internal class BanList
-  {
-    public const string BanlistFilename = &quot;banlist.xml&quot;;
+	internal class BanList
+	{
+		#region Constants
 
-    private AutoHost ah;
-    public List&lt;BannedUser&gt; Items = new List&lt;BannedUser&gt;();
-    private TasClient tas;
+		public const string BanlistFilename = &quot;banlist.xml&quot;;
 
-    public BanList(AutoHost ah, TasClient tas)
-    {
-      this.tas = tas;
-      this.ah = ah;
+		#endregion
 
-      tas.BattleUserIpRecieved += new EventHandler&lt;TasEventArgs&gt;(tas_BattleUserIpRecieved);
-      tas.BattleUserJoined += new EventHandler&lt;TasEventArgs&gt;(tas_BattleUserJoined);
-    }
+		#region Fields
 
-    private void tas_BattleUserIpRecieved(object sender, TasEventArgs e)
-    {
-      UpdateWithUserIp(e.ServerParams[0], IPAddress.Parse(e.ServerParams[1]));
-      BannedUser b;
-      if (IsBanned(e.ServerParams[0], out b)) {
-        tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, e.ServerParams[0] + &quot; (&quot; + b.Name + &quot;) is banned for &quot; + b.Reason, true);
-        tas.Kick(e.ServerParams[0]);
-      }
-    }
+		private AutoHost ah;
+		private TasClient tas;
 
+		#endregion
 
-    public bool GetByIp(string ip, out BannedUser b)
-    {
-      b = Items.Find(delegate(BannedUser u) { return u.ipAddresses.Contains(ip); });
-      if (b != null) {
-        if (b.Expired) {
-          Items.Remove(b);
-          b = null;
-          return false;
-        } else return true;
-      } else return false;
-    }
+		#region Properties
 
-    public bool GetByName(string name, out BannedUser b)
-    {
-      b = Items.Find(delegate(BannedUser u) { return u.nickNames.Contains(name); });
-      if (b != null) {
-        if (b.Expired) {
-          Items.Remove(b);
-          b = null;
-          return false;
-        } else return true;
-      } else return false;
-    }
+		public List&lt;BannedUser&gt; Items = new List&lt;BannedUser&gt;();
 
-    public bool GetByNameOrIp(string name, string ip, out BannedUser b)
-    {
-      b = Items.Find(delegate(BannedUser bu) { return bu.nickNames.Contains(name) || bu.ipAddresses.Contains(ip); });
-      if (b != null) {
-        if (b.Expired) {
-          Items.Remove(b);
-          b = null;
-          return false;
-        } else return true;
-      } else return false;
-    }
+		#endregion
 
-    private void UpdateWithUserIp(string name, IPAddress ip)
-    {
-      BannedUser b;
-      if (GetByIp(ip.ToString(), out b)) if (!b.nickNames.Contains(name)) b.nickNames.Add(name);
-      if (GetByName(name, out b)) if (ip != IPAddress.None &amp;&amp; !b.ipAddresses.Contains(ip.ToString())) b.ipAddresses.Add(ip.ToString());
-      if (b != null) {
-        if (b.Expired) Items.Remove(b);
-        Save();
-      }
-    }
+		#region Constructors
 
-    public bool IsBanned(string name, out BannedUser b)
-    {
-      Battle bat = tas.GetBattle();
-      if (GetByName(name, out b)) return true;
-      if (bat != null) {
-        UserBattleStatus ubs;
-        if (bat.ContainsUser(name, out ubs)) {
-          string ip = ubs.ip.ToString();
-          if (GetByIp(ip, out b)) return true;
-        }
-      }
-      return false;
-    }
+		public BanList(AutoHost ah, TasClient tas)
+		{
+			this.tas = tas;
+			this.ah = ah;
 
-    public bool IsBanned(string name)
-    {
-      BannedUser b;
-      return IsBanned(name, out b);
-    }
+			tas.BattleUserIpRecieved += tas_BattleUserIpRecieved;
+			tas.BattleUserJoined += tas_BattleUserJoined;
+		}
 
+		#endregion
 
-    private void tas_BattleUserJoined(object sender, TasEventArgs e)
-    {
-      BannedUser b;
-      string usname = e.ServerParams[0];
+		#region Public methods
 
-      if (IsBanned(usname, out b)) {
-        tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, usname + &quot; (&quot; + b.Name + &quot;) is banned for &quot; + b.Reason, true);
-        tas.Kick(usname);
-      }
-    }
+		/// &lt;summary&gt;
+		/// Disconnects event handlers
+		/// &lt;/summary&gt;
+		public void Close()
+		{
+			tas.BattleUserJoined -= tas_BattleUserJoined;
+			tas.BattleUserIpRecieved -= tas_BattleUserIpRecieved;
+		}
 
+		public void ComBan(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				ah.Respond(e, &quot;this command needs at least 1 argument - exact user name&quot;);
+				return;
+			}
 
-    public void ComBan(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        ah.Respond(e, &quot;this command needs at least 1 argument - exact user name&quot;);
-        return;
-      }
+			int duration = 0;
+			if (words.Length &gt; 1) {
+				if (!int.TryParse(words[1], out duration)) {
+					ah.Respond(e, &quot;second argument must be a number - ban time in minutes or 0 - forever&quot;);
+					return;
+				}
+			}
 
-      int duration = 0;
-      if (words.Length &gt; 1) {
-        if (!int.TryParse(words[1], out duration)) {
-          ah.Respond(e, &quot;second argument must be a number - ban time in minutes or 0 - forever&quot;);
-          return;
-        }
-      }
+			if (IsBanned(words[0])) {
+				ah.Respond(e, &quot;this user is already banned&quot;);
+				return;
+			}
 
-      if (IsBanned(words[0])) {
-        ah.Respond(e, &quot;this user is already banned&quot;);
-        return;
-      }
+			if (duration &lt; 0) duration = 0;
+			TimeSpan dur;
+			if (duration == 0) dur = TimeSpan.FromDays(365*1000);
+			else dur = TimeSpan.FromMinutes(duration);
 
-      if (duration &lt; 0) duration = 0;
-      TimeSpan dur;
-      if (duration == 0) dur = TimeSpan.FromDays(365*1000);
-      else dur = TimeSpan.FromMinutes(duration);
+			var b = new BannedUser(words[0]);
+			b.Duration = dur;
+			b.Reason = Utils.Glue(words, 2);
 
-      BannedUser b = new BannedUser(words[0]);
-      b.Duration = dur;
-      b.Reason = Utils.Glue(words, 2);
+			var battle = tas.GetBattle();
+			UserBattleStatus ubs;
+			if (battle.ContainsUser(b.Name, out ubs)) if (ubs.ip != IPAddress.None) b.ipAddresses.Add(ubs.ip.ToString());
+			Items.Add(b);
+			tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, b.Name + &quot; banned - &quot; + b.Reason, true);
+			tas.Kick(b.Name);
+			Save();
+		}
 
-      Battle battle = tas.GetBattle();
-      UserBattleStatus ubs;
-      if (battle.ContainsUser(b.Name, out ubs)) if (ubs.ip != IPAddress.None) b.ipAddresses.Add(ubs.ip.ToString());
-      Items.Add(b);
-      tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, b.Name + &quot; banned - &quot; + b.Reason, true);
-      tas.Kick(b.Name);
-      Save();
-    }
+		public void ComListBans(TasSayEventArgs e, string[] words)
+		{
+			Items.RemoveAll(delegate(BannedUser b) { return b.Expired; });
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+			foreach (var b in Items) {
+				string text = String.Format(&quot;{0} --&gt; {1} (banned from:{2} to:{3} (GMT))&quot;, b.Name, b.Reason, b.Started.ToUniversalTime(), b.Started.Add(b.Duration).ToUniversalTime());
+				tas.Say(TasClient.SayPlace.User, e.UserName, text, false);
+			}
+			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+		}
 
+		public void ComUnban(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				ah.Respond(e, &quot;this command needs 1 argument - user name&quot;);
+				return;
+			}
+			BannedUser b;
+			if (IsBanned(words[0], out b)) {
+				Items.Remove(b);
+				ah.Respond(e, b.Name + &quot; removed from banlist&quot;);
+				Save();
+			} else ah.Respond(e, &quot;no such user in banlist&quot;);
+		}
 
-    public void ComUnban(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        ah.Respond(e, &quot;this command needs 1 argument - user name&quot;);
-        return;
-      }
-      BannedUser b;
-      if (IsBanned(words[0], out b)) {
-        Items.Remove(b);
-        ah.Respond(e, b.Name + &quot; removed from banlist&quot;);
-        Save();
-      } else ah.Respond(e, &quot;no such user in banlist&quot;);
-    }
 
+		public bool GetByIp(string ip, out BannedUser b)
+		{
+			b = Items.Find(delegate(BannedUser u) { return u.ipAddresses.Contains(ip); });
+			if (b != null) {
+				if (b.Expired) {
+					Items.Remove(b);
+					b = null;
+					return false;
+				} else return true;
+			} else return false;
+		}
 
-    public void ComListBans(TasSayEventArgs e, string[] words)
-    {
-      Items.RemoveAll(delegate(BannedUser b) { return b.Expired; });
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-      foreach (BannedUser b in Items) {
-        string text = String.Format(&quot;{0} --&gt; {1} (banned from:{2} to:{3} (GMT))&quot;, b.Name, b.Reason, b.Started.ToUniversalTime(), b.Started.Add(b.Duration).ToUniversalTime());
-        tas.Say(TasClient.SayPlace.User, e.UserName, text, false);
-      }
-      tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-    }
+		public bool GetByName(string name, out BannedUser b)
+		{
+			b = Items.Find(delegate(BannedUser u) { return u.nickNames.Contains(name); });
+			if (b != null) {
+				if (b.Expired) {
+					Items.Remove(b);
+					b = null;
+					return false;
+				} else return true;
+			} else return false;
+		}
 
+		public bool GetByNameOrIp(string name, string ip, out BannedUser b)
+		{
+			b = Items.Find(delegate(BannedUser bu) { return bu.nickNames.Contains(name) || bu.ipAddresses.Contains(ip); });
+			if (b != null) {
+				if (b.Expired) {
+					Items.Remove(b);
+					b = null;
+					return false;
+				} else return true;
+			} else return false;
+		}
 
-    public void Save()
-    {
-      Items.RemoveAll(delegate(BannedUser b) { return b.Expired; });
-      Items.Sort(delegate(BannedUser a, BannedUser b) { return a.Name.CompareTo(b.Name); });
-      XmlSerializer s = new XmlSerializer(Items.GetType());
-      FileStream f = File.OpenWrite(Application.StartupPath + '/' + BanlistFilename);
-      f.SetLength(0);
-      s.Serialize(f, Items);
-      f.Close();
-    }
+		public bool IsBanned(string name, out BannedUser b)
+		{
+			var bat = tas.GetBattle();
+			if (GetByName(name, out b)) return true;
+			if (bat != null) {
+				UserBattleStatus ubs;
+				if (bat.ContainsUser(name, out ubs)) {
+					string ip = ubs.ip.ToString();
+					if (GetByIp(ip, out b)) return true;
+				}
+			}
+			return false;
+		}
 
-    public void Load()
-    {
-      if (File.Exists(Application.StartupPath + '/' + BanlistFilename)) {
-        XmlSerializer s = new XmlSerializer(Items.GetType());
-        StreamReader r = File.OpenText(Application.StartupPath + '/' + BanlistFilename);
-        Items = (List&lt;BannedUser&gt;)s.Deserialize(r);
-        r.Close();
-      }
-    }
+		public bool IsBanned(string name)
+		{
+			BannedUser b;
+			return IsBanned(name, out b);
+		}
 
 
-    /// &lt;summary&gt;
-    /// Disconnects event handlers
-    /// &lt;/summary&gt;
-    public void Close()
-    {
-      tas.BattleUserJoined -= tas_BattleUserJoined;
-      tas.BattleUserIpRecieved -= tas_BattleUserIpRecieved;
-    }
-  }
+		public void Load()
+		{
+			if (File.Exists(Application.StartupPath + '/' + BanlistFilename)) {
+				var s = new XmlSerializer(Items.GetType());
+				var r = File.OpenText(Application.StartupPath + '/' + BanlistFilename);
+				Items = (List&lt;BannedUser&gt;) s.Deserialize(r);
+				r.Close();
+			}
+		}
+
+		public void Save()
+		{
+			Items.RemoveAll(delegate(BannedUser b) { return b.Expired; });
+			Items.Sort(delegate(BannedUser a, BannedUser b) { return a.Name.CompareTo(b.Name); });
+			var s = new XmlSerializer(Items.GetType());
+			var f = File.OpenWrite(Application.StartupPath + '/' + BanlistFilename);
+			f.SetLength(0);
+			s.Serialize(f, Items);
+			f.Close();
+		}
+
+		#endregion
+
+		#region Other methods
+
+		private void UpdateWithUserIp(string name, IPAddress ip)
+		{
+			BannedUser b;
+			if (GetByIp(ip.ToString(), out b)) if (!b.nickNames.Contains(name)) b.nickNames.Add(name);
+			if (GetByName(name, out b)) if (ip != IPAddress.None &amp;&amp; !b.ipAddresses.Contains(ip.ToString())) b.ipAddresses.Add(ip.ToString());
+			if (b != null) {
+				if (b.Expired) Items.Remove(b);
+				Save();
+			}
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void tas_BattleUserIpRecieved(object sender, TasEventArgs e)
+		{
+			UpdateWithUserIp(e.ServerParams[0], IPAddress.Parse(e.ServerParams[1]));
+			BannedUser b;
+			if (IsBanned(e.ServerParams[0], out b)) {
+				tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, e.ServerParams[0] + &quot; (&quot; + b.Name + &quot;) is banned for &quot; + b.Reason, true);
+				tas.Kick(e.ServerParams[0]);
+			}
+		}
+
+		private void tas_BattleUserJoined(object sender, TasEventArgs e)
+		{
+			BannedUser b;
+			string usname = e.ServerParams[0];
+
+			if (IsBanned(usname, out b)) {
+				tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, usname + &quot; (&quot; + b.Name + &quot;) is banned for &quot; + b.Reason, true);
+				tas.Kick(usname);
+			}
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/BannedUser.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/BannedUser.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/BannedUser.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
@@ -3,67 +5,67 @@
 using System.Xml.Serialization;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public class BannedUser
-  {
-    private TimeSpan duration;
-    public List&lt;string&gt; ipAddresses = new List&lt;string&gt;();
-    private string name;
-    public List&lt;string&gt; nickNames = new List&lt;string&gt;();
+	public class BannedUser
+	{
+		#region Fields
 
-    private string reason;
-    private DateTime started;
-    public BannedUser() {}
+		private TimeSpan duration;
 
-    public BannedUser(string name)
-    {
-      this.name = name;
-      started = DateTime.Now;
-      nickNames.Add(name);
-    }
+		#endregion
 
-    [Description(&quot;Original name&quot;)]
-    public string Name
-    {
-      get { return name; }
-      set { name = value; }
-    }
+		#region Properties
 
-    [Description(&quot;Reason of the ban&quot;)]
-    public string Reason
-    {
-      get { return reason; }
-      set { reason = value; }
-    }
+		[Description(&quot;Ban duration&quot;)]
+		[XmlIgnore]
+		public TimeSpan Duration
+		{
+			get { return duration; }
+			set { duration = value; }
+		}
 
+		[XmlIgnore]
+		public bool Expired
+		{
+			get { return (Started + Duration &lt; DateTime.Now); }
+		}
 
-    [Description(&quot;Ban duration&quot;)]
-    [XmlIgnore]
-    public TimeSpan Duration
-    {
-      get { return duration; }
-      set { duration = value; }
-    }
+		public List&lt;string&gt; ipAddresses = new List&lt;string&gt;();
 
-    [Browsable(false)]
-    public string XmlDuration
-    {
-      get { return duration.ToString(); }
-      set { duration = TimeSpan.Parse(value); }
-    }
+		[Description(&quot;Original name&quot;)]
+		public string Name { get; set; }
 
+		public List&lt;string&gt; nickNames = new List&lt;string&gt;();
 
-    [Description(&quot;Ban start time&quot;)]
-    public DateTime Started
-    {
-      get { return started; }
-      set { started = value; }
-    }
+		[Description(&quot;Reason of the ban&quot;)]
+		public string Reason { get; set; }
 
-    [XmlIgnore]
-    public bool Expired
-    {
-      get { return (Started + Duration &lt; DateTime.Now); }
-    }
-  }
+
+		[Description(&quot;Ban start time&quot;)]
+		public DateTime Started { get; set; }
+
+		[Browsable(false)]
+		public string XmlDuration
+		{
+			get { return duration.ToString(); }
+			set { duration = TimeSpan.Parse(value); }
+		}
+
+		#endregion
+
+		#region Constructors
+
+		public BannedUser() {}
+
+		public BannedUser(string name)
+		{
+			this.Name = name;
+			Started = DateTime.Now;
+			nickNames.Add(name);
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/CommandConfig.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/CommandConfig.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/CommandConfig.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.ComponentModel;
 using System.Xml.Serialization;
@@ -3,80 +5,70 @@
 using Springie.Client;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public class CommandConfig
-  {
-    private string helpText;
+	public class CommandConfig
+	{
+		#region Fields
 
-    [XmlIgnore]
-    public DateTime lastCall = DateTime.Now;
+		private TasSayEventArgs.Places[] listenTo = new[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Normal};
 
-    private int level;
+		#endregion
 
+		#region Properties
 
-    private TasSayEventArgs.Places[] listenTo = new TasSayEventArgs.Places[] {TasSayEventArgs.Places.Battle, TasSayEventArgs.Places.Normal};
-    private string name;
-    private int throttling = 0;
+		[Category(&quot;Texts&quot;)]
+		[Description(&quot;Help text to be displayed in !help listings.&quot;)]
+		public string HelpText { get; set; }
 
+		[XmlIgnore]
+		public DateTime lastCall = DateTime.Now;
 
-    public CommandConfig() {}
+		[Category(&quot;Command&quot;)]
+		[Description(&quot;Rights level. If user's rights level is higher or equal to rights level of command - user has rights to use this command.&quot;)]
+		public int Level { get; set; }
 
+		[Category(&quot;Command&quot;)]
+		[Description(&quot;From which places can you use this command. Normal = PM to server, Battle = battle lobby, Game = from running game.&quot;)]
+		public TasSayEventArgs.Places[] ListenTo
+		{
+			get { return listenTo; }
+			set { listenTo = value; }
+		}
 
-    public CommandConfig(string name, int level, string helpText, int throttling, TasSayEventArgs.Places[] listenTo) : this(name, level, helpText, throttling)
-    {
-      this.listenTo = listenTo;
-    }
+		[ReadOnly(true)]
+		[Category(&quot;Command&quot;)]
+		public string Name { get; set; }
 
-    public CommandConfig(string name, int level, string helpText, int throttling) : this(name, level, helpText)
-    {
-      this.throttling = throttling;
-    }
+		[Category(&quot;Command&quot;)]
+		[Description(&quot;How often can this command be executed (in seconds). 0 = no throttling, can execute at any time.&quot;)]
+		public int Throttling { get; set; }
 
-    public CommandConfig(string name, int level, string helpText)
-    {
-      this.name = name;
-      this.level = level;
-      this.helpText = helpText;
-    }
+		#endregion
 
-    [ReadOnly(true)]
-    [Category(&quot;Command&quot;)]
-    public string Name
-    {
-      get { return name; }
-      set { name = value; }
-    }
+		#region Constructors
 
-    [Category(&quot;Command&quot;)]
-    [Description(&quot;Rights level. If user's rights level is higher or equal to rights level of command - user has rights to use this command.&quot;)]
-    public int Level
-    {
-      get { return level; }
-      set { level = value; }
-    }
+		public CommandConfig() {}
 
-    [Category(&quot;Texts&quot;)]
-    [Description(&quot;Help text to be displayed in !help listings.&quot;)]
-    public string HelpText
-    {
-      get { return helpText; }
-      set { helpText = value; }
-    }
 
-    [Category(&quot;Command&quot;)]
-    [Description(&quot;How often can this command be executed (in seconds). 0 = no throttling, can execute at any time.&quot;)]
-    public int Throttling
-    {
-      get { return throttling; }
-      set { throttling = value; }
-    }
+		public CommandConfig(string name, int level, string helpText, int throttling, TasSayEventArgs.Places[] listenTo) : this(name, level, helpText, throttling)
+		{
+			this.listenTo = listenTo;
+		}
 
-    [Category(&quot;Command&quot;)]
-    [Description(&quot;From which places can you use this command. Normal = PM to server, Battle = battle lobby, Game = from running game.&quot;)]
-    public TasSayEventArgs.Places[] ListenTo
-    {
-      get { return listenTo; }
-      set { listenTo = value; }
-    }
-  } ;
+		public CommandConfig(string name, int level, string helpText, int throttling) : this(name, level, helpText)
+		{
+			this.Throttling = throttling;
+		}
+
+		public CommandConfig(string name, int level, string helpText)
+		{
+			this.Name = name;
+			this.Level = level;
+			this.HelpText = helpText;
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/Ladder.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/Ladder.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/Ladder.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,111 +1,137 @@
-&#65279;using System.Collections.Generic;
+&#65279;#region using
+
+using System.Collections.Generic;
 using System.Net;
 using Springie.Client;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public class Ladder
-  {
-    private const string ladderUrl = &quot;<A HREF="http://blendax.informatik.uni-bremen.de/jan/spring/ladder/lobby/">http://blendax.informatik.uni-bremen.de/jan/spring/ladder/lobby/</A>&quot;;
-    private int ladderId;
+	public class Ladder
+	{
+		#region Constants
 
-    private List&lt;string&gt; maps = new List&lt;string&gt;();
+		private const string ladderUrl = &quot;<A HREF="http://blendax.informatik.uni-bremen.de/jan/spring/ladder/lobby/">http://blendax.informatik.uni-bremen.de/jan/spring/ladder/lobby/</A>&quot;;
 
-    private string[] rules;
+		#endregion
 
+		#region Fields
 
-    public Ladder(int id)
-    {
-      ladderId = id;
-      LoadMapList();
-      LoadRules();
-    }
+		private int ladderId;
 
-    public List&lt;string&gt; Maps
-    {
-      get { return maps; }
-    }
+		private List&lt;string&gt; maps = new List&lt;string&gt;();
 
-    public int Id
-    {
-      get { return ladderId; }
-    }
+		private string[] rules;
 
-    private void LoadMapList()
-    {
-      WebClient wc = new WebClient();
-      try {
-        string lines = wc.DownloadString(ladderUrl + &quot;maplist.php?ladder=&quot; + ladderId);
-        maps.Clear();
-        foreach (string line in lines.Split('\n')) maps.Add(line.ToLower());
-      } catch {}
-      ;
-    }
+		#endregion
 
+		#region Properties
 
-    private void LoadRules()
-    {
-      try {
-        WebClient wc = new WebClient();
-        wc.UseDefaultCredentials = true;
-        string lines = wc.DownloadString(ladderUrl + &quot;rules.php?ladder=&quot; + ladderId);
-        rules = lines.Split('\n');
-      } catch {}
-      ;
-    }
+		public int Id
+		{
+			get { return ladderId; }
+		}
 
+		public List&lt;string&gt; Maps
+		{
+			get { return maps; }
+		}
 
-    public BattleDetails CheckBattleDetails(BattleDetails battleDetailsOriginal, out int minTeamPlayers, out int maxTeamPlayers)
-    {
-      minTeamPlayers = 1;
-      maxTeamPlayers = 8;
-      BattleDetails battleDetails;
-      if (battleDetailsOriginal != null) battleDetails = (BattleDetails)battleDetailsOriginal.Clone();
-      else battleDetails = new BattleDetails();
+		#endregion
 
-      foreach (string line in rules) {
-        string[] args = line.Split(' ');
-        string key = args[0];
-        string val = Utils.Glue(args, 1);
+		#region Constructors
 
-        if (key == &quot;min_players_per_allyteam&quot;) minTeamPlayers = int.Parse(val);
-        if (key == &quot;max_players_per_allyteam&quot;) maxTeamPlayers = int.Parse(val);
-        if (key == &quot;startpos&quot;) if (val != &quot;any&quot;) battleDetails.StartPos = (BattleStartPos)int.Parse(val);
-        if (key == &quot;gamemode&quot;) if (val != &quot;any&quot;) battleDetails.EndCondition = (BattleEndCondition)int.Parse(val);
-        if (key == &quot;dgun&quot;) if (val != &quot;any&quot;) battleDetails.LimitDgun = int.Parse(val);
-        if (key == &quot;ghost&quot;) if (val != &quot;any&quot;) battleDetails.GhostedBuildings = int.Parse(val);
-        if (key == &quot;diminish&quot;) if (val != &quot;any&quot;) battleDetails.DiminishingMM = int.Parse(val);
-        if (key == &quot;metal&quot;) {
-          if (val != &quot;any&quot;) {
-            int min = int.Parse(args[1]);
-            int max = int.Parse(args[2]);
-            if (battleDetails.StartingMetal &lt; min) battleDetails.StartingMetal = min;
-            if (battleDetails.StartingMetal &gt; max) battleDetails.StartingMetal = max;
-          }
-        }
-        if (key == &quot;energy&quot;) {
-          if (val != &quot;any&quot;) {
-            int min = int.Parse(args[1]);
-            int max = int.Parse(args[2]);
-            if (battleDetails.StartingEnergy &lt; min) battleDetails.StartingEnergy = min;
-            if (battleDetails.StartingEnergy &gt; max) battleDetails.StartingEnergy = max;
-          }
-        }
+		public Ladder(int id)
+		{
+			ladderId = id;
+			LoadMapList();
+			LoadRules();
+		}
 
-        if (key == &quot;units&quot;) {
-          if (val != &quot;any&quot;) {
-            int min = int.Parse(args[1]);
-            int max = int.Parse(args[2]);
-            if (battleDetails.MaxUnits &lt; min) battleDetails.MaxUnits = min;
-            if (battleDetails.MaxUnits &gt; max) battleDetails.MaxUnits = max;
-          }
-        }
-      }
-      return battleDetails;
-    }
+		#endregion
 
+		#region Public methods
 
-    /*private static GetLadderList() {
+		public BattleDetails CheckBattleDetails(BattleDetails battleDetailsOriginal, out int minTeamPlayers, out int maxTeamPlayers)
+		{
+			minTeamPlayers = 1;
+			maxTeamPlayers = 8;
+			BattleDetails battleDetails;
+			if (battleDetailsOriginal != null) battleDetails = (BattleDetails) battleDetailsOriginal.Clone();
+			else battleDetails = new BattleDetails();
+
+			foreach (var line in rules) {
+				var args = line.Split(' ');
+				string key = args[0];
+				string val = Utils.Glue(args, 1);
+
+				if (key == &quot;min_players_per_allyteam&quot;) minTeamPlayers = int.Parse(val);
+				if (key == &quot;max_players_per_allyteam&quot;) maxTeamPlayers = int.Parse(val);
+				if (key == &quot;startpos&quot;) if (val != &quot;any&quot;) battleDetails.StartPos = (BattleStartPos) int.Parse(val);
+				if (key == &quot;gamemode&quot;) if (val != &quot;any&quot;) battleDetails.EndCondition = (BattleEndCondition) int.Parse(val);
+				if (key == &quot;dgun&quot;) if (val != &quot;any&quot;) battleDetails.LimitDgun = int.Parse(val);
+				if (key == &quot;ghost&quot;) if (val != &quot;any&quot;) battleDetails.GhostedBuildings = int.Parse(val);
+				if (key == &quot;diminish&quot;) if (val != &quot;any&quot;) battleDetails.DiminishingMM = int.Parse(val);
+				if (key == &quot;metal&quot;) {
+					if (val != &quot;any&quot;) {
+						int min = int.Parse(args[1]);
+						int max = int.Parse(args[2]);
+						if (battleDetails.StartingMetal &lt; min) battleDetails.StartingMetal = min;
+						if (battleDetails.StartingMetal &gt; max) battleDetails.StartingMetal = max;
+					}
+				}
+				if (key == &quot;energy&quot;) {
+					if (val != &quot;any&quot;) {
+						int min = int.Parse(args[1]);
+						int max = int.Parse(args[2]);
+						if (battleDetails.StartingEnergy &lt; min) battleDetails.StartingEnergy = min;
+						if (battleDetails.StartingEnergy &gt; max) battleDetails.StartingEnergy = max;
+					}
+				}
+
+				if (key == &quot;units&quot;) {
+					if (val != &quot;any&quot;) {
+						int min = int.Parse(args[1]);
+						int max = int.Parse(args[2]);
+						if (battleDetails.MaxUnits &lt; min) battleDetails.MaxUnits = min;
+						if (battleDetails.MaxUnits &gt; max) battleDetails.MaxUnits = max;
+					}
+				}
+			}
+			return battleDetails;
+		}
+
+		#endregion
+
+		#region Other methods
+
+		private void LoadMapList()
+		{
+			var wc = new WebClient();
+			try {
+				string lines = wc.DownloadString(ladderUrl + &quot;maplist.php?ladder=&quot; + ladderId);
+				maps.Clear();
+				foreach (var line in lines.Split('\n')) maps.Add(line.ToLower());
+			} catch {}
+			;
+		}
+
+
+		private void LoadRules()
+		{
+			try {
+				var wc = new WebClient();
+				wc.UseDefaultCredentials = true;
+				string lines = wc.DownloadString(ladderUrl + &quot;rules.php?ladder=&quot; + ladderId);
+				rules = lines.Split('\n');
+			} catch {}
+			;
+		}
+
+		#endregion
+
+		/*private static GetLadderList() {
       WebClient wc = new WebClient();
       try {
         string lines = wc.DownloadString(&quot;ladderlist.php&quot;);
@@ -119,5 +145,5 @@
         }
       } catch { };
     }*/
-  }
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/Polls.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/Polls.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/Polls.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System.Collections.Generic;
 using Springie.Client;
 using Springie.SpringNamespace;
@@ -2,549 +4,782 @@
 
+#endregion
+
 namespace Springie.autohost
 {
-  public interface IVotable
-  {
-    bool Init(TasSayEventArgs e, string[] words);
-    void TimeEnd();
-    bool Vote(TasSayEventArgs e, string[] words);
-  }
+	public interface IVotable
+	{
+		#region Public methods
 
-  public abstract class AbstractPoll
-  {
-    protected const double ratio = 0.5;
-    protected AutoHost ah;
-    protected int initialUserCount = 0;
-    protected int lastVote = -1; // last registered vote value
-    protected int options = 2;
-    protected Spring spring;
-    protected TasClient tas;
-    protected int defaultWinVote = 1;
-    protected bool hackEndTimeVote = false;
+		bool Init(TasSayEventArgs e, string[] words);
+		void TimeEnd();
+		bool Vote(TasSayEventArgs e, string[] words);
 
-    protected List&lt;string&gt; users = new List&lt;string&gt;();
-    protected List&lt;int&gt; votes = new List&lt;int&gt;();
+		#endregion
+	}
 
-    public AbstractPoll() {}
+	public abstract class AbstractPoll
+	{
+		#region Constants
 
-    public AbstractPoll(TasClient tas, Spring spring, AutoHost ah)
-    {
-      this.tas = tas;
-      this.spring = spring;
-      this.ah = ah;
+		protected const double ratio = 0.5;
 
-      initialUserCount = 0;
-      Battle b = tas.GetBattle();
-      if (b != null) {
-        foreach (UserBattleStatus us in b.Users) {
-          if (us.name != tas.UserName) {
-            users.Add(us.name);
-            votes.Add(0);
-            if (!us.IsSpectator) initialUserCount++;
-          }
-        }
-      }
-    }
+		#endregion
 
-    public virtual void TimeEnd()
-    {
-      hackEndTimeVote = true;
-      int vote;
-      IVotable iv = this as IVotable;
-      if (iv != null) iv.Vote(TasSayEventArgs.Default, new string[] {});
-    }
+		#region Fields
 
-    protected bool CheckEnd(out int winVote)
-    {
-      int[] sums = new int[options];
-      foreach (int val in votes) if (val &gt; 0 &amp;&amp; val &lt;= options) sums[val - 1]++;
+		protected AutoHost ah;
+		protected int defaultWinVote = 1;
+		protected bool hackEndTimeVote;
+		protected int initialUserCount;
+		protected int lastVote = -1; // last registered vote value
+		protected int options = 2;
+		protected Spring spring;
+		protected TasClient tas;
 
-      int votesLeft = votes.FindAll(delegate(int t) { return (t == 0); }).Count;
-      bool canDecide = false;
-      int winLimit = (int)(initialUserCount*ratio);
+		protected List&lt;string&gt; users = new List&lt;string&gt;();
+		protected List&lt;int&gt; votes = new List&lt;int&gt;();
 
-      int max = 0;
-      int maxCount = 0;
-      for (int i = 0; i &lt; sums.Length; ++i) if (sums[i] &gt; max) max = sums[i];
-      for (int i = 0; i &lt; sums.Length; ++i) if (sums[i] == max) maxCount++;
+		#endregion
 
-      for (int i = 0; i &lt; sums.Length; ++i) {
-        string text = string.Format(&quot;option {0} has {1} of {2} votes&quot;, i + 1, sums[i], winLimit + 1);
+		#region Constructors
 
-        if (!hackEndTimeVote &amp;&amp; i + 1 == lastVote) ah.SayBattle(text);
+		public AbstractPoll() {}
 
-        if (sums[i] &gt; winLimit) {
-          winVote = i + 1;
-          return true;
-        }
-        if (hackEndTimeVote &amp;&amp; sums[i] &gt;= 2 &amp;&amp; sums[i] == max &amp;&amp; maxCount == 1) {
-          winVote = i + 1;
-          return true;
-        }
+		public AbstractPoll(TasClient tas, Spring spring, AutoHost ah)
+		{
+			this.tas = tas;
+			this.spring = spring;
+			this.ah = ah;
 
-        if (sums[i] + votesLeft &gt; winLimit) canDecide = true;
-      }
-      winVote = 0;
-      if (!canDecide) return true;
-      else return false;
-    }
+			initialUserCount = 0;
+			var b = tas.GetBattle();
+			if (b != null) {
+				foreach (var us in b.Users) {
+					if (us.name != tas.UserName) {
+						users.Add(us.name);
+						votes.Add(0);
+						if (!us.IsSpectator) initialUserCount++;
+					}
+				}
+			}
+		}
 
-    protected bool RegisterVote(TasSayEventArgs e, string[] words, out int vote)
-    {
-      vote = 0;
-      if (hackEndTimeVote) return true;
-      if (words.Length != 1) return false;
-      int.TryParse(words[0], out vote);
-      if (vote &gt; 0 &amp;&amp; vote &lt;= options) {
-        // vote within parameters, lets register it
-        lastVote = vote;
+		#endregion
 
-        int ind = users.IndexOf(e.UserName);
-        Battle b = tas.GetBattle();
-        if (b != null) {
-          int bidx = b.GetUserIndex(e.UserName);
-          if (bidx &gt; -1) if (b.Users[bidx].IsSpectator) return false;
-          if (ind == -1) {
-            votes.Add(vote);
-            users.Add(e.UserName);
-          } else votes[ind] = vote;
-          return true;
-        }
-      }
-      return false;
-    }
-  } ;
+		#region Public methods
 
-  public class VoteMap : AbstractPoll, IVotable
-  {
-    private string map;
+		public virtual void TimeEnd()
+		{
+			hackEndTimeVote = true;
+			int vote;
+			var iv = this as IVotable;
+			if (iv != null) iv.Vote(TasSayEventArgs.Default, new string[] {});
+		}
 
-    public VoteMap(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+		#endregion
 
-    #region IVotable Members
-    bool IVotable.Init(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        AutoHost.Respond(tas, spring, e, &quot;You must specify map name&quot;);
-        return false;
-      }
+		#region Other methods
 
-      string[] vals;
-      int[] indexes;
-      if (ah.FilterMaps(words, out vals, out indexes) &gt; 0) {
-        map = vals[0];
-        ah.SayBattle(&quot;Do you want to change map to &quot; + map + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;Cannot find such map&quot;);
-        return false;
-      }
-    }
+		protected bool CheckEnd(out int winVote)
+		{
+			var sums = new int[options];
+			foreach (var val in votes) if (val &gt; 0 &amp;&amp; val &lt;= options) sums[val - 1]++;
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+			int votesLeft = votes.FindAll(delegate(int t) { return (t == 0); }).Count;
+			bool canDecide = false;
+			int winLimit = (int) (initialUserCount*ratio);
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - changing map to &quot; + map);
-          tas.ChangeMap(spring.UnitSync.MapList[map]);
-        } else ah.SayBattle(&quot;not enough votes, map stays&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+			int max = 0;
+			int maxCount = 0;
+			for (int i = 0; i &lt; sums.Length; ++i) if (sums[i] &gt; max) max = sums[i];
+			for (int i = 0; i &lt; sums.Length; ++i) if (sums[i] == max) maxCount++;
 
-  public class VoteKick : AbstractPoll, IVotable
-  {
-    private new const double ratio = 0.66;
-    private string player;
+			for (int i = 0; i &lt; sums.Length; ++i) {
+				string text = string.Format(&quot;option {0} has {1} of {2} votes&quot;, i + 1, sums[i], winLimit + 1);
 
-    public VoteKick(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+				if (!hackEndTimeVote &amp;&amp; i + 1 == lastVote) ah.SayBattle(text);
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        AutoHost.Respond(tas, spring, e, &quot;You must specify player name&quot;);
-        return false;
-      }
+				if (sums[i] &gt; winLimit) {
+					winVote = i + 1;
+					return true;
+				}
+				if (hackEndTimeVote &amp;&amp; sums[i] &gt;= 2 &amp;&amp; sums[i] == max &amp;&amp; maxCount == 1) {
+					winVote = i + 1;
+					return true;
+				}
 
-      string[] players;
-      int[] indexes;
-      if (AutoHost.FilterUsers(words, tas, spring, out players, out indexes) &gt; 0) {
-        player = players[0];
-        ah.SayBattle(&quot;Do you want to kick &quot; + player + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;Cannot find such player&quot;);
-        return false;
-      }
-    }
+				if (sums[i] + votesLeft &gt; winLimit) canDecide = true;
+			}
+			winVote = 0;
+			if (!canDecide) return true;
+			else return false;
+		}
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		protected bool RegisterVote(TasSayEventArgs e, string[] words, out int vote)
+		{
+			vote = 0;
+			if (hackEndTimeVote) return true;
+			if (words.Length != 1) return false;
+			int.TryParse(words[0], out vote);
+			if (vote &gt; 0 &amp;&amp; vote &lt;= options) {
+				// vote within parameters, lets register it
+				lastVote = vote;
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - kicking &quot; + player);
-          ah.ComKick(TasSayEventArgs.Default, new string[] {player});
-        } else ah.SayBattle(&quot;not enough votes, player stays&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+				int ind = users.IndexOf(e.UserName);
+				var b = tas.GetBattle();
+				if (b != null) {
+					int bidx = b.GetUserIndex(e.UserName);
+					if (bidx &gt; -1) if (b.Users[bidx].IsSpectator) return false;
+					if (ind == -1) {
+						votes.Add(vote);
+						users.Add(e.UserName);
+					} else votes[ind] = vote;
+					return true;
+				}
+			}
+			return false;
+		}
 
-  public class VoteForce : AbstractPoll, IVotable
-  {
-    private new const double ratio = 0.50;
+		#endregion
+	} ;
 
-    public VoteForce(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+	public class VoteMap : AbstractPoll, IVotable
+	{
+		#region Fields
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (spring.IsRunning) {
-        ah.SayBattle(&quot;Do you want to force game? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;battle not started yet&quot;);
-        return false;
-      }
-    }
+		private string map;
 
+		#endregion
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		#region Constructors
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.ComForce(e, words);
-          ah.SayBattle(&quot;vote successful - forcing&quot;);
-        } else ah.SayBattle(&quot;not enough votes&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+		public VoteMap(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
 
-  public class VoteForceStart : AbstractPoll, IVotable
-  {
-    private new const double ratio = 0.50;
+		#endregion
 
-    public VoteForceStart(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+		#region IVotable Members
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (!spring.IsRunning) {
-        ah.SayBattle(&quot;Do you want to force start game? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;battle already started&quot;);
-        return false;
-      }
-    }
+		bool IVotable.Init(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				AutoHost.Respond(tas, spring, e, &quot;You must specify map name&quot;);
+				return false;
+			}
 
+			string[] vals;
+			int[] indexes;
+			if (ah.FilterMaps(words, out vals, out indexes) &gt; 0) {
+				map = vals[0];
+				ah.SayBattle(&quot;Do you want to change map to &quot; + map + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;Cannot find such map&quot;);
+				return false;
+			}
+		}
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - force starting&quot;);
-          ah.ComForceStart(e, words);
-        } else ah.SayBattle(&quot;not enough votes&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - changing map to &quot; + map);
+					tas.ChangeMap(spring.UnitSync.MapList[map]);
+				} else ah.SayBattle(&quot;not enough votes, map stays&quot;);
+				return true;
+			} else return false;
+		}
 
-  public class VoteExit : AbstractPoll, IVotable
-  {
-    private new const double ratio = 0.66;
+		#endregion
+	}
 
-    public VoteExit(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+	public class VoteKick : AbstractPoll, IVotable
+	{
+		#region Constants
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (spring.IsRunning) {
-        ah.SayBattle(&quot;Do you want to exit this game? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;game not running&quot;);
-        return false;
-      }
-    }
+		private new const double ratio = 0.66;
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		#endregion
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - force exiting&quot;);
-          ah.ComExit(e, words);
-        } else ah.SayBattle(&quot;not enough votes&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+		#region Fields
 
-  public class VoteRehost : AbstractPoll, IVotable
-  {
-    private new const double ratio = 0.66;
-    private string modname = &quot;&quot;;
+		private string player;
 
-    public VoteRehost(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+		#endregion
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        ah.SayBattle(&quot;Do you want to rehost this game? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        string[] mods;
-        int[] indexes;
-        if (AutoHost.FilterMods(words, tas, spring, out mods, out indexes) == 0) {
-          AutoHost.Respond(tas, spring, e, &quot;cannot find such mod&quot;);
-          return false;
-        } else {
-          modname = mods[0];
-          ah.SayBattle(&quot;Do you want to rehost this game to &quot; + modname + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
-          return true;
-        }
-      }
-    }
+		#region Constructors
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		public VoteKick(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - rehosting&quot;);
+		#endregion
 
-          ah.ComRehost(e, new string[] {modname});
-        } else ah.SayBattle(&quot;not enough votes&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+		#region IVotable Members
 
-  public class VotePreset : AbstractPoll, IVotable
-  {
-    private int presetId;
-    private string presetName;
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				AutoHost.Respond(tas, spring, e, &quot;You must specify player name&quot;);
+				return false;
+			}
 
-    public VotePreset(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+			string[] players;
+			int[] indexes;
+			if (AutoHost.FilterUsers(words, tas, spring, out players, out indexes) &gt; 0) {
+				player = players[0];
+				ah.SayBattle(&quot;Do you want to kick &quot; + player + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;Cannot find such player&quot;);
+				return false;
+			}
+		}
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        AutoHost.Respond(tas, spring, e, &quot;You must specify preset name&quot;);
-        return false;
-      }
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
 
-      string[] vals;
-      int[] indexes;
-      if (AutoHost.FilterPresets(words, ah, out vals, out indexes) &gt; 0) {
-        presetId = indexes[0];
-        presetName = vals[0];
-        ah.SayBattle(&quot;Do you want to apply preset &quot; + presetName + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;cannot find such preset&quot;);
-        return false;
-      }
-    }
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - kicking &quot; + player);
+					ah.ComKick(TasSayEventArgs.Default, new[] {player});
+				} else ah.SayBattle(&quot;not enough votes, player stays&quot;);
+				return true;
+			} else return false;
+		}
 
+		#endregion
+	}
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+	public class VoteForce : AbstractPoll, IVotable
+	{
+		#region Constants
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - appling preset &quot; + presetName);
-          ah.presets[presetId].Apply(tas, ah.ladder);
-        } else ah.SayBattle(&quot;not enough votes for preset&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+		private new const double ratio = 0.50;
 
-  public class VoteKickSpec : AbstractPoll, IVotable
-  {
-    private bool stateAfter = false;
-    public VoteKickSpec(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+		#endregion
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      stateAfter = !ah.KickSpectators;
-      ah.SayBattle(&quot;Do you want to &quot; + (stateAfter ? &quot;ENABLE&quot; : &quot;DISABLE&quot;) + &quot; spectator kicking? !vote 1 = yes, !vote 2 = no&quot;);
-      return true;
-    }
+		#region Constructors
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		public VoteForce(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful&quot;);
-          ah.ComKickSpec(e, new string[] {stateAfter ? &quot;1&quot; : &quot;0&quot;});
-        } else ah.SayBattle(&quot;not enough votes to &quot; + (stateAfter ? &quot;ENABLE&quot; : &quot;DISABLE&quot;) + &quot; kickspec&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+		#endregion
 
-  public class VoteBoss : AbstractPoll, IVotable
-  {
-    private string player;
+		#region IVotable Members
 
-    //new const double ratio = 0.50;
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (spring.IsRunning) {
+				ah.SayBattle(&quot;Do you want to force game? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;battle not started yet&quot;);
+				return false;
+			}
+		}
 
-    public VoteBoss(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      if (words.Length == 0) {
-        if (ah.BossName == &quot;&quot;) {
-          ah.Respond(e, &quot;there is currently no boss to remove&quot;);
-          return false;
-        } else {
-          player = &quot;&quot;;
-          ah.SayBattle(&quot;Do you want to remove current boss &quot; + ah.BossName + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
-          return true;
-        }
-      }
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
 
-      string[] players;
-      int[] indexes;
-      if (AutoHost.FilterUsers(words, tas, spring, out players, out indexes) &gt; 0) {
-        player = players[0];
-        ah.SayBattle(&quot;Do you want to elect &quot; + player + &quot; for the boss? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      } else {
-        AutoHost.Respond(tas, spring, e, &quot;Cannot find such player&quot;);
-        return false;
-      }
-    }
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.ComForce(e, words);
+					ah.SayBattle(&quot;vote successful - forcing&quot;);
+				} else ah.SayBattle(&quot;not enough votes&quot;);
+				return true;
+			} else return false;
+		}
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		#endregion
+	}
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          if (player == &quot;&quot;) ah.SayBattle(&quot;vote successful - boss removed&quot;);
-          else ah.SayBattle(&quot;vote successful - new boss is &quot; + player);
-          ah.BossName = player;
-        } else ah.SayBattle(&quot;not enough votes&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+	public class VoteForceStart : AbstractPoll, IVotable
+	{
+		#region Constants
 
-  public class VoteSetOptions : AbstractPoll, IVotable
-  {
-    private string scriptTagsFormat;
-    private string wordFormat;
+		private new const double ratio = 0.50;
 
-    public VoteSetOptions(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+		#endregion
 
-    #region IVotable Members
-    public bool Init(TasSayEventArgs e, string[] words)
-    {
-      wordFormat = Utils.Glue(words);
-      scriptTagsFormat = ah.GetOptionsString(e, words);
-      if (scriptTagsFormat == &quot;&quot;) return false;
-      else {
-        ah.SayBattle(&quot;Do you want to apply options &quot; + wordFormat + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
-        return true;
-      }
-    }
+		#region Constructors
 
+		public VoteForceStart(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
 
-    public bool Vote(TasSayEventArgs e, string[] words)
-    {
-      int vote;
-      if (!RegisterVote(e, words, out vote)) {
-        AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
-        return false;
-      }
+		#endregion
 
-      int winVote;
-      if (CheckEnd(out winVote)) {
-        if (winVote == 1) {
-          ah.SayBattle(&quot;vote successful - appling options &quot; + wordFormat);
-          tas.SetScriptTag(scriptTagsFormat);
-        } else ah.SayBattle(&quot;not enough votes for setoptions&quot;);
-        return true;
-      } else return false;
-    }
-    #endregion
-  }
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (!spring.IsRunning) {
+				ah.SayBattle(&quot;Do you want to force start game? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;battle already started&quot;);
+				return false;
+			}
+		}
+
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - force starting&quot;);
+					ah.ComForceStart(e, words);
+				} else ah.SayBattle(&quot;not enough votes&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+	public class VoteExit : AbstractPoll, IVotable
+	{
+		#region Constants
+
+		private new const double ratio = 0.66;
+
+		#endregion
+
+		#region Constructors
+
+		public VoteExit(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+
+		#endregion
+
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (spring.IsRunning) {
+				ah.SayBattle(&quot;Do you want to exit this game? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;game not running&quot;);
+				return false;
+			}
+		}
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - force exiting&quot;);
+					ah.ComExit(e, words);
+				} else ah.SayBattle(&quot;not enough votes&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+	public class VoteRehost : AbstractPoll, IVotable
+	{
+		#region Constants
+
+		private new const double ratio = 0.66;
+
+		#endregion
+
+		#region Fields
+
+		private string modname = &quot;&quot;;
+
+		#endregion
+
+		#region Constructors
+
+		public VoteRehost(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+
+		#endregion
+
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				ah.SayBattle(&quot;Do you want to rehost this game? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				string[] mods;
+				int[] indexes;
+				if (AutoHost.FilterMods(words, tas, spring, out mods, out indexes) == 0) {
+					AutoHost.Respond(tas, spring, e, &quot;cannot find such mod&quot;);
+					return false;
+				} else {
+					modname = mods[0];
+					ah.SayBattle(&quot;Do you want to rehost this game to &quot; + modname + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
+					return true;
+				}
+			}
+		}
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - rehosting&quot;);
+
+					ah.ComRehost(e, new[] {modname});
+				} else ah.SayBattle(&quot;not enough votes&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+	public class VotePreset : AbstractPoll, IVotable
+	{
+		#region Fields
+
+		private int presetId;
+		private string presetName;
+
+		#endregion
+
+		#region Constructors
+
+		public VotePreset(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+
+		#endregion
+
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				AutoHost.Respond(tas, spring, e, &quot;You must specify preset name&quot;);
+				return false;
+			}
+
+			string[] vals;
+			int[] indexes;
+			if (AutoHost.FilterPresets(words, ah, out vals, out indexes) &gt; 0) {
+				presetId = indexes[0];
+				presetName = vals[0];
+				ah.SayBattle(&quot;Do you want to apply preset &quot; + presetName + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;cannot find such preset&quot;);
+				return false;
+			}
+		}
+
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - appling preset &quot; + presetName);
+					ah.presets[presetId].Apply(tas, ah.ladder);
+				} else ah.SayBattle(&quot;not enough votes for preset&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+	public class VoteKickSpec : AbstractPoll, IVotable
+	{
+		#region Fields
+
+		private bool stateAfter;
+
+		#endregion
+
+		#region Constructors
+
+		public VoteKickSpec(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+
+		#endregion
+
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			stateAfter = !ah.KickSpectators;
+			ah.SayBattle(&quot;Do you want to &quot; + (stateAfter ? &quot;ENABLE&quot; : &quot;DISABLE&quot;) + &quot; spectator kicking? !vote 1 = yes, !vote 2 = no&quot;);
+			return true;
+		}
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful&quot;);
+					ah.ComKickSpec(e, new[] {stateAfter ? &quot;1&quot; : &quot;0&quot;});
+				} else ah.SayBattle(&quot;not enough votes to &quot; + (stateAfter ? &quot;ENABLE&quot; : &quot;DISABLE&quot;) + &quot; kickspec&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+	public class VoteBoss : AbstractPoll, IVotable
+	{
+		#region Fields
+
+		private string player;
+
+		#endregion
+
+		//new const double ratio = 0.50;
+
+		#region Constructors
+
+		public VoteBoss(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+
+		#endregion
+
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				if (ah.BossName == &quot;&quot;) {
+					ah.Respond(e, &quot;there is currently no boss to remove&quot;);
+					return false;
+				} else {
+					player = &quot;&quot;;
+					ah.SayBattle(&quot;Do you want to remove current boss &quot; + ah.BossName + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
+					return true;
+				}
+			}
+
+			string[] players;
+			int[] indexes;
+			if (AutoHost.FilterUsers(words, tas, spring, out players, out indexes) &gt; 0) {
+				player = players[0];
+				ah.SayBattle(&quot;Do you want to elect &quot; + player + &quot; for the boss? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;Cannot find such player&quot;);
+				return false;
+			}
+		}
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					if (player == &quot;&quot;) ah.SayBattle(&quot;vote successful - boss removed&quot;);
+					else ah.SayBattle(&quot;vote successful - new boss is &quot; + player);
+					ah.BossName = player;
+				} else ah.SayBattle(&quot;not enough votes&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+	public class VoteSetOptions : AbstractPoll, IVotable
+	{
+		#region Fields
+
+		private string scriptTagsFormat;
+		private string wordFormat;
+
+		#endregion
+
+		#region Constructors
+
+		public VoteSetOptions(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah) {}
+
+		#endregion
+
+		#region IVotable Members
+
+		public bool Init(TasSayEventArgs e, string[] words)
+		{
+			wordFormat = Utils.Glue(words);
+			scriptTagsFormat = ah.GetOptionsString(e, words);
+			if (scriptTagsFormat == &quot;&quot;) return false;
+			else {
+				ah.SayBattle(&quot;Do you want to apply options &quot; + wordFormat + &quot;? !vote 1 = yes, !vote 2 = no&quot;);
+				return true;
+			}
+		}
+
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			if (!RegisterVote(e, words, out vote)) {
+				AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+				return false;
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - appling options &quot; + wordFormat);
+					tas.SetScriptTag(scriptTagsFormat);
+				} else ah.SayBattle(&quot;not enough votes for setoptions&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
+
+
+	public class VotePlanet : AbstractPoll, IVotable
+	{
+		#region Fields
+
+		private string faction;
+		private string planet;
+
+		#endregion
+
+		#region Constructors
+
+		public VotePlanet(TasClient tas, Spring spring, AutoHost ah) : base(tas, spring, ah)
+		{
+			this.tas = tas;
+			this.spring = spring;
+			this.ah = ah;
+
+			var pw = Program.main.PlanetWars;
+			var fact = pw.GetOffensiveFaction();
+			faction = fact.Name;
+
+			users.Clear();
+			votes.Clear();
+
+			initialUserCount = 0;
+			var b = tas.GetBattle();
+			if (b != null) {
+				foreach (var us in b.Users) {
+					if (us.name != tas.UserName &amp;&amp; !us.IsSpectator &amp;&amp; pw.GetPlayerInfo(us.name).FactionName == faction) {
+						users.Add(us.name);
+						votes.Add(0);
+						initialUserCount++;
+					}
+				}
+			}
+		}
+
+		#endregion
+
+		#region IVotable Members
+
+		bool IVotable.Init(TasSayEventArgs e, string[] words)
+		{
+			if (words.Length == 0) {
+				AutoHost.Respond(tas, spring, e, &quot;You must specify planet name&quot;);
+				return false;
+			}
+			string[] vals;
+			int[] indexes;
+			if (ah.FilterPlanets(words, out vals, out indexes) &gt; 0) {
+				planet = vals[0];
+				ah.SayBattle(string.Format(&quot;Do you want to change planet to {0}? !vote 1 = yes, !vote 2 = no&quot;, planet));
+				return true;
+			} else {
+				AutoHost.Respond(tas, spring, e, &quot;Cannot find such planet&quot;);
+				return false;
+			}
+		}
+
+		public bool Vote(TasSayEventArgs e, string[] words)
+		{
+			int vote;
+			var pw = Program.main.PlanetWars;
+
+
+			if (e.UserName != &quot;&quot;) {
+				// this is needed due to &quot;timeout&quot; hackthing with vote
+				var info = pw.GetPlayerInfo(e.UserName);
+
+				if (info == null || info.FactionName != faction) {
+					AutoHost.Respond(tas, spring, e, string.Format(&quot;{0}, it's not your faction's turn&quot;, e.UserName));
+					return false;
+				}
+
+				if (!RegisterVote(e, words, out vote)) {
+					AutoHost.Respond(tas, spring, e, &quot;You must vote valid option/not be a spectator&quot;);
+					return false;
+				}
+			}
+
+			int winVote;
+			if (CheckEnd(out winVote)) {
+				if (winVote == 1) {
+					ah.SayBattle(&quot;vote successful - changing planet to &quot; + planet);
+					var sel = pw.GetAttackOptions().Find((p) =&gt; p.Name == planet);
+					tas.ChangeMap(spring.UnitSync.MapList[sel.MapName]);
+				} else ah.SayBattle(&quot;not enough votes, planet stays&quot;);
+				return true;
+			} else return false;
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/Preset.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/Preset.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/Preset.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System.ComponentModel;
 using Springie.Client;
 using Springie.SpringNamespace;
@@ -2,173 +4,183 @@
 
+#endregion
+
 namespace Springie.autohost
 {
-  public class Preset
-  {
-    private string description;
-    private int? diminishingMM;
-    private UnitInfo[] disabledUnits = new UnitInfo[0];
-    private bool enableAllUnits = false;
-    private BattleEndCondition? endCondition;
-    private int? ghostedBuildings;
-    private int? limitDgun;
-    private int? maxUnits;
-    private string name = &quot;&lt;enter name here&gt;&quot;;
-    private string[] perform = new string[0];
-    private int? startingEnergy;
-    private int? startingMetal;
-    private BattleStartPos? startPos;
+	public class Preset
+	{
+		#region Fields
 
-    [Category(&quot;Basic&quot;)]
-    [Description(&quot;Name of this preset&quot;)]
-    public string Name
-    {
-      set { name = value; }
-      get { return name; }
-    }
+		private int? diminishingMM;
+		private UnitInfo[] disabledUnits = new UnitInfo[0];
+		private bool enableAllUnits;
+		private BattleEndCondition? endCondition;
+		private int? ghostedBuildings;
+		private int? limitDgun;
+		private int? maxUnits;
+		private string name = &quot;&lt;enter name here&gt;&quot;;
+		private string[] perform = new string[0];
+		private int? startingEnergy;
+		private int? startingMetal;
+		private BattleStartPos? startPos;
 
+		#endregion
 
-    [Category(&quot;Basic&quot;)]
-    [Description(&quot;Brief description of this preset&quot;)]
-    public string Description
-    {
-      get { return description; }
-      set { description = value; }
-    }
+		#region Properties
 
-    [Category(&quot;Basic&quot;)]
-    [Description(&quot;List of additional commands to be performed&quot;)]
-    public string[] Perform
-    {
-      set { perform = value; }
-      get { return perform; }
-    }
+		[Category(&quot;Basic&quot;)]
+		[Description(&quot;Brief description of this preset&quot;)]
+		public string Description { get; set; }
 
-    [Category(&quot;Resources&quot;)]
-    [Description(&quot;Starting metal&quot;)]
-    public int? StartingMetal
-    {
-      get { return startingMetal; }
-      set { startingMetal = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Diminishing metal maker outputs, 0 = normal mm, 1 = diminishing mm&quot;)]
+		public int? DiminishingMM
+		{
+			get { return diminishingMM; }
+			set { diminishingMM = value; }
+		}
 
-    [Category(&quot;Resources&quot;)]
-    [Description(&quot;Starting energy&quot;)]
-    public int? StartingEnergy
-    {
-      get { return startingEnergy; }
-      set { startingEnergy = value; }
-    }
+		[Category(&quot;Units&quot;)]
+		[Description(&quot;Units to disable&quot;)]
+		public UnitInfo[] DisabledUnits
+		{
+			get { return disabledUnits; }
+			set { disabledUnits = value; }
+		}
 
-    [Category(&quot;Resources&quot;)]
-    [Description(&quot;Maximum units&quot;)]
-    public int? MaxUnits
-    {
-      get { return maxUnits; }
-      set { maxUnits = value; }
-    }
+		[Category(&quot;Units&quot;)]
+		[Description(&quot;Should this preset enable all units before disabling&quot;)]
+		public bool EnableAllUnits
+		{
+			get { return enableAllUnits; }
+			set { enableAllUnits = value; }
+		}
 
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;End condition - should continue when comm dies&quot;)]
+		public BattleEndCondition? EndCondition
+		{
+			get { return endCondition; }
+			set { endCondition = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Starting position&quot;)]
-    public BattleStartPos? StartPos
-    {
-      get { return startPos; }
-      set { startPos = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Ghosted buildings, 0 = no ghosted buildings, 1 = ghosted buildings&quot;)]
+		public int? GhostedBuildings
+		{
+			get { return ghostedBuildings; }
+			set { ghostedBuildings = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;End condition - should continue when comm dies&quot;)]
-    public BattleEndCondition? EndCondition
-    {
-      get { return endCondition; }
-      set { endCondition = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Limit dgun to start position, 0 = no limit, 1 = limited&quot;)]
+		public int? LimitDgun
+		{
+			get { return limitDgun; }
+			set { limitDgun = value; }
+		}
 
+		[Category(&quot;Resources&quot;)]
+		[Description(&quot;Maximum units&quot;)]
+		public int? MaxUnits
+		{
+			get { return maxUnits; }
+			set { maxUnits = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Limit dgun to start position, 0 = no limit, 1 = limited&quot;)]
-    public int? LimitDgun
-    {
-      get { return limitDgun; }
-      set { limitDgun = value; }
-    }
+		[Category(&quot;Basic&quot;)]
+		[Description(&quot;Name of this preset&quot;)]
+		public string Name
+		{
+			set { name = value; }
+			get { return name; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Diminishing metal maker outputs, 0 = normal mm, 1 = diminishing mm&quot;)]
-    public int? DiminishingMM
-    {
-      get { return diminishingMM; }
-      set { diminishingMM = value; }
-    }
+		[Category(&quot;Basic&quot;)]
+		[Description(&quot;List of additional commands to be performed&quot;)]
+		public string[] Perform
+		{
+			set { perform = value; }
+			get { return perform; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Ghosted buildings, 0 = no ghosted buildings, 1 = ghosted buildings&quot;)]
-    public int? GhostedBuildings
-    {
-      get { return ghostedBuildings; }
-      set { ghostedBuildings = value; }
-    }
+		[Category(&quot;Resources&quot;)]
+		[Description(&quot;Starting energy&quot;)]
+		public int? StartingEnergy
+		{
+			get { return startingEnergy; }
+			set { startingEnergy = value; }
+		}
 
+		[Category(&quot;Resources&quot;)]
+		[Description(&quot;Starting metal&quot;)]
+		public int? StartingMetal
+		{
+			get { return startingMetal; }
+			set { startingMetal = value; }
+		}
 
-    [Category(&quot;Units&quot;)]
-    [Description(&quot;Should this preset enable all units before disabling&quot;)]
-    public bool EnableAllUnits
-    {
-      get { return enableAllUnits; }
-      set { enableAllUnits = value; }
-    }
 
-    [Category(&quot;Units&quot;)]
-    [Description(&quot;Units to disable&quot;)]
-    public UnitInfo[] DisabledUnits
-    {
-      get { return disabledUnits; }
-      set { disabledUnits = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Starting position&quot;)]
+		public BattleStartPos? StartPos
+		{
+			get { return startPos; }
+			set { startPos = value; }
+		}
 
-    public void Apply(TasClient tas, Ladder ladder)
-    {
-      Battle b = tas.GetBattle();
-      if (b == null) return;
-      BattleDetails d = b.Details;
+		#endregion
 
-      if (startingMetal.HasValue) d.StartingMetal = startingMetal.Value;
-      if (startingEnergy.HasValue) d.StartingEnergy = startingEnergy.Value;
-      if (maxUnits.HasValue) d.MaxUnits = maxUnits.Value;
-      if (startPos.HasValue) d.StartPos = startPos.Value;
-      if (endCondition.HasValue) d.EndCondition = endCondition.Value;
-      if (limitDgun.HasValue) d.LimitDgun = limitDgun.Value;
-      if (diminishingMM.HasValue) d.DiminishingMM = diminishingMM.Value;
-      if (ghostedBuildings.HasValue) d.GhostedBuildings = ghostedBuildings.Value;
+		#region Public methods
 
-      d.Validate();
-      int mint, maxt;
-      if (ladder != null) d = ladder.CheckBattleDetails(d, out mint, out maxt);
-      tas.UpdateBattleDetails(d);
+		public void Apply(TasClient tas, Ladder ladder)
+		{
+			var b = tas.GetBattle();
+			if (b == null) return;
+			var d = b.Details;
 
-      if (enableAllUnits) tas.EnableAllUnits();
-      if (disabledUnits.Length &gt; 0) tas.DisableUnits(UnitInfo.ToStringList(disabledUnits));
+			if (startingMetal.HasValue) d.StartingMetal = startingMetal.Value;
+			if (startingEnergy.HasValue) d.StartingEnergy = startingEnergy.Value;
+			if (maxUnits.HasValue) d.MaxUnits = maxUnits.Value;
+			if (startPos.HasValue) d.StartPos = startPos.Value;
+			if (endCondition.HasValue) d.EndCondition = endCondition.Value;
+			if (limitDgun.HasValue) d.LimitDgun = limitDgun.Value;
+			if (diminishingMM.HasValue) d.DiminishingMM = diminishingMM.Value;
+			if (ghostedBuildings.HasValue) d.GhostedBuildings = ghostedBuildings.Value;
 
-      foreach (string s in perform) tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, s, false);
-    }
+			d.Validate();
+			int mint, maxt;
+			if (ladder != null) d = ladder.CheckBattleDetails(d, out mint, out maxt);
+			tas.UpdateBattleDetails(d);
 
-    public override string ToString()
-    {
-      string ret = &quot;&quot;;
+			if (enableAllUnits) tas.EnableAllUnits();
+			if (disabledUnits.Length &gt; 0) tas.DisableUnits(UnitInfo.ToStringList(disabledUnits));
 
-      if (startingMetal.HasValue) ret += &quot;metal: &quot; + startingMetal.Value + &quot;\n&quot;;
-      if (startingEnergy.HasValue) ret += &quot;energy: &quot; + startingEnergy.Value + &quot;\n&quot;;
-      if (maxUnits.HasValue) ret += &quot;units: &quot; + maxUnits.Value + &quot;\n&quot;;
-      if (startPos.HasValue) ret += &quot;start position: &quot; + startPos.Value + &quot;\n&quot;;
-      if (endCondition.HasValue) ret += &quot;comm end: &quot; + endCondition.Value + &quot;\n&quot;;
-      if (limitDgun.HasValue) ret += &quot;limit dgun: &quot; + limitDgun.Value + &quot;\n&quot;;
-      if (diminishingMM.HasValue) ret += &quot;diminishing mm: &quot; + diminishingMM.Value + &quot;\n&quot;;
-      if (ghostedBuildings.HasValue) ret += &quot;ghosted buildings: &quot; + ghostedBuildings.Value + &quot;\n&quot;;
+			foreach (var s in perform) tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, s, false);
+		}
 
-      for (int i = 0; i &lt; disabledUnits.Length; ++i) ret += &quot;Disable &quot; + disabledUnits[i].Name + &quot; (&quot; + disabledUnits[i].FullName + &quot;)\n&quot;;
+		#endregion
 
-      if (ret == &quot;&quot;) ret = &quot;no changes&quot;;
-      return ret;
-    }
-  }
+		#region Overrides
+
+		public override string ToString()
+		{
+			string ret = &quot;&quot;;
+
+			if (startingMetal.HasValue) ret += &quot;metal: &quot; + startingMetal.Value + &quot;\n&quot;;
+			if (startingEnergy.HasValue) ret += &quot;energy: &quot; + startingEnergy.Value + &quot;\n&quot;;
+			if (maxUnits.HasValue) ret += &quot;units: &quot; + maxUnits.Value + &quot;\n&quot;;
+			if (startPos.HasValue) ret += &quot;start position: &quot; + startPos.Value + &quot;\n&quot;;
+			if (endCondition.HasValue) ret += &quot;comm end: &quot; + endCondition.Value + &quot;\n&quot;;
+			if (limitDgun.HasValue) ret += &quot;limit dgun: &quot; + limitDgun.Value + &quot;\n&quot;;
+			if (diminishingMM.HasValue) ret += &quot;diminishing mm: &quot; + diminishingMM.Value + &quot;\n&quot;;
+			if (ghostedBuildings.HasValue) ret += &quot;ghosted buildings: &quot; + ghostedBuildings.Value + &quot;\n&quot;;
+
+			for (int i = 0; i &lt; disabledUnits.Length; ++i) ret += &quot;Disable &quot; + disabledUnits[i].Name + &quot; (&quot; + disabledUnits[i].FullName + &quot;)\n&quot;;
+
+			if (ret == &quot;&quot;) ret = &quot;no changes&quot;;
+			return ret;
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/autohost/PrivilegedUser.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/autohost/PrivilegedUser.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/autohost/PrivilegedUser.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,34 +1,35 @@
+#region using
+
 using System.ComponentModel;
 
+#endregion
+
 namespace Springie.autohost
 {
-  public class PrivilegedUser
-  {
-    private int level;
-    private string name;
+	public class PrivilegedUser
+	{
+		#region Properties
 
-    public PrivilegedUser() {}
+		[Category(&quot;User&quot;)]
+		[Description(&quot;Rights level. If rights level is higher or equal to rights level of command - user has rights to use that command.&quot;)]
+		public int Level { get; set; }
 
-    public PrivilegedUser(string name, int level)
-    {
-      this.name = name;
-      this.level = level;
-    }
+		[Category(&quot;User&quot;)]
+		[Description(&quot;Nickname used in spring lobby&quot;)]
+		public string Name { get; set; }
 
-    [Category(&quot;User&quot;)]
-    [Description(&quot;Nickname used in spring lobby&quot;)]
-    public string Name
-    {
-      get { return name; }
-      set { name = value; }
-    }
+		#endregion
 
-    [Category(&quot;User&quot;)]
-    [Description(&quot;Rights level. If rights level is higher or equal to rights level of command - user has rights to use that command.&quot;)]
-    public int Level
-    {
-      get { return level; }
-      set { level = value; }
-    }
-  } ;
+		#region Constructors
+
+		public PrivilegedUser() {}
+
+		public PrivilegedUser(string name, int level)
+		{
+			this.Name = name;
+			this.Level = level;
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/Battle.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/Battle.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/Battle.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using Springie.SpringNamespace;
@@ -2,210 +4,258 @@
 
+#endregion
+
 namespace Springie.Client
 {
-  public class Battle : ICloneable
-  {
-    #region NatMode enum
-    public enum NatMode : int
-    {
-      None = 0,
-      HolePunching = 1,
-      FixedPorts = 2
-    } ;
-    #endregion
+	public class Battle : ICloneable
+	{
+		#region NatMode enum
 
-    public BattleDetails Details = new BattleDetails();
-    public List&lt;string&gt; DisabledUnits = new List&lt;string&gt;();
-    public int HostPort;
-    public bool IsLocked = false;
-    public MapInfo Map;
-    public int MaxPlayers;
-    public ModInfo Mod;
-    public Dictionary&lt;string, string&gt; ModOptions = new Dictionary&lt;string, string&gt;();
-    public NatMode Nat = NatMode.None;
-    public string Password = &quot;*&quot;;
-    public int Rank;
-    public Dictionary&lt;int, BattleRect&gt; Rectangles = new Dictionary&lt;int, BattleRect&gt;();
-    public string Title;
+		public enum NatMode
+		{
+			None = 0,
+			HolePunching = 1,
+			FixedPorts = 2
+		} ;
 
-    public List&lt;UserBattleStatus&gt; Users = new List&lt;UserBattleStatus&gt;();
-    public List&lt;BotBattleStatus&gt; Bots = new List&lt;BotBattleStatus&gt;();
+		#endregion
 
-    public Battle(string password, int port, int maxplayers, int rank, MapInfo map, string title, ModInfo mod, BattleDetails details)
-    {
-      if (!String.IsNullOrEmpty(password)) Password = password;
-      else Password = &quot;*&quot;;
-      if (port == 0) HostPort = 8452;
-      else HostPort = port;
-      MaxPlayers = maxplayers;
-      Rank = rank;
-      Map = map;
-      Title = title;
-      Mod = mod;
-      if (details != null) Details = details;
-      else details = new BattleDetails();
-      details.Validate();
-    }
+		#region Properties
 
-    #region ICloneable Members
-    public object Clone()
-    {
-      Battle b = (Battle)MemberwiseClone();
-      if (Details != null) b.Details = (BattleDetails)Details.Clone();
-      if (Users != null) b.Users = new List&lt;UserBattleStatus&gt;(Users);
-      if (Rectangles != null) b.Rectangles = new Dictionary&lt;int, BattleRect&gt;(Rectangles);
+		public List&lt;BotBattleStatus&gt; Bots = new List&lt;BotBattleStatus&gt;();
 
-      if (DisabledUnits != null) b.DisabledUnits = new List&lt;string&gt;(DisabledUnits);
-      return b;
-    }
-    #endregion
+		public BattleDetails Details = new BattleDetails();
+		public List&lt;string&gt; DisabledUnits = new List&lt;string&gt;();
+		public int HostPort;
+		public bool IsLocked;
+		public MapInfo Map;
+		public int MaxPlayers;
+		public ModInfo Mod;
+		public Dictionary&lt;string, string&gt; ModOptions = new Dictionary&lt;string, string&gt;();
+		public NatMode Nat = NatMode.None;
+		public string Password = &quot;*&quot;;
+		public int Rank;
+		public Dictionary&lt;int, BattleRect&gt; Rectangles = new Dictionary&lt;int, BattleRect&gt;();
+		public string Title;
 
-    public int GetFirstEmptyRectangle()
-    {
-      for (int i = 0; i &lt; Spring.MaxAllies; ++i) if (!Rectangles.ContainsKey(i)) return i;
-      return -1;
-    }
+		public List&lt;UserBattleStatus&gt; Users = new List&lt;UserBattleStatus&gt;();
 
-    public bool ContainsUser(string name)
-    {
-      foreach (UserBattleStatus u in Users) if (u.name == name) return true;
-      return false;
-    }
+		#endregion
 
-    public bool ContainsUser(string name, out UserBattleStatus retu)
-    {
-      foreach (UserBattleStatus u in Users) {
-        if (u.name == name) {
-          retu = u;
-          return true;
-        }
-      }
-      retu = new UserBattleStatus();
-      return false;
-    }
+		#region Constructors
 
-    public void RemoveUser(string name)
-    {
-      int ret = GetUserIndex(name);
-      if (ret != -1) Users.RemoveAt(ret);
-    }
+		public Battle(string password, int port, int maxplayers, int rank, MapInfo map, string title, ModInfo mod, BattleDetails details)
+		{
+			if (!String.IsNullOrEmpty(password)) Password = password;
+			else Password = &quot;*&quot;;
+			if (port == 0) HostPort = 8452;
+			else HostPort = port;
+			MaxPlayers = maxplayers;
+			Rank = rank;
+			Map = map;
+			Title = title;
+			Mod = mod;
+			if (details != null) Details = details;
+			else details = new BattleDetails();
+			details.Validate();
+		}
 
+		#endregion
 
-    public int GetUserIndex(string name)
-    {
-      for (int i = 0; i &lt; Users.Count; ++i) if (Users[i].name == name) return i;
-      return -1;
-    }
+		#region Public methods
 
-    public int CountSpectators()
-    {
-      int speccount = 0;
-      foreach (UserBattleStatus u in Users) if (u.IsSpectator) speccount++;
-      return speccount;
-    }
+		public bool ContainsUser(string name)
+		{
+			foreach (var u in Users) if (u.name == name) return true;
+			return false;
+		}
 
-    /// &lt;summary&gt;
-    /// count players - non spectators
-    /// &lt;/summary&gt;
-    /// &lt;returns&gt;returns number of players that will play the game&lt;/returns&gt;
-    public int CountPlayers()
-    {
-      int speccount = 0;
-      foreach (UserBattleStatus u in Users) if (!u.IsSpectator) speccount++;
-      return speccount;
-    }
+		public bool ContainsUser(string name, out UserBattleStatus retu)
+		{
+			foreach (var u in Users) {
+				if (u.name == name) {
+					retu = u;
+					return true;
+				}
+			}
+			retu = new UserBattleStatus();
+			return false;
+		}
 
-    /// &lt;summary&gt;
-    /// Groups tam and ally numbers, so that they both start from 0
-    /// &lt;/summary&gt;
-    public void GroupData(out List&lt;GrPlayer&gt; players, out List&lt;GrTeam&gt; teams, out List&lt;GrAlly&gt; alliances)
-    {
-      Dictionary&lt;int, int&gt; teamNums = new Dictionary&lt;int, int&gt;();
-      Dictionary&lt;int, int&gt; allyNums = new Dictionary&lt;int, int&gt;();
+		/// &lt;summary&gt;
+		/// count players - non spectators
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;returns number of players that will play the game&lt;/returns&gt;
+		public int CountPlayers()
+		{
+			int speccount = 0;
+			foreach (var u in Users) if (!u.IsSpectator) speccount++;
+			return speccount;
+		}
 
-      players = new List&lt;GrPlayer&gt;();
-      teams = new List&lt;GrTeam&gt;();
-      alliances = new List&lt;GrAlly&gt;();
+		public int CountSpectators()
+		{
+			int speccount = 0;
+			foreach (var u in Users) if (u.IsSpectator) speccount++;
+			return speccount;
+		}
 
-      foreach (UserBattleStatus p in Users) {
-        UserBattleStatus u = (UserBattleStatus)p.Clone();
+		public int GetFirstEmptyRectangle()
+		{
+			for (int i = 0; i &lt; Spring.MaxAllies; ++i) if (!Rectangles.ContainsKey(i)) return i;
+			return -1;
+		}
 
-        if (!u.IsSpectator) {
-          if (!teamNums.ContainsKey(u.TeamNumber)) {
-            teamNums.Add(u.TeamNumber, teams.Count); // add transformation of team
-            teams.Add(new GrTeam(players.Count));
-          }
-          u.TeamNumber = teamNums[u.TeamNumber];
+		public int GetUserIndex(string name)
+		{
+			for (int i = 0; i &lt; Users.Count; ++i) if (Users[i].name == name) return i;
+			return -1;
+		}
 
-          if (!allyNums.ContainsKey(u.AllyNumber)) {
-            allyNums.Add(u.AllyNumber, alliances.Count); // add transformation of ally
-            alliances.Add(new GrAlly());
-          }
-          u.AllyNumber = allyNums[u.AllyNumber];
-        }
-        players.Add(new GrPlayer(u));
-      }
+		/// &lt;summary&gt;
+		/// Groups tam and ally numbers, so that they both start from 0
+		/// &lt;/summary&gt;
+		public void GroupData(out List&lt;GrPlayer&gt; players, out List&lt;GrTeam&gt; teams, out List&lt;GrAlly&gt; alliances)
+		{
+			var teamNums = new Dictionary&lt;int, int&gt;();
+			var allyNums = new Dictionary&lt;int, int&gt;();
 
-      foreach (BotBattleStatus p in Bots) {
-        BotBattleStatus u = (BotBattleStatus)p.Clone();
+			players = new List&lt;GrPlayer&gt;();
+			teams = new List&lt;GrTeam&gt;();
+			alliances = new List&lt;GrAlly&gt;();
 
-        if (!teamNums.ContainsKey(u.TeamNumber)) {
-          teamNums.Add(u.TeamNumber, teams.Count); // add transformation of team
-          int leader = 0;
-          for (leader =0; leader &lt; players.Count; ++leader) if (players[leader].user.name == u.owner) break;
-          GrTeam gr = new GrTeam(leader);
-          gr.bot = u;
-          teams.Add(gr);
-        }
-        u.TeamNumber = teamNums[u.TeamNumber];
+			foreach (var p in Users) {
+				var u = (UserBattleStatus) p.Clone();
 
-        if (!allyNums.ContainsKey(u.AllyNumber)) {
-          allyNums.Add(u.AllyNumber, alliances.Count); // add transformation of ally
-          alliances.Add(new GrAlly());
-        }
-        u.AllyNumber = allyNums[u.AllyNumber];
-      }
+				if (!u.IsSpectator) {
+					if (!teamNums.ContainsKey(u.TeamNumber)) {
+						teamNums.Add(u.TeamNumber, teams.Count); // add transformation of team
+						teams.Add(new GrTeam(players.Count));
+					}
+					u.TeamNumber = teamNums[u.TeamNumber];
 
+					if (!allyNums.ContainsKey(u.AllyNumber)) {
+						allyNums.Add(u.AllyNumber, alliances.Count); // add transformation of ally
+						alliances.Add(new GrAlly());
+					}
+					u.AllyNumber = allyNums[u.AllyNumber];
+				}
+				players.Add(new GrPlayer(u));
+			}
 
-      // now assign rectangles and skip unused
-      foreach (KeyValuePair&lt;int, BattleRect&gt; r in Rectangles) if (allyNums.ContainsKey(r.Key)) alliances[allyNums[r.Key]] = new GrAlly(r.Value);
-    }
+			foreach (var p in Bots) {
+				var u = (BotBattleStatus) p.Clone();
 
-    #region Nested type: GrAlly
-    public struct GrAlly
-    {
-      public BattleRect rect;
+				if (!teamNums.ContainsKey(u.TeamNumber)) {
+					teamNums.Add(u.TeamNumber, teams.Count); // add transformation of team
+					int leader = 0;
+					for (leader = 0; leader &lt; players.Count; ++leader) if (players[leader].user.name == u.owner) break;
+					var gr = new GrTeam(leader);
+					gr.bot = u;
+					teams.Add(gr);
+				}
+				u.TeamNumber = teamNums[u.TeamNumber];
 
-      public GrAlly(BattleRect r)
-      {
-        rect = r;
-      }
-    } ;
-    #endregion
+				if (!allyNums.ContainsKey(u.AllyNumber)) {
+					allyNums.Add(u.AllyNumber, alliances.Count); // add transformation of ally
+					alliances.Add(new GrAlly());
+				}
+				u.AllyNumber = allyNums[u.AllyNumber];
+			}
 
-    #region Nested type: GrPlayer
-    public struct GrPlayer
-    {
-      public UserBattleStatus user;
 
-      public GrPlayer(UserBattleStatus ubs)
-      {
-        user = ubs;
-      }
-    } ;
-    #endregion
+			// now assign rectangles and skip unused
+			foreach (var r in Rectangles) if (allyNums.ContainsKey(r.Key)) alliances[allyNums[r.Key]] = new GrAlly(r.Value);
+		}
 
-    #region Nested type: GrTeam
-    public struct GrTeam
-    {
-      public int leader;
-      public BotBattleStatus bot;
+		public void RemoveUser(string name)
+		{
+			int ret = GetUserIndex(name);
+			if (ret != -1) Users.RemoveAt(ret);
+		}
 
-      public GrTeam(int leader)
-      {
-        this.bot = null;
-        this.leader = leader;
-      }
-    } ;
-    #endregion
-  } ;
+		#endregion
+
+		#region ICloneable Members
+
+		public object Clone()
+		{
+			var b = (Battle) MemberwiseClone();
+			if (Details != null) b.Details = (BattleDetails) Details.Clone();
+			if (Users != null) b.Users = new List&lt;UserBattleStatus&gt;(Users);
+			if (Rectangles != null) b.Rectangles = new Dictionary&lt;int, BattleRect&gt;(Rectangles);
+
+			if (DisabledUnits != null) b.DisabledUnits = new List&lt;string&gt;(DisabledUnits);
+			return b;
+		}
+
+		#endregion
+
+		#region Nested type: GrAlly
+
+		public struct GrAlly
+		{
+			#region Properties
+
+			public BattleRect rect;
+
+			#endregion
+
+			#region Constructors
+
+			public GrAlly(BattleRect r)
+			{
+				rect = r;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+
+		#region Nested type: GrPlayer
+
+		public struct GrPlayer
+		{
+			#region Properties
+
+			public UserBattleStatus user;
+
+			#endregion
+
+			#region Constructors
+
+			public GrPlayer(UserBattleStatus ubs)
+			{
+				user = ubs;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+
+		#region Nested type: GrTeam
+
+		public struct GrTeam
+		{
+			#region Properties
+
+			public BotBattleStatus bot;
+			public int leader;
+
+			#endregion
+
+			#region Constructors
+
+			public GrTeam(int leader)
+			{
+				bot = null;
+				this.leader = leader;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/BattleDetails.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/BattleDetails.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/BattleDetails.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
@@ -3,182 +5,202 @@
 using System.Globalization;
 
+#endregion
+
 namespace Springie.Client
 {
-  public enum BattleStartPos : int
-  {
-    Fixed = 0,
-    Random = 1,
-    Choose = 2
-  }
+	public enum BattleStartPos
+	{
+		Fixed = 0,
+		Random = 1,
+		Choose = 2
+	}
 
-  public enum BattleEndCondition : int
-  {
-    Continues = 0,
-    Ends = 1,
-    Lineage = 2
-  }
+	public enum BattleEndCondition
+	{
+		Continues = 0,
+		Ends = 1,
+		Lineage = 2
+	}
 
-  [TypeConverter(typeof(BattleDetailsConverter))]
-  public class BattleDetails : ICloneable
-  {
-    public static BattleDetails Default = new BattleDetails();
-    private int diminishingMM = 0;
-    private BattleEndCondition endCondition = BattleEndCondition.Continues;
-    private int ghostedBuildings = 1;
-    private int limitDgun = 0;
-    private int maxUnits = 1000;
-    private int startingEnergy = 1000;
+	[TypeConverter(typeof (BattleDetailsConverter))]
+	public class BattleDetails : ICloneable
+	{
+		#region Fields
 
-    private int startingMetal = 1000;
-    private BattleStartPos startPos = BattleStartPos.Choose;
+		private int diminishingMM;
+		private BattleEndCondition endCondition = BattleEndCondition.Continues;
+		private int ghostedBuildings = 1;
+		private int limitDgun;
+		private int maxUnits = 1000;
+		private int startingEnergy = 1000;
 
-    [Category(&quot;Resources&quot;)]
-    [Description(&quot;Starting metal&quot;)]
-    public int StartingMetal
-    {
-      get { return startingMetal; }
-      set { startingMetal = value; }
-    }
+		private int startingMetal = 1000;
+		private BattleStartPos startPos = BattleStartPos.Choose;
 
-    [Category(&quot;Resources&quot;)]
-    [Description(&quot;Starting energy&quot;)]
-    public int StartingEnergy
-    {
-      get { return startingEnergy; }
-      set { startingEnergy = value; }
-    }
+		#endregion
 
-    [Category(&quot;Resources&quot;)]
-    [Description(&quot;Maximum units&quot;)]
-    public int MaxUnits
-    {
-      get { return maxUnits; }
-      set { maxUnits = value; }
-    }
+		#region Properties
 
+		public static BattleDetails Default = new BattleDetails();
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Starting position&quot;)]
-    public BattleStartPos StartPos
-    {
-      get { return startPos; }
-      set { startPos = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Diminishing metal maker outputs&quot;)]
+		public int DiminishingMM
+		{
+			get { return diminishingMM; }
+			set { diminishingMM = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;End condition - should continue when comm dies&quot;)]
-    public BattleEndCondition EndCondition
-    {
-      get { return endCondition; }
-      set { endCondition = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;End condition - should continue when comm dies&quot;)]
+		public BattleEndCondition EndCondition
+		{
+			get { return endCondition; }
+			set { endCondition = value; }
+		}
 
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Ghosted buildings&quot;)]
+		public int GhostedBuildings
+		{
+			get { return ghostedBuildings; }
+			set { ghostedBuildings = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Limit dgun to start position&quot;)]
-    public int LimitDgun
-    {
-      get { return limitDgun; }
-      set { limitDgun = value; }
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Limit dgun to start position&quot;)]
+		public int LimitDgun
+		{
+			get { return limitDgun; }
+			set { limitDgun = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Diminishing metal maker outputs&quot;)]
-    public int DiminishingMM
-    {
-      get { return diminishingMM; }
-      set { diminishingMM = value; }
-    }
+		[Category(&quot;Resources&quot;)]
+		[Description(&quot;Maximum units&quot;)]
+		public int MaxUnits
+		{
+			get { return maxUnits; }
+			set { maxUnits = value; }
+		}
 
-    [Category(&quot;Game rules&quot;)]
-    [Description(&quot;Ghosted buildings&quot;)]
-    public int GhostedBuildings
-    {
-      get { return ghostedBuildings; }
-      set { ghostedBuildings = value; }
-    }
+		[Category(&quot;Resources&quot;)]
+		[Description(&quot;Starting energy&quot;)]
+		public int StartingEnergy
+		{
+			get { return startingEnergy; }
+			set { startingEnergy = value; }
+		}
 
-    #region ICloneable Members
-    public object Clone()
-    {
-      return MemberwiseClone();
-    }
-    #endregion
+		[Category(&quot;Resources&quot;)]
+		[Description(&quot;Starting metal&quot;)]
+		public int StartingMetal
+		{
+			get { return startingMetal; }
+			set { startingMetal = value; }
+		}
 
-    public void Validate()
-    {
-      if (startingMetal &lt; 0) startingMetal = Default.startingMetal;
-      if (startingEnergy &lt; 0) startingEnergy = Default.startingEnergy;
-      if (maxUnits &lt; 0) maxUnits = Default.maxUnits;
-      if (limitDgun &lt; 0) limitDgun = Default.limitDgun;
-      if (diminishingMM &lt; 0) diminishingMM = Default.diminishingMM;
-      if (ghostedBuildings &lt; 0) ghostedBuildings = Default.ghostedBuildings;
-    }
+		[Category(&quot;Game rules&quot;)]
+		[Description(&quot;Starting position&quot;)]
+		public BattleStartPos StartPos
+		{
+			get { return startPos; }
+			set { startPos = value; }
+		}
 
-    /// &lt;summary&gt;
-    /// parses itself from source tags
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
-    public void Parse(string source, Dictionary&lt;string, string&gt; modOptions)
-    {
-      foreach (string pair in source.Split('\t')) {
-        string[] arg = pair.Split(new char[] {'='}, 2);
-        if (arg.Length == 2) {
-          switch (arg[0]) {
-            case &quot;game/startmetal&quot;:
-              StartingMetal = int.Parse(arg[1]);
-              break;
-            case &quot;game/startenergy&quot;:
-              StartingEnergy = int.Parse(arg[1]);
-              break;
-            case &quot;game/maxunits&quot;:
-              MaxUnits = int.Parse(arg[1]);
-              break;
-            case &quot;game/startpostype&quot;:
-              StartPos = (BattleStartPos)int.Parse(arg[1]);
-              break;
-            case &quot;game/gamemode&quot;:
-              EndCondition = (BattleEndCondition)int.Parse(arg[1]);
-              break;
-            case &quot;game/limitdgun&quot;:
-              LimitDgun = int.Parse(arg[1]);
-              break;
-            case &quot;game/diminishingmms&quot;:
-              DiminishingMM = int.Parse(arg[1]);
-              break;
-            case &quot;game/ghostedbuildings&quot;:
-              GhostedBuildings = int.Parse(arg[1]);
-              break;
-            default:
-              if (arg[0].ToLower().StartsWith(&quot;game/modoptions/&quot;) || arg[0].ToLower().StartsWith(&quot;game\\modoptions\\&quot;)) {
-                string val = arg[0].Substring(16);
-                if (modOptions.ContainsKey(val)) modOptions[val] = arg[1];
-                else modOptions.Add(val, arg[1]);
-              }
-              break;
-          }
-        }
-      }
-    }
+		#endregion
 
+		#region Public methods
 
-    public string GetParamList()
-    {
-      Validate();
-      return string.Format(&quot;GAME/StartMetal={0}\tGAME/StartEnergy={1}\tGAME/MaxUnits={2}\tGAME/StartPosType={3}\tGAME/GameMode={4}\tGAME/LimitDGun={5}\tGAME/DiminishingMMs={6}\tGAME/GhostedBuildings={7}&quot;, startingMetal, startingEnergy, maxUnits, (int)startPos, (int)endCondition, limitDgun, diminishingMM, ghostedBuildings);
-    }
+		public string GetParamList()
+		{
+			Validate();
+			return string.Format(&quot;GAME/StartMetal={0}\tGAME/StartEnergy={1}\tGAME/MaxUnits={2}\tGAME/StartPosType={3}\tGAME/GameMode={4}\tGAME/LimitDGun={5}\tGAME/DiminishingMMs={6}\tGAME/GhostedBuildings={7}&quot;, startingMetal, startingEnergy, maxUnits, (int) startPos, (int) endCondition, limitDgun, diminishingMM, ghostedBuildings);
+		}
 
-    #region Nested type: BattleDetailsConverter
-    protected class BattleDetailsConverter : ExpandableObjectConverter
-    {
-      public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
-      {
-        if (destinationType == typeof(string)) {
-          BattleDetails b = (BattleDetails)value;
-          return &quot;Position:&quot; + b.StartPos + &quot;; Comm:&quot; + b.EndCondition + &quot;; Dgun:&quot; + b.LimitDgun;
-        } else return base.ConvertTo(context, culture, value, destinationType);
-      }
-    }
-    #endregion
-  } ;
+		/// &lt;summary&gt;
+		/// parses itself from source tags
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;source&quot;&gt;&lt;/param&gt;
+		public void Parse(string source, Dictionary&lt;string, string&gt; modOptions)
+		{
+			foreach (var pair in source.Split('\t')) {
+				var arg = pair.Split(new[] {'='}, 2);
+				if (arg.Length == 2) {
+					switch (arg[0]) {
+						case &quot;game/startmetal&quot;:
+							StartingMetal = int.Parse(arg[1]);
+							break;
+						case &quot;game/startenergy&quot;:
+							StartingEnergy = int.Parse(arg[1]);
+							break;
+						case &quot;game/maxunits&quot;:
+							MaxUnits = int.Parse(arg[1]);
+							break;
+						case &quot;game/startpostype&quot;:
+							StartPos = (BattleStartPos) int.Parse(arg[1]);
+							break;
+						case &quot;game/gamemode&quot;:
+							EndCondition = (BattleEndCondition) int.Parse(arg[1]);
+							break;
+						case &quot;game/limitdgun&quot;:
+							LimitDgun = int.Parse(arg[1]);
+							break;
+						case &quot;game/diminishingmms&quot;:
+							DiminishingMM = int.Parse(arg[1]);
+							break;
+						case &quot;game/ghostedbuildings&quot;:
+							GhostedBuildings = int.Parse(arg[1]);
+							break;
+						default:
+							if (arg[0].ToLower().StartsWith(&quot;game/modoptions/&quot;) || arg[0].ToLower().StartsWith(&quot;game\\modoptions\\&quot;)) {
+								string val = arg[0].Substring(16);
+								if (modOptions.ContainsKey(val)) modOptions[val] = arg[1];
+								else modOptions.Add(val, arg[1]);
+							}
+							break;
+					}
+				}
+			}
+		}
+
+		public void Validate()
+		{
+			if (startingMetal &lt; 0) startingMetal = Default.startingMetal;
+			if (startingEnergy &lt; 0) startingEnergy = Default.startingEnergy;
+			if (maxUnits &lt; 0) maxUnits = Default.maxUnits;
+			if (limitDgun &lt; 0) limitDgun = Default.limitDgun;
+			if (diminishingMM &lt; 0) diminishingMM = Default.diminishingMM;
+			if (ghostedBuildings &lt; 0) ghostedBuildings = Default.ghostedBuildings;
+		}
+
+		#endregion
+
+		#region ICloneable Members
+
+		public object Clone()
+		{
+			return MemberwiseClone();
+		}
+
+		#endregion
+
+		#region Nested type: BattleDetailsConverter
+
+		protected class BattleDetailsConverter : ExpandableObjectConverter
+		{
+			#region Overrides
+
+			public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
+			{
+				if (destinationType == typeof (string)) {
+					var b = (BattleDetails) value;
+					return &quot;Position:&quot; + b.StartPos + &quot;; Comm:&quot; + b.EndCondition + &quot;; Dgun:&quot; + b.LimitDgun;
+				} else return base.ConvertTo(context, culture, value, destinationType);
+			}
+
+			#endregion
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/BattleRect.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/BattleRect.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/BattleRect.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,71 +1,99 @@
+#region using
+
 using System;
 
+#endregion
+
 namespace Springie.Client
 {
-  [Serializable]
-  public struct BattleRect
-  {
-    public const double Max = 200;
-    private int bottom; // values 0-200 (native tasclient format)
-    private int left; // values 0-200 (native tasclient format)
-    private int right; // values 0-200 (native tasclient format)
-    private int top; // values 0-200 (native tasclient format)
+	[Serializable]
+	public struct BattleRect
+	{
+		#region Constants
 
-    public BattleRect(double left, double top, double right, double bottom)
-    {
-      // convert from percentages
-      this.left = LimitByMax((int)(Max*left));
-      this.top = LimitByMax((int)(Max*top));
-      this.right = LimitByMax((int)(Max*right));
-      this.bottom = LimitByMax((int)(Max*bottom));
-    }
+		public const double Max = 200;
 
-    public BattleRect(int left, int top, int right, int bottom)
-    {
-      this.left = LimitByMax(left);
-      this.top = LimitByMax(top);
-      this.right = LimitByMax(right);
-      this.bottom = LimitByMax(bottom);
-    }
+		#endregion
 
-    public int Left
-    {
-      get { return left; }
-      set { left = LimitByMax(value); }
-    }
+		#region Fields
 
-    public int Right
-    {
-      get { return right; }
-      set { right = LimitByMax(value); }
-    }
+		private int bottom; // values 0-200 (native tasclient format)
+		private int left; // values 0-200 (native tasclient format)
+		private int right; // values 0-200 (native tasclient format)
+		private int top; // values 0-200 (native tasclient format)
 
-    public int Top
-    {
-      get { return top; }
-      set { top = LimitByMax(value); }
-    }
+		#endregion
 
-    public int Bottom
-    {
-      get { return bottom; }
-      set { bottom = LimitByMax(value); }
-    }
+		#region Properties
 
-    private static int LimitByMax(int input)
-    {
-      if (input &lt; 0) return 0;
-      if (input &gt; Max) return (int)Max;
-      return input;
-    }
+		public int Bottom
+		{
+			get { return bottom; }
+			set { bottom = LimitByMax(value); }
+		}
 
+		public int Left
+		{
+			get { return left; }
+			set { left = LimitByMax(value); }
+		}
 
-    public void ToFractions(out double left, out double top, out double right, out double bottom)
-    {
-      left = Left/Max;
-      top = Top/Max;
-      right = Right/Max;
-      bottom = Bottom/Max;
-    }
-  } ;
+		public int Right
+		{
+			get { return right; }
+			set { right = LimitByMax(value); }
+		}
+
+		public int Top
+		{
+			get { return top; }
+			set { top = LimitByMax(value); }
+		}
+
+		#endregion
+
+		#region Constructors
+
+		public BattleRect(double left, double top, double right, double bottom)
+		{
+			// convert from percentages
+			this.left = LimitByMax((int) (Max*left));
+			this.top = LimitByMax((int) (Max*top));
+			this.right = LimitByMax((int) (Max*right));
+			this.bottom = LimitByMax((int) (Max*bottom));
+		}
+
+		public BattleRect(int left, int top, int right, int bottom)
+		{
+			this.left = LimitByMax(left);
+			this.top = LimitByMax(top);
+			this.right = LimitByMax(right);
+			this.bottom = LimitByMax(bottom);
+		}
+
+		#endregion
+
+		#region Public methods
+
+		public void ToFractions(out double left, out double top, out double right, out double bottom)
+		{
+			left = Left/Max;
+			top = Top/Max;
+			right = Right/Max;
+			bottom = Bottom/Max;
+		}
+
+		#endregion
+
+		#region Other methods
+
+		private static int LimitByMax(int input)
+		{
+			if (input &lt; 0) return 0;
+			if (input &gt; Max) return (int) Max;
+			return input;
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/BotBattleStatus.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/BotBattleStatus.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/BotBattleStatus.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,16 +1,22 @@
-using System.Net;
-
 namespace Springie.Client
 {
-  public class BotBattleStatus:UserBattleStatus
-  {
-    public string aiLib;
-    public string owner;
+	public class BotBattleStatus : UserBattleStatus
+	{
+		#region Properties
 
-    public BotBattleStatus(string name, string owner, string aiLib): base(name)
-    {
-      this.owner = owner;
-      this.aiLib = aiLib;
-    }
-  } ;
+		public string aiLib;
+		public string owner;
+
+		#endregion
+
+		#region Constructors
+
+		public BotBattleStatus(string name, string owner, string aiLib) : base(name)
+		{
+			this.owner = owner;
+			this.aiLib = aiLib;
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/ServerConnection.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/ServerConnection.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/ServerConnection.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Net.Sockets;
 using System.Text;
@@ -2,276 +4,288 @@
 
+#endregion
+
 namespace Springie.Client
 {
-  /// &lt;summary&gt;
-  /// Event arguments used in many ServerConnection events
-  /// &lt;/summary&gt;
-  public class ServerConnectionEventArgs : EventArgs
-  {
-    #region ResultTypes enum
-    public enum ResultTypes
-    {
-      Success,
-      NetworkError,
-      NotSet
-    } ;
-    #endregion
+	/// &lt;summary&gt;
+	/// Event arguments used in many ServerConnection events
+	/// &lt;/summary&gt;
+	public class ServerConnectionEventArgs : EventArgs
+	{
+		#region ResultTypes enum
 
-    private string command = &quot;&quot;;
+		public enum ResultTypes
+		{
+			Success,
+			NetworkError,
+			NotSet
+		} ;
 
-    private object[] parameters;
-    private int requestId = 0;
+		#endregion
 
-    private ResultTypes result = ResultTypes.NotSet;
+		#region Fields
 
-    private ServerConnection serverConnection = null;
+		private string command = &quot;&quot;;
 
+		private ResultTypes result = ResultTypes.NotSet;
 
-    public ServerConnectionEventArgs() {}
+		#endregion
 
-    public ServerConnectionEventArgs(ServerConnection serverConnection, int requestId, string command, object[] parameters)
-    {
-      this.serverConnection = serverConnection;
-      this.requestId = requestId;
-      this.command = command;
-      this.parameters = parameters;
-    }
+		#region Properties
 
-    public int RequestId
-    {
-      get { return requestId; }
-      set { requestId = value; }
-    }
+		public string Command
+		{
+			get { return command; }
+			set { command = value; }
+		}
 
-    public string Command
-    {
-      get { return command; }
-      set { command = value; }
-    }
+		public object[] Parameters { get; set; }
+		public int RequestId { get; set; }
 
-    public object[] Parameters
-    {
-      get { return parameters; }
-      set { parameters = value; }
-    }
+		public ResultTypes Result
+		{
+			get { return result; }
+			set { result = value; }
+		}
 
-    public ResultTypes Result
-    {
-      get { return result; }
-      set { result = value; }
-    }
+		public ServerConnection ServerConnection { get; set; }
 
-    public ServerConnection ServerConnection
-    {
-      get { return serverConnection; }
-      set { serverConnection = value; }
-    }
-  }
+		#endregion
 
+		#region Constructors
 
-  /// &lt;summary&gt;
-  /// Handles communiction with server on low level
-  /// &lt;/summary&gt;
-  public class ServerConnection : IDisposable
-  {
-    private int commandNumber = 0;
-    private object myLock = new object();
-    private Byte[] readBuffer;
-    private int readPosition = 0;
-    private NetworkStream stream;
-    private TcpClient tcp;
+		public ServerConnectionEventArgs() {}
 
-    public ServerConnection() {}
+		public ServerConnectionEventArgs(ServerConnection serverConnection, int requestId, string command, object[] parameters)
+		{
+			this.ServerConnection = serverConnection;
+			this.RequestId = requestId;
+			this.command = command;
+			this.Parameters = parameters;
+		}
 
-    /// &lt;summary&gt;
-    /// Creates object and connects to TA server
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;host&quot;&gt;server host&lt;/param&gt;
-    /// &lt;param name=&quot;port&quot;&gt;server port&lt;/param&gt;
-    public ServerConnection(string host, int port)
-    {
-      Connect(host, port);
-    }
+		#endregion
+	}
 
-    #region IDisposable Members
-    public void Dispose()
-    {
-      Close();
-    }
-    #endregion
 
-    /// &lt;summary&gt;
-    /// Raised when command has finished sending
-    /// &lt;/summary&gt;
-    public event EventHandler&lt;ServerConnectionEventArgs&gt; CommandSent;
+	/// &lt;summary&gt;
+	/// Handles communiction with server on low level
+	/// &lt;/summary&gt;
+	public class ServerConnection : IDisposable
+	{
+		#region Fields
 
-    /// &lt;summary&gt;
-    /// raised when connection is closed 
-    /// &lt;/summary&gt;
-    public event EventHandler ConnectionClosed;
+		private int commandNumber;
+		private object myLock = new object();
+		private Byte[] readBuffer;
+		private int readPosition;
+		private NetworkStream stream;
+		private TcpClient tcp;
 
-    /// &lt;summary&gt;
-    /// Raised when command is recieved from the server
-    /// &lt;/summary&gt;
-    public event EventHandler&lt;ServerConnectionEventArgs&gt; CommandRecieved;
+		#endregion
 
+		#region Events
 
-    /// &lt;summary&gt;
-    /// Connects to TA server and resets internal data
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;host&quot;&gt;server host&lt;/param&gt;
-    /// &lt;param name=&quot;port&quot;&gt;server port&lt;/param&gt;
-    public void Connect(string host, int port)
-    {
-      tcp = new TcpClient(host, port);
-      stream = tcp.GetStream();
-      readBuffer = new byte[tcp.ReceiveBufferSize];
-      readPosition = 0;
-      stream.BeginRead(readBuffer, 0, readBuffer.Length, new AsyncCallback(DataRecieveCallback), this);
-    }
+		/// &lt;summary&gt;
+		/// Raised when command is recieved from the server
+		/// &lt;/summary&gt;
+		public event EventHandler&lt;ServerConnectionEventArgs&gt; CommandRecieved;
 
-    /// &lt;summary&gt;
-    /// Prepares byte array with command
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;command&quot;&gt;command&lt;/param&gt;
-    /// &lt;param name=&quot;pars&quot;&gt;command parameters&lt;/param&gt;
-    /// &lt;returns&gt;&lt;/returns&gt;
-    private byte[] PrepareCommand(string command, object[] pars)
-    {
-      string prepstring = command;
-      for (int i = 0; i &lt; pars.Length; ++i) {
-        string s = pars[i].ToString();
+		/// &lt;summary&gt;
+		/// Raised when command has finished sending
+		/// &lt;/summary&gt;
+		public event EventHandler&lt;ServerConnectionEventArgs&gt; CommandSent;
 
-        prepstring += (s[0] == '\t' ? &quot;&quot; : &quot; &quot;) + s; // if parameter starts with \t it's sentence seperator and we will ommit space
-      }
-      prepstring += '\n';
-      return ASCIIEncoding.ASCII.GetBytes(prepstring);
-    }
+		/// &lt;summary&gt;
+		/// raised when connection is closed 
+		/// &lt;/summary&gt;
+		public event EventHandler ConnectionClosed;
 
-    /// &lt;summary&gt;
-    /// Sends command to server
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;id&quot;&gt;command id - use this to internally track when command finished sending&lt;/param&gt;
-    /// &lt;param name=&quot;command&quot;&gt;command&lt;/param&gt;
-    /// &lt;param name=&quot;parameters&quot;&gt;command parameters&lt;/param&gt;
-    public void SendCommand(int id, string command, params object[] parameters)
-    {
-      ServerConnectionEventArgs eventArgs = new ServerConnectionEventArgs(this, id, command, parameters);
-      if (stream != null &amp;&amp; stream.CanWrite) {
-        try {
-          byte[] buffer = PrepareCommand(command, parameters);
-          stream.BeginWrite(buffer, 0, buffer.Length, new AsyncCallback(CommandSentCallback), eventArgs);
-        } catch {
-          eventArgs.Result = ServerConnectionEventArgs.ResultTypes.NetworkError;
-          if (CommandSent != null) CommandSent(this, eventArgs);
-          Close();
-          return;
-        }
-      } else {
-        eventArgs.Result = ServerConnectionEventArgs.ResultTypes.NetworkError;
-        if (CommandSent != null) CommandSent(this, eventArgs);
-      }
-    }
+		#endregion
 
+		#region Constructors
 
-    private static void CommandSentCallback(IAsyncResult res)
-    {
-      ServerConnectionEventArgs arg = (ServerConnectionEventArgs)res.AsyncState;
-      arg.Result = ServerConnectionEventArgs.ResultTypes.Success;
-      try {
-        arg.ServerConnection.stream.EndWrite(res);
-      } catch {
-        arg.Result = ServerConnectionEventArgs.ResultTypes.NetworkError;
-        arg.ServerConnection.Close();
-        return;
-      }
-      if (arg.ServerConnection.CommandSent != null) arg.ServerConnection.CommandSent(arg.ServerConnection, arg);
-    }
+		public ServerConnection() {}
 
+		/// &lt;summary&gt;
+		/// Creates object and connects to TA server
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;host&quot;&gt;server host&lt;/param&gt;
+		/// &lt;param name=&quot;port&quot;&gt;server port&lt;/param&gt;
+		public ServerConnection(string host, int port)
+		{
+			Connect(host, port);
+		}
 
-    private static void DataRecieveCallback(IAsyncResult res)
-    {
-      ServerConnection server = (ServerConnection)res.AsyncState;
-      try {
-        int cnt = server.stream.EndRead(res); // actual data read - this blocks
-		server.readPosition += cnt;
-		if (cnt == 0)
+		public void Dispose()
 		{
-			server.Close();
-			return;
+			Close();
 		}
-      } catch {
-        // there was error while reading - stream is broken
-        server.Close();
-        return;
-      }
 
-      // check data for new line - isolating commands from it
-      for (int i = server.readPosition - 1; i &gt;= 0; --i) {
-        if (server.readBuffer[i] == '\n') {
-          // new line found - convert to string and parse commands
+		#endregion
 
-          String recData = Encoding.ASCII.GetString(server.readBuffer, 0, i + 1); // convert recieved bytes to string
+		#region Public methods
 
-          // cycle through lines of data
-          foreach (string line in recData.Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries)) {
-            // for each line = command do
-            string[] args = line.Split(' '); // split arguments
-            /*for (int j = 0; j &lt; args.Length; ++j) { // replace \t with ' ' in every argument
+		/// &lt;summary&gt;
+		/// Closes connection to remote server
+		/// &lt;/summary&gt;
+		public void Close()
+		{
+			lock (myLock) {
+				CommandRecieved = null;
+				CommandSent = null;
+				if (tcp != null &amp;&amp; tcp.Connected) tcp.Close();
+				stream = null;
+				tcp = null;
+				if (ConnectionClosed != null) ConnectionClosed(this, EventArgs.Empty);
+				ConnectionClosed = null;
+			}
+		}
+
+
+		/// &lt;summary&gt;
+		/// Connects to TA server and resets internal data
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;host&quot;&gt;server host&lt;/param&gt;
+		/// &lt;param name=&quot;port&quot;&gt;server port&lt;/param&gt;
+		public void Connect(string host, int port)
+		{
+			tcp = new TcpClient(host, port);
+			stream = tcp.GetStream();
+			readBuffer = new byte[tcp.ReceiveBufferSize];
+			readPosition = 0;
+			stream.BeginRead(readBuffer, 0, readBuffer.Length, DataRecieveCallback, this);
+		}
+
+		/// &lt;summary&gt;
+		/// Sends command to server
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;id&quot;&gt;command id - use this to internally track when command finished sending&lt;/param&gt;
+		/// &lt;param name=&quot;command&quot;&gt;command&lt;/param&gt;
+		/// &lt;param name=&quot;parameters&quot;&gt;command parameters&lt;/param&gt;
+		public void SendCommand(int id, string command, params object[] parameters)
+		{
+			var eventArgs = new ServerConnectionEventArgs(this, id, command, parameters);
+			if (stream != null &amp;&amp; stream.CanWrite) {
+				try {
+					var buffer = PrepareCommand(command, parameters);
+					stream.BeginWrite(buffer, 0, buffer.Length, CommandSentCallback, eventArgs);
+				} catch {
+					eventArgs.Result = ServerConnectionEventArgs.ResultTypes.NetworkError;
+					if (CommandSent != null) CommandSent(this, eventArgs);
+					Close();
+					return;
+				}
+			} else {
+				eventArgs.Result = ServerConnectionEventArgs.ResultTypes.NetworkError;
+				if (CommandSent != null) CommandSent(this, eventArgs);
+			}
+		}
+
+		#endregion
+
+		#region Other methods
+
+		private static void CommandSentCallback(IAsyncResult res)
+		{
+			var arg = (ServerConnectionEventArgs) res.AsyncState;
+			arg.Result = ServerConnectionEventArgs.ResultTypes.Success;
+			try {
+				arg.ServerConnection.stream.EndWrite(res);
+			} catch {
+				arg.Result = ServerConnectionEventArgs.ResultTypes.NetworkError;
+				arg.ServerConnection.Close();
+				return;
+			}
+			if (arg.ServerConnection.CommandSent != null) arg.ServerConnection.CommandSent(arg.ServerConnection, arg);
+		}
+
+
+		private static void DataRecieveCallback(IAsyncResult res)
+		{
+			var server = (ServerConnection) res.AsyncState;
+			try {
+				int cnt = server.stream.EndRead(res); // actual data read - this blocks
+				server.readPosition += cnt;
+				if (cnt == 0) {
+					server.Close();
+					return;
+				}
+			} catch {
+				// there was error while reading - stream is broken
+				server.Close();
+				return;
+			}
+
+			// check data for new line - isolating commands from it
+			for (int i = server.readPosition - 1; i &gt;= 0; --i) {
+				if (server.readBuffer[i] == '\n') {
+					// new line found - convert to string and parse commands
+
+					String recData = Encoding.ASCII.GetString(server.readBuffer, 0, i + 1); // convert recieved bytes to string
+
+					// cycle through lines of data
+					foreach (var line in recData.Split(new[] {'\n'}, StringSplitOptions.RemoveEmptyEntries)) {
+						// for each line = command do
+						var args = line.Split(' '); // split arguments
+						/*for (int j = 0; j &lt; args.Length; ++j) { // replace \t with ' ' in every argument
               args[j] = args[j].Replace('\t', ' ');
             }*/
 
-            // prepare and send command recieved info
-            ServerConnectionEventArgs command = new ServerConnectionEventArgs();
-            command.ServerConnection = server;
-            command.RequestId = server.commandNumber++;
-            command.Command = args[0];
-            command.Result = ServerConnectionEventArgs.ResultTypes.Success;
-            command.Parameters = new string[args.Length - 1];
-            for (int j = 1; j &lt; args.Length; ++j) command.Parameters[j - 1] = args[j];
-            if (server.CommandRecieved != null) server.CommandRecieved(server, command);
-          }
+						// prepare and send command recieved info
+						var command = new ServerConnectionEventArgs();
+						command.ServerConnection = server;
+						command.RequestId = server.commandNumber++;
+						command.Command = args[0];
+						command.Result = ServerConnectionEventArgs.ResultTypes.Success;
+						command.Parameters = new string[args.Length - 1];
+						for (int j = 1; j &lt; args.Length; ++j) command.Parameters[j - 1] = args[j];
+						if (server.CommandRecieved != null) server.CommandRecieved(server, command);
+					}
 
-          // copy remaining data (not ended by \n yet) to the beginning of buffer
-          for (int x = 0; x &lt; server.readPosition - i - 1; ++x) server.readBuffer[x] = server.readBuffer[x + i + 1];
-          server.readPosition = server.readPosition - i - 1;
-          break;
-        }
-      }
+					// copy remaining data (not ended by \n yet) to the beginning of buffer
+					for (int x = 0; x &lt; server.readPosition - i - 1; ++x) server.readBuffer[x] = server.readBuffer[x + i + 1];
+					server.readPosition = server.readPosition - i - 1;
+					break;
+				}
+			}
 
-      // prepare to read more data
-      int rembuf = server.readBuffer.Length - server.readPosition;
-      if (rembuf &lt;= 0) {
-        // read buffer too small, increase it
-        byte[] n = new byte[server.readBuffer.Length*2];
-        server.readBuffer.CopyTo(n, 0);
-        server.readBuffer = n;
-        rembuf = server.readBuffer.Length - server.readPosition;
-      }
+			// prepare to read more data
+			int rembuf = server.readBuffer.Length - server.readPosition;
+			if (rembuf &lt;= 0) {
+				// read buffer too small, increase it
+				var n = new byte[server.readBuffer.Length*2];
+				server.readBuffer.CopyTo(n, 0);
+				server.readBuffer = n;
+				rembuf = server.readBuffer.Length - server.readPosition;
+			}
 
-      try {
-        server.stream.BeginRead(server.readBuffer, server.readPosition, rembuf, new AsyncCallback(DataRecieveCallback), server);
-      } catch {
-        // there was error while reading - stream is broken
-        server.Close();
-        return;
-      }
-    }
+			try {
+				server.stream.BeginRead(server.readBuffer, server.readPosition, rembuf, DataRecieveCallback, server);
+			} catch {
+				// there was error while reading - stream is broken
+				server.Close();
+				return;
+			}
+		}
 
+		/// &lt;summary&gt;
+		/// Prepares byte array with command
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;command&quot;&gt;command&lt;/param&gt;
+		/// &lt;param name=&quot;pars&quot;&gt;command parameters&lt;/param&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		private byte[] PrepareCommand(string command, object[] pars)
+		{
+			string prepstring = command;
+			for (int i = 0; i &lt; pars.Length; ++i) {
+				string s = pars[i].ToString();
 
-    /// &lt;summary&gt;
-    /// Closes connection to remote server
-    /// &lt;/summary&gt;
-    public void Close()
-    {
-      lock (myLock) {
-        CommandRecieved = null;
-        CommandSent = null;
-        if (tcp != null &amp;&amp; tcp.Connected) tcp.Close();
-        stream = null;
-        tcp = null;
-        if (ConnectionClosed != null) ConnectionClosed(this, EventArgs.Empty);
-        ConnectionClosed = null;
-      }
-    }
-  }
+				prepstring += (s[0] == '\t' ? &quot;&quot; : &quot; &quot;) + s; // if parameter starts with \t it's sentence seperator and we will ommit space
+			}
+			prepstring += '\n';
+			return Encoding.ASCII.GetBytes(prepstring);
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/TasClient.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/TasClient.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/TasClient.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.Globalization;
@@ -12,857 +14,863 @@
 using Springie.SpringNamespace;
 using Timer=System.Timers.Timer;
 
+#endregion
+
 namespace Springie.Client
 {
-  public partial class TasClient
-  {
-    // server info
+	public class TasClient
+	{
+		// server info
 
-    #region SayPlace enum
-    public enum SayPlace
-    {
-      Channel,
-      Battle,
-      User
-    } ;
-    #endregion
+		#region Constants
 
-    public const int MaxRank = 4;
-    public const int MinRank = 0;
-    private Battle battle = null;
-    private int battleID = 0;
+		public const int MaxRank = 4;
+		public const int MinRank = 0;
 
-    private ServerConnection con = null;
-    private Dictionary&lt;string, ExistingChannel&gt; existingChannels = new Dictionary&lt;string, ExistingChannel&gt;();
-    private Dictionary&lt;string, User&gt; existingUsers = new Dictionary&lt;string, User&gt;();
-    private bool isChanScanning = false;
-    private bool isConnected = false;
-    private bool isLoggedIn = false;
-    private Dictionary&lt;string, Channel&gt; joinedChannels = new Dictionary&lt;string, Channel&gt;();
-    private int lastSpectatorCount;
-    private int lastUdpSourcePort = 0;
-    private bool lockToChangeTo;
-    private MapInfo mapToChangeTo;
-    private int pingInterval = 10; // how often to ping server (in seconds)
-    private Timer pingTimer;
+		#endregion
 
-    private string serverHost = &quot;&quot;;
-    private IPAddress serverIp;
-    private int serverPort = 0;
-    private int serverUdpHolePunchingPort = 0;
-    private string serverVersion = &quot;&quot;;
-    private bool startingAfterUdpPunch = false;
-    private Timer udpPunchingTimer = new Timer(400);
+		#region SayPlace enum
 
-    // user info 
-    private string username = &quot;&quot;;
+		public enum SayPlace
+		{
+			Channel,
+			Battle,
+			User
+		} ;
 
-    public TasClient()
-    {
-      pingTimer = new Timer(pingInterval*1000);
-      pingTimer.AutoReset = true;
-      pingTimer.Elapsed += OnPingTimer;
-      pingTimer.Start();
+		#endregion
 
-      udpPunchingTimer.Elapsed += new ElapsedEventHandler(udpPunchingTimer_Elapsed);
-      udpPunchingTimer.AutoReset = true;
+		#region Fields
 
-      ConnectionLost += RaiseFailure;
-      LoginDenied += RaiseFailure;
-      ChannelJoinFailed += RaiseFailure;
-      BattleOpenFailed += RaiseFailure;
-    }
+		private Battle battle;
+		private int battleID;
 
-    public string UserName
-    {
-      get { return username; }
-    }
+		private ServerConnection con;
+		private Dictionary&lt;string, ExistingChannel&gt; existingChannels = new Dictionary&lt;string, ExistingChannel&gt;();
+		private Dictionary&lt;string, User&gt; existingUsers = new Dictionary&lt;string, User&gt;();
+		private bool isChanScanning;
+		private bool isConnected;
+		private bool isLoggedIn;
+		private Dictionary&lt;string, Channel&gt; joinedChannels = new Dictionary&lt;string, Channel&gt;();
+		private int lastSpectatorCount;
+		private int lastUdpSourcePort;
+		private bool lockToChangeTo;
+		private MapInfo mapToChangeTo;
+		private int pingInterval = 10; // how often to ping server (in seconds)
+		private Timer pingTimer;
 
-    public bool IsLoggedIn
-    {
-      get { return isLoggedIn; }
-    }
+		private string serverHost = &quot;&quot;;
+		private IPAddress serverIp;
+		private int serverPort;
+		private int serverUdpHolePunchingPort;
+		private string serverVersion = &quot;&quot;;
+		private bool startingAfterUdpPunch;
+		private Timer udpPunchingTimer = new Timer(400);
 
-    public int PingInterval
-    {
-      get { return pingInterval; }
-      set
-      {
-        pingInterval = value;
-        pingTimer.Interval = pingInterval*1000;
-      }
-    }
+		// user info 
+		private string username = &quot;&quot;;
 
-    public bool IsConnected
-    {
-      get { return isConnected; }
-    }
+		#endregion
 
-    // group events
-    public event EventHandler&lt;TasEventArgs&gt; Failure; //this event is fired whenever any failure events fire
-    public event EventHandler&lt;TasSayEventArgs&gt; Said; // this is fired when any kind of say message is recieved
+		#region Properties
 
+		public bool IsConnected
+		{
+			get { return isConnected; }
+		}
 
-    // invidivudal events
-    public event EventHandler&lt;TasEventArgs&gt; Connected;
-    public event EventHandler&lt;TasEventArgs&gt; ConnectionLost;
+		public bool IsLoggedIn
+		{
+			get { return isLoggedIn; }
+		}
 
-    public event EventHandler&lt;TasEventArgs&gt; LoginAccepted;
-    public event EventHandler&lt;TasEventArgs&gt; LoginDenied;
+		public int PingInterval
+		{
+			get { return pingInterval; }
+			set
+			{
+				pingInterval = value;
+				pingTimer.Interval = pingInterval*1000;
+			}
+		}
 
-    public event EventHandler&lt;TasEventArgs&gt; ChannelJoined;
-    public event EventHandler&lt;TasEventArgs&gt; ChannelLeft;
-    public event EventHandler&lt;TasEventArgs&gt; ChannelJoinFailed;
+		public string UserName
+		{
+			get { return username; }
+		}
 
-    public event EventHandler&lt;TasEventArgs&gt; ChannelListDone;
+		#endregion
 
-    public event EventHandler&lt;TasEventArgs&gt; UserAdded;
-    public event EventHandler&lt;TasEventArgs&gt; UserRemoved;
+		#region Events
 
-    public event EventHandler&lt;TasEventArgs&gt; BattleOpenFailed;
-    public event EventHandler&lt;TasEventArgs&gt; BattleOpened;
-    public event EventHandler&lt;TasEventArgs&gt; BattleClosed;
-    public event EventHandler&lt;TasEventArgs&gt; BattleUserJoined;
-    public event EventHandler&lt;TasEventArgs&gt; BattleUserLeft;
-    public event EventHandler&lt;TasEventArgs&gt; BattleUserStatusChanged;
-    public event EventHandler&lt;TasEventArgs&gt; BattleUserIpRecieved;
-    public event EventHandler&lt;TasEventArgs&gt; BattleMapChanged;
-    public event EventHandler&lt;TasEventArgs&gt; BattleLockChanged;
-    public event EventHandler&lt;TasEventArgs&gt; BattleDisabledUnitsChanged;
-    public event EventHandler&lt;TasEventArgs&gt; BattleDetailsChanged;
+		public event EventHandler&lt;TasEventArgs&gt; BattleClosed;
+		public event EventHandler&lt;TasEventArgs&gt; BattleDetailsChanged;
+		public event EventHandler&lt;TasEventArgs&gt; BattleDisabledUnitsChanged;
+		public event EventHandler&lt;TasEventArgs&gt; BattleFound;
+		public event EventHandler&lt;TasEventArgs&gt; BattleLockChanged;
+		public event EventHandler&lt;TasEventArgs&gt; BattleMapChanged;
+		public event EventHandler&lt;TasEventArgs&gt; BattleOpened;
+		public event EventHandler&lt;TasEventArgs&gt; BattleOpenFailed;
+		public event EventHandler&lt;TasEventArgs&gt; BattleUserIpRecieved;
+		public event EventHandler&lt;TasEventArgs&gt; BattleUserJoined;
+		public event EventHandler&lt;TasEventArgs&gt; BattleUserLeft;
+		public event EventHandler&lt;TasEventArgs&gt; BattleUserStatusChanged;
+		public event EventHandler&lt;TasEventArgs&gt; ChannelJoined;
+		public event EventHandler&lt;TasEventArgs&gt; ChannelJoinFailed;
+		public event EventHandler&lt;TasEventArgs&gt; ChannelLeft;
+		public event EventHandler&lt;TasEventArgs&gt; ChannelListDone;
+		public event EventHandler&lt;TasEventArgs&gt; ChannelTopicChanged;
 
-    public event EventHandler&lt;TasEventArgs&gt; BattleFound;
 
+		public event EventHandler&lt;TasEventArgs&gt; ChannelUserAdded;
+		public event EventHandler&lt;TasEventArgs&gt; ChannelUserRemoved;
+		public event EventHandler&lt;TasEventArgs&gt; Connected;
+		public event EventHandler&lt;TasEventArgs&gt; ConnectionLost;
+		public event EventHandler&lt;TasEventArgs&gt; Failure; //this event is fired whenever any failure events fire
+		public event EventHandler&lt;TasEventArgs&gt; LoginAccepted;
+		public event EventHandler&lt;TasEventArgs&gt; LoginDenied;
 
-    public event EventHandler&lt;TasEventArgs&gt; ChannelUserAdded;
-    public event EventHandler&lt;TasEventArgs&gt; ChannelUserRemoved;
-    public event EventHandler&lt;TasEventArgs&gt; ChannelTopicChanged;
+		public event EventHandler&lt;TasEventArgs&gt; MyStatusChangedToInGame;
+		public event EventHandler&lt;TasSayEventArgs&gt; Said; // this is fired when any kind of say message is recieved
+		public event EventHandler&lt;TasEventArgs&gt; UserAdded;
+		public event EventHandler&lt;TasEventArgs&gt; UserRemoved;
+		public event EventHandler&lt;TasEventArgs&gt; UserStatusChanged;
 
-    public event EventHandler&lt;TasEventArgs&gt; UserStatusChanged;
+		#endregion
 
-    public event EventHandler&lt;TasEventArgs&gt; MyStatusChangedToInGame;
+		#region Constructors
 
+		public TasClient()
+		{
+			pingTimer = new Timer(pingInterval*1000);
+			pingTimer.AutoReset = true;
+			pingTimer.Elapsed += OnPingTimer;
+			pingTimer.Start();
 
-    public Dictionary&lt;string, Channel&gt; GetJoinedChannels()
-    {
-      return new Dictionary&lt;string, Channel&gt;(joinedChannels);
-    }
+			udpPunchingTimer.Elapsed += udpPunchingTimer_Elapsed;
+			udpPunchingTimer.AutoReset = true;
 
+			ConnectionLost += RaiseFailure;
+			LoginDenied += RaiseFailure;
+			ChannelJoinFailed += RaiseFailure;
+			BattleOpenFailed += RaiseFailure;
+		}
 
-    public bool GetExistingUser(string name, out User u)
-    {
-      return existingUsers.TryGetValue(name, out u);
-    }
+		#endregion
 
-    public void Connect(string host, int port)
-    {
-      serverHost = host;
-      serverIp = Dns.GetHostAddresses(host)[0];
-      serverPort = port;
-      battle = null;
-      battleID = 0;
-      existingUsers = new Dictionary&lt;string, User&gt;();
-      existingChannels = new Dictionary&lt;string, ExistingChannel&gt;();
-      joinedChannels = new Dictionary&lt;string, Channel&gt;();
-      isChanScanning = false;
-      isLoggedIn = false;
-      isConnected = false;
-      username = &quot;&quot;;
-      try {
-        con = new ServerConnection();
-        con.Connect(host, port);
-        con.ConnectionClosed += OnConnectionClosed;
-        con.CommandRecieved += OnCommandRecieved;
-      } catch {
-        con = null;
-        if (ConnectionLost != null) ConnectionLost(this, new TasEventArgs(&quot;Cannot connect to remote machine&quot;));
-      }
-    }
+		#region Public methods
 
-    public void Disconnect()
-    {
-      if (con != null &amp;&amp; isConnected) con.Close();
-      //con.CommandRecieved 
-      existingUsers = new Dictionary&lt;string, User&gt;();
-      existingChannels = new Dictionary&lt;string, ExistingChannel&gt;();
-      joinedChannels = new Dictionary&lt;string, Channel&gt;();
-      battle = null;
-      battleID = 0;
-      username = &quot;&quot;;
-      isLoggedIn = false;
-      isConnected = false;
-      isChanScanning = false;
-    }
+		public void AddBattleRectangle(int allyno, BattleRect rect)
+		{
+			if (battle != null) {
+				if (allyno &lt; Spring.MaxAllies &amp;&amp; allyno &gt;= 0) {
+					RemoveBattleRectangle(allyno);
+					battle.Rectangles.Add(allyno, rect);
+					con.SendCommand(0, &quot;ADDSTARTRECT&quot;, allyno, rect.Left, rect.Top, rect.Right, rect.Bottom);
+				}
+			}
+		}
 
-    private void OnPingTimer(object sender, EventArgs args)
-    {
-      if (isConnected &amp;&amp; con != null) con.SendCommand(0, &quot;PING&quot;);
-    }
+		public void ChangeLock(bool lck)
+		{
+			if (battle != null &amp;&amp; lck != lockToChangeTo) UpdateBattleInfo(lck, mapToChangeTo);
+		}
 
+		public void ChangeMap(MapInfo nmap)
+		{
+			if (battle != null) {
+				mapToChangeTo = nmap;
+				UpdateBattleInfo(lockToChangeTo, nmap);
+			}
+		}
 
-    public void Login(string login, string password, string appinfo)
-    {
-      if (con == null) throw new TasClientException(&quot;Not connected&quot;);
+		public void ChangeMyStatus(bool isAway, bool isInGame)
+		{
+			var u = new User();
+			u.isAway = isAway;
+			u.isInGame = isInGame;
+			con.SendCommand(0, &quot;MYSTATUS&quot;, u.ToInt());
+		}
 
-      string localIp = Dns.GetHostAddresses(Dns.GetHostName())[0].ToString();
 
-      string mhz = Registry.GetValue(&quot;HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\CentralProcessor\\0&quot;, &quot;~MHz&quot;, 0).ToString();
+		public void Connect(string host, int port)
+		{
+			serverHost = host;
+			serverIp = Dns.GetHostAddresses(host)[0];
+			serverPort = port;
+			battle = null;
+			battleID = 0;
+			existingUsers = new Dictionary&lt;string, User&gt;();
+			existingChannels = new Dictionary&lt;string, ExistingChannel&gt;();
+			joinedChannels = new Dictionary&lt;string, Channel&gt;();
+			isChanScanning = false;
+			isLoggedIn = false;
+			isConnected = false;
+			username = &quot;&quot;;
+			try {
+				con = new ServerConnection();
+				con.Connect(host, port);
+				con.ConnectionClosed += OnConnectionClosed;
+				con.CommandRecieved += OnCommandRecieved;
+			} catch {
+				con = null;
+				if (ConnectionLost != null) ConnectionLost(this, new TasEventArgs(&quot;Cannot connect to remote machine&quot;));
+			}
+		}
 
-      string mhz2 = &quot;&quot;;
+		public static DateTime ConvertMilisecondTime(string arg)
+		{
+			return (new DateTime(1970, 1, 1, 0, 0, 0)).AddMilliseconds(long.Parse(arg));
+		}
 
-      if (Registry.GetValue(&quot;HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\CentralProcessor\\0&quot;, &quot;VendorIdentifier&quot;, 0).ToString().Contains(&quot;AMD&quot;)) {
-        Match m = Regex.Match(Registry.GetValue(&quot;HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\CentralProcessor\\0&quot;, &quot;ProcessorNameString&quot;, 0).ToString(), &quot;[^0-9]*([0-9]*)&quot;);
-        if (m.Groups.Count &gt; 1) mhz2 = m.Groups[1].Value;
+		public void DisableUnits(params string[] units)
+		{
+			if (battle != null) {
+				var tmp = new List&lt;string&gt;(units);
+				foreach (var s in tmp) {
+					if (!battle.DisabledUnits.Contains(s)) {
+						UnitInfo u;
+						if (battle.Mod.GetUnitInfo(s, out u)) battle.DisabledUnits.Add(s);
+					}
+				}
+				if (battle.DisabledUnits.Count &gt; 0) {
+					con.SendCommand(0, &quot;DISABLEUNITS&quot;, battle.DisabledUnits.ToArray());
+					if (BattleDisabledUnitsChanged != null) BattleDisabledUnitsChanged(this, new TasEventArgs(battle.DisabledUnits.ToArray()));
+				}
+			}
+		}
 
-        int i, o;
-        int.TryParse(mhz2, out o);
-        int.TryParse(mhz, out i);
-        if (o &gt; i) mhz = o.ToString();
-      }
+		public void Disconnect()
+		{
+			if (con != null &amp;&amp; isConnected) con.Close();
+			//con.CommandRecieved 
+			existingUsers = new Dictionary&lt;string, User&gt;();
+			existingChannels = new Dictionary&lt;string, ExistingChannel&gt;();
+			joinedChannels = new Dictionary&lt;string, Channel&gt;();
+			battle = null;
+			battleID = 0;
+			username = &quot;&quot;;
+			isLoggedIn = false;
+			isConnected = false;
+			isChanScanning = false;
+		}
 
-      con.SendCommand(0, &quot;LOGIN&quot;, login, HashPassword(password), mhz, localIp, appinfo);
-    }
+		public void EnableAllUnits()
+		{
+			if (battle != null) {
+				battle.DisabledUnits.Clear();
+				con.SendCommand(0, &quot;ENABLEALLUNITS&quot;);
+				if (BattleDisabledUnitsChanged != null) BattleDisabledUnitsChanged(this, new TasEventArgs(battle.DisabledUnits.ToArray()));
+			}
+		}
 
+		public void ForceAlly(string username, int ally)
+		{
+			con.SendCommand(0, &quot;FORCEALLYNO&quot;, username, ally);
+		}
 
-    public void ListChannels()
-    {
-      isChanScanning = true;
-      existingChannels.Clear();
-      con.SendCommand(0, &quot;CHANNELS&quot;);
-    }
+		public void ForceColor(string username, int color)
+		{
+			con.SendCommand(0, &quot;FORCETEAMCOLOR&quot;, username, color);
+		}
 
-    public Battle GetBattle()
-    {
-      if (battle != null) return (Battle)battle.Clone();
-      else return null;
-    }
+		public void ForceSpectator(string username)
+		{
+			con.SendCommand(0, &quot;FORCESPECTATORMODE&quot;, username);
+		}
 
-    public Dictionary&lt;string, ExistingChannel&gt; GetExistingChannels()
-    {
-      if (isChanScanning) throw new TasClientException(&quot;Channel scan operation in progress&quot;);
-      return new Dictionary&lt;string, ExistingChannel&gt;(existingChannels);
-    }
+		public void ForceTeam(string username, int team)
+		{
+			con.SendCommand(0, &quot;FORCETEAMNO&quot;, username, team);
+		}
 
+		public void GameSaid(string username, string text)
+		{
+			if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Game, &quot;&quot;, username, text, false));
+		}
 
-    public void JoinChannel(string channelName)
-    {
-      JoinChannel(channelName, null);
-    }
+		public Battle GetBattle()
+		{
+			if (battle != null) return (Battle) battle.Clone();
+			else return null;
+		}
 
+		public Dictionary&lt;string, ExistingChannel&gt; GetExistingChannels()
+		{
+			if (isChanScanning) throw new TasClientException(&quot;Channel scan operation in progress&quot;);
+			return new Dictionary&lt;string, ExistingChannel&gt;(existingChannels);
+		}
 
-    public void JoinChannel(string channelName, string key)
-    {
-      if (con == null) throw new TasClientException(&quot;Not connected&quot;);
+		public bool GetExistingUser(string name, out User u)
+		{
+			return existingUsers.TryGetValue(name, out u);
+		}
 
-      if (!String.IsNullOrEmpty(key)) con.SendCommand(0, &quot;JOIN&quot;, channelName, HashPassword(key));
-      else con.SendCommand(0, &quot;JOIN&quot;, channelName);
-    }
+		public Dictionary&lt;string, Channel&gt; GetJoinedChannels()
+		{
+			return new Dictionary&lt;string, Channel&gt;(joinedChannels);
+		}
 
+		/// &lt;summary&gt;
+		/// Hash password with default hash used by remote server
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;pass&quot;&gt;string with password&lt;/param&gt;
+		/// &lt;returns&gt;hash string&lt;/returns&gt;
+		public static string HashPassword(string pass)
+		{
+			var md5 = (MD5) HashAlgorithm.Create(&quot;MD5&quot;);
+			md5.Initialize();
+			var hashed = md5.ComputeHash(Encoding.ASCII.GetBytes(pass));
+			return Convert.ToBase64String(hashed);
+		}
 
-    public void LeaveChannel(string channelName)
-    {
-      con.SendCommand(0, &quot;LEAVE&quot;, channelName);
-      joinedChannels.Remove(channelName);
-      if (ChannelLeft != null) ChannelLeft(this, new TasEventArgs(channelName));
-    }
 
+		public void JoinChannel(string channelName)
+		{
+			JoinChannel(channelName, null);
+		}
 
-    public void ChangeMyStatus(bool isAway, bool isInGame)
-    {
-      User u = new User();
-      u.isAway = isAway;
-      u.isInGame = isInGame;
-      con.SendCommand(0, &quot;MYSTATUS&quot;, u.ToInt());
-    }
 
+		public void JoinChannel(string channelName, string key)
+		{
+			if (con == null) throw new TasClientException(&quot;Not connected&quot;);
 
-    /// &lt;summary&gt;
-    /// Starts game and automatically does hole punching if necessary
-    /// &lt;/summary&gt;
-    public void StartGame()
-    {
-      if (battle != null) {
-        if (battle.Nat == Battle.NatMode.HolePunching) {
-          startingAfterUdpPunch = true;
-          SendUdpPacket(0, serverIp, serverUdpHolePunchingPort);
-          udpPunchingTimer.Start();
-        } else ChangeMyStatus(false, true);
-      }
-    }
+			if (!String.IsNullOrEmpty(key)) con.SendCommand(0, &quot;JOIN&quot;, channelName, HashPassword(key));
+			else con.SendCommand(0, &quot;JOIN&quot;, channelName);
+		}
 
-    private void udpPunchingTimer_Elapsed(object sender, ElapsedEventArgs e)
-    {
-      SendUdpPacket(lastUdpSourcePort, serverIp, serverUdpHolePunchingPort);
-    }
+		public void Kick(string username)
+		{
+			con.SendCommand(0, &quot;KICKFROMBATTLE&quot;, username);
+		}
 
-    private void SendUdpPacket(int sourcePort, IPAddress targetIp, int targetPort)
-    {
-      IPAddress[] ret = Dns.GetHostAddresses(serverHost);
+		public void LeaveBattle()
+		{
+			if (battle != null) {
+				con.SendCommand(0, &quot;LEAVEBATTLE&quot;);
+				battle = null;
+				battleID = 0;
+				if (BattleClosed != null) BattleClosed(this, new TasEventArgs());
+			}
+		}
 
-      Socket s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
 
-      IPEndPoint local = new IPEndPoint(IPAddress.Any, sourcePort);
-      s.Bind(local);
-      //s.ExclusiveAddressUse = false;
-      lastUdpSourcePort = ((IPEndPoint)s.LocalEndPoint).Port;
+		public void LeaveChannel(string channelName)
+		{
+			con.SendCommand(0, &quot;LEAVE&quot;, channelName);
+			joinedChannels.Remove(channelName);
+			if (ChannelLeft != null) ChannelLeft(this, new TasEventArgs(channelName));
+		}
 
-      s.Connect(targetIp, targetPort);
-      s.Send(ASCIIEncoding.ASCII.GetBytes(UserName));
-      s.Close();
-    }
+		public void ListChannels()
+		{
+			isChanScanning = true;
+			existingChannels.Clear();
+			con.SendCommand(0, &quot;CHANNELS&quot;);
+		}
 
+		public void Login(string login, string password, string appinfo)
+		{
+			if (con == null) throw new TasClientException(&quot;Not connected&quot;);
 
-    /// &lt;summary&gt;
-    /// Say something through chat system
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;place&quot;&gt;Pick user (private message) channel or battle&lt;/param&gt;
-    /// &lt;param name=&quot;channel&quot;&gt;Channel or User name&lt;/param&gt;
-    /// &lt;param name=&quot;text&quot;&gt;chat text&lt;/param&gt;
-    /// &lt;param name=&quot;isEmote&quot;&gt;is message emote? (channel or battle only)&lt;/param&gt;
-    public void Say(SayPlace place, string channel, string text, bool isEmote)
-    {
-      if (String.IsNullOrEmpty(text)) return;
-      switch (place) {
-        case SayPlace.Channel:
-          if (isEmote) con.SendCommand(0, &quot;SAYEX&quot;, channel, text);
-          else con.SendCommand(0, &quot;SAY&quot;, channel, text);
-          break;
+			string localIp = Dns.GetHostAddresses(Dns.GetHostName())[0].ToString();
 
-        case SayPlace.User:
-          con.SendCommand(0, &quot;SAYPRIVATE&quot;, channel, text);
-          break;
+			string mhz = Registry.GetValue(&quot;HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\CentralProcessor\\0&quot;, &quot;~MHz&quot;, 0).ToString();
 
-        case SayPlace.Battle:
-          if (isEmote) con.SendCommand(0, &quot;SAYBATTLEEX&quot;, text);
-          else con.SendCommand(0, &quot;SAYBATTLE&quot;, text);
-          break;
-      }
-    }
+			string mhz2 = &quot;&quot;;
 
+			if (Registry.GetValue(&quot;HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\CentralProcessor\\0&quot;, &quot;VendorIdentifier&quot;, 0).ToString().Contains(&quot;AMD&quot;)) {
+				var m = Regex.Match(Registry.GetValue(&quot;HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\SYSTEM\\CentralProcessor\\0&quot;, &quot;ProcessorNameString&quot;, 0).ToString(), &quot;[^0-9]*([0-9]*)&quot;);
+				if (m.Groups.Count &gt; 1) mhz2 = m.Groups[1].Value;
 
-    public void GameSaid(string username, string text)
-    {
-      if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Game, &quot;&quot;, username, text, false));
-    }
+				int i, o;
+				int.TryParse(mhz2, out o);
+				int.TryParse(mhz, out i);
+				if (o &gt; i) mhz = o.ToString();
+			}
 
+			con.SendCommand(0, &quot;LOGIN&quot;, login, HashPassword(password), mhz, localIp, appinfo);
+		}
 
-    public void OpenBattle(Battle nbattle)
-    {
-      LeaveBattle(); // leave current battle
-      battleID = -1;
-      battle = (Battle)nbattle.Clone();
 
-      List&lt;Object&gt; objList = new List&lt;object&gt;();
-      objList.Add(0); // type = normal
-      objList.Add((int)battle.Nat);
-      objList.Add(battle.Password);
-      objList.Add(battle.HostPort);
-      objList.Add(battle.MaxPlayers);
-      ;
-      //battle.Details.AddToParamList(objList);
-      objList.Add(battle.Mod.Checksum);
-      objList.Add(battle.Rank);
-      objList.Add(battle.Map.Checksum);
-      objList.Add(battle.Map.Name);
-      objList.Add('\t' + battle.Title);
-      objList.Add('\t' + battle.Mod.Name);
+		public void OpenBattle(Battle nbattle)
+		{
+			LeaveBattle(); // leave current battle
+			battleID = -1;
+			battle = (Battle) nbattle.Clone();
 
-      mapToChangeTo = battle.Map;
-      lockToChangeTo = false;
+			var objList = new List&lt;object&gt;();
+			objList.Add(0); // type = normal
+			objList.Add((int) battle.Nat);
+			objList.Add(battle.Password);
+			objList.Add(battle.HostPort);
+			objList.Add(battle.MaxPlayers);
+			;
+			//battle.Details.AddToParamList(objList);
+			objList.Add(battle.Mod.Checksum);
+			objList.Add(battle.Rank);
+			objList.Add(battle.Map.Checksum);
+			objList.Add(battle.Map.Name);
+			objList.Add('\t' + battle.Title);
+			objList.Add('\t' + battle.Mod.Name);
 
-      con.SendCommand(0, &quot;OPENBATTLE&quot;, objList.ToArray());
+			mapToChangeTo = battle.Map;
+			lockToChangeTo = false;
 
-      lastSpectatorCount = -1;
+			con.SendCommand(0, &quot;OPENBATTLE&quot;, objList.ToArray());
 
-      // send predefined starting rectangles
-      foreach (KeyValuePair&lt;int, BattleRect&gt; v in battle.Rectangles) con.SendCommand(0, &quot;ADDSTARTRECT&quot;, v.Key, v.Value.Left, v.Value.Top, v.Value.Right, v.Value.Bottom);
-    }
+			lastSpectatorCount = -1;
 
-    public void LeaveBattle()
-    {
-      if (battle != null) {
-        con.SendCommand(0, &quot;LEAVEBATTLE&quot;);
-        battle = null;
-        battleID = 0;
-        if (BattleClosed != null) BattleClosed(this, new TasEventArgs());
-      }
-    }
+			// send predefined starting rectangles
+			foreach (var v in battle.Rectangles) con.SendCommand(0, &quot;ADDSTARTRECT&quot;, v.Key, v.Value.Left, v.Value.Top, v.Value.Right, v.Value.Bottom);
+		}
 
+		public void RemoveBattleRectangle(int allyno)
+		{
+			if (battle != null) {
+				if (battle.Rectangles.ContainsKey(allyno)) {
+					battle.Rectangles.Remove(allyno);
+					con.SendCommand(0, &quot;REMOVESTARTRECT&quot;, allyno);
+				}
+			}
+		}
 
-    public void AddBattleRectangle(int allyno, BattleRect rect)
-    {
-      if (battle != null) {
-        if (allyno &lt; Spring.MaxAllies &amp;&amp; allyno &gt;= 0) {
-          RemoveBattleRectangle(allyno);
-          battle.Rectangles.Add(allyno, rect);
-          con.SendCommand(0, &quot;ADDSTARTRECT&quot;, allyno, rect.Left, rect.Top, rect.Right, rect.Bottom);
-        }
-      }
-    }
+		public void Ring(string username)
+		{
+			con.SendCommand(0, &quot;RING&quot;, username);
+		}
 
-    public void RemoveBattleRectangle(int allyno)
-    {
-      if (battle != null) {
-        if (battle.Rectangles.ContainsKey(allyno)) {
-          battle.Rectangles.Remove(allyno);
-          con.SendCommand(0, &quot;REMOVESTARTRECT&quot;, allyno);
-        }
-      }
-    }
+		/// &lt;summary&gt;
+		/// Say something through chat system
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;place&quot;&gt;Pick user (private message) channel or battle&lt;/param&gt;
+		/// &lt;param name=&quot;channel&quot;&gt;Channel or User name&lt;/param&gt;
+		/// &lt;param name=&quot;text&quot;&gt;chat text&lt;/param&gt;
+		/// &lt;param name=&quot;isEmote&quot;&gt;is message emote? (channel or battle only)&lt;/param&gt;
+		public void Say(SayPlace place, string channel, string text, bool isEmote)
+		{
+			if (String.IsNullOrEmpty(text)) return;
+			switch (place) {
+				case SayPlace.Channel:
+					if (isEmote) con.SendCommand(0, &quot;SAYEX&quot;, channel, text);
+					else con.SendCommand(0, &quot;SAY&quot;, channel, text);
+					break;
 
+				case SayPlace.User:
+					con.SendCommand(0, &quot;SAYPRIVATE&quot;, channel, text);
+					break;
 
-    public void DisableUnits(params string[] units)
-    {
-      if (battle != null) {
-        List&lt;string&gt; tmp = new List&lt;string&gt;(units);
-        foreach (string s in tmp) {
-          if (!battle.DisabledUnits.Contains(s)) {
-            UnitInfo u;
-            if (battle.Mod.GetUnitInfo(s, out u)) battle.DisabledUnits.Add(s);
-          }
-        }
-        if (battle.DisabledUnits.Count &gt; 0) {
-          con.SendCommand(0, &quot;DISABLEUNITS&quot;, battle.DisabledUnits.ToArray());
-          if (BattleDisabledUnitsChanged != null) BattleDisabledUnitsChanged(this, new TasEventArgs(battle.DisabledUnits.ToArray()));
-        }
-      }
-    }
+				case SayPlace.Battle:
+					if (isEmote) con.SendCommand(0, &quot;SAYBATTLEEX&quot;, text);
+					else con.SendCommand(0, &quot;SAYBATTLE&quot;, text);
+					break;
+			}
+		}
 
-    public void EnableAllUnits()
-    {
-      if (battle != null) {
-        battle.DisabledUnits.Clear();
-        con.SendCommand(0, &quot;ENABLEALLUNITS&quot;);
-        if (BattleDisabledUnitsChanged != null) BattleDisabledUnitsChanged(this, new TasEventArgs(battle.DisabledUnits.ToArray()));
-      }
-    }
+		public void SetScriptTag(string data)
+		{
+			con.SendCommand(0, &quot;SETSCRIPTTAGS&quot;, data);
+		}
 
+		/// &lt;summary&gt;
+		/// Starts game and automatically does hole punching if necessary
+		/// &lt;/summary&gt;
+		public void StartGame()
+		{
+			if (battle != null) {
+				if (battle.Nat == Battle.NatMode.HolePunching) {
+					startingAfterUdpPunch = true;
+					SendUdpPacket(0, serverIp, serverUdpHolePunchingPort);
+					udpPunchingTimer.Start();
+				} else ChangeMyStatus(false, true);
+			}
+		}
 
-    private void UpdateBattleInfo(bool lck, MapInfo mapname)
-    {
-      if (battle != null) {
-        lockToChangeTo = lck;
-        con.SendCommand(0, &quot;UPDATEBATTLEINFO&quot;, battle.CountSpectators(), (int)(lck ? 1 : 0), mapname.Checksum, mapname.Name);
-      }
-    }
+		public void UpdateBattleDetails(BattleDetails bd)
+		{
+			if (battle != null) {
+				var objList = new List&lt;object&gt;();
+				con.SendCommand(0, &quot;SETSCRIPTTAGS&quot;, bd.GetParamList());
+			}
+		}
 
+		#endregion
 
-    public void ChangeLock(bool lck)
-    {
-      if (battle != null &amp;&amp; lck != lockToChangeTo) UpdateBattleInfo(lck, mapToChangeTo);
-    }
+		#region Other methods
 
-    private void UpdateSpectators()
-    {
-      if (battle != null) {
-        int n = battle.CountSpectators();
-        if (n != lastSpectatorCount) {
-          lastSpectatorCount = n;
-          con.SendCommand(0, &quot;UPDATEBATTLEINFO&quot;, n, (int)(battle.IsLocked ? 1 : 0), battle.Map.Checksum, battle.Map.Name);
-        }
-      }
-    }
+		/// &lt;summary&gt;
+		/// Primary method - processes commands from server
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;command&quot;&gt;command name&lt;/param&gt;
+		/// &lt;param name=&quot;args&quot;&gt;command arguments&lt;/param&gt;
+		private void DispatchServerCommand(string command, string[] args)
+		{
+			Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+			try {
+				switch (command) {
+					case &quot;TASServer&quot;: // happens after connecting to server
+						serverVersion = args[0];
+						int.TryParse(args[2], out serverUdpHolePunchingPort);
+						isConnected = true;
+						if (Connected != null) Connected(this, new TasEventArgs());
+						break;
 
-    public void ChangeMap(MapInfo nmap)
-    {
-      if (battle != null) {
-        mapToChangeTo = nmap;
-        UpdateBattleInfo(lockToChangeTo, nmap);
-      }
-    }
+					case &quot;ACCEPTED&quot;: // Login accepted
+						username = args[0];
+						isLoggedIn = true;
+						if (LoginAccepted != null) LoginAccepted(this, new TasEventArgs());
+						break;
 
-    public void UpdateBattleDetails(BattleDetails bd)
-    {
-      if (battle != null) {
-        List&lt;object&gt; objList = new List&lt;object&gt;();
-        con.SendCommand(0, &quot;SETSCRIPTTAGS&quot;, bd.GetParamList());
-      }
-    }
+					case &quot;DENIED&quot;: // login denied
+						isLoggedIn = false;
+						if (LoginDenied != null) LoginDenied(this, new TasEventArgs(Utils.Glue(args)));
+						break;
 
-    public void SetScriptTag(string data)
-    {
-      con.SendCommand(0, &quot;SETSCRIPTTAGS&quot;, data);
-    }
+					case &quot;JOIN&quot;: // channel joined
+						if (!joinedChannels.ContainsKey(args[0])) joinedChannels.Add(args[0], Channel.Create(args[0]));
+						if (ChannelJoined != null) ChannelJoined(this, new TasEventArgs(args));
+						break;
 
+					case &quot;JOINFAILED&quot;: // channel join failed
+						if (ChannelJoinFailed != null) ChannelJoinFailed(this, new TasEventArgs(Utils.Glue(args)));
+						break;
 
-    private void OnConnectionClosed(object sender, EventArgs args)
-    {
-      if (sender == con) {
-        isConnected = false;
-        if (ConnectionLost != null) ConnectionLost(this, new TasEventArgs(&quot;Connection was closed&quot;));
-        Disconnect();
-      }
-    }
+					case &quot;CHANNEL&quot;: // iterating channels
+					{
+						var c = new ExistingChannel();
+						c.name = args[0];
+						int.TryParse(args[1], out c.userCount);
+						if (args.Length &gt;= 3) c.topic = Utils.Glue(args, 2);
+						existingChannels.Add(c.name, c);
+					}
+						break;
 
-    private void OnCommandRecieved(object sender, ServerConnectionEventArgs args)
-    {
-      if (sender == con) DispatchServerCommand(args.Command, (string[])args.Parameters);
-    }
+					case &quot;ENDOFCHANNELS&quot;: // end of channel list iteration
+						isChanScanning = false;
+						if (ChannelListDone != null) ChannelListDone(this, new TasEventArgs());
+						break;
 
-    /// &lt;summary&gt;
-    /// purpose of this event handler is to redirect &quot;fail&quot; events to failure event too
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
-    /// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
-    private void RaiseFailure(object sender, TasEventArgs args)
-    {
-      if (Failure != null) Failure(this, args);
-    }
+					case &quot;ADDUSER&quot;: // new user joined ta server
+					{
+						var u = User.Create(args[0]);
+						u.country = args[1];
+						int.TryParse(args[2], out u.cpu);
+						//IPAddress.TryParse(args[3], out u.ip);
+						existingUsers.Add(u.name, u);
+						if (UserAdded != null) UserAdded(this, new TasEventArgs(args));
+					}
+						break;
 
+					case &quot;REMOVEUSER&quot;: // user left ta server
+						existingUsers.Remove(args[0]);
+						if (UserRemoved != null) UserRemoved(this, new TasEventArgs(args));
+						break;
 
-    /// &lt;summary&gt;
-    /// Hash password with default hash used by remote server
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;pass&quot;&gt;string with password&lt;/param&gt;
-    /// &lt;returns&gt;hash string&lt;/returns&gt;
-    public static string HashPassword(string pass)
-    {
-      MD5 md5 = (MD5)HashAlgorithm.Create(&quot;MD5&quot;);
-      md5.Initialize();
-      byte[] hashed = md5.ComputeHash(ASCIIEncoding.ASCII.GetBytes(pass));
-      return Convert.ToBase64String(hashed);
-    }
+					case &quot;MOTD&quot;: // server motd
+						if (Said != null &amp;&amp; args.Length &gt; 0) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Motd, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
+						break;
 
+					case &quot;SERVERMSG&quot;: // server message
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Normal, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
+						break;
 
-    public void Ring(string username)
-    {
-      con.SendCommand(0, &quot;RING&quot;, username);
-    }
+					case &quot;SERVERMSGBOX&quot;: // server messagebox
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.MessageBox, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
+						break;
 
+					case &quot;CHANNELMESSAGE&quot;: // server broadcast to channel
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Channel, args[0], &quot;&quot;, Utils.Glue(args, 1), false));
+						break;
 
-    public void Kick(string username)
-    {
-      con.SendCommand(0, &quot;KICKFROMBATTLE&quot;, username);
-    }
+					case &quot;SAID&quot;: // someone said something in channel
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Channel, args[0], args[1], Utils.Glue(args, 2), false));
+						break;
 
-    public void ForceTeam(string username, int team)
-    {
-      con.SendCommand(0, &quot;FORCETEAMNO&quot;, username, team);
-    }
+					case &quot;SAIDEX&quot;: // someone said something with emote in channel
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Channel, args[0], args[1], Utils.Glue(args, 2), true));
+						break;
 
-    public void ForceAlly(string username, int ally)
-    {
-      con.SendCommand(0, &quot;FORCEALLYNO&quot;, username, ally);
-    }
+					case &quot;SAYPRIVATE&quot;: // sent back from sever when user sends private message
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Normal, args[0], username, Utils.Glue(args, 1), false)); // channel = char partner name
+						break;
 
-    public void ForceSpectator(string username)
-    {
-      con.SendCommand(0, &quot;FORCESPECTATORMODE&quot;, username);
-    }
+					case &quot;SAIDPRIVATE&quot;: // someone said something to me
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Normal, args[0], args[0], Utils.Glue(args, 1), false));
+						break;
 
+					case &quot;SAIDBATTLE&quot;: // someone said something in battle
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Battle, &quot;&quot;, args[0], Utils.Glue(args, 1), false));
+						break;
 
-    public void ForceColor(string username, int color)
-    {
-      con.SendCommand(0, &quot;FORCETEAMCOLOR&quot;, username, color);
-    }
+					case &quot;SAIDBATTLEEX&quot;: // someone said in battle with emote
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Battle, &quot;&quot;, args[0], Utils.Glue(args, 1), true));
+						break;
 
-    /// &lt;summary&gt;
-    /// Primary method - processes commands from server
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;command&quot;&gt;command name&lt;/param&gt;
-    /// &lt;param name=&quot;args&quot;&gt;command arguments&lt;/param&gt;
-    private void DispatchServerCommand(string command, string[] args)
-    {
-      Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
-      try {
-        switch (command) {
-          case &quot;TASServer&quot;: // happens after connecting to server
-            serverVersion = args[0];
-            int.TryParse(args[2], out serverUdpHolePunchingPort);
-            isConnected = true;
-            if (Connected != null) Connected(this, new TasEventArgs());
-            break;
+					case &quot;BROADCAST&quot;: // server sends urgent broadcast
+						if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Broadcast, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
+						break;
 
-          case &quot;ACCEPTED&quot;: // Login accepted
-            username = args[0];
-            isLoggedIn = true;
-            if (LoginAccepted != null) LoginAccepted(this, new TasEventArgs());
-            break;
+					case &quot;REDIRECT&quot;: // server sends backup IP
+						// removed due to bugs         
+						break;
 
-          case &quot;DENIED&quot;: // login denied
-            isLoggedIn = false;
-            if (LoginDenied != null) LoginDenied(this, new TasEventArgs(Utils.Glue(args)));
-            break;
+					case &quot;CLIENTSTATUS&quot;: // client's status changed
+					{
+						int status = 0;
+						int.TryParse(args[1], out status);
+						var u = existingUsers[args[0]];
+						u.FromInt(status);
 
-          case &quot;JOIN&quot;: // channel joined
-            if (!joinedChannels.ContainsKey(args[0])) joinedChannels.Add(args[0], Channel.Create(args[0]));
-            if (ChannelJoined != null) ChannelJoined(this, new TasEventArgs(args));
-            break;
+						if (u.name == UserName &amp;&amp; (u.isInGame &amp;&amp; existingUsers[args[0]].isInGame == false)) {
+							existingUsers[args[0]] = u;
+							if (MyStatusChangedToInGame != null) MyStatusChangedToInGame(this, new TasEventArgs());
+						}
 
-          case &quot;JOINFAILED&quot;: // channel join failed
-            if (ChannelJoinFailed != null) ChannelJoinFailed(this, new TasEventArgs(Utils.Glue(args)));
-            break;
+						existingUsers[args[0]] = u;
+						if (UserStatusChanged != null) UserStatusChanged(this, new TasEventArgs(args));
+					}
+						break;
 
-          case &quot;CHANNEL&quot;: // iterating channels
-            {
-              ExistingChannel c = new ExistingChannel();
-              c.name = args[0];
-              int.TryParse(args[1], out c.userCount);
-              if (args.Length &gt;= 3) c.topic = Utils.Glue(args, 2);
-              existingChannels.Add(c.name, c);
-            }
-            break;
+					case &quot;CLIENTS&quot;: // client list sent after channel join
+						var usrs = Utils.Glue(args, 1).Split(' ');
+						foreach (var s in usrs) joinedChannels[args[0]].channelUsers.Add(s);
+						if (ChannelUserAdded != null) ChannelUserAdded(this, new TasEventArgs(args[0]));
+						break;
 
-          case &quot;ENDOFCHANNELS&quot;: // end of channel list iteration
-            isChanScanning = false;
-            if (ChannelListDone != null) ChannelListDone(this, new TasEventArgs());
-            break;
+					case &quot;JOINED&quot;: // user joined one of my channels
+						joinedChannels[args[0]].channelUsers.Add(args[1]);
+						if (ChannelUserAdded != null) ChannelUserAdded(this, new TasEventArgs(args[0]));
+						break;
 
-          case &quot;ADDUSER&quot;: // new user joined ta server
-            {
-              User u = User.Create(args[0]);
-              u.country = args[1];
-              int.TryParse(args[2], out u.cpu);
-              //IPAddress.TryParse(args[3], out u.ip);
-              existingUsers.Add(u.name, u);
-              if (UserAdded != null) UserAdded(this, new TasEventArgs(args));
-            }
-            break;
+					case &quot;LEFT&quot;: // user left one of my channels
+						joinedChannels[args[0]].channelUsers.Remove(args[1]);
+						if (ChannelUserRemoved != null) ChannelUserRemoved(this, new TasEventArgs(args[0], args[1], Utils.Glue(args, 2)));
+						break;
 
-          case &quot;REMOVEUSER&quot;: // user left ta server
-            existingUsers.Remove(args[0]);
-            if (UserRemoved != null) UserRemoved(this, new TasEventArgs(args));
-            break;
+					case &quot;CHANNELTOPIC&quot;: // channel topic update (after joining a channel)
+					{
+						var c = joinedChannels[args[0]];
+						c.topicSetBy = args[1];
+						c.topicSetDate = ConvertMilisecondTime(args[2]);
+						c.topic = Utils.Glue(args, 3);
+						if (ChannelTopicChanged != null) ChannelTopicChanged(this, new TasEventArgs(args[0]));
+					}
+						break;
 
-          case &quot;MOTD&quot;: // server motd
-            if (Said != null &amp;&amp; args.Length &gt; 0) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Motd, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
-            break;
+					case &quot;OPENBATTLEFAILED&quot;: // opening new battle has failed
+						if (BattleOpenFailed != null) BattleOpenFailed(this, new TasEventArgs(Utils.Glue(args)));
+						break;
 
-          case &quot;SERVERMSG&quot;: // server message
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Normal, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
-            break;
+					case &quot;OPENBATTLE&quot;: // openbattle ok
+					{
+						battleID = int.Parse(args[0]);
+						var self = new UserBattleStatus(username);
+						self.IsSpectator = true;
+						battle.Users.Add(self); // add self
+						UpdateBattleDetails(battle.Details);
+						if (BattleOpened != null) BattleOpened(this, new TasEventArgs(args[0]));
+					}
+						break;
 
-          case &quot;SERVERMSGBOX&quot;: // server messagebox
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.MessageBox, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
-            break;
+					case &quot;REQUESTBATTLESTATUS&quot;: // server asks us to update our status
+						con.SendCommand(0, &quot;MYBATTLESTATUS&quot;, 1 &lt;&lt; 22, 0); // tell server that we are synchronized  spectators
+						break;
 
-          case &quot;CHANNELMESSAGE&quot;: // server broadcast to channel
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Channel, args[0], &quot;&quot;, Utils.Glue(args, 1), false));
-            break;
+					case &quot;JOINEDBATTLE&quot;: // user joined the battle
+						if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
+							battle.Users.Add(new UserBattleStatus(args[1]));
+							if (BattleUserJoined != null) BattleUserJoined(this, new TasEventArgs(args[1]));
+						}
+						break;
 
-          case &quot;SAID&quot;: // someone said something in channel
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Channel, args[0], args[1], Utils.Glue(args, 2), false));
-            break;
+					case &quot;ADDBOT&quot;: // bot added to battle
+						if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
+							var bs = new BotBattleStatus(args[1], args[2], Utils.Glue(args, 5));
+							bs.SetFrom(int.Parse(args[3]), int.Parse(args[4]));
+							battle.Bots.Add(bs);
+						}
+						break;
 
-          case &quot;SAIDEX&quot;: // someone said something with emote in channel
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Channel, args[0], args[1], Utils.Glue(args, 2), true));
-            break;
+					case &quot;REMOVEBOT&quot;: // bot removed from battle
+						if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) battle.Bots.RemoveAll(delegate(BotBattleStatus bot) { return bot.name == args[1]; });
+						break;
 
-          case &quot;SAYPRIVATE&quot;: // sent back from sever when user sends private message
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Normal, args[0], username, Utils.Glue(args, 1), false)); // channel = char partner name
-            break;
+					case &quot;UPDATEBOT&quot;: // bot data changed
+						if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
+							var st = battle.Bots.Find(delegate(BotBattleStatus bot) { return bot.name == args[1]; });
+							if (st != null) st.SetFrom(int.Parse(args[2]), int.Parse(args[3]));
+						}
+						break;
 
-          case &quot;SAIDPRIVATE&quot;: // someone said something to me
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Normal, args[0], args[0], Utils.Glue(args, 1), false));
-            break;
 
-          case &quot;SAIDBATTLE&quot;: // someone said something in battle
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Battle, &quot;&quot;, args[0], Utils.Glue(args, 1), false));
-            break;
+					case &quot;LEFTBATTLE&quot;: // user left the battle
+						if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
+							battle.RemoveUser(args[1]);
+							UpdateSpectators();
+							if (BattleUserLeft != null) BattleUserLeft(this, new TasEventArgs(args[1]));
+							if (args[1] == username) {
+								battle = null;
+								battleID = 0;
+								if (BattleClosed != null) BattleClosed(this, new TasEventArgs());
+							}
+						}
+						break;
 
-          case &quot;SAIDBATTLEEX&quot;: // someone said in battle with emote
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Player, TasSayEventArgs.Places.Battle, &quot;&quot;, args[0], Utils.Glue(args, 1), true));
-            break;
+					case &quot;CLIENTBATTLESTATUS&quot;: // player battle status has changed
+						if (battle != null) {
+							int uindex = battle.GetUserIndex(args[0]);
+							if (uindex != -1) {
+								var bs = battle.Users[uindex];
+								bs.SetFrom(int.Parse(args[1]), int.Parse(args[2]));
+								battle.Users[uindex] = bs;
+								UpdateSpectators();
+								if (BattleUserStatusChanged != null) BattleUserStatusChanged(this, new TasEventArgs(args[0]));
+							}
+						}
+						break;
 
-          case &quot;BROADCAST&quot;: // server sends urgent broadcast
-            if (Said != null) Said(this, new TasSayEventArgs(TasSayEventArgs.Origins.Server, TasSayEventArgs.Places.Broadcast, &quot;&quot;, &quot;&quot;, Utils.Glue(args, 0), false));
-            break;
+					case &quot;UPDATEBATTLEINFO&quot;: // update external battle info (lock and map)
+						if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
+							string mapname = Utils.Glue(args, 4);
+							if (battle.Map.Name != mapname) {
+								if (mapToChangeTo != null &amp;&amp; mapToChangeTo.Name == mapname) {
+									// if we changed to known requested map, use it
+									battle.Map = mapToChangeTo;
+								} else battle.Map = Program.main.Spring.UnitSync.MapList[mapname]; //otherwise find this map using unitsync
+								if (BattleMapChanged != null) BattleMapChanged(this, new TasEventArgs(mapname));
+							}
 
-          case &quot;REDIRECT&quot;: // server sends backup IP
-            // removed due to bugs         
-            break;
+							if (battle.IsLocked != int.Parse(args[2]) &gt; 0) {
+								battle.IsLocked = int.Parse(args[2]) &gt; 0;
+								if (BattleLockChanged != null) BattleLockChanged(this, new TasEventArgs(args[2]));
+							}
+						}
+						break;
 
-          case &quot;CLIENTSTATUS&quot;: // client's status changed
-            {
-              int status = 0;
-              int.TryParse(args[1], out status);
-              User u = existingUsers[args[0]];
-              u.FromInt(status);
+					case &quot;BATTLEOPENED&quot;:
+					{
+						if (BattleFound != null) BattleFound(this, new TasEventArgs(args));
+						break;
+					}
 
-              if (u.name == UserName &amp;&amp; (u.isInGame == true &amp;&amp; existingUsers[args[0]].isInGame == false)) {
-                existingUsers[args[0]] = u;
-                if (MyStatusChangedToInGame != null) MyStatusChangedToInGame(this, new TasEventArgs());
-              }
+					case &quot;CLIENTIPPORT&quot;:
+						if (battle != null) {
+							int idx = battle.GetUserIndex(args[0]);
+							if (idx != -1) {
+								var bs = battle.Users[idx];
+								bs.ip = IPAddress.Parse(args[1]);
+								bs.port = int.Parse(args[2]);
+								battle.Users[idx] = bs;
+								if (BattleUserIpRecieved != null) BattleUserIpRecieved(this, new TasEventArgs(args));
+							}
+						}
+						break;
 
-              existingUsers[args[0]] = u;
-              if (UserStatusChanged != null) UserStatusChanged(this, new TasEventArgs(args));
-            }
-            break;
+					case &quot;SETSCRIPTTAGS&quot;: // updates internal battle details
+						if (battle != null) {
+							var bd = new BattleDetails();
+							bd.Parse(Utils.Glue(args), battle.ModOptions);
+							battle.Details = bd;
+							if (BattleDetailsChanged != null) BattleDetailsChanged(this, new TasEventArgs(args));
+						}
+						break;
 
-          case &quot;CLIENTS&quot;: // client list sent after channel join
-            string[] usrs = Utils.Glue(args, 1).Split(' ');
-            foreach (string s in usrs) joinedChannels[args[0]].channelUsers.Add(s);
-            if (ChannelUserAdded != null) ChannelUserAdded(this, new TasEventArgs(args[0]));
-            break;
+					case &quot;UDPSOURCEPORT&quot;:
+						udpPunchingTimer.Stop();
+						if (startingAfterUdpPunch) {
+							startingAfterUdpPunch = false;
+							if (battle != null) {
+								// send UDP packets to client (2x to be sure)
+								foreach (var ubs in battle.Users) if (ubs.ip != IPAddress.None &amp;&amp; ubs.port != 0) SendUdpPacket(lastUdpSourcePort, ubs.ip, ubs.port);
+								foreach (var ubs in battle.Users) if (ubs.ip != IPAddress.None &amp;&amp; ubs.port != 0) SendUdpPacket(lastUdpSourcePort, ubs.ip, ubs.port);
 
-          case &quot;JOINED&quot;: // user joined one of my channels
-            joinedChannels[args[0]].channelUsers.Add(args[1]);
-            if (ChannelUserAdded != null) ChannelUserAdded(this, new TasEventArgs(args[0]));
-            break;
+								battle.HostPort = lastUdpSourcePort; // update source port for hosting and start it
+								ChangeMyStatus(false, true);
+							}
+						}
+						break;
+				}
+			} catch (Exception e) {
+				if (!ErrorHandling.HandleException(e, &quot;Exception while dispatching &quot; + command + &quot; &quot; + Utils.Glue(args))) throw e;
+			}
+			;
+		}
 
-          case &quot;LEFT&quot;: // user left one of my channels
-            joinedChannels[args[0]].channelUsers.Remove(args[1]);
-            if (ChannelUserRemoved != null) ChannelUserRemoved(this, new TasEventArgs(args[0], args[1], Utils.Glue(args, 2)));
-            break;
+		private void SendUdpPacket(int sourcePort, IPAddress targetIp, int targetPort)
+		{
+			var ret = Dns.GetHostAddresses(serverHost);
 
-          case &quot;CHANNELTOPIC&quot;: // channel topic update (after joining a channel)
-            {
-              Channel c = joinedChannels[args[0]];
-              c.topicSetBy = args[1];
-              c.topicSetDate = ConvertMilisecondTime(args[2]);
-              c.topic = Utils.Glue(args, 3);
-              if (ChannelTopicChanged != null) ChannelTopicChanged(this, new TasEventArgs(args[0]));
-            }
-            break;
+			var s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
 
-          case &quot;OPENBATTLEFAILED&quot;: // opening new battle has failed
-            if (BattleOpenFailed != null) BattleOpenFailed(this, new TasEventArgs(Utils.Glue(args)));
-            break;
+			var local = new IPEndPoint(IPAddress.Any, sourcePort);
+			s.Bind(local);
+			//s.ExclusiveAddressUse = false;
+			lastUdpSourcePort = ((IPEndPoint) s.LocalEndPoint).Port;
 
-          case &quot;OPENBATTLE&quot;: // openbattle ok
-            {
-              battleID = int.Parse(args[0]);
-              UserBattleStatus self = new UserBattleStatus(username);
-              self.IsSpectator = true;
-              battle.Users.Add(self); // add self
-              UpdateBattleDetails(battle.Details);
-              if (BattleOpened != null) BattleOpened(this, new TasEventArgs(args[0]));
-            }
-            break;
+			s.Connect(targetIp, targetPort);
+			s.Send(Encoding.ASCII.GetBytes(UserName));
+			s.Close();
+		}
 
-          case &quot;REQUESTBATTLESTATUS&quot;: // server asks us to update our status
-            con.SendCommand(0, &quot;MYBATTLESTATUS&quot;, 1 &lt;&lt; 22, 0); // tell server that we are synchronized  spectators
-            break;
 
-          case &quot;JOINEDBATTLE&quot;: // user joined the battle
-            if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
-              battle.Users.Add(new UserBattleStatus(args[1]));
-              if (BattleUserJoined != null) BattleUserJoined(this, new TasEventArgs(args[1]));
-            }
-            break;
+		private void UpdateBattleInfo(bool lck, MapInfo mapname)
+		{
+			if (battle != null) {
+				lockToChangeTo = lck;
+				con.SendCommand(0, &quot;UPDATEBATTLEINFO&quot;, battle.CountSpectators(), (lck ? 1 : 0), mapname.Checksum, mapname.Name);
+			}
+		}
 
-          case &quot;ADDBOT&quot;: // bot added to battle
-            if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
-              BotBattleStatus bs = new BotBattleStatus(args[1], args[2], Utils.Glue(args, 5));
-              bs.SetFrom(int.Parse(args[3]), int.Parse(args[4]));
-              battle.Bots.Add(bs);
-            }
-            break;
 
-          case &quot;REMOVEBOT&quot;: // bot removed from battle
-            if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
-              battle.Bots.RemoveAll(delegate(BotBattleStatus bot) { return bot.name == args[1]; });
-            }
-            break;
+		private void UpdateSpectators()
+		{
+			if (battle != null) {
+				int n = battle.CountSpectators();
+				if (n != lastSpectatorCount) {
+					lastSpectatorCount = n;
+					con.SendCommand(0, &quot;UPDATEBATTLEINFO&quot;, n, (battle.IsLocked ? 1 : 0), battle.Map.Checksum, battle.Map.Name);
+				}
+			}
+		}
 
-          case &quot;UPDATEBOT&quot;: // bot data changed
-            if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
-              BotBattleStatus st = battle.Bots.Find(delegate(BotBattleStatus bot) { return bot.name == args[1]; });
-              if (st != null) {
-                st.SetFrom(int.Parse(args[2]), int.Parse(args[3]));
-              }
-            }
-            break;
-           
+		#endregion
 
+		#region Event Handlers
 
-          case &quot;LEFTBATTLE&quot;: // user left the battle
-            if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
-              battle.RemoveUser(args[1]);
-              UpdateSpectators();
-              if (BattleUserLeft != null) BattleUserLeft(this, new TasEventArgs(args[1]));
-              if (args[1] == username) {
-                battle = null;
-                battleID = 0;
-                if (BattleClosed != null) BattleClosed(this, new TasEventArgs());
-              }
-            }
-            break;
+		private void OnCommandRecieved(object sender, ServerConnectionEventArgs args)
+		{
+			if (sender == con) DispatchServerCommand(args.Command, (string[]) args.Parameters);
+		}
 
-          case &quot;CLIENTBATTLESTATUS&quot;: // player battle status has changed
-            if (battle != null) {
-              int uindex = battle.GetUserIndex(args[0]);
-              if (uindex != -1) {
-                UserBattleStatus bs = battle.Users[uindex];
-                bs.SetFrom(int.Parse(args[1]), int.Parse(args[2]));
-                battle.Users[uindex] = bs;
-                UpdateSpectators();
-                if (BattleUserStatusChanged != null) BattleUserStatusChanged(this, new TasEventArgs(args[0]));
-              }
-            }
-            break;
+		private void OnConnectionClosed(object sender, EventArgs args)
+		{
+			if (sender == con) {
+				isConnected = false;
+				if (ConnectionLost != null) ConnectionLost(this, new TasEventArgs(&quot;Connection was closed&quot;));
+				Disconnect();
+			}
+		}
 
-          case &quot;UPDATEBATTLEINFO&quot;: // update external battle info (lock and map)
-            if (battle != null &amp;&amp; int.Parse(args[0]) == battleID) {
-              string mapname = Utils.Glue(args, 4);
-              if (battle.Map.Name != mapname) {
-                if (mapToChangeTo != null &amp;&amp; mapToChangeTo.Name == mapname) {
-                  // if we changed to known requested map, use it
-                  battle.Map = mapToChangeTo;
-                } else battle.Map = Program.main.Spring.UnitSync.MapList[mapname]; //otherwise find this map using unitsync
-                if (BattleMapChanged != null) BattleMapChanged(this, new TasEventArgs(mapname));
-              }
+		private void OnPingTimer(object sender, EventArgs args)
+		{
+			if (isConnected &amp;&amp; con != null) con.SendCommand(0, &quot;PING&quot;);
+		}
 
-              if (battle.IsLocked != int.Parse(args[2]) &gt; 0) {
-                battle.IsLocked = int.Parse(args[2]) &gt; 0;
-                if (BattleLockChanged != null) BattleLockChanged(this, new TasEventArgs(args[2]));
-              }
-            }
-            break;
+		/// &lt;summary&gt;
+		/// purpose of this event handler is to redirect &quot;fail&quot; events to failure event too
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt;
+		/// &lt;param name=&quot;args&quot;&gt;&lt;/param&gt;
+		private void RaiseFailure(object sender, TasEventArgs args)
+		{
+			if (Failure != null) Failure(this, args);
+		}
 
-          case &quot;BATTLEOPENED&quot;:
-            {
-              if (BattleFound != null) BattleFound(this, new TasEventArgs(args));
-              break;
-            }
+		private void udpPunchingTimer_Elapsed(object sender, ElapsedEventArgs e)
+		{
+			SendUdpPacket(lastUdpSourcePort, serverIp, serverUdpHolePunchingPort);
+		}
 
-          case &quot;CLIENTIPPORT&quot;:
-            if (battle != null) {
-              int idx = battle.GetUserIndex(args[0]);
-              if (idx != -1) {
-                UserBattleStatus bs = battle.Users[idx];
-                bs.ip = IPAddress.Parse(args[1]);
-                bs.port = int.Parse(args[2]);
-                battle.Users[idx] = bs;
-                if (BattleUserIpRecieved != null) BattleUserIpRecieved(this, new TasEventArgs(args));
-              }
-            }
-            break;
-
-          case &quot;SETSCRIPTTAGS&quot;: // updates internal battle details
-            if (battle != null) {
-              BattleDetails bd = new BattleDetails();
-              bd.Parse(Utils.Glue(args), battle.ModOptions);
-              battle.Details = bd;
-              if (BattleDetailsChanged != null) BattleDetailsChanged(this, new TasEventArgs(args));
-            }
-            break;
-
-          case &quot;UDPSOURCEPORT&quot;:
-            udpPunchingTimer.Stop();
-            if (startingAfterUdpPunch) {
-              startingAfterUdpPunch = false;
-              if (battle != null) {
-                // send UDP packets to client (2x to be sure)
-                foreach (UserBattleStatus ubs in battle.Users) if (ubs.ip != IPAddress.None &amp;&amp; ubs.port != 0) SendUdpPacket(lastUdpSourcePort, ubs.ip, ubs.port);
-                foreach (UserBattleStatus ubs in battle.Users) if (ubs.ip != IPAddress.None &amp;&amp; ubs.port != 0) SendUdpPacket(lastUdpSourcePort, ubs.ip, ubs.port);
-
-                battle.HostPort = lastUdpSourcePort; // update source port for hosting and start it
-                ChangeMyStatus(false, true);
-              }
-            }
-            break;
-        }
-      } catch (Exception e) {
-        if (!ErrorHandling.HandleException(e, &quot;Exception while dispatching &quot; + command + &quot; &quot; + Utils.Glue(args))) throw e;
-      }
-      ;
-    }
-
-
-    public static DateTime ConvertMilisecondTime(string arg)
-    {
-      return (new DateTime(1970, 1, 1, 0, 0, 0)).AddMilliseconds(long.Parse(arg));
-    }
-  }
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/TasClient_structures.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/TasClient_structures.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/TasClient_structures.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,179 +1,199 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 
+#endregion
+
 namespace Springie.Client
 {
-  // NOTE: all these stuffs are actually structures.. Why? To protected data from being modified when accessed by other modules. I'm too lazy to sort rights and make proper classes.
-  /// &lt;summary&gt;
-  /// Channel - active joined channels
-  /// &lt;/summary&gt;
-  public struct Channel
-  {
-    public List&lt;string&gt; channelUsers;
-    public string name;
-    public string topic;
-    public string topicSetBy;
-    public DateTime topicSetDate;
+	// NOTE: all these stuffs are actually structures.. Why? To protected data from being modified when accessed by other modules. I'm too lazy to sort rights and make proper classes.
+	/// &lt;summary&gt;
+	/// Channel - active joined channels
+	/// &lt;/summary&gt;
+	public struct Channel
+	{
+		#region Properties
 
-    public static Channel Create(string name)
-    {
-      Channel c = new Channel();
-      c.name = name;
-      c.channelUsers = new List&lt;string&gt;();
-      return c;
-    }
-  } ;
+		public List&lt;string&gt; channelUsers;
+		public string name;
+		public string topic;
+		public string topicSetBy;
+		public DateTime topicSetDate;
 
-  /// &lt;summary&gt;
-  /// Basic channel information - for channel enumeration
-  /// &lt;/summary&gt;
-  public struct ExistingChannel
-  {
-    public string name;
-    public string topic;
-    public int userCount;
-  } ;
+		#endregion
 
+		#region Public methods
 
-  /// &lt;summary&gt;
-  /// User - on the server
-  /// &lt;/summary&gt;
-  public struct User
-  {
-    public string country;
-    public int cpu;
-    public bool isAdmin;
-    public bool isAway;
-    public bool isInGame;
-    public string name;
-    public int rank;
+		public static Channel Create(string name)
+		{
+			var c = new Channel();
+			c.name = name;
+			c.channelUsers = new List&lt;string&gt;();
+			return c;
+		}
 
-    public static User Create(string name)
-    {
-      User u = new User();
-      u.name = name;
-      return u;
-    }
+		#endregion
+	} ;
 
-    public void FromInt(int status)
-    {
-      isInGame = (status &amp; 1) &gt; 0;
-      isAway = (status &amp; 2) &gt; 0;
-      isAdmin = (status &amp; 32) &gt; 0;
-      rank = (status &amp; 28) &gt;&gt; 2;
-    }
+	/// &lt;summary&gt;
+	/// Basic channel information - for channel enumeration
+	/// &lt;/summary&gt;
+	public struct ExistingChannel
+	{
+		#region Properties
 
-    public int ToInt()
-    {
-      int res = 0;
-      res |= isInGame ? 1 : 0;
-      res |= isAway ? 2 : 0;
-      return res;
-    }
-  } ;
+		public string name;
+		public string topic;
+		public int userCount;
 
+		#endregion
+	} ;
 
-  public class TasEventArgs : EventArgs
-  {
-    private List&lt;string&gt; serverParams = new List&lt;string&gt;();
 
-    public TasEventArgs() {}
+	/// &lt;summary&gt;
+	/// User - on the server
+	/// &lt;/summary&gt;
+	public struct User
+	{
+		#region Properties
 
-    public TasEventArgs(params string[] serverParams)
-    {
-      this.serverParams = new List&lt;string&gt;(serverParams);
-    }
+		public string country;
+		public int cpu;
+		public bool isAdmin;
+		public bool isAway;
+		public bool isInGame;
+		public string name;
+		public int rank;
 
-    public List&lt;string&gt; ServerParams
-    {
-      get { return serverParams; }
-      set { serverParams = value; }
-    }
-  } ;
+		#endregion
 
+		#region Public methods
 
-  public class TasSayEventArgs : EventArgs
-  {
-    #region Origins enum
-    public enum Origins
-    {
-      Server,
-      Player
-    }
-    #endregion
+		public static User Create(string name)
+		{
+			var u = new User();
+			u.name = name;
+			return u;
+		}
 
-    #region Places enum
-    public enum Places
-    {
-      Normal,
-      Motd,
-      Channel,
-      Battle,
-      MessageBox,
-      Broadcast,
-      Game
-    }
-    #endregion
+		public void FromInt(int status)
+		{
+			isInGame = (status &amp; 1) &gt; 0;
+			isAway = (status &amp; 2) &gt; 0;
+			isAdmin = (status &amp; 32) &gt; 0;
+			rank = (status &amp; 28) &gt;&gt; 2;
+		}
 
-    public static TasSayEventArgs Default = new TasSayEventArgs(Origins.Player, Places.Battle, &quot;&quot;, &quot;&quot;, &quot;&quot;, false);
-    private string channel;
-    private bool isEmote;
+		public int ToInt()
+		{
+			int res = 0;
+			res |= isInGame ? 1 : 0;
+			res |= isAway ? 2 : 0;
+			return res;
+		}
 
-    private Origins origin;
-    private Places place;
-    private string text;
-    private string userName;
+		#endregion
+	} ;
 
-    public TasSayEventArgs(Origins origin, Places place, string channel, string username, string text, bool isEmote)
-    {
-      this.origin = origin;
-      this.place = place;
-      userName = username;
-      this.text = text;
-      this.isEmote = isEmote;
-      this.channel = channel;
-    }
 
-    public string Channel
-    {
-      get { return channel; }
-      set { channel = value; }
-    }
+	public class TasEventArgs : EventArgs
+	{
+		#region Fields
 
-    public bool IsEmote
-    {
-      get { return isEmote; }
-      set { isEmote = value; }
-    }
+		private List&lt;string&gt; serverParams = new List&lt;string&gt;();
 
-    public Origins Origin
-    {
-      get { return origin; }
-      set { origin = value; }
-    }
+		#endregion
 
-    public Places Place
-    {
-      get { return place; }
-      set { place = value; }
-    }
+		#region Properties
 
-    public string Text
-    {
-      get { return text; }
-      set { text = value; }
-    }
+		public List&lt;string&gt; ServerParams
+		{
+			get { return serverParams; }
+			set { serverParams = value; }
+		}
 
-    public string UserName
-    {
-      get { return userName; }
-      set { userName = value; }
-    }
-  } ;
+		#endregion
 
-  public class TasClientException : Exception
-  {
-    public TasClientException() {}
-    public TasClientException(string message) : base(message) {}
-  } ;
+		#region Constructors
+
+		public TasEventArgs() {}
+
+		public TasEventArgs(params string[] serverParams)
+		{
+			this.serverParams = new List&lt;string&gt;(serverParams);
+		}
+
+		#endregion
+	} ;
+
+
+	public class TasSayEventArgs : EventArgs
+	{
+		#region Origins enum
+
+		public enum Origins
+		{
+			Server,
+			Player
+		}
+
+		#endregion
+
+		#region Places enum
+
+		public enum Places
+		{
+			Normal,
+			Motd,
+			Channel,
+			Battle,
+			MessageBox,
+			Broadcast,
+			Game
+		}
+
+		#endregion
+
+		#region Properties
+
+		public string Channel { get; set; }
+		public static TasSayEventArgs Default = new TasSayEventArgs(Origins.Player, Places.Battle, &quot;&quot;, &quot;&quot;, &quot;&quot;, false);
+
+		public bool IsEmote { get; set; }
+
+		public Origins Origin { get; set; }
+
+		public Places Place { get; set; }
+
+		public string Text { get; set; }
+
+		public string UserName { get; set; }
+
+		#endregion
+
+		#region Constructors
+
+		public TasSayEventArgs(Origins origin, Places place, string channel, string username, string text, bool isEmote)
+		{
+			this.Origin = origin;
+			this.Place = place;
+			UserName = username;
+			this.Text = text;
+			this.IsEmote = isEmote;
+			this.Channel = channel;
+		}
+
+		#endregion
+	} ;
+
+	public class TasClientException : Exception
+	{
+		#region Constructors
+
+		public TasClientException() {}
+		public TasClientException(string message) : base(message) {}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/client/UserBattleStatus.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/client/UserBattleStatus.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/client/UserBattleStatus.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,57 +1,76 @@
+#region using
+
 using System;
 using System.Net;
 
+#endregion
+
 namespace Springie.Client
 {
-  public enum SyncStatuses : int
-  {
-    Unknown = 0,
-    Synced = 1,
-    Unsynced = 2
-  }
+	public enum SyncStatuses
+	{
+		Unknown = 0,
+		Synced = 1,
+		Unsynced = 2
+	}
 
-  public class UserBattleStatus: ICloneable
-  {
-    public int AllyNumber;
-    public IPAddress ip = IPAddress.None;
-    public bool IsReady;
-    public bool IsSpectator;
-    public string name;
-    public int port;
-    public int Side;
-    public SyncStatuses SyncStatus = SyncStatuses.Unknown;
-    public int TeamColor;
-    public int TeamNumber;
+	public class UserBattleStatus : ICloneable
+	{
+		#region Properties
 
-    public UserBattleStatus() {}
-  
+		public int AllyNumber;
+		public IPAddress ip = IPAddress.None;
+		public bool IsReady;
+		public bool IsSpectator;
+		public string name;
+		public int port;
+		public int Side;
+		public SyncStatuses SyncStatus = SyncStatuses.Unknown;
+		public int TeamColor;
+		public int TeamNumber;
 
-    public UserBattleStatus(string name)
-    {
-      this.name = name;
-    }
+		#endregion
 
-    public virtual object Clone()
-    {
-      return MemberwiseClone();
-    }
+		#region Constructors
 
-    public void SetFrom(int status, int color, string name)
-    {
-      this.name = name;
-      SetFrom(status, color);
-    }
+		public UserBattleStatus() {}
 
-    public void SetFrom(int status, int color)
-    {
-      IsReady = (status &amp; 2) &gt; 0;
-      TeamNumber = (status &gt;&gt; 2) &amp; 15;
-      AllyNumber = (status &gt;&gt; 6) &amp; 15;
-      IsSpectator = (status &amp; 1024) == 0;
-      SyncStatus = (SyncStatuses)(int)((status &gt;&gt; 22) &amp; 3);
-      Side = (status &gt;&gt; 24) &amp; 15;
-      TeamColor = color;
-    }
 
-  } ;
+		public UserBattleStatus(string name)
+		{
+			this.name = name;
+		}
+
+		#endregion
+
+		#region Public methods
+
+		public void SetFrom(int status, int color, string name)
+		{
+			this.name = name;
+			SetFrom(status, color);
+		}
+
+		public void SetFrom(int status, int color)
+		{
+			IsReady = (status &amp; 2) &gt; 0;
+			TeamNumber = (status &gt;&gt; 2) &amp; 15;
+			AllyNumber = (status &gt;&gt; 6) &amp; 15;
+			IsSpectator = (status &amp; 1024) == 0;
+			SyncStatus = (SyncStatuses) ((status &gt;&gt; 22) &amp; 3);
+			Side = (status &gt;&gt; 24) &amp; 15;
+			TeamColor = color;
+		}
+
+		#endregion
+
+		#region ICloneable Members
+
+		public virtual object Clone()
+		{
+			return MemberwiseClone();
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/doc/devlog.txt
===================================================================
--- branches/caiinterface/tools/springie/Springie/doc/devlog.txt	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/doc/devlog.txt	2008-10-09 18:55:21 UTC (rev 6639)
@@ -11,11 +11,11 @@
 ===============
 TODO
 ===============
-* CAutohostInterface or full dedicated server support
+* CAutohostInterface or full dedicated server support - done in the previous version
 * fix linux compatibility
 * <A HREF="http://replays.unknown-files.net/bot_upload.php?title=title&amp;description=description">http://replays.unknown-files.net/bot_upload.php?title=title&amp;description=description</A>
-* ranked servers
 * gui - add player lists by channel
 * demo upload
 * kick with reason - stop
 * reenable alternative way to determine that game has ended (people in lobby not in game)
+* autoconnect to backup
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/spring/ConfigMaker.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/spring/ConfigMaker.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/spring/ConfigMaker.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System.Collections.Generic;
 using System.Globalization;
 using System.IO;
@@ -5,116 +7,123 @@
 using System.Threading;
 using Springie.Client;
 
+#endregion
+
 namespace Springie.SpringNamespace
 {
-  public class ConfigMaker
-  {
-    public static void Generate(string filename, Battle b, out List&lt;Battle.GrPlayer&gt; players)
-    {
-      Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+	public class ConfigMaker
+	{
+		#region Public methods
 
-      StringBuilder s = new StringBuilder();
+		public static void Generate(string filename, Battle b, int autoHostPort, out List&lt;Battle.GrPlayer&gt; players)
+		{
+			Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
 
-      s.AppendLine(&quot;[GAME]&quot;);
-      s.AppendLine(&quot;{&quot;);
-      s.AppendFormat(&quot;  Mapname={0};\n&quot;, b.Map.Name);
-      s.AppendFormat(&quot;  StartMetal={0};\n&quot;, b.Details.StartingMetal);
-      s.AppendFormat(&quot;  StartEnergy={0};\n&quot;, b.Details.StartingEnergy);
-      s.AppendFormat(&quot;  MaxUnits={0};\n&quot;, b.Details.MaxUnits);
-      s.AppendFormat(&quot;  StartPosType={0};\n&quot;, (int)b.Details.StartPos);
-      s.AppendFormat(&quot;  GameMode={0};\n&quot;, (int)b.Details.EndCondition);
-      s.AppendFormat(&quot;  GameType={0};\n&quot;, b.Mod.ArchiveName);
-      s.AppendFormat(&quot;  LimitDGun={0};\n&quot;, b.Details.LimitDgun);
-      s.AppendFormat(&quot;  DiminishingMMs={0};\n&quot;, b.Details.DiminishingMM);
-      s.AppendFormat(&quot;  GhostedBuildings={0};\n&quot;, b.Details.GhostedBuildings);
-      s.AppendLine();
-      s.AppendFormat(&quot;  HostIP={0};\n&quot;, &quot;127.0.0.1&quot;);
-      s.AppendFormat(&quot;  HostPort={0};\n&quot;, b.HostPort);
-      //s.AppendFormat(&quot;  MinSpeed={0};\n&quot;, 1);
-      //s.AppendFormat(&quot;  MaxSpeed={0};\n&quot;, 1);
-      s.AppendLine();
-      s.AppendFormat(&quot;  MyPlayerNum={0};\n&quot;, 0);
+			var s = new StringBuilder();
 
-      //List&lt;Battle.GrPlayer&gt; players;
-      List&lt;Battle.GrTeam&gt; teams;
-      List&lt;Battle.GrAlly&gt; alliances;
+			s.AppendLine(&quot;[GAME]&quot;);
+			s.AppendLine(&quot;{&quot;);
+			s.AppendFormat(&quot;  Mapname={0};\n&quot;, b.Map.Name);
+			s.AppendFormat(&quot;  StartMetal={0};\n&quot;, b.Details.StartingMetal);
+			s.AppendFormat(&quot;  StartEnergy={0};\n&quot;, b.Details.StartingEnergy);
+			s.AppendFormat(&quot;  MaxUnits={0};\n&quot;, b.Details.MaxUnits);
+			s.AppendFormat(&quot;  StartPosType={0};\n&quot;, (int) b.Details.StartPos);
+			s.AppendFormat(&quot;  GameMode={0};\n&quot;, (int) b.Details.EndCondition);
+			s.AppendFormat(&quot;  GameType={0};\n&quot;, b.Mod.ArchiveName);
+			s.AppendFormat(&quot;  LimitDGun={0};\n&quot;, b.Details.LimitDgun);
+			s.AppendFormat(&quot;  DiminishingMMs={0};\n&quot;, b.Details.DiminishingMM);
+			s.AppendFormat(&quot;  GhostedBuildings={0};\n&quot;, b.Details.GhostedBuildings);
+			s.AppendFormat(&quot;  AutohostPort={0};\n&quot;, autoHostPort);
+			s.AppendLine();
+			s.AppendFormat(&quot;  HostIP={0};\n&quot;, &quot;127.0.0.1&quot;);
+			s.AppendFormat(&quot;  HostPort={0};\n&quot;, b.HostPort);
+			//s.AppendFormat(&quot;  MinSpeed={0};\n&quot;, 1);
+			//s.AppendFormat(&quot;  MaxSpeed={0};\n&quot;, 1);
+			s.AppendLine();
+			s.AppendFormat(&quot;  MyPlayerNum={0};\n&quot;, 0);
 
-      b.GroupData(out players, out teams, out alliances);
+			//List&lt;Battle.GrPlayer&gt; players;
+			List&lt;Battle.GrTeam&gt; teams;
+			List&lt;Battle.GrAlly&gt; alliances;
 
-      s.AppendLine();
-      s.AppendFormat(&quot;  NumPlayers={0};\n&quot;, players.Count);
-      s.AppendFormat(&quot;  NumTeams={0};\n&quot;, teams.Count);
-      s.AppendFormat(&quot;  NumAllyTeams={0};\n&quot;, alliances.Count);
-      s.AppendLine();
+			b.GroupData(out players, out teams, out alliances);
 
-      // PLAYERS
-      for (int i = 0; i &lt; players.Count; ++i) {
-        UserBattleStatus u = players[i].user;
-        s.AppendFormat(&quot;  [PLAYER{0}]\n&quot;, i);
-        s.AppendLine(&quot;  {&quot;);
-        s.AppendFormat(&quot;     name={0};\n&quot;, u.name);
-        s.AppendFormat(&quot;     Spectator={0};\n&quot;, u.IsSpectator ? 1 : 0);
-        if (!u.IsSpectator) s.AppendFormat(&quot;     team={0};\n&quot;, u.TeamNumber);
-        s.AppendLine(&quot;  }&quot;);
-      }
+			s.AppendLine();
+			s.AppendFormat(&quot;  NumPlayers={0};\n&quot;, players.Count);
+			s.AppendFormat(&quot;  NumTeams={0};\n&quot;, teams.Count);
+			s.AppendFormat(&quot;  NumAllyTeams={0};\n&quot;, alliances.Count);
+			s.AppendLine();
 
-      // TEAMS
-      s.AppendLine();
-      for (int i = 0; i &lt; teams.Count; ++i) {
-        s.AppendFormat(&quot;  [TEAM{0}]\n&quot;, i);
-        s.AppendLine(&quot;  {&quot;);
-        s.AppendFormat(&quot;     TeamLeader={0};\n&quot;, teams[i].leader);
-        UserBattleStatus u = teams[i].bot ?? players[teams[i].leader].user; 
-        s.AppendFormat(&quot;     AllyTeam={0};\n&quot;, u.AllyNumber);
-        s.AppendFormat(&quot;     RGBColor={0:F5} {1:F5} {2:F5};\n&quot;, (u.TeamColor &amp; 255)/255.0, ((u.TeamColor &gt;&gt; 8) &amp; 255)/255.0, ((u.TeamColor &gt;&gt; 16) &amp; 255)/255.0);
-        s.AppendFormat(&quot;     Side={0};\n&quot;, b.Mod.Sides[u.Side]);
-        s.AppendFormat(&quot;     Handicap={0};\n&quot;, 0);
-        if (teams[i].bot != null) {
-          s.AppendFormat(&quot;     AIDLL={0};\n&quot;, teams[i].bot.aiLib);
-        }
-        s.AppendLine(&quot;  }&quot;);
-      }
+			// PLAYERS
+			for (int i = 0; i &lt; players.Count; ++i) {
+				var u = players[i].user;
+				s.AppendFormat(&quot;  [PLAYER{0}]\n&quot;, i);
+				s.AppendLine(&quot;  {&quot;);
+				s.AppendFormat(&quot;     name={0};\n&quot;, u.name);
+				s.AppendFormat(&quot;     Spectator={0};\n&quot;, u.IsSpectator ? 1 : 0);
+				if (!u.IsSpectator) s.AppendFormat(&quot;     team={0};\n&quot;, u.TeamNumber);
+				s.AppendLine(&quot;  }&quot;);
+			}
 
-      // ALLYS
-      s.AppendLine();
-      for (int i = 0; i &lt; alliances.Count; ++i) {
-        s.AppendFormat(&quot;[ALLYTEAM{0}]\n&quot;, i);
-        s.AppendLine(&quot;{&quot;);
-        s.AppendFormat(&quot;     NumAllies={0};\n&quot;, 0);
-        double left, top, right, bottom;
-        alliances[i].rect.ToFractions(out left, out top, out right, out bottom);
-        s.AppendFormat(&quot;     StartRectLeft={0};\n&quot;, left);
-        s.AppendFormat(&quot;     StartRectTop={0};\n&quot;, top);
-        s.AppendFormat(&quot;     StartRectRight={0};\n&quot;, right);
-        s.AppendFormat(&quot;     StartRectBottom={0};\n&quot;, bottom);
-        s.AppendLine(&quot;}&quot;);
-      }
+			// TEAMS
+			s.AppendLine();
+			for (int i = 0; i &lt; teams.Count; ++i) {
+				s.AppendFormat(&quot;  [TEAM{0}]\n&quot;, i);
+				s.AppendLine(&quot;  {&quot;);
+				s.AppendFormat(&quot;     TeamLeader={0};\n&quot;, teams[i].leader);
+				var u = teams[i].bot ?? players[teams[i].leader].user;
+				s.AppendFormat(&quot;     AllyTeam={0};\n&quot;, u.AllyNumber);
+				s.AppendFormat(&quot;     RGBColor={0:F5} {1:F5} {2:F5};\n&quot;, (u.TeamColor &amp; 255)/255.0, ((u.TeamColor &gt;&gt; 8) &amp; 255)/255.0, ((u.TeamColor &gt;&gt; 16) &amp; 255)/255.0);
+				s.AppendFormat(&quot;     Side={0};\n&quot;, b.Mod.Sides[u.Side]);
+				s.AppendFormat(&quot;     Handicap={0};\n&quot;, 0);
+				if (teams[i].bot != null) s.AppendFormat(&quot;     AIDLL={0};\n&quot;, teams[i].bot.aiLib);
+				s.AppendLine(&quot;  }&quot;);
+			}
 
-      s.AppendLine();
-      s.AppendFormat(&quot;  NumRestrictions={0};\n&quot;, b.DisabledUnits.Count);
-      s.AppendLine(&quot;  [RESTRICT]&quot;);
-      s.AppendLine(&quot;  {&quot;);
-      for (int i = 0; i &lt; b.DisabledUnits.Count; ++i) {
-        s.AppendFormat(&quot;    Unit{0}={1};\n&quot;, i, b.DisabledUnits[i]);
-        s.AppendFormat(&quot;    Limit{0}=0;\n&quot;, i);
-      }
-      s.AppendLine(&quot;  }&quot;);
 
-      s.AppendLine(&quot;  [modoptions]&quot;);
-      s.AppendLine(&quot;  {&quot;);
-      foreach (UnitSync.Option o in b.Mod.Options) {
-        string v = o.Default;
-        if (b.ModOptions.ContainsKey(o.Key)) v = b.ModOptions[o.Key];
-        s.AppendFormat(&quot;    {0}={1};\n&quot;, o.Key, v);
-      }
-      s.AppendLine(&quot;  }&quot;);
+			// ALLYS
+			s.AppendLine();
+			for (int i = 0; i &lt; alliances.Count; ++i) {
+				s.AppendFormat(&quot;[ALLYTEAM{0}]\n&quot;, i);
+				s.AppendLine(&quot;{&quot;);
+				s.AppendFormat(&quot;     NumAllies={0};\n&quot;, 0);
+				double left, top, right, bottom;
+				alliances[i].rect.ToFractions(out left, out top, out right, out bottom);
+				s.AppendFormat(&quot;     StartRectLeft={0};\n&quot;, left);
+				s.AppendFormat(&quot;     StartRectTop={0};\n&quot;, top);
+				s.AppendFormat(&quot;     StartRectRight={0};\n&quot;, right);
+				s.AppendFormat(&quot;     StartRectBottom={0};\n&quot;, bottom);
+				s.AppendLine(&quot;}&quot;);
+			}
 
-      s.AppendLine(&quot;}&quot;);
+			s.AppendLine();
+			s.AppendFormat(&quot;  NumRestrictions={0};\n&quot;, b.DisabledUnits.Count);
+			s.AppendLine(&quot;  [RESTRICT]&quot;);
+			s.AppendLine(&quot;  {&quot;);
+			for (int i = 0; i &lt; b.DisabledUnits.Count; ++i) {
+				s.AppendFormat(&quot;    Unit{0}={1};\n&quot;, i, b.DisabledUnits[i]);
+				s.AppendFormat(&quot;    Limit{0}=0;\n&quot;, i);
+			}
+			s.AppendLine(&quot;  }&quot;);
 
-      StreamWriter f = File.CreateText(filename);
-      f.Write(s.ToString());
-      f.Flush();
-      f.Close();
-    }
-  }
+			s.AppendLine(&quot;  [modoptions]&quot;);
+			s.AppendLine(&quot;  {&quot;);
+			foreach (var o in b.Mod.Options) {
+				string v = o.Default;
+				if (b.ModOptions.ContainsKey(o.Key)) v = b.ModOptions[o.Key];
+				s.AppendFormat(&quot;    {0}={1};\n&quot;, o.Key, v);
+			}
+			s.AppendLine(&quot;  }&quot;);
+
+
+			s.AppendLine(&quot;}&quot;);
+
+			var f = File.CreateText(filename);
+			f.Write(s.ToString());
+			f.Flush();
+			f.Close();
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/spring/Spring.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/spring/Spring.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/spring/Spring.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,250 +1,272 @@
+#region using
+
 using System;
 using System.Collections.Generic;
-using System.Text;
+using System.Diagnostics;
 using System.IO;
-using System.Diagnostics;
 using System.Threading;
-using Microsoft.Win32;
-using System.Timers;
 using Springie.Client;
 
+#endregion
+
 namespace Springie.SpringNamespace
 {
-  public class SpringLogEventArgs : EventArgs
-  {
-    string username;
-    public string Username { get { return username; } }
+	public class SpringLogEventArgs : EventArgs
+	{
+		#region Fields
 
-    string line;
-    public string Line { get { return line; } }
+		private List&lt;string&gt; args = new List&lt;string&gt;();
+		private string line;
+		private string username;
 
-    List&lt;string&gt; args = new List&lt;string&gt;();
-    public List&lt;string&gt; Args
-    {
-      get { return args; }
-    }
+		#endregion
 
-    public SpringLogEventArgs(string username): this(username, &quot;&quot;) {}
+		#region Properties
 
-    public SpringLogEventArgs(string username, string line)
-    {
-      this.line = line;
-      this.username = username;
-    }
-  };
+		public List&lt;string&gt; Args
+		{
+			get { return args; }
+		}
 
-  /// &lt;summary&gt;
-  /// represents one install location of spring game
-  /// &lt;/summary&gt;
-  public class Spring : IDisposable
-  {
-    public event EventHandler&lt;SpringLogEventArgs&gt; PlayerSaid;
-    public event EventHandler&lt;SpringLogEventArgs&gt; PlayerJoined;
-    public event EventHandler&lt;SpringLogEventArgs&gt; PlayerLeft;
-    public event EventHandler&lt;SpringLogEventArgs&gt; PlayerDisconnected;
-    public event EventHandler&lt;SpringLogEventArgs&gt; PlayerLost; // player lost the game
-    public event EventHandler&lt;SpringLogEventArgs&gt; GameOver; // game has ended
+		public string Line
+		{
+			get { return line; }
+		}
 
-    public event EventHandler SpringExited;
-    public event EventHandler SpringStarted;
+		public string Username
+		{
+			get { return username; }
+		}
 
-    public const string ExecutableName = &quot;dedicated.exe&quot;;
-    public const int MaxTeams = 32;
-    public const int MaxAllies = 10;
-//    const string PathDivider = &quot;/&quot;;
+		#endregion
 
-    Talker talker;
-    string path;
-    public string Path { get { return path; } }
-    Process process;
+		#region Constructors
 
+		public SpringLogEventArgs(string username) : this(username, &quot;&quot;) {}
 
-    public ProcessPriorityClass ProcessPriority
-    {
-      get
-      {
-        if (IsRunning) return process.PriorityClass;
-        else return Program.main.config.HostingProcessPriority;
-      }
-      set
-      {
-        if (IsRunning) {
-          process.PriorityClass = value;
-        }
-      }
+		public SpringLogEventArgs(string username, string line)
+		{
+			this.line = line;
+			this.username = username;
+		}
 
-    }
+		#endregion
+	} ;
 
+	/// &lt;summary&gt;
+	/// represents one install location of spring game
+	/// &lt;/summary&gt;
+	public class Spring : IDisposable
+	{
+		#region Constants
 
+		public const string ExecutableName = &quot;spring-dedicated.exe&quot;;
+		public const int MaxAllies = 10;
+		public const int MaxTeams = 32;
 
-    public bool IsRunning
-    {
-      get
-      {
-        return (process != null &amp;&amp; !process.HasExited);
-      }
-    }
-    DateTime gameStarted;
-    public DateTime GameStarted
-    {
-      get { return gameStarted; }
-    }
+		#endregion
 
-    UnitSync unitSync;
-    public UnitSync UnitSync
-    {
-      get { return unitSync; }
-    }
+		#region Fields
 
-    public Spring(string path)
-    {
-      if (string.IsNullOrEmpty(path)) path = Directory.GetCurrentDirectory();
+		private DateTime gameStarted;
+		//    const string PathDivider = &quot;/&quot;;
 
-      if (!path.EndsWith(&quot;/&quot;)) path += &quot;/&quot;; // ensure that path ends with \\
-      this.path = path;
+		private string path;
 
-      if (!File.Exists(path + ExecutableName)) throw new Exception(ExecutableName + &quot; not found in &quot; + path);
+		private Process process;
+		private Talker talker;
 
-      // init unitsync and load basic info
-      unitSync = new UnitSync(path);
-    }
 
+		private UnitSync unitSync;
 
-    /// &lt;summary&gt;
-    /// Reloads map and or mod list
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;reloadMods&quot;&gt;should reload mods&lt;/param&gt;
-    /// &lt;param name=&quot;reloadMaps&quot;&gt;should reload maps&lt;/param&gt;
-    public void Reload(bool reloadMods, bool reloadMaps)
-    {
-      unitSync.Reload(reloadMods, reloadMaps);
-    }
+		#endregion
 
-    // SPRING.EXE functions
-    public void StartGame(Battle battle)
-    {
-      if (!IsRunning) {
+		#region Properties
 
-        List&lt;Battle.GrPlayer&gt; players;
-        talker = new Talker();
-        talker.SpringEvent += new EventHandler&lt;Talker.SpringEventArgs&gt;(talker_SpringEvent);
-        string configName = &quot;springie&quot; + Program.main.AutoHost.config.HostingPort + &quot;.txt&quot;;
-        ConfigMaker.Generate(path + configName, battle, talker.LoopbackPort, out players);
-        talker.SetPlayers(players);
+		public DateTime GameStarted
+		{
+			get { return gameStarted; }
+		}
 
+		public bool IsRunning
+		{
+			get { return (process != null &amp;&amp; !process.HasExited); }
+		}
 
-        process = new Process();
-        process.StartInfo.CreateNoWindow = true;
-        process.StartInfo.Arguments += configName;
-        process.StartInfo.WorkingDirectory = path;
-        process.StartInfo.FileName = path + ExecutableName;
-        process.StartInfo.UseShellExecute = false;
-        process.Exited += new EventHandler(springProcess_Exited);
-        
-        process.Start();
-        process.ProcessorAffinity = (IntPtr)Program.main.config.SpringCoreAffinity;
+		public string Path
+		{
+			get { return path; }
+		}
 
-        gameStarted = DateTime.Now;
-        process.WaitForInputIdle();
+		public ProcessPriorityClass ProcessPriority
+		{
+			get
+			{
+				if (IsRunning) return process.PriorityClass;
+				else return Program.main.config.HostingProcessPriority;
+			}
+			set { if (IsRunning) process.PriorityClass = value; }
+		}
 
-    
-        if (IsRunning &amp;&amp; SpringStarted != null) SpringStarted(this, EventArgs.Empty);
-        
-        System.Threading.Thread.Sleep(1000);
-        ProcessPriority = Program.main.config.HostingProcessPriority;
-      }
-    }
+		public UnitSync UnitSync
+		{
+			get { return unitSync; }
+		}
 
-    void talker_SpringEvent(object sender, Talker.SpringEventArgs e)
-    {
-      switch (e.EventType) {
-        case Talker.SpringEventType.PLAYER_JOINED:
-          if (PlayerJoined != null) PlayerJoined(this, new SpringLogEventArgs(e.PlayerName));
-          break;
+		#endregion
 
-        case Talker.SpringEventType.PLAYER_LEFT:
-          if (e.Param == 0) if (PlayerDisconnected != null) PlayerDisconnected(this, new SpringLogEventArgs(e.PlayerName));
-            else if (PlayerLeft != null) PlayerLeft(this, new SpringLogEventArgs(e.PlayerName));
-          break;
+		#region Events
 
-        case Talker.SpringEventType.PLAYER_CHAT:
-          if (PlayerSaid != null) PlayerSaid(this, new SpringLogEventArgs(e.PlayerName, e.Text));
-          break;
+		public event EventHandler&lt;SpringLogEventArgs&gt; GameOver; // game has ended
+		public event EventHandler&lt;SpringLogEventArgs&gt; PlayerDisconnected;
+		public event EventHandler&lt;SpringLogEventArgs&gt; PlayerJoined;
+		public event EventHandler&lt;SpringLogEventArgs&gt; PlayerLeft;
+		public event EventHandler&lt;SpringLogEventArgs&gt; PlayerLost; // player lost the game
+		public event EventHandler&lt;SpringLogEventArgs&gt; PlayerSaid;
+		public event EventHandler SpringExited;
+		public event EventHandler SpringStarted;
 
-        case Talker.SpringEventType.PLAYER_DEFEATED:
-          if (PlayerLost != null) PlayerLost(this, new SpringLogEventArgs(e.PlayerName));
-          break;
+		#endregion
 
-        case Talker.SpringEventType.SERVER_GAMEOVER:
-//          if (GameOver != null) GameOver(this, new SpringLogEventArgs(e.PlayerName));
-          break;
-        
-        case Talker.SpringEventType.SERVER_QUIT:
-          if (GameOver != null) GameOver(this, new SpringLogEventArgs(e.PlayerName));
-          break;
+		#region Constructors
 
-      }
+		public Spring(string path)
+		{
+			if (string.IsNullOrEmpty(path)) path = Directory.GetCurrentDirectory();
 
-    }
+			if (!path.EndsWith(&quot;/&quot;)) path += &quot;/&quot;; // ensure that path ends with \\
+			this.path = path;
 
+			if (!File.Exists(path + ExecutableName)) throw new Exception(ExecutableName + &quot; not found in &quot; + path);
 
+			// init unitsync and load basic info
+			unitSync = new UnitSync(path);
+		}
 
-    
-    public void ForceStart()
-    {
-      if (IsRunning) {
-        talker.SendText(&quot;.forcestart&quot;);
-      }
-    }
+		public void Dispose() {}
 
-    public void ExitGame()
-    {
-      if (IsRunning) {
-        // TODO talker method to exit spring
-//        process.WaitForExit(1000);
-//        if (!IsRunning) return;
+		#endregion
 
-        process.CloseMainWindow();
-        process.WaitForExit(1000);
-        if (!IsRunning) return;
-        process.Kill();
-      }
-    }
+		#region Public methods
 
-    public void SayGame(string text)
-    {
-      if (IsRunning) {
-        talker.SendText(text);
-      }
-    }
+		public void ExitGame()
+		{
+			if (IsRunning) {
+				SayGame(&quot;/quit&quot;);
+			  process.WaitForExit(2000);
+				if (!IsRunning) return;
+				process.Kill();;
+				process.WaitForExit(1000);
+				if (!IsRunning) return;
+				process.Kill();
+			}
+		}
 
-    public void Kick(string name)
-    {
-      SayGame(&quot;.kick &quot; + name);
-    }
+		public void ForceStart()
+		{
+			if (IsRunning) talker.SendText(&quot;/forcestart&quot;);
+		}
 
+		public string GetMapArchiveName(string mapname)
+		{
+			return unitSync.GetMapArchiveName(mapname);
+		}
 
-    void springProcess_Exited(object sender, EventArgs e)
-    {
-      process = null;
-      talker.Close();
-      talker = null;
-      if (SpringExited != null) SpringExited(this, EventArgs.Empty);
-    }
+		public void Kick(string name)
+		{
+			SayGame(&quot;/kick &quot; + name);
+		}
 
+		/// &lt;summary&gt;
+		/// Reloads map and or mod list
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;reloadMods&quot;&gt;should reload mods&lt;/param&gt;
+		/// &lt;param name=&quot;reloadMaps&quot;&gt;should reload maps&lt;/param&gt;
+		public void Reload(bool reloadMods, bool reloadMaps)
+		{
+			unitSync.Reload(reloadMods, reloadMaps);
+		}
 
-    public string GetMapArchiveName(string mapname)
-    {
-      return unitSync.GetMapArchiveName(mapname);
-    }
+		public void SayGame(string text)
+		{
+			if (IsRunning) talker.SendText(text);
+		}
 
+		public void StartGame(Battle battle)
+		{
+			if (!IsRunning) {
+				List&lt;Battle.GrPlayer&gt; players;
+				talker = new Talker();
+				talker.SpringEvent += talker_SpringEvent;
+				string configName = &quot;springie&quot; + Program.main.AutoHost.config.HostingPort + &quot;.txt&quot;;
+				ConfigMaker.Generate(path + configName, battle, talker.LoopbackPort, out players);
+				talker.SetPlayers(players);
 
-    #region IDisposable Members
 
-    public void Dispose()
-    {
-    }
+				process = new Process();
+				process.StartInfo.CreateNoWindow = true;
+				process.StartInfo.Arguments += configName;
+				process.StartInfo.WorkingDirectory = path;
+				process.StartInfo.FileName = path + ExecutableName;
+				process.StartInfo.UseShellExecute = false;
+				process.Exited += springProcess_Exited;
 
-    #endregion
-  }
-}
+				process.Start();
+        
+				gameStarted = DateTime.Now;
+
+
+				if (IsRunning &amp;&amp; SpringStarted != null) SpringStarted(this, EventArgs.Empty);
+
+				Thread.Sleep(1000);
+				ProcessPriority = Program.main.config.HostingProcessPriority;
+			}
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void springProcess_Exited(object sender, EventArgs e)
+		{
+			process = null;
+			talker.Close();
+			talker = null;
+			if (SpringExited != null) SpringExited(this, EventArgs.Empty);
+		}
+
+		private void talker_SpringEvent(object sender, Talker.SpringEventArgs e)
+		{
+			switch (e.EventType) {
+				case Talker.SpringEventType.PLAYER_JOINED:
+					if (PlayerJoined != null) PlayerJoined(this, new SpringLogEventArgs(e.PlayerName));
+					break;
+
+				case Talker.SpringEventType.PLAYER_LEFT:
+					if (e.Param == 0) {
+						if (PlayerDisconnected != null) PlayerDisconnected(this, new SpringLogEventArgs(e.PlayerName));
+						else if (PlayerLeft != null) PlayerLeft(this, new SpringLogEventArgs(e.PlayerName));
+					}
+					break;
+
+				case Talker.SpringEventType.PLAYER_CHAT:
+					if (PlayerSaid != null) PlayerSaid(this, new SpringLogEventArgs(e.PlayerName, e.Text));
+					break;
+
+				case Talker.SpringEventType.PLAYER_DEFEATED:
+					if (PlayerLost != null) PlayerLost(this, new SpringLogEventArgs(e.PlayerName));
+					break;
+
+				case Talker.SpringEventType.SERVER_GAMEOVER:
+					if (GameOver != null) GameOver(this, new SpringLogEventArgs(e.PlayerName));
+					break;
+
+				case Talker.SpringEventType.SERVER_QUIT:
+					//if (GameOver != null) GameOver(this, new SpringLogEventArgs(e.PlayerName));
+					break;
+			}
+		}
+
+		#endregion
+	}
+}
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/spring/Talker.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/spring/Talker.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/spring/Talker.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,161 +1,184 @@
+#region using
+
 using System;
-using System.Runtime.InteropServices;
 using System.Collections.Generic;
-using System.Threading;
-using System.Diagnostics;
+using System.Net;
 using System.Net.Sockets;
-using System.Net;
 using System.Text;
+using System.Threading;
 using Springie.Client;
 
+#endregion
+
 namespace Springie.SpringNamespace
 {
-  class Talker : IDisposable
-  {
-    public enum SpringEventType : byte
-    {
-      /// Server has started ()
-      SERVER_STARTED = 0,
+	internal class Talker : IDisposable
+	{
+		#region SpringEventType enum
 
-      /// Server is about to exit ()
-      SERVER_QUIT = 1,
+		public enum SpringEventType : byte
+		{
+			/// Server has started ()
+			SERVER_STARTED = 0,
 
-      /// Game starts ()
-      SERVER_STARTPLAYING = 2,
+			/// Server is about to exit ()
+			SERVER_QUIT = 1,
 
-      /// Game has ended ()
-      SERVER_GAMEOVER = 3,
+			/// Game starts ()
+			SERVER_STARTPLAYING = 2,
 
-      /// Player has joined the game (uchar playernumber, string name)
-      PLAYER_JOINED = 10,
+			/// Game has ended ()
+			SERVER_GAMEOVER = 3,
 
-      /// Player has left (uchar playernumber, uchar reason (0: lost connection, 1: left, 2: kicked) )
-      PLAYER_LEFT = 11,
+			/// Player has joined the game (uchar playernumber, string name)
+			PLAYER_JOINED = 10,
 
-      /// Player has updated its ready-state (uchar playernumber, uchar state (0: not ready, 1: ready, 2: state not changed) )
-      PLAYER_READY = 12,
+			/// Player has left (uchar playernumber, uchar reason (0: lost connection, 1: left, 2: kicked) )
+			PLAYER_LEFT = 11,
 
-      /// Player has sent a chat message (uchar playernumber, string text)
-      PLAYER_CHAT = 13,
+			/// Player has updated its ready-state (uchar playernumber, uchar state (0: not ready, 1: ready, 2: state not changed) )
+			PLAYER_READY = 12,
 
-      /// Player has been defeated (uchar playernumber)
-      PLAYER_DEFEATED = 14
-    };
+			/// Player has sent a chat message (uchar playernumber, string text)
+			PLAYER_CHAT = 13,
 
-    public class SpringEventArgs : EventArgs
-    {
-      public SpringEventType EventType;
-      public string PlayerName;
-      public byte PlayerNumber = 0;
-      public byte Param;
-      public string Text;
-    }
+			/// Player has been defeated (uchar playernumber)
+			PLAYER_DEFEATED = 14
+		} ;
 
+		#endregion
 
+		#region Fields
 
+		protected bool close;
+		private List&lt;Battle.GrPlayer&gt; initialPlayers;
 
+		private int loopbackPort;
+		private int springTalkPort;
 
-    protected bool close = false;
+		private Thread thread;
+		private UdpClient udp;
 
-    int loopbackPort;
-    public int LoopbackPort
-    {
-      get
-      {
-        return loopbackPort;
-      }
-    }
+		#endregion
 
-    Thread thread;
-    UdpClient udp;
-    int springTalkPort;
-    List&lt;Battle.GrPlayer&gt; initialPlayers;
+		#region Properties
 
-    public event EventHandler&lt;SpringEventArgs&gt; SpringEvent;
+		public int LoopbackPort
+		{
+			get { return loopbackPort; }
+		}
 
+		#endregion
 
-    public void SendText(string text)
-    {
-      byte[] bytes = Encoding.ASCII.GetBytes(text);
-      udp.Send(bytes, bytes.Length, &quot;127.0.0.1&quot;, springTalkPort);
-    }
+		#region Events
 
-    
-    public void SetPlayers(List&lt;Battle.GrPlayer&gt; players) {
-      initialPlayers = players;
-    }
+		public event EventHandler&lt;SpringEventArgs&gt; SpringEvent;
 
+		#endregion
 
-    public Talker()
-    {
-      udp = new UdpClient(0);
-      loopbackPort = ((IPEndPoint)udp.Client.LocalEndPoint).Port;
+		#region Constructors
 
-      thread = new Thread(delegate() { Listener(); });
-      thread.Start();
-    }
+		public Talker()
+		{
+			udp = new UdpClient(0);
+			loopbackPort = ((IPEndPoint) udp.Client.LocalEndPoint).Port;
 
-    private void Listener()
-    {
-      while (!close) {
-        IPEndPoint endpoint = new IPEndPoint(IPAddress.Loopback, 0);
-        byte[] data = udp.Receive(ref endpoint);
-        if (endpoint.Port != loopbackPort) {
-          springTalkPort = endpoint.Port;
-        }
-        if (data.Length &gt; 0) {
-          SpringEventArgs sea = new SpringEventArgs();
+			thread = new Thread(delegate() { Listener(); });
+			thread.Start();
+		}
 
-          sea.EventType = (SpringEventType)data[0];
+		public void Dispose()
+		{
+			Close();
+		}
 
-          switch (sea.EventType) {
-            case SpringEventType.PLAYER_JOINED:
-              sea.PlayerNumber = data[1];
-              sea.PlayerName = Encoding.ASCII.GetString(data, 2, data.Length - 2);
-              break;
-            case SpringEventType.PLAYER_LEFT:
-              sea.PlayerNumber = data[1];
-              sea.Param = data[2];
-              break;
-            case SpringEventType.PLAYER_READY:
-              sea.PlayerNumber = data[1];
-              sea.Param = data[2];
-              break;
+		#endregion
 
-            case SpringEventType.PLAYER_CHAT:
-              sea.PlayerNumber = data[1];
-              sea.Text = Encoding.ASCII.GetString(data, 2, data.Length - 2);
-              break;
+		#region Public methods
 
-            case SpringEventType.PLAYER_DEFEATED:
-              sea.PlayerNumber = data[1];
-              break;
-          }
-          if (sea.PlayerName == null) {
-            sea.PlayerName = initialPlayers[sea.PlayerNumber].user.name;
-          }
+		public void Close()
+		{
+			close = true;
+			var udclose = new UdpClient();
+			udclose.Send(new byte[2] {0, (byte) SpringEventType.SERVER_QUIT}, 1, &quot;127.0.0.1&quot;, loopbackPort);
+			thread.Join(1000);
+		}
 
-          if (SpringEvent != null) SpringEvent(this, sea);
-        }
-      }
-    }
 
-    public void Close()
-    {
-      close = true;
-      UdpClient udclose = new UdpClient();
-      udclose.Send(new byte[2] { 0, (byte)SpringEventType.SERVER_QUIT }, 1, &quot;127.0.0.1&quot;, loopbackPort);
-      thread.Join(1000);
-    }
+		public void SendText(string text)
+		{
+			var bytes = Encoding.ASCII.GetBytes(text);
+			udp.Send(bytes, bytes.Length, &quot;127.0.0.1&quot;, springTalkPort);
+		}
 
 
-    #region IDisposable Members
+		public void SetPlayers(List&lt;Battle.GrPlayer&gt; players)
+		{
+			initialPlayers = players;
+		}
 
-    public void Dispose()
-    {
-      Close();
-    }
+		#endregion
 
-    #endregion
-  }
-}
+		#region Other methods
+
+		private void Listener()
+		{
+			while (!close) {
+				var endpoint = new IPEndPoint(IPAddress.Loopback, 0);
+				var data = udp.Receive(ref endpoint);
+				if (endpoint.Port != loopbackPort) springTalkPort = endpoint.Port;
+				if (data.Length &gt; 0) {
+					var sea = new SpringEventArgs();
+
+					sea.EventType = (SpringEventType) data[0];
+
+					switch (sea.EventType) {
+						case SpringEventType.PLAYER_JOINED:
+							sea.PlayerNumber = data[1];
+							sea.PlayerName = Encoding.ASCII.GetString(data, 2, data.Length - 2);
+							break;
+						case SpringEventType.PLAYER_LEFT:
+							sea.PlayerNumber = data[1];
+							sea.Param = data[2];
+							break;
+						case SpringEventType.PLAYER_READY:
+							sea.PlayerNumber = data[1];
+							sea.Param = data[2];
+							break;
+
+						case SpringEventType.PLAYER_CHAT:
+							sea.PlayerNumber = data[1];
+							sea.Text = Encoding.ASCII.GetString(data, 2, data.Length - 2);
+							break;
+
+						case SpringEventType.PLAYER_DEFEATED:
+							sea.PlayerNumber = data[1];
+							break;
+					}
+					if (sea.PlayerName == null) sea.PlayerName = initialPlayers[sea.PlayerNumber].user.name;
+
+					if (SpringEvent != null) SpringEvent(this, sea);
+				}
+			}
+		}
+
+		#endregion
+
+		#region Nested type: SpringEventArgs
+
+		public class SpringEventArgs : EventArgs
+		{
+			#region Properties
+
+			public SpringEventType EventType;
+			public byte Param;
+			public string PlayerName;
+			public byte PlayerNumber;
+			public string Text;
+
+			#endregion
+		}
+
+		#endregion
+	}
+}
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/spring/UnitSync.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/spring/UnitSync.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/spring/UnitSync.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.ComponentModel;
@@ -5,742 +7,828 @@
 using System.IO;
 using System.Runtime.InteropServices;
 using System.Threading;
-using Springie.Client;
 
+#endregion
+
 namespace Springie.SpringNamespace
 {
-  internal class UnitConverter : StringConverter
-  {
-    public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
-    {
-      return true;
-    }
+	internal class UnitConverter : StringConverter
+	{
+		#region Overrides
 
-    public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
-    {
-      string tofind = value.ToString().Split(' ')[0];
-      foreach (UnitInfo u in GetMod().Units) if (u.Name == tofind) return u;
-      return null;
-    }
+		public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
+		{
+			string tofind = value.ToString().Split(' ')[0];
+			foreach (var u in GetMod().Units) if (u.Name == tofind) return u;
+			return null;
+		}
 
-    public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
-    {
-      if (destinationType == typeof(String)) {
-        if (value == null) return null;
-        UnitInfo u = (UnitInfo)value;
-        if (u.Name != null) return u.Name + &quot; (&quot; + u.FullName + &quot;)&quot;;
-        else return null;
-      } else return base.ConvertTo(context, culture, value, destinationType);
-    }
+		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
+		{
+			if (destinationType == typeof (String)) {
+				if (value == null) return null;
+				var u = (UnitInfo) value;
+				if (u.Name != null) return u.Name + &quot; (&quot; + u.FullName + &quot;)&quot;;
+				else return null;
+			} else return base.ConvertTo(context, culture, value, destinationType);
+		}
 
 
-    public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
-    {
-      return new StandardValuesCollection(GetMod().Units);
-    }
+		public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
+		{
+			return new StandardValuesCollection(GetMod().Units);
+		}
 
-    private ModInfo GetMod()
-    {
-      if (Program.main.Tas != null) {
-        Battle b = Program.main.Tas.GetBattle();
-        if (b != null) return b.Mod;
-      }
-      return Program.main.Spring.UnitSync.GetModInfo(Program.main.AutoHost.config.DefaultMod);
-    }
-  }
+		public override bool GetStandardValuesSupported(ITypeDescriptorContext context)
+		{
+			return true;
+		}
 
+		#endregion
 
-  [TypeConverter(typeof(UnitConverter))]
-  public struct UnitInfo
-  {
-    public string FullName;
-    public string Name;
+		#region Other methods
 
+		private ModInfo GetMod()
+		{
+			if (Program.main.Tas != null) {
+				var b = Program.main.Tas.GetBattle();
+				if (b != null) return b.Mod;
+			}
+			return Program.main.Spring.UnitSync.GetModInfo(Program.main.AutoHost.config.DefaultMod);
+		}
 
-    public UnitInfo(string name, string fullName)
-    {
-      Name = name;
-      FullName = fullName;
-    }
+		#endregion
+	}
 
-    public static string[] ToStringList(UnitInfo[] src)
-    {
-      string[] result = new string[src.Length];
-      for (int i = 0; i &lt; src.Length; ++i) result[i] = src[i].Name;
-      return result;
-    }
 
-    public static UnitInfo[] FromStringList(string[] src, ModInfo mod)
-    {
-      List&lt;UnitInfo&gt; result = new List&lt;UnitInfo&gt;();
-      for (int i = 0; i &lt; src.Length; ++i) {
-        UnitInfo u;
-        if (mod.GetUnitInfo(src[i], out u)) result.Add(u);
-      }
-      return result.ToArray();
-    }
-  }
+	[TypeConverter(typeof (UnitConverter))]
+	public struct UnitInfo
+	{
+		#region Properties
 
+		public string FullName;
+		public string Name;
 
-  /// &lt;summary&gt;
-  /// Represents one mod. Detailed information are loaded on demand for given mod.
-  /// &lt;/summary&gt;
-  public class ModInfo
-  {
-    protected string archiveName;
-    private int checksum;
-    private bool loaded = false;
-    private int modId = -1;
-    private object myLock = new object();
-    private string name;
-    public List&lt;UnitSync.Option&gt; Options = new List&lt;UnitSync.Option&gt;();
-    private string[] sides;
-    private UnitInfo[] units;
-    private UnitSync unitSync = null;
+		#endregion
 
-    public ModInfo(UnitSync owner, string name, int modId)
-    {
-      unitSync = owner;
-      this.name = name;
-      this.modId = modId;
-    }
+		#region Constructors
 
-    public string Name
-    {
-      get { return name; }
-    }
+		public UnitInfo(string name, string fullName)
+		{
+			Name = name;
+			FullName = fullName;
+		}
 
-    public string ArchiveName
-    {
-      get
-      {
-        CheckLoaded();
-        return archiveName;
-      }
-      set { archiveName = value; }
-    }
+		#endregion
 
-    public int Checksum
-    {
-      get
-      {
-        CheckLoaded();
-        return checksum;
-      }
-      set { checksum = value; }
-    }
+		#region Public methods
 
-    public string[] Sides
-    {
-      get
-      {
-        CheckLoaded();
-        return sides;
-      }
-      set { sides = value; }
-    }
+		public static UnitInfo[] FromStringList(string[] src, ModInfo mod)
+		{
+			var result = new List&lt;UnitInfo&gt;();
+			for (int i = 0; i &lt; src.Length; ++i) {
+				UnitInfo u;
+				if (mod.GetUnitInfo(src[i], out u)) result.Add(u);
+			}
+			return result.ToArray();
+		}
 
-    public UnitInfo[] Units
-    {
-      get
-      {
-        CheckLoaded();
-        return units;
-      }
-      set { units = value; }
-    }
+		public static string[] ToStringList(UnitInfo[] src)
+		{
+			var result = new string[src.Length];
+			for (int i = 0; i &lt; src.Length; ++i) result[i] = src[i].Name;
+			return result;
+		}
 
-    public int ModId
-    {
-      get { return modId; }
-    }
+		#endregion
+	}
 
 
-    public bool GetUnitInfo(string name, out UnitInfo res)
-    {
-      for (int i = 0; i &lt; Units.Length; ++i) {
-        if (Units[i].Name == name) {
-          res = Units[i];
-          return true;
-        }
-      }
-      res = new UnitInfo();
-      return false;
-    }
+	/// &lt;summary&gt;
+	/// Represents one mod. Detailed information are loaded on demand for given mod.
+	/// &lt;/summary&gt;
+	public class ModInfo
+	{
+		#region Fields
 
-    private void CheckLoaded()
-    {
-      if (!loaded &amp;&amp; unitSync != null) {
-        lock (myLock) {
-          loaded = true;
-          unitSync.LoadModInfo(this);
-        }
-      }
-    }
+		protected string archiveName;
+		private int checksum;
+		private bool loaded;
+		private int modId = -1;
+		private object myLock = new object();
+		private string name;
+		private string[] sides;
+		private UnitInfo[] units;
+		private UnitSync unitSync;
 
-    public override string ToString()
-    {
-      return name;
-    }
-  } ;
+		#endregion
 
+		#region Properties
 
-  public class MapInfo
-  {
-    protected string archiveName;
+		public string ArchiveName
+		{
+			get
+			{
+				CheckLoaded();
+				return archiveName;
+			}
+			set { archiveName = value; }
+		}
 
-    private int checksum;
-    private bool loaded = false;
-    private int mapId = -1;
-    private object myLock = new object();
-    private string name;
-    private UnitSync unitSync = null;
+		public int Checksum
+		{
+			get
+			{
+				CheckLoaded();
+				return checksum;
+			}
+			set { checksum = value; }
+		}
 
+		public int ModId
+		{
+			get { return modId; }
+		}
 
-    public MapInfo(UnitSync owner, string name, int mapId)
-    {
-      unitSync = owner;
-      this.name = name;
-      this.mapId = mapId;
-    }
+		public string Name
+		{
+			get { return name; }
+		}
 
-    public string Name
-    {
-      get { return name; }
-    }
+		public List&lt;UnitSync.Option&gt; Options = new List&lt;UnitSync.Option&gt;();
 
-    public string ArchiveName
-    {
-      get
-      {
-        CheckLoaded();
-        return archiveName;
-      }
-      set { archiveName = value; }
-    }
+		public string[] Sides
+		{
+			get
+			{
+				CheckLoaded();
+				return sides;
+			}
+			set { sides = value; }
+		}
 
-    public int Checksum
-    {
-      get
-      {
-        CheckLoaded();
-        return checksum;
-      }
-      set { checksum = value; }
-    }
+		public UnitInfo[] Units
+		{
+			get
+			{
+				CheckLoaded();
+				return units;
+			}
+			set { units = value; }
+		}
 
-    public int MapId
-    {
-      get { return mapId; }
-    }
+		#endregion
 
-    private void CheckLoaded()
-    {
-      if (!loaded &amp;&amp; unitSync != null) {
-        lock (myLock) {
-          loaded = true;
-          unitSync.LoadMapInfo(this);
-        }
-      }
-    }
+		#region Constructors
 
-    public override string ToString()
-    {
-      return name;
-    }
-  } ;
+		public ModInfo(UnitSync owner, string name, int modId)
+		{
+			unitSync = owner;
+			this.name = name;
+			this.modId = modId;
+		}
 
+		#endregion
 
-  public class UnitSync : IDisposable
-  {
-    private Dictionary&lt;string, MapInfo&gt; mapList = new Dictionary&lt;string, MapInfo&gt;();
-    private Dictionary&lt;string, ModInfo&gt; modList = new Dictionary&lt;string, ModInfo&gt;();
-    private string path;
-    public UnitSync() : this(Directory.GetCurrentDirectory()) {}
+		#region Public methods
 
-    public UnitSync(string path)
-    {
-      this.path = path;
-      string opath = Directory.GetCurrentDirectory();
-      Directory.SetCurrentDirectory(path);
-      if (Init(false, 0) != 1) throw new Exception(&quot;unitsync.dll init failed&quot;);
-      //if (InitArchiveScanner() != 1) throw new Exception(&quot;unitsync.dll:InitArchiveScanner() failed&quot;);
-      LoadModList();
-      LoadMapList();
-      Directory.SetCurrentDirectory(opath);
-    }
+		public bool GetUnitInfo(string name, out UnitInfo res)
+		{
+			for (int i = 0; i &lt; Units.Length; ++i) {
+				if (Units[i].Name == name) {
+					res = Units[i];
+					return true;
+				}
+			}
+			res = new UnitInfo();
+			return false;
+		}
 
-    public Dictionary&lt;string, ModInfo&gt; ModList
-    {
-      get { return modList; }
-    }
+		#endregion
 
+		#region Overrides
 
-    public Dictionary&lt;string, MapInfo&gt; MapList
-    {
-      get { return mapList; }
-    }
+		public override string ToString()
+		{
+			return name;
+		}
 
-    #region IDisposable Members
-    public void Dispose()
-    {
-      UnInit();
-    }
-    #endregion
+		#endregion
 
-    /// &lt;summary&gt;
-    /// Gets map list from unit sync, does not make full reinit by default
-    /// &lt;/summary&gt;
-    /// &lt;returns&gt;&lt;/returns&gt;
-    private void LoadMapList()
-    {
-      string opath = Directory.GetCurrentDirectory();
-      Directory.SetCurrentDirectory(path);
+		#region Other methods
 
-      int mapCount = GetMapCount();
-      mapList.Clear();
-      for (int i = 0; i &lt; mapCount; ++i) {
-        MapInfo mi = new MapInfo(this, GetMapName(i), i);
-        mapList[mi.Name] = mi;
-        mi.ArchiveName = RequestMapArchive(mi.Name);
-      }
-      Directory.SetCurrentDirectory(opath);
-    }
+		private void CheckLoaded()
+		{
+			if (!loaded &amp;&amp; unitSync != null) {
+				lock (myLock) {
+					loaded = true;
+					unitSync.LoadModInfo(this);
+				}
+			}
+		}
 
+		#endregion
+	} ;
 
-    /// &lt;summary&gt;
-    /// Gets mod list - does not make full reinit by default
-    /// &lt;/summary&gt;
-    /// &lt;returns&gt;&lt;/returns&gt;
-    private void LoadModList()
-    {
-      string opath = Directory.GetCurrentDirectory();
-      Directory.SetCurrentDirectory(path);
 
-      int modCount = GetPrimaryModCount();
+	public class MapInfo
+	{
+		#region Fields
 
-      modList.Clear();
-      for (int i = 0; i &lt; modCount; ++i) {
-        ModInfo mi = new ModInfo(this, GetPrimaryModName(i), i);
-        modList[mi.Name] = mi;
-      }
-    }
+		protected string archiveName;
 
+		private int checksum;
+		private bool loaded;
+		private int mapId = -1;
+		private object myLock = new object();
+		private string name;
+		private UnitSync unitSync;
 
-    internal void LoadModInfo(ModInfo mi)
-    {
-      Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
-      string opath = Directory.GetCurrentDirectory();
-      Directory.SetCurrentDirectory(path);
-      int i = mi.ModId;
+		#endregion
 
-      ReInit(true);
+		#region Properties
 
-      GetPrimaryModCount();
-      if (mi.Name != GetPrimaryModName(i)) throw new Exception(&quot;Mod &quot; + mi.Name + &quot; modified without reload&quot;);
+		public string ArchiveName
+		{
+			get
+			{
+				CheckLoaded();
+				return archiveName;
+			}
+			set { archiveName = value; }
+		}
 
-      //uint result = 0;
-      mi.ArchiveName = GetPrimaryModArchive(i);
+		public int Checksum
+		{
+			get
+			{
+				CheckLoaded();
+				return checksum;
+			}
+			set { checksum = value; }
+		}
 
-      /*      int acount = GetPrimaryModArchiveCount(i);
-            for (int x = 0; x &lt; acount; ++x) {
-              result += GetArchiveChecksum(GetPrimaryModArchiveList(x));
-            }
-            mi.Checksum = (int)result;*/
-      mi.Checksum = GetPrimaryModChecksum(mi.ModId);
+		public int MapId
+		{
+			get { return mapId; }
+		}
 
-      AddAllArchives(mi.ArchiveName);
-      mi.Sides = new String[GetSideCount()];
-      for (int x = 0; x &lt; mi.Sides.Length; ++x) mi.Sides[x] = GetSideName(x);
+		public string Name
+		{
+			get { return name; }
+		}
 
-      // weirdest stuff of all...
-      while (ProcessUnitsNoChecksum() != 0) {}
-      ;
-      mi.Units = new UnitInfo[GetUnitCount()];
-      for (int x = 0; x &lt; mi.Units.Length; ++x) mi.Units[x] = new UnitInfo(GetUnitName(x), GetFullUnitName(x));
+		#endregion
 
-      int opts = GetModOptionCount();
-      for (int x = 0; x &lt; opts; x++) {
-        Option o = new Option(x);
-        mi.Options.Add(o);
-      }
+		#region Constructors
 
-      Directory.SetCurrentDirectory(opath);
-    }
+		public MapInfo(UnitSync owner, string name, int mapId)
+		{
+			unitSync = owner;
+			this.name = name;
+			this.mapId = mapId;
+		}
 
+		#endregion
 
-    /// &lt;summary&gt;
-    /// Loads new map information
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;mi&quot;&gt;&lt;/param&gt;
-    internal void LoadMapInfo(MapInfo mi)
-    {
-      string opath = Directory.GetCurrentDirectory();
-      Directory.SetCurrentDirectory(path);
-      int i = mi.MapId;
+		#region Overrides
 
-      ReInit(true);
+		public override string ToString()
+		{
+			return name;
+		}
 
-      GetMapCount();
-      //if (mi.Name != GetMapName(i)) throw new Exception(&quot;Map &quot; + mi.Name + &quot; modified without reload&quot;);
+		#endregion
 
-      uint result = 0;
-      int acount = GetMapArchiveCount(mi.Name);
-      for (int x = 0; x &lt; acount; ++x) result += GetArchiveChecksum(GetMapArchiveName(x));
-      mi.Checksum = (int)result;
+		#region Other methods
 
-      Directory.SetCurrentDirectory(opath);
-    }
+		private void CheckLoaded()
+		{
+			if (!loaded &amp;&amp; unitSync != null) {
+				lock (myLock) {
+					loaded = true;
+					unitSync.LoadMapInfo(this);
+				}
+			}
+		}
 
+		#endregion
+	} ;
 
-    /// &lt;summary&gt;
-    /// ReInits unitsync
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;full&quot;&gt;if true does complete reinit (neccesary to find new map or mod), if false does just archivescannerinit&lt;/param&gt;
-    private void ReInit(bool full)
-    {
-      string opath = Directory.GetCurrentDirectory();
-      Directory.SetCurrentDirectory(path);
 
-      if (full) {
-        UnInit();
-        if (Init(false, 0) != 1) throw new Exception(&quot;unitsync.dll init failed&quot;);
-      }
-      //if (InitArchiveScanner() != 1) throw new Exception(&quot;unitsync.dll:InitArchiveScanner() failed&quot;);
+	public class UnitSync : IDisposable
+	{
+		#region Fields
 
-      Directory.SetCurrentDirectory(opath);
-    }
+		private Dictionary&lt;string, MapInfo&gt; mapList = new Dictionary&lt;string, MapInfo&gt;();
+		private Dictionary&lt;string, ModInfo&gt; modList = new Dictionary&lt;string, ModInfo&gt;();
+		private string path;
 
+		#endregion
 
-    public string GetMapArchiveName(string mapname)
-    {
-      if (mapList.ContainsKey(mapname)) return mapList[mapname].ArchiveName;
-      else return &quot;&quot;;
-    }
+		#region Properties
 
-    public bool HasMap(string name)
-    {
-      return mapList.ContainsKey(name);
-    }
+		public Dictionary&lt;string, MapInfo&gt; MapList
+		{
+			get { return mapList; }
+		}
 
-    public ModInfo GetModInfo(string name)
-    {
-      if (modList.ContainsKey(name)) return modList[name];
-      else {
-        foreach (KeyValuePair&lt;string, ModInfo&gt; p in modList) if (p.Value.ArchiveName == name) return p.Value;
-        return null;
-      }
-    }
+		public Dictionary&lt;string, ModInfo&gt; ModList
+		{
+			get { return modList; }
+		}
 
-    public MapInfo GetMapInfo(string name)
-    {
-      return mapList[name];
-    }
+		#endregion
 
+		#region Constructors
 
-    public bool HasMod(string modName)
-    {
-      if (!modList.ContainsKey(modName)) {
-        foreach (KeyValuePair&lt;string, ModInfo&gt; p in modList) if (p.Value.ArchiveName == modName) return true;
-        return false;
-      } else return true;
-    }
+		public UnitSync() : this(Directory.GetCurrentDirectory()) {}
 
+		public UnitSync(string path)
+		{
+			this.path = path;
+			string opath = Directory.GetCurrentDirectory();
+			Directory.SetCurrentDirectory(path);
+			if (Init(false, 0) != 1) throw new Exception(&quot;unitsync.dll init failed&quot;);
+			//if (InitArchiveScanner() != 1) throw new Exception(&quot;unitsync.dll:InitArchiveScanner() failed&quot;);
+			LoadModList();
+			LoadMapList();
+			Directory.SetCurrentDirectory(opath);
+		}
 
-    private string RequestMapArchive(string mapname)
-    {
-      int i = GetMapArchiveCount(mapname);
-      if (i &gt; 0) {
-        string arch = GetMapArchiveName(0);
-        int lastslash = arch.LastIndexOfAny(new char[] {'/', '\\'});
-        return arch.Substring(lastslash + 1);
-      } else return &quot;&quot;;
-    }
+		public void Dispose()
+		{
+			UnInit();
+		}
 
-    /*
-    //     MAPS
-    */
+		#endregion
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetMapCount();
+		#region Public methods
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetMapName(int index);
+		public string GetMapArchiveName(string mapname)
+		{
+			if (mapList.ContainsKey(mapname)) return mapList[mapname].ArchiveName;
+			else return &quot;&quot;;
+		}
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetMapArchiveCount(string mapName);
+		public MapInfo GetMapInfo(string name)
+		{
+			return mapList[name];
+		}
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetMapArchiveName(int index);
+		public ModInfo GetModInfo(string name)
+		{
+			if (modList.ContainsKey(name)) return modList[name];
+			else {
+				foreach (var p in modList) if (p.Value.ArchiveName == name) return p.Value;
+				return null;
+			}
+		}
 
-    /*
-    //     MODS
-    */
+		public bool HasMap(string name)
+		{
+			return mapList.ContainsKey(name);
+		}
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetPrimaryModCount();
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetPrimaryModName(int index);
+		public bool HasMod(string modName)
+		{
+			if (!modList.ContainsKey(modName)) {
+				foreach (var p in modList) if (p.Value.ArchiveName == modName) return true;
+				return false;
+			} else return true;
+		}
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetPrimaryModArchive(int index);
+		/// &lt;summary&gt;
+		/// Loads new map information
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;mi&quot;&gt;&lt;/param&gt;
+		internal void LoadMapInfo(MapInfo mi)
+		{
+			string opath = Directory.GetCurrentDirectory();
+			Directory.SetCurrentDirectory(path);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetPrimaryModArchiveList(int index);
+			mi.Checksum = (int)GetMapChecksum(mi.MapId);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern uint GetArchiveChecksum(string archive);
+			Directory.SetCurrentDirectory(opath);
+		}
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetPrimaryModArchiveCount(int index);
+		internal void LoadModInfo(ModInfo mi)
+		{
+			Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+			string opath = Directory.GetCurrentDirectory();
+			Directory.SetCurrentDirectory(path);
+			//ReInit(true);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern void AddAllArchives(string root);
+			//GetPrimaryModCount();
+			if (mi.Name != GetPrimaryModName(mi.ModId)) throw new Exception(&quot;Mod &quot; + mi.Name + &quot; modified without reload&quot;);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetPrimaryModChecksum(int index);
+			//uint result = 0;
+			mi.ArchiveName = GetPrimaryModArchive(mi.ModId);
 
+			mi.Checksum = (int)GetPrimaryModChecksum(mi.ModId);
 
-    /*
-    //     SIDES
-    */
+			AddAllArchives(mi.ArchiveName);
+			mi.Sides = new String[GetSideCount()];
+			for (int x = 0; x &lt; mi.Sides.Length; ++x) mi.Sides[x] = GetSideName(x);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetSideCount();
+			// weirdest stuff of all...
+			while (ProcessUnitsNoChecksum() != 0) {}
+			;
+			mi.Units = new UnitInfo[GetUnitCount()];
+			for (int x = 0; x &lt; mi.Units.Length; ++x) mi.Units[x] = new UnitInfo(GetUnitName(x), GetFullUnitName(x));
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetSideName(int index);
+			int opts = GetModOptionCount();
+			for (int x = 0; x &lt; opts; x++) {
+				var o = new Option(x);
+				mi.Options.Add(o);
+			}
 
+			Directory.SetCurrentDirectory(opath);
+		}
 
-    /*
-    //     UNITS
-    */
+		internal void Reload(bool reloadMods, bool reloadMaps)
+		{
+			if (reloadMods || reloadMaps) ReInit(true);
+			if (reloadMaps) LoadMapList();
+			if (reloadMods) LoadModList();
+		}
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int ProcessUnitsNoChecksum();
+		#endregion
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetUnitCount();
+		#region Other methods
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetUnitName(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern void AddAllArchives(string root);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetFullUnitName(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern uint GetArchiveChecksum(string archive);
 
-    /************************************************************************/
-    /*     OPTIONS                                                          */
-    /************************************************************************/
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetFullUnitName(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetMapOptionCount(string mapName);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetMapArchiveCount(string mapName);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetModOptionCount();
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetMapArchiveName(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionKey(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetMapCount();
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionName(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetMapName(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionDesc(int index);
+		/************************************************************************/
+		/*     OPTIONS                                                          */
+		/************************************************************************/
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetOptionType(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetMapOptionCount(string mapName);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern float GetOptionNumberMin(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetModOptionCount();
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern float GetOptionNumberMax(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetOptionBoolDef(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern float GetOptionNumberStep(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionDesc(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetOptionStringMaxLen(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionKey(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetOptionListCount(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetOptionListCount(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionListItemKey(int index, int itemIndex);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionListDef(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionListItemName(int index, int itemIndex);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionListItemDesc(int index, int itemIndex);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionListItemDesc(int index, int itemIndex);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionListItemKey(int index, int itemIndex);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int GetOptionBoolDef(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionListItemName(int index, int itemIndex);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern float GetOptionNumberDef(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionName(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionStringDef(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern float GetOptionNumberDef(int index);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern string GetOptionListDef(int index);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern float GetOptionNumberMax(int index);
 
-    /*
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern float GetOptionNumberMin(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern float GetOptionNumberStep(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetOptionStringDef(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetOptionStringMaxLen(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetOptionType(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetPrimaryModArchive(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetPrimaryModArchiveCount(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetPrimaryModArchiveList(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern uint GetMapChecksumFromName(string mapName);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern uint GetMapChecksum(int mapIndex);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern uint GetPrimaryModChecksum(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetPrimaryModCount();
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetPrimaryModName(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetSideCount();
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetSideName(int index);
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int GetUnitCount();
+
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern string GetUnitName(int index);
+
+		/*
     //     INIT
     */
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern int Init(bool isServer, int id);
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int Init(bool isServer, int id);
 
+		/// &lt;summary&gt;
+		/// Gets map list from unit sync, does not make full reinit by default
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		private void LoadMapList()
+		{
+			string opath = Directory.GetCurrentDirectory();
+			Directory.SetCurrentDirectory(path);
 
-    [DllImport(&quot;unitsync.dll&quot;)]
-    private static extern void UnInit();
+			int mapCount = GetMapCount();
+			mapList.Clear();
+			for (int i = 0; i &lt; mapCount; ++i) {
+				var mi = new MapInfo(this, GetMapName(i), i);
+				mapList[mi.Name] = mi;
+				mi.ArchiveName = RequestMapArchive(mi.Name);
+			}
+			Directory.SetCurrentDirectory(opath);
+		}
 
 
-    internal void Reload(bool reloadMods, bool reloadMaps)
-    {
-      if (reloadMods || reloadMaps) ReInit(true);
-      if (reloadMaps) LoadMapList();
-      if (reloadMods) LoadModList();
-    }
+		/// &lt;summary&gt;
+		/// Gets mod list - does not make full reinit by default
+		/// &lt;/summary&gt;
+		/// &lt;returns&gt;&lt;/returns&gt;
+		private void LoadModList()
+		{
+			string opath = Directory.GetCurrentDirectory();
+			Directory.SetCurrentDirectory(path);
 
-    #region Nested type: ListOption
-    public struct ListOption
-    {
-      public string Description;
-      public string Key;
-      public string Name;
+			int modCount = GetPrimaryModCount();
 
-      public ListOption(int optionIndex, int itemIndex)
-      {
-        Name = GetOptionListItemName(optionIndex, itemIndex);
-        Description = GetOptionListItemDesc(optionIndex, itemIndex);
-        Key = GetOptionListItemKey(optionIndex, itemIndex);
-      }
-    }
-    #endregion
+			modList.Clear();
+			for (int i = 0; i &lt; modCount; ++i) {
+				var mi = new ModInfo(this, GetPrimaryModName(i), i);
+				modList[mi.Name] = mi;
+			}
+		}
 
-    #region Nested type: Option
-    public class Option
-    {
-      #region Type enum
-      public enum Type : int
-      {
-        Error = 0,
-        Bool = 1,
-        List = 2,
-        Number = 3,
-        String = 4
-      } ;
-      #endregion
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern int ProcessUnitsNoChecksum();
 
-      public string Default;
-      public string Description;
-      public string Key;
-      public List&lt;ListOption&gt; ListOptions = new List&lt;ListOption&gt;();
+		/// &lt;summary&gt;
+		/// ReInits unitsync
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;full&quot;&gt;if true does complete reinit (neccesary to find new map or mod), if false does just archivescannerinit&lt;/param&gt;
+		private void ReInit(bool full)
+		{
+			string opath = Directory.GetCurrentDirectory();
+			Directory.SetCurrentDirectory(path);
 
-      private float max = float.MinValue;
-      private float min = float.MinValue;
-      public string Name;
-      public Type OptionType;
-      private float step = 0, strMaxLen = 65535;
-      private string Table = &quot;GAME\\MODOPTIONS\\&quot;;
+			if (full) {
+				UnInit();
+				if (Init(false, 0) != 1) throw new Exception(&quot;unitsync.dll init failed&quot;);
+			}
+			//if (InitArchiveScanner() != 1) throw new Exception(&quot;unitsync.dll:InitArchiveScanner() failed&quot;);
 
-      public Option(int idx)
-      {
-        Name = GetOptionName(idx);
-        Key = GetOptionKey(idx);
-        Description = GetOptionDesc(idx);
-        OptionType = (Type)GetOptionType(idx);
-        strMaxLen = GetOptionStringMaxLen(idx);
-        min = GetOptionNumberMin(idx);
-        max = GetOptionNumberMax(idx);
-        step = GetOptionNumberStep(idx);
-        int listCount = GetOptionListCount(idx);
-        for (int i = 0; i &lt; listCount; i++) {
-          ListOption optl = new ListOption(idx, i);
-          ListOptions.Add(optl);
-        }
-        switch (OptionType) {
-          case Type.Bool:
-            Default = GetOptionBoolDef(idx).ToString();
-            break;
-          case Type.Number:
-            Default = GetOptionNumberDef(idx).ToString();
-            break;
-          case Type.String:
-            Default = GetOptionStringDef(idx);
-            break;
-          case Type.List:
-            Default = GetOptionListDef(idx);
-            break;
-        }
-      }
+			Directory.SetCurrentDirectory(opath);
+		}
 
-      private string ConstructLine(string val)
-      {
-        return Table + Key + &quot;=&quot; + val;
-      }
+		private string RequestMapArchive(string mapname)
+		{
+			int i = GetMapArchiveCount(mapname);
+			if (i &gt; 0) {
+				string arch = GetMapArchiveName(0);
+				int lastslash = arch.LastIndexOfAny(new[] {'/', '\\'});
+				return arch.Substring(lastslash + 1);
+			} else return &quot;&quot;;
+		}
 
-      public bool GetPair(string Value, out string result)
-      {
-        result = &quot;&quot;;
-        switch (OptionType) {
-          case Type.Bool:
-            if (Value != &quot;0&quot; &amp;&amp; Value != &quot;1&quot;) return false;
-            result = ConstructLine(Value);
-            return true;
 
-          case Type.Number:
-            double d;
-            if (!double.TryParse(Value, out d)) return false;
-            if (d &lt; min || d &gt; max) return false;
-            result = ConstructLine(Value);
-            return true;
+		[DllImport(&quot;unitsync.dll&quot;)]
+		private static extern void UnInit();
 
-          case Type.String:
-            if (Value.Length &gt; strMaxLen) return false;
-            result = ConstructLine(Value);
-            return true;
+		#endregion
 
-          case Type.List:
-            foreach (ListOption lop in ListOptions) {
-              if (lop.Key == Value) {
-                result = ConstructLine(lop.Key);
-                return true;
-              }
-            }
-            return false;
-        }
+		#region Nested type: ListOption
 
-        return false;
-      }
+		public struct ListOption
+		{
+			#region Properties
 
-      public override string ToString()
-      {
-        string pom = &quot;&quot;;
-        string typs = &quot;&quot;;
-        if (OptionType == Type.Number) {
-          typs = &quot;x&quot;;
-          pom += &quot; = &quot;;
-          if (min != float.MinValue) pom += &quot; &gt;=&quot; + min;
-          if (max != float.MaxValue) pom += &quot; &lt;=&quot; + max;
-        }
-        if (OptionType == Type.List) {
-          pom += &quot; = &quot;;
-          foreach (ListOption lop in ListOptions) {
-            pom += lop.Key + &quot;-&quot; + lop.Description + &quot; | &quot;;
-            typs += lop.Key + &quot;|&quot;;
-          }
-        }
-        if (OptionType == Type.Bool) typs += &quot;0|1&quot;;
-        if (OptionType == Type.String) typs += &quot;s&quot;;
+			public string Description;
+			public string Key;
+			public string Name;
 
-        return string.Format(&quot;{0}={1}  ({2}{3})&quot;, Key, typs, Description, pom);
-      }
-    }
-    #endregion
-  }
+			#endregion
+
+			#region Constructors
+
+			public ListOption(int optionIndex, int itemIndex)
+			{
+				Name = GetOptionListItemName(optionIndex, itemIndex);
+				Description = GetOptionListItemDesc(optionIndex, itemIndex);
+				Key = GetOptionListItemKey(optionIndex, itemIndex);
+			}
+
+			#endregion
+		}
+
+		#endregion
+
+		#region Nested type: Option
+
+		public class Option
+		{
+			#region Type enum
+
+			public enum Type
+			{
+				Error = 0,
+				Bool = 1,
+				List = 2,
+				Number = 3,
+				String = 4
+			} ;
+
+			#endregion
+
+			#region Fields
+
+			private float max = float.MinValue;
+			private float min = float.MinValue;
+			private float step, strMaxLen = 65535;
+			private string Table = &quot;GAME/MODOPTIONS/&quot;;
+
+			#endregion
+
+			#region Properties
+
+			public string Default;
+			public string Description;
+			public string Key;
+			public List&lt;ListOption&gt; ListOptions = new List&lt;ListOption&gt;();
+
+			public string Name;
+			public Type OptionType;
+
+			#endregion
+
+			#region Constructors
+
+			public Option(int idx)
+			{
+				Name = GetOptionName(idx);
+				Key = GetOptionKey(idx);
+				Description = GetOptionDesc(idx);
+				OptionType = (Type) GetOptionType(idx);
+				strMaxLen = GetOptionStringMaxLen(idx);
+				min = GetOptionNumberMin(idx);
+				max = GetOptionNumberMax(idx);
+				step = GetOptionNumberStep(idx);
+				int listCount = GetOptionListCount(idx);
+				for (int i = 0; i &lt; listCount; i++) {
+					var optl = new ListOption(idx, i);
+					ListOptions.Add(optl);
+				}
+				switch (OptionType) {
+					case Type.Bool:
+						Default = GetOptionBoolDef(idx).ToString();
+						break;
+					case Type.Number:
+						Default = GetOptionNumberDef(idx).ToString();
+						break;
+					case Type.String:
+						Default = GetOptionStringDef(idx);
+						break;
+					case Type.List:
+						Default = GetOptionListDef(idx);
+						break;
+				}
+			}
+
+			#endregion
+
+			#region Public methods
+
+			public bool GetPair(string Value, out string result)
+			{
+				result = &quot;&quot;;
+				switch (OptionType) {
+					case Type.Bool:
+						if (Value != &quot;0&quot; &amp;&amp; Value != &quot;1&quot;) return false;
+						result = ConstructLine(Value);
+						return true;
+
+					case Type.Number:
+						double d;
+						if (!double.TryParse(Value, out d)) return false;
+						if (d &lt; min || d &gt; max) return false;
+						result = ConstructLine(Value);
+						return true;
+
+					case Type.String:
+						if (strMaxLen != 0 &amp;&amp; Value.Length &gt; strMaxLen) return false;
+						result = ConstructLine(Value);
+						return true;
+
+					case Type.List:
+						foreach (var lop in ListOptions) {
+							if (lop.Key == Value) {
+								result = ConstructLine(lop.Key);
+								return true;
+							}
+						}
+						return false;
+				}
+
+				return false;
+			}
+
+			#endregion
+
+			#region Overrides
+
+			public override string ToString()
+			{
+				string pom = &quot;&quot;;
+				string typs = &quot;&quot;;
+				if (OptionType == Type.Number) {
+					typs = &quot;x&quot;;
+					pom += &quot; = &quot;;
+					if (min != float.MinValue) pom += &quot; &gt;=&quot; + min;
+					if (max != float.MaxValue) pom += &quot; &lt;=&quot; + max;
+				}
+				if (OptionType == Type.List) {
+					pom += &quot; = &quot;;
+					foreach (var lop in ListOptions) {
+						pom += lop.Key + &quot;-&quot; + lop.Description + &quot; | &quot;;
+						typs += lop.Key + &quot;|&quot;;
+					}
+				}
+				if (OptionType == Type.Bool) typs += &quot;0|1&quot;;
+				if (OptionType == Type.String) typs += &quot;s&quot;;
+
+				return string.Format(&quot;{0}={1}  ({2}{3})&quot;, Key, typs, Description, pom);
+			}
+
+			#endregion
+
+			#region Other methods
+
+			private string ConstructLine(string val)
+			{
+				return Table + Key + &quot;=&quot; + val;
+			}
+
+			#endregion
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/utils/AutoUpdater.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/utils/AutoUpdater.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/utils/AutoUpdater.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Diagnostics;
 using System.IO;
@@ -9,127 +11,145 @@
 using Springie.SpringNamespace;
 using Timer=System.Timers.Timer;
 
+#endregion
+
 namespace Springie
 {
-  internal class AutoUpdater
-  {
-    /************************************************************************/
-    /*    PRIVATE ATTRIBS                                                   */
-    /************************************************************************/
+	internal class AutoUpdater
+	{
+		/************************************************************************/
+		/*    PRIVATE ATTRIBS                                                   */
+		/************************************************************************/
 
-    private const int updateCheckInterval = 1; //in minutes
-    private const string updateSite = &quot;<A HREF="http://springie.licho.eu/">http://springie.licho.eu/</A>&quot;;
-    private Spring spring;
-    private TasClient tas;
-    private Timer timer;
+		#region Constants
 
-    /************************************************************************/
-    /*    PUBLIC METHODS                                                    */
-    /************************************************************************/
+		private const int updateCheckInterval = 1; //in minutes
+		private const string updateSite = &quot;<A HREF="http://springie.licho.eu/">http://springie.licho.eu/</A>&quot;;
 
-    /// &lt;summary&gt;
-    /// Initializes auto downloader
-    /// &lt;/summary&gt;
-    public AutoUpdater(Spring spring, TasClient tas)
-    {
-      this.spring = spring;
-      this.tas = tas;
+		#endregion
 
-      timer = new Timer();
-      timer.Interval = updateCheckInterval*1000*60;
-      timer.AutoReset = true;
-      timer.Elapsed += timer_Elapsed;
-      timer.Start();
-      spring.SpringExited += spring_SpringExited;
-    }
+		#region Fields
 
-    private bool enabled
-    {
-      get { return Program.main.config.AutoUpdate; }
-    }
+		private bool enabled
+		{
+			get { return Program.main.config.AutoUpdate; }
+		}
 
-    private void timer_Elapsed(object sender, ElapsedEventArgs e)
-    {
-      updateSpringie();
-    }
+		private Spring spring;
+		private TasClient tas;
+		private Timer timer;
 
-    private void spring_SpringExited(object sender, EventArgs e)
-    {
-      updateSpringie();
-    }
+		#endregion
 
+		/************************************************************************/
+		/*    PUBLIC METHODS                                                    */
+		/************************************************************************/
 
-    /************************************************************************/
-    /*    PRIVATE METHODS                                                   */
-    /************************************************************************/
+		#region Constructors
 
-    private void updateSpringie()
-    {
-      if (enabled &amp;&amp; !spring.IsRunning) {
-        timer.Enabled = false;
+		/// &lt;summary&gt;
+		/// Initializes auto downloader
+		/// &lt;/summary&gt;
+		public AutoUpdater(Spring spring, TasClient tas)
+		{
+			this.spring = spring;
+			this.tas = tas;
 
-        UpdateCa();
+			timer = new Timer();
+			timer.Interval = updateCheckInterval*1000*60;
+			timer.AutoReset = true;
+			timer.Elapsed += timer_Elapsed;
+			timer.Start();
+			spring.SpringExited += spring_SpringExited;
+		}
 
-        using (WebClient wc = new WebClient()) {
-          try {
-            string remoteVersion = wc.DownloadString(updateSite + &quot;version.txt&quot;).Trim();
-            if (!string.IsNullOrEmpty(remoteVersion) &amp;&amp; remoteVersion != MainConfig.SpringieVersion.Trim()) {
-              string target = Application.ExecutablePath;
-              target = target.Remove(target.LastIndexOf('.'));
-              target += &quot;.upd&quot;;
+		#endregion
 
-              tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;Springie is now downloading new version&quot;, true);
-              wc.DownloadFile(updateSite + &quot;springie.upd&quot;, target);
+		#region Other methods
 
-              File.Delete(Application.ExecutablePath + &quot;.bak&quot;);
-              File.Move(Application.ExecutablePath, Application.ExecutablePath + &quot;.bak&quot;);
-              File.Move(target, Application.ExecutablePath);
-              tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;Springie is auto-upgrading to newer version, rejoin please&quot;, true);
+		private static int ExtractVersionNumber(string modname)
+		{
+			int ver = 0;
+			var m = Regex.Match(modname, &quot;\\-([0-9]+)&quot;);
+			if (m.Success) int.TryParse(m.Groups[1].Value, out ver);
+			return ver;
+		}
 
-              Process.Start(Application.ExecutablePath);
-              Application.Exit();
-            }
-          } catch (WebException) {}
-        }
-        timer.Enabled = true;
-      }
-    }
 
-    private static int ExtractVersionNumber(string modname)
-    {
-      int ver = 0;
-      Match m = Regex.Match(modname, &quot;\\-([0-9]+)&quot;);
-      if (m.Success) int.TryParse(m.Groups[1].Value, out ver);
-      return ver;
-    }
+		private void UpdateCa()
+		{
+			if (Program.main.config.CaUpdating == MainConfig.CaUpdateMode.None) return;
 
+			var b = tas.GetBattle();
+			if (b != null) {
+				spring.Reload(true, false);
+				string selMod = b.Mod.Name;
+				int vers = int.MinValue;
+				foreach (var s in spring.UnitSync.ModList.Keys) {
+					if (s.Contains(&quot;Complete Annihilation&quot;)) {
+						if ((Program.main.config.CaUpdating == MainConfig.CaUpdateMode.Stable &amp;&amp; s.Contains(&quot;stable&quot;)) || Program.main.config.CaUpdating == MainConfig.CaUpdateMode.Latest) {
+							int nv = ExtractVersionNumber(s);
+							if (nv &gt; vers) {
+								vers = nv;
+								selMod = s;
+							}
+						}
+					}
+				}
 
-    private void UpdateCa()
-    {
-      if (Program.main.config.CaUpdating == MainConfig.CaUpdateMode.None) return;
+				if (b.Mod.Name != selMod) {
+					tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;Springie is now rehosting to new version of CA - &quot; + selMod, true);
+					Program.main.AutoHost.ComRehost(TasSayEventArgs.Default, new[] {selMod});
+				}
+			}
+		}
 
-      Battle b = tas.GetBattle();
-      if (b != null) {
-        spring.Reload(true, false);
-        string selMod = b.Mod.Name;
-        int vers = int.MinValue;
-        foreach (string s in spring.UnitSync.ModList.Keys) {
-          if (s.Contains(&quot;Complete Annihilation&quot;)) {
-            if ((Program.main.config.CaUpdating == MainConfig.CaUpdateMode.Stable &amp;&amp; s.Contains(&quot;stable&quot;)) || Program.main.config.CaUpdating == MainConfig.CaUpdateMode.Latest) {
-              int nv = ExtractVersionNumber(s);
-              if (nv &gt; vers) {
-                vers = nv;
-                selMod = s;
-              }
-            }
-          }
-        }
+		private void updateSpringie()
+		{
+			if (enabled &amp;&amp; !spring.IsRunning) {
+				timer.Enabled = false;
 
-        if (b.Mod.Name != selMod) {
-          tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;Springie is now rehosting to new version of CA - &quot; + selMod, true);
-          Program.main.AutoHost.ComRehost(TasSayEventArgs.Default, new string[] {selMod});
-        }
-      }
-    }
-  }
+				UpdateCa();
+
+				using (var wc = new WebClient()) {
+					try {
+						string remoteVersion = wc.DownloadString(updateSite + &quot;version.txt&quot;).Trim();
+						if (!string.IsNullOrEmpty(remoteVersion) &amp;&amp; remoteVersion != MainConfig.SpringieVersion.Trim()) {
+							string target = Application.ExecutablePath;
+							target = target.Remove(target.LastIndexOf('.'));
+							target += &quot;.upd&quot;;
+
+							tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;Springie is now downloading new version&quot;, true);
+							wc.DownloadFile(updateSite + &quot;springie.upd&quot;, target);
+
+							File.Delete(Application.ExecutablePath + &quot;.bak&quot;);
+							File.Move(Application.ExecutablePath, Application.ExecutablePath + &quot;.bak&quot;);
+							File.Move(target, Application.ExecutablePath);
+							tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;Springie is auto-upgrading to newer version, rejoin please&quot;, true);
+
+							Process.Start(Application.ExecutablePath);
+							Application.Exit();
+						}
+					} catch (WebException) {}
+				}
+				timer.Enabled = true;
+			}
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void spring_SpringExited(object sender, EventArgs e)
+		{
+			updateSpringie();
+		}
+
+		private void timer_Elapsed(object sender, ElapsedEventArgs e)
+		{
+			updateSpringie();
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/utils/FileDownloader.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/utils/FileDownloader.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/utils/FileDownloader.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.Net;
@@ -5,199 +7,217 @@
 using System.Threading;
 using Springie.SpringNamespace;
 
+#endregion
+
 namespace Springie
 {
-  /// &lt;summary&gt;
-  /// Class responsible for downloading new Mods to spring
-  /// &lt;/summary&gt;
-  internal class FileDownloader
-  {
-    #region FileType enum
-    /// &lt;summary&gt;
-    /// Download progress has changed
-    /// &lt;/summary&gt;
-    //public event EventHandler&lt;TasEventArgs&gt; DownloadProgressChanged;
-    /// &lt;summary&gt;
-    /// How often to report progresschanged (in percents)
-    /// &lt;/summary&gt;
-    //public const int ReportPercentStep = 20;
-    public enum FileType
-    {
-      Map,
-      Mod
-    }
-    #endregion
+	/// &lt;summary&gt;
+	/// Class responsible for downloading new Mods to spring
+	/// &lt;/summary&gt;
+	internal class FileDownloader
+	{
+		#region FileType enum
 
-    #region Status enum
-    public enum Status
-    {
-      Done,
-      Failed
-    } ;
-    #endregion
+		/// &lt;summary&gt;
+		/// Download progress has changed
+		/// &lt;/summary&gt;
+		//public event EventHandler&lt;TasEventArgs&gt; DownloadProgressChanged;
+		/// &lt;summary&gt;
+		/// How often to report progresschanged (in percents)
+		/// &lt;/summary&gt;
+		//public const int ReportPercentStep = 20;
+		public enum FileType
+		{
+			Map,
+			Mod
+		}
 
-    private DownloadItem currentDownload = null;
-    private Queue&lt;DownloadItem&gt; downloadQueue = new Queue&lt;DownloadItem&gt;();
-    private Thread downloadThread = null;
+		#endregion
 
-    /************************************************************************/
-    /*    PRIVATE ATTRIBS                                                   */
-    /************************************************************************/
+		#region Status enum
 
-    private Spring spring;
-    private WebClient wc = null;
+		public enum Status
+		{
+			Done,
+			Failed
+		} ;
 
+		#endregion
 
-    /************************************************************************/
-    /*    PUBLIC METHODS                                                    */
-    /************************************************************************/
+		#region Fields
 
-    /// &lt;summary&gt;
-    /// Initializes Mod downloader
-    /// &lt;/summary&gt;
-    public FileDownloader(Spring spring)
-    {
-      this.spring = spring;
-    }
+		private DownloadItem currentDownload;
+		private Queue&lt;DownloadItem&gt; downloadQueue = new Queue&lt;DownloadItem&gt;();
+		private Thread downloadThread;
 
-    /// &lt;summary&gt;
-    /// Download completed (either successfully or unsuccessfully)
-    /// &lt;/summary&gt;
-    public event EventHandler&lt;DownloadEventArgs&gt; DownloadCompleted;
+		/************************************************************************/
+		/*    PRIVATE ATTRIBS                                                   */
+		/************************************************************************/
 
+		private Spring spring;
+		private WebClient wc;
 
-    /// &lt;summary&gt;
-    /// Queues file for download
-    /// &lt;/summary&gt;
-    public void DownloadFile(string url, string fileName, FileType fileType)
-    {
-      DownloadItem d = new DownloadItem();
-      d.url = new Uri(url);
-      d.fileType = fileType;
-      if (fileType == FileType.Map) d.targetPath = spring.Path + &quot;maps/&quot;;
-      else if (fileType == FileType.Mod) d.targetPath = spring.Path + &quot;mods/&quot;;
-      d.fileName = fileName;
-      downloadQueue.Enqueue(d);
+		#endregion
 
-      if (downloadQueue.Count == 1 &amp;&amp; (downloadThread == null || downloadThread.IsAlive == false)) {
-        downloadThread = new Thread(delegate()
-                                      {
-                                        wc = new WebClient();
-                                        GetNext();
-                                      });
-        downloadThread.Start();
-      }
-    }
+		/************************************************************************/
+		/*    PUBLIC METHODS                                                    */
+		/************************************************************************/
 
+		#region Events
 
-    public static bool IsFileUrl(string what, out string fileName)
-    {
-      fileName = &quot;&quot;;
-      if (what.StartsWith(&quot;<A HREF="http://">http://</A>&quot;) || what.StartsWith(&quot;<A HREF="ftp://">ftp://</A>&quot;)) {
-        string[] fs = what.Split(new char[] {'/', '\\', '?'}, StringSplitOptions.RemoveEmptyEntries);
-        if (fs.Length &gt; 0) {
-          fileName = fs[fs.Length - 1];
-          return true;
-        }
-      }
-      return false;
-    }
+		/// &lt;summary&gt;
+		/// Download completed (either successfully or unsuccessfully)
+		/// &lt;/summary&gt;
+		public event EventHandler&lt;DownloadEventArgs&gt; DownloadCompleted;
 
+		#endregion
 
-    /// &lt;summary&gt;
-    /// Prepares map download
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;mapNameUrlOrId&quot;&gt;&lt;/param&gt;
-    public void DownloadMap(string mapNameUrlOrId)
-    {
-      string realFileName = &quot;&quot;;
+		#region Constructors
 
-      if (IsFileUrl(mapNameUrlOrId, out realFileName)) {
-        DownloadFile(mapNameUrlOrId, realFileName, FileType.Map);
-        return;
-      }
+		/// &lt;summary&gt;
+		/// Initializes Mod downloader
+		/// &lt;/summary&gt;
+		public FileDownloader(Spring spring)
+		{
+			this.spring = spring;
+		}
 
-      try {
-        WebClient wc2 = new WebClient();
-        string result = &quot;&quot;;
-        if (mapNameUrlOrId.Contains(&quot;.&quot;)) {
-          result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?filename=">http://www.unknown-files.net/licho.php?filename=</A>&quot; + mapNameUrlOrId.Replace(&quot;.smf&quot;, &quot;.sd7&quot;)); // try sd7 first
+		#endregion
 
-          if (result == &quot;error&quot; || result == &quot;&quot;) result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?filename=">http://www.unknown-files.net/licho.php?filename=</A>&quot; + mapNameUrlOrId.Replace(&quot;.smf&quot;, &quot;.sdz&quot;)); //then sdz
-        } else result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?id=">http://www.unknown-files.net/licho.php?id=</A>&quot; + mapNameUrlOrId);
+		#region Public methods
 
-        string realUrl = &quot;&quot;;
-        try {
-          realUrl = Regex.Match(result, &quot;file=(.*)&quot;).Groups[1].Value;
-          realFileName = Regex.Match(result, &quot;filename=([^\\&amp;]+)&quot;).Groups[1].Value;
-        } catch {
-          if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;File not found&quot;));
-          return;
-        }
-        if (realFileName == &quot;&quot;) {
-          if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;File not found&quot;));
-          return;
-        }
+		/// &lt;summary&gt;
+		/// Queues file for download
+		/// &lt;/summary&gt;
+		public void DownloadFile(string url, string fileName, FileType fileType)
+		{
+			var d = new DownloadItem();
+			d.url = new Uri(url);
+			d.fileType = fileType;
+			if (fileType == FileType.Map) d.targetPath = spring.Path + &quot;maps/&quot;;
+			else if (fileType == FileType.Mod) d.targetPath = spring.Path + &quot;mods/&quot;;
+			d.fileName = fileName;
+			downloadQueue.Enqueue(d);
 
-        string mapSmf = realFileName.Substring(0, realFileName.LastIndexOf('.')) + &quot;.smf&quot;;
-        if (spring.UnitSync.HasMap(mapSmf)) {
-          // we have this map already let's fuck this
-          if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;We already have this map&quot;));
-          return;
-        }
+			if (downloadQueue.Count == 1 &amp;&amp; (downloadThread == null || downloadThread.IsAlive == false)) {
+				downloadThread = new Thread(delegate()
+				                            	{
+				                            		wc = new WebClient();
+				                            		GetNext();
+				                            	});
+				downloadThread.Start();
+			}
+		}
 
-        DownloadFile(realUrl, realFileName, FileType.Map);
-      } catch {
-        if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;Error while determining map URL&quot;));
-        return;
-      }
-    }
 
+		/// &lt;summary&gt;
+		/// Prepares map download
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;mapNameUrlOrId&quot;&gt;&lt;/param&gt;
+		public void DownloadMap(string mapNameUrlOrId)
+		{
+			string realFileName = &quot;&quot;;
 
-    /// &lt;summary&gt;
-    /// Prepares mod download
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;modNameUrlOrId&quot;&gt;&lt;/param&gt;
-    public void DownloadMod(string modUrlOrId)
-    {
-      string realFileName = &quot;&quot;;
+			if (IsFileUrl(mapNameUrlOrId, out realFileName)) {
+				DownloadFile(mapNameUrlOrId, realFileName, FileType.Map);
+				return;
+			}
 
-      if (IsFileUrl(modUrlOrId, out realFileName)) {
-        DownloadFile(modUrlOrId, realFileName, FileType.Mod);
-        return;
-      }
+			try {
+				var wc2 = new WebClient();
+				string result = &quot;&quot;;
+				if (mapNameUrlOrId.Contains(&quot;.&quot;)) {
+					result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?filename=">http://www.unknown-files.net/licho.php?filename=</A>&quot; + mapNameUrlOrId.Replace(&quot;.smf&quot;, &quot;.sd7&quot;)); // try sd7 first
 
-      try {
-        WebClient wc2 = new WebClient();
-        string result = &quot;&quot;;
+					if (result == &quot;error&quot; || result == &quot;&quot;) result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?filename=">http://www.unknown-files.net/licho.php?filename=</A>&quot; + mapNameUrlOrId.Replace(&quot;.smf&quot;, &quot;.sdz&quot;)); //then sdz
+				} else result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?id=">http://www.unknown-files.net/licho.php?id=</A>&quot; + mapNameUrlOrId);
 
-        // otherwise use unknown files
-        result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?id=">http://www.unknown-files.net/licho.php?id=</A>&quot; + modUrlOrId + &quot;&amp;mod=yes&quot;);
+				string realUrl = &quot;&quot;;
+				try {
+					realUrl = Regex.Match(result, &quot;file=(.*)&quot;).Groups[1].Value;
+					realFileName = Regex.Match(result, &quot;filename=([^\\&amp;]+)&quot;).Groups[1].Value;
+				} catch {
+					if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;File not found&quot;));
+					return;
+				}
+				if (realFileName == &quot;&quot;) {
+					if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;File not found&quot;));
+					return;
+				}
 
-        realFileName = &quot;&quot;;
-        try {
-          realFileName = Regex.Match(result, &quot;file=([^\\&amp;]+)&quot;).Groups[1].Value;
-        } catch {
-          if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, modUrlOrId), Status.Failed, &quot;File not found&quot;));
-          return;
-        }
-        if (realFileName == &quot;&quot;) {
-          if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, modUrlOrId), Status.Failed, &quot;File not found&quot;));
-          return;
-        }
+				string mapSmf = realFileName.Substring(0, realFileName.LastIndexOf('.')) + &quot;.smf&quot;;
+				if (spring.UnitSync.HasMap(mapSmf)) {
+					// we have this map already let's fuck this
+					if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;We already have this map&quot;));
+					return;
+				}
 
-        DownloadFile(result, realFileName, FileType.Mod);
-      } catch {
-        if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, modUrlOrId), Status.Failed, &quot;Error while determining mod URL&quot;));
-        return;
-      }
-    }
+				DownloadFile(realUrl, realFileName, FileType.Map);
+			} catch {
+				if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, mapNameUrlOrId), Status.Failed, &quot;Error while determining map URL&quot;));
+				return;
+			}
+		}
 
 
-    /************************************************************************/
-    /*     EVENT HANDLERS                                                   */
-    /************************************************************************/
-    /*void wc_DownloadProgressChanged(object sender, DownloadProgressChangedEventArgs e)
+		/// &lt;summary&gt;
+		/// Prepares mod download
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;modNameUrlOrId&quot;&gt;&lt;/param&gt;
+		public void DownloadMod(string modUrlOrId)
+		{
+			string realFileName = &quot;&quot;;
+
+			if (IsFileUrl(modUrlOrId, out realFileName)) {
+				DownloadFile(modUrlOrId, realFileName, FileType.Mod);
+				return;
+			}
+
+			try {
+				var wc2 = new WebClient();
+				string result = &quot;&quot;;
+
+				// otherwise use unknown files
+				result = wc2.DownloadString(&quot;<A HREF="http://www.unknown-files.net/licho.php?id=">http://www.unknown-files.net/licho.php?id=</A>&quot; + modUrlOrId + &quot;&amp;mod=yes&quot;);
+
+				realFileName = &quot;&quot;;
+				try {
+					realFileName = Regex.Match(result, &quot;file=([^\\&amp;]+)&quot;).Groups[1].Value;
+				} catch {
+					if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, modUrlOrId), Status.Failed, &quot;File not found&quot;));
+					return;
+				}
+				if (realFileName == &quot;&quot;) {
+					if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, modUrlOrId), Status.Failed, &quot;File not found&quot;));
+					return;
+				}
+
+				DownloadFile(result, realFileName, FileType.Mod);
+			} catch {
+				if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(new DownloadItem(FileType.Map, modUrlOrId), Status.Failed, &quot;Error while determining mod URL&quot;));
+				return;
+			}
+		}
+
+		public static bool IsFileUrl(string what, out string fileName)
+		{
+			fileName = &quot;&quot;;
+			if (what.StartsWith(&quot;<A HREF="http://">http://</A>&quot;) || what.StartsWith(&quot;<A HREF="ftp://">ftp://</A>&quot;)) {
+				var fs = what.Split(new[] {'/', '\\', '?'}, StringSplitOptions.RemoveEmptyEntries);
+				if (fs.Length &gt; 0) {
+					fileName = fs[fs.Length - 1];
+					return true;
+				}
+			}
+			return false;
+		}
+
+		#endregion
+
+		/************************************************************************/
+		/*     EVENT HANDLERS                                                   */
+		/************************************************************************/
+		/*void wc_DownloadProgressChanged(object sender, DownloadProgressChangedEventArgs e)
     {
       if (e.ProgressPercentage &gt;= lastPercent + ReportPercentStep) {
         lastPercent = (e.ProgressPercentage / ReportPercentStep) * ReportPercentStep;
@@ -215,67 +235,92 @@
       GetNext();
     }*/
 
-    /************************************************************************/
-    /*     STATIC METHODS                                                   */
-    /************************************************************************/
+		/************************************************************************/
+		/*     STATIC METHODS                                                   */
+		/************************************************************************/
 
 
-    /************************************************************6************/
-    /*    PRIVATE METHODS                                                   */
-    /************************************************************************/
+		/************************************************************6************/
+		/*    PRIVATE METHODS                                                   */
+		/************************************************************************/
 
-    /// &lt;summary&gt;
-    /// Tries to handle next request from queue
-    /// &lt;/summary&gt;
-    private void GetNext()
-    {
-      if (downloadQueue.Count == 0 || wc.IsBusy) return;
+		#region Other methods
 
-      currentDownload = downloadQueue.Dequeue();
-      // lastPercent = 0;
-      try {
-        wc.DownloadFile(currentDownload.url, currentDownload.targetPath + &quot;/&quot; + currentDownload.fileName);
+		/// &lt;summary&gt;
+		/// Tries to handle next request from queue
+		/// &lt;/summary&gt;
+		private void GetNext()
+		{
+			if (downloadQueue.Count == 0 || wc.IsBusy) return;
 
-        if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(currentDownload, Status.Done, &quot;&quot;));
-      } catch (Exception e) {
-        if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(currentDownload, Status.Failed, e.Message));
-      }
-      GetNext();
+			currentDownload = downloadQueue.Dequeue();
+			// lastPercent = 0;
+			try {
+				wc.DownloadFile(currentDownload.url, currentDownload.targetPath + &quot;/&quot; + currentDownload.fileName);
 
-      //wc.DownloadFileAsync(currentDownload.url, currentDownload.targetPath + &quot;/&quot; + currentDownload.fileName);
-    }
+				if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(currentDownload, Status.Done, &quot;&quot;));
+			} catch (Exception e) {
+				if (DownloadCompleted != null) DownloadCompleted(this, new DownloadEventArgs(currentDownload, Status.Failed, e.Message));
+			}
+			GetNext();
 
-    #region Nested type: DownloadEventArgs
-    public class DownloadEventArgs : EventArgs
-    {
-      public DownloadItem DownloadItem;
-      public string Message;
-      public Status Status;
+			//wc.DownloadFileAsync(currentDownload.url, currentDownload.targetPath + &quot;/&quot; + currentDownload.fileName);
+		}
 
-      public DownloadEventArgs(DownloadItem item, Status status, string message)
-      {
-        DownloadItem = item;
-        Status = status;
-        Message = message;
-      }
-    }
-    #endregion
+		#endregion
 
-    #region Nested type: DownloadItem
-    public class DownloadItem
-    {
-      public string fileName;
-      public FileType fileType;
-      public string targetPath;
-      public Uri url;
-      public DownloadItem() {}
+		#region Nested type: DownloadEventArgs
 
-      public DownloadItem(FileType fileType, string fileName)
-      {
-        this.fileType = fileType;
-        this.fileName = fileName;
-      }
-    } ;
-    #endregion
-  }
+		public class DownloadEventArgs : EventArgs
+		{
+			#region Properties
+
+			public DownloadItem DownloadItem;
+			public string Message;
+			public Status Status;
+
+			#endregion
+
+			#region Constructors
+
+			public DownloadEventArgs(DownloadItem item, Status status, string message)
+			{
+				DownloadItem = item;
+				Status = status;
+				Message = message;
+			}
+
+			#endregion
+		}
+
+		#endregion
+
+		#region Nested type: DownloadItem
+
+		public class DownloadItem
+		{
+			#region Properties
+
+			public string fileName;
+			public FileType fileType;
+			public string targetPath;
+			public Uri url;
+
+			#endregion
+
+			#region Constructors
+
+			public DownloadItem() {}
+
+			public DownloadItem(FileType fileType, string fileName)
+			{
+				this.fileType = fileType;
+				this.fileName = fileName;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/utils/MyCol.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/utils/MyCol.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/utils/MyCol.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,149 +1,170 @@
+#region using
+
 using System.Drawing;
 
+#endregion
+
 namespace Springie
 {
-  /// &lt;summary&gt;
-  /// Structure for storing lightweight color info and transformation from and to spring format
-  /// &lt;/summary&gt;
-  public struct MyCol
-  {
-    /************************************************************************/
-    /*   PUBLIC ATTRIBS                                                     */
-    /************************************************************************/
-    public byte B;
-    public byte G;
-    public byte R;
+	/// &lt;summary&gt;
+	/// Structure for storing lightweight color info and transformation from and to spring format
+	/// &lt;/summary&gt;
+	public struct MyCol
+	{
+		/************************************************************************/
+		/*   PUBLIC ATTRIBS                                                     */
+		/************************************************************************/
 
-    /************************************************************************/
-    /*   PUBLIC METHODS                                                     */
-    /************************************************************************/
+		#region Properties
 
-    public MyCol(byte r, byte g, byte b)
-    {
-      R = r;
-      G = g;
-      B = b;
-    }
+		public byte B;
+		public byte G;
+		public byte R;
 
-    /// &lt;summary&gt;
-    /// Conversion to color format
-    /// &lt;/summary&gt;
-    public static explicit operator Color(MyCol m)
-    {
-      return Color.FromArgb(m.R, m.G, m.B);
-    }
+		#endregion
 
-    /// &lt;summary&gt;
-    /// Conversion from color format
-    /// &lt;/summary&gt;
-    public static explicit operator MyCol(Color c)
-    {
-      return new MyCol(c.R, c.G, c.B);
-    }
+		/************************************************************************/
+		/*   PUBLIC METHODS                                                     */
+		/************************************************************************/
 
-    /// &lt;summary&gt;
-    /// Conversion to spring (tasclient) format
-    /// &lt;/summary&gt;
-    public static explicit operator int(MyCol m)
-    {
-      int ret = m.B;
-      ret = ret &lt;&lt; 8;
-      ret += m.G;
-      ret = ret &lt;&lt; 8;
-      ret += m.R;
-      return ret;
-    }
+		#region Constructors
 
-    /// &lt;summary&gt;
-    /// Conversion from spring (tasclient) format
-    /// &lt;/summary&gt;
-    public static explicit operator MyCol(int c)
-    {
-      byte r = (byte)(c &amp; 255);
-      c = c &gt;&gt; 8;
-      byte g = (byte)(c &amp; 255);
-      c = c &gt;&gt; 8;
-      byte b = (byte)(c &amp; 255);
-      return new MyCol(r, g, b);
-    }
+		public MyCol(byte r, byte g, byte b)
+		{
+			R = r;
+			G = g;
+			B = b;
+		}
 
-    /// &lt;summary&gt;
-    /// This method calculates visual apparent &quot;distance&quot; of colors
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;e1&quot;&gt;first color to compare&lt;/param&gt;
-    /// &lt;param name=&quot;e2&quot;&gt;second color to compare&lt;/param&gt;
-    /// &lt;returns&gt;Return number representing distance .. values under 30 000 or so seems similar&lt;/returns&gt;
-    public static int Distance(MyCol e1, MyCol e2)
-    {
-      int r, g, b;
-      int rmean;
-      rmean = ((int)e1.R + (int)e2.R)/2;
-      r = (int)e1.R - (int)e2.R;
-      g = (int)e1.G - (int)e2.G;
-      b = (int)e1.B - (int)e2.B;
-      return (((512 + rmean)*r*r) &gt;&gt; 8) + 4*g*g + (((767 - rmean)*b*b) &gt;&gt; 8);
-    }
+		#endregion
 
-    public int Distance(MyCol e2)
-    {
-      return Distance(this, e2);
-    }
+		#region Public methods
 
-    public static int operator %(MyCol e1, MyCol e2)
-    {
-      return Distance(e1, e2);
-    }
+		/// &lt;summary&gt;
+		/// This method calculates visual apparent &quot;distance&quot; of colors
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;e1&quot;&gt;first color to compare&lt;/param&gt;
+		/// &lt;param name=&quot;e2&quot;&gt;second color to compare&lt;/param&gt;
+		/// &lt;returns&gt;Return number representing distance .. values under 30 000 or so seems similar&lt;/returns&gt;
+		public static int Distance(MyCol e1, MyCol e2)
+		{
+			int r, g, b;
+			int rmean;
+			rmean = (e1.R + e2.R)/2;
+			r = e1.R - e2.R;
+			g = e1.G - e2.G;
+			b = e1.B - e2.B;
+			return (((512 + rmean)*r*r) &gt;&gt; 8) + 4*g*g + (((767 - rmean)*b*b) &gt;&gt; 8);
+		}
 
-    /// &lt;summary&gt;
-    /// Tries to change one color to not be so similar to others
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;input&quot;&gt;array of colors to process&lt;/param&gt;
-    /// &lt;param name=&quot;index&quot;&gt;index of current color to check against others&lt;/param&gt;
-    /// &lt;param name=&quot;bestCol&quot;&gt;output color (most far from others)&lt;/param&gt;
-    /// &lt;returns&gt;minimum distance of best colors to others&lt;/returns&gt;
-    public static int GetBestRelocation(MyCol[] input, int index, out MyCol bestCol)
-    {
-      int bestVal;
-      bestCol = new MyCol(0, 0, 0);
-      bestVal = int.MinValue;
+		public int Distance(MyCol e2)
+		{
+			return Distance(this, e2);
+		}
 
-      MyCol temp = new MyCol();
-      for (short r = 20; r &lt;= 255; r += 3) {
-        for (short g = 20; g &lt;= 255; g += 3) {
-          for (short b = 50; b &lt;= 255; b += 3) {
-            temp.R = (byte)r;
-            temp.G = (byte)g;
-            temp.B = (byte)b;
+		/// &lt;summary&gt;
+		/// Processes input array of colors and if some colors are too similar, it changes them to be more different
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;input&quot;&gt;Array of colors to process&lt;/param&gt;
+		/// &lt;param name=&quot;balanceDistance&quot;&gt;Treshold distance, if two colors are more similar than this, it changes one of them&lt;/param&gt;
+		public static void FixColors(MyCol[] input, int balanceDistance)
+		{
+			for (int i = 0; i &lt; input.Length - 1; ++i) for (int j = i + 1; j &lt; input.Length; ++j) if (input[i]%input[j] &lt; balanceDistance) GetBestRelocation(input, i, out input[i]);
+		}
 
-            int minDist = int.MaxValue;
-            for (int i = 0; i &lt; input.Length; ++i) {
-              if (i == index) continue;
-              int cDistance = temp%input[i];
-              if (cDistance &lt;= bestVal) {
-                minDist = int.MinValue;
-                break;
-              }
-              if (cDistance &lt; minDist) minDist = cDistance;
-            }
+		/// &lt;summary&gt;
+		/// Tries to change one color to not be so similar to others
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;input&quot;&gt;array of colors to process&lt;/param&gt;
+		/// &lt;param name=&quot;index&quot;&gt;index of current color to check against others&lt;/param&gt;
+		/// &lt;param name=&quot;bestCol&quot;&gt;output color (most far from others)&lt;/param&gt;
+		/// &lt;returns&gt;minimum distance of best colors to others&lt;/returns&gt;
+		public static int GetBestRelocation(MyCol[] input, int index, out MyCol bestCol)
+		{
+			int bestVal;
+			bestCol = new MyCol(0, 0, 0);
+			bestVal = int.MinValue;
 
-            if (minDist &gt; bestVal) {
-              bestVal = minDist;
-              bestCol = temp;
-            }
-          }
-        }
-      }
-      return bestVal;
-    }
+			var temp = new MyCol();
+			for (short r = 20; r &lt;= 255; r += 3) {
+				for (short g = 20; g &lt;= 255; g += 3) {
+					for (short b = 50; b &lt;= 255; b += 3) {
+						temp.R = (byte) r;
+						temp.G = (byte) g;
+						temp.B = (byte) b;
 
-    /// &lt;summary&gt;
-    /// Processes input array of colors and if some colors are too similar, it changes them to be more different
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;input&quot;&gt;Array of colors to process&lt;/param&gt;
-    /// &lt;param name=&quot;balanceDistance&quot;&gt;Treshold distance, if two colors are more similar than this, it changes one of them&lt;/param&gt;
-    public static void FixColors(MyCol[] input, int balanceDistance)
-    {
-      for (int i = 0; i &lt; input.Length - 1; ++i) for (int j = i + 1; j &lt; input.Length; ++j) if (input[i]%input[j] &lt; balanceDistance) GetBestRelocation(input, i, out input[i]);
-    }
-  } ;
+						int minDist = int.MaxValue;
+						for (int i = 0; i &lt; input.Length; ++i) {
+							if (i == index) continue;
+							int cDistance = temp%input[i];
+							if (cDistance &lt;= bestVal) {
+								minDist = int.MinValue;
+								break;
+							}
+							if (cDistance &lt; minDist) minDist = cDistance;
+						}
+
+						if (minDist &gt; bestVal) {
+							bestVal = minDist;
+							bestCol = temp;
+						}
+					}
+				}
+			}
+			return bestVal;
+		}
+
+		#endregion
+
+		#region Operators
+
+		/// &lt;summary&gt;
+		/// Conversion to color format
+		/// &lt;/summary&gt;
+		public static explicit operator Color(MyCol m)
+		{
+			return Color.FromArgb(m.R, m.G, m.B);
+		}
+
+		/// &lt;summary&gt;
+		/// Conversion from color format
+		/// &lt;/summary&gt;
+		public static explicit operator MyCol(Color c)
+		{
+			return new MyCol(c.R, c.G, c.B);
+		}
+
+		/// &lt;summary&gt;
+		/// Conversion to spring (tasclient) format
+		/// &lt;/summary&gt;
+		public static explicit operator int(MyCol m)
+		{
+			int ret = m.B;
+			ret = ret &lt;&lt; 8;
+			ret += m.G;
+			ret = ret &lt;&lt; 8;
+			ret += m.R;
+			return ret;
+		}
+
+		/// &lt;summary&gt;
+		/// Conversion from spring (tasclient) format
+		/// &lt;/summary&gt;
+		public static explicit operator MyCol(int c)
+		{
+			byte r = (byte) (c &amp; 255);
+			c = c &gt;&gt; 8;
+			byte g = (byte) (c &amp; 255);
+			c = c &gt;&gt; 8;
+			byte b = (byte) (c &amp; 255);
+			return new MyCol(r, g, b);
+		}
+
+		public static int operator %(MyCol e1, MyCol e2)
+		{
+			return Distance(e1, e2);
+		}
+
+		#endregion
+	} ;
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/utils/Stats.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/utils/Stats.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/utils/Stats.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.IO;
@@ -7,260 +9,285 @@
 using System.Threading;
 using System.Windows.Forms;
 using System.Xml.Serialization;
+using PlanetWarsShared;
+using PlanetWarsShared.Springie;
 using Springie.Client;
 using Springie.SpringNamespace;
 
+#endregion
+
 namespace Springie
 {
-  public class Stats
-  {
-    public const string accountsFileName = &quot;do_not_delete_me.xml&quot;;
-    public const string gatherScript = &quot;statsGather.php&quot;;
-    public const string smurfScript = &quot;smurfs.php&quot;;
-    public const string statsScript = &quot;stats.php&quot;;
-    private List&lt;Account&gt; accounts = new List&lt;Account&gt;();
-    private Battle battle;
-    private string password = &quot;&quot;;
-    private Dictionary&lt;string, Player&gt; players = new Dictionary&lt;string, Player&gt;();
-    private Spring spring;
-    private DateTime startTime;
-    private TasClient tas;
+	public class Stats
+	{
+		#region Constants
 
-    public Stats(TasClient tas, Spring spring)
-    {
-      this.tas = tas;
-      this.spring = spring;
+		public const string accountsFileName = &quot;do_not_delete_me.xml&quot;;
+		public const string gatherScript = &quot;statsGather.php&quot;;
+		public const string smurfScript = &quot;smurfs.php&quot;;
+		public const string statsScript = &quot;stats.php&quot;;
 
-      LoadAccounts();
+		#endregion
 
-      tas.LoginAccepted += new EventHandler&lt;TasEventArgs&gt;(tas_LoginAccepted);
-      if (Program.main.config.GargamelMode) {
-        tas.UserRemoved += new EventHandler&lt;TasEventArgs&gt;(tas_UserRemoved);
-        tas.BattleUserIpRecieved += new EventHandler&lt;TasEventArgs&gt;(tas_BattleUserIpRecieved);
-        tas.UserStatusChanged += new EventHandler&lt;TasEventArgs&gt;(tas_UserStatusChanged);
-      }
-      spring.SpringStarted += new EventHandler(spring_SpringStarted);
-      spring.PlayerJoined += new EventHandler&lt;SpringLogEventArgs&gt;(spring_PlayerJoined);
-      spring.PlayerLeft += new EventHandler&lt;SpringLogEventArgs&gt;(spring_PlayerLeft);
-      spring.PlayerLost += new EventHandler&lt;SpringLogEventArgs&gt;(spring_PlayerLost);
-      spring.PlayerDisconnected += new EventHandler&lt;SpringLogEventArgs&gt;(spring_PlayerDisconnected);
-      spring.GameOver += new EventHandler&lt;SpringLogEventArgs&gt;(spring_GameOver);
-    }
+		#region Fields
 
-    protected string StatsUrl
-    {
-      get { return Program.main.config.StatsUrlAddressReal; }
-    }
+		private List&lt;Account&gt; accounts = new List&lt;Account&gt;();
+		private Battle battle;
+		private string password = &quot;&quot;;
+		private Dictionary&lt;string, EndGamePlayerInfo&gt; players = new Dictionary&lt;string, EndGamePlayerInfo&gt;();
+		private Spring spring;
+		private DateTime startTime;
 
-    protected string UserName
-    {
-      get
-      {
-        if (tas != null &amp;&amp; !string.IsNullOrEmpty(tas.UserName)) return tas.UserName;
-        else return Program.main.config.AccountName;
-      }
-    }
+		protected string StatsUrl
+		{
+			get { return Program.main.config.StatsUrlAddressReal; }
+		}
 
-    public string SendCommand(string script, string query, bool async, bool hash)
-    {
-      Uri uri;
-      try {
-        if (hash) {
-          query += &quot;&amp;login=&quot; + UserName;
-          uri = new Uri(StatsUrl + script + &quot;?&quot; + query.Replace(&quot;#&quot;, &quot;%23&quot;) + &quot;&amp;hash=&quot; + CalculateHexMD5Hash(query + password));
+		private TasClient tas;
 
-          Console.WriteLine(query);
-          Console.WriteLine(CalculateHexMD5Hash(query + password));
-        } else uri = new Uri(StatsUrl + script + &quot;?&quot; + query);
+		protected string UserName
+		{
+			get
+			{
+				if (tas != null &amp;&amp; !string.IsNullOrEmpty(tas.UserName)) return tas.UserName;
+				else return Program.main.config.AccountName;
+			}
+		}
 
-        if (async) {
-          Thread t1 = new Thread(delegate(object s)
-                                   {
-                                     try {
-                                       WebClient wc = new WebClient();
-                                       wc.DownloadString((Uri)s);
-                                     } catch {}
-                                   });
-          t1.Start(uri);
-          return &quot;&quot;;
-        } else {
-          WebClient wc = new WebClient();
-          return wc.DownloadString(uri);
-        }
-      } catch {
-        return &quot;&quot;;
-      }
-    }
+		#endregion
 
+		#region Constructors
 
-    private void tas_UserStatusChanged(object sender, TasEventArgs e)
-    {
-      User u;
-      if (tas.GetExistingUser(e.ServerParams[0], out u)) SendCommand(gatherScript, &quot;a=addplayer&amp;name=&quot; + u.name + &quot;&amp;rank=&quot; + (u.rank + 1), true, true);
-    }
+		public Stats(TasClient tas, Spring spring)
+		{
+			this.tas = tas;
+			this.spring = spring;
 
-    private void tas_BattleUserIpRecieved(object sender, TasEventArgs e)
-    {
-      User u;
-      if (tas.GetExistingUser(e.ServerParams[0], out u)) SendCommand(gatherScript, &quot;a=joinplayer&amp;name=&quot; + u.name + &quot;&amp;rank=&quot; + u.rank + &quot;&amp;ip=&quot; + e.ServerParams[1], true, true);
-    }
+			LoadAccounts();
 
+			tas.LoginAccepted += tas_LoginAccepted;
+			if (Program.main.config.GargamelMode) {
+				tas.UserRemoved += tas_UserRemoved;
+				tas.BattleUserIpRecieved += tas_BattleUserIpRecieved;
+				tas.UserStatusChanged += tas_UserStatusChanged;
+			}
+			spring.SpringStarted += spring_SpringStarted;
+			spring.PlayerJoined += spring_PlayerJoined;
+			spring.PlayerLeft += spring_PlayerLeft;
+			spring.PlayerLost += spring_PlayerLost;
+			spring.PlayerDisconnected += spring_PlayerDisconnected;
+			spring.GameOver += spring_GameOver;
+		}
 
-    private void spring_GameOver(object sender, SpringLogEventArgs e)
-    {
-      string query = String.Format(&quot;a=battle&amp;map={0}&amp;mod={1}&amp;title={2}&amp;start={3}&amp;duration={4}&quot;, battle.Map.Name, battle.Mod.Name, battle.Title, Utils.ToUnix(startTime), Utils.ToUnix(DateTime.Now.Subtract(startTime)));
+		#endregion
 
-      foreach (Player p in players.Values) if (!p.Spectator &amp;&amp; p.AliveTillEnd) foreach (Player pset in players.Values) if (pset.AllyNumber == p.AllyNumber &amp;&amp; !pset.Spectator) pset.OnVictoryTeam = true;
+		#region Public methods
 
-      foreach (Player p in players.Values) query += &quot;&amp;player[]=&quot; + p;
+		public static string CalculateHexMD5Hash(string input)
+		{
+			var md5 = MD5.Create();
+			var inputBytes = Encoding.ASCII.GetBytes(input);
+			var hash = md5.ComputeHash(inputBytes);
 
-      // send only if there were at least 2 players in game
-      if (players.Count &gt; 1) SendCommand(gatherScript, query, true, true);
-    }
+			var sb = new StringBuilder();
+			for (int i = 0; i &lt; hash.Length; i++) sb.Append(hash[i].ToString(&quot;x2&quot;));
+			return sb.ToString();
+		}
 
-    private void spring_PlayerDisconnected(object sender, SpringLogEventArgs e)
-    {
-      if (RegisterPlayerInCombat(e.Username)) players[e.Username].DisconnectTime = DateTime.Now.Subtract(startTime);
-    }
+		public string SendCommand(string script, string query, bool async, bool hash)
+		{
+			Uri uri;
+			try {
+				if (hash) {
+					query += &quot;&amp;login=&quot; + UserName;
+					uri = new Uri(StatsUrl + script + &quot;?&quot; + query.Replace(&quot;#&quot;, &quot;%23&quot;) + &quot;&amp;hash=&quot; + CalculateHexMD5Hash(query + password));
 
-    private void spring_PlayerLost(object sender, SpringLogEventArgs e)
-    {
-      if (RegisterPlayerInCombat(e.Username)) {
-        players[e.Username].LoseTime = DateTime.Now.Subtract(startTime);
-        players[e.Username].AliveTillEnd = false;
-      }
-    }
+					Console.WriteLine(query);
+					Console.WriteLine(CalculateHexMD5Hash(query + password));
+				} else uri = new Uri(StatsUrl + script + &quot;?&quot; + query);
 
-    private void spring_PlayerLeft(object sender, SpringLogEventArgs e)
-    {
-      if (RegisterPlayerInCombat(e.Username)) players[e.Username].LeaveTime = DateTime.Now.Subtract(startTime);
-    }
+				if (async) {
+					var t1 = new Thread(delegate(object s)
+					                    	{
+					                    		try {
+					                    			var wc = new WebClient();
+					                    			wc.DownloadString((Uri) s);
+					                    		} catch {}
+					                    	});
+					t1.Start(uri);
+					return &quot;&quot;;
+				} else {
+					var wc = new WebClient();
+					return wc.DownloadString(uri);
+				}
+			} catch {
+				return &quot;&quot;;
+			}
+		}
 
-    private bool RegisterPlayerInCombat(string name)
-    {
-      if (players.ContainsKey(name)) return true;
-      Player p = new Player();
-      p.Name = name;
-      int idx = battle.GetUserIndex(name);
-      if (idx != -1) {
-        p.Side = battle.Mod.Sides[battle.Users[idx].Side];
-        p.Spectator = battle.Users[idx].IsSpectator;
-        p.AllyNumber = battle.Users[idx].AllyNumber;
-        p.Ip = battle.Users[idx].ip.ToString();
+		#endregion
 
-        User u;
-        if (tas.GetExistingUser(name, out u)) p.Rank = u.rank + 1;
-      } else return false;
-      players.Add(name, p);
-      return true;
-    }
+		#region Other methods
 
-    private void spring_PlayerJoined(object sender, SpringLogEventArgs e)
-    {
-      if (e.Username == UserName) return; // do not add autohost itself
-      RegisterPlayerInCombat(e.Username);
-    }
+		private void LoadAccounts()
+		{
+			if (File.Exists(accountsFileName)) {
+				var s = new XmlSerializer(accounts.GetType());
+				var r = File.OpenText(accountsFileName);
+				accounts = (List&lt;Account&gt;) s.Deserialize(r);
+				r.Close();
+			}
+		}
 
-    private void spring_SpringStarted(object sender, EventArgs e)
-    {
-      battle = tas.GetBattle();
-      players = new Dictionary&lt;string, Player&gt;();
-      startTime = DateTime.Now;
-    }
+		private bool RegisterPlayerInCombat(string name)
+		{
+			if (players.ContainsKey(name)) return true;
+			var p = new EndGamePlayerInfo();
+			p.Name = name;
+			int idx = battle.GetUserIndex(name);
+			if (idx != -1) {
+				p.Side = battle.Mod.Sides[battle.Users[idx].Side];
+				p.Spectator = battle.Users[idx].IsSpectator;
+				p.AllyNumber = battle.Users[idx].AllyNumber;
+				p.Ip = battle.Users[idx].ip.ToString();
 
-    private void tas_UserRemoved(object sender, TasEventArgs e)
-    {
-      SendCommand(gatherScript, &quot;a=removeplayer&amp;name=&quot; + e.ServerParams[0], true, true);
-    }
+				User u;
+				if (tas.GetExistingUser(name, out u)) p.Rank = u.rank + 1;
+			} else return false;
+			players.Add(name, p);
+			return true;
+		}
 
+		private void SaveAccounts()
+		{
+			var s = new XmlSerializer(accounts.GetType());
+			var f = File.OpenWrite(accountsFileName);
+			f.SetLength(0);
+			s.Serialize(f, accounts);
+			f.Close();
+		}
 
-    private void tas_LoginAccepted(object sender, TasEventArgs e)
-    {
-      Account a = accounts.Find(delegate(Account acc) { return acc.UserName == UserName; });
-      if (a != null) password = a.Password;
+		#endregion
 
-      if (password == &quot;&quot;) {
-        password = SendCommand(gatherScript, &quot;a=register&amp;name=&quot; + UserName, false, false);
-        if (password != &quot;&quot;) {
-          if (password.StartsWith(&quot;FAILED&quot;)) MessageBox.Show(&quot;You need correct password to submit stats with account &quot; + UserName + &quot;, stats won't work - &quot; + password, &quot;Stats registration failed&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
-          else {
-            accounts.Add(new Account(UserName, password));
-            SaveAccounts();
-          }
-        } else MessageBox.Show(&quot;Error registering to stats server - stats server probably down. Statistics wont work until next Springie start&quot;, &quot;Stats registration failed&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
-      }
-    }
+		#region Event Handlers
 
-    private void SaveAccounts()
-    {
-      XmlSerializer s = new XmlSerializer(accounts.GetType());
-      FileStream f = File.OpenWrite(accountsFileName);
-      f.SetLength(0);
-      s.Serialize(f, accounts);
-      f.Close();
-    }
+		private void spring_GameOver(object sender, SpringLogEventArgs e)
+		{
+			string query = String.Format(&quot;a=battle&amp;map={0}&amp;mod={1}&amp;title={2}&amp;start={3}&amp;duration={4}&quot;, battle.Map.Name, battle.Mod.Name, battle.Title, Utils.ToUnix(startTime), Utils.ToUnix(DateTime.Now.Subtract(startTime)));
 
-    private void LoadAccounts()
-    {
-      if (File.Exists(accountsFileName)) {
-        XmlSerializer s = new XmlSerializer(accounts.GetType());
-        StreamReader r = File.OpenText(accountsFileName);
-        accounts = (List&lt;Account&gt;)s.Deserialize(r);
-        r.Close();
-      }
-    }
+			foreach (var p in players.Values) if (!p.Spectator &amp;&amp; p.AliveTillEnd) foreach (var pset in players.Values) if (pset.AllyNumber == p.AllyNumber &amp;&amp; !pset.Spectator) pset.OnVictoryTeam = true;
 
-    public static string CalculateHexMD5Hash(string input)
-    {
-      MD5 md5 = MD5.Create();
-      byte[] inputBytes = Encoding.ASCII.GetBytes(input);
-      byte[] hash = md5.ComputeHash(inputBytes);
+			foreach (var p in players.Values) query += &quot;&amp;player[]=&quot; + p;
 
-      StringBuilder sb = new StringBuilder();
-      for (int i = 0; i &lt; hash.Length; i++) sb.Append(hash[i].ToString(&quot;x2&quot;));
-      return sb.ToString();
-    }
+			if (Program.main.config.PlanetWarsEnabled) {
+				try {
+					var pw = Program.main.PlanetWars;
 
-    #region Nested type: Account
-    public class Account
-    {
-      public string Password;
-      public string UserName;
-      public Account() {}
+					string response = pw.SendBattleResult(new AuthInfo {Login = Program.main.config.PlanetWarsServerLogin, Password = Program.main.config.PlanetWarsServerPassword}, battle.Map.Name, players.Values);
 
-      public Account(string userName, string password)
-      {
-        UserName = userName;
-        Password = password;
-      }
-    } ;
-    #endregion
+					Program.main.AutoHost.SayBattle(response);
+					foreach (var p in players.Values) if (p.Name != tas.UserName) tas.Say(TasClient.SayPlace.User, p.Name, response, false);
+				} catch (Exception ex) {
+					Program.main.AutoHost.SayBattle(string.Format(&quot;Error sending planet battle result :(( {0}&quot;, ex.Message), true);
+				}
+			}
 
-    #region Nested type: Player
-    private class Player
-    {
-      public bool AliveTillEnd = true;
-      public int AllyNumber = 0;
-      public TimeSpan DisconnectTime;
-      public string Ip = &quot;&quot;;
-      public TimeSpan LeaveTime;
-      public TimeSpan LoseTime;
-      public string Name = &quot;&quot;;
-      public bool OnVictoryTeam = false;
-      public int Rank = 0; // - actually rank + 1 .. starts at 1 and not 0
-      public string Side = &quot;&quot;; // mod side
-      public bool Spectator = false;
+			// send only if there were at least 2 players in game
+			if (players.Count &gt; 1) SendCommand(gatherScript, query, true, true);
+		}
 
-      public override string ToString()
-      {
-        string ret = &quot;&quot;;
-        ret += Name + &quot;|&quot; + Ip + &quot;|&quot; + (Spectator ? &quot;1&quot; : &quot;0&quot;) + &quot;|&quot;;
-        ret += (OnVictoryTeam ? &quot;1&quot; : &quot;0&quot;) + &quot;|&quot; + (AliveTillEnd ? &quot;1&quot; : &quot;0&quot;) + &quot;|&quot;;
-        ret += Utils.ToUnix(DisconnectTime) + &quot;|&quot; + Utils.ToUnix(LeaveTime) + &quot;|&quot;;
-        ret += Side + &quot;|&quot; + Utils.ToUnix(LoseTime) + &quot;|&quot; + AllyNumber + &quot;|&quot; + Rank;
-        return ret;
-      }
-    } ;
-    #endregion
-  }
+		private void spring_PlayerDisconnected(object sender, SpringLogEventArgs e)
+		{
+			if (RegisterPlayerInCombat(e.Username)) players[e.Username].DisconnectTime = DateTime.Now.Subtract(startTime);
+		}
+
+		private void spring_PlayerJoined(object sender, SpringLogEventArgs e)
+		{
+			if (e.Username == UserName) return; // do not add autohost itself
+			RegisterPlayerInCombat(e.Username);
+		}
+
+		private void spring_PlayerLeft(object sender, SpringLogEventArgs e)
+		{
+			if (RegisterPlayerInCombat(e.Username)) players[e.Username].LeaveTime = DateTime.Now.Subtract(startTime);
+		}
+
+		private void spring_PlayerLost(object sender, SpringLogEventArgs e)
+		{
+			if (RegisterPlayerInCombat(e.Username)) {
+				players[e.Username].LoseTime = DateTime.Now.Subtract(startTime);
+				players[e.Username].AliveTillEnd = false;
+			}
+		}
+
+		private void spring_SpringStarted(object sender, EventArgs e)
+		{
+			battle = tas.GetBattle();
+			players = new Dictionary&lt;string, EndGamePlayerInfo&gt;();
+			startTime = DateTime.Now;
+		}
+
+		private void tas_BattleUserIpRecieved(object sender, TasEventArgs e)
+		{
+			User u;
+			if (tas.GetExistingUser(e.ServerParams[0], out u)) SendCommand(gatherScript, &quot;a=joinplayer&amp;name=&quot; + u.name + &quot;&amp;rank=&quot; + u.rank + &quot;&amp;ip=&quot; + e.ServerParams[1], true, true);
+		}
+
+
+		private void tas_LoginAccepted(object sender, TasEventArgs e)
+		{
+			var a = accounts.Find(delegate(Account acc) { return acc.UserName == UserName; });
+			if (a != null) password = a.Password;
+
+			if (password == &quot;&quot;) {
+				password = SendCommand(gatherScript, &quot;a=register&amp;name=&quot; + UserName, false, false);
+				if (password != &quot;&quot;) {
+					if (password.StartsWith(&quot;FAILED&quot;)) MessageBox.Show(&quot;You need correct password to submit stats with account &quot; + UserName + &quot;, stats won't work - &quot; + password, &quot;Stats registration failed&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
+					else {
+						accounts.Add(new Account(UserName, password));
+						SaveAccounts();
+					}
+				} else MessageBox.Show(&quot;Error registering to stats server - stats server probably down. Statistics wont work until next Springie start&quot;, &quot;Stats registration failed&quot;, MessageBoxButtons.OK, MessageBoxIcon.Warning);
+			}
+		}
+
+		private void tas_UserRemoved(object sender, TasEventArgs e)
+		{
+			SendCommand(gatherScript, &quot;a=removeplayer&amp;name=&quot; + e.ServerParams[0], true, true);
+		}
+
+		private void tas_UserStatusChanged(object sender, TasEventArgs e)
+		{
+			User u;
+			if (tas.GetExistingUser(e.ServerParams[0], out u)) SendCommand(gatherScript, &quot;a=addplayer&amp;name=&quot; + u.name + &quot;&amp;rank=&quot; + (u.rank + 1), true, true);
+		}
+
+		#endregion
+
+		#region Nested type: Account
+
+		public class Account
+		{
+			#region Properties
+
+			public string Password;
+			public string UserName;
+
+			#endregion
+
+			#region Constructors
+
+			public Account() {}
+
+			public Account(string userName, string password)
+			{
+				UserName = userName;
+				Password = password;
+			}
+
+			#endregion
+		} ;
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/utils/UnknownFilesLinker.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/utils/UnknownFilesLinker.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/utils/UnknownFilesLinker.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,3 +1,5 @@
+#region using
+
 using System;
 using System.Collections.Generic;
 using System.Net;
@@ -6,117 +8,146 @@
 using Springie.Client;
 using Springie.SpringNamespace;
 
+#endregion
+
 namespace Springie
 {
-  /// &lt;summary&gt;
-  /// Class responsible for providing map links
-  /// &lt;/summary&gt;
-  public class UnknownFilesLinker
-  {
-    /************************************************************************/
-    /*   PRIVATE ATTRIBS                                                    */
-    /************************************************************************/
+	/// &lt;summary&gt;
+	/// Class responsible for providing map links
+	/// &lt;/summary&gt;
+	public class UnknownFilesLinker
+	{
+		/************************************************************************/
+		/*   PRIVATE ATTRIBS                                                    */
+		/************************************************************************/
 
-    #region FileType enum
-    public enum FileType
-    {
-      Map = 13,
-      Mod = 14
-    }
-    #endregion
+		#region Constants
 
-    private const int DeleteCacheInterval = 3600; // inerval in seconds
-    private Dictionary&lt;string, string&gt; cachedResults = new Dictionary&lt;string, string&gt;();
-    private Spring spring;
-    private Timer timerDelResults = new Timer(DeleteCacheInterval*1000);
+		private const int DeleteCacheInterval = 3600; // inerval in seconds
 
-    /************************************************************************/
-    /*   PUBLIC METHODS                                                     */
-    /************************************************************************/
+		#endregion
 
-    public UnknownFilesLinker(Spring spring)
-    {
-      this.spring = spring;
-      timerDelResults.Elapsed += new ElapsedEventHandler(timerDelResults_Elapsed);
-      timerDelResults.Enabled = true;
-    }
+		#region FileType enum
 
-    /// &lt;summary&gt;
-    /// Gets map link from .smf map name
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;name&quot;&gt;.smf based map name&lt;/param&gt;
-    /// &lt;returns&gt;maplink to download corresponding map archive&lt;/returns&gt;
-    public string GetMapBounceLink(string name)
-    {
-      name = spring.GetMapArchiveName(name);
-      return &quot;<A HREF="http://spring.jobjol.nl/search_result.php?select_select=select_file_name&amp;search=">http://spring.jobjol.nl/search_result.php?select_select=select_file_name&amp;search=</A>&quot; + Uri.EscapeDataString(name);
-    }
+		public enum FileType
+		{
+			Map = 13,
+			Mod = 14
+		}
 
-    /// &lt;summary&gt;
-    /// Gets search results for full text map search
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;name&quot;&gt;Name to search for&lt;/param&gt;
-    /// &lt;returns&gt;Search results&lt;/returns&gt;
-    public string GetResults(string name, FileType type)
-    {
-      if (cachedResults.ContainsKey(name)) return cachedResults[name];
+		#endregion
 
-      WebClient wc = new WebClient();
-      string result = &quot;&quot;;
+		#region Fields
 
-      if (String.IsNullOrEmpty(name)) return &quot;you must type name of map, e.g. !maplink altored&quot;;
+		private Dictionary&lt;string, string&gt; cachedResults = new Dictionary&lt;string, string&gt;();
+		private Spring spring;
+		private Timer timerDelResults = new Timer(DeleteCacheInterval*1000);
 
-      try {
-        result = wc.DownloadString(&quot;<A HREF="http://spring.unknown-files.net/page/search/1/">http://spring.unknown-files.net/page/search/1/</A>&quot; + (int)type + &quot;/&quot; + name);
-      } catch {
-        return &quot;link search failed, unknown files down :(&quot;;
-      }
-      if (result == &quot;&quot; || !result.Contains(&quot;<A HREF="http://spring.unknown-files.net/file/">http://spring.unknown-files.net/file/</A>&quot;)) return &quot;link search failed, contact Licho&quot;;
+		#endregion
 
-      int start = result.IndexOf(&quot;&lt;b&gt;Search Results&lt;/b&gt;&quot;);
-      int end = result.IndexOf(&quot;&lt;b&gt;Quick Search&lt;/b&gt;&quot;);
-      if (start == -1 || end == -1) return &quot;no link found&quot;;
-      result = result.Substring(start, end - start); // pickup just result lines + something
+		/************************************************************************/
+		/*   PUBLIC METHODS                                                     */
+		/************************************************************************/
 
-      MatchCollection c = Regex.Matches(result, &quot;&lt;a href='(<A HREF="http://spring.unknown-files.net/file/[0-9">http://spring.unknown-files.net/file/[0-9</A>]*)[^&gt;]*&gt;([^&lt;]+)&quot;);
-      string response = &quot;&quot;;
-      foreach (Match m in c) response += m.Groups[2].Value + &quot; ---&gt; &quot; + m.Groups[1].Value + &quot;\n&quot;;
-      if (response == &quot;&quot;) response = &quot;no such map found&quot;;
-      cachedResults[name] = response;
-      return response;
-    }
+		#region Constructors
 
+		public UnknownFilesLinker(Spring spring)
+		{
+			this.spring = spring;
+			timerDelResults.Elapsed += timerDelResults_Elapsed;
+			timerDelResults.Enabled = true;
+		}
 
-    /// &lt;summary&gt;
-    /// Performs map search and says result
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;name&quot;&gt;map to search for&lt;/param&gt;
-    /// &lt;param name=&quot;tas&quot;&gt;tasclient to recieve response&lt;/param&gt;
-    /// &lt;param name=&quot;e&quot;&gt;say parameters (for forming response)&lt;/param&gt;
-    public void SayResults(string name, FileType type, TasClient tas, TasSayEventArgs e)
-    {
-      SayLines(GetResults(name, type), tas, e);
-    }
+		#endregion
 
+		#region Public methods
 
-    /************************************************************************/
-    /*   EVENT HANDLERS                                                     */
-    /************************************************************************/
+		/// &lt;summary&gt;
+		/// Gets map link from .smf map name
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;name&quot;&gt;.smf based map name&lt;/param&gt;
+		/// &lt;returns&gt;maplink to download corresponding map archive&lt;/returns&gt;
+		public string GetMapBounceLink(string name)
+		{
+			name = spring.GetMapArchiveName(name);
+			return &quot;<A HREF="http://spring.jobjol.nl/search_result.php?select_select=select_file_name&amp;search=">http://spring.jobjol.nl/search_result.php?select_select=select_file_name&amp;search=</A>&quot; + Uri.EscapeDataString(name) + &quot;  Or use CaDownloader to auto get maps for game: <A HREF="http://caspring.org/wiki/CaUpdater">http://caspring.org/wiki/CaUpdater</A>&quot;;
+		}
 
-    private void timerDelResults_Elapsed(object sender, ElapsedEventArgs e)
-    {
-      cachedResults = new Dictionary&lt;string, string&gt;();
-    }
+		/// &lt;summary&gt;
+		/// Gets search results for full text map search
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;name&quot;&gt;Name to search for&lt;/param&gt;
+		/// &lt;returns&gt;Search results&lt;/returns&gt;
+		public string GetResults(string name, FileType type)
+		{
+			return &quot;Use CaDownloader to get maps and mods automatically: <A HREF="http://caspring.org/wiki/CaUpdater">http://caspring.org/wiki/CaUpdater</A>&quot;;
+			if (cachedResults.ContainsKey(name)) return cachedResults[name];
 
+			var wc = new WebClient();
+			string result = &quot;&quot;;
 
-    /************************************************************************/
-    /*   PRIVATE METHODS                                                    */
-    /************************************************************************/
+			if (String.IsNullOrEmpty(name)) return &quot;you must type name of map, e.g. !maplink altored&quot;;
 
-    private void SayLines(string text, TasClient tas, TasSayEventArgs e)
-    {
-      string[] lines = text.Split(new char[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);
-      foreach (string l in lines) tas.Say(TasClient.SayPlace.User, e.UserName, l, false);
-    }
-  }
+			try {
+				result = wc.DownloadString(&quot;<A HREF="http://spring.unknown-files.net/page/search/1/">http://spring.unknown-files.net/page/search/1/</A>&quot; + (int) type + &quot;/&quot; + name);
+			} catch {
+				return &quot;link search failed, unknown files down :(&quot;;
+			}
+			if (result == &quot;&quot; || !result.Contains(&quot;<A HREF="http://spring.unknown-files.net/file/">http://spring.unknown-files.net/file/</A>&quot;)) return &quot;link search failed, contact Licho&quot;;
+
+			int start = result.IndexOf(&quot;&lt;b&gt;Search Results&lt;/b&gt;&quot;);
+			int end = result.IndexOf(&quot;&lt;b&gt;Quick Search&lt;/b&gt;&quot;);
+			if (start == -1 || end == -1) return &quot;no link found&quot;;
+			result = result.Substring(start, end - start); // pickup just result lines + something
+
+			var c = Regex.Matches(result, &quot;&lt;a href='(<A HREF="http://spring.unknown-files.net/file/[0-9">http://spring.unknown-files.net/file/[0-9</A>]*)[^&gt;]*&gt;([^&lt;]+)&quot;);
+			string response = &quot;&quot;;
+			foreach (Match m in c) response += m.Groups[2].Value + &quot; ---&gt; &quot; + m.Groups[1].Value + &quot;\n&quot;;
+			if (response == &quot;&quot;) response = &quot;no such map found&quot;;
+			cachedResults[name] = response;
+			return response;
+		}
+
+
+		/// &lt;summary&gt;
+		/// Performs map search and says result
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;name&quot;&gt;map to search for&lt;/param&gt;
+		/// &lt;param name=&quot;tas&quot;&gt;tasclient to recieve response&lt;/param&gt;
+		/// &lt;param name=&quot;e&quot;&gt;say parameters (for forming response)&lt;/param&gt;
+		public void SayResults(string name, FileType type, TasClient tas, TasSayEventArgs e)
+		{
+			SayLines(GetResults(name, type), tas, e);
+		}
+
+		#endregion
+
+		/************************************************************************/
+		/*   EVENT HANDLERS                                                     */
+		/************************************************************************/
+
+
+		/************************************************************************/
+		/*   PRIVATE METHODS                                                    */
+		/************************************************************************/
+
+		#region Other methods
+
+		private void SayLines(string text, TasClient tas, TasSayEventArgs e)
+		{
+			var lines = text.Split(new[] {'\n'}, StringSplitOptions.RemoveEmptyEntries);
+			foreach (var l in lines) tas.Say(TasClient.SayPlace.User, e.UserName, l, false);
+		}
+
+		#endregion
+
+		#region Event Handlers
+
+		private void timerDelResults_Elapsed(object sender, ElapsedEventArgs e)
+		{
+			cachedResults = new Dictionary&lt;string, string&gt;();
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie/utils/Utils.cs
===================================================================
--- branches/caiinterface/tools/springie/Springie/utils/Utils.cs	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie/utils/Utils.cs	2008-10-09 18:55:21 UTC (rev 6639)
@@ -1,56 +1,64 @@
+#region using
+
 using System;
 
+#endregion
+
 namespace Springie
 {
-  /// &lt;summary&gt;
-  /// General purpose static functions here
-  /// &lt;/summary&gt;
-  internal class Utils
-  {
-    /// &lt;summary&gt;
-    /// Glues remaining arguments together
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;args&quot;&gt;argument array&lt;/param&gt;
-    /// &lt;param name=&quot;startindex&quot;&gt;index to start gluing&lt;/param&gt;
-    /// &lt;returns&gt;glued string&lt;/returns&gt;
-    public static string Glue(string[] args, int startindex)
-    {
-      if (args.Length &lt;= startindex) return &quot;&quot;;
-      string ret = args[startindex];
-      for (int i = startindex + 1; i &lt; args.Length; ++i) ret += ' ' + args[i];
-      return ret;
-    }
+	/// &lt;summary&gt;
+	/// General purpose static functions here
+	/// &lt;/summary&gt;
+	internal class Utils
+	{
+		#region Public methods
 
-    public static string Glue(string[] args)
-    {
-      return Glue(args, 0);
-    }
+		/// &lt;summary&gt;
+		/// Glues remaining arguments together
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;args&quot;&gt;argument array&lt;/param&gt;
+		/// &lt;param name=&quot;startindex&quot;&gt;index to start gluing&lt;/param&gt;
+		/// &lt;returns&gt;glued string&lt;/returns&gt;
+		public static string Glue(string[] args, int startindex)
+		{
+			if (args.Length &lt;= startindex) return &quot;&quot;;
+			string ret = args[startindex];
+			for (int i = startindex + 1; i &lt; args.Length; ++i) ret += ' ' + args[i];
+			return ret;
+		}
 
-    /// &lt;summary&gt;
-    /// shifts array by given number of indexes
-    /// &lt;/summary&gt;
-    /// &lt;param name=&quot;input&quot;&gt;input array&lt;/param&gt;
-    /// &lt;param name=&quot;bynum&quot;&gt;if bynum is negative, creates shorter array starting at abs(bynum) element of original arraym, if bynum is positive creates new array and makes bynum empty pieces in the beginning&lt;/param&gt;
-    /// &lt;returns&gt;returned new array&lt;/returns&gt;
-    public static T[] ShiftArray&lt;T&gt;(T[] input, int bynum)
-    {
-      T[] ret = new T[input.Length + bynum];
-      if (bynum == 0) input.CopyTo(ret, 0);
-      else if (bynum &lt; 0) for (int i = 0; i &lt; ret.Length; ++i) ret[i] = input[i - bynum];
-      else if (bynum &gt; 0) for (int i = 0; i &lt; input.Length; ++i) ret[i + bynum] = input[i];
-      return ret;
-    }
+		public static string Glue(string[] args)
+		{
+			return Glue(args, 0);
+		}
 
-    public static long ToUnix(DateTime t)
-    {
-      if (t == DateTime.MinValue) return 0;
-      return (long)(t.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
-    }
+		/// &lt;summary&gt;
+		/// shifts array by given number of indexes
+		/// &lt;/summary&gt;
+		/// &lt;param name=&quot;input&quot;&gt;input array&lt;/param&gt;
+		/// &lt;param name=&quot;bynum&quot;&gt;if bynum is negative, creates shorter array starting at abs(bynum) element of original arraym, if bynum is positive creates new array and makes bynum empty pieces in the beginning&lt;/param&gt;
+		/// &lt;returns&gt;returned new array&lt;/returns&gt;
+		public static T[] ShiftArray&lt;T&gt;(T[] input, int bynum)
+		{
+			var ret = new T[input.Length + bynum];
+			if (bynum == 0) input.CopyTo(ret, 0);
+			else if (bynum &lt; 0) for (int i = 0; i &lt; ret.Length; ++i) ret[i] = input[i - bynum];
+			else if (bynum &gt; 0) for (int i = 0; i &lt; input.Length; ++i) ret[i + bynum] = input[i];
+			return ret;
+		}
 
-    public static long ToUnix(TimeSpan t)
-    {
-      if (t == TimeSpan.MinValue) return 0;
-      return (long)t.TotalSeconds;
-    }
-  }
+		public static long ToUnix(DateTime t)
+		{
+			if (t == DateTime.MinValue) return 0;
+			return (long) (t.ToUniversalTime() - new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
+		}
+
+		public static long ToUnix(TimeSpan t)
+		{
+			if (t == TimeSpan.MinValue) return 0;
+			return (long) t.TotalSeconds;
+		}
+
+		#endregion
+	}
 }
\ No newline at end of file

Modified: branches/caiinterface/tools/springie/Springie.sln
===================================================================
--- branches/caiinterface/tools/springie/Springie.sln	2008-10-09 17:55:40 UTC (rev 6638)
+++ branches/caiinterface/tools/springie/Springie.sln	2008-10-09 18:55:21 UTC (rev 6639)
@@ -9,8 +9,8 @@
 		Release|Any cpu = Release|Any cpu
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{DD5A4F64-6C82-4F75-9EED-992378EC65FC}.Debug|Any cpu.ActiveCfg = Release|x86
-		{DD5A4F64-6C82-4F75-9EED-992378EC65FC}.Debug|Any cpu.Build.0 = Release|x86
+		{DD5A4F64-6C82-4F75-9EED-992378EC65FC}.Debug|Any cpu.ActiveCfg = Debug|x86
+		{DD5A4F64-6C82-4F75-9EED-992378EC65FC}.Debug|Any cpu.Build.0 = Debug|x86
 		{DD5A4F64-6C82-4F75-9EED-992378EC65FC}.Release|Any cpu.ActiveCfg = Release|x86
 		{DD5A4F64-6C82-4F75-9EED-992378EC65FC}.Release|Any cpu.Build.0 = Release|x86
 	EndGlobalSection

Copied: branches/caiinterface/tools/springie/libs (from rev 6638, trunk/tools/springie/libs)


Property changes on: branches/caiinterface/tools/springie/libs
___________________________________________________________________
Name: svn:ignore
   + PlanetWarsShared.pdb


Deleted: branches/caiinterface/tools/springie/libs/PlanetWarsShared.dll
===================================================================
(Binary files differ)

Copied: branches/caiinterface/tools/springie/libs/PlanetWarsShared.dll (from rev 6638, trunk/tools/springie/libs/PlanetWarsShared.dll)
===================================================================
(Binary files differ)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001407.html">[Taspring-linux-commit] r6638 - in branches/caiinterface: . AI	AI/Interfaces AI/Interfaces/C AI/Skirmish AI/Skirmish/AAI	AI/Skirmish/KAIK-0.13 AI/Skirmish/NullAI	AI/Skirmish/NullLegacyCppAI AI/Skirmish/RAI-0.553	rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper rts/Game	rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Units	rts/Sim/Units/CommandAI rts/System rts/System/Platform	rts/System/Platform/Win rts/System/creg rts/build/scons
</A></li>
	<LI>Next message: <A HREF="001409.html">[Taspring-linux-commit] r6640 - trunk/rts/Game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1408">[ date ]</a>
              <a href="thread.html#1408">[ thread ]</a>
              <a href="subject.html#1408">[ subject ]</a>
              <a href="author.html#1408">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
