<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6915 - in trunk/rts: Game/UI Rendering	Sim/Misc Sim/MoveTypes Sim/Path	Sim/Projectiles/WeaponProjectiles Sim/Units	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System	System/Sync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6915%20-%20in%20trunk/rts%3A%20Game/UI%20Rendering%0A%09Sim/Misc%20Sim/MoveTypes%20Sim/Path%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%0A%09Sim/Units/CommandAI%20Sim/Units/UnitTypes%20Sim/Weapons%20System%0A%09System/Sync&In-Reply-To=%3C20081027110929.7C893474F%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001683.html">
   <LINK REL="Next"  HREF="001685.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6915 - in trunk/rts: Game/UI Rendering	Sim/Misc Sim/MoveTypes Sim/Path	Sim/Projectiles/WeaponProjectiles Sim/Units	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System	System/Sync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6915%20-%20in%20trunk/rts%3A%20Game/UI%20Rendering%0A%09Sim/Misc%20Sim/MoveTypes%20Sim/Path%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%0A%09Sim/Units/CommandAI%20Sim/Units/UnitTypes%20Sim/Weapons%20System%0A%09System/Sync&In-Reply-To=%3C20081027110929.7C893474F%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6915 - in trunk/rts: Game/UI Rendering	Sim/Misc Sim/MoveTypes Sim/Path	Sim/Projectiles/WeaponProjectiles Sim/Units	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System	System/Sync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Mon Oct 27 12:09:29 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001683.html">[Taspring-linux-commit] r6914 - trunk/rts/Map
</A></li>
        <LI>Next message: <A HREF="001685.html">[Taspring-linux-commit] r6916 - in trunk:	installer/builddata/springcontent/shaders rts/Rendering/Env
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1684">[ date ]</a>
              <a href="thread.html#1684">[ thread ]</a>
              <a href="subject.html#1684">[ subject ]</a>
              <a href="author.html#1684">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-10-27 12:09:28 +0100 (Mon, 27 Oct 2008)
New Revision: 6915

Modified:
   trunk/rts/Game/UI/GuiHandler.cpp
   trunk/rts/Game/UI/SelectionKeyHandler.cpp
   trunk/rts/Rendering/GroundDecalHandler.cpp
   trunk/rts/Rendering/InMapDraw.cpp
   trunk/rts/Sim/Misc/AirBaseHandler.cpp
   trunk/rts/Sim/Misc/InterceptHandler.cpp
   trunk/rts/Sim/MoveTypes/AirMoveType.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Path/PathManager.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   trunk/rts/Sim/Units/CommandAI/AirCAI.cpp
   trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   trunk/rts/Sim/Units/CommandAI/BuilderCAI.h
   trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
   trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitTypes/Builder.cpp
   trunk/rts/Sim/Units/UnitTypes/Builder.h
   trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
   trunk/rts/Sim/Weapons/DGunWeapon.cpp
   trunk/rts/Sim/Weapons/bombdropper.cpp
   trunk/rts/System/Sync/SyncedFloat3.h
   trunk/rts/System/float3.h
Log:
 * added float3::SqDistance &amp; float3::SqDistance2D to reduce unneeded squareroot calcuations

Modified: trunk/rts/Game/UI/GuiHandler.cpp
===================================================================
--- trunk/rts/Game/UI/GuiHandler.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Game/UI/GuiHandler.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -55,6 +55,7 @@
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/Util.h&quot;
+#include &quot;System/myMath.h&quot;
 
 extern Uint8 *keys;
 
@@ -2312,7 +2313,7 @@
 				c.params[2] = pos.z;
 
 				if (!commands[tempInCommand].params.empty() &amp;&amp;
-				    pos.distance2D(pos2) &gt; atof(commands[tempInCommand].params[0].c_str())) {
+				    pos.SqDistance2D(pos2) &gt; Square(atof(commands[tempInCommand].params[0].c_str()))) {
 					float3 dif=pos2-pos;
 					dif.ANormalize();
 					pos2=pos+dif*atoi(commands[tempInCommand].params[0].c_str());
@@ -4043,7 +4044,7 @@
 	float3 forward=(pos1-pos2).cross(UpVector);
 	forward.ANormalize();
 	float3 side=forward.cross(UpVector);
-	if(pos1.distance2D(pos2)&gt;maxSize){
+	if(pos1.SqDistance2D(pos2)&gt;maxSize*maxSize){
 		pos2=pos1+side*maxSize;
 		pos2.y=ground-&gt;GetHeight(pos2.x,pos2.z);
 	}

Modified: trunk/rts/Game/UI/SelectionKeyHandler.cpp
===================================================================
--- trunk/rts/Game/UI/SelectionKeyHandler.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Game/UI/SelectionKeyHandler.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -20,6 +20,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitTypes/Building.h&quot;
+#include &quot;System/myMath.h&quot;
 
 CSelectionKeyHandler *selectionKeys;
 
@@ -190,7 +191,7 @@
 		  // team units in mouse range
 			CUnitSet* tu=&amp;gs-&gt;Team(gu-&gt;myTeam)-&gt;units;
 			for(CUnitSet::iterator ui=tu-&gt;begin();ui!=tu-&gt;end();++ui){
-				if(mp.distance((*ui)-&gt;pos)&lt;maxDist){
+				if(mp.SqDistance((*ui)-&gt;pos)&lt;Square(maxDist)){
 					selection.push_back(*ui);
 				}
 			}
@@ -198,7 +199,7 @@
 		  // all units in mouse range
 			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
 			for(std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
-				if(mp.distance((*ui)-&gt;pos)&lt;maxDist){
+				if(mp.SqDistance((*ui)-&gt;pos)&lt;Square(maxDist)){
 					selection.push_back(*ui);
 				}
 			}

Modified: trunk/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- trunk/rts/Rendering/GroundDecalHandler.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Rendering/GroundDecalHandler.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -662,7 +662,7 @@
 		--pi;
 		list&lt;TrackPart&gt;::iterator pi2=pi;
 		--pi;
-		if(((tp.pos1+pi-&gt;pos1)*0.5f).distance(pi2-&gt;pos1)&lt;1){
+		if(((tp.pos1+pi-&gt;pos1)*0.5f).SqDistance(pi2-&gt;pos1)&lt;1){
 			unit-&gt;myTrack-&gt;parts.back()=tp;
 			return;
 		}

Modified: trunk/rts/Rendering/InMapDraw.cpp
===================================================================
--- trunk/rts/Rendering/InMapDraw.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Rendering/InMapDraw.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -566,7 +566,7 @@
 
 			std::list&lt;MapPoint&gt;::iterator pi;
 			for (pi = dq-&gt;points.begin(); pi != dq-&gt;points.end(); /* none */) {
-				if (pi-&gt;pos.distance2D(pos) &lt; radius) {
+				if (pi-&gt;pos.SqDistance2D(pos) &lt; (radius*radius)) {
 					pi = dq-&gt;points.erase(pi);
 				} else {
 					++pi;
@@ -574,7 +574,7 @@
 			}
 			std::list&lt;MapLine&gt;::iterator li;
 			for (li = dq-&gt;lines.begin(); li != dq-&gt;lines.end(); /* none */) {
-				if (li-&gt;pos.distance2D(pos) &lt; radius) {
+				if (li-&gt;pos.SqDistance2D(pos) &lt; (radius*radius)) {
 					li = dq-&gt;lines.erase(li);
 				} else {
 					++li;

Modified: trunk/rts/Sim/Misc/AirBaseHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/AirBaseHandler.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Misc/AirBaseHandler.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -127,12 +127,12 @@
 			continue;
 		}
 
-		if (baseUnit-&gt;pos.distance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
+		if (baseUnit-&gt;pos.SqDistance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
 			continue;
 		}
 
+		closest = baseUnit-&gt;pos.SqDistance(unit-&gt;pos);
 		for (padLstIt pi = (*bi)-&gt;freePads.begin(); pi != (*bi)-&gt;freePads.end(); ++pi) {
-			closest = baseUnit-&gt;pos.distance(unit-&gt;pos);
 			foundPad = pi;
 			foundBase = bi;
 		}
@@ -169,11 +169,11 @@
 			continue;
 		}
 
-		if (baseUnit-&gt;pos.distance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
+		if (baseUnit-&gt;pos.SqDistance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
 			continue;
 		}
 
-		closest = baseUnit-&gt;pos.distance(unit-&gt;pos);
+		closest = baseUnit-&gt;pos.SqDistance(unit-&gt;pos);
 		foundBase = bi;
 	}
 

Modified: trunk/rts/Sim/Misc/InterceptHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/InterceptHandler.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Misc/InterceptHandler.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -10,6 +10,7 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/PlasmaRepulser.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;creg/STL_List.h&quot;
 
 CR_BIND(CInterceptHandler, )
@@ -53,7 +54,7 @@
 
 	for(std::list&lt;CWeapon*&gt;::iterator wi=interceptors.begin();wi!=interceptors.end();++wi){
 		CWeapon* w=*wi;
-		if ((targTeam==-1 || !gs-&gt;Ally(w-&gt;owner-&gt;allyteam,targTeam)) &amp;&amp; (target-&gt;weaponDef-&gt;targetable &amp; w-&gt;weaponDef-&gt;interceptor) &amp;&amp; w-&gt;weaponPos.distance2D(destination) &lt; w-&gt;weaponDef-&gt;coverageRange){
+		if ((targTeam==-1 || !gs-&gt;Ally(w-&gt;owner-&gt;allyteam,targTeam)) &amp;&amp; (target-&gt;weaponDef-&gt;targetable &amp; w-&gt;weaponDef-&gt;interceptor) &amp;&amp; w-&gt;weaponPos.SqDistance2D(destination) &lt; Square(w-&gt;weaponDef-&gt;coverageRange)){
 			w-&gt;incoming.push_back(target);
 			w-&gt;AddDeathDependence(target);
 		}

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -205,7 +205,7 @@
 
 			goalPos = pos;
 
-			if (pos.distance2D(owner-&gt;pos) &lt; 400) {
+			if (pos.SqDistance2D(owner-&gt;pos) &lt; (400*400)) {
 				padStatus = 1;
 			}
 		} else if (padStatus == 1) {
@@ -216,7 +216,7 @@
 			goalPos = pos;
 			reservedLandingPos = pos;
 
-			if (owner-&gt;pos.distance(pos) &lt; 3 || aircraftState == AIRCRAFT_LANDED) {
+			if (owner-&gt;pos.SqDistance(pos) &lt; 9 || aircraftState == AIRCRAFT_LANDED) {
 				padStatus = 2;
 			}
 		} else {
@@ -275,7 +275,7 @@
 				if (maneuver) {
 					UpdateManeuver();
 					inefficientAttackTime = 0;
-				} else if (isFighter &amp;&amp; goalPos.distance(pos) &lt; owner-&gt;maxRange * 4) {
+				} else if (isFighter &amp;&amp; goalPos.SqDistance(pos) &lt; Square(owner-&gt;maxRange * 4)) {
 					inefficientAttackTime++;
 					UpdateFighterAttack();
 				} else {

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -286,7 +286,7 @@
 					logOutput.Print(&quot;eta failure %i %i %i %i %i&quot;, owner-&gt;id, pathId, !atGoal, currentDistanceToWaypoint &lt; MinDistanceToWaypoint(), gs-&gt;frameNum &gt; etaWaypoint);
 			}
 			if (pathId &amp;&amp; !atGoal &amp;&amp; gs-&gt;frameNum &gt; etaWaypoint2) {
-				if (owner-&gt;pos.distance2D(goalPos) &gt; 200 || CheckGoalFeasability()) {
+				if (owner-&gt;pos.SqDistance2D(goalPos) &gt; (200*200) || CheckGoalFeasability()) {
 					etaWaypoint2 += 100;
 				} else {
 					if (DEBUG_CONTROLLER)
@@ -402,7 +402,7 @@
 
 	// if we've strayed too far away from path, then need to reconsider
 	if (progressState == Active &amp;&amp; etaFailures &gt; 8) {
-		if (owner-&gt;pos.distance2D(goalPos) &gt; 200 || CheckGoalFeasability()) {
+		if (owner-&gt;pos.SqDistance2D(goalPos) &gt; (200*200) || CheckGoalFeasability()) {
 			if (DEBUG_CONTROLLER)
 				logOutput.Print(&quot;ETA failure for unit %i&quot;, owner-&gt;id);
 
@@ -1185,7 +1185,7 @@
 // Creates a path to the goal.
 void CGroundMoveType::GetNewPath()
 {
-	if (owner-&gt;pos.distance2D(lastGetPathPos) &lt; 20) {
+	if (owner-&gt;pos.SqDistance2D(lastGetPathPos) &lt; 400) {
 		if (DEBUG_CONTROLLER)
 			logOutput.Print(&quot;Non-moving path failures for unit %i: %i&quot;, owner-&gt;id, nonMovingFailures);
 		nonMovingFailures++;
@@ -1244,7 +1244,7 @@
 			nextWaypoint = waypoint;
 		}
 		// If the waypoint is very close to the goal, then correct it into the goal.
-		if (waypoint.distance2D(goalPos) &lt; CPathManager::PATH_RESOLUTION) {
+		if (waypoint.SqDistance2D(goalPos) &lt; Square(CPathManager::PATH_RESOLUTION)) {
 			waypoint = goalPos;
 			haveFinalWaypoint = true;
 		}
@@ -1415,7 +1415,7 @@
 				owner-&gt;unitDef-&gt;sounds.cant.getVolume(soundIdx));
 		}
 		if (!owner-&gt;commandAI-&gt;unimportantMove &amp;&amp;
-		    (owner-&gt;pos.distance(goalPos) &gt; (goalRadius + 150.0f))) {
+		    (owner-&gt;pos.SqDistance(goalPos) &gt; Square(goalRadius + 150.0f))) {
 			logOutput.Print(owner-&gt;unitDef-&gt;humanName + &quot;: Can't reach destination!&quot;);
 			logOutput.SetLastMsgPos(owner-&gt;pos);
 		}

Modified: trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -323,7 +323,7 @@
 	// move towards goal position if it's not immediately
 	// behind us when we have more waypoints to get to
 	if (aircraftState != AIRCRAFT_LANDING &amp;&amp; owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
-		(l &lt; 120) &amp;&amp; (deltaDir.distance(deltaVec) &gt; 1.0f)) {
+		(l &lt; 120) &amp;&amp; (deltaDir.SqDistance(deltaVec) &gt; 1.0f)) {
 		deltaDir = owner-&gt;frontdir;
 		moveFactor = 1.0f;
 	}
@@ -353,7 +353,7 @@
 
 	// don't change direction for waypoints we just flew over and missed slightly
 	if (flyState != FLY_LANDING &amp;&amp; owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
-		(dir.SqLength2D() &lt; 10000) &amp;&amp; (float3(dir).Normalize().distance(dir) &lt; 1)) {
+		(dir.SqLength2D() &lt; 10000) &amp;&amp; (float3(dir).Normalize().SqDistance(dir) &lt; 1)) {
 		dir = owner-&gt;frontdir;
 	}
 
@@ -458,7 +458,7 @@
 	if ((flyState == FLY_ATTACKING) || (flyState == FLY_CIRCLING)) {
 		dir = circlingPos - pos;
 	} else if (flyState != FLY_LANDING &amp;&amp; (owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
-			   dist &lt; 120) &amp;&amp; (goalPos - pos).Normalize().distance(dir) &gt; 1) {
+			   dist &lt; 120) &amp;&amp; (goalPos - pos).Normalize().SqDistance(dir) &gt; 1) {
 		dir = owner-&gt;frontdir;
 	} else {
 		dir = goalPos - pos;
@@ -499,7 +499,7 @@
 			owner-&gt;Deactivate();
 			owner-&gt;cob-&gt;Call(COBFN_StopMoving);
 		} else {
-			if (goalPos.distance2D(pos) &lt; 30) {
+			if (goalPos.SqDistance2D(pos) &lt; 900) {
 				goalPos = goalPos + gs-&gt;randVector() * 300;
 				goalPos.CheckInBounds();
 			}
@@ -784,7 +784,7 @@
 
 					goalPos = pos;
 
-					if (pos.distance2D(owner-&gt;pos) &lt; 400) {
+					if (pos.SqDistance2D(owner-&gt;pos) &lt; 400*400) {
 						padStatus = 1;
 					}
 				} else if (padStatus == 1) {
@@ -796,7 +796,7 @@
 					reservedLandingPos = pos;
 					wantedHeight = pos.y - ground-&gt;GetHeight(pos.x, pos.z);
 
-					if (owner-&gt;pos.distance(pos) &lt; 3 || aircraftState == AIRCRAFT_LANDED) {
+					if (owner-&gt;pos.SqDistance(pos) &lt; 9 || aircraftState == AIRCRAFT_LANDED) {
 						padStatus = 2;
 					}
 				} else {

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -990,7 +990,7 @@
 					glColor3f(1, 1 / (cost/BLOCK_SIZE), blue);
 
 					p2 = (p1 + p2) / 2;
-					if (camera-&gt;pos.distance(p2) &lt; 500) {
+					if (camera-&gt;pos.SqDistance(p2) &lt; 250000) {
 						glPushMatrix();
 						glTranslatef3(p2);
 						glScalef(5, 5, 5);
@@ -1050,7 +1050,7 @@
 		p1.z=(ob-&gt;block.y * BLOCK_SIZE + blockState[blocknr].sqrCenter[md-&gt;pathType].y)*SQUARE_SIZE;
 		p1.y=ground-&gt;GetHeight(p1.x,p1.z)+15;
 
-		if(camera-&gt;pos.distance(p1)&lt;500){
+		if(camera-&gt;pos.SqDistance(p1)&lt;250000){
 			glPushMatrix();
 			glTranslatef3(p1);
 			glScalef(5,5,5);

Modified: trunk/rts/Sim/Path/PathManager.cpp
===================================================================
--- trunk/rts/Sim/Path/PathManager.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Path/PathManager.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -6,6 +6,7 @@
 
 #include &quot;PathManager.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/MoveTypes/MoveMath/GroundMoveMath.h&quot;
 #include &quot;Sim/MoveTypes/MoveMath/HoverMoveMath.h&quot;
@@ -235,7 +236,7 @@
 	//Remove estimate waypoints until
 	//the next one is far enought.
 	while(!path.estimatedPath.path.empty()
-	&amp;&amp; path.estimatedPath.path.back().distance2D(startPos) &lt; DETAILED_DISTANCE * SQUARE_SIZE)
+	&amp;&amp; path.estimatedPath.path.back().SqDistance2D(startPos) &lt; Square(DETAILED_DISTANCE * SQUARE_SIZE))
 		path.estimatedPath.path.pop_back();
 
 	//Get the goal of the detailed search.
@@ -275,7 +276,7 @@
 	//Remove estimate2 waypoints until
 	//the next one is far enought.
 	while(!path.estimatedPath2.path.empty()
-	&amp;&amp; path.estimatedPath2.path.back().distance2D(startPos) &lt; ESTIMATE_DISTANCE * SQUARE_SIZE)
+	&amp;&amp; path.estimatedPath2.path.back().SqDistance2D(startPos) &lt; Square(ESTIMATE_DISTANCE * SQUARE_SIZE))
 		path.estimatedPath2.path.pop_back();
 
 	//Get the goal of the detailed search.
@@ -330,11 +331,11 @@
 
 	//check if detailed path need bettering
 	if(!multiPath-&gt;estimatedPath.path.empty()
-	&amp;&amp; (multiPath-&gt;estimatedPath.path.back().distance2D(callerPos) &lt; MIN_DETAILED_DISTANCE * SQUARE_SIZE
+	&amp;&amp; (multiPath-&gt;estimatedPath.path.back().SqDistance2D(callerPos) &lt; Square(MIN_DETAILED_DISTANCE * SQUARE_SIZE)
 	|| multiPath-&gt;detailedPath.path.size() &lt;= 2)){
 
 		if(!multiPath-&gt;estimatedPath2.path.empty()		//if so check if estimated path also need bettering
-			&amp;&amp; (multiPath-&gt;estimatedPath2.path.back().distance2D(callerPos) &lt; MIN_ESTIMATE_DISTANCE * SQUARE_SIZE
+			&amp;&amp; (multiPath-&gt;estimatedPath2.path.back().SqDistance2D(callerPos) &lt; Square(MIN_ESTIMATE_DISTANCE * SQUARE_SIZE)
 			|| multiPath-&gt;estimatedPath.path.size() &lt;= 2)){
 				Estimate2ToEstimate(*multiPath, callerPos);
 		}
@@ -359,7 +360,7 @@
 			waypoint = multiPath-&gt;detailedPath.path.back();
 			multiPath-&gt;detailedPath.path.pop_back();
 		}
-	} while(callerPos.distance2D(waypoint) &lt; minDistance &amp;&amp; waypoint != multiPath-&gt;detailedPath.pathGoal);
+	} while(callerPos.SqDistance2D(waypoint) &lt; Square(minDistance) &amp;&amp; waypoint != multiPath-&gt;detailedPath.pathGoal);
 
 	return waypoint;
 }

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -160,7 +160,7 @@
 	}
 	if (interceptTarget) {
 		targetPos = interceptTarget-&gt;pos;
-		if (targetPos.distance(pos) &lt; areaOfEffect * 2) {
+		if (targetPos.SqDistance(pos) &lt; Square(areaOfEffect * 2)) {
 			interceptTarget-&gt;Collision();
 			Collision();
 		}

Modified: trunk/rts/Sim/Units/CommandAI/AirCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -521,7 +521,7 @@
 	if (inCommand) {
 		if (myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDED)
 			inCommand = false;
-		if (orderTarget &amp;&amp; orderTarget-&gt;pos.distance2D(pos) &gt; radius) {
+		if (orderTarget &amp;&amp; orderTarget-&gt;pos.SqDistance2D(pos) &gt; Square(radius)) {
 			inCommand = false;
 			DeleteDeathDependence(orderTarget);
 			orderTarget = 0;

Modified: trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -374,7 +374,7 @@
 		const float radius = GetUnitDefRadius(ud, c.id);
 		if (inCommand) {
 			if (building) {
-				if (f3Dist(build.pos, fac-&gt;pos) &gt; fac-&gt;buildDistance + radius - 8.0f) {
+				if (f3SqDist(build.pos, fac-&gt;pos) &gt; Square(fac-&gt;buildDistance + radius - 8.0f)) {
 					owner-&gt;moveType-&gt;StartMoving(build.pos, fac-&gt;buildDistance * 0.5f + radius);
 				} else {
 					StopMove();
@@ -407,10 +407,10 @@
 					StopMove();
 				} else {
 					build.pos = helper-&gt;Pos2BuildPos(build);
-					const float dist = f3Dist(build.pos, fac-&gt;pos);
+					const float sqdist = f3SqDist(build.pos, fac-&gt;pos);
 
-					if ((dist &lt; (fac-&gt;buildDistance * 0.6f + radius)) ||
-						(!owner-&gt;unitDef-&gt;canmove &amp;&amp; (dist &lt;= (fac-&gt;buildDistance + radius - 8.0f)))) {
+					if ((sqdist &lt; Square(fac-&gt;buildDistance * 0.6f + radius)) ||
+						(!owner-&gt;unitDef-&gt;canmove &amp;&amp; (sqdist &lt;= Square(fac-&gt;buildDistance + radius - 8.0f)))) {
 						StopMove();
 
 						if (luaRules &amp;&amp; !luaRules-&gt;AllowUnitCreation(build.def, owner, &amp;build.pos)) {
@@ -531,12 +531,12 @@
 		    ((unit != owner) || owner-&gt;unitDef-&gt;canSelfRepair) &amp;&amp;
 		    (!unit-&gt;soloBuilder || (unit-&gt;soloBuilder == owner)) &amp;&amp;
 		    UpdateTargetLostTimer((int)c.params[0])) {
-			if (f3Dist(unit-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance+unit-&gt;radius-8) {
+			if (f3SqDist(unit-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance+unit-&gt;radius-8)) {
 				StopMove();
 				fac-&gt;SetRepairTarget(unit);
 				owner-&gt;moveType-&gt;KeepPointingTo(unit-&gt;pos, fac-&gt;buildDistance*0.9f+unit-&gt;radius, false);
 			} else {
-				if (f3Dist(goalPos, unit-&gt;pos) &gt; 1) {
+				if (f3SqDist(goalPos, unit-&gt;pos) &gt; 1) {
 					SetGoal(unit-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance*0.9f+unit-&gt;radius);
 				}
 			}
@@ -570,12 +570,12 @@
 		CUnit* unit = uh-&gt;units[(int)c.params[0]];
 
 		if (unit &amp;&amp; unit-&gt;unitDef-&gt;capturable &amp;&amp; unit-&gt;team != owner-&gt;team &amp;&amp; UpdateTargetLostTimer((int) c.params[0])) {
-			if (f3Dist(unit-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance + unit-&gt;radius - 8) {
+			if (f3SqDist(unit-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance + unit-&gt;radius - 8)) {
 				StopMove();
 				fac-&gt;SetCaptureTarget(unit);
 				owner-&gt;moveType-&gt;KeepPointingTo(unit-&gt;pos, fac-&gt;buildDistance * 0.9f + unit-&gt;radius, false);
 			} else {
-				if (f3Dist(goalPos, unit-&gt;pos) &gt; 1) {
+				if (f3SqDist(goalPos, unit-&gt;pos) &gt; 1) {
 					SetGoal(unit-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance * 0.9f + unit-&gt;radius);
 				}
 			}
@@ -608,8 +608,8 @@
 	if (guarded &amp;&amp; guarded!=owner &amp;&amp; UpdateTargetLostTimer((int)c.params[0])) {
 		if (CBuilder* b=dynamic_cast&lt;CBuilder*&gt;(guarded)) {
 			if (b-&gt;terraforming) {
-				if (f3Dist(fac-&gt;pos, b-&gt;terraformCenter) &lt;
-						(fac-&gt;buildDistance * 0.8f) + (b-&gt;terraformRadius * 0.7f)) {
+				if (f3SqDist(fac-&gt;pos, b-&gt;terraformCenter) &lt;
+						Square((fac-&gt;buildDistance * 0.8f) + (b-&gt;terraformRadius * 0.7f))) {
 					StopMove();
 					owner-&gt;moveType-&gt;KeepPointingTo(b-&gt;terraformCenter, fac-&gt;buildDistance*0.9f, false);
 					fac-&gt;HelpTerraform(b);
@@ -781,12 +781,12 @@
 			CFeatureSet::const_iterator it = featureHandler-&gt;GetActiveFeatures().find(id - MAX_UNITS);
 			if (it != featureHandler-&gt;GetActiveFeatures().end() &amp;&amp; (*it)-&gt;createdFromUnit != &quot;&quot;) {
 				CFeature* feature = *it;
-				if (f3Dist(feature-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance*0.9f+feature-&gt;radius) {
+				if (f3SqDist(feature-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance*0.9f+feature-&gt;radius)) {
 					StopMove();
 					owner-&gt;moveType-&gt;KeepPointingTo(feature-&gt;pos, fac-&gt;buildDistance*0.9f+feature-&gt;radius, false);
 					fac-&gt;SetResurrectTarget(feature);
 				} else {
-					if (f3Dist(goalPos, feature-&gt;pos) &gt; 1) {
+					if (f3SqDist(goalPos, feature-&gt;pos) &gt; 1) {
 						SetGoal(feature-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance*0.8f+feature-&gt;radius);
 					} else {
 						if(owner-&gt;moveType-&gt;progressState==AMoveType::Failed){
@@ -940,7 +940,7 @@
 		pos.y = ground-&gt;GetHeight2(pos.x,pos.y);
 		float radius(c.params[3]);
 		if (radius&gt;200) radius = 200;
-		if (f3Dist(fac-&gt;pos, pos) &lt; fac-&gt;buildDistance-1) {
+		if (f3SqDist(fac-&gt;pos, pos) &lt; Square(fac-&gt;buildDistance-1)) {
 			StopMove();
 			fac-&gt;StartRestore(pos,radius);
 			owner-&gt;moveType-&gt;KeepPointingTo(pos, fac-&gt;buildDistance*0.9f, false);
@@ -1083,12 +1083,12 @@
 
 bool CBuilderCAI::ReclaimObject(CSolidObject* object){
 	CBuilder* fac=(CBuilder*)owner;
-	if (f3Dist(object-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance-1+object-&gt;radius) {
+	if (f3SqDist(object-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance-1+object-&gt;radius)) {
 		StopMove();
 		owner-&gt;moveType-&gt;KeepPointingTo(object-&gt;pos, fac-&gt;buildDistance*0.9f+object-&gt;radius, false);
 		fac-&gt;SetReclaimTarget(object);
 	} else {
-		if (f3Dist(goalPos, object-&gt;pos) &gt; 1) {
+		if (f3SqDist(goalPos, object-&gt;pos) &gt; 1) {
 			SetGoal(object-&gt;pos, owner-&gt;pos);
 		} else {
 			if (owner-&gt;moveType-&gt;progressState == AMoveType::Failed) {

Modified: trunk/rts/Sim/Units/CommandAI/BuilderCAI.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/BuilderCAI.h	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/CommandAI/BuilderCAI.h	2008-10-27 11:09:28 UTC (rev 6915)
@@ -66,6 +66,9 @@
 	inline float f3Dist(const float3&amp; a, const float3&amp; b) const {
 		return range3D ? a.distance(b) : a.distance2D(b);
 	}
+	inline float f3SqDist(const float3&amp; a, const float3&amp; b) const {
+		return range3D ? a.SqDistance(b) : a.SqDistance2D(b);
+	}
 	inline float f3Len(const float3&amp; a) const {
 		return range3D ? a.Length() : a.Length2D();
 	}

Modified: trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -633,7 +633,7 @@
 void CMobileCAI::ExecuteDGun(Command &amp;c)
 {
 	if (uh-&gt;limitDgun &amp;&amp; owner-&gt;unitDef-&gt;isCommander
-			&amp;&amp; owner-&gt;pos.distance(gs-&gt;Team(owner-&gt;team)-&gt;startPos) &gt; uh-&gt;dgunRadius) {
+			&amp;&amp; owner-&gt;pos.SqDistance(gs-&gt;Team(owner-&gt;team)-&gt;startPos) &gt; Square(uh-&gt;dgunRadius)) {
 		StopMove();
 		return FinishCommand();
 	}
@@ -734,8 +734,8 @@
 			// if we have at least one weapon then check if we
 			// can hit target with our first (meanest) one
 			b2 = w-&gt;TryTargetRotate(orderTarget, c.id == CMD_DGUN);
-			b3 = (w-&gt;range - (w-&gt;relWeaponPos).Length())
-					&gt; (orderTarget-&gt;pos.distance(owner-&gt;pos));
+			b3 = Square(w-&gt;range - (w-&gt;relWeaponPos).Length())
+					&gt; (orderTarget-&gt;pos.SqDistance(owner-&gt;pos));
 			b4 = w-&gt;TryTargetHeading(GetHeadingFromVector(-diff.x, -diff.z),
 					orderTarget-&gt;pos, orderTarget != NULL);
 			edgeFactor = fabs(w-&gt;targetBorder);
@@ -804,8 +804,8 @@
 		// to goal position greater than
 		// (10 plus 20% of 2D distance between attacker and target) then we need to close
 		// in on target more
-		else if ((orderTarget-&gt;pos + owner-&gt;posErrorVector * 128).distance2D(goalPos)
-				&gt; (10 + orderTarget-&gt;pos.distance2D(owner-&gt;pos) * 0.2f)) {
+		else if ((orderTarget-&gt;pos + owner-&gt;posErrorVector * 128).SqDistance2D(goalPos)
+				&gt; Square(10 + orderTarget-&gt;pos.distance2D(owner-&gt;pos) * 0.2f)) {
 			// if the target isn't in LOS, go to its approximate position
 			// otherwise try to go precisely to the target
 			// this should fix issues with low range weapons (mainly melee)
@@ -866,7 +866,7 @@
 		}
 
 		// if we are more than 10 units distant from target position then keeping moving closer
-		else if (pos.distance2D(goalPos) &gt; 10) {
+		else if (pos.SqDistance2D(goalPos) &gt; 100) {
 			SetGoal(pos, owner-&gt;pos);
 		}
 	}
@@ -1041,8 +1041,8 @@
 			&amp;&amp; !owner-&gt;weapons.empty() &amp;&amp; owner-&gt;haveTarget) {
 		if(!owner-&gt;userTarget) {
 			owner-&gt;haveTarget = false;
-		} else if(owner-&gt;pos.distance2D(owner-&gt;userTarget-&gt;pos) &lt;
-				owner-&gt;maxRange + 200*owner-&gt;moveState*owner-&gt;moveState) {
+		} else if(owner-&gt;pos.SqDistance2D(owner-&gt;userTarget-&gt;pos) &lt;
+				Square(owner-&gt;maxRange + 200*owner-&gt;moveState*owner-&gt;moveState)) {
 			Command c;
 			c.id = CMD_ATTACK;
 			c.options=INTERNAL_ORDER;
@@ -1057,8 +1057,8 @@
 		if(owner-&gt;lastAttacker &amp;&amp; owner-&gt;lastAttack + 200 &gt; gs-&gt;frameNum
 				&amp;&amp; !(owner-&gt;unitDef-&gt;noChaseCategory &amp; owner-&gt;lastAttacker-&gt;category)){
 			float3 apos=owner-&gt;lastAttacker-&gt;pos;
-			float dist=apos.distance2D(owner-&gt;pos);
-			if(dist&lt;owner-&gt;maxRange+200*owner-&gt;moveState*owner-&gt;moveState){
+			float dist=apos.SqDistance2D(owner-&gt;pos);
+			if(dist&lt;Square(owner-&gt;maxRange+200*owner-&gt;moveState*owner-&gt;moveState)){
 				Command c;
 				c.id=CMD_ATTACK;
 				c.options=INTERNAL_ORDER;

Modified: trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -20,6 +20,7 @@
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;creg/STL_List.h&quot;
 #include &quot;System/GlobalUnsynced.h&quot;
+#include &quot;System/myMath.h&quot;
 
 #define AIRTRANSPORT_DOCKING_RADIUS 16
 #define AIRTRANSPORT_DOCKING_ANGLE 50
@@ -159,11 +160,11 @@
 				FinishCommand();
 				return;
 			}
-			if(goalPos.distance2D(unit-&gt;pos)&gt;10){
+			if(goalPos.SqDistance2D(unit-&gt;pos)&gt;100){
 				float3 fix = unit-&gt;pos;
 				SetGoal(fix,owner-&gt;pos,64);
 			}
-			if(unit-&gt;pos.distance2D(owner-&gt;pos)&lt;owner-&gt;unitDef-&gt;loadingRadius*0.9f){
+			if(unit-&gt;pos.SqDistance2D(owner-&gt;pos)&lt;Square(owner-&gt;unitDef-&gt;loadingRadius*0.9f)){
 				if(CTAAirMoveType* am=dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType)){		//handle air transports differently
 					float3 wantedPos=unit-&gt;pos+UpVector*unit-&gt;model-&gt;height;
 					SetGoal(wantedPos,owner-&gt;pos);
@@ -172,7 +173,7 @@
 					am-&gt;SetWantedAltitude(unit-&gt;model-&gt;height);
 					am-&gt;maxDrift=1;
 					//logOutput.Print(&quot;cai dist %f %f %f&quot;,owner-&gt;pos.distance(wantedPos),owner-&gt;pos.distance2D(wantedPos),owner-&gt;pos.y-wantedPos.y);
-					if(owner-&gt;pos.distance(wantedPos)&lt;AIRTRANSPORT_DOCKING_RADIUS &amp;&amp; abs(owner-&gt;heading-unit-&gt;heading)&lt;AIRTRANSPORT_DOCKING_ANGLE &amp;&amp; owner-&gt;updir.dot(UpVector)&gt;0.995f){
+					if(owner-&gt;pos.SqDistance(wantedPos)&lt;Square(AIRTRANSPORT_DOCKING_RADIUS) &amp;&amp; abs(owner-&gt;heading-unit-&gt;heading)&lt;AIRTRANSPORT_DOCKING_ANGLE &amp;&amp; owner-&gt;updir.dot(UpVector)&gt;0.995f){
 						am-&gt;dontCheckCol=false;
 						am-&gt;dontLand=true;
 						std::vector&lt;int&gt; args;
@@ -450,7 +451,7 @@
 
 	// remaining spots
 	if (dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType)) {
-		while (ti != transport-&gt;transported.end() &amp;&amp; startpos.distance(nextPos) &lt; startpos.distance(endpos)) {
+		while (ti != transport-&gt;transported.end() &amp;&amp; startpos.SqDistance(nextPos) &lt; startpos.SqDistance(endpos)) {
 			nextPos += dir*(ti-&gt;unit-&gt;radius);
 			nextPos.y = ground-&gt;GetHeight(nextPos.x, nextPos.z);
 
@@ -633,7 +634,7 @@
 		}
 
 		float3 pos(c.params[0], c.params[1], c.params[2]);
-		if(goalPos.distance2D(pos) &gt; 20){
+		if(goalPos.SqDistance2D(pos) &gt; 400){
 			SetGoal(pos, owner-&gt;pos);
 		}
 
@@ -656,7 +657,7 @@
 			}
 		}
 
-		if (pos.distance2D(owner-&gt;pos) &lt; (owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
+		if (pos.SqDistance2D(owner-&gt;pos) &lt; Square(owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
 			CTAAirMoveType* am = dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType);
 			if (am != NULL) {
 				// handle air transports differently
@@ -665,7 +666,7 @@
 				SetGoal(wantedPos, owner-&gt;pos);
 				am-&gt;SetWantedAltitude(unit-&gt;model-&gt;height);
 				am-&gt;maxDrift = 1;
-				if ((owner-&gt;pos.distance(wantedPos) &lt; 8) &amp;&amp;
+				if ((owner-&gt;pos.SqDistance(wantedPos) &lt; 64) &amp;&amp;
 						(owner-&gt;updir.dot(UpVector) &gt; 0.99f)) {
 					if (!SpotIsClearIgnoreSelf(wantedPos, unit)) {
 						// chosen spot is no longer clear to land, choose a new one
@@ -720,7 +721,7 @@
 		float3 pos(c.params[0],c.params[1],c.params[2]); //head towards goal
 
 		//note that taairmovetype must be modified to allow non stop movement through goals for this to work well
-		if(goalPos.distance2D(pos)&gt;20){
+		if(goalPos.SqDistance2D(pos)&gt;400){
 			SetGoal(pos,owner-&gt;pos);
 			lastDropPos = pos;
 		}
@@ -732,7 +733,7 @@
 			am-&gt;maxDrift=1;
 
 			//if near target or have past it accidentally- drop unit
-			if(owner-&gt;pos.distance2D(pos) &lt; 40 || (((pos - owner-&gt;pos).Normalize()).distance(owner-&gt;frontdir.Normalize()) &gt; 0.5 &amp;&amp; owner-&gt;pos.distance2D(pos)&lt; 205)) {
+			if(owner-&gt;pos.SqDistance2D(pos) &lt; 1600 || (((pos - owner-&gt;pos).Normalize()).SqDistance(owner-&gt;frontdir.Normalize()) &gt; 0.25 &amp;&amp; owner-&gt;pos.SqDistance2D(pos)&lt; (205*205))) {
 				am-&gt;dontLand=true;
 				owner-&gt;cob-&gt;Call(&quot;EndTransport&quot;); //test
 				((CTransportUnit*)owner)-&gt;DetachUnitFromAir(unit,pos);
@@ -798,11 +799,11 @@
 		//move to position
 		float3 pos(c.params[0], c.params[1], c.params[2]);
 		if (isFirstIteration) {
-			if(goalPos.distance2D(pos) &gt; 20)
+			if(goalPos.SqDistance2D(pos) &gt; 400)
 				SetGoal(startingDropPos, owner-&gt;pos);
 		}
 
-		if (startingDropPos.distance2D(owner-&gt;pos) &lt; (owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
+		if (startingDropPos.SqDistance2D(owner-&gt;pos) &lt; Square(owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
 			//create aircraft movetype instance
 			CTAAirMoveType* am = dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType);
 
@@ -866,7 +867,7 @@
 	std::vector&lt;CUnit*&gt; units=qf-&gt;GetUnitsExact(center,radius);
 	for(std::vector&lt;CUnit*&gt;::iterator ui=units.begin();ui!=units.end();++ui){
 		CUnit* unit=(*ui);
-		float dist=unit-&gt;pos.distance2D(owner-&gt;pos);
+		float dist=unit-&gt;pos.SqDistance2D(owner-&gt;pos);
 		if(CanTransport(unit) &amp;&amp; dist&lt;bestDist &amp;&amp; !unit-&gt;toBeTransported &amp;&amp;
 				 (unit-&gt;losStatus[owner-&gt;allyteam] &amp; (LOS_INRADAR|LOS_INLOS))){
 			bestDist=dist;
@@ -1022,8 +1023,8 @@
 	}
 	Command cmd = commandQue[1];
 	return !(cmd.id == CMD_LOAD_UNITS &amp;&amp; cmd.params.size() == 4
-		&amp;&amp; unit-&gt;pos.distance2D(
-		float3(cmd.params[0], cmd.params[1], cmd.params[2])) &gt; cmd.params[3]*2);
+		&amp;&amp; unit-&gt;pos.SqDistance2D(
+		float3(cmd.params[0], cmd.params[1], cmd.params[2])) &gt; Square(cmd.params[3]*2));
 }
 
 bool CTransportCAI::AllowedCommand(const Command&amp; c)

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -874,9 +874,9 @@
 				KillUnit(true, false, NULL);
 			}
 		}
-		if (userTarget &amp;&amp; userTarget-&gt;pos.distance(pos) &lt; unitDef-&gt;kamikazeDist)
+		if (userTarget &amp;&amp; (userTarget-&gt;pos.SqDistance(pos) &lt; Square(unitDef-&gt;kamikazeDist)))
 			KillUnit(true, false, NULL);
-		if (userAttackGround &amp;&amp; userAttackPos.distance(pos) &lt; unitDef-&gt;kamikazeDist)
+		if (userAttackGround &amp;&amp; (userAttackPos.distance(pos)) &lt; Square(unitDef-&gt;kamikazeDist))
 			KillUnit(true, false, NULL);
 	}
 

Modified: trunk/rts/Sim/Units/UnitTypes/Builder.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -257,7 +257,7 @@
 				StopBuild(true);
 			}
 		}
-		else if (curBuild &amp;&amp; f3Dist(curBuild-&gt;pos, pos) &lt; buildDistance + curBuild-&gt;radius) {
+		else if (curBuild &amp;&amp; f3SqDist(curBuild-&gt;pos, pos) &lt; Square(buildDistance + curBuild-&gt;radius)) {
 			if (curBuild-&gt;soloBuilder &amp;&amp; (curBuild-&gt;soloBuilder != this)) {
 				StopBuild();
 			} else {
@@ -292,7 +292,7 @@
 				}
 			}
 		}
-		else if(curReclaim &amp;&amp; f3Dist(curReclaim-&gt;pos, pos)&lt;buildDistance+curReclaim-&gt;radius &amp;&amp; inBuildStance){
+		else if(curReclaim &amp;&amp; f3SqDist(curReclaim-&gt;pos, pos)&lt;Square(buildDistance+curReclaim-&gt;radius) &amp;&amp; inBuildStance){
 			if (scriptCloak &lt;= 2) {
 				if (isCloaked) {
 					isCloaked = false;
@@ -304,7 +304,7 @@
 				CreateNanoParticle(curReclaim-&gt;midPos, curReclaim-&gt;radius * 0.7f, true);
 			}
 		}
-		else if(curResurrect &amp;&amp; f3Dist(curResurrect-&gt;pos, pos)&lt;buildDistance+curResurrect-&gt;radius &amp;&amp; inBuildStance){
+		else if(curResurrect &amp;&amp; f3SqDist(curResurrect-&gt;pos, pos)&lt;Square(buildDistance+curResurrect-&gt;radius) &amp;&amp; inBuildStance){
 			const UnitDef* ud=unitDefHandler-&gt;GetUnitByName(curResurrect-&gt;createdFromUnit);
 			if(ud){
 				if ((modInfo.reclaimMethod != 1) &amp;&amp; (curResurrect-&gt;reclaimLeft &lt; 1)) {
@@ -338,7 +338,7 @@
 				StopBuild(true);
 			}
 		}
-		else if(curCapture &amp;&amp; f3Dist(curCapture-&gt;pos, pos)&lt;buildDistance+curCapture-&gt;radius &amp;&amp; inBuildStance){
+		else if(curCapture &amp;&amp; f3SqDist(curCapture-&gt;pos, pos)&lt;Square(buildDistance+curCapture-&gt;radius) &amp;&amp; inBuildStance){
 			if(curCapture-&gt;team!=team){
 
 				float captureProgressTemp = curCapture-&gt;captureProgress + 1.0f/(150+curCapture-&gt;buildTime/captureSpeed*(curCapture-&gt;health+curCapture-&gt;maxHealth)/curCapture-&gt;maxHealth*0.4f);

Modified: trunk/rts/Sim/Units/UnitTypes/Builder.h
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Builder.h	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/UnitTypes/Builder.h	2008-10-27 11:09:28 UTC (rev 6915)
@@ -20,6 +20,9 @@
 	inline float f3Dist(const float3&amp; a, const float3&amp; b) const {
 		return range3D ? a.distance(b) : a.distance2D(b);
 	}
+	inline float f3SqDist(const float3&amp; a, const float3&amp; b) const {
+		return range3D ? a.SqDistance(b) : a.SqDistance2D(b);
+	}
 	inline float f3Len(const float3&amp; a) const {
 		return range3D ? a.Length() : a.Length2D();
 	}

Modified: trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -18,6 +18,7 @@
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
 #include &quot;creg/STL_List.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CExtractorBuilding, CBuilding, );
@@ -108,10 +109,10 @@
 		const float3 p7 = circle-&gt;pos + float3(                    0.0f, 0.0f,  circle-&gt;extractionRange); // 270
 
 		// square corners must all lie outside circle
-		const bool b0 = (p0.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
-		const bool b1 = (p1.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
-		const bool b2 = (p2.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
-		const bool b3 = (p3.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
+		const bool b0 = (p0.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
+		const bool b1 = (p1.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
+		const bool b2 = (p2.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
+		const bool b3 = (p3.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
 		// circle &quot;corners&quot; must all lie outside square
 		const bool b4 = ((p4.x &lt; p0.x || p4.x &gt; p1.x) &amp;&amp; (p4.z &lt; p0.z || p4.z &gt; p3.z));
 		const bool b5 = ((p5.x &lt; p0.x || p5.x &gt; p1.x) &amp;&amp; (p5.z &lt; p0.z || p5.z &gt; p3.z));
@@ -122,7 +123,7 @@
 	}
 	if (sum == 0) {
 		// circle vs. circle
-		return (this-&gt;pos.distance2D(other-&gt;pos) &lt; (this-&gt;extractionRange + other-&gt;extractionRange));
+		return (this-&gt;pos.SqDistance2D(other-&gt;pos) &lt; Square(this-&gt;extractionRange + other-&gt;extractionRange));
 	}
 
 	return false;
@@ -164,9 +165,9 @@
 			// center of metalsquare at (x, z)
 			const float3 msqrPos((x + 0.5f) * METAL_MAP_SQUARE_SIZE, pos.y,
 			                     (z + 0.5f) * METAL_MAP_SQUARE_SIZE);
-			const float sqrCenterDistance = msqrPos.distance2D(this-&gt;pos);
+			const float sqrCenterDistance = msqrPos.SqDistance2D(this-&gt;pos);
 
-			if (unitDef-&gt;extractSquare || sqrCenterDistance &lt; extractionRange) {
+			if (unitDef-&gt;extractSquare || sqrCenterDistance &lt; Square(extractionRange)) {
 				MetalSquareOfControl msqr;
 				msqr.x = x;
 				msqr.z = z;

Modified: trunk/rts/Sim/Weapons/DGunWeapon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/DGunWeapon.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Weapons/DGunWeapon.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -7,6 +7,7 @@
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;WeaponDefHandler.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CDGunWeapon, CWeapon, (NULL));
@@ -40,7 +41,7 @@
 
 void CDGunWeapon::Fire(void)
 {
-	if(uh-&gt;limitDgun &amp;&amp; owner-&gt;unitDef-&gt;isCommander &amp;&amp; owner-&gt;pos.distance(gs-&gt;Team(owner-&gt;team)-&gt;startPos)&gt;uh-&gt;dgunRadius){
+	if(uh-&gt;limitDgun &amp;&amp; owner-&gt;unitDef-&gt;isCommander &amp;&amp; owner-&gt;pos.SqDistance(gs-&gt;Team(owner-&gt;team)-&gt;startPos)&gt;Square(uh-&gt;dgunRadius)){
 		return;		//prevents dgunning using fps view if outside dgunlimit
 	}
 

Modified: trunk/rts/Sim/Weapons/bombdropper.cpp
===================================================================
--- trunk/rts/Sim/Weapons/bombdropper.cpp	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/Sim/Weapons/bombdropper.cpp	2008-10-27 11:09:28 UTC (rev 6915)
@@ -16,6 +16,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;WeaponDefHandler.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CBombDropper, CWeapon, (NULL, false));
@@ -65,7 +66,7 @@
 				predict=0;
 			float3 hitpos=owner-&gt;pos+owner-&gt;speed*predict;
 			float speedf=owner-&gt;speed.Length();
-			if(hitpos.distance2D(targetPos)&lt;std::max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange){
+			if(hitpos.SqDistance2D(targetPos)&lt;Square(std::max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange)){
 				subClassReady=true;
 			}
 		}

Modified: trunk/rts/System/Sync/SyncedFloat3.h
===================================================================
--- trunk/rts/System/Sync/SyncedFloat3.h	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/System/Sync/SyncedFloat3.h	2008-10-27 11:09:28 UTC (rev 6915)
@@ -496,6 +496,47 @@
 		return x*x+z*z;
 	}
 
+
+	/**
+	 * @brief SqDistance between float3s squared
+	 * @param f float3 to compare against
+	 * @return float squared distance between float3s
+	 *
+	 * Returns the squared distance of 2 float3s
+	 */
+	inline float SqDistance(const SyncedFloat3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dy = y - f.y;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dy*dy + dz*dz);
+	}
+	inline float SqDistance(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dy = y - f.y;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dy*dy + dz*dz);
+	}
+
+
+	/**
+	 * @brief SqDistance2D between float3s (only x and z)
+	 * @param f float3 to compare against
+	 * @return 2D squared distance between float3s
+	 *
+	 * Returns the squared 2d-distance of 2 float3s
+	 */
+	inline float SqDistance2D(const SyncedFloat3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dz*dz);
+	}
+	inline float SqDistance2D(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dz*dz);
+	}
+
+
 	SyncedFloat x; ///&lt; x component
 	SyncedFloat y; ///&lt; y component
 	SyncedFloat z; ///&lt; z component

Modified: trunk/rts/System/float3.h
===================================================================
--- trunk/rts/System/float3.h	2008-10-27 09:42:50 UTC (rev 6914)
+++ trunk/rts/System/float3.h	2008-10-27 11:09:28 UTC (rev 6915)
@@ -430,7 +430,37 @@
 		return x*x + z*z;
 	}
 
+
 	/**
+	 * @brief SqDistance between float3s squared
+	 * @param f float3 to compare against
+	 * @return float squared distance between float3s
+	 *
+	 * Returns the squared distance of 2 float3s
+	 */
+	inline float SqDistance(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dy = y - f.y;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dy*dy + dz*dz);
+	}
+
+
+	/**
+	 * @brief SqDistance2D between float3s (only x and z)
+	 * @param f float3 to compare against
+	 * @return 2D squared distance between float3s
+	 *
+	 * Returns the squared 2d-distance of 2 float3s
+	 */
+	inline float SqDistance2D(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dz = z - f.z;
+		return (float)(dx*dx + dz*dz);
+	}
+
+
+	/**
 	 * @brief max x pos
 	 *
 	 * Static value containing the maximum


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001683.html">[Taspring-linux-commit] r6914 - trunk/rts/Map
</A></li>
	<LI>Next message: <A HREF="001685.html">[Taspring-linux-commit] r6916 - in trunk:	installer/builddata/springcontent/shaders rts/Rendering/Env
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1684">[ date ]</a>
              <a href="thread.html#1684">[ thread ]</a>
              <a href="subject.html#1684">[ subject ]</a>
              <a href="author.html#1684">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
