<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6494 - in branches/caiinterface: . AI	AI/Group AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/AAI AI/Skirmish/CSAI	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win	AI/Skirmish/CSAI/CSAI2 AI/Skirmish/CSAI/CSAILoader	AI/Skirmish/CSAI/MonoLoader AI/Skirmish/JCAI	AI/Skirmish/KAI-0.2 AI/Skirmish/KAIK-0.13 AI/Skirmish/NTai	AI/Skirmish/NTai/AI AI/Skirmish/NTai/AI/nbproject/private	AI/Skirmish/NullAI AI/Skirmish/RAI-0.553	AI/Skirmish/TestGlobalAI Lobby/AFLobby/src/aflobby	Lobby/TASClient game/startscripts installer/sections rts	rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper	rts/ExternalAI/Interface/LegacyCppWrapper/Event rts/Game	rts/Game/StartScripts rts/Lua rts/Map rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/build/scons	rts/lib/lua/src rts/lib/streflop
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6494%20-%20in%20branches/caiinterface%3A%20.%20AI%0A%09AI/Group%20AI/Interfaces%20AI/Interfaces/C%20AI/Skirmish%0A%09AI/Skirmish/AAI%20AI/Skirmish/CSAI%0A%09AI/Skirmish/CSAI/ABICompatibilityLayer%0A%09AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win%0A%09AI/Skirmish/CSAI/CSAI2%20AI/Skirmish/CSAI/CSAILoader%0A%09AI/Skirmish/CSAI/MonoLoader%20AI/Skirmish/JCAI%0A%09AI/Skirmish/KAI-0.2%20AI/Skirmish/KAIK-0.13%20AI/Skirmish/NTai%0A%09AI/Skirmish/NTai/AI%20AI/Skirmish/NTai/AI/nbproject/private%0A%09AI/Skirmish/NullAI%20AI/Skirmish/RAI-0.553%0A%09AI/Skirmish/TestGlobalAI%20Lobby/AFLobby/src/aflobby%0A%09Lobby/TASClient%20game/startscripts%20installer/sections%20rts%0A%09rts/ExternalAI%20rts/ExternalAI/Interface%0A%09rts/ExternalAI/Interface/LegacyCppWrapper%0A%09rts/ExternalAI/Interface/LegacyCppWrapper/Event%20rts/Game%0A%09rts/Game/StartScripts%20rts/Lua%20rts/Map%20rts/System%0A%09rts/System/Platform%20rts/System/Platform/Linux%0A%09rts/System/Platform/Win%20rts/System/Script%20rts/build/scons%0A%09rts/lib/lua/src%20rts/lib/streflop&In-Reply-To=%3C20081001180338.6FD334A43%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001263.html">
   <LINK REL="Next"  HREF="001265.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6494 - in branches/caiinterface: . AI	AI/Group AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/AAI AI/Skirmish/CSAI	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win	AI/Skirmish/CSAI/CSAI2 AI/Skirmish/CSAI/CSAILoader	AI/Skirmish/CSAI/MonoLoader AI/Skirmish/JCAI	AI/Skirmish/KAI-0.2 AI/Skirmish/KAIK-0.13 AI/Skirmish/NTai	AI/Skirmish/NTai/AI AI/Skirmish/NTai/AI/nbproject/private	AI/Skirmish/NullAI AI/Skirmish/RAI-0.553	AI/Skirmish/TestGlobalAI Lobby/AFLobby/src/aflobby	Lobby/TASClient game/startscripts installer/sections rts	rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper	rts/ExternalAI/Interface/LegacyCppWrapper/Event rts/Game	rts/Game/StartScripts rts/Lua rts/Map rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/build/scons	rts/lib/lua/src rts/lib/streflop</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6494%20-%20in%20branches/caiinterface%3A%20.%20AI%0A%09AI/Group%20AI/Interfaces%20AI/Interfaces/C%20AI/Skirmish%0A%09AI/Skirmish/AAI%20AI/Skirmish/CSAI%0A%09AI/Skirmish/CSAI/ABICompatibilityLayer%0A%09AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win%0A%09AI/Skirmish/CSAI/CSAI2%20AI/Skirmish/CSAI/CSAILoader%0A%09AI/Skirmish/CSAI/MonoLoader%20AI/Skirmish/JCAI%0A%09AI/Skirmish/KAI-0.2%20AI/Skirmish/KAIK-0.13%20AI/Skirmish/NTai%0A%09AI/Skirmish/NTai/AI%20AI/Skirmish/NTai/AI/nbproject/private%0A%09AI/Skirmish/NullAI%20AI/Skirmish/RAI-0.553%0A%09AI/Skirmish/TestGlobalAI%20Lobby/AFLobby/src/aflobby%0A%09Lobby/TASClient%20game/startscripts%20installer/sections%20rts%0A%09rts/ExternalAI%20rts/ExternalAI/Interface%0A%09rts/ExternalAI/Interface/LegacyCppWrapper%0A%09rts/ExternalAI/Interface/LegacyCppWrapper/Event%20rts/Game%0A%09rts/Game/StartScripts%20rts/Lua%20rts/Map%20rts/System%0A%09rts/System/Platform%20rts/System/Platform/Linux%0A%09rts/System/Platform/Win%20rts/System/Script%20rts/build/scons%0A%09rts/lib/lua/src%20rts/lib/streflop&In-Reply-To=%3C20081001180338.6FD334A43%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6494 - in branches/caiinterface: . AI	AI/Group AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/AAI AI/Skirmish/CSAI	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win	AI/Skirmish/CSAI/CSAI2 AI/Skirmish/CSAI/CSAILoader	AI/Skirmish/CSAI/MonoLoader AI/Skirmish/JCAI	AI/Skirmish/KAI-0.2 AI/Skirmish/KAIK-0.13 AI/Skirmish/NTai	AI/Skirmish/NTai/AI AI/Skirmish/NTai/AI/nbproject/private	AI/Skirmish/NullAI AI/Skirmish/RAI-0.553	AI/Skirmish/TestGlobalAI Lobby/AFLobby/src/aflobby	Lobby/TASClient game/startscripts installer/sections rts	rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper	rts/ExternalAI/Interface/LegacyCppWrapper/Event rts/Game	rts/Game/StartScripts rts/Lua rts/Map rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/build/scons	rts/lib/lua/src rts/lib/streflop">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Oct  1 20:03:37 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001263.html">[Taspring-linux-commit] r6493 - in branches/caiinterface/tools:	scripts unitsync
</A></li>
        <LI>Next message: <A HREF="001265.html">[Taspring-linux-commit] r6495 - in	branches/caiinterface/AI/Skirmish/RAI-0.553: CodeBlocks DevC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1264">[ date ]</a>
              <a href="thread.html#1264">[ thread ]</a>
              <a href="subject.html#1264">[ subject ]</a>
              <a href="author.html#1264">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-10-01 20:03:35 +0200 (Wed, 01 Oct 2008)
New Revision: 6494

Added:
   branches/caiinterface/AI/Group/CMakeLists.txt
   branches/caiinterface/AI/Interfaces/
   branches/caiinterface/AI/Interfaces/C/
   branches/caiinterface/AI/Interfaces/C/Interface.cpp
   branches/caiinterface/AI/Interfaces/C/Interface.h
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
   branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua
   branches/caiinterface/AI/Interfaces/C/README
   branches/caiinterface/AI/Interfaces/CMakeLists.txt
   branches/caiinterface/AI/Skirmish/
   branches/caiinterface/AI/Skirmish/AAI/
   branches/caiinterface/AI/Skirmish/CMakeLists.txt
   branches/caiinterface/AI/Skirmish/CSAI/
   branches/caiinterface/AI/Skirmish/JCAI/
   branches/caiinterface/AI/Skirmish/KAI-0.2/
   branches/caiinterface/AI/Skirmish/KAIK-0.13/
   branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h
   branches/caiinterface/AI/Skirmish/KAIK-0.13/AIInfo.lua
   branches/caiinterface/AI/Skirmish/KAIK-0.13/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NTai/
   branches/caiinterface/AI/Skirmish/NullAI/
   branches/caiinterface/AI/Skirmish/NullAI/AI.cpp
   branches/caiinterface/AI/Skirmish/NullAI/AI.h
   branches/caiinterface/AI/Skirmish/NullAI/AIExport.cpp
   branches/caiinterface/AI/Skirmish/NullAI/AIExport.h
   branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullAI/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NullAI/AISCommands.cpp
   branches/caiinterface/AI/Skirmish/RAI-0.553/
   branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.cpp
   branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.h
   branches/caiinterface/AI/Skirmish/RAI-0.553/AIInfo.lua
   branches/caiinterface/AI/Skirmish/RAI-0.553/AIOptions.lua
   branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp
   branches/caiinterface/AI/Skirmish/TestGlobalAI/
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
   branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
   branches/caiinterface/rts/ExternalAI/AILibraryManager.h
   branches/caiinterface/rts/ExternalAI/GroupAILibrary.cpp
   branches/caiinterface/rts/ExternalAI/GroupAILibrary.h
   branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
   branches/caiinterface/rts/ExternalAI/IAIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/IAILibraryManager.cpp
   branches/caiinterface/rts/ExternalAI/IAILibraryManager.h
   branches/caiinterface/rts/ExternalAI/IGroupAILibrary.h
   branches/caiinterface/rts/ExternalAI/ISkirmishAI.h
   branches/caiinterface/rts/ExternalAI/ISkirmishAILibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/
   branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
   branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h
   branches/caiinterface/rts/ExternalAI/Interface/ELevelOfSupport.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.cpp
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.cpp
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.cpp
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.cpp
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AISCommands.cpp
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDamagedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDestroyedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterLOSEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterRadarEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveLOSEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveRadarEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvents.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIInitEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIMessageEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AINullEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIPlayerCommandEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AISeismicPingEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCapturedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCreatedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDamagedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDestroyedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitFinishedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitGivenEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitIdleEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitMoveFailedEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUpdateEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIWeaponFiredEvent.h
   branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
   branches/caiinterface/rts/ExternalAI/Interface/SAIFloat3.h
   branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SInfo.h
   branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SOption.h
   branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/aidefines.h
   branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAI.h
   branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.h
   branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
   branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h
   branches/caiinterface/rts/System/exportdefines.h
Removed:
   branches/caiinterface/AI/Global/
   branches/caiinterface/AI/Skirmish/AAI/
   branches/caiinterface/AI/Skirmish/CSAI/
   branches/caiinterface/AI/Skirmish/JCAI/
   branches/caiinterface/AI/Skirmish/KAI-0.2/
   branches/caiinterface/AI/Skirmish/KAIK-0.13/
   branches/caiinterface/AI/Skirmish/NTai/
   branches/caiinterface/AI/Skirmish/RAI-0.553/
   branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp
   branches/caiinterface/AI/Skirmish/TestGlobalAI/
   branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp
   branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h
   branches/caiinterface/rts/ExternalAI/AISCommands.h
   branches/caiinterface/rts/ExternalAI/AISEvents.h
   branches/caiinterface/rts/ExternalAI/GlobalAI.cpp
   branches/caiinterface/rts/ExternalAI/GlobalAI.h
   branches/caiinterface/rts/ExternalAI/Group.cpp
   branches/caiinterface/rts/ExternalAI/Group.h
   branches/caiinterface/rts/ExternalAI/IGroupAI.h
   branches/caiinterface/rts/ExternalAI/SAICallback.h
   branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp
   branches/caiinterface/rts/ExternalAI/SAIFloat3.h
Modified:
   branches/caiinterface/AI/CMakeLists.txt
   branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/AbicProxy.h
   branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.cpp
   branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.h
   branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/buildabic.bat
   branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/buildabic_obsolete_for_spring_in_msvc.bat
   branches/caiinterface/AI/Skirmish/CSAI/CSAI2/CSAI2.csproj
   branches/caiinterface/AI/Skirmish/CSAI/CSAILoader/CSAILoader.build
   branches/caiinterface/AI/Skirmish/CSAI/CSAILoader/CSAIProxy.h
   branches/caiinterface/AI/Skirmish/CSAI/MonoLoader/build.bat
   branches/caiinterface/AI/Skirmish/CSAI/readme.txt
   branches/caiinterface/AI/Skirmish/CSAI/setup.cs
   branches/caiinterface/AI/Skirmish/JCAI/GlobalAI.cpp
   branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExports.cpp
   branches/caiinterface/AI/Skirmish/NTai/AI/AI.vcproj
   branches/caiinterface/AI/Skirmish/NTai/AI/dll.cbp
   branches/caiinterface/AI/Skirmish/NTai/AI/nbproject/private/private.xml
   branches/caiinterface/AI/Skirmish/TestGlobalAI/TestAI.vcproj
   branches/caiinterface/Lobby/AFLobby/src/aflobby/CBattleWindow.java
   branches/caiinterface/Lobby/TASClient/MainUnit.pas
   branches/caiinterface/SConstruct
   branches/caiinterface/directories.txt
   branches/caiinterface/game/startscripts/aistartscripttest.lua
   branches/caiinterface/installer/sections/aai.nsh
   branches/caiinterface/installer/sections/kai.nsh
   branches/caiinterface/installer/sections/main.nsh
   branches/caiinterface/rts/CMakeLists.txt
   branches/caiinterface/rts/ExternalAI/AICallback.cpp
   branches/caiinterface/rts/ExternalAI/AICheats.cpp
   branches/caiinterface/rts/ExternalAI/AICheats.h
   branches/caiinterface/rts/ExternalAI/AILibrary.cpp
   branches/caiinterface/rts/ExternalAI/AILibrary.h
   branches/caiinterface/rts/ExternalAI/AISCommands.cpp
   branches/caiinterface/rts/ExternalAI/GlobalAICallback.cpp
   branches/caiinterface/rts/ExternalAI/GlobalAICallback.h
   branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp
   branches/caiinterface/rts/ExternalAI/GlobalAIHandler.h
   branches/caiinterface/rts/ExternalAI/SAICallback.cpp
   branches/caiinterface/rts/ExternalAI/aibase.h
   branches/caiinterface/rts/Game/GameServer.cpp
   branches/caiinterface/rts/Game/GameSetup.cpp
   branches/caiinterface/rts/Game/GameSetup.h
   branches/caiinterface/rts/Game/Player.cpp
   branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp
   branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.cpp
   branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.h
   branches/caiinterface/rts/Game/StartScripts/ScriptHandler.cpp
   branches/caiinterface/rts/Game/Team.cpp
   branches/caiinterface/rts/Game/Team.h
   branches/caiinterface/rts/Lua/LuaIO.cpp
   branches/caiinterface/rts/Lua/LuaSyncedRead.cpp
   branches/caiinterface/rts/Map/MapParser.cpp
   branches/caiinterface/rts/System/GlobalStuff.cpp
   branches/caiinterface/rts/System/GlobalStuff.h
   branches/caiinterface/rts/System/LoadSaveHandler.cpp
   branches/caiinterface/rts/System/LogOutput.cpp
   branches/caiinterface/rts/System/LogOutput.h
   branches/caiinterface/rts/System/Platform/BaseCmd.cpp
   branches/caiinterface/rts/System/Platform/ConfigHandler.cpp
   branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp
   branches/caiinterface/rts/System/Platform/Linux/SoLib.cpp
   branches/caiinterface/rts/System/Platform/Linux/SoLib.h
   branches/caiinterface/rts/System/Platform/SharedLib.cpp
   branches/caiinterface/rts/System/Platform/SharedLib.h
   branches/caiinterface/rts/System/Platform/Win/DllLib.cpp
   branches/caiinterface/rts/System/Platform/Win/DllLib.h
   branches/caiinterface/rts/System/Platform/Win/RegHandler.cpp
   branches/caiinterface/rts/System/Platform/errorhandler.h
   branches/caiinterface/rts/System/Script/LuaBinder.cpp
   branches/caiinterface/rts/System/Script/LuaFunctions.cpp
   branches/caiinterface/rts/System/Script/LuaFunctions.h
   branches/caiinterface/rts/System/SpringApp.cpp
   branches/caiinterface/rts/System/StdAfx.h
   branches/caiinterface/rts/System/float3.h
   branches/caiinterface/rts/System/myMath.cpp
   branches/caiinterface/rts/System/myMath.h
   branches/caiinterface/rts/build/scons/config.py
   branches/caiinterface/rts/build/scons/filelist.py
   branches/caiinterface/rts/build/scons/rts.py
   branches/caiinterface/rts/lib/lua/src/lmathlib.cpp
   branches/caiinterface/rts/lib/lua/src/lvm.cpp
   branches/caiinterface/rts/lib/streflop/CMakeLists.txt
Log:
finally it is working in linux (compiled with gcc and cmake) and on windows (compiled with mingw and scons).
what works:
+ AI Interface libraries
+ Skirmish AI libraries
+ AIInfo.lua and AIInterfaceInfo.lua can be read from unitsync(untested) and are read by the engine, to know what engines are around (eg to check if script.txt specifies good values, and for the startscripts)
+ AIOptions.lua can be read through unitsync(untested)
what does not work:
- group AIs (most of the interface code is still missing, the game crashes if you try to select one in game)
- actually passing option values to the AIs (though that will be very simple to add)

How to specify an AI in script.txt
----------------------------------
LUA AI:
both are possible, the first one only for legacy support:
* [code]aispecifyer=LuaAI:&lt;luaAIName&gt;[/code]
* [code]luaai=&lt;luaAIName&gt;[/code]

Skirmish AI:
[code]
aishortname=RAI
aiversion=0.600
[/code]
the second line (specifying the version) is optional.

Modified: branches/caiinterface/AI/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/CMakeLists.txt	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/AI/CMakeLists.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,72 +1,26 @@
-include_directories(${CMAKE_SOURCE_DIR}/rts ${CMAKE_SOURCE_DIR}/rts/ExternalAI ${CMAKE_SOURCE_DIR}/rts/System)
+include_directories(${CMAKE_SOURCE_DIR}/rts ${CMAKE_SOURCE_DIR}/rts/ExternalAI ${CMAKE_SOURCE_DIR}/rts/System ${SDL_INCLUDE_DIR})
 
 add_definitions(-fPIC)
+#remove_definitions(-DSTREFLOP_X87)
+
 aux_source_directory(${CMAKE_SOURCE_DIR}/rts/System/creg creg)
-list (APPEND creg ${CMAKE_SOURCE_DIR}/rts/System/float3)
 
-### Global AIs
-aux_source_directory(Global/KAI-0.2 kai02)
-add_library(KAI-0.2 SHARED ${kai02} ${creg})
+aux_source_directory(${CMAKE_SOURCE_DIR}/rts/ExternalAI/Interface aienv)
+list (APPEND aienv ${CMAKE_SOURCE_DIR}/rts/Game/GameVersion)
+list (APPEND aienv ${CMAKE_SOURCE_DIR}/rts/System/Platform/errorhandler)
 
-aux_source_directory(Global/KAIK-0.13 kai013)
-add_library(KAIK-0.13 SHARED ${kai013} ${creg})
+aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Lua/LuaParser luaparsingenv)
+#aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Map/MapParser luaparsingenv)
 
-aux_source_directory(Global/RAI-0.553 rai)
-add_library(RAI_0.553 SHARED ${rai} Global/RAI-0.553/KrogsMetalClass/MetalMap)
+list (APPEND legacycppaienv ${aienv})
+aux_source_directory(${CMAKE_SOURCE_DIR}/rts/ExternalAI/Interface/LegacyCppWrapper legacycppaienv)
+list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/float3)
+#list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/LogOutput)
 
-aux_source_directory(Global/AAI aai)
-add_library(AAI SHARED ${aai})
 
-if (UNIX)
-	# doesn't build in win32currently
-	aux_source_directory(Global/JCAI jcai)
-	add_library(JCAI SHARED ${jcai})
-endif (UNIX)
 
-aux_source_directory(Global/NTai/AI/NTai/Units ntai)
-aux_source_directory(Global/NTai/AI/NTai/Units/Behaviours ntai)
-aux_source_directory(Global/NTai/AI/NTai/Tasks ntai)
-aux_source_directory(Global/NTai/AI/NTai/Helpers ntai)
-aux_source_directory(Global/NTai/AI/NTai/Helpers/grid ntai)
-aux_source_directory(Global/NTai/AI/NTai/Helpers/Terrain ntai)
-aux_source_directory(Global/NTai/AI/NTai/Helpers/Units ntai)
-aux_source_directory(Global/NTai/AI/NTai/Engine ntai)
-aux_source_directory(Global/NTai/AI/NTai/Core ntai)
-aux_source_directory(Global/NTai/AI/NTai/Agents ntai)
-add_library(NTai SHARED ${ntai})
-target_link_libraries(NTai boost_thread-mt)
+Add_Subdirectory(Interfaces)
+Add_Subdirectory(Skirmish)
+Add_Subdirectory(Group)
 
-aux_source_directory(Global/TestGlobalAI testai)
-add_library(TestGlobalAI SHARED ${testai})
 
-
-if (UNIX)
-	install (TARGETS KAIK-0.13 KAI-0.2 RAI_0.553 AAI JCAI NTai TestGlobalAI DESTINATION ${DATADIR}/AI/Bot-libs)
-else (UNIX)
-	install (TARGETS KAIK-0.13 KAI-0.2 RAI_0.553 AAI NTai TestGlobalAI DESTINATION ${DATADIR}/AI/Bot-libs)
-endif (UNIX)
-
-### Group AIs
-aux_source_directory(Group/CentralBuildAI central)
-add_library(CentralBuildAI SHARED ${central})
-
-aux_source_directory(Group/EconomyAI economy)
-add_library(EconomyAI SHARED ${economy} ${creg})
-
-aux_source_directory(Group/MetalMakerAI metal)
-add_library(MetalMakerAI SHARED ${metal})
-
-aux_source_directory(Group/MexUpgraderAI mex)
-add_library(MexUpgraderAI SHARED ${mex} ${creg})
-
-aux_source_directory(Group/RadarAI radar)
-add_library(RadarAI SHARED ${radar})
-
-aux_source_directory(Group/ReportIdleAI idle)
-add_library(ReportIdleAI SHARED ${idle})
-
-aux_source_directory(Group/SimpleFormationAI formation)
-add_library(SimpleFormationAI SHARED ${formation})
-
-
-install (TARGETS CentralBuildAI EconomyAI MetalMakerAI MexUpgraderAI RadarAI ReportIdleAI SimpleFormationAI DESTINATION ${DATADIR}/AI/Helper-libs)

Added: branches/caiinterface/AI/Group/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Group/CMakeLists.txt	                        (rev 0)
+++ branches/caiinterface/AI/Group/CMakeLists.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,25 @@
+
+### Group AIs
+aux_source_directory(CentralBuildAI central)
+add_library(CentralBuildAI SHARED ${central})
+
+aux_source_directory(EconomyAI economy)
+add_library(EconomyAI SHARED ${economy} ${aienv})
+
+aux_source_directory(MetalMakerAI metal)
+add_library(MetalMakerAI SHARED ${metal})
+
+aux_source_directory(MexUpgraderAI mex)
+add_library(MexUpgraderAI SHARED ${mex} ${aienv})
+
+aux_source_directory(RadarAI radar)
+add_library(RadarAI SHARED ${radar})
+
+aux_source_directory(ReportIdleAI idle)
+add_library(ReportIdleAI SHARED ${idle})
+
+aux_source_directory(SimpleFormationAI formation)
+add_library(SimpleFormationAI SHARED ${formation})
+
+
+install (TARGETS CentralBuildAI EconomyAI MetalMakerAI MexUpgraderAI RadarAI ReportIdleAI SimpleFormationAI DESTINATION ${DATADIR}/AI/Helper-libs)


Property changes on: branches/caiinterface/AI/Group/CMakeLists.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/C/Interface.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,696 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;Interface.h&quot;
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+
+#include &lt;boost/filesystem.hpp&gt;
+#include &lt;boost/regex.hpp&gt;
+
+#include &quot;StdAfx.h&quot;
+#include &quot;System/Platform/errorhandler.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+#include &quot;LogOutput.h&quot;
+
+void CInterface::errorMsgFileNames(const std::string&amp; additionalTxt) const {
+	// !!!check everything in mySkirmishAIFileNames and do a reportError!!!;
+	std::string msg(&quot;mySkirmishAIFileNames:\n&quot;);
+	char buffer[16];
+	sprintf(buffer, &quot;%i&quot;, mySkirmishAIFileNames.size());
+	msg.append(&quot;num: &quot;).append(buffer).append(&quot;\n&quot;);
+	T_skirmishAIFileNames::const_iterator fn;
+	for (fn=mySkirmishAIFileNames.begin(); fn!=mySkirmishAIFileNames.end(); fn++) {
+		msg.append(fn-&gt;first.shortName).append(&quot;\t&quot;);
+		msg.append(fn-&gt;first.version).append(&quot;\t&quot;);
+		msg.append(fn-&gt;second).append(&quot;\n&quot;);
+	}
+	msg.append(&quot;additionalTxt:\n&quot;).append(additionalTxt).append(&quot;\n&quot;);
+	
+	reportError(msg);
+}
+
+CInterface::CInterface() {
+	
+/*
+	// look for Skirmish AI library files
+	std::vector&lt;std::string&gt; skirmishAILibFiles =
+			FindFiles(std::string(PATH_TO_SPRING_HOME) +
+			SKIRMISH_AI_IMPLS_DIR,
+			std::string(&quot;.&quot;) + SharedLib::GetLibExtension());
+	
+	// initialize the skirmish AI specifyers
+	std::vector&lt;std::string&gt;::const_iterator libFile;
+	for (libFile=skirmishAILibFiles.begin(); libFile!=skirmishAILibFiles.end(); libFile++) { // skimrihs IAs
+		
+		//std::string fileName = std::string(extractFileName(*libFile, false));
+		std::string fileName = boost::filesystem::basename(*libFile);
+		
+		// load the interface
+		SSAILibrary skirmishAILib;
+		SharedLib* sharedLib = LoadSkirmishAILib(*libFile, &amp;skirmishAILib);
+		if (sharedLib == NULL) {
+			reportError(std::string(&quot;Failed to load skirmish AI shared library: &quot;) + (*libFile));
+		}
+		
+		SSAISpecifyer skirmishAISpecifyer = extractSpecifyer(skirmishAILib);
+		skirmishAISpecifyer = copySSAISpecifyer(&amp;skirmishAISpecifyer);
+		mySkirmishAISpecifyers.push_back(skirmishAISpecifyer);
+		
+		delete sharedLib;
+	}
+*/
+	
+	//static const unsigned int MAX_INFOS = 128;
+	
+	// Read from Skirmish AI info and option files
+	std::vector&lt;std::string&gt; skirmishAIDataDirs = FindDirs(SKIRMISH_AI_DATA_DIR);
+	for (std::vector&lt;std::string&gt;::iterator dir = skirmishAIDataDirs.begin(); dir != skirmishAIDataDirs.end(); ++dir) {
+		const std::string&amp; possibleDataDir = *dir;
+		boost::filesystem::path fullPath(possibleDataDir + &quot;/AIInfo.lua&quot;);
+		if (boost::filesystem::exists(fullPath)) { // skirmish AI info is available
+			//logOutput.Print(&quot;FFFFFF AIInfo.lua file: %s\n&quot;, fullPath.string().c_str());
+			// parse the ai info and extract specifyer and filename
+			InfoItem tmpInfos[MAX_INFOS];
+			unsigned int num = ParseInfosRawFileSystem(fullPath.string().c_str(), tmpInfos, MAX_INFOS);
+			std::map&lt;std::string,const char*&gt; infos;
+			for (unsigned int i=0; i &lt; num; ++i) {
+				infos[std::string(tmpInfos[i].key)] = tmpInfos[i].value;
+			}
+	
+			const char* intSN = infos[SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME];
+			const char* intV = infos[SKIRMISH_AI_PROPERTY_INTERFACE_VERSION];
+			//logOutput.Print(&quot;FFFFFF required interface (SN/V): %s %s\n&quot;, intSN, intV);
+/*
+std::string msg(&quot;&quot;);
+char buffer[128];
+sprintf(buffer, &quot;FFF: %s %s\n&quot;, intSN, intV);
+msg.append(buffer);
+reportError(msg);
+*/
+			bool fits = FitsThisInterface(intSN, intV);
+			if (fits) {
+				const char* fn = infos[SKIRMISH_AI_PROPERTY_FILE_NAME];
+				const char* sn = infos[SKIRMISH_AI_PROPERTY_SHORT_NAME];
+				const char* v = infos[SKIRMISH_AI_PROPERTY_VERSION];
+				//logOutput.Print(&quot;FFFFFF AI (FN/SN/V): %s %s %s\n&quot;, fn, sn, v);
+/*
+std::string msg(&quot;&quot;);
+char buffer[128];
+sprintf(buffer, &quot;%s %s %s\n&quot;, fn, sn, v);
+msg.append(buffer);
+reportError(msg);
+*/
+				if (strlen(fn) == 0 || strlen(sn) == 0 || strlen(v) == 0) {
+					//logOutput.Print(&quot;FFFFFF something has 0 length -&gt; not added\n&quot;);
+					// not all needed values are specifyed in AIInfo.lua
+				} else {
+					SSAISpecifyer skirmishAISpecifyer = {sn, v};
+					skirmishAISpecifyer = copySSAISpecifyer(&amp;skirmishAISpecifyer);
+					//logOutput.Print(&quot;FFFFFF AI specifyer (SN/V): %s %s\n&quot;, skirmishAISpecifyer.shortName, skirmishAISpecifyer.version);
+					//int pos = mySkirmishAISpecifyers.size();
+					mySkirmishAISpecifyers.push_back(skirmishAISpecifyer);
+					mySkirmishAIFileNames[skirmishAISpecifyer] = fn;
+					//mySkirmishAIFileNames[mySkirmishAISpecifyers.at(pos)] = fn;
+				}
+			}
+		}
+	}
+	
+	
+/*
+	SSAISpecifyer a = {&quot;A&quot;, &quot;0.1&quot;};
+	SSAISpecifyer b = {&quot;B&quot;, &quot;0.2&quot;};
+	SSAISpecifyer c = {&quot;B&quot;, &quot;0.2&quot;};
+	mySkirmishAIFileNames[a] = &quot;A&quot;;
+	mySkirmishAIFileNames[b] = &quot;B&quot;;
+	mySkirmishAIFileNames[c] = &quot;C&quot;;
+*/
+/*
+	equalTheyAre = SSAISpecifyer_Comparator()(a, b);
+	logOutput.Print(&quot;FFFFFF specs are equal? (N): %i\n&quot;, equalTheyAre);
+	equalTheyAre = SSAISpecifyer_Comparator()(b, c);
+	logOutput.Print(&quot;FFFFFF specs are equal? (Y): %i\n&quot;, equalTheyAre);
+*/
+	
+/*
+	logOutput.Print(&quot;FFFFFF num filenames and specifyers: %i %i\n&quot;, mySkirmishAIFileNames.size(), mySkirmishAISpecifyers.size());
+	T_skirmishAIFileNames::const_iterator fn;
+	for (fn=mySkirmishAIFileNames.begin(); fn!=mySkirmishAIFileNames.end(); fn++) {
+		logOutput.Print(&quot;FFFFFF shortName version filename: %s %s %s\n&quot;, fn-&gt;first.shortName, fn-&gt;first.version, fn-&gt;second.c_str());
+	}
+	bool equalTheyAre = SSAISpecifyer_Comparator()(mySkirmishAISpecifyers.at(0), mySkirmishAISpecifyers.at(1));
+	logOutput.Print(&quot;FFFFFF specs are equal?: %i\n&quot;, equalTheyAre);
+	std::vector&lt;SSAISpecifyer&gt;::const_iterator spec;
+	for (spec=mySkirmishAISpecifyers.begin(); spec!=mySkirmishAISpecifyers.end(); spec++) {
+		logOutput.Print(&quot;FFFFFF spec: shortName version: %s %s\n&quot;, spec-&gt;shortName, spec-&gt;version);
+	}
+*/
+	
+	
+	
+	// look for Group AI library files
+/*
+	std::vector&lt;std::string&gt; groupAILibFiles =
+			FindFiles(GROUP_AI_IMPLS_DIR,
+			std::string(&quot;*.&quot;) + SharedLib::GetLibExtension());
+	
+	// initialize the group AI specifyers
+	for (libFile=groupAILibFiles.begin(); libFile!=groupAILibFiles.end(); libFile++) { // group IAs
+		
+		std::string fileName = boost::filesystem::basename(*libFile);
+		
+		// load the interface
+		SGAILibrary groupAILib;
+		SharedLib* sharedLib = LoadGroupAILib(*libFile, &amp;groupAILib);
+		if (sharedLib == NULL) {
+			reportError(std::string(&quot;Failed to load group AI shared library: &quot;) + (*libFile));
+		}
+		
+		SGAISpecifyer groupAISpecifyer = extractSpecifyer(groupAILib);
+		groupAISpecifyer = copySGAISpecifyer(&amp;groupAISpecifyer);
+		myGroupAISpecifyers.push_back(groupAISpecifyer);
+		
+		delete sharedLib;
+	}
+*/
+	std::vector&lt;std::string&gt; groupAIDataDirs = FindDirs(GROUP_AI_DATA_DIR);
+	for (std::vector&lt;std::string&gt;::iterator dir = groupAIDataDirs.begin(); dir != groupAIDataDirs.end(); ++dir) {
+		const std::string&amp; possibleDataDir = *dir;
+		boost::filesystem::path fullPath(possibleDataDir + &quot;/AIInfo.lua&quot;);
+		if (boost::filesystem::exists(fullPath)) { // group AI info is available
+			// parse the ai info and extract specifyer and filename
+			InfoItem tmpInfos[MAX_INFOS];
+			unsigned int num = ParseInfosRawFileSystem(fullPath.string().c_str(), tmpInfos, MAX_INFOS);
+			std::map&lt;std::string,const char*&gt; infos;
+			for (unsigned int i=0; i &lt; num; ++i) {
+				infos[std::string(tmpInfos[i].key)] = tmpInfos[i].value;
+			}
+	
+			const char* intSN = infos[GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME];
+			const char* intV = infos[GROUP_AI_PROPERTY_INTERFACE_VERSION];
+			bool fits = FitsThisInterface(intSN, intV);
+			if (fits) {
+				const char* fn = infos[GROUP_AI_PROPERTY_FILE_NAME];
+				const char* sn = infos[GROUP_AI_PROPERTY_SHORT_NAME];
+				const char* v = infos[GROUP_AI_PROPERTY_VERSION];
+				if (strlen(fn) == 0 || strlen(sn) == 0 || strlen(v) == 0) {
+					// not all needed values are specifyed in AIInfo.lua
+				} else {
+					SGAISpecifyer groupAISpecifyer = {sn, v};
+					myGroupAIFileNames[groupAISpecifyer] = fn;
+					myGroupAISpecifyers.push_back(groupAISpecifyer);
+				}
+			}
+		}
+	}
+}
+
+int CInterface::GetInfos(InfoItem infos[], int max) {
+	
+	int i = 0;
+	
+	if (myInfos.empty()) {
+		InfoItem ii_0 = {AI_INTERFACE_PROPERTY_SHORT_NAME, &quot;C&quot;, NULL}; myInfos.push_back(ii_0);
+		InfoItem ii_1 = {AI_INTERFACE_PROPERTY_VERSION, &quot;0.1&quot;, NULL}; myInfos.push_back(ii_1);
+		InfoItem ii_2 = {AI_INTERFACE_PROPERTY_NAME, &quot;default C &amp; C++ (legacy and new)&quot;, NULL}; myInfos.push_back(ii_2);
+		InfoItem ii_3 = {AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in C or C++.&quot;, NULL}; myInfos.push_back(ii_3);
+		InfoItem ii_4 = {AI_INTERFACE_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AIInterface:C">http://spring.clan-sy.com/wiki/AIInterface:C</A>&quot;, NULL}; myInfos.push_back(ii_4);
+		InfoItem ii_5 = {AI_INTERFACE_PROPERTY_SUPPORTED_LANGUAGES, &quot;C, C++&quot;, NULL}; myInfos.push_back(ii_5);
+	}
+	
+/*
+	std::map&lt;std::string, std::string&gt;::const_iterator prop;
+	for (prop=myProperties.begin(); prop!=myProperties.end() &amp;&amp; i &lt; max; prop++) {
+		properties[i][0] = prop-&gt;first.c_str();
+		properties[i][1] = prop-&gt;second.c_str();
+		i++;
+	}
+*/
+	std::vector&lt;InfoItem&gt;::const_iterator inf;
+	for (inf=myInfos.begin(); inf!=myInfos.end() &amp;&amp; i &lt; max; inf++) {
+		infos[i] = *inf;
+		i++;
+	}
+	
+	return i;
+}
+
+LevelOfSupport CInterface::GetLevelOfSupportFor(
+		const char* engineVersion, int engineAIInterfaceGeneratedVersion) {
+	return LOS_Working;
+}
+
+
+int CInterface::GetSkirmishAISpecifyers(SSAISpecifyer* sAISpecifyers, int max) const {
+	
+	int i = 0;
+	
+	std::vector&lt;SSAISpecifyer&gt;::const_iterator speci;
+	for (speci=mySkirmishAISpecifyers.begin(); speci!=mySkirmishAISpecifyers.end() &amp;&amp; i &lt; max; speci++) {
+		sAISpecifyers[i] = *speci;
+		i++;
+	}
+	
+	return i;
+}
+const SSAILibrary* CInterface::LoadSkirmishAILibrary(const SSAISpecifyer* const sAISpecifyer) {
+	
+	SSAILibrary* ai;
+	
+	T_skirmishAIs::iterator skirmishAI;
+	skirmishAI = myLoadedSkirmishAIs.find(*sAISpecifyer);
+	if (skirmishAI == myLoadedSkirmishAIs.end()) {
+		
+		ai = new SSAILibrary;
+		SharedLib* lib = Load(sAISpecifyer, ai);
+		
+		myLoadedSkirmishAIs[*sAISpecifyer] = ai;
+		myLoadedSkirmishAILibs[*sAISpecifyer] = lib;
+	} else {
+		ai = skirmishAI-&gt;second;
+	}
+	
+	return ai;
+}
+int CInterface::UnloadSkirmishAILibrary(const SSAISpecifyer* const sAISpecifyer) {
+	
+	T_skirmishAIs::iterator skirmishAI = myLoadedSkirmishAIs.find(*sAISpecifyer);
+	T_skirmishAILibs::iterator skirmishAILib = myLoadedSkirmishAILibs.find(*sAISpecifyer);
+	if (skirmishAI == myLoadedSkirmishAIs.end()) {
+		// to unload AI is not loaded -&gt; no problem, do nothing
+	} else {
+		delete skirmishAI-&gt;second;
+		myLoadedSkirmishAIs.erase(skirmishAI);
+		delete skirmishAILib-&gt;second;
+		myLoadedSkirmishAILibs.erase(skirmishAILib);
+	}
+	
+	return 0;
+}
+int CInterface::UnloadAllSkirmishAILibraries() {
+	
+	while (myLoadedSkirmishAIs.size() &gt; 0) {
+		UnloadSkirmishAILibrary(&amp;(myLoadedSkirmishAIs.begin()-&gt;first));
+	}
+	
+	return 0;
+}
+
+
+
+int CInterface::GetGroupAISpecifyers(SGAISpecifyer* gAISpecifyers, int max) const {
+	
+	int i = 0;
+	
+	std::vector&lt;SGAISpecifyer&gt;::const_iterator speci;
+	for (speci=myGroupAISpecifyers.begin(); speci!=myGroupAISpecifyers.end() &amp;&amp; i &lt; max; speci++) {
+		gAISpecifyers[i] = *speci;
+		i++;
+	}
+	
+	return i;
+}
+const SGAILibrary* CInterface::LoadGroupAILibrary(const SGAISpecifyer* const gAISpecifyer) {
+	
+	SGAILibrary* ai = NULL;
+	
+	T_groupAIs::iterator groupAI;
+	groupAI = myLoadedGroupAIs.find(*gAISpecifyer);
+	if (groupAI == myLoadedGroupAIs.end()) {
+		//myLoadedGroupAIs[*gAISpecifyer] = Load(gAISpecifyer);
+		ai = new SGAILibrary;
+		SharedLib* lib = Load(gAISpecifyer, ai);
+		myLoadedGroupAIs[*gAISpecifyer] = ai;
+		myLoadedGroupAILibs[*gAISpecifyer] = lib;
+	} else {
+		ai = groupAI-&gt;second;
+	}
+	
+	return ai;
+}
+int CInterface::UnloadGroupAILibrary(const SGAISpecifyer* const gAISpecifyer) {
+	
+	T_groupAIs::iterator groupAI = myLoadedGroupAIs.find(*gAISpecifyer);
+	T_groupAILibs::iterator groupAILib = myLoadedGroupAILibs.find(*gAISpecifyer);
+	if (groupAI == myLoadedGroupAIs.end()) {
+		// to unload AI is not loaded -&gt; no problem, do nothing
+	} else {
+		delete groupAI-&gt;second;
+		myLoadedGroupAIs.erase(groupAI);
+		delete groupAILib-&gt;second;
+		myLoadedGroupAILibs.erase(groupAILib);
+	}
+	
+	return 0;
+}
+int CInterface::UnloadAllGroupAILibraries() {
+	
+	while (myLoadedGroupAIs.size() &gt; 0) {
+		UnloadGroupAILibrary(&amp;(myLoadedGroupAIs.begin()-&gt;first));
+	}
+	
+	return 0;
+}
+
+
+
+
+SharedLib* CInterface::Load(const SSAISpecifyer* const sAISpecifyer, SSAILibrary* skirmishAILibrary) {
+	return LoadSkirmishAILib(GenerateLibFilePath(*sAISpecifyer), skirmishAILibrary);
+}
+SharedLib* CInterface::LoadSkirmishAILib(const std::string&amp; libFilePath, SSAILibrary* skirmishAILibrary) {
+	
+	//reportError(std::string(&quot;CInterface::LoadSkirmishAILib libFilePath: &quot;) + libFilePath);
+	SharedLib* sharedLib = SharedLib::Instantiate(libFilePath);
+	
+	if (sharedLib == NULL) {
+		reportError(std::string(&quot;Failed loading shared library: &quot;) + libFilePath);
+	}
+	
+	// initialize the AI library
+	std::string funcName;
+	
+	funcName = &quot;getInfos&quot;;
+    skirmishAILibrary-&gt;getInfos = (int (CALLING_CONV *)(InfoItem[], int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (skirmishAILibrary-&gt;getInfos == NULL) {
+		// do nothing: this is permitted, if the AI supplies infos through an AIInfo.lua file
+		//reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;getOptions&quot;;
+    skirmishAILibrary-&gt;getOptions = (int (CALLING_CONV *)(Option*, int max)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (skirmishAILibrary-&gt;getOptions == NULL) {
+		// do nothing: this is permitted, if the AI supplies options through an AIOptions.lua file
+		//reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;getLevelOfSupportFor&quot;;
+    skirmishAILibrary-&gt;getLevelOfSupportFor = (LevelOfSupport (CALLING_CONV *)(const char*, int, const char*, const char*)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (skirmishAILibrary-&gt;getLevelOfSupportFor == NULL) {
+		// do nothing: it is permitted that an AI does not export this function
+		//reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;init&quot;;
+    skirmishAILibrary-&gt;init = (int (CALLING_CONV *)(int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (skirmishAILibrary-&gt;init == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;release&quot;;
+    skirmishAILibrary-&gt;release = (int (CALLING_CONV *)(int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (skirmishAILibrary-&gt;release == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;handleEvent&quot;;
+    skirmishAILibrary-&gt;handleEvent = (int (CALLING_CONV *)(int, int, const void*)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (skirmishAILibrary-&gt;handleEvent == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	return sharedLib;
+}
+
+
+SharedLib* CInterface::Load(const SGAISpecifyer* const gAISpecifyer, SGAILibrary* groupAILibrary) {
+	return LoadGroupAILib(GenerateLibFilePath(*gAISpecifyer), groupAILibrary);
+}
+SharedLib* CInterface::LoadGroupAILib(const std::string&amp; libFilePath, SGAILibrary* groupAILibrary) {
+	
+	SharedLib* sharedLib = SharedLib::Instantiate(libFilePath);
+	
+	// initialize the AI library
+	std::string funcName;
+	
+	funcName = &quot;getInfos&quot;;
+    groupAILibrary-&gt;getInfos = (int (CALLING_CONV *)(InfoItem[], int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (groupAILibrary-&gt;getInfos == NULL) {
+		// do nothing: this is permitted, if the AI supplies infos through an AIInfo.lua file
+		//reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;getLevelOfSupportFor&quot;;
+    groupAILibrary-&gt;getLevelOfSupportFor = (LevelOfSupport (CALLING_CONV *)(const char*, int, const char*, const char*)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (groupAILibrary-&gt;getLevelOfSupportFor == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;getOptions&quot;;
+    groupAILibrary-&gt;getOptions = (int (CALLING_CONV *)(Option*, int max)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (groupAILibrary-&gt;getOptions == NULL) {
+		// do nothing: this is permitted, if the AI supplies options through an AIOptions.lua file
+		//reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;init&quot;;
+    groupAILibrary-&gt;init = (int (CALLING_CONV *)(int, int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (groupAILibrary-&gt;init == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;release&quot;;
+    groupAILibrary-&gt;release = (int (CALLING_CONV *)(int, int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (groupAILibrary-&gt;release == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	funcName = &quot;handleEvent&quot;;
+    groupAILibrary-&gt;handleEvent = (int (CALLING_CONV *)(int, int, int, const void*)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (groupAILibrary-&gt;handleEvent == NULL) {
+		reportInterfaceFunctionError(libFilePath, funcName);
+    }
+	
+	return sharedLib;
+}
+
+
+void CInterface::reportInterfaceFunctionError(const std::string&amp; libFilePath, const std::string&amp; functionName) {
+	
+	std::string msg(&quot;Failed loading AI Library from file \&quot;&quot;);
+	msg += libFilePath + &quot;\&quot;: no \&quot;&quot; + functionName + &quot;\&quot; function exported&quot;;
+	reportError(msg);
+}
+
+void CInterface::reportError(const std::string&amp; msg) {
+	handleerror(NULL, msg.c_str(), &quot;C AI Interface Error&quot;, MBF_OK | MBF_EXCL);
+}
+
+
+std::string CInterface::GenerateLibFilePath(const SSAISpecifyer&amp; sAISpecifyer) {
+	
+/*
+	std::string libFileName = std::string(sAISpecifyer.shortName) // eg. RAI
+			.append(&quot;-&quot;)
+			.append(sAISpecifyer.version); // eg. 0.600
+#ifndef _WIN32
+	libFileName = &quot;lib&quot; + libFileName;
+#endif
+	return GenerateLibFilePath(std::string(PATH_TO_SPRING_HOME) +
+			SKIRMISH_AI_IMPLS_DIR, libFileName);
+*/
+	
+/*
+	std::string pattern(&quot;.*&quot;);
+	pattern.append(sAISpecifyer.shortName).append(&quot;.*&quot;);
+	pattern.append(sAISpecifyer.version).append(&quot;.*&quot;);
+	pattern.append(SharedLib::GetLibExtension());
+	
+	return FindFilesRegex(PATH_TO_SPRING_HOME&quot;&quot;SKIRMISH_AI_IMPLS_DIR, pattern).at(0);
+*/
+	static const std::string path = std::string(PATH_TO_SPRING_HOME&quot;&quot;SKIRMISH_AI_IMPLS_DIR&quot;/&quot;);
+	
+	T_skirmishAIFileNames::const_iterator fileName = mySkirmishAIFileNames.find(sAISpecifyer);
+	if (fileName == mySkirmishAIFileNames.end()) {
+		reportError(std::string(&quot;Missing Skirmish-AI file name for &quot;) + sAISpecifyer.shortName + &quot; &quot; + sAISpecifyer.version);
+	}
+	
+	std::string libFileName = fileName-&gt;second; // eg. RAI-0.600
+#ifndef _WIN32
+	libFileName = &quot;lib&quot; + libFileName; // eg. libRAI-0.600
+#endif
+	
+	libFileName.append(&quot;.&quot;); // eg. libRAI-0.600.
+	libFileName.append(SharedLib::GetLibExtension()); // eg. libRAI-0.600.so
+	
+	return path + libFileName;
+}
+
+std::string CInterface::GenerateLibFilePath(const SGAISpecifyer&amp; gAISpecifyer) {
+	
+	static const std::string path = std::string(PATH_TO_SPRING_HOME&quot;&quot;GROUP_AI_IMPLS_DIR&quot;/&quot;);
+	
+	T_groupAIFileNames::const_iterator fileName = myGroupAIFileNames.find(gAISpecifyer);
+	if (fileName == myGroupAIFileNames.end()) {
+		reportError(std::string(&quot;Missing Group-AI file name for &quot;) + gAISpecifyer.shortName + &quot; &quot; + gAISpecifyer.version);
+	}
+	
+	std::string libFileName = fileName-&gt;second; // eg. RAI-0.600
+#ifndef _WIN32
+	libFileName = &quot;lib&quot; + libFileName; // eg. libRAI-0.600
+#endif
+	
+	libFileName.append(&quot;.&quot;); // eg. libRAI-0.600.
+	libFileName.append(SharedLib::GetLibExtension()); // eg. libRAI-0.600.so
+	
+	return path + libFileName;
+}
+
+/*
+std::string CInterface::GenerateLibFilePath(const std::string&amp; basePath, const std::string&amp; libFileName) {
+	return std::string(basePath) // eg AI/Skirmish/impls
+			.append(&quot;/&quot;)
+			.append(libFileName) // eg. RAI-0.600
+			.append(&quot;.&quot;)
+			.append(SharedLib::GetLibExtension()); // eg. dll
+}
+*/
+
+SSAISpecifyer CInterface::extractSpecifyer(const SSAILibrary&amp; skirmishAILib) {
+	
+	SSAISpecifyer skirmishAISpecifyer;
+	
+	InfoItem infos[MAX_INFOS];
+	int numInfos =  skirmishAILib.getInfos(infos, MAX_INFOS);
+
+	std::string spsn = std::string(SKIRMISH_AI_PROPERTY_SHORT_NAME);
+	std::string spv = std::string(SKIRMISH_AI_PROPERTY_VERSION);
+	for (int i=0; i &lt; numInfos; ++i) {
+		std::string key = std::string(infos[i].key);
+		if (key == spsn) {
+			skirmishAISpecifyer.shortName = infos[i].value;
+		} else if (key == spv) {
+			skirmishAISpecifyer.version = infos[i].value;
+		}
+	}
+	
+	return skirmishAISpecifyer;
+}
+
+SGAISpecifyer CInterface::extractSpecifyer(const SGAILibrary&amp; groupAILib) {
+	
+	SGAISpecifyer groupAISpecifyer;
+	
+	InfoItem infos[MAX_INFOS];
+	int numInfos =  groupAILib.getInfos(infos, MAX_INFOS);
+
+	std::string spsn = std::string(GROUP_AI_PROPERTY_SHORT_NAME);
+	std::string spv = std::string(GROUP_AI_PROPERTY_VERSION);
+	for (int i=0; i &lt; numInfos; ++i) {
+		std::string key = std::string(infos[i].key);
+		if (key == spsn) {
+			groupAISpecifyer.shortName = infos[i].value;
+		} else if (key == spv) {
+			groupAISpecifyer.version = infos[i].value;
+		}
+	}
+	
+	return groupAISpecifyer;
+}
+
+std::vector&lt;std::string&gt; CInterface::FindDirs(const std::string&amp; path, const std::string&amp; pattern) {
+	
+	std::vector&lt;std::string&gt; found;
+
+	boost::regex regPattern(pattern, boost::regex::perl|boost::regex::icase);
+	boost::match_results&lt;std::string::const_iterator&gt; matchResult;
+	if (boost::filesystem::exists(path)) {
+		  boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
+		  for (boost::filesystem::directory_iterator itr(path); itr != end_itr; ++itr) {
+			  if (boost::filesystem::is_directory(*itr)
+					  &amp;&amp; boost::regex_match(itr-&gt;string(), matchResult, regPattern, boost::match_default) != 0
+					  &amp;&amp; matchResult[0].matched) {
+				  found.push_back(itr-&gt;string());
+			  }
+		  }
+	}
+	
+	return found;
+}
+
+std::vector&lt;std::string&gt; CInterface::FindFiles(const std::string&amp; path, const std::string&amp; fileExtension) {
+	
+	std::vector&lt;std::string&gt; found;
+
+	if (boost::filesystem::exists(path)) {
+		  boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
+		  for (boost::filesystem::directory_iterator itr(path); itr != end_itr; ++itr) {
+			  if (!boost::filesystem::is_directory(*itr)
+					  &amp;&amp; boost::filesystem::extension(*itr) == fileExtension) {
+				  found.push_back(itr-&gt;string());
+			  }
+		  }
+	}
+	
+	return found;
+}
+
+/*
+bool CInterface::FileExists(const std::string&amp; path, const std::string&amp; fileName) {
+	
+	boost::filesystem::path fullPath(path, fileName);
+	
+	return boost::filesystem::exists(fullPath);
+}
+*/
+
+std::vector&lt;std::string&gt; CInterface::FindFilesRegex(const std::string&amp; path, const std::string&amp; pattern) {
+	
+	std::vector&lt;std::string&gt; found;
+
+	boost::regex regPattern(pattern, boost::regex::perl|boost::regex::icase);
+	boost::match_results&lt;std::string::const_iterator&gt; matchResult;
+	if (boost::filesystem::exists(path)) {
+		  boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
+		  for (boost::filesystem::directory_iterator itr(path); itr != end_itr; ++itr) {
+			  if (!boost::filesystem::is_directory(*itr)
+					  &amp;&amp; boost::regex_match(itr-&gt;string(), matchResult, regPattern, boost::match_default) != 0
+					  &amp;&amp; matchResult[0].matched) {
+				  found.push_back(itr-&gt;string());
+			  }
+		  }
+	}
+	
+	return found;
+}
+
+bool CInterface::FitsThisInterface(const std::string&amp; requestedShortName, const std::string&amp; requestedVersion) {
+	
+	bool shortNameFits = false;
+	bool versionFits = false;
+	
+	InfoItem infos[MAX_INFOS];
+	int num = GetInfos(infos, MAX_INFOS);
+	
+	std::string shortNameKey(AI_INTERFACE_PROPERTY_SHORT_NAME);
+	std::string versionKey(AI_INTERFACE_PROPERTY_VERSION);
+    for (int i=0; i &lt; num; ++i) {
+		if (shortNameKey == infos[i].key) {
+			if (requestedShortName == infos[i].value) {
+				shortNameFits = true;
+			}
+		} else if (versionKey == infos[i].key) {
+			if (requestedVersion == infos[i].value) {
+				versionFits = true;
+			}
+		}
+    }
+	
+	return shortNameFits &amp;&amp; versionFits;
+}


Property changes on: branches/caiinterface/AI/Interfaces/C/Interface.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/C/Interface.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/Interface.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,102 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _INTERFACE_H
+#define _INTERFACE_H
+
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+#include &quot;ExternalAI/Interface/SGAILibrary.h&quot;
+
+#include &lt;map&gt;
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+enum LevelOfSupport;
+class SharedLib;
+
+class CInterface {
+public:
+	CInterface();
+    
+	// static properties
+	int GetInfos(InfoItem infos[], int max);
+	LevelOfSupport GetLevelOfSupportFor(
+			const char* engineVersion, int engineAIInterfaceGeneratedVersion);
+
+	// skirmish AI methods
+	int GetSkirmishAISpecifyers(SSAISpecifyer* sAISpecifyers, int max) const;
+	const SSAILibrary* LoadSkirmishAILibrary(const SSAISpecifyer* const sAISpecifyer);
+	int UnloadSkirmishAILibrary(const SSAISpecifyer* const sAISpecifyer);
+	int UnloadAllSkirmishAILibraries();
+
+	// group AI methods
+	int GetGroupAISpecifyers(SGAISpecifyer* gAISpecifyers, int max) const;
+	const SGAILibrary* LoadGroupAILibrary(const SGAISpecifyer* const gAISpecifyer);
+	int UnloadGroupAILibrary(const SGAISpecifyer* const gAISpecifyer);
+	int UnloadAllGroupAILibraries();
+	
+private:
+	// these functions actually load and unload the libraries
+	SharedLib* Load(const SSAISpecifyer* const sAISpecifyer, SSAILibrary* ai);
+	SharedLib* LoadSkirmishAILib(const std::string&amp; libFilePath, SSAILibrary* ai);
+	
+	SharedLib* Load(const SGAISpecifyer* const gAISpecifyer, SGAILibrary* ai);
+	SharedLib* LoadGroupAILib(const std::string&amp; libFilePath, SGAILibrary* ai);
+	
+	static void reportInterfaceFunctionError(const std::string&amp; libFileName, const std::string&amp; functionName);
+	static void reportError(const std::string&amp; msg);
+	std::string GenerateLibFilePath(const SSAISpecifyer&amp; sAISpecifyer);
+	std::string GenerateLibFilePath(const SGAISpecifyer&amp; gAISpecifyer);
+	//static std::string GenerateLibFilePath(const std::string&amp; basePath, const std::string&amp; libFileName);
+#define MAX_INFOS 128
+	static SSAISpecifyer extractSpecifyer(const SSAILibrary&amp; skirmishAILib);
+	static SGAISpecifyer extractSpecifyer(const SGAILibrary&amp; groupAILib);
+	
+	static std::vector&lt;std::string&gt; FindDirs(const std::string&amp; path, const std::string&amp; pattern = &quot;.*&quot;);
+	/**
+	 * Searches non-recursively for files under path, with a given file extension.
+	 * The fileExtension you supplied have to contain the '.' as well, it will not be prepended.
+	 */
+	static std::vector&lt;std::string&gt; FindFiles(const std::string&amp; path, const std::string&amp; fileExtension);
+	//static bool FileExists(const std::string&amp; path, const std::string&amp; fileName);
+	static std::vector&lt;std::string&gt; FindFilesRegex(const std::string&amp; path, const std::string&amp; pattern);
+	
+	bool FitsThisInterface(const std::string&amp; requestedShortName, const std::string&amp; requestedVersion);
+	void errorMsgFileNames(const std::string&amp; additionalTxt = &quot;&quot;) const;
+private:
+//	std::map&lt;std::string, std::string&gt; myProperties;
+	std::vector&lt;InfoItem&gt; myInfos;
+	
+	std::vector&lt;SSAISpecifyer&gt; mySkirmishAISpecifyers;
+	typedef std::map&lt;SSAISpecifyer, std::string, SSAISpecifyer_Comparator&gt; T_skirmishAIFileNames;
+	T_skirmishAIFileNames mySkirmishAIFileNames;
+	typedef std::map&lt;SSAISpecifyer, SSAILibrary*, SSAISpecifyer_Comparator&gt; T_skirmishAIs;
+	T_skirmishAIs myLoadedSkirmishAIs;
+	typedef std::map&lt;SSAISpecifyer, SharedLib*, SSAISpecifyer_Comparator&gt; T_skirmishAILibs;
+	T_skirmishAILibs myLoadedSkirmishAILibs;
+	
+	std::vector&lt;SGAISpecifyer&gt; myGroupAISpecifyers;
+	typedef std::map&lt;SGAISpecifyer, std::string, SGAISpecifyer_Comparator&gt; T_groupAIFileNames;
+	T_groupAIFileNames myGroupAIFileNames;
+	typedef std::map&lt;SGAISpecifyer, SGAILibrary*, SGAISpecifyer_Comparator&gt; T_groupAIs;
+	T_groupAIs myLoadedGroupAIs;
+	typedef std::map&lt;SGAISpecifyer, SharedLib*, SGAISpecifyer_Comparator&gt; T_groupAILibs;
+	T_groupAILibs myLoadedGroupAILibs;
+};
+
+#endif	/* _INTERFACE_H */
+


Property changes on: branches/caiinterface/AI/Interfaces/C/Interface.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,171 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;InterfaceExport.h&quot;
+
+#include &quot;Interface.h&quot;
+
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+/*
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+#include &quot;ExternalAI/Interface/SGAILibrary.h&quot;
+*/
+
+/*
+If we do not have an init() method, then we would instead pass
+an event InitEvent to handleEvent. However, we would have to make
+handleEvent have to wait for an InitEvent as a special case, since
+the team in question would not yet exist. 
+
+Therefore, the handleEvent code would look like this:
+[code]
+SHARED_EXPORT int handleEvent(int team, int eventID, void* event) {
+    if (eventID == INIT_EVENT) {
+        ais[team] = CAIObject();
+    }
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team].handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}
+[/code]
+Advantages:
+* All events to AI go through handleEvent.
+* People don't get confused and start adding bananaSplitz() functions.
+
+Disadvantages:
+* We need to check for INIT_EVENT before *every message*.
+* These events will happen only once per game -- after that the check becomes a necessary waste of time.
+* Handling events is no longer about getting the right object to deal with an event, it also includes initialising object properly.
+
+I understand that we want to keep the interface simple. In fact,
+I think we should keep it as minimal as possible, and ideally everything
+would go through handleEvent. Practically though, it does not make sense
+to do this: we'll be wasting our own time for no good reason in the
+case of initialisation. 
+
+The (in my opinion much cleaner) alternative is the one I've implemented.
+Advantages:
+* One function that initialises a team before everything is passed to handlEvent
+* No redundant if statements.
+* Simple design.
+
+Disadvantage:
+* People might start adding other functions to the interface.
+
+I don't think that the disadvantage is a real one: it's pretty standard to 
+see initialisation as a special case. It's pretty clear that everything
+else goes through handleEvent. 
+
+The advantage is clear: a more efficient, simpler design. Of course, you could
+argue that the efficiency is nominal, one extra if per event is very little cost,
+and granted, that's true; but this doesn't change the fact that we're checking
+for a special case that we know only happens once at the beginning of the game, before
+every single event after.
+
+Of course, we still need an INIT_EVENT, since initialising the existance of a team
+member is not the same as initialising its state.
+
+You might also argue that we do this check in the handleEvent switch within each
+team. This is true, although the difference there is that a switch is translated
+to address lookups and so there is no increase in cost if there are more switch
+cases. 
+*/
+
+// AI Interface vars
+/*
+const char* const myProperties[][2] = {
+	{AI_INTERFACE_PROPERTY_SHORT_NAME, &quot;C&quot;},
+	{AI_INTERFACE_PROPERTY_VERSION, &quot;0.1&quot;},
+	{AI_INTERFACE_PROPERTY_NAME, &quot;C &amp; C++&quot;},
+	{AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in C or C++.&quot;},
+	{AI_INTERFACE_PROPERTY_URL, &quot;<A HREF="http://sy.spring.com/Wiki/CInterface">http://sy.spring.com/Wiki/CInterface</A>&quot;},
+	{&quot;supportedLanguages&quot;, &quot;C, C++&quot;}
+};
+const int numMyProperties = 6;
+*/
+
+
+/*
+// Skirmish AI vars
+const struct SSAISpecifyer* mySAISpecifyers = NULL;
+const int numMySAISpecifyers;
+
+const struct SSAILibrary* mySAILibraries;
+const int numMySAILibraries;
+
+
+// Group AI vars
+const struct SGAISpecifyer* myGAISpecifyers = NULL;
+const int numMyGAISpecifyers;
+
+const struct SGAILibrary* myGAILibraries;
+const int numMyGAILibraries;
+*/
+
+CInterface myInterface;
+
+/*
+#include &quot;stdio.h&quot;
+*/
+//#include &quot;&lt;iostream&gt;&quot;
+
+Export(int) getInfos(InfoItem infos[], int max) {
+/*
+	printf(&quot;in getProperties here.&quot;);
+*/
+	return myInterface.GetInfos(infos, max);
+}
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersion, int engineAIInterfaceGeneratedVersion) {
+	return myInterface.GetLevelOfSupportFor(engineVersion, engineAIInterfaceGeneratedVersion);
+}
+
+
+// skirmish AI methods
+Export(int) getSkirmishAISpecifyers(struct SSAISpecifyer* sAISpecifyers, int max) {
+	return myInterface.GetSkirmishAISpecifyers(sAISpecifyers, max);
+}
+Export(const struct SSAILibrary*) loadSkirmishAILibrary(const struct SSAISpecifyer* const sAISpecifyer) {
+	return myInterface.LoadSkirmishAILibrary(sAISpecifyer);
+}
+Export(int) unloadSkirmishAILibrary(const struct SSAISpecifyer* const sAISpecifyer) {
+	return myInterface.UnloadSkirmishAILibrary(sAISpecifyer);
+}
+Export(int) unloadAllSkirmishAILibraries() {
+	return myInterface.UnloadAllSkirmishAILibraries();
+}
+
+
+
+// group AI methods
+Export(int) getGroupAISpecifyers(struct SGAISpecifyer* gAISpecifyers, int max) {
+	return myInterface.GetGroupAISpecifyers(gAISpecifyers, max);
+}
+Export(const struct SGAILibrary*) loadGroupAILibrary(const struct SGAISpecifyer* const gAISpecifyer) {
+	return myInterface.LoadGroupAILibrary(gAISpecifyer);
+}
+Export(int) unloadGroupAILibrary(const struct SGAISpecifyer* const gAISpecifyer) {
+	return myInterface.UnloadGroupAILibrary(gAISpecifyer);
+}
+Export(int) unloadAllGroupAILibraries() {
+	return myInterface.UnloadAllGroupAILibraries();
+}
+


Property changes on: branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,66 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _INTERFACEEXPORT_H
+#define _INTERFACEEXPORT_H
+
+#if	!defined BUILDING_AI_INTERFACE
+#error BUILDING_AI_INTERFACE should be defined when building AI interfaces
+#endif
+#if	defined BUILDING_AI
+#error BUILDING_AI should not be defined when building AI interfaces
+#endif
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+struct InfoItem;
+struct SSAISpecifyer;
+struct SSAILibrary;
+struct SGAISpecifyer;
+struct SGAILibrary;
+
+// for a list of the functions that have to be exported,
+// see struct SAIInterfaceLibrary in &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+
+// static interface library methods
+Export(int) getInfos(InfoItem infos[], int max); // static properties
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersion, int engineAIInterfaceGeneratedVersion);
+	
+// skirmish AI methods
+Export(int) getSkirmishAISpecifyers(struct SSAISpecifyer* sAISpecifyers, int max);
+Export(const struct SSAILibrary*) loadSkirmishAILibrary(const struct SSAISpecifyer* const sAISpecifyer);
+Export(int) unloadSkirmishAILibrary(const struct SSAISpecifyer* const sAISpecifyer);
+Export(int) unloadAllSkirmishAILibraries();
+	
+// group AI methods
+Export(int) getGroupAISpecifyers(struct SGAISpecifyer* gAISpecifyers, int max);
+Export(const struct SGAILibrary*) loadGroupAILibrary(const struct SGAISpecifyer* const gAISpecifyer);
+Export(int) unloadGroupAILibrary(const struct SGAISpecifyer* const gAISpecifyer);
+Export(int) unloadAllGroupAILibraries();
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _INTERFACEEXPORT_H */
+


Property changes on: branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,47 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the AI_INTERFACE_PROPERTY_* defines in
+--            SAIInterfaceLibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'shortName',
+		value  = 'C',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'name',
+		value  = 'default C AI Interface',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'This interface is needed for C and C++ AIs',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AIInterface:C">http://spring.clan-sy.com/wiki/AIInterface:C</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'supportedLanguages',
+		value  = 'C, C++',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/C/README
===================================================================
--- branches/caiinterface/AI/Interfaces/C/README	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/README	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1 @@
+All these files will not be linked into the engine, but to a separate shared library.


Property changes on: branches/caiinterface/AI/Interfaces/C/README
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Interfaces/CMakeLists.txt	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,20 @@
+
+### AI Interfaces
+## This section will only contain the C AI interface most likely,
+## as all the other ones will need special libraries to compile and link,
+## which not everyone will have installed.
+#add_definitions(-DBUILDING_AI_INTERFACE -DSTREFLOP_X87)
+add_definitions(-DBUILDING_AI_INTERFACE)
+
+aux_source_directory(C cAIInterface)
+list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/SharedLib)
+if (UNIX)
+	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Linux/SoLib)
+else (UNIX)
+	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Win/DllLib)
+endif (UNIX)
+add_library(C-0.1 SHARED ${cAIInterface} ${aienv} ${luaparsingenv})
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Interfaces/C/InterfaceInfo.lua DESTINATION ${DATADIR}/AI/Interfaces/data/C-0.1)
+
+install (TARGETS C-0.1 DESTINATION ${DATADIR}/AI/Interfaces/impls)
+


Property changes on: branches/caiinterface/AI/Interfaces/CMakeLists.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish (from rev 6207, branches/caiinterface/AI/Global)

Copied: branches/caiinterface/AI/Skirmish/AAI (from rev 6207, branches/caiinterface/AI/Global/AAI)


Property changes on: branches/caiinterface/AI/Skirmish/AAI
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Skirmish/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Skirmish/CMakeLists.txt	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,55 @@
+
+### Skirmish AIs
+#remove_definitions(-DBUILDING_AI_INTERFACE -DSTREFLOP_X87 -DSTREFLOP_SSE -DSTREFLOP_SOFT)
+add_definitions(-DBUILDING_AI)
+
+aux_source_directory(KAI-0.2 kai02)
+#add_library(KAI-0.2 SHARED ${kai02} ${legacycppaienv} ${creg})
+
+aux_source_directory(KAIK-0.13 kaik013)
+add_library(KAIK-0.13 SHARED ${kaik013} ${legacycppaienv} ${creg})
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/KAIK-0.13)
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/KAIK-0.13/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/KAIK-0.13)
+
+aux_source_directory(RAI-0.553 rai)
+add_library(RAI-0.553 SHARED ${rai} ${legacycppaienv} RAI-0.553/KrogsMetalClass/MetalMap)
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/RAI-0.553)
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/RAI-0.553/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/RAI-0.553)
+
+aux_source_directory(AAI aai)
+#add_library(AAI SHARED ${aai} ${legacycppaienv})
+
+aux_source_directory(NTai/AI/NTai/Units ntai)
+aux_source_directory(NTai/AI/NTai/Units/Behaviours ntai)
+aux_source_directory(NTai/AI/NTai/Tasks ntai)
+aux_source_directory(NTai/AI/NTai/Helpers ntai)
+aux_source_directory(NTai/AI/NTai/Helpers/grid ntai)
+aux_source_directory(NTai/AI/NTai/Helpers/Terrain ntai)
+aux_source_directory(NTai/AI/NTai/Helpers/Units ntai)
+aux_source_directory(NTai/AI/NTai/Engine ntai)
+aux_source_directory(NTai/AI/NTai/Core ntai)
+aux_source_directory(NTai/AI/NTai/Agents ntai)
+#add_library(NTai SHARED ${ntai} ${legacycppaienv})
+#target_link_libraries(NTai boost_thread-mt)
+
+#aux_source_directory(TestGlobalAI testai)
+#add_library(TestGlobalAI SHARED ${testai} ${legacycppaienv})
+
+aux_source_directory(NullAI nullai)
+add_library(NullAI-0.1 SHARED ${nullai}  ${legacycppaienv})
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/AIInfo.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NullAI-0.1)
+install (FILES ${CMAKE_SOURCE_DIR}/AI/Skirmish/NullAI/AIOptions.lua DESTINATION ${DATADIR}/AI/Skirmish/data/NullAI-0.1)
+
+if (UNIX)
+	# doesn't build in win32currently
+	aux_source_directory(JCAI jcai)
+#	add_library(JCAI SHARED ${jcai} ${legacycppaienv})
+endif (UNIX)
+
+if (UNIX)
+#	install (TARGETS KAIK-0.13 KAI-0.2 RAI-0.553 AAI NTai TestGlobalAI NullAI-0.1 JCAI DESTINATION ${DATADIR}/AI/Skirmish/impls)
+else (UNIX)
+#	install (TARGETS KAIK-0.13 KAI-0.2 RAI-0.553 AAI NTai TestGlobalAI NullAI-0.1 DESTINATION ${DATADIR}/AI/Skirmish/impls)
+endif (UNIX)
+install (TARGETS KAIK-0.13 RAI-0.553 NullAI-0.1 DESTINATION ${DATADIR}/AI/Skirmish/impls)
+


Property changes on: branches/caiinterface/AI/Skirmish/CMakeLists.txt
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/CSAI (from rev 6207, branches/caiinterface/AI/Global/CSAI)


Property changes on: branches/caiinterface/AI/Skirmish/CSAI
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/AbicProxy.h
===================================================================
--- branches/caiinterface/AI/Global/CSAI/ABICompatibilityLayer/AbicProxy.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/AbicProxy.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -45,9 +45,9 @@
 using namespace std;
 
 #ifdef WIN32
-	#define AILOG_PATH &quot;AI\\Bot-libs\\&quot;
+	#define AILOG_PATH &quot;AI\\Skirmish/impls\\&quot;
 #else
-	#define AILOG_PATH &quot;AI/Bot-libs/&quot;
+	#define AILOG_PATH &quot;AI/Skirmish/impls/&quot;
 #endif
 
 class AbicProxy : public ::IGlobalAI  

Modified: branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.cpp
===================================================================
--- branches/caiinterface/AI/Global/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -21,9 +21,21 @@
 /**
  * Does a FreeLibrary on the given DLL
  */
+void DllLib::Unload() {
+	
+	if (dll != NULL) {
+		FreeLibrary(dll);
+		dll = NULL;
+	}
+}
+
+bool DllLib::LoadFailed() {
+	return dll == NULL;
+}
+
 DllLib::~DllLib()
 {
-	FreeLibrary(dll);
+	Unload();
 }
 
 /**

Modified: branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.h
===================================================================
--- branches/caiinterface/AI/Global/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win/DllLib.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -28,7 +28,16 @@
 	 */
 	DllLib(const char *filename);
 	
+	
 	/**
+	 * Frees the dll
+	 * @brief unload
+	 */
+	virtual void Unload();
+	
+	virtual bool LoadFailed();
+	
+	/**
 	 * @brief Destructor
 	 */
 	~DllLib();

Modified: branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/buildabic.bat
===================================================================
--- branches/caiinterface/AI/Global/CSAI/ABICompatibilityLayer/buildabic.bat	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/buildabic.bat	2008-10-01 18:03:35 UTC (rev 6494)
@@ -51,4 +51,4 @@
 dllwrap --driver-name g++ --dllname %ABICDLLNAME% %OBJECTS% --output-def abicdef.def
 
 copy /y GlobalAIInterfaces.dll %SPRINGAPPLICATION%
-copy /y %ABICDLLNAME% &quot;%SPRINGAPPLICATION%\AI\Bot-libs&quot;
+copy /y %ABICDLLNAME% &quot;%SPRINGAPPLICATION%\AI\Skirmish/impls&quot;

Modified: branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/buildabic_obsolete_for_spring_in_msvc.bat
===================================================================
--- branches/caiinterface/AI/Global/CSAI/ABICompatibilityLayer/buildabic_obsolete_for_spring_in_msvc.bat	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/ABICompatibilityLayer/buildabic_obsolete_for_spring_in_msvc.bat	2008-10-01 18:03:35 UTC (rev 6494)
@@ -48,4 +48,4 @@
 link /dll /out:%ABICDLLNAME% %OBJECTS%
 
 copy /y CSAIInterfaces.dll %SPRINGAPPLICATION%
-copy /y %ABICDLLNAME% &quot;%SPRINGAPPLICATION%\AI\Bot-libs&quot;
+copy /y %ABICDLLNAME% &quot;%SPRINGAPPLICATION%\AI\Skirmish/impls&quot;

Modified: branches/caiinterface/AI/Skirmish/CSAI/CSAI2/CSAI2.csproj
===================================================================
--- branches/caiinterface/AI/Global/CSAI/CSAI2/CSAI2.csproj	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/CSAI2/CSAI2.csproj	2008-10-01 18:03:35 UTC (rev 6494)
@@ -46,7 +46,7 @@
   &lt;PropertyGroup Condition=&quot; '$(Configuration)|$(Platform)' == 'Release|AnyCPU' &quot;&gt;
     &lt;DebugType&gt;pdbonly&lt;/DebugType&gt;
     &lt;Optimize&gt;true&lt;/Optimize&gt;
-    &lt;OutputPath&gt;..\..\..\..\game\AI\Bot-libs\&lt;/OutputPath&gt;
+    &lt;OutputPath&gt;..\..\..\..\game\AI\Skirmish/impls\&lt;/OutputPath&gt;
     &lt;DefineConstants&gt;TRACE&lt;/DefineConstants&gt;
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
     &lt;WarningLevel&gt;4&lt;/WarningLevel&gt;

Modified: branches/caiinterface/AI/Skirmish/CSAI/CSAILoader/CSAILoader.build
===================================================================
--- branches/caiinterface/AI/Global/CSAI/CSAILoader/CSAILoader.build	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/CSAILoader/CSAILoader.build	2008-10-01 18:03:35 UTC (rev 6494)
@@ -77,7 +77,7 @@
    &lt;/target&gt;
    
    &lt;target name=&quot;deploy&quot; depends=&quot;link&quot;&gt;
-      &lt;copy todir=&quot;${taspring.applicationdirectory}/AI/Bot-libs&quot;&gt;
+      &lt;copy todir=&quot;${taspring.applicationdirectory}/AI/Skirmish/impls&quot;&gt;
           &lt;fileset&gt;
               &lt;include name=&quot;CSAILoader.dll&quot; /&gt;
               &lt;include name=&quot;CSAILoader.xml&quot; /&gt;

Modified: branches/caiinterface/AI/Skirmish/CSAI/CSAILoader/CSAIProxy.h
===================================================================
--- branches/caiinterface/AI/Global/CSAI/CSAILoader/CSAIProxy.h	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/CSAILoader/CSAIProxy.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -48,9 +48,9 @@
 using namespace std;
 
 #ifdef WIN32
-	#define AILOG_PATH &quot;AI\\Bot-libs\\&quot;
+	#define AILOG_PATH &quot;AI\\Skirmish/impls\\&quot;
 #else
-	#define AILOG_PATH &quot;AI/Bot-libs/&quot;
+	#define AILOG_PATH &quot;AI/Skirmish/impls/&quot;
 #endif
 
 struct AbicAICallbackWrapper;

Modified: branches/caiinterface/AI/Skirmish/CSAI/MonoLoader/build.bat
===================================================================
--- branches/caiinterface/AI/Global/CSAI/MonoLoader/build.bat	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/MonoLoader/build.bat	2008-10-01 18:03:35 UTC (rev 6494)
@@ -43,6 +43,6 @@
 g++ -DBUILDING_AI -DSTREFLOP_X87=1 %CCOPTIONS% -c CSAILoaderMono.cpp
 dllwrap --driver-name g++ -o csailoadermono.dll CSAILoaderMono.o %LINKOPTIONS%
 
-copy /y CSAILoaderMono.dll &quot;%SPRINGAPPLICATION%\AI\Bot-libs&quot;
+copy /y CSAILoaderMono.dll &quot;%SPRINGAPPLICATION%\AI\Skirmish/impls&quot;
 
 

Modified: branches/caiinterface/AI/Skirmish/CSAI/readme.txt
===================================================================
--- branches/caiinterface/AI/Global/CSAI/readme.txt	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/readme.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -38,7 +38,7 @@
 - csaiabic.dll will load csailoader.dll
 - csailoader.dll should have a C interface conform to what the ABIC layer is expecting
 
-There are copied into root of game\AI\Bot-libs bot-libs directory
+There are copied into root of game\AI\Skirmish/impls bot-libs directory
 
 3. abicwrappers
 

Modified: branches/caiinterface/AI/Skirmish/CSAI/setup.cs
===================================================================
--- branches/caiinterface/AI/Global/CSAI/setup.cs	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/CSAI/setup.cs	2008-10-01 18:03:35 UTC (rev 6494)
@@ -42,8 +42,8 @@
         &quot;CSAIInterfaces/CSAIInterfaces.pdb&quot;, &quot;&quot;,
         &quot;CSAI/CSAI.dll&quot;, &quot;AI/CSAI&quot;,
         &quot;CSAI/CSAI.pdb&quot;, &quot;AI/CSAI&quot;, 
-        &quot;CSAILoader/csailoader.dll&quot;, &quot;AI/Bot-libs&quot;,
-        &quot;CSAILoader/csailoader.xml&quot;, &quot;AI/Bot-libs&quot; };
+        &quot;CSAILoader/csailoader.dll&quot;, &quot;AI/Skirmish/impls&quot;,
+        &quot;CSAILoader/csailoader.xml&quot;, &quot;AI/Skirmish/impls&quot; };
     
     string GetSpringInstallDirectory()
     {

Copied: branches/caiinterface/AI/Skirmish/JCAI (from rev 6207, branches/caiinterface/AI/Global/JCAI)


Property changes on: branches/caiinterface/AI/Skirmish/JCAI
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: branches/caiinterface/AI/Skirmish/JCAI/GlobalAI.cpp
===================================================================
--- branches/caiinterface/AI/Global/JCAI/GlobalAI.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/JCAI/GlobalAI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -19,7 +19,7 @@
 #include &quot;SupportHandler.h&quot;
 #include &quot;ReconHandler.h&quot;
 
-#include &quot;Sim/Units/UnitHandler.h&quot; // for MAX_UNITS
+//#include &quot;Sim/Units/UnitHandler.h&quot; // for MAX_UNITS
 
 #include &quot;DebugWindow.h&quot;
 
@@ -313,6 +313,13 @@
 	if (aiConfig.showDebugWindow)
 		InitDebugWindow();
 
+	int MAX_UNITS = -1;
+	bool valueFetchOk = cb-&gt;GetValue(AIVAL_UNIT_LIMIT, &amp;MAX_UNITS);
+	if (!valueFetchOk) {
+		ChatMsgPrintf(cb, &quot;Failed to fetch unit limit (AIVAL_UNIT_LIMIT)&quot;);
+		return;
+	}
+	
 	unitDefs = new const UnitDef*[MAX_UNITS];
 	for (int a=0;a&lt;MAX_UNITS;a++) unitDefs[a]=0;
 }

Copied: branches/caiinterface/AI/Skirmish/KAI-0.2 (from rev 6207, branches/caiinterface/AI/Global/KAI-0.2)


Property changes on: branches/caiinterface/AI/Skirmish/KAI-0.2
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: branches/caiinterface/AI/Skirmish/KAIK-0.13 (from rev 6207, branches/caiinterface/AI/Global/KAIK-0.13)


Property changes on: branches/caiinterface/AI/Skirmish/KAIK-0.13
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,43 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIEXPORT_H
+#define _AIEXPORT_H
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+
+struct InfoItem;
+struct Option;
+
+// for a list of the functions that have to be exported,
+// see struct SSAILibrary in &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+// static AI library methods
+Export(int) getInfos(InfoItem infos[], int max); // static properties
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+Export(int) getOptions(struct Option options[], int max);
+
+// team instance functions
+Export(int) init(int teamId);
+Export(int) release(int teamId);
+Export(int) handleEvent(int teamId, int topic, const void* data);
+
+#endif /* _AIEXPORT_H */
+


Property changes on: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExports.cpp
===================================================================
--- branches/caiinterface/AI/Global/KAIK-0.13/AIExports.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/KAIK-0.13/AIExports.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,5 +1,14 @@
+#include &quot;AIExport.h&quot;
+
+#include &lt;map&gt;
+
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AI.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h&quot;
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
 #include &quot;GlobalAI.h&quot;
 
+/*
 std::set&lt;IGlobalAI*&gt; ais;
 
 
@@ -35,3 +44,93 @@
 DLL_EXPORT int IsLoadSupported() {
 	return 1;
 }
+*/
+
+
+std::map&lt;int, CAI*&gt; ais;
+std::vector&lt;InfoItem&gt; myInfos;
+
+int getInfos(InfoItem infos[], int max) {
+	
+	int i = 0;
+	
+	// initialize the myInfos
+	if (myInfos.empty()) {
+		InfoItem ii_0 = {SKIRMISH_AI_PROPERTY_SHORT_NAME, &quot;KAIK&quot;, NULL}; myInfos.push_back(ii_0);
+		InfoItem ii_1 = {SKIRMISH_AI_PROPERTY_VERSION, &quot;0.13&quot;, NULL}; myInfos.push_back(ii_1);
+		InfoItem ii_2 = {SKIRMISH_AI_PROPERTY_NAME, &quot;Kloots Skirmish AI&quot;, NULL}; myInfos.push_back(ii_2);
+		InfoItem ii_3 = {SKIRMISH_AI_PROPERTY_DESCRIPTION, &quot;This Skirmish AI supports most TA based mods and plays decently.&quot;, NULL}; myInfos.push_back(ii_3);
+		InfoItem ii_4 = {SKIRMISH_AI_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AI:KAIK">http://spring.clan-sy.com/wiki/AI:KAIK</A>&quot;, NULL}; myInfos.push_back(ii_4);
+		InfoItem ii_5 = {SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED, &quot;no&quot;, NULL}; myInfos.push_back(ii_5);
+	}
+	
+	// copy myInfos to the argument container infos
+	std::vector&lt;InfoItem&gt;::const_iterator inf;
+	for (inf=myInfos.begin(); inf!=myInfos.end() &amp;&amp; i &lt; max; inf++) {
+		infos[i] = *inf;
+		i++;
+	}
+
+	// return the number of key-value pairs copied into properties
+	return i;
+}
+
+enum LevelOfSupport getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
+	
+	if (strcmp(engineVersionString, ENGINE_VERSION_STRING) == 0 &amp;&amp;
+			engineVersionNumber &lt;= ENGINE_VERSION_NUMBER) {
+		return LOS_Working;
+	}
+	
+	return LOS_None;
+}
+
+int getOptions(struct Option options[], int max) {
+	return 0;
+}
+
+// Since this is a C interface, we can only be told by the engine
+// to set up an AI with the number team that indicates a receiver
+// of any handleEvent() call.
+Export(int) init(int teamId) {
+    // the map already has an AI for this team.
+    // raise an error, since it's probably a mistake if we're trying
+    // reinitialise a team that's already had init() called on it.
+    if (ais.count(teamId) &gt; 0) {
+        return -1;
+    }
+    //TODO:
+    // Change the line below so that CAI is 
+    // your AI, which should be a subclass of CAI that
+    // overrides the handleEvent() method.
+    ais[teamId] = new CAIGlobalAI(teamId, new CGlobalAI());
+	
+	return 0;
+}
+
+Export(int) release(int teamId) {
+    // the map has no AI for this team.
+    // raise an error, since it's probably a mistake if we're trying to
+    // release a team that's not initialized.
+    if (ais.count(teamId) == 0) {
+        return -1;
+    }
+	
+    delete ais[teamId];
+	ais.erase(teamId);
+	
+	return 0;
+}
+
+Export(int) handleEvent(int teamId, int topic, const void* data) {
+    // events sent to team -1 will always be to the AI object itself,
+    // not to a particular team.
+    if (ais.count(teamId) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[teamId]-&gt;handleEvent(topic, data);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}

Added: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK-0.13/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK-0.13/AIInfo.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'KAIK-0.13',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'KAIK',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.13',
+	},
+	{
+		key    = 'name',
+		value  = 'Kloots Skirmish AI (KAIK)',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'Competetive AI that supports most TA based Mods and plays decently.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:KAIK">http://spring.clan-sy.com/wiki/AI:KAIK</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIInfo.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK-0.13/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK-0.13/AIOptions.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/KAIK-0.13/AIOptions.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/NTai (from rev 6207, branches/caiinterface/AI/Global/NTai)


Property changes on: branches/caiinterface/AI/Skirmish/NTai
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/AI.vcproj
===================================================================
--- branches/caiinterface/AI/Global/NTai/AI/AI.vcproj	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/AI.vcproj	2008-10-01 18:03:35 UTC (rev 6494)
@@ -58,7 +58,7 @@
 			/&gt;
 			&lt;Tool
 				Name=&quot;VCLinkerTool&quot;
-				OutputFile=&quot;..\..\..\..\game\AI\Bot-libs\$(ProjectName)-debug.dll&quot;
+				OutputFile=&quot;..\..\..\..\game\AI\Skirmish/impls\$(ProjectName)-debug.dll&quot;
 				AdditionalLibraryDirectories=&quot;..\..\..\..\vclibs\Boost\lib&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				LargeAddressAware=&quot;2&quot;
@@ -131,7 +131,7 @@
 			/&gt;
 			&lt;Tool
 				Name=&quot;VCLinkerTool&quot;
-				OutputFile=&quot;..\..\..\..\game\AI\Bot-libs\$(ProjectName)-release.dll&quot;
+				OutputFile=&quot;..\..\..\..\game\AI\Skirmish/impls\$(ProjectName)-release.dll&quot;
 				AdditionalLibraryDirectories=&quot;..\..\..\..\vclibs\Boost\lib&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				OptimizeReferences=&quot;2&quot;
@@ -205,7 +205,7 @@
 			/&gt;
 			&lt;Tool
 				Name=&quot;VCLinkerTool&quot;
-				OutputFile=&quot;..\..\..\..\game\AI\Bot-libs\$(ProjectName)-release-ecatch.dll&quot;
+				OutputFile=&quot;..\..\..\..\game\AI\Skirmish/impls\$(ProjectName)-release-ecatch.dll&quot;
 				AdditionalLibraryDirectories=&quot;..\..\..\..\vclibs\Boost\lib&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				AssemblyDebug=&quot;2&quot;

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/dll.cbp
===================================================================
--- branches/caiinterface/AI/Global/NTai/AI/dll.cbp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/dll.cbp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -8,7 +8,7 @@
 		&lt;Option compiler=&quot;gcc&quot; /&gt;
 		&lt;Build&gt;
 			&lt;Target title=&quot;default&quot;&gt;
-				&lt;Option output=&quot;~/.spring/AI/Bot-libs/NTaiAI&quot; prefix_auto=&quot;0&quot; extension_auto=&quot;1&quot; /&gt;
+				&lt;Option output=&quot;~/.spring/AI/Skirmish/impls/NTaiAI&quot; prefix_auto=&quot;0&quot; extension_auto=&quot;1&quot; /&gt;
 				&lt;Option type=&quot;3&quot; /&gt;
 				&lt;Option compiler=&quot;gcc&quot; /&gt;
 				&lt;Option host_application=&quot;/usr/local/games/spring&quot; /&gt;

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/nbproject/private/private.xml
===================================================================
--- branches/caiinterface/AI/Global/NTai/AI/nbproject/private/private.xml	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/nbproject/private/private.xml	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,4 +1,4 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;project-private xmlns=&quot;<A HREF="http://www.netbeans.org/ns/project-private/1">http://www.netbeans.org/ns/project-private/1</A>&quot;&gt;
-    &lt;editor-bookmarks xmlns=&quot;<A HREF="http://www.netbeans.org/ns/editor-bookmarks/1">http://www.netbeans.org/ns/editor-bookmarks/1</A>&quot;/&gt;
-&lt;/project-private&gt;
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;project-private xmlns=&quot;<A HREF="http://www.netbeans.org/ns/project-private/1">http://www.netbeans.org/ns/project-private/1</A>&quot;&gt;
+    &lt;editor-bookmarks xmlns=&quot;<A HREF="http://www.netbeans.org/ns/editor-bookmarks/1">http://www.netbeans.org/ns/editor-bookmarks/1</A>&quot;/&gt;
+&lt;/project-private&gt;

Added: branches/caiinterface/AI/Skirmish/NullAI/AI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,106 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+/*
+#include &quot;AI.h&quot;
+#include &quot;Event/AIEvents.h&quot;
+#include &quot;ExternalAI/Interface/AISEvents.h&quot;
+
+CAI::CAI() : team(0) { 
+	
+}
+
+
+CAI::CAI(int team) : team(team) {
+	
+}
+
+int CAI::handleEvent(int eventID, void* event) {
+	CAIEvent* e;
+	switch(eventID) {
+		case EVENT_NULL:
+			e = new CAINullEvent();
+			break;
+		case EVENT_INIT:
+			e = new CAIInitEvent((SInitEvent*) event);
+			break;
+		case EVENT_UPDATE:
+			e = new CAIUpdateEvent((SUpdateEvent*) event);
+			break;
+		case EVENT_MESSAGE:	
+			e = new CAIMessageEvent((SMessageEvent*) event);
+			break;
+		case EVENT_UNIT_CREATED:
+			e = new CAIUnitCreatedEvent((SUnitCreatedEvent*) event);
+			break;
+		case EVENT_UNIT_FINISHED:
+			e = new CAIUnitFinishedEvent((SUnitFinishedEvent*) event);
+			break;
+		case EVENT_UNIT_IDLE:
+			e = new CAIUnitIdleEvent((SUnitIdleEvent*) event);
+			break;
+		case EVENT_UNIT_MOVE_FAILED:
+			e = new CAIUnitMoveFailedEvent((SUnitMoveFailedEvent*) event);
+			break;
+		case EVENT_UNIT_DAMAGED:
+			e = new CAIUnitDamagedEvent((SUnitDamagedEvent*) event);
+			break;
+		case EVENT_UNIT_DESTROYED: 
+			e = new CAIUnitDestroyedEvent((SUnitDestroyedEvent*) event);
+			break;
+		case EVENT_UNIT_GIVEN:
+			e = new CAIUnitGivenEvent((SUnitGivenEvent*) event);
+			break;
+		case EVENT_UNIT_CAPTURED:
+			e = new CAIUnitCapturedEvent((SUnitCapturedEvent*) event);
+			break;
+		case EVENT_ENEMY_ENTER_LOS:
+			e = new CAIEnemyEnterLOSEvent((SEnemyEnterLOSEvent*) event);
+			break;
+		case EVENT_ENEMY_LEAVE_LOS:
+			e = new CAIEnemyLeaveLOSEvent((SEnemyLeaveLOSEvent*) event);
+			break;
+		case EVENT_ENEMY_ENTER_RADAR:
+			e = new CAIEnemyEnterRadarEvent((SEnemyEnterRadarEvent*) event);
+			break;
+		case EVENT_ENEMY_LEAVE_RADAR:
+			e = new CAIEnemyLeaveRadarEvent((SEnemyLeaveRadarEvent*) event);
+			break;
+		case EVENT_ENEMY_DAMAGED:
+			e = new CAIEnemyDamagedEvent((SEnemyDamagedEvent*) event);
+			break;
+		case EVENT_ENEMY_DESTROYED: 
+			e = new CAIEnemyDestroyedEvent((SEnemyDestroyedEvent*) event);
+			break;
+		case EVENT_WEAPON_FIRED: 
+			e = new CAIWeaponFiredEvent((SWeaponFiredEvent*) event);
+			break;
+		case EVENT_PLAYER_COMMAND: 
+			e = new CAIPlayerCommandEvent((SPlayerCommandEvent*) event);
+			break;
+		case EVENT_SEISMIC_PING: 
+			e = new CAISeismicPingEvent((SSeismicPingEvent*) event);
+			break;
+		default:
+			e = new CAINullEvent();
+			break;
+	}
+	e-&gt;run(this);
+	delete e;
+	return 0;
+}
+*/


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullAI/AI.h
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AI.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,33 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AI_H
+//#define AI_H
+//
+//#include &lt;iostream&gt;
+//
+//class CAI { 
+//public:
+//    CAI();
+//    CAI(int team);
+//    virtual int handleEvent(int eventID, void* event);
+//
+//    int team;
+//};
+
+
+#endif /*AI_H*/


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullAI/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AIExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AIExport.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,127 @@
+#include &quot;AIExport.h&quot;
+
+#include &lt;map&gt;
+
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AI.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h&quot;
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+/*
+If we do not have an init() method, then we would instead pass
+an event InitEvent to handleEvent. However, we would have to make
+handleEvent have to wait for an InitEvent as a special case, since
+the team in question would not yet exist. 
+
+Therefore, the handleEvent code would look like this:
+[code]
+DLL_EXPORT int handleEvent(int team, int eventID, void* event) {
+    if (eventID == INIT_EVENT) {
+        ais[team] = CAIObject();
+    }
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team].handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}
+[/code]
+Advantages:
+* All events to AI go through handleEvent.
+* People don't get confused and start adding bananaSplitz() functions.
+
+Disadvantages:
+* We need to check for INIT_EVENT before *every message*.
+* These events will happen only once per game -- after that the check becomes a necessary waste of time.
+* Handling events is no longer about getting the right object to deal with an event, it also includes initialising object properly.
+
+I understand that we want to keep the interface simple. In fact,
+I think we should keep it as minimal as possible, and ideally everything
+would go through handleEvent. Practically though, it does not make sense
+to do this: we'll be wasting our own time for no good reason in the
+case of initialisation. 
+
+The (in my opinion much cleaner) alternative is the one I've implemented.
+Advantages:
+* One function that initialises a team before everything is passed to handlEvent
+* No redundant if statements.
+* Simple design.
+
+Disadvantage:
+* People might start adding other functions to the interface.
+
+I don't think that the disadvantage is a real one: it's pretty standard to 
+see initialisation as a special case. It's pretty clear that everything
+else goes through handleEvent. 
+
+The advantage is clear: a more efficient, simpler design. Of course, you could
+argue that the efficiency is nominal, one extra if per event is very little cost,
+and granted, that's true; but this doesn't change the fact that we're checking
+for a special case that we know only happens once at the beginning of the game, before
+every single event after.
+
+Of course, we still need an INIT_EVENT, since initialising the existance of a team
+member is not the same as initialising its state.
+
+You might also argue that we do this check in the handleEvent switch within each
+team. This is true, although the difference there is that a switch is translated
+to address lookups and so there is no increase in cost if there are more switch
+cases. 
+*/
+
+std::map&lt;int, CAI*&gt; ais;
+
+/*
+DLL_EXPORT int version() {
+    return 1;
+}
+*/
+
+// Since this is a C interface, we can only be told by the engine
+// to set up an AI with the number team that indicates a receiver
+// of any handleEvent() call.
+Export(int) init(int teamId) {
+	
+    if (ais.count(teamId) &gt; 0) {
+		// the map already has an AI for this team.
+		// raise an error, since it's probably a mistake if we're trying
+		// reinitialise a team that's already had init() called on it.
+        return -1;
+    }
+	
+    //TODO:
+    // Change the line below so that CAI is 
+    // your AI, which should be a subclass of CAI that
+    // overrides the handleEvent() method.
+    ais[teamId] = new CAI(teamId, NULL);
+}
+
+Export(int) release(int teamId) {
+	
+    if (ais.count(teamId) == 0) {
+		// the map has no AI for this team.
+		// raise an error, since it's probably a mistake if we're trying to
+		// release a team that's not initialized.
+        return -1;
+    }
+	
+    delete ais[teamId];
+	ais.erase(teamId);
+	
+	return 0;
+}
+
+Export(int) handleEvent(int teamId, int topic, const void* data) {
+	
+	if (ais.count(teamId) &gt; 0) {
+        // allow the AI instance to handle the event.
+        return ais[teamId]-&gt;handleEvent(topic, data);
+    } else {
+		// events sent to team -1 will always be to the AI object itself,
+		// not to a particular team.
+		
+		// no ai with value, so return error.
+		return -1;
+	}
+}
+


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AIExport.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullAI/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AIExport.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,50 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIEXPORT_H
+#define _AIEXPORT_H
+
+#if	!defined BUILDING_AI
+#error BUILDING_AI should be defined when building AIs
+#endif
+#if	defined BUILDING_AI_INTERFACE
+#error BUILDING_AI_INTERFACE should not be defined when building AIs
+#endif
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+//#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+
+//struct InfoItem;
+//struct Option;
+
+// for a list of the functions that have to be exported,
+// see struct SSAILibrary in &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+// static AI library methods (OPTIONAL TO IMPLEMENT)
+//Export(int) getInfos(InfoItem infos[], int max); // static properties
+//Export(enum LevelOfSupport) getLevelOfSupportFor(
+//		const char* engineVersionString, int engineVersionNumber,
+//		const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+//Export(int) getOptions(struct Option options[], int max);
+
+// team instance functions
+Export(int) init(int teamId);
+Export(int) release(int teamId);
+Export(int) handleEvent(int teamId, int topic, const void* data);
+
+#endif /* _AIEXPORT_H */
+


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AIExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'NullAI-0.1',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'NullAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'name',
+		value  = 'Test AI using the new C interface',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'This AI does absolutely nothing.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:NullAI">http://spring.clan-sy.com/wiki/AI:NullAI</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullAI/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AIOptions.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AIOptions.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullAI/AISCommands.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AISCommands.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/AISCommands.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,18 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+//#include &quot;ExternalAI/AISCommands.cpp&quot;


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/AISCommands.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/RAI-0.553 (from rev 6207, branches/caiinterface/AI/Global/RAI-0.553)

Copied: branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.cpp (from rev 6208, branches/caiinterface/AI/Global/RAI-0.553/AIExport.cpp)
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,172 @@
+#include &quot;AIExport.h&quot;
+
+#include &lt;map&gt;
+
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AI.h&quot;
+#include &quot;ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h&quot;
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+#include &quot;RAI.h&quot;
+
+/*
+If we do not have an init() method, then we would instead pass
+an event InitEvent to handleEvent. However, we would have to make
+handleEvent have to wait for an InitEvent as a special case, since
+the team in question would not yet exist. 
+
+Therefore, the handleEvent code would look like this:
+[code]
+DLL_EXPORT int handleEvent(int team, int eventID, void* event) {
+    if (eventID == INIT_EVENT) {
+        ais[team] = CAIObject();
+    }
+    if (ais.count(team) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[team].handleEvent(eventID, event);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}
+[/code]
+Advantages:
+* All events to AI go through handleEvent.
+* People don't get confused and start adding bananaSplitz() functions.
+
+Disadvantages:
+* We need to check for INIT_EVENT before *every message*.
+* These events will happen only once per game -- after that the check becomes a necessary waste of time.
+* Handling events is no longer about getting the right object to deal with an event, it also includes initialising object properly.
+
+I understand that we want to keep the interface simple. In fact,
+I think we should keep it as minimal as possible, and ideally everything
+would go through handleEvent. Practically though, it does not make sense
+to do this: we'll be wasting our own time for no good reason in the
+case of initialisation. 
+
+The (in my opinion much cleaner) alternative is the one I've implemented.
+Advantages:
+* One function that initialises a team before everything is passed to handlEvent
+* No redundant if statements.
+* Simple design.
+
+Disadvantage:
+* People might start adding other functions to the interface.
+
+I don't think that the disadvantage is a real one: it's pretty standard to 
+see initialisation as a special case. It's pretty clear that everything
+else goes through handleEvent. 
+
+The advantage is clear: a more efficient, simpler design. Of course, you could
+argue that the efficiency is nominal, one extra if per event is very little cost,
+and granted, that's true; but this doesn't change the fact that we're checking
+for a special case that we know only happens once at the beginning of the game, before
+every single event after.
+
+Of course, we still need an INIT_EVENT, since initialising the existance of a team
+member is not the same as initialising its state. (It's for this reason that
+I would consider renaming init() to create()).
+
+You might also argue that we do this check in the handleEvent switch within each
+team. This is true, although the difference there is that a switch is translated
+to address lookups and so there is no increase in cost if there are more switch
+cases. 
+*/
+
+std::map&lt;int, CAI*&gt; ais;
+
+int getInfos(InfoItem infos[], int max) {
+	
+	int i = 0;
+	
+	if (i &lt; max) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_SHORT_NAME, &quot;RAI&quot;, NULL};
+		infos[i] = ii;
+		i++;
+	}
+	if (i &lt; max) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_VERSION, &quot;0.553&quot;, NULL};
+		infos[i] = ii;
+		i++;
+	}
+	if (i &lt; max) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_NAME, &quot;Reths Skirmish AI&quot;, NULL};
+		infos[i] = ii;
+		i++;
+	}
+	if (i &lt; max) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_DESCRIPTION, &quot;This Skirmish AI supports most mods and plays decently.&quot;, NULL};
+		infos[i] = ii;
+		i++;
+	}
+	if (i &lt; max) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AI:RAI">http://spring.clan-sy.com/wiki/AI:RAI</A>&quot;, NULL};
+		infos[i] = ii;
+		i++;
+	}
+	if (i &lt; max) {
+		InfoItem ii = {SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED, &quot;no&quot;, NULL};
+		infos[i] = ii;
+		i++;
+	}
+	
+	return i;
+}
+enum LevelOfSupport getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
+	
+	if (strcmp(engineVersionString, ENGINE_VERSION_STRING) == 0 &amp;&amp;
+			engineVersionNumber &lt;= ENGINE_VERSION_NUMBER) {
+		return LOS_Working;
+	}
+	
+	return LOS_None;
+}
+
+int getOptions(struct Option options[], int max) {
+	return 0;
+}
+
+// Since this is a C interface, we can only be told by the engine
+// to set up an AI with the number team that indicates a receiver
+// of any handleEvent() call.
+int init(int teamId) {
+    // the map already has an AI for this team.
+    // raise an error, since it's probably a mistake if we're trying
+    // reinitialise a team that's already had init() called on it.
+    if (ais.count(teamId) &gt; 0) {
+        return -1;
+    }
+    //TODO:
+    // Change the line below so that CAI is 
+    // your AI, which should be a subclass of CAI that
+    // overrides the handleEvent() method.
+    ais[teamId] = new CAIGlobalAI(teamId, new cRAI);
+	
+	return 0;
+}
+
+int release(int teamId) {
+    // the map has no AI for this team.
+    // raise an error, since it's probably a mistake if we're trying to
+    // release a team that's not initialized.
+    if (ais.count(teamId) == 0) {
+        return -1;
+    }
+	
+    delete ais[teamId];
+	ais.erase(teamId);
+	
+	return 0;
+}
+
+int handleEvent(int teamId, int topic, const void* data) {
+    // events sent to team -1 will always be to the AI object itself,
+    // not to a particular team.
+    if (ais.count(teamId) &gt; 0){
+        // allow the AI instance to handle the event.
+        return ais[teamId]-&gt;handleEvent(topic, data);
+    }
+    // no ai with value, so return error.
+    else return -1;
+}

Copied: branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.h (from rev 6208, branches/caiinterface/AI/Global/RAI-0.553/AIExport.h)
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI-0.553/AIExport.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,43 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIEXPORT_H
+#define _AIEXPORT_H
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+
+struct InfoItem;
+struct Option;
+
+// for a list of the functions that have to be exported,
+// see struct SSAILibrary in &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+
+// static AI library methods
+Export(int) getInfos(InfoItem infos[], int max); // static properties
+Export(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+Export(int) getOptions(struct Option options[], int max);
+
+// team instance functions
+Export(int) init(int teamId);
+Export(int) release(int teamId);
+Export(int) handleEvent(int teamId, int topic, const void* data);
+
+#endif /* _AIEXPORT_H */
+

Added: branches/caiinterface/AI/Skirmish/RAI-0.553/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI-0.553/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI-0.553/AIInfo.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'RAI-0.553',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'RAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.553',
+	},
+	{
+		key    = 'name',
+		value  = 'Reths Skirmish AI (RAI)',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'Competetive AI that supports most Mods, also non TA ones.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:RAI">http://spring.clan-sy.com/wiki/AI:RAI</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/RAI-0.553/AIInfo.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/RAI-0.553/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI-0.553/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI-0.553/AIOptions.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/RAI-0.553/AIOptions.lua
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp
===================================================================
--- branches/caiinterface/AI/Global/RAI-0.553/GlobalAIs.cpp	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,30 +0,0 @@
-#include &quot;RAI.h&quot;
-#include &quot;ExternalAI/aibase.h&quot;
-//#include &lt;set&gt;
-
-/////////////////////////////////////////////////////////////////////////////
-
-std::set&lt;IGlobalAI*&gt; ais;
-
-DLL_EXPORT int GetGlobalAiVersion()
-{
-	return GLOBAL_AI_INTERFACE_VERSION;
-}
-
-DLL_EXPORT void GetAiName(char* name)
-{
-	strcpy(name,AI_NAME);
-}
-
-DLL_EXPORT IGlobalAI* GetNewAI()
-{
-	cRAI* ai=new cRAI;
-	ais.insert(ai);
-	return ai;
-}
-
-DLL_EXPORT void ReleaseAI(IGlobalAI* i)
-{
-	delete (cRAI*)i;
-	ais.erase(i);
-}

Copied: branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp (from rev 6208, branches/caiinterface/AI/Global/RAI-0.553/GlobalAIs.cpp)
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI-0.553/GlobalAIs.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,30 @@
+#include &quot;RAI.h&quot;
+#include &quot;ExternalAI/aibase.h&quot;
+//#include &lt;set&gt;
+
+/////////////////////////////////////////////////////////////////////////////
+
+std::set&lt;IGlobalAI*&gt; oldais;
+
+DLL_EXPORT int GetGlobalAiVersion()
+{
+	return GLOBAL_AI_INTERFACE_VERSION;
+}
+
+DLL_EXPORT void GetAiName(char* name)
+{
+	strcpy(name,AI_NAME);
+}
+
+DLL_EXPORT IGlobalAI* GetNewAI()
+{
+	cRAI* ai=new cRAI;
+	oldais.insert(ai);
+	return ai;
+}
+
+DLL_EXPORT void ReleaseAI(IGlobalAI* i)
+{
+	delete (cRAI*)i;
+	oldais.erase(i);
+}

Copied: branches/caiinterface/AI/Skirmish/TestGlobalAI (from rev 6207, branches/caiinterface/AI/Global/TestGlobalAI)


Property changes on: branches/caiinterface/AI/Skirmish/TestGlobalAI
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: branches/caiinterface/AI/Skirmish/TestGlobalAI/TestAI.vcproj
===================================================================
--- branches/caiinterface/AI/Global/TestGlobalAI/TestAI.vcproj	2008-07-21 08:06:44 UTC (rev 6207)
+++ branches/caiinterface/AI/Skirmish/TestGlobalAI/TestAI.vcproj	2008-10-01 18:03:35 UTC (rev 6494)
@@ -16,7 +16,7 @@
 	&lt;Configurations&gt;
 		&lt;Configuration
 			Name=&quot;Release|Win32&quot;
-			OutputDirectory=&quot;..\..\..\game\AI\Bot-libs&quot;
+			OutputDirectory=&quot;..\..\..\game\AI\Skirmish/impls&quot;
 			IntermediateDirectory=&quot;.\Release&quot;
 			ConfigurationType=&quot;2&quot;
 			InheritedPropertySheets=&quot;$(VCInstallDir)VCProjectDefaults\UpgradeFromVC71.vsprops&quot;

Modified: branches/caiinterface/Lobby/AFLobby/src/aflobby/CBattleWindow.java
===================================================================
--- branches/caiinterface/Lobby/AFLobby/src/aflobby/CBattleWindow.java	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/Lobby/AFLobby/src/aflobby/CBattleWindow.java	2008-10-01 18:03:35 UTC (rev 6494)
@@ -283,15 +283,15 @@
         
         String sk;
         if (Misc.isWindows()) {
-            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Bot-libs/*.dll&quot;);
+            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Skirmish/impls/*.dll&quot;);
         } else if (Misc.isMacOS()) {
-            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Bot-libs/*.dylib&quot;);
+            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Skirmish/impls/*.dylib&quot;);
         } else {
             // if(Misc.isLinux()){
-            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Bot-libs/*.so&quot;);
+            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Skirmish/impls/*.so&quot;);
         }
         //sk = sk;//replaceAll(&quot;\\&quot;, &quot;&quot;);
-        //sk = sk.replaceAll(&quot;AI/Bot-libs/&quot;, &quot;&quot;);
+        //sk = sk.replaceAll(&quot;AI/Skirmish/impls/&quot;, &quot;&quot;);
         final String[] ailist = sk.split(&quot;,&quot;);
 
         Runnable doWorkRunnable = new Runnable() {
@@ -725,12 +725,12 @@
         String sk;
         
         if (Misc.isWindows()) {
-            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Bot-libs/*.dll&quot;);
+            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Skirmish/impls/*.dll&quot;);
         } else if (Misc.isMacOS()) {
-            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Bot-libs/*.dylib&quot;);
+            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Skirmish/impls/*.dylib&quot;);
         } else {
             // if(Misc.isLinux()){
-            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Bot-libs/*.so&quot;);
+            sk = CUnitSyncJNIBindings.SearchVFS(&quot;AI/Skirmish/impls/*.so&quot;);
         }
         
         final String[] ailist = sk.split(&quot;,&quot;);
@@ -1360,7 +1360,7 @@
                     
                     
                     if (ai.equalsIgnoreCase(&quot;&quot;) == false) {
-                        s += &quot;\t\taidll=AI/Bot-libs/&quot; + ai + &quot;;\n&quot;;
+                        s += &quot;\t\taidll=AI/Skirmish/impls/&quot; + ai + &quot;;\n&quot;;
                     }else{
                         s += &quot;\t\t// no AI\n&quot;;
                     }

Modified: branches/caiinterface/Lobby/TASClient/MainUnit.pas
===================================================================
--- branches/caiinterface/Lobby/TASClient/MainUnit.pas	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/Lobby/TASClient/MainUnit.pas	2008-10-01 18:03:35 UTC (rev 6494)
@@ -540,7 +540,7 @@
   SPSKIN_FOLDER = LOBBY_FOLDER + '\SPSkins';
   SCRIPTS_FOLDER = LOBBY_FOLDER + '\Python\engine';
   FIRST_UDP_SOURCEPORT = 8300; // udp source port (used with &quot;fixed source ports&quot; NAT traversal technique) of the second (first one is host) client in clients list of the battle. Third client uses this+1 port, fourth one this+2, etc.
-  AIDLL_FOLDER = 'AI/Bot-libs'; // searching for *.dll in this folder will return all bots that you can use to play with
+  AIDLL_FOLDER = 'AI/Skirmish/impls'; // searching for *.dll in this folder will return all bots that you can use to play with
   MAP_DOWNLOADER_ENABLED = False; // integrated map downloader is currently disabled as FileUniverse.com is no longer hosting spring content
 
   MAX_PLAYERS = 32; // max. players supported by Spring in a game

Modified: branches/caiinterface/SConstruct
===================================================================
--- branches/caiinterface/SConstruct	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/SConstruct	2008-10-01 18:03:35 UTC (rev 6494)
@@ -7,18 +7,23 @@
 `install-CentralBuildAI' and the default target has `install'.
 
 [default]
-
 	spring
 	unitsync
+	AIInterfaces
+		C
+		Java
 	GroupAI
 		CentralBuildAI
 		MetalMakerAI
 		SimpleFormationAI
-	GlobalAI
-		JCAI
+	SkirmishAI
+		RAI
 		NTAI
-		OTAI
-		TestGlobalAI
+		KAI
+		KAIK
+		AAI
+		TestSkirmishAI
+		NullAI
 &quot;&quot;&quot;
 
 
@@ -32,6 +37,10 @@
 else:
 	env = Environment(tools = ['default', 'rts'], toolpath = ['.', 'rts/build/scons'])
 
+
+################################################################################
+### Build spring(.exe)
+################################################################################
 spring_files = filelist.get_spring_source(env)
 
 # spring.exe icon
@@ -69,7 +78,10 @@
 if env['strip']:
 	env.AddPostAction(spring, Action([['strip','$TARGET']]))
 
-# Build unitsync shared object
+
+################################################################################
+### Build unitsync shared object
+################################################################################
 # HACK   we should probably compile libraries from 7zip, hpiutil2 and minizip
 # so we don't need so much bloat here.
 # Need a new env otherwise scons chokes on equal targets built with different flags.
@@ -140,66 +152,158 @@
 if env['platform'] != 'windows':
 	Default(unitsync)
 
-# Make a copy of the build environment for the AIs, but remove libraries and add include path.
+
+################################################################################
+### AIs
+################################################################################
+# Make a copy of the build environment for the AIs,
+# but remove libraries and add include path.
 # TODO: make separate SConstructs for AIs
 aienv = env.Copy()
 aienv.Append(CPPPATH = ['rts/ExternalAI'])
+aienv['LINKFLAGS'] += ['-Wl,--kill-at', '--add-stdcall-alias', '-mno-cygwin', '-lstdc++']
+#aienv['CPPDEFINES'] += ['_DLL']
+aiinterfaceenv = aienv.Copy()
+print aienv['CPPDEFINES']
 
+aienv['CPPDEFINES'] += ['BUILDING_AI']
+
+aiinterfaceenv['CPPDEFINES'] += ['BUILDING_AI_INTERFACE']
+#aiinterfaceenv['LINKFLAGS'] += ['-llua']
+
+################################################################################
+### Build AI Interface shared objects
+################################################################################
+## Use subst() to substitute $installprefix in datadir.
+#install_dir = os.path.join(aiinterfaceenv['installprefix'], aiinterfaceenv.subst(aiinterfaceenv['libdir']), 'AI/Interfaces/impls')
+install_dir = os.path.join(aiinterfaceenv['installprefix'], aiinterfaceenv['libdir'], 'AI/Interfaces/impls')
+
+# store shared ai-interface objects so newer scons versions don't choke with
+# *** Two environments with different actions were specified for the same target
+aiinterfaceobjs = []
+for f in filelist.get_shared_AIInterface_source(aiinterfaceenv, True, True, False):
+	while isinstance(f, list):
+		f = f[0]
+	fpath, fbase = os.path.split(f)
+#	print &quot;file: %s&quot; % f
+#	print &quot;base: %s&quot; % fbase
+	fname, fext = fbase.rsplit('.', 1)
+	aiinterfaceobjs.append(aiinterfaceenv.SharedObject(os.path.join(fpath, fname + '-aiinterface'), f))
+
+# Build
+for f in filelist.list_AIInterfaces(aiinterfaceenv, exclude_list=['build']):
+	lib = aiinterfaceenv.SharedLibrary(os.path.join('game/AI/Interfaces/impls', f), aiinterfaceobjs + filelist.get_AIInterface_source(aiinterfaceenv, f))
+	Alias(f, lib)          # Allow e.g. `scons Java' to compile just that specific AI interface.
+	Alias('AIInterfaces', lib) # Allow `scons AIInterfaces' to compile all AI interfaces.
+	Default(lib)
+	inst = env.Install(install_dir, lib)
+	Alias('install', inst)
+	Alias('install-AIInterfaces', inst)
+	Alias('install-'+f, inst)
+	if aiinterfaceenv['strip']:
+		aiinterfaceenv.AddPostAction(lib, Action([['strip','$TARGET']]))
+
+################################################################################
+### Build Skirmish AI shared objects
+################################################################################
 # Use subst() to substitute $installprefix in datadir.
-install_dir = os.path.join(aienv['installprefix'], aienv['libdir'], 'AI/Helper-libs')
+install_dir = os.path.join(aienv['installprefix'], aienv.subst(aienv['libdir']), 'AI/Skirmish/impls')
 
 # store shared ai objects so newer scons versions don't choke with
 # *** Two environments with different actions were specified for the same target
-aiobjs = []
-for f in filelist.get_shared_AI_source(aienv):
+skirmishaiobjs = []
+for f in filelist.get_shared_skirmishAI_source(aienv, True, False, True):
         while isinstance(f, list):
                 f = f[0]
         fpath, fbase = os.path.split(f)
         fname, fext = fbase.rsplit('.', 1)
-        aiobjs.append(aienv.SharedObject(os.path.join(fpath, fname + '-ai'), f))
+        skirmishaiobjs.append(aienv.SharedObject(os.path.join(fpath, fname + '-skirmishai'), f))
 
-#Build GroupAIs
-for f in filelist.list_groupAIs(aienv, exclude_list=['build']):
-	lib = aienv.SharedLibrary(os.path.join('game/AI/Helper-libs', f), aiobjs + filelist.get_groupAI_source(aienv, f))
-	Alias(f, lib)         # Allow e.g. `scons CentralBuildAI' to compile just an AI.
-	Alias('GroupAI', lib) # Allow `scons GroupAI' to compile all groupAIs.
+# Build
+ai_exclude_list=['build', 'CSAI', 'TestABICAI','AbicWrappersTestAI', 'TestGlobalAI']
+for f in filelist.list_skirmishAIs(aienv, exclude_list=ai_exclude_list):
+	lib = aienv.SharedLibrary(os.path.join('game/AI/Skirmish/impls', f), skirmishaiobjs + filelist.get_skirmishAI_source(aienv, f))
+	Alias(f, lib)          # Allow e.g. `scons JCAI' to compile just a skirmish AI.
+	Alias('SkirmishAI', lib) # Allow `scons SkirmishAI' to compile all skirmishAIs.
 	Default(lib)
 	inst = env.Install(install_dir, lib)
 	Alias('install', inst)
-	Alias('install-GroupAI', inst)
+	Alias('install-SkirmishAI', inst)
 	Alias('install-'+f, inst)
 	if aienv['strip']:
 		aienv.AddPostAction(lib, Action([['strip','$TARGET']]))
 
-install_dir = os.path.join(aienv['installprefix'], aienv.subst(aienv['libdir']), 'AI/Bot-libs')
-
-#Build GlobalAIs
-for f in filelist.list_globalAIs(aienv, exclude_list=['build', 'CSAI', 'TestABICAI','AbicWrappersTestAI']):
-	lib = aienv.SharedLibrary(os.path.join('game/AI/Bot-libs', f), aiobjs + filelist.get_globalAI_source(aienv, f))
-	Alias(f, lib)          # Allow e.g. `scons JCAI' to compile just a global AI.
-	Alias('GlobalAI', lib) # Allow `scons GlobalAI' to compile all globalAIs.
-	Default(lib)
-	inst = env.Install(install_dir, lib)
-	Alias('install', inst)
-	Alias('install-GlobalAI', inst)
-	Alias('install-'+f, inst)
-	if aienv['strip']:
-		aienv.AddPostAction(lib, Action([['strip','$TARGET']]))
-
 # build TestABICAI
-# lib = aienv.SharedLibrary(os.path.join('game/AI/Bot-libs','TestABICAI'), ['game/spring.a'], CPPDEFINES = env# ['CPPDEFINES'] + ['BUILDING_AI'] )
+# lib = aienv.SharedLibrary(os.path.join('game/AI/Skirmish/impls','TestABICAI'), ['game/spring.a'], CPPDEFINES = env# ['CPPDEFINES'] + ['BUILDING_AI'] )
 # Alias('TestABICAI', lib)
 # Alias('install-TestABICAI', inst)
 # if sys.platform == 'win32':
-# 	Alias('GlobalAI', lib)
+# 	Alias('SkirmishAI', lib)
 # 	Default(lib)
 # 	inst = env.Install(install_dir, lib)
 # 	Alias('install', inst)
-# 	Alias('install-GlobalAI', inst)
+# 	Alias('install-SkirmishAI', inst)
 # 	if env['strip']:
 # 		env.AddPostAction(lib, Action([['strip','$TARGET']]))
 
-# Build streflop (which has it's own Makefile-based build system)
+# install Skirmish AI info and options files
+info_files=filelist.list_directories(env, 'AI/Skirmish', exclude_list=ai_exclude_list, recursively=False)
+for f in info_files:
+	#print &quot;inspecting %s ...&quot; % f
+	if os.path.exists(f + &quot;/AIInfo.lua&quot;):
+		print &quot;exists: %s/AIInfo.lua&quot; % f
+		print &quot;installprefix: %s&quot; % aienv['installprefix']
+		print &quot;datadir: %s&quot; % aienv['datadir']
+		print &quot;copying to: %s&quot; % &quot;AI/Skirmish/data/&quot; + os.path.basename(f) + &quot;/AIInfo.lua&quot;
+		inst = env.Install(os.path.join(aienv['installprefix'], aienv['datadir'], &quot;AI/Skirmish/data/&quot; + os.path.basename(f)), f + &quot;/AIInfo.lua&quot;)
+		Alias('install', inst)
+	if os.path.exists(f + &quot;/AIOptions.lua&quot;):
+		print &quot;exists: %s/AIOptions.lua&quot; % f
+		print &quot;copying to: %s&quot; % &quot;AI/Skirmish/data/&quot; + os.path.basename(f) + &quot;/AIOptions.lua&quot;
+		inst = env.Install(os.path.join(aienv['installprefix'], aienv['datadir'], &quot;AI/Skirmish/data/&quot; + os.path.basename(f)), f + &quot;/AIOptions.lua&quot;)
+		Alias('install', inst)
+	print &quot;&quot;
+
+# install AAI config files
+aai_data=filelist.list_files_recursive(env, 'game/AI/AAI')
+for f in aai_data:
+	if not os.path.isdir(f):
+		inst = env.Install(os.path.join(aienv['installprefix'], aienv['datadir'], os.path.dirname(f)[5:]), f)
+		Alias('install', inst)
+
+################################################################################
+### Build Group AI shared objects
+################################################################################
+# Use subst() to substitute $installprefix in datadir.
+install_dir = os.path.join(aienv['installprefix'], aienv.subst(aienv['libdir']), 'AI/Helper-libs')
+
+# store shared ai objects so newer scons versions don't choke with
+# *** Two environments with different actions were specified for the same target
+groupaiobjs = []
+for f in filelist.get_shared_skirmishAI_source(aienv, True, False, True):
+        while isinstance(f, list):
+                f = f[0]
+        fpath, fbase = os.path.split(f)
+        fname, fext = fbase.rsplit('.', 1)
+        groupaiobjs.append(aienv.SharedObject(os.path.join(fpath, fname + '-groupai'), f))
+
+# Build
+for f in filelist.list_groupAIs(aienv, exclude_list=['build']):
+	lib = aienv.SharedLibrary(os.path.join('game/AI/Helper-libs', f), groupaiobjs + filelist.get_groupAI_source(aienv, f))
+	Alias(f, lib)         # Allow e.g. `scons CentralBuildAI' to compile just an AI.
+	Alias('GroupAI', lib) # Allow `scons GroupAI' to compile all groupAIs.
+	Default(lib)
+	inst = env.Install(install_dir, lib)
+	Alias('install', inst)
+	Alias('install-GroupAI', inst)
+	Alias('install-'+f, inst)
+	if aienv['strip']:
+		aienv.AddPostAction(lib, Action([['strip','$TARGET']]))
+
+
+################################################################################
+### Build streflop (which has it's own Makefile-based build system)
+################################################################################
 if not 'configure' in sys.argv and not 'test' in sys.argv and not 'install' in sys.argv:
 	cmd = &quot;CC=&quot; + env['CC'] + &quot; CXX=&quot; + env['CXX'] + &quot; --no-print-directory -C rts/lib/streflop&quot;
 	if env['fpmath'] == 'sse':
@@ -234,8 +338,9 @@
 				os.system(test)
 
 
-# Build gamedata zip archives
-
+################################################################################
+### Build gamedata zip archives
+################################################################################
 # Can't use these, we can't set the working directory and putting a SConscript
 # in the respective directories doesn't work either because then the SConstript
 # ends up in the zip too... Bah. SCons sucks. Just like autoshit and everything else btw.
@@ -289,13 +394,6 @@
 inst = env.Install(os.path.join(env['installprefix'], 'share/applications'), 'rts/spring.desktop')
 Alias('install', inst)
 
-# install AAI config files
-aai_data=filelist.list_files_recursive(env, 'game/AI/AAI')
-for f in aai_data:
-	if not os.path.isdir(f):
-		inst = env.Install(os.path.join(aienv['installprefix'], aienv['datadir'], os.path.dirname(f)[5:]), f)
-		Alias('install', inst)
-
 # install LuaUI files
 for f in ['luaui.lua']:
 	inst = env.Install(os.path.join(env['installprefix'], env['datadir']), os.path.join('game', f))

Modified: branches/caiinterface/directories.txt
===================================================================
--- branches/caiinterface/directories.txt	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/directories.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -4,7 +4,10 @@
 rts/build/vstudio7                Visual Studio 7 project files
 rts/build/vstudio8                Visual Studio 8 project files
 rts/build/xcode                   xcode project file
-rts/ExternalAI                    AI interfaces
+rts/ExternalAI                    engine side AI interface
+rts/ExternalAI/Interface          AI side AI interface (also used by the engine)
+rts/ExternalAI/Interface/LegacyCppWrapper                 Legacy C++ AI side AI interface
+rts/ExternalAI/Interface/LegacyCppWrapper/Event           Legacy C++ AI side AI interface Event classes
 rts/Game                          General game code
 rts/Game/StartScripts             Hardcoded startscripts
 rts/Game/UI                       Game controls including current gui
@@ -49,11 +52,13 @@
 rts/System/Sync                   Sync debuggers
 
 AI                                AI sourcecode..
-AI/Global                         ..for GlobalAIs (Bot-libs)
+AI/Interfaces                     ..for interfaceing with Skirmish and Group AIs (Interfaces/impls)
+AI/Skirmish                       ..for SkirmishAIs (Skirmish/impls)
 AI/Group                          ..for GroupAIs (Helper-libs)
 
-game/AI/Bot-libs                  Output directory for global AI binaries
 game/AI                           Files related to AI
+game/AI/Interfaces/impls          Output directory for AI interface binaries
+game/AI/Skirmish/impls            Output directory for skirmish AI binaries
 game/AI/Helper-libs               Output directory for group AI binaries
 game/base                         Output directory for springcontent.sdz &amp; bitmaps.sdz
 game/maps                         Map archives (sd7,sdz,sdd)

Modified: branches/caiinterface/game/startscripts/aistartscripttest.lua
===================================================================
--- branches/caiinterface/game/startscripts/aistartscripttest.lua	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/game/startscripts/aistartscripttest.lua	2008-10-01 18:03:35 UTC (rev 6494)
@@ -78,8 +78,8 @@
 
 -- Create a bunch of units for this simple mission
 function MissionTest:Setup()
-    AIs.CreateGlobalAI( 0, &quot;AI/Bot-libs/TestGlobalAI.dll&quot; )
-    AIs.CreateGlobalAI( 1, &quot;AI/Bot-libs/TestGlobalAI.dll&quot; )
+    AIs.CreateGlobalAI( 0, &quot;AI/Skirmish/impls/TestGlobalAI.dll&quot; )
+    AIs.CreateGlobalAI( 1, &quot;AI/Skirmish/impls/TestGlobalAI.dll&quot; )
 
     units.Load(&quot;ARM_Jeffy&quot;, float3(300, 80, 300), 0, false)
     units.Load(&quot;ARM_Jeffy&quot;, float3(340, 80, 300), 0, false)

Modified: branches/caiinterface/installer/sections/aai.nsh
===================================================================
--- branches/caiinterface/installer/sections/aai.nsh	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/installer/sections/aai.nsh	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,6 +1,6 @@
 !ifdef INSTALL
-  SetOutPath &quot;$INSTDIR\AI\Bot-libs&quot;
-  File &quot;..\game\AI\Bot-libs\AAI.dll&quot;
+  SetOutPath &quot;$INSTDIR\AI\Skirmish/impls&quot;
+  File &quot;..\game\AI\Skirmish/impls\AAI.dll&quot;
 
   SetOutPath &quot;$INSTDIR\AI\AAI&quot;
   File /r /x .svn &quot;..\game\AI\AAI\*.*&quot;
@@ -10,9 +10,9 @@
   Delete &quot;$INSTDIR\AI\AAI\learn\mod\XTAPE.dat&quot;
   
 !else
-  Delete &quot;$INSTDIR\AI\Bot-libs\AAI.dll&quot;
+  Delete &quot;$INSTDIR\AI\Skirmish/impls\AAI.dll&quot;
   RmDir /r &quot;$INSTDIR\AI\AAI&quot;
   ; we run after main.nsh so need to remove dirs here..
-  RmDir &quot;$INSTDIR\AI\Bot-libs&quot;
+  RmDir &quot;$INSTDIR\AI\Skirmish/impls&quot;
   RmDir &quot;$INSTDIR\AI&quot;
 !endif

Modified: branches/caiinterface/installer/sections/kai.nsh
===================================================================
--- branches/caiinterface/installer/sections/kai.nsh	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/installer/sections/kai.nsh	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,17 +1,17 @@
 !ifdef INSTALL
 
-  SetOutPath &quot;$INSTDIR\AI\Bot-libs&quot;
-  File &quot;..\game\AI\Bot-libs\KAIK-0.13.dll&quot;
+  SetOutPath &quot;$INSTDIR\AI\Skirmish/impls&quot;
+  File &quot;..\game\AI\Skirmish/impls\KAIK-0.13.dll&quot;
 
   ; Delete the old KAI.
-  Delete &quot;$INSTDIR\AI\Bot-libs\KAI-0.12.dll&quot;
+  Delete &quot;$INSTDIR\AI\Skirmish/impls\KAI-0.12.dll&quot;
 
 !else
 
-  Delete &quot;$INSTDIR\AI\Bot-libs\KAIK-0.13.dll&quot;
+  Delete &quot;$INSTDIR\AI\Skirmish/impls\KAIK-0.13.dll&quot;
   RmDir /r &quot;$INSTDIR\AI\KAIK013&quot;
   ; we run after main.nsh so need to remove dirs here..
-  RmDir &quot;$INSTDIR\AI\Bot-libs&quot;
+  RmDir &quot;$INSTDIR\AI\Skirmish/impls&quot;
   RmDir &quot;$INSTDIR\AI&quot;
 
 !endif

Modified: branches/caiinterface/installer/sections/main.nsh
===================================================================
--- branches/caiinterface/installer/sections/main.nsh	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/installer/sections/main.nsh	2008-10-01 18:03:35 UTC (rev 6494)
@@ -98,8 +98,8 @@
   File &quot;..\game\AI\Helper-libs\ReportIdleAI.dll&quot;
 
 ; TODO: Fix the vc projects to use the same names.
-  SetOutPath &quot;$INSTDIR\AI\Bot-libs&quot;
-  File &quot;..\game\AI\Bot-libs\TestGlobalAI.dll&quot;
+  SetOutPath &quot;$INSTDIR\AI\Skirmish/impls&quot;
+  File &quot;..\game\AI\Skirmish/impls\TestGlobalAI.dll&quot;
 
 ; Default content
   SetOverWrite on
@@ -182,8 +182,8 @@
   RmDir &quot;$INSTDIR\fonts&quot;
   
   ; AI Bot dlls
-  Delete &quot;$INSTDIR\AI\Bot-libs\TestGlobalAI.dll&quot;
-  RmDir &quot;$INSTDIR\AI\Bot-libs&quot;
+  Delete &quot;$INSTDIR\AI\Skirmish/impls\TestGlobalAI.dll&quot;
+  RmDir &quot;$INSTDIR\AI\Skirmish/impls&quot;
 
   ; AI Helper dlls
   Delete &quot;$INSTDIR\AI\Helper-libs\CentralBuildAI.dll&quot;

Modified: branches/caiinterface/rts/CMakeLists.txt
===================================================================
--- branches/caiinterface/rts/CMakeLists.txt	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/CMakeLists.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -76,7 +76,7 @@
 	FIND_PACKAGE(SDL REQUIRED)
 	INCLUDE_DIRECTORIES(${SDL_INCLUDE_DIR})
 
-	FIND_PACKAGE(Boost 1.34.0 COMPONENTS thread regex REQUIRED)
+	FIND_PACKAGE(Boost 1.34.0 COMPONENTS thread regex filesystem REQUIRED)
 
 	FIND_PACKAGE(X11 REQUIRED)
 	FIND_PACKAGE(OpenAL REQUIRED)
@@ -89,7 +89,7 @@
 
 	FIND_PACKAGE(Freetype REQUIRED)
 	INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIR})
-	LIST(APPEND spring_libraries openal GL GLU ${DEVIL_LIBRARIES} X11 Xcursor ${GLEW_LIBRARIES} ${Boost_REGEX_LIBRARY} ${Boost_THREAD_LIBRARY})
+	LIST(APPEND spring_libraries openal GL GLU ${DEVIL_LIBRARIES} X11 Xcursor ${GLEW_LIBRARIES} ${Boost_REGEX_LIBRARY} ${Boost_THREAD_LIBRARY} ${Boost_FILESYSTEM_LIBRARY})
 ENDIF (MINGW)
 
 ### libraries needed on all platforms
@@ -117,6 +117,7 @@
 AUX_SOURCE_DIRECTORY(Lua luafiles)
 
 AUX_SOURCE_DIRECTORY(ExternalAI aifiles)
+AUX_SOURCE_DIRECTORY(ExternalAI/Interface aifiles)
 
 AUX_SOURCE_DIRECTORY(Map mapfiles)
 AUX_SOURCE_DIRECTORY(Map/SM3 mapfiles)

Modified: branches/caiinterface/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -41,7 +41,7 @@
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;AICheats.h&quot;
 #include &quot;GlobalAICallback.h&quot;
-#include &quot;GlobalAI.h&quot;
+#include &quot;SkirmishAIWrapper.h&quot;
 #include &quot;GlobalAIHandler.h&quot;
 #include &quot;Group.h&quot;
 #include &quot;GroupHandler.h&quot;
@@ -188,9 +188,15 @@
 // (still completely insecure ofcourse, but it filters out the easiest way of cheating)
 void CAICallback::verify()
 {
-	CGlobalAI *gai = globalAI-&gt;ais [team];
-	if (gai &amp;&amp; (((group &amp;&amp; group-&gt;handler != /*gai-&gt;gh*/grouphandlers[gai-&gt;team] /*&amp;&amp; group-&gt;handler != grouphandler*/) || gai-&gt;team != team))) {
-		handleerror (0, &quot;AI has modified spring components(possible cheat)&quot;, &quot;Spring is closing:&quot;, MBF_OK | MBF_EXCL);
+	const CSkirmishAIWrapper* skirmishAI = globalAI-&gt;GetSkirmishAI(team);
+	if (
+			skirmishAI
+			&amp;&amp; (((group
+					&amp;&amp; group-&gt;handler != /*skirmishAI-&gt;gh*/grouphandlers[skirmishAI-&gt;GetTeamId()]
+					/*&amp;&amp; group-&gt;handler != grouphandler*/)
+			|| skirmishAI-&gt;GetTeamId() != team))) {
+		handleerror (0, &quot;AI has modified spring components(possible cheat)&quot;,
+				&quot;Spring is closing:&quot;, MBF_OK | MBF_EXCL);
 		exit (-1);
 	}
 }
@@ -236,12 +242,14 @@
 
 void* CAICallback::CreateSharedMemArea(char* name, int size)
 {
-	return globalAI-&gt;GetAIBuffer(team,name,size);
+	handleerror (0, &quot;AI wants to use deprecated function \&quot;CreateSharedMemArea\&quot;&quot;,
+				&quot;Spring is closing:&quot;, MBF_OK | MBF_EXCL);
 }
 
 void CAICallback::ReleasedSharedMemArea(char* name)
 {
-	globalAI-&gt;ReleaseAIBuffer(team,name);
+	handleerror (0, &quot;AI wants to use deprecated function \&quot;ReleasedSharedMemArea\&quot;&quot;,
+				&quot;Spring is closing:&quot;, MBF_OK | MBF_EXCL);
 }
 
 int CAICallback::CreateGroup(char* libraryName, unsigned aiNumber)

Modified: branches/caiinterface/rts/ExternalAI/AICheats.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AICheats.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AICheats.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,7 +1,9 @@
+
+#include &quot;AICheats.h&quot;
+
 #include &quot;StdAfx.h&quot;
 #include &lt;vector&gt;
-#include &quot;AICheats.h&quot;
-#include &quot;GlobalAI.h&quot;
+#include &quot;SkirmishAIWrapper.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
@@ -18,7 +20,7 @@
 
 using namespace std;
 
-CAICheats::CAICheats(CGlobalAI* ai): ai(ai)
+CAICheats::CAICheats(CSkirmishAIWrapper* ai): ai(ai)
 {
 }
 
@@ -43,32 +45,32 @@
 
 void CAICheats::EnableCheatEvents(bool enable)
 {
-	ai-&gt;cheatevents = enable;
+	ai-&gt;SetCheatEventsEnabled(enable);
 }
 
 void CAICheats::SetMyHandicap(float handicap)
 {
 	if (!OnlyPassiveCheats()) {
-		gs-&gt;Team(ai-&gt;team)-&gt;handicap = 1 + handicap / 100;
+		gs-&gt;Team(ai-&gt;GetTeamId())-&gt;handicap = 1 + handicap / 100;
 	}
 }
 
 void CAICheats::GiveMeMetal(float amount)
 {
 	if (!OnlyPassiveCheats())
-		gs-&gt;Team(ai-&gt;team)-&gt;metal += amount;
+		gs-&gt;Team(ai-&gt;GetTeamId())-&gt;metal += amount;
 }
 
 void CAICheats::GiveMeEnergy(float amount)
 {
 	if (!OnlyPassiveCheats())
-		gs-&gt;Team(ai-&gt;team)-&gt;energy += amount;
+		gs-&gt;Team(ai-&gt;GetTeamId())-&gt;energy += amount;
 }
 
 int CAICheats::CreateUnit(const char* name, float3 pos)
 {
 	if (!OnlyPassiveCheats()) {
-		CUnit* u = unitLoader.LoadUnit(name, pos, ai-&gt;team, false, 0, NULL);
+		CUnit* u = unitLoader.LoadUnit(name, pos, ai-&gt;GetTeamId(), false, 0, NULL);
 		if (u)
 			return u-&gt;id;
 	}
@@ -105,7 +107,7 @@
 	for (list&lt;CUnit*&gt;::iterator ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ++ui) {
 		CUnit* u = *ui;
 
-		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(ai-&gt;team))) {
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(ai-&gt;GetTeamId()))) {
 			if (!IsUnitNeutral(u-&gt;id)) {
 				units[a++] = u-&gt;id;
 			}
@@ -124,7 +126,7 @@
 	for (ui = unit.begin(); ui != unit.end(); ++ui) {
 		CUnit* u = *ui;
 
-		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(ai-&gt;team))) {
+		if (!gs-&gt;Ally(u-&gt;allyteam, gs-&gt;AllyTeam(ai-&gt;GetTeamId()))) {
 			if (!IsUnitNeutral(u-&gt;id)) {
 				units[a] = u-&gt;id;
 				++a;

Modified: branches/caiinterface/rts/ExternalAI/AICheats.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AICheats.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AICheats.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -2,13 +2,13 @@
 #define AICHEATS_H
 
 #include &quot;IAICheats.h&quot;
-class CGlobalAI;
+class CSkirmishAIWrapper;
 
 class CAICheats: public IAICheats
 {
-	CGlobalAI* ai;
+	CSkirmishAIWrapper* ai;
 public:
-	CAICheats(CGlobalAI* ai);
+	CAICheats(CSkirmishAIWrapper* ai);
 	~CAICheats(void);
 
 	void SetMyHandicap(float handicap);
@@ -18,28 +18,28 @@
 
 	int CreateUnit(const char* name, float3 pos);
 
-	const UnitDef* GetUnitDef(int unitid);
-	float3 GetUnitPos(int unitid);
+	const UnitDef* GetUnitDef(int unitId);
+	float3 GetUnitPos(int unitId);
 	int GetEnemyUnits(int* units);
 	int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
 	int GetNeutralUnits(int* units);
 	int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
 
-	int GetUnitTeam(int unitid);
-	int GetUnitAllyTeam(int unitid);
-	float GetUnitHealth(int unitid);
-	float GetUnitMaxHealth(int unitid);
-	float GetUnitPower(int unitid);
-	float GetUnitExperience(int unitid);
-	bool IsUnitActivated(int unitid);
-	bool UnitBeingBuilt(int unitid);
-	bool IsUnitNeutral(int unitid);
-	bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
-	const CCommandQueue* GetCurrentUnitCommands(int unitid);
+	int GetUnitTeam(int unitId);
+	int GetUnitAllyTeam(int unitId);
+	float GetUnitHealth(int unitId);
+	float GetUnitMaxHealth(int unitId);
+	float GetUnitPower(int unitId);
+	float GetUnitExperience(int unitId);
+	bool IsUnitActivated(int unitId);
+	bool UnitBeingBuilt(int unitId);
+	bool IsUnitNeutral(int unitId);
+	bool GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo);
+	const CCommandQueue* GetCurrentUnitCommands(int unitId);
 
-	int GetBuildingFacing(int unitid);
-	bool IsUnitCloaked(int unitid);
-	bool IsUnitParalyzed(int unitid);
+	int GetBuildingFacing(int unitId);
+	bool IsUnitCloaked(int unitId);
+	bool IsUnitParalyzed(int unitId);
 
 	bool OnlyPassiveCheats();
 	void EnableCheatEvents(bool enable);

Added: branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,365 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIInterfaceLibrary.h&quot;
+
+#include &quot;Interface/aidefines.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;SkirmishAILibrary.h&quot;
+#include &quot;GroupAILibrary.h&quot;
+
+#include &quot;StdAfx.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+
+#include &lt;string&gt;
+
+
+/*
+CAIInterfaceLibrary::CAIInterfaceLibrary(const CAIInterfaceLibrary&amp; interface) {
+	int loadCount = 0;
+	SAIInterfaceLibrary sAIInterfaceLibrary;wecd
+}
+CAIInterfaceLibrary::CAIInterfaceLibrary(SharedLib* sharedLib) {TODO;}
+*/
+
+CAIInterfaceLibrary::CAIInterfaceLibrary(
+		const SAIInterfaceSpecifyer&amp; interfaceSpecifyer,
+		const std::string&amp; libFileName)
+		: specifyer(interfaceSpecifyer) {
+	
+	std::string libFilePath;
+	
+	if (libFileName.empty()) {
+		libFilePath = GenerateLibFilePath(specifyer);
+	} else {
+		libFilePath = GenerateLibFilePath(libFileName);
+	}
+	
+	sharedLib = SharedLib::Instantiate(libFilePath);
+	if (sharedLib == NULL) {
+		const int MAX_MSG_LENGTH = 511;
+		char s_msg[MAX_MSG_LENGTH + 1];
+		SNPRINTF(s_msg, MAX_MSG_LENGTH,
+				&quot;Error while loading AI Interface Library from file \&quot;%s\&quot;&quot;,
+				libFilePath.c_str());
+		handleerror(NULL, s_msg, &quot;AI Interface Error&quot;, MBF_OK | MBF_EXCL);
+	}
+	
+	InitializeFromLib(libFilePath);
+}
+/*
+CAIInterfaceLibrary::CAIInterfaceLibrary(const std::string&amp; libFileName,
+		const SAIInterfaceSpecifyer&amp; interfaceSpecifyer)
+		: specifyer(interfaceSpecifyer) {
+	
+	std::string libFilePath = GenerateLibFilePath(libFileName);
+	
+	sharedLib = SharedLib::Instantiate(libFilePath);
+	
+	InitializeFromLib(libFilePath);
+*/
+	
+/*
+	std::map&lt;std::string, InfoItem&gt; infos = GetInfos();
+	specifyer.shortName = infos.at(AI_INTERFACE_PROPERTY_SHORT_NAME).value;
+	specifyer.version = infos.at(AI_INTERFACE_PROPERTY_VERSION).value;
+*/
+//}
+
+CAIInterfaceLibrary::~CAIInterfaceLibrary() {
+	delete sharedLib;
+}
+
+SAIInterfaceSpecifyer CAIInterfaceLibrary::GetSpecifyer() const {
+	return specifyer;
+}
+
+LevelOfSupport CAIInterfaceLibrary::GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber) const {
+	
+	if (sAIInterfaceLibrary.getLevelOfSupportFor != NULL) {
+		return sAIInterfaceLibrary.getLevelOfSupportFor(engineVersionString.c_str(), engineVersionNumber);
+	} else {
+		return LOS_Unknown;
+	}
+}
+
+std::map&lt;std::string, InfoItem&gt; CAIInterfaceLibrary::GetInfos() const {
+	
+	std::map&lt;std::string, InfoItem&gt; infos;
+	
+	if (sAIInterfaceLibrary.getInfos != NULL) {
+		InfoItem infs[MAX_INFOS];
+		int num = sAIInterfaceLibrary.getInfos(infs, MAX_INFOS);
+
+		int i;
+		for (i=0; i &lt; num; ++i) {
+			InfoItem newII = copyInfoItem(&amp;infs[i]);
+			infos[std::string(newII.key)] = newII;
+		}
+	}
+
+	return infos;
+}
+
+int CAIInterfaceLibrary::GetLoadCount() const {
+	
+	int totalSkirmishAILibraryLoadCount = 0;
+	std::map&lt;const SSAISpecifyer, int&gt;::const_iterator salc;
+	for (salc=skirmishAILoadCount.begin();  salc != skirmishAILoadCount.end(); salc++) {
+		totalSkirmishAILibraryLoadCount += salc-&gt;second;
+	}
+	
+	int totalGroupAILibraryLoadCount = 0;
+	std::map&lt;const SGAISpecifyer, int&gt;::const_iterator galc;
+	for (galc=groupAILoadCount.begin();  galc != groupAILoadCount.end(); galc++) {
+		totalGroupAILibraryLoadCount += galc-&gt;second;
+	}
+	
+	return totalSkirmishAILibraryLoadCount + totalGroupAILibraryLoadCount;
+}
+
+
+// Skirmish AI methods
+std::vector&lt;SSAISpecifyer&gt; CAIInterfaceLibrary::GetSkirmishAILibrarySpecifyers() const {
+	
+	std::vector&lt;SSAISpecifyer&gt; specs;
+	
+	int max = 128;
+	SSAISpecifyer specifyers[max];
+	int num = sAIInterfaceLibrary.getSkirmishAISpecifyers(specifyers, max);
+    for (int i=0; i &lt; num; ++i) {
+        specs.push_back(specifyers[i]);
+    }
+	
+	return specs;
+}
+const ISkirmishAILibrary* CAIInterfaceLibrary::FetchSkirmishAILibrary(const SSAISpecifyer&amp; sAISpecifyer) {
+	
+	ISkirmishAILibrary* ai = NULL;
+	
+	if (skirmishAILoadCount[sAISpecifyer] == 0) {
+		const SSAILibrary* sLib = sAIInterfaceLibrary.loadSkirmishAILibrary(&amp;sAISpecifyer);
+		ai = new CSkirmishAILibrary(*sLib, sAISpecifyer);
+		loadedSkirmishAILibraries[sAISpecifyer] = ai;
+	} else {
+		ai = loadedSkirmishAILibraries[sAISpecifyer];
+	}
+	
+	skirmishAILoadCount[sAISpecifyer]++;
+	
+	return ai;
+}
+int CAIInterfaceLibrary::ReleaseSkirmishAILibrary(const SSAISpecifyer&amp; sAISpecifyer) {
+	
+	if (skirmishAILoadCount[sAISpecifyer] == 0) {
+		return 0;
+	}
+	
+	skirmishAILoadCount[sAISpecifyer]--;
+	
+	if (skirmishAILoadCount[sAISpecifyer] == 0) {
+		loadedSkirmishAILibraries.erase(sAISpecifyer);
+		sAIInterfaceLibrary.unloadSkirmishAILibrary(&amp;sAISpecifyer);
+	}
+	
+	return skirmishAILoadCount[sAISpecifyer];
+}
+int CAIInterfaceLibrary::GetSkirmishAILibraryLoadCount(const SSAISpecifyer&amp; sAISpecifyer) const {
+	return skirmishAILoadCount.at(sAISpecifyer);
+}
+int CAIInterfaceLibrary::ReleaseAllSkirmishAILibraries() {
+	
+	int releasedAIs = sAIInterfaceLibrary.unloadAllSkirmishAILibraries();
+	loadedSkirmishAILibraries.clear();
+	skirmishAILoadCount.clear();
+	
+	return releasedAIs;
+}
+
+
+
+// Group AI methods
+std::vector&lt;SGAISpecifyer&gt; CAIInterfaceLibrary::GetGroupAILibrarySpecifyers() const {
+	
+	std::vector&lt;SGAISpecifyer&gt; specs;
+	
+	int max = 128;
+	SGAISpecifyer specifyers[max];
+	int num = sAIInterfaceLibrary.getGroupAISpecifyers(specifyers, max);
+    for (int i=0; i &lt; num; ++i) {
+        specs.push_back(specifyers[i]);
+    }
+	
+	return specs;
+}
+const IGroupAILibrary* CAIInterfaceLibrary::FetchGroupAILibrary(const SGAISpecifyer&amp; gAISpecifyer) {
+	
+	IGroupAILibrary* ai = NULL;
+	
+	if (groupAILoadCount[gAISpecifyer] == 0) {
+		const SGAILibrary* gLib = sAIInterfaceLibrary.loadGroupAILibrary(&amp;gAISpecifyer);
+		ai = new CGroupAILibrary(*gLib);
+		loadedGroupAILibraries[gAISpecifyer] = ai;
+	} else {
+		ai = loadedGroupAILibraries[gAISpecifyer];
+	}
+	
+	groupAILoadCount[gAISpecifyer]++;
+	
+	return ai;
+}
+int CAIInterfaceLibrary::ReleaseGroupAILibrary(const SGAISpecifyer&amp; gAISpecifyer) {
+	
+	if (groupAILoadCount[gAISpecifyer] == 0) {
+		return 0;
+	}
+	
+	groupAILoadCount[gAISpecifyer]--;
+	
+	if (groupAILoadCount[gAISpecifyer] == 0) {
+		loadedGroupAILibraries.erase(gAISpecifyer);
+		sAIInterfaceLibrary.unloadGroupAILibrary(&amp;gAISpecifyer);
+	}
+	
+	return groupAILoadCount[gAISpecifyer];
+}
+int CAIInterfaceLibrary::GetGroupAILibraryLoadCount(const SGAISpecifyer&amp; gAISpecifyer) const {
+	return groupAILoadCount.at(gAISpecifyer);
+}
+int CAIInterfaceLibrary::ReleaseAllGroupAILibraries() {
+	
+	int releasedAIs = sAIInterfaceLibrary.unloadAllGroupAILibraries();
+	loadedGroupAILibraries.clear();
+	groupAILoadCount.clear();
+	
+	return releasedAIs;
+}
+	
+	
+
+void CAIInterfaceLibrary::reportInterfaceFunctionError(const std::string* libFileName, const std::string* functionName) {
+	
+	const int MAX_MSG_LENGTH = 511;
+	char s_msg[MAX_MSG_LENGTH + 1];
+	SNPRINTF(s_msg, MAX_MSG_LENGTH,
+			&quot;Error loading AI Interface Library from file \&quot;%s\&quot;: no \&quot;%s\&quot; function exported&quot;,
+			libFileName-&gt;c_str(), functionName-&gt;c_str());
+	handleerror(NULL, s_msg, &quot;AI Interface Error&quot;, MBF_OK | MBF_EXCL);
+}
+int CAIInterfaceLibrary::InitializeFromLib(const std::string&amp; libFilePath) {
+	
+    // TODO: version checking
+	
+	std::string funcName;
+	
+	funcName = &quot;getInfos&quot;;
+    sAIInterfaceLibrary.getInfos = (int (CALLING_CONV *)(InfoItem[], int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.getInfos == NULL) {
+		// do nothing: this is permitted, if the AI supplies infos through an AIInfo.lua file
+		//reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        //return -1;
+    }
+	
+	funcName = &quot;getLevelOfSupportFor&quot;;
+    sAIInterfaceLibrary.getLevelOfSupportFor = (LevelOfSupport (CALLING_CONV *)(const char*, int)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.getLevelOfSupportFor == NULL) {
+		// do nothing: it is permitted that an AI does not export this function
+		//reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        //return -2;
+    }
+	
+	funcName = &quot;getSkirmishAISpecifyers&quot;;
+    sAIInterfaceLibrary.getSkirmishAISpecifyers = (int (CALLING_CONV *)(SSAISpecifyer*, int max)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.getSkirmishAISpecifyers == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -3;
+    }
+	
+	funcName = &quot;loadSkirmishAILibrary&quot;;
+    sAIInterfaceLibrary.loadSkirmishAILibrary = (const SSAILibrary* (CALLING_CONV *)(const SSAISpecifyer* const)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.loadSkirmishAILibrary == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -4;
+    }
+	
+	funcName = &quot;unloadSkirmishAILibrary&quot;;
+    sAIInterfaceLibrary.unloadSkirmishAILibrary = (int (CALLING_CONV *)(const SSAISpecifyer* const)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.unloadSkirmishAILibrary == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -5;
+    }
+	
+	funcName = &quot;unloadAllSkirmishAILibraries&quot;;
+    sAIInterfaceLibrary.unloadAllSkirmishAILibraries = (int (CALLING_CONV *)()) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.unloadAllSkirmishAILibraries == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -6;
+    }
+	
+	funcName = &quot;getGroupAISpecifyers&quot;;
+    sAIInterfaceLibrary.getGroupAISpecifyers = (int (CALLING_CONV *)(SGAISpecifyer*, int max)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.getGroupAISpecifyers == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -7;
+    }
+	
+	funcName = &quot;loadGroupAILibrary&quot;;
+    sAIInterfaceLibrary.loadGroupAILibrary = (const SGAILibrary* (CALLING_CONV *)(const SGAISpecifyer* const)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.loadGroupAILibrary == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -8;
+    }
+	
+	funcName = &quot;unloadGroupAILibrary&quot;;
+    sAIInterfaceLibrary.unloadGroupAILibrary = (int (CALLING_CONV *)(const SGAISpecifyer* const)) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.unloadGroupAILibrary == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -9;
+    }
+	
+	funcName = &quot;unloadAllGroupAILibraries&quot;;
+    sAIInterfaceLibrary.unloadAllGroupAILibraries = (int (CALLING_CONV *)()) sharedLib-&gt;FindAddress(funcName.c_str());
+    if (sAIInterfaceLibrary.unloadAllGroupAILibraries == NULL) {
+		reportInterfaceFunctionError(&amp;libFilePath, &amp;funcName);
+        return -10;
+    }
+	
+	return 0;
+}
+
+
+std::string CAIInterfaceLibrary::GenerateLibFilePath(const std::string&amp; libFileName) {
+	return std::string(PATH_TO_SPRING_HOME) +
+			std::string(AI_INTERFACES_IMPLS_DIR) // eg AI/Interfaces/impls
+			.append(&quot;/&quot;)
+			.append(libFileName) // eg. Java-0.600
+			.append(&quot;.&quot;)
+			.append(SharedLib::GetLibExtension()); // eg. dll
+}
+
+std::string CAIInterfaceLibrary::GenerateLibFilePath(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) {
+	
+	std::string libFileName = std::string(interfaceSpecifyer.shortName) // eg. Java
+			.append(&quot;-&quot;)
+			.append(interfaceSpecifyer.version); // eg. 0.600
+#ifndef _WIN32
+	libFileName = &quot;lib&quot; + libFileName;
+#endif
+	return GenerateLibFilePath(libFileName);
+}
+


Property changes on: branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,83 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIINTERFACELIBRARY_H
+#define	_AIINTERFACELIBRARY_H
+
+#include &quot;IAIInterfaceLibrary.h&quot;
+
+#include &quot;Platform/SharedLib.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+
+class CAIInterfaceLibrary : public IAIInterfaceLibrary {
+public:
+//	CAIInterfaceLibrary(const CAIInterfaceLibrary&amp; interface);
+//	CAIInterfaceLibrary(const std::string&amp; libFileName);
+	CAIInterfaceLibrary(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer, const std::string&amp; libFileName = &quot;&quot;);
+	//CAIInterfaceLibrary(const std::string&amp; libFileName, const SAIInterfaceSpecifyer&amp; interfaceSpecifyer);
+	virtual ~CAIInterfaceLibrary();
+	
+//	static CAIInterfaceLibrary* Load(const std::string&amp; libFileName); // increments load counter
+//	static CAIInterfaceLibrary* Get(const std::string&amp; shortName, const std::string&amp; version); // does not increment load counter
+	
+	virtual SAIInterfaceSpecifyer GetSpecifyer() const;
+	virtual LevelOfSupport GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber) const;
+	
+//    virtual std::string GetProperty(const std::string&amp; propertyName) const;
+    virtual std::map&lt;std::string, InfoItem&gt; GetInfos() const;
+	virtual int GetLoadCount() const;
+	
+	// Skirmish AI methods
+	virtual std::vector&lt;SSAISpecifyer&gt; GetSkirmishAILibrarySpecifyers() const;
+	virtual const ISkirmishAILibrary* FetchSkirmishAILibrary(const SSAISpecifyer&amp; sAISpecifyer);
+	virtual int ReleaseSkirmishAILibrary(const SSAISpecifyer&amp; sAISpecifyer);
+	virtual int GetSkirmishAILibraryLoadCount(const SSAISpecifyer&amp; sAISpecifyer) const;
+	virtual int ReleaseAllSkirmishAILibraries();
+	
+	// Group AI methods
+	virtual std::vector&lt;SGAISpecifyer&gt; GetGroupAILibrarySpecifyers() const;
+	virtual const IGroupAILibrary* FetchGroupAILibrary(const SGAISpecifyer&amp; gAISpecifyer);
+	virtual int ReleaseGroupAILibrary(const SGAISpecifyer&amp; gAISpecifyer);
+	virtual int GetGroupAILibraryLoadCount(const SGAISpecifyer&amp; gAISpecifyer) const;
+	virtual int ReleaseAllGroupAILibraries();
+	
+private:
+//	static s_assoc&lt;const std::string, const std::string&gt; specifyers; // &quot;libFileName&quot; -&gt; &quot;shortName#version&quot;
+//	static s_assoc&lt;const std::string, CSkirmishAILibraryInterface&gt;::map interfaces; // &quot;shortName#version&quot; -&gt; interface
+	
+private:
+	SharedLib* sharedLib;
+	SAIInterfaceLibrary sAIInterfaceLibrary;
+	SAIInterfaceSpecifyer specifyer;
+	std::map&lt;const SSAISpecifyer, ISkirmishAILibrary*, SSAISpecifyer_Comparator&gt; loadedSkirmishAILibraries;
+	std::map&lt;const SSAISpecifyer, int, SSAISpecifyer_Comparator&gt; skirmishAILoadCount;
+	std::map&lt;const SGAISpecifyer, IGroupAILibrary*, SGAISpecifyer_Comparator&gt; loadedGroupAILibraries;
+	std::map&lt;const SGAISpecifyer, int, SGAISpecifyer_Comparator&gt; groupAILoadCount;
+	
+private:
+	static const int MAX_INFOS = 128;
+	
+	static void reportInterfaceFunctionError(const std::string* libFileName, const std::string* functionName);
+	int InitializeFromLib(const std::string&amp; libFilePath);
+	
+	static std::string GenerateLibFilePath(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer);
+	static std::string GenerateLibFilePath(const std::string&amp; libFileName);
+};
+
+#endif	/* _AIINTERFACELIBRARY_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/AIInterfaceLibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,144 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIInterfaceLibraryInfo.h&quot;
+
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;IAIInterfaceLibrary.h&quot;
+#include &quot;Interface/aidefines.h&quot;
+#include &quot;Interface/SInfo.h&quot;
+#include &quot;StdAfx.h&quot;
+#include &quot;LogOutput.h&quot;
+
+CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(const IAIInterfaceLibrary&amp; interface) {
+	infos = interface.GetInfos();
+	levelOfSupport = interface.GetLevelOfSupportFor(std::string(ENGINE_VERSION_STRING),
+			ENGINE_VERSION_NUMBER);
+}
+
+CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(const CAIInterfaceLibraryInfo&amp; interfaceInfo) {
+	infos = std::map&lt;std::string, InfoItem&gt;(
+			interfaceInfo.infos.begin(),
+			interfaceInfo.infos.end());
+	levelOfSupport = interfaceInfo.levelOfSupport;
+}
+
+CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
+		const std::string&amp; interfaceInfoFile,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes) {
+	
+	//std::vector&lt;InfoItem&gt; tmpInfos = ParseInfos(interfaceInfoFile, fileModes, accessModes);
+	InfoItem tmpInfos[MAX_INFOS];
+	unsigned int num = ParseInfos(interfaceInfoFile.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfos, MAX_INFOS);
+/*
+	std::vector&lt;InfoItem&gt;::iterator i;
+    for (i = tmpInfos.begin(); i != tmpInfos.end(); ++i) {
+		infos[std::string(i-&gt;key)] = *i;
+    }
+*/
+    for (unsigned int i=0; i &lt; num; ++i) {
+		logOutput.Print(&quot;info %i: %s / %s / %s&quot;, i, tmpInfos[i].key, tmpInfos[i].value, tmpInfos[i].desc);
+		infos[std::string(tmpInfos[i].key)] = copyInfoItem(&amp;(tmpInfos[i]));
+    }
+	
+	levelOfSupport = LOS_Unknown;
+}
+
+LevelOfSupport CAIInterfaceLibraryInfo::GetLevelOfSupportForCurrentEngine() const {
+	return levelOfSupport;
+}
+
+std::string CAIInterfaceLibraryInfo::GetFileName() const {
+	return GetInfo(AI_INTERFACE_PROPERTY_FILE_NAME);
+}
+std::string CAIInterfaceLibraryInfo::GetShortName() const {
+	return GetInfo(AI_INTERFACE_PROPERTY_SHORT_NAME);
+}
+std::string CAIInterfaceLibraryInfo::GetVersion() const {
+	return GetInfo(AI_INTERFACE_PROPERTY_VERSION);
+}
+std::string CAIInterfaceLibraryInfo::GetName() const {
+	return GetInfo(AI_INTERFACE_PROPERTY_NAME);
+}
+std::string CAIInterfaceLibraryInfo::GetDescription() const {
+	return GetInfo(AI_INTERFACE_PROPERTY_DESCRIPTION);
+}
+std::string CAIInterfaceLibraryInfo::GetURL() const {
+	return GetInfo(AI_INTERFACE_PROPERTY_URL);
+}
+std::string CAIInterfaceLibraryInfo::GetInfo(const std::string&amp; key) const {
+	
+	if (infos.find(key) == infos.end()) {
+		std::string tmp = std::string(&quot;numInfos: &quot;);
+		tmp += IntToString(infos.size());
+		tmp += &quot;\n&quot;;
+		std::map&lt;std::string, InfoItem&gt;::const_iterator it = infos.begin();
+		for (unsigned int i=0; it != infos.end(); ++i, ++it) {
+            tmp += &quot;info &quot;;
+			tmp += IntToString(i);
+			tmp += &quot;: &quot;;
+			tmp += it-&gt;first;
+			tmp += &quot; / &quot;;
+			tmp += it-&gt;second.value;
+			tmp += &quot;\n&quot;;
+        }
+		tmp += &quot;shortName: &quot;;
+		tmp += infos.at(std::string(AI_INTERFACE_PROPERTY_SHORT_NAME)).value;
+		tmp += &quot;\n&quot;;
+
+		handleerror(NULL, std::string(&quot;AI interface property '&quot;).append(key).append(&quot;' can not be found&quot;).append(&quot;\n&quot;).append(tmp).c_str(), &quot;IntefaceInfo Error&quot;, MBF_OK | MBF_EXCL);
+	}
+	return infos.at(key).value;
+}
+const std::map&lt;std::string, InfoItem&gt;* CAIInterfaceLibraryInfo::GetInfos() const {
+	return &infos;
+}
+
+
+void CAIInterfaceLibraryInfo::SetFileName(const std::string&amp; fileName) {
+	SetInfo(AI_INTERFACE_PROPERTY_FILE_NAME, fileName);
+}
+void CAIInterfaceLibraryInfo::SetShortName(const std::string&amp; shortName) {
+	SetInfo(AI_INTERFACE_PROPERTY_SHORT_NAME, shortName);
+}
+void CAIInterfaceLibraryInfo::SetVersion(const std::string&amp; version) {
+	SetInfo(AI_INTERFACE_PROPERTY_VERSION, version);
+}
+void CAIInterfaceLibraryInfo::SetName(const std::string&amp; name) {
+	SetInfo(AI_INTERFACE_PROPERTY_NAME, name);
+}
+void CAIInterfaceLibraryInfo::SetDescription(const std::string&amp; description) {
+	SetInfo(AI_INTERFACE_PROPERTY_DESCRIPTION, description);
+}
+void CAIInterfaceLibraryInfo::SetURL(const std::string&amp; url) {
+	SetInfo(AI_INTERFACE_PROPERTY_URL, url);
+}
+bool CAIInterfaceLibraryInfo::SetInfo(const std::string&amp; key, const std::string&amp; value) {
+	
+	if (key == AI_INTERFACE_PROPERTY_SHORT_NAME ||
+			key == AI_INTERFACE_PROPERTY_VERSION) {
+		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
+			handleerror(NULL, &quot;AI interface property (shortName or version) contains illegal characters ('_', '#' or white spaces)&quot;, &quot;IntefaceInfo Error&quot;, MBF_OK | MBF_EXCL);
+			return false;
+		}
+	}
+	
+	InfoItem ii = {key.c_str(), value.c_str(), NULL};
+	infos[key] = ii;
+	return true;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,63 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIINTERFACELIBRARYINFO_H
+#define	_AIINTERFACELIBRARYINFO_H
+
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class IAIInterfaceLibrary;
+struct InfoItem;
+
+class CAIInterfaceLibraryInfo {
+public:
+	CAIInterfaceLibraryInfo(const IAIInterfaceLibrary&amp; interface);
+	CAIInterfaceLibraryInfo(const CAIInterfaceLibraryInfo&amp; interfaceInfo);
+	CAIInterfaceLibraryInfo(const std::string&amp; interfaceInfoFile,
+			const std::string&amp; fileModes,
+			const std::string&amp; accessModes);
+    
+    virtual LevelOfSupport GetLevelOfSupportForCurrentEngine() const;
+    
+    virtual std::string GetFileName() const; // when the AI is &quot;libRAI-0.600.so&quot; or &quot;RAI-0.600.dll&quot;, this value should be &quot;RAI-0.600&quot;
+    virtual std::string GetShortName() const; // restrictions: none of the following: spaces, '_', '#'
+    virtual std::string GetVersion() const; // restrictions: none of the following: spaces, '_', '#'
+    virtual std::string GetName() const;
+    virtual std::string GetDescription() const;
+    virtual std::string GetURL() const;
+    virtual std::string GetInfo(const std::string&amp; key) const;
+    virtual const std::map&lt;std::string, InfoItem&gt;* GetInfos() const;
+	
+    virtual void SetFileName(const std::string&amp; fileName); // when the AI is &quot;libRAI-0.600.so&quot; or &quot;RAI-0.600.dll&quot;, this value should be &quot;RAI-0.600&quot;
+    virtual void SetShortName(const std::string&amp; shortName); // restrictions: none of the following: spaces, '_', '#'
+    virtual void SetVersion(const std::string&amp; version); // restrictions: none of the following: spaces, '_', '#'
+    virtual void SetName(const std::string&amp; name);
+    virtual void SetDescription(const std::string&amp; description);
+    virtual void SetURL(const std::string&amp; url);
+    virtual bool SetInfo(const std::string&amp; key, const std::string&amp; value);
+	
+private:
+	static const unsigned int MAX_INFOS = 128;
+	std::map&lt;std::string, InfoItem&gt; infos;
+	LevelOfSupport levelOfSupport;
+};
+
+#endif	/* _AIINTERFACELIBRARYINFO_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/ExternalAI/AILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibrary.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AILibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -72,7 +72,7 @@
     }
 }
 
-int CAILibrary::handleEvent(int eventID, void* event) {
-    _handleEvent(team, eventID, event);
+int CAILibrary::handleEvent(int topic, void* data) {
+	return _handleEvent(team, topic, data);
 }
 

Modified: branches/caiinterface/rts/ExternalAI/AILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibrary.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -28,12 +28,12 @@
 class CAILibrary {
 public:
     
-    CAILibrary(const char* libName,  int team);
+    CAILibrary(const char* libName, int team);
     ~CAILibrary();
     
     void init();
     
-    int handleEvent(int eventID, void* event);
+    int handleEvent(int topic, void* data);
     
     typedef void (*AI_INIT)(int);
     AI_INIT _init;

Deleted: branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,192 +0,0 @@
-/*
-	Copyright 2008  Nicolas Wu
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;AISCommands.h&quot;
-
-
-#include &quot;AILibraryGlobalAI.h&quot;
-#include &quot;AISEvents.h&quot;
-#include &quot;GlobalAICallback.h&quot;
-//#include &quot;SGlobalAICallback.h&quot;
-#include &quot;SAICallback.h&quot;
-#include &quot;float3.h&quot;
-#include &quot;SAIFloat3.h&quot;
-
-#include &lt;iostream&gt;
-
-//SGlobalAICallback* initSGlobalAICallback(int teamId, IGlobalAICallback* globalAICallback);
-SAICallback* initSAICallback(int teamId, IGlobalAICallback* aiGlobalCallback); // defined in &quot;SGlobalAICallback.cpp&quot;
-
-CAILibraryGlobalAI::CAILibraryGlobalAI(const char* libName, int team)  : CAILibrary(libName, team)
-{
-	CGlobalAI::team = team;
-	
-	ai = this;  
-	callback = new CGlobalAICallback(this);
-	InitAI(callback, team);
-}
-
-CAILibraryGlobalAI::~CAILibraryGlobalAI() {
-	delete callback;
-	ai = 0;
-}
-
-// This is the inherited interface from CGlobalAI, we don't
-// wish to do anything here.
-
-void CAILibraryGlobalAI::LoadAILib(int, const char*, bool) {
-}
-void CAILibraryGlobalAI::Serialize(creg::ISerializer *s) {
-}
-void CAILibraryGlobalAI::PostLoad() {
-}
-void CAILibraryGlobalAI::Load(std::istream *s) {
-}
-void CAILibraryGlobalAI::PreDestroy() {} 
-
-// This is the inherited interface from IGlobalAI
-void CAILibraryGlobalAI::InitAI(IGlobalAICallback* callback, int team) {
-//	SGlobalAICallback* c_callback = initSGlobalAICallback(team, callback);
-	SAICallback* c_callback = initSAICallback(team, callback);
-	SInitEvent event = {team, c_callback};
-	handleEvent(EVENT_INIT, &amp;event);
-}
-
-void CAILibraryGlobalAI::Update() {
-	SUpdateEvent event = {0};
-	handleEvent(EVENT_UPDATE, &amp;event);
-}
-
-void CAILibraryGlobalAI::Load(IGlobalAICallback* callback, std::istream *s) {
-	//TODO
-}
-
-void CAILibraryGlobalAI::Save(std::ostream *s) {
-	//TODO
-}
-
-// NOTE: this isn't the same as handleEvent, it's the one that's been inherited.
-int CAILibraryGlobalAI::HandleEvent(int aiEventId, const void *data) {
-
-	switch (aiEventId) {
-		case AI_EVENT_UNITGIVEN:
-		{
-			ChangeTeamEvent* evt = (ChangeTeamEvent*) data;
-			SUnitGivenEvent sEvent = {evt-&gt;unit, evt-&gt;oldteam, evt-&gt;newteam};
-			return handleEvent(EVENT_UNIT_GIVEN, &amp;sEvent);
-		}
-		case AI_EVENT_UNITCAPTURED:
-		{
-			ChangeTeamEvent* evt = (ChangeTeamEvent*) data;
-			SUnitCapturedEvent sEvent = {evt-&gt;unit, evt-&gt;oldteam, evt-&gt;newteam};
-			return handleEvent(EVENT_UNIT_CAPTURED, &amp;sEvent);
-		}
-		case AI_EVENT_WEAPON_FIRED:
-		{
-			WeaponFireEvent* evt = (WeaponFireEvent*) data;
-			SWeaponFiredEvent sEvent = {evt-&gt;unit, evt-&gt;def-&gt;id};
-			return handleEvent(EVENT_WEAPON_FIRED, &amp;sEvent);
-		}
-		case AI_EVENT_PLAYER_COMMAND:
-		{
-			PlayerCommandEvent* evt = (PlayerCommandEvent*) data;
-			int numUnits = evt-&gt;units.size();
-			int unitIds[numUnits];
-			int i;
-            for (i=0; i &lt; numUnits; ++i) {
-                unitIds[i] = evt-&gt;units.at(i);
-            }
-            int sCommandId;
-            void* sCommandData = mallocSUnitCommand(-1, -1, &amp;(evt-&gt;command), &amp;sCommandId);
-			SPlayerCommandEvent sEvent = {unitIds, numUnits, sCommandId, sCommandData, evt-&gt;player};
-			return handleEvent(EVENT_PLAYER_COMMAND, &amp;sEvent);
-		}
-		case AI_EVENT_SEISMIC_PING:
-		{
-			SeismicPingEvent* evt = (SeismicPingEvent*) data;
-			SSeismicPingEvent sEvent = {evt-&gt;pos.toSAIFloat3(), evt-&gt;strength};
-			return handleEvent(EVENT_SEISMIC_PING, &amp;sEvent);
-		}
-		default:
-			return 0;
-	}
-}
-
-
-void CAILibraryGlobalAI::GotChatMsg(const char* message,int player) {
-	SMessageEvent event = {player, message};
-	handleEvent(EVENT_MESSAGE, &amp;event);
-}
-
-void CAILibraryGlobalAI::UnitCreated(int unit) {
-	SUnitCreatedEvent event = {unit};
-	handleEvent(EVENT_UNIT_CREATED, &amp;event);
-}
-
-void CAILibraryGlobalAI::UnitFinished(int unit) {
-	SUnitFinishedEvent event = {unit};
-	handleEvent(EVENT_UNIT_FINISHED, &amp;event);
-}
-
-void CAILibraryGlobalAI::UnitIdle(int unit) {
-	SUnitIdleEvent event = {unit};
-	handleEvent(EVENT_UNIT_IDLE, &amp;event);
-}
-
-void CAILibraryGlobalAI::UnitMoveFailed(int unit) {
-	SUnitMoveFailedEvent event = {unit};
-	handleEvent(EVENT_UNIT_MOVE_FAILED, &amp;event);
-}
-
-void CAILibraryGlobalAI::UnitDamaged(int unit,int attacker,float damage, float3 dir) {
-	SUnitDamagedEvent event = {unit, attacker, damage, dir.toSAIFloat3()};
-	handleEvent(EVENT_UNIT_DAMAGED, &amp;event);
-}
-
-void CAILibraryGlobalAI::UnitDestroyed(int unit, int attacker) {
-	SUnitDestroyedEvent event = {unit, attacker};
-	handleEvent(EVENT_UNIT_DESTROYED, &amp;event);
-}
-
-void CAILibraryGlobalAI::EnemyEnterLOS(int enemy) {
-	SEnemyEnterLOSEvent event = {enemy};
-	handleEvent(EVENT_ENEMY_ENTER_LOS, &amp;event);
-}
-
-void CAILibraryGlobalAI::EnemyLeaveLOS(int enemy) {
-	SEnemyLeaveLOSEvent event = {enemy};
-	handleEvent(EVENT_ENEMY_LEAVE_LOS, &amp;event);
-}
-
-void CAILibraryGlobalAI::EnemyEnterRadar(int enemy) {
-	SEnemyEnterRadarEvent event = {enemy};
-	handleEvent(EVENT_ENEMY_ENTER_RADAR, &amp;event);
-}
-void CAILibraryGlobalAI::EnemyLeaveRadar(int enemy) {
-	SEnemyLeaveRadarEvent event = {enemy};
-	handleEvent(EVENT_ENEMY_LEAVE_RADAR, &amp;event);
-}
-
-void CAILibraryGlobalAI::EnemyDamaged(int enemy,int attacker,float damage,float3 dir) {
-	SEnemyDamagedEvent event = {enemy, attacker, damage, dir.toSAIFloat3()};
-	handleEvent(EVENT_ENEMY_DAMAGED, &amp;event);
-}
-
-void CAILibraryGlobalAI::EnemyDestroyed(int enemy, int attacker) {
-	SEnemyDestroyedEvent event = {enemy, attacker};
-	handleEvent(EVENT_ENEMY_DESTROYED, &amp;event);
-}

Deleted: branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AILibraryGlobalAI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,67 +0,0 @@
-/*
-	Copyright 2008  Nicolas Wu
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef AILIBRARYGLOBALAI_H
-#define AILIBRARYGLOBALAI_H
-
-
-// This class extends GlobalAI, but implements the
-// AILibrary interface, which means it can deal with 
-// the new AI interface.
-
-// Unfortunately, GlobalAIHandler uses the ai parameter of CGlobalAI,
-// and so expects to use the IGlobalAI object.
-// We get around this by implementing all the IGlobalAI interface here
-// as well, and setting ai to this.
-
-#include &quot;AILibrary.h&quot;
-#include &quot;GlobalAI.h&quot;
-#include &quot;IGlobalAI.h&quot;
-
-class CAILibraryGlobalAI : public CGlobalAI, public IGlobalAI, public CAILibrary {
-	
-public:
-	CAILibraryGlobalAI(const char* libName, int team);
-	~CAILibraryGlobalAI();
-	
-	virtual void LoadAILib(int team, const char* libName, bool postLoad);
-	virtual void Serialize(creg::ISerializer*);
-	virtual void PostLoad();
-	virtual void Load(std::istream *s);
-	virtual void PreDestroy();
-	
-	virtual void InitAI(IGlobalAICallback* callback, int team);
-	virtual void UnitCreated(int unit);
-	virtual void UnitFinished(int unit);
-	virtual void UnitDestroyed(int unit, int attacker);
-	virtual void EnemyEnterLOS(int enemy);
-	virtual void EnemyLeaveLOS(int enemy);
-	virtual void EnemyEnterRadar(int enemy);
-	virtual void EnemyLeaveRadar(int enemy);
-	virtual void EnemyDamaged(int damaged,int attacker,float damage,float3 dir);
-	virtual void EnemyDestroyed(int enemy, int attacker);
-	virtual void UnitIdle(int unit);
-	virtual void GotChatMsg(const char* msg,int player);
-	virtual void UnitDamaged(int damaged,int attacker,float damage,float3 dir);
-	virtual void UnitMoveFailed(int unit);
-	virtual int HandleEvent (int msg, const void *data);
-	virtual void Update();
-	virtual void Load(IGlobalAICallback* callback,std::istream *s);
-	virtual void Save(std::ostream *s);
-};
-
-#endif /*AILIBRARYGLOBALAI_H*/

Added: branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,693 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AILibraryManager.h&quot;
+
+#include &quot;Interface/aidefines.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;AIInterfaceLibraryInfo.h&quot;
+#include &quot;AIInterfaceLibrary.h&quot;
+#include &quot;SkirmishAILibraryInfo.h&quot;
+
+#include &lt;boost/filesystem.hpp&gt;
+#include &quot;StdAfx.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;LogOutput.h&quot;
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &lt;sstream&gt;
+#include &lt;vector&gt;
+#include &lt;limits&gt;
+//#include &lt;fstream&gt;
+#include &lt;string.h&gt;
+
+
+void CAILibraryManager::reportError(const char* topic, const char* msg) {
+	handleerror(NULL, msg, topic, MBF_OK | MBF_EXCL);
+}
+void CAILibraryManager::reportError1(const char* topic, const char* msg, const char* arg0) {
+	
+	const int MAX_MSG_LENGTH = 511;
+	char s_msg[MAX_MSG_LENGTH + 1];
+	SNPRINTF(s_msg, MAX_MSG_LENGTH, msg, arg0);
+	reportError(topic, s_msg);
+}
+void CAILibraryManager::reportError2(const char* topic, const char* msg, const char* arg0, const char* arg1) {
+	
+	const int MAX_MSG_LENGTH = 511;
+	char s_msg[MAX_MSG_LENGTH + 1];
+	SNPRINTF(s_msg, MAX_MSG_LENGTH, msg, arg0, arg1);
+	reportError(topic, s_msg);
+}
+
+std::string CAILibraryManager::extractFileName(const std::string&amp; libFile, bool includeExtension) {
+	
+	std::string::size_type firstChar = libFile.find_last_of(&quot;/\\&quot;);
+	std::string::size_type lastChar = std::string::npos;
+	if (!includeExtension) {
+		lastChar = libFile.find_last_of('.');
+	}
+	
+	return libFile.substr(firstChar+1, lastChar - firstChar -1);
+}
+
+CAILibraryManager::CAILibraryManager() {
+	//GetAllInfosFromLibraries();
+	GetAllInfosFromCache();
+}
+
+/*
+void CAILibraryManager::GetAllInfosFromLibraries() {
+	
+	ClearAllInfos();
+	
+	// look for AI interface library files
+	std::vector&lt;std::string&gt; interfaceLibFiles =
+			FindFiles(std::string(PATH_TO_SPRING_HOME) +
+			std::string(&quot;&quot;) + AI_INTERFACES_IMPLS_DIR,
+			std::string(&quot;.&quot;) + SharedLib::GetLibExtension());
+	
+	// initialize the interface infos
+	std::vector&lt;std::string&gt;::const_iterator libFile;
+	for (libFile=interfaceLibFiles.begin(); libFile!=interfaceLibFiles.end(); libFile++) { // interfaces
+		
+		std::string fileName = std::string(extractFileName(*libFile, false));
+		
+		// load the interface
+		IAIInterfaceLibrary* interfaceLib = new CAIInterfaceLibrary(fileName);
+		if (interfaceLib == NULL) {
+			reportError1(&quot;AI Error&quot;,
+					&quot;Failed to load interface shared library \&quot;%s\&quot;&quot;,
+					libFile-&gt;c_str());
+		}
+		
+		SAIInterfaceSpecifyer interfaceSpecifyer = interfaceLib-&gt;GetSpecifyer();
+		interfaceSpecifyer = copySAIInterfaceSpecifyer(&amp;interfaceSpecifyer);
+		interfaceSpecifyers.push_back(interfaceSpecifyer);
+		
+		// generate and store the interface info
+		CAIInterfaceLibraryInfo* interfaceInfo = new CAIInterfaceLibraryInfo(*interfaceLib);
+		interfaceInfos[interfaceSpecifyer] = interfaceInfo;
+		
+		// generate and store the pure file name
+		//interfaceFileNames[interfaceSpecifyer] = fileName;
+		interfaceInfo-&gt;SetFileName(fileName);
+		
+		// fetch the info of all Skirmish AIs available through the interface
+		std::vector&lt;SSAISpecifyer&gt; sass = interfaceLib-&gt;GetSkirmishAILibrarySpecifyers();
+		std::vector&lt;SSAISpecifyer&gt;::const_iterator sas;
+		for (sas=sass.begin(); sas!=sass.end(); sas++) { // AIs
+			const ISkirmishAILibrary* skirmishAI = interfaceLib-&gt;FetchSkirmishAILibrary(*sas);
+			CSkirmishAILibraryInfo* skirmishAIInfo = new CSkirmishAILibraryInfo(*skirmishAI, interfaceSpecifyer);
+			SSAIKey skirmishAIKey = {interfaceSpecifyer, copySSAISpecifyer(&amp;(*sas))};
+			skirmishAIKeys.push_back(skirmishAIKey);
+			skirmishAIInfos[skirmishAIKey] = skirmishAIInfo;
+			interfaceLib-&gt;ReleaseSkirmishAILibrary(*sas);
+		}
+		
+		// fetch the info of all Group AIs available through the interface
+		std::vector&lt;SGAISpecifyer&gt; gass = interfaceLib-&gt;GetGroupAILibrarySpecifyers();
+		std::vector&lt;SGAISpecifyer&gt;::const_iterator gas;
+		for (gas=gass.begin(); gas!=gass.end(); gas++) { // AIs
+			const IGroupAILibrary* groupAI = interfaceLib-&gt;FetchGroupAILibrary(*gas);
+			CGroupAILibraryInfo* groupAIInfo = new CGroupAILibraryInfo(*groupAI, interfaceSpecifyer);
+			SGAIKey groupAIKey = {interfaceSpecifyer, copySGAISpecifyer(&amp;(*gas))};
+			groupAIKeys.push_back(groupAIKey);
+			groupAIInfos[groupAIKey] = groupAIInfo;
+			interfaceLib-&gt;ReleaseGroupAILibrary(*gas);
+		}
+		
+		delete interfaceLib;
+    }
+}
+*/
+
+/*
+std::vector&lt;InfoItem&gt; ParseInfos(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes)
+{
+	std::vector&lt;InfoItem&gt; infos;
+	
+	//static const int MAX_INFOS = 128;
+#define MAX_INFOS 128
+	InfoItem tmpInfos[MAX_INFOS];
+	unsigned int num = ParseInfos(fileName.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfos, MAX_INFOS);
+	for (unsigned int i=0; i &lt; num; ++i) {
+		infos.push_back(copyInfoItem(&amp;(tmpInfos[i])));
+    }
+	
+	return infos;
+}
+*/
+
+void CAILibraryManager::GetAllInfosFromCache() {
+	//reportError(&quot;NOT YET IMPLEMENTED&quot;, &quot;CAILibraryManager::GetAllInfosFromCache() is not yet implemented.&quot;);
+	
+	ClearAllInfos();
+	
+	// look for AI data files (AIInfo.lua &amp; AIOptions.lua)
+	//int GetSkirmishAICount() {
+	
+/*
+	if (!(vfsHandler)) {
+		reportError(&quot;Initialization Error&quot;, Call InitArchiveScanner before GetSkirmishAICount.&quot;);
+	}
+*/
+	
+	// Read from AI Interface info files
+	std::vector&lt;std::string&gt; aiInterfaceDataDirs = CFileHandler::SubDirs(AI_INTERFACES_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
+	for (std::vector&lt;std::string&gt;::iterator dir = aiInterfaceDataDirs.begin(); dir != aiInterfaceDataDirs.end(); ++dir) {
+		const std::string&amp; possibleDataDir = *dir;
+		std::vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;InterfaceInfo.lua&quot;);
+		if (infoFile.size() &gt; 0) { // interface info is available
+			//aiInterfaceDataDirs.erase(dir);
+			
+			// generate and store the interface info
+			CAIInterfaceLibraryInfo* interfaceInfo = new CAIInterfaceLibraryInfo(infoFile.at(0), SPRING_VFS_RAW, SPRING_VFS_RAW);
+			
+			//std::vector&lt;InfoItem&gt; infos = ParseInfos(infoFile.at(0), SPRING_VFS_RAW, SPRING_VFS_RAW);
+			//options = ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+			
+			std::string sn = interfaceInfo-&gt;GetShortName();
+			std::string v = interfaceInfo-&gt;GetVersion();
+			SAIInterfaceSpecifyer interfaceSpecifyer = {sn.c_str(), v.c_str()};
+			interfaceSpecifyer = copySAIInterfaceSpecifyer(&amp;interfaceSpecifyer);
+			//interfaceSpecifyer = copySAIInterfaceSpecifyer(&amp;interfaceSpecifyer);
+			interfaceSpecifyers.push_back(interfaceSpecifyer);
+/*
+
+			// generate and store the pure file name
+			std::string fileName = std::string(extractFileName(*libFile, false));
+			interfaceFileNames[interfaceSpecifyer] = fileName;
+*/
+			interfaceInfos[interfaceSpecifyer] = interfaceInfo;
+		}
+	}
+	
+	
+	
+	// Read from Skirmish AI info and option files
+	std::vector&lt;std::string&gt; skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
+	for (std::vector&lt;std::string&gt;::iterator dir = skirmishAIDataDirs.begin(); dir != skirmishAIDataDirs.end(); ++dir) {
+		const std::string&amp; possibleDataDir = *dir;
+		std::vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+		if (infoFile.size() &gt; 0) { // skirmish AI info is available
+			std::string optionFileName = &quot;&quot;;
+			std::vector&lt;std::string&gt; optionFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIOptions.lua&quot;);
+			if (optionFile.size() &gt; 0) {
+				optionFileName = optionFile.at(0);
+			}
+			// generate and store the ai info
+			CSkirmishAILibraryInfo* skirmishAIInfo = new CSkirmishAILibraryInfo(infoFile.at(0), optionFileName, SPRING_VFS_RAW, SPRING_VFS_RAW);
+			
+			std::string sn = skirmishAIInfo-&gt;GetShortName();
+			std::string v = skirmishAIInfo-&gt;GetVersion();
+			SSAISpecifyer skirmishAISpecifyer = {sn.c_str(), v.c_str()};
+			SAIInterfaceSpecifyer interfaceSpecifyer = findFittingInterfaceSpecifyer(skirmishAIInfo-&gt;GetInterfaceShortName(), skirmishAIInfo-&gt;GetInterfaceVersion(), interfaceSpecifyers);
+			if (interfaceSpecifyer.shortName != NULL) {
+				skirmishAISpecifyer = copySSAISpecifyer(&amp;skirmishAISpecifyer);
+				SSAIKey skirmishAIKey = {interfaceSpecifyer, skirmishAISpecifyer};
+				skirmishAIKeys.push_back(skirmishAIKey);
+
+				skirmishAIInfos[skirmishAIKey] = skirmishAIInfo;
+			}
+		}
+	}
+	
+	
+	// Read from Group AI info and option files
+	std::vector&lt;std::string&gt; groupAIDataDirs = CFileHandler::SubDirs(GROUP_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
+	for (std::vector&lt;std::string&gt;::iterator dir = groupAIDataDirs.begin(); dir != groupAIDataDirs.end(); ++dir) {
+		const std::string&amp; possibleDataDir = *dir;
+		std::vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+		if (infoFile.size() &gt; 0) { // group AI info is available
+			std::string optionFileName = &quot;&quot;;
+			std::vector&lt;std::string&gt; optionFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIOptions.lua&quot;);
+			if (optionFile.size() &gt; 0) {
+				optionFileName = optionFile.at(0);
+			}
+			// generate and store the ai info
+			CGroupAILibraryInfo* groupAIInfo = new CGroupAILibraryInfo(infoFile.at(0), optionFileName, SPRING_VFS_RAW, SPRING_VFS_RAW);
+			
+			std::string sn = groupAIInfo-&gt;GetShortName();
+			std::string v = groupAIInfo-&gt;GetVersion();
+			SGAISpecifyer groupAISpecifyer = {sn.c_str(), v.c_str()};
+			SAIInterfaceSpecifyer interfaceSpecifyer = findFittingInterfaceSpecifyer(groupAIInfo-&gt;GetInterfaceShortName(), groupAIInfo-&gt;GetInterfaceVersion(), interfaceSpecifyers);
+			if (interfaceSpecifyer.shortName != NULL) {
+				groupAISpecifyer = copySGAISpecifyer(&amp;groupAISpecifyer);
+				SGAIKey groupAIKey = {interfaceSpecifyer, groupAISpecifyer};
+				groupAIKeys.push_back(groupAIKey);
+
+				groupAIInfos[groupAIKey] = groupAIInfo;
+			}
+		}
+	}
+	
+	
+/*
+	std::vector&lt;std::string&gt; infoFiles =
+			FindFiles(std::string(
+			std::string(&quot;&quot;) + AI_INTERFACES_DATA_DIR,
+			std::string(&quot;.&quot;) + SharedLib::GetLibExtension());
+	
+	// initialize the interface infos
+	std::vector&lt;std::string&gt;::const_iterator libFile;
+	for (libFile=interfaceLibFiles.begin(); libFile!=interfaceLibFiles.end(); libFile++) { // interfaces
+		
+		std::string fileName = std::string(extractFileName(*libFile, false));
+		
+		// load the interface
+		IAIInterfaceLibrary* interfaceLib = new CAIInterfaceLibrary(fileName);
+		if (interfaceLib == NULL) {
+			reportError1(&quot;AI Error&quot;,
+					&quot;Failed to load interface shared library \&quot;%s\&quot;&quot;,
+					libFile-&gt;c_str());
+		}
+		
+		SAIInterfaceSpecifyer interfaceSpecifyer = interfaceLib-&gt;GetSpecifyer();
+		interfaceSpecifyer = copySAIInterfaceSpecifyer(&amp;interfaceSpecifyer);
+		interfaceSpecifyers.push_back(interfaceSpecifyer);
+		
+		// generate and store the interface info
+		CAIInterfaceLibraryInfo* interfaceInfo = new CAIInterfaceLibraryInfo(*interfaceLib);
+		interfaceInfos[interfaceSpecifyer] = interfaceInfo;
+		
+		// generate and store the pure file name
+		interfaceFileNames[interfaceSpecifyer] = fileName;
+		
+		// fetch the info of all Skirmish AIs available through the interface
+		std::vector&lt;SSAISpecifyer&gt; sass = interfaceLib-&gt;GetSkirmishAILibrarySpecifyers();
+		std::vector&lt;SSAISpecifyer&gt;::const_iterator sas;
+		for (sas=sass.begin(); sas!=sass.end(); sas++) { // AIs
+			const ISkirmishAILibrary* skirmishAI = interfaceLib-&gt;FetchSkirmishAILibrary(*sas);
+			CSkirmishAILibraryInfo* skirmishAIInfo = new CSkirmishAILibraryInfo(*skirmishAI, interfaceSpecifyer);
+			SSAIKey skirmishAIKey = {interfaceSpecifyer, copySSAISpecifyer(&amp;(*sas))};
+			skirmishAIKeys.push_back(skirmishAIKey);
+			skirmishAIInfos[skirmishAIKey] = skirmishAIInfo;
+			interfaceLib-&gt;ReleaseSkirmishAILibrary(*sas);
+		}
+		
+		// fetch the info of all Group AIs available through the interface
+		std::vector&lt;SGAISpecifyer&gt; gass = interfaceLib-&gt;GetGroupAILibrarySpecifyers();
+		std::vector&lt;SGAISpecifyer&gt;::const_iterator gas;
+		for (gas=gass.begin(); gas!=gass.end(); gas++) { // AIs
+			const IGroupAILibrary* groupAI = interfaceLib-&gt;FetchGroupAILibrary(*gas);
+			CGroupAILibraryInfo* groupAIInfo = new CGroupAILibraryInfo(*groupAI, interfaceSpecifyer);
+			SGAIKey groupAIKey = {interfaceSpecifyer, copySGAISpecifyer(&amp;(*gas))};
+			groupAIKeys.push_back(groupAIKey);
+			groupAIInfos[groupAIKey] = groupAIInfo;
+			interfaceLib-&gt;ReleaseGroupAILibrary(*gas);
+		}
+		
+		delete interfaceLib;
+    }
+*/
+}
+void CAILibraryManager::ClearAllInfos() {
+	
+	std::map&lt;const SAIInterfaceSpecifyer, CAIInterfaceLibraryInfo*&gt;::iterator iii;
+	for (iii=interfaceInfos.begin(); iii!=interfaceInfos.end(); iii++) {
+		delete iii-&gt;second;
+		iii-&gt;second = NULL;
+	}
+	
+	std::map&lt;const SSAIKey, CSkirmishAILibraryInfo*&gt;::iterator sai;
+	for (sai=skirmishAIInfos.begin(); sai!=skirmishAIInfos.end(); sai++) {
+		delete sai-&gt;second;
+		sai-&gt;second = NULL;
+	}
+	
+	std::map&lt;const SGAIKey, CGroupAILibraryInfo*&gt;::iterator gai;
+	for (gai=groupAIInfos.begin(); gai!=groupAIInfos.end(); gai++) {
+		delete gai-&gt;second;
+		gai-&gt;second = NULL;
+	}
+	
+	interfaceInfos.clear();
+	skirmishAIInfos.clear();
+	groupAIInfos.clear();
+	
+	interfaceSpecifyers.clear();
+	skirmishAIKeys.clear();
+	groupAIKeys.clear();
+}
+
+CAILibraryManager::~CAILibraryManager() {
+	
+	ReleaseEverything();
+
+	// delete all strings contained in skirmish AI specifyers
+	std::vector&lt;SSAIKey&gt;::iterator sSpec;
+	for (sSpec=skirmishAIKeys.begin(); sSpec!=skirmishAIKeys.end(); sSpec++) {
+		deleteSSAISpecifyer(&amp;(sSpec-&gt;ai));
+	}
+	
+	// delete all strings contained in group AI specifyers
+	std::vector&lt;SGAIKey&gt;::iterator gSpec;
+	for (gSpec=groupAIKeys.begin(); gSpec!=groupAIKeys.end(); gSpec++) {
+		deleteSGAISpecifyer(&amp;(gSpec-&gt;ai));
+	}
+	
+	// delete all strings contained in interface specifyers
+	std::vector&lt;SAIInterfaceSpecifyer&gt;::iterator iSpec;
+	for (iSpec=interfaceSpecifyers.begin(); iSpec!=interfaceSpecifyers.end(); iSpec++) {
+		deleteSAIInterfaceSpecifyer(&amp;(*iSpec));
+	}
+}
+
+const std::vector&lt;SAIInterfaceSpecifyer&gt;* CAILibraryManager::GetInterfaceSpecifyers() const {
+	return &interfaceSpecifyers;
+}
+const std::vector&lt;SSAIKey&gt;* CAILibraryManager::GetSkirmishAIKeys() const {
+	return &skirmishAIKeys;
+}
+const std::vector&lt;SGAIKey&gt;* CAILibraryManager::GetGroupAIKeys() const {
+	return &groupAIKeys;
+}
+	
+const IAILibraryManager::T_interfaceInfos* CAILibraryManager::GetInterfaceInfos() const {
+	return &interfaceInfos;
+}
+const IAILibraryManager::T_skirmishAIInfos* CAILibraryManager::GetSkirmishAIInfos() const {
+	return &skirmishAIInfos;
+}
+const IAILibraryManager::T_groupAIInfos* CAILibraryManager::GetGroupAIInfos() const {
+	return &groupAIInfos;
+}
+
+
+
+std::vector&lt;SSAIKey&gt; CAILibraryManager::ResolveSkirmishAIKey(const SSAISpecifyer&amp; skirmishAISpecifyer) const {
+	
+	std::vector&lt;SSAIKey&gt; applyingKeys;
+	
+	if (skirmishAISpecifyer.shortName == NULL || strlen(skirmishAISpecifyer.shortName) == 0) {
+		return applyingKeys;
+	}
+	
+	std::string aiName(skirmishAISpecifyer.shortName);
+	
+	bool checkVersion = false;
+	std::string aiVersion;
+	if (skirmishAISpecifyer.version != NULL &amp;&amp; strlen(skirmishAISpecifyer.version) &gt; 0) {
+		aiVersion = std::string(skirmishAISpecifyer.version);
+		checkVersion = true;
+	}
+	
+	std::vector&lt;SSAIKey&gt;::const_iterator sasi;
+	for (sasi=skirmishAIKeys.begin(); sasi!=skirmishAIKeys.end(); sasi++) {
+
+		// check if the ai name fits
+		if (aiName != sasi-&gt;ai.shortName) {
+			continue;
+		}
+
+		// check if the ai version fits (if one is specifyed)
+		if (checkVersion &amp;&amp; aiVersion != sasi-&gt;ai.version) {
+			continue;
+		}
+
+		// if the programm raches here, we know that this key fits
+		applyingKeys.push_back(*sasi);
+	}
+	
+	return applyingKeys;
+}
+std::vector&lt;SSAIKey&gt; CAILibraryManager::ResolveSkirmishAIKey(const std::string&amp; skirmishAISpecifyer) const {
+	
+	std::vector&lt;SSAIKey&gt; applyingKeys;
+	
+	std::string* aiName;
+	std::string* aiVersion;
+	std::string* interfaceName;
+	std::string* interfaceVersion;
+	bool isValid = SplittAIKey(skirmishAISpecifyer, aiName, aiVersion, interfaceName, interfaceVersion);
+	if (!isValid) {
+		reportError1(&quot;AI Library Error&quot;, &quot;Invalid Skirmish AI Key: %s&quot;, skirmishAISpecifyer.c_str());
+		return applyingKeys;
+	}
+	
+	std::vector&lt;SSAIKey&gt;::const_iterator sasi;
+	for (sasi=skirmishAIKeys.begin(); sasi!=skirmishAIKeys.end(); sasi++) {
+
+		// check if the ai name fits
+		if (*aiName != sasi-&gt;ai.shortName) {
+			continue;
+		}
+
+		// check if the ai version fits (if one is specifyed)
+		if (aiVersion &amp;&amp; *aiVersion != sasi-&gt;ai.version) {
+			continue;
+		}
+
+		// check if the interface name fits (if one is specifyed)
+		if (interfaceName &amp;&amp; *interfaceName != sasi-&gt;interface.shortName) {
+			continue;
+		}
+
+		// check if the interface version fits (if one is specifyed)
+		if (interfaceVersion &amp;&amp; *interfaceVersion != sasi-&gt;interface.version) {
+			continue;
+		}
+
+		// if the programm raches here, we know that this key fits
+		applyingKeys.push_back(*sasi);
+	}
+	
+	return applyingKeys;
+}
+
+const ISkirmishAILibrary* CAILibraryManager::FetchSkirmishAILibrary(const SSAIKey&amp; skirmishAIKey) {
+	return FetchInterface(skirmishAIKey.interface)-&gt;FetchSkirmishAILibrary(skirmishAIKey.ai);
+}
+
+void CAILibraryManager::ReleaseSkirmishAILibrary(const SSAIKey&amp; skirmishAIKey) {
+	FetchInterface(skirmishAIKey.interface)-&gt;ReleaseSkirmishAILibrary(skirmishAIKey.ai);
+	ReleaseInterface(skirmishAIKey.interface); // only releases the library if its load count is 0
+}
+
+void CAILibraryManager::ReleaseAllSkirmishAILibraries() {
+	
+	T_loadedInterfaces::const_iterator lil;
+	for (lil=loadedAIInterfaceLibraries.begin(); lil!=loadedAIInterfaceLibraries.end(); lil++) {
+		FetchInterface(lil-&gt;first)-&gt;ReleaseAllSkirmishAILibraries();
+		ReleaseInterface(lil-&gt;first); // only releases the library if its load count is 0
+	}
+}
+
+
+std::vector&lt;SGAIKey&gt; CAILibraryManager::ResolveGroupAIKey(const std::string&amp; groupAISpecifyer) const {
+	
+	std::vector&lt;SGAIKey&gt; applyingKeys;
+	
+	std::string* aiName;
+	std::string* aiVersion;
+	std::string* interfaceName;
+	std::string* interfaceVersion;
+	bool isValid = SplittAIKey(groupAISpecifyer, aiName, aiVersion, interfaceName, interfaceVersion);
+	if (!isValid) {
+		reportError1(&quot;AI Library Error&quot;, &quot;Invalid Group AI Key: %s&quot;, groupAISpecifyer.c_str());
+		return applyingKeys;
+	}
+	
+	std::vector&lt;SGAIKey&gt;::const_iterator gasi;
+	for (gasi=groupAIKeys.begin(); gasi!=groupAIKeys.end(); gasi++) {
+
+		// check if the ai name fits
+		if (*aiName != gasi-&gt;ai.shortName) {
+			continue;
+		}
+
+		// check if the ai version fits (if one is specifyed)
+		if (aiVersion &amp;&amp; *aiVersion != gasi-&gt;ai.version) {
+			continue;
+		}
+
+		// check if the interface name fits (if one is specifyed)
+		if (interfaceName &amp;&amp; *interfaceName != gasi-&gt;interface.shortName) {
+			continue;
+		}
+
+		// check if the interface version fits (if one is specifyed)
+		if (interfaceVersion &amp;&amp; *interfaceVersion != gasi-&gt;interface.version) {
+			continue;
+		}
+
+		// if the programm raches here, we know that this key fits
+		applyingKeys.push_back(*gasi);
+	}
+	
+	return applyingKeys;
+}
+
+const IGroupAILibrary* CAILibraryManager::FetchGroupAILibrary(const SGAIKey&amp; groupAIKey) {
+	return FetchInterface(groupAIKey.interface)-&gt;FetchGroupAILibrary(groupAIKey.ai);
+}
+
+void CAILibraryManager::ReleaseGroupAILibrary(const SGAIKey&amp; groupAIKey) {
+	FetchInterface(groupAIKey.interface)-&gt;ReleaseGroupAILibrary(groupAIKey.ai);
+	ReleaseInterface(groupAIKey.interface); // only releases the library if its load count is 0
+}
+
+void CAILibraryManager::ReleaseAllGroupAILibraries() {
+	
+	T_loadedInterfaces::const_iterator lil;
+	for (lil=loadedAIInterfaceLibraries.begin(); lil!=loadedAIInterfaceLibraries.end(); lil++) {
+		FetchInterface(lil-&gt;first)-&gt;ReleaseAllGroupAILibraries();
+		ReleaseInterface(lil-&gt;first); // only releases the library if its load count is 0
+	}
+}
+
+
+
+
+IAIInterfaceLibrary* CAILibraryManager::FetchInterface(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) {
+	
+	IAIInterfaceLibrary* interfaceLib;
+	
+	T_loadedInterfaces::const_iterator interfacePos = loadedAIInterfaceLibraries.find(interfaceSpecifyer);
+	if (interfacePos == loadedAIInterfaceLibraries.end()) { // interface not yet loaded
+		interfaceLib = new CAIInterfaceLibrary(interfaceSpecifyer);
+		loadedAIInterfaceLibraries[interfaceSpecifyer] = interfaceLib;
+	} else {
+		interfaceLib = interfacePos-&gt;second;
+	}
+
+	return interfaceLib;
+}
+
+void CAILibraryManager::ReleaseInterface(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) {
+	
+	T_loadedInterfaces::iterator interfacePos = loadedAIInterfaceLibraries.find(interfaceSpecifyer);
+	if (interfacePos != loadedAIInterfaceLibraries.end()) {
+		IAIInterfaceLibrary* interfaceLib = interfacePos-&gt;second;
+		if (interfaceLib-&gt;GetLoadCount() == 0) {
+			loadedAIInterfaceLibraries.erase(interfacePos);
+			delete interfaceLib;
+			interfaceLib = NULL;
+		}
+	}
+}
+
+
+/** unloads all interfaces and AIs */
+void CAILibraryManager::ReleaseEverything() {
+	
+	ReleaseAllSkirmishAILibraries();
+	ReleaseAllGroupAILibraries();
+}
+
+std::vector&lt;std::string&gt; CAILibraryManager::FindFiles(const std::string&amp; path, const std::string&amp; fileExtension) {
+	
+	std::vector&lt;std::string&gt; found;
+
+	if (boost::filesystem::exists(path)) {
+		  boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end
+		  for (boost::filesystem::directory_iterator itr(path); itr != end_itr; ++itr) {
+			  if (!boost::filesystem::is_directory(*itr)
+					  &amp;&amp; boost::filesystem::extension(*itr) == fileExtension) {
+				  found.push_back(itr-&gt;string());
+			  }
+		  }
+	}
+	
+	return found;
+}
+
+SAIInterfaceSpecifyer CAILibraryManager::findFittingInterfaceSpecifyer(
+		const std::string&amp; shortName,
+		const std::string&amp; minVersion,
+		const std::vector&lt;SAIInterfaceSpecifyer&gt;&amp; specs) {
+	
+	std::vector&lt;SAIInterfaceSpecifyer&gt;::const_iterator spec;
+	int minDiff = INT_MAX;
+	const char* chosenShortName = NULL;
+	const char* chosenVersion = NULL;
+	for (spec=specs.begin(); spec!=specs.end(); spec++) {
+		if (shortName == spec-&gt;shortName) {
+			int diff = versionCompare(spec-&gt;version, minVersion);
+			if (diff &gt;= 0 &amp;&amp; diff &lt; minDiff) {
+				chosenShortName = spec-&gt;shortName;
+				chosenVersion = spec-&gt;version;
+				minDiff = diff;
+			}
+		}
+	}
+	
+	SAIInterfaceSpecifyer found = {chosenShortName, chosenVersion};
+	return found;
+}
+
+std::vector&lt;std::string&gt; split(const std::string&amp; str, const char sep) {
+	
+/*
+	std::vector&lt;std::string&gt; parts;
+	
+	std::istringstream s(str);
+	std::string temp;
+
+	while (std::getline(s, temp, sep)) {
+		parts.push_back(temp);
+	}
+	
+	return parts;
+*/
+	std::vector&lt;std::string&gt; tokens;
+	std::string delimitters = &quot;.&quot;;
+	
+    // Skip delimiters at beginning.
+    std::string::size_type lastPos = str.find_first_not_of(delimitters, 0);
+    // Find first &quot;non-delimiter&quot;.
+    std::string::size_type pos     = str.find_first_of(delimitters, lastPos);
+
+    while (std::string::npos != pos || std::string::npos != lastPos)
+    {
+        // Found a token, add it to the vector.
+        tokens.push_back(str.substr(lastPos, pos - lastPos));
+        // Skip delimiters.  Note the &quot;not_of&quot;
+        lastPos = str.find_first_not_of(sep, pos);
+        // Find next &quot;non-delimiter&quot;
+        pos = str.find_first_of(delimitters, lastPos);
+    }
+	
+	return tokens;
+}
+int CAILibraryManager::versionCompare(
+		const std::string&amp; version1,
+		const std::string&amp; version2) {/*TODO: test this function!*/
+	
+	std::vector&lt;std::string&gt; parts1 = split(version1, '.');
+	std::vector&lt;std::string&gt; parts2 = split(version2, '.');
+	//int partsDiff = parts1.size() - parts2.size();
+	unsigned int maxParts = parts1.size() &gt; parts2.size() ? parts1.size() : parts2.size();
+	
+	int diff = 0;
+	int mult = maxParts;
+    for (unsigned int i=0; i &lt; maxParts; ++i) {
+		const std::string&amp; v1p = i &lt; parts1.size() ? parts1.at(i) : &quot;&quot;;
+		const std::string&amp; v2p = i &lt; parts2.size() ? parts2.at(i) : &quot;&quot;;
+		diff += (10^(mult*mult)) * v1p.compare(v2p);
+    }
+
+	return diff;
+}
+


Property changes on: branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/AILibraryManager.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryManager.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/AILibraryManager.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,172 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AILIBRARYMANAGER_H
+#define	_AILIBRARYMANAGER_H
+
+#include &quot;IAILibraryManager.h&quot;
+
+#include &quot;AIInterfaceLibrary.h&quot;
+#include &quot;AIInterfaceLibraryInfo.h&quot;
+#include &quot;SkirmishAILibraryInfo.h&quot;
+#include &quot;GroupAILibraryInfo.h&quot;
+
+class CAILibraryManager : public IAILibraryManager {
+private:
+//	typedef s_cont&lt;ISkirmishAILibraryInterfaceInfo&gt;::vector T_interfaceInfos;
+//	typedef s_cont&lt;CSkirmishAILibraryInfoKey&gt;::vector T_infoKeys;
+////	typedef s_cont&lt;ISkirmishAILibraryInfo&gt;::vector T_aiInfos;
+//	typedef s_cont&lt;std::string&gt;::vector T_specifyers;
+//	
+//	typedef s_assoc&lt;ISkirmishAILibraryInterfaceInfo, std::string&gt;::map T_fileNames;
+//	typedef s_assoc&lt;ISkirmishAILibraryInterfaceInfo, ISkirmishAILibraryInterface&gt;::map T_loadedInterfaces;
+	
+public:
+	CAILibraryManager(); // looks for interface and AIs supported by them (ret != 0: error)
+	~CAILibraryManager(); // unloads all shared libraries that are currently loaded (interfaces and implementations)
+	
+	virtual const std::vector&lt;SAIInterfaceSpecifyer&gt;* GetInterfaceSpecifyers() const;
+	virtual const std::vector&lt;SSAIKey&gt;* GetSkirmishAIKeys() const;
+	virtual const std::vector&lt;SGAIKey&gt;* GetGroupAIKeys() const;
+	
+	virtual const T_interfaceInfos* GetInterfaceInfos() const;
+	virtual const T_skirmishAIInfos* GetSkirmishAIInfos() const;
+	virtual const T_groupAIInfos* GetGroupAIInfos() const;
+
+	virtual std::vector&lt;SSAIKey&gt; ResolveSkirmishAIKey(const SSAISpecifyer&amp; skirmishAISpecifyer) const;
+	virtual std::vector&lt;SSAIKey&gt; ResolveSkirmishAIKey(const std::string&amp; skirmishAISpecifyer) const;
+	// a Skirmish AI (its library) is only really loaded when it is not yet loaded.
+	virtual const ISkirmishAILibrary* FetchSkirmishAILibrary(const SSAIKey&amp; skirmishAIKey);
+	// a Skirmish AI is only unloaded when ReleaseSkirmishAILibrary() is called
+	// as many times as GetSkirmishAILibrary() was.
+	// loading and unloading of the interfaces
+	// is handled internally/automatically.
+	virtual void ReleaseSkirmishAILibrary(const SSAIKey&amp; skirmishAIKey);
+	virtual void ReleaseAllSkirmishAILibraries(); // unloads all currently Skirmish loaded AIs
+	
+	virtual std::vector&lt;SGAIKey&gt; ResolveGroupAIKey(const std::string&amp; groupAISpecifyer) const;
+	// a Group AI (its library) is only really loaded when it is not yet loaded.
+	virtual const IGroupAILibrary* FetchGroupAILibrary(const SGAIKey&amp; groupAIKey);
+	// a Group AI is only unloaded when ReleaseSkirmishAILibrary() is called
+	// as many times as GetSkirmishAILibrary() was.
+	// loading and unloading of the interfaces
+	// is handled internally/automatically.
+	virtual void ReleaseGroupAILibrary(const SGAIKey&amp; groupAIKey);
+	virtual void ReleaseAllGroupAILibraries(); // unloads all currently loaded Group AIs
+	
+	virtual void ReleaseEverything(); // unloads all currently loaded AIs and interfaces
+	
+private:
+	typedef std::map&lt;const SAIInterfaceSpecifyer, IAIInterfaceLibrary*, SAIInterfaceSpecifyer_Comparator&gt; T_loadedInterfaces;
+	T_loadedInterfaces loadedAIInterfaceLibraries;
+	
+	std::vector&lt;SAIInterfaceSpecifyer&gt; interfaceSpecifyers;
+	std::vector&lt;SSAIKey&gt; skirmishAIKeys;
+	std::vector&lt;SGAIKey&gt; groupAIKeys;
+//	std::vector&lt;const SAIInterfaceSpecifyer&gt; interfaceLibrarySpecifyers;
+//	std::vector&lt;const SSAIKey&gt; skirmishAILibrarySpecifyers;
+//	std::vector&lt;const SGAIKey&gt; groupAILibrarySpecifyers;
+	//std::map&lt;const SAIInterfaceSpecifyer, std::string, SAIInterfaceSpecifyer_Comparator&gt; interfaceFileNames; // file name of the AI interface library and (LUA-)info cache file (these two have to be the same [without extension])
+	
+	T_interfaceInfos interfaceInfos;
+	T_skirmishAIInfos skirmishAIInfos;
+	T_groupAIInfos groupAIInfos;
+//	T_interfaceInfos interfaceInfos;
+//	T_infoKeys infoKeys;
+////	typedef s_cont&lt;ISkirmishAILibraryInfo&gt;::vector T_aiInfos;
+////	typedef s_cont&lt;ISkirmishAILibraryInfo&gt;::const_vector T_aiInfos_const;
+////	T_aiInfos aiInfos;
+//	T_specifyers specifyers;
+//	T_fileNames fileNames; // file name of the library and (LUA-)info cache file (without extension)
+//	
+//	T_loadedInterfaces loadedInterfaces;
+////	std::map&lt;const ISkirmishAILibraryInterfaceInfo, ISkirmishAILibraryInterface*&gt; interfaceInfo_interface; // loaded interfaces
+////	std::map&lt;const CSkirmishAILibraryInfoKey&amp;, CSkirmishAILibraryKey*&gt; infoKey_key; // loaded AI keys
+////	std::map&lt;const ISkirmishAILibraryInterfaceInfo&amp;, SAIInterfaceLibrary*&gt; interfaceInfo_interface; // interface shared-lib file and interface
+////	std::map&lt;const ISkirmishAILibraryInterfaceInfo&amp;, int&gt; interfaceInfo_loadCounter; // interface shared-lib file and how many times it is loaded
+//	
+////	std::map&lt;const std::string, const SAI*&gt; aiLibFile_ai; // ai shared-lib file and ai
+////	std::map&lt;const std::string, int&gt; aiLibFile_counter; // ai shared-lib file and how many times it is loaded
+	
+private:
+	/**
+	 * Loads the interface if it is not yet loaded; increments load count.
+	 */
+	IAIInterfaceLibrary* FetchInterface(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer);
+	/**
+	 * Unloads the interface if its load count reaches 0.
+	 */
+	void ReleaseInterface(const SAIInterfaceSpecifyer&amp; interfaceSpecifyer);
+//	// the interface has to be loaded already. if it is not, a pointer to NULL will be returned.
+//	s_p&lt;ISkirmishAILibraryInterface&gt; GetInterface(const s_p&lt;const ISkirmishAILibraryInterfaceInfo&gt;&amp; interfaceInfo) const;
+//	// if the filename is not found, a pointer to NULL will be returned.
+//	s_p&lt;std::string&gt; GetFileName(const s_p&lt;const ISkirmishAILibraryInterfaceInfo&gt;&amp; interfaceInfo) const;
+//	// an interface is only really loaded when it is not yet loaded.
+//	s_p&lt;ISkirmishAILibraryInterface&gt; LoadInterface(const s_p&lt;const ISkirmishAILibraryInterfaceInfo&gt;&amp; interfaceInfo);
+//	// actually loads an interface (always loads it)
+//	static s_p&lt;ISkirmishAILibraryInterface&gt; InitializeInterface(const std::string&amp; libFileName);
+//	// an interface is only unloaded when UnloadInterface() is called
+//	// as many times as LoadInterface() was.
+//	void UnloadInterface(const s_p&lt;const ISkirmishAILibraryInterfaceInfo&gt;&amp; interfaceInfo);
+//	// actually unloads an interface (always unloads it)
+//	static void DeinitializeInterface(const std::string&amp; libFileName);
+//	
+//	std::string GenerateLibFilePath(const s_p&lt;const ISkirmishAILibraryInterfaceInfo&gt;&amp; interfaceInfo);
+////	static std::string GenerateLibFileName(const ISkirmishAILibraryInterfaceInfo&amp; interfaceInfo);
+////	static ISkirmishAILibraryInterfaceInfo GenerateInfo(const std::string&amp; libFileName);
+	/**
+	 * Loads all libraries and queries htem for info about available AIs.
+	 */
+	//void GetAllInfosFromLibraries();
+	/**
+	 * Loads info about available AIs from cached LUA files.
+	 * -&gt; interface and AI libraries can not corrupt the engines memory
+	 */
+	void GetAllInfosFromCache();
+	/**
+	 * Clears info about available AIs.
+	 */
+	void ClearAllInfos();
+	
+private:
+	// helper functions
+	static void reportError(const char* topic, const char* msg);
+	static void reportError1(const char* topic, const char* msg, const char* arg0);
+	static void reportError2(const char* topic, const char* msg, const char* arg0, const char* arg1);
+	static void reportInterfaceFunctionError(const std::string* libFileName, const std::string* functionName);
+	static std::string extractFileName(const std::string&amp; libFile, bool includeExtension);
+	static std::vector&lt;std::string&gt; FindFiles(const std::string&amp; path, const std::string&amp; fileExtension);
+	/**
+	 * Finds the best fitting interface.
+	 * The  short name has to fit perfectly, and the version of the interface
+	 * has to be equal or higher then the requested one.
+	 * If there are multiple fitting interfaces, the one with the next higher
+	 * version is selected, eg:
+	 * wanted: 0.2
+	 * available: 0.1, 0.3, 0.5
+	 * chosen: 0.3
+	 */
+	static SAIInterfaceSpecifyer findFittingInterfaceSpecifyer(
+			const std::string&amp; shortName,
+			const std::string&amp; minVersion,
+			const std::vector&lt;SAIInterfaceSpecifyer&gt;&amp; specs);
+	static int versionCompare(
+			const std::string&amp; version1,
+			const std::string&amp; version2);
+};
+
+#endif	/* _AILIBRARYMANAGER_H */


Property changes on: branches/caiinterface/rts/ExternalAI/AILibraryManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/ExternalAI/AISCommands.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AISCommands.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AISCommands.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,4 +1,6 @@
 /*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -13,1149 +15,1165 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#include &quot;AISCommands.h&quot;
+#include &quot;Interface/AISCommands.h&quot;
 
 #include &lt;limits.h&gt;
-#include &quot;Sim/Units/CommandAI/Command.h&quot;
 
 void initSUnitCommand(void* sUnitCommand) {
-	SStopUnitCommand* scmd = (SStopUnitCommand*) sUnitCommand;
+	
+	struct SStopUnitCommand* scmd = (struct SStopUnitCommand*) sUnitCommand;
+
 	scmd-&gt;unitId = -1;
 	scmd-&gt;groupId = -1;
 	scmd-&gt;options = 0;
 	scmd-&gt;timeOut = INT_MAX;
 }
 
+
+#ifdef	__cplusplus
+#include &quot;Sim/Units/CommandAI/Command.h&quot;
+
 void freeSUnitCommand(void* sCommandData, int sCommandId) {
 
-    switch (sCommandId) {
-        case COMMAND_UNIT_LOAD_UNITS:
-        {
-            SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) sCommandData;
-            free(cmd-&gt;toLoadUnitIds);
-            break;
-        }
-        case COMMAND_UNIT_CUSTOM:
-        {
-            SCustomUnitCommand* cmd = (SCustomUnitCommand*) sCommandData;
-            free(cmd-&gt;params);
-            break;
-        }
-    }
+	switch (sCommandId) {
+		case COMMAND_UNIT_LOAD_UNITS:
+		{
+			struct SLoadUnitsUnitCommand* cmd = (struct SLoadUnitsUnitCommand*) sCommandData;
+			free(cmd-&gt;toLoadUnitIds);
+			break;
+		}
+		case COMMAND_UNIT_CUSTOM:
+		{
+			struct SCustomUnitCommand* cmd = (struct SCustomUnitCommand*) sCommandData;
+			free(cmd-&gt;params);
+			break;
+		}
+	}
 
-    free(sCommandData);
+	free(sCommandData);
 }
 
-void* mallocSUnitCommand(int unitId, int groupId, void* v_c, int sCommandId[0]) {
+void* mallocSUnitCommand(int unitId, int groupId, const Command* c, int sCommandId[0]) {
 
-    int sCmdId = COMMAND_NULL;
-    void* sCommandData;
-    
-    Command* c = (Command*) v_c;
-    switch (c-&gt;id) {
-        case CMD_STOP:
-        {
-            SStopUnitCommand* cmd = (SStopUnitCommand*) malloc(sizeof (SStopUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+	int sCmdId = COMMAND_NULL;
+	void* sCommandData;
+	
+	switch (c-&gt;id) {
+		case CMD_STOP:
+		{
+			SStopUnitCommand* cmd = (SStopUnitCommand*) malloc(sizeof (SStopUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_STOP;
-            break;
-        }
-        case CMD_WAIT:
-        {
-            SWaitUnitCommand* cmd = (SWaitUnitCommand*) malloc(sizeof (SWaitUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_STOP;
+			break;
+		}
+		case CMD_WAIT:
+		{
+			SWaitUnitCommand* cmd = (SWaitUnitCommand*) malloc(sizeof (SWaitUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_WAIT;
-            break;
-        }
-        case CMD_TIMEWAIT:
-        {
-            STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) malloc(sizeof (STimeWaitUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;time = c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_WAIT;
+			break;
+		}
+		case CMD_TIMEWAIT:
+		{
+			STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) malloc(sizeof (STimeWaitUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;time = c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_WAIT_TIME;
-            break;
-        }
-        case CMD_DEATHWAIT:
-        {
-            SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) malloc(sizeof (SDeathWaitUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toDieUnitId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_WAIT_TIME;
+			break;
+		}
+		case CMD_DEATHWAIT:
+		{
+			SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) malloc(sizeof (SDeathWaitUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toDieUnitId = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_WAIT_DEATH;
-            break;
-        }
-        case CMD_SQUADWAIT:
-        {
-            SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) malloc(sizeof (SSquadWaitUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;numUnits = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_WAIT_DEATH;
+			break;
+		}
+		case CMD_SQUADWAIT:
+		{
+			SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) malloc(sizeof (SSquadWaitUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;numUnits = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_WAIT_SQUAD;
-            break;
-        }
-        case CMD_GATHERWAIT:
-        {
-            SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) malloc(sizeof (SGatherWaitUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_WAIT_SQUAD;
+			break;
+		}
+		case CMD_GATHERWAIT:
+		{
+			SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) malloc(sizeof (SGatherWaitUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_WAIT_GATHER;
-            break;
-        }
-        case CMD_MOVE:
-        {
-            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            SMoveUnitCommand* cmd = (SMoveUnitCommand*) malloc(sizeof (SMoveUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toPos = toPos;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_WAIT_GATHER;
+			break;
+		}
+		case CMD_MOVE:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SMoveUnitCommand* cmd = (SMoveUnitCommand*) malloc(sizeof (SMoveUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toPos = toPos;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_MOVE;
-            break;
-        }
-        case CMD_PATROL:
-        {
-            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) malloc(sizeof (SPatrolUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toPos = toPos;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_MOVE;
+			break;
+		}
+		case CMD_PATROL:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) malloc(sizeof (SPatrolUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toPos = toPos;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_PATROL;
-            break;
-        }
-        case CMD_FIGHT:
-        {
-            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            SFightUnitCommand* cmd = (SFightUnitCommand*) malloc(sizeof (SFightUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toPos = toPos;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_PATROL;
+			break;
+		}
+		case CMD_FIGHT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SFightUnitCommand* cmd = (SFightUnitCommand*) malloc(sizeof (SFightUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toPos = toPos;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_FIGHT;
-            break;
-        }
-        case CMD_ATTACK:
-        {
-            if (c-&gt;params.size() &lt; 3) {
-                SAttackUnitCommand* cmd = (SAttackUnitCommand*) malloc(sizeof (SAttackUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toAttackUnitId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_FIGHT;
+			break;
+		}
+		case CMD_ATTACK:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SAttackUnitCommand* cmd = (SAttackUnitCommand*) malloc(sizeof (SAttackUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toAttackUnitId = (int) c-&gt;params[0];
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_ATTACK;
-            } else {
-                SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                float radius = 0.0f;
-                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-                SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) malloc(sizeof (SAttackAreaUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toAttackPos = toAttackPos;
-                cmd-&gt;radius = radius;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_ATTACK;
+			} else {
+				SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) malloc(sizeof (SAttackAreaUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toAttackPos = toAttackPos;
+				cmd-&gt;radius = radius;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_ATTACK_AREA;
-            }
-            break;
-        }
-        case CMD_GUARD:
-        {
-            SGuardUnitCommand* cmd = (SGuardUnitCommand*) malloc(sizeof (SGuardUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toGuardUnitId = (int) c-&gt;params[0];
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_ATTACK_AREA;
+			}
+			break;
+		}
+		case CMD_GUARD:
+		{
+			SGuardUnitCommand* cmd = (SGuardUnitCommand*) malloc(sizeof (SGuardUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toGuardUnitId = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_GUARD;
-            break;
-        }
-        case CMD_AISELECT:
-        {
-            SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) malloc(sizeof (SAiSelectUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_GUARD;
+			break;
+		}
+		case CMD_AISELECT:
+		{
+			SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) malloc(sizeof (SAiSelectUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_AI_SELECT;
-            break;
-        }
-        case CMD_GROUPADD:
-        {
-            SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) malloc(sizeof (SGroupAddUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toGroupId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_AI_SELECT;
+			break;
+		}
+		case CMD_GROUPADD:
+		{
+			SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) malloc(sizeof (SGroupAddUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toGroupId = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_GROUP_ADD;
-            break;
-        }
-        case CMD_GROUPCLEAR:
-        {
-            SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) malloc(sizeof (SGroupClearUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_GROUP_ADD;
+			break;
+		}
+		case CMD_GROUPCLEAR:
+		{
+			SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) malloc(sizeof (SGroupClearUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_GROUP_CLEAR;
-            break;
-        }
-        case CMD_REPAIR:
-        {
-            SRepairUnitCommand* cmd = (SRepairUnitCommand*) malloc(sizeof (SRepairUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toRepairUnitId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_GROUP_CLEAR;
+			break;
+		}
+		case CMD_REPAIR:
+		{
+			SRepairUnitCommand* cmd = (SRepairUnitCommand*) malloc(sizeof (SRepairUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toRepairUnitId = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_REPAIR;
-            break;
-        }
-        case CMD_FIRE_STATE:
-        {
-            SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) malloc(sizeof (SSetFireStateUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;fireState = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_REPAIR;
+			break;
+		}
+		case CMD_FIRE_STATE:
+		{
+			SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) malloc(sizeof (SSetFireStateUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;fireState = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_FIRE_STATE;
-            break;
-        }
-        case CMD_MOVE_STATE:
-        {
-            SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) malloc(sizeof (SSetMoveStateUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;moveState = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_FIRE_STATE;
+			break;
+		}
+		case CMD_MOVE_STATE:
+		{
+			SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) malloc(sizeof (SSetMoveStateUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;moveState = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_MOVE_STATE;
-            break;
-        }
-        case CMD_SETBASE:
-        {
-            SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) malloc(sizeof (SSetBaseUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;basePos = basePos;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_MOVE_STATE;
+			break;
+		}
+		case CMD_SETBASE:
+		{
+			SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) malloc(sizeof (SSetBaseUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;basePos = basePos;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_BASE;
-            break;
-        }
-        case CMD_SELFD:
-        {
-            SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) malloc(sizeof (SSelfDestroyUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_BASE;
+			break;
+		}
+		case CMD_SELFD:
+		{
+			SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) malloc(sizeof (SSelfDestroyUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SELF_DESTROY;
-            break;
-        }
-        case CMD_SET_WANTED_MAX_SPEED:
-        {
-            SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) malloc(sizeof (SSetWantedMaxSpeedUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;wantedMaxSpeed = c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SELF_DESTROY;
+			break;
+		}
+		case CMD_SET_WANTED_MAX_SPEED:
+		{
+			SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) malloc(sizeof (SSetWantedMaxSpeedUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;wantedMaxSpeed = c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_WANTED_MAX_SPEED;
-            break;
-        }
-        case CMD_LOAD_UNITS:
-        {
-            if (c-&gt;params.size() &lt; 3) {
-                //int numToLoadUnits = 1;
-                int numToLoadUnits = c-&gt;params.size();
-                
-                SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) malloc(sizeof (SLoadUnitsUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                
-                cmd-&gt;numToLoadUnits = numToLoadUnits;
-                cmd-&gt;toLoadUnitIds = (int*) calloc(numToLoadUnits, sizeof(int));
-                int i;
-                for (i=0; i &lt; numToLoadUnits; ++i) {
-                    cmd-&gt;toLoadUnitIds[i] = (int) c-&gt;params.at(i);
-                }
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_WANTED_MAX_SPEED;
+			break;
+		}
+		case CMD_LOAD_UNITS:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				//int numToLoadUnits = 1;
+				int numToLoadUnits = c-&gt;params.size();
+				
+				SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) malloc(sizeof (SLoadUnitsUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				
+				cmd-&gt;numToLoadUnits = numToLoadUnits;
+				cmd-&gt;toLoadUnitIds = (int*) calloc(numToLoadUnits, sizeof(int));
+				int i;
+				for (i=0; i &lt; numToLoadUnits; ++i) {
+					cmd-&gt;toLoadUnitIds[i] = (int) c-&gt;params.at(i);
+				}
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_LOAD_UNITS;
-            } else {
-                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                float radius = 0.0f;
-                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-                SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) malloc(sizeof (SLoadUnitsAreaUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;pos = pos;
-                cmd-&gt;radius = radius;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_LOAD_UNITS;
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) malloc(sizeof (SLoadUnitsAreaUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;pos = pos;
+				cmd-&gt;radius = radius;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_LOAD_UNITS_AREA;
-            }
-            break;
-        }
-        case CMD_LOAD_ONTO:
-        {
-            SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) malloc(sizeof (SLoadOntoUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;transporterUnitId = (int) c-&gt;params[0];
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_LOAD_UNITS_AREA;
+			}
+			break;
+		}
+		case CMD_LOAD_ONTO:
+		{
+			SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) malloc(sizeof (SLoadOntoUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;transporterUnitId = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_LOAD_ONTO;
-            break;
-        }
-        case CMD_UNLOAD_UNIT:
-        {
-            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) malloc(sizeof (SUnloadUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toPos = toPos;
-            cmd-&gt;toUnloadUnitId = (int) c-&gt;params[3];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_LOAD_ONTO;
+			break;
+		}
+		case CMD_UNLOAD_UNIT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) malloc(sizeof (SUnloadUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toPos = toPos;
+			cmd-&gt;toUnloadUnitId = (int) c-&gt;params[3];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_UNLOAD_UNIT;
-            break;
-        }
-        case CMD_UNLOAD_UNITS:
-        {
-            SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            float radius = 0.0f;
-            if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-            SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) malloc(sizeof (SUnloadUnitsAreaUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;toPos = toPos;
-            cmd-&gt;radius = radius;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_UNLOAD_UNIT;
+			break;
+		}
+		case CMD_UNLOAD_UNITS:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			float radius = 0.0f;
+			if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+			SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) malloc(sizeof (SUnloadUnitsAreaUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;toPos = toPos;
+			cmd-&gt;radius = radius;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_UNLOAD_UNITS_AREA;
-            break;
-        }
-        case CMD_ONOFF:
-        {
-            SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) malloc(sizeof (SSetOnOffUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;on = (bool) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_UNLOAD_UNITS_AREA;
+			break;
+		}
+		case CMD_ONOFF:
+		{
+			SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) malloc(sizeof (SSetOnOffUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;on = (bool) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_ON_OFF;
-            break;
-        }
-        case CMD_RECLAIM:
-        {
-            if (c-&gt;params.size() &lt; 3) {
-                SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) malloc(sizeof (SReclaimUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toReclaimUnitIdOrFeatureId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_ON_OFF;
+			break;
+		}
+		case CMD_RECLAIM:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) malloc(sizeof (SReclaimUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toReclaimUnitIdOrFeatureId = (int) c-&gt;params[0];
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_RECLAIM;
-            } else {
-                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                float radius = 0.0f;
-                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-                SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) malloc(sizeof (SReclaimAreaUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;pos = pos;
-                cmd-&gt;radius = radius;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_RECLAIM;
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) malloc(sizeof (SReclaimAreaUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;pos = pos;
+				cmd-&gt;radius = radius;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_RECLAIM_AREA;
-            }
-            break;
-        }
-        case CMD_CLOAK:
-        {
-            SCloakUnitCommand* cmd = (SCloakUnitCommand*) malloc(sizeof (SCloakUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;cloak = (bool) c-&gt;params[0];
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_RECLAIM_AREA;
+			}
+			break;
+		}
+		case CMD_CLOAK:
+		{
+			SCloakUnitCommand* cmd = (SCloakUnitCommand*) malloc(sizeof (SCloakUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;cloak = (bool) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_CLOAK;
-            break;
-        }
-        case CMD_STOCKPILE:
-        {
-            SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) malloc(sizeof (SStockpileUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_CLOAK;
+			break;
+		}
+		case CMD_STOCKPILE:
+		{
+			SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) malloc(sizeof (SStockpileUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_STOCKPILE;
-            break;
-        }
-        case CMD_DGUN:
-        {
-            if (c-&gt;params.size() &lt; 3) {
-                SDGunUnitCommand* cmd = (SDGunUnitCommand*) malloc(sizeof (SDGunUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toAttackUnitId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_STOCKPILE;
+			break;
+		}
+		case CMD_DGUN:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SDGunUnitCommand* cmd = (SDGunUnitCommand*) malloc(sizeof (SDGunUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toAttackUnitId = (int) c-&gt;params[0];
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_D_GUN;
-            } else {
-                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) malloc(sizeof (SDGunPosUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;pos = pos;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_D_GUN;
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) malloc(sizeof (SDGunPosUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;pos = pos;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_D_GUN_POS;
-            }
-            break;
-        }
-        case CMD_RESTORE:
-        {
-            SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-            float radius = 0.0f;
-            if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-            SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) malloc(sizeof (SRestoreAreaUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;pos = pos;
-            cmd-&gt;radius = radius;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_D_GUN_POS;
+			}
+			break;
+		}
+		case CMD_RESTORE:
+		{
+			SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			float radius = 0.0f;
+			if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+			SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) malloc(sizeof (SRestoreAreaUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;pos = pos;
+			cmd-&gt;radius = radius;
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_RESTORE_AREA;
-            break;
-        }
-        case CMD_REPEAT:
-        {
-            SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) malloc(sizeof (SSetRepeatUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;repeat = (bool) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_RESTORE_AREA;
+			break;
+		}
+		case CMD_REPEAT:
+		{
+			SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) malloc(sizeof (SSetRepeatUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;repeat = (bool) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_REPEAT;
-            break;
-        }
-        case CMD_TRAJECTORY:
-        {
-            SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) malloc(sizeof (SSetTrajectoryUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;trajectory = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_REPEAT;
+			break;
+		}
+		case CMD_TRAJECTORY:
+		{
+			SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) malloc(sizeof (SSetTrajectoryUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;trajectory = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_TRAJECTORY;
-            break;
-        }
-        case CMD_RESURRECT:
-        {
-            if (c-&gt;params.size() &lt; 3) {
-                SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) malloc(sizeof (SResurrectUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toResurrectFeatureId = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_TRAJECTORY;
+			break;
+		}
+		case CMD_RESURRECT:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) malloc(sizeof (SResurrectUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toResurrectFeatureId = (int) c-&gt;params[0];
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_RESURRECT;
-            } else {
-                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                float radius = 0.0f;
-                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-                SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) malloc(sizeof (SResurrectAreaUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;pos = pos;
-                cmd-&gt;radius = radius;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_RESURRECT;
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) malloc(sizeof (SResurrectAreaUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;pos = pos;
+				cmd-&gt;radius = radius;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_RESURRECT_AREA;
-            }
-            break;
-        }
-        case CMD_CAPTURE:
-        {
-            if (c-&gt;params.size() &lt; 3) {
-                SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) malloc(sizeof (SCaptureUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toCaptureUnitId = (int) c-&gt;params[0];
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_RESURRECT_AREA;
+			}
+			break;
+		}
+		case CMD_CAPTURE:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) malloc(sizeof (SCaptureUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toCaptureUnitId = (int) c-&gt;params[0];
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_CAPTURE;
-            } else {
-                SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                float radius = 0.0f;
-                if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-                SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) malloc(sizeof (SCaptureAreaUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;pos = pos;
-                cmd-&gt;radius = radius;
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_CAPTURE;
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) malloc(sizeof (SCaptureAreaUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;pos = pos;
+				cmd-&gt;radius = radius;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_CAPTURE_AREA;
-            }
-            break;
-        }
-        case CMD_AUTOREPAIRLEVEL:
-        {
-            SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) malloc(sizeof (SSetAutoRepairLevelUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;autoRepairLevel = (int) c-&gt;params[0];
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_CAPTURE_AREA;
+			}
+			break;
+		}
+		case CMD_AUTOREPAIRLEVEL:
+		{
+			SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) malloc(sizeof (SSetAutoRepairLevelUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;autoRepairLevel = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL;
-            break;
-        }
-        case CMD_IDLEMODE:
-        {
-            SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) malloc(sizeof (SSetIdleModeUnitCommand));
-            cmd-&gt;unitId = unitId;
-            cmd-&gt;groupId = groupId;
-            cmd-&gt;options = c-&gt;options;
-            cmd-&gt;timeOut = c-&gt;timeOut;
-            cmd-&gt;idleMode = (int) c-&gt;params[0];
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL;
+			break;
+		}
+		case CMD_IDLEMODE:
+		{
+			SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) malloc(sizeof (SSetIdleModeUnitCommand));
+			cmd-&gt;unitId = unitId;
+			cmd-&gt;groupId = groupId;
+			cmd-&gt;options = c-&gt;options;
+			cmd-&gt;timeOut = c-&gt;timeOut;
+			cmd-&gt;idleMode = (int) c-&gt;params[0];
 
-            sCommandData = cmd;
-            sCmdId = COMMAND_UNIT_SET_IDLE_MODE;
-            break;
-        }
-        default:
-        {
-            if (c-&gt;id &lt; 0) { // CMD_BUILD
-                int toBuildUnitDefId = -c-&gt;id;
-                SAIFloat3 buildPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-                int facing = UNIT_COMMAND_BUILD_NO_FACING;
-                if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
-                SBuildUnitCommand* cmd = (SBuildUnitCommand*) malloc(sizeof (SBuildUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;toBuildUnitDefId = toBuildUnitDefId;
-                cmd-&gt;buildPos = buildPos;
-                cmd-&gt;facing = facing;
+			sCommandData = cmd;
+			sCmdId = COMMAND_UNIT_SET_IDLE_MODE;
+			break;
+		}
+		default:
+		{
+			if (c-&gt;id &lt; 0) { // CMD_BUILD
+				int toBuildUnitDefId = -c-&gt;id;
+				SAIFloat3 buildPos = {-1.0, -1.0, -1.0};
+				if (c-&gt;params.size() &gt;= 3) {
+					buildPos.x = c-&gt;params[0];
+					buildPos.y = c-&gt;params[1];
+					buildPos.z = c-&gt;params[2];
+				}
+				int facing = UNIT_COMMAND_BUILD_NO_FACING;
+				if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
+				SBuildUnitCommand* cmd = (SBuildUnitCommand*) malloc(sizeof (SBuildUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;toBuildUnitDefId = toBuildUnitDefId;
+				cmd-&gt;buildPos = buildPos;
+				cmd-&gt;facing = facing;
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_BUILD;
-            } else { // CMD_CUSTOM
-                int cmdId = c-&gt;id;
-                int numParams = c-&gt;params.size();
-                SCustomUnitCommand* cmd = (SCustomUnitCommand*) malloc(sizeof (SCustomUnitCommand));
-                cmd-&gt;unitId = unitId;
-                cmd-&gt;groupId = groupId;
-                cmd-&gt;options = c-&gt;options;
-                cmd-&gt;timeOut = c-&gt;timeOut;
-                cmd-&gt;cmdId = cmdId;
-                cmd-&gt;numParams = numParams;
-                cmd-&gt;params = (float*) calloc(numParams, sizeof(float));
-                int i;
-                for (i=0; i &lt; numParams; ++i) {
-                    cmd-&gt;params[i] = c-&gt;params.at(i);
-                }
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_BUILD;
+			} else { // CMD_CUSTOM
+				int cmdId = c-&gt;id;
+				int numParams = c-&gt;params.size();
+				SCustomUnitCommand* cmd = (SCustomUnitCommand*) malloc(sizeof (SCustomUnitCommand));
+				cmd-&gt;unitId = unitId;
+				cmd-&gt;groupId = groupId;
+				cmd-&gt;options = c-&gt;options;
+				cmd-&gt;timeOut = c-&gt;timeOut;
+				cmd-&gt;cmdId = cmdId;
+				cmd-&gt;numParams = numParams;
+				cmd-&gt;params = (float*) calloc(numParams, sizeof(float));
+				int i;
+				for (i=0; i &lt; numParams; ++i) {
+					cmd-&gt;params[i] = c-&gt;params.at(i);
+				}
 
-                sCommandData = cmd;
-                sCmdId = COMMAND_UNIT_CUSTOM;
-            }
-            break;
-        }
+				sCommandData = cmd;
+				sCmdId = COMMAND_UNIT_CUSTOM;
+			}
+			break;
+		}
 
-    }
+	}
 
-    *sCommandId = sCmdId;
-    return sCommandData;
+	*sCommandId = sCmdId;
+	return sCommandData;
 }
 
 
 
-void* newCommand(void* sUnitCommandData, int sCommandId) {
+Command* newCommand(void* sUnitCommandData, int sCommandId) {
 
-    Command* c = new Command();
+	Command* c = new Command();
 
-    switch (sCommandId) {
-        case COMMAND_UNIT_BUILD:
-        {
-            SBuildUnitCommand* cmd = (SBuildUnitCommand*) sUnitCommandData;
-            c-&gt;id = -cmd-&gt;toBuildUnitDefId;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+	switch (sCommandId) {
+		case COMMAND_UNIT_BUILD:
+		{
+			SBuildUnitCommand* cmd = (SBuildUnitCommand*) sUnitCommandData;
+			c-&gt;id = -cmd-&gt;toBuildUnitDefId;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;buildPos.x);
-            c-&gt;params.push_back(cmd-&gt;buildPos.y);
-            c-&gt;params.push_back(cmd-&gt;buildPos.z);
-            if (cmd-&gt;facing != UNIT_COMMAND_BUILD_NO_FACING) c-&gt;params.push_back(cmd-&gt;facing);
-            break;
-        }
-        case COMMAND_UNIT_STOP:
-        {
-            SStopUnitCommand* cmd = (SStopUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_STOP;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_WAIT:
-        {
-            SWaitUnitCommand* cmd = (SWaitUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_WAIT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_WAIT_TIME:
-        {
-            STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_WAITCODE_TIMEWAIT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			if (cmd-&gt;buildPos.x != -1.0
+					|| cmd-&gt;buildPos.y != -1.0
+					|| cmd-&gt;buildPos.z != -1.0) {
+				c-&gt;params.push_back(cmd-&gt;buildPos.x);
+				c-&gt;params.push_back(cmd-&gt;buildPos.y);
+				c-&gt;params.push_back(cmd-&gt;buildPos.z);
+			}
+			if (cmd-&gt;facing != UNIT_COMMAND_BUILD_NO_FACING) c-&gt;params.push_back(cmd-&gt;facing);
+			break;
+		}
+		case COMMAND_UNIT_STOP:
+		{
+			SStopUnitCommand* cmd = (SStopUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_STOP;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_WAIT:
+		{
+			SWaitUnitCommand* cmd = (SWaitUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_WAIT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_WAIT_TIME:
+		{
+			STimeWaitUnitCommand* cmd = (STimeWaitUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_WAITCODE_TIMEWAIT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;time);
-            break;
-        }
-        case COMMAND_UNIT_WAIT_DEATH:
-        {
-            SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_WAITCODE_DEATHWAIT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;time);
+			break;
+		}
+		case COMMAND_UNIT_WAIT_DEATH:
+		{
+			SDeathWaitUnitCommand* cmd = (SDeathWaitUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_WAITCODE_DEATHWAIT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toDieUnitId);
-            break;
-        }
-        case COMMAND_UNIT_WAIT_SQUAD:
-        {
-            SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_WAITCODE_SQUADWAIT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toDieUnitId);
+			break;
+		}
+		case COMMAND_UNIT_WAIT_SQUAD:
+		{
+			SSquadWaitUnitCommand* cmd = (SSquadWaitUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_WAITCODE_SQUADWAIT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;numUnits);
-            break;
-        }
-        case COMMAND_UNIT_WAIT_GATHER:
-        {
-            SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_WAITCODE_GATHERWAIT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_MOVE:
-        {
-            SMoveUnitCommand* cmd = (SMoveUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_MOVE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;numUnits);
+			break;
+		}
+		case COMMAND_UNIT_WAIT_GATHER:
+		{
+			SGatherWaitUnitCommand* cmd = (SGatherWaitUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_WAITCODE_GATHERWAIT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_MOVE:
+		{
+			SMoveUnitCommand* cmd = (SMoveUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_MOVE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toPos.x);
-            c-&gt;params.push_back(cmd-&gt;toPos.y);
-            c-&gt;params.push_back(cmd-&gt;toPos.z);
-            break;
-        }
-        case COMMAND_UNIT_PATROL:
-        {
-            SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_PATROL;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toPos.x);
+			c-&gt;params.push_back(cmd-&gt;toPos.y);
+			c-&gt;params.push_back(cmd-&gt;toPos.z);
+			break;
+		}
+		case COMMAND_UNIT_PATROL:
+		{
+			SPatrolUnitCommand* cmd = (SPatrolUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_PATROL;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toPos.x);
-            c-&gt;params.push_back(cmd-&gt;toPos.y);
-            c-&gt;params.push_back(cmd-&gt;toPos.z);
-            break;
-        }
-        case COMMAND_UNIT_FIGHT:
-        {
-            SFightUnitCommand* cmd = (SFightUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_FIGHT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toPos.x);
+			c-&gt;params.push_back(cmd-&gt;toPos.y);
+			c-&gt;params.push_back(cmd-&gt;toPos.z);
+			break;
+		}
+		case COMMAND_UNIT_FIGHT:
+		{
+			SFightUnitCommand* cmd = (SFightUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_FIGHT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toPos.x);
-            c-&gt;params.push_back(cmd-&gt;toPos.y);
-            c-&gt;params.push_back(cmd-&gt;toPos.z);
-            break;
-        }
-        case COMMAND_UNIT_ATTACK:
-        {
-            SAttackUnitCommand* cmd = (SAttackUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_ATTACK;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toPos.x);
+			c-&gt;params.push_back(cmd-&gt;toPos.y);
+			c-&gt;params.push_back(cmd-&gt;toPos.z);
+			break;
+		}
+		case COMMAND_UNIT_ATTACK:
+		{
+			SAttackUnitCommand* cmd = (SAttackUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_ATTACK;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toAttackUnitId);
-            break;
-        }
-        case COMMAND_UNIT_ATTACK_AREA:
-        {
-            SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_ATTACK;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toAttackUnitId);
+			break;
+		}
+		case COMMAND_UNIT_ATTACK_AREA:
+		{
+			SAttackAreaUnitCommand* cmd = (SAttackAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_ATTACK;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toAttackPos.x);
-            c-&gt;params.push_back(cmd-&gt;toAttackPos.y);
-            c-&gt;params.push_back(cmd-&gt;toAttackPos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_GUARD:
-        {
-            SGuardUnitCommand* cmd = (SGuardUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_GUARD;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toAttackPos.x);
+			c-&gt;params.push_back(cmd-&gt;toAttackPos.y);
+			c-&gt;params.push_back(cmd-&gt;toAttackPos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_GUARD:
+		{
+			SGuardUnitCommand* cmd = (SGuardUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_GUARD;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toGuardUnitId);
-            break;
-        }
-        case COMMAND_UNIT_AI_SELECT:
-        {
-            SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_AISELECT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_GROUP_ADD:
-        {
-            SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_GROUPADD;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toGuardUnitId);
+			break;
+		}
+		case COMMAND_UNIT_AI_SELECT:
+		{
+			SAiSelectUnitCommand* cmd = (SAiSelectUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_AISELECT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_GROUP_ADD:
+		{
+			SGroupAddUnitCommand* cmd = (SGroupAddUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_GROUPADD;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toGroupId);
-            break;
-        }
-        case COMMAND_UNIT_GROUP_CLEAR:
-        {
-            SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_GROUPCLEAR;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_REPAIR:
-        {
-            SRepairUnitCommand* cmd = (SRepairUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_REPAIR;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toGroupId);
+			break;
+		}
+		case COMMAND_UNIT_GROUP_CLEAR:
+		{
+			SGroupClearUnitCommand* cmd = (SGroupClearUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_GROUPCLEAR;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_REPAIR:
+		{
+			SRepairUnitCommand* cmd = (SRepairUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_REPAIR;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toRepairUnitId);
-            break;
-        }
-        case COMMAND_UNIT_SET_FIRE_STATE:
-        {
-            SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_FIRE_STATE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toRepairUnitId);
+			break;
+		}
+		case COMMAND_UNIT_SET_FIRE_STATE:
+		{
+			SSetFireStateUnitCommand* cmd = (SSetFireStateUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_FIRE_STATE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;fireState);
-            break;
-        }
-        case COMMAND_UNIT_SET_MOVE_STATE:
-        {
-            SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_MOVE_STATE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;fireState);
+			break;
+		}
+		case COMMAND_UNIT_SET_MOVE_STATE:
+		{
+			SSetMoveStateUnitCommand* cmd = (SSetMoveStateUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_MOVE_STATE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;moveState);
-            break;
-        }
-        case COMMAND_UNIT_SET_BASE:
-        {
-            SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_SETBASE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;moveState);
+			break;
+		}
+		case COMMAND_UNIT_SET_BASE:
+		{
+			SSetBaseUnitCommand* cmd = (SSetBaseUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_SETBASE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;basePos.x);
-            c-&gt;params.push_back(cmd-&gt;basePos.y);
-            c-&gt;params.push_back(cmd-&gt;basePos.z);
-            break;
-        }
-        case COMMAND_UNIT_SELF_DESTROY:
-        {
-            SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_SELFD;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_SET_WANTED_MAX_SPEED:
-        {
-            SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_SET_WANTED_MAX_SPEED;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;basePos.x);
+			c-&gt;params.push_back(cmd-&gt;basePos.y);
+			c-&gt;params.push_back(cmd-&gt;basePos.z);
+			break;
+		}
+		case COMMAND_UNIT_SELF_DESTROY:
+		{
+			SSelfDestroyUnitCommand* cmd = (SSelfDestroyUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_SELFD;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_SET_WANTED_MAX_SPEED:
+		{
+			SSetWantedMaxSpeedUnitCommand* cmd = (SSetWantedMaxSpeedUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_SET_WANTED_MAX_SPEED;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;wantedMaxSpeed);
-            break;
-        }
-        case COMMAND_UNIT_LOAD_UNITS:
-        {
-            SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_LOAD_UNITS;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;wantedMaxSpeed);
+			break;
+		}
+		case COMMAND_UNIT_LOAD_UNITS:
+		{
+			SLoadUnitsUnitCommand* cmd = (SLoadUnitsUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_LOAD_UNITS;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            for (int i = 0; i &lt; cmd-&gt;numToLoadUnits; ++i) {
-                c-&gt;params.push_back(cmd-&gt;toLoadUnitIds[i]);
-            }
-            break;
-        }
-        case COMMAND_UNIT_LOAD_UNITS_AREA:
-        {
-            SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_LOAD_UNITS;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			for (int i = 0; i &lt; cmd-&gt;numToLoadUnits; ++i) {
+				c-&gt;params.push_back(cmd-&gt;toLoadUnitIds[i]);
+			}
+			break;
+		}
+		case COMMAND_UNIT_LOAD_UNITS_AREA:
+		{
+			SLoadUnitsAreaUnitCommand* cmd = (SLoadUnitsAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_LOAD_UNITS;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;pos.x);
-            c-&gt;params.push_back(cmd-&gt;pos.y);
-            c-&gt;params.push_back(cmd-&gt;pos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_LOAD_ONTO:
-        {
-            SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_LOAD_ONTO;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;pos.x);
+			c-&gt;params.push_back(cmd-&gt;pos.y);
+			c-&gt;params.push_back(cmd-&gt;pos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_LOAD_ONTO:
+		{
+			SLoadOntoUnitCommand* cmd = (SLoadOntoUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_LOAD_ONTO;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;transporterUnitId);
-            break;
-        }
-        case COMMAND_UNIT_UNLOAD_UNITS_AREA:
-        {
-            SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_UNLOAD_UNITS;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;transporterUnitId);
+			break;
+		}
+		case COMMAND_UNIT_UNLOAD_UNITS_AREA:
+		{
+			SUnloadUnitsAreaUnitCommand* cmd = (SUnloadUnitsAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_UNLOAD_UNITS;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toPos.x);
-            c-&gt;params.push_back(cmd-&gt;toPos.y);
-            c-&gt;params.push_back(cmd-&gt;toPos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_UNLOAD_UNIT:
-        {
-            SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_UNLOAD_UNIT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toPos.x);
+			c-&gt;params.push_back(cmd-&gt;toPos.y);
+			c-&gt;params.push_back(cmd-&gt;toPos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_UNLOAD_UNIT:
+		{
+			SUnloadUnitCommand* cmd = (SUnloadUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_UNLOAD_UNIT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toPos.x);
-            c-&gt;params.push_back(cmd-&gt;toPos.y);
-            c-&gt;params.push_back(cmd-&gt;toPos.z);
-            c-&gt;params.push_back(cmd-&gt;toUnloadUnitId);
-            break;
-        }
-        case COMMAND_UNIT_SET_ON_OFF:
-        {
-            SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_ONOFF;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toPos.x);
+			c-&gt;params.push_back(cmd-&gt;toPos.y);
+			c-&gt;params.push_back(cmd-&gt;toPos.z);
+			c-&gt;params.push_back(cmd-&gt;toUnloadUnitId);
+			break;
+		}
+		case COMMAND_UNIT_SET_ON_OFF:
+		{
+			SSetOnOffUnitCommand* cmd = (SSetOnOffUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_ONOFF;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;on);
-            break;
-        }
-        case COMMAND_UNIT_RECLAIM:
-        {
-            SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_RECLAIM;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;on);
+			break;
+		}
+		case COMMAND_UNIT_RECLAIM:
+		{
+			SReclaimUnitCommand* cmd = (SReclaimUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_RECLAIM;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toReclaimUnitIdOrFeatureId);
-            break;
-        }
-        case COMMAND_UNIT_RECLAIM_AREA:
-        {
-            SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_RECLAIM;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toReclaimUnitIdOrFeatureId);
+			break;
+		}
+		case COMMAND_UNIT_RECLAIM_AREA:
+		{
+			SReclaimAreaUnitCommand* cmd = (SReclaimAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_RECLAIM;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;pos.x);
-            c-&gt;params.push_back(cmd-&gt;pos.y);
-            c-&gt;params.push_back(cmd-&gt;pos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_CLOAK:
-        {
-            SCloakUnitCommand* cmd = (SCloakUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_CLOAK;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;pos.x);
+			c-&gt;params.push_back(cmd-&gt;pos.y);
+			c-&gt;params.push_back(cmd-&gt;pos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_CLOAK:
+		{
+			SCloakUnitCommand* cmd = (SCloakUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_CLOAK;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;cloak);
-            break;
-        }
-        case COMMAND_UNIT_STOCKPILE:
-        {
-            SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_STOCKPILE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
-            break;
-        }
-        case COMMAND_UNIT_D_GUN:
-        {
-            SDGunUnitCommand* cmd = (SDGunUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_DGUN;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;cloak);
+			break;
+		}
+		case COMMAND_UNIT_STOCKPILE:
+		{
+			SStockpileUnitCommand* cmd = (SStockpileUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_STOCKPILE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
+			break;
+		}
+		case COMMAND_UNIT_D_GUN:
+		{
+			SDGunUnitCommand* cmd = (SDGunUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_DGUN;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toAttackUnitId);
-            break;
-        }
-        case COMMAND_UNIT_D_GUN_POS:
-        {
-            SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_DGUN;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toAttackUnitId);
+			break;
+		}
+		case COMMAND_UNIT_D_GUN_POS:
+		{
+			SDGunPosUnitCommand* cmd = (SDGunPosUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_DGUN;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;pos.x);
-            c-&gt;params.push_back(cmd-&gt;pos.y);
-            c-&gt;params.push_back(cmd-&gt;pos.z);
-            break;
-        }
-        case COMMAND_UNIT_RESTORE_AREA:
-        {
-            SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_RESTORE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;pos.x);
+			c-&gt;params.push_back(cmd-&gt;pos.y);
+			c-&gt;params.push_back(cmd-&gt;pos.z);
+			break;
+		}
+		case COMMAND_UNIT_RESTORE_AREA:
+		{
+			SRestoreAreaUnitCommand* cmd = (SRestoreAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_RESTORE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;pos.x);
-            c-&gt;params.push_back(cmd-&gt;pos.y);
-            c-&gt;params.push_back(cmd-&gt;pos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_SET_REPEAT:
-        {
-            SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_REPEAT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;pos.x);
+			c-&gt;params.push_back(cmd-&gt;pos.y);
+			c-&gt;params.push_back(cmd-&gt;pos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_SET_REPEAT:
+		{
+			SSetRepeatUnitCommand* cmd = (SSetRepeatUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_REPEAT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;repeat);
-            break;
-        }
-        case COMMAND_UNIT_SET_TRAJECTORY:
-        {
-            SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_TRAJECTORY;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;repeat);
+			break;
+		}
+		case COMMAND_UNIT_SET_TRAJECTORY:
+		{
+			SSetTrajectoryUnitCommand* cmd = (SSetTrajectoryUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_TRAJECTORY;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;trajectory);
-            break;
-        }
-        case COMMAND_UNIT_RESURRECT:
-        {
-            SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_RESURRECT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;trajectory);
+			break;
+		}
+		case COMMAND_UNIT_RESURRECT:
+		{
+			SResurrectUnitCommand* cmd = (SResurrectUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_RESURRECT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toResurrectFeatureId);
-            break;
-        }
-        case COMMAND_UNIT_RESURRECT_AREA:
-        {
-            SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_RESURRECT;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toResurrectFeatureId);
+			break;
+		}
+		case COMMAND_UNIT_RESURRECT_AREA:
+		{
+			SResurrectAreaUnitCommand* cmd = (SResurrectAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_RESURRECT;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;pos.x);
-            c-&gt;params.push_back(cmd-&gt;pos.y);
-            c-&gt;params.push_back(cmd-&gt;pos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_CAPTURE:
-        {
-            SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_CAPTURE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;pos.x);
+			c-&gt;params.push_back(cmd-&gt;pos.y);
+			c-&gt;params.push_back(cmd-&gt;pos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_CAPTURE:
+		{
+			SCaptureUnitCommand* cmd = (SCaptureUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_CAPTURE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;toCaptureUnitId);
-            break;
-        }
-        case COMMAND_UNIT_CAPTURE_AREA:
-        {
-            SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_CAPTURE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;toCaptureUnitId);
+			break;
+		}
+		case COMMAND_UNIT_CAPTURE_AREA:
+		{
+			SCaptureAreaUnitCommand* cmd = (SCaptureAreaUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_CAPTURE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;pos.x);
-            c-&gt;params.push_back(cmd-&gt;pos.y);
-            c-&gt;params.push_back(cmd-&gt;pos.z);
-            c-&gt;params.push_back(cmd-&gt;radius);
-            break;
-        }
-        case COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL:
-        {
-            SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_AUTOREPAIRLEVEL;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;pos.x);
+			c-&gt;params.push_back(cmd-&gt;pos.y);
+			c-&gt;params.push_back(cmd-&gt;pos.z);
+			c-&gt;params.push_back(cmd-&gt;radius);
+			break;
+		}
+		case COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL:
+		{
+			SSetAutoRepairLevelUnitCommand* cmd = (SSetAutoRepairLevelUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_AUTOREPAIRLEVEL;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;autoRepairLevel);
-            break;
-        }
-        case COMMAND_UNIT_SET_IDLE_MODE:
-        {
-            SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) sUnitCommandData;
-            c-&gt;id = CMD_IDLEMODE;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;autoRepairLevel);
+			break;
+		}
+		case COMMAND_UNIT_SET_IDLE_MODE:
+		{
+			SSetIdleModeUnitCommand* cmd = (SSetIdleModeUnitCommand*) sUnitCommandData;
+			c-&gt;id = CMD_IDLEMODE;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            c-&gt;params.push_back(cmd-&gt;idleMode);
-            break;
-        }
-        case COMMAND_UNIT_CUSTOM:
-        {
-            SCustomUnitCommand* cmd = (SCustomUnitCommand*) sUnitCommandData;
-            c-&gt;id = cmd-&gt;cmdId;
-            c-&gt;options = cmd-&gt;options;
-            c-&gt;timeOut = cmd-&gt;timeOut;
+			c-&gt;params.push_back(cmd-&gt;idleMode);
+			break;
+		}
+		case COMMAND_UNIT_CUSTOM:
+		{
+			SCustomUnitCommand* cmd = (SCustomUnitCommand*) sUnitCommandData;
+			c-&gt;id = cmd-&gt;cmdId;
+			c-&gt;options = cmd-&gt;options;
+			c-&gt;timeOut = cmd-&gt;timeOut;
 
-            for (int i = 0; i &lt; cmd-&gt;numParams; ++i) {
-                c-&gt;params.push_back(cmd-&gt;params[i]);
-            }
-            break;
-        }
-        default:
-        {
-            delete c;
-            c = NULL;
-        }
-    }
+			for (int i = 0; i &lt; cmd-&gt;numParams; ++i) {
+				c-&gt;params.push_back(cmd-&gt;params[i]);
+			}
+			break;
+		}
+		default:
+		{
+			delete c;
+			c = NULL;
+		}
+	}
 
-    return c;
+	return c;
 }
+
+#endif /* __cplusplus */
+

Deleted: branches/caiinterface/rts/ExternalAI/AISCommands.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AISCommands.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AISCommands.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,788 +0,0 @@
-/*
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _AISCOMMANDS_H
-#define	_AISCOMMANDS_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-
-#include &quot;SAIFloat3.h&quot;
-	
-
-#define COMMAND_TO_ID_ENGINE -1
-	
-	
-#define COMMAND_NULL 0
-#define COMMAND_DRAWER_POINT_ADD 1
-#define COMMAND_DRAWER_LINE_ADD 2
-#define COMMAND_DRAWER_POINT_REMOVE 3
-#define COMMAND_SEND_START_POS 4
-#define COMMAND_CHEATS_SET_MY_HANDICAP 5
-#define COMMAND_SEND_TEXT_MESSAGE 6
-#define COMMAND_SET_LAST_POS_MESSAGE 7
-#define COMMAND_SEND_RESOURCES 8
-#define COMMAND_SEND_UNITS 9
-#define COMMAND_SHARED_MEM_AREA_CREATE 10
-#define COMMAND_SHARED_MEM_AREA_RELEASE 11
-#define COMMAND_GROUP_CREATE 12
-#define COMMAND_GROUP_ERASE 13
-#define COMMAND_GROUP_ADD_UNIT 14
-#define COMMAND_GROUP_REMOVE_UNIT 15
-#define COMMAND_PATH_INIT 16
-#define COMMAND_PATH_GET_APPROXIMATE_LENGTH 17
-#define COMMAND_PATH_GET_NEXT_WAYPOINT 18
-#define COMMAND_PATH_FREE 19
-#define COMMAND_CHEATS_GIVE_ME_METAL 20
-#define COMMAND_CALL_LUA_RULES 21
-#define COMMAND_DRAWER_ADD_NOTIFICATION 22
-#define COMMAND_DRAWER_DRAW_UNIT 23
-#define COMMAND_DRAWER_PATH_START 24
-#define COMMAND_DRAWER_PATH_FINISH 25
-#define COMMAND_DRAWER_PATH_DRAW_LINE 26
-#define COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON 27
-#define COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS 28
-#define COMMAND_DRAWER_PATH_BREAK 29
-#define COMMAND_DRAWER_PATH_RESTART 30
-#define COMMAND_DRAWER_FIGURE_CREATE_SPLINE 31
-#define COMMAND_DRAWER_FIGURE_CREATE_LINE 32
-#define COMMAND_DRAWER_FIGURE_SET_COLOR 33
-#define COMMAND_DRAWER_FIGURE_DELETE 34
-#define COMMAND_UNIT_BUILD 35
-#define COMMAND_UNIT_STOP 36
-#define COMMAND_UNIT_WAIT 37
-#define COMMAND_UNIT_WAIT_TIME 38
-#define COMMAND_UNIT_WAIT_DEATH 39
-#define COMMAND_UNIT_WAIT_SQUAD 40
-#define COMMAND_UNIT_WAIT_GATHER 41
-#define COMMAND_UNIT_MOVE 42
-#define COMMAND_UNIT_PATROL 43
-#define COMMAND_UNIT_FIGHT 44
-#define COMMAND_UNIT_ATTACK 45
-#define COMMAND_UNIT_ATTACK_AREA 46
-#define COMMAND_UNIT_GUARD 47
-#define COMMAND_UNIT_AI_SELECT 48
-#define COMMAND_UNIT_GROUP_ADD 49
-#define COMMAND_UNIT_GROUP_CLEAR 50
-#define COMMAND_UNIT_REPAIR 51
-#define COMMAND_UNIT_SET_FIRE_STATE 52
-#define COMMAND_UNIT_SET_MOVE_STATE 53
-#define COMMAND_UNIT_SET_BASE 54
-#define COMMAND_UNIT_SELF_DESTROY 55
-#define COMMAND_UNIT_SET_WANTED_MAX_SPEED 56
-#define COMMAND_UNIT_LOAD_UNITS 57
-#define COMMAND_UNIT_LOAD_UNITS_AREA 58
-#define COMMAND_UNIT_LOAD_ONTO 59
-#define COMMAND_UNIT_UNLOAD_UNITS_AREA 60
-#define COMMAND_UNIT_UNLOAD_UNIT 61
-#define COMMAND_UNIT_SET_ON_OFF 62
-#define COMMAND_UNIT_RECLAIM 63
-#define COMMAND_UNIT_RECLAIM_AREA 64
-#define COMMAND_UNIT_CLOAK 65
-#define COMMAND_UNIT_STOCKPILE 66
-#define COMMAND_UNIT_D_GUN 67
-#define COMMAND_UNIT_D_GUN_POS 68
-#define COMMAND_UNIT_RESTORE_AREA 69
-#define COMMAND_UNIT_SET_REPEAT 70
-#define COMMAND_UNIT_SET_TRAJECTORY 71
-#define COMMAND_UNIT_RESURRECT 72
-#define COMMAND_UNIT_RESURRECT_AREA 73
-#define COMMAND_UNIT_CAPTURE 74
-#define COMMAND_UNIT_CAPTURE_AREA 75
-#define COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL 76
-#define COMMAND_UNIT_SET_IDLE_MODE 77
-#define COMMAND_UNIT_CUSTOM 78
-//#define COMMAND_UNIT_ATTACK_POS 
-//#define COMMAND_UNIT_INSERT 
-//#define COMMAND_UNIT_REMOVE 
-//#define COMMAND_UNIT_ATTACK_AREA 
-//#define COMMAND_UNIT_ATTACK_LOOPBACK 
-//#define COMMAND_UNIT_GROUP_SELECT 
-//#define COMMAND_UNIT_INTERNAL 
-#define COMMAND_CHEATS_GIVE_ME_ENERGY 79
-#define COMMAND_CHEATS_GIVE_ME_NEW_UNIT 80
-
-#define NUM_CMD_TOPICS 81
-
-	
-#define UNIT_COMMAND_OPTION_DONT_REPEAT	 (1 &lt;&lt; 3) //   8
-#define UNIT_COMMAND_OPTION_RIGHT_MOUSE_KEY (1 &lt;&lt; 4) //  16
-#define UNIT_COMMAND_OPTION_SHIFT_KEY	   (1 &lt;&lt; 5) //  32
-#define UNIT_COMMAND_OPTION_CONTROL_KEY	 (1 &lt;&lt; 6) //  64
-#define UNIT_COMMAND_OPTION_ALT_KEY		 (1 &lt;&lt; 7) // 128
-
-
-#define UNIT_COMMAND_BUILD_NO_FACING -1
-
-	
-	
-	struct SSetMyHandicapCheatCommand {
-		float handicap;
-	};
-	struct SGiveMeMetalCheatCommand {
-		float amount;
-	};
-	struct SGiveMeEnergyCheatCommand {
-		float amount;
-	};
-	struct SGiveMeNewUnitCheatCommand {
-		int unitDefId;
-		SAIFloat3 pos;
-		int ret_newUnitId;
-	};
-	
-	struct SSendTextMessageCommand {
-		const char* text;
-		int zone;
-	};
-
-	struct SSetLastPosMessageCommand {
-		SAIFloat3 pos;
-	};
-
-	struct SSendResourcesCommand {
-		float mAmount;
-		float eAmount;
-		int receivingTeam;
-		bool ret_isExecuted;
-	};
-
-	struct SSendUnitsCommand {
-		int* unitIds;
-		int numUnitIds;
-		int receivingTeam;
-		int ret_sentUnits;
-	};
-
-	struct SCreateSharedMemAreaCommand {
-		char* name;
-		int size;
-		void* ret_sharedMemArea;
-	};
-
-	struct SReleaseSharedMemAreaCommand {
-		char* name;
-	};
-
-	struct SCreateGroupCommand {
-		char* libraryName;
-		unsigned int aiNumber;
-		int ret_groupId;
-	};
-	struct SEraseGroupCommand {
-		int groupId;
-	};
-	struct SAddUnitToGroupCommand {
-		int groupId;
-		int unitId;
-		bool ret_isExecuted;
-	};
-	struct SRemoveUnitFromGroupCommand {
-		int unitId;
-		bool ret_isExecuted;
-	};
-
-	
-	struct SInitPathCommand {
-		SAIFloat3 start;
-		SAIFloat3 end;
-		int pathType;
-		int ret_pathId;
-	};
-	/**
-	 * Returns the approximate path cost between two points
-	 * note: needs to calculate the complete path so somewhat expensive
-	 * note: currently disabled, always returns 0
-	 */
-	struct SGetApproximateLengthPathCommand {
-		SAIFloat3 start;
-		SAIFloat3 end;
-		int pathType;
-		int ret_approximatePathLength;
-	};
-	struct SGetNextWaypointPathCommand {
-		int pathId;
-		SAIFloat3 ret_nextWaypoint;
-	};
-	struct SFreePathCommand {
-		int pathId;
-	};
-
-	struct SCallLuaRulesCommand {
-		const char* data;
-		int inSize;
-		int* outSize;
-		const char* ret_outData;
-	};
-
-	struct SSendStartPosCommand ///&lt; result of HandleCommand is 1 - ok supported
-	{
-		bool ready;
-		SAIFloat3 pos;
-	};
-
-	struct SAddNotificationDrawerCommand {
-		SAIFloat3 pos;
-		SAIFloat3 color;
-		float alpha;
-	};
-	struct SAddPointDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
-	{
-		SAIFloat3 pos; ///&lt; on this position, only x and z matter
-		char* label; ///&lt; create this text on pos in my team color
-	};
-	struct SRemovePointDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
-	{
-		SAIFloat3 pos; ///&lt; remove map points and lines near this point (100 distance)
-	};
-	struct SAddLineDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
-	{
-		SAIFloat3 posFrom; ///&lt; draw line from this pos
-		SAIFloat3 posTo; ///&lt; to this pos, again only x and z matter
-	};
-	
-	struct SStartPathDrawerCommand {
-		SAIFloat3 pos;
-		SAIFloat3 color;
-		float alpha;
-	};
-	struct SFinishPathDrawerCommand {
-	};
-	struct SDrawLinePathDrawerCommand {
-		SAIFloat3 endPos;
-		SAIFloat3 color;
-		float alpha;
-	};
-	struct SDrawLineAndIconPathDrawerCommand {
-		int cmdId;
-		SAIFloat3 endPos;
-		SAIFloat3 color;
-		float alpha;
-	};
-	struct SDrawIconAtLastPosPathDrawerCommand {
-		int cmdId;
-	};
-	struct SBreakPathDrawerCommand {
-		SAIFloat3 endPos;
-		SAIFloat3 color;
-		float alpha;
-	};
-	struct SRestartPathDrawerCommand {
-		bool sameColor;
-	};
-
-	/**
-	 * Creates a cubic Bezier spline figure (from pos1 to pos4 with control points pos2 and pos3)
-	 */
-	struct SCreateSplineFigureDrawerCommand {
-		SAIFloat3 pos1;
-		SAIFloat3 pos2;
-		SAIFloat3 pos3;
-		SAIFloat3 pos4;
-		float width;
-		bool arrow; // true: means that the figure will get an arrow at the end
-		int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
-		int figureGroupId; // use 0 to get a new group
-		int ret_newFigureGroupId; // the new group
-	};
-	struct SCreateLineFigureDrawerCommand {
-		SAIFloat3 pos1;
-		SAIFloat3 pos2;
-		float width;
-		bool arrow; // true: means that the figure will get an arrow at the end
-		int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
-		int figureGroupId; // use 0 to get a new group
-		int ret_newFigureGroupId; // the new group
-	};
-	struct SSetColorFigureDrawerCommand {
-		int figureGroupId;
-		SAIFloat3 color;
-		float alpha;
-	};
-	struct SDeleteFigureDrawerCommand {
-		int figureGroupId;
-	};
-
-	struct SDrawUnitDrawerCommand {
-		int toDrawUnitDefId;
-		SAIFloat3 pos;
-		float rotation;
-		int lifeTime;
-		int teamId;
-		bool transparent;
-		bool drawBorder;
-		int facing;
-	};
-
-	
-	
-	struct SBuildUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toBuildUnitDefId;
-		SAIFloat3 buildPos;
-		int facing; // set to UNIT_COMMAND_BUILD_NO_FACING if you want to specify no facing
-	};
-
-	struct SStopUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-//	struct SInsertUnitCommand {
-//		int unitId;
-//		int groupId;
-//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-//		int timeOut; // command execution-time in ?seconds?
-//	};	
-//
-//	struct SRemoveUnitCommand {
-//		int unitId;
-//		int groupId;
-//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-//		int timeOut; // command execution-time in ?seconds?
-//	};	
-
-	struct SWaitUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-	struct STimeWaitUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		// the time in seconds to wait
-		int time;
-	};	
-
-	struct SDeathWaitUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		// wait until this unit is dead
-		int toDieUnitId;
-	};	
-
-	struct SSquadWaitUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int numUnits;
-	};	
-
-	struct SGatherWaitUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-	struct SMoveUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 toPos;
-	};	
-
-	struct SPatrolUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 toPos;
-	};	
-
-	struct SFightUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 toPos;
-	};	
-
-	struct SAttackUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toAttackUnitId;
-	};	
-
-//	struct SAttackPosUnitCommand {
-	struct SAttackAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 toAttackPos;
-		float radius;
-	};	
-
-//	struct SAttackAreaUnitCommand {
-//		int unitId;
-//		int groupId;
-//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-//		int timeOut; // command execution-time in ?seconds?
-//	};	
-
-	struct SGuardUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toGuardUnitId;
-	};	
-
-	struct SAiSelectUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-//	struct SGroupSelectUnitCommand {
-//		int unitId;
-//		int groupId;
-//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-//		int timeOut; // command execution-time in ?seconds?
-//	};	
-
-	struct SGroupAddUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toGroupId;
-	};	
-
-	struct SGroupClearUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-	struct SRepairUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toRepairUnitId;
-	};	
-
-	struct SSetFireStateUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		// can be: 0=hold fire, 1=return fire, 2=fire at will
-		int fireState;
-	};	
-
-	struct SSetMoveStateUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int moveState;
-	};	
-
-	struct SSetBaseUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 basePos;
-	};	
-
-//	struct SInternalUnitCommand {
-//		int unitId;
-//		int groupId;
-//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-//		int timeOut; // command execution-time in ?seconds?
-//	};	
-
-	struct SSelfDestroyUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-	struct SSetWantedMaxSpeedUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		float wantedMaxSpeed;
-	};	
-
-	struct SLoadUnitsUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int* toLoadUnitIds;
-		int numToLoadUnits;
-	};	
-
-	struct SLoadUnitsAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 pos;
-		float radius;
-	};	
-
-	struct SLoadOntoUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int transporterUnitId;
-	};	
-
-	struct SUnloadUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 toPos;
-		int toUnloadUnitId;
-	};	
-
-	struct SUnloadUnitsAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 toPos;
-		float radius;
-	};	
-
-	struct SSetOnOffUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		bool on;
-	};	
-
-	struct SReclaimUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toReclaimUnitIdOrFeatureId;
-	};	
-
-	struct SReclaimAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 pos;
-		float radius;
-	};	
-
-	struct SCloakUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		bool cloak;
-	};	
-
-	struct SStockpileUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-	};	
-
-	struct SDGunUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toAttackUnitId;
-	};	
-
-	struct SDGunPosUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 pos;
-	};	
-
-	struct SRestoreAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 pos;
-		float radius;
-	};	
-
-	struct SSetRepeatUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		bool repeat;
-	};	
-
-	struct SSetTrajectoryUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int trajectory;
-	};	
-
-	struct SResurrectUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toResurrectFeatureId;
-	};	
-
-	struct SResurrectAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 pos;
-		float radius;
-	};	
-
-	struct SCaptureUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int toCaptureUnitId;
-	};	
-
-	struct SCaptureAreaUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		SAIFloat3 pos;
-		float radius;
-	};	
-
-	struct SSetAutoRepairLevelUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int autoRepairLevel;
-	};	
-
-//	struct SAttackLoopbackUnitCommand {
-//		int unitId;
-//		int groupId;
-//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-//		int timeOut; // command execution-time in ?seconds?
-//	};	
-
-	struct SSetIdleModeUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int idleMode;
-	};	
-
-	struct SCustomUnitCommand {
-		int unitId;
-		int groupId;
-		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-		int timeOut; // command execution-time in ?seconds?
-		
-		int cmdId;
-		float* params;
-		int numParams;
-	};
-
-	
-void initSUnitCommand(void* sUnitCommand);
-
-// legacy support functions
-// the void* c has to be of type Command*
-void* mallocSUnitCommand(int unitId, int groupId, void* c, int sCommandId[0]);
-void freeSUnitCommand(void* sCommandData, int sCommandId);
-// the returned void* is a Command*
-void* newCommand(void* sUnitCommandData, int sCommandId);
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _AISCOMMANDS_H */
-

Deleted: branches/caiinterface/rts/ExternalAI/AISEvents.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AISEvents.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/AISEvents.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,149 +0,0 @@
-/*
-	Copyright 2008  Nicolas Wu
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef AISEVENTS_H
-#define AISEVENTS_H
-
-#include &quot;SAIFloat3.h&quot;
-#include &quot;SAICallback.h&quot;
-
-#define EVENT_NULL				0
-#define EVENT_INIT				1
-#define EVENT_UPDATE			2
-#define EVENT_MESSAGE			3
-#define EVENT_UNIT_CREATED		4
-#define EVENT_UNIT_FINISHED		5
-#define EVENT_UNIT_IDLE			6
-#define EVENT_UNIT_MOVE_FAILED	7
-#define EVENT_UNIT_DAMAGED		8
-#define EVENT_UNIT_DESTROYED	9
-#define EVENT_UNIT_GIVEN		10
-#define EVENT_UNIT_CAPTURED		11
-#define EVENT_ENEMY_ENTER_LOS	12
-#define EVENT_ENEMY_LEAVE_LOS	13
-#define EVENT_ENEMY_ENTER_RADAR 14
-#define EVENT_ENEMY_LEAVE_RADAR 15
-#define EVENT_ENEMY_DAMAGED		16
-#define EVENT_ENEMY_DESTROYED	17
-#define EVENT_WEAPON_FIRED		18
-#define EVENT_PLAYER_COMMAND	19
-#define EVENT_SEISMIC_PING		20
-
-#define NUM_EVENTS				21
-
-
-struct SInitEvent {
-	int team;
-	SAICallback* c_callback;
-};
-
-struct SUpdateEvent {
-	int frame;
-};
-
-struct SMessageEvent {
-	int player;
-	const char* message;
-};
-
-struct SUnitCreatedEvent {
-	int unit;
-};
-
-struct SUnitFinishedEvent {
-	int unit;
-};
-
-struct SUnitIdleEvent {
-	int unit;
-};
-
-struct SUnitMoveFailedEvent {
-	int unit;
-};
-
-struct SUnitDamagedEvent {
-	int unit;
-	int attacker;
-	float damage;
-	SAIFloat3 dir;
-};
-
-struct SUnitDestroyedEvent {
-	int unit;
-	int attacker;
-};
-
-struct SUnitGivenEvent {
-	int unitId;
-	int oldTeamId;
-	int newTeamId;
-};
-
-struct SUnitCapturedEvent {
-	int unitId;
-	int oldTeamId;
-	int newTeamId;
-};
-
-struct SEnemyEnterLOSEvent {
-	int enemy;
-};
-
-struct SEnemyLeaveLOSEvent {
-	int enemy;
-};
-
-struct SEnemyEnterRadarEvent {
-	int enemy;
-};
-
-struct SEnemyLeaveRadarEvent {
-	int enemy;
-};
-
-struct SEnemyDamagedEvent {
-	int enemy;
-	int attacker;
-	float damage;
-	SAIFloat3 dir;
-};
-
-struct SEnemyDestroyedEvent {
-	int enemy;
-	int attacker;
-};
-
-struct SWeaponFiredEvent {
-	int unitId;
-	int weaponDefId;
-};
-
-struct SPlayerCommandEvent {
-	int* unitIds;
-	int numUnitIds;
-	int commandTopic; // see AISCommands.h COMMAND_* defines
-	void* commandData; // see AISCommands.h S*Command structs
-	int playerId;
-};
-
-struct SSeismicPingEvent {
-	SAIFloat3 pos;
-	float strength;
-};
-
-#endif /*AISEVENTS_H*/

Deleted: branches/caiinterface/rts/ExternalAI/GlobalAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAI.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/GlobalAI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,272 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;GlobalAI.h&quot;
-#include &quot;IGlobalAI.h&quot;
-#include &quot;GlobalAICallback.h&quot;
-#include &quot;GlobalAIHandler.h&quot;
-#include &quot;Platform/FileSystem.h&quot;
-#include &quot;Platform/errorhandler.h&quot;
-#include &quot;Platform/SharedLib.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &quot;mmgr.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sim/Units/UnitHandler.h&quot;
-
-#include &lt;sstream&gt;
-
-CR_BIND_DERIVED(CGlobalAI, CObject, (0, NULL))
-CR_REG_METADATA(CGlobalAI, (
-	CR_MEMBER(team),
-	CR_MEMBER(cheatevents),
-	CR_MEMBER(libName),
-	CR_MEMBER(IsCInterface),
-	CR_MEMBER(IsLoadSupported),
-	CR_SERIALIZER(Serialize),
-	CR_POSTLOAD(PostLoad)
-));
-
-void AIException(const char *what);
-
-#define HANDLE_EXCEPTION					\
-	catch (const std::exception&amp; e) {		\
-		if (globalAI-&gt;CatchException()) {	\
-			AIException(e.what());			\
-			throw;							\
-		} else throw;						\
-	}										\
-	catch (const char *s) {	\
-		if (globalAI-&gt;CatchException()) {	\
-			AIException(s);					\
-			throw;							\
-		} else throw;						\
-	}										\
-	catch (...) {							\
-		if (globalAI-&gt;CatchException()) {	\
-			AIException(0);					\
-			throw;							\
-		} else throw;						\
-	}
-
-CGlobalAI::CGlobalAI() {
-    
-}
-
-CGlobalAI::CGlobalAI(int team, const char* botLibName): team(team), cheatevents(false), libName(botLibName? botLibName: &quot;&quot;)
-{
-	LoadAILib(team, botLibName, false);
-}
-
-void CGlobalAI::PreDestroy()
-{
-	callback-&gt;noMessages = true;
-}
-
-CGlobalAI::~CGlobalAI(void)
-{
-	if (ai) {
-		if (!IsCInterface) {
-			try {
-				_ReleaseAIFunc(ai);
-			} HANDLE_EXCEPTION;
-		}
-
-		delete lib;
-		delete callback;
-	}
-}
-
-void CGlobalAI::Serialize(creg::ISerializer* s)
-{
-}
-
-
-
-void CGlobalAI::Load(std::istream* s)
-{
-	try {
-		ai-&gt;Load(callback, s);
-	} HANDLE_EXCEPTION;
-}
-
-void CGlobalAI::Save(std::ostream* s)
-{
-	try {
-		ai-&gt;Save(s);
-	} HANDLE_EXCEPTION;
-}
-
-
-
-void CGlobalAI::PostLoad()
-{
-	LoadAILib(team, libName.c_str(), true);
-}
-
-
-
-void CGlobalAI::LoadAILib(int team, const char* botLibName, bool postLoad)
-{
-	ai = 0;
-
-	if (!botLibName) {
-		// no AI for this team
-		return;
-	}
-
-	if (!filesystem.GetFilesize(botLibName)) {
-		char msg[512];
-		SNPRINTF(msg, 511, &quot;Could not find GlobalAI library \&quot;%s\&quot;&quot;, botLibName);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-	bool isJavaAI = (strstr(botLibName, &quot;.jar&quot;) == (botLibName + strlen(botLibName) - 4));
-
-	if (isJavaAI) {
-		// Java AI, need to load the JAI proxy first
-		LoadJavaProxyAI();
-	} else {
-		lib = SharedLib::Instantiate(botLibName);
-	}
-
-	// the JAI proxy is C++ anyway
-	_IsCInterfaceFunc = (isJavaAI)? 0: (ISCINTERFACE) lib-&gt;FindAddress(&quot;IsCInterface&quot;);
-	_IsLoadSupportedFunc = (ISLOADSUPPORTED) lib-&gt;FindAddress(&quot;IsLoadSupported&quot;);
-
-	IsCInterface = (_IsCInterfaceFunc != 0 &amp;&amp; _IsCInterfaceFunc() == 1);
-	IsLoadSupported = (_IsLoadSupportedFunc != 0 &amp;&amp; _IsLoadSupportedFunc());
-
-	//if (IsCInterface) {
-	//	LoadABICAI(team, botLibName, postLoad, IsLoadSupported);
-	//} else {
-		LoadCPPAI(team, botLibName, postLoad, IsLoadSupported, isJavaAI);
-	//}
-
-
-	if (postLoad &amp;&amp; !IsLoadSupported) {
-		// fallback code to help the AI if it
-		// doesn't implement load/save support
-		for (int a = 0; a &lt; MAX_UNITS; a++) {
-			if (!uh-&gt;units[a])
-				continue;
-
-			if (uh-&gt;units[a]-&gt;team == team) {
-				try {
-					ai-&gt;UnitCreated(a);
-				} HANDLE_EXCEPTION;
-				if (!uh-&gt;units[a]-&gt;beingBuilt)
-					try {
-						ai-&gt;UnitFinished(a);
-					} HANDLE_EXCEPTION;
-			} else {
-				if ((uh-&gt;units[a]-&gt;allyteam == gs-&gt;AllyTeam(team)) || gs-&gt;Ally(gs-&gt;AllyTeam(team), uh-&gt;units[a]-&gt;allyteam)) {
-					/* do nothing */
-				} else {
-					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; (LOS_INRADAR | LOS_INLOS)) {
-						try {
-							ai-&gt;EnemyEnterRadar(a);
-						} HANDLE_EXCEPTION;
-					}
-					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(team)] &amp; LOS_INLOS) {
-						try {
-							ai-&gt;EnemyEnterLOS(a);
-						} HANDLE_EXCEPTION;
-					}
-				}
-			}
-		}
-	}
-}
-
-void CGlobalAI::LoadCPPAI(int team, const char* botLibName, bool postLoad, bool loadSupported, bool isJavaAI)
-{
-	if (isJavaAI) {
-		logOutput &lt;&lt; botLibName &lt;&lt; &quot; is a Java archive\n&quot;;
-	} else {
-		logOutput &lt;&lt; botLibName &lt;&lt; &quot; has a C++ interface\n&quot;;
-	}
-
-	_GetGlobalAiVersionFunc = (GETGLOBALAIVERSION) lib-&gt;FindAddress(&quot;GetGlobalAiVersion&quot;);
-
-	if (_GetGlobalAiVersionFunc == 0) {
-		char msg[512];
-		SNPRINTF(msg, 511, &quot;Incorrect GlobalAI library \&quot;%s\&quot; (no \&quot;GetGlobalAiVersion\&quot; function exported)&quot;, botLibName);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-	const int botInterfaceVersion = _GetGlobalAiVersionFunc();
-
-	if (botInterfaceVersion != GLOBAL_AI_INTERFACE_VERSION) {
-		char msg[1024];
-		SNPRINTF(msg, 1023,
-			&quot;Incorrect GlobalAI library \&quot;%s\&quot;\n&quot;
-			&quot;(lib interface version %d, engine interface version %d)&quot;,
-			botLibName, botInterfaceVersion, GLOBAL_AI_INTERFACE_VERSION);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-
-	if (isJavaAI) {
-		// we want to load a Java AI inside a jar,
-		// pass the name of the actual .jar to the
-		// proxy library so it can spawn a JVM for
-		// that AI
-		_GetNewAIByNameFunc = (GETNEWAIBYNAME) lib-&gt;FindAddress(&quot;GetNewAIByName&quot;);
-
-		if (_GetNewAIByNameFunc == 0) {
-			throw std::runtime_error(&quot;JAI proxy does not export \&quot;GetNewAIByName\&quot;&quot;);
-		}
-
-		// note: team parameter is unnecessary
-		ai = _GetNewAIByNameFunc(botLibName, team);
-	} else {
-		_GetNewAIFunc = (GETNEWAI) lib-&gt;FindAddress(&quot;GetNewAI&quot;);
-
-		if (_GetNewAIFunc == 0) {
-			char msg[512];
-			SNPRINTF(msg, 511, &quot;GlobalAI library \&quot;%s\&quot; does not export \&quot;GetNewAI\&quot;&quot;, botLibName);
-			throw std::runtime_error(msg);
-		}
-
-		ai = _GetNewAIFunc();
-	}
-
-	// note: verify that this is really exported too?
-	_ReleaseAIFunc = (RELEASEAI) lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
-	callback = SAFE_NEW CGlobalAICallback(this);
-
-	if (!postLoad || (postLoad &amp;&amp; !loadSupported)) {
-		try {
-			ai-&gt;InitAI(callback, team);
-		} HANDLE_EXCEPTION;
-	}
-}
-
-
-void CGlobalAI::LoadJavaProxyAI()
-{
-	// TODO: Mac support? non-hardcoded proxy?
-	#ifdef WIN32
-	const char* javaProxyAI = &quot;AI\\Bot-libs\\JAI\\JAI.dll&quot;;
-	#else
-	const char* javaProxyAI = &quot;AI/Bot-libs/JAI/JAI.so&quot;;
-	#endif
-
-	if (!filesystem.GetFilesize(javaProxyAI)) {
-		char msg[512];
-		SNPRINTF(msg, 511, &quot;Could not find Java GlobalAI proxy library \&quot;%s\&quot;&quot;, javaProxyAI);
-		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
-		return;
-	}
-
-	lib = SharedLib::Instantiate(javaProxyAI);
-}
-
-
-void CGlobalAI::Update(void)
-{
-	ai-&gt;Update();
-}
-
-IMPLEMENT_PURE_VIRTUAL(IGlobalAI::~IGlobalAI())

Deleted: branches/caiinterface/rts/ExternalAI/GlobalAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAI.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/GlobalAI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,60 +0,0 @@
-#ifndef GLOBALAI_H
-#define GLOBALAI_H
-
-#include &quot;Object.h&quot;
-#include &quot;Platform/SharedLib.h&quot;
-
-class IGlobalAI;
-class CGlobalAICallback;
-class CGroupHandler;
-
-class CGlobalAI: public CObject
-{
-public:
-	CR_DECLARE(CGlobalAI);
-	CGlobalAI();
-	CGlobalAI(int team, const char* dll);
-	~CGlobalAI(void);
-
-	virtual void LoadAILib(int, const char*, bool);
-
-	void Serialize(creg::ISerializer *s);
-	void PostLoad();
-	virtual void Load(std::istream *s);
-	virtual void Save(std::ostream *s);
-
-	virtual void Update(void);
-	virtual void PreDestroy(); // called just before all the units are destroyed
-
-	int team;
-	bool cheatevents;
-
-	bool IsCInterface;
-	bool IsLoadSupported;
-
-	IGlobalAI* ai;
-	CGlobalAICallback* callback;
-
-	SharedLib* lib;
-	std::string libName;
-
-	typedef bool (*ISCINTERFACE)();
-	typedef int (*GETGLOBALAIVERSION)();
-	typedef IGlobalAI* (*GETNEWAI)();
-	typedef IGlobalAI* (*GETNEWAIBYNAME)(const char*, int);
-	typedef void (*RELEASEAI)(IGlobalAI* i);
-	typedef bool (*ISLOADSUPPORTED)();
-	
-	ISCINTERFACE _IsCInterfaceFunc;
-	GETGLOBALAIVERSION _GetGlobalAiVersionFunc;
-	GETNEWAI _GetNewAIFunc;
-	GETNEWAIBYNAME _GetNewAIByNameFunc;
-	RELEASEAI _ReleaseAIFunc;
-	ISLOADSUPPORTED _IsLoadSupportedFunc;
-
-private:
-	void LoadCPPAI(int, const char*, bool, bool, bool);
-	void LoadJavaProxyAI();
-};
-
-#endif

Modified: branches/caiinterface/rts/ExternalAI/GlobalAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAICallback.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/GlobalAICallback.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,36 +1,36 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;GlobalAICallback.h&quot;
-#include &quot;GlobalAI.h&quot;
+#include &quot;SkirmishAIWrapper.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;GroupHandler.h&quot;
 #include &quot;AICheats.h&quot;
 #include &quot;mmgr.h&quot;
 
-CGlobalAICallback::CGlobalAICallback(CGlobalAI* ai):
+CGlobalAICallback::CGlobalAICallback(CSkirmishAIWrapper* ai):
 	ai(ai),
-	cheats(0),
-	scb(ai-&gt;team, grouphandlers[ai-&gt;team]/*ai-&gt;gh*/)
+	cheatCallback(0),
+	callback(ai-&gt;GetTeamId(), grouphandlers[ai-&gt;GetTeamId()])
 {
 }
 
-CGlobalAICallback::~CGlobalAICallback(void)
+CGlobalAICallback::~CGlobalAICallback()
 {
-	delete cheats;
+	delete cheatCallback;
 }
 
 IAICheats* CGlobalAICallback::GetCheatInterface()
 {
-	if (cheats)
-		return cheats;
+	if (cheatCallback)
+		return cheatCallback;
 
-	logOutput.Print(&quot;GlobalAI%i: Cheating enabled.&quot;, ai-&gt;team);
-	cheats = SAFE_NEW CAICheats(ai);
-	return cheats;
+	logOutput.Print(&quot;SkirmishAI (with team ID = %i): Cheating enabled!&quot;, ai-&gt;GetTeamId());
+	cheatCallback = SAFE_NEW CAICheats(ai);
+	return cheatCallback;
 }
 
 IAICallback* CGlobalAICallback::GetAICallback()
 {
-	return &scb;
+	return &callback;
 }
 
 IMPLEMENT_PURE_VIRTUAL(IGlobalAICallback::~IGlobalAICallback())

Modified: branches/caiinterface/rts/ExternalAI/GlobalAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAICallback.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/GlobalAICallback.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,25 +1,28 @@
-#ifndef GLOBALAICALLBACK_H
-#define GLOBALAICALLBACK_H
+#ifndef _GLOBALAICALLBACK_H
+#define _GLOBALAICALLBACK_H
 
 #include &quot;IGlobalAICallback.h&quot;
+
 #include &quot;AICallback.h&quot;
-class CGlobalAI;
+
+class CSkirmishAIWrapper;
 class CAICheats;
 
 class CGlobalAICallback :
 	public IGlobalAICallback
 {
-	CGlobalAI* ai;
+	CSkirmishAIWrapper* ai;
+	
 public:
-	CGlobalAICallback(CGlobalAI* ai);
-	~CGlobalAICallback(void);
+	CGlobalAICallback(CSkirmishAIWrapper* ai);
+	~CGlobalAICallback();
 
-	CAICheats* cheats;
+	CAICheats* cheatCallback;
 	bool noMessages;
-	CAICallback scb;
+	CAICallback callback;
 
-	IAICheats* GetCheatInterface();
-	IAICallback* GetAICallback();
+	virtual IAICheats* GetCheatInterface();
+	virtual IAICallback* GetAICallback();
 };
 
-#endif
+#endif /* _GLOBALAICALLBACK_H */

Modified: branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -2,7 +2,10 @@
 
 #include &quot;StdAfx.h&quot;
 #include &quot;GlobalAIHandler.h&quot;
-#include &quot;GlobalAI.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;AILibraryManager.h&quot;
+#include &quot;SkirmishAI.h&quot;
+#include &quot;SkirmishAIWrapper.h&quot;
 #include &quot;IGlobalAI.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/Player.h&quot;
@@ -71,7 +74,7 @@
 //	exit(-1);
 }
 
-CGlobalAIHandler::CGlobalAIHandler(void)
+CGlobalAIHandler::CGlobalAIHandler()
 {
 	hasAI=false;
 
@@ -79,16 +82,10 @@
 		ais[a]=0;
 }
 
-CGlobalAIHandler::~CGlobalAIHandler(void)
+CGlobalAIHandler::~CGlobalAIHandler()
 {
 	for(int a=0;a&lt;MAX_TEAMS;++a)
 		delete ais[a];
-
-	for(int team=0;team&lt;MAX_TEAMS;++team){
-		for(std::map&lt;std::string,AIMemBuffer&gt;::iterator mi=memBuffers[team].begin();mi!=memBuffers[team].end();++mi){
-			delete mi-&gt;second.mem;
-		}
-	}
 }
 
 void CGlobalAIHandler::PostLoad()
@@ -113,13 +110,14 @@
 	} HANDLE_EXCEPTION;
 }
 
-void CGlobalAIHandler::Update(void)
+void CGlobalAIHandler::Update()
 {
-	SCOPED_TIMER(&quot;Global AI&quot;)
+	SCOPED_TIMER(&quot;Skimrish AI&quot;)
 	try {
+		int frame = gs-&gt;frameNum;
 		for(int a=0;a&lt;gs-&gt;activeTeams;++a)
 			if(ais[a])
-				ais[a]-&gt;Update();
+				ais[a]-&gt;Update(frame);
 	} HANDLE_EXCEPTION;
 }
 
@@ -128,7 +126,7 @@
 	try {
 		for(int a=0;a&lt;gs-&gt;activeTeams;a++)
 			if(ais[a])
-				ais[a]-&gt;PreDestroy ();
+				ais[a]-&gt;PreDestroy();
 	} HANDLE_EXCEPTION;
 }
 
@@ -138,7 +136,7 @@
 		for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
 			if (ais[a] &amp;&amp; gs-&gt;AllyTeam(a) == allyteam &amp;&amp; !gs-&gt;Ally(allyteam, unit-&gt;allyteam))
 				try {
-					ais[a]-&gt;ai-&gt;EnemyEnterLOS(unit-&gt;id);
+					ais[a]-&gt;EnemyEnterLOS(unit-&gt;id);
 				} HANDLE_EXCEPTION;
 		}
 	}
@@ -150,7 +148,7 @@
 		for(int a=0;a&lt;gs-&gt;activeTeams;++a){
 			if(ais[a] &amp;&amp; gs-&gt;AllyTeam(a)==allyteam &amp;&amp; !gs-&gt;Ally(allyteam,unit-&gt;allyteam))
 				try {
-					ais[a]-&gt;ai-&gt;EnemyLeaveLOS(unit-&gt;id);
+					ais[a]-&gt;EnemyLeaveLOS(unit-&gt;id);
 				} HANDLE_EXCEPTION;
 		}
 	}
@@ -162,7 +160,7 @@
 		for(int a=0;a&lt;gs-&gt;activeTeams;++a){
 			if(ais[a] &amp;&amp; gs-&gt;AllyTeam(a)==allyteam &amp;&amp; !gs-&gt;Ally(allyteam,unit-&gt;allyteam))
 				try {
-					ais[a]-&gt;ai-&gt;EnemyEnterRadar(unit-&gt;id);
+					ais[a]-&gt;EnemyEnterRadar(unit-&gt;id);
 				} HANDLE_EXCEPTION;
 		}
 	}
@@ -175,7 +173,7 @@
 			if(ais[a] &amp;&amp; gs-&gt;AllyTeam(a)==allyteam &amp;&amp; !gs-&gt;Ally(allyteam,unit-&gt;allyteam))
 			{
 				try {
-					ais[a]-&gt;ai-&gt;EnemyLeaveRadar(unit-&gt;id);
+					ais[a]-&gt;EnemyLeaveRadar(unit-&gt;id);
 				} HANDLE_EXCEPTION;
 			}
 		}
@@ -186,7 +184,7 @@
 {
 	if(ais[unit-&gt;team])
 		try {
-			ais[unit-&gt;team]-&gt;ai-&gt;UnitIdle(unit-&gt;id);
+			ais[unit-&gt;team]-&gt;UnitIdle(unit-&gt;id);
 		} HANDLE_EXCEPTION;
 }
 
@@ -194,7 +192,7 @@
 {
 	if(ais[unit-&gt;team])
 		try {
-			ais[unit-&gt;team]-&gt;ai-&gt;UnitCreated(unit-&gt;id);
+			ais[unit-&gt;team]-&gt;UnitCreated(unit-&gt;id);
 		} 	HANDLE_EXCEPTION;
 }
 
@@ -202,7 +200,7 @@
 {
 	if(ais[unit-&gt;team])
 		try {
-			ais[unit-&gt;team]-&gt;ai-&gt;UnitFinished(unit-&gt;id);
+			ais[unit-&gt;team]-&gt;UnitFinished(unit-&gt;id);
 		} HANDLE_EXCEPTION;
 }
 
@@ -211,58 +209,18 @@
 	if(hasAI){
 		try {
 			for(int a=0;a&lt;gs-&gt;activeTeams;++a){
-				if(ais[a] &amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(a),unit-&gt;allyteam) &amp;&amp; (ais[a]-&gt;cheatevents || (unit-&gt;losStatus[a] &amp; (LOS_INLOS | LOS_INRADAR))))
-					ais[a]-&gt;ai-&gt;EnemyDestroyed(unit-&gt;id,attacker?attacker-&gt;id:0);
+				if(ais[a]
+						&amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(a),unit-&gt;allyteam)
+						&amp;&amp; (ais[a]-&gt;IsCheatEventsEnabled() || (unit-&gt;losStatus[a] &amp; (LOS_INLOS | LOS_INRADAR))))
+					ais[a]-&gt;EnemyDestroyed(unit-&gt;id, attacker ? attacker-&gt;id : 0);
 			}
 			if(ais[unit-&gt;team])
-				ais[unit-&gt;team]-&gt;ai-&gt;UnitDestroyed(unit-&gt;id,attacker?attacker-&gt;id:0);
+				ais[unit-&gt;team]-&gt;UnitDestroyed(unit-&gt;id,attacker?attacker-&gt;id:0);
 		} HANDLE_EXCEPTION;
 	}
 }
 
-bool CGlobalAIHandler::CreateGlobalAI(int teamID, const char* dll)
-{
-	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
-		return false;
-	}
-
-	if (net-&gt;localDemoPlayback) {
-		return false;
-	}
-
-	if (strncmp(dll, &quot;LuaAI:&quot;, 6) == 0) {
-		CTeam* team = gs-&gt;Team(teamID);
-		if (team != NULL) {
-			team-&gt;luaAI = (dll + 6);
-			return true;
-		}
-		return false;
-	}
-
-	try {
-		if (ais[teamID]) {
-			delete ais[teamID];
-			ais[teamID] = 0;
-		}
-
-		//TODO : This is the crossover to the new AI
-		//Eventually we should rewrite a less hacky AILibraryHandler
-		//and change all calls to the global ai to be appropriate.
-		//ais[teamID] = SAFE_NEW CGlobalAI(teamID, dll);
-		ais[teamID] = SAFE_NEW CAILibraryGlobalAI(dll, teamID);
-		
-		if (!ais[teamID]-&gt;ai) {
-			delete ais[teamID];
-			ais[teamID] = 0;
-			return false;
-		}
-
-		hasAI = true;
-		return true;
-	} HANDLE_EXCEPTION;
-	return false;
-}
-
+/*
 void* CGlobalAIHandler::GetAIBuffer(int team, std::string name, int length)
 {
 	if(memBuffers[team].find(name)!=memBuffers[team].end()){
@@ -288,8 +246,9 @@
 		}
 	}
 }
+*/
 
-void CGlobalAIHandler::GotChatMsg(const char* msg, int player)
+void CGlobalAIHandler::GotChatMsg(const char* msg, int fromPlayerId)
 {
 	if(hasAI){
 		for(int a=0;a&lt;gs-&gt;activeTeams;++a)
@@ -297,14 +256,14 @@
 			if(ais[a])
 			{
 				try {
-					ais[a]-&gt;ai-&gt;GotChatMsg(msg,player);
+					ais[a]-&gt;GotChatMsg(msg, fromPlayerId);
 				} HANDLE_EXCEPTION
 			}
 		}
 	}
 }
 
-void CGlobalAIHandler::UnitDamaged(CUnit* attacked,CUnit* attacker,float damage)
+void CGlobalAIHandler::UnitDamaged(CUnit* attacked, CUnit* attacker, float damage)
 {
 	if(hasAI){
 		try {
@@ -312,17 +271,17 @@
 				if(attacker){
 					float3 dir=helper-&gt;GetUnitErrorPos(attacker,attacked-&gt;allyteam)-attacked-&gt;pos;
 					dir.Normalize();
-					ais[attacked-&gt;team]-&gt;ai-&gt;UnitDamaged(attacked-&gt;id,attacker-&gt;id,damage,dir);
+					ais[attacked-&gt;team]-&gt;UnitDamaged(attacked-&gt;id,attacker-&gt;id,damage,dir);
 				} else {
-					ais[attacked-&gt;team]-&gt;ai-&gt;UnitDamaged(attacked-&gt;id,-1,damage,ZeroVector);
+					ais[attacked-&gt;team]-&gt;UnitDamaged(attacked-&gt;id,-1,damage,ZeroVector);
 				}
 
 			if(attacker) {
 				int a = attacker-&gt;team;
-				if(ais[attacker-&gt;team] &amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(a),attacked-&gt;allyteam) &amp;&amp; (ais[a]-&gt;cheatevents || (attacked-&gt;losStatus[a] &amp; (LOS_INLOS | LOS_INRADAR)))) {
+				if(ais[attacker-&gt;team] &amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(a),attacked-&gt;allyteam) &amp;&amp; (ais[a]-&gt;IsCheatEventsEnabled() || (attacked-&gt;losStatus[a] &amp; (LOS_INLOS | LOS_INRADAR)))) {
 					float3 dir=attacker-&gt;pos-helper-&gt;GetUnitErrorPos(attacked,attacker-&gt;allyteam);
 					dir.Normalize();
-					ais[a]-&gt;ai-&gt;EnemyDamaged(attacked-&gt;id,attacker-&gt;id,damage,dir);
+					ais[a]-&gt;EnemyDamaged(attacked-&gt;id,attacker-&gt;id,damage,dir);
 				}
 			}
 		} HANDLE_EXCEPTION;
@@ -333,12 +292,8 @@
 {
 	if(ais[unit-&gt;team]){
 		try {
-			IGlobalAI::WeaponFireEvent wfe;
-			wfe.unit = unit-&gt;id;
-			wfe.def = def;
-			ais[unit-&gt;team]-&gt;ai-&gt;HandleEvent(AI_EVENT_WEAPON_FIRED,&amp;wfe);
-		}
-		HANDLE_EXCEPTION;
+			ais[unit-&gt;team]-&gt;WeaponFired(unit-&gt;id, def-&gt;id);
+		} HANDLE_EXCEPTION;
 	}
 }
 
@@ -346,60 +301,118 @@
 {
 	if(ais[unit-&gt;team])
 		try {
-			ais[unit-&gt;team]-&gt;ai-&gt;UnitMoveFailed (unit-&gt;id);
+			ais[unit-&gt;team]-&gt;UnitMoveFailed(unit-&gt;id);
 		} HANDLE_EXCEPTION;
 }
 
-void CGlobalAIHandler::UnitGiven(CUnit *unit,int oldteam)
+void CGlobalAIHandler::UnitGiven(CUnit *unit, int oldTeam)
 {
 	if(ais[unit-&gt;team])
 		try {
-			IGlobalAI::ChangeTeamEvent cte;
-			cte.newteam = unit-&gt;team;
-			cte.oldteam = oldteam;
-			cte.unit = unit-&gt;id;
-			ais[unit-&gt;team]-&gt;ai-&gt;HandleEvent (AI_EVENT_UNITGIVEN, &amp;cte);
+			ais[unit-&gt;team]-&gt;UnitGiven(unit-&gt;id, oldTeam, unit-&gt;team);
 		} HANDLE_EXCEPTION;
 }
 
-void CGlobalAIHandler::UnitTaken (CUnit *unit,int newteam)
+void CGlobalAIHandler::UnitTaken(CUnit *unit, int newTeam)
 {
 	if(ais[unit-&gt;team])
 		try {
-			IGlobalAI::ChangeTeamEvent cte;
-			cte.newteam = newteam;
-			cte.oldteam = unit-&gt;team;
-			cte.unit = unit-&gt;id;
-			ais[unit-&gt;team]-&gt;ai-&gt;HandleEvent (AI_EVENT_UNITCAPTURED, &amp;cte);
-		}
-		HANDLE_EXCEPTION;
+			ais[unit-&gt;team]-&gt;UnitCaptured(unit-&gt;id, unit-&gt;team, newTeam);
+		} HANDLE_EXCEPTION;
 }
 
-void CGlobalAIHandler::PlayerCommandGiven(std::vector&lt;int&gt;&amp; selectedunits,Command&amp; c,int player)
+void CGlobalAIHandler::PlayerCommandGiven(std::vector&lt;int&gt;&amp; selectedunits, Command&amp; c, int playerId)
 {
-	if(ais[gs-&gt;players[player]-&gt;team]){
+	if(ais[gs-&gt;players[playerId]-&gt;team]){
 		try {
-			IGlobalAI::PlayerCommandEvent pce;
-			pce.units = selectedunits;
-			pce.player = player;
-			pce.command = c;
-			ais[gs-&gt;players[player]-&gt;team]-&gt;ai-&gt;HandleEvent(AI_EVENT_PLAYER_COMMAND,&amp;pce);
+			ais[gs-&gt;players[playerId]-&gt;team]-&gt;PlayerCommandGiven(selectedunits, c, playerId);
 		}
 		HANDLE_EXCEPTION;
 	}
 }
 
-void CGlobalAIHandler::SeismicPing(int allyteam, CUnit *unit, const float3 &amp;pos, float strength)
+void CGlobalAIHandler::SeismicPing(int allyTeam, CUnit* unit, const float3&amp; pos, float strength)
 {
 	if(hasAI){
 		for(int a=0;a&lt;gs-&gt;activeTeams;++a){
-			if(ais[a] &amp;&amp; gs-&gt;AllyTeam(a)==allyteam &amp;&amp; !gs-&gt;Ally(allyteam,unit-&gt;allyteam))
+			if(ais[a] &amp;&amp; gs-&gt;AllyTeam(a)==allyTeam &amp;&amp; !gs-&gt;Ally(allyTeam, unit-&gt;allyteam))
 				try {
-					IGlobalAI::SeismicPingEvent spe;
-					spe.pos = pos;
-					spe.strength = strength;
-					ais[a]-&gt;ai-&gt;HandleEvent(AI_EVENT_SEISMIC_PING,&amp;spe);
+					ais[a]-&gt;SeismicPing(allyTeam, unit-&gt;id, pos, strength);
 				} HANDLE_EXCEPTION;
 		}
 	}
 }
+
+
+
+
+
+bool CGlobalAIHandler::CreateSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey)
+{
+	if ((teamId &lt; 0) || (teamId &gt;= gs-&gt;activeTeams)) {
+		return false;
+	}
+
+	if (net-&gt;localDemoPlayback) {
+		return false;
+	}
+
+	//TODO: make this work again
+/*
+	if (strncmp(dll, &quot;LuaAI:&quot;, 6) == 0) {
+		CTeam* team = gs-&gt;Team(teamId);
+		if (team != NULL) {
+			team-&gt;luaAI = (dll + 6);
+			return true;
+		}
+		return false;
+	}
+*/
+
+	try {
+		if (ais[teamId]) {
+			delete ais[teamId];
+			ais[teamId] = 0;
+		}
+
+		//TODO : This is the crossover to the new AI
+		//Eventually we should rewrite a less hacky AILibraryHandler
+		//and change all calls to the global ai to be appropriate.
+		//ais[teamId] = SAFE_NEW CGlobalAI(teamId, dll);
+		//ais[teamId] = SAFE_NEW CAILibraryGlobalAI(dll, teamId);
+/*
+		const ISkirmishAILibrary* skirmishAILibrary = IAILibraryManager::GetInstance()-&gt;FetchSkirmishAILibrary(skirmishAIKey);
+		skirmishAIs[teamId] = SAFE_NEW CSkirmishAI(teamId, skirmishAILibrary);
+*/
+		ais[teamId] = SAFE_NEW CSkirmishAIWrapper(teamId, skirmishAIKey);
+		
+/*
+		if (!ais[teamId]-&gt;ai) {
+			delete ais[teamId];
+			ais[teamId] = 0;
+			return false;
+		}
+*/
+
+		hasAI = true;
+		return true;
+	} HANDLE_EXCEPTION;
+	return false;
+}
+
+bool CGlobalAIHandler::IsSkirmishAI(int teamId) {
+	return ais[teamId] != 0;
+}
+
+void CGlobalAIHandler::DestroySkirmishAI(int teamId) {
+	
+	try {
+		delete ais[teamId];
+		ais[teamId] = 0;
+	} HANDLE_EXCEPTION;
+}
+
+const CSkirmishAIWrapper* CGlobalAIHandler::GetSkirmishAI(int teamId) {
+	return ais[teamId];
+}
+

Modified: branches/caiinterface/rts/ExternalAI/GlobalAIHandler.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAIHandler.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/GlobalAIHandler.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,6 +1,8 @@
 #ifndef GLOBALAIHANDLER_H
 #define GLOBALAIHANDLER_H
 
+#include &quot;IAILibraryManager.h&quot;
+#include &quot;ISkirmishAI.h&quot;
 #include &quot;Object.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &lt;map&gt;
@@ -8,6 +10,7 @@
 
 class CUnit;
 class CGlobalAI;
+class CSkirmishAIWrapper;
 struct WeaponDef;
 struct Command;
 
@@ -19,45 +22,49 @@
 //	CR_DECLARE_SUB(AIMemBuffer);
 	static bool CatchException();
 
-	CGlobalAIHandler(void);
-	~CGlobalAIHandler(void);
+	CGlobalAIHandler();
+	~CGlobalAIHandler();
+
 	void PostLoad();
+	void PreDestroy();
 
-	void Update(void);
-	void PreDestroy ();
-
-	void UnitEnteredLos(CUnit* unit,int allyteam);
-	void UnitLeftLos(CUnit* unit,int allyteam);
-	void UnitEnteredRadar(CUnit* unit,int allyteam);
-	void UnitLeftRadar(CUnit* unit,int allyteam);
+	void Update();
+	void UnitEnteredLos(CUnit* unit, int allyTeam);
+	void UnitLeftLos(CUnit* unit, int allyTeam);
+	void UnitEnteredRadar(CUnit* unit, int allyTeam);
+	void UnitLeftRadar(CUnit* unit, int allyTeam);
 	void SeismicPing(int allyteam, CUnit *unit, const float3 &amp;pos, float strength);
-
 	void UnitIdle(CUnit* unit);
 	void UnitCreated(CUnit* unit);
 	void UnitFinished(CUnit* unit);
 	void UnitDestroyed(CUnit* unit, CUnit *attacker);
-	void UnitDamaged(CUnit* attacked,CUnit* attacker,float damage);
+	void UnitDamaged(CUnit* attacked, CUnit* attacker, float damage);
 	void UnitMoveFailed(CUnit* unit);
-	void UnitTaken(CUnit* unit, int newteam);
-	void UnitGiven(CUnit* unit, int oldteam);
+	void UnitTaken(CUnit* unit, int newTeam);
+	void UnitGiven(CUnit* unit, int oldTeam);
 	void WeaponFired(CUnit* unit, const WeaponDef* def);
 	void PlayerCommandGiven(std::vector&lt;int&gt;&amp; selectedunits,Command&amp; c,int player);
 	void Load(std::istream *s);
 	void Save(std::ostream *s);
-	CGlobalAI* ais[MAX_TEAMS];
+	void GotChatMsg(const char* msg, int player);
+//	void* GetAIBuffer(int teamId, std::string name, int length);
+//	void ReleaseAIBuffer(int teamId, std::string name);
+
+	bool CreateSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey);
+	bool IsSkirmishAI(int teamId);
+	void DestroySkirmishAI(int teamId);
+	const CSkirmishAIWrapper* GetSkirmishAI(int teamId);
+	
+private:
+	CSkirmishAIWrapper* ais[MAX_TEAMS];
 	bool hasAI;
-
-	struct AIMemBuffer{
-//		CR_DECLARE_STRUCT(AIMemBuffer);
-		char* mem;
-		int usage;
-	};
-	std::map&lt;std::string,AIMemBuffer&gt; memBuffers[MAX_TEAMS];
-
-	bool CreateGlobalAI(int team, const char* dll);
-	void* GetAIBuffer(int team, std::string name, int length);
-	void ReleaseAIBuffer(int team, std::string name);
-	void GotChatMsg(const char* msg, int player);
+	
+//	struct AIMemBuffer{
+////		CR_DECLARE_STRUCT(AIMemBuffer);
+//		char* mem;
+//		int usage;
+//	};
+//	std::map&lt;std::string,AIMemBuffer&gt; memBuffers[MAX_TEAMS];
 };
 
 extern CGlobalAIHandler* globalAI;

Deleted: branches/caiinterface/rts/ExternalAI/Group.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Group.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/Group.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,348 +0,0 @@
-// Group.cpp: implementation of the CGroup class.
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &quot;StdAfx.h&quot;
-#include &quot;Group.h&quot;
-#include &quot;IGroupAI.h&quot;
-#include &quot;GroupAiCallback.h&quot;
-#include &quot;GroupHandler.h&quot;
-#include &quot;Game/SelectedUnits.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;System/EventHandler.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &quot;Platform/errorhandler.h&quot;
-#include &quot;mmgr.h&quot;
-#include &quot;creg/STL_List.h&quot;
-
-AIKey defaultKey(std::string(&quot;default&quot;),0);
-
-CR_BIND_DERIVED(CGroup,CObject,(defaultKey,0,NULL))
-
-CR_REG_METADATA(CGroup, (
-				CR_MEMBER(id),
-				CR_MEMBER(units),
-				CR_MEMBER(myCommands),
-				CR_MEMBER(lastCommandPage),
-				CR_MEMBER(currentAiNum),
-				CR_MEMBER(currentAiKey),
-				CR_MEMBER(handler),
-				CR_SERIALIZER(Serialize),
-				CR_POSTLOAD(PostLoad)
-				));
-
-CR_BIND(AIKey,)
-
-CR_REG_METADATA(AIKey, (
-				CR_MEMBER(dllName),
-				CR_MEMBER(aiNumber)
-				));
-
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
-
-CGroup::CGroup(AIKey aiKey,int id,CGroupHandler* grouphandler)
-: lastCommandPage(0),
-	id(id),
-	ai(0),
-	currentAiNum(0),
-	handler(grouphandler),
-	lib(0)
-{
-	if (grouphandler) callback=SAFE_NEW CGroupAICallback(this); else callback=0;
-	SetNewAI(aiKey);
-
-	int a=0;
-	if (grouphandler) for(map&lt;AIKey,string&gt;::iterator aai=handler-&gt;lastSuitedAis.begin();aai!=handler-&gt;lastSuitedAis.end() &amp;&amp; aiKey!=aai-&gt;first;++aai){
-		a++;
-	}
-	currentAiNum=a;
-}
-
-CGroup::~CGroup()
-{
-	ClearUnits();			//shouldnt have any units left but just to be sure
-	if(ai)
-		ReleaseAI(currentAiKey.aiNumber,ai);
-	if(lib)
-		delete lib;
-	delete callback;
-}
-
-void CGroup::Serialize(creg::ISerializer *s)
-{
-}
-
-void CGroup::PostLoad()
-{
-	callback=SAFE_NEW CGroupAICallback(this);
-	int a=0;
-	for(map&lt;AIKey,string&gt;::iterator aai=handler-&gt;lastSuitedAis.begin();aai!=handler-&gt;lastSuitedAis.end() &amp;&amp; currentAiKey!=aai-&gt;first;++aai){
-		a++;
-	}
-	currentAiNum=a;
-/*
-	if(ai) {
-		ReleaseAI(currentAiKey.aiNumber,ai);
-		ai = 0;
-	}
-*/
-	if(lib) {
-		delete lib;
-		lib = 0;
-	}
-
-	if(currentAiKey.dllName==&quot;default&quot;){
-		return;
-	}
-
-	lib = SharedLib::Instantiate(currentAiKey.dllName);
-	if (lib==0)
-		handleerror(NULL,currentAiKey.dllName.c_str(),&quot;Could not find AI dll&quot;,MBF_OK|MBF_EXCL);
-
-	GetGroupAiVersion = (GETGROUPAIVERSION)lib-&gt;FindAddress(&quot;GetGroupAiVersion&quot;);
-	if (GetGroupAiVersion==0)
-		handleerror(NULL,currentAiKey.dllName.c_str(),&quot;Incorrect AI dll&quot;,MBF_OK|MBF_EXCL);
-
-	int i=GetGroupAiVersion();
-
-	if (i!=AI_INTERFACE_VERSION)
-		handleerror(NULL,currentAiKey.dllName.c_str(),&quot;Incorrect AI dll version&quot;,MBF_OK|MBF_EXCL);
-
-	GetNewAI = (GETNEWAI)lib-&gt;FindAddress(&quot;GetNewAI&quot;);
-	ReleaseAI = (RELEASEAI)lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
-	IsUnitSuited = (ISUNITSUITED)lib-&gt;FindAddress(&quot;IsUnitSuited&quot;);
-
-	typedef bool (* ISLOADSUPPORTED)(unsigned aiNumber);
-	ISLOADSUPPORTED IsLoadSupported;
-	IsLoadSupported = (ISLOADSUPPORTED)lib-&gt;FindAddress(&quot;IsLoadSupported&quot;);
-
-	ai=GetNewAI(currentAiKey.aiNumber);
-	if (IsLoadSupported&amp;&amp;IsLoadSupported(currentAiKey.aiNumber)) {
-		return;
-	}
-	ai-&gt;InitAi(callback);
-
-	CUnitSet unitBackup=units;
-
-	for(CUnitSet::iterator ui=unitBackup.begin();ui!=unitBackup.end();++ui)
-	{
-		if(IsUnitSuited(currentAiKey.aiNumber,(*ui)-&gt;unitDef))
-		{
-			if(ai-&gt;AddUnit((*ui)-&gt;id))
-			{
-				continue;
-			}
-		}
-		units.erase(*ui);
-		(*ui)-&gt;group=0;
-	}
-}
-
-bool CGroup::AddUnit(CUnit *unit)
-{
-	eventHandler.GroupChanged(id);
-
-	units.insert(unit);
-	if(ai)
-	{
-		if(IsUnitSuited(currentAiKey.aiNumber,unit-&gt;unitDef))
-		{
-			if(ai-&gt;AddUnit(unit-&gt;id))
-			{
-				return true;
-			}
-		}
-		units.erase(unit);
-		return false;
-	}
-	return true;
-}
-
-void CGroup::RemoveUnit(CUnit *unit)
-{
-	eventHandler.GroupChanged(id);
-	if(ai)
-		ai-&gt;RemoveUnit(unit-&gt;id);
-	units.erase(unit);
-}
-
-void CGroup::SetNewAI(AIKey aiKey)
-{
-	eventHandler.GroupChanged(id);
-	if(ai) {
-		ReleaseAI(currentAiKey.aiNumber,ai);
-		ai = 0;
-	}
-	if(lib) {
-		delete lib;
-		lib = 0;
-	}
-
-	currentAiKey=aiKey;
-	if(aiKey.dllName==&quot;default&quot;){
-		return;
-	}
-
-	lib = SharedLib::Instantiate(aiKey.dllName);
-	if (lib==0)
-		handleerror(NULL,aiKey.dllName.c_str(),&quot;Could not find AI dll&quot;,MBF_OK|MBF_EXCL);
-
-	GetGroupAiVersion = (GETGROUPAIVERSION)lib-&gt;FindAddress(&quot;GetGroupAiVersion&quot;);
-	if (GetGroupAiVersion==0)
-		handleerror(NULL,aiKey.dllName.c_str(),&quot;Incorrect AI dll&quot;,MBF_OK|MBF_EXCL);
-
-	int i=GetGroupAiVersion();
-
-	if (i!=AI_INTERFACE_VERSION)
-		handleerror(NULL,aiKey.dllName.c_str(),&quot;Incorrect AI dll version&quot;,MBF_OK|MBF_EXCL);
-
-	GetNewAI = (GETNEWAI)lib-&gt;FindAddress(&quot;GetNewAI&quot;);
-	ReleaseAI = (RELEASEAI)lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
-	IsUnitSuited = (ISUNITSUITED)lib-&gt;FindAddress(&quot;IsUnitSuited&quot;);
-
-	ai=GetNewAI(currentAiKey.aiNumber);
-	ai-&gt;InitAi(callback);
-
-	CUnitSet unitBackup=units;
-
-	for(CUnitSet::iterator ui=unitBackup.begin();ui!=unitBackup.end();++ui)
-	{
-		if(IsUnitSuited(currentAiKey.aiNumber,(*ui)-&gt;unitDef))
-		{
-			if(ai-&gt;AddUnit((*ui)-&gt;id))
-			{
-				continue;
-			}
-		}
-		units.erase(*ui);
-		(*ui)-&gt;group=0;
-	}
-}
-
-void CGroup::Update()
-{
-	if(units.empty() &amp;&amp; id&gt;=10 &amp;&amp; /*handler==grouphandler*/handler-&gt;team==gu-&gt;myTeam){		//last check is a hack so globalai groups dont get erased
-		handler-&gt;RemoveGroup(this);
-		return;
-	}
-	if(ai)
-		ai-&gt;Update();
-}
-
-void CGroup::DrawCommands()
-{
-	if(units.empty() &amp;&amp; id&gt;=10 &amp;&amp; /*handler==grouphandler*/handler-&gt;team==gu-&gt;myTeam){		//last check is a hack so globalai groups dont get erased
-		handler-&gt;RemoveGroup(this);
-		return;
-	}
-	if(ai)
-		ai-&gt;DrawCommands();
-}
-
-const vector&lt;CommandDescription&gt;&amp; CGroup::GetPossibleCommands()
-{
-	CommandDescription c;
-
-	myCommands.clear();
-
-	if(ai){
-		/*
-		We deepcopy the vector member-by-member, because relying on copy
-		constructors, as in 'myCommands=ai-&gt;GetPossibleCommands();', would mean
-		marshalling of container objects (std::string particularly) over DLL
-		boundaries.
-
-		On MinGW (at least) this caused a crash when clearing the last Group AI:
-		When the code here was executed, the std::string implementation did not
-		copy the strings, but it incremented a reference counter and stored
-		a pointer to the data in the DLL. When the last group AI was cleared
-		the DLL was unloaded from memory.
-		Then, after CGroup::~CGroup() execution finished, the myCommands destructor
-		would be called, which would call all the std::string destructors, which
-		would try to decrement a reference counter in inaccesible (DLL) memory -&gt;
-		segfault
-		*/
-		const vector&lt;CommandDescription&gt;&amp; aipc=ai-&gt;GetPossibleCommands();
-		for (vector&lt;CommandDescription&gt;::const_iterator i = aipc.begin(); i != aipc.end(); ++i) {
-			c.id   = i-&gt;id;
-			c.type = i-&gt;type;
-			c.action    = i-&gt;action.c_str();
-			c.name      = i-&gt;name.c_str();
-			c.iconname  = i-&gt;iconname.c_str();
-			c.mouseicon = i-&gt;mouseicon.c_str();
-			c.tooltip   = i-&gt;tooltip.c_str();
-			c.showUnique  = i-&gt;showUnique;
-			c.hidden      = i-&gt;hidden;
-			c.disabled    = i-&gt;disabled;
-			c.onlyTexture = i-&gt;onlyTexture;
-			for (vector&lt;string&gt;::const_iterator j = i-&gt;params.begin(); j != i-&gt;params.end(); ++j) {
-				c.params.push_back(j-&gt;c_str());
-			}
-			myCommands.push_back(c);
-			c.params.clear();
-		}
-	}
-
-	c.id=CMD_AISELECT;
-	c.type=CMDTYPE_COMBO_BOX;
-	c.name=&quot;Select AI&quot;;
-	c.tooltip=&quot;Select the AI to use for this group from the available AIs&quot;;
-	c.showUnique=true;
-
-	char t[50];
-	sprintf(t,&quot;%i&quot;,currentAiNum+1);
-	c.params.push_back(t);
-	c.params.push_back(&quot;Cancel&quot;);
-	map&lt;AIKey,string&gt;::iterator aai;
-	map&lt;AIKey,string&gt; suitedAis = handler-&gt;GetSuitedAis(units);
-	for(aai=suitedAis.begin();aai!=suitedAis.end();++aai){
-		c.params.push_back((aai-&gt;second).c_str());
-	}
-	myCommands.push_back(c);
-	return myCommands;
-}
-
-int CGroup::GetDefaultCmd(CUnit *unit,CFeature* feature)
-{
-	if(!ai)
-		return CMD_STOP;
-
-	if(unit==0)
-		return ai-&gt;GetDefaultCmd(0);
-	return ai-&gt;GetDefaultCmd(unit-&gt;id);
-}
-
-void CGroup::GiveCommand(Command c)
-{
-	if(c.id==CMD_AISELECT){
-		if (c.params[0]!=0) {
-			map&lt;AIKey,string&gt;::iterator aai;
-			int a=0;
-			for(aai=handler-&gt;lastSuitedAis.begin();aai!=handler-&gt;lastSuitedAis.end() &amp;&amp; a&lt;c.params[0]-1;++aai){
-				a++;
-			}
-			currentAiNum=a;
-			SetNewAI(aai-&gt;first);
-			selectedUnits.PossibleCommandChange(0);
-		}
-	} else {
-		if(ai)
-			ai-&gt;GiveCommand(&amp;c);
-	}
-}
-
-void CGroup::CommandFinished(int unit,int type)
-{
-	if(ai)
-		ai-&gt;CommandFinished(unit,type);
-}
-
-void CGroup::ClearUnits(void)
-{
-	eventHandler.GroupChanged(id);
-	while(!units.empty()){
-		(*units.begin())-&gt;SetGroup(0);
-	}
-}

Deleted: branches/caiinterface/rts/ExternalAI/Group.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Group.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/Group.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,67 +0,0 @@
-#ifndef GROUP_H
-#define GROUP_H
-// Group.h: interface for the CGroup class.
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &quot;Object.h&quot;
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &quot;Sim/Units/CommandAI/Command.h&quot;
-#include &quot;Platform/SharedLib.h&quot;
-#include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;Sim/Units/UnitSet.h&quot;
-#include &quot;ExternalAI/aikey.h&quot;
-class IGroupAI;
-class CUnit;
-class CFeature;
-class CGroupAICallback;
-class CGroupHandler;
-
-class CGroup : public CObject
-{
-public:
-	CR_DECLARE(CGroup);
-	void CommandFinished(int unit,int type);
-	CGroup(AIKey aiKey,int id,CGroupHandler* grouphandler);
-	virtual ~CGroup();
-	void Serialize(creg::ISerializer *s);
-	void PostLoad();
-
-	void Update();
-	void DrawCommands();
-	void SetNewAI(AIKey aiKey);
-
-	void RemoveUnit(CUnit* unit);	//call setgroup(0) instead of calling this directly
-	bool AddUnit(CUnit* unit);		//dont call this directly call unit.SetGroup and let that call this
-	const vector&lt;CommandDescription&gt;&amp; GetPossibleCommands();
-	int GetDefaultCmd(CUnit* unit,CFeature* feature);
-	void GiveCommand(Command c);
-	void ClearUnits(void);
-
-	int id;
-
-	CUnitSet units;
-
-	vector&lt;CommandDescription&gt; myCommands;
-	SharedLib *lib;
-	typedef int (* GETGROUPAIVERSION)();
-	typedef IGroupAI* (* GETNEWAI)(unsigned aiNumber);
-	typedef void (* RELEASEAI)(unsigned aiNumber,IGroupAI* i);
-	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
-
-	GETGROUPAIVERSION GetGroupAiVersion;
-	GETNEWAI GetNewAI;
-	RELEASEAI ReleaseAI;
-	ISUNITSUITED IsUnitSuited;
-	int lastCommandPage;
-	int currentAiNum;
-	AIKey currentAiKey;
-
-	IGroupAI* ai;
-	CGroupAICallback* callback;
-
-	CGroupHandler* handler;
-};
-
-#endif /* GROUP_H */

Added: branches/caiinterface/rts/ExternalAI/GroupAILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,95 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;GroupAILibrary.h&quot;
+
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &lt;string&gt;
+
+CGroupAILibrary::CGroupAILibrary(const SGAILibrary&amp; ai) {
+	
+	sGAI = ai;
+	
+	std::map&lt;std::string, InfoItem&gt; infos = GetInfos();
+	specifyer.shortName = infos.at(GROUP_AI_PROPERTY_SHORT_NAME).value;
+	specifyer.version = infos.at(GROUP_AI_PROPERTY_VERSION).value;
+}
+
+CGroupAILibrary::~CGroupAILibrary() {}
+	
+SGAISpecifyer CGroupAILibrary::GetSpecifyer() const {
+	return specifyer;
+}
+
+LevelOfSupport CGroupAILibrary::GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber,
+		const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) const {
+	
+	if (sGAI.getLevelOfSupportFor != NULL) {
+		return sGAI.getLevelOfSupportFor(engineVersionString.c_str(), engineVersionNumber,
+			interfaceSpecifyer.shortName, interfaceSpecifyer.version);
+	} else {
+		return LOS_Unknown;
+	}
+}
+	
+std::map&lt;std::string, InfoItem&gt; CGroupAILibrary::GetInfos() const {
+	
+	std::map&lt;std::string, InfoItem&gt; infos;
+	
+	if (sGAI.getInfos != NULL) {
+		InfoItem infs[MAX_INFOS];
+		int num = sGAI.getInfos(infs, MAX_INFOS);
+
+		int i;
+		for (i=0; i &lt; num; ++i) {
+			InfoItem newII = copyInfoItem(&amp;infs[i]);
+			infos[std::string(newII.key)] = newII;
+		}
+	}
+
+	return infos;
+}
+std::vector&lt;Option&gt; CGroupAILibrary::GetOptions() const {
+	
+	std::vector&lt;Option&gt; ops;
+	
+	if (sGAI.getOptions != NULL) {
+		Option options[MAX_OPTIONS];
+		int num = sGAI.getOptions(options, MAX_OPTIONS);
+
+		int i;
+		for (i=0; i &lt; num; ++i) {
+			ops.push_back(options[i]);
+		}
+	}
+
+	return ops;
+}
+
+
+void CGroupAILibrary::Init(int teamId, int groupId) const {
+	sGAI.init(teamId, groupId);
+}
+
+void CGroupAILibrary::Release(int teamId, int groupId) const {
+	sGAI.release(teamId, groupId);
+}
+
+int CGroupAILibrary::HandleEvent(int teamId, int groupId, int topic, const void* data) const {
+	return sGAI.handleEvent(teamId, groupId, topic, data);
+}


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAILibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/GroupAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,60 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _GROUPAILIBRARY_H
+#define	_GROUPAILIBRARY_H
+
+
+#include &quot;IGroupAILibrary.h&quot;
+
+#include &quot;Interface/SGAILibrary.h&quot;
+
+class CGroupAILibrary : public IGroupAILibrary {
+public:
+	CGroupAILibrary(const SGAILibrary&amp; ai);
+	virtual ~CGroupAILibrary();
+	
+	virtual SGAISpecifyer GetSpecifyer() const;
+	/**
+	 * Level of Support for a specific engine version and ai interface.
+	 * @return see enum LevelOfSupport (higher values could be used optionally)
+	 */
+	virtual LevelOfSupport GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber,
+			const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) const;
+	
+    virtual std::map&lt;std::string, InfoItem&gt; GetInfos() const;
+	virtual std::vector&lt;Option&gt; GetOptions() const;
+	
+	
+    virtual void Init(int teamId, int groupId) const;
+    virtual void Release(int teamId, int groupId) const;
+    virtual int HandleEvent(int teamId, int groupId, int topic, const void* data) const;
+	
+private:
+	SGAILibrary sGAI;
+	SGAISpecifyer specifyer;
+	
+private:
+//	void reportInterfaceFunctionError(const std::string* libFileName, const std::string* functionName);
+	
+	static const int MAX_INFOS = 128;
+	static const int MAX_OPTIONS = 128;
+};
+
+#endif	/* _GROUPAILIBRARY_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAILibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,142 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;GroupAILibraryInfo.h&quot;
+
+#include &quot;Interface/aidefines.h&quot;
+#include &quot;Interface/SGAILibrary.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;IGroupAILibrary.h&quot;
+
+#include &quot;Platform/errorhandler.h&quot;
+
+CGroupAILibraryInfo::CGroupAILibraryInfo(const IGroupAILibrary&amp; ai, const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) {
+	infos = ai.GetInfos();
+	options = ai.GetOptions();
+	//levelOfSupport = ai.GetLevelOfSupportFor(std::string(ENGINE_VERSION_STRING),
+	//		ENGINE_VERSION_NUMBER, interfaceSpecifyer);
+}
+
+CGroupAILibraryInfo::CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo) {
+	infos = std::map&lt;std::string, InfoItem&gt;(
+			aiInfo.infos.begin(),
+			aiInfo.infos.end());
+	options = std::vector&lt;Option&gt;(
+			aiInfo.options.begin(),
+			aiInfo.options.end());
+	//levelOfSupport = aiInfo.levelOfSupport;
+}
+
+CGroupAILibraryInfo::CGroupAILibraryInfo(
+		const std::string&amp; aiInfoFile,
+		const std::string&amp; aiOptionFile,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes) {
+	
+	InfoItem tmpInfos[MAX_INFOS];
+	unsigned int num = ParseInfos(aiInfoFile.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfos, MAX_INFOS);
+    for (unsigned int i=0; i &lt; num; ++i) {
+		infos[std::string(tmpInfos[i].key)] = tmpInfos[i];
+    }
+	
+	if (!aiOptionFile.empty()) {
+		Option tmpOptions[MAX_OPTIONS];
+		num = ParseOptions(aiOptionFile.c_str(), fileModes.c_str(), accessModes.c_str(), &quot;&quot;, tmpOptions, MAX_OPTIONS);
+		for (unsigned int i=0; i &lt; num; ++i) {
+			options.push_back(tmpOptions[i]);
+		}
+	}
+}
+
+/*
+LevelOfSupport CGroupAILibraryInfo::GetLevelOfSupportForCurrentEngine() const {
+	return levelOfSupport;
+}
+*/
+	
+std::string CGroupAILibraryInfo::GetShortName() const { // restrictions: none of the following: spaces, '_', '#'
+	return GetInfo(GROUP_AI_PROPERTY_SHORT_NAME);
+}
+std::string CGroupAILibraryInfo::GetVersion() const { // restrictions: none of the following: spaces, '_', '#'
+	return GetInfo(GROUP_AI_PROPERTY_VERSION);
+}
+std::string CGroupAILibraryInfo::GetName() const {
+	return GetInfo(GROUP_AI_PROPERTY_NAME);
+}
+std::string CGroupAILibraryInfo::GetDescription() const {
+	return GetInfo(GROUP_AI_PROPERTY_DESCRIPTION);
+}
+std::string CGroupAILibraryInfo::GetURL() const {
+	return GetInfo(GROUP_AI_PROPERTY_URL);
+}
+std::string CGroupAILibraryInfo::GetInterfaceShortName() const {
+	return GetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME);
+}
+std::string CGroupAILibraryInfo::GetInterfaceVersion() const {
+	return GetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION);
+}
+std::string CGroupAILibraryInfo::GetInfo(const std::string&amp; key) const {
+	return infos.at(key).value;
+}
+const std::map&lt;std::string, InfoItem&gt;* CGroupAILibraryInfo::GetInfos() const {
+	return &infos;
+}
+
+const std::vector&lt;Option&gt;* CGroupAILibraryInfo::GetOptions() const {
+	return &options;
+}
+
+
+void CGroupAILibraryInfo::SetShortName(const std::string&amp; shortName) { // restrictions: none of the following: spaces, '_', '#'
+	SetInfo(GROUP_AI_PROPERTY_SHORT_NAME, shortName);
+}
+void CGroupAILibraryInfo::SetVersion(const std::string&amp; version) { // restrictions: none of the following: spaces, '_', '#'
+	SetInfo(GROUP_AI_PROPERTY_VERSION, version);
+}
+void CGroupAILibraryInfo::SetName(const std::string&amp; name) {
+	SetInfo(GROUP_AI_PROPERTY_NAME, name);
+}
+void CGroupAILibraryInfo::SetDescription(const std::string&amp; description) {
+	SetInfo(GROUP_AI_PROPERTY_DESCRIPTION, description);
+}
+void CGroupAILibraryInfo::SetURL(const std::string&amp; url) {
+	SetInfo(GROUP_AI_PROPERTY_URL, url);
+}
+void CGroupAILibraryInfo::SetInterfaceShortName(const std::string&amp; interfaceShortName) {
+	SetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME, interfaceShortName);
+}
+void CGroupAILibraryInfo::SetInterfaceVersion(const std::string&amp; interfaceVersion) {
+	SetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION, interfaceVersion);
+}
+bool CGroupAILibraryInfo::SetInfo(const std::string&amp; key, const std::string&amp; value) {
+	
+	if (key == GROUP_AI_PROPERTY_SHORT_NAME ||
+			key == GROUP_AI_PROPERTY_VERSION) {
+		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
+			handleerror(NULL, &quot;Error&quot;, &quot;Group AI info (shortName or version) contains illegal characters ('_', '#' or white spaces)&quot;, MBF_OK | MBF_EXCL);
+			return false;
+		}
+	}
+	
+	InfoItem ii = {key.c_str(), value.c_str(), NULL};
+	infos[key] = ii;
+	return true;
+}
+
+void CGroupAILibraryInfo::SetOptions(const std::vector&lt;Option&gt;&amp; _options) {
+	options = std::vector&lt;Option&gt;(_options.begin(), _options.end()); // implicit convertible types -&gt; range-ctor can be used
+}


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,77 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _GROUPAILIBRARYINFO_H
+#define	_GROUPAILIBRARYINFO_H
+
+
+#include &quot;Interface/ELevelOfSupport.h&quot;
+
+#include &lt;vector&gt;
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class IGroupAILibrary;
+struct InfoItem;
+struct Option;
+struct SAIInterfaceSpecifyer;
+
+class CGroupAILibraryInfo {
+public:
+	CGroupAILibraryInfo(const IGroupAILibrary&amp; ai, const SAIInterfaceSpecifyer&amp; interfaceSpecifyer);
+	CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo);
+	CGroupAILibraryInfo(
+			const std::string&amp; aiInfoFile,
+			const std::string&amp; aiOptionFile,
+			const std::string&amp; fileModes,
+			const std::string&amp; accessModes);
+    
+    //virtual LevelOfSupport GetLevelOfSupportForCurrentEngine() const;
+	
+    virtual std::string GetShortName() const; // restrictions: none of the following: spaces, '_', '#'
+    virtual std::string GetName() const;
+    virtual std::string GetVersion() const; // restrictions: none of the following: spaces, '_', '#'
+    virtual std::string GetDescription() const;
+    virtual std::string GetURL() const;
+    virtual std::string GetInterfaceShortName() const;
+    virtual std::string GetInterfaceVersion() const;
+    virtual std::string GetInfo(const std::string&amp; key) const;
+    virtual const std::map&lt;std::string, InfoItem&gt;* GetInfos() const;
+	
+	virtual const std::vector&lt;Option&gt;* GetOptions() const;
+	
+    virtual void SetShortName(const std::string&amp; shortName); // restrictions: none of the following: spaces, '_', '#'
+    virtual void SetName(const std::string&amp; name);
+    virtual void SetVersion(const std::string&amp; version); // restrictions: none of the following: spaces, '_', '#'
+    virtual void SetDescription(const std::string&amp; description);
+    virtual void SetURL(const std::string&amp; url);
+    virtual void SetInterfaceShortName(const std::string&amp; interfaceShortName);
+    virtual void SetInterfaceVersion(const std::string&amp; interfaceVersion);
+    virtual bool SetInfo(const std::string&amp; key, const std::string&amp; value);
+	
+	virtual void SetOptions(const std::vector&lt;Option&gt;&amp; options);
+	
+private:
+	static const unsigned int MAX_INFOS = 128;
+	static const unsigned int MAX_OPTIONS = 128;
+	std::map&lt;std::string, InfoItem&gt; infos;
+	std::vector&lt;Option&gt; options;
+	//LevelOfSupport levelOfSupport;
+};
+
+#endif	/* _GROUPAILIBRARYINFO_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/IAIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/IAIInterfaceLibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/IAIInterfaceLibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,100 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _IAIINTERFACELIBRARY_H
+#define	_IAIINTERFACELIBRARY_H
+
+#include &quot;ISkirmishAILibrary.h&quot;
+#include &quot;IGroupAILibrary.h&quot;
+
+class IAIInterfaceLibrary {
+public:
+	virtual ~IAIInterfaceLibrary() {}
+	
+	virtual SAIInterfaceSpecifyer GetSpecifyer() const = 0;
+	virtual LevelOfSupport GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber) const = 0;
+	
+//    virtual std::string GetProperty(const std::string&amp; propertyName) const = 0;
+    virtual std::map&lt;std::string, InfoItem&gt; GetInfos() const = 0;
+	
+	/**
+	 * @brief	how many times is this interface loaded
+	 * Thought the AI library may be loaded only once, it can be logically
+	 * loaded multiple times.
+	 * Example: If we load one RAI and two AAIs over this interface,
+	 * the interface load counter will be three.
+	 */
+	virtual int GetLoadCount() const = 0;
+	
+	
+	
+//	virtual std::vector&lt;ISkirmishAILibraryInfo*&gt; GetSkirmishAILibraryInfos(bool forceLoadFromLibrary = false) const;
+	/**
+	 * Returns the specifyers for all Skirmish AIs available through this interface.
+	 */
+	virtual std::vector&lt;SSAISpecifyer&gt; GetSkirmishAILibrarySpecifyers() const = 0;
+	/**
+	 * @brief	loads the AI library
+	 * This only loads the AI library, and does not yet create an instance
+	 * for a team.
+	 * For the C and C++ AI interface eg, this will load a shared library.
+	 * Increments the load counter.
+	 */
+	virtual const ISkirmishAILibrary* FetchSkirmishAILibrary(const SSAISpecifyer&amp; sAISpecifyer) = 0;
+	/**
+	 * @brief	unloads the Skirmish AI library
+	 * This unloads the Skirmish AI library.
+	 * For the C and C++ AI interface eg, this will unload a shared library.
+	 * This should not be done when any instances
+	 * of that AI are still in use, as it will result in a crash.
+	 * Decrements the load counter.
+	 */
+	virtual int ReleaseSkirmishAILibrary(const SSAISpecifyer&amp; sAISpecifyer) = 0;
+	/**
+	 * @brief	is the Skirmish AI library loaded
+	 */
+	bool IsSkirmishAILibraryLoaded(const SSAISpecifyer&amp; sAISpecifyer) const {
+		return GetSkirmishAILibraryLoadCount(sAISpecifyer) &gt; 0;
+	}
+	/**
+	 * @brief	how many times is the Skirmish AI loaded
+	 * Thought the AI library may be loaded only once, it can be logically
+	 * loaded multiple times (load counter).
+	 */
+	virtual int GetSkirmishAILibraryLoadCount(const SSAISpecifyer&amp; sAISpecifyer) const = 0;
+	/**
+	 * @brief	unloads all AIs
+	 * Unloads all AI libraries currently loaded through this interface.
+	 */
+	virtual int ReleaseAllSkirmishAILibraries() = 0;
+	
+	
+	
+//	virtual std::vector&lt;IGroupAILibraryInfo*&gt; GetGroupAILibraryInfos(bool forceLoadFromLibrary = false) const;
+	virtual std::vector&lt;SGAISpecifyer&gt; GetGroupAILibrarySpecifyers() const = 0;
+	virtual const IGroupAILibrary* FetchGroupAILibrary(const SGAISpecifyer&amp; gAISpecifyer) = 0;
+	virtual int ReleaseGroupAILibrary(const SGAISpecifyer&amp; gAISpecifyer) = 0;
+	virtual int GetGroupAILibraryLoadCount(const SGAISpecifyer&amp; gAISpecifyer) const = 0;
+	bool IsGroupAILibraryLoaded(const SGAISpecifyer&amp; gAISpecifyer) const {
+		return GetGroupAILibraryLoadCount(gAISpecifyer) &gt; 0;
+	}
+	virtual int ReleaseAllGroupAILibraries() = 0;
+};
+
+#endif	/* _IAIINTERFACELIBRARY_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/IAIInterfaceLibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/IAILibraryManager.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/IAILibraryManager.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/IAILibraryManager.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,99 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;IAILibraryManager.h&quot;
+
+
+#include &quot;StdAfx.h&quot;
+#include &quot;AILibraryManager.h&quot;
+
+#include &lt;iostream&gt;
+
+IAILibraryManager* IAILibraryManager::myAILibraryManager = NULL;
+
+IAILibraryManager* IAILibraryManager::GetInstance() {
+
+	if (myAILibraryManager == NULL) {
+		myAILibraryManager = SAFE_NEW CAILibraryManager();
+	}
+
+	return myAILibraryManager;
+}
+
+void IAILibraryManager::OutputSkirmishAIInfo() {
+
+	const IAILibraryManager* myLibManager = IAILibraryManager::GetInstance();
+	const std::vector&lt;SSAIKey&gt;* keys = myLibManager-&gt;GetSkirmishAIKeys();
+	
+	std::cout &lt;&lt; &quot;#&quot; &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;# Available Spring Skirmish AIs&quot; &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;# -----------------------------&quot; &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;# [Name]\t[Version]\t[Interface-name]\t[Interface-version]&quot; &lt;&lt; std::endl;
+	
+	std::vector&lt;SSAIKey&gt;::const_iterator key;
+    for (key=keys-&gt;begin(); key != keys-&gt;end(); key++) {
+		std::cout &lt;&lt; &quot;  &quot;;
+		std::cout &lt;&lt; key-&gt;ai.shortName &lt;&lt; &quot;\t\t&quot;;
+		std::cout &lt;&lt; key-&gt;ai.version &lt;&lt; &quot;\t\t&quot;;
+		std::cout &lt;&lt; key-&gt;interface.shortName &lt;&lt; &quot;\t\t\t&quot;;
+		std::cout &lt;&lt; key-&gt;interface.version;
+		std::cout &lt;&lt; std::endl;
+    }
+	
+	std::cout &lt;&lt; &quot;#&quot; &lt;&lt; std::endl;
+}
+	
+bool IAILibraryManager::SplittAIKey(const std::string&amp; key,
+		std::string* aiName,
+		std::string* aiVersion,
+		std::string* interfaceName,
+		std::string* interfaceVersion) {
+
+	bool isValid = true;
+
+	size_t sepPos;
+	size_t versionSepPos;
+	std::string tmp;
+
+	// interface
+	sepPos = key.find('_');
+	if (sepPos != std::string::npos) { // interface info is available
+		tmp = key.substr(0, sepPos); // interface part
+		versionSepPos = tmp.find('#');
+		if (versionSepPos != std::string::npos) { // interface version info available
+			interfaceName = new std::string(tmp.substr(0, versionSepPos));
+			interfaceVersion = new std::string(tmp.substr(versionSepPos+1));
+		} else {
+			interfaceName = new std::string(tmp);
+		}
+
+		tmp = key.substr(sepPos+1); // ai part
+	} else {
+		tmp = key; // ai part
+	}
+
+	// ai
+	versionSepPos = tmp.find('#');
+	if (versionSepPos != std::string::npos) { // ai version info available
+		aiName = new std::string(tmp.substr(0, versionSepPos));
+		aiVersion = new std::string(tmp.substr(versionSepPos+1));
+	} else {
+		aiName = new std::string(tmp);
+	}
+
+	return isValid;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/IAILibraryManager.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/IAILibraryManager.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/IAILibraryManager.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/IAILibraryManager.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,133 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _IAILIBRARYMANAGER_H
+#define	_IAILIBRARYMANAGER_H
+
+#include &quot;IAIInterfaceLibrary.h&quot;
+#include &quot;ISkirmishAILibrary.h&quot;
+//#include &quot;SkirmishAILibraryKey.h&quot;
+
+//#include &quot;AIInterfaceLibraryInfo.h&quot;
+struct SSAIKey;
+struct SGAIKey;
+#include &quot;AIInterfaceLibraryInfo.h&quot;
+#include &quot;SkirmishAILibraryInfo.h&quot;
+#include &quot;GroupAILibraryInfo.h&quot;
+
+/**
+ * @brief manages AIs and AI interfaces
+ */
+class IAILibraryManager {
+//public:
+//	typedef s_cont&lt;ISkirmishAILibraryInterfaceInfo&gt;::const_vector T_interfaceInfos_const;
+//	typedef s_cont&lt;CSkirmishAILibraryInfoKey&gt;::const_vector T_infoKeys_const;
+////	typedef s_cont&lt;ISkirmishAILibraryInfo&gt;::const_vector T_aiInfos_const;
+//	typedef s_cont&lt;std::string&gt;::const_vector T_specifyers_const;
+	
+public:
+	virtual ~IAILibraryManager() {}
+////	virtual ISkirmishAILibraryManager() = 0; // looks for interface and AIs supported by them (ret != 0: error)
+////	virtual ~ISkirmishAILibraryManager() = 0; // unloads all shared libraries that are currently loaded (interfaces and implementations)
+//
+//	virtual T_interfaceInfos_const GetInterfaceInfos() const = 0;
+//	virtual T_infoKeys_const GetInfoKeys() const = 0;
+////	virtual const std::vector&lt;const ISkirmishAILibraryInfo*&gt;* GetAIInfos() const = 0;
+////	virtual const std::vector&lt;const ISkirmishAILibraryInfo*&gt;* GetInterfaceAIs(const SAIInterfaceLibraryInfo&amp; interfaceInfo) const = 0;
+//
+//	virtual T_specifyers_const GetSpecifyers() const = 0;
+//	virtual T_infoKeys_const GetApplyingInfoKeys(const std::string&amp; specifyer) const {
+//		
+//		T_infoKeys_const applyingInfoKeys;
+//		
+//		const T_infoKeys_const infoKeys = GetInfoKeys();
+//		T_infoKeys_const::const_iterator infoKey;
+//		for (infoKey=infoKeys.begin(); infoKey!=infoKeys.end(); infoKey++) {
+//			if ((*infoKey)-&gt;IsApplyingSpecifyer(specifyer)) {
+//				applyingInfoKeys.push_back(*infoKey);
+//			}
+//		}
+//		
+//		return applyingInfoKeys;
+//	}
+//
+//	// an AI is only really loaded when it is not yet loaded.
+//	virtual const s_p&lt;const CSkirmishAILibraryKey&gt; LoadAI(const CSkirmishAILibraryInfoKey&amp; infoKey) = 0;
+//	// an AI is only unloaded when UnloadAI() is called
+//	// as many times as LoadAI() was.
+//	// loading and unloading of the interfaces
+//	// is handled internally/automatically.
+////	virtual int UnloadAI(const CSkirmishAILibraryKey&amp; key) = 0;
+//	virtual void UnloadAI(const CSkirmishAILibraryInfoKey&amp; infoKey) = 0;
+//	
+//	virtual int UnloadEverything() = 0; // unloads all currently loaded AIs and interfaces
+//	faces and implementations)
+	
+	virtual const std::vector&lt;SAIInterfaceSpecifyer&gt;* GetInterfaceSpecifyers() const = 0;
+	virtual const std::vector&lt;SSAIKey&gt;* GetSkirmishAIKeys() const = 0;
+	virtual const std::vector&lt;SGAIKey&gt;* GetGroupAIKeys() const = 0;
+	
+//	virtual const std::map&lt;const SAIInterfaceSpecifyer, CAIInterfaceLibraryInfo*&gt;* GetInterfaceInfos() const = 0;
+//	virtual const std::map&lt;const SSAIKey, CSkirmishAILibraryInfo*&gt;* GetSkirmishAIInfos() const = 0;
+//	virtual const std::map&lt;const SGAIKey, CGroupAILibraryInfo*&gt;* GetGroupAIInfos() const = 0;
+	typedef std::map&lt;const SAIInterfaceSpecifyer, CAIInterfaceLibraryInfo*, SAIInterfaceSpecifyer_Comparator&gt; T_interfaceInfos;
+	typedef std::map&lt;const SSAIKey, CSkirmishAILibraryInfo*, SSAIKey_Comparator&gt; T_skirmishAIInfos;
+	typedef std::map&lt;const SGAIKey, CGroupAILibraryInfo*, SGAIKey_Comparator&gt; T_groupAIInfos;
+	
+	virtual const T_interfaceInfos* GetInterfaceInfos() const = 0;
+	virtual const T_skirmishAIInfos* GetSkirmishAIInfos() const = 0;
+	virtual const T_groupAIInfos* GetGroupAIInfos() const = 0;
+
+	virtual std::vector&lt;SSAIKey&gt; ResolveSkirmishAIKey(const SSAISpecifyer&amp; skirmishAISpecifyer) const = 0;
+	virtual std::vector&lt;SSAIKey&gt; ResolveSkirmishAIKey(const std::string&amp; skirmishAISpecifyer) const = 0;
+	// a Skirmish AI (its library) is only really loaded when it is not yet loaded.
+	virtual const ISkirmishAILibrary* FetchSkirmishAILibrary(const SSAIKey&amp; skirmishAIKey) = 0;
+	// a Skirmish AI is only unloaded when ReleaseSkirmishAILibrary() is called
+	// as many times as GetSkirmishAILibrary() was.
+	// loading and unloading of the interfaces
+	// is handled internally/automatically.
+	virtual void ReleaseSkirmishAILibrary(const SSAIKey&amp; skirmishAIKey) = 0;
+	virtual void ReleaseAllSkirmishAILibraries() = 0; // unloads all currently Skirmish loaded AIs
+	
+	virtual std::vector&lt;SGAIKey&gt; ResolveGroupAIKey(const std::string&amp; groupAISpecifyer) const = 0;
+	// a Group AI (its library) is only really loaded when it is not yet loaded.
+	virtual const IGroupAILibrary* FetchGroupAILibrary(const SGAIKey&amp; groupAIKey) = 0;
+	// a Group AI is only unloaded when ReleaseSkirmishAILibrary() is called
+	// as many times as GetSkirmishAILibrary() was.
+	// loading and unloading of the interfaces
+	// is handled internally/automatically.
+	virtual void ReleaseGroupAILibrary(const SGAIKey&amp; groupAIKey) = 0;
+	virtual void ReleaseAllGroupAILibraries() = 0; // unloads all currently loaded Group AIs
+	
+	virtual void ReleaseEverything() = 0; // unloads all currently loaded AIs and interfaces
+	
+public:
+	/* guaranteed to not return NULL */
+	static IAILibraryManager* GetInstance();
+	static void OutputSkirmishAIInfo();
+private:
+	static IAILibraryManager* myAILibraryManager;
+	
+protected:
+	static bool SplittAIKey(const std::string&amp; key,
+			std::string* aiName,
+			std::string* aiVersion,
+			std::string* interfaceName,
+			std::string* interfaceVersion);
+};
+
+#endif	/* _IAILIBRARYMANAGER_H */


Property changes on: branches/caiinterface/rts/ExternalAI/IAILibraryManager.h
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: branches/caiinterface/rts/ExternalAI/IGroupAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/IGroupAI.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/IGroupAI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,36 +0,0 @@
-#ifndef IGROUPAI_H
-#define IGROUPAI_H
-// IGroupAI.h: interface for the IGroupAI class.
-// Dont modify this file
-//////////////////////////////////////////////////////////////////////
-
-#include &quot;aibase.h&quot;
-#include &quot;Sim/Units/CommandAI/Command.h&quot;
-
-class IGroupAICallback;
-class IAICallback;
-
-#define AI_INTERFACE_VERSION (14 + AI_INTERFACE_GENERATED_VERSION)
-
-class SPRING_API IGroupAI
-{
-public:
-	virtual void InitAi(IGroupAICallback* callback)=0;
-	virtual bool AddUnit(int unit)=0;									//group should return false if it doenst want the unit for some reason
-	virtual void RemoveUnit(int unit)=0;								//no way to refuse giving up a unit
-
-	virtual void GiveCommand(Command* c)=0;								//the group is given a command by the player
-	virtual const std::vector&lt;CommandDescription&gt;&amp; GetPossibleCommands()=0;	//the ai tells the interface what commands it can take (note that it returns a reference so it must keep the vector in memory itself)
-	virtual int GetDefaultCmd(int unitid)=0;							//the default command for the ai given that the mouse pointer hovers above unit unitid (or no unit if unitid=0)
-
-	virtual void CommandFinished(int unit,int type)=0;					//a specific unit has finished a specific command, might be a good idea to give new orders to it
-
-	virtual void Update()=0;											//called once a frame (30 times a second)
-	virtual void DrawCommands()=0;										//the place to use the LineDrawer interface functions
-	virtual void Load(IGroupAICallback* callback,std::istream *s){};	//load ai from file
-	virtual void Save(std::ostream *s){};							//save ai to file
-
-	DECLARE_PURE_VIRTUAL(~IGroupAI())
-};
-
-#endif /* IGROUPAI_H */

Copied: branches/caiinterface/rts/ExternalAI/IGroupAILibrary.h (from rev 6207, branches/caiinterface/rts/ExternalAI/IGroupAI.h)
===================================================================
--- branches/caiinterface/rts/ExternalAI/IGroupAILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/IGroupAILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,53 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _IGROUPAILIBRARY_H
+#define	_IGROUPAILIBRARY_H
+
+#include &quot;Interface/ELevelOfSupport.h&quot;
+#include &lt;vector&gt;
+#include &lt;map&gt;
+
+struct SGAISpecifyer;
+struct InfoItem;
+struct Option;
+struct SAIInterfaceSpecifyer;
+
+class IGroupAILibrary {
+public:
+	virtual ~IGroupAILibrary() {}
+	
+	virtual SGAISpecifyer GetSpecifyer() const = 0;
+	/**
+	 * Level of Support for a specific engine version and AI interface.
+	 * @return see enum LevelOfSupport (higher values could be used optionally)
+	 */
+	virtual LevelOfSupport GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber,
+			const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) const = 0;
+	
+    virtual std::map&lt;std::string, InfoItem&gt; GetInfos() const = 0;
+	virtual std::vector&lt;Option&gt; GetOptions() const = 0;
+	
+	
+    virtual void Init(int teamId, int groupId) const = 0;
+    virtual void Release(int teamId, int groupId) const = 0;
+    virtual int HandleEvent(int teamId, int groupId, int topic, const void* data) const = 0;
+};
+
+#endif	/* _IGROUPAILIBRARY_H */
+

Added: branches/caiinterface/rts/ExternalAI/ISkirmishAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/ISkirmishAI.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/ISkirmishAI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,33 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _ISKIRMISHAI_H
+#define	_ISKIRMISHAI_H
+
+class ISkirmishAI {
+public:
+//    virtual ~ISkirmishAI() = 0;
+	
+	/**
+	 * inherited form ISkirmishAI.
+	 * CAUTION: takes C AI Interface events, not engine C++ ones!
+	 */
+    virtual int HandleEvent(int topic, const void* data) const = 0;
+};
+
+#endif	/* _ISKIRMISHAI_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/ISkirmishAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/ISkirmishAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/ISkirmishAILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/ISkirmishAILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,53 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _ISKIRMISHAILIBRARY_H
+#define	_ISKIRMISHAILIBRARY_H
+
+#include &quot;Interface/ELevelOfSupport.h&quot;
+#include &lt;vector&gt;
+#include &lt;map&gt;
+
+struct SSAISpecifyer;
+struct InfoItem;
+struct Option;
+struct SAIInterfaceSpecifyer;
+
+class ISkirmishAILibrary {
+public:
+	virtual ~ISkirmishAILibrary() {}
+	
+	virtual SSAISpecifyer GetSpecifyer() const = 0;
+	/**
+	 * Level of Support for a specific engine version and AI interface.
+	 * @return see enum LevelOfSupport (higher values could be used optionally)
+	 */
+	virtual LevelOfSupport GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber,
+			const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) const = 0;
+	
+    virtual std::map&lt;std::string, InfoItem&gt; GetInfos() const = 0;
+	virtual std::vector&lt;Option&gt; GetOptions() const = 0;
+	
+	
+    virtual void Init(int teamId) const = 0;
+    virtual void Release(int teamId) const = 0;
+    virtual int HandleEvent(int teamId, int topic, const void* data) const = 0;
+};
+
+#endif	/* _ISKIRMISHAILIBRARY_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/ISkirmishAILibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,804 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AISCOMMANDS_H
+#define	_AISCOMMANDS_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;aidefines.h&quot;
+	
+
+#define COMMAND_TO_ID_ENGINE -1
+	
+	
+#define COMMAND_NULL 0
+#define COMMAND_DRAWER_POINT_ADD 1
+#define COMMAND_DRAWER_LINE_ADD 2
+#define COMMAND_DRAWER_POINT_REMOVE 3
+#define COMMAND_SEND_START_POS 4
+#define COMMAND_CHEATS_SET_MY_HANDICAP 5
+#define COMMAND_SEND_TEXT_MESSAGE 6
+#define COMMAND_SET_LAST_POS_MESSAGE 7
+#define COMMAND_SEND_RESOURCES 8
+#define COMMAND_SEND_UNITS 9
+#define COMMAND_SHARED_MEM_AREA_CREATE 10
+#define COMMAND_SHARED_MEM_AREA_RELEASE 11
+#define COMMAND_GROUP_CREATE 12
+#define COMMAND_GROUP_ERASE 13
+#define COMMAND_GROUP_ADD_UNIT 14
+#define COMMAND_GROUP_REMOVE_UNIT 15
+#define COMMAND_PATH_INIT 16
+#define COMMAND_PATH_GET_APPROXIMATE_LENGTH 17
+#define COMMAND_PATH_GET_NEXT_WAYPOINT 18
+#define COMMAND_PATH_FREE 19
+#define COMMAND_CHEATS_GIVE_ME_METAL 20
+#define COMMAND_CALL_LUA_RULES 21
+#define COMMAND_DRAWER_ADD_NOTIFICATION 22
+#define COMMAND_DRAWER_DRAW_UNIT 23
+#define COMMAND_DRAWER_PATH_START 24
+#define COMMAND_DRAWER_PATH_FINISH 25
+#define COMMAND_DRAWER_PATH_DRAW_LINE 26
+#define COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON 27
+#define COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS 28
+#define COMMAND_DRAWER_PATH_BREAK 29
+#define COMMAND_DRAWER_PATH_RESTART 30
+#define COMMAND_DRAWER_FIGURE_CREATE_SPLINE 31
+#define COMMAND_DRAWER_FIGURE_CREATE_LINE 32
+#define COMMAND_DRAWER_FIGURE_SET_COLOR 33
+#define COMMAND_DRAWER_FIGURE_DELETE 34
+#define COMMAND_UNIT_BUILD 35
+#define COMMAND_UNIT_STOP 36
+#define COMMAND_UNIT_WAIT 37
+#define COMMAND_UNIT_WAIT_TIME 38
+#define COMMAND_UNIT_WAIT_DEATH 39
+#define COMMAND_UNIT_WAIT_SQUAD 40
+#define COMMAND_UNIT_WAIT_GATHER 41
+#define COMMAND_UNIT_MOVE 42
+#define COMMAND_UNIT_PATROL 43
+#define COMMAND_UNIT_FIGHT 44
+#define COMMAND_UNIT_ATTACK 45
+#define COMMAND_UNIT_ATTACK_AREA 46
+#define COMMAND_UNIT_GUARD 47
+#define COMMAND_UNIT_AI_SELECT 48
+#define COMMAND_UNIT_GROUP_ADD 49
+#define COMMAND_UNIT_GROUP_CLEAR 50
+#define COMMAND_UNIT_REPAIR 51
+#define COMMAND_UNIT_SET_FIRE_STATE 52
+#define COMMAND_UNIT_SET_MOVE_STATE 53
+#define COMMAND_UNIT_SET_BASE 54
+#define COMMAND_UNIT_SELF_DESTROY 55
+#define COMMAND_UNIT_SET_WANTED_MAX_SPEED 56
+#define COMMAND_UNIT_LOAD_UNITS 57
+#define COMMAND_UNIT_LOAD_UNITS_AREA 58
+#define COMMAND_UNIT_LOAD_ONTO 59
+#define COMMAND_UNIT_UNLOAD_UNITS_AREA 60
+#define COMMAND_UNIT_UNLOAD_UNIT 61
+#define COMMAND_UNIT_SET_ON_OFF 62
+#define COMMAND_UNIT_RECLAIM 63
+#define COMMAND_UNIT_RECLAIM_AREA 64
+#define COMMAND_UNIT_CLOAK 65
+#define COMMAND_UNIT_STOCKPILE 66
+#define COMMAND_UNIT_D_GUN 67
+#define COMMAND_UNIT_D_GUN_POS 68
+#define COMMAND_UNIT_RESTORE_AREA 69
+#define COMMAND_UNIT_SET_REPEAT 70
+#define COMMAND_UNIT_SET_TRAJECTORY 71
+#define COMMAND_UNIT_RESURRECT 72
+#define COMMAND_UNIT_RESURRECT_AREA 73
+#define COMMAND_UNIT_CAPTURE 74
+#define COMMAND_UNIT_CAPTURE_AREA 75
+#define COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL 76
+#define COMMAND_UNIT_SET_IDLE_MODE 77
+#define COMMAND_UNIT_CUSTOM 78
+//#define COMMAND_UNIT_ATTACK_POS 
+//#define COMMAND_UNIT_INSERT 
+//#define COMMAND_UNIT_REMOVE 
+//#define COMMAND_UNIT_ATTACK_AREA 
+//#define COMMAND_UNIT_ATTACK_LOOPBACK 
+//#define COMMAND_UNIT_GROUP_SELECT 
+//#define COMMAND_UNIT_INTERNAL 
+#define COMMAND_CHEATS_GIVE_ME_ENERGY 79
+#define COMMAND_CHEATS_GIVE_ME_NEW_UNIT 80
+
+#define NUM_CMD_TOPICS 81
+
+	
+#define UNIT_COMMAND_OPTION_DONT_REPEAT	 (1 &lt;&lt; 3) //   8
+#define UNIT_COMMAND_OPTION_RIGHT_MOUSE_KEY (1 &lt;&lt; 4) //  16
+#define UNIT_COMMAND_OPTION_SHIFT_KEY	   (1 &lt;&lt; 5) //  32
+#define UNIT_COMMAND_OPTION_CONTROL_KEY	 (1 &lt;&lt; 6) //  64
+#define UNIT_COMMAND_OPTION_ALT_KEY		 (1 &lt;&lt; 7) // 128
+
+
+#define UNIT_COMMAND_BUILD_NO_FACING -1
+
+
+
+struct SSetMyHandicapCheatCommand {
+	float handicap;
+};
+struct SGiveMeMetalCheatCommand {
+	float amount;
+};
+struct SGiveMeEnergyCheatCommand {
+	float amount;
+};
+struct SGiveMeNewUnitCheatCommand {
+	int unitDefId;
+	struct SAIFloat3 pos;
+	int ret_newUnitId;
+};
+
+struct SSendTextMessageCommand {
+	const char* text;
+	int zone;
+};
+
+struct SSetLastPosMessageCommand {
+	struct SAIFloat3 pos;
+};
+
+struct SSendResourcesCommand {
+	float mAmount;
+	float eAmount;
+	int receivingTeam;
+	bool ret_isExecuted;
+};
+
+struct SSendUnitsCommand {
+	int* unitIds;
+	int numUnitIds;
+	int receivingTeam;
+	int ret_sentUnits;
+};
+
+struct SCreateSharedMemAreaCommand {
+	char* name;
+	int size;
+	void* ret_sharedMemArea;
+};
+
+struct SReleaseSharedMemAreaCommand {
+	char* name;
+};
+
+struct SCreateGroupCommand {
+	char* libraryName;
+	unsigned int aiNumber;
+	int ret_groupId;
+};
+struct SEraseGroupCommand {
+	int groupId;
+};
+struct SAddUnitToGroupCommand {
+	int groupId;
+	int unitId;
+	bool ret_isExecuted;
+};
+struct SRemoveUnitFromGroupCommand {
+	int unitId;
+	bool ret_isExecuted;
+};
+
+
+struct SInitPathCommand {
+	struct SAIFloat3 start;
+	struct SAIFloat3 end;
+	int pathType;
+	int ret_pathId;
+};
+/**
+ * Returns the approximate path cost between two points
+ * note: needs to calculate the complete path so somewhat expensive
+ * note: currently disabled, always returns 0
+ */
+struct SGetApproximateLengthPathCommand {
+	struct SAIFloat3 start;
+	struct SAIFloat3 end;
+	int pathType;
+	int ret_approximatePathLength;
+};
+struct SGetNextWaypointPathCommand {
+	int pathId;
+	struct SAIFloat3 ret_nextWaypoint;
+};
+struct SFreePathCommand {
+	int pathId;
+};
+
+struct SCallLuaRulesCommand {
+	const char* data;
+	int inSize;
+	int* outSize;
+	const char* ret_outData;
+};
+
+struct SSendStartPosCommand ///&lt; result of HandleCommand is 1 - ok supported
+{
+	bool ready;
+	struct SAIFloat3 pos;
+};
+
+struct SAddNotificationDrawerCommand {
+	struct SAIFloat3 pos;
+	struct SAIFloat3 color;
+	float alpha;
+};
+struct SAddPointDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
+{
+	struct SAIFloat3 pos; ///&lt; on this position, only x and z matter
+	char* label; ///&lt; create this text on pos in my team color
+};
+struct SRemovePointDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
+{
+	struct SAIFloat3 pos; ///&lt; remove map points and lines near this point (100 distance)
+};
+struct SAddLineDrawCommand ///&lt; result of HandleCommand is 1 - ok supported
+{
+	struct SAIFloat3 posFrom; ///&lt; draw line from this pos
+	struct SAIFloat3 posTo; ///&lt; to this pos, again only x and z matter
+};
+
+struct SStartPathDrawerCommand {
+	struct SAIFloat3 pos;
+	struct SAIFloat3 color;
+	float alpha;
+};
+struct SFinishPathDrawerCommand {
+};
+struct SDrawLinePathDrawerCommand {
+	struct SAIFloat3 endPos;
+	struct SAIFloat3 color;
+	float alpha;
+};
+struct SDrawLineAndIconPathDrawerCommand {
+	int cmdId;
+	struct SAIFloat3 endPos;
+	struct SAIFloat3 color;
+	float alpha;
+};
+struct SDrawIconAtLastPosPathDrawerCommand {
+	int cmdId;
+};
+struct SBreakPathDrawerCommand {
+	struct SAIFloat3 endPos;
+	struct SAIFloat3 color;
+	float alpha;
+};
+struct SRestartPathDrawerCommand {
+	bool sameColor;
+};
+
+/**
+ * Creates a cubic Bezier spline figure (from pos1 to pos4 with control points pos2 and pos3)
+ */
+struct SCreateSplineFigureDrawerCommand {
+	struct SAIFloat3 pos1;
+	struct SAIFloat3 pos2;
+	struct SAIFloat3 pos3;
+	struct SAIFloat3 pos4;
+	float width;
+	bool arrow; // true: means that the figure will get an arrow at the end
+	int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
+	int figureGroupId; // use 0 to get a new group
+	int ret_newFigureGroupId; // the new group
+};
+struct SCreateLineFigureDrawerCommand {
+	struct SAIFloat3 pos1;
+	struct SAIFloat3 pos2;
+	float width;
+	bool arrow; // true: means that the figure will get an arrow at the end
+	int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
+	int figureGroupId; // use 0 to get a new group
+	int ret_newFigureGroupId; // the new group
+};
+struct SSetColorFigureDrawerCommand {
+	int figureGroupId;
+	struct SAIFloat3 color;
+	float alpha;
+};
+struct SDeleteFigureDrawerCommand {
+	int figureGroupId;
+};
+
+struct SDrawUnitDrawerCommand {
+	int toDrawUnitDefId;
+	struct SAIFloat3 pos;
+	float rotation;
+	int lifeTime;
+	int teamId;
+	bool transparent;
+	bool drawBorder;
+	int facing;
+};
+
+
+
+struct SBuildUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toBuildUnitDefId;
+	struct SAIFloat3 buildPos;
+	int facing; // set to UNIT_COMMAND_BUILD_NO_FACING if you want to specify no facing
+};
+
+struct SStopUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+//	struct SInsertUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+//
+//	struct SRemoveUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+struct SWaitUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+struct STimeWaitUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	// the time in seconds to wait
+	int time;
+};	
+
+struct SDeathWaitUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	// wait until this unit is dead
+	int toDieUnitId;
+};	
+
+struct SSquadWaitUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int numUnits;
+};	
+
+struct SGatherWaitUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+struct SMoveUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 toPos;
+};	
+
+struct SPatrolUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 toPos;
+};	
+
+struct SFightUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 toPos;
+};	
+
+struct SAttackUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toAttackUnitId;
+};	
+
+//	struct SAttackPosUnitCommand {
+struct SAttackAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 toAttackPos;
+	float radius;
+};	
+
+//	struct SAttackAreaUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+struct SGuardUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toGuardUnitId;
+};	
+
+struct SAiSelectUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+//	struct SGroupSelectUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+struct SGroupAddUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toGroupId;
+};	
+
+struct SGroupClearUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+struct SRepairUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toRepairUnitId;
+};	
+
+struct SSetFireStateUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	// can be: 0=hold fire, 1=return fire, 2=fire at will
+	int fireState;
+};	
+
+struct SSetMoveStateUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int moveState;
+};	
+
+struct SSetBaseUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 basePos;
+};	
+
+//	struct SInternalUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+struct SSelfDestroyUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+struct SSetWantedMaxSpeedUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	float wantedMaxSpeed;
+};	
+
+struct SLoadUnitsUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int* toLoadUnitIds;
+	int numToLoadUnits;
+};	
+
+struct SLoadUnitsAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 pos;
+	float radius;
+};	
+
+struct SLoadOntoUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int transporterUnitId;
+};	
+
+struct SUnloadUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 toPos;
+	int toUnloadUnitId;
+};	
+
+struct SUnloadUnitsAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 toPos;
+	float radius;
+};	
+
+struct SSetOnOffUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	bool on;
+};	
+
+struct SReclaimUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toReclaimUnitIdOrFeatureId;
+};	
+
+struct SReclaimAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 pos;
+	float radius;
+};	
+
+struct SCloakUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	bool cloak;
+};	
+
+struct SStockpileUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+};	
+
+struct SDGunUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toAttackUnitId;
+};	
+
+struct SDGunPosUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 pos;
+};	
+
+struct SRestoreAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 pos;
+	float radius;
+};	
+
+struct SSetRepeatUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	bool repeat;
+};	
+
+struct SSetTrajectoryUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int trajectory;
+};	
+
+struct SResurrectUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toResurrectFeatureId;
+};	
+
+struct SResurrectAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 pos;
+	float radius;
+};	
+
+struct SCaptureUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int toCaptureUnitId;
+};	
+
+struct SCaptureAreaUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	struct SAIFloat3 pos;
+	float radius;
+};	
+
+struct SSetAutoRepairLevelUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int autoRepairLevel;
+};	
+
+//	struct SAttackLoopbackUnitCommand {
+//		int unitId;
+//		int groupId;
+//		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+//		int timeOut; // command execution-time in ?seconds?
+//	};	
+
+struct SSetIdleModeUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int idleMode;
+};	
+
+struct SCustomUnitCommand {
+	int unitId;
+	int groupId;
+	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
+	int timeOut; // command execution-time in ?seconds?
+
+	int cmdId;
+	float* params;
+	int numParams;
+};
+
+
+/**
+ * @brief Sets default values
+ */
+void initSUnitCommand(void* sUnitCommand);
+
+#ifdef	__cplusplus
+struct Command;
+
+// legacy support functions
+/**
+ * @brief Allocates memory for a C Command struct
+ */
+void* mallocSUnitCommand(int unitId, int groupId, const Command* c, int sCommandId[0]);
+/**
+ * @brief Frees memory of a C Command struct
+ */
+void freeSUnitCommand(void* sCommandData, int sCommandId);
+/**
+ * @brief creates - with new - an engine C++ Command struct
+ */
+Command* newCommand(void* sUnitCommandData, int sCommandId);
+#endif	/* __cplusplus */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _AISCOMMANDS_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,149 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AISEVENTS_H
+#define AISEVENTS_H
+
+#include &quot;SAIFloat3.h&quot;
+#include &quot;SAICallback.h&quot;
+
+#define EVENT_NULL				0
+#define EVENT_INIT				1
+#define EVENT_UPDATE			2
+#define EVENT_MESSAGE			3
+#define EVENT_UNIT_CREATED		4
+#define EVENT_UNIT_FINISHED		5
+#define EVENT_UNIT_IDLE			6
+#define EVENT_UNIT_MOVE_FAILED	7
+#define EVENT_UNIT_DAMAGED		8
+#define EVENT_UNIT_DESTROYED	9
+#define EVENT_UNIT_GIVEN		10
+#define EVENT_UNIT_CAPTURED		11
+#define EVENT_ENEMY_ENTER_LOS	12
+#define EVENT_ENEMY_LEAVE_LOS	13
+#define EVENT_ENEMY_ENTER_RADAR 14
+#define EVENT_ENEMY_LEAVE_RADAR 15
+#define EVENT_ENEMY_DAMAGED		16
+#define EVENT_ENEMY_DESTROYED	17
+#define EVENT_WEAPON_FIRED		18
+#define EVENT_PLAYER_COMMAND	19
+#define EVENT_SEISMIC_PING		20
+
+#define NUM_EVENTS				21
+
+
+struct SInitEvent {
+	int team;
+	SAICallback* c_callback;
+};
+
+struct SUpdateEvent {
+	int frame;
+};
+
+struct SMessageEvent {
+	int player;
+	const char* message;
+};
+
+struct SUnitCreatedEvent {
+	int unit;
+};
+
+struct SUnitFinishedEvent {
+	int unit;
+};
+
+struct SUnitIdleEvent {
+	int unit;
+};
+
+struct SUnitMoveFailedEvent {
+	int unit;
+};
+
+struct SUnitDamagedEvent {
+	int unit;
+	int attacker;
+	float damage;
+	SAIFloat3 dir;
+};
+
+struct SUnitDestroyedEvent {
+	int unit;
+	int attacker;
+};
+
+struct SUnitGivenEvent {
+	int unitId;
+	int oldTeamId;
+	int newTeamId;
+};
+
+struct SUnitCapturedEvent {
+	int unitId;
+	int oldTeamId;
+	int newTeamId;
+};
+
+struct SEnemyEnterLOSEvent {
+	int enemy;
+};
+
+struct SEnemyLeaveLOSEvent {
+	int enemy;
+};
+
+struct SEnemyEnterRadarEvent {
+	int enemy;
+};
+
+struct SEnemyLeaveRadarEvent {
+	int enemy;
+};
+
+struct SEnemyDamagedEvent {
+	int enemy;
+	int attacker;
+	float damage;
+	SAIFloat3 dir;
+};
+
+struct SEnemyDestroyedEvent {
+	int enemy;
+	int attacker;
+};
+
+struct SWeaponFiredEvent {
+	int unitId;
+	int weaponDefId;
+};
+
+struct SPlayerCommandEvent {
+	int* unitIds;
+	int numUnitIds;
+	int commandTopic; // see AISCommands.h COMMAND_* defines
+	void* commandData; // see AISCommands.h S*Command structs
+	int playerId;
+};
+
+struct SSeismicPingEvent {
+	SAIFloat3 pos;
+	float strength;
+};
+
+#endif /*AISEVENTS_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/ELevelOfSupport.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/ELevelOfSupport.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/ELevelOfSupport.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,41 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _ELEVELOFSUPPORT_H
+#define	_ELEVELOFSUPPORT_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+enum LevelOfSupport {
+	LOS_None,		// 0: will (possibly) result in a crash
+	LOS_Bad,		// 1: does not work correctly, eg.: does nothing, just stand around, but neither does crash
+	LOS_Working,	// 2: does work, but may not use all info the engine and ai interface supply
+	LOS_Compleet,	// 3: does work and use the engine and ai interface to the fullest,
+					//    but is optimised for newer versions
+	LOS_Optimal,	// 4: is made optimally suitet for this engine and ai interface version
+	LOS_Unknown		// 5: not evaluated (used eg when a library is not accessed directly,
+					//    but info is loaded from a file)
+};
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _ELEVELOFSUPPORT_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/ELevelOfSupport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,111 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AI.h&quot;
+#include &quot;Event/AIEvents.h&quot;
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;ExternalAI/Interface/AISEvents.h&quot;
+
+CAI::CAI() : team(0), ai(NULL) { 
+	
+}
+
+
+CAI::CAI(int team, IGlobalAI* ai) : team(team), ai(ai) {
+	
+}
+
+int CAI::handleEvent(int topic, const void* data) {
+	
+	if (ai != NULL) {
+		CAIEvent* e;
+
+		switch(topic) {
+			case EVENT_NULL:
+				e = new CAINullEvent();
+				break;
+			case EVENT_INIT:
+				e = new CAIInitEvent((const SInitEvent*) data);
+				break;
+			case EVENT_UPDATE:
+				e = new CAIUpdateEvent((const SUpdateEvent*) data);
+				break;
+			case EVENT_MESSAGE:	
+				e = new CAIMessageEvent((const SMessageEvent*) data);
+				break;
+			case EVENT_UNIT_CREATED:
+				e = new CAIUnitCreatedEvent((const SUnitCreatedEvent*) data);
+				break;
+			case EVENT_UNIT_FINISHED:
+				e = new CAIUnitFinishedEvent((const SUnitFinishedEvent*) data);
+				break;
+			case EVENT_UNIT_IDLE:
+				e = new CAIUnitIdleEvent((const SUnitIdleEvent*) data);
+				break;
+			case EVENT_UNIT_MOVE_FAILED:
+				e = new CAIUnitMoveFailedEvent((const SUnitMoveFailedEvent*) data);
+				break;
+			case EVENT_UNIT_DAMAGED:
+				e = new CAIUnitDamagedEvent((const SUnitDamagedEvent*) data);
+				break;
+			case EVENT_UNIT_DESTROYED: 
+				e = new CAIUnitDestroyedEvent((const SUnitDestroyedEvent*) data);
+				break;
+			case EVENT_UNIT_GIVEN:
+				e = new CAIUnitGivenEvent((const SUnitGivenEvent*) data);
+				break;
+			case EVENT_UNIT_CAPTURED:
+				e = new CAIUnitCapturedEvent((const SUnitCapturedEvent*) data);
+				break;
+			case EVENT_ENEMY_ENTER_LOS:
+				e = new CAIEnemyEnterLOSEvent((const SEnemyEnterLOSEvent*) data);
+				break;
+			case EVENT_ENEMY_LEAVE_LOS:
+				e = new CAIEnemyLeaveLOSEvent((const SEnemyLeaveLOSEvent*) data);
+				break;
+			case EVENT_ENEMY_ENTER_RADAR:
+				e = new CAIEnemyEnterRadarEvent((const SEnemyEnterRadarEvent*) data);
+				break;
+			case EVENT_ENEMY_LEAVE_RADAR:
+				e = new CAIEnemyLeaveRadarEvent((const SEnemyLeaveRadarEvent*) data);
+				break;
+			case EVENT_ENEMY_DAMAGED:
+				e = new CAIEnemyDamagedEvent((const SEnemyDamagedEvent*) data);
+				break;
+			case EVENT_ENEMY_DESTROYED: 
+				e = new CAIEnemyDestroyedEvent((const SEnemyDestroyedEvent*) data);
+				break;
+			case EVENT_WEAPON_FIRED: 
+				e = new CAIWeaponFiredEvent((const SWeaponFiredEvent*) data);
+				break;
+			case EVENT_PLAYER_COMMAND: 
+				e = new CAIPlayerCommandEvent((const SPlayerCommandEvent*) data);
+				break;
+			case EVENT_SEISMIC_PING: 
+				e = new CAISeismicPingEvent((const SSeismicPingEvent*) data);
+				break;
+			default:
+				e = new CAINullEvent();
+				break;
+		}
+
+		e-&gt;run(ai);
+		delete e;
+	}
+	
+	return 0;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,34 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AI_H
+#define AI_H
+
+class IGlobalAI;
+
+class CAI { 
+public:
+    CAI();
+    CAI(int team, IGlobalAI* ai);
+    virtual int handleEvent(int topic, const void* data);
+
+    int team;
+    IGlobalAI* ai;
+};
+
+
+#endif /*AI_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,2215 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIAICallback.h&quot;
+
+#include &quot;ExternalAI/Interface/AISCommands.h&quot;
+
+
+creg::Class* CCommandQueue::GetClass() { return NULL; }
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+UnitDef::~UnitDef() {
+    delete movedata;
+}
+CIcon::CIcon() {}
+CIcon::~CIcon() {}
+UnitDef::UnitDefWeapon::UnitDefWeapon() {}
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+WeaponDef::~WeaponDef() {}
+DamageArray::DamageArray() {}
+
+#include &lt;string&gt;
+
+
+CAIAICallback::CAIAICallback()
+	: IAICallback(), teamId(-1), sAICallback(NULL)/*, aiCallback(NULL)*/ {
+	init();
+}
+
+CAIAICallback::CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/)
+	: IAICallback(), teamId(teamId), sAICallback(sAICallback)/*, aiCallback(aiCallback)*/ {
+	init();
+}
+
+
+void fillWithNULL(void** arr, int size) {
+	for (int i=0; i &lt; size; ++i) {
+		arr[i] = NULL;
+	}
+}
+void fillWithMinusOne(int* arr, int size) {
+	for (int i=0; i &lt; size; ++i) {
+		arr[i] = -1;
+	}
+}
+
+void CAIAICallback::init() {
+	
+	// init caches
+	int maxCacheSize = 512;
+	int maxUnits = 10000;
+	int maxGroups = 100;
+	
+	weaponDefs = new WeaponDef*[maxCacheSize]; fillWithNULL((void**)weaponDefs, maxCacheSize);
+	weaponDefFrames = new int[maxCacheSize]; fillWithMinusOne(weaponDefFrames, maxCacheSize);
+	
+	unitDefs = new UnitDef*[maxCacheSize]; fillWithNULL((void**)unitDefs, maxCacheSize);
+	unitDefFrames = new int[maxCacheSize]; fillWithMinusOne(unitDefFrames, maxCacheSize);
+	groupPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxGroups]; fillWithNULL((void**)groupPossibleCommands, maxGroups);
+	unitPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxUnits]; fillWithNULL((void**)unitPossibleCommands, maxUnits);
+	unitCurrentCommandQueues = new CCommandQueue*[maxUnits]; fillWithNULL((void**)unitCurrentCommandQueues, maxUnits);
+	
+	featureDefs = new FeatureDef*[maxCacheSize]; fillWithNULL((void**)featureDefs, maxCacheSize);
+	featureDefFrames = new int[maxCacheSize]; fillWithMinusOne(featureDefFrames, maxCacheSize);
+}
+
+
+//bool CAIAICallback::PosInCamera(float3 pos, float radius) {
+//	return aiCallback-&gt;PosInCamera(pos, radius);
+//}
+//
+//int CAIAICallback::GetCurrentFrame() {
+//	return aiCallback-&gt;GetCurrentFrame();
+//}
+//
+//int CAIAICallback::GetMyTeam() {
+//	return aiCallback-&gt;GetMyTeam();
+//}
+//
+//int CAIAICallback::GetMyAllyTeam() {
+//	return aiCallback-&gt;GetMyAllyTeam();
+//}
+//
+//int CAIAICallback::GetPlayerTeam(int player) {
+//	return aiCallback-&gt;GetPlayerTeam(player);
+//}
+//
+//const char* CAIAICallback::GetTeamSide(int team) {
+//	return aiCallback-&gt;GetTeamSide(team);
+//}
+//
+//int CAIAICallback::GetUnitGroup(int unitId) {
+//	return aiCallback-&gt;GetUnitGroup(unitId);
+//}
+//
+//int CAIAICallback::GetUnitAiHint(int unitId) {
+//	return aiCallback-&gt;GetUnitAiHint(unitId);
+//}
+//
+//int CAIAICallback::GetUnitTeam(int unitId) {
+//	return aiCallback-&gt;GetUnitTeam(unitId);
+//}
+//
+//int CAIAICallback::GetUnitAllyTeam(int unitId) {
+//	return aiCallback-&gt;GetUnitAllyTeam(unitId);
+//}
+//
+//float CAIAICallback::GetUnitHealth(int unitId) {
+//	return aiCallback-&gt;GetUnitHealth(unitId);
+//}
+//
+//float CAIAICallback::GetUnitMaxHealth(int unitId) {
+//	return aiCallback-&gt;GetUnitMaxHealth(unitId);
+//}
+//
+//float CAIAICallback::GetUnitSpeed(int unitId) {
+//	return aiCallback-&gt;GetUnitSpeed(unitId);
+//}
+//
+//float CAIAICallback::GetUnitPower(int unitId) {
+//	return aiCallback-&gt;GetUnitPower(unitId);
+//}
+//
+//float CAIAICallback::GetUnitExperience(int unitId) {
+//	return aiCallback-&gt;GetUnitExperience(unitId);
+//}
+//
+//float CAIAICallback::GetUnitMaxRange(int unitId) {
+//	return aiCallback-&gt;GetUnitMaxRange(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitActivated(int unitId) {
+//	return aiCallback-&gt;IsUnitActivated(unitId);
+//}
+//
+//bool CAIAICallback::UnitBeingBuilt(int unitId) {
+//	return aiCallback-&gt;UnitBeingBuilt(unitId);
+//}
+//
+//float3 CAIAICallback::GetUnitPos(int unitId) {
+//	return aiCallback-&gt;GetUnitPos(unitId);
+//}
+//
+//int CAIAICallback::GetBuildingFacing(int unitId) {
+//	return aiCallback-&gt;GetBuildingFacing(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitCloaked(int unitId) {
+//	return aiCallback-&gt;IsUnitCloaked(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitParalyzed(int unitId) {
+//	return aiCallback-&gt;IsUnitParalyzed(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitNeutral(int unitId) {
+//	return aiCallback-&gt;IsUnitNeutral(unitId);
+//}
+//
+//bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+//	return aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+//}
+//
+//float3 CAIAICallback::GetNextWaypoint(int pathid) {
+//	return aiCallback-&gt;GetNextWaypoint(pathid);
+//}
+//
+//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;GetPathLength(start, end, pathType);
+//}
+//
+//int CAIAICallback::GetEnemyUnits(int* unitIds) {
+//	return aiCallback-&gt;GetEnemyUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
+//	return aiCallback-&gt;GetEnemyUnitsInRadarAndLos(unitIds);
+//}
+//
+//int CAIAICallback::GetFriendlyUnits(int* unitIds) {
+//	return aiCallback-&gt;GetFriendlyUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetFriendlyUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetNeutralUnits(int* unitIds) {
+//	return aiCallback-&gt;GetNeutralUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetMapWidth() {
+//	return aiCallback-&gt;GetMapWidth();
+//}
+//
+//int CAIAICallback::GetMapHeight() {
+//	return aiCallback-&gt;GetMapHeight();
+//}
+//
+//const float* CAIAICallback::GetHeightMap() {
+//	return aiCallback-&gt;GetHeightMap();
+//}
+//
+//float CAIAICallback::GetMinHeight() {
+//	return aiCallback-&gt;GetMinHeight();
+//}
+//
+//float CAIAICallback::GetMaxHeight() {
+//	return aiCallback-&gt;GetMaxHeight();
+//}
+//
+//const float* CAIAICallback::GetSlopeMap() {
+//	return aiCallback-&gt;GetSlopeMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetLosMap() {
+//	return aiCallback-&gt;GetLosMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetRadarMap() {
+//	return aiCallback-&gt;GetRadarMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetJammerMap() {
+//	return aiCallback-&gt;GetJammerMap();
+//}
+//
+//const unsigned char* CAIAICallback::GetMetalMap() {
+//	return aiCallback-&gt;GetMetalMap();
+//}
+//
+//const char* CAIAICallback::GetMapName() {
+//	return aiCallback-&gt;GetMapName();
+//}
+//
+//const char* CAIAICallback::GetModName() {
+//	return aiCallback-&gt;GetModName();
+//}
+//
+//float CAIAICallback::GetElevation(float x, float z) {
+//	return aiCallback-&gt;GetElevation(x, z);
+//}
+//
+//float CAIAICallback::GetMaxMetal() {
+//	return aiCallback-&gt;GetMaxMetal();
+//}
+//
+//float CAIAICallback::GetExtractorRadius() {
+//	return aiCallback-&gt;GetExtractorRadius();
+//}
+//
+//float CAIAICallback::GetMinWind() {
+//	return aiCallback-&gt;GetMinWind();
+//}
+//
+//float CAIAICallback::GetMaxWind() {
+//	return aiCallback-&gt;GetMaxWind();
+//}
+//
+//float CAIAICallback::GetTidalStrength() {
+//	return aiCallback-&gt;GetTidalStrength();
+//}
+//
+//float CAIAICallback::GetGravity() {
+//	return aiCallback-&gt;GetGravity();
+//}
+//
+//bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
+//	return aiCallback-&gt;CanBuildAt(unitDef, pos, facing);
+//}
+//
+//float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
+//	return aiCallback-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing);
+//}
+//
+//bool CAIAICallback::GetProperty(int id, int property, void* dst) {
+//	return aiCallback-&gt;GetProperty(id, property, dst);
+//}
+//
+//bool CAIAICallback::GetValue(int id, void* dst) {
+//	return aiCallback-&gt;GetValue(id, dst);
+//}
+//
+//int CAIAICallback::GetFileSize(const char* name) {
+//	return aiCallback-&gt;GetFileSize(name);
+//}
+//
+//int CAIAICallback::GetSelectedUnits(int* unitIds) {
+//	return aiCallback-&gt;GetSelectedUnits(unitIds);
+//}
+//
+//float3 CAIAICallback::GetMousePos() {
+//	return aiCallback-&gt;GetMousePos();
+//}
+//
+//float CAIAICallback::GetMetal() {
+//	return aiCallback-&gt;GetMetal();
+//}
+//
+//float CAIAICallback::GetMetalIncome() {
+//	return aiCallback-&gt;GetMetalIncome();
+//}
+//
+//float CAIAICallback::GetMetalUsage() {
+//	return aiCallback-&gt;GetMetalUsage();
+//}
+//
+//float CAIAICallback::GetMetalStorage() {
+//	return aiCallback-&gt;GetMetalStorage();
+//}
+//
+//float CAIAICallback::GetEnergy() {
+//	return aiCallback-&gt;GetEnergy();
+//}
+//
+//float CAIAICallback::GetEnergyIncome() {
+//	return aiCallback-&gt;GetEnergyIncome();
+//}
+//
+//float CAIAICallback::GetEnergyUsage() {
+//	return aiCallback-&gt;GetEnergyUsage();
+//}
+//
+//float CAIAICallback::GetEnergyStorage() {
+//	return aiCallback-&gt;GetEnergyStorage();
+//}
+//
+//int CAIAICallback::GetFeatures(int *features, int max) {
+//	return aiCallback-&gt;GetFeatures(features, max);
+//}
+//
+//int CAIAICallback::GetFeatures(int *features, int max, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetFeatures(features, max, pos, radius);
+//}
+//
+//const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
+//	return aiCallback-&gt;GetFeatureDef(featureId);
+//}
+//
+//float CAIAICallback::GetFeatureHealth(int featureId) {
+//	return aiCallback-&gt;GetFeatureHealth(featureId);
+//}
+//
+//float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
+//	return aiCallback-&gt;GetFeatureReclaimLeft(featureId);
+//}
+//
+//float3 CAIAICallback::GetFeaturePos(int featureId) {
+//	return aiCallback-&gt;GetFeaturePos(featureId);
+//}
+//
+//int CAIAICallback::GetNumUnitDefs() {
+//	return aiCallback-&gt;GetNumUnitDefs();
+//}
+//
+//void CAIAICallback::GetUnitDefList(const UnitDef** list) {
+//	aiCallback-&gt;GetUnitDefList(list);
+//}
+
+//float CAIAICallback::GetUnitDefHeight(int def) {
+//	return aiCallback-&gt;GetUnitDefHeight(def);
+//}
+//
+//float CAIAICallback::GetUnitDefRadius(int def) {
+//	return aiCallback-&gt;GetUnitDefRadius(def);
+//}
+//
+//const float3* CAIAICallback::GetStartPos() {
+//	return aiCallback-&gt;GetStartPos();
+//}
+//
+//
+//
+//const WeaponDef* CAIAICallback::GetWeapon(const char* weaponname) {
+//	logT(&quot;CAIAICallback::GetWeapon() aiCallback&quot;);
+//	return aiCallback-&gt;GetWeapon(weaponname);
+//}
+//
+//const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
+//	logT(&quot;CAIAICallback::GetWeaponDefById() return NULL&quot;);
+//	return NULL;
+//}
+//
+//const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
+//	logT(&quot;CAIAICallback::GetFeatureDefById() aiCallback&quot;);
+//	return aiCallback-&gt;GetFeatureDefById(featureDefId);
+//}
+//
+//int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+//	return aiCallback-&gt;GetMapPoints(pm, maxPoints);
+//}
+//
+//int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+//	return aiCallback-&gt;GetMapLines(lm, maxLines);
+//}
+//
+//const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
+//	return aiCallback-&gt;GetUnitDef(unitName);
+//}
+
+//const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
+//	return aiCallback-&gt;GetUnitDefById(unitDefId);
+//}
+
+//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int unitId) {
+//	return aiCallback-&gt;GetGroupCommands(unitId);
+//}
+//
+//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+//	return aiCallback-&gt;GetUnitCommands(unitId);
+//}
+//
+//const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+//	return aiCallback-&gt;GetCurrentUnitCommands(unitId);
+//}
+//
+//const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
+//	return aiCallback-&gt;GetUnitDef(unitId);
+//}
+
+
+
+
+
+
+
+//void CAIAICallback::SendTextMsg(const char* text, int zone) {
+//	aiCallback-&gt;SendTextMsg(text, zone);
+//}
+//
+//void CAIAICallback::SetLastMsgPos(float3 pos) {
+//	aiCallback-&gt;SetLastMsgPos(pos);
+//}
+//
+//void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
+//	aiCallback-&gt;AddNotification(pos, color, alpha);
+//}
+//
+//bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
+//	return aiCallback-&gt;SendResources(mAmount, eAmount, receivingTeam);
+//}
+//
+//int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam) {
+//	return aiCallback-&gt;SendUnits(unitIDs, receivingTeam);
+//}
+//
+//void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
+//	return aiCallback-&gt;CreateSharedMemArea(name, size);
+//}
+//
+//void CAIAICallback::ReleasedSharedMemArea(char* name) {
+//	aiCallback-&gt;ReleasedSharedMemArea(name);
+//}
+//
+//int CAIAICallback::CreateGroup(char* dll, unsigned aiNumber) {
+//	return aiCallback-&gt;CreateGroup(dll, aiNumber);
+//}
+//
+//void CAIAICallback::EraseGroup(int groupid) {
+//	aiCallback-&gt;EraseGroup(groupid);
+//}
+//
+//bool CAIAICallback::AddUnitToGroup(int unitId, int groupid) {
+//	return aiCallback-&gt;AddUnitToGroup(unitId, groupid);
+//}
+//
+//bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
+//	return aiCallback-&gt;RemoveUnitFromGroup(unitId);
+//}
+//
+//int CAIAICallback::GiveGroupOrder(int unitId, Command* c) {
+//	return aiCallback-&gt;GiveGroupOrder(unitId, c);
+//}
+//
+//int CAIAICallback::GiveOrder(int unitId, Command* c) {
+//	return aiCallback-&gt;GiveOrder(unitId, c);
+//}
+//
+//int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;InitPath(start, end, pathType);
+//}
+//
+//float3 CAIAICallback::GetNextWaypoint(int pathId) {
+//	return aiCallback-&gt;GetNextWaypoint(pathId);
+//}
+//
+//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;GetPathLength(start, end, pathType);
+//}
+//
+//void CAIAICallback::FreePath(int pathid) {
+//	aiCallback-&gt;FreePath(pathid);
+//}
+//
+//void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
+//	aiCallback-&gt;LineDrawerStartPath(pos, color);
+//}
+//
+//void CAIAICallback::LineDrawerFinishPath() {
+//	aiCallback-&gt;LineDrawerFinishPath();
+//}
+//
+//void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerDrawLine(endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerDrawLineAndIcon(cmdID, endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdID) {
+//	aiCallback-&gt;LineDrawerDrawIconAtLastPos(cmdID);
+//}
+//
+//void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerBreak(endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerRestart() {
+//	aiCallback-&gt;LineDrawerRestart();
+//}
+//
+//void CAIAICallback::LineDrawerRestartSameColor() {
+//	aiCallback-&gt;LineDrawerRestartSameColor();
+//}
+//
+//int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group) {
+//	return aiCallback-&gt;CreateSplineFigure(pos1, pos2, pos3, pos4, width, arrow, lifetime, group);
+//}
+//
+//int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group) {
+//	return aiCallback-&gt;CreateLineFigure(pos1, pos2, width, arrow, lifetime, group);
+//}
+//
+//void CAIAICallback::SetFigureColor(int group, float red, float green, float blue, float alpha) {
+//	aiCallback-&gt;SetFigureColor(group, red, green, blue, alpha);
+//}
+//
+//void CAIAICallback::DeleteFigureGroup(int group) {
+//	aiCallback-&gt;DeleteFigureGroup(group);
+//}
+//
+//void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
+//	aiCallback-&gt;DrawUnit(name, pos, rotation, lifetime, team, transparent, drawBorder, facing);
+//}
+//
+//int CAIAICallback::HandleCommand(int commandId, void* data) {
+//	return aiCallback-&gt;HandleCommand(commandId, data);
+//}
+//
+//bool CAIAICallback::ReadFile(const char* name, void* buffer, int bufferLen) {
+//	return aiCallback-&gt;ReadFile(name, buffer, bufferLen);
+//}
+//
+//const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
+//	return aiCallback-&gt;CallLuaRules(data, inSize, outSize);
+//}
+// ################################ &lt;- OLD impl ################################
+
+
+
+
+// ################################ NEW impl -&gt; ################################
+bool CAIAICallback::PosInCamera(float3 pos, float radius) {
+	return sAICallback-&gt;Map_isPosInCamera(teamId, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetCurrentFrame() {
+	return sAICallback-&gt;Game_getCurrentFrame(teamId);
+}
+
+int CAIAICallback::GetMyTeam() {
+	return sAICallback-&gt;Game_getMyTeam(teamId);
+}
+
+int CAIAICallback::GetMyAllyTeam() {
+	return sAICallback-&gt;Game_getMyAllyTeam(teamId);
+}
+
+int CAIAICallback::GetPlayerTeam(int player) {
+	return sAICallback-&gt;Game_getPlayerTeam(teamId, player);
+}
+
+const char* CAIAICallback::GetTeamSide(int team) {
+	return sAICallback-&gt;Game_getTeamSide(teamId, team);
+}
+
+int CAIAICallback::GetUnitGroup(int unitId) {
+	return sAICallback-&gt;Unit_getGroup(teamId, unitId);
+}
+
+
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
+	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
+int ids[numCmds];
+const char* names[numCmds];
+const char* toolTips[numCmds];
+bool showUniques[numCmds];
+bool disableds[numCmds];
+int numParams[numCmds];
+const char** params[numCmds];
+sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
+sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
+sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
+sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
+sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
+sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
+for (int c=0; c &lt; numCmds; c++) {
+	params[c] = new const char*[numParams[c]];
+}
+sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, params);
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[c][p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+	
+	// to prevent memory wholes
+	if (groupPossibleCommands[groupId] != NULL) {
+		delete groupPossibleCommands[groupId];
+	}
+	groupPossibleCommands[groupId] = cmdDescVec;
+	
+	return cmdDescVec;
+}
+
+
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+	int numCmds = sAICallback-&gt;Unit_getNumSupportedCommands(teamId, unitId);
+int* ids = new int[numCmds];
+const char* names[numCmds];
+const char* toolTips[numCmds];
+bool showUniques[numCmds];
+bool disableds[numCmds];
+int numParams[numCmds];
+const char** params[numCmds];
+sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
+sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
+sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
+sAICallback-&gt;Unit_SupportedCommands_isShowUnique(teamId, unitId, showUniques);
+sAICallback-&gt;Unit_SupportedCommands_isDisabled(teamId, unitId, disableds);
+sAICallback-&gt;Unit_SupportedCommands_getNumParams(teamId, unitId, numParams);
+for (int c=0; c &lt; numCmds; c++) {
+	params[c] = new const char*[numParams[c]];
+}
+sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, params);
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[c][p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+	
+	// to prevent memory wholes
+	if (unitPossibleCommands[unitId] != NULL) {
+		delete unitPossibleCommands[unitId];
+	}
+	unitPossibleCommands[unitId] = cmdDescVec;
+	
+	return cmdDescVec;
+}
+
+const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+	int numCmds = sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+int ids[numCmds];
+unsigned char options[numCmds];
+unsigned int tags[numCmds];
+int timeOuts[numCmds];
+int numParams[numCmds];
+float* params[numCmds];
+sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+sAICallback-&gt;Unit_CurrentCommands_getIds(teamId, unitId, ids);
+sAICallback-&gt;Unit_CurrentCommands_getOptions(teamId, unitId, options);
+sAICallback-&gt;Unit_CurrentCommands_getTag(teamId, unitId, tags);
+sAICallback-&gt;Unit_CurrentCommands_getTimeOut(teamId, unitId, timeOuts);
+sAICallback-&gt;Unit_CurrentCommands_getNumParams(teamId, unitId, numParams);
+for (int c=0; c &lt; numCmds; c++) {
+	params[c] = new float[numParams[c]];
+}	
+sAICallback-&gt;Unit_CurrentCommands_getParams(teamId, unitId, params);
+	CCommandQueue* cc = new CCommandQueue();
+	for (int c=0; c &lt; numCmds; c++) {
+		Command command;
+		command.id = ids[c];
+		command.options = options[c];
+		command.tag = tags[c];
+		command.timeOut = timeOuts[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			command.params.push_back(params[c][p]);
+		}
+		cc-&gt;push_back(command);
+	}
+	
+	// to prevent memory wholes
+	if (unitCurrentCommandQueues[unitId] != NULL) {
+		delete unitCurrentCommandQueues[unitId];
+	}
+	unitCurrentCommandQueues[unitId] = cc;
+	
+	return cc;
+}
+
+int CAIAICallback::GetUnitAiHint(int unitId) {
+	return sAICallback-&gt;Unit_getAiHint(teamId, unitId);
+}
+
+int CAIAICallback::GetUnitTeam(int unitId) {
+	return sAICallback-&gt;Unit_getTeam(teamId, unitId);
+}
+
+int CAIAICallback::GetUnitAllyTeam(int unitId) {
+	return sAICallback-&gt;Unit_getAllyTeam(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitHealth(int unitId) {
+	return sAICallback-&gt;Unit_getHealth(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitMaxHealth(int unitId) {
+	return sAICallback-&gt;Unit_getMaxHealth(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitSpeed(int unitId) {
+	return sAICallback-&gt;Unit_getSpeed(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitPower(int unitId) {
+	return sAICallback-&gt;Unit_getPower(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitExperience(int unitId) {
+	return sAICallback-&gt;Unit_getExperience(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitMaxRange(int unitId) {
+	return sAICallback-&gt;Unit_getMaxRange(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitActivated(int unitId) {
+	return sAICallback-&gt;Unit_isActivated(teamId, unitId);
+}
+
+bool CAIAICallback::UnitBeingBuilt(int unitId) {
+	return sAICallback-&gt;Unit_isBeingBuilt(teamId, unitId);
+}
+
+const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
+	int unitDefId = sAICallback-&gt;Unit_getDefId(teamId, unitId);
+	return this-&gt;GetUnitDefById(unitDefId);
+}
+
+float3 CAIAICallback::GetUnitPos(int unitId) {
+	return float3(sAICallback-&gt;Unit_getPos(teamId, unitId));
+}
+
+int CAIAICallback::GetBuildingFacing(int unitId) {
+	return sAICallback-&gt;Unit_getBuildingFacing(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitCloaked(int unitId) {
+	return sAICallback-&gt;Unit_isCloaked(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitParalyzed(int unitId) {
+	return sAICallback-&gt;Unit_isParalyzed(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitNeutral(int unitId) {
+	return sAICallback-&gt;Unit_isNeutral(teamId, unitId);
+}
+
+bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+	resourceInfo-&gt;energyMake = sAICallback-&gt;Unit_ResourceInfo_Energy_getMake(teamId, unitId);
+	if (resourceInfo-&gt;energyMake &lt; 0) return false;
+	resourceInfo-&gt;energyUse = sAICallback-&gt;Unit_ResourceInfo_Energy_getUse(teamId, unitId);
+	resourceInfo-&gt;metalMake = sAICallback-&gt;Unit_ResourceInfo_Metal_getMake(teamId, unitId);
+	resourceInfo-&gt;metalUse = sAICallback-&gt;Unit_ResourceInfo_Metal_getUse(teamId, unitId);
+	return true;
+}
+
+const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
+	int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitName);
+	return this-&gt;GetUnitDefById(unitDefId);
+}
+
+
+const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
+	//logT(&quot;entering: GetUnitDefById sAICallback&quot;);
+	
+	if (unitDefId &lt; 0) {
+		return NULL;
+	}
+	
+	bool doRecreate = unitDefFrames[unitDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+	UnitDef* unitDef = new UnitDef();
+unitDef-&gt;valid = sAICallback-&gt;UnitDef_isValid(teamId, unitDefId);
+unitDef-&gt;name = sAICallback-&gt;UnitDef_getName(teamId, unitDefId);
+unitDef-&gt;humanName = sAICallback-&gt;UnitDef_getHumanName(teamId, unitDefId);
+unitDef-&gt;filename = sAICallback-&gt;UnitDef_getFilename(teamId, unitDefId);
+unitDef-&gt;id = sAICallback-&gt;UnitDef_getId(teamId, unitDefId);
+unitDef-&gt;aihint = sAICallback-&gt;UnitDef_getAiHint(teamId, unitDefId);
+unitDef-&gt;cobID = sAICallback-&gt;UnitDef_getCobID(teamId, unitDefId);
+unitDef-&gt;techLevel = sAICallback-&gt;UnitDef_getTechLevel(teamId, unitDefId);
+unitDef-&gt;gaia = sAICallback-&gt;UnitDef_getGaia(teamId, unitDefId);
+unitDef-&gt;metalUpkeep = sAICallback-&gt;UnitDef_getMetalUpkeep(teamId, unitDefId);
+unitDef-&gt;energyUpkeep = sAICallback-&gt;UnitDef_getEnergyUpkeep(teamId, unitDefId);
+unitDef-&gt;metalMake = sAICallback-&gt;UnitDef_getMetalMake(teamId, unitDefId);
+unitDef-&gt;makesMetal = sAICallback-&gt;UnitDef_getMakesMetal(teamId, unitDefId);
+unitDef-&gt;energyMake = sAICallback-&gt;UnitDef_getEnergyMake(teamId, unitDefId);
+unitDef-&gt;metalCost = sAICallback-&gt;UnitDef_getMetalCost(teamId, unitDefId);
+unitDef-&gt;energyCost = sAICallback-&gt;UnitDef_getEnergyCost(teamId, unitDefId);
+unitDef-&gt;buildTime = sAICallback-&gt;UnitDef_getBuildTime(teamId, unitDefId);
+unitDef-&gt;extractsMetal = sAICallback-&gt;UnitDef_getExtractsMetal(teamId, unitDefId);
+unitDef-&gt;extractRange = sAICallback-&gt;UnitDef_getExtractRange(teamId, unitDefId);
+unitDef-&gt;windGenerator = sAICallback-&gt;UnitDef_getWindGenerator(teamId, unitDefId);
+unitDef-&gt;tidalGenerator = sAICallback-&gt;UnitDef_getTidalGenerator(teamId, unitDefId);
+unitDef-&gt;metalStorage = sAICallback-&gt;UnitDef_getMetalStorage(teamId, unitDefId);
+unitDef-&gt;energyStorage = sAICallback-&gt;UnitDef_getEnergyStorage(teamId, unitDefId);
+unitDef-&gt;autoHeal = sAICallback-&gt;UnitDef_getAutoHeal(teamId, unitDefId);
+unitDef-&gt;idleAutoHeal = sAICallback-&gt;UnitDef_getIdleAutoHeal(teamId, unitDefId);
+unitDef-&gt;idleTime = sAICallback-&gt;UnitDef_getIdleTime(teamId, unitDefId);
+unitDef-&gt;power = sAICallback-&gt;UnitDef_getPower(teamId, unitDefId);
+unitDef-&gt;health = sAICallback-&gt;UnitDef_getHealth(teamId, unitDefId);
+unitDef-&gt;category = sAICallback-&gt;UnitDef_getCategory(teamId, unitDefId);
+unitDef-&gt;speed = sAICallback-&gt;UnitDef_getSpeed(teamId, unitDefId);
+unitDef-&gt;turnRate = sAICallback-&gt;UnitDef_getTurnRate(teamId, unitDefId);
+unitDef-&gt;moveType = sAICallback-&gt;UnitDef_getMoveType(teamId, unitDefId);
+unitDef-&gt;upright = sAICallback-&gt;UnitDef_isUpright(teamId, unitDefId);
+unitDef-&gt;collide = sAICallback-&gt;UnitDef_isCollide(teamId, unitDefId);
+unitDef-&gt;controlRadius = sAICallback-&gt;UnitDef_getControlRadius(teamId, unitDefId);
+unitDef-&gt;losRadius = sAICallback-&gt;UnitDef_getLosRadius(teamId, unitDefId);
+unitDef-&gt;airLosRadius = sAICallback-&gt;UnitDef_getAirLosRadius(teamId, unitDefId);
+unitDef-&gt;losHeight = sAICallback-&gt;UnitDef_getLosHeight(teamId, unitDefId);
+unitDef-&gt;radarRadius = sAICallback-&gt;UnitDef_getRadarRadius(teamId, unitDefId);
+unitDef-&gt;sonarRadius = sAICallback-&gt;UnitDef_getSonarRadius(teamId, unitDefId);
+unitDef-&gt;jammerRadius = sAICallback-&gt;UnitDef_getJammerRadius(teamId, unitDefId);
+unitDef-&gt;sonarJamRadius = sAICallback-&gt;UnitDef_getSonarJamRadius(teamId, unitDefId);
+unitDef-&gt;seismicRadius = sAICallback-&gt;UnitDef_getSeismicRadius(teamId, unitDefId);
+unitDef-&gt;seismicSignature = sAICallback-&gt;UnitDef_getSeismicSignature(teamId, unitDefId);
+unitDef-&gt;stealth = sAICallback-&gt;UnitDef_isStealth(teamId, unitDefId);
+unitDef-&gt;sonarStealth = sAICallback-&gt;UnitDef_isSonarStealth(teamId, unitDefId);
+unitDef-&gt;buildRange3D = sAICallback-&gt;UnitDef_isBuildRange3D(teamId, unitDefId);
+unitDef-&gt;buildDistance = sAICallback-&gt;UnitDef_getBuildDistance(teamId, unitDefId);
+unitDef-&gt;buildSpeed = sAICallback-&gt;UnitDef_getBuildSpeed(teamId, unitDefId);
+unitDef-&gt;reclaimSpeed = sAICallback-&gt;UnitDef_getReclaimSpeed(teamId, unitDefId);
+unitDef-&gt;repairSpeed = sAICallback-&gt;UnitDef_getRepairSpeed(teamId, unitDefId);
+unitDef-&gt;maxRepairSpeed = sAICallback-&gt;UnitDef_getMaxRepairSpeed(teamId, unitDefId);
+unitDef-&gt;resurrectSpeed = sAICallback-&gt;UnitDef_getResurrectSpeed(teamId, unitDefId);
+unitDef-&gt;captureSpeed = sAICallback-&gt;UnitDef_getCaptureSpeed(teamId, unitDefId);
+unitDef-&gt;terraformSpeed = sAICallback-&gt;UnitDef_getTerraformSpeed(teamId, unitDefId);
+unitDef-&gt;mass = sAICallback-&gt;UnitDef_getMass(teamId, unitDefId);
+unitDef-&gt;pushResistant = sAICallback-&gt;UnitDef_isPushResistant(teamId, unitDefId);
+unitDef-&gt;strafeToAttack = sAICallback-&gt;UnitDef_isStrafeToAttack(teamId, unitDefId);
+unitDef-&gt;minCollisionSpeed = sAICallback-&gt;UnitDef_getMinCollisionSpeed(teamId, unitDefId);
+unitDef-&gt;slideTolerance = sAICallback-&gt;UnitDef_getSlideTolerance(teamId, unitDefId);
+unitDef-&gt;maxSlope = sAICallback-&gt;UnitDef_getMaxSlope(teamId, unitDefId);
+unitDef-&gt;maxHeightDif = sAICallback-&gt;UnitDef_getMaxHeightDif(teamId, unitDefId);
+unitDef-&gt;minWaterDepth = sAICallback-&gt;UnitDef_getMinWaterDepth(teamId, unitDefId);
+unitDef-&gt;waterline = sAICallback-&gt;UnitDef_getWaterline(teamId, unitDefId);
+unitDef-&gt;maxWaterDepth = sAICallback-&gt;UnitDef_getMaxWaterDepth(teamId, unitDefId);
+unitDef-&gt;armoredMultiple = sAICallback-&gt;UnitDef_getArmoredMultiple(teamId, unitDefId);
+unitDef-&gt;armorType = sAICallback-&gt;UnitDef_getArmorType(teamId, unitDefId);
+unitDef-&gt;flankingBonusMode = sAICallback-&gt;UnitDef_getFlankingBonusMode(teamId, unitDefId);
+unitDef-&gt;flankingBonusDir = float3(sAICallback-&gt;UnitDef_getFlankingBonusDir(teamId, unitDefId));
+unitDef-&gt;flankingBonusMax = sAICallback-&gt;UnitDef_getFlankingBonusMax(teamId, unitDefId);
+unitDef-&gt;flankingBonusMin = sAICallback-&gt;UnitDef_getFlankingBonusMin(teamId, unitDefId);
+unitDef-&gt;flankingBonusMobilityAdd = sAICallback-&gt;UnitDef_getFlankingBonusMobilityAdd(teamId, unitDefId);
+unitDef-&gt;collisionVolumeType = sAICallback-&gt;UnitDef_getCollisionVolumeType(teamId, unitDefId);
+unitDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;UnitDef_getCollisionVolumeScales(teamId, unitDefId));
+unitDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;UnitDef_getCollisionVolumeOffsets(teamId, unitDefId));
+unitDef-&gt;collisionVolumeTest = sAICallback-&gt;UnitDef_getCollisionVolumeTest(teamId, unitDefId);
+unitDef-&gt;maxWeaponRange = sAICallback-&gt;UnitDef_getMaxWeaponRange(teamId, unitDefId);
+unitDef-&gt;type = sAICallback-&gt;UnitDef_getType(teamId, unitDefId);
+unitDef-&gt;tooltip = sAICallback-&gt;UnitDef_getTooltip(teamId, unitDefId);
+unitDef-&gt;wreckName = sAICallback-&gt;UnitDef_getWreckName(teamId, unitDefId);
+unitDef-&gt;deathExplosion = sAICallback-&gt;UnitDef_getDeathExplosion(teamId, unitDefId);
+unitDef-&gt;selfDExplosion = sAICallback-&gt;UnitDef_getSelfDExplosion(teamId, unitDefId);
+unitDef-&gt;TEDClassString = sAICallback-&gt;UnitDef_getTedClassString(teamId, unitDefId);
+unitDef-&gt;categoryString = sAICallback-&gt;UnitDef_getCategoryString(teamId, unitDefId);
+unitDef-&gt;canSelfD = sAICallback-&gt;UnitDef_isCanSelfD(teamId, unitDefId);
+unitDef-&gt;selfDCountdown = sAICallback-&gt;UnitDef_getSelfDCountdown(teamId, unitDefId);
+unitDef-&gt;canSubmerge = sAICallback-&gt;UnitDef_isCanSubmerge(teamId, unitDefId);
+unitDef-&gt;canfly = sAICallback-&gt;UnitDef_isCanFly(teamId, unitDefId);
+unitDef-&gt;canmove = sAICallback-&gt;UnitDef_isCanMove(teamId, unitDefId);
+unitDef-&gt;canhover = sAICallback-&gt;UnitDef_isCanHover(teamId, unitDefId);
+unitDef-&gt;floater = sAICallback-&gt;UnitDef_isFloater(teamId, unitDefId);
+unitDef-&gt;builder = sAICallback-&gt;UnitDef_isBuilder(teamId, unitDefId);
+unitDef-&gt;activateWhenBuilt = sAICallback-&gt;UnitDef_isActivateWhenBuilt(teamId, unitDefId);
+unitDef-&gt;onoffable = sAICallback-&gt;UnitDef_isOnOffable(teamId, unitDefId);
+unitDef-&gt;fullHealthFactory = sAICallback-&gt;UnitDef_isFullHealthFactory(teamId, unitDefId);
+unitDef-&gt;factoryHeadingTakeoff = sAICallback-&gt;UnitDef_isFactoryHeadingTakeoff(teamId, unitDefId);
+unitDef-&gt;reclaimable = sAICallback-&gt;UnitDef_isReclaimable(teamId, unitDefId);
+unitDef-&gt;capturable = sAICallback-&gt;UnitDef_isCapturable(teamId, unitDefId);
+unitDef-&gt;canRestore = sAICallback-&gt;UnitDef_isCanRestore(teamId, unitDefId);
+unitDef-&gt;canRepair = sAICallback-&gt;UnitDef_isCanRepair(teamId, unitDefId);
+unitDef-&gt;canSelfRepair = sAICallback-&gt;UnitDef_isCanSelfRepair(teamId, unitDefId);
+unitDef-&gt;canReclaim = sAICallback-&gt;UnitDef_isCanReclaim(teamId, unitDefId);
+unitDef-&gt;canAttack = sAICallback-&gt;UnitDef_isCanAttack(teamId, unitDefId);
+unitDef-&gt;canPatrol = sAICallback-&gt;UnitDef_isCanPatrol(teamId, unitDefId);
+unitDef-&gt;canFight = sAICallback-&gt;UnitDef_isCanFight(teamId, unitDefId);
+unitDef-&gt;canGuard = sAICallback-&gt;UnitDef_isCanGuard(teamId, unitDefId);
+unitDef-&gt;canBuild = sAICallback-&gt;UnitDef_isCanBuild(teamId, unitDefId);
+unitDef-&gt;canAssist = sAICallback-&gt;UnitDef_isCanAssist(teamId, unitDefId);
+unitDef-&gt;canBeAssisted = sAICallback-&gt;UnitDef_isCanBeAssisted(teamId, unitDefId);
+unitDef-&gt;canRepeat = sAICallback-&gt;UnitDef_isCanRepeat(teamId, unitDefId);
+unitDef-&gt;canFireControl = sAICallback-&gt;UnitDef_isCanFireControl(teamId, unitDefId);
+unitDef-&gt;fireState = sAICallback-&gt;UnitDef_getFireState(teamId, unitDefId);
+unitDef-&gt;moveState = sAICallback-&gt;UnitDef_getMoveState(teamId, unitDefId);
+unitDef-&gt;wingDrag = sAICallback-&gt;UnitDef_getWingDrag(teamId, unitDefId);
+unitDef-&gt;wingAngle = sAICallback-&gt;UnitDef_getWingAngle(teamId, unitDefId);
+unitDef-&gt;drag = sAICallback-&gt;UnitDef_getDrag(teamId, unitDefId);
+unitDef-&gt;frontToSpeed = sAICallback-&gt;UnitDef_getFrontToSpeed(teamId, unitDefId);
+unitDef-&gt;speedToFront = sAICallback-&gt;UnitDef_getSpeedToFront(teamId, unitDefId);
+unitDef-&gt;myGravity = sAICallback-&gt;UnitDef_getMyGravity(teamId, unitDefId);
+unitDef-&gt;maxBank = sAICallback-&gt;UnitDef_getMaxBank(teamId, unitDefId);
+unitDef-&gt;maxPitch = sAICallback-&gt;UnitDef_getMaxPitch(teamId, unitDefId);
+unitDef-&gt;turnRadius = sAICallback-&gt;UnitDef_getTurnRadius(teamId, unitDefId);
+unitDef-&gt;wantedHeight = sAICallback-&gt;UnitDef_getWantedHeight(teamId, unitDefId);
+unitDef-&gt;verticalSpeed = sAICallback-&gt;UnitDef_getVerticalSpeed(teamId, unitDefId);
+unitDef-&gt;canCrash = sAICallback-&gt;UnitDef_isCanCrash(teamId, unitDefId);
+unitDef-&gt;hoverAttack = sAICallback-&gt;UnitDef_isHoverAttack(teamId, unitDefId);
+unitDef-&gt;airStrafe = sAICallback-&gt;UnitDef_isAirStrafe(teamId, unitDefId);
+unitDef-&gt;dlHoverFactor = sAICallback-&gt;UnitDef_getDlHoverFactor(teamId, unitDefId);
+unitDef-&gt;maxAcc = sAICallback-&gt;UnitDef_getMaxAcceleration(teamId, unitDefId);
+unitDef-&gt;maxDec = sAICallback-&gt;UnitDef_getMaxDeceleration(teamId, unitDefId);
+unitDef-&gt;maxAileron = sAICallback-&gt;UnitDef_getMaxAileron(teamId, unitDefId);
+unitDef-&gt;maxElevator = sAICallback-&gt;UnitDef_getMaxElevator(teamId, unitDefId);
+unitDef-&gt;maxRudder = sAICallback-&gt;UnitDef_getMaxRudder(teamId, unitDefId);
+//unitDef-&gt;yardmaps = sAICallback-&gt;UnitDef_getYardMaps(teamId, unitDefId);
+unitDef-&gt;xsize = sAICallback-&gt;UnitDef_getXSize(teamId, unitDefId);
+unitDef-&gt;ysize = sAICallback-&gt;UnitDef_getYSize(teamId, unitDefId);
+unitDef-&gt;buildangle = sAICallback-&gt;UnitDef_getBuildAngle(teamId, unitDefId);
+unitDef-&gt;loadingRadius = sAICallback-&gt;UnitDef_getLoadingRadius(teamId, unitDefId);
+unitDef-&gt;unloadSpread = sAICallback-&gt;UnitDef_getUnloadSpread(teamId, unitDefId);
+unitDef-&gt;transportCapacity = sAICallback-&gt;UnitDef_getTransportCapacity(teamId, unitDefId);
+unitDef-&gt;transportSize = sAICallback-&gt;UnitDef_getTransportSize(teamId, unitDefId);
+unitDef-&gt;minTransportSize = sAICallback-&gt;UnitDef_getMinTransportSize(teamId, unitDefId);
+unitDef-&gt;isAirBase = sAICallback-&gt;UnitDef_isAirBase(teamId, unitDefId);
+unitDef-&gt;transportMass = sAICallback-&gt;UnitDef_getTransportMass(teamId, unitDefId);
+unitDef-&gt;minTransportMass = sAICallback-&gt;UnitDef_getMinTransportMass(teamId, unitDefId);
+unitDef-&gt;holdSteady = sAICallback-&gt;UnitDef_isHoldSteady(teamId, unitDefId);
+unitDef-&gt;releaseHeld = sAICallback-&gt;UnitDef_isReleaseHeld(teamId, unitDefId);
+unitDef-&gt;cantBeTransported = sAICallback-&gt;UnitDef_isCantBeTransported(teamId, unitDefId);
+unitDef-&gt;transportByEnemy = sAICallback-&gt;UnitDef_isTransportByEnemy(teamId, unitDefId);
+unitDef-&gt;transportUnloadMethod = sAICallback-&gt;UnitDef_getTransportUnloadMethod(teamId, unitDefId);
+unitDef-&gt;fallSpeed = sAICallback-&gt;UnitDef_getFallSpeed(teamId, unitDefId);
+unitDef-&gt;unitFallSpeed = sAICallback-&gt;UnitDef_getUnitFallSpeed(teamId, unitDefId);
+unitDef-&gt;canCloak = sAICallback-&gt;UnitDef_isCanCloak(teamId, unitDefId);
+unitDef-&gt;startCloaked = sAICallback-&gt;UnitDef_isStartCloaked(teamId, unitDefId);
+unitDef-&gt;cloakCost = sAICallback-&gt;UnitDef_getCloakCost(teamId, unitDefId);
+unitDef-&gt;cloakCostMoving = sAICallback-&gt;UnitDef_getCloakCostMoving(teamId, unitDefId);
+unitDef-&gt;decloakDistance = sAICallback-&gt;UnitDef_getDecloakDistance(teamId, unitDefId);
+unitDef-&gt;decloakSpherical = sAICallback-&gt;UnitDef_isDecloakSpherical(teamId, unitDefId);
+unitDef-&gt;decloakOnFire = sAICallback-&gt;UnitDef_isDecloakOnFire(teamId, unitDefId);
+unitDef-&gt;canKamikaze = sAICallback-&gt;UnitDef_isCanKamikaze(teamId, unitDefId);
+unitDef-&gt;kamikazeDist = sAICallback-&gt;UnitDef_getKamikazeDist(teamId, unitDefId);
+unitDef-&gt;targfac = sAICallback-&gt;UnitDef_isTargetingFacility(teamId, unitDefId);
+unitDef-&gt;canDGun = sAICallback-&gt;UnitDef_isCanDGun(teamId, unitDefId);
+unitDef-&gt;needGeo = sAICallback-&gt;UnitDef_isNeedGeo(teamId, unitDefId);
+unitDef-&gt;isFeature = sAICallback-&gt;UnitDef_isFeature(teamId, unitDefId);
+unitDef-&gt;hideDamage = sAICallback-&gt;UnitDef_isHideDamage(teamId, unitDefId);
+unitDef-&gt;isCommander = sAICallback-&gt;UnitDef_isCommander(teamId, unitDefId);
+unitDef-&gt;showPlayerName = sAICallback-&gt;UnitDef_isShowPlayerName(teamId, unitDefId);
+unitDef-&gt;canResurrect = sAICallback-&gt;UnitDef_isCanResurrect(teamId, unitDefId);
+unitDef-&gt;canCapture = sAICallback-&gt;UnitDef_isCanCapture(teamId, unitDefId);
+unitDef-&gt;highTrajectoryType = sAICallback-&gt;UnitDef_getHighTrajectoryType(teamId, unitDefId);
+unitDef-&gt;noChaseCategory = sAICallback-&gt;UnitDef_getNoChaseCategory(teamId, unitDefId);
+unitDef-&gt;leaveTracks = sAICallback-&gt;UnitDef_isLeaveTracks(teamId, unitDefId);
+unitDef-&gt;trackWidth = sAICallback-&gt;UnitDef_getTrackWidth(teamId, unitDefId);
+unitDef-&gt;trackOffset = sAICallback-&gt;UnitDef_getTrackOffset(teamId, unitDefId);
+unitDef-&gt;trackStrength = sAICallback-&gt;UnitDef_getTrackStrength(teamId, unitDefId);
+unitDef-&gt;trackStretch = sAICallback-&gt;UnitDef_getTrackStretch(teamId, unitDefId);
+unitDef-&gt;trackType = sAICallback-&gt;UnitDef_getTrackType(teamId, unitDefId);
+unitDef-&gt;canDropFlare = sAICallback-&gt;UnitDef_isCanDropFlare(teamId, unitDefId);
+unitDef-&gt;flareReloadTime = sAICallback-&gt;UnitDef_getFlareReloadTime(teamId, unitDefId);
+unitDef-&gt;flareEfficiency = sAICallback-&gt;UnitDef_getFlareEfficiency(teamId, unitDefId);
+unitDef-&gt;flareDelay = sAICallback-&gt;UnitDef_getFlareDelay(teamId, unitDefId);
+unitDef-&gt;flareDropVector = float3(sAICallback-&gt;UnitDef_getFlareDropVector(teamId, unitDefId));
+unitDef-&gt;flareTime = sAICallback-&gt;UnitDef_getFlareTime(teamId, unitDefId);
+unitDef-&gt;flareSalvoSize = sAICallback-&gt;UnitDef_getFlareSalvoSize(teamId, unitDefId);
+unitDef-&gt;flareSalvoDelay = sAICallback-&gt;UnitDef_getFlareSalvoDelay(teamId, unitDefId);
+unitDef-&gt;smoothAnim = sAICallback-&gt;UnitDef_isSmoothAnim(teamId, unitDefId);
+unitDef-&gt;isMetalMaker = sAICallback-&gt;UnitDef_isMetalMaker(teamId, unitDefId);
+unitDef-&gt;canLoopbackAttack = sAICallback-&gt;UnitDef_isCanLoopbackAttack(teamId, unitDefId);
+unitDef-&gt;levelGround = sAICallback-&gt;UnitDef_isLevelGround(teamId, unitDefId);
+unitDef-&gt;useBuildingGroundDecal = sAICallback-&gt;UnitDef_isUseBuildingGroundDecal(teamId, unitDefId);
+unitDef-&gt;buildingDecalType = sAICallback-&gt;UnitDef_getBuildingDecalType(teamId, unitDefId);
+unitDef-&gt;buildingDecalSizeX = sAICallback-&gt;UnitDef_getBuildingDecalSizeX(teamId, unitDefId);
+unitDef-&gt;buildingDecalSizeY = sAICallback-&gt;UnitDef_getBuildingDecalSizeY(teamId, unitDefId);
+unitDef-&gt;buildingDecalDecaySpeed = sAICallback-&gt;UnitDef_getBuildingDecalDecaySpeed(teamId, unitDefId);
+unitDef-&gt;isFirePlatform = sAICallback-&gt;UnitDef_isFirePlatform(teamId, unitDefId);
+unitDef-&gt;maxFuel = sAICallback-&gt;UnitDef_getMaxFuel(teamId, unitDefId);
+unitDef-&gt;refuelTime = sAICallback-&gt;UnitDef_getRefuelTime(teamId, unitDefId);
+unitDef-&gt;minAirBasePower = sAICallback-&gt;UnitDef_getMinAirBasePower(teamId, unitDefId);
+unitDef-&gt;maxThisUnit = sAICallback-&gt;UnitDef_getMaxThisUnit(teamId, unitDefId);
+//unitDef-&gt;decoyDef = sAICallback-&gt;UnitDef_getDecoyDefId(teamId, unitDefId);
+unitDef-&gt;shieldWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getShieldWeaponDefId(teamId, unitDefId));
+unitDef-&gt;stockpileWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getStockpileWeaponDefId(teamId, unitDefId));
+{
+	int numBo = sAICallback-&gt;UnitDef_getNumBuildOptions(teamId, unitDefId);
+	int* bo = new int[numBo];
+	sAICallback-&gt;UnitDef_getBuildOptions(teamId, unitDefId, bo);
+	for (int b=0; b &lt; numBo; b++) {
+		unitDef-&gt;buildOptions[b] = sAICallback-&gt;UnitDef_getName(teamId, bo[b]);
+	}
+	delete [] bo;
+}
+{
+	int size = sAICallback-&gt;UnitDef_getNumCustomParams(teamId, unitDefId);
+	const char* cMap[size][2];
+	sAICallback-&gt;UnitDef_getCustomParams(teamId, unitDefId, cMap);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+		unitDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+	}
+}
+if (sAICallback-&gt;UnitDef_hasMoveData(teamId, unitDefId)) {
+	unitDef-&gt;movedata = new MoveData(NULL, -1);
+		unitDef-&gt;movedata-&gt;moveType = (enum MoveData::MoveType)sAICallback-&gt;UnitDef_MoveData_getMoveType(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;moveFamily = (enum MoveData::MoveFamily) sAICallback-&gt;UnitDef_MoveData_getMoveFamily(teamId, unitDefId);
+        unitDef-&gt;movedata-&gt;size = sAICallback-&gt;UnitDef_MoveData_getSize(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;depth = sAICallback-&gt;UnitDef_MoveData_getDepth(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxSlope = sAICallback-&gt;UnitDef_MoveData_getMaxSlope(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;slopeMod = sAICallback-&gt;UnitDef_MoveData_getSlopeMod(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;depthMod = sAICallback-&gt;UnitDef_MoveData_getDepthMod(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;pathType = sAICallback-&gt;UnitDef_MoveData_getPathType(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;crushStrength = sAICallback-&gt;UnitDef_MoveData_getCrushStrength(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxSpeed = sAICallback-&gt;UnitDef_MoveData_getMaxSpeed(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxTurnRate = sAICallback-&gt;UnitDef_MoveData_getMaxTurnRate(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxAcceleration = sAICallback-&gt;UnitDef_MoveData_getMaxAcceleration(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxBreaking = sAICallback-&gt;UnitDef_MoveData_getMaxBreaking(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;subMarine = sAICallback-&gt;UnitDef_MoveData_isSubMarine(teamId, unitDefId);
+	} else {
+		unitDef-&gt;movedata = NULL;
+	}
+int numWeapons = sAICallback-&gt;UnitDef_getNumUnitDefWeapons(teamId, unitDefId);
+for (int w=0; w &lt; numWeapons; ++w) {
+	unitDef-&gt;weapons.push_back(UnitDef::UnitDefWeapon());
+	unitDef-&gt;weapons[w].name = sAICallback-&gt;UnitDef_UnitDefWeapon_getName(teamId, unitDefId, w);
+	int weaponDefId = sAICallback-&gt;UnitDef_UnitDefWeapon_getWeaponDefId(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].def = this-&gt;GetWeaponDefById(weaponDefId);
+	unitDef-&gt;weapons[w].slavedTo = sAICallback-&gt;UnitDef_UnitDefWeapon_getSlavedTo(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].mainDir = float3(sAICallback-&gt;UnitDef_UnitDefWeapon_getMainDir(teamId, unitDefId, w));
+	unitDef-&gt;weapons[w].maxAngleDif = sAICallback-&gt;UnitDef_UnitDefWeapon_getMaxAngleDif(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].fuelUsage = sAICallback-&gt;UnitDef_UnitDefWeapon_getFuelUsage(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].badTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getBadTargetCat(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].onlyTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getOnlyTargetCat(teamId, unitDefId, w);
+}
+	if (unitDefs[unitDefId] != NULL) {
+		delete unitDefs[unitDefId];
+	}
+		unitDefs[unitDefId] = unitDef;
+		unitDefFrames[unitDefId] = currentFrame;
+	}
+
+	return unitDefs[unitDefId];
+}
+
+int CAIAICallback::GetEnemyUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getEnemies(teamId, unitIds);
+}
+
+int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getEnemiesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getEnemiesInRadarAndLos(teamId, unitIds);
+}
+
+int CAIAICallback::GetFriendlyUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getFriendlies(teamId, unitIds);
+}
+
+int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getFriendliesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetNeutralUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getNeutrals(teamId, unitIds);
+}
+
+int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getNeutralsIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetMapWidth() {
+	return sAICallback-&gt;Map_getWidth(teamId);
+}
+
+int CAIAICallback::GetMapHeight() {
+	return sAICallback-&gt;Map_getHeight(teamId);
+}
+
+const float* CAIAICallback::GetHeightMap() {
+	return sAICallback-&gt;Map_getHeightMap(teamId);
+}
+
+float CAIAICallback::GetMinHeight() {
+	return sAICallback-&gt;Map_getMinHeight(teamId);
+}
+
+float CAIAICallback::GetMaxHeight() {
+	return sAICallback-&gt;Map_getMaxHeight(teamId);
+}
+
+const float* CAIAICallback::GetSlopeMap() {
+	return sAICallback-&gt;Map_getSlopeMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetLosMap() {
+	return sAICallback-&gt;Map_getLosMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetRadarMap() {
+	return sAICallback-&gt;Map_getRadarMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetJammerMap() {
+	return sAICallback-&gt;Map_getJammerMap(teamId);
+}
+
+const unsigned char* CAIAICallback::GetMetalMap() {
+	return sAICallback-&gt;Map_getMetalMap(teamId);
+}
+
+const char* CAIAICallback::GetMapName() {
+	return sAICallback-&gt;Map_getName(teamId);
+}
+
+const char* CAIAICallback::GetModName() {
+	return sAICallback-&gt;Mod_getName(teamId);
+}
+
+float CAIAICallback::GetElevation(float x, float z) {
+	return sAICallback-&gt;Map_getElevationAt(teamId, x, z);
+}
+
+float CAIAICallback::GetMaxMetal() {
+	return sAICallback-&gt;Map_getMaxMetal(teamId);
+}
+
+float CAIAICallback::GetExtractorRadius() {
+	return sAICallback-&gt;Map_getExtractorRadius(teamId);
+}
+
+float CAIAICallback::GetMinWind() {
+	return sAICallback-&gt;Map_getMinWind(teamId);
+}
+
+float CAIAICallback::GetMaxWind() {
+	return sAICallback-&gt;Map_getMaxWind(teamId);
+}
+
+float CAIAICallback::GetTidalStrength() {
+	return sAICallback-&gt;Map_getTidalStrength(teamId);
+}
+
+float CAIAICallback::GetGravity() {
+	return sAICallback-&gt;Map_getGravity(teamId);
+}
+
+bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
+	return sAICallback-&gt;Map_canBuildAt(teamId, unitDef-&gt;id, pos.toSAIFloat3(), facing);
+}
+
+float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
+	return float3(sAICallback-&gt;Map_findClosestBuildSite(teamId, unitDef-&gt;id, pos.toSAIFloat3(), searchRadius, minDist, facing));
+}
+
+/*
+bool CAIAICallback::GetProperty(int id, int property, void* dst) {
+//	return sAICallback-&gt;getProperty(teamId, id, property, dst);
+	return false;
+}
+*/
+bool CAIAICallback::GetProperty(int unitId, int propertyId, void *data)
+{
+    switch (propertyId) {
+        case AIVAL_UNITDEF: {
+            return false;
+        }
+        case AIVAL_CURRENT_FUEL: {
+            (*(float*)data) = sAICallback-&gt;Unit_getCurrentFuel(teamId, unitId);
+            return (*(float*)data) != -1.0f;
+        }
+        case AIVAL_STOCKPILED: {
+            (*(int*)data) = sAICallback-&gt;Unit_getStockpile(teamId, unitId);
+            return (*(int*)data) != -1;
+        }
+        case AIVAL_STOCKPILE_QUED: {
+            (*(int*)data) = sAICallback-&gt;Unit_getStockpileQueued(teamId, unitId);
+            return (*(int*)data) != -1;
+        }
+        case AIVAL_UNIT_MAXSPEED: {
+            (*(float*) data) = sAICallback-&gt;Unit_getMaxSpeed(teamId, unitId);
+            return (*(float*)data) != -1.0f;
+        }
+        default:
+            return false;
+	}
+	return false;
+}
+
+/*
+bool CAIAICallback::GetValue(int valueId, void* dst) {
+//	return sAICallback-&gt;getValue(teamId, valueId, dst);
+	return false;
+}
+*/
+bool CAIAICallback::GetValue(int valueId, void *data)
+{
+	switch (valueId) {
+		case AIVAL_NUMDAMAGETYPES:{
+			*((int*)data) = sAICallback-&gt;WeaponDef_STATIC_getNumDamageTypes(teamId);
+			return true;
+		}case AIVAL_EXCEPTION_HANDLING:{
+			*(bool*)data = sAICallback-&gt;Game_isExceptionHandlingEnabled(teamId);
+			return true;
+		}case AIVAL_MAP_CHECKSUM:{
+			*(unsigned int*)data = sAICallback-&gt;Map_getChecksum(teamId);
+			return true;
+		}case AIVAL_DEBUG_MODE:{
+			*(bool*)data = sAICallback-&gt;Game_isDebugModeEnabled(teamId);
+			return true;
+		}case AIVAL_GAME_MODE:{
+			*(int*)data = sAICallback-&gt;Game_getMode(teamId);
+			return true;
+		}case AIVAL_GAME_PAUSED:{
+			*(bool*)data = sAICallback-&gt;Game_isPaused(teamId);
+			return true;
+		}case AIVAL_GAME_SPEED_FACTOR:{
+			*(float*)data = sAICallback-&gt;Game_getSpeedFactor(teamId);
+			return true;
+		}case AIVAL_GUI_VIEW_RANGE:{
+			*(float*)data = sAICallback-&gt;Gui_getViewRange(teamId);
+			return true;
+		}case AIVAL_GUI_SCREENX:{
+			*(float*)data = sAICallback-&gt;Gui_getScreenX(teamId);
+			return true;
+		}case AIVAL_GUI_SCREENY:{
+			*(float*)data = sAICallback-&gt;Gui_getScreenY(teamId);
+			return true;
+		}case AIVAL_GUI_CAMERA_DIR:{
+			*(float3*)data = sAICallback-&gt;Gui_Camera_getDirection(teamId);
+			return true;
+		}case AIVAL_GUI_CAMERA_POS:{
+			*(float3*)data = sAICallback-&gt;Gui_Camera_getPosition(teamId);
+			return true;
+		}case AIVAL_LOCATE_FILE_R:{
+            sAICallback-&gt;File_locateForReading(teamId, (char*) data);
+			return true;
+		}case AIVAL_LOCATE_FILE_W:{
+            sAICallback-&gt;File_locateForWriting(teamId, (char*) data);
+			return true;
+		}
+		case AIVAL_UNIT_LIMIT: {
+			*(int*) data = sAICallback-&gt;Unit_STATIC_getLimit(teamId);
+			return true;
+		}
+		case AIVAL_SCRIPT: {
+			*(const char**) data = sAICallback-&gt;Game_getSetupScript(teamId);
+			return true;
+		}
+		default:
+			return false;
+	}
+}
+
+int CAIAICallback::GetFileSize(const char* name) {
+	return sAICallback-&gt;File_getSize(teamId, name);
+}
+
+int CAIAICallback::GetSelectedUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getSelected(teamId, unitIds);
+}
+
+float3 CAIAICallback::GetMousePos() {
+	return float3(sAICallback-&gt;Map_getMousePos(teamId));
+}
+
+int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+	SAIFloat3* positions = new SAIFloat3[maxPoints];
+	unsigned char** colors = new unsigned char*[maxPoints];
+	const char** labels = new const char*[maxPoints];
+	int numPoints = sAICallback-&gt;Map_getPoints(teamId, positions, colors, labels, maxPoints);
+	for (int i=0; i &lt; numPoints; ++i) {
+		pm[i].pos = float3(positions[i]);
+		pm[i].color = colors[i];
+		pm[i].label = labels[i];
+	}
+	delete [] positions;
+	delete [] colors;
+	delete [] labels;
+	return numPoints;
+}
+
+int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+	SAIFloat3* firstPositions = new SAIFloat3[maxLines];
+	SAIFloat3* secondPositions = new SAIFloat3[maxLines];
+	unsigned char** colors = new unsigned char*[maxLines];
+	int numLines = sAICallback-&gt;Map_getLines(teamId, firstPositions, secondPositions, colors, maxLines);
+	for (int i=0; i &lt; numLines; ++i) {
+		lm[i].pos = float3(firstPositions[i]);
+		lm[i].pos2 = float3(secondPositions[i]);
+		lm[i].color = colors[i];
+	}
+	delete [] firstPositions;
+	delete [] secondPositions;
+	delete [] colors;
+	return numLines;
+}
+
+float CAIAICallback::GetMetal() {
+	return sAICallback-&gt;ResourceInfo_Metal_getCurrent(teamId);
+}
+
+float CAIAICallback::GetMetalIncome() {
+	return sAICallback-&gt;ResourceInfo_Metal_getIncome(teamId);
+}
+
+float CAIAICallback::GetMetalUsage() {
+	return sAICallback-&gt;ResourceInfo_Metal_getUsage(teamId);
+}
+
+float CAIAICallback::GetMetalStorage() {
+	return sAICallback-&gt;ResourceInfo_Metal_getStorage(teamId);
+}
+
+float CAIAICallback::GetEnergy() {
+	return sAICallback-&gt;ResourceInfo_Energy_getCurrent(teamId);
+}
+
+float CAIAICallback::GetEnergyIncome() {
+	return sAICallback-&gt;ResourceInfo_Energy_getIncome(teamId);
+}
+
+float CAIAICallback::GetEnergyUsage() {
+	return sAICallback-&gt;ResourceInfo_Energy_getUsage(teamId);
+}
+
+float CAIAICallback::GetEnergyStorage() {
+	return sAICallback-&gt;ResourceInfo_Energy_getStorage(teamId);
+}
+
+int CAIAICallback::GetFeatures(int *featureIds, int max) {
+	return sAICallback-&gt;Feature_STATIC_getIds(teamId, featureIds, max);
+}
+
+int CAIAICallback::GetFeatures(int *featureIds, int max, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Feature_STATIC_getIdsIn(teamId, featureIds, max, pos.toSAIFloat3(), radius);
+}
+
+const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
+	int featureDefId = sAICallback-&gt;Feature_getDefId(teamId, featureId);
+	return this-&gt;GetFeatureDefById(featureDefId);
+}
+
+const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
+	
+	if (featureDefId &lt; 0) {
+		return NULL;
+	}
+	
+	bool doRecreate = featureDefFrames[featureDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+	FeatureDef* featureDef = new FeatureDef();
+featureDef-&gt;myName = sAICallback-&gt;FeatureDef_getName(teamId, featureDefId);
+featureDef-&gt;description = sAICallback-&gt;FeatureDef_getDescription(teamId, featureDefId);
+featureDef-&gt;filename = sAICallback-&gt;FeatureDef_getFilename(teamId, featureDefId);
+featureDef-&gt;id = sAICallback-&gt;FeatureDef_getId(teamId, featureDefId);
+featureDef-&gt;metal = sAICallback-&gt;FeatureDef_getMetal(teamId, featureDefId);
+featureDef-&gt;energy = sAICallback-&gt;FeatureDef_getEnergy(teamId, featureDefId);
+featureDef-&gt;maxHealth = sAICallback-&gt;FeatureDef_getMaxHealth(teamId, featureDefId);
+featureDef-&gt;reclaimTime = sAICallback-&gt;FeatureDef_getReclaimTime(teamId, featureDefId);
+featureDef-&gt;mass = sAICallback-&gt;FeatureDef_getMass(teamId, featureDefId);
+featureDef-&gt;collisionVolumeType = sAICallback-&gt;FeatureDef_getCollisionVolumeType(teamId, featureDefId);	
+featureDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeScales(teamId, featureDefId));		
+featureDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeOffsets(teamId, featureDefId));		
+featureDef-&gt;collisionVolumeTest = sAICallback-&gt;FeatureDef_getCollisionVolumeTest(teamId, featureDefId);			
+featureDef-&gt;upright = sAICallback-&gt;FeatureDef_isUpright(teamId, featureDefId);
+featureDef-&gt;drawType = sAICallback-&gt;FeatureDef_getDrawType(teamId, featureDefId);
+featureDef-&gt;modelname = sAICallback-&gt;FeatureDef_getModelName(teamId, featureDefId);
+featureDef-&gt;modelType = sAICallback-&gt;FeatureDef_getModelType(teamId, featureDefId);
+featureDef-&gt;destructable = sAICallback-&gt;FeatureDef_isDestructable(teamId, featureDefId);
+featureDef-&gt;reclaimable = sAICallback-&gt;FeatureDef_isReclaimable(teamId, featureDefId);
+featureDef-&gt;blocking = sAICallback-&gt;FeatureDef_isBlocking(teamId, featureDefId);
+featureDef-&gt;burnable = sAICallback-&gt;FeatureDef_isBurnable(teamId, featureDefId);
+featureDef-&gt;floating = sAICallback-&gt;FeatureDef_isFloating(teamId, featureDefId);
+featureDef-&gt;noSelect = sAICallback-&gt;FeatureDef_isNoSelect(teamId, featureDefId);
+featureDef-&gt;geoThermal = sAICallback-&gt;FeatureDef_isGeoThermal(teamId, featureDefId);
+featureDef-&gt;deathFeature = sAICallback-&gt;FeatureDef_getDeathFeature(teamId, featureDefId);
+featureDef-&gt;xsize = sAICallback-&gt;FeatureDef_getXsize(teamId, featureDefId);
+featureDef-&gt;ysize = sAICallback-&gt;FeatureDef_getYsize(teamId, featureDefId);
+{
+	int size = sAICallback-&gt;FeatureDef_getNumCustomParams(teamId, featureDefId);
+	featureDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+	const char* cMap[size][2];
+	sAICallback-&gt;FeatureDef_getCustomParams(teamId, featureDefId, cMap);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+		featureDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+	}
+}
+	if (featureDefs[featureDefId] != NULL) {
+		delete featureDefs[featureDefId];
+	}
+		featureDefs[featureDefId] = featureDef;
+		featureDefFrames[featureDefId] = currentFrame;
+	}
+
+	return featureDefs[featureDefId];
+}
+
+float CAIAICallback::GetFeatureHealth(int featureId) {
+	return sAICallback-&gt;Feature_getHealth(teamId, featureId);
+}
+
+float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
+	return sAICallback-&gt;Feature_getReclaimLeft(teamId, featureId);
+}
+
+float3 CAIAICallback::GetFeaturePos(int featureId) {
+	return float3(sAICallback-&gt;Feature_getPos(teamId, featureId));
+}
+
+int CAIAICallback::GetNumUnitDefs() {
+	return sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
+}
+
+void CAIAICallback::GetUnitDefList(const UnitDef** list) {
+	int numUnitDefs = sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
+	int* unitDefIds = new int[numUnitDefs];
+	sAICallback-&gt;UnitDef_STATIC_getIds(teamId, unitDefIds);
+	for (int i=0; i &lt; numUnitDefs; ++i) {
+		list[i] = this-&gt;GetUnitDefById(unitDefIds[i]);
+	}
+}
+
+float CAIAICallback::GetUnitDefHeight(int def) {
+	return sAICallback-&gt;UnitDef_getHeight(teamId, def);
+}
+
+float CAIAICallback::GetUnitDefRadius(int def) {
+	return sAICallback-&gt;UnitDef_getRadius(teamId, def);
+}
+
+const WeaponDef* CAIAICallback::GetWeapon(const char* weaponName) {
+	int weaponDefId = sAICallback-&gt;WeaponDef_STATIC_getIdByName(teamId, weaponName);
+	return this-&gt;GetWeaponDefById(weaponDefId);
+}
+
+const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
+	
+//	logT(&quot;entering: GetWeaponDefById sAICallback&quot;);
+	if (weaponDefId &lt; 0) {
+		return NULL;
+	}
+	
+	bool doRecreate = weaponDefFrames[weaponDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+//weaponDef-&gt;damages = sAICallback-&gt;WeaponDef_getDamages(teamId, weaponDefId);
+//{
+int numTypes = sAICallback-&gt;WeaponDef_Damages_getNumTypes(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 1&quot;);
+//float* typeDamages = new float[numTypes];
+float typeDamages[numTypes];
+sAICallback-&gt;WeaponDef_Damages_getTypeDamages(teamId, weaponDefId, typeDamages);
+//	logT(&quot;GetWeaponDefById 2&quot;);
+//for(int i=0; i &lt; numTypes; ++i) {
+//	typeDamages[i] = sAICallback-&gt;WeaponDef_Damages_getType(teamId, weaponDefId, i);
+//}
+DamageArray da(numTypes, typeDamages);
+//	logT(&quot;GetWeaponDefById 3&quot;);
+//AIDamageArray tmpDa(numTypes, typeDamages);
+//AIDamageArray tmpDa;
+//weaponDef-&gt;damages = *(reinterpret_cast&lt;DamageArray*&gt;(&amp;tmpDa));
+//tmpDa.numTypes = numTypes;
+//tmpDa.damages = typeDamages;
+//delete tmpDa;
+//da.SetTypes(numTypes, typeDamages);
+//delete [] typeDamages;
+da.paralyzeDamageTime = sAICallback-&gt;WeaponDef_Damages_getParalyzeDamageTime(teamId, weaponDefId);
+da.impulseFactor = sAICallback-&gt;WeaponDef_Damages_getImpulseFactor(teamId, weaponDefId);
+da.impulseBoost = sAICallback-&gt;WeaponDef_Damages_getImpulseBoost(teamId, weaponDefId);
+da.craterMult = sAICallback-&gt;WeaponDef_Damages_getCraterMult(teamId, weaponDefId);
+da.craterBoost = sAICallback-&gt;WeaponDef_Damages_getCraterBoost(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 4&quot;);
+//}
+
+	WeaponDef* weaponDef = new WeaponDef(da);
+//	WeaponDef* weaponDef = new WeaponDef();
+//	logT(&quot;GetWeaponDefById 5&quot;);
+//	logI(&quot;GetWeaponDefById 5 defId: %d&quot;, weaponDefId);
+weaponDef-&gt;name = sAICallback-&gt;WeaponDef_getName(teamId, weaponDefId);
+weaponDef-&gt;type = sAICallback-&gt;WeaponDef_getType(teamId, weaponDefId);
+weaponDef-&gt;description = sAICallback-&gt;WeaponDef_getDescription(teamId, weaponDefId);
+weaponDef-&gt;filename = sAICallback-&gt;WeaponDef_getFilename(teamId, weaponDefId);
+weaponDef-&gt;cegTag = sAICallback-&gt;WeaponDef_getCegTag(teamId, weaponDefId);
+weaponDef-&gt;range = sAICallback-&gt;WeaponDef_getRange(teamId, weaponDefId);
+weaponDef-&gt;heightmod = sAICallback-&gt;WeaponDef_getHeightMod(teamId, weaponDefId);
+weaponDef-&gt;accuracy = sAICallback-&gt;WeaponDef_getAccuracy(teamId, weaponDefId);
+weaponDef-&gt;sprayAngle = sAICallback-&gt;WeaponDef_getSprayAngle(teamId, weaponDefId);
+weaponDef-&gt;movingAccuracy = sAICallback-&gt;WeaponDef_getMovingAccuracy(teamId, weaponDefId);
+weaponDef-&gt;targetMoveError = sAICallback-&gt;WeaponDef_getTargetMoveError(teamId, weaponDefId);
+weaponDef-&gt;leadLimit = sAICallback-&gt;WeaponDef_getLeadLimit(teamId, weaponDefId);
+weaponDef-&gt;leadBonus = sAICallback-&gt;WeaponDef_getLeadBonus(teamId, weaponDefId);
+weaponDef-&gt;predictBoost = sAICallback-&gt;WeaponDef_getPredictBoost(teamId, weaponDefId);
+weaponDef-&gt;areaOfEffect = sAICallback-&gt;WeaponDef_getAreaOfEffect(teamId, weaponDefId);
+weaponDef-&gt;noSelfDamage = sAICallback-&gt;WeaponDef_isNoSelfDamage(teamId, weaponDefId);
+weaponDef-&gt;fireStarter = sAICallback-&gt;WeaponDef_getFireStarter(teamId, weaponDefId);
+weaponDef-&gt;edgeEffectiveness = sAICallback-&gt;WeaponDef_getEdgeEffectiveness(teamId, weaponDefId);
+weaponDef-&gt;size = sAICallback-&gt;WeaponDef_getSize(teamId, weaponDefId);
+weaponDef-&gt;sizeGrowth = sAICallback-&gt;WeaponDef_getSizeGrowth(teamId, weaponDefId);
+weaponDef-&gt;collisionSize = sAICallback-&gt;WeaponDef_getCollisionSize(teamId, weaponDefId);
+weaponDef-&gt;salvosize = sAICallback-&gt;WeaponDef_getSalvoSize(teamId, weaponDefId);
+weaponDef-&gt;salvodelay = sAICallback-&gt;WeaponDef_getSalvoDelay(teamId, weaponDefId);
+weaponDef-&gt;reload = sAICallback-&gt;WeaponDef_getReload(teamId, weaponDefId);
+weaponDef-&gt;beamtime = sAICallback-&gt;WeaponDef_getBeamTime(teamId, weaponDefId);
+weaponDef-&gt;beamburst = sAICallback-&gt;WeaponDef_isBeamBurst(teamId, weaponDefId);
+weaponDef-&gt;waterBounce = sAICallback-&gt;WeaponDef_isWaterBounce(teamId, weaponDefId);
+weaponDef-&gt;groundBounce = sAICallback-&gt;WeaponDef_isGroundBounce(teamId, weaponDefId);
+weaponDef-&gt;bounceRebound = sAICallback-&gt;WeaponDef_getBounceRebound(teamId, weaponDefId);
+weaponDef-&gt;bounceSlip = sAICallback-&gt;WeaponDef_getBounceSlip(teamId, weaponDefId);
+weaponDef-&gt;numBounce = sAICallback-&gt;WeaponDef_getNumBounce(teamId, weaponDefId);
+weaponDef-&gt;maxAngle = sAICallback-&gt;WeaponDef_getMaxAngle(teamId, weaponDefId);
+weaponDef-&gt;restTime = sAICallback-&gt;WeaponDef_getRestTime(teamId, weaponDefId);
+weaponDef-&gt;uptime = sAICallback-&gt;WeaponDef_getUpTime(teamId, weaponDefId);
+weaponDef-&gt;flighttime = sAICallback-&gt;WeaponDef_getFlightTime(teamId, weaponDefId);
+weaponDef-&gt;metalcost = sAICallback-&gt;WeaponDef_getMetalCost(teamId, weaponDefId);
+weaponDef-&gt;energycost = sAICallback-&gt;WeaponDef_getEnergyCost(teamId, weaponDefId);
+weaponDef-&gt;supplycost = sAICallback-&gt;WeaponDef_getSupplyCost(teamId, weaponDefId);
+weaponDef-&gt;projectilespershot = sAICallback-&gt;WeaponDef_getProjectilesPerShot(teamId, weaponDefId);
+weaponDef-&gt;id = sAICallback-&gt;WeaponDef_getId(teamId, weaponDefId);
+weaponDef-&gt;tdfId = sAICallback-&gt;WeaponDef_getTdfId(teamId, weaponDefId);
+weaponDef-&gt;turret = sAICallback-&gt;WeaponDef_isTurret(teamId, weaponDefId);
+weaponDef-&gt;onlyForward = sAICallback-&gt;WeaponDef_isOnlyForward(teamId, weaponDefId);
+weaponDef-&gt;fixedLauncher = sAICallback-&gt;WeaponDef_isFixedLauncher(teamId, weaponDefId);
+weaponDef-&gt;waterweapon = sAICallback-&gt;WeaponDef_isWaterWeapon(teamId, weaponDefId);
+weaponDef-&gt;fireSubmersed = sAICallback-&gt;WeaponDef_isFireSubmersed(teamId, weaponDefId);
+weaponDef-&gt;submissile = sAICallback-&gt;WeaponDef_isSubMissile(teamId, weaponDefId);
+weaponDef-&gt;tracks = sAICallback-&gt;WeaponDef_isTracks(teamId, weaponDefId);
+weaponDef-&gt;dropped = sAICallback-&gt;WeaponDef_isDropped(teamId, weaponDefId);
+weaponDef-&gt;paralyzer = sAICallback-&gt;WeaponDef_isParalyzer(teamId, weaponDefId);
+weaponDef-&gt;impactOnly = sAICallback-&gt;WeaponDef_isImpactOnly(teamId, weaponDefId);
+weaponDef-&gt;noAutoTarget = sAICallback-&gt;WeaponDef_isNoAutoTarget(teamId, weaponDefId);
+weaponDef-&gt;manualfire = sAICallback-&gt;WeaponDef_isManualFire(teamId, weaponDefId);
+weaponDef-&gt;interceptor = sAICallback-&gt;WeaponDef_getInterceptor(teamId, weaponDefId);
+weaponDef-&gt;targetable = sAICallback-&gt;WeaponDef_getTargetable(teamId, weaponDefId);
+weaponDef-&gt;stockpile = sAICallback-&gt;WeaponDef_isStockpileable(teamId, weaponDefId);
+weaponDef-&gt;coverageRange = sAICallback-&gt;WeaponDef_getCoverageRange(teamId, weaponDefId);
+weaponDef-&gt;intensity = sAICallback-&gt;WeaponDef_getIntensity(teamId, weaponDefId);
+weaponDef-&gt;thickness = sAICallback-&gt;WeaponDef_getThickness(teamId, weaponDefId);
+weaponDef-&gt;laserflaresize = sAICallback-&gt;WeaponDef_getLaserFlareSize(teamId, weaponDefId);
+weaponDef-&gt;corethickness = sAICallback-&gt;WeaponDef_getCoreThickness(teamId, weaponDefId);
+weaponDef-&gt;duration = sAICallback-&gt;WeaponDef_getDuration(teamId, weaponDefId);
+weaponDef-&gt;lodDistance = sAICallback-&gt;WeaponDef_getLodDistance(teamId, weaponDefId);
+weaponDef-&gt;falloffRate = sAICallback-&gt;WeaponDef_getFalloffRate(teamId, weaponDefId);
+weaponDef-&gt;graphicsType = sAICallback-&gt;WeaponDef_getGraphicsType(teamId, weaponDefId);
+weaponDef-&gt;soundTrigger = sAICallback-&gt;WeaponDef_isSoundTrigger(teamId, weaponDefId);
+weaponDef-&gt;selfExplode = sAICallback-&gt;WeaponDef_isSelfExplode(teamId, weaponDefId);
+weaponDef-&gt;gravityAffected = sAICallback-&gt;WeaponDef_isGravityAffected(teamId, weaponDefId);
+weaponDef-&gt;highTrajectory = sAICallback-&gt;WeaponDef_getHighTrajectory(teamId, weaponDefId);
+weaponDef-&gt;myGravity = sAICallback-&gt;WeaponDef_getMyGravity(teamId, weaponDefId);
+weaponDef-&gt;twophase = sAICallback-&gt;WeaponDef_isTwoPhase(teamId, weaponDefId);
+weaponDef-&gt;guided = sAICallback-&gt;WeaponDef_isGuided(teamId, weaponDefId);
+weaponDef-&gt;vlaunch = sAICallback-&gt;WeaponDef_isVLaunched(teamId, weaponDefId);
+weaponDef-&gt;selfprop = sAICallback-&gt;WeaponDef_isSelfPropelled(teamId, weaponDefId);
+weaponDef-&gt;noExplode = sAICallback-&gt;WeaponDef_isNoExplode(teamId, weaponDefId);
+weaponDef-&gt;startvelocity = sAICallback-&gt;WeaponDef_getStartVelocity(teamId, weaponDefId);
+weaponDef-&gt;weaponacceleration = sAICallback-&gt;WeaponDef_getWeaponAcceleration(teamId, weaponDefId);
+weaponDef-&gt;turnrate = sAICallback-&gt;WeaponDef_getTurnRate(teamId, weaponDefId);
+weaponDef-&gt;maxvelocity = sAICallback-&gt;WeaponDef_getMaxVelocity(teamId, weaponDefId);
+weaponDef-&gt;projectilespeed = sAICallback-&gt;WeaponDef_getProjectileSpeed(teamId, weaponDefId);
+weaponDef-&gt;explosionSpeed = sAICallback-&gt;WeaponDef_getExplosionSpeed(teamId, weaponDefId);
+weaponDef-&gt;onlyTargetCategory = sAICallback-&gt;WeaponDef_getOnlyTargetCategory(teamId, weaponDefId);
+weaponDef-&gt;wobble = sAICallback-&gt;WeaponDef_getWobble(teamId, weaponDefId);
+weaponDef-&gt;dance = sAICallback-&gt;WeaponDef_getDance(teamId, weaponDefId);
+weaponDef-&gt;trajectoryHeight = sAICallback-&gt;WeaponDef_getTrajectoryHeight(teamId, weaponDefId);
+weaponDef-&gt;largeBeamLaser = sAICallback-&gt;WeaponDef_isLargeBeamLaser(teamId, weaponDefId);
+weaponDef-&gt;isShield = sAICallback-&gt;WeaponDef_isShield(teamId, weaponDefId);
+weaponDef-&gt;shieldRepulser = sAICallback-&gt;WeaponDef_isShieldRepulser(teamId, weaponDefId);
+weaponDef-&gt;smartShield = sAICallback-&gt;WeaponDef_isSmartShield(teamId, weaponDefId);
+weaponDef-&gt;exteriorShield = sAICallback-&gt;WeaponDef_isExteriorShield(teamId, weaponDefId);
+weaponDef-&gt;visibleShield = sAICallback-&gt;WeaponDef_isVisibleShield(teamId, weaponDefId);
+weaponDef-&gt;visibleShieldRepulse = sAICallback-&gt;WeaponDef_isVisibleShieldRepulse(teamId, weaponDefId);
+weaponDef-&gt;visibleShieldHitFrames = sAICallback-&gt;WeaponDef_getVisibleShieldHitFrames(teamId, weaponDefId);
+weaponDef-&gt;shieldEnergyUse = sAICallback-&gt;WeaponDef_getShieldEnergyUse(teamId, weaponDefId);
+weaponDef-&gt;shieldRadius = sAICallback-&gt;WeaponDef_getShieldRadius(teamId, weaponDefId);
+weaponDef-&gt;shieldForce = sAICallback-&gt;WeaponDef_getShieldForce(teamId, weaponDefId);
+weaponDef-&gt;shieldMaxSpeed = sAICallback-&gt;WeaponDef_getShieldMaxSpeed(teamId, weaponDefId);
+weaponDef-&gt;shieldPower = sAICallback-&gt;WeaponDef_getShieldPower(teamId, weaponDefId);
+weaponDef-&gt;shieldPowerRegen = sAICallback-&gt;WeaponDef_getShieldPowerRegen(teamId, weaponDefId);
+weaponDef-&gt;shieldPowerRegenEnergy = sAICallback-&gt;WeaponDef_getShieldPowerRegenEnergy(teamId, weaponDefId);
+weaponDef-&gt;shieldStartingPower = sAICallback-&gt;WeaponDef_getShieldStartingPower(teamId, weaponDefId);
+weaponDef-&gt;shieldRechargeDelay = sAICallback-&gt;WeaponDef_getShieldRechargeDelay(teamId, weaponDefId);
+weaponDef-&gt;shieldGoodColor = float3(sAICallback-&gt;WeaponDef_getShieldGoodColor(teamId, weaponDefId));
+weaponDef-&gt;shieldBadColor = float3(sAICallback-&gt;WeaponDef_getShieldBadColor(teamId, weaponDefId));
+weaponDef-&gt;shieldAlpha = sAICallback-&gt;WeaponDef_getShieldAlpha(teamId, weaponDefId);
+weaponDef-&gt;shieldInterceptType = sAICallback-&gt;WeaponDef_getShieldInterceptType(teamId, weaponDefId);
+weaponDef-&gt;interceptedByShieldType = sAICallback-&gt;WeaponDef_getInterceptedByShieldType(teamId, weaponDefId);
+weaponDef-&gt;avoidFriendly = sAICallback-&gt;WeaponDef_isAvoidFriendly(teamId, weaponDefId);
+weaponDef-&gt;avoidFeature = sAICallback-&gt;WeaponDef_isAvoidFeature(teamId, weaponDefId);
+weaponDef-&gt;avoidNeutral = sAICallback-&gt;WeaponDef_isAvoidNeutral(teamId, weaponDefId);
+weaponDef-&gt;targetBorder = sAICallback-&gt;WeaponDef_getTargetBorder(teamId, weaponDefId);
+weaponDef-&gt;cylinderTargetting = sAICallback-&gt;WeaponDef_getCylinderTargetting(teamId, weaponDefId);
+weaponDef-&gt;minIntensity = sAICallback-&gt;WeaponDef_getMinIntensity(teamId, weaponDefId);
+weaponDef-&gt;heightBoostFactor = sAICallback-&gt;WeaponDef_getHeightBoostFactor(teamId, weaponDefId);
+weaponDef-&gt;proximityPriority = sAICallback-&gt;WeaponDef_getProximityPriority(teamId, weaponDefId);
+weaponDef-&gt;collisionFlags = sAICallback-&gt;WeaponDef_getCollisionFlags(teamId, weaponDefId);
+weaponDef-&gt;sweepFire = sAICallback-&gt;WeaponDef_isSweepFire(teamId, weaponDefId);
+weaponDef-&gt;canAttackGround = sAICallback-&gt;WeaponDef_isCanAttackGround(teamId, weaponDefId);
+weaponDef-&gt;cameraShake = sAICallback-&gt;WeaponDef_getCameraShake(teamId, weaponDefId);
+weaponDef-&gt;dynDamageExp = sAICallback-&gt;WeaponDef_getDynDamageExp(teamId, weaponDefId);
+weaponDef-&gt;dynDamageMin = sAICallback-&gt;WeaponDef_getDynDamageMin(teamId, weaponDefId);
+weaponDef-&gt;dynDamageRange = sAICallback-&gt;WeaponDef_getDynDamageRange(teamId, weaponDefId);
+weaponDef-&gt;dynDamageInverted = sAICallback-&gt;WeaponDef_isDynDamageInverted(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 6&quot;);
+//{
+//	SProperties* sProperties = sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId);
+//	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+//	int i;
+//	for (i=0; i &lt; sProperties-&gt;size; ++i) {
+//		weaponDef-&gt;customParams.insert(sProperties-&gt;map[i][0], sProperties-&gt;map[i][1]);
+//	}
+//	free(sProperties-&gt;map);
+//}
+{
+	int size = sAICallback-&gt;WeaponDef_getNumCustomParams(teamId, weaponDefId);
+	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+//	logT(&quot;GetWeaponDefById 7&quot;);
+//	logI(&quot;GetWeaponDefById 7 size: %d&quot;, size);
+//	int i;
+//	for (i=0; i &lt; size; ++i) {
+//		const char** entry = sAICallback-&gt;WeaponDef_getCustomParam(teamId, weaponDefId, i);
+////		weaponDef-&gt;customParams.insert(entry[0], entry[1]);
+//		weaponDef-&gt;customParams[entry[0]] = entry[1];
+////		free(entry);
+//	}
+//	const char*** cMap = (const char***) malloc(size*2*sizeof(char*));
+	const char* cMap[size][2];
+	sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId, cMap);
+//	logT(&quot;GetWeaponDefById 8&quot;);
+//	logI(&quot;GetWeaponDefById 8 size: %d&quot;, size);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+//	logI(&quot;GetWeaponDefById 8 i: %d&quot;, i);
+		weaponDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+	}
+//	free(cMap);
+}
+//	logT(&quot;GetWeaponDefById 9&quot;);
+	if (weaponDefs[weaponDefId] != NULL) {
+		delete weaponDefs[weaponDefId];
+	}
+//	logT(&quot;GetWeaponDefById 10&quot;);
+		weaponDefs[weaponDefId] = weaponDef;
+//	logT(&quot;GetWeaponDefById 11&quot;);
+		weaponDefFrames[weaponDefId] = currentFrame;
+//	logT(&quot;GetWeaponDefById 12&quot;);
+	}
+
+//	logT(&quot;leaving: GetWeaponDefById sAICallback&quot;);
+	return weaponDefs[weaponDefId];
+}
+
+const float3* CAIAICallback::GetStartPos() {
+	return new float3(sAICallback-&gt;Map_getStartPos(teamId));
+}
+
+
+
+
+
+
+
+void CAIAICallback::SendTextMsg(const char* text, int zone) {
+	SSendTextMessageCommand cmd = {text, zone};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_TEXT_MESSAGE, &amp;cmd);
+}
+
+void CAIAICallback::SetLastMsgPos(float3 pos) {
+	SSetLastPosMessageCommand cmd = {pos.toSAIFloat3()}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SET_LAST_POS_MESSAGE, &amp;cmd);
+}
+
+void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
+	SAddNotificationDrawerCommand cmd = {pos.toSAIFloat3(), color.toSAIFloat3(), alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_ADD_NOTIFICATION, &amp;cmd);
+}
+
+bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
+		SSendResourcesCommand cmd = {mAmount, eAmount, receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_RESOURCES, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeam) {
+	int arr_unitIds[unitIds.size()];
+	for (unsigned int i=0; i &lt; unitIds.size(); ++i) {
+		arr_unitIds[i] = unitIds[i];
+	}
+	SSendUnitsCommand cmd = {arr_unitIds, unitIds.size(), receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_UNITS, &amp;cmd); return cmd.ret_sentUnits;
+}
+
+void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
+		SCreateSharedMemAreaCommand cmd = {name, size}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_CREATE, &amp;cmd); return cmd.ret_sharedMemArea;
+}
+
+void CAIAICallback::ReleasedSharedMemArea(char* name) {
+	SReleaseSharedMemAreaCommand cmd = {name}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_RELEASE, &amp;cmd);
+}
+
+int CAIAICallback::CreateGroup(char* libraryName, unsigned aiNumber) {
+		SCreateGroupCommand cmd = {libraryName, aiNumber}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_CREATE, &amp;cmd); return cmd.ret_groupId;
+}
+
+void CAIAICallback::EraseGroup(int groupId) {
+	SEraseGroupCommand cmd = {groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ERASE, &amp;cmd);
+}
+
+bool CAIAICallback::AddUnitToGroup(int unitId, int groupId) {
+		SAddUnitToGroupCommand cmd = {unitId, groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ADD_UNIT, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
+		SRemoveUnitFromGroupCommand cmd = {unitId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_REMOVE_UNIT, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+int CAIAICallback::GiveGroupOrder(int groupId, Command* c) {
+	return this-&gt;Internal_GiveOrder(-1, groupId, c);
+}
+
+int CAIAICallback::GiveOrder(int unitId, Command* c) {
+	return this-&gt;Internal_GiveOrder(unitId, -1, c);
+}
+
+int CAIAICallback::Internal_GiveOrder(int unitId, int groupId, Command* c) {
+	
+/*
+	int ret = -1;
+	
+	switch (c-&gt;id) {
+        case CMD_STOP:
+		{
+			SStopUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOP, &amp;cmd);
+			break;
+		}
+		case CMD_WAIT:
+		{
+			SWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT, &amp;cmd);
+			break;
+		}
+		case CMD_TIMEWAIT:
+		{
+			STimeWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_TIME, &amp;cmd);
+			break;
+		}
+		case CMD_DEATHWAIT:
+		{
+			SDeathWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_DEATH, &amp;cmd);
+			break;
+		}
+		case CMD_SQUADWAIT:
+		{
+			SSquadWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_SQUAD, &amp;cmd);
+			break;
+		}
+		case CMD_GATHERWAIT:
+		{
+			SGatherWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_GATHER, &amp;cmd);
+			break;
+		}
+		case CMD_MOVE:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SMoveUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_MOVE, &amp;cmd);
+			break;
+		}
+		case CMD_PATROL:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SPatrolUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_PATROL, &amp;cmd);
+			break;
+		}
+		case CMD_FIGHT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SFightUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_FIGHT, &amp;cmd);
+			break;
+		}
+		case CMD_ATTACK:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SAttackUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK, &amp;cmd);
+			} else {
+				SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SAttackAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toAttackPos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_GUARD:
+		{
+			SGuardUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GUARD, &amp;cmd);
+			break;
+		}
+		case CMD_AISELECT:
+		{
+			SAiSelectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_AI_SELECT, &amp;cmd);
+			break;
+		}
+		case CMD_GROUPADD:
+		{
+			SGroupAddUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_ADD, &amp;cmd);
+			break;
+		}
+		case CMD_GROUPCLEAR:
+		{
+			SGroupClearUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_CLEAR, &amp;cmd);
+			break;
+		}
+		case CMD_REPAIR:
+		{
+			SRepairUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_REPAIR, &amp;cmd);
+			break;
+		}
+		case CMD_FIRE_STATE:
+		{
+			SSetFireStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_FIRE_STATE, &amp;cmd);
+			break;
+		}
+		case CMD_MOVE_STATE:
+		{
+			SSetMoveStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_MOVE_STATE, &amp;cmd);
+			break;
+		}
+		case CMD_SETBASE:
+		{
+			SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SSetBaseUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, basePos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_BASE, &amp;cmd);
+			break;
+		}
+		case CMD_SELFD:
+		{
+			SSelfDestroyUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SELF_DESTROY, &amp;cmd);
+			break;
+		}
+		case CMD_SET_WANTED_MAX_SPEED:
+		{
+			SSetWantedMaxSpeedUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_WANTED_MAX_SPEED, &amp;cmd);
+			break;
+		}
+		case CMD_LOAD_UNITS:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				int toLoadUnitId = (int) c-&gt;params[0];
+				SLoadUnitsUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, &amp;toLoadUnitId, 1};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SLoadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_LOAD_ONTO:
+		{
+			SLoadOntoUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_ONTO, &amp;cmd);
+			break;
+		}
+		case CMD_UNLOAD_UNIT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, (int) c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNIT, &amp;cmd);
+			break;
+		}
+		case CMD_UNLOAD_UNITS:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNITS_AREA, &amp;cmd);
+			break;
+		}
+		case CMD_ONOFF:
+		{
+			SSetOnOffUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_ON_OFF, &amp;cmd);
+			break;
+		}
+		case CMD_RECLAIM:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SReclaimUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SReclaimAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_CLOAK:
+		{
+			SCloakUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CLOAK, &amp;cmd);
+			break;
+		}
+		case CMD_STOCKPILE:
+		{
+			SStockpileUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOCKPILE, &amp;cmd);
+			break;
+		}
+		case CMD_DGUN:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SDGunUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				SDGunPosUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN_POS, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_RESTORE:
+		{
+			SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SRestoreAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESTORE_AREA, &amp;cmd);
+			break;
+		}
+		case CMD_REPEAT:
+		{
+			SSetRepeatUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_REPEAT, &amp;cmd);
+			break;
+		}
+		case CMD_TRAJECTORY:
+		{
+			SSetTrajectoryUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_TRAJECTORY, &amp;cmd);
+			break;
+		}
+		case CMD_RESURRECT:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SResurrectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SResurrectAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_CAPTURE:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SCaptureUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SCaptureAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_AUTOREPAIRLEVEL:
+		{
+			SSetAutoRepairLevelUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL, &amp;cmd);
+			break;
+		}
+		case CMD_IDLEMODE:
+		{
+			SSetIdleModeUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_IDLE_MODE, &amp;cmd);
+			break;
+		}
+		default:
+		{
+			if (c-&gt;id &lt; 0) { // CMD_BUILD
+				int toBuildUnitDefId = -c-&gt;id;
+				SAIFloat3 buildPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				int facing = UNIT_COMMAND_BUILD_NO_FACING;
+				if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
+				SBuildUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toBuildUnitDefId, buildPos, facing};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_BUILD, &amp;cmd);
+			} else { // CMD_CUSTOM
+				int cmdId = c-&gt;id;
+				int numParams = c-&gt;params.size();
+				float params[numParams];
+				SCustomUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, cmdId, params, numParams};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CUSTOM, &amp;cmd);
+			}
+			break;
+		}
+
+	}
+	
+	return ret;
+*/
+    int sCommandId;
+    void* sCommandData = mallocSUnitCommand(unitId, groupId, c, &amp;sCommandId);
+    
+    int ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, sCommandId, sCommandData);
+    
+    freeSUnitCommand(sCommandData, sCommandId);
+    
+    return ret;
+}
+
+int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
+		SInitPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_INIT, &amp;cmd); return cmd.ret_pathId;
+}
+
+float3 CAIAICallback::GetNextWaypoint(int pathId) {
+		SGetNextWaypointPathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_NEXT_WAYPOINT, &amp;cmd); return float3(cmd.ret_nextWaypoint);
+}
+
+float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+		SGetApproximateLengthPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_APPROXIMATE_LENGTH, &amp;cmd); return cmd.ret_approximatePathLength;
+}
+
+void CAIAICallback::FreePath(int pathId) {
+	SFreePathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_FREE, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SStartPathDrawerCommand cmd = {pos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_START, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerFinishPath() {
+	SFinishPathDrawerCommand cmd = {}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_FINISH, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SDrawLinePathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdId, const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SDrawLineAndIconPathDrawerCommand cmd = {cmdId, endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdId) {
+	SDrawIconAtLastPosPathDrawerCommand cmd = {cmdId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SBreakPathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_BREAK, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerRestart() {
+	SRestartPathDrawerCommand cmd = {false}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerRestartSameColor() {
+	SRestartPathDrawerCommand cmd = {true}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
+}
+
+int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifeTime, int figureGroupId) {
+		SCreateSplineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), pos3.toSAIFloat3(), pos4.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_SPLINE, &amp;cmd); return cmd.ret_newFigureGroupId;
+}
+
+int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifeTime, int figureGroupId) {
+		SCreateLineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_LINE, &amp;cmd); return cmd.ret_newFigureGroupId;
+}
+
+void CAIAICallback::SetFigureColor(int figureGroupId, float red, float green, float blue, float alpha) {
+	SAIFloat3 col3 = {red, green, blue};
+	SSetColorFigureDrawerCommand cmd = {figureGroupId, col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_SET_COLOR, &amp;cmd);
+}
+
+void CAIAICallback::DeleteFigureGroup(int figureGroupId) {
+	SDeleteFigureDrawerCommand cmd = {figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_DELETE, &amp;cmd);
+}
+
+void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifeTime, int unitTeamId, bool transparent, bool drawBorder, int facing) {
+	SDrawUnitDrawerCommand cmd = {sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, name), pos.toSAIFloat3(), rotation, lifeTime, unitTeamId, transparent, drawBorder, facing}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_DRAW_UNIT, &amp;cmd);
+}
+
+int CAIAICallback::HandleCommand(int commandId, void* data) {
+	
+	int cmdTopicIndex = commandId;
+	int ret = -99;
+	
+	switch (commandId) {
+		case AIHCQuerySubVersionId: {
+//			SQuerySubVersionCommand cmd;
+//			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			ret = sAICallback-&gt;Game_getAiInterfaceVersion(teamId);
+			break;
+		}
+		case AIHCAddMapPointId: {
+			AIHCAddMapPoint* myData = (AIHCAddMapPoint*) data;
+			SAddPointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3(), myData-&gt;label};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCAddMapLineId: {
+			AIHCAddMapLine* myData = (AIHCAddMapLine*) data;
+			SAddLineDrawCommand cmd = {myData-&gt;posfrom.toSAIFloat3(), myData-&gt;posto.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCRemoveMapPointId: {
+			AIHCRemoveMapPoint* myData = (AIHCRemoveMapPoint*) data;
+			SRemovePointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCSendStartPosId: {
+			AIHCSendStartPos* myData = (AIHCSendStartPos*) data;
+			SSendStartPosCommand cmd = {myData-&gt;ready, myData-&gt;pos.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+	}
+	
+	return ret;
+}
+
+bool CAIAICallback::ReadFile(const char* filename, void* buffer, int bufferLen) {
+//		SReadFileCommand cmd = {name, buffer, bufferLen}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_READ_FILE, &amp;cmd); return cmd.ret_isExecuted;
+	return sAICallback-&gt;File_getContent(teamId, filename, buffer, bufferLen);
+}
+
+const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
+		SCallLuaRulesCommand cmd = {data, inSize, outSize}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CALL_LUA_RULES, &amp;cmd); return cmd.ret_outData;
+}
+
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,214 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIAICALLBACK_H
+#define	_AIAICALLBACK_H
+
+
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;ExternalAI/IAICallback.h&quot;
+
+/**
+ * The AI side wrapper over the C AI interface for IAICallback.
+ */
+class CAIAICallback : public IAICallback {
+public:
+    CAIAICallback();
+    CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/);
+
+	virtual void SendTextMsg(const char* text, int zone);
+	virtual void SetLastMsgPos(float3 pos);
+	virtual void AddNotification(float3 pos, float3 color, float alpha);
+
+	virtual bool SendResources(float mAmount, float eAmount, int receivingTeam);
+	
+	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam);
+
+	virtual bool PosInCamera(float3 pos, float radius);
+
+	virtual int GetCurrentFrame();
+
+	virtual int GetMyTeam();
+	virtual int GetMyAllyTeam();
+	virtual int GetPlayerTeam(int player);
+	virtual const char* GetTeamSide(int team);
+
+	virtual void* CreateSharedMemArea(char* name, int size);
+	
+	virtual void ReleasedSharedMemArea(char* name);
+
+	virtual int CreateGroup(char* dll, unsigned aiNumber);							
+																						
+	virtual void EraseGroup(int groupid);											
+	virtual bool AddUnitToGroup(int unitid, int groupid);							
+																						
+	virtual bool RemoveUnitFromGroup(int unitid);									
+	virtual int GetUnitGroup(int unitid);											
+	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);	
+	virtual int GiveGroupOrder(int unitid, Command* c);
+
+	virtual int GiveOrder(int unitid, Command* c);
+
+	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid);
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+
+	virtual int GetUnitAiHint(int unitid);				
+	virtual int GetUnitTeam(int unitid);
+	virtual int GetUnitAllyTeam(int unitid);
+	virtual float GetUnitHealth(int unitid);			
+	virtual float GetUnitMaxHealth(int unitid);			
+	virtual float GetUnitSpeed(int unitid);				
+	virtual float GetUnitPower(int unitid);				
+	virtual float GetUnitExperience(int unitid);		
+	virtual float GetUnitMaxRange(int unitid);			
+	virtual bool IsUnitActivated (int unitid);
+	virtual bool UnitBeingBuilt(int unitid);			
+	virtual const UnitDef* GetUnitDef(int unitid);		
+															
+	virtual float3 GetUnitPos(int unitid);
+	virtual int GetBuildingFacing(int unitid);			
+	virtual bool IsUnitCloaked(int unitid);
+	virtual bool IsUnitParalyzed(int unitid);
+	virtual bool IsUnitNeutral(int unitid);
+	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+
+	virtual const UnitDef* GetUnitDef(const char* unitName);
+	virtual const UnitDef* GetUnitDefById(int unitDefId);
+
+	virtual int InitPath(float3 start, float3 end, int pathType);
+	virtual float3 GetNextWaypoint(int pathid);
+	virtual void FreePath(int pathid);
+
+	virtual float GetPathLength(float3 start, float3 end, int pathType);
+
+	virtual int GetEnemyUnits(int* units);										
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);		
+	virtual int GetEnemyUnitsInRadarAndLos(int* units);							
+	virtual int GetFriendlyUnits(int* units);									
+	virtual int GetFriendlyUnits(int* units, const float3&amp; pos, float radius);	
+	virtual int GetNeutralUnits(int* units);									
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);	
+
+	virtual int GetMapWidth();
+	virtual int GetMapHeight();
+	virtual const float* GetHeightMap();			
+	virtual float GetMinHeight();					
+	virtual float GetMaxHeight();					
+	virtual const float* GetSlopeMap();				
+														
+	virtual const unsigned short* GetLosMap();		
+	virtual const unsigned short* GetRadarMap();	
+	virtual const unsigned short* GetJammerMap();	
+	virtual const unsigned char* GetMetalMap();		
+	virtual const char* GetMapName();
+	virtual const char* GetModName();
+
+	virtual float GetElevation(float x, float z);	
+
+	virtual float GetMaxMetal();					
+	virtual float GetExtractorRadius();				
+	virtual float GetMinWind();
+	virtual float GetMaxWind();
+	virtual float GetTidalStrength();
+	virtual float GetGravity();
+
+	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color);
+	virtual void LineDrawerFinishPath();
+	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color);
+	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color);
+	virtual void LineDrawerDrawIconAtLastPos(int cmdID);
+	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color);
+	virtual void LineDrawerRestart();
+	virtual void LineDrawerRestartSameColor();
+
+	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group);
+	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group);
+	virtual void SetFigureColor(int group, float red, float green, float blue, float alpha);
+	virtual void DeleteFigureGroup(int group);
+
+	virtual void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing);
+
+	virtual bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing);
+	
+	virtual float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing);
+
+	virtual bool GetProperty(int id, int property, void* dst);
+	virtual bool GetValue(int id, void* dst);
+	virtual int HandleCommand(int commandId, void* data);
+
+	virtual int GetFileSize(const char* name);								
+	virtual bool ReadFile(const char* name, void* buffer, int bufferLen);	
+
+	virtual int GetSelectedUnits(int* units);
+	virtual float3 GetMousePos();
+	virtual int GetMapPoints(PointMarker* pm, int maxPoints);
+	virtual int GetMapLines(LineMarker* lm, int maxLines);
+
+	virtual float GetMetal();					
+	virtual float GetMetalIncome();				
+	virtual float GetMetalUsage();				
+	virtual float GetMetalStorage();			
+
+	virtual float GetEnergy();					
+	virtual float GetEnergyIncome();			
+	virtual float GetEnergyUsage();				
+	virtual float GetEnergyStorage();			
+
+	virtual int GetFeatures(int *features, int max);
+	virtual int GetFeatures(int *features, int max, const float3&amp; pos, float radius);
+	virtual const FeatureDef* GetFeatureDef(int feature);
+	virtual const FeatureDef* GetFeatureDefById(int featureDefId);
+	virtual float GetFeatureHealth(int feature);
+	virtual float GetFeatureReclaimLeft(int feature);
+	virtual float3 GetFeaturePos(int feature);
+
+	virtual int GetNumUnitDefs();
+	virtual void GetUnitDefList(const UnitDef** list);
+	virtual float GetUnitDefHeight(int def);	
+	virtual float GetUnitDefRadius(int def);	
+
+	virtual const WeaponDef* GetWeapon(const char* weaponName);
+	virtual const WeaponDef* GetWeaponDefById(int weaponDefId);
+
+	virtual const float3* GetStartPos();
+
+	
+	virtual const char* CallLuaRules(const char* data, int inSize = -1, int* outSize = NULL);
+
+private:
+    int teamId;
+    SAICallback* sAICallback;
+//    IAICallback* aiCallback;
+//    int currentFrame;
+    void init();
+//    void setCurrentFrame(int frame) { currentFrame = frame; }
+    int Internal_GiveOrder(int unitId, int groupId, Command* c);
+    
+	// caches
+    WeaponDef** weaponDefs;
+    int* weaponDefFrames;
+    UnitDef** unitDefs;
+    int* unitDefFrames;
+	std::vector&lt;CommandDescription&gt;** groupPossibleCommands; // needed to prevent memory leacks
+	std::vector&lt;CommandDescription&gt;** unitPossibleCommands; // needed to prevent memory leacks
+	CCommandQueue** unitCurrentCommandQueues; // needed to prevent memory leacks
+    FeatureDef** featureDefs;
+    int* featureDefFrames;
+};
+
+#endif	/* _AIAICALLBACK_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,219 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIAICheats.h&quot;
+
+#include &quot;ExternalAI/Interface/AISCommands.h&quot;
+
+
+CAIAICheats::CAIAICheats()
+    : IAICheats(), teamId(-1), sAICallback(NULL)/*, aiCheatCallback(NULL)*/, aiCallback(NULL) {
+    
+}
+
+CAIAICheats::CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback)
+    : IAICheats(), teamId(teamId), sAICallback(sAICallback)/*, aiCheatCallback(aiCheatCallback)*/, aiCallback(aiCallback) {
+    
+}
+
+void CAIAICheats::setCheatsEnabled(bool enabled) {
+    sAICallback-&gt;Cheats_setEnabled(teamId, enabled);
+}
+
+
+void CAIAICheats::SetMyHandicap(float handicap) {
+    setCheatsEnabled(true);
+    SSetMyHandicapCheatCommand cmd = {handicap};
+    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_SET_MY_HANDICAP, &amp;cmd);
+    setCheatsEnabled(false);
+}
+void CAIAICheats::GiveMeMetal(float amount) {
+    setCheatsEnabled(true);
+    SGiveMeMetalCheatCommand cmd = {amount};
+    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_METAL, &amp;cmd);
+    setCheatsEnabled(false);
+}
+void CAIAICheats::GiveMeEnergy(float amount) {
+    setCheatsEnabled(true);
+    SGiveMeEnergyCheatCommand cmd = {amount};
+    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_ENERGY, &amp;cmd);
+    setCheatsEnabled(false);
+}
+
+int CAIAICheats::CreateUnit(const char* unitDefName, float3 pos) {
+    setCheatsEnabled(true);
+    int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitDefName);
+    SGiveMeNewUnitCheatCommand cmd = {unitDefId, pos.toSAIFloat3()};
+    int unitId = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_NEW_UNIT, &amp;cmd);
+    setCheatsEnabled(false);
+    return unitId;
+}
+
+const UnitDef* CAIAICheats::GetUnitDef(int unitId) {
+    setCheatsEnabled(true);
+    const UnitDef* unitDef = aiCallback-&gt;GetUnitDef(unitId);
+    setCheatsEnabled(false);
+    return unitDef;
+}
+float3 CAIAICheats::GetUnitPos(int unitId) {
+    setCheatsEnabled(true);
+    float3 pos = aiCallback-&gt;GetUnitPos(unitId);
+    setCheatsEnabled(false);
+    return pos;
+}
+int CAIAICheats::GetEnemyUnits(int* unitIds) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+int CAIAICheats::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+int CAIAICheats::GetNeutralUnits(int* unitIds) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+int CAIAICheats::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+    setCheatsEnabled(true);
+    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+    setCheatsEnabled(false);
+    return numUnits;
+}
+
+int CAIAICheats::GetUnitTeam(int unitId) {
+    setCheatsEnabled(true);
+    int t = aiCallback-&gt;GetUnitTeam(unitId);
+    setCheatsEnabled(false);
+    return t;
+}
+int CAIAICheats::GetUnitAllyTeam(int unitId) {
+    setCheatsEnabled(true);
+    int t = aiCallback-&gt;GetUnitAllyTeam(unitId);
+    setCheatsEnabled(false);
+    return t;
+}
+float CAIAICheats::GetUnitHealth(int unitId) {
+    setCheatsEnabled(true);
+    float health = aiCallback-&gt;GetUnitHealth(unitId);
+    setCheatsEnabled(false);
+    return health;
+}
+float CAIAICheats::GetUnitMaxHealth(int unitId) {
+    setCheatsEnabled(true);
+    float health = aiCallback-&gt;GetUnitMaxHealth(unitId);
+    setCheatsEnabled(false);
+    return health;
+}
+float CAIAICheats::GetUnitPower(int unitId) {
+    setCheatsEnabled(true);
+    float power = aiCallback-&gt;GetUnitPower(unitId);
+    setCheatsEnabled(false);
+    return power;
+}
+float CAIAICheats::GetUnitExperience(int unitId) {
+    setCheatsEnabled(true);
+    float experience = aiCallback-&gt;GetUnitExperience(unitId);
+    setCheatsEnabled(false);
+    return experience;
+}
+bool CAIAICheats::IsUnitActivated(int unitId) {
+    setCheatsEnabled(true);
+    bool activated = aiCallback-&gt;IsUnitActivated(unitId);
+    setCheatsEnabled(false);
+    return activated;
+}
+bool CAIAICheats::UnitBeingBuilt(int unitId) {
+    setCheatsEnabled(true);
+    bool isBeingBuilt = aiCallback-&gt;UnitBeingBuilt(unitId);
+    setCheatsEnabled(false);
+    return isBeingBuilt;
+}
+bool CAIAICheats::IsUnitNeutral(int unitId) {
+    setCheatsEnabled(true);
+    bool neutral = aiCallback-&gt;IsUnitNeutral(unitId);
+    setCheatsEnabled(false);
+    return neutral;
+}
+bool CAIAICheats::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+    setCheatsEnabled(true);
+    bool fetchOk = aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+    setCheatsEnabled(false);
+    return fetchOk;
+}
+const CCommandQueue* CAIAICheats::GetCurrentUnitCommands(int unitId) {
+    setCheatsEnabled(true);
+    const CCommandQueue* cc = aiCallback-&gt;GetCurrentUnitCommands(unitId);
+    setCheatsEnabled(false);
+    return cc;
+}
+
+int CAIAICheats::GetBuildingFacing(int unitId) {
+    setCheatsEnabled(true);
+    int facing = aiCallback-&gt;GetBuildingFacing(unitId);
+    setCheatsEnabled(false);
+    return facing;
+}
+bool CAIAICheats::IsUnitCloaked(int unitId) {
+    setCheatsEnabled(true);
+    bool cloaked = aiCallback-&gt;IsUnitCloaked(unitId);
+    setCheatsEnabled(false);
+    return cloaked;
+}
+bool CAIAICheats::IsUnitParalyzed(int unitId) {
+    setCheatsEnabled(true);
+    bool paralyzed = aiCallback-&gt;IsUnitParalyzed(unitId);
+    setCheatsEnabled(false);
+    return paralyzed;
+}
+
+bool CAIAICheats::OnlyPassiveCheats() {
+    return sAICallback-&gt;Cheats_isOnlyPassive(teamId);
+}
+void CAIAICheats::EnableCheatEvents(bool enable) {
+    sAICallback-&gt;Cheats_setEventsEnabled(teamId, enable);
+}
+
+bool CAIAICheats::GetProperty(int id, int property, void* dst) {
+//    setCheatsEnabled(true);
+//    bool fetchOk = aiCallback-&gt;GetProperty(id, property, dst);
+//    setCheatsEnabled(false);
+//    return fetchOk;
+	// this returns always false, cause these values are now available through
+	// individual callback functions -&gt; this method is deprecated
+	return false;
+}
+bool CAIAICheats::GetValue(int id, void* dst) {
+//    setCheatsEnabled(true);
+//    bool fetchOk = aiCallback-&gt;GetValue(id, dst);
+//    setCheatsEnabled(false);
+//    return fetchOk;
+	// this returns always false, cause these values are now available through
+	// individual callback functions -&gt; this method is deprecated
+	return false;
+}
+int CAIAICheats::HandleCommand(int commandId, void* data) {
+    setCheatsEnabled(true);
+    int ret = aiCallback-&gt;HandleCommand(commandId, data);
+    setCheatsEnabled(false);
+    return ret;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,81 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIAICHEATS_H
+#define	_AIAICHEATS_H
+
+#include &quot;ExternalAI/IAICheats.h&quot;
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
+
+/**
+ * The AI side wrapper over the C AI interface for IAICheats.
+ */
+class CAIAICheats : public IAICheats {
+public:
+    CAIAICheats();
+    CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback);
+
+
+    virtual void SetMyHandicap(float handicap);
+
+    virtual void GiveMeMetal(float amount);
+    virtual void GiveMeEnergy(float amount);
+
+    virtual int CreateUnit(const char* name, float3 pos);
+
+    virtual const UnitDef* GetUnitDef(int unitid);
+    virtual float3 GetUnitPos(int unitid);
+    virtual int GetEnemyUnits(int* units);
+    virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
+    virtual int GetNeutralUnits(int* units);
+    virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
+
+    virtual int GetUnitTeam(int unitid);
+    virtual int GetUnitAllyTeam(int unitid);
+    virtual float GetUnitHealth(int unitid);
+    virtual float GetUnitMaxHealth(int unitid);
+    virtual float GetUnitPower(int unitid);
+    virtual float GetUnitExperience(int unitid);
+    virtual bool IsUnitActivated(int unitid);
+    virtual bool UnitBeingBuilt(int unitid);
+    virtual bool IsUnitNeutral(int unitid);
+    virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+    virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+
+    virtual int GetBuildingFacing(int unitid);
+    virtual bool IsUnitCloaked(int unitid);
+    virtual bool IsUnitParalyzed(int unitid);
+
+    virtual bool OnlyPassiveCheats();
+    virtual void EnableCheatEvents(bool enable);
+
+    virtual bool GetProperty(int id, int property, void* dst);
+    virtual bool GetValue(int id, void* dst);
+    virtual int HandleCommand(int commandId, void* data);
+    
+private:
+    int teamId;
+    SAICallback* sAICallback;
+//    IAICheats* aiCheatCallback;
+//    IAICallback* aiCallback;
+    CAIAICallback* aiCallback;
+    void setCheatsEnabled(bool enable);
+};
+
+
+#endif	/* _AIAICHEATS_H */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,33 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIGlobalAI.h&quot;
+
+CAIGlobalAI::CAIGlobalAI() : CAI(), gai(0) { 
+    
+}
+
+CAIGlobalAI::CAIGlobalAI(int team, IGlobalAI* gai) : CAI(team, gai), gai(gai) {
+    
+}
+
+CAIGlobalAI::~CAIGlobalAI() {
+    delete gai;
+}
+void CAIGlobalAI::InitAI(IGlobalAICallback* globalAICallback, int team) {
+	gai-&gt;InitAI(globalAICallback, team);
+}


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,37 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef AIGLOBALAI_H
+#define AIGLOBALAI_H
+
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;AI.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot; // Remove
+
+class CAIGlobalAI : public CAI {
+public:
+    CAIGlobalAI();
+    CAIGlobalAI(int team, IGlobalAI* gai);
+    ~CAIGlobalAI();
+
+    void InitAI(IGlobalAICallback* globalAICallback, int team);
+    
+    IGlobalAI* gai;
+};
+
+#endif /*AIGLOBALAI_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,54 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIGlobalAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
+#include &quot;AIAICheats.h&quot;
+
+CAIGlobalAICallback::CAIGlobalAICallback()
+    : IGlobalAICallback(), sAICallback(NULL), teamId(-1),
+        wrappedAICallback(NULL), wrappedAICheats(NULL) {
+    
+}
+
+CAIGlobalAICallback::CAIGlobalAICallback(SAICallback* sAICallback, int teamId)
+    : IGlobalAICallback(), sAICallback(sAICallback), teamId(teamId),
+        wrappedAICallback(NULL), wrappedAICheats(NULL) {
+    
+}
+
+CAIGlobalAICallback::~CAIGlobalAICallback() {
+    
+}
+
+
+IAICallback* CAIGlobalAICallback::GetAICallback() {
+    
+    if (wrappedAICallback == NULL) {
+        wrappedAICallback = new CAIAICallback(teamId, sAICallback);
+    }
+    return wrappedAICallback;
+}
+
+IAICheats* CAIGlobalAICallback::GetCheatInterface() {
+    
+    if (wrappedAICheats == NULL) {
+        this-&gt;GetAICallback(); // to initialize
+        wrappedAICheats = new CAIAICheats(teamId, sAICallback, wrappedAICallback);
+    }
+    return wrappedAICheats;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,47 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIGLOBALAICALLBACK_H
+#define	_AIGLOBALAICALLBACK_H
+
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+
+#include &quot;AIAICallback.h&quot;
+#include &quot;AIAICheats.h&quot;
+
+/**
+ * The AI side wrapper over the C AI interface for IGlobalAICallback.
+ */
+class CAIGlobalAICallback : public IGlobalAICallback {
+public:
+    CAIGlobalAICallback();
+    CAIGlobalAICallback(SAICallback* sAICallback, int teamId);
+    ~CAIGlobalAICallback();
+
+    virtual IAICheats* GetCheatInterface();
+    virtual IAICallback* GetAICallback();
+    
+private:
+    SAICallback* sAICallback;
+    int teamId;
+    CAIAICallback* wrappedAICallback;
+    CAIAICheats* wrappedAICheats;
+};
+
+#endif	/* _AIGLOBALAICALLBACK_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AISCommands.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AISCommands.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AISCommands.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,18 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;ExternalAI/AISCommands.cpp&quot;


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AISCommands.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDamagedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDamagedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDamagedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyDamagedEvent : public CAIEvent {
+public:
+    CAIEnemyDamagedEvent(const SEnemyDamagedEvent* event): event(*event) {}
+    ~CAIEnemyDamagedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;EnemyDamaged(event.enemy, event.attacker, event.damage, event.dir);
+    }
+private:
+    SEnemyDamagedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDamagedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDestroyedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDestroyedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDestroyedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyDestroyedEvent : public CAIEvent {
+public:
+    CAIEnemyDestroyedEvent(const SEnemyDestroyedEvent* event): event(*event) {}
+    ~CAIEnemyDestroyedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;EnemyDestroyed(event.enemy, event.attacker);
+    }
+private:
+    SEnemyDestroyedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyDestroyedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterLOSEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterLOSEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterLOSEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyEnterLOSEvent : public CAIEvent {
+public:
+    CAIEnemyEnterLOSEvent(const SEnemyEnterLOSEvent* event): event(*event) {}
+    ~CAIEnemyEnterLOSEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;EnemyEnterLOS(event.enemy);
+    }
+private:
+    SEnemyEnterLOSEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterLOSEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterRadarEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterRadarEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterRadarEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyEnterRadarEvent : public CAIEvent {
+public:
+    CAIEnemyEnterRadarEvent(const SEnemyEnterRadarEvent* event): event(*event) {}
+    ~CAIEnemyEnterRadarEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;EnemyEnterRadar(event.enemy);
+    }
+private:
+    SEnemyEnterRadarEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyEnterRadarEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveLOSEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveLOSEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveLOSEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyLeaveLOSEvent : public CAIEvent {
+public:
+    CAIEnemyLeaveLOSEvent(const SEnemyLeaveLOSEvent* event): event(*event) {}
+    ~CAIEnemyLeaveLOSEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;EnemyLeaveLOS(event.enemy);
+    }
+private:
+    SEnemyLeaveLOSEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveLOSEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveRadarEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveRadarEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveRadarEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIEnemyLeaveRadarEvent : public CAIEvent {
+public:
+    CAIEnemyLeaveRadarEvent(const SEnemyLeaveRadarEvent* event): event(*event) {}
+    ~CAIEnemyLeaveRadarEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;EnemyLeaveRadar(event.enemy);
+    }
+private:
+    SEnemyLeaveRadarEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEnemyLeaveRadarEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,24 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+
+class CAIEvent {
+public:
+    
+    virtual void run(IGlobalAI* ai) = 0;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvents.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvents.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvents.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,57 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+#ifndef AIEVENTS_H
+#define AIEVENTS_H
+
+#include &quot;../AI.h&quot;
+#include &quot;../AIGlobalAI.h&quot;
+
+#include &quot;ExternalAI/Interface/AISEvents.h&quot;
+#include &quot;ExternalAI/Interface/AISCommands.h&quot;
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+
+#include &quot;AIEvent.h&quot;
+#include &quot;AINullEvent.h&quot;
+
+#include &quot;AIInitEvent.h&quot;
+#include &quot;AIUpdateEvent.h&quot;
+
+#include &quot;AIMessageEvent.h&quot;
+
+#include &quot;AIUnitCreatedEvent.h&quot;
+#include &quot;AIUnitFinishedEvent.h&quot;
+#include &quot;AIUnitIdleEvent.h&quot;
+#include &quot;AIUnitMoveFailedEvent.h&quot;
+#include &quot;AIUnitDamagedEvent.h&quot;
+#include &quot;AIUnitDestroyedEvent.h&quot;
+#include &quot;AIUnitGivenEvent.h&quot;
+#include &quot;AIUnitCapturedEvent.h&quot;
+
+#include &quot;AIEnemyEnterLOSEvent.h&quot;
+#include &quot;AIEnemyLeaveLOSEvent.h&quot;
+#include &quot;AIEnemyEnterRadarEvent.h&quot;
+#include &quot;AIEnemyLeaveRadarEvent.h&quot;
+#include &quot;AIEnemyDamagedEvent.h&quot;
+#include &quot;AIEnemyDestroyedEvent.h&quot;
+
+#include &quot;AIWeaponFiredEvent.h&quot;
+#include &quot;AIPlayerCommandEvent.h&quot;
+#include &quot;AISeismicPingEvent.h&quot;
+
+#endif /*AIEVENTS_H*/


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIEvents.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIInitEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIInitEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIInitEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,34 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+#include &quot;../AIGlobalAICallback.h&quot;
+
+class CAIInitEvent : public CAIEvent {
+public:
+    CAIInitEvent(const SInitEvent* event): event(*event) {}
+    ~CAIInitEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        //((CAIGlobalAI*) ai)-&gt;gai-&gt;InitAI(event.callback, event.team);
+        //((CAIGlobalAI*) ai)-&gt;InitAI(event.c_callback, event.team, event.callback);
+        IGlobalAICallback* wrappedGlobalAICallback = new CAIGlobalAICallback(event.c_callback, event.team);
+        ai-&gt;InitAI(wrappedGlobalAICallback, event.team);
+    }
+private:
+    SInitEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIInitEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIMessageEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIMessageEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIMessageEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIMessageEvent : public CAIEvent {
+public:
+    CAIMessageEvent(const SMessageEvent* event): event(*event) {}
+    ~CAIMessageEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;GotChatMsg(event.message, event.player);
+    }
+private:
+    SMessageEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIMessageEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AINullEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AINullEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AINullEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,23 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+class CAINullEvent : public CAIEvent {
+public:
+    CAINullEvent() {}
+    ~CAINullEvent() {}
+    void run(IGlobalAI* ai) {}
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AINullEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIPlayerCommandEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIPlayerCommandEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIPlayerCommandEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,45 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIPLAYERCOMMANDEVENT_H
+#define	_AIPLAYERCOMMANDEVENT_H
+
+#include &quot;ExternalAI/Interface/AISCommands.h&quot;
+
+class CAIPlayerCommandEvent : public CAIEvent {
+public:
+    CAIPlayerCommandEvent(const SPlayerCommandEvent* event): event(*event) {}
+    ~CAIPlayerCommandEvent() {}
+    
+    void run(IGlobalAI* ai) {
+		int evtId = AI_EVENT_PLAYER_COMMAND;
+		std::vector&lt;int&gt; unitIds;
+		int i;
+		for (i=0; i &lt; event.numUnitIds; i++) {
+            unitIds.push_back(event.unitIds[i]);
+        }
+		Command* c = (Command*) newCommand(event.commandData, event.commandTopic);
+		IGlobalAI::PlayerCommandEvent evt = {unitIds, *c, event.playerId};
+        ai-&gt;HandleEvent(evtId, &amp;evt);
+		delete c;
+    }
+private:
+    SPlayerCommandEvent event;
+};
+
+#endif	/* _AIPLAYERCOMMANDEVENT_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIPlayerCommandEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AISeismicPingEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AISeismicPingEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AISeismicPingEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,36 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AISEISMICPINGEVENT_H
+#define	_AISEISMICPINGEVENT_H
+
+class CAISeismicPingEvent : public CAIEvent {
+public:
+    CAISeismicPingEvent(const SSeismicPingEvent* event): event(*event) {}
+    ~CAISeismicPingEvent() {}
+    
+    void run(IGlobalAI* ai) {
+		int evtId = AI_EVENT_SEISMIC_PING;
+		IGlobalAI::SeismicPingEvent evt = {float3(event.pos), event.strength};
+        ai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SSeismicPingEvent event;
+};
+
+#endif	/* _AISEISMICPINGEVENT_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AISeismicPingEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCapturedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCapturedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCapturedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,36 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIUNITCAPTUREDEVENT_H
+#define	_AIUNITCAPTUREDEVENT_H
+
+class CAIUnitCapturedEvent : public CAIEvent {
+public:
+    CAIUnitCapturedEvent(const SUnitCapturedEvent* event): event(*event) {}
+    ~CAIUnitCapturedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+		int evtId = AI_EVENT_UNITCAPTURED;
+		IGlobalAI::ChangeTeamEvent evt = {event.unitId, event.newTeamId, event.oldTeamId};
+        ai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SUnitCapturedEvent event;
+};
+
+#endif	/* _AIUNITCAPTUREDEVENT_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCapturedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCreatedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCreatedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCreatedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitCreatedEvent : public CAIEvent {
+public:
+    CAIUnitCreatedEvent(const SUnitCreatedEvent* event): event(*event) {}
+    ~CAIUnitCreatedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;UnitCreated(event.unit);
+    }
+private:
+    SUnitCreatedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitCreatedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDamagedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDamagedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDamagedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitDamagedEvent : public CAIEvent {
+public:
+    CAIUnitDamagedEvent(const SUnitDamagedEvent* event): event(*event) {}
+    ~CAIUnitDamagedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;UnitDamaged(event.unit, event.attacker, event.damage, event.dir);
+    }
+private:
+    SUnitDamagedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDamagedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDestroyedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDestroyedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDestroyedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitDestroyedEvent : public CAIEvent {
+public:
+    CAIUnitDestroyedEvent(const SUnitDestroyedEvent* event): event(*event) {}
+    ~CAIUnitDestroyedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;UnitDestroyed(event.unit, event.attacker);
+    }
+private:
+    SUnitDestroyedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitDestroyedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitFinishedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitFinishedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitFinishedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitFinishedEvent : public CAIEvent {
+public:
+    CAIUnitFinishedEvent(const SUnitFinishedEvent* event): event(*event) {}
+    ~CAIUnitFinishedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;UnitFinished(event.unit);
+    }
+private:
+    SUnitFinishedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitFinishedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitGivenEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitGivenEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitGivenEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,36 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIUNITGIVENEVENT_H
+#define	_AIUNITGIVENEVENT_H
+
+class CAIUnitGivenEvent : public CAIEvent {
+public:
+    CAIUnitGivenEvent(const SUnitGivenEvent* event): event(*event) {}
+    ~CAIUnitGivenEvent() {}
+    
+    void run(IGlobalAI* ai) {
+		int evtId = AI_EVENT_UNITGIVEN;
+		IGlobalAI::ChangeTeamEvent evt = {event.unitId, event.newTeamId, event.oldTeamId};
+        ai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SUnitGivenEvent event;
+};
+
+#endif	/* _AIUNITGIVENEVENT_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitGivenEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitIdleEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitIdleEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitIdleEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUnitIdleEvent : public CAIEvent {
+public:
+    CAIUnitIdleEvent(const SUnitIdleEvent* event): event(*event) {}
+    ~CAIUnitIdleEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;UnitIdle(event.unit);
+    }
+private:
+    SUnitIdleEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitIdleEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitMoveFailedEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitMoveFailedEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitMoveFailedEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,30 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+//#include &quot;AIEvent.h&quot;
+
+class CAIUnitMoveFailedEvent : public CAIEvent {
+public:
+    CAIUnitMoveFailedEvent(const SUnitMoveFailedEvent* event): event(*event) {}
+    ~CAIUnitMoveFailedEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;UnitMoveFailed(event.unit);
+    }
+private:
+    SUnitMoveFailedEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUnitMoveFailedEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUpdateEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUpdateEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUpdateEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,29 @@
+/*
+    Copyright 2008  Nicolas Wu
+    
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+
+class CAIUpdateEvent : public CAIEvent {
+public:
+    CAIUpdateEvent(const SUpdateEvent* event): event(*event) {}
+    ~CAIUpdateEvent() {}
+    
+    void run(IGlobalAI* ai) {
+        ai-&gt;Update();
+    }
+private:
+    SUpdateEvent event;
+};


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIUpdateEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIWeaponFiredEvent.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIWeaponFiredEvent.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIWeaponFiredEvent.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,40 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIWEAPONFIREDEVENT_H
+#define	_AIWEAPONFIREDEVENT_H
+
+class CAIWeaponFiredEvent : public CAIEvent {
+public:
+    CAIWeaponFiredEvent(const SWeaponFiredEvent* event): event(*event) {}
+    ~CAIWeaponFiredEvent() {}
+    
+    void run(IGlobalAI* ai) {
+		int evtId = AI_EVENT_WEAPON_FIRED;
+		//TODO: maybe: retrieve a WeaponDef that contains all attributes
+		// as thisone contians only the correct id
+		WeaponDef weaponDef;
+		weaponDef.id = event.weaponDefId;
+		IGlobalAI::WeaponFireEvent evt = {event.unitId, &amp;weaponDef};
+        ai-&gt;HandleEvent(evtId, &amp;evt);
+    }
+private:
+    SWeaponFiredEvent event;
+};
+
+#endif	/* _AIWEAPONFIREDEVENT_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/Event/AIWeaponFiredEvent.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,671 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SAICALLBACK_H
+#define	_SAICALLBACK_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+    
+#include &quot;aidefines.h&quot;
+
+/**
+ * Global AI Callback function pointers.
+ */
+struct SAICallback {
+
+/**
+ * Whenever an AI wants to change engine state in any way, it has to call this method.
+ * In other words, all commands from AIs to the engine (and other AIs) go through this method.
+ *
+ * teamId	the team number of the AI that sends the command
+ * toId		the team number of the AI that should receive the command,
+ * 		or COMMAND_TO_ID_ENGINE if it is meant for the engine
+ * commandId	used on asynchronous commands, this allows the AI to identify
+ * 		a possible result event, which would come with the same id
+ * commandTopic	unique identifyer of a command (see COMMAND_* defines in AISCommands.h)
+ * commandData	a commandTopic specific struct, which contains the data associated
+ * 		with the command (see *Command structs)
+ * return	0 if command handling ok, something else otherwise
+ */
+int (CALLING_CONV *handleCommand)(int teamId, int toId, int commandId, int commandTopic, void* commandData);
+
+
+// BEGINN misc callback functions
+int (CALLING_CONV *Game_getCurrentFrame)(int teamId); //TODO: deprecate, becuase we get the frame from the SUpdateEvent
+int (CALLING_CONV *Game_getAiInterfaceVersion)(int teamId);
+int (CALLING_CONV *Game_getMyTeam)(int teamId);
+int (CALLING_CONV *Game_getMyAllyTeam)(int teamId);
+int (CALLING_CONV *Game_getPlayerTeam)(int teamId, int playerId);
+const char* (CALLING_CONV *Game_getTeamSide)(int teamId, int otherTeamId);
+// END misc callback functions
+
+int (CALLING_CONV *WeaponDef_STATIC_getNumDamageTypes)(int teamId);
+unsigned int (CALLING_CONV *Map_getChecksum)(int teamId);
+
+bool (CALLING_CONV *Game_isExceptionHandlingEnabled)(int teamId);
+bool (CALLING_CONV *Game_isDebugModeEnabled)(int teamId);
+int (CALLING_CONV *Game_getMode)(int teamId);
+bool (CALLING_CONV *Game_isPaused)(int teamId);
+float (CALLING_CONV *Game_getSpeedFactor)(int teamId);
+
+float (CALLING_CONV *Gui_getViewRange)(int teamId);
+float (CALLING_CONV *Gui_getScreenX)(int teamId);
+float (CALLING_CONV *Gui_getScreenY)(int teamId);
+struct SAIFloat3 (CALLING_CONV *Gui_Camera_getDirection)(int teamId);
+struct SAIFloat3 (CALLING_CONV *Gui_Camera_getPosition)(int teamId);
+
+bool (CALLING_CONV *File_locateForReading)(int teamId, char* filename);
+bool (CALLING_CONV *File_locateForWriting)(int teamId, char* filename);
+
+int (CALLING_CONV *Unit_STATIC_getLimit)(int teamId);
+const char* (CALLING_CONV *Game_getSetupScript)(int teamId);
+
+
+// BEGINN kind of deprecated; it is recommended not to use these
+//bool (CALLING_CONV *getProperty)(int teamId, int id, int property, void* dst);
+//bool (CALLING_CONV *getValue)(int teamId, int id, void* dst);
+// END kind of deprecated; it is recommended not to use these
+
+
+// BEGINN OBJECT Cheats
+bool (CALLING_CONV *Cheats_isEnabled)(int teamId);
+bool (CALLING_CONV *Cheats_setEnabled)(int teamId, bool enable);
+bool (CALLING_CONV *Cheats_setEventsEnabled)(int teamId, bool enabled);
+bool (CALLING_CONV *Cheats_isOnlyPassive)(int teamId);
+// END OBJECT Cheats
+
+
+// BEGINN OBJECT ResourceInfo
+float (CALLING_CONV *ResourceInfo_Metal_getCurrent)(int teamId);
+float (CALLING_CONV *ResourceInfo_Metal_getIncome)(int teamId);
+float (CALLING_CONV *ResourceInfo_Metal_getUsage)(int teamId);
+float (CALLING_CONV *ResourceInfo_Metal_getStorage)(int teamId);
+float (CALLING_CONV *ResourceInfo_Energy_getCurrent)(int teamId);
+float (CALLING_CONV *ResourceInfo_Energy_getIncome)(int teamId);
+float (CALLING_CONV *ResourceInfo_Energy_getUsage)(int teamId);
+float (CALLING_CONV *ResourceInfo_Energy_getStorage)(int teamId);
+// END OBJECT ResourceInfo
+
+
+// BEGINN OBJECT File
+int (CALLING_CONV *File_getSize)(int teamId, const char* fileName);
+bool (CALLING_CONV *File_getContent)(int teamId, const char* filename, void* buffer, int bufferLen);
+// END OBJECT File
+
+
+// BEGINN OBJECT UnitDef
+int (CALLING_CONV *UnitDef_STATIC_getIds)(int teamId, int* unitDefIds);
+int (CALLING_CONV *UnitDef_STATIC_getNumIds)(int teamId);
+int (CALLING_CONV *UnitDef_STATIC_getIdByName)(int teamId, const char* unitName);
+
+float (CALLING_CONV *UnitDef_getHeight)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getRadius)(int teamId, int unitDefId);
+
+bool (CALLING_CONV *UnitDef_isValid)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getName)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getHumanName)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getFilename)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getId)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getAiHint)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getCobID)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getTechLevel)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getGaia)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMetalUpkeep)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getEnergyUpkeep)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMetalMake)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMakesMetal)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getEnergyMake)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMetalCost)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getEnergyCost)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getBuildTime)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getExtractsMetal)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getExtractRange)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getWindGenerator)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTidalGenerator)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMetalStorage)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getEnergyStorage)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getAutoHeal)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getIdleAutoHeal)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getIdleTime)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getPower)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getHealth)(int teamId, int unitDefId);
+unsigned int (CALLING_CONV *UnitDef_getCategory)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTurnRate)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getMoveType)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isUpright)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCollide)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getControlRadius)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getLosRadius)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getAirLosRadius)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getLosHeight)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getRadarRadius)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getSonarRadius)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getJammerRadius)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getSonarJamRadius)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getSeismicRadius)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getSeismicSignature)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isStealth)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isSonarStealth)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isBuildRange3D)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getBuildDistance)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getBuildSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getReclaimSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getRepairSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxRepairSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getResurrectSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getCaptureSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTerraformSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMass)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isPushResistant)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isStrafeToAttack)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMinCollisionSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getSlideTolerance)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxSlope)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxHeightDif)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMinWaterDepth)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getWaterline)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxWaterDepth)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getArmoredMultiple)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getArmorType)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getFlankingBonusMode)(int teamId, int unitDefId);
+struct SAIFloat3 (CALLING_CONV *UnitDef_getFlankingBonusDir)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFlankingBonusMax)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFlankingBonusMin)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFlankingBonusMobilityAdd)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getCollisionVolumeType)(int teamId, int unitDefId);
+struct SAIFloat3 (CALLING_CONV *UnitDef_getCollisionVolumeScales)(int teamId, int unitDefId);
+struct SAIFloat3 (CALLING_CONV *UnitDef_getCollisionVolumeOffsets)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getCollisionVolumeTest)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxWeaponRange)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getType)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getTooltip)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getWreckName)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getDeathExplosion)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getSelfDExplosion)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getTedClassString)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_getCategoryString)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanSelfD)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getSelfDCountdown)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanSubmerge)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanFly)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanMove)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanHover)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isFloater)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isBuilder)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isActivateWhenBuilt)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isOnOffable)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isFullHealthFactory)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isFactoryHeadingTakeoff)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isReclaimable)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCapturable)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanRestore)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanRepair)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanSelfRepair)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanReclaim)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanAttack)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanPatrol)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanFight)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanGuard)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanBuild)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanAssist)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanBeAssisted)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanRepeat)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanFireControl)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getFireState)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getMoveState)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getWingDrag)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getWingAngle)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getDrag)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFrontToSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getSpeedToFront)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMyGravity)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxBank)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxPitch)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTurnRadius)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getWantedHeight)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getVerticalSpeed)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanCrash)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isHoverAttack)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isAirStrafe)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getDlHoverFactor)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxAcceleration)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxDeceleration)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxAileron)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxElevator)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxRudder)(int teamId, int unitDefId);
+///* returned size is 4 */
+//const unsigned char** (CALLING_CONV *UnitDef_getYardMaps)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getXSize)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getYSize)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getBuildAngle)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getLoadingRadius)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getUnloadSpread)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getTransportCapacity)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getTransportSize)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getMinTransportSize)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isAirBase)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTransportMass)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMinTransportMass)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isHoldSteady)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isReleaseHeld)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCantBeTransported)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isTransportByEnemy)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getTransportUnloadMethod)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFallSpeed)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getUnitFallSpeed)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanCloak)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isStartCloaked)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getCloakCost)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getCloakCostMoving)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getDecloakDistance)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isDecloakSpherical)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isDecloakOnFire)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanKamikaze)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getKamikazeDist)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isTargetingFacility)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanDGun)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isNeedGeo)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isFeature)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isHideDamage)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCommander)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isShowPlayerName)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanResurrect)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanCapture)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getHighTrajectoryType)(int teamId, int unitDefId);
+unsigned int (CALLING_CONV *UnitDef_getNoChaseCategory)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isLeaveTracks)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTrackWidth)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTrackOffset)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTrackStrength)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getTrackStretch)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getTrackType)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanDropFlare)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFlareReloadTime)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFlareEfficiency)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getFlareDelay)(int teamId, int unitDefId);
+struct SAIFloat3 (CALLING_CONV *UnitDef_getFlareDropVector)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getFlareTime)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getFlareSalvoSize)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getFlareSalvoDelay)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isSmoothAnim)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isMetalMaker)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isCanLoopbackAttack)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isLevelGround)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isUseBuildingGroundDecal)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getBuildingDecalType)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getBuildingDecalSizeX)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getBuildingDecalSizeY)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getBuildingDecalDecaySpeed)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isFirePlatform)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMaxFuel)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getRefuelTime)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_getMinAirBasePower)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getMaxThisUnit)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getDecoyDefId)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_isDontLand)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getShieldWeaponDefId)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getStockpileWeaponDefId)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getNumBuildOptions)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getBuildOptions)(int teamId, int unitDefId, int* unitDefIds);
+int (CALLING_CONV *UnitDef_getNumCustomParams)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getCustomParams)(int teamId, int unitDefId, const char* map[][2]);
+bool (CALLING_CONV *UnitDef_hasMoveData)(int teamId, int unitDefId);
+/* enum MoveType { Ground_Move, Hover_Move, Ship_Move }; */
+int (CALLING_CONV *UnitDef_MoveData_getMoveType)(int teamId, int unitDefId);
+/* 0=tank,1=kbot,2=hover,3=ship */
+int (CALLING_CONV *UnitDef_MoveData_getMoveFamily)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_MoveData_getSize)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getDepth)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getMaxSlope)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getSlopeMod)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getDepthMod)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_MoveData_getPathType)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getCrushStrength)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getMaxSpeed)(int teamId, int unitDefId);
+short (CALLING_CONV *UnitDef_MoveData_getMaxTurnRate)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getMaxAcceleration)(int teamId, int unitDefId);
+float (CALLING_CONV *UnitDef_MoveData_getMaxBreaking)(int teamId, int unitDefId);
+bool (CALLING_CONV *UnitDef_MoveData_isSubMarine)(int teamId, int unitDefId);
+int (CALLING_CONV *UnitDef_getNumUnitDefWeapons)(int teamId, int unitDefId);
+const char* (CALLING_CONV *UnitDef_UnitDefWeapon_getName)(int teamId, int unitDefId, int weaponIndex);
+int (CALLING_CONV *UnitDef_UnitDefWeapon_getWeaponDefId)(int teamId, int unitDefId, int weaponIndex);
+int (CALLING_CONV *UnitDef_UnitDefWeapon_getSlavedTo)(int teamId, int unitDefId, int weaponIndex);
+struct SAIFloat3 (CALLING_CONV *UnitDef_UnitDefWeapon_getMainDir)(int teamId, int unitDefId, int weaponIndex);
+float (CALLING_CONV *UnitDef_UnitDefWeapon_getMaxAngleDif)(int teamId, int unitDefId, int weaponIndex);
+float (CALLING_CONV *UnitDef_UnitDefWeapon_getFuelUsage)(int teamId, int unitDefId, int weaponIndex);
+unsigned int (CALLING_CONV *UnitDef_UnitDefWeapon_getBadTargetCat)(int teamId, int unitDefId, int weaponIndex);
+unsigned int (CALLING_CONV *UnitDef_UnitDefWeapon_getOnlyTargetCat)(int teamId, int unitDefId, int weaponIndex);
+// END OBJECT UnitDef
+
+
+
+// BEGINN OBJECT Unit
+int (CALLING_CONV *Unit_STATIC_getEnemies)(int teamId, int* unitIds);
+int (CALLING_CONV *Unit_STATIC_getEnemiesIn)(int teamId, int* unitIds, struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Unit_STATIC_getEnemiesInRadarAndLos)(int teamId, int* units);
+int (CALLING_CONV *Unit_STATIC_getFriendlies)(int teamId, int* unitIds);
+int (CALLING_CONV *Unit_STATIC_getFriendliesIn)(int teamId, int* unitIds, struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Unit_STATIC_getNeutrals)(int teamId, int* unitIds);
+int (CALLING_CONV *Unit_STATIC_getNeutralsIn)(int teamId, int* unitIds, struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Unit_STATIC_getSelected)(int teamId, int* unitIds);
+
+int (CALLING_CONV *Unit_getDefId)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getAiHint)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getTeam)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getAllyTeam)(int teamId, int unitId);
+
+int (CALLING_CONV *Unit_getStockpile)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getStockpileQueued)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getCurrentFuel)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getMaxSpeed)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getMaxRange)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getMaxHealth)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getExperience)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getGroup)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getNumCurrentCommands)(int teamId, int unitId);
+/* for the type of the command queue, see CCommandQueue::CommandQueueType CommandQueue.h */
+int (CALLING_CONV *Unit_CurrentCommands_getType)(int teamId, int unitId);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (CALLING_CONV *Unit_CurrentCommands_getIds)(int teamId, int unitId, int* ids);
+int (CALLING_CONV *Unit_CurrentCommands_getOptions)(int teamId, int unitId, unsigned char* options);
+int (CALLING_CONV *Unit_CurrentCommands_getTag)(int teamId, int unitId, unsigned int* tags);
+int (CALLING_CONV *Unit_CurrentCommands_getTimeOut)(int teamId, int unitId, int* timeOuts);
+int (CALLING_CONV *Unit_CurrentCommands_getNumParams)(int teamId, int unitId, int* numParams);
+int (CALLING_CONV *Unit_CurrentCommands_getParams)(int teamId, int unitId, float** params);
+int (CALLING_CONV *Unit_getNumSupportedCommands)(int teamId, int unitId);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (CALLING_CONV *Unit_SupportedCommands_getId)(int teamId, int unitId, int* ids);
+int (CALLING_CONV *Unit_SupportedCommands_getName)(int teamId, int unitId, const char** names);
+int (CALLING_CONV *Unit_SupportedCommands_getToolTip)(int teamId, int unitId, const char** toolTips);
+int (CALLING_CONV *Unit_SupportedCommands_isShowUnique)(int teamId, int unitId, bool* showUniques);
+int (CALLING_CONV *Unit_SupportedCommands_isDisabled)(int teamId, int unitId, bool* disableds);
+int (CALLING_CONV *Unit_SupportedCommands_getNumParams)(int teamId, int unitId, int* numParams);
+int (CALLING_CONV *Unit_SupportedCommands_getParams)(int teamId, int unitId, const char*** params);
+float (CALLING_CONV *Unit_getHealth)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getSpeed)(int teamId, int unitId);
+float (CALLING_CONV *Unit_getPower)(int teamId, int unitId);
+float (CALLING_CONV *Unit_ResourceInfo_Metal_getUse)(int teamId, int unitId);
+float (CALLING_CONV *Unit_ResourceInfo_Metal_getMake)(int teamId, int unitId);
+float (CALLING_CONV *Unit_ResourceInfo_Energy_getUse)(int teamId, int unitId);
+float (CALLING_CONV *Unit_ResourceInfo_Energy_getMake)(int teamId, int unitId);
+struct SAIFloat3 (CALLING_CONV *Unit_getPos)(int teamId, int unitId);
+bool (CALLING_CONV *Unit_isActivated)(int teamId, int unitId);
+bool (CALLING_CONV *Unit_isBeingBuilt)(int teamId, int unitId);
+bool (CALLING_CONV *Unit_isCloaked)(int teamId, int unitId);
+bool (CALLING_CONV *Unit_isParalyzed)(int teamId, int unitId);
+bool (CALLING_CONV *Unit_isNeutral)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getBuildingFacing)(int teamId, int unitId);
+// END OBJECT Unit
+
+
+// BEGINN OBJECT Group
+int (CALLING_CONV *Group_getNumSupportedCommands)(int teamId, int groupId);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (CALLING_CONV *Group_SupportedCommands_getId)(int teamId, int groupId, int* ids);
+int (CALLING_CONV *Group_SupportedCommands_getName)(int teamId, int groupId, const char** names);
+int (CALLING_CONV *Group_SupportedCommands_getToolTip)(int teamId, int groupId, const char** toolTips);
+int (CALLING_CONV *Group_SupportedCommands_isShowUnique)(int teamId, int groupId, bool* showUniques);
+int (CALLING_CONV *Group_SupportedCommands_isDisabled)(int teamId, int groupId, bool* disableds);
+int (CALLING_CONV *Group_SupportedCommands_getNumParams)(int teamId, int groupId, int* numParams);
+int (CALLING_CONV *Group_SupportedCommands_getParams)(int teamId, int groupId, const char*** params);
+// END OBJECT Group
+
+
+
+// BEGINN OBJECT Mod
+const char* (CALLING_CONV *Mod_getName)(int teamId);
+// END OBJECT Mod
+
+
+
+// BEGINN OBJECT Map
+struct SAIFloat3 (CALLING_CONV *Map_getStartPos)(int teamId);
+struct SAIFloat3 (CALLING_CONV *Map_getMousePos)(int teamId);
+bool (CALLING_CONV *Map_isPosInCamera)(int teamId, struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Map_getWidth)(int teamId);
+int (CALLING_CONV *Map_getHeight)(int teamId);
+const float* (CALLING_CONV *Map_getHeightMap)(int teamId);
+float (CALLING_CONV *Map_getMinHeight)(int teamId);
+float (CALLING_CONV *Map_getMaxHeight)(int teamId);
+const float* (CALLING_CONV *Map_getSlopeMap)(int teamId);
+const unsigned short* (CALLING_CONV *Map_getLosMap)(int teamId);
+const unsigned short* (CALLING_CONV *Map_getRadarMap)(int teamId);
+const unsigned short* (CALLING_CONV *Map_getJammerMap)(int teamId);
+const unsigned char* (CALLING_CONV *Map_getMetalMap)(int teamId);
+const char* (CALLING_CONV *Map_getName)(int teamId);
+float (CALLING_CONV *Map_getElevationAt)(int teamId, float x, float z);
+float (CALLING_CONV *Map_getMaxMetal)(int teamId);
+float (CALLING_CONV *Map_getExtractorRadius)(int teamId);
+float (CALLING_CONV *Map_getMinWind)(int teamId);
+float (CALLING_CONV *Map_getMaxWind)(int teamId);
+float (CALLING_CONV *Map_getTidalStrength)(int teamId);
+float (CALLING_CONV *Map_getGravity)(int teamId);
+int (CALLING_CONV *Map_getPoints)(int teamId, struct SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints);
+int (CALLING_CONV *Map_getLines)(int teamId, struct SAIFloat3* firstPositions, struct SAIFloat3* secondPositions, unsigned char** colors, int maxLines);
+bool (CALLING_CONV *Map_canBuildAt)(int teamId, int unitDefId, struct SAIFloat3 pos, int facing);
+struct SAIFloat3 (CALLING_CONV *Map_findClosestBuildSite)(int teamId, int unitDefId, struct SAIFloat3 pos, float searchRadius, int minDist, int facing);
+// BEGINN OBJECT Map
+
+
+
+// BEGINN OBJECT FeatureDef
+//const SAIFeatureDef* (CALLING_CONV *getFeatureDef)(int teamId, int featureDefId);
+const char* (CALLING_CONV *FeatureDef_getName)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *FeatureDef_getDescription)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *FeatureDef_getFilename)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getId)(int teamId, int weaponDefId);
+float (CALLING_CONV *FeatureDef_getMetal)(int teamId, int weaponDefId);
+float (CALLING_CONV *FeatureDef_getEnergy)(int teamId, int weaponDefId);
+float (CALLING_CONV *FeatureDef_getMaxHealth)(int teamId, int weaponDefId);
+float (CALLING_CONV *FeatureDef_getReclaimTime)(int teamId, int weaponDefId);
+float (CALLING_CONV *FeatureDef_getMass)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *FeatureDef_getCollisionVolumeType)(int teamId, int weaponDefId);	
+struct SAIFloat3 (CALLING_CONV *FeatureDef_getCollisionVolumeScales)(int teamId, int weaponDefId);		
+struct SAIFloat3 (CALLING_CONV *FeatureDef_getCollisionVolumeOffsets)(int teamId, int weaponDefId);		
+int (CALLING_CONV *FeatureDef_getCollisionVolumeTest)(int teamId, int weaponDefId);			
+bool (CALLING_CONV *FeatureDef_isUpright)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getDrawType)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *FeatureDef_getModelName)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getModelType)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isDestructable)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isReclaimable)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isBlocking)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isBurnable)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isFloating)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isNoSelect)(int teamId, int weaponDefId);
+bool (CALLING_CONV *FeatureDef_isGeoThermal)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *FeatureDef_getDeathFeature)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getXsize)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getYsize)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getNumCustomParams)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+// END OBJECT FeatureDef
+
+
+// BEGINN OBJECT Feature
+int (CALLING_CONV *Feature_STATIC_getIds)(int teamId, int *featureIds, int max);
+int (CALLING_CONV *Feature_STATIC_getIdsIn)(int teamId, int *featureIds, int max, struct SAIFloat3 pos, float radius);
+
+int (CALLING_CONV *Feature_getDefId)(int teamId, int featureId);
+float (CALLING_CONV *Feature_getHealth)(int teamId, int featureId);
+float (CALLING_CONV *Feature_getReclaimLeft)(int teamId, int featureId);
+struct SAIFloat3 (CALLING_CONV *Feature_getPos)(int teamId, int featureId);
+// END OBJECT Feature
+
+
+
+// BEGINN OBJECT WeaponDef
+int (CALLING_CONV *WeaponDef_STATIC_getIdByName)(int teamId, const char* weaponDefName);
+
+//const SAIWeaponDef* (CALLING_CONV *getWeaponDef)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *WeaponDef_getName)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *WeaponDef_getType)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *WeaponDef_getDescription)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *WeaponDef_getFilename)(int teamId, int weaponDefId);
+const char* (CALLING_CONV *WeaponDef_getCegTag)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getRange)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getHeightMod)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getAccuracy)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getSprayAngle)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getMovingAccuracy)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getTargetMoveError)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getLeadLimit)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getLeadBonus)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getPredictBoost)(int teamId, int weaponDefId);
+
+//DamageArray (CALLING_CONV *WeaponDef_getDamages)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_Damages_getParalyzeDamageTime)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_Damages_getImpulseFactor)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_Damages_getImpulseBoost)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_Damages_getCraterMult)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_Damages_getCraterBoost)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_Damages_getNumTypes)(int teamId, int weaponDefId);
+//float (CALLING_CONV *WeaponDef_Damages_getType)(int teamId, int weaponDefId, int typeIndex);
+void (CALLING_CONV *WeaponDef_Damages_getTypeDamages)(int teamId, int weaponDefId, float* typeDamages);
+
+float (CALLING_CONV *WeaponDef_getAreaOfEffect)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isNoSelfDamage)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getFireStarter)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getEdgeEffectiveness)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getSize)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getSizeGrowth)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getCollisionSize)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getSalvoSize)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getSalvoDelay)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getReload)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getBeamTime)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isBeamBurst)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isWaterBounce)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isGroundBounce)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getBounceRebound)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getBounceSlip)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getNumBounce)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getMaxAngle)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getRestTime)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getUpTime)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getFlightTime)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getMetalCost)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getEnergyCost)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getSupplyCost)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getProjectilesPerShot)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getId)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getTdfId)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isTurret)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isOnlyForward)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isFixedLauncher)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isWaterWeapon)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isFireSubmersed)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isSubMissile)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isTracks)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isDropped)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isParalyzer)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isImpactOnly)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isNoAutoTarget)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isManualFire)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getInterceptor)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getTargetable)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isStockpileable)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getCoverageRange)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getIntensity)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getThickness)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getLaserFlareSize)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getCoreThickness)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getDuration)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getLodDistance)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getFalloffRate)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getGraphicsType)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isSoundTrigger)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isSelfExplode)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isGravityAffected)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getHighTrajectory)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getMyGravity)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isTwoPhase)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isGuided)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isVLaunched)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isSelfPropelled)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isNoExplode)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getStartVelocity)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getWeaponAcceleration)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getTurnRate)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getMaxVelocity)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getProjectileSpeed)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getExplosionSpeed)(int teamId, int weaponDefId);
+unsigned int (CALLING_CONV *WeaponDef_getOnlyTargetCategory)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getWobble)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getDance)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getTrajectoryHeight)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isLargeBeamLaser)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isShield)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isShieldRepulser)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isSmartShield)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isExteriorShield)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isVisibleShield)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isVisibleShieldRepulse)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getVisibleShieldHitFrames)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldEnergyUse)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldRadius)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldForce)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldMaxSpeed)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldPower)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldPowerRegen)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldPowerRegenEnergy)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldStartingPower)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getShieldRechargeDelay)(int teamId, int weaponDefId);
+struct SAIFloat3 (CALLING_CONV *WeaponDef_getShieldGoodColor)(int teamId, int weaponDefId);
+struct SAIFloat3 (CALLING_CONV *WeaponDef_getShieldBadColor)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getShieldAlpha)(int teamId, int weaponDefId);
+unsigned int (CALLING_CONV *WeaponDef_getShieldInterceptType)(int teamId, int weaponDefId);
+unsigned int (CALLING_CONV *WeaponDef_getInterceptedByShieldType)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isAvoidFriendly)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isAvoidFeature)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isAvoidNeutral)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getTargetBorder)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getCylinderTargetting)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getMinIntensity)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getHeightBoostFactor)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getProximityPriority)(int teamId, int weaponDefId);
+unsigned int (CALLING_CONV *WeaponDef_getCollisionFlags)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isSweepFire)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isCanAttackGround)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getCameraShake)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getDynDamageExp)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getDynDamageMin)(int teamId, int weaponDefId);
+float (CALLING_CONV *WeaponDef_getDynDamageRange)(int teamId, int weaponDefId);
+bool (CALLING_CONV *WeaponDef_isDynDamageInverted)(int teamId, int weaponDefId);
+int (CALLING_CONV *WeaponDef_getNumCustomParams)(int teamId, int weaponDefId);
+//const char** (CALLING_CONV *WeaponDef_getCustomParam)(int teamId, int weaponDefId, int index);
+int (CALLING_CONV *WeaponDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+// END OBJECT WeaponDef
+
+};
+
+
+#ifdef	__cplusplus
+class IGlobalAICallback;
+SAICallback* initSAICallback(int teamId, IGlobalAICallback* aiGlobalCallback);
+#endif /* __cplusplus */
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SAICALLBACK_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SAIFloat3.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIFloat3.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIFloat3.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,34 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SAIFLOAT3_H
+#define	_SAIFLOAT3_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct SAIFloat3 {
+    float x, y, z;
+};
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SAIFLOAT3_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SAIFloat3.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,214 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SAIInterfaceLibrary.h&quot;
+
+#include &quot;string.h&quot;
+
+
+SAIInterfaceSpecifyer copySAIInterfaceSpecifyer(const struct SAIInterfaceSpecifyer* const orig) {
+	
+	struct SAIInterfaceSpecifyer copy;
+	
+	char* tmpStr = (char *) malloc(sizeof(char) * strlen(orig-&gt;shortName) + 1);
+	strcpy(tmpStr, orig-&gt;shortName);
+	copy.shortName = tmpStr;
+	
+	tmpStr = (char *) malloc(sizeof(char) * strlen(orig-&gt;version) + 1);
+	strcpy(tmpStr, orig-&gt;version);
+	copy.version = tmpStr;
+	
+	return copy;
+}
+void deleteSAIInterfaceSpecifyer(const struct SAIInterfaceSpecifyer* const spec) {
+	free(const_cast&lt;char*&gt;(spec-&gt;shortName));
+	free(const_cast&lt;char*&gt;(spec-&gt;version));
+}
+
+
+#ifdef	__cplusplus
+CR_BIND(SSAIKey,)
+CR_BIND(SGAIKey,)
+#endif /* __cplusplus */
+
+#ifdef	__cplusplus
+bool SAIInterfaceSpecifyer_Comparator::operator()(const struct SAIInterfaceSpecifyer&amp; a, const struct SAIInterfaceSpecifyer&amp; b) const {
+
+	bool isLess = false;
+	
+	int shortNameComp = strcmp(a.shortName, b.shortName);
+	if (shortNameComp &lt; 0) {
+		return isLess = true;
+	} else if (shortNameComp == 0) {
+		int versionComp = strcmp(a.version, b.version);
+		
+		if (versionComp &lt; 0) {
+			isLess = true;
+		}
+	}
+
+	return isLess;
+}
+bool SAIInterfaceSpecifyer_Comparator::IsEmpty(const struct SAIInterfaceSpecifyer&amp; spec) {
+	
+	bool empty = false;
+	
+	if (spec.shortName == NULL || spec.version == NULL) {
+		empty = true;
+	}
+	
+	return empty;
+}
+#endif /* __cplusplus */
+
+
+
+/*
+struct SSAIKey SSAIKey_init(struct SAIInterfaceSpecifyer _interface, struct SSAISpecifyer _ai) {
+	
+	struct SSAIKey key;
+	
+	key.interface = _interface;
+	key.ai = _ai;
+	
+	return key;
+}
+*/
+
+#ifdef	__cplusplus
+bool SSAIKey_Comparator::operator()(const struct SSAIKey&amp; a, const struct SSAIKey&amp; b) const {
+	
+	bool isLess = false;
+	
+	bool interfaceLess = SAIInterfaceSpecifyer_Comparator()(a.interface, b.interface);
+	if (interfaceLess) {
+		isLess = true;
+	} else if (!(SAIInterfaceSpecifyer_Comparator()(b.interface, a.interface))) { // -&gt; interfaces are equal
+		bool aiLess = SSAISpecifyer_Comparator()(a.ai, b.ai);
+		
+		if (aiLess) {
+			isLess = true;
+		}
+	}
+
+	return isLess;
+}
+bool SSAIKey_Comparator::IsEmpty(const struct SSAIKey&amp; key) {
+	
+	bool empty = false;
+	
+	if (SAIInterfaceSpecifyer_Comparator::IsEmpty(key.interface)
+			|| SSAISpecifyer_Comparator::IsEmpty(key.ai)) {
+		empty = true;
+	}
+	
+	return empty;
+}
+#endif /* __cplusplus */
+
+
+
+/*
+struct SGAIKey SGAIKey_init(struct SAIInterfaceSpecifyer _interface, struct SGAISpecifyer _ai) {
+	
+	struct SGAIKey key;
+	
+	key.interface = _interface;
+	key.ai = _ai;
+	
+	return key;
+}
+*/
+
+#ifdef	__cplusplus
+#include &quot;string.h&quot;
+
+bool SGAIKey_Comparator::operator()(const struct SGAIKey&amp; a, const struct SGAIKey&amp; b) const {
+
+/*
+	bool interfaceEqual = SAIInterfaceSpecifyer_Comparator()(a.interface, b.interface);
+	if (interfaceEqual) {
+		bool aiEqual = SGAISpecifyer_Comparator()(a.ai, b.ai);
+		return aiEqual;
+	}
+
+	return false;
+*/
+	bool isLess = false;
+	
+	bool interfaceLess = SAIInterfaceSpecifyer_Comparator()(a.interface, b.interface);
+	if (interfaceLess) {
+		isLess = true;
+	} else if (!(SAIInterfaceSpecifyer_Comparator()(b.interface, a.interface))) { // -&gt; interfaces are equal
+		bool aiLess = SGAISpecifyer_Comparator()(a.ai, b.ai);
+		
+		if (aiLess) {
+			isLess = true;
+		}
+	}
+
+	return isLess;
+}
+bool SGAIKey_Comparator::IsEmpty(const struct SGAIKey&amp; key) {
+	
+	bool empty = false;
+	
+	if (SAIInterfaceSpecifyer_Comparator::IsEmpty(key.interface)
+			|| SGAISpecifyer_Comparator::IsEmpty(key.ai)) {
+		empty = true;
+	}
+	
+	return empty;
+}
+#endif /* __cplusplus */
+
+
+
+//struct SAIInterfaceLibraryInfo {
+//	const char* libFileName; // the library file name, eg &quot;C-1.0.dll&quot;, &quot;CppLegacy-1.0.so&quot; or &quot;Java-1.0.dylib&quot;
+//	
+//	const char* name; // [may not contain: spaces, '_', '#']
+//	const char* version; // [may not contain: spaces, '_', '#']
+//	const char* description;
+//	const char* infoUrl; // usually a link to a spring wiki page
+//	
+//	const SAIInfo* aiInfos;
+//	int numAiInfos;
+//};
+
+
+//SAIInterfaceLibraryInfo* initAIInterfaceInfo(const SAIInterfaceLibrary* interface) {
+//	
+//	SAIInterfaceLibraryInfo* interfaceInfo = (SAIInterfaceLibraryInfo*) malloc(sizeof(SAIInterfaceLibraryInfo));
+//	
+//	interfaceInfo-&gt;libFileName = interface-&gt;libFileName;
+//	interfaceInfo-&gt;name = interface-&gt;getName();
+//	interfaceInfo-&gt;version = interface-&gt;getVersion();
+//	interfaceInfo-&gt;description = interface-&gt;getDescription();
+//	interfaceInfo-&gt;infoUrl = interface-&gt;getInfoUrl();
+//	interfaceInfo-&gt;aiInfos = (SAIInfo*) calloc(MAX_AI_INFOS, sizeof(SAIInfo));
+//	interfaceInfo-&gt;numAiInfos = interface-&gt;getAIInfos(interfaceInfo-&gt;aiInfos, MAX_AI_INFOS);
+//	
+//	return interfaceInfo;
+//}
+//
+//void deleteAIInterfaceInfo(const SAIInterfaceLibraryInfo* interfaceInfo) {
+//	
+//	free((void*)interfaceInfo-&gt;aiInfos);
+//	free((void*)interfaceInfo);
+//}
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,144 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SAIINTERFACELIBRARY_H
+#define	_SAIINTERFACELIBRARY_H
+
+#ifdef	__cplusplus
+#include &quot;creg/creg.h&quot;
+#endif /* __cplusplus */
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;ELevelOfSupport.h&quot;
+#include &quot;SSAILibrary.h&quot;
+#include &quot;SGAILibrary.h&quot;
+#include &quot;exportdefines.h&quot;
+
+#define AI_INTERFACE_PROPERTY_FILE_NAME &quot;fileName&quot;                     // [string] when the library file is &quot;libC-0.1.so&quot; or &quot;C-0.1.dll&quot;, this value should be &quot;C-0.1&quot;
+#define AI_INTERFACE_PROPERTY_SHORT_NAME &quot;shortName&quot;                   // [string: [a-zA-Z0-9_.]*]
+#define AI_INTERFACE_PROPERTY_VERSION &quot;version&quot;                        // [string: [a-zA-Z0-9_.]*]
+#define AI_INTERFACE_PROPERTY_NAME &quot;name&quot;                              // [string]
+#define AI_INTERFACE_PROPERTY_DESCRIPTION &quot;description&quot;                // [string]
+#define AI_INTERFACE_PROPERTY_URL &quot;url&quot;                                // [string]
+#define AI_INTERFACE_PROPERTY_SUPPORTED_LANGUAGES &quot;supportedLanguages&quot; // [string]
+#define AI_INTERFACE_PROPERTY_ENGINE_VERSION &quot;engineVersion&quot;           // [int] the engine version number the AI was compiled, but may work with newer or older ones too
+
+/**
+ * @brief struct Artificial Intelligence Interface Specifyer
+ */
+struct SAIInterfaceSpecifyer {
+	const char* shortName; // [may not contain: spaces, '_', '#']
+	const char* version; // [may not contain: spaces, '_', '#']
+};
+
+SAIInterfaceSpecifyer copySAIInterfaceSpecifyer(const struct SAIInterfaceSpecifyer* const orig);
+void deleteSAIInterfaceSpecifyer(const struct SAIInterfaceSpecifyer* const spec);
+
+#ifdef	__cplusplus
+struct SAIInterfaceSpecifyer_Comparator {
+	/**
+	 * The key comparison function, a Strict Weak Ordering;
+	 * it returns true if its first argument is less
+	 * than its second argument, and false otherwise.
+	 * This is also defined as map::key_compare.
+	 */
+	bool operator()(const struct SAIInterfaceSpecifyer&amp; a, const struct SAIInterfaceSpecifyer&amp; b) const;
+	static bool IsEmpty(const struct SAIInterfaceSpecifyer&amp; spec);
+};
+#endif /* __cplusplus */
+
+/**
+ * @brief struct Skirmish Artificial Intelligence Key
+ * Compleetly specifies a skirmish AI together with an interface.
+ */
+struct SSAIKey {
+#ifdef	__cplusplus
+	CR_DECLARE_STRUCT(SSAIKey);
+#endif /* __cplusplus */
+	struct SAIInterfaceSpecifyer interface;
+	struct SSAISpecifyer ai;
+};
+
+#ifdef	__cplusplus
+struct SSAIKey_Comparator {
+	/**
+	 * The key comparison function, a Strict Weak Ordering;
+	 * it returns true if its first argument is less
+	 * than its second argument, and false otherwise.
+	 * This is also defined as map::key_compare.
+	 */
+	bool operator()(const struct SSAIKey&amp; a, const struct SSAIKey&amp; b) const;
+	static bool IsEmpty(const struct SSAIKey&amp; key);
+};
+#endif /* __cplusplus */
+
+/**
+ * @brief struct Group Artificial Intelligence Key
+ * Compleetly specifies a group AI together with an interface.
+ */
+struct SGAIKey {
+#ifdef	__cplusplus
+	CR_DECLARE_STRUCT(SGAIKey);
+#endif /* __cplusplus */
+	struct SAIInterfaceSpecifyer interface;
+	struct SGAISpecifyer ai;
+};
+
+#ifdef	__cplusplus
+struct SGAIKey_Comparator {
+	/**
+	 * The key comparison function, a Strict Weak Ordering;
+	 * it returns true if its first argument is less
+	 * than its second argument, and false otherwise.
+	 * This is also defined as map::key_compare.
+	 */
+	bool operator()(const struct SGAIKey&amp; a, const struct SGAIKey&amp; b) const;
+	static bool IsEmpty(const struct SGAIKey&amp; key);
+};
+#endif /* __cplusplus */
+
+/**
+ * @brief struct Artificial Intelligence Interface
+ */
+struct SAIInterfaceLibrary {
+	// static interface library methods
+	int (CALLING_CONV *getInfos)(InfoItem infos[], int max); // static properties
+	enum LevelOfSupport (CALLING_CONV *getLevelOfSupportFor)(
+			const char* engineVersionString, int engineVersionNumber);
+	
+	// skirmish AI methods
+	int (CALLING_CONV *getSkirmishAISpecifyers)(struct SSAISpecifyer* sAISpecifyers, int max);
+	const struct SSAILibrary* (CALLING_CONV *loadSkirmishAILibrary)(const struct SSAISpecifyer* const sAISpecifyer);
+	int (CALLING_CONV *unloadSkirmishAILibrary)(const struct SSAISpecifyer* const sAISpecifyer);
+	int (CALLING_CONV *unloadAllSkirmishAILibraries)();
+	
+	// group AI methods
+	int (CALLING_CONV *getGroupAISpecifyers)(struct SGAISpecifyer* gAISpecifyers, int max);
+	const struct SGAILibrary* (CALLING_CONV *loadGroupAILibrary)(const struct SGAISpecifyer* const gAISpecifyer);
+	int (CALLING_CONV *unloadGroupAILibrary)(const struct SGAISpecifyer* const gAISpecifyer);
+	int (CALLING_CONV *unloadAllGroupAILibraries)();
+};
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SAIINTERFACELIBRARY_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,70 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SGAILibrary.h&quot;
+
+#include &quot;string.h&quot;
+
+
+SGAISpecifyer copySGAISpecifyer(const struct SGAISpecifyer* const orig) {
+	
+	struct SGAISpecifyer copy;
+	
+	char* tmpStr = (char *) malloc(sizeof(char) * (strlen(orig-&gt;shortName) + 1));
+	strcpy(tmpStr, orig-&gt;shortName);
+	copy.shortName = tmpStr;
+	
+	tmpStr = (char *) malloc(sizeof(char) * (strlen(orig-&gt;version) + 1));
+	strcpy(tmpStr, orig-&gt;version);
+	copy.version = tmpStr;
+	
+	return copy;
+}
+void deleteSGAISpecifyer(const struct SGAISpecifyer* const spec) {
+	free(const_cast&lt;char*&gt;(spec-&gt;shortName));
+	free(const_cast&lt;char*&gt;(spec-&gt;version));
+}
+
+#ifdef	__cplusplus
+bool SGAISpecifyer_Comparator::operator()(const struct SGAISpecifyer&amp; a, const struct SGAISpecifyer&amp; b) const {
+
+	bool isLess = false;
+	
+	int shortNameComp = strcmp(a.shortName, b.shortName);
+	if (shortNameComp &lt; 0) {
+		return isLess = true;
+	} else if (shortNameComp == 0) {
+		int versionComp = strcmp(a.version, b.version);
+		
+		if (versionComp &lt; 0) {
+			isLess = true;
+		}
+	}
+
+	return isLess;
+}
+bool SGAISpecifyer_Comparator::IsEmpty(const struct SGAISpecifyer&amp; spec) {
+	
+	bool empty = false;
+	
+	if (spec.shortName == NULL || spec.version == NULL) {
+		empty = true;
+	}
+	
+	return empty;
+}
+#endif /* __cplusplus */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,109 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SGAILIBRARY_H
+#define	_SGAILIBRARY_H
+
+#ifdef	__cplusplus
+#include &quot;creg/creg.h&quot;
+#endif /* __cplusplus */
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;SInfo.h&quot;
+#include &quot;SOption.h&quot;
+#include &quot;ELevelOfSupport.h&quot;
+#include &quot;exportdefines.h&quot;
+
+#define GROUP_AI_PROPERTY_FILE_NAME &quot;fileName&quot;                      // [string] when the library file is &quot;libRAI-0.600.so&quot; or &quot;RAI-0.600.dll&quot;, this value should be &quot;RAI-0.600&quot;
+#define GROUP_AI_PROPERTY_SHORT_NAME &quot;shortName&quot;                    // [string: [a-zA-Z0-9_.]*]
+#define GROUP_AI_PROPERTY_VERSION &quot;version&quot;                         // [string: [a-zA-Z0-9_.]*]
+#define GROUP_AI_PROPERTY_NAME &quot;name&quot;                               // [string]
+#define GROUP_AI_PROPERTY_DESCRIPTION &quot;description&quot;                 // [string]
+#define GROUP_AI_PROPERTY_URL &quot;url&quot;                                 // [string]
+#define GROUP_AI_PROPERTY_LOAD_SUPPORTED &quot;loadSupported&quot;            // [bool: &quot;yes&quot; | &quot;no&quot;]
+#define GROUP_AI_PROPERTY_ENGINE_VERSION &quot;engineVersion&quot;            // [int] the engine version number the AI was compiled, but may work with newer or older ones too
+#define GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME &quot;interfaceShortName&quot; // [string: [a-zA-Z0-9_.]*] this interface has to be used to load the AI
+#define GROUP_AI_PROPERTY_INTERFACE_VERSION &quot;interfaceVersion&quot;      // [string: [a-zA-Z0-9_.]*] the interface version number the AI was compiled, but may work with newer or older ones too
+
+/**
+ * @brief struct Group Artificial Intelligence Specifyer
+ */
+struct SGAISpecifyer {
+	const char* shortName; // [may not contain: spaces, '_', '#']
+	const char* version; // [may not contain: spaces, '_', '#']
+};
+
+SGAISpecifyer copySGAISpecifyer(const struct SGAISpecifyer* const orig);
+void deleteSGAISpecifyer(const struct SGAISpecifyer* const spec);
+
+#ifdef	__cplusplus
+struct SGAISpecifyer_Comparator {
+	/**
+	 * The key comparison function, a Strict Weak Ordering;
+	 * it returns true if its first argument is less
+	 * than its second argument, and false otherwise.
+	 * This is also defined as map::key_compare.
+	 */
+	bool operator()(const struct SGAISpecifyer&amp; a, const struct SGAISpecifyer&amp; b) const;
+	static bool IsEmpty(const struct SGAISpecifyer&amp; spec);
+};
+#endif /* __cplusplus */
+
+/**
+ * @brief struct Group Artificial Intelligence
+ * This is the interface between the engine and an implementation of a Skirmish AI.
+ */
+struct SGAILibrary {
+	// static AI library functions
+	/**
+	 * Level of Support for a specific engine version.
+	 * NOTE: this method is optional. An AI not exporting this function is still
+	 * valid.
+	 * @return 0: perfectly supported, &gt; 0: some issues, &lt; 0: crashing/not supported
+	 */
+	enum LevelOfSupport (CALLING_CONV *getLevelOfSupportFor)(
+			const char* engineVersionString, int engineVersionNumber,
+			const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+	/**
+	 * Returns static properties with info about this AI library.
+	 * NOTE: this method is optional. An AI not exporting this function is still
+	 * valid.
+	 * @return number of elements stored into parameter infos
+	 */
+	int (CALLING_CONV *getInfos)(InfoItem infos[], int max);
+	/**
+	 * Returns options that can be set on this AI.
+	 * NOTE: this method is optional. An AI not exporting this function is still
+	 * valid.
+	 * @return number of elements stored into parameter options
+	 */
+	int (CALLING_CONV *getOptions)(struct Option optionsInfo[], int max);
+
+	// team and group instance functions
+	int (CALLING_CONV *init)(int teamId, int groupId);
+	int (CALLING_CONV *release)(int teamId, int groupId);
+	int (CALLING_CONV *handleEvent)(int teamId, int groupId, int topic, const void* data);
+};
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SGAILIBRARY_H */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,170 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+//#ifndef _SINFO_CPP
+//#define	_SINFO_CPP
+
+#include &quot;SInfo.h&quot;
+
+#include &quot;string.h&quot;
+#include &quot;System/StdAfx.h&quot;
+
+
+InfoItem copyInfoItem(const struct InfoItem* const orig) {
+	
+	struct InfoItem copy;
+	
+	copy.key = mallocCopyString(orig-&gt;key);
+	
+	copy.value = mallocCopyString(orig-&gt;value);
+	
+	if (orig-&gt;desc != NULL) {
+		copy.desc = mallocCopyString(orig-&gt;desc);
+	} else {
+		copy.desc = NULL;
+	}
+	
+	return copy;
+}
+void deleteInfoItem(const struct InfoItem* const info) {
+	
+	freeString(info-&gt;key);
+	freeString(info-&gt;value);
+	freeString(info-&gt;desc);
+	
+	InfoItem* const mutableInfo = const_cast&lt;InfoItem* const&gt;(info);
+	mutableInfo-&gt;key = NULL;
+	mutableInfo-&gt;value = NULL;
+	mutableInfo-&gt;desc = NULL;
+}
+
+#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI)
+#include &quot;StdAfx.h&quot;
+#include &lt;cstdlib&gt;
+#include &quot;Lua/LuaParser.h&quot;
+
+#include &lt;set&gt;
+
+static const char* badKeyChars = &quot; =;\r\n\t&quot;;
+
+bool ParseInfo(const LuaTable&amp; root, int index, InfoItem&amp; info, std::set&lt;std::string&gt; infosSet)
+{
+	const LuaTable&amp; infoTbl = root.SubTable(index);
+	if (!infoTbl.IsValid()) {
+		return false;
+	}
+
+	// info properties
+	std::string info_key = infoTbl.GetString(&quot;key&quot;, &quot;&quot;);
+	if (info_key.empty() ||
+	    (info_key.find_first_of(badKeyChars) != std::string::npos)) {
+		return false;
+	}
+	std::string keyLower = StringToLower(info_key);
+	if (infosSet.find(keyLower) != infosSet.end()) {
+		return false;
+	}
+	info.key = mallocCopyString(info_key.c_str());
+	
+	std::string info_value = infoTbl.GetString(&quot;value&quot;, &quot;&quot;);
+	if (info_value.empty()) {
+		return false;
+	}
+	info.value = mallocCopyString(info_value.c_str());
+	
+	std::string info_desc = infoTbl.GetString(&quot;desc&quot;, &quot;&quot;);
+	if (info_desc.empty()) {
+		info.desc = NULL;
+	} else {
+		info.desc = mallocCopyString(info_desc.c_str());
+	}
+
+	infosSet.insert(keyLower);
+
+	return true;
+}
+
+/*
+std::vector&lt;InfoItem&gt; ParseInfos(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes)
+{
+	std::vector&lt;InfoItem&gt; infos;
+	
+	LuaParser luaParser(fileName, fileModes, accessModes);
+		
+	if (!luaParser.Execute()) {
+		printf(&quot;ParseInfos(%s) ERROR: %s\n&quot;,
+		       fileName.c_str(), luaParser.GetErrorLog().c_str());
+		return infos;
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+	if (!root.IsValid()) {
+		return infos;
+	}
+
+	std::set&lt;std::string&gt; infosSet;
+	for (int index = 1; root.KeyExists(index); index++) {
+		InfoItem info;
+		if (ParseInfo(root, index, info, infosSet)) {
+			infos.push_back(info);
+		}
+	}
+	
+	return infos;
+}
+*/
+unsigned int ParseInfos(
+		const char* fileName,
+		const char* fileModes,
+		const char* accessModes,
+		InfoItem infos[], unsigned int max)
+{
+	LuaParser luaParser(fileName, fileModes, accessModes);
+		
+	if (!luaParser.Execute()) {
+		printf(&quot;ParseInfos(%s) ERROR: %s\n&quot;,
+		       fileName, luaParser.GetErrorLog().c_str());
+		return 0;
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+	if (!root.IsValid()) {
+		return 0;
+	}
+
+	unsigned int i = 0;
+	std::set&lt;std::string&gt; infosSet;
+	for (int index = 1; root.KeyExists(index) &amp;&amp; i &lt; max; index++) {
+		InfoItem info;
+		if (ParseInfo(root, index, info, infosSet)) {
+			infos[i++] = info;
+		}
+	}
+	
+	return i;
+}
+unsigned int ParseInfosRawFileSystem(
+		const char* fileName,
+		InfoItem infos[], unsigned int max) {
+	return ParseInfos(fileName, SPRING_VFS_RAW, SPRING_VFS_RAW, infos, max);
+}
+#endif	/* defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) */
+
+//#endif	/* _SINFO_CPP */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SInfo.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SInfo.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,62 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+// The structs in this files relate to *Infos.lua files
+// They are used for AIs eg (-&gt; AIInfo.lua)
+
+#ifndef _SINFO_H
+#define	_SINFO_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct InfoItem {
+	const char* key;
+	const char* value;
+	const char* desc;
+};
+
+InfoItem copyInfoItem(const struct InfoItem* const orig);
+void deleteInfoItem(const struct InfoItem* const info);
+
+#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI)
+unsigned int ParseInfos(
+		const char* fileName,
+		const char* fileModes,
+		const char* accessModes,
+		InfoItem infos[], unsigned int max);
+unsigned int ParseInfosRawFileSystem(
+		const char* fileName,
+		InfoItem infos[], unsigned int max);
+#endif	/* defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) */
+
+#ifdef	__cplusplus
+}
+#endif
+
+//#ifdef	__cplusplus
+//#include &lt;vector&gt;
+//#include &lt;string&gt;
+//std::vector&lt;InfoItem&gt; ParseInfos(
+//		const std::string&amp; fileName,
+//		const std::string&amp; fileModes,
+//		const std::string&amp; accessModes);
+//#endif
+
+#endif	/* _SINFO_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SInfo.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,193 @@
+
+#ifndef _SOPTION_CPP
+#define	_SOPTION_CPP
+
+#include &quot;SOption.h&quot;
+
+#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI)
+#include &quot;System/StdAfx.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/MapParser.h&quot;
+
+#include &lt;set&gt;
+
+static const char* badKeyChars = &quot; =;\r\n\t&quot;;
+
+
+bool ParseOption(const LuaTable&amp; root, int index, Option&amp; opt, std::set&lt;std::string&gt; optionsSet)
+{
+	const LuaTable&amp; optTbl = root.SubTable(index);
+	if (!optTbl.IsValid()) {
+		return false;
+	}
+
+	// common options properties
+	std::string opt_key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
+	if (opt_key.empty() ||
+	    (opt_key.find_first_of(badKeyChars) != std::string::npos)) {
+		return false;
+	}
+	opt_key = StringToLower(opt_key);
+	if (optionsSet.find(opt_key) != optionsSet.end()) {
+		return false;
+	}
+	//opt.key = opt_key.c_str();
+	opt.key = mallocCopyString(opt_key.c_str());
+	std::string opt_name = optTbl.GetString(&quot;name&quot;, opt_key);
+	if (opt_name.empty()) {
+		return false;
+	}
+	//opt.name = opt_name.c_str();
+	opt.name = mallocCopyString(opt_name.c_str());
+	std::string opt_desc = optTbl.GetString(&quot;desc&quot;, opt_name);
+	//opt.desc = opt_desc.c_str();
+	opt.desc = mallocCopyString(opt_desc.c_str());
+	
+
+	std::string opt_type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
+	opt_type = StringToLower(opt_type);
+	//opt.type = opt_type.c_str();
+	opt.type = mallocCopyString(opt_type.c_str());
+
+	// option type specific properties
+	if (opt_type == &quot;bool&quot;) {
+		opt.typeCode = opt_bool;
+		opt.boolDef = optTbl.GetBool(&quot;def&quot;, false);
+	}
+	else if (opt_type == &quot;number&quot;) {
+		opt.typeCode = opt_number;
+		opt.numberDef  = optTbl.GetFloat(&quot;def&quot;,  0.0f);
+		opt.numberMin  = optTbl.GetFloat(&quot;min&quot;,  -1.0e30f);
+		opt.numberMax  = optTbl.GetFloat(&quot;max&quot;,  +1.0e30f);
+		opt.numberStep = optTbl.GetFloat(&quot;step&quot;, 0.0f);
+	}
+	else if (opt_type == &quot;string&quot;) {
+		opt.typeCode = opt_string;
+		//opt.stringDef    = optTbl.GetString(&quot;def&quot;, &quot;&quot;).c_str();
+		opt.stringDef    = mallocCopyString(optTbl.GetString(&quot;def&quot;, &quot;&quot;).c_str());
+		opt.stringMaxLen = optTbl.GetInt(&quot;maxlen&quot;, 0);
+	}
+	else if (opt_type == &quot;list&quot;) {
+		opt.typeCode = opt_list;
+
+		const LuaTable&amp; listTbl = optTbl.SubTable(&quot;items&quot;);
+		if (!listTbl.IsValid()) {
+			return false;
+		}
+
+		vector&lt;OptionListItem&gt; opt_list;
+		for (int i = 1; listTbl.KeyExists(i); i++) {
+			OptionListItem item;
+
+			// string format
+			std::string item_key = listTbl.GetString(i, &quot;&quot;);
+			if (!item_key.empty() &amp;&amp;
+			    (item_key.find_first_of(badKeyChars) == string::npos)) {
+				//item.key = item_key.c_str();
+				item.key = mallocCopyString(item_key.c_str());
+				item.name = item.key;
+				item.desc = item.name;
+				opt_list.push_back(item);
+				continue;
+			}
+
+			// table format  (name &amp; desc)
+			const LuaTable&amp; itemTbl = listTbl.SubTable(i);
+			if (!itemTbl.IsValid()) {
+				break;
+			}
+			item_key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
+			if (item_key.empty() ||
+			    (item_key.find_first_of(badKeyChars) != string::npos)) {
+				return false;
+			}
+			item_key = StringToLower(item_key);
+			//item.key = item_key.c_str();
+			item.key = mallocCopyString(item_key.c_str());
+			std::string item_name = itemTbl.GetString(&quot;name&quot;, item_key);
+			if (item_name.empty()) {
+				return false;
+			}
+			//item.name = item_name.c_str();
+			item.name = mallocCopyString(item_name.c_str());
+			std::string item_desc = itemTbl.GetString(&quot;desc&quot;, item_name);
+			//item.desc = item_desc.c_str();
+			item.desc = mallocCopyString(item_desc.c_str());
+			opt_list.push_back(item);
+		}
+
+		if (opt_list.size() &lt;= 0) {
+			return false; // no empty lists
+		}
+		
+		opt.numListItems = opt_list.size();
+		opt.list = (OptionListItem*) calloc(sizeof(OptionListItem), opt.numListItems);
+        for (int i=0; i &lt; opt.numListItems; ++i) {
+            opt.list[i] = opt_list.at(i);
+        }
+
+		//opt.listDef = optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str();
+		opt.listDef = mallocCopyString(optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str());
+	}
+	else {
+		return false; // unknown type
+	}
+
+	optionsSet.insert(opt.key);
+
+	return true;
+}
+
+
+/*
+std::vector&lt;Option&gt; ParseOptions(const std::string&amp; fileName,
+                         const std::string&amp; fileModes,
+                         const std::string&amp; accessModes,
+                         const std::string&amp; mapName)
+*/
+int ParseOptions(
+		const char* fileName,
+		const char* fileModes,
+		const char* accessModes,
+		const char* mapName,
+		Option options[], unsigned int max)
+{
+	//std::vector&lt;Option&gt; options;
+
+	LuaParser luaParser(fileName, fileModes, accessModes);
+
+	const string configName = MapParser::GetMapConfigName(mapName);
+
+	if (!std::string(mapName).empty() &amp;&amp; !configName.empty()) {
+		luaParser.GetTable(&quot;Map&quot;);
+		luaParser.AddString(&quot;fileName&quot;, mapName);
+		luaParser.AddString(&quot;fullName&quot;, std::string(&quot;maps/&quot;) + mapName);
+		luaParser.AddString(&quot;configFile&quot;, configName);
+		luaParser.EndTable();
+	}
+		
+	if (!luaParser.Execute()) {
+		printf(&quot;ParseOptions(%s) ERROR: %s\n&quot;,
+		       fileName, luaParser.GetErrorLog().c_str());
+		return 0;
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+	if (!root.IsValid()) {
+		return 0;
+	}
+
+	std::set&lt;std::string&gt; optionsSet;
+	int i = 0;
+	for (int index = 1; root.KeyExists(index) &amp;&amp; i &lt; (int)max; index++) {
+		Option opt;
+		if (ParseOption(root, index, opt, optionsSet)) {
+			options[i++] = opt;
+		}
+	}
+
+	return i;
+}
+#endif	/* defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) */
+
+#endif	/* _SOPTION_CPP */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SOption.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SOption.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SOption.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,79 @@
+// The structs in this files relate to *Options.lua files
+// They are used for Mods and Skirmish AIs eg
+
+#ifndef _SOPTION_H
+#define	_SOPTION_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+struct OptionListItem {
+	const char* key;
+	const char* name;
+	const char* desc;
+};
+
+enum OptionType {
+	opt_error  = 0,
+	opt_bool   = 1,
+	opt_list   = 2,
+	opt_number = 3,
+	opt_string = 4
+};
+
+struct Option {
+#ifdef	__cplusplus
+	Option() : typeCode(opt_error) {}
+#endif
+
+	const char* key;
+	const char* name;
+	const char* desc;
+
+	const char* type; // &quot;bool&quot;, &quot;number&quot;, &quot;string&quot;, &quot;list&quot;, ... (see enum OptionType)
+
+	OptionType typeCode;
+
+	bool   boolDef;
+
+	float  numberDef;
+	float  numberMin;
+	float  numberMax;
+	float  numberStep; // aligned to numberDef
+
+	const char* stringDef;
+	int    stringMaxLen;
+
+	const char* listDef;
+	//vector&lt;ListItem&gt; list;
+	int numListItems;
+	OptionListItem* list;
+};
+
+#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI)
+int ParseOptions(
+		const char* fileName,
+		const char* fileModes,
+		const char* accessModes,
+		const char* mapName,
+		Option options[], unsigned int max);
+#endif	/* defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) */
+
+#ifdef	__cplusplus
+}
+#endif
+
+
+//#ifdef	__cplusplus
+//#include &lt;vector&gt;
+//#include &lt;string&gt;
+//std::vector&lt;Option&gt; ParseOptions(const std::string&amp; fileName,
+//                         const std::string&amp; fileModes,
+//                         const std::string&amp; accessModes,
+//                         const std::string&amp; mapName = &quot;&quot;);
+//#endif
+
+
+#endif	/* _SOPTION_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SOption.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,83 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SSAILibrary.h&quot;
+
+#include &quot;string.h&quot;
+//#include &quot;LogOutput.h&quot;
+
+
+SSAISpecifyer copySSAISpecifyer(const struct SSAISpecifyer* const orig) {
+	
+	struct SSAISpecifyer copy;
+	
+	char* tmpStr = (char *) malloc(sizeof(char) * (strlen(orig-&gt;shortName) + 1));
+	strcpy(tmpStr, orig-&gt;shortName);
+	copy.shortName = tmpStr;
+	
+	tmpStr = (char *) malloc(sizeof(char) * (strlen(orig-&gt;version) + 1));
+	strcpy(tmpStr, orig-&gt;version);
+	copy.version = tmpStr;
+	
+	return copy;
+}
+void deleteSSAISpecifyer(const struct SSAISpecifyer* const spec) {
+	free(const_cast&lt;char*&gt;(spec-&gt;shortName));
+	free(const_cast&lt;char*&gt;(spec-&gt;version));
+}
+
+#ifdef	__cplusplus
+bool SSAISpecifyer_Comparator::operator()(const struct SSAISpecifyer&amp; a, const struct SSAISpecifyer&amp; b) const {
+
+	bool isLess = false;
+	
+	int shortNameComp = strcmp(a.shortName, b.shortName);
+	if (shortNameComp &lt; 0) {
+		return isLess = true;
+	} else if (shortNameComp == 0) {
+		int versionComp = strcmp(a.version, b.version);
+		
+		if (versionComp &lt; 0) {
+			isLess = true;
+		}
+	}
+
+	return isLess;
+}
+bool SSAISpecifyer_Comparator::IsEmpty(const struct SSAISpecifyer&amp; spec) {
+	
+	bool empty = false;
+	
+	if (spec.shortName == NULL || spec.version == NULL) {
+		empty = true;
+	}
+	
+	return empty;
+}
+#endif /* __cplusplus */
+
+//char* SSAISpecifyer_toString(const SSAISpecifyer* sSAISpecifyer) {
+//
+//	char *spec = (char *)calloc(strlen(sSAISpecifyer-&gt;shortName) +
+//			strlen(sSAISpecifyer-&gt;version) + 1 + 1, sizeof(char));
+//
+//	strcpy(spec, sSAISpecifyer-&gt;shortName);
+//	strcat(spec, &quot;#&quot;);
+//	strcat(spec, sSAISpecifyer-&gt;version);
+//
+//	return spec;
+//}


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,109 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SSAILIBRARY_H
+#define	_SSAILIBRARY_H
+
+#ifdef	__cplusplus
+#include &quot;creg/creg.h&quot;
+#endif /* __cplusplus */
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;SInfo.h&quot;
+#include &quot;SOption.h&quot;
+#include &quot;ELevelOfSupport.h&quot;
+#include &quot;exportdefines.h&quot;
+
+#define SKIRMISH_AI_PROPERTY_FILE_NAME &quot;fileName&quot;                      // [string] when the library file is &quot;libRAI-0.600.so&quot; or &quot;RAI-0.600.dll&quot;, this value should be &quot;RAI-0.600&quot;
+#define SKIRMISH_AI_PROPERTY_SHORT_NAME &quot;shortName&quot;                    // [string: [a-zA-Z0-9_.]*]
+#define SKIRMISH_AI_PROPERTY_VERSION &quot;version&quot;                         // [string: [a-zA-Z0-9_.]*]
+#define SKIRMISH_AI_PROPERTY_NAME &quot;name&quot;                               // [string]
+#define SKIRMISH_AI_PROPERTY_DESCRIPTION &quot;description&quot;                 // [string]
+#define SKIRMISH_AI_PROPERTY_URL &quot;url&quot;                                 // [string]
+#define SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED &quot;loadSupported&quot;            // [bool: &quot;yes&quot; | &quot;no&quot;]
+#define SKIRMISH_AI_PROPERTY_ENGINE_VERSION &quot;engineVersion&quot;            // [int] the engine version number the AI was compiled, but may work with newer or older ones too
+#define SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME &quot;interfaceShortName&quot; // [string: [a-zA-Z0-9_.]*] this interface has to be used to load the AI
+#define SKIRMISH_AI_PROPERTY_INTERFACE_VERSION &quot;interfaceVersion&quot;      // [string: [a-zA-Z0-9_.]*] the interface version number the AI was compiled, but may work with newer or older ones too
+
+/**
+ * @brief struct Skirmish Artificial Intelligence Specifyer
+ */
+struct SSAISpecifyer {
+	const char* shortName; // [may not contain: spaces, '_', '#']
+	const char* version; // [may not contain: spaces, '_', '#']
+};
+
+SSAISpecifyer copySSAISpecifyer(const struct SSAISpecifyer* const orig);
+void deleteSSAISpecifyer(const struct SSAISpecifyer* const spec);
+
+#ifdef	__cplusplus
+struct SSAISpecifyer_Comparator {
+	/**
+	 * The key comparison function, a Strict Weak Ordering;
+	 * it returns true if its first argument is less
+	 * than its second argument, and false otherwise.
+	 * This is also defined as map::key_compare.
+	 */
+	bool operator()(const struct SSAISpecifyer&amp; a, const struct SSAISpecifyer&amp; b) const;
+	static bool IsEmpty(const struct SSAISpecifyer&amp; spec);
+};
+#endif /* __cplusplus */
+
+/**
+ * @brief struct Skirmish Artificial Intelligence
+ * This is the interface between the engine and an implementation of a Skirmish AI.
+ */
+struct SSAILibrary {
+	// static AI library functions
+	/**
+	 * Level of Support for a specific engine version.
+	 * NOTE: this method is optional. An AI not exporting this function is still
+	 * valid.
+	 * @return 0: perfectly supported, &gt; 0: some issues, &lt; 0: crashing/not supported
+	 */
+	enum LevelOfSupport (CALLING_CONV *getLevelOfSupportFor)(
+			const char* engineVersionString, int engineVersionNumber,
+			const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+	/**
+	 * Returns static properties with info about this AI library.
+	 * NOTE: this method is optional. An AI not exporting this function is still
+	 * valid.
+	 * @return number of elements stored into parameter infos
+	 */
+	int (CALLING_CONV *getInfos)(InfoItem infos[], int max);
+	/**
+	 * Returns options that can be set on this AI.
+	 * NOTE: this method is optional. An AI not exporting this function is still
+	 * valid.
+	 * @return number of elements stored into parameter options
+	 */
+	int (CALLING_CONV *getOptions)(struct Option options[], int max);
+
+	// team instance functions
+	int (CALLING_CONV *init)(int teamId);
+	int (CALLING_CONV *release)(int teamId);
+	int (CALLING_CONV *handleEvent)(int teamId, int topic, const void* data);
+};
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _SSAILIBRARY_H */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/Interface/aidefines.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/aidefines.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/Interface/aidefines.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,66 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIDEFINES_H
+#define	_AIDEFINES_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;exportdefines.h&quot;
+
+#include &quot;SAIFloat3.h&quot;
+
+#include &quot;Game/GameVersion.h&quot;
+
+#define ENGINE_VERSION_STRING VERSION_STRING
+#define ENGINE_VERSION_NUMBER 1000
+
+// TODO: comment toggle the two following lines
+// !!!absolute paths are needed when debugging!!!
+//#define PATH_TO_SPRING_HOME &quot;/home/robin/svn_work/robin/Development/Projects/Others/spring_C_AI_interface/game_linux/&quot;
+//#define PATH_TO_SPRING_HOME &quot;P:/svn_work/robin/Development/Projects/Others/spring_current/game/&quot;
+#define PATH_TO_SPRING_HOME &quot;&quot;
+
+/**
+ * @brief max skirmish AIs
+ *
+ * Defines the maximum number of skirmish AIs.
+ * As there can not be more then spring allows teams, this is the upper limit.
+ * (currently (July 2008) 16 real teams)
+ */
+//const unsigned int MAX_SKIRMISH_AIS = MAX_TEAMS - 1;
+#define MAX_SKIRMISH_AIS 16
+
+//const char* const AI_INTERFACES_DIR = &quot;AI/interfaces&quot;;
+//#define AI_INTERFACES_DIR &quot;AI/interfaces&quot;
+#define AI_INTERFACES_IMPLS_DIR &quot;AI/Interfaces/impls&quot;
+#define AI_INTERFACES_DATA_DIR &quot;AI/Interfaces/data&quot;
+//#define AI_INTERFACES_LOGS_DIR &quot;AI/Interfaces/logs&quot;
+
+#define SKIRMISH_AI_IMPLS_DIR &quot;AI/Skirmish/impls&quot;
+#define SKIRMISH_AI_DATA_DIR &quot;AI/Skirmish/data&quot;
+
+#define GROUP_AI_IMPLS_DIR &quot;AI/Group/impls&quot;
+#define GROUP_AI_DATA_DIR &quot;AI/Group/data&quot;
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _AIDEFINES_H */


Property changes on: branches/caiinterface/rts/ExternalAI/Interface/aidefines.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/ExternalAI/SAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,4 +1,6 @@
 /*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -13,7 +15,7 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#include &quot;SAICallback.h&quot;
+#include &quot;Interface/SAICallback.h&quot;
 
 #include &quot;IGlobalAICallback.h&quot;
 #include &quot;IAICallback.h&quot;
@@ -22,13 +24,13 @@
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
-#include &quot;AISCommands.h&quot;
+#include &quot;Interface/AISCommands.h&quot;
 
 
-IGlobalAICallback* team_globalCallback[MAX_AIS];
-IAICallback* team_callback[MAX_AIS];
-bool team_cheatingEnabled[MAX_AIS];
-IAICheats* team_cheatCallback[MAX_AIS];
+IGlobalAICallback* team_globalCallback[MAX_SKIRMISH_AIS];
+IAICallback* team_callback[MAX_SKIRMISH_AIS];
+bool team_cheatingEnabled[MAX_SKIRMISH_AIS];
+IAICheats* team_cheatCallback[MAX_SKIRMISH_AIS];
 
 int fillCMap(const std::map&lt;std::string,std::string&gt;* map, const char* cMap[][2]) {
 	std::map&lt;std::string,std::string&gt;::const_iterator it;
@@ -92,7 +94,7 @@
 	return ret;
 }
 
-int _handleCommand(int teamId, int toId, int commandId, int commandTopic, void* commandData) {
+Export(int) _handleCommand(int teamId, int toId, int commandId, int commandTopic, void* commandData) {
 
 	int ret = 0;
 
@@ -1279,7 +1281,7 @@
 
 
 //##############################################################################
-bool _Cheats_isEnabled(int teamId) {
+Export(bool) _Cheats_isEnabled(int teamId) {
 	team_cheatCallback[teamId] = NULL;
 	if (team_cheatingEnabled[teamId]) {
 		team_cheatCallback[teamId] = team_globalCallback[teamId]-&gt;GetCheatInterface();
@@ -1287,7 +1289,7 @@
 	return team_cheatCallback[teamId] != NULL;
 }
 
-bool _Cheats_setEnabled(int teamId, bool enabled) {
+Export(bool) _Cheats_setEnabled(int teamId, bool enabled) {
 //	bool isEnabled = _Cheats_isEnabled(teamId);
 //	
 //	if (enabled != isEnabled) {
@@ -1307,7 +1309,7 @@
 	return enabled == _Cheats_isEnabled(teamId);
 }
 
-bool _Cheats_setEventsEnabled(int teamId, bool enabled) {
+Export(bool) _Cheats_setEventsEnabled(int teamId, bool enabled) {
 	if (_Cheats_isEnabled(teamId)) {
 		team_cheatCallback[teamId]-&gt;EnableCheatEvents(enabled);
 		return true;
@@ -1316,7 +1318,7 @@
 	}
 }
 
-bool _Cheats_isOnlyPassive(int teamId) {
+Export(bool) _Cheats_isOnlyPassive(int teamId) {
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;OnlyPassiveCheats();
 	} else {
@@ -1324,31 +1326,31 @@
 	}
 }
 
-int _Game_getAiInterfaceVersion(int teamId) {
+Export(int) _Game_getAiInterfaceVersion(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return wrapper_HandleCommand(clb, NULL, AIHCQuerySubVersionId, NULL);
 }
 
-bool _Map_isPosInCamera(int teamId, SAIFloat3 pos, float radius) {
+Export(bool) _Map_isPosInCamera(int teamId, SAIFloat3 pos, float radius) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;PosInCamera(SAIFloat3(pos), radius);
 }
 
-int _Game_getCurrentFrame(int teamId) {
+Export(int) _Game_getCurrentFrame(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetCurrentFrame();
 }
 
-int _Game_getMyTeam(int teamId) {
+Export(int) _Game_getMyTeam(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMyTeam();
 }
 
-int _Game_getMyAllyTeam(int teamId) {
+Export(int) _Game_getMyAllyTeam(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMyAllyTeam();
 }
 
-int _Game_getPlayerTeam(int teamId, int player) {
+Export(int) _Game_getPlayerTeam(int teamId, int player) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetPlayerTeam(player);
 }
 
-const char* _Game_getTeamSide(int teamId, int team) {
+Export(const char*) _Game_getTeamSide(int teamId, int team) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetTeamSide(team);
 }
 
@@ -1356,7 +1358,7 @@
 
 
 
-int _WeaponDef_STATIC_getNumDamageTypes(int teamId) {
+Export(int) _WeaponDef_STATIC_getNumDamageTypes(int teamId) {
     int numDamageTypes;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numDamageTypes);
@@ -1365,7 +1367,7 @@
     }
     return numDamageTypes;
 }
-unsigned int _Map_getChecksum(int teamId) {
+Export(unsigned int) _Map_getChecksum(int teamId) {
     unsigned int checksum;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_MAP_CHECKSUM, &amp;checksum);
@@ -1375,7 +1377,7 @@
     return checksum;
 }
 
-bool _Game_isExceptionHandlingEnabled(int teamId) {
+Export(bool) _Game_isExceptionHandlingEnabled(int teamId) {
     bool exceptionHandlingEnabled;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_EXCEPTION_HANDLING, &amp;exceptionHandlingEnabled);
@@ -1384,7 +1386,7 @@
     }
     return exceptionHandlingEnabled;
 }
-bool _Game_isDebugModeEnabled(int teamId) {
+Export(bool) _Game_isDebugModeEnabled(int teamId) {
     bool debugModeEnabled;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_DEBUG_MODE, &amp;debugModeEnabled);
@@ -1393,7 +1395,7 @@
     }
     return debugModeEnabled;
 }
-int _Game_getMode(int teamId) {
+Export(int) _Game_getMode(int teamId) {
     int mode;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_MODE, &amp;mode);
@@ -1402,7 +1404,7 @@
     }
     return mode;
 }
-bool _Game_isPaused(int teamId) {
+Export(bool) _Game_isPaused(int teamId) {
     bool paused;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_PAUSED, &amp;paused);
@@ -1411,7 +1413,7 @@
     }
     return paused;
 }
-float _Game_getSpeedFactor(int teamId) {
+Export(float) _Game_getSpeedFactor(int teamId) {
     float speedFactor;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_SPEED_FACTOR, &amp;speedFactor);
@@ -1421,7 +1423,7 @@
     return speedFactor;
 }
 
-float _Gui_getViewRange(int teamId) {
+Export(float) _Gui_getViewRange(int teamId) {
     float viewRange;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_VIEW_RANGE, &amp;viewRange);
@@ -1430,7 +1432,7 @@
     }
     return viewRange;
 }
-float _Gui_getScreenX(int teamId) {
+Export(float) _Gui_getScreenX(int teamId) {
     float screenX;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENX, &amp;screenX);
@@ -1439,7 +1441,7 @@
     }
     return screenX;
 }
-float _Gui_getScreenY(int teamId) {
+Export(float) _Gui_getScreenY(int teamId) {
     float screenY;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENY, &amp;screenY);
@@ -1448,7 +1450,7 @@
     }
     return screenY;
 }
-SAIFloat3 _Gui_Camera_getDirection(int teamId) {
+Export(SAIFloat3) _Gui_Camera_getDirection(int teamId) {
     float3 cameraDir;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_DIR, &amp;cameraDir);
@@ -1457,7 +1459,7 @@
     }
     return cameraDir.toSAIFloat3();
 }
-SAIFloat3 _Gui_Camera_getPosition(int teamId) {
+Export(SAIFloat3) _Gui_Camera_getPosition(int teamId) {
     float3 cameraPosition;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_POS, &amp;cameraPosition);
@@ -1467,16 +1469,16 @@
     return cameraPosition.toSAIFloat3();
 }
 
-bool _File_locateForReading(int teamId, char* filename) {
+Export(bool) _File_locateForReading(int teamId, char* filename) {
 	IAICallback* clb = team_callback[teamId];
     return clb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename);
 }
-bool _File_locateForWriting(int teamId, char* filename) {
+Export(bool) _File_locateForWriting(int teamId, char* filename) {
 	IAICallback* clb = team_callback[teamId];
     return clb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
 }
 
-int _Unit_STATIC_getLimit(int teamId) {
+Export(int) _Unit_STATIC_getLimit(int teamId) {
     int unitLimit;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_UNIT_LIMIT, &amp;unitLimit);
@@ -1485,7 +1487,7 @@
     }
     return unitLimit;
 }
-const char* _Game_getSetupScript(int teamId) {
+Export(const char*) _Game_getSetupScript(int teamId) {
     const char* setupScript;
 	IAICallback* clb = team_callback[teamId];
     bool fetchOk = clb-&gt;GetValue(AIVAL_SCRIPT, &amp;setupScript);
@@ -1502,7 +1504,7 @@
 
 
 //########### BEGINN UnitDef
-int _UnitDef_STATIC_getIds(int teamId, int* list) {
+Export(int) _UnitDef_STATIC_getIds(int teamId, int* list) {
 	IAICallback* clb = team_callback[teamId];
 	int numUnitDefs = clb-&gt;GetNumUnitDefs();
 	const UnitDef** defList = (const UnitDef**) new UnitDef*[numUnitDefs];
@@ -1514,236 +1516,244 @@
 	delete [] defList;
 	return numUnitDefs;
 }
-int _UnitDef_STATIC_getIdByName(int teamId, const char* unitName) {
+Export(int) _UnitDef_STATIC_getIdByName(int teamId, const char* unitName) {
+	
+	int unitDefId = -1;
+	
 	IAICallback* clb = team_callback[teamId];
-	return clb-&gt;GetUnitDef(unitName)-&gt;id;
+	const UnitDef* ud = clb-&gt;GetUnitDef(unitName);
+	if (ud != NULL) {
+		unitDefId = ud-&gt;id;
+	}
+	
+	return unitDefId;
 }
 
-float _UnitDef_getHeight(int teamId, int unitDefId) {
+Export(float) _UnitDef_getHeight(int teamId, int unitDefId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitDefHeight(unitDefId);
 }
-float _UnitDef_getRadius(int teamId, int unitDefId) {
+Export(float) _UnitDef_getRadius(int teamId, int unitDefId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitDefRadius(unitDefId);
 }
 
-bool _UnitDef_isValid(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;valid;}
-const char* _UnitDef_getName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;name.c_str();}
-const char* _UnitDef_getHumanName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;humanName.c_str();}
-const char* _UnitDef_getFilename(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;filename.c_str();}
-int _UnitDef_getId(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;id;}
-int _UnitDef_getAiHint(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;aihint;}
-int _UnitDef_getCobID(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cobID;}
-int _UnitDef_getTechLevel(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;techLevel;}
-const char* _UnitDef_getGaia(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;gaia.c_str();}
-float _UnitDef_getMetalUpkeep(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalUpkeep;}
-float _UnitDef_getEnergyUpkeep(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyUpkeep;}
-float _UnitDef_getMetalMake(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalMake;}
-float _UnitDef_getMakesMetal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;makesMetal;}
-float _UnitDef_getEnergyMake(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyMake;}
-float _UnitDef_getMetalCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalCost;}
-float _UnitDef_getEnergyCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyCost;}
-float _UnitDef_getBuildTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildTime;}
-float _UnitDef_getExtractsMetal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;extractsMetal;}
-float _UnitDef_getExtractRange(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;extractRange;}
-float _UnitDef_getWindGenerator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;windGenerator;}
-float _UnitDef_getTidalGenerator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;tidalGenerator;}
-float _UnitDef_getMetalStorage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalStorage;}
-float _UnitDef_getEnergyStorage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyStorage;}
-float _UnitDef_getAutoHeal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;autoHeal;}
-float _UnitDef_getIdleAutoHeal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;idleAutoHeal;}
-int _UnitDef_getIdleTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;idleTime;}
-float _UnitDef_getPower(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;power;}
-float _UnitDef_getHealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;health;}
-unsigned int _UnitDef_getCategory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;category;}
-float _UnitDef_getSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;speed;}
-float _UnitDef_getTurnRate(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;turnRate;}
-int _UnitDef_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;moveType;}
-bool _UnitDef_isUpright(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;upright;}
-bool _UnitDef_isCollide(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collide;}
-float _UnitDef_getControlRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;controlRadius;}
-float _UnitDef_getLosRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;losRadius;}
-float _UnitDef_getAirLosRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;airLosRadius;}
-float _UnitDef_getLosHeight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;losHeight;}
-int _UnitDef_getRadarRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;radarRadius;}
-int _UnitDef_getSonarRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarRadius;}
-int _UnitDef_getJammerRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;jammerRadius;}
-int _UnitDef_getSonarJamRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarJamRadius;}
-int _UnitDef_getSeismicRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;seismicRadius;}
-float _UnitDef_getSeismicSignature(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;seismicSignature;}
-bool _UnitDef_isStealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;stealth;}
-bool _UnitDef_isSonarStealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarStealth;}
-bool _UnitDef_isBuildRange3D(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildRange3D;}
-float _UnitDef_getBuildDistance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildDistance;}
-float _UnitDef_getBuildSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildSpeed;}
-float _UnitDef_getReclaimSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;reclaimSpeed;}
-float _UnitDef_getRepairSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;repairSpeed;}
-float _UnitDef_getMaxRepairSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxRepairSpeed;}
-float _UnitDef_getResurrectSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;resurrectSpeed;}
-float _UnitDef_getCaptureSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;captureSpeed;}
-float _UnitDef_getTerraformSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;terraformSpeed;}
-float _UnitDef_getMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;mass;}
-bool _UnitDef_isPushResistant(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;pushResistant;}
-bool _UnitDef_isStrafeToAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;strafeToAttack;}
-float _UnitDef_getMinCollisionSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minCollisionSpeed;}
-float _UnitDef_getSlideTolerance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;slideTolerance;}
-float _UnitDef_getMaxSlope(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxSlope;}
-float _UnitDef_getMaxHeightDif(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxHeightDif;}
-float _UnitDef_getMinWaterDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minWaterDepth;}
-float _UnitDef_getWaterline(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;waterline;}
-float _UnitDef_getMaxWaterDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxWaterDepth;}
-float _UnitDef_getArmoredMultiple(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;armoredMultiple;}
-int _UnitDef_getArmorType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;armorType;}
-int _UnitDef_getFlankingBonusMode(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMode;}
-SAIFloat3 _UnitDef_getFlankingBonusDir(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusDir.toSAIFloat3();}
-float _UnitDef_getFlankingBonusMax(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMax;}
-float _UnitDef_getFlankingBonusMin(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMin;}
-float _UnitDef_getFlankingBonusMobilityAdd(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMobilityAdd;}
-const char* _UnitDef_getCollisionVolumeType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeType.c_str();}
-SAIFloat3 _UnitDef_getCollisionVolumeScales(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeScales.toSAIFloat3();}
-SAIFloat3 _UnitDef_getCollisionVolumeOffsets(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeOffsets.toSAIFloat3();}
-int _UnitDef_getCollisionVolumeTest(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeTest;}
-float _UnitDef_getMaxWeaponRange(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxWeaponRange;}
-const char* _UnitDef_getType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;type.c_str();}
-const char* _UnitDef_getTooltip(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;tooltip.c_str();}
-const char* _UnitDef_getWreckName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wreckName.c_str();}
-const char* _UnitDef_getDeathExplosion(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;deathExplosion.c_str();}
-const char* _UnitDef_getSelfDExplosion(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;selfDExplosion.c_str();}
-const char* _UnitDef_getTedClassString(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;TEDClassString.c_str();}
-const char* _UnitDef_getCategoryString(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;categoryString.c_str();}
-bool _UnitDef_isCanSelfD(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSelfD;}
-int _UnitDef_getSelfDCountdown(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;selfDCountdown;}
-bool _UnitDef_isCanSubmerge(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSubmerge;}
-bool _UnitDef_isCanFly(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canfly;}
-bool _UnitDef_isCanMove(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canmove;}
-bool _UnitDef_isCanHover(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canhover;}
-bool _UnitDef_isFloater(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;floater;}
-bool _UnitDef_isBuilder(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;builder;}
-bool _UnitDef_isActivateWhenBuilt(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;activateWhenBuilt;}
-bool _UnitDef_isOnOffable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;onoffable;}
-bool _UnitDef_isFullHealthFactory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fullHealthFactory;}
-bool _UnitDef_isFactoryHeadingTakeoff(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;factoryHeadingTakeoff;}
-bool _UnitDef_isReclaimable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;reclaimable;}
-bool _UnitDef_isCapturable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;capturable;}
-bool _UnitDef_isCanRestore(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRestore;}
-bool _UnitDef_isCanRepair(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRepair;}
-bool _UnitDef_isCanSelfRepair(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSelfRepair;}
-bool _UnitDef_isCanReclaim(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canReclaim;}
-bool _UnitDef_isCanAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canAttack;}
-bool _UnitDef_isCanPatrol(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canPatrol;}
-bool _UnitDef_isCanFight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canFight;}
-bool _UnitDef_isCanGuard(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canGuard;}
-bool _UnitDef_isCanBuild(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canBuild;}
-bool _UnitDef_isCanAssist(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canAssist;}
-bool _UnitDef_isCanBeAssisted(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canBeAssisted;}
-bool _UnitDef_isCanRepeat(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRepeat;}
-bool _UnitDef_isCanFireControl(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canFireControl;}
-int _UnitDef_getFireState(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fireState;}
-int _UnitDef_getMoveState(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;moveState;}
-float _UnitDef_getWingDrag(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wingDrag;}
-float _UnitDef_getWingAngle(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wingAngle;}
-float _UnitDef_getDrag(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;drag;}
-float _UnitDef_getFrontToSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;frontToSpeed;}
-float _UnitDef_getSpeedToFront(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;speedToFront;}
-float _UnitDef_getMyGravity(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;myGravity;}
-float _UnitDef_getMaxBank(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxBank;}
-float _UnitDef_getMaxPitch(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxPitch;}
-float _UnitDef_getTurnRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;turnRadius;}
-float _UnitDef_getWantedHeight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wantedHeight;}
-float _UnitDef_getVerticalSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;verticalSpeed;}
-bool _UnitDef_isCanCrash(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCrash;}
-bool _UnitDef_isHoverAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;hoverAttack;}
-bool _UnitDef_isAirStrafe(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;airStrafe;}
-float _UnitDef_getDlHoverFactor(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;dlHoverFactor;}
-float _UnitDef_getMaxAcceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxAcc;}
-float _UnitDef_getMaxDeceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxDec;}
-float _UnitDef_getMaxAileron(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxAileron;}
-float _UnitDef_getMaxElevator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxElevator;}
-float _UnitDef_getMaxRudder(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxRudder;}
+Export(bool) _UnitDef_isValid(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;valid;}
+Export(const char*) _UnitDef_getName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;name.c_str();}
+Export(const char*) _UnitDef_getHumanName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;humanName.c_str();}
+Export(const char*) _UnitDef_getFilename(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;filename.c_str();}
+Export(int) _UnitDef_getId(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;id;}
+Export(int) _UnitDef_getAiHint(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;aihint;}
+Export(int) _UnitDef_getCobID(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cobID;}
+Export(int) _UnitDef_getTechLevel(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;techLevel;}
+Export(const char*) _UnitDef_getGaia(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;gaia.c_str();}
+Export(float) _UnitDef_getMetalUpkeep(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalUpkeep;}
+Export(float) _UnitDef_getEnergyUpkeep(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyUpkeep;}
+Export(float) _UnitDef_getMetalMake(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalMake;}
+Export(float) _UnitDef_getMakesMetal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;makesMetal;}
+Export(float) _UnitDef_getEnergyMake(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyMake;}
+Export(float) _UnitDef_getMetalCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalCost;}
+Export(float) _UnitDef_getEnergyCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyCost;}
+Export(float) _UnitDef_getBuildTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildTime;}
+Export(float) _UnitDef_getExtractsMetal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;extractsMetal;}
+Export(float) _UnitDef_getExtractRange(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;extractRange;}
+Export(float) _UnitDef_getWindGenerator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;windGenerator;}
+Export(float) _UnitDef_getTidalGenerator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;tidalGenerator;}
+Export(float) _UnitDef_getMetalStorage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;metalStorage;}
+Export(float) _UnitDef_getEnergyStorage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;energyStorage;}
+Export(float) _UnitDef_getAutoHeal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;autoHeal;}
+Export(float) _UnitDef_getIdleAutoHeal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;idleAutoHeal;}
+Export(int) _UnitDef_getIdleTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;idleTime;}
+Export(float) _UnitDef_getPower(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;power;}
+Export(float) _UnitDef_getHealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;health;}
+Export(unsigned int) _UnitDef_getCategory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;category;}
+Export(float) _UnitDef_getSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;speed;}
+Export(float) _UnitDef_getTurnRate(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;turnRate;}
+Export(int) _UnitDef_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;moveType;}
+Export(bool) _UnitDef_isUpright(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;upright;}
+Export(bool) _UnitDef_isCollide(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collide;}
+Export(float) _UnitDef_getControlRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;controlRadius;}
+Export(float) _UnitDef_getLosRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;losRadius;}
+Export(float) _UnitDef_getAirLosRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;airLosRadius;}
+Export(float) _UnitDef_getLosHeight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;losHeight;}
+Export(int) _UnitDef_getRadarRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;radarRadius;}
+Export(int) _UnitDef_getSonarRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarRadius;}
+Export(int) _UnitDef_getJammerRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;jammerRadius;}
+Export(int) _UnitDef_getSonarJamRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarJamRadius;}
+Export(int) _UnitDef_getSeismicRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;seismicRadius;}
+Export(float) _UnitDef_getSeismicSignature(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;seismicSignature;}
+Export(bool) _UnitDef_isStealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;stealth;}
+Export(bool) _UnitDef_isSonarStealth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;sonarStealth;}
+Export(bool) _UnitDef_isBuildRange3D(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildRange3D;}
+Export(float) _UnitDef_getBuildDistance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildDistance;}
+Export(float) _UnitDef_getBuildSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildSpeed;}
+Export(float) _UnitDef_getReclaimSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;reclaimSpeed;}
+Export(float) _UnitDef_getRepairSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;repairSpeed;}
+Export(float) _UnitDef_getMaxRepairSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxRepairSpeed;}
+Export(float) _UnitDef_getResurrectSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;resurrectSpeed;}
+Export(float) _UnitDef_getCaptureSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;captureSpeed;}
+Export(float) _UnitDef_getTerraformSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;terraformSpeed;}
+Export(float) _UnitDef_getMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;mass;}
+Export(bool) _UnitDef_isPushResistant(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;pushResistant;}
+Export(bool) _UnitDef_isStrafeToAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;strafeToAttack;}
+Export(float) _UnitDef_getMinCollisionSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minCollisionSpeed;}
+Export(float) _UnitDef_getSlideTolerance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;slideTolerance;}
+Export(float) _UnitDef_getMaxSlope(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxSlope;}
+Export(float) _UnitDef_getMaxHeightDif(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxHeightDif;}
+Export(float) _UnitDef_getMinWaterDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minWaterDepth;}
+Export(float) _UnitDef_getWaterline(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;waterline;}
+Export(float) _UnitDef_getMaxWaterDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxWaterDepth;}
+Export(float) _UnitDef_getArmoredMultiple(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;armoredMultiple;}
+Export(int) _UnitDef_getArmorType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;armorType;}
+Export(int) _UnitDef_getFlankingBonusMode(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMode;}
+Export(SAIFloat3) _UnitDef_getFlankingBonusDir(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusDir.toSAIFloat3();}
+Export(float) _UnitDef_getFlankingBonusMax(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMax;}
+Export(float) _UnitDef_getFlankingBonusMin(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMin;}
+Export(float) _UnitDef_getFlankingBonusMobilityAdd(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flankingBonusMobilityAdd;}
+Export(const char*) _UnitDef_getCollisionVolumeType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeType.c_str();}
+Export(SAIFloat3) _UnitDef_getCollisionVolumeScales(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeScales.toSAIFloat3();}
+Export(SAIFloat3) _UnitDef_getCollisionVolumeOffsets(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeOffsets.toSAIFloat3();}
+Export(int) _UnitDef_getCollisionVolumeTest(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;collisionVolumeTest;}
+Export(float) _UnitDef_getMaxWeaponRange(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxWeaponRange;}
+Export(const char*) _UnitDef_getType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;type.c_str();}
+Export(const char*) _UnitDef_getTooltip(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;tooltip.c_str();}
+Export(const char*) _UnitDef_getWreckName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wreckName.c_str();}
+Export(const char*) _UnitDef_getDeathExplosion(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;deathExplosion.c_str();}
+Export(const char*) _UnitDef_getSelfDExplosion(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;selfDExplosion.c_str();}
+Export(const char*) _UnitDef_getTedClassString(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;TEDClassString.c_str();}
+Export(const char*) _UnitDef_getCategoryString(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;categoryString.c_str();}
+Export(bool) _UnitDef_isCanSelfD(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSelfD;}
+Export(int) _UnitDef_getSelfDCountdown(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;selfDCountdown;}
+Export(bool) _UnitDef_isCanSubmerge(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSubmerge;}
+Export(bool) _UnitDef_isCanFly(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canfly;}
+Export(bool) _UnitDef_isCanMove(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canmove;}
+Export(bool) _UnitDef_isCanHover(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canhover;}
+Export(bool) _UnitDef_isFloater(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;floater;}
+Export(bool) _UnitDef_isBuilder(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;builder;}
+Export(bool) _UnitDef_isActivateWhenBuilt(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;activateWhenBuilt;}
+Export(bool) _UnitDef_isOnOffable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;onoffable;}
+Export(bool) _UnitDef_isFullHealthFactory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fullHealthFactory;}
+Export(bool) _UnitDef_isFactoryHeadingTakeoff(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;factoryHeadingTakeoff;}
+Export(bool) _UnitDef_isReclaimable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;reclaimable;}
+Export(bool) _UnitDef_isCapturable(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;capturable;}
+Export(bool) _UnitDef_isCanRestore(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRestore;}
+Export(bool) _UnitDef_isCanRepair(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRepair;}
+Export(bool) _UnitDef_isCanSelfRepair(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canSelfRepair;}
+Export(bool) _UnitDef_isCanReclaim(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canReclaim;}
+Export(bool) _UnitDef_isCanAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canAttack;}
+Export(bool) _UnitDef_isCanPatrol(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canPatrol;}
+Export(bool) _UnitDef_isCanFight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canFight;}
+Export(bool) _UnitDef_isCanGuard(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canGuard;}
+Export(bool) _UnitDef_isCanBuild(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canBuild;}
+Export(bool) _UnitDef_isCanAssist(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canAssist;}
+Export(bool) _UnitDef_isCanBeAssisted(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canBeAssisted;}
+Export(bool) _UnitDef_isCanRepeat(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canRepeat;}
+Export(bool) _UnitDef_isCanFireControl(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canFireControl;}
+Export(int) _UnitDef_getFireState(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fireState;}
+Export(int) _UnitDef_getMoveState(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;moveState;}
+Export(float) _UnitDef_getWingDrag(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wingDrag;}
+Export(float) _UnitDef_getWingAngle(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wingAngle;}
+Export(float) _UnitDef_getDrag(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;drag;}
+Export(float) _UnitDef_getFrontToSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;frontToSpeed;}
+Export(float) _UnitDef_getSpeedToFront(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;speedToFront;}
+Export(float) _UnitDef_getMyGravity(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;myGravity;}
+Export(float) _UnitDef_getMaxBank(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxBank;}
+Export(float) _UnitDef_getMaxPitch(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxPitch;}
+Export(float) _UnitDef_getTurnRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;turnRadius;}
+Export(float) _UnitDef_getWantedHeight(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;wantedHeight;}
+Export(float) _UnitDef_getVerticalSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;verticalSpeed;}
+Export(bool) _UnitDef_isCanCrash(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCrash;}
+Export(bool) _UnitDef_isHoverAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;hoverAttack;}
+Export(bool) _UnitDef_isAirStrafe(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;airStrafe;}
+Export(float) _UnitDef_getDlHoverFactor(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;dlHoverFactor;}
+Export(float) _UnitDef_getMaxAcceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxAcc;}
+Export(float) _UnitDef_getMaxDeceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxDec;}
+Export(float) _UnitDef_getMaxAileron(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxAileron;}
+Export(float) _UnitDef_getMaxElevator(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxElevator;}
+Export(float) _UnitDef_getMaxRudder(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxRudder;}
 //const unsigned char** _UnitDef_getYardMaps(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;yardmaps;}
-int _UnitDef_getXSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;xsize;}
-int _UnitDef_getYSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;ysize;}
-int _UnitDef_getBuildAngle(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildangle;}
-float _UnitDef_getLoadingRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;loadingRadius;}
-float _UnitDef_getUnloadSpread(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;unloadSpread;}
-int _UnitDef_getTransportCapacity(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportCapacity;}
-int _UnitDef_getTransportSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportSize;}
-int _UnitDef_getMinTransportSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minTransportSize;}
-bool _UnitDef_isAirBase(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isAirBase;}
-float _UnitDef_getTransportMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportMass;}
-float _UnitDef_getMinTransportMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minTransportMass;}
-bool _UnitDef_isHoldSteady(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;holdSteady;}
-bool _UnitDef_isReleaseHeld(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;releaseHeld;}
-bool _UnitDef_isCantBeTransported(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cantBeTransported;}
-bool _UnitDef_isTransportByEnemy(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportByEnemy;}
-int _UnitDef_getTransportUnloadMethod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportUnloadMethod;}
-float _UnitDef_getFallSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fallSpeed;}
-float _UnitDef_getUnitFallSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;unitFallSpeed;}
-bool _UnitDef_isCanCloak(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCloak;}
-bool _UnitDef_isStartCloaked(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;startCloaked;}
-float _UnitDef_getCloakCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cloakCost;}
-float _UnitDef_getCloakCostMoving(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cloakCostMoving;}
-float _UnitDef_getDecloakDistance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakDistance;}
-bool _UnitDef_isDecloakSpherical(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakSpherical;}
-bool _UnitDef_isDecloakOnFire(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakOnFire;}
-bool _UnitDef_isCanKamikaze(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canKamikaze;}
-float _UnitDef_getKamikazeDist(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;kamikazeDist;}
-bool _UnitDef_isTargetingFacility(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;targfac;}
-bool _UnitDef_isCanDGun(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canDGun;}
-bool _UnitDef_isNeedGeo(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;needGeo;}
-bool _UnitDef_isFeature(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isFeature;}
-bool _UnitDef_isHideDamage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;hideDamage;}
-bool _UnitDef_isCommander(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isCommander;}
-bool _UnitDef_isShowPlayerName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;showPlayerName;}
-bool _UnitDef_isCanResurrect(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canResurrect;}
-bool _UnitDef_isCanCapture(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCapture;}
-int _UnitDef_getHighTrajectoryType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;highTrajectoryType;}
-unsigned int _UnitDef_getNoChaseCategory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;noChaseCategory;}
-bool _UnitDef_isLeaveTracks(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;leaveTracks;}
-float _UnitDef_getTrackWidth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackWidth;}
-float _UnitDef_getTrackOffset(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackOffset;}
-float _UnitDef_getTrackStrength(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackStrength;}
-float _UnitDef_getTrackStretch(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackStretch;}
-int _UnitDef_getTrackType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackType;}
-bool _UnitDef_isCanDropFlare(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canDropFlare;}
-float _UnitDef_getFlareReloadTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareReloadTime;}
-float _UnitDef_getFlareEfficiency(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareEfficiency;}
-float _UnitDef_getFlareDelay(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareDelay;}
-SAIFloat3 _UnitDef_getFlareDropVector(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareDropVector.toSAIFloat3();}
-int _UnitDef_getFlareTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareTime;}
-int _UnitDef_getFlareSalvoSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareSalvoSize;}
-int _UnitDef_getFlareSalvoDelay(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareSalvoDelay;}
-bool _UnitDef_isSmoothAnim(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;smoothAnim;}
-bool _UnitDef_isMetalMaker(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isMetalMaker;}
-bool _UnitDef_isCanLoopbackAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canLoopbackAttack;}
-bool _UnitDef_isLevelGround(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;levelGround;}
-bool _UnitDef_isUseBuildingGroundDecal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;useBuildingGroundDecal;}
-int _UnitDef_getBuildingDecalType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalType;}
-int _UnitDef_getBuildingDecalSizeX(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalSizeX;}
-int _UnitDef_getBuildingDecalSizeY(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalSizeY;}
-float _UnitDef_getBuildingDecalDecaySpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalDecaySpeed;}
-bool _UnitDef_isFirePlatform(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isFirePlatform;}
-float _UnitDef_getMaxFuel(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxFuel;}
-float _UnitDef_getRefuelTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;refuelTime;}
-float _UnitDef_getMinAirBasePower(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minAirBasePower;}
-int _UnitDef_getMaxThisUnit(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxThisUnit;}
-int _UnitDef_getDecoyDefId(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decoyDef-&gt;id;}
-bool _UnitDef_isDontLand(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;DontLand();}
-int _UnitDef_getShieldWeaponDefId(int teamId, int unitDefId) {
+Export(int) _UnitDef_getXSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;xsize;}
+Export(int) _UnitDef_getYSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;ysize;}
+Export(int) _UnitDef_getBuildAngle(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildangle;}
+Export(float) _UnitDef_getLoadingRadius(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;loadingRadius;}
+Export(float) _UnitDef_getUnloadSpread(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;unloadSpread;}
+Export(int) _UnitDef_getTransportCapacity(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportCapacity;}
+Export(int) _UnitDef_getTransportSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportSize;}
+Export(int) _UnitDef_getMinTransportSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minTransportSize;}
+Export(bool) _UnitDef_isAirBase(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isAirBase;}
+Export(float) _UnitDef_getTransportMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportMass;}
+Export(float) _UnitDef_getMinTransportMass(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minTransportMass;}
+Export(bool) _UnitDef_isHoldSteady(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;holdSteady;}
+Export(bool) _UnitDef_isReleaseHeld(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;releaseHeld;}
+Export(bool) _UnitDef_isCantBeTransported(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cantBeTransported;}
+Export(bool) _UnitDef_isTransportByEnemy(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportByEnemy;}
+Export(int) _UnitDef_getTransportUnloadMethod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;transportUnloadMethod;}
+Export(float) _UnitDef_getFallSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;fallSpeed;}
+Export(float) _UnitDef_getUnitFallSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;unitFallSpeed;}
+Export(bool) _UnitDef_isCanCloak(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCloak;}
+Export(bool) _UnitDef_isStartCloaked(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;startCloaked;}
+Export(float) _UnitDef_getCloakCost(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cloakCost;}
+Export(float) _UnitDef_getCloakCostMoving(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;cloakCostMoving;}
+Export(float) _UnitDef_getDecloakDistance(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakDistance;}
+Export(bool) _UnitDef_isDecloakSpherical(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakSpherical;}
+Export(bool) _UnitDef_isDecloakOnFire(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decloakOnFire;}
+Export(bool) _UnitDef_isCanKamikaze(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canKamikaze;}
+Export(float) _UnitDef_getKamikazeDist(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;kamikazeDist;}
+Export(bool) _UnitDef_isTargetingFacility(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;targfac;}
+Export(bool) _UnitDef_isCanDGun(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canDGun;}
+Export(bool) _UnitDef_isNeedGeo(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;needGeo;}
+Export(bool) _UnitDef_isFeature(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isFeature;}
+Export(bool) _UnitDef_isHideDamage(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;hideDamage;}
+Export(bool) _UnitDef_isCommander(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isCommander;}
+Export(bool) _UnitDef_isShowPlayerName(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;showPlayerName;}
+Export(bool) _UnitDef_isCanResurrect(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canResurrect;}
+Export(bool) _UnitDef_isCanCapture(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canCapture;}
+Export(int) _UnitDef_getHighTrajectoryType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;highTrajectoryType;}
+Export(unsigned int) _UnitDef_getNoChaseCategory(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;noChaseCategory;}
+Export(bool) _UnitDef_isLeaveTracks(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;leaveTracks;}
+Export(float) _UnitDef_getTrackWidth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackWidth;}
+Export(float) _UnitDef_getTrackOffset(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackOffset;}
+Export(float) _UnitDef_getTrackStrength(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackStrength;}
+Export(float) _UnitDef_getTrackStretch(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackStretch;}
+Export(int) _UnitDef_getTrackType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;trackType;}
+Export(bool) _UnitDef_isCanDropFlare(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canDropFlare;}
+Export(float) _UnitDef_getFlareReloadTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareReloadTime;}
+Export(float) _UnitDef_getFlareEfficiency(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareEfficiency;}
+Export(float) _UnitDef_getFlareDelay(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareDelay;}
+Export(SAIFloat3) _UnitDef_getFlareDropVector(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareDropVector.toSAIFloat3();}
+Export(int) _UnitDef_getFlareTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareTime;}
+Export(int) _UnitDef_getFlareSalvoSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareSalvoSize;}
+Export(int) _UnitDef_getFlareSalvoDelay(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;flareSalvoDelay;}
+Export(bool) _UnitDef_isSmoothAnim(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;smoothAnim;}
+Export(bool) _UnitDef_isMetalMaker(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isMetalMaker;}
+Export(bool) _UnitDef_isCanLoopbackAttack(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;canLoopbackAttack;}
+Export(bool) _UnitDef_isLevelGround(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;levelGround;}
+Export(bool) _UnitDef_isUseBuildingGroundDecal(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;useBuildingGroundDecal;}
+Export(int) _UnitDef_getBuildingDecalType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalType;}
+Export(int) _UnitDef_getBuildingDecalSizeX(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalSizeX;}
+Export(int) _UnitDef_getBuildingDecalSizeY(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalSizeY;}
+Export(float) _UnitDef_getBuildingDecalDecaySpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildingDecalDecaySpeed;}
+Export(bool) _UnitDef_isFirePlatform(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;isFirePlatform;}
+Export(float) _UnitDef_getMaxFuel(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxFuel;}
+Export(float) _UnitDef_getRefuelTime(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;refuelTime;}
+Export(float) _UnitDef_getMinAirBasePower(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;minAirBasePower;}
+Export(int) _UnitDef_getMaxThisUnit(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;maxThisUnit;}
+Export(int) _UnitDef_getDecoyDefId(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;decoyDef-&gt;id;}
+Export(bool) _UnitDef_isDontLand(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;DontLand();}
+Export(int) _UnitDef_getShieldWeaponDefId(int teamId, int unitDefId) {
 	const WeaponDef* wd = getUnitDefById(teamId, unitDefId)-&gt;shieldWeaponDef;
 	if (wd == NULL)
 		return -1;
 	else
 		return wd-&gt;id;
 }
-int _UnitDef_getStockpileWeaponDefId(int teamId, int unitDefId) {
+Export(int) _UnitDef_getStockpileWeaponDefId(int teamId, int unitDefId) {
 	const WeaponDef* wd = getUnitDefById(teamId, unitDefId)-&gt;stockpileWeaponDef;
 	if (wd == NULL)
 		return -1;
 	else
 		return wd-&gt;id;
 }
-int _UnitDef_getNumBuildOptions(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildOptions.size();}
-int _UnitDef_getBuildOptions(int teamId, int unitDefId, int* unitDefIds) {
+Export(int) _UnitDef_getNumBuildOptions(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;buildOptions.size();}
+Export(int) _UnitDef_getBuildOptions(int teamId, int unitDefId, int* unitDefIds) {
 	const std::map&lt;int,std::string&gt;* bo = &amp;(getUnitDefById(teamId, unitDefId)-&gt;buildOptions);
 	int numBo = bo-&gt;size();
 	std::map&lt;int,std::string&gt;::const_iterator bb;
@@ -1753,38 +1763,38 @@
 	}
 	return numBo;
 }
-int _UnitDef_getNumCustomParams(int teamId, int unitDefId) {
+Export(int) _UnitDef_getNumCustomParams(int teamId, int unitDefId) {
 	return getUnitDefById(teamId, unitDefId)-&gt;customParams.size();
 }
-int _UnitDef_getCustomParams(int teamId, int unitDefId, const char* map[][2]) {
+Export(int) _UnitDef_getCustomParams(int teamId, int unitDefId, const char* map[][2]) {
 	return fillCMap(&amp;(getUnitDefById(teamId, unitDefId)-&gt;customParams), map);
 }
-bool _UnitDef_hasMoveData(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata != NULL;}
-int _UnitDef_MoveData_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveType;}
-int _UnitDef_MoveData_getMoveFamily(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveFamily;}
-int _UnitDef_MoveData_getSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;size;}
-float _UnitDef_MoveData_getDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;depth;}
-float _UnitDef_MoveData_getMaxSlope(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxSlope;}
-float _UnitDef_MoveData_getSlopeMod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;slopeMod;}
-float _UnitDef_MoveData_getDepthMod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;depthMod;}
-int _UnitDef_MoveData_getPathType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;pathType;}
-float _UnitDef_MoveData_getCrushStrength(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;crushStrength;}
-float _UnitDef_MoveData_getMaxSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxSpeed;}
-short _UnitDef_MoveData_getMaxTurnRate(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxTurnRate;}
-float _UnitDef_MoveData_getMaxAcceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxAcceleration;}
-float _UnitDef_MoveData_getMaxBreaking(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxBreaking;}
-bool _UnitDef_MoveData_isSubMarine(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;subMarine;}
-int _UnitDef_getNumUnitDefWeapons(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.size();}
-const char* _UnitDef_UnitDefWeapon_getName(int teamId, int unitDefId, int weaponIndex) {
+Export(bool) _UnitDef_hasMoveData(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata != NULL;}
+Export(int) _UnitDef_MoveData_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveType;}
+Export(int) _UnitDef_MoveData_getMoveFamily(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveFamily;}
+Export(int) _UnitDef_MoveData_getSize(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;size;}
+Export(float) _UnitDef_MoveData_getDepth(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;depth;}
+Export(float) _UnitDef_MoveData_getMaxSlope(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxSlope;}
+Export(float) _UnitDef_MoveData_getSlopeMod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;slopeMod;}
+Export(float) _UnitDef_MoveData_getDepthMod(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;depthMod;}
+Export(int) _UnitDef_MoveData_getPathType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;pathType;}
+Export(float) _UnitDef_MoveData_getCrushStrength(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;crushStrength;}
+Export(float) _UnitDef_MoveData_getMaxSpeed(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxSpeed;}
+Export(short) _UnitDef_MoveData_getMaxTurnRate(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxTurnRate;}
+Export(float) _UnitDef_MoveData_getMaxAcceleration(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxAcceleration;}
+Export(float) _UnitDef_MoveData_getMaxBreaking(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;maxBreaking;}
+Export(bool) _UnitDef_MoveData_isSubMarine(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;subMarine;}
+Export(int) _UnitDef_getNumUnitDefWeapons(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.size();}
+Export(const char*) _UnitDef_UnitDefWeapon_getName(int teamId, int unitDefId, int weaponIndex) {
 	return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).name.c_str();
 }
-int _UnitDef_UnitDefWeapon_getWeaponDefId(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).def-&gt;id;}
-int _UnitDef_UnitDefWeapon_getSlavedTo(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).slavedTo;}
-SAIFloat3 _UnitDef_UnitDefWeapon_getMainDir(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).mainDir.toSAIFloat3();}
-float _UnitDef_UnitDefWeapon_getMaxAngleDif(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).maxAngleDif;}
-float _UnitDef_UnitDefWeapon_getFuelUsage(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).fuelUsage;}
-unsigned int _UnitDef_UnitDefWeapon_getBadTargetCat(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).badTargetCat;}
-unsigned int _UnitDef_UnitDefWeapon_getOnlyTargetCat(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).onlyTargetCat;}
+Export(int) _UnitDef_UnitDefWeapon_getWeaponDefId(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).def-&gt;id;}
+Export(int) _UnitDef_UnitDefWeapon_getSlavedTo(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).slavedTo;}
+Export(SAIFloat3) _UnitDef_UnitDefWeapon_getMainDir(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).mainDir.toSAIFloat3();}
+Export(float) _UnitDef_UnitDefWeapon_getMaxAngleDif(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).maxAngleDif;}
+Export(float) _UnitDef_UnitDefWeapon_getFuelUsage(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).fuelUsage;}
+Export(unsigned int) _UnitDef_UnitDefWeapon_getBadTargetCat(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).badTargetCat;}
+Export(unsigned int) _UnitDef_UnitDefWeapon_getOnlyTargetCat(int teamId, int unitDefId, int weaponIndex) {return getUnitDefById(teamId, unitDefId)-&gt;weapons.at(weaponIndex).onlyTargetCat;}
 //########### END UnitDef
 
 
@@ -1792,7 +1802,7 @@
 
 
 //########### BEGINN Unit
-int _Unit_getDefId(int teamId, int unitId) {
+Export(int) _Unit_getDefId(int teamId, int unitId) {
 	const UnitDef* unitDef;
 	if (_Cheats_isEnabled(teamId)) {
 		unitDef = team_cheatCallback[teamId]-&gt;GetUnitDef(unitId);
@@ -1807,13 +1817,13 @@
 		return -1;
 	}
 }
-int _Unit_getAiHint(int teamId, int unitId) {
+Export(int) _Unit_getAiHint(int teamId, int unitId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitAiHint(unitId);
 }
-int _Unit_getGroup(int teamId, int unitId) {
+Export(int) _Unit_getGroup(int teamId, int unitId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitGroup(unitId);
 }
-int _Unit_getTeam(int teamId, int unitId) {
+Export(int) _Unit_getTeam(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitTeam(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetUnitTeam(unitId);
@@ -1821,7 +1831,7 @@
 		return team_callback[teamId]-&gt;GetUnitTeam(unitId);
 	}
 }
-int _Unit_getAllyTeam(int teamId, int unitId) {
+Export(int) _Unit_getAllyTeam(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitAllyTeam(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetUnitAllyTeam(unitId);
@@ -1829,11 +1839,11 @@
 		return team_callback[teamId]-&gt;GetUnitAllyTeam(unitId);
 	}
 }
-int _Unit_getNumSupportedCommands(int teamId, int unitId) {
+Export(int) _Unit_getNumSupportedCommands(int teamId, int unitId) {
 	IAICallback* clb = team_callback[teamId];
 	return clb-&gt;GetUnitCommands(unitId)-&gt;size();
 }
-int _Unit_SupportedCommands_getId(int teamId, int unitId, int* ids) {
+Export(int) _Unit_SupportedCommands_getId(int teamId, int unitId, int* ids) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1842,7 +1852,7 @@
 	}
 	return numComDescs;
 }
-int _Unit_SupportedCommands_getName(int teamId, int unitId, const char** names) {
+Export(int) _Unit_SupportedCommands_getName(int teamId, int unitId, const char** names) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1851,7 +1861,7 @@
 	}
 	return numComDescs;
 }
-int _Unit_SupportedCommands_getToolTip(int teamId, int unitId, const char** toolTips) {
+Export(int) _Unit_SupportedCommands_getToolTip(int teamId, int unitId, const char** toolTips) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1860,7 +1870,7 @@
 	}
 	return numComDescs;
 }
-int _Unit_SupportedCommands_isShowUnique(int teamId, int unitId, bool* showUniques) {
+Export(int) _Unit_SupportedCommands_isShowUnique(int teamId, int unitId, bool* showUniques) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1869,7 +1879,7 @@
 	}
 	return numComDescs;
 }
-int _Unit_SupportedCommands_isDisabled(int teamId, int unitId, bool* disableds) {
+Export(int) _Unit_SupportedCommands_isDisabled(int teamId, int unitId, bool* disableds) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1878,7 +1888,7 @@
 	}
 	return numComDescs;
 }
-int _Unit_SupportedCommands_getNumParams(int teamId, int unitId, int* numParams) {
+Export(int) _Unit_SupportedCommands_getNumParams(int teamId, int unitId, int* numParams) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1887,20 +1897,20 @@
 	}
 	return numComDescs;
 }
-int _Unit_SupportedCommands_getParams(int teamId, int unitId, const char*** params) {
+Export(int) _Unit_SupportedCommands_getParams(int teamId, int unitId, const char*** params) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
 	for (int c=0; c &lt; numComDescs; c++) {
 		const std::vector&lt;std::string&gt; ps = comDescs-&gt;at(c).params;
-		for (int p=0; p &lt; ps.size(); p++) {
+		for (unsigned int p=0; p &lt; ps.size(); p++) {
 			params[c][p] = ps.at(p).c_str();
 		}
 	}
 	return numComDescs;
 }
 
-int _Unit_getStockpile(int teamId, int unitId) {
+Export(int) _Unit_getStockpile(int teamId, int unitId) {
     IAICallback* clb = team_callback[teamId];
     int stockpile;
     bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILED, unitId, &amp;stockpile);
@@ -1909,7 +1919,7 @@
     }
     return stockpile;
 }
-int _Unit_getStockpileQueued(int teamId, int unitId) {
+Export(int) _Unit_getStockpileQueued(int teamId, int unitId) {
     IAICallback* clb = team_callback[teamId];
     int stockpileQueue;
     bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILE_QUED, unitId, &amp;stockpileQueue);
@@ -1918,7 +1928,7 @@
     }
     return stockpileQueue;
 }
-float _Unit_getCurrentFuel(int teamId, int unitId) {
+Export(float) _Unit_getCurrentFuel(int teamId, int unitId) {
     IAICallback* clb = team_callback[teamId];
     float currentFuel;
     bool fetchOk = clb-&gt;GetProperty(AIVAL_CURRENT_FUEL, unitId, &amp;currentFuel);
@@ -1927,7 +1937,7 @@
     }
     return currentFuel;
 }
-float _Unit_getMaxSpeed(int teamId, int unitId) {
+Export(float) _Unit_getMaxSpeed(int teamId, int unitId) {
     IAICallback* clb = team_callback[teamId];
     float maxSpeed;
     bool fetchOk = clb-&gt;GetProperty(AIVAL_UNIT_MAXSPEED, unitId, &amp;maxSpeed);
@@ -1937,11 +1947,11 @@
     return maxSpeed;
 }
 
-float _Unit_getMaxRange(int teamId, int unitId) {
+Export(float) _Unit_getMaxRange(int teamId, int unitId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitMaxRange(unitId);
 }
 
-float _Unit_getMaxHealth(int teamId, int unitId) {
+Export(float) _Unit_getMaxHealth(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitMaxHealth(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetUnitMaxHealth(unitId);
@@ -1950,7 +1960,7 @@
 	}
 }
 
-int _Unit_getNumCurrentCommands(int teamId, int unitId) {
+Export(int) _Unit_getNumCurrentCommands(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId];
 //	return clb-&gt;GetCurrentUnitCommands(unitId)-&gt;size();
 	if (_Cheats_isEnabled(teamId)) {
@@ -1959,7 +1969,7 @@
 		return team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId)-&gt;size();
 	}
 }
-int _Unit_CurrentCommands_getType(int teamId, int unitId) {
+Export(int) _Unit_CurrentCommands_getType(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId];
 //	CCommandQueue::QueueType qt = clb-&gt;GetCurrentUnitCommands(unitId)-&gt;GetType();
 //	return qt;
@@ -1969,7 +1979,7 @@
 		return team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId)-&gt;GetType();
 	}
 }
-int _Unit_CurrentCommands_getIds(int teamId, int unitId, int* ids) {
+Export(int) _Unit_CurrentCommands_getIds(int teamId, int unitId, int* ids) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -1984,7 +1994,7 @@
 	}
 	return numCommands;
 }
-int _Unit_CurrentCommands_getOptions(int teamId, int unitId, unsigned char* options) {
+Export(int) _Unit_CurrentCommands_getOptions(int teamId, int unitId, unsigned char* options) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -1999,7 +2009,7 @@
 	}
 	return numCommands;
 }
-int _Unit_CurrentCommands_getTag(int teamId, int unitId, unsigned int* tags) {
+Export(int) _Unit_CurrentCommands_getTag(int teamId, int unitId, unsigned int* tags) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -2014,7 +2024,7 @@
 	}
 	return numCommands;
 }
-int _Unit_CurrentCommands_getTimeOut(int teamId, int unitId, int* timeOuts) {
+Export(int) _Unit_CurrentCommands_getTimeOut(int teamId, int unitId, int* timeOuts) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -2029,7 +2039,7 @@
 	}
 	return numCommands;
 }
-int _Unit_CurrentCommands_getNumParams(int teamId, int unitId, int* numParams) {
+Export(int) _Unit_CurrentCommands_getNumParams(int teamId, int unitId, int* numParams) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -2044,7 +2054,7 @@
 	}
 	return numCommands;
 }
-int _Unit_CurrentCommands_getParams(int teamId, int unitId, float** params) {
+Export(int) _Unit_CurrentCommands_getParams(int teamId, int unitId, float** params) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -2056,14 +2066,14 @@
 	int numCommands = cc-&gt;size();
 	for (int c=0; c &lt; numCommands; c++) {
 		const std::vector&lt;float&gt; ps = cc-&gt;at(c).params;
-		for (int p=0; p &lt; ps.size(); p++) {
+		for (unsigned int p=0; p &lt; ps.size(); p++) {
 			params[c][p] = ps.at(p);
 		}
 	}
 	return numCommands;
 }
 
-float _Unit_getExperience(int teamId, int unitId) {
+Export(float) _Unit_getExperience(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitExperience(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetUnitExperience(unitId);
@@ -2072,7 +2082,7 @@
 	}
 }
 
-float _Unit_getHealth(int teamId, int unitId) {
+Export(float) _Unit_getHealth(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitHealth(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetUnitHealth(unitId);
@@ -2080,10 +2090,10 @@
 		return team_callback[teamId]-&gt;GetUnitHealth(unitId);
 	}
 }
-float _Unit_getSpeed(int teamId, int unitId) {
+Export(float) _Unit_getSpeed(int teamId, int unitId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitSpeed(unitId);
 }
-float _Unit_getPower(int teamId, int unitId) {
+Export(float) _Unit_getPower(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId];return clb-&gt;GetUnitPower(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetUnitPower(unitId);
@@ -2091,7 +2101,7 @@
 		return team_callback[teamId]-&gt;GetUnitPower(unitId);
 	}
 }
-SAIFloat3 _Unit_getPos(int teamId, int unitId) {
+Export(SAIFloat3) _Unit_getPos(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId];
 //	return clb-&gt;GetUnitPos(unitId).toSAIFloat3();
 	if (_Cheats_isEnabled(teamId)) {
@@ -2100,7 +2110,7 @@
 		return team_callback[teamId]-&gt;GetUnitPos(unitId).toSAIFloat3();
 	}
 }
-float _Unit_ResourceInfo_Metal_getUse(int teamId, int unitId) {
+Export(float) _Unit_ResourceInfo_Metal_getUse(int teamId, int unitId) {
 	
 	int res = -1.0F;
 	UnitResourceInfo resourceInfo;
@@ -2119,7 +2129,7 @@
 	
 	return res;
 }
-float _Unit_ResourceInfo_Metal_getMake(int teamId, int unitId) {
+Export(float) _Unit_ResourceInfo_Metal_getMake(int teamId, int unitId) {
 	
 	int res = -1.0F;
 	UnitResourceInfo resourceInfo;
@@ -2138,7 +2148,7 @@
 	
 	return res;
 }
-float _Unit_ResourceInfo_Energy_getUse(int teamId, int unitId) {
+Export(float) _Unit_ResourceInfo_Energy_getUse(int teamId, int unitId) {
 	
 	int res = -1.0F;
 	UnitResourceInfo resourceInfo;
@@ -2157,7 +2167,7 @@
 	
 	return res;
 }
-float _Unit_ResourceInfo_Energy_getMake(int teamId, int unitId) {
+Export(float) _Unit_ResourceInfo_Energy_getMake(int teamId, int unitId) {
 	
 	int res = -1.0F;
 	UnitResourceInfo resourceInfo;
@@ -2176,7 +2186,7 @@
 	
 	return res;
 }
-bool _Unit_isActivated(int teamId, int unitId) {
+Export(bool) _Unit_isActivated(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitActivated(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;IsUnitActivated(unitId);
@@ -2184,7 +2194,7 @@
 		return team_callback[teamId]-&gt;IsUnitActivated(unitId);
 	}
 }
-bool _Unit_isBeingBuilt(int teamId, int unitId) {
+Export(bool) _Unit_isBeingBuilt(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;UnitBeingBuilt(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;UnitBeingBuilt(unitId);
@@ -2192,7 +2202,7 @@
 		return team_callback[teamId]-&gt;UnitBeingBuilt(unitId);
 	}
 }
-bool _Unit_isCloaked(int teamId, int unitId) {
+Export(bool) _Unit_isCloaked(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitCloaked(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;IsUnitCloaked(unitId);
@@ -2200,7 +2210,7 @@
 		return team_callback[teamId]-&gt;IsUnitCloaked(unitId);
 	}
 }
-bool _Unit_isParalyzed(int teamId, int unitId) {
+Export(bool) _Unit_isParalyzed(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitParalyzed(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;IsUnitParalyzed(unitId);
@@ -2208,7 +2218,7 @@
 		return team_callback[teamId]-&gt;IsUnitParalyzed(unitId);
 	}
 }
-bool _Unit_isNeutral(int teamId, int unitId) {
+Export(bool) _Unit_isNeutral(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;IsUnitNeutral(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;IsUnitNeutral(unitId);
@@ -2216,7 +2226,7 @@
 		return team_callback[teamId]-&gt;IsUnitNeutral(unitId);
 	}
 }
-int _Unit_getBuildingFacing(int teamId, int unitId) {
+Export(int) _Unit_getBuildingFacing(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetBuildingFacing(unitId);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetBuildingFacing(unitId);
@@ -2226,7 +2236,7 @@
 }
 //########### END Unit
 
-int _Unit_STATIC_getEnemies(int teamId, int* unitIds) {
+Export(int) _Unit_STATIC_getEnemies(int teamId, int* unitIds) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnemyUnits(unitIds);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetEnemyUnits(unitIds);
@@ -2235,7 +2245,7 @@
 	}
 }
 
-int _Unit_STATIC_getEnemiesIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+Export(int) _Unit_STATIC_getEnemiesIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnemyUnits(unitIds, float3(pos), radius);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetEnemyUnits(unitIds, float3(pos), radius);
@@ -2244,19 +2254,19 @@
 	}
 }
 
-int _Unit_STATIC_getEnemiesInRadarAndLos(int teamId, int* unitIds) {
+Export(int) _Unit_STATIC_getEnemiesInRadarAndLos(int teamId, int* unitIds) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnemyUnitsInRadarAndLos(unitIds);
 }
 
-int _Unit_STATIC_getFriendlies(int teamId, int* unitIds) {
+Export(int) _Unit_STATIC_getFriendlies(int teamId, int* unitIds) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFriendlyUnits(unitIds);
 }
 
-int _Unit_STATIC_getFriendliesIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+Export(int) _Unit_STATIC_getFriendliesIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFriendlyUnits(unitIds, float3(pos), radius);
 }
 
-int _Unit_STATIC_getNeutrals(int teamId, int* unitIds) {
+Export(int) _Unit_STATIC_getNeutrals(int teamId, int* unitIds) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNeutralUnits(unitIds);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetNeutralUnits(unitIds);
@@ -2265,7 +2275,7 @@
 	}
 }
 
-int _Unit_STATIC_getNeutralsIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+Export(int) _Unit_STATIC_getNeutralsIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
@@ -2274,96 +2284,96 @@
 	}
 }
 
-const char* _Mod_getName(int teamId) {
+Export(const char*) _Mod_getName(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetModName();
 }
 
 //########### BEGINN Map
-int _Map_getWidth(int teamId) {
+Export(int) _Map_getWidth(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMapWidth();
 }
 
-int _Map_getHeight(int teamId) {
+Export(int) _Map_getHeight(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMapHeight();
 }
 
-const float* _Map_getHeightMap(int teamId) {
+Export(const float*) _Map_getHeightMap(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetHeightMap();
 }
 
-float _Map_getMinHeight(int teamId) {
+Export(float) _Map_getMinHeight(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMinHeight();
 }
 
-float _Map_getMaxHeight(int teamId) {
+Export(float) _Map_getMaxHeight(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMaxHeight();
 }
 
-const float* _Map_getSlopeMap(int teamId) {
+Export(const float*) _Map_getSlopeMap(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetSlopeMap();
 }
 
-const unsigned short* _Map_getLosMap(int teamId) {
+Export(const unsigned short*) _Map_getLosMap(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetLosMap();
 }
 
-const unsigned short* _Map_getRadarMap(int teamId) {
+Export(const unsigned short*) _Map_getRadarMap(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetRadarMap();
 }
 
-const unsigned short* _Map_getJammerMap(int teamId) {
+Export(const unsigned short*) _Map_getJammerMap(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetJammerMap();
 }
 
-const unsigned char* _Map_getMetalMap(int teamId) {
+Export(const unsigned char*) _Map_getMetalMap(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalMap();
 }
 
-const char* _Map_getName(int teamId) {
+Export(const char*) _Map_getName(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMapName();
 }
 
-float _Map_getElevationAt(int teamId, float x, float z) {
+Export(float) _Map_getElevationAt(int teamId, float x, float z) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetElevation(x, z);
 }
 
-float _Map_getMaxMetal(int teamId) {
+Export(float) _Map_getMaxMetal(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMaxMetal();
 }
 
-float _Map_getExtractorRadius(int teamId) {
+Export(float) _Map_getExtractorRadius(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetExtractorRadius();
 }
 
-float _Map_getMinWind(int teamId) {
+Export(float) _Map_getMinWind(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMinWind();
 }
 
-float _Map_getMaxWind(int teamId) {
+Export(float) _Map_getMaxWind(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMaxWind();
 }
 
-float _Map_getTidalStrength(int teamId) {
+Export(float) _Map_getTidalStrength(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetTidalStrength();
 }
 
-float _Map_getGravity(int teamId) {
+Export(float) _Map_getGravity(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetGravity();
 }
 
-bool _Map_canBuildAt(int teamId, int unitDefId, SAIFloat3 pos, int facing) {
+Export(bool) _Map_canBuildAt(int teamId, int unitDefId, SAIFloat3 pos, int facing) {
 	IAICallback* clb = team_callback[teamId];
 	const UnitDef* unitDef = getUnitDefById(teamId, unitDefId);
 	return clb-&gt;CanBuildAt(unitDef, pos, facing);
 }
 
-SAIFloat3 _Map_findClosestBuildSite(int teamId, int unitDefId, SAIFloat3 pos, float searchRadius, int minDist, int facing) {
+Export(SAIFloat3) _Map_findClosestBuildSite(int teamId, int unitDefId, SAIFloat3 pos, float searchRadius, int minDist, int facing) {
 	IAICallback* clb = team_callback[teamId];
 	const UnitDef* unitDef = getUnitDefById(teamId, unitDefId);
 	return clb-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing).toSAIFloat3();
 }
 
-int _Map_getPoints(int teamId, SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints) {
+Export(int) _Map_getPoints(int teamId, SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints) {
 	IAICallback* clb = team_callback[teamId];
 	PointMarker* pm = new PointMarker[maxPoints];
 	int numPoints = clb-&gt;GetMapPoints(pm, maxPoints);
@@ -2376,7 +2386,7 @@
 	return numPoints;
 }
 
-int _Map_getLines(int teamId, SAIFloat3* firstPositions, SAIFloat3* secondPositions, unsigned char** colors, int maxLines) {
+Export(int) _Map_getLines(int teamId, SAIFloat3* firstPositions, SAIFloat3* secondPositions, unsigned char** colors, int maxLines) {
 	IAICallback* clb = team_callback[teamId];
 	LineMarker* lm = new LineMarker[maxLines];
 	int numLines = clb-&gt;GetMapLines(lm, maxLines);
@@ -2392,7 +2402,7 @@
 
 
 /*
-bool _getProperty(int teamId, int id, int property, void* dst) {
+Export(bool) _getProperty(int teamId, int id, int property, void* dst) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetProperty(id, property, dst);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetProperty(id, property, dst);
@@ -2401,7 +2411,7 @@
 	}
 }
 
-bool _getValue(int teamId, int id, void* dst) {
+Export(bool) _getValue(int teamId, int id, void* dst) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetValue(id, dst);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetValue(id, dst);
@@ -2411,292 +2421,300 @@
 }
 */
 
-int _File_getSize(int teamId, const char* filename) {
+Export(int) _File_getSize(int teamId, const char* filename) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFileSize(filename);
 }
 
-bool _File_getContent(int teamId, const char* filename, void* buffer, int bufferLen) {
+Export(bool) _File_getContent(int teamId, const char* filename, void* buffer, int bufferLen) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;ReadFile(filename, buffer, bufferLen);
 }
 
-int _Unit_STATIC_getSelected(int teamId, int* units) {
+Export(int) _Unit_STATIC_getSelected(int teamId, int* units) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetSelectedUnits(units);
 }
 
-SAIFloat3 _Map_getMousePos(int teamId) {
+Export(SAIFloat3) _Map_getMousePos(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMousePos().toSAIFloat3();
 }
 
-float _ResourceInfo_Metal_getCurrent(int teamId) {
+Export(float) _ResourceInfo_Metal_getCurrent(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetal();
 }
 
-float _ResourceInfo_Metal_getIncome(int teamId) {
+Export(float) _ResourceInfo_Metal_getIncome(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalIncome();
 }
 
-float _ResourceInfo_Metal_getUsage(int teamId) {
+Export(float) _ResourceInfo_Metal_getUsage(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalUsage();
 }
 
-float _ResourceInfo_Metal_getStorage(int teamId) {
+Export(float) _ResourceInfo_Metal_getStorage(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetMetalStorage();
 }
 
-float _ResourceInfo_Energy_getCurrent(int teamId) {
+Export(float) _ResourceInfo_Energy_getCurrent(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergy();
 }
 
-float _ResourceInfo_Energy_getIncome(int teamId) {
+Export(float) _ResourceInfo_Energy_getIncome(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergyIncome();
 }
 
-float _ResourceInfo_Energy_getUsage(int teamId) {
+Export(float) _ResourceInfo_Energy_getUsage(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergyUsage();
 }
 
-float _ResourceInfo_Energy_getStorage(int teamId) {
+Export(float) _ResourceInfo_Energy_getStorage(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetEnergyStorage();
 }
 
-int _Feature_STATIC_getIds(int teamId, int *featureIds, int max) {
+Export(int) _Feature_STATIC_getIds(int teamId, int *featureIds, int max) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatures(featureIds, max);
 }
 
-int _Feature_STATIC_getIdsIn(int teamId, int *featureIds, int max, SAIFloat3 pos, float radius) {
+Export(int) _Feature_STATIC_getIdsIn(int teamId, int *featureIds, int max, SAIFloat3 pos, float radius) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatures(featureIds, max, pos, radius);
 }
 
 //########### BEGINN FeatureDef
-const char* _FeatureDef_getName(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;myName.c_str();}
-const char* _FeatureDef_getDescription(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;description.c_str();}
-const char* _FeatureDef_getFilename(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;filename.c_str();}
-int _FeatureDef_getId(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;id;}
-float _FeatureDef_getMetal(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;metal;}
-float _FeatureDef_getEnergy(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;energy;}
-float _FeatureDef_getMaxHealth(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;maxHealth;}
-float _FeatureDef_getReclaimTime(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;reclaimTime;}
-float _FeatureDef_getMass(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;mass;}
-const char* _FeatureDef_getCollisionVolumeType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeType.c_str();}	
-SAIFloat3 _FeatureDef_getCollisionVolumeScales(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeScales.toSAIFloat3();}		
-SAIFloat3 _FeatureDef_getCollisionVolumeOffsets(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeOffsets.toSAIFloat3();}		
-int _FeatureDef_getCollisionVolumeTest(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeTest;}			
-bool _FeatureDef_isUpright(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;upright;}
-int _FeatureDef_getDrawType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;drawType;}
-const char* _FeatureDef_getModelName(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;modelname.c_str();}
-int _FeatureDef_getModelType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;modelType;}
-bool _FeatureDef_isDestructable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;destructable;}
-bool _FeatureDef_isReclaimable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;reclaimable;}
-bool _FeatureDef_isBlocking(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;blocking;}
-bool _FeatureDef_isBurnable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;burnable;}
-bool _FeatureDef_isFloating(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;floating;}
-bool _FeatureDef_isNoSelect(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;noSelect;}
-bool _FeatureDef_isGeoThermal(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;geoThermal;}
-const char* _FeatureDef_getDeathFeature(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;deathFeature.c_str();}
-int _FeatureDef_getXsize(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;xsize;}
-int _FeatureDef_getYsize(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;ysize;}
-int _FeatureDef_getNumCustomParams(int teamId, int featureDefId) {
+Export(const char*) _FeatureDef_getName(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;myName.c_str();}
+Export(const char*) _FeatureDef_getDescription(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;description.c_str();}
+Export(const char*) _FeatureDef_getFilename(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;filename.c_str();}
+Export(int) _FeatureDef_getId(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;id;}
+Export(float) _FeatureDef_getMetal(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;metal;}
+Export(float) _FeatureDef_getEnergy(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;energy;}
+Export(float) _FeatureDef_getMaxHealth(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;maxHealth;}
+Export(float) _FeatureDef_getReclaimTime(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;reclaimTime;}
+Export(float) _FeatureDef_getMass(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;mass;}
+Export(const char*) _FeatureDef_getCollisionVolumeType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeType.c_str();}	
+Export(SAIFloat3) _FeatureDef_getCollisionVolumeScales(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeScales.toSAIFloat3();}		
+Export(SAIFloat3) _FeatureDef_getCollisionVolumeOffsets(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeOffsets.toSAIFloat3();}		
+Export(int) _FeatureDef_getCollisionVolumeTest(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;collisionVolumeTest;}			
+Export(bool) _FeatureDef_isUpright(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;upright;}
+Export(int) _FeatureDef_getDrawType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;drawType;}
+Export(const char*) _FeatureDef_getModelName(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;modelname.c_str();}
+Export(int) _FeatureDef_getModelType(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;modelType;}
+Export(bool) _FeatureDef_isDestructable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;destructable;}
+Export(bool) _FeatureDef_isReclaimable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;reclaimable;}
+Export(bool) _FeatureDef_isBlocking(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;blocking;}
+Export(bool) _FeatureDef_isBurnable(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;burnable;}
+Export(bool) _FeatureDef_isFloating(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;floating;}
+Export(bool) _FeatureDef_isNoSelect(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;noSelect;}
+Export(bool) _FeatureDef_isGeoThermal(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;geoThermal;}
+Export(const char*) _FeatureDef_getDeathFeature(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;deathFeature.c_str();}
+Export(int) _FeatureDef_getXsize(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;xsize;}
+Export(int) _FeatureDef_getYsize(int teamId, int featureDefId) {return getFeatureDefById(teamId, featureDefId)-&gt;ysize;}
+Export(int) _FeatureDef_getNumCustomParams(int teamId, int featureDefId) {
 	return getFeatureDefById(teamId, featureDefId)-&gt;customParams.size();
 }
-int _FeatureDef_getCustomParams(int teamId, int featureDefId, const char* map[][2]) {
+Export(int) _FeatureDef_getCustomParams(int teamId, int featureDefId, const char* map[][2]) {
 	return fillCMap(&amp;(getFeatureDefById(teamId, featureDefId)-&gt;customParams), map);
 }
 //########### END FeatureDef
 
-int _Feature_getDefId(int teamId, int featureId) {
+Export(int) _Feature_getDefId(int teamId, int featureId) {
 	IAICallback* clb = team_callback[teamId];
 	return clb-&gt;GetFeatureDef(featureId)-&gt;id;
 }
 
-float _Feature_getHealth(int teamId, int feature) {
+Export(float) _Feature_getHealth(int teamId, int feature) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatureHealth(feature);
 }
 
-float _Feature_getReclaimLeft(int teamId, int feature) {
+Export(float) _Feature_getReclaimLeft(int teamId, int feature) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeatureReclaimLeft(feature);
 }
 
-SAIFloat3 _Feature_getPos(int teamId, int feature) {
+Export(SAIFloat3) _Feature_getPos(int teamId, int feature) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetFeaturePos(feature).toSAIFloat3();
 }
 
-int _UnitDef_STATIC_getNumIds(int teamId) {
+Export(int) _UnitDef_STATIC_getNumIds(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNumUnitDefs();
 }
 
 //########### BEGINN WeaponDef
-int _WeaponDef_STATIC_getIdByName(int teamId, const char* weaponDefName) {
+Export(int) _WeaponDef_STATIC_getIdByName(int teamId, const char* weaponDefName) {
+	
+	int weaponDefId = -1;
+	
 	IAICallback* clb = team_callback[teamId];
-	return clb-&gt;GetWeapon(weaponDefName)-&gt;id;
+	const WeaponDef* wd = clb-&gt;GetWeapon(weaponDefName);
+	if (wd != NULL) {
+		weaponDefId = wd-&gt;id;
+	}
+	
+	return weaponDefId;
 }
 
-const char* _WeaponDef_getName(int teamId, int weaponDefId) {
+Export(const char*) _WeaponDef_getName(int teamId, int weaponDefId) {
 	return getWeaponDefById(teamId, weaponDefId)-&gt;name.c_str();
 }
-const char* _WeaponDef_getType(int teamId, int weaponDefId) {
+Export(const char*) _WeaponDef_getType(int teamId, int weaponDefId) {
 	return getWeaponDefById(teamId, weaponDefId)-&gt;type.c_str();
 }
-const char* _WeaponDef_getDescription(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;description.c_str();}
-const char* _WeaponDef_getFilename(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;filename.c_str();}
-const char* _WeaponDef_getCegTag(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cegTag.c_str();}
-float _WeaponDef_getRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;range;}
-float _WeaponDef_getHeightMod(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;heightmod;}
-float _WeaponDef_getAccuracy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;accuracy;}
-float _WeaponDef_getSprayAngle(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sprayAngle;}
-float _WeaponDef_getMovingAccuracy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;movingAccuracy;}
-float _WeaponDef_getTargetMoveError(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetMoveError;}
-float _WeaponDef_getLeadLimit(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;leadLimit;}
-float _WeaponDef_getLeadBonus(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;leadBonus;}
-float _WeaponDef_getPredictBoost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;predictBoost;}
-int _WeaponDef_Damages_getParalyzeDamageTime(int teamId, int weaponDefId) {
+Export(const char*) _WeaponDef_getDescription(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;description.c_str();}
+Export(const char*) _WeaponDef_getFilename(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;filename.c_str();}
+Export(const char*) _WeaponDef_getCegTag(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cegTag.c_str();}
+Export(float) _WeaponDef_getRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;range;}
+Export(float) _WeaponDef_getHeightMod(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;heightmod;}
+Export(float) _WeaponDef_getAccuracy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;accuracy;}
+Export(float) _WeaponDef_getSprayAngle(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sprayAngle;}
+Export(float) _WeaponDef_getMovingAccuracy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;movingAccuracy;}
+Export(float) _WeaponDef_getTargetMoveError(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetMoveError;}
+Export(float) _WeaponDef_getLeadLimit(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;leadLimit;}
+Export(float) _WeaponDef_getLeadBonus(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;leadBonus;}
+Export(float) _WeaponDef_getPredictBoost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;predictBoost;}
+Export(int) _WeaponDef_Damages_getParalyzeDamageTime(int teamId, int weaponDefId) {
 	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
 	return da.paralyzeDamageTime;
 }
-float _WeaponDef_Damages_getImpulseFactor(int teamId, int weaponDefId) {
+Export(float) _WeaponDef_Damages_getImpulseFactor(int teamId, int weaponDefId) {
 	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
 	return da.impulseFactor;
 }
-float _WeaponDef_Damages_getImpulseBoost(int teamId, int weaponDefId) {
+Export(float) _WeaponDef_Damages_getImpulseBoost(int teamId, int weaponDefId) {
 	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
 	return da.impulseBoost;
 }
-float _WeaponDef_Damages_getCraterMult(int teamId, int weaponDefId) {
+Export(float) _WeaponDef_Damages_getCraterMult(int teamId, int weaponDefId) {
 	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
 	return da.craterMult;
 }
-float _WeaponDef_Damages_getCraterBoost(int teamId, int weaponDefId) {
+Export(float) _WeaponDef_Damages_getCraterBoost(int teamId, int weaponDefId) {
 	DamageArray da = getWeaponDefById(teamId, weaponDefId)-&gt;damages;
 	return da.craterBoost;
 }
-int _WeaponDef_Damages_getNumTypes(int teamId, int weaponDefId) {
+Export(int) _WeaponDef_Damages_getNumTypes(int teamId, int weaponDefId) {
 	return getWeaponDefById(teamId, weaponDefId)-&gt;damages.GetNumTypes();
 }
-void _WeaponDef_Damages_getTypeDamages(int teamId, int weaponDefId, float* typeDamages) {
+Export(void) _WeaponDef_Damages_getTypeDamages(int teamId, int weaponDefId, float* typeDamages) {
 	int numTypes = _WeaponDef_Damages_getNumTypes(teamId, weaponDefId);
 	const WeaponDef* weaponDef = getWeaponDefById(teamId, weaponDefId);
 	for (int i=0; i &lt; numTypes; ++i) {
 		typeDamages[i] = weaponDef-&gt;damages[i];
 	}
 }
-float _WeaponDef_getAreaOfEffect(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;areaOfEffect;}
-bool _WeaponDef_isNoSelfDamage(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noSelfDamage;}
-float _WeaponDef_getFireStarter(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fireStarter;}
-float _WeaponDef_getEdgeEffectiveness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;edgeEffectiveness;}
-float _WeaponDef_getSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;size;}
-float _WeaponDef_getSizeGrowth(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sizeGrowth;}
-float _WeaponDef_getCollisionSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;collisionSize;}
-int _WeaponDef_getSalvoSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;salvosize;}
-float _WeaponDef_getSalvoDelay(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;salvodelay;}
-float _WeaponDef_getReload(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;reload;}
-float _WeaponDef_getBeamTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;beamtime;}
-bool _WeaponDef_isBeamBurst(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;beamburst;}
-bool _WeaponDef_isWaterBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;waterBounce;}
-bool _WeaponDef_isGroundBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;groundBounce;}
-float _WeaponDef_getBounceRebound(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;bounceRebound;}
-float _WeaponDef_getBounceSlip(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;bounceSlip;}
-int _WeaponDef_getNumBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;numBounce;}
-float _WeaponDef_getMaxAngle(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;maxAngle;}
-float _WeaponDef_getRestTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;restTime;}
-float _WeaponDef_getUpTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;uptime;}
-int _WeaponDef_getFlightTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;flighttime;}
-float _WeaponDef_getMetalCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;metalcost;}
-float _WeaponDef_getEnergyCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;energycost;}
-float _WeaponDef_getSupplyCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;supplycost;}
-int _WeaponDef_getProjectilesPerShot(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;projectilespershot;}
-int _WeaponDef_getId(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;id;}
-int _WeaponDef_getTdfId(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;tdfId;}
-bool _WeaponDef_isTurret(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;turret;}
-bool _WeaponDef_isOnlyForward(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;onlyForward;}
-bool _WeaponDef_isFixedLauncher(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fixedLauncher;}
-bool _WeaponDef_isWaterWeapon(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;waterweapon;}
-bool _WeaponDef_isFireSubmersed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fireSubmersed;}
-bool _WeaponDef_isSubMissile(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;submissile;}
-bool _WeaponDef_isTracks(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;tracks;}
-bool _WeaponDef_isDropped(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dropped;}
-bool _WeaponDef_isParalyzer(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;paralyzer;}
-bool _WeaponDef_isImpactOnly(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;impactOnly;}
-bool _WeaponDef_isNoAutoTarget(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noAutoTarget;}
-bool _WeaponDef_isManualFire(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;manualfire;}
-int _WeaponDef_getInterceptor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;interceptor;}
-int _WeaponDef_getTargetable(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetable;}
-bool _WeaponDef_isStockpileable(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;stockpile;}
-float _WeaponDef_getCoverageRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;coverageRange;}
-float _WeaponDef_getIntensity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;intensity;}
-float _WeaponDef_getThickness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;thickness;}
-float _WeaponDef_getLaserFlareSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;laserflaresize;}
-float _WeaponDef_getCoreThickness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;corethickness;}
-float _WeaponDef_getDuration(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;duration;}
-int _WeaponDef_getLodDistance(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;lodDistance;}
-float _WeaponDef_getFalloffRate(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;falloffRate;}
-int _WeaponDef_getGraphicsType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;graphicsType;}
-bool _WeaponDef_isSoundTrigger(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;soundTrigger;}
-bool _WeaponDef_isSelfExplode(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;selfExplode;}
-bool _WeaponDef_isGravityAffected(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;gravityAffected;}
-int _WeaponDef_getHighTrajectory(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;highTrajectory;}
-float _WeaponDef_getMyGravity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;myGravity;}
-bool _WeaponDef_isTwoPhase(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;twophase;}
-bool _WeaponDef_isGuided(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;guided;}
-bool _WeaponDef_isVLaunched(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;vlaunch;}
-bool _WeaponDef_isSelfPropelled(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;selfprop;}
-bool _WeaponDef_isNoExplode(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noExplode;}
-float _WeaponDef_getStartVelocity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;startvelocity;}
-float _WeaponDef_getWeaponAcceleration(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;weaponacceleration;}
-float _WeaponDef_getTurnRate(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;turnrate;}
-float _WeaponDef_getMaxVelocity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;maxvelocity;}
-float _WeaponDef_getProjectileSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;projectilespeed;}
-float _WeaponDef_getExplosionSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;explosionSpeed;}
-unsigned int _WeaponDef_getOnlyTargetCategory(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;onlyTargetCategory;}
-float _WeaponDef_getWobble(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;wobble;}
-float _WeaponDef_getDance(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dance;}
-float _WeaponDef_getTrajectoryHeight(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;trajectoryHeight;}
-bool _WeaponDef_isLargeBeamLaser(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;largeBeamLaser;}
-bool _WeaponDef_isShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;isShield;}
-bool _WeaponDef_isShieldRepulser(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRepulser;}
-bool _WeaponDef_isSmartShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;smartShield;}
-bool _WeaponDef_isExteriorShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;exteriorShield;}
-bool _WeaponDef_isVisibleShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShield;}
-bool _WeaponDef_isVisibleShieldRepulse(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShieldRepulse;}
-int _WeaponDef_getVisibleShieldHitFrames(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShieldHitFrames;}
-float _WeaponDef_getShieldEnergyUse(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldEnergyUse;}
-float _WeaponDef_getShieldRadius(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRadius;}
-float _WeaponDef_getShieldForce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldForce;}
-float _WeaponDef_getShieldMaxSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldMaxSpeed;}
-float _WeaponDef_getShieldPower(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPower;}
-float _WeaponDef_getShieldPowerRegen(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPowerRegen;}
-float _WeaponDef_getShieldPowerRegenEnergy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPowerRegenEnergy;}
-float _WeaponDef_getShieldStartingPower(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldStartingPower;}
-int _WeaponDef_getShieldRechargeDelay(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRechargeDelay;}
-SAIFloat3 _WeaponDef_getShieldGoodColor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldGoodColor.toSAIFloat3();}
-SAIFloat3 _WeaponDef_getShieldBadColor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldBadColor.toSAIFloat3();}
-float _WeaponDef_getShieldAlpha(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldAlpha;}
-unsigned int _WeaponDef_getShieldInterceptType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldInterceptType;}
-unsigned int _WeaponDef_getInterceptedByShieldType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;interceptedByShieldType;}
-bool _WeaponDef_isAvoidFriendly(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidFriendly;}
-bool _WeaponDef_isAvoidFeature(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidFeature;}
-bool _WeaponDef_isAvoidNeutral(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidNeutral;}
-float _WeaponDef_getTargetBorder(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetBorder;}
-float _WeaponDef_getCylinderTargetting(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cylinderTargetting;}
-float _WeaponDef_getMinIntensity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;minIntensity;}
-float _WeaponDef_getHeightBoostFactor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;heightBoostFactor;}
-float _WeaponDef_getProximityPriority(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;proximityPriority;}
-unsigned int _WeaponDef_getCollisionFlags(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;collisionFlags;}
-bool _WeaponDef_isSweepFire(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sweepFire;}
-bool _WeaponDef_isCanAttackGround(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;canAttackGround;}
-float _WeaponDef_getCameraShake(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cameraShake;}
-float _WeaponDef_getDynDamageExp(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageExp;}
-float _WeaponDef_getDynDamageMin(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageMin;}
-float _WeaponDef_getDynDamageRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageRange;}
-bool _WeaponDef_isDynDamageInverted(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageInverted;}
-int _WeaponDef_getNumCustomParams(int teamId, int weaponDefId) {
+Export(float) _WeaponDef_getAreaOfEffect(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;areaOfEffect;}
+Export(bool) _WeaponDef_isNoSelfDamage(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noSelfDamage;}
+Export(float) _WeaponDef_getFireStarter(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fireStarter;}
+Export(float) _WeaponDef_getEdgeEffectiveness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;edgeEffectiveness;}
+Export(float) _WeaponDef_getSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;size;}
+Export(float) _WeaponDef_getSizeGrowth(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sizeGrowth;}
+Export(float) _WeaponDef_getCollisionSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;collisionSize;}
+Export(int) _WeaponDef_getSalvoSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;salvosize;}
+Export(float) _WeaponDef_getSalvoDelay(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;salvodelay;}
+Export(float) _WeaponDef_getReload(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;reload;}
+Export(float) _WeaponDef_getBeamTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;beamtime;}
+Export(bool) _WeaponDef_isBeamBurst(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;beamburst;}
+Export(bool) _WeaponDef_isWaterBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;waterBounce;}
+Export(bool) _WeaponDef_isGroundBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;groundBounce;}
+Export(float) _WeaponDef_getBounceRebound(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;bounceRebound;}
+Export(float) _WeaponDef_getBounceSlip(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;bounceSlip;}
+Export(int) _WeaponDef_getNumBounce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;numBounce;}
+Export(float) _WeaponDef_getMaxAngle(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;maxAngle;}
+Export(float) _WeaponDef_getRestTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;restTime;}
+Export(float) _WeaponDef_getUpTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;uptime;}
+Export(int) _WeaponDef_getFlightTime(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;flighttime;}
+Export(float) _WeaponDef_getMetalCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;metalcost;}
+Export(float) _WeaponDef_getEnergyCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;energycost;}
+Export(float) _WeaponDef_getSupplyCost(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;supplycost;}
+Export(int) _WeaponDef_getProjectilesPerShot(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;projectilespershot;}
+Export(int) _WeaponDef_getId(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;id;}
+Export(int) _WeaponDef_getTdfId(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;tdfId;}
+Export(bool) _WeaponDef_isTurret(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;turret;}
+Export(bool) _WeaponDef_isOnlyForward(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;onlyForward;}
+Export(bool) _WeaponDef_isFixedLauncher(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fixedLauncher;}
+Export(bool) _WeaponDef_isWaterWeapon(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;waterweapon;}
+Export(bool) _WeaponDef_isFireSubmersed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;fireSubmersed;}
+Export(bool) _WeaponDef_isSubMissile(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;submissile;}
+Export(bool) _WeaponDef_isTracks(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;tracks;}
+Export(bool) _WeaponDef_isDropped(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dropped;}
+Export(bool) _WeaponDef_isParalyzer(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;paralyzer;}
+Export(bool) _WeaponDef_isImpactOnly(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;impactOnly;}
+Export(bool) _WeaponDef_isNoAutoTarget(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noAutoTarget;}
+Export(bool) _WeaponDef_isManualFire(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;manualfire;}
+Export(int) _WeaponDef_getInterceptor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;interceptor;}
+Export(int) _WeaponDef_getTargetable(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetable;}
+Export(bool) _WeaponDef_isStockpileable(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;stockpile;}
+Export(float) _WeaponDef_getCoverageRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;coverageRange;}
+Export(float) _WeaponDef_getIntensity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;intensity;}
+Export(float) _WeaponDef_getThickness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;thickness;}
+Export(float) _WeaponDef_getLaserFlareSize(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;laserflaresize;}
+Export(float) _WeaponDef_getCoreThickness(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;corethickness;}
+Export(float) _WeaponDef_getDuration(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;duration;}
+Export(int) _WeaponDef_getLodDistance(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;lodDistance;}
+Export(float) _WeaponDef_getFalloffRate(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;falloffRate;}
+Export(int) _WeaponDef_getGraphicsType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;graphicsType;}
+Export(bool) _WeaponDef_isSoundTrigger(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;soundTrigger;}
+Export(bool) _WeaponDef_isSelfExplode(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;selfExplode;}
+Export(bool) _WeaponDef_isGravityAffected(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;gravityAffected;}
+Export(int) _WeaponDef_getHighTrajectory(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;highTrajectory;}
+Export(float) _WeaponDef_getMyGravity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;myGravity;}
+Export(bool) _WeaponDef_isTwoPhase(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;twophase;}
+Export(bool) _WeaponDef_isGuided(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;guided;}
+Export(bool) _WeaponDef_isVLaunched(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;vlaunch;}
+Export(bool) _WeaponDef_isSelfPropelled(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;selfprop;}
+Export(bool) _WeaponDef_isNoExplode(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;noExplode;}
+Export(float) _WeaponDef_getStartVelocity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;startvelocity;}
+Export(float) _WeaponDef_getWeaponAcceleration(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;weaponacceleration;}
+Export(float) _WeaponDef_getTurnRate(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;turnrate;}
+Export(float) _WeaponDef_getMaxVelocity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;maxvelocity;}
+Export(float) _WeaponDef_getProjectileSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;projectilespeed;}
+Export(float) _WeaponDef_getExplosionSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;explosionSpeed;}
+Export(unsigned int) _WeaponDef_getOnlyTargetCategory(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;onlyTargetCategory;}
+Export(float) _WeaponDef_getWobble(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;wobble;}
+Export(float) _WeaponDef_getDance(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dance;}
+Export(float) _WeaponDef_getTrajectoryHeight(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;trajectoryHeight;}
+Export(bool) _WeaponDef_isLargeBeamLaser(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;largeBeamLaser;}
+Export(bool) _WeaponDef_isShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;isShield;}
+Export(bool) _WeaponDef_isShieldRepulser(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRepulser;}
+Export(bool) _WeaponDef_isSmartShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;smartShield;}
+Export(bool) _WeaponDef_isExteriorShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;exteriorShield;}
+Export(bool) _WeaponDef_isVisibleShield(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShield;}
+Export(bool) _WeaponDef_isVisibleShieldRepulse(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShieldRepulse;}
+Export(int) _WeaponDef_getVisibleShieldHitFrames(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;visibleShieldHitFrames;}
+Export(float) _WeaponDef_getShieldEnergyUse(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldEnergyUse;}
+Export(float) _WeaponDef_getShieldRadius(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRadius;}
+Export(float) _WeaponDef_getShieldForce(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldForce;}
+Export(float) _WeaponDef_getShieldMaxSpeed(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldMaxSpeed;}
+Export(float) _WeaponDef_getShieldPower(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPower;}
+Export(float) _WeaponDef_getShieldPowerRegen(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPowerRegen;}
+Export(float) _WeaponDef_getShieldPowerRegenEnergy(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldPowerRegenEnergy;}
+Export(float) _WeaponDef_getShieldStartingPower(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldStartingPower;}
+Export(int) _WeaponDef_getShieldRechargeDelay(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldRechargeDelay;}
+Export(struct SAIFloat3) _WeaponDef_getShieldGoodColor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldGoodColor.toSAIFloat3();}
+Export(struct SAIFloat3) _WeaponDef_getShieldBadColor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldBadColor.toSAIFloat3();}
+Export(float) _WeaponDef_getShieldAlpha(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldAlpha;}
+Export(unsigned int) _WeaponDef_getShieldInterceptType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;shieldInterceptType;}
+Export(unsigned int) _WeaponDef_getInterceptedByShieldType(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;interceptedByShieldType;}
+Export(bool) _WeaponDef_isAvoidFriendly(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidFriendly;}
+Export(bool) _WeaponDef_isAvoidFeature(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidFeature;}
+Export(bool) _WeaponDef_isAvoidNeutral(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;avoidNeutral;}
+Export(float) _WeaponDef_getTargetBorder(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;targetBorder;}
+Export(float) _WeaponDef_getCylinderTargetting(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cylinderTargetting;}
+Export(float) _WeaponDef_getMinIntensity(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;minIntensity;}
+Export(float) _WeaponDef_getHeightBoostFactor(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;heightBoostFactor;}
+Export(float) _WeaponDef_getProximityPriority(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;proximityPriority;}
+Export(unsigned int) _WeaponDef_getCollisionFlags(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;collisionFlags;}
+Export(bool) _WeaponDef_isSweepFire(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;sweepFire;}
+Export(bool) _WeaponDef_isCanAttackGround(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;canAttackGround;}
+Export(float) _WeaponDef_getCameraShake(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;cameraShake;}
+Export(float) _WeaponDef_getDynDamageExp(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageExp;}
+Export(float) _WeaponDef_getDynDamageMin(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageMin;}
+Export(float) _WeaponDef_getDynDamageRange(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageRange;}
+Export(bool) _WeaponDef_isDynDamageInverted(int teamId, int weaponDefId) {return getWeaponDefById(teamId, weaponDefId)-&gt;dynDamageInverted;}
+Export(int) _WeaponDef_getNumCustomParams(int teamId, int weaponDefId) {
 	return getWeaponDefById(teamId, weaponDefId)-&gt;customParams.size();
 }
-int _WeaponDef_getCustomParams(int teamId, int weaponDefId, const char* map[][2]) {
+Export(int) _WeaponDef_getCustomParams(int teamId, int weaponDefId, const char* map[][2]) {
 	return fillCMap(&amp;(getWeaponDefById(teamId, weaponDefId)-&gt;customParams), map);
 }
 //########### END WeaponDef
 
 
-SAIFloat3 _Map_getStartPos(int teamId) {
+Export(SAIFloat3) _Map_getStartPos(int teamId) {
 	IAICallback* clb = team_callback[teamId];
 	return clb-&gt;GetStartPos()-&gt;toSAIFloat3();
 }
@@ -2712,23 +2730,23 @@
 
 
 /*
-void _sendTextMsg(int teamId, const char* text, int zone) {
+Export(void) _sendTextMsg(int teamId, const char* text, int zone) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;SendTextMsg(text, zone);
 }
 
-void _setLastMsgPos(int teamId, SAIFloat3 pos) {
+Export(void) _setLastMsgPos(int teamId, SAIFloat3 pos) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;SetLastMsgPos(pos);
 }
 
-void _addNotification(int teamId, SAIFloat3 pos, SAIFloat3 color, float alpha) {
+Export(void) _addNotification(int teamId, SAIFloat3 pos, SAIFloat3 color, float alpha) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;AddNotification(pos, color, alpha);
 }
 
-bool _sendResources(int teamId, float mAmount, float eAmount, int receivingTeam) {
+Export(bool) _sendResources(int teamId, float mAmount, float eAmount, int receivingTeam) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;SendResources(mAmount, eAmount, receivingTeam);
 }
 
-int _sendUnits(int teamId, int numUnitIds, const int* unitIds, int receivingTeam) {
+Export(int) _sendUnits(int teamId, int numUnitIds, const int* unitIds, int receivingTeam) {
 	IAICallback* clb = team_callback[teamId];
 	std::vector&lt;int&gt; unitIdVector(numUnitIds);
 	int i;
@@ -2738,28 +2756,28 @@
 	return clb-&gt;SendUnits(unitIdVector, receivingTeam);
 }
 
-void* _createSharedMemArea(int teamId, char* name, int size) {
+Export(void*) _createSharedMemArea(int teamId, char* name, int size) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateSharedMemArea(name, size);
 }
 
-void _releasedSharedMemArea(int teamId, char* name) {
+Export(void) _releasedSharedMemArea(int teamId, char* name) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;ReleasedSharedMemArea(name);
 }
 
-int _Group_create(int teamId, char* dll, unsigned aiNumber) {
+Export(int) _Group_create(int teamId, char* dll, unsigned aiNumber) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateGroup(dll, aiNumber);
 }
 
-void _Group_erase(int teamId, int groupId) {
+Export(void) _Group_erase(int teamId, int groupId) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;EraseGroup(groupId);
 }
 */
 
-int _Group_getNumSupportedCommands(int teamId, int groupId) {
+Export(int) _Group_getNumSupportedCommands(int teamId, int groupId) {
 	IAICallback* clb = team_callback[teamId];
 	return clb-&gt;GetGroupCommands(groupId)-&gt;size();
 }
-int _Group_SupportedCommands_getId(int teamId, int groupId, int* ids) {
+Export(int) _Group_SupportedCommands_getId(int teamId, int groupId, int* ids) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2768,7 +2786,7 @@
 	}
 	return numComDescs;
 }
-int _Group_SupportedCommands_getName(int teamId, int groupId, const char** names) {
+Export(int) _Group_SupportedCommands_getName(int teamId, int groupId, const char** names) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2777,7 +2795,7 @@
 	}
 	return numComDescs;
 }
-int _Group_SupportedCommands_getToolTip(int teamId, int groupId, const char** toolTips) {
+Export(int) _Group_SupportedCommands_getToolTip(int teamId, int groupId, const char** toolTips) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2786,7 +2804,7 @@
 	}
 	return numComDescs;
 }
-int _Group_SupportedCommands_isShowUnique(int teamId, int groupId, bool* showUniques) {
+Export(int) _Group_SupportedCommands_isShowUnique(int teamId, int groupId, bool* showUniques) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2795,7 +2813,7 @@
 	}
 	return numComDescs;
 }
-int _Group_SupportedCommands_isDisabled(int teamId, int groupId, bool* disableds) {
+Export(int) _Group_SupportedCommands_isDisabled(int teamId, int groupId, bool* disableds) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2804,7 +2822,7 @@
 	}
 	return numComDescs;
 }
-int _Group_SupportedCommands_getNumParams(int teamId, int groupId, int* numParams) {
+Export(int) _Group_SupportedCommands_getNumParams(int teamId, int groupId, int* numParams) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2813,13 +2831,13 @@
 	}
 	return numComDescs;
 }
-int _Group_SupportedCommands_getParams(int teamId, int groupId, const char*** params) {
+Export(int) _Group_SupportedCommands_getParams(int teamId, int groupId, const char*** params) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
 	for (int c=0; c &lt; numComDescs; c++) {
 		const std::vector&lt;std::string&gt; ps = comDescs-&gt;at(c).params;
-		for (int p=0; p &lt; ps.size(); p++) {
+		for (unsigned int p=0; p &lt; ps.size(); p++) {
 			params[c][p] = ps.at(p).c_str();
 		}
 	}
@@ -2827,11 +2845,11 @@
 }
 
 /*
-bool _Unit_addToGroup(int teamId, int unitId, int groupId) {
+Export(bool) _Unit_addToGroup(int teamId, int unitId, int groupId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;AddUnitToGroup(unitId, groupId);
 }
 
-bool _Unit_removeFromGroup(int teamId, int unitId) {
+Export(bool) _Unit_removeFromGroup(int teamId, int unitId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;RemoveUnitFromGroup(unitId);
 }
 */
@@ -2845,63 +2863,63 @@
 //}
 /*
 
-int _initPath(int teamId, SAIFloat3 start, SAIFloat3 end, int pathType) {
+Export(int) _initPath(int teamId, SAIFloat3 start, SAIFloat3 end, int pathType) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;InitPath(start, end, pathType);
 }
 
-void _freePath(int teamId, int pathid) {
+Export(void) _freePath(int teamId, int pathid) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;FreePath(pathid);
 }
 
-void _LineDrawer_startPath(int teamId, SAIFloat3 pos, const float* color) {
+Export(void) _LineDrawer_startPath(int teamId, SAIFloat3 pos, const float* color) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerStartPath(pos, color);
 }
 
-void _LineDrawer_finishPath(int teamId) {
+Export(void) _LineDrawer_finishPath(int teamId) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerFinishPath();
 }
 
-void _LineDrawer_drawLine(int teamId, SAIFloat3 endPos, const float* color) {
+Export(void) _LineDrawer_drawLine(int teamId, SAIFloat3 endPos, const float* color) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerDrawLine(endPos, color);
 }
 
-void _LineDrawer_drawLineAndIcon(int teamId, int cmdID, SAIFloat3 endPos, const float* color) {
+Export(void) _LineDrawer_drawLineAndIcon(int teamId, int cmdID, SAIFloat3 endPos, const float* color) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerDrawLineAndIcon(cmdID, endPos, color);
 }
 
-void _LineDrawer_drawIconAtLastPos(int teamId, int cmdID) {
+Export(void) _LineDrawer_drawIconAtLastPos(int teamId, int cmdID) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerDrawIconAtLastPos(cmdID);
 }
 
-void _LineDrawer_break(int teamId, SAIFloat3 endPos, const float* color) {
+Export(void) _LineDrawer_break(int teamId, SAIFloat3 endPos, const float* color) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerBreak(endPos, color);
 }
 
-void _LineDrawer_restart(int teamId) {
+Export(void) _LineDrawer_restart(int teamId) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerRestart();
 }
 
-void _LineDrawer_restartSameColor(int teamId) {
+Export(void) _LineDrawer_restartSameColor(int teamId) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;LineDrawerRestartSameColor();
 }
 
-int _createSplineFigure(int teamId, SAIFloat3 pos1, SAIFloat3 pos2, SAIFloat3 pos3, SAIFloat3 pos4, float width, int arrow, int lifetime, int figureGroupId) {
+Export(int) _createSplineFigure(int teamId, SAIFloat3 pos1, SAIFloat3 pos2, SAIFloat3 pos3, SAIFloat3 pos4, float width, int arrow, int lifetime, int figureGroupId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateSplineFigure(pos1, pos2, pos3, pos4, width, arrow, lifetime, figureGroupId);
 }
 
-int _createLineFigure(int teamId, SAIFloat3 pos1, SAIFloat3 pos2, float width, int arrow, int lifetime, int figureGroupId) {
+Export(int) _createLineFigure(int teamId, SAIFloat3 pos1, SAIFloat3 pos2, float width, int arrow, int lifetime, int figureGroupId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;CreateLineFigure(pos1, pos2, width, arrow, lifetime, figureGroupId);
 }
 
-void _setFigureColor(int teamId, int group, float red, float green, float blue, float alpha) {
+Export(void) _setFigureColor(int teamId, int group, float red, float green, float blue, float alpha) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;SetFigureColor(group, red, green, blue, alpha);
 }
 
-void _deleteFigureGroup(int teamId, int figureGroupId) {
+Export(void) _deleteFigureGroup(int teamId, int figureGroupId) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;DeleteFigureGroup(figureGroupId);
 }
 
-void _drawUnit(int teamId, const char* name, SAIFloat3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
+Export(void) _drawUnit(int teamId, const char* name, SAIFloat3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
 	IAICallback* clb = team_callback[teamId]; clb-&gt;DrawUnit(name, pos, rotation, lifetime, team, transparent, drawBorder, facing);
 }
 */
@@ -2911,11 +2929,11 @@
 //}
 
 /*
-bool _readFile(int teamId, const char* name, void* buffer, int bufferLen) {
+Export(bool) _readFile(int teamId, const char* name, void* buffer, int bufferLen) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;ReadFile(name, buffer, bufferLen);
 }
 
-const char* _callLuaRules(int teamId, const char* data, int inSize, int* outSize) {
+Export(const char*) _callLuaRules(int teamId, const char* data, int inSize, int* outSize) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;CallLuaRules(data, inSize, outSize);
 }
 */

Deleted: branches/caiinterface/rts/ExternalAI/SAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAICallback.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/SAICallback.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,665 +0,0 @@
-/*
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _SAICALLBACK_H
-#define	_SAICALLBACK_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-    
-#define MAX_AIS 32
-    
-#include &quot;SAIFloat3.h&quot;
-
-
-/**
- * Global AI Callback function pointers.
- */
-struct SAICallback {
-
-/**
- * Whenever an AI wants to change engine state in any way, it has to call this method.
- * In other words, all commands from AIs to the engine (and other AIs) go through this method.
- *
- * teamId	the team number of the AI that sends the command
- * toId		the team number of the AI that should receive the command,
- * 		or COMMAND_TO_ID_ENGINE if it is meant for the engine
- * commandId	used on asynchronous commands, this allows the AI to identify
- * 		a possible result event, which would come with the same id
- * commandTopic	unique identifyer of a command (see COMMAND_* defines in AISCommands.h)
- * commandData	a commandTopic specific struct, which contains the data associated
- * 		with the command (see *Command structs)
- * return	0 if command handling ok, something else otherwise
- */
-int (*handleCommand)(int teamId, int toId, int commandId, int commandTopic, void* commandData);
-
-
-// BEGINN misc callback functions
-int (*Game_getCurrentFrame)(int teamId); //TODO: deprecate, becuase we get the frame from the SUpdateEvent
-int (*Game_getAiInterfaceVersion)(int teamId);
-int (*Game_getMyTeam)(int teamId);
-int (*Game_getMyAllyTeam)(int teamId);
-int (*Game_getPlayerTeam)(int teamId, int playerId);
-const char* (*Game_getTeamSide)(int teamId, int otherTeamId);
-// END misc callback functions
-
-int (*WeaponDef_STATIC_getNumDamageTypes)(int teamId);
-unsigned int (*Map_getChecksum)(int teamId);
-
-bool (*Game_isExceptionHandlingEnabled)(int teamId);
-bool (*Game_isDebugModeEnabled)(int teamId);
-int (*Game_getMode)(int teamId);
-bool (*Game_isPaused)(int teamId);
-float (*Game_getSpeedFactor)(int teamId);
-
-float (*Gui_getViewRange)(int teamId);
-float (*Gui_getScreenX)(int teamId);
-float (*Gui_getScreenY)(int teamId);
-SAIFloat3 (*Gui_Camera_getDirection)(int teamId);
-SAIFloat3 (*Gui_Camera_getPosition)(int teamId);
-
-bool (*File_locateForReading)(int teamId, char* filename);
-bool (*File_locateForWriting)(int teamId, char* filename);
-
-int (*Unit_STATIC_getLimit)(int teamId);
-const char* (*Game_getSetupScript)(int teamId);
-
-
-// BEGINN kind of deprecated; it is recommended not to use these
-//bool (*getProperty)(int teamId, int id, int property, void* dst);
-//bool (*getValue)(int teamId, int id, void* dst);
-// END kind of deprecated; it is recommended not to use these
-
-
-// BEGINN OBJECT Cheats
-bool (*Cheats_isEnabled)(int teamId);
-bool (*Cheats_setEnabled)(int teamId, bool enable);
-bool (*Cheats_setEventsEnabled)(int teamId, bool enabled);
-bool (*Cheats_isOnlyPassive)(int teamId);
-// END OBJECT Cheats
-
-
-// BEGINN OBJECT ResourceInfo
-float (*ResourceInfo_Metal_getCurrent)(int teamId);
-float (*ResourceInfo_Metal_getIncome)(int teamId);
-float (*ResourceInfo_Metal_getUsage)(int teamId);
-float (*ResourceInfo_Metal_getStorage)(int teamId);
-float (*ResourceInfo_Energy_getCurrent)(int teamId);
-float (*ResourceInfo_Energy_getIncome)(int teamId);
-float (*ResourceInfo_Energy_getUsage)(int teamId);
-float (*ResourceInfo_Energy_getStorage)(int teamId);
-// END OBJECT ResourceInfo
-
-
-// BEGINN OBJECT File
-int (*File_getSize)(int teamId, const char* fileName);
-bool (*File_getContent)(int teamId, const char* filename, void* buffer, int bufferLen);
-// END OBJECT File
-
-
-// BEGINN OBJECT UnitDef
-int (*UnitDef_STATIC_getIds)(int teamId, int* unitDefIds);
-int (*UnitDef_STATIC_getNumIds)(int teamId);
-int (*UnitDef_STATIC_getIdByName)(int teamId, const char* unitName);
-
-float (*UnitDef_getHeight)(int teamId, int unitDefId);
-float (*UnitDef_getRadius)(int teamId, int unitDefId);
-
-bool (*UnitDef_isValid)(int teamId, int unitDefId);
-const char* (*UnitDef_getName)(int teamId, int unitDefId);
-const char* (*UnitDef_getHumanName)(int teamId, int unitDefId);
-const char* (*UnitDef_getFilename)(int teamId, int unitDefId);
-int (*UnitDef_getId)(int teamId, int unitDefId);
-int (*UnitDef_getAiHint)(int teamId, int unitDefId);
-int (*UnitDef_getCobID)(int teamId, int unitDefId);
-int (*UnitDef_getTechLevel)(int teamId, int unitDefId);
-const char* (*UnitDef_getGaia)(int teamId, int unitDefId);
-float (*UnitDef_getMetalUpkeep)(int teamId, int unitDefId);
-float (*UnitDef_getEnergyUpkeep)(int teamId, int unitDefId);
-float (*UnitDef_getMetalMake)(int teamId, int unitDefId);
-float (*UnitDef_getMakesMetal)(int teamId, int unitDefId);
-float (*UnitDef_getEnergyMake)(int teamId, int unitDefId);
-float (*UnitDef_getMetalCost)(int teamId, int unitDefId);
-float (*UnitDef_getEnergyCost)(int teamId, int unitDefId);
-float (*UnitDef_getBuildTime)(int teamId, int unitDefId);
-float (*UnitDef_getExtractsMetal)(int teamId, int unitDefId);
-float (*UnitDef_getExtractRange)(int teamId, int unitDefId);
-float (*UnitDef_getWindGenerator)(int teamId, int unitDefId);
-float (*UnitDef_getTidalGenerator)(int teamId, int unitDefId);
-float (*UnitDef_getMetalStorage)(int teamId, int unitDefId);
-float (*UnitDef_getEnergyStorage)(int teamId, int unitDefId);
-float (*UnitDef_getAutoHeal)(int teamId, int unitDefId);
-float (*UnitDef_getIdleAutoHeal)(int teamId, int unitDefId);
-int (*UnitDef_getIdleTime)(int teamId, int unitDefId);
-float (*UnitDef_getPower)(int teamId, int unitDefId);
-float (*UnitDef_getHealth)(int teamId, int unitDefId);
-unsigned int (*UnitDef_getCategory)(int teamId, int unitDefId);
-float (*UnitDef_getSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getTurnRate)(int teamId, int unitDefId);
-int (*UnitDef_getMoveType)(int teamId, int unitDefId);
-bool (*UnitDef_isUpright)(int teamId, int unitDefId);
-bool (*UnitDef_isCollide)(int teamId, int unitDefId);
-float (*UnitDef_getControlRadius)(int teamId, int unitDefId);
-float (*UnitDef_getLosRadius)(int teamId, int unitDefId);
-float (*UnitDef_getAirLosRadius)(int teamId, int unitDefId);
-float (*UnitDef_getLosHeight)(int teamId, int unitDefId);
-int (*UnitDef_getRadarRadius)(int teamId, int unitDefId);
-int (*UnitDef_getSonarRadius)(int teamId, int unitDefId);
-int (*UnitDef_getJammerRadius)(int teamId, int unitDefId);
-int (*UnitDef_getSonarJamRadius)(int teamId, int unitDefId);
-int (*UnitDef_getSeismicRadius)(int teamId, int unitDefId);
-float (*UnitDef_getSeismicSignature)(int teamId, int unitDefId);
-bool (*UnitDef_isStealth)(int teamId, int unitDefId);
-bool (*UnitDef_isSonarStealth)(int teamId, int unitDefId);
-bool (*UnitDef_isBuildRange3D)(int teamId, int unitDefId);
-float (*UnitDef_getBuildDistance)(int teamId, int unitDefId);
-float (*UnitDef_getBuildSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getReclaimSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getRepairSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getMaxRepairSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getResurrectSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getCaptureSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getTerraformSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getMass)(int teamId, int unitDefId);
-bool (*UnitDef_isPushResistant)(int teamId, int unitDefId);
-bool (*UnitDef_isStrafeToAttack)(int teamId, int unitDefId);
-float (*UnitDef_getMinCollisionSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getSlideTolerance)(int teamId, int unitDefId);
-float (*UnitDef_getMaxSlope)(int teamId, int unitDefId);
-float (*UnitDef_getMaxHeightDif)(int teamId, int unitDefId);
-float (*UnitDef_getMinWaterDepth)(int teamId, int unitDefId);
-float (*UnitDef_getWaterline)(int teamId, int unitDefId);
-float (*UnitDef_getMaxWaterDepth)(int teamId, int unitDefId);
-float (*UnitDef_getArmoredMultiple)(int teamId, int unitDefId);
-int (*UnitDef_getArmorType)(int teamId, int unitDefId);
-int (*UnitDef_getFlankingBonusMode)(int teamId, int unitDefId);
-SAIFloat3 (*UnitDef_getFlankingBonusDir)(int teamId, int unitDefId);
-float (*UnitDef_getFlankingBonusMax)(int teamId, int unitDefId);
-float (*UnitDef_getFlankingBonusMin)(int teamId, int unitDefId);
-float (*UnitDef_getFlankingBonusMobilityAdd)(int teamId, int unitDefId);
-const char* (*UnitDef_getCollisionVolumeType)(int teamId, int unitDefId);
-SAIFloat3 (*UnitDef_getCollisionVolumeScales)(int teamId, int unitDefId);
-SAIFloat3 (*UnitDef_getCollisionVolumeOffsets)(int teamId, int unitDefId);
-int (*UnitDef_getCollisionVolumeTest)(int teamId, int unitDefId);
-float (*UnitDef_getMaxWeaponRange)(int teamId, int unitDefId);
-const char* (*UnitDef_getType)(int teamId, int unitDefId);
-const char* (*UnitDef_getTooltip)(int teamId, int unitDefId);
-const char* (*UnitDef_getWreckName)(int teamId, int unitDefId);
-const char* (*UnitDef_getDeathExplosion)(int teamId, int unitDefId);
-const char* (*UnitDef_getSelfDExplosion)(int teamId, int unitDefId);
-const char* (*UnitDef_getTedClassString)(int teamId, int unitDefId);
-const char* (*UnitDef_getCategoryString)(int teamId, int unitDefId);
-bool (*UnitDef_isCanSelfD)(int teamId, int unitDefId);
-int (*UnitDef_getSelfDCountdown)(int teamId, int unitDefId);
-bool (*UnitDef_isCanSubmerge)(int teamId, int unitDefId);
-bool (*UnitDef_isCanFly)(int teamId, int unitDefId);
-bool (*UnitDef_isCanMove)(int teamId, int unitDefId);
-bool (*UnitDef_isCanHover)(int teamId, int unitDefId);
-bool (*UnitDef_isFloater)(int teamId, int unitDefId);
-bool (*UnitDef_isBuilder)(int teamId, int unitDefId);
-bool (*UnitDef_isActivateWhenBuilt)(int teamId, int unitDefId);
-bool (*UnitDef_isOnOffable)(int teamId, int unitDefId);
-bool (*UnitDef_isFullHealthFactory)(int teamId, int unitDefId);
-bool (*UnitDef_isFactoryHeadingTakeoff)(int teamId, int unitDefId);
-bool (*UnitDef_isReclaimable)(int teamId, int unitDefId);
-bool (*UnitDef_isCapturable)(int teamId, int unitDefId);
-bool (*UnitDef_isCanRestore)(int teamId, int unitDefId);
-bool (*UnitDef_isCanRepair)(int teamId, int unitDefId);
-bool (*UnitDef_isCanSelfRepair)(int teamId, int unitDefId);
-bool (*UnitDef_isCanReclaim)(int teamId, int unitDefId);
-bool (*UnitDef_isCanAttack)(int teamId, int unitDefId);
-bool (*UnitDef_isCanPatrol)(int teamId, int unitDefId);
-bool (*UnitDef_isCanFight)(int teamId, int unitDefId);
-bool (*UnitDef_isCanGuard)(int teamId, int unitDefId);
-bool (*UnitDef_isCanBuild)(int teamId, int unitDefId);
-bool (*UnitDef_isCanAssist)(int teamId, int unitDefId);
-bool (*UnitDef_isCanBeAssisted)(int teamId, int unitDefId);
-bool (*UnitDef_isCanRepeat)(int teamId, int unitDefId);
-bool (*UnitDef_isCanFireControl)(int teamId, int unitDefId);
-int (*UnitDef_getFireState)(int teamId, int unitDefId);
-int (*UnitDef_getMoveState)(int teamId, int unitDefId);
-float (*UnitDef_getWingDrag)(int teamId, int unitDefId);
-float (*UnitDef_getWingAngle)(int teamId, int unitDefId);
-float (*UnitDef_getDrag)(int teamId, int unitDefId);
-float (*UnitDef_getFrontToSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getSpeedToFront)(int teamId, int unitDefId);
-float (*UnitDef_getMyGravity)(int teamId, int unitDefId);
-float (*UnitDef_getMaxBank)(int teamId, int unitDefId);
-float (*UnitDef_getMaxPitch)(int teamId, int unitDefId);
-float (*UnitDef_getTurnRadius)(int teamId, int unitDefId);
-float (*UnitDef_getWantedHeight)(int teamId, int unitDefId);
-float (*UnitDef_getVerticalSpeed)(int teamId, int unitDefId);
-bool (*UnitDef_isCanCrash)(int teamId, int unitDefId);
-bool (*UnitDef_isHoverAttack)(int teamId, int unitDefId);
-bool (*UnitDef_isAirStrafe)(int teamId, int unitDefId);
-float (*UnitDef_getDlHoverFactor)(int teamId, int unitDefId);
-float (*UnitDef_getMaxAcceleration)(int teamId, int unitDefId);
-float (*UnitDef_getMaxDeceleration)(int teamId, int unitDefId);
-float (*UnitDef_getMaxAileron)(int teamId, int unitDefId);
-float (*UnitDef_getMaxElevator)(int teamId, int unitDefId);
-float (*UnitDef_getMaxRudder)(int teamId, int unitDefId);
-///* returned size is 4 */
-//const unsigned char** (*UnitDef_getYardMaps)(int teamId, int unitDefId);
-int (*UnitDef_getXSize)(int teamId, int unitDefId);
-int (*UnitDef_getYSize)(int teamId, int unitDefId);
-int (*UnitDef_getBuildAngle)(int teamId, int unitDefId);
-float (*UnitDef_getLoadingRadius)(int teamId, int unitDefId);
-float (*UnitDef_getUnloadSpread)(int teamId, int unitDefId);
-int (*UnitDef_getTransportCapacity)(int teamId, int unitDefId);
-int (*UnitDef_getTransportSize)(int teamId, int unitDefId);
-int (*UnitDef_getMinTransportSize)(int teamId, int unitDefId);
-bool (*UnitDef_isAirBase)(int teamId, int unitDefId);
-float (*UnitDef_getTransportMass)(int teamId, int unitDefId);
-float (*UnitDef_getMinTransportMass)(int teamId, int unitDefId);
-bool (*UnitDef_isHoldSteady)(int teamId, int unitDefId);
-bool (*UnitDef_isReleaseHeld)(int teamId, int unitDefId);
-bool (*UnitDef_isCantBeTransported)(int teamId, int unitDefId);
-bool (*UnitDef_isTransportByEnemy)(int teamId, int unitDefId);
-int (*UnitDef_getTransportUnloadMethod)(int teamId, int unitDefId);
-float (*UnitDef_getFallSpeed)(int teamId, int unitDefId);
-float (*UnitDef_getUnitFallSpeed)(int teamId, int unitDefId);
-bool (*UnitDef_isCanCloak)(int teamId, int unitDefId);
-bool (*UnitDef_isStartCloaked)(int teamId, int unitDefId);
-float (*UnitDef_getCloakCost)(int teamId, int unitDefId);
-float (*UnitDef_getCloakCostMoving)(int teamId, int unitDefId);
-float (*UnitDef_getDecloakDistance)(int teamId, int unitDefId);
-bool (*UnitDef_isDecloakSpherical)(int teamId, int unitDefId);
-bool (*UnitDef_isDecloakOnFire)(int teamId, int unitDefId);
-bool (*UnitDef_isCanKamikaze)(int teamId, int unitDefId);
-float (*UnitDef_getKamikazeDist)(int teamId, int unitDefId);
-bool (*UnitDef_isTargetingFacility)(int teamId, int unitDefId);
-bool (*UnitDef_isCanDGun)(int teamId, int unitDefId);
-bool (*UnitDef_isNeedGeo)(int teamId, int unitDefId);
-bool (*UnitDef_isFeature)(int teamId, int unitDefId);
-bool (*UnitDef_isHideDamage)(int teamId, int unitDefId);
-bool (*UnitDef_isCommander)(int teamId, int unitDefId);
-bool (*UnitDef_isShowPlayerName)(int teamId, int unitDefId);
-bool (*UnitDef_isCanResurrect)(int teamId, int unitDefId);
-bool (*UnitDef_isCanCapture)(int teamId, int unitDefId);
-int (*UnitDef_getHighTrajectoryType)(int teamId, int unitDefId);
-unsigned int (*UnitDef_getNoChaseCategory)(int teamId, int unitDefId);
-bool (*UnitDef_isLeaveTracks)(int teamId, int unitDefId);
-float (*UnitDef_getTrackWidth)(int teamId, int unitDefId);
-float (*UnitDef_getTrackOffset)(int teamId, int unitDefId);
-float (*UnitDef_getTrackStrength)(int teamId, int unitDefId);
-float (*UnitDef_getTrackStretch)(int teamId, int unitDefId);
-int (*UnitDef_getTrackType)(int teamId, int unitDefId);
-bool (*UnitDef_isCanDropFlare)(int teamId, int unitDefId);
-float (*UnitDef_getFlareReloadTime)(int teamId, int unitDefId);
-float (*UnitDef_getFlareEfficiency)(int teamId, int unitDefId);
-float (*UnitDef_getFlareDelay)(int teamId, int unitDefId);
-SAIFloat3 (*UnitDef_getFlareDropVector)(int teamId, int unitDefId);
-int (*UnitDef_getFlareTime)(int teamId, int unitDefId);
-int (*UnitDef_getFlareSalvoSize)(int teamId, int unitDefId);
-int (*UnitDef_getFlareSalvoDelay)(int teamId, int unitDefId);
-bool (*UnitDef_isSmoothAnim)(int teamId, int unitDefId);
-bool (*UnitDef_isMetalMaker)(int teamId, int unitDefId);
-bool (*UnitDef_isCanLoopbackAttack)(int teamId, int unitDefId);
-bool (*UnitDef_isLevelGround)(int teamId, int unitDefId);
-bool (*UnitDef_isUseBuildingGroundDecal)(int teamId, int unitDefId);
-int (*UnitDef_getBuildingDecalType)(int teamId, int unitDefId);
-int (*UnitDef_getBuildingDecalSizeX)(int teamId, int unitDefId);
-int (*UnitDef_getBuildingDecalSizeY)(int teamId, int unitDefId);
-float (*UnitDef_getBuildingDecalDecaySpeed)(int teamId, int unitDefId);
-bool (*UnitDef_isFirePlatform)(int teamId, int unitDefId);
-float (*UnitDef_getMaxFuel)(int teamId, int unitDefId);
-float (*UnitDef_getRefuelTime)(int teamId, int unitDefId);
-float (*UnitDef_getMinAirBasePower)(int teamId, int unitDefId);
-int (*UnitDef_getMaxThisUnit)(int teamId, int unitDefId);
-int (*UnitDef_getDecoyDefId)(int teamId, int unitDefId);
-bool (*UnitDef_isDontLand)(int teamId, int unitDefId);
-int (*UnitDef_getShieldWeaponDefId)(int teamId, int unitDefId);
-int (*UnitDef_getStockpileWeaponDefId)(int teamId, int unitDefId);
-int (*UnitDef_getNumBuildOptions)(int teamId, int unitDefId);
-int (*UnitDef_getBuildOptions)(int teamId, int unitDefId, int* unitDefIds);
-int (*UnitDef_getNumCustomParams)(int teamId, int unitDefId);
-int (*UnitDef_getCustomParams)(int teamId, int unitDefId, const char* map[][2]);
-bool (*UnitDef_hasMoveData)(int teamId, int unitDefId);
-/* enum MoveType { Ground_Move, Hover_Move, Ship_Move }; */
-int (*UnitDef_MoveData_getMoveType)(int teamId, int unitDefId);
-/* 0=tank,1=kbot,2=hover,3=ship */
-int (*UnitDef_MoveData_getMoveFamily)(int teamId, int unitDefId);
-int (*UnitDef_MoveData_getSize)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getDepth)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getMaxSlope)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getSlopeMod)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getDepthMod)(int teamId, int unitDefId);
-int (*UnitDef_MoveData_getPathType)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getCrushStrength)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getMaxSpeed)(int teamId, int unitDefId);
-short (*UnitDef_MoveData_getMaxTurnRate)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getMaxAcceleration)(int teamId, int unitDefId);
-float (*UnitDef_MoveData_getMaxBreaking)(int teamId, int unitDefId);
-bool (*UnitDef_MoveData_isSubMarine)(int teamId, int unitDefId);
-int (*UnitDef_getNumUnitDefWeapons)(int teamId, int unitDefId);
-const char* (*UnitDef_UnitDefWeapon_getName)(int teamId, int unitDefId, int weaponIndex);
-int (*UnitDef_UnitDefWeapon_getWeaponDefId)(int teamId, int unitDefId, int weaponIndex);
-int (*UnitDef_UnitDefWeapon_getSlavedTo)(int teamId, int unitDefId, int weaponIndex);
-SAIFloat3 (*UnitDef_UnitDefWeapon_getMainDir)(int teamId, int unitDefId, int weaponIndex);
-float (*UnitDef_UnitDefWeapon_getMaxAngleDif)(int teamId, int unitDefId, int weaponIndex);
-float (*UnitDef_UnitDefWeapon_getFuelUsage)(int teamId, int unitDefId, int weaponIndex);
-unsigned int (*UnitDef_UnitDefWeapon_getBadTargetCat)(int teamId, int unitDefId, int weaponIndex);
-unsigned int (*UnitDef_UnitDefWeapon_getOnlyTargetCat)(int teamId, int unitDefId, int weaponIndex);
-// END OBJECT UnitDef
-
-
-
-// BEGINN OBJECT Unit
-int (*Unit_STATIC_getEnemies)(int teamId, int* unitIds);
-int (*Unit_STATIC_getEnemiesIn)(int teamId, int* unitIds, SAIFloat3 pos, float radius);
-int (*Unit_STATIC_getEnemiesInRadarAndLos)(int teamId, int* units);
-int (*Unit_STATIC_getFriendlies)(int teamId, int* unitIds);
-int (*Unit_STATIC_getFriendliesIn)(int teamId, int* unitIds, SAIFloat3 pos, float radius);
-int (*Unit_STATIC_getNeutrals)(int teamId, int* unitIds);
-int (*Unit_STATIC_getNeutralsIn)(int teamId, int* unitIds, SAIFloat3 pos, float radius);
-int (*Unit_STATIC_getSelected)(int teamId, int* unitIds);
-
-int (*Unit_getDefId)(int teamId, int unitId);
-int (*Unit_getAiHint)(int teamId, int unitId);
-int (*Unit_getTeam)(int teamId, int unitId);
-int (*Unit_getAllyTeam)(int teamId, int unitId);
-
-int (*Unit_getStockpile)(int teamId, int unitId);
-int (*Unit_getStockpileQueued)(int teamId, int unitId);
-float (*Unit_getCurrentFuel)(int teamId, int unitId);
-float (*Unit_getMaxSpeed)(int teamId, int unitId);
-float (*Unit_getMaxRange)(int teamId, int unitId);
-float (*Unit_getMaxHealth)(int teamId, int unitId);
-float (*Unit_getExperience)(int teamId, int unitId);
-int (*Unit_getGroup)(int teamId, int unitId);
-int (*Unit_getNumCurrentCommands)(int teamId, int unitId);
-/* for the type of the command queue, see CCommandQueue::CommandQueueType CommandQueue.h */
-int (*Unit_CurrentCommands_getType)(int teamId, int unitId);
-/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
-int (*Unit_CurrentCommands_getIds)(int teamId, int unitId, int* ids);
-int (*Unit_CurrentCommands_getOptions)(int teamId, int unitId, unsigned char* options);
-int (*Unit_CurrentCommands_getTag)(int teamId, int unitId, unsigned int* tags);
-int (*Unit_CurrentCommands_getTimeOut)(int teamId, int unitId, int* timeOuts);
-int (*Unit_CurrentCommands_getNumParams)(int teamId, int unitId, int* numParams);
-int (*Unit_CurrentCommands_getParams)(int teamId, int unitId, float** params);
-int (*Unit_getNumSupportedCommands)(int teamId, int unitId);
-/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
-int (*Unit_SupportedCommands_getId)(int teamId, int unitId, int* ids);
-int (*Unit_SupportedCommands_getName)(int teamId, int unitId, const char** names);
-int (*Unit_SupportedCommands_getToolTip)(int teamId, int unitId, const char** toolTips);
-int (*Unit_SupportedCommands_isShowUnique)(int teamId, int unitId, bool* showUniques);
-int (*Unit_SupportedCommands_isDisabled)(int teamId, int unitId, bool* disableds);
-int (*Unit_SupportedCommands_getNumParams)(int teamId, int unitId, int* numParams);
-int (*Unit_SupportedCommands_getParams)(int teamId, int unitId, const char*** params);
-float (*Unit_getHealth)(int teamId, int unitId);
-float (*Unit_getSpeed)(int teamId, int unitId);
-float (*Unit_getPower)(int teamId, int unitId);
-float (*Unit_ResourceInfo_Metal_getUse)(int teamId, int unitId);
-float (*Unit_ResourceInfo_Metal_getMake)(int teamId, int unitId);
-float (*Unit_ResourceInfo_Energy_getUse)(int teamId, int unitId);
-float (*Unit_ResourceInfo_Energy_getMake)(int teamId, int unitId);
-SAIFloat3 (*Unit_getPos)(int teamId, int unitId);
-bool (*Unit_isActivated)(int teamId, int unitId);
-bool (*Unit_isBeingBuilt)(int teamId, int unitId);
-bool (*Unit_isCloaked)(int teamId, int unitId);
-bool (*Unit_isParalyzed)(int teamId, int unitId);
-bool (*Unit_isNeutral)(int teamId, int unitId);
-int (*Unit_getBuildingFacing)(int teamId, int unitId);
-// END OBJECT Unit
-
-
-// BEGINN OBJECT Group
-int (*Group_getNumSupportedCommands)(int teamId, int groupId);
-/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
-int (*Group_SupportedCommands_getId)(int teamId, int groupId, int* ids);
-int (*Group_SupportedCommands_getName)(int teamId, int groupId, const char** names);
-int (*Group_SupportedCommands_getToolTip)(int teamId, int groupId, const char** toolTips);
-int (*Group_SupportedCommands_isShowUnique)(int teamId, int groupId, bool* showUniques);
-int (*Group_SupportedCommands_isDisabled)(int teamId, int groupId, bool* disableds);
-int (*Group_SupportedCommands_getNumParams)(int teamId, int groupId, int* numParams);
-int (*Group_SupportedCommands_getParams)(int teamId, int groupId, const char*** params);
-// END OBJECT Group
-
-
-
-// BEGINN OBJECT Mod
-const char* (*Mod_getName)(int teamId);
-// END OBJECT Mod
-
-
-
-// BEGINN OBJECT Map
-SAIFloat3 (*Map_getStartPos)(int teamId);
-SAIFloat3 (*Map_getMousePos)(int teamId);
-bool (*Map_isPosInCamera)(int teamId, SAIFloat3 pos, float radius);
-int (*Map_getWidth)(int teamId);
-int (*Map_getHeight)(int teamId);
-const float* (*Map_getHeightMap)(int teamId);
-float (*Map_getMinHeight)(int teamId);
-float (*Map_getMaxHeight)(int teamId);
-const float* (*Map_getSlopeMap)(int teamId);
-const unsigned short* (*Map_getLosMap)(int teamId);
-const unsigned short* (*Map_getRadarMap)(int teamId);
-const unsigned short* (*Map_getJammerMap)(int teamId);
-const unsigned char* (*Map_getMetalMap)(int teamId);
-const char* (*Map_getName)(int teamId);
-float (*Map_getElevationAt)(int teamId, float x, float z);
-float (*Map_getMaxMetal)(int teamId);
-float (*Map_getExtractorRadius)(int teamId);
-float (*Map_getMinWind)(int teamId);
-float (*Map_getMaxWind)(int teamId);
-float (*Map_getTidalStrength)(int teamId);
-float (*Map_getGravity)(int teamId);
-int (*Map_getPoints)(int teamId, SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints);
-int (*Map_getLines)(int teamId, SAIFloat3* firstPositions, SAIFloat3* secondPositions, unsigned char** colors, int maxLines);
-bool (*Map_canBuildAt)(int teamId, int unitDefId, SAIFloat3 pos, int facing);
-SAIFloat3 (*Map_findClosestBuildSite)(int teamId, int unitDefId, SAIFloat3 pos, float searchRadius, int minDist, int facing);
-// BEGINN OBJECT Map
-
-
-
-// BEGINN OBJECT FeatureDef
-//const SAIFeatureDef* (*getFeatureDef)(int teamId, int featureDefId);
-const char* (*FeatureDef_getName)(int teamId, int weaponDefId);
-const char* (*FeatureDef_getDescription)(int teamId, int weaponDefId);
-const char* (*FeatureDef_getFilename)(int teamId, int weaponDefId);
-int (*FeatureDef_getId)(int teamId, int weaponDefId);
-float (*FeatureDef_getMetal)(int teamId, int weaponDefId);
-float (*FeatureDef_getEnergy)(int teamId, int weaponDefId);
-float (*FeatureDef_getMaxHealth)(int teamId, int weaponDefId);
-float (*FeatureDef_getReclaimTime)(int teamId, int weaponDefId);
-float (*FeatureDef_getMass)(int teamId, int weaponDefId);
-const char* (*FeatureDef_getCollisionVolumeType)(int teamId, int weaponDefId);	
-SAIFloat3 (*FeatureDef_getCollisionVolumeScales)(int teamId, int weaponDefId);		
-SAIFloat3 (*FeatureDef_getCollisionVolumeOffsets)(int teamId, int weaponDefId);		
-int (*FeatureDef_getCollisionVolumeTest)(int teamId, int weaponDefId);			
-bool (*FeatureDef_isUpright)(int teamId, int weaponDefId);
-int (*FeatureDef_getDrawType)(int teamId, int weaponDefId);
-const char* (*FeatureDef_getModelName)(int teamId, int weaponDefId);
-int (*FeatureDef_getModelType)(int teamId, int weaponDefId);
-bool (*FeatureDef_isDestructable)(int teamId, int weaponDefId);
-bool (*FeatureDef_isReclaimable)(int teamId, int weaponDefId);
-bool (*FeatureDef_isBlocking)(int teamId, int weaponDefId);
-bool (*FeatureDef_isBurnable)(int teamId, int weaponDefId);
-bool (*FeatureDef_isFloating)(int teamId, int weaponDefId);
-bool (*FeatureDef_isNoSelect)(int teamId, int weaponDefId);
-bool (*FeatureDef_isGeoThermal)(int teamId, int weaponDefId);
-const char* (*FeatureDef_getDeathFeature)(int teamId, int weaponDefId);
-int (*FeatureDef_getXsize)(int teamId, int weaponDefId);
-int (*FeatureDef_getYsize)(int teamId, int weaponDefId);
-int (*FeatureDef_getNumCustomParams)(int teamId, int weaponDefId);
-int (*FeatureDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
-// END OBJECT FeatureDef
-
-
-// BEGINN OBJECT Feature
-int (*Feature_STATIC_getIds)(int teamId, int *featureIds, int max);
-int (*Feature_STATIC_getIdsIn)(int teamId, int *featureIds, int max, SAIFloat3 pos, float radius);
-
-int (*Feature_getDefId)(int teamId, int featureId);
-float (*Feature_getHealth)(int teamId, int featureId);
-float (*Feature_getReclaimLeft)(int teamId, int featureId);
-SAIFloat3 (*Feature_getPos)(int teamId, int featureId);
-// END OBJECT Feature
-
-
-
-// BEGINN OBJECT WeaponDef
-int (*WeaponDef_STATIC_getIdByName)(int teamId, const char* weaponDefName);
-
-//const SAIWeaponDef* (*getWeaponDef)(int teamId, int weaponDefId);
-const char* (*WeaponDef_getName)(int teamId, int weaponDefId);
-const char* (*WeaponDef_getType)(int teamId, int weaponDefId);
-const char* (*WeaponDef_getDescription)(int teamId, int weaponDefId);
-const char* (*WeaponDef_getFilename)(int teamId, int weaponDefId);
-const char* (*WeaponDef_getCegTag)(int teamId, int weaponDefId);
-float (*WeaponDef_getRange)(int teamId, int weaponDefId);
-float (*WeaponDef_getHeightMod)(int teamId, int weaponDefId);
-float (*WeaponDef_getAccuracy)(int teamId, int weaponDefId);
-float (*WeaponDef_getSprayAngle)(int teamId, int weaponDefId);
-float (*WeaponDef_getMovingAccuracy)(int teamId, int weaponDefId);
-float (*WeaponDef_getTargetMoveError)(int teamId, int weaponDefId);
-float (*WeaponDef_getLeadLimit)(int teamId, int weaponDefId);
-float (*WeaponDef_getLeadBonus)(int teamId, int weaponDefId);
-float (*WeaponDef_getPredictBoost)(int teamId, int weaponDefId);
-
-//DamageArray (*WeaponDef_getDamages)(int teamId, int weaponDefId);
-int (*WeaponDef_Damages_getParalyzeDamageTime)(int teamId, int weaponDefId);
-float (*WeaponDef_Damages_getImpulseFactor)(int teamId, int weaponDefId);
-float (*WeaponDef_Damages_getImpulseBoost)(int teamId, int weaponDefId);
-float (*WeaponDef_Damages_getCraterMult)(int teamId, int weaponDefId);
-float (*WeaponDef_Damages_getCraterBoost)(int teamId, int weaponDefId);
-int (*WeaponDef_Damages_getNumTypes)(int teamId, int weaponDefId);
-//float (*WeaponDef_Damages_getType)(int teamId, int weaponDefId, int typeIndex);
-void (*WeaponDef_Damages_getTypeDamages)(int teamId, int weaponDefId, float* typeDamages);
-
-float (*WeaponDef_getAreaOfEffect)(int teamId, int weaponDefId);
-bool (*WeaponDef_isNoSelfDamage)(int teamId, int weaponDefId);
-float (*WeaponDef_getFireStarter)(int teamId, int weaponDefId);
-float (*WeaponDef_getEdgeEffectiveness)(int teamId, int weaponDefId);
-float (*WeaponDef_getSize)(int teamId, int weaponDefId);
-float (*WeaponDef_getSizeGrowth)(int teamId, int weaponDefId);
-float (*WeaponDef_getCollisionSize)(int teamId, int weaponDefId);
-int (*WeaponDef_getSalvoSize)(int teamId, int weaponDefId);
-float (*WeaponDef_getSalvoDelay)(int teamId, int weaponDefId);
-float (*WeaponDef_getReload)(int teamId, int weaponDefId);
-float (*WeaponDef_getBeamTime)(int teamId, int weaponDefId);
-bool (*WeaponDef_isBeamBurst)(int teamId, int weaponDefId);
-bool (*WeaponDef_isWaterBounce)(int teamId, int weaponDefId);
-bool (*WeaponDef_isGroundBounce)(int teamId, int weaponDefId);
-float (*WeaponDef_getBounceRebound)(int teamId, int weaponDefId);
-float (*WeaponDef_getBounceSlip)(int teamId, int weaponDefId);
-int (*WeaponDef_getNumBounce)(int teamId, int weaponDefId);
-float (*WeaponDef_getMaxAngle)(int teamId, int weaponDefId);
-float (*WeaponDef_getRestTime)(int teamId, int weaponDefId);
-float (*WeaponDef_getUpTime)(int teamId, int weaponDefId);
-int (*WeaponDef_getFlightTime)(int teamId, int weaponDefId);
-float (*WeaponDef_getMetalCost)(int teamId, int weaponDefId);
-float (*WeaponDef_getEnergyCost)(int teamId, int weaponDefId);
-float (*WeaponDef_getSupplyCost)(int teamId, int weaponDefId);
-int (*WeaponDef_getProjectilesPerShot)(int teamId, int weaponDefId);
-int (*WeaponDef_getId)(int teamId, int weaponDefId);
-int (*WeaponDef_getTdfId)(int teamId, int weaponDefId);
-bool (*WeaponDef_isTurret)(int teamId, int weaponDefId);
-bool (*WeaponDef_isOnlyForward)(int teamId, int weaponDefId);
-bool (*WeaponDef_isFixedLauncher)(int teamId, int weaponDefId);
-bool (*WeaponDef_isWaterWeapon)(int teamId, int weaponDefId);
-bool (*WeaponDef_isFireSubmersed)(int teamId, int weaponDefId);
-bool (*WeaponDef_isSubMissile)(int teamId, int weaponDefId);
-bool (*WeaponDef_isTracks)(int teamId, int weaponDefId);
-bool (*WeaponDef_isDropped)(int teamId, int weaponDefId);
-bool (*WeaponDef_isParalyzer)(int teamId, int weaponDefId);
-bool (*WeaponDef_isImpactOnly)(int teamId, int weaponDefId);
-bool (*WeaponDef_isNoAutoTarget)(int teamId, int weaponDefId);
-bool (*WeaponDef_isManualFire)(int teamId, int weaponDefId);
-int (*WeaponDef_getInterceptor)(int teamId, int weaponDefId);
-int (*WeaponDef_getTargetable)(int teamId, int weaponDefId);
-bool (*WeaponDef_isStockpileable)(int teamId, int weaponDefId);
-float (*WeaponDef_getCoverageRange)(int teamId, int weaponDefId);
-float (*WeaponDef_getIntensity)(int teamId, int weaponDefId);
-float (*WeaponDef_getThickness)(int teamId, int weaponDefId);
-float (*WeaponDef_getLaserFlareSize)(int teamId, int weaponDefId);
-float (*WeaponDef_getCoreThickness)(int teamId, int weaponDefId);
-float (*WeaponDef_getDuration)(int teamId, int weaponDefId);
-int (*WeaponDef_getLodDistance)(int teamId, int weaponDefId);
-float (*WeaponDef_getFalloffRate)(int teamId, int weaponDefId);
-int (*WeaponDef_getGraphicsType)(int teamId, int weaponDefId);
-bool (*WeaponDef_isSoundTrigger)(int teamId, int weaponDefId);
-bool (*WeaponDef_isSelfExplode)(int teamId, int weaponDefId);
-bool (*WeaponDef_isGravityAffected)(int teamId, int weaponDefId);
-int (*WeaponDef_getHighTrajectory)(int teamId, int weaponDefId);
-float (*WeaponDef_getMyGravity)(int teamId, int weaponDefId);
-bool (*WeaponDef_isTwoPhase)(int teamId, int weaponDefId);
-bool (*WeaponDef_isGuided)(int teamId, int weaponDefId);
-bool (*WeaponDef_isVLaunched)(int teamId, int weaponDefId);
-bool (*WeaponDef_isSelfPropelled)(int teamId, int weaponDefId);
-bool (*WeaponDef_isNoExplode)(int teamId, int weaponDefId);
-float (*WeaponDef_getStartVelocity)(int teamId, int weaponDefId);
-float (*WeaponDef_getWeaponAcceleration)(int teamId, int weaponDefId);
-float (*WeaponDef_getTurnRate)(int teamId, int weaponDefId);
-float (*WeaponDef_getMaxVelocity)(int teamId, int weaponDefId);
-float (*WeaponDef_getProjectileSpeed)(int teamId, int weaponDefId);
-float (*WeaponDef_getExplosionSpeed)(int teamId, int weaponDefId);
-unsigned int (*WeaponDef_getOnlyTargetCategory)(int teamId, int weaponDefId);
-float (*WeaponDef_getWobble)(int teamId, int weaponDefId);
-float (*WeaponDef_getDance)(int teamId, int weaponDefId);
-float (*WeaponDef_getTrajectoryHeight)(int teamId, int weaponDefId);
-bool (*WeaponDef_isLargeBeamLaser)(int teamId, int weaponDefId);
-bool (*WeaponDef_isShield)(int teamId, int weaponDefId);
-bool (*WeaponDef_isShieldRepulser)(int teamId, int weaponDefId);
-bool (*WeaponDef_isSmartShield)(int teamId, int weaponDefId);
-bool (*WeaponDef_isExteriorShield)(int teamId, int weaponDefId);
-bool (*WeaponDef_isVisibleShield)(int teamId, int weaponDefId);
-bool (*WeaponDef_isVisibleShieldRepulse)(int teamId, int weaponDefId);
-int (*WeaponDef_getVisibleShieldHitFrames)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldEnergyUse)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldRadius)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldForce)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldMaxSpeed)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldPower)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldPowerRegen)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldPowerRegenEnergy)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldStartingPower)(int teamId, int weaponDefId);
-int (*WeaponDef_getShieldRechargeDelay)(int teamId, int weaponDefId);
-SAIFloat3 (*WeaponDef_getShieldGoodColor)(int teamId, int weaponDefId);
-SAIFloat3 (*WeaponDef_getShieldBadColor)(int teamId, int weaponDefId);
-float (*WeaponDef_getShieldAlpha)(int teamId, int weaponDefId);
-unsigned int (*WeaponDef_getShieldInterceptType)(int teamId, int weaponDefId);
-unsigned int (*WeaponDef_getInterceptedByShieldType)(int teamId, int weaponDefId);
-bool (*WeaponDef_isAvoidFriendly)(int teamId, int weaponDefId);
-bool (*WeaponDef_isAvoidFeature)(int teamId, int weaponDefId);
-bool (*WeaponDef_isAvoidNeutral)(int teamId, int weaponDefId);
-float (*WeaponDef_getTargetBorder)(int teamId, int weaponDefId);
-float (*WeaponDef_getCylinderTargetting)(int teamId, int weaponDefId);
-float (*WeaponDef_getMinIntensity)(int teamId, int weaponDefId);
-float (*WeaponDef_getHeightBoostFactor)(int teamId, int weaponDefId);
-float (*WeaponDef_getProximityPriority)(int teamId, int weaponDefId);
-unsigned int (*WeaponDef_getCollisionFlags)(int teamId, int weaponDefId);
-bool (*WeaponDef_isSweepFire)(int teamId, int weaponDefId);
-bool (*WeaponDef_isCanAttackGround)(int teamId, int weaponDefId);
-float (*WeaponDef_getCameraShake)(int teamId, int weaponDefId);
-float (*WeaponDef_getDynDamageExp)(int teamId, int weaponDefId);
-float (*WeaponDef_getDynDamageMin)(int teamId, int weaponDefId);
-float (*WeaponDef_getDynDamageRange)(int teamId, int weaponDefId);
-bool (*WeaponDef_isDynDamageInverted)(int teamId, int weaponDefId);
-int (*WeaponDef_getNumCustomParams)(int teamId, int weaponDefId);
-//const char** (*WeaponDef_getCustomParam)(int teamId, int weaponDefId, int index);
-int (*WeaponDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
-// END OBJECT WeaponDef
-
-};
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _SAICALLBACK_H */
-

Deleted: branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/SAIFloat3.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,13 +0,0 @@
-
-#include &quot;SAIFloat3.h&quot;
-
-SAIFloat3 newSAIFloat3(float x, float y, float z) {
-    
-    SAIFloat3 sAIFloat3;
-    
-    sAIFloat3.x = x;
-    sAIFloat3.y = y;
-    sAIFloat3.z = z;
-    
-    return  sAIFloat3;
-}

Deleted: branches/caiinterface/rts/ExternalAI/SAIFloat3.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAIFloat3.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/SAIFloat3.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,49 +0,0 @@
-/*
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _SAIFLOAT3_H
-#define	_SAIFLOAT3_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-
-struct SAIFloat3 {
-    float x, y, z;
-};
-
-SAIFloat3 newSAIFloat3(float x, float y, float z);
-
-#ifdef	__cplusplus
-}
-#endif
-
-//#ifdef	__cplusplus
-//#include &quot;float3.h&quot;
-//
-//SAIFloat3 newSAIFloat3_Cpp(float3* f3) {
-//    
-//    SAIFloat3 sAIFloat3;
-//    
-//    sAIFloat3.x = f3-&gt;x;
-//    sAIFloat3.y = f3-&gt;y;
-//    sAIFloat3.z = f3-&gt;z;
-//    
-//    return  sAIFloat3;
-//}
-//#endif
-
-#endif	/* _SAIFLOAT3_H */
-

Added: branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,38 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SkirmishAI.h&quot;
+
+#include &quot;IAILibraryManager.h&quot;
+
+CSkirmishAI::CSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey)
+		: teamId(teamId), skirmishAIKey(skirmishAIKey) {
+	
+	skirmishAILibrary = IAILibraryManager::GetInstance()-&gt;FetchSkirmishAILibrary(skirmishAIKey);
+	skirmishAILibrary-&gt;Init(teamId);
+}
+
+CSkirmishAI::~CSkirmishAI() {
+	
+	skirmishAILibrary-&gt;Release(teamId);
+	IAILibraryManager::GetInstance()-&gt;ReleaseSkirmishAILibrary(skirmishAIKey);
+}
+
+int CSkirmishAI::HandleEvent(int topic, const void* data) const {
+	return skirmishAILibrary-&gt;HandleEvent(teamId, topic, data);
+}
+


Property changes on: branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SkirmishAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAI.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAI.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,39 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SKIRMISHAI_H
+#define	_SKIRMISHAI_H
+
+#include &quot;ISkirmishAI.h&quot;
+#include &quot;ISkirmishAILibrary.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+
+class CSkirmishAI : public ISkirmishAI {
+public:
+    CSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey);
+    virtual ~CSkirmishAI();
+	
+    virtual int HandleEvent(int topic, const void* data) const;
+	
+private:
+	int teamId;
+	const SSAIKey skirmishAIKey;
+	const ISkirmishAILibrary* skirmishAILibrary;
+};
+
+#endif	/* _SKIRMISHAI_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/SkirmishAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,96 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SkirmishAILibrary.h&quot;
+
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &lt;string&gt;
+
+CSkirmishAILibrary::CSkirmishAILibrary(const SSAILibrary&amp; ai,
+		const SSAISpecifyer&amp; specifyer) : sSAI(ai), specifyer(specifyer) {
+	
+/*
+	std::map&lt;std::string, InfoItem&gt; infos = GetInfos();
+	specifyer.shortName = infos.at(SKIRMISH_AI_PROPERTY_SHORT_NAME).value;
+	specifyer.version = infos.at(SKIRMISH_AI_PROPERTY_VERSION).value;
+*/
+}
+
+CSkirmishAILibrary::~CSkirmishAILibrary() {}
+	
+SSAISpecifyer CSkirmishAILibrary::GetSpecifyer() const {
+	return specifyer;
+}
+
+LevelOfSupport CSkirmishAILibrary::GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber,
+		const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) const {
+	
+	if (sSAI.getLevelOfSupportFor != NULL) {
+		return sSAI.getLevelOfSupportFor(engineVersionString.c_str(), engineVersionNumber,
+			interfaceSpecifyer.shortName, interfaceSpecifyer.version);
+	} else {
+		return LOS_Unknown;
+	}
+}
+	
+std::map&lt;std::string, InfoItem&gt; CSkirmishAILibrary::GetInfos() const {
+	
+	std::map&lt;std::string, InfoItem&gt; infos;
+	
+	if (sSAI.getInfos != NULL) {
+		InfoItem infs[MAX_INFOS];
+		int num = sSAI.getInfos(infs, MAX_INFOS);
+
+		int i;
+		for (i=0; i &lt; num; ++i) {
+			InfoItem newII = copyInfoItem(&amp;infs[i]);
+			infos[std::string(newII.key)] = newII;
+		}
+	}
+
+	return infos;
+}
+std::vector&lt;Option&gt; CSkirmishAILibrary::GetOptions() const {
+	
+	std::vector&lt;Option&gt; ops;
+	
+	if (sSAI.getOptions != NULL) {
+		Option options[MAX_OPTIONS];
+		int num = sSAI.getOptions(options, MAX_OPTIONS);
+
+		int i;
+		for (i=0; i &lt; num; ++i) {
+			ops.push_back(options[i]);
+		}
+	}
+
+	return ops;
+}
+
+
+void CSkirmishAILibrary::Init(int teamId) const {
+	sSAI.init(teamId);
+}
+
+void CSkirmishAILibrary::Release(int teamId) const {
+	sSAI.release(teamId);
+}
+
+int CSkirmishAILibrary::HandleEvent(int teamId, int topic, const void* data) const {
+	return sSAI.handleEvent(teamId, topic, data);
+}


Property changes on: branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,58 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SKIRMISHAILIBRARY_H
+#define	_SKIRMISHAILIBRARY_H
+
+#include &quot;ISkirmishAILibrary.h&quot;
+
+#include &quot;Interface/SSAILibrary.h&quot;
+
+class CSkirmishAILibrary : public ISkirmishAILibrary {
+public:
+	CSkirmishAILibrary(const SSAILibrary&amp; ai, const SSAISpecifyer&amp; specifyer);
+	virtual ~CSkirmishAILibrary();
+	
+	virtual SSAISpecifyer GetSpecifyer() const;
+	/**
+	 * Level of Support for a specific engine version and ai interface.
+	 * @return see enum LevelOfSupport (higher values could be used optionally)
+	 */
+	virtual LevelOfSupport GetLevelOfSupportFor(
+			const std::string&amp; engineVersionString, int engineVersionNumber,
+			const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) const;
+	
+    virtual std::map&lt;std::string, InfoItem&gt; GetInfos() const;
+	virtual std::vector&lt;Option&gt; GetOptions() const;
+	
+	
+    virtual void Init(int teamId) const;
+    virtual void Release(int teamId) const;
+    virtual int HandleEvent(int teamId, int topic, const void* data) const;
+	
+private:
+	SSAILibrary sSAI;
+	SSAISpecifyer specifyer;
+	
+private:
+//	void reportInterfaceFunctionError(const std::string* libFileName, const std::string* functionName);
+	
+	static const int MAX_INFOS = 128;
+	static const int MAX_OPTIONS = 128;
+};
+
+#endif	/* _SKIRMISHAILIBRARY_H */


Property changes on: branches/caiinterface/rts/ExternalAI/SkirmishAILibrary.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,167 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SkirmishAILibraryInfo.h&quot;
+
+#include &quot;Interface/aidefines.h&quot;
+#include &quot;Interface/SSAILibrary.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;ISkirmishAILibrary.h&quot;
+
+#include &quot;Platform/errorhandler.h&quot;
+
+CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(const ISkirmishAILibrary&amp; ai, const SAIInterfaceSpecifyer&amp; interfaceSpecifyer) {
+	infos = ai.GetInfos();
+	options = ai.GetOptions();
+	//levelOfSupport = ai.GetLevelOfSupportFor(std::string(ENGINE_VERSION_STRING),
+	//		ENGINE_VERSION_NUMBER, interfaceSpecifyer);
+}
+
+CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(const CSkirmishAILibraryInfo&amp; aiInfo) {
+	infos = std::map&lt;std::string, InfoItem&gt;(
+			aiInfo.infos.begin(),
+			aiInfo.infos.end());
+	options = std::vector&lt;Option&gt;(
+			aiInfo.options.begin(),
+			aiInfo.options.end());
+	//levelOfSupport = aiInfo.levelOfSupport;
+}
+
+CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(
+		const std::string&amp; aiInfoFile,
+		const std::string&amp; aiOptionFile,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes) {
+	
+	InfoItem tmpInfos[MAX_INFOS];
+	unsigned int num = ParseInfos(aiInfoFile.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfos, MAX_INFOS);
+    for (unsigned int i=0; i &lt; num; ++i) {
+		infos[std::string(tmpInfos[i].key)] = tmpInfos[i];
+    }
+	
+	if (!aiOptionFile.empty()) {
+		Option tmpOptions[MAX_OPTIONS];
+		num = ParseOptions(aiOptionFile.c_str(), fileModes.c_str(), accessModes.c_str(), &quot;&quot;, tmpOptions, MAX_OPTIONS);
+		for (unsigned int i=0; i &lt; num; ++i) {
+			options.push_back(tmpOptions[i]);
+		}
+	}
+	//options = ParseOptions(aiOptionFile, fileModes, accessModes);
+}
+
+/*
+LevelOfSupport CSkirmishAILibraryInfo::GetLevelOfSupportForCurrentEngineAndSetInterface() const {
+	return levelOfSupport;
+}
+*/
+	
+std::string CSkirmishAILibraryInfo::GetShortName() const { // restrictions: none of the following: spaces, '_', '#'
+	return GetInfo(SKIRMISH_AI_PROPERTY_SHORT_NAME);
+}
+std::string CSkirmishAILibraryInfo::GetVersion() const { // restrictions: none of the following: spaces, '_', '#'
+	return GetInfo(SKIRMISH_AI_PROPERTY_VERSION);
+}
+std::string CSkirmishAILibraryInfo::GetName() const {
+	return GetInfo(SKIRMISH_AI_PROPERTY_NAME);
+}
+std::string CSkirmishAILibraryInfo::GetDescription() const {
+	return GetInfo(SKIRMISH_AI_PROPERTY_DESCRIPTION);
+}
+std::string CSkirmishAILibraryInfo::GetURL() const {
+	return GetInfo(SKIRMISH_AI_PROPERTY_URL);
+}
+std::string CSkirmishAILibraryInfo::GetInterfaceShortName() const {
+	return GetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME);
+}
+std::string CSkirmishAILibraryInfo::GetInterfaceVersion() const {
+	return GetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_VERSION);
+}
+std::string CSkirmishAILibraryInfo::GetInfo(const std::string&amp; key) const {
+	return infos.at(key).value;
+}
+const std::map&lt;std::string, InfoItem&gt;* CSkirmishAILibraryInfo::GetInfos() const {
+	return &infos;
+}
+
+const std::vector&lt;Option&gt;* CSkirmishAILibraryInfo::GetOptions() const {
+//	return &optionInfos;
+/*
+	std::vector&lt;const ISkirmishAIOption*&gt; opInfs;
+	
+	std::vector&lt;CSkirmishAIOption&gt;::const_iterator  opInf;
+	for (opInf=optionInfos.begin(); opInf != optionInfos.end(); opInf++) {
+//		opInfs.push_back((const ISkirmishAIOption*) opInf);
+		const CSkirmishAIOption* cop = &amp;(*opInf);
+		const ISkirmishAIOption* iop = cop;
+		opInfs.push_back(iop);
+	}
+	
+	return opInfs;
+*/
+/*
+	ISkirmishAIOption::const_vector c_optionInfos(optionInfos.begin(), optionInfos.end()); // implicit convertible types -&gt; range-ctor can be used
+*/
+	return &options;
+}
+
+
+void CSkirmishAILibraryInfo::SetShortName(const std::string&amp; shortName) { // restrictions: none of the following: spaces, '_', '#'
+	SetInfo(SKIRMISH_AI_PROPERTY_SHORT_NAME, shortName);
+}
+void CSkirmishAILibraryInfo::SetVersion(const std::string&amp; version) { // restrictions: none of the following: spaces, '_', '#'
+	SetInfo(SKIRMISH_AI_PROPERTY_VERSION, version);
+}
+void CSkirmishAILibraryInfo::SetName(const std::string&amp; name) {
+	SetInfo(SKIRMISH_AI_PROPERTY_NAME, name);
+}
+void CSkirmishAILibraryInfo::SetDescription(const std::string&amp; description) {
+	SetInfo(SKIRMISH_AI_PROPERTY_DESCRIPTION, description);
+}
+void CSkirmishAILibraryInfo::SetURL(const std::string&amp; url) {
+	SetInfo(SKIRMISH_AI_PROPERTY_URL, url);
+}
+void CSkirmishAILibraryInfo::SetInterfaceShortName(const std::string&amp; interfaceShortName) {
+	SetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME, interfaceShortName);
+}
+void CSkirmishAILibraryInfo::SetInterfaceVersion(const std::string&amp; interfaceVersion) {
+	SetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_VERSION, interfaceVersion);
+}
+bool CSkirmishAILibraryInfo::SetInfo(const std::string&amp; key, const std::string&amp; value) {
+	
+	if (key == SKIRMISH_AI_PROPERTY_SHORT_NAME ||
+			key == SKIRMISH_AI_PROPERTY_VERSION) {
+		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
+			handleerror(NULL, &quot;Error&quot;, &quot;Skirmish AI info (shortName or version) contains illegal characters ('_', '#' or white spaces)&quot;, MBF_OK | MBF_EXCL);
+			return false;
+		}
+	}
+	
+	InfoItem ii = {key.c_str(), value.c_str(), NULL};
+	infos[key] = ii;
+	return true;
+}
+
+void CSkirmishAILibraryInfo::SetOptions(const std::vector&lt;Option&gt;&amp; _options) {
+/*
+	optionInfos.clear();
+	ISkirmishAIOption::const_vector::const_iterator opInf;
+	for (opInf=_optionInfos.begin(); opInf != _optionInfos.end(); opInf++) {
+		optionInfos.push_back(**opInf);
+	}
+*/
+	options = std::vector&lt;Option&gt;(_options.begin(), _options.end()); // implicit convertible types -&gt; range-ctor can be used
+}


Property changes on: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,80 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SKIRMISHAILIBRARYINFO_H
+#define	_SKIRMISHAILIBRARYINFO_H
+
+#include &quot;Interface/ELevelOfSupport.h&quot;
+//#include &quot;Interface/SAIInfo.h&quot;
+//#include &quot;Interface/SAIOption.h&quot;
+
+#include &lt;vector&gt;
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class ISkirmishAILibrary;
+struct InfoItem;
+struct Option;
+struct SAIInterfaceSpecifyer;
+
+class CSkirmishAILibraryInfo {
+public:
+	CSkirmishAILibraryInfo(const ISkirmishAILibrary&amp; ai, const SAIInterfaceSpecifyer&amp; interfaceSpecifyer);
+	CSkirmishAILibraryInfo(const CSkirmishAILibraryInfo&amp; aiInfo);
+	CSkirmishAILibraryInfo(
+			const std::string&amp; aiInfoFile,
+			const std::string&amp; aiOptionFile,
+			const std::string&amp; fileModes,
+			const std::string&amp; accessModes);
+    
+//    virtual LevelOfSupport GetLevelOfSupportForCurrentEngineAndSetInterface() const;
+//    virtual LevelOfSupport GetLevelOfSupportForCurrentEngine(SAIInterfaceSpecifyer interfaceSpecifyer) const;
+	
+    virtual std::string GetShortName() const; // restrictions: none of the following: spaces, '_', '#'
+    virtual std::string GetName() const;
+    virtual std::string GetVersion() const; // restrictions: none of the following: spaces, '_', '#'
+    virtual std::string GetDescription() const;
+    virtual std::string GetURL() const;
+    virtual std::string GetInterfaceShortName() const;
+    virtual std::string GetInterfaceVersion() const;
+    virtual std::string GetInfo(const std::string&amp; key) const;
+    virtual const std::map&lt;std::string, InfoItem&gt;* GetInfos() const;
+//    virtual std::vector&lt;std::string&gt; GetPropertyNames() const;
+	
+	virtual const std::vector&lt;Option&gt;* GetOptions() const;
+	
+    virtual void SetShortName(const std::string&amp; shortName); // restrictions: none of the following: spaces, '_', '#'
+    virtual void SetName(const std::string&amp; name);
+    virtual void SetVersion(const std::string&amp; version); // restrictions: none of the following: spaces, '_', '#'
+    virtual void SetDescription(const std::string&amp; description);
+    virtual void SetURL(const std::string&amp; url);
+    virtual void SetInterfaceShortName(const std::string&amp; interfaceShortName);
+    virtual void SetInterfaceVersion(const std::string&amp; interfaceVersion);
+    virtual bool SetInfo(const std::string&amp; key, const std::string&amp; value);
+	
+	virtual void SetOptions(const std::vector&lt;Option&gt;&amp; options);
+	
+private:
+	static const unsigned int MAX_INFOS = 128;
+	static const unsigned int MAX_OPTIONS = 128;
+	std::map&lt;std::string, InfoItem&gt; infos;
+	std::vector&lt;Option&gt; options;
+	//LevelOfSupport levelOfSupport;
+};
+
+#endif	/* _SKIRMISHAILIBRARYINFO_H */
+


Property changes on: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
___________________________________________________________________
Name: svn:eol-style
   + native

Copied: branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp (from rev 6208, branches/caiinterface/rts/ExternalAI/GlobalAI.cpp)
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,434 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;SkirmishAIWrapper.h&quot;
+
+#include &quot;StdAfx.h&quot;
+#include &quot;IGlobalAI.h&quot;
+#include &quot;SkirmishAI.h&quot;
+#include &quot;GlobalAICallback.h&quot;
+#include &quot;GlobalAIHandler.h&quot;
+#include &quot;Platform/FileSystem.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;mmgr.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Units/UnitHandler.h&quot;
+#include &quot;Interface/AISEvents.h&quot;
+#include &quot;Interface/AISCommands.h&quot;
+#include &quot;Interface/SSAILibrary.h&quot;
+
+#include &lt;sstream&gt;
+
+CR_BIND_DERIVED(CSkirmishAIWrapper, CObject, (0, SSAIKey()))
+CR_REG_METADATA(CSkirmishAIWrapper, (
+	CR_MEMBER(teamId),
+	CR_MEMBER(cheatEvents),
+	CR_MEMBER(skirmishAIKey),
+/*
+	CR_MEMBER(libName),
+	CR_MEMBER(IsCInterface),
+	CR_MEMBER(IsLoadSupported),
+*/
+	CR_SERIALIZER(Serialize),
+	CR_POSTLOAD(PostLoad)
+));
+
+void AIException(const char *what);
+
+#define HANDLE_EXCEPTION					\
+	catch (const std::exception&amp; e) {		\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(e.what());			\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (const char *s) {	\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(s);					\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (...) {							\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(0);					\
+			throw;							\
+		} else throw;						\
+	}
+
+/*
+CSkirmishAIWrapper::CSkirmishAIWrapper() {
+    
+}
+*/
+
+CSkirmishAIWrapper::CSkirmishAIWrapper(int teamId, const SSAIKey&amp; skirmishAIKey)
+		: teamId(teamId), cheatEvents(false), skirmishAIKey(skirmishAIKey) {
+	
+	LoadSkirmishAI(teamId, skirmishAIKey, false);
+	
+	Init();
+}
+
+void CSkirmishAIWrapper::PreDestroy() {
+	callback-&gt;noMessages = true;
+}
+
+CSkirmishAIWrapper::~CSkirmishAIWrapper() {
+	
+	if (ai) {
+/*
+		if (!IsCInterface) {
+			try {
+				_ReleaseAIFunc(ai);
+			} HANDLE_EXCEPTION;
+		}
+*/
+
+		delete c_callback;
+		delete callback;
+		delete ai;
+	}
+}
+
+void CSkirmishAIWrapper::Serialize(creg::ISerializer* s) {}
+
+
+
+
+void CSkirmishAIWrapper::PostLoad() {
+	LoadSkirmishAI(teamId, skirmishAIKey, true);
+}
+
+
+
+void CSkirmishAIWrapper::LoadSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey, bool postLoad) {
+	
+	ai = SAFE_NEW CSkirmishAI(teamId, skirmishAIKey);
+	
+	const ISkirmishAILibrary* skirmishAILibrary = IAILibraryManager::GetInstance()-&gt;FetchSkirmishAILibrary(skirmishAIKey);
+	//bool loadSupported = std::string(skirmishAILibrary-&gt;GetInfos()[SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED].value) == &quot;yes&quot;;
+	bool loadSupported = IAILibraryManager::GetInstance()-&gt;GetSkirmishAIInfos()-&gt;at(skirmishAIKey)-&gt;GetInfo(SKIRMISH_AI_PROPERTY_LOAD_SUPPORTED) == &quot;yes&quot;;
+	IAILibraryManager::GetInstance()-&gt;ReleaseSkirmishAILibrary(skirmishAIKey);
+
+	if (postLoad &amp;&amp; !loadSupported) {
+		// fallback code to help the AI if it
+		// doesn't implement load/save support
+		for (int a = 0; a &lt; MAX_UNITS; a++) {
+			if (!uh-&gt;units[a])
+				continue;
+
+			if (uh-&gt;units[a]-&gt;team == teamId) {
+				try {
+					UnitCreated(a);
+				} HANDLE_EXCEPTION;
+				if (!uh-&gt;units[a]-&gt;beingBuilt)
+					try {
+						UnitFinished(a);
+					} HANDLE_EXCEPTION;
+			} else {
+				if ((uh-&gt;units[a]-&gt;allyteam == gs-&gt;AllyTeam(teamId)) || gs-&gt;Ally(gs-&gt;AllyTeam(teamId), uh-&gt;units[a]-&gt;allyteam)) {
+					/* do nothing */
+				} else {
+					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(teamId)] &amp; (LOS_INRADAR | LOS_INLOS)) {
+						try {
+							EnemyEnterRadar(a);
+						} HANDLE_EXCEPTION;
+					}
+					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(teamId)] &amp; LOS_INLOS) {
+						try {
+							EnemyEnterLOS(a);
+						} HANDLE_EXCEPTION;
+					}
+				}
+			}
+		}
+	}
+}
+/*
+
+void CSkirmishAIWrapper::LoadCPPAI(int team, const char* botLibName, bool postLoad, bool loadSupported, bool isJavaAI)
+{
+	if (isJavaAI) {
+		logOutput &lt;&lt; botLibName &lt;&lt; &quot; is a Java archive\n&quot;;
+	} else {
+		logOutput &lt;&lt; botLibName &lt;&lt; &quot; has a C++ interface\n&quot;;
+	}
+
+	_GetGlobalAiVersionFunc = (GETGLOBALAIVERSION) lib-&gt;FindAddress(&quot;GetGlobalAiVersion&quot;);
+
+	if (_GetGlobalAiVersionFunc == 0) {
+		char msg[512];
+		SNPRINTF(msg, 511, &quot;Incorrect GlobalAI library \&quot;%s\&quot; (no \&quot;GetGlobalAiVersion\&quot; function exported)&quot;, botLibName);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
+
+	const int botInterfaceVersion = _GetGlobalAiVersionFunc();
+
+	if (botInterfaceVersion != GLOBAL_AI_INTERFACE_VERSION) {
+		char msg[1024];
+		SNPRINTF(msg, 1023,
+			&quot;Incorrect GlobalAI library \&quot;%s\&quot;\n&quot;
+			&quot;(lib interface version %d, engine interface version %d)&quot;,
+			botLibName, botInterfaceVersion, GLOBAL_AI_INTERFACE_VERSION);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
+
+
+	if (isJavaAI) {
+		// we want to load a Java AI inside a jar,
+		// pass the name of the actual .jar to the
+		// proxy library so it can spawn a JVM for
+		// that AI
+		_GetNewAIByNameFunc = (GETNEWAIBYNAME) lib-&gt;FindAddress(&quot;GetNewAIByName&quot;);
+
+		if (_GetNewAIByNameFunc == 0) {
+			throw std::runtime_error(&quot;JAI proxy does not export \&quot;GetNewAIByName\&quot;&quot;);
+		}
+
+		// note: team parameter is unnecessary
+		ai = _GetNewAIByNameFunc(botLibName, team);
+	} else {
+		_GetNewAIFunc = (GETNEWAI) lib-&gt;FindAddress(&quot;GetNewAI&quot;);
+
+		if (_GetNewAIFunc == 0) {
+			char msg[512];
+			SNPRINTF(msg, 511, &quot;GlobalAI library \&quot;%s\&quot; does not export \&quot;GetNewAI\&quot;&quot;, botLibName);
+			throw std::runtime_error(msg);
+		}
+
+		ai = _GetNewAIFunc();
+	}
+
+	// note: verify that this is really exported too?
+	_ReleaseAIFunc = (RELEASEAI) lib-&gt;FindAddress(&quot;ReleaseAI&quot;);
+	callback = SAFE_NEW CGlobalAICallback(this);
+
+	if (!postLoad || (postLoad &amp;&amp; !loadSupported)) {
+		try {
+			ai-&gt;InitAI(callback, team);
+		} HANDLE_EXCEPTION;
+	}
+}
+
+
+void CSkirmishAIWrapper::LoadJavaProxyAI()
+{
+	// TODO: Mac support? non-hardcoded proxy?
+	#ifdef WIN32
+	const char* javaProxyAI = &quot;AI\\Skirmish\\impls\\JAI\\JAI.dll&quot;;
+	#else
+	const char* javaProxyAI = &quot;AI/Skirmish/impls/JAI/JAI.so&quot;;
+	#endif
+
+	if (!filesystem.GetFilesize(javaProxyAI)) {
+		char msg[512];
+		SNPRINTF(msg, 511, &quot;Could not find Java GlobalAI proxy library \&quot;%s\&quot;&quot;, javaProxyAI);
+		handleerror(NULL, msg, &quot;Error&quot;, MBF_OK | MBF_EXCL);
+		return;
+	}
+
+	lib = SharedLib::Instantiate(javaProxyAI);
+}
+*/
+
+
+
+
+
+void CSkirmishAIWrapper::Init() {
+	
+	callback = SAFE_NEW CGlobalAICallback(this);
+	c_callback = initSAICallback(teamId, callback);
+	
+	SInitEvent evtData = {teamId, c_callback};
+	ai-&gt;HandleEvent(EVENT_INIT, &amp;evtData);
+}
+
+
+void CSkirmishAIWrapper::Load(std::istream* s) {
+	
+/* TODO
+	SLoadAIEvent evtData = {s.TO_FILENAME(TODO), callback};
+	ai-&gt;HandleEvent(EVENT_LOAD_AI, &amp;evtData);
+*/
+}
+
+void CSkirmishAIWrapper::Save(std::ostream* s) {
+	
+/* TODO
+	SSaveAIEvent evtData = {s.TO_FILENAME(TODO)};
+	ai-&gt;HandleEvent(EVENT_SAVE_AI, &amp;evtData);
+*/
+}
+
+void CSkirmishAIWrapper::UnitIdle(int unitId) {
+	
+	SUnitIdleEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_IDLE, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitCreated(int unitId) {
+	
+	SUnitCreatedEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_CREATED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitFinished(int unitId) {
+	
+	SUnitFinishedEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_FINISHED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitDestroyed(int unitId, int attackerUnitId) {
+	
+	SUnitDestroyedEvent evtData = {unitId, attackerUnitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_DESTROYED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitDamaged(int unitId, int attackerUnitId, float damage, const float3&amp; dir) {
+	
+	SUnitDamagedEvent evtData = {unitId, attackerUnitId, damage, dir.toSAIFloat3()};
+	ai-&gt;HandleEvent(EVENT_UNIT_DAMAGED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitMoveFailed(int unitId) {
+	
+	SUnitMoveFailedEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_MOVE_FAILED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitGiven(int unitId, int oldTeam, int newTeam) {
+
+	SUnitGivenEvent evtData = {unitId, oldTeam, newTeam};
+	ai-&gt;HandleEvent(EVENT_UNIT_GIVEN, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::UnitCaptured(int unitId, int oldTeam, int newTeam) {
+	
+	SUnitCapturedEvent evtData = {unitId, oldTeam, newTeam};
+	ai-&gt;HandleEvent(EVENT_UNIT_CAPTURED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::EnemyEnterLOS(int unitId) {
+	
+	SEnemyEnterLOSEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_ENTER_LOS, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::EnemyLeaveLOS(int unitId) {
+	
+	SEnemyLeaveLOSEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_LEAVE_LOS, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::EnemyEnterRadar(int unitId) {
+	
+	SEnemyEnterRadarEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_ENTER_RADAR, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::EnemyLeaveRadar(int unitId) {
+	
+	SEnemyLeaveRadarEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_LEAVE_RADAR, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::EnemyDestroyed(int enemyUnitId, int attackerUnitId) {
+	
+	SEnemyDestroyedEvent evtData = {enemyUnitId, attackerUnitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_DESTROYED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::EnemyDamaged(int enemyUnitId, int attackerUnitId, float damage, const float3&amp; dir) {
+	
+	SEnemyDamagedEvent evtData = {enemyUnitId, attackerUnitId, damage, dir.toSAIFloat3()};
+	ai-&gt;HandleEvent(EVENT_ENEMY_DAMAGED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::Update(int frame) {
+	
+	SUpdateEvent evtData = {frame};
+	ai-&gt;HandleEvent(EVENT_UPDATE, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::GotChatMsg(const char* msg, int fromPlayerId) {
+	
+	SMessageEvent evtData = {fromPlayerId, msg};
+	ai-&gt;HandleEvent(EVENT_MESSAGE, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::WeaponFired(int unitId, int weaponDefId) {
+	
+	SWeaponFiredEvent evtData = {unitId, weaponDefId};
+	ai-&gt;HandleEvent(EVENT_WEAPON_FIRED, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::PlayerCommandGiven(const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId) {
+	
+	int numUnits = selectedUnits.size();
+	int unitIds[numUnits];
+	int i;
+	for (i=0; i &lt; numUnits; ++i) {
+		unitIds[i] = selectedUnits.at(i);
+	}
+	int sCommandId;
+	void* sCommandData = mallocSUnitCommand(-1, -1, &amp;c, &amp;sCommandId);
+	
+	SPlayerCommandEvent evtData = {unitIds, numUnits, sCommandId, sCommandData, playerId};
+	ai-&gt;HandleEvent(EVENT_PLAYER_COMMAND, &amp;evtData);
+}
+
+void CSkirmishAIWrapper::SeismicPing(int allyTeam, int unitId, const float3&amp; pos, float strength) {
+	
+	SSeismicPingEvent evtData = {pos.toSAIFloat3(), strength};
+	ai-&gt;HandleEvent(EVENT_SEISMIC_PING, &amp;evtData);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+int CSkirmishAIWrapper::GetTeamId() const {
+	return teamId;
+}
+
+void CSkirmishAIWrapper::SetCheatEventsEnabled(bool enable) {
+	cheatEvents = enable;
+}
+bool CSkirmishAIWrapper::IsCheatEventsEnabled() const {
+	return cheatEvents;
+}
+
+int CSkirmishAIWrapper::HandleEvent(int topic, const void* data) const
+{
+	return ai-&gt;HandleEvent(topic, data);
+}
+
+//IMPLEMENT_PURE_VIRTUAL(CSkirmishAIWrapper::~CSkirmishAIWrapper())

Copied: branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h (from rev 6208, branches/caiinterface/rts/ExternalAI/GlobalAI.h)
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,118 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _SKIRMISHAIWRAPPER_H
+#define _SKIRMISHAIWRAPPER_H
+
+#include &quot;Object.h&quot;
+#include &quot;ISkirmishAI.h&quot;
+#include &quot;GlobalAICallback.h&quot;
+#include &quot;Interface/SAICallback.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+
+class CAICallback;
+struct Command;
+struct float3;
+
+class CSkirmishAIWrapper : public CObject, public ISkirmishAI {
+public:
+	CR_DECLARE(CSkirmishAIWrapper);
+//	CSkirmishAIWrapper();
+	CSkirmishAIWrapper(int teamId, const SSAIKey&amp; skirmishAIKey);
+	~CSkirmishAIWrapper();
+
+	void Serialize(creg::ISerializer *s);
+	void PostLoad();
+	
+	// AI Events
+	virtual void Load(std::istream *s);
+	virtual void Save(std::ostream *s);
+	
+	virtual void UnitIdle(int unitId);
+	virtual void UnitCreated(int unitId);
+	virtual void UnitFinished(int unitId);
+	virtual void UnitDestroyed(int unitId, int attackerUnitId);
+	virtual void UnitDamaged(int unitId, int attackerUnitId, float damage, const float3&amp; dir);
+	virtual void UnitMoveFailed(int unitId);
+	virtual void UnitGiven(int unitId, int oldTeam, int newTeam);
+	virtual void UnitCaptured(int unitId, int oldTeam, int newTeam);
+	virtual void EnemyEnterLOS(int unitId);
+	virtual void EnemyLeaveLOS(int unitId);
+	virtual void EnemyEnterRadar(int unitId);
+	virtual void EnemyLeaveRadar(int unitId);
+	virtual void EnemyDestroyed(int enemyUnitId, int attackerUnitId);
+	virtual void EnemyDamaged(int enemyUnitId, int attackerUnitId, float damage, const float3&amp; dir);
+	virtual void Update(int frame);
+	virtual void GotChatMsg(const char* msg, int fromPlayerId);
+	virtual void WeaponFired(int unitId, int weaponDefId);
+	virtual void PlayerCommandGiven(const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId);
+	virtual void SeismicPing(int allyTeam, int unitId, const float3&amp; pos, float strength);
+
+	
+	
+	virtual void PreDestroy(); // called just before all the units are destroyed
+	
+    virtual int GetTeamId() const;
+	
+    virtual void SetCheatEventsEnabled(bool enable);
+    virtual bool IsCheatEventsEnabled() const;
+	
+	
+	
+	/**
+	 * inherited form ISkirmishAI.
+	 * CAUTION: takes C AI Interface events, not engine C++ ones!
+	 */
+    virtual int HandleEvent(int topic, const void* data) const;
+
+private:
+	virtual void Init();
+	
+private:
+	int teamId;
+	bool cheatEvents;
+
+//	bool loadSupported;
+
+	ISkirmishAI* ai;
+	CGlobalAICallback* callback;
+	SAICallback* c_callback;
+	SSAIKey skirmishAIKey;
+
+//	typedef bool (*ISCINTERFACE)();
+//	typedef int (*GETGLOBALAIVERSION)();
+//	typedef IGlobalAI* (*GETNEWAI)();
+//	typedef IGlobalAI* (*GETNEWAIBYNAME)(const char*, int);
+//	typedef void (*RELEASEAI)(IGlobalAI* i);
+//	typedef bool (*ISLOADSUPPORTED)();
+	
+//	ISCINTERFACE _IsCInterfaceFunc;
+//	GETGLOBALAIVERSION _GetGlobalAiVersionFunc;
+//	GETNEWAI _GetNewAIFunc;
+//	GETNEWAIBYNAME _GetNewAIByNameFunc;
+//	RELEASEAI _ReleaseAIFunc;
+//	ISLOADSUPPORTED _IsLoadSupportedFunc;
+
+private:
+	void LoadSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey, bool postLoad);
+//	void LoadCPPAI(int, const char*, bool, bool, bool);
+//	void LoadJavaProxyAI();
+};
+
+#endif /* _SKIRMISHAIWRAPPER_H */
+

Modified: branches/caiinterface/rts/ExternalAI/aibase.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/aibase.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/ExternalAI/aibase.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -6,19 +6,7 @@
 #ifndef AIBASE_H
 #define AIBASE_H
 
-// Shared library support
-#ifdef _WIN32
-	#define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)
-	#define SPRING_API
-#elif __GNUC__ &gt;= 4
-	// Support for '-fvisibility=hidden'.
-	#define DLL_EXPORT extern &quot;C&quot; __attribute__ ((visibility(&quot;default&quot;)))
-	#define SPRING_API __attribute__ ((visibility(&quot;default&quot;)))
-#else
-	// Older versions of gcc have everything visible; no need for fancy stuff.
-	#define DLL_EXPORT extern &quot;C&quot;
-	#define SPRING_API
-#endif
+#include &quot;exportdefines.h&quot;
 
 // Virtual destructor support (across DLL/SO interface)
 #if defined(_WIN32) || defined(__APPLE__)

Modified: branches/caiinterface/rts/Game/GameServer.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameServer.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/GameServer.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -29,6 +29,10 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;FileSystem/CRC.h&quot;
 #include &quot;Player.h&quot;
+// This undef is needed, as somewhere there is a type interface specifyed,
+// which we need not!
+// (would cause problems in ExternalAI/Interface/SAIInterfaceLibrary.h)
+#undef interface
 #include &quot;Team.h&quot;
 #include &quot;Server/MsgStrings.h&quot;
 
@@ -1199,7 +1203,7 @@
 				hasPlayer = true;
 			}
 		}
-		if (!setup || !gs-&gt;Team(a)-&gt;dllAI.empty())
+		if (!setup || !SSAIKey_Comparator::IsEmpty(gs-&gt;Team(a)-&gt;skirmishAISpecifyer)) // is not empty?
 			hasPlayer = true;
 
 		if (!gs-&gt;Team(a)-&gt;isDead &amp;&amp; !gs-&gt;Team(a)-&gt;gaia &amp;&amp; hasPlayer)

Modified: branches/caiinterface/rts/Game/GameSetup.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/GameSetup.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -194,7 +194,7 @@
 	int playerCount = -1;
 	file.GetDef(playerCount,   &quot;-1&quot;, &quot;GAME\\NumPlayers&quot;);
 	
-	if (playerCount == -1 || playerStartingData.size() == playerCount)
+	if (playerCount == -1 || (int)playerStartingData.size() == playerCount)
 		numPlayers = playerStartingData.size();
 	else
 		throw content_error(&quot;incorrect number of players in GameSetup script&quot;);
@@ -238,8 +238,15 @@
 
 		// Is this team (Lua) AI controlled?
 		// If this is a demo replay, non-Lua AIs aren't loaded.
-		const string aiDll = file.SGetValueDef(&quot;&quot;, s + &quot;aidll&quot;);
-		data.aiDll = aiDll;
+		data.luaAI = file.SGetValueDef(&quot;&quot;, s + &quot;aispecifyer&quot;);
+		if (data.luaAI.empty()) {
+			data.luaAI = file.SGetValueDef(&quot;&quot;, s + &quot;luaai&quot;);
+		} else if (data.luaAI.size() &gt; 6 &amp;&amp; data.luaAI.substr(0, 6) == &quot;LuaAI:&quot;) {
+			data.luaAI = data.luaAI.substr(6);
+		}
+		data.skirmishAIShortName = file.SGetValueDef(&quot;&quot;, s + &quot;ainame&quot;);
+		data.skirmishAIVersion = file.SGetValueDef(&quot;&quot;, s + &quot;aiversion&quot;);
+		
 		teamStartingData.push_back(data);
 
 		teamRemap[a] = i;
@@ -249,7 +256,7 @@
 	int teamCount = -1;
 	file.GetDef(teamCount, &quot;-1&quot;, &quot;GAME\\NumTeams&quot;);
 	
-	if (teamCount == -1 || teamStartingData.size() == teamCount)
+	if (teamCount == -1 || (int)teamStartingData.size() == teamCount)
 		numTeams = teamStartingData.size();
 	else
 		throw content_error(&quot;incorrect number of teams in GameSetup script&quot;);
@@ -296,7 +303,7 @@
 	int allyCount = -1;
 	file.GetDef(allyCount, &quot;-1&quot;, &quot;GAME\\NumAllyTeams&quot;);
 	
-	if (allyCount == -1 || allyStartingData.size() == allyCount)
+	if (allyCount == -1 || (int)allyStartingData.size() == allyCount)
 		numAllyTeams = allyStartingData.size();
 	else
 		throw content_error(&quot;incorrect number of teams in GameSetup script&quot;);

Modified: branches/caiinterface/rts/Game/GameSetup.h
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/GameSetup.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -72,7 +72,9 @@
 		SFloat3 startPos;
 		int teamStartNum;
 		int teamAllyteam;
-		std::string aiDll;
+		std::string luaAI;
+		std::string skirmishAIShortName;
+		std::string skirmishAIVersion;
 	};
 	std::vector&lt;TeamData&gt; teamStartingData;
 	

Modified: branches/caiinterface/rts/Game/Player.cpp
===================================================================
--- branches/caiinterface/rts/Game/Player.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/Player.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -110,7 +110,7 @@
 	for (int t = 0; t &lt; gs-&gt;activeTeams; t++) {
 		const CTeam* team = gs-&gt;Team(t);
 		if (team &amp;&amp; team-&gt;isAI &amp;&amp;
-		    !team-&gt;dllAI.empty() &amp;&amp; // luaAI does not require client control
+		    !SSAIKey_Comparator::IsEmpty(team-&gt;skirmishAISpecifyer) &amp;&amp; // is not empty? -&gt; luaAI does not require client control
 		    (team-&gt;leader == playerNum)) {
 			controlledTeams.insert(t);
 		}

Modified: branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -4,6 +4,7 @@
 #include &lt;map&gt;
 #include &quot;CommanderScript.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/Team.h&quot;
@@ -54,8 +55,9 @@
 			team-&gt;energyStorage = 20;
 
 			// create a GlobalAI if required
-			if (!team-&gt;dllAI.empty() &amp;&amp; (gu-&gt;myPlayerNum == team-&gt;leader)) {
-				globalAI-&gt;CreateGlobalAI(a, team-&gt;dllAI.c_str());
+			if (!SSAIKey_Comparator::IsEmpty(team-&gt;skirmishAISpecifyer) // is an AI specifyed?
+					&amp;&amp; (gu-&gt;myPlayerNum == team-&gt;leader)) {
+				globalAI-&gt;CreateSkirmishAI(a, team-&gt;skirmishAISpecifyer);
 			}
 
 			// get the team startup info

Modified: branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -18,14 +18,14 @@
 extern std::string stupidGlobalMapname;
 
 
-CGlobalAITestScript::CGlobalAITestScript(std::string dll):
-	CScript(std::string(&quot;GlobalAI test (&quot;) + filesystem.GetFilename(dll) + std::string(&quot;)&quot;)),
-	dllName(dll)
+CGlobalAITestScript::CGlobalAITestScript(const SSAIKey&amp; skirmishAISpecifyer):
+	CScript(std::string(&quot;GlobalAI test (&quot;) + std::string(skirmishAISpecifyer.ai.shortName) + std::string(&quot;)&quot;)),
+	skirmishAISpecifyer(skirmishAISpecifyer)
 {
 	// make sure CSelectedUnits::AiOrder()
 	// still works without a setup script
 	gs-&gt;Team(1)-&gt;isAI = true;
-	gs-&gt;Team(1)-&gt;dllAI = dllName;
+	gs-&gt;Team(1)-&gt;skirmishAISpecifyer = skirmishAISpecifyer;
 	gs-&gt;Team(1)-&gt;leader = 0;
 }
 
@@ -37,7 +37,7 @@
 
 void CGlobalAITestScript::GameStart(void)
 {
-	globalAI-&gt;CreateGlobalAI(1, dllName.c_str());
+	globalAI-&gt;CreateSkirmishAI(1, skirmishAISpecifyer);
 
 	gs-&gt;Team(0)-&gt;energy        = 1000;
 	gs-&gt;Team(0)-&gt;energyStorage = 1000;

Modified: branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.h
===================================================================
--- branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/StartScripts/GlobalAITestScript.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -2,13 +2,14 @@
 #define GLOBALAITESTSCRIPT_H
 
 #include &quot;Script.h&quot;
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 
 class CGlobalAITestScript :
 	public CScript
 {
-	std::string dllName;
+	SSAIKey skirmishAISpecifyer;
 public:
-	CGlobalAITestScript(std::string dll);
+	CGlobalAITestScript(const SSAIKey&amp; skirmishAISpecifyer);
 	~CGlobalAITestScript(void);
 
 	void GameStart(void);

Modified: branches/caiinterface/rts/Game/StartScripts/ScriptHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/StartScripts/ScriptHandler.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/StartScripts/ScriptHandler.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -16,10 +16,12 @@
 #include &quot;EmptyScript.h&quot;
 #include &quot;TestScript.h&quot;
 #include &quot;Platform/SharedLib.h&quot;
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
 #ifndef NO_LUA
 #  include &quot;System/Platform/errorhandler.h&quot;
 #endif
 #include &quot;mmgr.h&quot;
+#include &quot;ExternalAI/IAILibraryManager.h&quot;
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -43,13 +45,14 @@
 	loaded_scripts.push_back( SAFE_NEW CSpawnScript(true) );
 	loaded_scripts.push_back( SAFE_NEW CTestScript() );
 
-	const char *path = &quot;AI/Bot-libs/&quot;;
-	std::vector&lt;std::string&gt; f = CFileHandler::FindFiles(path, std::string(&quot;*.&quot;) + SharedLib::GetLibExtension());
+	const std::vector&lt;SSAIKey&gt;* skirmishAIKeys = IAILibraryManager::GetInstance()-&gt;GetSkirmishAIKeys();
+	
+	std::vector&lt;SSAIKey&gt;::const_iterator ai, e;
+	for(ai=skirmishAIKeys-&gt;begin(), e=skirmishAIKeys-&gt;end(); ai != e; ++ai) {
+		loaded_scripts.push_back(SAFE_NEW CGlobalAITestScript(*ai));
+	}
 
-	for(std::vector&lt;std::string&gt;::iterator fi = f.begin(), e = f.end(); fi != e; ++fi)
-		loaded_scripts.push_back(SAFE_NEW CGlobalAITestScript(*fi));
-
-	f = CFileHandler::FindFiles(&quot;Saves/&quot;, &quot;*.ssf&quot;);
+	std::vector&lt;std::string&gt; f = CFileHandler::FindFiles(&quot;Saves/&quot;, &quot;*.ssf&quot;);
 	for(std::vector&lt;std::string&gt;::iterator fi = f.begin(), e = f.end(); fi != e; ++fi) {
 		loaded_scripts.push_back(SAFE_NEW CLoadScript(*fi));
 	}

Modified: branches/caiinterface/rts/Game/Team.cpp
===================================================================
--- branches/caiinterface/rts/Game/Team.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/Team.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -12,7 +12,6 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;ExternalAI/GlobalAI.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;System/EventHandler.h&quot;
 #include &quot;creg/STL_List.h&quot;
@@ -35,7 +34,7 @@
 				CR_MEMBER(side),
 				CR_MEMBER(isAI),
 				CR_MEMBER(luaAI),
-				CR_MEMBER(dllAI),
+				CR_MEMBER(skirmishAISpecifyer),
 				CR_MEMBER(units),
 				CR_MEMBER(startPos),
 				CR_MEMBER(metal),
@@ -129,7 +128,7 @@
   side(&quot;arm&quot;),
   isAI(false),
   luaAI(&quot;&quot;),
-  dllAI(&quot;&quot;),
+//  skirmishAISpecifyer(SSAIKey()),
   startPos(100,100,100),
   handicap(1),
   leader(-1),
@@ -279,9 +278,8 @@
 			gs-&gt;players[a]-&gt;StartSpectating();
 		}
 	}
-	if (globalAI-&gt;ais[teamNum]) {
-		delete globalAI-&gt;ais[teamNum];
-		globalAI-&gt;ais[teamNum] = NULL;
+	if (globalAI-&gt;IsSkirmishAI(teamNum)) {
+		globalAI-&gt;DestroySkirmishAI(teamNum);
 	}
 
 	CLuaUI::UpdateTeams();

Modified: branches/caiinterface/rts/Game/Team.h
===================================================================
--- branches/caiinterface/rts/Game/Team.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Game/Team.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -11,6 +11,7 @@
 #include &lt;list&gt;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;Sim/Units/UnitSet.h&quot;
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 
 class CTeam
 {
@@ -67,7 +68,7 @@
 
 	bool isAI;
 	std::string luaAI;
-	std::string dllAI;
+	SSAIKey skirmishAISpecifyer;
 
 	// color info is unsynced
 	unsigned char color[4];

Modified: branches/caiinterface/rts/Lua/LuaIO.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaIO.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Lua/LuaIO.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -11,7 +11,9 @@
 #include &lt;string&gt;
 using std::string;
 
+#if !defined UNITSYNC &amp;&amp; !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 #include &quot;LuaHandle.h&quot;
+#endif
 #include &quot;LuaInclude.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
 
@@ -65,7 +67,7 @@
 bool LuaIO::SafeWritePath(const string&amp; path)
 {
 	string prefix = &quot;&quot;; // FIXME
-#if !defined UNITSYNC &amp;&amp; !defined DEDICATED
+#if !defined UNITSYNC &amp;&amp; !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 	const CLuaHandle* lh = CLuaHandle::GetActiveHandle();
 	if (lh != NULL) {
 		prefix = lh-&gt;GetName() + &quot;/&quot; + &quot;Write&quot;;

Modified: branches/caiinterface/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaSyncedRead.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Lua/LuaSyncedRead.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1012,7 +1012,7 @@
 
 	bool isAiTeam = false;
 	if (!team-&gt;luaAI.empty() ||
-	    ((globalAI != NULL) &amp;&amp; (globalAI-&gt;ais[teamID] != NULL))) {
+	    ((globalAI != NULL) &amp;&amp; globalAI-&gt;IsSkirmishAI(teamID))) {
 		isAiTeam = true;
 	}
 

Modified: branches/caiinterface/rts/Map/MapParser.cpp
===================================================================
--- branches/caiinterface/rts/Map/MapParser.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/Map/MapParser.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -41,14 +41,14 @@
 	parser-&gt;AddString(&quot;fullName&quot;, &quot;maps/&quot; + mapName);
 	parser-&gt;AddString(&quot;configFile&quot;, mapConfig);
 	parser-&gt;EndTable();
-#if !defined UNITSYNC &amp;&amp; !defined DEDICATED
+#if !defined UNITSYNC &amp;&amp; !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 	// this should not be included with unitsync:
 	// 1. avoids linkage with LuaSyncedRead
 	// 2. MapOptions are not valid during unitsync map parsing
 	parser-&gt;GetTable(&quot;Spring&quot;);
 	parser-&gt;AddFunc(&quot;GetMapOptions&quot;, LuaSyncedRead::GetMapOptions);
 	parser-&gt;EndTable();
-#endif
+#endif	/* !defined UNITSYNC &amp;&amp; !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
 	if (!parser-&gt;Execute()) {
 		// do nothing
 	}

Modified: branches/caiinterface/rts/System/GlobalStuff.cpp
===================================================================
--- branches/caiinterface/rts/System/GlobalStuff.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/GlobalStuff.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -6,6 +6,7 @@
  * unsynced global stuff
  */
 #include &quot;StdAfx.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
 #include &lt;cstring&gt;
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Game/GameHelper.h&quot;
@@ -19,6 +20,7 @@
 #include &quot;SDL_types.h&quot;
 #include &quot;SDL_timer.h&quot;
 #include &quot;mmgr.h&quot;
+#include &quot;ExternalAI/IAILibraryManager.h&quot;
 
 /**
  * @brief global synced
@@ -191,17 +193,30 @@
 		teams[i]-&gt;leader = setup-&gt;teamStartingData[i].leader;
 		teams[i]-&gt;side = setup-&gt;teamStartingData[i].side;
 		SetAllyTeam(i, setup-&gt;teamStartingData[i].teamAllyteam);
-		if (setup-&gt;teamStartingData[i].aiDll.substr(0, 6) == &quot;LuaAI:&quot;) {
-			teams[i]-&gt;luaAI = setup-&gt;teamStartingData[i].aiDll.substr(6);
+		if (!(setup-&gt;teamStartingData[i].luaAI.empty())) {
+			teams[i]-&gt;luaAI = setup-&gt;teamStartingData[i].luaAI;
 			teams[i]-&gt;isAI = true;
 		}
 		else {
-			if (setup-&gt;hostDemo)
-				teams[i]-&gt;dllAI = &quot;&quot;;
+			if (setup-&gt;hostDemo) {
+				SSAIKey key = {{NULL, NULL}, {NULL, NULL}};
+				teams[i]-&gt;skirmishAISpecifyer = key;
+			}
 			else
 			{
-				teams[i]-&gt;dllAI = setup-&gt;teamStartingData[i].aiDll;
-				teams[i]-&gt;isAI = true;
+				const char* sn = setup-&gt;teamStartingData[i].skirmishAIShortName.c_str();
+				const char* v = setup-&gt;teamStartingData[i].skirmishAIVersion.empty() ? NULL : setup-&gt;teamStartingData[i].skirmishAIVersion.c_str();
+				SSAISpecifyer spec = {sn, v};
+				std::vector&lt;SSAIKey&gt; fittingKeys = IAILibraryManager::GetInstance()-&gt;ResolveSkirmishAIKey(spec);
+				if (fittingKeys.size() &gt; 0) {
+					teams[i]-&gt;skirmishAISpecifyer = fittingKeys[0];
+					teams[i]-&gt;isAI = true;
+				} else {
+					const int MAX_MSG_LENGTH = 511;
+					char s_msg[MAX_MSG_LENGTH + 1];
+					SNPRINTF(s_msg, MAX_MSG_LENGTH, &quot;Specifyed Skirmish AI could not be found: %s (version: %s)&quot;, spec.shortName, spec.version != NULL ? spec.version : &quot;&lt;not specifyed&gt;&quot;);
+					handleerror(NULL, s_msg, &quot;Game Script Error&quot;, MBF_OK | MBF_EXCL);
+				}
 			}
 		}
 		for (unsigned t = 0; t &lt; static_cast&lt;unsigned&gt;(MAX_TEAMS); ++t)
@@ -280,6 +295,11 @@
 	return -1;
 }
 
+CGlobalSyncedStuff* CGlobalSyncedStuff::instance = NULL;
+CGlobalSyncedStuff* CGlobalSyncedStuff::GetInstance() {
+	return instance;
+}
+
 /**
  * Initializes variables in CGlobalUnsyncedStuff
  */
@@ -374,3 +394,8 @@
 	spectatingFullSelect = setup-&gt;playerStartingData[myPlayerNum].spectator;
 }
 
+CGlobalUnsyncedStuff* CGlobalUnsyncedStuff::instance = NULL;
+CGlobalUnsyncedStuff* CGlobalUnsyncedStuff::GetInstance() {
+	return instance;
+}
+

Modified: branches/caiinterface/rts/System/GlobalStuff.h
===================================================================
--- branches/caiinterface/rts/System/GlobalStuff.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/GlobalStuff.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -123,6 +123,7 @@
  */
 const float3 ZeroVector(0,0,0);
 
+#if !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 class CTeam;
 class CUnit;
 class CPlayer;
@@ -153,6 +154,11 @@
 	}
 	unsigned int GetRandSeed()     const { return randSeed; }
 	unsigned int GetInitRandSeed() const { return initRandSeed; }
+	
+	static CGlobalSyncedStuff* GetInstance();
+private:
+	static CGlobalSyncedStuff* instance;
+public:
 
 	/**
 	 * @brief frame number
@@ -471,6 +477,11 @@
 	float3 usRandVector(); //!&lt; Unsynced random vector
 
 	void LoadFromSetup(const CGameSetup*);
+	
+	static CGlobalUnsyncedStuff* GetInstance();
+private:
+	static CGlobalUnsyncedStuff* instance;
+public:
 
 	/**
 	 * Does the user want team colored nanospray if the mod allows it?
@@ -666,7 +677,7 @@
 	 * this player
 	 */
 	CUnit* directControl;
-#endif
+#endif	/* DIRECT_CONTROL_ALLOWED */
 	
 private:
 	/**
@@ -681,5 +692,6 @@
 extern CGlobalSyncedStuff* gs;
 extern CGlobalUnsyncedStuff* gu;
 extern bool fullscreen;
+#endif /* !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
 
 #endif /* GLOBALSTUFF_H */

Modified: branches/caiinterface/rts/System/LoadSaveHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/LoadSaveHandler.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/LoadSaveHandler.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,6 +1,5 @@
 #include &quot;StdAfx.h&quot;
 #include &lt;fstream&gt;
-#include &quot;ExternalAI/GlobalAI.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;ExternalAI/GroupHandler.h&quot;
 #include &quot;LoadSaveHandler.h&quot;
@@ -202,9 +201,8 @@
 	globalAI-&gt;Load(ifs);
 	delete ifs;
 	for (int a=0;a&lt;MAX_TEAMS;a++) {//For old savegames
-		if (gs-&gt;Team(a)-&gt;isDead &amp;&amp; globalAI-&gt;ais[a]) {
-			delete globalAI-&gt;ais[a];
-			globalAI-&gt;ais[a] = 0;
+		if (gs-&gt;Team(a)-&gt;isDead &amp;&amp; globalAI-&gt;IsSkirmishAI(a)) {
+			globalAI-&gt;DestroySkirmishAI(a);
 		}
 	}
 	gs-&gt;paused = false;

Modified: branches/caiinterface/rts/System/LogOutput.cpp
===================================================================
--- branches/caiinterface/rts/System/LogOutput.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/LogOutput.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -2,6 +2,9 @@
 #include &quot;StdAfx.h&quot;
 #include &lt;assert.h&gt;
 #include &quot;LogOutput.h&quot;
+#if !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
+#include &quot;GlobalStuff.h&quot;
+#endif	/* !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
 #include &lt;cstdarg&gt;
 #include &lt;fstream&gt;
 #include &lt;string.h&gt;
@@ -12,19 +15,50 @@
 #include &lt;windows.h&gt;
 #endif
 
-static std::ofstream* filelog = 0;
-static bool initialized = false;
+//#if defined BUILDING_AI
+//static std::ofstream* ai_filelog = 0;
+/*
+#if defined BUILDING_AI_INTERFACE
+#define LOG_FILE_NAME &quot;CAIInterface_infolog.txt&quot;
+static std::ofstream* aiinterface_filelog = 0;
+static bool aiinterface_initialized = false;
+#define FILE_LOG aiinterface_filelog
+#define INITIALIZED aiinterface_initialized
+#else
+*/
+//#define LOG_FILE_NAME &quot;infolog.txt&quot;
+#if defined BUILDING_AI_INTERFACE
+#define LOG_FILE_PREFIX &quot;infolog_aiinterface&quot;
+#define LOG_FILE_PREFIX &quot;infolog&quot;
+#else
+#endif
+#define LOG_FILE_SUFFIX &quot;.txt&quot;
+//static std::ofstream* filelog = 0;
+//static bool initialized = false;
+static int infologIndex = 0;
+#define FILE_LOG filelog
+//#define INITIALIZED initialized
+//#endif
 static bool stdoutDebug = false;
-CLogOutput logOutput;
+//CLogOutput logOutput;
+CLogOutput&amp; logOutput = CLogOutput::GetInstance();
 static boost::recursive_mutex tempstrMutex;
 static std::string tempstr;
 
 static const int bufferSize = 2048;
 
+CLogOutput CLogOutput::myLogOutput = CLogOutput();
+//std::ofstream* CLogOutput::filelog = NULL;
+
+CLogOutput&amp; CLogOutput::GetInstance() {
+	return myLogOutput;
+}
+
 CLogOutput::CLogOutput()
 {
 	assert(this == &amp;logOutput);
-	assert(!filelog); // multiple infologs can't exist together!
+	FILE_LOG = NULL;
+	//assert(!(FILE_LOG)); // multiple infologs can't exist together!
 }
 
 CLogOutput::~CLogOutput()
@@ -34,8 +68,8 @@
 
 void CLogOutput::End()
 {
-	delete filelog;
-	filelog = 0;
+	delete FILE_LOG;
+	FILE_LOG = 0;
 }
 
 void CLogOutput::SetMirrorToStdout(bool value)
@@ -45,14 +79,29 @@
 
 void CLogOutput::Output(int zone, const char *str)
 {
-	if (!initialized) {
-		filelog = new std::ofstream(&quot;infolog.txt&quot;);
-		initialized = true;
+/*
+	if (!INITIALIZED) {
+		FILE_LOG = new std::ofstream(LOG_FILE_NAME);
+		INITIALIZED = true;
 	}
+*/
+	#if !defined BUILDING_AI_INTERFACE
+	if (FILE_LOG == NULL) {
+		#if defined BUILDING_AI_INTERFACE
+		const int MAX_STR_LENGTH = 511;
+		char logFileName[MAX_STR_LENGTH + 1];
+		SNPRINTF(logFileName, MAX_STR_LENGTH, &quot;infolog_aiinterface_%d.txt&quot;, infologIndex++);
+		#else
+		const char* logFileName = &quot;infolog.txt&quot;;
+		#endif
+		FILE_LOG = new std::ofstream(logFileName);
+	}
 
 	// Output to subscribers
-	for(std::vector&lt;ILogSubscriber*&gt;::iterator lsi=subscribers.begin();lsi!=subscribers.end();++lsi)
+#if !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
+	for(std::vector&lt;ILogSubscriber*&gt;::iterator lsi=subscribers.begin(); lsi!=subscribers.end();++lsi)
 		(*lsi)-&gt;NotifyLogMsg(zone, str);
+#endif	/* !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
 
 	int nl = strlen(str) - 1;
 
@@ -62,16 +111,16 @@
 		OutputDebugString(&quot;\n&quot;);
 #endif
 
-	if (filelog) {
-#ifndef DEDICATED
+	if (FILE_LOG) {
+#if !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 		if (gs) {
-			(*filelog) &lt;&lt; IntToString(gs-&gt;frameNum, &quot;[%7d] &quot;);
+			(*FILE_LOG) &lt;&lt; IntToString(gs-&gt;frameNum, &quot;[%7d] &quot;);
 		}
-#endif
-		(*filelog) &lt;&lt; str;
+#endif	/* !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
+		(*FILE_LOG) &lt;&lt; str;
 		if (nl &lt; 0 || str[nl] != '\n')
-			(*filelog) &lt;&lt; &quot;\n&quot;;
-		filelog-&gt;flush();
+			(*FILE_LOG) &lt;&lt; &quot;\n&quot;;
+		FILE_LOG-&gt;flush();
 	}
 
 	if (stdoutDebug) {
@@ -81,6 +130,7 @@
 		}
 		fflush(stdout);
 	}
+	#endif	/* !defined BUILDING_AI_INTERFACE */
 }
 
 void CLogOutput::SetLastMsgPos(const float3&amp; pos)

Modified: branches/caiinterface/rts/System/LogOutput.h
===================================================================
--- branches/caiinterface/rts/System/LogOutput.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/LogOutput.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -29,10 +29,10 @@
 
 class CLogOutput
 {
-public:
 	CLogOutput();
 	~CLogOutput();
 
+public:
 	void Print(int zone, const char *fmt, ...) FORMATSTRING(3);
 	void Print(const char *fmt, ...) FORMATSTRING(2);
 	void Print(const std::string&amp; text);
@@ -57,6 +57,11 @@
 	void RemoveSubscriber(ILogSubscriber *ls);
 
 	void SetMirrorToStdout(bool);
+	
+	static CLogOutput&amp; GetInstance();
+private:
+	static CLogOutput myLogOutput;
+	std::ofstream* filelog;
 
 protected:
 	void Output(int zone, const char *str);
@@ -65,7 +70,7 @@
 };
 
 
-extern CLogOutput logOutput;
+extern CLogOutput&amp; logOutput;
 
 #undef FORMATSTRING
 

Modified: branches/caiinterface/rts/System/Platform/BaseCmd.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/BaseCmd.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/BaseCmd.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -103,7 +103,7 @@
 		std::cout &lt;&lt; std::endl;
 		std::cout &lt;&lt; &quot;This program is licensed under the GNU General Public License&quot; &lt;&lt; std::endl;
 	}
-	std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; [OPTIONS]&quot; &lt;&lt; std::endl;
+	std::cout &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; [OPTIONS] [SCRIPTFILE]&quot; &lt;&lt; std::endl;
 }
 
 /**

Modified: branches/caiinterface/rts/System/Platform/ConfigHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/ConfigHandler.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/ConfigHandler.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -30,7 +30,7 @@
 
 
 std::string ConfigHandler::configSource;
-extern const char* VERSION_STRING;
+extern const char* const VERSION_STRING;
 
 
 /**

Modified: branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -228,11 +228,13 @@
 	datadirs.clear();
 
 	// user defined (in spring config handler (Linux: ~/.spring, Windows: registry))
+	#if !defined WIN32 || !(defined BUILDING_AI || defined BUILDING_AI_INTERFACE)
 	std::string userDef = configHandler.GetString(&quot;SpringData&quot;, &quot;&quot;);
 	if (!userDef.empty())
 	{
 		AddDirs(SubstEnvVars(userDef));
 	}
+	#endif	/* !defined WIN32 || !(defined BUILDING_AI || defined BUILDING_AI_INTERFACE) */
 	
 #ifdef WIN32
 	TCHAR currentDir[MAX_PATH];

Modified: branches/caiinterface/rts/System/Platform/Linux/SoLib.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/SoLib.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/Linux/SoLib.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -3,12 +3,11 @@
  * @brief Linux shared object loader implementation
  * @author Christopher Han &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">xiphux at gmail.com</A>&gt;
  *
- * Linux Shared Object loader class implementation
+ * Linux, Unix and Mac OS X Shared Object loader class implementation
  * Copyright (C) 2005.  Licensed under the terms of the
  * GNU GPL, v2 or later.
  */
 #include &lt;vector&gt;
-#include &quot;LogOutput.h&quot;
 #include &quot;SoLib.h&quot;
 #include &lt;dlfcn.h&gt;
 
@@ -19,17 +18,32 @@
 SoLib::SoLib(const char *filename)
 {
 	so = dlopen(filename,RTLD_LAZY);
-	if (so == NULL)
-		logOutput.Print(&quot;%s:%d: SoLib::SoLib: %s&quot;, __FILE__, __LINE__, dlerror());
+	if (so == NULL) {
+		SharedLib::reportError(dlerror(), __FILE__, __LINE__, &quot;SoLib::SoLib&quot;);
+	}
 }
 
 /**
  * Just dlcloses the shared object
  */
+void SoLib::Unload() {
+	
+	if (so != NULL) {
+		dlclose(so);
+		so = NULL;
+	}
+}
+
+bool SoLib::LoadFailed() {
+	return so == NULL;
+}
+
+/**
+ * Just dlcloses the shared object
+ */
 SoLib::~SoLib()
 {
-	if (so != NULL)
-		dlclose(so);
+	Unload();
 }
 
 /**
@@ -39,8 +53,9 @@
 {
 	if (so != NULL) {
 		void* p = dlsym(so, symbol);
-		if (p == NULL)
-			logOutput.Print(&quot;%s:%d: SoLib::FindAddress: %s&quot;, __FILE__, __LINE__, dlerror());
+		if (p == NULL) {
+			SharedLib::reportError(dlerror(), __FILE__, __LINE__, &quot;SoLib::FindAddress&quot;);
+		}
 		return p;
 	}
 	return NULL;

Modified: branches/caiinterface/rts/System/Platform/Linux/SoLib.h
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/SoLib.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/Linux/SoLib.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -28,6 +28,14 @@
 	SoLib(const char *filename);
 
 	/**
+	 * Just dlcloses the shared object
+	 * @brief unload
+	 */
+	virtual void Unload();
+	
+	virtual bool LoadFailed();
+
+	/**
 	 * @brief Destructor
 	 */
 	~SoLib();

Modified: branches/caiinterface/rts/System/Platform/SharedLib.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/SharedLib.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/SharedLib.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -8,6 +8,7 @@
  * GNU GPL, v2 or later.
  */
 #include &quot;StdAfx.h&quot;
+#include &quot;LogOutput.h&quot;
 #ifdef _WIN32
 #include &quot;Win/DllLib.h&quot;
 #else
@@ -17,13 +18,21 @@
 /**
  * Used to create a platform-specific shared library handler.
  */
-SharedLib *SharedLib::Instantiate(const char *filename)
+SharedLib* SharedLib::Instantiate(const char *filename)
 {
+	SharedLib* lib = NULL;
+	
 #ifdef _WIN32
-	return SAFE_NEW DllLib(filename);
+	lib = SAFE_NEW DllLib(filename);
 #else
-	return SAFE_NEW SoLib(filename);
+	lib = SAFE_NEW SoLib(filename);
 #endif
+	
+	if (lib == NULL || lib-&gt;LoadFailed()) {
+		lib = NULL;
+	}
+	
+	return lib;
 }
 
 /**
@@ -46,6 +55,17 @@
 #endif
 }
 
+void SharedLib::reportError(const char* errorMsg, const char* fileName, int lineNumber, const char* function) {
+	
+/*
+	const int MAX_MSG_LENGTH = 511;
+	char s_msg[MAX_MSG_LENGTH + 1];
+	SNPRINTF(s_msg, MAX_MSG_LENGTH, &quot;%s:%d: %s: %s&quot;, fileName, lineNumber, function, errorMsg);
+	handleerror(NULL, s_msg, &quot;Shared Library Error&quot;, MBF_OK | MBF_EXCL);
+*/
+	logOutput.Print(&quot;%s:%d: %s: %s&quot;, fileName, lineNumber, function, errorMsg);
+}
 
 SharedLib::~SharedLib() {
+    // subclasses will call Unload in thier destructors.
 }

Modified: branches/caiinterface/rts/System/Platform/SharedLib.h
===================================================================
--- branches/caiinterface/rts/System/Platform/SharedLib.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/SharedLib.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -47,6 +47,18 @@
 	static SharedLib *Instantiate(std::string filename);
 
 	/**
+	 * Explicitly unload this shared library
+	 * @brief unload
+	 */
+	virtual void Unload() = 0;
+
+	/**
+	 * Returns true if loading of the native library failed.
+	 * @brief loadFailed
+	 */
+	virtual bool LoadFailed() = 0;
+
+	/**
 	 * @brief GetLibExtension
 	 * @return &quot;dll&quot;, &quot;dylib&quot; or &quot;so&quot; depending on OS
 	 */
@@ -61,6 +73,9 @@
 	virtual void *FindAddress(const char *symbol) = 0;
 
 	virtual ~SharedLib();
+
+protected:
+	static void reportError(const char* errorMsg, const char* fileName = &quot;???&quot;, int lineNumber = -1, const char* function = &quot;???&quot;);
 };
 
 #endif /* SHAREDLIB_H */

Modified: branches/caiinterface/rts/System/Platform/Win/DllLib.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Win/DllLib.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/Win/DllLib.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -21,9 +21,20 @@
 /**
  * Does a FreeLibrary on the given DLL
  */
+void DllLib::Unload() {
+	FreeLibrary(dll);
+}
+
+bool DllLib::LoadFailed() {
+	return dll == NULL;
+}
+
+/**
+ * Does a FreeLibrary on the given DLL
+ */
 DllLib::~DllLib()
 {
-	FreeLibrary(dll);
+	Unload();
 }
 
 /**

Modified: branches/caiinterface/rts/System/Platform/Win/DllLib.h
===================================================================
--- branches/caiinterface/rts/System/Platform/Win/DllLib.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/Win/DllLib.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -29,6 +29,14 @@
 	DllLib(const char *filename);
 	
 	/**
+	 * Does a FreeLibrary on the given DLL
+	 * @brief unload
+	 */
+	virtual void Unload();
+	
+	virtual bool LoadFailed();
+	
+	/**
 	 * @brief Destructor
 	 */
 	~DllLib();

Modified: branches/caiinterface/rts/System/Platform/Win/RegHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Win/RegHandler.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/Win/RegHandler.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -27,8 +27,8 @@
 
 int RegHandler::GetInt(string name, int def)
 {
-	unsigned char regbuf[100];
-	DWORD regLength=100; // this is windows specific stuff, so no need to use sdl types
+	unsigned char regbuf[100]={'\0'};
+	DWORD regLength=sizeof(regbuf); // this is windows specific stuff, so no need to use sdl types
 	DWORD regType=REG_DWORD;
 
 	if(RegQueryValueEx(regkey,name.c_str(),0,&amp;regType,regbuf,&amp;regLength)==ERROR_SUCCESS)
@@ -41,12 +41,13 @@
 
 string RegHandler::GetString(string name, string def)
 {
-	unsigned char regbuf[100];
-	DWORD regLength=100;
+	unsigned char regbuf[100]={'\0'};
+	DWORD regLength=sizeof(regbuf);
 	DWORD regType=REG_SZ;
 
-	if(RegQueryValueEx(regkey,name.c_str(),0,&amp;regType,regbuf,&amp;regLength)==ERROR_SUCCESS)
+	if(RegQueryValueEx(regkey,name.c_str(),0,&amp;regType,regbuf,&amp;regLength)==ERROR_SUCCESS) {
 		return string((char*)regbuf);
+	}
 	else
 		SetString(name, def);
 		

Modified: branches/caiinterface/rts/System/Platform/errorhandler.h
===================================================================
--- branches/caiinterface/rts/System/Platform/errorhandler.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Platform/errorhandler.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -15,7 +15,13 @@
 #define MBF_INFO	2
 #define MBF_EXCL	4
 
+#if __GNUC__ &gt;= 4
+	#define NO_RETURN __attribute__ ((noreturn))
+#else
+	#define NO_RETURN
+#endif
+
 #define handleerror(o, m, c, f) ErrorMessageBox(m, c, f)
-void ErrorMessageBox(const char *msg, const char *caption, unsigned int flags);
+void ErrorMessageBox(const char *msg, const char *caption, unsigned int flags) NO_RETURN;
 
 #endif

Modified: branches/caiinterface/rts/System/Script/LuaBinder.cpp
===================================================================
--- branches/caiinterface/rts/System/Script/LuaBinder.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Script/LuaBinder.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -296,7 +296,7 @@
 
         namespace_(&quot;AIs&quot;)
         [
-            def(&quot;CreateGlobalAI&quot;, &amp;luafunctions::CreateGlobalAI )
+            def(&quot;CreateSkirmishAI&quot;, &amp;luafunctions::CreateSkirmishAI )
         ],
 
 		namespace_(&quot;features&quot;)

Modified: branches/caiinterface/rts/System/Script/LuaFunctions.cpp
===================================================================
--- branches/caiinterface/rts/System/Script/LuaFunctions.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Script/LuaFunctions.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -42,9 +42,9 @@
 		eventHandler.GameOver();
 	}
 
-	void CreateGlobalAI( int teamnumber, std::string dllname )
+	void CreateSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey)
 	{
-			globalAI-&gt;CreateGlobalAI( teamnumber, dllname.c_str() );
+			globalAI-&gt;CreateSkirmishAI(teamId, skirmishAIKey);
 	}
 
 	void UnitGiveCommand(CObject_pointer&lt;CUnit&gt;* u, Command* c)

Modified: branches/caiinterface/rts/System/Script/LuaFunctions.h
===================================================================
--- branches/caiinterface/rts/System/Script/LuaFunctions.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/Script/LuaFunctions.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -11,6 +11,7 @@
 class CUnit;
 class CFeature;
 struct UnitDef;
+struct SSAIKey;
 
 // This class is meant to contain COBject and its descendants only..
 template&lt;class A&gt;
@@ -27,7 +28,7 @@
 
 namespace luafunctions
 {
-	void CreateGlobalAI( int teamnumber, std::string dllname);
+	void CreateSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey);
 	void EndGame();
 	void UnitGiveCommand(CObject_pointer&lt;CUnit&gt;* u, Command* c);
 	CObject_pointer&lt;CUnit&gt;* UnitGetTransporter(CObject_pointer&lt;CUnit&gt;* u);

Modified: branches/caiinterface/rts/System/SpringApp.cpp
===================================================================
--- branches/caiinterface/rts/System/SpringApp.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/SpringApp.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -24,6 +24,7 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
+#include &quot;ExternalAI/IAILibraryManager.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Rendering/GLContext.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
@@ -576,6 +577,7 @@
 	cmdline-&gt;addoption('c', &quot;client&quot;,         OPTPARM_NONE,   &quot;&quot;,  &quot;Run as a client&quot;);
 	cmdline-&gt;addoption('p', &quot;projectiledump&quot;, OPTPARM_NONE,   &quot;&quot;,  &quot;Dump projectile class info in projectiles.txt&quot;);
 	cmdline-&gt;addoption('t', &quot;textureatlas&quot;,   OPTPARM_NONE,   &quot;&quot;,  &quot;Dump each finalized textureatlas in textureatlasN.tga&quot;);
+	cmdline-&gt;addoption('a', &quot;list-skirmish-ais&quot;,   OPTPARM_NONE,   &quot;&quot;,  &quot;Dump a list of all available skirmish AIs&quot;);
 	cmdline-&gt;addoption('q', &quot;quit&quot;,           OPTPARM_INT,    &quot;T&quot;, &quot;Quit immediately on game over or after T seconds&quot;);
 	cmdline-&gt;addoption('n', &quot;name&quot;,           OPTPARM_STRING, &quot;&quot;,  &quot;Set your player name&quot;);
 	cmdline-&gt;addoption('C', &quot;config&quot;,         OPTPARM_STRING, &quot;&quot;,  &quot;Configuration file&quot;);
@@ -602,6 +604,9 @@
 	} else if (cmdline-&gt;result(&quot;projectiledump&quot;)) {
 		CCustomExplosionGenerator::OutputProjectileClassInfo();
 		exit(0);
+	} else if (cmdline-&gt;result(&quot;list-skirmish-ais&quot;)) {
+		IAILibraryManager::OutputSkirmishAIInfo();
+		exit(0);
 	}
 
 	// flags
@@ -700,7 +705,7 @@
 		{
 			string command(argv[i]);
 			int idx = command.rfind(&quot;sdf&quot;);
-			if (idx == command.size()-3) {
+			if (idx == (int)command.size()-3) {
 				demofile = command;
 				logOutput &lt;&lt; &quot;Using demofile &quot; &lt;&lt; demofile.c_str() &lt;&lt; &quot;\n&quot;;
 			} else if (command.rfind(&quot;ssf&quot;) == command.size()-3) {

Modified: branches/caiinterface/rts/System/StdAfx.h
===================================================================
--- branches/caiinterface/rts/System/StdAfx.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/StdAfx.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -1,6 +1,8 @@
 #ifndef __STD_AFX_H__
 #define __STD_AFX_H__
 
+#ifdef	__cplusplus
+
 #ifndef NOMINMAX
 #define NOMINMAX // avoid conflicts with std::min and std::max
 #endif
@@ -17,15 +19,21 @@
 	#if _MSC_VER &gt; 1310 // &gt;= Visual Studio 2005
 		#define SNPRINTF sprintf_s
 		#define VSNPRINTF vsprintf_s
+		#define STRCPY strcpy_s
+		#define FOPEN fopen_s
 	#else              // Visual Studio 2003
 		#define SNPRINTF _snprintf
 		#define VSNPRINTF _vsnprintf
+		#define STRCPY strcpy
+		#define FOPEN fopen
 	#endif
 	#define STRCASECMP stricmp
 #else
 	// assuming GCC
 	#define SNPRINTF snprintf
 	#define VSNPRINTF vsnprintf
+	#define STRCPY strcpy
+	#define FOPEN fopen
 	#define STRCASECMP strcasecmp
 #endif
 
@@ -72,6 +80,7 @@
 #include &lt;stdexcept&gt;
 #include &lt;string&gt;
 #include &lt;cctype&gt;
+#include &lt;cassert&gt;
 
 /**
  * content_error
@@ -106,5 +115,19 @@
 	return std::string(buf);
 }
 
+#endif	/* __cplusplus */
 
+static inline char* mallocCopyString(const char* const orig) {
+	
+	char* copy;
+	
+	copy = (char *) malloc(/*sizeof(char) * */strlen(orig) + 1);
+	STRCPY(copy, orig);
+	
+	return copy;
+}
+static inline void freeString(const char* const toFreeStr) {
+	free(const_cast&lt;char*&gt;(toFreeStr));
+}
+
 #endif // __STD_AFX_H__

Added: branches/caiinterface/rts/System/exportdefines.h
===================================================================
--- branches/caiinterface/rts/System/exportdefines.h	                        (rev 0)
+++ branches/caiinterface/rts/System/exportdefines.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -0,0 +1,74 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _EXPORTDEFINES_H
+#define	_EXPORTDEFINES_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif	/* __cplusplus */
+
+#define SPRING_CALLING_CONVENTION stdcall
+#define SPRING_CALLING_CONVENTION_2 __stdcall
+
+// extern declaration that will work across
+// different platforms and compilers
+#ifndef SHARED_EXPORT
+	#ifdef _WIN32
+		#define SHARED_EXPORT extern &quot;C&quot; __declspec(dllexport)
+		#define SPRING_API
+	#elif __GNUC__ &gt;= 4
+		// Support for '-fvisibility=hidden'.
+		#define SHARED_EXPORT extern &quot;C&quot; __attribute__ ((visibility(&quot;default&quot;)))
+		#define SPRING_API __attribute__ ((visibility(&quot;default&quot;)))
+	#else
+		// Older versions of gcc have everything visible; no need for fancy stuff.
+		#define SHARED_EXPORT extern &quot;C&quot;
+		#define SPRING_API
+	#endif
+#endif	/* SHARED_EXPORT */
+
+#ifndef DLL_EXPORT
+	#define DLL_EXPORT SHARED_EXPORT
+#endif	/* DLL_EXPORT */
+
+
+// calling convention declaration that will work across
+// different platforms and compilers
+//#ifdef __GNUC__
+//	#define __stdcall
+//#else
+#ifndef CALLING_CONV
+	#ifdef _WIN32
+		#define CALLING_CONV SPRING_CALLING_CONVENTION_2
+	#elif __GNUC__
+		#define CALLING_CONV __attribute__ ((SPRING_CALLING_CONVENTION))
+	#else
+		#define CALLING_CONV SPRING_CALLING_CONVENTION_2
+	#endif
+#endif	/* CALLING_CONV */
+
+
+#define Export(type) SHARED_EXPORT type CALLING_CONV
+
+
+#ifdef	__cplusplus
+}
+#endif	/* __cplusplus */
+
+#endif	/* _EXPORTDEFINES_H */
+


Property changes on: branches/caiinterface/rts/System/exportdefines.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/System/float3.h
===================================================================
--- branches/caiinterface/rts/System/float3.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/float3.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -10,7 +10,7 @@
 #include &quot;SFloat3.h&quot;
 #include &quot;lib/streflop/streflop_cond.h&quot;
 #include &quot;creg/creg.h&quot;
-#include &quot;ExternalAI/SAIFloat3.h&quot;
+#include &quot;ExternalAI/Interface/SAIFloat3.h&quot;
 
 /**
  * @brief float3 class

Modified: branches/caiinterface/rts/System/myMath.cpp
===================================================================
--- branches/caiinterface/rts/System/myMath.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/myMath.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -42,8 +42,11 @@
 
 		// release mode check
 		if (checksum != 0x617a9968)
-			handleerror(0, &quot;invalid headingToVectorTable checksum&quot;, &quot;Sync Error&quot;, 0);
-#endif
+			handleerror(0, &quot;Invalid headingToVectorTable checksum. Most likely&quot;
+					&quot; your streflop library was not compiled with the correct&quot;
+					&quot; options, or you are not using streflop at all.&quot;,
+					&quot;Sync Error&quot;, 0);
+#endif	/* STREFLOP_H */
 	}
 };
 

Modified: branches/caiinterface/rts/System/myMath.h
===================================================================
--- branches/caiinterface/rts/System/myMath.h	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/System/myMath.h	2008-10-01 18:03:35 UTC (rev 6494)
@@ -80,7 +80,11 @@
 	// If h goes beyond SHORTINT_MAXVALUE, the following
 	// conversion to a short int crashes.
 	//this change destroys the whole meaning with using short ints....
+	#if defined BUILDING_AI || defined BUILDING_AI_Interface
+	int iy = (int) (std::asin(vec.y) * (SHORTINT_MAXVALUE / PI));
+	#else
 	int iy = (int) (streflop::asin(vec.y) * (SHORTINT_MAXVALUE / PI));
+	#endif	/* defined BUILDING_AI || defined BUILDING_AI_Interface */
 	iy %= SHORTINT_MAXVALUE;
 	ret.y = (short int) iy;
 	ret.x = GetHeadingFromVector(vec.x, vec.z);

Modified: branches/caiinterface/rts/build/scons/config.py
===================================================================
--- branches/caiinterface/rts/build/scons/config.py	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/build/scons/config.py	2008-10-01 18:03:35 UTC (rev 6494)
@@ -272,6 +272,7 @@
 	print &quot;\nChecking headers and libraries&quot;
 
 	boost_common = Dependency([], ['boost/cstdint.hpp'])
+	boost_filesystem = Dependency(['boost_filesystem'], ['boost/filesystem.hpp'])
 	boost_thread = Dependency(['boost_thread'], ['boost/thread.hpp'])
 	boost_regex  = Dependency(['boost_regex'],   ['boost/regex.hpp'])
 	boost_serial = Dependency([], ['boost/serialization/split_member.hpp'])
@@ -279,12 +280,12 @@
 	if env.Dictionary('CC').find('gcc') != -1: gcc = True
 	else: gcc = False
 
-	for boost in (boost_thread, boost_regex):
+	for boost in (boost_filesystem, boost_thread, boost_regex):
 		l = boost.libraries[0]
 		if gcc: boost.libraries = [l+'-gcc-mt', l+'-mt', l+'-gcc', l]
 		else:   boost.libraries = [l+'-mt', l]
 
-	d = [boost_common, boost_regex, boost_serial, boost_thread]
+	d = [boost_common, boost_filesystem, boost_regex, boost_serial, boost_thread]
 
 	d += [Dependency(['GL', 'opengl32'], ['GL/gl.h'])]
 	d += [Dependency(['GLU', 'glu32'],   ['GL/glu.h'])]

Modified: branches/caiinterface/rts/build/scons/filelist.py
===================================================================
--- branches/caiinterface/rts/build/scons/filelist.py	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/build/scons/filelist.py	2008-10-01 18:03:35 UTC (rev 6494)
@@ -18,7 +18,7 @@
 	return newpath
 
 
-def list_directories(env, path, exclude_list = (), exclude_regexp = '^\.'):
+def list_directories(env, path, exclude_list = (), exclude_regexp = '^\.', recursively = True):
 	path_stack = [path]
 	#walk through dir tree
 	exclude = re.compile(exclude_regexp)
@@ -31,7 +31,8 @@
 			if os.path.exists(g) and not f in exclude_list and not exclude.search(f):
 				if os.path.isdir(g):
 					dirs += [g]
-					path_stack += [g]
+					if recursively:
+						path_stack += [g]
 	return dirs
 
 
@@ -90,6 +91,7 @@
 		'rts/System/Platform/BackgroundReader.cpp',
 		'rts/System/Platform/Mac', # Mac build uses XCode
 		'rts/System/Platform/Linux/DataDirLocater.cpp', # see SConstruct
+		'rts/ExternalAI/Interface/LegacyCppWrapper', # only needed by AI libraries using the legacy C++ interface to connect with spring
 	]
 	# we may be called before we were configured (e.g. when cleaning)
 	if env.has_key('platform'):
@@ -117,23 +119,104 @@
 
 
 def get_AI_source(env, path, which):
-	return get_source(env, os.path.join(path, which))
+	return get_source(env, os.path.join(path, which)) #+ get_source(env, 'rts/ExternalAI/Interface')
 
 
-def get_globalAI_source(env, which):
-	return get_AI_source(env, 'AI/Global', which)
+def get_AIInterface_source(env, which):
+	return get_AI_source(env, 'AI/Interfaces', which)
 
 
+def get_skirmishAI_source(env, which):
+	return get_AI_source(env, 'AI/Skirmish', which)
+
+
 def get_groupAI_source(env, which):
 	return get_AI_source(env, 'AI/Group', which)
 
 
-def get_shared_AI_source(env):
-	result = get_source(env, 'rts/System/creg')
+def get_shared_AI_source(env, needLuaParsing = False, needCreg = False):
+	result = []
 	if env.has_key('builddir') and env['builddir']:
-		result += [os.path.join(env['builddir'], 'rts/System/float3.cpp')]
+		if needLuaParsing:
+			result += [os.path.join(env['builddir'], 'rts/Lua/LuaParser.cpp')]
+			#result += [os.path.join(env['builddir'], 'rts/Lua/LuaSyncedRead.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/Lua/LuaIO.cpp')]
+			#result += [os.path.join(env['builddir'], 'rts/Lua/LuaHandle.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/Lua/LuaUtils.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/Map/MapParser.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/LogOutput.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/FileHandler.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/VFSHandler.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveScanner.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveFactory.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveBase.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveBuffered.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/Archive7Zip.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveZip.cpp')]
+			result += get_source(env, 'rts/lib/minizip')
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveDir.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/ArchiveHPI.cpp')]
+			result += get_source(env, 'rts/lib/hpiutil2')
+			needCreg = True
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/CRC.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/FileSystem/FileFilter.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/System/Platform/FileSystem.cpp')]
+			if env['platform'] == 'windows':
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Win/WinFileSystemHandler.cpp')]
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Win/DataDirLocater.cpp')]
+			else:
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Linux/UnixFileSystemHandler.cpp')]
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Linux/DataDirLocater.cpp')]
+			result += get_source(env, 'rts/lib/lua/src')
+			result += [os.path.join(env['builddir'], 'rts/System/Platform/ConfigHandler.cpp')]
+			if env['platform'] == 'windows':
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Win/RegHandler.cpp')]
+			else:
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Linux/DotfileHandler.cpp')]
+			result += get_source(env, 'rts/lib/7zip')
+
+		if needCreg:
+			result += get_source(env, 'rts/System/creg')
+		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SInfo.cpp')]
+		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SOption.cpp')]
+		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SGAILibrary.cpp')]
+		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SSAILibrary.cpp')]
+		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp')]
+		result += [os.path.join(env['builddir'], 'rts/Game/GameVersion.cpp')]
+		#result += [os.path.join(env['builddir'], 'rts/System/Platform/errorhandler.cpp')]
+		#result += [os.path.join(env['builddir'], 'rts/System/LogOutput.cpp')]
 	return result
 
+def get_shared_AIInterface_source(env, needSharedLib, needLuaParsing = False, needCreg = False):
+	result = get_shared_AI_source(env, needLuaParsing, needCreg)
+	if env.has_key('builddir') and env['builddir']:
+		result += [os.path.join(env['builddir'], 'rts/System/Platform/errorhandler.cpp')]
+		#if not needLuaParsing:
+			#result += [os.path.join(env['builddir'], 'rts/System/LogOutput.cpp')]
+		if needSharedLib:
+			result += [os.path.join(env['builddir'], 'rts/System/Platform/SharedLib.cpp')]
+			if env['platform'] == 'windows':
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Win/DllLib.cpp')]
+			else:
+				result += [os.path.join(env['builddir'], 'rts/System/Platform/Linux/SoLib.cpp')]
+	return result
+
+def get_shared_skirmishAI_source(env, isLegacyCPP, needLuaParsing = False, needCreg = False):
+	result = get_shared_AI_source(env, needLuaParsing, needCreg)
+	if env.has_key('builddir') and env['builddir']:
+		if isLegacyCPP:
+			result += [os.path.join(env['builddir'], 'rts/System/float3.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/LegacyCppWrapper/AISCommands.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/LegacyCppWrapper/AIAICheats.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAICallback.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/LegacyCppWrapper/AIGlobalAI.cpp')]
+			result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/LegacyCppWrapper/AI.cpp')]
+		#result += [os.path.join(env['builddir'], 'rts/System/Platform/errorhandler.cpp')]
+		#result += [os.path.join(env['builddir'], 'rts/System/LogOutput.cpp')]
+	return result
+
+
 def list_AIs(env, path, exclude_list = (), exclude_regexp = '^\.'):
 	exclude = re.compile(exclude_regexp)
 	files = os.listdir(path)
@@ -146,9 +229,13 @@
 	return result
 
 
-def list_globalAIs(env, exclude_list = (), exclude_regexp = '^\.'):
-	return list_AIs(env, 'AI/Global', exclude_list, exclude_regexp)
+def list_AIInterfaces(env, exclude_list = (), exclude_regexp = '^\.'):
+	return list_AIs(env, 'AI/Interfaces', exclude_list, exclude_regexp)
 
 
+def list_skirmishAIs(env, exclude_list = (), exclude_regexp = '^\.'):
+	return list_AIs(env, 'AI/Skirmish', exclude_list, exclude_regexp)
+
+
 def list_groupAIs(env, exclude_list = (), exclude_regexp = '^\.'):
 	return list_AIs(env, 'AI/Group', exclude_list, exclude_regexp)

Modified: branches/caiinterface/rts/build/scons/rts.py
===================================================================
--- branches/caiinterface/rts/build/scons/rts.py	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/build/scons/rts.py	2008-10-01 18:03:35 UTC (rev 6494)
@@ -236,8 +236,11 @@
 			env['debug'] = level
 			# MinGW gdb chokes on the dwarf debugging format produced by '-ggdb',
 			# so use the more generic '-g' instead.
+			# MinGW 4.2.1 gdb does not like the DWARF2 debug format generated by default,
+			# so produce STABS instead
 			if env['platform'] == 'windows' or env['syncdebug']:
-				env.AppendUnique(CCFLAGS=['-g'])
+				#env.AppendUnique(CCFLAGS=['-g'])
+				env.AppendUnique(CCFLAGS=['-gstabs'])
 			else:
 				env.AppendUnique(CCFLAGS=['-ggdb'+level])
 			# We can't enable -Wall because that silently enables an order of

Modified: branches/caiinterface/rts/lib/lua/src/lmathlib.cpp
===================================================================
--- branches/caiinterface/rts/lib/lua/src/lmathlib.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/lib/lua/src/lmathlib.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -8,11 +8,11 @@
 #include &lt;stdlib.h&gt;
 //SPRING#include &lt;math.h&gt;
 #include &quot;streflop_cond.h&quot; // FIXME -- should always be compiled with streflop
-#ifdef UNITSYNC
+#if defined UNITSYNC || defined BUILDING_AI || defined BUILDING_AI_INTERFACE
 using std::isfinite;
 using std::isnan;
 using std::isinf;
-#endif
+#endif	/* defined UNITSYNC || defined BUILDING_AI || defined BUILDING_AI_INTERFACE */
 
 #define lmathlib_c
 #define LUA_LIB

Modified: branches/caiinterface/rts/lib/lua/src/lvm.cpp
===================================================================
--- branches/caiinterface/rts/lib/lua/src/lvm.cpp	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/lib/lua/src/lvm.cpp	2008-10-01 18:03:35 UTC (rev 6494)
@@ -11,11 +11,11 @@
 
 //SPRING#include &lt;math.h&gt;
 #include &quot;streflop_cond.h&quot; // FIXME -- should always be compiled with streflop
-#ifdef UNITSYNC
+#if defined UNITSYNC || defined BUILDING_AI || defined BUILDING_AI_INTERFACE
 using std::isfinite;
 using std::isnan;
 using std::isinf;
-#endif
+#endif	/* defined UNITSYNC || defined BUILDING_AI || defined BUILDING_AI_INTERFACE */
 
 #define lvm_c
 #define LUA_CORE

Modified: branches/caiinterface/rts/lib/streflop/CMakeLists.txt
===================================================================
--- branches/caiinterface/rts/lib/streflop/CMakeLists.txt	2008-10-01 17:53:40 UTC (rev 6493)
+++ branches/caiinterface/rts/lib/streflop/CMakeLists.txt	2008-10-01 18:03:35 UTC (rev 6494)
@@ -6,7 +6,7 @@
 # th&lt;ts why it is set in cxxflags as a workaround
 #INCLUDE_DIRECTORIES(libm/headers)
 
-SET(cxxflags &quot;-w -O3 -I${CMAKE_CURRENT_SOURCE_DIR}/libm/headers&quot;)
+SET(cxxflags &quot;-w -O3 -DSTREFLOP_X87 -fsingle-precision-constant -fno-strict-aliasing -fsignaling-nans -frounding-math -mieee-fp -mfpmath=387 -I${CMAKE_CURRENT_SOURCE_DIR}/libm/headers&quot;)
 SET_SOURCE_FILES_PROPERTIES(${libm_flt32_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_FLT32 ${cxxflags}&quot;)
 SET_SOURCE_FILES_PROPERTIES(${libm_dbl64_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_DBL64 ${cxxflags}&quot;)
 SET_SOURCE_FILES_PROPERTIES(${libm_ldbl96_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_LDBL96 ${cxxflags}&quot;)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001263.html">[Taspring-linux-commit] r6493 - in branches/caiinterface/tools:	scripts unitsync
</A></li>
	<LI>Next message: <A HREF="001265.html">[Taspring-linux-commit] r6495 - in	branches/caiinterface/AI/Skirmish/RAI-0.553: CodeBlocks DevC
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1264">[ date ]</a>
              <a href="thread.html#1264">[ thread ]</a>
              <a href="subject.html#1264">[ subject ]</a>
              <a href="author.html#1264">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
