<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6499 - in trunk: AI/Global/AAI game/AI/AAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6499%20-%20in%20trunk%3A%20AI/Global/AAI%20game/AI/AAI&In-Reply-To=%3C20081002141611.2F6D74656%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001268.html">
   <LINK REL="Next"  HREF="001270.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6499 - in trunk: AI/Global/AAI game/AI/AAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6499%20-%20in%20trunk%3A%20AI/Global/AAI%20game/AI/AAI&In-Reply-To=%3C20081002141611.2F6D74656%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6499 - in trunk: AI/Global/AAI game/AI/AAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Oct  2 16:16:10 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001268.html">[Taspring-linux-commit] r6498 - trunk/rts/Map/SMF
</A></li>
        <LI>Next message: <A HREF="001270.html">[Taspring-linux-commit] r6500 - trunk/rts/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1269">[ date ]</a>
              <a href="thread.html#1269">[ thread ]</a>
              <a href="subject.html#1269">[ subject ]</a>
              <a href="author.html#1269">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: submarine
Date: 2008-10-02 16:16:09 +0200 (Thu, 02 Oct 2008)
New Revision: 6499

Modified:
   trunk/AI/Global/AAI/AAI ReadMe.txt
   trunk/AI/Global/AAI/AAI.cpp
   trunk/AI/Global/AAI/AAIBrain.cpp
   trunk/AI/Global/AAI/AAIBuildTable.cpp
   trunk/AI/Global/AAI/AAIBuildTable.h
   trunk/AI/Global/AAI/AAIConfig.cpp
   trunk/AI/Global/AAI/AAIConstructor.cpp
   trunk/AI/Global/AAI/AAIExecute.cpp
   trunk/AI/Global/AAI/AAIExecute.h
   trunk/AI/Global/AAI/AAIMap.cpp
   trunk/AI/Global/AAI/AAISector.cpp
   trunk/AI/Global/AAI/AAIUnitTable.cpp
   trunk/AI/Global/AAI/aidef.h
   trunk/game/AI/AAI/AAI ReadMe.txt
Log:
AAI v0.87

- Proper detection of amphibious ground units (was causing AAI to freeze on water maps)

- Prevent AAI from blocking buildqueues for combat units by requesting too many scouts

Modified: trunk/AI/Global/AAI/AAI ReadMe.txt
===================================================================
--- trunk/AI/Global/AAI/AAI ReadMe.txt	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAI ReadMe.txt	2008-10-02 14:16:09 UTC (rev 6499)
@@ -1,509 +1,512 @@
-Author: 	Alexander 'submarine' Seizinger		icq: 138100896		<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">alexander.seizinger at gmx.net</A>
-
-
-Installation: 	Windows users:
-
-		Simply extract the archive into your spring\ai\ folder and make sure, the following subfolders exist:
-		
-		\ai\aai			-&gt; readme, faq and different logs 
-		\ai\aai\cache		-&gt; map data (metal spots, water, etc)
-		\ai\aai\cfg\map		-&gt; map config files
-		\ai\aai\cfg\mod		-&gt; mod config files
-		\ai\aai\learn\map	-&gt; map learn files
-		\ai\aai\learn\mod	-&gt; mod learn files
-		\ai\aai\log		-&gt; log files 
-
-		\ai\bot-libs\aai.dll 	-&gt; main ai dll
-
-		If one of these folders does not exist, AAI will crash!
-
-		
-		Linux users: 
-
-		AAI will get the path of a writable directory from spring and load/save its files there
-		e.g.  /usr/local/games/taspring 
-
-		Apart from that the structure is the same as for windows users.
-
-
-
-		Please note, that there are hardly any buildtables included in this release. AAI should make better 
-		unit choices after a while. For further information, have a look at the AAI FAQ.
-
-		Furthermore I want to emphasize that there are quite some opportunities to change/improve AAI's way of
-		playing the game. Have a look at the cfg/help/mod.cfg for further information. If you think you created 
-		a cfg file which makes AAI play a certain much better than the default one mail it to me to include it 
-		in future releases.
-
-
-
-License:	Since AAI v0.70 all files have been released under the GPL
-
-
-
-Mod Support:	AAI must know the internal names of the starting units of the different sides (e.g. ARMCOM 
-		and CORCOM for most TA-mods). There are also some constants you may want to play with, so 
-		AAI tries to load the config from a file in the aai subfolder. The name must be the same as 
-		the modname, with &quot;.cfg&quot; extension (e.g. xta_se_v066.cfg for XTA mod). If you are not sure 
-		about the correct filename, just start a game running that mod. AAI will complain about 
-		missing cfg files and put the desired cfg filename in the log files.
-
-		See example.cfg for more information.
-		
-		By default, AAI has cfg files to support the following mods:
-		- XTA
-		- TA:WD 5.65
-		- AA 2.23 Standard
-		- AA 2.23 Forge
-		- Balanced AA
-		- OTA Shiny 5.5
-		- OTA Classic 5.5
-		- BoTA 1.3
-		- KuroTA 0.47
-		- Star Wars 1.0
-		- TLL 1.04
-		- FF 1.19		
-		- Gundam Annihilation 
-		- Expand &amp; Exterminate 0.163
-		- Spring 1944
-		- TA Battle Fleet
-
-
-		
-	!!!	Remember due to updates of these mods the filenames might change as well, so you have	!!!
-	!!!	to rename the mod.cfg file yourself							!!!
-
-
-
-
-Known bugs/	- AAI sometimes suffers from a bug in the pathfinding (units sometimes get stuck when close 
-Limitations:	  to buildings/objects)
-
-		- AAI does not use nukes, antinukes, emp missiles
-
-
-
-Thanks to: 	- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
-		  and coding contributions (since AAI v0.83) 
-
-		- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
-
-		- TA Spring devs for creating the best open source rts game I know
-
-		- Jelmer 'JC' Cnossen for some functions and a lot of helpful discussions
-
-		- Krogothe for his mex spot algorithm
-
-		- AccidUK for debugging and some coding suggestions
-
-		- Tournesol and Firenu for helping me getting debugging to work
-		
-		- All other testers who are not listed here
-		
-		- All other people who gave some feedback 
-
-		- Brandon Potter for his TBT 12 cfg file
-
-
-
-AAI v0.869	- Added proper handling of resurrected units (however AAI does not build resurrectors atm)
-		
-		- Fixed a bug that could prevent AAI from rebuilding destroyed factories	
-
-
-AAI v0.868	- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
-		  their turnrate is not too low)
-
-		- Added some new variables to mod config file:
-
-		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
-		  
-		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
-		 
-		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
-	
-  		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
-
-		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 
-		  naval units
-
-		- AAI now takes continents into account when sending scouts to positions (e.g. it does not try send ground scouts to 
-		  positions on other islands/continents anymore)
-
-		- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
-		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
-
-		- Fixed a bug that caused builders to leave the buildsite during construction 
-
-		- Fixed various freezes that have been caused by AAI flooding the ai interface with thousands of orders per frame
-
-
-		- Bumped mod learning file version to 0.86 due to some changes in handling of amphibious units
-
-
-AAI v0.86	- Added NON_AMPHIB_MAX_WATERDEPTH float (default is 15) statement to mod cfg file, specifies the max water depth 
-		  non amphibious ground units can cross
-
-		- Added detection of amphibious units 
-
-		- Added new continent detection system: AAI will divide the map into continents marking connected land(water)masses
-		  AAI will make a lot of use of this knowledge in future versions
-		  -&gt; map cache file version bumped to 0.86
-
-		- Improved base expansion on water maps (e.g. AAI should no longer expand into a small pond on Small Supreme Battlefield
-		  rather than the big ocean next to it) 
-
-		- Added COST_MULTIPLIER key word to mod cfg file, it allows to override the costs of a unit, e.g. 
-		  COST_MULTIPLIER armzeus 0.5 causes AAI to treat Arm Zeus as if it would cost half as much as it really does
-		  This feature has been requested by Argh to porperly deal with unit squads (building a single unit will 
-		  provide the player with several independent units)
-
-		- Fixed a stupid bug that prevented AAI from placing static defences according to terrain if map has already 
-		  been played before (bug in loading routine of map cache file)  
-
-
-AAI v0.85	- Added TRANSPORTERS keyword to mod cfg file, works like SCOUTS or ATTACKERS. Note that AAI does not use transporters
-		  yet, but it may be used in future times
-
-		- Redone scout selection, AAI may now use cloaked scouts, reduced GROUND/AIR/SEA/HOVER_SCOUT categories to one 
-		  SCOUT category 
-		
-		-&gt; Due to those changes buildtable version has been bumped to 0.85
-
-		- Fixed a bug that prevented AAI from building builders under certain conditions (S44 was suffering from that)
-
-		- AAI will remove sectors where it lost all its buildings from base (may add them again at any time later though)
-
-		- Completly redone defence building placement (AAI will now take terrain into account as well as already existing 
-		  defences) It should give much better results now especially on maps that dont have rather flat terrain
-		  
-		- AAI will take allied structures into account when looking for rally points for its combat units (helps to
-		  better prevent AAI from blocking allied bases with its units)
-
-		- Different instances of AAI now share several kind of map information (saves ram space) and do not expand to 
-		  sectors occupied by allied AAIs anymore
-
-		- Added DONT_BUILD keyword to mod cfg files, it works like SCOUTS or ATTACKERS, units listed after DONT_BUILD will 
-		  not be build by AAI in any case (and will not been taken into account for internal statistics)			
-
-		- Added ATTACKERS keyword to mod cfg file to force AAI to use specified units as combat units despite all other 
-		  capabilities of the unit (e.g. buildoptions)  (implemented by Yuritch)
-
-		- Resurrectors now may ressurect corpses instead of reclaiming them (however ressurectors chase newly resurrected 
-		  units trying to repair them - needs some work) (implemented by Yuritch)
-
-		- Improved mex and power plant building rules a bit
-
-		- AAI will upgrade the least effective metal extractors first (only important if a mod has more than two metal 
-		  extractors with different efficiencies)
-
-		- Fixed a few potential crash bugs
-
-
-AAI v0.80	- Improved/tweaked/fixed attack behaviour, AAI will try to withdraw when facing much stronger enemy forces
-
-		- Added attack behaviour for air only mods
-
-		- Added support for different reading/writing paths (only important for linux users)
-
-		- Completly redesigned factory/builder management to support mobile factories and other stuff in the future
-		  (EE hub system is NOT supported though)
-
-		- Extended mod learning about usage of different unit categories with respect to elapsed game time	
-
-		- Reduced unit categories: LAND/SEA/HOVER/AIR_BUILDER are now in the same category GROUND/SEA_FACTORY 
-		  are now in the same category (slight performace increase and nicer code)
-
-		- Improved mex spot selection (to prevent unnecessary long ways for builders), AAI will now also build better 
-		  extractors (e.g. moho mines) outside the base (according to safety)
-
-		- Improved placement of stationary defences and tweaked selection of them a bit
-
-		- Cleaned up buildtables, removed some old stuff, mod learning filesize decreased
-
-		- Decreased map-learning filesize by removing stationary artillery learning and some other unnecessary stuff
-		  (map-leraning version changed)
-
-		- AAI no longer crashes when one of its units get captured
-
-		- AAI now builds air bases/refuel pads (thx to yuritch for finding the bug)
-
-		- Fixed various issues/bugs that could cause stalling / prevent AAI from building further factories, builders 
-
-		- Fixed a few bugs that could cause erroneus behaviour on water maps as well as a submarine related bug
-	
-		- Fixed lots of crash bugs
-
-		- Fixed a possible memory leak in AAIBuildTable
-
-		- Increased mod learning file version 
-
-
-
-AAI v0.75	- Completly redone attack system: AAI will now attack more elaborately 
-		  (attackers move on if are cleared, bombers returning to base when target destroyed, attack groups now 
-		  retreat under several circumstances, combat groups are guarded by aa units - however it still tends 
-		  to send in streams of attackers - will be adressed in one of the next versions ) Please note that at the 
-		  moment the new attack system does not work with air only mods such as FF at all. AAI will build a base 
-		  as well as combat units and react to the actions of the player but it will not attack in a proper way
-		
-		- Added MAX_ATTACKS statement to mod.cfg which determines the max number of independent attack waves at
-		  the same time (set to 4 by default)
-
-		- Modified artillery sorting in preparation of artillery support in one of the next versions.
-		  Added GROUND_ARTY_RANGE, SEA_ARTY_RANGE and HOVER_ARTY_RANGE statement to mod cfg. These replace the
-		  former MOBILE_ARTY_RANGE statement (it's no longer valid, remove from old cfg files)
-
-		- For linux users: AAI will now store its files in the only writable datadirectory automatically (where 
-		  spring saves all its other files) 
-
-		- AAI now tries to get a safer rally point if combat units are killed en route 
-
-		- Builders now try to flee when attacked 
-
-		- AAI now takes allied buildings into account when expanding its base (to prevent AAI from building within
- 		  the base of someone else)	
-
-		- Improved AAI's building placement at the beginning of the game (buildings will not be spread out 
-		  that much anymore to reduce walking time of commander (thx to Accid_UK for the idea - should have been 
-		  already implemented in 0.70 but has somehow been commented out)   
-
-		- Tweaked economy/factory/defence building placement and selection
-
-		- Fixed a bug that prevented AAI from building naval power plants
-
-		- Fixed a bug which sometimes caused builders to leave their construction site
-
-		- Fixed a bug that caused AAI to temporarily run out of scouts when requesting several scouts it could 
-		  not build at that time 
-
-		- Fixed a bug that caused serious confusion concerning unit speeds (unfortunately mod learning file 
-		  version had to be changed)
-
-		- Fixed a very rare crashbug in the building placement algorithm
-
-		- Fixed a possible crash bug in the airforce handling (thx to Nicklas Marcusson for reporting it)
-
-
-
-AAI v0.70	- AAI now handles anti air/assault units, bombers and fighters with different groups 
-		  (requires a little bit of learning to work properly)
-
-		- Added new category SUBMARINE_ASSAULT to improve AAI's behaviour on water maps 
-
-		- Added MAX_ANTI_AIR_GROUP_SIZE, MAX_NAVAL_GROUP_SIZE, MAX_SUBMARINE_GROUP_SIZE 
-		  and MAX_ARTY_GROUP_SIZE (not in use yet) statement to mod cfg	
-
-		- Added FAST_UNITS_RATE and HIGH_RANGE_UNITS_RATE statements to mod.cfg
-
-		- Added different sub-groups for air only mods (light, medium, heavy &amp; super heavy air assault)
-
-		- Added a message being displayed from time to time when AAI has not been loaded succesfully
-
-		- Completly new combat unit selection (in theory, aai should react more dynamically to its 
-		  opponent's behaviour - requires some learning to work porperly)
-
-		- Improved/fixed building of stationary defences - only terporary, defence placement will be reworked 
-		  within the next versions (MIN_SECTOR_THREAT statement added to mod.cfg)
-
-		- Idle builders will now try to reclaim wreckages/features in/close to the base
-
-		- Improved unit detection a bit (some bogus weapons like mobile jammers in aa will not be considered 
-		  being combat units anymore, static mobile units (like dragons claw) will be filtered out as well)		 
-		
-		- Improved assistance management e.g. factories will now call assisters both based on buildque length 
-		  and buildtime of single units (thx to accid_uk for his suggestion)
-
-		- Added MIN_ASSISTANCE_BUILDSPEED statement to mod cfg
-
-		- AAI now takes the position of its base into account when placing stationary defences for 
-		  extractors outside of its base
-
-		- New power plant selection (fixed AAI not building pocket fusions in ff) 
-
-		- Fixed a spelling bug when reading cfg files (keyword had been MAX_ASSITANTS instead of MAX_ASSISTANTS)
-		  (thx to Acidd_UK for reporting this bug) 
-
-		- Fixed a bug that prevented AAI from upgrading metal extractors
-
-		- Fixed a bug that could cause AAI to freeze when builders get stuck
-
-		- Fixed scout spamming bug 
-
-		- Fixed possible buffer overflow when reading cfg files (thx to FizzWizz for reporting)
-
-		- Fixed a bug that crashed the game on small maps when MAX_MEX_DISTANCE was greater than 
-		  map size (e.g. small divide)
-
-		- Fixed a bug that prevented AAI from rebuilding killed builders
-
-
-AAI v0.63	- AAI now upgrades radars/jammers 
-	
-		- Added MIN_FACTORIES_FOR_RADAR_JAMMER statement to mod cfg
-
-		- Added support for Expand&amp;Exterminate
-
-		- Added support for mods with buildings as starting units (like AATA)
-
-		- Added mod cfg file for BoTA (thx to yuri)
-
-		- Tweaked defence building selection
-	
-		- AAI now prefers armed metal extractors when building far away from its main base
-
-		- Fixed some bugs in the BuildTable (buildtable version changed)
-
-		- Fixed a bug causing the buildmap not to be cleared when a building has been destroyed
-
-		- Fixed a bug concerning speed groups
-
-		- Fixed various crashbugs (big thank you to nicke for helping me finding them)
-
-
-AAI v0.60:	(AAI's folder structure changed as well as all cache/learning files - i heavily recommend deleting old 
-		 AAI versions before installing AAI 0.60)
-	
-		- Experimental water map support, view FAQ for more details
-
-		- Changed buildtable: Hover crafts got their own category (no longer part of ground units) and several
-		  code cleanups to optimize speed
-
-		- AAI remembers which usefulness of different assault categories and orders further combat units based on 
-		  that (i hope this will especially help adjusting the amount of land, hover and sea units aai uses on a 
-		  mixed land/water map) 
-	
-		- Added support for stationary artillery (e.g. berthas) (added MAX_STAT_ARTY statement to mod cfg)
-
-		- Added support for air repair pads (added MAX_AIR_BASE statement to mod cfg)
-		  edit: seems to be broken somehow 
-
-		- Added support for several factories of the same type (added MAX_FACTORIES_PER_TYPE statement to mod cfg)
-
-		- AAI now defends extractors outside its base up to a certain max dinstace with cheap defence buildings
-		  (added MAX_MEX_DEFENCE_DISTANCE statement to mod cfg)		
-
-		- Builder selection improved, AAI now uses closest idle builder
-
-		- AAI now sorts combat units into groups according to their max speed 
-		  (added UNITS_SPEED_SUBGROUPS statement to mod cfg)
-
-		- Improved Air Force handling (added MAX_AIR_GROUP_SIZE, MIN_AIR_SUPPORT_EFFICIENCY statement to mod cfg)
-			
-		- Improved/Fixed several mod cfg files
-
-		- Improved ressource management/AAI will now upgrade extractors to better ones
-
-		- Improved defence building selection
-
-		- Fixed a bug that crashed game right at the start on certain maps (eg. Battle Holmes)
-		  (thx to HiEnergy for reporting this bug)
-
-		- Fixed a few crashbugs
-
-		- Fixed various smaller issues/bugs
-
-		- Extended memory sharing between multiple instances of AAI and fixed a shared memory related crashbug
-		
-
-AAI v0.55:	- AAI is now compatible with the modified ai interface of spring 0.70	
-	
-		- Extended map learning files/every mod now creates own map learing files
-
-		- AAI tries not to send builders in setors which turned out to be too dangerous
-
-		- Fixed a rounding related crashbug
-
-		- Fixed a bug causing AAI to stop constructing new buidlings
-
-		- Fixed a bug causing AAI to build rows of sensor towers in SW:TA			
-
-		- Fixed several bugs in the energy management causing aai not to build any further power plants
-
-
-AAI v0.50:	- Completly new ressource management system (will be further improved in future versions)
-
-		- Buildtable will now be shared by all instances of AAI (this mainly reduces aai's memory usage as well as 
-		  a slight increase in loading time when running more than one aai-player at the same time) 
-
-		- Improved factory/builder request system/modified buildtable, to be able to add support for AATA	
-
-		- Improved radar/jammer placement
-
-		- AAI now builds metal makers and storage buidlings
-	
-		- Added support for metal maps 
-
-		- Added support for air units only mods (e.g. Final Frontier)
-
-		- Added a general.cfg holding information that is used for all mods (e.g. allowing users to adjust how much
-		  cpu-power AAI takes for scouting)
-		
-		- Fixed a bug when AAI stopped building after completing a few buildings
-
-		- Fixed a bug that crashed AAI right at the beginning on certain maps (especially metal maps)
-		  (thx to IMSabbel for reporting this bug)
-
-		- Fixed a few crashbugs
-
-		- Added mod support: Final Frontier, Gundam Annihilation
-	  
-
-AAI v0.40:	- Scouting redone
- 
-		- Construction units now assist other builders/factories when needed
-
-		- Added support for mods with more than two sides -&gt; cfg files changed, replace with new ones
-		
-		- Improved building placement (AAI now prevents &quot;diagonal rows&quot;), fixed a building placement 
-		  related crashbug as well
-
-		- AAI now uses radar
-
-		- AAI now uses air units
-
-		- Hopefully fixed a bug concerning blocked buildsites
-
-
-AAI v0.30: 	- AAI now builds defence buildings (will be extended later on)
-
-		- Improved expansion
-	
-		- All learning/cache files now contain an internal version to provide better compatibility in the future. 
-		  if there will be any changes in the future newer file versions will be created automatically
-
-		- Fixed various bugs, AAI should be running much more stable now
-
-		- Switched to krogothe's mex spot algorithm
-
-
-AAI v0.20: 	- First released version
-
-		- Completely rewritten metal/energy management -&gt; still not working very good
-
-		- Improved selection of more expensive units (prevents AAI from building level 2 
-		  units too early (in most cases...))
-
-		- A certain amount of units will be build to counter air units
-
-		- Various minor fixes and code improvements
-
-
-AAI v0.10: 	(internal version)
-
-		- Works with different mods (see config file section for more information)
-		
-		- AI builds a little base 
-
-		- AI builds all kinds of units and tries to attack enemy bases
-
-		- AI learns about important locations in a map on its own 
-		  (and saves results in a learning-file)
-
-
-
-
-
-
-
-
+Author: 	Alexander 'submarine' Seizinger		icq: 138100896		<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">alexander.seizinger at gmx.net</A>
+
+
+Installation: 	Windows users:
+
+		Simply extract the archive into your spring\ai\ folder and make sure, the following subfolders exist:
+		
+		\ai\aai			-&gt; readme, faq and different logs 
+		\ai\aai\cache		-&gt; map data (metal spots, water, etc)
+		\ai\aai\cfg\map		-&gt; map config files
+		\ai\aai\cfg\mod		-&gt; mod config files
+		\ai\aai\learn\map	-&gt; map learn files
+		\ai\aai\learn\mod	-&gt; mod learn files
+		\ai\aai\log		-&gt; log files 
+
+		\ai\bot-libs\aai.dll 	-&gt; main ai dll
+
+		If one of these folders does not exist, AAI will crash!
+
+		
+		Linux users: 
+
+		AAI will get the path of a writable directory from spring and load/save its files there
+		e.g.  /usr/local/games/taspring 
+
+		Apart from that the structure is the same as for windows users.
+
+
+
+		Please note, that there are hardly any buildtables included in this release. AAI should make better 
+		unit choices after a while. For further information, have a look at the AAI FAQ.
+
+		Furthermore I want to emphasize that there are quite some opportunities to change/improve AAI's way of
+		playing the game. Have a look at the cfg/help/mod.cfg for further information. If you think you created 
+		a cfg file which makes AAI play a certain much better than the default one mail it to me to include it 
+		in future releases.
+
+
+
+License:	Since AAI v0.70 all files have been released under the GPL
+
+
+
+Mod Support:	AAI must know the internal names of the starting units of the different sides (e.g. ARMCOM 
+		and CORCOM for most TA-mods). There are also some constants you may want to play with, so 
+		AAI tries to load the config from a file in the aai subfolder. The name must be the same as 
+		the modname, with &quot;.cfg&quot; extension (e.g. xta_se_v066.cfg for XTA mod). If you are not sure 
+		about the correct filename, just start a game running that mod. AAI will complain about 
+		missing cfg files and put the desired cfg filename in the log files.
+
+		See example.cfg for more information.
+		
+		By default, AAI has cfg files to support the following mods:
+		- XTA
+		- TA:WD 5.65
+		- AA 2.23 Standard
+		- AA 2.23 Forge
+		- Balanced AA
+		- OTA Shiny 5.5
+		- OTA Classic 5.5
+		- BoTA 1.3
+		- KuroTA 0.47
+		- Star Wars 1.0
+		- TLL 1.04
+		- FF 1.19		
+		- Gundam Annihilation 
+		- Expand &amp; Exterminate 0.163
+		- Spring 1944
+		- TA Battle Fleet
+
+
+		
+	!!!	Remember due to updates of these mods the filenames might change as well, so you have	!!!
+	!!!	to rename the mod.cfg file yourself							!!!
+
+
+
+
+Known bugs/	- AAI sometimes suffers from a bug in the pathfinding (units sometimes get stuck when close 
+Limitations:	  to buildings/objects)
+
+		- AAI does not use nukes, antinukes, emp missiles
+
+
+
+Thanks to: 	- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
+		  and coding contributions (since AAI v0.83) 
+
+		- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
+
+		- TA Spring devs for creating the best open source rts game I know
+
+		- Jelmer 'JC' Cnossen for some functions and a lot of helpful discussions
+
+		- Krogothe for his mex spot algorithm
+
+		- AccidUK for debugging and some coding suggestions
+
+		- Tournesol and Firenu for helping me getting debugging to work
+		
+		- All other testers who are not listed here
+		
+		- All other people who gave some feedback 
+
+		- Brandon Potter for his TBT 12 cfg file
+
+
+AAI v0.87	- Proper detection of amphibious ground units (was causing AAI to freeze on water maps)
+
+		- Prevent AAI from blocking buildqueues for combat units by requesting too many scouts
+
+
+AAI v0.869	- Added proper handling of resurrected units (however AAI does not build resurrectors atm)
+		
+		- Fixed a bug that could prevent AAI from rebuilding destroyed factories	
+
+		- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
+		  their turnrate is not too low)
+
+		- Added some new variables to mod config file:
+
+		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
+		  
+		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
+		 
+		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
+	
+  		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
+
+		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 
+		  naval units
+
+		- AAI now takes continents into account when sending scouts to positions (e.g. it does not try send ground scouts to 
+		  positions on other islands/continents anymore)
+
+		- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
+		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
+
+		- Fixed a bug that caused builders to leave the buildsite during construction 
+
+		- Fixed various freezes that have been caused by AAI flooding the ai interface with thousands of orders per frame
+
+
+		- Bumped mod learning file version to 0.86 due to some changes in handling of amphibious units
+
+
+AAI v0.86	- Added NON_AMPHIB_MAX_WATERDEPTH float (default is 15) statement to mod cfg file, specifies the max water depth 
+		  non amphibious ground units can cross
+
+		- Added detection of amphibious units 
+
+		- Added new continent detection system: AAI will divide the map into continents marking connected land(water)masses
+		  AAI will make a lot of use of this knowledge in future versions
+		  -&gt; map cache file version bumped to 0.86
+
+		- Improved base expansion on water maps (e.g. AAI should no longer expand into a small pond on Small Supreme Battlefield
+		  rather than the big ocean next to it) 
+
+		- Added COST_MULTIPLIER key word to mod cfg file, it allows to override the costs of a unit, e.g. 
+		  COST_MULTIPLIER armzeus 0.5 causes AAI to treat Arm Zeus as if it would cost half as much as it really does
+		  This feature has been requested by Argh to porperly deal with unit squads (building a single unit will 
+		  provide the player with several independent units)
+
+		- Fixed a stupid bug that prevented AAI from placing static defences according to terrain if map has already 
+		  been played before (bug in loading routine of map cache file)  
+
+
+AAI v0.85	- Added TRANSPORTERS keyword to mod cfg file, works like SCOUTS or ATTACKERS. Note that AAI does not use transporters
+		  yet, but it may be used in future times
+
+		- Redone scout selection, AAI may now use cloaked scouts, reduced GROUND/AIR/SEA/HOVER_SCOUT categories to one 
+		  SCOUT category 
+		
+		-&gt; Due to those changes buildtable version has been bumped to 0.85
+
+		- Fixed a bug that prevented AAI from building builders under certain conditions (S44 was suffering from that)
+
+		- AAI will remove sectors where it lost all its buildings from base (may add them again at any time later though)
+
+		- Completly redone defence building placement (AAI will now take terrain into account as well as already existing 
+		  defences) It should give much better results now especially on maps that dont have rather flat terrain
+		  
+		- AAI will take allied structures into account when looking for rally points for its combat units (helps to
+		  better prevent AAI from blocking allied bases with its units)
+
+		- Different instances of AAI now share several kind of map information (saves ram space) and do not expand to 
+		  sectors occupied by allied AAIs anymore
+
+		- Added DONT_BUILD keyword to mod cfg files, it works like SCOUTS or ATTACKERS, units listed after DONT_BUILD will 
+		  not be build by AAI in any case (and will not been taken into account for internal statistics)			
+
+		- Added ATTACKERS keyword to mod cfg file to force AAI to use specified units as combat units despite all other 
+		  capabilities of the unit (e.g. buildoptions)  (implemented by Yuritch)
+
+		- Resurrectors now may ressurect corpses instead of reclaiming them (however ressurectors chase newly resurrected 
+		  units trying to repair them - needs some work) (implemented by Yuritch)
+
+		- Improved mex and power plant building rules a bit
+
+		- AAI will upgrade the least effective metal extractors first (only important if a mod has more than two metal 
+		  extractors with different efficiencies)
+
+		- Fixed a few potential crash bugs
+
+
+AAI v0.80	- Improved/tweaked/fixed attack behaviour, AAI will try to withdraw when facing much stronger enemy forces
+
+		- Added attack behaviour for air only mods
+
+		- Added support for different reading/writing paths (only important for linux users)
+
+		- Completly redesigned factory/builder management to support mobile factories and other stuff in the future
+		  (EE hub system is NOT supported though)
+
+		- Extended mod learning about usage of different unit categories with respect to elapsed game time	
+
+		- Reduced unit categories: LAND/SEA/HOVER/AIR_BUILDER are now in the same category GROUND/SEA_FACTORY 
+		  are now in the same category (slight performace increase and nicer code)
+
+		- Improved mex spot selection (to prevent unnecessary long ways for builders), AAI will now also build better 
+		  extractors (e.g. moho mines) outside the base (according to safety)
+
+		- Improved placement of stationary defences and tweaked selection of them a bit
+
+		- Cleaned up buildtables, removed some old stuff, mod learning filesize decreased
+
+		- Decreased map-learning filesize by removing stationary artillery learning and some other unnecessary stuff
+		  (map-leraning version changed)
+
+		- AAI no longer crashes when one of its units get captured
+
+		- AAI now builds air bases/refuel pads (thx to yuritch for finding the bug)
+
+		- Fixed various issues/bugs that could cause stalling / prevent AAI from building further factories, builders 
+
+		- Fixed a few bugs that could cause erroneus behaviour on water maps as well as a submarine related bug
+	
+		- Fixed lots of crash bugs
+
+		- Fixed a possible memory leak in AAIBuildTable
+
+		- Increased mod learning file version 
+
+
+
+AAI v0.75	- Completly redone attack system: AAI will now attack more elaborately 
+		  (attackers move on if are cleared, bombers returning to base when target destroyed, attack groups now 
+		  retreat under several circumstances, combat groups are guarded by aa units - however it still tends 
+		  to send in streams of attackers - will be adressed in one of the next versions ) Please note that at the 
+		  moment the new attack system does not work with air only mods such as FF at all. AAI will build a base 
+		  as well as combat units and react to the actions of the player but it will not attack in a proper way
+		
+		- Added MAX_ATTACKS statement to mod.cfg which determines the max number of independent attack waves at
+		  the same time (set to 4 by default)
+
+		- Modified artillery sorting in preparation of artillery support in one of the next versions.
+		  Added GROUND_ARTY_RANGE, SEA_ARTY_RANGE and HOVER_ARTY_RANGE statement to mod cfg. These replace the
+		  former MOBILE_ARTY_RANGE statement (it's no longer valid, remove from old cfg files)
+
+		- For linux users: AAI will now store its files in the only writable datadirectory automatically (where 
+		  spring saves all its other files) 
+
+		- AAI now tries to get a safer rally point if combat units are killed en route 
+
+		- Builders now try to flee when attacked 
+
+		- AAI now takes allied buildings into account when expanding its base (to prevent AAI from building within
+ 		  the base of someone else)	
+
+		- Improved AAI's building placement at the beginning of the game (buildings will not be spread out 
+		  that much anymore to reduce walking time of commander (thx to Accid_UK for the idea - should have been 
+		  already implemented in 0.70 but has somehow been commented out)   
+
+		- Tweaked economy/factory/defence building placement and selection
+
+		- Fixed a bug that prevented AAI from building naval power plants
+
+		- Fixed a bug which sometimes caused builders to leave their construction site
+
+		- Fixed a bug that caused AAI to temporarily run out of scouts when requesting several scouts it could 
+		  not build at that time 
+
+		- Fixed a bug that caused serious confusion concerning unit speeds (unfortunately mod learning file 
+		  version had to be changed)
+
+		- Fixed a very rare crashbug in the building placement algorithm
+
+		- Fixed a possible crash bug in the airforce handling (thx to Nicklas Marcusson for reporting it)
+
+
+
+AAI v0.70	- AAI now handles anti air/assault units, bombers and fighters with different groups 
+		  (requires a little bit of learning to work properly)
+
+		- Added new category SUBMARINE_ASSAULT to improve AAI's behaviour on water maps 
+
+		- Added MAX_ANTI_AIR_GROUP_SIZE, MAX_NAVAL_GROUP_SIZE, MAX_SUBMARINE_GROUP_SIZE 
+		  and MAX_ARTY_GROUP_SIZE (not in use yet) statement to mod cfg	
+
+		- Added FAST_UNITS_RATE and HIGH_RANGE_UNITS_RATE statements to mod.cfg
+
+		- Added different sub-groups for air only mods (light, medium, heavy &amp; super heavy air assault)
+
+		- Added a message being displayed from time to time when AAI has not been loaded succesfully
+
+		- Completly new combat unit selection (in theory, aai should react more dynamically to its 
+		  opponent's behaviour - requires some learning to work porperly)
+
+		- Improved/fixed building of stationary defences - only terporary, defence placement will be reworked 
+		  within the next versions (MIN_SECTOR_THREAT statement added to mod.cfg)
+
+		- Idle builders will now try to reclaim wreckages/features in/close to the base
+
+		- Improved unit detection a bit (some bogus weapons like mobile jammers in aa will not be considered 
+		  being combat units anymore, static mobile units (like dragons claw) will be filtered out as well)		 
+		
+		- Improved assistance management e.g. factories will now call assisters both based on buildque length 
+		  and buildtime of single units (thx to accid_uk for his suggestion)
+
+		- Added MIN_ASSISTANCE_BUILDSPEED statement to mod cfg
+
+		- AAI now takes the position of its base into account when placing stationary defences for 
+		  extractors outside of its base
+
+		- New power plant selection (fixed AAI not building pocket fusions in ff) 
+
+		- Fixed a spelling bug when reading cfg files (keyword had been MAX_ASSITANTS instead of MAX_ASSISTANTS)
+		  (thx to Acidd_UK for reporting this bug) 
+
+		- Fixed a bug that prevented AAI from upgrading metal extractors
+
+		- Fixed a bug that could cause AAI to freeze when builders get stuck
+
+		- Fixed scout spamming bug 
+
+		- Fixed possible buffer overflow when reading cfg files (thx to FizzWizz for reporting)
+
+		- Fixed a bug that crashed the game on small maps when MAX_MEX_DISTANCE was greater than 
+		  map size (e.g. small divide)
+
+		- Fixed a bug that prevented AAI from rebuilding killed builders
+
+
+AAI v0.63	- AAI now upgrades radars/jammers 
+	
+		- Added MIN_FACTORIES_FOR_RADAR_JAMMER statement to mod cfg
+
+		- Added support for Expand&amp;Exterminate
+
+		- Added support for mods with buildings as starting units (like AATA)
+
+		- Added mod cfg file for BoTA (thx to yuri)
+
+		- Tweaked defence building selection
+	
+		- AAI now prefers armed metal extractors when building far away from its main base
+
+		- Fixed some bugs in the BuildTable (buildtable version changed)
+
+		- Fixed a bug causing the buildmap not to be cleared when a building has been destroyed
+
+		- Fixed a bug concerning speed groups
+
+		- Fixed various crashbugs (big thank you to nicke for helping me finding them)
+
+
+AAI v0.60:	(AAI's folder structure changed as well as all cache/learning files - i heavily recommend deleting old 
+		 AAI versions before installing AAI 0.60)
+	
+		- Experimental water map support, view FAQ for more details
+
+		- Changed buildtable: Hover crafts got their own category (no longer part of ground units) and several
+		  code cleanups to optimize speed
+
+		- AAI remembers which usefulness of different assault categories and orders further combat units based on 
+		  that (i hope this will especially help adjusting the amount of land, hover and sea units aai uses on a 
+		  mixed land/water map) 
+	
+		- Added support for stationary artillery (e.g. berthas) (added MAX_STAT_ARTY statement to mod cfg)
+
+		- Added support for air repair pads (added MAX_AIR_BASE statement to mod cfg)
+		  edit: seems to be broken somehow 
+
+		- Added support for several factories of the same type (added MAX_FACTORIES_PER_TYPE statement to mod cfg)
+
+		- AAI now defends extractors outside its base up to a certain max dinstace with cheap defence buildings
+		  (added MAX_MEX_DEFENCE_DISTANCE statement to mod cfg)		
+
+		- Builder selection improved, AAI now uses closest idle builder
+
+		- AAI now sorts combat units into groups according to their max speed 
+		  (added UNITS_SPEED_SUBGROUPS statement to mod cfg)
+
+		- Improved Air Force handling (added MAX_AIR_GROUP_SIZE, MIN_AIR_SUPPORT_EFFICIENCY statement to mod cfg)
+			
+		- Improved/Fixed several mod cfg files
+
+		- Improved ressource management/AAI will now upgrade extractors to better ones
+
+		- Improved defence building selection
+
+		- Fixed a bug that crashed game right at the start on certain maps (eg. Battle Holmes)
+		  (thx to HiEnergy for reporting this bug)
+
+		- Fixed a few crashbugs
+
+		- Fixed various smaller issues/bugs
+
+		- Extended memory sharing between multiple instances of AAI and fixed a shared memory related crashbug
+		
+
+AAI v0.55:	- AAI is now compatible with the modified ai interface of spring 0.70	
+	
+		- Extended map learning files/every mod now creates own map learing files
+
+		- AAI tries not to send builders in setors which turned out to be too dangerous
+
+		- Fixed a rounding related crashbug
+
+		- Fixed a bug causing AAI to stop constructing new buidlings
+
+		- Fixed a bug causing AAI to build rows of sensor towers in SW:TA			
+
+		- Fixed several bugs in the energy management causing aai not to build any further power plants
+
+
+AAI v0.50:	- Completly new ressource management system (will be further improved in future versions)
+
+		- Buildtable will now be shared by all instances of AAI (this mainly reduces aai's memory usage as well as 
+		  a slight increase in loading time when running more than one aai-player at the same time) 
+
+		- Improved factory/builder request system/modified buildtable, to be able to add support for AATA	
+
+		- Improved radar/jammer placement
+
+		- AAI now builds metal makers and storage buidlings
+	
+		- Added support for metal maps 
+
+		- Added support for air units only mods (e.g. Final Frontier)
+
+		- Added a general.cfg holding information that is used for all mods (e.g. allowing users to adjust how much
+		  cpu-power AAI takes for scouting)
+		
+		- Fixed a bug when AAI stopped building after completing a few buildings
+
+		- Fixed a bug that crashed AAI right at the beginning on certain maps (especially metal maps)
+		  (thx to IMSabbel for reporting this bug)
+
+		- Fixed a few crashbugs
+
+		- Added mod support: Final Frontier, Gundam Annihilation
+	  
+
+AAI v0.40:	- Scouting redone
+ 
+		- Construction units now assist other builders/factories when needed
+
+		- Added support for mods with more than two sides -&gt; cfg files changed, replace with new ones
+		
+		- Improved building placement (AAI now prevents &quot;diagonal rows&quot;), fixed a building placement 
+		  related crashbug as well
+
+		- AAI now uses radar
+
+		- AAI now uses air units
+
+		- Hopefully fixed a bug concerning blocked buildsites
+
+
+AAI v0.30: 	- AAI now builds defence buildings (will be extended later on)
+
+		- Improved expansion
+	
+		- All learning/cache files now contain an internal version to provide better compatibility in the future. 
+		  if there will be any changes in the future newer file versions will be created automatically
+
+		- Fixed various bugs, AAI should be running much more stable now
+
+		- Switched to krogothe's mex spot algorithm
+
+
+AAI v0.20: 	- First released version
+
+		- Completely rewritten metal/energy management -&gt; still not working very good
+
+		- Improved selection of more expensive units (prevents AAI from building level 2 
+		  units too early (in most cases...))
+
+		- A certain amount of units will be build to counter air units
+
+		- Various minor fixes and code improvements
+
+
+AAI v0.10: 	(internal version)
+
+		- Works with different mods (see config file section for more information)
+		
+		- AI builds a little base 
+
+		- AI builds all kinds of units and tries to attack enemy bases
+
+		- AI learns about important locations in a map on its own 
+		  (and saves results in a learning-file)
+
+
+
+
+
+
+
+

Modified: trunk/AI/Global/AAI/AAI.cpp
===================================================================
--- trunk/AI/Global/AAI/AAI.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAI.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -51,7 +51,7 @@
 	// save several ai data
 	fprintf(file, &quot;\nShutting down....\n\n&quot;);
 	fprintf(file, &quot;Unit category	active / under construction\n&quot;);
-	for(int i = 0; i &lt;= MOBILE_CONSTRUCTOR; i++)
+	for(int i = 0; i &lt;= MOBILE_CONSTRUCTOR; ++i)
 	{
 		fprintf(file, &quot;%-20s: %i / %i\n&quot;, bt-&gt;GetCategoryString2((UnitCategory)i), activeUnits[i], futureUnits[i]); 
 	}
@@ -60,13 +60,20 @@
 	fprintf(file, &quot;\nAir Groups:       %i\n&quot;, group_list[AIR_ASSAULT].size());
 	fprintf(file, &quot;\nHover Groups:     %i\n&quot;, group_list[HOVER_ASSAULT].size());
 	fprintf(file, &quot;\nSea Groups:       %i\n&quot;, group_list[SEA_ASSAULT].size());
-	fprintf(file, &quot;\nSubmarine Groups: %i\n&quot;, group_list[SUBMARINE_ASSAULT].size());
+	fprintf(file, &quot;\nSubmarine Groups: %i\n\n&quot;, group_list[SUBMARINE_ASSAULT].size());
 	
-	fprintf(file, &quot;\nFuture metal/energy request: %i / %i\n&quot;, (int)execute-&gt;futureRequestedMetal, (int)execute-&gt;futureRequestedEnergy);
-	fprintf(file, &quot;Future metal/energy supply:  %i / %i\n&quot;, (int)execute-&gt;futureAvailableMetal, (int)execute-&gt;futureAvailableEnergy);
+	fprintf(file, &quot;Future metal/energy request: %i / %i\n&quot;, (int)execute-&gt;futureRequestedMetal, (int)execute-&gt;futureRequestedEnergy);
+	fprintf(file, &quot;Future metal/energy supply:    %i / %i\n\n&quot;, (int)execute-&gt;futureAvailableMetal, (int)execute-&gt;futureAvailableEnergy);
 
-	fprintf(file, &quot;\nFuture/active scouts: %i / %i\n&quot;, futureScouts, activeScouts);
+	fprintf(file, &quot;Future/active scouts:      %i / %i\n&quot;, futureScouts, activeScouts);
+	fprintf(file, &quot;Future/active builders:    %i / %i\n&quot;, futureBuilders, activeBuilders);
+	fprintf(file, &quot;Future/active factories:   %i / %i\n\n&quot;, futureFactories, activeFactories);
 
+	fprintf(file, &quot;Factory ratings:\n&quot;);
+	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].begin(); fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].end(); ++fac)
+		fprintf(file, &quot;%-20s: %f\n&quot;, bt-&gt;unitList[*fac-1]-&gt;humanName.c_str(), bt-&gt;GetFactoryRating(*fac));
+		
+
 	// delete buildtasks
 	for(list&lt;AAIBuildTask*&gt;::iterator task = build_tasks.begin(); task != build_tasks.end(); task++)
 	{
@@ -277,6 +284,7 @@
 	{
 		// UnitFinished() will decrease it later -&gt; prevents AAI from having -1 future commanders 
 		requestedUnits[COMMANDER] += 1;
+		futureBuilders += 1;
 		bt-&gt;units_dynamic[def-&gt;id].under_construction += 1;
 
 		execute-&gt;InitAI(unit, def);
@@ -514,7 +522,7 @@
 				--futureBuilders;
 
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
-					--bt-&gt;units_dynamic[*unit].buildersRequested;
+					--bt-&gt;units_dynamic[*unit].constructorsRequested;
 			}
 			else if(bt-&gt;IsFactory(def-&gt;id))
 			{
@@ -522,7 +530,7 @@
 					--futureFactories;
 	
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
-					--bt-&gt;units_dynamic[*unit].buildersRequested;
+					--bt-&gt;units_dynamic[*unit].constructorsRequested;
 			}
 		}
 	}
@@ -852,7 +860,7 @@
 	// unit management 
 	if(!(tick%649))
 	{
-		execute-&gt;CheckBuildques();
+		execute-&gt;CheckBuildqueues();
 		brain-&gt;BuildUnits();
 	}
 

Modified: trunk/AI/Global/AAI/AAIBrain.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIBrain.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIBrain.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -793,7 +793,7 @@
 					{
 						air_eff = 4;
 
-						if(anti_air_urgency &gt; 1.5 * anti_ground_urgency)
+						if(anti_air_urgency &gt; 2.0f * anti_ground_urgency)
 							urgent = true;
 					}
 					else
@@ -890,7 +890,7 @@
 					{
 						air_eff = 4;
 
-						if(anti_air_urgency &gt; anti_ground_urgency)
+						if(anti_air_urgency &gt; 2.0f * anti_ground_urgency)
 							urgent = true;
 					}
 					else if(k &lt; anti_ground_urgency + anti_air_urgency + anti_hover_urgency)

Modified: trunk/AI/Global/AAI/AAIBuildTable.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIBuildTable.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIBuildTable.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -259,8 +259,8 @@
 	{
 		units_dynamic[i].active = 0;
 		units_dynamic[i].requested = 0;
-		units_dynamic[i].buildersAvailable = 0;
-		units_dynamic[i].buildersRequested = 0;
+		units_dynamic[i].constructorsAvailable = 0;
+		units_dynamic[i].constructorsRequested = 0;
 	}
 
 	// get unit defs from game
@@ -364,7 +364,7 @@
 				if(unitList[i-1]-&gt;movedata-&gt;moveType == MoveData::Ground_Move)
 				{
 					// check for amphibious units
-					if(unitList[i-1]-&gt;maxWaterDepth &gt;= 250)
+					if(unitList[i-1]-&gt;movedata-&gt;depth &gt; 250)
 						units_static[i].movement_type |= MOVE_TYPE_AMPHIB;
 					else
 						units_static[i].movement_type |= MOVE_TYPE_GROUND;
@@ -1601,7 +1601,7 @@
 	{
 		unit = &amp;units_static[*pplant];
 
-		if(canBuild &amp;&amp; units_dynamic[*pplant].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*pplant].constructorsAvailable &lt;= 0)
 			my_ranking = -10000;
 		else if(!geo &amp;&amp; unitList[*pplant-1]-&gt;needGeo)
 			my_ranking = -10000;
@@ -1639,7 +1639,7 @@
 
 	for(list&lt;int&gt;::iterator i = units_of_category[EXTRACTOR][side].begin(); i != units_of_category[EXTRACTOR][side].end(); i++)
 	{
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &lt;= 0)
 			my_ranking = -10000;
 		// check if under water or ground || water = true and building under water
 		else if( ( (!water) &amp;&amp; unitList[*i-1]-&gt;minWaterDepth &lt;= 0 ) || ( water &amp;&amp; unitList[*i-1]-&gt;minWaterDepth &gt; 0 ) )
@@ -1690,7 +1690,7 @@
 
 	for(list&lt;int&gt;::iterator storage = units_of_category[STORAGE][side-1].begin(); storage != units_of_category[STORAGE][side-1].end(); storage++)
 	{
-		if(canBuild &amp;&amp; units_dynamic[*storage].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*storage].constructorsAvailable &lt;= 0)
 			my_rating = 0;
 		else if(!water &amp;&amp; unitList[*storage-1]-&gt;minWaterDepth &lt;= 0)
 		{
@@ -1723,7 +1723,7 @@
 
 	for(list&lt;int&gt;::iterator maker = units_of_category[METAL_MAKER][side-1].begin(); maker != units_of_category[METAL_MAKER][side-1].end(); maker++)
 	{
-		if(canBuild &amp;&amp; units_dynamic[*maker].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*maker].constructorsAvailable &lt;= 0)
 			my_rating = 0;
 		else if(!water &amp;&amp; unitList[*maker-1]-&gt;minWaterDepth &lt;= 0)
 		{
@@ -1804,7 +1804,7 @@
 	// calculate rating
 	for(list&lt;int&gt;::iterator defence = units_of_category[STATIONARY_DEF][side].begin(); defence != units_of_category[STATIONARY_DEF][side].end(); ++defence)
 	{
-		if(canBuild &amp;&amp; units_dynamic[*defence].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*defence].constructorsAvailable &lt;= 0)
 			my_ranking = -100000;
 		else if( (!water &amp;&amp; unitList[*defence-1]-&gt;minWaterDepth &lt;= 0) || (water &amp;&amp; unitList[*defence-1]-&gt;minWaterDepth &gt; 0) )
 		{
@@ -1871,7 +1871,7 @@
 	for(list&lt;int&gt;::iterator airbase = units_of_category[AIR_BASE][side-1].begin(); airbase != units_of_category[AIR_BASE][side-1].end(); ++airbase)
 	{
 		// check if water 
-		if(canBuild &amp;&amp; units_dynamic[*airbase].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*airbase].constructorsAvailable &lt;= 0)
 			my_ranking = 0;
 		else if(!water &amp;&amp; unitList[*airbase-1]-&gt;minWaterDepth &lt;= 0)
 		{
@@ -1902,7 +1902,7 @@
 	for(list&lt;int&gt;::iterator arty = units_of_category[STATIONARY_ARTY][side-1].begin(); arty != units_of_category[STATIONARY_ARTY][side-1].end(); ++arty)
 	{
 		// check if water 
-		if(canBuild &amp;&amp; units_dynamic[*arty].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*arty].constructorsAvailable &lt;= 0)
 			my_ranking = 0;
 		else if(!water &amp;&amp; unitList[*arty-1]-&gt;minWaterDepth &lt;= 0)
 		{
@@ -1934,7 +1934,7 @@
 	{
 		if(unitList[*i-1]-&gt;radarRadius &gt; 0)
 		{
-			if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &lt;= 0)
+			if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &lt;= 0)
 				my_rating = -10000;
 			else if(water &amp;&amp; unitList[*i-1]-&gt;minWaterDepth &gt; 0)
 				my_rating = cost * (avg_cost[STATIONARY_RECON][side] - units_static[*i].cost)/max_cost[STATIONARY_RECON][side] 
@@ -1969,7 +1969,7 @@
 
 	for(list&lt;int&gt;::iterator i = units_of_category[STATIONARY_JAMMER][side].begin(); i != units_of_category[STATIONARY_JAMMER][side].end(); i++)
 	{
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &lt;= 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &lt;= 0)
 			my_rating = -10000;
 		else if(water &amp;&amp; unitList[*i-1]-&gt;minWaterDepth &gt; 0)
 			my_rating = cost * (avg_cost[STATIONARY_JAMMER][side] - units_static[*i].cost)/max_cost[STATIONARY_JAMMER][side] 
@@ -2005,7 +2005,7 @@
 	{
 		if(units_static[*i].movement_type &amp; allowed_movement_types)
 		{
-			if(!canBuild || (canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &gt; 0))
+			if(!canBuild || (canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &gt; 0))
 			{
 				my_ranking = los * ( unitList[*i-1]-&gt;losRadius - avg_value[SCOUT][side]) / max_value[SCOUT][side];
 				my_ranking += cost * (avg_cost[SCOUT][side] - units_static[*i].cost) / max_cost[SCOUT][side];
@@ -2098,7 +2098,7 @@
 	{
 		unit = &amp;units_static[*i];
 
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &gt; 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &gt; 0)
 		{
 			my_ranking = power * combat_eff[c] / max_power;
 			my_ranking -= cost * unit-&gt;cost / max_cost; 
@@ -2183,7 +2183,7 @@
 	{
 		unit = &amp;units_static[*i];
 
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &gt; 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &gt; 0)
 		{
 			my_ranking = power * combat_eff[c] / max_power;
 			my_ranking -= cost * unit-&gt;cost / max_cost; 
@@ -2266,7 +2266,7 @@
 	{
 		unit = &amp;units_static[*i];
 
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &gt; 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &gt; 0)
 		{
 			my_ranking = power * combat_eff[c] / max_power;
 			my_ranking -= cost * unit-&gt;cost / max_cost; 
@@ -2348,7 +2348,7 @@
 	{
 		unit = &amp;units_static[*i];
 
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &gt; 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &gt; 0)
 		{
 			my_ranking = power * combat_eff[c] / max_power;
 			my_ranking -= cost * unit-&gt;cost / max_cost; 
@@ -2429,7 +2429,7 @@
 	{
 		unit = &amp;units_static[*i];
 
-		if(canBuild &amp;&amp; units_dynamic[*i].buildersAvailable &gt; 0)
+		if(canBuild &amp;&amp; units_dynamic[*i].constructorsAvailable &gt; 0)
 		{
 			my_ranking = power * combat_eff[c] / max_power;
 			my_ranking -= cost * unit-&gt;cost / max_cost; 
@@ -2632,8 +2632,8 @@
 		{
 			units_dynamic[i].active = 0;
 			units_dynamic[i].requested = 0;
-			units_dynamic[i].buildersAvailable = 0;
-			units_dynamic[i].buildersRequested = 0;
+			units_dynamic[i].constructorsAvailable = 0;
+			units_dynamic[i].constructorsRequested = 0;
 		}
 
 		return true;
@@ -2717,8 +2717,8 @@
 
 				units_dynamic[i].active = 0;
 				units_dynamic[i].requested = 0;
-				units_dynamic[i].buildersAvailable = 0;
-				units_dynamic[i].buildersRequested = 0;
+				units_dynamic[i].constructorsAvailable = 0;
+				units_dynamic[i].constructorsRequested = 0;
 			
 				// load buildoptions
 				for(int j = 0; j &lt; bo; j++)
@@ -3156,6 +3156,7 @@
 
 	// calculate rating and cache result
 	bool builder = false;
+	bool scout = false;
 	double rating = 1;
 	double combat_units = 0;
 	float ground = (ai-&gt;map-&gt;map_usefulness[0][ai-&gt;side-1] + mod_usefulness[0][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
@@ -3193,11 +3194,15 @@
 				rating += 256.0 * GetBuilderRating(*unit);
 				builder = true;
 			}
+			else if(IsScout(def_id))
+			{
+				scout = true;
+			}
 		}
 	}
 	else if(ai-&gt;map-&gt;mapType == LAND_MAP)
 	{
-		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); unit++)	
+		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
 			if(units_static[*unit].category == GROUND_ASSAULT) 
 			{
@@ -3219,11 +3224,15 @@
 				rating += 256 * GetBuilderRating(*unit);
 				builder = true;
 			}
+			else if(units_static[*unit].category == SCOUT &amp;&amp; !(units_static[*unit].movement_type &amp; MOVE_TYPE_SEA) )
+			{
+				scout = true;
+			}
 		}	
 	}
 	else if(ai-&gt;map-&gt;mapType == AIR_MAP)
 	{
-		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); unit++)	
+		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
 			if(units_static[*unit].category == AIR_ASSAULT)
 			{
@@ -3235,11 +3244,15 @@
 				rating += 256 * GetBuilderRating(*unit);
 				builder = true;
 			}
+			else if(units_static[*unit].category == SCOUT &amp;&amp; units_static[*unit].movement_type &amp; MOVE_TYPE_AIR)
+			{
+				scout = true;
+			}
 		}	
 	}
 	else if(ai-&gt;map-&gt;mapType == LAND_WATER_MAP)
 	{
-		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); unit++)	
+		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
 			if(units_static[*unit].category == GROUND_ASSAULT) 
 			{
@@ -3271,11 +3284,15 @@
 				rating += 256 * GetBuilderRating(*unit);
 				builder = true;
 			}
+			else if(units_static[*unit].category == SCOUT)
+			{
+				scout = true;
+			}
 		}
 	}
 	else if(ai-&gt;map-&gt;mapType == WATER_MAP)
 	{
-		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); unit++)	
+		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
 			if(units_static[*unit].category == HOVER_ASSAULT) 
 			{
@@ -3302,20 +3319,37 @@
 				rating += 256 * GetBuilderRating(*unit);
 				builder = true;
 			}
+			else if(units_static[*unit].category == SCOUT)
+			{
+				scout = true;
+			}
 		}
 	}
 	
 	if(combat_units &gt; 0)
 	{
-		rating /= (combat_units * pow(units_static[def_id].cost, 2));
-		rating *= sqrt(8 + combat_units);
+		rating /= (combat_units * units_static[def_id].cost);
+		rating *= fastmath::sqrt((float) (4 + combat_units) );
+
+		if(scout) 
+			rating += 8.0f;
+
 		units_static[def_id].efficiency[5] = rating;
 		return rating;
 	}
 	else if(builder)
 	{
-		units_static[def_id].efficiency[5] = 0.25;
-		return 0.25;
+		if(scout)
+		{
+			
+			units_static[def_id].efficiency[5] = 1.0f;
+			return 1.0f;
+		}
+		else
+		{
+			units_static[def_id].efficiency[5] = 0.5f;
+			return 0.5f;
+		}
 	}
 	else
 	{
@@ -3362,150 +3396,98 @@
 	}
 }
 
-void AAIBuildTable::BuildFactoryFor(int def_id)
+void AAIBuildTable::BuildConstructorFor(int def_id)
 {
-	bool suitable;
+	int constructor = 0;
+	float best_rating = -100000.0f, my_rating; 
 
-	float best_rating = -100000, my_rating;
-	int best_factory = 0;
-
-	//fprintf(ai-&gt;file, &quot;Looking for factory to build %s\n&quot;, unitList[unit_id-1]-&gt;humanName.c_str());
-		
-	for(list&lt;int&gt;::iterator fac = units_static[def_id].builtByList.begin();  fac != units_static[def_id].builtByList.end(); ++fac)
-	{	
-		if(units_dynamic[*fac].requested &lt;= 0)
+	float max_buildtime = max_builder_buildtime[ai-&gt;side-1]/256.0f;
+	
+	// look for best builder to do the job
+	for(list&lt;int&gt;::iterator unit = units_static[def_id].builtByList.begin();  unit != units_static[def_id].builtByList.end(); ++unit)
+	{
+		if(units_dynamic[*unit].requested &lt;= 0)
 		{
-			if(IsStatic(*fac))
-			{
-				if(ai-&gt;map-&gt;mapType == LAND_MAP &amp;&amp; !CanPlacedLand(*fac))
-					suitable = false;
-				else 
-					suitable = true;
-			}
-			else 
-				suitable = true;
-		}
-		else
-			suitable = false;
+			my_rating = (unitList[*unit-1]-&gt;buildSpeed / max_builder_buildspeed[ai-&gt;side-1]) 
+						- (unitList[*unit-1]-&gt;buildTime / max_buildtime) 
+						- (units_static[*unit].cost / max_builder_cost[ai-&gt;side-1]);
 
-		if(suitable)
-		{
-			my_rating = GetFactoryRating(*fac);
+			my_rating += 0.25f * GetBuilderRating(*unit);
 
+			// prefer builders that can be built atm
+			if(units_dynamic[*unit].constructorsAvailable &gt; 0)
+				my_rating += 4.0f;
+
 			if(my_rating &gt; best_rating)
 			{	
 				best_rating = my_rating;
-				best_factory = *fac;
-			}
+				constructor = *unit;
+			}	
 		}
 	}
 
-
-	if(best_factory)
+	if(constructor)
 	{
-		if(IsStatic(best_factory))
+		// factory requested
+		if(IsStatic(constructor))
 		{
-			units_dynamic[best_factory].requested += 1;
+			units_dynamic[constructor].requested += 1;
 
-			for(list&lt;int&gt;::iterator j = units_static[best_factory].canBuildList.begin(); j != units_static[best_factory].canBuildList.end(); ++j)
+			for(list&lt;int&gt;::iterator j = units_static[constructor].canBuildList.begin(); j != units_static[constructor].canBuildList.end(); ++j)
 			{
-					//// only set to true, if the factory is not built by that unit itself
-					//if(!MemberOf(*j, units_static[*i].builtByList))
-						units_dynamic[*j].buildersRequested += 1;
+				//// only set to true, if the factory is not built by that unit itself
+				//if(!MemberOf(*j, units_static[*i].builtByList))
+				units_dynamic[*j].constructorsRequested += 1;
 			}
 
-			if(units_dynamic[best_factory].buildersAvailable &lt;= 0)
+			if(units_dynamic[constructor].constructorsAvailable &lt;= 0)
 			{
-				fprintf(ai-&gt;file, &quot;BuildFactory() is requesting builder for %s\n&quot;, unitList[best_factory-1]-&gt;humanName.c_str()); 	
-				BuildBuilderFor(best_factory);	
+				fprintf(ai-&gt;file, &quot;BuildConstructorFor() is requesting builder for %s\n&quot;, unitList[constructor-1]-&gt;humanName.c_str()); 	
+				BuildConstructorFor(constructor);	
 			}
 
 			// debug
-			fprintf(ai-&gt;file, &quot;Added %s to buildque\n&quot;, unitList[best_factory-1]-&gt;humanName.c_str()); 		
+			//fprintf(ai-&gt;file, &quot;Added %s to buildqueue\n&quot;, unitList[constructor-1]-&gt;humanName.c_str()); 		
 		}
+		// mobile constructor requested
 		else
 		{
-			if(ai-&gt;execute-&gt;AddUnitToBuildque(best_factory, 1))
+			if(ai-&gt;execute-&gt;AddUnitToBuildqueue(constructor, 1, true))
 			{
-				units_dynamic[best_factory].requested += 1;
+				units_dynamic[constructor].requested += 1;
+				
+				// increase counter if mobile factory is a builder as well
+				if(units_static[constructor].unit_type &amp; UNIT_TYPE_BUILDER)
+					ai-&gt;futureBuilders += 1;
 
-				for(list&lt;int&gt;::iterator j = units_static[best_factory].canBuildList.begin(); j != units_static[best_factory].canBuildList.end(); ++j)
+				for(list&lt;int&gt;::iterator j = units_static[constructor].canBuildList.begin(); j != units_static[constructor].canBuildList.end(); ++j)
 				{
 					//// only set to true, if the factory is not built by that unit itself
 					//if(!MemberOf(*j, units_static[*i].builtByList))
-						units_dynamic[*j].buildersRequested += 1;
+					units_dynamic[*j].constructorsRequested += 1;
 				}
 
-				if(units_dynamic[best_factory].buildersAvailable &lt;= 0)
-					BuildBuilderFor(best_factory);
+				if(units_dynamic[constructor].constructorsAvailable &lt;= 0)
+				{
+					fprintf(ai-&gt;file, &quot;BuildConstructorFor() is requesting factory for %s\n&quot;, unitList[constructor-1]-&gt;humanName.c_str()); 	
+					BuildConstructorFor(constructor);	
+				}
 
 				// debug
-				fprintf(ai-&gt;file, &quot;Added %s to buildque\n&quot;, unitList[best_factory-1]-&gt;humanName.c_str()); 
+				//fprintf(ai-&gt;file, &quot;Added %s to buildqueue\n&quot;, unitList[constructor-1]-&gt;humanName.c_str()); 
 			}
 		}
 	}
 }
 
-void AAIBuildTable::BuildBuilderFor(int building_id)
-{
-	int builder = 0;
-	float best_rating = -100000, my_rating; 
-
-	float cost = 1.0f;
-	float buildspeed = 0.5f;
-	float urgency = 2.0f;
-
-	float max_buildtime = max_builder_buildtime[ai-&gt;side-1]/256.0f;
-	
-	// look for best builder to do the job
-	for(list&lt;int&gt;::iterator unit = units_static[building_id].builtByList.begin();  unit != units_static[building_id].builtByList.end(); ++unit)
-	{
-		my_rating = buildspeed * (unitList[*unit-1]-&gt;buildSpeed / max_builder_buildspeed[ai-&gt;side-1]) 
-					- urgency * (unitList[*unit-1]-&gt;buildTime / max_buildtime) 
-					- cost * (units_static[*unit].cost / max_builder_cost[ai-&gt;side-1]);
-
-		my_rating += GetBuilderRating(*unit);
-
-		// prefer builders that can be built atm
-		if(units_dynamic[*unit].buildersAvailable &gt; 0)
-			my_rating += 20.0f;
-
-		if(my_rating &gt; best_rating)
-		{	
-			best_rating = my_rating;
-			builder = *unit;
-		}	
-	}
-
-	if(builder &amp;&amp; units_dynamic[builder].requested &lt;= 0)
-	{
-		// build factory if necessary
-		if(units_dynamic[builder].buildersAvailable &lt;= 0)
-			BuildFactoryFor(builder);
-
-		if(ai-&gt;execute-&gt;AddUnitToBuildque(builder))
-		{
-			units_dynamic[builder].requested += 1;
-			ai-&gt;futureBuilders += 1;
-
-			// set builder requested for all its buildoptions 
-			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); ++j)
-			units_dynamic[*j].buildersRequested += 1; 
-
-			// debug
-			//fprintf(ai-&gt;file, &quot;BuildBuilderFor() requested: %s %i\n&quot;, unitList[builder-1]-&gt;humanName.c_str(), units_dynamic[builder].requested);	
-		}
-	}
-}
-
 void AAIBuildTable::AddBuilder(int building_id)
 {
 	int builder = 0;
 	float best_rating = -10000, my_rating; 
 
 	float cost = ai-&gt;brain-&gt;Affordable()/2.0; 
-	float buildspeed = fastmath::sqrt((float) (1.0 + units_dynamic[building_id].buildersAvailable + units_dynamic[building_id].buildersRequested))/2.0;
-	float urgency = 12.0 / (units_dynamic[building_id].buildersAvailable +  2.0);
+	float buildspeed = 2.0;
+	float urgency = 12.0 / (units_dynamic[building_id].constructorsAvailable +  2.0);
 
 	float max_buildtime = max_builder_buildtime[ai-&gt;side-1]/256.0;
 
@@ -3513,13 +3495,13 @@
 	for(list&lt;int&gt;::iterator unit = units_static[building_id].builtByList.begin();  unit != units_static[building_id].builtByList.end(); ++unit)
 	{
 		// prevent ai from ordering too many builders of the same type/commanders/builders that cant be built atm
-		if(units_dynamic[*unit].active &lt; cfg-&gt;MAX_BUILDERS_PER_TYPE &amp;&amp; units_dynamic[*unit].buildersAvailable &gt; 0)
+		if(units_dynamic[*unit].active &lt; cfg-&gt;MAX_BUILDERS_PER_TYPE &amp;&amp; units_dynamic[*unit].constructorsAvailable &gt; 0)
 		{
 			my_rating = buildspeed * (unitList[*unit-1]-&gt;buildSpeed / max_builder_buildspeed[ai-&gt;side-1]) 
 						- cost * (units_static[*unit].cost / max_builder_cost[ai-&gt;side-1]) 
 						- urgency * (unitList[*unit-1]-&gt;buildTime / max_buildtime);
 
-			my_rating += GetBuilderRating(*unit);
+			my_rating += 0.25f * GetBuilderRating(*unit);
 			//my_rating -=  0.5 * ((float)(units_dynamic[*unit].requested + units_dynamic[*unit].active)) / (float)cfg-&gt;MAX_BUILDERS_PER_TYPE;
 
 			if(my_rating &gt; best_rating)
@@ -3533,17 +3515,17 @@
 	if(builder &amp;&amp; units_dynamic[builder].requested &lt;= 0)
 	{
 		// build factory if necessary
-		if(units_dynamic[builder].buildersAvailable &lt;= 0)
-			BuildFactoryFor(builder);
+		if(units_dynamic[builder].constructorsAvailable &lt;= 0 &amp;&amp; units_dynamic[builder].constructorsRequested &lt;= 0)
+			BuildConstructorFor(builder);
 
-		if(ai-&gt;execute-&gt;AddUnitToBuildque(builder))
+		if(ai-&gt;execute-&gt;AddUnitToBuildqueue(builder, 1, true))
 		{
 			units_dynamic[builder].requested += 1;
 			ai-&gt;futureBuilders += 1;
 
 			// set all its buildoptions buildable
 			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); j++)
-				units_dynamic[*j].buildersRequested += 1;
+				units_dynamic[*j].constructorsRequested += 1;
 	
 			// debug
 			//fprintf(ai-&gt;file, &quot;AddBuilder() requested: %s %i \n&quot;, unitList[builder-1]-&gt;humanName.c_str(), units_dynamic[builder].requested);
@@ -3569,7 +3551,7 @@
 	{
 		if(units_static[*unit].movement_type &amp; allowed_movement_types)
 		{
-			if( (!canBuild || units_dynamic[*unit].buildersAvailable &gt; 0)
+			if( (!canBuild || units_dynamic[*unit].constructorsAvailable &gt; 0)
 				&amp;&amp; units_dynamic[*unit].active &lt; cfg-&gt;MAX_BUILDERS_PER_TYPE)
 			{
 				if( unitList[*unit-1]-&gt;buildSpeed &gt;= (float)cfg-&gt;MIN_ASSISTANCE_BUILDTIME &amp;&amp; unitList[*unit-1]-&gt;canAssist)
@@ -3591,19 +3573,19 @@
 	if(builder &amp;&amp; units_dynamic[builder].requested &lt; 1)
 	{
 		// build factory if necessary
-		if(units_dynamic[builder].buildersAvailable &lt;= 0)
-			BuildFactoryFor(builder);
+		if(units_dynamic[builder].constructorsAvailable &lt;= 0)
+			BuildConstructorFor(builder);
 
-		if(ai-&gt;execute-&gt;AddUnitToBuildque(builder))
+		if(ai-&gt;execute-&gt;AddUnitToBuildqueue(builder, 1, true))
 		{
 			units_dynamic[builder].requested += 1;
 			ai-&gt;futureBuilders += 1;
 
 			// increase number of requested builders of all buildoptions
 			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); ++j)
-				units_dynamic[*j].buildersRequested += 1;
+				units_dynamic[*j].constructorsRequested += 1;
 
-			fprintf(ai-&gt;file, &quot;AddAssister() requested: %s %i \n&quot;, unitList[builder-1]-&gt;humanName.c_str(), units_dynamic[builder].requested);
+			//fprintf(ai-&gt;file, &quot;AddAssister() requested: %s %i \n&quot;, unitList[builder-1]-&gt;humanName.c_str(), units_dynamic[builder].requested);
 		}
 	}
 }

Modified: trunk/AI/Global/AAI/AAIBuildTable.h
===================================================================
--- trunk/AI/Global/AAI/AAIBuildTable.h	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIBuildTable.h	2008-10-02 14:16:09 UTC (rev 6499)
@@ -91,8 +91,7 @@
 	int GetJammer(int side, float cost, float range, bool water, bool canBuild);
 
 	// checks which factory is needed for a specific unit and orders it to be built
-	void BuildFactoryFor(int def_id);
-	void BuildBuilderFor(int building_id);
+	void BuildConstructorFor(int def_id);
 
 	// tries to build another builder for a certain building
 	void AddBuilder(int building_id);

Modified: trunk/AI/Global/AAI/AAIConfig.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIConfig.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIConfig.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -70,7 +70,7 @@
 	MIN_SUBMARINE_WATERLINE = 15;
 	MAX_ATTACKS = 4;
 	
-	NON_AMPHIB_MAX_WATERDEPTH = 15;
+	NON_AMPHIB_MAX_WATERDEPTH = 15.0f;
 
 	MAX_COST_LIGHT_ASSAULT = 0.025f;
 	MAX_COST_MEDIUM_ASSAULT = 0.13f;

Modified: trunk/AI/Global/AAI/AAIConstructor.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIConstructor.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIConstructor.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -30,7 +30,7 @@
 	this-&gt;builder = builder;
 	this-&gt;assistant = assistant;
 
-	buildque = ai-&gt;execute-&gt;GetBuildqueOfFactory(def_id);
+	buildque = ai-&gt;execute-&gt;GetBuildqueueOfFactory(def_id);
 }
 
 AAIConstructor::~AAIConstructor(void)
@@ -239,7 +239,7 @@
 					ai-&gt;execute-&gt;urgency[STATIONARY_CONSTRUCTOR] = 1;
 
 				for(list&lt;int&gt;::iterator j = bt-&gt;units_static[def_id].canBuildList.begin(); j != bt-&gt;units_static[def_id].canBuildList.end(); ++j)
-					bt-&gt;units_dynamic[*j].buildersRequested += 1;
+					bt-&gt;units_dynamic[*j].constructorsRequested += 1;
 			}
 		}
 		

Modified: trunk/AI/Global/AAI/AAIExecute.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIExecute.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIExecute.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -300,18 +300,18 @@
 
 		if(period == 0)
 		{
-			cost = 2;
-			los = 0.5;
+			cost = 2.0f;
+			los = 0.5f;
 		}
 		else if(period == 1)
 		{
-			cost = 1;
-			los = 2;
+			cost = 1.0f;
+			los = 2.0f;
 		}
 		else 
 		{
-			cost = 0.5;
-			los = 4.0;
+			cost = 0.5f;
+			los = 4.0f;
 		}
 
 		// determine movement type of scout based on map
@@ -337,7 +337,12 @@
 
 		if(scout)
 		{
-			if(AddUnitToBuildque(scout, 1, false))
+			bool urgent = true;
+
+			if(ai-&gt;activeScouts &gt;= 2)
+				urgent = false;
+
+			if(AddUnitToBuildqueue(scout, 1, urgent))
 			{
 				++ai-&gt;futureScouts;
 				++bt-&gt;units_dynamic[scout].requested;
@@ -550,7 +555,7 @@
 	return power;
 }
 
-list&lt;int&gt;* AAIExecute::GetBuildqueOfFactory(int def_id)
+list&lt;int&gt;* AAIExecute::GetBuildqueueOfFactory(int def_id)
 {
 	for(int i = 0; i &lt; numOfFactories; ++i)
 	{
@@ -561,16 +566,13 @@
 	return 0;
 }
 
-bool AAIExecute::AddUnitToBuildque(int def_id, int number, bool urgent)
+bool AAIExecute::AddUnitToBuildqueue(int def_id, int number, bool urgent)
 {
 	urgent = false;
 
 	UnitCategory category = bt-&gt;units_static[def_id].category;
 
-	if(category == UNKNOWN)
-		return false;
-
-	list&lt;int&gt; *buildque = 0, *temp = 0;
+	list&lt;int&gt; *buildqueue = 0, *temp_buildqueue = 0;
 	
 	float my_rating, best_rating = 0;
 
@@ -578,11 +580,11 @@
 	{
 		if(bt-&gt;units_dynamic[*fac].active &gt; 0)
 		{
-			temp = GetBuildqueOfFactory(*fac);
+			temp_buildqueue = GetBuildqueueOfFactory(*fac);
 
-			if(temp)
+			if(temp_buildqueue)
 			{
-				my_rating = (1 + 2 * (float) bt-&gt;units_dynamic[*fac].active) / (temp-&gt;size() + 3);
+				my_rating = (1 + 2 * (float) bt-&gt;units_dynamic[*fac].active) / (temp_buildqueue-&gt;size() + 3);
 
 				if(map-&gt;mapType == WATER_MAP &amp;&amp; !bt-&gt;CanPlacedWater(*fac))
 					my_rating /= 10.0;
@@ -596,59 +598,25 @@
 		if(my_rating &gt; best_rating)
 		{
 			best_rating = my_rating;
-			buildque = temp;
+			buildqueue = temp_buildqueue;
 		}
 	}
 
-	
-
 	// determine position
-	if(buildque)
+	if(buildqueue)
 	{
-		//fprintf(ai-&gt;file, &quot;Found builque for %s\n&quot;, bt-&gt;unitList[def_id-1]-&gt;humanName.c_str());
-
-		if(bt-&gt;IsBuilder(def_id))
-		{	
-			buildque-&gt;insert(buildque-&gt;begin(), number, def_id);
-			return true;	
-		}
-		else if(category == SCOUT)
+		if(urgent)
 		{
-			if(ai-&gt;activeScouts &lt; 2)
-			{
-				buildque-&gt;insert(buildque-&gt;begin(), number, def_id);
+				buildqueue-&gt;insert(buildqueue-&gt;begin(), number, def_id);
 				return true;
-			}
-			else
-			{
-				/*// insert after the last builder
-				for(list&lt;int&gt;::iterator unit = buildque-&gt;begin(); unit != buildque-&gt;end();  ++unit)
-				{
-					if(!bt-&gt;IsBuilder(*unit))
-					{
-						buildque-&gt;insert(unit, number, def_id);
-						return true;
-					}
-				}*/
-				buildque-&gt;insert(buildque-&gt;begin(), number, def_id);
-				return true;
-			}
 		}
-		else if(buildque-&gt;size() &lt; cfg-&gt;MAX_BUILDQUE_SIZE)
+		else if(buildqueue-&gt;size() &lt; cfg-&gt;MAX_BUILDQUE_SIZE)
 		{
-			if(urgent)
-				buildque-&gt;insert(buildque-&gt;begin(), number, def_id);
-			else
-				buildque-&gt;insert(buildque-&gt;end(), number, def_id);
-
-			//fprintf(ai-&gt;file, &quot;Added %s to buildque with length %i\n&quot;, bt-&gt;unitList[def_id-1]-&gt;humanName.c_str(), buildque-&gt;size());
-
+			buildqueue-&gt;insert(buildqueue-&gt;end(), number, def_id);
 			return true;
-		}
+		}	
 	}
-	//else
-	//	fprintf(ai-&gt;file, &quot;Could not find builque for %s\n&quot;, bt-&gt;unitList[def_id-1]-&gt;humanName.c_str());
-
+	
 	return false;
 }
 
@@ -838,9 +806,9 @@
 		// get id of an extractor and look for suitable builder
 		land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, false);
 
-		if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].buildersAvailable &lt;= 0)
+		if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsRequested &lt;= 0)
 		{
-			bt-&gt;BuildBuilderFor(land_mex);
+			bt-&gt;BuildConstructorFor(land_mex);
 			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
 		}
 
@@ -870,17 +838,17 @@
 			// get id of an extractor and look for suitable builder
 			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, false);
 
-			if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].buildersAvailable &lt;= 0)
+			if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsRequested &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(land_mex);
+				bt-&gt;BuildConstructorFor(land_mex);
 				land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
 			}
 
 			water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, false);
 
-			if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].buildersAvailable &lt;= 0)
+			if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsRequested &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(water_mex);
+				bt-&gt;BuildConstructorFor(water_mex);
 				water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, true);
 			}
 
@@ -975,9 +943,9 @@
 
 				int mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, armed, water, false);
 
-				if(mex &amp;&amp; bt-&gt;units_dynamic[mex].buildersAvailable &lt;= 0)
+				if(mex &amp;&amp; bt-&gt;units_dynamic[mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[mex].constructorsAvailable &lt;= 0)
 				{
-					bt-&gt;BuildBuilderFor(mex);
+					bt-&gt;BuildConstructorFor(mex);
 
 					mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, armed, water, true);
 				}
@@ -1016,6 +984,8 @@
 {	
 	if(ai-&gt;futureUnits[POWER_PLANT] + ai-&gt;requestedUnits[POWER_PLANT] &gt; 1)
 		return true;
+	else if(ai-&gt;futureUnits[POWER_PLANT] &lt;= 0 &amp;&amp; ai-&gt;requestedUnits[POWER_PLANT] &gt; 0)
+		return true;
 	else if(ai-&gt;futureUnits[POWER_PLANT] &gt; 0)
 	{
 		// try to assist construction of other power plants first
@@ -1099,20 +1069,20 @@
 	// get water and ground plant
 	ground_plant = bt-&gt;GetPowerPlant(ai-&gt;side, eff, urgency, max_power, energy, false, false, false);
 	// currently aai cannot build this building
-	if(ground_plant &amp;&amp; bt-&gt;units_dynamic[ground_plant].buildersAvailable &lt;= 0)
+	if(ground_plant &amp;&amp; bt-&gt;units_dynamic[ground_plant].constructorsAvailable &lt;= 0)
 	{
-		if( bt-&gt;units_dynamic[water_plant].buildersRequested &lt;= 0)
-			bt-&gt;AddBuilder(ground_plant);
+		if( bt-&gt;units_dynamic[water_plant].constructorsRequested &lt;= 0)
+			bt-&gt;BuildConstructorFor(ground_plant);
 
 		ground_plant = bt-&gt;GetPowerPlant(ai-&gt;side, eff, urgency, max_power, energy, false, false, true);
 	}
 
 	water_plant = bt-&gt;GetPowerPlant(ai-&gt;side, eff, urgency, max_power, energy, true, false, false);
 	// currently aai cannot build this building
-	if(water_plant &amp;&amp; bt-&gt;units_dynamic[water_plant].buildersAvailable &lt;= 0)
+	if(water_plant &amp;&amp; bt-&gt;units_dynamic[water_plant].constructorsAvailable &lt;= 0)
 	{
-		if( bt-&gt;units_dynamic[water_plant].buildersRequested &lt;= 0)
-			bt-&gt;AddBuilder(water_plant);
+		if( bt-&gt;units_dynamic[water_plant].constructorsRequested &lt;= 0)
+			bt-&gt;BuildConstructorFor(water_plant);
 
 		water_plant = bt-&gt;GetPowerPlant(ai-&gt;side, eff, urgency, max_power, energy, true, false, true);
 	}
@@ -1264,10 +1234,10 @@
 			maker = bt-&gt;GetMetalMaker(ai-&gt;side, cost,  efficiency, metal, urgency, false, false); 
 	
 			// currently aai cannot build this building
-			if(maker &amp;&amp; bt-&gt;units_dynamic[maker].buildersAvailable &lt;= 0)
+			if(maker &amp;&amp; bt-&gt;units_dynamic[maker].constructorsAvailable &lt;= 0)
 			{
-				if(bt-&gt;units_dynamic[maker].buildersRequested &lt;= 0)
-					bt-&gt;BuildBuilderFor(maker);
+				if(bt-&gt;units_dynamic[maker].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(maker);
 				
 				maker = bt-&gt;GetMetalMaker(ai-&gt;side, cost, efficiency, metal, urgency, false, true);
 			}
@@ -1305,10 +1275,10 @@
 			maker = bt-&gt;GetMetalMaker(ai-&gt;side, brain-&gt;Affordable(),  8.0/(urgency+2.0), 64.0/(16*urgency+2.0), urgency, true, false); 
 	
 			// currently aai cannot build this building
-			if(maker &amp;&amp; bt-&gt;units_dynamic[maker].buildersAvailable &lt;= 0)
+			if(maker &amp;&amp; bt-&gt;units_dynamic[maker].constructorsAvailable &lt;= 0)
 			{
-				if(bt-&gt;units_dynamic[maker].buildersRequested &lt;= 0)
-					bt-&gt;BuildBuilderFor(maker);
+				if(bt-&gt;units_dynamic[maker].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(maker);
 				
 				maker = bt-&gt;GetMetalMaker(ai-&gt;side, brain-&gt;Affordable(),  8.0/(urgency+2.0), 64.0/(16*urgency+2.0), urgency, true, true);
 			}
@@ -1386,9 +1356,11 @@
 		{		
 			storage = bt-&gt;GetStorage(ai-&gt;side, brain-&gt;Affordable(),  metal, energy, 1, false, false); 
 	
-			if(storage &amp;&amp; bt-&gt;units_dynamic[storage].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[storage].buildersRequested &lt;= 0)
+			if(storage &amp;&amp; bt-&gt;units_dynamic[storage].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(storage);
+				if(bt-&gt;units_dynamic[storage].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(storage);
+
 				storage = bt-&gt;GetStorage(ai-&gt;side, brain-&gt;Affordable(),  metal, energy, 1, false, true); 
 			}
 
@@ -1423,9 +1395,11 @@
 		{
 			storage = bt-&gt;GetStorage(ai-&gt;side, brain-&gt;Affordable(),  metal, energy, 1, true, false); 
 	
-			if(storage &amp;&amp; bt-&gt;units_dynamic[storage].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[storage].buildersRequested &lt;= 0)
+			if(storage &amp;&amp; bt-&gt;units_dynamic[storage].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(storage);
+				if( bt-&gt;units_dynamic[storage].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(storage);
+
 				storage = bt-&gt;GetStorage(ai-&gt;side, brain-&gt;Affordable(),  metal, energy, 1, true, true); 
 			}
 
@@ -1493,10 +1467,10 @@
 
 			airbase = bt-&gt;GetAirBase(ai-&gt;side, brain-&gt;Affordable(), false, false); 
 	
-			if(airbase &amp;&amp; bt-&gt;units_dynamic[airbase].buildersAvailable &lt;= 0)
+			if(airbase &amp;&amp; bt-&gt;units_dynamic[airbase].constructorsAvailable &lt;= 0)
 			{
-				if(bt-&gt;units_dynamic[airbase].buildersRequested &lt;= 0)
-					bt-&gt;BuildBuilderFor(airbase);
+				if(bt-&gt;units_dynamic[airbase].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(airbase);
 
 				airbase = bt-&gt;GetAirBase(ai-&gt;side, brain-&gt;Affordable(), false, true);
 			}
@@ -1532,10 +1506,10 @@
 		{
 			airbase = bt-&gt;GetAirBase(ai-&gt;side, brain-&gt;Affordable(), true, false); 
 	
-			if(airbase &amp;&amp; bt-&gt;units_dynamic[airbase].buildersAvailable &lt;= 0 )
+			if(airbase &amp;&amp; bt-&gt;units_dynamic[airbase].constructorsAvailable &lt;= 0 )
 			{
-				if(bt-&gt;units_dynamic[airbase].buildersRequested &lt;= 0)
-					bt-&gt;BuildBuilderFor(airbase);
+				if(bt-&gt;units_dynamic[airbase].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(airbase);
 
 				airbase = bt-&gt;GetAirBase(ai-&gt;side, brain-&gt;Affordable(), true, true);  
 			}
@@ -1691,9 +1665,11 @@
 		else
 			building = bt-&gt;GetDefenceBuilding(ai-&gt;side, eff, power, cost, gr_eff, air_eff, hover_eff, sea_eff, submarine_eff, urgency, range, 8, false, false);
 
-		if(building &amp;&amp; bt-&gt;units_dynamic[building].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[building].buildersRequested &lt;= 0)
+		if(building &amp;&amp; bt-&gt;units_dynamic[building].constructorsAvailable &lt;= 0)
 		{
-			bt-&gt;BuildBuilderFor(building);
+			if(bt-&gt;units_dynamic[building].constructorsRequested &lt;= 0)
+				bt-&gt;BuildConstructorFor(building);
+
 			building = bt-&gt;GetDefenceBuilding(ai-&gt;side, eff, power, cost, gr_eff, air_eff, hover_eff, sea_eff, submarine_eff, urgency, range, 8, false, true);
 		}
 
@@ -1748,9 +1724,11 @@
 		else
 			building = bt-&gt;GetDefenceBuilding(ai-&gt;side, eff, power, cost, gr_eff, air_eff, hover_eff, sea_eff, submarine_eff, urgency, 1, 8, true, false);
 
-		if(building &amp;&amp; bt-&gt;units_dynamic[building].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[building].buildersRequested &lt;= 0)
+		if(building &amp;&amp; bt-&gt;units_dynamic[building].constructorsAvailable &lt;= 0)
 		{
-			bt-&gt;BuildBuilderFor(building);
+			if(bt-&gt;units_dynamic[building].constructorsRequested &lt;= 0)
+				bt-&gt;BuildConstructorFor(building);
+
 			building = bt-&gt;GetDefenceBuilding(ai-&gt;side, eff, power, cost, gr_eff, air_eff, hover_eff, sea_eff, submarine_eff, urgency, 1,  8, true, true);
 		}
 
@@ -1837,10 +1815,10 @@
 		
 			if(arty)
 			{
-				if(bt-&gt;units_dynamic[arty].buildersAvailable &lt;= 0)
+				if(bt-&gt;units_dynamic[arty].constructorsAvailable &lt;= 0)
 				{
-					if(bt-&gt;units_dynamic[arty].buildersRequested &lt;= 0)
-						bt-&gt;BuildBuilderFor(arty);
+					if(bt-&gt;units_dynamic[arty].constructorsRequested &lt;= 0)
+						bt-&gt;BuildConstructorFor(arty);
 					
 					return true;
 				}
@@ -1871,10 +1849,10 @@
 		
 			if(arty)
 			{
-				if(bt-&gt;units_dynamic[arty].buildersAvailable &lt;= 0)
+				if(bt-&gt;units_dynamic[arty].constructorsAvailable &lt;= 0)
 				{
-					if(bt-&gt;units_dynamic[arty].buildersRequested &lt;= 0)
-						bt-&gt;BuildBuilderFor(arty);
+					if(bt-&gt;units_dynamic[arty].constructorsRequested &lt;= 0)
+						bt-&gt;BuildConstructorFor(arty);
 
 					return true;
 				}
@@ -1919,7 +1897,7 @@
 		if(bt-&gt;units_dynamic[*fac].requested &gt; 0)	
 		{
 			my_rating = bt-&gt;GetFactoryRating(*fac) / pow( (float) (1 + bt-&gt;units_dynamic[*fac].active), 2.0f);
-			my_rating *= (1 + sqrt(2.0 + (float) GetBuildqueOfFactory(*fac)-&gt;size())); 
+			my_rating *= (1 + sqrt(2.0 + (float) GetBuildqueueOfFactory(*fac)-&gt;size())); 
 
 			if(ai-&gt;activeFactories &lt; 1)
 				my_rating /= bt-&gt;units_static[*fac].cost;
@@ -2029,8 +2007,8 @@
 			}
 			else
 			{
-				if(bt-&gt;units_dynamic[building].buildersRequested &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[building].buildersAvailable &lt;= 0)
-					bt-&gt;BuildBuilderFor(building);
+				if(bt-&gt;units_dynamic[building].constructorsRequested &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[building].constructorsAvailable &lt;= 0)
+					bt-&gt;BuildConstructorFor(building);
 					
 				return false;
 			}
@@ -2075,9 +2053,9 @@
 		{
 			unit = bt-&gt;GetGroundAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, stat_eff, eff, speed, range, cost, 15, false);
 
-			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].buildersAvailable &lt;= 0)
+			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildFactoryFor(unit);
+				bt-&gt;BuildConstructorFor(unit);
 				unit = bt-&gt;GetGroundAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, stat_eff, eff, speed, range, cost, 15, true);
 			}
 		}
@@ -2090,9 +2068,9 @@
 		{
 			unit = bt-&gt;GetAirAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, stat_eff, eff, speed, range, cost, 9, false);
 
-			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].buildersAvailable &lt;= 0)
+			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildFactoryFor(unit);
+				bt-&gt;BuildConstructorFor(unit);
 				unit = bt-&gt;GetAirAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, stat_eff, eff, speed, range, cost, 9, true);
 			}
 		}
@@ -2105,9 +2083,9 @@
 		{
 			unit = bt-&gt;GetHoverAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, stat_eff, eff, speed, range, cost, 9, false);
 
-			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].buildersAvailable &lt;= 0)
+			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildFactoryFor(unit);
+				bt-&gt;BuildConstructorFor(unit);
 				unit = bt-&gt;GetHoverAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, stat_eff, eff, speed, range, cost, 9, true);
 			}
 		}
@@ -2120,9 +2098,9 @@
 		{
 			unit = bt-&gt;GetSeaAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, submarine_eff, stat_eff, eff, speed, range, cost, 9, false);
 
-			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].buildersAvailable &lt;= 0)
+			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildFactoryFor(unit);
+				bt-&gt;BuildConstructorFor(unit);
 				unit = bt-&gt;GetSeaAssault(ai-&gt;side, power, ground_eff, air_eff, hover_eff, sea_eff, submarine_eff, stat_eff, eff, speed, range, cost, 9, false);
 			}
 		}
@@ -2135,9 +2113,9 @@
 		{
 			unit = bt-&gt;GetSubmarineAssault(ai-&gt;side, power, sea_eff, submarine_eff, stat_eff, eff, speed, range, cost, 9, false);
 
-			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].buildersAvailable &lt;= 0)
+			if(unit &amp;&amp; bt-&gt;units_dynamic[unit].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildFactoryFor(unit);
+				bt-&gt;BuildConstructorFor(unit);
 				unit = bt-&gt;GetSubmarineAssault(ai-&gt;side, power, sea_eff, submarine_eff, stat_eff, eff, speed, range, cost, 9, false);
 			}
 		}
@@ -2146,26 +2124,26 @@
 
 	if(unit)
 	{
-		if(bt-&gt;units_dynamic[unit].buildersAvailable &gt; 0)
+		if(bt-&gt;units_dynamic[unit].constructorsAvailable &gt; 0)
 		{	
 			if(bt-&gt;units_static[unit].cost &lt; cfg-&gt;MAX_COST_LIGHT_ASSAULT * bt-&gt;max_cost[category][ai-&gt;side-1])
 			{
-				if(AddUnitToBuildque(unit, 3, urgent))
+				if(AddUnitToBuildqueue(unit, 3, urgent))
 					bt-&gt;units_dynamic[unit].requested += 3;
 			}
 			else if(bt-&gt;units_static[unit].cost &lt; cfg-&gt;MAX_COST_MEDIUM_ASSAULT * bt-&gt;max_cost[category][ai-&gt;side-1])
 			{
-				if(AddUnitToBuildque(unit, 2, urgent))
+				if(AddUnitToBuildqueue(unit, 2, urgent))
 					bt-&gt;units_dynamic[unit].requested += 2;
 			}
 			else
 			{
-				if(AddUnitToBuildque(unit, 1, urgent))
+				if(AddUnitToBuildqueue(unit, 1, urgent))
 					bt-&gt;units_dynamic[unit].requested += 1;
 			}
 		}
-		else
-			bt-&gt;BuildFactoryFor(unit);
+		else if(bt-&gt;units_dynamic[unit].constructorsRequested &lt;= 0)
+			bt-&gt;BuildConstructorFor(unit);
 	}
 }
 
@@ -2210,9 +2188,11 @@
 			// find radar
 			radar = bt-&gt;GetRadar(ai-&gt;side, cost, range, false, false);
 
-			if(radar &amp;&amp; bt-&gt;units_dynamic[radar].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[radar].buildersRequested &lt;= 0)
+			if(radar &amp;&amp; bt-&gt;units_dynamic[radar].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(radar);
+				if(bt-&gt;units_dynamic[radar].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(radar);
+
 				radar = bt-&gt;GetRadar(ai-&gt;side, cost, range, false, true);
 			}
 		
@@ -2243,9 +2223,11 @@
 			// find radar
 			radar = bt-&gt;GetRadar(ai-&gt;side, cost, range, true, false);
 
-			if(radar &amp;&amp; bt-&gt;units_dynamic[radar].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[radar].buildersRequested &lt;= 0)
+			if(radar &amp;&amp; bt-&gt;units_dynamic[radar].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(radar);
+				if(bt-&gt;units_dynamic[radar].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(radar);
+				
 				radar = bt-&gt;GetRadar(ai-&gt;side, cost, range, true, true);
 			}
 		
@@ -2316,9 +2298,11 @@
 			// find jammer
 			jammer = bt-&gt;GetJammer(ai-&gt;side, cost, range, false, false);
 
-			if(jammer &amp;&amp; bt-&gt;units_dynamic[jammer].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[jammer].buildersRequested &lt;= 0)
+			if(jammer &amp;&amp; bt-&gt;units_dynamic[jammer].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(jammer);
+				if(bt-&gt;units_dynamic[jammer].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(jammer);
+
 				jammer = bt-&gt;GetRadar(ai-&gt;side, cost, range, false, true);
 			}
 		
@@ -2349,9 +2333,11 @@
 			// find radar
 			jammer = bt-&gt;GetJammer(ai-&gt;side, cost, range, true, false);
 
-			if(jammer &amp;&amp; bt-&gt;units_dynamic[jammer].buildersAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[jammer].buildersRequested &lt;= 0)
+			if(jammer &amp;&amp; bt-&gt;units_dynamic[jammer].constructorsAvailable &lt;= 0)
 			{
-				bt-&gt;BuildBuilderFor(jammer);
+				if(bt-&gt;units_dynamic[jammer].constructorsRequested &lt;= 0)
+					bt-&gt;BuildConstructorFor(jammer);
+
 				jammer = bt-&gt;GetJammer(ai-&gt;side, cost, range, true, true);
 			}
 		
@@ -2511,7 +2497,7 @@
 		urgency[STATIONARY_ARTY] = temp;
 }
 
-void AAIExecute::CheckBuildques()
+void AAIExecute::CheckBuildqueues()
 {
 	int req_units = 0;
 	int active_factory_types = 0;
@@ -2731,18 +2717,18 @@
 
 	int land_mex = bt-&gt;GetMex(ai-&gt;side, cost, eff, false, false, false);
 
-	if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].buildersAvailable &lt;= 0)
+	if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0)
 	{
-		bt-&gt;BuildBuilderFor(land_mex);
+		bt-&gt;BuildConstructorFor(land_mex);
 
 		land_mex = bt-&gt;GetMex(ai-&gt;side, cost, eff, false, false, true);
 	}
 
 	int water_mex = bt-&gt;GetMex(ai-&gt;side, cost, eff, false, true, false);
 
-	if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].buildersAvailable &lt;= 0)
+	if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsAvailable &lt;= 0)
 	{
-		bt-&gt;BuildBuilderFor(water_mex);
+		bt-&gt;BuildConstructorFor(water_mex);
 
 		water_mex = bt-&gt;GetMex(ai-&gt;side, cost, eff, false, true, true);
 	}
@@ -3347,7 +3333,7 @@
 		--ai-&gt;futureFactories;
 
 		for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
-			bt-&gt;units_dynamic[*unit].buildersRequested -= 1;
+			bt-&gt;units_dynamic[*unit].constructorsRequested -= 1;
 
 		// remove future ressource demand now factory has been finished
 		futureRequestedMetal -= bt-&gt;units_static[def-&gt;id].efficiency[0];
@@ -3386,10 +3372,10 @@
 
 	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][ai-&gt;side-1].begin(); fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][ai-&gt;side-1].end(); ++fac)
 	{
-		if(bt-&gt;units_dynamic[*fac].buildersAvailable &gt; 0)
+		if(bt-&gt;units_dynamic[*fac].constructorsAvailable &gt; 0)
 		{
 			my_rating = bt-&gt;GetFactoryRating(*fac);
-			my_rating *= (1 - (bt-&gt;units_static[*fac].cost / bt-&gt;max_cost[STATIONARY_CONSTRUCTOR][ai-&gt;side-1]));
+			my_rating *= (2.0 - (bt-&gt;units_static[*fac].cost / bt-&gt;max_cost[STATIONARY_CONSTRUCTOR][ai-&gt;side-1]));
 
 			if(my_rating &gt; best_rating)
 			{
@@ -3406,7 +3392,7 @@
 		fprintf(ai-&gt;file, &quot;%s requested\n&quot;, bt-&gt;unitList[best_factory-1]-&gt;humanName.c_str());
 
 		for(list&lt;int&gt;::iterator j = bt-&gt;units_static[best_factory].canBuildList.begin(); j != bt-&gt;units_static[best_factory].canBuildList.end(); ++j)
-			bt-&gt;units_dynamic[*j].buildersRequested += 1;
+			bt-&gt;units_dynamic[*j].constructorsRequested += 1;
 	}
 }
 
@@ -3780,4 +3766,4 @@
 		fprintf(ai-&gt;file, &quot;%i th order has been given by %s in frame %i\n&quot;, issued_orders, owner,  cb-&gt;GetCurrentFrame());
 
 	cb-&gt;GiveOrder(unit, c);
-}
+}
\ No newline at end of file

Modified: trunk/AI/Global/AAI/AAIExecute.h
===================================================================
--- trunk/AI/Global/AAI/AAIExecute.h	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIExecute.h	2008-10-02 14:16:09 UTC (rev 6499)
@@ -65,8 +65,8 @@
 	void CheckJammer();
 	void CheckStationaryArty();
 
-	// checks length of buildques and adjusts rate of unit production
-	void CheckBuildques();
+	// checks length of buildqueues and adjusts rate of unit production
+	void CheckBuildqueues();
 
 	//
 	void CheckDefences();
@@ -108,10 +108,10 @@
 	bool AssistConstructionOfCategory(UnitCategory category, int importance = 5);
 
 	// adds a unit to the correct wishlist
-	bool AddUnitToBuildque(int def_id, int number = 1, bool urgent = false);
+	bool AddUnitToBuildqueue(int def_id, int number, bool urgent);
 
 	// returns buildque for a certain factory
-	list&lt;int&gt;* GetBuildqueOfFactory(int def_id);
+	list&lt;int&gt;* GetBuildqueueOfFactory(int def_id);
 
 	// returns the the total ground offensive power of all units
 	float GetTotalGroundPower();

Modified: trunk/AI/Global/AAI/AAIMap.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIMap.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIMap.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -2665,4 +2665,4 @@
 		y = yContMapSize - 1;
 
 	return continent_map[y * xContMapSize + x];
-}
+}
\ No newline at end of file

Modified: trunk/AI/Global/AAI/AAISector.cpp
===================================================================
--- trunk/AI/Global/AAI/AAISector.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAISector.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -789,4 +789,4 @@
 			pos-&gt;x = left + map-&gt;xSectorSize * (0.2f + 0.06f * (float)(rand()%11) );
 			pos-&gt;z = top + map-&gt;ySectorSize * (0.2f + 0.06f * (float)(rand()%11) );
 	}
-}
+}
\ No newline at end of file

Modified: trunk/AI/Global/AAI/AAIUnitTable.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIUnitTable.cpp	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/AAIUnitTable.cpp	2008-10-02 14:16:09 UTC (rev 6499)
@@ -123,8 +123,8 @@
 	// increase/decrease number of available/requested builders for all buildoptions of the builder
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)	
 	{	
-		bt-&gt;units_dynamic[*unit].buildersAvailable += 1;
-		bt-&gt;units_dynamic[*unit].buildersRequested -= 1;
+		bt-&gt;units_dynamic[*unit].constructorsAvailable += 1;
+		bt-&gt;units_dynamic[*unit].constructorsRequested -= 1;
 	}
 
 	if(builder)
@@ -154,7 +154,7 @@
 	
 	// decrease number of available builders for all buildoptions of the builder
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)		
-		bt-&gt;units_dynamic[*unit].buildersAvailable -= 1;
+		bt-&gt;units_dynamic[*unit].constructorsAvailable -= 1;
 
 	// erase from builders list
 	constructors.erase(unit_id);
@@ -194,7 +194,7 @@
 
 	// increase number of builders for all buildoptions of the commander 
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)		
-		++bt-&gt;units_dynamic[*unit].buildersAvailable;
+		++bt-&gt;units_dynamic[*unit].constructorsAvailable;
 	
 }
 
@@ -202,7 +202,7 @@
 {
 	// decrease number of builders for all buildoptions of the commander 
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)	
-		--bt-&gt;units_dynamic[*unit].buildersAvailable;
+		--bt-&gt;units_dynamic[*unit].constructorsAvailable;
 
 	// erase from builders list
 	constructors.erase(unit_id);

Modified: trunk/AI/Global/AAI/aidef.h
===================================================================
--- trunk/AI/Global/AAI/aidef.h	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/AI/Global/AAI/aidef.h	2008-10-02 14:16:09 UTC (rev 6499)
@@ -32,7 +32,7 @@
 #ifndef AIDEF_H
 #define AIDEF_H
 
-#define AAI_VERSION &quot;0.869&quot;
+#define AAI_VERSION &quot;0.87&quot;
 #define MAP_FILE_VERSION &quot;MAP_LEARN_0_80&quot;
 #define TABLE_FILE_VERSION &quot;MOD_LEARN_0_86&quot;
 #define MAP_DATA_VERSION &quot;MAP_DATA_0_86&quot;
@@ -77,7 +77,7 @@
 #define MOVE_TYPE_STATIC_WATER (unsigned int) 512
 
 
-#define MOVE_TYPE_UNIT (unsigned int) 31	// used to filter out unit movement typ (e.g. only MOVE_TYPE_SEA for sumarines (that also have MOVE_TYPE_UNDERWATER set))
+#define MOVE_TYPE_UNIT (unsigned int) 31	// used to filter out unit movement type (e.g. only MOVE_TYPE_SEA for sumarines (that also have MOVE_TYPE_UNDERWATER set))
 #define MOVE_TYPE_CONTINENT_BOUND (unsigned int) 9
 
 
@@ -136,8 +136,8 @@
 	int under_construction;	// how many units of that type are under construction
 	int requested;			// how many units of that type have been requested
 	int active;				// how many units of that type are currently alive
-	int buildersAvailable;	// how many factories/builders available being able to build that unit
-	int buildersRequested;	// how many factories/builders requested being able to build that unit
+	int constructorsAvailable;	// how many factories/builders available being able to build that unit
+	int constructorsRequested;	// how many factories/builders requested being able to build that unit
 };
 
 struct UnitTypeStatic

Modified: trunk/game/AI/AAI/AAI ReadMe.txt
===================================================================
--- trunk/game/AI/AAI/AAI ReadMe.txt	2008-10-02 12:05:50 UTC (rev 6498)
+++ trunk/game/AI/AAI/AAI ReadMe.txt	2008-10-02 14:16:09 UTC (rev 6499)
@@ -105,13 +105,16 @@
 		- Brandon Potter for his TBT 12 cfg file
 
 
+AAI v0.87	- Proper detection of amphibious ground units (was causing AAI to freeze on water maps)
 
+		- Prevent AAI from blocking buildqueues for combat units by requesting too many scouts
+
+
 AAI v0.869	- Added proper handling of resurrected units (however AAI does not build resurrectors atm)
 		
 		- Fixed a bug that could prevent AAI from rebuilding destroyed factories	
 
-
-AAI v0.868	- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
+		- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
 		  their turnrate is not too low)
 
 		- Added some new variables to mod config file:


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001268.html">[Taspring-linux-commit] r6498 - trunk/rts/Map/SMF
</A></li>
	<LI>Next message: <A HREF="001270.html">[Taspring-linux-commit] r6500 - trunk/rts/System
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1269">[ date ]</a>
              <a href="thread.html#1269">[ thread ]</a>
              <a href="subject.html#1269">[ subject ]</a>
              <a href="author.html#1269">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
