<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6796 - in trunk/rts: ExternalAI Game	Game/Camera Game/UI Lua Map Map/SM3 Map/SMF Rendering	Rendering/Env Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/Path Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units	Sim/Units/CommandAI System lib/gml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6796%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%0A%09Game/Camera%20Game/UI%20Lua%20Map%20Map/SM3%20Map/SMF%20Rendering%0A%09Rendering/Env%20Rendering/Textures%20Rendering/UnitModels%0A%09Sim/Features%20Sim/Misc%20Sim/Path%20Sim/Projectiles%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%0A%09Sim/Units/CommandAI%20System%20lib/gml&In-Reply-To=%3C20081017191547.0CEE446ED%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001564.html">
   <LINK REL="Next"  HREF="001566.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6796 - in trunk/rts: ExternalAI Game	Game/Camera Game/UI Lua Map Map/SM3 Map/SMF Rendering	Rendering/Env Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/Path Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units	Sim/Units/CommandAI System lib/gml</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6796%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%0A%09Game/Camera%20Game/UI%20Lua%20Map%20Map/SM3%20Map/SMF%20Rendering%0A%09Rendering/Env%20Rendering/Textures%20Rendering/UnitModels%0A%09Sim/Features%20Sim/Misc%20Sim/Path%20Sim/Projectiles%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%0A%09Sim/Units/CommandAI%20System%20lib/gml&In-Reply-To=%3C20081017191547.0CEE446ED%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6796 - in trunk/rts: ExternalAI Game	Game/Camera Game/UI Lua Map Map/SM3 Map/SMF Rendering	Rendering/Env Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/Path Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units	Sim/Units/CommandAI System lib/gml">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Oct 17 21:15:46 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001564.html">[Taspring-linux-commit] r6795 - trunk/game/LuaUI
</A></li>
        <LI>Next message: <A HREF="001566.html">[Taspring-linux-commit] r6797 - trunk/rts/lib/gml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1565">[ date ]</a>
              <a href="thread.html#1565">[ thread ]</a>
              <a href="subject.html#1565">[ subject ]</a>
              <a href="author.html#1565">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-10-17 21:15:44 +0200 (Fri, 17 Oct 2008)
New Revision: 6796

Modified:
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/ExternalAI/Group.cpp
   trunk/rts/ExternalAI/GroupHandler.cpp
   trunk/rts/Game/Camera/OrbitController.cpp
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/SelectedUnits.cpp
   trunk/rts/Game/UI/GuiHandler.cpp
   trunk/rts/Game/UI/GuiHandler.h
   trunk/rts/Game/UI/MiniMap.cpp
   trunk/rts/Game/UI/MouseHandler.cpp
   trunk/rts/Game/UI/TooltipConsole.cpp
   trunk/rts/Lua/LuaCallInCheck.h
   trunk/rts/Lua/LuaHandle.cpp
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.cpp
   trunk/rts/Map/BaseGroundDrawer.cpp
   trunk/rts/Map/ReadMap.cpp
   trunk/rts/Map/ReadMap.h
   trunk/rts/Map/SM3/Sm3Map.cpp
   trunk/rts/Map/SM3/Sm3Map.h
   trunk/rts/Map/SMF/SmfReadMap.cpp
   trunk/rts/Map/SMF/SmfReadMap.h
   trunk/rts/Rendering/Env/AdvTreeDrawer.cpp
   trunk/rts/Rendering/Env/AdvWater.cpp
   trunk/rts/Rendering/Env/BaseTreeDrawer.cpp
   trunk/rts/Rendering/Env/BaseTreeDrawer.h
   trunk/rts/Rendering/Env/BaseWater.cpp
   trunk/rts/Rendering/Env/BaseWater.h
   trunk/rts/Rendering/Env/BasicTreeDrawer.cpp
   trunk/rts/Rendering/Env/BasicWater.cpp
   trunk/rts/Rendering/Env/BasicWater.h
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/DynWater.cpp
   trunk/rts/Rendering/Env/GrassDrawer.cpp
   trunk/rts/Rendering/FartextureHandler.cpp
   trunk/rts/Rendering/GroundDecalHandler.cpp
   trunk/rts/Rendering/InMapDraw.cpp
   trunk/rts/Rendering/Textures/TextureHandler.cpp
   trunk/rts/Rendering/Textures/TextureHandler.h
   trunk/rts/Rendering/UnitModels/3DModelParser.cpp
   trunk/rts/Rendering/UnitModels/3DModelParser.h
   trunk/rts/Rendering/UnitModels/3DOParser.cpp
   trunk/rts/Rendering/UnitModels/3DOParser.h
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Rendering/UnitModels/s3oParser.cpp
   trunk/rts/Rendering/UnitModels/s3oParser.h
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Misc/QuadField.cpp
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Path/PathManager.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
   trunk/rts/Sim/Units/CommandAI/CommandQueue.h
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/System/SpringApp.cpp
   trunk/rts/System/SpringApp.h
   trunk/rts/lib/gml/gml.cpp
   trunk/rts/lib/gml/gml.h
   trunk/rts/lib/gml/gmlcls.h
   trunk/rts/lib/gml/gmlsrv.h
Log:
Sim can now run in parallel with Draw (still experimental).
Removed some GL calls from Sim.

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,5 +1,6 @@
 // Generalized callback interface - shared between global AI and group AI
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
 #include &quot;Game/Camera.h&quot;
@@ -49,14 +50,6 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;mmgr.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex unitmutex;
-#	endif
-#endif
-
 /* Cast id to unsigned to catch negative ids in the same operations,
 cast MAX_* to unsigned to suppress GCC comparison between signed/unsigned warning. */
 #define CHECK_UNITID(id) ((unsigned)(id) &lt; (unsigned)MAX_UNITS)
@@ -1005,9 +998,7 @@
 	tdu.facing=facing;
 	std::pair&lt;int,CUnitDrawer::TempDrawUnit&gt; tp(gs-&gt;frameNum+lifetime,tdu);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex); // maybe superfluous
-#endif
+	GML_STDMUTEX_LOCK(temp); //unit); // maybe superfluous
 
 	if(transparent)
 		unitDrawer-&gt;tempTransparentDrawUnits.insert(tp);

Modified: trunk/rts/ExternalAI/Group.cpp
===================================================================
--- trunk/rts/ExternalAI/Group.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/ExternalAI/Group.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -142,6 +142,8 @@
 
 bool CGroup::AddUnit(CUnit *unit)
 {
+	GML_STDMUTEX_LOCK(group); // AddUnit
+
 	eventHandler.GroupChanged(id);
 
 	units.insert(unit);
@@ -162,6 +164,8 @@
 
 void CGroup::RemoveUnit(CUnit *unit)
 {
+	GML_STDMUTEX_LOCK(group); // RemoveUnit
+
 	eventHandler.GroupChanged(id);
 	if(ai)
 		ai-&gt;RemoveUnit(unit-&gt;id);
@@ -233,6 +237,7 @@
 
 void CGroup::DrawCommands()
 {
+//	GML_STDMUTEX_LOCK(cai); // DrawCommands. Not needed, protected via CGroupHandler
 	if(units.empty() &amp;&amp; id&gt;=10 &amp;&amp; /*handler==grouphandler*/handler-&gt;team==gu-&gt;myTeam){		//last check is a hack so globalai groups dont get erased
 		handler-&gt;RemoveGroup(this);
 		return;
@@ -341,6 +346,8 @@
 
 void CGroup::ClearUnits(void)
 {
+	GML_STDMUTEX_LOCK(group); // ClearUnits
+
 	eventHandler.GroupChanged(id);
 	while(!units.empty()){
 		(*units.begin())-&gt;SetGroup(0);

Modified: trunk/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- trunk/rts/ExternalAI/GroupHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/ExternalAI/GroupHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -87,6 +87,7 @@
 
 void CGroupHandler::DrawCommands()
 {
+	GML_STDMUTEX_LOCK(cai);
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)!=0)
 			(*ai)-&gt;DrawCommands();

Modified: trunk/rts/Game/Camera/OrbitController.cpp
===================================================================
--- trunk/rts/Game/Camera/OrbitController.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/Camera/OrbitController.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -41,8 +41,8 @@
 	const float3 w = (v / v.Length()); // do not normalize v in-place
 
 	const float d = v.Length();
-	const float e = RAD2DEG(acosf(v.Length2D() / d));
-	const float r = RAD2DEG(acosf(w.x));
+	const float e = RAD2DEG(acos(v.Length2D() / d));
+	const float r = RAD2DEG(acos(w.x));
 
 	distance  = cDistance = d;
 	elevation = cElevation = e;
@@ -223,12 +223,12 @@
 	float tx = cx;
 
 	tx = cx;
-	cx = cx * cosf(beta) + cy * sinf(beta);
-	cy = tx * sinf(beta) + cy * cosf(beta);
+	cx = cx * cos(beta) + cy * sin(beta);
+	cy = tx * sin(beta) + cy * cos(beta);
 
 	tx = cx;
-	cx = cx * cosf(gamma) - cz * sinf(gamma);
-	cz = tx * sinf(gamma) + cz * cosf(gamma);
+	cx = cx * cos(gamma) - cz * sin(gamma);
+	cz = tx * sin(gamma) + cz * cos(gamma);
 
 	return float3(cx, cy, cz);
 }

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/Game.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -435,7 +435,7 @@
 	keyBindings = SAFE_NEW CKeyBindings();
 	keyBindings-&gt;Load(&quot;uikeys.txt&quot;);
 
-	water=CBaseWater::GetWater();
+	water=CBaseWater::GetWater(NULL);
 	for(int a=0;a&lt;MAX_TEAMS;a++)
 		grouphandlers[a] = SAFE_NEW CGroupHandler(a);
 
@@ -637,8 +637,7 @@
 	}
 
 	// Fix water renderer, they depend on screen resolution...
-	delete water;
-	water = CBaseWater::GetWater();
+	water = CBaseWater::GetWater(water);
 
 	eventHandler.ViewResize();
 }
@@ -944,8 +943,6 @@
 		shadowHandler = SAFE_NEW CShadowHandler();
 	}
 	else if (cmd == &quot;water&quot;) {
-		delete water;
-
 		static char rmodes[5][32] = {&quot;basic&quot;, &quot;reflective&quot;, &quot;dynamic&quot;, &quot;reflective&amp;refractive&quot;, &quot;bumpmapped&quot;};
 		int next = 0;
 
@@ -957,7 +954,7 @@
 		}
 		configHandler.SetInt(&quot;ReflectiveWater&quot;, next);
 		logOutput.Print(&quot;Set water rendering mode to %i (%s)&quot;, next, rmodes[next]);
-		water = CBaseWater::GetWater();
+		water = CBaseWater::GetWater(water);
 	}
 	else if (cmd == &quot;advshading&quot;) {
 		static bool canUse = unitDrawer-&gt;advShading;
@@ -2405,7 +2402,6 @@
 	good_fpu_control_registers(&quot;CGame::Update&quot;);
 
 	mouse-&gt;EmptyMsgQueUpdate();
-	thisFps++;
 
 	unsigned timeNow = SDL_GetTicks();
 
@@ -2508,13 +2504,6 @@
 	return true;
 }
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex luamutex;
-#	endif
-#endif
 
 bool CGame::DrawWorld()
 {
@@ -2540,6 +2529,7 @@
 
 	selectedUnits.Draw();
 	eventHandler.DrawWorldPreUnit();
+
 	unitDrawer-&gt;Draw(false);
 	featureHandler-&gt;Draw();
 
@@ -2656,6 +2646,8 @@
 bool CGame::Draw() {
 #endif
 
+	thisFps++;
+
 	ASSERT_UNSYNCED_MODE;
 
 	SetDrawMode(normalDraw);
@@ -2668,6 +2660,11 @@
 	if (luaGaia)  { luaGaia-&gt;CheckStack(); }
 	if (luaRules) { luaRules-&gt;CheckStack(); }
 
+	texturehandler-&gt;Update(); // delayed loading of textures
+	modelParser-&gt;Update(); // delayed fixup of models
+	treeDrawer-&gt;UpdateDraw(); // delete disp lists
+	readmap-&gt;UpdateDraw(); // update heightmap texture
+
 	LuaUnsyncedCtrl::ClearUnitCommandQueues();
 
 	eventHandler.Update();
@@ -3056,21 +3053,20 @@
 	}
 }
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 int numNewFrames=0;
 #endif
 
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 void CGame::SimFrame() {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	SimFrameMT();
+#	else
+#		if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 	if(gmlThreadCount&gt;1) { // if there is more than one cpu, run draw in parallel with sim
 		int oldgsframe=gs-&gt;frameNum;
 		gmlProcessor.AuxWork(&amp;CGame::SimFrameMTcb,this); // start sim thread
 		UnsyncedStuff();
-		while(oldgsframe==*(volatile int *)&amp;(gs-&gt;frameNum)) { // wait until GL calls in script.update() have finished (ugly hack)
-			gmlProcessor.PumpAux();
-			boost::thread::yield();
-		}
 		if(--numNewFrames==0) {
 			gu-&gt;drawFrame++;
 			if (gu-&gt;drawFrame == 0)
@@ -3083,8 +3079,9 @@
 		}
 	}
 	else
-#	endif
+#		endif
 	gmlProcessor.Work(&amp;CGame::SimFrameMTcb,NULL,NULL,this,2,FALSE,NULL,1,2,2,FALSE,&amp;CGame::UnsyncedStuffcb);
+#	endif
 #else
 void CGame::SimFrameMT() {
 #endif
@@ -3114,16 +3111,13 @@
 	if (luaUI)    { luaUI-&gt;GameFrame(gs-&gt;frameNum); }
 	if (luaGaia)  { luaGaia-&gt;GameFrame(gs-&gt;frameNum); }
 	if (luaRules) { luaRules-&gt;GameFrame(gs-&gt;frameNum); }
-/*
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	gmlProcessor.GetQueue();
-#endif*/
+
 	gs-&gt;frameNum++;
 
 	ENTER_UNSYNCED;
 
 	if (!skipping) {
-#if !defined(USE_GML) || !GML_ENABLE_SIM
+#if !defined(USE_GML) || !GML_ENABLE_SIM || GML_ENABLE_SIMLOOP
     UnsyncedStuff();
 #endif
 //		infoConsole-&gt;Update();
@@ -3276,7 +3270,7 @@
 	boost::shared_ptr&lt;const netcode::RawPacket&gt; packet;
 
 	// compute new timeLeft to &quot;smooth&quot; out SimFrame() calls
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 	numNewFrames=0;
 #endif
 	if(!gameServer){
@@ -3294,7 +3288,7 @@
 		int que = 0; // Number of NETMSG_NEWFRAMEs waiting to be processed.
 		unsigned ahead = 0;
 		while ((packet = net-&gt;Peek(ahead))) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 			if (packet-&gt;data[0] == NETMSG_NEWFRAME)
 				++numNewFrames;
 #endif
@@ -3308,7 +3302,7 @@
 	}
 	else
 	{
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 		unsigned ahead = 0;
 		while ((packet = net-&gt;Peek(ahead))) {
 			if (packet-&gt;data[0] == NETMSG_NEWFRAME)
@@ -4644,9 +4638,8 @@
 				count++;
 				delete unit-&gt;cob;
 				unit-&gt;cob = SAFE_NEW CCobInstance(*newScript, unit);
-				delete unit-&gt;localmodel;
-				unit-&gt;localmodel =
-					modelParser-&gt;CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
+				modelParser-&gt;DeleteLocalModel(unit);
+				modelParser-&gt;CreateLocalModel(unit);
 				unit-&gt;cob-&gt;Call(&quot;Create&quot;);
 			}
 		}

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/GameHelper.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 
 #include &quot;Camera.h&quot;
@@ -286,6 +287,8 @@
 	hit = 0x0;
 	CollisionQuery cq;
 
+	GML_RECMUTEX_LOCK(quad); // GuiTraceRay
+
 	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
 	vector&lt;int&gt;::iterator qi;
 
@@ -470,6 +473,9 @@
 {
 	float closeDist = (radius * radius);
 	CUnit* closeUnit = NULL;
+
+	GML_RECMUTEX_LOCK(quad); //GetClosestUnit
+
 	vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
 
 	int tempNum = gs-&gt;tempNum++;
@@ -689,6 +695,9 @@
 float CGameHelper::GuiTraceRayFeature(const float3&amp; start, const float3&amp; dir, float length, CFeature*&amp; feature)
 {
 	float nearHit = length;
+
+	GML_RECMUTEX_LOCK(quad); //GuiTraceRayFeature
+
 	std::vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
 	std::vector&lt;int&gt;::iterator qi;
 

Modified: trunk/rts/Game/SelectedUnits.cpp
===================================================================
--- trunk/rts/Game/SelectedUnits.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/SelectedUnits.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -39,14 +39,6 @@
 #include &quot;Sound.h&quot;
 #include &quot;Util.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-extern boost::mutex caimutex;
-boost::mutex selmutex;
-#	endif
-#endif
-
 extern Uint8 *keys;
 
 
@@ -375,9 +367,7 @@
 		return;
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // AddUnit
 
 	selectedUnits.insert(unit);
 	AddDeathDependence(unit);
@@ -396,9 +386,7 @@
 
 void CSelectedUnits::RemoveUnit(CUnit* unit)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); //RemoveUnit
 
 	selectedUnits.erase(unit);
 	DeleteDeathDependence(unit);
@@ -414,9 +402,7 @@
 
 void CSelectedUnits::ClearSelected()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // ClearSelected
 
 	CUnitSet::iterator ui;
 	ENTER_MIXED;
@@ -435,9 +421,8 @@
 
 void CSelectedUnits::SelectGroup(int num)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // SelectGroup
+//	GML_STDMUTEX_LOCK(group); // SelectGroup. not needed? only reading group
 
 	ClearSelected();
 	selectedGroup=num;
@@ -465,6 +450,9 @@
 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 	glLineWidth(cmdColors.UnitBoxLineWidth());
 
+	GML_RECMUTEX_LOCK(sel); // Draw
+	GML_STDMUTEX_LOCK(group); // Draw
+
 	if (cmdColors.unitBox[3] &gt; 0.0f) {
 		glColor4fv(cmdColors.unitBox);
 
@@ -499,9 +487,7 @@
 				 ((guihandler-&gt;inCommand &gt;= 0) &amp;&amp;
 					(guihandler-&gt;inCommand &lt; guihandler-&gt;commands.size()) &amp;&amp;
 					(guihandler-&gt;commands[guihandler-&gt;inCommand].id &lt; 0)))) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-			boost::mutex::scoped_lock cailock(caimutex);
-#endif
+			GML_STDMUTEX_LOCK(cai); // Draw
 			bool myColor = true;
 			glColor4fv(cmdColors.buildBox);
 			std::list&lt;CBuilderCAI*&gt;::const_iterator bi;
@@ -534,9 +520,7 @@
 
 void CSelectedUnits::DependentDied(CObject *o)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // DependentDied, maybe superfluous - too late anyway
 
 	selectedUnits.erase((CUnit*)o);
 	selectionChanged=true;
@@ -645,8 +629,14 @@
 }
 
 
+// CALLINFO: 
+// DrawMapStuff --&gt; CGuiHandler::GetDefaultCommand --&gt; GetDefaultCmd
+// CMouseHandler::DrawCursor --&gt; DrawCentroidCursor --&gt; CGuiHandler::GetDefaultCommand --&gt; GetDefaultCmd
+// LuaUnsyncedRead::GetDefaultCommand --&gt; CGuiHandler::GetDefaultCommand --&gt; GetDefaultCmd
 int CSelectedUnits::GetDefaultCmd(CUnit* unit, CFeature* feature)
 {
+	GML_RECMUTEX_LOCK(sel); // GetDefaultCmd
+	GML_STDMUTEX_LOCK(group); // GetDefaultCmd
 	// NOTE: the unitDef-&gt;aihint value is being ignored
 	int luaCmd;
 	if (eventHandler.DefaultCommand(unit, feature, luaCmd)) {
@@ -696,7 +686,9 @@
 		possibleCommandsChanged = true;
 }
 
-
+// CALLINFO: 
+// CGame::Draw --&gt; DrawCommands
+// CMiniMap::DrawForReal --&gt; DrawCommands
 void CSelectedUnits::DrawCommands()
 {
 	glDisable(GL_TEXTURE_2D);
@@ -714,6 +706,10 @@
 
 	glLineWidth(cmdColors.QueuedLineWidth());
 
+	GML_RECMUTEX_LOCK(sel); // DrawCommands
+	GML_STDMUTEX_LOCK(group); // DrawCommands
+	GML_STDMUTEX_LOCK(cai); // DrawCommands
+
 	CUnitSet::iterator ui;
 	if (selectedGroup != -1) {
 		CUnitSet&amp; groupUnits = grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;units;
@@ -721,9 +717,6 @@
 			(*ui)-&gt;commandAI-&gt;DrawCommands();
 		}
 	} else {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::mutex::scoped_lock sellock(selmutex);
-#endif
 		for(ui = selectedUnits.begin(); ui != selectedUnits.end(); ++ui) {
 			(*ui)-&gt;commandAI-&gt;DrawCommands();
 		}
@@ -739,8 +732,15 @@
 }
 
 
+// CALLINFO:
+// CTooltipConsole::Draw --&gt; CMouseHandler::GetCurrentTooltip
+// LuaUnsyncedRead::GetCurrentTooltip --&gt; CMouseHandler::GetCurrentTooltip
+// CMouseHandler::GetCurrentTooltip --&gt; CMiniMap::GetToolTip --&gt; GetTooltip
+// CMouseHandler::GetCurrentTooltip --&gt; GetTooltip
 std::string CSelectedUnits::GetTooltip(void)
 {
+	GML_RECMUTEX_LOCK(sel); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
+	GML_STDMUTEX_LOCK(group); // GetTooltip
 	std::string s;
 	if ((selectedGroup != -1) &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
 		s = &quot;Group selected&quot;;
@@ -816,6 +816,8 @@
 
 void CSelectedUnits::SetCommandPage(int page)
 {
+	GML_RECMUTEX_LOCK(sel); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc --&gt; SetCommandPage
+	GML_STDMUTEX_LOCK(group); // SetCommandPage
 	if(selectedGroup!=-1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai){
 		grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;lastCommandPage=page;
 	}

Modified: trunk/rts/Game/UI/GuiHandler.cpp
===================================================================
--- trunk/rts/Game/UI/GuiHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/UI/GuiHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -56,16 +56,6 @@
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/Util.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::mutex caimutex;
-extern boost::mutex selmutex;
-extern boost::recursive_mutex quadmutex;
-#	endif
-#endif
-
 extern Uint8 *keys;
 
 
@@ -461,6 +451,8 @@
 
 int CGuiHandler::FindInCommandPage()
 {
+	GML_RECMUTEX_LOCK(gui); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; FindInCommandPage
+
 	if ((inCommand &lt; 0) || (inCommand &gt;= commands.size())) {
 		return -1;
 	}
@@ -477,6 +469,8 @@
 void CGuiHandler::RevertToCmdDesc(const CommandDescription&amp; cmdDesc,
                                   bool defaultCommand, bool samePage)
 {
+	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc
+
 	for (int a = 0; a &lt; commands.size(); ++a) {
 		if (commands[a].id == cmdDesc.id) {
 			if (defaultCommand) {
@@ -506,6 +500,8 @@
 
 void CGuiHandler::LayoutIcons(bool useSelectionPage)
 {
+	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons
+
 	const bool defCmd =
 		(mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed &amp;&amp;
 		 (defaultCmdMemory &gt;= 0) &amp;&amp; (inCommand &lt; 0) &amp;&amp;
@@ -929,6 +925,8 @@
 
 void CGuiHandler::Update()
 {
+	GML_RECMUTEX_LOCK(gui); // Update - updates inCommand
+
 	SetCursorIcon();
 
 	// Notify LuaUI about groups that have changed
@@ -1040,6 +1038,8 @@
 
 bool CGuiHandler::MousePress(int x, int y, int button)
 {
+	GML_RECMUTEX_LOCK(gui); // MousePress - updates inCommand
+
 	if (button == SDL_BUTTON_MIDDLE) {
 		return false;
 	}
@@ -1079,7 +1079,7 @@
 }
 
 
-void CGuiHandler::MouseRelease(int x, int y, int button)
+void CGuiHandler::MouseRelease(int x, int y, int button, float3&amp; camerapos, float3&amp; mousedir)
 {
 	int iconCmd = -1;
 
@@ -1120,7 +1120,7 @@
 	}
 
 	// not over a button, try to execute a command
-	Command c = GetCommand(x, y, button, false);
+	Command c = GetCommand(x, y, button, false, camerapos, mousedir);
 
 	// if cmd_stop is returned it indicates that no good command could be found
 	if (c.id != CMD_STOP) {
@@ -1134,6 +1134,8 @@
 
 bool CGuiHandler::SetActiveCommand(int cmdIndex, bool rmb)
 {
+	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand
+
 	if (cmdIndex &gt;= (int)commands.size()) {
 		return false;
 	}
@@ -1294,7 +1296,7 @@
 }
 
 
-int CGuiHandler::IconAtPos(int x, int y)
+int CGuiHandler::IconAtPos(int x, int y) // GetToolTip --&gt; IconAtPos
 {
 	const float fx = MouseX(x);
 	const float fy = MouseY(y);
@@ -1440,6 +1442,8 @@
 
 bool CGuiHandler::AboveGui(int x, int y)
 {
+	GML_RECMUTEX_LOCK(gui); // CMouseHandler::GetCurrentTooltip --&gt; IsAbove --&gt; AboveGui
+
 	if (iconsCount &lt;= 0) {
 		return false;
 	}
@@ -1494,8 +1498,11 @@
 	return (minV + (factor * (maxV - minV)));
 }
 
-
-int CGuiHandler::GetDefaultCommand(int x, int y) const
+// CALLINFO: 
+// DrawMapStuff --&gt; GetDefaultCommand
+// CMouseHandler::DrawCursor --&gt; DrawCentroidCursor --&gt; GetDefaultCommand
+// LuaUnsyncedRead::GetDefaultCommand --&gt; GetDefaultCommand
+int CGuiHandler::GetDefaultCommand(int x, int y, float3&amp; camerapos, float3&amp; mousedir) const
 {
 	CInputReceiver* ir = NULL;
 	if (!game-&gt;hideInterface) {
@@ -1506,15 +1513,17 @@
 		return -1;
 	}
 
+	GML_RECMUTEX_LOCK(quad); // GetDefaultCommand
 	CUnit* unit = NULL;
+//	GML_RECMUTEX_LOCK(unit); // GetDefaultCommand
 	CFeature* feature = NULL;
-
+//	GML_RECMUTEX_LOCK(feat); // GetDefaultCommand
 	if ((ir == minimap) &amp;&amp; (minimap-&gt;FullProxy())) {
 		unit = minimap-&gt;GetSelectUnit(minimap-&gt;GetMapPosition(x, y));
 	}
 	else {
-		const float3 camPos = camera-&gt;pos;
-		const float3 camDir = mouse-&gt;dir;
+		const float3 camPos = camerapos;
+		const float3 camDir = mousedir;
 		const float viewRange = gu-&gt;viewRange*1.4f;
 		const float dist = helper-&gt;GuiTraceRay(camPos, camDir, viewRange, unit, 20, true);
 		const float dist2 = helper-&gt;GuiTraceRayFeature(camPos, camDir, viewRange, feature);
@@ -1536,6 +1545,8 @@
 		}
 	}
 
+	GML_RECMUTEX_LOCK(gui); // GetDefaultCommand
+
 	// make sure the command is currently available
 	const int cmd_id = selectedUnits.GetDefaultCmd(unit, feature);
 	for (int c = 0; c &lt; (int)commands.size(); c++) {
@@ -1741,7 +1752,7 @@
 }
 
 
-int CGuiHandler::GetIconPosCommand(int slot) const
+int CGuiHandler::GetIconPosCommand(int slot) const // only called by SetActiveCommand
 {
 	if (slot &lt; 0) {
 		return -1;
@@ -1756,6 +1767,8 @@
 
 bool CGuiHandler::KeyPressed(unsigned short key, bool isRepeat)
 {
+	GML_RECMUTEX_LOCK(gui); // KeyPressed - updates inCommand
+
 	if (key == SDLK_ESCAPE &amp;&amp; activeMousePress) {
 		activeMousePress = false;
 		inCommand = -1;
@@ -1804,6 +1817,8 @@
 bool CGuiHandler::SetActiveCommand(const Action&amp; action,
                                    const CKeySet&amp; ks, int actionIndex)
 {
+	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand
+
 	if (ProcessLocalActions(action)) {
 		return true;
 	}
@@ -2021,6 +2036,8 @@
 
 void CGuiHandler::MenuChoice(std::string s)
 {
+	GML_RECMUTEX_LOCK(gui); // MenuChoice - updates inCommand
+
 	if (activeReceiver == list) {
 		activeReceiver = NULL;
 	}
@@ -2056,6 +2073,8 @@
 
 void CGuiHandler::FinishCommand(int button)
 {
+	GML_RECMUTEX_LOCK(gui); // FinishCommand - updates inCommand
+
 	if ((button == SDL_BUTTON_LEFT) &amp;&amp; (keys[SDLK_LSHIFT] || invertQueueKey)) {
 		needShift=true;
 	} else {
@@ -2073,6 +2092,8 @@
 
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
+	GML_RECMUTEX_LOCK(gui); // GetTooltip
+
 	std::string s;
 
 	const int iconPos = IconAtPos(x, y);
@@ -2097,9 +2118,13 @@
 	return s;
 }
 
-
+// CALLINFO:
+// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; CMiniMap::gettooltip --&gt; GetBuildTooltip
 std::string CGuiHandler::GetBuildTooltip() const
 {
+	GML_RECMUTEX_LOCK(gui); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size()) &amp;&amp;
 	    (commands[inCommand].type == CMDTYPE_ICON_BUILDING)) {
 		return commands[inCommand].tooltip;
@@ -2114,8 +2139,9 @@
 }
 
 
-Command CGuiHandler::GetCommand(int mousex, int mousey, int buttonHint, bool preview)
+Command CGuiHandler::GetCommand(int mousex, int mousey, int buttonHint, bool preview, float3&amp; camerapos, float3&amp; mousedir)
 {
+	GML_RECMUTEX_LOCK(gui); // GetCommand - updates inCommand
 	Command defaultRet;
 	defaultRet.id=CMD_STOP;
 
@@ -2138,7 +2164,7 @@
 		if (mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed) {
 			tempInCommand = defaultCmdMemory;
 		} else {
-			tempInCommand = GetDefaultCommand(mousex, mousey);
+			tempInCommand = GetDefaultCommand(mousex, mousey, camerapos, mousedir);
 		}
 	}
 
@@ -2162,11 +2188,11 @@
 			return c;}
 
 		case CMDTYPE_ICON_MAP:{
-			float dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+			float dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 			if(dist&lt;0){
 				return defaultRet;
 			}
-			float3 pos=camera-&gt;pos+mouse-&gt;dir*dist;
+			float3 pos=camerapos+mousedir*dist;
 			Command c;
 			c.id=commands[tempInCommand].id;
 			c.params.push_back(pos.x);
@@ -2176,7 +2202,7 @@
 			return c;}
 
 		case CMDTYPE_ICON_BUILDING:{
-			float dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+			float dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 			if(dist&lt;0){
 				return defaultRet;
 			}
@@ -2186,15 +2212,15 @@
 				return defaultRet;
 			}
 
-			float3 pos=camera-&gt;pos+mouse-&gt;dir*dist;
+			float3 pos=camerapos+mousedir*dist;
 			std::vector&lt;BuildInfo&gt; buildPos;
 			BuildInfo bi(unitdef, pos, buildFacing);
 			if(GetQueueKeystate() &amp;&amp; button==SDL_BUTTON_LEFT){
 				float dist=ground-&gt;LineGroundCol(mouse-&gt;buttons[SDL_BUTTON_LEFT].camPos,mouse-&gt;buttons[SDL_BUTTON_LEFT].camPos+mouse-&gt;buttons[SDL_BUTTON_LEFT].dir*gu-&gt;viewRange*1.4f);
 				float3 pos2=mouse-&gt;buttons[SDL_BUTTON_LEFT].camPos+mouse-&gt;buttons[SDL_BUTTON_LEFT].dir*dist;
-				buildPos=GetBuildPos(BuildInfo(unitdef,pos2,buildFacing),bi);
+				buildPos=GetBuildPos(BuildInfo(unitdef,pos2,buildFacing),bi,camerapos,mousedir);
 			} else
-				buildPos=GetBuildPos(bi,bi);
+				buildPos=GetBuildPos(bi,bi,camerapos,mousedir);
 
 			if(buildPos.empty()){
 				return defaultRet;
@@ -2219,7 +2245,7 @@
 			Command c;
 
 			c.id=commands[tempInCommand].id;
-			helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
+			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 			if (!unit){
 				return defaultRet;
 			}
@@ -2233,7 +2259,7 @@
 			c.id=commands[tempInCommand].id;
 
 			CUnit* unit=0;
-			float dist2=helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
+			float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 			if(dist2&gt;gu-&gt;viewRange*1.4f-300){
 				return defaultRet;
 			}
@@ -2241,7 +2267,7 @@
 			if (unit!=0) {  // clicked on unit
 				c.params.push_back(unit-&gt;id);
 			} else { // clicked in map
-				float3 pos=camera-&gt;pos+mouse-&gt;dir*dist2;
+				float3 pos=camerapos+mousedir*dist2;
 				c.params.push_back(pos.x);
 				c.params.push_back(pos.y);
 				c.params.push_back(pos.z);
@@ -2265,11 +2291,11 @@
 			c.params.push_back(pos.z);
 
 			if(mouse-&gt;buttons[button].movement&gt;30){		//only create the front if the mouse has moved enough
-				dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+				dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 				if(dist&lt;0){
 					return defaultRet;
 				}
-				float3 pos2 = camera-&gt;pos + mouse-&gt;dir * dist;
+				float3 pos2 = camerapos + mousedir * dist;
 
 				ProcessFrontPositions(pos, pos2);
 
@@ -2304,8 +2330,8 @@
 			if(mouse-&gt;buttons[button].movement&lt;4){
 				CUnit* unit=0;
 				CFeature* feature=0;
-				float dist2=helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
-				float dist3=helper-&gt;GuiTraceRayFeature(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,feature);
+				float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
+				float dist3=helper-&gt;GuiTraceRayFeature(camerapos,mousedir,gu-&gt;viewRange*1.4f,feature);
 
 				if(dist2&gt;gu-&gt;viewRange*1.4f-300 &amp;&amp; (commands[tempInCommand].type!=CMDTYPE_ICON_UNIT_FEATURE_OR_AREA || dist3&gt;gu-&gt;viewRange*1.4f-300)){
 					return defaultRet;
@@ -2316,7 +2342,7 @@
 				} else if (unit!=0 &amp;&amp; commands[tempInCommand].type!=CMDTYPE_ICON_AREA) {  // clicked on unit
 					c.params.push_back(unit-&gt;id);
 				} else { // clicked in map
-					float3 pos=camera-&gt;pos+mouse-&gt;dir*dist2;
+					float3 pos=camerapos+mousedir*dist2;
 					c.params.push_back(pos.x);
 					c.params.push_back(pos.y);
 					c.params.push_back(pos.z);
@@ -2331,11 +2357,11 @@
 				c.params.push_back(pos.x);
 				c.params.push_back(pos.y);
 				c.params.push_back(pos.z);
-				dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+				dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 				if(dist&lt;0){
 					return defaultRet;
 				}
-				float3 pos2=camera-&gt;pos+mouse-&gt;dir*dist;
+				float3 pos2=camerapos+mousedir*dist;
 				c.params.push_back(std::min(maxRadius,pos.distance2D(pos2)));
 			}
 			CreateOptions(c,(button==SDL_BUTTON_LEFT?0:1));
@@ -2349,7 +2375,7 @@
 				CUnit* unit=0;
 
 				float dist2=helper-&gt;GuiTraceRay(
-					camera-&gt;pos, mouse-&gt;dir, gu-&gt;viewRange*1.4f, unit, 20, true);
+					camerapos, mousedir, gu-&gt;viewRange*1.4f, unit, 20, true);
 
 				if(dist2&gt;gu-&gt;viewRange*1.4f-300) {
 					return defaultRet;
@@ -2359,7 +2385,7 @@
 				  // clicked on unit
 					c.params.push_back(unit-&gt;id);
 				} else { // clicked in map
-					float3 pos = camera-&gt;pos + (mouse-&gt;dir * dist2);
+					float3 pos = camerapos + (mousedir * dist2);
 					c.params.push_back(pos.x);
 					c.params.push_back(pos.y);
 					c.params.push_back(pos.z);
@@ -2372,11 +2398,11 @@
 					return defaultRet;
 				}
 				float3 startPos = mouse-&gt;buttons[button].camPos + mouse-&gt;buttons[button].dir * dist;
-				dist = ground-&gt;LineGroundCol(camera-&gt;pos, camera-&gt;pos + mouse-&gt;dir*gu-&gt;viewRange * 1.4f);
+				dist = ground-&gt;LineGroundCol(camerapos, camerapos + mousedir*gu-&gt;viewRange * 1.4f);
 				if(dist&lt;0){
 					return defaultRet;
 				}
-				float3 endPos=camera-&gt;pos+mouse-&gt;dir*dist;
+				float3 endPos=camerapos+mousedir*dist;
 				c.params.push_back(startPos.x);
 				c.params.push_back(startPos.y);
 				c.params.push_back(startPos.z);
@@ -2402,6 +2428,7 @@
 static bool WouldCancelAnyQueued(const BuildInfo&amp; b) {
 	Command c;
 	b.FillCmd(c);
+	GML_RECMUTEX_LOCK(sel); //drawmapstuff -&gt; getbuildpos --&gt; fillrowofbuildpos -&gt; wouldcancelanyqueued
 	CUnitSet::iterator ui = selectedUnits.selectedUnits.begin();
 	for(;ui != selectedUnits.selectedUnits.end(); ++ui){
 		if((*ui)-&gt;commandAI-&gt;WillCancelQueued(c))
@@ -2424,7 +2451,7 @@
 }
 
 // Assuming both builds have the same unitdef
-std::vector&lt;BuildInfo&gt; CGuiHandler::GetBuildPos(const BuildInfo&amp; startInfo, const BuildInfo&amp; endInfo)
+std::vector&lt;BuildInfo&gt; CGuiHandler::GetBuildPos(const BuildInfo&amp; startInfo, const BuildInfo&amp; endInfo, float3&amp; camerapos, float3&amp; mousedir)
 {
 	std::vector&lt;BuildInfo&gt; ret;
 
@@ -2435,13 +2462,14 @@
 	if(GetQueueKeystate() &amp;&amp; keys[SDLK_LCTRL])
 	{
 		CUnit* unit=0;
-		helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
+		GML_RECMUTEX_LOCK(unit); // GetBuildCommand accesses activeunits. drawmapstuff -&gt; getbuildpos
+		helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 		if(unit){
 			other.def = unit-&gt;unitDef;
 			other.pos = unit-&gt;pos;
 			other.buildFacing = unit-&gt;buildFacing;
 		} else {
-			Command c = uh-&gt;GetBuildCommand(camera-&gt;pos,mouse-&gt;dir);
+			Command c = uh-&gt;GetBuildCommand(camerapos,mousedir);
 			if(c.id &lt; 0){
 				assert(c.params.size()==4);
 				other.pos = float3(c.params[0],c.params[1],c.params[2]);
@@ -2534,6 +2562,9 @@
 
 void CGuiHandler::Draw()
 {
+	GML_RECMUTEX_LOCK(gui); // accesses iconsCount. Draw
+//	GML_RECMUTEX_LOCK(quad); // update accesses setcursoricon-&gt;getdefaultcommand-&gt;guitraceray which accesses the quadfield
+
 	Update();
 
 	if ((iconsCount &lt;= 0) &amp;&amp; (luaUI == NULL)) {
@@ -2960,7 +2991,7 @@
 }
 
 
-void CGuiHandler::DrawButtons()
+void CGuiHandler::DrawButtons() // Only called by Draw
 {
 	glLineWidth(1.0f);
 	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
@@ -3128,7 +3159,7 @@
 }
 
 
-void CGuiHandler::DrawMenuName()
+void CGuiHandler::DrawMenuName() // Only called by drawbuttons
 {
 	if (!menuName.empty() &amp;&amp; (iconsCount &gt; 0)) {
 		const char* text = menuName.c_str();
@@ -3161,6 +3192,8 @@
 
 void CGuiHandler::DrawSelectionInfo()
 {
+	GML_RECMUTEX_LOCK(sel); // Draw --&gt; DrawButtons --&gt; DrawSelectionInfo
+
 	if (!selectedUnits.selectedUnits.empty()) {
 		char buf[64];
 
@@ -3197,8 +3230,9 @@
 }
 
 
-void CGuiHandler::DrawNumberInput()
+void CGuiHandler::DrawNumberInput() // Only called by drawbuttons
 {
+	GML_RECMUTEX_LOCK(gui); // DrawNumberInput
 	// draw the value for CMDTYPE_NUMBER commands
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		const CommandDescription&amp; cd = commands[inCommand];
@@ -3422,6 +3456,8 @@
 
 void CGuiHandler::DrawMapStuff(int onMinimap)
 {
+	GML_RECMUTEX_LOCK(gui); // DrawMapStuff
+
 	if (!onMinimap) {
 		glEnable(GL_DEPTH_TEST);
 		glDepthMask(GL_FALSE);
@@ -3431,23 +3467,29 @@
 		glDisable(GL_ALPHA_TEST);
 	}
 
+	float3 camerapos=camera-&gt;pos; 
+	//CCamera tmpcam(*camera);
+	//	CCamera *camera=&tmpcam;
+	float3 mousedir=mouse-&gt;dir;
+
 	// setup for minimap proxying
-	float3 tmpCamPos, tmpMouseDir;
+//	float3 tmpCamPos, tmpMouseDir;
 	const bool minimapCoords =
 		(minimap-&gt;ProxyMode() ||
 		 ((activeReceiver != this) &amp;&amp; !game-&gt;hideInterface &amp;&amp;
 		  (GetReceiverAt(mouse-&gt;lastx, mouse-&gt;lasty) == minimap)));
 	if (minimapCoords) {
-		tmpCamPos = camera-&gt;pos;
-		tmpMouseDir = mouse-&gt;dir;
-		camera-&gt;pos = minimap-&gt;GetMapPosition(mouse-&gt;lastx, mouse-&gt;lasty);
-		mouse-&gt;dir = float3(0.0f, -1.0f, 0.0f);
+//		tmpCamPos = camera-&gt;pos;
+//		tmpMouseDir = mouse-&gt;dir;
+		camerapos = minimap-&gt;GetMapPosition(mouse-&gt;lastx, mouse-&gt;lasty);
+		mousedir = float3(0.0f, -1.0f, 0.0f);
 		if (miniMapMarker &amp;&amp; minimap-&gt;FullProxy() &amp;&amp;
 		    !onMinimap &amp;&amp; !minimap-&gt;GetMinimized()) {
-			DrawMiniMapMarker();
+			DrawMiniMapMarker(camerapos);
 		}
 	}
 
+
 	if (activeMousePress) {
 		int cmdIndex = -1;
 		int button = SDL_BUTTON_LEFT;
@@ -3474,7 +3516,7 @@
 						if (cmdDesc.params.size() &gt; 1) {
 							sizeDiv = atof(cmdDesc.params[1].c_str());
 						}
-						DrawFront(button, maxSize, sizeDiv, !!onMinimap);
+						DrawFront(button, maxSize, sizeDiv, !!onMinimap, camerapos, mousedir);
 					}
 					break;
 				}
@@ -3491,11 +3533,11 @@
 							break;
 						}
 						float3 pos=mouse-&gt;buttons[button].camPos+mouse-&gt;buttons[button].dir*dist;
-						dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+						dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 						if (dist &lt; 0) {
 							break;
 						}
-						float3 pos2 = camera-&gt;pos + mouse-&gt;dir * dist;
+						float3 pos2 = camerapos + mousedir * dist;
 						const float* color;
 						switch (cmdDesc.id) {
 							case CMD_ATTACK:
@@ -3543,13 +3585,13 @@
 							break;
 						}
 						const float3 pos1 = mouse-&gt;buttons[button].camPos+mouse-&gt;buttons[button].dir*dist;
-						dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+						dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 						if (dist &lt; 0) {
 							break;
 						}
-						const float3 pos2 = camera-&gt;pos+mouse-&gt;dir*dist;
+						const float3 pos2 = camerapos+mousedir*dist;
 						if (!onMinimap) {
-							DrawSelectBox(pos1, pos2);
+							DrawSelectBox(pos1, pos2, camerapos);
 						} else {
 							glColor4f(1.0f, 0.0f, 0.0f, 0.5f);
 							glBegin(GL_QUADS);
@@ -3576,16 +3618,15 @@
 
 	// draw the ranges for the unit that is being pointed at
 	CUnit* pointedAt = NULL;
+	GML_RECMUTEX_LOCK(unit); // DrawMapStuff
 	if (GetQueueKeystate()) {
 		CUnit* unit = NULL;
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::recursive_mutex::scoped_lock quadlock(quadmutex); // getselectunit, guitraceray accesses quadfield
-#endif
+//		GML_RECMUTEX_LOCK(quad);  // getselectunit, guitraceray accesses quadfield
 		if (minimapCoords) {
-			unit = minimap-&gt;GetSelectUnit(camera-&gt;pos);
+			unit = minimap-&gt;GetSelectUnit(camerapos);
 		} else {
 			// ignoring the returned distance
-			helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,false);
+			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,false);
 		}
 		if (unit &amp;&amp; ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) || gu-&gt;spectatingFullView)) {
 			pointedAt = unit;
@@ -3675,9 +3716,7 @@
 	// draw buildings we are about to build
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size()) &amp;&amp;
 	    (commands[inCommand].type == CMDTYPE_ICON_BUILDING)) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::mutex::scoped_lock cailock(caimutex);
-#endif
+		GML_STDMUTEX_LOCK(cai); // DrawMapStuff
 		// draw build distance for all immobile builders during build commands
 		std::list&lt;CBuilderCAI*&gt;::const_iterator bi;
 		for (bi = uh-&gt;builderCAIs.begin(); bi != uh-&gt;builderCAIs.end(); ++bi) {
@@ -3697,25 +3736,23 @@
 			}
 		}
 
-		float dist = ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+		float dist = ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 		if (dist &gt; 0) {
 			const UnitDef* unitdef = unitDefHandler-&gt;GetUnitByID(-commands[inCommand].id);
 			if (unitdef) {
 				// get the build information
-				float3 pos = camera-&gt;pos+mouse-&gt;dir*dist;
+				float3 pos = camerapos+mousedir*dist;
 				std::vector&lt;BuildInfo&gt; buildPos;
 				const CMouseHandler::ButtonPress&amp; bp = mouse-&gt;buttons[SDL_BUTTON_LEFT];
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-			boost::recursive_mutex::scoped_lock quadlock(quadmutex); // getbuildpos accesses quadfield
-#endif
+//			GML_RECMUTEX_LOCK(quad);  // getbuildpos accesses quadfield
 				if (GetQueueKeystate() &amp;&amp; bp.pressed) {
 					const float dist = ground-&gt;LineGroundCol(bp.camPos, bp.camPos + bp.dir * gu-&gt;viewRange * 1.4f);
 					const float3 pos2 = bp.camPos + bp.dir * dist;
 					buildPos = GetBuildPos(BuildInfo(unitdef, pos2, buildFacing),
-					                       BuildInfo(unitdef, pos, buildFacing));
+					                       BuildInfo(unitdef, pos, buildFacing), camerapos, mousedir);
 				} else {
 					BuildInfo bi(unitdef, pos, buildFacing);
-					buildPos = GetBuildPos(bi, bi);
+					buildPos = GetBuildPos(bi, bi, camerapos, mousedir);
 				}
 
 				for (std::vector&lt;BuildInfo&gt;::iterator bpi = buildPos.begin(); bpi != buildPos.end(); ++bpi) {
@@ -3767,9 +3804,7 @@
 
 					std::vector&lt;Command&gt; cv;
 					if (GetQueueKeystate()) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-						boost::mutex::scoped_lock sellock(selmutex);
-#endif
+						GML_RECMUTEX_LOCK(sel); // DrawMapStuff
 						Command c;
 						bpi-&gt;FillCmd(c);
 						std::vector&lt;Command&gt; temp;
@@ -3799,13 +3834,12 @@
 		}
 	}
 
+//	GML_RECMUTEX_LOCK(quad); // getdefaultcommand calls guitraceray which accesses quadfield
 	// draw range circles if attack orders are imminent
-	int defcmd = GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty);
+	int defcmd = GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty, camerapos, mousedir);
 	if ((inCommand&gt;=0 &amp;&amp; inCommand&lt;commands.size() &amp;&amp; commands[inCommand].id==CMD_ATTACK) ||
 	    (inCommand==-1 &amp;&amp; defcmd&gt;0 &amp;&amp; commands[defcmd].id==CMD_ATTACK)){
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::mutex::scoped_lock sellock(selmutex);
-#endif
+		GML_RECMUTEX_LOCK(sel); // DrawMapStuff
 		for(CUnitSet::iterator si=selectedUnits.selectedUnits.begin(); si!=selectedUnits.selectedUnits.end(); ++si) {
 			CUnit* unit = *si;
 			if (unit == pointedAt) {
@@ -3827,14 +3861,14 @@
 
 	glLineWidth(1.0f);
 
-	if (minimapCoords) {
+/*	if (minimapCoords) {
 		camera-&gt;pos = tmpCamPos;
 		mouse-&gt;dir = tmpMouseDir;
-	}
+	}*/
 }
 
 
-void CGuiHandler::DrawMiniMapMarker()
+void CGuiHandler::DrawMiniMapMarker(float3&amp; camerapos)
 {
 	const float w = 10.0f;
 	const float h = 30.0f;
@@ -3852,13 +3886,13 @@
 		{ bc[0] * d[7],  bc[1] * d[7],  bc[2] * d[7],  bc[3] },
 	};
 
-	const float groundLevel = ground-&gt;GetHeight(camera-&gt;pos.x, camera-&gt;pos.z);
+	const float groundLevel = ground-&gt;GetHeight(camerapos.x, camerapos.z);
 
 	static float spinTime = 0.0f;
 	spinTime = fmod(spinTime + gu-&gt;lastFrameTime, 60.0f);
 
 	glPushMatrix();
-	glTranslatef(camera-&gt;pos.x, groundLevel, camera-&gt;pos.z);
+	glTranslatef(camerapos.x, groundLevel, camerapos.z);
 	glRotatef(360.0f * (spinTime / 2.0f), 0.0f, 1.0f, 0.0f);
 
 	glEnable(GL_BLEND);
@@ -3888,11 +3922,13 @@
 
 void CGuiHandler::DrawCentroidCursor()
 {
+	GML_RECMUTEX_LOCK(sel); // CMouseHandler::DrawCursor --&gt; DrawCentroidCursor
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 	if (selUnits.size() &lt; 2) {
 		return;
 	}
 
+	GML_RECMUTEX_LOCK(gui); // DrawCentroidCursor
 	int cmd = -1;
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		cmd = commands[inCommand].id;
@@ -3971,7 +4007,7 @@
 }
 
 
-void CGuiHandler::DrawFront(int button,float maxSize,float sizeDiv, bool onMinimap)
+void CGuiHandler::DrawFront(int button,float maxSize,float sizeDiv, bool onMinimap, float3&amp; camerapos, float3&amp; mousedir)
 {
 	CMouseHandler::ButtonPress&amp; bp = mouse-&gt;buttons[button];
 	if(bp.movement&lt;5){
@@ -3982,11 +4018,11 @@
 		return;
 	}
 	float3 pos1=bp.camPos+bp.dir*dist;
-	dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+	dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 	if(dist&lt;0){
 		return;
 	}
-	float3 pos2 = camera-&gt;pos + (mouse-&gt;dir * dist);
+	float3 pos2 = camerapos + (mousedir * dist);
 
 	ProcessFrontPositions(pos1, pos2);
 
@@ -4188,7 +4224,7 @@
 }
 
 
-void CGuiHandler::DrawSelectBox(const float3&amp; pos0, const float3&amp; pos1)
+void CGuiHandler::DrawSelectBox(const float3&amp; pos0, const float3&amp; pos1, float3&amp; camerapos)
 {
 	if (useStencil) {
 		StencilDrawSelectBox(pos0, pos1, invColorSelect);
@@ -4217,9 +4253,9 @@
 	glDisable(GL_CULL_FACE);
 
 	// do a full screen inversion if the camera is within the box
-	if ((camera-&gt;pos.x &gt; mins.x) &amp;&amp; (camera-&gt;pos.x &lt; maxs.x) &amp;&amp;
-	    (camera-&gt;pos.y &gt; mins.y) &amp;&amp; (camera-&gt;pos.y &lt; maxs.y) &amp;&amp;
-	    (camera-&gt;pos.z &gt; mins.z) &amp;&amp; (camera-&gt;pos.z &lt; maxs.z)) {
+	if ((camerapos.x &gt; mins.x) &amp;&amp; (camerapos.x &lt; maxs.x) &amp;&amp;
+	    (camerapos.y &gt; mins.y) &amp;&amp; (camerapos.y &lt; maxs.y) &amp;&amp;
+	    (camerapos.z &gt; mins.z) &amp;&amp; (camerapos.z &lt; maxs.z)) {
 		glDisable(GL_DEPTH_TEST);
 		FullScreenDraw();
 		glEnable(GL_DEPTH_TEST);

Modified: trunk/rts/Game/UI/GuiHandler.h
===================================================================
--- trunk/rts/Game/UI/GuiHandler.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/UI/GuiHandler.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -11,6 +11,8 @@
 #include &quot;KeySet.h&quot;
 #include &quot;KeyBindings.h&quot;
 #include &quot;InputReceiver.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Game/UI/MouseHandler.h&quot;
 
 class CUnit;
 class CglList;
@@ -32,15 +34,16 @@
 		bool KeyPressed(unsigned short key, bool isRepeat);
 		bool KeyReleased(unsigned short key);
 		bool MousePress(int x, int y, int button);
-		void MouseRelease(int x, int y, int button);
+		void MouseRelease(int x, int y, int button) {MouseRelease(x,y,button, ::camera-&gt;pos, ::mouse-&gt;dir);}
+		void MouseRelease(int x, int y, int button, float3&amp; camerapos, float3&amp; mousedir);
 		bool IsAbove(int x, int y);
 		std::string GetTooltip(int x, int y);
 		std::string GetBuildTooltip() const;
 
 		Command GetOrderPreview();
-		Command GetCommand(int mousex, int mousey, int buttonHint, bool preview);
+		Command GetCommand(int mousex, int mousey, int buttonHint, bool preview, float3&amp; camerapos=::camera-&gt;pos, float3&amp; mousedir=::mouse-&gt;dir);
 		std::vector&lt;BuildInfo&gt; GetBuildPos(const BuildInfo&amp; startInfo,
-		                                   const BuildInfo&amp; endInfo);
+			const BuildInfo&amp; endInfo, float3&amp; camerapos, float3&amp; mousedir);
 		                                   // start.def has to be end.def
 
 		bool ReloadConfig(const std::string&amp; filename);
@@ -62,7 +65,7 @@
 
 		bool GetOutlineFonts() const { return outlineFonts; }
 
-		int  GetDefaultCommand(int x, int y) const;
+		int  GetDefaultCommand(int x, int y, float3&amp; camerapos=::camera-&gt;pos, float3&amp; mousedir=::mouse-&gt;dir) const;
 
 		bool SetActiveCommand(int cmdIndex, bool rmb);
 		bool SetActiveCommand(int cmdIndex,
@@ -122,10 +125,10 @@
 		void DrawMenuName();
 		void DrawSelectionInfo();
 		void DrawNumberInput();
-		void DrawMiniMapMarker();
-		void DrawFront(int button, float maxSize, float sizeDiv, bool onMinimap);
+		void DrawMiniMapMarker(float3&amp; camerapos);
+		void DrawFront(int button, float maxSize, float sizeDiv, bool onMinimap, float3&amp; camerapos, float3&amp; mousedir);
 		void DrawArea(float3 pos, float radius, const float* color);
-		void DrawSelectBox(const float3&amp; start, const float3&amp; end);
+		void DrawSelectBox(const float3&amp; start, const float3&amp; end, float3&amp; camerapos);
 		void DrawSelectCircle(const float3&amp; pos, float radius,
 		                      const float* color);
 

Modified: trunk/rts/Game/UI/MiniMap.cpp
===================================================================
--- trunk/rts/Game/UI/MiniMap.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/UI/MiniMap.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -60,17 +60,6 @@
 #include &quot;TimeProfiler.h&quot;
 #include &quot;TooltipConsole.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex unitmutex;
-extern boost::recursive_mutex quadmutex;
-extern boost::recursive_mutex projmutex;
-extern boost::mutex selmutex;
-#	endif
-#endif
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -845,10 +834,10 @@
 void CMiniMap::ProxyMouseRelease(int x, int y, int button)
 {
 	// is this really needed?
-	CCamera *c = camera;
-	camera = new CCamera(*c);
+//	CCamera *c = camera;
+//	camera = new CCamera(*c);
 
-	const float3 tmpMouseDir = mouse-&gt;dir;
+//	const float3 tmpMouseDir = mouse-&gt;dir; 
 
 	float3 mapPos = GetMapPosition(x, y);
 	const CUnit* unit = GetSelectUnit(mapPos);
@@ -861,15 +850,15 @@
 		}
 	}
 
-	mouse-&gt;dir = float3(0.0f, -1.0f, 0.0f);
-	camera-&gt;pos = mapPos;
-	camera-&gt;forward = mouse-&gt;dir;
+	float3 mousedir = float3(0.0f, -1.0f, 0.0f);
+	float3 campos = mapPos;
+//	float3 camfwd = mousedir; // not used?
 
-	guihandler-&gt;MouseRelease(x, y, -button);
+	guihandler-&gt;MouseRelease(x, y, -button, campos, mousedir);
 
-	mouse-&gt;dir = tmpMouseDir;
-	delete camera;
-	camera = c;
+//	mouse-&gt;dir = tmpMouseDir;
+//	delete camera;
+//	camera = c;
 }
 
 
@@ -924,6 +913,8 @@
 		return buildTip;
 	}
 
+	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
+
 	const CUnit* unit = GetSelectUnit(GetMapPosition(x, y));
 	if (unit) {
 		return CTooltipConsole::MakeUnitString(unit);
@@ -1050,17 +1041,13 @@
 	glEnable(GL_ALPHA_TEST);
 	glAlphaFunc(GL_GREATER, 0.0f);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // DrawForReal
 	// draw the units
 	std::list&lt;CUnit*&gt;::iterator ui;
 	for (ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ui++) {
 		DrawUnit(*ui);
 	}
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::recursive_mutex::scoped_lock quadlock(quadmutex); // getselectunit accesses quadfield
-#endif
+//	GML_RECMUTEX_LOCK(quad);  // getselectunit accesses quadfield
 	// highlight the selected unit
 	CUnit* unit = GetSelectUnit(GetMapPosition(mouse-&gt;lastx, mouse-&gt;lasty));
 	if (unit != NULL) {
@@ -1111,62 +1098,63 @@
 
 	glRotatef(-90.0f, +1.0f, 0.0f, 0.0f); // real 'world' coordinates
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+
 	// draw the projectiles
-	if (drawProjectiles &amp;&amp; ph-&gt;ps.size()&gt;0) {
-		CVertexArray* lines=GetVertexArray();
-		CVertexArray* points=GetVertexArray();
-		lines-&gt;Initialize();
-		lines-&gt;EnlargeArrays(ph-&gt;ps.size()*2,0,VA_SIZE_C);
-		points-&gt;Initialize();
-		points-&gt;EnlargeArrays(ph-&gt;ps.size(),0,VA_SIZE_C);
+	if (drawProjectiles) {
+		GML_RECMUTEX_LOCK(proj); // DrawForReal
+		if(ph-&gt;ps.size()&gt;0) {
+			CVertexArray* lines=GetVertexArray();
+			CVertexArray* points=GetVertexArray();
+			lines-&gt;Initialize();
+			lines-&gt;EnlargeArrays(ph-&gt;ps.size()*2,0,VA_SIZE_C);
+			points-&gt;Initialize();
+			points-&gt;EnlargeArrays(ph-&gt;ps.size(),0,VA_SIZE_C);
 
-		static unsigned char red[4]    = {255,0,0,255};
-		static unsigned char redA[4]   = {255,0,0,128};
-		static unsigned char yellow[4] = {255,255,0,255};
-		static unsigned char green[4]  = {0,255,0,25};
-		static unsigned char white[4]  = {255,255,255,25};
+			static unsigned char red[4]    = {255,0,0,255};
+			static unsigned char redA[4]   = {255,0,0,128};
+			static unsigned char yellow[4] = {255,255,0,255};
+			static unsigned char green[4]  = {0,255,0,25};
+			static unsigned char white[4]  = {255,255,255,25};
 
-		Projectile_List::iterator psi;
-		for(psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
-			CProjectile* p = *psi;
+			Projectile_List::iterator psi;
+			for(psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
+				CProjectile* p = *psi;
 
-			if ((p-&gt;owner &amp;&amp; (p-&gt;owner-&gt;allyteam == gu-&gt;myAllyTeam)) ||
-				gu-&gt;spectatingFullView || loshandler-&gt;InLos(p, gu-&gt;myAllyTeam)) {
+				if ((p-&gt;owner &amp;&amp; (p-&gt;owner-&gt;allyteam == gu-&gt;myAllyTeam)) ||
+					gu-&gt;spectatingFullView || loshandler-&gt;InLos(p, gu-&gt;myAllyTeam)) {
 
-				if (dynamic_cast&lt;CGeoThermSmokeProjectile*&gt;(p)) {
-				} else if (dynamic_cast&lt;CGfxProjectile*&gt;(p)) {//Nano-piece
-					points-&gt;AddVertexQC(p-&gt;pos,green);
-				} else if (dynamic_cast&lt;CBeamLaserProjectile*&gt;(p)) {
-					CBeamLaserProjectile&amp; beam = *(CBeamLaserProjectile*)p;
-					unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
-					lines-&gt;AddVertexQC(beam.startPos,color);
-					lines-&gt;AddVertexQC(beam.endPos,color);
-				} else if (dynamic_cast&lt;CLargeBeamLaserProjectile*&gt;(p)) {
-					CLargeBeamLaserProjectile&amp; beam = *(CLargeBeamLaserProjectile*)p;
-					unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
-					lines-&gt;AddVertexQC(beam.startPos,color);
-					lines-&gt;AddVertexQC(beam.endPos,color);
-				} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
-					CLightingProjectile&amp; beam = *(CLightingProjectile*)p;
-					unsigned char color[4] = {(unsigned char)beam.color[0]*255,(unsigned char)beam.color[1]*255,(unsigned char)beam.color[2]*255,255};
-					lines-&gt;AddVertexQC(beam.pos,color);
-					lines-&gt;AddVertexQC(beam.endPos,color);
-				} else if (dynamic_cast&lt;CPieceProjectile*&gt;(p)) {
-					points-&gt;AddVertexQC(p-&gt;pos,red);
-				} else if (dynamic_cast&lt;CWreckProjectile*&gt;(p)) {
-					points-&gt;AddVertexQC(p-&gt;pos,redA);
-				} else if (dynamic_cast&lt;CWeaponProjectile*&gt;(p)) {
-					points-&gt;AddVertexQC(p-&gt;pos,yellow);
-				} else {
-					points-&gt;AddVertexQC(p-&gt;pos,white);
+						if (dynamic_cast&lt;CGeoThermSmokeProjectile*&gt;(p)) {
+						} else if (dynamic_cast&lt;CGfxProjectile*&gt;(p)) {//Nano-piece
+							points-&gt;AddVertexQC(p-&gt;pos,green);
+						} else if (dynamic_cast&lt;CBeamLaserProjectile*&gt;(p)) {
+							CBeamLaserProjectile&amp; beam = *(CBeamLaserProjectile*)p;
+							unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
+							lines-&gt;AddVertexQC(beam.startPos,color);
+							lines-&gt;AddVertexQC(beam.endPos,color);
+						} else if (dynamic_cast&lt;CLargeBeamLaserProjectile*&gt;(p)) {
+							CLargeBeamLaserProjectile&amp; beam = *(CLargeBeamLaserProjectile*)p;
+							unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
+							lines-&gt;AddVertexQC(beam.startPos,color);
+							lines-&gt;AddVertexQC(beam.endPos,color);
+						} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
+							CLightingProjectile&amp; beam = *(CLightingProjectile*)p;
+							unsigned char color[4] = {(unsigned char)beam.color[0]*255,(unsigned char)beam.color[1]*255,(unsigned char)beam.color[2]*255,255};
+							lines-&gt;AddVertexQC(beam.pos,color);
+							lines-&gt;AddVertexQC(beam.endPos,color);
+						} else if (dynamic_cast&lt;CPieceProjectile*&gt;(p)) {
+							points-&gt;AddVertexQC(p-&gt;pos,red);
+						} else if (dynamic_cast&lt;CWreckProjectile*&gt;(p)) {
+							points-&gt;AddVertexQC(p-&gt;pos,redA);
+						} else if (dynamic_cast&lt;CWeaponProjectile*&gt;(p)) {
+							points-&gt;AddVertexQC(p-&gt;pos,yellow);
+						} else {
+							points-&gt;AddVertexQC(p-&gt;pos,white);
+						}
 				}
 			}
+			lines-&gt;DrawArrayC(GL_LINES);
+			points-&gt;DrawArrayC(GL_POINTS);
 		}
-		lines-&gt;DrawArrayC(GL_LINES);
-		points-&gt;DrawArrayC(GL_POINTS);
 	}
 
 	// draw the queued commands
@@ -1186,9 +1174,7 @@
 		guihandler-&gt;DrawMapStuff(!!drawCommands);
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // DrawForReal
 	// draw unit ranges
 	const float radarSquare = (SQUARE_SIZE * RADAR_SIZE);
 	CUnitSet&amp; selUnits = selectedUnits.selectedUnits;

Modified: trunk/rts/Game/UI/MouseHandler.cpp
===================================================================
--- trunk/rts/Game/UI/MouseHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/UI/MouseHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -591,10 +591,13 @@
 		return buildTip;
 	}
 
+	GML_RECMUTEX_LOCK(quad); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
 	const float range = (gu-&gt;viewRange * 1.4f);
 	CUnit* unit = NULL;
+//	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
+	float udist = helper-&gt;GuiTraceRay(camera-&gt;pos, dir, range, unit, 20, true);
 	CFeature* feature = NULL;
-	float udist = helper-&gt;GuiTraceRay(camera-&gt;pos, dir, range, unit, 20, true);
+//	GML_RECMUTEX_LOCK(feat); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
 	float fdist = helper-&gt;GuiTraceRayFeature(camera-&gt;pos, dir, range, feature);
 
 	if ((udist &gt; (range - 300.0f)) &amp;&amp;

Modified: trunk/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- trunk/rts/Game/UI/TooltipConsole.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Game/UI/TooltipConsole.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -22,7 +22,6 @@
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/Util.h&quot;
 
-
 CTooltipConsole* tooltip = 0;
 
 
@@ -69,6 +68,8 @@
 		return;
 	}
 
+//	GML_RECMUTEX_LOCK(quad); // getcurrenttooltip accesses guitraceray which accesses quadfield
+
 	const std::string s = mouse-&gt;GetCurrentTooltip();
 
 	glDisable(GL_TEXTURE_2D);

Modified: trunk/rts/Lua/LuaCallInCheck.h
===================================================================
--- trunk/rts/Lua/LuaCallInCheck.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Lua/LuaCallInCheck.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -26,14 +26,16 @@
 #  define LUA_CALL_IN_CHECK(L)
 #endif
 
-#ifdef USE_GML
-#include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex luamutex;
-#undef LUA_CALL_IN_CHECK
-#define LUA_CALL_IN_CHECK(L) boost::recursive_mutex::scoped_lock lualock(luamutex);
+#ifdef USE_GML // hack to add some degree of thread safety to LUA
+#	include &quot;Rendering/GL/myGL.h&quot;
+#	include &quot;lib/gml/gmlsrv.h&quot;
+#	if GML_ENABLE_SIMDRAW
+#		undef LUA_CALL_IN_CHECK
+#		if DEBUG_LUA
+#			define LUA_CALL_IN_CHECK(L) GML_RECMUTEX_LOCK(lua); LuaCallInCheck ciCheck((L), __FUNCTION__);
+#		else
+#			define LUA_CALL_IN_CHECK(L) GML_RECMUTEX_LOCK(lua);
+#		endif
 #	endif
 #endif
 

Modified: trunk/rts/Lua/LuaHandle.cpp
===================================================================
--- trunk/rts/Lua/LuaHandle.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Lua/LuaHandle.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -169,7 +169,7 @@
 
 void CLuaHandle::CheckStack()
 {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW // Add mutex to avoid bogus errors due to concurrency
 	LUA_CALL_IN_CHECK(L);
 #endif
 	const int top = lua_gettop(L);

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1968,10 +1968,11 @@
 	}
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	if (unit-&gt;transporter == NULL) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		pos += (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		pos += (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	const float3 scale(luaL_optnumber(L, 4, 1.0f),
@@ -2016,10 +2017,11 @@
 	}
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	if (unit-&gt;transporter == NULL) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		pos += (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		pos += (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	const int args = lua_gettop(L); // number of arguments

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -333,6 +333,7 @@
 
 	glLineWidth(cmdColors.QueuedLineWidth());
 
+	GML_STDMUTEX_LOCK(cai);
 	const CUnitSet&amp; units = drawCmdQueueUnits;
 	CUnitSet::const_iterator ui;
 	for (ui = units.begin(); ui != units.end(); ++ui) {

Modified: trunk/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/BaseGroundDrawer.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -21,15 +21,6 @@
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/FastMath.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex featmutex;
-extern boost::mutex selmutex;
-#	endif
-#endif
-
 CBaseGroundDrawer::CBaseGroundDrawer(void)
 {
 	updateFov = true;
@@ -244,6 +235,7 @@
 
 		switch(drawMode) {
 			case drawPath: {
+				GML_RECMUTEX_LOCK(gui); // UpdateExtraTexture
 				if (guihandler-&gt;inCommand &gt; 0 &amp;&amp; guihandler-&gt;inCommand &lt; guihandler-&gt;commands.size() &amp;&amp;
 						guihandler-&gt;commands[guihandler-&gt;inCommand].type == CMDTYPE_ICON_BUILDING) {
 					// use the current build order
@@ -255,9 +247,7 @@
 							} else {
 								const UnitDef* unitdef = unitDefHandler-&gt;GetUnitByID(-guihandler-&gt;commands[guihandler-&gt;inCommand].id);
 								CFeature* f;
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-								boost::recursive_mutex::scoped_lock featlock(featmutex); // testunitbuildsquare accesses features in the quadfield
-#endif
+								GML_RECMUTEX_LOCK(quad); //feat); // UpdateExtraTexture: testunitbuildsquare accesses features in the quadfield
 								if(uh-&gt;TestUnitBuildSquare(BuildInfo(unitdef, float3(x*16+8, 0, y*16+8), guihandler-&gt;buildFacing), f, gu-&gt;myAllyTeam)) {
 									if (f) {
 										m = 0.5f;
@@ -277,9 +267,7 @@
 				}
 				else {
 					// use the first selected unit
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-					boost::mutex::scoped_lock sellock(selmutex);
-#endif
+					GML_RECMUTEX_LOCK(sel); // UpdateExtraTexture
 					if (selectedUnits.selectedUnits.empty()) {
 						return true;
 					}

Modified: trunk/rts/Map/ReadMap.cpp
===================================================================
--- trunk/rts/Map/ReadMap.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/ReadMap.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -241,6 +241,17 @@
 	}
 }
 
+void CReadMap::UpdateDraw() {
+	GML_STDMUTEX_LOCK(map); // UpdateDraw
+	for(std::vector&lt;HeightmapUpdate&gt;::iterator i=heightmapUpdates.begin(); i!=heightmapUpdates.end(); ++i)
+		HeightmapUpdatedNow((*i).x1,(*i).x2,(*i).y1,(*i).y2);
+	heightmapUpdates.clear();
+}
 
+void CReadMap::HeightmapUpdated(int x1, int x2, int y1, int y2) {
+	GML_STDMUTEX_LOCK(map); // HeightmapUpdated
+	heightmapUpdates.push_back(HeightmapUpdate(x1,x2,y1,y2));
+}
+
 CReadMap::IQuadDrawer::~IQuadDrawer() {
 }

Modified: trunk/rts/Map/ReadMap.h
===================================================================
--- trunk/rts/Map/ReadMap.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/ReadMap.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -36,6 +36,13 @@
 	int height;
 };
 
+struct HeightmapUpdate {
+	HeightmapUpdate(int x, int xx, int y, int yy) : x1(x),x2(xx),y1(y),y2(yy) {}
+	int x1;
+	int x2;
+	int y1;
+	int y2;
+};
 
 class CReadMap
 {
@@ -76,7 +83,10 @@
 	CReadMap(); // use LoadMap
 public:
 	virtual CBaseGroundDrawer *GetGroundDrawer () { return 0; }
-	virtual void HeightmapUpdated(int x1, int x2, int y1, int y2)=0;
+	std::vector&lt;HeightmapUpdate&gt; heightmapUpdates;
+	void HeightmapUpdated(int x1, int x2, int y1, int y2);
+	virtual void HeightmapUpdatedNow(int x1, int x2, int y1, int y2)=0;
+	void UpdateDraw();
 	virtual void Update(){};
 	virtual void Explosion(float x,float y,float strength){};
 	virtual GLuint GetShadingTexture () = 0; // a texture with RGB for shading and A for height

Modified: trunk/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- trunk/rts/Map/SM3/Sm3Map.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/SM3/Sm3Map.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -155,7 +155,7 @@
 	return groundDrawer;
 }
 
-void CSm3ReadMap::HeightmapUpdated(int x1, int x2, int y1, int y2)
+void CSm3ReadMap::HeightmapUpdatedNow(int x1, int x2, int y1, int y2)
 {
 	// heightmap is [width+1][height+1]
 	x1-=2; x2+=2;

Modified: trunk/rts/Map/SM3/Sm3Map.h
===================================================================
--- trunk/rts/Map/SM3/Sm3Map.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/SM3/Sm3Map.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -21,7 +21,7 @@
 	void Initialize(const char* mapname); // throws std::runtime_exception on errors
 
 	CBaseGroundDrawer* GetGroundDrawer();
-	void HeightmapUpdated(int x1, int x2, int y1, int y2);
+	void HeightmapUpdatedNow(int x1, int x2, int y1, int y2);
 	const float* GetHeightmap() { return renderer-&gt;GetHeightmap(); }
 
 	inline void SetHeight(int idx, float h) {

Modified: trunk/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/SMF/SmfReadMap.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -156,7 +156,7 @@
 }
 
 
-void CSmfReadMap::HeightmapUpdated(int x1, int x2, int y1, int y2)
+void CSmfReadMap::HeightmapUpdatedNow(int x1, int x2, int y1, int y2)
 {
 	x1-=x1&amp;3;
 	x2+=(20004-x2)&amp;3;

Modified: trunk/rts/Map/SMF/SmfReadMap.h
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Map/SMF/SmfReadMap.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -13,7 +13,7 @@
 	CSmfReadMap(std::string mapname);
 	~CSmfReadMap();
 
-	void HeightmapUpdated(int x1, int x2, int y1, int y2);
+	void HeightmapUpdatedNow(int x1, int x2, int y1, int y2);
 	GLuint GetShadingTexture () { return shadowTex; }
 	GLuint GetGrassShadingTexture () { return minimapTex; }
 	void DrawMinimap ();

Modified: trunk/rts/Rendering/Env/AdvTreeDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 #include &quot;AdvTreeDrawer.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
@@ -19,12 +20,6 @@
 #include &quot;Matrix44f.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-boost::mutex treemutex;
-#	endif
-#endif
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -85,9 +80,7 @@
 
 void CAdvTreeDrawer::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Update
 
 	for(std::list&lt;FallingTree&gt;::iterator fti=fallingTrees.begin();fti!=fallingTrees.end();){
 		fti-&gt;fallPos+=fti-&gt;speed*0.1f;
@@ -344,9 +337,7 @@
 	drawer.treeDistance = treeDistance;
 	drawer.drawDetailed = drawDetailed;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Draw
 
 	// draw far away trees using the map dependent grid visibility
 	oldTreeDistance=treeDistance;
@@ -654,9 +645,7 @@
 	drawer.td = this;
 	drawer.treeDistance = treeDistance;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // DrawShadowPass
 
 	// draw with extraSize=1
 	readmap-&gt;GridVisibility (camera, TREE_SQUARE_SIZE, treeDistance*2*SQUARE_SIZE*TREE_SQUARE_SIZE, &amp;drawer, 1);
@@ -791,11 +780,13 @@
 	int y=(int)pos.z/TREE_SQUARE_SIZE/SQUARE_SIZE;
 	TreeSquareStruct* pTSS=trees+y*treesX+x;
 	if(pTSS-&gt;displist){
-		glDeleteLists(pTSS-&gt;displist,1);
+//		glDeleteLists(pTSS-&gt;displist,1);
+		delDispLists.push_back(pTSS-&gt;displist);
 		pTSS-&gt;displist=0;
 	}
 	if(pTSS-&gt;farDisplist){
-		glDeleteLists(pTSS-&gt;farDisplist,1);
+//		glDeleteLists(pTSS-&gt;farDisplist,1);
+		delDispLists.push_back(pTSS-&gt;farDisplist);
 		pTSS-&gt;farDisplist=0;
 	}
 	grassDrawer-&gt;ResetPos(pos);
@@ -803,9 +794,7 @@
 
 void CAdvTreeDrawer::AddTree(int type, float3 pos, float size)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddTree
 
 	TreeStruct ts;
 	ts.pos=pos;
@@ -818,9 +807,7 @@
 
 void CAdvTreeDrawer::DeleteTree(float3 pos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // DeleteTree
 
 	int hash=(int)pos.x+((int)(pos.z))*20000;
 	int square=((int)pos.x)/(SQUARE_SIZE*TREE_SQUARE_SIZE)+((int)pos.z)/(SQUARE_SIZE*TREE_SQUARE_SIZE)*treesX;
@@ -832,9 +819,7 @@
 
 int CAdvTreeDrawer::AddFallingTree(float3 pos, float3 dir, int type)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddFallingTree
 
 	FallingTree ft;
 
@@ -854,18 +839,14 @@
 
 void CAdvTreeDrawer::AddGrass(float3 pos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddGrass
 
 	grassDrawer-&gt;AddGrass(pos);
 }
 
 void CAdvTreeDrawer::RemoveGrass(int x, int z)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // RemoveGrass
 
 	grassDrawer-&gt;RemoveGrass(x,z);
 }

Modified: trunk/rts/Rendering/Env/AdvWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvWater.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/AdvWater.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -229,6 +229,8 @@
 
 void CAdvWater::UpdateWater(CGame* game)
 {
+	DeleteOldWater(this);
+
 	if ((!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
@@ -319,8 +321,10 @@
 	glBindTexture(GL_TEXTURE_2D, bumpTexture);
 	glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,128,128);
 
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
 
 	camera-&gt;up.x=0;
 	camera-&gt;up.y=1;
@@ -361,7 +365,10 @@
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
+
 	camera-&gt;Update(false);
 }

Modified: trunk/rts/Rendering/Env/BaseTreeDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/BaseTreeDrawer.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BaseTreeDrawer.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -53,3 +53,11 @@
 
 	Draw (treeDistance, drawReflection);
 }
+
+void CBaseTreeDrawer::UpdateDraw() {
+	GML_STDMUTEX_LOCK(tree); // UpdateDraw
+	for(std::vector&lt;GLuint&gt;::iterator i=delDispLists.begin(); i!=delDispLists.end(); ++i)
+		glDeleteLists(*i, 1);
+	delDispLists.clear();
+}
+

Modified: trunk/rts/Rendering/Env/BaseTreeDrawer.h
===================================================================
--- trunk/rts/Rendering/Env/BaseTreeDrawer.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BaseTreeDrawer.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,6 +1,7 @@
 #ifndef __BASE_TREE_DRAWER_H__
 #define __BASE_TREE_DRAWER_H__
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;float3.h&quot;
 
 #define TREE_SQUARE_SIZE 64
@@ -20,6 +21,9 @@
 	virtual void AddTree(int type, float3 pos, float size)=0;
 	virtual void DeleteTree(float3 pos)=0;
 
+	std::vector&lt;GLuint&gt; delDispLists;
+  virtual void UpdateDraw();
+
 	float baseTreeDistance;
 	bool drawTrees;
 

Modified: trunk/rts/Rendering/Env/BaseWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BaseWater.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BaseWater.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -20,18 +20,28 @@
 	drawRefraction=false;
  	noWakeProjectiles=false;
  	drawSolid=false;
+	oldwater=NULL;
 }
 
 CBaseWater::~CBaseWater(void)
 {
+	DeleteOldWater(this);
 }
 
-CBaseWater* CBaseWater::GetWater()
+void CBaseWater::DeleteOldWater(CBaseWater *water) {
+	if(water-&gt;oldwater) {
+		DeleteOldWater(water-&gt;oldwater);
+		delete water-&gt;oldwater;
+		water-&gt;oldwater=NULL;
+	}
+}
+
+CBaseWater* CBaseWater::GetWater(CBaseWater* old)
 {
 	CBaseWater* water = NULL;
 	const int configValue = configHandler.GetInt(&quot;ReflectiveWater&quot;,1);
 	
-	if(configValue==2 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_float &amp;&amp;
+	if(water==NULL &amp;&amp; configValue==2 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_float &amp;&amp;
 	   ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB,&quot;waterDyn.fp&quot;)) {
 		try {
 			water = SAFE_NEW CDynWater;
@@ -41,12 +51,9 @@
 			logOutput.Print(&quot;Loading Dynamic Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
 
-	if(configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
+	if(water==NULL &amp;&amp; configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
 		try {
 			water = SAFE_NEW CBumpWater;
 		} catch (content_error&amp; e) {
@@ -55,12 +62,9 @@
 			logOutput.Print(&quot;Loading Bumpmapped Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
 	
-	if(configValue==3 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_rectangle){
+	if(water==NULL &amp;&amp; configValue==3 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_rectangle){
 		try {
 			water = SAFE_NEW CRefractWater;
 		} catch (content_error&amp; e) {
@@ -69,12 +73,9 @@
 			logOutput.Print(&quot;Loading Refractive Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
 	
-	if(configValue!=0 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp;
+	if(water==NULL &amp;&amp; configValue!=0 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp;
 	   ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB,&quot;water.fp&quot;)){
 		try {
 			water = SAFE_NEW CAdvWater;
@@ -84,10 +85,9 @@
 			logOutput.Print(&quot;Loading Reflective Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
-	
-	return SAFE_NEW CBasicWater;
+	if(water==NULL)
+		water = SAFE_NEW CBasicWater;
+	water-&gt;oldwater=old;
+	return water;
 }

Modified: trunk/rts/Rendering/Env/BaseWater.h
===================================================================
--- trunk/rts/Rendering/Env/BaseWater.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BaseWater.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -11,14 +11,17 @@
 	virtual ~CBaseWater(void);
 
 	virtual void Draw()=0;
-	virtual void Update(){};
+	virtual void Update() {}
 	virtual void UpdateWater(CGame* game)=0;
 	virtual void HeightmapChanged(const int x1, const int y1, const int x2, const int y2){};
 	virtual void AddExplosion(const float3&amp; pos, float strength, float size){};
 	virtual int  GetID() const { return -1; }
 
-	static CBaseWater* GetWater();
+	static CBaseWater* GetWater(CBaseWater* old);
 
+	CBaseWater* oldwater;
+	void DeleteOldWater(CBaseWater *water);
+
 	bool drawReflection;
 	bool drawRefraction;
  	bool noWakeProjectiles;

Modified: trunk/rts/Rendering/Env/BasicTreeDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -16,13 +16,6 @@
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-extern boost::mutex treemutex;
-#	endif
-#endif
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -397,9 +390,7 @@
 	drawer.cy = cy;
 	drawer.treeDistance = treeDistance;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Draw
 
 	readmap-&gt;GridVisibility (camera, TREE_SQUARE_SIZE, treeDistance*2*SQUARE_SIZE*TREE_SQUARE_SIZE, &amp;drawer);
 
@@ -446,9 +437,7 @@
 
 void CBasicTreeDrawer::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Update
 
 }
 
@@ -467,20 +456,18 @@
 	int y=(int)(pos.z/TREE_SQUARE_SIZE/SQUARE_SIZE);
 	TreeSquareStruct* pTSS=trees+y*treesX+x;
 	if(pTSS-&gt;displist){
-		glDeleteLists(pTSS-&gt;displist,1);
+		delDispLists.push_back(pTSS-&gt;displist);
 		pTSS-&gt;displist=0;
 	}
 	if(pTSS-&gt;farDisplist){
-		glDeleteLists(pTSS-&gt;farDisplist,1);
+		delDispLists.push_back(pTSS-&gt;farDisplist);
 		pTSS-&gt;farDisplist=0;
 	}
 }
 
 void CBasicTreeDrawer::AddTree(int type, float3 pos, float size)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddTree
 
 	TreeStruct ts;
 	ts.pos=pos;
@@ -493,9 +480,7 @@
 
 void CBasicTreeDrawer::DeleteTree(float3 pos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // DeleteTree
 
 	int hash=(int)pos.x+((int)(pos.z))*20000;
 	int square=((int)pos.x)/(SQUARE_SIZE*TREE_SQUARE_SIZE)+((int)pos.z)/(SQUARE_SIZE*TREE_SQUARE_SIZE)*treesX;

Modified: trunk/rts/Rendering/Env/BasicWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicWater.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BasicWater.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -41,6 +41,10 @@
 	glDeleteLists(displist,1);
 }
 
+void CBasicWater::UpdateWater(CGame* game) {
+	DeleteOldWater(this);
+}
+
 void CBasicWater::Draw()
 {
 	if (!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)

Modified: trunk/rts/Rendering/Env/BasicWater.h
===================================================================
--- trunk/rts/Rendering/Env/BasicWater.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BasicWater.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -12,7 +12,7 @@
 {
 public:
 	void Draw();
-	void UpdateWater(CGame* game){};
+	void UpdateWater(CGame* game);
 	CBasicWater();
 	virtual ~CBasicWater();
 	int GetID() const { return 0; }

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -687,6 +687,8 @@
 
 void CBumpWater::UpdateWater(CGame* game)
 {
+	DeleteOldWater(this);
+
 	if ((!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
@@ -1057,8 +1059,11 @@
 	if (reflectFBO)
 		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
 
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
+
 	camera-&gt;up.x=0;
 	camera-&gt;up.y=1;
 	camera-&gt;up.z=0;
@@ -1098,7 +1103,10 @@
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
+
 	camera-&gt;Update(false);
 }

Modified: trunk/rts/Rendering/Env/DynWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/DynWater.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/DynWater.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -356,6 +356,8 @@
 
 void CDynWater::UpdateWater(CGame* game)
 {
+	DeleteOldWater(this);
+
 	if ((!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
@@ -407,8 +409,10 @@
 
 void CDynWater::DrawReflection(CGame* game)
 {
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
 
 	camera-&gt;up.x=0;
 	camera-&gt;up.y=1;
@@ -466,8 +470,11 @@
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
+
 	camera-&gt;Update(false);
 }
 

Modified: trunk/rts/Rendering/Env/GrassDrawer.cpp
===================================================================
--- trunk/rts/Rendering/Env/GrassDrawer.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Env/GrassDrawer.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -22,14 +22,6 @@
 #include &quot;System/Exceptions.h&quot;
 //#include &quot;TimeProfiler.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex grassmutex;
-#	endif
-#endif
-
 static const float turfSize=20;				//single turf size
 static const float partTurfSize=turfSize*0.6f;				//single turf size
 static const int grassSquareSize=4;		//mapsquares per grass square
@@ -428,9 +420,7 @@
 	drawer.cy=(int)(camera-&gt;pos.z/bMSsq);
 	drawer.gd = this;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // Draw
 
 	readmap-&gt;GridVisibility (camera, blockMapSize, maxGrassDist, &amp;drawer);
 	CVertexArray *va = drawer.va;
@@ -608,9 +598,7 @@
 	if(grassOff)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // ResetPos
 
 	int a=(int(pos.z/bMSsq)&amp;31)*32+(int(pos.x/bMSsq)&amp;31);
 	if(grass[a].va){
@@ -803,9 +791,7 @@
 	if(grassOff)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // AddGrass
 
 	grassMap[(int(pos.z)/SQUARE_SIZE/grassSquareSize)*gs-&gt;mapx/grassSquareSize+int(pos.x)/SQUARE_SIZE/grassSquareSize]=1;
 }
@@ -815,9 +801,7 @@
 	if(grassOff)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // RemoveGrass
 
 	grassMap[(z/grassSquareSize)*gs-&gt;mapx/grassSquareSize+x/grassSquareSize]=0;
 	ResetPos(float3(x*SQUARE_SIZE,0,z*SQUARE_SIZE));

Modified: trunk/rts/Rendering/FartextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/FartextureHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/FartextureHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 
 #include &quot;FartextureHandler.h&quot;
@@ -9,7 +10,6 @@
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 
-
 CFartextureHandler* fartextureHandler = NULL;
 
 
@@ -43,6 +43,7 @@
  */
 void CFartextureHandler::CreateFarTexture(S3DOModel* model)
 {
+	GML_STDMUTEX_LOCK(tex); // CreateFarTexture
 	pending.push_back(model);
 }
 
@@ -54,6 +55,7 @@
  */
 void CFartextureHandler::CreateFarTextures()
 {
+	GML_STDMUTEX_LOCK(tex); // CreateFarTextures
 	for(std::vector&lt;S3DOModel*&gt;::const_iterator it = pending.begin(); it != pending.end(); ++it) {
 		ReallyCreateFarTexture(*it);
 	}

Modified: trunk/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- trunk/rts/Rendering/GroundDecalHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/GroundDecalHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -22,13 +22,6 @@
 #include &quot;System/Util.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-boost::mutex decalmutex;
-#	endif
-#endif
-
 using std::list;
 using std::min;
 using std::max;
@@ -415,9 +408,7 @@
 		glMatrixMode(GL_MODELVIEW);
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // Draw
 
 	// create and draw the quads for each building decal
 	for (std::vector&lt;BuildingDecalType*&gt;::iterator bdti = buildingDecalTypes.begin(); bdti != buildingDecalTypes.end(); ++bdti) {
@@ -585,9 +576,7 @@
 
 void CGroundDecalHandler::Update(void)
 {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // Update
 	for(std::vector&lt;CUnit *&gt;::iterator i=moveUnits.begin(); i!=moveUnits.end(); ++i)
 		UnitMovedNow(*i);
 	moveUnits.clear();
@@ -688,9 +677,7 @@
 		++a;
 	}
 
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // GetTrackType
 
 	TrackType* tt = SAFE_NEW TrackType;
 	tt-&gt;name = lowerName;
@@ -736,9 +723,7 @@
 	if (decalLevel == 0)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // AddExplosion
 
 	float height = pos.y - ground-&gt;GetHeight2(pos.x, pos.z);
 	if (height &gt;= radius)
@@ -907,9 +892,7 @@
 	if (decalLevel == 0)
 		return;
 
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // AddBuilding
 
 	BuildingDecalType* type = buildingDecalTypes[building-&gt;unitDef-&gt;buildingDecalType];
 	BuildingGroundDecal* decal = SAFE_NEW BuildingGroundDecal;
@@ -947,9 +930,7 @@
 
 void CGroundDecalHandler::RemoveBuilding(CBuilding* building,CUnitDrawer::GhostBuilding* gb)
 {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // RemoveBuilding
 
 	BuildingGroundDecal* decal = building-&gt;buildingDecal;
 	if (!decal)
@@ -978,9 +959,7 @@
 		++a;
 	}
 
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // GetBuildingDecalType
 
 	BuildingDecalType* tt = SAFE_NEW BuildingDecalType;
 	tt-&gt;name = lowerName;

Modified: trunk/rts/Rendering/InMapDraw.cpp
===================================================================
--- trunk/rts/Rendering/InMapDraw.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/InMapDraw.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -308,6 +308,8 @@
 
 void CInMapDraw::Draw(void)
 {
+	GML_STDMUTEX_LOCK(inmap); // Draw
+
 	glDepthMask(0);
 
 	CVertexArray* va = GetVertexArray();
@@ -433,6 +435,8 @@
 void CInMapDraw::LocalPoint(const float3&amp; constPos, const std::string&amp; label,
                             int playerID)
 {
+	GML_STDMUTEX_LOCK(inmap); // LocalPoint
+
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}
@@ -488,6 +492,8 @@
 void CInMapDraw::LocalLine(const float3&amp; constPos1, const float3&amp; constPos2,
                            int playerID)
 {
+	GML_STDMUTEX_LOCK(inmap); // LocalLine
+
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}
@@ -526,6 +532,8 @@
 
 void CInMapDraw::LocalErase(const float3&amp; constPos, int playerID)
 {
+	GML_STDMUTEX_LOCK(inmap); // LocalErase
+
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}

Modified: trunk/rts/Rendering/Textures/TextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -279,7 +279,25 @@
 	glBindTexture(GL_TEXTURE_2D, globalTex);
 }
 
-int CTextureHandler::LoadS3OTexture(const std::string&amp; tex1, const std::string&amp; tex2)
+void CTextureHandler::LoadS3OTexture(S3DOModel *model) {
+	string totalName=model-&gt;tex1+model-&gt;tex2;
+
+	if(s3oTextureNames.find(totalName)!=s3oTextureNames.end()){
+		model-&gt;textureType=s3oTextureNames[totalName];
+	}
+	model-&gt;textureType=0;
+	GML_STDMUTEX_LOCK(model); // LoadS3OTexture
+	loadTextures.push_back(model);
+}
+
+void CTextureHandler::Update() {
+	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;S3DOModel *&gt;::iterator i=loadTextures.begin(); i!=loadTextures.end();++i)
+		(*i)-&gt;textureType=LoadS3OTextureNow((char*)(*i)-&gt;tex1.c_str(),(char*)(*i)-&gt;tex2.c_str());
+	loadTextures.clear();
+}
+
+int CTextureHandler::LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2)
 {
 	string totalName=tex1+tex2;
 

Modified: trunk/rts/Rendering/Textures/TextureHandler.h
===================================================================
--- trunk/rts/Rendering/Textures/TextureHandler.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/Textures/TextureHandler.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -8,6 +8,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 
 struct TexFile;
 class CFileHandler;
@@ -38,7 +39,10 @@
 	UnitTexture* GetTATexture(std::string name, int team, int teamTex);
 	UnitTexture* GetTATexture(const std::string&amp; name);
 
-	int LoadS3OTexture(const std::string&amp; tex1, const std::string&amp; tex2);
+	std::vector&lt;S3DOModel *&gt; loadTextures;
+	void Update();
+	void LoadS3OTexture(S3DOModel *model);
+	int LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2);
 	void SetS3oTexture(int num);
 
 	const S3oTex* GetS3oTex(int num) {

Modified: trunk/rts/Rendering/UnitModels/3DModelParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;algorithm&gt;
 #include &lt;cctype&gt;
 #include &quot;mmgr.h&quot;
@@ -44,6 +45,44 @@
 }
 */
 
+void C3DModelParser::Update() {
+	GML_STDMUTEX_LOCK(model); // Update
+	units3oparser-&gt;Update();
+	unit3doparser-&gt;Update();
+
+	for(std::set&lt;CUnit *&gt;::iterator i=fixLocalModels.begin(); i!=fixLocalModels.end(); ++i)
+		FixLocalModel(*i);
+	fixLocalModels.clear();
+
+	for(std::vector&lt;LocalS3DOModel *&gt;::iterator i=deleteLocalModels.begin(); i!=deleteLocalModels.end(); ++i)
+		delete *i;
+	deleteLocalModels.clear();
+}
+
+void C3DModelParser::CreateLocalModel(CUnit *unit)
+{
+	GML_STDMUTEX_LOCK(model); // CreateLocalModel
+	unit-&gt;localmodel=CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
+	fixLocalModels.insert(unit);
+}
+
+void C3DModelParser::DeleteLocalModel(CUnit *unit)
+{
+	GML_STDMUTEX_LOCK(model); // DeleteLocalModel
+	fixLocalModels.erase(unit);
+	deleteLocalModels.push_back(unit-&gt;localmodel);
+}
+
+void C3DModelParser::FixLocalModel(CUnit *unit)
+{
+	if (unit-&gt;model-&gt;rootobject3do) {
+		unit3doparser-&gt;FixLocalModel(unit-&gt;model,unit-&gt;localmodel,&amp;unit-&gt;cob-&gt;pieces);
+	} else {
+		units3oparser-&gt;FixLocalModel(unit-&gt;model,unit-&gt;localmodel,&amp;unit-&gt;cob-&gt;pieces);
+	}
+}
+
+
 LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel* lm;

Modified: trunk/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -5,6 +5,7 @@
 #include &lt;string&gt;
 #include &quot;Matrix44f.h&quot;
 #include &quot;System/GlobalStuff.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
 
 struct S3DO;
 struct SS3O;
@@ -20,8 +21,14 @@
 	C3DModelParser(void);
 	~C3DModelParser(void);
 
+	void Update();
 	S3DOModel* Load3DModel(std::string name, float scale = 1.0f, int side = 1);
 	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
+	std::set&lt;CUnit *&gt; fixLocalModels;
+	std::vector&lt;LocalS3DOModel *&gt; deleteLocalModels;
+	void DeleteLocalModel(CUnit *unit);
+	void CreateLocalModel(CUnit *unit);
+	void FixLocalModel(CUnit *unit);
 	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 	C3DOParser* unit3doparser;
@@ -44,7 +51,8 @@
 	float minx,miny,minz;
 	float3 relMidPos;
 	int textureType;		//0=3do, otherwise s3o
-
+	std::string tex1;
+	std::string tex2;
 	void DrawStatic();
 };
 

Modified: trunk/rts/Rendering/UnitModels/3DOParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DOParser.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/3DOParser.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -506,7 +506,20 @@
 }
 
 
-void C3DOParser::CreateLists(S3DO *o)
+void C3DOParser::Update() {
+//	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;S3DO *&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
+		CreateListsNow(*i);
+	createLists.clear();
+}
+
+void C3DOParser::CreateLists(S3DO *o) {
+	GML_STDMUTEX_LOCK(model); // CreateLists
+	createLists.push_back(o);
+}
+
+
+void C3DOParser::CreateListsNow(S3DO *o)
 {
 	o-&gt;displist = glGenLists(1);
 	PUSH_CODE_MODE;
@@ -517,7 +530,7 @@
 	POP_CODE_MODE;
 
 	for(std::vector&lt;S3DO*&gt;::iterator bs=o-&gt;childs.begin();bs!=o-&gt;childs.end();bs++){
-		CreateLists(*bs);
+		CreateListsNow(*bs);
 	}
 }
 
@@ -682,6 +695,21 @@
 }
 
 
+void C3DOParser::FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces) {
+	int piecenum=0;
+	FixLocalModel(model-&gt;rootobject3do, lmodel, pieces, &amp;piecenum);
+}
+
+void C3DOParser::FixLocalModel(S3DO *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum) {
+	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
+
+	for(unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
+		(*piecenum)++;
+		FixLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
+	}
+}
+
+
 LocalS3DOModel *C3DOParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel *lmodel = SAFE_NEW LocalS3DOModel;

Modified: trunk/rts/Rendering/UnitModels/3DOParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DOParser.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/3DOParser.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -92,6 +92,8 @@
 	S3DOModel* Load3DO(std::string name, float scale = 1, int side = 1);
 	// S3DOModel* Load3DO(std::string name,float scale,int side,const float3&amp; offsets);
 	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
+	void Update();
+	void FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces);
 
 private:
 	void FindCenter(S3DO* object);
@@ -100,7 +102,9 @@
 	void CalcNormals(S3DO* o);
 
 	void DeleteS3DO(S3DO* o);
+	std::vector&lt;S3DO*&gt; createLists;
 	void CreateLists(S3DO* o);
+	void CreateListsNow(S3DO* o);
 	float scaleFactor;
 
 	void GetPrimitives(S3DO* obj,int pos,int num,vertex_vector* vv,int excludePrim,int side);
@@ -109,6 +113,7 @@
 	bool ReadChild(int pos,S3DO* root,int side, int *numobj);
 	void DrawSub(S3DO* o);
 	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void FixLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
 	std::map&lt;std::string, S3DOModel*&gt; units;
 	std::set&lt;std::string&gt; teamtex;

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -46,10 +46,6 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex unitmutex;
-#	endif
 extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 #endif
 
@@ -219,9 +215,7 @@
 
 void CUnitDrawer::Update(void)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_STDMUTEX_LOCK(temp); //unit); // Update
 
 	while (!tempDrawUnits.empty() &amp;&amp; tempDrawUnits.begin()-&gt;first &lt; gs-&gt;frameNum - 1) {
 		tempDrawUnits.erase(tempDrawUnits.begin());
@@ -414,9 +408,7 @@
 	CUnit* excludeUnit = drawReflection ? NULL : gu-&gt;directControl;
 #endif
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // Draw
 
 #ifdef USE_GML
 	if(multiThreadDrawUnit) {
@@ -443,14 +435,18 @@
 	}
 #endif
 
-	std::multimap&lt;int, TempDrawUnit&gt;::iterator ti;
-	for (ti = tempDrawUnits.begin(); ti != tempDrawUnits.end(); ++ti) {
-		if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
-			glPushMatrix();
-			glTranslatef3(ti-&gt;second.pos);
-			glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
-			ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team)-&gt;DrawStatic();
-			glPopMatrix();
+	{
+		GML_STDMUTEX_LOCK(temp); // Draw
+
+		std::multimap&lt;int, TempDrawUnit&gt;::iterator ti;
+		for (ti = tempDrawUnits.begin(); ti != tempDrawUnits.end(); ++ti) {
+			if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
+				glPushMatrix();
+				glTranslatef3(ti-&gt;second.pos);
+				glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
+				ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team)-&gt;DrawStatic();
+				glPopMatrix();
+			}
 		}
 	}
 
@@ -691,9 +687,7 @@
 
 	CUnit::SetLODFactor(LODScale * LODScaleShadow);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // DrawShadowPass
 
 #ifdef USE_GML
 	if(multiThreadDrawUnitShadow) {
@@ -865,45 +859,45 @@
 	glColor4f(1, 1, 1, 0.3f);
 	glDepthMask(0);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // DrawCloakedUnits
 
-	// units drawn by AI, these aren't really
-	// cloaked but the effect is the same
-	for (std::multimap&lt;int, TempDrawUnit&gt;::iterator ti = tempTransparentDrawUnits.begin(); ti != tempTransparentDrawUnits.end(); ++ti) {
-		if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
-			glPushMatrix();
-			glTranslatef3(ti-&gt;second.pos);
-			glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
-			S3DOModel* model = ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team);
-			model-&gt;DrawStatic();
-			glPopMatrix();
-		}
-		if (ti-&gt;second.drawBorder) {
-			float3 pos = ti-&gt;second.pos;
-			const UnitDef *unitdef = ti-&gt;second.unitdef;
+	{
+		GML_STDMUTEX_LOCK(temp); // DrawCloakedUnits
+		// units drawn by AI, these aren't really
+		// cloaked but the effect is the same
+		for (std::multimap&lt;int, TempDrawUnit&gt;::iterator ti = tempTransparentDrawUnits.begin(); ti != tempTransparentDrawUnits.end(); ++ti) {
+			if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
+				glPushMatrix();
+				glTranslatef3(ti-&gt;second.pos);
+				glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
+				S3DOModel* model = ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team);
+				model-&gt;DrawStatic();
+				glPopMatrix();
+			}
+			if (ti-&gt;second.drawBorder) {
+				float3 pos = ti-&gt;second.pos;
+				const UnitDef *unitdef = ti-&gt;second.unitdef;
 
-			BuildInfo bi(unitdef, pos, ti-&gt;second.facing);
-			pos = helper-&gt;Pos2BuildPos(bi);
+				BuildInfo bi(unitdef, pos, ti-&gt;second.facing);
+				pos = helper-&gt;Pos2BuildPos(bi);
 
-			float xsize = bi.GetXSize() * 4;
-			float ysize = bi.GetYSize() * 4;
-			glColor4f(0.2f, 1, 0.2f, 0.7f);
-			glDisable(GL_TEXTURE_2D);
-			glBegin(GL_LINE_STRIP);
-			glVertexf3(pos+float3( xsize, 1,  ysize));
-			glVertexf3(pos+float3(-xsize, 1,  ysize));
-			glVertexf3(pos+float3(-xsize, 1, -ysize));
-			glVertexf3(pos+float3( xsize, 1, -ysize));
-			glVertexf3(pos+float3( xsize, 1,  ysize));
-			glEnd();
-			glColor4f(1, 1, 1, 0.3f);
-			glEnable(GL_TEXTURE_2D);
+				float xsize = bi.GetXSize() * 4;
+				float ysize = bi.GetYSize() * 4;
+				glColor4f(0.2f, 1, 0.2f, 0.7f);
+				glDisable(GL_TEXTURE_2D);
+				glBegin(GL_LINE_STRIP);
+				glVertexf3(pos+float3( xsize, 1,  ysize));
+				glVertexf3(pos+float3(-xsize, 1,  ysize));
+				glVertexf3(pos+float3(-xsize, 1, -ysize));
+				glVertexf3(pos+float3( xsize, 1, -ysize));
+				glVertexf3(pos+float3( xsize, 1,  ysize));
+				glEnd();
+				glColor4f(1, 1, 1, 0.3f);
+				glEnable(GL_TEXTURE_2D);
+			}
 		}
 	}
 
-
 	// 3dos
 	DrawCloakedUnitsHelper(drawCloaked, ghostBuildings, false);
 
@@ -1514,8 +1508,11 @@
 {
 	glViewport(0, 0, reflTexSize, reflTexSize);
 
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
+
 	camera-&gt;SetFov(90);
 	camera-&gt;forward = camdir;
 	camera-&gt;up = -UpVector;
@@ -1544,8 +1541,10 @@
 
 	glViewport(gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
 }
 
 void CUnitDrawer::QueS3ODraw(CWorldObject* object, int textureType)
@@ -2039,10 +2038,11 @@
 
 	float3 interPos;
 
-	if (!unit-&gt;transporter) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (!trans) {
 		interPos = unit-&gt;pos + (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		interPos = unit-&gt;pos + (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		interPos = unit-&gt;pos + (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	interPos.y += unit-&gt;model-&gt;height + 5.0f;

Modified: trunk/rts/Rendering/UnitModels/s3oParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/s3oParser.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/s3oParser.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -92,7 +92,9 @@
 	model-&gt;rootobject3do=0;
 	object-&gt;isEmpty=true;
 	model-&gt;name=name;
-	model-&gt;textureType=texturehandler-&gt;LoadS3OTexture((char*)&amp;fileBuf[header.texture1],(char*)&amp;fileBuf[header.texture2]);
+	model-&gt;tex1=(char*)&amp;fileBuf[header.texture1];
+	model-&gt;tex2=(char*)&amp;fileBuf[header.texture2];
+	texturehandler-&gt;LoadS3OTexture(model);
 
 	FindMinMax(object);
 
@@ -204,6 +206,22 @@
 	POP_CODE_MODE;
 }
 
+
+void CS3OParser::FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces) {
+	int piecenum=0;
+	FixLocalModel(model-&gt;rootobjects3o, lmodel, pieces, &amp;piecenum);
+}
+
+void CS3OParser::FixLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum) {
+	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
+
+	for (unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
+		(*piecenum)++;
+		FixLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
+	}
+}
+
+
 SS3O* CS3OParser::LoadPiece(unsigned char* buf, int offset,S3DOModel* model)
 {
 	model-&gt;numobjects++;
@@ -317,8 +335,19 @@
 
 }
 
+void CS3OParser::Update() {
+//	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;SS3O *&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
+		CreateListsNow(*i);
+	createLists.clear();
+}
 
-void CS3OParser::CreateLists(SS3O *o)
+void CS3OParser::CreateLists(SS3O *o) {
+	GML_STDMUTEX_LOCK(model); // CreateLists
+	createLists.push_back(o);
+}
+
+void CS3OParser::CreateListsNow(SS3O *o)
 {
 	o-&gt;displist = glGenLists(1);
 	PUSH_CODE_MODE;
@@ -329,7 +358,7 @@
 	POP_CODE_MODE;
 
 	for(std::vector&lt;SS3O*&gt;::iterator bs=o-&gt;childs.begin();bs!=o-&gt;childs.end();bs++){
-		CreateLists(*bs);
+		CreateListsNow(*bs);
 	}
 }
 

Modified: trunk/rts/Rendering/UnitModels/s3oParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/s3oParser.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Rendering/UnitModels/s3oParser.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -40,14 +40,19 @@
 
 	S3DOModel* LoadS3O(std::string name, float scale = 1, int side = 1);
 	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
+	void FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces);
+	void Update();
 
 private:
 	SS3O* LoadPiece(unsigned char* buf, int offset,S3DOModel* model);
 	void DeleteSS3O(SS3O* o);
 	void FindMinMax(SS3O *object);
 	void DrawSub(SS3O* o);
+	std::vector&lt;SS3O *&gt; createLists;
 	void CreateLists(SS3O *o);
+	void CreateListsNow(SS3O *o);
 	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void FixLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
 	std::map&lt;std::string,S3DOModel*&gt; units;
 };

Modified: trunk/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Features/FeatureHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -32,14 +32,6 @@
 #include &quot;creg/STL_Set.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex featmutex;
-#	endif
-#endif
-
 using namespace std;
 
 
@@ -398,9 +390,7 @@
 
 int CFeatureHandler::AddFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // AddFeature
 
 	ASSERT_SYNCED_MODE;
 
@@ -431,9 +421,7 @@
 
 void CFeatureHandler::DeleteFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex); // maybe superfluous
-#endif
+	GML_RECMUTEX_LOCK(feat); // DeleteFeature, maybe superfluous
 
 	ASSERT_SYNCED_MODE;
 	toBeRemoved.push_back(feature-&gt;id);
@@ -482,10 +470,6 @@
 
 void CFeatureHandler::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
-
 	ASSERT_SYNCED_MODE;
 	SCOPED_TIMER(&quot;Feature::Update&quot;);
 
@@ -503,24 +487,29 @@
 			freeIDs.splice(freeIDs.end(), toBeFreedIDs, toBeFreedIDs.begin(), toBeFreedIDs.end());
 	}
 
-	while (!toBeRemoved.empty()) {
-		CFeatureSet::iterator it = activeFeatures.find(toBeRemoved.back());
-		toBeRemoved.pop_back();
-		if (it != activeFeatures.end()) {
-			CFeature* feature = *it;
-			toBeFreedIDs.push_back(feature-&gt;id);
-			activeFeatures.erase(feature);
-
-			if (feature-&gt;drawQuad &gt;= 0) {
-				DrawQuad* dq = &amp;drawQuads[feature-&gt;drawQuad];
-				dq-&gt;features.erase(feature);
+	if(!toBeRemoved.empty()) {
+		GML_RECMUTEX_LOCK(feat); // Update
+		GML_RECMUTEX_LOCK(quad); // Update
+		
+		while (!toBeRemoved.empty()) {
+			CFeatureSet::iterator it = activeFeatures.find(toBeRemoved.back());
+			toBeRemoved.pop_back();
+			if (it != activeFeatures.end()) {
+				CFeature* feature = *it;
+				toBeFreedIDs.push_back(feature-&gt;id);
+				activeFeatures.erase(feature);
+				
+				if (feature-&gt;drawQuad &gt;= 0) {
+					DrawQuad* dq = &amp;drawQuads[feature-&gt;drawQuad];
+					dq-&gt;features.erase(feature);
+				}
+				
+				if (feature-&gt;inUpdateQue) {
+					updateFeatures.erase(feature);
+				}
+				
+				delete feature;
 			}
-
-			if (feature-&gt;inUpdateQue) {
-				updateFeatures.erase(feature);
-			}
-
-			delete feature;
 		}
 	}
 
@@ -540,9 +529,7 @@
 
 void CFeatureHandler::UpdateDrawQuad(CFeature* feature, const float3&amp; newPos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // UpdateDrawQuad
 
 	const int oldDrawQuad = feature-&gt;drawQuad;
 	if (oldDrawQuad &gt;= 0) {
@@ -604,9 +591,7 @@
 	ASSERT_UNSYNCED_MODE;
 	drawFar.clear();
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // Draw
 
 	unitDrawer-&gt;SetupForUnitDrawing();
 	DrawRaw(0, &amp;drawFar);
@@ -639,9 +624,7 @@
 	glPolygonOffset(1,1);
 	glEnable(GL_POLYGON_OFFSET_FILL);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // DrawShadowPass
 
 	unitDrawer-&gt;SetupForUnitDrawing();
 	DrawRaw(1, NULL);

Modified: trunk/rts/Sim/Misc/QuadField.cpp
===================================================================
--- trunk/rts/Sim/Misc/QuadField.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Misc/QuadField.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 // QuadField.cpp: implementation of the CQuadField class.
 //
 //////////////////////////////////////////////////////////////////////
@@ -12,15 +13,6 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;creg/STL_List.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex featmutex;
-boost::recursive_mutex quadmutex;
-#	endif
-#endif
-
 CR_BIND(CQuadField, );
 CR_REG_METADATA(CQuadField, (
 		CR_MEMBER(numQuadsX),
@@ -134,9 +126,7 @@
 			return;
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock quadlock(quadmutex); // possible performance hog
-#endif
+	GML_RECMUTEX_LOCK(quad); // MovedUnit, possible performance hog
 
 	std::vector&lt;int&gt;::iterator qi;
 	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
@@ -374,9 +364,7 @@
 
 void CQuadField::RemoveUnit(CUnit* unit)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock quadlock(quadmutex);
-#endif
+	GML_RECMUTEX_LOCK(quad); // RemoveUnit
 	std::vector&lt;int&gt;::iterator qi;
 	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
 		std::list&lt;CUnit*&gt;::iterator ui;
@@ -397,9 +385,7 @@
 
 void CQuadField::AddFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(quad); //feat); // AddFeature
 
 	vector&lt;int&gt; newQuads=GetQuads(feature-&gt;pos,feature-&gt;radius);
 
@@ -411,9 +397,7 @@
 
 void CQuadField::RemoveFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(quad); //feat); // RemoveFeature
 
 	vector&lt;int&gt; quads=GetQuads(feature-&gt;pos,feature-&gt;radius);
 

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -20,13 +20,6 @@
 #include &quot;FileSystem/ArchiveZip.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-extern boost::mutex selmutex;
-#	endif
-#endif
-
 #define PATHDEBUG false
 
 
@@ -918,9 +911,7 @@
 
 void CPathEstimator::Draw(void)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-					boost::mutex::scoped_lock sellock(selmutex);
-#endif
+//	GML_RECMUTEX_LOCK(sel); // Draw
 	MoveData* md = moveinfo-&gt;GetMoveDataFromName(&quot;TANKSH2&quot;);
 	if (!selectedUnits.selectedUnits.empty() &amp;&amp; (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata)
 		md = (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata;

Modified: trunk/rts/Sim/Path/PathManager.cpp
===================================================================
--- trunk/rts/Sim/Path/PathManager.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Path/PathManager.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -460,9 +460,11 @@
 		path-&gt;peDef-&gt;Draw();
 	}
 	glLineWidth(1);
+#if !defined(USE_GML) || !GML_ENABLE_SIMDRAW // making this threadsafe might be too costly performance wise
 	pf-&gt;Draw();
 	pe-&gt;Draw();
 	pe2-&gt;Draw();
+#endif
 }
 
 

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -40,14 +40,6 @@
 #include &quot;System/creg/STL_List.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#	include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex projmutex;
-#	endif
-#endif
-
 CProjectileHandler* ph;
 
 using namespace std;
@@ -407,9 +399,7 @@
 
 void CProjectileHandler::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // Update
 
 	SCOPED_TIMER(&quot;Projectile handler&quot;);
 
@@ -493,9 +483,7 @@
 	/* 3DO */
 	unitDrawer-&gt;SetupForUnitDrawing();
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // Draw
 
 	va-&gt;Initialize();
 	va-&gt;EnlargeArrays(flying3doPieces-&gt;size()*4,0,VA_SIZE_TN);
@@ -680,9 +668,7 @@
 	glEnable( GL_VERTEX_PROGRAM_ARB );
 	glDisable(GL_TEXTURE_2D);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // DrawShadowPass
 
 	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		if ((gu-&gt;spectatingFullView || loshandler-&gt;InLos(*psi, gu-&gt;myAllyTeam) ||
@@ -725,9 +711,7 @@
 
 void CProjectileHandler::AddProjectile(CProjectile* p)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // AddProjectile
 
 	ps.push_back(p);
 
@@ -840,6 +824,7 @@
 
 void CProjectileHandler::AddGroundFlash(CGroundFlash* flash)
 {
+	GML_RECMUTEX_LOCK(proj); // AddGroundFlash
 	groundFlashes.push_back(flash);
 }
 
@@ -860,14 +845,20 @@
 
 	CGroundFlash::va=GetVertexArray();
 	CGroundFlash::va-&gt;Initialize();
-	CGroundFlash::va-&gt;EnlargeArrays(8*groundFlashes.size(),0,VA_SIZE_TC);
 
-	vector&lt;CGroundFlash*&gt;::iterator gfi;
-	for(gfi=groundFlashes.begin();gfi!=groundFlashes.end();++gfi){
-		if ((*gfi)-&gt;alwaysVisible || gu-&gt;spectatingFullView ||
-		    loshandler-&gt;InAirLos((*gfi)-&gt;pos,gu-&gt;myAllyTeam))
-			(*gfi)-&gt;Draw();
+	{
+		GML_RECMUTEX_LOCK(proj); // DrawGroundFlashes
+
+		CGroundFlash::va-&gt;EnlargeArrays(8*groundFlashes.size(),0,VA_SIZE_TC);
+
+		vector&lt;CGroundFlash*&gt;::iterator gfi;
+		for(gfi=groundFlashes.begin();gfi!=groundFlashes.end();++gfi){
+			if ((*gfi)-&gt;alwaysVisible || gu-&gt;spectatingFullView ||
+				loshandler-&gt;InAirLos((*gfi)-&gt;pos,gu-&gt;myAllyTeam))
+				(*gfi)-&gt;Draw();
+		}
 	}
+
 	CGroundFlash::va-&gt;DrawArrayTC(GL_QUADS);
 
 	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
@@ -905,9 +896,7 @@
 	fp-&gt;rotSpeed=gu-&gt;usRandFloat()*0.1f;
 	fp-&gt;rot=0;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // AddFlyingPiece
 
 	flying3doPieces-&gt;push_back(fp);
 }
@@ -915,9 +904,7 @@
 void CProjectileHandler::AddFlyingPiece(int textureType, int team, float3 pos, float3 speed, SS3OVertex * verts){
 	FlyingPiece_List * pieceList = NULL;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // AddFlyingPiece
 
 	while(flyings3oPieces.size()&lt;=textureType)
 		flyings3oPieces.push_back(vector&lt;FlyingPiece_List*&gt;());

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -19,6 +19,8 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;Rendering/UnitModels/s3oParser.h&quot;
+#include &quot;Rendering/UnitModels/3DOParser.h&quot;
 
 static const float Smoke_Time=60;
 
@@ -447,7 +449,7 @@
 	CMatrix44f transMatrix(interPos + dir * radius * 0.9f,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
-	glCallList(modelDispList);
+	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
 
 	glPopMatrix();
 }

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -17,6 +17,7 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;StarburstProjectile.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;Rendering/UnitModels/s3oParser.h&quot;
 
 static const float Smoke_Time=70;
 
@@ -410,7 +411,7 @@
 	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
 	glMultMatrixf(&amp;transMatrix[0]);
 
-	glCallList(modelDispList);
+	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
 	glPopMatrix();
 }
 

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -36,7 +36,6 @@
 	CR_MEMBER(targetPos),
 	CR_MEMBER(startpos),
 	CR_MEMBER(ttl),
-	CR_MEMBER(modelDispList),
 	CR_MEMBER(colorTeam),
 	CR_MEMBER(bounces),
 	CR_MEMBER(keepBouncing),
@@ -55,7 +54,6 @@
 	target = 0;
 	ttl = 0;
 	colorTeam = 0;
-	modelDispList = 0;
 	interceptTarget = 0;
 	bounces = 0;
 	keepBouncing = true;
@@ -103,11 +101,6 @@
 			S3DOModel* model = modelParser-&gt;Load3DModel(string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
 			if (model) {
 				s3domodel = model;
-
-				if (s3domodel-&gt;rootobject3do)
-					modelDispList = model-&gt;rootobject3do-&gt;displist;
-				else
-					modelDispList = model-&gt;rootobjects3o-&gt;displist;
 			}
 		}
 		collisionFlags = weaponDef-&gt;collisionFlags;
@@ -314,7 +307,8 @@
 	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
-	glCallList(modelDispList);
+//	glCallList(modelDispList);
+	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
 	glPopMatrix();
 }
 
@@ -349,10 +343,10 @@
 				string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
 		if(model){
 			s3domodel = model;
-			if(s3domodel-&gt;rootobject3do)
+/*			if(s3domodel-&gt;rootobject3do)
 				modelDispList= model-&gt;rootobject3do-&gt;displist;
 			else
-				modelDispList= model-&gt;rootobjects3o-&gt;displist;
+				modelDispList= model-&gt;rootobjects3o-&gt;displist;*/
 		}
 	}
 //	collisionFlags = weaponDef-&gt;collisionFlags;

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -43,7 +43,6 @@
 	float3 startpos;
 	int ttl;
 	int colorTeam;
-	unsigned int modelDispList;
 	int bounces;
 	
 	virtual void UpdateGroundBounce();

Modified: trunk/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- trunk/rts/Sim/Units/CommandAI/CommandQueue.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Units/CommandAI/CommandQueue.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,10 +1,10 @@
 #ifndef __COMMAND_QUEUE_H__
 #define __COMMAND_QUEUE_H__
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;deque&gt;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 
-
 // A wrapper class for  std::deque&lt;Command&gt;  to keep track of commands
 
 
@@ -44,16 +44,18 @@
 
 		inline iterator insert(iterator pos, const Command&amp; cmd);
 
-		inline void pop_back()  { queue.pop_back(); }
-		inline void pop_front() { queue.pop_front(); }
+		inline void pop_back()  { GML_STDMUTEX_LOCK(cai); queue.pop_back(); }
+		inline void pop_front() { GML_STDMUTEX_LOCK(cai); queue.pop_front(); }
 
 		inline iterator erase(iterator pos) {
+			GML_STDMUTEX_LOCK(cai); // Erase
 			return queue.erase(pos);
 		}
 		inline iterator erase(iterator first, iterator last) {
+			GML_STDMUTEX_LOCK(cai); // Erase
 			return queue.erase(first, last);
 		}
-		inline void clear() { queue.clear(); }
+		inline void clear() { GML_STDMUTEX_LOCK(cai); queue.clear(); }
 
 		inline iterator       end()         { return queue.end(); }
 		inline const_iterator end()   const { return queue.end(); }
@@ -104,6 +106,7 @@
 
 inline void CCommandQueue::push_back(const Command&amp; cmd)
 {
+	GML_STDMUTEX_LOCK(cai); // push_back
 	queue.push_back(cmd);
 	queue.back().tag = GetNextTag();
 }
@@ -111,6 +114,7 @@
 
 inline void CCommandQueue::push_front(const Command&amp; cmd)
 {
+	GML_STDMUTEX_LOCK(cai); // push_front
 	queue.push_front(cmd);
 	queue.front().tag = GetNextTag();
 }
@@ -121,6 +125,7 @@
 {
 	Command tmpCmd = cmd;
 	tmpCmd.tag = GetNextTag();
+	GML_STDMUTEX_LOCK(cai); // insert
 	return queue.insert(pos, tmpCmd);
 }
 

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -307,7 +307,7 @@
 
 	delete cob;
 	//FIXME delete script;
-	delete localmodel;
+	modelParser-&gt;DeleteLocalModel(this);
 }
 
 
@@ -1357,8 +1357,8 @@
 
 	model = unitDef-&gt;LoadModel(newteam);
 
-	delete localmodel;
-	localmodel = modelParser-&gt;CreateLocalModel(model, &amp;cob-&gt;pieces);
+	modelParser-&gt;DeleteLocalModel(this);
+	modelParser-&gt;CreateLocalModel(this);
 	SetLODCount(0);
 
 	if (unitDef-&gt;isAirBase) {
@@ -2204,7 +2204,7 @@
 	//FIXME script = SAFE_NEW CUnitScript(this);
 	//FIXME localmodel = modelParser-&gt;CreateLocalModel(model, script-&gt;GetPieces());
 	cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + unitDef-&gt;name+&quot;.cob&quot;), this);
-	localmodel = modelParser-&gt;CreateLocalModel(model, &amp;cob-&gt;pieces);
+	modelParser-&gt;CreateLocalModel(this);
 
 	// Calculate the max() of the available weapon reloadtimes
 	int relMax = 0;

Modified: trunk/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Units/UnitHandler.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -41,15 +41,6 @@
 using std::min;
 using std::max;
 
-#ifdef USE_GML
-#	include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex unitmutex;
-boost::mutex caimutex;
-#	endif
-#endif
-
 BuildInfo::BuildInfo(const std::string&amp; name, const float3&amp; p, int facing)
 {
 	def = unitDefHandler-&gt;GetUnitByName(name);
@@ -194,9 +185,7 @@
 
 int CUnitHandler::AddUnit(CUnit *unit)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // AddUnit
 	ASSERT_SYNCED_MODE;
 	int num = (int)(gs-&gt;randFloat()) * ((int)activeUnits.size() - 1);
 	std::list&lt;CUnit*&gt;::iterator ui = activeUnits.begin();
@@ -275,22 +264,19 @@
 	ASSERT_SYNCED_MODE;
 	SCOPED_TIMER(&quot;Unit handler&quot;);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	{
-		boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	if(!toBeRemoved.empty()) {
+		GML_RECMUTEX_LOCK(unit); // Update. Possibly not needed, activeUnits.erase is synchronized.
+		GML_RECMUTEX_LOCK(quad); // Update. Make sure unit does not get partially deleted before before being removed from the quadfield
+		GML_RECMUTEX_LOCK(sel); // Update. Unit is removed from selectedUnits in ~CObject, which is too late.
 
-	while (!toBeRemoved.empty()) {
-		CUnit* delUnit = toBeRemoved.back();
-		toBeRemoved.pop_back();
+		while (!toBeRemoved.empty()) {
+			CUnit* delUnit = toBeRemoved.back();
+			toBeRemoved.pop_back();
 
-		DeleteUnitNow(delUnit);
+			DeleteUnitNow(delUnit);
+		}
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	}
-#endif
-
 	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = activeUnits.begin(); usi != activeUnits.end(); usi++) {
 		(*usi)-&gt;Update();
@@ -608,18 +594,14 @@
 
 void CUnitHandler::AddBuilderCAI(CBuilderCAI* b)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock cailock(caimutex);
-#endif
+	GML_STDMUTEX_LOCK(cai); // AddBuilderCAI
 	builderCAIs.insert(builderCAIs.end(),b);
 }
 
 
 void CUnitHandler::RemoveBuilderCAI(CBuilderCAI* b)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock cailock(caimutex);
-#endif
+	GML_STDMUTEX_LOCK(cai); // RemoveBuilderCAI
 	ListErase&lt;CBuilderCAI*&gt;(builderCAIs, b);
 }
 
@@ -670,6 +652,7 @@
 Command CUnitHandler::GetBuildCommand(float3 pos, float3 dir){
 	float3 tempF1 = pos;
 	std::list&lt;CUnit*&gt;::iterator ui = this-&gt;activeUnits.begin();
+	GML_STDMUTEX_LOCK(cai); // GetBuildCommand
 	CCommandQueue::iterator ci;
 	for(; ui != this-&gt;activeUnits.end(); ui++){
 		if((*ui)-&gt;team == gu-&gt;myTeam){

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 
 #include &quot;UnitLoader.h&quot;
@@ -73,6 +74,9 @@
 CUnit* CUnitLoader::LoadUnit(const string&amp; name, float3 pos, int team,
                              bool build, int facing, const CUnit* builder)
 {
+	GML_RECMUTEX_LOCK(unit); // LoadUnit. Unitinit puts unit in the quadfield and activeUnits -
+	GML_RECMUTEX_LOCK(quad); // LoadUnit. - make sure other threads cannot access an incomplete unit
+
 	CUnit* unit;
 
 	SCOPED_TIMER(&quot;Unit loader&quot;);
@@ -335,7 +339,7 @@
 
 //FIXME: add unitdef tag cob/cobscript/cobfilename
 	unit-&gt;cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + name + &quot;.cob&quot;), unit);
-	unit-&gt;localmodel = modelParser-&gt;CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
+	modelParser-&gt;CreateLocalModel(unit);
 
 
 	for (unsigned int i = 0; i &lt; ud-&gt;weapons.size(); i++) {

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/System/SpringApp.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -848,7 +848,6 @@
 	}
 }
 
-
 /**
  * @return return code of activecontroller draw function
  *
@@ -860,28 +859,43 @@
 	if (FSAA)
 		glEnable(GL_MULTISAMPLE_ARB);
 
+#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
 	mouseInput-&gt;Update();
-
+#endif
 	int ret = 1;
 	if (activeController) {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 		int frame=gu-&gt;drawFrame;
-#endif
+#	endif
 		if (!activeController-&gt;Update()) {
 			ret = 0;
 		} else {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 			if(frame==gu-&gt;drawFrame) { // only draw if it was not done in parallel with sim
+#	endif
+#else
+				if(!gs-&gt;frameNum) {
+					mouseInput-&gt;Update();
+					activeController-&gt;Update();
+					if(gs-&gt;frameNum)
+						startsim=1;
+				}
 #endif
 				gu-&gt;drawFrame++;
 				if (gu-&gt;drawFrame == 0) {
 					gu-&gt;drawFrame++;
 				}
 				ret = activeController-&gt;Draw();
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+				gmlProcessor.PumpAux(); 
+#endif
+#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 			}
+#	endif
+		}
 #endif
-		}
 	}
 
 	VSync.Delay();
@@ -893,6 +907,28 @@
 	return ret;
 }
 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+int SpringApp::Sim() {
+	while(keeprunning &amp;&amp; !startsim)
+		boost::thread::yield();
+	unsigned lastSim = SDL_GetTicks();
+	while(keeprunning) {
+		mouseInput-&gt;Update();
+		if (activeController) {
+			if (!activeController-&gt;Update()) {
+				return 0;
+			}
+			gmlProcessor.GetQueue();
+		}
+		unsigned lastSimDiff=SDL_GetTicks()-lastSim;
+		if(lastSimDiff&lt;=10)
+			SDL_Delay(10-lastSimDiff);
+		lastSim = SDL_GetTicks();
+	}
+	return 1;
+}
+#endif
+
 /**
  * Tests SDL keystates and sets values
  * in key array
@@ -940,6 +976,12 @@
 	SDL_EventState (SDL_SYSWMEVENT, SDL_ENABLE);
 #endif
 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	keeprunning=1;
+	startsim=0;
+	gmlProcessor.AuxWork(&amp;SpringApp::Simcb,this); // start sim thread
+#endif
+
 	SDL_Event event;
 	bool done = false;
 
@@ -1075,6 +1117,12 @@
 	}
 	ENTER_MIXED;
 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	keeprunning=0; // wait for sim to finish
+	while(!gmlProcessor.PumpAux())
+		boost::thread::yield();
+#endif
+
 	// Shutdown
 	Shutdown();
 	return 0;

Modified: trunk/rts/System/SpringApp.h
===================================================================
--- trunk/rts/System/SpringApp.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/System/SpringApp.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -1,9 +1,11 @@
 #ifndef SPRING_APP
 #define SPRING_APP
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;string&gt;
 #include &lt;SDL_types.h&gt;
 
+
 class BaseCmd;
 class CGameController;
 
@@ -30,6 +32,12 @@
 	bool SetSDLVideoMode(); 			//!&lt; Sets SDL video mode
 	void Shutdown (); 				//!&lt; Shuts down application
 	int Update (); 					//!&lt; Run simulation and draw
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	int Sim (); 					//!&lt; Simulation  loop
+	static void Simcb(void *c) {((SpringApp *)c)-&gt;Sim();}
+	volatile int keeprunning;
+	volatile int startsim;
+#endif
 	void UpdateSDLKeys (); 				//!&lt; Update SDL key array
 	bool GetDisplayGeometry();
 	void SetupViewportGeometry();

Modified: trunk/rts/lib/gml/gml.cpp
===================================================================
--- trunk/rts/lib/gml/gml.cpp	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/lib/gml/gml.cpp	2008-10-17 19:15:44 UTC (rev 6796)
@@ -34,6 +34,8 @@
 #include &quot;StdAfx.h&quot;
 #ifdef USE_GML
 #include &quot;gmlcls.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
 
 #define EXEC_RUN (BYTE *)NULL
 #define EXEC_SYNC (BYTE *)-1
@@ -54,7 +56,7 @@
 int gmlThreadNumber=0;
 #endif
 int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
-int gmlThreadCountOverride=0; // number of threads to use (can be manually overridden here)
+int gmlThreadCountOverride=configHandler.GetInt(&quot;HardwareThreadCount&quot;, 0); // number of threads to use (can be manually overridden here)
 int gmlItemsConsumed=0;
 
 // gmlCPUCount returns the number of CPU cores
@@ -173,6 +175,29 @@
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSPROC *&gt; gmlBufferServer(&amp;glGenBuffers, 2, 0);
 
 
+#if GML_ENABLE_SIMDRAW
+#include &lt;boost/thread/mutex.hpp&gt;
+boost::mutex caimutex;
+boost::mutex decalmutex;
+boost::mutex treemutex;
+boost::mutex modelmutex;
+boost::mutex texmutex;
+boost::mutex mapmutex;
+boost::mutex groupmutex;
+boost::mutex inmapmutex;
+boost::mutex tempmutex;
+
+#include &lt;boost/thread/recursive_mutex.hpp&gt;
+boost::recursive_mutex unitmutex;
+boost::recursive_mutex quadmutex;
+boost::recursive_mutex selmutex;
+boost::recursive_mutex luamutex;
+boost::recursive_mutex featmutex;
+boost::recursive_mutex projmutex;
+boost::recursive_mutex grassmutex;
+boost::recursive_mutex guimutex;
+#endif
+
 // GMLqueue implementation
 gmlQueue::gmlQueue():
 ReadPos(0),WritePos(0),WriteSize(0),Read(0),Write(0),Locked1(FALSE),Locked2(FALSE),Reloc(FALSE),Sync(EXEC_RUN),WasSynced(FALSE),
@@ -882,7 +907,6 @@
 	BYTE *p=Read;
 	BYTE *e=ReadPos;
 	BYTE *ptr=NULL;
-
 	while(p&lt;e) {
 //		GML_DEBUG(&quot;Cmd &quot;,*(int *)p, 2);
 		QueueHandler(p,ptr);
@@ -891,12 +915,28 @@
 //	GML_DEBUG(&quot;Execute &quot;,procs, 2);
 }
 
+void gmlQueue::ExecuteDebug() {
+	int procs=0;
+	BYTE *p=Read;
+	BYTE *e=ReadPos;
+	BYTE *ptr=NULL;
+
+	while(p&lt;e) {
+		if(*(int *)p!=0)
+			logOutput.Print(&quot;GML error: OpenGL call #%d in SimFrame()&quot;,*(int *)p);
+		QueueHandler(p,ptr);
+		++procs;
+	}
+	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
+		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
+}
+
 #include &quot;gmlsrv.h&quot;
 
-// Execute - executes all GL commands in the current read queue.
+// ExecuteSynced - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points
 // to return values to the worker thread)
-void gmlQueue::ExecuteSynced() {
+void gmlQueue::ExecuteSynced(void (gmlQueue::*execfun)() ) {
 //int procs=0;
 #if GML_ALTERNATE_SYNCMODE
 	BYTE *s;
@@ -908,7 +948,7 @@
 			if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 				gmlUpdateServers();
 			if(GetRead()) {
-				Execute();
+				(this-&gt;*execfun)();
 				ReleaseRead();
 			}
 			boost::thread::yield();
@@ -918,14 +958,14 @@
 			Sync=EXEC_SYNC; //NEW
 			GetRead(TRUE);
 			Sync=EXEC_RUN; // cannot allow worker to continue before right queue acquired
-			Execute();
+			(this-&gt;*execfun)();
 			ReleaseRead();
 			break;
 		}
 
 		Sync=EXEC_RUN; // sync confirmed
 		GetRead(TRUE);
-		Execute();
+		(this-&gt;*execfun)();
 		Sync=EXEC_RES; // result available
 		ReleaseRead();
 		while(Sync==EXEC_RES) // waiting for worker to acquire result

Modified: trunk/rts/lib/gml/gml.h
===================================================================
--- trunk/rts/lib/gml/gml.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/lib/gml/gml.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -133,12 +133,50 @@
 
 #include &quot;gmlimp.h&quot;
 #include &quot;gmldef.h&quot;
+
 #define GML_VECTOR gmlVector
 #define GML_CLASSVECTOR gmlClassVector
 
+#if GML_ENABLE_SIMDRAW
+#include &lt;boost/thread/mutex.hpp&gt;
+extern boost::mutex caimutex;
+extern boost::mutex decalmutex;
+extern boost::mutex treemutex;
+extern boost::mutex modelmutex;
+extern boost::mutex texmutex;
+extern boost::mutex mapmutex;
+extern boost::mutex groupmutex;
+extern boost::mutex inmapmutex;
+extern boost::mutex tempmutex;
+
+#include &lt;boost/thread/recursive_mutex.hpp&gt;
+extern boost::recursive_mutex unitmutex;
+extern boost::recursive_mutex quadmutex;
+extern boost::recursive_mutex selmutex;
+extern boost::recursive_mutex luamutex;
+extern boost::recursive_mutex featmutex;
+extern boost::recursive_mutex projmutex;
+extern boost::recursive_mutex grassmutex;
+extern boost::recursive_mutex guimutex;
+
+#define GML_STDMUTEX_LOCK(name) boost::mutex::scoped_lock name##lock(name##mutex)
+#define GML_RECMUTEX_LOCK(name) boost::recursive_mutex::scoped_lock name##lock(name##mutex)
+
 #else
+
+#define GML_STDMUTEX_LOCK(name)
+#define GML_RECMUTEX_LOCK(name)
+
+#endif
+
+#else
+
 #define GML_VECTOR std::vector
 #define GML_CLASSVECTOR std::vector
+
+#define GML_STDMUTEX_LOCK(name)
+#define GML_RECMUTEX_LOCK(name)
+
 #endif // USE_GML
 
 #endif

Modified: trunk/rts/lib/gml/gmlcls.h
===================================================================
--- trunk/rts/lib/gml/gmlcls.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/lib/gml/gmlcls.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -34,9 +34,12 @@
 #endif
 
 #define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
+#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; 0) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
+#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; 0) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
+
 #define GML_ENABLE_DRAW (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
-#define GML_SERVER_GLCALL 1 // allow the server thread (0) to make direct GL calls
-#define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 1
+#define GML_SERVER_GLCALL 1 // allows the server thread (0) to make direct GL calls
+#define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 4
 #define GML_USE_NO_ERROR 1 // glGetError always returns success (to improve performance)
 #define GML_USE_DEFAULT 1// compile/link/buffer status always returns TRUE/COMPLETE (to improve performance)
 #define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
@@ -803,7 +806,8 @@
 	BOOL_ GetRead(BOOL_ critical=FALSE);
 	void SyncRequest();
 	void Execute();
-	void ExecuteSynced();
+	void ExecuteSynced(void (gmlQueue::*execfun)() =&amp;gmlQueue::Execute);
+	void ExecuteDebug();
 };
 
 

Modified: trunk/rts/lib/gml/gmlsrv.h
===================================================================
--- trunk/rts/lib/gml/gmlsrv.h	2008-10-17 18:11:10 UTC (rev 6795)
+++ trunk/rts/lib/gml/gmlsrv.h	2008-10-17 19:15:44 UTC (rev 6796)
@@ -10,7 +10,6 @@
 #define GMLSRV_H
 
 #ifdef USE_GML
-#define GML_MT_TEST 0 // run Draw() parallel with SimFrame(). Highly experimental, not fully working yet.
 
 #include &lt;boost/thread/barrier.hpp&gt;
 #include &lt;boost/bind.hpp&gt;
@@ -112,6 +111,7 @@
 
 };
 
+
 template&lt;class R,class A, typename U&gt;
 class gmlClientServer {
 public:
@@ -324,24 +324,14 @@
 	}
 
 	void GetQueue() {
-		int thread=gmlThreadNumber;
-//		int processed=1;
+		gmlQueue *qd=&amp;gmlQueues[gmlThreadCount];
 
-//		GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
+		if(!qd-&gt;WasSynced &amp;&amp; qd-&gt;Write==qd-&gt;WritePos)
+			return;
 
-		gmlQueue *qd=&amp;gmlQueues[thread];
-
 		BOOL_ isq1=qd-&gt;Write==qd-&gt;Queue1;
 
-    qd-&gt;GetWrite(TRUE);
-/*#if GML_ALTERNATE_SYNCMODE
-		if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(ex-&gt;syncmode?TRUE:2))
-#else
-		if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(TRUE))
-#endif
-			processed=0;
-		if(processed &amp;&amp; qd-&gt;GetWrite(TRUE))
-			processed=0;*/
+		qd-&gt;GetWrite(qd-&gt;WasSynced?2:TRUE);
 
 		if(isq1) {
 			while(!qd-&gt;Locked1 &amp;&amp; *(BYTE * volatile *)&amp;qd-&gt;Pos1!=qd-&gt;Queue1)
@@ -363,18 +353,17 @@
 			if(qd-&gt;Reloc)
 				qd-&gt;Realloc();
 			if(qd-&gt;GetRead()) {
-				qd-&gt;Execute();
+				qd-&gt;ExecuteDebug();
 				qd-&gt;ReleaseRead();
 			}
 			if(qd-&gt;Sync) {
-				qd-&gt;ExecuteSynced();
+				qd-&gt;ExecuteSynced(&amp;gmlQueue::ExecuteDebug);
 			}
 			if(AuxClientsReady==0)
 				return FALSE;
 			else
 				++AuxClientsReady;
 		}
-//		auxworker=NULL; // move to auxsub?
 		return TRUE;
 	}
 
@@ -407,7 +396,7 @@
 		qd-&gt;ReleaseWrite();
 
 		++AuxClientsReady;	
-		auxworker=NULL; // move to auxsub?
+		auxworker=NULL;
 	}
 
 	void gmlClientAux() {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001564.html">[Taspring-linux-commit] r6795 - trunk/game/LuaUI
</A></li>
	<LI>Next message: <A HREF="001566.html">[Taspring-linux-commit] r6797 - trunk/rts/lib/gml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1565">[ date ]</a>
              <a href="thread.html#1565">[ thread ]</a>
              <a href="subject.html#1565">[ subject ]</a>
              <a href="author.html#1565">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
