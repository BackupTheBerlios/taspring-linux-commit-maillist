<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6801 - in branches/caiinterface: .	Documentation game/LuaUI installer installer/include	installer/nsis_plugins installer/sections rts/ExternalAI	rts/Game rts/Game/Camera rts/Game/UI rts/Lua rts/Map	rts/Map/SM3 rts/Map/SMF rts/Rendering rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/CommandAI rts/System	rts/System/FileSystem rts/System/Script rts/lib rts/lib/gml	tools/DedicatedServer tools/unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6801%20-%20in%20branches/caiinterface%3A%20.%0A%09Documentation%20game/LuaUI%20installer%20installer/include%0A%09installer/nsis_plugins%20installer/sections%20rts/ExternalAI%0A%09rts/Game%20rts/Game/Camera%20rts/Game/UI%20rts/Lua%20rts/Map%0A%09rts/Map/SM3%20rts/Map/SMF%20rts/Rendering%20rts/Rendering/Env%0A%09rts/Rendering/Textures%20rts/Rendering/UnitModels%0A%09rts/Sim/Features%20rts/Sim/Misc%20rts/Sim/MoveTypes%20rts/Sim/Path%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/WeaponProjectiles%0A%09rts/Sim/Units%20rts/Sim/Units/CommandAI%20rts/System%0A%09rts/System/FileSystem%20rts/System/Script%20rts/lib%20rts/lib/gml%0A%09tools/DedicatedServer%20tools/unitsync&In-Reply-To=%3C20081017225005.886C746ED%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001569.html">
   <LINK REL="Next"  HREF="001571.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6801 - in branches/caiinterface: .	Documentation game/LuaUI installer installer/include	installer/nsis_plugins installer/sections rts/ExternalAI	rts/Game rts/Game/Camera rts/Game/UI rts/Lua rts/Map	rts/Map/SM3 rts/Map/SMF rts/Rendering rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/CommandAI rts/System	rts/System/FileSystem rts/System/Script rts/lib rts/lib/gml	tools/DedicatedServer tools/unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6801%20-%20in%20branches/caiinterface%3A%20.%0A%09Documentation%20game/LuaUI%20installer%20installer/include%0A%09installer/nsis_plugins%20installer/sections%20rts/ExternalAI%0A%09rts/Game%20rts/Game/Camera%20rts/Game/UI%20rts/Lua%20rts/Map%0A%09rts/Map/SM3%20rts/Map/SMF%20rts/Rendering%20rts/Rendering/Env%0A%09rts/Rendering/Textures%20rts/Rendering/UnitModels%0A%09rts/Sim/Features%20rts/Sim/Misc%20rts/Sim/MoveTypes%20rts/Sim/Path%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/WeaponProjectiles%0A%09rts/Sim/Units%20rts/Sim/Units/CommandAI%20rts/System%0A%09rts/System/FileSystem%20rts/System/Script%20rts/lib%20rts/lib/gml%0A%09tools/DedicatedServer%20tools/unitsync&In-Reply-To=%3C20081017225005.886C746ED%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6801 - in branches/caiinterface: .	Documentation game/LuaUI installer installer/include	installer/nsis_plugins installer/sections rts/ExternalAI	rts/Game rts/Game/Camera rts/Game/UI rts/Lua rts/Map	rts/Map/SM3 rts/Map/SMF rts/Rendering rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/CommandAI rts/System	rts/System/FileSystem rts/System/Script rts/lib rts/lib/gml	tools/DedicatedServer tools/unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Oct 18 00:50:04 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001569.html">[Taspring-linux-commit] r6800 - in trunk: rts/Sim/Units/CommandAI	rts/System rts/System/Script tools/unitsync
</A></li>
        <LI>Next message: <A HREF="001571.html">[Taspring-linux-commit] r6802 - trunk/rts/Game/Camera
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1570">[ date ]</a>
              <a href="thread.html#1570">[ thread ]</a>
              <a href="subject.html#1570">[ subject ]</a>
              <a href="author.html#1570">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-10-18 00:50:00 +0200 (Sat, 18 Oct 2008)
New Revision: 6801

Added:
   branches/caiinterface/installer/include/
   branches/caiinterface/installer/include/checkrunning.nsh
   branches/caiinterface/installer/include/fileassoc.nsh
   branches/caiinterface/installer/include/otacontent.nsh
   branches/caiinterface/installer/nsis_plugins/
   branches/caiinterface/installer/nsis_plugins/FindProcDLL.dll
   branches/caiinterface/installer/nsis_plugins/inetc.dll
Removed:
   branches/caiinterface/installer/fileassoc.nsh
   branches/caiinterface/installer/include/checkrunning.nsh
   branches/caiinterface/installer/include/fileassoc.nsh
   branches/caiinterface/installer/include/otacontent.nsh
   branches/caiinterface/installer/nsis_plugins/FindProcDLL.dll
   branches/caiinterface/installer/nsis_plugins/inetc.dll
Modified:
   branches/caiinterface/CMakeLists.txt
   branches/caiinterface/Documentation/changelog.txt
   branches/caiinterface/Documentation/releasechecklist.txt
   branches/caiinterface/game/LuaUI/fonts.lua
   branches/caiinterface/installer/sections/main.nsh
   branches/caiinterface/installer/spring.nsi
   branches/caiinterface/installer/springsettings.nsh
   branches/caiinterface/rts/ExternalAI/AICallback.cpp
   branches/caiinterface/rts/ExternalAI/Group.cpp
   branches/caiinterface/rts/ExternalAI/GroupHandler.cpp
   branches/caiinterface/rts/Game/Camera/OrbitController.cpp
   branches/caiinterface/rts/Game/Game.cpp
   branches/caiinterface/rts/Game/GameHelper.cpp
   branches/caiinterface/rts/Game/GameServer.cpp
   branches/caiinterface/rts/Game/GameSetup.cpp
   branches/caiinterface/rts/Game/GameSetup.h
   branches/caiinterface/rts/Game/SelectedUnits.cpp
   branches/caiinterface/rts/Game/UI/EndGameBox.h
   branches/caiinterface/rts/Game/UI/GuiHandler.cpp
   branches/caiinterface/rts/Game/UI/GuiHandler.h
   branches/caiinterface/rts/Game/UI/MiniMap.cpp
   branches/caiinterface/rts/Game/UI/MouseHandler.cpp
   branches/caiinterface/rts/Game/UI/TooltipConsole.cpp
   branches/caiinterface/rts/Lua/LuaCallInCheck.h
   branches/caiinterface/rts/Lua/LuaHandle.cpp
   branches/caiinterface/rts/Lua/LuaOpenGL.cpp
   branches/caiinterface/rts/Lua/LuaUnitDefs.cpp
   branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp
   branches/caiinterface/rts/Lua/LuaUtils.h
   branches/caiinterface/rts/Map/BaseGroundDrawer.cpp
   branches/caiinterface/rts/Map/ReadMap.cpp
   branches/caiinterface/rts/Map/ReadMap.h
   branches/caiinterface/rts/Map/SM3/Sm3Map.cpp
   branches/caiinterface/rts/Map/SM3/Sm3Map.h
   branches/caiinterface/rts/Map/SMF/SmfReadMap.cpp
   branches/caiinterface/rts/Map/SMF/SmfReadMap.h
   branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp
   branches/caiinterface/rts/Rendering/Env/AdvWater.cpp
   branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp
   branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h
   branches/caiinterface/rts/Rendering/Env/BaseWater.cpp
   branches/caiinterface/rts/Rendering/Env/BaseWater.h
   branches/caiinterface/rts/Rendering/Env/BasicTreeDrawer.cpp
   branches/caiinterface/rts/Rendering/Env/BasicWater.cpp
   branches/caiinterface/rts/Rendering/Env/BasicWater.h
   branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
   branches/caiinterface/rts/Rendering/Env/DynWater.cpp
   branches/caiinterface/rts/Rendering/Env/GrassDrawer.cpp
   branches/caiinterface/rts/Rendering/FartextureHandler.cpp
   branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp
   branches/caiinterface/rts/Rendering/InMapDraw.cpp
   branches/caiinterface/rts/Rendering/Textures/TextureHandler.cpp
   branches/caiinterface/rts/Rendering/Textures/TextureHandler.h
   branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.cpp
   branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.h
   branches/caiinterface/rts/Rendering/UnitModels/3DOParser.cpp
   branches/caiinterface/rts/Rendering/UnitModels/3DOParser.h
   branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/caiinterface/rts/Rendering/UnitModels/s3oParser.cpp
   branches/caiinterface/rts/Rendering/UnitModels/s3oParser.h
   branches/caiinterface/rts/Sim/Features/FeatureHandler.cpp
   branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp
   branches/caiinterface/rts/Sim/Misc/CollisionHandler.h
   branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp
   branches/caiinterface/rts/Sim/Misc/QuadField.cpp
   branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp
   branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp
   branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h
   branches/caiinterface/rts/Sim/Path/PathEstimator.cpp
   branches/caiinterface/rts/Sim/Path/PathManager.cpp
   branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
   branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h
   branches/caiinterface/rts/Sim/Units/Unit.cpp
   branches/caiinterface/rts/Sim/Units/Unit.h
   branches/caiinterface/rts/Sim/Units/UnitDef.h
   branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitLoader.cpp
   branches/caiinterface/rts/System/AutohostInterface.cpp
   branches/caiinterface/rts/System/AutohostInterface.h
   branches/caiinterface/rts/System/BaseNetProtocol.cpp
   branches/caiinterface/rts/System/BaseNetProtocol.h
   branches/caiinterface/rts/System/DemoReader.cpp
   branches/caiinterface/rts/System/FileSystem/ArchiveScanner.cpp
   branches/caiinterface/rts/System/LoadSaveHandler.cpp
   branches/caiinterface/rts/System/Matrix44f.cpp
   branches/caiinterface/rts/System/Matrix44f.h
   branches/caiinterface/rts/System/Script/LuaFunctions.cpp
   branches/caiinterface/rts/System/SpringApp.cpp
   branches/caiinterface/rts/System/SpringApp.h
   branches/caiinterface/rts/System/myMath.cpp
   branches/caiinterface/rts/System/myMath.h
   branches/caiinterface/rts/lib/CMakeLists.txt
   branches/caiinterface/rts/lib/gml/gml.cpp
   branches/caiinterface/rts/lib/gml/gml.h
   branches/caiinterface/rts/lib/gml/gmlcls.h
   branches/caiinterface/rts/lib/gml/gmlsrv.h
   branches/caiinterface/tools/DedicatedServer/main.cpp
   branches/caiinterface/tools/unitsync/CMakeLists.txt
Log:
reintegrated trunk up to 6800

Modified: branches/caiinterface/CMakeLists.txt
===================================================================
--- branches/caiinterface/CMakeLists.txt	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/CMakeLists.txt	2008-10-17 22:50:00 UTC (rev 6801)
@@ -54,7 +54,7 @@
 	set (Boost_THREAD_LIBRARY boost_thread-mt)
 	set (Boost_FILESYSTEM_LIBRARY boost_filesystem-mt)
 	set (DEVIL_ILU_LIBRARY ilu)
-	set (DEVIL_LIBRARIES &quot;devil ${DEVIL_ILU_LIBRARY}&quot;)
+	set (DEVIL_LIBRARIES devil ${DEVIL_ILU_LIBRARY})
 else (MINGW)
 	# AIs need it
 	FIND_PACKAGE(SDL REQUIRED)

Modified: branches/caiinterface/Documentation/changelog.txt
===================================================================
--- branches/caiinterface/Documentation/changelog.txt	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/Documentation/changelog.txt	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,5 +1,13 @@
 Spring change log
 
+0.77b5
+Crashes:
+
+Engine:
+ - new fbi tag: bankingAllowed - only affects hoverAttack=1 units; controls if the aircraft can bank.
+ - fbi tag upright now affects gunships
+
+
 0.77b4:
 Crashes:
  - fixed a crash (on exit) in colormap.cpp

Modified: branches/caiinterface/Documentation/releasechecklist.txt
===================================================================
--- branches/caiinterface/Documentation/releasechecklist.txt	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/Documentation/releasechecklist.txt	2008-10-17 22:50:00 UTC (rev 6801)
@@ -2,14 +2,21 @@
 not necessarily in the optimal order, but I tried to make it pretty much right.
 
 Spring engine:
+Before you start:
 - make sure changelog is up to date (including version number!)
+- talk to people to fix their apps which get included in the installer (Lobby, Downloader...)
+
+Then proceed:
+- make sure all packages build correctly (test building on buildbot, test-generate source packages (and check them if they work))
 - set buildbot to only produce builds if forced to (comment out schedulers)
+- test source package linux (or not if you feel brave)
+- test source package windows (ditto)
+- test installer (NEVER EVER SKIP THIS NO MATTER HOW SMALL THE CHANGES)
+
 - bump version number in installer/springsettings.nsh to e.g. &quot;0.76b1&quot;
 - bump version number in rts/Game/GameVersion.cpp
+- tag the released revision in SVN as e.g. &quot;tags/spring_0.76b1&quot;
 - have buildbot compile installer and make source packages
-- test source package linux (or not if you feel brave)
-- test source package windows (ditto)
-- test installer (NEVER EVER SKIP THIS NO MATTER HOW SMALL THE CHANGES)
 - upload installer to fnord.clan-sy.com
 - upload installer to the big Spring file sites (watch out for notification bots,
   it can create chaos if you upload early in release process and the upload gets
@@ -19,7 +26,6 @@
 - upload spring_X.XXbX_src.tar.bz2 to Berlios (not too important)
 - upload spring_X.XXbX_src.zip to Berlios (ditto)
 - make news post (don't forget to thank contributors, link to installer and source)
-- tag the released revision in SVN as e.g. &quot;tags/spring_0.76b1&quot;
 - bump version number in rts/Game/GameVersion.cpp to e.g. &quot;0.76b1+&quot; (note the plus)
 - enable automatic builds in buildbot again
 

Modified: branches/caiinterface/game/LuaUI/fonts.lua
===================================================================
--- branches/caiinterface/game/LuaUI/fonts.lua	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/game/LuaUI/fonts.lua	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,559 +1,560 @@
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  file:    fonts.lua
---  brief:   font handler, uses texture atlases from BZFlag
---  author:  Dave Rodgers
---
---  Copyright (C) 2007.
---  Licensed under the terms of the GNU GPL, v2 or later.
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-if (fontHandler ~= nil) then
-  return fontHandler
-end
-
--- &quot;:n:&quot; sets it to nearest texture filtering
-local DefaultFontName = &quot;:n:&quot; .. LUAUI_DIRNAME .. &quot;Fonts/FreeMonoBold_12&quot;
-
-Spring.CreateDir(LUAUI_DIRNAME .. 'Fonts')
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
--- Automatically generated local definitions
-
-local glCallList             = gl.CallList
-local glColor                = gl.Color
-local glCreateList           = gl.CreateList
-local glDeleteList           = gl.DeleteList
-local glDeleteTexture        = gl.DeleteTexture
-local glPopMatrix            = gl.PopMatrix
-local glPushMatrix           = gl.PushMatrix
-local glTexRect              = gl.TexRect
-local glTexture              = gl.Texture
-local glTranslate            = gl.Translate
-local spGetLastUpdateSeconds = Spring.GetLastUpdateSeconds
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  Local speedups
---
-
-local floor     = math.floor
-local strlen    = string.len
-local strsub    = string.sub
-local strbyte   = string.byte
-local strchar   = string.char
-local strfind   = string.find
-local strgmatch = string.gmatch
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local fonts = {}
-local activeFont  = nil
-local defaultFont = nil
-
-local caching = true
-local useFloor = true
-
-local timeStamp  = 0
-local lastUpdate = 0
-
-local debug = false
-local origPrint = print
-local print = function(...)
-  if (debug) then
-    origPrint(...)
-  end
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local function HaveFontFiles(fontName)
-  if (VFS.FileExists(fontName .. '.lua') and
-      VFS.FileExists(fontName .. '.png')) then
-    return true
-  end
-  return false
-end
-
-
-local function CreateFontFiles(fontName)
-  local _, _, name, size = string.find(fontName, '^(.*)_(%d*)$')
-  if ((not name) or (not size)) then
-    return false
-  end
-
-  local fullName = name .. '.ttf'
-  local inData = VFS.LoadFile(fullName)
-  if (not inData) then
-    fullName = name .. '.otf'
-    inData = VFS.LoadFile(fullName)
-  end
-  if (not inData) then
-    return false
-  end
-  
-  print('CreateFontFiles = ' .. fullName .. ', ' .. size)
-
-  return
-    Spring.MakeFont(fullName, {
-      inData = inData,
-      height = tonumber(size),
-      minChar = 0,
-      maxChar = 255,
-    --[[
-      texWidth = 
-      outlineMode = 
-      outlineRadius = 
-      outlineWeight = 
-      padding = 
-      spacing = 
-      debug =
-    --]]
-    })
-end
-
-
-local function LoadFontSpecs(fontName)
-  local specFile = fontName .. &quot;.lua&quot;
-  local text = VFS.LoadFile(specFile)
-  if (text == nil) then
-    return nil
-  end
-  local chunk, err = loadstring(text, specFile)
-  if (not chunk) then
-    return nil
-  end
-  local fontSpecs = chunk()
-
-  print('fontSpecs.srcFile  = ' .. fontSpecs.srcFile)
-  print('fontSpecs.family   = ' .. fontSpecs.family)
-  print('fontSpecs.style    = ' .. fontSpecs.style)
-  print('fontSpecs.size     = ' .. fontSpecs.height)
-  print('fontSpecs.yStep    = ' .. fontSpecs.yStep)
-  print('fontSpecs.xTexSize = ' .. fontSpecs.xTexSize)
-  print('fontSpecs.yTexSize = ' .. fontSpecs.yTexSize)
-
-  return fontSpecs
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local function MakeDisplayLists(fontSpecs)
-  local lists = {}
-  local xs = fontSpecs.xTexSize
-  local ys = fontSpecs.yTexSize
-  for _,gi in pairs(fontSpecs.glyphs) do
-    local list = glCreateList(function ()
-      glTexRect(gi.oxn, gi.oyn, gi.oxp, gi.oyp,
-                 gi.txn / xs, 1.0 - (gi.tyn / ys),
-                 gi.txp / xs, 1.0 - (gi.typ / ys))
-      glTranslate(gi.adv, 0, 0)
-    end)
-    lists[gi.num] = list
-  end
-  return lists
-end
-
-
-local function MakeOutlineDisplayLists(fontSpecs)
-  local lists = {}
-  local tw = fontSpecs.xTexSize
-  local th = fontSpecs.yTexSize
-
-  for _,gi in pairs(fontSpecs.glyphs) do
-    local w = gi.xmax - gi.xmin
-    local h = gi.ymax - gi.ymin
-    local txn = gi.xmin / tw
-    local tyn = gi.ymax / th
-    local txp = gi.xmax / tw
-    local typ = gi.ymin / th
-    
-    local list = glCreateList(function ()
-      glTranslate(gi.initDist, 0, 0)
-
-      glColor(0, 0, 0, 0.75)
-      local o = 2
-      glTexRect( o,  o, w, h, txn, tyn, txp, typ)
-      glTexRect(-o,  o, w, h, txn, tyn, txp, typ)
-      glTexRect( o,  0, w, h, txn, tyn, txp, typ)
-      glTexRect(-o,  0, w, h, txn, tyn, txp, typ)
-      glTexRect( o, -o, w, h, txn, tyn, txp, typ)
-      glTexRect(-o, -o, w, h, txn, tyn, txp, typ)
-      glTexRect( 0,  o, w, h, txn, tyn, txp, typ)
-      glTexRect( 0, -o, w, h, txn, tyn, txp, typ)
-
-      glColor(1, 1, 1, 1)
-      glTexRect( 0,  0, w, h, txn, tyn, txp, typ)
-
-      glTranslate(gi.width + gi.whitespace, 0, 0)
-    end)
-
-    lists[gi.num] = list
-  end
-  return lists
-end
-
-
---------------------------------------------------------------------------------
-
-local function StripColorCodes(text)
-  local stripped = &quot;&quot;
-  for txt, color in strgmatch(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
-    if (strlen(txt) &gt; 0) then
-      stripped = stripped .. txt
-    end
-  end
-  return stripped
-end
-
-
---------------------------------------------------------------------------------
-
-local function RawGetTextWidth(text)
-  local specs = activeFont.specs
-  local w = 0
-  for i = 1, strlen(text) do
-    local c = strbyte(text, i)
-    local glyphInfo = specs.glyphs[c]
-    if (not glyphInfo) then
-      glyphInfo = specs.glyphs[32]
-    end
-    if (glyphInfo) then
-      w = w + glyphInfo.adv
-    end
-  end
-  return w
-end
-
-
-local function GetTextWidth(text)
-  -- return the cached value if available
-  local cacheTextData = activeFont.cache[text]
-  if (cacheTextData) then
-    local width = cacheTextData[3]
-    if (width) then
-      return width
-    end
-  end
-  local stripped = StripColorCodes(text)
-  return RawGetTextWidth(stripped)
-end
-
-
-local function CalcTextHeight(text)
-  return activeFont.specs.height
-end
-
-
---------------------------------------------------------------------------------
-
-local function RawDraw(text)
-  local lists = activeFont.lists
-  for i = 1, strlen(text) do
-    local c = strbyte(text, i)
-    local list = lists[c]
-    if (list) then
-      glCallList(list)
-    else
-      glCallList(lists[strbyte(&quot; &quot;, 1)])
-    end
-  end
-end
-
-
-local function RawColorDraw(text)
-  for txt, color in strgmatch(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
-    if (strlen(txt) &gt; 0) then
-      RawDraw(txt)
-    end
-    if (strlen(color) == 4) then
-      glColor(strbyte(color, 2) / 255,
-              strbyte(color, 3) / 255,
-              strbyte(color, 4) / 255)
-    end
-  end
-end
-
-
-local function DrawNoCache(text, x, y)
-  if (not x) then
-    RawDraw(text)
-  else
-    glPushMatrix()
-    glTranslate(x, y, 0)
-    glTexture(activeFont.image)
-    RawColorDraw(text)
-    glTexture(false)
-    glPopMatrix()
-  end
-end
-
-
-local function Draw(text, x, y)
-  if (not caching) then
-    DrawNoCache(text, x, y)
-    return
-  end
-
-  local cacheTextData = activeFont.cache[text]
-  if (not cacheTextData) then
-    local textList = glCreateList(function()
-      glTexture(activeFont.image)
-      RawColorDraw(text)
-      glTexture(false)
-    end)
-    cacheTextData = { textList, timeStamp }  -- param [3] is the width
-    activeFont.cache[text] = cacheTextData
-  else
-    cacheTextData[2] = timeStamp  --  refresh the timeStamp
-  end
-
-  if (not x) then
-    glCallList(cacheTextData[1])
-  else
-    glPushMatrix()
-    if (useFloor) then
-      glTranslate(floor(x), floor(y), 0)
-    else
-      glTranslate(x, y, 0)
-    end
-    glCallList(cacheTextData[1])
-    glPopMatrix()
-  end
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local function DrawRight(text, x, y)
-  local width = GetTextWidth(text)
-  glPushMatrix()
-  glTranslate(-width, 0, 0)
-  Draw(text, x, y)
-  glPopMatrix()
-end
-
-
-local function DrawCentered(text, x, y)
-  local width = GetTextWidth(text)
-  local halfWidth
-  if (useFloor) then
-    halfWidth = floor(width * 0.5)
-  else
-    halfWidth = width * 0.5
-  end
-  glPushMatrix()
-  glTranslate(-halfWidth, 0, 0)
-  Draw(text, x, y)
-  glPopMatrix()
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local function LoadFont(fontName)
-  print('LoadFont:  ' .. fontName)
-
-  if (fonts[fontName]) then
-    return nil  -- already loaded
-  end
-
-  local baseName = fontName
-  local _,_,options,bn = strfind(fontName, &quot;(:.-:)(.*)&quot;)
-  if (options) then
-    baseName = bn
-  else
-    options = ''
-  end
-
-  if (not HaveFontFiles(baseName)) then
-    CreateFontFiles(baseName)
-  end
-
-  local fontSpecs = LoadFontSpecs(baseName)
-  if (not fontSpecs) then
-    return nil  -- bad specs
-  end
-
-  if (not VFS.FileExists(baseName .. &quot;.png&quot;)) then
-    return nil  -- missing texture
-  end
-
-  local fontLists
-  if (strfind(options, &quot;o&quot;)) then
-    fontLists = MakeOutlineDisplayLists(fontSpecs)
-  else
-    fontLists = MakeDisplayLists(fontSpecs)
-  end
-  if (not fontLists) then
-    return nil  -- bad display lists
-  end
-
-  local font = {}
-  font.name  = fontName
-  font.base  = baseName
-  font.opts  = options
-  font.specs = fontSpecs
-  font.lists = fontLists
-  font.cache = {}
-  font.image = options .. baseName .. &quot;.png&quot;
-
-  fonts[fontName] = font
-
-  return font
-end
-
-
-local function UseFont(fontName)
-  local font = fonts[fontName]
-  if (font) then
-    activeFont = font
-    return true
-  end
-
-  font = LoadFont(fontName)
-  if (font) then
-    activeFont = font
-    print(&quot;Loaded font: &quot; .. fontName)
-    return true
-  end
-
-  return false
-end
-
-
-local function UseDefaultFont()
-  activeFont = defaultFont
-end
-
-
-local function SetDefaultFont(name)
-  local tmpFont = activeFont
-  if (UseFont(name)) then
-    DefaultFontName = name
-    defaultFont = activeFont
-  end
-  activeFont = tmpFont
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local function FreeCache(fontName)
-  local font = (fontName == nil) and activeFont or fonts[fontName]
-  if (not font) then
-    return
-  end
-  for text,data in pairs(font.cache) do
-    glDeleteList(data[1])
-  end
-end
-
-
-local function FreeFont(fontName)
-  local font = (fontName == nil) and activeFont or fonts[fontName]
-  if (not font) then
-    return
-  end
-
-  for _,list in pairs(font.lists) do
-    glDeleteList(list)
-  end
-  for text,data in pairs(font.cache) do
-    glDeleteList(data[1])
-  end
-  glDeleteTexture(font.image)
-
-  fonts[font.name] = nil
-end
-
-
-local function FreeFonts()
-  for fontName in pairs(fonts) do
-    FreeFont(fontName)
-  end
-end
-
-
-local function Update()
-  timeStamp = timeStamp + spGetLastUpdateSeconds()
-  if (timeStamp &lt; (lastUpdate + 1.0)) then
-    return  -- only update every 1.0 seconds
-  end
-
-  local killTime = (timeStamp - 3.0)
-  for fontName, font in pairs(fonts) do
-    local killList = {}
-    for text,data in pairs(font.cache) do
-      if (data[2] &lt; killTime) then
-        glDeleteList(data[1])
-        table.insert(killList, text)
-        print(fontName .. &quot; removed string list(&quot; .. data[1] .. &quot;) &quot; .. text)
-      end
-    end
-    for _,text in ipairs(killList) do
-      font.cache[text] = nil
-    end
-  end
-
-  lastUpdate = timeStamp
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-UseFont(DefaultFontName)
-defaultFont = activeFont
-
-
-local FH = {}
-
-FH.Update = Update
-
-FH.UseFont        = UseFont
-FH.UseDefaultFont = UseDefaultFont
-FH.SetDefaultFont = SetDefaultFont
-
-FH.GetFontName  = function() return activeFont.name         end
-FH.GetFontSize  = function() return activeFont.specs.height end
-FH.GetFontYStep = function() return activeFont.specs.yStep  end
-FH.GetTextWidth = GetTextWidth
-
-FH.Draw         = Draw
-FH.DrawRight    = DrawRight
-FH.DrawCentered = DrawCentered
-
-FH.StripColors = StripColorCodes
-
-FH.FreeFont  = FreeFont
-FH.FreeFonts = FreeFonts
-FH.FreeCache = FreeCache
-
-FH.CacheState   = function() return caching  end
-FH.EnableCache  = function() caching = true  end
-FH.DisableCache = function() caching = false end
-
-fontHandler = FH  -- make it global
-
-return FH
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  file:    fonts.lua
+--  brief:   font handler, uses texture atlases from BZFlag
+--  author:  Dave Rodgers
+--
+--  Copyright (C) 2007.
+--  Licensed under the terms of the GNU GPL, v2 or later.
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+if (fontHandler ~= nil) then
+  return fontHandler
+end
+
+-- &quot;:n:&quot; sets it to nearest texture filtering
+local DefaultFontName = &quot;:n:&quot; .. LUAUI_DIRNAME .. &quot;Fonts/FreeMonoBold_12&quot;
+
+Spring.CreateDir(LUAUI_DIRNAME .. 'Fonts')
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+-- Automatically generated local definitions
+
+local glCallList             = gl.CallList
+local glColor                = gl.Color
+local glCreateList           = gl.CreateList
+local glDeleteList           = gl.DeleteList
+local glDeleteTexture        = gl.DeleteTexture
+local glPopMatrix            = gl.PopMatrix
+local glPushMatrix           = gl.PushMatrix
+local glTexRect              = gl.TexRect
+local glTexture              = gl.Texture
+local glTranslate            = gl.Translate
+local spGetLastUpdateSeconds = Spring.GetLastUpdateSeconds
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Local speedups
+--
+
+local floor     = math.floor
+local strlen    = string.len
+local strsub    = string.sub
+local strbyte   = string.byte
+local strchar   = string.char
+local strfind   = string.find
+local strgmatch = string.gmatch
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local fonts = {}
+local activeFont  = nil
+local defaultFont = nil
+
+local caching = true
+local useFloor = true
+
+local timeStamp  = 0
+local lastUpdate = 0
+
+local debug = false
+local origPrint = print
+local print = function(...)
+  if (debug) then
+    origPrint(...)
+  end
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function HaveFontFiles(fontName)
+  if (VFS.FileExists(fontName .. '.lua') and
+      VFS.FileExists(fontName .. '.png')) then
+    return true
+  end
+  return false
+end
+
+
+local function CreateFontFiles(fontName)
+  local _, _, name, size = string.find(fontName, '^(.*)_(%d*)$')
+  if ((not name) or (not size)) then
+    return false
+  end
+
+  local fullName = name .. '.ttf'
+  local inData = VFS.LoadFile(fullName)
+  if (not inData) then
+    fullName = name .. '.otf'
+    inData = VFS.LoadFile(fullName)
+  end
+  if (not inData) then
+    return false
+  end
+  
+  print('CreateFontFiles = ' .. fullName .. ', ' .. size)
+
+  return
+    Spring.MakeFont(fullName, {
+      inData = inData,
+      height = tonumber(size),
+      minChar = 0,
+      maxChar = 255,
+    --[[
+      texWidth = 
+      outlineMode = 
+      outlineRadius = 
+      outlineWeight = 
+      padding = 
+      spacing = 
+      debug =
+    --]]
+    })
+end
+
+
+local function LoadFontSpecs(fontName)
+  local specFile = fontName .. &quot;.lua&quot;
+  local text = VFS.LoadFile(specFile)
+  if (text == nil) then
+    return nil
+  end
+  local chunk, err = loadstring(text, specFile)
+  if (not chunk) then
+    return nil
+  end
+  local fontSpecs = chunk()
+
+  print('fontSpecs.srcFile  = ' .. fontSpecs.srcFile)
+  print('fontSpecs.family   = ' .. fontSpecs.family)
+  print('fontSpecs.style    = ' .. fontSpecs.style)
+  print('fontSpecs.size     = ' .. fontSpecs.height)
+  print('fontSpecs.yStep    = ' .. fontSpecs.yStep)
+  print('fontSpecs.xTexSize = ' .. fontSpecs.xTexSize)
+  print('fontSpecs.yTexSize = ' .. fontSpecs.yTexSize)
+
+  return fontSpecs
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function MakeDisplayLists(fontSpecs)
+  local lists = {}
+  local xs = fontSpecs.xTexSize
+  local ys = fontSpecs.yTexSize
+  for _,gi in pairs(fontSpecs.glyphs) do
+    local list = glCreateList(function ()
+      glTexRect(gi.oxn, gi.oyn, gi.oxp, gi.oyp,
+                 gi.txn / xs, 1.0 - (gi.tyn / ys),
+                 gi.txp / xs, 1.0 - (gi.typ / ys))
+      glTranslate(gi.adv, 0, 0)
+    end)
+    lists[gi.num] = list
+  end
+  return lists
+end
+
+
+local function MakeOutlineDisplayLists(fontSpecs)
+  local lists = {}
+  local tw = fontSpecs.xTexSize
+  local th = fontSpecs.yTexSize
+
+  for _,gi in pairs(fontSpecs.glyphs) do
+    local w = gi.xmax - gi.xmin
+    local h = gi.ymax - gi.ymin
+    local txn = gi.xmin / tw
+    local tyn = gi.ymax / th
+    local txp = gi.xmax / tw
+    local typ = gi.ymin / th
+    
+    local list = glCreateList(function ()
+      glTranslate(gi.initDist, 0, 0)
+
+      glColor(0, 0, 0, 0.75)
+      local o = 2
+      glTexRect( o,  o, w, h, txn, tyn, txp, typ)
+      glTexRect(-o,  o, w, h, txn, tyn, txp, typ)
+      glTexRect( o,  0, w, h, txn, tyn, txp, typ)
+      glTexRect(-o,  0, w, h, txn, tyn, txp, typ)
+      glTexRect( o, -o, w, h, txn, tyn, txp, typ)
+      glTexRect(-o, -o, w, h, txn, tyn, txp, typ)
+      glTexRect( 0,  o, w, h, txn, tyn, txp, typ)
+      glTexRect( 0, -o, w, h, txn, tyn, txp, typ)
+
+      glColor(1, 1, 1, 1)
+      glTexRect( 0,  0, w, h, txn, tyn, txp, typ)
+
+      glTranslate(gi.width + gi.whitespace, 0, 0)
+    end)
+
+    lists[gi.num] = list
+  end
+  return lists
+end
+
+
+--------------------------------------------------------------------------------
+
+local function StripColorCodes(text)
+  local stripped = &quot;&quot;
+  for txt, color in strgmatch(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
+    if (strlen(txt) &gt; 0) then
+      stripped = stripped .. txt
+    end
+  end
+  return stripped
+end
+
+
+--------------------------------------------------------------------------------
+
+local function RawGetTextWidth(text)
+  local specs = activeFont.specs
+  local w = 0
+  for i = 1, strlen(text) do
+    local c = strbyte(text, i)
+    local glyphInfo = specs.glyphs[c]
+    if (not glyphInfo) then
+      glyphInfo = specs.glyphs[32]
+    end
+    if (glyphInfo) then
+      w = w + glyphInfo.adv
+    end
+  end
+  return w
+end
+
+
+local function GetTextWidth(text)
+  -- return the cached value if available
+  local cacheTextData = activeFont.cache[text]
+  if (cacheTextData) then
+    local width = cacheTextData[3]
+    if (width) then
+      return width
+    end
+  end
+  local stripped = StripColorCodes(text)
+  return RawGetTextWidth(stripped)
+end
+
+
+local function CalcTextHeight(text)
+  return activeFont.specs.height
+end
+
+
+--------------------------------------------------------------------------------
+
+local function RawDraw(text)
+  local lists = activeFont.lists
+  for i = 1, strlen(text) do
+    local c = strbyte(text, i)
+    local list = lists[c]
+    if (list) then
+      glCallList(list)
+    else
+      glCallList(lists[strbyte(&quot; &quot;, 1)])
+    end
+  end
+end
+
+
+local function RawColorDraw(text)
+  for txt, color in strgmatch(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
+    if (strlen(txt) &gt; 0) then
+      RawDraw(txt)
+    end
+    if (strlen(color) == 4) then
+      glColor(strbyte(color, 2) / 255,
+              strbyte(color, 3) / 255,
+              strbyte(color, 4) / 255)
+    end
+  end
+end
+
+
+local function DrawNoCache(text, x, y)
+  if (not x) then
+    RawDraw(text)
+  else
+    glPushMatrix()
+    glTranslate(x, y, 0)
+    glTexture(activeFont.image)
+    RawColorDraw(text)
+    glTexture(false)
+    glPopMatrix()
+  end
+end
+
+
+local function Draw(text, x, y)
+  if (not caching) then
+    DrawNoCache(text, x, y)
+    return
+  end
+
+  local cacheTextData = activeFont.cache[text]
+  if (not cacheTextData) then
+    glTexture(activeFont.image) -- else we would _recreate_ the texture each call to the displaylist!
+    local textList = glCreateList(function()
+      glTexture(activeFont.image)
+      RawColorDraw(text)
+      glTexture(false)
+    end)
+    cacheTextData = { textList, timeStamp }  -- param [3] is the width
+    activeFont.cache[text] = cacheTextData
+  else
+    cacheTextData[2] = timeStamp  --  refresh the timeStamp
+  end
+
+  if (not x) then
+    glCallList(cacheTextData[1])
+  else
+    glPushMatrix()
+    if (useFloor) then
+      glTranslate(floor(x), floor(y), 0)
+    else
+      glTranslate(x, y, 0)
+    end
+    glCallList(cacheTextData[1])
+    glPopMatrix()
+  end
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function DrawRight(text, x, y)
+  local width = GetTextWidth(text)
+  glPushMatrix()
+  glTranslate(-width, 0, 0)
+  Draw(text, x, y)
+  glPopMatrix()
+end
+
+
+local function DrawCentered(text, x, y)
+  local width = GetTextWidth(text)
+  local halfWidth
+  if (useFloor) then
+    halfWidth = floor(width * 0.5)
+  else
+    halfWidth = width * 0.5
+  end
+  glPushMatrix()
+  glTranslate(-halfWidth, 0, 0)
+  Draw(text, x, y)
+  glPopMatrix()
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function LoadFont(fontName)
+  print('LoadFont:  ' .. fontName)
+
+  if (fonts[fontName]) then
+    return nil  -- already loaded
+  end
+
+  local baseName = fontName
+  local _,_,options,bn = strfind(fontName, &quot;(:.-:)(.*)&quot;)
+  if (options) then
+    baseName = bn
+  else
+    options = ''
+  end
+
+  if (not HaveFontFiles(baseName)) then
+    CreateFontFiles(baseName)
+  end
+
+  local fontSpecs = LoadFontSpecs(baseName)
+  if (not fontSpecs) then
+    return nil  -- bad specs
+  end
+
+  if (not VFS.FileExists(baseName .. &quot;.png&quot;)) then
+    return nil  -- missing texture
+  end
+
+  local fontLists
+  if (strfind(options, &quot;o&quot;)) then
+    fontLists = MakeOutlineDisplayLists(fontSpecs)
+  else
+    fontLists = MakeDisplayLists(fontSpecs)
+  end
+  if (not fontLists) then
+    return nil  -- bad display lists
+  end
+
+  local font = {}
+  font.name  = fontName
+  font.base  = baseName
+  font.opts  = options
+  font.specs = fontSpecs
+  font.lists = fontLists
+  font.cache = {}
+  font.image = options .. baseName .. &quot;.png&quot;
+
+  fonts[fontName] = font
+
+  return font
+end
+
+
+local function UseFont(fontName)
+  local font = fonts[fontName]
+  if (font) then
+    activeFont = font
+    return true
+  end
+
+  font = LoadFont(fontName)
+  if (font) then
+    activeFont = font
+    print(&quot;Loaded font: &quot; .. fontName)
+    return true
+  end
+
+  return false
+end
+
+
+local function UseDefaultFont()
+  activeFont = defaultFont
+end
+
+
+local function SetDefaultFont(name)
+  local tmpFont = activeFont
+  if (UseFont(name)) then
+    DefaultFontName = name
+    defaultFont = activeFont
+  end
+  activeFont = tmpFont
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function FreeCache(fontName)
+  local font = (fontName == nil) and activeFont or fonts[fontName]
+  if (not font) then
+    return
+  end
+  for text,data in pairs(font.cache) do
+    glDeleteList(data[1])
+  end
+end
+
+
+local function FreeFont(fontName)
+  local font = (fontName == nil) and activeFont or fonts[fontName]
+  if (not font) then
+    return
+  end
+
+  for _,list in pairs(font.lists) do
+    glDeleteList(list)
+  end
+  for text,data in pairs(font.cache) do
+    glDeleteList(data[1])
+  end
+  glDeleteTexture(font.image)
+
+  fonts[font.name] = nil
+end
+
+
+local function FreeFonts()
+  for fontName in pairs(fonts) do
+    FreeFont(fontName)
+  end
+end
+
+
+local function Update()
+  timeStamp = timeStamp + spGetLastUpdateSeconds()
+  if (timeStamp &lt; (lastUpdate + 1.0)) then
+    return  -- only update every 1.0 seconds
+  end
+
+  local killTime = (timeStamp - 3.0)
+  for fontName, font in pairs(fonts) do
+    local killList = {}
+    for text,data in pairs(font.cache) do
+      if (data[2] &lt; killTime) then
+        glDeleteList(data[1])
+        table.insert(killList, text)
+        print(fontName .. &quot; removed string list(&quot; .. data[1] .. &quot;) &quot; .. text)
+      end
+    end
+    for _,text in ipairs(killList) do
+      font.cache[text] = nil
+    end
+  end
+
+  lastUpdate = timeStamp
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+UseFont(DefaultFontName)
+defaultFont = activeFont
+
+
+local FH = {}
+
+FH.Update = Update
+
+FH.UseFont        = UseFont
+FH.UseDefaultFont = UseDefaultFont
+FH.SetDefaultFont = SetDefaultFont
+
+FH.GetFontName  = function() return activeFont.name         end
+FH.GetFontSize  = function() return activeFont.specs.height end
+FH.GetFontYStep = function() return activeFont.specs.yStep  end
+FH.GetTextWidth = GetTextWidth
+
+FH.Draw         = Draw
+FH.DrawRight    = DrawRight
+FH.DrawCentered = DrawCentered
+
+FH.StripColors = StripColorCodes
+
+FH.FreeFont  = FreeFont
+FH.FreeFonts = FreeFonts
+FH.FreeCache = FreeCache
+
+FH.CacheState   = function() return caching  end
+FH.EnableCache  = function() caching = true  end
+FH.DisableCache = function() caching = false end
+
+fontHandler = FH  -- make it global
+
+return FH
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------

Deleted: branches/caiinterface/installer/fileassoc.nsh
===================================================================
--- branches/caiinterface/installer/fileassoc.nsh	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/fileassoc.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,119 +0,0 @@
-; fileassoc.nsh
-; File association helper macros
-; Written by Saivert
-;
-; Features automatic backup system and UPDATEFILEASSOC macro for
-; shell change notification.
-;
-; |&gt; How to use &lt;|
-; To associate a file with an application so you can double-click it in explorer, use
-; the APP_ASSOCIATE macro like this:
-;
-;   Example:
-;   !insertmacro APP_ASSOCIATE &quot;txt&quot; &quot;myapp.textfile&quot; &quot;$INSTDIR\myapp.exe,0&quot; \
-;     &quot;Open with myapp&quot; &quot;$INSTDIR\myapp.exe $\&quot;%1$\&quot;&quot;
-;
-; Never insert the APP_ASSOCIATE macro multiple times, it is only ment
-; to associate an application with a single file and using the
-; the &quot;open&quot; verb as default. To add more verbs (actions) to a file
-; use the APP_ASSOCIATE_ADDVERB macro.
-;
-;   Example:
-;   !insertmacro APP_ASSOCIATE_ADDVERB &quot;myapp.textfile&quot; &quot;edit&quot; &quot;Edit with myapp&quot; \
-;     &quot;$INSTDIR\myapp.exe /edit $\&quot;%1$\&quot;&quot;
-;
-; To have access to more options when registering the file association use the
-; APP_ASSOCIATE_EX macro. Here you can specify the verb and what verb is to be the
-; standard action (default verb).
-;
-; And finally: To remove the association from the registry use the APP_UNASSOCIATE
-; macro. Here is another example just to wrap it up:
-;   !insertmacro APP_UNASSOCIATE &quot;txt&quot; &quot;myapp.textfile&quot;
-;
-; |&gt; Note &lt;|
-; When defining your file class string always use the short form of your application title
-; then a period (dot) and the type of file. This keeps the file class sort of unique.
-;   Examples:
-;   Winamp.Playlist
-;   NSIS.Script
-;   Photoshop.JPEGFile
-;
-; |&gt; Tech info &lt;|
-; The registry key layout for a file association is:
-; HKEY_CLASSES_ROOT
-;     &lt;applicationID&gt; = &lt;&quot;description&quot;&gt;
-;         shell
-;             &lt;verb&gt; = &lt;&quot;menu-item text&quot;&gt;
-;                 command = &lt;&quot;command string&quot;&gt;
-;
- 
-!macro APP_ASSOCIATE EXT FILECLASS DESCRIPTION ICON COMMANDTEXT COMMAND
-  ; Backup the previously associated file class
-  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; &quot;&quot;
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;${FILECLASS}_backup&quot; &quot;$R0&quot;
- 
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;${FILECLASS}&quot;
- 
-  WriteRegStr HKCR &quot;${FILECLASS}&quot; &quot;&quot; `${DESCRIPTION}`
-  WriteRegStr HKCR &quot;${FILECLASS}\DefaultIcon&quot; &quot;&quot; `${ICON}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell&quot; &quot;&quot; &quot;open&quot;
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\open&quot; &quot;&quot; `${COMMANDTEXT}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\open\command&quot; &quot;&quot; `${COMMAND}`
-!macroend
- 
-!macro APP_ASSOCIATE_EX EXT FILECLASS DESCRIPTION ICON VERB DEFAULTVERB SHELLNEW COMMANDTEXT COMMAND
-  ; Backup the previously associated file class
-  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; &quot;&quot;
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;${FILECLASS}_backup&quot; &quot;$R0&quot;
- 
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;${FILECLASS}&quot;
-  StrCmp &quot;${SHELLNEW}&quot; &quot;0&quot; +2
-  WriteRegStr HKCR &quot;.${EXT}\ShellNew&quot; &quot;NullFile&quot; &quot;&quot;
- 
-  WriteRegStr HKCR &quot;${FILECLASS}&quot; &quot;&quot; `${DESCRIPTION}`
-  WriteRegStr HKCR &quot;${FILECLASS}\DefaultIcon&quot; &quot;&quot; `${ICON}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell&quot; &quot;&quot; `${DEFAULTVERB}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}&quot; &quot;&quot; `${COMMANDTEXT}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}\command&quot; &quot;&quot; `${COMMAND}`
-!macroend
- 
-!macro APP_ASSOCIATE_ADDVERB FILECLASS VERB COMMANDTEXT COMMAND
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}&quot; &quot;&quot; `${COMMANDTEXT}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}\command&quot; &quot;&quot; `${COMMAND}`
-!macroend
- 
-!macro APP_ASSOCIATE_REMOVEVERB FILECLASS VERB
-  DeleteRegKey HKCR `${FILECLASS}\shell\${VERB}`
-!macroend
- 
- 
-!macro APP_UNASSOCIATE EXT FILECLASS
-  ; Backup the previously associated file class
-  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; `${FILECLASS}_backup`
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;$R0&quot;
- 
-  DeleteRegKey HKCR `${FILECLASS}`
-!macroend
- 
-!macro APP_ASSOCIATE_GETFILECLASS OUTPUT EXT
-  ReadRegStr ${OUTPUT} HKCR &quot;.${EXT}&quot; &quot;&quot;
-!macroend
- 
- 
-; !defines for use with SHChangeNotify
-!ifdef SHCNE_ASSOCCHANGED
-!undef SHCNE_ASSOCCHANGED
-!endif
-!define SHCNE_ASSOCCHANGED 0x08000000
-!ifdef SHCNF_FLUSH
-!undef SHCNF_FLUSH
-!endif
-!define SHCNF_FLUSH        0x1000
- 
-!macro UPDATEFILEASSOC
-; Using the system.dll plugin to call the SHChangeNotify Win32 API function so we
-; can update the shell.
-  System::Call &quot;shell32::SHChangeNotify(i,i,i,i) (${SHCNE_ASSOCCHANGED}, ${SHCNF_FLUSH}, 0, 0)&quot;
-!macroend
- 
-;EOF
\ No newline at end of file

Copied: branches/caiinterface/installer/include (from rev 6800, trunk/installer/include)

Deleted: branches/caiinterface/installer/include/checkrunning.nsh
===================================================================
--- trunk/installer/include/checkrunning.nsh	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/include/checkrunning.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,68 +0,0 @@
-Function CheckTASClientRunning
-  FindProcDLL::FindProc &quot;TASClient.exe&quot;
-  ; $R0 == 1: process found
-  ;        0: process not found
-  ;       &gt;1: some error, assume everything's ok
-  IntCmp $R0 1 do_abort proceed proceed
-do_abort:
-  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close TASClient before installing.&quot;
-  Abort
-proceed:
-  Return
-FunctionEnd
-
-
-Function CheckSpringLobbyRunning
-  FindProcDLL::FindProc &quot;springlobby.exe&quot;
-  ; $R0 == 1: process found
-  ;        0: process not found
-  ;       &gt;1: some error, assume everything's ok
-  IntCmp $R0 1 do_abort proceed proceed
-do_abort:
-  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close Spring Lobby before installing.&quot;
-  Abort
-proceed:
-  Return
-FunctionEnd
-
-
-Function CheckSpringDownloaderRunning
-  FindProcDLL::FindProc &quot;SpringDownloader.exe&quot;
-  ; $R0 == 1: process found
-  ;        0: process not found
-  ;       &gt;1: some error, assume everything's ok
-  IntCmp $R0 1 do_abort proceed proceed
-do_abort:
-  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close Spring Downloader before installing.&quot;
-  Abort
-proceed:
-  Return
-FunctionEnd
-
-
-Function CheckCADownloaderRunning
-  FindProcDLL::FindProc &quot;CADownloader.exe&quot;
-  ; $R0 == 1: process found
-  ;        0: process not found
-  ;       &gt;1: some error, assume everything's ok
-  IntCmp $R0 1 do_abort proceed proceed
-do_abort:
-  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close CA Downloader before installing.&quot;
-  Abort
-proceed:
-  Return
-FunctionEnd
-
-
-Function CheckSpringSettingsRunning
-  FindProcDLL::FindProc &quot;springsettings.exe&quot;
-  ; $R0 == 1: process found
-  ;        0: process not found
-  ;       &gt;1: some error, assume everything's ok
-  IntCmp $R0 1 do_abort proceed proceed
-do_abort:
-  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close Spring Settings before installing.&quot;
-  Abort
-proceed:
-  Return
-FunctionEnd

Copied: branches/caiinterface/installer/include/checkrunning.nsh (from rev 6800, trunk/installer/include/checkrunning.nsh)
===================================================================
--- branches/caiinterface/installer/include/checkrunning.nsh	                        (rev 0)
+++ branches/caiinterface/installer/include/checkrunning.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -0,0 +1,68 @@
+Function CheckTASClientRunning
+  FindProcDLL::FindProc &quot;TASClient.exe&quot;
+  ; $R0 == 1: process found
+  ;        0: process not found
+  ;       &gt;1: some error, assume everything's ok
+  IntCmp $R0 1 do_abort proceed proceed
+do_abort:
+  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close TASClient before installing.&quot;
+  Abort
+proceed:
+  Return
+FunctionEnd
+
+
+Function CheckSpringLobbyRunning
+  FindProcDLL::FindProc &quot;springlobby.exe&quot;
+  ; $R0 == 1: process found
+  ;        0: process not found
+  ;       &gt;1: some error, assume everything's ok
+  IntCmp $R0 1 do_abort proceed proceed
+do_abort:
+  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close Spring Lobby before installing.&quot;
+  Abort
+proceed:
+  Return
+FunctionEnd
+
+
+Function CheckSpringDownloaderRunning
+  FindProcDLL::FindProc &quot;SpringDownloader.exe&quot;
+  ; $R0 == 1: process found
+  ;        0: process not found
+  ;       &gt;1: some error, assume everything's ok
+  IntCmp $R0 1 do_abort proceed proceed
+do_abort:
+  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close Spring Downloader before installing.&quot;
+  Abort
+proceed:
+  Return
+FunctionEnd
+
+
+Function CheckCADownloaderRunning
+  FindProcDLL::FindProc &quot;CADownloader.exe&quot;
+  ; $R0 == 1: process found
+  ;        0: process not found
+  ;       &gt;1: some error, assume everything's ok
+  IntCmp $R0 1 do_abort proceed proceed
+do_abort:
+  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close CA Downloader before installing.&quot;
+  Abort
+proceed:
+  Return
+FunctionEnd
+
+
+Function CheckSpringSettingsRunning
+  FindProcDLL::FindProc &quot;springsettings.exe&quot;
+  ; $R0 == 1: process found
+  ;        0: process not found
+  ;       &gt;1: some error, assume everything's ok
+  IntCmp $R0 1 do_abort proceed proceed
+do_abort:
+  MessageBox MB_OK|MB_ICONEXCLAMATION &quot;Please close Spring Settings before installing.&quot;
+  Abort
+proceed:
+  Return
+FunctionEnd

Deleted: branches/caiinterface/installer/include/fileassoc.nsh
===================================================================
--- trunk/installer/include/fileassoc.nsh	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/include/fileassoc.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,119 +0,0 @@
-; fileassoc.nsh
-; File association helper macros
-; Written by Saivert
-;
-; Features automatic backup system and UPDATEFILEASSOC macro for
-; shell change notification.
-;
-; |&gt; How to use &lt;|
-; To associate a file with an application so you can double-click it in explorer, use
-; the APP_ASSOCIATE macro like this:
-;
-;   Example:
-;   !insertmacro APP_ASSOCIATE &quot;txt&quot; &quot;myapp.textfile&quot; &quot;$INSTDIR\myapp.exe,0&quot; \
-;     &quot;Open with myapp&quot; &quot;$INSTDIR\myapp.exe $\&quot;%1$\&quot;&quot;
-;
-; Never insert the APP_ASSOCIATE macro multiple times, it is only ment
-; to associate an application with a single file and using the
-; the &quot;open&quot; verb as default. To add more verbs (actions) to a file
-; use the APP_ASSOCIATE_ADDVERB macro.
-;
-;   Example:
-;   !insertmacro APP_ASSOCIATE_ADDVERB &quot;myapp.textfile&quot; &quot;edit&quot; &quot;Edit with myapp&quot; \
-;     &quot;$INSTDIR\myapp.exe /edit $\&quot;%1$\&quot;&quot;
-;
-; To have access to more options when registering the file association use the
-; APP_ASSOCIATE_EX macro. Here you can specify the verb and what verb is to be the
-; standard action (default verb).
-;
-; And finally: To remove the association from the registry use the APP_UNASSOCIATE
-; macro. Here is another example just to wrap it up:
-;   !insertmacro APP_UNASSOCIATE &quot;txt&quot; &quot;myapp.textfile&quot;
-;
-; |&gt; Note &lt;|
-; When defining your file class string always use the short form of your application title
-; then a period (dot) and the type of file. This keeps the file class sort of unique.
-;   Examples:
-;   Winamp.Playlist
-;   NSIS.Script
-;   Photoshop.JPEGFile
-;
-; |&gt; Tech info &lt;|
-; The registry key layout for a file association is:
-; HKEY_CLASSES_ROOT
-;     &lt;applicationID&gt; = &lt;&quot;description&quot;&gt;
-;         shell
-;             &lt;verb&gt; = &lt;&quot;menu-item text&quot;&gt;
-;                 command = &lt;&quot;command string&quot;&gt;
-;
-
-!macro APP_ASSOCIATE EXT FILECLASS DESCRIPTION ICON COMMANDTEXT COMMAND
-  ; Backup the previously associated file class
-  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; &quot;&quot;
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;${FILECLASS}_backup&quot; &quot;$R0&quot;
-
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;${FILECLASS}&quot;
-
-  WriteRegStr HKCR &quot;${FILECLASS}&quot; &quot;&quot; `${DESCRIPTION}`
-  WriteRegStr HKCR &quot;${FILECLASS}\DefaultIcon&quot; &quot;&quot; `${ICON}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell&quot; &quot;&quot; &quot;open&quot;
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\open&quot; &quot;&quot; `${COMMANDTEXT}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\open\command&quot; &quot;&quot; `${COMMAND}`
-!macroend
-
-!macro APP_ASSOCIATE_EX EXT FILECLASS DESCRIPTION ICON VERB DEFAULTVERB SHELLNEW COMMANDTEXT COMMAND
-  ; Backup the previously associated file class
-  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; &quot;&quot;
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;${FILECLASS}_backup&quot; &quot;$R0&quot;
-
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;${FILECLASS}&quot;
-  StrCmp &quot;${SHELLNEW}&quot; &quot;0&quot; +2
-  WriteRegStr HKCR &quot;.${EXT}\ShellNew&quot; &quot;NullFile&quot; &quot;&quot;
-
-  WriteRegStr HKCR &quot;${FILECLASS}&quot; &quot;&quot; `${DESCRIPTION}`
-  WriteRegStr HKCR &quot;${FILECLASS}\DefaultIcon&quot; &quot;&quot; `${ICON}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell&quot; &quot;&quot; `${DEFAULTVERB}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}&quot; &quot;&quot; `${COMMANDTEXT}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}\command&quot; &quot;&quot; `${COMMAND}`
-!macroend
-
-!macro APP_ASSOCIATE_ADDVERB FILECLASS VERB COMMANDTEXT COMMAND
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}&quot; &quot;&quot; `${COMMANDTEXT}`
-  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}\command&quot; &quot;&quot; `${COMMAND}`
-!macroend
-
-!macro APP_ASSOCIATE_REMOVEVERB FILECLASS VERB
-  DeleteRegKey HKCR `${FILECLASS}\shell\${VERB}`
-!macroend
-
-
-!macro APP_UNASSOCIATE EXT FILECLASS
-  ; Backup the previously associated file class
-  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; `${FILECLASS}_backup`
-  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;$R0&quot;
-
-  DeleteRegKey HKCR `${FILECLASS}`
-!macroend
-
-!macro APP_ASSOCIATE_GETFILECLASS OUTPUT EXT
-  ReadRegStr ${OUTPUT} HKCR &quot;.${EXT}&quot; &quot;&quot;
-!macroend
-
-
-; !defines for use with SHChangeNotify
-!ifdef SHCNE_ASSOCCHANGED
-!undef SHCNE_ASSOCCHANGED
-!endif
-!define SHCNE_ASSOCCHANGED 0x08000000
-!ifdef SHCNF_FLUSH
-!undef SHCNF_FLUSH
-!endif
-!define SHCNF_FLUSH        0x1000
-
-!macro UPDATEFILEASSOC
-; Using the system.dll plugin to call the SHChangeNotify Win32 API function so we
-; can update the shell.
-  System::Call &quot;shell32::SHChangeNotify(i,i,i,i) (${SHCNE_ASSOCCHANGED}, ${SHCNF_FLUSH}, 0, 0)&quot;
-!macroend
-
-;EOF
\ No newline at end of file

Copied: branches/caiinterface/installer/include/fileassoc.nsh (from rev 6800, trunk/installer/include/fileassoc.nsh)
===================================================================
--- branches/caiinterface/installer/include/fileassoc.nsh	                        (rev 0)
+++ branches/caiinterface/installer/include/fileassoc.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -0,0 +1,119 @@
+; fileassoc.nsh
+; File association helper macros
+; Written by Saivert
+;
+; Features automatic backup system and UPDATEFILEASSOC macro for
+; shell change notification.
+;
+; |&gt; How to use &lt;|
+; To associate a file with an application so you can double-click it in explorer, use
+; the APP_ASSOCIATE macro like this:
+;
+;   Example:
+;   !insertmacro APP_ASSOCIATE &quot;txt&quot; &quot;myapp.textfile&quot; &quot;$INSTDIR\myapp.exe,0&quot; \
+;     &quot;Open with myapp&quot; &quot;$INSTDIR\myapp.exe $\&quot;%1$\&quot;&quot;
+;
+; Never insert the APP_ASSOCIATE macro multiple times, it is only ment
+; to associate an application with a single file and using the
+; the &quot;open&quot; verb as default. To add more verbs (actions) to a file
+; use the APP_ASSOCIATE_ADDVERB macro.
+;
+;   Example:
+;   !insertmacro APP_ASSOCIATE_ADDVERB &quot;myapp.textfile&quot; &quot;edit&quot; &quot;Edit with myapp&quot; \
+;     &quot;$INSTDIR\myapp.exe /edit $\&quot;%1$\&quot;&quot;
+;
+; To have access to more options when registering the file association use the
+; APP_ASSOCIATE_EX macro. Here you can specify the verb and what verb is to be the
+; standard action (default verb).
+;
+; And finally: To remove the association from the registry use the APP_UNASSOCIATE
+; macro. Here is another example just to wrap it up:
+;   !insertmacro APP_UNASSOCIATE &quot;txt&quot; &quot;myapp.textfile&quot;
+;
+; |&gt; Note &lt;|
+; When defining your file class string always use the short form of your application title
+; then a period (dot) and the type of file. This keeps the file class sort of unique.
+;   Examples:
+;   Winamp.Playlist
+;   NSIS.Script
+;   Photoshop.JPEGFile
+;
+; |&gt; Tech info &lt;|
+; The registry key layout for a file association is:
+; HKEY_CLASSES_ROOT
+;     &lt;applicationID&gt; = &lt;&quot;description&quot;&gt;
+;         shell
+;             &lt;verb&gt; = &lt;&quot;menu-item text&quot;&gt;
+;                 command = &lt;&quot;command string&quot;&gt;
+;
+
+!macro APP_ASSOCIATE EXT FILECLASS DESCRIPTION ICON COMMANDTEXT COMMAND
+  ; Backup the previously associated file class
+  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; &quot;&quot;
+  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;${FILECLASS}_backup&quot; &quot;$R0&quot;
+
+  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;${FILECLASS}&quot;
+
+  WriteRegStr HKCR &quot;${FILECLASS}&quot; &quot;&quot; `${DESCRIPTION}`
+  WriteRegStr HKCR &quot;${FILECLASS}\DefaultIcon&quot; &quot;&quot; `${ICON}`
+  WriteRegStr HKCR &quot;${FILECLASS}\shell&quot; &quot;&quot; &quot;open&quot;
+  WriteRegStr HKCR &quot;${FILECLASS}\shell\open&quot; &quot;&quot; `${COMMANDTEXT}`
+  WriteRegStr HKCR &quot;${FILECLASS}\shell\open\command&quot; &quot;&quot; `${COMMAND}`
+!macroend
+
+!macro APP_ASSOCIATE_EX EXT FILECLASS DESCRIPTION ICON VERB DEFAULTVERB SHELLNEW COMMANDTEXT COMMAND
+  ; Backup the previously associated file class
+  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; &quot;&quot;
+  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;${FILECLASS}_backup&quot; &quot;$R0&quot;
+
+  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;${FILECLASS}&quot;
+  StrCmp &quot;${SHELLNEW}&quot; &quot;0&quot; +2
+  WriteRegStr HKCR &quot;.${EXT}\ShellNew&quot; &quot;NullFile&quot; &quot;&quot;
+
+  WriteRegStr HKCR &quot;${FILECLASS}&quot; &quot;&quot; `${DESCRIPTION}`
+  WriteRegStr HKCR &quot;${FILECLASS}\DefaultIcon&quot; &quot;&quot; `${ICON}`
+  WriteRegStr HKCR &quot;${FILECLASS}\shell&quot; &quot;&quot; `${DEFAULTVERB}`
+  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}&quot; &quot;&quot; `${COMMANDTEXT}`
+  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}\command&quot; &quot;&quot; `${COMMAND}`
+!macroend
+
+!macro APP_ASSOCIATE_ADDVERB FILECLASS VERB COMMANDTEXT COMMAND
+  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}&quot; &quot;&quot; `${COMMANDTEXT}`
+  WriteRegStr HKCR &quot;${FILECLASS}\shell\${VERB}\command&quot; &quot;&quot; `${COMMAND}`
+!macroend
+
+!macro APP_ASSOCIATE_REMOVEVERB FILECLASS VERB
+  DeleteRegKey HKCR `${FILECLASS}\shell\${VERB}`
+!macroend
+
+
+!macro APP_UNASSOCIATE EXT FILECLASS
+  ; Backup the previously associated file class
+  ReadRegStr $R0 HKCR &quot;.${EXT}&quot; `${FILECLASS}_backup`
+  WriteRegStr HKCR &quot;.${EXT}&quot; &quot;&quot; &quot;$R0&quot;
+
+  DeleteRegKey HKCR `${FILECLASS}`
+!macroend
+
+!macro APP_ASSOCIATE_GETFILECLASS OUTPUT EXT
+  ReadRegStr ${OUTPUT} HKCR &quot;.${EXT}&quot; &quot;&quot;
+!macroend
+
+
+; !defines for use with SHChangeNotify
+!ifdef SHCNE_ASSOCCHANGED
+!undef SHCNE_ASSOCCHANGED
+!endif
+!define SHCNE_ASSOCCHANGED 0x08000000
+!ifdef SHCNF_FLUSH
+!undef SHCNF_FLUSH
+!endif
+!define SHCNF_FLUSH        0x1000
+
+!macro UPDATEFILEASSOC
+; Using the system.dll plugin to call the SHChangeNotify Win32 API function so we
+; can update the shell.
+  System::Call &quot;shell32::SHChangeNotify(i,i,i,i) (${SHCNE_ASSOCCHANGED}, ${SHCNF_FLUSH}, 0, 0)&quot;
+!macroend
+
+;EOF
\ No newline at end of file

Deleted: branches/caiinterface/installer/include/otacontent.nsh
===================================================================
--- trunk/installer/include/otacontent.nsh	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/include/otacontent.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,48 +0,0 @@
-;Three functions which check to make sure OTA Content is installed before installing mods that depend on it.
-
-Function CheckTATextures
-  ClearErrors
-  FileOpen $0 &quot;$INSTDIR\base\tatextures_v062.sdz&quot; r
-  IfErrors Fail
-  FileSeek $0 0 END $1
-
-  IntCmp $1 1245637 Done
-Fail:
-  inetc::get \
-             &quot;<A HREF="http://installer.clan-sy.com/base/tatextures_v062.sdz">http://installer.clan-sy.com/base/tatextures_v062.sdz</A>&quot; &quot;$INSTDIR\base\tatextures_v062.sdz&quot;
-Done:
-  FileClose $0
-
-FunctionEnd
-
-
-Function CheckOTAContent
-  ClearErrors
-  FileOpen $0 &quot;$INSTDIR\base\otacontent.sdz&quot; r
-  IfErrors Fail
-  FileSeek $0 0 END $1
-
-  IntCmp $1 7421640 Done
-Fail:
-  inetc::get \
-             &quot;<A HREF="http://installer.clan-sy.com/base/otacontent.sdz">http://installer.clan-sy.com/base/otacontent.sdz</A>&quot; &quot;$INSTDIR\base\otacontent.sdz&quot;
-Done:
-  FileClose $0
-
-FunctionEnd
-
-
-Function CheckTAContent
-  ClearErrors
-  FileOpen $0 &quot;$INSTDIR\base\tacontent_v2.sdz&quot; r
-  IfErrors Fail
-  FileSeek $0 0 END $1
-
-  IntCmp $1 284 Done
-Fail:
-  inetc::get \
-             &quot;<A HREF="http://installer.clan-sy.com/base/tacontent_v2.sdz">http://installer.clan-sy.com/base/tacontent_v2.sdz</A>&quot; &quot;$INSTDIR\base\tacontent_v2.sdz&quot;
-Done:
-  FileClose $0
-
-FunctionEnd

Copied: branches/caiinterface/installer/include/otacontent.nsh (from rev 6800, trunk/installer/include/otacontent.nsh)
===================================================================
--- branches/caiinterface/installer/include/otacontent.nsh	                        (rev 0)
+++ branches/caiinterface/installer/include/otacontent.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -0,0 +1,48 @@
+;Three functions which check to make sure OTA Content is installed before installing mods that depend on it.
+
+Function CheckTATextures
+  ClearErrors
+  FileOpen $0 &quot;$INSTDIR\base\tatextures_v062.sdz&quot; r
+  IfErrors Fail
+  FileSeek $0 0 END $1
+
+  IntCmp $1 1245637 Done
+Fail:
+  inetc::get \
+             &quot;<A HREF="http://installer.clan-sy.com/base/tatextures_v062.sdz">http://installer.clan-sy.com/base/tatextures_v062.sdz</A>&quot; &quot;$INSTDIR\base\tatextures_v062.sdz&quot;
+Done:
+  FileClose $0
+
+FunctionEnd
+
+
+Function CheckOTAContent
+  ClearErrors
+  FileOpen $0 &quot;$INSTDIR\base\otacontent.sdz&quot; r
+  IfErrors Fail
+  FileSeek $0 0 END $1
+
+  IntCmp $1 7421640 Done
+Fail:
+  inetc::get \
+             &quot;<A HREF="http://installer.clan-sy.com/base/otacontent.sdz">http://installer.clan-sy.com/base/otacontent.sdz</A>&quot; &quot;$INSTDIR\base\otacontent.sdz&quot;
+Done:
+  FileClose $0
+
+FunctionEnd
+
+
+Function CheckTAContent
+  ClearErrors
+  FileOpen $0 &quot;$INSTDIR\base\tacontent_v2.sdz&quot; r
+  IfErrors Fail
+  FileSeek $0 0 END $1
+
+  IntCmp $1 284 Done
+Fail:
+  inetc::get \
+             &quot;<A HREF="http://installer.clan-sy.com/base/tacontent_v2.sdz">http://installer.clan-sy.com/base/tacontent_v2.sdz</A>&quot; &quot;$INSTDIR\base\tacontent_v2.sdz&quot;
+Done:
+  FileClose $0
+
+FunctionEnd

Copied: branches/caiinterface/installer/nsis_plugins (from rev 6800, trunk/installer/nsis_plugins)

Deleted: branches/caiinterface/installer/nsis_plugins/FindProcDLL.dll
===================================================================
(Binary files differ)

Copied: branches/caiinterface/installer/nsis_plugins/FindProcDLL.dll (from rev 6800, trunk/installer/nsis_plugins/FindProcDLL.dll)
===================================================================
(Binary files differ)

Deleted: branches/caiinterface/installer/nsis_plugins/inetc.dll
===================================================================
(Binary files differ)

Copied: branches/caiinterface/installer/nsis_plugins/inetc.dll (from rev 6800, trunk/installer/nsis_plugins/inetc.dll)
===================================================================
(Binary files differ)

Modified: branches/caiinterface/installer/sections/main.nsh
===================================================================
--- branches/caiinterface/installer/sections/main.nsh	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/sections/main.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -23,7 +23,7 @@
   Delete &quot;$INSTDIR\python24.dll&quot;
   Delete &quot;$INSTDIR\MSVCP71.dll&quot;
   Delete &quot;$INSTDIR\MSVCR71.dll&quot;
-  
+
   ; Delete Previous settings.exe
   Delete &quot;..\game\settings.exe&quot;
   File &quot;..\external\SelectionEditor.exe&quot;
@@ -32,7 +32,7 @@
 ;New Settings Program
 
   inetc::get \
-  &quot;<A HREF="http://www.springlobby.info/installer/springsettings.exe">http://www.springlobby.info/installer/springsettings.exe</A>&quot; &quot;$INSTDIR\springsettings.exe&quot; 
+  &quot;<A HREF="http://www.springlobby.info/installer/springsettings.exe">http://www.springlobby.info/installer/springsettings.exe</A>&quot; &quot;$INSTDIR\springsettings.exe&quot;
 
   File &quot;..\external\mingwm10.dll&quot;
   File &quot;..\external\wxbase28u_gcc_custom.dll&quot;
@@ -115,29 +115,10 @@
 ${IfNot} ${FileExists} &quot;$INSTDIR\spring.exe&quot;
   ; Demofile file association
   !insertmacro APP_ASSOCIATE &quot;sdf&quot; &quot;spring.demofile&quot; &quot;Spring demo file&quot; &quot;$INSTDIR\spring.exe,0&quot; &quot;Open with Spring&quot; &quot;$\&quot;$INSTDIR\spring.exe$\&quot; $\&quot;%1$\&quot;&quot;
-  !insertmacro UPDATEFILEASSOC 
+  !insertmacro UPDATEFILEASSOC
 ${EndIf}
 ;!endif ; SP_UPDATE
 
-; Fix issue with riverdale maps by deleting old versions and installing the latest one (if riverdale is already present)
-${If} ${FileExists} &quot;$INSTDIR\maps\River_Dalev01.sd7&quot;
-  Delete &quot;$INSTDIR\maps\River_Dalev01.sd7&quot;
-${AndIfNot} ${FileExists} &quot;$INSTDIR\maps\River_Dale-V01(onlyRiverdale).sd7&quot; 
-  inetc::get \
-	     &quot;<A HREF="http://installer.clan-sy.com/maps/River_Dale-V01(onlyRiverdale">http://installer.clan-sy.com/maps/River_Dale-V01(onlyRiverdale</A>).sd7&quot; &quot;$INSTDIR\maps\River_Dale-V01(onlyRiverdale).sd7&quot; 
-${OrIf} ${FileExists} &quot;$INSTDIR\maps\River_Dale-v01.sd7&quot;
-  Delete &quot;$INSTDIR\maps\River_Dale-v01.sd7&quot;
-${AndIfNot} ${FileExists} &quot;$INSTDIR\maps\River_Dale-V01(onlyRiverdale).sd7&quot; 
-  inetc::get \
-	     &quot;<A HREF="http://installer.clan-sy.com/maps/River_Dale-V01(onlyRiverdale">http://installer.clan-sy.com/maps/River_Dale-V01(onlyRiverdale</A>).sd7&quot; &quot;$INSTDIR\maps\River_Dale-V01(onlyRiverdale).sd7&quot; 
-${EndIf}
-
-; Fix small divide desync
-${If} ${FileExists} &quot;$INSTDIR\maps\SmallDivide.sd7&quot;
-  Delete &quot;$INSTDIR\maps\SmallDivide.sd7&quot;
-    inetc::get \
-	     &quot;<A HREF="http://installer.clan-sy.com/maps/SmallDivide.sd7">http://installer.clan-sy.com/maps/SmallDivide.sd7</A>&quot; &quot;$INSTDIR\maps\SmallDivide.sd7&quot; 
-${EndIf}
 !else
 
   ; Main files
@@ -181,7 +162,7 @@
   ; Fonts
   Delete &quot;$INSTDIR\fonts\Luxi.ttf&quot;
   RmDir &quot;$INSTDIR\fonts&quot;
-  
+
   ; AI Bot dlls
   Delete &quot;$INSTDIR\AI\Skirmish\impls\TestGlobalAI.dll&quot;
   RmDir &quot;$INSTDIR\AI\Skirmish\impls&quot;

Modified: branches/caiinterface/installer/spring.nsi
===================================================================
--- branches/caiinterface/installer/spring.nsi	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/spring.nsi	2008-10-17 22:50:00 UTC (rev 6801)
@@ -3,6 +3,8 @@
 ; Compiler-defines to generate different types of installers
 ;   SP_UPDATE - Only include changed files and no maps
 
+!addPluginDir &quot;nsis_plugins&quot;
+
 ; Use the 7zip-like compressor
 SetCompressor lzma
 
@@ -94,16 +96,26 @@
 ;ShowInstDetails show ;fix graphical glitch
 ;ShowUnInstDetails show ;fix graphical glitch
 
-!include fileassoc.nsh
+!include &quot;include\fileassoc.nsh&quot;
+!include &quot;include\otacontent.nsh&quot;
+!include &quot;include\checkrunning.nsh&quot;
 
+
 Function .onInit
+  ; check if we need to exit some processes which may be using unitsync
+  call CheckTASClientRunning
+  call CheckSpringDownloaderRunning
+  call CheckCADownloaderRunning
+  call CheckSpringLobbyRunning
+  call CheckSpringSettingsRunning
+
   ;Push $0 ; Create variable $0
 
   ; The core cannot be deselected
   ;SectionGetFlags 0 $0 ; Get the current selection of the first component and store in variable $0
   ;IntOp $0 $0 | 16 ; Change the selection flag in variable $0 to read only (16)
   ;SectionSetFlags 0 $0 ; Set the selection flag of the first component to the contents of variable $0
-  
+
   ;Pop $0 ; Delete variable $0
   ${IfNot} ${FileExists} &quot;$INSTDIR\spring.exe&quot;
     !insertmacro SetSectionFlag 0 16 ; make the core section read only
@@ -153,10 +165,10 @@
 Function GetDotNETVersion
   Push $0 ; Create variable 0 (version number).
   Push $1 ; Create variable 1 (error).
-  
+
   ; Request the version number from the Microsoft .NET Runtime Execution Engine DLL
   System::Call &quot;mscoree::GetCORVersion(w .r0, i ${NSIS_MAX_STRLEN}, *i) i .r1 ?u&quot;
- 
+
  ; If error, set &quot;not found&quot; as the top element of the stack. Otherwise, set the version number.
   StrCmp $1 &quot;error&quot; 0 +2 ; If variable 1 is equal to &quot;error&quot;, continue, otherwise skip the next couple of lines.
   StrCpy $0 &quot;not found&quot;
@@ -174,7 +186,7 @@
     Delete   &quot;$INSTDIR\dotnetfx.exe&quot;
   Goto next
 false:
-next:  
+next:
 FunctionEnd
 
 Function OldDotNet
@@ -216,53 +228,7 @@
 ; For CA and Evolution: END
 
 
-;Three functions which check to make sure OTA Content is installed before installing Mods that depend on it.
-Function CheckTATextures
-  ClearErrors
-  FileOpen $0 &quot;$INSTDIR\base\tatextures_v062.sdz&quot; r
-  IfErrors Fail
-  FileSeek $0 0 END $1
 
-  IntCmp $1 1245637 Done              
-Fail:
-  inetc::get \
-             &quot;<A HREF="http://installer.clan-sy.com/base/tatextures_v062.sdz">http://installer.clan-sy.com/base/tatextures_v062.sdz</A>&quot; &quot;$INSTDIR\base\tatextures_v062.sdz&quot; 
-Done:
-  FileClose $0
-
-FunctionEnd
-
-Function CheckOTAContent
-  ClearErrors
-  FileOpen $0 &quot;$INSTDIR\base\otacontent.sdz&quot; r
-  IfErrors Fail
-  FileSeek $0 0 END $1
-
-  IntCmp $1 7421640 Done              
-Fail:
-  inetc::get \
-             &quot;<A HREF="http://installer.clan-sy.com/base/otacontent.sdz">http://installer.clan-sy.com/base/otacontent.sdz</A>&quot; &quot;$INSTDIR\base\otacontent.sdz&quot; 
-Done:
-  FileClose $0
-
-FunctionEnd
-
-Function CheckTAContent
-  ClearErrors
-  FileOpen $0 &quot;$INSTDIR\base\tacontent_v2.sdz&quot; r
-  IfErrors Fail
-  FileSeek $0 0 END $1
-
-  IntCmp $1 284 Done              
-Fail:
-  inetc::get \
-             &quot;<A HREF="http://installer.clan-sy.com/base/tacontent_v2.sdz">http://installer.clan-sy.com/base/tacontent_v2.sdz</A>&quot; &quot;$INSTDIR\base\tacontent_v2.sdz&quot;
-Done:
-  FileClose $0
-
-FunctionEnd
-
-
 Section &quot;Main application (req)&quot; SEC_MAIN
 !ifdef SP_UPDATE
 !ifndef TEST_BUILD
@@ -276,7 +242,7 @@
 SectionEnd
 
 
-SectionGroup &quot;Multiplayer battlerooms&quot; 
+SectionGroup &quot;Multiplayer battlerooms&quot;
   Section &quot;TASClient&quot; SEC_TASCLIENT
   !define INSTALL
   !include &quot;sections\tasclient.nsh&quot;
@@ -287,7 +253,7 @@
   !define INSTALL
   !include &quot;sections\springlobby.nsh&quot;
   !undef INSTALL
-  SectionEnd  
+  SectionEnd
 SectionGroupEnd
 
 
@@ -335,7 +301,7 @@
 	!include &quot;sections\xta.nsh&quot;
 	!undef INSTALL
 	SectionEnd
- 
+
 	Section &quot;Gundam&quot; SEC_GUNDAM
 	!define INSTALL
 	AddSize 51000
@@ -349,7 +315,7 @@
 	!include &quot;sections\kp.nsh&quot;
 	!undef INSTALL
 	SectionEnd
-	
+
 	Section &quot;Evolution RTS&quot; SEC_EVOLUTION
 	!define INSTALL
 	AddSize 38700

Modified: branches/caiinterface/installer/springsettings.nsh
===================================================================
--- branches/caiinterface/installer/springsettings.nsh	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/installer/springsettings.nsh	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,10 +1,10 @@
 !ifdef TEST_BUILD
  !define PRODUCT_NAME &quot;Spring - Test Build&quot;
- !define PRODUCT_VERSION &quot;0.77b5+svn${REVISION}&quot;
+ !define PRODUCT_VERSION &quot;0.77b4+svn${REVISION}&quot;
  !define SP_BASENAME &quot;spring_${PRODUCT_VERSION}&quot;
 !else
  !define PRODUCT_NAME &quot;Spring&quot;
- !define PRODUCT_VERSION &quot;0.77b5&quot;
+ !define PRODUCT_VERSION &quot;0.77b4&quot;
  !define SP_BASENAME &quot;spring_${PRODUCT_VERSION}&quot;
 !endif
 

Modified: branches/caiinterface/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,5 +1,6 @@
 // Generalized callback interface - shared between global AI and group AI
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
 #include &quot;Game/Camera.h&quot;
@@ -49,14 +50,6 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;mmgr.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex unitmutex;
-#	endif
-#endif
-
 /* Cast id to unsigned to catch negative ids in the same operations,
 cast MAX_* to unsigned to suppress GCC comparison between signed/unsigned warning. */
 #define CHECK_UNITID(id) ((unsigned)(id) &lt; (unsigned)MAX_UNITS)
@@ -1012,9 +1005,7 @@
 	tdu.facing=facing;
 	std::pair&lt;int,CUnitDrawer::TempDrawUnit&gt; tp(gs-&gt;frameNum+lifetime,tdu);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex); // maybe superfluous
-#endif
+	GML_STDMUTEX_LOCK(temp); //unit); // maybe superfluous
 
 	if(transparent)
 		unitDrawer-&gt;tempTransparentDrawUnits.insert(tp);

Modified: branches/caiinterface/rts/ExternalAI/Group.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Group.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/ExternalAI/Group.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -142,6 +142,8 @@
 
 bool CGroup::AddUnit(CUnit *unit)
 {
+	GML_STDMUTEX_LOCK(group); // AddUnit
+
 	eventHandler.GroupChanged(id);
 
 	units.insert(unit);
@@ -162,6 +164,8 @@
 
 void CGroup::RemoveUnit(CUnit *unit)
 {
+	GML_STDMUTEX_LOCK(group); // RemoveUnit
+
 	eventHandler.GroupChanged(id);
 	if(ai)
 		ai-&gt;RemoveUnit(unit-&gt;id);
@@ -233,6 +237,7 @@
 
 void CGroup::DrawCommands()
 {
+//	GML_STDMUTEX_LOCK(cai); // DrawCommands. Not needed, protected via CGroupHandler
 	if(units.empty() &amp;&amp; id&gt;=10 &amp;&amp; /*handler==grouphandler*/handler-&gt;team==gu-&gt;myTeam){		//last check is a hack so globalai groups dont get erased
 		handler-&gt;RemoveGroup(this);
 		return;
@@ -341,6 +346,8 @@
 
 void CGroup::ClearUnits(void)
 {
+	GML_STDMUTEX_LOCK(group); // ClearUnits
+
 	eventHandler.GroupChanged(id);
 	while(!units.empty()){
 		(*units.begin())-&gt;SetGroup(0);

Modified: branches/caiinterface/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/ExternalAI/GroupHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -87,6 +87,7 @@
 
 void CGroupHandler::DrawCommands()
 {
+	GML_STDMUTEX_LOCK(cai);
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)!=0)
 			(*ai)-&gt;DrawCommands();

Modified: branches/caiinterface/rts/Game/Camera/OrbitController.cpp
===================================================================
--- branches/caiinterface/rts/Game/Camera/OrbitController.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/Camera/OrbitController.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -41,8 +41,8 @@
 	const float3 w = (v / v.Length()); // do not normalize v in-place
 
 	const float d = v.Length();
-	const float e = RAD2DEG(acosf(v.Length2D() / d));
-	const float r = RAD2DEG(acosf(w.x));
+	const float e = RAD2DEG(acos(v.Length2D() / d));
+	const float r = RAD2DEG(acos(w.x));
 
 	distance  = cDistance = d;
 	elevation = cElevation = e;
@@ -223,12 +223,12 @@
 	float tx = cx;
 
 	tx = cx;
-	cx = cx * cosf(beta) + cy * sinf(beta);
-	cy = tx * sinf(beta) + cy * cosf(beta);
+	cx = cx * cos(beta) + cy * sin(beta);
+	cy = tx * sin(beta) + cy * cos(beta);
 
 	tx = cx;
-	cx = cx * cosf(gamma) - cz * sinf(gamma);
-	cz = tx * sinf(gamma) + cz * cosf(gamma);
+	cx = cx * cos(gamma) - cz * sin(gamma);
+	cz = tx * sin(gamma) + cz * cos(gamma);
 
 	return float3(cx, cy, cz);
 }

Modified: branches/caiinterface/rts/Game/Game.cpp
===================================================================
--- branches/caiinterface/rts/Game/Game.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/Game.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -435,7 +435,7 @@
 	keyBindings = SAFE_NEW CKeyBindings();
 	keyBindings-&gt;Load(&quot;uikeys.txt&quot;);
 
-	water=CBaseWater::GetWater();
+	water=CBaseWater::GetWater(NULL);
 	for(int a=0;a&lt;MAX_TEAMS;a++)
 		grouphandlers[a] = SAFE_NEW CGroupHandler(a);
 
@@ -637,8 +637,7 @@
 	}
 
 	// Fix water renderer, they depend on screen resolution...
-	delete water;
-	water = CBaseWater::GetWater();
+	water = CBaseWater::GetWater(water);
 
 	eventHandler.ViewResize();
 }
@@ -944,8 +943,6 @@
 		shadowHandler = SAFE_NEW CShadowHandler();
 	}
 	else if (cmd == &quot;water&quot;) {
-		delete water;
-
 		static char rmodes[5][32] = {&quot;basic&quot;, &quot;reflective&quot;, &quot;dynamic&quot;, &quot;reflective&amp;refractive&quot;, &quot;bumpmapped&quot;};
 		int next = 0;
 
@@ -957,7 +954,7 @@
 		}
 		configHandler.SetInt(&quot;ReflectiveWater&quot;, next);
 		logOutput.Print(&quot;Set water rendering mode to %i (%s)&quot;, next, rmodes[next]);
-		water = CBaseWater::GetWater();
+		water = CBaseWater::GetWater(water);
 	}
 	else if (cmd == &quot;advshading&quot;) {
 		static bool canUse = unitDrawer-&gt;advShading;
@@ -2405,7 +2402,6 @@
 	good_fpu_control_registers(&quot;CGame::Update&quot;);
 
 	mouse-&gt;EmptyMsgQueUpdate();
-	thisFps++;
 
 	unsigned timeNow = SDL_GetTicks();
 
@@ -2508,13 +2504,6 @@
 	return true;
 }
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex luamutex;
-#	endif
-#endif
 
 bool CGame::DrawWorld()
 {
@@ -2540,6 +2529,7 @@
 
 	selectedUnits.Draw();
 	eventHandler.DrawWorldPreUnit();
+
 	unitDrawer-&gt;Draw(false);
 	featureHandler-&gt;Draw();
 
@@ -2656,6 +2646,8 @@
 bool CGame::Draw() {
 #endif
 
+	thisFps++;
+
 	ASSERT_UNSYNCED_MODE;
 
 	SetDrawMode(normalDraw);
@@ -2668,6 +2660,11 @@
 	if (luaGaia)  { luaGaia-&gt;CheckStack(); }
 	if (luaRules) { luaRules-&gt;CheckStack(); }
 
+	texturehandler-&gt;Update(); // delayed loading of textures
+	modelParser-&gt;Update(); // delayed fixup of models
+	treeDrawer-&gt;UpdateDraw(); // delete disp lists
+	readmap-&gt;UpdateDraw(); // update heightmap texture
+
 	LuaUnsyncedCtrl::ClearUnitCommandQueues();
 
 	eventHandler.Update();
@@ -3056,21 +3053,20 @@
 	}
 }
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 int numNewFrames=0;
 #endif
 
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 void CGame::SimFrame() {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	SimFrameMT();
+#	else
+#		if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 	if(gmlThreadCount&gt;1) { // if there is more than one cpu, run draw in parallel with sim
 		int oldgsframe=gs-&gt;frameNum;
 		gmlProcessor.AuxWork(&amp;CGame::SimFrameMTcb,this); // start sim thread
 		UnsyncedStuff();
-		while(oldgsframe==*(volatile int *)&amp;(gs-&gt;frameNum)) { // wait until GL calls in script.update() have finished (ugly hack)
-			gmlProcessor.PumpAux();
-			boost::thread::yield();
-		}
 		if(--numNewFrames==0) {
 			gu-&gt;drawFrame++;
 			if (gu-&gt;drawFrame == 0)
@@ -3083,8 +3079,9 @@
 		}
 	}
 	else
-#	endif
+#		endif
 	gmlProcessor.Work(&amp;CGame::SimFrameMTcb,NULL,NULL,this,2,FALSE,NULL,1,2,2,FALSE,&amp;CGame::UnsyncedStuffcb);
+#	endif
 #else
 void CGame::SimFrameMT() {
 #endif
@@ -3114,16 +3111,13 @@
 	if (luaUI)    { luaUI-&gt;GameFrame(gs-&gt;frameNum); }
 	if (luaGaia)  { luaGaia-&gt;GameFrame(gs-&gt;frameNum); }
 	if (luaRules) { luaRules-&gt;GameFrame(gs-&gt;frameNum); }
-/*
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	gmlProcessor.GetQueue();
-#endif*/
+
 	gs-&gt;frameNum++;
 
 	ENTER_UNSYNCED;
 
 	if (!skipping) {
-#if !defined(USE_GML) || !GML_ENABLE_SIM
+#if !defined(USE_GML) || !GML_ENABLE_SIM || GML_ENABLE_SIMLOOP
     UnsyncedStuff();
 #endif
 //		infoConsole-&gt;Update();
@@ -3276,7 +3270,7 @@
 	boost::shared_ptr&lt;const netcode::RawPacket&gt; packet;
 
 	// compute new timeLeft to &quot;smooth&quot; out SimFrame() calls
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 	numNewFrames=0;
 #endif
 	if(!gameServer){
@@ -3294,7 +3288,7 @@
 		int que = 0; // Number of NETMSG_NEWFRAMEs waiting to be processed.
 		unsigned ahead = 0;
 		while ((packet = net-&gt;Peek(ahead))) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 			if (packet-&gt;data[0] == NETMSG_NEWFRAME)
 				++numNewFrames;
 #endif
@@ -3308,7 +3302,7 @@
 	}
 	else
 	{
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
 		unsigned ahead = 0;
 		while ((packet = net-&gt;Peek(ahead))) {
 			if (packet-&gt;data[0] == NETMSG_NEWFRAME)
@@ -3752,10 +3746,10 @@
 				if ((player &lt; 0) || (player &gt;= MAX_PLAYERS)) {
 					logOutput.Print(&quot;Got invalid player num %i in LuaMsg&quot;, player);
 				}
-				const int script = inbuf[4];
-				const int mode = inbuf[5];
-				const int msglen = *((short*)(inbuf + 1)) - 6;
-				const string msg((char*)&amp;inbuf[6], msglen); // allow embedded 0's
+				const int script = *reinterpret_cast&lt;const unsigned short*&gt;(inbuf+4);
+				const int mode = inbuf[6];
+				const int msglen = *((short*)(inbuf + 1)) - 7;
+				const string msg((char*)&amp;inbuf[7], msglen); // allow embedded 0's
 				CLuaHandle::HandleLuaMsg(player, script, mode, msg);
 				AddTraffic(player, packetCode, dataLength);
 				break;
@@ -4644,9 +4638,8 @@
 				count++;
 				delete unit-&gt;cob;
 				unit-&gt;cob = SAFE_NEW CCobInstance(*newScript, unit);
-				delete unit-&gt;localmodel;
-				unit-&gt;localmodel =
-					modelParser-&gt;CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
+				modelParser-&gt;DeleteLocalModel(unit);
+				modelParser-&gt;CreateLocalModel(unit);
 				unit-&gt;cob-&gt;Call(&quot;Create&quot;);
 			}
 		}

Modified: branches/caiinterface/rts/Game/GameHelper.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/GameHelper.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 
 #include &quot;Camera.h&quot;
@@ -286,6 +287,8 @@
 	hit = 0x0;
 	CollisionQuery cq;
 
+	GML_RECMUTEX_LOCK(quad); // GuiTraceRay
+
 	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
 	vector&lt;int&gt;::iterator qi;
 
@@ -304,10 +307,6 @@
 				(useRadar &amp;&amp; radarhandler-&gt;InRadar(unit, gu-&gt;myAllyTeam))) {
 
 				CollisionVolume* cv = 0x0;
-				float3 error = (!gu-&gt;spectatingFullView)?
-					// relative error, since MouseHit() translates by relMidPos
-					(GetUnitErrorPos(unit, gu-&gt;myAllyTeam) - unit-&gt;midPos):
-					ZeroVector;
 
 				if (unit-&gt;isIcon) {
 					// for iconified units, just pretend the collision
@@ -319,7 +318,7 @@
 					cv = unit-&gt;collisionVolume;
 				}
 
-				if (CCollisionHandler::MouseHit(unit, error, start, start + dir * length, cv, &amp;cq)) {
+				if (CCollisionHandler::MouseHit(unit, start, start + dir * length, cv, &amp;cq)) {
 					// get the distance to the ray-volume egress point
 					// so we can still select stuff inside factories
 					const float len = (cq.p1 - start).Length();
@@ -474,6 +473,9 @@
 {
 	float closeDist = (radius * radius);
 	CUnit* closeUnit = NULL;
+
+	GML_RECMUTEX_LOCK(quad); //GetClosestUnit
+
 	vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
 
 	int tempNum = gs-&gt;tempNum++;
@@ -693,6 +695,9 @@
 float CGameHelper::GuiTraceRayFeature(const float3&amp; start, const float3&amp; dir, float length, CFeature*&amp; feature)
 {
 	float nearHit = length;
+
+	GML_RECMUTEX_LOCK(quad); //GuiTraceRayFeature
+
 	std::vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
 	std::vector&lt;int&gt;::iterator qi;
 

Modified: branches/caiinterface/rts/Game/GameServer.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameServer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/GameServer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -429,7 +429,7 @@
 				}
 			}
 
-			if (maxCpu &gt; 0.3f) {
+			if (maxCpu &gt; 0.0f) {
 				float wantedCpu=0.5f+(1-internalSpeed/userSpeedFactor)*0.5f;
 				//float speedMod=1+wantedCpu-maxCpu;
 				float newSpeed=internalSpeed*wantedCpu/maxCpu;
@@ -1196,6 +1196,12 @@
 		if (isPaused &amp;&amp; !demoReader)
 			gameServer-&gt;CreateNewFrame(true, true);
 	}
+#ifdef DEDICATED // we already have a quit command in the client
+	else if (action.command == &quot;kill&quot;)
+	{
+		quitServer = true;
+	}
+#endif
 	else
 	{
 		// only forward to players (send over network)
@@ -1473,7 +1479,7 @@
 	Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(msg.Pack()));
 	if (hostif &amp;&amp; msg.fromPlayer != SERVER_PLAYER) {
 		// don't echo packets to autohost
-		hostif-&gt;SendPlayerChat(msg.fromPlayer, msg.msg);
+		hostif-&gt;SendPlayerChat(msg.fromPlayer, msg.destination,  msg.msg);
 	}
 }
 

Modified: branches/caiinterface/rts/Game/GameSetup.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/GameSetup.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -92,7 +92,8 @@
 
 	for(int a = 0; a &lt; numTeams; ++a) {
 		float3 pos(1000.0f, 100.0f, 1000.0f);
-		mapParser.GetStartPos(a, pos);
+		if (!mapParser.GetStartPos(a, pos))
+			throw content_error(mapParser.GetErrorLog());
 		teamStartingData[a].startPos = SFloat3(pos.x, pos.y, pos.z);
 	}
 }
@@ -109,8 +110,6 @@
 	TdfParser file;
 	file.LoadBuffer(gameSetupText, gameSetupTextLength-1);
 	for (int a = 0; a &lt; numTeams; ++a) {
-		// Ready up automatically unless startPosType is choose in game
-		//teamStartingData[a].readyTeams = (startPosType != StartPos_ChooseInGame);
 		teamStartingData[a].teamStartNum = a;
 	}
 
@@ -395,6 +394,14 @@
 
 	// Game parameters
 	scriptName  = file.SGetValueDef(&quot;Commanders&quot;, &quot;GAME\\ScriptName&quot;);
+
+	// Used by dedicated server only
+	int tempMapHash, tempModHash;
+	file.GetDef(tempMapHash, &quot;0&quot;, &quot;GAME\\MapHash&quot;);
+	file.GetDef(tempModHash, &quot;0&quot;, &quot;GAME\\ModHash&quot;);
+	mapHash = (unsigned int) tempMapHash;
+	modHash = (unsigned int) tempModHash;
+
 	baseMod     = file.SGetValueDef(&quot;&quot;,  &quot;GAME\\Gametype&quot;);
 	mapName     = file.SGetValueDef(&quot;&quot;,  &quot;GAME\\MapName&quot;);
 	luaGaiaStr  = file.SGetValueDef(&quot;1&quot;, &quot;GAME\\LuaGaia&quot;);

Modified: branches/caiinterface/rts/Game/GameSetup.h
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/GameSetup.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -34,6 +34,8 @@
 	int numTeams;
 	int numAllyTeams;
 	bool fixedAllies;
+	unsigned int mapHash;
+	unsigned int modHash;
 	std::string mapName;
 	std::string baseMod;
 	std::string scriptName;

Modified: branches/caiinterface/rts/Game/SelectedUnits.cpp
===================================================================
--- branches/caiinterface/rts/Game/SelectedUnits.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/SelectedUnits.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -39,14 +39,6 @@
 #include &quot;Sound.h&quot;
 #include &quot;Util.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-extern boost::mutex caimutex;
-boost::mutex selmutex;
-#	endif
-#endif
-
 extern Uint8 *keys;
 
 
@@ -375,9 +367,7 @@
 		return;
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // AddUnit
 
 	selectedUnits.insert(unit);
 	AddDeathDependence(unit);
@@ -396,9 +386,7 @@
 
 void CSelectedUnits::RemoveUnit(CUnit* unit)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); //RemoveUnit
 
 	selectedUnits.erase(unit);
 	DeleteDeathDependence(unit);
@@ -414,9 +402,7 @@
 
 void CSelectedUnits::ClearSelected()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // ClearSelected
 
 	CUnitSet::iterator ui;
 	ENTER_MIXED;
@@ -435,9 +421,8 @@
 
 void CSelectedUnits::SelectGroup(int num)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // SelectGroup
+//	GML_STDMUTEX_LOCK(group); // SelectGroup. not needed? only reading group
 
 	ClearSelected();
 	selectedGroup=num;
@@ -465,6 +450,9 @@
 	glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 	glLineWidth(cmdColors.UnitBoxLineWidth());
 
+	GML_RECMUTEX_LOCK(sel); // Draw
+	GML_STDMUTEX_LOCK(group); // Draw
+
 	if (cmdColors.unitBox[3] &gt; 0.0f) {
 		glColor4fv(cmdColors.unitBox);
 
@@ -499,9 +487,7 @@
 				 ((guihandler-&gt;inCommand &gt;= 0) &amp;&amp;
 					(guihandler-&gt;inCommand &lt; guihandler-&gt;commands.size()) &amp;&amp;
 					(guihandler-&gt;commands[guihandler-&gt;inCommand].id &lt; 0)))) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-			boost::mutex::scoped_lock cailock(caimutex);
-#endif
+			GML_STDMUTEX_LOCK(cai); // Draw
 			bool myColor = true;
 			glColor4fv(cmdColors.buildBox);
 			std::list&lt;CBuilderCAI*&gt;::const_iterator bi;
@@ -534,9 +520,7 @@
 
 void CSelectedUnits::DependentDied(CObject *o)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // DependentDied, maybe superfluous - too late anyway
 
 	selectedUnits.erase((CUnit*)o);
 	selectionChanged=true;
@@ -645,8 +629,14 @@
 }
 
 
+// CALLINFO: 
+// DrawMapStuff --&gt; CGuiHandler::GetDefaultCommand --&gt; GetDefaultCmd
+// CMouseHandler::DrawCursor --&gt; DrawCentroidCursor --&gt; CGuiHandler::GetDefaultCommand --&gt; GetDefaultCmd
+// LuaUnsyncedRead::GetDefaultCommand --&gt; CGuiHandler::GetDefaultCommand --&gt; GetDefaultCmd
 int CSelectedUnits::GetDefaultCmd(CUnit* unit, CFeature* feature)
 {
+	GML_RECMUTEX_LOCK(sel); // GetDefaultCmd
+	GML_STDMUTEX_LOCK(group); // GetDefaultCmd
 	// NOTE: the unitDef-&gt;aihint value is being ignored
 	int luaCmd;
 	if (eventHandler.DefaultCommand(unit, feature, luaCmd)) {
@@ -696,7 +686,9 @@
 		possibleCommandsChanged = true;
 }
 
-
+// CALLINFO: 
+// CGame::Draw --&gt; DrawCommands
+// CMiniMap::DrawForReal --&gt; DrawCommands
 void CSelectedUnits::DrawCommands()
 {
 	glDisable(GL_TEXTURE_2D);
@@ -714,6 +706,10 @@
 
 	glLineWidth(cmdColors.QueuedLineWidth());
 
+	GML_RECMUTEX_LOCK(sel); // DrawCommands
+	GML_STDMUTEX_LOCK(group); // DrawCommands
+	GML_STDMUTEX_LOCK(cai); // DrawCommands
+
 	CUnitSet::iterator ui;
 	if (selectedGroup != -1) {
 		CUnitSet&amp; groupUnits = grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;units;
@@ -721,9 +717,6 @@
 			(*ui)-&gt;commandAI-&gt;DrawCommands();
 		}
 	} else {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::mutex::scoped_lock sellock(selmutex);
-#endif
 		for(ui = selectedUnits.begin(); ui != selectedUnits.end(); ++ui) {
 			(*ui)-&gt;commandAI-&gt;DrawCommands();
 		}
@@ -739,8 +732,15 @@
 }
 
 
+// CALLINFO:
+// CTooltipConsole::Draw --&gt; CMouseHandler::GetCurrentTooltip
+// LuaUnsyncedRead::GetCurrentTooltip --&gt; CMouseHandler::GetCurrentTooltip
+// CMouseHandler::GetCurrentTooltip --&gt; CMiniMap::GetToolTip --&gt; GetTooltip
+// CMouseHandler::GetCurrentTooltip --&gt; GetTooltip
 std::string CSelectedUnits::GetTooltip(void)
 {
+	GML_RECMUTEX_LOCK(sel); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
+	GML_STDMUTEX_LOCK(group); // GetTooltip
 	std::string s;
 	if ((selectedGroup != -1) &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
 		s = &quot;Group selected&quot;;
@@ -816,6 +816,8 @@
 
 void CSelectedUnits::SetCommandPage(int page)
 {
+	GML_RECMUTEX_LOCK(sel); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc --&gt; SetCommandPage
+	GML_STDMUTEX_LOCK(group); // SetCommandPage
 	if(selectedGroup!=-1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai){
 		grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;lastCommandPage=page;
 	}

Modified: branches/caiinterface/rts/Game/UI/EndGameBox.h
===================================================================
--- branches/caiinterface/rts/Game/UI/EndGameBox.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/UI/EndGameBox.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -52,7 +52,7 @@
 	};
 
 	struct Stat {
-		Stat(std::string s):max(1),maxdif(1),name(s){}
+		Stat(std::string s) : name(s),max(1),maxdif(1){}
 
 		void AddStat(int team,float value){
 			if(value&gt;max)

Modified: branches/caiinterface/rts/Game/UI/GuiHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/GuiHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/UI/GuiHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -56,16 +56,6 @@
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/Util.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::mutex caimutex;
-extern boost::mutex selmutex;
-extern boost::recursive_mutex quadmutex;
-#	endif
-#endif
-
 extern Uint8 *keys;
 
 
@@ -461,6 +451,8 @@
 
 int CGuiHandler::FindInCommandPage()
 {
+	GML_RECMUTEX_LOCK(gui); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; FindInCommandPage
+
 	if ((inCommand &lt; 0) || (inCommand &gt;= commands.size())) {
 		return -1;
 	}
@@ -477,6 +469,8 @@
 void CGuiHandler::RevertToCmdDesc(const CommandDescription&amp; cmdDesc,
                                   bool defaultCommand, bool samePage)
 {
+	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc
+
 	for (int a = 0; a &lt; commands.size(); ++a) {
 		if (commands[a].id == cmdDesc.id) {
 			if (defaultCommand) {
@@ -506,6 +500,8 @@
 
 void CGuiHandler::LayoutIcons(bool useSelectionPage)
 {
+	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons
+
 	const bool defCmd =
 		(mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed &amp;&amp;
 		 (defaultCmdMemory &gt;= 0) &amp;&amp; (inCommand &lt; 0) &amp;&amp;
@@ -929,6 +925,8 @@
 
 void CGuiHandler::Update()
 {
+	GML_RECMUTEX_LOCK(gui); // Update - updates inCommand
+
 	SetCursorIcon();
 
 	// Notify LuaUI about groups that have changed
@@ -1040,6 +1038,8 @@
 
 bool CGuiHandler::MousePress(int x, int y, int button)
 {
+	GML_RECMUTEX_LOCK(gui); // MousePress - updates inCommand
+
 	if (button == SDL_BUTTON_MIDDLE) {
 		return false;
 	}
@@ -1079,7 +1079,7 @@
 }
 
 
-void CGuiHandler::MouseRelease(int x, int y, int button)
+void CGuiHandler::MouseRelease(int x, int y, int button, float3&amp; camerapos, float3&amp; mousedir)
 {
 	int iconCmd = -1;
 
@@ -1120,7 +1120,7 @@
 	}
 
 	// not over a button, try to execute a command
-	Command c = GetCommand(x, y, button, false);
+	Command c = GetCommand(x, y, button, false, camerapos, mousedir);
 
 	// if cmd_stop is returned it indicates that no good command could be found
 	if (c.id != CMD_STOP) {
@@ -1134,6 +1134,8 @@
 
 bool CGuiHandler::SetActiveCommand(int cmdIndex, bool rmb)
 {
+	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand
+
 	if (cmdIndex &gt;= (int)commands.size()) {
 		return false;
 	}
@@ -1294,7 +1296,7 @@
 }
 
 
-int CGuiHandler::IconAtPos(int x, int y)
+int CGuiHandler::IconAtPos(int x, int y) // GetToolTip --&gt; IconAtPos
 {
 	const float fx = MouseX(x);
 	const float fy = MouseY(y);
@@ -1440,6 +1442,8 @@
 
 bool CGuiHandler::AboveGui(int x, int y)
 {
+	GML_RECMUTEX_LOCK(gui); // CMouseHandler::GetCurrentTooltip --&gt; IsAbove --&gt; AboveGui
+
 	if (iconsCount &lt;= 0) {
 		return false;
 	}
@@ -1494,8 +1498,11 @@
 	return (minV + (factor * (maxV - minV)));
 }
 
-
-int CGuiHandler::GetDefaultCommand(int x, int y) const
+// CALLINFO: 
+// DrawMapStuff --&gt; GetDefaultCommand
+// CMouseHandler::DrawCursor --&gt; DrawCentroidCursor --&gt; GetDefaultCommand
+// LuaUnsyncedRead::GetDefaultCommand --&gt; GetDefaultCommand
+int CGuiHandler::GetDefaultCommand(int x, int y, float3&amp; camerapos, float3&amp; mousedir) const
 {
 	CInputReceiver* ir = NULL;
 	if (!game-&gt;hideInterface) {
@@ -1506,15 +1513,17 @@
 		return -1;
 	}
 
+	GML_RECMUTEX_LOCK(quad); // GetDefaultCommand
 	CUnit* unit = NULL;
+//	GML_RECMUTEX_LOCK(unit); // GetDefaultCommand
 	CFeature* feature = NULL;
-
+//	GML_RECMUTEX_LOCK(feat); // GetDefaultCommand
 	if ((ir == minimap) &amp;&amp; (minimap-&gt;FullProxy())) {
 		unit = minimap-&gt;GetSelectUnit(minimap-&gt;GetMapPosition(x, y));
 	}
 	else {
-		const float3 camPos = camera-&gt;pos;
-		const float3 camDir = mouse-&gt;dir;
+		const float3 camPos = camerapos;
+		const float3 camDir = mousedir;
 		const float viewRange = gu-&gt;viewRange*1.4f;
 		const float dist = helper-&gt;GuiTraceRay(camPos, camDir, viewRange, unit, 20, true);
 		const float dist2 = helper-&gt;GuiTraceRayFeature(camPos, camDir, viewRange, feature);
@@ -1536,6 +1545,8 @@
 		}
 	}
 
+	GML_RECMUTEX_LOCK(gui); // GetDefaultCommand
+
 	// make sure the command is currently available
 	const int cmd_id = selectedUnits.GetDefaultCmd(unit, feature);
 	for (int c = 0; c &lt; (int)commands.size(); c++) {
@@ -1741,7 +1752,7 @@
 }
 
 
-int CGuiHandler::GetIconPosCommand(int slot) const
+int CGuiHandler::GetIconPosCommand(int slot) const // only called by SetActiveCommand
 {
 	if (slot &lt; 0) {
 		return -1;
@@ -1756,6 +1767,8 @@
 
 bool CGuiHandler::KeyPressed(unsigned short key, bool isRepeat)
 {
+	GML_RECMUTEX_LOCK(gui); // KeyPressed - updates inCommand
+
 	if (key == SDLK_ESCAPE &amp;&amp; activeMousePress) {
 		activeMousePress = false;
 		inCommand = -1;
@@ -1804,6 +1817,8 @@
 bool CGuiHandler::SetActiveCommand(const Action&amp; action,
                                    const CKeySet&amp; ks, int actionIndex)
 {
+	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand
+
 	if (ProcessLocalActions(action)) {
 		return true;
 	}
@@ -2021,6 +2036,8 @@
 
 void CGuiHandler::MenuChoice(std::string s)
 {
+	GML_RECMUTEX_LOCK(gui); // MenuChoice - updates inCommand
+
 	if (activeReceiver == list) {
 		activeReceiver = NULL;
 	}
@@ -2056,6 +2073,8 @@
 
 void CGuiHandler::FinishCommand(int button)
 {
+	GML_RECMUTEX_LOCK(gui); // FinishCommand - updates inCommand
+
 	if ((button == SDL_BUTTON_LEFT) &amp;&amp; (keys[SDLK_LSHIFT] || invertQueueKey)) {
 		needShift=true;
 	} else {
@@ -2073,6 +2092,8 @@
 
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
+	GML_RECMUTEX_LOCK(gui); // GetTooltip
+
 	std::string s;
 
 	const int iconPos = IconAtPos(x, y);
@@ -2097,9 +2118,13 @@
 	return s;
 }
 
-
+// CALLINFO:
+// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; CMiniMap::gettooltip --&gt; GetBuildTooltip
 std::string CGuiHandler::GetBuildTooltip() const
 {
+	GML_RECMUTEX_LOCK(gui); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size()) &amp;&amp;
 	    (commands[inCommand].type == CMDTYPE_ICON_BUILDING)) {
 		return commands[inCommand].tooltip;
@@ -2114,8 +2139,9 @@
 }
 
 
-Command CGuiHandler::GetCommand(int mousex, int mousey, int buttonHint, bool preview)
+Command CGuiHandler::GetCommand(int mousex, int mousey, int buttonHint, bool preview, float3&amp; camerapos, float3&amp; mousedir)
 {
+	GML_RECMUTEX_LOCK(gui); // GetCommand - updates inCommand
 	Command defaultRet;
 	defaultRet.id=CMD_STOP;
 
@@ -2138,7 +2164,7 @@
 		if (mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed) {
 			tempInCommand = defaultCmdMemory;
 		} else {
-			tempInCommand = GetDefaultCommand(mousex, mousey);
+			tempInCommand = GetDefaultCommand(mousex, mousey, camerapos, mousedir);
 		}
 	}
 
@@ -2162,11 +2188,11 @@
 			return c;}
 
 		case CMDTYPE_ICON_MAP:{
-			float dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+			float dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 			if(dist&lt;0){
 				return defaultRet;
 			}
-			float3 pos=camera-&gt;pos+mouse-&gt;dir*dist;
+			float3 pos=camerapos+mousedir*dist;
 			Command c;
 			c.id=commands[tempInCommand].id;
 			c.params.push_back(pos.x);
@@ -2176,7 +2202,7 @@
 			return c;}
 
 		case CMDTYPE_ICON_BUILDING:{
-			float dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+			float dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 			if(dist&lt;0){
 				return defaultRet;
 			}
@@ -2186,15 +2212,15 @@
 				return defaultRet;
 			}
 
-			float3 pos=camera-&gt;pos+mouse-&gt;dir*dist;
+			float3 pos=camerapos+mousedir*dist;
 			std::vector&lt;BuildInfo&gt; buildPos;
 			BuildInfo bi(unitdef, pos, buildFacing);
 			if(GetQueueKeystate() &amp;&amp; button==SDL_BUTTON_LEFT){
 				float dist=ground-&gt;LineGroundCol(mouse-&gt;buttons[SDL_BUTTON_LEFT].camPos,mouse-&gt;buttons[SDL_BUTTON_LEFT].camPos+mouse-&gt;buttons[SDL_BUTTON_LEFT].dir*gu-&gt;viewRange*1.4f);
 				float3 pos2=mouse-&gt;buttons[SDL_BUTTON_LEFT].camPos+mouse-&gt;buttons[SDL_BUTTON_LEFT].dir*dist;
-				buildPos=GetBuildPos(BuildInfo(unitdef,pos2,buildFacing),bi);
+				buildPos=GetBuildPos(BuildInfo(unitdef,pos2,buildFacing),bi,camerapos,mousedir);
 			} else
-				buildPos=GetBuildPos(bi,bi);
+				buildPos=GetBuildPos(bi,bi,camerapos,mousedir);
 
 			if(buildPos.empty()){
 				return defaultRet;
@@ -2219,7 +2245,7 @@
 			Command c;
 
 			c.id=commands[tempInCommand].id;
-			helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
+			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 			if (!unit){
 				return defaultRet;
 			}
@@ -2233,7 +2259,7 @@
 			c.id=commands[tempInCommand].id;
 
 			CUnit* unit=0;
-			float dist2=helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
+			float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 			if(dist2&gt;gu-&gt;viewRange*1.4f-300){
 				return defaultRet;
 			}
@@ -2241,7 +2267,7 @@
 			if (unit!=0) {  // clicked on unit
 				c.params.push_back(unit-&gt;id);
 			} else { // clicked in map
-				float3 pos=camera-&gt;pos+mouse-&gt;dir*dist2;
+				float3 pos=camerapos+mousedir*dist2;
 				c.params.push_back(pos.x);
 				c.params.push_back(pos.y);
 				c.params.push_back(pos.z);
@@ -2265,11 +2291,11 @@
 			c.params.push_back(pos.z);
 
 			if(mouse-&gt;buttons[button].movement&gt;30){		//only create the front if the mouse has moved enough
-				dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+				dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 				if(dist&lt;0){
 					return defaultRet;
 				}
-				float3 pos2 = camera-&gt;pos + mouse-&gt;dir * dist;
+				float3 pos2 = camerapos + mousedir * dist;
 
 				ProcessFrontPositions(pos, pos2);
 
@@ -2304,8 +2330,8 @@
 			if(mouse-&gt;buttons[button].movement&lt;4){
 				CUnit* unit=0;
 				CFeature* feature=0;
-				float dist2=helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
-				float dist3=helper-&gt;GuiTraceRayFeature(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,feature);
+				float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
+				float dist3=helper-&gt;GuiTraceRayFeature(camerapos,mousedir,gu-&gt;viewRange*1.4f,feature);
 
 				if(dist2&gt;gu-&gt;viewRange*1.4f-300 &amp;&amp; (commands[tempInCommand].type!=CMDTYPE_ICON_UNIT_FEATURE_OR_AREA || dist3&gt;gu-&gt;viewRange*1.4f-300)){
 					return defaultRet;
@@ -2316,7 +2342,7 @@
 				} else if (unit!=0 &amp;&amp; commands[tempInCommand].type!=CMDTYPE_ICON_AREA) {  // clicked on unit
 					c.params.push_back(unit-&gt;id);
 				} else { // clicked in map
-					float3 pos=camera-&gt;pos+mouse-&gt;dir*dist2;
+					float3 pos=camerapos+mousedir*dist2;
 					c.params.push_back(pos.x);
 					c.params.push_back(pos.y);
 					c.params.push_back(pos.z);
@@ -2331,11 +2357,11 @@
 				c.params.push_back(pos.x);
 				c.params.push_back(pos.y);
 				c.params.push_back(pos.z);
-				dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+				dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 				if(dist&lt;0){
 					return defaultRet;
 				}
-				float3 pos2=camera-&gt;pos+mouse-&gt;dir*dist;
+				float3 pos2=camerapos+mousedir*dist;
 				c.params.push_back(std::min(maxRadius,pos.distance2D(pos2)));
 			}
 			CreateOptions(c,(button==SDL_BUTTON_LEFT?0:1));
@@ -2349,7 +2375,7 @@
 				CUnit* unit=0;
 
 				float dist2=helper-&gt;GuiTraceRay(
-					camera-&gt;pos, mouse-&gt;dir, gu-&gt;viewRange*1.4f, unit, 20, true);
+					camerapos, mousedir, gu-&gt;viewRange*1.4f, unit, 20, true);
 
 				if(dist2&gt;gu-&gt;viewRange*1.4f-300) {
 					return defaultRet;
@@ -2359,7 +2385,7 @@
 				  // clicked on unit
 					c.params.push_back(unit-&gt;id);
 				} else { // clicked in map
-					float3 pos = camera-&gt;pos + (mouse-&gt;dir * dist2);
+					float3 pos = camerapos + (mousedir * dist2);
 					c.params.push_back(pos.x);
 					c.params.push_back(pos.y);
 					c.params.push_back(pos.z);
@@ -2372,11 +2398,11 @@
 					return defaultRet;
 				}
 				float3 startPos = mouse-&gt;buttons[button].camPos + mouse-&gt;buttons[button].dir * dist;
-				dist = ground-&gt;LineGroundCol(camera-&gt;pos, camera-&gt;pos + mouse-&gt;dir*gu-&gt;viewRange * 1.4f);
+				dist = ground-&gt;LineGroundCol(camerapos, camerapos + mousedir*gu-&gt;viewRange * 1.4f);
 				if(dist&lt;0){
 					return defaultRet;
 				}
-				float3 endPos=camera-&gt;pos+mouse-&gt;dir*dist;
+				float3 endPos=camerapos+mousedir*dist;
 				c.params.push_back(startPos.x);
 				c.params.push_back(startPos.y);
 				c.params.push_back(startPos.z);
@@ -2402,6 +2428,7 @@
 static bool WouldCancelAnyQueued(const BuildInfo&amp; b) {
 	Command c;
 	b.FillCmd(c);
+	GML_RECMUTEX_LOCK(sel); //drawmapstuff -&gt; getbuildpos --&gt; fillrowofbuildpos -&gt; wouldcancelanyqueued
 	CUnitSet::iterator ui = selectedUnits.selectedUnits.begin();
 	for(;ui != selectedUnits.selectedUnits.end(); ++ui){
 		if((*ui)-&gt;commandAI-&gt;WillCancelQueued(c))
@@ -2424,7 +2451,7 @@
 }
 
 // Assuming both builds have the same unitdef
-std::vector&lt;BuildInfo&gt; CGuiHandler::GetBuildPos(const BuildInfo&amp; startInfo, const BuildInfo&amp; endInfo)
+std::vector&lt;BuildInfo&gt; CGuiHandler::GetBuildPos(const BuildInfo&amp; startInfo, const BuildInfo&amp; endInfo, float3&amp; camerapos, float3&amp; mousedir)
 {
 	std::vector&lt;BuildInfo&gt; ret;
 
@@ -2435,13 +2462,14 @@
 	if(GetQueueKeystate() &amp;&amp; keys[SDLK_LCTRL])
 	{
 		CUnit* unit=0;
-		helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,true);
+		GML_RECMUTEX_LOCK(unit); // GetBuildCommand accesses activeunits. drawmapstuff -&gt; getbuildpos
+		helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
 		if(unit){
 			other.def = unit-&gt;unitDef;
 			other.pos = unit-&gt;pos;
 			other.buildFacing = unit-&gt;buildFacing;
 		} else {
-			Command c = uh-&gt;GetBuildCommand(camera-&gt;pos,mouse-&gt;dir);
+			Command c = uh-&gt;GetBuildCommand(camerapos,mousedir);
 			if(c.id &lt; 0){
 				assert(c.params.size()==4);
 				other.pos = float3(c.params[0],c.params[1],c.params[2]);
@@ -2534,6 +2562,9 @@
 
 void CGuiHandler::Draw()
 {
+	GML_RECMUTEX_LOCK(gui); // accesses iconsCount. Draw
+//	GML_RECMUTEX_LOCK(quad); // update accesses setcursoricon-&gt;getdefaultcommand-&gt;guitraceray which accesses the quadfield
+
 	Update();
 
 	if ((iconsCount &lt;= 0) &amp;&amp; (luaUI == NULL)) {
@@ -2960,7 +2991,7 @@
 }
 
 
-void CGuiHandler::DrawButtons()
+void CGuiHandler::DrawButtons() // Only called by Draw
 {
 	glLineWidth(1.0f);
 	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
@@ -3128,7 +3159,7 @@
 }
 
 
-void CGuiHandler::DrawMenuName()
+void CGuiHandler::DrawMenuName() // Only called by drawbuttons
 {
 	if (!menuName.empty() &amp;&amp; (iconsCount &gt; 0)) {
 		const char* text = menuName.c_str();
@@ -3161,6 +3192,8 @@
 
 void CGuiHandler::DrawSelectionInfo()
 {
+	GML_RECMUTEX_LOCK(sel); // Draw --&gt; DrawButtons --&gt; DrawSelectionInfo
+
 	if (!selectedUnits.selectedUnits.empty()) {
 		char buf[64];
 
@@ -3197,8 +3230,9 @@
 }
 
 
-void CGuiHandler::DrawNumberInput()
+void CGuiHandler::DrawNumberInput() // Only called by drawbuttons
 {
+	GML_RECMUTEX_LOCK(gui); // DrawNumberInput
 	// draw the value for CMDTYPE_NUMBER commands
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		const CommandDescription&amp; cd = commands[inCommand];
@@ -3422,6 +3456,8 @@
 
 void CGuiHandler::DrawMapStuff(int onMinimap)
 {
+	GML_RECMUTEX_LOCK(gui); // DrawMapStuff
+
 	if (!onMinimap) {
 		glEnable(GL_DEPTH_TEST);
 		glDepthMask(GL_FALSE);
@@ -3431,23 +3467,29 @@
 		glDisable(GL_ALPHA_TEST);
 	}
 
+	float3 camerapos=camera-&gt;pos; 
+	//CCamera tmpcam(*camera);
+	//	CCamera *camera=&tmpcam;
+	float3 mousedir=mouse-&gt;dir;
+
 	// setup for minimap proxying
-	float3 tmpCamPos, tmpMouseDir;
+//	float3 tmpCamPos, tmpMouseDir;
 	const bool minimapCoords =
 		(minimap-&gt;ProxyMode() ||
 		 ((activeReceiver != this) &amp;&amp; !game-&gt;hideInterface &amp;&amp;
 		  (GetReceiverAt(mouse-&gt;lastx, mouse-&gt;lasty) == minimap)));
 	if (minimapCoords) {
-		tmpCamPos = camera-&gt;pos;
-		tmpMouseDir = mouse-&gt;dir;
-		camera-&gt;pos = minimap-&gt;GetMapPosition(mouse-&gt;lastx, mouse-&gt;lasty);
-		mouse-&gt;dir = float3(0.0f, -1.0f, 0.0f);
+//		tmpCamPos = camera-&gt;pos;
+//		tmpMouseDir = mouse-&gt;dir;
+		camerapos = minimap-&gt;GetMapPosition(mouse-&gt;lastx, mouse-&gt;lasty);
+		mousedir = float3(0.0f, -1.0f, 0.0f);
 		if (miniMapMarker &amp;&amp; minimap-&gt;FullProxy() &amp;&amp;
 		    !onMinimap &amp;&amp; !minimap-&gt;GetMinimized()) {
-			DrawMiniMapMarker();
+			DrawMiniMapMarker(camerapos);
 		}
 	}
 
+
 	if (activeMousePress) {
 		int cmdIndex = -1;
 		int button = SDL_BUTTON_LEFT;
@@ -3474,7 +3516,7 @@
 						if (cmdDesc.params.size() &gt; 1) {
 							sizeDiv = atof(cmdDesc.params[1].c_str());
 						}
-						DrawFront(button, maxSize, sizeDiv, !!onMinimap);
+						DrawFront(button, maxSize, sizeDiv, !!onMinimap, camerapos, mousedir);
 					}
 					break;
 				}
@@ -3491,11 +3533,11 @@
 							break;
 						}
 						float3 pos=mouse-&gt;buttons[button].camPos+mouse-&gt;buttons[button].dir*dist;
-						dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+						dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 						if (dist &lt; 0) {
 							break;
 						}
-						float3 pos2 = camera-&gt;pos + mouse-&gt;dir * dist;
+						float3 pos2 = camerapos + mousedir * dist;
 						const float* color;
 						switch (cmdDesc.id) {
 							case CMD_ATTACK:
@@ -3543,13 +3585,13 @@
 							break;
 						}
 						const float3 pos1 = mouse-&gt;buttons[button].camPos+mouse-&gt;buttons[button].dir*dist;
-						dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+						dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 						if (dist &lt; 0) {
 							break;
 						}
-						const float3 pos2 = camera-&gt;pos+mouse-&gt;dir*dist;
+						const float3 pos2 = camerapos+mousedir*dist;
 						if (!onMinimap) {
-							DrawSelectBox(pos1, pos2);
+							DrawSelectBox(pos1, pos2, camerapos);
 						} else {
 							glColor4f(1.0f, 0.0f, 0.0f, 0.5f);
 							glBegin(GL_QUADS);
@@ -3576,16 +3618,15 @@
 
 	// draw the ranges for the unit that is being pointed at
 	CUnit* pointedAt = NULL;
+	GML_RECMUTEX_LOCK(unit); // DrawMapStuff
 	if (GetQueueKeystate()) {
 		CUnit* unit = NULL;
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::recursive_mutex::scoped_lock quadlock(quadmutex); // getselectunit, guitraceray accesses quadfield
-#endif
+//		GML_RECMUTEX_LOCK(quad);  // getselectunit, guitraceray accesses quadfield
 		if (minimapCoords) {
-			unit = minimap-&gt;GetSelectUnit(camera-&gt;pos);
+			unit = minimap-&gt;GetSelectUnit(camerapos);
 		} else {
 			// ignoring the returned distance
-			helper-&gt;GuiTraceRay(camera-&gt;pos,mouse-&gt;dir,gu-&gt;viewRange*1.4f,unit,20,false);
+			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,false);
 		}
 		if (unit &amp;&amp; ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) || gu-&gt;spectatingFullView)) {
 			pointedAt = unit;
@@ -3675,9 +3716,7 @@
 	// draw buildings we are about to build
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size()) &amp;&amp;
 	    (commands[inCommand].type == CMDTYPE_ICON_BUILDING)) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::mutex::scoped_lock cailock(caimutex);
-#endif
+		GML_STDMUTEX_LOCK(cai); // DrawMapStuff
 		// draw build distance for all immobile builders during build commands
 		std::list&lt;CBuilderCAI*&gt;::const_iterator bi;
 		for (bi = uh-&gt;builderCAIs.begin(); bi != uh-&gt;builderCAIs.end(); ++bi) {
@@ -3697,25 +3736,23 @@
 			}
 		}
 
-		float dist = ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+		float dist = ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 		if (dist &gt; 0) {
 			const UnitDef* unitdef = unitDefHandler-&gt;GetUnitByID(-commands[inCommand].id);
 			if (unitdef) {
 				// get the build information
-				float3 pos = camera-&gt;pos+mouse-&gt;dir*dist;
+				float3 pos = camerapos+mousedir*dist;
 				std::vector&lt;BuildInfo&gt; buildPos;
 				const CMouseHandler::ButtonPress&amp; bp = mouse-&gt;buttons[SDL_BUTTON_LEFT];
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-			boost::recursive_mutex::scoped_lock quadlock(quadmutex); // getbuildpos accesses quadfield
-#endif
+//			GML_RECMUTEX_LOCK(quad);  // getbuildpos accesses quadfield
 				if (GetQueueKeystate() &amp;&amp; bp.pressed) {
 					const float dist = ground-&gt;LineGroundCol(bp.camPos, bp.camPos + bp.dir * gu-&gt;viewRange * 1.4f);
 					const float3 pos2 = bp.camPos + bp.dir * dist;
 					buildPos = GetBuildPos(BuildInfo(unitdef, pos2, buildFacing),
-					                       BuildInfo(unitdef, pos, buildFacing));
+					                       BuildInfo(unitdef, pos, buildFacing), camerapos, mousedir);
 				} else {
 					BuildInfo bi(unitdef, pos, buildFacing);
-					buildPos = GetBuildPos(bi, bi);
+					buildPos = GetBuildPos(bi, bi, camerapos, mousedir);
 				}
 
 				for (std::vector&lt;BuildInfo&gt;::iterator bpi = buildPos.begin(); bpi != buildPos.end(); ++bpi) {
@@ -3767,9 +3804,7 @@
 
 					std::vector&lt;Command&gt; cv;
 					if (GetQueueKeystate()) {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-						boost::mutex::scoped_lock sellock(selmutex);
-#endif
+						GML_RECMUTEX_LOCK(sel); // DrawMapStuff
 						Command c;
 						bpi-&gt;FillCmd(c);
 						std::vector&lt;Command&gt; temp;
@@ -3799,13 +3834,12 @@
 		}
 	}
 
+//	GML_RECMUTEX_LOCK(quad); // getdefaultcommand calls guitraceray which accesses quadfield
 	// draw range circles if attack orders are imminent
-	int defcmd = GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty);
+	int defcmd = GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty, camerapos, mousedir);
 	if ((inCommand&gt;=0 &amp;&amp; inCommand&lt;commands.size() &amp;&amp; commands[inCommand].id==CMD_ATTACK) ||
 	    (inCommand==-1 &amp;&amp; defcmd&gt;0 &amp;&amp; commands[defcmd].id==CMD_ATTACK)){
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::mutex::scoped_lock sellock(selmutex);
-#endif
+		GML_RECMUTEX_LOCK(sel); // DrawMapStuff
 		for(CUnitSet::iterator si=selectedUnits.selectedUnits.begin(); si!=selectedUnits.selectedUnits.end(); ++si) {
 			CUnit* unit = *si;
 			if (unit == pointedAt) {
@@ -3827,14 +3861,14 @@
 
 	glLineWidth(1.0f);
 
-	if (minimapCoords) {
+/*	if (minimapCoords) {
 		camera-&gt;pos = tmpCamPos;
 		mouse-&gt;dir = tmpMouseDir;
-	}
+	}*/
 }
 
 
-void CGuiHandler::DrawMiniMapMarker()
+void CGuiHandler::DrawMiniMapMarker(float3&amp; camerapos)
 {
 	const float w = 10.0f;
 	const float h = 30.0f;
@@ -3852,13 +3886,13 @@
 		{ bc[0] * d[7],  bc[1] * d[7],  bc[2] * d[7],  bc[3] },
 	};
 
-	const float groundLevel = ground-&gt;GetHeight(camera-&gt;pos.x, camera-&gt;pos.z);
+	const float groundLevel = ground-&gt;GetHeight(camerapos.x, camerapos.z);
 
 	static float spinTime = 0.0f;
 	spinTime = fmod(spinTime + gu-&gt;lastFrameTime, 60.0f);
 
 	glPushMatrix();
-	glTranslatef(camera-&gt;pos.x, groundLevel, camera-&gt;pos.z);
+	glTranslatef(camerapos.x, groundLevel, camerapos.z);
 	glRotatef(360.0f * (spinTime / 2.0f), 0.0f, 1.0f, 0.0f);
 
 	glEnable(GL_BLEND);
@@ -3888,11 +3922,13 @@
 
 void CGuiHandler::DrawCentroidCursor()
 {
+	GML_RECMUTEX_LOCK(sel); // CMouseHandler::DrawCursor --&gt; DrawCentroidCursor
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 	if (selUnits.size() &lt; 2) {
 		return;
 	}
 
+	GML_RECMUTEX_LOCK(gui); // DrawCentroidCursor
 	int cmd = -1;
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		cmd = commands[inCommand].id;
@@ -3971,7 +4007,7 @@
 }
 
 
-void CGuiHandler::DrawFront(int button,float maxSize,float sizeDiv, bool onMinimap)
+void CGuiHandler::DrawFront(int button,float maxSize,float sizeDiv, bool onMinimap, float3&amp; camerapos, float3&amp; mousedir)
 {
 	CMouseHandler::ButtonPress&amp; bp = mouse-&gt;buttons[button];
 	if(bp.movement&lt;5){
@@ -3982,11 +4018,11 @@
 		return;
 	}
 	float3 pos1=bp.camPos+bp.dir*dist;
-	dist=ground-&gt;LineGroundCol(camera-&gt;pos,camera-&gt;pos+mouse-&gt;dir*gu-&gt;viewRange*1.4f);
+	dist=ground-&gt;LineGroundCol(camerapos,camerapos+mousedir*gu-&gt;viewRange*1.4f);
 	if(dist&lt;0){
 		return;
 	}
-	float3 pos2 = camera-&gt;pos + (mouse-&gt;dir * dist);
+	float3 pos2 = camerapos + (mousedir * dist);
 
 	ProcessFrontPositions(pos1, pos2);
 
@@ -4188,7 +4224,7 @@
 }
 
 
-void CGuiHandler::DrawSelectBox(const float3&amp; pos0, const float3&amp; pos1)
+void CGuiHandler::DrawSelectBox(const float3&amp; pos0, const float3&amp; pos1, float3&amp; camerapos)
 {
 	if (useStencil) {
 		StencilDrawSelectBox(pos0, pos1, invColorSelect);
@@ -4217,9 +4253,9 @@
 	glDisable(GL_CULL_FACE);
 
 	// do a full screen inversion if the camera is within the box
-	if ((camera-&gt;pos.x &gt; mins.x) &amp;&amp; (camera-&gt;pos.x &lt; maxs.x) &amp;&amp;
-	    (camera-&gt;pos.y &gt; mins.y) &amp;&amp; (camera-&gt;pos.y &lt; maxs.y) &amp;&amp;
-	    (camera-&gt;pos.z &gt; mins.z) &amp;&amp; (camera-&gt;pos.z &lt; maxs.z)) {
+	if ((camerapos.x &gt; mins.x) &amp;&amp; (camerapos.x &lt; maxs.x) &amp;&amp;
+	    (camerapos.y &gt; mins.y) &amp;&amp; (camerapos.y &lt; maxs.y) &amp;&amp;
+	    (camerapos.z &gt; mins.z) &amp;&amp; (camerapos.z &lt; maxs.z)) {
 		glDisable(GL_DEPTH_TEST);
 		FullScreenDraw();
 		glEnable(GL_DEPTH_TEST);

Modified: branches/caiinterface/rts/Game/UI/GuiHandler.h
===================================================================
--- branches/caiinterface/rts/Game/UI/GuiHandler.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/UI/GuiHandler.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -11,6 +11,8 @@
 #include &quot;KeySet.h&quot;
 #include &quot;KeyBindings.h&quot;
 #include &quot;InputReceiver.h&quot;
+#include &quot;Game/Camera.h&quot;
+#include &quot;Game/UI/MouseHandler.h&quot;
 
 class CUnit;
 class CglList;
@@ -32,15 +34,16 @@
 		bool KeyPressed(unsigned short key, bool isRepeat);
 		bool KeyReleased(unsigned short key);
 		bool MousePress(int x, int y, int button);
-		void MouseRelease(int x, int y, int button);
+		void MouseRelease(int x, int y, int button) {MouseRelease(x,y,button, ::camera-&gt;pos, ::mouse-&gt;dir);}
+		void MouseRelease(int x, int y, int button, float3&amp; camerapos, float3&amp; mousedir);
 		bool IsAbove(int x, int y);
 		std::string GetTooltip(int x, int y);
 		std::string GetBuildTooltip() const;
 
 		Command GetOrderPreview();
-		Command GetCommand(int mousex, int mousey, int buttonHint, bool preview);
+		Command GetCommand(int mousex, int mousey, int buttonHint, bool preview, float3&amp; camerapos=::camera-&gt;pos, float3&amp; mousedir=::mouse-&gt;dir);
 		std::vector&lt;BuildInfo&gt; GetBuildPos(const BuildInfo&amp; startInfo,
-		                                   const BuildInfo&amp; endInfo);
+			const BuildInfo&amp; endInfo, float3&amp; camerapos, float3&amp; mousedir);
 		                                   // start.def has to be end.def
 
 		bool ReloadConfig(const std::string&amp; filename);
@@ -62,7 +65,7 @@
 
 		bool GetOutlineFonts() const { return outlineFonts; }
 
-		int  GetDefaultCommand(int x, int y) const;
+		int  GetDefaultCommand(int x, int y, float3&amp; camerapos=::camera-&gt;pos, float3&amp; mousedir=::mouse-&gt;dir) const;
 
 		bool SetActiveCommand(int cmdIndex, bool rmb);
 		bool SetActiveCommand(int cmdIndex,
@@ -122,10 +125,10 @@
 		void DrawMenuName();
 		void DrawSelectionInfo();
 		void DrawNumberInput();
-		void DrawMiniMapMarker();
-		void DrawFront(int button, float maxSize, float sizeDiv, bool onMinimap);
+		void DrawMiniMapMarker(float3&amp; camerapos);
+		void DrawFront(int button, float maxSize, float sizeDiv, bool onMinimap, float3&amp; camerapos, float3&amp; mousedir);
 		void DrawArea(float3 pos, float radius, const float* color);
-		void DrawSelectBox(const float3&amp; start, const float3&amp; end);
+		void DrawSelectBox(const float3&amp; start, const float3&amp; end, float3&amp; camerapos);
 		void DrawSelectCircle(const float3&amp; pos, float radius,
 		                      const float* color);
 

Modified: branches/caiinterface/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -60,17 +60,6 @@
 #include &quot;TimeProfiler.h&quot;
 #include &quot;TooltipConsole.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex unitmutex;
-extern boost::recursive_mutex quadmutex;
-extern boost::recursive_mutex projmutex;
-extern boost::mutex selmutex;
-#	endif
-#endif
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -845,10 +834,10 @@
 void CMiniMap::ProxyMouseRelease(int x, int y, int button)
 {
 	// is this really needed?
-	CCamera *c = camera;
-	camera = new CCamera(*c);
+//	CCamera *c = camera;
+//	camera = new CCamera(*c);
 
-	const float3 tmpMouseDir = mouse-&gt;dir;
+//	const float3 tmpMouseDir = mouse-&gt;dir; 
 
 	float3 mapPos = GetMapPosition(x, y);
 	const CUnit* unit = GetSelectUnit(mapPos);
@@ -861,15 +850,15 @@
 		}
 	}
 
-	mouse-&gt;dir = float3(0.0f, -1.0f, 0.0f);
-	camera-&gt;pos = mapPos;
-	camera-&gt;forward = mouse-&gt;dir;
+	float3 mousedir = float3(0.0f, -1.0f, 0.0f);
+	float3 campos = mapPos;
+//	float3 camfwd = mousedir; // not used?
 
-	guihandler-&gt;MouseRelease(x, y, -button);
+	guihandler-&gt;MouseRelease(x, y, -button, campos, mousedir);
 
-	mouse-&gt;dir = tmpMouseDir;
-	delete camera;
-	camera = c;
+//	mouse-&gt;dir = tmpMouseDir;
+//	delete camera;
+//	camera = c;
 }
 
 
@@ -924,6 +913,8 @@
 		return buildTip;
 	}
 
+	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
+
 	const CUnit* unit = GetSelectUnit(GetMapPosition(x, y));
 	if (unit) {
 		return CTooltipConsole::MakeUnitString(unit);
@@ -1050,17 +1041,13 @@
 	glEnable(GL_ALPHA_TEST);
 	glAlphaFunc(GL_GREATER, 0.0f);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // DrawForReal
 	// draw the units
 	std::list&lt;CUnit*&gt;::iterator ui;
 	for (ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ui++) {
 		DrawUnit(*ui);
 	}
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-		boost::recursive_mutex::scoped_lock quadlock(quadmutex); // getselectunit accesses quadfield
-#endif
+//	GML_RECMUTEX_LOCK(quad);  // getselectunit accesses quadfield
 	// highlight the selected unit
 	CUnit* unit = GetSelectUnit(GetMapPosition(mouse-&gt;lastx, mouse-&gt;lasty));
 	if (unit != NULL) {
@@ -1111,62 +1098,63 @@
 
 	glRotatef(-90.0f, +1.0f, 0.0f, 0.0f); // real 'world' coordinates
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+
 	// draw the projectiles
-	if (drawProjectiles &amp;&amp; ph-&gt;ps.size()&gt;0) {
-		CVertexArray* lines=GetVertexArray();
-		CVertexArray* points=GetVertexArray();
-		lines-&gt;Initialize();
-		lines-&gt;EnlargeArrays(ph-&gt;ps.size()*2,0,VA_SIZE_C);
-		points-&gt;Initialize();
-		points-&gt;EnlargeArrays(ph-&gt;ps.size(),0,VA_SIZE_C);
+	if (drawProjectiles) {
+		GML_RECMUTEX_LOCK(proj); // DrawForReal
+		if(ph-&gt;ps.size()&gt;0) {
+			CVertexArray* lines=GetVertexArray();
+			CVertexArray* points=GetVertexArray();
+			lines-&gt;Initialize();
+			lines-&gt;EnlargeArrays(ph-&gt;ps.size()*2,0,VA_SIZE_C);
+			points-&gt;Initialize();
+			points-&gt;EnlargeArrays(ph-&gt;ps.size(),0,VA_SIZE_C);
 
-		static unsigned char red[4]    = {255,0,0,255};
-		static unsigned char redA[4]   = {255,0,0,128};
-		static unsigned char yellow[4] = {255,255,0,255};
-		static unsigned char green[4]  = {0,255,0,25};
-		static unsigned char white[4]  = {255,255,255,25};
+			static unsigned char red[4]    = {255,0,0,255};
+			static unsigned char redA[4]   = {255,0,0,128};
+			static unsigned char yellow[4] = {255,255,0,255};
+			static unsigned char green[4]  = {0,255,0,25};
+			static unsigned char white[4]  = {255,255,255,25};
 
-		Projectile_List::iterator psi;
-		for(psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
-			CProjectile* p = *psi;
+			Projectile_List::iterator psi;
+			for(psi = ph-&gt;ps.begin(); psi != ph-&gt;ps.end(); ++psi) {
+				CProjectile* p = *psi;
 
-			if ((p-&gt;owner &amp;&amp; (p-&gt;owner-&gt;allyteam == gu-&gt;myAllyTeam)) ||
-				gu-&gt;spectatingFullView || loshandler-&gt;InLos(p, gu-&gt;myAllyTeam)) {
+				if ((p-&gt;owner &amp;&amp; (p-&gt;owner-&gt;allyteam == gu-&gt;myAllyTeam)) ||
+					gu-&gt;spectatingFullView || loshandler-&gt;InLos(p, gu-&gt;myAllyTeam)) {
 
-				if (dynamic_cast&lt;CGeoThermSmokeProjectile*&gt;(p)) {
-				} else if (dynamic_cast&lt;CGfxProjectile*&gt;(p)) {//Nano-piece
-					points-&gt;AddVertexQC(p-&gt;pos,green);
-				} else if (dynamic_cast&lt;CBeamLaserProjectile*&gt;(p)) {
-					CBeamLaserProjectile&amp; beam = *(CBeamLaserProjectile*)p;
-					unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
-					lines-&gt;AddVertexQC(beam.startPos,color);
-					lines-&gt;AddVertexQC(beam.endPos,color);
-				} else if (dynamic_cast&lt;CLargeBeamLaserProjectile*&gt;(p)) {
-					CLargeBeamLaserProjectile&amp; beam = *(CLargeBeamLaserProjectile*)p;
-					unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
-					lines-&gt;AddVertexQC(beam.startPos,color);
-					lines-&gt;AddVertexQC(beam.endPos,color);
-				} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
-					CLightingProjectile&amp; beam = *(CLightingProjectile*)p;
-					unsigned char color[4] = {(unsigned char)beam.color[0]*255,(unsigned char)beam.color[1]*255,(unsigned char)beam.color[2]*255,255};
-					lines-&gt;AddVertexQC(beam.pos,color);
-					lines-&gt;AddVertexQC(beam.endPos,color);
-				} else if (dynamic_cast&lt;CPieceProjectile*&gt;(p)) {
-					points-&gt;AddVertexQC(p-&gt;pos,red);
-				} else if (dynamic_cast&lt;CWreckProjectile*&gt;(p)) {
-					points-&gt;AddVertexQC(p-&gt;pos,redA);
-				} else if (dynamic_cast&lt;CWeaponProjectile*&gt;(p)) {
-					points-&gt;AddVertexQC(p-&gt;pos,yellow);
-				} else {
-					points-&gt;AddVertexQC(p-&gt;pos,white);
+						if (dynamic_cast&lt;CGeoThermSmokeProjectile*&gt;(p)) {
+						} else if (dynamic_cast&lt;CGfxProjectile*&gt;(p)) {//Nano-piece
+							points-&gt;AddVertexQC(p-&gt;pos,green);
+						} else if (dynamic_cast&lt;CBeamLaserProjectile*&gt;(p)) {
+							CBeamLaserProjectile&amp; beam = *(CBeamLaserProjectile*)p;
+							unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
+							lines-&gt;AddVertexQC(beam.startPos,color);
+							lines-&gt;AddVertexQC(beam.endPos,color);
+						} else if (dynamic_cast&lt;CLargeBeamLaserProjectile*&gt;(p)) {
+							CLargeBeamLaserProjectile&amp; beam = *(CLargeBeamLaserProjectile*)p;
+							unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
+							lines-&gt;AddVertexQC(beam.startPos,color);
+							lines-&gt;AddVertexQC(beam.endPos,color);
+						} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
+							CLightingProjectile&amp; beam = *(CLightingProjectile*)p;
+							unsigned char color[4] = {(unsigned char)beam.color[0]*255,(unsigned char)beam.color[1]*255,(unsigned char)beam.color[2]*255,255};
+							lines-&gt;AddVertexQC(beam.pos,color);
+							lines-&gt;AddVertexQC(beam.endPos,color);
+						} else if (dynamic_cast&lt;CPieceProjectile*&gt;(p)) {
+							points-&gt;AddVertexQC(p-&gt;pos,red);
+						} else if (dynamic_cast&lt;CWreckProjectile*&gt;(p)) {
+							points-&gt;AddVertexQC(p-&gt;pos,redA);
+						} else if (dynamic_cast&lt;CWeaponProjectile*&gt;(p)) {
+							points-&gt;AddVertexQC(p-&gt;pos,yellow);
+						} else {
+							points-&gt;AddVertexQC(p-&gt;pos,white);
+						}
 				}
 			}
+			lines-&gt;DrawArrayC(GL_LINES);
+			points-&gt;DrawArrayC(GL_POINTS);
 		}
-		lines-&gt;DrawArrayC(GL_LINES);
-		points-&gt;DrawArrayC(GL_POINTS);
 	}
 
 	// draw the queued commands
@@ -1186,9 +1174,7 @@
 		guihandler-&gt;DrawMapStuff(!!drawCommands);
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock sellock(selmutex);
-#endif
+	GML_RECMUTEX_LOCK(sel); // DrawForReal
 	// draw unit ranges
 	const float radarSquare = (SQUARE_SIZE * RADAR_SIZE);
 	CUnitSet&amp; selUnits = selectedUnits.selectedUnits;

Modified: branches/caiinterface/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -591,10 +591,13 @@
 		return buildTip;
 	}
 
+	GML_RECMUTEX_LOCK(quad); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
 	const float range = (gu-&gt;viewRange * 1.4f);
 	CUnit* unit = NULL;
+//	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
+	float udist = helper-&gt;GuiTraceRay(camera-&gt;pos, dir, range, unit, 20, true);
 	CFeature* feature = NULL;
-	float udist = helper-&gt;GuiTraceRay(camera-&gt;pos, dir, range, unit, 20, true);
+//	GML_RECMUTEX_LOCK(feat); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
 	float fdist = helper-&gt;GuiTraceRayFeature(camera-&gt;pos, dir, range, feature);
 
 	if ((udist &gt; (range - 300.0f)) &amp;&amp;

Modified: branches/caiinterface/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/TooltipConsole.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Game/UI/TooltipConsole.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -22,7 +22,6 @@
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/Util.h&quot;
 
-
 CTooltipConsole* tooltip = 0;
 
 
@@ -69,6 +68,8 @@
 		return;
 	}
 
+//	GML_RECMUTEX_LOCK(quad); // getcurrenttooltip accesses guitraceray which accesses quadfield
+
 	const std::string s = mouse-&gt;GetCurrentTooltip();
 
 	glDisable(GL_TEXTURE_2D);

Modified: branches/caiinterface/rts/Lua/LuaCallInCheck.h
===================================================================
--- branches/caiinterface/rts/Lua/LuaCallInCheck.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Lua/LuaCallInCheck.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -26,14 +26,16 @@
 #  define LUA_CALL_IN_CHECK(L)
 #endif
 
-#ifdef USE_GML
-#include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex luamutex;
-#undef LUA_CALL_IN_CHECK
-#define LUA_CALL_IN_CHECK(L) boost::recursive_mutex::scoped_lock lualock(luamutex);
+#ifdef USE_GML // hack to add some degree of thread safety to LUA
+#	include &quot;Rendering/GL/myGL.h&quot;
+#	include &quot;lib/gml/gmlsrv.h&quot;
+#	if GML_ENABLE_SIMDRAW
+#		undef LUA_CALL_IN_CHECK
+#		if DEBUG_LUA
+#			define LUA_CALL_IN_CHECK(L) GML_RECMUTEX_LOCK(lua); LuaCallInCheck ciCheck((L), __FUNCTION__);
+#		else
+#			define LUA_CALL_IN_CHECK(L) GML_RECMUTEX_LOCK(lua);
+#		endif
 #	endif
 #endif
 

Modified: branches/caiinterface/rts/Lua/LuaHandle.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaHandle.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Lua/LuaHandle.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -169,7 +169,7 @@
 
 void CLuaHandle::CheckStack()
 {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW // Add mutex to avoid bogus errors due to concurrency
 	LUA_CALL_IN_CHECK(L);
 #endif
 	const int top = lua_gettop(L);

Modified: branches/caiinterface/rts/Lua/LuaOpenGL.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaOpenGL.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Lua/LuaOpenGL.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1968,10 +1968,11 @@
 	}
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	if (unit-&gt;transporter == NULL) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		pos += (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		pos += (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	const float3 scale(luaL_optnumber(L, 4, 1.0f),
@@ -2016,10 +2017,11 @@
 	}
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	if (unit-&gt;transporter == NULL) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		pos += (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		pos += (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	const int args = lua_gettop(L); // number of arguments

Modified: branches/caiinterface/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnitDefs.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Lua/LuaUnitDefs.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -817,6 +817,7 @@
 	ADD_FLOAT(&quot;wantedHeight&quot;, ud.wantedHeight);
 	ADD_BOOL(&quot;hoverAttack&quot;,   ud.hoverAttack);
 	ADD_BOOL(&quot;airStrafe&quot;,     ud.airStrafe);
+	ADD_BOOL(&quot;bankingAllowed&quot;,ud.bankingAllowed);
 
 	// &lt; 0 means it can land,
 	// &gt;= 0 indicates how much the unit will move during hovering on the spot

Modified: branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -333,6 +333,7 @@
 
 	glLineWidth(cmdColors.QueuedLineWidth());
 
+	GML_STDMUTEX_LOCK(cai);
 	const CUnitSet&amp; units = drawCmdQueueUnits;
 	CUnitSet::const_iterator ui;
 	for (ui = units.begin(); ui != units.end(); ++ui) {

Modified: branches/caiinterface/rts/Lua/LuaUtils.h
===================================================================
--- branches/caiinterface/rts/Lua/LuaUtils.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Lua/LuaUtils.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -14,6 +14,11 @@
 #include &quot;LuaDefs.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 
+// is defined as macro on FreeBSD (wtf)
+#ifdef isnumber
+	#undef isnumber
+#endif
+
 class LuaUtils {
 	public:
 		static int CopyData(lua_State* dst, lua_State* src, int count);

Modified: branches/caiinterface/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/BaseGroundDrawer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/BaseGroundDrawer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -21,15 +21,6 @@
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/FastMath.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex featmutex;
-extern boost::mutex selmutex;
-#	endif
-#endif
-
 CBaseGroundDrawer::CBaseGroundDrawer(void)
 {
 	updateFov = true;
@@ -244,6 +235,7 @@
 
 		switch(drawMode) {
 			case drawPath: {
+				GML_RECMUTEX_LOCK(gui); // UpdateExtraTexture
 				if (guihandler-&gt;inCommand &gt; 0 &amp;&amp; guihandler-&gt;inCommand &lt; guihandler-&gt;commands.size() &amp;&amp;
 						guihandler-&gt;commands[guihandler-&gt;inCommand].type == CMDTYPE_ICON_BUILDING) {
 					// use the current build order
@@ -255,9 +247,7 @@
 							} else {
 								const UnitDef* unitdef = unitDefHandler-&gt;GetUnitByID(-guihandler-&gt;commands[guihandler-&gt;inCommand].id);
 								CFeature* f;
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-								boost::recursive_mutex::scoped_lock featlock(featmutex); // testunitbuildsquare accesses features in the quadfield
-#endif
+								GML_RECMUTEX_LOCK(quad); //feat); // UpdateExtraTexture: testunitbuildsquare accesses features in the quadfield
 								if(uh-&gt;TestUnitBuildSquare(BuildInfo(unitdef, float3(x*16+8, 0, y*16+8), guihandler-&gt;buildFacing), f, gu-&gt;myAllyTeam)) {
 									if (f) {
 										m = 0.5f;
@@ -277,9 +267,7 @@
 				}
 				else {
 					// use the first selected unit
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-					boost::mutex::scoped_lock sellock(selmutex);
-#endif
+					GML_RECMUTEX_LOCK(sel); // UpdateExtraTexture
 					if (selectedUnits.selectedUnits.empty()) {
 						return true;
 					}

Modified: branches/caiinterface/rts/Map/ReadMap.cpp
===================================================================
--- branches/caiinterface/rts/Map/ReadMap.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/ReadMap.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -241,6 +241,17 @@
 	}
 }
 
+void CReadMap::UpdateDraw() {
+	GML_STDMUTEX_LOCK(map); // UpdateDraw
+	for(std::vector&lt;HeightmapUpdate&gt;::iterator i=heightmapUpdates.begin(); i!=heightmapUpdates.end(); ++i)
+		HeightmapUpdatedNow((*i).x1,(*i).x2,(*i).y1,(*i).y2);
+	heightmapUpdates.clear();
+}
 
+void CReadMap::HeightmapUpdated(int x1, int x2, int y1, int y2) {
+	GML_STDMUTEX_LOCK(map); // HeightmapUpdated
+	heightmapUpdates.push_back(HeightmapUpdate(x1,x2,y1,y2));
+}
+
 CReadMap::IQuadDrawer::~IQuadDrawer() {
 }

Modified: branches/caiinterface/rts/Map/ReadMap.h
===================================================================
--- branches/caiinterface/rts/Map/ReadMap.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/ReadMap.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -36,6 +36,13 @@
 	int height;
 };
 
+struct HeightmapUpdate {
+	HeightmapUpdate(int x, int xx, int y, int yy) : x1(x),x2(xx),y1(y),y2(yy) {}
+	int x1;
+	int x2;
+	int y1;
+	int y2;
+};
 
 class CReadMap
 {
@@ -76,7 +83,10 @@
 	CReadMap(); // use LoadMap
 public:
 	virtual CBaseGroundDrawer *GetGroundDrawer () { return 0; }
-	virtual void HeightmapUpdated(int x1, int x2, int y1, int y2)=0;
+	std::vector&lt;HeightmapUpdate&gt; heightmapUpdates;
+	void HeightmapUpdated(int x1, int x2, int y1, int y2);
+	virtual void HeightmapUpdatedNow(int x1, int x2, int y1, int y2)=0;
+	void UpdateDraw();
 	virtual void Update(){};
 	virtual void Explosion(float x,float y,float strength){};
 	virtual GLuint GetShadingTexture () = 0; // a texture with RGB for shading and A for height

Modified: branches/caiinterface/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- branches/caiinterface/rts/Map/SM3/Sm3Map.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/SM3/Sm3Map.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -155,7 +155,7 @@
 	return groundDrawer;
 }
 
-void CSm3ReadMap::HeightmapUpdated(int x1, int x2, int y1, int y2)
+void CSm3ReadMap::HeightmapUpdatedNow(int x1, int x2, int y1, int y2)
 {
 	// heightmap is [width+1][height+1]
 	x1-=2; x2+=2;

Modified: branches/caiinterface/rts/Map/SM3/Sm3Map.h
===================================================================
--- branches/caiinterface/rts/Map/SM3/Sm3Map.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/SM3/Sm3Map.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -21,7 +21,7 @@
 	void Initialize(const char* mapname); // throws std::runtime_exception on errors
 
 	CBaseGroundDrawer* GetGroundDrawer();
-	void HeightmapUpdated(int x1, int x2, int y1, int y2);
+	void HeightmapUpdatedNow(int x1, int x2, int y1, int y2);
 	const float* GetHeightmap() { return renderer-&gt;GetHeightmap(); }
 
 	inline void SetHeight(int idx, float h) {

Modified: branches/caiinterface/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- branches/caiinterface/rts/Map/SMF/SmfReadMap.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/SMF/SmfReadMap.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -156,7 +156,7 @@
 }
 
 
-void CSmfReadMap::HeightmapUpdated(int x1, int x2, int y1, int y2)
+void CSmfReadMap::HeightmapUpdatedNow(int x1, int x2, int y1, int y2)
 {
 	x1-=x1&amp;3;
 	x2+=(20004-x2)&amp;3;

Modified: branches/caiinterface/rts/Map/SMF/SmfReadMap.h
===================================================================
--- branches/caiinterface/rts/Map/SMF/SmfReadMap.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Map/SMF/SmfReadMap.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -13,7 +13,7 @@
 	CSmfReadMap(std::string mapname);
 	~CSmfReadMap();
 
-	void HeightmapUpdated(int x1, int x2, int y1, int y2);
+	void HeightmapUpdatedNow(int x1, int x2, int y1, int y2);
 	GLuint GetShadingTexture () { return shadowTex; }
 	GLuint GetGrassShadingTexture () { return minimapTex; }
 	void DrawMinimap ();

Modified: branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 #include &quot;AdvTreeDrawer.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
@@ -19,12 +20,6 @@
 #include &quot;Matrix44f.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-boost::mutex treemutex;
-#	endif
-#endif
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -85,9 +80,7 @@
 
 void CAdvTreeDrawer::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Update
 
 	for(std::list&lt;FallingTree&gt;::iterator fti=fallingTrees.begin();fti!=fallingTrees.end();){
 		fti-&gt;fallPos+=fti-&gt;speed*0.1f;
@@ -344,9 +337,7 @@
 	drawer.treeDistance = treeDistance;
 	drawer.drawDetailed = drawDetailed;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Draw
 
 	// draw far away trees using the map dependent grid visibility
 	oldTreeDistance=treeDistance;
@@ -654,9 +645,7 @@
 	drawer.td = this;
 	drawer.treeDistance = treeDistance;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // DrawShadowPass
 
 	// draw with extraSize=1
 	readmap-&gt;GridVisibility (camera, TREE_SQUARE_SIZE, treeDistance*2*SQUARE_SIZE*TREE_SQUARE_SIZE, &amp;drawer, 1);
@@ -791,11 +780,13 @@
 	int y=(int)pos.z/TREE_SQUARE_SIZE/SQUARE_SIZE;
 	TreeSquareStruct* pTSS=trees+y*treesX+x;
 	if(pTSS-&gt;displist){
-		glDeleteLists(pTSS-&gt;displist,1);
+//		glDeleteLists(pTSS-&gt;displist,1);
+		delDispLists.push_back(pTSS-&gt;displist);
 		pTSS-&gt;displist=0;
 	}
 	if(pTSS-&gt;farDisplist){
-		glDeleteLists(pTSS-&gt;farDisplist,1);
+//		glDeleteLists(pTSS-&gt;farDisplist,1);
+		delDispLists.push_back(pTSS-&gt;farDisplist);
 		pTSS-&gt;farDisplist=0;
 	}
 	grassDrawer-&gt;ResetPos(pos);
@@ -803,9 +794,7 @@
 
 void CAdvTreeDrawer::AddTree(int type, float3 pos, float size)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddTree
 
 	TreeStruct ts;
 	ts.pos=pos;
@@ -818,9 +807,7 @@
 
 void CAdvTreeDrawer::DeleteTree(float3 pos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // DeleteTree
 
 	int hash=(int)pos.x+((int)(pos.z))*20000;
 	int square=((int)pos.x)/(SQUARE_SIZE*TREE_SQUARE_SIZE)+((int)pos.z)/(SQUARE_SIZE*TREE_SQUARE_SIZE)*treesX;
@@ -832,9 +819,7 @@
 
 int CAdvTreeDrawer::AddFallingTree(float3 pos, float3 dir, int type)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddFallingTree
 
 	FallingTree ft;
 
@@ -854,18 +839,14 @@
 
 void CAdvTreeDrawer::AddGrass(float3 pos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddGrass
 
 	grassDrawer-&gt;AddGrass(pos);
 }
 
 void CAdvTreeDrawer::RemoveGrass(int x, int z)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // RemoveGrass
 
 	grassDrawer-&gt;RemoveGrass(x,z);
 }

Modified: branches/caiinterface/rts/Rendering/Env/AdvWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/AdvWater.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/AdvWater.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -229,6 +229,8 @@
 
 void CAdvWater::UpdateWater(CGame* game)
 {
+	DeleteOldWater(this);
+
 	if ((!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
@@ -319,8 +321,10 @@
 	glBindTexture(GL_TEXTURE_2D, bumpTexture);
 	glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,128,128);
 
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
 
 	camera-&gt;up.x=0;
 	camera-&gt;up.y=1;
@@ -361,7 +365,10 @@
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
+
 	camera-&gt;Update(false);
 }

Modified: branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -53,3 +53,11 @@
 
 	Draw (treeDistance, drawReflection);
 }
+
+void CBaseTreeDrawer::UpdateDraw() {
+	GML_STDMUTEX_LOCK(tree); // UpdateDraw
+	for(std::vector&lt;GLuint&gt;::iterator i=delDispLists.begin(); i!=delDispLists.end(); ++i)
+		glDeleteLists(*i, 1);
+	delDispLists.clear();
+}
+

Modified: branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,6 +1,7 @@
 #ifndef __BASE_TREE_DRAWER_H__
 #define __BASE_TREE_DRAWER_H__
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;float3.h&quot;
 
 #define TREE_SQUARE_SIZE 64
@@ -20,6 +21,9 @@
 	virtual void AddTree(int type, float3 pos, float size)=0;
 	virtual void DeleteTree(float3 pos)=0;
 
+	std::vector&lt;GLuint&gt; delDispLists;
+  virtual void UpdateDraw();
+
 	float baseTreeDistance;
 	bool drawTrees;
 

Modified: branches/caiinterface/rts/Rendering/Env/BaseWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseWater.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BaseWater.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -20,18 +20,28 @@
 	drawRefraction=false;
  	noWakeProjectiles=false;
  	drawSolid=false;
+	oldwater=NULL;
 }
 
 CBaseWater::~CBaseWater(void)
 {
+	DeleteOldWater(this);
 }
 
-CBaseWater* CBaseWater::GetWater()
+void CBaseWater::DeleteOldWater(CBaseWater *water) {
+	if(water-&gt;oldwater) {
+		DeleteOldWater(water-&gt;oldwater);
+		delete water-&gt;oldwater;
+		water-&gt;oldwater=NULL;
+	}
+}
+
+CBaseWater* CBaseWater::GetWater(CBaseWater* old)
 {
 	CBaseWater* water = NULL;
 	const int configValue = configHandler.GetInt(&quot;ReflectiveWater&quot;,1);
 	
-	if(configValue==2 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_float &amp;&amp;
+	if(water==NULL &amp;&amp; configValue==2 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_float &amp;&amp;
 	   ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB,&quot;waterDyn.fp&quot;)) {
 		try {
 			water = SAFE_NEW CDynWater;
@@ -41,12 +51,9 @@
 			logOutput.Print(&quot;Loading Dynamic Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
 
-	if(configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
+	if(water==NULL &amp;&amp; configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
 		try {
 			water = SAFE_NEW CBumpWater;
 		} catch (content_error&amp; e) {
@@ -55,12 +62,9 @@
 			logOutput.Print(&quot;Loading Bumpmapped Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
 	
-	if(configValue==3 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_rectangle){
+	if(water==NULL &amp;&amp; configValue==3 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp; GLEW_ARB_texture_rectangle){
 		try {
 			water = SAFE_NEW CRefractWater;
 		} catch (content_error&amp; e) {
@@ -69,12 +73,9 @@
 			logOutput.Print(&quot;Loading Refractive Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
 	
-	if(configValue!=0 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp;
+	if(water==NULL &amp;&amp; configValue!=0 &amp;&amp; GLEW_ARB_fragment_program &amp;&amp;
 	   ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB,&quot;water.fp&quot;)){
 		try {
 			water = SAFE_NEW CAdvWater;
@@ -84,10 +85,9 @@
 			logOutput.Print(&quot;Loading Reflective Water failed&quot;);
 			logOutput.Print(&quot;Error: %s&quot;, e.what());
 		}
-		if (water) {
-			return water;
-		}
 	}
-	
-	return SAFE_NEW CBasicWater;
+	if(water==NULL)
+		water = SAFE_NEW CBasicWater;
+	water-&gt;oldwater=old;
+	return water;
 }

Modified: branches/caiinterface/rts/Rendering/Env/BaseWater.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseWater.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BaseWater.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -11,14 +11,17 @@
 	virtual ~CBaseWater(void);
 
 	virtual void Draw()=0;
-	virtual void Update(){};
+	virtual void Update() {}
 	virtual void UpdateWater(CGame* game)=0;
 	virtual void HeightmapChanged(const int x1, const int y1, const int x2, const int y2){};
 	virtual void AddExplosion(const float3&amp; pos, float strength, float size){};
 	virtual int  GetID() const { return -1; }
 
-	static CBaseWater* GetWater();
+	static CBaseWater* GetWater(CBaseWater* old);
 
+	CBaseWater* oldwater;
+	void DeleteOldWater(CBaseWater *water);
+
 	bool drawReflection;
 	bool drawRefraction;
  	bool noWakeProjectiles;

Modified: branches/caiinterface/rts/Rendering/Env/BasicTreeDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BasicTreeDrawer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -16,13 +16,6 @@
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-extern boost::mutex treemutex;
-#	endif
-#endif
-
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -397,9 +390,7 @@
 	drawer.cy = cy;
 	drawer.treeDistance = treeDistance;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Draw
 
 	readmap-&gt;GridVisibility (camera, TREE_SQUARE_SIZE, treeDistance*2*SQUARE_SIZE*TREE_SQUARE_SIZE, &amp;drawer);
 
@@ -446,9 +437,7 @@
 
 void CBasicTreeDrawer::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // Update
 
 }
 
@@ -467,20 +456,18 @@
 	int y=(int)(pos.z/TREE_SQUARE_SIZE/SQUARE_SIZE);
 	TreeSquareStruct* pTSS=trees+y*treesX+x;
 	if(pTSS-&gt;displist){
-		glDeleteLists(pTSS-&gt;displist,1);
+		delDispLists.push_back(pTSS-&gt;displist);
 		pTSS-&gt;displist=0;
 	}
 	if(pTSS-&gt;farDisplist){
-		glDeleteLists(pTSS-&gt;farDisplist,1);
+		delDispLists.push_back(pTSS-&gt;farDisplist);
 		pTSS-&gt;farDisplist=0;
 	}
 }
 
 void CBasicTreeDrawer::AddTree(int type, float3 pos, float size)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // AddTree
 
 	TreeStruct ts;
 	ts.pos=pos;
@@ -493,9 +480,7 @@
 
 void CBasicTreeDrawer::DeleteTree(float3 pos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock treelock(treemutex);
-#endif
+	GML_STDMUTEX_LOCK(tree); // DeleteTree
 
 	int hash=(int)pos.x+((int)(pos.z))*20000;
 	int square=((int)pos.x)/(SQUARE_SIZE*TREE_SQUARE_SIZE)+((int)pos.z)/(SQUARE_SIZE*TREE_SQUARE_SIZE)*treesX;

Modified: branches/caiinterface/rts/Rendering/Env/BasicWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BasicWater.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BasicWater.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -41,6 +41,10 @@
 	glDeleteLists(displist,1);
 }
 
+void CBasicWater::UpdateWater(CGame* game) {
+	DeleteOldWater(this);
+}
+
 void CBasicWater::Draw()
 {
 	if (!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f)

Modified: branches/caiinterface/rts/Rendering/Env/BasicWater.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BasicWater.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BasicWater.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -12,7 +12,7 @@
 {
 public:
 	void Draw();
-	void UpdateWater(CGame* game){};
+	void UpdateWater(CGame* game);
 	CBasicWater();
 	virtual ~CBasicWater();
 	int GetID() const { return 0; }

Modified: branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -687,6 +687,8 @@
 
 void CBumpWater::UpdateWater(CGame* game)
 {
+	DeleteOldWater(this);
+
 	if ((!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
@@ -1057,8 +1059,11 @@
 	if (reflectFBO)
 		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
 
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
+
 	camera-&gt;up.x=0;
 	camera-&gt;up.y=1;
 	camera-&gt;up.z=0;
@@ -1098,7 +1103,10 @@
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
+
 	camera-&gt;Update(false);
 }

Modified: branches/caiinterface/rts/Rendering/Env/DynWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/DynWater.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/DynWater.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -356,6 +356,8 @@
 
 void CDynWater::UpdateWater(CGame* game)
 {
+	DeleteOldWater(this);
+
 	if ((!mapInfo-&gt;water.forceRendering &amp;&amp; readmap-&gt;currMinHeight &gt; 1.0f) || mapInfo-&gt;map.voidWater)
 		return;
 
@@ -407,8 +409,10 @@
 
 void CDynWater::DrawReflection(CGame* game)
 {
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
 
 	camera-&gt;up.x=0;
 	camera-&gt;up.y=1;
@@ -466,8 +470,11 @@
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 	glClearColor(mapInfo-&gt;atmosphere.fogColor[0],mapInfo-&gt;atmosphere.fogColor[1],mapInfo-&gt;atmosphere.fogColor[2],1);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
+
 	camera-&gt;Update(false);
 }
 

Modified: branches/caiinterface/rts/Rendering/Env/GrassDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/GrassDrawer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Env/GrassDrawer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -22,14 +22,6 @@
 #include &quot;System/Exceptions.h&quot;
 //#include &quot;TimeProfiler.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex grassmutex;
-#	endif
-#endif
-
 static const float turfSize=20;				//single turf size
 static const float partTurfSize=turfSize*0.6f;				//single turf size
 static const int grassSquareSize=4;		//mapsquares per grass square
@@ -428,9 +420,7 @@
 	drawer.cy=(int)(camera-&gt;pos.z/bMSsq);
 	drawer.gd = this;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // Draw
 
 	readmap-&gt;GridVisibility (camera, blockMapSize, maxGrassDist, &amp;drawer);
 	CVertexArray *va = drawer.va;
@@ -608,9 +598,7 @@
 	if(grassOff)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // ResetPos
 
 	int a=(int(pos.z/bMSsq)&amp;31)*32+(int(pos.x/bMSsq)&amp;31);
 	if(grass[a].va){
@@ -803,9 +791,7 @@
 	if(grassOff)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // AddGrass
 
 	grassMap[(int(pos.z)/SQUARE_SIZE/grassSquareSize)*gs-&gt;mapx/grassSquareSize+int(pos.x)/SQUARE_SIZE/grassSquareSize]=1;
 }
@@ -815,9 +801,7 @@
 	if(grassOff)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock grasslock(grassmutex);
-#endif
+	GML_RECMUTEX_LOCK(grass); // RemoveGrass
 
 	grassMap[(z/grassSquareSize)*gs-&gt;mapx/grassSquareSize+x/grassSquareSize]=0;
 	ResetPos(float3(x*SQUARE_SIZE,0,z*SQUARE_SIZE));

Modified: branches/caiinterface/rts/Rendering/FartextureHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/FartextureHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/FartextureHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 
 #include &quot;FartextureHandler.h&quot;
@@ -9,7 +10,6 @@
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 
-
 CFartextureHandler* fartextureHandler = NULL;
 
 
@@ -43,6 +43,7 @@
  */
 void CFartextureHandler::CreateFarTexture(S3DOModel* model)
 {
+	GML_STDMUTEX_LOCK(tex); // CreateFarTexture
 	pending.push_back(model);
 }
 
@@ -54,6 +55,7 @@
  */
 void CFartextureHandler::CreateFarTextures()
 {
+	GML_STDMUTEX_LOCK(tex); // CreateFarTextures
 	for(std::vector&lt;S3DOModel*&gt;::const_iterator it = pending.begin(); it != pending.end(); ++it) {
 		ReallyCreateFarTexture(*it);
 	}

Modified: branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -22,13 +22,6 @@
 #include &quot;System/Util.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-boost::mutex decalmutex;
-#	endif
-#endif
-
 using std::list;
 using std::min;
 using std::max;
@@ -415,9 +408,7 @@
 		glMatrixMode(GL_MODELVIEW);
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // Draw
 
 	// create and draw the quads for each building decal
 	for (std::vector&lt;BuildingDecalType*&gt;::iterator bdti = buildingDecalTypes.begin(); bdti != buildingDecalTypes.end(); ++bdti) {
@@ -585,9 +576,7 @@
 
 void CGroundDecalHandler::Update(void)
 {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // Update
 	for(std::vector&lt;CUnit *&gt;::iterator i=moveUnits.begin(); i!=moveUnits.end(); ++i)
 		UnitMovedNow(*i);
 	moveUnits.clear();
@@ -688,9 +677,7 @@
 		++a;
 	}
 
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // GetTrackType
 
 	TrackType* tt = SAFE_NEW TrackType;
 	tt-&gt;name = lowerName;
@@ -736,9 +723,7 @@
 	if (decalLevel == 0)
 		return;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // AddExplosion
 
 	float height = pos.y - ground-&gt;GetHeight2(pos.x, pos.z);
 	if (height &gt;= radius)
@@ -907,9 +892,7 @@
 	if (decalLevel == 0)
 		return;
 
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // AddBuilding
 
 	BuildingDecalType* type = buildingDecalTypes[building-&gt;unitDef-&gt;buildingDecalType];
 	BuildingGroundDecal* decal = SAFE_NEW BuildingGroundDecal;
@@ -947,9 +930,7 @@
 
 void CGroundDecalHandler::RemoveBuilding(CBuilding* building,CUnitDrawer::GhostBuilding* gb)
 {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // RemoveBuilding
 
 	BuildingGroundDecal* decal = building-&gt;buildingDecal;
 	if (!decal)
@@ -978,9 +959,7 @@
 		++a;
 	}
 
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock decallock(decalmutex);
-#endif
+	GML_STDMUTEX_LOCK(decal); // GetBuildingDecalType
 
 	BuildingDecalType* tt = SAFE_NEW BuildingDecalType;
 	tt-&gt;name = lowerName;

Modified: branches/caiinterface/rts/Rendering/InMapDraw.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/InMapDraw.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/InMapDraw.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -308,6 +308,8 @@
 
 void CInMapDraw::Draw(void)
 {
+	GML_STDMUTEX_LOCK(inmap); // Draw
+
 	glDepthMask(0);
 
 	CVertexArray* va = GetVertexArray();
@@ -433,6 +435,8 @@
 void CInMapDraw::LocalPoint(const float3&amp; constPos, const std::string&amp; label,
                             int playerID)
 {
+	GML_STDMUTEX_LOCK(inmap); // LocalPoint
+
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}
@@ -488,6 +492,8 @@
 void CInMapDraw::LocalLine(const float3&amp; constPos1, const float3&amp; constPos2,
                            int playerID)
 {
+	GML_STDMUTEX_LOCK(inmap); // LocalLine
+
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}
@@ -526,6 +532,8 @@
 
 void CInMapDraw::LocalErase(const float3&amp; constPos, int playerID)
 {
+	GML_STDMUTEX_LOCK(inmap); // LocalErase
+
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}

Modified: branches/caiinterface/rts/Rendering/Textures/TextureHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Textures/TextureHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Textures/TextureHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -279,7 +279,25 @@
 	glBindTexture(GL_TEXTURE_2D, globalTex);
 }
 
-int CTextureHandler::LoadS3OTexture(const std::string&amp; tex1, const std::string&amp; tex2)
+void CTextureHandler::LoadS3OTexture(S3DOModel *model) {
+	string totalName=model-&gt;tex1+model-&gt;tex2;
+
+	if(s3oTextureNames.find(totalName)!=s3oTextureNames.end()){
+		model-&gt;textureType=s3oTextureNames[totalName];
+	}
+	model-&gt;textureType=0;
+	GML_STDMUTEX_LOCK(model); // LoadS3OTexture
+	loadTextures.push_back(model);
+}
+
+void CTextureHandler::Update() {
+	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;S3DOModel *&gt;::iterator i=loadTextures.begin(); i!=loadTextures.end();++i)
+		(*i)-&gt;textureType=LoadS3OTextureNow((char*)(*i)-&gt;tex1.c_str(),(char*)(*i)-&gt;tex2.c_str());
+	loadTextures.clear();
+}
+
+int CTextureHandler::LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2)
 {
 	string totalName=tex1+tex2;
 

Modified: branches/caiinterface/rts/Rendering/Textures/TextureHandler.h
===================================================================
--- branches/caiinterface/rts/Rendering/Textures/TextureHandler.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/Textures/TextureHandler.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -8,6 +8,7 @@
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 
 struct TexFile;
 class CFileHandler;
@@ -38,7 +39,10 @@
 	UnitTexture* GetTATexture(std::string name, int team, int teamTex);
 	UnitTexture* GetTATexture(const std::string&amp; name);
 
-	int LoadS3OTexture(const std::string&amp; tex1, const std::string&amp; tex2);
+	std::vector&lt;S3DOModel *&gt; loadTextures;
+	void Update();
+	void LoadS3OTexture(S3DOModel *model);
+	int LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2);
 	void SetS3oTexture(int num);
 
 	const S3oTex* GetS3oTex(int num) {

Modified: branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;algorithm&gt;
 #include &lt;cctype&gt;
 #include &quot;mmgr.h&quot;
@@ -44,6 +45,44 @@
 }
 */
 
+void C3DModelParser::Update() {
+	GML_STDMUTEX_LOCK(model); // Update
+	units3oparser-&gt;Update();
+	unit3doparser-&gt;Update();
+
+	for(std::set&lt;CUnit *&gt;::iterator i=fixLocalModels.begin(); i!=fixLocalModels.end(); ++i)
+		FixLocalModel(*i);
+	fixLocalModels.clear();
+
+	for(std::vector&lt;LocalS3DOModel *&gt;::iterator i=deleteLocalModels.begin(); i!=deleteLocalModels.end(); ++i)
+		delete *i;
+	deleteLocalModels.clear();
+}
+
+void C3DModelParser::CreateLocalModel(CUnit *unit)
+{
+	GML_STDMUTEX_LOCK(model); // CreateLocalModel
+	unit-&gt;localmodel=CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
+	fixLocalModels.insert(unit);
+}
+
+void C3DModelParser::DeleteLocalModel(CUnit *unit)
+{
+	GML_STDMUTEX_LOCK(model); // DeleteLocalModel
+	fixLocalModels.erase(unit);
+	deleteLocalModels.push_back(unit-&gt;localmodel);
+}
+
+void C3DModelParser::FixLocalModel(CUnit *unit)
+{
+	if (unit-&gt;model-&gt;rootobject3do) {
+		unit3doparser-&gt;FixLocalModel(unit-&gt;model,unit-&gt;localmodel,&amp;unit-&gt;cob-&gt;pieces);
+	} else {
+		units3oparser-&gt;FixLocalModel(unit-&gt;model,unit-&gt;localmodel,&amp;unit-&gt;cob-&gt;pieces);
+	}
+}
+
+
 LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel* lm;

Modified: branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/3DModelParser.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -2,9 +2,11 @@
 #define SPRING_3DMODELPARSER_H
 
 #include &lt;vector&gt;
+#include &lt;set&gt;
 #include &lt;string&gt;
 #include &quot;Matrix44f.h&quot;
 #include &quot;System/GlobalStuff.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
 
 struct S3DO;
 struct SS3O;
@@ -20,8 +22,14 @@
 	C3DModelParser(void);
 	~C3DModelParser(void);
 
+	void Update();
 	S3DOModel* Load3DModel(std::string name, float scale = 1.0f, int side = 1);
 	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
+	std::set&lt;CUnit *&gt; fixLocalModels;
+	std::vector&lt;LocalS3DOModel *&gt; deleteLocalModels;
+	void DeleteLocalModel(CUnit *unit);
+	void CreateLocalModel(CUnit *unit);
+	void FixLocalModel(CUnit *unit);
 	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
 
 	C3DOParser* unit3doparser;
@@ -44,7 +52,8 @@
 	float minx,miny,minz;
 	float3 relMidPos;
 	int textureType;		//0=3do, otherwise s3o
-
+	std::string tex1;
+	std::string tex2;
 	void DrawStatic();
 };
 

Modified: branches/caiinterface/rts/Rendering/UnitModels/3DOParser.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/3DOParser.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/3DOParser.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -506,7 +506,20 @@
 }
 
 
-void C3DOParser::CreateLists(S3DO *o)
+void C3DOParser::Update() {
+//	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;S3DO *&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
+		CreateListsNow(*i);
+	createLists.clear();
+}
+
+void C3DOParser::CreateLists(S3DO *o) {
+	GML_STDMUTEX_LOCK(model); // CreateLists
+	createLists.push_back(o);
+}
+
+
+void C3DOParser::CreateListsNow(S3DO *o)
 {
 	o-&gt;displist = glGenLists(1);
 	PUSH_CODE_MODE;
@@ -517,7 +530,7 @@
 	POP_CODE_MODE;
 
 	for(std::vector&lt;S3DO*&gt;::iterator bs=o-&gt;childs.begin();bs!=o-&gt;childs.end();bs++){
-		CreateLists(*bs);
+		CreateListsNow(*bs);
 	}
 }
 
@@ -682,6 +695,21 @@
 }
 
 
+void C3DOParser::FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces) {
+	int piecenum=0;
+	FixLocalModel(model-&gt;rootobject3do, lmodel, pieces, &amp;piecenum);
+}
+
+void C3DOParser::FixLocalModel(S3DO *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum) {
+	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
+
+	for(unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
+		(*piecenum)++;
+		FixLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
+	}
+}
+
+
 LocalS3DOModel *C3DOParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
 {
 	LocalS3DOModel *lmodel = SAFE_NEW LocalS3DOModel;

Modified: branches/caiinterface/rts/Rendering/UnitModels/3DOParser.h
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/3DOParser.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/3DOParser.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -92,6 +92,8 @@
 	S3DOModel* Load3DO(std::string name, float scale = 1, int side = 1);
 	// S3DOModel* Load3DO(std::string name,float scale,int side,const float3&amp; offsets);
 	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
+	void Update();
+	void FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces);
 
 private:
 	void FindCenter(S3DO* object);
@@ -100,7 +102,9 @@
 	void CalcNormals(S3DO* o);
 
 	void DeleteS3DO(S3DO* o);
+	std::vector&lt;S3DO*&gt; createLists;
 	void CreateLists(S3DO* o);
+	void CreateListsNow(S3DO* o);
 	float scaleFactor;
 
 	void GetPrimitives(S3DO* obj,int pos,int num,vertex_vector* vv,int excludePrim,int side);
@@ -109,6 +113,7 @@
 	bool ReadChild(int pos,S3DO* root,int side, int *numobj);
 	void DrawSub(S3DO* o);
 	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void FixLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
 	std::map&lt;std::string, S3DOModel*&gt; units;
 	std::set&lt;std::string&gt; teamtex;

Modified: branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -46,10 +46,6 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex unitmutex;
-#	endif
 extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 #endif
 
@@ -219,9 +215,7 @@
 
 void CUnitDrawer::Update(void)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_STDMUTEX_LOCK(temp); //unit); // Update
 
 	while (!tempDrawUnits.empty() &amp;&amp; tempDrawUnits.begin()-&gt;first &lt; gs-&gt;frameNum - 1) {
 		tempDrawUnits.erase(tempDrawUnits.begin());
@@ -414,9 +408,7 @@
 	CUnit* excludeUnit = drawReflection ? NULL : gu-&gt;directControl;
 #endif
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // Draw
 
 #ifdef USE_GML
 	if(multiThreadDrawUnit) {
@@ -443,14 +435,18 @@
 	}
 #endif
 
-	std::multimap&lt;int, TempDrawUnit&gt;::iterator ti;
-	for (ti = tempDrawUnits.begin(); ti != tempDrawUnits.end(); ++ti) {
-		if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
-			glPushMatrix();
-			glTranslatef3(ti-&gt;second.pos);
-			glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
-			ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team)-&gt;DrawStatic();
-			glPopMatrix();
+	{
+		GML_STDMUTEX_LOCK(temp); // Draw
+
+		std::multimap&lt;int, TempDrawUnit&gt;::iterator ti;
+		for (ti = tempDrawUnits.begin(); ti != tempDrawUnits.end(); ++ti) {
+			if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
+				glPushMatrix();
+				glTranslatef3(ti-&gt;second.pos);
+				glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
+				ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team)-&gt;DrawStatic();
+				glPopMatrix();
+			}
 		}
 	}
 
@@ -691,9 +687,7 @@
 
 	CUnit::SetLODFactor(LODScale * LODScaleShadow);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // DrawShadowPass
 
 #ifdef USE_GML
 	if(multiThreadDrawUnitShadow) {
@@ -865,45 +859,45 @@
 	glColor4f(1, 1, 1, 0.3f);
 	glDepthMask(0);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // DrawCloakedUnits
 
-	// units drawn by AI, these aren't really
-	// cloaked but the effect is the same
-	for (std::multimap&lt;int, TempDrawUnit&gt;::iterator ti = tempTransparentDrawUnits.begin(); ti != tempTransparentDrawUnits.end(); ++ti) {
-		if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
-			glPushMatrix();
-			glTranslatef3(ti-&gt;second.pos);
-			glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
-			S3DOModel* model = ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team);
-			model-&gt;DrawStatic();
-			glPopMatrix();
-		}
-		if (ti-&gt;second.drawBorder) {
-			float3 pos = ti-&gt;second.pos;
-			const UnitDef *unitdef = ti-&gt;second.unitdef;
+	{
+		GML_STDMUTEX_LOCK(temp); // DrawCloakedUnits
+		// units drawn by AI, these aren't really
+		// cloaked but the effect is the same
+		for (std::multimap&lt;int, TempDrawUnit&gt;::iterator ti = tempTransparentDrawUnits.begin(); ti != tempTransparentDrawUnits.end(); ++ti) {
+			if (camera-&gt;InView(ti-&gt;second.pos, 100)) {
+				glPushMatrix();
+				glTranslatef3(ti-&gt;second.pos);
+				glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
+				S3DOModel* model = ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team);
+				model-&gt;DrawStatic();
+				glPopMatrix();
+			}
+			if (ti-&gt;second.drawBorder) {
+				float3 pos = ti-&gt;second.pos;
+				const UnitDef *unitdef = ti-&gt;second.unitdef;
 
-			BuildInfo bi(unitdef, pos, ti-&gt;second.facing);
-			pos = helper-&gt;Pos2BuildPos(bi);
+				BuildInfo bi(unitdef, pos, ti-&gt;second.facing);
+				pos = helper-&gt;Pos2BuildPos(bi);
 
-			float xsize = bi.GetXSize() * 4;
-			float ysize = bi.GetYSize() * 4;
-			glColor4f(0.2f, 1, 0.2f, 0.7f);
-			glDisable(GL_TEXTURE_2D);
-			glBegin(GL_LINE_STRIP);
-			glVertexf3(pos+float3( xsize, 1,  ysize));
-			glVertexf3(pos+float3(-xsize, 1,  ysize));
-			glVertexf3(pos+float3(-xsize, 1, -ysize));
-			glVertexf3(pos+float3( xsize, 1, -ysize));
-			glVertexf3(pos+float3( xsize, 1,  ysize));
-			glEnd();
-			glColor4f(1, 1, 1, 0.3f);
-			glEnable(GL_TEXTURE_2D);
+				float xsize = bi.GetXSize() * 4;
+				float ysize = bi.GetYSize() * 4;
+				glColor4f(0.2f, 1, 0.2f, 0.7f);
+				glDisable(GL_TEXTURE_2D);
+				glBegin(GL_LINE_STRIP);
+				glVertexf3(pos+float3( xsize, 1,  ysize));
+				glVertexf3(pos+float3(-xsize, 1,  ysize));
+				glVertexf3(pos+float3(-xsize, 1, -ysize));
+				glVertexf3(pos+float3( xsize, 1, -ysize));
+				glVertexf3(pos+float3( xsize, 1,  ysize));
+				glEnd();
+				glColor4f(1, 1, 1, 0.3f);
+				glEnable(GL_TEXTURE_2D);
+			}
 		}
 	}
 
-
 	// 3dos
 	DrawCloakedUnitsHelper(drawCloaked, ghostBuildings, false);
 
@@ -1514,8 +1508,11 @@
 {
 	glViewport(0, 0, reflTexSize, reflTexSize);
 
-	CCamera *realCam = camera;
-	camera = new CCamera(*realCam);
+//	CCamera *realCam = camera;
+//	camera = new CCamera(*realCam);
+	char realCam[sizeof(CCamera)];
+	new (realCam) CCamera(*camera); // anti-crash workaround for multithreading
+
 	camera-&gt;SetFov(90);
 	camera-&gt;forward = camdir;
 	camera-&gt;up = -UpVector;
@@ -1544,8 +1541,10 @@
 
 	glViewport(gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
 
-	delete camera;
-	camera = realCam;
+//	delete camera;
+//	camera = realCam;
+	camera-&gt;~CCamera();
+	new (camera) CCamera(*(CCamera *)realCam);
 }
 
 void CUnitDrawer::QueS3ODraw(CWorldObject* object, int textureType)
@@ -1932,13 +1931,7 @@
 
 void CUnitDrawer::ApplyUnitTransformMatrix(CUnit* unit)
 {
-#ifdef USE_GML
-	CMatrix44f m;
-#else
-	static CMatrix44f m;
-	m.LoadIdentity();
-#endif
-	unit-&gt;GetTransformMatrix(m);
+	CMatrix44f m = unit-&gt;GetTransformMatrix();
 	glMultMatrixf(&amp;m[0]);
 }
 
@@ -2045,10 +2038,11 @@
 
 	float3 interPos;
 
-	if (!unit-&gt;transporter) {
+	CTransportUnit *trans=unit-&gt;transporter;
+	if (!trans) {
 		interPos = unit-&gt;pos + (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		interPos = unit-&gt;pos + (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		interPos = unit-&gt;pos + (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	interPos.y += unit-&gt;model-&gt;height + 5.0f;

Modified: branches/caiinterface/rts/Rendering/UnitModels/s3oParser.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/s3oParser.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/s3oParser.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -92,7 +92,9 @@
 	model-&gt;rootobject3do=0;
 	object-&gt;isEmpty=true;
 	model-&gt;name=name;
-	model-&gt;textureType=texturehandler-&gt;LoadS3OTexture((char*)&amp;fileBuf[header.texture1],(char*)&amp;fileBuf[header.texture2]);
+	model-&gt;tex1=(char*)&amp;fileBuf[header.texture1];
+	model-&gt;tex2=(char*)&amp;fileBuf[header.texture2];
+	texturehandler-&gt;LoadS3OTexture(model);
 
 	FindMinMax(object);
 
@@ -204,6 +206,22 @@
 	POP_CODE_MODE;
 }
 
+
+void CS3OParser::FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces) {
+	int piecenum=0;
+	FixLocalModel(model-&gt;rootobjects3o, lmodel, pieces, &amp;piecenum);
+}
+
+void CS3OParser::FixLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum) {
+	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
+
+	for (unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
+		(*piecenum)++;
+		FixLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
+	}
+}
+
+
 SS3O* CS3OParser::LoadPiece(unsigned char* buf, int offset,S3DOModel* model)
 {
 	model-&gt;numobjects++;
@@ -317,8 +335,19 @@
 
 }
 
+void CS3OParser::Update() {
+//	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;SS3O *&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
+		CreateListsNow(*i);
+	createLists.clear();
+}
 
-void CS3OParser::CreateLists(SS3O *o)
+void CS3OParser::CreateLists(SS3O *o) {
+	GML_STDMUTEX_LOCK(model); // CreateLists
+	createLists.push_back(o);
+}
+
+void CS3OParser::CreateListsNow(SS3O *o)
 {
 	o-&gt;displist = glGenLists(1);
 	PUSH_CODE_MODE;
@@ -329,7 +358,7 @@
 	POP_CODE_MODE;
 
 	for(std::vector&lt;SS3O*&gt;::iterator bs=o-&gt;childs.begin();bs!=o-&gt;childs.end();bs++){
-		CreateLists(*bs);
+		CreateListsNow(*bs);
 	}
 }
 

Modified: branches/caiinterface/rts/Rendering/UnitModels/s3oParser.h
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/s3oParser.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Rendering/UnitModels/s3oParser.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -40,14 +40,19 @@
 
 	S3DOModel* LoadS3O(std::string name, float scale = 1, int side = 1);
 	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
+	void FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces);
+	void Update();
 
 private:
 	SS3O* LoadPiece(unsigned char* buf, int offset,S3DOModel* model);
 	void DeleteSS3O(SS3O* o);
 	void FindMinMax(SS3O *object);
 	void DrawSub(SS3O* o);
+	std::vector&lt;SS3O *&gt; createLists;
 	void CreateLists(SS3O *o);
+	void CreateListsNow(SS3O *o);
 	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	void FixLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
 
 	std::map&lt;std::string,S3DOModel*&gt; units;
 };

Modified: branches/caiinterface/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Features/FeatureHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Features/FeatureHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -32,14 +32,6 @@
 #include &quot;creg/STL_Set.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex featmutex;
-#	endif
-#endif
-
 using namespace std;
 
 
@@ -398,9 +390,7 @@
 
 int CFeatureHandler::AddFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // AddFeature
 
 	ASSERT_SYNCED_MODE;
 
@@ -431,9 +421,7 @@
 
 void CFeatureHandler::DeleteFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex); // maybe superfluous
-#endif
+	GML_RECMUTEX_LOCK(feat); // DeleteFeature, maybe superfluous
 
 	ASSERT_SYNCED_MODE;
 	toBeRemoved.push_back(feature-&gt;id);
@@ -482,10 +470,6 @@
 
 void CFeatureHandler::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
-
 	ASSERT_SYNCED_MODE;
 	SCOPED_TIMER(&quot;Feature::Update&quot;);
 
@@ -503,24 +487,29 @@
 			freeIDs.splice(freeIDs.end(), toBeFreedIDs, toBeFreedIDs.begin(), toBeFreedIDs.end());
 	}
 
-	while (!toBeRemoved.empty()) {
-		CFeatureSet::iterator it = activeFeatures.find(toBeRemoved.back());
-		toBeRemoved.pop_back();
-		if (it != activeFeatures.end()) {
-			CFeature* feature = *it;
-			toBeFreedIDs.push_back(feature-&gt;id);
-			activeFeatures.erase(feature);
-
-			if (feature-&gt;drawQuad &gt;= 0) {
-				DrawQuad* dq = &amp;drawQuads[feature-&gt;drawQuad];
-				dq-&gt;features.erase(feature);
+	if(!toBeRemoved.empty()) {
+		GML_RECMUTEX_LOCK(feat); // Update
+		GML_RECMUTEX_LOCK(quad); // Update
+		
+		while (!toBeRemoved.empty()) {
+			CFeatureSet::iterator it = activeFeatures.find(toBeRemoved.back());
+			toBeRemoved.pop_back();
+			if (it != activeFeatures.end()) {
+				CFeature* feature = *it;
+				toBeFreedIDs.push_back(feature-&gt;id);
+				activeFeatures.erase(feature);
+				
+				if (feature-&gt;drawQuad &gt;= 0) {
+					DrawQuad* dq = &amp;drawQuads[feature-&gt;drawQuad];
+					dq-&gt;features.erase(feature);
+				}
+				
+				if (feature-&gt;inUpdateQue) {
+					updateFeatures.erase(feature);
+				}
+				
+				delete feature;
 			}
-
-			if (feature-&gt;inUpdateQue) {
-				updateFeatures.erase(feature);
-			}
-
-			delete feature;
 		}
 	}
 
@@ -540,9 +529,7 @@
 
 void CFeatureHandler::UpdateDrawQuad(CFeature* feature, const float3&amp; newPos)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // UpdateDrawQuad
 
 	const int oldDrawQuad = feature-&gt;drawQuad;
 	if (oldDrawQuad &gt;= 0) {
@@ -604,9 +591,7 @@
 	ASSERT_UNSYNCED_MODE;
 	drawFar.clear();
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // Draw
 
 	unitDrawer-&gt;SetupForUnitDrawing();
 	DrawRaw(0, &amp;drawFar);
@@ -639,9 +624,7 @@
 	glPolygonOffset(1,1);
 	glEnable(GL_POLYGON_OFFSET_FILL);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(feat); // DrawShadowPass
 
 	unitDrawer-&gt;SetupForUnitDrawing();
 	DrawRaw(1, NULL);

Modified: branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -79,8 +79,7 @@
 			// NOTE: we have to translate by relMidPos to get to midPos
 			// (which is where the collision volume gets drawn) because
 			// GetTransformMatrix() only uses pos
-			CMatrix44f m;
-			u-&gt;GetTransformMatrix(m, true);
+			CMatrix44f m = u-&gt;GetTransformMatrix(true);
 			m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
 			m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
 
@@ -175,13 +174,10 @@
 
 
 
-bool CCollisionHandler::MouseHit(const CUnit* u, const float3&amp; e, const float3&amp; p0, const float3&amp; p1, const CollisionVolume* v, CollisionQuery* q)
+bool CCollisionHandler::MouseHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, const CollisionVolume* v, CollisionQuery* q)
 {
-	CMatrix44f m;
-	u-&gt;GetTransformMatrix(m, true);
-	float3 relMidPos(u-&gt;midPos - u-&gt;pos);
-	m.Translate(relMidPos.x + e.x, relMidPos.y + e.y, relMidPos.z + e.z);
-	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
+	CMatrix44f m = u-&gt;GetTransformMatrix(false, true);
+	m.Translate(u-&gt;relMidPos + v-&gt;axisOffsets);
 
 	return CCollisionHandler::Intersect(v, m, p0, p1, q);
 }
@@ -190,8 +186,7 @@
 {
 	const CollisionVolume* v = u-&gt;collisionVolume;
 
-	CMatrix44f m;
-	u-&gt;GetTransformMatrix(m, true);
+	CMatrix44f m = u-&gt;GetTransformMatrix(true);
 	m.Translate(u-&gt;relMidPos.x, u-&gt;relMidPos.y, u-&gt;relMidPos.z);
 	m.Translate(v-&gt;axisOffsets.x, v-&gt;axisOffsets.y, v-&gt;axisOffsets.z);
 

Modified: branches/caiinterface/rts/Sim/Misc/CollisionHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionHandler.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Misc/CollisionHandler.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -33,7 +33,7 @@
 
 		static bool DetectHit(const CUnit*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
 		static bool DetectHit(const CFeature*, const float3&amp;, const float3&amp;, CollisionQuery* q = 0x0);
-		static bool MouseHit(const CUnit*, const float3&amp; e, const float3&amp; p0, const float3&amp; p1, const CollisionVolume*, CollisionQuery* q);
+		static bool MouseHit(const CUnit*, const float3&amp; p0, const float3&amp; p1, const CollisionVolume*, CollisionQuery* q);
 
 	private:
 		static bool Collision(const CUnit*, const float3&amp;);

Modified: branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -213,10 +213,20 @@
 			BlockingMapCell&amp; cell = groundBlockingMap[idx];
 			BlockingMapCellIt it = cell.find(objID);
 
-			if (it != cell.end() &amp;&amp; cell.size() &gt;= 2) {
-				// something else besides us present
-				// at this position, cannot close yet
-				return false;
+			if (it == cell.end()) {
+				// we are non-blocking in this part of
+				// our yardmap footprint, but something
+				// might be inside us
+				if (cell.size() &gt;= 1) {
+					return false;
+				}
+			} else {
+				// this part of our yardmap is blocking, we
+				// can't close if something else present on
+				// it besides us
+				if (cell.size() &gt;= 2) {
+					return false;
+				}
 			}
 		}
 	}

Modified: branches/caiinterface/rts/Sim/Misc/QuadField.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/QuadField.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Misc/QuadField.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 // QuadField.cpp: implementation of the CQuadField class.
 //
 //////////////////////////////////////////////////////////////////////
@@ -12,15 +13,6 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;creg/STL_List.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-extern boost::recursive_mutex featmutex;
-boost::recursive_mutex quadmutex;
-#	endif
-#endif
-
 CR_BIND(CQuadField, );
 CR_REG_METADATA(CQuadField, (
 		CR_MEMBER(numQuadsX),
@@ -134,9 +126,7 @@
 			return;
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock quadlock(quadmutex); // possible performance hog
-#endif
+	GML_RECMUTEX_LOCK(quad); // MovedUnit, possible performance hog
 
 	std::vector&lt;int&gt;::iterator qi;
 	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
@@ -374,9 +364,7 @@
 
 void CQuadField::RemoveUnit(CUnit* unit)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock quadlock(quadmutex);
-#endif
+	GML_RECMUTEX_LOCK(quad); // RemoveUnit
 	std::vector&lt;int&gt;::iterator qi;
 	for (qi = unit-&gt;quads.begin(); qi != unit-&gt;quads.end(); ++qi) {
 		std::list&lt;CUnit*&gt;::iterator ui;
@@ -397,9 +385,7 @@
 
 void CQuadField::AddFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(quad); //feat); // AddFeature
 
 	vector&lt;int&gt; newQuads=GetQuads(feature-&gt;pos,feature-&gt;radius);
 
@@ -411,9 +397,7 @@
 
 void CQuadField::RemoveFeature(CFeature* feature)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock featlock(featmutex);
-#endif
+	GML_RECMUTEX_LOCK(quad); //feat); // RemoveFeature
 
 	vector&lt;int&gt; quads=GetQuads(feature-&gt;pos,feature-&gt;radius);
 

Modified: branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -100,6 +100,7 @@
 	maxAileron(0.04f),
 	maxElevator(0.02f),
 	maxRudder(0.01f),
+	maxSpeed(owner-&gt;maxSpeed),
 	invDrag(0.995f),
 	crashDrag(0.995f),
 	inSupply(0),
@@ -114,9 +115,10 @@
 	loopbackAttack(false)
 {
 	turnRadius = 150;
-	if (owner) owner-&gt;mapSquare += 1;						//to force los recalculation
 
-	//From Aircraft::Init
+	// force LOS recalculation
+	if (owner) owner-&gt;mapSquare += 1;
+
 	maxRudder *= 0.99f + gs-&gt;randFloat() * 0.02f;
 	maxElevator *= 0.99f + gs-&gt;randFloat() * 0.02f;
 	maxAileron *= 0.99f + gs-&gt;randFloat() * 0.02f;
@@ -149,7 +151,7 @@
 
 void CAirMoveType::Update(void)
 {
-	float3 &amp;pos = owner-&gt;pos;
+	float3&amp; pos = owner-&gt;pos;
 
 	// note: this is only set to false after
 	// the plane has finished constructing
@@ -163,6 +165,7 @@
 		goto EndNormalControl;
 	}
 
+
 #ifdef DIRECT_CONTROL_ALLOWED
 	if (owner-&gt;directControl &amp;&amp; !(aircraftState == AIRCRAFT_CRASHING)) {
 		SetState(AIRCRAFT_FLYING);
@@ -189,6 +192,7 @@
 	}
 #endif
 
+
 	if (reservedPad) {
 		CUnit* unit = reservedPad-&gt;GetUnit();
 		float3 relPos = unit-&gt;localmodel-&gt;GetPiecePos(reservedPad-&gt;GetPiece());
@@ -233,13 +237,15 @@
 				SetState(AIRCRAFT_TAKEOFF);
 			}
 		}
-	} else if (padStatus == 0 &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0.0f &amp;&amp; owner-&gt;currentFuel &lt;= 0.0f) {
+	} else if ((owner-&gt;unitDef-&gt;maxFuel &gt; 0.0f &amp;&amp; owner-&gt;currentFuel &lt;= 0.0f) &amp;&amp;
+				padStatus == 0 &amp;&amp; maxWantedSpeed &gt; 0.0f) {
 		// keep us in the air to reach our landing goalPos
 		// (which is hopefully in the vicinity of a pad)
 		SetState(AIRCRAFT_FLYING);
 	}
 
 
+
 	switch (aircraftState) {
 		case AIRCRAFT_FLYING: {
 	#ifdef DEBUG_AIRCRAFT
@@ -303,6 +309,8 @@
 EndNormalControl:
 
 
+
+	// handle collisions
 	if (pos != oldpos) {
 		oldpos = pos;
 		bool hitBuilding = false;
@@ -374,12 +382,14 @@
 		}
 	}
 
+
+
 #ifdef DEBUG_AIRCRAFT
-	if (lastColWarningType==1) {
+	if (lastColWarningType == 1) {
 		int g = geometricObjects-&gt;AddLine(owner-&gt;pos, lastColWarning-&gt;pos, 10, 1, 1);
 		geometricObjects-&gt;SetColor(g, 0.2f, 1, 0.2f, 0.6f);
-	} else if(lastColWarningType == 2) {
-		int g=geometricObjects-&gt;AddLine(owner-&gt;pos, lastColWarning-&gt;pos, 10, 1, 1);
+	} else if (lastColWarningType == 2) {
+		int g = geometricObjects-&gt;AddLine(owner-&gt;pos, lastColWarning-&gt;pos, 10, 1, 1);
 		if (owner-&gt;frontdir.dot(lastColWarning-&gt;midPos + lastColWarning-&gt;speed * 20 - owner-&gt;midPos - owner-&gt;speed * 20) &lt; 0)
 			geometricObjects-&gt;SetColor(g, 1, 0.2f, 0.2f, 0.6f);
 		else
@@ -392,17 +402,19 @@
 
 void CAirMoveType::SlowUpdate(void)
 {
-	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0)
-		owner-&gt;currentFuel = std::max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
+	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0.0f) {
+		owner-&gt;currentFuel = std::max(0.0f, owner-&gt;currentFuel - (16.0f / GAME_SPEED));
+	}
 
 	if (owner-&gt;pos != oldSlowUpdatePos) {
 		oldSlowUpdatePos = owner-&gt;pos;
 
-		//try to handle aircraft getting unlimited height
+		// try to handle aircraft getting unlimited height
 		if (owner-&gt;pos.y - ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) &gt; wantedHeight * 5 + 100)
 			owner-&gt;pos.y = ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) + wantedHeight * 5  + 100;
 
 		int newmapSquare = ground-&gt;GetSquare(owner-&gt;pos);
+
 		if (newmapSquare != owner-&gt;mapSquare) {
 			owner-&gt;mapSquare = newmapSquare;
 			float oldlh = owner-&gt;losHeight;
@@ -430,47 +442,59 @@
 	}
 #endif
 	float speedf = owner-&gt;speed.Length();
-	switch(maneuver) {
-	case 1: {	//immelman
-		int aileron = 0, elevator = 0;
-		if (owner-&gt;updir.y &gt; 0) {
-			if (owner-&gt;rightdir.y &gt; maxAileron * speedf) {
-				aileron = 1;
-			} else if (owner-&gt;rightdir.y &lt; -maxAileron * speedf) {
-				aileron = -1;
+
+	switch (maneuver) {
+		case 1: {
+			// Immelman
+			int aileron = 0, elevator = 0;
+
+			if (owner-&gt;updir.y &gt; 0.0f) {
+				if (owner-&gt;rightdir.y &gt; maxAileron * speedf) {
+					aileron = 1;
+				} else if (owner-&gt;rightdir.y &lt; -maxAileron * speedf) {
+					aileron = -1;
+				}
 			}
+
+			if (fabs(owner-&gt;rightdir.y) &lt; maxAileron * 3.0f * speedf || owner-&gt;updir.y &lt; 0.0f)
+				elevator = 1;
+			UpdateAirPhysics(0, aileron, elevator, 1, owner-&gt;frontdir);
+
+			if ((owner-&gt;updir.y &lt; 0.0f &amp;&amp; owner-&gt;frontdir.y &lt; 0.0f) || speedf &lt; 0.8f)
+				maneuver = 0;
+			// some seem to report that the &quot;unlimited altitude&quot; thing is because of these maneuvers
+			if (owner-&gt;pos.y - ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) &gt; wantedHeight * 4.0f)
+				maneuver = 0;
+			break;
 		}
-		if (fabs(owner-&gt;rightdir.y) &lt; maxAileron * 3 * speedf || owner-&gt;updir.y &lt; 0)
-			elevator = 1;
-		UpdateAirPhysics(0, aileron, elevator, 1, owner-&gt;frontdir);
-		if ((owner-&gt;updir.y &lt; 0 &amp;&amp; owner-&gt;frontdir.y &lt; 0) || speedf &lt; 0.8f)
-			maneuver = 0;
-		//some seem to report that the &quot;unlimited altitude&quot; thing is because of these maneuvers
-		if(owner-&gt;pos.y - ground-&gt;GetApproximateHeight(owner-&gt;pos.x, owner-&gt;pos.z) &gt; wantedHeight * 4)
-			maneuver = 0;
-		break;}
-	case 2: {	//inverted immelman
-		int aileron = 0, elevator = 0;
-		if (maneuverSubState == 0) {
-			if (owner-&gt;rightdir.y &gt;= 0) {
-				aileron = -1;
-			} else {
-				aileron = 1;
+
+		case 2: {
+			// inverted Immelman
+			int aileron = 0, elevator = 0;
+			if (maneuverSubState == 0) {
+				if (owner-&gt;rightdir.y &gt;= 0.0f) {
+					aileron = -1;
+				} else {
+					aileron = 1;
+				}
 			}
+
+			if (owner-&gt;frontdir.y &lt; -0.7f)
+				maneuverSubState = 1;
+			if (maneuverSubState == 1 || owner-&gt;updir.y &lt; 0.0f)
+				elevator = 1;
+
+			UpdateAirPhysics(0, aileron, elevator, 1, owner-&gt;frontdir);
+	
+			if ((owner-&gt;updir.y &gt; 0.0f &amp;&amp; owner-&gt;frontdir.y &gt; 0.0f &amp;&amp; maneuverSubState == 1) || speedf &lt; 0.2f)
+				maneuver = 0;
+			break;
 		}
-		if (owner-&gt;frontdir.y &lt; -0.7f)
-			maneuverSubState = 1;
-		if (maneuverSubState == 1 || owner-&gt;updir.y &lt; 0)
-			elevator = 1;
-		UpdateAirPhysics(0, aileron, elevator, 1, owner-&gt;frontdir);
 
-		if ((owner-&gt;updir.y &gt; 0 &amp;&amp; owner-&gt;frontdir.y &gt; 0 &amp;&amp; maneuverSubState == 1) || speedf &lt; 0.2f)
+		default:
+			UpdateAirPhysics(0, 0, 0, 1, owner-&gt;frontdir);
 			maneuver = 0;
-		break;}
-	default:
-		UpdateAirPhysics(0, 0, 0, 1, owner-&gt;frontdir);
-		maneuver = 0;
-		break;
+			break;
 	}
 }
 
@@ -485,7 +509,7 @@
 	float3 &amp;speed = owner-&gt;speed;
 
 	float speedf = owner-&gt;speed.Length();
-	if (speedf &lt; 0.01f){
+	if (speedf &lt; 0.01f) {
 		UpdateAirPhysics(0, 0, 0, 1, owner-&gt;frontdir);
 		return;
 	}
@@ -516,18 +540,25 @@
 	goalPos = tgp;
 
 	float goalLength = (goalPos - pos).Length();
-	float3 goalDir = (goalPos - pos) / goalLength;
+	float3 goalDir =
+		(goalLength &gt; 0.0f)?
+		(goalPos - pos) / goalLength:
+		ZeroVector;
 
 	float aileron = 0;
 	float rudder = 0;
 	float elevator = 0;
 	float engine = 0;
-
 	float gHeight = ground-&gt;GetHeight(pos.x, pos.z);
 
-	float goalDot = rightdir.dot(goalDir);
-	goalDot /= goalDir.dot(frontdir) * 0.5f + 0.501f;
+	float goalDotRight = rightdir.dot(goalDir);
+	float goalDotFront = goalDir.dot(frontdir) * 0.5f + 0.501f;
 
+	if (goalDotFront != 0.0f) {
+		goalDotRight /= goalDotFront;
+	}
+
+
 	if (goalDir.dot(frontdir) &lt; -0.2f + inefficientAttackTime * 0.002f &amp;&amp; frontdir.y &gt; -0.2f &amp;&amp; speedf &gt; 2.0f &amp;&amp; gs-&gt;randFloat() &gt; 0.996f)
 		maneuver = 1;
 
@@ -536,38 +567,46 @@
 		maneuverSubState = 0;
 	}
 
-	//roll
+	// roll
 	if (speedf &gt; 0.45f &amp;&amp; pos.y + owner-&gt;speed.y * 60 * fabs(frontdir.y) + std::min(0.0f, float(updir.y)) * 150 &gt; gHeight + 60 + fabs(rightdir.y) * 150) {
-		float goalBankDif = goalDot + rightdir.y * 0.2f;
-		if (goalBankDif &gt; maxAileron * speedf * 4) {
+		float goalBankDif = goalDotRight + rightdir.y * 0.2f;
+		if (goalBankDif &gt; maxAileron * speedf * 4.0f) {
 			aileron = 1;
-		} else if(goalBankDif &lt; -maxAileron * speedf * 4) {
+		} else if (goalBankDif &lt; -maxAileron * speedf * 4.0f) {
 			aileron = -1;
 		} else {
-			aileron = goalBankDif / (maxAileron * speedf * 4);
+			aileron = goalBankDif / (maxAileron * speedf * 4.0f);
 		}
 	} else {
-		if (rightdir.y &gt; 0) {
-			if (rightdir.y &gt; maxAileron * speedf || frontdir.y &lt; -0.7f)
+		if (rightdir.y &gt; 0.0f) {
+			if (rightdir.y &gt; maxAileron * speedf || frontdir.y &lt; -0.7f) {
 				aileron = 1;
-			else
-				aileron = rightdir.y / (maxAileron * speedf);
+			} else {
+				if (speedf &gt; 0.0f) {
+					aileron = rightdir.y / (maxAileron * speedf);
+				}
+			}
 		} else {
-			if (rightdir.y &lt; -maxAileron * speedf || frontdir.y &lt; -0.7f)
+			if (rightdir.y &lt; -maxAileron * speedf || frontdir.y &lt; -0.7f) {
 				aileron = -1;
-			else
-				aileron = rightdir.y / (maxAileron * speedf);
+			} else {
+				if (speedf &gt; 0.0f) {
+					aileron = rightdir.y / (maxAileron * speedf);
+				}
+			}
 		}
 	}
 
-	//yaw
+	// yaw
 	if (pos.y &gt; gHeight + 30) {
-		if (goalDot &lt; -maxRudder * speedf) {
+		if (goalDotRight &lt; -maxRudder * speedf) {
 			rudder = -1;
-		} else if (goalDot &gt; maxRudder * speedf) {
+		} else if (goalDotRight &gt; maxRudder * speedf) {
 			rudder = 1;
 		} else {
-			rudder = goalDot / (maxRudder * speedf);
+			if (speedf &gt; 0.0f) {
+				rudder = goalDotRight / (maxRudder * speedf);
+			}
 		}
 	}
 
@@ -575,17 +614,17 @@
 	if (updir.y &lt; -0.3f)
 		upside = -1;
 
-	//pitch
+	// pitch
 	if (speedf &lt; 1.5f) {
 		if (frontdir.y &lt; 0.0f) {
-			elevator=upside;
-		} else if(frontdir.y &gt; 0.0f) {
-			elevator=-upside;
+			elevator = upside;
+		} else if (frontdir.y &gt; 0.0f) {
+			elevator = -upside;
 		}
 	} else {
 		float gHeight2 = ground-&gt;GetHeight(pos.x + speed.x * 40, pos.z + speed.z * 40);
 		float hdif = std::max(gHeight, gHeight2) + 60 - pos.y - frontdir.y * speedf * 20;
-		float minPitch;//=min(1.0f,hdif/(maxElevator*speedf*speedf*20));
+		float minPitch = 1.0f; // min(1.0f, hdif / (maxElevator * speedf * speedf * 20));
 
 		if (hdif &lt; -(maxElevator * speedf * speedf * 20)) {
 			minPitch = -1;
@@ -594,21 +633,17 @@
 		} else {
 			minPitch = hdif / (maxElevator * speedf * speedf * 20);
 		}
-
-/*		if(pos.y+min(0,owner-&gt;speed.y)*70*fabs(frontdir.y)+min(0,updir.y)*50&lt;gHeight+50){
-		if(frontdir.y&lt;0.5f){
-			elevator=upside;
-		} else if(frontdir.y&gt;0.55f){
-			elevator=-upside;
-		}*/
 //	} else {
-		if(lastColWarning &amp;&amp; lastColWarningType == 2 &amp;&amp; frontdir.dot(lastColWarning-&gt;pos + lastColWarning-&gt;speed * 20 - pos-owner-&gt;speed * 20) &lt; 0) {
-/*			float pitchMod=updir.y&gt;0?1:-1;
-			if(lastColWarning-&gt;pos.y&gt;pos.y)
-				elevator=-pitchMod;
+		if (lastColWarning &amp;&amp; lastColWarningType == 2 &amp;&amp; frontdir.dot(lastColWarning-&gt;pos + lastColWarning-&gt;speed * 20 - pos-owner-&gt;speed * 20) &lt; 0) {
+			/*
+			float pitchMod = (updir.y &gt; 0.0f)? 1: -1;
+			if (lastColWarning-&gt;pos.y &gt; pos.y)
+				elevator = -pitchMod;
 			else
-				elevator=pitchMod;
-/*/			elevator = updir.dot(lastColWarning-&gt;midPos - owner-&gt;midPos) &gt; 0 ? -1 : 1;/**/
+				elevator = pitchMod;
+			*/
+
+			elevator = (updir.dot(lastColWarning-&gt;midPos - owner-&gt;midPos) &gt; 0.0f)? -1 : 1;
 		} else {
 			float hdif = goalDir.dot(updir);
 			if (hdif &lt; -maxElevator * speedf) {
@@ -654,8 +689,13 @@
 	float3&amp; speed = owner-&gt;speed;
 
 	float speedf = speed.Length();
-	float goalLength = (goalPos - pos).Length2D() + 0.01f;
-	float3 goalDir = (goalPos - pos) / goalLength;
+	float goalLength = (goalPos - pos).Length2D();
+
+	float3 goalDir =
+		(goalLength &gt; 0.0f)?
+		((goalPos - pos) / goalLength).Normalize():
+		ZeroVector;
+
 	float3 adjustedGoalDir = float3(goalPos.x, 0, goalPos.z) - float3(pos.x, 0, pos.z);
 	goalDir.Normalize();
 	adjustedGoalDir.Normalize();
@@ -663,48 +703,61 @@
 	float aileron = 0.0f;
 	float rudder = 0.0f;
 	float elevator = 0.0f;
-
 	float gHeight = ground-&gt;GetHeight(pos.x, pos.z);
 
 	if (!((gs-&gt;frameNum + owner-&gt;id) &amp; 3))
 		CheckForCollision();
 
-	float otherThreat = 0;
+	float otherThreat = 0.0f;
 	float3 otherDir;
 	if (lastColWarning) {
 		float3 otherDif = lastColWarning-&gt;pos - pos;
-		float otherLength = otherDif.Length() + 0.01f;
-		otherDir = otherDif / (otherLength);
-		otherThreat = std::max(1200.0f, goalLength) / otherLength * 0.036f;
+		float otherLength = otherDif.Length();
+
+		otherDir =
+			(otherLength &gt; 0.0f)?
+			(otherDif / otherLength):
+			ZeroVector;
+		otherThreat =
+			(otherLength &gt; 0.0f)?
+			std::max(1200.0f, goalLength) / otherLength * 0.036f:
+			0.0f;
 	}
 
-	float goalDot = rightdir.dot(adjustedGoalDir);
-	goalDot /= adjustedGoalDir.dot(frontdir) * 0.5f + 0.501f;
+	float goalDotRight = rightdir.dot(adjustedGoalDir);
+	float goalDotFront = adjustedGoalDir.dot(frontdir) * 0.5f + 0.501f;
+
+	if (goalDotFront != 0.0f) {
+		goalDotRight /= goalDotFront;
+	}
+
+
 	if (adjustedGoalDir.dot(frontdir) &lt; -0.1f &amp;&amp; goalLength &lt; turnRadius
 #ifdef DIRECT_CONTROL_ALLOWED
 		&amp;&amp; (!owner-&gt;directControl || owner-&gt;directControl-&gt;mouse2)
 #endif
 		)
-		goalDot =- goalDot;
+		goalDotRight = -goalDotRight;
 	if (lastColWarning) {
-		goalDot -= otherDir.dot(rightdir) * otherThreat;
+		goalDotRight -= otherDir.dot(rightdir) * otherThreat;
 	}
 
 	// roll
 	if (speedf &gt; 1.5f &amp;&amp; pos.y + speed.y * 10 &gt; gHeight + wantedHeight * 0.6f) {
-		float goalBankDif = goalDot + rightdir.y * 0.5f;
+		float goalBankDif = goalDotRight + rightdir.y * 0.5f;
 		if (goalBankDif &gt; maxAileron*speedf * 4 &amp;&amp; rightdir.y &gt; -maxBank) {
 			aileron = 1;
 		} else if (goalBankDif &lt; -maxAileron * speedf * 4 &amp;&amp; rightdir.y &lt; maxBank) {
 			aileron = -1;
 		} else {
-			if (fabs(rightdir.y) &lt; maxBank)
+			if (fabs(rightdir.y) &lt; maxBank) {
 				aileron = goalBankDif / (maxAileron * speedf * 4);
-			else {
-				if (rightdir.y &lt; 0 &amp;&amp; goalBankDif &lt; 0)
+			} else {
+				if (rightdir.y &lt; 0.0f &amp;&amp; goalBankDif &lt; 0.0f) {
 					aileron = -1;
-				else if (rightdir.y &gt; 0 &amp;&amp; goalBankDif &gt; 0)
+				} else if (rightdir.y &gt; 0.0f &amp;&amp; goalBankDif &gt; 0.0f) {
 					aileron = 1;
+				}
 			}
 		}
 	} else {
@@ -717,13 +770,13 @@
 
 	// yaw
 	if (pos.y &gt; gHeight + 15) {
-		if (goalDot &lt; -maxRudder * speedf * 2) {
+		if (goalDotRight &lt; -maxRudder * speedf * 2) {
 			rudder = -1;
-		} else if (goalDot &gt; maxRudder * speedf * 2) {
+		} else if (goalDotRight &gt; maxRudder * speedf * 2) {
 			rudder = 1;
 		} else {
-			if (speedf &gt; 0.0f) {
-				rudder = goalDot / (maxRudder * speedf * 2);
+			if (speedf &gt; 0.0f &amp;&amp; maxRudder &gt; 0.0f) {
+				rudder = goalDotRight / (maxRudder * speedf * 2);
 			} else {
 				rudder = 0;
 			}
@@ -769,11 +822,11 @@
 
 void CAirMoveType::UpdateLanded(void)
 {
-	float3 &amp;pos = owner-&gt;pos;
-	SyncedFloat3 &amp;rightdir = owner-&gt;rightdir;
-	SyncedFloat3 &amp;frontdir = owner-&gt;frontdir;
-	SyncedFloat3 &amp;updir = owner-&gt;updir;
-	float3 &amp;speed = owner-&gt;speed;
+	float3&amp; pos = owner-&gt;pos;
+	SyncedFloat3&amp; rightdir = owner-&gt;rightdir;
+	SyncedFloat3&amp; frontdir = owner-&gt;frontdir;
+	SyncedFloat3&amp; updir = owner-&gt;updir;
+	float3&amp; speed = owner-&gt;speed;
 
 	speed = ZeroVector;
 
@@ -788,8 +841,8 @@
 
 void CAirMoveType::UpdateTakeOff(float wantedHeight)
 {
-	float3&amp; pos=owner-&gt;pos;
-	float3&amp; speed=owner-&gt;speed;
+	float3&amp; pos = owner-&gt;pos;
+	float3&amp; speed = owner-&gt;speed;
 
 	float h = 0.0f;
 	if (owner-&gt;unitDef-&gt;canSubmerge)
@@ -824,18 +877,18 @@
 
 void CAirMoveType::UpdateLanding(void)
 {
-	float3 &amp;pos = owner-&gt;pos;
-	SyncedFloat3 &amp;rightdir = owner-&gt;rightdir;
-	SyncedFloat3 &amp;frontdir = owner-&gt;frontdir;
-	SyncedFloat3 &amp;updir = owner-&gt;updir;
-	float3 &amp;speed = owner-&gt;speed;
+	float3&amp; pos = owner-&gt;pos;
+	SyncedFloat3&amp; rightdir = owner-&gt;rightdir;
+	SyncedFloat3&amp; frontdir = owner-&gt;frontdir;
+	SyncedFloat3&amp; updir = owner-&gt;updir;
+	float3&amp; speed = owner-&gt;speed;
 	float speedf = speed.Length();
 
 	// find a landing spot if we dont have one
-	if (reservedLandingPos.x &lt; 0) {
+	if (reservedLandingPos.x &lt; 0.0f) {
 		reservedLandingPos = FindLandingPos();
 
-		if (reservedLandingPos.x &gt; 0) {
+		if (reservedLandingPos.x &gt; 0.0f) {
 			reservedLandingPos.y += wantedHeight;
 			float3 tp = pos;
 			pos = reservedLandingPos;
@@ -874,22 +927,25 @@
 	// update our speed
 	float3 dif = reservedLandingPos - pos;
 	float dist = dif.Length();
+	float landingSpeed =
+		(speedf &gt; 0.0f &amp;&amp; maxAcc &gt; 0.0f)?
+		(dist / speedf * 1.8f * maxAcc):
+		0.0f;
+	float wsf = std::min(owner-&gt;maxSpeed, landingSpeed);
 
 	if (dist &gt; 0.0f) {
 		dif /= dist;
 	}
 
-	float wsf = std::min(owner-&gt;maxSpeed, dist / speedf * 1.8f * maxAcc);
 	float3 wantedSpeed = dif * wsf;
-
 	float3 delta = wantedSpeed - speed;
 	float dl = delta.Length();
 
-	if (dl &lt; maxAcc * 3) {
+	if (dl &lt; maxAcc * 3.0f) {
 		speed = wantedSpeed;
 	} else {
-		if (dl &gt; 0.0f) {
-			speed += delta / dl * maxAcc * 3;
+		if (dl &gt; 0.0f &amp;&amp; maxAcc &gt; 0.0f) {
+			speed += delta / dl * maxAcc * 3.0f;
 		}
 	}
 
@@ -919,7 +975,7 @@
 	owner-&gt;UpdateMidPos();
 
 	// see if we are at the reserved (not user-clicked) landing spot
-	if (dist &lt; 1) {
+	if (dist &lt; 1.0f) {
 		float gh = ground-&gt;GetHeight(pos.x, pos.z);
 		float gah = ground-&gt;GetApproximateHeight(pos.x, pos.z);
 		float alt = 0.0f;
@@ -928,13 +984,12 @@
 		if ((owner-&gt;unitDef-&gt;canSubmerge) &amp;&amp; (gah &lt; 0)) {
 			alt = pos.y - gah;
 			reservedLandingPos.y = gah;
-		}
-		else {
+		} else {
 			alt = pos.y - gh;
 			reservedLandingPos.y = gh;
 		}
 
-		if (alt &lt;= 1) {
+		if (alt &lt;= 1.0f) {
 			SetState(AIRCRAFT_LANDED);
 		}
 	}
@@ -944,11 +999,11 @@
 
 void CAirMoveType::UpdateAirPhysics(float rudder, float aileron, float elevator, float engine, const float3&amp; engineVector)
 {
-	float3 &amp;pos = owner-&gt;pos;
-	SyncedFloat3 &amp;rightdir = owner-&gt;rightdir;
-	SyncedFloat3 &amp;frontdir = owner-&gt;frontdir;
-	SyncedFloat3 &amp;updir = owner-&gt;updir;
-	float3 &amp;speed = owner-&gt;speed;
+	float3&amp; pos = owner-&gt;pos;
+	SyncedFloat3&amp; rightdir = owner-&gt;rightdir;
+	SyncedFloat3&amp; frontdir = owner-&gt;frontdir;
+	SyncedFloat3&amp; updir = owner-&gt;updir;
+	float3&amp; speed = owner-&gt;speed;
 	bool nextPosInBounds = true;
 
 	lastRudderPos = rudder;
@@ -957,7 +1012,7 @@
 
 	float speedf = speed.Length();
 	float3 speeddir = frontdir;
-	if (speedf != 0)
+	if (speedf != 0.0f)
 		speeddir = speed / speedf;
 
 	float gHeight = ground-&gt;GetHeight(pos.x, pos.z);
@@ -975,10 +1030,10 @@
 
 	speed += engineVector * maxAcc * engine;
 	speed.y += mapInfo-&gt;map.gravity * myGravity;
+
 	if (aircraftState == AIRCRAFT_CRASHING) {
 		speed *= crashDrag;
-	}
-	else {
+	} else {
 		speed *= invDrag;
 	}
 
@@ -1008,8 +1063,10 @@
 					damage += impactSpeed * impactSpeed * 1000;
 				if (updir.dot(gNormal) &lt; 0.95f)
 					damage += (1 - (updir.dot(gNormal))) * 1000;
-				if (damage &gt; 0)
-					owner-&gt;DoDamage(DamageArray() * (damage * 0.4f), 0, ZeroVector);	//only do damage while stunned for now
+				if (damage &gt; 0) {
+					// only do damage while stunned for now
+					owner-&gt;DoDamage(DamageArray() * (damage * 0.4f), 0, ZeroVector);
+				}
 			}
 			pos.y = gHeight + owner-&gt;model-&gt;radius * 0.2f + 0.01f;
 			speed += gNormal * (impactSpeed * 1.5f);
@@ -1027,9 +1084,9 @@
 	owner-&gt;UpdateMidPos();
 
 #ifdef DEBUG_AIRCRAFT
-	if(selectedUnits.selectedUnits.find(this)!=selectedUnits.selectedUnits.end()){
-		logOutput.Print(&quot;UpdataAP %.1f %.1f %.1f %.1f&quot;,speedf,pos.x,pos.y,pos.z);
-//		logOutput.Print(&quot;Rudders %.1f %.1f %.1f %.1f&quot;,rudder,aileron,elevator,engine);
+	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
+		logOutput.Print(&quot;UpdataAP %.1f %.1f %.1f %.1f&quot;, speedf, pos.x, pos.y, pos.z);
+		// logOutput.Print(&quot;Rudders %.1f %.1f %.1f %.1f&quot;, rudder, aileron, elevator, engine);
 	}
 #endif
 }
@@ -1038,14 +1095,18 @@
 
 void CAirMoveType::SetState(AAirMoveType::AircraftState state)
 {
+	// this state is only used by CTAAirMoveType
 	assert(state != AIRCRAFT_HOVERING);
+
 	if (aircraftState == AIRCRAFT_CRASHING || state == aircraftState)
 		return;
 
-/*	if (state == AIRCRAFT_LANDING)
+	/*
+	if (state == AIRCRAFT_LANDING)
 		owner-&gt;cob-&gt;Call(COBFN_Deactivate);
-		else if (state == aircraft_flying)
-		//cob-&gt;Call(COBFN_Activate); */
+	else if (state == aircraft_flying)
+		// cob-&gt;Call(COBFN_Activate);
+	*/
 
 	if (state == AIRCRAFT_FLYING) {
 		owner-&gt;Activate();
@@ -1059,7 +1120,7 @@
 	} else {
 		owner-&gt;physicalState = CSolidObject::Flying;
 		owner-&gt;useAirLos = true;
-		if(state != AIRCRAFT_LANDING) {
+		if (state != AIRCRAFT_LANDING) {
 			reservedLandingPos.x = -1;
 			owner-&gt;UnBlock();
 		}
@@ -1070,11 +1131,12 @@
 	}
 	subState = 0;
 
-	//make sure we only go into takeoff if actually landed
-	if (state != AIRCRAFT_TAKEOFF || aircraftState == AIRCRAFT_LANDED)
+	// make sure we only go into takeoff if actually landed
+	if (state != AIRCRAFT_TAKEOFF || aircraftState == AIRCRAFT_LANDED) {
 		aircraftState = state;
-	else
+	} else {
 		aircraftState = AIRCRAFT_TAKEOFF;
+	}
 }
 
 
@@ -1148,10 +1210,14 @@
 		if (forwardDif.SqLength() &lt; dist * dist) {
 			float frontLength = forwardDif.Length();
 			float3 ortoDif = dif - forwardDif;
-			//note that the radiuses is multiplied by two since we rely on
-			//the aircrafts having to small radiuses (see unitloader)
-			
+
+			// note that the radii are multiplied by two since we rely on
+			// aircraft having half-size hitspheres (see unitloader)
+			//
 			// FIXME: with the new collision volumes, is this still true?
+			//
+			// yes: for backward compatibility, aircraft that do not define
+			// their own custom volumes get halved hitspheres by default
 
 			float minOrtoDif = ((*ui)-&gt;radius + owner-&gt;radius) * 2 + frontLength * 0.1f + 10;
 			if (ortoDif.SqLength() &lt; minOrtoDif * minOrtoDif) {
@@ -1183,7 +1249,7 @@
 
 void CAirMoveType::DependentDied(CObject* o)
 {
-	if(o == lastColWarning){
+	if (o == lastColWarning) {
 		lastColWarning = 0;
 		lastColWarningType = 0;
 	}
@@ -1195,10 +1261,10 @@
 void CAirMoveType::SetMaxSpeed(float speed)
 {
 	maxSpeed = speed;
-	if (maxAcc != 0 &amp;&amp; maxSpeed != 0) {
-		//meant to set the drag such that the maxspeed becomes what it should be
+	if (maxAcc != 0.0f &amp;&amp; maxSpeed != 0.0f) {
+		// meant to set the drag such that the maxspeed becomes what it should be
 		float drag = 1.0f / (maxSpeed / GAME_SPEED * 1.1f / maxAcc) - wingAngle * wingAngle * wingDrag;
-		invDrag = 1 - drag;
+		invDrag = 1.0f - drag;
 	}
 }
 
@@ -1212,6 +1278,7 @@
 
 void CAirMoveType::StartMoving(float3 gpos, float goalRadius)
 {
+	SetWantedMaxSpeed(owner-&gt;maxSpeed);
 	SetGoal(gpos);
 }
 
@@ -1228,10 +1295,10 @@
 void CAirMoveType::StopMoving()
 {
 	SetGoal(owner-&gt;pos);
+	SetWantedMaxSpeed(0.0);
 
-	if ((aircraftState == AAirMoveType::AIRCRAFT_FLYING) &amp;&amp;
-		!owner-&gt;unitDef-&gt;DontLand() &amp;&amp; autoLand) {
-		SetState(AAirMoveType::AIRCRAFT_LANDING);
+	if ((aircraftState == AAirMoveType::AIRCRAFT_FLYING) &amp;&amp; !owner-&gt;unitDef-&gt;DontLand() &amp;&amp; autoLand) {
+		SetState(AIRCRAFT_LANDING);
 	}
 }
 
@@ -1239,12 +1306,16 @@
 
 void CAirMoveType::Takeoff()
 {
-	if (aircraftState == AAirMoveType::AIRCRAFT_LANDED) {
-		SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
+	if (aircraftState != AAirMoveType::AIRCRAFT_FLYING) {
+		if ((owner-&gt;currentFuel &gt; 0.0f) || owner-&gt;unitDef-&gt;maxFuel &lt;= 0.0f) {
+			if (aircraftState == AAirMoveType::AIRCRAFT_LANDED) {
+				SetState(AAirMoveType::AIRCRAFT_TAKEOFF);
+			}
+			if (aircraftState == AAirMoveType::AIRCRAFT_LANDING) {
+				SetState(AAirMoveType::AIRCRAFT_FLYING);
+			}
+		}
 	}
-	if (aircraftState == AAirMoveType::AIRCRAFT_LANDING) {
-		SetState(AAirMoveType::AIRCRAFT_FLYING);
-	}
 }
 
 

Modified: branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -67,6 +67,7 @@
 	wantToStop(false),
 	forceHeading(false),
 	dontCheckCol(false),
+	bankingAllowed(true),
 	dontLand(false),
 	lastMoveRate(0),
 	waitCounter(0),
@@ -547,14 +548,17 @@
 {
 	SyncedFloat3 &amp;frontdir = owner-&gt;frontdir;
 	SyncedFloat3 &amp;updir = owner-&gt;updir;
-	float wantedPitch = 0;
 
-	if (aircraftState == AIRCRAFT_FLYING &amp;&amp; flyState == FLY_ATTACKING &amp;&amp; circlingPos.y &lt; owner-&gt;pos.y) {
-		wantedPitch = (circlingPos.y - owner-&gt;pos.y) / circlingPos.distance(owner-&gt;pos);
+	if (!owner-&gt;upright) {
+		float wantedPitch = 0;
+
+		if (aircraftState == AIRCRAFT_FLYING &amp;&amp; flyState == FLY_ATTACKING &amp;&amp; circlingPos.y &lt; owner-&gt;pos.y) {
+			wantedPitch = (circlingPos.y - owner-&gt;pos.y) / circlingPos.distance(owner-&gt;pos);
+		}
+
+		currentPitch = currentPitch * 0.95f + wantedPitch * 0.05f;
 	}
 
-	currentPitch = currentPitch * 0.95f + wantedPitch * 0.05f;
-
 	frontdir = GetVectorFromHeading(owner-&gt;heading);
 	frontdir.y = currentPitch;
 	frontdir.Normalize();
@@ -563,7 +567,7 @@
 	rightdir.Normalize();
 
 	float wantedBank = 0.0f;
-	if (!noBanking) wantedBank = rightdir.dot(deltaSpeed)/accRate*0.5f;
+	if (!noBanking &amp;&amp; bankingAllowed) wantedBank = rightdir.dot(deltaSpeed)/accRate*0.5f;
 
 	float limit = std::min(1.0f,goalPos.distance2D(owner-&gt;pos)*0.15f);
 	if(wantedBank&gt;limit)
@@ -891,7 +895,7 @@
 	if (aircraftState != AIRCRAFT_LANDED &amp;&amp; owner-&gt;unitDef-&gt;maxFuel &gt; 0)
 		owner-&gt;currentFuel = std::max(0.f, owner-&gt;currentFuel - (16.f / GAME_SPEED));
 
-	if (!reservedPad &amp;&amp; aircraftState == AIRCRAFT_FLYING 
+	if (!reservedPad &amp;&amp; aircraftState == AIRCRAFT_FLYING
 			&amp;&amp; owner-&gt;health &lt; owner-&gt;maxHealth * repairBelowHealth) {
 		CAirBaseHandler::LandingPad* lp = airBaseHandler-&gt;FindAirBase(
 				owner, owner-&gt;unitDef-&gt;minAirBasePower);

Modified: branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -18,14 +18,15 @@
 	//needed to get transport close enough to what is going to be transported.
 	//better way ?
 	bool dontCheckCol;
+	bool bankingAllowed;
 
 	float orgWantedHeight;	//to reset altitude back
-	
+
 	float3 circlingPos;
 	float goalDistance;			//Used when circling something
 	int waitCounter;			//need to pause between circling steps
 	bool wantToStop;			//Set to true on StopMove, to be able to not stop if a new order comes directly after
-	
+
 	//Seems odd to use heading in unit, since we have toggled useHeading to false..
 	short wantedHeading;
 
@@ -56,7 +57,7 @@
 	CTAAirMoveType(CUnit* owner);
 	~CTAAirMoveType(void);
 
-	//MoveType interface	
+	//MoveType interface
 	virtual void Update();
 	virtual void SlowUpdate();
 	virtual void StartMoving(float3 pos, float goalRadius);
@@ -78,7 +79,7 @@
 	void UpdateBanking(bool noBanking);
 	void UpdateAirPhysics();
 	void UpdateMoveRate();
-	
+
 	void SetGoal(float3 newPos, float distance);
 	void SetState(AircraftState newState);
 
@@ -88,7 +89,7 @@
 	void SetWantedAltitude(float altitude);
 	void CheckForCollision(void);
 	void DependentDied(CObject* o);
-	
+
 	void Takeoff();
 	bool IsFighter();
 };

Modified: branches/caiinterface/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Path/PathEstimator.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Path/PathEstimator.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -20,13 +20,6 @@
 #include &quot;FileSystem/ArchiveZip.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 
-#ifdef USE_GML
-#include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-extern boost::mutex selmutex;
-#	endif
-#endif
-
 #define PATHDEBUG false
 
 
@@ -918,9 +911,7 @@
 
 void CPathEstimator::Draw(void)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-					boost::mutex::scoped_lock sellock(selmutex);
-#endif
+//	GML_RECMUTEX_LOCK(sel); // Draw
 	MoveData* md = moveinfo-&gt;GetMoveDataFromName(&quot;TANKSH2&quot;);
 	if (!selectedUnits.selectedUnits.empty() &amp;&amp; (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata)
 		md = (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata;

Modified: branches/caiinterface/rts/Sim/Path/PathManager.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Path/PathManager.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Path/PathManager.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -460,9 +460,11 @@
 		path-&gt;peDef-&gt;Draw();
 	}
 	glLineWidth(1);
+#if !defined(USE_GML) || !GML_ENABLE_SIMDRAW // making this threadsafe might be too costly performance wise
 	pf-&gt;Draw();
 	pe-&gt;Draw();
 	pe2-&gt;Draw();
+#endif
 }
 
 

Modified: branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -40,14 +40,6 @@
 #include &quot;System/creg/STL_List.h&quot;
 #include &quot;System/Exceptions.h&quot;
 
-#ifdef USE_GML
-#	include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex projmutex;
-#	endif
-#endif
-
 CProjectileHandler* ph;
 
 using namespace std;
@@ -407,9 +399,7 @@
 
 void CProjectileHandler::Update()
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // Update
 
 	SCOPED_TIMER(&quot;Projectile handler&quot;);
 
@@ -493,9 +483,7 @@
 	/* 3DO */
 	unitDrawer-&gt;SetupForUnitDrawing();
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // Draw
 
 	va-&gt;Initialize();
 	va-&gt;EnlargeArrays(flying3doPieces-&gt;size()*4,0,VA_SIZE_TN);
@@ -680,9 +668,7 @@
 	glEnable( GL_VERTEX_PROGRAM_ARB );
 	glDisable(GL_TEXTURE_2D);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // DrawShadowPass
 
 	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		if ((gu-&gt;spectatingFullView || loshandler-&gt;InLos(*psi, gu-&gt;myAllyTeam) ||
@@ -725,9 +711,7 @@
 
 void CProjectileHandler::AddProjectile(CProjectile* p)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // AddProjectile
 
 	ps.push_back(p);
 
@@ -840,6 +824,7 @@
 
 void CProjectileHandler::AddGroundFlash(CGroundFlash* flash)
 {
+	GML_RECMUTEX_LOCK(proj); // AddGroundFlash
 	groundFlashes.push_back(flash);
 }
 
@@ -860,14 +845,20 @@
 
 	CGroundFlash::va=GetVertexArray();
 	CGroundFlash::va-&gt;Initialize();
-	CGroundFlash::va-&gt;EnlargeArrays(8*groundFlashes.size(),0,VA_SIZE_TC);
 
-	vector&lt;CGroundFlash*&gt;::iterator gfi;
-	for(gfi=groundFlashes.begin();gfi!=groundFlashes.end();++gfi){
-		if ((*gfi)-&gt;alwaysVisible || gu-&gt;spectatingFullView ||
-		    loshandler-&gt;InAirLos((*gfi)-&gt;pos,gu-&gt;myAllyTeam))
-			(*gfi)-&gt;Draw();
+	{
+		GML_RECMUTEX_LOCK(proj); // DrawGroundFlashes
+
+		CGroundFlash::va-&gt;EnlargeArrays(8*groundFlashes.size(),0,VA_SIZE_TC);
+
+		vector&lt;CGroundFlash*&gt;::iterator gfi;
+		for(gfi=groundFlashes.begin();gfi!=groundFlashes.end();++gfi){
+			if ((*gfi)-&gt;alwaysVisible || gu-&gt;spectatingFullView ||
+				loshandler-&gt;InAirLos((*gfi)-&gt;pos,gu-&gt;myAllyTeam))
+				(*gfi)-&gt;Draw();
+		}
 	}
+
 	CGroundFlash::va-&gt;DrawArrayTC(GL_QUADS);
 
 	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
@@ -905,9 +896,7 @@
 	fp-&gt;rotSpeed=gu-&gt;usRandFloat()*0.1f;
 	fp-&gt;rot=0;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // AddFlyingPiece
 
 	flying3doPieces-&gt;push_back(fp);
 }
@@ -915,9 +904,7 @@
 void CProjectileHandler::AddFlyingPiece(int textureType, int team, float3 pos, float3 speed, SS3OVertex * verts){
 	FlyingPiece_List * pieceList = NULL;
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock projlock(projmutex);
-#endif
+	GML_RECMUTEX_LOCK(proj); // AddFlyingPiece
 
 	while(flyings3oPieces.size()&lt;=textureType)
 		flyings3oPieces.push_back(vector&lt;FlyingPiece_List*&gt;());

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -19,6 +19,8 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;Rendering/UnitModels/s3oParser.h&quot;
+#include &quot;Rendering/UnitModels/3DOParser.h&quot;
 
 static const float Smoke_Time=60;
 
@@ -447,7 +449,7 @@
 	CMatrix44f transMatrix(interPos + dir * radius * 0.9f,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
-	glCallList(modelDispList);
+	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
 
 	glPopMatrix();
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -17,6 +17,7 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;StarburstProjectile.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;Rendering/UnitModels/s3oParser.h&quot;
 
 static const float Smoke_Time=70;
 
@@ -410,7 +411,7 @@
 	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
 	glMultMatrixf(&amp;transMatrix[0]);
 
-	glCallList(modelDispList);
+	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
 	glPopMatrix();
 }
 

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -36,7 +36,6 @@
 	CR_MEMBER(targetPos),
 	CR_MEMBER(startpos),
 	CR_MEMBER(ttl),
-	CR_MEMBER(modelDispList),
 	CR_MEMBER(colorTeam),
 	CR_MEMBER(bounces),
 	CR_MEMBER(keepBouncing),
@@ -55,7 +54,6 @@
 	target = 0;
 	ttl = 0;
 	colorTeam = 0;
-	modelDispList = 0;
 	interceptTarget = 0;
 	bounces = 0;
 	keepBouncing = true;
@@ -103,11 +101,6 @@
 			S3DOModel* model = modelParser-&gt;Load3DModel(string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
 			if (model) {
 				s3domodel = model;
-
-				if (s3domodel-&gt;rootobject3do)
-					modelDispList = model-&gt;rootobject3do-&gt;displist;
-				else
-					modelDispList = model-&gt;rootobjects3o-&gt;displist;
 			}
 		}
 		collisionFlags = weaponDef-&gt;collisionFlags;
@@ -314,7 +307,8 @@
 	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
-	glCallList(modelDispList);
+//	glCallList(modelDispList);
+	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
 	glPopMatrix();
 }
 
@@ -349,10 +343,10 @@
 				string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
 		if(model){
 			s3domodel = model;
-			if(s3domodel-&gt;rootobject3do)
+/*			if(s3domodel-&gt;rootobject3do)
 				modelDispList= model-&gt;rootobject3do-&gt;displist;
 			else
-				modelDispList= model-&gt;rootobjects3o-&gt;displist;
+				modelDispList= model-&gt;rootobjects3o-&gt;displist;*/
 		}
 	}
 //	collisionFlags = weaponDef-&gt;collisionFlags;

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -43,7 +43,6 @@
 	float3 startpos;
 	int ttl;
 	int colorTeam;
-	unsigned int modelDispList;
 	int bounces;
 	
 	virtual void UpdateGroundBounce();

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -455,13 +455,14 @@
 			return;
 		}
 	}
+
 	if (inCommand) {
 		if (targetDied || (c.params.size() == 1 &amp;&amp; UpdateTargetLostTimer(int(c.params[0])) == 0)) {
 			FinishCommand();
 			return;
 		}
-		if ((c.params.size() == 3) &amp;&amp; (owner-&gt;commandShotCount &gt; 0) &amp;&amp; (commandQue.size() &gt; 1)) {
-			owner-&gt;AttackUnit(0, true);
+		if ((c.params.size() == 3) &amp;&amp; (owner-&gt;commandShotCount &lt; 0) &amp;&amp; (commandQue.size() &gt; 1)) {
+			owner-&gt;AttackGround(float3(c.params[0], c.params[1], c.params[2]), true);
 			FinishCommand();
 			return;
 		}

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -790,7 +790,7 @@
 	if (c.options &amp; ALT_KEY) {
 		// treat param0 as a position
 		int pos = (int)c.params[0];
-		const int qsize = (int)queue-&gt;size();
+		const unsigned int qsize = queue-&gt;size();
 		if (pos &lt; 0) {
 			pos = qsize + pos + 1; // convert the negative index
 			if (pos &lt; 0) {
@@ -804,7 +804,7 @@
 	}
 	else {
 		// treat param0 as a command tag
-		const int tag = (int)c.params[0];
+		const unsigned int tag = (unsigned int)c.params[0];
 		CCommandQueue::iterator ci;
 		bool found = false;
 		for (ci = queue-&gt;begin(); ci != queue-&gt;end(); ++ci) {
@@ -881,7 +881,7 @@
 
 	// erase commands by a list of command types
 	bool active = false;
-	for (int p = 0; p &lt; (int)c.params.size(); p++) {
+	for (unsigned int p = 0; p &lt; c.params.size(); p++) {
 		const int removeValue = (int)c.params[p]; // tag or id
 
 		if (facBuildQueue &amp;&amp; (removeValue == 0) &amp;&amp; !(c.options &amp; ALT_KEY)) {

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,10 +1,10 @@
 #ifndef __COMMAND_QUEUE_H__
 #define __COMMAND_QUEUE_H__
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;deque&gt;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 
-
 // A wrapper class for  std::deque&lt;Command&gt;  to keep track of commands
 
 
@@ -45,16 +45,18 @@
 
 		inline iterator insert(iterator pos, const Command&amp; cmd);
 
-		inline void pop_back()  { queue.pop_back(); }
-		inline void pop_front() { queue.pop_front(); }
+		inline void pop_back()  { GML_STDMUTEX_LOCK(cai); queue.pop_back(); }
+		inline void pop_front() { GML_STDMUTEX_LOCK(cai); queue.pop_front(); }
 
 		inline iterator erase(iterator pos) {
+			GML_STDMUTEX_LOCK(cai); // Erase
 			return queue.erase(pos);
 		}
 		inline iterator erase(iterator first, iterator last) {
+			GML_STDMUTEX_LOCK(cai); // Erase
 			return queue.erase(first, last);
 		}
-		inline void clear() { queue.clear(); }
+		inline void clear() { GML_STDMUTEX_LOCK(cai); queue.clear(); }
 
 		inline iterator       end()         { return queue.end(); }
 		inline const_iterator end()   const { return queue.end(); }
@@ -105,6 +107,7 @@
 
 inline void CCommandQueue::push_back(const Command&amp; cmd)
 {
+	GML_STDMUTEX_LOCK(cai); // push_back
 	queue.push_back(cmd);
 	queue.back().tag = GetNextTag();
 }
@@ -112,6 +115,7 @@
 
 inline void CCommandQueue::push_front(const Command&amp; cmd)
 {
+	GML_STDMUTEX_LOCK(cai); // push_front
 	queue.push_front(cmd);
 	queue.front().tag = GetNextTag();
 }
@@ -122,6 +126,7 @@
 {
 	Command tmpCmd = cmd;
 	tmpCmd.tag = GetNextTag();
+	GML_STDMUTEX_LOCK(cai); // insert
 	return queue.insert(pos, tmpCmd);
 }
 

Modified: branches/caiinterface/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -307,7 +307,7 @@
 
 	delete cob;
 	//FIXME delete script;
-	delete localmodel;
+	modelParser-&gt;DeleteLocalModel(this);
 }
 
 
@@ -1116,7 +1116,7 @@
 /******************************************************************************/
 /******************************************************************************/
 
-void CUnit::GetTransformMatrix(CMatrix44f&amp; matrix, bool synced) const
+CMatrix44f CUnit::GetTransformMatrix(const bool synced, const bool error) const
 {
 	float3 interPos;
 	if (!transporter) {
@@ -1125,13 +1125,16 @@
 		interPos = (synced? pos: pos + (transporter-&gt;speed * gu-&gt;timeOffset));
 	}
 
+	if (!synced &amp;&amp; error) {
+		interPos += helper-&gt;GetUnitErrorPos(this, gu-&gt;myAllyTeam) - midPos;
+	}
+
 	if (usingScriptMoveType ||
 	    (!beingBuilt &amp;&amp; (physicalState == Flying) &amp;&amp; unitDef-&gt;canmove)) {
 		// aircraft, skidding ground unit, or active ScriptMoveType
 		// note: (CAirMoveType) aircraft under construction should not
 		// use this matrix, or their nanoframes won't spin on pad
-		CMatrix44f transMatrix(interPos, -rightdir, updir, frontdir);
-		matrix = transMatrix;
+		return CMatrix44f(interPos, -rightdir, updir, frontdir);
 	}
 	else if (transporter &amp;&amp; transporter-&gt;unitDef-&gt;holdSteady) {
 		// making local copies of vectors
@@ -1140,13 +1143,11 @@
 		float3 rightDir = frontDir.cross(upDir);
 		rightDir.Normalize();
 		frontDir = upDir.cross(rightDir);
-		CMatrix44f transMatrix(interPos, -rightDir, upDir, frontDir);
-		matrix = transMatrix;
+		return CMatrix44f(interPos, -rightDir, upDir, frontDir);
 	}
 	else if (upright || !unitDef-&gt;canmove) {
 		if (heading == 0) {
-			matrix.LoadIdentity();
-			matrix.Translate(interPos);
+			return CMatrix44f(interPos);
 		} else {
 			// making local copies of vectors
 			float3 frontDir = GetVectorFromHeading(heading);
@@ -1154,8 +1155,7 @@
 			float3 rightDir = frontDir.cross(upDir);
 			rightDir.Normalize();
 			frontDir = upDir.cross(rightDir);
-			CMatrix44f transMatrix(interPos, -rightdir, updir, frontdir);
-			matrix = transMatrix;
+			return CMatrix44f(interPos, -rightdir, updir, frontdir);
 		}
 	}
 	else {
@@ -1165,8 +1165,7 @@
 		float3 rightDir = frontDir.cross(upDir);
 		rightDir.Normalize();
 		frontDir = upDir.cross(rightDir);
-		CMatrix44f transMatrix(interPos, -rightDir, upDir, frontDir);
-		matrix = transMatrix;
+		return CMatrix44f(interPos, -rightDir, upDir, frontDir);
 	}
 }
 
@@ -1358,8 +1357,8 @@
 
 	model = unitDef-&gt;LoadModel(newteam);
 
-	delete localmodel;
-	localmodel = modelParser-&gt;CreateLocalModel(model, &amp;cob-&gt;pieces);
+	modelParser-&gt;DeleteLocalModel(this);
+	modelParser-&gt;CreateLocalModel(this);
 	SetLODCount(0);
 
 	if (unitDef-&gt;isAirBase) {
@@ -2205,7 +2204,7 @@
 	//FIXME script = SAFE_NEW CUnitScript(this);
 	//FIXME localmodel = modelParser-&gt;CreateLocalModel(model, script-&gt;GetPieces());
 	cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + unitDef-&gt;name+&quot;.cob&quot;), this);
-	localmodel = modelParser-&gt;CreateLocalModel(model, &amp;cob-&gt;pieces);
+	modelParser-&gt;CreateLocalModel(this);
 
 	// Calculate the max() of the available weapon reloadtimes
 	int relMax = 0;

Modified: branches/caiinterface/rts/Sim/Units/Unit.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/Unit.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -108,7 +108,7 @@
 	void SetDirectionFromHeading();
 
 	void ApplyTransformMatrix() const;
-	void GetTransformMatrix(CMatrix44f&amp; matrix, bool synced = false) const;
+	CMatrix44f GetTransformMatrix(const bool synced = false, const bool error = false) const;
 
 	void SetLastAttacker(CUnit* attacker);
 	void DependentDied(CObject* o);

Modified: branches/caiinterface/rts/Sim/Units/UnitDef.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitDef.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/UnitDef.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -291,6 +291,7 @@
 	bool airStrafe;
 	float dlHoverFactor; // &lt; 0 means it can land, &gt;= 0 indicates how much the unit will move during hovering on the spot
 	bool DontLand () const { return dlHoverFactor &gt;= 0.0f; }
+	bool bankingAllowed;
 
 	float maxAcc;
 	float maxDec;

Modified: branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -456,6 +456,7 @@
 	ud.hoverAttack   = udTable.GetBool(&quot;hoverAttack&quot;, false);
 	ud.wantedHeight  = udTable.GetFloat(&quot;cruiseAlt&quot;, 0.0f);
 	ud.dlHoverFactor = udTable.GetFloat(&quot;airHoverFactor&quot;, -1.0f);
+	ud.bankingAllowed = udTable.GetBool(&quot;bankingAllowed&quot;, true);
 
 	ud.transportSize     = udTable.GetInt(&quot;transportSize&quot;,      0);
 	ud.minTransportSize  = udTable.GetInt(&quot;minTransportSize&quot;,   0);

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -41,15 +41,6 @@
 using std::min;
 using std::max;
 
-#ifdef USE_GML
-#	include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_MT_TEST
-#include &lt;boost/thread/recursive_mutex.hpp&gt;
-boost::recursive_mutex unitmutex;
-boost::mutex caimutex;
-#	endif
-#endif
-
 BuildInfo::BuildInfo(const std::string&amp; name, const float3&amp; p, int facing)
 {
 	def = unitDefHandler-&gt;GetUnitByName(name);
@@ -194,9 +185,7 @@
 
 int CUnitHandler::AddUnit(CUnit *unit)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	GML_RECMUTEX_LOCK(unit); // AddUnit
 	ASSERT_SYNCED_MODE;
 	int num = (int)(gs-&gt;randFloat()) * ((int)activeUnits.size() - 1);
 	std::list&lt;CUnit*&gt;::iterator ui = activeUnits.begin();
@@ -275,22 +264,19 @@
 	ASSERT_SYNCED_MODE;
 	SCOPED_TIMER(&quot;Unit handler&quot;);
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	{
-		boost::recursive_mutex::scoped_lock unitlock(unitmutex);
-#endif
+	if(!toBeRemoved.empty()) {
+		GML_RECMUTEX_LOCK(unit); // Update. Possibly not needed, activeUnits.erase is synchronized.
+		GML_RECMUTEX_LOCK(quad); // Update. Make sure unit does not get partially deleted before before being removed from the quadfield
+		GML_RECMUTEX_LOCK(sel); // Update. Unit is removed from selectedUnits in ~CObject, which is too late.
 
-	while (!toBeRemoved.empty()) {
-		CUnit* delUnit = toBeRemoved.back();
-		toBeRemoved.pop_back();
+		while (!toBeRemoved.empty()) {
+			CUnit* delUnit = toBeRemoved.back();
+			toBeRemoved.pop_back();
 
-		DeleteUnitNow(delUnit);
+			DeleteUnitNow(delUnit);
+		}
 	}
 
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	}
-#endif
-
 	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = activeUnits.begin(); usi != activeUnits.end(); usi++) {
 		(*usi)-&gt;Update();
@@ -608,18 +594,14 @@
 
 void CUnitHandler::AddBuilderCAI(CBuilderCAI* b)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock cailock(caimutex);
-#endif
+	GML_STDMUTEX_LOCK(cai); // AddBuilderCAI
 	builderCAIs.insert(builderCAIs.end(),b);
 }
 
 
 void CUnitHandler::RemoveBuilderCAI(CBuilderCAI* b)
 {
-#	if defined(USE_GML) &amp;&amp; GML_MT_TEST
-	boost::mutex::scoped_lock cailock(caimutex);
-#endif
+	GML_STDMUTEX_LOCK(cai); // RemoveBuilderCAI
 	ListErase&lt;CBuilderCAI*&gt;(builderCAIs, b);
 }
 
@@ -670,6 +652,7 @@
 Command CUnitHandler::GetBuildCommand(float3 pos, float3 dir){
 	float3 tempF1 = pos;
 	std::list&lt;CUnit*&gt;::iterator ui = this-&gt;activeUnits.begin();
+	GML_STDMUTEX_LOCK(cai); // GetBuildCommand
 	CCommandQueue::iterator ci;
 	for(; ui != this-&gt;activeUnits.end(); ui++){
 		if((*ui)-&gt;team == gu-&gt;myTeam){

Modified: branches/caiinterface/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitLoader.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/Sim/Units/UnitLoader.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -3,6 +3,7 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;mmgr.h&quot;
 
 #include &quot;UnitLoader.h&quot;
@@ -73,6 +74,9 @@
 CUnit* CUnitLoader::LoadUnit(const string&amp; name, float3 pos, int team,
                              bool build, int facing, const CUnit* builder)
 {
+	GML_RECMUTEX_LOCK(unit); // LoadUnit. Unitinit puts unit in the quadfield and activeUnits -
+	GML_RECMUTEX_LOCK(quad); // LoadUnit. - make sure other threads cannot access an incomplete unit
+
 	CUnit* unit;
 
 	SCOPED_TIMER(&quot;Unit loader&quot;);
@@ -257,6 +261,7 @@
 			mt-&gt;dontLand = ud-&gt;DontLand();
 			mt-&gt;collide = ud-&gt;collide;
 			mt-&gt;altitudeRate = ud-&gt;verticalSpeed;
+			mt-&gt;bankingAllowed = ud-&gt;bankingAllowed;
 
 			unit-&gt;moveType = mt;
 		}
@@ -334,7 +339,7 @@
 
 //FIXME: add unitdef tag cob/cobscript/cobfilename
 	unit-&gt;cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + name + &quot;.cob&quot;), unit);
-	unit-&gt;localmodel = modelParser-&gt;CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
+	modelParser-&gt;CreateLocalModel(unit);
 
 
 	for (unsigned int i = 0; i &lt; ud-&gt;weapons.size(); i++) {

Modified: branches/caiinterface/rts/System/AutohostInterface.cpp
===================================================================
--- branches/caiinterface/rts/System/AutohostInterface.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/AutohostInterface.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -38,8 +38,15 @@
  
 	/// Player has updated its ready-state (uchar playernumber, uchar state (0: not ready, 1: ready, 2: state not changed) )
 	PLAYER_READY = 12,
- 
-	/// Player has sent a chat message (uchar playernumber, string text)
+
+	/**
+	@brief Player has sent a chat message (uchar playernumber, uchar destination, string text)
+	Destination can be any of: a playernumber [0-32]
+	static const int TO_ALLIES = 127;
+	static const int TO_SPECTATORS = 126;
+	static const int TO_EVERYONE = 125;
+	(copied from Game/ChatMessage.h)
+	*/
 	PLAYER_CHAT = 13,
  
 	/// Player has been defeated (uchar playernumber)
@@ -104,13 +111,14 @@
 	autohost-&gt;Send(msg, 3);
 }
 
-void AutohostInterface::SendPlayerChat(uchar playerNum, const std::string&amp; chatmsg) const
+void AutohostInterface::SendPlayerChat(uchar playerNum, uchar destination, const std::string&amp; chatmsg) const
 {
-	unsigned msgsize = 2*sizeof(uchar)+chatmsg.size();
+	unsigned msgsize = 3*sizeof(uchar)+chatmsg.size();
 	uchar* msg = new uchar[msgsize];
 	msg[0] = PLAYER_CHAT;
 	msg[1] = playerNum;
-	strncpy((char*)msg+2, chatmsg.c_str(), chatmsg.size());
+	msg[2] = destination;
+	strncpy((char*)msg+3, chatmsg.c_str(), chatmsg.size());
 	autohost-&gt;Send(msg, msgsize);
 	delete[] msg;
 }

Modified: branches/caiinterface/rts/System/AutohostInterface.h
===================================================================
--- branches/caiinterface/rts/System/AutohostInterface.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/AutohostInterface.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -32,7 +32,7 @@
 	void SendPlayerJoined(uchar playerNum, const std::string&amp; name) const;
 	void SendPlayerLeft(uchar playerNum, uchar reason) const;
 	void SendPlayerReady(uchar playerNum, uchar readyState) const;
-	void SendPlayerChat(uchar playerNum, const std::string&amp; msg) const;
+	void SendPlayerChat(uchar playerNum, uchar destination, const std::string&amp; msg) const;
 	void SendPlayerDefeated(uchar playerNum) const;
 	
 	void Message(const std::string&amp; message);

Modified: branches/caiinterface/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/caiinterface/rts/System/BaseNetProtocol.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/BaseNetProtocol.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -265,10 +265,9 @@
 }
 
 // NETMSG_LUAMSG = 50, uchar myPlayerNum; std::string modName; (e.g. `custom msg')
-PacketType CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode,
-                                  const std::string&amp; msg)
+PacketType CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, unsigned short script, uchar mode, const std::string&amp; msg)
 {
-	uint16_t size = 6 + msg.size()+1;
+	uint16_t size = 7 + msg.size()+1;
 	PackPacket* packet = new PackPacket(size, NETMSG_LUAMSG);
 	*packet &lt;&lt; size &lt;&lt; myPlayerNum &lt;&lt; script &lt;&lt; mode &lt;&lt; msg;
 	return PacketType(packet);

Modified: branches/caiinterface/rts/System/BaseNetProtocol.h
===================================================================
--- branches/caiinterface/rts/System/BaseNetProtocol.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/BaseNetProtocol.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -143,7 +143,7 @@
 	PacketType SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z);
 	PacketType SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping);
 	PacketType SendPlayerLeft(uchar myPlayerNum, uchar bIntended);
-	PacketType SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode, const std::string&amp; msg);
+	PacketType SendLuaMsg(uchar myPlayerNum, unsigned short script, uchar mode, const std::string&amp; msg);
 	
 	PacketType SendGiveAwayEverything(uchar myPlayerNum, uchar giveTo);
 	PacketType SendResign(uchar myPlayerNum);

Modified: branches/caiinterface/rts/System/DemoReader.cpp
===================================================================
--- branches/caiinterface/rts/System/DemoReader.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/DemoReader.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -61,6 +61,7 @@
 			temp-&gt;Init(buf, fileHeader.scriptSize);
 			temp-&gt;demoName = filename;
 			temp-&gt;numDemoPlayers = GetFileHeader().maxPlayerNum+1;
+			temp-&gt;maxSpeed = 10;
 			gameSetup = temp;
 		}
 		delete[] buf;

Modified: branches/caiinterface/rts/System/FileSystem/ArchiveScanner.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/ArchiveScanner.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/FileSystem/ArchiveScanner.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -142,7 +142,7 @@
 
 	string name;
 	int size;
-	for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+	for (int cur = 0; (cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size)); /* no-op */) {
 		if (name == &quot;gamedata/parse_tdf.lua&quot;) {
 			const int fh = ar-&gt;OpenFile(name);
 			if (fh != 0) {
@@ -356,7 +356,7 @@
 
 			string name;
 			int size;
-			for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+			for (int cur = 0; (cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size)); /* no-op */) {
 				const string lowerName = StringToLower(name);
 				const string ext = lowerName.substr(lowerName.find_last_of('.') + 1);
 
@@ -526,7 +526,7 @@
 	string name;
 	int size;
 	// Sort all file paths for deterministic behaviour
-	for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+	for (int cur = 0; (cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size)); /* no-op */) {
 		if (ignore-&gt;Match(name)) {
 			continue;
 		}
@@ -803,8 +803,15 @@
 	// add depth-first
 	for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
 		vector&lt;string&gt; dep = GetArchives(*i, depth + 1);
+
 		for (vector&lt;string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
-			ret.push_back(*j);
+			if (std::find(ret.begin(), ret.end(), *j) == ret.end()) {
+				// add only if this dependency is not already somewhere
+				// in the chain (which can happen if ArchiveCacheV* has
+				// not been written yet) so its checksum is not XOR'ed
+				// with the running one multiple times (Get*Checksum())
+				ret.push_back(*j);
+			}
 		}
 	}
 
@@ -900,6 +907,7 @@
 {
 	const vector&lt;string&gt; ars = GetArchives(root);
 	unsigned int checksum = 0;
+
 	for (unsigned int a = 0; a &lt; ars.size(); a++) {
 		const unsigned int tmp = GetArchiveChecksum(ars[a]);
 		if (debugChecksums) {
@@ -931,6 +939,7 @@
 void CArchiveScanner::CheckMod(const string&amp; root, unsigned checksum)
 {
 	unsigned localChecksum = GetModChecksum(root);
+
 	if (localChecksum != checksum) {
 		char msg[1024];
 		sprintf(

Modified: branches/caiinterface/rts/System/LoadSaveHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/LoadSaveHandler.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/LoadSaveHandler.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -68,7 +68,7 @@
 static void WriteString(std::ostream&amp; s, std::string&amp; str)
 {
 	char c;
-	for (int a=0;a&lt;str.length();a++) {
+	for (unsigned int a=0;a&lt;str.length();a++) {
 		c = str[a];
 		s.write(&amp;c,sizeof(char));
 	}

Modified: branches/caiinterface/rts/System/Matrix44f.cpp
===================================================================
--- branches/caiinterface/rts/System/Matrix44f.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/Matrix44f.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -32,6 +32,18 @@
 }
 
 
+CMatrix44f::CMatrix44f(const float3&amp; pos)
+{
+	m[0]  = m[5]  = m[10] = m[15] = 1.0f;
+
+	m[1]  = m[2]  = m[3]  = 0.0f;
+	m[4]  = m[6]  = m[7]  = 0.0f;
+	m[8]  = m[9]  = m[11] = 0.0f;
+
+	m[12] = pos.x; m[13] = pos.y; m[14] = pos.z;
+}
+
+
 CMatrix44f::~CMatrix44f(void)
 {
 }
@@ -186,9 +198,9 @@
 	*this = Mul(tm);
 */
 
-	const float x=pos.x;
-	const float y=pos.y;
-	const float z=pos.z;
+	const float&amp; x=pos.x;
+	const float&amp; y=pos.y;
+	const float&amp; z=pos.z;
 	m[12] += x*m[0] + y*m[4] + z*m[8];
 	m[13] += x*m[1] + y*m[5] + z*m[9];
 	m[14] += x*m[2] + y*m[6] + z*m[10];

Modified: branches/caiinterface/rts/System/Matrix44f.h
===================================================================
--- branches/caiinterface/rts/System/Matrix44f.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/Matrix44f.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -11,6 +11,7 @@
 	CMatrix44f(void);
 	CMatrix44f(const float3&amp; pos, const float3&amp; x, const float3&amp; y, const float3&amp; z);
 	CMatrix44f(const CMatrix44f&amp; n);
+	CMatrix44f(const float3&amp; pos);
 	~CMatrix44f(void);
 
 	void LoadIdentity();

Modified: branches/caiinterface/rts/System/Script/LuaFunctions.cpp
===================================================================
--- branches/caiinterface/rts/System/Script/LuaFunctions.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/Script/LuaFunctions.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -113,7 +113,7 @@
 		object o = newtable(L);
 
 		int count = 1;
-		for (int a=0;a&lt;ft.size();a++)
+		for (unsigned int a=0;a&lt;ft.size();a++)
 		{
 			CFeature *f = ft[a];
 			o[count++] = SAFE_NEW CObject_pointer&lt;CFeature&gt;(f);
@@ -160,7 +160,7 @@
 	{
 		object o = newtable(L);
 
-		for (int i = 0; i &lt; selectedUnits.netSelected[player].size(); ++i)
+		for (unsigned int i = 0; i &lt; selectedUnits.netSelected[player].size(); ++i)
 			o[i+1] = SAFE_NEW CObject_pointer&lt;CUnit&gt;(uh-&gt;units[selectedUnits.netSelected[player][i]]);
 
 		return o;

Modified: branches/caiinterface/rts/System/SpringApp.cpp
===================================================================
--- branches/caiinterface/rts/System/SpringApp.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/SpringApp.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -861,7 +861,6 @@
 	}
 }
 
-
 /**
  * @return return code of activecontroller draw function
  *
@@ -873,28 +872,43 @@
 	if (FSAA)
 		glEnable(GL_MULTISAMPLE_ARB);
 
+#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
 	mouseInput-&gt;Update();
-
+#endif
 	int ret = 1;
 	if (activeController) {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 		int frame=gu-&gt;drawFrame;
-#endif
+#	endif
 		if (!activeController-&gt;Update()) {
 			ret = 0;
 		} else {
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 			if(frame==gu-&gt;drawFrame) { // only draw if it was not done in parallel with sim
+#	endif
+#else
+				if(!gs-&gt;frameNum) {
+					mouseInput-&gt;Update();
+					activeController-&gt;Update();
+					if(gs-&gt;frameNum)
+						startsim=1;
+				}
 #endif
 				gu-&gt;drawFrame++;
 				if (gu-&gt;drawFrame == 0) {
 					gu-&gt;drawFrame++;
 				}
 				ret = activeController-&gt;Draw();
-#if defined(USE_GML) &amp;&amp; GML_MT_TEST
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+				gmlProcessor.PumpAux(); 
+#endif
+#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
+#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
 			}
+#	endif
+		}
 #endif
-		}
 	}
 
 	VSync.Delay();
@@ -906,6 +920,28 @@
 	return ret;
 }
 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+int SpringApp::Sim() {
+	while(keeprunning &amp;&amp; !startsim)
+		boost::thread::yield();
+	unsigned lastSim = SDL_GetTicks();
+	while(keeprunning) {
+		mouseInput-&gt;Update();
+		if (activeController) {
+			if (!activeController-&gt;Update()) {
+				return 0;
+			}
+			gmlProcessor.GetQueue();
+		}
+		unsigned lastSimDiff=SDL_GetTicks()-lastSim;
+		if(lastSimDiff&lt;=10)
+			SDL_Delay(10-lastSimDiff);
+		lastSim = SDL_GetTicks();
+	}
+	return 1;
+}
+#endif
+
 /**
  * Tests SDL keystates and sets values
  * in key array
@@ -953,6 +989,12 @@
 	SDL_EventState (SDL_SYSWMEVENT, SDL_ENABLE);
 #endif
 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	keeprunning=1;
+	startsim=0;
+	gmlProcessor.AuxWork(&amp;SpringApp::Simcb,this); // start sim thread
+#endif
+
 	SDL_Event event;
 	bool done = false;
 
@@ -1088,6 +1130,12 @@
 	}
 	ENTER_MIXED;
 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	keeprunning=0; // wait for sim to finish
+	while(!gmlProcessor.PumpAux())
+		boost::thread::yield();
+#endif
+
 	// Shutdown
 	Shutdown();
 	return 0;

Modified: branches/caiinterface/rts/System/SpringApp.h
===================================================================
--- branches/caiinterface/rts/System/SpringApp.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/SpringApp.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,9 +1,11 @@
 #ifndef SPRING_APP
 #define SPRING_APP
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;string&gt;
 #include &lt;SDL_types.h&gt;
 
+
 class BaseCmd;
 class CGameController;
 
@@ -30,6 +32,12 @@
 	bool SetSDLVideoMode(); 			//!&lt; Sets SDL video mode
 	void Shutdown (); 				//!&lt; Shuts down application
 	int Update (); 					//!&lt; Run simulation and draw
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	int Sim (); 					//!&lt; Simulation  loop
+	static void Simcb(void *c) {((SpringApp *)c)-&gt;Sim();}
+	volatile int keeprunning;
+	volatile int startsim;
+#endif
 	void UpdateSDLKeys (); 				//!&lt; Update SDL key array
 	bool GetDisplayGeometry();
 	void SetupViewportGeometry();

Modified: branches/caiinterface/rts/System/myMath.cpp
===================================================================
--- branches/caiinterface/rts/System/myMath.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/myMath.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -10,7 +10,7 @@
 CR_BIND(int2, );
 CR_REG_METADATA(int2, (CR_MEMBER(x),CR_MEMBER(y)));
 
-float2 headingToVectorTable[1024];
+float2 headingToVectorTable[NUM_HEADINGS];
 
 class CMyMath
 {
@@ -23,21 +23,21 @@
 		streflop_init&lt;streflop::Simple&gt;();
 #endif
 
-		for(int a=0;a&lt;1024;++a){
-			float ang=(a-512)*2*PI/1024;
+		for(int a=0;a&lt;NUM_HEADINGS;++a){
+			float ang=(a-(NUM_HEADINGS/2))*2*PI/NUM_HEADINGS;
 			float2 v;
 			v.x=sin(ang);
 			v.y=cos(ang);
 			headingToVectorTable[a]=v;
 		}
 		unsigned checksum = 0;
-		for (int a = 0; a &lt; 1024; ++a) {
+		for (int a = 0; a &lt; NUM_HEADINGS; ++a) {
 			checksum = 33 * checksum + *(unsigned*)&amp;headingToVectorTable[a].x;
 			checksum *= 33;
 			checksum = 33 * checksum + *(unsigned*)&amp;headingToVectorTable[a].y;
 		}
 #ifdef STREFLOP_H
-		if (checksum != 0x617a9968)
+		if (checksum != HEADING_CHECKSUM)
 			handleerror(0, &quot;Invalid headingToVectorTable checksum. Most likely&quot;
 					&quot; your streflop library was not compiled with the correct&quot;
 					&quot; options, or you are not using streflop at all.&quot;,

Modified: branches/caiinterface/rts/System/myMath.h
===================================================================
--- branches/caiinterface/rts/System/myMath.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/System/myMath.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -7,9 +7,20 @@
 
 #define SHORTINT_MAXVALUE 32768
 
+#define HEADING_CHECKSUM_1024 0x617a9968
+#define HEADING_CHECKSUM_4096 0x3d51b476
+#define NUM_HEADINGS 4096
 
-extern float2 headingToVectorTable[1024];
+#if (NUM_HEADINGS == 1024)
+#  define HEADING_CHECKSUM	HEADING_CHECKSUM_1024
+#elif (NUM_HEADINGS == 4096)
+#  define HEADING_CHECKSUM	HEADING_CHECKSUM_4096
+#else
+#  error &quot;HEADING_CHECKSUM not set, invalid NUM_HEADINGS?&quot;
+#endif
 
+extern float2 headingToVectorTable[NUM_HEADINGS];
+
 inline short int GetHeadingFromFacing(int facing)
 {
 	switch (facing) {
@@ -93,7 +104,7 @@
 
 inline float3 GetVectorFromHeading(short int heading)
 {
-	float2 v = headingToVectorTable[heading / 64 + 512];
+	float2 v = headingToVectorTable[heading / ((SHORTINT_MAXVALUE/NUM_HEADINGS) * 2) + NUM_HEADINGS/2];
 	return float3(v.x, 0.0f, v.y);
 }
 

Modified: branches/caiinterface/rts/lib/CMakeLists.txt
===================================================================
--- branches/caiinterface/rts/lib/CMakeLists.txt	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/lib/CMakeLists.txt	2008-10-17 22:50:00 UTC (rev 6801)
@@ -1,4 +1,4 @@
-INCLUDE_DIRECTORIES(streflop lua/include luabind ${CMAKE_SOURCE_DIR}/rts/System)
+INCLUDE_DIRECTORIES(BEFORE streflop lua/include luabind ${CMAKE_SOURCE_DIR}/rts/System)
 
 ADD_DEFINITIONS(${PIC_FLAG}) # all libraries need to be position independent (gives compiler warnings on 64bit-linux)
 
@@ -36,4 +36,4 @@
 ENDIF (UNIX)
 TARGET_LINK_LIBRARIES(minizip z)
 
-ADD_SUBDIRECTORY(streflop)
+ADD_SUBDIRECTORY(streflop)

Modified: branches/caiinterface/rts/lib/gml/gml.cpp
===================================================================
--- branches/caiinterface/rts/lib/gml/gml.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/lib/gml/gml.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -34,6 +34,8 @@
 #include &quot;StdAfx.h&quot;
 #ifdef USE_GML
 #include &quot;gmlcls.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
 
 #define EXEC_RUN (BYTE *)NULL
 #define EXEC_SYNC (BYTE *)-1
@@ -54,7 +56,7 @@
 int gmlThreadNumber=0;
 #endif
 int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
-int gmlThreadCountOverride=0; // number of threads to use (can be manually overridden here)
+int gmlThreadCountOverride=0; //configHandler.GetInt(&quot;HardwareThreadCount&quot;, 0); // number of threads to use (can be manually overridden here)
 int gmlItemsConsumed=0;
 
 // gmlCPUCount returns the number of CPU cores
@@ -173,6 +175,29 @@
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSPROC *&gt; gmlBufferServer(&amp;glGenBuffers, 2, 0);
 
 
+#if GML_ENABLE_SIMDRAW
+#include &lt;boost/thread/mutex.hpp&gt;
+boost::mutex caimutex;
+boost::mutex decalmutex;
+boost::mutex treemutex;
+boost::mutex modelmutex;
+boost::mutex texmutex;
+boost::mutex mapmutex;
+boost::mutex groupmutex;
+boost::mutex inmapmutex;
+boost::mutex tempmutex;
+
+#include &lt;boost/thread/recursive_mutex.hpp&gt;
+boost::recursive_mutex unitmutex;
+boost::recursive_mutex quadmutex;
+boost::recursive_mutex selmutex;
+boost::recursive_mutex luamutex;
+boost::recursive_mutex featmutex;
+boost::recursive_mutex projmutex;
+boost::recursive_mutex grassmutex;
+boost::recursive_mutex guimutex;
+#endif
+
 // GMLqueue implementation
 gmlQueue::gmlQueue():
 ReadPos(0),WritePos(0),WriteSize(0),Read(0),Write(0),Locked1(FALSE),Locked2(FALSE),Reloc(FALSE),Sync(EXEC_RUN),WasSynced(FALSE),
@@ -882,7 +907,6 @@
 	BYTE *p=Read;
 	BYTE *e=ReadPos;
 	BYTE *ptr=NULL;
-
 	while(p&lt;e) {
 //		GML_DEBUG(&quot;Cmd &quot;,*(int *)p, 2);
 		QueueHandler(p,ptr);
@@ -891,12 +915,28 @@
 //	GML_DEBUG(&quot;Execute &quot;,procs, 2);
 }
 
+void gmlQueue::ExecuteDebug() {
+	int procs=0;
+	BYTE *p=Read;
+	BYTE *e=ReadPos;
+	BYTE *ptr=NULL;
+
+	while(p&lt;e) {
+		if(*(int *)p!=0)
+			logOutput.Print(&quot;GML error: OpenGL call #%d in SimFrame()&quot;,*(int *)p);
+		QueueHandler(p,ptr);
+		++procs;
+	}
+	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
+		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
+}
+
 #include &quot;gmlsrv.h&quot;
 
-// Execute - executes all GL commands in the current read queue.
+// ExecuteSynced - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points
 // to return values to the worker thread)
-void gmlQueue::ExecuteSynced() {
+void gmlQueue::ExecuteSynced(void (gmlQueue::*execfun)() ) {
 //int procs=0;
 #if GML_ALTERNATE_SYNCMODE
 	BYTE *s;
@@ -908,7 +948,7 @@
 			if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 				gmlUpdateServers();
 			if(GetRead()) {
-				Execute();
+				(this-&gt;*execfun)();
 				ReleaseRead();
 			}
 			boost::thread::yield();
@@ -918,14 +958,14 @@
 			Sync=EXEC_SYNC; //NEW
 			GetRead(TRUE);
 			Sync=EXEC_RUN; // cannot allow worker to continue before right queue acquired
-			Execute();
+			(this-&gt;*execfun)();
 			ReleaseRead();
 			break;
 		}
 
 		Sync=EXEC_RUN; // sync confirmed
 		GetRead(TRUE);
-		Execute();
+		(this-&gt;*execfun)();
 		Sync=EXEC_RES; // result available
 		ReleaseRead();
 		while(Sync==EXEC_RES) // waiting for worker to acquire result

Modified: branches/caiinterface/rts/lib/gml/gml.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gml.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/lib/gml/gml.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -133,12 +133,50 @@
 
 #include &quot;gmlimp.h&quot;
 #include &quot;gmldef.h&quot;
+
 #define GML_VECTOR gmlVector
 #define GML_CLASSVECTOR gmlClassVector
 
+#if GML_ENABLE_SIMDRAW
+#include &lt;boost/thread/mutex.hpp&gt;
+extern boost::mutex caimutex;
+extern boost::mutex decalmutex;
+extern boost::mutex treemutex;
+extern boost::mutex modelmutex;
+extern boost::mutex texmutex;
+extern boost::mutex mapmutex;
+extern boost::mutex groupmutex;
+extern boost::mutex inmapmutex;
+extern boost::mutex tempmutex;
+
+#include &lt;boost/thread/recursive_mutex.hpp&gt;
+extern boost::recursive_mutex unitmutex;
+extern boost::recursive_mutex quadmutex;
+extern boost::recursive_mutex selmutex;
+extern boost::recursive_mutex luamutex;
+extern boost::recursive_mutex featmutex;
+extern boost::recursive_mutex projmutex;
+extern boost::recursive_mutex grassmutex;
+extern boost::recursive_mutex guimutex;
+
+#define GML_STDMUTEX_LOCK(name) boost::mutex::scoped_lock name##lock(name##mutex)
+#define GML_RECMUTEX_LOCK(name) boost::recursive_mutex::scoped_lock name##lock(name##mutex)
+
 #else
+
+#define GML_STDMUTEX_LOCK(name)
+#define GML_RECMUTEX_LOCK(name)
+
+#endif
+
+#else
+
 #define GML_VECTOR std::vector
 #define GML_CLASSVECTOR std::vector
+
+#define GML_STDMUTEX_LOCK(name)
+#define GML_RECMUTEX_LOCK(name)
+
 #endif // USE_GML
 
 #endif

Modified: branches/caiinterface/rts/lib/gml/gmlcls.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlcls.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/lib/gml/gmlcls.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -34,9 +34,12 @@
 #endif
 
 #define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
+#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; 0) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
+#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; 0) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
+
 #define GML_ENABLE_DRAW (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
-#define GML_SERVER_GLCALL 1 // allow the server thread (0) to make direct GL calls
-#define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 1
+#define GML_SERVER_GLCALL 1 // allows the server thread (0) to make direct GL calls
+#define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 4
 #define GML_USE_NO_ERROR 1 // glGetError always returns success (to improve performance)
 #define GML_USE_DEFAULT 1// compile/link/buffer status always returns TRUE/COMPLETE (to improve performance)
 #define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
@@ -803,7 +806,8 @@
 	BOOL_ GetRead(BOOL_ critical=FALSE);
 	void SyncRequest();
 	void Execute();
-	void ExecuteSynced();
+	void ExecuteSynced(void (gmlQueue::*execfun)() =&amp;gmlQueue::Execute);
+	void ExecuteDebug();
 };
 
 

Modified: branches/caiinterface/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlsrv.h	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/rts/lib/gml/gmlsrv.h	2008-10-17 22:50:00 UTC (rev 6801)
@@ -10,7 +10,6 @@
 #define GMLSRV_H
 
 #ifdef USE_GML
-#define GML_MT_TEST 0 // run Draw() parallel with SimFrame(). Highly experimental, not fully working yet.
 
 #include &lt;boost/thread/barrier.hpp&gt;
 #include &lt;boost/bind.hpp&gt;
@@ -112,6 +111,7 @@
 
 };
 
+
 template&lt;class R,class A, typename U&gt;
 class gmlClientServer {
 public:
@@ -324,24 +324,14 @@
 	}
 
 	void GetQueue() {
-		int thread=gmlThreadNumber;
-//		int processed=1;
+		gmlQueue *qd=&amp;gmlQueues[gmlThreadCount];
 
-//		GML_TYPENAME gmlExecState&lt;R,A,U&gt; *ex=ExecState+ExecDepth;
+		if(!qd-&gt;WasSynced &amp;&amp; qd-&gt;Write==qd-&gt;WritePos)
+			return;
 
-		gmlQueue *qd=&amp;gmlQueues[thread];
-
 		BOOL_ isq1=qd-&gt;Write==qd-&gt;Queue1;
 
-	qd-&gt;GetWrite(TRUE);
-/*#if GML_ALTERNATE_SYNCMODE
-		if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(ex-&gt;syncmode?TRUE:2))
-#else
-		if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(TRUE))
-#endif
-			processed=0;
-		if(processed &amp;&amp; qd-&gt;GetWrite(TRUE))
-			processed=0;*/
+		qd-&gt;GetWrite(qd-&gt;WasSynced?2:TRUE);
 
 		if(isq1) {
 			while(!qd-&gt;Locked1 &amp;&amp; *(BYTE * volatile *)&amp;qd-&gt;Pos1!=qd-&gt;Queue1)
@@ -363,18 +353,17 @@
 			if(qd-&gt;Reloc)
 				qd-&gt;Realloc();
 			if(qd-&gt;GetRead()) {
-				qd-&gt;Execute();
+				qd-&gt;ExecuteDebug();
 				qd-&gt;ReleaseRead();
 			}
 			if(qd-&gt;Sync) {
-				qd-&gt;ExecuteSynced();
+				qd-&gt;ExecuteSynced(&amp;gmlQueue::ExecuteDebug);
 			}
 			if(AuxClientsReady==0)
 				return FALSE;
 			else
 				++AuxClientsReady;
 		}
-//		auxworker=NULL; // move to auxsub?
 		return TRUE;
 	}
 
@@ -407,7 +396,7 @@
 		qd-&gt;ReleaseWrite();
 
 		++AuxClientsReady;	
-		auxworker=NULL; // move to auxsub?
+		auxworker=NULL;
 	}
 
 	void gmlClientAux() {

Modified: branches/caiinterface/tools/DedicatedServer/main.cpp
===================================================================
--- branches/caiinterface/tools/DedicatedServer/main.cpp	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/tools/DedicatedServer/main.cpp	2008-10-17 22:50:00 UTC (rev 6801)
@@ -3,9 +3,14 @@
 #include &quot;GameData.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
 #include &quot;System/FileSystem/ArchiveScanner.h&quot;
+#include &quot;System/FileSystem/VFSHandler.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
+#include &quot;System/Exceptions.h&quot;
+#include &quot;System/UnsyncedRNG.h&quot;
 
 #include &lt;string&gt;
 #include &lt;iostream&gt;
+#include &lt;SDL_timer.h&gt;
 
 #ifdef _WIN32
 #include &lt;windows.h&gt;
@@ -25,6 +30,7 @@
 	{
 		std::string script = argv[1];
 		std::cout &lt;&lt; &quot;Loading script: &quot; &lt;&lt; script &lt;&lt; std::endl;
+
 		gameSetup = new CGameSetup();	// to store the gamedata inside
 		if (!gameSetup-&gt;Init(script))	// read the script provided by cmdline
 		{
@@ -34,12 +40,43 @@
 		
 		std::cout &lt;&lt; &quot;Starting server...&quot; &lt;&lt; std::endl;
 		// Create the server, it will run in a separate thread
-		const std::string modArchive = archiveScanner-&gt;ModNameToModArchive(gameSetup-&gt;baseMod);
 		GameData* data = new GameData();
-		data-&gt;SetMap(gameSetup-&gt;mapName, archiveScanner-&gt;GetMapChecksum(gameSetup-&gt;mapName));
-		data-&gt;SetMod(gameSetup-&gt;baseMod, archiveScanner-&gt;GetModChecksum(modArchive));
+		UnsyncedRNG rng;
+		rng.Seed(SDL_GetTicks());
+		rng.Seed(gameSetup-&gt;gameSetupTextLength);
+		data-&gt;SetRandomSeed(SDL_GetTicks());
+
+		//  Use script provided hashes if they exist
+		if (gameSetup-&gt;mapHash != 0) {
+			data-&gt;SetMap(gameSetup-&gt;mapName, gameSetup-&gt;mapHash);
+		} else {
+			data-&gt;SetMap(gameSetup-&gt;mapName, archiveScanner-&gt;GetMapChecksum(gameSetup-&gt;mapName));
+
+			CFileHandler* f = new CFileHandler(&quot;maps/&quot; + gameSetup-&gt;mapName);
+			if (!f-&gt;FileExists()) {
+				std::vector&lt;std::string&gt; ars = archiveScanner-&gt;GetArchivesForMap(gameSetup-&gt;mapName);
+				if (ars.empty()) {
+					throw content_error(&quot;Couldn't find any archives for map '&quot; + gameSetup-&gt;mapName + &quot;'.&quot;);
+				}
+				for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
+					if (!vfsHandler-&gt;AddArchive(*i, false)) {
+						throw content_error(&quot;Couldn't load archive '&quot; + *i + &quot;' for map '&quot; + gameSetup-&gt;mapName + &quot;'.&quot;);
+					}
+				}
+			}
+			delete f;
+		
+			gameSetup-&gt;LoadStartPositions();
+                }
+
+		if (gameSetup-&gt;modHash != 0) {
+			data-&gt;SetMod(gameSetup-&gt;baseMod, gameSetup-&gt;modHash);
+		} else {
+			const std::string modArchive = archiveScanner-&gt;ModNameToModArchive(gameSetup-&gt;baseMod);
+			data-&gt;SetMod(gameSetup-&gt;baseMod, archiveScanner-&gt;GetModChecksum(modArchive));
+		}
+
 		data-&gt;SetScript(gameSetup-&gt;scriptName);
-		
 		server = new CGameServer(gameSetup-&gt;hostport, false, data, gameSetup);
 		
 		if (gameSetup-&gt;autohostport &gt; 0)

Modified: branches/caiinterface/tools/unitsync/CMakeLists.txt
===================================================================
--- branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-10-17 22:24:15 UTC (rev 6800)
+++ branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-10-17 22:50:00 UTC (rev 6801)
@@ -9,7 +9,7 @@
 	
 	FIND_PACKAGE(GLEW REQUIRED)
 	
-	set (unitsync_libs ${GLEW_LIBRARIES} ${DEVIL_IL_LIBRARY} ${OPENAL_LIBRARY} ${GL_gl_LIBRARY} ${GL_glu_LIBRARY})
+	set (unitsync_libs ${GLEW_LIBRARIES} ${DEVIL_IL_LIBRARY} ${GL_gl_LIBRARY} ${GL_glu_LIBRARY})
 	list (APPEND unitsync_libs util) # sometimes this is needed (and I have no clue why)
 	
 	FIND_PACKAGE(PythonLibs)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001569.html">[Taspring-linux-commit] r6800 - in trunk: rts/Sim/Units/CommandAI	rts/System rts/System/Script tools/unitsync
</A></li>
	<LI>Next message: <A HREF="001571.html">[Taspring-linux-commit] r6802 - trunk/rts/Game/Camera
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1570">[ date ]</a>
              <a href="thread.html#1570">[ thread ]</a>
              <a href="subject.html#1570">[ subject ]</a>
              <a href="author.html#1570">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
