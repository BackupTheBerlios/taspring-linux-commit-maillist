<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6493 - in branches/caiinterface/tools:	scripts unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6493%20-%20in%20branches/caiinterface/tools%3A%0A%09scripts%20unitsync&In-Reply-To=%3C20081001175341.78D354A43%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001264.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6493 - in branches/caiinterface/tools:	scripts unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6493%20-%20in%20branches/caiinterface/tools%3A%0A%09scripts%20unitsync&In-Reply-To=%3C20081001175341.78D354A43%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6493 - in branches/caiinterface/tools:	scripts unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Oct  1 19:53:41 CEST 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001264.html">[Taspring-linux-commit] r6494 - in branches/caiinterface: . AI	AI/Group AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/AAI AI/Skirmish/CSAI	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win	AI/Skirmish/CSAI/CSAI2 AI/Skirmish/CSAI/CSAILoader	AI/Skirmish/CSAI/MonoLoader AI/Skirmish/JCAI	AI/Skirmish/KAI-0.2 AI/Skirmish/KAIK-0.13 AI/Skirmish/NTai	AI/Skirmish/NTai/AI AI/Skirmish/NTai/AI/nbproject/private	AI/Skirmish/NullAI AI/Skirmish/RAI-0.553	AI/Skirmish/TestGlobalAI Lobby/AFLobby/src/aflobby	Lobby/TASClient game/startscripts installer/sections rts	rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper	rts/ExternalAI/Interface/LegacyCppWrapper/Event rts/Game	rts/Game/StartScripts rts/Lua rts/Map rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/build/scons	rts/lib/lua/src rts/lib/streflop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1263">[ date ]</a>
              <a href="thread.html#1263">[ thread ]</a>
              <a href="subject.html#1263">[ subject ]</a>
              <a href="author.html#1263">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-10-01 19:53:40 +0200 (Wed, 01 Oct 2008)
New Revision: 6493

Modified:
   branches/caiinterface/tools/scripts/builder.sh
   branches/caiinterface/tools/scripts/runner.sh
   branches/caiinterface/tools/unitsync/CMakeLists.txt
   branches/caiinterface/tools/unitsync/LuaParserAPI.cpp
   branches/caiinterface/tools/unitsync/LuaParserAPI.h
   branches/caiinterface/tools/unitsync/pybind.cpp
   branches/caiinterface/tools/unitsync/unitsync.cpp
   branches/caiinterface/tools/unitsync/unitsync.h
Log:
finally it is working in linux (compiled with gcc and cmake) and on windows (compiled with mingw and scons).
what works:
+ AI Interface libraries
+ Skirmish AI libraries
+ AIInfo.lua and AIInterfaceInfo.lua can be read from unitsync(untested) and are read by the engine, to know what engines are around (eg to check if script.txt specifies good values, and for the startscripts)
+ AIOptions.lua can be read through unitsync(untested)
what does not work:
- group AIs (most of the interface code is still missing, the game crashes if you try to select one in game)
- actually passing option values to the AIs (though that will be very simple to add)

How to specify an AI in script.txt
----------------------------------
LUA AI:
both are possible, the first one only for legacy support:
* [code]aispecifyer=LuaAI:&lt;luaAIName&gt;[/code]
* [code]luaai=&lt;luaAIName&gt;[/code]

Skirmish AI:
[code]
aishortname=RAI
aiversion=0.600
[/code]
the second line (specifying the version) is optional.

Modified: branches/caiinterface/tools/scripts/builder.sh
===================================================================
--- branches/caiinterface/tools/scripts/builder.sh	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/scripts/builder.sh	2008-10-01 17:53:40 UTC (rev 6493)
@@ -11,7 +11,7 @@
 
 # AI used for testing.. (used as compile target and to generate DLL/SO name)
 AI=&quot;AAI&quot;
-AIDIR=&quot;AI/Bot-libs&quot;  # relative to '$WINEDIR' or 'game'.
+AIDIR=&quot;AI/Skirmish/impls&quot;  # relative to '$WINEDIR' or 'game'.
 
 # For crosscompiling MinGW builds.
 MINGDIR=&quot;/usr/i586-mingw32msvc&quot;

Modified: branches/caiinterface/tools/scripts/runner.sh
===================================================================
--- branches/caiinterface/tools/scripts/runner.sh	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/scripts/runner.sh	2008-10-01 17:53:40 UTC (rev 6493)
@@ -19,7 +19,7 @@
 [ -z &quot;$SPRING_CLIENT&quot; ] &amp;&amp; SPRING_CLIENT=&quot;game/spring&quot;
 
 # Where AIs are stored..
-AIDIR=&quot;AI/Bot-libs&quot;
+AIDIR=&quot;AI/Skirmish/impls&quot;
 
 # Some control of logging.
 LOGDIR=&quot;log&quot;

Modified: branches/caiinterface/tools/unitsync/CMakeLists.txt
===================================================================
--- branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-10-01 17:53:40 UTC (rev 6493)
@@ -22,7 +22,7 @@
 ADD_DEFINITIONS( -D_SZ_ONE_DIRECTORY -DNO_AVI -DSYNCCHECK -DUNITSYNC -DBITMAP_NO_OPENGL)
 
 INCLUDE_DIRECTORIES(../../rts/System/Net/ ../../rts/lib/lua/include)
-INCLUDE_DIRECTORIES(../../rts/ ../../rts/Game ../../rts/lib/7zip ../../rts/System)
+INCLUDE_DIRECTORIES(../../rts ../../rts/Game ../../rts/lib/7zip ../../rts/System)
 
 IF (UNIX)
 	SET(platformfiles

Modified: branches/caiinterface/tools/unitsync/LuaParserAPI.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/LuaParserAPI.cpp	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/unitsync/LuaParserAPI.cpp	2008-10-01 17:53:40 UTC (rev 6493)
@@ -41,7 +41,7 @@
 //  Primary calls
 //
 
-DLL_EXPORT void __stdcall lpClose()
+Export(void) lpClose()
 {
 	rootTable = LuaTable();
 	currTable = LuaTable();
@@ -58,7 +58,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpOpenFile(const char* filename,
+Export(int) lpOpenFile(const char* filename,
                                     const char* fileModes,
                                     const char* accessModes)
 {
@@ -68,7 +68,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpOpenSource(const char* source,
+Export(int) lpOpenSource(const char* source,
                                       const char* accessModes)
 {
 	lpClose();
@@ -77,7 +77,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpExecute()
+Export(int) lpExecute()
 {
 	if (!luaParser) {
 		return 0;
@@ -89,7 +89,7 @@
 }
 
 
-DLL_EXPORT const char* __stdcall lpErrorLog()
+Export(const char*) lpErrorLog()
 {
 	if (luaParser) {
 		return GetStr(luaParser-&gt;GetErrorLog());
@@ -103,67 +103,67 @@
 //  Environment additions
 //
 
-DLL_EXPORT void __stdcall lpAddTableInt(int key, int override)
+Export(void) lpAddTableInt(int key, int override)
 {
 	if (luaParser) { luaParser-&gt;GetTable(key, override); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddTableStr(const char* key, int override)
+Export(void) lpAddTableStr(const char* key, int override)
 {
 	if (luaParser) { luaParser-&gt;GetTable(key, override); }
 }
 
 
-DLL_EXPORT void __stdcall lpEndTable()
+Export(void) lpEndTable()
 {
 	if (luaParser) { luaParser-&gt;EndTable(); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddIntKeyIntVal(int key, int val)
+Export(void) lpAddIntKeyIntVal(int key, int val)
 {
 	if (luaParser) { luaParser-&gt;AddInt(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddStrKeyIntVal(const char* key, int val)
+Export(void) lpAddStrKeyIntVal(const char* key, int val)
 {
 	if (luaParser) { luaParser-&gt;AddInt(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddIntKeyBoolVal(int key, int val)
+Export(void) lpAddIntKeyBoolVal(int key, int val)
 {
 	if (luaParser) { luaParser-&gt;AddBool(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddStrKeyBoolVal(const char* key, int val)
+Export(void) lpAddStrKeyBoolVal(const char* key, int val)
 {
 	if (luaParser) { luaParser-&gt;AddBool(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddIntKeyFloatVal(int key, float val)
+Export(void) lpAddIntKeyFloatVal(int key, float val)
 {
 	if (luaParser) { luaParser-&gt;AddFloat(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddStrKeyFloatVal(const char* key, float val)
+Export(void) lpAddStrKeyFloatVal(const char* key, float val)
 {
 	if (luaParser) { luaParser-&gt;AddFloat(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddIntKeyStrVal(int key, const char* val)
+Export(void) lpAddIntKeyStrVal(int key, const char* val)
 {
 	if (luaParser) { luaParser-&gt;AddString(key, val); }
 }
 
 
-DLL_EXPORT void __stdcall lpAddStrKeyStrVal(const char* key, const char* val)
+Export(void) lpAddStrKeyStrVal(const char* key, const char* val)
 {
 	if (luaParser) { luaParser-&gt;AddString(key, val); }
 }
@@ -174,7 +174,7 @@
 //  Table manipulation
 //
 
-DLL_EXPORT int __stdcall lpRootTable()
+Export(int) lpRootTable()
 {
 	currTable = rootTable;
 	luaTables.clear();
@@ -182,7 +182,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpRootTableExpr(const char* expr)
+Export(int) lpRootTableExpr(const char* expr)
 {
 	currTable = rootTable.SubTableExpr(expr);
 	luaTables.clear();
@@ -190,7 +190,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpSubTableInt(int key)
+Export(int) lpSubTableInt(int key)
 {
 	luaTables.push_back(currTable);
 	currTable = currTable.SubTable(key);
@@ -198,7 +198,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpSubTableStr(const char* key)
+Export(int) lpSubTableStr(const char* key)
 {
 	luaTables.push_back(currTable);
 	currTable = currTable.SubTable(key);
@@ -206,7 +206,7 @@
 }
 
 
-DLL_EXPORT int __stdcall lpSubTableExpr(const char* expr)
+Export(int) lpSubTableExpr(const char* expr)
 {
 	luaTables.push_back(currTable);
 	currTable = currTable.SubTableExpr(expr);
@@ -214,7 +214,7 @@
 }
 
 
-DLL_EXPORT void __stdcall lpPopTable()
+Export(void) lpPopTable()
 {
 	if (luaTables.empty()) {
 		currTable = rootTable;
@@ -231,13 +231,13 @@
 //  Key existance
 //
 
-DLL_EXPORT int __stdcall lpGetKeyExistsInt(int key)
+Export(int) lpGetKeyExistsInt(int key)
 {
 	return currTable.KeyExists(key) ? 1 : 0;
 }
 
 
-DLL_EXPORT int __stdcall lpGetKeyExistsStr(const char* key)
+Export(int) lpGetKeyExistsStr(const char* key)
 {
 	return currTable.KeyExists(key) ? 1 : 0;
 }
@@ -248,13 +248,13 @@
 //  Type
 //
 
-DLL_EXPORT int __stdcall lpGetIntKeyType(int key)
+Export(int) lpGetIntKeyType(int key)
 {
 	return currTable.GetType(key);
 }
 
 
-DLL_EXPORT int __stdcall lpGetStrKeyType(const char* key)
+Export(int) lpGetStrKeyType(const char* key)
 {
 	return currTable.GetType(key);
 }
@@ -265,7 +265,7 @@
 // Key lists
 //
 
-DLL_EXPORT int __stdcall lpGetIntKeyListCount()
+Export(int) lpGetIntKeyListCount()
 {
 	if (!currTable.IsValid()) {
 		intKeys.clear();
@@ -277,16 +277,16 @@
 }
 
 
-DLL_EXPORT int __stdcall lpGetIntKeyListEntry(int index)
+Export(int) lpGetIntKeyListEntry(int index)
 {
-	if ((index &lt; 0) || (index &gt;= intKeys.size())) {
+	if ((index &lt; 0) || (index &gt;= (int)intKeys.size())) {
 		return 0;
 	}
 	return intKeys[index];
 }
 
 
-DLL_EXPORT int __stdcall lpGetStrKeyListCount()
+Export(int) lpGetStrKeyListCount()
 {
 	if (!currTable.IsValid()) {
 		strKeys.clear();
@@ -298,9 +298,9 @@
 }
 
 
-DLL_EXPORT const char* __stdcall lpGetStrKeyListEntry(int index)
+Export(const char*) lpGetStrKeyListEntry(int index)
 {
-	if ((index &lt; 0) || (index &gt;= strKeys.size())) {
+	if ((index &lt; 0) || (index &gt;= (int)strKeys.size())) {
 		return GetStr(&quot;&quot;);
 	}
 	return GetStr(strKeys[index]);
@@ -312,50 +312,50 @@
 //  Value queries
 //
 
-DLL_EXPORT int __stdcall lpGetIntKeyIntVal(int key, int defVal)
+Export(int) lpGetIntKeyIntVal(int key, int defVal)
 {
 	return currTable.GetInt(key, defVal);
 }
 
 
-DLL_EXPORT int __stdcall lpGetStrKeyIntVal(const char* key, int defVal)
+Export(int) lpGetStrKeyIntVal(const char* key, int defVal)
 {
 	return currTable.GetInt(key, defVal);
 }
 
 
-DLL_EXPORT int __stdcall lpGetIntKeyBoolVal(int key, int defVal)
+Export(int) lpGetIntKeyBoolVal(int key, int defVal)
 {
 	return currTable.GetBool(key, defVal) ? 1 : 0;
 }
 
 
-DLL_EXPORT int __stdcall lpGetStrKeyBoolVal(const char* key, int defVal)
+Export(int) lpGetStrKeyBoolVal(const char* key, int defVal)
 {
 	return currTable.GetBool(key, defVal) ? 1 : 0;
 }
 
 
-DLL_EXPORT float __stdcall lpGetIntKeyFloatVal(int key, float defVal)
+Export(float) lpGetIntKeyFloatVal(int key, float defVal)
 {
 	return currTable.GetFloat(key, defVal);
 }
 
 
-DLL_EXPORT float __stdcall lpGetStrKeyFloatVal(const char* key, float defVal)
+Export(float) lpGetStrKeyFloatVal(const char* key, float defVal)
 {
 	return currTable.GetFloat(key, defVal);
 }
 
 
-DLL_EXPORT const char* __stdcall lpGetIntKeyStrVal(int key,
+Export(const char*) lpGetIntKeyStrVal(int key,
                                                    const char* defVal)
 {
 	return GetStr(currTable.GetString(key, defVal));
 }
 
 
-DLL_EXPORT const char* __stdcall lpGetStrKeyStrVal(const char* key,
+Export(const char*) lpGetStrKeyStrVal(const char* key,
                                                    const char* defVal)
 {
 	return GetStr(currTable.GetString(key, defVal));

Modified: branches/caiinterface/tools/unitsync/LuaParserAPI.h
===================================================================
--- branches/caiinterface/tools/unitsync/LuaParserAPI.h	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/unitsync/LuaParserAPI.h	2008-10-01 17:53:40 UTC (rev 6493)
@@ -3,6 +3,6 @@
 
 #include &quot;unitsync.h&quot;
 
-DLL_EXPORT void __stdcall lpClose();
+Export(void) lpClose();
 
 #endif /* LUA_PARSER_API_H */

Modified: branches/caiinterface/tools/unitsync/pybind.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/pybind.cpp	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/unitsync/pybind.cpp	2008-10-01 17:53:40 UTC (rev 6493)
@@ -10,59 +10,6 @@
 #define NAMEBUF_SIZE 4096
 
 
-
-DLL_EXPORT const char*  __stdcall GetSpringVersion();
-DLL_EXPORT void         __stdcall Message(const char* p_szMessage);
-DLL_EXPORT int          __stdcall Init(bool isServer, int id);
-DLL_EXPORT void         __stdcall UnInit();
-DLL_EXPORT int          __stdcall ProcessUnits(void);
-DLL_EXPORT int          __stdcall ProcessUnitsNoChecksum(void);
-DLL_EXPORT const char*  __stdcall GetCurrentList();
-DLL_EXPORT void         __stdcall AddClient(int id, const char *unitList);
-DLL_EXPORT void         __stdcall RemoveClient(int id);
-DLL_EXPORT const char*  __stdcall GetClientDiff(int id);
-DLL_EXPORT void         __stdcall InstallClientDiff(const char *diff);
-DLL_EXPORT int          __stdcall GetUnitCount();
-DLL_EXPORT const char*  __stdcall GetUnitName(int unit);
-DLL_EXPORT const char*  __stdcall GetFullUnitName(int unit);
-DLL_EXPORT int          __stdcall IsUnitDisabled(int unit);
-DLL_EXPORT int          __stdcall IsUnitDisabledByClient(int unit, int clientId);
-DLL_EXPORT void         __stdcall AddArchive(const char* name);
-DLL_EXPORT void         __stdcall AddAllArchives(const char* root);
-DLL_EXPORT unsigned int __stdcall GetArchiveChecksum(const char* arname);
-DLL_EXPORT int          __stdcall GetMapCount();
-DLL_EXPORT const char*  __stdcall GetMapName(int index);
-DLL_EXPORT int          __stdcall GetMapInfoEx(const char* name, MapInfo* outInfo, int version);
-DLL_EXPORT int          __stdcall GetMapInfo(const char* name, MapInfo* outInfo);
-DLL_EXPORT void*        __stdcall GetMinimap(const char* filename, int miplevel);
-DLL_EXPORT int          __stdcall GetMapArchiveCount(const char* mapName);
-DLL_EXPORT const char*  __stdcall GetMapArchiveName(int index);
-DLL_EXPORT unsigned int __stdcall GetMapChecksum(int index);
-DLL_EXPORT int          __stdcall GetPrimaryModCount();
-DLL_EXPORT const char*  __stdcall GetPrimaryModName(int index);
-DLL_EXPORT const char*  __stdcall GetPrimaryModArchive(int index);
-DLL_EXPORT int          __stdcall GetPrimaryModArchiveCount(int index);
-DLL_EXPORT const char*  __stdcall GetPrimaryModArchiveList(int arnr);
-DLL_EXPORT int          __stdcall GetPrimaryModIndex(const char* name);
-DLL_EXPORT unsigned int __stdcall GetPrimaryModChecksum(int index);
-DLL_EXPORT int          __stdcall GetSideCount();
-DLL_EXPORT const char*  __stdcall GetSideName(int side);
-DLL_EXPORT int          __stdcall OpenFileVFS(const char* name);
-DLL_EXPORT void         __stdcall CloseFileVFS(int handle);
-DLL_EXPORT void         __stdcall ReadFileVFS(int handle, void* buf, int length);
-DLL_EXPORT int          __stdcall FileSizeVFS(int handle);
-DLL_EXPORT int          __stdcall InitFindVFS(const char* pattern);
-DLL_EXPORT int          __stdcall FindFilesVFS(int handle, char* nameBuf, int size);
-DLL_EXPORT int          __stdcall OpenArchive(const char* name);
-DLL_EXPORT void         __stdcall CloseArchive(int archive);
-DLL_EXPORT int          __stdcall FindFilesArchive(int archive, int cur, char* nameBuf, int* size);
-DLL_EXPORT int          __stdcall OpenArchiveFile(int archive, const char* name);
-DLL_EXPORT int          __stdcall ReadArchiveFile(int archive, int handle, void* buffer, int numBytes);
-DLL_EXPORT void         __stdcall CloseArchiveFile(int archive, int handle);
-DLL_EXPORT int          __stdcall SizeArchiveFile(int archive, int handle);
-
-
-
 static PyObject *unitsync_GetSpringVersion(PyObject *self, PyObject *args)
 {
 	if (!PyArg_ParseTuple(args, &quot;&quot;))

Modified: branches/caiinterface/tools/unitsync/unitsync.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync.cpp	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/unitsync/unitsync.cpp	2008-10-01 17:53:40 UTC (rev 6493)
@@ -14,6 +14,8 @@
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Sim/SideParser.h&quot;
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
 
 #include &quot;LuaParserAPI.h&quot;
 #include &quot;Syncer.h&quot;
@@ -88,7 +90,7 @@
 
 
 #ifdef WIN32
-BOOL __stdcall DllMain(HINSTANCE hInst,
+BOOL DllMain(HINSTANCE hInst,
                        DWORD dwReason,
                        LPVOID lpReserved) {
 	logOutput.Print(&quot;----\nunitsync loaded\n&quot;);
@@ -128,29 +130,17 @@
 };
 
 
-/**
- * @brief returns the version fo spring this was compiled with
- *
- * Returns a const char* string specifying the version of spring used to build this library with.
- * It was added to aid in lobby creation, where checks for updates to spring occur.
- */
-DLL_EXPORT const char* __stdcall GetSpringVersion()
+const char* GetSpringVersion()
 {
 	return VERSION_STRING;
 }
 
-/**
- * @brief Creates a messagebox with said message
- * @param p_szMessage const char* string holding the message
- *
- * Creates a messagebox with the title &quot;Message from DLL&quot;, an OK button, and the specified message
- */
-DLL_EXPORT void __stdcall Message(const char* p_szMessage)
+void Message(const char* p_szMessage)
 {
 	MessageBox(NULL, p_szMessage, &quot;Message from DLL&quot;, MB_OK);
 }
 
-DLL_EXPORT void __stdcall UnInit()
+void UnInit()
 {
 	lpClose();
 
@@ -166,7 +156,7 @@
 	ConfigHandler::Deallocate();
 }
 
-DLL_EXPORT int __stdcall Init(bool isServer, int id)
+int Init(bool isServer, int id)
 {
 	UnInit();
 	logOutput.Print(&quot;unitsync initialized\n&quot;);
@@ -191,32 +181,19 @@
 	return 1;
 }
 
-/**
- * @brief process another unit and return how many are left to process
- * @return int The number of unprocessed units to be handled
- *
- * Call this function repeatedly untill it returns 0 before calling any other function related to units.
- */
-DLL_EXPORT int __stdcall ProcessUnits(void)
+int ProcessUnits(void)
 {
 	logOutput.Print(&quot;syncer: process units\n&quot;);
 	return syncer-&gt;ProcessUnits();
 }
 
-/**
- * @brief process another unit and return how many are left to process without checksumming
- * @return int The number of unprocessed units to be handled
- *
- * Call this function repeatedly untill it returns 0 before calling any other function related to units.
- * This function performs the same operations as ProcessUnits() but it does not generate checksums.
- */
-DLL_EXPORT int __stdcall ProcessUnitsNoChecksum(void)
+int ProcessUnitsNoChecksum(void)
 {
 	logOutput.Print(&quot;syncer: process units\n&quot;);
 	return syncer-&gt;ProcessUnits(false);
 }
 
-DLL_EXPORT const char * __stdcall GetCurrentList()
+const char* GetCurrentList()
 {
 	logOutput.Print(&quot;syncer: get current list\n&quot;);
 	string tmp = syncer-&gt;GetCurrentList();
@@ -236,79 +213,52 @@
 	return GetStr(tmp);
 }
 
-DLL_EXPORT void __stdcall AddClient(int id, const char *unitList)
+void AddClient(int id, const char *unitList)
 {
 	logOutput.Print(&quot;syncer: add client\n&quot;);
 	((CSyncServer *)syncer)-&gt;AddClient(id, unitList);
 }
 
-DLL_EXPORT void __stdcall RemoveClient(int id)
+void RemoveClient(int id)
 {
 	logOutput.Print(&quot;syncer: remove client\n&quot;);
 	((CSyncServer *)syncer)-&gt;RemoveClient(id);
 }
 
-DLL_EXPORT const char * __stdcall GetClientDiff(int id)
+const char* GetClientDiff(int id)
 {
 	logOutput.Print(&quot;syncer: get client diff\n&quot;);
 	string tmp = ((CSyncServer *)syncer)-&gt;GetClientDiff(id);
 	return GetStr(tmp);
 }
 
-DLL_EXPORT void __stdcall InstallClientDiff(const char *diff)
+void InstallClientDiff(const char *diff)
 {
 	logOutput.Print(&quot;syncer: install client diff\n&quot;);
 	syncer-&gt;InstallClientDiff(diff);
 }
 
-/**
- * @brief returns the number of units
- * @return int number of units processed and available
- *
- * Will return the number of units. Remember to call processUnits() beforehand untill it returns 0
- * As ProcessUnits is called the number of processed units goes up, and so will the value returned
- * by this function.
- *
- * while(processUnits()){}
- * int unit_number = GetUnitCount();
- */
-DLL_EXPORT int __stdcall GetUnitCount()
+int GetUnitCount()
 {
 	logOutput.Print(&quot;syncer: get unit count\n&quot;);
 	return syncer-&gt;GetUnitCount();
 }
 
-/**
- * @brief returns the units internal mod name
- * @param int the units id number
- * @return const char* The units internal modname
- *
- * This function returns the units internal mod name. For example it would return armck and not
- * Arm Construction kbot.
- */
-DLL_EXPORT const char * __stdcall GetUnitName(int unit)
+const char* GetUnitName(int unit)
 {
 	logOutput.Print(&quot;syncer: get unit %d name\n&quot;, unit);
 	string tmp = syncer-&gt;GetUnitName(unit);
 	return GetStr(tmp);
 }
 
-/**
- * @brief returns The units human readable name
- * @param int The units id number
- * @return const char* The Units human readable name
- *
- * This function returns the units human name. For example it would return Arm Construction kbot
- * and not armck.
- */
-DLL_EXPORT const char * __stdcall GetFullUnitName(int unit)
+const char* GetFullUnitName(int unit)
 {
 	logOutput.Print(&quot;syncer: get full unit %d name\n&quot;, unit);
 	string tmp = syncer-&gt;GetFullUnitName(unit);
 	return GetStr(tmp);
 }
 
-DLL_EXPORT int __stdcall IsUnitDisabled(int unit)
+int IsUnitDisabled(int unit)
 {
 	logOutput.Print(&quot;syncer: is unit %d disabled\n&quot;, unit);
 	if (syncer-&gt;IsUnitDisabled(unit))
@@ -317,7 +267,7 @@
 		return 0;
 }
 
-DLL_EXPORT int __stdcall IsUnitDisabledByClient(int unit, int clientId)
+int IsUnitDisabledByClient(int unit, int clientId)
 {
 	logOutput.Print(&quot;syncer: is unit %d disabled by client %d\n&quot;, unit, clientId);
 	if (syncer-&gt;IsUnitDisabledByClient(unit, clientId))
@@ -329,14 +279,14 @@
 //////////////////////////
 //////////////////////////
 
-DLL_EXPORT void __stdcall AddArchive(const char* name)
+void AddArchive(const char* name)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before AddArchive.&quot;);
 	ASSERT(name &amp;&amp; *name, &quot;Don't pass a NULL pointer or an empty string to AddArchive.&quot;);
 	vfsHandler-&gt;AddArchive(name, false);
 }
 
-DLL_EXPORT void __stdcall AddAllArchives(const char* root)
+void AddAllArchives(const char* root)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before AddAllArchives.&quot;);
 	ASSERT(root &amp;&amp; *root, &quot;Don't pass a NULL pointer or an empty string to AddAllArchives.&quot;);
@@ -348,7 +298,7 @@
 	}
 }
 
-DLL_EXPORT unsigned int __stdcall GetArchiveChecksum(const char* arname)
+unsigned int GetArchiveChecksum(const char* arname)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetArchiveChecksum.&quot;);
 	ASSERT(arname &amp;&amp; *arname, &quot;Don't pass a NULL pointer or an empty string to GetArchiveChecksum.&quot;);
@@ -356,7 +306,7 @@
 	return archiveScanner-&gt;GetArchiveChecksum(arname);
 }
 
-DLL_EXPORT const char* __stdcall GetArchivePath(const char* arname)
+const char* GetArchivePath(const char* arname)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetArchivePath.&quot;);
 	ASSERT(arname &amp;&amp; *arname, &quot;Don't pass a NULL pointer or an empty string to GetArchivePath.&quot;);
@@ -364,10 +314,10 @@
 	return GetStr(archiveScanner-&gt;GetArchivePath(arname));
 }
 
-// Updated on every call to getmapcount
+// Updated on every call to GetMapCount
 static vector&lt;string&gt; mapNames;
 
-DLL_EXPORT int __stdcall GetMapCount()
+int GetMapCount()
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapCount.&quot;);
 	//vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;{maps/*.smf,maps/*.sm3}&quot;);
@@ -391,7 +341,7 @@
 	return mapNames.size();
 }
 
-DLL_EXPORT const char* __stdcall GetMapName(int index)
+const char* GetMapName(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapName.&quot;);
 	ASSERT((unsigned)index &lt; mapNames.size(), &quot;Array index out of bounds. Call GetMapCount before GetMapName.&quot;);
@@ -399,7 +349,7 @@
 }
 
 
-DLL_EXPORT int __stdcall GetMapInfoEx(const char* name, MapInfo* outInfo, int version)
+int GetMapInfoEx(const char* name, MapInfo* outInfo, int version)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapInfo.&quot;);
 	ASSERT(name &amp;&amp; *name &amp;&amp; outInfo, &quot;Don't pass a NULL pointer or an empty string to GetMapInfo.&quot;);
@@ -497,35 +447,35 @@
 }
 
 
-DLL_EXPORT int __stdcall GetMapInfo(const char* name, MapInfo* outInfo)
+int GetMapInfo(const char* name, MapInfo* outInfo)
 {
 	return GetMapInfoEx(name, outInfo, 0);
 }
 
 static vector&lt;string&gt; mapArchives;
 
-DLL_EXPORT int __stdcall GetMapArchiveCount(const char* mapName)
+int GetMapArchiveCount(const char* mapName)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapArchiveCount.&quot;);
 	mapArchives = archiveScanner-&gt;GetArchivesForMap(mapName);
 	return mapArchives.size();
 }
 
-DLL_EXPORT const char* __stdcall GetMapArchiveName(int index)
+const char* GetMapArchiveName(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapArchiveName.&quot;);
 	ASSERT((unsigned)index &lt; mapArchives.size(), &quot;Array index out of bounds. Call GetMapArchiveCount before GetMapArchiveName.&quot;);
 	return GetStr(mapArchives[index]);
 }
 
-DLL_EXPORT unsigned int __stdcall GetMapChecksum(int index)
+unsigned int GetMapChecksum(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapChecksum.&quot;);
 	ASSERT((unsigned)index &lt; mapNames.size(), &quot;Array index out of bounds. Call GetMapCount before GetMapChecksum.&quot;);
 	return archiveScanner-&gt;GetMapChecksum(mapNames[index]);
 }
 
-DLL_EXPORT unsigned int __stdcall GetMapChecksumFromName(const char* mapName)
+unsigned int GetMapChecksumFromName(const char* mapName)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapChecksumFromName.&quot;);
 	return archiveScanner-&gt;GetMapChecksum(mapName);
@@ -695,23 +645,7 @@
 	return (void*)ret;
 }
 
-/**
- * @brief Retrieves a minimap image for a map.
- * @param filename The name of the map, including extension.
- * @param miplevel Which miplevel of the minimap to extract from the file.
- * Set miplevel to 0 to get the largest, 1024x1024 minimap. Each increment
- * divides the width and height by 2. The maximum miplevel is 8, resulting in a
- * 4x4 image.
- * @return A pointer to a static memory area containing the minimap as a 16 bit
- * packed RGB-565 (MSB to LSB: 5 bits red, 6 bits green, 5 bits blue) linear
- * bitmap.
- *
- * An example usage would be GetMinimap(&quot;SmallDivide.smf&quot;, 2).
- * This would return a 16 bit packed RGB-565 256x256 (= 1024/2^2) bitmap.
- *
- * Be sure you've made a calls to Init prior to using this.
- */
-DLL_EXPORT void* __stdcall GetMinimap(const char* filename, int miplevel)
+void* GetMinimap(const char* filename, int miplevel)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMinimap.&quot;);
 	ASSERT(filename &amp;&amp; *filename, &quot;Don't pass a NULL pointer or an empty string to GetMinimap.&quot;);
@@ -740,14 +674,7 @@
 vector&lt;CArchiveScanner::ModData&gt; modData;
 
 
-/**
- * @brief Retrieves the name of this mod
- * @return int The number of mods
- *
- * Returns the name of the mod usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT int __stdcall GetPrimaryModCount()
+int GetPrimaryModCount()
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModCount.&quot;);
 	modData = archiveScanner-&gt;GetPrimaryMods();
@@ -755,15 +682,7 @@
 }
 
 
-/**
- * @brief Retrieves the name of this mod
- * @param index in The mods index/id
- * @return const char* The mods name
- *
- * Returns the name of the mod usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModName(int index)
+const char* GetPrimaryModName(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModName.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModName.&quot;);
@@ -772,15 +691,7 @@
 }
 
 
-/**
- * @brief Retrieves the shortened name of this mod
- * @param index in The mods index/id
- * @return const char* The mods abbrieviated name
- *
- * Returns the shortened name of the mod usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModShortName(int index)
+const char* GetPrimaryModShortName(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModShortName.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModShortName.&quot;);
@@ -789,15 +700,7 @@
 }
 
 
-/**
- * @brief Retrieves the version string of this mod
- * @param index in The mods index/id
- * @return const char* The mods version string
- *
- * Returns value of the mutator tag for the specified mod usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModVersion(int index)
+const char* GetPrimaryModVersion(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModVersion.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModMutator.&quot;);
@@ -806,15 +709,7 @@
 }
 
 
-/**
- * @brief Retrieves the mutator name of this mod
- * @param index in The mods index/id
- * @return const char* The mods mutator name
- *
- * Returns value of the mutator tag for the specified mod usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModMutator(int index)
+const char* GetPrimaryModMutator(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModMutator.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModMutator.&quot;);
@@ -823,15 +718,7 @@
 }
 
 
-/**
- * @brief Retrieves the game name of this mod
- * @param index in The mods index/id
- * @return const char* The mods game
- *
- * Returns the name of the game this mod belongs to usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModGame(int index)
+const char* GetPrimaryModGame(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModName.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModName.&quot;);
@@ -840,15 +727,7 @@
 }
 
 
-/**
- * @brief Retrieves the short game name of this mod
- * @param index in The mods index/id
- * @return const char* The mods abbrieviated game name
- *
- * Returns the abbrieviated name of the game this mod belongs to usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModShortGame(int index)
+const char* GetPrimaryModShortGame(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModShortGame.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModShortGame.&quot;);
@@ -857,15 +736,7 @@
 }
 
 
-/**
- * @brief Retrieves the description of this mod
- * @param index in The mods index/id
- * @return const char* The mods description
- *
- * Returns a description for the specified mod usually found in modinfo.tdf.
- * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModDescription(int index)
+const char* GetPrimaryModDescription(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModDescription.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModDescription.&quot;);
@@ -874,7 +745,7 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetPrimaryModArchive(int index)
+const char* GetPrimaryModArchive(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModArchive.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModArchive.&quot;);
@@ -884,17 +755,7 @@
 
 vector&lt;string&gt; primaryArchives;
 
-/**
- * @brief Retrieves the number of archives a mod requires
- * @param index int The index of the mod
- * @return the number of archives this mod depends on.
- *
- * This is used to get the entire list of archives that a mod requires.
- * Call GetPrimaryModArchiveCount() with selected mod first to get number of
- * archives, and then use GetPrimaryModArchiveList() for 0 to count-1 to get the
- * name of each archive.
- */
-DLL_EXPORT int __stdcall GetPrimaryModArchiveCount(int index)
+int GetPrimaryModArchiveCount(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModArchiveCount.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModArchiveCount.&quot;);
@@ -902,21 +763,15 @@
 	return primaryArchives.size();
 }
 
-/**
- * @brief Retrieves the name of the current mod's archive.
- * @param arnr The mod's archive index/id.
- * @return the name of the archive
- * @see GetPrimaryModArchiveCount()
- */
-DLL_EXPORT const char* __stdcall GetPrimaryModArchiveList(int arnr)
+const char* GetPrimaryModArchiveList(int archiveNr)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModArchiveList.&quot;);
-	ASSERT((unsigned)arnr &lt; primaryArchives.size(), &quot;Array index out of bounds. Call GetPrimaryModArchiveCount before GetPrimaryModArchiveList.&quot;);
-	logOutput.Print(&quot;primary mod archive list: %s\n&quot;, primaryArchives[arnr].c_str());
-	return GetStr(primaryArchives[arnr]);
+	ASSERT((unsigned)archiveNr &lt; primaryArchives.size(), &quot;Array index out of bounds. Call GetPrimaryModArchiveCount before GetPrimaryModArchiveList.&quot;);
+	logOutput.Print(&quot;primary mod archive list: %s\n&quot;, primaryArchives[archiveNr].c_str());
+	return GetStr(primaryArchives[archiveNr]);
 }
 
-DLL_EXPORT int __stdcall GetPrimaryModIndex(const char* name)
+int GetPrimaryModIndex(const char* name)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModIndex.&quot;);
 	string n(name);
@@ -928,14 +783,14 @@
 	return -1;
 }
 
-DLL_EXPORT unsigned int __stdcall GetPrimaryModChecksum(int index)
+unsigned int GetPrimaryModChecksum(int index)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModChecksum.&quot;);
 	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModChecksum.&quot;);
 	return archiveScanner-&gt;GetModChecksum(GetPrimaryModArchive(index));
 }
 
-DLL_EXPORT unsigned int __stdcall GetPrimaryModChecksumFromName(const char* name)
+unsigned int GetPrimaryModChecksumFromName(const char* name)
 {
 	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetPrimaryModChecksumFromName.&quot;);
 	return archiveScanner-&gt;GetModChecksum(archiveScanner-&gt;ModNameToModArchive(name));
@@ -945,7 +800,7 @@
 //////////////////////////
 //////////////////////////
 
-DLL_EXPORT int __stdcall GetSideCount()
+int GetSideCount()
 {
 	if (!sideParser.Load()) {
 		logOutput.Print(&quot;failed: %s\n&quot;, sideParser.GetErrorLog().c_str());
@@ -955,7 +810,7 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetSideName(int side)
+const char* GetSideName(int side)
 {
 	ASSERT((unsigned int)side &lt; sideParser.GetCount(),
 	       &quot;Array index out of bounds. Call GetSideCount before GetSideName.&quot;);
@@ -964,7 +819,7 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetSideStartUnit(int side)
+const char* GetSideStartUnit(int side)
 {
 	ASSERT((unsigned int)side &lt; sideParser.GetCount(),
 	       &quot;Array index out of bounds. Call GetSideCount before GetSideStartUnit.&quot;);
@@ -1026,25 +881,25 @@
 }
 
 
-DLL_EXPORT int __stdcall GetLuaAICount()
+int GetLuaAICount()
 {
 	GetLuaAIOptions();
 	return luaAIOptions.size();
 }
 
 
-DLL_EXPORT const char* __stdcall GetLuaAIName(int aiIndex)
+const char* GetLuaAIName(int aiIndex)
 {
-	if ((aiIndex &lt; 0) || (aiIndex &gt;= luaAIOptions.size())) {
+	if ((aiIndex &lt; 0) || (aiIndex &gt;= (int)luaAIOptions.size())) {
 		return NULL;
 	}
 	return GetStr(luaAIOptions[aiIndex].name);
 }
 
 
-DLL_EXPORT const char* __stdcall GetLuaAIDesc(int aiIndex)
+const char* GetLuaAIDesc(int aiIndex)
 {
-	if ((aiIndex &lt; 0) || (aiIndex &gt;= luaAIOptions.size())) {
+	if ((aiIndex &lt; 0) || (aiIndex &gt;= (int)luaAIOptions.size())) {
 		return NULL;
 	}
 	return GetStr(luaAIOptions[aiIndex].desc);
@@ -1054,9 +909,10 @@
 //////////////////////////
 //////////////////////////
 
-static const char* badKeyChars = &quot; =;\r\n\t&quot;;
+//static const char* badKeyChars = &quot; =;\r\n\t&quot;;
 
 
+/*
 struct ListItem {
 	string key;
 	string name;
@@ -1088,11 +944,12 @@
 	string listDef;
 	vector&lt;ListItem&gt; list;
 };
+*/
 
 
 static vector&lt;Option&gt; options;
-static set&lt;string&gt; optionsSet;
 
+/*
 
 static bool ParseOption(const LuaTable&amp; root, int index, Option&amp; opt)
 {
@@ -1102,42 +959,47 @@
 	}
 
 	// common options properties
-	opt.key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
-	if (opt.key.empty() ||
-	    (opt.key.find_first_of(badKeyChars) != string::npos)) {
+	string opt_key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
+	if (opt_key.empty() ||
+	    (opt_key.find_first_of(badKeyChars) != string::npos)) {
 		return false;
 	}
-	opt.key = StringToLower(opt.key);
-	if (optionsSet.find(opt.key) != optionsSet.end()) {
+	opt_key = StringToLower(opt_key);
+	if (optionsSet.find(opt_key) != optionsSet.end()) {
 		return false;
 	}
-	opt.name = optTbl.GetString(&quot;name&quot;, opt.key);
-	if (opt.name.empty()) {
+	opt.key = opt_key.c_str();
+	string opt_name = optTbl.GetString(&quot;name&quot;, opt_key);
+	if (opt_name.empty()) {
 		return false;
 	}
-	opt.desc = optTbl.GetString(&quot;desc&quot;, opt.name);
+	opt.name = opt_name.c_str();
+	string opt_desc = optTbl.GetString(&quot;desc&quot;, opt_name);
+	opt.desc = opt_desc.c_str();
+	
 
-	opt.type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
-	opt.type = StringToLower(opt.type);
+	string opt_type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
+	opt_type = StringToLower(opt_type);
+	opt.type = opt_type.c_str();
 
 	// option type specific properties
-	if (opt.type == &quot;bool&quot;) {
+	if (opt_type == &quot;bool&quot;) {
 		opt.typeCode = opt_bool;
 		opt.boolDef = optTbl.GetBool(&quot;def&quot;, false);
 	}
-	else if (opt.type == &quot;number&quot;) {
+	else if (opt_type == &quot;number&quot;) {
 		opt.typeCode = opt_number;
 		opt.numberDef  = optTbl.GetFloat(&quot;def&quot;,  0.0f);
 		opt.numberMin  = optTbl.GetFloat(&quot;min&quot;,  -1.0e30f);
 		opt.numberMax  = optTbl.GetFloat(&quot;max&quot;,  +1.0e30f);
 		opt.numberStep = optTbl.GetFloat(&quot;step&quot;, 0.0f);
 	}
-	else if (opt.type == &quot;string&quot;) {
+	else if (opt_type == &quot;string&quot;) {
 		opt.typeCode = opt_string;
-		opt.stringDef    = optTbl.GetString(&quot;def&quot;, &quot;&quot;);
+		opt.stringDef    = optTbl.GetString(&quot;def&quot;, &quot;&quot;).c_str();
 		opt.stringMaxLen = optTbl.GetInt(&quot;maxlen&quot;, 0);
 	}
-	else if (opt.type == &quot;list&quot;) {
+	else if (opt_type == &quot;list&quot;) {
 		opt.typeCode = opt_list;
 
 		const LuaTable&amp; listTbl = optTbl.SubTable(&quot;items&quot;);
@@ -1145,16 +1007,18 @@
 			return false;
 		}
 
+		vector&lt;OptionListItem&gt; opt_list;
 		for (int i = 1; listTbl.KeyExists(i); i++) {
-			ListItem item;
+			OptionListItem item;
 
 			// string format
-			item.key = listTbl.GetString(i, &quot;&quot;);
-			if (!item.key.empty() &amp;&amp;
-			    (item.key.find_first_of(badKeyChars) == string::npos)) {
+			string item_key = listTbl.GetString(i, &quot;&quot;);
+			if (!item_key.empty() &amp;&amp;
+			    (item_key.find_first_of(badKeyChars) == string::npos)) {
+				item.key = item_key.c_str();
 				item.name = item.key;
 				item.desc = item.name;
-				opt.list.push_back(item);
+				opt_list.push_back(item);
 				continue;
 			}
 
@@ -1163,25 +1027,34 @@
 			if (!itemTbl.IsValid()) {
 				break;
 			}
-			item.key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
-			if (item.key.empty() ||
-			    (item.key.find_first_of(badKeyChars) != string::npos)) {
+			item_key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
+			if (item_key.empty() ||
+			    (item_key.find_first_of(badKeyChars) != string::npos)) {
 				return false;
 			}
-			item.key = StringToLower(item.key);
-			item.name = itemTbl.GetString(&quot;name&quot;, item.key);
-			if (item.name.empty()) {
+			item_key = StringToLower(item_key);
+			item.key = item_key.c_str();
+			string item_name = itemTbl.GetString(&quot;name&quot;, item_key);
+			if (item_name.empty()) {
 				return false;
 			}
-			item.desc = itemTbl.GetString(&quot;desc&quot;, item.name);
-			opt.list.push_back(item);
+			item.name = item_name.c_str();
+			string item_desc = itemTbl.GetString(&quot;desc&quot;, item_name);
+			item.desc = item_desc.c_str();
+			opt_list.push_back(item);
 		}
 
-		if (opt.list.size() &lt;= 0) {
+		if (opt_list.size() &lt;= 0) {
 			return false; // no empty lists
 		}
+		
+		opt.numListItems = opt_list.size();
+		opt.list = (OptionListItem*) calloc(sizeof(OptionListItem), opt.numListItems);
+        for (int i=0; i &lt; opt.numListItems; ++i) {
+            opt.list[i] = opt_list.at(i);
+        }
 
-		opt.listDef = optTbl.GetString(&quot;def&quot;, opt.list[0].name);
+		opt.listDef = optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str();
 	}
 	else {
 		return false; // unknown type
@@ -1234,8 +1107,9 @@
 	optionsSet.clear();
 
 	return;
-};
+}
 
+*/
 
 static bool InvalidOptionIndex(int optIndex)
 {
@@ -1258,8 +1132,91 @@
 }
 
 
-DLL_EXPORT int __stdcall GetMapOptionCount(const char* name)
+vector&lt;InfoItem&gt; infos;
+set&lt;string&gt; infosSet;
+/*
+static bool ParseInfo(const LuaTable&amp; root, int index, InfoItem&amp; info)
 {
+	const LuaTable&amp; infoTbl = root.SubTable(index);
+	if (!infoTbl.IsValid()) {
+		return false;
+	}
+
+	// info properties
+	info.key = infoTbl.GetString(&quot;key&quot;, &quot;&quot;);
+	if (info.key.empty() ||
+	    (info.key.find_first_of(badKeyChars) != string::npos)) {
+		return false;
+	}
+	string keyLower = StringToLower(info.key);
+	if (infosSet.find(keyLower) != infosSet.end()) {
+		return false;
+	}
+	
+	info.value = infoTbl.GetString(&quot;value&quot;, &quot;&quot;);
+	if (info.value.empty()) {
+		return false;
+	}
+	
+	info.desc = infoTbl.GetString(&quot;desc&quot;, &quot;&quot;);
+
+	infosSet.insert(keyLower);
+
+	return true;
+}
+
+static void ParseInfos(const string&amp; fileName,
+                         const string&amp; fileModes,
+                         const string&amp; accessModes)
+{
+	infos.clear();
+	
+	LuaParser luaParser(fileName, fileModes, accessModes);
+		
+	if (!luaParser.Execute()) {
+		printf(&quot;ParseInfos(%s) ERROR: %s\n&quot;,
+		       fileName.c_str(), luaParser.GetErrorLog().c_str());
+		return;
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+	if (!root.IsValid()) {
+		return;
+	}
+
+	infosSet.clear();
+	for (int index = 1; root.KeyExists(index); index++) {
+		InfoItem info;
+		if (ParseInfo(root, index, info)) {
+			infos.push_back(info);
+		}
+	}
+	infosSet.clear();
+}
+*/
+
+
+std::vector&lt;Option&gt; ParseOptions(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes,
+		const std::string&amp; mapName = &quot;&quot;)
+{
+	std::vector&lt;Option&gt; options;
+	
+	static const unsigned int MAX_OPTIONS = 128;
+	Option tmpOptions[MAX_OPTIONS];
+	unsigned int num = ParseOptions(fileName.c_str(), fileModes.c_str(),
+			accessModes.c_str(), mapName.c_str(), tmpOptions, MAX_OPTIONS);
+	for (unsigned int i=0; i &lt; num; ++i) {
+		options.push_back(tmpOptions[i]);
+    }
+	
+	return options;
+}
+
+int GetMapOptionCount(const char* name)
+{
 	ASSERT(archiveScanner &amp;&amp; vfsHandler,
 	       &quot;Call InitArchiveScanner before GetMapOptionCount.&quot;);
 	ASSERT(name &amp;&amp; *name,
@@ -1267,23 +1224,114 @@
 
 	ScopedMapLoader mapLoader(name);
 
-	ParseOptions(&quot;MapOptions.lua&quot;, SPRING_VFS_MAP, SPRING_VFS_MAP, name);
+	options = ParseOptions(&quot;MapOptions.lua&quot;, SPRING_VFS_MAP, SPRING_VFS_MAP, name);
 
 	return (int)options.size();
 }
 
 
-DLL_EXPORT int __stdcall GetModOptionCount()
+int GetModOptionCount()
 {
-	ParseOptions(&quot;ModOptions.lua&quot;, SPRING_VFS_MOD, SPRING_VFS_MOD);
+	options = ParseOptions(&quot;ModOptions.lua&quot;, SPRING_VFS_MOD, SPRING_VFS_MOD);
 	return (int)options.size();
 }
 
 
-// Common Parameters
+// Updated on every call to GetSkirmishAICount
+static vector&lt;string&gt; skirmishAIDataDirs;
 
-DLL_EXPORT const char* __stdcall GetOptionKey(int optIndex)
+int GetSkirmishAICount() {
+	
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetSkirmishAICount.&quot;);
+	
+	skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
+	
+	// filter out dirs not containing an AIInfo.lua file 
+	for (vector&lt;string&gt;::iterator i = skirmishAIDataDirs.begin(); i != skirmishAIDataDirs.end(); ++i) {
+		const string&amp; possibleDataDir = *i;
+		vector&lt;string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+		if (infoFile.size() == 0) {
+			skirmishAIDataDirs.erase(i);
+		}
+	}
+	
+	sort(skirmishAIDataDirs.begin(), skirmishAIDataDirs.end());
+
+	return skirmishAIDataDirs.size();
+}
+
+struct SSAISpecifyer GetSkirmishAISpecifyer(int index) {
+	
+	SSAISpecifyer spec = {NULL, NULL};
+	
+	int num = GetSkirmishAIInfoCount(index);
+	
+	for (int i=0; i &lt; num; ++i) {
+		string info_key = string(GetInfoKey(i));
+		if (info_key == SKIRMISH_AI_PROPERTY_SHORT_NAME) {
+			spec.shortName = GetInfoValue(i);
+		} else if (info_key == SKIRMISH_AI_PROPERTY_VERSION) {
+			spec.version = GetInfoValue(i);
+		}
+	}
+	
+	return spec;
+}
+
+std::vector&lt;InfoItem&gt; ParseInfos(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes)
 {
+	std::vector&lt;InfoItem&gt; infos;
+	
+	static const unsigned int MAX_INFOS = 128;
+	InfoItem tmpInfos[MAX_INFOS];
+	unsigned int num = ParseInfos(fileName.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfos, MAX_INFOS);
+	for (unsigned int i=0; i &lt; num; ++i) {
+		infos.push_back(tmpInfos[i]);
+    }
+	
+	return infos;
+}
+
+int GetSkirmishAIInfoCount(int index) {
+	
+	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetSkirmishAIInfoCount.&quot;);
+	infos = ParseInfos(skirmishAIDataDirs[index] + &quot;/AIInfo.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+	return (int)infos.size();
+}
+const char* GetInfoKey(int index) {
+	
+	ASSERT(!infos.empty(), &quot;Call GetSkirmishAIInfoCount before GetInfoKey.&quot;);
+	return infos.at(index).key;
+}
+const char* GetInfoValue(int index) {
+	
+	ASSERT(!infos.empty(), &quot;Call GetSkirmishAIInfoCount before GetInfoValue.&quot;);
+	return infos.at(index).value;
+}
+const char* GetInfoDescription(int index) {
+	
+	ASSERT(!infos.empty(), &quot;Call GetSkirmishAIInfoCount before GetInfoDescription.&quot;);
+	return infos.at(index).desc;
+}
+//struct LevelOfSupport GetSkirmishAILevelOfSupport(int index, const char* engineVersionString, int engineVersionNumber, const char* aiInterfaceShortName, const char* aiInterfaceVersion) {}
+
+
+
+int GetSkirmishAIOptionCount(int index) {
+//int GetSkirmishAIOptionCount(const char* shortName, const char* version = NULL) {
+	
+	ASSERT(!skirmishAIDataDirs.empty(), &quot;Call GetSkirmishAICount before GetSkirmishAIOptionCount.&quot;);
+	//SSAISpecifyer spec = {shortName, version};
+	options = ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+	return (int)options.size();
+}
+
+
+const char* GetOptionKey(int optIndex)
+{
 	if (InvalidOptionIndex(optIndex)) {
 		return NULL;
 	}
@@ -1291,7 +1339,7 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetOptionName(int optIndex)
+const char* GetOptionName(int optIndex)
 {
 	if (InvalidOptionIndex(optIndex)) {
 		return NULL;
@@ -1300,7 +1348,7 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetOptionDesc(int optIndex)
+const char* GetOptionDesc(int optIndex)
 {
 	if (InvalidOptionIndex(optIndex)) {
 		return NULL;
@@ -1309,7 +1357,7 @@
 }
 
 
-DLL_EXPORT int __stdcall GetOptionType(int optIndex)
+int GetOptionType(int optIndex)
 {
 	if (InvalidOptionIndex(optIndex)) {
 		return 0;
@@ -1318,9 +1366,7 @@
 }
 
 
-// Bool Options
-
-DLL_EXPORT int __stdcall GetOptionBoolDef(int optIndex)
+int GetOptionBoolDef(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_bool)) {
 		return 0;
@@ -1329,9 +1375,7 @@
 }
 
 
-// Number Options
-
-DLL_EXPORT float __stdcall GetOptionNumberDef(int optIndex)
+float GetOptionNumberDef(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_number)) {
 		return 0.0f;
@@ -1340,7 +1384,7 @@
 }
 
 
-DLL_EXPORT float __stdcall GetOptionNumberMin(int optIndex)
+float GetOptionNumberMin(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_number)) {
 		return -1.0e30f; // FIXME ?
@@ -1349,7 +1393,7 @@
 }
 
 
-DLL_EXPORT float __stdcall GetOptionNumberMax(int optIndex)
+float GetOptionNumberMax(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_number)) {
 		return +1.0e30f; // FIXME ?
@@ -1358,7 +1402,7 @@
 }
 
 
-DLL_EXPORT float __stdcall GetOptionNumberStep(int optIndex)
+float GetOptionNumberStep(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_number)) {
 		return 0.0f;
@@ -1367,9 +1411,7 @@
 }
 
 
-// String Options
-
-DLL_EXPORT const char* __stdcall GetOptionStringDef(int optIndex)
+const char* GetOptionStringDef(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_string)) {
 		return NULL;
@@ -1378,7 +1420,7 @@
 }
 
 
-DLL_EXPORT int __stdcall GetOptionStringMaxLen(int optIndex)
+int GetOptionStringMaxLen(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_string)) {
 		return 0;
@@ -1387,18 +1429,16 @@
 }
 
 
-// List Options
-
-DLL_EXPORT int __stdcall GetOptionListCount(int optIndex)
+int GetOptionListCount(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_list)) {
 		return 0;
 	}
-	return options[optIndex].list.size();
+	return options[optIndex].numListItems;
 }
 
 
-DLL_EXPORT const char* __stdcall GetOptionListDef(int optIndex)
+const char* GetOptionListDef(int optIndex)
 {
 	if (WrongOptionType(optIndex, opt_list)) {
 		return 0;
@@ -1407,42 +1447,42 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetOptionListItemKey(int optIndex, int itemIndex)
+const char* GetOptionListItemKey(int optIndex, int itemIndex)
 {
 	if (WrongOptionType(optIndex, opt_list)) {
 		return NULL;
 	}
-	const vector&lt;ListItem&gt;&amp; list = options[optIndex].list;
-	if ((itemIndex &lt; 0) || (itemIndex &gt;= (int)list.size())) {
+	//const vector&lt;OptionListItem&gt;&amp; list = options[optIndex].list;
+	if ((itemIndex &lt; 0) || (itemIndex &gt;= options[optIndex].numListItems)) {
 		return NULL;
 	}
-	return GetStr(list[itemIndex].key);
+	return GetStr(options[optIndex].list[itemIndex].key);
 }
 
 
-DLL_EXPORT const char* __stdcall GetOptionListItemName(int optIndex, int itemIndex)
+const char* GetOptionListItemName(int optIndex, int itemIndex)
 {
 	if (WrongOptionType(optIndex, opt_list)) {
 		return NULL;
 	}
-	const vector&lt;ListItem&gt;&amp; list = options[optIndex].list;
-	if ((itemIndex &lt; 0) || (itemIndex &gt;= (int)list.size())) {
+	//const vector&lt;OptionListItem&gt;&amp; list = options[optIndex].list;
+	if ((itemIndex &lt; 0) || (itemIndex &gt;= options[optIndex].numListItems)) {
 		return NULL;
 	}
-	return GetStr(list[itemIndex].name);
+	return GetStr(options[optIndex].list[itemIndex].name);
 }
 
 
-DLL_EXPORT const char* __stdcall GetOptionListItemDesc(int optIndex, int itemIndex)
+const char* GetOptionListItemDesc(int optIndex, int itemIndex)
 {
 	if (WrongOptionType(optIndex, opt_list)) {
 		return NULL;
 	}
-	const vector&lt;ListItem&gt;&amp; list = options[optIndex].list;
-	if ((itemIndex &lt; 0) || (itemIndex &gt;= (int)list.size())) {
+	//const vector&lt;OptionListItem&gt;&amp; list = options[optIndex].list;
+	if ((itemIndex &lt; 0) || (itemIndex &gt;= options[optIndex].numListItems)) {
 		return NULL;
 	}
-	return GetStr(list[itemIndex].desc);
+	return GetStr(options[optIndex].list[itemIndex].desc);
 }
 
 
@@ -1527,9 +1567,7 @@
 }
 
 
-// A return value of 0 means that any map can be selected
-// Map names should be complete  (including the .smf or .sm3 extension)
-DLL_EXPORT int __stdcall GetModValidMapCount()
+int GetModValidMapCount()
 {
 	modValidMaps.clear();
 
@@ -1558,9 +1596,9 @@
 }
 
 
-DLL_EXPORT const char* __stdcall GetModValidMap(int index)
+const char* GetModValidMap(int index)
 {
-	if ((index &lt; 0) || (index &gt;= modValidMaps.size())) {
+	if ((index &lt; 0) || (index &gt;= (int)modValidMaps.size())) {
 		return NULL;
 	}
 	return GetStr(modValidMaps[index]);
@@ -1570,13 +1608,12 @@
 //////////////////////////
 //////////////////////////
 
-// Map the wanted archives into the VFS with AddArchive before using these functions
 
 static map&lt;int, CFileHandler*&gt; openFiles;
 static int nextFile = 0;
 static vector&lt;string&gt; curFindFiles;
 
-DLL_EXPORT int __stdcall OpenFileVFS(const char* name)
+int OpenFileVFS(const char* name)
 {
 	ASSERT(name &amp;&amp; *name, &quot;Don't pass a NULL pointer or an empty string to OpenFileVFS.&quot;);
 	logOutput.Print(&quot;openfilevfs: %s\n&quot;, name);
@@ -1593,7 +1630,7 @@
 	return nextFile;
 }
 
-DLL_EXPORT void __stdcall CloseFileVFS(int handle)
+void CloseFileVFS(int handle)
 {
 	ASSERT(openFiles.find(handle) != openFiles.end(), &quot;Unregistered handle. Pass the handle returned by OpenFileVFS to CloseFileVFS.&quot;);
 	logOutput.Print(&quot;closefilevfs: %d\n&quot;, handle);
@@ -1601,7 +1638,7 @@
 	openFiles.erase(handle);
 }
 
-DLL_EXPORT void __stdcall ReadFileVFS(int handle, void* buf, int length)
+void ReadFileVFS(int handle, void* buf, int length)
 {
 	ASSERT(openFiles.find(handle) != openFiles.end(), &quot;Unregistered handle. Pass the handle returned by OpenFileVFS to ReadFileVFS.&quot;);
 	ASSERT(buf, &quot;Don't pass a NULL pointer to ReadFileVFS.&quot;);
@@ -1610,7 +1647,7 @@
 	fh-&gt;Read(buf, length);
 }
 
-DLL_EXPORT int __stdcall FileSizeVFS(int handle)
+int FileSizeVFS(int handle)
 {
 	ASSERT(openFiles.find(handle) != openFiles.end(), &quot;Unregistered handle. Pass the handle returned by OpenFileVFS to FileSizeVFS.&quot;);
 	logOutput.Print(&quot;filesizevfs: %d\n&quot;, handle);
@@ -1619,9 +1656,7 @@
 }
 
 
-// Does not currently support more than one call at a time (a new call to initfind destroys data from previous ones)
-// pass the returned handle to findfiles to get the results
-DLL_EXPORT int __stdcall InitFindVFS(const char* pattern)
+int InitFindVFS(const char* pattern)
 {
 	string path = filesystem.GetDirectory(pattern);
 	string patt = filesystem.GetFilename(pattern);
@@ -1630,9 +1665,7 @@
 	return 0;
 }
 
-// Does not currently support more than one call at a time (a new call to initfind destroys data from previous ones)
-// pass the returned handle to findfiles to get the results
-DLL_EXPORT int __stdcall InitDirListVFS(const char* path, const char* pattern, const char* modes)
+int InitDirListVFS(const char* path, const char* pattern, const char* modes)
 {
 	if (path    == NULL) { path = &quot;&quot;;              }
 	if (modes   == NULL) { modes = SPRING_VFS_ALL; }
@@ -1642,9 +1675,7 @@
 	return 0;
 }
 
-// Does not currently support more than one call at a time (a new call to initfind destroys data from previous ones)
-// pass the returned handle to findfiles to get the results
-DLL_EXPORT int __stdcall InitSubDirsVFS(const char* path, const char* pattern, const char* modes)
+int InitSubDirsVFS(const char* path, const char* pattern, const char* modes)
 {
 	if (path    == NULL) { path = &quot;&quot;;              }
 	if (modes   == NULL) { modes = SPRING_VFS_ALL; }
@@ -1654,9 +1685,7 @@
 	return 0;
 }
 
-// On first call, pass handle from initfind. pass the return value of this function on subsequent calls
-// until 0 is returned. size should be set to max namebuffer size on call
-DLL_EXPORT int __stdcall FindFilesVFS(int handle, char* nameBuf, int size)
+int FindFilesVFS(int handle, char* nameBuf, int size)
 {
 	ASSERT(nameBuf, &quot;Don't pass a NULL pointer to FindFilesVFS.&quot;);
 	ASSERT(size &gt; 0, &quot;Negative or zero buffer length doesn't make sense.&quot;);
@@ -1674,8 +1703,7 @@
 static map&lt;int, CArchiveBase*&gt; openArchives;
 static int nextArchive = 0;
 
-// returns 0 on error, a handle otherwise
-DLL_EXPORT int __stdcall OpenArchive(const char* name)
+int OpenArchive(const char* name)
 {
 	ASSERT(name &amp;&amp; *name, &quot;Don't pass a NULL pointer or an empty string to OpenArchive.&quot;);
 	CArchiveBase* a = CArchiveFactory::OpenArchive(name);
@@ -1689,8 +1717,7 @@
 	}
 }
 
-// returns 0 on error, a handle otherwise
-DLL_EXPORT int __stdcall OpenArchiveType(const char* name, const char* type)
+int OpenArchiveType(const char* name, const char* type)
 {
 	ASSERT(name &amp;&amp; *name &amp;&amp; type &amp;&amp; *type,
 	       &quot;Don't pass a NULL pointer or an empty string to OpenArchiveType.&quot;);
@@ -1705,14 +1732,14 @@
 	}
 }
 
-DLL_EXPORT void __stdcall CloseArchive(int archive)
+void CloseArchive(int archive)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to CloseArchive.&quot;);
 	delete openArchives[archive];
 	openArchives.erase(archive);
 }
 
-DLL_EXPORT int __stdcall FindFilesArchive(int archive, int cur, char* nameBuf, int* size)
+int FindFilesArchive(int archive, int cur, char* nameBuf, int* size)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to FindFilesArchive.&quot;);
 	ASSERT(nameBuf &amp;&amp; size, &quot;Don't pass a NULL pointer to FindFilesArchive.&quot;);
@@ -1730,7 +1757,7 @@
 	return ret;
 }
 
-DLL_EXPORT int __stdcall OpenArchiveFile(int archive, const char* name)
+int OpenArchiveFile(int archive, const char* name)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to OpenArchiveFile.&quot;);
 	ASSERT(name &amp;&amp; *name, &quot;Don't pass a NULL pointer or an empty string to OpenArchiveFile.&quot;);
@@ -1738,7 +1765,7 @@
 	return a-&gt;OpenFile(name);
 }
 
-DLL_EXPORT int __stdcall ReadArchiveFile(int archive, int handle, void* buffer, int numBytes)
+int ReadArchiveFile(int archive, int handle, void* buffer, int numBytes)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to ReadArchiveFile.&quot;);
 	ASSERT(buffer, &quot;Don't pass a NULL pointer to ReadArchiveFile.&quot;);
@@ -1746,14 +1773,14 @@
 	return a-&gt;ReadFile(handle, buffer, numBytes);
 }
 
-DLL_EXPORT void __stdcall CloseArchiveFile(int archive, int handle)
+void CloseArchiveFile(int archive, int handle)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to CloseArchiveFile.&quot;);
 	CArchiveBase* a = openArchives[archive];
 	return a-&gt;CloseFile(handle);
 }
 
-DLL_EXPORT int __stdcall SizeArchiveFile(int archive, int handle)
+int SizeArchiveFile(int archive, int handle)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to SizeArchiveFile.&quot;);
 	CArchiveBase* a = openArchives[archive];
@@ -1788,66 +1815,33 @@
 //////////////////////////
 //////////////////////////
 
-/**
- * @brief get string from Spring configuration
- * @param name name of key to get
- * @param defvalue default string value to use if key is not found, may not be NULL
- * @return string value
- */
-DLL_EXPORT const char* __stdcall GetSpringConfigString( const char* name, const char* defvalue )
+const char* GetSpringConfigString( const char* name, const char* defValue )
 {
-	string res = configHandler.GetString( name, defvalue );
+	string res = configHandler.GetString( name, defValue );
 	return GetStr(res);
 }
 
-/**
- * @brief get integer from Spring configuration
- * @param name name of key to get
- * @param defvalue default integer value to use if key is not found
- * @return integer value
- */
-DLL_EXPORT int __stdcall GetSpringConfigInt( const char* name, const int defvalue )
+int GetSpringConfigInt( const char* name, const int defValue )
 {
-	return configHandler.GetInt( name, defvalue );
+	return configHandler.GetInt( name, defValue );
 }
 
-/**
- * @brief get float from Spring configuration
- * @param name name of key to get
- * @param defvalue default float value to use if key is not found
- * @return float value
- */
-DLL_EXPORT float __stdcall GetSpringConfigFloat( const char* name, const float defvalue )
+float GetSpringConfigFloat( const char* name, const float defValue)
 {
-	return configHandler.GetFloat( name, defvalue );
+	return configHandler.GetFloat( name, defValue );
 }
 
-/**
- * @brief set string in Spring configuration
- * @param name name of key to set
- * @param value string value to set
- */
-DLL_EXPORT void __stdcall SetSpringConfigString(const char* name, const char* value)
+void SetSpringConfigString(const char* name, const char* value)
 {
 	configHandler.SetString( name, value );
 }
 
-/**
- * @brief set integer in Spring configuration
- * @param name name of key to set
- * @param value integer value to set
- */
-DLL_EXPORT void __stdcall SetSpringConfigInt(const char* name, const int value)
+void SetSpringConfigInt(const char* name, const int value)
 {
 	configHandler.SetInt( name, value );
 }
 
-/**
- * @brief set float in Spring configuration
- * @param name name of key to set
- * @param value float value to set
- */
-DLL_EXPORT void __stdcall SetSpringConfigFloat(const char* name, const float value)
+void SetSpringConfigFloat(const char* name, const float value)
 {
 	configHandler.SetFloat( name, value );
 }

Modified: branches/caiinterface/tools/unitsync/unitsync.h
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync.h	2008-09-30 21:38:37 UTC (rev 6492)
+++ branches/caiinterface/tools/unitsync/unitsync.h	2008-10-01 17:53:40 UTC (rev 6493)
@@ -2,6 +2,10 @@
 #define UNITSYNC_H
 
 #include &lt;string&gt;
+#include &quot;exportdefines.h&quot;
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+#include &quot;ExternalAI/Interface/SOption.h&quot;
+#include &quot;ExternalAI/Interface/SInfo.h&quot;
 
 #define STRBUF_SIZE 100000
 
@@ -34,30 +38,370 @@
 };
 
 
-enum OptionType {
-	opt_error  = 0,
-	opt_bool   = 1,
-	opt_list   = 2,
-	opt_number = 3,
-	opt_string = 4
-};
+//enum OptionType {
+//	opt_error  = 0,
+//	opt_bool   = 1,
+//	opt_list   = 2,
+//	opt_number = 3,
+//	opt_string = 4
+//};
 
 
 const char *GetStr(std::string str);
 
 
 #ifdef WIN32
-#define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)
-#include &lt;windows.h&gt;
+//	#define DLL_EXPORT extern &quot;C&quot; __declspec(dllexport)
+	#include &lt;windows.h&gt;
 #else
-#include &lt;iostream&gt;
-#define DLL_EXPORT extern &quot;C&quot; __attribute__ ((visibility(&quot;default&quot;)))
-#define __stdcall
-#define MB_OK 0
-static inline void MessageBox(void*, const char* msg, const char* capt, unsigned int)
-{
-	std::cerr &lt;&lt; &quot;unitsync: &quot; &lt;&lt; capt &lt;&lt; &quot;: &quot; &lt;&lt; msg &lt;&lt; std::endl;
-}
-#endif
+	#include &lt;iostream&gt;
+//	#define DLL_EXPORT extern &quot;C&quot; __attribute__ ((visibility(&quot;default&quot;)))
+//	#define __stdcall
+	#define MB_OK 0
+	static inline void MessageBox(void*, const char* msg, const char* capt, unsigned int)
+	{
+		std::cerr &lt;&lt; &quot;unitsync: &quot; &lt;&lt; capt &lt;&lt; &quot;: &quot; &lt;&lt; msg &lt;&lt; std::endl;
+	}
+#endif	/* WIN32 */
 
-#endif
+/**
+ * @brief returns the version fo spring this was compiled with
+ *
+ * Returns a const char* string specifying the version of spring used to build this library with.
+ * It was added to aid in lobby creation, where checks for updates to spring occur.
+ */
+Export(const char*) GetSpringVersion();
+/**
+ * @brief Creates a messagebox with said message
+ * @param p_szMessage const char* string holding the message
+ *
+ * Creates a messagebox with the title &quot;Message from DLL&quot;, an OK button, and the specified message
+ */
+Export(void) Message(const char* p_szMessage);
+Export(void) UnInit();
+Export(int) Init(bool isServer, int id);
+/**
+ * @brief process another unit and return how many are left to process
+ * @return int The number of unprocessed units to be handled
+ *
+ * Call this function repeatedly untill it returns 0 before calling any other function related to units.
+ */
+Export(int) ProcessUnits(void);
+/**
+ * @brief process another unit and return how many are left to process without checksumming
+ * @return int The number of unprocessed units to be handled
+ *
+ * Call this function repeatedly untill it returns 0 before calling any other function related to units.
+ * This function performs the same operations as ProcessUnits() but it does not generate checksums.
+ */
+Export(int) ProcessUnitsNoChecksum(void);
+Export(const char*) GetCurrentList();
+Export(void) AddClient(int id, const char *unitList);
+Export(void) RemoveClient(int id);
+Export(const char*) GetClientDiff(int id);
+Export(void) InstallClientDiff(const char *diff);
+/**
+ * @brief returns the number of units
+ * @return int number of units processed and available
+ *
+ * Will return the number of units. Remember to call processUnits() beforehand untill it returns 0
+ * As ProcessUnits is called the number of processed units goes up, and so will the value returned
+ * by this function.
+ *
+ * while(processUnits()){}
+ * int unit_number = GetUnitCount();
+ */
+Export(int) GetUnitCount();
+/**
+ * @brief returns the units internal mod name
+ * @param int the units id number
+ * @return const char* The units internal modname
+ *
+ * This function returns the units internal mod name. For example it would return armck and not
+ * Arm Construction kbot.
+ */
+Export(const char*) GetUnitName(int unit);
+/**
+ * @brief returns The units human readable name
+ * @param int The units id number
+ * @return const char* The Units human readable name
+ *
+ * This function returns the units human name. For example it would return Arm Construction kbot
+ * and not armck.
+ */
+Export(const char*) GetFullUnitName(int unit);
+Export(int) IsUnitDisabled(int unit);
+Export(int) IsUnitDisabledByClient(int unit, int clientId);
+Export(void) AddArchive(const char* name);
+Export(void) AddAllArchives(const char* root);
+Export(unsigned int) GetArchiveChecksum(const char* arname);
+Export(const char*) GetArchivePath(const char* arname);
+
+Export(int) GetMapCount();
+Export(const char*) GetMapName(int index);
+Export(int) GetMapInfoEx(const char* name, MapInfo* outInfo, int version);
+Export(int) GetMapInfo(const char* name, MapInfo* outInfo);
+Export(int) GetMapArchiveCount(const char* mapName);
+Export(const char*) GetMapArchiveName(int index);
+Export(unsigned int) GetMapChecksum(int index);
+Export(unsigned int) GetMapChecksumFromName(const char* mapName);
+/**
+ * @brief Retrieves a minimap image for a map.
+ * @param filename The name of the map, including extension.
+ * @param miplevel Which miplevel of the minimap to extract from the file.
+ * Set miplevel to 0 to get the largest, 1024x1024 minimap. Each increment
+ * divides the width and height by 2. The maximum miplevel is 8, resulting in a
+ * 4x4 image.
+ * @return A pointer to a static memory area containing the minimap as a 16 bit
+ * packed RGB-565 (MSB to LSB: 5 bits red, 6 bits green, 5 bits blue) linear
+ * bitmap.
+ *
+ * An example usage would be GetMinimap(&quot;SmallDivide.smf&quot;, 2).
+ * This would return a 16 bit packed RGB-565 256x256 (= 1024/2^2) bitmap.
+ *
+ * Be sure you've made a calls to Init prior to using this.
+ */
+Export(void*) GetMinimap(const char* filename, int miplevel);
+
+/**
+ * @brief Retrieves the name of this mod
+ * @return int The number of mods
+ *
+ * Returns the name of the mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(int) GetPrimaryModCount();
+/**
+ * @brief Retrieves the name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods name
+ *
+ * Returns the name of the mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModName(int index);
+/**
+ * @brief Retrieves the shortened name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods abbrieviated name
+ *
+ * Returns the shortened name of the mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModShortName(int index);
+/**
+ * @brief Retrieves the version string of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods version string
+ *
+ * Returns value of the mutator tag for the specified mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModVersion(int index);
+/**
+ * @brief Retrieves the mutator name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods mutator name
+ *
+ * Returns value of the mutator tag for the specified mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModMutator(int index);
+/**
+ * @brief Retrieves the game name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods game
+ *
+ * Returns the name of the game this mod belongs to usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModGame(int index);
+/**
+ * @brief Retrieves the short game name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods abbrieviated game name
+ *
+ * Returns the abbrieviated name of the game this mod belongs to usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModShortGame(int index);
+/**
+ * @brief Retrieves the description of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods description
+ *
+ * Returns a description for the specified mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
+Export(const char*) GetPrimaryModDescription(int index);
+Export(const char*) GetPrimaryModArchive(int index);
+/**
+ * @brief Retrieves the number of archives a mod requires
+ * @param index int The index of the mod
+ * @return the number of archives this mod depends on.
+ *
+ * This is used to get the entire list of archives that a mod requires.
+ * Call GetPrimaryModArchiveCount() with selected mod first to get number of
+ * archives, and then use GetPrimaryModArchiveList() for 0 to count-1 to get the
+ * name of each archive.
+ */
+Export(int) GetPrimaryModArchiveCount(int index);
+/**
+ * @brief Retrieves the name of the current mod's archive.
+ * @param archiveNr The mod's archive index/id.
+ * @return the name of the archive
+ * @see GetPrimaryModArchiveCount()
+ */
+Export(const char*) GetPrimaryModArchiveList(int archiveNr);
+Export(int) GetPrimaryModIndex(const char* name);
+Export(unsigned int) GetPrimaryModChecksum(int index);
+Export(unsigned int) GetPrimaryModChecksumFromName(const char* name);
+Export(int) GetSideCount();
+Export(const char*) GetSideName(int side);
+Export(const char*) GetSideStartUnit(int side);
+Export(int) GetLuaAICount();
+Export(const char*) GetLuaAIName(int aiIndex);
+Export(const char*) GetLuaAIDesc(int aiIndex);
+
+/**
+ * Returns the number of available Skirmish AIs.
+ * A call to this function will load AI information.
+ */
+Export(int) GetSkirmishAICount();
+/**
+ * Returns the specifyer of a Skirmish AI.
+ * It contians all hte info needed to specify an AI in script.txt eg.
+ */
+Export(struct SSAISpecifyer) GetSkirmishAISpecifyer(int index);
+/**
+ * Returns a list of static properties of a skirmish AI.
+ * For a list of standard properties, see the SKIRMISH_AI_PROPERTY_* defines
+ * in rts/ExternalAI/Interface/SSAILibrary.h.
+ */
+Export(int) GetSkirmishAIInfoCount(int index);
+Export(const char*) GetInfoKey(int index);
+Export(const char*) GetInfoValue(int index);
+Export(const char*) GetInfoDescription(int index);
+/**
+ * Returns the level of support we can avait from a Skirmish AI, concerning a
+ * specific Spring and AI Interface version.
+ */
+//Export(struct LevelOfSupport) GetSkirmishAILevelOfSupport(int index, const char* engineVersionString, int engineVersionNumber, const char* aiInterfaceShortName, const char* aiInterfaceVersion);
+
+Export(int) GetMapOptionCount(const char* name);
+Export(int) GetModOptionCount();
+Export(int) GetSkirmishAIOptionCount(int index);
+
+// Common Parameters
+Export(const char*) GetOptionKey(int optIndex);
+Export(const char*) GetOptionName(int optIndex);
+Export(const char*) GetOptionDesc(int optIndex);
+Export(int) GetOptionType(int optIndex);
+
+// Bool Options
+Export(int) GetOptionBoolDef(int optIndex);
+
+// Number Options
+Export(float) GetOptionNumberDef(int optIndex);
+Export(float) GetOptionNumberMin(int optIndex);
+Export(float) GetOptionNumberMax(int optIndex);
+Export(float) GetOptionNumberStep(int optIndex);
+
+// String Options
+Export(const char*) GetOptionStringDef(int optIndex);
+Export(int) GetOptionStringMaxLen(int optIndex);
+
+// List Options
+Export(int) GetOptionListCount(int optIndex);
+Export(const char*) GetOptionListDef(int optIndex);
+Export(const char*) GetOptionListItemKey(int optIndex, int itemIndex);
+Export(const char*) GetOptionListItemName(int optIndex, int itemIndex);
+Export(const char*) GetOptionListItemDesc(int optIndex, int itemIndex);
+
+/**
+ * A return value of 0 means that any map can be selected
+ * Map names should be complete  (including the .smf or .sm3 extension)
+ */
+Export(int) GetModValidMapCount();
+Export(const char*) GetModValidMap(int index);
+
+// Map the wanted archives into the VFS with AddArchive before using these functions
+Export(int) OpenFileVFS(const char* name);
+Export(void) CloseFileVFS(int handle);
+Export(void) ReadFileVFS(int handle, void* buf, int length);
+Export(int) FileSizeVFS(int handle);
+/**
+ * Does not currently support more than one call at a time
+ * (a new call to initfind destroys data from previous ones)
+ * pass the returned handle to findfiles to get the results
+ */
+Export(int) InitFindVFS(const char* pattern);
+/**
+ * Does not currently support more than one call at a time
+ * (a new call to initfind destroys data from previous ones)
+ * pass the returned handle to findfiles to get the results
+ */
+Export(int) InitDirListVFS(const char* path, const char* pattern, const char* modes);
+/**
+ * Does not currently support more than one call at a time
+ * (a new call to initfind destroys data from previous ones)
+ * pass the returned handle to findfiles to get the results
+ */
+Export(int) InitSubDirsVFS(const char* path, const char* pattern, const char* modes);
+/**
+ * On first call, pass handle from initfind. pass the return value of this
+ * function on subsequent calls until 0 is returned.
+ * size should be set to max namebuffer size on call.
+ */
+Export(int) FindFilesVFS(int handle, char* nameBuf, int size);
+/** returns 0 on error, a handle otherwise */
+Export(int) OpenArchive(const char* name);
+/** returns 0 on error, a handle otherwise */
+Export(int) OpenArchiveType(const char* name, const char* type);
+Export(void) CloseArchive(int archive);
+Export(int) FindFilesArchive(int archive, int cur, char* nameBuf, int* size);
+Export(int) OpenArchiveFile(int archive, const char* name);
+Export(int) ReadArchiveFile(int archive, int handle, void* buffer, int numBytes);
+Export(void) CloseArchiveFile(int archive, int handle);
+Export(int) SizeArchiveFile(int archive, int handle);
+/**
+ * @brief get string from Spring configuration
+ * @param name name of key to get
+ * @param defvalue default string value to use if key is not found, may not be NULL
+ * @return string value
+ */
+Export(const char*) GetSpringConfigString( const char* name, const char* defValue);
+/**
+ * @brief get integer from Spring configuration
+ * @param name name of key to get
+ * @param defvalue default integer value to use if key is not found
+ * @return integer value
+ */
+Export(int) GetSpringConfigInt( const char* name, const int defValue);
+/**
+ * @brief get float from Spring configuration
+ * @param name name of key to get
+ * @param defvalue default float value to use if key is not found
+ * @return float value
+ */
+Export(float) GetSpringConfigFloat( const char* name, const float defValue);
+/**
+ * @brief set string in Spring configuration
+ * @param name name of key to set
+ * @param value string value to set
+ */
+Export(void) SetSpringConfigString(const char* name, const char* value);
+/**
+ * @brief set integer in Spring configuration
+ * @param name name of key to set
+ * @param value integer value to set
+ */
+Export(void) SetSpringConfigInt(const char* name, const int value);
+/**
+ * @brief set float in Spring configuration
+ * @param name name of key to set
+ * @param value float value to set
+ */
+Export(void) SetSpringConfigFloat(const char* name, const float value);
+
+#endif	/* UNITSYNC_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001264.html">[Taspring-linux-commit] r6494 - in branches/caiinterface: . AI	AI/Group AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/AAI AI/Skirmish/CSAI	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/ABICompatibilityLayer/Platform/Win	AI/Skirmish/CSAI/CSAI2 AI/Skirmish/CSAI/CSAILoader	AI/Skirmish/CSAI/MonoLoader AI/Skirmish/JCAI	AI/Skirmish/KAI-0.2 AI/Skirmish/KAIK-0.13 AI/Skirmish/NTai	AI/Skirmish/NTai/AI AI/Skirmish/NTai/AI/nbproject/private	AI/Skirmish/NullAI AI/Skirmish/RAI-0.553	AI/Skirmish/TestGlobalAI Lobby/AFLobby/src/aflobby	Lobby/TASClient game/startscripts installer/sections rts	rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper	rts/ExternalAI/Interface/LegacyCppWrapper/Event rts/Game	rts/Game/StartScripts rts/Lua rts/Map rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/build/scons	rts/lib/lua/src rts/lib/streflop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1263">[ date ]</a>
              <a href="thread.html#1263">[ thread ]</a>
              <a href="subject.html#1263">[ subject ]</a>
              <a href="author.html#1263">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
