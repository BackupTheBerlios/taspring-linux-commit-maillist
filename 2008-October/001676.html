<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6907 - in trunk: AI/Global/AAI game/AI/AAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-October/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6907%20-%20in%20trunk%3A%20AI/Global/AAI%20game/AI/AAI&In-Reply-To=%3C20081026194415.BA7214751%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001675.html">
   <LINK REL="Next"  HREF="001677.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6907 - in trunk: AI/Global/AAI game/AI/AAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6907%20-%20in%20trunk%3A%20AI/Global/AAI%20game/AI/AAI&In-Reply-To=%3C20081026194415.BA7214751%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6907 - in trunk: AI/Global/AAI game/AI/AAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sun Oct 26 20:44:15 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001675.html">[Taspring-linux-commit] r6906 - in trunk/rts/Sim: MoveTypes Units
</A></li>
        <LI>Next message: <A HREF="001677.html">[Taspring-linux-commit] r6908 -	trunk/installer/builddata/springcontent
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1676">[ date ]</a>
              <a href="thread.html#1676">[ thread ]</a>
              <a href="subject.html#1676">[ subject ]</a>
              <a href="author.html#1676">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: submarine
Date: 2008-10-26 20:44:14 +0100 (Sun, 26 Oct 2008)
New Revision: 6907

Modified:
   trunk/AI/Global/AAI/AAI ReadMe.txt
   trunk/AI/Global/AAI/AAI.cpp
   trunk/AI/Global/AAI/AAI.h
   trunk/AI/Global/AAI/AAIAttackManager.cpp
   trunk/AI/Global/AAI/AAIBrain.cpp
   trunk/AI/Global/AAI/AAIBrain.h
   trunk/AI/Global/AAI/AAIBuildTable.cpp
   trunk/AI/Global/AAI/AAIBuildTable.h
   trunk/AI/Global/AAI/AAIConstructor.cpp
   trunk/AI/Global/AAI/AAIExecute.cpp
   trunk/AI/Global/AAI/AAIExecute.h
   trunk/AI/Global/AAI/AAIGroup.cpp
   trunk/AI/Global/AAI/AAIMap.cpp
   trunk/AI/Global/AAI/AAIMap.h
   trunk/AI/Global/AAI/AAISector.cpp
   trunk/AI/Global/AAI/AAIUnitTable.cpp
   trunk/AI/Global/AAI/AAIUnitTable.h
   trunk/AI/Global/AAI/aidef.h
   trunk/game/AI/AAI/AAI ReadMe.txt
Log:
AAI v0.875	

- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order water factories on a land map anymore)

- Improved AAIs behaviour on water maps with start positions on islands/land masses

- Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, works better if there are land and sea spots available at the same time)

- Continent file version bumped to 0.87

- Fixed a crash on shut down introduced in Spring v0.77

Modified: trunk/AI/Global/AAI/AAI ReadMe.txt
===================================================================
--- trunk/AI/Global/AAI/AAI ReadMe.txt	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAI ReadMe.txt	2008-10-26 19:44:14 UTC (rev 6907)
@@ -106,7 +106,19 @@
 		- Brandon Potter for his TBT 12 cfg file
 
 
+AAI v0.875	- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order 
+		  water factories on a land map anymore)
 
+		- Improved AAIs behaviour on water maps with start positions on islands/land masses
+
+		- Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, 
+		  works better if there are land and sea spots available at the same time)
+
+		- Continent file version bumped to 0.87
+
+		- Fixed a crash on shut down introduced in Spring v0.77
+
+
 AAI v0.872	- Refactored code for getting rally points and positions to withdraw units and made 
 
 		- Construction units that are member of the DONT_BUILD list will not be built anymore
@@ -126,11 +138,11 @@
 		- Added some new variables to mod config file:
 
 		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
-		  
+
 		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
-		 
+
 		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
-	
+
   		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
 
 		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 

Modified: trunk/AI/Global/AAI/AAI.cpp
===================================================================
--- trunk/AI/Global/AAI/AAI.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAI.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -36,10 +36,6 @@
 		requestedUnits[i] = 0;
 	}
 
-	activeScouts = futureScouts = 0;
-	activeBuilders = futureBuilders = 0;
-	activeFactories = futureFactories = 0;
-
 	initialized = false;
 }
 
@@ -65,9 +61,9 @@
 	fprintf(file, &quot;Future metal/energy request: %i / %i\n&quot;, (int)execute-&gt;futureRequestedMetal, (int)execute-&gt;futureRequestedEnergy);
 	fprintf(file, &quot;Future metal/energy supply:    %i / %i\n\n&quot;, (int)execute-&gt;futureAvailableMetal, (int)execute-&gt;futureAvailableEnergy);
 
-	fprintf(file, &quot;Future/active scouts:      %i / %i\n&quot;, futureScouts, activeScouts);
-	fprintf(file, &quot;Future/active builders:    %i / %i\n&quot;, futureBuilders, activeBuilders);
-	fprintf(file, &quot;Future/active factories:   %i / %i\n\n&quot;, futureFactories, activeFactories);
+	fprintf(file, &quot;Future/active scouts:      %i / %i\n&quot;, ut-&gt;futureScouts, ut-&gt;activeScouts);
+	fprintf(file, &quot;Future/active builders:    %i / %i\n&quot;, ut-&gt;futureBuilders, ut-&gt;activeBuilders);
+	fprintf(file, &quot;Future/active factories:   %i / %i\n\n&quot;, ut-&gt;futureFactories, ut-&gt;activeFactories);
 
 	fprintf(file, &quot;Factory ratings:\n&quot;);
 	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].begin(); fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].end(); ++fac)
@@ -178,9 +174,6 @@
 
 void AAI::UnitDamaged(int damaged, int attacker, float damage, float3 dir)
 {
-	if(damaged &lt; 0)
-		return;
-
 	const UnitDef *def, *att_def;
 	UnitCategory att_cat, cat;
 	
@@ -197,29 +190,32 @@
 		cat =  bt-&gt;units_static[def-&gt;id].category;
 	else
 		cat = UNKNOWN;
+
+	// assault grups may be ordered to retreat
+	if(cat &gt;= GROUND_ASSAULT &amp;&amp; cat &lt;= SUBMARINE_ASSAULT) 
+			execute-&gt;CheckFallBack(damaged, def-&gt;id);
 	
 	// known attacker
 	if(attacker &gt;= 0)
 	{
-		if(cat &gt;= GROUND_ASSAULT &amp;&amp; cat &lt;= SUBMARINE_ASSAULT) 
-			execute-&gt;CheckFallBack(damaged, def-&gt;id);
-
-		att_def = cb-&gt;GetUnitDef(attacker);
-
 		// filter out friendly fire
 		if(cb-&gt;GetUnitTeam(attacker) == cb-&gt;GetMyTeam())
 			return;
 
+		att_def = cb-&gt;GetUnitDef(attacker);
+
 		if(att_def)
 		{
+			unsigned int att_movement_type = bt-&gt;units_static[att_def-&gt;id].movement_type;
 			att_cat = bt-&gt;units_static[att_def-&gt;id].category;
 
 			// retreat builders
 			if(ut-&gt;IsBuilder(damaged))
 				ut-&gt;units[damaged].cons-&gt;Retreat(att_cat);
-			
-			if(att_cat &gt;= GROUND_ASSAULT &amp;&amp; att_cat &lt;= SUBMARINE_ASSAULT)
+			else
 			{
+				//if(att_cat &gt;= GROUND_ASSAULT &amp;&amp; att_cat &lt;= SUBMARINE_ASSAULT)
+		
 				float3 pos = cb-&gt;GetUnitPos(attacker);
 				AAISector *sector = map-&gt;GetSectorOfPos(&amp;pos);
 
@@ -227,13 +223,13 @@
 				{
 					// building has been attacked
 					if(cat &lt;= METAL_MAKER)
-						execute-&gt;DefendUnitVS(damaged, def, att_cat, &amp;pos, 115);
+						execute-&gt;DefendUnitVS(damaged, att_movement_type, &amp;pos, 115);
 					// builder
 					else if(ut-&gt;IsBuilder(damaged))
-						execute-&gt;DefendUnitVS(damaged, def, att_cat, &amp;pos, 110);
+						execute-&gt;DefendUnitVS(damaged, att_movement_type, &amp;pos, 110);
 					// normal units
 					else 
-						execute-&gt;DefendUnitVS(damaged, def, att_cat, &amp;pos, 105);
+						execute-&gt;DefendUnitVS(damaged, att_movement_type, &amp;pos, 105);
 				}
 			}
 		}
@@ -284,7 +280,7 @@
 	{
 		// UnitFinished() will decrease it later -&gt; prevents AAI from having -1 future commanders 
 		requestedUnits[COMMANDER] += 1;
-		futureBuilders += 1;
+		ut-&gt;futureBuilders += 1;
 		bt-&gt;units_dynamic[def-&gt;id].under_construction += 1;
 
 		execute-&gt;InitAI(unit, def);
@@ -305,13 +301,16 @@
 		bt-&gt;units_dynamic[def-&gt;id].requested += 1;
 
 		if(category == SCOUT)
-			futureScouts += 1;
+			ut-&gt;futureScouts += 1;
 		else if(category &lt;= METAL_MAKER &amp;&amp; category &gt; UNKNOWN)
 		{
 			float3 pos = cb-&gt;GetUnitPos(unit);
 			map-&gt;Pos2FinalBuildPos(&amp;pos, def);
 
-			execute-&gt;InitBuildingAt(def, pos);
+			if(pos.y &lt; 0)
+				execute-&gt;InitBuildingAt(def, pos, true);
+			else
+				execute-&gt;InitBuildingAt(def, pos, false);
 		}
 	}
 	else
@@ -434,11 +433,8 @@
 		// scout
 		else if(category == SCOUT)
 		{
-			++activeScouts;
-			--futureScouts;
+			ut-&gt;AddScout(unit);
 
-			scouts.push_back(unit);
-
 			// cloak scout if cloakable
 			if(def-&gt;canCloak)
 			{
@@ -515,11 +511,11 @@
 		else
 		{
 			if(category == SCOUT)
-				--futureScouts;	
+				--ut-&gt;futureScouts;	
 
 			if(bt-&gt;IsBuilder(def-&gt;id))
 			{
-				--futureBuilders;
+				--ut-&gt;futureBuilders;
 
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 					--bt-&gt;units_dynamic[*unit].constructorsRequested;
@@ -527,7 +523,7 @@
 			else if(bt-&gt;IsFactory(def-&gt;id))
 			{
 				if(category == STATIONARY_CONSTRUCTOR)
-					--futureFactories;
+					--ut-&gt;futureFactories;
 	
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 					--bt-&gt;units_dynamic[*unit].constructorsRequested;
@@ -702,19 +698,9 @@
 			// scout
 			if(category == SCOUT)
 			{
-				--activeScouts;
+				ut-&gt;RemoveScout(unit);
 
-				// remove from scout list
-				for(list&lt;int&gt;::iterator i = scouts.begin(); i != scouts.end(); i++)
-				{
-					if(*i == unit)
-					{
-						scouts.erase(i);
-						break;
-					}
-				}
-
-				// add building to sector
+				// add enemy building to sector
 				if(validSector &amp;&amp; map-&gt;sector[x][y].distance_to_base &gt; 0)
 					map-&gt;sector[x][y].enemy_structures += 5;
 				
@@ -841,9 +827,7 @@
 
 	// scouting
 	if(!(tick%cfg-&gt;SCOUT_UPDATE_FREQUENCY))
-	{
 		execute-&gt;UpdateRecon(); // update threat values for all sectors, move scouts...
-	}
 	
 	// update groups
 	if(!(tick%169))
@@ -874,9 +858,7 @@
 
 	// ressource management
 	if(!(tick%199))
-	{
 		execute-&gt;CheckRessources();
-	}
 
 	// update sectors
 	if(!(tick%423))
@@ -887,21 +869,15 @@
 
 	// builder management
 	if(!(tick%917))
-	{
 		brain-&gt;UpdateDefenceCapabilities();
-	}
 
 	// update income 
 	if(!(tick%45))
-	{
 		execute-&gt;UpdateRessources();
-	}
 
 	// building management
 	if(!(tick%97))
-	{
 		execute-&gt;CheckConstruction();
-	}
 
 	// builder/factory management
 	if(!(tick%677))
@@ -910,16 +886,11 @@
 			ut-&gt;units[(*builder)].cons-&gt;Update();
 	}
 
-	
 	if(!(tick%437))
-	{
 		execute-&gt;CheckFactories();
-	}
 
 	if(!(tick%1079))
-	{
 		execute-&gt;CheckDefences(); 
-	}
 
 	// build radar/jammer
 	if(!(tick%1177))
@@ -956,7 +927,7 @@
 	}
 }
 
-int AAI::HandleEvent(int msg,const void* data)
+int AAI::HandleEvent(int msg, const void* data)
 {
    switch (msg)
    {

Modified: trunk/AI/Global/AAI/AAI.h
===================================================================
--- trunk/AI/Global/AAI/AAI.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAI.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -66,20 +66,14 @@
 	// side 1= arm, 2 = core, 0 = neutral
 	int side;
 
+	// if there is more than one instance of AAI, make sure to allocate/free memory only once
 	int aai_instance;
 
-	// units, buildings etc.
-	list&lt;int&gt; scouts;
-
 	// number of active/under construction units of all different types
 	int activeUnits[(int)MOBILE_CONSTRUCTOR+1];
 	int futureUnits[(int)MOBILE_CONSTRUCTOR+1];
 	int requestedUnits[(int)MOBILE_CONSTRUCTOR+1];
 
-	int activeScouts, futureScouts;
-	int activeBuilders, futureBuilders;
-	int activeFactories, futureFactories;
-
 	// list of buildtasks
 	list&lt;AAIBuildTask*&gt; build_tasks;
 

Modified: trunk/AI/Global/AAI/AAIAttackManager.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIAttackManager.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIAttackManager.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -83,17 +83,17 @@
 	}
 	else
 	{
-		if(map-&gt;mapType == LAND_MAP)
+		if(map-&gt;map_type == LAND_MAP)
 		{
 			land = true;
 			water = false;
 		}
-		else if(map-&gt;mapType == LAND_WATER_MAP)
+		else if(map-&gt;map_type == LAND_WATER_MAP)
 		{
 			land = true;
 			water = true;
 		}
-		else if(map-&gt;mapType == WATER_MAP)
+		else if(map-&gt;map_type == WATER_MAP)
 		{
 			land = false;
 			water = true;
@@ -167,16 +167,7 @@
 		{
 			AAIAttack *attack;
 			
-			try
-			{
-				attack = new AAIAttack(ai);
-			}
-			catch(...)
-			{
-				fprintf(ai-&gt;file, &quot;Exception thrown when allocating memory for AAIAttack&quot;);
-				return;
-			}
-
+			attack = new AAIAttack(ai);
 			attacks.push_back(attack);
 
 			attack-&gt;land = land;

Modified: trunk/AI/Global/AAI/AAIBrain.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIBrain.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIBrain.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -21,9 +21,6 @@
 	freeBaseSpots = false;
 	expandable = true;
 
-	land_sectors = 0;
-	water_sectors = 0;
-
 	// initialize random numbers generator
 	srand ( time(NULL) );
 
@@ -261,37 +258,45 @@
 
 void AAIBrain::AddSector(AAISector *sector)
 {
-	if(sector-&gt;water_ratio &lt; 0.4)
-		++land_sectors;
-	else if(sector-&gt;water_ratio &lt; 0.6)
+	sectors[0].push_back(sector);
+
+	sector-&gt;SetBase(true);
+
+	// update base land/water ratio
+	baseLandRatio = 0;
+	baseWaterRatio = 0;
+
+	for(list&lt;AAISector*&gt;::iterator s = sectors[0].begin(); s != sectors[0].end(); ++s)
 	{
-		++land_sectors;
-		++water_sectors;
+		baseLandRatio += (*s)-&gt;GetFlatRatio();
+		baseWaterRatio += (*s)-&gt;GetWaterRatio();
 	}
-	else
-		++water_sectors;
 
-	sectors[0].push_back(sector);
-	
-	sector-&gt;SetBase(true);
+	baseLandRatio /= (float)sectors[0].size();
+	baseWaterRatio /= (float)sectors[0].size();
 }
 
 void AAIBrain::RemoveSector(AAISector *sector)
 {
-	if(sector-&gt;water_ratio &lt; 0.4)
-		--land_sectors;
-	else if(sector-&gt;water_ratio &lt; 0.6)
-	{
-		--land_sectors;
-		--water_sectors;
-	}
-	else
-		--water_sectors;
-
-
 	sectors[0].remove(sector);
 	
 	sector-&gt;SetBase(false);
+
+	// update base land/water ratio
+	baseLandRatio = 0;
+	baseWaterRatio = 0;
+
+	if(sectors[0].size() &gt; 0)
+	{
+		for(list&lt;AAISector*&gt;::iterator s = sectors[0].begin(); s != sectors[0].end(); ++s)
+		{
+			baseLandRatio += (*s)-&gt;GetFlatRatio();
+			baseWaterRatio += (*s)-&gt;GetWaterRatio();
+		}
+
+		baseLandRatio /= (float)sectors[0].size();
+		baseWaterRatio /= (float)sectors[0].size();
+	}
 }
 
 
@@ -398,7 +403,7 @@
 bool AAIBrain::SectorInList(list&lt;AAISector*&gt; mylist, AAISector *sector)
 {
 	// check if sector already added to list
-	for(list&lt;AAISector*&gt;::iterator t = mylist.begin(); t != mylist.end(); t++)
+	for(list&lt;AAISector*&gt;::iterator t = mylist.begin(); t != mylist.end(); ++t)
 	{
 		if(*t == sector)
 			return true;
@@ -406,6 +411,36 @@
 	return false;
 }
 
+float AAIBrain::GetBaseBuildspaceRatio(unsigned int building_move_type)
+{
+	if(building_move_type &amp; MOVE_TYPE_STATIC_LAND)
+		return baseLandRatio;
+	else if(building_move_type &amp; MOVE_TYPE_STATIC_WATER)
+		return baseWaterRatio;
+	else
+		return 1.0f;
+}
+
+bool AAIBrain::CommanderAllowedForConstructionAt(AAISector *sector, float3 *pos)
+{
+	// commander is always allowed in base
+	if(sector-&gt;distance_to_base &lt;= 0)
+		return true;
+	// allow construction close to base for small bases 
+	else if(sectors[0].size() &lt; 3 &amp;&amp; sector-&gt;distance_to_base &lt;= 1)
+		return true;
+	// allow construction on islands close to base on water maps
+	else if(map-&gt;map_type == WATER_MAP &amp;&amp; cb-&gt;GetElevation(pos-&gt;x, pos-&gt;z) &gt;= 0 &amp;&amp; sector-&gt;distance_to_base &lt;= 3)
+		return true;
+	else 
+		return false;
+}
+
+bool AAIBrain::MexConstructionAllowedInSector(AAISector *sector)
+{
+	return sector-&gt;freeMetalSpots &amp;&amp; sector-&gt;enemy_structures &lt;= 0  &amp;&amp; sector-&gt;lost_units[MOBILE_CONSTRUCTOR-COMMANDER]  &lt; 0.5 &amp;&amp; sector-&gt;threat &lt;= 0;
+}
+
 bool AAIBrain::ExpandBase(SectorType sectorType)
 {
 	if(sectors[0].size() &gt;= cfg-&gt;MAX_BASE_SIZE)
@@ -420,9 +455,9 @@
 
 	int max_search_dist = 1;
 
-	// if aai is looking for a water sector to expand into ocean, allow bigger serach_dist
-	if(sectorType == WATER_SECTOR &amp;&amp;  water_sectors == 0 &amp;&amp; land_sectors &gt; 1)
-		max_search_dist = 2;
+	// if aai is looking for a water sector to expand into ocean, allow greater search_dist
+	if(sectorType == WATER_SECTOR &amp;&amp;  baseWaterRatio &lt; 0.1)
+		max_search_dist = 3;
 
 	for(int search_dist = 1; search_dist &lt;= max_search_dist; ++search_dist)
 	{
@@ -454,16 +489,21 @@
 				}
 				else if(sectorType == WATER_SECTOR)
 				{
-					my_rating += 8.0f * (*t)-&gt;water_ratio;
-					my_rating /= dist;
-
+					
 					// check for continent size (to prevent aai to expand into little ponds instead of big ocean)
-					if((*t)-&gt;water_ratio &gt; 0.3 &amp;&amp; !(*t)-&gt;ConnectedToOcean())
+					if((*t)-&gt;water_ratio &gt; 0.1 &amp;&amp;  (*t)-&gt;ConnectedToOcean())
+					{
+						my_rating += 8.0f * (*t)-&gt;water_ratio;
+						my_rating /= dist;	
+					}
+					else
 						my_rating = 0;
 				}
-				else
-					my_rating = 0;
-
+				else // LAND_WATER_SECTOR
+				{
+					my_rating += ((*t)-&gt;flat_ratio + (*t)-&gt;water_ratio) * 8.0f;
+					my_rating /= dist;
+				}
 			
 				// choose higher rated sector
 				if(my_rating &gt; best_rating)
@@ -482,9 +522,15 @@
 
 		// debug purposes:
 		if(sectorType == LAND_SECTOR)
-			fprintf(ai-&gt;file, &quot;\nAdding land sector %i,%i to base; base size: %i \n\n&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+		{
+			fprintf(ai-&gt;file, &quot;\nAdding land sector %i,%i to base; base size: %i&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+			fprintf(ai-&gt;file, &quot;\nNew land : water ratio within base: %f : %f\n\n&quot;, baseLandRatio, baseWaterRatio);
+		}
 		else
-			fprintf(ai-&gt;file, &quot;\nAdding water sector %i,%i to base; base size: %i \n\n&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+		{
+			fprintf(ai-&gt;file, &quot;\nAdding water sector %i,%i to base; base size: %i&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+			fprintf(ai-&gt;file, &quot;\nNew land : water ratio within base: %f : %f\n\n&quot;, baseLandRatio, baseWaterRatio);
+		}
 
 		// update neighbouring sectors
 		UpdateNeighbouringSectors();
@@ -675,13 +721,13 @@
 	// todo: improve selection
 	category = UNKNOWN;
 
-	MapType mapType = map-&gt;mapType;
+	MapType map_type = map-&gt;map_type;
 
-	float ground_usefulness = map-&gt;map_usefulness[0][side] + bt-&gt;mod_usefulness[0][side][mapType];
-	float air_usefulness = map-&gt;map_usefulness[1][side] + bt-&gt;mod_usefulness[1][side][mapType];
-	float hover_usefulness = map-&gt;map_usefulness[2][side] + bt-&gt;mod_usefulness[2][side][mapType];
-	float sea_usefulness = map-&gt;map_usefulness[3][side] + bt-&gt;mod_usefulness[3][side][mapType];
-	float submarine_usefulness = map-&gt;map_usefulness[4][side] + bt-&gt;mod_usefulness[4][side][mapType];
+	float ground_usefulness = map-&gt;map_usefulness[0][side] + bt-&gt;mod_usefulness[0][side][map_type];
+	float air_usefulness = map-&gt;map_usefulness[1][side] + bt-&gt;mod_usefulness[1][side][map_type];
+	float hover_usefulness = map-&gt;map_usefulness[2][side] + bt-&gt;mod_usefulness[2][side][map_type];
+	float sea_usefulness = map-&gt;map_usefulness[3][side] + bt-&gt;mod_usefulness[3][side][map_type];
+	float submarine_usefulness = map-&gt;map_usefulness[4][side] + bt-&gt;mod_usefulness[4][side][map_type];
 
 	if(cfg-&gt;AIR_ONLY_MOD)
 	{
@@ -738,7 +784,7 @@
 	else
 	{
 		// choose unit category dependend on map type
-		if(mapType == LAND_MAP)
+		if(map_type == LAND_MAP)
 		{
 			// determine effectiveness vs several other units
 			anti_ground_urgency = (int)( 2 + (0.05f + bt-&gt;attacked_by_category[1][0][t]) * ground_usefulness * (2.0f * attacked_by[0] + 1.0f) * (4.0f * max_units_spotted[0] + 0.2f) / (4.0f * defence_power_vs[0] + 1));
@@ -813,7 +859,7 @@
 			fprintf(ai-&gt;file, &quot;Air assault:    %f %f %f %i \n&quot;, defence_power_vs[1], attacked_by[1], max_units_spotted[1], anti_air_urgency);
 			fprintf(ai-&gt;file, &quot;Hover assault:  %f %f %f %i \n&quot;, defence_power_vs[2], attacked_by[2], max_units_spotted[1], anti_hover_urgency);*/
 		}
-		else if(mapType == LAND_WATER_MAP)
+		else if(map_type == LAND_WATER_MAP)
 		{
 			// determine effectiveness vs several other units
 			anti_ground_urgency = (int)( 2 + (0.05f + bt-&gt;attacked_by_category[1][0][t]) * ground_usefulness * (2.0f * attacked_by[0] + 1.0f) * (4.0f * max_units_spotted[0] + 0.2f) / (4.0f * defence_power_vs[0] + 1));
@@ -913,7 +959,7 @@
 				BuildUnitOfCategory(category, cost, ground_eff, air_eff, hover_eff, sea_eff, submarine_eff,stat_eff, urgent);
 			}
 		}
-		else if(mapType == WATER_MAP)
+		else if(map_type == WATER_MAP)
 		{
 			// determine effectiveness vs several other units
 			anti_air_urgency = (int)( 2 + (0.05f + bt-&gt;attacked_by_category[1][1][t]) * air_usefulness * (2.0f * attacked_by[1] + 1.0f) * (4.0f * max_units_spotted[1] + 0.2f) / (4.0f * defence_power_vs[1] + 1));
@@ -1003,7 +1049,7 @@
 				BuildUnitOfCategory(category, cost, ground_eff, air_eff, hover_eff, sea_eff, submarine_eff,stat_eff, urgent);
 			}
 		}
-		else if(mapType == AIR_MAP)
+		else if(map_type == AIR_MAP)
 		{
 			category = AIR_ASSAULT;	
 

Modified: trunk/AI/Global/AAI/AAIBrain.h
===================================================================
--- trunk/AI/Global/AAI/AAIBrain.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIBrain.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -81,6 +81,15 @@
 	// returns how much ressources can be spent for unit construction atm 
 	float Affordable();
 
+	// returns true if commander is allowed for construction at the specified position in the sector 
+	bool CommanderAllowedForConstructionAt(AAISector *sector, float3 *pos);
+
+	// returns true if AAI may build a mex in this sector (e.g. safe sector)
+	bool MexConstructionAllowedInSector(AAISector *sector);
+
+	// returns ratio of cells in the current base sectors that match movement_type (e.g. 0.3 if 30% of base is covered with water and building is naval)
+	float GetBaseBuildspaceRatio(unsigned int building_move_type);
+
 	void DefendCommander(int attacker);
 
 	void BuildUnits();
@@ -93,11 +102,13 @@
 	//  0 = sectors the ai uses to build its base, 1 = direct neighbours etc.
 	vector&lt;list&lt;AAISector*&gt; &gt; sectors; 
 
-	int land_sectors;
-	int water_sectors;
+	// ratio of land/water cells in all base sectors
+	float baseLandRatio;
+	float baseWaterRatio;
 
 	int max_distance;
 
+	// center of base (mean value of centers of all base sectors)
 	float3 base_center;
 
 	// are there any free metal spots within the base

Modified: trunk/AI/Global/AAI/AAIBuildTable.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIBuildTable.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIBuildTable.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -15,6 +15,7 @@
 const UnitDef** AAIBuildTable::unitList = 0;
 list&lt;int&gt;* AAIBuildTable::units_of_category[MOBILE_CONSTRUCTOR+1];
 int AAIBuildTable::aai_instances = 0; 
+char AAIBuildTable::buildtable_filename[500];
 float* AAIBuildTable::avg_cost[MOBILE_CONSTRUCTOR+1]; 
 float* AAIBuildTable::avg_buildtime[MOBILE_CONSTRUCTOR+1];
 float* AAIBuildTable::avg_value[MOBILE_CONSTRUCTOR+1];
@@ -2057,8 +2058,6 @@
 	float best_ranking = -10000, my_ranking;
 	int best_unit = 0;
 
-	int c = 0;
-	
 	float max_cost = this-&gt;max_cost[GROUND_ASSAULT][side-1];
 	float max_range = max_value[GROUND_ASSAULT][side-1];
 	float max_speed = this-&gt;max_speed[0][side-1];
@@ -2069,6 +2068,8 @@
 	UnitTypeStatic *unit;
 
 	// precache eff
+	int c = 0;
+
 	for(list&lt;int&gt;::iterator i = units_of_category[GROUND_ASSAULT][side].begin(); i != units_of_category[GROUND_ASSAULT][side].end(); ++i)
 	{
 		unit = &amp;units_static[*i];
@@ -2091,7 +2092,7 @@
 		max_power = 1;
 
 	if(max_efficiency &lt;= 0)
-		max_efficiency = 0;
+		max_efficiency = 1;
 
 	// TODO: improve algorithm
 	for(list&lt;int&gt;::iterator i = units_of_category[GROUND_ASSAULT][side].begin(); i != units_of_category[GROUND_ASSAULT][side].end(); ++i)
@@ -2641,21 +2642,20 @@
 	else	// load data
 	{
 		// get filename
-		char filename[500];
 		char buffer[500];
 		strcpy(buffer, MAIN_PATH);
 		strcat(buffer, MOD_LEARN_PATH);
 		strcat(buffer, cb-&gt;GetModName());
-		ReplaceExtension (buffer, filename, sizeof(filename), &quot;.dat&quot;);
+		ReplaceExtension (buffer, buildtable_filename, sizeof(buildtable_filename), &quot;.dat&quot;);
 
-		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename); 
+		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buildtable_filename); 
 
 		FILE *load_file;
 
 		int tmp = 0, bo = 0, bb = 0, cat = 0;
 	
 		// load units if file exists
-		if((load_file = fopen(filename, &quot;r&quot;)))
+		if((load_file = fopen(buildtable_filename, &quot;r&quot;)))
 		{
 			// check if correct version
 			fscanf(load_file, &quot;%s&quot;, buffer);
@@ -2686,9 +2686,7 @@
 				}
 			}
 
-//			units_static = new UnitTypeStatic[numOfUnits+1];
 			units_static.resize(numOfUnits+1);
-//			units_dynamic = new UnitTypeDynamic[numOfUnits+1];
 			units_dynamic.resize(numOfUnits+1);
 			fixed_eff.resize(numOfUnits+1, vector&lt;float&gt;(combat_categories));
 
@@ -2703,7 +2701,6 @@
 									&amp;cat, &amp;bo, &amp;bb);
 
 				// get memory for eff
-//				units_static[i].efficiency = new float[combat_categories];
 				units_static[i].efficiency.resize(combat_categories);
 
 				// load eff
@@ -2794,28 +2791,17 @@
 	}
 
 	// get filename
-	char filename[500];
-	char buffer[500];
-	strcpy(buffer, MAIN_PATH);
-	strcat(buffer, MOD_LEARN_PATH);
-	strcat(buffer, cb-&gt;GetModName());
-	ReplaceExtension (buffer, filename, sizeof(filename), &quot;.dat&quot;);
+	FILE *save_file = fopen(buildtable_filename, &quot;w+&quot;);
 
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename); 
-
-	//fprintf(ai-&gt;file, &quot;Saving buildtable to %s\n&quot;, filename);
-
-	FILE *save_file = fopen(filename, &quot;w+&quot;);
-
 	// file version
 	fprintf(save_file, &quot;%s \n&quot;, TABLE_FILE_VERSION);
 	
-	MapType mapType;
+	MapType map_type;
 	
 	if(ai-&gt;map)
-		mapType = ai-&gt;map-&gt;mapType;
+		map_type = ai-&gt;map-&gt;map_type;
 	else
-		mapType = LAND_MAP;
+		map_type = LAND_MAP;
 
 	float sum = 0;
 
@@ -2825,19 +2811,19 @@
 		// rebalance mod_usefulness
 		if(cfg-&gt;AIR_ONLY_MOD)
 		{
-			sum = mod_usefulness[0][i][mapType] + mod_usefulness[2][i][mapType] + mod_usefulness[3][i][mapType] + mod_usefulness[4][i][mapType];
-			mod_usefulness[0][i][mapType] *= (100.0/sum);
-			mod_usefulness[2][i][mapType] *= (100.0/sum);
-			mod_usefulness[3][i][mapType] *= (100.0/sum);
-			mod_usefulness[4][i][mapType] *= (100.0/sum);
+			sum = mod_usefulness[0][i][map_type] + mod_usefulness[2][i][map_type] + mod_usefulness[3][i][map_type] + mod_usefulness[4][i][map_type];
+			mod_usefulness[0][i][map_type] *= (100.0/sum);
+			mod_usefulness[2][i][map_type] *= (100.0/sum);
+			mod_usefulness[3][i][map_type] *= (100.0/sum);
+			mod_usefulness[4][i][map_type] *= (100.0/sum);
 		}
-		else if(mapType == LAND_MAP)
+		else if(map_type == LAND_MAP)
 		{
 			sum = mod_usefulness[0][i][LAND_MAP] + mod_usefulness[2][i][LAND_MAP];
 			mod_usefulness[0][i][LAND_MAP] *= (100.0/sum);
 			mod_usefulness[2][i][LAND_MAP] *= (100.0/sum);
 		}
-		else if(mapType == LAND_WATER_MAP)
+		else if(map_type == LAND_WATER_MAP)
 		{
 			sum = mod_usefulness[0][i][LAND_WATER_MAP] + mod_usefulness[2][i][LAND_WATER_MAP] + mod_usefulness[3][i][LAND_WATER_MAP] + mod_usefulness[4][i][LAND_WATER_MAP];
 			mod_usefulness[0][i][LAND_WATER_MAP] *= (100.0/sum);
@@ -2845,7 +2831,7 @@
 			mod_usefulness[3][i][LAND_WATER_MAP] *= (100.0/sum);
 			mod_usefulness[4][i][LAND_WATER_MAP] *= (100.0/sum);
 		}
-		else if(mapType == WATER_MAP)
+		else if(map_type == WATER_MAP)
 		{
 			sum = mod_usefulness[2][i][WATER_MAP] + mod_usefulness[3][i][WATER_MAP] + mod_usefulness[4][i][WATER_MAP];
 			mod_usefulness[2][i][WATER_MAP] *= (100.0/sum);
@@ -3159,11 +3145,11 @@
 	bool scout = false;
 	double rating = 1;
 	double combat_units = 0;
-	float ground = (ai-&gt;map-&gt;map_usefulness[0][ai-&gt;side-1] + mod_usefulness[0][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
-	float hover = (ai-&gt;map-&gt;map_usefulness[2][ai-&gt;side-1] + mod_usefulness[2][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
+	float ground = (ai-&gt;map-&gt;map_usefulness[0][ai-&gt;side-1] + mod_usefulness[0][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) / 10.0f;
+	float hover = (ai-&gt;map-&gt;map_usefulness[2][ai-&gt;side-1] + mod_usefulness[2][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) / 10.0f;
 	float air = 10/((float)(cfg-&gt;AIRCRAFT_RATE));
-	float sea = (ai-&gt;map-&gt;map_usefulness[3][ai-&gt;side-1] + mod_usefulness[3][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
-	float submarine = (ai-&gt;map-&gt;map_usefulness[4][ai-&gt;side-1] + mod_usefulness[4][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) /10.0f;
+	float sea = (ai-&gt;map-&gt;map_usefulness[3][ai-&gt;side-1] + mod_usefulness[3][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) / 10.0f;
+	float submarine = (ai-&gt;map-&gt;map_usefulness[4][ai-&gt;side-1] + mod_usefulness[4][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) /10.0f;
 
 	if(cfg-&gt;AIR_ONLY_MOD)
 	{
@@ -3200,7 +3186,7 @@
 			}
 		}
 	}
-	else if(ai-&gt;map-&gt;mapType == LAND_MAP)
+	else if(ai-&gt;map-&gt;map_type == LAND_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3230,7 +3216,7 @@
 			}
 		}	
 	}
-	else if(ai-&gt;map-&gt;mapType == AIR_MAP)
+	else if(ai-&gt;map-&gt;map_type == AIR_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3250,7 +3236,7 @@
 			}
 		}	
 	}
-	else if(ai-&gt;map-&gt;mapType == LAND_WATER_MAP)
+	else if(ai-&gt;map-&gt;map_type == LAND_WATER_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3290,7 +3276,7 @@
 			}
 		}
 	}
-	else if(ai-&gt;map-&gt;mapType == WATER_MAP)
+	else if(ai-&gt;map-&gt;map_type == WATER_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3369,7 +3355,7 @@
 		int buildings = 10;
 
 		// only cout buildings that are likely to be built on that type of map
-		if(ai-&gt;map-&gt;mapType == LAND_MAP)
+		if(ai-&gt;map-&gt;map_type == LAND_MAP)
 		{
 			for(list&lt;int&gt;::iterator building = units_static[def_id].canBuildList.begin(); building != units_static[def_id].canBuildList.end(); ++building)
 			{
@@ -3377,7 +3363,7 @@
 					++buildings;
 			}
 		}
-		else if(ai-&gt;map-&gt;mapType == WATER_MAP)
+		else if(ai-&gt;map-&gt;map_type == WATER_MAP)
 		{
 			for(list&lt;int&gt;::iterator building = units_static[def_id].canBuildList.begin(); building != units_static[def_id].canBuildList.end(); ++building)
 			{
@@ -3418,6 +3404,9 @@
 			if(units_dynamic[*unit].constructorsAvailable &gt; 0)
 				my_rating += 4.0f;
 
+			// apply terrain modifier
+			my_rating *= ai-&gt;brain-&gt;GetBaseBuildspaceRatio(units_static[*unit].movement_type);
+
 			if(my_rating &gt; best_rating)
 			{	
 				best_rating = my_rating;
@@ -3458,7 +3447,7 @@
 				
 				// increase counter if mobile factory is a builder as well
 				if(units_static[constructor].unit_type &amp; UNIT_TYPE_BUILDER)
-					ai-&gt;futureBuilders += 1;
+					ai-&gt;ut-&gt;futureBuilders += 1;
 
 				for(list&lt;int&gt;::iterator j = units_static[constructor].canBuildList.begin(); j != units_static[constructor].canBuildList.end(); ++j)
 				{
@@ -3521,7 +3510,7 @@
 		if(ai-&gt;execute-&gt;AddUnitToBuildqueue(builder, 1, true))
 		{
 			units_dynamic[builder].requested += 1;
-			ai-&gt;futureBuilders += 1;
+			ai-&gt;ut-&gt;futureBuilders += 1;
 
 			// set all its buildoptions buildable
 			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); j++)
@@ -3543,7 +3532,7 @@
 
 	float cost = ai-&gt;brain-&gt;Affordable()/2.0f; 
 	float buildspeed = 3.0f;
-	float urgency = 12.0f / (ai-&gt;activeBuilders + ai-&gt;futureBuilders + 3);
+	float urgency = 12.0f / (ai-&gt;ut-&gt;activeBuilders + ai-&gt;ut-&gt;futureBuilders + 3);
 
 	float max_buildtime = max_builder_buildtime[ai-&gt;side-1]/256.0;
 		
@@ -3579,7 +3568,7 @@
 		if(ai-&gt;execute-&gt;AddUnitToBuildqueue(builder, 1, true))
 		{
 			units_dynamic[builder].requested += 1;
-			ai-&gt;futureBuilders += 1;
+			ai-&gt;ut-&gt;futureBuilders += 1;
 
 			// increase number of requested builders of all buildoptions
 			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); ++j)

Modified: trunk/AI/Global/AAI/AAIBuildTable.h
===================================================================
--- trunk/AI/Global/AAI/AAIBuildTable.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIBuildTable.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -205,6 +205,9 @@
 	// how many aai instances have been initialized
 	static int aai_instances; 
 
+	// path/name of the file in which AAI stores the build table
+	static char buildtable_filename[500];
+
 	// all the unit defs
 	static const UnitDef **unitList;
 	

Modified: trunk/AI/Global/AAI/AAIConstructor.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIConstructor.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIConstructor.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -349,7 +349,7 @@
 	ai-&gt;map-&gt;Pos2FinalBuildPos(&amp;pos, def);
 	
 	// give order if building can be placed at the desired position (position lies within a valid sector)
-	if(ai-&gt;execute-&gt;InitBuildingAt(def, pos))
+	if(ai-&gt;execute-&gt;InitBuildingAt(def, pos, water))
 	{
 		order_tick = cb-&gt;GetCurrentFrame();
 

Modified: trunk/AI/Global/AAI/AAIExecute.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIExecute.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIExecute.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -119,10 +119,12 @@
 		ChooseDifferentStartingSector(x, y);
 	}
 
-	if(map-&gt;mapType == WATER_MAP)
+	if(map-&gt;map_type == WATER_MAP)
 		brain-&gt;ExpandBase(WATER_SECTOR);
-	else 
+	else if(map-&gt;map_type == LAND_MAP)
 		brain-&gt;ExpandBase(LAND_SECTOR);
+	else 
+		brain-&gt;ExpandBase(LAND_WATER_SECTOR);
 	
 	// now that we know the side, init buildques
 	InitBuildques();
@@ -159,15 +161,8 @@
 	}
 }
 
-bool AAIExecute::InitBuildingAt(const UnitDef *def, float3 pos)
+bool AAIExecute::InitBuildingAt(const UnitDef *def, float3 pos, bool water)
 {			
-	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
-
-	bool water = false;
-
-	if(pos.y &lt; 0) 
-		water = true;
-
 	// determine target sector
 	int x = pos.x/map-&gt;xSectorSize;
 	int y = pos.z/map-&gt;ySectorSize;
@@ -175,8 +170,10 @@
 	// drop bad sectors (should only happen when defending mexes at the edge of the map)
 	if(x &lt; 0 || y &lt; 0 || x &gt;= map-&gt;xSectors || y &gt;= map-&gt;ySectors)
 		return false;
-	
+
 	// increase number of units of that category in the target sector
+	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
+	
 	map-&gt;sector[x][y].unitsOfType[category] += 1;
 	map-&gt;sector[x][y].own_structures += bt-&gt;units_static[def-&gt;id].cost;
 
@@ -186,7 +183,7 @@
 	// factory
 	if(bt-&gt;IsFactory(def-&gt;id))
 	{
-		ai-&gt;futureFactories += 1;
+		ut-&gt;futureFactories += 1;
 
 		if(water)
 			map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 5);
@@ -255,10 +252,8 @@
 	// determine continent if necessary
 	int continent_id = -1;
 
-	if(bt-&gt;units_static[def_id].movement_type &amp; MOVE_TYPE_CONTINENT_BOUND) {
-		float3 unitPos = cb-&gt;GetUnitPos(unit_id);
-		continent_id = map-&gt;GetContinentID(&amp;unitPos);
-	}
+	if(bt-&gt;units_static[def_id].movement_type &amp; MOVE_TYPE_CONTINENT_BOUND) 
+		continent_id = map-&gt;GetContinentID(&amp;cb-&gt;GetUnitPos(unit_id));
 
 	// try to add unit to an existing group 
 	for(list&lt;AAIGroup*&gt;::iterator group = ai-&gt;group_list[category].begin(); group != ai-&gt;group_list[category].end(); ++group)
@@ -274,10 +269,8 @@
 	// -&gt; create new one
 
 	// get continent for ground assault units, even if they are amphibious (otherwise non amphib ground units will be added no matter which continent they are on)
-	if(category == GROUND_ASSAULT  &amp;&amp; continent_id == 1) {
-		float3 unitPos = cb-&gt;GetUnitPos(unit_id);
-		continent_id = map-&gt;GetContinentID(&amp;unitPos);
-	}
+	if(category == GROUND_ASSAULT  &amp;&amp; continent_id == -1)
+		continent_id = map-&gt;GetContinentID(&amp;cb-&gt;GetUnitPos(unit_id));
 
 	AAIGroup *new_group = new AAIGroup(ai, bt-&gt;unitList[def_id-1], unit_type, continent_id);
 
@@ -295,7 +288,7 @@
 
 	// explore map -&gt; send scouts to different sectors, build new scouts if needed etc.
 	// check number of scouts and order new ones if necessary
-	if(ai-&gt;activeScouts + ai-&gt;futureScouts &lt; cfg-&gt;MAX_SCOUTS)
+	if(ut-&gt;activeScouts + ut-&gt;futureScouts &lt; cfg-&gt;MAX_SCOUTS)
 	{
 		int scout = 0;
 
@@ -324,14 +317,14 @@
 		// always: MOVE_TYPE_AIR, MOVE_TYPE_HOVER, MOVE_TYPE_AMPHIB
 		unsigned int allowed_movement_types = 22;
 		
-		if(map-&gt;mapType == LAND_MAP)
+		if(map-&gt;map_type == LAND_MAP)
 			allowed_movement_types |= MOVE_TYPE_GROUND;
-		else if(map-&gt;mapType == LAND_WATER_MAP)
+		else if(map-&gt;map_type == LAND_WATER_MAP)
 		{
 			allowed_movement_types |= MOVE_TYPE_GROUND;
 			allowed_movement_types |= MOVE_TYPE_SEA;
 		}
-		else if(map-&gt;mapType == WATER_MAP)
+		else if(map-&gt;map_type == WATER_MAP)
 			allowed_movement_types |= MOVE_TYPE_SEA;
 		
 
@@ -345,19 +338,19 @@
 		{
 			bool urgent = true;
 
-			if(ai-&gt;activeScouts &gt;= 2)
+			if(ut-&gt;activeScouts &gt;= 2)
 				urgent = false;
 
 			if(AddUnitToBuildqueue(scout, 1, urgent))
 			{
-				++ai-&gt;futureScouts;
+				++ut-&gt;futureScouts;
 				++bt-&gt;units_dynamic[scout].requested;
 			}
 		}
 	}
 
 	// get idle scouts and let them explore the map
-	for(list&lt;int&gt;::iterator scout = ai-&gt;scouts.begin(); scout != ai-&gt;scouts.end(); ++scout)
+	for(set&lt;int&gt;::iterator scout = ut-&gt;scouts.begin(); scout != ut-&gt;scouts.end(); ++scout)
 	{
 		if(!IsBusy(*scout))
 		{
@@ -437,107 +430,6 @@
 	return best_pos;
 }
 
-AAIMetalSpot* AAIExecute::FindMetalSpot(bool land, bool water)
-{
-	// prevent crashes on smaller maps 
-	int max_distance = min(cfg-&gt;MAX_MEX_DISTANCE, brain-&gt;max_distance);
-
-	for(int sector_dist = 0; sector_dist &lt; max_distance; ++sector_dist)
-	{
-		for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[sector_dist].begin();sector != brain-&gt;sectors[sector_dist].end(); sector++)
-		{
-			if(sector_dist == 0)
-			{
-				if((*sector)-&gt;freeMetalSpots)
-				{
-					for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
-					{
-						if(!(*spot)-&gt;occupied)	
-						{
-							if( (land &amp;&amp; (*spot)-&gt;pos.y &gt;= 0) ||(water &amp;&amp; (*spot)-&gt;pos.y &lt; 0) )
-								return *spot;
-						}
-					}
-				}
-			}
-			else
-			{
-				if((*sector)-&gt;freeMetalSpots &amp;&amp; brain-&gt;IsSafeSector(*sector) &amp;&amp; map-&gt;team_sector_map[(*sector)-&gt;x][(*sector)-&gt;y] == -1 )
-				{
-					for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
-					{
-						if(!(*spot)-&gt;occupied)	
-						{
-							if( (land &amp;&amp; (*spot)-&gt;pos.y &gt;= 0) ||(water &amp;&amp; (*spot)-&gt;pos.y &lt; 0) )
-								return *spot;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return 0;
-}
-
-AAIMetalSpot* AAIExecute::FindMetalSpotClosestToBuilder(int land_mex, int water_mex)
-{
-	AAIMetalSpot *best_spot = 0;
-	float shortest_dist = 10000.0f, dist;
-	float3 builder_pos;
-	AAIConstructor *builder = 0;
-
-	// prevent crashes on smaller maps 
-	int max_distance = min(cfg-&gt;MAX_MEX_DISTANCE, brain-&gt;max_distance);
-
-	// dont search for too long if possible spot already found
-	int min_spot_dist = -1;
-
-	// look for free spots in all sectors within max range
-	for(int sector_dist = 0; sector_dist &lt; max_distance; ++sector_dist)
-	{
-		// skip search if spot already found 
-		if(min_spot_dist &gt;= 0 &amp;&amp; sector_dist - min_spot_dist &gt; 2)
-			return best_spot;
-
-		for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[sector_dist].begin(); sector != brain-&gt;sectors[sector_dist].end(); sector++)
-		{
-			if((*sector)-&gt;freeMetalSpots &amp;&amp; (*sector)-&gt;enemy_structures &lt;= 0  &amp;&amp; (*sector)-&gt;lost_units[MOBILE_CONSTRUCTOR-COMMANDER]  &lt; 0.5 &amp;&amp; (*sector)-&gt;threat &lt;= 0)
-			{
-				for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
-				{
-					if(!(*spot)-&gt;occupied)	
-					{
-						if((*spot)-&gt;pos.y &gt; 0)
-							builder = ut-&gt;FindClosestBuilder(land_mex, (*spot)-&gt;pos, true);
-						else
-							builder = ut-&gt;FindClosestBuilder(water_mex, (*spot)-&gt;pos, true);
-
-						if(builder)
-						{
-							// get distance to pos
-							builder_pos = cb-&gt;GetUnitPos(builder-&gt;unit_id);
-
-							dist = sqrt( pow(((*spot)-&gt;pos.x - builder_pos.x), 2) + pow(((*spot)-&gt;pos.z - builder_pos.z),2) ) / bt-&gt;unitList[builder-&gt;def_id-1]-&gt;speed;
-
-							if(dist &lt; shortest_dist)
-							{
-								best_spot = *spot;
-								shortest_dist = dist;
-
-								min_spot_dist = sector_dist;
-							}	
-						}
-					}	
-				}
-			}
-		}
-	}
-
-	return best_spot;
-}
-
-
 float AAIExecute::GetTotalGroundPower()
 {
 	float power = 0;
@@ -592,7 +484,7 @@
 			{
 				my_rating = (1 + 2 * (float) bt-&gt;units_dynamic[*fac].active) / (temp_buildqueue-&gt;size() + 3);
 
-				if(map-&gt;mapType == WATER_MAP &amp;&amp; !bt-&gt;CanPlacedWater(*fac))
+				if(map-&gt;map_type == WATER_MAP &amp;&amp; !bt-&gt;CanPlacedWater(*fac))
 					my_rating /= 10.0;
 			}
 			else 
@@ -815,15 +707,13 @@
 
 bool AAIExecute::BuildExtractor()
 {
-	if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
+	if(ai-&gt;futureUnits[POWER_PLANT] + ai-&gt;requestedUnits[POWER_PLANT] &gt; 2)
 		return true;
 
-	AAIConstructor *builder; 
-	AAIMetalSpot *spot = 0;
+	AAIConstructor *builder, *land_builder = 0, *water_builder = 0; 
 	float3 pos;
-	int land_mex;
-	int water_mex;
-	bool water;
+	int land_mex, water_mex;
+	float min_dist;
 
 	float cost = 0.25f + brain-&gt;Affordable() / 6.0f;
 	float efficiency = 6.0 / (cost + 0.75f);
@@ -840,16 +730,15 @@
 			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
 		}
 
-		builder = ut-&gt;FindBuilder(land_mex, true);
+		land_builder = ut-&gt;FindBuilder(land_mex, true);
 
-		if(builder)
+		if(land_builder)
 		{
-			pos = GetBuildsite(builder-&gt;unit_id, land_mex, EXTRACTOR);
+			pos = GetBuildsite(land_builder-&gt;unit_id, land_mex, EXTRACTOR);
 
 			if(pos.x != 0)
-			{
-				builder-&gt;GiveConstructionOrder(land_mex, pos, false);
-			}
+				land_builder-&gt;GiveConstructionOrder(land_mex, pos, false);
+			
 			return true;
 		}
 		else
@@ -858,156 +747,141 @@
 			return false;
 		}
 	}
-	else // normal map
+	
+	// normal map
+
+	// select a land/water mex 
+	if(map-&gt;land_metal_spots &gt; 0)
 	{
-		// different behaviour dependent on number of builders (to save time in late game)
-		if(ut-&gt;constructors.size() &lt; 4)
+		land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, false);
+
+		if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsRequested &lt;= 0)
 		{
-			// get id of an extractor and look for suitable builder
-			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, false);
+			bt-&gt;BuildConstructorFor(land_mex);
+			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
+		}
+	}
 
-			if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsRequested &lt;= 0)
-			{
-				bt-&gt;BuildConstructorFor(land_mex);
-				land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
-			}
+	if(map-&gt;water_metal_spots &gt; 0)
+	{
+		water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, false);
 
-			water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, false);
+		if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsRequested &lt;= 0)
+		{
+			bt-&gt;BuildConstructorFor(water_mex);
+			water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, true);
+		}
+	}
 
-			if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsRequested &lt;= 0)
-			{
-				bt-&gt;BuildConstructorFor(water_mex);
-				water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, true);
-			}
+	// check if there is any builder for at least one of the selected extractors available
+	land_builder = ut-&gt;FindBuilder(land_mex, true);
+	water_builder = ut-&gt;FindBuilder(water_mex, true);
 
-			// find metal spot with lowest distance to available builders
-			spot = FindMetalSpotClosestToBuilder(land_mex, water_mex);
-	
-			if(spot)
-			{	
-				// check if land or sea spot
-				if(cb-&gt;GetElevation(spot-&gt;pos.x, spot-&gt;pos.z) &lt; 0)
-				{
-					water = true;
+	if(!land_builder &amp;&amp; !water_builder)
+		return false;
 
-					// build the water mex instead of land mex
-					land_mex = water_mex;	
-				}
-				else
-					water = false;
-		
-				// look for suitable builder
-				int x = spot-&gt;pos.x/map-&gt;xSectorSize;
-				int y = spot-&gt;pos.z/map-&gt;ySectorSize;
+	// check the first 10 free spots for the one with least distance to available builder
+	int max_spots = 10;
+	int current_spot = 0;
+	bool free_spot_found = false;
 
-				// only allow commander if spot is close to own base
-				if(map-&gt;sector[x][y].distance_to_base &lt;= 0 || (brain-&gt;sectors[0].size() &lt; 3 &amp;&amp; map-&gt;sector[x][y].distance_to_base &lt;= 1) )
-					builder = ut-&gt;FindClosestBuilder(land_mex, spot-&gt;pos, true);
-				else
-					builder = ut-&gt;FindClosestBuilder(land_mex, spot-&gt;pos, false);
-		
-				if(builder)
-				{
-					builder-&gt;GiveConstructionOrder(land_mex, spot-&gt;pos, water);
-					spot-&gt;occupied = true;
-				}
-				else
-				{
-					bt-&gt;AddBuilder(land_mex);
-					return false;
-				}
-			}
-			else
-			{	
-				// request metal makers if no spot found (only if spot was not found due to no buidlers available)
-				builder = ut-&gt;FindClosestBuilder(land_mex, brain-&gt;base_center, true);
+	vector&lt;AAIMetalSpot*&gt; spots;
+	spots.resize(max_spots);
+	vector&lt;AAIConstructor*&gt; builders;
+	builders.resize(max_spots, 0);
 
-				if(!builder)	
-					builder = ut-&gt;FindClosestBuilder(water_mex, brain-&gt;base_center, true);
-		
-				if(!builder)
-				{
-					if(map-&gt;mapType == WATER_MAP &amp;&amp; !cfg-&gt;AIR_ONLY_MOD)
-						bt-&gt;AddBuilder(water_mex);
-					else
-						bt-&gt;AddBuilder(land_mex);
-				
-					return false;
-				}
-				else
-				{
-					if(ai-&gt;activeUnits[METAL_MAKER] &lt; cfg-&gt;MAX_METAL_MAKERS &amp;&amp; urgency[METAL_MAKER] &lt;= GetMetalUrgency() / 2.0f)
-						urgency[METAL_MAKER] = GetMetalUrgency() / 2.0f;
-				}
-			}
-		}
-		else
-		{
-			bool land = true, water = true;
+	vector&lt;float&gt; dist_to_builder;
 
-			// get next free metal spot
-			AAIMetalSpot *spot = FindMetalSpot(land, water);
+	// determine max search dist - prevent crashes on smaller maps 
+	int max_search_dist = min(cfg-&gt;MAX_MEX_DISTANCE, brain-&gt;max_distance);
 
-			if(spot)
+	for(int sector_dist = 0; sector_dist &lt; max_search_dist; ++sector_dist)
+	{
+		for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[sector_dist].begin(); sector != brain-&gt;sectors[sector_dist].end(); ++sector)
+		{
+			if(brain-&gt;MexConstructionAllowedInSector(*sector))
 			{
-				int x = spot-&gt;pos.x/map-&gt;xSectorSize;
-				int y = spot-&gt;pos.z/map-&gt;ySectorSize;
+				for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
+				{
+					if(!(*spot)-&gt;occupied)
+					{
+						//
+						if((*spot)-&gt;pos.y &gt;= 0 &amp;&amp; land_builder)
+						{
+							free_spot_found = true;
 
-				if(cb-&gt;GetElevation(spot-&gt;pos.x, spot-&gt;pos.z) &gt;= 0) 
-					water = false;	
-				else
-					water = true;
-				
-				// choose mex dependend on safety
-				bool armed = false;
+							builder = ut-&gt;FindClosestBuilder(land_mex, &amp;(*spot)-&gt;pos, brain-&gt;CommanderAllowedForConstructionAt(*sector, &amp;(*spot)-&gt;pos), &amp;min_dist);
 
-				//if(map-&gt;sector[x][y].lost_units[EXTRACTOR-COMMANDER] &gt; 0.01f || map-&gt;sector[x][y].distance_to_base &gt; 2)
-				if(map-&gt;sector[x][y].distance_to_base &gt; 2)
-				{
-					cost = 6.0f;
-					armed = true;
-					efficiency = 1.0f;
-				}
+							if(builder)
+							{
+								dist_to_builder.push_back(min_dist);
+								spots[current_spot] = *spot;
+								builders[current_spot] = builder;
 
-				int mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, armed, water, false);
+								++current_spot;
+							}
+						}
+						else if((*spot)-&gt;pos.y &lt; 0 &amp;&amp; water_builder)
+						{
+							free_spot_found = true;
 
-				if(mex &amp;&amp; bt-&gt;units_dynamic[mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[mex].constructorsAvailable &lt;= 0)
-				{
-					bt-&gt;BuildConstructorFor(mex);
+							builder = ut-&gt;FindClosestBuilder(water_mex, &amp;(*spot)-&gt;pos, brain-&gt;CommanderAllowedForConstructionAt(*sector, &amp;(*spot)-&gt;pos), &amp;min_dist);
 
-					mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, armed, water, true);
-				}
+							if(builder)
+							{
+								dist_to_builder.push_back(min_dist);
+								spots[current_spot] = *spot;
+								builders[current_spot] = builder;
 
-				if(mex)
-				{
-					if(map-&gt;sector[x][y].distance_to_base &lt;= 0 || (brain-&gt;sectors[0].size() &lt; 3 &amp;&amp; map-&gt;sector[x][y].distance_to_base &lt;= 1) )
-						builder = ut-&gt;FindClosestBuilder(mex, spot-&gt;pos, true);
-					else
-						builder = ut-&gt;FindClosestBuilder(mex, spot-&gt;pos, false);
+								++current_spot;
+							}
+						}
 
-					if(builder)
-					{
-						builder-&gt;GiveConstructionOrder(mex, spot-&gt;pos, water);
-						spot-&gt;occupied = true;
+						if(current_spot &gt;= max_spots)
+							break;
 					}
-					else //try to request more builders if none available	
-						bt-&gt;AddBuilder(mex);
 				}
 			}
-			else
-			{	
-				// check mex upgrade
-				if(ai-&gt;futureUnits[EXTRACTOR] + ai-&gt;requestedUnits[EXTRACTOR] + ai-&gt;requestedUnits[EXTRACTOR] &lt; 1)
-					CheckMexUpgrade();
 
-				// request metal makers if no spot found
-				if(ai-&gt;activeUnits[METAL_MAKER] &lt; cfg-&gt;MAX_METAL_MAKERS &amp;&amp; urgency[METAL_MAKER] &lt;= GetMetalUrgency() / 2.0f)
-					urgency[METAL_MAKER] = GetMetalUrgency() / 2.0f;
-			}
+			if(current_spot &gt;= max_spots)
+				break;
 		}
+
+		if(current_spot &gt;= max_spots)
+			break;
 	}
 
-	return true;
+	// look for spot with minimum dist to available builder
+	int best = -1;
+	min_dist = 1000000.0f;
+
+	for(int i = 0; i &lt; dist_to_builder.size(); ++i)
+	{
+		if(dist_to_builder[i] &lt; min_dist)
+		{
+			best = i;
+			min_dist = dist_to_builder[i];
+		}
+	}
+
+	// order mex construction for best spot
+	if(best &gt;= 0)
+	{
+		if(spots[best]-&gt;pos.y &gt;= 0)
+			builders[best]-&gt;GiveConstructionOrder(land_mex, spots[best]-&gt;pos, false);
+		else
+			builders[best]-&gt;GiveConstructionOrder(water_mex, spots[best]-&gt;pos, true);
+				
+		spots[best]-&gt;occupied = true;
+
+		return true;		
+	}
+	
+	// dont build other things if construction could not be started due to unavailable builders
+	if(free_spot_found)
+		return false;
+	else
+		return true;
 }
 
 bool AAIExecute::BuildPowerPlant()
@@ -1055,7 +929,7 @@
 		// power plant construction has not started -&gt; builder is still on its way to constrcution site, wait until starting a new power plant
 		return false;
 	}
-	else if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[POWER_PLANT] &gt;= 2)
+	else if(ut-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[POWER_PLANT] &gt;= 2)
 		return true;
 
 	// stop building power plants if already to much available energy
@@ -1146,7 +1020,8 @@
 
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(ground_plant, pos, true);
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(ground_plant, &amp;pos, true, &amp;min_dist);
 
 				if(builder)
 				{
@@ -1188,7 +1063,8 @@
 
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(water_plant, pos, true);
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(water_plant, &amp;pos, true, &amp;min_dist);
 
 				if(builder)
 				{
@@ -1215,7 +1091,7 @@
 
 bool AAIExecute::BuildMetalMaker()
 {
-	if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
+	if(ut-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
 		return true;
 
 	if(ai-&gt;futureUnits[METAL_MAKER] + ai-&gt;requestedUnits[METAL_MAKER] &gt; 0 || disabledMMakers &gt;= 1)
@@ -1278,7 +1154,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(maker, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(maker, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1319,7 +1196,8 @@
 	
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(maker, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(maker, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1350,7 +1228,7 @@
 	if(ai-&gt;futureUnits[STORAGE] + ai-&gt;requestedUnits[STORAGE]&gt; 0 || ai-&gt;activeUnits[STORAGE] &gt;= cfg-&gt;MAX_STORAGE)
 		return true;
 
-	if(ai-&gt;activeFactories &lt; 2)
+	if(ut-&gt;activeFactories &lt; 2)
 		return true;
 
 	int storage = 0;
@@ -1400,7 +1278,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(storage, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(storage, &amp;pos, true, &amp;min_dist);
 	
 					if(builder)
 					{
@@ -1439,7 +1318,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(storage, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(storage, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1511,7 +1391,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(airbase, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(airbase, &amp;pos, true, &amp;min_dist);
 	
 					if(builder)
 					{
@@ -1550,7 +1431,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(airbase, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(airbase, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1725,7 +1607,8 @@
 				
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(building, pos, true);	
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(building, &amp;pos, true,&amp;min_dist);	
 
 				if(builder)
 				{
@@ -1784,7 +1667,8 @@
 				
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(building, pos, true);
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(building, &amp;pos, true, &amp;min_dist);
 
 				if(builder)
 				{
@@ -1857,7 +1741,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(arty, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(arty, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1891,7 +1776,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(arty, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(arty, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1929,7 +1815,7 @@
 			my_rating = bt-&gt;GetFactoryRating(*fac) / pow( (float) (1 + bt-&gt;units_dynamic[*fac].active), 2.0f);
 			my_rating *= (1 + sqrt(2.0 + (float) GetBuildqueueOfFactory(*fac)-&gt;size())); 
 
-			if(ai-&gt;activeFactories &lt; 1)
+			if(ut-&gt;activeFactories &lt; 1)
 				my_rating /= bt-&gt;units_static[*fac].cost;
 
 			// skip factories that could not be built 
@@ -2022,7 +1908,9 @@
 			
 		if(pos.x &gt; 0)
 		{
-			builder = ut-&gt;FindClosestBuilder(building, pos, true);
+			float min_dist;
+
+			builder = ut-&gt;FindClosestBuilder(building, &amp;pos, true, &amp;min_dist);
 			
 			if(builder)
 			{
@@ -2232,7 +2120,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(radar, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(radar, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2267,7 +2156,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(radar, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(radar, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2342,7 +2232,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(jammer, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(jammer, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2377,7 +2268,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(jammer, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(jammer, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2399,7 +2291,7 @@
 
 void AAIExecute::DefendMex(int mex, int def_id)
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES)
+	if(ut-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES)
 		return;
 
 	float3 pos = cb-&gt;GetUnitPos(mex);
@@ -2433,7 +2325,7 @@
 					defence = bt-&gt;GetDefenceBuilding(ai-&gt;side, 2, 1, 1, 1, 0.5, 0, 0, 0, 4, 0.1, 1, false, true);
 				else
 				{
-					if(map-&gt;mapType == AIR_MAP)
+					if(map-&gt;map_type == AIR_MAP)
 						defence = bt-&gt;GetDefenceBuilding(ai-&gt;side, 2, 1, 1, 0, 2, 0, 0, 0, 4, 0.1, 1, false, true); 
 					else
 						defence = bt-&gt;GetDefenceBuilding(ai-&gt;side, 2, 1, 1, 1.5, 0.5, 0, 0, 0, 4, 0.1, 3, false, true); 
@@ -2470,11 +2362,12 @@
 				if(pos.x &gt; 0)
 				{
 					AAIConstructor *builder;
+					float min_dist;
 
 					if(brain-&gt;sectors[0].size() &gt; 2)
-						builder = ut-&gt;FindClosestBuilder(defence, pos, false);
+						builder = ut-&gt;FindClosestBuilder(defence, &amp;pos, false, &amp;min_dist);
 					else
-						builder = ut-&gt;FindClosestBuilder(defence, pos, true);
+						builder = ut-&gt;FindClosestBuilder(defence, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 						builder-&gt;GiveConstructionOrder(defence, pos, water);	
@@ -2564,7 +2457,7 @@
 
 void AAIExecute::CheckDefences()
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES || ai-&gt;futureUnits[STATIONARY_DEF] +  ai-&gt;requestedUnits[STATIONARY_DEF] &gt; 2)
+	if(ut-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES || ai-&gt;futureUnits[STATIONARY_DEF] +  ai-&gt;requestedUnits[STATIONARY_DEF] &gt; 2)
 		return;
 
 	int t = brain-&gt;GetGamePeriod();
@@ -2591,10 +2484,10 @@
 					{
 						// anti air defences may be built anywhere
 						if(cfg-&gt;AIR_ONLY_MOD || *cat == AIR_ASSAULT)
-							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.5f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );
+							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.25f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );
 						// dont build anti ground/hover/sea defences in interior sectors
 						else if(!(*sector)-&gt;interior)
-							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.5f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );		
+							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.25f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );		
 						else
 							rating = 0;
 								
@@ -2625,7 +2518,7 @@
 
 		if(status == BUILDORDER_NOBUILDER)
 		{
-			float temp = 0.05f + 1.5f / ( (float) first-&gt;defences.size() + 0.5f); 
+			float temp = 0.03f + 1.0f / ( (float) first-&gt;defences.size() + 0.5f); 
 
 			if(urgency[STATIONARY_DEF] &lt; temp)
 				urgency[STATIONARY_DEF] = temp;
@@ -2649,6 +2542,7 @@
 
 	// determine how much metal/energy is needed based on net surplus
 	float temp = GetMetalUrgency();
+
 	if(urgency[EXTRACTOR] &lt; temp) // &amp;&amp; urgency[EXTRACTOR] &gt; 0.05) 
 		urgency[EXTRACTOR] = temp;
 
@@ -2658,7 +2552,7 @@
 
 	// build storages if needed
 	if(ai-&gt;activeUnits[STORAGE] + ai-&gt;requestedUnits[STORAGE] + ai-&gt;futureUnits[STORAGE] &lt; cfg-&gt;MAX_STORAGE 
-		&amp;&amp; ai-&gt;activeFactories &gt;= cfg-&gt;MIN_FACTORIES_FOR_STORAGE)
+		&amp;&amp; ut-&gt;activeFactories &gt;= cfg-&gt;MIN_FACTORIES_FOR_STORAGE)
 	{
 		float temp = max(GetMetalStorageUrgency(), GetEnergyStorageUrgency());
 		
@@ -2999,7 +2893,7 @@
 			// at least one requested factory has not been built yet
 			float urgency;
 
-			if(ai-&gt;activeFactories &gt; 0)
+			if(ut-&gt;activeFactories &gt; 0)
 				urgency = 0.4f;
 			else
 				urgency = 3.0f;
@@ -3014,7 +2908,7 @@
 
 void AAIExecute::CheckRecon()
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_RADAR_JAMMER
+	if(ut-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_RADAR_JAMMER
 		|| ai-&gt;activeUnits[STATIONARY_RECON] &gt;= brain-&gt;sectors[0].size())
 		return;
 
@@ -3034,7 +2928,7 @@
 
 void AAIExecute::CheckJammer()
 {
-	if(ai-&gt;activeFactories &lt; 2 || ai-&gt;activeUnits[STATIONARY_JAMMER] &gt; brain-&gt;sectors[0].size())
+	if(ut-&gt;activeFactories &lt; 2 || ai-&gt;activeUnits[STATIONARY_JAMMER] &gt; brain-&gt;sectors[0].size())
 	{
 		this-&gt;urgency[STATIONARY_JAMMER] = 0;
 	}
@@ -3129,8 +3023,8 @@
 	{
 		urgency[i] *= 1.035f;
 		
-		if(urgency[i] &gt; 18.0f)
-			urgency[i] -= 2.0f;
+		if(urgency[i] &gt; 20.0f)
+			urgency[i] -= 1.0f;
 	}
 }
 
@@ -3163,20 +3057,20 @@
 
 bool AAIExecute::least_dangerous(AAISector *left, AAISector *right)
 {
-	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;mapType == AIR_MAP)
+	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;map_type == AIR_MAP)
 		return (left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) &lt; right-&gt;GetThreatBy(AIR_ASSAULT, learned, current));  
 	else
 	{
-		if(left-&gt;map-&gt;mapType == LAND_MAP)
+		if(left-&gt;map-&gt;map_type == LAND_MAP)
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)));  
 	
-		else if(left-&gt;map-&gt;mapType == LAND_WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == LAND_WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)));  
 		}
-		else if(left-&gt;map-&gt;mapType == WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)) 
 					&lt; (right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)));  
@@ -3186,20 +3080,20 @@
 
 bool AAIExecute::suitable_for_power_plant(AAISector *left, AAISector *right)
 {
-	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;mapType == AIR_MAP)
+	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;map_type == AIR_MAP)
 		return (left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) * left-&gt;GetMapBorderDist()  &lt; right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) * right-&gt;GetMapBorderDist());  
 	else
 	{
-		if(left-&gt;map-&gt;mapType == LAND_MAP)
+		if(left-&gt;map-&gt;map_type == LAND_MAP)
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * left-&gt;GetMapBorderDist() ) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * right-&gt;GetMapBorderDist()));  
 	
-		else if(left-&gt;map-&gt;mapType == LAND_WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == LAND_WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * left-&gt;GetMapBorderDist() ) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * right-&gt;GetMapBorderDist()));  
 		}
-		else if(left-&gt;map-&gt;mapType == WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * left-&gt;GetMapBorderDist()) 
 					&lt; (right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * right-&gt;GetMapBorderDist()));  
@@ -3360,7 +3254,7 @@
 			value = 4;
 		}
 
-		--ai-&gt;futureFactories;
+		--ut-&gt;futureFactories;
 
 		for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 			bt-&gt;units_dynamic[*unit].constructorsRequested -= 1;
@@ -3426,27 +3320,32 @@
 	}
 }
 
-
-AAIGroup* AAIExecute::GetClosestGroupOfCategory(UnitCategory category, UnitType type, float3 pos, int importance)
+AAIGroup* AAIExecute::GetClosestGroupForDefence(UnitType group_type, float3 *pos, int continent, int importance)
 {
 	AAIGroup *best_group = 0;
 	float best_rating = 0, my_rating;
 	float3 group_pos; 
 
-	for(list&lt;AAIGroup*&gt;::iterator group = ai-&gt;group_list[category].begin(); group != ai-&gt;group_list[category].end(); ++group)
+	for(list&lt;UnitCategory&gt;::iterator category = bt-&gt;assault_categories.begin(); category != bt-&gt;assault_categories.end(); ++category)
 	{
-		if((*group)-&gt;group_unit_type == type &amp;&amp; !(*group)-&gt;attack)
+		for(list&lt;AAIGroup*&gt;::iterator group = ai-&gt;group_list[*category].begin(); group != ai-&gt;group_list[*category].end(); ++group)
 		{
-			if((*group)-&gt;task == GROUP_IDLE || (*group)-&gt;task_importance &lt; importance)
+			if((*group)-&gt;group_unit_type == group_type &amp;&amp; !(*group)-&gt;attack)
 			{
-				group_pos = (*group)-&gt;GetGroupPos();
+				if((*group)-&gt;continent == -1 || (*group)-&gt;continent == continent)
+				{
+					if((*group)-&gt;task == GROUP_IDLE) // || (*group)-&gt;task_importance &lt; importance)
+					{
+						group_pos = (*group)-&gt;GetGroupPos();
 
-				my_rating = (*group)-&gt;avg_speed / sqrt(1 +  pow(pos.x - group_pos.x, 2.0f) + pow(pos.z - group_pos.z, 2.0f) );
+						my_rating = (*group)-&gt;avg_speed / ( 1.0 + fastmath::sqrt((pos-&gt;x - group_pos.x) * (pos-&gt;x - group_pos.x)  + (pos-&gt;z - group_pos.z) * (pos-&gt;z - group_pos.z) ));
 
-				if(my_rating &gt; best_rating)
-				{
-					best_group = *group;
-					best_rating = my_rating;
+						if(my_rating &gt; best_rating)
+						{
+							best_group = *group;
+							best_rating = my_rating;
+						}
+					}
 				}
 			}
 		}
@@ -3455,157 +3354,24 @@
 	return best_group;
 }
 
-void AAIExecute::DefendUnitVS(int unit, const UnitDef *def, UnitCategory category, float3 *enemy_pos, int importance)
+void AAIExecute::DefendUnitVS(int unit, unsigned int enemy_movement_type, float3 *enemy_pos, int importance)
 {
-	if(unit &lt; 0)
-		return;
-
-	float3 pos = cb-&gt;GetUnitPos(unit);
-
-	AAISector *sector = map-&gt;GetSectorOfPos(&amp;pos);
-
-	// unit/building located in invalid sector
-	if(!sector)
-		return;
-
 	AAIGroup *support = 0;
-
-	// anti air mods have special behaviour
-	if(cfg-&gt;AIR_ONLY_MOD)
-	{
-		support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-		if(!support)
-			support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-		if(!support)
-			support = GetClosestGroupOfCategory(GROUND_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-		if(support)
-			support-&gt;Defend(unit, enemy_pos, importance);
-	}
-	// normal mods
-	else  
-	{
-		bool land, water;
-
-		if(sector-&gt;water_ratio &gt; 0.6)
-		{
-			land = false;
-			water = true;
-		}
-		else
-		{
-			land = true;
-			water = false;
-		}
-
-		// find possible defenders depending on category of attacker
-
-		// anti air 
-		if(category == AIR_ASSAULT)
-		{
-			// try to call fighters first
-			support = GetClosestGroupOfCategory(AIR_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-				
-			// no fighters available
-			if(!support)
-			{	
-				// try to get ground or hover aa support
-				if(land)
-				{
-					support = GetClosestGroupOfCategory(GROUND_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-
-					if(!support)
-						support = GetClosestGroupOfCategory(HOVER_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-				}
-
-				// try to get sea or hover aa support
-				if(water)
-				{
-					support = GetClosestGroupOfCategory(SEA_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-
-					if(!support)
-						support = GetClosestGroupOfCategory(HOVER_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-				}
-			}
-
-			if(support)
-			{
-				// dont defend units too far away from own base
-				if(sector-&gt;distance_to_base &gt; 3 &amp;&amp; support-&gt;category != AIR_ASSAULT)
-					return;
 	
-				support-&gt;Defend(unit, NULL, importance);
-			}
-		}
-		// ground unit attacked
-		else if(land)
-		{
-			if(category == GROUND_ASSAULT || category == HOVER_ASSAULT || category == GROUND_ARTY || category == HOVER_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
+	int continent = map-&gt;GetContinentID(enemy_pos);
 
-				if(!support)
-					support = GetClosestGroupOfCategory(GROUND_ASSAULT, ASSAULT_UNIT, pos, 100);
+	UnitType group_type;
 
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-			else if(category == SEA_ASSAULT || category == SEA_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
+	// anti air needed
+	if(enemy_movement_type &amp; MOVE_TYPE_AIR &amp;&amp; !cfg-&gt;AIR_ONLY_MOD)
+		group_type = ANTI_AIR_UNIT;
+	else
+		group_type = ASSAULT_UNIT;
 
-				if(!support)
-					support = GetClosestGroupOfCategory(SEA_ASSAULT, ASSAULT_UNIT, pos, 100);
+	support = GetClosestGroupForDefence(group_type, enemy_pos, continent, 100);
 
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-
-			if(support)
-			{
-				// dont defend units too far away from own base
-				if(sector-&gt;distance_to_base &gt; 3 &amp;&amp; support-&gt;category != AIR_ASSAULT)
-					return;
-
-				support-&gt;Defend(unit, enemy_pos, importance);
-			}
-		}
-		// water unit attacked
-		else if(water)
-		{
-			if(category == GROUND_ASSAULT || category == GROUND_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(GROUND_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-			else if(category == SEA_ASSAULT || category == HOVER_ASSAULT || category == SEA_ARTY || category == HOVER_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(SEA_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-
-			if(support)
-			{
-				// dont defend units too far away from own base
-				if(sector-&gt;distance_to_base &gt; 3 &amp;&amp; support-&gt;category != AIR_ASSAULT)
-					return;
-
-				support-&gt;Defend(unit, enemy_pos, importance);
-			}
-		}	
-	}
+	if(support)
+		support-&gt;Defend(unit, enemy_pos, importance);
 }
 
 float3 AAIExecute::GetSafePos(int def_id, float3 unit_pos)
@@ -3790,4 +3556,4 @@
 	//	fprintf(ai-&gt;file, &quot;%i th order has been given by %s in frame %i\n&quot;, issued_orders, owner,  cb-&gt;GetCurrentFrame());
 
 	cb-&gt;GiveOrder(unit, c);
-}
+}
\ No newline at end of file

Modified: trunk/AI/Global/AAI/AAIExecute.h
===================================================================
--- trunk/AI/Global/AAI/AAIExecute.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIExecute.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -28,7 +28,7 @@
 	void InitAI(int commander_unit_id, const UnitDef *commander_def);
 
 	// return true if building will be placed at a valid pos = inside sectors
-	bool InitBuildingAt(const UnitDef *def, float3 pos);
+	bool InitBuildingAt(const UnitDef *def, float3 pos, bool water);
 
 	void ConstructBuildingAt(int building, int builder, float3 position); 
 
@@ -110,7 +110,7 @@
 	BuildOrderStatus BuildStationaryDefenceVS(UnitCategory category, AAISector *dest);
 
 	// tries to call support vs air (returns true if succesful)
-	void DefendUnitVS(int unit, const UnitDef *def, UnitCategory category, float3 *enemy_pos, int importance);
+	void DefendUnitVS(int unit, unsigned int enemy_movement_type, float3 *enemy_pos, int importance);
 
 	// returns true if succesfully assisting construction
 	bool AssistConstructionOfCategory(UnitCategory category, int importance = 5);
@@ -127,18 +127,15 @@
 	// returns the the total air defence power of all units
 	float GetTotalAirPower();
 	
-	// chooses a stzarting sector close to specified sector
+	// chooses a starting sector close to specified sector
 	void ChooseDifferentStartingSector(int x, int y);
 
-	// 
-	AAIGroup* GetClosestGroupOfCategory(UnitCategory category, UnitType type, float3 pos, int importance); 
+	// returns closest (taking into account movement speed) group with units of specified unit type that may reach the location 
+	AAIGroup* GetClosestGroupForDefence(UnitType group_type, float3 *pos, int continent, int importance);
 
 	float3 GetRallyPoint(unsigned int unit_movement_type, int continent_id, int min_dist, int max_dist);
 	float3 GetRallyPointCloseTo(UnitCategory category, unsigned int unit_movement_type, int continent_id, float3 pos, int min_dist, int max_dist);
 
-	AAIMetalSpot* FindMetalSpotClosestToBuilder(int land_mex, int water_mex);
-	AAIMetalSpot* FindMetalSpot(bool land, bool water);
-
 	float3 GetBuildsite(int builder, int building, UnitCategory category);
 	float3 GetUnitBuildsite(int builder, int unit);
 

Modified: trunk/AI/Global/AAI/AAIGroup.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIGroup.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIGroup.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -14,7 +14,6 @@
 
 AAIGroup::AAIGroup(AAI *ai, const UnitDef *def, UnitType unit_type, int continent_id)
 {
-	
 	this-&gt;ai = ai;
 	cb = ai-&gt;cb;
 	bt = ai-&gt;bt;
@@ -165,7 +164,7 @@
 bool AAIGroup::RemoveUnit(int unit, int attacker)
 {
 	// look for unit with that id
-	for(list&lt;int2&gt;::iterator i = units.begin(); i != units.end(); i++)
+	for(list&lt;int2&gt;::iterator i = units.begin(); i != units.end(); ++i)
 	{
 		if(i-&gt;x == unit)
 		{
@@ -210,11 +209,13 @@
 						ai-&gt;af-&gt;CheckTarget(attacker, def);
 					else if(category == AIR_ASSAULT)
 					{
+						float3 enemy_pos = cb-&gt;GetUnitPos(attacker);
+
 						// get a random unit of the group
 						int unit = GetRandomUnit();
 
 						if(unit)
-							ai-&gt;execute-&gt;DefendUnitVS(unit, cb-&gt;GetUnitDef(unit), category, NULL, 110);
+							ai-&gt;execute-&gt;DefendUnitVS(unit, bt-&gt;units_static[def-&gt;id].movement_type, &amp;enemy_pos, 100);
 					}
 				}
 			}

Modified: trunk/AI/Global/AAI/AAIMap.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIMap.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIMap.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -14,29 +14,33 @@
 
 // all the static vars
 int AAIMap::aai_instances = 0;
+char AAIMap::map_filename[500];
 int AAIMap::xSize;
-int AAIMap::ySize;
+int AAIMap::ySize;	
 int AAIMap::xMapSize;
-int AAIMap::yMapSize;
+int AAIMap::yMapSize;				
 int AAIMap::xDefMapSize;
 int AAIMap::yDefMapSize;
 int AAIMap::xContMapSize;
-int AAIMap::yContMapSize;
+int AAIMap::yContMapSize;	
 int AAIMap::xSectors;
-int AAIMap::ySectors;
+int AAIMap::ySectors;				
 int AAIMap::xSectorSize; 
-int AAIMap::ySectorSize;
+int AAIMap::ySectorSize;		
 int AAIMap::xSectorSizeMap; 
 int AAIMap::ySectorSizeMap;
 
 list&lt;AAIMetalSpot&gt;  AAIMap::metal_spots;
 
+int AAIMap::land_metal_spots;
+int AAIMap::water_metal_spots;
+
 bool AAIMap::metalMap;
-MapType AAIMap::mapType;
+MapType AAIMap::map_type;	
 
 vector&lt; vector&lt;int&gt; &gt; AAIMap::team_sector_map;
-vector&lt;int&gt; AAIMap::buildmap;
-vector&lt;int&gt; AAIMap::blockmap;
+vector&lt;int&gt; AAIMap::buildmap;	
+vector&lt;int&gt; AAIMap::blockmap;	
 vector&lt;float&gt; AAIMap::plateau_map;
 vector&lt;int&gt; AAIMap::continent_map;	
 
@@ -45,7 +49,12 @@
 int AAIMap::water_continents;
 int AAIMap::avg_land_continent_size;
 int AAIMap::avg_water_continent_size;
+int AAIMap::max_land_continent_size;
+int AAIMap::max_water_continent_size;
+int AAIMap::min_land_continent_size;
+int AAIMap::min_water_continent_size;
 
+
 list&lt;UnitCategory&gt; AAIMap::map_categories;
 list&lt;int&gt; AAIMap::map_categories_id;
 vector&lt;vector&lt;float&gt; &gt; AAIMap::map_usefulness;
@@ -82,23 +91,12 @@
 		Learn();
 
 		// save map data
-		char filename[500];
-		char buffer[500];
-		strcpy(buffer, MAIN_PATH);
-		strcat(buffer, MAP_LEARN_PATH);
-		strcat(buffer, cb-&gt;GetMapName());
-		ReplaceExtension(buffer, filename, sizeof(filename), &quot;_&quot;);
-		strcat(filename, cb-&gt;GetModName());
-		ReplaceExtension(filename, buffer, sizeof(filename), &quot;.dat&quot;);
+		FILE *save_file = fopen(map_filename, &quot;w+&quot;);
 
-		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
-	
-		FILE *save_file = fopen(buffer, &quot;w+&quot;);
-
 		fprintf(save_file, &quot;%s \n&quot;,MAP_FILE_VERSION);
 
 		// save map type
-		fprintf(save_file, &quot;%s \n&quot;, GetMapTypeString(mapType));
+		fprintf(save_file, &quot;%s \n&quot;, GetMapTypeString(map_type));
 
 		// save units map_usefulness
 		float sum;
@@ -106,13 +104,13 @@
 		for(int i = 0; i &lt; cfg-&gt;SIDES; ++i)
 		{
 			// rebalance map_usefulness
-			if(mapType == LAND_MAP)
+			if(map_type == LAND_MAP)
 			{
 				sum = map_usefulness[0][i] + map_usefulness[2][i];
 				map_usefulness[0][i] *= (100.0/sum);
 				map_usefulness[2][i] *= (100.0/sum);
 			}
-			else if(mapType == LAND_WATER_MAP)
+			else if(map_type == LAND_WATER_MAP)
 			{
 				sum = map_usefulness[0][i] + map_usefulness[2][i] + map_usefulness[3][i] + map_usefulness[4][i];
 				map_usefulness[0][i] *= (100.0/sum);
@@ -120,7 +118,7 @@
 				map_usefulness[3][i] *= (100.0/sum);
 				map_usefulness[4][i] *= (100.0/sum);
 			}
-			else if(mapType == WATER_MAP)
+			else if(map_type == WATER_MAP)
 			{
 				sum = map_usefulness[2][i] + map_usefulness[3][i] + map_usefulness[4][i];
 				map_usefulness[2][i] *= (100.0/sum);
@@ -202,9 +200,9 @@
 		for(int x = 0; x &lt; xSectors; ++x)
 			team_sector_map[x].resize(ySectors, -1);
 
-		ReadCacheFile();
+		ReadContinentFile();
 
-		ReadContinentFile();
+		ReadMapCacheFile();
 	}
 
 	// create field of sectors
@@ -245,12 +243,13 @@
 
 	// for log file
 	fprintf(ai-&gt;file, &quot;Map: %s\n&quot;,cb-&gt;GetMapName());
+	fprintf(ai-&gt;file, &quot;Maptype: %s\n&quot;, GetMapTypeTextString(map_type));
 	fprintf(ai-&gt;file, &quot;Mapsize is %i x %i\n&quot;, cb-&gt;GetMapWidth(),cb-&gt;GetMapHeight());
 	fprintf(ai-&gt;file, &quot;%i sectors in x direction\n&quot;, xSectors);
 	fprintf(ai-&gt;file, &quot;%i sectors in y direction\n&quot;, ySectors);
 	fprintf(ai-&gt;file, &quot;x-sectorsize is %i (Map %i)\n&quot;, xSectorSize, xSectorSizeMap);
 	fprintf(ai-&gt;file, &quot;y-sectorsize is %i (Map %i)\n&quot;, ySectorSize, ySectorSizeMap);
-	fprintf(ai-&gt;file, &quot;%i metal spots found \n \n&quot;,metal_spots.size());
+	fprintf(ai-&gt;file, &quot;%i metal spots found (%i are on land, %i under water) \n \n&quot;,metal_spots.size(), land_metal_spots, water_metal_spots);
 	fprintf(ai-&gt;file, &quot;%i continents found on map\n&quot;, continents.size());
 	fprintf(ai-&gt;file, &quot;%i land and %i water continents\n&quot;, land_continents, water_continents);
 	fprintf(ai-&gt;file, &quot;Average land continent size is %i\n&quot;, avg_land_continent_size);
@@ -273,31 +272,30 @@
 	}*/
 }
 
-void AAIMap::ReadCacheFile()
+void AAIMap::ReadMapCacheFile()
 {
 	// try to read cache file
 	bool loaded = false;
 	
-	char filename[500];
 	char buffer[500];
 	strcpy(buffer, MAIN_PATH);
 	strcat(buffer, MAP_CACHE_PATH);
 	strcat(buffer, cb-&gt;GetMapName());
-	ReplaceExtension(buffer, filename, sizeof(filename), &quot;.dat&quot;);
+	ReplaceExtension(buffer, map_filename, sizeof(map_filename), &quot;.dat&quot;);
 
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename);
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, map_filename);
 
 	FILE *file;
 
-	if(file = fopen(filename, &quot;r&quot;))
+	if(file = fopen(map_filename, &quot;r&quot;))
 	{
 		// check if correct version
 		fscanf(file, &quot;%s &quot;, buffer);
 
-		if(strcmp(buffer, MAP_DATA_VERSION))
+		if(strcmp(buffer, MAP_CACHE_VERSION))
 		{
 			cb-&gt;SendTextMsg(&quot;Mapcache out of date - creating new one&quot;, 0);
-			fprintf(ai-&gt;file, &quot;Map cache-file out of date - new one has been created\n&quot;);
+			fprintf(ai-&gt;file, &quot;Map cache file out of date - new one has been created\n&quot;);
 			fclose(file);
 		}
 		else
@@ -336,6 +334,8 @@
 				metal_spots.push_back(spot);
 			}
 
+			fscanf(file, &quot;%i %i &quot;, &amp;land_metal_spots, &amp;water_metal_spots); 
+
 			fclose(file);
 
 			fprintf(ai-&gt;file, &quot;Map cache file succesfully loaded\n&quot;);
@@ -357,13 +357,13 @@
 		strcpy(buffer, MAIN_PATH);
 		strcat(buffer, MAP_CACHE_PATH);
 		strcat(buffer, cb-&gt;GetMapName());
-		ReplaceExtension(buffer, filename, sizeof(filename), &quot;.dat&quot;);
+		ReplaceExtension(buffer, map_filename, sizeof(map_filename), &quot;.dat&quot;);
 
-		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
+		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, map_filename);
 
-		file = fopen(filename, &quot;w+&quot;);
+		file = fopen(map_filename, &quot;w+&quot;);
 
-		fprintf(file, &quot;%s\n&quot;, MAP_DATA_VERSION);
+		fprintf(file, &quot;%s\n&quot;, MAP_CACHE_VERSION);
 
 		// save if its a metal map
 		fprintf(file, &quot;%i\n&quot;, (int)metalMap);
@@ -379,11 +379,23 @@
 			fprintf(file, &quot;%f &quot;, plateau_map[i]); 
 
 		// save mex spots
+		land_metal_spots = 0;
+		water_metal_spots = 0;
+
 		fprintf(file, &quot;\n%i \n&quot;, metal_spots.size());
 
-		for(list&lt;AAIMetalSpot&gt;::iterator spot = metal_spots.begin(); spot != metal_spots.end(); spot++)
+		for(list&lt;AAIMetalSpot&gt;::iterator spot = metal_spots.begin(); spot != metal_spots.end(); ++spot)
+		{
 			fprintf(file, &quot;%f %f %f %f \n&quot;, spot-&gt;pos.x, spot-&gt;pos.y, spot-&gt;pos.z, spot-&gt;amount);
 
+			if(spot-&gt;pos.y &gt;= 0)
+				++land_metal_spots;
+			else
+				++water_metal_spots;
+		}
+
+		fprintf(file, &quot;%i %i\n&quot;, land_metal_spots, water_metal_spots);
+
 		fclose(file);
 
 		fprintf(ai-&gt;file, &quot;New map cache-file created\n&quot;);
@@ -391,6 +403,9 @@
 
 	// determine map type
 	loaded = true;
+
+	char filename[500];
+
 	strcpy(buffer, MAIN_PATH);
 	strcat(buffer, MAP_CFG_PATH);
 	strcat(buffer, cb-&gt;GetMapName());
@@ -404,26 +419,22 @@
 		fscanf(file, &quot;%s &quot;, buffer);
 
 		if(!strcmp(buffer, &quot;LAND_MAP&quot;))
-			mapType = LAND_MAP;
+			map_type = LAND_MAP;
 		else if(!strcmp(buffer, &quot;AIR_MAP&quot;))
-			mapType = AIR_MAP;
+			map_type = AIR_MAP;
 		else if(!strcmp(buffer, &quot;LAND_WATER_MAP&quot;))
-			mapType = LAND_WATER_MAP;
+			map_type = LAND_WATER_MAP;
 		else if(!strcmp(buffer, &quot;WATER_MAP&quot;))
-			mapType = WATER_MAP;
+			map_type = WATER_MAP;
 		else
-			mapType = UNKNOWN_MAP;
+			map_type = UNKNOWN_MAP;
 
-		if(mapType &gt;= 0 &amp;&amp; mapType &lt;= WATER_MAP)
+		if(map_type &gt;= 0 &amp;&amp; map_type &lt;= WATER_MAP)
 		{
-			this-&gt;mapType = (MapType) mapType;
+			this-&gt;map_type = (MapType) map_type;
 
-			// logging
-			sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(mapType));
-			fprintf(ai-&gt;file, &quot;\nLoading map type:\n&quot;);
-			fprintf(ai-&gt;file, buffer);
-			fprintf(ai-&gt;file, &quot;\n\n&quot;);
-
+			sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(map_type));
+	
 			if(bt-&gt;aai_instances == 1)
 				ai-&gt;cb-&gt;SendTextMsg(buffer, 0);
 		}
@@ -450,16 +461,18 @@
 
 		water_ratio = water_ratio / ((float)(xMapSize*yMapSize));
 
-		if(water_ratio &gt; 0.80f)
-			this-&gt;mapType = WATER_MAP;
+
+		//
+		if( (float)max_land_continent_size &lt; 0.5f * (float)max_water_continent_size || water_ratio &gt; 0.80f)
+			this-&gt;map_type = WATER_MAP;
 		else if(water_ratio &gt; 0.25f)
-			this-&gt;mapType = LAND_WATER_MAP;
+			this-&gt;map_type = LAND_WATER_MAP;
 		else
-			this-&gt;mapType = LAND_MAP;
+			this-&gt;map_type = LAND_MAP;
 
 
 		// logging
-		sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(this-&gt;mapType));
+		sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(this-&gt;map_type));
 		ai-&gt;cb-&gt;SendTextMsg(buffer, 0);
 		fprintf(ai-&gt;file, &quot;\nAutodetecting map type:\n&quot;);
 		fprintf(ai-&gt;file, buffer);
@@ -474,7 +487,7 @@
 		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
 
 		file = fopen(filename, &quot;w+&quot;);
-		fprintf(file, &quot;%s\n&quot;, GetMapTypeString(this-&gt;mapType));
+		fprintf(file, &quot;%s\n&quot;, GetMapTypeString(this-&gt;map_type));
 		fclose(file);
 	}
 
@@ -493,7 +506,7 @@
 	}
 	else
 	{
-		if(mapType == LAND_MAP)
+		if(map_type == LAND_MAP)
 		{
 			map_categories.push_back(GROUND_ASSAULT);
 			map_categories.push_back(AIR_ASSAULT);
@@ -503,7 +516,7 @@
 			map_categories_id.push_back(1);
 			map_categories_id.push_back(2);
 		}
-		else if(mapType == LAND_WATER_MAP)
+		else if(map_type == LAND_WATER_MAP)
 		{
 			map_categories.push_back(GROUND_ASSAULT);
 			map_categories.push_back(AIR_ASSAULT);
@@ -517,7 +530,7 @@
 			map_categories_id.push_back(3);
 			map_categories_id.push_back(4);
 		}
-		else if(mapType == WATER_MAP)
+		else if(map_type == WATER_MAP)
 		{
 			map_categories.push_back(AIR_ASSAULT);
 			map_categories.push_back(HOVER_ASSAULT);
@@ -592,7 +605,9 @@
 			}
 
 			// load statistical data
-			fscanf(file, &quot;%i %i %i %i&quot;, &amp;land_continents, &amp;water_continents, &amp;avg_land_continent_size, &amp;avg_water_continent_size);
+			fscanf(file, &quot;%i %i %i %i %i %i %i %i&quot;, &amp;land_continents, &amp;water_continents, &amp;avg_land_continent_size, &amp;avg_water_continent_size, 
+																			&amp;max_land_continent_size, &amp;max_water_continent_size, 
+																			&amp;min_land_continent_size, &amp;min_water_continent_size);
 
 			fclose(file);
 
@@ -639,7 +654,9 @@
 		fprintf(file, &quot;%i %i \n&quot;, continents[c].size, (int)continents[c].water);
 
 	// save statistical data
-	fprintf(file, &quot;%i %i %i %i\n&quot;, land_continents, water_continents, avg_land_continent_size, avg_water_continent_size);
+	fprintf(file, &quot;%i %i %i %i %i %i %i %i\n&quot;, land_continents, water_continents, avg_land_continent_size, avg_water_continent_size, 
+																	max_land_continent_size, max_water_continent_size, 
+																	min_land_continent_size, min_water_continent_size);
 
 	fclose(file);
 }
@@ -681,7 +698,7 @@
 			fscanf(load_file, &quot;%s&quot;, buffer);
 
 			// map type does not match
-			if(strcmp(buffer, GetMapTypeString(mapType)))
+			if(strcmp(buffer, GetMapTypeString(map_type)))
 			{
 				cb-&gt;SendTextMsg(&quot;Map type has changed - creating new map learning file&quot;, 0);
 				fclose(load_file);
@@ -728,7 +745,7 @@
 		for(int i = 0; i &lt; cfg-&gt;SIDES; ++i)
 		{
 			for(int j = 0; j &lt; bt-&gt;assault_categories.size(); ++j)
-				map_usefulness[j][i] = bt-&gt;mod_usefulness[j][i][mapType];
+				map_usefulness[j][i] = bt-&gt;mod_usefulness[j][i][map_type];
 		}
 	}
 
@@ -1239,9 +1256,9 @@
 	// check horizontal space
 	if(xPos+xSize+cfg-&gt;MAX_XROW &lt;= xMapSize &amp;&amp; xPos - cfg-&gt;MAX_XROW &gt;= 0)
 	{
-		for(int y = yPos; y &lt; yPos + ySize; y++)
+		for(int y = yPos; y &lt; yPos + ySize; ++y)
 		{
-			if(y&gt;= yMapSize)
+			if(y &gt;= yMapSize)
 			{
 				fprintf(ai-&gt;file, &quot;ERROR: y = %i index out of range when checking horizontal rows&quot;, y);
 				return;
@@ -1380,10 +1397,6 @@
 
 void AAIMap::BlockCells(int xPos, int yPos, int width, int height, bool block, bool water)
 {
-	// check range
-	if(xPos &lt; 0 || yPos &lt; 0 || xPos+width &gt; xMapSize || yPos + height &gt; yMapSize)
-		return;
-
 	//float3 my_pos;
 	int empty, cell;
 
@@ -1394,59 +1407,58 @@
 
 	if(block)	// block cells
 	{
-		for(int x = xPos; x &lt; xPos + width; x++)
+		for(int x = xPos; x &lt; xPos + width; ++x)
 		{
-			for(int y = yPos; y &lt; yPos + height; y++)
+			for(int y = yPos; y &lt; yPos + height; ++y)
 			{
 				cell = x + xMapSize*y;
 
 				// if no building ordered that cell to be blocked, update buildmap
 				// (only if space is not already occupied by a building)
-				if(!(blockmap[cell]++))
+				if(blockmap[cell] == 0 &amp;&amp; buildmap[cell] == empty)
 				{
-					if(buildmap[cell] == empty)
+					buildmap[cell] = 2;
+
+					// debug
+					/*if(x%2 == 0 &amp;&amp; y%2 == 0)
 					{
-						buildmap[cell] = 2;
+						my_pos.x = x * 8;
+						my_pos.z = y * 8;
+						my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
+						cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
+					}*/
+				}
 
-						/*// debug
-						if(x%2 == 0 &amp;&amp; y%2 == 0)
-						{
-							my_pos.x = x * 8;
-							my_pos.z = y * 8;
-							my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
-							cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
-						}*/
-					}
-				}
+				++blockmap[cell];
 			}
 		}
 	}
 	else		// unblock cells
 	{
-		for(int x = xPos; x &lt; xPos + width; x++)
+		for(int x = xPos; x &lt; xPos + width; ++x)
 		{
-			for(int y = yPos; y &lt; yPos + height; y++)
+			for(int y = yPos; y &lt; yPos + height; ++y)
 			{
 				cell = x + xMapSize*y;
 
-				if(blockmap[cell])
+				if(blockmap[cell] &gt; 0)
 				{
-					// if cell is not blocked anymore, update buildmap
-					if(!(--blockmap[cell]))
+					--blockmap[cell];
+
+					// if cell is not blocked anymore, mark cell on buildmap as empty (only if it has been marked bloked 
+					//					- if it is not marked as blocked its occupied by another building or unpassable)
+					if(blockmap[cell] == 0 &amp;&amp; buildmap[cell] == 2)
 					{
-						if(buildmap[cell] == 2)
+						buildmap[cell] = empty;
+
+						// debug
+						/*if(x%2 == 0 &amp;&amp; y%2 == 0)
 						{
-							buildmap[cell] = empty;
-
-							// debug
-							/*if(x%2 == 0 &amp;&amp; y%2 == 0)
-							{
-								my_pos.x = x * 8;
-								my_pos.z = y * 8;
-								my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
-								cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
-							}*/
-						}
+							my_pos.x = x * 8;
+							my_pos.z = y * 8;
+							my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
+							cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
+						}*/
 					}
 				}
 			}
@@ -1475,9 +1487,9 @@
 	while(buildmap[x+yPos*xMapSize] == value)
 	{
 		if(direction)
-			x++;
+			++x;
 		else
-			x--;
+			--x;
 
 		// search went out of map
 		if(x &lt; 0 || x &gt;= xMapSize)
@@ -1494,9 +1506,9 @@
 	while(buildmap[xPos+y*xMapSize] == value)
 	{
 		if(direction)
-			y++;
+			++y;
 		else
-			y--;
+			--y;
 
 		// search went out of map
 		if(y &lt; 0 || y &gt;= yMapSize)
@@ -1792,7 +1804,6 @@
 						y = ((*cell) - x) / xContMapSize;
 
 						// check edges
-						
 						if(x &gt; 0 &amp;&amp; continent_map[y * xContMapSize + x - 1] &lt; 0)
 						{
 							if(height_map[4 * (y * xMapSize + x - 1)] &lt; 0)
@@ -1860,8 +1871,13 @@
 	// calculate some statistical data
 	land_continents = 0;
 	water_continents = 0;
+
 	avg_land_continent_size = 0;
 	avg_water_continent_size = 0;
+	max_land_continent_size = 0;
+	max_water_continent_size = 0;
+	min_land_continent_size = xContMapSize * yContMapSize;
+	min_water_continent_size = xContMapSize * yContMapSize;
 
 	for(int i = 0; i &lt; continents.size(); ++i)
 	{
@@ -1869,11 +1885,23 @@
 		{
 			++water_continents;
 			avg_water_continent_size += continents[i].size;
+
+			if(continents[i].size &gt; max_water_continent_size)
+				max_water_continent_size = continents[i].size;
+
+			if(continents[i].size &lt; min_water_continent_size)
+				min_water_continent_size = continents[i].size;
 		}
 		else
 		{
 			++land_continents;
 			avg_land_continent_size += continents[i].size;
+
+			if(continents[i].size &gt; max_land_continent_size)
+				max_land_continent_size = continents[i].size;
+
+			if(continents[i].size &lt; min_land_continent_size)
+				min_land_continent_size = continents[i].size;
 		}
 	}
 
@@ -1884,8 +1912,7 @@
 		avg_land_continent_size /= land_continents;
 }
 
-// algorithm more or less by krogothe
-// thx very much
+// algorithm more or less by krogothe - thx very much
 void AAIMap::SearchMetalSpots()
 {
 	const UnitDef* def = bt-&gt;unitList[bt-&gt;GetBiggestMex()-1];
@@ -2060,26 +2087,13 @@
 		fprintf(ai-&gt;file, &quot;Map is considered to be a metal map\n&quot;,0);
 	}
 	else
-	{
 		metalMap = false;
 
-		// debug
-		/*for(list&lt;AAIMetalSpot&gt;::iterator spot = metal_spots.begin(); spot != metal_spots.end(); spot++)
-		{
-			cb-&gt;DrawUnit(&quot;ARMMEX&quot;, spot-&gt;pos, 0.0f, 200000, cb-&gt;GetMyAllyTeam(), false, true);
-		}*/
-	}
-
-
 	delete [] MexArrayA;
 	delete [] MexArrayB;
 	delete [] TempAverage;
 }
 
-void AAIMap::GetMapData()
-{
-}
-
 void AAIMap::UpdateRecon()
 {
 	const UnitDef *def;
@@ -2257,47 +2271,47 @@
 
 	if(killer &lt; 5)
 	{
-		bt-&gt;mod_usefulness[killer][killer_type-&gt;side-1][mapType] += change;
+		bt-&gt;mod_usefulness[killer][killer_type-&gt;side-1][map_type] += change;
 		map_usefulness[killer][killer_type-&gt;side-1] += change;
 	}
 
 	if(killed &lt; 5)
 	{
 		map_usefulness[killed][killed_type-&gt;side-1] -= change;
-		bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][mapType] -= change;
+		bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][map_type] -= change;
 
 		if(map_usefulness[killed][killed_type-&gt;side-1] &lt; 1)
 			map_usefulness[killed][killed_type-&gt;side-1] = 1;
 
-		if(bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][mapType] &lt; 1)
-			bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][mapType] = 1;
+		if(bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][map_type] &lt; 1)
+			bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][map_type] = 1;
 	}
 }
 
 
-const char* AAIMap::GetMapTypeString(int mapType)
+const char* AAIMap::GetMapTypeString(int map_type)
 {
-	if(mapType == 1)
+	if(map_type == 1)
 		return &quot;LAND_MAP&quot;;
-	else if(mapType == 2)
+	else if(map_type == 2)
 		return &quot;AIR_MAP&quot;;
-	else if(mapType == 3)
+	else if(map_type == 3)
 		return &quot;LAND_WATER_MAP&quot;;
-	else if(mapType == 4)
+	else if(map_type == 4)
 		return &quot;WATER_MAP&quot;;
 	else
 		return &quot;UNKNOWN_MAP&quot;;
 }
 
-const char* AAIMap::GetMapTypeTextString(int mapType)
+const char* AAIMap::GetMapTypeTextString(int map_type)
 {
-	if(mapType == 1)
+	if(map_type == 1)
 		return &quot;land map&quot;;
-	else if(mapType == 2)
+	else if(map_type == 2)
 		return &quot;air map&quot;;
-	else if(mapType == 3)
+	else if(map_type == 3)
 		return &quot;land-water map&quot;;
-	else if(mapType == 4)
+	else if(map_type == 4)
 		return &quot;water map&quot;;
 	else
 		return &quot;unknown map type&quot;;
@@ -2665,4 +2679,4 @@
 		y = yContMapSize - 1;
 
 	return continent_map[y * xContMapSize + x];
-}
+}
\ No newline at end of file

Modified: trunk/AI/Global/AAI/AAIMap.h
===================================================================
--- trunk/AI/Global/AAI/AAIMap.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIMap.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -26,7 +26,7 @@
 	int GetContinentID(int x, int y);
 	int GetContinentID(float3 *pos);
 
-	// returns continent id with respect to the units movement type (eg land, non amphib unit being in shallow water will return id of nearest land continent)
+	// returns continent id with respect to the units movement type (e.g. land, non amphib unit being in shallow water will return id of nearest land continent)
 	int GetSmartContinentID(float3 *pos, unsigned int unit_movement_type);
 
 	// true if x/y are a valid sector
@@ -52,7 +52,7 @@
 	// prevents ai from building too many buildings in a row
 	void CheckRows(int xPos, int yPos, int xSize, int ySize, bool add, bool water);
 
-	// adds or removes blocked cells (to prevent aai from packing buildings too close to each other)
+	// blocks/unblocks cells (to prevent AAI from packing buildings too close to each other)
 	void BlockCells(int xPos, int yPos, int width, int height, bool block, bool water);
 
 	// returns number of cells with big slope
@@ -67,8 +67,8 @@
 	// increases/decreases usefulness of the category of the killer/killed unit 
 	void UpdateCategoryUsefulness(const UnitDef *killer_def, int killer, const UnitDef *killed_def, int killed);
 
-	const char* GetMapTypeTextString(int mapType);
-	const char* GetMapTypeString(int mapType);
+	const char* GetMapTypeTextString(int map_type);
+	const char* GetMapTypeString(int map_type);
 
 	// return next cell in direction with a certain value
 	int GetNextX(int direction, int xPos, int yPos, int value);	// 0 means left, other right; returns -1 if not found 
@@ -78,7 +78,8 @@
 	bool CanBuildAt(int xPos, int yPos, int xSize, int ySize, bool water = false);
 
 	// reads map cache file (and creates new one if necessary)
-	void ReadCacheFile();
+	// loads mex spots, cliffs etc. from file or creates new one
+	void ReadMapCacheFile();
 
 	// reads continent cache file (and creates new one if necessary)
 	void ReadContinentFile();
@@ -86,15 +87,13 @@
 	// if auto_set == true, the loaded values are assigned to the current sectordata as well 
 	void ReadMapLearnFile(bool auto_set);
 
-	// loads mex spots, cliffs etc. from file or creates new one
-	void GetMapData();
-
 	// calculates learning effect
 	void Learn();
 
-	// get water, high slopes, defence map
+	// determines water, high slopes, defence map
 	void AnalyseMap();
 
+	// calculates which parts of the are connected
 	void CalculateContinentMaps();
 
 	// adds/removes a defence buidling to the defence map (air == true -&gt; add to air defence map)
@@ -130,6 +129,7 @@
 public:
 
 	static int aai_instances;	// how many aai instances have been initialized
+	static char map_filename[500];
 
 	static int xSize, ySize;					// x and y size of the map (unit coordinates)
 	static int xMapSize, yMapSize;				// x and y size of the map (map coordinates)
@@ -141,10 +141,13 @@
 
 	static list&lt;AAIMetalSpot&gt; metal_spots;
 
+	static int land_metal_spots;
+	static int water_metal_spots;
+
 	static bool metalMap;
-	static MapType mapType;	// 0 -&gt; unknown ,1-&gt; land map (default), 2 -&gt; air map, 
-							// 3 -&gt; water map with land connections 
-							// 4 -&gt; &quot;full water map
+	static MapType map_type;	// 0 -&gt; unknown ,1-&gt; land map (default), 2 -&gt; air map, 
+								// 3 -&gt; water map with land connections 
+								// 4 -&gt; &quot;full water map
 
 	static vector&lt; vector&lt;int&gt; &gt; team_sector_map;	// stores the number of ai player which has taken that sector (-1 if none)
 											// this helps preventing aai from expanding into sectors of other aai players
@@ -170,8 +173,13 @@
 	static vector&lt;AAIContinent&gt; continents;
 	static int land_continents;
 	static int water_continents;
+	
 	static int avg_land_continent_size;
 	static int avg_water_continent_size;
+	static int max_land_continent_size;
+	static int max_water_continent_size;
+	static int min_land_continent_size;
+	static int min_water_continent_size;
 
 	static list&lt;UnitCategory&gt; map_categories;
 	static list&lt;int&gt; map_categories_id;

Modified: trunk/AI/Global/AAI/AAISector.cpp
===================================================================
--- trunk/AI/Global/AAI/AAISector.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAISector.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -16,9 +16,9 @@
 }
 
 AAISector::~AAISector(void)
-{
+{	
 	defences.clear();
-
+	
 	attacked_by_this_game.clear(); 
 	attacked_by_learned.clear(); 
 
@@ -52,14 +52,14 @@
 	distance_to_base = -1;
 	last_scout = 1;
 	rally_points = 0;
-
+	
 	// nothing sighted in that sector
 	enemy_structures = 0;
 	own_structures = 0;
 	allied_structures = 0;
 	threat = 0;
 	failed_defences = 0;
-
+	
 	int categories = ai-&gt;bt-&gt;assault_categories.size();
 
 	combats_learned.resize(categories, 0);
@@ -498,7 +498,7 @@
 
 float AAISector::GetThreatByID(int combat_cat_id, float learned, float current)
 {
-	return 1.0f + (learned * attacked_by_learned[combat_cat_id] + current * attacked_by_this_game[combat_cat_id] ) / (learned + current);
+	return 0.25f + (learned * attacked_by_learned[combat_cat_id] + current * attacked_by_this_game[combat_cat_id] ) / (learned + current);
 }
 
 float AAISector::GetThreatTo(float ground, float air, float hover, float sea, float submarine)
@@ -770,4 +770,4 @@
 	}
 
 	*pos = ZeroVector;
-}
+}
\ No newline at end of file

Modified: trunk/AI/Global/AAI/AAIUnitTable.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIUnitTable.cpp	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIUnitTable.cpp	2008-10-26 19:44:14 UTC (rev 6907)
@@ -18,7 +18,6 @@
 	this-&gt;bt = bt;
 	this-&gt;cb = ai-&gt;cb;
 
-//	units = new AAIUnit[cfg-&gt;MAX_UNITS];
 	units.resize(cfg-&gt;MAX_UNITS);
 
 	// fill buildtable 
@@ -31,6 +30,10 @@
 		units[i].status = UNIT_KILLED;
 	}
 
+	activeScouts = futureScouts = 0;
+	activeBuilders = futureBuilders = 0;
+	activeFactories = futureFactories = 0;
+
 	cmdr = -1;
 }
 
@@ -129,14 +132,14 @@
 
 	if(builder)
 	{
-		--ai-&gt;futureBuilders;
-		++ai-&gt;activeBuilders;
+		--futureBuilders;
+		++activeBuilders;
 	}
 
 	if(factory &amp;&amp; bt-&gt;IsStatic(def_id))
 	{
-		--ai-&gt;futureFactories;
-		++ai-&gt;activeFactories;
+		--futureFactories;
+		++activeFactories;
 
 		// remove future ressource demand now factory has been finished
 		ai-&gt;execute-&gt;futureRequestedMetal -= bt-&gt;units_static[def_id].efficiency[0];
@@ -147,10 +150,10 @@
 void AAIUnitTable::RemoveConstructor(int unit_id, int def_id)
 {
 	if(units[unit_id].cons-&gt;builder)
-		ai-&gt;activeBuilders -= 1;
+		activeBuilders -= 1;
 
 	if(units[unit_id].cons-&gt;factory &amp;&amp; bt-&gt;IsStatic(def_id))
-		ai-&gt;activeFactories -= 1;
+		activeFactories -= 1;
 	
 	// decrease number of available builders for all buildoptions of the builder
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)		
@@ -224,10 +227,24 @@
 
 void AAIUnitTable::RemoveExtractor(int unit_id)
 {
-	// delete mex from list
 	extractors.erase(unit_id);
 }
 
+void AAIUnitTable::AddScout(int unit_id)
+{
+	++activeScouts;
+	--futureScouts;
+
+	scouts.insert(unit_id);
+}
+
+void AAIUnitTable::RemoveScout(int unit_id)
+{
+	--activeScouts;
+
+	scouts.erase(unit_id);
+}
+
 void AAIUnitTable::AddPowerPlant(int unit_id, int def_id)
 {
 	power_plants.insert(unit_id);
@@ -320,14 +337,15 @@
 	return 0;
 }
 
-AAIConstructor* AAIUnitTable::FindClosestBuilder(int building, float3 pos, bool commander)
+AAIConstructor* AAIUnitTable::FindClosestBuilder(int building, float3 *pos, bool commander, float *min_dist)
 {	
-	float min_dist = 1000000, my_dist;
+	float my_dist;
 	AAIConstructor *best_builder = 0, *builder;
 	float3 builder_pos;
 	bool suitable;
 
-	int continent = ai-&gt;map-&gt;GetContinentID(&amp;pos);
+	int continent = ai-&gt;map-&gt;GetContinentID(pos);
+	*min_dist = 100000.0f;
 
 	// look for idle builder
 	for(set&lt;int&gt;::iterator i = constructors.begin(); i != constructors.end(); ++i)
@@ -356,15 +374,15 @@
 				// filter out commander
 				if(suitable &amp;&amp; ( commander || !bt-&gt;IsCommander(builder-&gt;def_id) ) )
 				{
-					my_dist = fastmath::sqrt( (builder_pos.x - pos.x) * (builder_pos.x - pos.x) + (builder_pos.z - pos.z) * (builder_pos.z - pos.z) );
+					my_dist = fastmath::sqrt( (builder_pos.x - pos-&gt;x) * (builder_pos.x - pos-&gt;x) + (builder_pos.z - pos-&gt;z) * (builder_pos.z - pos-&gt;z) );
 					
 					if(bt-&gt;unitList[builder-&gt;def_id-1]-&gt;speed &gt; 0)
 						my_dist /= bt-&gt;unitList[builder-&gt;def_id-1]-&gt;speed;
 
-					if(my_dist &lt; min_dist)
+					if(my_dist &lt; *min_dist)
 					{
 						best_builder = builder;
-						min_dist = my_dist;
+						*min_dist = my_dist;
 					}
 				}
 			}

Modified: trunk/AI/Global/AAI/AAIUnitTable.h
===================================================================
--- trunk/AI/Global/AAI/AAIUnitTable.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/AAIUnitTable.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -17,6 +17,9 @@
 
 	bool AddUnit(int unit_id, int def_id, AAIGroup *group = 0, AAIConstructor *cons = 0);
 	void RemoveUnit(int unit_id);
+	
+	void AddScout(int unit_id);
+	void RemoveScout(int unit_id);
 
 	void AddConstructor(int unit_id, int def_id);
 	void RemoveConstructor(int unit_id, int def_id);
@@ -43,7 +46,10 @@
 	void RemoveStationaryArty(int unit_id);
 
 	AAIConstructor* FindBuilder(int building, bool commander);
-	AAIConstructor* FindClosestBuilder(int building, float3 pos, bool commander);
+
+	// finds closest builder and stores its distance to pos in min_dist
+	AAIConstructor* FindClosestBuilder(int building, float3 *pos, bool commander, float *min_dist);
+
 	AAIConstructor* FindClosestAssistant(float3 pos, int importance, bool commander);
 
 	void EnemyKilled(int unit);
@@ -62,12 +68,18 @@
 	AAIBuildTable *bt;
 	IAICallback* cb;
 
+	// units[i].unitId = -1 -&gt; not used , -2 -&gt; enemy unit
 	vector&lt;AAIUnit&gt; units;
-	// units[i].unitId = -1 -&gt; not used , -2 -&gt; enemy unit
 
+	// number of active/under construction units of all different types
+	int activeScouts, futureScouts;
+	int activeBuilders, futureBuilders;
+	int activeFactories, futureFactories;
+
 	// commanders id
 	int cmdr;
-
+		
+	set&lt;int&gt; scouts;
 	set&lt;int&gt; constructors;
 	set&lt;int&gt; metal_makers;
 	set&lt;int&gt; jammers; 

Modified: trunk/AI/Global/AAI/aidef.h
===================================================================
--- trunk/AI/Global/AAI/aidef.h	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/AI/Global/AAI/aidef.h	2008-10-26 19:44:14 UTC (rev 6907)
@@ -18,10 +18,10 @@
 #include &quot;ExternalAI/IGlobalAICallback.h&quot;
 #include &quot;ExternalAI/IAICallback.h&quot;
 #include &quot;ExternalAI/aibase.h&quot;
-#include &quot;System/Vec2.h&quot;
-#include &quot;Game/GlobalConstants.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+#include &quot;System/vec2.h&quot;
+#include &quot;Game/GlobalConstants.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandQueue.h&quot;
@@ -38,11 +38,11 @@
 #ifndef AIDEF_H
 #define AIDEF_H
 
-#define AAI_VERSION &quot;0.872&quot;
+#define AAI_VERSION &quot;0.875&quot;
 #define MAP_FILE_VERSION &quot;MAP_LEARN_0_80&quot;
 #define TABLE_FILE_VERSION &quot;MOD_LEARN_0_87&quot;
-#define MAP_DATA_VERSION &quot;MAP_DATA_0_86&quot;
-#define CONTINENT_DATA_VERSION &quot;MOVEMENT_MAPS_0_86&quot;
+#define MAP_CACHE_VERSION &quot;MAP_DATA_0_87&quot;
+#define CONTINENT_DATA_VERSION &quot;MOVEMENT_MAPS_0_87&quot;
 
 // all paths 
 #define MAIN_PATH &quot;AI/AAI/&quot;

Modified: trunk/game/AI/AAI/AAI ReadMe.txt
===================================================================
--- trunk/game/AI/AAI/AAI ReadMe.txt	2008-10-26 16:30:14 UTC (rev 6906)
+++ trunk/game/AI/AAI/AAI ReadMe.txt	2008-10-26 19:44:14 UTC (rev 6907)
@@ -106,7 +106,19 @@
 		- Brandon Potter for his TBT 12 cfg file
 
 
+AAI v0.875	- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order 
+		  water factories on a land map anymore)
 
+		- Improved AAIs behaviour on water maps with start positions on islands/land masses
+
+		- Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, 
+		  works better if there are land and sea spots available at the same time)
+
+		- Continent file version bumped to 0.87
+
+		- Fixed a crash on shut down introduced in Spring v0.77
+
+
 AAI v0.872	- Refactored code for getting rally points and positions to withdraw units and made 
 
 		- Construction units that are member of the DONT_BUILD list will not be built anymore
@@ -126,11 +138,11 @@
 		- Added some new variables to mod config file:
 
 		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
-		  
+
 		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
-		 
+
 		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
-	
+
   		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
 
 		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001675.html">[Taspring-linux-commit] r6906 - in trunk/rts/Sim: MoveTypes Units
</A></li>
	<LI>Next message: <A HREF="001677.html">[Taspring-linux-commit] r6908 -	trunk/installer/builddata/springcontent
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1676">[ date ]</a>
              <a href="thread.html#1676">[ thread ]</a>
              <a href="subject.html#1676">[ subject ]</a>
              <a href="author.html#1676">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
