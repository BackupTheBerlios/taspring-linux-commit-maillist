<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7188 - in branches/caiinterface: . AI	AI/Interfaces/C AI/Interfaces/Java AI/Skirmish/AAI	AI/Skirmish/KAIK AI/Skirmish/NTai/AI/NTai/Core AI/Skirmish/RAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7188%20-%20in%20branches/caiinterface%3A%20.%20AI%0A%09AI/Interfaces/C%20AI/Interfaces/Java%20AI/Skirmish/AAI%0A%09AI/Skirmish/KAIK%20AI/Skirmish/NTai/AI/NTai/Core%20AI/Skirmish/RAI&In-Reply-To=%3C20081217113215.DC33B47BA%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001956.html">
   <LINK REL="Next"  HREF="001958.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7188 - in branches/caiinterface: . AI	AI/Interfaces/C AI/Interfaces/Java AI/Skirmish/AAI	AI/Skirmish/KAIK AI/Skirmish/NTai/AI/NTai/Core AI/Skirmish/RAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7188%20-%20in%20branches/caiinterface%3A%20.%20AI%0A%09AI/Interfaces/C%20AI/Interfaces/Java%20AI/Skirmish/AAI%0A%09AI/Skirmish/KAIK%20AI/Skirmish/NTai/AI/NTai/Core%20AI/Skirmish/RAI&In-Reply-To=%3C20081217113215.DC33B47BA%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7188 - in branches/caiinterface: . AI	AI/Interfaces/C AI/Interfaces/Java AI/Skirmish/AAI	AI/Skirmish/KAIK AI/Skirmish/NTai/AI/NTai/Core AI/Skirmish/RAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Dec 17 12:32:15 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001956.html">[Taspring-linux-commit] r7187 - trunk/rts/Sim/Units/COB
</A></li>
        <LI>Next message: <A HREF="001958.html">[Taspring-linux-commit] r7189 - in branches/caiinterface:	Documentation rts/ExternalAI rts/Game rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/Units/COB rts/System	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/build/vstudio8 rts/lib/gml	tools/unitsync
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1957">[ date ]</a>
              <a href="thread.html#1957">[ thread ]</a>
              <a href="subject.html#1957">[ subject ]</a>
              <a href="author.html#1957">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-17 12:32:14 +0100 (Wed, 17 Dec 2008)
New Revision: 7188

Added:
   branches/caiinterface/AI/Interfaces/Java/Util.c
   branches/caiinterface/AI/Interfaces/Java/Util.h
Removed:
   branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c
   branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.h
Modified:
   branches/caiinterface/AI/CMakeLists.txt
   branches/caiinterface/AI/Interfaces/C/Interface.cpp
   branches/caiinterface/AI/Interfaces/C/Interface.h
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
   branches/caiinterface/AI/Interfaces/C/Log.cpp
   branches/caiinterface/AI/Interfaces/C/Log.h
   branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h
   branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
   branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
   branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
   branches/caiinterface/AI/Interfaces/Java/Log.c
   branches/caiinterface/AI/Skirmish/AAI/AIExport.cpp
   branches/caiinterface/AI/Skirmish/AAI/AIExport.h
   branches/caiinterface/AI/Skirmish/AAI/Interface.cpp
   branches/caiinterface/AI/Skirmish/AAI/aidef.h
   branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp
   branches/caiinterface/AI/Skirmish/KAIK/AIExport.h
   branches/caiinterface/AI/Skirmish/KAIK/Defines.h
   branches/caiinterface/AI/Skirmish/KAIK/GlobalAI.cpp
   branches/caiinterface/AI/Skirmish/KAIK/UnitTable.cpp
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.cpp
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.h
   branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp
   branches/caiinterface/AI/Skirmish/RAI/AIExport.h
   branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp
   branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp
   branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp
   branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp
   branches/caiinterface/AI/Skirmish/RAI/LogFile.h
   branches/caiinterface/AI/Skirmish/RAI/RAI.cpp
   branches/caiinterface/CMakeLists.txt
   branches/caiinterface/SConstruct
Log:
* NTai is compiled agian with SCons under Linux (still not when compiling under windows, but always with CMake)
* AI Interfaces and SKirmish AIs written in C now receive the same defines as the ones written in C++ (-&gt; fixes no debug symbols with C AI Interface bug)
* all AI Interfaces and Skirmish AIs on SVN now have easy access to the info and option values they receive from the engine through simple C functions in (Interface|AI)Export.h, so they can for example fetch their data-dir location
* AAI, RAI and KAIK now use their new location for log-, cache- and config-files (NTai not, because the code looked too difficult to me: will have to do it together with AF once)

Modified: branches/caiinterface/AI/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/CMakeLists.txt	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/CMakeLists.txt	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,29 +1,37 @@
-include_directories(${CMAKE_SOURCE_DIR}/rts ${CMAKE_SOURCE_DIR}/rts/ExternalAI ${CMAKE_SOURCE_DIR}/AI/Wrappers ${CMAKE_SOURCE_DIR}/rts/System ${SDL_INCLUDE_DIR})
-
-remove_definitions(-DSTREFLOP_SSE) # would break AI compiling
-add_definitions(${PIC_FLAG} -D_REENTRANT -D_GNU_SOURCE=1)
-aux_source_directory(${CMAKE_SOURCE_DIR}/rts/System/creg creg)
-#list (APPEND creg ${CMAKE_SOURCE_DIR}/rts/System/float3)
-
-aux_source_directory(${CMAKE_SOURCE_DIR}/rts/ExternalAI/Interface aienv)
-list (APPEND aienv ${CMAKE_SOURCE_DIR}/rts/Game/GameVersion)
-
-list (APPEND errorhandler ${CMAKE_SOURCE_DIR}/rts/System/Platform/errorhandler)
-if (UNIX AND NOT MINGW)
-	list (APPEND errorhandler ${CMAKE_SOURCE_DIR}/rts/System/Platform/Linux/X_MessageBox)
-endif (UNIX AND NOT MINGW)
-
-#aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Lua/LuaParser luaparsingenv)
-#aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Map/MapParser luaparsingenv)
-
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Wrappers/LegacyCpp legacycppaienv)
-list (APPEND legacycppaienv ${aienv})
-list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/float3)
-list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/Sim/Misc/DamageArray)
-#list (APPEND legacycppaienv ${errorhandler})
-#list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/LogOutput)
-
-
-Add_Subdirectory(Interfaces)
-Add_Subdirectory(Skirmish)
-#Add_Subdirectory(Group)
+include_directories(${CMAKE_SOURCE_DIR}/rts ${CMAKE_SOURCE_DIR}/rts/ExternalAI ${CMAKE_SOURCE_DIR}/AI/Wrappers ${CMAKE_SOURCE_DIR}/rts/System ${SDL_INCLUDE_DIR})
+
+# set these for C Interfaces and AIs
+SET(CMAKE_C_FLAGS_DEBUG          &quot;${CMAKE_CXX_FLAGS_DEBUG}&quot;)
+SET(CMAKE_C_FLAGS_DEBUG2         &quot;${CMAKE_CXX_FLAGS_DEBUG2}&quot;)
+SET(CMAKE_C_FLAGS_DEBUG3         &quot;${CMAKE_CXX_FLAGS_DEBUG3}&quot;)
+SET(CMAKE_C_FLAGS_RELEASE        &quot;${CMAKE_CXX_FLAGS_RELEASE}&quot;)
+SET(CMAKE_C_FLAGS_RELWITHDEBINFO &quot;${CMAKE_CXX_FLAGS_RELWITHDEBINFO}&quot;)
+SET(CMAKE_C_FLAGS_PROFILE        &quot;${CMAKE_CXX_FLAGS_PROFILE}&quot;)
+
+remove_definitions(-DSTREFLOP_SSE) # would break AI compiling
+add_definitions(${PIC_FLAG} -D_REENTRANT -D_GNU_SOURCE=1)
+aux_source_directory(${CMAKE_SOURCE_DIR}/rts/System/creg creg)
+#list (APPEND creg ${CMAKE_SOURCE_DIR}/rts/System/float3)
+
+aux_source_directory(${CMAKE_SOURCE_DIR}/rts/ExternalAI/Interface aienv)
+list (APPEND aienv ${CMAKE_SOURCE_DIR}/rts/Game/GameVersion)
+
+list (APPEND errorhandler ${CMAKE_SOURCE_DIR}/rts/System/Platform/errorhandler)
+if (UNIX AND NOT MINGW)
+	list (APPEND errorhandler ${CMAKE_SOURCE_DIR}/rts/System/Platform/Linux/X_MessageBox)
+endif (UNIX AND NOT MINGW)
+
+#aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Lua/LuaParser luaparsingenv)
+#aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Map/MapParser luaparsingenv)
+
+aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Wrappers/LegacyCpp legacycppaienv)
+list (APPEND legacycppaienv ${aienv})
+list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/float3)
+list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/Sim/Misc/DamageArray)
+#list (APPEND legacycppaienv ${errorhandler})
+#list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/LogOutput)
+
+
+Add_Subdirectory(Interfaces)
+Add_Subdirectory(Skirmish)
+#Add_Subdirectory(Group)

Modified: branches/caiinterface/AI/Interfaces/C/Interface.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -26,6 +26,7 @@
 
 #include &quot;System/Platform/SharedLib.h&quot;
 #include &quot;System/Util.h&quot;
+#include &quot;Util.h&quot;
 
 #include &lt;sys/stat.h&gt;	// used for check if a file exists
 #ifdef	WIN32
@@ -35,12 +36,12 @@
 #include &lt;sys/types.h&gt;	// mkdir()
 #endif	// WIN32
 
-#define MY_SHORT_NAME &quot;C&quot;
-#define MY_VERSION &quot;0.1&quot;
-#define MY_NAME &quot;C &amp; C++ AI Interface&quot;
+//#define MY_SHORT_NAME &quot;C&quot;
+//#define MY_VERSION &quot;0.1&quot;
+//#define MY_NAME &quot;C &amp; C++ AI Interface&quot;
+//
+//#define MAX_INFOS 128
 
-#define MAX_INFOS 128
-
 static std::string local_getValueByKey(
 		const std::map&lt;std::string, std::string&gt;&amp; map, std::string key) {
 
@@ -60,32 +61,35 @@
 		springDataDirs.push_back(staticGlobalData-&gt;dataDirs[i]);
 	}
 
-	// example: &quot;AI/Interfaces/C&quot;
-	std::string myDataDirRelative =
-			std::string(AI_INTERFACES_DATA_DIR) + PS + MY_SHORT_NAME;
-	// example: &quot;AI/Interfaces/C/0.1&quot;
-	std::string myDataDirVersRelative = myDataDirRelative + PS + MY_VERSION;
+	// &quot;C:/Games/spring/AI/Interfaces/C/0.1&quot;
+	myDataDirVersioned = util_getDataDirVersioned();
+	if (!FileExists(myDataDirVersioned)) {
+		MakeDirRecursive(myDataDirVersioned);
+	}
 
 	// &quot;C:/Games/spring/AI/Interfaces/C&quot;
-	myDataDir = FindDir(myDataDirRelative, true, true);
-	if (!FileExists(myDataDir)) {
-		MakeDirRecursive(myDataDir);
+	myDataDirUnversioned = util_getDataDirUnversioned();
+	if (!FileExists(myDataDirUnversioned)) {
+		MakeDirRecursive(myDataDirUnversioned);
 	}
-	// &quot;C:/Games/spring/AI/Interfaces/C/0.1&quot;
-	myDataDirVers = FindDir(myDataDirVersRelative, true, true);
-	if (!FileExists(myDataDirVers)) {
-		MakeDirRecursive(myDataDirVers);
-	}
 
-	std::string logFileName = myDataDirVers + PS + &quot;log.txt&quot;;
-	simpleLog_init(logFileName.c_str(), true);
+	std::string logFileName = myDataDirVersioned + PS + &quot;log.txt&quot;;
+	bool timeStamps = true;
+	bool fineLogging = false;
+#if defined DEBUG
+	fineLogging = true;
+#endif // defined DEBUG
+	simpleLog_init(logFileName.c_str(), timeStamps, fineLogging);
 
-	simpleLog_log(&quot;This is the log-file of the %s version %s&quot;, MY_NAME,
-			MY_VERSION);
+	const char* myShortName = util_getMyInfo(AI_INTERFACE_PROPERTY_SHORT_NAME);
+	const char* myVersion = util_getMyInfo(AI_INTERFACE_PROPERTY_VERSION);
+
+	simpleLog_log(&quot;This is the log-file of the %s version %s&quot;, myShortName,
+			myVersion);
+	simpleLog_log(&quot;Using data-directory (version specific): %s&quot;,
+			myDataDirVersioned.c_str());
 	simpleLog_log(&quot;Using data-directory (version-less): %s&quot;,
-			myDataDir.c_str());
-	simpleLog_log(&quot;Using data-directory (version specific): %s&quot;,
-			myDataDirVers.c_str());
+			myDataDirUnversioned.c_str());
 	simpleLog_log(&quot;Using log file: %s&quot;, logFileName.c_str());
 }
 

Modified: branches/caiinterface/AI/Interfaces/C/Interface.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/C/Interface.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -97,15 +97,18 @@
 
 	std::vector&lt;std::string&gt; springDataDirs;
 	/**
-	 * All accompanying data for this interface that is not version specifc
+	 * All accompanying data for this interface that is version specifc
 	 * should go in here.
+	 * If you are not sure whether to use this or the unversioned one, use this.
 	 */
-	std::string myDataDir;
+	std::string myDataDirVersioned;
 	/**
-	 * All accompanying data for this interface that is version specifc
+	 * All accompanying data for this interface that is not version specifc
 	 * should go in here.
+	 * If you are not sure whether to use this or the versioned one,
+	 * use the versioned one.
 	 */
-	std::string myDataDirVers;
+	std::string myDataDirUnversioned;
 
 	std::set&lt;SSkirmishAISpecifier, SSkirmishAISpecifier_Comparator&gt; mySkirmishAISpecifiers;
 	typedef std::map&lt;const SSkirmishAISpecifier, std::map&lt;std::string, std::string&gt;, SSkirmishAISpecifier_Comparator&gt; T_skirmishAIInfos;

Modified: branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -18,6 +18,7 @@
 #include &quot;InterfaceExport.h&quot;
 
 #include &quot;Interface.h&quot;
+#include &quot;Util.h&quot;
 
 #include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 #include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot;
@@ -38,6 +39,8 @@
 		const char** infoKeys, const char** infoValues,
 		const SStaticGlobalData* staticGlobalData) {
 
+	util_setMyInfo(infoSize, infoKeys, infoValues);
+
 	std::map&lt;std::string, std::string&gt; infoMap;
 	local_copyToInfoMap(infoMap, infoSize, infoKeys, infoValues);
 	

Modified: branches/caiinterface/AI/Interfaces/C/Log.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Log.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/C/Log.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,110 +1,111 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
- */
-
-#include &quot;Log.h&quot;
-
-#include &lt;stdio.h&gt;	// for file IO
-#include &lt;stdlib.h&gt;	// calloc(), exit()
-#include &lt;string.h&gt;	// strlen(), strcpy()
-#include &lt;time.h&gt;	// for fetching current time
-#include &lt;stdarg.h&gt;	// var-arg support
-#ifdef _MSC_VER
-#if _MSC_VER &gt; 1310
-#define VSNPRINTF _vsnprintf_s
-#else
-#define VSNPRINTF _vsnprintf
-#endif
-#else
-#define VSNPRINTF vsnprintf
-#endif
-
-static const unsigned int bufferSize = 2048;
-
-const char* myLogFileName = NULL;
-bool useTimeStamps = NULL;
-
-void simpleLog_init(const char* _logFileName, bool _useTimeStamps) {
-
-	// NOTE: causeing a memory leack, as it is never freed.
-	// but it is used till the end of the applications runtime anyway
-	// -&gt; no problem
-	char* logFileName = (char*) calloc(strlen(_logFileName) + 1, sizeof (char));
-	strcpy(logFileName, _logFileName);
-	myLogFileName = logFileName;
-
-	useTimeStamps = _useTimeStamps;
-
-	simpleLog_log(&quot;\n\n[logging started]&quot;);
-}
-
-char* simpleLog_createTimeStamp() {
-
-	time_t now;
-	now = time(&amp;now);
-	struct tm* myTime = localtime(&amp;now);
-	unsigned int maxTimeStampSize = 32;
-	char* timeStamp = (char*) calloc(maxTimeStampSize + 1, sizeof (char));
-	strftime(timeStamp, maxTimeStampSize, &quot;%c&quot;, myTime);
-
-	return timeStamp;
-}
-
-void simpleLog_out(const char* msg) {
-
-	if (myLogFileName != NULL) {
-		FILE* file = fopen(myLogFileName, &quot;a&quot;);
-		if (useTimeStamps) {
-			char* timeStamp = simpleLog_createTimeStamp();
-			fprintf(file, &quot;%s: %s\n&quot;, timeStamp, msg);
-			free(timeStamp);
-		} else {
-			fprintf(file, &quot;%s\n&quot;, msg);
-		}
-		fclose(file);
-	} else {
-		// fallback method: write to stdout
-		printf(msg);
-	}
-}
-
-void simpleLog_logv(const char* fmt, va_list argp) {
-	
-	char text[bufferSize];
-
-	VSNPRINTF(text, sizeof(text), fmt, argp);
-	simpleLog_out(text);
-}
-
-void simpleLog_log(const char* fmt, ...) {
-
-	va_list argp;
-
-	va_start(argp, fmt);
-	simpleLog_logv(fmt, argp);
-	va_end(argp);
-}
-
-void simpleLog_error(int error, const char* fmt, ...) {
-
-	va_list argp;
-
-	va_start(argp, fmt);
-	simpleLog_logv(fmt, argp);
-	va_end(argp);
-
-	exit(error);
-}
+#include &quot;../Java/Log.c&quot;
+///*
+//	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+//
+//	This program is free software; you can redistribute it and/or modify
+//	it under the terms of the GNU General Public License as published by
+//	the Free Software Foundation; either version 2 of the License, or
+//	(at your option) any later version.
+//
+//	This program is distributed in the hope that it will be useful,
+//	but WITHOUT ANY WARRANTY; without even the implied warranty of
+//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//	GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+// */
+//
+//#include &quot;Log.h&quot;
+//
+//#include &lt;stdio.h&gt;	// for file IO
+//#include &lt;stdlib.h&gt;	// calloc(), exit()
+//#include &lt;string.h&gt;	// strlen(), strcpy()
+//#include &lt;time.h&gt;	// for fetching current time
+//#include &lt;stdarg.h&gt;	// var-arg support
+//#ifdef _MSC_VER
+//#if _MSC_VER &gt; 1310
+//#define VSNPRINTF _vsnprintf_s
+//#else
+//#define VSNPRINTF _vsnprintf
+//#endif
+//#else
+//#define VSNPRINTF vsnprintf
+//#endif
+//
+//static const unsigned int bufferSize = 2048;
+//
+//const char* myLogFileName = NULL;
+//bool useTimeStamps = NULL;
+//
+//void simpleLog_init(const char* _logFileName, bool _useTimeStamps) {
+//
+//	// NOTE: causeing a memory leack, as it is never freed.
+//	// but it is used till the end of the applications runtime anyway
+//	// -&gt; no problem
+//	char* logFileName = (char*) calloc(strlen(_logFileName) + 1, sizeof (char));
+//	strcpy(logFileName, _logFileName);
+//	myLogFileName = logFileName;
+//
+//	useTimeStamps = _useTimeStamps;
+//
+//	simpleLog_log(&quot;\n\n[logging started]&quot;);
+//}
+//
+//char* simpleLog_createTimeStamp() {
+//
+//	time_t now;
+//	now = time(&amp;now);
+//	struct tm* myTime = localtime(&amp;now);
+//	unsigned int maxTimeStampSize = 32;
+//	char* timeStamp = (char*) calloc(maxTimeStampSize + 1, sizeof (char));
+//	strftime(timeStamp, maxTimeStampSize, &quot;%c&quot;, myTime);
+//
+//	return timeStamp;
+//}
+//
+//void simpleLog_out(const char* msg) {
+//
+//	if (myLogFileName != NULL) {
+//		FILE* file = fopen(myLogFileName, &quot;a&quot;);
+//		if (useTimeStamps) {
+//			char* timeStamp = simpleLog_createTimeStamp();
+//			fprintf(file, &quot;%s: %s\n&quot;, timeStamp, msg);
+//			free(timeStamp);
+//		} else {
+//			fprintf(file, &quot;%s\n&quot;, msg);
+//		}
+//		fclose(file);
+//	} else {
+//		// fallback method: write to stdout
+//		printf(msg);
+//	}
+//}
+//
+//void simpleLog_logv(const char* fmt, va_list argp) {
+//
+//	char text[bufferSize];
+//
+//	VSNPRINTF(text, sizeof(text), fmt, argp);
+//	simpleLog_out(text);
+//}
+//
+//void simpleLog_log(const char* fmt, ...) {
+//
+//	va_list argp;
+//
+//	va_start(argp, fmt);
+//	simpleLog_logv(fmt, argp);
+//	va_end(argp);
+//}
+//
+//void simpleLog_error(int error, const char* fmt, ...) {
+//
+//	va_list argp;
+//
+//	va_start(argp, fmt);
+//	simpleLog_logv(fmt, argp);
+//	va_end(argp);
+//
+//	exit(error);
+//}

Modified: branches/caiinterface/AI/Interfaces/C/Log.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Log.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/C/Log.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,48 +1,49 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _LOG_H
-#define	_LOG_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-
-// used in System/SharedLib.cpp:reportError()
-#define EXTERNAL_LOGGER(msg)	log(msg);
-
-/**
- * Initializes the log.
- */
-void simpleLog_init(const char* logFileName, bool useTimeStamps);
-
-/**
- * Logs a text message. Works like printf(fmt, ...)
- */
-void simpleLog_log(const char* fmt, ...);
-
-/**
- * Logs a text message and exits. Works like printf(fmt, ...)
- */
-void simpleLog_error(int error, const char* msg, ...);
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif	/* _LOG_H */
-
+#include &quot;../Java/Log.h&quot;
+///*
+//	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+//
+//	This program is free software; you can redistribute it and/or modify
+//	it under the terms of the GNU General Public License as published by
+//	the Free Software Foundation; either version 2 of the License, or
+//	(at your option) any later version.
+//
+//	This program is distributed in the hope that it will be useful,
+//	but WITHOUT ANY WARRANTY; without even the implied warranty of
+//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+//	GNU General Public License for more details.
+//
+//	You should have received a copy of the GNU General Public License
+//	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+//*/
+//
+//#ifndef _LOG_H
+//#define	_LOG_H
+//
+//#ifdef	__cplusplus
+//extern &quot;C&quot; {
+//#endif
+//
+//// used in System/SharedLib.cpp:reportError()
+//#define EXTERNAL_LOGGER(msg)	log(msg);
+//
+///**
+// * Initializes the log.
+// */
+//void simpleLog_init(const char* logFileName, bool useTimeStamps);
+//
+///**
+// * Logs a text message. Works like printf(fmt, ...)
+// */
+//void simpleLog_log(const char* fmt, ...);
+//
+///**
+// * Logs a text message and exits. Works like printf(fmt, ...)
+// */
+//void simpleLog_error(int error, const char* msg, ...);
+//
+//#ifdef	__cplusplus
+//}
+//#endif
+//
+//#endif	/* _LOG_H */
+//

Modified: branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -16,26 +16,28 @@
  */
 
 #ifndef _INTERFACEDEFINES_H
-#define	_INTERFACEDEFINES_H
+#define _INTERFACEDEFINES_H
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
 
 #define JAVA_SKIRMISH_AI_PROPERTY_CLASS_NAME &quot;className&quot;
 
-#define MY_SHORT_NAME &quot;Java&quot;
-#define MY_VERSION &quot;0.1&quot;
-#define MY_NAME &quot;Java AI Interface&quot;
+//#define MY_SHORT_NAME &quot;Java&quot;
+//#define MY_VERSION &quot;0.1&quot;
+//#define MY_NAME &quot;Java AI Interface&quot;
 #define MY_LOG_FILE &quot;log.txt&quot;
+#define JAVA_AI_INTERFACE_LIBRARY_FILE_NAME &quot;interface.jar&quot;
+#define JAVA_AI_INTERFACE_JAVA_LIBS_DIR &quot;llib&quot;
+#define JAVA_AI_INTERFACE_NATIVE_LIBS_DIR &quot;lib&quot;
 
 #ifndef NULL
 #define NULL 0
 #endif
 
-#ifdef	__cplusplus
-}
+#ifdef __cplusplus
+} // extern &quot;C&quot;
 #endif
 
-#endif	// _INTERFACEDEFINES_H
-
+#endif // _INTERFACEDEFINES_H

Modified: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c	2008-12-17 11:32:14 UTC (rev 7188)
@@ -18,7 +18,7 @@
 #include &quot;InterfaceExport.h&quot;
 
 #include &quot;InterfaceDefines.h&quot;
-#include &quot;InterfaceUtil.h&quot;
+#include &quot;Util.h&quot;
 #include &quot;JavaBridge.h&quot;
 #include &quot;Log.h&quot;
 
@@ -42,6 +42,11 @@
 	// initialize C part fo the interface
 	staticGlobalData = _staticGlobalData;
 
+	util_setMyInfo(infoSize, infoKeys, infoValues);
+
+	const char* myShortName = util_getMyInfo(AI_INTERFACE_PROPERTY_SHORT_NAME);
+	const char* myVersion = util_getMyInfo(AI_INTERFACE_PROPERTY_VERSION);
+/*
 	// example: &quot;AI/Interfaces/Java&quot;
 	//const char* myDataDirRelative = AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME;
 	char myDataDirRelative[128];
@@ -71,18 +76,24 @@
 	if (!exists) {
 		simpleLog_error(-2, &quot;Failed to create &quot;MY_NAME&quot; versioned data directory.&quot;);
 	}
+*/
 
-	char* logFileName = util_allocStr(strlen(myDataDirVers) + 1 + strlen(MY_LOG_FILE));
+	char* logFileName = util_allocStr(strlen(util_getDataDirVersioned())
+			+ 1 + strlen(MY_LOG_FILE));
 	logFileName[0]= '\0';
-	logFileName = strcat(logFileName, myDataDirVers);
+	logFileName = strcat(logFileName, util_getDataDirVersioned());
 	logFileName = strcat(logFileName, sPS);
 	logFileName = strcat(logFileName, MY_LOG_FILE);
 	simpleLog_init(logFileName, true, true);
-	util_setDataDirs(myDataDir, myDataDirVers);
+/*
+	util_setDataDirs(myDataDirUnversioned, myDataDir);
+*/
 
-	simpleLog_log(&quot;This is the log-file of the %s v%s&quot;, MY_NAME, MY_VERSION);
-	simpleLog_log(&quot;Using data-directory (version-less): %s&quot;, myDataDir);
-	simpleLog_log(&quot;Using data-directory (version specific): %s&quot;, myDataDirVers);
+	simpleLog_log(&quot;This is the log-file of the %s v%s&quot;, myShortName, myVersion);
+	simpleLog_log(&quot;Using data-directory (version specific): %s&quot;,
+			util_getDataDirVersioned());
+	simpleLog_log(&quot;Using data-directory (version-less): %s&quot;,
+			util_getDataDirUnversioned());
 	simpleLog_log(&quot;Using log file: %s&quot;, logFileName);
 	free(logFileName);
 
@@ -135,6 +146,7 @@
 		const char* engineVersionString, int engineVersionNumber,
 		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
 
+	return LOS_Unknown;
 }
 
 int CALLING_CONV proxy_skirmishAI_init(int teamId,

Deleted: branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,440 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;InterfaceUtil.h&quot;
-
-#include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot; // for sPS
-
-#include &lt;string.h&gt;	// strcpy(), str...()
-#include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
-#include &lt;sys/stat.h&gt;	// used for check if a file exists
-#ifdef	WIN32
-#include &lt;io.h&gt;		// needed for dir listing
-#include &lt;direct.h&gt;	// mkdir()
-#else	// WIN32
-#include &lt;sys/stat.h&gt;	// mkdir()
-#include &lt;sys/types.h&gt;	// mkdir()
-#include &lt;dirent.h&gt;		// needed for dir listing
-#endif	// WIN32
-
-static const char* myDataDir = NULL;
-static const char* myDataDirVers = NULL;
-
-void util_setDataDirs(const char* unversioned, const char* versioned) {
-
-	myDataDir = unversioned;
-	myDataDirVers = versioned;
-}
-const char* util_getDataDirUnversioned() {
-	return myDataDir;
-}
-const char* util_getDataDirVersioned() {
-	return myDataDirVers;
-}
-
-char* util_allocStr(unsigned int length) {
-	return (char*) calloc(length+1, sizeof(char));
-}
-
-char* util_allocStrCpy(const char* toCopy) {
-	
-	char* copy = (char*) calloc(strlen(toCopy)+1, sizeof(char));
-	STRCPY(copy, toCopy);
-	return copy;
-}
-
-char* util_allocStrCpyCat(const char* toPart1, const char* toPart2) {
-	
-	char* copy = (char*) calloc(strlen(toPart1)+strlen(toPart2)+1, sizeof(char));
-	STRCPY(copy, toPart1);
-	STRCAT(copy, toPart2);
-	return copy;
-}
-
-void util_strReplace(char* toChange, char toFind, char replacer) {
-	
-	const unsigned int len = strlen(toChange);
-	unsigned int i;
-    for (i = 0; i &lt; len; i++) {
-		if (toChange[i] == toFind) {
-			toChange[i] = replacer;
-		}
-    }
-}
-
-bool util_endsWith(const char* str, const char* suffix) {
-
-	bool endsWith = false;
-	
-	const unsigned int l_str = strlen(str);
-	const unsigned int l_suffix = strlen(suffix);
-
-	if (l_str &gt; l_suffix) {
-		endsWith = true;
-		
-		unsigned int i;
-		for (i = 1; i &lt;= l_suffix; ++i) {
-			if (str[l_str - i] != suffix[l_suffix - i]) {
-				endsWith = false;
-				break;
-			}
-		}
-	}
-
-	return endsWith;
-}
-
-
-#ifdef WIN32
-static bool util_isFile(const struct _finddata_t* fileInfo) {
-	return !(fileInfo-&gt;attrib &amp; _A_SUBDIR)
-			&amp;&amp; fileInfo-&gt;attrib &amp; (_A_NORMAL | _A_HIDDEN | _A_ARCH);
-}
-static bool util_isNormalDir(const struct _finddata_t* fileInfo) {
-	return strcmp(fileInfo-&gt;name, &quot;.&quot;) != 0
-			&amp;&amp; strcmp(fileInfo-&gt;name, &quot;..&quot;) != 0
-			&amp;&amp; (fileInfo-&gt;attrib &amp; _A_SUBDIR);
-}
-static unsigned int util_listFilesRec(const char* dir, const char* suffix,
-		char** fileNames, bool recursive, const unsigned int maxFileNames,
-		unsigned int numFileNames, const char* relPath) {
-
-	if (numFileNames &gt;= maxFileNames) {
-		return numFileNames;
-	}
-
-	struct _finddata_t fileInfo;
-	int handle;
-
-	// look for files which end in: suffix
-	char suffixFilesSpec[strlen(dir) + strlen(&quot;\\*&quot;) + strlen(suffix) + 1];
-	strcpy(suffixFilesSpec, dir);
-	strcat(suffixFilesSpec, &quot;\\*&quot;);
-	strcat(suffixFilesSpec, suffix);
-	handle = _findfirst(suffixFilesSpec, &amp;fileInfo);
-	if (handle != -1L) {
-		if (util_isFile(&amp;fileInfo)) {
-			fileNames[numFileNames++] = util_allocStrCpy(fileInfo.name);
-		}
-		while (_findnext(handle, &amp;fileInfo) == 0
-				&amp;&amp; numFileNames &lt; maxFileNames) {
-			if (util_isFile(&amp;fileInfo)) {
-				char fileRelPath[strlen(relPath) + strlen(fileInfo.name) + 1];
-					strcpy(fileRelPath, relPath);
-					strcat(fileRelPath, fileInfo.name);
-				fileNames[numFileNames++] = util_allocStrCpy(fileRelPath);
-			}
-		}
-		_findclose(handle);
-	}
-
-	// search in sub-directories
-	if (recursive) {
-		char subDirsSpec[strlen(dir) + strlen(&quot;\\*.*&quot;) + 1];
-		strcpy(subDirsSpec, dir);
-		strcat(subDirsSpec, &quot;\\*.*&quot;);
-		handle = _findfirst(subDirsSpec, &amp;fileInfo);
-		if (handle != -1L) {
-			// check if not current or parent directories
-			if (util_isNormalDir(&amp;fileInfo)) {
-				char subDir[strlen(dir) + strlen(&quot;\\&quot;)
-						+ strlen(fileInfo.name) + 1];
-				strcpy(subDir, dir);
-				strcat(subDir, &quot;\\&quot;);
-				strcat(subDir, fileInfo.name);
-				char subRelPath[strlen(relPath) + strlen(fileInfo.name)
-						+ strlen(&quot;\\&quot;) + 1];
-				strcpy(subRelPath, relPath);
-				strcat(subRelPath, fileInfo.name);
-				strcat(subRelPath, &quot;\\&quot;);
-				numFileNames = util_listFilesRec(subDir, suffix, fileNames,
-						recursive, maxFileNames, numFileNames, subRelPath);
-			}
-			while (_findnext(handle, &amp;fileInfo) == 0
-					&amp;&amp; numFileNames &lt; maxFileNames) {
-				if (util_isNormalDir(&amp;fileInfo)) {
-					char subDir[strlen(dir) + strlen(&quot;\\&quot;)
-							+ strlen(fileInfo.name) + 1];
-					strcpy(subDir, dir);
-					strcat(subDir, &quot;\\&quot;);
-					strcat(subDir, fileInfo.name);
-					char subRelPath[strlen(relPath) + strlen(fileInfo.name)
-							+ strlen(&quot;\\&quot;) + 1];
-					strcpy(subRelPath, relPath);
-					strcat(subRelPath, fileInfo.name);
-					strcat(subRelPath, &quot;\\&quot;);
-					numFileNames = util_listFilesRec(subDir, suffix, fileNames,
-							recursive, maxFileNames, numFileNames, subRelPath);
-				}
-			}
-			_findclose(handle);
-		}
-	}
-
-	return numFileNames;
-}
-unsigned int util_listFiles(const char* dir, const char* suffix,
-		char** fileNames, bool recursive, const unsigned int maxFileNames) {
-	return util_listFilesRec(
-			dir, suffix, fileNames, recursive, maxFileNames, 0, &quot;&quot;);
-}
-#else
-
-static const char* fileSelectorSuffix = NULL;
-
-static void util_initFileSelector(const char* suffix) {
-	fileSelectorSuffix = suffix;
-}
-static int util_fileSelector(const struct dirent* fileDesc) {
-	return util_endsWith(fileDesc-&gt;d_name, fileSelectorSuffix);
-}
-
-static unsigned int util_listFilesU(const char* dir, struct dirent*** files) {
-	
-	int foundDirs = scandir(dir, files, util_fileSelector, alphasort);
-	
-	if (foundDirs &lt; 0) { // error, act as if no file found
-		foundDirs = 0;
-	}
-	
-	return (unsigned int) foundDirs;
-}
-
-static unsigned int util_listFilesRec(const char* dir, const char* suffix,
-		char** fileNames, bool recursive, const unsigned int maxFileNames,
-		unsigned int numFiles, const char* relPath) {
-
-	struct dirent** files;
-	util_initFileSelector(suffix);
-	unsigned int currentNumFiles = util_listFilesU(dir, &amp;files);
-	unsigned int f;
-	for (f = 0; f &lt; currentNumFiles &amp;&amp; numFiles &lt; maxFileNames; ++f) {
-		char fileRelPath[strlen(relPath) + strlen(files[f]-&gt;d_name) + 1];
-			strcpy(fileRelPath, relPath);
-			strcat(fileRelPath, files[f]-&gt;d_name);
-		fileNames[numFiles++] = util_allocStrCpy(fileRelPath);
-	}
-/*
-	for (; f &lt; currentNumFiles; ++f) {
-		free(files[f]);
-	}
-*/
-
-	if (recursive) {
-		struct stat dirStat;
-		util_initFileSelector(&quot;&quot;);
-		currentNumFiles = util_listFilesU(dir, &amp;files);
-		for (f = 0; f &lt; currentNumFiles &amp;&amp; numFiles &lt; maxFileNames; ++f) {
-			if (strcmp(files[f]-&gt;d_name, &quot;.&quot;) == 0
-					|| strcmp(files[f]-&gt;d_name, &quot;..&quot;) == 0) {
-				continue;
-			}
-			char subDir[strlen(dir) + strlen(&quot;/&quot;) + strlen(relPath)
-					+ strlen(files[f]-&gt;d_name) + 1];
-			strcpy(subDir, dir);
-			strcat(subDir, &quot;/&quot;);
-			strcat(subDir, relPath);
-			strcat(subDir, files[f]-&gt;d_name);
-			char subRelPath[strlen(relPath) + strlen(files[f]-&gt;d_name)
-					+ strlen(&quot;/&quot;) + 1];
-			strcpy(subRelPath, relPath);
-			strcat(subRelPath, files[f]-&gt;d_name);
-			strcat(subRelPath, &quot;/&quot;);
-			int retStat = stat(subDir, &amp;dirStat);
-			if (retStat == 0 &amp;&amp; S_ISDIR(dirStat.st_mode)) {
-				numFiles = util_listFilesRec(subDir, suffix, fileNames,
-						recursive, maxFileNames, numFiles, subRelPath);
-			}
-		}
-	}
-
-	return numFiles;
-}
-unsigned int util_listFiles(const char* dir, const char* suffix,
-		char** fileNames, bool recursive, const unsigned int maxFileNames) {
-	return util_listFilesRec(
-			dir, suffix, fileNames, recursive, maxFileNames, 0, &quot;&quot;);
-}
-#endif
-
-bool util_fileExists(const char* filePath) {
-	
-	struct stat fileInfo;
-	bool exists;
-	int intStat;
-
-	// Attempt to get the file attributes 
-	intStat = stat(filePath, &amp;fileInfo);
-	if (intStat == 0) {
-		// We were able to get the file attributes 
-		// so the file obviously exists. 
-		exists = true;
-	} else {
-		// We were not able to get the file attributes. 
-		// This may mean that we don't have permission to 
-		// access the folder which contains this file. If you 
-		// need to do that level of checking, lookup the 
-		// return values of stat which will give you 
-		// more details on why stat failed. 
-		exists = false;
-	}
-
-	return exists;
-}
-
-bool util_makeDir(const char* dirPath) {
-	
-	#ifdef	WIN32
-		int mkStat = _mkdir(dirPath);
-		if (mkStat == 0) {
-			return true;
-		} else {
-			return false;
-		}
-	#else	// WIN32
-		// with read/write/search permissions for owner and group,
-		// and with read/search permissions for others
-		int mkStat = mkdir(dirPath, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
-		if (mkStat == 0) {
-			return true;
-		} else {
-			return false;
-		}
-	#endif	// WIN32
-}
-
-bool util_makeDirRecursive(const char* dirPath) {
-	
-	if (!util_fileExists(dirPath)) {
-		char parentDir[strlen(dirPath)+1];
-		bool hasParent = util_getParentDir(dirPath, parentDir);
-		if (hasParent) {
-			bool parentExists = util_makeDirRecursive(parentDir);
-			if (parentExists) {
-				return util_makeDir(dirPath);
-			}
-		}
-		return false;
-	}
-	
-	return true;
-}
-
-bool util_getParentDir(const char* path, char* parentPath) {
-	
-	//size_t pos = strcspn(dirPath, &quot;/\\&quot;);
-	char* ptr = strrchr(path, '/'); // search char from end reverse
-	if (ptr == NULL) {
-		ptr = strrchr(path, '\\'); // search char from end reverse
-		if (ptr == NULL) {
-			return false;
-		}
-	}
-	
-	// copy the parent substring to parentPath
-	unsigned int i;
-    for (i = 0; &amp;(path[i+1]) != ptr; i++) {
-        parentPath[i] = path[i];
-    }
-	parentPath[i] = '\0';
-	
-	return true;
-}
-
-bool util_findFile(const char* dirs[], unsigned int numDirs,
-		const char* relativeFilePath, char* absoluteFilePath) {
-	
-	bool found = false;
-	
-	unsigned int d;
-	for (d=0; d &lt; numDirs &amp;&amp; !found; ++d) {
-		// do the following: tmpPath = dirs[d] + sPS + relativeFilePath
-		char* tmpPath = util_allocStr(strlen(dirs[d]) + 1 + strlen(relativeFilePath));
-		//char tmpPath[strlen(dirs[d]) + 1 + strlen(relativeFilePath) + 1];
-		tmpPath[0]= '\0';
-		tmpPath = strcat(tmpPath, dirs[d]);
-		tmpPath = strcat(tmpPath, sPS);
-		tmpPath = strcat(tmpPath, relativeFilePath);
-		
-		if (util_fileExists(tmpPath)) {
-			STRCPY(absoluteFilePath, tmpPath);
-			found = true;
-		}
-		
-		free(tmpPath);
-	}
-	
-	return found;
-}
-
-bool util_findDir(const char* dirs[], unsigned int numDirs,
-		const char* relativeDirPath, char* absoluteDirPath,
-		bool searchOnlyWriteable, bool create) {
-	
-	bool found = false;
-	
-	if (searchOnlyWriteable &amp;&amp; numDirs &gt; 1) {
-		numDirs = 1;
-	}
-	
-	unsigned int d;
-	for (d=0; d &lt; numDirs &amp;&amp; !found; ++d) {
-		// do the following: tmpPath = dirs[d] + sPS + relativeFilePath
-		char* tmpPath = util_allocStr(strlen(dirs[d]) + 1 + strlen(relativeDirPath));
-		//char tmpPath[strlen(dirs[d]) + 1 + strlen(relativeDirPath) + 1];
-		tmpPath[0]= '\0';
-		tmpPath = strcat(tmpPath, dirs[d]);
-		tmpPath = strcat(tmpPath, sPS);
-		tmpPath = strcat(tmpPath, relativeDirPath);
-		
-		if (util_fileExists(tmpPath)) {
-			STRCPY(absoluteDirPath, tmpPath);
-			found = true;
-		}
-		
-		free(tmpPath);
-	}
-	
-	// not found -&gt; create it
-	if (!found &amp;&amp; create &amp;&amp; numDirs &gt;= 1) {
-		strcat(absoluteDirPath, dirs[0]);
-		strcat(absoluteDirPath, sPS);
-		strcat(absoluteDirPath, relativeDirPath);
-		found = util_makeDir(absoluteDirPath);
-	}
-	
-	return found;
-}
-
-const char* util_map_getValueByKey(
-		unsigned int infoSize,
-		const char** infoKeys, const char** infoValues,
-		const char* key) {
-
-	const char* value = NULL;
-
-	unsigned int i;
-    for (i = 0; i &lt; infoSize; i++) {
-		if (strcmp(infoKeys[i], key) == 0) {
-			value = infoValues[i];
-			break;
-		}
-    }
-
-	return value;
-}
-

Deleted: branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,105 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _INTERFACEUTIL_H
-#define _INTERFACEUTIL_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-
-#include &lt;stdbool.h&gt;	// bool, true, false
-
-#ifdef _MSC_VER
-	// Microsoft Visual C++ 7.1: MSC_VER = 1310
-	// Microsoft Visual C++ 7.0: MSC_VER = 1300
-	#if _MSC_VER &gt; 1310 // &gt;= Visual Studio 2005
-		#define PRINTF printf_s
-		#define FPRINTF fprintf_s
-		#define SNPRINTF sprintf_s
-		#define VSNPRINTF vsprintf_s
-		#define STRCPY strcpy_s
-		#define STRCAT strcat_s
-		#define FOPEN fopen_s
-	#else              // Visual Studio 2003
-		#define PRINTF _printf
-		#define FPRINTF _fprintf
-		#define SNPRINTF _snprintf
-		#define VSNPRINTF _vsnprintf
-		#define STRCPY strcpy
-		#define STRCAT strcat
-		#define FOPEN fopen
-	#endif
-	#define STRCASECMP stricmp
-#else	// _MSC_VER
-	// assuming GCC
-	#define PRINTF printf
-	#define FPRINTF fprintf
-	#define SNPRINTF snprintf
-	#define VSNPRINTF vsnprintf
-	#define STRCPY strcpy
-	#define STRCAT strcat
-	#define FOPEN fopen
-	#define STRCASECMP strcasecmp
-#endif	// _MSC_VER
-
-void util_setDataDirs(const char* unversioned, const char* versioned);
-const char* util_getDataDirUnversioned();
-const char* util_getDataDirVersioned();
-
-char* util_allocStr(unsigned int length);
-
-char* util_allocStrCpy(const char* toCopy);
-
-char* util_allocStrCpyCat(const char* toPart1, const char* toPart2);
-
-void util_strReplace(char* toChange, char toFind, char replacer);
-
-bool util_endsWith(const char* str, const char* suffix);
-
-// suffix example: &quot;.jar&quot;
-unsigned int util_listFiles(const char* dir, const char* suffix,
-		char** fileNames, bool recursive, const unsigned int maxFileNames);
-
-bool util_fileExists(const char* filePath);
-
-bool util_makeDir(const char* dirPath);
-
-bool util_makeDirRecursive(const char* dirPath);
-
-bool util_getParentDir(const char* path, char* parentPath);
-
-bool util_findFile(const char* dirs[], unsigned int numDirs,
-		const char* relativeFilePath, char* absoluteFilePath);
-
-bool util_findDir(const char* dirs[], unsigned int numDirs,
-		const char* relativeDirPath, char* absoluteDirPath,
-		bool searchOnlyWriteable, bool create);
-
-/**
- * Return NULL if the key was not found.
- */
-const char* util_map_getValueByKey(
-		unsigned int infoSize,
-		const char** infoKeys, const char** infoValues,
-		const char* key);
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif // _INTERFACEUTIL_H

Modified: branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/JavaBridge.c	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/JavaBridge.c	2008-12-17 11:32:14 UTC (rev 7188)
@@ -15,13 +15,10 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#include &quot;InterfaceUtil.h&quot;
-
-
 #include &quot;JavaBridge.h&quot;
 
 #include &quot;InterfaceDefines.h&quot;
-#include &quot;InterfaceUtil.h&quot;
+#include &quot;Util.h&quot;
 #include &quot;StreflopBridge.h&quot;
 #include &quot;Log.h&quot;
 
@@ -38,27 +35,10 @@
 #include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
 #include &lt;inttypes.h&gt; // intptr_t -&gt; a signed int with the same size
                       // as a pointer (whether 32bit or 64bit)
-/*
-#ifdef WIN32
-#include &lt;io.h&gt;
-#else
-#include &lt;dirent.h&gt;
-#endif
-#if defined STREFLOP_X87 || defined STREFLOP_SSE
-#include &quot;lib/streflop/streflop_cond.h&quot;
-using namespace streflop;
-#else
-#include &lt;math.h&gt;
-#endif
-*/
-//#include &quot;lib/streflop/streflop.h&quot;
-////#include &quot;lib/streflop/FPUSettings.h&quot;
-//using namespace streflop;
 
 
 
 
-
 static const struct SStaticGlobalData* staticGlobalData = NULL;
 static unsigned int maxTeams = 0;
 static unsigned int maxGroups = 0;
@@ -112,24 +92,27 @@
 	unsigned int j;
 	unsigned int applSkirmishAIs[staticGlobalData-&gt;maxTeams];
 	unsigned int sizeApplSkimrishAIs = 0;
+	const char* myShortName = util_getMyInfo(AI_INTERFACE_PROPERTY_SHORT_NAME);
 	for (i = 0; i &lt; staticGlobalData-&gt;numSkirmishAIs; ++i) {
 		// find the interface shortName
-		const char* intShortName = util_map_getValueByKey(
+		const char* ai_intShortName = util_map_getValueByKey(
 				staticGlobalData-&gt;skirmishAIInfosSizes[i],
 				staticGlobalData-&gt;skirmishAIInfosKeys[i],
 				staticGlobalData-&gt;skirmishAIInfosValues[i],
 				SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME);
+/*
 		const char* shortName_ai = util_map_getValueByKey(
 				staticGlobalData-&gt;skirmishAIInfosSizes[i],
 				staticGlobalData-&gt;skirmishAIInfosKeys[i],
 				staticGlobalData-&gt;skirmishAIInfosValues[i],
 				SKIRMISH_AI_PROPERTY_SHORT_NAME);
-simpleLog_log(&quot;shortName_ai: %s&quot;, shortName_ai);
-simpleLog_log(&quot;intShortName_ai: %s&quot;, intShortName);
+*/
+//simpleLog_log(&quot;shortName_ai: %s&quot;, shortName_ai);
+//simpleLog_log(&quot;intShortName_ai: %s&quot;, intShortName);
 
 		// if the interface shortName was found, check for appliance
-		if (intShortName != NULL &amp;&amp; strcmp(intShortName, MY_SHORT_NAME) == 0) {
-simpleLog_log(&quot;applSkirmishAIs: %i&quot;, i);
+		if (ai_intShortName != NULL &amp;&amp; strcmp(ai_intShortName, myShortName) == 0) {
+//simpleLog_log(&quot;applSkirmishAIs: %i&quot;, i);
 			applSkirmishAIs[sizeApplSkimrishAIs++] = i;
 		}
 	}
@@ -145,14 +128,22 @@
 		//jarFiles[sizeJarFiles++] = AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;interface.jar&quot;;
 		//jarFiles[sizeJarFiles++] = AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;interface.jar&quot;;
 
-		jarFiles[sizeJarFiles] = util_allocStr(128);
-		strcpy(jarFiles[sizeJarFiles], AI_INTERFACES_DATA_DIR);
-		strcat(jarFiles[sizeJarFiles], sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;interface.jar&quot;);
+		jarFiles[sizeJarFiles] =
+				util_allocStr(strlen(util_getDataDirVersioned()) + strlen(sPS)
+						+ strlen(JAVA_AI_INTERFACE_LIBRARY_FILE_NAME));
+		STRCPY(jarFiles[sizeJarFiles], util_getDataDirVersioned());
+		STRCAT(jarFiles[sizeJarFiles], sPS);
+		STRCAT(jarFiles[sizeJarFiles], JAVA_AI_INTERFACE_LIBRARY_FILE_NAME);
+//simpleLog_log(&quot;jarFiles[%i]: %s&quot;, sizeJarFiles, jarFiles[sizeJarFiles]);
 		sizeJarFiles++;
 
-		jarFiles[sizeJarFiles] = util_allocStr(128);
-		strcpy(jarFiles[sizeJarFiles], AI_INTERFACES_DATA_DIR);
-		strcat(jarFiles[sizeJarFiles], sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;interface.jar&quot;);
+		jarFiles[sizeJarFiles] =
+				util_allocStr(strlen(util_getDataDirUnversioned()) + strlen(sPS)
+						+ strlen(JAVA_AI_INTERFACE_LIBRARY_FILE_NAME));
+		STRCPY(jarFiles[sizeJarFiles], util_getDataDirUnversioned());
+		STRCAT(jarFiles[sizeJarFiles], sPS);
+		STRCAT(jarFiles[sizeJarFiles], JAVA_AI_INTERFACE_LIBRARY_FILE_NAME);
+//simpleLog_log(&quot;jarFiles[%i]: %s&quot;, sizeJarFiles, jarFiles[sizeJarFiles]);
 		sizeJarFiles++;
 	}
 	// the file names of the Java AIs used during the current game
@@ -192,10 +183,10 @@
 	// to the classpath directly, so you can keep .class files in there
 	char* jarDirs[MAX_ENTRIES];
 	int unsigned sizeJarDirs = 0;
-	jarDirs[sizeJarDirs++] = util_allocStrCpyCat(AI_INTERFACES_DATA_DIR,
-			sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;jlib&quot;);
-	jarDirs[sizeJarDirs++] = util_allocStrCpyCat(AI_INTERFACES_DATA_DIR,
-			sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;jlib&quot;);
+	jarDirs[sizeJarDirs++] = util_allocStrCpyCat(util_getDataDirVersioned(),
+			sPS&quot;jlib&quot;);
+	jarDirs[sizeJarDirs++] = util_allocStrCpyCat(util_getDataDirUnversioned(),
+			sPS&quot;jlib&quot;);
 	// the jlib dirs of the Java AIs used during the current game
 	for (i = 0; i &lt; sizeApplSkimrishAIs; ++i) {
 		const char* shortName_ai = util_map_getValueByKey(
@@ -226,7 +217,7 @@
 
 
 	// searching the individual jar files and adding everything to the classpath
-	strcat(classPath, &quot;-Djava.class.path=&quot;);
+	STRCAT(classPath, &quot;-Djava.class.path=&quot;);
 /*
 	// add the first jar file
 	if (sizeJarFiles &gt; 0) {
@@ -236,7 +227,7 @@
 					staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
 					jarFiles[0], absoluteFilePath);
 			if (found) {
-				strcat(classPath, absoluteFilePath);
+				STRCAT(classPath, absoluteFilePath);
 			}
 		}
 	}
@@ -249,11 +240,12 @@
 			bool found = util_findFile(
 					staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
 					jarFiles[i], absoluteFilePath);
+//simpleLog_log(&quot;jarFiles[%i]: %i&quot;, i, found);
 			if (found) {
 				if (i &gt; 0) {
-					strcat(classPath, ENTRY_DELIM);
+					STRCAT(classPath, ENTRY_DELIM);
 				}
-				strcat(classPath, absoluteFilePath);
+				STRCAT(classPath, absoluteFilePath);
 			}
 		//}
 	}
@@ -265,8 +257,8 @@
 				jarDirs[i], absoluteDirPath, false, false);
 		free(jarDirs[i]);
 		if (found) {
-			strcat(classPath, ENTRY_DELIM);
-			strcat(classPath, absoluteDirPath);
+			STRCAT(classPath, ENTRY_DELIM);
+			STRCAT(classPath, absoluteDirPath);
 			jarDirs[i] = absoluteDirPath;
 		} else {
 			jarDirs[i] = NULL;
@@ -279,47 +271,14 @@
 			unsigned int sizeJarFileNames = util_listFiles(jarDirs[i], &quot;.jar&quot;,
 					jarFileNames, true, MAX_ENTRIES);
 			for (j = 0; j &lt; sizeJarFileNames; ++j) {
-				strcat(classPath, ENTRY_DELIM);
-				strcat(classPath, jarDirs[i]);
-				strcat(classPath, sPS);
-				strcat(classPath, jarFileNames[j]);
+				STRCAT(classPath, ENTRY_DELIM);
+				STRCAT(classPath, jarDirs[i]);
+				STRCAT(classPath, sPS);
+				STRCAT(classPath, jarFileNames[j]);
 			}
 		}
 	}
 
-
-/*
-	char* libJars[MAX_JARS];
-	char* implJars[MAX_JARS];
-
-	const unsigned int sizeImplDataDirs = java_listJars(IMPL_DIR, implJars, MAX_JARS);
-	const unsigned int sizeLibJars = java_listJars(LIB_DIR, libJars, MAX_JARS);
-	const unsigned int sizeImplJars = java_listJars(IMPL_DIR, implJars, MAX_JARS);
-
-	strcpy(classPath, &quot;-Djava.class.path=&quot;JAI_DIR&quot;/JAI.jar&quot;);
-
-	// add the JAI dir for config files and testing without jars
-	strcat(classPath, ENTRY_DELIM&quot;&quot;JAI_DIR);
-
-	if (numLibJars &gt; 0) {
-		int cnt;
-		for (cnt = 0; cnt &lt; numLibJars; ++cnt) {
-			strcat(classPath, ENTRY_DELIM&quot;&quot;LIB_DIR&quot;&quot;PATH_DELIM);
-			strcat(classPath, libJars[cnt]);
-			free(libJars[cnt]);
-		}
-	}
-
-	if (numImplJars &gt; 0) {
-		int cnt;
-		for (cnt = 0; cnt &lt; numImplJars; ++cnt) {
-			strcat(classPath, ENTRY_DELIM&quot;&quot;IMPL_DIR&quot;&quot;PATH_DELIM);
-			strcat(classPath, implJars[cnt]);
-			free(implJars[cnt]);
-		}
-	}
-*/
-
 	return true;
 }
 
@@ -335,44 +294,34 @@
 	// consists of:
 	// * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/{version}/lib/
 	// * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/lib/
-	char libraryPath1[512];
-	//const char* relLibPath1 =
-	//		AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;lib&quot;;
-	char relLibPath1[128];
-	STRCPY(relLibPath1, AI_INTERFACES_DATA_DIR);
-	STRCAT(relLibPath1, sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;lib&quot;);
-	bool found_libraryPath1 = util_findDir(
-			staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
-			relLibPath1, libraryPath1, false, false);
-/*
-	if (!found_libraryPath1) {
-		simpleLog_error(-1, &quot;!Java library path does not exist: %s&quot;, relLibPath1);
-		return false;
-	}
-*/
-	char libraryPath2[512];
-	//const char* relLibPath2 =
-	//		AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;lib&quot;;
-	char relLibPath2[128];
-	STRCPY(relLibPath2, AI_INTERFACES_DATA_DIR);
-	STRCAT(relLibPath2, sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;lib&quot;);
-	bool found_libraryPath2 = util_findDir(
-			staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
-			relLibPath2, libraryPath2, false, false);
+	char libraryPathPart1[strlen(util_getDataDirVersioned()) + strlen(sPS)
+						+ strlen(JAVA_AI_INTERFACE_NATIVE_LIBS_DIR) + 1];
+	STRCPY(libraryPathPart1, util_getDataDirVersioned());
+	STRCAT(libraryPathPart1, sPS);
+	STRCAT(libraryPathPart1, JAVA_AI_INTERFACE_NATIVE_LIBS_DIR);
+	bool libraryPathPart1_exists = util_fileExists(libraryPathPart1);
+
+	char libraryPathPart2[strlen(util_getDataDirUnversioned()) + strlen(sPS)
+						+ strlen(JAVA_AI_INTERFACE_NATIVE_LIBS_DIR) + 1];
+	STRCPY(libraryPathPart2, util_getDataDirUnversioned());
+	STRCAT(libraryPathPart2, sPS);
+	STRCAT(libraryPathPart2, JAVA_AI_INTERFACE_NATIVE_LIBS_DIR);
+	bool libraryPathPart2_exists = util_fileExists(libraryPathPart2);
+
 	char libraryPath[1024];
-	libraryPath[0] = '\0';
-	strcat(libraryPath, &quot;-Djava.library.path=&quot;);
-// TODO remove the two following lines, but check first.. seems not to be working without
-strcat(libraryPath, &quot;/home/robin/svn_work/robin/Development/Projects/Others/spring_C_AI_interface/game_linux/AI/Interfaces/Java/0.1&quot;);
-strcat(libraryPath, ENTRY_DELIM);
-	if (found_libraryPath1) {
-		strcat(libraryPath, libraryPath1);
+	STRCPY(libraryPath, &quot;-Djava.library.path=&quot;);
+	STRCAT(libraryPath, util_getDataDirVersioned());
+	STRCAT(libraryPath, ENTRY_DELIM);
+	STRCAT(libraryPath, util_getDataDirUnversioned());
+	STRCAT(libraryPath, ENTRY_DELIM);
+	if (libraryPathPart1_exists) {
+		STRCAT(libraryPath, libraryPathPart1);
 	}
-	if (found_libraryPath1 &amp;&amp; found_libraryPath2) {
-		strcat(libraryPath, ENTRY_DELIM);
+	if (libraryPathPart1_exists &amp;&amp; libraryPathPart2_exists) {
+		STRCAT(libraryPath, ENTRY_DELIM);
 	}
-	if (found_libraryPath2) {
-		strcat(libraryPath, libraryPath2);
+	if (libraryPathPart2_exists) {
+		STRCAT(libraryPath, libraryPathPart2);
 	}
 
 	const char* strOptions[32];
@@ -392,28 +341,31 @@
 		//strOptions[op++] = &quot;-XX:+AlwaysRestoreFPU&quot;;
 		//strOptions[op++] = &quot;-Djava.util.logging.config.file=&quot;JAI_DIR&quot;/logging.properties&quot;;
 
-		if (JVM_LOGGING) {
-			simpleLog_fine(&quot;JVM logging enabled.&quot;);
-			strOptions[op++] = &quot;-Xcheck:jni&quot;;
-			strOptions[op++] = &quot;-verbose:jni&quot;;
-			strOptions[op++] = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
-			strOptions[op++] = &quot;-XX:+LogVMOutput&quot;;
-			//strOptions[op++] = &quot;-XX:LogFile=C:/javaLog.txt&quot;;
-			//strOptions[op++] = &quot;-XX:LogFile=&quot;JAI_DIR&quot;/log/jvm-log.txt&quot;;
-		}
-		if (JVM_DEBUGGING) {
-			simpleLog_fine(&quot;JVM debugging enabled.&quot;);
-			strOptions[op++] = &quot;-Xdebug&quot;;
-			strOptions[op++] = &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=&quot;JVM_DEBUG_PORT;
-			// disable JIT (required for debugging under the classical VM)
-			strOptions[op++] = &quot;-Djava.compiler=NONE&quot;;
-			strOptions[op++] = &quot;-Xnoagent&quot;; // disables old JDB
-		}
+#if defined JVM_LOGGING
+		simpleLog_fine(&quot;JVM logging enabled.&quot;);
+		strOptions[op++] = &quot;-Xcheck:jni&quot;;
+		strOptions[op++] = &quot;-verbose:jni&quot;;
+		strOptions[op++] = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
+		strOptions[op++] = &quot;-XX:+LogVMOutput&quot;;
+		//strOptions[op++] = &quot;-XX:LogFile=C:/javaLog.txt&quot;;
+		//strOptions[op++] = &quot;-XX:LogFile=&quot;JAI_DIR&quot;/log/jvm-log.txt&quot;;
+#endif // defined JVM_LOGGING
+
+#if defined JVM_DEBUGGING
+		simpleLog_fine(&quot;JVM debugging enabled.&quot;);
+		strOptions[op++] = &quot;-Xdebug&quot;;
+		strOptions[op++] = &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=&quot;JVM_DEBUG_PORT;
+		// disable JIT (required for debugging under the classical VM)
+		strOptions[op++] = &quot;-Djava.compiler=NONE&quot;;
+		strOptions[op++] = &quot;-Xnoagent&quot;; // disables old JDB
+#endif // defined JVM_DEBUGGING
 	//}
-	unsigned int numOptions = op;
 
-	struct JavaVMOption* options = (struct JavaVMOption*) calloc(numOptions, sizeof(struct JavaVMOption));
+	const unsigned int numOptions = op;
 
+	struct JavaVMOption* options = (struct JavaVMOption*)
+			calloc(numOptions, sizeof(struct JavaVMOption));
+
 	// fill strOptions into the JVM options
 	simpleLog_fine(&quot;JVM init options (size: %i):&quot;, numOptions);
 	unsigned int i;
@@ -442,10 +394,6 @@
 		JavaVM* jvm = NULL;
 		struct JavaVMInitArgs vm_args;
 		jint res;
-/*
-		jclass cls;
-		jmethodID mid;
-*/
 
 		if (!java_createJavaVMInitArgs(&amp;vm_args)) {
 			simpleLog_error(-1, &quot;!Failed initializing JVM init-arguments.&quot;);
@@ -454,13 +402,15 @@
 
 		/*
 				// looking for existing JVMs is problematic,
-				// cause they could be initialized with other JVM-arguments then we need
+				// cause they could be initialized with other
+				// JVM-arguments then we need
 				simpleLog_log(&quot;looking for existing JVMs ...&quot;);
 				jsize numJVMsFound = 0;
 
 				// jint JNI_GetCreatedJavaVMs(JavaVM **vmBuf, jsize bufLen, jsize *nVMs);
 				// Returns all Java VMs that have been created.
-				// Pointers to VMs are written in the buffer vmBuf in the order they are created.
+				// Pointers to VMs are written in the buffer vmBuf,
+				// in the order they are created.
 				// At most bufLen number of entries will be written.
 				// The total number of created VMs is returned in *nVMs.
 				// Returns &#8220;0&#8221; on success; returns a negative number on failure.
@@ -497,7 +447,8 @@
 		}
 
 end:
-		if (env == NULL || jvm == NULL || (*env)-&gt;ExceptionCheck(env) || res != 0) {
+		if (env == NULL || jvm == NULL || (*env)-&gt;ExceptionCheck(env)
+				|| res != 0) {
 			simpleLog_fine(&quot;!Failed creating JVM.&quot;);
 			if (env != NULL &amp;&amp; (*env)-&gt;ExceptionCheck(env)) {
 				(*env)-&gt;ExceptionDescribe(env);
@@ -514,7 +465,8 @@
 	}
 
 	//simpleLog_fine(&quot;Reattaching current thread...&quot;);
-	jint res = (*g_jvm)-&gt;AttachCurrentThreadAsDaemon(g_jvm, (void**) &amp;g_jniEnv, NULL);
+	jint res = (*g_jvm)-&gt;AttachCurrentThreadAsDaemon(g_jvm,
+			(void**) &amp;g_jniEnv, NULL);
 	//res = jvm-&gt;AttachCurrentThread((void**) &amp; jniEnv, NULL);
 	if (res &lt; 0 || (*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
 		if ((*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
@@ -535,7 +487,8 @@
 
 		// We have to be the ONLY running thread (native and Java)
 		// this may not help, but cant be bad
-		jint res = (*g_jvm)-&gt;AttachCurrentThreadAsDaemon(g_jvm, (void**) &amp;g_jniEnv, NULL);
+		jint res = (*g_jvm)-&gt;AttachCurrentThreadAsDaemon(g_jvm,
+				(void**) &amp;g_jniEnv, NULL);
 		//res = jvm-&gt;AttachCurrentThread((void**) &amp; jniEnv, NULL);
 		if (res &lt; 0 || (*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
 			if ((*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
@@ -583,9 +536,11 @@
 
 	aiImplId_className = (const char**) calloc(maxSkirmishImpls, sizeof(char*));
 	aiImplId_instance = (jobject*) calloc(maxSkirmishImpls, sizeof(jobject));
-	aiImplId_methods = (jmethodID**) calloc(maxSkirmishImpls, sizeof(jmethodID*));
+	aiImplId_methods = (jmethodID**)
+			calloc(maxSkirmishImpls, sizeof(jmethodID*));
 	teamId_aiImplId = (unsigned int*) calloc(maxTeams, sizeof(unsigned int));
-	teamId_cCallback = (const struct SAICallback**) calloc(maxTeams, sizeof(struct SAICallback*));
+	teamId_cCallback =(const struct SAICallback**)
+			calloc(maxTeams, sizeof(struct SAICallback*));
 	teamId_jCallback = (jobject*) calloc(maxTeams, sizeof(jobject));
 
 	unsigned int impl;
@@ -639,7 +594,8 @@
 	// get no-arg constructor
 	g_m_props_ctor = (*env)-&gt;GetMethodID(env, g_cls_props, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
 	if (g_m_props_ctor == NULL || (*env)-&gt;ExceptionCheck(env)) {
-		simpleLog_log(&quot;!No-arg constructor not found for class: %s&quot;, &quot;java/util/Properties&quot;);
+		simpleLog_log(&quot;!No-arg constructor not found for class: %s&quot;,
+				&quot;java/util/Properties&quot;);
 		if ((*env)-&gt;ExceptionCheck(env)) {
 			(*env)-&gt;ExceptionDescribe(env);
 		}
@@ -647,10 +603,13 @@
 	}
 
 	// get the setProperty() method
-	g_m_props_setProperty = (*env)-&gt;GetMethodID(env, g_cls_props, &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
+	g_m_props_setProperty = (*env)-&gt;GetMethodID(env, g_cls_props, &quot;setProperty&quot;,
+			&quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
 	if (g_m_props_setProperty == NULL || (*env)-&gt;ExceptionCheck(env)) {
 		g_m_props_setProperty = NULL;
-		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, &quot;java/util/Properties&quot;, &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, &quot;java/util/Properties&quot;,
+				&quot;setProperty&quot;,
+				&quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
 		if ((*env)-&gt;ExceptionCheck(env)) {
 			(*env)-&gt;ExceptionDescribe(env);
 		}
@@ -737,7 +696,8 @@
 	for (op=0; op &lt; size; op++) {
 		jstring jstr_key = (*env)-&gt;NewStringUTF(env, keys[op]);
 		jstring jstr_value = (*env)-&gt;NewStringUTF(env, values[op]);
-		(*env)-&gt;CallObjectMethod(env, o_props, g_m_props_setProperty, jstr_key, jstr_value);
+		(*env)-&gt;CallObjectMethod(env, o_props, g_m_props_setProperty, jstr_key,
+				jstr_value);
 		if ((*env)-&gt;ExceptionCheck(env)) {
 			simpleLog_log(&quot;!Failed adding property&quot;);
 			if ((*env)-&gt;ExceptionCheck(env)) {
@@ -751,88 +711,6 @@
 }
 
 
-/**
- * Instantiates an instance of the class specified className.
- *
- * @param	className	fully qualified name of a Java clas that implements
- *						interface com.clan_sy.spring.ai.AI
- * @param	aiInstance	where the AI instance will be stored
- * @param	methods		where the method IDs of the AI will be stored
- */
-/*
-int getFactory(struct JNIEnv* env, const char* className, jobject aiInstance, jmethodID methods) {
-
-	if (g_factory == NULL) {
-		simpleLog_log(&quot;Create the factory...&quot;);
-
-		jclass cls_factory;
-		jmethodID mid_factory_init;
-		jmethodID mid_factory_createAi = NULL;
-		jmethodID mid_factory_createAiByName = NULL;
-		jobject factory = NULL;
-		jmethodID release_mid;
-		jclass javaAiClass = NULL;
-
-		// get factory class
-		cls_factory = jniEnv-&gt;FindClass(CLS_FACTORY);
-		if (cls_factory == 0) {
-			simpleLog_log(&quot;!Can't find class &quot;CLS_FACTORY);
-			goto end;
-		}
-
-		// get factory constructor
-		mid_factory_init = jniEnv-&gt;GetMethodID(cls_factory, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
-		if (mid_factory_init == 0) {
-			simpleLog_log(&quot;!Can't find no-arg-constructor of class &quot;CLS_FACTORY);
-			goto end;
-		}
-
-		// get factory method, the one that serves AI instances
-		mid_factory_createAi = jniEnv-&gt;GetMethodID(cls_factory, MTH_FACTORY_CREATEAI, SIG_FACTORY_CREATEAI);
-		if (mid_factory_createAi == 0) {
-			simpleLog_log(&quot;!Can't find method: &quot;CLS_FACTORY&quot;.&quot;MTH_FACTORY_CREATEAI&quot;&quot;SIG_FACTORY_CREATEAI);
-			goto end;
-		}
-		// get factory method , the one that serves AI instances out of a specified jar
-		mid_factory_createAiByName = jniEnv-&gt;GetMethodID(cls_factory, MTH_FACTORY_CREATEAIBYNAME, SIG_FACTORY_CREATEAIBYNAME);
-		if (mid_factory_createAiByName == 0) {
-			simpleLog_log(&quot;!Can't find method: &quot;CLS_FACTORY&quot;.&quot;MTH_FACTORY_CREATEAIBYNAME&quot;&quot;SIG_FACTORY_CREATEAIBYNAME);
-			goto end;
-		}
-
-		// create the factory
-		factory = jniEnv-&gt;NewObject(cls_factory, mid_factory_init);
-		if (factory == 0) {
-			simpleLog_log(&quot;!Can't instantiate factory.&quot;);
-			goto end;
-		}
-
-		// make the factory a global reference,
-		// so it will not be garbage collected,
-		// even after this method returned
-		factory = jniEnv-&gt;NewGlobalRef(factory);
-		if (jniEnv-&gt;ExceptionCheck()) {
-			simpleLog_log(&quot;!Can't make factory a global reference.&quot;);
-			goto end;
-		}
-
-end:
-		if (jniEnv-&gt;ExceptionCheck()) {
-			simpleLog_log(&quot;!Failed creating factory.&quot;);
-			factory = NULL;
-			jniEnv-&gt;ExceptionDescribe();
-		}
-
-		g_mid_factory_createAi = mid_factory_createAi;
-		g_mid_factory_createAiByName = mid_factory_createAiByName;
-		g_factory = factory;
-	}
-
-	return g_factory;
-}
-*/
-
-
 bool java_releaseStatic() {
 
 	unsigned int impl;
@@ -879,7 +757,7 @@
 
 	// convert className from &quot;com.myai.AI&quot; to &quot;com/myai/AI&quot;
 	char classNameP[strlen(className)+1];
-	strcpy(classNameP, className);
+	STRCPY(classNameP, className);
 	util_strReplace(classNameP, '.', '/');
 
 	// get the AI class
@@ -927,23 +805,29 @@
 	// get the AIs methods
 
 	// init
-	methods[MTH_INDEX_SKIRMISH_AI_INIT] = (*env)-&gt;GetMethodID(env, cls_ai, MTH_SKIRMISH_AI_INIT, SIG_SKIRMISH_AI_INIT);
+	methods[MTH_INDEX_SKIRMISH_AI_INIT] = (*env)-&gt;GetMethodID(env, cls_ai,
+			MTH_SKIRMISH_AI_INIT, SIG_SKIRMISH_AI_INIT);
 	if (methods[MTH_INDEX_SKIRMISH_AI_INIT] == NULL) {
-		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className, MTH_SKIRMISH_AI_INIT, SIG_SKIRMISH_AI_INIT);
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className,
+				MTH_SKIRMISH_AI_INIT, SIG_SKIRMISH_AI_INIT);
 		return false;
 	}
 
 	// release
-	methods[MTH_INDEX_SKIRMISH_AI_RELEASE] = (*env)-&gt;GetMethodID(env, cls_ai, MTH_SKIRMISH_AI_RELEASE, SIG_SKIRMISH_AI_RELEASE);
+	methods[MTH_INDEX_SKIRMISH_AI_RELEASE] = (*env)-&gt;GetMethodID(env, cls_ai,
+			MTH_SKIRMISH_AI_RELEASE, SIG_SKIRMISH_AI_RELEASE);
 	if (methods[MTH_INDEX_SKIRMISH_AI_RELEASE] == NULL) {
-		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className, MTH_SKIRMISH_AI_RELEASE, SIG_SKIRMISH_AI_RELEASE);
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className,
+				MTH_SKIRMISH_AI_RELEASE, SIG_SKIRMISH_AI_RELEASE);
 		return false;
 	}
 
 	// handleEvent
-	methods[MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT] = (*env)-&gt;GetMethodID(env, cls_ai, MTH_SKIRMISH_AI_HANDLE_EVENT, SIG_SKIRMISH_AI_HANDLE_EVENT);
+	methods[MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT] = (*env)-&gt;GetMethodID(env,
+			cls_ai, MTH_SKIRMISH_AI_HANDLE_EVENT, SIG_SKIRMISH_AI_HANDLE_EVENT);
 	if (methods[MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT] == NULL) {
-		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className, MTH_SKIRMISH_AI_HANDLE_EVENT, SIG_SKIRMISH_AI_HANDLE_EVENT);
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className,
+				MTH_SKIRMISH_AI_HANDLE_EVENT, SIG_SKIRMISH_AI_HANDLE_EVENT);
 		return false;
 	}
 
@@ -981,13 +865,16 @@
 			java_initPointerClass(env);
 		}
 
-		aiImplId_methods[implId] = (jmethodID*) calloc(MTHS_SIZE_SKIRMISH_AI, sizeof(jmethodID));
-		success = java_loadSkirmishAI(env, className, &amp;(aiImplId_instance[implId]), aiImplId_methods[implId]);
+		aiImplId_methods[implId] = (jmethodID*) calloc(MTHS_SIZE_SKIRMISH_AI,
+				sizeof(jmethodID));
+		success = java_loadSkirmishAI(env, className,
+				&amp;(aiImplId_instance[implId]), aiImplId_methods[implId]);
 		ESTABLISH_SPRING_ENV;
 		if (success) {
 			aiImplId_className[implId] = util_allocStrCpy(className);
 		} else {
-			simpleLog_error(-1, &quot;!Class loading failed for class: %s&quot;, className);
+			simpleLog_error(-1, &quot;!Class loading failed for class: %s&quot;,
+					className);
 		}
 	}
 
@@ -1060,7 +947,9 @@
 	return teamId_cCallback[teamId];
 }
 
-static jobject java_toJavaAICallback(JNIEnv* env, int teamId, const struct SAICallback* cCallback) {
+/*
+static jobject java_toJavaAICallback(JNIEnv* env, int teamId,
+		const struct SAICallback* cCallback) {
 
 	jobject jCallback = NULL;
 
@@ -1073,65 +962,9 @@
 
 	return jCallback;
 }
-
-/*
-static jobject java_toJavaAIEvent(JNIEnv* env, int teamId, int topic, const void* data) {
-
-	jobject jEvt = NULL;
-	bool ok = false;
-
-	switch (topic) {
-		case EVENT_INIT:
-			;
-			const struct SInitEvent* cEvt = (const struct SInitEvent*) data;
-			jclass cls_jEvt = (*env)-&gt;FindClass(env, PKG_EVENT&quot;InitAIEvent&quot;);
-			jfieldID f_jEvt_teamId = (*env)-&gt;GetFieldID(env, cls_jEvt,
-					&quot;teamId&quot;, &quot;I&quot;);
-			jfieldID f_jEvt_callback = (*env)-&gt;GetFieldID(env, cls_jEvt,
-					&quot;callback&quot;, &quot;L&quot;CLS_AI_CALLBACK&quot;;&quot;);
-			jfieldID f_jEvt_options = (*env)-&gt;GetFieldID(env, cls_jEvt,
-					&quot;options&quot;, &quot;Ljava/util/Properties;&quot;);
-			jclass cls_props = (*env)-&gt;FindClass(env, &quot;java/util/Properties&quot;);
-			jmethodID m_props_ctor = (*env)-&gt;GetMethodID(env, cls_props,
-					&quot;&lt;init&gt;&quot;, &quot;()V&quot;);
-			jmethodID m_props_setProperty = (*env)-&gt;GetMethodID(env, cls_jEvt,
-					&quot;setProperty&quot;,
-					&quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
-
-			jEvt = (*env)-&gt;AllocObject(env, cls_jEvt);
-
-			(*env)-&gt;SetIntField(env, jEvt, f_jEvt_teamId, cEvt-&gt;team);
-
-			jobject o_callback = java_toJavaAICallback(env, teamId, cEvt-&gt;callback);
-			(*env)-&gt;SetObjectField(env, jEvt, f_jEvt_callback, o_callback);
-
-			jobject props = (*env)-&gt;NewObject(env, cls_props, m_props_ctor);
-			unsigned int op;
-			for (op = 0; op &lt; cEvt-&gt;sizeOptions; op++) {
-				jstring jstr_key = (*env)-&gt;NewStringUTF(env, cEvt-&gt;optionKeys[op]);
-				jstring jstr_value = (*env)-&gt;NewStringUTF(env, cEvt-&gt;optionValues[op]);
-				(*env)-&gt;CallObjectMethod(env, props, m_props_setProperty,
-						jstr_key, jstr_value);
-			}
-			(*env)-&gt;SetObjectField(env, jEvt, f_jEvt_options, props);
-
-			ok = true;
-			break;
-		default:
-			//jEvt = new NullAIEvent();
-			break;
-	}
-
-	if (!ok) {
-		jEvt = false;
-	}
-
-	return jEvt;
-}
 */
 
 
-
 /**
  * Instantiates an instance of the class specified className.
  *
@@ -1215,7 +1048,8 @@
 
 	jmethodID mth = NULL;
 	jobject o_ai = NULL;
-	bool success = java_getSkirmishAIAndMethod(teamId, &amp;o_ai, MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT, &amp;mth);
+	bool success = java_getSkirmishAIAndMethod(teamId, &amp;o_ai,
+			MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT, &amp;mth);
 
 	if (success) {
 		ESTABLISH_JAVA_ENV;
@@ -1260,207 +1094,3 @@
 
 	return res;
 }
-
-
-
-/*
-		// make a new AI, specifying a jar
-		simpleLog_log(&quot;calling Java factory by-name method with \&quot;%s\&quot;...&quot;, aiJar);
-		jstring aiJarNameJava = jniEnv-&gt;NewStringUTF(aiJar);
-		javaAi = jniEnv-&gt;CallObjectMethod(factory, mid_factory_createAiByName, aiJarNameJava);
-	}
-	if (jniEnv-&gt;ExceptionCheck()) {
-		simpleLog_log(&quot;!Failed to get AI from factory.&quot;);
-		goto end;
-	}
-
-	// make the AI a global reference,
-	// so it will not be garbage collected,
-	// even after this method returned
-	javaAi = jniEnv-&gt;NewGlobalRef(javaAi);
-	if (jniEnv-&gt;ExceptionCheck()) {
-		simpleLog_log(&quot;!Failed to make AI a global reference.&quot;);
-		goto end;
-	}
-
-end:
-	if (jniEnv-&gt;ExceptionCheck()) {
-		javaAi = NULL;
-		jniEnv-&gt;ExceptionDescribe();
-	}
-
-	return javaAi;
-}
-
-
-
-IGlobalAI* ConnectJGlobalAI(struct JNIEnv* env, jobject javaAi) {
-
-	jclass javaAiClass;
-	SwigDirector_JGlobalAI* aiDirector;
-
-	static const bool swig_mem_own = true;
-	static const bool weak_global = false;
-
-	// make a new SWIG director, for connecting the Java AI with the native part
-	aiDirector = new SwigDirector_JGlobalAI(jniEnv);
-	if (jniEnv-&gt;ExceptionCheck()) {
-		simpleLog_log(&quot;!Failed to create SwigDirector_JGlobalAI.&quot;);
-		goto end;
-	}
-
-	// connect the SWIG director with the Java AI
-	javaAiClass = jniEnv-&gt;GetObjectClass(javaAi);
-	aiDirector-&gt;swig_connect_director(jniEnv, javaAi, javaAiClass, swig_mem_own, weak_global);
-	if (jniEnv-&gt;ExceptionCheck()) {
-		simpleLog_log(&quot;!Failed connecing SwigDirector_JGlobalAI.&quot;);
-		goto end;
-	}
-
-end:
-	if (jniEnv-&gt;ExceptionCheck()) {
-		aiDirector = NULL;
-		jniEnv-&gt;ExceptionDescribe();
-	}
-
-	return aiDirector;
-}
-*/
-
-/*
-
-DLL_EXPORT IGlobalAI* loadAIJar(const char* fileName) {
-
-	struct JNIEnv* env = getJNIEnv();
-
-	(*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
-
-	if (jniEnv == NULL) {
-		simpleLog_log(&quot;!JVM creation failed.&quot;);
-		return NULL;
-	}
-
-	jobject factory = GetFactory(jniEnv);
-	if (factory == NULL) {
-		simpleLog_log(&quot;!Factory creation failed.&quot;);
-		return NULL;
-	}
-
-	jobject javaAi = GetNewJGlobalAI(jniEnv, jarName);
-	if (javaAi == NULL) {
-		simpleLog_log(&quot;!Java AI creation failed.&quot;);
-		return NULL;
-	}
-
-	IGlobalAI* aiDirector = ConnectJGlobalAI(jniEnv, javaAi);
-	if (aiDirector == NULL) {
-		simpleLog_log(&quot;!Director creation failed.&quot;);
-		return NULL;
-	}
-
-	g_director_javaAis[aiDirector] = javaAi;
-
-	return aiDirector;
-}
-
-
-DLL_EXPORT void ReleaseAI(IGlobalAI* ai) {
-
-	JNIEnv* jniEnv = GetJNIEnv();
-	if (jniEnv == NULL) {
-		simpleLog_log(&quot;!JVM creation failed.&quot;);
-		simpleLog_log(&quot; -&gt; unable to delete global reference of Java AI.&quot;);
-	}
-
-	jobject javaAi = g_director_javaAis[ai];
-	g_director_javaAis.erase(ai);
-	ReleaseJavaAI(javaAi);
-
-	delete ai;
-	if (jniEnv != NULL) {
-		jniEnv-&gt;DeleteGlobalRef(javaAi);
-	}
-	javaAi = NULL;
-}
-*/
-
-
-/*
-int GetOptionsFromConfigFile(std::vector&lt;const char*&gt;* strOptions, const char* configFile) {
-
-	TiXmlDocument doc(configFile);
-	if (!doc.LoadFile()) return -1;
-
-	TiXmlHandle hDoc(&amp;doc);
-	TiXmlElement* pElem;
-	TiXmlHandle hRoot(0);
-	TiXmlHandle hJvm(0);
-	int numOptions = 0;
-
-	// get root node
-	{
-		pElem = hDoc.FirstChildElement().Element();
-		// should always have a valid root but handle gracefully if not
-		if (!pElem) return -2;
-		hRoot = TiXmlHandle(pElem);
-	}
-
-	// read options
-	{
-		pElem = hRoot.FirstChild(&quot;jvm&quot;).Element();
-		if (pElem == NULL) return -3;
-		hJvm = TiXmlHandle(pElem);
-
-		pElem = hJvm.FirstChild(&quot;option&quot;).Element();
-		for (pElem; pElem; pElem = pElem-&gt;NextSiblingElement()) {
-			if (pElem-&gt;GetText()) {
-				char* textCopy = new char[strlen(pElem-&gt;GetText()) + 1];
-				strcpy(textCopy, pElem-&gt;GetText());
-				strOptions-&gt;push_back(textCopy);
-				numOptions++;
-			}
-		}
-	}
-
-	return numOptions;
-}
-
-
-*/
-
-
-/*
-bool ReleaseJavaAI(jobject javaAi) {
-
-	jclass cls_javaAiImpl = NULL;
-	jmethodID release_mid = NULL;
-
-	JNIEnv* jniEnv = GetJNIEnv();
-	if (jniEnv == NULL) {
-		simpleLog_fine(&quot;!JVM creation failed.&quot;);
-		return false;
-	}
-
-	cls_javaAiImpl = jniEnv-&gt;GetObjectClass(javaAi);
-	release_mid = jniEnv-&gt;GetMethodID(cls_javaAiImpl, MTH_AI_RELEASE, SIG_AI_RELEASE);
-	if (release_mid == 0) {
-		simpleLog_fine(&quot;!Can't find method: (? extends &quot;CLS_AI&quot;).&quot;MTH_AI_RELEASE&quot;&quot;SIG_AI_RELEASE);
-		goto end;
-	}
-
-	jniEnv-&gt;CallVoidMethod(javaAi, release_mid);
-	if (jniEnv-&gt;ExceptionCheck()) {
-		simpleLog_fine(&quot;!Error when calling: (? extends &quot;CLS_AI&quot;).&quot;MTH_AI_RELEASE&quot;&quot;SIG_AI_RELEASE);
-		goto end;
-	}
-
-end:
-	if (jniEnv-&gt;ExceptionCheck() || release_mid == 0) {
-		simpleLog_fine(&quot;!Failed releasing Java AI.&quot;);
-		jniEnv-&gt;ExceptionDescribe();
-		return false;
-	}
-
-	return true;
-}
-*/

Modified: branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/JavaBridge.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/JavaBridge.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -16,9 +16,9 @@
  */
 
 #ifndef _JAVABRIDGE_H
-#define	_JAVABRIDGE_H
+#define _JAVABRIDGE_H
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
 
@@ -27,35 +27,13 @@
 struct SStaticGlobalData;
 struct SAICallback;
 
-/**
- * Returns a JNI environment, which includes a JVM.
- * Only one will exist at a time.
- * It is lazyly created.
- *
- * JNI = Java Native Interface
- * JVM = Java Virtual Machine
- */
-//JNIEnv* getJNIEnv();
+#if defined DEBUG
+	#define JVM_LOGGING
+	#define JVM_DEBUGGING
+	#define JVM_DEBUG_PORT &quot;7777&quot;
+#endif // defined DEBUG
 
-// #############################################################################
-// ### checked till here
-// #############################################################################
 
-#define JAI_DIR &quot;AI/Bot-libs/JAI&quot;
-#define IMPL_DIR &quot;AI/Bot-libs&quot;
-//#define IMPL_DIR JAI_DIR&quot;/impl&quot;
-#define LIB_DIR JAI_DIR&quot;/lib&quot;
-#define LOG_DIR JAI_DIR&quot;/log&quot;
-
-#define CONFIG_FILE JAI_DIR&quot;/config.xml&quot;
-#define LOG_FILE LOG_DIR&quot;/native-log.txt&quot;
-
-#define JVM_LOGGING true
-#define JVM_DEBUGGING false
-#define JVM_DEBUG_PORT &quot;7777&quot;
-#define MAX_JARS 512
-
-
 #define PKG_MAIN	&quot;com/clan_sy/spring/ai/&quot;
 #define PKG_EVENT	&quot;com/clan_sy/spring/ai/event/&quot;
 #define PKG_COMMAND	&quot;com/clan_sy/spring/ai/command/&quot;
@@ -64,28 +42,27 @@
 #define CLS_AI_CALLBACK	PKG_MAIN&quot;AICallback&quot;
 
 // #############################################################################
-// AI methods
+// Skirmish AI methods
 
-#define MTH_INDEX_SKIRMISH_AI_INIT			0
+#define MTH_INDEX_SKIRMISH_AI_INIT          0
 #define MTH_SKIRMISH_AI_INIT &quot;init&quot;
 #define SIG_SKIRMISH_AI_INIT &quot;(ILjava/util/Properties;Ljava/util/Properties;)I&quot;
 
-#define MTH_INDEX_SKIRMISH_AI_RELEASE		1
+#define MTH_INDEX_SKIRMISH_AI_RELEASE       1
 #define MTH_SKIRMISH_AI_RELEASE &quot;release&quot;
 #define SIG_SKIRMISH_AI_RELEASE &quot;(I)I&quot;
 
-#define MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT	2
+#define MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT  2
 #define MTH_SKIRMISH_AI_HANDLE_EVENT &quot;handleEvent&quot;
 //#define SIG_SKIRMISH_AI_HANDLE_EVENT &quot;(IL&quot;CLS_AI_EVENT&quot;;)I&quot;
 #define SIG_SKIRMISH_AI_HANDLE_EVENT &quot;(IILcom/sun/jna/Pointer;)I&quot;
 
 
-#define MTHS_SIZE_SKIRMISH_AI				3
+#define MTHS_SIZE_SKIRMISH_AI               3
+// #############################################################################
 
 
-
-
-
+// define path entry delimitter, used eg for the java class-path
 #ifdef WIN32
 #define ENTRY_DELIM &quot;;&quot;
 #else
@@ -94,17 +71,16 @@
 #define PATH_DELIM &quot;/&quot;
 
 
-//jobject GetFactory(JNIEnv* jniEnv);
-//jobject GetNewJGlobalAI(
-//IGlobalAI* ConnectJGlobalAI(JNIEnv* jniEnv, jobject javaAi);
-//bool ReleaseJavaAI(jobject javaAi);
-//
-//
-//DLL_EXPORT IGlobalAI* GetNewAIByName(const char* jarName);
-//DLL_EXPORT void ReleaseAI(IGlobalAI* ai);
-//
-//bool endsWith(const char* str, const char* suffix);
 
+///**
+// * Returns a JNI environment, which includes a JVM.
+// * Only one will exist at a time.
+// * It is lazyly created.
+// *
+// * JNI = Java Native Interface
+// * JVM = Java Virtual Machine
+// */
+//JNIEnv* getJNIEnv();
 bool java_preloadJNIEnv();
 bool java_unloadJNIEnv();
 bool java_initStatic(const struct SStaticGlobalData* staticGlobalData);
@@ -117,12 +93,13 @@
 		const char** infoKeys, const char** infoValues,
 		unsigned int optionsSize,
 		const char** optionsKeys, const char** optionsValues);
+int java_skirmishAI_release(int teamId);
+int java_skirmishAI_handleEvent(int teamId, int topic, const void* data);
 const struct SAICallback* java_getSkirmishAICCallback(int teamId);
 
 
-#ifdef	__cplusplus
-}
+#ifdef __cplusplus
+} // extern &quot;C&quot;
 #endif
 
-#endif	// _JAVABRIDGE_H
-
+#endif // _JAVABRIDGE_H

Modified: branches/caiinterface/AI/Interfaces/Java/Log.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/Log.c	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Interfaces/Java/Log.c	2008-12-17 11:32:14 UTC (rev 7188)
@@ -17,7 +17,7 @@
 
 #include &quot;Log.h&quot;
 
-#include &quot;InterfaceUtil.h&quot;
+#include &quot;Util.h&quot;
 #include &quot;InterfaceDefines.h&quot;
 
 #include &lt;stdio.h&gt;	// for file IO

Copied: branches/caiinterface/AI/Interfaces/Java/Util.c (from rev 7187, branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c)
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/Util.c	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/Util.c	2008-12-17 11:32:14 UTC (rev 7188)
@@ -0,0 +1,513 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;Util.h&quot;
+
+#include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot; // for sPS
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot; // for AI_INTERFACE_PROPERTY_DATA_DIR
+
+#include &lt;string.h&gt;	// strcpy(), str...()
+#include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
+#include &lt;sys/stat.h&gt;	// used for check if a file exists
+#ifdef	WIN32
+#include &lt;io.h&gt;		// needed for dir listing
+#include &lt;direct.h&gt;	// mkdir()
+#else	// WIN32
+#include &lt;sys/stat.h&gt;	// mkdir()
+#include &lt;sys/types.h&gt;	// mkdir()
+#include &lt;dirent.h&gt;		// needed for dir listing
+#endif	// WIN32
+
+static unsigned int myInfoSize;
+static const char** myInfoKeys;
+static const char** myInfoValues;
+
+static const char* myDataDirVersioned = NULL;
+static const char* myDataDirUnversioned = NULL;
+
+void util_setMyInfo(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues) {
+
+	myInfoSize = infoSize;
+	myInfoKeys = infoKeys;
+	myInfoValues = infoValues;
+
+	myDataDirVersioned = util_getMyInfo(AI_INTERFACE_PROPERTY_DATA_DIR);
+
+	const char* lastSlash = strrchr(myDataDirVersioned, '/');
+	if (lastSlash == NULL) {
+		lastSlash = strrchr(myDataDirVersioned, '\\');
+	}
+	myDataDirUnversioned = util_allocStrSubCpyByPointers(
+			myDataDirVersioned, myDataDirVersioned, lastSlash);
+}
+const char* util_getMyInfo(const char* key) {
+	return util_map_getValueByKey(myInfoSize, myInfoKeys, myInfoValues, key);
+}
+
+/*
+void util_setDataDirs(const char* unversioned, const char* versioned) {
+
+	myDataDir = unversioned;
+	myDataDirVers = versioned;
+}
+*/
+const char* util_getDataDirVersioned() {
+	return myDataDirVersioned;
+}
+const char* util_getDataDirUnversioned() {
+	return myDataDirUnversioned;
+}
+
+char* util_allocStr(unsigned int length) {
+	return (char*) calloc(length+1, sizeof(char));
+}
+
+char* util_allocStrCpy(const char* toCopy) {
+
+	char* copy = (char*) calloc(strlen(toCopy)+1, sizeof(char));
+	STRCPY(copy, toCopy);
+	return copy;
+}
+
+char* util_allocStrSubCpy(const char* toCopy, int fromPos, int toPos) {
+
+	if (toPos &lt; 0) {
+		toPos = strlen(toCopy);
+	}
+
+	if (fromPos &lt; 0 || toPos &lt; fromPos) {
+		return NULL;
+	}
+
+	unsigned int newSize = toPos - fromPos;
+	char* copy = (char*) calloc(newSize+1, sizeof(char));
+	unsigned int i;
+	for (i=0; i &lt; newSize; ++i) {
+		copy[i] = toCopy[fromPos + i];
+	}
+
+	return copy;
+}
+
+char* util_allocStrSubCpyByPointers(const char* toCopy,
+		const char* fromPos, const char* toPos) {
+
+	unsigned int newSize = toPos - fromPos;
+	char* copy = (char*) calloc(newSize+1, sizeof(char));
+	unsigned int i;
+	for (i=0; i &lt; newSize; ++i) {
+		copy[i] = *(fromPos + i);
+	}
+
+	return copy;
+}
+
+char* util_allocStrCpyCat(const char* toPart1, const char* toPart2) {
+
+	char* copy = (char*) calloc(strlen(toPart1)+strlen(toPart2)+1, sizeof(char));
+	STRCPY(copy, toPart1);
+	STRCAT(copy, toPart2);
+	return copy;
+}
+
+void util_strReplace(char* toChange, char toFind, char replacer) {
+
+	const unsigned int len = strlen(toChange);
+	unsigned int i;
+	for (i = 0; i &lt; len; i++) {
+		if (toChange[i] == toFind) {
+			toChange[i] = replacer;
+		}
+	}
+}
+
+bool util_endsWith(const char* str, const char* suffix) {
+
+	bool endsWith = false;
+
+	const unsigned int l_str = strlen(str);
+	const unsigned int l_suffix = strlen(suffix);
+
+	if (l_str &gt; l_suffix) {
+		endsWith = true;
+
+		unsigned int i;
+		for (i = 1; i &lt;= l_suffix; ++i) {
+			if (str[l_str - i] != suffix[l_suffix - i]) {
+				endsWith = false;
+				break;
+			}
+		}
+	}
+
+	return endsWith;
+}
+
+
+#ifdef WIN32
+static bool util_isFile(const struct _finddata_t* fileInfo) {
+	return !(fileInfo-&gt;attrib &amp; _A_SUBDIR)
+			&amp;&amp; fileInfo-&gt;attrib &amp; (_A_NORMAL | _A_HIDDEN | _A_ARCH);
+}
+static bool util_isNormalDir(const struct _finddata_t* fileInfo) {
+	return strcmp(fileInfo-&gt;name, &quot;.&quot;) != 0
+			&amp;&amp; strcmp(fileInfo-&gt;name, &quot;..&quot;) != 0
+			&amp;&amp; (fileInfo-&gt;attrib &amp; _A_SUBDIR);
+}
+static unsigned int util_listFilesRec(const char* dir, const char* suffix,
+		char** fileNames, bool recursive, const unsigned int maxFileNames,
+		unsigned int numFileNames, const char* relPath) {
+
+	if (numFileNames &gt;= maxFileNames) {
+		return numFileNames;
+	}
+
+	struct _finddata_t fileInfo;
+	int handle;
+
+	// look for files which end in: suffix
+	char suffixFilesSpec[strlen(dir) + strlen(&quot;\\*&quot;) + strlen(suffix) + 1];
+	STRCPY(suffixFilesSpec, dir);
+	STRCAT(suffixFilesSpec, &quot;\\*&quot;);
+	STRCAT(suffixFilesSpec, suffix);
+	handle = _findfirst(suffixFilesSpec, &amp;fileInfo);
+	if (handle != -1L) {
+		if (util_isFile(&amp;fileInfo)) {
+			fileNames[numFileNames++] = util_allocStrCpy(fileInfo.name);
+		}
+		while (_findnext(handle, &amp;fileInfo) == 0
+				&amp;&amp; numFileNames &lt; maxFileNames) {
+			if (util_isFile(&amp;fileInfo)) {
+				char fileRelPath[strlen(relPath) + strlen(fileInfo.name) + 1];
+					STRCPY(fileRelPath, relPath);
+					STRCAT(fileRelPath, fileInfo.name);
+				fileNames[numFileNames++] = util_allocStrCpy(fileRelPath);
+			}
+		}
+		_findclose(handle);
+	}
+
+	// search in sub-directories
+	if (recursive) {
+		char subDirsSpec[strlen(dir) + strlen(&quot;\\*.*&quot;) + 1];
+		STRCPY(subDirsSpec, dir);
+		STRCAT(subDirsSpec, &quot;\\*.*&quot;);
+		handle = _findfirst(subDirsSpec, &amp;fileInfo);
+		if (handle != -1L) {
+			// check if not current or parent directories
+			if (util_isNormalDir(&amp;fileInfo)) {
+				char subDir[strlen(dir) + strlen(&quot;\\&quot;)
+						+ strlen(fileInfo.name) + 1];
+				STRCPY(subDir, dir);
+				STRCAT(subDir, &quot;\\&quot;);
+				STRCAT(subDir, fileInfo.name);
+				char subRelPath[strlen(relPath) + strlen(fileInfo.name)
+						+ strlen(&quot;\\&quot;) + 1];
+				STRCPY(subRelPath, relPath);
+				STRCAT(subRelPath, fileInfo.name);
+				STRCAT(subRelPath, &quot;\\&quot;);
+				numFileNames = util_listFilesRec(subDir, suffix, fileNames,
+						recursive, maxFileNames, numFileNames, subRelPath);
+			}
+			while (_findnext(handle, &amp;fileInfo) == 0
+					&amp;&amp; numFileNames &lt; maxFileNames) {
+				if (util_isNormalDir(&amp;fileInfo)) {
+					char subDir[strlen(dir) + strlen(&quot;\\&quot;)
+							+ strlen(fileInfo.name) + 1];
+					STRCPY(subDir, dir);
+					STRCAT(subDir, &quot;\\&quot;);
+					STRCAT(subDir, fileInfo.name);
+					char subRelPath[strlen(relPath) + strlen(fileInfo.name)
+							+ strlen(&quot;\\&quot;) + 1];
+					STRCPY(subRelPath, relPath);
+					STRCAT(subRelPath, fileInfo.name);
+					STRCAT(subRelPath, &quot;\\&quot;);
+					numFileNames = util_listFilesRec(subDir, suffix, fileNames,
+							recursive, maxFileNames, numFileNames, subRelPath);
+				}
+			}
+			_findclose(handle);
+		}
+	}
+
+	return numFileNames;
+}
+unsigned int util_listFiles(const char* dir, const char* suffix,
+		char** fileNames, bool recursive, const unsigned int maxFileNames) {
+	return util_listFilesRec(
+			dir, suffix, fileNames, recursive, maxFileNames, 0, &quot;&quot;);
+}
+#else
+
+static const char* fileSelectorSuffix = NULL;
+
+static void util_initFileSelector(const char* suffix) {
+	fileSelectorSuffix = suffix;
+}
+static int util_fileSelector(const struct dirent* fileDesc) {
+	return util_endsWith(fileDesc-&gt;d_name, fileSelectorSuffix);
+}
+
+static unsigned int util_listFilesU(const char* dir, struct dirent*** files) {
+
+	int foundDirs = scandir(dir, files, util_fileSelector, alphasort);
+
+	if (foundDirs &lt; 0) { // error, act as if no file found
+		foundDirs = 0;
+	}
+
+	return (unsigned int) foundDirs;
+}
+
+static unsigned int util_listFilesRec(const char* dir, const char* suffix,
+		char** fileNames, bool recursive, const unsigned int maxFileNames,
+		unsigned int numFiles, const char* relPath) {
+
+	struct dirent** files;
+	util_initFileSelector(suffix);
+	unsigned int currentNumFiles = util_listFilesU(dir, &amp;files);
+	unsigned int f;
+	for (f = 0; f &lt; currentNumFiles &amp;&amp; numFiles &lt; maxFileNames; ++f) {
+		char fileRelPath[strlen(relPath) + strlen(files[f]-&gt;d_name) + 1];
+			STRCPY(fileRelPath, relPath);
+			STRCAT(fileRelPath, files[f]-&gt;d_name);
+		fileNames[numFiles++] = util_allocStrCpy(fileRelPath);
+	}
+/*
+	for (; f &lt; currentNumFiles; ++f) {
+		free(files[f]);
+	}
+*/
+
+	if (recursive) {
+		struct stat dirStat;
+		util_initFileSelector(&quot;&quot;);
+		currentNumFiles = util_listFilesU(dir, &amp;files);
+		for (f = 0; f &lt; currentNumFiles &amp;&amp; numFiles &lt; maxFileNames; ++f) {
+			if (strcmp(files[f]-&gt;d_name, &quot;.&quot;) == 0
+					|| strcmp(files[f]-&gt;d_name, &quot;..&quot;) == 0) {
+				continue;
+			}
+			char subDir[strlen(dir) + strlen(&quot;/&quot;) + strlen(relPath)
+					+ strlen(files[f]-&gt;d_name) + 1];
+			STRCPY(subDir, dir);
+			STRCAT(subDir, &quot;/&quot;);
+			STRCAT(subDir, relPath);
+			STRCAT(subDir, files[f]-&gt;d_name);
+			char subRelPath[strlen(relPath) + strlen(files[f]-&gt;d_name)
+					+ strlen(&quot;/&quot;) + 1];
+			STRCPY(subRelPath, relPath);
+			STRCAT(subRelPath, files[f]-&gt;d_name);
+			STRCAT(subRelPath, &quot;/&quot;);
+			int retStat = stat(subDir, &amp;dirStat);
+			if (retStat == 0 &amp;&amp; S_ISDIR(dirStat.st_mode)) {
+				numFiles = util_listFilesRec(subDir, suffix, fileNames,
+						recursive, maxFileNames, numFiles, subRelPath);
+			}
+		}
+	}
+
+	return numFiles;
+}
+unsigned int util_listFiles(const char* dir, const char* suffix,
+		char** fileNames, bool recursive, const unsigned int maxFileNames) {
+	return util_listFilesRec(
+			dir, suffix, fileNames, recursive, maxFileNames, 0, &quot;&quot;);
+}
+#endif
+
+bool util_fileExists(const char* filePath) {
+
+	struct stat fileInfo;
+	bool exists;
+	int intStat;
+
+	// Attempt to get the file attributes
+	intStat = stat(filePath, &amp;fileInfo);
+	if (intStat == 0) {
+		// We were able to get the file attributes
+		// so the file obviously exists.
+		exists = true;
+	} else {
+		// We were not able to get the file attributes.
+		// This may mean that we don't have permission to
+		// access the folder which contains this file. If you
+		// need to do that level of checking, lookup the
+		// return values of stat which will give you
+		// more details on why stat failed.
+		exists = false;
+	}
+
+	return exists;
+}
+
+bool util_makeDir(const char* dirPath) {
+
+	#ifdef	WIN32
+		int mkStat = _mkdir(dirPath);
+		if (mkStat == 0) {
+			return true;
+		} else {
+			return false;
+		}
+	#else	// WIN32
+		// with read/write/search permissions for owner and group,
+		// and with read/search permissions for others
+		int mkStat = mkdir(dirPath, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
+		if (mkStat == 0) {
+			return true;
+		} else {
+			return false;
+		}
+	#endif	// WIN32
+}
+
+bool util_makeDirRecursive(const char* dirPath) {
+
+	if (!util_fileExists(dirPath)) {
+		char parentDir[strlen(dirPath)+1];
+		bool hasParent = util_getParentDir(dirPath, parentDir);
+		if (hasParent) {
+			bool parentExists = util_makeDirRecursive(parentDir);
+			if (parentExists) {
+				return util_makeDir(dirPath);
+			}
+		}
+		return false;
+	}
+
+	return true;
+}
+
+bool util_getParentDir(const char* path, char* parentPath) {
+
+	//size_t pos = strcspn(dirPath, &quot;/\\&quot;);
+	char* ptr = strrchr(path, '/'); // search char from end reverse
+	if (ptr == NULL) {
+		ptr = strrchr(path, '\\'); // search char from end reverse
+		if (ptr == NULL) {
+			return false;
+		}
+	}
+
+	// copy the parent substring to parentPath
+	unsigned int i;
+	for (i = 0; &amp;(path[i+1]) != ptr; i++) {
+		parentPath[i] = path[i];
+	}
+	parentPath[i] = '\0';
+
+	return true;
+}
+
+bool util_findFile(const char* dirs[], unsigned int numDirs,
+		const char* relativeFilePath, char* absoluteFilePath) {
+
+	bool found = false;
+
+	// check if it is an absolute file path
+	if (util_fileExists(relativeFilePath)) {
+		STRCPY(absoluteFilePath, relativeFilePath);
+		found = true;
+	}
+
+	unsigned int d;
+	for (d=0; d &lt; numDirs &amp;&amp; !found; ++d) {
+		// do the following: tmpPath = dirs[d] + sPS + relativeFilePath
+		char* tmpPath = util_allocStr(strlen(dirs[d]) + 1 + strlen(relativeFilePath));
+		//char tmpPath[strlen(dirs[d]) + 1 + strlen(relativeFilePath) + 1];
+		tmpPath[0]= '\0';
+		tmpPath = STRCAT(tmpPath, dirs[d]);
+		tmpPath = STRCAT(tmpPath, sPS);
+		tmpPath = STRCAT(tmpPath, relativeFilePath);
+
+		if (util_fileExists(tmpPath)) {
+			STRCPY(absoluteFilePath, tmpPath);
+			found = true;
+		}
+
+		free(tmpPath);
+	}
+
+	return found;
+}
+
+bool util_findDir(const char* dirs[], unsigned int numDirs,
+		const char* relativeDirPath, char* absoluteDirPath,
+		bool searchOnlyWriteable, bool create) {
+
+	bool found = false;
+
+	// check if it is an absolute file path
+	if (util_fileExists(relativeDirPath)) {
+		STRCPY(absoluteDirPath, relativeDirPath);
+		found = true;
+	}
+
+	if (searchOnlyWriteable &amp;&amp; numDirs &gt; 1) {
+		numDirs = 1;
+	}
+
+	unsigned int d;
+	for (d=0; d &lt; numDirs &amp;&amp; !found; ++d) {
+		// do the following: tmpPath = dirs[d] + sPS + relativeFilePath
+		char* tmpPath = util_allocStr(strlen(dirs[d]) + 1 + strlen(relativeDirPath));
+		//char tmpPath[strlen(dirs[d]) + 1 + strlen(relativeDirPath) + 1];
+		tmpPath[0]= '\0';
+		tmpPath = STRCAT(tmpPath, dirs[d]);
+		tmpPath = STRCAT(tmpPath, sPS);
+		tmpPath = STRCAT(tmpPath, relativeDirPath);
+
+		if (util_fileExists(tmpPath)) {
+			STRCPY(absoluteDirPath, tmpPath);
+			found = true;
+		}
+
+		free(tmpPath);
+	}
+
+	// not found -&gt; create it
+	if (!found &amp;&amp; create &amp;&amp; numDirs &gt;= 1) {
+		STRCAT(absoluteDirPath, dirs[0]);
+		STRCAT(absoluteDirPath, sPS);
+		STRCAT(absoluteDirPath, relativeDirPath);
+		found = util_makeDir(absoluteDirPath);
+	}
+
+	return found;
+}
+
+const char* util_map_getValueByKey(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const char* key) {
+
+	const char* value = NULL;
+
+	unsigned int i;
+	for (i = 0; i &lt; infoSize; i++) {
+		if (strcmp(infoKeys[i], key) == 0) {
+			value = infoValues[i];
+			break;
+		}
+	}
+
+	return value;
+}
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/Util.c
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Interfaces/Java/Util.h (from rev 7187, branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.h)
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/Util.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/Util.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -0,0 +1,114 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _INTERFACEUTIL_H
+#define _INTERFACEUTIL_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;stdbool.h&gt;	// bool, true, false
+
+#ifdef _MSC_VER
+	// Microsoft Visual C++ 7.1: MSC_VER = 1310
+	// Microsoft Visual C++ 7.0: MSC_VER = 1300
+	#if _MSC_VER &gt; 1310 // &gt;= Visual Studio 2005
+		#define PRINTF printf_s
+		#define FPRINTF fprintf_s
+		#define SNPRINTF sprintf_s
+		#define VSNPRINTF vsprintf_s
+		#define STRCPY strcpy_s
+		#define STRCAT strcat_s
+		#define FOPEN fopen_s
+	#else              // Visual Studio 2003
+		#define PRINTF _printf
+		#define FPRINTF _fprintf
+		#define SNPRINTF _snprintf
+		#define VSNPRINTF _vsnprintf
+		#define STRCPY strcpy
+		#define STRCAT strcat
+		#define FOPEN fopen
+	#endif
+	#define STRCASECMP stricmp
+#else	// _MSC_VER
+	// assuming GCC
+	#define PRINTF printf
+	#define FPRINTF fprintf
+	#define SNPRINTF snprintf
+	#define VSNPRINTF vsnprintf
+	#define STRCPY strcpy
+	#define STRCAT strcat
+	#define FOPEN fopen
+	#define STRCASECMP strcasecmp
+#endif	// _MSC_VER
+
+void util_setMyInfo(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues);
+const char* util_getMyInfo(const char* key);
+
+//void util_setDataDirs(const char* unversioned, const char* versioned);
+const char* util_getDataDirVersioned();
+const char* util_getDataDirUnversioned();
+
+char* util_allocStr(unsigned int length);
+
+char* util_allocStrCpy(const char* toCopy);
+
+char* util_allocStrSubCpy(const char* toCopy, int fromPos, int toPos);
+char* util_allocStrSubCpyByPointers(const char* toCopy,
+		const char* fromPos, const char* toPos);
+
+char* util_allocStrCpyCat(const char* toPart1, const char* toPart2);
+
+void util_strReplace(char* toChange, char toFind, char replacer);
+
+bool util_endsWith(const char* str, const char* suffix);
+
+// suffix example: &quot;.jar&quot;
+unsigned int util_listFiles(const char* dir, const char* suffix,
+		char** fileNames, bool recursive, const unsigned int maxFileNames);
+
+bool util_fileExists(const char* filePath);
+
+bool util_makeDir(const char* dirPath);
+
+bool util_makeDirRecursive(const char* dirPath);
+
+bool util_getParentDir(const char* path, char* parentPath);
+
+bool util_findFile(const char* dirs[], unsigned int numDirs,
+		const char* relativeFilePath, char* absoluteFilePath);
+
+bool util_findDir(const char* dirs[], unsigned int numDirs,
+		const char* relativeDirPath, char* absoluteDirPath,
+		bool searchOnlyWriteable, bool create);
+
+/**
+ * Return NULL if the key was not found.
+ */
+const char* util_map_getValueByKey(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const char* key);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif // _INTERFACEUTIL_H


Property changes on: branches/caiinterface/AI/Interfaces/Java/Util.h
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Modified: branches/caiinterface/AI/Skirmish/AAI/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AIExport.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/AAI/AIExport.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -32,9 +32,17 @@
 #include &quot;AAI.h&quot;
 
 
-std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
+static std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
 
+static unsigned int myInfoSize;
+static const char** myInfoKeys;
+static const char** myInfoValues;
 
+static std::map&lt;int, unsigned int&gt; myOptionsSize;
+static std::map&lt;int, const char**&gt; myOptionsKeys;
+static std::map&lt;int, const char**&gt; myOptionsValues;
+
+
 EXPORT(enum LevelOfSupport) getLevelOfSupportFor(int teamId,
 		const char* engineVersionString, int engineVersionNumber,
 		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
@@ -60,6 +68,14 @@
 		return -1;
 	}
 
+	myInfoSize = infoSize;
+	myInfoKeys = infoKeys;
+	myInfoValues = infoValues;
+
+	myOptionsSize[teamId] = optionsSize;
+	myOptionsKeys[teamId] = optionsKeys;
+	myOptionsValues[teamId] = optionsValues;
+
 	// CAIGlobalAI is the Legacy C++ wrapper
 	myAIs[teamId] = new CAIGlobalAI(teamId, new AAI());
 
@@ -97,3 +113,51 @@
 	return -1;
 }
 
+
+// methods from here on are for AI internal use only
+
+static const char* util_map_getValueByKey(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const char* key) {
+
+	const char* value = NULL;
+
+	unsigned int i;
+	for (i = 0; i &lt; infoSize; i++) {
+		if (strcmp(infoKeys[i], key) == 0) {
+			value = infoValues[i];
+			break;
+		}
+	}
+
+	return value;
+}
+
+const char* aiexport_getMyInfo(const char* key) {
+	return util_map_getValueByKey(myInfoSize, myInfoKeys, myInfoValues, key);
+}
+const char* aiexport_getDataDir() {
+
+	static char* ddWithSlash = NULL;
+
+	if (ddWithSlash == NULL) {
+		const char* dd = aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_DATA_DIR);
+
+		ddWithSlash = (char*) calloc(strlen(dd) + 1 + 1, sizeof(char));
+		strcpy(ddWithSlash, dd);
+		strcat(ddWithSlash, &quot;/&quot;);
+	}
+
+	return ddWithSlash;
+}
+const char* aiexport_getVersion() {
+	return aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_VERSION);
+}
+
+const char* aiexport_getMyOption(int teamId, const char* key) {
+	return util_map_getValueByKey(
+			myOptionsSize[teamId],
+			myOptionsKeys[teamId], myOptionsValues[teamId],
+			key);
+}

Modified: branches/caiinterface/AI/Skirmish/AAI/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AIExport.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/AAI/AIExport.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -49,5 +49,10 @@
 EXPORT(int) release(int teamId);
 EXPORT(int) handleEvent(int teamId, int topic, const void* data);
 
+// methods from here on are for AI internal use only
+const char* aiexport_getMyInfo(const char* key);
+const char* aiexport_getDataDir();
+const char* aiexport_getVersion();
+const char* aiexport_getMyOption(int teamId, const char* key);
+
 #endif // _AIEXPORT_H
-

Modified: branches/caiinterface/AI/Skirmish/AAI/Interface.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/Interface.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/AAI/Interface.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,50 +1,50 @@
-// -------------------------------------------------------------------------
-// AAI
+//// -------------------------------------------------------------------------
+//// AAI
+////
+//// A skirmish AI for the TA Spring engine.
+//// Copyright Alexander Seizinger
+////
+//// Released under GPL license: see LICENSE.html for more information.
+//// -------------------------------------------------------------------------
 //
-// A skirmish AI for the TA Spring engine.
-// Copyright Alexander Seizinger
-// 
-// Released under GPL license: see LICENSE.html for more information.
-// -------------------------------------------------------------------------
-
-#include &quot;aidef.h&quot;
-#include &quot;Platform/Win/win32.h&quot;
-#include &quot;AAI.h&quot;
-
-/////////////////////////////////////////////////////////////////////////////
-
-std::set&lt;IGlobalAI*&gt; ais;
-
-
-SHARED_EXPORT int GetGlobalAiVersion()
-{
-	return GLOBAL_AI_INTERFACE_VERSION;
-}
-
-SHARED_EXPORT void GetAiName(char* name)
-{
-	strcpy(name, AAI_VERSION);
-}
-
-SHARED_EXPORT IGlobalAI* GetNewAI()
-{
-	AAI* ai = new AAI();
-	ais.insert(ai);
-	return ai;
-}
-
-SHARED_EXPORT void ReleaseAI(IGlobalAI* i)
-{
-	ais.erase(i);
-	delete (AAI*)i;
-}
-
-SHARED_EXPORT int IsCInterface(void) 
-{
-	return 0;
-} 
-
-SHARED_EXPORT int IsLoadSupported() 
-{
-	return 0;
-}
+//#include &quot;aidef.h&quot;
+//#include &quot;Platform/Win/win32.h&quot;
+//#include &quot;AAI.h&quot;
+//
+///////////////////////////////////////////////////////////////////////////////
+//
+//std::set&lt;IGlobalAI*&gt; ais;
+//
+//
+//SHARED_EXPORT int GetGlobalAiVersion()
+//{
+//	return GLOBAL_AI_INTERFACE_VERSION;
+//}
+//
+//SHARED_EXPORT void GetAiName(char* name)
+//{
+//	strcpy(name, AAI_VERSION);
+//}
+//
+//SHARED_EXPORT IGlobalAI* GetNewAI()
+//{
+//	AAI* ai = new AAI();
+//	ais.insert(ai);
+//	return ai;
+//}
+//
+//SHARED_EXPORT void ReleaseAI(IGlobalAI* i)
+//{
+//	ais.erase(i);
+//	delete (AAI*)i;
+//}
+//
+//SHARED_EXPORT int IsCInterface(void)
+//{
+//	return 0;
+//}
+//
+//SHARED_EXPORT int IsLoadSupported()
+//{
+//	return 0;
+//}

Modified: branches/caiinterface/AI/Skirmish/AAI/aidef.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/aidef.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/AAI/aidef.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -25,6 +25,7 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandQueue.h&quot;
 #include &quot;AAIConfig.h&quot;
+#include &quot;AIExport.h&quot;
 
 
 
@@ -37,14 +38,14 @@
 #ifndef AIDEF_H
 #define AIDEF_H
 
-#define AAI_VERSION &quot;0.875&quot;
+#define AAI_VERSION aiexport_getVersion()
 #define MAP_FILE_VERSION &quot;MAP_LEARN_0_80&quot;
 #define TABLE_FILE_VERSION &quot;MOD_LEARN_0_87&quot;
 #define MAP_CACHE_VERSION &quot;MAP_DATA_0_87&quot;
 #define CONTINENT_DATA_VERSION &quot;MOVEMENT_MAPS_0_87&quot;
 
 // all paths
-#define MAIN_PATH &quot;AI/Skirmish/AAI/&quot;AAI_VERSION&quot;/&quot;
+#define MAIN_PATH aiexport_getDataDir()
 #define AILOG_PATH &quot;log/&quot;
 #define MOD_CFG_PATH &quot;cfg/mod/&quot;
 #define GENERAL_CFG_FILE &quot;cfg/general.cfg&quot;

Modified: branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIExport.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -32,9 +32,17 @@
 #include &quot;GlobalAI.h&quot;
 
 
-std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
+static std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
 
+static unsigned int myInfoSize;
+static const char** myInfoKeys;
+static const char** myInfoValues;
 
+static std::map&lt;int, unsigned int&gt; myOptionsSize;
+static std::map&lt;int, const char**&gt; myOptionsKeys;
+static std::map&lt;int, const char**&gt; myOptionsValues;
+
+
 EXPORT(enum LevelOfSupport) getLevelOfSupportFor(int teamId,
 		const char* engineVersionString, int engineVersionNumber,
 		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
@@ -60,6 +68,14 @@
 		return -1;
 	}
 
+	myInfoSize = infoSize;
+	myInfoKeys = infoKeys;
+	myInfoValues = infoValues;
+
+	myOptionsSize[teamId] = optionsSize;
+	myOptionsKeys[teamId] = optionsKeys;
+	myOptionsValues[teamId] = optionsValues;
+
 	// CAIGlobalAI is the Legacy C++ wrapper, CGlobalAI is KAIK
 	myAIs[teamId] = new CAIGlobalAI(teamId, new CGlobalAI());
 
@@ -96,3 +112,52 @@
 	// no AI for that team, so return error.
 	return -1;
 }
+
+
+// methods from here on are for AI internal use only
+
+static const char* util_map_getValueByKey(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const char* key) {
+
+	const char* value = NULL;
+
+	unsigned int i;
+	for (i = 0; i &lt; infoSize; i++) {
+		if (strcmp(infoKeys[i], key) == 0) {
+			value = infoValues[i];
+			break;
+		}
+	}
+
+	return value;
+}
+
+const char* aiexport_getMyInfo(const char* key) {
+	return util_map_getValueByKey(myInfoSize, myInfoKeys, myInfoValues, key);
+}
+const char* aiexport_getDataDir() {
+
+	static char* ddWithSlash = NULL;
+
+	if (ddWithSlash == NULL) {
+		const char* dd = aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_DATA_DIR);
+
+		ddWithSlash = (char*) calloc(strlen(dd) + 1 + 1, sizeof(char));
+		strcpy(ddWithSlash, dd);
+		strcat(ddWithSlash, &quot;/&quot;);
+	}
+
+	return ddWithSlash;
+}
+const char* aiexport_getVersion() {
+	return aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_VERSION);
+}
+
+const char* aiexport_getMyOption(int teamId, const char* key) {
+	return util_map_getValueByKey(
+			myOptionsSize[teamId],
+			myOptionsKeys[teamId], myOptionsValues[teamId],
+			key);
+}

Modified: branches/caiinterface/AI/Skirmish/KAIK/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/AIExport.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIExport.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -49,4 +49,10 @@
 EXPORT(int) release(int teamId);
 EXPORT(int) handleEvent(int teamId, int topic, const void* data);
 
+// methods from here on are for AI internal use only
+const char* aiexport_getMyInfo(const char* key);
+const char* aiexport_getDataDir();
+const char* aiexport_getVersion();
+const char* aiexport_getMyOption(int teamId, const char* key);
+
 #endif // _AIEXPORT_H

Modified: branches/caiinterface/AI/Skirmish/KAIK/Defines.h
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/Defines.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/KAIK/Defines.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,9 +1,13 @@
 #ifndef DEFINES_H
 #define DEFINES_H
 
-#define AI_NAME			&quot;KAIK 0.13 Unofficial&quot;
+#include &quot;AIExport.h&quot; // for aiexport_getVersion() and aiexport_getDataDir()
+
+#define AI_VERSION_NUMBER aiexport_getVersion()
+//#define AI_VERSION_NUMBER &quot;0.13&quot;
+#define AI_NAME			std::string(&quot;KAIK &quot;) + AI_VERSION_NUMBER + &quot; Unofficial&quot;
 #define AI_DATE			&quot;20/10/2008&quot;
-#define AI_VERSION		AI_NAME &quot; (rev. &quot; AI_DATE &quot;)&quot;
+#define AI_VERSION		AI_NAME + &quot; (rev. &quot; + AI_DATE + &quot;)&quot;
 #define AI_CREDITS		&quot;(original developer: Krogothe, current maintainer: Kloot)&quot;
 
 // Logger
@@ -24,12 +28,12 @@
 #define TIMER_SECS		ai-&gt;math-&gt;TimerSecs()
 
 // Folders
-#define ROOTFOLDER		&quot;AI/KAIK013/&quot;
+#define ROOTFOLDER		aiexport_getDataDir()
 
-#define LOGFOLDER		ROOTFOLDER&quot;Logs/&quot;
-#define METALFOLDER		ROOTFOLDER&quot;Metal/&quot;
-#define TGAFOLDER		ROOTFOLDER&quot;TGAs/&quot;
-#define CFGFOLDER		ROOTFOLDER&quot;CFGs/&quot;
+#define LOGFOLDER		std::string(ROOTFOLDER) + &quot;Logs/&quot;
+#define METALFOLDER		std::string(ROOTFOLDER) + &quot;Metal/&quot;
+#define TGAFOLDER		std::string(ROOTFOLDER) + &quot;TGAs/&quot;
+#define CFGFOLDER		std::string(ROOTFOLDER) + &quot;CFGs/&quot;
 
 // Error outputs
 #define ZEROVECTOR		float3( 0, 0, 0)

Modified: branches/caiinterface/AI/Skirmish/KAIK/GlobalAI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/GlobalAI.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/KAIK/GlobalAI.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -168,7 +168,8 @@
 	sprintf(c, &quot;%s%s %2.2d-%2.2d-%4.4d %2.2d%2.2d (team %d).log&quot;,
 		string(LOGFOLDER).c_str(), mapname.c_str(), now2-&gt;tm_mon + 1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour, now2-&gt;tm_min, team);
 
-	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, CFGFOLDER);
+	string cfgFolderStr = CFGFOLDER;
+	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, cfgFolderStr.c_str());
 
 	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, this-&gt;c);
 	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, cfgFolder);
@@ -236,10 +237,12 @@
 	struct tm* now2 = localtime(&amp;now1);
 
 	// timestamp logfile name
+	string logFolder = LOGFOLDER;
 	sprintf(this-&gt;c, &quot;%s%s %2.2d-%2.2d-%4.4d %2.2d%2.2d (team %d).log&quot;,
-		string(LOGFOLDER).c_str(), mapname.c_str(), (now2-&gt;tm_mon + 1), now2-&gt;tm_mday, (now2-&gt;tm_year + 1900), now2-&gt;tm_hour, now2-&gt;tm_min, team);
+		logFolder.c_str(), mapname.c_str(), (now2-&gt;tm_mon + 1), now2-&gt;tm_mday, (now2-&gt;tm_year + 1900), now2-&gt;tm_hour, now2-&gt;tm_min, team);
 
-	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, CFGFOLDER);
+	string cfgFolderStr = CFGFOLDER;
+	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, cfgFolderStr.c_str());
 
 	// initialize class wrapper struct
 	ai = new AIClasses;
@@ -278,7 +281,8 @@
 	ai-&gt;ut-&gt;Init();
 	ai-&gt;pather-&gt;Init();
 
-	ai-&gt;cb-&gt;SendTextMsg(AI_VERSION &quot; initialized succesfully!&quot;, 0);
+	std::string versMsg = std::string(AI_VERSION) + &quot; initialized succesfully!&quot;;
+	ai-&gt;cb-&gt;SendTextMsg(versMsg.c_str(), 0);
 	ai-&gt;cb-&gt;SendTextMsg(AI_CREDITS, 0);
 }
 

Modified: branches/caiinterface/AI/Skirmish/KAIK/UnitTable.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/UnitTable.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/KAIK/UnitTable.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -153,9 +153,10 @@
 	L(&quot;[CUnitTable::ReadModConfig()]&quot;);
 
 	const char* modName = ai-&gt;cb-&gt;GetModName();
-	char configFileName[1024] = {0};
-	char logMsg[2048] = {0};
-	snprintf(configFileName, 1023, &quot;%s%s.cfg&quot;, CFGFOLDER, modName);
+	char configFileName[1024] = {'\0'};
+	char logMsg[2048] = {'\0'};
+	std::string cfgFolderStr = CFGFOLDER;
+	snprintf(configFileName, 1023, &quot;%s%s.cfg&quot;, cfgFolderStr.c_str(), modName);
 	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, configFileName);
 
 	FILE* f = fopen(configFileName, &quot;r&quot;);
@@ -1029,7 +1030,9 @@
 		&quot;ENERGY-STORAGE&quot;, &quot;NUKE-SILO&quot;, &quot;SHIELD-GENERATOR&quot;, &quot;LAST-CATEGORY&quot;
 	};
 
-	char filename[1024] = ROOTFOLDER&quot;CUnitTable.log&quot;;
+	char filename[1024];
+	strcpy(filename, ROOTFOLDER);
+	strcat(filename, &quot;CUnitTable.log&quot;);
 	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
 	FILE* file = fopen(filename, &quot;w&quot;);
 

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -32,9 +32,17 @@
 #include &quot;CNTai.h&quot;
 
 
-std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
+static std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
 
+static unsigned int myInfoSize;
+static const char** myInfoKeys;
+static const char** myInfoValues;
 
+static std::map&lt;int, unsigned int&gt; myOptionsSize;
+static std::map&lt;int, const char**&gt; myOptionsKeys;
+static std::map&lt;int, const char**&gt; myOptionsValues;
+
+
 EXPORT(enum LevelOfSupport) getLevelOfSupportFor(int teamId,
 		const char* engineVersionString, int engineVersionNumber,
 		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
@@ -60,6 +68,14 @@
 		return -1;
 	}
 
+	myInfoSize = infoSize;
+	myInfoKeys = infoKeys;
+	myInfoValues = infoValues;
+
+	myOptionsSize[teamId] = optionsSize;
+	myOptionsKeys[teamId] = optionsKeys;
+	myOptionsValues[teamId] = optionsValues;
+
 	// CAIGlobalAI is the Legacy C++ wrapper, CGlobalAI is KAIK
 	myAIs[teamId] = new CAIGlobalAI(teamId, new ntai::CNTai());
 
@@ -97,3 +113,51 @@
 	return -1;
 }
 
+
+// methods from here on are for AI internal use only
+
+static const char* util_map_getValueByKey(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const char* key) {
+
+	const char* value = NULL;
+
+	unsigned int i;
+	for (i = 0; i &lt; infoSize; i++) {
+		if (strcmp(infoKeys[i], key) == 0) {
+			value = infoValues[i];
+			break;
+		}
+	}
+
+	return value;
+}
+
+const char* aiexport_getMyInfo(const char* key) {
+	return util_map_getValueByKey(myInfoSize, myInfoKeys, myInfoValues, key);
+}
+const char* aiexport_getDataDir() {
+
+	static char* ddWithSlash = NULL;
+
+	if (ddWithSlash == NULL) {
+		const char* dd = aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_DATA_DIR);
+
+		ddWithSlash = (char*) calloc(strlen(dd) + 1 + 1, sizeof(char));
+		strcpy(ddWithSlash, dd);
+		strcat(ddWithSlash, &quot;/&quot;);
+	}
+
+	return ddWithSlash;
+}
+const char* aiexport_getVersion() {
+	return aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_VERSION);
+}
+
+const char* aiexport_getMyOption(int teamId, const char* key) {
+	return util_map_getValueByKey(
+			myOptionsSize[teamId],
+			myOptionsKeys[teamId], myOptionsValues[teamId],
+			key);
+}

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/AIExport.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -49,5 +49,10 @@
 EXPORT(int) release(int teamId);
 EXPORT(int) handleEvent(int teamId, int topic, const void* data);
 
+// methods from here on are for AI internal use only
+const char* aiexport_getMyInfo(const char* key);
+const char* aiexport_getDataDir();
+const char* aiexport_getVersion();
+const char* aiexport_getMyOption(int teamId, const char* key);
+
 #endif // _AIEXPORT_H
-

Modified: branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/AIExport.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -31,11 +31,19 @@
 // RAI stuff
 #include &quot;RAI.h&quot;
 
-#define MY_SHORT_NAME &quot;RAI&quot;
-#define MY_VERSION &quot;0.601&quot;
+//#define MY_SHORT_NAME &quot;RAI&quot;
+//#define MY_VERSION &quot;0.601&quot;
 
-std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
+static std::map&lt;int, CAIGlobalAI*&gt; myAIs; // teamId -&gt; AI map
 
+static unsigned int myInfoSize;
+static const char** myInfoKeys;
+static const char** myInfoValues;
+
+static std::map&lt;int, unsigned int&gt; myOptionsSize;
+static std::map&lt;int, const char**&gt; myOptionsKeys;
+static std::map&lt;int, const char**&gt; myOptionsValues;
+
 EXPORT(enum LevelOfSupport) getLevelOfSupportFor(int teamId,
 		const char* engineVersionString, int engineVersionNumber,
 		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
@@ -61,6 +69,14 @@
 		return -1;
 	}
 
+	myInfoSize = infoSize;
+	myInfoKeys = infoKeys;
+	myInfoValues = infoValues;
+
+	myOptionsSize[teamId] = optionsSize;
+	myOptionsKeys[teamId] = optionsKeys;
+	myOptionsValues[teamId] = optionsValues;
+
 	// CAIGlobalAI is the Legacy C++ wrapper, cRAI is RAI
 	myAIs[teamId] = new CAIGlobalAI(teamId, new cRAI());
 
@@ -97,3 +113,52 @@
 	// no AI for that team, so return error.
 	return -1;
 }
+
+
+// methods from here on are for AI internal use only
+
+static const char* util_map_getValueByKey(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const char* key) {
+
+	const char* value = NULL;
+
+	unsigned int i;
+	for (i = 0; i &lt; infoSize; i++) {
+		if (strcmp(infoKeys[i], key) == 0) {
+			value = infoValues[i];
+			break;
+		}
+	}
+
+	return value;
+}
+
+const char* aiexport_getMyInfo(const char* key) {
+	return util_map_getValueByKey(myInfoSize, myInfoKeys, myInfoValues, key);
+}
+const char* aiexport_getDataDir() {
+
+	static char* ddWithSlash = NULL;
+
+	if (ddWithSlash == NULL) {
+		const char* dd = aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_DATA_DIR);
+
+		ddWithSlash = (char*) calloc(strlen(dd) + 1 + 1, sizeof(char));
+		strcpy(ddWithSlash, dd);
+		strcat(ddWithSlash, &quot;/&quot;);
+	}
+
+	return ddWithSlash;
+}
+const char* aiexport_getVersion() {
+	return aiexport_getMyInfo(SKIRMISH_AI_PROPERTY_VERSION);
+}
+
+const char* aiexport_getMyOption(int teamId, const char* key) {
+	return util_map_getValueByKey(
+			myOptionsSize[teamId],
+			myOptionsKeys[teamId], myOptionsValues[teamId],
+			key);
+}

Modified: branches/caiinterface/AI/Skirmish/RAI/AIExport.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIExport.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/AIExport.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -49,4 +49,10 @@
 EXPORT(int) release(int teamId);
 EXPORT(int) handleEvent(int teamId, int topic, const void* data);
 
+// methods from here on are for AI internal use only
+const char* aiexport_getMyInfo(const char* key);
+const char* aiexport_getDataDir();
+const char* aiexport_getVersion();
+const char* aiexport_getMyOption(int teamId, const char* key);
+
 #endif // _AIEXPORT_H

Modified: branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/DLLExportRAI.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,30 +1,30 @@
-#include &quot;RAI.h&quot;
-#include &quot;ExternalAI/aibase.h&quot;
-//#include &lt;set&gt;
-
-/////////////////////////////////////////////////////////////////////////////
-
-std::set&lt;IGlobalAI*&gt; ais;
-
-SHARED_EXPORT int GetGlobalAiVersion()
-{
-	return GLOBAL_AI_INTERFACE_VERSION;
-}
-
-SHARED_EXPORT void GetAiName(char* name)
-{
-	strcpy(name,AI_NAME);
-}
-
-SHARED_EXPORT IGlobalAI* GetNewAI()
-{
-	cRAI* ai=new cRAI;
-	ais.insert(ai);
-	return ai;
-}
-
-SHARED_EXPORT void ReleaseAI(IGlobalAI* i)
-{
-	delete (cRAI*)i;
-	ais.erase(i);
-}
+//#include &quot;RAI.h&quot;
+//#include &quot;ExternalAI/aibase.h&quot;
+////#include &lt;set&gt;
+//
+///////////////////////////////////////////////////////////////////////////////
+//
+//std::set&lt;IGlobalAI*&gt; ais;
+//
+//SHARED_EXPORT int GetGlobalAiVersion()
+//{
+//	return GLOBAL_AI_INTERFACE_VERSION;
+//}
+//
+//SHARED_EXPORT void GetAiName(char* name)
+//{
+//	strcpy(name,AI_NAME);
+//}
+//
+//SHARED_EXPORT IGlobalAI* GetNewAI()
+//{
+//	cRAI* ai=new cRAI;
+//	ais.insert(ai);
+//	return ai;
+//}
+//
+//SHARED_EXPORT void ReleaseAI(IGlobalAI* i)
+//{
+//	delete (cRAI*)i;
+//	ais.erase(i);
+//}

Modified: branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/GResourceMap.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -98,7 +98,7 @@
 				fList[i] = fList[--fSize];
 	}
 
-	resourceFileName = RAIDirectory + &quot;cache/&quot; + string(cb-&gt;GetModName());
+	resourceFileName = cLogFile::GetRAIRootDirectory() + &quot;cache/&quot; + string(cb-&gt;GetModName());
 	resourceFileName.resize(resourceFileName.size()-4);
 	resourceFileName += &quot;-&quot; + string(cb-&gt;GetMapName());
 	resourceFileName.resize(resourceFileName.size()-3);

Modified: branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/GTerrainMap.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -14,7 +14,7 @@
 	const int mapFileVersion = 2;
 	waterIsHarmful = false;
 	string mapFileName = cb-&gt;GetMapName();
-	mapFileName = RAIDirectory + &quot;cache/&quot; + mapFileName.substr(0,int(mapFileName.size())-3) + &quot;res&quot;;
+	mapFileName = cLogFile::GetRAIRootDirectory() + &quot;cache/&quot; + mapFileName.substr(0,int(mapFileName.size())-3) + &quot;res&quot;;
 	FILE *mapFile = fopen(mapFileName.c_str(),&quot;rb&quot;);
 	bool mapFileLoaded = false;
 	if( mapFile )

Modified: branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/LogFile.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -9,7 +9,7 @@
 
 cLogFile::cLogFile(string sFilename, bool bAppend)
 {
-	logFileName=RAIDirectory+sFilename;
+	logFileName = cLogFile::GetRAIRootDirectory() + sFilename;
 	if( bAppend )
 		logFile = fopen(logFileName.c_str(),&quot;a&quot;);
 //		logFile = new ofstream();
@@ -83,3 +83,9 @@
 //	logFile-&gt;flush();
 }
 */
+
+const std::string&amp; cLogFile::GetRAIRootDirectory() {
+
+	static std::string raiRootDirectory = aiexport_getDataDir();
+	return raiRootDirectory;
+}

Modified: branches/caiinterface/AI/Skirmish/RAI/LogFile.h
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/LogFile.h	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/LogFile.h	2008-12-17 11:32:14 UTC (rev 7188)
@@ -8,10 +8,9 @@
 #define RAI_LOGFILE_H
 
 #include &quot;ExternalAI/IAICallback.h&quot;
+#include &quot;AIExport.h&quot;
 using std::string;
 
-const string RAIDirectory = &quot;AI/RAI/&quot;;
-
 class cLogFile
 {
 public:
@@ -21,6 +20,8 @@
 	cLogFile&amp; operator&lt;&lt;(float message);
 	cLogFile&amp; operator&lt;&lt;(string message);
 
+	static const std::string&amp; GetRAIRootDirectory();
+
 private:
 	string logFileName;
 	FILE *logFile;

Modified: branches/caiinterface/AI/Skirmish/RAI/RAI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/RAI.cpp	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/AI/Skirmish/RAI/RAI.cpp	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1083,8 +1083,8 @@
 
 void cRAI::ClearLogFiles()
 {
-	const string dataDirectory = RAIDirectory + &quot;cache/&quot;;
-	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)RAIDirectory.c_str() );
+	const string dataDirectory = cLogFile::GetRAIRootDirectory() + &quot;cache/&quot;;
+	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)cLogFile::GetRAIRootDirectory().c_str() );
 	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)dataDirectory.c_str() );
 
 	string logFileName;
@@ -1092,22 +1092,22 @@
 	{	
 		char c[2];
 		sprintf(c, &quot;%i&quot;,i);
-		logFileName = RAIDirectory+&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;;
+		logFileName = cLogFile::GetRAIRootDirectory()+&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;;
 		remove(logFileName.c_str());
 	}
 
-	logFileName=RAIDirectory+&quot;RAIGlobal_LastGame.log&quot;;
+	logFileName=cLogFile::GetRAIRootDirectory()+&quot;RAIGlobal_LastGame.log&quot;;
 	remove(logFileName.c_str());
-	logFileName=RAIDirectory+&quot;TerrainMapDebug.log&quot;;
+	logFileName=cLogFile::GetRAIRootDirectory()+&quot;TerrainMapDebug.log&quot;;
 	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;PathfinderDebug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;PathfinderDebug.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;PathFinderAPNDebug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;PathFinderAPNDebug.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;PathFinderNPNDebug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;PathFinderNPNDebug.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;Prerequisite.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;Prerequisite.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;Debug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;Debug.log&quot;;
 //	remove(logFileName.c_str());
 }

Modified: branches/caiinterface/CMakeLists.txt
===================================================================
--- branches/caiinterface/CMakeLists.txt	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/CMakeLists.txt	2008-12-17 11:32:14 UTC (rev 7188)
@@ -1,131 +1,133 @@
-### Cmake 2.4 lacks some cross-compiling features and fails on windows
-cmake_minimum_required(VERSION 2.6)
-project(Spring)
-
-LIST(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/rts/build/cmake&quot;)
-
-### Install path (relative to CMAKE_INSTALL_PREFIX)
-set (BINDIR &quot;bin&quot; CACHE STRING &quot;Where to install binaries&quot;)
-set (LIBDIR &quot;lib&quot; CACHE STRING &quot;Where to install libraries&quot;)
-set (DATADIR &quot;share/games/spring&quot; CACHE STRING &quot;Where to install game content&quot;)
-if (UNIX AND NOT MINGW)
-	set (APPLICATIONS_DIR &quot;share/applications&quot; CACHE STRING &quot;Where to install desktop files&quot;)
-	set (PIXMAPS_DIR &quot;share/pixmaps&quot; CACHE STRING &quot;Where to install icons&quot;)
-	set (MIME_DIR &quot;share/mime&quot;CACHE STRING &quot;Where MIME definitions are located&quot;)
-endif (UNIX AND NOT MINGW)
-
-### Usr-definable build options
-SET(SYNCCHECK TRUE CACHE BOOL &quot;Check sync during gameplay (Required for online play!)&quot;)
-if (SYNCCHECK)
-	ADD_DEFINITIONS(-DSYNCCHECK)
-endif (SYNCCHECK)
-
-SET(DIRECT_CONTROL TRUE CACHE BOOL &quot;Allow controling units in first-person-mode&quot;)
-if (DIRECT_CONTROL)
-	ADD_DEFINITIONS(-DDIRECT_CONTROL_ALLOWED)
-endif (DIRECT_CONTROL)
-
-IF (WIN32)
-	SET(NO_AVI FALSE CACHE BOOL &quot;Disable in-game video recording&quot;)
-	if (NO_AVI)
-		ADD_DEFINITIONS(-DNO_AVI)
-	endif (NO_AVI)
-	SET(WINDOWS_CONSOLE FALSE CACHE BOOL &quot;Show a visible cmd.exe with stdout when spring runs&quot;)
-	IF (NOT WINDOWS_CONSOLE)
-		SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -mwindows&quot;)
-	ENDIF (NOT WINDOWS_CONSOLE)
-	SET(PATH_DELIM &quot;;&quot;)
-ELSE (WIN32)
-	ADD_DEFINITIONS(-DNO_AVI)
-	SET(PATH_DELIM &quot;:&quot;)
-ENDIF(WIN32)
-
-SET(SPRING_DATADIR ${CMAKE_INSTALL_PREFIX}/${DATADIR} CACHE STRING &quot;Path to game content (in addition to /etc/spring/datadir)&quot;)
-if (SPRING_DATADIR)
-	ADD_DEFINITIONS(-DSPRING_DATADIR=&quot;${SPRING_DATADIR}&quot;)
-endif (SPRING_DATADIR)
-
-set (CUSTOM_COMPILER_DEFINITIONS &quot;&quot; CACHE STRING &quot;Custom flags can be defined here&quot;)
-if (CUSTOM_COMPILER_DEFINITIONS)
-	ADD_DEFINITIONS(${CUSTOM_COMPILER_DEFINITIONS})
-endif (CUSTOM_COMPILER_DEFINITIONS)
-
-### mingwlibs
-if (MINGW)
-	SET(MINGWLIBS ${CMAKE_SOURCE_DIR}/mingwlibs CACHE PATH &quot;Location of the mingwlibs (you can't build windows executables without them)&quot;)
-	include_directories(${MINGWLIBS}/include ${MINGWLIBS}/include/SDL)
-	LINK_DIRECTORIES(${MINGWLIBS}/lib ${MINGWLIBS}/dll)
-	set (SDL_LIBRARY SDL)
-	set (Boost_REGEX_LIBRARY boost_regex-mt)
-	set (Boost_THREAD_LIBRARY boost_thread-mt)
-	set (DEVIL_ILU_LIBRARY ilu)
-	set (DEVIL_LIBRARIES devil ${DEVIL_ILU_LIBRARY})
-else (MINGW)
-	# AIs need it
-	FIND_PACKAGE(SDL REQUIRED)
-	INCLUDE_DIRECTORIES(${SDL_INCLUDE_DIR})
-
-	FIND_PACKAGE(Boost 1.34.0 COMPONENTS thread regex REQUIRED)
-	INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIR})
-	
-	FIND_PACKAGE(Devil REQUIRED)
-endif (MINGW)
-
-### Compiler flags and defines based on build type
-INCLUDE(TestCXXAcceptsVisibilityFlag)
-set (MARCH_FLAG native CACHE STRING &quot;CPU optimization (use i686 for generic optimization)&quot;)
-if (MARCH_FLAG)
-	set (CMAKE_CXX_FLAGS &quot;-march=${MARCH_FLAG} -msse -mfpmath=sse&quot;)
-endif (MARCH_FLAG)
-
-# intel C compiler fix (does not support these flags: -march -mfpmath -ggdb)
-IF ($ENV{CXX} MATCHES &quot;icpc&quot;)
-	SET(CMAKE_CXX_FLAGS &quot; -axK&quot;)
-	SET(CXX_FLAGS_DEBUG_ADDITIONAL &quot;-g -debug full&quot;)
-ELSE ($ENV{CXX} MATCHES &quot;icpc&quot;)
-	SET(CXX_FLAGS_DEBUG_ADDITIONAL &quot;&quot;)
-ENDIF ($ENV{CXX} MATCHES &quot;icpc&quot;)
-
-SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsingle-precision-constant -frounding-math -fsignaling-nans -mieee-fp -pipe -fno-strict-aliasing ${VISIBILITY_HIDDEN} ${VISIBILITY_INLINES_HIDDEN}&quot;)
-ADD_DEFINITIONS(-DSTREFLOP_SSE) # would break AI compiling, but is undefined in ./AI/CMakeLists.txt
-IF (UNIX)
-	SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot;)
-ENDIF (UNIX)
-SET(CMAKE_CXX_FLAGS_DEBUG   &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
-SET(CMAKE_CXX_FLAGS_DEBUG2  &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
-SET(CMAKE_CXX_FLAGS_DEBUG3  &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
-SET(CMAKE_CXX_FLAGS_RELEASE &quot;-O2 -DNDEBUG -fomit-frame-pointer&quot;)
-SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-g -O2 -DNDEBUG&quot;)
-SET(CMAKE_CXX_FLAGS_PROFILE   &quot;-O2 -pg -Wall -DNDEBUG&quot;)
-if (NOT MINGW)
-	set (PIC_FLAG &quot;-fpic&quot;)
-endif (NOT MINGW)
-
-### Where the other CMakeLists.txt are
-Add_Subdirectory(rts)
-Add_Subdirectory(AI)
-Add_Subdirectory(tools/DedicatedServer)
-Add_Subdirectory(tools/unitsync)
-#Add_Subdirectory(tools/DemoAnalyser)
-#Add_Subdirectory(tools/DemoDumper)
-
-### make the basefiles (aka sdz's)
-if (UNIX OR CMAKE_CROSSCOMPILING OR CMAKE_GENERATOR STREQUAL &quot;MSYS Makefiles&quot;)
-	add_custom_target(gamedata ALL COMMAND sh make_gamedata_arch.sh WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/installer)
-else (UNIX OR CMAKE_CROSSCOMPILING OR CMAKE_GENERATOR STREQUAL &quot;MSYS Makefiles&quot;)
-	add_custom_target(gamedata ALL COMMAND call make_gamedata_arch.bat WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/installer)
-endif(UNIX OR CMAKE_CROSSCOMPILING OR CMAKE_GENERATOR STREQUAL &quot;MSYS Makefiles&quot;)
-
-### install base data files
-install (DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/game/ DESTINATION ${DATADIR} PATTERN &quot;.svn&quot; EXCLUDE)
-
-### Install freedesktop-files, mime-types etc.
-if (UNIX AND NOT MINGW)
-	install (FILES installer/freedesktop/applications/spring.desktop DESTINATION ${APPLICATIONS_DIR})
-	install (FILES installer/freedesktop/mime/spring.xml DESTINATION ${MIME_DIR}/packages)
-	install (FILES installer/freedesktop/pixmaps/spring.png installer/freedesktop/pixmaps/application-x-spring-demo.png DESTINATION ${PIXMAPS_DIR})
-else (UNIX AND NOT MINGW)
-	install (DIRECTORY ${MINGWLIBS}/dll/ DESTINATION ${BINDIR})
-endif (UNIX AND NOT MINGW)
-
-
+### Cmake 2.4 lacks some cross-compiling features and fails on windows
+cmake_minimum_required(VERSION 2.6)
+project(Spring)
+
+LIST(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/rts/build/cmake&quot;)
+
+### Install path (relative to CMAKE_INSTALL_PREFIX)
+set (BINDIR &quot;bin&quot; CACHE STRING &quot;Where to install binaries&quot;)
+set (LIBDIR &quot;lib&quot; CACHE STRING &quot;Where to install libraries&quot;)
+set (DATADIR &quot;share/games/spring&quot; CACHE STRING &quot;Where to install game content&quot;)
+if (UNIX AND NOT MINGW)
+	set (APPLICATIONS_DIR &quot;share/applications&quot; CACHE STRING &quot;Where to install desktop files&quot;)
+	set (PIXMAPS_DIR &quot;share/pixmaps&quot; CACHE STRING &quot;Where to install icons&quot;)
+	set (MIME_DIR &quot;share/mime&quot;CACHE STRING &quot;Where MIME definitions are located&quot;)
+endif (UNIX AND NOT MINGW)
+
+### Usr-definable build options
+SET(SYNCCHECK TRUE CACHE BOOL &quot;Check sync during gameplay (Required for online play!)&quot;)
+if (SYNCCHECK)
+	ADD_DEFINITIONS(-DSYNCCHECK)
+endif (SYNCCHECK)
+
+SET(DIRECT_CONTROL TRUE CACHE BOOL &quot;Allow controling units in first-person-mode&quot;)
+if (DIRECT_CONTROL)
+	ADD_DEFINITIONS(-DDIRECT_CONTROL_ALLOWED)
+endif (DIRECT_CONTROL)
+
+IF (WIN32)
+	SET(NO_AVI FALSE CACHE BOOL &quot;Disable in-game video recording&quot;)
+	if (NO_AVI)
+		ADD_DEFINITIONS(-DNO_AVI)
+	endif (NO_AVI)
+	SET(WINDOWS_CONSOLE FALSE CACHE BOOL &quot;Show a visible cmd.exe with stdout when spring runs&quot;)
+	IF (NOT WINDOWS_CONSOLE)
+		SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -mwindows&quot;)
+	ENDIF (NOT WINDOWS_CONSOLE)
+	SET(PATH_DELIM &quot;;&quot;)
+ELSE (WIN32)
+	ADD_DEFINITIONS(-DNO_AVI)
+	SET(PATH_DELIM &quot;:&quot;)
+ENDIF(WIN32)
+
+SET(SPRING_DATADIR ${CMAKE_INSTALL_PREFIX}/${DATADIR} CACHE STRING &quot;Path to game content (in addition to /etc/spring/datadir)&quot;)
+if (SPRING_DATADIR)
+	ADD_DEFINITIONS(-DSPRING_DATADIR=&quot;${SPRING_DATADIR}&quot;)
+endif (SPRING_DATADIR)
+
+set (CUSTOM_COMPILER_DEFINITIONS &quot;&quot; CACHE STRING &quot;Custom flags can be defined here&quot;)
+if (CUSTOM_COMPILER_DEFINITIONS)
+	ADD_DEFINITIONS(${CUSTOM_COMPILER_DEFINITIONS})
+endif (CUSTOM_COMPILER_DEFINITIONS)
+
+### mingwlibs
+if (MINGW)
+	SET(MINGWLIBS ${CMAKE_SOURCE_DIR}/mingwlibs CACHE PATH &quot;Location of the mingwlibs (you can't build windows executables without them)&quot;)
+	include_directories(${MINGWLIBS}/include ${MINGWLIBS}/include/SDL)
+	LINK_DIRECTORIES(${MINGWLIBS}/lib ${MINGWLIBS}/dll)
+	set (SDL_LIBRARY SDL)
+	set (Boost_REGEX_LIBRARY boost_regex-mt)
+	set (Boost_THREAD_LIBRARY boost_thread-mt)
+	set (DEVIL_ILU_LIBRARY ilu)
+	set (DEVIL_LIBRARIES devil ${DEVIL_ILU_LIBRARY})
+else (MINGW)
+	# AIs need it
+	FIND_PACKAGE(SDL REQUIRED)
+	INCLUDE_DIRECTORIES(${SDL_INCLUDE_DIR})
+
+	FIND_PACKAGE(Boost 1.34.0 COMPONENTS thread regex REQUIRED)
+	INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIR})
+	
+	FIND_PACKAGE(Devil REQUIRED)
+endif (MINGW)
+
+### Compiler flags and defines based on build type
+INCLUDE(TestCXXAcceptsVisibilityFlag)
+set (MARCH_FLAG native CACHE STRING &quot;CPU optimization (use i686 for generic optimization)&quot;)
+if (MARCH_FLAG)
+	set (CMAKE_CXX_FLAGS &quot;-march=${MARCH_FLAG} -msse -mfpmath=sse&quot;)
+endif (MARCH_FLAG)
+
+# intel C compiler fix (does not support these flags: -march -mfpmath -ggdb)
+IF ($ENV{CXX} MATCHES &quot;icpc&quot;)
+	SET(CMAKE_CXX_FLAGS &quot; -axK&quot;)
+	SET(CXX_FLAGS_DEBUG_ADDITIONAL &quot;-g -debug full&quot;)
+ELSE ($ENV{CXX} MATCHES &quot;icpc&quot;)
+	SET(CXX_FLAGS_DEBUG_ADDITIONAL &quot;&quot;)
+ENDIF ($ENV{CXX} MATCHES &quot;icpc&quot;)
+
+SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fsingle-precision-constant -frounding-math -fsignaling-nans -mieee-fp -pipe -fno-strict-aliasing ${VISIBILITY_HIDDEN} ${VISIBILITY_INLINES_HIDDEN}&quot;)
+ADD_DEFINITIONS(-DSTREFLOP_SSE) # would break AI compiling, but is undefined in ./AI/CMakeLists.txt
+IF (UNIX)
+	SET(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread&quot;)
+ENDIF (UNIX)
+
+SET(CMAKE_CXX_FLAGS_DEBUG          &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG2         &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG3         &quot;${CXX_FLAGS_DEBUG_ADDITIONAL} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG -DNO_CATCH_EXCEPTIONS&quot;)
+SET(CMAKE_CXX_FLAGS_RELEASE        &quot;-O2 -DNDEBUG -fomit-frame-pointer&quot;)
+SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-g -O2 -DNDEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_PROFILE        &quot;-O2 -pg -Wall -DNDEBUG&quot;)
+
+if (NOT MINGW)
+	set (PIC_FLAG &quot;-fpic&quot;)
+endif (NOT MINGW)
+
+### Where the other CMakeLists.txt are
+Add_Subdirectory(rts)
+Add_Subdirectory(AI)
+Add_Subdirectory(tools/DedicatedServer)
+Add_Subdirectory(tools/unitsync)
+#Add_Subdirectory(tools/DemoAnalyser)
+#Add_Subdirectory(tools/DemoDumper)
+
+### make the basefiles (aka sdz's)
+if (UNIX OR CMAKE_CROSSCOMPILING OR CMAKE_GENERATOR STREQUAL &quot;MSYS Makefiles&quot;)
+	add_custom_target(gamedata ALL COMMAND sh make_gamedata_arch.sh WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/installer)
+else (UNIX OR CMAKE_CROSSCOMPILING OR CMAKE_GENERATOR STREQUAL &quot;MSYS Makefiles&quot;)
+	add_custom_target(gamedata ALL COMMAND call make_gamedata_arch.bat WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/installer)
+endif(UNIX OR CMAKE_CROSSCOMPILING OR CMAKE_GENERATOR STREQUAL &quot;MSYS Makefiles&quot;)
+
+### install base data files
+install (DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/game/ DESTINATION ${DATADIR} PATTERN &quot;.svn&quot; EXCLUDE)
+
+### Install freedesktop-files, mime-types etc.
+if (UNIX AND NOT MINGW)
+	install (FILES installer/freedesktop/applications/spring.desktop DESTINATION ${APPLICATIONS_DIR})
+	install (FILES installer/freedesktop/mime/spring.xml DESTINATION ${MIME_DIR}/packages)
+	install (FILES installer/freedesktop/pixmaps/spring.png installer/freedesktop/pixmaps/application-x-spring-demo.png DESTINATION ${PIXMAPS_DIR})
+else (UNIX AND NOT MINGW)
+	install (DIRECTORY ${MINGWLIBS}/dll/ DESTINATION ${BINDIR})
+endif (UNIX AND NOT MINGW)
+
+

Modified: branches/caiinterface/SConstruct
===================================================================
--- branches/caiinterface/SConstruct	2008-12-15 22:32:40 UTC (rev 7187)
+++ branches/caiinterface/SConstruct	2008-12-17 11:32:14 UTC (rev 7188)
@@ -356,7 +356,13 @@
 skirmishaiobjs_LegacyCppCregged = create_shared_objects(skirmishaienv, filelist.get_shared_skirmishAI_source_LegacyCpp(skirmishaienv), '-skirmishai_creg', ['USING_CREG'])
 
 # Build
-skirmishai_exclude_list=['NTai', 'build', 'CSAI', 'TestABICAI', 'AbicWrappersTestAI']
+skirmishai_exclude_list=['build', 'CSAI', 'TestABICAI', 'AbicWrappersTestAI']
+# for some strange reason, NTai has a compile error
+# when compiling with MinGW on windows, because of
+# a class in the Legacy C++ wrapper, which is used
+# by all other legacy C++ AIs aswell
+if sys.platform == 'win32':
+	skirmishai_exclude_list += ['NTai']
 skirmishai_isLegacyCpp_list=['AAI', 'KAIK', 'RAI', 'NullLegacyCppAI', 'KAI', 'NTai']
 skirmishai_needCreg_list=['KAIK', 'KAI']
 skirmishai_isJava_list=['NullJavaAI', 'NullOOJavaAI']


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001956.html">[Taspring-linux-commit] r7187 - trunk/rts/Sim/Units/COB
</A></li>
	<LI>Next message: <A HREF="001958.html">[Taspring-linux-commit] r7189 - in branches/caiinterface:	Documentation rts/ExternalAI rts/Game rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/Units/COB rts/System	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/build/vstudio8 rts/lib/gml	tools/unitsync
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1957">[ date ]</a>
              <a href="thread.html#1957">[ thread ]</a>
              <a href="subject.html#1957">[ subject ]</a>
              <a href="author.html#1957">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
