<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7141 - in branches/caiinterface: .	AI/Interfaces/C AI/Interfaces/Java AI/Skirmish/NullJavaAI/nulljavaai	AI/Skirmish/NullOOJavaAI/nulloojavaai rts/ExternalAI	rts/ExternalAI/Interface rts/System rts/build/scons tools/unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7141%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Interfaces/C%20AI/Interfaces/Java%20AI/Skirmish/NullJavaAI/nulljavaai%0A%09AI/Skirmish/NullOOJavaAI/nulloojavaai%20rts/ExternalAI%0A%09rts/ExternalAI/Interface%20rts/System%20rts/build/scons%20tools/unitsync&In-Reply-To=%3C20081206161623.DE2C2478C%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001909.html">
   <LINK REL="Next"  HREF="001911.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7141 - in branches/caiinterface: .	AI/Interfaces/C AI/Interfaces/Java AI/Skirmish/NullJavaAI/nulljavaai	AI/Skirmish/NullOOJavaAI/nulloojavaai rts/ExternalAI	rts/ExternalAI/Interface rts/System rts/build/scons tools/unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7141%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Interfaces/C%20AI/Interfaces/Java%20AI/Skirmish/NullJavaAI/nulljavaai%0A%09AI/Skirmish/NullOOJavaAI/nulloojavaai%20rts/ExternalAI%0A%09rts/ExternalAI/Interface%20rts/System%20rts/build/scons%20tools/unitsync&In-Reply-To=%3C20081206161623.DE2C2478C%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7141 - in branches/caiinterface: .	AI/Interfaces/C AI/Interfaces/Java AI/Skirmish/NullJavaAI/nulljavaai	AI/Skirmish/NullOOJavaAI/nulloojavaai rts/ExternalAI	rts/ExternalAI/Interface rts/System rts/build/scons tools/unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Dec  6 17:16:23 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001909.html">[Taspring-linux-commit] r7140 - in Lobby/springie/Springie: .	PlanetWars
</A></li>
        <LI>Next message: <A HREF="001911.html">[Taspring-linux-commit] r7142 - Lobby/springie/Springie/PlanetWars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1910">[ date ]</a>
              <a href="thread.html#1910">[ thread ]</a>
              <a href="subject.html#1910">[ subject ]</a>
              <a href="author.html#1910">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-06 17:16:22 +0100 (Sat, 06 Dec 2008)
New Revision: 7141

Added:
   branches/caiinterface/rts/System/Info.cpp
   branches/caiinterface/rts/System/Info.h
   branches/caiinterface/rts/System/Option.cpp
   branches/caiinterface/rts/System/Option.h
Removed:
   branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SInfo.h
   branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SOption.h
Modified:
   branches/caiinterface/AI/Interfaces/C/Interface.cpp
   branches/caiinterface/AI/Interfaces/C/Interface.h
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
   branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
   branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
   branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h
   branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c
   branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
   branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
   branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java
   branches/caiinterface/SConstruct
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
   branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
   branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
   branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
   branches/caiinterface/rts/System/LogOutput.cpp
   branches/caiinterface/rts/System/LogOutput.h
   branches/caiinterface/rts/build/scons/filelist.py
   branches/caiinterface/tools/unitsync/CMakeLists.txt
   branches/caiinterface/tools/unitsync/unitsync.cpp
Log:
* Info and Options are now C++ again (in preparation for reintegration into trunk)
* removed some outcommented code

Modified: branches/caiinterface/AI/Interfaces/C/Interface.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/C/Interface.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -41,12 +41,6 @@
 
 #define MAX_INFOS 128
 
-/*
-std::string CInterface::relSkirmishAIImplsDir =
-		std::string(SKIRMISH_AI_IMPLS_DIR) + PS;
-std::string CInterface::relGroupAIImplsDir =
-		std::string(GROUP_AI_IMPLS_DIR) + PS;
-*/
 static std::string local_getValueByKey(
 		const std::map&lt;std::string, std::string&gt;&amp; map, std::string key) {
 
@@ -95,28 +89,6 @@
 	simpleLog_log(&quot;Using log file: %s&quot;, logFileName.c_str());
 }
 
-//unsigned int CInterface::GetInfo(InfoItem info[], unsigned int maxInfoItems) {
-//
-//	unsigned int i = 0;
-//
-//	if (myInfo.empty()) {
-//		InfoItem ii_0 = {AI_INTERFACE_PROPERTY_SHORT_NAME, MY_SHORT_NAME, NULL}; myInfo.push_back(ii_0);
-//		InfoItem ii_1 = {AI_INTERFACE_PROPERTY_VERSION, MY_VERSION, NULL}; myInfo.push_back(ii_1);
-//		InfoItem ii_2 = {AI_INTERFACE_PROPERTY_NAME, MY_NAME, NULL}; myInfo.push_back(ii_2);
-//		InfoItem ii_3 = {AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in C or C++. It is neded for legacy C++ AIs as well.&quot;, NULL}; myInfo.push_back(ii_3);
-//		InfoItem ii_4 = {AI_INTERFACE_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AIInterface:C">http://spring.clan-sy.com/wiki/AIInterface:C</A>&quot;, NULL}; myInfo.push_back(ii_4);
-//		InfoItem ii_5 = {AI_INTERFACE_PROPERTY_SUPPORTED_LANGUAGES, &quot;C, C++&quot;, NULL}; myInfo.push_back(ii_5);
-//	}
-//
-//	std::vector&lt;InfoItem&gt;::const_iterator inf;
-//	for (inf=myInfo.begin(); inf!=myInfo.end() &amp;&amp; i &lt; maxInfoItems; inf++) {
-//		info[i] = *inf;
-//		i++;
-//	}
-//
-//	return i;
-//}
-
 LevelOfSupport CInterface::GetLevelOfSupportFor(
 		const char* engineVersion, int engineAIInterfaceGeneratedVersion) {
 	return LOS_Working;
@@ -132,16 +104,6 @@
 
 	return spec;
 }
-//SGAISpecifier extractSGAISpecifier(
-//		const std::map&lt;std::string, InfoItem&gt;&amp; infoMap) {
-//
-//	const char* sn = infoMap.find(GROUP_AI_PROPERTY_SHORT_NAME)-&gt;second.value;
-//	const char* v = infoMap.find(GROUP_AI_PROPERTY_VERSION)-&gt;second.value;
-//
-//	SGAISpecifier specifier = {sn, v};
-//
-//	return specifier;
-//}
 
 const SSAILibrary* CInterface::LoadSkirmishAILibrary(
 		const std::map&lt;std::string, std::string&gt;&amp; infoMap) {
@@ -197,56 +159,6 @@
 }
 
 
-
-//const SGAILibrary* CInterface::LoadGroupAILibrary(const struct InfoItem info[],
-//		unsigned int numInfoItems) {
-//
-//	SGAILibrary* ai = NULL;
-//
-//	std::map&lt;std::string, InfoItem&gt; infoMap;
-//	copyToInfoMap(infoMap, info, numInfoItems);
-//	SGAISpecifier gAISpecifier = extractSGAISpecifier(infoMap);
-//	myGroupAISpecifiers.push_back(gAISpecifier);
-//	myGroupAIInfos[gAISpecifier] = infoMap;
-//
-//	T_groupAIs::iterator groupAI;
-//	groupAI = myLoadedGroupAIs.find(gAISpecifier);
-//	if (groupAI == myLoadedGroupAIs.end()) {
-//		ai = new SGAILibrary;
-//		SharedLib* lib = Load(&amp;gAISpecifier, ai);
-//		myLoadedGroupAIs[gAISpecifier] = ai;
-//		myLoadedGroupAILibs[gAISpecifier] = lib;
-//	} else {
-//		ai = groupAI-&gt;second;
-//	}
-//
-//	return ai;
-//}
-//int CInterface::UnloadGroupAILibrary(const SGAISpecifier* const gAISpecifier) {
-//
-//	T_groupAIs::iterator groupAI = myLoadedGroupAIs.find(*gAISpecifier);
-//	T_groupAILibs::iterator groupAILib =
-//			myLoadedGroupAILibs.find(*gAISpecifier);
-//	if (groupAI == myLoadedGroupAIs.end()) {
-//		// to unload AI is not loaded -&gt; no problem, do nothing
-//	} else {
-//		delete groupAI-&gt;second;
-//		myLoadedGroupAIs.erase(groupAI);
-//		delete groupAILib-&gt;second;
-//		myLoadedGroupAILibs.erase(groupAILib);
-//	}
-//
-//	return 0;
-//}
-//int CInterface::UnloadAllGroupAILibraries() {
-//
-//	while (myLoadedGroupAIs.size() &gt; 0) {
-//		UnloadGroupAILibrary(&amp;(myLoadedGroupAIs.begin()-&gt;first));
-//	}
-//
-//	return 0;
-//}
-
 // private functions following
 
 SharedLib* CInterface::Load(const SSkirmishAISpecifier&amp; spec, SSAILibrary* skirmishAILibrary) {
@@ -264,26 +176,6 @@
 	// initialize the AI library
 	std::string funcName;
 
-/*
-	funcName = &quot;getInfo&quot;;
-	skirmishAILibrary-&gt;getInfo = (unsigned int (CALLING_CONV_FUNC_POINTER *)(int teamId, struct InfoItem[], unsigned int)) sharedLib-&gt;FindAddress(funcName.c_str());
-	if (skirmishAILibrary-&gt;getInfo == NULL) {
-		// do nothing: this is permitted, if the AI supplies info through an AIInfo.lua file
-		//reportInterfaceFunctionError(libFilePath, funcName);
-	}
-*/
-//	skirmishAILibrary-&gt;getInfo = NULL;
-
-/*
-	funcName = &quot;getOptions&quot;;
-	skirmishAILibrary-&gt;getOptions = (unsigned int (CALLING_CONV_FUNC_POINTER *)(int teamId, Option[], unsigned int max)) sharedLib-&gt;FindAddress(funcName.c_str());
-	if (skirmishAILibrary-&gt;getOptions == NULL) {
-		// do nothing: this is permitted, if the AI supplies options through an AIOptions.lua file
-		//reportInterfaceFunctionError(libFilePath, funcName);
-	}
-*/
-//	skirmishAILibrary-&gt;getOptions = NULL;
-
 	funcName = &quot;getLevelOfSupportFor&quot;;
 	skirmishAILibrary-&gt;getLevelOfSupportFor
 			= (LevelOfSupport (CALLING_CONV_FUNC_POINTER *)(int teamId,
@@ -331,75 +223,6 @@
 }
 
 
-//SharedLib* CInterface::Load(const SGAISpecifier* const gAISpecifier,
-//		SGAILibrary* groupAILibrary) {
-//	return LoadGroupAILib(FindLibFile(*gAISpecifier), groupAILibrary);
-//}
-//SharedLib* CInterface::LoadGroupAILib(const std::string&amp; libFilePath,
-//		SGAILibrary* groupAILibrary) {
-//
-//	SharedLib* sharedLib = SharedLib::Instantiate(libFilePath);
-//
-//	if (sharedLib == NULL) {
-//		reportError(std::string(&quot;Failed loading shared library: &quot;) + libFilePath);
-//	}
-//
-//	// initialize the AI library
-//	std::string funcName;
-//
-///*
-//	funcName = &quot;getInfo&quot;;
-//	groupAILibrary-&gt;getInfo = (unsigned int (CALLING_CONV_FUNC_POINTER *)(InfoItem[], unsigned int max)) sharedLib-&gt;FindAddress(funcName.c_str());
-//	if (groupAILibrary-&gt;getInfo == NULL) {
-//		// do nothing: this is permitted, if the AI supplies info through an AIInfo.lua file
-//		//reportInterfaceFunctionError(libFilePath, funcName);
-//	}
-//*/
-//	groupAILibrary-&gt;getInfo = NULL;
-//
-///*
-//	funcName = &quot;getOptions&quot;;
-//	groupAILibrary-&gt;getOptions = (unsigned int (CALLING_CONV_FUNC_POINTER *)(Option[], unsigned int max)) sharedLib-&gt;FindAddress(funcName.c_str());
-//	if (groupAILibrary-&gt;getOptions == NULL) {
-//		// do nothing: this is permitted, if the AI supplies options through an AIOptions.lua file
-//		//reportInterfaceFunctionError(libFilePath, funcName);
-//	}
-//*/
-//	groupAILibrary-&gt;getOptions = NULL;
-//
-//	funcName = &quot;getLevelOfSupportFor&quot;;
-//	groupAILibrary-&gt;getLevelOfSupportFor = (LevelOfSupport (CALLING_CONV_FUNC_POINTER *)(int teamId, int groupId, const char*, int, const char*, const char*)) sharedLib-&gt;FindAddress(funcName.c_str());
-//	if (groupAILibrary-&gt;getLevelOfSupportFor == NULL) {
-//		// do nothing: it is permitted that an AI does not export this function
-//		//reportInterfaceFunctionError(libFilePath, funcName);
-//	}
-//
-//	funcName = &quot;init&quot;;
-//	groupAILibrary-&gt;init = (int (CALLING_CONV_FUNC_POINTER *)(int teamId, int groupId, const struct InfoItem info[], unsigned int maxInfoItems)) sharedLib-&gt;FindAddress(funcName.c_str());
-//	if (groupAILibrary-&gt;init == NULL) {
-//		// do nothing: it is permitted that an AI does not export this function,
-//		// as it can still use EVENT_INIT instead
-//		//reportInterfaceFunctionError(libFilePath, funcName);
-//	}
-//
-//	funcName = &quot;release&quot;;
-//	groupAILibrary-&gt;release = (int (CALLING_CONV_FUNC_POINTER *)(int teamId, int groupId)) sharedLib-&gt;FindAddress(funcName.c_str());
-//	if (groupAILibrary-&gt;release == NULL) {
-//		// do nothing: it is permitted that an AI does not export this function,
-//		// as it can still use EVENT_RELEASE instead
-//		//reportInterfaceFunctionError(libFilePath, funcName);
-//	}
-//
-//	funcName = &quot;handleEvent&quot;;
-//	groupAILibrary-&gt;handleEvent = (int (CALLING_CONV_FUNC_POINTER *)(int teamId, int groupId, int topic, const void* data)) sharedLib-&gt;FindAddress(funcName.c_str());
-//	if (groupAILibrary-&gt;handleEvent == NULL) {
-//		reportInterfaceFunctionError(libFilePath, funcName);
-//	}
-//
-//	return sharedLib;
-//}
-
-
 void CInterface::reportInterfaceFunctionError(const std::string&amp; libFilePath,
 		const std::string&amp; functionName) {
 
@@ -452,43 +275,6 @@
 	return dataDir + PS + libFileName;
 }
 
-//std::string CInterface::FindLibFile(const SGAISpecifier&amp; gAISpecifier) {
-//
-//	// fetch the data-dir and file-name from the info about the AI to load,
-//	// which was supplied to us by the engine
-//	T_groupAIInfos::const_iterator info = myGroupAIInfos.find(gAISpecifier);
-//	if (info == myGroupAIInfos.end()) {
-//		reportError(std::string(&quot;Missing Group-AI info for &quot;)
-//				+ gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
-//	}
-//
-//	std::map&lt;std::string, InfoItem&gt;::const_iterator prop =
-//			info-&gt;second.find(GROUP_AI_PROPERTY_DATA_DIR);
-//	if (prop == info-&gt;second.end()) {
-//		reportError(std::string(&quot;Missing Group-AI data dir for &quot;)
-//				+ gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
-//	}
-//	const std::string&amp; dataDir(prop-&gt;second.value);
-//
-//	prop = info-&gt;second.find(GROUP_AI_PROPERTY_FILE_NAME);
-//	if (prop == info-&gt;second.end()) {
-//		reportError(std::string(&quot;Missing Group-AI file name for &quot;)
-//				+ gAISpecifier.shortName + &quot; &quot; + gAISpecifier.version);
-//	}
-//	const std::string&amp; fileName(prop-&gt;second.value);
-//
-//	std::string libFileName(fileName); // eg. MetalMaker-1.0
-//	#ifndef _WIN32
-//		libFileName = &quot;lib&quot; + libFileName; // eg. libMetalMaker-1.0
-//	#endif
-//
-//	// eg. libMetalMaker-1.0.so
-//	libFileName = libFileName + &quot;.&quot; + SharedLib::GetLibExtension();
-//
-//	//return FindFile(dataDir + PS + libFileName);
-//	return dataDir + PS + libFileName;
-//}
-
 bool CInterface::FileExists(const std::string&amp; filePath) {
 
 	struct stat fileInfo;
@@ -594,52 +380,6 @@
 	return path;
 }
 
-/*
-SSAISpecifier CInterface::ExtractSpecifier(const SSAILibrary&amp; skirmishAILib) {
-
-	SSAISpecifier skirmishAISpecifier;
-
-	InfoItem info[MAX_INFOS];
-	int numInfo =  skirmishAILib.getInfo(info, MAX_INFOS);
-
-	std::string spsn = std::string(SKIRMISH_AI_PROPERTY_SHORT_NAME);
-	std::string spv = std::string(SKIRMISH_AI_PROPERTY_VERSION);
-	for (int i=0; i &lt; numInfo; ++i) {
-		std::string key = std::string(info[i].key);
-		if (key == spsn) {
-			skirmishAISpecifier.shortName = info[i].value;
-		} else if (key == spv) {
-			skirmishAISpecifier.version = info[i].value;
-		}
-	}
-
-	return skirmishAISpecifier;
-}
-*/
-
-/*
-SGAISpecifier CInterface::ExtractSpecifier(const SGAILibrary&amp; groupAILib) {
-
-	SGAISpecifier groupAISpecifier;
-
-	InfoItem info[MAX_INFOS];
-	int numInfo =  groupAILib.getInfo(info, MAX_INFOS);
-
-	std::string spsn = std::string(GROUP_AI_PROPERTY_SHORT_NAME);
-	std::string spv = std::string(GROUP_AI_PROPERTY_VERSION);
-	for (int i=0; i &lt; numInfo; ++i) {
-		std::string key = std::string(info[i].key);
-		if (key == spsn) {
-			groupAISpecifier.shortName = info[i].value;
-		} else if (key == spv) {
-			groupAISpecifier.version = info[i].value;
-		}
-	}
-
-	return groupAISpecifier;
-}
-*/
-
 bool CInterface::FitsThisInterface(const std::string&amp; requestedShortName,
 		const std::string&amp; requestedVersion) {
 

Modified: branches/caiinterface/AI/Interfaces/C/Interface.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/Interface.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/C/Interface.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -20,7 +20,6 @@
 
 #include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
 #include &quot;ExternalAI/Interface/SSkirmishAISpecifier.h&quot;
-//#include &quot;ExternalAI/Interface/SGAILibrary.h&quot;
 
 #include &lt;map&gt;
 #include &lt;set&gt;
@@ -40,7 +39,6 @@
 			const SStaticGlobalData* staticGlobalData);
 
 	// static properties
-//	unsigned int GetInfo(InfoItem info[], unsigned int maxInfoItems);
 	LevelOfSupport GetLevelOfSupportFor(
 			const char* engineVersion, int engineAIInterfaceGeneratedVersion);
 
@@ -51,12 +49,6 @@
 			const std::map&lt;std::string, std::string&gt;&amp; infoMap);
 	int UnloadAllSkirmishAILibraries();
 
-//	// group AI methods
-//	const SGAILibrary* LoadGroupAILibrary(const struct InfoItem info[],
-//			unsigned int numInfoItems);
-//	int UnloadGroupAILibrary(const SGAISpecifier* const gAISpecifier);
-//	int UnloadAllGroupAILibraries();
-
 private:
 	static SSkirmishAISpecifier ExtractSpecifier(
 		const std::map&lt;std::string, std::string&gt;&amp; infoMap);
@@ -65,14 +57,10 @@
 	SharedLib* LoadSkirmishAILib(const std::string&amp; libFilePath,
 			SSAILibrary* ai);
 
-//	SharedLib* Load(const SGAISpecifier* const gAISpecifier, SGAILibrary* ai);
-//	SharedLib* LoadGroupAILib(const std::string&amp; libFilePath, SGAILibrary* ai);
-
 	static void reportInterfaceFunctionError(const std::string&amp; libFileName,
 			const std::string&amp; functionName);
 	static void reportError(const std::string&amp; msg);
 	std::string FindLibFile(const SSkirmishAISpecifier&amp; sAISpecifier);
-//	std::string FindLibFile(const SGAISpecifier&amp; gAISpecifier);
 	/**
 	 * Searches for a file in all data-dirs.
 	 * If not found, the input param relativeFilePath is returned.
@@ -100,14 +88,10 @@
 	 * @return	true if the directory was created or already existed
 	 */
 	static bool MakeDirRecursive(const std::string&amp; dirPath);
-//	static SSAISpecifier ExtractSpecifier(const SSAILibrary&amp; skirmishAILib);
-//	static SGAISpecifier ExtractSpecifier(const SGAILibrary&amp; groupAILib);
 
 	bool FitsThisInterface(const std::string&amp; requestedShortName,
 			const std::string&amp; requestedVersion);
 private:
-//	static std::string relSkirmishAIImplsDir;
-//	static std::string relGroupAIImplsDir;
 	const std::map&lt;std::string, std::string&gt; myInfo;
 	const SStaticGlobalData* staticGlobalData;
 
@@ -122,15 +106,7 @@
 	 * should go in here.
 	 */
 	std::string myDataDirVers;
-	//const SStaticGlobalData* staticGlobalData;
-	//std::string skirmishAIsLibDir;
-	//std::string groupAIsLibDir;
-//	std::vector&lt;InfoItem&gt; myInfo;
 
-//	std::vector&lt;SSAISpecifier&gt; mySkirmishAISpecifiers;
-//	typedef std::map&lt;SSAISpecifier, std::map&lt;std::string, std::string&gt;,SSAISpecifier_Comparator&gt; T_skirmishAIInfos;
-//	typedef std::map&lt;SSAISpecifier, SSAILibrary*, SSAISpecifier_Comparator&gt; T_skirmishAIs;
-//	typedef std::map&lt;SSAISpecifier, SharedLib*, SSAISpecifier_Comparator&gt; T_skirmishAILibs;
 	std::set&lt;SSkirmishAISpecifier, SSkirmishAISpecifier_Comparator&gt; mySkirmishAISpecifiers;
 	typedef std::map&lt;const SSkirmishAISpecifier, std::map&lt;std::string, std::string&gt;, SSkirmishAISpecifier_Comparator&gt; T_skirmishAIInfos;
 	typedef std::map&lt;const SSkirmishAISpecifier, SSAILibrary*, SSkirmishAISpecifier_Comparator&gt; T_skirmishAIs;
@@ -138,14 +114,6 @@
 	T_skirmishAIInfos mySkirmishAIInfos;
 	T_skirmishAIs myLoadedSkirmishAIs;
 	T_skirmishAILibs myLoadedSkirmishAILibs;
-
-//	std::vector&lt;SGAISpecifier&gt; myGroupAISpecifiers;
-//	typedef std::map&lt;SGAISpecifier, std::map&lt;std::string, InfoItem&gt;, SGAISpecifier_Comparator&gt; T_groupAIInfos;
-//	T_groupAIInfos myGroupAIInfos;
-//	typedef std::map&lt;SGAISpecifier, SGAILibrary*, SGAISpecifier_Comparator&gt; T_groupAIs;
-//	T_groupAIs myLoadedGroupAIs;
-//	typedef std::map&lt;SGAISpecifier, SharedLib*, SGAISpecifier_Comparator&gt; T_groupAILibs;
-//	T_groupAILibs myLoadedGroupAILibs;
 };
 
 #endif // _INTERFACE_H

Modified: branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -57,20 +57,6 @@
 	return myInterface-&gt;GetLevelOfSupportFor(engineVersion, engineAIInterfaceGeneratedVersion);
 }
 
-//EXPORT(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems) {
-//	return myInterface-&gt;GetInfo(info, maxInfoItems);
-//}
-
-
-// skirmish AI methods
-/*
-EXPORT(int) getSkirmishAISpecifiers(struct SSAISpecifier* sAISpecifiers, int max) {
-	return myInterface-&gt;GetSkirmishAISpecifiers(sAISpecifiers, max);
-}
-EXPORT(const struct SSAILibrary*) loadSkirmishAILibrary(const struct SSAISpecifier* const sAISpecifier) {
-	return myInterface-&gt;LoadSkirmishAILibrary(sAISpecifier);
-}
-*/
 EXPORT(const struct SSAILibrary*) loadSkirmishAILibrary(
 		unsigned int infoSize,
 		const char** infoKeys, const char** infoValues) {
@@ -92,25 +78,3 @@
 EXPORT(int) unloadAllSkirmishAILibraries() {
 	return myInterface-&gt;UnloadAllSkirmishAILibraries();
 }
-
-
-
-//// group AI methods
-///*
-//EXPORT(int) getGroupAISpecifiers(struct SGAISpecifier* gAISpecifiers, int max) {
-//	return myInterface-&gt;GetGroupAISpecifiers(gAISpecifiers, max);
-//}
-//EXPORT(const struct SGAILibrary*) loadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier) {
-//	return myInterface-&gt;LoadGroupAILibrary(gAISpecifier);
-//}
-//*/
-//EXPORT(const struct SGAILibrary*) loadGroupAILibrary(
-//		const struct InfoItem info[], unsigned int numInfoItems) {
-//	return myInterface-&gt;LoadGroupAILibrary(info, numInfoItems);
-//}
-//EXPORT(int) unloadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier) {
-//	return myInterface-&gt;UnloadGroupAILibrary(gAISpecifier);
-//}
-//EXPORT(int) unloadAllGroupAILibraries() {
-//	return myInterface-&gt;UnloadAllGroupAILibraries();
-//}

Modified: branches/caiinterface/AI/Interfaces/C/InterfaceExport.h
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceExport.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceExport.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -30,16 +30,13 @@
 
 #include &quot;ExternalAI/Interface/aidefines.h&quot;
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
 
 #include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
-//struct InfoItem;
-//struct SSAISpecifier;
+
 struct SSAILibrary;
-//struct SGAISpecifier;
-//struct SGAILibrary;
 struct SStaticGlobalData;
 
 // for a list of the functions that have to be exported,
@@ -70,19 +67,7 @@
 		const char** infoKeys, const char** infoValues);
 EXPORT(int) unloadAllSkirmishAILibraries();
 
-
-//// group AI related methods
-//
-////EXPORT(int) getGroupAISpecifiers(struct SGAISpecifier* gAISpecifiers, int max);
-////EXPORT(const struct SGAILibrary*) loadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier);
-//EXPORT(const struct SGAILibrary*) loadGroupAILibrary(
-//		const struct InfoItem info[], unsigned int numInfoItems);
-//EXPORT(int) unloadGroupAILibrary(
-//		const struct SGAISpecifier* const gAISpecifier);
-//EXPORT(int) unloadAllGroupAILibraries();
-
-
-#ifdef	__cplusplus
+#ifdef __cplusplus
 }
 #endif
 

Modified: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c	2008-12-06 16:16:22 UTC (rev 7141)
@@ -29,17 +29,7 @@
 #include &lt;string.h&gt;	// strlen(), strcat(), strcpy()
 #include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
 
-// static -&gt; file local vars
-//static struct InfoItem* myInfo = NULL;
-/*
-static struct InfoItem myInfo[16];
-static unsigned int myNumInfoItems = 0;
-*/
 static const struct SStaticGlobalData* staticGlobalData = NULL;
-/*
-static const char* myDataDir = NULL;
-static const char* myDataDirVers = NULL;
-*/
 
 EXPORT(int) initStatic(
 		unsigned int infoSize,
@@ -135,30 +125,6 @@
 	return LOS_Unknown;
 }
 
-/*
-EXPORT(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems) {
-
-	if (myNumInfoItems == 0) {
-		//myInfo = (struct InfoItem*) calloc(10, sizeof(struct InfoItem));
-		struct InfoItem ii_0 = {AI_INTERFACE_PROPERTY_SHORT_NAME, MY_SHORT_NAME, NULL}; myInfo[myNumInfoItems++] = ii_0;
-		struct InfoItem ii_1 = {AI_INTERFACE_PROPERTY_VERSION, MY_VERSION, NULL}; myInfo[myNumInfoItems++] = ii_1;
-		struct InfoItem ii_2 = {AI_INTERFACE_PROPERTY_NAME, MY_NAME, NULL}; myInfo[myNumInfoItems++] = ii_2;
-		struct InfoItem ii_3 = {AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in Java (Groovy, JRuby, ...).&quot;, NULL}; myInfo[myNumInfoItems++] = ii_3;
-		struct InfoItem ii_4 = {AI_INTERFACE_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AIInterface:Java">http://spring.clan-sy.com/wiki/AIInterface:Java</A>&quot;, NULL}; myInfo[myNumInfoItems++] = ii_4;
-		struct InfoItem ii_5 = {AI_INTERFACE_PROPERTY_SUPPORTED_LANGUAGES, &quot;Java (Groovy, JRuby, ...)&quot;, NULL}; myInfo[myNumInfoItems++] = ii_5;
-	}
-
-	maxInfoItems = maxInfoItems &gt; myNumInfoItems ? myNumInfoItems : maxInfoItems;
-	unsigned int i;
-	for (i = 0; i &lt; maxInfoItems; ++i) {
-		info[i] = myInfo[i];
-	}
-
-	// return the number of elements copied to info
-	return i;
-}
-*/
-
 // skirmish AI methods
 static struct SSAILibrary* mySSAILibrary = NULL;
 
@@ -171,18 +137,6 @@
 
 }
 
-/*
-unsigned int CALLING_CONV proxy_skirmishAI_getInfo(int teamId,
-		struct InfoItem info[], unsigned int maxInfoItems) {
-
-}
-
-unsigned int CALLING_CONV proxy_skirmishAI_getOptions(int teamId,
-		struct Option options[], unsigned int maxOptions) {
-
-}
-*/
-
 int CALLING_CONV proxy_skirmishAI_init(int teamId,
 		unsigned int infoSize,
 		const char** infoKeys, const char** infoValues,
@@ -260,30 +214,3 @@
 EXPORT(int) unloadAllSkirmishAILibraries() {
 	return java_releaseAllSkirmishAIClasses() ? 0 : -1;
 }
-
-
-
-
-
-
-
-// group AI methods
-
-/*
-EXPORT(const struct SGAILibrary*) loadGroupAILibrary(
-		const struct InfoItem info[], unsigned int numInfoItems) {
-
-	//loadLibOnlyIfNotYetLoaded();
-	return NULL;
-}
-EXPORT(int) unloadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier) {
-
-	//unloadLibIfLoaded();
-	return -1;
-}
-EXPORT(int) unloadAllGroupAILibraries() {
-
-	//unloadAllLibsIfLoaded();
-	return -1;
-}
-*/

Modified: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -30,7 +30,7 @@
 
 #include &quot;ExternalAI/Interface/aidefines.h&quot;
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
 
@@ -38,8 +38,6 @@
 
 struct SSAISpecifier;
 struct SSAILibrary;
-//struct SGAISpecifier;
-//struct SGAILibrary;
 struct SStaticGlobalData;
 
 // for a list of the functions that have to be exported,
@@ -69,17 +67,8 @@
 EXPORT(int) unloadAllSkirmishAILibraries();
 
 
-// group AI related methods
-
-//EXPORT(const struct SGAILibrary*) loadGroupAILibrary(
-//		const struct InfoItem info[], unsigned int numInfoItems);
-//EXPORT(int) unloadGroupAILibrary(
-//		const struct SGAISpecifier* const gAISpecifier);
-//EXPORT(int) unloadAllGroupAILibraries();
-
-
-#ifdef	__cplusplus
+#ifdef __cplusplus
 }
 #endif
 
-#endif	// _INTERFACEEXPORT_H
+#endif // _INTERFACEEXPORT_H

Modified: branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c	2008-12-06 16:16:22 UTC (rev 7141)
@@ -420,33 +420,6 @@
 	return found;
 }
 
-/*
-bool fitsThisInterface(const char* reqShortName, const char* reqVersion) {
-	
-	bool shortNameFits = false;
-	bool versionFits = false;
-	
-	InfoItem info[MAX_INFOS];
-	int num = GetInfo(info, MAX_INFOS);
-	
-	std::string shortNameKey(AI_INTERFACE_PROPERTY_SHORT_NAME);
-	std::string versionKey(AI_INTERFACE_PROPERTY_VERSION);
-	for (int i=0; i &lt; num; ++i) {
-		if (shortNameKey == info[i].key) {
-			if (requestedShortName == info[i].value) {
-				shortNameFits = true;
-			}
-		} else if (versionKey == info[i].key) {
-			if (requestedVersion == info[i].value) {
-				versionFits = true;
-			}
-		}
-	}
-	
-	return shortNameFits &amp;&amp; versionFits;
-}
-*/
-
 const char* util_map_getValueByKey(
 		unsigned int infoSize,
 		const char** infoKeys, const char** infoValues,

Modified: branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/JavaBridge.c	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/Java/JavaBridge.c	2008-12-06 16:16:22 UTC (rev 7141)
@@ -29,9 +29,7 @@
 #include &quot;ExternalAI/Interface/SAICallback.h&quot;
 #include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
 #include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
-//#include &quot;ExternalAI/Interface/SGAILibrary.h&quot;
 #include &quot;ExternalAI/Interface/AISEvents.h&quot;
-//#include &quot;ExternalAI/Interface/SInfo.h&quot;
 #include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot;
 
 #include &lt;jni.h&gt;
@@ -725,34 +723,6 @@
 	return o_props;
 }
 
-/*
-static jobject java_createPropertiesFromInfoItems(JNIEnv* env,
-		const struct InfoItem info[], unsigned int numInfoItems) {
-
-	jobject o_props = java_createPropertiesInstance(env);
-	if (o_props == NULL) {
-		return o_props;
-	}
-
-	// fill the Java Properties instance with the info keys and values
-	unsigned int ii;
-	for (ii=0; ii &lt; numInfoItems; ii++) {
-		jstring jstr_key = (*env)-&gt;NewStringUTF(env, info[ii].key);
-		jstring jstr_value = (*env)-&gt;NewStringUTF(env, info[ii].value);
-		(*env)-&gt;CallObjectMethod(env, o_props, g_m_props_setProperty, jstr_key, jstr_value);
-		if ((*env)-&gt;ExceptionCheck(env)) {
-			simpleLog_log(&quot;!Failed adding property&quot;);
-			if ((*env)-&gt;ExceptionCheck(env)) {
-				(*env)-&gt;ExceptionDescribe(env);
-			}
-			return NULL;
-		}
-	}
-
-	return o_props;
-}
-*/
-
 static jobject java_createPropertiesFromCMap(JNIEnv* env,
 		unsigned int size,
 		const char** keys, const char** values) {

Modified: branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/JavaBridge.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Interfaces/Java/JavaBridge.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -24,8 +24,6 @@
 
 #include &lt;stdbool.h&gt;	// bool, true, false
 
-#include &quot;ExternalAI/Interface/SInfo.h&quot;
-
 struct SStaticGlobalData;
 struct SAICallback;
 

Modified: branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java
===================================================================
--- branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java	2008-12-06 16:16:22 UTC (rev 7141)
@@ -86,7 +86,6 @@
 		// initialize the log
 		try {
 			myDataDir = info.getProperty(&quot;dataDir&quot;);
-			//myLogFile = &quot;/home/robin/NullJavaAI_test_log.txt&quot;;
 			myLogFile = myDataDir + &quot;/log.txt&quot;;
 			FileHandler fileLogger = new FileHandler(myLogFile, false);
 			fileLogger.setFormatter(new MyCustomLogFormatter());

Modified: branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java	2008-12-06 16:16:22 UTC (rev 7141)
@@ -113,7 +113,6 @@
 		// initialize the log
 		try {
 			myDataDir = info.getProperty(&quot;dataDir&quot;);
-			//myLogFile = &quot;/home/robin/NullJavaAI_test_log.txt&quot;;
 			myLogFile = myDataDir + &quot;/log.txt&quot;;
 			FileHandler fileLogger = new FileHandler(myLogFile, false);
 			fileLogger.setFormatter(new MyCustomLogFormatter());

Modified: branches/caiinterface/SConstruct
===================================================================
--- branches/caiinterface/SConstruct	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/SConstruct	2008-12-06 16:16:22 UTC (rev 7141)
@@ -120,7 +120,7 @@
 	'rts/Rendering/Textures/Bitmap.cpp',
 	'rts/Rendering/Textures/nv_dds.cpp',
 	'rts/Sim/Misc/SideParser.cpp',
-	'rts/ExternalAI/Interface/SInfo.cpp',
+	'rts/System/Info.cpp',
 	'rts/System/ConfigHandler.cpp',
 	'rts/System/LogOutput.cpp',
 ]

Modified: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -20,75 +20,59 @@
 #include &quot;IAIInterfaceLibrary.h&quot;
 #include &quot;AIInterfaceKey.h&quot;
 #include &quot;Interface/aidefines.h&quot;
-#include &quot;Interface/SInfo.h&quot;
 #include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;Info.h&quot;
+#include &quot;Util.h&quot;
 
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;FileSystem/VFSModes.h&quot;
 
-//CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
-//		const IAIInterfaceLibrary&amp; interface) {
-//
-//	info = interface.GetInfo();
-//
-//	std::map&lt;std::string, InfoItem&gt;::iterator iip;
-//    for (iip = info.begin(); iip != info.begin(); ++iip) {
-//		iip-&gt;second = copyInfoItem(&amp;(iip-&gt;second));
-//    }
-//}
+static const char* BAD_CHARS = &quot;\t _#&quot;;
 
-CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
-		const CAIInterfaceLibraryInfo&amp; interfaceInfo)
-		: infoKeys_c(NULL), infoValues_c(NULL) {
+static const std::string&amp; info_getValue(
+		const std::map&lt;std::string, InfoItem&gt;&amp; info,
+		const std::string&amp; key, const std::string&amp; defValue) {
 
-	info = std::map&lt;std::string, InfoItem&gt;(
-			interfaceInfo.info.begin(),
-			interfaceInfo.info.end());
-
-	std::map&lt;std::string, InfoItem&gt;::iterator iip;
-    for (iip = info.begin(); iip != info.begin(); ++iip) {
-		iip-&gt;second = copyInfoItem(&amp;(iip-&gt;second));
-    }
+	std::map&lt;std::string, InfoItem&gt;::const_iterator inf = info.find(StringToLower(key));
+	if (inf == info.end()) {
+		return defValue;
+	} else {
+		return inf-&gt;second.value;
+	}
 }
 
+
 CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
+		const CAIInterfaceLibraryInfo&amp; interfaceInfo)
+		: info(interfaceInfo.info), infoKeys_c(NULL), infoValues_c(NULL) {}
+
+CAIInterfaceLibraryInfo::CAIInterfaceLibraryInfo(
 		const std::string&amp; interfaceInfoFile)
 		: infoKeys_c(NULL), infoValues_c(NULL) {
 
-	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(interfaceInfoFile.c_str(), SPRING_VFS_RAW,
-			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
-    for (unsigned int i=0; i &lt; num; ++i) {
-/*
-		logOutput.Print(&quot;info %i: %s / %s / %s&quot;, i, tmpInfo[i].key,
-				tmpInfo[i].value, tmpInfo[i].desc);
-*/
-		info[std::string(tmpInfo[i].key)] = copyInfoItem(&amp;(tmpInfo[i]));
-    }
-
-	//levelOfSupport = LOS_Unknown;
+	std::vector&lt;InfoItem&gt; tmpInfo;
+	parseInfo(tmpInfo, interfaceInfoFile);
+	std::vector&lt;InfoItem&gt;::const_iterator ii;
+	for (ii = tmpInfo.begin(); ii != tmpInfo.end(); ++ii) {
+		info[StringToLower(ii-&gt;key)] = *ii;
+	}
 }
 
 CAIInterfaceLibraryInfo::~CAIInterfaceLibraryInfo() {
 
 	FreeCReferences();
-	std::map&lt;std::string, InfoItem&gt;::const_iterator iip;
-    for (iip = info.begin(); iip != info.begin(); ++iip) {
-		deleteInfoItem(&amp;(iip-&gt;second));
-    }
 }
 
-/*
-LevelOfSupport CAIInterfaceLibraryInfo::GetLevelOfSupportForCurrentEngine() const {
-	return levelOfSupport;
-}
-*/
-
 AIInterfaceKey CAIInterfaceLibraryInfo::GetKey() const {
 
-	const char* sn = info.at(AI_INTERFACE_PROPERTY_SHORT_NAME).value;
-	const char* v = info.at(AI_INTERFACE_PROPERTY_VERSION).value;
+	static const std::string defVal = &quot;&quot;;
+	static const std::string snKey = StringToLower(AI_INTERFACE_PROPERTY_SHORT_NAME);
+	static const std::string vKey = StringToLower(AI_INTERFACE_PROPERTY_VERSION);
+
+	const std::string&amp; sn = info_getValue(info, snKey, defVal);
+	const std::string&amp; v = info_getValue(info, vKey, defVal);
 	AIInterfaceKey key = AIInterfaceKey(sn, v);
+
 	return key;
 }
 
@@ -115,13 +99,16 @@
 }
 std::string CAIInterfaceLibraryInfo::GetInfo(const std::string&amp; key) const {
 
-	if (info.find(key) == info.end()) {
+	static const std::string defVal = &quot;&quot;;
+	const std::string&amp; val = info_getValue(info, key, defVal);
+	if (val == defVal) {
 		std::string errorMsg = std::string(&quot;AI interface property '&quot;) + key
 				+ &quot;' could not be found.\n&quot;;
 		handleerror(NULL, errorMsg.c_str(), &quot;AI Interface Info Error&quot;,
 				MBF_OK | MBF_EXCL);
 	}
-	return info.at(key).value;
+
+	return val;
 }
 const std::map&lt;std::string, InfoItem&gt;&amp; CAIInterfaceLibraryInfo::GetInfo() const {
 	return info;
@@ -135,8 +122,8 @@
 	unsigned int i=0;
 	std::map&lt;std::string, InfoItem&gt;::const_iterator ii;
 	for (ii=info.begin(); ii != info.end(); ++ii) {
-		infoKeys_c[i] = ii-&gt;second.key;
-		infoValues_c[i] = ii-&gt;second.value;
+		infoKeys_c[i] = ii-&gt;second.key.c_str();
+		infoValues_c[i] = ii-&gt;second.value.c_str();
 		i++;
 	}
 }
@@ -180,19 +167,24 @@
 bool CAIInterfaceLibraryInfo::SetInfo(const std::string&amp; key,
 		const std::string&amp; value) {
 
-	if (key == AI_INTERFACE_PROPERTY_SHORT_NAME ||
-			key == AI_INTERFACE_PROPERTY_VERSION) {
-		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
-			handleerror(NULL, &quot;AI interface property (shortName or version)\n&quot;
-					&quot;contains illegal characters ('_', '#' or white spaces)&quot;,
-					&quot;AI Interface Info Error&quot;, MBF_OK | MBF_EXCL);
+	static const std::string snKey = StringToLower(AI_INTERFACE_PROPERTY_SHORT_NAME);
+	static const std::string vKey = StringToLower(AI_INTERFACE_PROPERTY_VERSION);
+
+	std::string lowerKey = StringToLower(key);
+	if (lowerKey == snKey || key == vKey) {
+		if (value.find_first_of(BAD_CHARS) != std::string::npos) {
+			std::string msg = &quot;AI interface property (shortName or version)\n&quot;;
+			msg += &quot;contains illegal characters (&quot;;
+			msg += BAD_CHARS;
+			msg += &quot;)&quot;;
+			handleerror(NULL, msg.c_str(), &quot;AI Interface Info Error&quot;,
+					MBF_OK | MBF_EXCL);
 			return false;
 		}
 	}
 
-	InfoItem ii = {key.c_str(), value.c_str(), NULL};
-	ii = copyInfoItem(&amp;ii);
+	InfoItem ii = {key, value, &quot;&quot;};
+	info[lowerKey] = ii;
 
-	info[key] = ii;
 	return true;
 }

Modified: branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/AIInterfaceLibraryInfo.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -18,8 +18,6 @@
 #ifndef _AIINTERFACELIBRARYINFO_H
 #define _AIINTERFACELIBRARYINFO_H
 
-//#include &quot;AIInterfaceKey.h&quot;
-
 #include &lt;map&gt;
 #include &lt;string&gt;
 

Modified: branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/AILibraryManager.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -25,6 +25,7 @@
 
 #include &lt;boost/filesystem.hpp&gt;
 #include &quot;Util.h&quot;
+#include &quot;LogOutput.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/SharedLib.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
@@ -32,7 +33,6 @@
 #include &quot;Sim/Misc/GlobalConstants.h&quot;
 #include &quot;Sim/Misc/Team.h&quot;
 #include &quot;Sim/Misc/TeamHandler.h&quot;
-#include &quot;LogOutput.h&quot;
 
 #include &lt;string&gt;
 #include &lt;set&gt;
@@ -193,27 +193,6 @@
 }
 */
 
-/*
-std::vector&lt;InfoItem&gt; ParseInfos(
-		const std::string&amp; fileName,
-		const std::string&amp; fileModes,
-		const std::string&amp; accessModes)
-{
-	std::vector&lt;InfoItem&gt; infos;
-
-	//static const int MAX_INFOS = 128;
-#define MAX_INFOS 128
-	InfoItem tmpInfos[MAX_INFOS];
-	unsigned int num = ParseInfos(fileName.c_str(), fileModes.c_str(), accessModes.c_str(), tmpInfos, MAX_INFOS);
-	for (unsigned int i=0; i &lt; num; ++i) {
-		infos.push_back(copyInfoItem(&amp;(tmpInfos[i])));
-    }
-
-	return infos;
-}
-*/
-
-
 void CAILibraryManager::GetAllInfosFromCache() {
 
 	ClearAllInfos();

Modified: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -15,184 +15,184 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#include &quot;GroupAILibraryInfo.h&quot;
-
-#include &quot;Interface/aidefines.h&quot;
-#include &quot;Interface/SGAILibrary.h&quot;
-#include &quot;Interface/SAIInterfaceLibrary.h&quot;
-#include &quot;IGroupAILibrary.h&quot;
-
-#include &quot;Platform/errorhandler.h&quot;
-#include &quot;FileSystem/VFSModes.h&quot;
-
-CGroupAILibraryInfo::CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo) {
-
-	info = std::map&lt;std::string, InfoItem&gt;(
-			aiInfo.info.begin(),
-			aiInfo.info.end());
-	options = std::vector&lt;Option&gt;(
-			aiInfo.options.begin(),
-			aiInfo.options.end());
-
-	std::map&lt;std::string, InfoItem&gt;::iterator iip;
-	for (iip = info.begin(); iip != info.begin(); ++iip) {
-		iip-&gt;second = copyInfoItem(&amp;(iip-&gt;second));
-	}
-}
-
-CGroupAILibraryInfo::CGroupAILibraryInfo(
-		const std::string&amp; aiInfoFile,
-		const std::string&amp; aiOptionFile) {
-
-	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(aiInfoFile.c_str(), SPRING_VFS_RAW,
-			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
-	for (unsigned int i=0; i &lt; num; ++i) {
-		info[std::string(tmpInfo[i].key)] = tmpInfo[i];
-	}
-
-	if (!aiOptionFile.empty()) {
-		Option tmpOptions[MAX_OPTIONS];
-		num = ParseOptions(aiOptionFile.c_str(), SPRING_VFS_RAW, SPRING_VFS_RAW,
-				&quot;&quot;, tmpOptions, MAX_OPTIONS);
-		for (unsigned int i=0; i &lt; num; ++i) {
-			options.push_back(tmpOptions[i]);
-		}
-	}
-}
-
-CGroupAILibraryInfo::~CGroupAILibraryInfo() {
-
-	std::map&lt;std::string, InfoItem&gt;::const_iterator iip;
-	for (iip = info.begin(); iip != info.begin(); ++iip) {
-		deleteInfoItem(&amp;(iip-&gt;second));
-	}
-}
-
-SGAISpecifier CGroupAILibraryInfo::GetSpecifier() const {
-
-	const char* sn = info.at(GROUP_AI_PROPERTY_SHORT_NAME).value;
-	const char* v = info.at(GROUP_AI_PROPERTY_VERSION).value;
-	SGAISpecifier specifier = {sn, v};
-	return specifier;
-}
-
-std::string CGroupAILibraryInfo::GetDataDir() const {
-	return GetInfo(GROUP_AI_PROPERTY_DATA_DIR);
-}
-std::string CGroupAILibraryInfo::GetFileName() const {
-	return GetInfo(GROUP_AI_PROPERTY_FILE_NAME);
-}
-std::string CGroupAILibraryInfo::GetShortName() const { // restrictions: none of the following: spaces, '_', '#'
-	return GetInfo(GROUP_AI_PROPERTY_SHORT_NAME);
-}
-std::string CGroupAILibraryInfo::GetVersion() const { // restrictions: none of the following: spaces, '_', '#'
-	return GetInfo(GROUP_AI_PROPERTY_VERSION);
-}
-std::string CGroupAILibraryInfo::GetName() const {
-	return GetInfo(GROUP_AI_PROPERTY_NAME);
-}
-std::string CGroupAILibraryInfo::GetDescription() const {
-	return GetInfo(GROUP_AI_PROPERTY_DESCRIPTION);
-}
-std::string CGroupAILibraryInfo::GetURL() const {
-	return GetInfo(GROUP_AI_PROPERTY_URL);
-}
-std::string CGroupAILibraryInfo::GetInterfaceShortName() const {
-	return GetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME);
-}
-std::string CGroupAILibraryInfo::GetInterfaceVersion() const {
-	return GetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION);
-}
-std::string CGroupAILibraryInfo::GetInfo(const std::string&amp; key) const {
-	return info.at(key).value;
-}
-const std::map&lt;std::string, InfoItem&gt;* CGroupAILibraryInfo::GetInfo() const {
-	return &info;
-}
-
-const std::vector&lt;Option&gt;* CGroupAILibraryInfo::GetOptions() const {
-	return &options;
-}
-
-
-unsigned int CGroupAILibraryInfo::GetInfoCReference(InfoItem cInfo[],
-		unsigned int maxInfoItems) const {
-
-	unsigned int i=0;
-
-	std::map&lt;std::string, InfoItem&gt;::const_iterator infs;
-	for (infs=info.begin(); infs != info.end() &amp;&amp; i &lt; maxInfoItems; ++infs) {
-		cInfo[i++] = infs-&gt;second;
-	}
-
-	return i;
-}
-unsigned int CGroupAILibraryInfo::GetOptionsCReference(Option cOptions[],
-		unsigned int maxOptions) const {
-
-	unsigned int i=0;
-
-	std::vector&lt;Option&gt;::const_iterator ops;
-	for (ops=options.begin(); ops != options.end() &amp;&amp; i &lt; maxOptions; ++ops) {
-		cOptions[i++] = *ops;
-	}
-
-	return i;
-}
-
-
-void CGroupAILibraryInfo::SetDataDir(const std::string&amp; dataDir) {
-	SetInfo(GROUP_AI_PROPERTY_DATA_DIR, dataDir);
-}
-void CGroupAILibraryInfo::SetFileName(const std::string&amp; fileName) {
-	SetInfo(GROUP_AI_PROPERTY_FILE_NAME, fileName);
-}
-void CGroupAILibraryInfo::SetShortName(const std::string&amp; shortName) { // restrictions: none of the following: spaces, '_', '#'
-	SetInfo(GROUP_AI_PROPERTY_SHORT_NAME, shortName);
-}
-void CGroupAILibraryInfo::SetVersion(const std::string&amp; version) { // restrictions: none of the following: spaces, '_', '#'
-	SetInfo(GROUP_AI_PROPERTY_VERSION, version);
-}
-void CGroupAILibraryInfo::SetName(const std::string&amp; name) {
-	SetInfo(GROUP_AI_PROPERTY_NAME, name);
-}
-void CGroupAILibraryInfo::SetDescription(const std::string&amp; description) {
-	SetInfo(GROUP_AI_PROPERTY_DESCRIPTION, description);
-}
-void CGroupAILibraryInfo::SetURL(const std::string&amp; url) {
-	SetInfo(GROUP_AI_PROPERTY_URL, url);
-}
-void CGroupAILibraryInfo::SetInterfaceShortName(
-		const std::string&amp; interfaceShortName) {
-	SetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME, interfaceShortName);
-}
-void CGroupAILibraryInfo::SetInterfaceVersion(
-		const std::string&amp; interfaceVersion) {
-	SetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION, interfaceVersion);
-}
-bool CGroupAILibraryInfo::SetInfo(const std::string&amp; key,
-		const std::string&amp; value) {
-
-	if (key == GROUP_AI_PROPERTY_SHORT_NAME ||
-			key == GROUP_AI_PROPERTY_VERSION) {
-		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
-			handleerror(NULL, &quot;Error&quot;,
-					&quot;Group AI info (shortName or version) contains&quot;
-					&quot; illegal characters ('_', '#' or white spaces)&quot;,
-					MBF_OK | MBF_EXCL);
-			return false;
-		}
-	}
-
-	InfoItem ii = {key.c_str(), value.c_str(), NULL};
-	ii = copyInfoItem(&amp;ii);
-
-	info[key] = ii;
-	return true;
-}
-
-void CGroupAILibraryInfo::SetOptions(const std::vector&lt;Option&gt;&amp; _options) {
-	// implicit convertible types -&gt; range-ctor can be used
-	options = std::vector&lt;Option&gt;(_options.begin(), _options.end());
-}
+//#include &quot;GroupAILibraryInfo.h&quot;
+//
+//#include &quot;Interface/aidefines.h&quot;
+//#include &quot;Interface/SGAILibrary.h&quot;
+//#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+//#include &quot;IGroupAILibrary.h&quot;
+//
+//#include &quot;Platform/errorhandler.h&quot;
+//#include &quot;FileSystem/VFSModes.h&quot;
+//
+//CGroupAILibraryInfo::CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo) {
+//
+//	info = std::map&lt;std::string, InfoItem&gt;(
+//			aiInfo.info.begin(),
+//			aiInfo.info.end());
+//	options = std::vector&lt;Option&gt;(
+//			aiInfo.options.begin(),
+//			aiInfo.options.end());
+//
+//	std::map&lt;std::string, InfoItem&gt;::iterator iip;
+//	for (iip = info.begin(); iip != info.begin(); ++iip) {
+//		iip-&gt;second = copyInfoItem(&amp;(iip-&gt;second));
+//	}
+//}
+//
+//CGroupAILibraryInfo::CGroupAILibraryInfo(
+//		const std::string&amp; aiInfoFile,
+//		const std::string&amp; aiOptionFile) {
+//
+//	InfoItem tmpInfo[MAX_INFOS];
+//	unsigned int num = ParseInfo(aiInfoFile.c_str(), SPRING_VFS_RAW,
+//			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
+//	for (unsigned int i=0; i &lt; num; ++i) {
+//		info[std::string(tmpInfo[i].key)] = tmpInfo[i];
+//	}
+//
+//	if (!aiOptionFile.empty()) {
+//		Option tmpOptions[MAX_OPTIONS];
+//		num = ParseOptions(aiOptionFile.c_str(), SPRING_VFS_RAW, SPRING_VFS_RAW,
+//				&quot;&quot;, tmpOptions, MAX_OPTIONS);
+//		for (unsigned int i=0; i &lt; num; ++i) {
+//			options.push_back(tmpOptions[i]);
+//		}
+//	}
+//}
+//
+//CGroupAILibraryInfo::~CGroupAILibraryInfo() {
+//
+//	std::map&lt;std::string, InfoItem&gt;::const_iterator iip;
+//	for (iip = info.begin(); iip != info.begin(); ++iip) {
+//		deleteInfoItem(&amp;(iip-&gt;second));
+//	}
+//}
+//
+//SGAISpecifier CGroupAILibraryInfo::GetSpecifier() const {
+//
+//	const char* sn = info.at(GROUP_AI_PROPERTY_SHORT_NAME).value;
+//	const char* v = info.at(GROUP_AI_PROPERTY_VERSION).value;
+//	SGAISpecifier specifier = {sn, v};
+//	return specifier;
+//}
+//
+//std::string CGroupAILibraryInfo::GetDataDir() const {
+//	return GetInfo(GROUP_AI_PROPERTY_DATA_DIR);
+//}
+//std::string CGroupAILibraryInfo::GetFileName() const {
+//	return GetInfo(GROUP_AI_PROPERTY_FILE_NAME);
+//}
+//std::string CGroupAILibraryInfo::GetShortName() const { // restrictions: none of the following: spaces, '_', '#'
+//	return GetInfo(GROUP_AI_PROPERTY_SHORT_NAME);
+//}
+//std::string CGroupAILibraryInfo::GetVersion() const { // restrictions: none of the following: spaces, '_', '#'
+//	return GetInfo(GROUP_AI_PROPERTY_VERSION);
+//}
+//std::string CGroupAILibraryInfo::GetName() const {
+//	return GetInfo(GROUP_AI_PROPERTY_NAME);
+//}
+//std::string CGroupAILibraryInfo::GetDescription() const {
+//	return GetInfo(GROUP_AI_PROPERTY_DESCRIPTION);
+//}
+//std::string CGroupAILibraryInfo::GetURL() const {
+//	return GetInfo(GROUP_AI_PROPERTY_URL);
+//}
+//std::string CGroupAILibraryInfo::GetInterfaceShortName() const {
+//	return GetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME);
+//}
+//std::string CGroupAILibraryInfo::GetInterfaceVersion() const {
+//	return GetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION);
+//}
+//std::string CGroupAILibraryInfo::GetInfo(const std::string&amp; key) const {
+//	return info.at(key).value;
+//}
+//const std::map&lt;std::string, InfoItem&gt;* CGroupAILibraryInfo::GetInfo() const {
+//	return &info;
+//}
+//
+//const std::vector&lt;Option&gt;* CGroupAILibraryInfo::GetOptions() const {
+//	return &options;
+//}
+//
+//
+//unsigned int CGroupAILibraryInfo::GetInfoCReference(InfoItem cInfo[],
+//		unsigned int maxInfoItems) const {
+//
+//	unsigned int i=0;
+//
+//	std::map&lt;std::string, InfoItem&gt;::const_iterator infs;
+//	for (infs=info.begin(); infs != info.end() &amp;&amp; i &lt; maxInfoItems; ++infs) {
+//		cInfo[i++] = infs-&gt;second;
+//	}
+//
+//	return i;
+//}
+//unsigned int CGroupAILibraryInfo::GetOptionsCReference(Option cOptions[],
+//		unsigned int maxOptions) const {
+//
+//	unsigned int i=0;
+//
+//	std::vector&lt;Option&gt;::const_iterator ops;
+//	for (ops=options.begin(); ops != options.end() &amp;&amp; i &lt; maxOptions; ++ops) {
+//		cOptions[i++] = *ops;
+//	}
+//
+//	return i;
+//}
+//
+//
+//void CGroupAILibraryInfo::SetDataDir(const std::string&amp; dataDir) {
+//	SetInfo(GROUP_AI_PROPERTY_DATA_DIR, dataDir);
+//}
+//void CGroupAILibraryInfo::SetFileName(const std::string&amp; fileName) {
+//	SetInfo(GROUP_AI_PROPERTY_FILE_NAME, fileName);
+//}
+//void CGroupAILibraryInfo::SetShortName(const std::string&amp; shortName) { // restrictions: none of the following: spaces, '_', '#'
+//	SetInfo(GROUP_AI_PROPERTY_SHORT_NAME, shortName);
+//}
+//void CGroupAILibraryInfo::SetVersion(const std::string&amp; version) { // restrictions: none of the following: spaces, '_', '#'
+//	SetInfo(GROUP_AI_PROPERTY_VERSION, version);
+//}
+//void CGroupAILibraryInfo::SetName(const std::string&amp; name) {
+//	SetInfo(GROUP_AI_PROPERTY_NAME, name);
+//}
+//void CGroupAILibraryInfo::SetDescription(const std::string&amp; description) {
+//	SetInfo(GROUP_AI_PROPERTY_DESCRIPTION, description);
+//}
+//void CGroupAILibraryInfo::SetURL(const std::string&amp; url) {
+//	SetInfo(GROUP_AI_PROPERTY_URL, url);
+//}
+//void CGroupAILibraryInfo::SetInterfaceShortName(
+//		const std::string&amp; interfaceShortName) {
+//	SetInfo(GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME, interfaceShortName);
+//}
+//void CGroupAILibraryInfo::SetInterfaceVersion(
+//		const std::string&amp; interfaceVersion) {
+//	SetInfo(GROUP_AI_PROPERTY_INTERFACE_VERSION, interfaceVersion);
+//}
+//bool CGroupAILibraryInfo::SetInfo(const std::string&amp; key,
+//		const std::string&amp; value) {
+//
+//	if (key == GROUP_AI_PROPERTY_SHORT_NAME ||
+//			key == GROUP_AI_PROPERTY_VERSION) {
+//		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
+//			handleerror(NULL, &quot;Error&quot;,
+//					&quot;Group AI info (shortName or version) contains&quot;
+//					&quot; illegal characters ('_', '#' or white spaces)&quot;,
+//					MBF_OK | MBF_EXCL);
+//			return false;
+//		}
+//	}
+//
+//	InfoItem ii = {key.c_str(), value.c_str(), NULL};
+//	ii = copyInfoItem(&amp;ii);
+//
+//	info[key] = ii;
+//	return true;
+//}
+//
+//void CGroupAILibraryInfo::SetOptions(const std::vector&lt;Option&gt;&amp; _options) {
+//	// implicit convertible types -&gt; range-ctor can be used
+//	options = std::vector&lt;Option&gt;(_options.begin(), _options.end());
+//}

Modified: branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/GroupAILibraryInfo.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -15,67 +15,67 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#ifndef _GROUPAILIBRARYINFO_H
-#define	_GROUPAILIBRARYINFO_H
-
-
-#include &quot;Interface/ELevelOfSupport.h&quot;
-
-#include &lt;vector&gt;
-#include &lt;map&gt;
-#include &lt;string&gt;
-
-class IGroupAILibrary;
-struct InfoItem;
-struct Option;
-struct SAIInterfaceSpecifier;
-struct SGAISpecifier;
-
-class CGroupAILibraryInfo {
-public:
-	CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo);
-	CGroupAILibraryInfo(const std::string&amp; aiInfoFile,
-			const std::string&amp; aiOptionFile);
-	~CGroupAILibraryInfo();
-
-	virtual SGAISpecifier GetSpecifier() const;
-
-	virtual std::string GetDataDir() const;
-	virtual std::string GetFileName() const;
-	virtual std::string GetShortName() const; // restrictions: none of the following: spaces, '_', '#'
-	virtual std::string GetName() const;
-	virtual std::string GetVersion() const; // restrictions: none of the following: spaces, '_', '#'
-	virtual std::string GetDescription() const;
-	virtual std::string GetURL() const;
-	virtual std::string GetInterfaceShortName() const;
-	virtual std::string GetInterfaceVersion() const;
-	virtual std::string GetInfo(const std::string&amp; key) const;
-	virtual const std::map&lt;std::string, InfoItem&gt;* GetInfo() const;
-	virtual unsigned int GetInfoCReference(InfoItem cInfo[],
-			unsigned int maxInfoItems) const;
-	virtual unsigned int GetOptionsCReference(Option cOptions[],
-			unsigned int maxOptions) const;
-
-	virtual const std::vector&lt;Option&gt;* GetOptions() const;
-
-	virtual void SetDataDir(const std::string&amp; dataDir);
-	virtual void SetFileName(const std::string&amp; fileName);
-	virtual void SetShortName(const std::string&amp; shortName); // restrictions: none of the following: spaces, '_', '#'
-	virtual void SetName(const std::string&amp; name);
-	virtual void SetVersion(const std::string&amp; version); // restrictions: none of the following: spaces, '_', '#'
-	virtual void SetDescription(const std::string&amp; description);
-	virtual void SetURL(const std::string&amp; url);
-	virtual void SetInterfaceShortName(const std::string&amp; interfaceShortName);
-	virtual void SetInterfaceVersion(const std::string&amp; interfaceVersion);
-	virtual bool SetInfo(const std::string&amp; key, const std::string&amp; value);
-
-	virtual void SetOptions(const std::vector&lt;Option&gt;&amp; options);
-
-private:
-	static const unsigned int MAX_INFOS = 128;
-	static const unsigned int MAX_OPTIONS = 128;
-	std::map&lt;std::string, InfoItem&gt; info;
-	std::vector&lt;Option&gt; options;
-};
-
-#endif	// _GROUPAILIBRARYINFO_H
+//#ifndef _GROUPAILIBRARYINFO_H
+//#define	_GROUPAILIBRARYINFO_H
+//
+//
+//#include &quot;Interface/ELevelOfSupport.h&quot;
+//
+//#include &lt;vector&gt;
+//#include &lt;map&gt;
+//#include &lt;string&gt;
+//
+//class IGroupAILibrary;
+//struct InfoItem;
+//struct Option;
+//struct SAIInterfaceSpecifier;
+//struct SGAISpecifier;
+//
+//class CGroupAILibraryInfo {
+//public:
+//	CGroupAILibraryInfo(const CGroupAILibraryInfo&amp; aiInfo);
+//	CGroupAILibraryInfo(const std::string&amp; aiInfoFile,
+//			const std::string&amp; aiOptionFile);
+//	~CGroupAILibraryInfo();
+//
+//	virtual SGAISpecifier GetSpecifier() const;
+//
+//	virtual std::string GetDataDir() const;
+//	virtual std::string GetFileName() const;
+//	virtual std::string GetShortName() const; // restrictions: none of the following: spaces, '_', '#'
+//	virtual std::string GetName() const;
+//	virtual std::string GetVersion() const; // restrictions: none of the following: spaces, '_', '#'
+//	virtual std::string GetDescription() const;
+//	virtual std::string GetURL() const;
+//	virtual std::string GetInterfaceShortName() const;
+//	virtual std::string GetInterfaceVersion() const;
+//	virtual std::string GetInfo(const std::string&amp; key) const;
+//	virtual const std::map&lt;std::string, InfoItem&gt;* GetInfo() const;
+//	virtual unsigned int GetInfoCReference(InfoItem cInfo[],
+//			unsigned int maxInfoItems) const;
+//	virtual unsigned int GetOptionsCReference(Option cOptions[],
+//			unsigned int maxOptions) const;
+//
+//	virtual const std::vector&lt;Option&gt;* GetOptions() const;
+//
+//	virtual void SetDataDir(const std::string&amp; dataDir);
+//	virtual void SetFileName(const std::string&amp; fileName);
+//	virtual void SetShortName(const std::string&amp; shortName); // restrictions: none of the following: spaces, '_', '#'
+//	virtual void SetName(const std::string&amp; name);
+//	virtual void SetVersion(const std::string&amp; version); // restrictions: none of the following: spaces, '_', '#'
+//	virtual void SetDescription(const std::string&amp; description);
+//	virtual void SetURL(const std::string&amp; url);
+//	virtual void SetInterfaceShortName(const std::string&amp; interfaceShortName);
+//	virtual void SetInterfaceVersion(const std::string&amp; interfaceVersion);
+//	virtual bool SetInfo(const std::string&amp; key, const std::string&amp; value);
+//
+//	virtual void SetOptions(const std::vector&lt;Option&gt;&amp; options);
+//
+//private:
+//	static const unsigned int MAX_INFOS = 128;
+//	static const unsigned int MAX_OPTIONS = 128;
+//	std::map&lt;std::string, InfoItem&gt; info;
+//	std::vector&lt;Option&gt; options;
+//};
+//
+//#endif	// _GROUPAILIBRARYINFO_H

Modified: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -27,7 +27,7 @@
 
 #include &quot;ELevelOfSupport.h&quot;
 #include &quot;SSAILibrary.h&quot;
-#include &quot;SGAILibrary.h&quot;
+//#include &quot;SGAILibrary.h&quot;
 #include &quot;System/exportdefines.h&quot;
 
 struct SStaticGlobalData;

Deleted: branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -1,136 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;SInfo.h&quot;
-
-#include &quot;System/Util.h&quot;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
-
-struct InfoItem copyInfoItem(const struct InfoItem* const orig) {
-	
-	struct InfoItem copy;
-	
-	copy.key = mallocCopyString(orig-&gt;key);
-	
-	copy.value = mallocCopyString(orig-&gt;value);
-	
-	if (orig-&gt;desc != NULL) {
-		copy.desc = mallocCopyString(orig-&gt;desc);
-	} else {
-		copy.desc = NULL;
-	}
-	
-	return copy;
-}
-void deleteInfoItem(const struct InfoItem* const info) {
-	
-	freeString(info-&gt;key);
-	freeString(info-&gt;value);
-	freeString(info-&gt;desc);
-	
-	InfoItem* const mutableInfo = const_cast&lt;InfoItem* const&gt;(info);
-	mutableInfo-&gt;key = NULL;
-	mutableInfo-&gt;value = NULL;
-	mutableInfo-&gt;desc = NULL;
-}
-
-#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-
-#include &quot;Lua/LuaParser.h&quot;
-
-#include &lt;set&gt;
-
-static const char* badKeyChars = &quot; =;\r\n\t&quot;;
-
-bool ParseInfo(const LuaTable&amp; root, int index, InfoItem&amp; info, std::set&lt;std::string&gt; infoSet)
-{
-	const LuaTable&amp; infoTbl = root.SubTable(index);
-	if (!infoTbl.IsValid()) {
-		return false;
-	}
-
-	// info properties
-	std::string info_key = infoTbl.GetString(&quot;key&quot;, &quot;&quot;);
-	if (info_key.empty() ||
-	    (info_key.find_first_of(badKeyChars) != std::string::npos)) {
-		return false;
-	}
-	std::string keyLower = StringToLower(info_key);
-	if (infoSet.find(keyLower) != infoSet.end()) {
-		return false;
-	}
-	info.key = mallocCopyString(info_key.c_str());
-	
-	std::string info_value = infoTbl.GetString(&quot;value&quot;, &quot;&quot;);
-	if (info_value.empty()) {
-		return false;
-	}
-	info.value = mallocCopyString(info_value.c_str());
-	
-	std::string info_desc = infoTbl.GetString(&quot;desc&quot;, &quot;&quot;);
-	if (info_desc.empty()) {
-		info.desc = NULL;
-	} else {
-		info.desc = mallocCopyString(info_desc.c_str());
-	}
-
-	infoSet.insert(keyLower);
-
-	return true;
-}
-
-unsigned int ParseInfo(
-		const char* fileName,
-		const char* fileModes,
-		const char* accessModes,
-		InfoItem info[], unsigned int max)
-{
-	LuaParser luaParser(fileName, fileModes, accessModes);
-		
-	if (!luaParser.Execute()) {
-		printf(&quot;ParseInfo(%s) ERROR: %s\n&quot;,
-		       fileName, luaParser.GetErrorLog().c_str());
-		return 0;
-	}
-
-	const LuaTable root = luaParser.GetRoot();
-	if (!root.IsValid()) {
-		return 0;
-	}
-
-	unsigned int i = 0;
-	std::set&lt;std::string&gt; infoSet;
-	for (int index = 1; root.KeyExists(index) &amp;&amp; i &lt; max; index++) {
-		bool parseOk = ParseInfo(root, index, info[i], infoSet);
-		if (!parseOk) {
-			info[i].key = NULL;
-			info[i].value = NULL;
-			info[i].desc = NULL;
-		}
-		i++;
-	}
-	
-	return i;
-}
-unsigned int ParseInfoRawFileSystem(
-		const char* fileName,
-		InfoItem info[], unsigned int max) {
-	return ParseInfo(fileName, SPRING_VFS_RAW, SPRING_VFS_RAW, info, max);
-}
-
-#endif // defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)

Deleted: branches/caiinterface/rts/ExternalAI/Interface/SInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SInfo.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/Interface/SInfo.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -1,54 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-// The structs in this files relate to *Info.lua files
-// They are used for AIs eg (-&gt; AIInfo.lua)
-
-#ifndef _SINFO_H
-#define	_SINFO_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-
-struct InfoItem {
-	const char* key;
-	const char* value;
-	const char* desc;
-};
-
-struct InfoItem copyInfoItem(const struct InfoItem* const orig);
-void deleteInfoItem(const struct InfoItem* const info);
-
-
-#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-unsigned int ParseInfo(
-		const char* fileName,
-		const char* fileModes,
-		const char* accessModes,
-		InfoItem info[], unsigned int max);
-unsigned int ParseInfoRawFileSystem(
-		const char* fileName,
-		InfoItem info[], unsigned int max);
-#endif	// defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-
-#ifdef	__cplusplus
-}	// extern &quot;C&quot;
-#endif
-
-#endif	// _SINFO_H
-

Deleted: branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -1,209 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _SOPTION_CPP
-#define	_SOPTION_CPP
-
-#include &quot;SOption.h&quot;
-
-#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-
-#include &quot;System/Util.h&quot;
-#include &quot;Lua/LuaParser.h&quot;
-#include &quot;Map/MapParser.h&quot;
-
-#include &lt;set&gt;
-
-bool ParseOption(const LuaTable&amp; root, int index, Option&amp; opt, std::set&lt;std::string&gt; optionsSet)
-{
-	const LuaTable&amp; optTbl = root.SubTable(index);
-	if (!optTbl.IsValid()) {
-		return false;
-	}
-
-	// common options properties
-	std::string opt_key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
-	if (opt_key.empty() ||
-	    (opt_key.find_first_of(Option_badKeyChars) != std::string::npos)) {
-		return false;
-	}
-	opt_key = StringToLower(opt_key);
-	if (optionsSet.find(opt_key) != optionsSet.end()) {
-		return false;
-	}
-	opt.key = mallocCopyString(opt_key.c_str());
-	
-	std::string opt_name = optTbl.GetString(&quot;name&quot;, opt_key);
-	if (opt_name.empty()) {
-		return false;
-	}
-	opt.name = mallocCopyString(opt_name.c_str());
-	
-	std::string opt_desc = optTbl.GetString(&quot;desc&quot;, opt_name);
-	opt.desc = mallocCopyString(opt_desc.c_str());
-	
-	std::string opt_section = optTbl.GetString(&quot;section&quot;, &quot;&quot;);
-	opt.section = mallocCopyString(opt_section.c_str());
-	
-	std::string opt_style = optTbl.GetString(&quot;style&quot;, &quot;&quot;);
-	opt.style = mallocCopyString(opt_style.c_str());
-
-	std::string opt_type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
-	opt_type = StringToLower(opt_type);
-	opt.type = mallocCopyString(opt_type.c_str());
-
-	// option type specific properties
-	if (opt_type == &quot;bool&quot;) {
-		opt.typeCode = opt_bool;
-		opt.boolDef = optTbl.GetBool(&quot;def&quot;, false);
-	}
-	else if (opt_type == &quot;number&quot;) {
-		opt.typeCode = opt_number;
-		opt.numberDef  = optTbl.GetFloat(&quot;def&quot;,  0.0f);
-		opt.numberMin  = optTbl.GetFloat(&quot;min&quot;,  -1.0e30f);
-		opt.numberMax  = optTbl.GetFloat(&quot;max&quot;,  +1.0e30f);
-		opt.numberStep = optTbl.GetFloat(&quot;step&quot;, 0.0f);
-	}
-	else if (opt_type == &quot;string&quot;) {
-		opt.typeCode = opt_string;
-		opt.stringDef    = mallocCopyString(optTbl.GetString(&quot;def&quot;, &quot;&quot;).c_str());
-		opt.stringMaxLen = optTbl.GetInt(&quot;maxlen&quot;, 0);
-	}
-	else if (opt_type == &quot;list&quot;) {
-		opt.typeCode = opt_list;
-
-		const LuaTable&amp; listTbl = optTbl.SubTable(&quot;items&quot;);
-		if (!listTbl.IsValid()) {
-			return false;
-		}
-
-		vector&lt;OptionListItem&gt; opt_list;
-		for (int i = 1; listTbl.KeyExists(i); i++) {
-			OptionListItem item;
-
-			// string format
-			std::string item_key = listTbl.GetString(i, &quot;&quot;);
-			if (!item_key.empty() &amp;&amp;
-			    (item_key.find_first_of(Option_badKeyChars) == string::npos)) {
-				item.key = mallocCopyString(item_key.c_str());
-				item.name = item.key;
-				item.desc = item.name;
-				opt_list.push_back(item);
-				continue;
-			}
-
-			// table format  (name &amp; desc)
-			const LuaTable&amp; itemTbl = listTbl.SubTable(i);
-			if (!itemTbl.IsValid()) {
-				break;
-			}
-			item_key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
-			if (item_key.empty() ||
-				(item_key.find_first_of(Option_badKeyChars) != string::npos)) {
-				return false;
-			}
-			item_key = StringToLower(item_key);
-			//item.key = item_key.c_str();
-			item.key = mallocCopyString(item_key.c_str());
-			std::string item_name = itemTbl.GetString(&quot;name&quot;, item_key);
-			if (item_name.empty()) {
-				return false;
-			}
-			//item.name = item_name.c_str();
-			item.name = mallocCopyString(item_name.c_str());
-			std::string item_desc = itemTbl.GetString(&quot;desc&quot;, item_name);
-			//item.desc = item_desc.c_str();
-			item.desc = mallocCopyString(item_desc.c_str());
-			opt_list.push_back(item);
-		}
-
-		if (opt_list.size() &lt;= 0) {
-			return false; // no empty lists
-		}
-		
-		opt.numListItems = opt_list.size();
-		opt.list = (OptionListItem*) calloc(sizeof(OptionListItem), opt.numListItems);
-        for (int i=0; i &lt; opt.numListItems; ++i) {
-            opt.list[i] = opt_list.at(i);
-        }
-
-		//opt.listDef = optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str();
-		opt.listDef = mallocCopyString(optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str());
-	}
-	else {
-		return false; // unknown type
-	}
-
-	optionsSet.insert(opt.key);
-
-	return true;
-}
-
-
-/*
-std::vector&lt;Option&gt; ParseOptions(const std::string&amp; fileName,
-                         const std::string&amp; fileModes,
-                         const std::string&amp; accessModes,
-                         const std::string&amp; mapName)
-*/
-int ParseOptions(
-		const char* fileName,
-		const char* fileModes,
-		const char* accessModes,
-		const char* mapName,
-		Option options[], unsigned int max)
-{
-	//std::vector&lt;Option&gt; options;
-
-	LuaParser luaParser(fileName, fileModes, accessModes);
-
-	const string configName = MapParser::GetMapConfigName(mapName);
-
-	if (!std::string(mapName).empty() &amp;&amp; !configName.empty()) {
-		luaParser.GetTable(&quot;Map&quot;);
-		luaParser.AddString(&quot;fileName&quot;, mapName);
-		luaParser.AddString(&quot;fullName&quot;, std::string(&quot;maps/&quot;) + mapName);
-		luaParser.AddString(&quot;configFile&quot;, configName);
-		luaParser.EndTable();
-	}
-		
-	if (!luaParser.Execute()) {
-		printf(&quot;ParseOptions(%s) ERROR: %s\n&quot;,
-		       fileName, luaParser.GetErrorLog().c_str());
-		return 0;
-	}
-
-	const LuaTable root = luaParser.GetRoot();
-	if (!root.IsValid()) {
-		return 0;
-	}
-
-	std::set&lt;std::string&gt; optionsSet;
-	int i = 0;
-	for (int index = 1; root.KeyExists(index) &amp;&amp; i &lt; (int)max; index++) {
-		Option opt;
-		if (ParseOption(root, index, opt, optionsSet)) {
-			options[i++] = opt;
-		}
-	}
-
-	return i;
-}
-
-#endif	// defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-
-#endif	// _SOPTION_CPP

Deleted: branches/caiinterface/rts/ExternalAI/Interface/SOption.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SOption.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/Interface/SOption.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -1,91 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-// The structs in this files relate to *Options.lua files
-// They are used for Mods and Skirmish AIs eg
-
-#ifndef _SOPTION_H
-#define	_SOPTION_H
-
-#ifdef	__cplusplus
-extern &quot;C&quot; {
-#endif
-
-#define Option_badKeyChars &quot; =;\r\n\t&quot;
-
-struct OptionListItem {
-	const char* key;
-	const char* name;
-	const char* desc;
-};
-
-enum OptionType {
-	opt_error   = 0,
-	opt_bool    = 1,
-	opt_list    = 2,
-	opt_number  = 3,
-	opt_string  = 4,
-	opt_section = 5
-};
-
-struct Option {
-#ifdef	__cplusplus
-	Option() : typeCode(opt_error) {}
-#endif
-
-	const char* key;
-	const char* name;
-	const char* desc;
-	const char* section;
-	const char* style;
-
-	const char* type; // &quot;bool&quot;, &quot;number&quot;, &quot;string&quot;, &quot;list&quot;, ... (see enum OptionType)
-
-	enum OptionType typeCode;
-
-//	bool   boolDef;
-	int   boolDef; // 0 -&gt; false, 1 -&gt; true
-
-	float  numberDef;
-	float  numberMin;
-	float  numberMax;
-	float  numberStep; // aligned to numberDef
-
-	const char* stringDef;
-	int    stringMaxLen;
-
-	const char* listDef;
-	int numListItems;
-	struct OptionListItem* list;
-};
-
-
-#if	defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-int ParseOptions(
-		const char* fileName,
-		const char* fileModes,
-		const char* accessModes,
-		const char* mapName,
-		Option options[], unsigned int max);
-#endif	// defined(__cplusplus) &amp;&amp; !defined(BUILDING_AI) &amp;&amp; !defined(BUILDING_AI_INTERFACE)
-
-#ifdef	__cplusplus
-}	// extern &quot;C&quot;
-#endif
-
-#endif	// _SOPTION_H */
-

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -19,68 +19,66 @@
 
 #include &quot;Interface/aidefines.h&quot;
 #include &quot;Interface/SSAILibrary.h&quot;
-#include &quot;Interface/SInfo.h&quot;
-#include &quot;Interface/SOption.h&quot;
 #include &quot;SkirmishAIKey.h&quot;
 #include &quot;ISkirmishAILibrary.h&quot;
+#include &quot;Info.h&quot;
+#include &quot;Option.h&quot;
+#include &quot;Util.h&quot;
 
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;FileSystem/VFSModes.h&quot;
 
-CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(
-		const CSkirmishAILibraryInfo&amp; aiInfo)
-		: infoKeys_c(NULL), infoValues_c(NULL) {
+static const char* BAD_CHARS = &quot;\t _#&quot;;
 
-	info = std::map&lt;std::string, InfoItem&gt;(
-			aiInfo.info.begin(),
-			aiInfo.info.end());
-	options = std::vector&lt;Option&gt;(
-			aiInfo.options.begin(),
-			aiInfo.options.end());
+static const std::string&amp; info_getValue(
+		const std::map&lt;std::string, InfoItem&gt;&amp; info,
+		const std::string&amp; key, const std::string&amp; defValue) {
 
-	std::map&lt;std::string, InfoItem&gt;::iterator iip;
-	for (iip = info.begin(); iip != info.begin(); ++iip) {
-		iip-&gt;second = copyInfoItem(&amp;(iip-&gt;second));
+	std::map&lt;std::string, InfoItem&gt;::const_iterator inf
+			= info.find(StringToLower(key));
+	if (inf == info.end()) {
+		return defValue;
+	} else {
+		return inf-&gt;second.value;
 	}
 }
 
 CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(
+		const CSkirmishAILibraryInfo&amp; aiInfo)
+		: info(aiInfo.info), infoKeys_c(NULL), infoValues_c(NULL),
+		options(aiInfo.options) {}
+
+CSkirmishAILibraryInfo::CSkirmishAILibraryInfo(
 		const std::string&amp; aiInfoFile,
 		const std::string&amp; aiOptionFile)
 		: infoKeys_c(NULL), infoValues_c(NULL) {
 
-	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(aiInfoFile.c_str(), SPRING_VFS_RAW,
-			SPRING_VFS_RAW, tmpInfo, MAX_INFOS);
-	for (unsigned int i=0; i &lt; num; ++i) {
-		info[std::string(tmpInfo[i].key)] = tmpInfo[i];
-		InfoItem ii = copyInfoItem(&amp;(tmpInfo[i]));
-		info[std::string(ii.key)] = ii;
+	std::vector&lt;InfoItem&gt; tmpInfo;
+	parseInfo(tmpInfo, aiInfoFile);
+	std::vector&lt;InfoItem&gt;::const_iterator ii;
+	for (ii = tmpInfo.begin(); ii != tmpInfo.end(); ++ii) {
+		info[StringToLower(ii-&gt;key)] = *ii;
 	}
 
-	if (!aiOptionFile.empty()) {
-		Option tmpOptions[MAX_OPTIONS];
-		num = ParseOptions(aiOptionFile.c_str(), SPRING_VFS_RAW, SPRING_VFS_RAW,
-				&quot;&quot;, tmpOptions, MAX_OPTIONS);
-		for (unsigned int i=0; i &lt; num; ++i) {
-			options.push_back(tmpOptions[i]);
-		}
+	if (aiOptionFile != &quot;&quot;) {
+		parseOptions(options, aiOptionFile);
 	}
 }
 
 CSkirmishAILibraryInfo::~CSkirmishAILibraryInfo() {
 
 	FreeCReferences();
-	std::map&lt;std::string, InfoItem&gt;::const_iterator iip;
-	for (iip = info.begin(); iip != info.begin(); ++iip) {
-		deleteInfoItem(&amp;(iip-&gt;second));
-	}
 }
 
 SkirmishAIKey CSkirmishAILibraryInfo::GetKey() const {
 
-	const char* sn = info.at(SKIRMISH_AI_PROPERTY_SHORT_NAME).value;
-	const char* v = info.at(SKIRMISH_AI_PROPERTY_VERSION).value;
+	static const std::string defVal = &quot;&quot;;
+	static const std::string snKey = StringToLower(SKIRMISH_AI_PROPERTY_SHORT_NAME);
+	static const std::string vKey = StringToLower(SKIRMISH_AI_PROPERTY_VERSION);
+
+	const std::string&amp; sn = info_getValue(info, snKey, defVal);
+	const std::string&amp; v = info_getValue(info, vKey, defVal);
+
 	SkirmishAIKey key = SkirmishAIKey(sn, v);
 	return key;
 }
@@ -113,7 +111,17 @@
 	return GetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_VERSION);
 }
 std::string CSkirmishAILibraryInfo::GetInfo(const std::string&amp; key) const {
-	return info.at(key).value;
+
+	static const std::string defVal = &quot;&quot;;
+	const std::string&amp; val = info_getValue(info, key, defVal);
+	if (val == defVal) {
+		std::string errorMsg = std::string(&quot;Skirmish AI property '&quot;) + key
+				+ &quot;' could not be found.\n&quot;;
+		handleerror(NULL, errorMsg.c_str(), &quot;Skirmish AI Info Error&quot;,
+				MBF_OK | MBF_EXCL);
+	}
+
+	return val;
 }
 const std::map&lt;std::string, InfoItem&gt;&amp; CSkirmishAILibraryInfo::GetInfo() const {
 	return info;
@@ -123,37 +131,17 @@
 	return options;
 }
 
-
-//unsigned int CSkirmishAILibraryInfo::GetInfoCReference(InfoItem cInfo[],
-//		unsigned int maxInfoItems) const {
-//
-//	unsigned int i=0;
-//
-//	std::map&lt;std::string, InfoItem&gt;::const_iterator infs;
-//	for (infs=info.begin(); infs != info.end() &amp;&amp; i &lt; maxInfoItems; ++infs) {
-//		cInfo[i++] = infs-&gt;second;
-//	}
-//
-//	return i;
-//}
-
 void CSkirmishAILibraryInfo::CreateCReferences() {
 
 	FreeCReferences();
 
-//	info_c = (struct InfoItem*) calloc(info.size(), sizeof(struct InfoItem));
-//	unsigned int i=0;
-//	std::map&lt;std::string, InfoItem&gt;::const_iterator ii;
-//	for (ii=info.begin(); ii != info.end(); ++ii) {
-//		info_c[i++] = ii-&gt;second;
-//	}
 	infoKeys_c = (const char**) calloc(info.size(), sizeof(char*));
 	infoValues_c = (const char**) calloc(info.size(), sizeof(char*));
 	unsigned int i=0;
 	std::map&lt;std::string, InfoItem&gt;::const_iterator ii;
 	for (ii=info.begin(); ii != info.end(); ++ii) {
-		infoKeys_c[i] = ii-&gt;second.key;
-		infoValues_c[i] = ii-&gt;second.value;
+		infoKeys_c[i] = ii-&gt;second.key.c_str();
+		infoValues_c[i] = ii-&gt;second.value.c_str();
 		i++;
 	}
 }
@@ -194,29 +182,41 @@
 void CSkirmishAILibraryInfo::SetURL(const std::string&amp; url) {
 	SetInfo(SKIRMISH_AI_PROPERTY_URL, url);
 }
-void CSkirmishAILibraryInfo::SetInterfaceShortName(const std::string&amp; interfaceShortName) {
+void CSkirmishAILibraryInfo::SetInterfaceShortName(
+		const std::string&amp; interfaceShortName) {
 	SetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME, interfaceShortName);
 }
-void CSkirmishAILibraryInfo::SetInterfaceVersion(const std::string&amp; interfaceVersion) {
+void CSkirmishAILibraryInfo::SetInterfaceVersion(
+		const std::string&amp; interfaceVersion) {
 	SetInfo(SKIRMISH_AI_PROPERTY_INTERFACE_VERSION, interfaceVersion);
 }
-bool CSkirmishAILibraryInfo::SetInfo(const std::string&amp; key, const std::string&amp; value) {
+bool CSkirmishAILibraryInfo::SetInfo(const std::string&amp; key,
+				const std::string&amp; value) {
 
-	if (key == SKIRMISH_AI_PROPERTY_SHORT_NAME ||
-			key == SKIRMISH_AI_PROPERTY_VERSION) {
-		if (value.find_first_of(&quot;\t _#&quot;) != std::string::npos) {
-			handleerror(NULL, &quot;Error&quot;, &quot;Skirmish AI info (shortName or version) contains illegal characters ('_', '#' or white spaces)&quot;, MBF_OK | MBF_EXCL);
+	static const std::string snKey = StringToLower(SKIRMISH_AI_PROPERTY_SHORT_NAME);
+	static const std::string vKey = StringToLower(SKIRMISH_AI_PROPERTY_VERSION);
+
+	std::string lowerKey = StringToLower(key);
+	if (lowerKey == snKey || key == vKey) {
+		if (value.find_first_of(BAD_CHARS) != std::string::npos) {
+			std::string msg = &quot;Skirmish AI property (shortName or version)\n&quot;;
+			msg += &quot;contains illegal characters (&quot;;
+			msg += BAD_CHARS;
+			msg += &quot;)&quot;;
+			handleerror(NULL, msg.c_str(), &quot;Skirmish AI Info Error&quot;,
+					MBF_OK | MBF_EXCL);
 			return false;
 		}
 	}
 
-	InfoItem ii = {key.c_str(), value.c_str(), NULL};
-	ii = copyInfoItem(&amp;ii);
+	InfoItem ii = {key, value, &quot;&quot;};
+	info[lowerKey] = ii;
 
-	info[key] = ii;
 	return true;
 }
 
 void CSkirmishAILibraryInfo::SetOptions(const std::vector&lt;Option&gt;&amp; _options) {
-	options = std::vector&lt;Option&gt;(_options.begin(), _options.end()); // implicit convertible types -&gt; range-ctor can be used
+
+	// implicit convertible types -&gt; range-ctor can be used
+	options = std::vector&lt;Option&gt;(_options.begin(), _options.end());
 }

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAILibraryInfo.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -34,7 +34,7 @@
 public:
 	CSkirmishAILibraryInfo(const CSkirmishAILibraryInfo&amp; aiInfo);
 	CSkirmishAILibraryInfo(const std::string&amp; aiInfoFile,
-			const std::string&amp; aiOptionFile);
+			const std::string&amp; aiOptionFile = &quot;&quot;);
 	~CSkirmishAILibraryInfo();
 
 	virtual void CreateCReferences();

Copied: branches/caiinterface/rts/System/Info.cpp (from rev 7115, branches/caiinterface/rts/ExternalAI/Interface/SInfo.cpp)
===================================================================
--- branches/caiinterface/rts/System/Info.cpp	                        (rev 0)
+++ branches/caiinterface/rts/System/Info.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -0,0 +1,121 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;Info.h&quot;
+
+#include &quot;System/Util.h&quot;
+#include &quot;System/Exceptions.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+
+#include &lt;assert.h&gt;
+
+static const char* InfoItem_badKeyChars = &quot; =;\r\n\t&quot;;
+
+static bool parseInfoItem(const LuaTable&amp; root, int index, InfoItem&amp; inf,
+		std::set&lt;string&gt;&amp; infoSet, CLogSubsystem&amp; logSubsystem)
+{
+	const LuaTable&amp; infsTbl = root.SubTable(index);
+	if (!infsTbl.IsValid()) {
+		logOutput.Print(logSubsystem,
+				&quot;parseInfoItem: subtable %d invalid&quot;, index);
+		return false;
+	}
+
+	// common info properties
+	inf.key = infsTbl.GetString(&quot;key&quot;, &quot;&quot;);
+	if (inf.key.empty()
+			|| (inf.key.find_first_of(InfoItem_badKeyChars) != string::npos)) {
+		logOutput.Print(logSubsystem,
+				&quot;parseInfoItem: empty key or key contains bad characters&quot;);
+		return false;
+	}
+	std::string lowerKey = StringToLower(inf.key);
+	if (infoSet.find(inf.key) != infoSet.end()) {
+		logOutput.Print(logSubsystem, &quot;parseInfoItem: key toLowerCase(%s) exists already&quot;,
+				inf.key.c_str());
+		return false;
+	}
+	inf.value = infsTbl.GetString(&quot;value&quot;, inf.key);
+	if (inf.value.empty()) {
+		logOutput.Print(logSubsystem, &quot;parseInfoItem: %s: empty value&quot;,
+				inf.key.c_str());
+		return false;
+	}
+	inf.desc = infsTbl.GetString(&quot;desc&quot;, &quot;&quot;);
+
+	infoSet.insert(lowerKey);
+
+	return true;
+}
+
+
+void parseInfo(
+		std::vector&lt;InfoItem&gt;&amp; info,
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes,
+		std::set&lt;std::string&gt;* infoSet,
+		CLogSubsystem* logSubsystem) {
+
+	if (!logSubsystem) {
+		assert(logSubsystem);
+	}
+
+	LuaParser luaParser(fileName, fileModes, accessModes);
+
+	if (!luaParser.Execute()) {
+		throw content_error(&quot;luaParser.Execute() failed: &quot;
+				+ luaParser.GetErrorLog());
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+	if (!root.IsValid()) {
+		throw content_error(&quot;root table invalid&quot;);
+	}
+
+	std::set&lt;std::string&gt;* myInfoSet = NULL;
+	if (infoSet == NULL) {
+		myInfoSet = new std::set&lt;std::string&gt;();
+	} else {
+		myInfoSet = infoSet;
+	}
+	for (int index = 1; root.KeyExists(index); index++) {
+		InfoItem inf;
+		if (parseInfoItem(root, index, inf, *myInfoSet, *logSubsystem)) {
+			info.push_back(inf);
+		}
+	}
+	if (infoSet == NULL) {
+		delete myInfoSet;
+		myInfoSet = NULL;
+	}
+}
+
+std::vector&lt;InfoItem&gt; parseInfo(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes,
+		std::set&lt;std::string&gt;* infoSet,
+		CLogSubsystem* logSubsystem) {
+
+	std::vector&lt;InfoItem&gt; info;
+
+	parseInfo(info, fileName, fileModes, accessModes, infoSet,
+			logSubsystem);
+
+	return info;
+}


Property changes on: branches/caiinterface/rts/System/Info.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/rts/System/Info.h (from rev 7034, branches/caiinterface/rts/ExternalAI/Interface/SInfo.h)
===================================================================
--- branches/caiinterface/rts/System/Info.h	                        (rev 0)
+++ branches/caiinterface/rts/System/Info.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -0,0 +1,53 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+// The structs in this files relate to *Info.lua files
+// They are used for AIs (-&gt; AIInfo.lua) for example;
+// This file is used (at least) by unitsync and the engine
+
+#ifndef _INFO_H
+#define _INFO_H
+
+#include &quot;System/FileSystem/VFSModes.h&quot;
+#include &quot;LogOutput.h&quot;
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+
+struct InfoItem {
+	std::string key;
+	std::string value;
+	std::string desc;
+};
+
+void parseInfo(
+		std::vector&lt;InfoItem&gt;&amp; options,
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes = SPRING_VFS_RAW,
+		const std::string&amp; accessModes = SPRING_VFS_RAW,
+		std::set&lt;std::string&gt;* infoSet = NULL,
+		CLogSubsystem* logSubsystem = &amp;(CLogOutput::GetDefaultLogSubsystem()));
+
+std::vector&lt;InfoItem&gt; parseInfo(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes = SPRING_VFS_RAW,
+		const std::string&amp; accessModes = SPRING_VFS_RAW,
+		std::set&lt;std::string&gt;* infoSet = NULL,
+		CLogSubsystem* logSubsystem = &amp;(CLogOutput::GetDefaultLogSubsystem()));
+
+#endif // _INFO_H


Property changes on: branches/caiinterface/rts/System/Info.h
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/System/LogOutput.cpp
===================================================================
--- branches/caiinterface/rts/System/LogOutput.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/System/LogOutput.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -351,7 +351,12 @@
 	Output(subsystem, text.c_str());
 }
 
+CLogSubsystem&amp; CLogOutput::GetDefaultLogSubsystem()
+{
+	return LOG_DEFAULT;
+}
 
+
 CLogOutput&amp; CLogOutput::operator&lt;&lt; (const int i)
 {
 	char t[50];

Modified: branches/caiinterface/rts/System/LogOutput.h
===================================================================
--- branches/caiinterface/rts/System/LogOutput.h	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/System/LogOutput.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -78,6 +78,7 @@
 	void Print(const std::string&amp; text);
 	void Print(CLogSubsystem&amp; subsystem, const std::string&amp; text);
 	void Printv(CLogSubsystem&amp; subsystem, const char* fmt, va_list argp);
+	static CLogSubsystem&amp; GetDefaultLogSubsystem();
 
 	CLogOutput&amp; operator&lt;&lt;(const int i);
 	CLogOutput&amp; operator&lt;&lt;(const float f);

Copied: branches/caiinterface/rts/System/Option.cpp (from rev 7034, branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp)
===================================================================
--- branches/caiinterface/rts/System/Option.cpp	                        (rev 0)
+++ branches/caiinterface/rts/System/Option.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -0,0 +1,227 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _OPTION_CPP
+#define _OPTION_CPP
+
+#include &quot;Option.h&quot;
+
+#include &quot;System/Util.h&quot;
+#include &quot;System/Exceptions.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/MapParser.h&quot;
+
+#include &lt;assert.h&gt;
+
+static const char* Option_badKeyChars = &quot; =;\r\n\t&quot;;
+
+static bool parseOption(const LuaTable&amp; root, int index, Option&amp; opt,
+		std::set&lt;string&gt;&amp; optionsSet, CLogSubsystem&amp; logSubsystem) {
+
+	const LuaTable&amp; optTbl = root.SubTable(index);
+	if (!optTbl.IsValid()) {
+		logOutput.Print(logSubsystem,
+				&quot;parseOption: subtable %d invalid&quot;, index);
+		return false;
+	}
+
+	// common options properties
+	opt.key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
+	if (opt.key.empty()
+			|| (opt.key.find_first_of(Option_badKeyChars) != string::npos)) {
+		logOutput.Print(logSubsystem,
+				&quot;parseOption: empty key or key contains bad characters&quot;);
+		return false;
+	}
+	opt.key = StringToLower(opt.key);
+	if (optionsSet.find(opt.key) != optionsSet.end()) {
+		logOutput.Print(logSubsystem, &quot;parseOption: key %s exists already&quot;,
+				opt.key.c_str());
+		return false;
+	}
+	opt.name = optTbl.GetString(&quot;name&quot;, opt.key);
+	if (opt.name.empty()) {
+		logOutput.Print(logSubsystem, &quot;parseOption: %s: empty name&quot;,
+				opt.key.c_str());
+		return false;
+	}
+	opt.desc = optTbl.GetString(&quot;desc&quot;, opt.name);
+
+	opt.section = optTbl.GetString(&quot;section&quot;, &quot;&quot;);
+	opt.style = optTbl.GetString(&quot;style&quot;, &quot;&quot;);
+
+	opt.type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
+	opt.type = StringToLower(opt.type);
+
+	// option type specific properties
+	if (opt.type == &quot;bool&quot;) {
+		opt.typeCode = opt_bool;
+		opt.boolDef = optTbl.GetBool(&quot;def&quot;, false);
+	}
+	else if (opt.type == &quot;number&quot;) {
+		opt.typeCode = opt_number;
+		opt.numberDef  = optTbl.GetFloat(&quot;def&quot;,  0.0f);
+		opt.numberMin  = optTbl.GetFloat(&quot;min&quot;,  -1.0e30f);
+		opt.numberMax  = optTbl.GetFloat(&quot;max&quot;,  +1.0e30f);
+		opt.numberStep = optTbl.GetFloat(&quot;step&quot;, 0.0f);
+	}
+	else if (opt.type == &quot;string&quot;) {
+		opt.typeCode = opt_string;
+		opt.stringDef    = optTbl.GetString(&quot;def&quot;, &quot;&quot;);
+		opt.stringMaxLen = optTbl.GetInt(&quot;maxlen&quot;, 0);
+	}
+	else if (opt.type == &quot;list&quot;) {
+		opt.typeCode = opt_list;
+
+		const LuaTable&amp; listTbl = optTbl.SubTable(&quot;items&quot;);
+		if (!listTbl.IsValid()) {
+			logOutput.Print(logSubsystem, &quot;parseOption: %s: subtable items invalid&quot;, opt.key.c_str());
+			return false;
+		}
+
+		for (int i = 1; listTbl.KeyExists(i); i++) {
+			OptionListItem item;
+
+			// string format
+			item.key = listTbl.GetString(i, &quot;&quot;);
+			if (!item.key.empty() &amp;&amp;
+			    (item.key.find_first_of(Option_badKeyChars) == string::npos)) {
+				item.name = item.key;
+				item.desc = item.name;
+				opt.list.push_back(item);
+				continue;
+			}
+
+			// table format  (name &amp; desc)
+			const LuaTable&amp; itemTbl = listTbl.SubTable(i);
+			if (!itemTbl.IsValid()) {
+				logOutput.Print(logSubsystem,
+						&quot;parseOption: %s: subtable %d of subtable items invalid&quot;,
+						opt.key.c_str(), i);
+				break;
+			}
+			item.key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
+			if (item.key.empty() || (item.key.find_first_of(Option_badKeyChars) != string::npos)) {
+				logOutput.Print(logSubsystem,
+						&quot;parseOption: %s: empty key or key contains bad characters&quot;,
+						opt.key.c_str());
+				return false;
+			}
+			item.key = StringToLower(item.key);
+			item.name = itemTbl.GetString(&quot;name&quot;, item.key);
+			if (item.name.empty()) {
+				logOutput.Print(logSubsystem, &quot;parseOption: %s: empty name&quot;,
+						opt.key.c_str());
+				return false;
+			}
+			item.desc = itemTbl.GetString(&quot;desc&quot;, item.name);
+			opt.list.push_back(item);
+		}
+
+		if (opt.list.size() &lt;= 0) {
+			logOutput.Print(logSubsystem, &quot;parseOption: %s: empty list&quot;,
+					opt.key.c_str());
+			return false; // no empty lists
+		}
+
+		opt.listDef = optTbl.GetString(&quot;def&quot;, opt.list[0].name);
+	}
+	else if (opt.type == &quot;section&quot;) {
+		opt.typeCode = opt_section;
+	}
+	else {
+		logOutput.Print(logSubsystem, &quot;parseOption: %s: unknown type %s&quot;,
+				opt.key.c_str(), opt.type.c_str());
+		return false; // unknown type
+	}
+
+	optionsSet.insert(opt.key);
+
+	return true;
+}
+
+
+void parseOptions(
+		std::vector&lt;Option&gt;&amp; options,
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes,
+		const std::string&amp; mapName,
+		std::set&lt;std::string&gt;* optionsSet,
+		CLogSubsystem* logSubsystem) {
+
+	if (!logSubsystem) {
+		assert(logSubsystem);
+	}
+
+	LuaParser luaParser(fileName, fileModes, accessModes);
+
+	const string configName = MapParser::GetMapConfigName(mapName);
+
+	if (!mapName.empty() &amp;&amp; !configName.empty()) {
+		luaParser.GetTable(&quot;Map&quot;);
+		luaParser.AddString(&quot;fileName&quot;, mapName);
+		luaParser.AddString(&quot;fullName&quot;, &quot;maps/&quot; + mapName);
+		luaParser.AddString(&quot;configFile&quot;, configName);
+		luaParser.EndTable();
+	}
+
+	if (!luaParser.Execute()) {
+		throw content_error(&quot;luaParser.Execute() failed: &quot;
+				+ luaParser.GetErrorLog());
+	}
+
+	const LuaTable root = luaParser.GetRoot();
+	if (!root.IsValid()) {
+		throw content_error(&quot;root table invalid&quot;);
+	}
+
+	std::set&lt;std::string&gt;* myOptionsSet = NULL;
+	if (optionsSet == NULL) {
+		myOptionsSet = new std::set&lt;std::string&gt;();
+	} else {
+		myOptionsSet = optionsSet;
+	}
+	for (int index = 1; root.KeyExists(index); index++) {
+		Option opt;
+		if (parseOption(root, index, opt, *myOptionsSet, *logSubsystem)) {
+			options.push_back(opt);
+		}
+	}
+	if (optionsSet == NULL) {
+		delete myOptionsSet;
+		myOptionsSet = NULL;
+	}
+}
+
+std::vector&lt;Option&gt; parseOptions(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes,
+		const std::string&amp; accessModes,
+		const std::string&amp; mapName,
+		std::set&lt;std::string&gt;* optionsSet,
+		CLogSubsystem* logSubsystem) {
+
+	std::vector&lt;Option&gt; options;
+
+	parseOptions(options, fileName, fileModes, accessModes, mapName, optionsSet,
+			logSubsystem);
+
+	return options;
+}
+
+#endif // _OPTION_CPP


Property changes on: branches/caiinterface/rts/System/Option.cpp
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/rts/System/Option.h (from rev 7034, branches/caiinterface/rts/ExternalAI/Interface/SOption.h)
===================================================================
--- branches/caiinterface/rts/System/Option.h	                        (rev 0)
+++ branches/caiinterface/rts/System/Option.h	2008-12-06 16:16:22 UTC (rev 7141)
@@ -0,0 +1,97 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+// The structs in this files relate to *Options.lua files
+// They are used for Mods and Skirmish AIs for example;
+// This file is used (at least) by unitsync and the engine
+
+#ifndef _OPTION_H
+#define	_OPTION_H
+
+#include &quot;System/FileSystem/VFSModes.h&quot;
+#include &quot;LogOutput.h&quot;
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &lt;set&gt;
+
+/**
+ * @brief Available mod/map/ai option types
+ * @sa GetOptionType
+ */
+enum OptionType {
+	opt_error   = 0, ///&lt; error
+	opt_bool    = 1, ///&lt; boolean option
+	opt_list    = 2, ///&lt; list option (e.g. combobox)
+	opt_number  = 3, ///&lt; numeric option (e.g. spinner / slider)
+	opt_string  = 4, ///&lt; string option (e.g. textbox)
+	opt_section = 5  ///&lt; option section (e.g. groupbox)
+};
+
+
+struct OptionListItem {
+	std::string key;
+	std::string name;
+	std::string desc;
+};
+
+
+struct Option {
+	Option() : typeCode(opt_error) {}
+
+	std::string key;
+	std::string name;
+	std::string desc;
+	std::string section;
+	std::string style;
+
+	std::string type; // &quot;bool&quot;, &quot;number&quot;, &quot;string&quot;, &quot;list&quot;, &quot;section&quot;
+
+	OptionType typeCode;
+
+	bool   boolDef;
+
+	float  numberDef;
+	float  numberMin;
+	float  numberMax;
+	float  numberStep; // aligned to numberDef
+
+	std::string stringDef;
+	int         stringMaxLen;
+
+	std::string listDef;
+	std::vector&lt;OptionListItem&gt; list;
+};
+
+void parseOptions(
+		std::vector&lt;Option&gt;&amp; options,
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes = SPRING_VFS_RAW,
+		const std::string&amp; accessModes = SPRING_VFS_RAW,
+		const std::string&amp; mapName = &quot;&quot;,
+		std::set&lt;std::string&gt;* optionsSet = NULL,
+		CLogSubsystem* logSubsystem = &amp;(CLogOutput::GetDefaultLogSubsystem()));
+
+std::vector&lt;Option&gt; parseOptions(
+		const std::string&amp; fileName,
+		const std::string&amp; fileModes = SPRING_VFS_RAW,
+		const std::string&amp; accessModes = SPRING_VFS_RAW,
+		const std::string&amp; mapName = &quot;&quot;,
+		std::set&lt;std::string&gt;* optionsSet = NULL,
+		CLogSubsystem* logSubsystem = &amp;(CLogOutput::GetDefaultLogSubsystem()));
+
+#endif // _OPTION_H


Property changes on: branches/caiinterface/rts/System/Option.h
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/build/scons/filelist.py
===================================================================
--- branches/caiinterface/rts/build/scons/filelist.py	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/rts/build/scons/filelist.py	2008-12-06 16:16:22 UTC (rev 7141)
@@ -147,8 +147,6 @@
 def get_shared_AI_source(env):
 	result = []
 	if env.has_key('builddir') and env['builddir']:
-		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SInfo.cpp')]
-		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SOption.cpp')]
 		result += [os.path.join(env['builddir'], 'rts/ExternalAI/Interface/SSkirmishAISpecifier.cpp')]
 		result += [os.path.join(env['builddir'], 'rts/Game/GameVersion.cpp')]
 #		result += [os.path.join(env['builddir'], 'rts/System/Platform/errorhandler.cpp')]

Modified: branches/caiinterface/tools/unitsync/CMakeLists.txt
===================================================================
--- branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-12-06 16:16:22 UTC (rev 7141)
@@ -44,8 +44,8 @@
 set(unitsync_files
 	../../rts/System/LogOutput
 	../../rts/System/TdfParser
+	../../rts/System/Info
 	../../rts/Sim/Misc/SideParser
-	../../rts/ExternalAI/Interface/SInfo
 	../../rts/Game/GameVersion
 	../../rts/Lua/LuaParser
 	../../rts/Lua/LuaUtils

Modified: branches/caiinterface/tools/unitsync/unitsync.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync.cpp	2008-12-06 15:25:35 UTC (rev 7140)
+++ branches/caiinterface/tools/unitsync/unitsync.cpp	2008-12-06 16:16:22 UTC (rev 7141)
@@ -22,12 +22,12 @@
 #include &quot;Sim/Misc/SideParser.h&quot;
 #include &quot;ExternalAI/Interface/aidefines.h&quot;
 //#include &quot;ExternalAI/Interface/SSkirmishAISpecifier.h&quot;
-#include &quot;ExternalAI/Interface/SInfo.h&quot;
-#include &quot;ExternalAI/Interface/SOption.h&quot;
 #include &quot;System/Exceptions.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Util.h&quot;
 #include &quot;System/exportdefines.h&quot;
+#include &quot;System/Info.h&quot;
+#include &quot;System/Option.h&quot;
 
 // unitsync only:
 #include &quot;LuaParserAPI.h&quot;
@@ -1578,177 +1578,19 @@
 //////////////////////////
 
 
-static vector&lt;Option&gt; options;
-static set&lt;string&gt; optionsSet;
+static std::vector&lt;Option&gt; options;
+static std::set&lt;std::string&gt; optionsSet;
 
-
-static bool ParseOption(const LuaTable&amp; root, int index, Option&amp; opt)
-{
-	const LuaTable&amp; optTbl = root.SubTable(index);
-	if (!optTbl.IsValid()) {
-		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: subtable %d invalid&quot;, index);
-		return false;
-	}
-
-	// common options properties
-	std::string opt_key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
-	if (opt_key.empty() ||
-		(opt_key.find_first_of(Option_badKeyChars) != std::string::npos)) {
-		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: empty key or key contains bad characters&quot;);
-		return false;
-	}
-	opt_key = StringToLower(opt_key);
-	if (optionsSet.find(opt_key) != optionsSet.end()) {
-		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: key %s exists already&quot;, opt_key.c_str());
-		return false;
-	}
-	opt.key = mallocCopyString(opt_key.c_str());
-	
-	std::string opt_name = optTbl.GetString(&quot;name&quot;, opt_key);
-	if (opt_name.empty()) {
-		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty name&quot;, opt.key);
-		return false;
-	}
-	opt.name = mallocCopyString(opt_name.c_str());
-	
-	std::string opt_desc = optTbl.GetString(&quot;desc&quot;, opt_name);
-	opt.desc = mallocCopyString(opt_desc.c_str());
-	
-	std::string opt_section = optTbl.GetString(&quot;section&quot;, &quot;&quot;);
-	opt.section = mallocCopyString(opt_section.c_str());
-	
-	std::string opt_style = optTbl.GetString(&quot;style&quot;, &quot;&quot;);
-	opt.style = mallocCopyString(opt_style.c_str());
-
-	std::string opt_type = optTbl.GetString(&quot;type&quot;, &quot;&quot;);
-	opt_type = StringToLower(opt_type);
-	opt.type = mallocCopyString(opt_type.c_str());
-
-	// option type specific properties
-	if (opt_type == &quot;bool&quot;) {
-		opt.typeCode = opt_bool;
-		opt.boolDef = optTbl.GetBool(&quot;def&quot;, false);
-	}
-	else if (opt_type == &quot;number&quot;) {
-		opt.typeCode = opt_number;
-		opt.numberDef  = optTbl.GetFloat(&quot;def&quot;,  0.0f);
-		opt.numberMin  = optTbl.GetFloat(&quot;min&quot;,  -1.0e30f);
-		opt.numberMax  = optTbl.GetFloat(&quot;max&quot;,  +1.0e30f);
-		opt.numberStep = optTbl.GetFloat(&quot;step&quot;, 0.0f);
-	}
-	else if (opt_type == &quot;string&quot;) {
-		opt.typeCode = opt_string;
-		opt.stringDef    = mallocCopyString(optTbl.GetString(&quot;def&quot;, &quot;&quot;).c_str());
-		opt.stringMaxLen = optTbl.GetInt(&quot;maxlen&quot;, 0);
-	}
-	else if (opt_type == &quot;list&quot;) {
-		opt.typeCode = opt_list;
-
-		const LuaTable&amp; listTbl = optTbl.SubTable(&quot;items&quot;);
-		if (!listTbl.IsValid()) {
-			logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: subtable items invalid&quot;, opt.key);
-			return false;
-		}
-
-		vector&lt;OptionListItem&gt; opt_list;
-		for (int i = 1; listTbl.KeyExists(i); i++) {
-			OptionListItem item;
-
-			// string format
-			std::string item_key = listTbl.GetString(i, &quot;&quot;);
-			if (!item_key.empty() &amp;&amp;
-				(item_key.find_first_of(Option_badKeyChars) == string::npos)) {
-				item.key = mallocCopyString(item_key.c_str());
-				item.name = item.key;
-				item.desc = item.name;
-				opt_list.push_back(item);
-				continue;
-			}
-
-			// table format  (name &amp; desc)
-			const LuaTable&amp; itemTbl = listTbl.SubTable(i);
-			if (!itemTbl.IsValid()) {
-				logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: subtable %d of subtable items invalid&quot;, opt.key, i);
-				break;
-			}
-			item_key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
-			if (item_key.empty() ||
-				(item_key.find_first_of(Option_badKeyChars) != string::npos)) {
-				logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty key or key contains bad characters&quot;, opt.key);
-				return false;
-			}
-			item_key = StringToLower(item_key);
-			item.key = mallocCopyString(item_key.c_str());
-			std::string item_name = itemTbl.GetString(&quot;name&quot;, item_key);
-			if (item_name.empty()) {
-				logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty name&quot;, opt.key);
-				return false;
-			}
-			item.name = mallocCopyString(item_name.c_str());
-			std::string item_desc = itemTbl.GetString(&quot;desc&quot;, item_name);
-			item.desc = mallocCopyString(item_desc.c_str());
-			opt_list.push_back(item);
-		}
-
-		if (opt_list.size() &lt;= 0) {
-			logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty list&quot;, opt.key);
-			return false; // no empty lists
-		}
-
-		opt.numListItems = opt_list.size();
-		opt.list = (OptionListItem*) calloc(sizeof(OptionListItem), opt.numListItems);
-		for (int i=0; i &lt; opt.numListItems; ++i) {
-			opt.list[i] = opt_list.at(i);
-		}
-
-		opt.listDef = mallocCopyString(optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str());
-	}
-	else {
-		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: unknown type %s&quot;, opt.key, opt_type.c_str());
-		return false; // unknown type
-	}
-
-	optionsSet.insert(opt.key);
-
-	return true;
-}
-
-
 static void ParseOptions(const string&amp; fileName,
                          const string&amp; fileModes,
                          const string&amp; accessModes,
                          const string&amp; mapName = &quot;&quot;)
 {
-	LuaParser luaParser(fileName, fileModes, accessModes);
+	parseOptions(options, fileName, fileModes, accessModes, mapName,
+			&amp;optionsSet, &amp;LOG_UNITSYNC);
+}
 
-	const string configName = MapParser::GetMapConfigName(mapName);
 
-	if (!mapName.empty() &amp;&amp; !configName.empty()) {
-		luaParser.GetTable(&quot;Map&quot;);
-		luaParser.AddString(&quot;fileName&quot;, mapName);
-		luaParser.AddString(&quot;fullName&quot;, &quot;maps/&quot; + mapName);
-		luaParser.AddString(&quot;configFile&quot;, configName);
-		luaParser.EndTable();
-	}
-
-	if (!luaParser.Execute()) {
-		throw content_error(&quot;luaParser.Execute() failed: &quot; + luaParser.GetErrorLog());
-	}
-
-	const LuaTable root = luaParser.GetRoot();
-	if (!root.IsValid()) {
-		throw content_error(&quot;root table invalid&quot;);
-	}
-
-	for (int index = 1; root.KeyExists(index); index++) {
-		Option opt;
-		if (ParseOption(root, index, opt)) {
-			options.push_back(opt);
-		}
-	}
-};
-
-
 static void CheckOptionIndex(int optIndex)
 {
 	CheckInit();
@@ -1828,23 +1670,23 @@
 }
 
 
-vector&lt;InfoItem&gt; infos;
-set&lt;string&gt; infosSet;
-
 // Updated on every call to GetSkirmishAICount
-static vector&lt;string&gt; skirmishAIDataDirs;
+static vector&lt;std::string&gt; skirmishAIDataDirs;
 
 EXPORT(int) GetSkirmishAICount() {
 
 	try {
 		CheckInit();
 
-		skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
+		skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;,
+				SPRING_VFS_RAW);
 
 		// filter out dirs not containing an AIInfo.lua file 
-		for (vector&lt;string&gt;::iterator i = skirmishAIDataDirs.begin(); i != skirmishAIDataDirs.end(); ++i) {
-			const string&amp; possibleDataDir = *i;
-			vector&lt;string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+		for (vector&lt;std::string&gt;::iterator i = skirmishAIDataDirs.begin();
+				i != skirmishAIDataDirs.end(); ++i) {
+			const std::string&amp; possibleDataDir = *i;
+			vector&lt;std::string&gt; infoFile = CFileHandler::FindFiles(
+					possibleDataDir, &quot;AIInfo.lua&quot;);
 			if (infoFile.size() == 0) {
 				skirmishAIDataDirs.erase(i);
 			}
@@ -1861,28 +1703,21 @@
 	return 0;
 }
 
-std::vector&lt;InfoItem&gt; ParseInfos(
-		const std::string&amp; fileName,
-		const std::string&amp; fileModes,
-		const std::string&amp; accessModes)
-{
-	std::vector&lt;InfoItem&gt; info;
 
-	static const unsigned int MAX_INFOS = 128;
-	InfoItem tmpInfo[MAX_INFOS];
-	unsigned int num = ParseInfo(fileName.c_str(), fileModes.c_str(),
-			accessModes.c_str(), tmpInfo, MAX_INFOS);
-	for (unsigned int i=0; i &lt; num; ++i) {
-		info.push_back(tmpInfo[i]);
-	}
+static std::vector&lt;InfoItem&gt; info;
+static std::set&lt;std::string&gt; infoSet;
 
-	return info;
+static void ParseInfo(const std::string&amp; fileName,
+                      const std::string&amp; fileModes,
+                      const std::string&amp; accessModes)
+{
+	parseInfo(info, fileName, fileModes, accessModes, &amp;infoSet, &amp;LOG_UNITSYNC);
 }
 
 static void CheckInfoIndex(int infIndex)
 {
 	CheckInit();
-	CheckBounds(infIndex, infos.size());
+	CheckBounds(infIndex, info.size());
 }
 
 EXPORT(int) GetSkirmishAIInfoCount(int index) {
@@ -1890,12 +1725,19 @@
 	try {
 		CheckInit();
 
-		infos = ParseInfos(skirmishAIDataDirs[index] + &quot;/AIInfo.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
-		return (int)infos.size();
+		info.clear();
+		infoSet.clear();
+
+		ParseInfo(skirmishAIDataDirs[index] + &quot;/AIInfo.lua&quot;, SPRING_VFS_RAW,
+				SPRING_VFS_RAW);
+
+		infoSet.clear();
+
+		return (int)info.size();
 	}
 	UNITSYNC_CATCH_BLOCKS;
 
-	infos.clear();
+	info.clear();
 
 	return 0;
 }
@@ -1903,7 +1745,7 @@
 
 	try {
 		CheckInfoIndex(index);
-		return GetStr(infos[index].key);
+		return GetStr(info[index].key);
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return NULL;
@@ -1912,7 +1754,7 @@
 
 	try {
 		CheckInfoIndex(index);
-		return GetStr(infos[index].value);
+		return GetStr(info[index].value);
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return NULL;
@@ -1921,7 +1763,7 @@
 
 	try {
 		CheckInfoIndex(index);
-		return GetStr(infos[index].desc);
+		return GetStr(info[index].desc);
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return NULL;
@@ -1953,7 +1795,8 @@
 		options.clear();
 		optionsSet.clear();
 
-		ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+		ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;,
+				SPRING_VFS_RAW, SPRING_VFS_RAW);
 
 		optionsSet.clear();
 
@@ -2239,7 +2082,7 @@
 {
 	try {
 		CheckOptionType(optIndex, opt_list);
-		return options[optIndex].numListItems;
+		return options[optIndex].list.size();
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return 0;
@@ -2278,8 +2121,9 @@
 {
 	try {
 		CheckOptionType(optIndex, opt_list);
-		CheckBounds(itemIndex, options[optIndex].numListItems);
-		return GetStr(options[optIndex].list[itemIndex].key);
+		const vector&lt;OptionListItem&gt;&amp; list = options[optIndex].list;
+		CheckBounds(itemIndex, list.size());
+		return GetStr(list[itemIndex].key);
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return NULL;
@@ -2299,8 +2143,9 @@
 {
 	try {
 		CheckOptionType(optIndex, opt_list);
-		CheckBounds(itemIndex, options[optIndex].numListItems);
-		return GetStr(options[optIndex].list[itemIndex].name);
+		const vector&lt;OptionListItem&gt;&amp; list = options[optIndex].list;
+		CheckBounds(itemIndex, list.size());
+		return GetStr(list[itemIndex].name);
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return NULL;
@@ -2320,8 +2165,9 @@
 {
 	try {
 		CheckOptionType(optIndex, opt_list);
-		CheckBounds(itemIndex, options[optIndex].numListItems);
-		return GetStr(options[optIndex].list[itemIndex].desc);
+		const vector&lt;OptionListItem&gt;&amp; list = options[optIndex].list;
+		CheckBounds(itemIndex, list.size());
+		return GetStr(list[itemIndex].desc);
 	}
 	UNITSYNC_CATCH_BLOCKS;
 	return NULL;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001909.html">[Taspring-linux-commit] r7140 - in Lobby/springie/Springie: .	PlanetWars
</A></li>
	<LI>Next message: <A HREF="001911.html">[Taspring-linux-commit] r7142 - Lobby/springie/Springie/PlanetWars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1910">[ date ]</a>
              <a href="thread.html#1910">[ thread ]</a>
              <a href="subject.html#1910">[ subject ]</a>
              <a href="author.html#1910">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
