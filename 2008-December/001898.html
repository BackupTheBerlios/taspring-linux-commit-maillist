<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7129 - in branches/caiinterface: . AI/Interfaces AI/Interfaces/C AI/Interfaces/C/data AI/Interfaces/Java AI/Interfaces/Java/bin AI/Interfaces/Java/data AI/Interfaces/Java/java AI/Interfaces/Java/java/src AI/Interfaces/Java/java/src/com AI/Interfaces/Java/java/src/com/clan_sy AI/Interfaces/Java/java/src/com/clan_sy/spring AI/Interfaces/Java/java/src/com/clan_sy/spring/ai AI/Interfaces/Java/jlib AI/Interfaces/Java/jlib/jna AI/Skirmish AI/Skirmish/AAI AI/Skirmish/AAI/data AI/Skirmish/AAI/data/cache AI/Skirmish/AAI/data/cfg AI/Skirmish/AAI/data/learn AI/Skirmish/AAI/data/log AI/Skirmish/CSAI AI/Skirmish/JCAI AI/Skirmish/KAI AI/Skirmish/KAIK AI/Skirmish/KAIK/data AI/Skirmish/NTai AI/Skirmish/NullAI AI/Skirmish/NullAI/data AI/Skirmish/NullJavaAI AI/Skirmish/NullJavaAI/data AI/Skirmish/NullJavaAI/nulljavaai AI/Skirmish/NullLegacyCppAI AI/Skirmish/NullLegacyCppAI/data AI/Skirmish/NullOOJavaAI AI/Skirmish/NullOOJavaAI/data AI/Skirmish/NullOOJavaAI/nulloojavaai AI/Skirmish/RA I AI/Skirmish/RAI/data game/AI rts/build/scons
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7129%20-%20in%20branches/caiinterface%3A%20.%0A%20AI/Interfaces%20AI/Interfaces/C%20AI/Interfaces/C/data%20AI/Interfaces/Java%0A%20AI/Interfaces/Java/bin%20AI/Interfaces/Java/data%20AI/Interfaces/Java/java%0A%20AI/Interfaces/Java/java/src%20AI/Interfaces/Java/java/src/com%0A%20AI/Interfaces/Java/java/src/com/clan_sy%0A%20AI/Interfaces/Java/java/src/com/clan_sy/spring%0A%20AI/Interfaces/Java/java/src/com/clan_sy/spring/ai%20AI/Interfaces/Java/jlib%0A%20AI/Interfaces/Java/jlib/jna%20AI/Skirmish%20AI/Skirmish/AAI%0A%20AI/Skirmish/AAI/data%20AI/Skirmish/AAI/data/cache%20AI/Skirmish/AAI/data/cfg%0A%20AI/Skirmish/AAI/data/learn%20AI/Skirmish/AAI/data/log%20AI/Skirmish/CSAI%0A%20AI/Skirmish/JCAI%20AI/Skirmish/KAI%20AI/Skirmish/KAIK%20AI/Skirmish/KAIK/data%0A%20AI/Skirmish/NTai%20AI/Skirmish/NullAI%20AI/Skirmish/NullAI/data%0A%20AI/Skirmish/NullJavaAI%20AI/Skirmish/NullJavaAI/data%0A%20AI/Skirmish/NullJavaAI/nulljavaai%20AI/Skirmish/NullLegacyCppAI%0A%20AI/Skirmish/NullLegacyCppAI/data%20AI/Skirmish/NullOOJavaAI%0A%20AI/Skirmish/NullOOJavaAI/data%20AI/Skirmish/NullOOJavaAI/nulloojavaai%0A%20AI/Skirmish/RA%20I%20AI/Skirmish/RAI/data%20game/AI%20rts/build/scons&In-Reply-To=%3C20081205161252.B743A476B%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001897.html">
   <LINK REL="Next"  HREF="001899.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7129 - in branches/caiinterface: . AI/Interfaces AI/Interfaces/C AI/Interfaces/C/data AI/Interfaces/Java AI/Interfaces/Java/bin AI/Interfaces/Java/data AI/Interfaces/Java/java AI/Interfaces/Java/java/src AI/Interfaces/Java/java/src/com AI/Interfaces/Java/java/src/com/clan_sy AI/Interfaces/Java/java/src/com/clan_sy/spring AI/Interfaces/Java/java/src/com/clan_sy/spring/ai AI/Interfaces/Java/jlib AI/Interfaces/Java/jlib/jna AI/Skirmish AI/Skirmish/AAI AI/Skirmish/AAI/data AI/Skirmish/AAI/data/cache AI/Skirmish/AAI/data/cfg AI/Skirmish/AAI/data/learn AI/Skirmish/AAI/data/log AI/Skirmish/CSAI AI/Skirmish/JCAI AI/Skirmish/KAI AI/Skirmish/KAIK AI/Skirmish/KAIK/data AI/Skirmish/NTai AI/Skirmish/NullAI AI/Skirmish/NullAI/data AI/Skirmish/NullJavaAI AI/Skirmish/NullJavaAI/data AI/Skirmish/NullJavaAI/nulljavaai AI/Skirmish/NullLegacyCppAI AI/Skirmish/NullLegacyCppAI/data AI/Skirmish/NullOOJavaAI AI/Skirmish/NullOOJavaAI/data AI/Skirmish/NullOOJavaAI/nulloojavaai AI/Skirmish/RA I AI/Skirmish/RAI/data game/AI rts/build/scons</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7129%20-%20in%20branches/caiinterface%3A%20.%0A%20AI/Interfaces%20AI/Interfaces/C%20AI/Interfaces/C/data%20AI/Interfaces/Java%0A%20AI/Interfaces/Java/bin%20AI/Interfaces/Java/data%20AI/Interfaces/Java/java%0A%20AI/Interfaces/Java/java/src%20AI/Interfaces/Java/java/src/com%0A%20AI/Interfaces/Java/java/src/com/clan_sy%0A%20AI/Interfaces/Java/java/src/com/clan_sy/spring%0A%20AI/Interfaces/Java/java/src/com/clan_sy/spring/ai%20AI/Interfaces/Java/jlib%0A%20AI/Interfaces/Java/jlib/jna%20AI/Skirmish%20AI/Skirmish/AAI%0A%20AI/Skirmish/AAI/data%20AI/Skirmish/AAI/data/cache%20AI/Skirmish/AAI/data/cfg%0A%20AI/Skirmish/AAI/data/learn%20AI/Skirmish/AAI/data/log%20AI/Skirmish/CSAI%0A%20AI/Skirmish/JCAI%20AI/Skirmish/KAI%20AI/Skirmish/KAIK%20AI/Skirmish/KAIK/data%0A%20AI/Skirmish/NTai%20AI/Skirmish/NullAI%20AI/Skirmish/NullAI/data%0A%20AI/Skirmish/NullJavaAI%20AI/Skirmish/NullJavaAI/data%0A%20AI/Skirmish/NullJavaAI/nulljavaai%20AI/Skirmish/NullLegacyCppAI%0A%20AI/Skirmish/NullLegacyCppAI/data%20AI/Skirmish/NullOOJavaAI%0A%20AI/Skirmish/NullOOJavaAI/data%20AI/Skirmish/NullOOJavaAI/nulloojavaai%0A%20AI/Skirmish/RA%20I%20AI/Skirmish/RAI/data%20game/AI%20rts/build/scons&In-Reply-To=%3C20081205161252.B743A476B%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7129 - in branches/caiinterface: . AI/Interfaces AI/Interfaces/C AI/Interfaces/C/data AI/Interfaces/Java AI/Interfaces/Java/bin AI/Interfaces/Java/data AI/Interfaces/Java/java AI/Interfaces/Java/java/src AI/Interfaces/Java/java/src/com AI/Interfaces/Java/java/src/com/clan_sy AI/Interfaces/Java/java/src/com/clan_sy/spring AI/Interfaces/Java/java/src/com/clan_sy/spring/ai AI/Interfaces/Java/jlib AI/Interfaces/Java/jlib/jna AI/Skirmish AI/Skirmish/AAI AI/Skirmish/AAI/data AI/Skirmish/AAI/data/cache AI/Skirmish/AAI/data/cfg AI/Skirmish/AAI/data/learn AI/Skirmish/AAI/data/log AI/Skirmish/CSAI AI/Skirmish/JCAI AI/Skirmish/KAI AI/Skirmish/KAIK AI/Skirmish/KAIK/data AI/Skirmish/NTai AI/Skirmish/NullAI AI/Skirmish/NullAI/data AI/Skirmish/NullJavaAI AI/Skirmish/NullJavaAI/data AI/Skirmish/NullJavaAI/nulljavaai AI/Skirmish/NullLegacyCppAI AI/Skirmish/NullLegacyCppAI/data AI/Skirmish/NullOOJavaAI AI/Skirmish/NullOOJavaAI/data AI/Skirmish/NullOOJavaAI/nulloojavaai AI/Skirmish/RA I AI/Skirmish/RAI/data game/AI rts/build/scons">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Dec  5 17:12:52 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001897.html">[Taspring-linux-commit] r7128 - trunk/rts/Rendering/GL
</A></li>
        <LI>Next message: <A HREF="001899.html">[Taspring-linux-commit] r7130 - in	branches/caiinterface/AI/Skirmish: . AAI AAI/data	AAI/data/cfg/mod NTai/AI/NTai/Core NTai/data
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1898">[ date ]</a>
              <a href="thread.html#1898">[ thread ]</a>
              <a href="subject.html#1898">[ subject ]</a>
              <a href="author.html#1898">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-05 17:12:49 +0100 (Fri, 05 Dec 2008)
New Revision: 7129

Added:
   branches/caiinterface/AI/Interfaces/C/data/
   branches/caiinterface/AI/Interfaces/C/data/InterfaceInfo.lua
   branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h
   branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
   branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h
   branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
   branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
   branches/caiinterface/AI/Interfaces/Java/Log.c
   branches/caiinterface/AI/Interfaces/Java/Log.h
   branches/caiinterface/AI/Interfaces/Java/README
   branches/caiinterface/AI/Interfaces/Java/StreflopBridge.cpp
   branches/caiinterface/AI/Interfaces/Java/StreflopBridge.h
   branches/caiinterface/AI/Interfaces/Java/VERSION
   branches/caiinterface/AI/Interfaces/Java/bin/
   branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.bat
   branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.sh
   branches/caiinterface/AI/Interfaces/Java/bin/java_compile.bat
   branches/caiinterface/AI/Interfaces/Java/bin/java_compile.sh
   branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.bat
   branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.sh
   branches/caiinterface/AI/Interfaces/Java/bin/java_install.bat
   branches/caiinterface/AI/Interfaces/Java/bin/java_install.sh
   branches/caiinterface/AI/Interfaces/Java/bin/java_wrappCallbackOO.awk
   branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCallback.awk
   branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCommands.awk
   branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappEvents.awk
   branches/caiinterface/AI/Interfaces/Java/bin/native_createCallbackFPInitializations.awk
   branches/caiinterface/AI/Interfaces/Java/data/
   branches/caiinterface/AI/Interfaces/Java/data/InterfaceInfo.lua
   branches/caiinterface/AI/Interfaces/Java/java/
   branches/caiinterface/AI/Interfaces/Java/java/src/
   branches/caiinterface/AI/Interfaces/Java/java/src/com/
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AI.java
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AICommand.java
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIEvent.java
   branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIFloat3.java
   branches/caiinterface/AI/Interfaces/Java/jlib/
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/freebsd-amd64.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/freebsd-i386.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/jna.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/linux-amd64.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/linux-i386.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/mac-darwin.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/win32-amd64.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/jna/win32-x86.jar
   branches/caiinterface/AI/Interfaces/Java/jlib/vecmath.jar
   branches/caiinterface/AI/Skirmish/AAI/data/
   branches/caiinterface/AI/Skirmish/AAI/data/AAI FAQ.txt
   branches/caiinterface/AI/Skirmish/AAI/data/AAI ReadMe.txt
   branches/caiinterface/AI/Skirmish/AAI/data/cache/
   branches/caiinterface/AI/Skirmish/AAI/data/cfg/
   branches/caiinterface/AI/Skirmish/AAI/data/learn/
   branches/caiinterface/AI/Skirmish/AAI/data/log/
   branches/caiinterface/AI/Skirmish/CSAI/data/
   branches/caiinterface/AI/Skirmish/JCAI/data/
   branches/caiinterface/AI/Skirmish/KAI/data/
   branches/caiinterface/AI/Skirmish/KAIK/data/
   branches/caiinterface/AI/Skirmish/KAIK/data/AIInfo.lua
   branches/caiinterface/AI/Skirmish/KAIK/data/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NTai/data/
   branches/caiinterface/AI/Skirmish/NullAI/data/
   branches/caiinterface/AI/Skirmish/NullAI/data/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullJavaAI/
   branches/caiinterface/AI/Skirmish/NullJavaAI/VERSION
   branches/caiinterface/AI/Skirmish/NullJavaAI/data/
   branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NullJavaAI/manifest.mf
   branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/
   branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java
   branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/
   branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/VERSION
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/manifest.mf
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java
   branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAIFactory.java
   branches/caiinterface/AI/Skirmish/RAI/data/
   branches/caiinterface/AI/Skirmish/RAI/data/AIInfo.lua
   branches/caiinterface/AI/Skirmish/RAI/data/AIOptions.lua
Removed:
   branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua
   branches/caiinterface/AI/Skirmish/KAIK/AIInfo.lua
   branches/caiinterface/AI/Skirmish/KAIK/AIOptions.lua
   branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIInfo.lua
   branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIOptions.lua
   branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua
   branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua
   branches/caiinterface/game/AI/AAI/
   branches/caiinterface/game/AI/Bot-libs/
   branches/caiinterface/game/AI/Helper-libs/
Modified:
   branches/caiinterface/AI/Interfaces/CMakeLists.txt
   branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c
   branches/caiinterface/AI/Skirmish/CMakeLists.txt
   branches/caiinterface/SConstruct
   branches/caiinterface/rts/build/scons/filelist.py
Log:
* Initial upload of the Java Interface
* Initial upload of NullJavaAI and NullOOJavaAI
* CMake and Scons can now also both build the Java AI Interface and Java AIs
* moved data files of Interfaces and Skimrish AIs to data subfolders (examples: AIInfo.lua, AIOptions.lua, InterfaceInfo.lua, (AAI) config files)

Deleted: branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua
===================================================================
--- branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,52 +0,0 @@
---
---  Info Definition Table format
---
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      user defined or one of the AI_INTERFACE_PROPERTY_* defines in
---            SAIInterfaceLibrary.h
---  value:    the value of the property
---  desc:     the description (could be used as a tooltip)
---
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local infos = {
-	{
-		key    = 'fileName',
-		value  = 'C-0.1',
-		desc   = 'base of the library file of this AI. &quot;C-0.1&quot; means &quot;AI/Interfaces/impls/libC-0.1.so&quot;, &quot;AI/Interfaces/impls/libC-0.1.dylib&quot; or &quot;AI/Interfaces/impls/C-0.1.dll&quot;',
-	},
-	{
-		key    = 'shortName',
-		value  = 'C',
-		desc   = 'machine conform name.',
-	},
-	{
-		key    = 'version',
-		value  = '0.1',
-	},
-	{
-		key    = 'name',
-		value  = 'default C AI Interface',
-		desc   = 'human readable name.',
-	},
-	{
-		key    = 'description',
-		value  = 'This interface is needed for C and C++ AIs',
-		desc   = 'tooltip.',
-	},
-	{
-		key    = 'url',
-		value  = '<A HREF="http://spring.clan-sy.com/wiki/AIInterface:C">http://spring.clan-sy.com/wiki/AIInterface:C</A>',
-		desc   = 'URL with more detailed info about the AI',
-	},
-	{
-		key    = 'supportedLanguages',
-		value  = 'C, C++',
-	},
-}
-
-return infos

Copied: branches/caiinterface/AI/Interfaces/C/data/InterfaceInfo.lua (from rev 7034, branches/caiinterface/AI/Interfaces/C/InterfaceInfo.lua)
===================================================================
--- branches/caiinterface/AI/Interfaces/C/data/InterfaceInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/C/data/InterfaceInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,52 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the AI_INTERFACE_PROPERTY_* defines in
+--            SAIInterfaceLibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'C-0.1',
+		desc   = 'base of the library file of this AI. &quot;C-0.1&quot; means &quot;AI/Interfaces/impls/libC-0.1.so&quot;, &quot;AI/Interfaces/impls/libC-0.1.dylib&quot; or &quot;AI/Interfaces/impls/C-0.1.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'C',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'name',
+		value  = 'default C AI Interface',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'This interface is needed for C and C++ AIs',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AIInterface:C">http://spring.clan-sy.com/wiki/AIInterface:C</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'supportedLanguages',
+		value  = 'C, C++',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Interfaces/C/data/InterfaceInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Modified: branches/caiinterface/AI/Interfaces/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-12-05 16:12:49 UTC (rev 7129)
@@ -22,6 +22,10 @@
 	set(C_AIINTERFACE_DATA_DIR ${AI_INTERFACES_DATA}/C/${C_AIINTERFACE_VERS})
 	message(STATUS &quot;${C_AIINTERFACE_VERS}\t(C AI Interface Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${C_AIINTERFACE_SRC}/data/&quot;
+			DESTINATION &quot;${C_AIINTERFACE_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${C_AIINTERFACE_SRC} cAIInterface)
 	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/SharedLib)
 	if (UNIX)
@@ -30,8 +34,7 @@
 		list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/Win/DllLib)
 	endif (UNIX)
 	add_library(${C_AIINTERFACE_TARGET} MODULE ${cAIInterface} ${aienv}) # ${errorhandler})
-	install (FILES ${C_AIINTERFACE_SRC}/InterfaceInfo.lua DESTINATION ${C_AIINTERFACE_DATA_DIR})
-	install (TARGETS ${C_AIINTERFACE_TARGET} DESTINATION ${C_AIINTERFACE_DATA_DIR})
+	install(TARGETS ${C_AIINTERFACE_TARGET} DESTINATION ${C_AIINTERFACE_DATA_DIR})
 endif (EXISTS ${C_AIINTERFACE_SRC})
 
 
@@ -76,11 +79,14 @@
 	set(Java_AIINTERFACE_CLASSPATH &quot;.:${PATH_DELIM}${Java_AIINTERFACE_SRC}/jlib/jna/jna.jar${PATH_DELIM}${Java_AIINTERFACE_SRC}/jlib/vecmath.jar&quot;)
 	message(STATUS &quot;${Java_AIINTERFACE_VERS}\t(Java AI Interface Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${Java_AIINTERFACE_SRC}/data/&quot;
+			DESTINATION &quot;${Java_AIINTERFACE_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	# handle native part
 	aux_source_directory(${Java_AIINTERFACE_SRC} javaAIInterface)
 	add_library(${Java_AIINTERFACE_TARGET} MODULE ${javaAIInterface} ${aienv})
 	target_link_libraries(${Java_AIINTERFACE_TARGET} ${JAVA_JVM_LIBRARY})
-	install(FILES ${Java_AIINTERFACE_SRC}/InterfaceInfo.lua DESTINATION ${Java_AIINTERFACE_DATA_DIR})
 	install(TARGETS ${Java_AIINTERFACE_TARGET} DESTINATION ${Java_AIINTERFACE_DATA_DIR})
 	INCLUDE_DIRECTORIES(BEFORE ${CMAKE_SOURCE_DIR}/rts/lib/streflop)
 	TARGET_LINK_LIBRARIES(${Java_AIINTERFACE_TARGET} streflop)
@@ -103,11 +109,6 @@
 		WORKING_DIRECTORY &quot;${Java_AIINTERFACE_SRC}/bin&quot;
 		COMMENT &quot;  Creating Java library interface.jar ...&quot; VERBATIM)
 	install(FILES ${Java_AIINTERFACE_SRC}/interface.jar DESTINATION ${Java_AIINTERFACE_DATA_DIR})
-	#install(FILES ${Java_AIINTERFACE_SRC}/java/interface.jar DESTINATION ${Java_AIINTERFACE_DATA_DIR}/jlib)
 	install(DIRECTORY ${Java_AIINTERFACE_SRC}/jlib/ DESTINATION ${Java_AIINTERFACE_DATA_DIR}/jlib FILES_MATCHING PATTERN &quot;*.jar&quot;)
-
-# Install the Java test Skirmish AI (only a temp solution here, move it to AI/Skirmish/...)
-#install (FILES ${Java_AIINTERFACE_SRC}/java/ai.jar DESTINATION ${CMAKE_SOURCE_DIR}/AI/Skirmish/hoijuiAI/${Java_AIINTERFACE_VERS})
-#install (FILES ${Java_AIINTERFACE_SRC}/AIInfo.lua DESTINATION ${CMAKE_SOURCE_DIR}/AI/Skirmish/hoijuiAI/${Java_AIINTERFACE_VERS})
 endif (JNI_FOUND AND JAVA_FOUND AND EXISTS ${Java_AIINTERFACE_SRC} AND EXISTS ${Java_AIINTERFACE_SRC}/bin)
 

Added: branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,41 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+ */
+
+#ifndef _INTERFACEDEFINES_H
+#define	_INTERFACEDEFINES_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define JAVA_SKIRMISH_AI_PROPERTY_CLASS_NAME &quot;className&quot;
+
+#define MY_SHORT_NAME &quot;Java&quot;
+#define MY_VERSION &quot;0.1&quot;
+#define MY_NAME &quot;Java AI Interface&quot;
+#define MY_LOG_FILE &quot;log.txt&quot;
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	// _INTERFACEDEFINES_H
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/InterfaceDefines.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,289 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;InterfaceExport.h&quot;
+
+#include &quot;InterfaceDefines.h&quot;
+#include &quot;InterfaceUtil.h&quot;
+#include &quot;JavaBridge.h&quot;
+#include &quot;Log.h&quot;
+
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot;
+
+#include &lt;stdbool.h&gt;	// bool, true, false
+#include &lt;string.h&gt;	// strlen(), strcat(), strcpy()
+#include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
+
+// static -&gt; file local vars
+//static struct InfoItem* myInfo = NULL;
+/*
+static struct InfoItem myInfo[16];
+static unsigned int myNumInfoItems = 0;
+*/
+static const struct SStaticGlobalData* staticGlobalData = NULL;
+/*
+static const char* myDataDir = NULL;
+static const char* myDataDirVers = NULL;
+*/
+
+EXPORT(int) initStatic(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const struct SStaticGlobalData* _staticGlobalData) {
+
+	bool success = false;
+
+
+	// initialize C part fo the interface
+	staticGlobalData = _staticGlobalData;
+
+	// example: &quot;AI/Interfaces/Java&quot;
+	//const char* myDataDirRelative = AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME;
+	char myDataDirRelative[128];
+	strcpy(myDataDirRelative, AI_INTERFACES_DATA_DIR);
+	strcat(myDataDirRelative, sPS&quot;&quot;MY_SHORT_NAME);
+	// example: &quot;AI/Interfaces/Java/0.1&quot;
+	//const char* myDataDirVersRelative =
+	//		AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION;
+	char myDataDirVersRelative[128];
+	strcpy(myDataDirVersRelative, AI_INTERFACES_DATA_DIR);
+	strcat(myDataDirVersRelative, sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION);
+
+	// &quot;C:/Games/spring/AI/Interfaces/C&quot;
+	char* myDataDir = util_allocStr(1024);
+	bool exists = util_findDir(staticGlobalData-&gt;dataDirs,
+			staticGlobalData-&gt;numDataDirs, myDataDirRelative, myDataDir, true,
+			true);
+	if (!exists) {
+		simpleLog_error(-1, &quot;Failed to create &quot;MY_NAME&quot; data directory.&quot;);
+	}
+
+	// &quot;C:/Games/spring/AI/Interfaces/C/0.1&quot;
+	char* myDataDirVers = util_allocStr(1024);
+	exists = util_findDir(staticGlobalData-&gt;dataDirs,
+			staticGlobalData-&gt;numDataDirs, myDataDirVersRelative, myDataDirVers,
+			true, true);
+	if (!exists) {
+		simpleLog_error(-2, &quot;Failed to create &quot;MY_NAME&quot; versioned data directory.&quot;);
+	}
+
+	char* logFileName = util_allocStr(strlen(myDataDirVers) + 1 + strlen(MY_LOG_FILE));
+	logFileName[0]= '\0';
+	logFileName = strcat(logFileName, myDataDirVers);
+	logFileName = strcat(logFileName, sPS);
+	logFileName = strcat(logFileName, MY_LOG_FILE);
+	simpleLog_init(logFileName, true, true);
+	util_setDataDirs(myDataDir, myDataDirVers);
+
+	simpleLog_log(&quot;This is the log-file of the %s v%s&quot;, MY_NAME, MY_VERSION);
+	simpleLog_log(&quot;Using data-directory (version-less): %s&quot;, myDataDir);
+	simpleLog_log(&quot;Using data-directory (version specific): %s&quot;, myDataDirVers);
+	simpleLog_log(&quot;Using log file: %s&quot;, logFileName);
+	free(logFileName);
+
+
+	// initialize Java part of the interface
+	success = java_initStatic(staticGlobalData);
+	// load the JVM
+	success = success &amp;&amp; java_preloadJNIEnv();
+	simpleLog_fine(&quot;initStatic java_preloadJNIEnv done.&quot;);
+
+	return success ? 0 : -1;
+}
+
+EXPORT(int) releaseStatic() {
+
+	bool success = false;
+
+	// release Java part of the interface
+	success = java_releaseStatic();
+	success = success &amp;&amp; java_unloadJNIEnv();
+
+	// release C part of the interface
+	free(util_getDataDirVersioned());
+	free(util_getDataDirUnversioned());
+
+	return success ? 0 : -1;
+}
+
+EXPORT(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersion, int engineAIInterfaceGeneratedVersion) {
+
+/*
+	if (strcmp(engineVersionString, ENGINE_VERSION_STRING) == 0 &amp;&amp;
+			engineVersionNumber &lt;= ENGINE_VERSION_NUMBER) {
+		return LOS_Working;
+	}
+
+	return LOS_None;
+*/
+	return LOS_Unknown;
+}
+
+/*
+EXPORT(unsigned int) getInfo(struct InfoItem info[], unsigned int maxInfoItems) {
+
+	if (myNumInfoItems == 0) {
+		//myInfo = (struct InfoItem*) calloc(10, sizeof(struct InfoItem));
+		struct InfoItem ii_0 = {AI_INTERFACE_PROPERTY_SHORT_NAME, MY_SHORT_NAME, NULL}; myInfo[myNumInfoItems++] = ii_0;
+		struct InfoItem ii_1 = {AI_INTERFACE_PROPERTY_VERSION, MY_VERSION, NULL}; myInfo[myNumInfoItems++] = ii_1;
+		struct InfoItem ii_2 = {AI_INTERFACE_PROPERTY_NAME, MY_NAME, NULL}; myInfo[myNumInfoItems++] = ii_2;
+		struct InfoItem ii_3 = {AI_INTERFACE_PROPERTY_DESCRIPTION, &quot;This AI Interface library is needed for Skirmish and Group AIs written in Java (Groovy, JRuby, ...).&quot;, NULL}; myInfo[myNumInfoItems++] = ii_3;
+		struct InfoItem ii_4 = {AI_INTERFACE_PROPERTY_URL, &quot;<A HREF="http://spring.clan-sy.com/wiki/AIInterface:Java">http://spring.clan-sy.com/wiki/AIInterface:Java</A>&quot;, NULL}; myInfo[myNumInfoItems++] = ii_4;
+		struct InfoItem ii_5 = {AI_INTERFACE_PROPERTY_SUPPORTED_LANGUAGES, &quot;Java (Groovy, JRuby, ...)&quot;, NULL}; myInfo[myNumInfoItems++] = ii_5;
+	}
+
+	maxInfoItems = maxInfoItems &gt; myNumInfoItems ? myNumInfoItems : maxInfoItems;
+	unsigned int i;
+	for (i = 0; i &lt; maxInfoItems; ++i) {
+		info[i] = myInfo[i];
+	}
+
+	// return the number of elements copied to info
+	return i;
+}
+*/
+
+// skirmish AI methods
+static struct SSAILibrary* mySSAILibrary = NULL;
+
+
+
+enum LevelOfSupport CALLING_CONV proxy_skirmishAI_getLevelOfSupportFor(
+		int teamId,
+		const char* engineVersionString, int engineVersionNumber,
+		const char* aiInterfaceShortName, const char* aiInterfaceVersion) {
+
+}
+
+/*
+unsigned int CALLING_CONV proxy_skirmishAI_getInfo(int teamId,
+		struct InfoItem info[], unsigned int maxInfoItems) {
+
+}
+
+unsigned int CALLING_CONV proxy_skirmishAI_getOptions(int teamId,
+		struct Option options[], unsigned int maxOptions) {
+
+}
+*/
+
+int CALLING_CONV proxy_skirmishAI_init(int teamId,
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		unsigned int optionsSize,
+		const char** optionsKeys, const char** optionsValues) {
+
+	int ret = -1;
+
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 0);
+	const char* className = util_map_getValueByKey(
+			infoSize, infoKeys, infoValues,
+			JAVA_SKIRMISH_AI_PROPERTY_CLASS_NAME);
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 1);
+
+	if (className != NULL) {
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 2);
+		ret = java_initSkirmishAIClass(className) ? 0 : 1;
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 3);
+	}
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 4);
+	bool ok = (ret == 0);
+	if (ok) {
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 5);
+		ret = java_skirmishAI_init(teamId,
+				infoSize, infoKeys, infoValues,
+				optionsSize, optionsKeys, optionsValues);
+	}
+//simpleLog_fine(&quot;proxy_skirmishAI_init %u&quot;, 6);
+
+	return ret;
+}
+
+int CALLING_CONV proxy_skirmishAI_release(int teamId) {
+	return java_skirmishAI_release(teamId);
+}
+
+int CALLING_CONV proxy_skirmishAI_handleEvent(
+		int teamId, int topic, const void* data) {
+	return java_skirmishAI_handleEvent(teamId, topic, data);
+}
+
+
+
+EXPORT(const struct SSAILibrary*) loadSkirmishAILibrary(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues) {
+
+//simpleLog_fine(&quot;loadSkirmishAILibrary %u&quot;, 0);
+	if (mySSAILibrary == NULL) {
+		mySSAILibrary = (struct SSAILibrary*) malloc(sizeof(struct SSAILibrary));
+
+		mySSAILibrary-&gt;getLevelOfSupportFor = proxy_skirmishAI_getLevelOfSupportFor;
+/*
+		mySSAILibrary-&gt;getInfo = proxy_skirmishAI_getInfo;
+		mySSAILibrary-&gt;getOptions = proxy_skirmishAI_getOptions;
+*/
+		mySSAILibrary-&gt;init = proxy_skirmishAI_init;
+		mySSAILibrary-&gt;release = proxy_skirmishAI_release;
+		mySSAILibrary-&gt;handleEvent = proxy_skirmishAI_handleEvent;
+	}
+//simpleLog_fine(&quot;loadSkirmishAILibrary %u&quot;, 10);
+
+	return mySSAILibrary;
+}
+EXPORT(int) unloadSkirmishAILibrary(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues) {
+
+	const char* className = util_map_getValueByKey(
+			infoSize, infoKeys, infoValues,
+			JAVA_SKIRMISH_AI_PROPERTY_CLASS_NAME);
+
+	return java_releaseSkirmishAIClass(className) ? 0 : -1;
+}
+EXPORT(int) unloadAllSkirmishAILibraries() {
+	return java_releaseAllSkirmishAIClasses() ? 0 : -1;
+}
+
+
+
+
+
+
+
+// group AI methods
+
+/*
+EXPORT(const struct SGAILibrary*) loadGroupAILibrary(
+		const struct InfoItem info[], unsigned int numInfoItems) {
+
+	//loadLibOnlyIfNotYetLoaded();
+	return NULL;
+}
+EXPORT(int) unloadGroupAILibrary(const struct SGAISpecifier* const gAISpecifier) {
+
+	//unloadLibIfLoaded();
+	return -1;
+}
+EXPORT(int) unloadAllGroupAILibraries() {
+
+	//unloadAllLibsIfLoaded();
+	return -1;
+}
+*/


Property changes on: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.c
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,85 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _INTERFACEEXPORT_H
+#define _INTERFACEEXPORT_H
+
+#if	!defined BUILDING_AI_INTERFACE
+#error BUILDING_AI_INTERFACE should be defined when building AI interfaces
+#endif
+#if	defined BUILDING_AI
+#error BUILDING_AI should not be defined when building AI interfaces
+#endif
+#if	defined SYNCIFY
+#error SYNCIFY should not be defined when building AI interfaces
+#endif
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &quot;ExternalAI/Interface/ELevelOfSupport.h&quot;
+
+struct SSAISpecifier;
+struct SSAILibrary;
+//struct SGAISpecifier;
+//struct SGAILibrary;
+struct SStaticGlobalData;
+
+// for a list of the functions that have to be exported,
+// see struct SAIInterfaceLibrary in:
+// &quot;rts/ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+
+
+// static AI interface library functions
+
+int CALLING_CONV initStatic(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		const struct SStaticGlobalData* staticGlobalData);
+EXPORT(int) releaseStatic();
+EXPORT(enum LevelOfSupport) getLevelOfSupportFor(
+		const char* engineVersion, int engineAIInterfaceGeneratedVersion);
+
+
+// skirmish AI related methods
+
+EXPORT(const struct SSAILibrary*) loadSkirmishAILibrary(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues);
+EXPORT(int) unloadSkirmishAILibrary(
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues);
+EXPORT(int) unloadAllSkirmishAILibraries();
+
+
+// group AI related methods
+
+//EXPORT(const struct SGAILibrary*) loadGroupAILibrary(
+//		const struct InfoItem info[], unsigned int numInfoItems);
+//EXPORT(int) unloadGroupAILibrary(
+//		const struct SGAISpecifier* const gAISpecifier);
+//EXPORT(int) unloadAllGroupAILibraries();
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	// _INTERFACEEXPORT_H


Property changes on: branches/caiinterface/AI/Interfaces/Java/InterfaceExport.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Interfaces/Java/InterfaceUtil.c	2008-12-05 16:12:49 UTC (rev 7129)
@@ -111,7 +111,7 @@
 }
 static unsigned int util_listFilesRec(const char* dir, const char* suffix,
 		char** fileNames, bool recursive, const unsigned int maxFileNames,
-		unsigned int numFileNames) {
+		unsigned int numFileNames, const char* relPath) {
 
 	if (numFileNames &gt;= maxFileNames) {
 		return numFileNames;
@@ -133,7 +133,10 @@
 		while (_findnext(handle, &amp;fileInfo) == 0
 				&amp;&amp; numFileNames &lt; maxFileNames) {
 			if (util_isFile(&amp;fileInfo)) {
-				fileNames[numFileNames++] = util_allocStrCpy(fileInfo.name);
+				char fileRelPath[strlen(relPath) + strlen(fileInfo.name) + 1];
+					strcpy(fileRelPath, relPath);
+					strcat(fileRelPath, fileInfo.name);
+				fileNames[numFileNames++] = util_allocStrCpy(fileRelPath);
 			}
 		}
 		_findclose(handle);
@@ -153,8 +156,13 @@
 				strcpy(subDir, dir);
 				strcat(subDir, &quot;\\&quot;);
 				strcat(subDir, fileInfo.name);
+				char subRelPath[strlen(relPath) + strlen(fileInfo.name)
+						+ strlen(&quot;\\&quot;) + 1];
+				strcpy(subRelPath, relPath);
+				strcat(subRelPath, fileInfo.name);
+				strcat(subRelPath, &quot;\\&quot;);
 				numFileNames = util_listFilesRec(subDir, suffix, fileNames,
-						recursive, maxFileNames, numFileNames);
+						recursive, maxFileNames, numFileNames, subRelPath);
 			}
 			while (_findnext(handle, &amp;fileInfo) == 0
 					&amp;&amp; numFileNames &lt; maxFileNames) {
@@ -164,8 +172,13 @@
 					strcpy(subDir, dir);
 					strcat(subDir, &quot;\\&quot;);
 					strcat(subDir, fileInfo.name);
+					char subRelPath[strlen(relPath) + strlen(fileInfo.name)
+							+ strlen(&quot;\\&quot;) + 1];
+					strcpy(subRelPath, relPath);
+					strcat(subRelPath, fileInfo.name);
+					strcat(subRelPath, &quot;\\&quot;);
 					numFileNames = util_listFilesRec(subDir, suffix, fileNames,
-							recursive, maxFileNames, numFileNames);
+							recursive, maxFileNames, numFileNames, subRelPath);
 				}
 			}
 			_findclose(handle);
@@ -177,7 +190,7 @@
 unsigned int util_listFiles(const char* dir, const char* suffix,
 		char** fileNames, bool recursive, const unsigned int maxFileNames) {
 	return util_listFilesRec(
-			dir, suffix, fileNames, recursive, maxFileNames, 0);
+			dir, suffix, fileNames, recursive, maxFileNames, 0, &quot;&quot;);
 }
 #else
 

Added: branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/JavaBridge.c	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/JavaBridge.c	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,1496 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;InterfaceUtil.h&quot;
+
+
+#include &quot;JavaBridge.h&quot;
+
+#include &quot;InterfaceDefines.h&quot;
+#include &quot;InterfaceUtil.h&quot;
+#include &quot;StreflopBridge.h&quot;
+#include &quot;Log.h&quot;
+
+#include &quot;ExternalAI/Interface/aidefines.h&quot;
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;ExternalAI/Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+//#include &quot;ExternalAI/Interface/SGAILibrary.h&quot;
+#include &quot;ExternalAI/Interface/AISEvents.h&quot;
+//#include &quot;ExternalAI/Interface/SInfo.h&quot;
+#include &quot;ExternalAI/Interface/SStaticGlobalData.h&quot;
+
+#include &lt;jni.h&gt;
+
+#include &lt;string.h&gt;	// strlen(), strcat(), strcpy()
+#include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
+#include &lt;inttypes.h&gt; // intptr_t -&gt; a signed int with the same size
+                      // as a pointer (whether 32bit or 64bit)
+/*
+#ifdef WIN32
+#include &lt;io.h&gt;
+#else
+#include &lt;dirent.h&gt;
+#endif
+#if defined STREFLOP_X87 || defined STREFLOP_SSE
+#include &quot;lib/streflop/streflop_cond.h&quot;
+using namespace streflop;
+#else
+#include &lt;math.h&gt;
+#endif
+*/
+//#include &quot;lib/streflop/streflop.h&quot;
+////#include &quot;lib/streflop/FPUSettings.h&quot;
+//using namespace streflop;
+
+
+
+
+
+static const struct SStaticGlobalData* staticGlobalData = NULL;
+static unsigned int maxTeams = 0;
+static unsigned int maxGroups = 0;
+static unsigned int maxSkirmishImpls = 0;
+static unsigned int sizeImpls = 0;
+static const char** aiImplId_className;
+static jobject* aiImplId_instance;
+static jmethodID** aiImplId_methods;
+static unsigned int* teamId_aiImplId;
+static const struct SAICallback** teamId_cCallback;
+static jobject* teamId_jCallback;
+
+
+
+
+static JNIEnv* g_jniEnv = NULL;
+static JavaVM* g_jvm = NULL;
+
+static jclass g_cls_jnaPointer = NULL;
+static jmethodID g_m_jnaPointer_ctor_long = NULL;
+
+static jclass g_cls_props = NULL;
+static jmethodID g_m_props_ctor = NULL;
+static jmethodID g_m_props_setProperty = NULL;
+
+
+/**
+ * Creates the Java classpath.
+ * It will consist of the following:
+ * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/{version}/interface.jar
+ * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/{version}/jlib/
+ * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/{version}/jlib/[*].jar
+ * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/interface.jar
+ * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/jlib/
+ * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/jlib/[*].jar
+ * {spring-data-dir}/{SKIRMISH_AI_DATA_DIR}/{ai-name}/{ai-version}/ai.jar
+ * {spring-data-dir}/{SKIRMISH_AI_DATA_DIR}/{ai-name}/{ai-version}/jlib/
+ * {spring-data-dir}/{SKIRMISH_AI_DATA_DIR}/{ai-name}/{ai-version}/jlib/[*].jar
+ * {spring-data-dir}/{SKIRMISH_AI_DATA_DIR}/{ai-name}/ai.jar
+ * {spring-data-dir}/{SKIRMISH_AI_DATA_DIR}/{ai-name}/jlib/
+ * {spring-data-dir}/{SKIRMISH_AI_DATA_DIR}/{ai-name}/jlib/[*].jar
+ * TODO: add class path for group AIs
+ */
+static bool java_createClassPath(char* classPath) {
+
+	classPath[0] = '\0';
+
+	// Check which of the skirmish AIs to be used in the current game will
+	// possibly be using this interface
+	unsigned int i;
+	unsigned int j;
+	unsigned int applSkirmishAIs[staticGlobalData-&gt;maxTeams];
+	unsigned int sizeApplSkimrishAIs = 0;
+	for (i = 0; i &lt; staticGlobalData-&gt;numSkirmishAIs; ++i) {
+		// find the interface shortName
+		const char* intShortName = util_map_getValueByKey(
+				staticGlobalData-&gt;skirmishAIInfosSizes[i],
+				staticGlobalData-&gt;skirmishAIInfosKeys[i],
+				staticGlobalData-&gt;skirmishAIInfosValues[i],
+				SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME);
+		const char* shortName_ai = util_map_getValueByKey(
+				staticGlobalData-&gt;skirmishAIInfosSizes[i],
+				staticGlobalData-&gt;skirmishAIInfosKeys[i],
+				staticGlobalData-&gt;skirmishAIInfosValues[i],
+				SKIRMISH_AI_PROPERTY_SHORT_NAME);
+simpleLog_log(&quot;shortName_ai: %s&quot;, shortName_ai);
+simpleLog_log(&quot;intShortName_ai: %s&quot;, intShortName);
+
+		// if the interface shortName was found, check for appliance
+		if (intShortName != NULL &amp;&amp; strcmp(intShortName, MY_SHORT_NAME) == 0) {
+simpleLog_log(&quot;applSkirmishAIs: %i&quot;, i);
+			applSkirmishAIs[sizeApplSkimrishAIs++] = i;
+		}
+	}
+
+
+	// the .jar files in the following list will be added to the classpath
+	static const unsigned int MAX_ENTRIES = 128;
+	static const unsigned int MAX_TEXT_LEN = 256;
+	char* jarFiles[MAX_ENTRIES];
+	int unsigned sizeJarFiles = 0;
+	// the Java AI Interfaces file name
+	{
+		//jarFiles[sizeJarFiles++] = AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;interface.jar&quot;;
+		//jarFiles[sizeJarFiles++] = AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;interface.jar&quot;;
+
+		jarFiles[sizeJarFiles] = util_allocStr(128);
+		strcpy(jarFiles[sizeJarFiles], AI_INTERFACES_DATA_DIR);
+		strcat(jarFiles[sizeJarFiles], sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;interface.jar&quot;);
+		sizeJarFiles++;
+
+		jarFiles[sizeJarFiles] = util_allocStr(128);
+		strcpy(jarFiles[sizeJarFiles], AI_INTERFACES_DATA_DIR);
+		strcat(jarFiles[sizeJarFiles], sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;interface.jar&quot;);
+		sizeJarFiles++;
+	}
+	// the file names of the Java AIs used during the current game
+//simpleLog_log(&quot;sizeApplSkimrishAIs: %u&quot;, sizeApplSkimrishAIs);
+	for (i = 0; i &lt; sizeApplSkimrishAIs; ++i) {
+		const char* shortName_ai = util_map_getValueByKey(
+				staticGlobalData-&gt;skirmishAIInfosSizes[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosKeys[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosValues[applSkirmishAIs[i]],
+				SKIRMISH_AI_PROPERTY_SHORT_NAME);
+		const char* version_ai = util_map_getValueByKey(
+				staticGlobalData-&gt;skirmishAIInfosSizes[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosKeys[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosValues[applSkirmishAIs[i]],
+				SKIRMISH_AI_PROPERTY_VERSION);
+
+		if (shortName_ai != NULL) {
+//simpleLog_log(&quot;shortName_ai: %s&quot;, shortName_ai);
+			char* jarPath = util_allocStr(MAX_TEXT_LEN);
+			SNPRINTF(jarPath, MAX_TEXT_LEN, &quot;%s&quot;sPS&quot;%s&quot;sPS&quot;ai.jar&quot;,
+					SKIRMISH_AI_DATA_DIR, shortName_ai);
+			jarFiles[sizeJarFiles++] = jarPath;
+
+			if (version_ai != NULL) {
+//simpleLog_log(&quot;version_ai: %s&quot;, version_ai);
+				jarPath = util_allocStr(MAX_TEXT_LEN);
+				SNPRINTF(jarPath, MAX_TEXT_LEN, &quot;%s&quot;sPS&quot;%s&quot;sPS&quot;%s&quot;sPS&quot;ai.jar&quot;,
+						SKIRMISH_AI_DATA_DIR, shortName_ai, version_ai);
+				jarFiles[sizeJarFiles++] = jarPath;
+			}
+		}
+	}
+
+
+	// the directories in the following list will be searched for .jar files
+	// which then will be added to the classpath, plus they will be added
+	// to the classpath directly, so you can keep .class files in there
+	char* jarDirs[MAX_ENTRIES];
+	int unsigned sizeJarDirs = 0;
+	jarDirs[sizeJarDirs++] = util_allocStrCpyCat(AI_INTERFACES_DATA_DIR,
+			sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;jlib&quot;);
+	jarDirs[sizeJarDirs++] = util_allocStrCpyCat(AI_INTERFACES_DATA_DIR,
+			sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;jlib&quot;);
+	// the jlib dirs of the Java AIs used during the current game
+	for (i = 0; i &lt; sizeApplSkimrishAIs; ++i) {
+		const char* shortName_ai = util_map_getValueByKey(
+				staticGlobalData-&gt;skirmishAIInfosSizes[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosKeys[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosValues[applSkirmishAIs[i]],
+				SKIRMISH_AI_PROPERTY_SHORT_NAME);
+		const char* version_ai = util_map_getValueByKey(
+				staticGlobalData-&gt;skirmishAIInfosSizes[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosKeys[applSkirmishAIs[i]],
+				staticGlobalData-&gt;skirmishAIInfosValues[applSkirmishAIs[i]],
+				SKIRMISH_AI_PROPERTY_VERSION);
+
+		if (shortName_ai != NULL) {
+			char* jarDir = util_allocStr(MAX_TEXT_LEN);
+			SNPRINTF(jarDir, MAX_TEXT_LEN, &quot;%s&quot;sPS&quot;%s&quot;sPS&quot;jlib&quot;,
+					SKIRMISH_AI_DATA_DIR, shortName_ai);
+			jarDirs[sizeJarDirs++] = jarDir;
+
+			if (version_ai != NULL) {
+				jarDir = util_allocStr(MAX_TEXT_LEN);
+				SNPRINTF(jarDir, MAX_TEXT_LEN, &quot;%s&quot;sPS&quot;%s&quot;sPS&quot;%s&quot;sPS&quot;jlib&quot;,
+						SKIRMISH_AI_DATA_DIR, shortName_ai, version_ai);
+				jarDirs[sizeJarDirs++] = jarDir;
+			}
+		}
+	}
+
+
+	// searching the individual jar files and adding everything to the classpath
+	strcat(classPath, &quot;-Djava.class.path=&quot;);
+/*
+	// add the first jar file
+	if (sizeJarFiles &gt; 0) {
+		if (util_fileExists(jarFiles[0])) {
+			char* absoluteFilePath = util_allocStr(MAX_TEXT_LEN);
+			bool found = util_findFile(
+					staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
+					jarFiles[0], absoluteFilePath);
+			if (found) {
+				strcat(classPath, absoluteFilePath);
+			}
+		}
+	}
+*/
+	// add the rest of the jar files
+	for (i = 0; i &lt; sizeJarFiles; ++i) {
+//simpleLog_log(&quot;jarFiles[%i]: %s&quot;, i, jarFiles[i]);
+		//if (util_fileExists(jarFiles[i])) {
+			char* absoluteFilePath = util_allocStr(MAX_TEXT_LEN);
+			bool found = util_findFile(
+					staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
+					jarFiles[i], absoluteFilePath);
+			if (found) {
+				if (i &gt; 0) {
+					strcat(classPath, ENTRY_DELIM);
+				}
+				strcat(classPath, absoluteFilePath);
+			}
+		//}
+	}
+	// add the jar dirs (for .class files)
+	for (i = 0; i &lt; sizeJarDirs; ++i) {
+		char* absoluteDirPath = util_allocStr(MAX_TEXT_LEN);
+		bool found = util_findDir(
+				staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
+				jarDirs[i], absoluteDirPath, false, false);
+		free(jarDirs[i]);
+		if (found) {
+			strcat(classPath, ENTRY_DELIM);
+			strcat(classPath, absoluteDirPath);
+			jarDirs[i] = absoluteDirPath;
+		} else {
+			jarDirs[i] = NULL;
+		}
+	}
+	// add the jars in the dirs
+	for (i = 0; i &lt; sizeJarDirs; ++i) {
+		if (jarDirs[i] != NULL) {
+			char* jarFileNames[MAX_ENTRIES];
+			unsigned int sizeJarFileNames = util_listFiles(jarDirs[i], &quot;.jar&quot;,
+					jarFileNames, true, MAX_ENTRIES);
+			for (j = 0; j &lt; sizeJarFileNames; ++j) {
+				strcat(classPath, ENTRY_DELIM);
+				strcat(classPath, jarDirs[i]);
+				strcat(classPath, sPS);
+				strcat(classPath, jarFileNames[j]);
+			}
+		}
+	}
+
+
+/*
+	char* libJars[MAX_JARS];
+	char* implJars[MAX_JARS];
+
+	const unsigned int sizeImplDataDirs = java_listJars(IMPL_DIR, implJars, MAX_JARS);
+	const unsigned int sizeLibJars = java_listJars(LIB_DIR, libJars, MAX_JARS);
+	const unsigned int sizeImplJars = java_listJars(IMPL_DIR, implJars, MAX_JARS);
+
+	strcpy(classPath, &quot;-Djava.class.path=&quot;JAI_DIR&quot;/JAI.jar&quot;);
+
+	// add the JAI dir for config files and testing without jars
+	strcat(classPath, ENTRY_DELIM&quot;&quot;JAI_DIR);
+
+	if (numLibJars &gt; 0) {
+		int cnt;
+		for (cnt = 0; cnt &lt; numLibJars; ++cnt) {
+			strcat(classPath, ENTRY_DELIM&quot;&quot;LIB_DIR&quot;&quot;PATH_DELIM);
+			strcat(classPath, libJars[cnt]);
+			free(libJars[cnt]);
+		}
+	}
+
+	if (numImplJars &gt; 0) {
+		int cnt;
+		for (cnt = 0; cnt &lt; numImplJars; ++cnt) {
+			strcat(classPath, ENTRY_DELIM&quot;&quot;IMPL_DIR&quot;&quot;PATH_DELIM);
+			strcat(classPath, implJars[cnt]);
+			free(implJars[cnt]);
+		}
+	}
+*/
+
+	return true;
+}
+
+static bool java_createJavaVMInitArgs(struct JavaVMInitArgs* vm_args) {
+
+	char classPath[16 * 1024];
+	if (!java_createClassPath(classPath)) {
+		simpleLog_error(-1, &quot;!Failed creating Java classpath.&quot;);
+		return false;
+	}
+
+	// create the Java library path (where native libs are searched)
+	// consists of:
+	// * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/{version}/lib/
+	// * {spring-data-dir}/{AI_INTERFACES_DATA_DIR}/Java/lib/
+	char libraryPath1[512];
+	//const char* relLibPath1 =
+	//		AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;lib&quot;;
+	char relLibPath1[128];
+	STRCPY(relLibPath1, AI_INTERFACES_DATA_DIR);
+	STRCAT(relLibPath1, sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;&quot;MY_VERSION&quot;&quot;sPS&quot;lib&quot;);
+	bool found_libraryPath1 = util_findDir(
+			staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
+			relLibPath1, libraryPath1, false, false);
+/*
+	if (!found_libraryPath1) {
+		simpleLog_error(-1, &quot;!Java library path does not exist: %s&quot;, relLibPath1);
+		return false;
+	}
+*/
+	char libraryPath2[512];
+	//const char* relLibPath2 =
+	//		AI_INTERFACES_DATA_DIR&quot;&quot;sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;lib&quot;;
+	char relLibPath2[128];
+	STRCPY(relLibPath2, AI_INTERFACES_DATA_DIR);
+	STRCAT(relLibPath2, sPS&quot;&quot;MY_SHORT_NAME&quot;&quot;sPS&quot;lib&quot;);
+	bool found_libraryPath2 = util_findDir(
+			staticGlobalData-&gt;dataDirs, staticGlobalData-&gt;numDataDirs,
+			relLibPath2, libraryPath2, false, false);
+	char libraryPath[1024];
+	libraryPath[0] = '\0';
+	strcat(libraryPath, &quot;-Djava.library.path=&quot;);
+// TODO remove the two following lines
+strcat(libraryPath, &quot;/home/robin/svn_work/robin/Development/Projects/Others/spring_C_AI_interface/game_linux/AI/Interfaces/Java/0.1&quot;);
+strcat(libraryPath, ENTRY_DELIM);
+	if (found_libraryPath1) {
+		strcat(libraryPath, libraryPath1);
+	}
+	if (found_libraryPath1 &amp;&amp; found_libraryPath2) {
+		strcat(libraryPath, ENTRY_DELIM);
+	}
+	if (found_libraryPath2) {
+		strcat(libraryPath, libraryPath2);
+	}
+
+	const char* strOptions[32];
+	unsigned int op = 0;
+
+	strOptions[op++] = classPath;
+	strOptions[op++] = libraryPath;
+
+	//if (GetOptionsFromConfigFile(&amp;strOptions, CONFIG_FILE) &lt; 0) {
+		//simpleLog_fine(&quot;No JVM arguments loaded from config file: ___&quot;);
+		simpleLog_fine(&quot; -&gt; using default options.&quot;);
+
+		strOptions[op++] = &quot;-Xms4M&quot;;
+		strOptions[op++] = &quot;-Xmx64M&quot;;
+		strOptions[op++] = &quot;-Xss512K&quot;;
+		strOptions[op++] = &quot;-Xoss400K&quot;;
+		//strOptions[op++] = &quot;-XX:+AlwaysRestoreFPU&quot;;
+		//strOptions[op++] = &quot;-Djava.util.logging.config.file=&quot;JAI_DIR&quot;/logging.properties&quot;;
+
+		if (JVM_LOGGING) {
+			simpleLog_fine(&quot;JVM logging enabled.&quot;);
+			strOptions[op++] = &quot;-Xcheck:jni&quot;;
+			strOptions[op++] = &quot;-verbose:jni&quot;;
+			strOptions[op++] = &quot;-XX:+UnlockDiagnosticVMOptions&quot;;
+			strOptions[op++] = &quot;-XX:+LogVMOutput&quot;;
+			//strOptions[op++] = &quot;-XX:LogFile=C:/javaLog.txt&quot;;
+			//strOptions[op++] = &quot;-XX:LogFile=&quot;JAI_DIR&quot;/log/jvm-log.txt&quot;;
+		}
+		if (JVM_DEBUGGING) {
+			simpleLog_fine(&quot;JVM debugging enabled.&quot;);
+			strOptions[op++] = &quot;-Xdebug&quot;;
+			strOptions[op++] = &quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=&quot;JVM_DEBUG_PORT;
+			// disable JIT (required for debugging under the classical VM)
+			strOptions[op++] = &quot;-Djava.compiler=NONE&quot;;
+			strOptions[op++] = &quot;-Xnoagent&quot;; // disables old JDB
+		}
+	//}
+	unsigned int numOptions = op;
+
+	struct JavaVMOption* options = (struct JavaVMOption*) calloc(numOptions, sizeof(struct JavaVMOption));
+
+	// fill strOptions into the JVM options
+	simpleLog_fine(&quot;JVM init options (size: %i):&quot;, numOptions);
+	unsigned int i;
+	for (i = 0; i &lt; numOptions; ++i) {
+		options[i].optionString = util_allocStrCpy(strOptions[i]);
+		simpleLog_fine(strOptions[i]);
+	}
+	simpleLog_fine(&quot;&quot;);
+
+	vm_args-&gt;version = JNI_VERSION_1_4;
+	//vm_args-&gt;version = JNI_VERSION_1_1;
+	//vm_args-&gt;version = JNI_VERSION_1_6;
+	vm_args-&gt;options = options;
+	vm_args-&gt;nOptions = numOptions;
+	vm_args-&gt;ignoreUnrecognized = JNI_FALSE;
+
+	return true;
+}
+
+static JNIEnv* java_getJNIEnv() {
+
+	if (g_jniEnv == NULL) {
+		simpleLog_fine(&quot;Creating the JVM.&quot;);
+
+		JNIEnv* env = NULL;
+		JavaVM* jvm = NULL;
+		struct JavaVMInitArgs vm_args;
+		jint res;
+/*
+		jclass cls;
+		jmethodID mid;
+*/
+
+		if (!java_createJavaVMInitArgs(&amp;vm_args)) {
+			simpleLog_error(-1, &quot;!Failed initializing JVM init-arguments.&quot;);
+			goto end;
+		}
+
+		/*
+				// looking for existing JVMs is problematic,
+				// cause they could be initialized with other JVM-arguments then we need
+				simpleLog_log(&quot;looking for existing JVMs ...&quot;);
+				jsize numJVMsFound = 0;
+
+				// jint JNI_GetCreatedJavaVMs(JavaVM **vmBuf, jsize bufLen, jsize *nVMs);
+				// Returns all Java VMs that have been created.
+				// Pointers to VMs are written in the buffer vmBuf in the order they are created.
+				// At most bufLen number of entries will be written.
+				// The total number of created VMs is returned in *nVMs.
+				// Returns &#8220;0&#8221; on success; returns a negative number on failure.
+				res = JNI_GetCreatedJavaVMs(&amp;jvm, 1, &amp;numJVMsFound);
+				if (res &lt; 0) {
+					simpleLog_log(&quot;!Can't looking for Java VMs, error code: %i&quot;, res);
+					goto end;
+				}
+				simpleLog_log(&quot;number of existing JVMs: %i&quot;, numJVMsFound);
+		 */
+
+		simpleLog_fine(&quot;creating JVM...&quot;);
+		res = JNI_CreateJavaVM(&amp;jvm, (void**) &amp;env, &amp;vm_args);
+		unsigned int i;
+		for (i = 0; i &lt; vm_args.nOptions; ++i) {
+			free(vm_args.options[i].optionString);
+		}
+		free(vm_args.options);
+		ESTABLISH_SPRING_ENV
+		if (res &lt; 0) {
+			simpleLog_error(res, &quot;!Can't create Java VM, error code: %i&quot;, res);
+			goto end;
+		}
+
+		res = (*jvm)-&gt;AttachCurrentThreadAsDaemon(jvm, (void**) &amp;env, NULL);
+		//res = AttachCurrentThread(jvm, (void**) &amp;env, NULL);
+		if (res &lt; 0 || (*env)-&gt;ExceptionCheck(env)) {
+			if ((*env)-&gt;ExceptionCheck(env)) {
+				(*env)-&gt;ExceptionDescribe(env);
+			}
+			simpleLog_error(res, &quot;!Can't Attach jvm to current thread,&quot;
+					&quot; error code: %i&quot;, res);
+			goto end;
+		}
+
+end:
+		if (env == NULL || jvm == NULL || (*env)-&gt;ExceptionCheck(env) || res != 0) {
+			simpleLog_fine(&quot;!Failed creating JVM.&quot;);
+			if (env != NULL &amp;&amp; (*env)-&gt;ExceptionCheck(env)) {
+				(*env)-&gt;ExceptionDescribe(env);
+			}
+			if (jvm != NULL) {
+				res = (*jvm)-&gt;DestroyJavaVM(jvm);
+			}
+			g_jniEnv = NULL;
+			g_jvm = NULL;
+		} else {
+			g_jniEnv = env;
+			g_jvm = jvm;
+		}
+	}
+
+	//simpleLog_fine(&quot;Reattaching current thread...&quot;);
+	jint res = (*g_jvm)-&gt;AttachCurrentThreadAsDaemon(g_jvm, (void**) &amp;g_jniEnv, NULL);
+	//res = jvm-&gt;AttachCurrentThread((void**) &amp; jniEnv, NULL);
+	if (res &lt; 0 || (*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
+		if ((*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
+			(*g_jniEnv)-&gt;ExceptionDescribe(g_jniEnv);
+		}
+		simpleLog_error(res, &quot;!Can't Attach jvm to current thread,&quot;
+				&quot; error code(2): %i&quot;, res);
+	}
+
+	return g_jniEnv;
+}
+
+
+bool java_unloadJNIEnv() {
+
+	if (g_jniEnv != NULL) {
+		simpleLog_fine(&quot;Unloading the JVM...&quot;);
+
+		// We have to be the ONLY running thread (native and Java)
+		// this may not help, but cant be bad
+		jint res = (*g_jvm)-&gt;AttachCurrentThreadAsDaemon(g_jvm, (void**) &amp;g_jniEnv, NULL);
+		//res = jvm-&gt;AttachCurrentThread((void**) &amp; jniEnv, NULL);
+		if (res &lt; 0 || (*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
+			if ((*g_jniEnv)-&gt;ExceptionCheck(g_jniEnv)) {
+				(*g_jniEnv)-&gt;ExceptionDescribe(g_jniEnv);
+			}
+			simpleLog_log(&quot;!Can't Attach jvm to current thread,&quot;
+					&quot; error code: %i&quot;, res);
+			return false;
+		}
+
+		res = (*g_jvm)-&gt;DestroyJavaVM(g_jvm);
+		if (res != 0) {
+			simpleLog_log(&quot;!Failed destroying the JVM, error code: %i&quot;, res);
+			return false;
+		} else {
+			g_jniEnv = NULL;
+			g_jvm = NULL;
+		}
+	}
+
+
+	return true;
+}
+
+
+bool java_preloadJNIEnv() {
+
+	ESTABLISH_JAVA_ENV;
+	JNIEnv* env = java_getJNIEnv();
+	ESTABLISH_SPRING_ENV;
+
+	return env != NULL;
+}
+
+
+bool java_initStatic(const struct SStaticGlobalData* _staticGlobalData) {
+
+	staticGlobalData = _staticGlobalData;
+
+	maxTeams = staticGlobalData-&gt;maxTeams;
+	maxTeams = staticGlobalData-&gt;maxTeams;
+	maxGroups = staticGlobalData-&gt;maxGroups;
+	maxSkirmishImpls = maxTeams;
+	sizeImpls = 0;
+
+	aiImplId_className = (const char**) calloc(maxSkirmishImpls, sizeof(char*));
+	aiImplId_instance = (jobject*) calloc(maxSkirmishImpls, sizeof(jobject));
+	aiImplId_methods = (jmethodID**) calloc(maxSkirmishImpls, sizeof(jmethodID*));
+	teamId_aiImplId = (unsigned int*) calloc(maxTeams, sizeof(unsigned int));
+	teamId_cCallback = (const struct SAICallback**) calloc(maxTeams, sizeof(struct SAICallback*));
+	teamId_jCallback = (jobject*) calloc(maxTeams, sizeof(jobject));
+
+	unsigned int impl;
+	for (impl = 0; impl &lt; maxSkirmishImpls; ++impl) {
+		aiImplId_className[impl] = NULL;
+		aiImplId_instance[impl] = NULL;
+		aiImplId_methods[impl] = NULL;
+	}
+
+	unsigned int t;
+	for (t = 0; t &lt; maxTeams; ++t) {
+		teamId_aiImplId[t] = 0;
+		teamId_cCallback[t] = NULL;
+		teamId_jCallback[t] = NULL;
+	}
+
+/*
+	ESTABLISH_JAVA_ENV;
+	JNIEnv* env = java_getJNIEnv();
+	callback_init(env);
+	wrappSAICallback_init(env);
+	ESTABLISH_SPRING_ENV;
+*/
+
+	return true;
+}
+
+
+static bool java_initPropertiesClass(JNIEnv* env) {
+
+	// get the Properties class
+	g_cls_props = (*env)-&gt;FindClass(env, &quot;java/util/Properties&quot;);
+	if (g_cls_props == NULL || (*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!Class not found \&quot;%s\&quot;&quot;, &quot;java/util/Properties&quot;);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		return false;
+	}
+
+	// make the Properties class a global reference,
+	// so it will not be garbage collected,
+	// even after this method returned
+	g_cls_props = (*env)-&gt;NewGlobalRef(env, g_cls_props);
+	if ((*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!Failed to make AI a global reference.&quot;);
+		(*env)-&gt;ExceptionDescribe(env);
+		return false;
+	}
+
+	// get no-arg constructor
+	g_m_props_ctor = (*env)-&gt;GetMethodID(env, g_cls_props, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
+	if (g_m_props_ctor == NULL || (*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!No-arg constructor not found for class: %s&quot;, &quot;java/util/Properties&quot;);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		return false;
+	}
+
+	// get the setProperty() method
+	g_m_props_setProperty = (*env)-&gt;GetMethodID(env, g_cls_props, &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
+	if (g_m_props_setProperty == NULL || (*env)-&gt;ExceptionCheck(env)) {
+		g_m_props_setProperty = NULL;
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, &quot;java/util/Properties&quot;, &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		return false;
+	}
+
+	return true;
+}
+
+
+static bool java_initPointerClass(JNIEnv* env) {
+
+	if (g_cls_jnaPointer == NULL) {
+		// get the Pointer class
+		g_cls_jnaPointer = (*env)-&gt;FindClass(env, &quot;com/sun/jna/Pointer&quot;);
+		if (g_cls_jnaPointer == NULL || (*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!Class not found \&quot;%s\&quot;&quot;, &quot;com/sun/jna/Pointer&quot;);
+			if ((*env)-&gt;ExceptionCheck(env)) {
+				(*env)-&gt;ExceptionDescribe(env);
+				return false;
+			}
+		}
+
+		// make the Pointer class a global reference,
+		// so it will not be garbage collected,
+		// even after this method returned
+		g_cls_jnaPointer = (*env)-&gt;NewGlobalRef(env, g_cls_jnaPointer);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!Failed to make Pointer a global reference.&quot;);
+			(*env)-&gt;ExceptionDescribe(env);
+			return false;
+		}
+
+		// get native pointer constructor
+		g_m_jnaPointer_ctor_long =
+				(*env)-&gt;GetMethodID(env, g_cls_jnaPointer, &quot;&lt;init&gt;&quot;, &quot;(J)V&quot;);
+		if (g_m_jnaPointer_ctor_long == NULL || (*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!long constructor not found for class: %s&quot;,
+					&quot;com/sun/jna/Pointer&quot;);
+			if ((*env)-&gt;ExceptionCheck(env)) {
+				(*env)-&gt;ExceptionDescribe(env);
+				return false;
+			}
+		}
+	}
+
+	return true;
+}
+
+static jobject java_createPropertiesInstance(JNIEnv* env) {
+
+	jobject o_props = NULL;
+
+	// initialize the properties class if not yet done
+	if (g_m_props_setProperty == NULL) {
+		if (!java_initPropertiesClass(env)) {
+			return NULL;
+		}
+	}
+
+	// create a Properties instance
+	o_props = (*env)-&gt;NewObject(env, g_cls_props, g_m_props_ctor);
+	if (o_props == NULL || (*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!Failed creating Properties instance&quot;);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+	}
+
+	return o_props;
+}
+
+/*
+static jobject java_createPropertiesFromInfoItems(JNIEnv* env,
+		const struct InfoItem info[], unsigned int numInfoItems) {
+
+	jobject o_props = java_createPropertiesInstance(env);
+	if (o_props == NULL) {
+		return o_props;
+	}
+
+	// fill the Java Properties instance with the info keys and values
+	unsigned int ii;
+	for (ii=0; ii &lt; numInfoItems; ii++) {
+		jstring jstr_key = (*env)-&gt;NewStringUTF(env, info[ii].key);
+		jstring jstr_value = (*env)-&gt;NewStringUTF(env, info[ii].value);
+		(*env)-&gt;CallObjectMethod(env, o_props, g_m_props_setProperty, jstr_key, jstr_value);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!Failed adding property&quot;);
+			if ((*env)-&gt;ExceptionCheck(env)) {
+				(*env)-&gt;ExceptionDescribe(env);
+			}
+			return NULL;
+		}
+	}
+
+	return o_props;
+}
+*/
+
+static jobject java_createPropertiesFromCMap(JNIEnv* env,
+		unsigned int size,
+		const char** keys, const char** values) {
+
+	jobject o_props = java_createPropertiesInstance(env);
+	if (o_props == NULL) {
+		return o_props;
+	}
+
+	// fill the Java Properties instance with the info keys and values
+	unsigned int op;
+	for (op=0; op &lt; size; op++) {
+		jstring jstr_key = (*env)-&gt;NewStringUTF(env, keys[op]);
+		jstring jstr_value = (*env)-&gt;NewStringUTF(env, values[op]);
+		(*env)-&gt;CallObjectMethod(env, o_props, g_m_props_setProperty, jstr_key, jstr_value);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!Failed adding property&quot;);
+			if ((*env)-&gt;ExceptionCheck(env)) {
+				(*env)-&gt;ExceptionDescribe(env);
+			}
+			return NULL;
+		}
+	}
+
+	return o_props;
+}
+
+
+/**
+ * Instantiates an instance of the class specified className.
+ *
+ * @param	className	fully qualified name of a Java clas that implements
+ *						interface com.clan_sy.spring.ai.AI
+ * @param	aiInstance	where the AI instance will be stored
+ * @param	methods		where the method IDs of the AI will be stored
+ */
+/*
+int getFactory(struct JNIEnv* env, const char* className, jobject aiInstance, jmethodID methods) {
+
+	if (g_factory == NULL) {
+		simpleLog_log(&quot;Create the factory...&quot;);
+
+		jclass cls_factory;
+		jmethodID mid_factory_init;
+		jmethodID mid_factory_createAi = NULL;
+		jmethodID mid_factory_createAiByName = NULL;
+		jobject factory = NULL;
+		jmethodID release_mid;
+		jclass javaAiClass = NULL;
+
+		// get factory class
+		cls_factory = jniEnv-&gt;FindClass(CLS_FACTORY);
+		if (cls_factory == 0) {
+			simpleLog_log(&quot;!Can't find class &quot;CLS_FACTORY);
+			goto end;
+		}
+
+		// get factory constructor
+		mid_factory_init = jniEnv-&gt;GetMethodID(cls_factory, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
+		if (mid_factory_init == 0) {
+			simpleLog_log(&quot;!Can't find no-arg-constructor of class &quot;CLS_FACTORY);
+			goto end;
+		}
+
+		// get factory method, the one that serves AI instances
+		mid_factory_createAi = jniEnv-&gt;GetMethodID(cls_factory, MTH_FACTORY_CREATEAI, SIG_FACTORY_CREATEAI);
+		if (mid_factory_createAi == 0) {
+			simpleLog_log(&quot;!Can't find method: &quot;CLS_FACTORY&quot;.&quot;MTH_FACTORY_CREATEAI&quot;&quot;SIG_FACTORY_CREATEAI);
+			goto end;
+		}
+		// get factory method , the one that serves AI instances out of a specified jar
+		mid_factory_createAiByName = jniEnv-&gt;GetMethodID(cls_factory, MTH_FACTORY_CREATEAIBYNAME, SIG_FACTORY_CREATEAIBYNAME);
+		if (mid_factory_createAiByName == 0) {
+			simpleLog_log(&quot;!Can't find method: &quot;CLS_FACTORY&quot;.&quot;MTH_FACTORY_CREATEAIBYNAME&quot;&quot;SIG_FACTORY_CREATEAIBYNAME);
+			goto end;
+		}
+
+		// create the factory
+		factory = jniEnv-&gt;NewObject(cls_factory, mid_factory_init);
+		if (factory == 0) {
+			simpleLog_log(&quot;!Can't instantiate factory.&quot;);
+			goto end;
+		}
+
+		// make the factory a global reference,
+		// so it will not be garbage collected,
+		// even after this method returned
+		factory = jniEnv-&gt;NewGlobalRef(factory);
+		if (jniEnv-&gt;ExceptionCheck()) {
+			simpleLog_log(&quot;!Can't make factory a global reference.&quot;);
+			goto end;
+		}
+
+end:
+		if (jniEnv-&gt;ExceptionCheck()) {
+			simpleLog_log(&quot;!Failed creating factory.&quot;);
+			factory = NULL;
+			jniEnv-&gt;ExceptionDescribe();
+		}
+
+		g_mid_factory_createAi = mid_factory_createAi;
+		g_mid_factory_createAiByName = mid_factory_createAiByName;
+		g_factory = factory;
+	}
+
+	return g_factory;
+}
+*/
+
+
+bool java_releaseStatic() {
+
+	unsigned int impl;
+	for (impl = 0; impl &lt; maxSkirmishImpls; ++impl) {
+		if (aiImplId_methods[impl] != NULL) {
+			free(aiImplId_methods[impl]);
+			aiImplId_methods[impl] = NULL;
+		}
+	}
+
+	free(aiImplId_className);
+	free(aiImplId_instance);
+	free(aiImplId_methods);
+	free(teamId_aiImplId);
+
+	return true;
+}
+
+bool java_getSkirmishAIAndMethod(unsigned int teamId, jobject* o_ai,
+		unsigned int methodIndex, jmethodID* mth) {
+
+	bool success = false;
+
+	unsigned int implId = teamId_aiImplId[teamId];
+	*o_ai = aiImplId_instance[implId];
+	*mth = aiImplId_methods[implId][methodIndex];
+	success = (*mth) != NULL;
+
+	return success;
+}
+
+
+/**
+ * Instantiates an instance of the class specified className.
+ *
+ * @param	className	fully qualified name of a Java clas that implements
+ *						interface com.clan_sy.spring.ai.AI, eg:
+ *						&quot;com.myai.AI&quot;
+ * @param	aiInstance	where the AI instance will be stored
+ * @param	methods		where the method IDs of the AI will be stored
+ */
+static bool java_loadSkirmishAI(JNIEnv* env, const char* className,
+		jobject* o_ai, jmethodID methods[MTHS_SIZE_SKIRMISH_AI]) {
+
+	// convert className from &quot;com.myai.AI&quot; to &quot;com/myai/AI&quot;
+	char classNameP[strlen(className)+1];
+	strcpy(classNameP, className);
+	util_strReplace(classNameP, '.', '/');
+
+	// get the AI class
+	jclass cls_ai = (*env)-&gt;FindClass(env, classNameP);
+	if (cls_ai == NULL || (*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!Class not found \&quot;%s\&quot;&quot;, className);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		return false;
+	}
+
+	// get AI constructor
+	jmethodID m_ai_ctor = (*env)-&gt;GetMethodID(env, cls_ai, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);
+	if (m_ai_ctor == NULL || (*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!No-arg constructor not found for class: %s&quot;, className);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		return false;
+	}
+
+	// instantiate AI
+	//jobject o_local_ai = (*env)-&gt;CallStaticObjectMethod(env, cls_ai, m_ai_ctor);
+	jobject o_local_ai = (*env)-&gt;NewObject(env, cls_ai, m_ai_ctor);
+	if (!o_local_ai || (*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!No-arg constructor not found for class: %s&quot;, className);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		return false;
+	}
+
+	// make the AI a global reference,
+	// so it will not be garbage collected,
+	// even after this method returned
+	jobject o_global_ai = (*env)-&gt;NewGlobalRef(env, o_local_ai);
+	*o_ai = o_global_ai;
+	if ((*env)-&gt;ExceptionCheck(env)) {
+		simpleLog_log(&quot;!Failed to make AI a global reference.&quot;);
+		(*env)-&gt;ExceptionDescribe(env);
+	}
+
+
+	// get the AIs methods
+
+	// init
+	methods[MTH_INDEX_SKIRMISH_AI_INIT] = (*env)-&gt;GetMethodID(env, cls_ai, MTH_SKIRMISH_AI_INIT, SIG_SKIRMISH_AI_INIT);
+	if (methods[MTH_INDEX_SKIRMISH_AI_INIT] == NULL) {
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className, MTH_SKIRMISH_AI_INIT, SIG_SKIRMISH_AI_INIT);
+		return false;
+	}
+
+	// release
+	methods[MTH_INDEX_SKIRMISH_AI_RELEASE] = (*env)-&gt;GetMethodID(env, cls_ai, MTH_SKIRMISH_AI_RELEASE, SIG_SKIRMISH_AI_RELEASE);
+	if (methods[MTH_INDEX_SKIRMISH_AI_RELEASE] == NULL) {
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className, MTH_SKIRMISH_AI_RELEASE, SIG_SKIRMISH_AI_RELEASE);
+		return false;
+	}
+
+	// handleEvent
+	methods[MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT] = (*env)-&gt;GetMethodID(env, cls_ai, MTH_SKIRMISH_AI_HANDLE_EVENT, SIG_SKIRMISH_AI_HANDLE_EVENT);
+	if (methods[MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT] == NULL) {
+		simpleLog_log(&quot;!Method not found: %s.%s%s&quot;, className, MTH_SKIRMISH_AI_HANDLE_EVENT, SIG_SKIRMISH_AI_HANDLE_EVENT);
+		return false;
+	}
+
+	return true;
+}
+
+
+/**
+ * Instantiates an instance of the specified className.
+ *
+ * @param	className	fully qualified name of a Java clas that implements
+ *						interface com.clan_sy.spring.ai.AI, eg:
+ *						&quot;com.myai.AI&quot;
+ * @param	aiInstance	where the AI instance will be stored
+ * @param	methods		where the method IDs of the AI will be stored
+ */
+bool java_initSkirmishAIClass(const char* className) {
+
+	bool success = false;
+
+	// see if an AI for className is instantiated already
+	unsigned int implId;
+	for (implId = 0; implId &lt; sizeImpls; ++implId) {
+		if (strcmp(aiImplId_className[implId], className) == 0) {
+			break;
+		}
+	}
+
+	// instantiate AI (if needed)
+	if (aiImplId_className[implId] == NULL) {
+		ESTABLISH_JAVA_ENV;
+		JNIEnv* env = java_getJNIEnv();
+
+		if (g_cls_jnaPointer == NULL) {
+			java_initPointerClass(env);
+		}
+
+		aiImplId_methods[implId] = (jmethodID*) calloc(MTHS_SIZE_SKIRMISH_AI, sizeof(jmethodID));
+		success = java_loadSkirmishAI(env, className, &amp;(aiImplId_instance[implId]), aiImplId_methods[implId]);
+		ESTABLISH_SPRING_ENV;
+		if (success) {
+			aiImplId_className[implId] = util_allocStrCpy(className);
+		} else {
+			simpleLog_error(-1, &quot;!Class loading failed for class: %s&quot;, className);
+		}
+	}
+
+	return success;
+}
+/**
+ * Release an instance of the specified className.
+ *
+ * @param	className	fully qualified name of a Java clas that implements
+ *						interface com.clan_sy.spring.ai.AI, eg:
+ *						&quot;com.myai.AI&quot;
+ * @param	aiInstance	where the AI instance will be stored
+ * @param	methods		where the method IDs of the AI will be stored
+ */
+bool java_releaseSkirmishAIClass(const char* className) {
+
+	bool success = false;
+
+	// see if an AI for className is instantiated
+	unsigned int implId;
+	for (implId = 0; implId &lt; sizeImpls; ++implId) {
+		if (strcmp(aiImplId_className[implId], className) == 0) {
+			break;
+		}
+	}
+
+	// release AI (if needed)
+	if (aiImplId_className[implId] != NULL) {
+		ESTABLISH_JAVA_ENV;
+		JNIEnv* env = java_getJNIEnv();
+
+		// delete the AI global reference,
+		// so it will be garbage collected
+		(*env)-&gt;DeleteGlobalRef(env, aiImplId_instance[implId]);
+		success = !((*env)-&gt;ExceptionCheck(env));
+		if (!success) {
+			simpleLog_log(&quot;!Failed to delete AI global reference.&quot;);
+			(*env)-&gt;ExceptionDescribe(env);
+		}
+		ESTABLISH_SPRING_ENV;
+
+		if (success) {
+			free(aiImplId_methods[implId]);
+			aiImplId_methods[implId] = NULL;
+			free(aiImplId_className[implId]);
+			aiImplId_className[implId] = NULL;
+		}
+	}
+
+	return success;
+}
+bool java_releaseAllSkirmishAIClasses() {
+
+	bool success = true;
+
+	const char* className;
+	unsigned int implId;
+	for (implId = 0; implId &lt; sizeImpls; ++implId) {
+		className = aiImplId_className[implId];
+		if (className != NULL) {
+			success = success &amp;&amp; java_releaseSkirmishAIClass(className);
+		}
+	}
+
+	return success;
+}
+
+
+const struct SAICallback* java_getSkirmishAICCallback(int teamId) {
+	return teamId_cCallback[teamId];
+}
+
+static jobject java_toJavaAICallback(JNIEnv* env, int teamId, const struct SAICallback* cCallback) {
+
+	jobject jCallback = NULL;
+
+	jclass cls_jClb = (*env)-&gt;FindClass(env, CLS_AI_CALLBACK);
+	jCallback = (*env)-&gt;AllocObject(env, cls_jClb);
+	jCallback = (*env)-&gt;NewGlobalRef(env, jCallback);
+
+	teamId_cCallback[teamId] = cCallback;
+	teamId_jCallback[teamId] = jCallback;
+
+	return jCallback;
+}
+
+/*
+static jobject java_toJavaAIEvent(JNIEnv* env, int teamId, int topic, const void* data) {
+
+	jobject jEvt = NULL;
+	bool ok = false;
+
+	switch (topic) {
+		case EVENT_INIT:
+			;
+			const struct SInitEvent* cEvt = (const struct SInitEvent*) data;
+			jclass cls_jEvt = (*env)-&gt;FindClass(env, PKG_EVENT&quot;InitAIEvent&quot;);
+			jfieldID f_jEvt_teamId = (*env)-&gt;GetFieldID(env, cls_jEvt,
+					&quot;teamId&quot;, &quot;I&quot;);
+			jfieldID f_jEvt_callback = (*env)-&gt;GetFieldID(env, cls_jEvt,
+					&quot;callback&quot;, &quot;L&quot;CLS_AI_CALLBACK&quot;;&quot;);
+			jfieldID f_jEvt_options = (*env)-&gt;GetFieldID(env, cls_jEvt,
+					&quot;options&quot;, &quot;Ljava/util/Properties;&quot;);
+			jclass cls_props = (*env)-&gt;FindClass(env, &quot;java/util/Properties&quot;);
+			jmethodID m_props_ctor = (*env)-&gt;GetMethodID(env, cls_props,
+					&quot;&lt;init&gt;&quot;, &quot;()V&quot;);
+			jmethodID m_props_setProperty = (*env)-&gt;GetMethodID(env, cls_jEvt,
+					&quot;setProperty&quot;,
+					&quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
+
+			jEvt = (*env)-&gt;AllocObject(env, cls_jEvt);
+
+			(*env)-&gt;SetIntField(env, jEvt, f_jEvt_teamId, cEvt-&gt;team);
+
+			jobject o_callback = java_toJavaAICallback(env, teamId, cEvt-&gt;callback);
+			(*env)-&gt;SetObjectField(env, jEvt, f_jEvt_callback, o_callback);
+
+			jobject props = (*env)-&gt;NewObject(env, cls_props, m_props_ctor);
+			unsigned int op;
+			for (op = 0; op &lt; cEvt-&gt;sizeOptions; op++) {
+				jstring jstr_key = (*env)-&gt;NewStringUTF(env, cEvt-&gt;optionKeys[op]);
+				jstring jstr_value = (*env)-&gt;NewStringUTF(env, cEvt-&gt;optionValues[op]);
+				(*env)-&gt;CallObjectMethod(env, props, m_props_setProperty,
+						jstr_key, jstr_value);
+			}
+			(*env)-&gt;SetObjectField(env, jEvt, f_jEvt_options, props);
+
+			ok = true;
+			break;
+		default:
+			//jEvt = new NullAIEvent();
+			break;
+	}
+
+	if (!ok) {
+		jEvt = false;
+	}
+
+	return jEvt;
+}
+*/
+
+
+
+/**
+ * Instantiates an instance of the class specified className.
+ *
+ * @param	className	fully qualified name of a Java clas that implements
+ *						interface com.clan_sy.spring.ai.AI, eg:
+ *						&quot;com.myai.AI&quot;
+ * @param	aiInstance	where the AI instance will be stored
+ * @param	methods		where the method IDs of the AI will be stored
+ */
+int java_skirmishAI_init(int teamId,
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		unsigned int optionsSize,
+		const char** optionsKeys, const char** optionsValues) {
+
+	int res = -1;
+
+	jmethodID mth = NULL;
+	jobject o_ai = NULL;
+	ESTABLISH_JAVA_ENV;
+	bool success = java_getSkirmishAIAndMethod(teamId, &amp;o_ai, MTH_INDEX_SKIRMISH_AI_INIT, &amp;mth);
+
+	JNIEnv* env = NULL;
+	if (success) {
+		env = java_getJNIEnv();
+	}
+
+//simpleLog_fine(&quot;java_skirmishAI_init 1&quot;);
+	// create Java info Properties
+	jobject o_infoProps = NULL;
+	if (success) {
+		simpleLog_fine(&quot;creating Java info Properties for init() ...&quot;);
+		o_infoProps = java_createPropertiesFromCMap(env, infoSize, infoKeys, infoValues);
+		simpleLog_fine(&quot;done.&quot;);
+		success = (o_infoProps != NULL);
+	}
+
+	// create Java options Properties
+	jobject o_optionsProps = NULL;
+	if (success) {
+		simpleLog_fine(&quot;creating Java options Properties for init() ...&quot;);
+		o_optionsProps = java_createPropertiesFromCMap(env, optionsSize, optionsKeys, optionsValues);
+		simpleLog_fine(&quot;done.&quot;);
+		success = (o_optionsProps != NULL);
+	}
+
+	if (success) {
+		simpleLog_fine(&quot;calling Java AI method init(teamId)...&quot;);
+		res = (int) (*env)-&gt;CallIntMethod(env, o_ai, mth, (jint) teamId,
+				o_infoProps, o_optionsProps);
+		simpleLog_fine(&quot;done.&quot;);
+	}
+	ESTABLISH_SPRING_ENV;
+
+	return res;
+}
+
+int java_skirmishAI_release(int teamId) {
+
+	int res = -1;
+
+	jmethodID mth = NULL;
+	jobject o_ai = NULL;
+	bool success = java_getSkirmishAIAndMethod(teamId, &amp;o_ai, MTH_INDEX_SKIRMISH_AI_RELEASE, &amp;mth);
+
+	if (success) {
+		ESTABLISH_JAVA_ENV
+		JNIEnv* env = java_getJNIEnv();
+		simpleLog_fine(&quot;calling Java AI method release(teamId)...&quot;);
+		res = (int) (*env)-&gt;CallIntMethod(env, o_ai, mth, (jint) teamId);
+		simpleLog_fine(&quot;done.&quot;);
+		ESTABLISH_SPRING_ENV
+	}
+
+	return res;
+}
+
+int java_skirmishAI_handleEvent(int teamId, int topic, const void* data) {
+
+	int res = -1;
+
+	jmethodID mth = NULL;
+	jobject o_ai = NULL;
+	bool success = java_getSkirmishAIAndMethod(teamId, &amp;o_ai, MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT, &amp;mth);
+
+	if (success) {
+		ESTABLISH_JAVA_ENV;
+		JNIEnv* env = java_getJNIEnv();
+		//simpleLog_fine(&quot;calling Java AI method handleEvent(teamId, evt)...&quot;);
+/*
+if (topic == EVENT_INIT) {
+	simpleLog_fine(&quot;EVENT_INIT...&quot;);
+	const struct SInitEvent* initEvt = (const struct SInitEvent*) data;
+	simpleLog_fine(&quot;check: is Clb_Game_getCurrentFrame initialized...&quot;);
+	if (initEvt-&gt;callback-&gt;Clb_Game_getCurrentFrame == NULL) {
+		simpleLog_fine(&quot;Game_getCurrentFrame is NULL&quot;);
+	} else {
+		simpleLog_fine(&quot;Game_getCurrentFrame is NOT NULL&quot;);
+	}
+}
+*/
+		//jobject evt = java_toJavaAIEvent(env, teamId, topic, data);
+		//res = (int) (*env)-&gt;CallIntMethod(env, o_ai, mth, (jint) teamId, evt);
+		//res = (int) (*env)-&gt;CallIntMethod(env, o_ai, mth, (jint) teamId, topic, data);
+		//jlong jniPointerToData = (jlong) data;
+		//jlong jniPointerToData = (jlong) ((uintptr_t)data &amp; PAGEOFFSET);
+		jlong jniPointerToData = (jlong) ((intptr_t)data);
+		// instantiate a JNA Pointer
+		jobject jnaPointerToData = (*env)-&gt;NewObject(env, g_cls_jnaPointer,
+				g_m_jnaPointer_ctor_long, jniPointerToData);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!handleEvent: creating JNA pointer to data failed&quot;);
+			(*env)-&gt;ExceptionDescribe(env);
+			res = -3;
+		}
+		res = (int) (*env)-&gt;CallIntMethod(env, o_ai, mth, (jint) teamId, topic,
+				jnaPointerToData);
+		if ((*env)-&gt;ExceptionCheck(env)) {
+			simpleLog_log(&quot;!handleEvent() call failed&quot;);
+			(*env)-&gt;ExceptionDescribe(env);
+			res = -2;
+		}
+		//simpleLog_fine(&quot;done.&quot;);
+		ESTABLISH_SPRING_ENV;
+	}
+
+	return res;
+}
+
+
+
+/*
+		// make a new AI, specifying a jar
+		simpleLog_log(&quot;calling Java factory by-name method with \&quot;%s\&quot;...&quot;, aiJar);
+		jstring aiJarNameJava = jniEnv-&gt;NewStringUTF(aiJar);
+		javaAi = jniEnv-&gt;CallObjectMethod(factory, mid_factory_createAiByName, aiJarNameJava);
+	}
+	if (jniEnv-&gt;ExceptionCheck()) {
+		simpleLog_log(&quot;!Failed to get AI from factory.&quot;);
+		goto end;
+	}
+
+	// make the AI a global reference,
+	// so it will not be garbage collected,
+	// even after this method returned
+	javaAi = jniEnv-&gt;NewGlobalRef(javaAi);
+	if (jniEnv-&gt;ExceptionCheck()) {
+		simpleLog_log(&quot;!Failed to make AI a global reference.&quot;);
+		goto end;
+	}
+
+end:
+	if (jniEnv-&gt;ExceptionCheck()) {
+		javaAi = NULL;
+		jniEnv-&gt;ExceptionDescribe();
+	}
+
+	return javaAi;
+}
+
+
+
+IGlobalAI* ConnectJGlobalAI(struct JNIEnv* env, jobject javaAi) {
+
+	jclass javaAiClass;
+	SwigDirector_JGlobalAI* aiDirector;
+
+	static const bool swig_mem_own = true;
+	static const bool weak_global = false;
+
+	// make a new SWIG director, for connecting the Java AI with the native part
+	aiDirector = new SwigDirector_JGlobalAI(jniEnv);
+	if (jniEnv-&gt;ExceptionCheck()) {
+		simpleLog_log(&quot;!Failed to create SwigDirector_JGlobalAI.&quot;);
+		goto end;
+	}
+
+	// connect the SWIG director with the Java AI
+	javaAiClass = jniEnv-&gt;GetObjectClass(javaAi);
+	aiDirector-&gt;swig_connect_director(jniEnv, javaAi, javaAiClass, swig_mem_own, weak_global);
+	if (jniEnv-&gt;ExceptionCheck()) {
+		simpleLog_log(&quot;!Failed connecing SwigDirector_JGlobalAI.&quot;);
+		goto end;
+	}
+
+end:
+	if (jniEnv-&gt;ExceptionCheck()) {
+		aiDirector = NULL;
+		jniEnv-&gt;ExceptionDescribe();
+	}
+
+	return aiDirector;
+}
+*/
+
+/*
+
+DLL_EXPORT IGlobalAI* loadAIJar(const char* fileName) {
+
+	struct JNIEnv* env = getJNIEnv();
+
+	(*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
+
+	if (jniEnv == NULL) {
+		simpleLog_log(&quot;!JVM creation failed.&quot;);
+		return NULL;
+	}
+
+	jobject factory = GetFactory(jniEnv);
+	if (factory == NULL) {
+		simpleLog_log(&quot;!Factory creation failed.&quot;);
+		return NULL;
+	}
+
+	jobject javaAi = GetNewJGlobalAI(jniEnv, jarName);
+	if (javaAi == NULL) {
+		simpleLog_log(&quot;!Java AI creation failed.&quot;);
+		return NULL;
+	}
+
+	IGlobalAI* aiDirector = ConnectJGlobalAI(jniEnv, javaAi);
+	if (aiDirector == NULL) {
+		simpleLog_log(&quot;!Director creation failed.&quot;);
+		return NULL;
+	}
+
+	g_director_javaAis[aiDirector] = javaAi;
+
+	return aiDirector;
+}
+
+
+DLL_EXPORT void ReleaseAI(IGlobalAI* ai) {
+
+	JNIEnv* jniEnv = GetJNIEnv();
+	if (jniEnv == NULL) {
+		simpleLog_log(&quot;!JVM creation failed.&quot;);
+		simpleLog_log(&quot; -&gt; unable to delete global reference of Java AI.&quot;);
+	}
+
+	jobject javaAi = g_director_javaAis[ai];
+	g_director_javaAis.erase(ai);
+	ReleaseJavaAI(javaAi);
+
+	delete ai;
+	if (jniEnv != NULL) {
+		jniEnv-&gt;DeleteGlobalRef(javaAi);
+	}
+	javaAi = NULL;
+}
+*/
+
+
+/*
+int GetOptionsFromConfigFile(std::vector&lt;const char*&gt;* strOptions, const char* configFile) {
+
+	TiXmlDocument doc(configFile);
+	if (!doc.LoadFile()) return -1;
+
+	TiXmlHandle hDoc(&amp;doc);
+	TiXmlElement* pElem;
+	TiXmlHandle hRoot(0);
+	TiXmlHandle hJvm(0);
+	int numOptions = 0;
+
+	// get root node
+	{
+		pElem = hDoc.FirstChildElement().Element();
+		// should always have a valid root but handle gracefully if not
+		if (!pElem) return -2;
+		hRoot = TiXmlHandle(pElem);
+	}
+
+	// read options
+	{
+		pElem = hRoot.FirstChild(&quot;jvm&quot;).Element();
+		if (pElem == NULL) return -3;
+		hJvm = TiXmlHandle(pElem);
+
+		pElem = hJvm.FirstChild(&quot;option&quot;).Element();
+		for (pElem; pElem; pElem = pElem-&gt;NextSiblingElement()) {
+			if (pElem-&gt;GetText()) {
+				char* textCopy = new char[strlen(pElem-&gt;GetText()) + 1];
+				strcpy(textCopy, pElem-&gt;GetText());
+				strOptions-&gt;push_back(textCopy);
+				numOptions++;
+			}
+		}
+	}
+
+	return numOptions;
+}
+
+
+*/
+
+
+/*
+bool ReleaseJavaAI(jobject javaAi) {
+
+	jclass cls_javaAiImpl = NULL;
+	jmethodID release_mid = NULL;
+
+	JNIEnv* jniEnv = GetJNIEnv();
+	if (jniEnv == NULL) {
+		simpleLog_fine(&quot;!JVM creation failed.&quot;);
+		return false;
+	}
+
+	cls_javaAiImpl = jniEnv-&gt;GetObjectClass(javaAi);
+	release_mid = jniEnv-&gt;GetMethodID(cls_javaAiImpl, MTH_AI_RELEASE, SIG_AI_RELEASE);
+	if (release_mid == 0) {
+		simpleLog_fine(&quot;!Can't find method: (? extends &quot;CLS_AI&quot;).&quot;MTH_AI_RELEASE&quot;&quot;SIG_AI_RELEASE);
+		goto end;
+	}
+
+	jniEnv-&gt;CallVoidMethod(javaAi, release_mid);
+	if (jniEnv-&gt;ExceptionCheck()) {
+		simpleLog_fine(&quot;!Error when calling: (? extends &quot;CLS_AI&quot;).&quot;MTH_AI_RELEASE&quot;&quot;SIG_AI_RELEASE);
+		goto end;
+	}
+
+end:
+	if (jniEnv-&gt;ExceptionCheck() || release_mid == 0) {
+		simpleLog_fine(&quot;!Failed releasing Java AI.&quot;);
+		jniEnv-&gt;ExceptionDescribe();
+		return false;
+	}
+
+	return true;
+}
+*/


Property changes on: branches/caiinterface/AI/Interfaces/Java/JavaBridge.c
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/JavaBridge.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/JavaBridge.h	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,130 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+ */
+
+#ifndef _JAVABRIDGE_H
+#define	_JAVABRIDGE_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;stdbool.h&gt;	// bool, true, false
+
+#include &quot;ExternalAI/Interface/SInfo.h&quot;
+
+struct SStaticGlobalData;
+struct SAICallback;
+
+/**
+ * Returns a JNI environment, which includes a JVM.
+ * Only one will exist at a time.
+ * It is lazyly created.
+ *
+ * JNI = Java Native Interface
+ * JVM = Java Virtual Machine
+ */
+//JNIEnv* getJNIEnv();
+
+// #############################################################################
+// ### checked till here
+// #############################################################################
+
+#define JAI_DIR &quot;AI/Bot-libs/JAI&quot;
+#define IMPL_DIR &quot;AI/Bot-libs&quot;
+//#define IMPL_DIR JAI_DIR&quot;/impl&quot;
+#define LIB_DIR JAI_DIR&quot;/lib&quot;
+#define LOG_DIR JAI_DIR&quot;/log&quot;
+
+#define CONFIG_FILE JAI_DIR&quot;/config.xml&quot;
+#define LOG_FILE LOG_DIR&quot;/native-log.txt&quot;
+
+#define JVM_LOGGING true
+#define JVM_DEBUGGING false
+#define JVM_DEBUG_PORT &quot;7777&quot;
+#define MAX_JARS 512
+
+
+#define PKG_MAIN	&quot;com/clan_sy/spring/ai/&quot;
+#define PKG_EVENT	&quot;com/clan_sy/spring/ai/event/&quot;
+#define PKG_COMMAND	&quot;com/clan_sy/spring/ai/command/&quot;
+#define CLS_AI			PKG_MAIN&quot;AI&quot;
+#define CLS_AI_EVENT	PKG_MAIN&quot;AIEvent&quot;
+#define CLS_AI_CALLBACK	PKG_MAIN&quot;AICallback&quot;
+
+// #############################################################################
+// AI methods
+
+#define MTH_INDEX_SKIRMISH_AI_INIT			0
+#define MTH_SKIRMISH_AI_INIT &quot;init&quot;
+#define SIG_SKIRMISH_AI_INIT &quot;(ILjava/util/Properties;Ljava/util/Properties;)I&quot;
+
+#define MTH_INDEX_SKIRMISH_AI_RELEASE		1
+#define MTH_SKIRMISH_AI_RELEASE &quot;release&quot;
+#define SIG_SKIRMISH_AI_RELEASE &quot;(I)I&quot;
+
+#define MTH_INDEX_SKIRMISH_AI_HANDLE_EVENT	2
+#define MTH_SKIRMISH_AI_HANDLE_EVENT &quot;handleEvent&quot;
+//#define SIG_SKIRMISH_AI_HANDLE_EVENT &quot;(IL&quot;CLS_AI_EVENT&quot;;)I&quot;
+#define SIG_SKIRMISH_AI_HANDLE_EVENT &quot;(IILcom/sun/jna/Pointer;)I&quot;
+
+
+#define MTHS_SIZE_SKIRMISH_AI				3
+
+
+
+
+
+#ifdef WIN32
+#define ENTRY_DELIM &quot;;&quot;
+#else
+#define ENTRY_DELIM &quot;:&quot;
+#endif
+#define PATH_DELIM &quot;/&quot;
+
+
+//jobject GetFactory(JNIEnv* jniEnv);
+//jobject GetNewJGlobalAI(
+//IGlobalAI* ConnectJGlobalAI(JNIEnv* jniEnv, jobject javaAi);
+//bool ReleaseJavaAI(jobject javaAi);
+//
+//
+//DLL_EXPORT IGlobalAI* GetNewAIByName(const char* jarName);
+//DLL_EXPORT void ReleaseAI(IGlobalAI* ai);
+//
+//bool endsWith(const char* str, const char* suffix);
+
+bool java_preloadJNIEnv();
+bool java_unloadJNIEnv();
+bool java_initStatic(const struct SStaticGlobalData* staticGlobalData);
+bool java_releaseStatic();
+bool java_initSkirmishAIClass(const char* className);
+bool java_releaseSkirmishAIClass(const char* className);
+bool java_releaseAllSkirmishAIClasses();
+int java_skirmishAI_init(int teamId,
+		unsigned int infoSize,
+		const char** infoKeys, const char** infoValues,
+		unsigned int optionsSize,
+		const char** optionsKeys, const char** optionsValues);
+const struct SAICallback* java_getSkirmishAICCallback(int teamId);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	// _JAVABRIDGE_H
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/JavaBridge.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/Log.c
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/Log.c	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/Log.c	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,118 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+ */
+
+#include &quot;Log.h&quot;
+
+#include &quot;InterfaceUtil.h&quot;
+#include &quot;InterfaceDefines.h&quot;
+
+#include &lt;stdio.h&gt;	// for file IO
+#include &lt;stdlib.h&gt;	// calloc(), exit()
+#include &lt;string.h&gt;	// strlen(), strcpy()
+#include &lt;time.h&gt;	// for fetching current time
+#include &lt;stdarg.h&gt;	// var-arg support
+
+static const unsigned int bufferSize = 2048;
+
+const char* myLogFileName = NULL;
+bool useTimeStamps;
+bool isFineLog;
+
+void simpleLog_init(const char* _logFileName, bool _useTimeStamps,
+		bool _isFineLog) {
+
+	// NOTE: causeing a memory leack, as it is never freed.
+	// but it is used till the end of the applications runtime anyway
+	// -&gt; no problem
+	char* logFileName = (char*) calloc(strlen(_logFileName) + 1, sizeof (char));
+	STRCPY(logFileName, _logFileName);
+	myLogFileName = logFileName;
+
+	useTimeStamps = _useTimeStamps;
+	isFineLog = _isFineLog;
+
+	simpleLog_log(&quot;\n\n[logging started]&quot;);
+}
+
+char* simpleLog_createTimeStamp() {
+
+	time_t now;
+	now = time(&amp;now);
+	struct tm* myTime = localtime(&amp;now);
+	unsigned int maxTimeStampSize = 32;
+	char* timeStamp = (char*) calloc(maxTimeStampSize + 1, sizeof (char));
+	strftime(timeStamp, maxTimeStampSize, &quot;%c&quot;, myTime);
+
+	return timeStamp;
+}
+
+void simpleLog_out(const char* msg) {
+
+	if (myLogFileName != NULL) {
+		FILE* file = FOPEN(myLogFileName, &quot;a&quot;);
+		if (useTimeStamps) {
+			char* timeStamp = simpleLog_createTimeStamp();
+			FPRINTF(file, &quot;%s: %s\n&quot;, timeStamp, msg);
+			free(timeStamp);
+		} else {
+			FPRINTF(file, &quot;%s\n&quot;, msg);
+		}
+		fclose(file);
+	} else {
+		// fallback method: write to stdout
+		PRINTF(msg);
+	}
+}
+
+void simpleLog_logv(const char* fmt, va_list argp) {
+	
+	char text[bufferSize];
+
+	VSNPRINTF(text, sizeof(text), fmt, argp);
+	simpleLog_out(text);
+}
+
+void simpleLog_log(const char* fmt, ...) {
+
+	va_list argp;
+
+	va_start(argp, fmt);
+	simpleLog_logv(fmt, argp);
+	va_end(argp);
+}
+
+void simpleLog_fine(const char* fmt, ...) {
+
+	if (isFineLog) {
+		va_list argp;
+
+		va_start(argp, fmt);
+		simpleLog_logv(fmt, argp);
+		va_end(argp);
+	}
+}
+
+void simpleLog_error(int error, const char* fmt, ...) {
+
+	va_list argp;
+
+	va_start(argp, fmt);
+	simpleLog_logv(fmt, argp);
+	va_end(argp);
+
+	exit(error);
+}


Property changes on: branches/caiinterface/AI/Interfaces/Java/Log.c
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/Log.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/Log.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/Log.h	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,58 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _LOG_H
+#define	_LOG_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+#include &lt;stdbool.h&gt;	// bool, true, false
+
+#define EXTERNAL_LOGGER(msg)	log(msg);
+
+/**
+ * Initializes the log.
+ */
+void simpleLog_init(const char* logFileName, bool useTimeStamps,
+		bool isFineLog);
+
+/**
+ * Logs a text message.
+ * Works like printf(fmt, ...).
+ */
+void simpleLog_log(const char* fmt, ...);
+
+/**
+ * Logs a text message only if log is initialized to fine.
+ * Works like printf(fmt, ...).
+ */
+void simpleLog_fine(const char* fmt, ...);
+
+/**
+ * Logs a text message and exits.
+ * Works like printf(fmt, ...).
+ */
+void simpleLog_error(int error, const char* msg, ...);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	// _LOG_H
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/Log.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/README
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/README	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/README	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1 @@
+All these files will not be linked into the engine, but to a separate shared library.


Property changes on: branches/caiinterface/AI/Interfaces/Java/README
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/StreflopBridge.cpp
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/StreflopBridge.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/StreflopBridge.cpp	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,33 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;StreflopBridge.h&quot;
+
+#include &quot;streflop_cond.h&quot;
+/*
+#include &lt;stdbool.h&gt;	// bool, true, false
+#include &lt;string.h&gt;	// strlen(), strcat(), strcpy()
+#include &lt;stdlib.h&gt;	// malloc(), calloc(), free()
+*/
+
+void streflopBridge_setSpringFPUSettings() {
+	streflop_init&lt;Simple&gt;();
+}
+
+void streflopBridge_setJavaFPUSettings() {
+	streflop_init&lt;Double&gt;();
+}


Property changes on: branches/caiinterface/AI/Interfaces/Java/StreflopBridge.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/StreflopBridge.h
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/StreflopBridge.h	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/StreflopBridge.h	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,43 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _STREFLOPBRIDGE_H
+#define _STREFLOPBRIDGE_H
+
+#ifdef	__cplusplus
+extern &quot;C&quot; {
+#endif
+
+
+#define ESTABLISH_SPRING_ENV	streflopBridge_setSpringFPUSettings();
+//#define ESTABLISH_SPRING_ENV
+
+//#define ESTABLISH_JAVA_ENV	streflopBridge_setJavaFPUSettings();
+#define ESTABLISH_JAVA_ENV
+
+
+void streflopBridge_setSpringFPUSettings();
+
+void streflopBridge_setJavaFPUSettings();
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	// _STREFLOPBRIDGE_H
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/StreflopBridge.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/VERSION
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/VERSION	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/VERSION	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1 @@
+0.1
\ No newline at end of file


Property changes on: branches/caiinterface/AI/Interfaces/Java/VERSION
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.bat
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.bat	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.bat	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,16 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">+ at ECHO</A> OFF
+REM
+REM Go through the whole Java build process
+REM @param_1	interface version (eg: &quot;0.1&quot;)
+REM
+
+SET INTERFACE_VERSION=%1
+IF &quot;%INTERFACE_VERSION%&quot;==&quot;&quot; (
+	ECHO &quot;Usage %0 [java-interface-version]&quot;
+	EXIT 1
+)
+
+call ./java_generateWrappers.bat
+call ./java_compile.bat
+call ./java_install.bat %INTERFACE_VERSION%
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.bat
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.sh
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.sh	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.sh	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,17 @@
+#!/bin/sh
+#
+# Go through the whole Java build process
+# @param_1	interface version (eg: &quot;0.1&quot;)
+#
+
+if [ $# != 1 ]
+then
+	echo &quot;Usage: $0 [java-interface-version]&quot; 1&gt;&amp;2
+	exit 1
+fi
+INTERFACE_VERSION=$1
+
+sh ./java_generateWrappers.sh
+sh ./java_compile.sh
+sh ./java_install.sh $INTERFACE_VERSION
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_buildAll.sh
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_compile.bat
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_compile.bat	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_compile.bat	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,16 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">+ at ECHO</A> OFF
+REM
+REM Compiles the Java sources
+REM
+
+SET JAVA_PKG=com/clan_sy/spring/ai
+SET JAVA_PKG_J=com.clan_sy.spring.ai
+
+ECHO &quot;	compiling ...&quot;
+cd ../java/src
+javac -cp &quot;../../jlib/jna.jar;../../jlib/vecmath.jar&quot; %JAVA_PKG%/*.java %JAVA_PKG%/command/*.java %JAVA_PKG%/event/*.java  %JAVA_PKG%/oo/*.java
+jar cmf manifest.mf interface.jar com
+rm %JAVA_PKG%/*.class %JAVA_PKG%/command/*.class %JAVA_PKG%/event/*.class  %JAVA_PKG%/oo/*.class
+mv interface.jar ../..
+cd ../../bin
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_compile.bat
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_compile.sh
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_compile.sh	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_compile.sh	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,16 @@
+#!/bin/sh
+#
+# Compiles the Java sources
+#
+
+JAVA_PKG=com/clan_sy/spring/ai
+JAVA_PKG_J=com.clan_sy.spring.ai
+
+echo &quot;	compiling ...&quot;
+cd ../java/src
+javac -cp &quot;../../jlib/jna.jar:../../jlib/vecmath.jar&quot; ${JAVA_PKG}/*.java ${JAVA_PKG}/command/*.java ${JAVA_PKG}/event/*.java ${JAVA_PKG}/oo/*.java
+jar cmf manifest.mf interface.jar com
+rm ${JAVA_PKG}/*.class ${JAVA_PKG}/command/*.class ${JAVA_PKG}/event/*.class ${JAVA_PKG}/oo/*.class
+mv interface.jar ../..
+cd ../../bin
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_compile.sh
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.bat
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.bat	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.bat	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,29 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">+ at ECHO</A> OFF
+REM
+REM Generates the Java JNA wrapper source files
+REM
+
+SET SPRING_SOURCE=../../../../rts
+SET MY_SOURCE_JAVA=../java/src/
+SET JAVA_PKG=com/clan_sy/spring/ai
+
+C_CALLBACK=%SPRING_SOURCE%/ExternalAI/Interface/SAICallback.h
+C_EVENTS=%SPRING_SOURCE%/ExternalAI/Interface/AISEvents.h
+C_COMMANDS=%SPRING_SOURCE%/ExternalAI/Interface/AISCommands.h
+JNA_CALLBACK=%MY_SOURCE_JAVA%%JAVA_PKG%/AICallback.java
+
+SET AWK=gawk.exe
+
+REM ##############################################
+REM ### do not change anything below this line ###
+
+REM ECHO &quot;	generating source files ...&quot;
+
+%AWK% -f jna_wrappEvents.awk %C_EVENTS%
+
+%AWK% -f jna_wrappCommands.awk %C_COMMANDS%
+
+%AWK% -f jna_wrappCallback.awk %C_CALLBACK%
+
+%AWK% -f java_wrappCallbackOO.awk %JNA_CALLBACK%
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.bat
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.sh
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.sh	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.sh	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,29 @@
+#!/bin/bash
+#
+# Generates the Java JNA wrapper source files
+#
+
+SPRING_SOURCE=../../../../rts
+MY_SOURCE_JAVA=../java/src/
+JAVA_PKG=com/clan_sy/spring/ai
+
+C_CALLBACK=${SPRING_SOURCE}/ExternalAI/Interface/SAICallback.h
+C_EVENTS=${SPRING_SOURCE}/ExternalAI/Interface/AISEvents.h
+C_COMMANDS=${SPRING_SOURCE}/ExternalAI/Interface/AISCommands.h
+JNA_CALLBACK=${MY_SOURCE_JAVA}${JAVA_PKG}/AICallback.java
+
+AWK=awk
+
+##############################################
+### do not change anything below this line ###
+
+#echo &quot;	generating source files ...&quot;
+
+$AWK -f jna_wrappEvents.awk ${C_EVENTS}
+
+$AWK -f jna_wrappCommands.awk ${C_COMMANDS}
+
+$AWK -f jna_wrappCallback.awk ${C_CALLBACK}
+
+$AWK -f java_wrappCallbackOO.awk ${JNA_CALLBACK}
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_generateWrappers.sh
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_install.bat
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_install.bat	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_install.bat	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,19 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">+ at ECHO</A> OFF
+REM
+REM Move the Java Part of the interface to its final destination.
+REM @param	interface version (eg: &quot;0.1&quot;)
+REM
+
+SET INTERFACE_VERSION=%1
+IF &quot;%INTERFACE_VERSION%&quot;==&quot;&quot; (
+	ECHO &quot;Usage %0 [java-interface-version]&quot;
+	EXIT 1
+)
+
+SET MY_HOME=..
+SET SPRING_HOME=%MY_HOME%/../../..
+
+ECHO &quot;	installing ...&quot;
+mkdir -p %SPRING_HOME%/game/AI/Interfaces/Java/%INTERFACE_VERSION%/jlib
+cp %MY_HOME%/interface.jar %SPRING_HOME%/game/AI/Interfaces/Java/%INTERFACE_VERSION%
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_install.bat
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_install.sh
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_install.sh	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_install.sh	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,20 @@
+#!/bin/sh
+#
+# Move the Java Part of the interface to its final destination.
+# @param	interface version (eg: &quot;0.1&quot;)
+#
+
+if [ $# != 1 ]
+then
+	echo &quot;Usage: $0 [java-interface-version]&quot; 1&gt;&amp;2
+	exit 1
+fi
+INTERFACE_VERSION=$1
+
+MY_HOME=..
+SPRING_HOME=${MY_HOME}/../../..
+
+echo &quot;	installing ...&quot;
+mkdir -p ${SPRING_HOME}/game/AI/Interfaces/Java/${INTERFACE_VERSION}/jlib
+cp ${MY_HOME}/interface.jar ${SPRING_HOME}/game/AI/Interfaces/Java/${INTERFACE_VERSION}
+


Property changes on: branches/caiinterface/AI/Interfaces/Java/bin/java_install.sh
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/bin/java_wrappCallbackOO.awk
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/java_wrappCallbackOO.awk	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/java_wrappCallbackOO.awk	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,1111 @@
+#!/bin/awk
+#
+# This awk script creates a Java class in OO style to wrapp the C style
+# JNA based AI Callback wrapper.
+# In other words, the output of this file wrapps:
+# com/clan_sy/spring/ai/AICallback.java
+# which wrapps:
+# rts/ExternalAI/Interface/SAICallback.h
+#
+
+BEGIN {
+	# initialize things
+
+	# define the field splitter(-regex)
+	#FS=&quot;[ \t]+&quot;;
+	FS=&quot;(\\()|(\\)\\;)&quot;;
+	IGNORECASE = 0;
+
+	javaSrcRoot = &quot;../java/src&quot;;
+
+	myParentPkgA = &quot;com.clan_sy.spring.ai&quot;;
+	myPkgA = myParentPkgA &quot;.oo&quot;;
+	myPkgD = convertJavaNameFormAToD(myPkgA);
+	myClass = &quot;OOAICallback&quot;;
+	myClassVar = &quot;ooClb&quot;;
+	myWrapClass = &quot;AICallback&quot;;
+	myWrapVar = &quot;innerCallback&quot;;
+	mySourceFile = javaSrcRoot &quot;/&quot; myPkgD &quot;/&quot; myClass &quot;.java&quot;;
+	MAX_IDS = 1024;
+	defMapJavaImpl = &quot;HashMap&quot;;
+
+	myBufferedClasses[&quot;_UnitDef&quot;] = 1;
+	myBufferedClasses[&quot;_WeaponDef&quot;] = 1;
+	myBufferedClasses[&quot;_FeatureDef&quot;] = 1;
+
+	size_funcs = 0;
+	size_classes = 0;
+	size_interfaces = 0;
+	# initialize all arrays
+	#funcFullName[&quot;&quot;] = 0;
+	#funcRetType[&quot;&quot;] = 0;
+	#funcParams[&quot;&quot;] = 0;
+	#funcInnerParams[&quot;&quot;] = 0;
+	#class_ancestors[&quot;&quot;] = 0;
+}
+
+
+# Some utility functions
+
+function ltrim(s) { sub(/^[ \t]+/, &quot;&quot;, s); return s; }
+function rtrim(s) { sub(/[ \t]+$/, &quot;&quot;, s); return s; }
+function trim(s)  { return rtrim(ltrim(s)); }
+
+function noSpaces(s)  { gsub(/[ \t]/, &quot;&quot;, s); return s; }
+
+function capitalize(s)  { return toupper(substr(s, 1, 1)) substr(s, 2); }
+function lowerize(s)  { return tolower(substr(s, 1, 1)) substr(s, 2); }
+
+function startsWithCapital(s) { return match(s, /^[ABCDEFGHIJKLMNOPQRDTUVWXYZ]/); }
+function startsWithLower(s) { return match(s, /^[abcdefghijklmnopqrdtuvwxyz]/); }
+
+# sort function -- sorts an array based on values (wether numbers or strings)
+# in ascending order; first array element at index [1]
+function mySort(array, size, temp, i, j) {
+
+	for (i = 2; i &lt;= size; ++i) {
+		for (j = i; array[j-1] &gt; array[j]; --j) {
+			temp = array[j];
+			array[j] = array[j-1];
+			array[j-1] = temp;
+		}
+	}
+}
+
+# Awaits this format:	com.clan_sy.spring.ai
+# Returns this format:	com/clan_sy/spring/ai
+function convertJavaNameFormAToD(javaNameFormA) {
+
+	javaNameFormD = javaNameFormA;
+
+	gsub(/\./, &quot;/&quot;, javaNameFormD);
+
+	return javaNameFormD;
+}
+
+# Awaits this format:	int / float / String
+# Returns this format:	Integer / Float / String
+function convertJavaBuiltinTypeToClass(javaBuiltinType_bt) {
+
+	javaClassType_bt = javaBuiltinType_bt;
+
+	sub(/int/, &quot;Integer&quot;, javaClassType_bt);
+	sub(/float/, &quot;Float&quot;, javaClassType_bt);
+
+	sub(/boolean/, &quot;Boolean&quot;, javaClassType_bt);
+	sub(/byte/, &quot;Byte&quot;, javaClassType_bt);
+	sub(/char/, &quot;Character&quot;, javaClassType_bt);
+	sub(/double/, &quot;Double&quot;, javaClassType_bt);
+	sub(/float/, &quot;Float&quot;, javaClassType_bt);
+	sub(/int/, &quot;Integer&quot;, javaClassType_bt);
+	sub(/long/, &quot;Long&quot;, javaClassType_bt);
+	sub(/short/, &quot;Short&quot;, javaClassType_bt);
+
+	return javaClassType_bt;
+}
+
+
+
+function printGeneratedWarningHeader(outFile) {
+
+	print(&quot;// WARNING: This file is machine generated,&quot;) &gt; outFile;
+	print(&quot;// please do not edit directly!&quot;) &gt;&gt; outFile;
+}
+
+function printGPLHeader(outFile) {
+
+	print(&quot;/*&quot;) &gt;&gt; outFile;
+	print(&quot;	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is free software; you can redistribute it and/or modify&quot;) &gt;&gt; outFile;
+	print(&quot;	it under the terms of the GNU General Public License as published by&quot;) &gt;&gt; outFile;
+	print(&quot;	the Free Software Foundation; either version 2 of the License, or&quot;) &gt;&gt; outFile;
+	print(&quot;	(at your option) any later version.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is distributed in the hope that it will be useful,&quot;) &gt;&gt; outFile;
+	print(&quot;	but WITHOUT ANY WARRANTY; without even the implied warranty of&quot;) &gt;&gt; outFile;
+	print(&quot;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&quot;) &gt;&gt; outFile;
+	print(&quot;	GNU General Public License for more details.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	You should have received a copy of the GNU General Public License&quot;) &gt;&gt; outFile;
+	print(&quot;	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.&quot;) &gt;&gt; outFile;
+	print(&quot;*/&quot;) &gt;&gt; outFile;
+}
+
+
+function printCommentsHeader(outFile) {
+
+	printGeneratedWarningHeader(outFile);
+	print(&quot;&quot;) &gt;&gt; outFile;
+	printGPLHeader(outFile);
+}
+
+function printHeader(outFile_h, javaPkg_h, javaClassName_h, isOrHasInterface_h) {
+
+	classOrInterface = &quot;class&quot;;
+	implementedInterfacePart = &quot;&quot;;
+	if (isOrHasInterface_h == 1) {
+		classOrInterface = &quot;interface&quot;;
+	} else if (isOrHasInterface_h != 0) {
+		implementedInterfacePart = &quot; implements &quot; isOrHasInterface_h;
+	}
+
+	printCommentsHeader(outFile_h);
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;package &quot; javaPkg_h &quot;;&quot;) &gt;&gt; outFile_h;
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	#print(&quot;import &quot; myParentPkgA &quot;.AIFloat3;&quot;) &gt;&gt; outFile_h;
+	#print(&quot;import &quot; myParentPkgA &quot;.AICallback;&quot;) &gt;&gt; outFile_h;
+	print(&quot;import &quot; myParentPkgA &quot;.*;&quot;) &gt;&gt; outFile_h;
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;/**&quot;) &gt;&gt; outFile_h;
+	print(&quot; * @author	AWK wrapper script&quot;) &gt;&gt; outFile_h;
+	print(&quot; * @version	GENERATED&quot;) &gt;&gt; outFile_h;
+	print(&quot; */&quot;) &gt;&gt; outFile_h;
+	print(&quot;public &quot; classOrInterface &quot; &quot; javaClassName_h implementedInterfacePart &quot; {&quot;) &gt;&gt; outFile_h;
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+}
+
+
+
+function removeParamTypes(params) {
+
+	innerParams = params;
+
+	sub(/^[^ ]* /, &quot;&quot;, innerParams);
+	gsub(/, [^ ]*/, &quot;,&quot;, innerParams);
+
+	return innerParams;
+}
+
+function matchesAnyKey(toSearch, matchArray) {
+
+	for (pattern in matchArray) {
+		if (match(toSearch, pattern)) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+function isBufferedFunc(funcFullName_b) {
+
+	np_b = extractNormalPart(funcFullName_b);
+
+	return matchesAnyKey(np_b, myBufferedClasses);
+}
+
+function isBufferedClass(clsName_bc) {
+
+	np_bc = extractNormalPart(clsName_bc);
+
+	return matchesAnyKey(np_bc, myBufferedClasses);
+}
+
+function extractNormalPart(namePart_a) {
+
+	normalPart_a = namePart_a;
+
+	do {
+		replaced_a = sub(/0[^0]*0/, &quot;0&quot;, normalPart_a);
+	} while (replaced_a);
+
+	sub(/0/, &quot;&quot;, normalPart_a);
+
+	return normalPart_a;
+}
+
+
+function createJavaFileName(clsName_c) {
+	return javaSrcRoot &quot;/&quot; myPkgD &quot;/&quot; clsName_c &quot;.java&quot;;
+}
+
+function part_isClass(namePart_p) {
+	sub(/0.*0/, &quot;&quot;, namePart_p);
+	return startsWithCapital(namePart_p);
+}
+function part_isStatic(namePart_p) {
+	return match(namePart_p, /0STATIC0/);
+}
+function part_isArraySize(namePart_p) {
+	return match(namePart_p, /0ARRAY1SIZE0/);
+}
+function part_isArrayValues(namePart_p) {
+	return match(namePart_p, /0ARRAY1VALS0/);
+}
+function part_isMapSize(namePart_p) {
+	return match(namePart_p, /0MAP1SIZE0/);
+}
+function part_isMapKeys(namePart_p) {
+	return match(namePart_p, /0MAP1KEYS0/);
+}
+function part_isMapValues(namePart_p) {
+	return match(namePart_p, /0MAP1VALS0/);
+}
+function part_isMultiSize(namePart_p) {
+	return match(namePart_p, /0MULTI1SIZE[0123]/);
+}
+function part_isMultiValues(namePart_p) {
+	return match(namePart_p, /0MULTI1SIZE[0123]/);
+}
+function part_isMultiFetch(namePart_p) {
+	return match(namePart_p, /0MULTI1FETCH[0123]/);
+}
+function part_isSingleFetch(namePart_p) {
+	return match(namePart_p, /0SINGLE1FETCH[0123]/);
+}
+function part_isAvailable(namePart_p) {
+	return match(namePart_p, /0AVAILABLE0/);
+}
+function part_hasReferenceObject(namePart_p) {
+	return match(namePart_p, /0REF[^0]*0/);
+}
+function part_getClsName(ancestorsPlusName_p) {
+
+	normalAPN_p = extractNormalPart(ancestorsPlusName_p);
+
+	if (ancestorsPlusName_clsName[normalAPN_p] != &quot;&quot;) {
+		return ancestorsPlusName_clsName[normalAPN_p];
+	}
+
+	clsName_a = ancestorsPlusName_p;
+
+	isClsMemberNameDifferent = match(ancestorsPlusName_p, /0MULTI1SIZE[^0]*2[_a-zA-Z]+[^0]*0/);
+#if (match(normalAPN_p, /Clb/)) { print(&quot;normalAPN_p: &quot; normalAPN_p); }
+	if (isClsMemberNameDifferent) {
+		sub(/^.*0MULTI1SIZE[^2]2*/, &quot;&quot;, clsName_a);
+		sub(/[0123].*$/, &quot;&quot;, clsName_a);
+	} else {
+		sub(/^.*_/, &quot;&quot;, clsName_a);
+		clsName_a = extractNormalPart(clsName_a);
+	}
+
+	ancestorsPlusName_clsName[normalAPN_p] = clsName_a;
+
+	return clsName_a;
+}
+
+function store_class(ancestors_s, clsName_s) {
+
+#if (match(clsName_s, /Clb$/)) { print(&quot;clsName_s: &quot; clsName_s); }
+#if (match(ancestors_s, /Clb$/)) { print(&quot;ancestors_s: &quot; ancestors_s); }
+	if (!(clsName_s in class_ancestors)) {
+		class_ancestors[clsName_s] = ancestors_s;
+	} else if (!match(class_ancestors[clsName_s], &quot;((^)|(,))&quot; ancestors_s &quot;(($)|(,))&quot;)) {
+	#} else if (!match(class_ancestors[clsName_s], ancestors_s)) {
+		class_ancestors[clsName_s] = class_ancestors[clsName_s] &quot;,&quot; ancestors_s;
+	}
+
+	if (!(ancestors_s in ancestors_class)) {
+		ancestors_class[ancestors_s] = clsName_s;
+	} else if (!match(ancestors_class[ancestors_s], &quot;((^)|(,))&quot; clsName_s &quot;(($)|(,))&quot;)) {
+	#} else if (!match(ancestors_class[ancestors_s], clsName_s)) {
+		ancestors_class[ancestors_s] = ancestors_class[ancestors_s] &quot;,&quot; clsName_s;
+	}
+}
+
+
+
+
+function storeClassesAndInterfaces() {
+
+	mySort(funcFullNames);
+
+	additionalClsIndices[&quot;*&quot;] = 0;
+	additionalClsIndices[&quot;-&quot; myClass &quot;*&quot;] = 0;
+
+	# store classes and assign functions
+	for (f=0; f &lt; size_funcs; f++) {
+		fullName = funcFullName[f];
+		retType = funcRetType[fullName];
+		params = funcParams[fullName];
+		innerParams = funcInnerParams[fullName];
+
+		size_nameParts = split(fullName, nameParts, &quot;_&quot;);
+
+		# go through the classes
+		ancestorsP = &quot;&quot;;
+		last_ancestorsP = &quot;&quot;;
+		clsName = myClass;
+		clsId = ancestorsP &quot;-&quot; clsName;
+		last_clsId = &quot;&quot;;
+		for (np=0; np &lt; size_nameParts-1; np++) {
+			last_clsName = clsName;
+			last_clsId = clsId;
+
+			nameP = nameParts[np+1];
+#if (match(nameP, /Clb/)) { print(&quot;nameP: &quot; nameP); }
+			normalP = extractNormalPart(nameP);
+
+			# register class
+			clsName = part_getClsName(ancestorsP &quot;_&quot; nameP);
+			#if (clsName == myClass) { normalP = clsName; }
+			clsId = ancestorsP &quot;-&quot; clsName;
+			store_class(ancestorsP, clsName);
+#if (match(ancestorsP, /Clb$/)) { print(&quot;ancestorsP/clsName: &quot; ancestorsP &quot; / &quot; clsName); }
+
+			if (additionalClsIndices[clsId &quot;*&quot;] == &quot;&quot;) {
+				additionalClsIndices[clsId &quot;*&quot;] = additionalClsIndices[last_clsId &quot;*&quot;];
+#print(&quot;additionalClsIndices I init : &quot; clsId &quot; / &quot;  last_clsId &quot; / &quot; additionalClsIndices[last_clsId &quot;*&quot;]);
+			}
+			if (part_isMultiSize(nameP)) {
+				parentNumInd = additionalClsIndices[last_clsId &quot;*&quot;];
+				#size_paramNames = split(innerParams, paramNames, &quot;, &quot;);
+				#indName = paramNames[1 + parentNumInd];
+				#additionalClsIndices[clsId &quot;#&quot; parentNumInd] = indName;
+				additionalClsIndices[clsId &quot;*&quot;] = parentNumInd + 1;
+#print(&quot;additionalClsIndices I ++ : &quot; clsId &quot; / &quot;  last_clsId &quot; / &quot; additionalClsIndices[clsId &quot;*&quot;]);
+			}
+			
+			secondLast_clsName = last_clsName;
+			last_ancestorsP = ancestorsP;
+			ancestorsP = ancestorsP &quot;_&quot; normalP;
+#print(&quot;clsName: &quot; clsName);
+#print(&quot;ancestorsP: &quot; ancestorsP);
+#print(&quot;last_ancestorsP: &quot; last_ancestorsP);
+		}
+
+		nameP = nameParts[size_nameParts];
+		normalP = extractNormalPart(nameP);
+		secondLast_clsName = last_clsName;
+		last_clsName = clsName;
+		clsName = part_getClsName(ancestorsP &quot;_&quot; nameP);
+		last_clsId = clsId;
+		clsId = ancestorsP &quot;-&quot; clsName;
+
+		isClass = part_isClass(normalP);
+#print(&quot;normalP: &quot; normalP);
+#print(&quot;startsWithCapital X: &quot; match(&quot;X&quot;, /^[ABCDEFGHIJKLMNOPQRDTUVWXYZ]/));
+#print(&quot;startsWithCapital X: &quot; tolower(&quot;ABCDEFGHIJKLMNOPQRDTUVWXYZ&quot;));
+#print(&quot;startsWithCapital x: &quot; match(&quot;x&quot;, /^[ABCX]/));
+#print(&quot;startsWithLower X: &quot; match(&quot;X&quot;, /^[a-z]/));
+#print(&quot;startsWithLower x: &quot; match(&quot;x&quot;, /^[a-z]/));
+#print(&quot;startsWithCapital 3: &quot; match(&quot;3&quot;, /^[A-Z]/));
+#print(&quot;startsWithLower 3: &quot; match(&quot;3&quot;, /^[a-z]/));
+		if (isClass) {
+#print(&quot;isClass == true&quot;);
+			if (additionalClsIndices[clsId &quot;*&quot;] == &quot;&quot;) {
+				additionalClsIndices[clsId &quot;*&quot;] = additionalClsIndices[last_clsId &quot;*&quot;];
+#print(&quot;additionalClsIndices init : &quot; clsId &quot; / &quot;  last_clsId &quot; / &quot; additionalClsIndices[last_clsId &quot;*&quot;]);
+			}
+			if (part_isMultiSize(nameP)) {
+#print(&quot;part_isMultiSize clsId fullName : &quot; clsId &quot; / &quot; fullName);
+				if (ancestorsClass_multiSizes[clsId &quot;*&quot;] == &quot;&quot;) {
+					#ancestorsClass_isMulti[clsId] = 1;
+					ancestorsClass_multiSizes[clsId &quot;*&quot;] = 0;
+					size_parentInd = additionalClsIndices[last_clsId &quot;*&quot;];
+					#size_paramNames = split(innerParams, paramNames, &quot;, &quot;);
+					#indName = paramNames[1 + size_parentInd];
+					#additionalClsIndices[clsId &quot;#&quot; size_parentInd] = indName;
+					additionalClsIndices[clsId &quot;#&quot; size_parentInd] = &quot;&quot;;
+					additionalClsIndices[clsId &quot;*&quot;] = size_parentInd + 1;
+#print(&quot;additionalClsIndices ++ : &quot; clsId &quot; / &quot;  last_clsId &quot; / &quot; additionalClsIndices[clsId &quot;*&quot;] &quot; / &quot; indName &quot; / &quot; innerParams);
+				}
+
+				ancestorsClass_multiSizes[clsId &quot;#&quot; ancestorsClass_multiSizes[clsId &quot;*&quot;]] = fullName;
+#print(&quot;part_isMultiSize clsId/i/fullName: &quot; clsId &quot; / &quot; ancestorsClass_multiSizes[clsId &quot;*&quot;] &quot; / &quot; fullName);
+				#additionalClsIndices[clsId &quot;*&quot;] = additionalClsIndices[last_clsId &quot;*&quot;] + 1;
+
+				ancestorsClass_multiSizes[clsId &quot;*&quot;]++;
+			} else if (part_isAvailable(nameP)) {
+				ancestorsClass_available[clsId] = fullName;
+			}
+		} else {
+#print(&quot;isClass == false&quot;);
+			# store names of additional parameters
+			size_parentInd = additionalClsIndices[last_clsId &quot;*&quot;];
+#print(&quot;a_additionalClsIndices[last_clsId # (size_parentInd-1)]: &quot; additionalClsIndices[last_clsId &quot;#&quot; (size_parentInd-1)]);
+			if (additionalClsIndices[last_clsId &quot;#&quot; (size_parentInd-1)] == &quot;&quot;) {
+				size_paramNames = split(innerParams, paramNames, &quot;, &quot;);
+				for (pci=0; pci &lt; size_parentInd; pci++) {
+					if (additionalClsIndices[last_clsId &quot;#&quot; pci] == &quot;&quot;) {
+						indName = paramNames[1 + pci];
+#print(&quot;a_indName: &quot; indName);
+						additionalClsIndices[last_clsId &quot;#&quot; pci] = indName;
+					}
+				}
+			}
+
+			# assign the function to a class
+			#isStatic = part_isStatic(fullName);
+			isStatic = part_isStatic(nameP);
+			if (isStatic) {
+				belongsTo = secondLast_clsName;
+				ancest = last_ancestorsP;
+			} else {
+				belongsTo = last_clsName;
+				ancest = last_ancestorsP;
+			}
+			# store one way ...
+			funcBelongsTo[fullName] = ancest &quot;-&quot; belongsTo;
+
+			# ... and the other
+			sizeI_belongsTo = ancest &quot;-&quot; belongsTo &quot;*&quot;;
+			if (ownerOfFunc[sizeI_belongsTo] == &quot;&quot;) {
+				ownerOfFunc[sizeI_belongsTo] = 0;
+			}
+			ownerOfFunc[ancest &quot;-&quot; belongsTo &quot;#&quot; ownerOfFunc[sizeI_belongsTo]] = fullName;
+	#print(&quot;ancest - belongsTo # ownerOfFunc[sizeI_belongsTo]: &quot; ancest &quot;-&quot; belongsTo &quot;#&quot; ownerOfFunc[sizeI_belongsTo] &quot; / &quot; fullName);
+	#print(&quot;clsName: &quot; clsName);
+	#print(&quot;last_clsName: &quot; last_clsName);
+	#print(&quot;secondLast_clsName: &quot; secondLast_clsName);
+			ownerOfFunc[sizeI_belongsTo]++;
+		}
+	}
+
+	# store interfaces
+	for (clsName in class_ancestors) {
+#print(&quot;clsName: &quot; clsName);
+		size_ancestorParts = split(class_ancestors[clsName], ancestorParts, &quot;,&quot;);
+#print(&quot;size_ancestorParts: &quot; size_ancestorParts);
+#print(&quot;ancestorParts[1]: &quot; ancestorParts[1]);
+
+		# check if an interface is needed
+		if (size_ancestorParts &gt; 1) {
+#print(&quot;interface: &quot; clsName);
+			interfaces[clsName] = 1;
+
+			# assign functions of the first implementation to the interface as reference
+			ancCls = ancestorParts[1] &quot;-&quot; clsName;
+			anc = ancestorParts[1] &quot;_&quot; clsName;
+			size_funcs = ownerOfFunc[ancCls &quot;*&quot;];
+			interfaceOwnerOfFunc[clsName &quot;*&quot;] = 0;
+			for (f=0; f &lt; size_funcs; f++) {
+				fullName = ownerOfFunc[ancCls &quot;#&quot; f];
+				interfaceOwnerOfFunc[clsName &quot;#&quot; interfaceOwnerOfFunc[clsName &quot;*&quot;]] = fullName;
+				interfaceOwnerOfFunc[clsName &quot;*&quot;]++;
+				
+				funcBelongsToInterface[fullName] = clsName;
+			}
+			# assign member classes of the first implementation to the interface as reference
+			interface_class[clsName] = ancestors_class[anc];
+			size_memCls = split(interface_class[clsName], memCls, &quot;,&quot;);
+			for (mc=0; mc &lt; size_memCl; mc++) {
+				ancestorsInterface_multiSizes[clsName &quot;-&quot; memCls[mc+1] &quot;*&quot;] = ancestorsClass_multiSizes[anc &quot;-&quot; memCls[mc+1] &quot;*&quot;];
+			}
+			additionalIntIndices[clsName &quot;*&quot;] = additionalClsIndices[ancCls &quot;*&quot;];
+
+			# generate class names for the implementations of the interface
+			for (a=0; a &lt; size_ancestorParts; a++) {
+				implClsName = ancestorParts[a+1];
+				implClsName = extractNormalPart(implClsName);
+				#sub(/^_$/, &quot;ROOT&quot;, implClsName);
+				gsub(/_/, &quot;&quot;, implClsName);
+				implClsName = implClsName clsName &quot;Impl&quot;;
+#print(&quot;implClsName: &quot; implClsName);
+
+				implClsNames[ancestorParts[a+1] &quot;-&quot; clsName] = implClsName;
+			}
+		}
+	}
+}
+
+
+
+
+
+function printInterfaces() {
+
+	for (clsName in class_ancestors) {
+		#size_ancestorParts = split(class_ancestors[clsName], ancestorParts, &quot;,&quot;);
+
+		# check if an interface is needed
+		if (clsName in interfaces) {
+#print(&quot;printInterfaces&quot;);
+			printInterface(clsName);
+		}
+	}
+}
+function printInterface(clsName_i) {
+
+	outFile_i = createJavaFileName(clsName_i);
+	printHeader(outFile_i, myPkgA, clsName_i, 1);
+
+	size_addInds = additionalIntIndices[clsName_i &quot;*&quot;];
+
+	# print member functions
+	size_funcs = interfaceOwnerOfFunc[clsName_i &quot;*&quot;];
+#print(size_funcs);
+	for (f=0; f &lt; size_funcs; f++) {
+		fullName_i = interfaceOwnerOfFunc[clsName &quot;#&quot; f];
+		printMember(outFile_i, fullName_i, size_addInds, 1);
+	}
+
+	# print member class fetchers (single, multi, multi-fetch-single)
+	size_memCls = split(interface_class[clsName], memCls, &quot;,&quot;);
+#print(&quot;printInterface size_memCls: &quot; size_memCls);
+	for (mc=0; mc &lt; size_memCls; mc++) {
+		memberClass = memCls[mc+1];
+		fullNameMultiSize_i = ancestorsInterface_isMulti[clsName &quot;-&quot; memberClass];TODO
+		if (fullNameMultiSize_i != &quot;&quot;) {
+			if (match(fullNameMultiSize_i, /^.*0MULTI1[^0]*3/)) { # wants a different function name then the default one
+				fn = fullNameMultiSize_i;
+				sub(/^.*0MULTI1[^3]*3/, &quot;&quot;, fn); # remove pre MULTI 3
+				sub(/[0-9].*$/, &quot;&quot;, fn); # remove post MULTI 3
+			} else {
+				fn = &quot;get&quot; memberClass &quot;s&quot;;
+			}
+			params = funcParams[fullNameMultiSize_i];
+		} else {
+			fn = &quot;get&quot; memberClass;
+			params = &quot;&quot;;
+		}
+		# remove additional indices from params
+		for (ai=0; ai &lt; size_addInds; ai++) {
+			sub(/int [_a-zA-Z0-9]+(, )?/, &quot;&quot;, params);
+		}
+		print(&quot;\t&quot; memberClass &quot; &quot; fn &quot;(&quot; params &quot;);&quot;) &gt;&gt; outFile_i;
+	}
+
+	print(&quot;}&quot;) &gt;&gt; outFile_i;
+	print(&quot;&quot;) &gt;&gt; outFile_i;
+
+}
+
+
+
+
+
+
+
+function printClasses() {
+
+	for (clsName in class_ancestors) {
+		size_ancestorParts = split(class_ancestors[clsName], ancestorParts, &quot;,&quot;);
+
+		# check if an interface is used/available
+		#hasInterface = 0;
+		#if (clsName in interfaces) {
+		#	hasInterface = 1;
+		#}
+#if (match(clsName, /Clb/)) {
+#print(&quot;clsName: &quot; clsName);
+#print(&quot;size_ancestorParts: &quot; size_ancestorParts);
+#print(&quot;class_ancestors[clsName]: &quot; class_ancestors[clsName]);
+#}
+		if (size_ancestorParts == 0) {
+			printClass(&quot;&quot;, clsName);
+		}
+
+		for (a=0; a &lt; size_ancestorParts; a++) {
+			printClass(ancestorParts[a+1], clsName);
+		}
+	}
+}
+function printClass(ancestors_c, clsName_c) {
+
+	clsNameExternal_c = clsName_c;
+	isClbRootCls = 0;
+	myWrapper = myClassVar &quot;.getInnerCallback()&quot;;
+	myTeamId = myClassVar &quot;.getTeamId()&quot;;
+	myClassVarLocal = myClassVar;
+	if (match(clsName_c, /^Clb$/)) {
+		clsNameExternal_c = myClass;
+		isClbRootCls = 1;
+		myWrapper = myWrapVar;
+		myTeamId = &quot;teamId&quot;;
+		myClassVarLocal = &quot;this&quot;;
+	}
+
+	clsId_c = ancestors_c &quot;-&quot; clsName_c;
+	clsFull_c = ancestors_c &quot;_&quot; clsName_c;
+	hasInterface = (interfaces[clsName] == 1);
+	intName_c = 0;
+	if (hasInterface) {
+		intName_c = clsName_c;
+		clsName_c = implClsNames[clsId_c];
+		clsNameExternal_c = clsName_c;
+	}
+
+	outFile_c = createJavaFileName(clsNameExternal_c);
+	printHeader(outFile_c, myPkgA, clsNameExternal_c, intName_c);
+
+	size_addInds = additionalClsIndices[clsId_c &quot;*&quot;];
+
+
+	# print private vars
+	if (isClbRootCls) {
+		print(&quot;\t&quot; &quot;private &quot; myWrapClass &quot; &quot; myWrapVar &quot; = null;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;private int teamId = -1;&quot;) &gt;&gt; outFile_c;
+	} else {
+		print(&quot;\t&quot; &quot;private &quot; myClass &quot; &quot; myClassVar &quot; = null;&quot;) &gt;&gt; outFile_c;
+	}
+	# print additionalVars
+	for (ai=0; ai &lt; size_addInds; ai++) {
+		print(&quot;\t&quot; &quot;private int &quot; additionalClsIndices[clsId_c &quot;#&quot; ai] &quot; = -1;&quot;) &gt;&gt; outFile_c;
+	}
+	print(&quot;&quot;) &gt;&gt; outFile_c;
+
+
+	# print constructor
+	if (isClbRootCls) {
+		ctorParams = myWrapClass &quot; &quot; myWrapVar &quot;, int teamId&quot;;
+	} else {
+		ctorParams = myClass &quot; &quot; myClassVar;
+	}
+	addIndPars_c = &quot;&quot;;
+	for (ai=0; ai &lt; size_addInds; ai++) {
+		addIndPars_c = addIndPars_c &quot;, int &quot; additionalClsIndices[clsId_c &quot;#&quot; ai];
+	}
+	ctorParams = ctorParams addIndPars_c;
+	ctorParamsNoTypes = removeParamTypes(ctorParams);
+	sub(/^, /, &quot;&quot;, addIndPars_c);
+	addIndParsNoTypes_c = removeParamTypes(addIndPars_c);
+	condaddIndPars_c = (addIndPars_c == &quot;&quot;) ? &quot;&quot; : &quot;, &quot;;
+	
+	print(&quot;\t&quot; &quot;private &quot; clsNameExternal_c &quot;(&quot; ctorParams &quot;) {&quot;) &gt;&gt; outFile_c;
+	print(&quot;&quot;) &gt;&gt; outFile_c;
+	if (isClbRootCls) {
+		print(&quot;\t\t&quot; &quot;this.&quot; myWrapVar &quot; = &quot; myWrapVar &quot;;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t\t&quot; &quot;this.teamId = teamId;&quot;) &gt;&gt; outFile_c;
+	} else {
+		print(&quot;\t\t&quot; &quot;this.&quot; myClassVar &quot; = &quot; myClassVar &quot;;&quot;) &gt;&gt; outFile_c;
+	}
+	# init additionalVars
+	for (ai=0; ai &lt; size_addInds; ai++) {
+		addIndName = additionalClsIndices[clsId_c &quot;#&quot; ai];
+		print(&quot;\t\t&quot; &quot;this.&quot; addIndName &quot; = &quot; addIndName &quot;;&quot;) &gt;&gt; outFile_c;
+	}
+	print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+	print(&quot;&quot;) &gt;&gt; outFile_c;
+	for (ai=0; ai &lt; size_addInds; ai++) {
+		addIndName = additionalClsIndices[clsId_c &quot;#&quot; ai];
+		print(&quot;\t&quot; &quot;int get&quot; capitalize(addIndName) &quot;() {&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t\t&quot; &quot;return &quot; addIndName &quot;;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		print(&quot;&quot;) &gt;&gt; outFile_c;
+	}
+
+
+	{
+		# print static fetcher method
+		print(&quot;\t&quot; &quot;static &quot; clsNameExternal_c &quot; getInstance(&quot; ctorParams &quot;) {&quot;) &gt;&gt; outFile_c;
+		print(&quot;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t\t&quot; clsNameExternal_c &quot; _ret = null;&quot;) &gt;&gt; outFile_c;
+		fullNameAvailable_c = ancestorsClass_available[clsId_c];
+		if (fullNameAvailable_c == &quot;&quot;) {
+			print(&quot;\t\t&quot; &quot;_ret = new &quot; clsNameExternal_c &quot;(&quot; ctorParamsNoTypes &quot;);&quot;) &gt;&gt; outFile_c;
+		} else {
+			print(&quot;\t\t&quot; &quot;boolean isAvailable = &quot; myClassVar &quot;.getInnerCallback().&quot; fullNameAvailable_c &quot;(&quot; myClassVar &quot;.getTeamId()&quot; condaddIndPars_c addIndParsNoTypes_c &quot;);&quot;) &gt;&gt; outFile_c;
+			print(&quot;\t\t&quot; &quot;if (isAvailable) {&quot;) &gt;&gt; outFile_c;
+			print(&quot;\t\t\t&quot; &quot;_ret = new &quot; clsNameExternal_c &quot;(&quot; ctorParamsNoTypes &quot;);&quot;) &gt;&gt; outFile_c;
+			print(&quot;\t\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		}
+		print(&quot;\t\t&quot; &quot;return _ret;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		print(&quot;&quot;) &gt;&gt; outFile_c;
+	}
+
+	if (isClbRootCls) {
+		# print inner-callback fetcher method
+		print(&quot;\t&quot; myWrapClass &quot; getInnerCallback() {&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t\t&quot; &quot;return this.&quot; myWrapVar &quot;;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		print(&quot;&quot;) &gt;&gt; outFile_c;
+		# print teamId fetcher method
+		print(&quot;\t&quot; &quot;public int getTeamId() {&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t\t&quot; &quot;return this.teamId;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		print(&quot;&quot;) &gt;&gt; outFile_c;
+	}
+
+
+	# print member functions
+	size_funcs = ownerOfFunc[clsId_c &quot;*&quot;];
+#print(&quot;&quot;);
+#print(clsId_c);
+#print(size_funcs);
+	for (f=0; f &lt; size_funcs; f++) {
+		fullName_c = ownerOfFunc[clsId_c &quot;#&quot; f];
+		printMember(outFile_c, fullName_c, size_addInds, 0);
+	}
+
+
+	# print member class fetchers (single, multi, multi-fetch-single)
+	size_memCls = split(ancestors_class[clsFull_c], memCls, &quot;,&quot;);
+#if (match(clsFull_c, /Clb$/)) { print(&quot;Clb ancestors: &quot; ancestors_class[clsFull_c]); }
+#print(&quot;printClass size_memCls: &quot; clsFull_c &quot; / &quot; size_memCls);
+	for (mc=0; mc &lt; size_memCls; mc++) {
+		memberClass_c = memCls[mc+1];
+#if (match(clsFull_c, /Clb$/)) { print(&quot;cls/mem: &quot; clsFull_c &quot; / &quot; memberClass_c); }
+		printMemberClassFetchers(outFile_c, clsFull_c, clsId_c, memberClass_c, isInterface_c);
+	}
+
+
+	print(&quot;}&quot;) &gt;&gt; outFile_c;
+	print(&quot;&quot;) &gt;&gt; outFile_c;
+}
+
+function printMemberClassFetchers(outFile_mc, clsFull_mc, clsId_mc, memberClsName_mc, isInterface_mc) {
+
+#if (match(clsFull_mc, /Clb$/)) { print(&quot;clsFull_mc: &quot; clsFull_mc); }
+		memberClassId_mc = clsFull_mc &quot;-&quot; memberClsName_mc;
+		size_multi_mc = ancestorsClass_multiSizes[memberClassId_mc &quot;*&quot;];
+		isMulti_mc = (size_multi_mc != &quot;&quot;);
+		if (isMulti_mc) { # multi element fetcher(s)
+			for (mmc=0; mmc &lt; size_multi_mc; mmc++) {
+				fullNameMultiSize_mc = ancestorsClass_multiSizes[memberClassId_mc &quot;#&quot; mmc];
+#print(&quot;multi mem cls: &quot; memberClassId_mc &quot;#&quot; mmc &quot; / &quot; fullNameMultiSize_mc);
+				printMemberClassFetcher(outFile_mc, clsFull_mc, clsId_mc, memberClsName_mc, isInterface_mc, fullNameMultiSize_mc);
+			}
+		} else { # single element fetcher
+			printMemberClassFetcher(outFile_mc, clsFull_mc, clsId_mc, memberClsName_mc, isInterface_mc, 0);
+		}
+}
+# fullNameMultiSize_mf is 0 if it is no multi element
+function printMemberClassFetcher(outFile_mf, clsFull_mf, clsId_mf, memberClsName_mf, isInterface_mf, fullNameMultiSize_mf) {
+
+		memberClassId_mf = clsFull_mf &quot;-&quot; memberClsName_mf;
+		isMulti_mf = fullNameMultiSize_mf != 0;
+		if (interfaces[memberClsName_mf] != &quot;&quot;) {
+			memberClassImpl_mf = implClsNames[memberClassId_mf];
+		} else {
+			memberClassImpl_mf = memberClsName_mf;
+		}
+		if (isMulti_mf) { # multi element fetcher
+			if (match(fullNameMultiSize_mf, /^.*0MULTI1[^0]*3/)) { # wants a different function name then the default one
+				fn = fullNameMultiSize_mf;
+				sub(/^.*0MULTI1[^3]*3/, &quot;&quot;, fn); # remove pre MULTI 3
+				sub(/[0-9].*$/, &quot;&quot;, fn); # remove post MULTI 3
+			} else {
+				fn = &quot;get&quot; memberClsName_mf &quot;s&quot;;
+			}
+			params = funcParams[fullNameMultiSize_mf];
+			innerParams = funcInnerParams[fullNameMultiSize_mf];
+
+			fullNameMultiVals_mf = fullNameMultiSize_mf;
+			sub(/0MULTI1SIZE/, &quot;0MULTI1VALS&quot;, fullNameMultiVals_mf);
+			hasMultiVals_mf = (funcRetType[fullNameMultiVals_mf] != &quot;&quot;);
+		} else { # single element fetcher
+			fn = &quot;get&quot; memberClsName_mf;
+			params = &quot;&quot;;
+		}
+
+		# remove additional indices from params
+		for (ai=0; ai &lt; size_addInds; ai++) {
+			sub(/int [_a-zA-Z0-9]+(, )?/, &quot;&quot;, params);
+		}
+
+		retType = memberClsName_mf;
+		if (isMulti_mf) {
+			retType = &quot;java.util.ArrayList&lt;&quot; retType &quot;&gt;&quot;;
+		}
+		condInnerParamsComma = (innerParams == &quot;&quot;) ? &quot;&quot; : &quot;, &quot;;
+
+		# concatenate additional indices
+		indexParams_mf = &quot;&quot;;
+		for (ai=0; ai &lt; size_addInds; ai++) {
+			addIndName = additionalClsIndices[clsId_mf &quot;#&quot; ai];
+			indexParams_mf = indexParams_mf  &quot;, &quot; addIndName;
+		}
+		sub(/^\, /, &quot;&quot;, indexParams_mf); # remove comma at the end
+		condIndexComma_mf = (indexParams_mf == &quot;&quot;) ? &quot;&quot; : &quot;, &quot;;
+
+		indent_mf = &quot;\t&quot;;
+
+		isBuffered_mf = isBufferedFunc(clsFull_mf &quot;_&quot; memberClsName_mf);
+		if (!isInterface_mf &amp;&amp; isBuffered_mf) {
+			print(indent_mf &quot;private &quot; retType &quot; buffer_&quot; fn &quot;;&quot;) &gt;&gt; outFile_mf;
+			print(indent_mf &quot;private boolean buffer_isInitialized_&quot; fn &quot; = false;&quot;) &gt;&gt; outFile_mf;
+		}
+
+		print(indent_mf &quot;public &quot; retType &quot; &quot; fn &quot;(&quot; params &quot;) {&quot;) &gt;&gt; outFile_mf;
+		print(&quot;&quot;) &gt;&gt; outFile_mf;
+		indent_mf = indent_mf &quot;\t&quot;;
+		if (isBuffered_mf) {
+			print(indent_mf retType &quot; _ret = buffer_&quot; fn &quot;;&quot;) &gt;&gt; outFile_mf;
+			print(indent_mf &quot;if (!buffer_isInitialized_&quot; fn &quot;) {&quot;) &gt;&gt; outFile_mf;
+			indent_mf = indent_mf &quot;\t&quot;;
+		} else {
+			print(indent_mf retType &quot; _ret;&quot;) &gt;&gt; outFile_mf;
+		}
+		if (isMulti_mf) {
+			print(indent_mf &quot;int size = &quot; myWrapper &quot;.&quot; fullNameMultiSize_mf &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;);&quot;) &gt;&gt; outFile_mf;
+			if (hasMultiVals_mf) {
+				print(indent_mf &quot;int[] tmpArr = new int[size];&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf myWrapper &quot;.&quot; fullNameMultiVals_mf &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;, tmpArr, size);&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf retType &quot; arrList = new &quot; retType &quot;(size);&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;for (int i=0; i &lt; size; i++) {&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;\t&quot; &quot;arrList.add(&quot; memberClassImpl_mf &quot;.getInstance(&quot; myClassVarLocal condIndexComma_mf indexParams_mf &quot;, tmpArr[i]));&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;}&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;_ret = arrList;&quot;) &gt;&gt; outFile_mf;
+			} else {
+				print(indent_mf retType &quot; arrList = new &quot; retType &quot;(size);&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;for (int i=0; i &lt; size; i++) {&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;\t&quot; &quot;arrList.add(&quot; memberClassImpl_mf &quot;.getInstance(&quot; myClassVarLocal condIndexComma_mf indexParams_mf &quot;, i));&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;}&quot;) &gt;&gt; outFile_mf;
+				print(indent_mf &quot;_ret = arrList;&quot;) &gt;&gt; outFile_mf;
+			}
+		} else {
+			print(indent_mf &quot;_ret = &quot; memberClassImpl_mf &quot;.getInstance(&quot; myClassVarLocal condIndexComma_mf indexParams_mf &quot;);&quot;) &gt;&gt; outFile_mf;
+		}
+		if (isBuffered_mf) {
+			print(indent_mf &quot;buffer_&quot; fn &quot; = _ret;&quot;) &gt;&gt; outFile_mf;
+			print(indent_mf &quot;buffer_isInitialized_&quot; fn &quot; = true;&quot;) &gt;&gt; outFile_mf;
+			sub(/\t/, &quot;&quot;, indent_mf);
+			print(indent_mf &quot;}&quot;) &gt;&gt; outFile_mf;
+			print(&quot;&quot;) &gt;&gt; outFile_mf;
+		}
+		print(indent_mf &quot;return _ret;&quot;) &gt;&gt; outFile_mf;
+		sub(/\t/, &quot;&quot;, indent_mf);
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_mf;
+}
+
+
+
+
+
+function printMember(outFile_m, fullName_m, additionalIndices_m, isInterface_m) {
+
+	if (part_isMultiValues(fullName_m) || part_isArrayValues(fullName_m) || part_isMapKeys(fullName_m) || part_isMapValues(fullName_m)) {
+		return;
+	}
+
+	indent_m = &quot;\t&quot;;
+	retType = funcRetType[fullName_m];
+	params = funcParams[fullName_m];
+	innerParams = funcInnerParams[fullName_m];
+	memName = extractNormalPart(fullName_m);
+	sub(/^.*_/, &quot;&quot;, memName);
+	isVoid_m = retType == &quot;void&quot;;
+	isBuffered_m = !isVoid_m &amp;&amp; isBufferedFunc(fullName_m);
+
+	if (memName == &quot;handleCommand&quot;) {
+		sub(/int commandTopic\, Pointer commandData/, &quot;AICommand command&quot;, params);
+		sub(/commandTopic\, commandData/, &quot;command.getTopic(), command.getPointer()&quot;, innerParams);
+	}
+
+#print(&quot;fullName_m: &quot; fullName_m);
+#print(&quot;additionalIndices_m: &quot; additionalIndices_m);
+
+	isArraySize = part_isArraySize(fullName_m);
+	if (isArraySize) {
+		fullNameArraySize = fullName_m;
+
+		fullNameArrayVals = fullNameArraySize;
+		sub(/0ARRAY1SIZE0/, &quot;0ARRAY1VALS0&quot;, fullNameArrayVals);
+		params = funcParams[fullNameArrayVals];
+
+		sub(/\, int [_a-zA-Z0-9]+$/, &quot;&quot;, params); # remove max
+		arrayType = params; # getArrayType
+		sub(/^.*\, /, &quot;&quot;, arrayType); # remove pre array type
+		sub(/\[\] .*$/, &quot;&quot;, arrayType); # remove post array type
+		retType = &quot;java.util.ArrayList&lt;&quot; convertJavaBuiltinTypeToClass(arrayType) &quot;&gt;&quot;;
+		sub(/(\, )?[^ ]+ [_a-zA-Z0-9]+$/, &quot;&quot;, params); # remove array
+	}
+
+	isMapSize = part_isMapSize(fullName_m);
+	if (isMapSize) {
+		fullNameMapSize = fullName_m;
+
+		fullNameMapKeys = fullNameMapSize;
+		sub(/0MAP1SIZE/, &quot;0MAP1KEYS&quot;, fullNameMapKeys);
+#print(&quot;fullNameMapKeys: &quot; fullNameMapKeys) &gt;&gt; outFile_m;
+		keyType = funcParams[fullNameMapKeys];
+		sub(/\[\].*$/, &quot;&quot;, keyType); # remove everything after array type
+		sub(/^.* /, &quot;&quot;, keyType); # remove everything before array type
+
+		fullNameMapVals = fullNameMapSize;
+		sub(/0MAP1SIZE/, &quot;0MAP1VALS&quot;, fullNameMapVals);
+		valType = funcParams[fullNameMapVals];
+		sub(/\[\].*$/, &quot;&quot;, valType); # remove everything after array type
+		sub(/^.* /, &quot;&quot;, valType); # remove everything before array type
+
+		sub(/\, int [_a-zA-Z0-9]+$/, &quot;&quot;, params); # remove max
+		retType = &quot;java.util.Map&lt;&quot; convertJavaBuiltinTypeToClass(keyType) &quot;, &quot; convertJavaBuiltinTypeToClass(valType) &quot;&gt;&quot;; # getArrayType
+		#sub(/^.*\, /, &quot;&quot;, retType);
+		#sub(/ .*$/, &quot;&quot;, retType);
+		sub(/\, [^ ]+ [_a-zA-Z0-9]+$/, &quot;&quot;, params); # remove array
+	}
+
+	isSingleFetch = part_isSingleFetch(fullName_m);
+	if (isSingleFetch) {
+		fetchClass_m = fullName_m;
+		sub(/0[^0]*$/, &quot;&quot;, fetchClass_m); # remove everything after array type
+		sub(/.*0SINGLE1FETCH[^2]*2/, &quot;&quot;, fetchClass_m); # remove everything before array type
+		innerRetType = retType;
+		retType = fetchClass_m;
+
+		indName_m = additionalClsIndices[clsId_c &quot;#&quot; (additionalClsIndices[clsId_c &quot;*&quot;]-1)];
+		#instanceInnerParams = innerParams;
+		#sub(&quot;(, )?&quot; indName_m, &quot;&quot;, instanceInnerParams); # remove index parameter
+		instanceInnerParams = &quot;&quot;;
+	}
+
+	refObjsFullName_m = fullName_m;
+	hasReferenceObject_m = part_hasReferenceObject(refObjsFullName_m);
+#print(&quot;hasRef: &quot; hasReferenceObject_m &quot; / &quot; fullName_m);
+	while (hasReferenceObject_m) {
+#0REF1Resource2resourceId0
+		refObj_m = refObjsFullName_m;
+		sub(/^.*0REF/, &quot;&quot;, refObj_m); # remove everything before ref type
+		sub(/0.*$/, &quot;&quot;, refObj_m); # remove everything after ref type
+
+		refCls_m = refObj_m;
+		sub(/^[^1]*1/, &quot;&quot;, refCls_m); # remove everything before ref cls
+		sub(/[123].*$/, &quot;&quot;, refCls_m); # remove everything after ref cls
+
+		refParamName_m = refObj_m;
+		sub(/^[^2]*2/, &quot;&quot;, refParamName_m); # remove everything before ref param name
+		sub(/[123].*$/, &quot;&quot;, refParamName_m); # remove everything after ref param name
+#print(&quot;Ref: &quot; refCls_m &quot; / &quot; refParamName_m &quot; / &quot; refObj_m &quot; / &quot; fullName_m);
+
+		#refParamNameClass_m[refParamName_m] = refCls_m; # eg: refParamNameClass_m[&quot;resourceId&quot;] = &quot;Resource&quot;
+		sub(&quot;int &quot; refParamName_m, refCls_m &quot; c_&quot; refParamName_m, params); # remove everything before ref param name
+		sub(refParamName_m, &quot;c_&quot; refParamName_m &quot;.get&quot; capitalize(refParamName_m) &quot;()&quot;, innerParams); # remove everything before ref param name
+
+		sub(&quot;0REF&quot; refObj_m, &quot;&quot;, refObjsFullName_m); # remove everything after array type
+		hasReferenceObject_m = part_hasReferenceObject(refObjsFullName_m);
+	}
+
+	# remove additional indices from params
+	for (ai=0; ai &lt; additionalIndices_m; ai++) {
+		sub(/int [_a-zA-Z0-9]+(, )?/, &quot;&quot;, params);
+	}
+
+	firstLineEnd = &quot;;&quot;;
+	mod_m = &quot;&quot;;
+	if (!isInterface_m) {
+		firstLineEnd = &quot; {&quot;;
+		mod_m = &quot;public &quot;;
+	}
+
+	if (!isInterface_m &amp;&amp; isBuffered_m) {
+		print(indent_m retType &quot; buffer_&quot; memName &quot;;&quot;) &gt;&gt; outFile_m;
+		print(indent_m &quot;boolean buffer_isInitialized_&quot; memName &quot; = false;&quot;) &gt;&gt; outFile_m;
+	}
+
+	print(indent_m mod_m retType &quot; &quot; memName &quot;(&quot; params &quot;)&quot; firstLineEnd) &gt;&gt; outFile_m;
+	if (!isInterface_m) {
+		condRet = isVoid_m ? &quot;&quot; : &quot;_ret = &quot;;
+		condInnerParamsComma = (innerParams == &quot;&quot;) ? &quot;&quot; : &quot;, &quot;;
+		indent_m = indent_m &quot;\t&quot;;
+		if (memName == &quot;handleCommand&quot;) {
+			print(indent_m &quot;command.write();&quot;) &gt;&gt; outFile_m;
+		}
+		if (isBuffered_m) {
+			print(indent_m retType &quot; _ret = buffer_&quot; memName &quot;;&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;if (!buffer_isInitialized_&quot; memName &quot;) {&quot;) &gt;&gt; outFile_m;
+			indent_m = indent_m &quot;\t&quot;;
+		} else {
+			print(indent_m retType &quot; _ret;&quot;) &gt;&gt; outFile_m;
+		}
+		if (isArraySize) {
+			print(&quot;&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;int size = &quot; myWrapper &quot;.&quot; fullNameArraySize &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;);&quot;) &gt;&gt; outFile_m;
+			print(indent_m arrayType &quot;[] tmpArr = new &quot; arrayType &quot;[size];&quot;) &gt;&gt; outFile_m;
+			print(indent_m myWrapper &quot;.&quot; fullNameArrayVals &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;, tmpArr, size);&quot;) &gt;&gt; outFile_m;
+			print(indent_m retType &quot; arrList = new &quot; retType &quot;(size);&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;for (int i=0; i &lt; size; i++) {&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;\t&quot; &quot;arrList.add(tmpArr[i]);&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;}&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;_ret = arrList;&quot;) &gt;&gt; outFile_m;
+		} else if (isMapSize) {
+			print(&quot;&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;int size = &quot; myWrapper &quot;.&quot; fullNameMapSize &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;);&quot;) &gt;&gt; outFile_m;
+			print(indent_m keyType &quot;[] tmpKeysArr = new &quot; keyType &quot;[size];&quot;) &gt;&gt; outFile_m;
+			print(indent_m myWrapper &quot;.&quot; fullNameMapKeys &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;, tmpKeysArr);&quot;) &gt;&gt; outFile_m;
+			print(indent_m valType &quot;[] tmpValsArr = new &quot; valType &quot;[size];&quot;) &gt;&gt; outFile_m;
+			print(indent_m myWrapper &quot;.&quot; fullNameMapVals &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;, tmpValsArr);&quot;) &gt;&gt; outFile_m;
+			retMapImplType = retType;
+			sub(/Map/, defMapJavaImpl, retMapImplType);
+			print(indent_m retType &quot; retMap = new &quot; retMapImplType &quot;(size);&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;for (int i=0; i &lt; size; i++) {&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;\t&quot; &quot;retMap.put(tmpKeysArr[i], tmpValsArr[i]);&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;}&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;_ret = retMap;&quot;) &gt;&gt; outFile_m;
+		} else if (isSingleFetch) {
+			condInstanceInnerParamsComma = (instanceInnerParams == &quot;&quot;) ? &quot;&quot; : &quot;, &quot;;
+			print(&quot;&quot;) &gt;&gt; outFile_m;
+			print(indent_m innerRetType &quot; innerRet = &quot; myWrapper &quot;.&quot; fullName_m &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;);&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;_ret = &quot; retType &quot;.getInstance(&quot; myClassVarLocal &quot;, innerRet&quot; condInstanceInnerParamsComma instanceInnerParams &quot;);&quot;) &gt;&gt; outFile_m;
+		} else {
+			print(indent_m condRet myWrapper &quot;.&quot; fullName_m &quot;(&quot; myTeamId condInnerParamsComma innerParams &quot;);&quot;) &gt;&gt; outFile_m;
+		}
+		if (isBuffered_m) {
+			print(indent_m &quot;buffer_&quot; memName &quot; = _ret;&quot;) &gt;&gt; outFile_m;
+			print(indent_m &quot;buffer_isInitialized_&quot; memName &quot; = true;&quot;) &gt;&gt; outFile_m;
+			sub(/\t/, &quot;&quot;, indent_m);
+			print(indent_m &quot;}&quot;) &gt;&gt; outFile_m;
+			print(&quot;&quot;) &gt;&gt; outFile_m;
+		}
+		if (!isVoid_m) {
+			print(indent_m &quot;return _ret;&quot;) &gt;&gt; outFile_m;
+		}
+		sub(/\t/, &quot;&quot;, indent_m);
+		print(indent_m &quot;}&quot;) &gt;&gt; outFile_m;
+	}
+}
+
+
+
+
+
+
+# grab callback functions
+#/^\t[^ ]+ Clb_[^ ]+\(int teamId.*\)\;$/ {
+/Clb_/ {
+
+	fullName = $1;
+	sub(/.* /, &quot;&quot;, fullName);
+
+	simpleFullName = extractNormalPart(fullName);
+
+	retType = trim($1);
+	sub(fullName, &quot;&quot;, retType);
+
+	params = $2;
+
+	doWrapp = !match(simpleFullName, /^Clb_File/);
+
+	if (doWrapp) {
+		#size_tmpParts = split($0, tmpParts, / invoke\(/);
+
+		#retType = trim(tmpParts[1]);
+
+		#params = trim(tmpParts[2]);
+		#sub(/\)\;/, &quot;&quot;, params);
+		sub(/^int teamId(\, )?/, &quot;&quot;, params);
+
+		innerParams = removeParamTypes(params);
+
+		funcFullName[size_funcs] = fullName;
+		funcRetType[fullName] = retType;
+		funcParams[fullName] = params;
+		funcInnerParams[fullName] = innerParams;
+
+		if (!(simpleFullName in funcSimpleFullName)) {
+			funcSimpleFullName[simpleFullName] = fullName;
+		} else if (!match(funcSimpleFullName[simpleFullName], fullName)) {
+			funcSimpleFullName[simpleFullName] = funcSimpleFullName[simpleFullName] &quot;,&quot; fullName;
+		}
+
+		size_funcs++;
+	}
+}
+
+
+END {
+	# finalize things
+	storeClassesAndInterfaces();
+
+#for (abc in funcFullName) {
+#print(&quot;funcFullName[i]: &quot; abc &quot; / &quot; funcFullName[abc]);
+#print(&quot;funcRetType[i]: &quot; abc &quot; / &quot; funcRetType[funcFullName[abc]]);
+#print(&quot;funcParams[i]: &quot; abc &quot; / &quot; funcParams[funcFullName[abc]]);
+#}
+#for (abc in ownerOfFunc) {
+#print(&quot;ownerOfFunc: &quot; abc &quot; / &quot; ownerOfFunc[abc]);
+#}
+#print(&quot;&quot;);
+#print(&quot;###############################################&quot;);
+#print(&quot;&quot;);
+#for (abc in interfaceOwnerOfFunc) {
+#print(&quot;interfaceOwnerOfFunc: &quot; abc &quot; / &quot; interfaceOwnerOfFunc[abc]);
+#}
+
+	printInterfaces();
+	printClasses();
+}

Added: branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCallback.awk
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCallback.awk	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCallback.awk	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,303 @@
+#!/bin/awk
+#
+# This awk script creates a Java class with JNA functions
+# to call to C function pointers in:
+# rts/ExternalAI/Interface/SAICallback.h
+#
+
+BEGIN {
+	# initialize things
+
+	# define the field splitter(-regex)
+	#FS=/,|\(|\)\;/
+	FS=&quot;(,)|(\\()|(\\)\\;)&quot;
+
+	javaSrcRoot = &quot;../java/src&quot;;
+
+	myPkgA = &quot;com.clan_sy.spring.ai&quot;;
+	myPkgD = convertJavaNameFormAToD(myPkgA);
+	myInterface = &quot;AICallback&quot;;
+	myDefaultClass = &quot;DefaultAICallback&quot;;
+	myWin32Class = &quot;Win32AICallback&quot;;
+
+	# Print a warning header
+	#printHeader(myPkgA, myClass);
+	#printLoadNativeFunc(myWrapClass, myWrapVar)
+
+	fi = 0;
+}
+
+
+
+function printGeneratedWarningHeader(outFile) {
+
+	print(&quot;// WARNING: This file is machine generated,&quot;) &gt; outFile;
+	print(&quot;// please do not edit directly!&quot;) &gt;&gt; outFile;
+}
+
+function printGPLHeader(outFile) {
+
+	print(&quot;/*&quot;) &gt;&gt; outFile;
+	print(&quot;	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is free software; you can redistribute it and/or modify&quot;) &gt;&gt; outFile;
+	print(&quot;	it under the terms of the GNU General Public License as published by&quot;) &gt;&gt; outFile;
+	print(&quot;	the Free Software Foundation; either version 2 of the License, or&quot;) &gt;&gt; outFile;
+	print(&quot;	(at your option) any later version.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is distributed in the hope that it will be useful,&quot;) &gt;&gt; outFile;
+	print(&quot;	but WITHOUT ANY WARRANTY; without even the implied warranty of&quot;) &gt;&gt; outFile;
+	print(&quot;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&quot;) &gt;&gt; outFile;
+	print(&quot;	GNU General Public License for more details.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	You should have received a copy of the GNU General Public License&quot;) &gt;&gt; outFile;
+	print(&quot;	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.&quot;) &gt;&gt; outFile;
+	print(&quot;*/&quot;) &gt;&gt; outFile;
+}
+
+
+function printCommentsHeader(outFile) {
+
+	printGeneratedWarningHeader(outFile);
+	print(&quot;&quot;) &gt;&gt; outFile;
+	printGPLHeader(outFile);
+}
+
+function printHeader(outFile_h, javaPkg_h, javaClassName_h) {
+
+	printCommentsHeader(outFile_h);
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;package &quot; javaPkg_h &quot;;&quot;) &gt;&gt; outFile_h;
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;import com.sun.jna.*;&quot;) &gt;&gt; outFile_h;
+	if (javaClassName_h == myWin32Class) {
+		print(&quot;import com.sun.jna.win32.StdCallLibrary;&quot;) &gt;&gt; outFile_h;
+	}
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+	print(&quot;/**&quot;) &gt;&gt; outFile_h;
+	print(&quot; * Lets Java Skirmish AIs call back to the Spring engine.&quot;) &gt;&gt; outFile_h;
+	print(&quot; * We are using JNA, so we do not need native code for Java -&gt; C wrapping.&quot;) &gt;&gt; outFile_h;
+	print(&quot; * We still need native code for C -&gt; Java wrapping though.&quot;) &gt;&gt; outFile_h;
+	print(&quot; *&quot;) &gt;&gt; outFile_h;
+	print(&quot; * @author	AWK wrapper script&quot;) &gt;&gt; outFile_h;
+	print(&quot; * @version	GENERATED&quot;) &gt;&gt; outFile_h;
+	print(&quot; */&quot;) &gt;&gt; outFile_h;
+	if (javaClassName_h == myInterface) {
+		print(&quot;public interface &quot; javaClassName_h &quot; {&quot;) &gt;&gt; outFile_h;
+	} else {
+		print(&quot;public class &quot; javaClassName_h &quot; extends Structure implements Structure.ByReference, &quot; myInterface &quot; {&quot;) &gt;&gt; outFile_h;
+	}
+	print(&quot;&quot;) &gt;&gt; outFile_h;
+}
+
+
+# Some utility functions
+
+function ltrim(s) { sub(/^[ \t]+/, &quot;&quot;, s); return s; }
+function rtrim(s) { sub(/[ \t]+$/, &quot;&quot;, s); return s; }
+function trim(s)  { return rtrim(ltrim(s)); }
+
+function noSpaces(s)  { gsub(/[ \t]/, &quot;&quot;, s); return s; }
+
+function capitalize(s)  { return toupper(substr(s, 1, 1)) substr(s, 2); }
+function lowerize(s)  { return tolower(substr(s, 1, 1)) substr(s, 2); }
+
+function startsWithCapital(s)  { return match(s, /^[A-Z]/); }
+function startsWithLower(s)  { return match(s, /^[a-z]/); }
+
+
+# Awaits this format:	com.clan_sy.spring.ai
+# Returns this format:	com/clan_sy/spring/ai
+function convertJavaNameFormAToD(javaNameFormA) {
+
+	javaNameFormD = javaNameFormA;
+
+	gsub(/\./, &quot;/&quot;, javaNameFormD);
+
+	return javaNameFormD;
+}
+
+function removeParamTypes(params) {
+
+	innerParams = params;
+
+	sub(/^[^ ]* /, &quot;&quot;, innerParams);
+	gsub(/, [^ ]*/, &quot;,&quot;, innerParams);
+
+	return innerParams;
+}
+
+# Awaits this format:	const char*[]
+# Returns this format:	String[]
+function convertCToJNAType(cType) {
+
+	jnaType = trim(cType);
+
+	sub(/const/, &quot;&quot;, jnaType);
+	sub(/unsigned/, &quot;&quot;, jnaType);
+	gsub(/ \*/, &quot;* &quot;, jnaType);
+
+	isComplex = 0;
+	isComplex += sub(/char\*\*/, &quot;Pointer&quot;, jnaType);
+	isComplex += sub(/char\*/, &quot;String&quot;, jnaType);
+	isComplex += sub(/struct SAIFloat3(\*)?/, &quot;AIFloat3&quot;, jnaType);
+	isComplex += sub(/struct SAICallback(\*)?/, &quot;AICallback&quot;, jnaType);
+	isComplex += sub(/struct [0-9a-zA-Z_]*/, &quot;Structure&quot;, jnaType);
+
+	isPrimitive = 0;
+	isPrimitive += sub(/bool/, &quot;boolean&quot;, jnaType);
+	isPrimitive += sub(/char/, &quot;byte&quot;, jnaType);
+	#isPrimitive += sub(/wchar_t/, &quot;char&quot;, jnaType);
+	isPrimitive += sub(/short/, &quot;short&quot;, jnaType);
+	isPrimitive += sub(/int/, &quot;int&quot;, jnaType);
+	isPrimitive += sub(/float/, &quot;float&quot;, jnaType);
+	isPrimitive += sub(/double/, &quot;double&quot;, jnaType);
+
+	isPointer = 0;
+	if (isComplex &lt;= 0 &amp;&amp; isPrimitive &lt;= 0) {
+		isPointer += sub(/.*\*/, &quot;Pointer&quot;, jnaType);
+	}
+
+	# convert possible array length specifiers (&quot;[]&quot; or &quot;[2]&quot;)
+	gsub(/\*/, &quot;[]&quot;, jnaType);
+	arrDims = gsub(/\[[^\]]*\]/, &quot;[]&quot;, jnaType);
+
+	jnaType = noSpaces(jnaType);
+
+	return jnaType;
+}
+
+function createJavaFileName(clsName_f) {
+	return javaSrcRoot &quot;/&quot; myPkgD &quot;/&quot; clsName_f &quot;.java&quot;;
+}
+
+# Awaits this format:	unsinged const char* paramName[]
+# Returns this format:	paramName
+function extractName(typeAndName) {
+
+	name = trim(typeAndName);
+
+	# Remove possible array length specifiers (&quot;[]&quot; or &quot;[2]&quot;)
+	gsub(/\[.*\]/, &quot;&quot;, name);
+
+	# Remove all type specific parts before the name
+	gsub(/.*[ \t]/, &quot;&quot;, name);
+
+	return name;
+}
+
+# Awaits this format:	unsinged const char* paramName[]
+# Returns this format:	unsinged const char**
+function extractType(typeAndName) {
+
+	name = extractName(typeAndName);
+	type = typeAndName;
+	sub(name, &quot;&quot;, type);
+	type = trim(type);
+
+	return type;
+}
+
+
+
+function printInterface() {
+
+	outFile_i = createJavaFileName(myInterface);
+
+	printHeader(outFile_i, myPkgA, myInterface);
+
+	for (i=0; i &lt; fi; i++) {
+		fullName = funcFullName[i];
+		retType = funcRetType[i];
+		paramList = funcParamList[i];
+
+		print(&quot;\t&quot; retType &quot; &quot; fullName &quot;(&quot; paramList &quot;);&quot;) &gt;&gt; outFile_i;
+	}
+
+	print(&quot;}&quot;) &gt;&gt; outFile_i;
+	print(&quot;&quot;) &gt;&gt; outFile_i;
+}
+
+function printClass(clsName_c) {
+
+	outFile_c = createJavaFileName(clsName_c);
+
+	printHeader(outFile_c, myPkgA, clsName_c);
+
+	clbType_c = &quot;Callback&quot;;
+	if (clsName_c == myWin32Class) {
+		clbType_c = &quot;StdCallLibrary.StdCallCallback&quot;;
+	}
+
+	for (i=0; i &lt; fi; i++) {
+		fullName = funcFullName[i];
+		retType = funcRetType[i];
+		paramList = funcParamList[i];
+
+		isVoid_c = (retType == &quot;void&quot;);
+		condRet_c = isVoid_c ? &quot;&quot; : &quot;return &quot;;
+		paramListNoTypes = removeParamTypes(paramList);
+
+		print(&quot;\t&quot; &quot;public static interface _&quot; fullName &quot; extends &quot; clbType_c &quot; {&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;\t&quot; retType &quot; invoke(&quot; paramList &quot;);&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;public _&quot; fullName &quot; _M_&quot; fullName &quot;;&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;public &quot; retType &quot; &quot; fullName &quot;(&quot; paramList &quot;) {&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;\t&quot; condRet_c &quot;_M_&quot; fullName &quot;.invoke(&quot; paramListNoTypes &quot;);&quot;) &gt;&gt; outFile_c;
+		print(&quot;\t&quot; &quot;}&quot;) &gt;&gt; outFile_c;
+		print(&quot;&quot;) &gt;&gt; outFile_c;
+	}
+
+	print(&quot;}&quot;) &gt;&gt; outFile_c;
+	print(&quot;&quot;) &gt;&gt; outFile_c;
+}
+
+
+
+# save function pointer info into arrays
+/^[^\/]*CALLING_CONV.*$/ {
+
+	doWrapp = !match(($0), /.*CALLING_CONV \*File_.*/);
+
+	if (doWrapp) {
+		retType_c = trim($1);
+		retType_jna = convertCToJNAType(retType_c);
+		#condRet = match(retType_c, &quot;void&quot;) ? &quot;&quot; : &quot;return &quot;;
+		fullName=$2;
+		sub(/CALLING_CONV \*/, &quot;&quot;, fullName);
+		sub(/\)/, &quot;&quot;, fullName);
+
+		# function parameters
+		paramList=&quot;&quot;
+	
+		if (($3) &amp;&amp; !match(($3), /.*\/\/.*/)) {
+			name = extractName(($3));
+			type_c = extractType(($3));
+			type_jna = convertCToJNAType(type_c);
+			paramList = paramList type_jna &quot; &quot; name;
+		}
+		for (i=4; i&lt;=NF &amp;&amp; ($i) &amp;&amp; !match(($i), /.*\/\/.*/); i++) {
+			name = extractName(($i));
+			type_c = extractType(($i));
+			type_jna = convertCToJNAType(type_c);
+			paramList = paramList &quot;, &quot; type_jna &quot; &quot; name;
+		}
+
+		funcFullName[fi] = fullName;
+		funcRetType[fi] = retType_jna;
+		funcParamList[fi] = paramList;
+		fi++;
+	}
+}
+
+
+
+
+END {
+	# finalize things
+
+	printInterface();
+	printClass(myDefaultClass);
+	printClass(myWin32Class);
+}

Added: branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCommands.awk
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCommands.awk	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappCommands.awk	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,416 @@
+#!/bin/awk
+#
+# This awk script creates the JNA wrapper classes for the C command structs in:
+# rts/ExternalAI/Interface/AISCommands.h
+#
+
+BEGIN {
+	# initialize things
+
+	# define the field splitter(-regex)
+	FS=&quot;[ \t]+&quot;
+
+	javaSrcRoot = &quot;../java/src&quot;;
+
+	myPkgA = &quot;com.clan_sy.spring.ai&quot;;
+	#myClass = &quot;AICallback&quot;;
+	aiFloat3Class = &quot;AIFloat3&quot;;
+	myPkgD = convertJavaNameFormAToD(myPkgA);
+
+	myPkgCmdA = myPkgA &quot;.command&quot;;
+	myPkgCmdD = convertJavaNameFormAToD(myPkgCmdA);
+
+	myPointerCmdWrapperClass = &quot;AICommandWrapper&quot;;
+	myPointerCmdWrapperFile = javaSrcRoot &quot;/&quot; myPkgD &quot;/&quot; myPointerCmdWrapperClass &quot;.java&quot;;
+
+	# Print a warning header
+	indent = &quot;	&quot;;
+
+	ind_cmdTopics = 0;
+	ind_cmdStructs = 0;
+	insideCmdStruct = 0;
+}
+
+function printGeneratedWarningHeader(outFile) {
+
+	print(&quot;// WARNING: This file is machine generated,&quot;) &gt; outFile;
+	print(&quot;// please do not edit directly!&quot;) &gt;&gt; outFile;
+}
+
+function printGPLHeader(outFile) {
+
+	print(&quot;/*&quot;) &gt;&gt; outFile;
+	print(&quot;	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is free software; you can redistribute it and/or modify&quot;) &gt;&gt; outFile;
+	print(&quot;	it under the terms of the GNU General Public License as published by&quot;) &gt;&gt; outFile;
+	print(&quot;	the Free Software Foundation; either version 2 of the License, or&quot;) &gt;&gt; outFile;
+	print(&quot;	(at your option) any later version.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is distributed in the hope that it will be useful,&quot;) &gt;&gt; outFile;
+	print(&quot;	but WITHOUT ANY WARRANTY; without even the implied warranty of&quot;) &gt;&gt; outFile;
+	print(&quot;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&quot;) &gt;&gt; outFile;
+	print(&quot;	GNU General Public License for more details.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	You should have received a copy of the GNU General Public License&quot;) &gt;&gt; outFile;
+	print(&quot;	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.&quot;) &gt;&gt; outFile;
+	print(&quot;*/&quot;) &gt;&gt; outFile;
+}
+
+
+# Some utility functions
+
+function ltrim(s) { sub(/^[ \t]+/, &quot;&quot;, s); return s; }
+function rtrim(s) { sub(/[ \t]+$/, &quot;&quot;, s); return s; }
+function trim(s)  { return rtrim(ltrim(s)); }
+
+function noSpaces(s)  { gsub(/[ \t]/, &quot;&quot;, s); return s; }
+
+function capFirst(s)  { return toupper(substr(s, 1, 1)) substr(s, 2); }
+
+
+# Awaits this format:	com.clan_sy.spring.ai
+# Returns this format:	com/clan_sy/spring/ai
+function convertJavaNameFormAToD(javaNameFormA) {
+
+	javaNameFormD = javaNameFormA;
+
+	gsub(/\./, &quot;/&quot;, javaNameFormD);
+
+	return javaNameFormD;
+}
+
+
+# Awaits this format:	unsinged const char* varName[]
+# Returns this format:	varName
+function extractParamName(typeAndName) {
+
+	name = trim(typeAndName);
+	gsub(/ \*/, &quot;* &quot;, name);
+
+	# Remove the type
+	sub(/(const )?(unsigned )?(void|int|float|char|byte|bool|struct SAIFloat3)(\*)* /, &quot;&quot;, name);
+
+	# Remove possible array length specifiers (&quot;[]&quot; or &quot;[2]&quot;)
+	gsub(/\[.*\]/, &quot;&quot;, name);
+
+	name = trim(name);
+
+	return name;
+}
+
+
+# Awaits this format:	const char* varName[]
+# Returns this format:	const char* []
+function extractCType(cTypeAndName) {
+
+	cType = trim(cTypeAndName);
+
+	gsub(/ \*/, &quot;* &quot;, cType);
+
+	# Remove the name
+	gsub(&quot; &quot; extractParamName(cTypeAndName), &quot;&quot;, cType);
+
+	gsub(/\[[^\]]*\]/, &quot;*&quot;, cType);
+
+	return cType;
+}
+
+
+# Checks if a field is available and is no comment
+function isFieldUsable(f) {
+	
+	valid = 0;
+
+	if (f &amp;&amp; !match(f, /.*\/\/.*/)) {
+		valid = 1;
+	}
+
+	return valid;
+}
+
+
+function printJavaCommandHeader(javaFile) {
+
+	printGeneratedWarningHeader(javaFile);
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	printGPLHeader(javaFile);
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;package &quot; myPkgCmdA &quot;;&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;import &quot; myPkgA &quot;.*;&quot;) &gt;&gt; javaFile;
+	print(&quot;import com.sun.jna.*;&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+}
+
+
+function printCommandJava(cmdIndex) {
+
+	topicName = cmdsTopicName[cmdIndex];
+	topicValue = cmdsTopicNameValue[topicName];
+	name = cmdsName[cmdIndex];
+	#isUnitCmd = cmdsIsUnitCmd[cmdIndex];
+	isUnitCmd = 0;
+
+	javaFile = javaSrcRoot &quot;/&quot; myPkgCmdD &quot;/&quot; name &quot;AICommand.java&quot;;
+	className = name &quot;AICommand&quot;;
+	cmdInterface = &quot;AICommand&quot;;
+	firstMethod = 0;
+	if (isUnitCmd) {
+		cmdInterface = &quot;UnitAICommand&quot;;
+		firstMethod = 4;
+	}
+
+	#print(&quot;########################################################&quot;);
+	#print(&quot;creating file &quot; javaFile);
+	#print(&quot;### topic name: &quot; topicName);
+	#print(&quot;### topic value: &quot; topicValue);
+	#print(&quot;########################################################&quot;);
+	printJavaCommandHeader(javaFile);
+	print(&quot;public final class &quot; className &quot; extends &quot; cmdInterface &quot; {&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;	public final static int TOPIC = &quot; topicValue &quot;;&quot;) &gt;&gt; javaFile;
+	print(&quot;	public int getTopic() {&quot;) &gt;&gt; javaFile;
+	print(&quot;		return &quot; className &quot;.TOPIC;&quot;) &gt;&gt; javaFile;
+	print(&quot;	}&quot;) &gt;&gt; javaFile;
+
+	# constructors
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;	public &quot; className &quot;() {}&quot;) &gt;&gt; javaFile;
+	print(&quot;	public &quot; className &quot;(Pointer memory) {&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;		useMemory(memory);&quot;) &gt;&gt; javaFile;
+	print(&quot;		read();&quot;) &gt;&gt; javaFile;
+	print(&quot;	}&quot;) &gt;&gt; javaFile;
+
+	if (cmdsNumMembers[cmdIndex] &gt; 0) {
+		typedMemberList = &quot;&quot;;
+		for (m=firstMethod; m &lt; cmdsNumMembers[cmdIndex]; m++) {
+			name = cmdsMembers_name[cmdIndex, m];
+			type_c = cmdsMembers_type_c[cmdIndex, m];
+			type_jna = convertCToJNAType(type_c);
+			typedMemberList = typedMemberList &quot;, &quot; type_jna &quot; &quot; name;
+		}
+		sub(/\, /, &quot;&quot;, typedMemberList);
+		print(&quot;	public &quot; className &quot;(&quot; typedMemberList &quot;) {&quot;) &gt;&gt; javaFile;
+		print(&quot;&quot;) &gt;&gt; javaFile;
+		for (m=firstMethod; m &lt; cmdsNumMembers[cmdIndex]; m++) {
+			name = cmdsMembers_name[cmdIndex, m];
+			print(&quot;		this.&quot; name &quot; = &quot; name &quot;;&quot;) &gt;&gt; javaFile;
+		}
+		print(&quot;	}&quot;) &gt;&gt; javaFile;
+	}
+
+	print(&quot;&quot;) &gt;&gt; javaFile;
+#print(&quot;//name: &quot; name) &gt;&gt; javaFile;
+#print(&quot;//topicName: &quot; topicName) &gt;&gt; javaFile;
+#print(&quot;//evtIndex: &quot; evtIndex) &gt;&gt; javaFile;
+	for (m=firstMethod; m &lt; cmdsNumMembers[cmdIndex]; m++) {
+		name = cmdsMembers_name[cmdIndex, m];
+		type_c = cmdsMembers_type_c[cmdIndex, m];
+		type_jna = convertCToJNAType(type_c);
+		print(&quot;	public &quot; type_jna &quot; &quot; name &quot;;&quot;) &gt;&gt; javaFile;
+	}
+	print(&quot;}&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+}
+
+# Awaits this format:	const char*[]
+# Returns this format:	String[]
+function convertCToJNAType(cType) {
+
+	jnaType = trim(cType);
+
+	sub(/const/, &quot;&quot;, jnaType);
+	sub(/unsigned/, &quot;&quot;, jnaType);
+	gsub(/ \*/, &quot;* &quot;, jnaType);
+
+	isComplex = 0;
+	isComplex += sub(/char\*\*/, &quot;Pointer&quot;, jnaType);
+	isComplex += sub(/char\*/, &quot;String&quot;, jnaType);
+	isComplex += sub(/struct SAIFloat3(\*)?/, &quot;AIFloat3&quot;, jnaType);
+	isComplex += sub(/struct SAICallback(\*)?/, &quot;AICallback&quot;, jnaType);
+	isComplex += sub(/struct [0-9a-zA-Z_]*/, &quot;Structure&quot;, jnaType);
+
+	isPrimitive = 0;
+	isPrimitive += sub(/bool/, &quot;boolean&quot;, jnaType);
+	isPrimitive += sub(/char/, &quot;byte&quot;, jnaType);
+	#isPrimitive += sub(/wchar_t/, &quot;char&quot;, jnaType);
+	isPrimitive += sub(/short/, &quot;short&quot;, jnaType);
+	isPrimitive += sub(/int/, &quot;int&quot;, jnaType);
+	isPrimitive += sub(/float/, &quot;float&quot;, jnaType);
+	isPrimitive += sub(/double/, &quot;double&quot;, jnaType);
+
+	isPointer = 0;
+	if (isComplex &lt;= 0 &amp;&amp; isPrimitive &lt;= 0) {
+		isPointer += sub(/.*\*/, &quot;Pointer&quot;, jnaType);
+	}
+
+	# convert possible array length specifiers (&quot;[]&quot; or &quot;[2]&quot;)
+	gsub(/\*/, &quot;[]&quot;, jnaType);
+	arrDims = gsub(/\[[^\]]*\]/, &quot;[]&quot;, jnaType);
+
+	jnaType = noSpaces(jnaType);
+
+	return jnaType;
+}
+
+function saveMember(ind_mem, member) {
+
+	name = extractParamName(member);
+	type_c = extractCType(member);
+
+	cmdsMembers_name[ind_cmdStructs, ind_mem] = name;
+	cmdsMembers_type_c[ind_cmdStructs, ind_mem] = type_c;
+}
+
+
+function doWrapp(ind_cmdStructs_dw) {
+	return !match(cmdsName[ind_cmdStructs_dw], /.*SharedMemArea.*/);
+}
+
+# aggare te los command defines in order
+/^[ \t]*COMMAND_.*$/ {
+
+	sub(&quot;,&quot;, &quot;&quot;, $4);
+	cmdsTopicNameValue[$2] = $4;
+}
+
+
+# end of struct S*Command 
+/^}; \/\/ COMMAND_.*$/ {
+
+	cmdsNumMembers[ind_cmdStructs] = ind_cmdMember;
+	cmdsTopicName[ind_cmdStructs] = $3;
+
+	if (doWrapp(ind_cmdStructs)) {
+		printCommandJava(ind_cmdStructs);
+	}
+
+	ind_cmdStructs++;
+	insideCmdStruct = 0;
+}
+
+
+# inside of struct S*Command 
+{
+	if (insideCmdStruct == 1) {
+		size_tmpMembers = split($0, tmpMembers, &quot;;&quot;);
+		for (i=1; i&lt;=size_tmpMembers; i++) {
+			tmpMembers[i] = trim(tmpMembers[i]);
+			if (tmpMembers[i] == &quot;&quot; || match(tmpMembers[i], /^\/\//)) {
+				break;
+			}
+			saveMember(ind_cmdMember++, tmpMembers[i]);
+		}
+	}
+}
+
+# beginn of struct S*Command
+/^\struct S.*Command( \{)?/ {
+
+	insideCmdStruct = 1;
+	ind_cmdMember = 0;
+	commandName = $2;
+	sub(/^S/, &quot;&quot;, commandName);
+	sub(/Command$/, &quot;&quot;, commandName);
+	
+	isUnitCommand = match(commandName, /.*Unit$/);
+
+	cmdsIsUnitCmd[ind_cmdStructs] = isUnitCommand;
+	cmdsName[ind_cmdStructs] = commandName;
+}
+
+# find COMMAND_TO_ID_ENGINE id
+/COMMAND_TO_ID_ENGINE/ {
+
+	cmdToIdEngine = $3;
+}
+
+
+
+function printPointerAICommandWrapperHeader(outFile_wh) {
+
+	printGeneratedWarningHeader(outFile_wh);
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	printGPLHeader(outFile_wh);
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;package &quot; myPkgA &quot;;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;import &quot; myPkgCmdA &quot;.*;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;import com.sun.jna.*;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;import java.lang.reflect.Constructor;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;/**&quot;) &gt;&gt; outFile_wh;
+	print(&quot; *&quot;) &gt;&gt; outFile_wh;
+	print(&quot; *&quot;) &gt;&gt; outFile_wh;
+	print(&quot; * @author	hoijui&quot;) &gt;&gt; outFile_wh;
+	print(&quot; * @version	GENERATED&quot;) &gt;&gt; outFile_wh;
+	print(&quot; */&quot;) &gt;&gt; outFile_wh;
+	print(&quot;public final class &quot; myPointerCmdWrapperClass &quot; {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	public static final int COMMAND_TO_ID_ENGINE = &quot; cmdToIdEngine &quot;;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	private static java.util.Map&lt;Integer, Class&lt;? extends AICommand&gt;&gt; topic_cmdClass = new java.util.HashMap&lt;Integer, Class&lt;? extends AICommand&gt;&gt;(&quot; ind_cmdStructs &quot;);&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	private static java.util.Map&lt;Integer, Constructor&lt;? extends AICommand&gt;&gt; topic_cmdCtor = new java.util.HashMap&lt;Integer, Constructor&lt;? extends AICommand&gt;&gt;(&quot; ind_cmdStructs &quot;);&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	static {&quot;) &gt;&gt; outFile_wh;
+}
+function printPointerAICommandWrapperPart(outFile_w, indCmd_w) {
+
+	topicName = cmdsTopicName[indCmd_w];
+	topicValue = cmdsTopicNameValue[topicName];
+	cmdName = cmdsName[indCmd_w];
+
+	print(&quot;		topic_cmdClass.put(&quot; topicValue &quot;, &quot; cmdName &quot;AICommand.class);&quot;) &gt;&gt; outFile_w;
+}
+function printPointerAICommandWrapperEnd(outFile_wh) {
+
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		for (int i=0; i &lt; topic_cmdClass.size(); i++) {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			try {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;				topic_cmdCtor.put(i, topic_cmdClass.get(i).getConstructor(Pointer.class));&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			} catch (Throwable t) {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;				// do nothing&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	public final static AICommand wrapp(int topic, Pointer data) {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		AICommand _ret = null;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		if (topic &lt; 1 || topic &gt;= topic_cmdClass.size()) {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			return _ret;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		try {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			Constructor&lt;? extends AICommand&gt; cmdCtor = topic_cmdCtor.get(topic);&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			_ret = cmdCtor.newInstance(data);&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		} catch (Throwable t) {&quot;) &gt;&gt; outFile_wh;
+	print(&quot;			_ret = null;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;		return _ret;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;	}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+	print(&quot;}&quot;) &gt;&gt; outFile_wh;
+	print(&quot;&quot;) &gt;&gt; outFile_wh;
+}
+
+
+
+END {
+	# finalize things
+
+	# print Pointer to AICommand wrapper helper
+	printPointerAICommandWrapperHeader(myPointerCmdWrapperFile);
+	for (i_f=0; i_f &lt; ind_cmdStructs; i_f++) {
+		if (doWrapp(i_f)) {
+			printPointerAICommandWrapperPart(myPointerCmdWrapperFile, i_f);
+		}
+	}
+	printPointerAICommandWrapperEnd(myPointerCmdWrapperFile);
+}

Added: branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappEvents.awk
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappEvents.awk	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/jna_wrappEvents.awk	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,595 @@
+#!/bin/awk
+#
+# This awk script creates the JNA wrapper classes for the C event structs in:
+# rts/ExternalAI/Interface/AISEvents.h
+#
+
+BEGIN {
+	# initialize things
+
+	# define the field splitter(-regex)
+	FS=&quot;[ \t]+&quot;
+
+	javaSrcRoot = &quot;../java/src&quot;;
+
+	myPkgA = &quot;com.clan_sy.spring.ai&quot;;
+	aiFloat3Class = &quot;AIFloat3&quot;;
+	myPkgD = convertJavaNameFormAToD(myPkgA);
+
+	myPkgEvtA = myPkgA &quot;.event&quot;;
+	myPkgEvtD = convertJavaNameFormAToD(myPkgEvtA);
+
+	myPkgOOA = myPkgA &quot;.oo&quot;;
+	myPkgOOD = convertJavaNameFormAToD(myPkgOOA);
+	myOOAIClass = &quot;OOAI&quot;;
+	myOOAIAbstractClass = &quot;AbstractOOAI&quot;;
+	myOOAIFactoryClass = &quot;OOAIFactory&quot;;
+	myOOAIFile = javaSrcRoot &quot;/&quot; myPkgOOD &quot;/&quot; myOOAIClass &quot;.java&quot;;
+	myOOAIAbstractFile = javaSrcRoot &quot;/&quot; myPkgOOD &quot;/&quot; myOOAIAbstractClass &quot;.java&quot;;
+	myOOAIFactoryFile = javaSrcRoot &quot;/&quot; myPkgOOD &quot;/&quot; myOOAIFactoryClass &quot;.java&quot;;
+
+	printOOAIHeader(myOOAIFile, myOOAIClass);
+	printOOAIHeader(myOOAIAbstractFile, myOOAIAbstractClass);
+	printOOAIFactoryHeader(myOOAIFactoryFile);
+
+	ind_evtTopics = 0;
+	ind_evtStructs = 0;
+	insideEvtStruct = 0;
+}
+
+function printGeneratedWarningHeader(outFile) {
+
+	print(&quot;// WARNING: This file is machine generated,&quot;) &gt; outFile;
+	print(&quot;// please do not edit directly!&quot;) &gt;&gt; outFile;
+}
+
+function printGPLHeader(outFile) {
+
+	print(&quot;/*&quot;) &gt;&gt; outFile;
+	print(&quot;	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is free software; you can redistribute it and/or modify&quot;) &gt;&gt; outFile;
+	print(&quot;	it under the terms of the GNU General Public License as published by&quot;) &gt;&gt; outFile;
+	print(&quot;	the Free Software Foundation; either version 2 of the License, or&quot;) &gt;&gt; outFile;
+	print(&quot;	(at your option) any later version.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	This program is distributed in the hope that it will be useful,&quot;) &gt;&gt; outFile;
+	print(&quot;	but WITHOUT ANY WARRANTY; without even the implied warranty of&quot;) &gt;&gt; outFile;
+	print(&quot;	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&quot;) &gt;&gt; outFile;
+	print(&quot;	GNU General Public License for more details.&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	You should have received a copy of the GNU General Public License&quot;) &gt;&gt; outFile;
+	print(&quot;	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.&quot;) &gt;&gt; outFile;
+	print(&quot;*/&quot;) &gt;&gt; outFile;
+}
+
+
+# Some utility functions
+function ltrim(s) { sub(/^[ \t]+/, &quot;&quot;, s); return s; }
+function rtrim(s) { sub(/[ \t]+$/, &quot;&quot;, s); return s; }
+function trim(s)  { return rtrim(ltrim(s)); }
+
+function noSpaces(s)  { gsub(/[ \t]/, &quot;&quot;, s); return s; }
+
+function capFirst(s)  { return toupper(substr(s, 1, 1)) substr(s, 2); }
+function capitalize(s)  { return toupper(substr(s, 1, 1)) substr(s, 2); }
+function lowerize(s)  { return tolower(substr(s, 1, 1)) substr(s, 2); }
+
+function startsWithCapital(s)  { return match(s, /^[A-Z]/); }
+function startsWithLower(s)  { return match(s, /^[a-z]/); }
+
+
+
+# Awaits this format:	com.clan_sy.spring.ai
+# Returns this format:	com/clan_sy/spring/ai
+function convertJavaNameFormAToD(javaNameFormA) {
+
+	javaNameFormD = javaNameFormA;
+
+	gsub(/\./, &quot;/&quot;, javaNameFormD);
+
+	return javaNameFormD;
+}
+
+
+# Awaits this format:	unsinged const char* varName[]
+# Returns this format:	varName
+function extractParamName(typeAndName) {
+
+	name = trim(typeAndName);
+	gsub(/ \*/, &quot;* &quot;, name);
+
+	# Remove the type
+	sub(/(const )?(unsigned )?(void|int|float|char|byte|bool|struct [_a-zA-Z0-9]+)(\*)* /, &quot;&quot;, name);
+
+	# Remove possible array length specifiers (&quot;[]&quot; or &quot;[2]&quot;)
+	gsub(/\[.*\]/, &quot;&quot;, name);
+
+	name = trim(name);
+
+	return name;
+}
+
+
+# Awaits this format:	const char* varName[]
+# Returns this format:	const char* []
+function extractCType(cTypeAndName) {
+
+	cType = trim(cTypeAndName);
+
+	gsub(/ \*/, &quot;* &quot;, cType);
+
+	# Remove the name
+	gsub(&quot; &quot; extractParamName(cTypeAndName), &quot;&quot;, cType);
+
+	gsub(/\[[^\]]*\]/, &quot;*&quot;, cType);
+
+	return cType;
+}
+
+
+# Checks if a field is available and is no comment
+function isFieldUsable(f) {
+	
+	valid = 0;
+
+	if (f &amp;&amp; !match(f, /.*\/\/.*/)) {
+		valid = 1;
+	}
+
+	return valid;
+}
+
+
+
+function printOOAIHeader(outFile, clsName) {
+
+	printGeneratedWarningHeader(outFile);
+	print(&quot;&quot;) &gt;&gt; outFile;
+	printGPLHeader(outFile);
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;package &quot; myPkgOOA &quot;;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;import java.util.Properties;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.clan_sy.spring.ai.AICommand;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.clan_sy.spring.ai.AIFloat3;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;/**&quot;) &gt;&gt; outFile;
+	print(&quot; *&quot;) &gt;&gt; outFile;
+	print(&quot; *&quot;) &gt;&gt; outFile;
+	print(&quot; * @author	hoijui&quot;) &gt;&gt; outFile;
+	print(&quot; * @version	GENERATED&quot;) &gt;&gt; outFile;
+	print(&quot; */&quot;) &gt;&gt; outFile;
+	if (clsName == myOOAIAbstractClass) {
+		print(&quot;public abstract class &quot; clsName &quot; implements &quot; myOOAIClass &quot; {&quot;) &gt;&gt; outFile;
+	} else {
+		print(&quot;public interface &quot; clsName &quot; {&quot;) &gt;&gt; outFile;
+	}
+	print(&quot;&quot;) &gt;&gt; outFile;
+}
+function printOOAIEnd(outFile) {
+
+	print(&quot;}&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+}
+
+function printOOAIFactoryHeader(outFile) {
+
+	printGeneratedWarningHeader(outFile);
+	print(&quot;&quot;) &gt;&gt; outFile;
+	printGPLHeader(outFile);
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;package &quot; myPkgOOA &quot;;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.clan_sy.spring.ai.AI;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.clan_sy.spring.ai.AICommand;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.clan_sy.spring.ai.AICommandWrapper;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.clan_sy.spring.ai.event.*;&quot;) &gt;&gt; outFile;
+	print(&quot;import com.sun.jna.Pointer;&quot;) &gt;&gt; outFile;
+	print(&quot;import java.util.Map;&quot;) &gt;&gt; outFile;
+	print(&quot;import java.util.HashMap;&quot;) &gt;&gt; outFile;
+	print(&quot;import java.util.Properties;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;/**&quot;) &gt;&gt; outFile;
+	print(&quot; *&quot;) &gt;&gt; outFile;
+	print(&quot; *&quot;) &gt;&gt; outFile;
+	print(&quot; * @author	hoijui&quot;) &gt;&gt; outFile;
+	print(&quot; * @version	GENERATED&quot;) &gt;&gt; outFile;
+	print(&quot; */&quot;) &gt;&gt; outFile;
+	print(&quot;public abstract class OOAIFactory implements AI {&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	private Map&lt;Integer, OOAI&gt; ais = new HashMap&lt;Integer, OOAI&gt;();&quot;) &gt;&gt; outFile;
+	print(&quot;	private Map&lt;Integer, OOAICallback&gt; ooClbs = new HashMap&lt;Integer, OOAICallback&gt;();&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	public final int init(int teamId, Properties info, Properties options) {&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;		OOAI ai = createAI(teamId, info, options);&quot;) &gt;&gt; outFile;
+	print(&quot;		if (ai != null) {&quot;) &gt;&gt; outFile;
+	print(&quot;			ais.put(teamId, ai);&quot;) &gt;&gt; outFile;
+	print(&quot;		}&quot;) &gt;&gt; outFile;
+	print(&quot;		return (ai == null) ? -1 : 0;&quot;) &gt;&gt; outFile;
+	print(&quot;	}&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	public final int release(int teamId) {&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;		OOAI ai = ais.remove(teamId);&quot;) &gt;&gt; outFile;
+	print(&quot;		ooClbs.remove(teamId);&quot;) &gt;&gt; outFile;
+	print(&quot;		return (ai == null) ? -1 : 0;&quot;) &gt;&gt; outFile;
+	print(&quot;	}&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	public final int handleEvent(int teamId, int topic, Pointer event) {&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;		int _ret = -1;&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;		OOAI ai = ais.get(teamId);&quot;) &gt;&gt; outFile;
+	print(&quot;		OOAICallback ooClb = ooClbs.get(teamId);&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;		if (ai != null) {&quot;) &gt;&gt; outFile;
+	print(&quot;			try {&quot;) &gt;&gt; outFile;
+	print(&quot;				switch (topic) {&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+}
+function printOOAIFactoryEnd(outFile) {
+
+	print(&quot;					default:&quot;) &gt;&gt; outFile;
+	print(&quot;						_ret = 1;&quot;) &gt;&gt; outFile;
+	print(&quot;				}&quot;) &gt;&gt; outFile;
+	print(&quot;			} catch (Throwable t) {&quot;) &gt;&gt; outFile;
+	print(&quot;				_ret = 2;&quot;) &gt;&gt; outFile;
+	print(&quot;			}&quot;) &gt;&gt; outFile;
+	print(&quot;		}&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;		return _ret;&quot;) &gt;&gt; outFile;
+	print(&quot;	}&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+	print(&quot;	public abstract OOAI createAI(int teamId, Properties info, Properties options);&quot;) &gt;&gt; outFile;
+	print(&quot;}&quot;) &gt;&gt; outFile;
+	print(&quot;&quot;) &gt;&gt; outFile;
+}
+
+
+function printEventOO(evtIndex) {
+
+	topicName = evtsTopicName[evtIndex];
+	topicValue = evtsTopicNameValue[topicName];
+	eName = evtsName[evtIndex];
+	eNameLowerized = lowerize(eName);
+	eCls = eName &quot;AIEvent&quot;;
+
+	paramsTypes = &quot;&quot;;
+	paramsEvt = &quot;&quot;;
+	for (m=0; m &lt; evtsNumMembers[evtIndex]; m++) {
+		name = evtsMembers_name[evtIndex, m];
+		type_c = evtsMembers_type_c[evtIndex, m];
+		type_jna = convertCToJNAType(type_c);
+		
+		paramsTypes = paramsTypes &quot;, &quot; type_jna &quot; &quot; name;
+		paramsEvt = paramsEvt &quot;, evt.&quot; name;
+	}
+	sub(/^\, /, &quot;&quot;, paramsTypes);
+	sub(/^\, /, &quot;&quot;, paramsEvt);
+
+	sub(/int unit(Id)?/, &quot;Unit unit&quot;, paramsTypes);
+	sub(/int attacker(Id)?/, &quot;Unit attacker&quot;, paramsTypes);
+	sub(/int enemy(Id)?/, &quot;Unit enemy&quot;, paramsTypes);
+	sub(/int weaponDef(Id)?/, &quot;WeaponDef weaponDef&quot;, paramsTypes);
+
+	unitRepls = sub(/evt.unitId/, &quot;Unit.getInstance(ooClb, evt.unitId)&quot;, paramsEvt);
+	if (unitRepls == 0) {
+		sub(/evt.unit/, &quot;Unit.getInstance(ooClb, evt.unit)&quot;, paramsEvt);
+	}
+	sub(/evt.attacker/, &quot;Unit.getInstance(ooClb, evt.attacker)&quot;, paramsEvt);
+	sub(/evt.enemy/, &quot;Unit.getInstance(ooClb, evt.enemy)&quot;, paramsEvt);
+	sub(/evt.weaponDefId/, &quot;WeaponDef.getInstance(ooClb, evt.weaponDefId)&quot;, paramsEvt);
+
+	if (eNameLowerized == &quot;init&quot;) {
+		paramsTypes = &quot;int teamId, OOAICallback callback, Properties info, Properties options&quot;;
+		paramsEvt = &quot;evt.team, ooClb, evt.info, evt.options&quot;;
+	} else if (eNameLowerized == &quot;playerCommand&quot;) {
+		paramsTypes = &quot;java.util.ArrayList&lt;Unit&gt; units, AICommand command, int playerId&quot;;
+		paramsEvt = &quot;units, command, evt.playerId&quot;;
+	}
+
+	print(&quot;	int &quot; eNameLowerized &quot;(&quot; paramsTypes &quot;);&quot;) &gt;&gt; myOOAIFile;
+
+	print(&quot;&quot;) &gt;&gt; myOOAIAbstractFile;
+	print(&quot;	public int &quot; eNameLowerized &quot;(&quot; paramsTypes &quot;) {&quot;) &gt;&gt; myOOAIAbstractFile;
+	print(&quot;		return 0; // signaling: OK&quot;) &gt;&gt; myOOAIAbstractFile;
+	print(&quot;	}&quot;) &gt;&gt; myOOAIAbstractFile;
+
+	print(&quot;\t\t\t\t\t&quot; &quot;case &quot; eCls &quot;.TOPIC:&quot;) &gt;&gt; myOOAIFactoryFile;
+	print(&quot;\t\t\t\t\t\t&quot; &quot;{&quot;) &gt;&gt; myOOAIFactoryFile;
+	print(&quot;\t\t\t\t\t\t\t&quot; eCls &quot; evt = new &quot; eCls &quot;(event);&quot;) &gt;&gt; myOOAIFactoryFile;
+	if (eNameLowerized == &quot;init&quot;) {
+		print(&quot;\t\t\t\t\t\t\t&quot; &quot;ooClb = OOAICallback.getInstance(evt.callback, evt.team);&quot;) &gt;&gt; myOOAIFactoryFile;
+		print(&quot;\t\t\t\t\t\t\t&quot; &quot;ooClbs.put(teamId, ooClb);&quot;) &gt;&gt; myOOAIFactoryFile;
+	} else if (eNameLowerized == &quot;playerCommand&quot;) {
+		print(&quot;\t\t\t\t\t\t\t&quot; &quot;java.util.ArrayList&lt;Unit&gt; units = new java.util.ArrayList&lt;Unit&gt;(evt.numUnitIds);&quot;) &gt;&gt; myOOAIFactoryFile;
+		print(&quot;\t\t\t\t\t\t\t&quot; &quot;for (int i=0; i &lt; evt.numUnitIds; i++) {&quot;) &gt;&gt; myOOAIFactoryFile;
+		print(&quot;\t\t\t\t\t\t\t\t&quot; &quot;units.add(Unit.getInstance(ooClb, evt.unitIds[i]));&quot;) &gt;&gt; myOOAIFactoryFile;
+		print(&quot;\t\t\t\t\t\t\t&quot; &quot;}&quot;) &gt;&gt; myOOAIFactoryFile;
+		print(&quot;\t\t\t\t\t\t\t&quot; &quot;AICommand command = AICommandWrapper.wrapp(evt.commandTopic, evt.commandData);&quot;) &gt;&gt; myOOAIFactoryFile;
+	}
+	print(&quot;\t\t\t\t\t\t\t&quot; &quot;_ret = ai.&quot; eNameLowerized &quot;(&quot; paramsEvt &quot;);&quot;) &gt;&gt; myOOAIFactoryFile;
+	print(&quot;\t\t\t\t\t\t\t&quot; &quot;break;&quot;) &gt;&gt; myOOAIFactoryFile;
+	print(&quot;\t\t\t\t\t\t&quot; &quot;}&quot;) &gt;&gt; myOOAIFactoryFile;
+}
+
+function printEventOOAIFactory(evtIndex) {
+
+	topicName = evtsTopicName[evtIndex];
+	topicValue = evtsTopicNameValue[topicName];
+	eName = evtsName[evtIndex];
+}
+
+
+
+
+function printJavaEventHeader(javaFile) {
+
+	printGeneratedWarningHeader(javaFile);
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	printGPLHeader(javaFile);
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;package &quot; myPkgEvtA &quot;;&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;import &quot; myPkgA &quot;.*;&quot;) &gt;&gt; javaFile;
+	print(&quot;import com.sun.jna.*;&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+}
+
+function printEventJava(evtIndex) {
+
+	topicName = evtsTopicName[evtIndex];
+	topicValue = evtsTopicNameValue[topicName];
+	eName = evtsName[evtIndex];
+
+	className = eName &quot;AIEvent&quot;;
+	javaFile = javaSrcRoot &quot;/&quot; myPkgEvtD &quot;/&quot; className &quot;.java&quot;;
+	evtInterface = &quot;AIEvent&quot;;
+	clsMods = &quot;public final &quot;;
+	printJavaEventHeader(javaFile);
+
+	if (eName == &quot;Init&quot;) {
+		#clsMods = &quot;public abstract &quot;;
+		printEventJavaCls(evtIndex);
+
+		className = &quot;Win32&quot; eName &quot;AIEvent&quot;;
+		javaFile = javaSrcRoot &quot;/&quot; myPkgEvtD &quot;/&quot; className &quot;.java&quot;;
+		#evtInterface = &quot;InitAIEvent&quot;;
+		#clsMods = &quot;public final &quot;;
+		printJavaEventHeader(javaFile);
+		printEventJavaCls(evtIndex);
+
+		className = &quot;Default&quot; eName &quot;AIEvent&quot;;
+		javaFile = javaSrcRoot &quot;/&quot; myPkgEvtD &quot;/&quot; className &quot;.java&quot;;
+		printJavaEventHeader(javaFile);
+		printEventJavaCls(evtIndex);
+	} else {
+		printEventJavaCls(evtIndex);
+	}
+}
+
+function printEventJavaCls(evtIndex) {
+
+	print(clsMods &quot;class &quot; className &quot; extends &quot; evtInterface &quot; {&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	print(&quot;	public final static int TOPIC = &quot; topicValue &quot;;&quot;) &gt;&gt; javaFile;
+	print(&quot;	public int getTopic() {&quot;) &gt;&gt; javaFile;
+	print(&quot;		return &quot; className &quot;.TOPIC;&quot;) &gt;&gt; javaFile;
+	print(&quot;	}&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	if (className == &quot;InitAIEvent&quot;) {
+		print(&quot;	public static boolean isWin32() {&quot;) &gt;&gt; javaFile;
+		print(&quot;&quot;) &gt;&gt; javaFile;
+		print(&quot;		String os = System.getProperty(\&quot;os.name\&quot;, \&quot;UNKNOWN\&quot;);&quot;) &gt;&gt; javaFile;
+		print(&quot;		boolean isWindows = os.matches(\&quot;[Ww]in\&quot;);&quot;) &gt;&gt; javaFile;
+		print(&quot;		String archDataModel = System.getProperty(\&quot;sun.arch.data.model\&quot;, \&quot;32\&quot;);&quot;) &gt;&gt; javaFile;
+		print(&quot;		boolean is32bit = archDataModel.equals(\&quot;32\&quot;);&quot;) &gt;&gt; javaFile;
+		print(&quot;		return isWindows &amp;&amp; is32bit;&quot;) &gt;&gt; javaFile;
+		print(&quot;	}&quot;) &gt;&gt; javaFile;
+		print(&quot;&quot;) &gt;&gt; javaFile;
+	}
+
+	print(&quot;	public &quot; className &quot;(Pointer memory) {&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	if (className == &quot;InitAIEvent&quot;) {
+		print(&quot;		if (isWin32()) {&quot;) &gt;&gt; javaFile;
+		print(&quot;			Win32InitAIEvent initEvtImpl = new Win32InitAIEvent(memory);&quot;) &gt;&gt; javaFile;
+		for (m=0; m &lt; evtsNumMembers[evtIndex]; m++) {
+			name = evtsMembers_name[evtIndex, m];
+			if (!match(name, /(info|options)(Size|Keys|Values)/)) {
+				print(&quot;			this.&quot; name &quot; = initEvtImpl.&quot; name &quot;;&quot;) &gt;&gt; javaFile;
+			}
+		}
+		print(&quot;&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pOptionKeys = initEvtImpl.optionsKeys.getPointerArray(0L, initEvtImpl.optionsSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pOptionValues = initEvtImpl.optionsValues.getPointerArray(0L, initEvtImpl.optionsSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			java.util.Properties tmpOptions = new java.util.Properties();&quot;) &gt;&gt; javaFile;
+		print(&quot;			for (int i=0; i &lt; initEvtImpl.optionsSize; i++) {&quot;) &gt;&gt; javaFile;
+		print(&quot;				tmpOptions.setProperty(pOptionKeys[i].getString(0L), pOptionValues[i].getString(0L));&quot;) &gt;&gt; javaFile;
+		print(&quot;			}&quot;) &gt;&gt; javaFile;
+		print(&quot;			this.options = tmpOptions;&quot;) &gt;&gt; javaFile;
+		print(&quot;&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pInfoKeys = initEvtImpl.infoKeys.getPointerArray(0L, initEvtImpl.infoSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pInfoValues = initEvtImpl.infoValues.getPointerArray(0L, initEvtImpl.infoSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			java.util.Properties tmpInfo = new java.util.Properties();&quot;) &gt;&gt; javaFile;
+		print(&quot;			for (int i=0; i &lt; initEvtImpl.infoSize; i++) {&quot;) &gt;&gt; javaFile;
+		print(&quot;				tmpInfo.setProperty(pInfoKeys[i].getString(0L), pInfoValues[i].getString(0L));&quot;) &gt;&gt; javaFile;
+		print(&quot;			}&quot;) &gt;&gt; javaFile;
+		print(&quot;			this.info = tmpInfo;&quot;) &gt;&gt; javaFile;
+		print(&quot;		} else {&quot;) &gt;&gt; javaFile;
+		print(&quot;			DefaultInitAIEvent initEvtImpl =  new DefaultInitAIEvent(memory);&quot;) &gt;&gt; javaFile;
+		for (m=0; m &lt; evtsNumMembers[evtIndex]; m++) {
+			name = evtsMembers_name[evtIndex, m];
+			if (!match(name, /(sizeInfo)|(info)|(sizeOptions)|(optionKeys)|(optionValues)/)) {
+				print(&quot;			this.&quot; name &quot; = initEvtImpl.&quot; name &quot;;&quot;) &gt;&gt; javaFile;
+			}
+		}
+		print(&quot;&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pOptionKeys = initEvtImpl.optionsKeys.getPointerArray(0L, initEvtImpl.optionsSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pOptionValues = initEvtImpl.optionsValues.getPointerArray(0L, initEvtImpl.optionsSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			java.util.Properties tmpOptions = new java.util.Properties();&quot;) &gt;&gt; javaFile;
+		print(&quot;			for (int i=0; i &lt; initEvtImpl.optionsSize; i++) {&quot;) &gt;&gt; javaFile;
+		print(&quot;				tmpOptions.setProperty(pOptionKeys[i].getString(0L), pOptionValues[i].getString(0L));&quot;) &gt;&gt; javaFile;
+		print(&quot;			}&quot;) &gt;&gt; javaFile;
+		print(&quot;			this.options = tmpOptions;&quot;) &gt;&gt; javaFile;
+		print(&quot;&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pInfoKeys = initEvtImpl.infoKeys.getPointerArray(0L, initEvtImpl.infoSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			Pointer[] pInfoValues = initEvtImpl.infoValues.getPointerArray(0L, initEvtImpl.infoSize);&quot;) &gt;&gt; javaFile;
+		print(&quot;			java.util.Properties tmpInfo = new java.util.Properties();&quot;) &gt;&gt; javaFile;
+		print(&quot;			for (int i=0; i &lt; initEvtImpl.infoSize; i++) {&quot;) &gt;&gt; javaFile;
+		print(&quot;				tmpInfo.setProperty(pInfoKeys[i].getString(0L), pInfoValues[i].getString(0L));&quot;) &gt;&gt; javaFile;
+		print(&quot;			}&quot;) &gt;&gt; javaFile;
+		print(&quot;			this.info = tmpInfo;&quot;) &gt;&gt; javaFile;
+		print(&quot;		}&quot;) &gt;&gt; javaFile;
+	} else {
+		print(&quot;		useMemory(memory);&quot;) &gt;&gt; javaFile;
+		print(&quot;		read();&quot;) &gt;&gt; javaFile;
+	}
+	print(&quot;	}&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+	for (m=0; m &lt; evtsNumMembers[evtIndex]; m++) {
+		name = evtsMembers_name[evtIndex, m];
+		type_c = evtsMembers_type_c[evtIndex, m];
+		type_jna = convertCToJNAType(type_c);
+		memMods = &quot;public &quot;;
+		if (name == &quot;callback&quot;) {
+			if (className == &quot;Win32InitAIEvent&quot;) {
+				type_jna = &quot;Win32AICallback&quot;;
+			} else if (className == &quot;DefaultInitAIEvent&quot;) {
+				type_jna = &quot;DefaultAICallback&quot;;
+			}
+		} else if (className == &quot;InitAIEvent&quot; &amp;&amp; match(name, /(sizeInfo)|(info)|(sizeOptions)|(optionKeys)|(optionValues)/)) {
+			continue;
+		}
+		print(&quot;	&quot; memMods type_jna &quot; &quot; name &quot;;&quot;) &gt;&gt; javaFile;
+	}
+	if (className == &quot;InitAIEvent&quot;) {
+		print(&quot;	&quot; memMods &quot;java.util.Properties info;&quot;) &gt;&gt; javaFile;
+		print(&quot;	&quot; memMods &quot;java.util.Properties options;&quot;) &gt;&gt; javaFile;
+	}
+	print(&quot;}&quot;) &gt;&gt; javaFile;
+	print(&quot;&quot;) &gt;&gt; javaFile;
+}
+
+# Awaits this format:	const char*[]
+# Returns this format:	String[]
+function convertCToJNAType(cType) {
+
+	jnaType = trim(cType);
+
+	sub(/const/, &quot;&quot;, jnaType);
+	sub(/unsigned/, &quot;&quot;, jnaType);
+	gsub(/ \*/, &quot;* &quot;, jnaType);
+
+	isComplex = 0;
+	isComplex += sub(/char\*\*/, &quot;Pointer&quot;, jnaType);
+	isComplex += sub(/char\*/, &quot;String&quot;, jnaType);
+	isComplex += sub(/struct SAIFloat3(\*)?/, &quot;AIFloat3&quot;, jnaType);
+	isComplex += sub(/struct SAICallback(\*)?/, &quot;AICallback&quot;, jnaType);
+	isComplex += sub(/struct [0-9a-zA-Z_]*/, &quot;Structure&quot;, jnaType);
+
+	isPrimitive = 0;
+	isPrimitive += sub(/bool/, &quot;boolean&quot;, jnaType);
+	isPrimitive += sub(/char/, &quot;byte&quot;, jnaType);
+	#isPrimitive += sub(/wchar_t/, &quot;char&quot;, jnaType);
+	isPrimitive += sub(/short/, &quot;short&quot;, jnaType);
+	isPrimitive += sub(/int/, &quot;int&quot;, jnaType);
+	isPrimitive += sub(/float/, &quot;float&quot;, jnaType);
+	isPrimitive += sub(/double/, &quot;double&quot;, jnaType);
+
+	isPointer = 0;
+	if (isComplex &lt;= 0 &amp;&amp; isPrimitive &lt;= 0) {
+		isPointer += sub(/.*\*/, &quot;Pointer&quot;, jnaType);
+	}
+
+	# convert possible array length specifiers (&quot;[]&quot; or &quot;[2]&quot;)
+	gsub(/\*/, &quot;[]&quot;, jnaType);
+	arrDims = gsub(/\[[^\]]*\]/, &quot;[]&quot;, jnaType);
+
+	jnaType = noSpaces(jnaType);
+
+	return jnaType;
+}
+
+function saveMember(ind_mem_s, member_s) {
+
+	name_s = extractParamName(member_s);
+	type_c_s = extractCType(member_s);
+
+	evtsMembers_name[ind_evtStructs, ind_mem_s] = name_s;
+	evtsMembers_type_c[ind_evtStructs, ind_mem_s] = type_c_s;
+}
+
+
+# aggare te los event defines in order
+/^[ \t]*EVENT_.*$/ {
+
+	doWrapp = !match(($0), /.*EVENT_NULL.*/) &amp;&amp; !match(($0), /.*EVENT_TO_ID_ENGINE.*/);
+	if (doWrapp) {
+		sub(&quot;,&quot;, &quot;&quot;, $4);
+		evtsTopicNameValue[$2] = $4;
+	}
+}
+
+
+# end of struct S*Event 
+/^}; \/\/ EVENT_.*$/ {
+
+	evtsNumMembers[ind_evtStructs] = ind_evtMember;
+	evtsTopicName[ind_evtStructs] = $3;
+
+	printEventJava(ind_evtStructs);
+	printEventOO(ind_evtStructs);
+
+	ind_evtStructs++;
+	insideEvtStruct = 0;
+}
+
+
+# inside of struct S*Event 
+{
+	if (insideEvtStruct == 1) {
+		size_tmpMembers = split($0, tmpMembers, &quot;;&quot;);
+		for (i=1; i&lt;=size_tmpMembers; i++) {
+			tmpMembers[i] = trim(tmpMembers[i]);
+			if (tmpMembers[i] == &quot;&quot; || match(tmpMembers[i], /^\/\//)) {
+				break;
+			}
+#print(&quot;eventName: &quot; eventName);
+#print(&quot;ind_evtStructs: &quot; ind_evtStructs);
+#print(&quot;ind_evtMember: &quot; ind_evtMember);
+#print(&quot;tmpMembers[i]: &quot; tmpMembers[i]);
+#print(&quot;&quot;);
+			saveMember(ind_evtMember++, tmpMembers[i]);
+		}
+	}
+}
+
+# beginn of struct S*Event 
+/^\struct S.*Event( \{)?/ {
+
+	insideEvtStruct = 1;
+	ind_evtMember = 0;
+	eventName = $2;
+	sub(/^S/, &quot;&quot;, eventName);
+	sub(/Event$/, &quot;&quot;, eventName);
+
+	evtsName[ind_evtStructs] = eventName;
+}
+
+
+
+
+
+END {
+	# finalize things
+
+	printOOAIEnd(myOOAIFile);
+	printOOAIEnd(myOOAIAbstractFile);
+	printOOAIFactoryEnd(myOOAIFactoryFile);
+}

Added: branches/caiinterface/AI/Interfaces/Java/bin/native_createCallbackFPInitializations.awk
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/bin/native_createCallbackFPInitializations.awk	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/bin/native_createCallbackFPInitializations.awk	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,47 @@
+#!/bin/awk
+#
+# This awk script creates the function pointer initializations for the SAICallback struct in:
+# rts/ExternalAI/Interface/SAICallback.h
+#
+
+BEGIN {
+	# initialize things
+
+	# define the field splitter(-regex)
+	#FS=&quot;[ \t]+&quot;
+}
+
+
+# Some utility functions
+
+function ltrim(s) { sub(/^[ \t]+/, &quot;&quot;, s); return s; }
+function rtrim(s) { sub(/[ \t]+$/, &quot;&quot;, s); return s; }
+function trim(s)  { return rtrim(ltrim(s)); }
+
+
+function printInit(functionName) {
+	print(&quot;	sAICallback-&gt;&quot; functionName &quot; = _&quot; functionName &quot;;&quot;)
+}
+
+
+/^.*CALLING_CONV.*$/ {
+
+	line = trim($0);
+	doWrapp = !match(line, /^[ \t]*\/\/.*/);
+	if (doWrapp) {
+		numParts = split(line, parts, /\(CALLING_CONV \*/);
+		if (numParts == 2) {
+			numParts2 = split(parts[2], parts2, /\)\(/);
+			if (numParts2 == 2) {
+				fn = parts2[1];
+				printInit(fn);
+			}
+		}
+	}
+}
+
+
+
+END {
+	# finalize things
+}

Added: branches/caiinterface/AI/Interfaces/Java/data/InterfaceInfo.lua
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/data/InterfaceInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/data/InterfaceInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,52 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the AI_INTERFACE_PROPERTY_* defines in
+--            SAIInterfaceLibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'Java-0.1',
+		desc   = 'base of the library file of this AI. &quot;C-0.1&quot; means &quot;AI/Interfaces/impls/libC-0.1.so&quot;, &quot;AI/Interfaces/impls/libC-0.1.dylib&quot; or &quot;AI/Interfaces/impls/C-0.1.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'Java',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'name',
+		value  = 'default Java AI Interface',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'This interface is needed for Java AIs',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AIInterface:Java">http://spring.clan-sy.com/wiki/AIInterface:Java</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'supportedLanguages',
+		value  = 'Java (possily Groovy, JRuby, ...)',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Interfaces/Java/data/InterfaceInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AI.java
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AI.java	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AI.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,37 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package com.clan_sy.spring.ai;
+
+
+import com.sun.jna.Pointer;
+import java.util.Properties;
+
+/**
+ * Serves as Interface for a Java Skirmish AIs for the Spring engine.
+ *
+ * @author	hoijui
+ * @version	0.1
+ */
+public interface AI {
+
+	public int init(int teamId, Properties info, Properties options);
+
+	public int release(int teamId);
+
+	public int handleEvent(int teamId, int topic, Pointer event);
+}


Property changes on: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AI.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AICommand.java
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AICommand.java	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AICommand.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,38 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package com.clan_sy.spring.ai;
+
+
+import com.sun.jna.Structure;
+
+/**
+ * Serves as Interface for a Java Skirmish AIs for the Spring engine.
+ *
+ * @author	hoijui
+ * @version	0.1
+ */
+//public interface AICommand {}
+public abstract class AICommand extends Structure/* implements Structure.ByReference*/ {
+
+	public abstract int getTopic();
+
+//	@Override
+//	public boolean getAutoRead() { return true; }
+//	@Override
+//	public boolean getAutoWrite() { return true; }
+}


Property changes on: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AICommand.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIEvent.java
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIEvent.java	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIEvent.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,32 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package com.clan_sy.spring.ai;
+
+
+import com.sun.jna.Structure;
+
+/**
+ * Serves as Interface for a Java Skirmish AIs for the Spring engine.
+ *
+ * @author	hoijui
+ * @version	0.1
+ */
+//public interface AIEvent {}
+public abstract class AIEvent extends Structure/* implements Structure.ByReference*/ {
+	public abstract int getTopic();
+}


Property changes on: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIEvent.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIFloat3.java
===================================================================
--- branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIFloat3.java	                        (rev 0)
+++ branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIFloat3.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,81 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package com.clan_sy.spring.ai;
+
+
+import com.sun.jna.Structure;
+import java.awt.Color;
+import javax.vecmath.Vector3f;
+
+/**
+ * Wrapper for file:
+ * rts/ExternalAI/Interface/SAIFloat3.h
+ *
+ * @author	<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>
+ * @version	0.1
+ */
+public final class AIFloat3 extends Structure implements Structure.ByValue {
+
+	public float x, y, z;
+
+	public AIFloat3() {
+
+		this.x = 0.0f;
+		this.y = 0.0f;
+		this.z = 0.0f;
+	}
+	public AIFloat3(float x, float y, float z) {
+
+		this.x = x;
+		this.y = y;
+		this.z = z;
+	}
+	public AIFloat3(final float[] xyz) {
+
+		this.x = xyz[0];
+		this.y = xyz[1];
+		this.z = xyz[2];
+	}
+	public AIFloat3(final Color color) {
+
+		this.x = color.getRed();
+		this.y = color.getGreen();
+		this.z = color.getBlue();
+	}
+	public AIFloat3(final Vector3f vec3f) {
+
+		float[] tmpXyz = new float[3];
+		vec3f.get(tmpXyz);
+		this.x = tmpXyz[0];
+		this.y = tmpXyz[1];
+		this.z = tmpXyz[2];
+	}
+
+	public Color toColor() {
+		return new Color(x, y, z);
+	}
+	public Vector3f toVector3f() {
+		return new Vector3f(x, y, z);
+	}
+	public void loadInto(float[] xyz) {
+
+		xyz[0] = x;
+		xyz[1] = y;
+		xyz[2] = z;
+	}
+}


Property changes on: branches/caiinterface/AI/Interfaces/Java/java/src/com/clan_sy/spring/ai/AIFloat3.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/freebsd-amd64.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/freebsd-amd64.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/freebsd-i386.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/freebsd-i386.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/jna.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/jna.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/linux-amd64.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/linux-amd64.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/linux-i386.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/linux-i386.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/mac-darwin.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/mac-darwin.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/win32-amd64.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/win32-amd64.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/jna/win32-x86.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/jna/win32-x86.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: branches/caiinterface/AI/Interfaces/Java/jlib/vecmath.jar
===================================================================
(Binary files differ)


Property changes on: branches/caiinterface/AI/Interfaces/Java/jlib/vecmath.jar
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Copied: branches/caiinterface/AI/Skirmish/AAI/data/AAI FAQ.txt (from rev 7034, branches/caiinterface/game/AI/AAI/AAI FAQ.txt)
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/data/AAI FAQ.txt	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/AAI/data/AAI FAQ.txt	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,217 @@
+Author: 	Alexander 		Icq: 138100896					email:	alexander.seizinger
+		Seizinger		Jabber: <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">alexander.seizinger at jabber.org</A>				@gmx.net
+
+Questions:
+
+- The message &quot;AAI not properly initialized, please view ai log for further information&quot; appears
+
+- How do i add support for other mods?
+
+- A new version of a mod has been released
+
+- How does water map support work?
+
+- AAI crashes right at the beginning on map x
+
+- AAI's commander just stands around doing nothing/stops after a few buildings
+
+- AAI crashes right at the beginning running mod y
+
+- AAI needs a lot of time to load on map z
+
+- Is it possible to play together with AAI in the same team?
+
+- AAI makes stupid unit/buidling choices (e.g. placing depth charge launchers on land maps)
+
+- AAI builds wrong factories first (eg. hovercraft platforms on land maps)
+
+- AAI places defence buildings ineffectively
+
+- AAI places metal extractors ineffectively/everywhere
+
+- What kind of information is stored in mod learning files?
+
+- Is it possible to play on water maps?
+
+- AAI does not build enough stationary artillery/builds to much stat. artillery
+
+- Why is it called 'AAI'?
+
+
+
+Answers:
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	The message &quot;AAI not properly initialized, please view ai log for further information&quot; appears
+
+A: 	This means that AAI has not been set up properly and will not work. This may have several reasons but in most 
+	cases AAI could not find the cfg file for the mod you are running. Another reason might be an erroneous cfg 
+	(such as misspelled keyword, non existing unit names, etc.)
+	Have a look at the AI log (in the main AAI folder) - it may provide you with further information about what 
+	went wrong. 
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	How do i add support for other mods?
+
+A: 	At first you have to figure out the internal names (e.g. ARMCOM) of the starting units of all sides (they can 
+	be found in the mod archive in sidedata.tdf) and create a cfg file in the cfg-subfolder. The filename is the name of the mod-file, 	replace its ending with &quot;.cfg&quot;. In case you are not sure about the filename try to run AAI with that mod. It will fail 
+	to load and print the desired cfg filename in its logfile (look at /aai/log/).
+
+	You will have to specify the number of different sides, their names and starting units. All other statements
+	are optional. You will find a complete list of all statements as well as their default values in the 
+	/aai/cfg/help/example mod.cfg) 
+	
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	A new version of a mod has been released
+
+A:	(a) Minor release (only minor tweaks/balances)
+	    AAI should adapt to minor changes concerning speed/damage etc. rather quickly. You may port your old mod 
+	    learning file by renaming it. Do not forget to rename the cfg file as well
+
+	(b) Major release (new units, different roles of existing units, changes concerning buildoptions)
+	    In this case AAI must create a new mod learning file. Just rename the cfg file and let AAI create a new 
+	    mod leraning file 
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	How does water map support work
+
+A: 	At first AAI will run an automatic test trying to detect the map type. However this may not be quite correct 
+	for several reasons so you may have to adjust AAI's behaviour manually. Browse the /cfg/map/ subfolder and 
+	look for the cfg-file of the map. Open it with a text editor and change the entry. The following expressions 
+	are valid:
+	
+	LAND_MAP 	- 	default map type
+	LAND_WATER_MAP 	-	map contains both water and land (with direct land connections to the other bases)
+	WATER_MAP	- 	pure water map (AAI will not build any ground assault units)
+	AIR_MAP		-	air only map (works more or less the same as &quot;AIR_ONLY_MOD&quot; option)
+
+	Please note, that after modifying the map cfg file you MUST delete the map learning file (browse to learn/map/ 
+	the filename constists of the mapname and the modname), otherwise AAI will not reset its map learning results
+	and try to build ground units on water maps.
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI crashes right at the beginning on map x
+
+A: 	This may have various reasons, AAI has sometimes problems with metal maps. Also note that water maps 
+	are not supported yet
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI's commander just stands around doing nothing/stops after a few buildings
+
+A: 	This is most likely because you are trying to play on a metal map with small extractor ranges. Since i really 
+	dislike metal maps its not quite on top of my todo list to support metal maps
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI crashes right at the beginning running mod y
+
+A: 	Some mods like FinalFrontier crash AAI for some reason. It could also be possible that one of the learning
+	files has been corrupted, try to remove the files in the learn and/or cache subfolder
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI needs a lot of time to load on map z
+
+A: 	Before being able to play the game, AAI must do two things, which may need quite some time:
+	- All unit definitions of the selected mod must be loaded (several instances of AAI share these data so it
+	  must be done only once per game)
+	- When playing a map for the first time, AAI has to determine suitable mex-spots as well as performing 
+	  some primitive terrain analysis (cliffs, water, flat terrain) - however, these data will be cached for
+	  usage in later games	
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	Is it possible to play together with AAI in the same team?
+
+A: 	Though it is possible there are various limitations: 
+	- Never build buildings on your own, AAI will get confused
+	- It's best not to touch construction units at all
+	- Don't give buildorders for units yourself, AAI will get confused
+	- You may take control of assault units
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI makes stupid unit/buidling choices (e.g. placing depth charge launchers on land maps)
+
+A: 	AAI has to learn about the abilities of the different combat units. At the beginning, all units are considered 
+	to be equally effective against any other unit. It will take some time until AAI learns, which units are for 
+	example suitable for air defence. AAI probably learns fastest when playing against human players who show the
+	&quot;correct&quot; usage of certain units. Keep in mind that for learning purposes AAI chooses a certain amount of 
+	units (adjustable in the general.cfg) by chance so it may sometimes build weak/wrong units no matter how 
+	long it has been learning.
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI builds wrong factories first (eg. hovercraft platforms on land maps)
+
+A: 	AAI will rate factories based on the units, they may build and how useful these units have been on a certain 
+	map in the last games. This may lead to rather strange behaviour (like building hovercraft platforms and 
+	aircraft plants before kbot lab on a land map) but it should be gone after a few matches. 
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI places defence buildings ineffectively
+
+A: 	AAI will remember where it has been attacked and place its defences according to these results. Therefore AAI 
+	will need some games to learn about the map. In general it will try to build defences at the border of 
+	its base
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI places metal extractors ineffectively/everywhere
+
+A: 	This is most likely the result of bug in the mex spot finding algorithm where a map is wrongly considered
+	to be a metal map 
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	What kind of information is stored in mod learning files?
+
+A: 	Mod learning files suit several purposes:
+	
+	- They provide AAI with a complete buildtree (which unit builds what) 
+	
+	- They store a lot of information about all units (category (e.g. power plant, mex, aircraft builder), cost,
+	  speed, buildtime, special ratings) that have been calculated in a special way  
+	
+	- They store a lot of precached data that help AAI selecting units/buildings (like min/max buildtime, cost, 
+	  weapons range, etc. of the categories)
+	
+	- They store the learning data of all combat units/stationary defences 
+
+	
+	Therefore mod learning files must be created again if
+	
+	- units have been added/removed
+
+	- buildoptions of a certain unit have been added/removed
+
+	- movement type (ground, air, sea, hover, building) of units changed
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	Is it possible to play on water maps?
+
+A: 	Since AAI v0.60 there is basic naval support. However AAI may have difficulties detecting the correct map 
+	type. Look some questions above for further information
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	AAI does not build enough stationary artillery/builds to much stat. artillery
+
+A: 	You can easily adjust the maximum number of stationary artillery in the mod.cfg file (look for MAX_STAT_ARTY 
+	statement - if it is not set, the default value will be 3). You may also disable stationary artillery 
+	completly by setting this to 0
+
+--------------------------------------------------------------------------------------------------------------------
+
+Q: 	Why is it called 'AAI'?
+
+A: 	Due to a lack of creativity the 'A' results from the prename of its developer
+


Property changes on: branches/caiinterface/AI/Skirmish/AAI/data/AAI FAQ.txt
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/AAI/data/AAI ReadMe.txt (from rev 7034, branches/caiinterface/game/AI/AAI/AAI ReadMe.txt)
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/data/AAI ReadMe.txt	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/AAI/data/AAI ReadMe.txt	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,531 @@
+Author: 	Alexander 		Icq: 138100896					email:	alexander.seizinger
+		Seizinger		Jabber: <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">alexander.seizinger at jabber.org</A>				@gmx.net
+
+
+Installation: 	Windows users:
+
+		Simply extract the archive into your spring\ai\ folder and make sure, the following subfolders exist:
+		
+		\ai\aai			-&gt; readme, faq and different logs 
+		\ai\aai\cache		-&gt; map data (metal spots, water, etc)
+		\ai\aai\cfg\map		-&gt; map config files
+		\ai\aai\cfg\mod		-&gt; mod config files
+		\ai\aai\learn\map	-&gt; map learn files
+		\ai\aai\learn\mod	-&gt; mod learn files
+		\ai\aai\log		-&gt; log files 
+
+		\ai\bot-libs\aai.dll 	-&gt; main ai dll
+
+		If one of these folders does not exist, AAI will crash!
+
+		
+		Linux users: 
+
+		AAI will get the path of a writable directory from spring and load/save its files there
+		e.g.  /usr/local/games/taspring 
+
+		Apart from that the structure is the same as for windows users.
+
+
+
+		Please note, that there are hardly any buildtables included in this release. AAI should make better 
+		unit choices after a while. For further information, have a look at the AAI FAQ.
+
+		Furthermore I want to emphasize that there are quite some opportunities to change/improve AAI's way of
+		playing the game. Have a look at the cfg/help/mod.cfg for further information. If you think you created 
+		a cfg file which makes AAI play a certain much better than the default one mail it to me to include it 
+		in future releases.
+
+
+
+License:	Since AAI v0.70 all files have been released under the GPL
+
+
+
+Mod Support:	AAI must know the internal names of the starting units of the different sides (e.g. ARMCOM 
+		and CORCOM for most TA-mods). There are also some constants you may want to play with, so 
+		AAI tries to load the config from a file in the aai subfolder. The name must be the same as 
+		the modname, with &quot;.cfg&quot; extension (e.g. xta_se_v066.cfg for XTA mod). If you are not sure 
+		about the correct filename, just start a game running that mod. AAI will complain about 
+		missing cfg files and put the desired cfg filename in the log files.
+
+		See example.cfg for more information.
+		
+		By default, AAI has cfg files to support the following mods:
+		- XTA
+		- TA:WD 5.65
+		- AA 2.23 Standard
+		- AA 2.23 Forge
+		- Balanced AA
+		- OTA Shiny 5.5
+		- OTA Classic 5.5
+		- BoTA 1.3
+		- KuroTA 0.47
+		- Star Wars 1.0
+		- TLL 1.04
+		- FF 1.19		
+		- Gundam Annihilation 
+		- Expand &amp; Exterminate 0.163
+		- Spring 1944
+		- TA Battle Fleet
+
+
+		
+	!!!	Remember due to updates of these mods the filenames might change as well, so you have	!!!
+	!!!	to rename the mod.cfg file yourself							!!!
+
+
+
+
+Known bugs/	- AAI sometimes suffers from a bug in the pathfinding (units sometimes get stuck when close 
+Limitations:	  to buildings/objects)
+
+		- AAI does not use nukes, antinukes, emp missiles
+
+
+
+Thanks to: 	- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
+		  and coding contributions (since AAI v0.83) 
+
+		- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
+
+		- TA Spring devs for creating the best open source rts game I know
+
+		- Jelmer 'JC' Cnossen for some functions and a lot of helpful discussions
+
+		- Krogothe for his mex spot algorithm
+
+		- AccidUK for debugging and some coding suggestions
+
+		- Tournesol and Firenu for helping me getting debugging to work
+		
+		- All other testers who are not listed here
+		
+		- All other people who gave some feedback 
+
+		- Brandon Potter for his TBT 12 cfg file
+
+
+AAI v0.875	- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order 
+		  water factories on a land map anymore)
+
+		- Improved AAIs behaviour on water maps with start positions on islands/land masses
+
+		- Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, 
+		  works better if there are land and sea spots available at the same time)
+
+		- Continent file version bumped to 0.87
+
+		- Fixed a crash on shut down introduced in Spring v0.77
+
+
+AAI v0.872	- Refactored code for getting rally points and positions to withdraw units and made 
+
+		- Construction units that are member of the DONT_BUILD list will not be built anymore
+		
+		- Fixed two bugs that have been introduced in v0.87 and could cripple AAI's economy a lot
+
+
+AAI v0.87	- Proper detection of amphibious ground units (was causing AAI to freeze on water maps)
+
+		- Prevent AAI from blocking buildqueues for combat units by requesting too many scouts
+
+		- Added proper handling of resurrected units (however AAI does not build resurrectors atm)	
+
+		- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
+		  their turnrate is not too low)
+
+		- Added some new variables to mod config file:
+
+		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
+
+		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
+
+		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
+
+  		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
+
+		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 
+		  naval units
+
+		- AAI now takes continents into account when sending scouts to positions (e.g. it does not try send ground scouts to 
+		  positions on other islands/continents anymore)
+
+		- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
+		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
+
+		- Fixed a bug that caused builders to leave the buildsite during construction 
+
+		- Fixed various freezes that have been caused by AAI flooding the ai interface with thousands of orders per frame
+
+		- Fixed a bug that could prevent AAI from rebuilding destroyed factories
+
+		- Bumped mod learning file version to 0.86 due to some changes in handling of amphibious units
+
+
+AAI v0.86	- Added NON_AMPHIB_MAX_WATERDEPTH float (default is 15) statement to mod cfg file, specifies the max water depth 
+		  non amphibious ground units can cross
+
+		- Added detection of amphibious units 
+
+		- Added new continent detection system: AAI will divide the map into continents marking connected land(water)masses
+		  AAI will make a lot of use of this knowledge in future versions
+		  -&gt; map cache file version bumped to 0.86
+
+		- Improved base expansion on water maps (e.g. AAI should no longer expand into a small pond on Small Supreme Battlefield
+		  rather than the big ocean next to it) 
+
+		- Added COST_MULTIPLIER key word to mod cfg file, it allows to override the costs of a unit, e.g. 
+		  COST_MULTIPLIER armzeus 0.5 causes AAI to treat Arm Zeus as if it would cost half as much as it really does
+		  This feature has been requested by Argh to porperly deal with unit squads (building a single unit will 
+		  provide the player with several independent units)
+
+		- Fixed a stupid bug that prevented AAI from placing static defences according to terrain if map has already 
+		  been played before (bug in loading routine of map cache file)  
+
+
+AAI v0.85	- Added TRANSPORTERS keyword to mod cfg file, works like SCOUTS or ATTACKERS. Note that AAI does not use transporters
+		  yet, but it may be used in future times
+
+		- Redone scout selection, AAI may now use cloaked scouts, reduced GROUND/AIR/SEA/HOVER_SCOUT categories to one 
+		  SCOUT category 
+		
+		-&gt; Due to those changes buildtable version has been bumped to 0.85
+
+		- Fixed a bug that prevented AAI from building builders under certain conditions (S44 was suffering from that)
+
+		- AAI will remove sectors where it lost all its buildings from base (may add them again at any time later though)
+
+		- Completly redone defence building placement (AAI will now take terrain into account as well as already existing 
+		  defences) It should give much better results now especially on maps that dont have rather flat terrain
+		  
+		- AAI will take allied structures into account when looking for rally points for its combat units (helps to
+		  better prevent AAI from blocking allied bases with its units)
+
+		- Different instances of AAI now share several kind of map information (saves ram space) and do not expand to 
+		  sectors occupied by allied AAIs anymore
+
+		- Added DONT_BUILD keyword to mod cfg files, it works like SCOUTS or ATTACKERS, units listed after DONT_BUILD will 
+		  not be build by AAI in any case (and will not been taken into account for internal statistics)			
+
+		- Added ATTACKERS keyword to mod cfg file to force AAI to use specified units as combat units despite all other 
+		  capabilities of the unit (e.g. buildoptions)  (implemented by Yuritch)
+
+		- Resurrectors now may ressurect corpses instead of reclaiming them (however ressurectors chase newly resurrected 
+		  units trying to repair them - needs some work) (implemented by Yuritch)
+
+		- Improved mex and power plant building rules a bit
+
+		- AAI will upgrade the least effective metal extractors first (only important if a mod has more than two metal 
+		  extractors with different efficiencies)
+
+		- Fixed a few potential crash bugs
+
+
+AAI v0.80	- Improved/tweaked/fixed attack behaviour, AAI will try to withdraw when facing much stronger enemy forces
+
+		- Added attack behaviour for air only mods
+
+		- Added support for different reading/writing paths (only important for linux users)
+
+		- Completly redesigned factory/builder management to support mobile factories and other stuff in the future
+		  (EE hub system is NOT supported though)
+
+		- Extended mod learning about usage of different unit categories with respect to elapsed game time	
+
+		- Reduced unit categories: LAND/SEA/HOVER/AIR_BUILDER are now in the same category GROUND/SEA_FACTORY 
+		  are now in the same category (slight performace increase and nicer code)
+
+		- Improved mex spot selection (to prevent unnecessary long ways for builders), AAI will now also build better 
+		  extractors (e.g. moho mines) outside the base (according to safety)
+
+		- Improved placement of stationary defences and tweaked selection of them a bit
+
+		- Cleaned up buildtables, removed some old stuff, mod learning filesize decreased
+
+		- Decreased map-learning filesize by removing stationary artillery learning and some other unnecessary stuff
+		  (map-leraning version changed)
+
+		- AAI no longer crashes when one of its units get captured
+
+		- AAI now builds air bases/refuel pads (thx to yuritch for finding the bug)
+
+		- Fixed various issues/bugs that could cause stalling / prevent AAI from building further factories, builders 
+
+		- Fixed a few bugs that could cause erroneus behaviour on water maps as well as a submarine related bug
+	
+		- Fixed lots of crash bugs
+
+		- Fixed a possible memory leak in AAIBuildTable
+
+		- Increased mod learning file version 
+
+
+
+AAI v0.75	- Completly redone attack system: AAI will now attack more elaborately 
+		  (attackers move on if are cleared, bombers returning to base when target destroyed, attack groups now 
+		  retreat under several circumstances, combat groups are guarded by aa units - however it still tends 
+		  to send in streams of attackers - will be adressed in one of the next versions ) Please note that at the 
+		  moment the new attack system does not work with air only mods such as FF at all. AAI will build a base 
+		  as well as combat units and react to the actions of the player but it will not attack in a proper way
+		
+		- Added MAX_ATTACKS statement to mod.cfg which determines the max number of independent attack waves at
+		  the same time (set to 4 by default)
+
+		- Modified artillery sorting in preparation of artillery support in one of the next versions.
+		  Added GROUND_ARTY_RANGE, SEA_ARTY_RANGE and HOVER_ARTY_RANGE statement to mod cfg. These replace the
+		  former MOBILE_ARTY_RANGE statement (it's no longer valid, remove from old cfg files)
+
+		- For linux users: AAI will now store its files in the only writable datadirectory automatically (where 
+		  spring saves all its other files) 
+
+		- AAI now tries to get a safer rally point if combat units are killed en route 
+
+		- Builders now try to flee when attacked 
+
+		- AAI now takes allied buildings into account when expanding its base (to prevent AAI from building within
+ 		  the base of someone else)	
+
+		- Improved AAI's building placement at the beginning of the game (buildings will not be spread out 
+		  that much anymore to reduce walking time of commander (thx to Accid_UK for the idea - should have been 
+		  already implemented in 0.70 but has somehow been commented out)   
+
+		- Tweaked economy/factory/defence building placement and selection
+
+		- Fixed a bug that prevented AAI from building naval power plants
+
+		- Fixed a bug which sometimes caused builders to leave their construction site
+
+		- Fixed a bug that caused AAI to temporarily run out of scouts when requesting several scouts it could 
+		  not build at that time 
+
+		- Fixed a bug that caused serious confusion concerning unit speeds (unfortunately mod learning file 
+		  version had to be changed)
+
+		- Fixed a very rare crashbug in the building placement algorithm
+
+		- Fixed a possible crash bug in the airforce handling (thx to Nicklas Marcusson for reporting it)
+
+
+
+AAI v0.70	- AAI now handles anti air/assault units, bombers and fighters with different groups 
+		  (requires a little bit of learning to work properly)
+
+		- Added new category SUBMARINE_ASSAULT to improve AAI's behaviour on water maps 
+
+		- Added MAX_ANTI_AIR_GROUP_SIZE, MAX_NAVAL_GROUP_SIZE, MAX_SUBMARINE_GROUP_SIZE 
+		  and MAX_ARTY_GROUP_SIZE (not in use yet) statement to mod cfg	
+
+		- Added FAST_UNITS_RATE and HIGH_RANGE_UNITS_RATE statements to mod.cfg
+
+		- Added different sub-groups for air only mods (light, medium, heavy &amp; super heavy air assault)
+
+		- Added a message being displayed from time to time when AAI has not been loaded succesfully
+
+		- Completly new combat unit selection (in theory, aai should react more dynamically to its 
+		  opponent's behaviour - requires some learning to work porperly)
+
+		- Improved/fixed building of stationary defences - only terporary, defence placement will be reworked 
+		  within the next versions (MIN_SECTOR_THREAT statement added to mod.cfg)
+
+		- Idle builders will now try to reclaim wreckages/features in/close to the base
+
+		- Improved unit detection a bit (some bogus weapons like mobile jammers in aa will not be considered 
+		  being combat units anymore, static mobile units (like dragons claw) will be filtered out as well)		 
+		
+		- Improved assistance management e.g. factories will now call assisters both based on buildque length 
+		  and buildtime of single units (thx to accid_uk for his suggestion)
+
+		- Added MIN_ASSISTANCE_BUILDSPEED statement to mod cfg
+
+		- AAI now takes the position of its base into account when placing stationary defences for 
+		  extractors outside of its base
+
+		- New power plant selection (fixed AAI not building pocket fusions in ff) 
+
+		- Fixed a spelling bug when reading cfg files (keyword had been MAX_ASSITANTS instead of MAX_ASSISTANTS)
+		  (thx to Acidd_UK for reporting this bug) 
+
+		- Fixed a bug that prevented AAI from upgrading metal extractors
+
+		- Fixed a bug that could cause AAI to freeze when builders get stuck
+
+		- Fixed scout spamming bug 
+
+		- Fixed possible buffer overflow when reading cfg files (thx to FizzWizz for reporting)
+
+		- Fixed a bug that crashed the game on small maps when MAX_MEX_DISTANCE was greater than 
+		  map size (e.g. small divide)
+
+		- Fixed a bug that prevented AAI from rebuilding killed builders
+
+
+AAI v0.63	- AAI now upgrades radars/jammers 
+	
+		- Added MIN_FACTORIES_FOR_RADAR_JAMMER statement to mod cfg
+
+		- Added support for Expand&amp;Exterminate
+
+		- Added support for mods with buildings as starting units (like AATA)
+
+		- Added mod cfg file for BoTA (thx to yuri)
+
+		- Tweaked defence building selection
+	
+		- AAI now prefers armed metal extractors when building far away from its main base
+
+		- Fixed some bugs in the BuildTable (buildtable version changed)
+
+		- Fixed a bug causing the buildmap not to be cleared when a building has been destroyed
+
+		- Fixed a bug concerning speed groups
+
+		- Fixed various crashbugs (big thank you to nicke for helping me finding them)
+
+
+AAI v0.60:	(AAI's folder structure changed as well as all cache/learning files - i heavily recommend deleting old 
+		 AAI versions before installing AAI 0.60)
+	
+		- Experimental water map support, view FAQ for more details
+
+		- Changed buildtable: Hover crafts got their own category (no longer part of ground units) and several
+		  code cleanups to optimize speed
+
+		- AAI remembers which usefulness of different assault categories and orders further combat units based on 
+		  that (i hope this will especially help adjusting the amount of land, hover and sea units aai uses on a 
+		  mixed land/water map) 
+	
+		- Added support for stationary artillery (e.g. berthas) (added MAX_STAT_ARTY statement to mod cfg)
+
+		- Added support for air repair pads (added MAX_AIR_BASE statement to mod cfg)
+		  edit: seems to be broken somehow 
+
+		- Added support for several factories of the same type (added MAX_FACTORIES_PER_TYPE statement to mod cfg)
+
+		- AAI now defends extractors outside its base up to a certain max dinstace with cheap defence buildings
+		  (added MAX_MEX_DEFENCE_DISTANCE statement to mod cfg)		
+
+		- Builder selection improved, AAI now uses closest idle builder
+
+		- AAI now sorts combat units into groups according to their max speed 
+		  (added UNITS_SPEED_SUBGROUPS statement to mod cfg)
+
+		- Improved Air Force handling (added MAX_AIR_GROUP_SIZE, MIN_AIR_SUPPORT_EFFICIENCY statement to mod cfg)
+			
+		- Improved/Fixed several mod cfg files
+
+		- Improved ressource management/AAI will now upgrade extractors to better ones
+
+		- Improved defence building selection
+
+		- Fixed a bug that crashed game right at the start on certain maps (eg. Battle Holmes)
+		  (thx to HiEnergy for reporting this bug)
+
+		- Fixed a few crashbugs
+
+		- Fixed various smaller issues/bugs
+
+		- Extended memory sharing between multiple instances of AAI and fixed a shared memory related crashbug
+		
+
+AAI v0.55:	- AAI is now compatible with the modified ai interface of spring 0.70	
+	
+		- Extended map learning files/every mod now creates own map learing files
+
+		- AAI tries not to send builders in setors which turned out to be too dangerous
+
+		- Fixed a rounding related crashbug
+
+		- Fixed a bug causing AAI to stop constructing new buidlings
+
+		- Fixed a bug causing AAI to build rows of sensor towers in SW:TA			
+
+		- Fixed several bugs in the energy management causing aai not to build any further power plants
+
+
+AAI v0.50:	- Completly new ressource management system (will be further improved in future versions)
+
+		- Buildtable will now be shared by all instances of AAI (this mainly reduces aai's memory usage as well as 
+		  a slight increase in loading time when running more than one aai-player at the same time) 
+
+		- Improved factory/builder request system/modified buildtable, to be able to add support for AATA	
+
+		- Improved radar/jammer placement
+
+		- AAI now builds metal makers and storage buidlings
+	
+		- Added support for metal maps 
+
+		- Added support for air units only mods (e.g. Final Frontier)
+
+		- Added a general.cfg holding information that is used for all mods (e.g. allowing users to adjust how much
+		  cpu-power AAI takes for scouting)
+		
+		- Fixed a bug when AAI stopped building after completing a few buildings
+
+		- Fixed a bug that crashed AAI right at the beginning on certain maps (especially metal maps)
+		  (thx to IMSabbel for reporting this bug)
+
+		- Fixed a few crashbugs
+
+		- Added mod support: Final Frontier, Gundam Annihilation
+	  
+
+AAI v0.40:	- Scouting redone
+ 
+		- Construction units now assist other builders/factories when needed
+
+		- Added support for mods with more than two sides -&gt; cfg files changed, replace with new ones
+		
+		- Improved building placement (AAI now prevents &quot;diagonal rows&quot;), fixed a building placement 
+		  related crashbug as well
+
+		- AAI now uses radar
+
+		- AAI now uses air units
+
+		- Hopefully fixed a bug concerning blocked buildsites
+
+
+AAI v0.30: 	- AAI now builds defence buildings (will be extended later on)
+
+		- Improved expansion
+	
+		- All learning/cache files now contain an internal version to provide better compatibility in the future. 
+		  if there will be any changes in the future newer file versions will be created automatically
+
+		- Fixed various bugs, AAI should be running much more stable now
+
+		- Switched to krogothe's mex spot algorithm
+
+
+AAI v0.20: 	- First released version
+
+		- Completely rewritten metal/energy management -&gt; still not working very good
+
+		- Improved selection of more expensive units (prevents AAI from building level 2 
+		  units too early (in most cases...))
+
+		- A certain amount of units will be build to counter air units
+
+		- Various minor fixes and code improvements
+
+
+AAI v0.10: 	(internal version)
+
+		- Works with different mods (see config file section for more information)
+		
+		- AI builds a little base 
+
+		- AI builds all kinds of units and tries to attack enemy bases
+
+		- AI learns about important locations in a map on its own 
+		  (and saves results in a learning-file)
+
+
+
+
+
+
+
+


Property changes on: branches/caiinterface/AI/Skirmish/AAI/data/AAI ReadMe.txt
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/AAI/data/cache (from rev 7034, branches/caiinterface/game/AI/AAI/cache)


Property changes on: branches/caiinterface/AI/Skirmish/AAI/data/cache
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: branches/caiinterface/AI/Skirmish/AAI/data/cfg (from rev 7034, branches/caiinterface/game/AI/AAI/cfg)


Property changes on: branches/caiinterface/AI/Skirmish/AAI/data/cfg
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: branches/caiinterface/AI/Skirmish/AAI/data/learn (from rev 7034, branches/caiinterface/game/AI/AAI/learn)


Property changes on: branches/caiinterface/AI/Skirmish/AAI/data/learn
___________________________________________________________________
Name: svn:mergeinfo
   + 

Copied: branches/caiinterface/AI/Skirmish/AAI/data/log (from rev 7034, branches/caiinterface/game/AI/AAI/log)


Property changes on: branches/caiinterface/AI/Skirmish/AAI/data/log
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: branches/caiinterface/AI/Skirmish/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/CMakeLists.txt	2008-12-05 16:12:49 UTC (rev 7129)
@@ -16,12 +16,12 @@
 	set(KAI_DATA_DIR ${SKIRMISH_DATA}/KAI/${KAI_VERS})
 	message(STATUS &quot;${KAI_VERS}\t(KAI Version)&quot;)
 
+	# install data files
+	#install(DIRECTORY &quot;${KAI_SRC}/data/&quot;
+	#		DESTINATION &quot;${KAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${KAI_SRC} kai)
 	#add_library(${KAI_TARGET} MODULE ${kai} ${legacycppaienv} ${creg})
-	#install (FILES ${KAI_SRC}/AIInfo.lua DESTINATION ${KAI_DATA_DIR})
-	#if (EXISTS ${KAI_SRC}/AIOptions.lua)
-	#	install (FILES ${KAI_SRC}/AIOptions.lua DESTINATION ${KAI_DATA_DIR})
-	#endif (EXISTS ${KAI_SRC}/AIOptions.lua)
 	#set_target_properties(${KAI_TARGET} PROPERTIES COMPILE_FLAGS &quot;-DUSING_CREG&quot;)
 	#install (TARGETS ${KAI_TARGET} DESTINATION ${KAI_DATA_DIR})
 endif (EXISTS ${KAI_SRC})
@@ -38,12 +38,12 @@
 	set(KAIK_DATA_DIR ${SKIRMISH_DATA}/KAIK/${KAIK_VERS})
 	message(STATUS &quot;${KAIK_VERS}\t(KAIK Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${KAIK_SRC}/data/&quot;
+			DESTINATION &quot;${KAIK_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${KAIK_SRC} kaik)
 	add_library(${KAIK_TARGET} MODULE ${kaik} ${legacycppaienv} ${creg})
-	install (FILES ${KAIK_SRC}/AIInfo.lua DESTINATION ${KAIK_DATA_DIR})
-	if (EXISTS ${KAIK_SRC}/AIOptions.lua)
-		install (FILES ${KAIK_SRC}/AIOptions.lua DESTINATION ${KAIK_DATA_DIR})
-	endif (EXISTS ${KAIK_SRC}/AIOptions.lua)
 	set_target_properties(${KAIK_TARGET} PROPERTIES COMPILE_FLAGS &quot;-DUSING_CREG&quot;)
 	install (TARGETS ${KAIK_TARGET} DESTINATION ${KAIK_DATA_DIR})
 endif (EXISTS ${KAIK_SRC})
@@ -60,12 +60,12 @@
 	set(RAI_DATA_DIR ${SKIRMISH_DATA}/RAI/${RAI_VERS})
 	message(STATUS &quot;${RAI_VERS}\t(RAI Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${RAI_SRC}/data/&quot;
+			DESTINATION &quot;${RAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${RAI_SRC} rai)
 	add_library(${RAI_TARGET} MODULE ${rai} ${legacycppaienv})
-	install (FILES ${RAI_SRC}/AIInfo.lua DESTINATION ${RAI_DATA_DIR})
-	if (EXISTS ${RAI_SRC}/AIOptions.lua)
-		install (FILES ${RAI_SRC}/AIOptions.lua DESTINATION ${RAI_DATA_DIR})
-	endif (EXISTS ${RAI_SRC}/AIOptions.lua)
 	install (TARGETS ${RAI_TARGET} DESTINATION ${RAI_DATA_DIR})
 endif (EXISTS ${RAI_SRC})
 
@@ -102,6 +102,10 @@
 	set(NTai_DATA_DIR ${SKIRMISH_DATA}/NTai/${NTai_VERS})
 	message(STATUS &quot;${NTai_VERS}\t(NTai Version)&quot;)
 
+	# install data files
+	#install(DIRECTORY &quot;${NTai_SRC}/data/&quot;
+	#		DESTINATION &quot;${NTai_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${NTai_SRC} ntai)
 	aux_source_directory(${NTai_SRC}/AI/NTai/Units ntai)
 	aux_source_directory(${NTai_SRC}/AI/NTai/Units/Behaviours ntai)
@@ -115,10 +119,6 @@
 	aux_source_directory(${NTai_SRC}/AI/NTai/Agents ntai)
 	#add_library(${NTai_TARGET} MODULE ${ntai} ${legacycppaienv})
 	#target_link_libraries(${NTai_TARGET} boost_thread-mt)
-	#install (FILES ${NTai_SRC}/AIInfo.lua DESTINATION ${NTai_DATA_DIR})
-	#if (EXISTS ${NTai_SRC}/AIOptions.lua)
-	#	install (FILES ${NTai_SRC}/AIOptions.lua DESTINATION ${NTai_DATA_DIR})
-	#endif (EXISTS ${NTai_SRC}/AIOptions.lua)
 	#install (TARGETS ${NTai_TARGET} DESTINATION ${NTai_DATA_DIR})
 endif (EXISTS ${NTai_SRC})
 
@@ -134,12 +134,12 @@
 	set(NullLegacyCppAI_DATA_DIR ${SKIRMISH_DATA}/NullLegacyCppAI/${NullLegacyCppAI_VERS})
 	message(STATUS &quot;${NullLegacyCppAI_VERS}\t(NullLegacyCppAI Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${NullLegacyCppAI_SRC}/data/&quot;
+			DESTINATION &quot;${NullLegacyCppAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${NullLegacyCppAI_SRC} nulllegacycppai)
 	add_library(${NullLegacyCppAI_TARGET} MODULE ${nulllegacycppai} ${legacycppaienv})
-	install (FILES ${NullLegacyCppAI_SRC}/AIInfo.lua DESTINATION ${NullLegacyCppAI_DATA_DIR})
-	if (EXISTS ${NullLegacyCppAI_SRC}/AIOptions.lua)
-		install (FILES ${NullLegacyCppAI_SRC}/AIOptions.lua DESTINATION ${NullLegacyCppAI_DATA_DIR})
-	endif (EXISTS ${NullLegacyCppAI_SRC}/AIOptions.lua)
 	install (TARGETS ${NullLegacyCppAI_TARGET} DESTINATION ${NullLegacyCppAI_DATA_DIR})
 endif (EXISTS ${NullLegacyCppAI_SRC})
 
@@ -155,12 +155,12 @@
 	set(NullAI_DATA_DIR ${SKIRMISH_DATA}/NullAI/${NullAI_VERS})
 	message(STATUS &quot;${NullAI_VERS}\t(NullAI Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${NullAI_SRC}/data/&quot;
+			DESTINATION &quot;${NullAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	aux_source_directory(${NullAI_SRC} nullai)
 	add_library(${NullAI_TARGET} MODULE ${mySrc} ${nullai})
-	install (FILES ${NullAI_SRC}/AIInfo.lua DESTINATION ${NullAI_DATA_DIR})
-	if (EXISTS ${NullAI_SRC}/AIOptions.lua)
-		install (FILES ${NullAI_SRC}/AIOptions.lua DESTINATION ${NullAI_DATA_DIR})
-	endif (EXISTS ${NullAI_SRC}/AIOptions.lua)
 	install (TARGETS ${NullAI_TARGET} DESTINATION ${NullAI_DATA_DIR})
 endif (EXISTS ${NullAI_SRC})
 
@@ -183,6 +183,10 @@
 	set(NullJavaAI_CLASSPATH &quot;.${PATH_DELIM}${Java_AIINTERFACE_SRC}/interface.jar${PATH_DELIM}${Java_AIINTERFACE_SRC}/jlib/jna/jna.jar${PATH_DELIM}${Java_AIINTERFACE_SRC}/jlib/vecmath.jar&quot;)
 	message(STATUS &quot;${NullJavaAI_VERS}\t(NullJavaAI Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${NullJavaAI_SRC}/data/&quot;
+			DESTINATION &quot;${NullJavaAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	file(REMOVE_RECURSE &quot;${NullJavaAI_SRC}/build&quot;)
 	file(MAKE_DIRECTORY &quot;${NullJavaAI_SRC}/build&quot;)
 	file(GLOB_RECURSE NullJavaAI_JAVA_SOURCES RELATIVE &quot;${NullJavaAI_SRC}&quot; FOLLOW_SYMLINKS &quot;${NullJavaAI_SRC}*.java&quot;)
@@ -200,10 +204,6 @@
 		WORKING_DIRECTORY &quot;${NullJavaAI_SRC}&quot;
 		COMMENT &quot;  Creating Java AI library ai.jar&quot; VERBATIM)
 
-	install (FILES ${NullJavaAI_SRC}/AIInfo.lua DESTINATION ${NullJavaAI_DATA_DIR})
-	if (EXISTS ${NullJavaAI_SRC}/AIOptions.lua)
-		install (FILES ${NullJavaAI_SRC}/AIOptions.lua DESTINATION ${NullJavaAI_DATA_DIR})
-	endif (EXISTS ${NullJavaAI_SRC}/AIOptions.lua)
 	install (FILES ${NullJavaAI_SRC}/ai.jar DESTINATION ${NullJavaAI_DATA_DIR})
 endif (JAVA_FOUND AND EXISTS ${NullJavaAI_SRC})
 
@@ -226,6 +226,10 @@
 	set(NullOOJavaAI_CLASSPATH &quot;.${PATH_DELIM}${Java_AIINTERFACE_SRC}/interface.jar${PATH_DELIM}${Java_AIINTERFACE_SRC}/jlib/jna/jna.jar${PATH_DELIM}${Java_AIINTERFACE_SRC}/jlib/vecmath.jar&quot;)
 	message(STATUS &quot;${NullOOJavaAI_VERS}\t(NullOOJavaAI Version)&quot;)
 
+	# install data files
+	install(DIRECTORY &quot;${NullOOJavaAI_SRC}/data/&quot;
+			DESTINATION &quot;${NullOOJavaAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 	file(REMOVE_RECURSE &quot;${NullOOJavaAI_SRC}/build&quot;)
 	file(MAKE_DIRECTORY &quot;${NullOOJavaAI_SRC}/build&quot;)
 	file(GLOB_RECURSE NullOOJavaAI_JAVA_SOURCES RELATIVE &quot;${NullOOJavaAI_SRC}&quot; FOLLOW_SYMLINKS &quot;${NullOOJavaAI_SRC}*.java&quot;)
@@ -243,10 +247,6 @@
 		WORKING_DIRECTORY &quot;${NullOOJavaAI_SRC}&quot;
 		COMMENT &quot;  Creating Java OO AI library ai.jar&quot; VERBATIM)
 
-	install (FILES ${NullOOJavaAI_SRC}/AIInfo.lua DESTINATION ${NullOOJavaAI_DATA_DIR})
-	if (EXISTS ${NullOOJavaAI_SRC}/AIOptions.lua)
-		install (FILES ${NullOOJavaAI_SRC}/AIOptions.lua DESTINATION ${NullOOJavaAI_DATA_DIR})
-	endif (EXISTS ${NullOOJavaAI_SRC}/AIOptions.lua)
 	install (FILES ${NullOOJavaAI_SRC}/ai.jar DESTINATION ${NullOOJavaAI_DATA_DIR})
 endif (JAVA_FOUND AND EXISTS ${NullOOJavaAI_SRC})
 
@@ -264,12 +264,12 @@
 		set(JCAI_DATA_DIR ${SKIRMISH_DATA}/JCAI/${JCAI_VERS})
 		message(STATUS &quot;${JCAI_VERS}\t(JCAI Version)&quot;)
 
+		# install data files
+		#install(DIRECTORY &quot;${JCAI_SRC}/data/&quot;
+		#		DESTINATION &quot;${JCAI_DATA_DIR}&quot; PATTERN &quot;.svn&quot; EXCLUDE)
+
 		aux_source_directory(${JCAI_SRC} jcai)
 		#add_library(${JCAI_TARGET} MODULE ${jcai} ${legacycppaienv})
-		#install (FILES ${JCAI_SRC}/AIInfo.lua DESTINATION ${JCAI_DATA_DIR})
-		#if (EXISTS ${JCAI_SRC}/AIOptions.lua)
-		#	install (FILES ${JCAI_SRC}/AIOptions.lua DESTINATION ${JCAI_DATA_DIR})
-		#endif (EXISTS ${JCAI_SRC}/AIOptions.lua)
 		#install (TARGETS ${JCAI_TARGET} DESTINATION ${JCAI_DATA_DIR})
 	endif (EXISTS ${JCAI_SRC})
 endif (UNIX)

Deleted: branches/caiinterface/AI/Skirmish/KAIK/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/AIInfo.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,63 +0,0 @@
---
---  Info Definition Table format
---
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
---            SSAILibrary.h
---  value:    the value of the property
---  desc:     the description (could be used as a tooltip)
---
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local infos = {
-	{
-		key    = 'fileName',
-		value  = 'KAIK-0.13',
-		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
-	},
-	{
-		key    = 'shortName',
-		value  = 'KAIK',
-		desc   = 'machine conform name.',
-	},
-	{
-		key    = 'version',
-		value  = '0.13',
-	},
-	{
-		key    = 'name',
-		value  = 'Kloots Skirmish AI (KAIK)',
-		desc   = 'human readable name.',
-	},
-	{
-		key    = 'description',
-		value  = 'Competetive AI that supports most TA based Mods and plays decently.',
-		desc   = 'tooltip.',
-	},
-	{
-		key    = 'url',
-		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:KAIK">http://spring.clan-sy.com/wiki/AI:KAIK</A>',
-		desc   = 'URL with more detailed info about the AI',
-	},
-	{
-		key    = 'loadSupported',
-		value  = 'no',
-		desc   = 'whether this AI supports loading or not',
-	},
-	{
-		key    = 'interfaceShortName',
-		value  = 'C',
-		desc   = 'the shortName of the AI interface this AI needs',
-	},
-	{
-		key    = 'interfaceVersion',
-		value  = '0.1',
-		desc   = 'the minimum version of the AI interface this AI needs',
-	},
-}
-
-return infos

Deleted: branches/caiinterface/AI/Skirmish/KAIK/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/AIOptions.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/KAIK/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,37 +0,0 @@
---
---  Custom Options Definition Table format
---
---  NOTES:
---  - using an enumerated table lets you specify the options order
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      the string used in the script.txt
---  name:     the displayed name
---  desc:     the description (could be used as a tooltip)
---  type:     the option type
---  def:      the default value;
---  min:      minimum value for number options
---  max:      maximum value for number options
---  step:     quantization step, aligned to the def value
---  maxlen:   the maximum string length for string options
---  items:    array of item strings for list options
---  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local options = {
-	{
-		key=&quot;difficulty&quot;,
-		name=&quot;AI Difficulty Level&quot;,
-		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
-		type   = 'number',
-		def    = 3,
-		min    = 1,
-		max    = 5,
-		step   = 1,
-	},
-}
-
-return options

Copied: branches/caiinterface/AI/Skirmish/KAIK/data/AIInfo.lua (from rev 7097, branches/caiinterface/AI/Skirmish/KAIK/AIInfo.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/data/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK/data/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'KAIK-0.13',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'KAIK',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.13',
+	},
+	{
+		key    = 'name',
+		value  = 'Kloots Skirmish AI (KAIK)',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'Competetive AI that supports most TA based Mods and plays decently.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:KAIK">http://spring.clan-sy.com/wiki/AI:KAIK</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/KAIK/data/AIInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/KAIK/data/AIOptions.lua (from rev 7097, branches/caiinterface/AI/Skirmish/KAIK/AIOptions.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/KAIK/data/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/KAIK/data/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/KAIK/data/AIOptions.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Deleted: branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,63 +0,0 @@
---
---  Info Definition Table format
---
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
---            SSAILibrary.h
---  value:    the value of the property
---  desc:     the description (could be used as a tooltip)
---
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local infos = {
-	{
-		key    = 'fileName',
-		value  = 'NullAI-0.1',
-		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
-	},
-	{
-		key    = 'shortName',
-		value  = 'NullAI',
-		desc   = 'machine conform name.',
-	},
-	{
-		key    = 'version',
-		value  = '0.1',
-	},
-	{
-		key    = 'name',
-		value  = 'Test AI using the new C interface',
-		desc   = 'human readable name.',
-	},
-	{
-		key    = 'description',
-		value  = 'This AI does absolutely nothing.',
-		desc   = 'tooltip.',
-	},
-	{
-		key    = 'url',
-		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:NullAI">http://spring.clan-sy.com/wiki/AI:NullAI</A>',
-		desc   = 'URL with more detailed info about the AI',
-	},
-	{
-		key    = 'loadSupported',
-		value  = 'no',
-		desc   = 'whether this AI supports loading or not',
-	},
-	{
-		key    = 'interfaceShortName',
-		value  = 'C',
-		desc   = 'the shortName of the AI interface this AI needs',
-	},
-	{
-		key    = 'interfaceVersion',
-		value  = '0.1',
-		desc   = 'the minimum version of the AI interface this AI needs',
-	},
-}
-
-return infos

Copied: branches/caiinterface/AI/Skirmish/NullAI/data/AIInfo.lua (from rev 7097, branches/caiinterface/AI/Skirmish/NullAI/AIInfo.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/NullAI/data/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullAI/data/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'NullAI-0.1',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'NullAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'name',
+		value  = 'Test AI using the new C interface',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'This AI does absolutely nothing.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:NullAI">http://spring.clan-sy.com/wiki/AI:NullAI</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/NullAI/data/AIInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullJavaAI/VERSION
===================================================================
--- branches/caiinterface/AI/Skirmish/NullJavaAI/VERSION	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullJavaAI/VERSION	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1 @@
+0.1
\ No newline at end of file


Property changes on: branches/caiinterface/AI/Skirmish/NullJavaAI/VERSION
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,53 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'shortName',
+		value  = 'NullJavaAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'className',
+		value  = 'nulljavaai.NullJavaAI',
+		desc   = 'fully qualified name of a class that implements interface com.clan_sy.spring.ai.AI',
+	},
+	{
+		key    = 'name',
+		value  = 'low-level Java test Skirmish AI',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'Java',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface required by this AI',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/NullJavaAI/data/AIOptions.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Skirmish/NullJavaAI/manifest.mf
===================================================================
--- branches/caiinterface/AI/Skirmish/NullJavaAI/manifest.mf	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullJavaAI/manifest.mf	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+


Property changes on: branches/caiinterface/AI/Skirmish/NullJavaAI/manifest.mf
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java
===================================================================
--- branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,201 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package nulljavaai;
+
+
+import com.clan_sy.spring.ai.*;
+import com.clan_sy.spring.ai.event.*;
+import com.clan_sy.spring.ai.command.*;
+
+import com.sun.jna.Pointer;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Properties;
+import java.util.Set;
+import java.util.logging.*;
+
+/**
+ * Serves as Interface for a Java Skirmish AIs for the Spring engine.
+ *
+ * @author	hoijui
+ * @version	0.1
+ */
+public class NullJavaAI implements AI {
+
+	private int teamId = -1;
+	private AICallback clb = null;
+	private String myDataDir = null;
+	private String myLogFile = null;
+	private Logger log = null;
+
+	private static class MyCustomLogFormatter extends Formatter {
+
+		private DateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss:SSS dd.MM.yyyy&quot;);
+
+		public String format(LogRecord record) {
+
+			// Create a StringBuffer to contain the formatted record
+			// start with the date.
+			StringBuffer sb = new StringBuffer();
+
+			// Get the date from the LogRecord and add it to the buffer
+			Date date = new Date(record.getMillis());
+			sb.append(dateFormat.format(date));
+			sb.append(&quot; &quot;);
+
+			// Get the level name and add it to the buffer
+			sb.append(record.getLevel().getName());
+			sb.append(&quot;: &quot;);
+
+			// Get the formatted message (includes localization
+			// and substitution of paramters) and add it to the buffer
+			sb.append(formatMessage(record));
+			sb.append(&quot;\n&quot;);
+
+			return sb.toString();
+		}
+	}
+
+	public static boolean isDebugging() {
+		return true;
+	}
+
+
+	public  NullJavaAI() {}
+	
+	public int init(int teamId, Properties info, Properties options) {
+
+		int ret = -1;
+
+		// initialize the log
+		try {
+			myDataDir = info.getProperty(&quot;dataDir&quot;);
+			//myLogFile = &quot;/home/robin/NullJavaAI_test_log.txt&quot;;
+			myLogFile = myDataDir + &quot;/log.txt&quot;;
+			FileHandler fileLogger = new FileHandler(myLogFile, false);
+			fileLogger.setFormatter(new MyCustomLogFormatter());
+			fileLogger.setLevel(Level.ALL);
+			log = Logger.getLogger(&quot;nulljavaai&quot;);
+			if (isDebugging()) {
+				log.setLevel(Level.ALL);
+			} else {
+				log.setLevel(Level.INFO);
+			}
+			log.addHandler(fileLogger);
+		} catch (Exception ex) {
+			System.out.println(&quot;NullJavaAI: Failed initializing the logger!&quot;);
+			ex.printStackTrace();
+			ret = -2;
+		}
+
+		try {
+			log.info(&quot;initializing team &quot; + teamId);
+
+			log.info(&quot;info (items: &quot; + info.size() + &quot;) ...&quot;);
+			Set&lt;String&gt; infoKeys = info.stringPropertyNames();
+			for (String infoKey : infoKeys) {
+				log.info(infoKey + &quot; = &quot; + info.getProperty(infoKey));
+			}
+
+			log.info(&quot;options (items: &quot; + options.size() + &quot;) ...&quot;);
+			Set&lt;String&gt; optionsKeys = options.stringPropertyNames();
+			for (String optionsKey : optionsKeys) {
+				log.info(optionsKey + &quot; = &quot; + options.getProperty(optionsKey));
+			}
+
+			ret = 0;
+		} catch (Exception ex) {
+			log.log(Level.SEVERE, &quot;Failed initializing&quot;, ex);
+			ret = -3;
+		}
+
+		return ret;
+	}
+
+	public int release(int teamId) {
+
+		int ret = -1;
+
+		try {
+			log.info(&quot;releasing team &quot; + teamId);
+
+			ret = 0;
+		} catch (Exception ex) {
+			log.log(Level.WARNING, &quot;Failed releasing&quot;, ex);
+			ret = -2;
+		}
+
+		return ret;
+	}
+
+	public int handleEvent(int teamId, int topic, Pointer event) {
+
+		if (log == null) {
+			System.out.println(&quot;out is still null&quot;);
+			System.exit(-1);
+		}
+		log.finest(&quot;handleEvent topic: &quot; + topic);
+		try {
+			if (topic == InitAIEvent.TOPIC) {
+				//InitAIEvent evt = InitAIEvent.getInstance(event);
+				//DefaultInitAIEvent evt = new DefaultInitAIEvent(event);
+				InitAIEvent evt = new InitAIEvent(event);
+				log.info(&quot;handleEvent:InitAIEvent&quot;);
+				this.teamId = evt.team;
+				clb = evt.callback;
+				log.info(&quot;handleEvent:InitAIEvent:team: &quot; + evt.team);
+				log.info(&quot;handleEvent:InitAIEvent:sizeOptions: &quot; + evt.options.size());
+				log.info(&quot;handleEvent:InitAIEvent:options:&quot;);
+//				Pointer[] pKeys = evt.optionKeys.getPointerArray(0L, evt.sizeOptions);
+//				Pointer[] pValues = evt.optionValues.getPointerArray(0L, evt.sizeOptions);
+//				Properties options = new Properties();
+//				for (int i = 0; i &lt; evt.sizeOptions; i++) {
+//					options.setProperty(pKeys[i].getString(0L), pValues[i].getString(0L));
+//				}
+				Set&lt;String&gt; optionsKeys = evt.options.stringPropertyNames();
+				for (String optionsKey : optionsKeys) {
+					log.info(optionsKey + &quot; = &quot; + evt.options.getProperty(optionsKey));
+				}
+				log.info(&quot;handleEvent:InitAIEvent:stored&quot;);
+			} else if (topic == UpdateAIEvent.TOPIC) {
+				UpdateAIEvent evt = new UpdateAIEvent(event);
+				log.finer(&quot;handleEvent UpdateAIEvent event ...&quot;);
+				log.finer(&quot;frame: &quot; + evt.frame);
+			} else {
+				if (clb != null) {
+					log.finer(&quot;handleEvent UNKNOWN event: fetching frame...&quot;);
+					int frame = clb.Clb_Game_getCurrentFrame(teamId);
+					log.finer(&quot;handleEvent UNKNOWN event: frame is: &quot; + frame);
+					log.finer(&quot;handleEvent UNKNOWN event: sending chat msg...&quot;);
+					SendTextMessageAICommand cmd = new SendTextMessageAICommand();
+					cmd.text = &quot;Hello Engine (from NullJavaAI.java)&quot;;
+					cmd.zone = 0;
+					cmd.write();
+					int ret = clb.Clb_handleCommand(teamId, 0, -1, cmd.getTopic(), cmd.getPointer());
+					log.finer(&quot;handleEvent UNKNOWN event: sending chat msg return: &quot; + ret);
+				}
+			}
+		} catch (Exception ex) {
+			log.log(Level.WARNING, &quot;Failed handling event&quot;, ex);
+			return -1;
+		}
+
+		return 0;
+	}
+}


Property changes on: branches/caiinterface/AI/Skirmish/NullJavaAI/nulljavaai/NullJavaAI.java
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIInfo.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,63 +0,0 @@
---
---  Info Definition Table format
---
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
---            SSAILibrary.h
---  value:    the value of the property
---  desc:     the description (could be used as a tooltip)
---
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local infos = {
-	{
-		key    = 'fileName',
-		value  = 'NullLegacyCppAI-0.1',
-		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
-	},
-	{
-		key    = 'shortName',
-		value  = 'NullLegacyCppAI',
-		desc   = 'machine conform name.',
-	},
-	{
-		key    = 'version',
-		value  = '0.1',
-	},
-	{
-		key    = 'name',
-		value  = 'Test AI using the new C interface and the legacy C++ wrapper',
-		desc   = 'human readable name.',
-	},
-	{
-		key    = 'description',
-		value  = 'This AI does absolutely nothing.',
-		desc   = 'tooltip.',
-	},
-	{
-		key    = 'url',
-		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:TestSkirmishAI">http://spring.clan-sy.com/wiki/AI:TestSkirmishAI</A>',
-		desc   = 'URL with more detailed info about the AI',
-	},
-	{
-		key    = 'loadSupported',
-		value  = 'no',
-		desc   = 'whether this AI supports loading or not',
-	},
-	{
-		key    = 'interfaceShortName',
-		value  = 'C',
-		desc   = 'the shortName of the AI interface this AI needs',
-	},
-	{
-		key    = 'interfaceVersion',
-		value  = '0.1',
-		desc   = 'the minimum version of the AI interface this AI needs',
-	},
-}
-
-return infos

Deleted: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIOptions.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,37 +0,0 @@
---
---  Custom Options Definition Table format
---
---  NOTES:
---  - using an enumerated table lets you specify the options order
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      the string used in the script.txt
---  name:     the displayed name
---  desc:     the description (could be used as a tooltip)
---  type:     the option type
---  def:      the default value;
---  min:      minimum value for number options
---  max:      maximum value for number options
---  step:     quantization step, aligned to the def value
---  maxlen:   the maximum string length for string options
---  items:    array of item strings for list options
---  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local options = {
-	{
-		key=&quot;difficulty&quot;,
-		name=&quot;AI Difficulty Level&quot;,
-		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
-		type   = 'number',
-		def    = 3,
-		min    = 1,
-		max    = 5,
-		step   = 1,
-	},
-}
-
-return options

Copied: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIInfo.lua (from rev 7097, branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIInfo.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'NullLegacyCppAI-0.1',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'NullLegacyCppAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'name',
+		value  = 'Test AI using the new C interface and the legacy C++ wrapper',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'This AI does absolutely nothing.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:TestSkirmishAI">http://spring.clan-sy.com/wiki/AI:TestSkirmishAI</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIOptions.lua (from rev 7097, branches/caiinterface/AI/Skirmish/NullLegacyCppAI/AIOptions.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/NullLegacyCppAI/data/AIOptions.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullOOJavaAI/VERSION
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/VERSION	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/VERSION	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1 @@
+0.1
\ No newline at end of file


Property changes on: branches/caiinterface/AI/Skirmish/NullOOJavaAI/VERSION
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,53 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'shortName',
+		value  = 'NullOOJavaAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.1',
+	},
+	{
+		key    = 'className',
+		value  = 'nulloojavaai.NullOOJavaAIFactory',
+		desc   = 'fully qualified name of a class that implements interface com.clan_sy.spring.ai.AI',
+	},
+	{
+		key    = 'name',
+		value  = 'low-level Java test Skirmish AI',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'Java',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface required by this AI',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/NullOOJavaAI/data/AIOptions.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 

Added: branches/caiinterface/AI/Skirmish/NullOOJavaAI/manifest.mf
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/manifest.mf	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/manifest.mf	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,2 @@
+Manifest-Version: 1.0
+


Property changes on: branches/caiinterface/AI/Skirmish/NullOOJavaAI/manifest.mf
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,274 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package nulloojavaai;
+
+
+import com.clan_sy.spring.ai.AICommand;
+import com.clan_sy.spring.ai.command.*;
+import com.clan_sy.spring.ai.AIFloat3;
+import com.clan_sy.spring.ai.oo.*;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Properties;
+import java.util.ArrayList;
+import java.util.logging.*;
+
+/**
+ * Serves as Interface for a Java Skirmish AIs for the Spring engine.
+ *
+ * @author	hoijui
+ * @version	0.1
+ */
+public class NullOOJavaAI extends AbstractOOAI implements OOAI {
+
+	private static class MyCustomLogFormatter extends Formatter {
+
+		private DateFormat dateFormat = new SimpleDateFormat(&quot;HH:mm:ss:SSS dd.MM.yyyy&quot;);
+
+		public String format(LogRecord record) {
+
+			// Create a StringBuffer to contain the formatted record
+			// start with the date.
+			StringBuffer sb = new StringBuffer();
+
+			// Get the date from the LogRecord and add it to the buffer
+			Date date = new Date(record.getMillis());
+			sb.append(dateFormat.format(date));
+			sb.append(&quot; &quot;);
+
+			// Get the level name and add it to the buffer
+			sb.append(record.getLevel().getName());
+			sb.append(&quot;: &quot;);
+
+			// Get the formatted message (includes localization
+			// and substitution of paramters) and add it to the buffer
+			sb.append(formatMessage(record));
+			sb.append(&quot;\n&quot;);
+
+			return sb.toString();
+		}
+	}
+
+	private static void logProperties(Logger log, Level level, Properties props) {
+
+		log.log(level, &quot;properties (items: &quot; + props.size() + &quot;):&quot;);
+		for (String key : props.stringPropertyNames()) {
+			log.log(level, key + &quot; = &quot; + props.getProperty(key));
+		}
+	}
+
+	private int teamId = -1;
+	private Properties info = null;
+	private Properties options = null;
+	private OOAICallback clb = null;
+	private String myDataDir = null;
+	private String myLogFile = null;
+	private Logger log = null;
+
+	private static final int DEFAULT_ZONE = 0;
+
+
+	NullOOJavaAI(int teamId, Properties info, Properties options) {
+
+		this.teamId = teamId;
+		this.info = info;
+		this.options = options;
+	}
+
+	private int handleEngineCommand(AICommand command) {
+		return clb.handleCommand(
+				com.clan_sy.spring.ai.AICommandWrapper.COMMAND_TO_ID_ENGINE,
+				-1, command);
+	}
+	private int sendTextMsg(String msg) {
+
+		SendTextMessageAICommand msgCmd
+				= new SendTextMessageAICommand(msg, DEFAULT_ZONE);
+		return handleEngineCommand(msgCmd);
+	}
+
+	@Override
+	public int init(int teamId, OOAICallback callback, Properties info,
+			Properties options) {
+
+		int ret = -1;
+
+		// initialize the log
+		try {
+			myDataDir = info.getProperty(&quot;dataDir&quot;);
+			//myLogFile = &quot;/home/robin/NullJavaAI_test_log.txt&quot;;
+			myLogFile = myDataDir + &quot;/log.txt&quot;;
+			FileHandler fileLogger = new FileHandler(myLogFile, false);
+			fileLogger.setFormatter(new MyCustomLogFormatter());
+			fileLogger.setLevel(Level.ALL);
+			log = Logger.getLogger(&quot;nulloojavaai&quot;);
+			log.addHandler(fileLogger);
+			if (NullOOJavaAIFactory.isDebugging()) {
+				log.setLevel(Level.ALL);
+			} else {
+				log.setLevel(Level.INFO);
+			}
+		} catch (Exception ex) {
+			System.out.println(&quot;NullOOJavaAI: Failed initializing the logger!&quot;);
+			ex.printStackTrace();
+			ret = -2;
+		}
+
+		this.clb = callback;
+
+		try {
+			log.info(&quot;initializing team &quot; + teamId);
+
+			log.log(Level.FINE, &quot;info:&quot;);
+			logProperties(log, Level.FINE, info);
+
+			log.log(Level.FINE, &quot;options:&quot;);
+			logProperties(log, Level.FINE, options);
+
+			ret = 0;
+		} catch (Exception ex) {
+			log.log(Level.SEVERE, &quot;Failed initializing&quot;, ex);
+			ret = -3;
+		}
+
+		return ret;
+	}
+
+	@Override
+	public int update(int frame) {
+
+		if (frame % 300 == 0) {
+			ArrayList&lt;Resource&gt; resources = clb.getResources();
+			for (Resource resource : resources) {
+				sendTextMsg(&quot;Resource &quot; + resource.getName() + &quot; optimum: &quot;
+						+ resource.getOptimum());
+				sendTextMsg(&quot;Resource &quot; + resource.getName() + &quot; current: &quot;
+						+ clb.getEconomy().getCurrent(resource));
+				sendTextMsg(&quot;Resource &quot; + resource.getName() + &quot; income: &quot;
+						+ clb.getEconomy().getIncome(resource));
+				sendTextMsg(&quot;Resource &quot; + resource.getName() + &quot; storage: &quot;
+						+ clb.getEconomy().getStorage(resource));
+				sendTextMsg(&quot;Resource &quot; + resource.getName() + &quot; usage: &quot;
+						+ clb.getEconomy().getUsage(resource));
+			}
+		}
+
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int message(int player, String message) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitCreated(Unit unit) {
+
+		int ret = sendTextMsg(&quot;unitCreated: &quot; + unit.getDef().getName());
+
+		return ret;
+	}
+
+	@Override
+	public int unitFinished(Unit unit) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitIdle(Unit unit) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitMoveFailed(Unit unit) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitDamaged(Unit unit, Unit attacker, float damage, AIFloat3 dir) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitDestroyed(Unit unit, Unit attacker) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitGiven(Unit unit, int oldTeamId, int newTeamId) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int unitCaptured(Unit unit, int oldTeamId, int newTeamId) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int enemyEnterLOS(Unit enemy) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int enemyLeaveLOS(Unit enemy) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int enemyEnterRadar(Unit enemy) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int enemyLeaveRadar(Unit enemy) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int enemyDamaged(Unit enemy, Unit attacker, float damage, AIFloat3 dir) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int enemyDestroyed(Unit enemy, Unit attacker) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int weaponFired(Unit unit, WeaponDef weaponDef) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int playerCommand(ArrayList&lt;Unit&gt; units, AICommand command, int playerId) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int commandFinished(Unit unit, int commandTopicId) {
+		return 0; // signaling: OK
+	}
+
+	@Override
+	public int seismicPing(AIFloat3 pos, float strength) {
+		return 0; // signaling: OK
+	}
+
+}


Property changes on: branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAI.java
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAIFactory.java
===================================================================
--- branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAIFactory.java	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAIFactory.java	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,43 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+package nulloojavaai;
+
+
+import com.clan_sy.spring.ai.oo.*;
+
+import java.util.Properties;
+
+/**
+ * Serves as Interface for a Java Skirmish AIs for the Spring engine.
+ *
+ * @author	hoijui
+ * @version	0.1
+ */
+public class NullOOJavaAIFactory extends OOAIFactory {
+
+	public NullOOJavaAIFactory() {}
+
+	public static boolean isDebugging() {
+		return true;
+	}
+
+	@Override
+	public OOAI createAI(int teamId, Properties info, Properties options) {
+		return new NullOOJavaAI(teamId, info, options);
+	}
+}


Property changes on: branches/caiinterface/AI/Skirmish/NullOOJavaAI/nulloojavaai/NullOOJavaAIFactory.java
___________________________________________________________________
Name: svn:eol-style
   + native

Deleted: branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,63 +0,0 @@
---
---  Info Definition Table format
---
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
---            SSAILibrary.h
---  value:    the value of the property
---  desc:     the description (could be used as a tooltip)
---
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local infos = {
-	{
-		key    = 'fileName',
-		value  = 'RAI-0.601',
-		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
-	},
-	{
-		key    = 'shortName',
-		value  = 'RAI',
-		desc   = 'machine conform name.',
-	},
-	{
-		key    = 'version',
-		value  = '0.601',
-	},
-	{
-		key    = 'name',
-		value  = 'Reths Skirmish AI (RAI)',
-		desc   = 'human readable name.',
-	},
-	{
-		key    = 'description',
-		value  = 'Competetive AI that supports most Mods, also non TA ones.',
-		desc   = 'tooltip.',
-	},
-	{
-		key    = 'url',
-		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:RAI">http://spring.clan-sy.com/wiki/AI:RAI</A>',
-		desc   = 'URL with more detailed info about the AI',
-	},
-	{
-		key    = 'loadSupported',
-		value  = 'no',
-		desc   = 'whether this AI supports loading or not',
-	},
-	{
-		key    = 'interfaceShortName',
-		value  = 'C',
-		desc   = 'the shortName of the AI interface this AI needs',
-	},
-	{
-		key    = 'interfaceVersion',
-		value  = '0.1',
-		desc   = 'the minimum version of the AI interface this AI needs',
-	},
-}
-
-return infos

Deleted: branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -1,37 +0,0 @@
---
---  Custom Options Definition Table format
---
---  NOTES:
---  - using an enumerated table lets you specify the options order
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      the string used in the script.txt
---  name:     the displayed name
---  desc:     the description (could be used as a tooltip)
---  type:     the option type
---  def:      the default value;
---  min:      minimum value for number options
---  max:      maximum value for number options
---  step:     quantization step, aligned to the def value
---  maxlen:   the maximum string length for string options
---  items:    array of item strings for list options
---  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
---
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
-local options = {
-	{
-		key=&quot;difficulty&quot;,
-		name=&quot;AI Difficulty Level&quot;,
-		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
-		type   = 'number',
-		def    = 3,
-		min    = 1,
-		max    = 5,
-		step   = 1,
-	},
-}
-
-return options

Copied: branches/caiinterface/AI/Skirmish/RAI/data/AIInfo.lua (from rev 7097, branches/caiinterface/AI/Skirmish/RAI/AIInfo.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/data/AIInfo.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/data/AIInfo.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,63 @@
+--
+--  Info Definition Table format
+--
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      user defined or one of the SKIRMISH_AI_PROPERTY_* defines in
+--            SSAILibrary.h
+--  value:    the value of the property
+--  desc:     the description (could be used as a tooltip)
+--
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local infos = {
+	{
+		key    = 'fileName',
+		value  = 'RAI-0.601',
+		desc   = 'base of the library file of this AI. &quot;RAI-0.553&quot; means &quot;AI/Skirmish/lib/libRAI-0.553.so&quot;, &quot;AI/Skirmish/lib/libRAI-0.553.dylib&quot; or &quot;AI/Skirmish/lib/RAI-0.553.dll&quot;',
+	},
+	{
+		key    = 'shortName',
+		value  = 'RAI',
+		desc   = 'machine conform name.',
+	},
+	{
+		key    = 'version',
+		value  = '0.601',
+	},
+	{
+		key    = 'name',
+		value  = 'Reths Skirmish AI (RAI)',
+		desc   = 'human readable name.',
+	},
+	{
+		key    = 'description',
+		value  = 'Competetive AI that supports most Mods, also non TA ones.',
+		desc   = 'tooltip.',
+	},
+	{
+		key    = 'url',
+		value  = '<A HREF="http://spring.clan-sy.com/wiki/AI:RAI">http://spring.clan-sy.com/wiki/AI:RAI</A>',
+		desc   = 'URL with more detailed info about the AI',
+	},
+	{
+		key    = 'loadSupported',
+		value  = 'no',
+		desc   = 'whether this AI supports loading or not',
+	},
+	{
+		key    = 'interfaceShortName',
+		value  = 'C',
+		desc   = 'the shortName of the AI interface this AI needs',
+	},
+	{
+		key    = 'interfaceVersion',
+		value  = '0.1',
+		desc   = 'the minimum version of the AI interface this AI needs',
+	},
+}
+
+return infos


Property changes on: branches/caiinterface/AI/Skirmish/RAI/data/AIInfo.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Copied: branches/caiinterface/AI/Skirmish/RAI/data/AIOptions.lua (from rev 7097, branches/caiinterface/AI/Skirmish/RAI/AIOptions.lua)
===================================================================
--- branches/caiinterface/AI/Skirmish/RAI/data/AIOptions.lua	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/RAI/data/AIOptions.lua	2008-12-05 16:12:49 UTC (rev 7129)
@@ -0,0 +1,37 @@
+--
+--  Custom Options Definition Table format
+--
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type
+--  def:      the default value;
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local options = {
+	{
+		key=&quot;difficulty&quot;,
+		name=&quot;AI Difficulty Level&quot;,
+		desc=&quot;1 means, the AI plays very poor, 5 means, it gives its best&quot;,
+		type   = 'number',
+		def    = 3,
+		min    = 1,
+		max    = 5,
+		step   = 1,
+	},
+}
+
+return options


Property changes on: branches/caiinterface/AI/Skirmish/RAI/data/AIOptions.lua
___________________________________________________________________
Name: svn:mergeinfo
   + 
Name: svn:eol-style
   + native

Modified: branches/caiinterface/SConstruct
===================================================================
--- branches/caiinterface/SConstruct	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/SConstruct	2008-12-05 16:12:49 UTC (rev 7129)
@@ -213,16 +213,40 @@
 	libName = interfaceName + '-' + fetch_ai_version(interfaceName, 'Interfaces')
 	return libName
 
-## appends the version to the end of the Skirmish AI name
-#def construct_skirmishai_libName(aiName):
-#	libName = aiName + '-' + fetch_ai_version(aiName, 'Skirmish')
-#	return libName
-#
-## appends the version to the end of the Group AI name
-#def construct_groupai_libName(aiName):
-#	libName = aiName + '-' + fetch_ai_version(aiName, 'Group')
-#	return libName
+#regexSvn = re.compile('.*\.svn.*')
+#def pathContainsSvnDir(path):
+#	#if regexSvn.match(path):
+#	#	print('contains .svn: 1 ' + path)
+#	#else:
+#	#	print('contains .svn: 0 ' + path)
+#	return regexSvn.match(path)
 
+def getLocalShellExecPostfix():
+	#print('sys.platform: ' + sys.platform)
+	if sys.platform == 'win32' or sys.platform == 'win64':
+		postfix = 'bat'
+	else:
+		postfix = 'sh'
+	return postfix
+
+def createJavaClasspath(path):
+	# helper function to get a list of all subdirectories
+	def addJars(jarList, dirname, names):
+		# internal function to pass to os.path.walk
+		for n in names:
+			f = os.path.join(dirname, n)
+			if os.path.isfile(f) and os.path.splitext(f)[1] == &quot;.jar&quot;:
+				jarList.append(f)
+				#print('found jar: ' + n)
+
+	jarList = []
+	os.path.walk(path, addJars, jarList)
+	clsPath = path
+	for j in jarList:
+		clsPath = clsPath + os.pathsep + j
+	#print('clsPath: ' + clsPath)
+	return clsPath
+
 ################################################################################
 ### Build AI Interface shared objects
 ################################################################################
@@ -237,57 +261,74 @@
 aiinterfaces_exclude_list=['build']
 aiinterfaces_needSharedLib_list=['C']
 aiinterfaces_needStreflop_list=['Java']
+javaInterfaceCP = ''
+javaInterfaceJar = ''
 for baseName in filelist.list_AIInterfaces(aiinterfaceenv, exclude_list=aiinterfaces_exclude_list):
 	aiInterfaceVersion = fetch_ai_version(baseName, 'Interfaces')
 	print &quot;AI Interface: &quot; + baseName + &quot; v&quot; + aiInterfaceVersion
 	myEnv = aiinterfaceenv.Copy()
+	install_data_interface_dir = os.path.join(install_aiinterfaces_dir, baseName, aiInterfaceVersion)
+	instList = []
 	objs = aiinterfaceobjs_main
 	if baseName in aiinterfaces_needSharedLib_list:
 		objs += aiinterfaceobjs_SharedLib
 	if baseName in aiinterfaces_needStreflop_list:
-		myEnv['CPPDEFINES'] += ['-DSTREFLOP_SSE']
+		if env['fpmath'] == 'sse':
+			myEnv['CPPDEFINES'] += ['-DSTREFLOP_SSE']
+		else:
+			myEnv['CPPDEFINES'] += ['-DSTREFLOP_X87']
 		myEnv.Append(CXXFLAGS = ['-Irts/lib/streflop'])
 		myEnv['LIBS'] += ['streflop']
+	mySource = objs + filelist.get_AIInterface_source(myEnv, baseName)
 	if baseName == 'Java':
-		#myEnv['LINKFLAGS'] += ['-ljvm']
-		#myEnv['LINKFLAGS'] += ['mingwlibs/lib/libjvm.dll.a']
-		#objs += ['mingwlibs/lib/libjvm.dll.a']
-		#myEnv['LIBPATH'] += ['mingwlibs/lib']
 		myEnv['LIBS'] += ['jvm']
-	mySource = objs + filelist.get_AIInterface_source(myEnv, baseName)
-	lib = myEnv.SharedLibrary(os.path.join(myEnv['builddir'], 'AI/Interfaces', baseName, aiInterfaceVersion, baseName), mySource)
+		# generate class files
+		javaWrapperScript = 'java_generateWrappers.' + getLocalShellExecPostfix()
+		javaWrapperScriptPath = os.path.join('AI/Interfaces', baseName, 'bin')
+		# TODO: the following was only tested on linux (it is not nice)
+		javaWrapperCmd = 'cd ' + javaWrapperScriptPath + '; ./' + javaWrapperScript + '; cd ../../../..'
+		javaWrapperBld = myEnv.Builder(action = javaWrapperCmd)
+		myEnv.Append(BUILDERS = {'JavaWrapper' : javaWrapperBld})
+		javaSrcGen = myEnv.JavaWrapper(source = mySource)
+		Alias(baseName, javaSrcGen)
+		Alias('AIInterfaces', javaSrcGen)
+		Default(javaSrcGen)
+		# compile the Java part
+		javaSrc = os.path.join('AI/Interfaces', baseName, 'java/src')
+		javaClasses = os.path.join(myEnv['builddir'], 'AI/Interfaces', baseName, aiInterfaceVersion, 'classes')
+		javaJar = os.path.join(myEnv['builddir'], 'AI/Interfaces', baseName, aiInterfaceVersion, 'interface.jar')
+		javaInterfaceJar = javaJar
+		jlibDir = os.path.join('AI/Interfaces', baseName, 'jlib')
+		javaInterfaceCP = createJavaClasspath(jlibDir)
+		myEnv['JAVACLASSPATH'] = javaInterfaceCP
+		myClasses = myEnv.Java(target = javaClasses, source = javaSrc)
+		myEnv['JARCHDIR'] = [javaClasses]
+		myJar = myEnv.Jar(target = javaJar, source = myClasses)
+		Alias(baseName, myJar)
+		Alias('AIInterfaces', myJar)
+		Default(myJar)
+		instList += [env.Install(install_data_interface_dir, myJar)]
+		#jlib_files = os.listdir(jlibDir)
+		#jlib_files = [os.path.join(jlibDir, jl) for jl in jlib_files if not pathContainsSvnDir(jl)]
+		jlib_files = filelist.list_files_recursive(myEnv, jlibDir, exclude_regexp = '\.svn', exclude_dirs = True)
+		instList += [env.Install(install_data_interface_dir, jlib_files)]
+	lib = myEnv.SharedLibrary(os.path.join(myEnv['builddir'], 'AI/Interfaces', baseName, aiInterfaceVersion, baseName + '-' + aiInterfaceVersion), mySource)
 	Alias(baseName, lib)       # Allow e.g. `scons Java' to compile just that specific AI interface.
 	Alias('AIInterfaces', lib) # Allow `scons AIInterfaces' to compile all AI interfaces.
 	Default(lib)
-	install_data_interface_dir = os.path.join(install_aiinterfaces_dir, baseName, aiInterfaceVersion)
-	instList = [myEnv.Install(install_data_interface_dir, lib)]
+	instList += [myEnv.Install(install_data_interface_dir, lib)]
 	if myEnv['strip']:
 		myEnv.AddPostAction(lib, Action([['strip','$TARGET']]))
 	source_data_dir = os.path.join('AI/Interfaces', baseName, 'data')
 	if os.path.exists(source_data_dir):
-		data_files_tmp = os.listdir(source_data_dir)
-		data_files = []
-		for df in data_files_tmp:
-			data_files += [os.path.join(source_data_dir, df)]
+		#data_files = os.listdir(source_data_dir)
+		#data_files = [os.path.join(source_data_dir, df) for df in data_files if df != &quot;.svn&quot;]
+		data_files = filelist.list_files_recursive(myEnv, source_data_dir, exclude_regexp = '\.svn', exclude_dirs = True)
 		instList += [env.Install(install_data_interface_dir, data_files)]
 	Alias('install', instList)
 	Alias('install-AIInterfaces', instList)
 	Alias('install-' + baseName, instList)
 
-# install AI interface info files
-aiinterfaces_data_dirs = filelist.list_directories(env, 'AI/Interfaces', exclude_list=aiinterfaces_exclude_list, recursively=False)
-for f in aiinterfaces_data_dirs:
-	baseName = os.path.basename(f)
-	aiInterfaceVersion = fetch_ai_version(baseName, 'Interfaces')
-	libName = construct_aiinterface_libName(baseName)
-	install_data_interface_dir = os.path.join(install_aiinterfaces_dir, baseName, aiInterfaceVersion)
-	infoFile = os.path.join(f, &quot;InterfaceInfo.lua&quot;)
-	if os.path.exists(infoFile):
-		inst = env.Install(install_data_interface_dir, infoFile)
-		Alias('install', inst)
-		Alias('install-AIInterfaces', inst)
-		Alias('install-' + baseName, inst)
-
 ################################################################################
 ### Build Skirmish AI shared objects
 ################################################################################
@@ -302,68 +343,82 @@
 skirmishaiobjs_LegacyCppCregged = create_shared_objects(skirmishaienv, filelist.get_shared_skirmishAI_source_LegacyCpp(skirmishaienv), '-skirmishai_creg', ['USING_CREG'])
 
 # Build
-skirmishai_exclude_list=['build', 'CSAI', 'TestABICAI', 'AbicWrappersTestAI', 'NullJavaAI', 'NullOOJavaAI']
+skirmishai_exclude_list=['build', 'CSAI', 'TestABICAI', 'AbicWrappersTestAI']
 skirmishai_isLegacyCpp_list=['AAI', 'KAIK', 'RAI', 'NullLegacyCppAI', 'KAI', 'NTai']
 skirmishai_needCreg_list=['KAIK', 'KAI']
+skirmishai_isJava_list=['NullJavaAI', 'NullOOJavaAI']
 for baseName in filelist.list_skirmishAIs(skirmishaienv, exclude_list=skirmishai_exclude_list):
 	aiVersion = fetch_ai_version(baseName, 'Skirmish')
 	print &quot;Skirmish AI: &quot; + baseName + &quot; v&quot; + aiVersion
+	isLegacyCpp = baseName in skirmishai_isLegacyCpp_list
 	useCreg = baseName in skirmishai_needCreg_list
-	isLegacyCpp = baseName in skirmishai_isLegacyCpp_list
+	isJava = baseName in skirmishai_isJava_list
 	myEnv = skirmishaienv.Copy()
-	if useCreg:
-		myEnv['CPPDEFINES'] += ['USING_CREG']
-	objs = []
-	if useCreg:
-		objs += skirmishaiobjs_mainCregged
-		objs += skirmishaiobjs_creg
+	install_data_ai_dir = os.path.join(install_skirmishai_dir, baseName, aiVersion)
+	instList = []
+
+	# create the library
+	if isJava:
+		javaSrc = os.path.join('AI/Skirmish', baseName)
+		javaClasses = os.path.join(myEnv['builddir'], 'AI/Skirmish', baseName, aiVersion, 'classes')
+		javaJar = os.path.join(myEnv['builddir'], 'AI/Skirmish', baseName, aiVersion, 'ai.jar')
+		jlibDir = os.path.join('AI/Skirmish', baseName, 'jlib')
+		aiCP = createJavaClasspath(jlibDir)
+		aiFullCP = aiCP + os.pathsep + javaInterfaceJar + os.pathsep + javaInterfaceCP
+		myEnv['JAVACLASSPATH'] = aiFullCP
+		myClasses = myEnv.Java(target = javaClasses, source = javaSrc)
+		myEnv['JARCHDIR'] = [javaClasses]
+		myJar = myEnv.Jar(target = javaJar, source = myClasses)
+		Alias(baseName, myJar)
+		Alias('SkirmishAI', myJar)
+		Default(myJar)
+		instList += [env.Install(install_data_ai_dir, myJar)]
+		jlib_files = filelist.list_files_recursive(myEnv, jlibDir, exclude_regexp = '\.svn', exclude_dirs = True)
+		instList += [env.Install(install_data_ai_dir, jlib_files)]
 	else:
-		objs += skirmishaiobjs_main
-	if isLegacyCpp:
-		myEnv.Append(CXXFLAGS = ['-IAI/Wrappers'])
 		if useCreg:
-			objs += skirmishaiobjs_LegacyCppCregged
+			myEnv['CPPDEFINES'] += ['USING_CREG']
+		objs = []
+		if useCreg:
+			objs += skirmishaiobjs_mainCregged
+			objs += skirmishaiobjs_creg
 		else:
-			objs += skirmishaiobjs_LegacyCpp
-	mySource = objs + filelist.get_skirmishAI_source(myEnv, baseName)
-	lib = myEnv.SharedLibrary(os.path.join(myEnv['builddir'], 'AI/Skirmish', baseName, aiVersion, baseName), mySource)
-	Alias(baseName, lib)            # Allow e.g. `scons JCAI' to compile just a skirmish AI.
-	Alias('SkirmishAI', lib) # Allow `scons SkirmishAI' to compile all skirmishAIs.
-	Default(lib)
-	install_data_ai_dir = os.path.join(install_skirmishai_dir, baseName, aiVersion)
-	inst = env.Install(install_data_ai_dir, lib)
-	Alias('install', inst)
-	Alias('install-SkirmishAI', inst)
-	Alias('install-'+baseName, inst)
-	if myEnv['strip']:
-		myEnv.AddPostAction(lib, Action([['strip','$TARGET']]))
+			objs += skirmishaiobjs_main
+		if isLegacyCpp:
+			myEnv.Append(CXXFLAGS = ['-IAI/Wrappers'])
+			if useCreg:
+				objs += skirmishaiobjs_LegacyCppCregged
+			else:
+				objs += skirmishaiobjs_LegacyCpp
+		mySource = objs + filelist.get_skirmishAI_source(myEnv, baseName)
+		lib = myEnv.SharedLibrary(os.path.join(myEnv['builddir'], 'AI/Skirmish', baseName, aiVersion, baseName + '-' + aiVersion), mySource)
+		Alias(baseName, lib)     # Allow e.g. `scons JCAI' to compile just a skirmish AI.
+		Alias('SkirmishAI', lib) # Allow `scons SkirmishAI' to compile all skirmishAIs.
+		Default(lib)
+		instList += [env.Install(install_data_ai_dir, lib)]
+		if myEnv['strip']:
+			myEnv.AddPostAction(lib, Action([['strip','$TARGET']]))
 
-# install Skirmish AI info and options files
-skirmishai_data_dirs=filelist.list_directories(env, 'AI/Skirmish', exclude_list=skirmishai_exclude_list, recursively=False)
-for f in skirmishai_data_dirs:
-	baseName = os.path.basename(f)
-	aiVerson = fetch_ai_version(baseName, 'Skirmish')
-	install_data_ai_dir = os.path.join(install_skirmishai_dir, baseName, aiVersion)
-	infoFile = os.path.join(f, &quot;AIInfo.lua&quot;)
-	if os.path.exists(infoFile):
-		inst = env.Install(install_data_ai_dir, infoFile)
-		Alias('install', inst)
-		Alias('install-SkirmishAI', inst)
-		Alias('install-'+baseName, inst)
-	optionsFile = os.path.join(f, &quot;AIOptions.lua&quot;)
-	if os.path.exists(optionsFile):
-		inst = env.Install(install_data_ai_dir, optionsFile)
-		Alias('install', inst)
-		Alias('install-SkirmishAI', inst)
-		Alias('install-'+baseName, inst)
+	# record data files (eg AIInfo.lua or config files) for installation
+	source_data_dir = os.path.join('AI/Skirmish', baseName, 'data')
+	if os.path.exists(source_data_dir):
+		#data_files = os.listdir(source_data_dir)
+		#data_files = [os.path.join(source_data_dir, df) for df in data_files if not pathContainsSvnDir(df)]
+		data_files = filelist.list_files_recursive(myEnv, source_data_dir, exclude_regexp = '\.svn', exclude_dirs = True)
+		instList += [env.Install(install_data_ai_dir, data_files)]
 
-# install AAI config files
-aai_data=filelist.list_files_recursive(env, 'game/AI/AAI')
-for f in aai_data:
-	if not os.path.isdir(f):
-		inst = env.Install(os.path.join(skirmishaienv['installprefix'], skirmishaienv['datadir'], os.path.dirname(f)[5:]), f)
-		Alias('install', inst)
+	# install everything from this AI
+	Alias('install', instList)
+	Alias('install-SkirmishAI', instList)
+	Alias('install-' + baseName, instList)
 
+## install AAI config files
+#aai_data=filelist.list_files_recursive(env, 'game/AI/AAI')
+#for f in aai_data:
+#	if not os.path.isdir(f):
+#		inst = env.Install(os.path.join(skirmishaienv['installprefix'], skirmishaienv['datadir'], os.path.dirname(f)[5:]), f)
+#		Alias('install', inst)
+
 ################################################################################
 ### Build Group AI shared objects
 ################################################################################

Modified: branches/caiinterface/rts/build/scons/filelist.py
===================================================================
--- branches/caiinterface/rts/build/scons/filelist.py	2008-12-05 14:40:33 UTC (rev 7128)
+++ branches/caiinterface/rts/build/scons/filelist.py	2008-12-05 16:12:49 UTC (rev 7129)
@@ -36,7 +36,7 @@
 	return dirs
 
 
-def list_files_recursive(env, path, exclude_list = (), exclude_regexp = '^\.'):
+def list_files_recursive(env, path, exclude_list = (), exclude_regexp = '^\.', exclude_dirs = False):
 	path_stack = [path]
 	exclude = re.compile(exclude_regexp)
 	ffiles = []
@@ -46,7 +46,8 @@
 		for f in files:
 			g = os.path.join(path, f)
 			if os.path.exists(g) and not f in exclude_list and not exclude.search(f):
-				ffiles += [g]
+				if not os.path.isdir(g) or not exclude_dirs:
+					ffiles += [g]
 				if os.path.isdir(g):
 					path_stack += [g]
 	return ffiles


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001897.html">[Taspring-linux-commit] r7128 - trunk/rts/Rendering/GL
</A></li>
	<LI>Next message: <A HREF="001899.html">[Taspring-linux-commit] r7130 - in	branches/caiinterface/AI/Skirmish: . AAI AAI/data	AAI/data/cfg/mod NTai/AI/NTai/Core NTai/data
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1898">[ date ]</a>
              <a href="thread.html#1898">[ thread ]</a>
              <a href="subject.html#1898">[ subject ]</a>
              <a href="author.html#1898">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
