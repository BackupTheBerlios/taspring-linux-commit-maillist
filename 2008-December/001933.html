<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7164 - in branches/caiinterface: .	rts/Game rts/Game/UI rts/Lua rts/Map rts/Map/SMF rts/Sim/Misc	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Weapons rts/System tools/unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7164%20-%20in%20branches/caiinterface%3A%20.%0A%09rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map%20rts/Map/SMF%20rts/Sim/Misc%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/WeaponProjectiles%0A%09rts/Sim/Units%20rts/Sim/Units/COB%20rts/Sim/Units/CommandAI%0A%09rts/Sim/Weapons%20rts/System%20tools/unitsync&In-Reply-To=%3C20081210191127.8524346E9%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001932.html">
   <LINK REL="Next"  HREF="001934.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7164 - in branches/caiinterface: .	rts/Game rts/Game/UI rts/Lua rts/Map rts/Map/SMF rts/Sim/Misc	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Weapons rts/System tools/unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7164%20-%20in%20branches/caiinterface%3A%20.%0A%09rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map%20rts/Map/SMF%20rts/Sim/Misc%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/WeaponProjectiles%0A%09rts/Sim/Units%20rts/Sim/Units/COB%20rts/Sim/Units/CommandAI%0A%09rts/Sim/Weapons%20rts/System%20tools/unitsync&In-Reply-To=%3C20081210191127.8524346E9%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7164 - in branches/caiinterface: .	rts/Game rts/Game/UI rts/Lua rts/Map rts/Map/SMF rts/Sim/Misc	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Weapons rts/System tools/unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Dec 10 20:11:27 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001932.html">[Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels
</A></li>
        <LI>Next message: <A HREF="001934.html">[Taspring-linux-commit] r7165 - in trunk: . rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Units rts/Sim/Units/CommandAI	rts/System rts/System/creg
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1933">[ date ]</a>
              <a href="thread.html#1933">[ thread ]</a>
              <a href="subject.html#1933">[ subject ]</a>
              <a href="author.html#1933">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-10 20:11:25 +0100 (Wed, 10 Dec 2008)
New Revision: 7164

Added:
   branches/caiinterface/rts/Sim/Misc/LosMap.cpp
   branches/caiinterface/rts/Sim/Misc/LosMap.h
Modified:
   branches/caiinterface/SConstruct
   branches/caiinterface/rts/Game/ChatMessage.h
   branches/caiinterface/rts/Game/Game.cpp
   branches/caiinterface/rts/Game/GameHelper.cpp
   branches/caiinterface/rts/Game/GameHelper.h
   branches/caiinterface/rts/Game/GameServer.cpp
   branches/caiinterface/rts/Game/UI/GuiHandler.cpp
   branches/caiinterface/rts/Game/UI/HwMouseCursor.cpp
   branches/caiinterface/rts/Game/UI/MiniMap.cpp
   branches/caiinterface/rts/Lua/LuaSyncedCtrl.cpp
   branches/caiinterface/rts/Lua/LuaSyncedRead.cpp
   branches/caiinterface/rts/Map/BaseGroundDrawer.cpp
   branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp
   branches/caiinterface/rts/Sim/Misc/LosHandler.cpp
   branches/caiinterface/rts/Sim/Misc/LosHandler.h
   branches/caiinterface/rts/Sim/Misc/RadarHandler.cpp
   branches/caiinterface/rts/Sim/Misc/RadarHandler.h
   branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   branches/caiinterface/rts/Sim/Units/COB/CobInstance.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/FactoryCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp
   branches/caiinterface/rts/Sim/Units/Unit.cpp
   branches/caiinterface/rts/Sim/Units/Unit.h
   branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
   branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp
   branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp
   branches/caiinterface/rts/System/LogOutput.cpp
   branches/caiinterface/rts/System/Vec2.h
   branches/caiinterface/rts/System/float3.cpp
   branches/caiinterface/tools/unitsync/unitsync.cpp
Log:
reintegrated trunk up to 7161

Modified: branches/caiinterface/SConstruct
===================================================================
--- branches/caiinterface/SConstruct	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/SConstruct	2008-12-10 19:11:25 UTC (rev 7164)
@@ -36,13 +36,13 @@
 	# force to mingw, otherwise picks up msvc
 	myTools = ['mingw', 'rts', 'gch']
 else:
-	myTools = ['default', 'rts',  'gch']
+	myTools = ['default', 'rts', 'gch']
 
-#env = Environment(tools = myTools, toolpath = ['.', 'rts/build/scons'])
-env = Environment(tools = myTools, toolpath = ['.', 'rts/build/scons'], ENV = {'PATH' : os.environ['PATH']})
+env = Environment(tools = myTools, toolpath = ['.', 'rts/build/scons'])
+#env = Environment(tools = myTools, toolpath = ['.', 'rts/build/scons'], ENV = {'PATH' : os.environ['PATH']})
 
 # the next four lines are needed when compiling on windows
-# (seems ot be some SCons bug)
+# (seems to be a SCons bug)
 import SCons.Tool.javac
 import SCons.Tool.jar
 SCons.Tool.javac.generate(env)
@@ -77,7 +77,7 @@
 	datadir = []
 else:
 	datadir = ['SPRING_DATADIR=&quot;\\&quot;'+os.path.join(env['prefix'], env['datadir'])+'\\&quot;&quot;',
-		   'SPRING_DATADIR_2=&quot;\\&quot;'+os.path.join(env['prefix'], env['libdir'])+'\\&quot;&quot;']
+			'SPRING_DATADIR_2=&quot;\\&quot;'+os.path.join(env['prefix'], env['libdir'])+'\\&quot;&quot;']
 
 # Build DataDirLocater.cpp separately from the other sources.  This is to prevent recompilation of
 # the entire source if one wants to change just the install installprefix (and hence the datadir).
@@ -177,8 +177,8 @@
 ################################################################################
 ### AIs
 ################################################################################
+# Make a copy of the build environment for the AIs, but remove libraries and add include path.
 # TODO: make separate SConstructs for AIs
-# Make a copy of the build environment for the AIs
 aienv = env.Clone()
 aienv.Append(CPPPATH = ['rts/ExternalAI'])
 aienv['LINKFLAGS'] += ['-Wl,--kill-at', '--add-stdcall-alias', '-mno-cygwin', '-lstdc++']
@@ -224,14 +224,6 @@
 	libName = interfaceName + '-' + fetch_ai_version(interfaceName, 'Interfaces')
 	return libName
 
-#regexSvn = re.compile('.*\.svn.*')
-#def pathContainsSvnDir(path):
-#	#if regexSvn.match(path):
-#	#	print('contains .svn: 1 ' + path)
-#	#else:
-#	#	print('contains .svn: 0 ' + path)
-#	return regexSvn.match(path)
-
 def getLocalShellExecPostfix():
 	#print('sys.platform: ' + sys.platform)
 	if sys.platform == 'win32' or sys.platform == 'win64':
@@ -493,6 +485,7 @@
 
 ################################################################################
 ### Build streflop (which has it's own Makefile-based build system)
+################################################################################
 if not 'configure' in sys.argv and not 'test' in sys.argv and not 'install' in sys.argv:
 	cmd = &quot;CC=&quot; + env['CC'] + &quot; CXX=&quot; + env['CXX'] + &quot; --no-print-directory -C rts/lib/streflop&quot;
 	if env.has_key('streflop_extra'):
@@ -533,7 +526,7 @@
 
 
 ################################################################################
-# Build gamedata zip archives
+### Build gamedata zip archives
 ################################################################################
 # Can't use these, we can't set the working directory and putting a SConscript
 # in the respective directories doesn't work either because then the SConstript

Modified: branches/caiinterface/rts/Game/ChatMessage.h
===================================================================
--- branches/caiinterface/rts/Game/ChatMessage.h	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/ChatMessage.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -2,9 +2,8 @@
 #define CHAT_MESSAGE_H
 
 #include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;string&gt;
 
-#include &quot;Action.h&quot;
-
 namespace netcode {
 	class RawPacket;
 }

Modified: branches/caiinterface/rts/Game/Game.cpp
===================================================================
--- branches/caiinterface/rts/Game/Game.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/Game.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1113,7 +1113,13 @@
 				is &gt;&gt; state;
 				if (state &gt;= 0 &amp;&amp; state &lt; 2 &amp;&amp; otherAllyTeam &gt;= 0 &amp;&amp; otherAllyTeam != gu-&gt;myAllyTeam)
 					net-&gt;Send(CBaseNetProtocol::Get().SendSetAllied(gu-&gt;myPlayerNum, otherAllyTeam, state));
+				else
+					logOutput.Print(&quot;/ally: wrong parameters (usage: /ally &lt;other team&gt; [0|1])&quot;);
 			}
+			else
+			{
+				logOutput.Print(&quot;No ingame alliances are allowed&quot;);
+			}
 		}
 	}
 	else if (cmd == &quot;group&quot;) {
@@ -3891,10 +3897,17 @@
 				const int whichAllyTeam = inbuf[2];
 				const bool allied = static_cast&lt;bool&gt;(inbuf[3]);
 				if (whichAllyTeam &lt; MAX_TEAMS &amp;&amp; whichAllyTeam &gt;= 0) {
+					const int fromAllyTeam = teamHandler-&gt;AllyTeam(playerHandler-&gt;Player(player)-&gt;team);
 					// FIXME - need to reset unit allyTeams
 					//       - need to reset unit texture for 3do
 					//       - need a call-in for AIs
-					teamHandler-&gt;SetAlly(teamHandler-&gt;AllyTeam(playerHandler-&gt;Player(player)-&gt;team), whichAllyTeam, allied);
+					teamHandler-&gt;SetAlly(fromAllyTeam, whichAllyTeam, allied);
+					if (fromAllyTeam == gu-&gt;myAllyTeam)
+					{
+						std::ostringstream msg;
+						msg &lt;&lt; &quot;You have &quot; &lt;&lt; (allied ? &quot; allied &quot; : &quot; unallied &quot;) &lt;&lt; &quot; allyteam &quot; &lt;&lt; whichAllyTeam;
+						logOutput.Print(msg.str());
+					}
 				} else {
 					logOutput.Print(&quot;Player %i sent out wrong allyTeam index in alliance message&quot;, player);
 				}

Modified: branches/caiinterface/rts/Game/GameHelper.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/GameHelper.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -165,7 +165,7 @@
 void CGameHelper::Explosion(float3 expPos, const DamageArray&amp; damages,
                             float expRad, float edgeEffectiveness,
                             float expSpeed, CUnit* owner,
-                            bool damageGround, float gfxMod, bool ignoreOwner,
+                            bool damageGround, float gfxMod, bool ignoreOwner, bool impactOnly,
                             CExplosionGenerator* explosionGraphics, CUnit* hit,
                             const float3&amp; impactDir, int weaponId)
 {
@@ -189,50 +189,55 @@
 	float h2 = ground-&gt;GetHeight2(expPos.x, expPos.z);
 	expPos.y = std::max(expPos.y, h2);
 	expRad = std::max(expRad, 1.0f);
-	float height = std::max(expPos.y - h2, 0.0f);
 
+	if (impactOnly) {
+		if (hit)
+			DoExplosionDamage(hit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
+	} else {
+		float height = std::max(expPos.y - h2, 0.0f);
 
-	// damage all units within the explosion radius
-	vector&lt;CUnit*&gt; units = qf-&gt;GetUnitsExact(expPos, expRad);
-	vector&lt;CUnit*&gt;::iterator ui;
-	bool hitUnitDamaged = false;
+		// damage all units within the explosion radius
+		vector&lt;CUnit*&gt; units = qf-&gt;GetUnitsExact(expPos, expRad);
+		vector&lt;CUnit*&gt;::iterator ui;
+		bool hitUnitDamaged = false;
 
-	for (ui = units.begin(); ui != units.end(); ++ui) {
-		CUnit* unit = *ui;
+		for (ui = units.begin(); ui != units.end(); ++ui) {
+			CUnit* unit = *ui;
 
-		if (unit == hit) {
-			hitUnitDamaged = true;
+			if (unit == hit) {
+				hitUnitDamaged = true;
+			}
+	
+			DoExplosionDamage(unit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
 		}
 
-		DoExplosionDamage(unit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
-	}
+		// HACK: for a unit with an offset coldet volume, the explosion
+		// (from an impacting projectile) position might not correspond
+		// to its quadfield position so we need to damage it separately
+		if (hit &amp;&amp; !hitUnitDamaged) {
+			DoExplosionDamage(hit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
+		}
 
-	// HACK: for a unit with an offset coldet volume, the explosion
-	// (from an impacting projectile) position might not correspond
-	// to its quadfield position so we need to damage it separately
-	if (hit &amp;&amp; !hitUnitDamaged) {
-		DoExplosionDamage(hit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
-	}
 
+		// damage all features within the explosion radius
+		vector&lt;CFeature*&gt; features = qf-&gt;GetFeaturesExact(expPos, expRad);
+		vector&lt;CFeature*&gt;::iterator fi;
 
-	// damage all features within the explosion radius
-	vector&lt;CFeature*&gt; features = qf-&gt;GetFeaturesExact(expPos, expRad);
-	vector&lt;CFeature*&gt;::iterator fi;
+		for (fi = features.begin(); fi != features.end(); ++fi) {
+			CFeature* feature = *fi;
 
-	for (fi = features.begin(); fi != features.end(); ++fi) {
-		CFeature* feature = *fi;
+			DoExplosionDamage(feature, expPos, expRad, owner, damages);
+		}
 
-		DoExplosionDamage(feature, expPos, expRad, owner, damages);
-	}
-
-	// deform the map
-	if (damageGround &amp;&amp; !mapDamage-&gt;disabled &amp;&amp;
-	    (expRad &gt; height) &amp;&amp; (damages.craterMult &gt; 0.0f)) {
-		float damage = damages[0] * (1.0f - (height / expRad));
-		if (damage &gt; (expRad * 10.0f)) {
-			damage = expRad * 10.0f; // limit the depth somewhat
+		// deform the map
+		if (damageGround &amp;&amp; !mapDamage-&gt;disabled &amp;&amp;
+		    (expRad &gt; height) &amp;&amp; (damages.craterMult &gt; 0.0f)) {
+			float damage = damages[0] * (1.0f - (height / expRad));
+			if (damage &gt; (expRad * 10.0f)) {
+				damage = expRad * 10.0f; // limit the depth somewhat
+			}
+			mapDamage-&gt;Explosion(expPos, (damage + damages.craterBoost) * damages.craterMult, expRad - height);
 		}
-		mapDamage-&gt;Explosion(expPos, (damage + damages.craterBoost) * damages.craterMult, expRad - height);
 	}
 
 	// use CStdExplosionGenerator by default
@@ -336,7 +341,6 @@
 	CollisionQuery cq;
 
 	GML_RECMUTEX_LOCK(quad); // GuiTraceRay
-
 	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
 	vector&lt;int&gt;::iterator qi;
 

Modified: branches/caiinterface/rts/Game/GameHelper.h
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.h	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/GameHelper.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -45,7 +45,7 @@
 
 	void DoExplosionDamage(CUnit*, const float3&amp;, float, float, bool, CUnit*, float, const DamageArray&amp;, int);
 	void DoExplosionDamage(CFeature*, const float3&amp;, float, CUnit*, const DamageArray&amp;);
-	void Explosion(float3 pos, const DamageArray&amp; damages,float radius, float edgeEffectiveness, float explosionSpeed, CUnit* owner,bool damageGround,float gfxMod,bool ignoreOwner, CExplosionGenerator *explosionGraphics,CUnit *hit, const float3 &amp;impactDir, int weaponId);
+	void Explosion(float3 pos, const DamageArray&amp; damages,float radius, float edgeEffectiveness, float explosionSpeed, CUnit* owner,bool damageGround,float gfxMod,bool ignoreOwner,bool impactOnly, CExplosionGenerator *explosionGraphics,CUnit *hit, const float3 &amp;impactDir, int weaponId);
 
 	float TraceRayTeam(const float3&amp; start,const float3&amp; dir,float length, CUnit*&amp; hit,bool useRadar,CUnit* exclude,int allyteam);
 	void BuggerOff(float3 pos, float radius,CUnit* exclude=0);

Modified: branches/caiinterface/rts/Game/GameServer.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameServer.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/GameServer.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -136,7 +136,7 @@
 
 	medianCpu=0.0f;
 	medianPing=0;
-	enforceSpeed=configHandler.Get(&quot;EnforceGameSpeed&quot;, 1);
+	enforceSpeed=configHandler.Get(&quot;EnforceGameSpeed&quot;, false);
 
 	if (!onlyLocal)
 		UDPNet.reset(new netcode::UDPListener(settings-&gt;hostport));
@@ -151,11 +151,6 @@
 
 	maxUserSpeed = setup-&gt;maxSpeed;
 	minUserSpeed = setup-&gt;minSpeed;
-	// enforce gamespeed if not configured
-	if(enforceSpeed &amp;&amp; minUserSpeed &lt;= 0.3f)
-		minUserSpeed = 1.0f;
-	if(enforceSpeed &amp;&amp; maxUserSpeed &gt;= 3.0f)
-		maxUserSpeed = 1.0f;
 	noHelperAIs = (bool)setup-&gt;noHelperAIs;
 
 	gameData.reset(newGameData);

Modified: branches/caiinterface/rts/Game/UI/GuiHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/GuiHandler.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/UI/GuiHandler.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -37,7 +37,6 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/Textures/NamedTextures.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
@@ -1503,7 +1502,7 @@
 	return (minV + (factor * (maxV - minV)));
 }
 
-// CALLINFO: 
+// CALLINFO:
 // DrawMapStuff --&gt; GetDefaultCommand
 // CMouseHandler::DrawCursor --&gt; DrawCentroidCursor --&gt; GetDefaultCommand
 // LuaUnsyncedRead::GetDefaultCommand --&gt; GetDefaultCommand
@@ -3374,7 +3373,7 @@
 static inline void DrawSensorRange(int radius,
                                    const float* color, const float3&amp; pos)
 {
-	const int sensorScale = (SQUARE_SIZE * RADAR_SIZE);
+	const int sensorScale = radarhandler-&gt;radarDiv;
 	const int realRadius = ((radius / sensorScale) * sensorScale);
 	if (realRadius &gt; 0) {
 		glColor4fv(color);
@@ -3479,7 +3478,7 @@
 		glDisable(GL_ALPHA_TEST);
 	}
 
-	float3 camerapos=camera-&gt;pos; 
+	float3 camerapos=camera-&gt;pos;
 	//CCamera tmpcam(*camera);
 	//	CCamera *camera=&tmpcam;
 	float3 mousedir=mouse-&gt;dir;

Modified: branches/caiinterface/rts/Game/UI/HwMouseCursor.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/HwMouseCursor.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/UI/HwMouseCursor.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -217,7 +217,7 @@
 	dst += 4;
 
 	////////////////////////////////////////////////////////////////////////////////////////////////
-	// the following code writes a full working .cur file in the memory (in a .ani container)
+	// the following code writes a fully working .cur file in the memory (in a .ani container)
 
 	//file header
 	WORD* header = (WORD*)&amp;dst[0]; int i=0;

Modified: branches/caiinterface/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1178,7 +1178,7 @@
 
 	GML_RECMUTEX_LOCK(sel); // DrawForReal
 	// draw unit ranges
-	const float radarSquare = (SQUARE_SIZE * RADAR_SIZE);
+	const float radarSquare = radarhandler-&gt;radarDiv;
 	CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 	for(CUnitSet::iterator si = selUnits.begin(); si != selUnits.end(); ++si) {
 		CUnit* unit = *si;

Modified: branches/caiinterface/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaSyncedCtrl.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Lua/LuaSyncedCtrl.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1714,8 +1714,8 @@
 	const string key = luaL_checkstring(L, 2);
 	const float radius = luaL_checkfloat(L, 3);
 
-	const int radarDiv    = (SQUARE_SIZE * RADAR_SIZE);
-	const int radarRadius = (int)(radius / (float)radarDiv);
+	const int radarDiv    = radarhandler-&gt;radarDiv;
+	const int radarRadius = (int)(radius * radarhandler-&gt;invRadarDiv);
 
 	if (key == &quot;los&quot;) {
 		const int losRange = (int)(radius * loshandler-&gt;invLosDiv);

Modified: branches/caiinterface/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaSyncedRead.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Lua/LuaSyncedRead.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -2311,7 +2311,7 @@
 	}
 	const string key = luaL_checkstring(L, 2);
 
-	const int radarDiv = (SQUARE_SIZE * RADAR_SIZE);
+	const int radarDiv = radarhandler-&gt;radarDiv;
 
 	if (key == &quot;los&quot;) {
 		lua_pushnumber(L, unit-&gt;losRadius * loshandler-&gt;losDiv);

Modified: branches/caiinterface/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/BaseGroundDrawer.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Map/BaseGroundDrawer.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -9,6 +9,7 @@
 #include &quot;Ground.h&quot;
 #include &quot;HeightLinePalette.h&quot;
 #include &quot;ReadMap.h&quot;
+#include &quot;MapInfo.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -252,6 +253,10 @@
 //   updateTextureState = 57:   Reset to 0 and restart updating
 bool CBaseGroundDrawer::UpdateExtraTexture()
 {
+	if (mapInfo-&gt;map.voidWater &amp;&amp; readmap-&gt;currMaxHeight&lt;0) {
+		return true;
+	}
+
 	if (drawMode == drawNormal) {
 		return true;
 	}

Modified: branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -675,6 +675,10 @@
 
 void CBFGroundDrawer::Draw(bool drawWaterReflection, bool drawUnitReflection, unsigned int overrideVP)
 {
+	if (mapInfo-&gt;map.voidWater &amp;&amp; map-&gt;currMaxHeight&lt;0) {
+		return;
+	}
+
 	if (wireframe) {
 		glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
 	}
@@ -1095,6 +1099,10 @@
 
 void CBFGroundDrawer::DrawShadowPass(void)
 {
+	if (mapInfo-&gt;map.voidWater &amp;&amp; map-&gt;currMaxHeight&lt;0) {
+		return;
+	}
+
 //	glEnable(GL_CULL_FACE);
 	const int NUM_LODS = 4;
 
@@ -1392,6 +1400,10 @@
 
 void CBFGroundDrawer::Update()
 {
+	if (mapInfo-&gt;map.voidWater &amp;&amp; map-&gt;currMaxHeight&lt;0) {
+		return;
+	}
+
 	textures-&gt;DrawUpdate();
 }
 

Modified: branches/caiinterface/rts/Sim/Misc/LosHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosHandler.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Misc/LosHandler.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -25,7 +25,6 @@
 CR_BIND(LosInstance, );
 CR_BIND(CLosHandler, );
 CR_BIND(CLosHandler::DelayedInstance, );
-CR_BIND(CLosHandler::CPoint, );
 
 CR_REG_METADATA(LosInstance,(
 //		CR_MEMBER(losSquares),
@@ -33,10 +32,9 @@
 		CR_MEMBER(airLosSize),
 		CR_MEMBER(refCount),
 		CR_MEMBER(allyteam),
-		CR_MEMBER(baseX),
-		CR_MEMBER(baseY),
+		CR_MEMBER(basePos),
 		CR_MEMBER(baseSquare),
-		CR_MEMBER(baseAirSquare),
+		CR_MEMBER(baseAirPos),
 		CR_MEMBER(hashNum),
 		CR_MEMBER(baseHeight),
 		CR_MEMBER(toBeDeleted),
@@ -48,11 +46,7 @@
 	for (int a = 0; a &lt; 2309; ++a)
 		for (std::list&lt;LosInstance*&gt;::iterator li = instanceHash[a].begin(); li != instanceHash[a].end(); ++li)
 			if ((*li)-&gt;refCount) {
-				if ((*li)-&gt;baseX-(*li)-&gt;losSize&lt;0 || (*li)-&gt;baseX+(*li)-&gt;losSize&gt;=losSizeX ||
-				    (*li)-&gt;baseY-(*li)-&gt;losSize&lt;0 || (*li)-&gt;baseY+(*li)-&gt;losSize&gt;=losSizeY)
-					SafeLosAdd(*li,(*li)-&gt;baseX,(*li)-&gt;baseY);
-				else
-					LosAdd(*li);
+				LosAdd(*li);
 			}
 }
 
@@ -61,8 +55,6 @@
 		CR_MEMBER(instanceHash),
 		CR_MEMBER(toBeDeleted),
 		CR_MEMBER(delayQue),
-//		CR_MEMBER(Points),
-//		CR_MEMBER(lostables)
 		CR_RESERVED(31),
 		CR_POSTLOAD(PostLoad)
 		));
@@ -75,6 +67,8 @@
 		CR_MEMBER(x),
 		CR_MEMBER(y)));
 */
+
+
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
@@ -94,16 +88,14 @@
 	airSizeY(std::max(1, gs-&gt;mapy &gt;&gt; airMipLevel)),
 	losSizeX(std::max(1, gs-&gt;mapx &gt;&gt; losMipLevel)),
 	losSizeY(std::max(1, gs-&gt;mapy &gt;&gt; losMipLevel)),
-	requireSonarUnderWater(modInfo.requireSonarUnderWater)
+	requireSonarUnderWater(modInfo.requireSonarUnderWater),
+	losAlgo(int2(losSizeX, losSizeY), -1e6f, 15, readmap-&gt;mipHeightmap[losMipLevel])
+	//airAlgo(int2(airSizeX, airSizeY), -1e6f, 15, readmap-&gt;mipHeightmap[airMipLevel])
 {
 	for (int a = 0; a &lt; teamHandler-&gt;ActiveAllyTeams(); ++a) {
-		losMap[a].resize(losSizeX * losSizeY, 0);
-		airLosMap[a].resize(airSizeX * airSizeY, 0);
+		losMap[a].SetSize(losSizeX, losSizeY);
+		airLosMap[a].SetSize(airSizeX, airSizeY);
 	}
-
-	for (int a=1;a&lt;=MAX_LOS_TABLE;++a) {
-		OutputTable(a);
-	}
 }
 
 
@@ -124,8 +116,7 @@
 void CLosHandler::MoveUnit(CUnit *unit, bool redoCurrent)
 {
 	SCOPED_TIMER(&quot;Los&quot;);
-	float3 losPos = unit-&gt;pos;
-	losPos.CheckInBounds();
+	const float3&amp; losPos = unit-&gt;pos;
 
 	const int allyteam = unit-&gt;allyteam;
 	unit-&gt;lastLosUpdate = gs-&gt;frameNum;
@@ -133,12 +124,13 @@
 	if (unit-&gt;losRadius &lt;= 0) {
 		return;
 	}
-	const int xmap = (int)(losPos.x*invLosDiv);
-	const int ymap = (int)(losPos.z*invLosDiv);
-	const int baseSquare = max(0,min(losSizeY-1,(ymap)))*losSizeX + max(0,min(losSizeX-1,xmap));
-	const int baseX = max(0,min(losSizeX-1,xmap));
-	const int baseY = max(0,min(losSizeY-1,(ymap)));
 
+	const int baseX = max(0, min(losSizeX - 1, (int)(losPos.x * invLosDiv)));
+	const int baseY = max(0, min(losSizeY - 1, (int)(losPos.z * invLosDiv)));
+	const int baseSquare = baseY * losSizeX + baseX;
+	const int baseAirX = max(0, min(airSizeX - 1, (int)(losPos.x * invAirDiv)));
+	const int baseAirY = max(0, min(airSizeY - 1, (int)(losPos.z * invAirDiv)));
+
 	LosInstance* instance;
 	if (redoCurrent) {
 		if (!unit-&gt;los) {
@@ -147,11 +139,11 @@
 		instance = unit-&gt;los;
 		CleanupInstance(instance);
 		instance-&gt;losSquares.clear();
-		instance-&gt;baseX = baseX;
-		instance-&gt;baseY = baseY;
-		instance-&gt;baseSquare = baseSquare;	//this could be a problem if several units are sharing the same instance
-		int baseAirSquare = max(0,min(airSizeY-1,((int)(losPos.z*invAirDiv))))*airSizeX + max(0,min(airSizeX-1,(int)(losPos.x*invAirDiv)));
-		instance-&gt;baseAirSquare = baseAirSquare;
+		instance-&gt;basePos.x = baseX;
+		instance-&gt;basePos.y = baseY;
+		instance-&gt;baseSquare = baseSquare; //this could be a problem if several units are sharing the same instance
+		instance-&gt;baseAirPos.x = baseAirX;
+		instance-&gt;baseAirPos.y = baseAirY;
 	} else {
 		if (unit-&gt;los &amp;&amp; (unit-&gt;los-&gt;baseSquare == baseSquare)) {
 			return;
@@ -170,17 +162,12 @@
 				return;
 			}
 		}
-		int baseAirSquare=max(0,min(airSizeY-1,((int)(losPos.z*invAirDiv))))*airSizeX + max(0,min(airSizeX-1,(int)(losPos.x*invAirDiv)));
-		instance=new(mempool.Alloc(sizeof(LosInstance))) LosInstance(unit-&gt;losRadius,allyteam,baseX,baseY,baseSquare,baseAirSquare,hash,unit-&gt;losHeight,unit-&gt;airLosRadius);
+		instance=new(mempool.Alloc(sizeof(LosInstance))) LosInstance(unit-&gt;losRadius, unit-&gt;airLosRadius, allyteam, int2(baseX,baseY), baseSquare, int2(baseAirX, baseAirY), hash, unit-&gt;losHeight);
 		instanceHash[hash].push_back(instance);
 		unit-&gt;los=instance;
 	}
-	if (xmap-unit-&gt;losRadius &lt; 0 || xmap+unit-&gt;losRadius &gt;= losSizeX ||
-	    ymap-unit-&gt;losRadius &lt; 0 || ymap+unit-&gt;losRadius &gt;= losSizeY) {
-		SafeLosAdd(instance, xmap, ymap);
-	} else {
-		LosAdd(instance);
-	}
+
+	LosAdd(instance);
 }
 
 
@@ -190,320 +177,13 @@
 	assert(instance-&gt;allyteam &lt; teamHandler-&gt;ActiveAllyTeams());
 	assert(instance-&gt;allyteam &gt;= 0);
 
-	const int allyteam  = instance-&gt;allyteam;
-	const int mapSquare = instance-&gt;baseSquare;
+	losAlgo.LosAdd(instance-&gt;basePos, instance-&gt;losSize, instance-&gt;baseHeight, instance-&gt;losSquares);
 
-	float* heightmap = readmap-&gt;mipHeightmap[losMipLevel];
-	vector&lt;unsigned short&gt;* allyLosMap = &amp;losMap[allyteam];
-
-	LosAddAir(instance);
-
-	const int tablenum = std::min(instance-&gt;losSize, MAX_LOS_TABLE);
-	LosTable&amp; table = lostables[tablenum - 1];
-
-	instance-&gt;losSquares.push_back(mapSquare);
-	(*allyLosMap)[mapSquare]++;
-
-	const float baseHeight = heightmap[mapSquare] + instance-&gt;baseHeight-15;
-
-	for(LosTable::iterator li=table.begin();li!=table.end();++li){
-		LosLine&amp; line=*li;
-		float maxAng1 = -1e6f;
-		float maxAng2 = -1e6f;
-		float maxAng3 = -1e6f;
-		float maxAng4 = -1e6f;
-		float r = 1;
-		for(LosLine::iterator linei=line.begin();linei!=line.end();++linei){
-			float invR=1.0f/r;
-			int square=mapSquare + linei-&gt;x + linei-&gt;y*losSizeX;
-			float dh=heightmap[square] - baseHeight;
-			float ang=dh*invR;
-			if(ang&gt;maxAng1){
-				instance-&gt;losSquares.push_back(square);
-				(*allyLosMap)[square]++;
-			}
-			dh-=15;
-			ang=dh*invR;
-			if(ang&gt;maxAng1){
-				maxAng1=ang;
-			}
-
-			square=mapSquare - linei-&gt;x - linei-&gt;y*losSizeX;
-			dh=heightmap[square] - baseHeight;
-			ang=dh*invR;
-			if(ang&gt;maxAng2){
-				instance-&gt;losSquares.push_back(square);
-				(*allyLosMap)[square]++;
-			}
-			dh-=15;
-			ang=dh*invR;
-			if(ang&gt;maxAng2){
-				maxAng2=ang;
-			}
-
-			square=mapSquare - linei-&gt;x*losSizeX + linei-&gt;y;
-			dh=heightmap[square] - baseHeight;
-			ang=dh*invR;
-			if(ang&gt;maxAng3){
-				instance-&gt;losSquares.push_back(square);
-				(*allyLosMap)[square]++;
-			}
-			dh-=15;
-			ang=dh*invR;
-			if(ang&gt;maxAng3){
-				maxAng3=ang;
-			}
-
-			square=mapSquare + linei-&gt;x*losSizeX - linei-&gt;y;
-			dh=heightmap[square] - baseHeight;
-			ang=dh*invR;
-			if(ang&gt;maxAng4){
-				instance-&gt;losSquares.push_back(square);
-				(*allyLosMap)[square]++;
-			}
-			dh-=15;
-			ang=dh*invR;
-			if(ang&gt;maxAng4){
-				maxAng4=ang;
-			}
-			r++;
-		}
-	}
+	losMap[instance-&gt;allyteam].AddMapSquares(instance-&gt;losSquares, 1);
+	airLosMap[instance-&gt;allyteam].AddMapArea(instance-&gt;baseAirPos, instance-&gt;airLosSize, 1);
 }
 
 
-void CLosHandler::SafeLosAdd(LosInstance* instance,int xm,int ym)
-{
-	int xmap=xm;
-	int ymap=ym;
-	const int allyteam=instance-&gt;allyteam;
-
-	const int mapSquare=instance-&gt;baseSquare;
-
-	float* heightmap = readmap-&gt;mipHeightmap[losMipLevel];
-	vector&lt;unsigned short&gt;* allyLosMap = &amp;losMap[allyteam];
-
-	LosAddAir(instance);
-
-	int tablenum=instance-&gt;losSize;
-	if(tablenum&gt;MAX_LOS_TABLE){
-		tablenum=MAX_LOS_TABLE;
-	}
-	LosTable&amp; table=lostables[tablenum-1];
-
-	const float baseHeight = heightmap[mapSquare] + instance-&gt;baseHeight-15;
-
-	for (LosTable::iterator li = table.begin(); li != table.end(); ++li) {
-		LosLine&amp; line = *li;
-		float maxAng1 = -1e6f;
-		float maxAng2 = -1e6f;
-		float maxAng3 = -1e6f;
-		float maxAng4 = -1e6f;
-		float r = 1;
-		instance-&gt;losSquares.push_back(mapSquare);
-		(*allyLosMap)[mapSquare]++;
-
-		for(LosLine::iterator linei=line.begin();linei!=line.end();++linei){
-			if(xmap+linei-&gt;x&lt;losSizeX &amp;&amp; ymap+linei-&gt;y&lt;losSizeY){
-				int square=mapSquare+linei-&gt;x+linei-&gt;y*losSizeX;
-				float dh=heightmap[square] - baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng1){
-					instance-&gt;losSquares.push_back(square);
-					(*allyLosMap)[square]++;
-				}
-				dh-=15;
-				ang=dh/r;
-				if(ang&gt;maxAng1){
-					maxAng1=ang;
-				}
-			}
-			if(xmap-linei-&gt;x&gt;=0 &amp;&amp; ymap-linei-&gt;y&gt;=0){
-				int square=mapSquare-linei-&gt;x-linei-&gt;y*losSizeX;
-				float dh=heightmap[square] - baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng2){
-					instance-&gt;losSquares.push_back(square);
-					(*allyLosMap)[square]++;
-				}
-				dh-=15;
-				ang=dh/r;
-				if(ang&gt;maxAng2){
-					maxAng2=ang;
-				}
-			}
-			if(xmap+linei-&gt;y&lt;losSizeX &amp;&amp; ymap-linei-&gt;x&gt;=0){
-				int square=mapSquare-linei-&gt;x*losSizeX+linei-&gt;y;
-				float dh=heightmap[square] - baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng3){
-					instance-&gt;losSquares.push_back(square);
-					(*allyLosMap)[square]++;
-				}
-				dh-=15;
-				ang=dh/r;
-				if(ang&gt;maxAng3){
-					maxAng3=ang;
-				}
-			}
-			if(xmap-linei-&gt;y&gt;=0 &amp;&amp; ymap+linei-&gt;x&lt;losSizeY){
-				int square=mapSquare+linei-&gt;x*losSizeX-linei-&gt;y;
-				float dh=heightmap[square] - baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng4){
-					instance-&gt;losSquares.push_back(square);
-					(*allyLosMap)[square]++;
-				}
-				dh-=15;
-				ang=dh/r;
-				if(ang&gt;maxAng4){
-					maxAng4=ang;
-				}
-			}
-			r++;
-		}
-	}
-}
-
-
-void CLosHandler::OutputTable(int Table)
-{
-	LosTable lostable;
-
-	int Radius = Table;
-	char* PaintTable = SAFE_NEW char[(Radius+1)*Radius];
-	memset(PaintTable, 0 , (Radius+1)*Radius);
-	CPoint P;
-
-	int x, y, r2;
-
-	P.x = 0;
-	P.y = Radius;
-	Points.push_front(P);
-//  DrawLine(0, Radius, Radius);
-	for(float i=Radius; i&gt;=1; i-=0.5f)
-	{
-		r2 = (int)(i * i);
-
-		y = (int)i;
-		x = 1;
-		y = (int) (sqrt((float)r2 - 1) + 0.5f);
-		while (x &lt; y) {
-			if(!PaintTable[x+y*Radius])
-			{
-				DrawLine(PaintTable, x, y, Radius);
-				P.x = x;
-				P.y = y;
-				Points.push_back(P);
-			}
-			if(!PaintTable[y+x*Radius])
-			{
-				DrawLine(PaintTable, y, x, Radius);
-				P.x = y;
-				P.y = x;
-				Points.push_back(P);
-			}
-
-			x += 1;
-			y = (int) (sqrt((float)r2 - x*x) + 0.5f);
-		}
-		if (x == y) {
-			if(!PaintTable[x+y*Radius])
-			{
-				DrawLine(PaintTable, x, y, Radius);
-				P.x = x;
-				P.y = y;
-				Points.push_back(P);
-			}
-		}
-	}
-
-	Points.sort();
-
-	int Line = 1;
-	int Size = Points.size();
-	for(int j=0; j&lt;Size; j++)
-	{
-		lostable.push_back(OutputLine(Points.back().x, Points.back().y, Line));
-		Points.pop_back();
-		Line++;
-	}
-
-	lostables.push_back(lostable);
-
-	delete[] PaintTable;
-}
-
-
-CLosHandler::LosLine CLosHandler::OutputLine(int x, int y, int Line)
-{
-	LosLine losline;
-
-	int x0 = 0;
-	int y0 = 0;
-	int dx = x;
-	int dy = y;
-
-	if (abs(dx) &gt; abs(dy)) {          // slope &lt;1
-		float m = (float) dy / (float) dx;      // compute slope
-		float b = y0 - m*x0;
-		dx = (dx &lt; 0) ? -1 : 1;
-		while (x0 != x) {
-			x0 += dx;
-			losline.push_back(CPoint(x0,Round(m*x0 + b)));
-		}
-	} else
-		if (dy != 0) {                              // slope = 1
-			float m = (float) dx / (float) dy;      // compute slope
-			float b = x0 - m*y0;
-			dy = (dy &lt; 0) ? -1 : 1;
-			while (y0 != y) {
-				y0 += dy;
-				losline.push_back(CPoint(Round(m*y0 + b),y0));
-			}
-		}
-	return losline;
-}
-
-
-void CLosHandler::DrawLine(char* PaintTable, int x, int y, int Size)
-{
-	int x0 = 0;
-	int y0 = 0;
-	int dx = x;
-	int dy = y;
-
-	if (abs(dx) &gt; abs(dy)) {          // slope &lt;1
-		float m = (float) dy / (float) dx;      // compute slope
-		float b = y0 - m*x0;
-		dx = (dx &lt; 0) ? -1 : 1;
-		while (x0 != x) {
-			x0 += dx;
-			PaintTable[x0+Round(m*x0 + b)*Size] = 1;
-		}
-	} else {
-		if (dy != 0) {                              // slope = 1
-			float m = (float) dx / (float) dy;      // compute slope
-			float b = x0 - m*y0;
-			dy = (dy &lt; 0) ? -1 : 1;
-			while (y0 != y) {
-				y0 += dy;
-				PaintTable[Round(m*y0 + b)+y0*Size] = 1;
-			}
-		}
-	}
-}
-
-
-int CLosHandler::Round(float Num)
-{
-  if((Num - (int)Num) &lt;0.5f)
-    return (int)Num;
-  else
-    return (int)Num+1;
-}
-
-
 void CLosHandler::FreeInstance(LosInstance* instance)
 {
 	if(instance==0)
@@ -553,12 +233,8 @@
 
 void CLosHandler::AllocInstance(LosInstance* instance)
 {
-	if(instance-&gt;refCount==0){
-		std::vector&lt;int&gt;::iterator lsi;
-		for(lsi=instance-&gt;losSquares.begin();lsi!=instance-&gt;losSquares.end();++lsi){
-			++losMap[instance-&gt;allyteam][*lsi];
-		}
-		LosAddAir(instance);
+	if (instance-&gt;refCount == 0) {
+		LosAdd(instance);
 	}
 	instance-&gt;refCount++;
 }
@@ -566,60 +242,11 @@
 
 void CLosHandler::CleanupInstance(LosInstance* instance)
 {
-	vector&lt;unsigned short&gt;&amp; allyLosMap = losMap[instance-&gt;allyteam];
-	for(std::vector&lt;int&gt;::iterator lsi=instance-&gt;losSquares.begin();lsi!=instance-&gt;losSquares.end();++lsi){
-		--allyLosMap[*lsi];
-	}
-
-	int by=(instance-&gt;baseAirSquare/airSizeX);
-	int bx=(instance-&gt;baseAirSquare-by*airSizeX);
-
-	int sx=max(0,bx-instance-&gt;airLosSize);
-	int ex=min(airSizeX-1,bx+instance-&gt;airLosSize);
-	int sy=max(0,by-instance-&gt;airLosSize);
-	int ey=min(airSizeY-1,by+instance-&gt;airLosSize);
-
-	int rr=instance-&gt;airLosSize*instance-&gt;airLosSize;
-	for(int y=sy;y&lt;=ey;++y){
-		int rrx=rr-(by-y)*(by-y);
-		for(int x=sx;x&lt;=ex;++x){
-			if((bx-x)*(bx-x)&lt;=rrx){
-				--allyLosMap[y*airSizeX+x];
-			}
-		}
-	}
+	losMap[instance-&gt;allyteam].AddMapSquares(instance-&gt;losSquares, -1);
+	airLosMap[instance-&gt;allyteam].AddMapArea(instance-&gt;baseAirPos, instance-&gt;airLosSize, -1);
 }
 
 
-void CLosHandler::LosAddAir(LosInstance* instance)
-{
-	/*int by=(instance-&gt;baseSquare/gs-&gt;hmapx);
-	int bx=(instance-&gt;baseSquare-by*gs-&gt;hmapx)/2;
-	by/=2;*/
-	int by=(instance-&gt;baseAirSquare/airSizeX);
-	int bx=(instance-&gt;baseAirSquare-by*airSizeX);
-
-	int sx=max(0,bx-instance-&gt;airLosSize);
-	int ex=min(airSizeX-1,bx+instance-&gt;airLosSize);
-	int sy=max(0,by-instance-&gt;airLosSize);
-	int ey=min(airSizeY-1,by+instance-&gt;airLosSize);
-
-	int rr=instance-&gt;airLosSize*instance-&gt;airLosSize;
-
-	if (instance-&gt;allyteam &lt; 0)
-		return;
-
-	for(int y=sy;y&lt;=ey;++y){
-		int rrx=rr-(by-y)*(by-y);
-		for(int x=sx;x&lt;=ex;++x){
-			if((bx-x)*(bx-x)&lt;=rrx){
-				++airLosMap[instance-&gt;allyteam][y*airSizeX+x];
-			}
-		}
-	}
-}
-
-
 void CLosHandler::Update(void)
 {
 	while(!delayQue.empty() &amp;&amp; delayQue.front().timeoutTime&lt;gs-&gt;frameNum){

Modified: branches/caiinterface/rts/Sim/Misc/LosHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosHandler.h	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Misc/LosHandler.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -12,27 +12,24 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Objects/WorldObject.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
-#include &quot;RadarHandler.h&quot;
+#include &quot;Sim/Misc/RadarHandler.h&quot;
 #include &lt;assert.h&gt;
 
-#define MAX_LOS_TABLE 110
 
 struct LosInstance : public boost::noncopyable
 {
 	CR_DECLARE_STRUCT(LosInstance);
  	std::vector&lt;int&gt; losSquares;
 	LosInstance() {} // default constructor for creg
-	LosInstance(int lossize, int allyteam, int baseX, int baseY,
-	            int baseSquare, int baseAirSquare, int hashNum,
-	            float baseHeight, int airLosSize)
+	LosInstance(int lossize, int airLosSize, int allyteam, int2 basePos,
+	            int baseSquare, int2 baseAirPos, int hashNum, float baseHeight)
 		: losSize(lossize),
 			airLosSize(airLosSize),
 			refCount(1),
 			allyteam(allyteam),
-			baseX(baseX),
-			baseY(baseY),
+			basePos(basePos),
 			baseSquare(baseSquare),
-			baseAirSquare(baseAirSquare),
+			baseAirPos(baseAirPos),
 			hashNum(hashNum),
 			baseHeight(baseHeight),
 			toBeDeleted(false) {}
@@ -40,10 +37,9 @@
 	int airLosSize;
 	int refCount;
 	int allyteam;
-	int baseX;
-	int baseY;
+	int2 basePos;
 	int baseSquare;
-	int baseAirSquare;
+	int2 baseAirPos;
 	int hashNum;
 	float baseHeight;
 	bool toBeDeleted;
@@ -67,20 +63,12 @@
 		else if (object-&gt;useAirLos) {
 			const int gx = (int)(object-&gt;pos.x * invAirDiv);
 			const int gz = (int)(object-&gt;pos.z * invAirDiv);
-			const int rowIdx = std::max(0, std::min(airSizeY - 1, gz));
-			const int colIdx = std::max(0, std::min(airSizeX - 1, gx));
-			const int square = (rowIdx * airSizeX) + colIdx;
-			assert(static_cast&lt;unsigned&gt;(square) &lt; airLosMap[allyTeam].size());
-			return !!airLosMap[allyTeam][square];
+			return !!airLosMap[allyTeam].At(gx, gz);
 		}
 		else {
 			const int gx = (int)(object-&gt;pos.x * invLosDiv);
 			const int gz = (int)(object-&gt;pos.z * invLosDiv);
-			const int rowIdx = std::max(0, std::min(losSizeY - 1, gz));
-			const int colIdx = std::max(0, std::min(losSizeX - 1, gx));
-			const int square = (rowIdx * losSizeX) + colIdx;
-			assert(static_cast&lt;unsigned&gt;(square) &lt; losMap[allyTeam].size());
-			return !!losMap[allyTeam][square];
+			return !!losMap[allyTeam].At(gx, gz);
 		}
 	}
 
@@ -98,11 +86,7 @@
 		else if (unit-&gt;useAirLos) {
 			const int gx = (int)(unit-&gt;pos.x * invAirDiv);
 			const int gz = (int)(unit-&gt;pos.z * invAirDiv);
-			const int rowIdx = std::max(0, std::min(airSizeY - 1, gz));
-			const int colIdx = std::max(0, std::min(airSizeX - 1, gx));
-			const int square = (rowIdx * airSizeX) + colIdx;
-			assert(static_cast&lt;unsigned&gt;(square) &lt; airLosMap[allyTeam].size());
-			return !!airLosMap[allyTeam][square];
+			return !!airLosMap[allyTeam].At(gx, gz);
 		}
 		else {
 			if (unit-&gt;isUnderWater &amp;&amp; requireSonarUnderWater &amp;&amp;
@@ -111,11 +95,7 @@
 			}
 			const int gx = (int)(unit-&gt;pos.x * invLosDiv);
 			const int gz = (int)(unit-&gt;pos.z * invLosDiv);
-			const int rowIdx = std::max(0, std::min(losSizeY - 1, gz));
-			const int colIdx = std::max(0, std::min(losSizeX - 1, gx));
-			const int square = (rowIdx * losSizeX) + colIdx;
-			assert(static_cast&lt;unsigned&gt;(square) &lt; losMap[allyTeam].size());
-			return !!losMap[allyTeam][square];
+			return !!losMap[allyTeam].At(gx, gz);
 		}
 	}
 
@@ -123,32 +103,26 @@
 		if (gs-&gt;globalLOS) {
 			return true;
 		}
-		pos.CheckInBounds();
-		const int square = ((int)(pos.z * invLosDiv)) * losSizeX
-		                 + ((int)(pos.x * invLosDiv));
-		assert(static_cast&lt;unsigned&gt;(square) &lt; losMap[allyTeam].size());
-		return !!losMap[allyTeam][square];
+		const int gx = (int)(pos.x * invLosDiv);
+		const int gz = (int)(pos.z * invLosDiv);
+		return !!losMap[allyTeam].At(gx, gz);
 	}
 
 	bool InAirLos(float3 pos, int allyTeam) {
 		if (gs-&gt;globalLOS) {
 			return true;
 		}
-		pos.CheckInBounds();
-		const int square = ((int)(pos.z * invAirDiv)) * airSizeX
-		                 + ((int)(pos.x * invAirDiv));
-		assert(static_cast&lt;unsigned&gt;(square) &lt; airLosMap[allyTeam].size());
-		return !!airLosMap[allyTeam][square];
+		const int gx = (int)(pos.x * invAirDiv);
+		const int gz = (int)(pos.z * invAirDiv);
+		return !!airLosMap[allyTeam].At(gx, gz);
 	}
 
 	CLosHandler();
 	~CLosHandler();
 
-	vector&lt;unsigned short&gt; losMap[MAX_TEAMS];
-	vector&lt;unsigned short&gt; airLosMap[MAX_TEAMS];
+	CLosMap losMap[MAX_TEAMS];
+	CLosMap airLosMap[MAX_TEAMS];
 
-	friend class CRadarHandler;
-
 	const int losMipLevel;
 	const int airMipLevel;
 	const int losDiv;
@@ -163,15 +137,14 @@
 	const bool requireSonarUnderWater;
 
 private:
-
 	void PostLoad();
-	void SafeLosAdd(LosInstance* instance,int xm,int ym);
 	void LosAdd(LosInstance* instance);
 	int GetHashNum(CUnit* unit);
 	void AllocInstance(LosInstance* instance);
 	void CleanupInstance(LosInstance* instance);
-	void LosAddAir(LosInstance* instance);
 
+	CLosAlgorithm losAlgo;
+
 	std::list&lt;LosInstance*&gt; instanceHash[2309+1];
 
 	std::deque&lt;LosInstance*&gt; toBeDeleted;
@@ -184,35 +157,6 @@
 
 	std::deque&lt;DelayedInstance&gt; delayQue;
 
-	struct CPoint {
-		CR_DECLARE_STRUCT(CPoint);
-
-		CPoint(){};
-		CPoint(int x,int y):x(x),y(y){};
-
-		int x;
-		int y;
-
-		int operator &lt; (const CPoint &amp;a) const
-		{
-			if(x!=a.x)
-				return x&lt;a.x;
-			else
-				return y&lt;a.y;
-		}
-	};
-	typedef std::list&lt;CPoint&gt; TPoints;
-	TPoints Points;
-
-	typedef std::vector&lt;CPoint&gt; LosLine;
-	typedef std::vector&lt;LosLine&gt; LosTable;
-
-	std::vector&lt;LosTable&gt; lostables;
-
-	int Round(float num);
-	void DrawLine(char* PaintTable, int x,int y,int Size);
-	LosLine OutputLine(int x,int y,int line);
-	void OutputTable(int table);
 public:
 	void Update(void);
 	void DelayedFreeInstance(LosInstance* instance);

Copied: branches/caiinterface/rts/Sim/Misc/LosMap.cpp (from rev 7161, trunk/rts/Sim/Misc/LosMap.cpp)
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosMap.cpp	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Misc/LosMap.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -0,0 +1,335 @@
+/* Author: Tobi Vollebregt */
+/* based on original los code in LosHandler.{cpp,h} and RadarHandler.{cpp,h} */
+
+#include &quot;StdAfx.h&quot;
+#include &quot;LosMap.h&quot;
+#include &quot;float3.h&quot;
+#include &lt;algorithm&gt;
+
+
+//////////////////////////////////////////////////////////////////////
+
+
+void CLosMap::SetSize(int2 newSize)
+{
+	size = newSize;
+	map.clear();
+	map.resize(size.x * size.y, 0);
+}
+
+
+void CLosMap::AddMapArea(int2 pos, int radius, int amount)
+{
+	const int sx = std::max(0, pos.x - radius);
+	const int ex = std::min(size.x - 1, pos.x + radius);
+	const int sy = std::max(0, pos.y - radius);
+	const int ey = std::min(size.y - 1, pos.y + radius);
+
+	const int rr = (radius * radius);
+
+	for (int y = sy; y &lt;= ey; ++y) {
+		const int rrx = rr - ((pos.y - y) * (pos.y - y));
+		for (int x = sx; x &lt;= ex; ++x) {
+			if (((pos.x - x) * (pos.x - x)) &lt;= rrx) {
+				map[(y * size.x) + x] += amount;
+			}
+		}
+	}
+}
+
+
+void CLosMap::AddMapSquares(const std::vector&lt;int&gt;&amp; squares, int amount)
+{
+	std::vector&lt;int&gt;::const_iterator lsi;
+	for (lsi = squares.begin(); lsi != squares.end(); ++lsi) {
+		map[*lsi] += amount;
+	}
+}
+
+
+//////////////////////////////////////////////////////////////////////
+namespace {
+//////////////////////////////////////////////////////////////////////
+
+
+#define MAX_LOS_TABLE 110
+
+typedef std::vector&lt;int2&gt; TPoints;
+typedef std::vector&lt;int2&gt; LosLine;
+typedef std::vector&lt;LosLine&gt; LosTable;
+
+
+class CLosTables
+{
+public:
+	static const LosTable&amp; GetForLosSize(int losSize) {
+		static CLosTables instance;
+		const int tablenum = std::min(MAX_LOS_TABLE, losSize);
+		return instance.lostables[tablenum - 1];
+	}
+
+private:
+	std::vector&lt;LosTable&gt; lostables;
+
+	CLosTables();
+	int Round(float num);
+	void DrawLine(char* PaintTable, int x,int y,int Size);
+	LosLine OutputLine(int x,int y,int line);
+	void OutputTable(int table);
+};
+
+
+CLosTables::CLosTables()
+{
+	for (int a = 1; a &lt;= MAX_LOS_TABLE; ++a) {
+		OutputTable(a);
+	}
+}
+
+
+struct int2_comparer
+{
+	bool operator () (const int2&amp; a, const int2&amp; b) const
+	{
+		if (a.x != b.x)
+			return a.x &lt; b.x;
+		else
+			return a.y &lt; b.y;
+	}
+};
+
+
+void CLosTables::OutputTable(int Table)
+{
+	TPoints Points;
+	LosTable lostable;
+
+	int Radius = Table;
+	char* PaintTable = SAFE_NEW char[(Radius+1)*Radius];
+	memset(PaintTable, 0 , (Radius+1)*Radius);
+	int2 P;
+
+	int x, y, r2;
+
+	P.x = 0;
+	P.y = Radius;
+	Points.push_back(P);
+//  DrawLine(0, Radius, Radius);
+	for(float i=Radius; i&gt;=1; i-=0.5f) {
+		r2 = (int)(i * i);
+
+		y = (int)i;
+		x = 1;
+		y = (int) (sqrt((float)r2 - 1) + 0.5f);
+		while (x &lt; y) {
+			if(!PaintTable[x+y*Radius]) {
+				DrawLine(PaintTable, x, y, Radius);
+				P.x = x;
+				P.y = y;
+				Points.push_back(P);
+			}
+			if(!PaintTable[y+x*Radius]) {
+				DrawLine(PaintTable, y, x, Radius);
+				P.x = y;
+				P.y = x;
+				Points.push_back(P);
+			}
+
+			x += 1;
+			y = (int) (sqrt((float)r2 - x*x) + 0.5f);
+		}
+		if (x == y) {
+			if(!PaintTable[x+y*Radius]) {
+				DrawLine(PaintTable, x, y, Radius);
+				P.x = x;
+				P.y = y;
+				Points.push_back(P);
+			}
+		}
+	}
+
+	std::sort(Points.begin(), Points.end(), int2_comparer());
+
+	int Line = 1;
+	int Size = Points.size();
+	for(int j=0; j&lt;Size; j++) {
+		lostable.push_back(OutputLine(Points.back().x, Points.back().y, Line));
+		Points.pop_back();
+		Line++;
+	}
+
+	lostables.push_back(lostable);
+
+	delete[] PaintTable;
+}
+
+
+LosLine CLosTables::OutputLine(int x, int y, int Line)
+{
+	LosLine losline;
+
+	int x0 = 0;
+	int y0 = 0;
+	int dx = x;
+	int dy = y;
+
+	if (abs(dx) &gt; abs(dy)) {                    // slope &lt;1
+		float m = (float) dy / (float) dx;      // compute slope
+		float b = y0 - m*x0;
+		dx = (dx &lt; 0) ? -1 : 1;
+		while (x0 != x) {
+			x0 += dx;
+			losline.push_back(int2(x0, Round(m*x0 + b)));
+		}
+	} else if (dy != 0) {                       // slope = 1
+		float m = (float) dx / (float) dy;      // compute slope
+		float b = x0 - m*y0;
+		dy = (dy &lt; 0) ? -1 : 1;
+		while (y0 != y) {
+			y0 += dy;
+			losline.push_back(int2(Round(m*y0 + b), y0));
+		}
+	}
+	return losline;
+}
+
+
+void CLosTables::DrawLine(char* PaintTable, int x, int y, int Size)
+{
+	int x0 = 0;
+	int y0 = 0;
+	int dx = x;
+	int dy = y;
+
+	if (abs(dx) &gt; abs(dy)) {                    // slope &lt;1
+		float m = (float) dy / (float) dx;      // compute slope
+		float b = y0 - m*x0;
+		dx = (dx &lt; 0) ? -1 : 1;
+		while (x0 != x) {
+			x0 += dx;
+			PaintTable[x0+Round(m*x0 + b)*Size] = 1;
+		}
+	} else if (dy != 0) {                       // slope = 1
+		float m = (float) dx / (float) dy;      // compute slope
+		float b = x0 - m*y0;
+		dy = (dy &lt; 0) ? -1 : 1;
+		while (y0 != y) {
+			y0 += dy;
+			PaintTable[Round(m*y0 + b)+y0*Size] = 1;
+		}
+	}
+}
+
+
+int CLosTables::Round(float Num)
+{
+	if ((Num - (int)Num) &lt; 0.5f)
+		return (int)Num;
+	else
+		return (int)Num+1;
+}
+
+
+//////////////////////////////////////////////////////////////////////
+}; // end of anon namespace
+//////////////////////////////////////////////////////////////////////
+
+
+void CLosAlgorithm::LosAdd(int2 pos, int radius, float baseHeight, std::vector&lt;int&gt;&amp; squares)
+{
+	pos.x = std::max(0, std::min(size.x - 1, pos.x));
+	pos.y = std::max(0, std::min(size.y - 1, pos.y));
+
+	if ((pos.x - radius &lt; 0) || (pos.x + radius &gt;= size.x) ||
+	    (pos.y - radius &lt; 0) || (pos.y + radius &gt;= size.y)) {
+		SafeLosAdd(pos, radius, baseHeight, squares);
+	} else {
+		UnsafeLosAdd(pos, radius, baseHeight, squares);
+	}
+}
+
+
+#define MAP_SQUARE(pos) \
+	((pos).y * size.x + (pos).x)
+
+#define LOS_ADD(_square, _maxAng) \
+	{ \
+		const int square = _square; \
+		const float dh = heightmap[square] - baseHeight; \
+		float ang = (dh + extraHeight) * invR; \
+		if(ang &gt; _maxAng) { \
+			squares.push_back(square); \
+			ang = dh * invR; \
+			if(ang &gt; _maxAng) _maxAng = ang; \
+		} \
+	}
+
+
+void CLosAlgorithm::UnsafeLosAdd(int2 pos, int radius, float baseHeight, std::vector&lt;int&gt;&amp; squares)
+{
+	const int mapSquare = MAP_SQUARE(pos);
+	const LosTable&amp; table = CLosTables::GetForLosSize(radius);
+
+	baseHeight += heightmap[mapSquare];
+
+	squares.push_back(mapSquare);
+
+	for(LosTable::const_iterator li = table.begin(); li != table.end(); ++li) {
+		const LosLine&amp; line = *li;
+		float maxAng1 = minMaxAng;
+		float maxAng2 = minMaxAng;
+		float maxAng3 = minMaxAng;
+		float maxAng4 = minMaxAng;
+		float r = 1;
+
+		for(LosLine::const_iterator linei = line.begin(); linei != line.end(); ++linei) {
+			const float invR = 1.0f / r;
+
+			LOS_ADD(mapSquare + linei-&gt;x + linei-&gt;y * size.x, maxAng1);
+			LOS_ADD(mapSquare - linei-&gt;x - linei-&gt;y * size.x, maxAng2);
+			LOS_ADD(mapSquare - linei-&gt;x * size.x + linei-&gt;y, maxAng3);
+			LOS_ADD(mapSquare + linei-&gt;x * size.x - linei-&gt;y, maxAng4);
+
+			r++;
+		}
+	}
+}
+
+
+void CLosAlgorithm::SafeLosAdd(int2 pos, int radius, float baseHeight, std::vector&lt;int&gt;&amp; squares)
+{
+	const int mapSquare = MAP_SQUARE(pos);
+	const LosTable&amp; table = CLosTables::GetForLosSize(radius);
+
+	baseHeight += heightmap[mapSquare];
+
+	squares.push_back(mapSquare);
+
+	for (LosTable::const_iterator li = table.begin(); li != table.end(); ++li) {
+		const LosLine&amp; line = *li;
+		float maxAng1 = minMaxAng;
+		float maxAng2 = minMaxAng;
+		float maxAng3 = minMaxAng;
+		float maxAng4 = minMaxAng;
+		float r = 1;
+
+		for(LosLine::const_iterator linei = line.begin(); linei != line.end(); ++linei) {
+			const float invR = 1.0f / r;
+
+			if ((pos.x + linei-&gt;x &lt; size.x) &amp;&amp; (pos.y + linei-&gt;y &lt; size.y)) {
+				LOS_ADD(mapSquare + linei-&gt;x + linei-&gt;y * size.x, maxAng1);
+			}
+			if ((pos.x - linei-&gt;x &gt;= 0) &amp;&amp; (pos.y - linei-&gt;y &gt;= 0)) {
+				LOS_ADD(mapSquare - linei-&gt;x - linei-&gt;y * size.x, maxAng2);
+			}
+			if ((pos.x + linei-&gt;y &lt; size.x) &amp;&amp; (pos.y - linei-&gt;x &gt;= 0)) {
+				LOS_ADD(mapSquare - linei-&gt;x * size.x + linei-&gt;y, maxAng3);
+			}
+			if ((pos.x - linei-&gt;y &gt;= 0) &amp;&amp; (pos.y + linei-&gt;x &lt; size.y)) {
+				LOS_ADD(mapSquare + linei-&gt;x * size.x - linei-&gt;y, maxAng4);
+			}
+
+			r++;
+		}
+	}
+}

Copied: branches/caiinterface/rts/Sim/Misc/LosMap.h (from rev 7161, trunk/rts/Sim/Misc/LosMap.h)
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosMap.h	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Misc/LosMap.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -0,0 +1,63 @@
+/* Author: Tobi Vollebregt */
+/* based on original los code in LosHandler.{cpp,h} and RadarHandler.{cpp,h} */
+
+#ifndef LOSMAP_H
+#define LOSMAP_H
+
+#include &lt;vector&gt;
+#include &quot;Vec2.h&quot;
+
+
+/// map containing counts of how many units have Line Of Sight (LOS) to each square
+class CLosMap
+{
+public:
+	CLosMap() : size(0, 0) {}
+
+	void SetSize(int2 size);
+	void SetSize(int w, int h) { SetSize(int2(w, h)); }
+
+	/// circular area, for airLosMap, circular radar maps, jammer maps, ...
+	void AddMapArea(int2 pos, int radius, int amount);
+
+	/// arbitrary area, for losMap, non-circular radar maps, ...
+	void AddMapSquares(const std::vector&lt;int&gt;&amp; squares, int amount);
+
+	int operator[] (int square) const { return map[square]; }
+
+	int At(int x, int y) const {
+		x = std::max(0, std::min(size.x - 1, x));
+		y = std::max(0, std::min(size.y - 1, y));
+		return map[y * size.x + x];
+	}
+
+	// temp fix for CBaseGroundDrawer and AI interface, which need raw data
+	unsigned short&amp; front() { return map.front(); }
+
+protected:
+
+	int2 size;
+	std::vector&lt;unsigned short&gt; map;
+};
+
+
+/// algorithm to calculate LOS squares using raycasting, taking terrain into account
+class CLosAlgorithm
+{
+public:
+	CLosAlgorithm(int2 size, float minMaxAng, float extraHeight, const float* heightmap)
+	: size(size), minMaxAng(minMaxAng), extraHeight(extraHeight), heightmap(heightmap) {}
+
+	void LosAdd(int2 pos, int radius, float baseHeight, std::vector&lt;int&gt;&amp; squares);
+
+private:
+	void UnsafeLosAdd(int2 pos, int radius, float baseHeight, std::vector&lt;int&gt;&amp; squares);
+	void SafeLosAdd(int2 pos, int radius, float baseHeight, std::vector&lt;int&gt;&amp; squares);
+
+	const int2 size;
+	const float minMaxAng;
+	const float extraHeight;
+	const float* const heightmap;
+};
+
+#endif

Modified: branches/caiinterface/rts/Sim/Misc/RadarHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/RadarHandler.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Misc/RadarHandler.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -15,7 +15,7 @@
 	CR_SERIALIZER(Serialize),
 	// radarMaps, airRadarMaps, sonarMaps, jammerMaps, sonarJammerMaps,
 	// seismicMaps, commonJammerMap, commonSonarJammerMap
-	CR_MEMBER(circularRadar),
+	//CR_MEMBER(circularRadar),
 	CR_MEMBER(radarErrorSize),
 	CR_MEMBER(baseRadarErrorSize),
 	CR_MEMBER(xsize),
@@ -32,7 +32,7 @@
 {
 	const int size = xsize*zsize*2;
 
-	// NOTE This could be tricky if gs is serialized after radarHandler.
+	// NOTE This could be tricky if teamHandler is serialized after radarHandler.
 	for (int a = 0; a &lt; teamHandler-&gt;ActiveAllyTeams(); ++a) {
 		s.Serialize(&amp;radarMaps[a].front(), size);
 		if (!circularRadar) {
@@ -51,25 +51,27 @@
 
 
 CRadarHandler::CRadarHandler(bool circularRadar)
-: circularRadar(circularRadar),
+: radarMipLevel(3),
+  radarDiv(SQUARE_SIZE * (1 &lt;&lt; radarMipLevel)),
+  invRadarDiv(1.0f / radarDiv),
+  circularRadar(circularRadar),
   baseRadarErrorSize(96),
-  xsize(gs-&gt;mapx / RADAR_SIZE),
-  zsize(gs-&gt;mapy / RADAR_SIZE),
-  targFacEffect(2)
+  xsize(std::max(1, gs-&gt;mapx &gt;&gt; radarMipLevel)),
+  zsize(std::max(1, gs-&gt;mapy &gt;&gt; radarMipLevel)),
+  targFacEffect(2),
+  radarAlgo(int2(xsize, zsize), -1000, 20, readmap-&gt;mipHeightmap[radarMipLevel])
 {
-	const int size = xsize * zsize;
+	commonJammerMap.SetSize(xsize, zsize);
+	commonSonarJammerMap.SetSize(xsize, zsize);
 
-	commonJammerMap.resize(size, 0);
-	commonSonarJammerMap.resize(size, 0);
-
 	for (int a = 0; a &lt; teamHandler-&gt;ActiveAllyTeams(); ++a) {
-		radarMaps[a].resize(size, 0);
-		sonarMaps[a].resize(size, 0);
-		seismicMaps[a].resize(size, 0);
-		airRadarMaps[a].resize(size, 0);
-		jammerMaps[a].resize(size, 0);
+		radarMaps[a].SetSize(xsize, zsize);
+		sonarMaps[a].SetSize(xsize, zsize);
+		seismicMaps[a].SetSize(xsize, zsize);
+		airRadarMaps[a].SetSize(xsize, zsize);
+		jammerMaps[a].SetSize(xsize, zsize);
 #ifdef SONAR_JAMMER_MAPS
-		sonarJammerMaps[a].resize(size, 0);
+		sonarJammerMaps[a].SetSize(xsize, zsize);
 #endif
 		radarErrorSize[a] = 96;
 	}
@@ -85,34 +87,35 @@
 void CRadarHandler::MoveUnit(CUnit* unit)
 {
 	int2 newPos;
-	newPos.x = (int) (unit-&gt;pos.x / (SQUARE_SIZE * RADAR_SIZE));
-	newPos.y = (int) (unit-&gt;pos.z / (SQUARE_SIZE * RADAR_SIZE));
+	newPos.x = (int) (unit-&gt;pos.x * invRadarDiv);
+	newPos.y = (int) (unit-&gt;pos.z * invRadarDiv);
 
 	if ((newPos.x != unit-&gt;oldRadarPos.x) ||
 	    (newPos.y != unit-&gt;oldRadarPos.y)) {
 		RemoveUnit(unit);
 		SCOPED_TIMER(&quot;Radar&quot;);
 		if (unit-&gt;jammerRadius) {
-			AddMapArea(newPos, unit-&gt;jammerRadius, jammerMaps[unit-&gt;allyteam], 1);
-			AddMapArea(newPos, unit-&gt;jammerRadius, commonJammerMap, 1);
+			jammerMaps[unit-&gt;allyteam].AddMapArea(newPos, unit-&gt;jammerRadius, 1);
+			commonJammerMap.AddMapArea(newPos, unit-&gt;jammerRadius, 1);
 		}
 		if (unit-&gt;sonarJamRadius) {
 #ifdef SONAR_JAMMER_MAPS
-			AddMapArea(newPos, unit-&gt;sonarJamRadius, sonarJammerMaps[unit-&gt;allyteam], 1);
+			sonarJammerMaps[unit-&gt;allyteam].AddMapArea(newPos, unit-&gt;sonarJamRadius, 1);
 #endif
-			AddMapArea(newPos, unit-&gt;sonarJamRadius, commonSonarJammerMap, 1);
+			commonSonarJammerMap.AddMapArea(newPos, unit-&gt;sonarJamRadius, 1);
 		}
 		if (unit-&gt;radarRadius) {
-			AddMapArea(newPos, unit-&gt;radarRadius, airRadarMaps[unit-&gt;allyteam], 1);
+			airRadarMaps[unit-&gt;allyteam].AddMapArea(newPos, unit-&gt;radarRadius, 1);
 			if (!circularRadar) {
-				SafeLosRadarAdd(unit);
+				radarAlgo.LosAdd(newPos, unit-&gt;radarRadius, unit-&gt;model-&gt;height, unit-&gt;radarSquares);
+				radarMaps[unit-&gt;allyteam].AddMapSquares(unit-&gt;radarSquares, 1);
 			}
 		}
 		if (unit-&gt;sonarRadius) {
-			AddMapArea(newPos, unit-&gt;sonarRadius, sonarMaps[unit-&gt;allyteam], 1);
+			sonarMaps[unit-&gt;allyteam].AddMapArea(newPos, unit-&gt;sonarRadius, 1);
 		}
 		if (unit-&gt;seismicRadius) {
-			AddMapArea(newPos, unit-&gt;seismicRadius, seismicMaps[unit-&gt;allyteam], 1);
+			seismicMaps[unit-&gt;allyteam].AddMapArea(newPos, unit-&gt;seismicRadius, 1);
 		}
 		unit-&gt;oldRadarPos = newPos;
 	}
@@ -125,150 +128,28 @@
 
 	if (unit-&gt;oldRadarPos.x &gt;= 0) {
 		if (unit-&gt;jammerRadius) {
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;jammerRadius, jammerMaps[unit-&gt;allyteam], -1);
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;jammerRadius, commonJammerMap, -1);
+			jammerMaps[unit-&gt;allyteam].AddMapArea(unit-&gt;oldRadarPos, unit-&gt;jammerRadius, -1);
+			commonJammerMap.AddMapArea(unit-&gt;oldRadarPos, unit-&gt;jammerRadius, -1);
 		}
 		if (unit-&gt;sonarJamRadius) {
 #ifdef SONAR_JAMMER_MAPS
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarJamRadius, sonarJammerMaps[unit-&gt;allyteam], -1);
+			sonarJammerMaps[unit-&gt;allyteam].AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarJamRadius, -1);
 #endif
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarJamRadius, commonSonarJammerMap, -1);
+			commonSonarJammerMap.AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarJamRadius, -1);
 		}
 		if (unit-&gt;radarRadius) {
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;radarRadius, airRadarMaps[unit-&gt;allyteam], -1);
+			airRadarMaps[unit-&gt;allyteam].AddMapArea(unit-&gt;oldRadarPos, unit-&gt;radarRadius, -1);
 			if (!circularRadar) {
-				for(std::vector&lt;int&gt;::iterator ri = unit-&gt;radarSquares.begin(); ri != unit-&gt;radarSquares.end(); ++ri) {
-					--radarMaps[unit-&gt;allyteam][*ri];
-				}
+				radarMaps[unit-&gt;allyteam].AddMapSquares(unit-&gt;radarSquares, -1);
 				unit-&gt;radarSquares.clear();
 			}
 		}
 		if (unit-&gt;sonarRadius) {
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarRadius, sonarMaps[unit-&gt;allyteam], -1);
+			sonarMaps[unit-&gt;allyteam].AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarRadius, -1);
 		}
 		if (unit-&gt;seismicRadius) {
-			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;seismicRadius, seismicMaps[unit-&gt;allyteam], -1);
+			seismicMaps[unit-&gt;allyteam].AddMapArea(unit-&gt;oldRadarPos, unit-&gt;seismicRadius, -1);
 		}
 		unit-&gt;oldRadarPos.x = -1;
 	}
 }
-
-
-void CRadarHandler::AddMapArea(int2 pos, int radius, std::vector&lt;unsigned short&gt;&amp; map, int amount)
-{
-	const int sx = std::max(0, pos.x - radius);
-	const int ex = std::min(xsize - 1, pos.x + radius);
-	const int sy = std::max(0, pos.y - radius);
-	const int ey = std::min(zsize - 1, pos.y + radius);
-
-	const int rr = (radius * radius);
-
-	for (int y = sy; y &lt;= ey; ++y) {
-		const int rrx = rr - ((pos.y - y) * (pos.y - y));
-		for (int x = sx; x &lt;= ex; ++x) {
-			if (((pos.x - x) * (pos.x - x)) &lt;= rrx) {
-				map[(y * xsize) + x] += amount;
-			}
-		}
-	}
-}
-
-
-void CRadarHandler::SafeLosRadarAdd(CUnit* unit)
-{
-	float3 pos = unit-&gt;pos;
-	pos.CheckInBounds();
-	int xradar = (int) (pos.x / (SQUARE_SIZE * RADAR_SIZE));
-	int yradar = (int) (pos.z / (SQUARE_SIZE * RADAR_SIZE));
-	int xmap = (int) (pos.x / (SQUARE_SIZE * 2));
-	int ymap = (int) (pos.z / (SQUARE_SIZE * 2));
-	int allyteam = unit-&gt;allyteam;
-
-	int tablenum = unit-&gt;radarRadius;
-	if (tablenum &gt; MAX_LOS_TABLE) {
-		tablenum = MAX_LOS_TABLE;
-	}
-	CLosHandler::LosTable&amp; table = loshandler-&gt;lostables[tablenum-1];
-
-	CLosHandler::LosTable::iterator li;
-	for (li = table.begin(); li != table.end(); ++li) {
-		CLosHandler::LosLine&amp; line = *li;
-		CLosHandler::LosLine::iterator linei;
-		float baseHeight = pos.y + unit-&gt;model-&gt;height - 20;
-		float maxAng1 = -1000;
-		float maxAng2 = -1000;
-		float maxAng3 = -1000;
-		float maxAng4 = -1000;
-		float r = 1;
-		unit-&gt;radarSquares.push_back(yradar * xsize + xradar);
-		radarMaps[allyteam][yradar * xsize + xradar]++;
-
-		for (linei = line.begin(); linei != line.end(); ++linei) {
-			if (((xradar + linei-&gt;x) &lt; xsize) &amp;&amp;
-			    ((yradar + linei-&gt;y) &lt; zsize)) {
-				int rsquare = (xradar + linei-&gt;x) + (yradar + linei-&gt;y) * xsize;
-				int msquare = (xmap + linei-&gt;x * 4) + (ymap + linei-&gt;y * 4) * gs-&gt;hmapx;
-				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
-				float ang = dh / r;
-				if (ang &gt; maxAng1) {
-					unit-&gt;radarSquares.push_back(rsquare);
-					radarMaps[allyteam][rsquare]++;
-				}
-				dh -= 20;
-				ang = dh / r;
-				if (ang &gt; maxAng1) {
-					maxAng1 = ang;
-				}
-			}
-			if (((xradar - linei-&gt;x) &gt;= 0) &amp;&amp;
-			    ((yradar - linei-&gt;y) &gt;= 0)) {
-				int rsquare = (xradar - linei-&gt;x) + (yradar - linei-&gt;y) * xsize;
-				int msquare = (xmap - linei-&gt;x*4) + (ymap - linei-&gt;y * 4) * gs-&gt;hmapx;
-				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
-				float ang = dh / r;
-				if (ang &gt; maxAng2) {
-					unit-&gt;radarSquares.push_back(rsquare);
-					radarMaps[allyteam][rsquare]++;
-				}
-				dh -= 20;
-				ang = dh / r;
-				if (ang &gt; maxAng2) {
-					maxAng2 = ang;
-				}
-			}
-			if (((xradar + linei-&gt;y) &lt; xsize) &amp;&amp;
-			    ((yradar - linei-&gt;x) &gt;= 0)) {
-				int rsquare = (xradar + linei-&gt;y) + (yradar - linei-&gt;x) * xsize;
-				int msquare = (xmap + linei-&gt;y * 4) + (ymap - linei-&gt;x * 4) * gs-&gt;hmapx;
-				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
-				float ang = dh / r;
-				if (ang &gt; maxAng3) {
-					unit-&gt;radarSquares.push_back(rsquare);
-					radarMaps[allyteam][rsquare]++;
-				}
-				dh -= 20;
-				ang = dh / r;
-				if (ang &gt; maxAng3) {
-					maxAng3 = ang;
-				}
-			}
-			if (((xradar - linei-&gt;y) &gt;= 0) &amp;&amp;
-			    ((yradar + linei-&gt;x) &lt; zsize)) {
-				int rsquare = (xradar - linei-&gt;y) + (yradar + linei-&gt;x) * xsize;
-				int msquare = (xmap - linei-&gt;y * 4) + (ymap + linei-&gt;x * 4) * gs-&gt;hmapx;
-				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
-				float ang = dh / r;
-				if (ang&gt;maxAng4) {
-					unit-&gt;radarSquares.push_back(rsquare);
-					radarMaps[allyteam][rsquare]++;
-				}
-				dh -= 20;
-				ang = dh / r;
-				if (ang &gt; maxAng4) {
-					maxAng4 = ang;
-				}
-			}
-			r++;
-		}
-	}
-}

Modified: branches/caiinterface/rts/Sim/Misc/RadarHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/RadarHandler.h	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Misc/RadarHandler.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -4,12 +4,10 @@
 #include &lt;boost/noncopyable.hpp&gt;
 
 #include &quot;Object.h&quot;
+#include &quot;Sim/Misc/LosMap.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &lt;assert.h&gt;
 
-#define RADAR_SIZE 8
-
-
 // Because submerged units are only given LOS if they are also
 // in sonar range (see LosHandler.h), sonar stealth and sonar
 // jammed units can not be detected (probably why those 2 features
@@ -34,8 +32,8 @@
 
 	inline int GetSquare(const float3&amp; pos) const
 	{
-		const int gx = (int)pos.x / (SQUARE_SIZE * RADAR_SIZE);
-		const int gz = (int)pos.z / (SQUARE_SIZE * RADAR_SIZE);
+		const int gx = (int)(pos.x * invRadarDiv);
+		const int gz = (int)(pos.z * invRadarDiv);
 		const int rowIdx = std::max(0, std::min(zsize - 1, gz));
 		const int colIdx = std::max(0, std::min(xsize - 1, gx));
 		return (rowIdx * xsize) + colIdx;
@@ -44,27 +42,22 @@
 	bool InRadar(const float3&amp; pos, int allyTeam) {
 		const int square = GetSquare(pos);
 		if (pos.y &lt; -0.5f) {
-			assert(static_cast&lt;unsigned&gt;(square) &lt; sonarMaps[allyTeam].size());
 			return (sonarMaps[allyTeam][square] &amp;&amp; !commonSonarJammerMap[square]);
 		}
 		else if (!circularRadar &amp;&amp; (pos.y &gt; 0.5f)) {
-			assert(static_cast&lt;unsigned&gt;(square) &lt; airRadarMaps[allyTeam].size());
 			return (airRadarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square]);
 		}
 		else {
-			assert(static_cast&lt;unsigned&gt;(square) &lt; radarMaps[allyTeam].size());
 			return (radarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square]);
 		}
 	}
 
 	bool InRadar(const CUnit* unit, int allyTeam) {
-
 		if (unit-&gt;isUnderWater) {
 			if (unit-&gt;sonarStealth) {
 				return false;
 			}
 			const int square = GetSquare(unit-&gt;pos);
-			assert(static_cast&lt;unsigned&gt;(square) &lt; sonarMaps[allyTeam].size());
 			return !!sonarMaps[allyTeam][square] &amp;&amp; !commonSonarJammerMap[square];
 		}
 		else if (!circularRadar &amp;&amp; unit-&gt;useAirLos) {
@@ -72,13 +65,10 @@
 				return false;
 			}
 			const int square = GetSquare(unit-&gt;pos);
-			assert(static_cast&lt;unsigned&gt;(square) &lt; airRadarMaps[allyTeam].size());
 			return airRadarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square];
 		}
 		else {
 			const int square = GetSquare(unit-&gt;pos);
-			assert((static_cast&lt;unsigned&gt;(square) &lt; radarMaps[allyTeam].size()) &amp;&amp;
-					(static_cast&lt;unsigned&gt;(square) &lt; sonarMaps[allyTeam].size()));
 			return (radarMaps[allyTeam][square]
 			        &amp;&amp; !unit-&gt;stealth
 			        &amp;&amp; !commonJammerMap[square])
@@ -92,22 +82,24 @@
 
 	bool InSeismicDistance(const CUnit* unit, int allyTeam) {
 		const int square = GetSquare(unit-&gt;pos);
-		assert(static_cast&lt;unsigned&gt;(square) &lt; seismicMaps[allyTeam].size());
 		return !!seismicMaps[allyTeam][square];
 	}
 
-	bool circularRadar;
+	const int radarMipLevel;
+	const int radarDiv;
+	const float invRadarDiv;
+	const bool circularRadar;
 
-	std::vector&lt;unsigned short&gt; radarMaps[MAX_TEAMS];
-	std::vector&lt;unsigned short&gt; airRadarMaps[MAX_TEAMS];
-	std::vector&lt;unsigned short&gt; sonarMaps[MAX_TEAMS];
-	std::vector&lt;unsigned short&gt; jammerMaps[MAX_TEAMS];
+	CLosMap radarMaps[MAX_TEAMS];
+	CLosMap airRadarMaps[MAX_TEAMS];
+	CLosMap sonarMaps[MAX_TEAMS];
+	CLosMap jammerMaps[MAX_TEAMS];
 #ifdef SONAR_JAMMER_MAPS
-	std::vector&lt;unsigned short&gt; sonarJammerMaps[MAX_TEAMS];
+	CLosMap sonarJammerMaps[MAX_TEAMS];
 #endif
-	std::vector&lt;unsigned short&gt; seismicMaps[MAX_TEAMS];
-	std::vector&lt;unsigned short&gt; commonJammerMap;
-	std::vector&lt;unsigned short&gt; commonSonarJammerMap;
+	CLosMap seismicMaps[MAX_TEAMS];
+	CLosMap commonJammerMap;
+	CLosMap commonSonarJammerMap;
 	float radarErrorSize[MAX_TEAMS];
 	float baseRadarErrorSize;
 
@@ -116,12 +108,9 @@
 
 	float targFacEffect;
 
-protected:
-	void AddMapArea(int2 pos, int radius, std::vector&lt;unsigned short&gt;&amp; map, int amount);
-
-	void SafeLosRadarAdd(CUnit* unit);
-
 private:
+	CLosAlgorithm radarAlgo;
+
 	void Serialize(creg::ISerializer&amp; s);
 };
 

Modified: branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -188,7 +188,7 @@
 		pos += norm * 0.1f;
 	} else {
 		if (flags &amp; PP_Explode) {
-			helper-&gt;Explosion(pos, DamageArray() * 50, 5, 0, 10, owner, false, 1.0f, false, 0, 0, ZeroVector, -1);
+			helper-&gt;Explosion(pos, DamageArray() * 50, 5, 0, 10, owner, false, 1.0f, false, false, 0, 0, ZeroVector, -1);
 		}
 		if (flags &amp; PP_Smoke) {
 			if (flags &amp; PP_NoCEGTrail) {
@@ -212,7 +212,7 @@
 	if (unit == owner)
 		return;
 	if (flags &amp; PP_Explode) {
-		helper-&gt;Explosion(pos, DamageArray() * 50, 5, 0, 10, owner, false, 1.0f, false, 0, unit, ZeroVector, -1);
+		helper-&gt;Explosion(pos, DamageArray() * 50, 5, 0, 10, owner, false, 1.0f, false, false, 0, unit, ZeroVector, -1);
 	}
 	if (flags &amp; PP_Smoke) {
 		if (flags &amp; PP_NoCEGTrail) {

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -130,22 +130,13 @@
 					weaponDef-&gt;dynDamageExp, weaponDef-&gt;dynDamageMin,
 					weaponDef-&gt;dynDamageInverted);
 
-		if (weaponDef-&gt;impactOnly) {
-			if (weaponDef-&gt;explosionGenerator) {
-				weaponDef-&gt;explosionGenerator-&gt;Explosion(pos,((weaponDef-&gt;dynDamageExp&gt;0)
-						? dynDamages : weaponDef-&gt;damages)[0],weaponDef-&gt;areaOfEffect,owner,0,NULL,impactDir);
-			}
-		} else {
-			helper-&gt;Explosion(pos,
-				(weaponDef-&gt;dynDamageExp &gt; 0)?
-					dynDamages:
-					weaponDef-&gt;damages,
-				weaponDef-&gt;areaOfEffect, weaponDef-&gt;edgeEffectiveness,
-				weaponDef-&gt;explosionSpeed, owner, true,
-				weaponDef-&gt;noExplode ? 0.3f : 1,
-				weaponDef-&gt;noExplode || weaponDef-&gt;noSelfDamage,
-				weaponDef-&gt;explosionGenerator, 0, impactDir, weaponDef-&gt;id);
-		}
+		helper-&gt;Explosion(pos,
+			(weaponDef-&gt;dynDamageExp &gt; 0) ? dynDamages : weaponDef-&gt;damages,
+			weaponDef-&gt;areaOfEffect, weaponDef-&gt;edgeEffectiveness,
+			weaponDef-&gt;explosionSpeed, owner, true,
+			weaponDef-&gt;noExplode ? 0.3f : 1,
+			weaponDef-&gt;noExplode || weaponDef-&gt;noSelfDamage, weaponDef-&gt;impactOnly,
+			weaponDef-&gt;explosionGenerator, 0, impactDir, weaponDef-&gt;id);
 	}
 
 	if (weaponDef-&gt;soundhit.getID(0) &gt; 0) {
@@ -193,23 +184,13 @@
 			damages = weaponDef-&gt;damages;
 		}
 
-		if (weaponDef-&gt;impactOnly) {
-			unit-&gt;DoDamage(
-				damages, owner,
-				impactDir * (damages[0] + weaponDef-&gt;damages.impulseBoost)
-				* weaponDef-&gt;damages.impulseFactor, weaponDef-&gt;id);
-			if (weaponDef-&gt;explosionGenerator) {
-				weaponDef-&gt;explosionGenerator-&gt;Explosion(pos,damages[0],weaponDef-&gt;areaOfEffect,owner,0,unit,impactDir);
-			}
-		}
-		else {
-		    helper-&gt;Explosion(pos, damages,
-				weaponDef-&gt;areaOfEffect, weaponDef-&gt;edgeEffectiveness,
-				weaponDef-&gt;explosionSpeed, owner, true,
-				weaponDef-&gt;noExplode ? 0.3f : 1,
-				weaponDef-&gt;noExplode || weaponDef-&gt;noSelfDamage, weaponDef-&gt;explosionGenerator, unit,
-				impactDir, weaponDef-&gt;id);
-		}
+		helper-&gt;Explosion(pos, damages,
+			weaponDef-&gt;areaOfEffect, weaponDef-&gt;edgeEffectiveness,
+			weaponDef-&gt;explosionSpeed, owner, true,
+			weaponDef-&gt;noExplode ? 0.3f : 1,
+			weaponDef-&gt;noExplode, weaponDef-&gt;impactOnly,
+			weaponDef-&gt;explosionGenerator, unit,
+			impactDir, weaponDef-&gt;id);
 	}
 
 	if (weaponDef-&gt;soundhit.getID(0) &gt; 0) {
@@ -353,5 +334,6 @@
 				modelDispList= model-&gt;rootobjects3o-&gt;displist;*/
 		}
 	}
+
 //	collisionFlags = weaponDef-&gt;collisionFlags;
 }

Modified: branches/caiinterface/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/COB/CobInstance.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/COB/CobInstance.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -734,7 +734,7 @@
 
 				helper-&gt;Explosion(
 					pos, weaponDef-&gt;damages, weaponDef-&gt;areaOfEffect, weaponDef-&gt;edgeEffectiveness,
-					weaponDef-&gt;explosionSpeed, unit, true, 1.0f, weaponDef-&gt;noSelfDamage, weaponDef-&gt;explosionGenerator,
+					weaponDef-&gt;explosionSpeed, unit, true, 1.0f, weaponDef-&gt;noSelfDamage, weaponDef-&gt;impactOnly, weaponDef-&gt;explosionGenerator,
 					NULL, float3(0, 0, 0), weaponDef-&gt;id
 				);
 			}

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -618,7 +618,7 @@
 
 void CAirCAI::DrawCommands(void)
 {
-	lineDrawer.StartPath(owner-&gt;pos, cmdColors.start);
+	lineDrawer.StartPath(owner-&gt;drawMidPos, cmdColors.start);
 
 	if (owner-&gt;selfDCountdown != 0) {
 		lineDrawer.DrawIconAtLastPos(CMD_SELFD);

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1340,7 +1340,7 @@
 		glSurfaceCircle(teamHandler-&gt;Team(owner-&gt;team)-&gt;startPos, uh-&gt;dgunRadius, 40);
 	}
 
-	lineDrawer.StartPath(owner-&gt;midPos, cmdColors.start);
+	lineDrawer.StartPath(owner-&gt;drawMidPos, cmdColors.start);
 
 	if (owner-&gt;selfDCountdown != 0) {
 		lineDrawer.DrawIconAtLastPos(CMD_SELFD);

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1257,7 +1257,7 @@
 
 void CCommandAI::DrawCommands(void)
 {
-	lineDrawer.StartPath(owner-&gt;midPos, cmdColors.start);
+	lineDrawer.StartPath(owner-&gt;drawMidPos, cmdColors.start);
 
 	if (owner-&gt;selfDCountdown != 0) {
 		lineDrawer.DrawIconAtLastPos(CMD_SELFD);

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/FactoryCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/FactoryCAI.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/FactoryCAI.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -453,7 +453,7 @@
 
 void CFactoryCAI::DrawCommands(void)
 {
-	lineDrawer.StartPath(owner-&gt;midPos, cmdColors.start);
+	lineDrawer.StartPath(owner-&gt;drawMidPos, cmdColors.start);
 
 	if (owner-&gt;selfDCountdown != 0) {
 		lineDrawer.DrawIconAtLastPos(CMD_SELFD);

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -918,7 +918,7 @@
 
 void CMobileCAI::DrawCommands(void)
 {
-	lineDrawer.StartPath(owner-&gt;midPos, cmdColors.start);
+	lineDrawer.StartPath(owner-&gt;drawMidPos, cmdColors.start);
 
 	if (owner-&gt;selfDCountdown != 0) {
 		lineDrawer.DrawIconAtLastPos(CMD_SELFD);

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -907,7 +907,7 @@
 
 void CTransportCAI::DrawCommands(void)
 {
-	lineDrawer.StartPath(owner-&gt;midPos, cmdColors.start);
+	lineDrawer.StartPath(owner-&gt;drawMidPos, cmdColors.start);
 
 	if (owner-&gt;selfDCountdown != 0) {
 		lineDrawer.DrawIconAtLastPos(CMD_SELFD);

Modified: branches/caiinterface/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1129,6 +1129,7 @@
 		drawPos = pos + (speed * gu-&gt;timeOffset);
 	}
 #endif
+	drawMidPos = drawPos + (midPos - pos);
 }
 /******************************************************************************/
 /******************************************************************************/
@@ -1172,15 +1173,13 @@
 			return CMatrix44f(interPos, -rightdir, updir, frontdir);
 		}
 	}
-	else {
-		// making local copies of vectors
-		float3 frontDir = GetVectorFromHeading(heading);
-		float3 upDir    = ground-&gt;GetSmoothNormal(pos.x, pos.z);
-		float3 rightDir = frontDir.cross(upDir);
-		rightDir.Normalize();
-		frontDir = upDir.cross(rightDir);
-		return CMatrix44f(interPos, -rightDir, upDir, frontDir);
-	}
+	// making local copies of vectors
+	float3 frontDir = GetVectorFromHeading(heading);
+	float3 upDir    = ground-&gt;GetSmoothNormal(pos.x, pos.z);
+	float3 rightDir = frontDir.cross(upDir);
+	rightDir.Normalize();
+	frontDir = upDir.cross(rightDir);
+	return CMatrix44f(interPos, -rightDir, upDir, frontDir);
 }
 
 
@@ -1401,6 +1400,7 @@
 		CCommandQueue&amp; buildCommands = facAI-&gt;commandQue;
 		CCommandQueue::iterator it;
 		std::vector&lt;Command&gt; clearCommands;
+		clearCommands.reserve(buildCommands.size());
 		for (it = buildCommands.begin(); it != buildCommands.end(); ++it) {
 			c.id = it-&gt;id;
 			clearCommands.push_back(c);
@@ -1913,7 +1913,7 @@
 				helper-&gt;Explosion(
 					midPos, wd-&gt;damages, wd-&gt;areaOfEffect, wd-&gt;edgeEffectiveness,
 					wd-&gt;explosionSpeed, this, true, wd-&gt;damages[0] &gt; 500 ? 1 : 2,
-					false, wd-&gt;explosionGenerator, 0, ZeroVector, wd-&gt;id
+					false, false, wd-&gt;explosionGenerator, 0, ZeroVector, wd-&gt;id
 				);
 
 				// play explosion sound
@@ -1921,7 +1921,7 @@
 					// HACK: loading code doesn't set sane defaults for explosion sounds, so we do it here
 					// NOTE: actually no longer true, loading code always ensures that sound volume != -1
 					float volume = wd-&gt;soundhit.getVolume(0);
-					sound-&gt;PlaySample(wd-&gt;soundhit.getID(0), pos, (volume == -1) ? 5.0f : volume);
+					sound-&gt;PlaySample(wd-&gt;soundhit.getID(0), pos, (volume == -1) ? 1.0f : volume);
 				}
 			}
 		}
@@ -2069,7 +2069,7 @@
 }
 
 
-void CUnit::PushWind(float x, float z, float strength)
+void CUnit::UpdateWind(float x, float z, float strength)
 {
 	if (strength &gt; unitDef-&gt;windGenerator) {
 		cob-&gt;Call(COBFN_SetSpeed, (int)(unitDef-&gt;windGenerator*3000.0f));
@@ -2249,7 +2249,7 @@
 		if (wind.GetCurrentStrength() &gt; unitDef-&gt;windGenerator) {
 			cob-&gt;Call(COBFN_SetSpeed, (int)(unitDef-&gt;windGenerator * 3000.0f));
 		} else {
-			cob-&gt;Call(COBFN_SetSpeed, (int)(wind.GetCurrentStrength()       * 3000.0f));
+			cob-&gt;Call(COBFN_SetSpeed, (int)(wind.GetCurrentStrength() * 3000.0f));
 		}
 		cob-&gt;Call(COBFN_SetDirection, (int)GetHeadingFromVector(-wind.GetCurrentDirection().x, -wind.GetCurrentDirection().z));
 	}

Modified: branches/caiinterface/rts/Sim/Units/Unit.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.h	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/Unit.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -122,7 +122,7 @@
 	void AddMetal(float metal, bool handicap = true);
 	bool UseEnergy(float energy);
 	void AddEnergy(float energy, bool handicap = true);
-	void PushWind(float x, float z, float strength);		//push the new wind to the script
+	void UpdateWind(float x, float z, float strength);		//push the new wind to the script
 	void SetMetalStorage(float newStorage);
 	void SetEnergyStorage(float newStorage);
 
@@ -323,6 +323,7 @@
 
 	void UpdateDrawPos();
 	float3 drawPos;
+	float3 drawMidPos;
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	unsigned lastUnitUpdate;
 #endif

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -138,7 +138,7 @@
 	limitDgun(false),
 	morphUnitToFeature(true)
 {
-	//unitModelLoader=SAFE_NEW CUnit3DLoader;
+	freeIDs.reserve(MAX_UNITS-1);
 	for (int a = 1; a &lt; MAX_UNITS; a++) {
 		freeIDs.push_back(a);
 		units[a] = NULL;
@@ -616,7 +616,7 @@
 	for(usi=activeUnits.begin();usi!=activeUnits.end();usi++)
 	{
 		if((*usi)-&gt;unitDef-&gt;windGenerator)
-			(*usi)-&gt;PushWind(x,z,strength);
+			(*usi)-&gt;UpdateWind(x,z,strength);
 	}
 }
 

Modified: branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -269,7 +269,7 @@
 		DamageArray dynDamages;
 		if (weaponDef-&gt;dynDamageExp &gt; 0)
 			dynDamages = weaponDefHandler-&gt;DynamicDamages(weaponDef-&gt;damages, weaponMuzzlePos, curPos, weaponDef-&gt;dynDamageRange&gt;0?weaponDef-&gt;dynDamageRange:weaponDef-&gt;range, weaponDef-&gt;dynDamageExp, weaponDef-&gt;dynDamageMin, weaponDef-&gt;dynDamageInverted);
-		helper-&gt;Explosion(hitPos, weaponDef-&gt;dynDamageExp&gt;0?dynDamages*(intensity*damageMul):weaponDef-&gt;damages*(intensity*damageMul), areaOfEffect, weaponDef-&gt;edgeEffectiveness, weaponDef-&gt;explosionSpeed,owner, true, 1.0f, weaponDef-&gt;noSelfDamage, weaponDef-&gt;explosionGenerator, hit, dir, weaponDef-&gt;id);
+		helper-&gt;Explosion(hitPos, weaponDef-&gt;dynDamageExp&gt;0?dynDamages*(intensity*damageMul):weaponDef-&gt;damages*(intensity*damageMul), areaOfEffect, weaponDef-&gt;edgeEffectiveness, weaponDef-&gt;explosionSpeed,owner, true, 1.0f, false, false, weaponDef-&gt;explosionGenerator, hit, dir, weaponDef-&gt;id);
 	}
 
 	if(targetUnit)

Modified: branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -110,7 +110,7 @@
 	if (weaponDef-&gt;dynDamageExp &gt; 0)
 		dynDamages = weaponDefHandler-&gt;DynamicDamages(weaponDef-&gt;damages, weaponMuzzlePos, targetPos, weaponDef-&gt;dynDamageRange&gt;0?weaponDef-&gt;dynDamageRange:weaponDef-&gt;range, weaponDef-&gt;dynDamageExp, weaponDef-&gt;dynDamageMin, weaponDef-&gt;dynDamageInverted);
 
-	helper-&gt;Explosion(weaponMuzzlePos+dir*r,weaponDef-&gt;dynDamageExp&gt;0?dynDamages:weaponDef-&gt;damages,areaOfEffect,weaponDef-&gt;edgeEffectiveness,weaponDef-&gt;explosionSpeed,owner,true,0.5f,weaponDef-&gt;noSelfDamage,weaponDef-&gt;explosionGenerator, u,dir, weaponDef-&gt;id);
+	helper-&gt;Explosion(weaponMuzzlePos+dir*r,weaponDef-&gt;dynDamageExp&gt;0?dynDamages:weaponDef-&gt;damages,areaOfEffect,weaponDef-&gt;edgeEffectiveness,weaponDef-&gt;explosionSpeed,owner,false,0.5f,true,false,weaponDef-&gt;explosionGenerator, u,dir, weaponDef-&gt;id);
 
 	SAFE_NEW CLightningProjectile(weaponMuzzlePos,
 		weaponMuzzlePos + dir * (r + 10), owner, color, weaponDef, 10, this);

Modified: branches/caiinterface/rts/System/LogOutput.cpp
===================================================================
--- branches/caiinterface/rts/System/LogOutput.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/System/LogOutput.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -238,7 +238,7 @@
 	OutputDebugString(str);
 	if (newline)
 		OutputDebugString(&quot;\n&quot;);
-#endif	// _MSC_VER
+#endif // _MSC_VER
 
 	if (filelog) {
 #if !defined UNITSYNC &amp;&amp; !defined DEDICATED
@@ -351,6 +351,7 @@
 	Output(subsystem, text.c_str());
 }
 
+
 CLogSubsystem&amp; CLogOutput::GetDefaultLogSubsystem()
 {
 	return LOG_DEFAULT;

Modified: branches/caiinterface/rts/System/Vec2.h
===================================================================
--- branches/caiinterface/rts/System/Vec2.h	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/System/Vec2.h	2008-12-10 19:11:25 UTC (rev 7164)
@@ -1,19 +1,30 @@
-#ifndef VEC2_H
-#define VEC2_H
-
-
-template&lt;typename T&gt;
-class Vec2
-{
-public:
-	Vec2() {};
-	Vec2(const T nx, const T ny) : x(nx), y(ny) {};
-
-	T x;
-	T y;
-};
-
-typedef Vec2&lt;int&gt; int2;
-typedef Vec2&lt;float&gt; float2;
-
-#endif
+#ifndef VEC2_H
+#define VEC2_H
+
+#include &quot;creg/creg_cond.h&quot;
+
+// can't easily use templates because of creg
+
+struct int2
+{
+	CR_DECLARE_STRUCT(int2);
+
+	int2() {};
+	int2(const int nx, const int ny) : x(nx), y(ny) {};
+
+	int x;
+	int y;
+};
+
+struct float2
+{
+	CR_DECLARE_STRUCT(float2);
+
+	float2() {};
+	float2(const float nx, const float ny) : x(nx), y(ny) {};
+
+	float x;
+	float y;
+};
+
+#endif

Modified: branches/caiinterface/rts/System/float3.cpp
===================================================================
--- branches/caiinterface/rts/System/float3.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/rts/System/float3.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -6,8 +6,15 @@
  */
 
 #include &quot;float3.h&quot;
+#include &quot;Vec2.h&quot;
 #include &quot;FastMath.h&quot;
 
+// TODO: this should go in Vec2.cpp if that is ever created
+CR_BIND(int2, );
+CR_REG_METADATA(int2, (CR_MEMBER(x), CR_MEMBER(y)));
+CR_BIND(float2, );
+CR_REG_METADATA(float2, (CR_MEMBER(x), CR_MEMBER(y)));
+
 CR_BIND(float3, );
 CR_REG_METADATA(float3, (CR_MEMBER(x), CR_MEMBER(y), CR_MEMBER(z)));
 

Modified: branches/caiinterface/tools/unitsync/unitsync.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync.cpp	2008-12-10 18:36:09 UTC (rev 7163)
+++ branches/caiinterface/tools/unitsync/unitsync.cpp	2008-12-10 19:11:25 UTC (rev 7164)
@@ -29,6 +29,7 @@
 #include &quot;System/Info.h&quot;
 #include &quot;System/Option.h&quot;
 
+
 // unitsync only:
 #include &quot;LuaParserAPI.h&quot;
 #include &quot;Syncer.h&quot;
@@ -1811,6 +1812,8 @@
 }
 
 
+// Common Options Parameters
+
 /**
  * @brief Retrieve an option's key
  * @param optIndex option index/id


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001932.html">[Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels
</A></li>
	<LI>Next message: <A HREF="001934.html">[Taspring-linux-commit] r7165 - in trunk: . rts/Sim/Misc	rts/Sim/MoveTypes rts/Sim/Units rts/Sim/Units/CommandAI	rts/System rts/System/creg
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1933">[ date ]</a>
              <a href="thread.html#1933">[ thread ]</a>
              <a href="subject.html#1933">[ subject ]</a>
              <a href="author.html#1933">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
