<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7163%20-%20in%20trunk/rts/Rendering%3A%20Textures%0A%09UnitModels&In-Reply-To=%3C20081210183610.4AAA946E9%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001931.html">
   <LINK REL="Next"  HREF="001933.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7163%20-%20in%20trunk/rts/Rendering%3A%20Textures%0A%09UnitModels&In-Reply-To=%3C20081210183610.4AAA946E9%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Dec 10 19:36:10 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001931.html">[Taspring-linux-commit] r7162 - in trunk/rts: ExternalAI Game Lua	Rendering Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System
</A></li>
        <LI>Next message: <A HREF="001933.html">[Taspring-linux-commit] r7164 - in branches/caiinterface: .	rts/Game rts/Game/UI rts/Lua rts/Map rts/Map/SMF rts/Sim/Misc	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Weapons rts/System tools/unitsync
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1932">[ date ]</a>
              <a href="thread.html#1932">[ thread ]</a>
              <a href="subject.html#1932">[ subject ]</a>
              <a href="author.html#1932">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-12-10 19:36:09 +0100 (Wed, 10 Dec 2008)
New Revision: 7163

Added:
   trunk/rts/Rendering/Textures/3DOTextureHandler.cpp
   trunk/rts/Rendering/Textures/3DOTextureHandler.h
   trunk/rts/Rendering/Textures/S3OTextureHandler.cpp
   trunk/rts/Rendering/Textures/S3OTextureHandler.h
   trunk/rts/Rendering/UnitModels/3DModel.cpp
   trunk/rts/Rendering/UnitModels/3DModel.h
   trunk/rts/Rendering/UnitModels/IModelParser.cpp
   trunk/rts/Rendering/UnitModels/IModelParser.h
Log:
forgot this

Added: trunk/rts/Rendering/Textures/3DOTextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/3DOTextureHandler.cpp	                        (rev 0)
+++ trunk/rts/Rendering/Textures/3DOTextureHandler.cpp	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,318 @@
+// 3DOTextureHandler.cpp: implementation of the C3DOTextureHandler class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;StdAfx.h&quot;
+
+#include &lt;algorithm&gt;
+#include &lt;cctype&gt;
+#include &lt;set&gt;
+#include &lt;sstream&gt;
+#include &quot;mmgr.h&quot;
+
+#include &quot;3DOTextureHandler.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;FileSystem/SimpleParser.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/ShadowHandler.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
+#include &quot;TAPalette.h&quot;
+#include &quot;System/Util.h&quot;
+#include &quot;System/Exceptions.h&quot;
+
+//////////////////////////////////////////////////////////////////////
+// Construction/Destruction
+//////////////////////////////////////////////////////////////////////
+
+C3DOTextureHandler* texturehandler3DO = 0;
+
+struct TexFile {
+	CBitmap tex;  // same format
+	CBitmap tex2; // as s3o's
+	std::string name;
+};
+
+static int CompareTatex2( const void *arg1, const void *arg2 ){
+	if((*(TexFile**)arg1)-&gt;tex.ysize &gt; (*(TexFile**)arg2)-&gt;tex.ysize)
+		return -1;
+	return 1;
+}
+
+C3DOTextureHandler::C3DOTextureHandler()
+{
+	PrintLoadMsg(&quot;Creating unit textures&quot;);
+
+	CFileHandler file(&quot;unittextures/tatex/teamtex.txt&quot;);
+	CSimpleParser parser(file);
+
+	std::set&lt;std::string&gt; teamTexes;
+	while(!file.Eof()) {
+		teamTexes.insert(StringToLower(parser.GetCleanLine()));
+	}
+
+	TexFile* texfiles[10000];
+
+	int numfiles = 0;
+	int totalSize = 0;
+
+	std::vector&lt;std::string&gt; filesBMP = CFileHandler::FindFiles(&quot;unittextures/tatex/&quot;, &quot;*.bmp&quot;);
+	std::vector&lt;std::string&gt; files    = CFileHandler::FindFiles(&quot;unittextures/tatex/&quot;, &quot;*.tga&quot;);
+	files.insert(files.end(),filesBMP.begin(),filesBMP.end());
+
+	std::set&lt;string&gt; usedNames;
+	for(std::vector&lt;std::string&gt;::iterator fi = files.begin(); fi != files.end(); ++fi) {
+		std::string s = std::string(*fi);
+		std::string s2 = s;
+
+		s2.erase(0, s2.find_last_of('/') + 1);
+		s2 = StringToLower(s2.substr(0, s2.find_last_of('.')));
+
+		//avoid duplicate names and give tga images priority
+		if(usedNames.find(s2)!=usedNames.end())
+			continue;
+		usedNames.insert(s2);
+
+		if(teamTexes.find(s2) == teamTexes.end()){
+			TexFile* tex = CreateTex(s, s2, false);
+			texfiles[numfiles++] = tex;
+			totalSize += tex-&gt;tex.xsize * tex-&gt;tex.ysize;
+		} else {
+			TexFile* tex = CreateTex(s, s2, true);
+			texfiles[numfiles++] = tex;
+			totalSize += tex-&gt;tex.xsize * tex-&gt;tex.ysize;
+		}
+	}
+
+	// &quot;TAPalette.h&quot;
+	for(int a=0;a&lt;256;++a){
+		string name=&quot;ta_color&quot;;
+		char t[50];
+		sprintf(t,&quot;%i&quot;,a);
+		name+=t;
+		TexFile* tex=SAFE_NEW TexFile;
+		tex-&gt;name=name;
+		tex-&gt;tex.Alloc(1,1);
+		tex-&gt;tex.mem[0]=palette[a][0];
+		tex-&gt;tex.mem[1]=palette[a][1];
+		tex-&gt;tex.mem[2]=palette[a][2];
+		tex-&gt;tex.mem[3]=0;   //teamcolor
+
+		tex-&gt;tex2.Alloc(1,1);
+		tex-&gt;tex2.mem[0]=0;  //self illum
+		tex-&gt;tex2.mem[1]=30; //reflectivity
+		tex-&gt;tex2.mem[2]=0;
+		tex-&gt;tex2.mem[3]=255;
+
+		texfiles[numfiles++]=tex;
+		totalSize+=tex-&gt;tex.xsize*tex-&gt;tex.ysize;
+	}
+
+	//pessimistic guess about how much space will be wasted
+	totalSize=(int)(totalSize * 1.2f);
+
+	if(totalSize&lt;1024*1024){
+		bigTexX=1024;
+		bigTexY=1024;
+	} else if(totalSize&lt;1024*2048){
+		bigTexX=1024;
+		bigTexY=2048;
+	} else if(totalSize&lt;2048*2048){
+		bigTexX=2048;
+		bigTexY=2048;
+	} else {
+		bigTexX=2048;
+		bigTexY=2048;
+		handleerror(0,&quot;Too many/large unit textures to fit in 2048*2048&quot;,&quot;Error&quot;,0);
+	}
+
+	qsort(texfiles,numfiles,sizeof(TexFile*),CompareTatex2);
+
+	unsigned char* bigtex1 = SAFE_NEW unsigned char[bigTexX*bigTexY*4];
+	unsigned char* bigtex2 = SAFE_NEW unsigned char[bigTexX*bigTexY*4];
+	for(int a=0;a&lt;bigTexX*bigTexY;++a) {
+		bigtex1[a*4+0] = 128;
+		bigtex1[a*4+1] = 128;
+		bigtex1[a*4+2] = 128;
+		bigtex1[a*4+3] = 0;
+
+		bigtex2[a*4+0] = 0;
+		bigtex2[a*4+1] = 128;
+		bigtex2[a*4+2] = 0;
+		bigtex2[a*4+3] = 255;
+	}
+
+	int cury=0;
+	int maxy=0;
+	int curx=0;
+	int foundx = 0, foundy = 0;
+	std::list&lt;int2&gt; nextSub;
+	std::list&lt;int2&gt; thisSub;
+	for(int a=0;a&lt;numfiles;++a){
+		CBitmap* curtex1=&amp;texfiles[a]-&gt;tex;
+		CBitmap* curtex2=&amp;texfiles[a]-&gt;tex2;
+
+		bool done=false;
+		while(!done){
+			// Find space for us
+			if(thisSub.empty()){
+				if(nextSub.empty()){
+					cury=maxy;
+					maxy+=curtex1-&gt;ysize;
+					if(maxy&gt;bigTexY){
+						handleerror(0,&quot;Too many/large unit textures&quot;,&quot;Error&quot;,0);
+						break;
+					}
+					thisSub.push_back(int2(0,cury));
+				} else {
+					thisSub=nextSub;
+					nextSub.clear();
+				}
+			}
+			if(thisSub.front().x+curtex1-&gt;xsize&gt;bigTexX){
+				thisSub.clear();
+				continue;
+			}
+			if(thisSub.front().y+curtex1-&gt;ysize&gt;maxy){
+				thisSub.pop_front();
+				continue;
+			}
+			// ok found space for us
+			foundx=thisSub.front().x;
+			foundy=thisSub.front().y;
+			done=true;
+
+			if(thisSub.front().y+curtex1-&gt;ysize&lt;maxy){
+				nextSub.push_back(int2(thisSub.front().x,thisSub.front().y+curtex1-&gt;ysize));
+			}
+
+			thisSub.front().x+=curtex1-&gt;xsize;
+			while(thisSub.size()&gt;1 &amp;&amp; thisSub.front().x &gt;= (++thisSub.begin())-&gt;x){
+				(++thisSub.begin())-&gt;x=thisSub.front().x;
+				thisSub.erase(thisSub.begin());
+			}
+
+		}
+		for(int y=0;y&lt;curtex1-&gt;ysize;y++){
+			for(int x=0;x&lt;curtex1-&gt;xsize;x++){
+//				if(curtex1-&gt;mem[(y*curtex1-&gt;xsize+x)*4]==254 &amp;&amp; curtex1-&gt;mem[(y*curtex1-&gt;xsize+x)*4+1]==0 &amp;&amp; curtex1-&gt;mem[(y*curtex1-&gt;xsize+x)*4+2]==254){
+//					bigtex1[((cury+y)*bigTexX+(curx+x))*4+3] = 0;
+//				} else {
+					for(int col=0;col&lt;4;col++){
+						bigtex1[((foundy+y)*bigTexX+(foundx+x))*4+col] = curtex1-&gt;mem[(y*curtex1-&gt;xsize+x)*4+col];
+						bigtex2[((foundy+y)*bigTexX+(foundx+x))*4+col] = curtex2-&gt;mem[(y*curtex1-&gt;xsize+x)*4+col];
+//					}
+				}
+			}
+		}
+
+		UnitTexture* unittex=SAFE_NEW UnitTexture;
+
+		unittex-&gt;xstart=(foundx+0.5f)/(float)bigTexX;
+		unittex-&gt;ystart=(foundy+0.5f)/(float)bigTexY;
+		unittex-&gt;xend=(foundx+curtex1-&gt;xsize-0.5f)/(float)bigTexX;
+		unittex-&gt;yend=(foundy+curtex1-&gt;ysize-0.5f)/(float)bigTexY;
+		textures[texfiles[a]-&gt;name]=unittex;
+
+		curx+=curtex1-&gt;xsize;
+		delete texfiles[a];
+	}
+
+	glGenTextures(1, &amp;atlas3do1);
+	glBindTexture(GL_TEXTURE_2D, atlas3do1);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8 ,bigTexX, bigTexY, 0, GL_RGBA, GL_UNSIGNED_BYTE, bigtex1);
+	//glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, bigtex1);
+
+	glGenTextures(1, &amp;atlas3do2);
+	glBindTexture(GL_TEXTURE_2D, atlas3do2);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8 ,bigTexX, bigTexY, 0, GL_RGBA, GL_UNSIGNED_BYTE, bigtex2);
+	//glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, bigtex2);
+
+
+//	CBitmap save(tex,bigTexX,bigTexY);
+//	save.Save(&quot;unittex-1x.jpg&quot;);
+
+	UnitTexture* t=SAFE_NEW UnitTexture;
+	t-&gt;xstart=0;
+	t-&gt;ystart=0;
+	t-&gt;xend=1;
+	t-&gt;yend=1;
+	textures[&quot; &quot;]=t;
+
+	delete[] bigtex1;
+	delete[] bigtex2;
+}
+
+C3DOTextureHandler::~C3DOTextureHandler()
+{
+	std::map&lt;string,UnitTexture*&gt;::iterator tti;
+	for(tti=textures.begin();tti!=textures.end();++tti){
+		delete tti-&gt;second;
+	}
+	glDeleteTextures(1, &amp;atlas3do1);
+	glDeleteTextures(1, &amp;atlas3do2);
+}
+
+C3DOTextureHandler::UnitTexture* C3DOTextureHandler::Get3DOTexture(std::string name)
+{
+	StringToLowerInPlace(name);
+	std::map&lt;std::string,UnitTexture*&gt;::iterator tti;
+	if((tti=textures.find(name))!=textures.end()){
+		return tti-&gt;second;
+	}
+	logOutput &lt;&lt; &quot;Unknown texture &quot; &lt;&lt; name.c_str() &lt;&lt; &quot;\n&quot;;
+	return textures[&quot; &quot;];
+}
+
+void C3DOTextureHandler::Set3doAtlases() const
+{
+	if(unitDrawer-&gt;advShading){
+		glActiveTexture(GL_TEXTURE1);
+		glBindTexture(GL_TEXTURE_2D, atlas3do2);
+		glActiveTexture(GL_TEXTURE0);
+	}
+	glBindTexture(GL_TEXTURE_2D, atlas3do1);
+}
+
+TexFile* C3DOTextureHandler::CreateTex(const std::string&amp; name, const std::string&amp; name2, bool teamcolor)
+{
+	TexFile* tex=SAFE_NEW TexFile;
+	tex-&gt;tex.Load(name,30);
+	char tmp[256];
+	tex-&gt;name = name2;
+	//sprintf(tmp,&quot;%s%02i&quot;,name2.c_str(),team);
+	//tex-&gt;name=tmp;
+
+	tex-&gt;tex2.Alloc(tex-&gt;tex.xsize,tex-&gt;tex.ysize);
+
+	CBitmap* tex1 = &amp;tex-&gt;tex;
+	CBitmap* tex2 = &amp;tex-&gt;tex2;
+
+	for(int a=0;a&lt;tex1-&gt;ysize*tex1-&gt;xsize;++a){
+		tex2-&gt;mem[a*4+0] = 0;
+		tex2-&gt;mem[a*4+1] = tex1-&gt;mem[a*4+3]; //move reflectivity to texture2
+		tex2-&gt;mem[a*4+2] = 0;
+		tex2-&gt;mem[a*4+3] = 255;
+
+		tex1-&gt;mem[a*4+3] = 0;
+
+		if (teamcolor) {
+			//purple = teamcolor
+			if(tex1-&gt;mem[a*4]==tex1-&gt;mem[a*4+2] &amp;&amp; tex1-&gt;mem[a*4+1]==0){
+				unsigned char lum = tex1-&gt;mem[a*4];
+				tex1-&gt;mem[a*4+0] = 0;
+				tex1-&gt;mem[a*4+1] = 0;
+				tex1-&gt;mem[a*4+2] = 0;
+				tex1-&gt;mem[a*4+3] = (unsigned char)(std::min(255.0f,lum*1.5f));
+			}
+		}
+	}
+	return tex;
+}
+

Added: trunk/rts/Rendering/Textures/3DOTextureHandler.h
===================================================================
--- trunk/rts/Rendering/Textures/3DOTextureHandler.h	                        (rev 0)
+++ trunk/rts/Rendering/Textures/3DOTextureHandler.h	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,51 @@
+#ifndef _3DOTEXTUREHANDLER_H
+#define _3DOTEXTUREHANDLER_H
+// _3DOTextureHandler.h: interface for the C3DOTextureHandler class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
+
+struct TexFile;
+class CFileHandler;
+
+class C3DOTextureHandler
+{
+public:
+	struct UnitTexture {
+		float xstart;
+		float xend;
+		float ystart;
+		float yend;
+	};
+
+	C3DOTextureHandler();
+	~C3DOTextureHandler();
+
+	void Set3doAtlases() const;
+
+	UnitTexture* Get3DOTexture(std::string name);
+
+	unsigned int GetAtlasTex1ID() const  { return atlas3do1; }
+	unsigned int GetAtlasTex2ID() const  { return atlas3do2; }
+	unsigned int GetAtlasTexSizeX() const { return bigTexX; }
+	unsigned int GetAtlasTexSizeY() const { return bigTexY; }
+	const std::map&lt;std::string, UnitTexture*&gt;&amp; GetAtlasTextures() const { return textures; }
+
+private:
+	std::map&lt;std::string, UnitTexture*&gt; textures;
+	GLuint atlas3do1;
+	GLuint atlas3do2;
+	int bigTexX;
+	int bigTexY;
+
+	TexFile* CreateTex(const std::string&amp; name, const std::string&amp; name2, bool teamcolor = false);
+};
+
+extern C3DOTextureHandler* texturehandler3DO;
+
+#endif /* _3DOTEXTUREHANDLER_H */

Added: trunk/rts/Rendering/Textures/S3OTextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/S3OTextureHandler.cpp	                        (rev 0)
+++ trunk/rts/Rendering/Textures/S3OTextureHandler.cpp	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,119 @@
+// S3OTextureHandler.cpp: implementation of the CS3OTextureHandler class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;StdAfx.h&quot;
+
+#include &lt;algorithm&gt;
+#include &lt;cctype&gt;
+#include &lt;set&gt;
+#include &lt;sstream&gt;
+#include &quot;mmgr.h&quot;
+
+#include &quot;S3OTextureHandler.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;FileSystem/SimpleParser.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/ShadowHandler.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
+#include &quot;TAPalette.h&quot;
+#include &quot;System/Util.h&quot;
+#include &quot;System/Exceptions.h&quot;
+
+//////////////////////////////////////////////////////////////////////
+// Construction/Destruction
+//////////////////////////////////////////////////////////////////////
+
+CS3OTextureHandler* texturehandlerS3O = 0;
+
+CS3OTextureHandler::CS3OTextureHandler()
+{
+	s3oTextures.push_back(S3oTex());
+	s3oTextures.push_back(S3oTex());
+}
+
+CS3OTextureHandler::~CS3OTextureHandler()
+{
+	while(s3oTextures.size()&gt;1){
+		glDeleteTextures (1, &amp;s3oTextures.back().tex1);
+		glDeleteTextures (1, &amp;s3oTextures.back().tex2);
+		s3oTextures.pop_back();
+	}
+}
+
+void CS3OTextureHandler::LoadS3OTexture(S3DModel* model) {
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	model-&gt;textureType=0;
+	GML_STDMUTEX_LOCK(model); // LoadS3OTexture
+	loadTextures.push_back(model);
+#else
+	model-&gt;textureType=LoadS3OTextureNow(model-&gt;tex1, model-&gt;tex2);
+#endif
+}
+
+void CS3OTextureHandler::Update() {
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;S3DModel *&gt;::iterator i=loadTextures.begin(); i!=loadTextures.end();++i)
+		(*i)-&gt;textureType=LoadS3OTextureNow((char*)(*i)-&gt;tex1.c_str(),(char*)(*i)-&gt;tex2.c_str());
+	loadTextures.clear();
+#endif
+}
+
+int CS3OTextureHandler::LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2)
+{
+	string totalName=tex1+tex2;
+
+	if(s3oTextureNames.find(totalName)!=s3oTextureNames.end()){
+		return s3oTextureNames[totalName];
+	}
+	int newNum=s3oTextures.size();
+	S3oTex tex;
+	tex.num=newNum;
+
+	CBitmap bm;
+	if (!bm.Load(string(&quot;unittextures/&quot;+tex1)))
+		throw content_error(&quot;Could not load S3O texture from file unittextures/&quot; + tex1);
+	tex.tex1 = bm.CreateTexture(true);
+	tex.tex1SizeX = bm.xsize;
+	tex.tex1SizeY = bm.ysize;
+	tex.tex2=0;
+	tex.tex2SizeX = 0;
+	tex.tex2SizeY = 0;
+	//if(unitDrawer-&gt;advShading)
+	{
+		CBitmap bm;
+		// No error checking here... other code relies on an empty texture
+		// being generated if it couldn't be loaded.
+		// Also many map features specify a tex2 but don't ship it with the map,
+		// so throwing here would cause maps to break.
+		if(!bm.Load(string(&quot;unittextures/&quot;+tex2))) {
+			bm.Alloc(1,1);
+			bm.mem[3] = 255;//file not found, set alpha to white so unit is visible
+		}
+		tex.tex2 = bm.CreateTexture(true);
+		tex.tex2SizeX = bm.xsize;
+		tex.tex2SizeY = bm.ysize;
+	}
+	s3oTextures.push_back(tex);
+	s3oTextureNames[totalName]=newNum;
+
+	return newNum;
+}
+
+void CS3OTextureHandler::SetS3oTexture(int num)
+{
+	if (shadowHandler-&gt;inShadowPass) {
+		glBindTexture(GL_TEXTURE_2D, s3oTextures[num].tex2);
+	} else {
+		glBindTexture(GL_TEXTURE_2D, s3oTextures[num].tex1);
+		if(unitDrawer-&gt;advShading){
+			glActiveTextureARB(GL_TEXTURE1_ARB);
+			glBindTexture(GL_TEXTURE_2D, s3oTextures[num].tex2);
+			glActiveTextureARB(GL_TEXTURE0_ARB);
+		}
+	}
+}

Added: trunk/rts/Rendering/Textures/S3OTextureHandler.h
===================================================================
--- trunk/rts/Rendering/Textures/S3OTextureHandler.h	                        (rev 0)
+++ trunk/rts/Rendering/Textures/S3OTextureHandler.h	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,52 @@
+#ifndef S3OTEXTUREHANDLER_H
+#define S3OTEXTUREHANDLER_H
+// S3OTextureHandler.h: interface for the CS3OTextureHandler class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
+
+struct TexFile;
+class CFileHandler;
+
+class CS3OTextureHandler
+{
+public:
+	struct S3oTex {
+		int num;
+		GLuint tex1;
+		unsigned int tex1SizeX;
+		unsigned int tex1SizeY;
+		GLuint tex2;
+		unsigned int tex2SizeX;
+		unsigned int tex2SizeY;
+	};
+
+	CS3OTextureHandler();
+	virtual ~CS3OTextureHandler();
+
+	std::vector&lt;S3DModel* &gt; loadTextures;
+	void Update();
+	void LoadS3OTexture(S3DModel* model);
+	int LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2);
+	void SetS3oTexture(int num);
+
+	const S3oTex* GetS3oTex(int num) {
+		if ((num &lt; 0) || (num &gt;= (int)s3oTextures.size())) {
+			return NULL;
+		}
+		return &amp;s3oTextures[num];
+	}
+
+private:
+	std::map&lt;std::string, int&gt; s3oTextureNames;
+	std::vector&lt;S3oTex&gt; s3oTextures;
+};
+
+extern CS3OTextureHandler* texturehandlerS3O;
+
+#endif /* S3OTEXTUREHANDLER_H */

Added: trunk/rts/Rendering/UnitModels/3DModel.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModel.cpp	                        (rev 0)
+++ trunk/rts/Rendering/UnitModels/3DModel.cpp	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,270 @@
+#include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &lt;algorithm&gt;
+#include &lt;cctype&gt;
+#include &quot;mmgr.h&quot;
+
+#include &quot;3DModel.h&quot;
+#include &quot;3DOParser.h&quot;
+#include &quot;s3oParser.h&quot;
+#include &quot;Sim/Units/COB/CobInstance.h&quot;
+#include &quot;Rendering/FartextureHandler.h&quot;
+#include &quot;Util.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Exceptions.h&quot;
+
+
+//////////////////////////////////////////////////////////////////////
+// S3DModelPiece
+//
+
+void S3DModelPiece::DrawStatic() const
+{
+	glPushMatrix();
+	glTranslatef(offset.x,offset.y,offset.z);
+	glCallList(displist);
+	for(std::vector&lt;S3DModelPiece*&gt;::const_iterator ci=childs.begin(); ci!=childs.end(); ci++)
+		(*ci)-&gt;DrawStatic();
+	glPopMatrix();
+}
+
+
+S3DModelPiece::~S3DModelPiece()
+{
+	glDeleteLists(displist, 1);
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
+//  LocalModel
+//
+
+LocalModel::~LocalModel()
+{
+	for(std::vector&lt;LocalModelPiece*&gt;::iterator pi=pieces.begin();pi!=pieces.end();pi++){
+		delete *pi;
+	}
+	pieces.clear();
+}
+
+
+void LocalModel::SetLODCount(unsigned int count)
+{
+	lodCount = count;
+	pieces[0]-&gt;SetLODCount(count);
+}
+
+
+void LocalModel::ApplyRawPieceTransform(int piecenum) const
+{
+	pieces[piecenum]-&gt;ApplyTransform();
+}
+
+
+float3 LocalModel::GetRawPiecePos(int piecenum) const
+{
+	return pieces[piecenum]-&gt;GetPos();
+}
+
+
+CMatrix44f LocalModel::GetRawPieceMatrix(int piecenum) const
+{
+	return pieces[piecenum]-&gt;GetMatrix();
+}
+
+
+//gets the number of vertices in the piece
+int LocalModel::GetRawPieceVertCount(int piecenum) const
+{
+	return pieces[piecenum]-&gt;original-&gt;vertexCount;
+}
+
+
+void LocalModel::GetRawEmitDirPos(int piecenum, float3 &amp;pos, float3 &amp;dir) const
+{
+	pieces[piecenum]-&gt;GetEmitDirPos(pos, dir);
+}
+
+
+//Only useful for special pieces used for emit-sfx
+float3 LocalModel::GetRawPieceDirection(int piecenum) const
+{
+	return pieces[piecenum]-&gt;GetDirection();
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
+//  LocalModelPiece
+//
+
+static const float RADTOANG  = 180 / PI;
+
+void LocalModelPiece::Draw() const
+{
+	if (!visible &amp;&amp; childs.size()==0)
+		return;
+
+	glPushMatrix();
+
+	if (pos.x || pos.y || pos.z) { glTranslatef(pos.x, pos.y, pos.z); }
+	if (rot[1]) { glRotatef( rot[1] * RADTOANG, 0.0f, 1.0f, 0.0f); }
+	if (rot[0]) { glRotatef( rot[0] * RADTOANG, 1.0f, 0.0f, 0.0f); }
+	if (rot[2]) { glRotatef(-rot[2] * RADTOANG, 0.0f, 0.0f, 1.0f); }
+
+	if (visible)
+		glCallList(displist);
+
+	for (unsigned int i = 0; i &lt; childs.size(); i++) {
+		childs[i]-&gt;Draw();
+	}
+
+	glPopMatrix();
+}
+
+
+void LocalModelPiece::DrawLOD(unsigned int lod) const
+{
+	if (!visible &amp;&amp; childs.size()==0)
+		return;
+
+	glPushMatrix();
+
+	if (pos.x || pos.y || pos.z) { glTranslatef(pos.x, pos.y, pos.z); }
+	if (rot[1]) { glRotatef( rot[1] * RADTOANG, 0.0f, 1.0f, 0.0f); }
+	if (rot[0]) { glRotatef( rot[0] * RADTOANG, 1.0f, 0.0f, 0.0f); }
+	if (rot[2]) { glRotatef(-rot[2] * RADTOANG, 0.0f, 0.0f, 1.0f); }
+
+	if (visible)
+		glCallList(lodDispLists[lod]);
+
+	for (unsigned int i = 0; i &lt; childs.size(); i++) {
+		childs[i]-&gt;DrawLOD(lod);
+	}
+
+	glPopMatrix();
+}
+
+
+void LocalModelPiece::ApplyTransform() const
+{
+	if (parent) {
+		parent-&gt;ApplyTransform();
+	}
+
+	if (pos.x || pos.y || pos.z) { glTranslatef(pos.x, pos.y, pos.z); }
+	if (rot[1]) { glRotatef( rot[1] * RADTOANG, 0.0f, 1.0f, 0.0f); }
+	if (rot[0]) { glRotatef( rot[0] * RADTOANG, 1.0f, 0.0f, 0.0f); }
+	if (rot[2]) { glRotatef(-rot[2] * RADTOANG, 0.0f, 0.0f, 1.0f); }
+}
+
+
+void LocalModelPiece::GetPiecePosIter(CMatrix44f* mat) const
+{
+	if (parent) {
+		parent-&gt;GetPiecePosIter(mat);
+	}
+
+	if (pos.x || pos.y || pos.z) { mat-&gt;Translate(pos.x, pos.y, -pos.z); }
+	if (rot[1]) { mat-&gt;RotateY(rot[1]); }
+	if (rot[0]) { mat-&gt;RotateX(rot[0]); }
+	if (rot[2]) { mat-&gt;RotateZ(rot[2]); }
+}
+
+
+void LocalModelPiece::SetLODCount(unsigned int count)
+{
+	const unsigned int oldCount = lodDispLists.size();
+
+	lodDispLists.resize(count);
+	for (unsigned int i = oldCount; i &lt; count; i++) {
+		lodDispLists[i] = 0;
+	}
+
+	for (unsigned int i = 0; i &lt; childs.size(); i++) {
+		childs[i]-&gt;SetLODCount(count);
+	}
+}
+
+
+float3 LocalModelPiece::GetPos() const
+{
+	CMatrix44f mat;
+	GetPiecePosIter(&amp;mat);
+
+	if (type==MODELTYPE_3DO) {
+		// fix for valkyres
+		const S3DOPiece* p3 = static_cast&lt;S3DOPiece*&gt;(original);
+		if (p3 &amp;&amp; (p3-&gt;vertices.size() == 2)) {
+			const std::vector&lt;S3DOVertex&gt;&amp; pv = p3-&gt;vertices;
+			if (pv[0].pos.y &gt; pv[1].pos.y) {
+				mat.Translate(pv[0].pos.x, pv[0].pos.y, -pv[0].pos.z);
+			} else {
+				mat.Translate(pv[1].pos.x, pv[1].pos.y, -pv[1].pos.z);
+			}
+		}
+	}
+
+	float3 pos = mat.GetPos();
+	pos.z *= -1.0f;
+	pos.x *= -1.0f;
+
+	return pos;
+}
+
+
+CMatrix44f LocalModelPiece::GetMatrix() const
+{
+	CMatrix44f mat;
+	GetPiecePosIter(&amp;mat);
+
+	return mat;
+}
+
+
+float3 LocalModelPiece::GetDirection() const
+{
+	const S3DModelPiece* piece = original;
+	const unsigned int count = piece-&gt;vertexCount;
+	if (count &lt; 2) {
+		return float3(1.0f, 1.0f, 1.0f);
+	}else if (count &gt; 2) {
+		//this is strange too, but probably caused by an incorrect 3rd party unit
+	}
+	return piece-&gt;GetVertexPos(0) - piece-&gt;GetVertexPos(1);
+}
+
+
+void LocalModelPiece::GetEmitDirPos(float3 &amp;pos, float3 &amp;dir) const
+{
+	CMatrix44f mat;
+	GetPiecePosIter(&amp;mat);
+
+	//hm...
+	static const float3 invAxis(-1, 1, -1);
+	static const float3 invVertAxis(1, 1, -1);
+
+	const S3DModelPiece* piece = original;
+
+	if (piece-&gt;vertexCount == 0) {
+		pos = mat.GetPos()*invAxis;
+		dir = mat.Mul(float3(0,0,-1))*invAxis - pos;
+	}
+	else if(piece-&gt;vertexCount == 1) {
+		pos = mat.GetPos()*invAxis;
+		dir = mat.Mul(piece-&gt;GetVertexPos(0)*invVertAxis)*invAxis - pos;
+	}
+	else {
+		float3 p1 = mat.Mul(piece-&gt;GetVertexPos(0) * invVertAxis) * invAxis;
+		float3 p2 = mat.Mul(piece-&gt;GetVertexPos(1) * invVertAxis) * invAxis;
+
+		pos = p1;
+		dir = p2 - p1;
+	}
+}
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/rts/Rendering/UnitModels/3DModel.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModel.h	                        (rev 0)
+++ trunk/rts/Rendering/UnitModels/3DModel.h	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,117 @@
+#ifndef _3DMODEL_H
+#define _3DMODEL_H
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &quot;Matrix44f.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+
+
+const int MODELTYPE_3DO   = 0;
+const int MODELTYPE_S3O   = 1;
+const int MODELTYPE_OTHER = 2;
+
+
+struct S3DModel;
+struct S3DModelPiece;
+struct LocalModel;
+struct LocalModelPiece;
+
+
+struct S3DModelPiece {
+	std::string name;
+	std::vector&lt;S3DModelPiece*&gt; childs;
+
+	unsigned int vertexCount;
+	unsigned int displist;
+	float3 offset;
+	bool isEmpty;
+	float maxx,maxy,maxz;
+	float minx,miny,minz;
+
+	int type;  //! MODELTYPE_3DO, MODELTYPE_S3O, MODELTYPE_OTHER
+
+	//todo: add float3 orientation;
+
+	void DrawStatic() const;
+	~S3DModelPiece();
+
+	virtual const float3&amp; GetVertexPos(const int&amp; idx) const = 0;
+};
+
+
+struct S3DModel
+{
+	S3DModelPiece* rootobject;
+	int numobjects;
+	float radius;
+	float height;
+	std::string name;
+	int farTextureNum;
+	float maxx,maxy,maxz;
+	float minx,miny,minz;
+	float3 relMidPos;
+	int type;        //! MODELTYPE_3DO, MODELTYPE_S3O, MODELTYPE_OTHER
+	int textureType; // FIXME MAKE S3O ONLY      //0=3do, otherwise s3o
+	std::string tex1;
+	std::string tex2;
+	inline void DrawStatic() const { rootobject-&gt;DrawStatic(); };
+};
+
+
+struct LocalModelPiece
+{
+	//todo: add (visibility) maxradius!
+
+	float3 pos;
+	float3 rot; //! in radian
+	bool updated; //FIXME unused?
+	bool visible;
+
+	int type;  //! MODELTYPE_3DO, MODELTYPE_S3O, MODELTYPE_OTHER
+	std::string name;
+	S3DModelPiece* original;
+	LocalModelPiece* parent;
+	std::vector&lt;LocalModelPiece*&gt; childs;
+
+	unsigned int displist;
+	std::vector&lt;unsigned int&gt; lodDispLists;
+
+	void Draw() const;
+	void DrawLOD(unsigned int lod) const;
+	void SetLODCount(unsigned int count);
+	void ApplyTransform() const;
+	void GetPiecePosIter(CMatrix44f* mat) const;
+	float3 GetPos() const;
+	CMatrix44f GetMatrix() const;
+	float3 GetDirection() const;
+	void GetEmitDirPos(float3 &amp;pos, float3 &amp;dir) const;
+};
+
+//FIXME redundant struct!?
+struct LocalModel
+{
+	LocalModel() : lodCount(0) {};
+	~LocalModel();
+
+	int type;  //! MODELTYPE_3DO, MODELTYPE_S3O, MODELTYPE_OTHER
+
+	std::vector&lt;LocalModelPiece*&gt; pieces;
+	unsigned int lodCount;
+
+	inline void Draw() const { pieces[0]-&gt;Draw(); };
+	inline void DrawLOD(unsigned int lod) const { if (lod &lt;= lodCount) pieces[0]-&gt;DrawLOD(lod);};
+	void SetLODCount(unsigned int count);
+
+	//! raw forms, the piecenum must be valid
+	void ApplyRawPieceTransform(int piecenum) const;
+	float3 GetRawPiecePos(int piecenum) const;
+	CMatrix44f GetRawPieceMatrix(int piecenum) const;
+	float3 GetRawPieceDirection(int piecenum) const;
+	int GetRawPieceVertCount(int piecenum) const;
+	void GetRawEmitDirPos(int piecenum, float3 &amp;pos, float3 &amp;dir) const;
+};
+
+
+#endif /* _3DMODEL_H */

Added: trunk/rts/Rendering/UnitModels/IModelParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/IModelParser.cpp	                        (rev 0)
+++ trunk/rts/Rendering/UnitModels/IModelParser.cpp	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,232 @@
+#include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &lt;algorithm&gt;
+#include &lt;cctype&gt;
+#include &quot;mmgr.h&quot;
+
+#include &quot;IModelParser.h&quot;
+#include &quot;3DModel.h&quot;
+#include &quot;3DOParser.h&quot;
+#include &quot;s3oParser.h&quot;
+#include &quot;Sim/Units/COB/CobInstance.h&quot;
+#include &quot;Rendering/FartextureHandler.h&quot;
+#include &quot;Util.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Exceptions.h&quot;
+
+
+C3DModelParser* modelParser = NULL;
+
+
+//////////////////////////////////////////////////////////////////////
+// C3DModelParser
+//
+
+C3DModelParser::C3DModelParser(void)
+{
+	C3DOParser* unit3doparser=SAFE_NEW C3DOParser();
+	CS3OParser* units3oparser=SAFE_NEW CS3OParser();
+
+	AddParser(&quot;3do&quot;,unit3doparser);
+	AddParser(&quot;s3o&quot;,units3oparser);
+}
+
+
+C3DModelParser::~C3DModelParser(void)
+{
+	// model cache
+	std::map&lt;std::string,S3DModel*&gt;::iterator ci;
+	for(ci=cache.begin();ci!=cache.end();++ci){
+		DeleteChilds(ci-&gt;second-&gt;rootobject);
+		delete ci-&gt;second;
+	}
+	cache.clear();
+
+	// parsers
+	std::map&lt;std::string,IModelParser*&gt;::iterator pi;
+	for(pi=parsers.begin(); pi!=parsers.end(); ++pi){
+		delete pi-&gt;second;
+	}
+	parsers.clear();
+
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	createLists.clear();
+	fixLocalModels.clear();
+	Update(); // delete remaining local models
+#endif
+}
+
+
+void C3DModelParser::AddParser(const std::string ext, IModelParser* parser)
+{
+	parsers[ext] = parser;
+}
+
+
+S3DModel* C3DModelParser::Load3DModel(std::string name)
+{
+	StringToLowerInPlace(name);
+
+	//search in cache first
+	std::map&lt;std::string,S3DModel*&gt;::iterator ci;
+	if((ci=cache.find(name))!=cache.end()){
+		return ci-&gt;second;
+	}
+
+	std::string fileExt = GetFileExt(name);
+
+	std::map&lt;std::string,IModelParser*&gt;::iterator pi;
+	if ((pi=parsers.find(fileExt)) != parsers.end()) {
+		IModelParser* p = pi-&gt;second;
+		S3DModel* model = p-&gt;Load(name);
+		CreateLists(p, model-&gt;rootobject);
+		fartextureHandler-&gt;CreateFarTexture(model);
+		cache[name] = model; // cache model
+		return model;
+	}
+	//throw content_error(&quot;couldn't find a model parser for &quot; + name);
+	logOutput.Print(&quot;couldn't find a model parser for &quot; + name);
+	return NULL;
+}
+
+void C3DModelParser::Update() {
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	GML_STDMUTEX_LOCK(model); // Update
+	for(std::vector&lt;ModelParserPair&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
+		CreateListsNow(i-&gt;parser,i-&gt;model);
+	createLists.clear();
+
+	for(std::set&lt;CUnit*&gt;::iterator i=fixLocalModels.begin(); i!=fixLocalModels.end(); ++i)
+		FixLocalModel(*i);
+	fixLocalModels.clear();
+
+	for(std::vector&lt;LocalModel*&gt;::iterator i=deleteLocalModels.begin(); i!=deleteLocalModels.end(); ++i)
+		delete *i;
+	deleteLocalModels.clear();
+#endif
+}
+
+
+void C3DModelParser::DeleteChilds(S3DModelPiece* o)
+{
+	for(std::vector&lt;S3DModelPiece*&gt;::iterator di=o-&gt;childs.begin();di!=o-&gt;childs.end();di++) {
+		delete *di;
+	}
+	o-&gt;childs.clear();
+	delete o;
+}
+
+
+void C3DModelParser::DeleteLocalModel(CUnit* unit)
+{
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	GML_STDMUTEX_LOCK(model); // DeleteLocalModel
+	fixLocalModels.erase(unit);
+	deleteLocalModels.push_back(unit-&gt;localmodel);
+#else
+	delete unit-&gt;localmodel;
+#endif
+}
+
+
+void C3DModelParser::CreateLocalModel(CUnit* unit)
+{
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	GML_STDMUTEX_LOCK(model); // CreateLocalModel
+
+	unit-&gt;localmodel = CreateLocalModel(unit-&gt;model);
+	fixLocalModels.insert(unit);
+#else
+	unit-&gt;localmodel = CreateLocalModel(unit-&gt;model);
+	//FixLocalModel(unit);
+#endif
+}
+
+
+LocalModel* C3DModelParser::CreateLocalModel(S3DModel* model)
+{
+	LocalModel *lmodel = SAFE_NEW LocalModel;
+	lmodel-&gt;type = model-&gt;type;
+	lmodel-&gt;pieces.reserve(model-&gt;numobjects);
+	LocalModelPiece* localpieces = SAFE_NEW LocalModelPiece[model-&gt;numobjects];
+	for (unsigned int i=0; i &lt; model-&gt;numobjects; i++) {
+		lmodel-&gt;pieces.push_back(&amp;localpieces[i]);
+	}
+	lmodel-&gt;pieces[0]-&gt;parent = NULL;
+
+	int piecenum = 0;
+	CreateLocalModelPieces(model-&gt;rootobject, lmodel, &amp;piecenum);
+	return lmodel;
+}
+
+
+void C3DModelParser::CreateLocalModelPieces(S3DModelPiece* model, LocalModel* lmodel, int* piecenum)
+{
+	PUSH_CODE_MODE;
+	ENTER_SYNCED;
+	LocalModelPiece&amp; lmp = *lmodel-&gt;pieces[*piecenum];
+	lmp.original  =  model;
+	lmp.name      =  model-&gt;name;
+	lmp.type      =  model-&gt;type;
+	lmp.displist  =  model-&gt;displist;
+	lmp.visible   = !model-&gt;isEmpty;
+	lmp.updated   =  false;
+	lmp.pos       =  model-&gt;offset;
+	lmp.rot       =  float3(0.0f,0.0f,0.0f);
+
+	lmp.childs.reserve(model-&gt;childs.size());
+	for (unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
+		(*piecenum)++;
+		lmp.childs.push_back(lmodel-&gt;pieces[*piecenum]);
+		lmodel-&gt;pieces[*piecenum]-&gt;parent = &lmp;
+		CreateLocalModelPieces(model-&gt;childs[i], lmodel, piecenum);
+	}
+	POP_CODE_MODE;
+}
+
+
+void C3DModelParser::FixLocalModel(CUnit *unit)
+{
+	int piecenum = 0;
+	FixLocalModel(unit-&gt;model-&gt;rootobject,unit-&gt;localmodel,&amp;piecenum);
+}
+
+
+void C3DModelParser::FixLocalModel(S3DModelPiece* model, LocalModel* lmodel, int* piecenum)
+{
+	lmodel-&gt;pieces[*piecenum]-&gt;displist = model-&gt;displist;
+
+	for (unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
+		(*piecenum)++;
+		FixLocalModel(model-&gt;childs[i], lmodel, piecenum);
+	}
+}
+
+
+void C3DModelParser::CreateListsNow(IModelParser* parser, S3DModelPiece* o)
+{
+	o-&gt;displist = glGenLists(1);
+	PUSH_CODE_MODE;
+	ENTER_MIXED;
+	glNewList(o-&gt;displist,GL_COMPILE);
+	parser-&gt;Draw(o);
+	glEndList();
+	POP_CODE_MODE;
+
+	for(std::vector&lt;S3DModelPiece*&gt;::iterator bs=o-&gt;childs.begin(); bs!=o-&gt;childs.end(); bs++){
+		CreateListsNow(parser,*bs);
+	}
+}
+
+
+void C3DModelParser::CreateLists(IModelParser* parser, S3DModelPiece* o) {
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	GML_STDMUTEX_LOCK(model); // CreateLists
+	createLists.push_back(ModelParserPair(o,parser));
+#else
+	CreateListsNow(parser, o);
+#endif
+}
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/rts/Rendering/UnitModels/IModelParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/IModelParser.h	                        (rev 0)
+++ trunk/rts/Rendering/UnitModels/IModelParser.h	2008-12-10 18:36:09 UTC (rev 7163)
@@ -0,0 +1,79 @@
+#ifndef IMODELPARSER_H
+#define IMODELPARSER_H
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+#include &lt;set&gt;
+#include &quot;Matrix44f.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;3DModel.h&quot;
+
+
+class C3DOParser;
+class CS3OParser;
+class C3DModelParser;
+extern C3DModelParser* modelParser;
+
+
+class IModelParser
+{
+public:
+	virtual S3DModel* Load(std::string name) = 0;
+	virtual void Draw(S3DModelPiece* o) = 0;
+};
+
+
+class C3DModelParser
+{
+public:
+	C3DModelParser(void);
+	~C3DModelParser(void);
+
+	void Update();
+	S3DModel* Load3DModel(std::string name);
+
+	void AddParser(const std::string ext, IModelParser* parser);
+
+	void DeleteLocalModel(CUnit* unit);
+	void CreateLocalModel(CUnit* unit);
+	void FixLocalModel(CUnit* unit);
+
+private:
+//FIXME make some static?
+	std::map&lt;std::string,S3DModel*&gt; cache;
+	std::map&lt;std::string,IModelParser*&gt; parsers;
+
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	struct ModelParserPair {
+		ModelParserPair(S3DModelPiece* o,IModelParser* p) : model(o),parser(p) {};
+		S3DModelPiece* model;
+		IModelParser* parser;
+	};
+	std::vector&lt;ModelParserPair&gt; createLists;
+
+	std::set&lt;CUnit*&gt; fixLocalModels;
+	std::vector&lt;LocalModel*&gt; deleteLocalModels;
+#endif
+
+	void CreateLists(IModelParser* parser, S3DModelPiece* o);
+	void CreateListsNow(IModelParser* parser, S3DModelPiece* o);
+
+	void DeleteChilds(S3DModelPiece* o);
+
+	LocalModel* CreateLocalModel(S3DModel *model);
+	void CreateLocalModelPieces(S3DModelPiece* model, LocalModel* lmodel, int* piecenum);
+
+	void FixLocalModel(S3DModelPiece* model, LocalModel* lmodel, int* piecenum);
+
+/*
+	//FIXME: abstract this too
+	//s3o
+	void FindMinMax(SS3O *object);
+	//3do
+	void FindCenter(S3DO* object);
+	float FindRadius(S3DO* object,float3 offset);
+	float FindHeight(S3DO* object,float3 offset);
+*/
+};
+
+#endif /* IMODELPARSER_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001931.html">[Taspring-linux-commit] r7162 - in trunk/rts: ExternalAI Game Lua	Rendering Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System
</A></li>
	<LI>Next message: <A HREF="001933.html">[Taspring-linux-commit] r7164 - in branches/caiinterface: .	rts/Game rts/Game/UI rts/Lua rts/Map rts/Map/SMF rts/Sim/Misc	rts/Sim/Projectiles rts/Sim/Projectiles/WeaponProjectiles	rts/Sim/Units rts/Sim/Units/COB rts/Sim/Units/CommandAI	rts/Sim/Weapons rts/System tools/unitsync
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1932">[ date ]</a>
              <a href="thread.html#1932">[ thread ]</a>
              <a href="subject.html#1932">[ subject ]</a>
              <a href="author.html#1932">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
