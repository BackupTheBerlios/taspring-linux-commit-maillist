<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7162 - in trunk/rts: ExternalAI Game Lua	Rendering Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7162%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%20Lua%0A%09Rendering%20Rendering/Textures%20Rendering/UnitModels%0A%09Sim/Features%20Sim/Misc%20Sim/MoveTypes%20Sim/Projectiles%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%20Sim/Units/COB%0A%09Sim/Units/CommandAI%20Sim/Units/UnitTypes%20Sim/Weapons%20System&In-Reply-To=%3C20081210183354.47D8846E9%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001930.html">
   <LINK REL="Next"  HREF="001932.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7162 - in trunk/rts: ExternalAI Game Lua	Rendering Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7162%20-%20in%20trunk/rts%3A%20ExternalAI%20Game%20Lua%0A%09Rendering%20Rendering/Textures%20Rendering/UnitModels%0A%09Sim/Features%20Sim/Misc%20Sim/MoveTypes%20Sim/Projectiles%0A%09Sim/Projectiles/WeaponProjectiles%20Sim/Units%20Sim/Units/COB%0A%09Sim/Units/CommandAI%20Sim/Units/UnitTypes%20Sim/Weapons%20System&In-Reply-To=%3C20081210183354.47D8846E9%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7162 - in trunk/rts: ExternalAI Game Lua	Rendering Rendering/Textures Rendering/UnitModels	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/WeaponProjectiles Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Units/UnitTypes Sim/Weapons System">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Dec 10 19:33:53 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001930.html">[Taspring-linux-commit] r7161 - branches/caiinterface
</A></li>
        <LI>Next message: <A HREF="001932.html">[Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1931">[ date ]</a>
              <a href="thread.html#1931">[ thread ]</a>
              <a href="subject.html#1931">[ subject ]</a>
              <a href="author.html#1931">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-12-10 19:33:51 +0100 (Wed, 10 Dec 2008)
New Revision: 7162

Removed:
   trunk/rts/Rendering/Textures/TextureHandler.cpp
   trunk/rts/Rendering/Textures/TextureHandler.h
   trunk/rts/Rendering/UnitModels/3DModelParser.cpp
   trunk/rts/Rendering/UnitModels/3DModelParser.h
Modified:
   trunk/rts/ExternalAI/AICallback.cpp
   trunk/rts/Game/Game.cpp
   trunk/rts/Lua/LuaFeatureDefs.cpp
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaRules.cpp
   trunk/rts/Lua/LuaSyncedCtrl.cpp
   trunk/rts/Lua/LuaSyncedRead.cpp
   trunk/rts/Lua/LuaUnitDefs.cpp
   trunk/rts/Lua/LuaUnitRendering.cpp
   trunk/rts/Rendering/FartextureHandler.cpp
   trunk/rts/Rendering/FartextureHandler.h
   trunk/rts/Rendering/Textures/TextureAtlas.h
   trunk/rts/Rendering/UnitModels/3DOParser.cpp
   trunk/rts/Rendering/UnitModels/3DOParser.h
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Rendering/UnitModels/UnitDrawer.h
   trunk/rts/Rendering/UnitModels/s3oParser.cpp
   trunk/rts/Rendering/UnitModels/s3oParser.h
   trunk/rts/Sim/Features/Feature.cpp
   trunk/rts/Sim/Features/Feature.h
   trunk/rts/Sim/Features/FeatureDef.h
   trunk/rts/Sim/Features/FeatureHandler.cpp
   trunk/rts/Sim/Features/FeatureHandler.h
   trunk/rts/Sim/Misc/AirBaseHandler.cpp
   trunk/rts/Sim/MoveTypes/AirMoveType.cpp
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp
   trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
   trunk/rts/Sim/Projectiles/PieceProjectile.cpp
   trunk/rts/Sim/Projectiles/PieceProjectile.h
   trunk/rts/Sim/Projectiles/Projectile.cpp
   trunk/rts/Sim/Projectiles/Projectile.h
   trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.h
   trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   trunk/rts/Sim/Units/COB/CobFile.cpp
   trunk/rts/Sim/Units/COB/CobInstance.cpp
   trunk/rts/Sim/Units/COB/CobInstance.h
   trunk/rts/Sim/Units/COB/CobThread.cpp
   trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/Unit.h
   trunk/rts/Sim/Units/UnitDef.h
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/Sim/Units/UnitTypes/Builder.cpp
   trunk/rts/Sim/Units/UnitTypes/Building.cpp
   trunk/rts/Sim/Units/UnitTypes/Building.h
   trunk/rts/Sim/Units/UnitTypes/Factory.cpp
   trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp
   trunk/rts/Sim/Weapons/BeamLaser.cpp
   trunk/rts/Sim/Weapons/PlasmaRepulser.cpp
   trunk/rts/Sim/Weapons/Weapon.cpp
   trunk/rts/Sim/Weapons/WeaponDefHandler.cpp
   trunk/rts/Sim/Weapons/WeaponDefHandler.h
   trunk/rts/System/Util.h
   trunk/rts/System/myMath.cpp
   trunk/rts/System/myMath.h
Log:
3DModel refactor:
 * 3do and s3o are now IModelParser interfaces (just need Load() and Draw())
 * 3dmodelparser does now all the other stuff (creation of LocalModel instances, model cache, model parser managment)
 * no more S3DO &amp; SS3O, they are now derivatives of S3DModel and S3DModelPiece, so there are just 4 classes/structures: S3DModel &amp; S3DModelPiece and their local instances LocalModel &amp; LocalModelPiece.
 * merged most parts of the 3do and s3o rendering, to do so it will create now a tex2 even for 3do and will use the alpha in the first tex for the teamcolor (so it won't create duplicates of the 3do teamtexs in the atlas -&gt; more space). Please note that this affects lua too, so there are now gl.Texture(&quot;$units1&quot;) and gl.Texture(&quot;$units2&quot;) respectively.
 * refactored piece settings (pos,rot,visible) out of COBInstance into LocalModelPiece, so COB is now optional and not needed for rendering anymore.
 * cache models in the unit-/weapon-/feature-defs
 * fixed lua unit rendering for non-GML builds

Modified: trunk/rts/ExternalAI/AICallback.cpp
===================================================================
--- trunk/rts/ExternalAI/AICallback.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/ExternalAI/AICallback.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -21,7 +21,7 @@
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;FileSystem/FileSystem.h&quot;
 #include &quot;Rendering/InMapDraw.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -1408,14 +1408,14 @@
 float CAICallback::GetUnitDefRadius(int def)
 {
 	UnitDef *ud = &amp;unitDefHandler-&gt;unitDefs[def];
-	S3DOModel* mdl = ud-&gt;LoadModel(0);
+	S3DModel* mdl = ud-&gt;LoadModel();
 	return mdl-&gt;radius;
 }
 
 float CAICallback::GetUnitDefHeight(int def)
 {
 	UnitDef *ud = &amp;unitDefHandler-&gt;unitDefs[def];
-	S3DOModel* mdl = ud-&gt;LoadModel(0);
+	S3DModel* mdl = ud-&gt;LoadModel();
 	return mdl-&gt;height;
 }
 

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Game/Game.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -81,6 +81,8 @@
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Rendering/VerticalSync.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
+#include &quot;Rendering/Textures/S3OTextureHandler.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Lua/LuaInputReceiver.h&quot;
@@ -600,6 +602,8 @@
 	SafeDelete(modelParser);
 	SafeDelete(iconHandler);
 	SafeDelete(fartextureHandler);
+	SafeDelete(texturehandler3DO);
+	SafeDelete(texturehandlerS3O);
 	SafeDelete(camera);
 	SafeDelete(cam2);
 	SafeDelete(infoConsole);
@@ -2709,10 +2713,11 @@
 	if (luaGaia)  { luaGaia-&gt;CheckStack(); }
 	if (luaRules) { luaRules-&gt;CheckStack(); }
 
-	texturehandler-&gt;Update(); // delayed loading of textures
-	modelParser-&gt;Update(); // delayed fixup of models
-	treeDrawer-&gt;UpdateDraw(); // delete disp lists
-	readmap-&gt;UpdateDraw(); // update heightmap texture
+	//GML delayed loading
+	texturehandlerS3O-&gt;Update();
+	modelParser-&gt;Update();
+	treeDrawer-&gt;UpdateDraw();
+	readmap-&gt;UpdateDraw();
 
 	LuaUnsyncedCtrl::ClearUnitCommandQueues();
 
@@ -3198,7 +3203,7 @@
 		std::vector&lt;int&gt; args;
 		args.push_back(0);
 		unit-&gt;cob-&gt;Call(COBFN_AimFromPrimary/*/COBFN_QueryPrimary+weaponNum/ **/,args);
-		float3 relPos=unit-&gt;localmodel-&gt;GetPiecePos(args[0]);
+		float3 relPos=unit-&gt;cob-&gt;GetPiecePos(args[0]);
 		float3 pos=unit-&gt;pos+unit-&gt;frontdir*relPos.z+unit-&gt;updir*relPos.y+unit-&gt;rightdir*relPos.x;
 		pos+=UpVector*7;
 
@@ -4034,7 +4039,7 @@
 		std::vector&lt;int&gt; args;
 		args.push_back(0);
 		owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary/*/COBFN_QueryPrimary+weaponNum/ **/,args);
-		float3 relPos = owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+		float3 relPos = owner-&gt;cob-&gt;GetPiecePos(args[0]);
 		float3 pos = owner-&gt;pos + owner-&gt;frontdir * relPos.z
 			+ owner-&gt;updir    * relPos.y
 			+ owner-&gt;rightdir * relPos.x;
@@ -4634,18 +4639,13 @@
 		logOutput.Print(&quot;Missing unit name&quot;);
 		return;
 	}
-	const UnitDef* unitDef = unitDefHandler-&gt;GetUnitByName(unitName);
-	if (unitDef == NULL) {
-		logOutput.Print(&quot;Unknown unit name&quot;);
-		return;
-	}
-	const string scriptPath = unitDef-&gt;scriptPath;
-	const CCobFile* oldScript = GCobEngine.GetScriptAddr(scriptPath);
+	const UnitDef* udef = unitDefHandler-&gt;GetUnitByName(unitName);
+	const CCobFile* oldScript = GCobEngine.GetScriptAddr(udef-&gt;cobFilename);
 	if (oldScript == NULL) {
-		logOutput.Print(&quot;Unknown cob script: %s&quot;, scriptPath.c_str());
+		logOutput.Print(&quot;Unknown cob script: %s&quot;, udef-&gt;cobFilename.c_str());
 		return;
 	}
-	CCobFile* newScript = &amp;GCobEngine.ReloadCobFile(scriptPath);
+	CCobFile* newScript = &amp;GCobEngine.ReloadCobFile(udef-&gt;cobFilename);
 	int count = 0;
 	for (int i = 0; i &lt; MAX_UNITS; i++) {
 		CUnit* unit = uh-&gt;units[i];
@@ -4654,8 +4654,6 @@
 				count++;
 				delete unit-&gt;cob;
 				unit-&gt;cob = SAFE_NEW CCobInstance(*newScript, unit);
-				modelParser-&gt;DeleteLocalModel(unit);
-				modelParser-&gt;CreateLocalModel(unit);
 				unit-&gt;cob-&gt;Call(&quot;Create&quot;);
 			}
 		}

Modified: trunk/rts/Lua/LuaFeatureDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaFeatureDefs.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaFeatureDefs.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -332,13 +332,13 @@
 
 static int ModelHeight(lua_State* L, const void* data)
 {
-	const FeatureDef&amp; fd = *((const FeatureDef*)data);
+	const FeatureDef* fd = ((const FeatureDef*)data);
 	float height = 0.0f;
-	switch (fd.drawType) {
-		case DRAWTYPE_3DO:  { height = fd.LoadModel(0)-&gt;height; break; }
-		case DRAWTYPE_TREE: { height = TREE_RADIUS * 2.0f;      break; }
-		case DRAWTYPE_NONE: { height = 0.0f;                    break; }
-		default:            { height = 0.0f;                    break; }
+	switch (fd-&gt;drawType) {
+		case DRAWTYPE_3DO:  { height = LoadModel(fd)-&gt;height;  break; }
+		case DRAWTYPE_TREE: { height = TREE_RADIUS * 2.0f;     break; }
+		case DRAWTYPE_NONE: { height = 0.0f;                   break; }
+		default:            { height = 0.0f;                   break; }
 	}
 	lua_pushnumber(L, height);
 	return 1;
@@ -347,13 +347,13 @@
 
 static int ModelRadius(lua_State* L, const void* data)
 {
-	const FeatureDef&amp; fd = *((const FeatureDef*)data);
+	const FeatureDef* fd = ((const FeatureDef*)data);
 	float radius = 0.0f;
-	switch (fd.drawType) {
-		case DRAWTYPE_3DO:  { radius = fd.LoadModel(0)-&gt;radius; break; }
-		case DRAWTYPE_TREE: { radius = TREE_RADIUS;             break; }
-		case DRAWTYPE_NONE: { radius = 0.0f;                    break; }
-		default:            { radius = 0.0f;                    break; }
+	switch (fd-&gt;drawType) {
+		case DRAWTYPE_3DO:  { radius = LoadModel(fd)-&gt;radius;  break; }
+		case DRAWTYPE_TREE: { radius = TREE_RADIUS;            break; }
+		case DRAWTYPE_NONE: { radius = 0.0f;                   break; }
+		default:            { radius = 0.0f;                   break; }
 	}
 	lua_pushnumber(L, radius);
 	return 1;
@@ -363,9 +363,9 @@
 #define TYPE_MODEL_FUNC(name, param)                       \
 	static int Model ## name(lua_State* L, const void* data) \
 	{                                                        \
-		const FeatureDef&amp; fd = *((const FeatureDef*)data);     \
-		if (fd.drawType == DRAWTYPE_3DO) {                     \
-			const S3DOModel* model = fd.LoadModel(0);            \
+		const FeatureDef* fd = ((const FeatureDef*)data);     \
+		if (fd-&gt;drawType == DRAWTYPE_3DO) {                     \
+			const S3DModel* model = LoadModel(fd);            \
 			lua_pushnumber(L, model -&gt; param);                   \
 			return 1;                                            \
 		}                                                      \

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -46,8 +46,9 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/Textures/NamedTextures.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
+#include &quot;Rendering/Textures/S3OTextureHandler.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -1745,15 +1746,15 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
-	LocalS3DO&amp; localPiece = localModel-&gt;pieces[piece];
+	LocalModelPiece* localPiece = localModel-&gt;pieces[piece];
 
-	glCallList(localPiece.displist);
+	glCallList(localPiece-&gt;displist);
 
 	return 0;
 }
@@ -1765,12 +1766,12 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	if (localModel == NULL) {
 		return 0;
 	}
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
 
@@ -1790,12 +1791,12 @@
 		return 0;
 	}
 
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	if (localModel == NULL) {
 		return 0;
 	}
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
 
@@ -1869,19 +1870,20 @@
 	CheckDrawingEnabled(L, __FUNCTION__);
 
 	const int fDefID = luaL_checkint(L, 1);
-	const int teamID = luaL_checkint(L, 2);
+	//const int teamID = luaL_checkint(L, 2);
 
-	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
-		return 0;
-	}
+	//if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
+	//	return 0;
+	//}
 	const FeatureDef* fd = featureHandler-&gt;GetFeatureDefByID(fDefID);
 	if (fd == NULL) {
 		return 0;
 	}
-	S3DOModel* model = fd-&gt;LoadModel(teamID);
+	const S3DModel* model = LoadModel(fd);
 	if (model == NULL) {
 		return 0;
 	}
+	//todo: teamcolor?
 	model-&gt;DrawStatic(); // FIXME: finish this, 3do/s3o, copy DrawIndividual...
 
 	return 0;
@@ -3548,8 +3550,16 @@
 static bool ParseUnitTexture(const string&amp; texture)
 {
 	if (texture[1] == 0) {
-		texturehandler-&gt;SetTATexture();
 		glEnable(GL_TEXTURE_2D);
+		if (texture.length() == 4) {
+			if (texture[3] == 0) {
+				glBindTexture(GL_TEXTURE_2D, texturehandler3DO-&gt;GetAtlasTex1ID() );
+			} else {
+				glBindTexture(GL_TEXTURE_2D, texturehandler3DO-&gt;GetAtlasTex2ID() );
+			}
+		} else {
+			glBindTexture(GL_TEXTURE_2D, texturehandler3DO-&gt;GetAtlasTex1ID() );
+		}
 		return true;
 	}
 
@@ -3563,13 +3573,13 @@
 	if (ud == NULL) {
 		return false;
 	}
-	S3DOModel* model = ud-&gt;LoadModel(0);
+	const S3DModel* model = LoadModel(ud);
 	const unsigned int texType = model-&gt;textureType;
 	if (texType == 0) {
 		return false;
 	}
 
-	const CTextureHandler::S3oTex* stex = texturehandler-&gt;GetS3oTex(texType);
+	const CS3OTextureHandler::S3oTex* stex = texturehandlerS3O-&gt;GetS3oTex(texType);
 	if (stex == NULL) {
 		return false;
 	}
@@ -3700,11 +3710,16 @@
 	}
 	else if (texture[0] == '$') {
 		// never enables
-		if (texture == &quot;$units&quot;) {
-			texturehandler-&gt;SetTATexture();
+		if (texture == &quot;$units1&quot; || texture == &quot;$units&quot;) {
+			glBindTexture(GL_TEXTURE_2D,  texturehandler3DO-&gt;GetAtlasTex1ID() );
 			glEnable(GL_TEXTURE_2D);
 			lua_pushboolean(L, true);
 		}
+		if (texture == &quot;$units2&quot;) {
+			glBindTexture(GL_TEXTURE_2D, texturehandler3DO-&gt;GetAtlasTex2ID() );
+			glEnable(GL_TEXTURE_2D);
+			lua_pushboolean(L, true);
+		}
 		else if (texture == &quot;$shadow&quot;) {
 			glBindTexture(GL_TEXTURE_2D, shadowHandler-&gt;shadowTexture);
 			glEnable(GL_TEXTURE_2D);
@@ -3853,8 +3868,8 @@
 {
 	if (texture[1] == 0) {
 		lua_newtable(L);
-		HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, texturehandler-&gt;GetGlobalTexSizeX());
-		HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, texturehandler-&gt;GetGlobalTexSizeY());
+		HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, texturehandler3DO-&gt;GetAtlasTexSizeX());
+		HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, texturehandler3DO-&gt;GetAtlasTexSizeY());
 		return 1;
 	}
 
@@ -3868,13 +3883,13 @@
 	if (ud == NULL) {
 		return 0;
 	}
-	S3DOModel* model = ud-&gt;LoadModel(0);
+	const S3DModel* model = LoadModel(ud);
 	const unsigned int texType = model-&gt;textureType;
 	if (texType == 0) {
 		return 0;
 	}
 
-	const CTextureHandler::S3oTex* stex = texturehandler-&gt;GetS3oTex(texType);
+	const CS3OTextureHandler::S3oTex* stex = texturehandlerS3O-&gt;GetS3oTex(texType);
 	if (stex == NULL) {
 		return 0;
 	}
@@ -3953,8 +3968,8 @@
 	else if (texture[0] == '$') {
 		if (texture == &quot;$units&quot;) {
 			lua_newtable(L);
-			HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, texturehandler-&gt;GetGlobalTexSizeX());
-			HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, texturehandler-&gt;GetGlobalTexSizeY());
+			HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, texturehandler3DO-&gt;GetAtlasTexSizeX());
+			HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, texturehandler3DO-&gt;GetAtlasTexSizeY());
 		}
 		else if (texture == &quot;$shadow&quot;) {
 			lua_newtable(L);
@@ -5191,9 +5206,9 @@
 
 int LuaOpenGL::GetGlobalTexNames(lua_State* L)
 {
-	map&lt;string, CTextureHandler::UnitTexture*&gt;::const_iterator it;
-	const map&lt;string, CTextureHandler::UnitTexture*&gt;&amp; textures =
-		texturehandler-&gt;GetGlobalTextures();
+	map&lt;string, C3DOTextureHandler::UnitTexture*&gt;::const_iterator it;
+	const map&lt;string, C3DOTextureHandler::UnitTexture*&gt;&amp; textures =
+		texturehandler3DO-&gt;GetAtlasTextures();
 
 	lua_newtable(L);
 	int count = 0;
@@ -5214,8 +5229,8 @@
 int LuaOpenGL::GetGlobalTexCoords(lua_State* L)
 {
 	const string name = luaL_checkstring(L, 1);
-	CTextureHandler::UnitTexture* texCoords = NULL;
-	texCoords = texturehandler-&gt;GetTATexture(name);
+	C3DOTextureHandler::UnitTexture* texCoords = NULL;
+	texCoords = texturehandler3DO-&gt;Get3DOTexture(name);
 	if (texCoords) {
 		lua_pushnumber(L, texCoords-&gt;xstart);
 		lua_pushnumber(L, texCoords-&gt;ystart);

Modified: trunk/rts/Lua/LuaRules.cpp
===================================================================
--- trunk/rts/Lua/LuaRules.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaRules.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -26,7 +26,7 @@
 #include &quot;Game/Game.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;

Modified: trunk/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaSyncedCtrl.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -31,7 +31,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Rendering/Env/BaseTreeDrawer.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/CollisionVolume.h&quot;
@@ -868,22 +868,27 @@
 		const string defName = lua_tostring(L, 1);
 		unitDef = unitDefHandler-&gt;GetUnitByName(defName);
 		if (unitDef == NULL) {
-			luaL_error(L, &quot;CreateUnit() bad unitDef name: %s&quot;, defName.c_str());
+			luaL_error(L, &quot;CreateUnit(): bad unitDef name: %s&quot;, defName.c_str());
+			return 0;
 		}
 	} else if (lua_israwnumber(L, 1)) {
 		const int defID = lua_toint(L, 1);
 		unitDef = unitDefHandler-&gt;GetUnitByID(defID);
 		if (unitDef == NULL) {
-			luaL_error(L, &quot;CreateUnit() bad unitDef ID: %i&quot;, defID);
+			luaL_error(L, &quot;CreateUnit(): bad unitDef ID: %i&quot;, defID);
+			return 0;
 		}
 	} else {
 		luaL_error(L, &quot;Incorrect arguments to CreateUnit()&quot;);
 	}
 
-	const float3 pos(luaL_checkfloat(L, 2),
-	                 luaL_checkfloat(L, 3),
-	                 luaL_checkfloat(L, 4));
+	float3 pos(luaL_checkfloat(L, 2),
+	           luaL_checkfloat(L, 3),
+	           luaL_checkfloat(L, 4));
 
+	//clamps the pos in the map boundings
+	pos.CheckInBounds(); //TODO: fix unit init code to work offmap
+
 	const int facing = ParseFacing(L, __FUNCTION__, 5);
 
 	int teamID = CtrlTeam();
@@ -892,17 +897,19 @@
 	}
 	if ((teamID &lt; 0) || (teamID &gt;= MAX_TEAMS)) {
 		luaL_error(L, &quot;CreateUnit(): bad team number: %d&quot;, teamID);
+		return 0;
 	}
 
 	if (teamHandler-&gt;AllyTeam(teamID) &gt;= teamHandler-&gt;ActiveAllyTeams()) {
 		// FIXME: there's a segv in CLosHandler::LosAddAir,
 		//        this is a dirty hack to avoid it
 		luaL_error(L, &quot;CreateUnit(): inactive team: %d&quot;, teamID);
+		return 0;
 	}
 
 
 	if (!FullCtrl() &amp;&amp; (CtrlTeam() != teamID)) {
-		luaL_error(L, &quot;Error in CreateUnit(), bad team %d&quot;, teamID);
+		luaL_error(L, &quot;CreateUnit(): bad team %d&quot;, teamID);
 		return 0;
 	}
 
@@ -913,7 +920,8 @@
 	// FIXME -- allow specifying the 'build' and 'builder' parameters?
 
 	if (inCreateUnit) {
-		luaL_error(L, &quot;CreateUnit() recursion is not permitted&quot;);
+		luaL_error(L, &quot;CreateUnit(): recursion is not permitted&quot;);
+		return 0;
 	}
 	inCreateUnit = true;
 	ASSERT_SYNCED_FLOAT3(pos);
@@ -1012,7 +1020,6 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const int args = lua_gettop(L); // number of arguments
 	if (!lua_istable(L, 2)) {
 		luaL_error(L, &quot;Incorrect arguments to SetUnitCosts&quot;);
 	}

Modified: trunk/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaSyncedRead.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -30,7 +30,7 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Sim/Misc/SideParser.h&quot;
@@ -3025,11 +3025,11 @@
 	if (ud == NULL) {
 		return 0;
 	}
-	const S3DOModel* model = ud-&gt;LoadModel(0);
+	const S3DModel* model = LoadModel(ud);
 	if (model == NULL) {
 		return 0;
 	}
-	const S3DOModel&amp; m = *model;
+	const S3DModel&amp; m = *model;
 	const float3&amp; mid = model-&gt;relMidPos;
 	lua_newtable(L);
 	HSTR_PUSH_NUMBER(L, &quot;height&quot;, m.height);
@@ -4231,10 +4231,10 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	lua_newtable(L);
-	for (int i = 0; i &lt; localModel-&gt;numpieces; i++) {
-		const LocalS3DO&amp; lp = localModel-&gt;pieces[i];
+	for (int i = 0; i &lt; localModel-&gt;pieces.size(); i++) {
+		const LocalModelPiece&amp; lp = *localModel-&gt;pieces[i];
 		lua_pushstring(L, lp.name.c_str());
 		lua_pushnumber(L, i + 1);
 		lua_rawset(L, -3);
@@ -4249,15 +4249,15 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	lua_newtable(L);
-	for (int i = 0; i &lt; localModel-&gt;numpieces; i++) {
-		const LocalS3DO&amp; lp = localModel-&gt;pieces[i];
+	for (int i = 0; i &lt; localModel-&gt;pieces.size(); i++) {
+		const LocalModelPiece&amp; lp = *localModel-&gt;pieces[i];
 		lua_pushnumber(L, i + 1);
 		lua_pushstring(L, lp.name.c_str());
 		lua_rawset(L, -3);
 	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, localModel-&gt;numpieces);
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, localModel-&gt;pieces.size());
 	return 1;
 }
 
@@ -4315,22 +4315,15 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
-	LocalS3DO&amp; lp = localModel-&gt;pieces[piece];
 
-	if (lp.originals3o) {
-		const SS3O&amp; op = *lp.originals3o;
-		return ::GetUnitPieceInfo(L, op);
-	}
-	else if (lp.original3do) {
-		const S3DO&amp; op = *lp.original3do;
-		return ::GetUnitPieceInfo(L, op);
-	}
+	const S3DModelPiece&amp; op = *localModel-&gt;pieces[piece]-&gt;original;
+	return ::GetUnitPieceInfo(L, op);
 
 	return 0;
 }
@@ -4342,12 +4335,12 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	if (localModel == NULL) {
 		return 0;
 	}
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
 	const float3 pos = localModel-&gt;GetRawPiecePos(piece);
@@ -4364,12 +4357,12 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	if (localModel == NULL) {
 		return 0;
 	}
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
 	float3 dir(0,0,0);
@@ -4397,12 +4390,12 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	if (localModel == NULL) {
 		return 0;
 	}
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
 	const float3 dir = localModel-&gt;GetRawPieceDirection(piece);
@@ -4419,12 +4412,12 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 	if (localModel == NULL) {
 		return 0;
 	}
 	const int piece = luaL_checkint(L, 2) - 1;
-	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;numpieces)) {
+	if ((piece &lt; 0) || (piece &gt;= localModel-&gt;pieces.size())) {
 		return 0;
 	}
 	const CMatrix44f mat = unit-&gt;localmodel-&gt;GetRawPieceMatrix(piece);
@@ -4441,16 +4434,16 @@
 	if (unit == NULL) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
-	if (localModel == NULL) {
+	const CCobInstance* cob = unit-&gt;cob;
+	if (cob == NULL) {
 		return 0;
 	}
 
 	if (!lua_isnumber(L, 2)) {
 		// return the whole script-&gt;piece map
 		lua_newtable(L);
-		for (int sp = 0; sp &lt; localModel-&gt;numpieces; sp++) {
-			const int piece = localModel-&gt;scritoa[sp];
+		for (int sp = 0; sp &lt; cob-&gt;pieces.size(); sp++) {
+			const int piece = cob-&gt;ScriptToModel(sp);
 			if (piece != -1) {
 				lua_pushnumber(L, sp);
 				lua_pushnumber(L, piece + 1);
@@ -4461,7 +4454,7 @@
 	}
 
 	const int scriptPiece = lua_toint(L, 2);
-	const int piece = localModel-&gt;ScriptToArray(scriptPiece);
+	const int piece = cob-&gt;ScriptToModel(scriptPiece);
 	if (piece &lt; 0) {
 		return 0;
 	}
@@ -4480,11 +4473,11 @@
 	if (unit-&gt;cob == NULL) {
 		return 0;
 	}
-	const vector&lt;struct PieceInfo&gt;&amp; pieces = unit-&gt;cob-&gt;pieces;
+	const vector&lt;LocalModelPiece*&gt;&amp; pieces = unit-&gt;cob-&gt;pieces;
 
 	lua_newtable(L);
 	for (int sp = 0; sp &lt; pieces.size(); sp++) {
-		lua_pushstring(L, pieces[sp].name.c_str());
+		lua_pushstring(L, pieces[sp]-&gt;name.c_str());
 		lua_pushnumber(L, sp);
 		lua_rawset(L, -3);
 	}

Modified: trunk/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitDefs.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaUnitDefs.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -26,7 +26,7 @@
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/IconHandler.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
@@ -573,8 +573,8 @@
 #define TYPE_MODEL_FUNC(name, param)              \
 	static int name(lua_State* L, const void* data) \
 	{                                               \
-		const UnitDef&amp; ud = *((const UnitDef*)data);  \
-		const S3DOModel* model = ud.LoadModel(0);     \
+		const UnitDef* ud = ((const UnitDef*)data);  \
+		const S3DModel* model = LoadModel(ud);     \
 		lua_pushnumber(L, model -&gt; param);            \
 		return 1;                                     \
 	}
@@ -627,7 +627,7 @@
 	ADD_FUNCTION(&quot;decoyDef&quot;,           ud.decoyDef,           UnitDefToID);
 	ADD_FUNCTION(&quot;weapons&quot;,            ud.weapons,            WeaponsTable);
 	ADD_FUNCTION(&quot;sounds&quot;,             ud.sounds,             SoundsTable);
-	ADD_FUNCTION(&quot;model&quot;,              ud.model,              ModelDefTable);
+	ADD_FUNCTION(&quot;model&quot;,              ud.modelDef,           ModelDefTable);
 	ADD_FUNCTION(&quot;moveData&quot;,           ud.movedata,           MoveDataTable);
 	ADD_FUNCTION(&quot;shieldWeaponDef&quot;,    ud.shieldWeaponDef,    WeaponDefToID);
 	ADD_FUNCTION(&quot;stockpileWeaponDef&quot;, ud.stockpileWeaponDef, WeaponDefToID);

Modified: trunk/rts/Lua/LuaUnitRendering.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitRendering.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Lua/LuaUnitRendering.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -14,9 +14,10 @@
 #include &quot;LuaHashString.h&quot;
 #include &quot;LuaUtils.h&quot;
 
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
+#include &quot;Rendering/Textures/S3OTextureHandler.h&quot;
 #include &quot;Rendering/Textures/NamedTextures.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
@@ -155,17 +156,17 @@
 	if ((unit == NULL) || (unit-&gt;localmodel == NULL)) {
 		return 0;
 	}
-	const LocalS3DOModel* localModel = unit-&gt;localmodel;
+	const LocalModel* localModel = unit-&gt;localmodel;
 
 	const unsigned int lod   = (unsigned int)luaL_checknumber(L, 2) - 1;
 	if (lod &gt;= unit-&gt;lodCount) {
 		return 0;
 	}
 	const unsigned int piece = (unsigned int)luaL_checknumber(L, 3) - 1;
-	if (piece &gt;= localModel-&gt;numpieces) {
+	if (piece &gt;= localModel-&gt;pieces.size()) {
 		return 0;
 	}
-	LocalS3DO&amp; localPiece = localModel-&gt;pieces[piece];
+	LocalModelPiece* localPiece = localModel-&gt;pieces[piece];
 
 	unsigned int dlist = 0;
 	if (lua_isnumber(L, 4)) {
@@ -173,10 +174,10 @@
 		CLuaDisplayLists&amp; displayLists = CLuaHandle::GetActiveDisplayLists();
 		dlist = displayLists.GetDList(ilist);
 	} else {
-		dlist = localPiece.displist; // set to the default
+		dlist = localPiece-&gt;displist; // set to the default
 	}
 
-	localPiece.lodDispLists[lod] = dlist;
+	localPiece-&gt;lodDispLists[lod] = dlist;
 
 	return 0;
 }
@@ -264,13 +265,13 @@
 	if (ud == NULL) {
 		return 0;
 	}
-	S3DOModel* model = ud-&gt;LoadModel(0);
+	const S3DModel* model = LoadModel(ud);
 	const unsigned int texType = model-&gt;textureType;
 	if (texType == 0) {
 		return 0;
 	}
 
-	const CTextureHandler::S3oTex* stex = texturehandler-&gt;GetS3oTex(texType);
+	const CS3OTextureHandler::S3oTex* stex = texturehandlerS3O-&gt;GetS3oTex(texType);
 	if (stex == NULL) {
 		return 0;
 	}
@@ -317,10 +318,14 @@
 		}
 	}
 	else if (image[0] == '$') {
-		if (image == &quot;$units&quot;) {
+		if (image == &quot;$units&quot; || image == &quot;$units1&quot;) {
 			texUnit.type = LuaMatTexture::LUATEX_GL;
-			texUnit.openglID = texturehandler-&gt;GetGlobalTexID();
+			texUnit.openglID = texturehandler3DO-&gt;GetAtlasTex1ID();
 		}
+		if (image == &quot;$units2&quot;) {
+			texUnit.type = LuaMatTexture::LUATEX_GL;
+			texUnit.openglID = texturehandler3DO-&gt;GetAtlasTex2ID();
+		}
 		else if (image == &quot;$shadow&quot;) {
 			texUnit.type = LuaMatTexture::LUATEX_SHADOWMAP;
 		}

Modified: trunk/rts/Rendering/FartextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/FartextureHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/FartextureHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -3,11 +3,10 @@
 #include &quot;mmgr.h&quot;
 
 #include &quot;FartextureHandler.h&quot;
-#include &quot;UnitModels/3DOParser.h&quot;
-#include &quot;GL/myGL.h&quot;
 #include &quot;GlobalUnsynced.h&quot;
 #include &quot;UnitModels/UnitDrawer.h&quot;
 #include &quot;Textures/Bitmap.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 
 CFartextureHandler* fartextureHandler = NULL;
@@ -30,9 +29,6 @@
 {
 	delete[] farTextureMem;
 	glDeleteTextures (1, &amp;farTexture);
-
-	delete texturehandler;
-	texturehandler=0;
 }
 
 
@@ -41,7 +37,7 @@
  * On the next CreateFarTextures() call the fartexture for this model will be
  * created.
  */
-void CFartextureHandler::CreateFarTexture(S3DOModel* model)
+void CFartextureHandler::CreateFarTexture(S3DModel* model)
 {
 	GML_STDMUTEX_LOCK(tex); // CreateFarTexture
 	pending.push_back(model);
@@ -56,7 +52,7 @@
 void CFartextureHandler::CreateFarTextures()
 {
 	GML_STDMUTEX_LOCK(tex); // CreateFarTextures
-	for(std::vector&lt;S3DOModel*&gt;::const_iterator it = pending.begin(); it != pending.end(); ++it) {
+	for(std::vector&lt;S3DModel*&gt;::const_iterator it = pending.begin(); it != pending.end(); ++it) {
 		ReallyCreateFarTexture(*it);
 	}
 	pending.clear();
@@ -66,7 +62,7 @@
 /**
  * @brief Really create the far texture for the given model.
  */
-void CFartextureHandler::ReallyCreateFarTexture(S3DOModel* model)
+void CFartextureHandler::ReallyCreateFarTexture(S3DModel* model)
 {
 	//UnitModelGeometry&amp; geometry=*model.geometry;
 	PUSH_CODE_MODE;
@@ -115,7 +111,7 @@
 	unsigned char buf[16*16*4];
 	for(int a=0;a&lt;8;++a){
 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-		texturehandler-&gt;SetTATexture();
+		texturehandler3DO-&gt;Set3doAtlases();
 		glPushMatrix();
 		glTranslatef(0,-model-&gt;height*0.5f,0);
 		model-&gt;DrawStatic();

Modified: trunk/rts/Rendering/FartextureHandler.h
===================================================================
--- trunk/rts/Rendering/FartextureHandler.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/FartextureHandler.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -3,9 +3,8 @@
 
 #include &lt;vector&gt;
 #include &quot;GL/myGL.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 
-struct S3DOModel;
-
 /**
  * @brief Cheap unit lodding using imposters.
  */
@@ -14,17 +13,17 @@
 public:
 	CFartextureHandler(void);
 	~CFartextureHandler(void);
-	void CreateFarTexture(S3DOModel* model);
+	void CreateFarTexture(S3DModel* model);
 	void CreateFarTextures();
 	GLuint GetTextureID() const { return farTexture; }
 
 private:
-	void ReallyCreateFarTexture(S3DOModel* model);
+	void ReallyCreateFarTexture(S3DModel* model);
 
 	GLuint farTexture;
 	unsigned char* farTextureMem;
 	int usedFarTextures;
-	std::vector&lt;S3DOModel*&gt; pending;
+	std::vector&lt;S3DModel*&gt; pending;
 };
 
 extern CFartextureHandler* fartextureHandler;

Modified: trunk/rts/Rendering/Textures/TextureAtlas.h
===================================================================
--- trunk/rts/Rendering/Textures/TextureAtlas.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/Textures/TextureAtlas.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -70,6 +70,9 @@
 	//return a pointer to a Texture struct of the specified texture, this pointer points to the actuall Texture struct stored, do not delete or modify
 	AtlasedTexture* GetTexturePtr(const std::string&amp; name);
 
+	int xsize;
+	int ysize;
+
 protected:
 	struct MemTex
 	{
@@ -89,8 +92,6 @@
 	std::map&lt;std::string, AtlasedTexture&gt; textures;
 	int maxxsize;
 	int maxysize;
-	int xsize;
-	int ysize;
 	int usedPixels;
 	bool initialized;
 

Deleted: trunk/rts/Rendering/Textures/TextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/Textures/TextureHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -1,375 +0,0 @@
-// TextureHandler.cpp: implementation of the CTextureHandler class.
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &quot;StdAfx.h&quot;
-
-#include &lt;algorithm&gt;
-#include &lt;cctype&gt;
-#include &lt;set&gt;
-#include &lt;sstream&gt;
-#include &quot;mmgr.h&quot;
-
-#include &quot;TextureHandler.h&quot;
-#include &quot;FileSystem/FileHandler.h&quot;
-#include &quot;FileSystem/SimpleParser.h&quot;
-#include &quot;Sim/Misc/GlobalSynced.h&quot;
-#include &quot;Sim/Misc/TeamHandler.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &quot;ConfigHandler.h&quot;
-#include &quot;Platform/errorhandler.h&quot;
-#include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/ShadowHandler.h&quot;
-#include &quot;Bitmap.h&quot;
-#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;TAPalette.h&quot;
-#include &quot;Util.h&quot;
-#include &quot;Exceptions.h&quot;
-
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
-
-CTextureHandler* texturehandler=0;
-
-struct TexFile {
-	CBitmap tex;
-	std::string name;
-};
-
-static int CompareTatex2( const void *arg1, const void *arg2 ){
-	if((*(TexFile**)arg1)-&gt;tex.ysize &gt; (*(TexFile**)arg2)-&gt;tex.ysize)
-	   return -1;
-   return 1;
-}
-
-CTextureHandler::CTextureHandler()
-{
-	PrintLoadMsg(&quot;Creating unit textures&quot;);
-
-	CFileHandler file(&quot;unittextures/tatex/teamtex.txt&quot;);
-	CSimpleParser parser(file);
-
-	std::set&lt;std::string&gt; teamTexes;
-	while(!file.Eof()) {
-		teamTexes.insert(StringToLower(parser.GetCleanLine()));
-	}
-
-	TexFile* texfiles[10000];
-
-	int numfiles = 0;
-	int totalSize = 0;
-
-	std::vector&lt;std::string&gt; files2 = CFileHandler::FindFiles(&quot;unittextures/tatex/&quot;, &quot;*.bmp&quot;);
-	std::vector&lt;std::string&gt; files = CFileHandler::FindFiles(&quot;unittextures/tatex/&quot;, &quot;*.tga&quot;);
-
-	for(std::vector&lt;std::string&gt;::iterator fi = files2.begin(); fi != files2.end(); ++fi) {
-		files.push_back(*fi);
-	}
-
-	std::set&lt;string&gt; usedNames;
-
-	for(std::vector&lt;std::string&gt;::iterator fi = files.begin(); fi != files.end(); ++fi) {
-		std::string s = std::string(*fi);
-		std::string s2 = s;
-
-		s2.erase(0, s2.find_last_of('/') + 1);
-		s2 = StringToLower(s2.substr(0, s2.find_last_of('.')));
-
-		if(usedNames.find(s2)!=usedNames.end()) //avoid duplicate names and give tga images priority
-			continue;
-		usedNames.insert(s2);
-
-		if(teamTexes.find(s2) == teamTexes.end()){
-			TexFile* tex = SAFE_NEW TexFile;
-			tex-&gt;tex.Load(s,30);
-			tex-&gt;name = s2;
-			texfiles[numfiles++] = tex;
-			totalSize += tex-&gt;tex.xsize * tex-&gt;tex.ysize;
-		} else {
-			for(int a = 0; a &lt; teamHandler-&gt;ActiveTeams(); ++a){
-				TexFile* tex = CreateTeamTex(s, s2, a);
-				texfiles[numfiles++] = tex;
-				totalSize += tex-&gt;tex.xsize * tex-&gt;tex.ysize;
-			}
-		}
-	}
-
-	for(int a=0;a&lt;256;++a){
-		string name=&quot;ta_color&quot;;
-		char t[50];
-		sprintf(t,&quot;%i&quot;,a);
-		name+=t;
-		TexFile* tex=SAFE_NEW TexFile;
-		tex-&gt;name=name;
-		tex-&gt;tex.Alloc(1,1);
-		tex-&gt;tex.mem[0]=palette[a][0];
-		tex-&gt;tex.mem[1]=palette[a][1];
-		tex-&gt;tex.mem[2]=palette[a][2];
-		tex-&gt;tex.mem[3]=30;
-
-		texfiles[numfiles++]=tex;
-		totalSize+=tex-&gt;tex.xsize*tex-&gt;tex.ysize;
-	}
-	totalSize=(int)(totalSize * 1.2f);		//pessimistic guess about how much space will be wasted
-
-	if(totalSize&lt;1024*1024){
-		bigTexX=1024;
-		bigTexY=1024;
-	} else if(totalSize&lt;1024*2048){
-		bigTexX=1024;
-		bigTexY=2048;
-	} else if(totalSize&lt;2048*2048){
-		bigTexX=2048;
-		bigTexY=2048;
-	} else {
-		bigTexX=2048;
-		bigTexY=2048;
-		handleerror(0,&quot;Too many/large unit textures to fit in 2048*2048&quot;,&quot;Error&quot;,0);
-	}
-
-	qsort(texfiles,numfiles,sizeof(TexFile*),CompareTatex2);
-
-	unsigned char* tex=SAFE_NEW unsigned char[bigTexX*bigTexY*4];
-	for(int a=0;a&lt;bigTexX*bigTexY*4;++a){
-		tex[a]=128;
-	}
-
-	int cury=0;
-	int maxy=0;
-	int curx=0;
-	int foundx = 0, foundy = 0;
-	std::list&lt;int2&gt; nextSub;
-	std::list&lt;int2&gt; thisSub;
-	for(int a=0;a&lt;numfiles;++a){
-		CBitmap* curtex=&amp;texfiles[a]-&gt;tex;
-
-		bool done=false;
-		while(!done){
-			if(thisSub.empty()){
-				if(nextSub.empty()){
-					cury=maxy;
-					maxy+=curtex-&gt;ysize;
-					if(maxy&gt;bigTexY){
-						handleerror(0,&quot;Too many/large unit textures&quot;,&quot;Error&quot;,0);
-						break;
-					}
-					thisSub.push_back(int2(0,cury));
-				} else {
-					thisSub=nextSub;
-					nextSub.clear();
-				}
-			}
-			if(thisSub.front().x+curtex-&gt;xsize&gt;bigTexX){
-				thisSub.clear();
-				continue;
-			}
-			if(thisSub.front().y+curtex-&gt;ysize&gt;maxy){
-				thisSub.pop_front();
-				continue;
-			}
-			//ok found space for us
-			foundx=thisSub.front().x;
-			foundy=thisSub.front().y;
-			done=true;
-
-			if(thisSub.front().y+curtex-&gt;ysize&lt;maxy){
-				nextSub.push_back(int2(thisSub.front().x,thisSub.front().y+curtex-&gt;ysize));
-			}
-
-			thisSub.front().x+=curtex-&gt;xsize;
-			while(thisSub.size()&gt;1 &amp;&amp; thisSub.front().x &gt;= (++thisSub.begin())-&gt;x){
-				(++thisSub.begin())-&gt;x=thisSub.front().x;
-				thisSub.erase(thisSub.begin());
-			}
-
-		}
-		for(int y=0;y&lt;curtex-&gt;ysize;y++){
-			for(int x=0;x&lt;curtex-&gt;xsize;x++){
-//				if(curtex-&gt;mem[(y*curtex-&gt;xsize+x)*4]==254 &amp;&amp; curtex-&gt;mem[(y*curtex-&gt;xsize+x)*4+1]==0 &amp;&amp; curtex-&gt;mem[(y*curtex-&gt;xsize+x)*4+2]==254){
-//					tex[((cury+y)*bigTexX+(curx+x))*4+3]=0;
-//				} else {
-					for(int col=0;col&lt;4;col++){
-						tex[((foundy+y)*bigTexX+(foundx+x))*4+col]=curtex-&gt;mem[(y*curtex-&gt;xsize+x)*4+col];
-//					}
-				}
-			}
-		}
-
-		UnitTexture* unittex=SAFE_NEW UnitTexture;
-
-		unittex-&gt;xstart=(foundx+0.5f)/(float)bigTexX;
-		unittex-&gt;ystart=(foundy+0.5f)/(float)bigTexY;
-		unittex-&gt;xend=(foundx+curtex-&gt;xsize-0.5f)/(float)bigTexX;
-		unittex-&gt;yend=(foundy+curtex-&gt;ysize-0.5f)/(float)bigTexY;
-		textures[texfiles[a]-&gt;name]=unittex;
-
-		curx+=curtex-&gt;xsize;
-		delete texfiles[a];
-
-	}
-
-	glGenTextures(1, &amp;globalTex);
-	glBindTexture(GL_TEXTURE_2D, globalTex);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
-	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR/*_MIPMAP_NEAREST*/);
-	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8 ,bigTexX, bigTexY, 0, GL_RGBA, GL_UNSIGNED_BYTE, tex);
-	//glBuildMipmaps(GL_TEXTURE_2D,GL_RGBA8 ,bigTexX, bigTexY, GL_RGBA, GL_UNSIGNED_BYTE, tex);
-//	CBitmap save(tex,bigTexX,bigTexY);
-	//save.Save(&quot;unittex-1x.jpg&quot;);
-
-	UnitTexture* t=SAFE_NEW UnitTexture;
-	t-&gt;xstart=0;
-	t-&gt;ystart=0;
-	t-&gt;xend=1;
-	t-&gt;yend=1;
-
-	s3oTextures.push_back(S3oTex());
-	textures[&quot; &quot;]=t;
-
-	delete[] tex;
-
-	s3oTextures.push_back(S3oTex());
-}
-
-CTextureHandler::~CTextureHandler()
-{
-	std::map&lt;string,UnitTexture*&gt;::iterator tti;
-	for(tti=textures.begin();tti!=textures.end();++tti){
-		delete tti-&gt;second;
-	}
-	while(s3oTextures.size()&gt;1){
-		glDeleteTextures (1, &amp;s3oTextures.back().tex1);
-		glDeleteTextures (1, &amp;s3oTextures.back().tex2);
-		s3oTextures.pop_back();
-	}
-	glDeleteTextures (1, &amp;(globalTex));
-}
-
-CTextureHandler::UnitTexture* CTextureHandler::GetTATexture(std::string name, int team, int teamTex)
-{
-	if(teamTex){
-		char c[50];
-		sprintf(c,&quot;team%d_&quot;,team);
-		name=string(c)+name;
-	}
-
-	StringToLowerInPlace(name);
-
-	std::map&lt;std::string,UnitTexture*&gt;::iterator tti;
-	if((tti=textures.find(name))!=textures.end()){
-		return tti-&gt;second;
-	}
-	logOutput &lt;&lt; &quot;Unknown texture &quot; &lt;&lt; name.c_str() &lt;&lt; &quot;\n&quot;;
-	return textures[&quot; &quot;];
-}
-
-CTextureHandler::UnitTexture* CTextureHandler::GetTATexture(const std::string&amp; name)
-{
-	std::map&lt;std::string,UnitTexture*&gt;::iterator tti;
-	if((tti=textures.find(name))!=textures.end()){
-
-		return tti-&gt;second;
-	}
-	logOutput &lt;&lt; &quot;Unknown texture &quot; &lt;&lt; name.c_str() &lt;&lt; &quot;\n&quot;;
-	return textures[&quot; &quot;];
-}
-
-void CTextureHandler::SetTATexture()
-{
-	glBindTexture(GL_TEXTURE_2D, globalTex);
-}
-
-void CTextureHandler::LoadS3OTexture(S3DOModel *model) {
-	string totalName=model-&gt;tex1+model-&gt;tex2;
-
-	if(s3oTextureNames.find(totalName)!=s3oTextureNames.end()){
-		model-&gt;textureType=s3oTextureNames[totalName];
-	}
-	model-&gt;textureType=0;
-//	GML_STDMUTEX_LOCK(model); // LoadS3OTexture
-	loadTextures.push_back(model);
-}
-
-void CTextureHandler::Update() {
-	GML_STDMUTEX_LOCK(model); // Update
-	for(std::vector&lt;S3DOModel *&gt;::iterator i=loadTextures.begin(); i!=loadTextures.end();++i)
-		(*i)-&gt;textureType=LoadS3OTextureNow((char*)(*i)-&gt;tex1.c_str(),(char*)(*i)-&gt;tex2.c_str());
-	loadTextures.clear();
-}
-
-int CTextureHandler::LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2)
-{
-	string totalName=tex1+tex2;
-
-	if(s3oTextureNames.find(totalName)!=s3oTextureNames.end()){
-		return s3oTextureNames[totalName];
-	}
-	int newNum=s3oTextures.size();
-	S3oTex tex;
-	tex.num=newNum;
-
-	CBitmap bm;
-	if (!bm.Load(string(&quot;unittextures/&quot;+tex1)))
-		throw content_error(&quot;Could not load S3O texture from file unittextures/&quot; + tex1);
-	tex.tex1 = bm.CreateTexture(true);
-	tex.tex1SizeX = bm.xsize;
-	tex.tex1SizeY = bm.ysize;
-	tex.tex2=0;
-	tex.tex2SizeX = 0;
-	tex.tex2SizeY = 0;
-	//if(unitDrawer-&gt;advShading)
-{
-		CBitmap bm;
-		// No error checking here... other code relies on an empty texture
-		// being generated if it couldn't be loaded.
-		// Also many map features specify a tex2 but don't ship it with the map,
-		// so throwing here would cause maps to break.
-		if(!bm.Load(string(&quot;unittextures/&quot;+tex2))) {
-			bm.Alloc(1,1);
-			bm.mem[3] = 255;//file not found, set alpha to white so unit is visible
-		}
-		tex.tex2 = bm.CreateTexture(true);
-		tex.tex2SizeX = bm.xsize;
-		tex.tex2SizeY = bm.ysize;
-}
-	s3oTextures.push_back(tex);
-	s3oTextureNames[totalName]=newNum;
-	return newNum;
-}
-
-void CTextureHandler::SetS3oTexture(int num)
-{
-	if (shadowHandler-&gt;inShadowPass) {
-		glBindTexture(GL_TEXTURE_2D, s3oTextures[num].tex2);
-	} else {
-		glBindTexture(GL_TEXTURE_2D, s3oTextures[num].tex1);
-		//if(unitDrawer-&gt;advShading){
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glBindTexture(GL_TEXTURE_2D, s3oTextures[num].tex2);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		//}
-	}
-}
-
-TexFile* CTextureHandler::CreateTeamTex(const std::string&amp; name, const std::string&amp; name2, int team)
-{
-	TexFile* tex=SAFE_NEW TexFile;
-	tex-&gt;tex.Load(name,30);
-	char tmp[256];
-	sprintf(tmp,&quot;%s%02i&quot;,name2.c_str(),team);
-	tex-&gt;name=tmp;
-
-	unsigned char* teamCol=teamHandler-&gt;Team(team)-&gt;color;
-	CBitmap* bm=&amp;tex-&gt;tex;
-	for(int a=0;a&lt;bm-&gt;ysize*bm-&gt;xsize;++a){
-		if(bm-&gt;mem[a*4]==bm-&gt;mem[a*4+2] &amp;&amp; bm-&gt;mem[a*4+1]==0){
-			float lum=bm-&gt;mem[a*4]/255.0f;
-			bm-&gt;mem[a*4+0]=(unsigned char)(std::min(255,int(teamCol[0]*lum*1.5f)));
-			bm-&gt;mem[a*4+1]=(unsigned char)(std::min(255,int(teamCol[1]*lum*1.5f)));
-			bm-&gt;mem[a*4+2]=(unsigned char)(std::min(255,int(teamCol[2]*lum*1.5f)));
-		}
-	}
-	return tex;
-}
-

Deleted: trunk/rts/Rendering/Textures/TextureHandler.h
===================================================================
--- trunk/rts/Rendering/Textures/TextureHandler.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/Textures/TextureHandler.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -1,74 +0,0 @@
-#ifndef TEXTUREHANDLER_H
-#define TEXTUREHANDLER_H
-// TextureHandler.h: interface for the CTextureHandler class.
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &lt;map&gt;
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
-
-struct TexFile;
-class CFileHandler;
-
-class CTextureHandler
-{
-public:
-	struct UnitTexture {
-		float xstart;
-		float xend;
-		float ystart;
-		float yend;
-	};
-	struct S3oTex {
-		int num;
-		GLuint tex1;
-		unsigned int tex1SizeX;
-		unsigned int tex1SizeY;
-		GLuint tex2;
-		unsigned int tex2SizeX;
-		unsigned int tex2SizeY;
-	};
-
-	CTextureHandler();
-	virtual ~CTextureHandler();
-
-	void SetTATexture();
-	UnitTexture* GetTATexture(std::string name, int team, int teamTex);
-	UnitTexture* GetTATexture(const std::string&amp; name);
-
-	std::vector&lt;S3DOModel *&gt; loadTextures;
-	void Update();
-	void LoadS3OTexture(S3DOModel *model);
-	int LoadS3OTextureNow(const std::string&amp; tex1, const std::string&amp; tex2);
-	void SetS3oTexture(int num);
-
-	const S3oTex* GetS3oTex(int num) {
-		if ((num &lt; 0) || (num &gt;= (int)s3oTextures.size())) {
-			return NULL;
-		}
-		return &amp;s3oTextures[num];
-	}
-
-	unsigned int GetGlobalTexID() const  { return globalTex; }
-	unsigned int GetGlobalTexSizeX() const { return bigTexX; }
-	unsigned int GetGlobalTexSizeY() const { return bigTexY; }
-	const std::map&lt;std::string, UnitTexture*&gt;&amp; GetGlobalTextures() const { return textures; }
-
-private:
-	std::map&lt;std::string, UnitTexture*&gt; textures;
-	GLuint globalTex;
-	int bigTexX;
-	int bigTexY;
-
-	std::map&lt;std::string, int&gt; s3oTextureNames;
-	std::vector&lt;S3oTex&gt; s3oTextures;
-
-	TexFile* CreateTeamTex(const std::string&amp; name, const std::string&amp; name2, int team);
-};
-
-extern CTextureHandler* texturehandler;
-
-#endif /* TEXTUREHANDLER_H */

Deleted: trunk/rts/Rendering/UnitModels/3DModelParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -1,408 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;Rendering/GL/myGL.h&quot;
-#include &lt;algorithm&gt;
-#include &lt;cctype&gt;
-#include &quot;mmgr.h&quot;
-
-#include &quot;3DModelParser.h&quot;
-#include &quot;3DOParser.h&quot;
-#include &quot;s3oParser.h&quot;
-#include &quot;Sim/Units/COB/CobInstance.h&quot;
-#include &quot;Util.h&quot;
-
-C3DModelParser* modelParser=0;
-
-C3DModelParser::C3DModelParser(void)
-{
-	unit3doparser=SAFE_NEW C3DOParser();
-	units3oparser=SAFE_NEW CS3OParser();
-}
-
-C3DModelParser::~C3DModelParser(void)
-{
-	delete unit3doparser;
-	delete units3oparser;
-}
-
-S3DOModel* C3DModelParser::Load3DModel(std::string name, float scale, int side)
-{
-	// TODO: abstract this
-	StringToLowerInPlace(name);
-	if (name.find(&quot;.s3o&quot;) != std::string::npos)
-		return units3oparser-&gt;LoadS3O(name, scale, side);
-	else
-		return unit3doparser-&gt;Load3DO(name, scale, side);
-}
-
-/*
-S3DOModel* C3DModelParser::Load3DO(string name,float scale,int side,const float3&amp; offsets)
-{
-	StringToLowerInPlace(name);
-	if(name.find(&quot;.s3o&quot;)!=string::npos)
-		return units3oparser-&gt;LoadS3O(name,scale,side);
-	else
-		return unit3doparser-&gt;Load3DO(name,scale,side,offsets);
-}
-*/
-
-void C3DModelParser::Update() {
-	GML_STDMUTEX_LOCK(model); // Update
-	units3oparser-&gt;Update();
-	unit3doparser-&gt;Update();
-
-	for(std::set&lt;CUnit *&gt;::iterator i=fixLocalModels.begin(); i!=fixLocalModels.end(); ++i)
-		FixLocalModel(*i);
-	fixLocalModels.clear();
-
-	for(std::vector&lt;LocalS3DOModel *&gt;::iterator i=deleteLocalModels.begin(); i!=deleteLocalModels.end(); ++i)
-		delete *i;
-	deleteLocalModels.clear();
-}
-
-void C3DModelParser::CreateLocalModel(CUnit *unit)
-{
-	GML_STDMUTEX_LOCK(model); // CreateLocalModel
-	unit-&gt;localmodel=CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
-	fixLocalModels.insert(unit);
-}
-
-void C3DModelParser::DeleteLocalModel(CUnit *unit)
-{
-	GML_STDMUTEX_LOCK(model); // DeleteLocalModel
-	fixLocalModels.erase(unit);
-	deleteLocalModels.push_back(unit-&gt;localmodel);
-}
-
-void C3DModelParser::FixLocalModel(CUnit *unit)
-{
-	if (unit-&gt;model-&gt;rootobject3do) {
-		unit3doparser-&gt;FixLocalModel(unit-&gt;model,unit-&gt;localmodel,&amp;unit-&gt;cob-&gt;pieces);
-	} else {
-		units3oparser-&gt;FixLocalModel(unit-&gt;model,unit-&gt;localmodel,&amp;unit-&gt;cob-&gt;pieces);
-	}
-}
-
-
-LocalS3DOModel *C3DModelParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
-{
-	LocalS3DOModel* lm;
-	if (model-&gt;rootobject3do) {
-		lm = unit3doparser-&gt;CreateLocalModel(model,pieces);
-	} else {
-		lm = units3oparser-&gt;CreateLocalModel(model,pieces);
-	}
-	return lm;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-//
-//  S3DOModel
-//
-
-void S3DOModel::DrawStatic()
-{
-	if (rootobject3do)
-		rootobject3do-&gt;DrawStatic();
-	else
-		rootobjects3o-&gt;DrawStatic();
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-//
-//  LocalS3DOModel
-//
-
-LocalS3DOModel::~LocalS3DOModel()
-{
-	delete [] pieces;
-	delete [] scritoa;
-}
-
-
-static const float CORDDIV = 65536.0f;
-static const float ANGDIV  = 182.0f;
-
-
-void LocalS3DOModel::Draw() const
-{
-	pieces-&gt;Draw();
-}
-
-
-void LocalS3DOModel::DrawLOD(unsigned int lod) const
-{
-	if (lod &gt; lodCount) {
-		return;
-	}
-	pieces-&gt;DrawLOD(lod);
-}
-
-
-void LocalS3DOModel::SetLODCount(unsigned int count)
-{
-	lodCount = count;
-	pieces-&gt;SetLODCount(count);
-}
-
-
-void LocalS3DOModel::ApplyRawPieceTransform(int piecenum) const
-{
-	pieces[piecenum].ApplyTransform();
-}
-
-
-float3 LocalS3DOModel::GetRawPiecePos(int piecenum) const
-{
-	CMatrix44f mat;
-	pieces[piecenum].GetPiecePosIter(&amp;mat);
-
-	// stupid fix for valkyres
-	const S3DO* p3do = pieces[piecenum].original3do;
-	if (p3do &amp;&amp; (p3do-&gt;vertices.size() == 2)) {
-		const std::vector&lt;S3DOVertex&gt;&amp; pv = p3do-&gt;vertices;
-		if (pv[0].pos.y &gt; pv[1].pos.y) {
-			mat.Translate(pv[0].pos.x, pv[0].pos.y, -pv[0].pos.z);
-		} else {
-			mat.Translate(pv[1].pos.x, pv[1].pos.y, -pv[1].pos.z);
-		}
-	}
-
-/*
-	logOutput.Print(&quot;%f %f %f %f&quot;,mat[0],mat[4],mat[8],mat[12]);
-	logOutput.Print(&quot;%f %f %f %f&quot;,mat[1],mat[5],mat[9],mat[13]);
-	logOutput.Print(&quot;%f %f %f %f&quot;,mat[2],mat[6],mat[10],mat[14]);
-	logOutput.Print(&quot;%f %f %f %f&quot;,mat[3],mat[7],mat[11],mat[15]);/**/
-	float3 pos = mat.GetPos();
-	pos.z *= -1.0f;
-	pos.x *= -1.0f;
-
-	return pos;
-}
-
-
-CMatrix44f LocalS3DOModel::GetRawPieceMatrix(int piecenum) const
-{
-	CMatrix44f mat;
-	pieces[piecenum].GetPiecePosIter(&amp;mat);
-
-	return mat;
-}
-
-
-//gets the number of vertices in the piece
-int LocalS3DOModel::GetRawPieceVertCount(int piecenum) const
-{
-	if (pieces[piecenum].original3do) {
-		S3DO &amp;orig = *pieces[piecenum].original3do;
-		return orig.vertices.size();
-	} else {
-		SS3O &amp;orig = *pieces[piecenum].originals3o;
-		return orig.vertices.size();
-	}
-}
-
-
-void LocalS3DOModel::GetRawEmitDirPos(int piecenum, float3 &amp;pos, float3 &amp;dir) const
-{
-	CMatrix44f mat;
-	pieces[piecenum].GetPiecePosIter(&amp;mat);
-
-	//hm...
-	static const float3 invAxis(-1, 1, -1);
-	static const float3 invVertAxis(1, 1, -1);
-
-	if (pieces[piecenum].original3do) {
-		S3DO &amp;orig = *pieces[piecenum].original3do;
-
-		if (orig.vertices.size() == 0) {
-			pos = mat.GetPos()*invAxis;
-			dir = mat.Mul(float3(0,0,-1))*invAxis - pos;
-		}
-		else if (orig.vertices.size() == 1) {
-			pos = mat.GetPos()*invAxis;
-			dir = mat.Mul(orig.vertices[0].pos*invVertAxis)*invAxis - pos;
-		}
-		else {
-			float3 p1 = mat.Mul(orig.vertices[0].pos * invVertAxis) * invAxis;
-
-			float3 p2 = mat.Mul(orig.vertices[1].pos * invVertAxis) * invAxis;
-
-			pos = p1;
-			dir = p2 - p1;
-		}
-	}
-	else {
-		SS3O &amp;orig = *pieces[piecenum].originals3o;
-
-		if (orig.vertices.size() == 0) {
-			pos = mat.GetPos()*invAxis;
-			dir = mat.Mul(float3(0,0,-1))*invAxis - pos;
-		}
-		else if(orig.vertices.size() == 1) {
-			pos = mat.GetPos()*invAxis;
-			dir = mat.Mul(orig.vertices[0].pos*invVertAxis)*invAxis - pos;
-		}
-		else {
-			float3 p1 = mat.Mul(orig.vertices[0].pos * invVertAxis) * invAxis;
-
-			float3 p2 = mat.Mul(orig.vertices[1].pos * invVertAxis) * invAxis;
-
-			pos = p1;
-			dir = p2 - p1;
-		}
-	}
-}
-
-
-//Only useful for special pieces used for emit-sfx
-float3 LocalS3DOModel::GetRawPieceDirection(int piecenum) const
-{
-	if (pieces[piecenum].original3do) {
-		S3DO &amp;orig = *pieces[piecenum].original3do;
-		if (orig.vertices.size() &lt; 2) {
-			//logOutput.Print(&quot;Use of GetPieceDir on strange piece (%d vertices)&quot;, orig.vertices.size());
-			return float3(1,1,1);
-		}
-		else if (orig.vertices.size() &gt; 2) {
-			//this is strange too, but probably caused by an incorrect 3rd party unit
-		}
-		//logOutput.Print(&quot;Vertexes %f %f %f&quot;, orig.vertices[0].pos.x, orig.vertices[0].pos.y, orig.vertices[0].pos.z);
-		//logOutput.Print(&quot;Vertexes %f %f %f&quot;, orig.vertices[1].pos.x, orig.vertices[1].pos.y, orig.vertices[1].pos.z);
-		return orig.vertices[0].pos - orig.vertices[1].pos;
-	}
-	else {
-		SS3O &amp;orig = *pieces[piecenum].originals3o;
-		if (orig.vertices.size() &lt; 2) {
-			return float3(1.0f, 1.0f, 1.0f);
-		}
-		else if (orig.vertices.size() &gt; 2) {
-			//this is strange too, but probably caused by an incorrect 3rd party unit
-		}
-		return orig.vertices[0].pos - orig.vertices[1].pos;
-	}
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-//
-//  LocalS3DO
-//
-
-void LocalS3DO::Draw() const
-{
-	glPushMatrix();
-	glTranslatef(offset.x, offset.y, offset.z);
-
-	if (!anim) {
-		glCallList(displist);
-	}
-	else {
-		glTranslatef(-anim-&gt;coords[0] / CORDDIV,
-		              anim-&gt;coords[1] / CORDDIV,
-		              anim-&gt;coords[2] / CORDDIV);
-		if (anim-&gt;rot[1]) { glRotatef( anim-&gt;rot[1] / ANGDIV, 0.0f, 1.0f, 0.0f); }
-		if (anim-&gt;rot[0]) { glRotatef( anim-&gt;rot[0] / ANGDIV, 1.0f, 0.0f, 0.0f); }
-		if (anim-&gt;rot[2]) { glRotatef(-anim-&gt;rot[2] / ANGDIV, 0.0f, 0.0f, 1.0f); }
-		if (anim-&gt;visible) {
-			glCallList(displist);
-		}
-	}
-
-	for (unsigned int i = 0; i &lt; childs.size(); i++) {
-		childs[i]-&gt;Draw();
-	}
-
-	glPopMatrix();
-}
-
-
-void LocalS3DO::DrawLOD(unsigned int lod) const
-{
-	const	unsigned int lodDispList = lodDispLists[lod];
-
-	glPushMatrix();
-	glTranslatef(offset.x, offset.y, offset.z);
-
-	if (!anim) {
-		glCallList(lodDispList);
-	}
-	else {
-		glTranslatef(-anim-&gt;coords[0] / CORDDIV,
-		              anim-&gt;coords[1] / CORDDIV,
-		              anim-&gt;coords[2] / CORDDIV);
-		if (anim-&gt;rot[1]) { glRotatef( anim-&gt;rot[1] / ANGDIV, 0.0f, 1.0f, 0.0f); }
-		if (anim-&gt;rot[0]) { glRotatef( anim-&gt;rot[0] / ANGDIV, 1.0f, 0.0f, 0.0f); }
-		if (anim-&gt;rot[2]) { glRotatef(-anim-&gt;rot[2] / ANGDIV, 0.0f, 0.0f, 1.0f); }
-		if (anim-&gt;visible) {
-			glCallList(lodDispList);
-		}
-	}
-
-	for (unsigned int i = 0; i &lt; childs.size(); i++) {
-		childs[i]-&gt;DrawLOD(lod);
-	}
-
-	glPopMatrix();
-}
-
-
-void LocalS3DO::SetLODCount(unsigned int count)
-{
-	const unsigned int oldCount = lodDispLists.size();
-
-	lodDispLists.resize(count);
-	for (unsigned int i = oldCount; i &lt; count; i++) {
-		lodDispLists[i] = 0;
-	}
-
-	for (unsigned int i = 0; i &lt; childs.size(); i++) {
-		childs[i]-&gt;SetLODCount(count);
-	}
-}
-
-
-void LocalS3DO::GetPiecePosIter(CMatrix44f* mat) const
-{
-	if (parent) {
-		parent-&gt;GetPiecePosIter(mat);
-	}
-
-	mat-&gt;Translate(offset.x, offset.y, -offset.z);
-
-	if (anim) {
-		mat-&gt;Translate(-anim-&gt;coords[0] / CORDDIV,
-		                anim-&gt;coords[1] / CORDDIV,
-		               -anim-&gt;coords[2] / CORDDIV);
-		if (anim-&gt;rot[1]) { mat-&gt;RotateY(anim-&gt;rot[1] * (PI / 32768)); }
-		if (anim-&gt;rot[0]) { mat-&gt;RotateX(anim-&gt;rot[0] * (PI / 32768)); }
-		if (anim-&gt;rot[2]) { mat-&gt;RotateZ(anim-&gt;rot[2] * (PI / 32768)); }
-	}
-}
-
-
-void LocalS3DO::ApplyTransform() const
-{
-	if (parent) {
-		parent-&gt;ApplyTransform();
-	}
-	
-	glTranslatef(offset.x, offset.y, offset.z);
-
-	if (anim) {
-		glTranslatef(anim-&gt;coords[0] / CORDDIV,
-				 anim-&gt;coords[1] / CORDDIV,
-				 anim-&gt;coords[2] / CORDDIV);
-		if (anim-&gt;rot[1]) { glRotatef( anim-&gt;rot[1] / ANGDIV, 0.0f, 1.0f, 0.0f); }
-		if (anim-&gt;rot[0]) { glRotatef( anim-&gt;rot[0] / ANGDIV, 1.0f, 0.0f, 0.0f); }
-		if (anim-&gt;rot[2]) { glRotatef(-anim-&gt;rot[2] / ANGDIV, 0.0f, 0.0f, 1.0f); }
-	}
-}
-
-
-/******************************************************************************/
-/******************************************************************************/

Deleted: trunk/rts/Rendering/UnitModels/3DModelParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/3DModelParser.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -1,196 +0,0 @@
-#ifndef SPRING_3DMODELPARSER_H
-#define SPRING_3DMODELPARSER_H
-
-#include &lt;vector&gt;
-#include &lt;string&gt;
-#include &lt;set&gt;
-#include &quot;Matrix44f.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-
-struct S3DO;
-struct SS3O;
-class C3DOParser;
-class CS3OParser;
-struct S3DOModel;
-struct LocalS3DOModel;
-
-
-class C3DModelParser
-{
-public:
-	C3DModelParser(void);
-	~C3DModelParser(void);
-
-	void Update();
-	S3DOModel* Load3DModel(std::string name, float scale = 1.0f, int side = 1);
-	// S3DOModel* Load3DO(string name,float scale,int side,const float3&amp; offsets);
-	std::set&lt;CUnit *&gt; fixLocalModels;
-	std::vector&lt;LocalS3DOModel *&gt; deleteLocalModels;
-	void DeleteLocalModel(CUnit *unit);
-	void CreateLocalModel(CUnit *unit);
-	void FixLocalModel(CUnit *unit);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
-
-	C3DOParser* unit3doparser;
-	CS3OParser* units3oparser;
-};
-
-extern C3DModelParser* modelParser;
-
-
-struct S3DOModel
-{
-	S3DO* rootobject3do;
-	SS3O* rootobjects3o;
-	int numobjects;
-	float radius;
-	float height;
-	std::string name;
-	int farTextureNum;
-	float maxx,maxy,maxz;
-	float minx,miny,minz;
-	float3 relMidPos;
-	int textureType;		//0=3do, otherwise s3o
-	std::string tex1;
-	std::string tex2;
-	void DrawStatic();
-};
-
-
-struct PieceInfo;
-
-struct LocalS3DO
-{
-	float3 offset;
-	unsigned int displist;
-	std::vector&lt;unsigned int&gt; lodDispLists;
-	std::string name;
-	std::vector&lt;LocalS3DO*&gt; childs;
-	LocalS3DO *parent;
-	S3DO *original3do;
-	SS3O *originals3o;
-	PieceInfo *anim;
-	void Draw() const;
-	void DrawLOD(unsigned int lod) const;
-	void SetLODCount(unsigned int count);
-	void ApplyTransform() const;
-	void GetPiecePosIter(CMatrix44f* mat) const;
-};
-
-
-struct LocalS3DOModel
-{
-	int numpieces;
-	//LocalS3DO *rootobject;
-	LocalS3DO *pieces;
-	int *scritoa;  //scipt index to local array index
-	unsigned int lodCount;
-
-	LocalS3DOModel() : lodCount(0) {};
-	~LocalS3DOModel();
-
-	void Draw() const;
-	void DrawLOD(unsigned int lod) const;
-	void SetLODCount(unsigned int count);
-
-	int ScriptToArray(int piecenum) const;
-
-	bool PieceExists(int scriptnum) const;
-
-	void ApplyPieceTransform(int scriptnum) const;
-	float3 GetPiecePos(int scriptnum) const;
-	CMatrix44f GetPieceMatrix(int scriptnum) const;
-	float3 GetPieceDirection(int scriptnum) const;
-	int GetPieceVertCount(int scriptnum) const;
-	void GetEmitDirPos(int scriptnum, float3 &amp;pos, float3 &amp;dir) const;
-
-	// raw forms, the piecenum must be valid
-	void ApplyRawPieceTransform(int piecenum) const;
-	float3 GetRawPiecePos(int piecenum) const;
-	CMatrix44f GetRawPieceMatrix(int piecenum) const;
-	float3 GetRawPieceDirection(int piecenum) const;
-	int GetRawPieceVertCount(int piecenum) const;
-	void GetRawEmitDirPos(int piecenum, float3 &amp;pos, float3 &amp;dir) const;
-};
-
-
-inline int LocalS3DOModel::ScriptToArray(int scriptnum) const
-{
-	if ((scriptnum &lt; 0) || (scriptnum &gt;= numpieces)) {
-		return -1;
-	}
-	return scritoa[scriptnum];
-}
-
-
-inline bool LocalS3DOModel::PieceExists(int scriptnum) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return false;
-	}
-	return true;
-}
-
-
-inline void LocalS3DOModel::ApplyPieceTransform(int scriptnum) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return;
-	}
-	ApplyRawPieceTransform(p);
-}
-
-
-inline float3 LocalS3DOModel::GetPiecePos(int scriptnum) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return ZeroVector;
-	}
-	return GetRawPiecePos(p);
-}
-
-
-inline CMatrix44f LocalS3DOModel::GetPieceMatrix(int scriptnum) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return CMatrix44f();
-	}
-	return GetRawPieceMatrix(p);
-}
-
-
-inline float3 LocalS3DOModel::GetPieceDirection(int scriptnum) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return float3(1.0f, 1.0f, 1.0f);
-	}
-	return GetRawPieceDirection(p);
-}
-
-
-inline int LocalS3DOModel::GetPieceVertCount(int scriptnum) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return 0;
-	}
-	return GetRawPieceVertCount(p);
-}
-
-
-inline void LocalS3DOModel::GetEmitDirPos(int scriptnum, float3 &amp;pos, float3 &amp;dir) const
-{
-	const int p = ScriptToArray(scriptnum);
-	if (p &lt; 0) {
-		return;
-	}
-	return GetRawEmitDirPos(p, pos, dir);
-}
-
-
-#endif /* SPRING_3DMODELPARSER_H */

Modified: trunk/rts/Rendering/UnitModels/3DOParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/3DOParser.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/3DOParser.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -11,14 +11,12 @@
 #include &lt;stdexcept&gt;
 #include &quot;mmgr.h&quot;
 
-#include &quot;3DOParser.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;FileSystem/VFSHandler.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;FileSystem/SimpleParser.h&quot;
-#include &quot;Rendering/FartextureHandler.h&quot;
 #include &quot;Sim/Units/COB/CobInstance.h&quot;
 #include &quot;Rendering/Textures/TAPalette.h&quot;
 #include &quot;Matrix44f.h&quot;
@@ -27,12 +25,14 @@
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;SDL_types.h&quot;
+#include &quot;3DOParser.h&quot;
 #include &quot;s3oParser.h&quot;
 #include &quot;Util.h&quot;
 #include &quot;Exceptions.h&quot;
 
 using namespace std;
 
+static const float scaleFactor = 1/(65536.0f);
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -107,27 +107,9 @@
 } while (0)
 
 
-void S3DO::DrawStatic()
-{
-	glPushMatrix();
-	glTranslatef(offset.x,offset.y,offset.z);
-	glCallList(displist);
-	for(unsigned int i=0; i&lt;childs.size(); i++)
-		childs[i]-&gt;DrawStatic();
-	glPopMatrix();
-}
 
-
-S3DO::~S3DO()
-{
-	glDeleteLists(displist, 1);
-}
-
-
 C3DOParser::C3DOParser()
 {
-	scaleFactor=400000.0f;
-
 	CFileHandler file(&quot;unittextures/tatex/teamtex.txt&quot;);
 	CSimpleParser parser(file);
 
@@ -137,48 +119,8 @@
 }
 
 
-C3DOParser::~C3DOParser()
+S3DModel* C3DOParser::Load(string name)
 {
-	map&lt;string,S3DOModel*&gt;::iterator ui;
-	for(ui=units.begin();ui!=units.end();++ui){
-		DeleteS3DO(ui-&gt;second-&gt;rootobject3do);
-		delete ui-&gt;second;
-	}
-}
-
-
-void C3DOParser::DeleteS3DO(S3DO *o)
-{
-	for(std::vector&lt;S3DO*&gt;::iterator di=o-&gt;childs.begin();di!=o-&gt;childs.end();di++){
-		DeleteS3DO(*di);
-	}
-	delete o;
-}
-
-
-S3DOModel* C3DOParser::Load3DO(string name,float scale,int team)
-{
-	GML_STDMUTEX_LOCK(model); // Load3DO
-
-	int color=team;
-
-	if(name.find(&quot;.&quot;)==string::npos)
-		name+=&quot;.3do&quot;;
-
-	scaleFactor=1/(65536.0f);
-
-	string sideName(name);
-	StringToLowerInPlace(sideName);
-	sideName+=color+'0';
-
-	map&lt;string,S3DOModel*&gt;::iterator ui;
-	if((ui=units.find(sideName))!=units.end()){
-		return ui-&gt;second;
-	}
-
-//	if(sideName.find(&quot;armstump.3do&quot;)!=std::string.npos){
-//		logOutput.Print(&quot;New type %s %i %s %s&quot;,name.c_str(),team,sideName.c_str(),playerHandler-&gt;Player(teamHandler-&gt;Team(team)-&gt;leader)-&gt;name.c_str());
-//	}
 	PUSH_CODE_MODE;
 	ENTER_SYNCED;
 //	ifstream ifs(name, ios::in|ios::binary);
@@ -196,10 +138,11 @@
 		throw content_error(&quot;Failed to read file &quot;+name);
 	}
 
-	S3DOModel *model = SAFE_NEW S3DOModel;
-	S3DO* object=SAFE_NEW S3DO;
-	model-&gt;rootobject3do=object;
-	model-&gt;rootobjects3o=0;
+	S3DModel *model = SAFE_NEW S3DModel;
+	S3DOPiece* object=SAFE_NEW S3DOPiece;
+	object-&gt;type=MODELTYPE_3DO;
+	model-&gt;type=MODELTYPE_3DO;
+	model-&gt;rootobject=object;
 	model-&gt;textureType=0;
 	object-&gt;isEmpty=true;
 	model-&gt;name=name;
@@ -215,14 +158,14 @@
 	std::vector&lt;float3&gt; vertexes;
 
 	GetVertexes(&amp;root,object);
-	GetPrimitives(object,root.OffsetToPrimitiveArray,root.NumberOfPrimitives,&amp;vertexes,root.SelectionPrimitive,color);
+	GetPrimitives(object,root.OffsetToPrimitiveArray,root.NumberOfPrimitives,&amp;vertexes,root.SelectionPrimitive);
 	CalcNormals(object);
 	if(root.OffsetToChildObject&gt;0)
-		if(!ReadChild(root.OffsetToChildObject,object,color,&amp;model-&gt;numobjects))
+		if(!ReadChild(root.OffsetToChildObject,object,&amp;model-&gt;numobjects))
 			object-&gt;isEmpty=false;
 
-	object-&gt;offset.x=root.XFromParent*scaleFactor;
-	object-&gt;offset.y=root.YFromParent*scaleFactor;
+	object-&gt;offset.x= root.XFromParent*scaleFactor;
+	object-&gt;offset.y= root.YFromParent*scaleFactor;
 	object-&gt;offset.z=-root.ZFromParent*scaleFactor;
 
 	FindCenter(object);
@@ -232,51 +175,29 @@
 	if(object-&gt;relMidPos.y&lt;1)
 		object-&gt;relMidPos.y=1;
 
-	units[sideName]=model;
+	model-&gt;radius = object-&gt;radius;
+	model-&gt;height = FindHeight(object,ZeroVector);
 
-	CreateLists(object);
+	model-&gt;maxx=object-&gt;maxx;
+	model-&gt;maxy=object-&gt;maxy;
+	model-&gt;maxz=object-&gt;maxz;
 
-	// this is a hack to make aircrafts less likely to collide and get hit by nontracking weapons
-	// note: does not apply anymore, unit &lt;--&gt; projectile coldet no longer depends on model-&gt;radius
-	model-&gt;radius = model-&gt;rootobject3do-&gt;radius * scale;
-	model-&gt;height = FindHeight(model-&gt;rootobject3do,ZeroVector);
-//	logOutput.Print(&quot;%s has height %f&quot;,name,model-&gt;height);
+	model-&gt;minx=object-&gt;minx;
+	model-&gt;miny=object-&gt;miny;
+	model-&gt;minz=object-&gt;minz;
 
-	model-&gt;maxx=model-&gt;rootobject3do-&gt;maxx;
-	model-&gt;maxy=model-&gt;rootobject3do-&gt;maxy;
-	model-&gt;maxz=model-&gt;rootobject3do-&gt;maxz;
+	model-&gt;relMidPos=object-&gt;relMidPos;
 
-	model-&gt;minx=model-&gt;rootobject3do-&gt;minx;
-	model-&gt;miny=model-&gt;rootobject3do-&gt;miny;
-	model-&gt;minz=model-&gt;rootobject3do-&gt;minz;
-
-	model-&gt;relMidPos=model-&gt;rootobject3do-&gt;relMidPos;
-
-	fartextureHandler-&gt;CreateFarTexture(model);
-
 	delete[] fileBuf;
 	POP_CODE_MODE;
 	return model;
 }
 
 
-/*
-S3DOModel* C3DOParser::Load3DO(string name,float scale,int team,const float3&amp; offsets)
+void C3DOParser::GetVertexes(_3DObject* o,S3DOPiece* object)
 {
-	S3DOModel *model = C3DOParser::Load3DO(name, scale, team);
-	model-&gt;rootobject3do-&gt;relMidPos.x=offsets.x;
-	model-&gt;rootobject3do-&gt;relMidPos.y=offsets.y;
-	model-&gt;rootobject3do-&gt;relMidPos.z=offsets.z;
-	model-&gt;relMidPos = model-&gt;rootobject3do-&gt;relMidPos;
-
-	return model;
-}
-*/
-
-
-void C3DOParser::GetVertexes(_3DObject* o,S3DO* object)
-{
 	curOffset=o-&gt;OffsetToVertexArray;
+	object-&gt;vertices.reserve(o-&gt;NumberOfVertices);
 	for(int a=0;a&lt;o-&gt;NumberOfVertices;a++){
 		_Vertex v;
 		READ_VERTEX(v);
@@ -292,7 +213,7 @@
 }
 
 
-void C3DOParser::GetPrimitives(S3DO* obj,int pos,int num,vertex_vector* vv,int excludePrim,int side)
+void C3DOParser::GetPrimitives(S3DOPiece* obj,int pos,int num,vertex_vector* vv,int excludePrim)
 {
 	map&lt;int,int&gt; prevHashes;
 
@@ -310,6 +231,9 @@
 		if(sp.numVertex&lt;3)
 			continue;
 
+		sp.vertices.reserve(sp.numVertex);
+		sp.normals.reserve(sp.numVertex);
+
 		curOffset=p.OffsetToVertexIndexArray;
 		Uint16 w;
 
@@ -330,54 +254,56 @@
 		if(p.OffsetToTextureName!=0)
 		{
 			string texture = GetText(p.OffsetToTextureName);
-
-			char chside[3];
-			chside[0] = '0' + (side / 10);
-			chside[1] = '0' + (side % 10);
-			chside[2] = 0;
 			StringToLowerInPlace(texture);
+
 			if(teamtex.find(texture) != teamtex.end())
-				sp.texture=texturehandler-&gt;GetTATexture(texture + chside, side, false);
+				sp.texture=texturehandler3DO-&gt;Get3DOTexture(texture);
 			else
-				sp.texture=texturehandler-&gt;GetTATexture(texture + &quot;00&quot;,side, false);
+				sp.texture=texturehandler3DO-&gt;Get3DOTexture(texture + &quot;00&quot;);
 
 			if(sp.texture==0)
 				logOutput &lt;&lt; &quot;Parser couldnt get texture &quot; &lt;&lt; GetText(p.OffsetToTextureName).c_str() &lt;&lt; &quot;\n&quot;;
 		} else {
 			char t[50];
 			sprintf(t,&quot;ta_color%i&quot;,p.PaletteEntry);
-			sp.texture=texturehandler-&gt;GetTATexture(t,0, false);
+			sp.texture=texturehandler3DO-&gt;Get3DOTexture(t);
 		}
 		float3 n=-(obj-&gt;vertices[sp.vertices[1]].pos-obj-&gt;vertices[sp.vertices[0]].pos).cross(obj-&gt;vertices[sp.vertices[2]].pos-obj-&gt;vertices[sp.vertices[0]].pos);
 		n.Normalize();
 		sp.normal=n;
-		for(int a=0;a&lt;sp.numVertex;++a)
-			sp.normals.push_back(n);
+		sp.normals.insert(sp.normals.begin(), sp.numVertex, n);
 
-		if(n.dot(float3(0,-1,0))&gt;0.99f){			//sometimes there are more than one selection primitive (??)
+		//sometimes there are more than one selection primitive (??)
+		if(n.dot(float3(0,-1,0))&gt;0.99f){
 			int ignore=true;
-			for(int a=0;a&lt;sp.numVertex;++a)
-				if(obj-&gt;vertices[sp.vertices[a]].pos.y&gt;0)
-					ignore=false;
-			if(sp.numVertex==4){
+
+			if(sp.numVertex!=4) {
+				ignore=false;
+			} else {
 				float3 s1=obj-&gt;vertices[sp.vertices[0]].pos-obj-&gt;vertices[sp.vertices[1]].pos;
 				float3 s2=obj-&gt;vertices[sp.vertices[1]].pos-obj-&gt;vertices[sp.vertices[2]].pos;
-				if(s1.Length()&lt;30 || s2.Length()&lt;30)
+				if(s1.SqLength()&lt;900 || s2.SqLength()&lt;900)
 					ignore=false;
-			}else
-				ignore=false;
+
+				if (ignore) {
+					for(int a=0;a&lt;sp.numVertex;++a) {
+						if(obj-&gt;vertices[sp.vertices[a]].pos.y&gt;0) {
+							ignore=false;
+							break;
+						}
+					}
+				}
+			}
+
 			if(ignore)
 				continue;
 		}
 
 		map&lt;int,int&gt;::iterator phi;
 		if((phi=prevHashes.find(vertHash))!=prevHashes.end()){
-			if(n.y&gt;0){
+			if(n.y&gt;0)
 				obj-&gt;prims[phi-&gt;second]=sp;
-				continue;
-			} else {
-				continue;
-			}
+			continue;
 		} else {
 			prevHashes[vertHash]=obj-&gt;prims.size();
 			obj-&gt;prims.push_back(sp);
@@ -394,7 +320,7 @@
 }
 
 
-void C3DOParser::CalcNormals(S3DO *o)
+void C3DOParser::CalcNormals(S3DOPiece *o)
 {
 	for(std::vector&lt;S3DOPrimitive&gt;::iterator ps=o-&gt;prims.begin();ps!=o-&gt;prims.end();ps++){
 		for(int a=0;a&lt;ps-&gt;numVertex;++a){
@@ -428,11 +354,11 @@
 }
 
 
-bool C3DOParser::ReadChild(int pos, S3DO *root,int side, int *numobj)
+bool C3DOParser::ReadChild(int pos, S3DOPiece *root,int *numobj)
 {
 	(*numobj)++;
 
-	S3DO* object=SAFE_NEW S3DO;
+	S3DOPiece* object=SAFE_NEW S3DOPiece;
 	_3DObject me;
 
 	curOffset=pos;
@@ -440,61 +366,70 @@
 
 	string s = StringToLower(GetText(me.OffsetToObjectName));
 	object-&gt;name = s;
-	object-&gt;displist=0;
+	object-&gt;displist = 0;
+	object-&gt;type = MODELTYPE_3DO;
 
-	object-&gt;offset.x=me.XFromParent*scaleFactor;
-	object-&gt;offset.y=me.YFromParent*scaleFactor;
+	object-&gt;offset.x= me.XFromParent*scaleFactor;
+	object-&gt;offset.y= me.YFromParent*scaleFactor;
 	object-&gt;offset.z=-me.ZFromParent*scaleFactor;
 	std::vector&lt;float3&gt; vertexes;
 	object-&gt;isEmpty=true;
 
 	GetVertexes(&amp;me,object);
-	GetPrimitives(object,me.OffsetToPrimitiveArray,me.NumberOfPrimitives,&amp;vertexes,-1/*me.SelectionPrimitive*/,side);
+	GetPrimitives(object,me.OffsetToPrimitiveArray,me.NumberOfPrimitives,&amp;vertexes,-1/*me.SelectionPrimitive*/);
 	CalcNormals(object);
 
 
 	if(me.OffsetToChildObject&gt;0){
-		if(!ReadChild(me.OffsetToChildObject,object,side,numobj)){
+		if(!ReadChild(me.OffsetToChildObject,object,numobj)){
 			object-&gt;isEmpty=false;
 		}
 	}
 	bool ret=object-&gt;isEmpty;
 
+	object-&gt;vertexCount = object-&gt;vertices.size();
+
 	root-&gt;childs.push_back(object);
 
 	if(me.OffsetToSiblingObject&gt;0)
-		if(!ReadChild(me.OffsetToSiblingObject,root,side,numobj))
+		if(!ReadChild(me.OffsetToSiblingObject,root,numobj))
 			ret=false;
 
 	return ret;
 }
 
 
-void C3DOParser::DrawSub(S3DO* o)
+void C3DOParser::Draw(S3DModelPiece *o)
 {
+	if (o-&gt;isEmpty)
+		return;
+
+	S3DOPiece* o3 = static_cast&lt;S3DOPiece*&gt;(o);
+
 	CVertexArray* va=GetVertexArray();
 	CVertexArray* va2=GetVertexArray();	//dont try to use more than 2 via getvertexarray, it wraps around
 	va-&gt;Initialize();
 	va2-&gt;Initialize();
 	std::vector&lt;S3DOPrimitive&gt;::iterator ps;
 
-	for(ps=o-&gt;prims.begin();ps!=o-&gt;prims.end();ps++){
-		CTextureHandler::UnitTexture* tex=ps-&gt;texture;
+	//glFrontFace(GL_CW);
+	for(ps=o3-&gt;prims.begin();ps!=o3-&gt;prims.end();ps++){
+		C3DOTextureHandler::UnitTexture* tex=ps-&gt;texture;
 		if(ps-&gt;numVertex==4){
-			va-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[0]].pos,tex-&gt;xstart,tex-&gt;ystart,ps-&gt;normals[0]);
-			va-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[1]].pos,tex-&gt;xend,tex-&gt;ystart,ps-&gt;normals[1]);
-			va-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[2]].pos,tex-&gt;xend,tex-&gt;yend,ps-&gt;normals[2]);
-			va-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[3]].pos,tex-&gt;xstart,tex-&gt;yend,ps-&gt;normals[3]);
+			va-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[0]].pos,tex-&gt;xstart,tex-&gt;ystart,ps-&gt;normals[0]);
+			va-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[1]].pos,tex-&gt;xend,tex-&gt;ystart,ps-&gt;normals[1]);
+			va-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[2]].pos,tex-&gt;xend,tex-&gt;yend,ps-&gt;normals[2]);
+			va-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[3]].pos,tex-&gt;xstart,tex-&gt;yend,ps-&gt;normals[3]);
 		} else if (ps-&gt;numVertex==3) {
-			va2-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[0]].pos,tex-&gt;xstart,tex-&gt;ystart,ps-&gt;normals[0]);
-			va2-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[1]].pos,tex-&gt;xend,tex-&gt;ystart,ps-&gt;normals[1]);
-			va2-&gt;AddVertexTN(o-&gt;vertices[ps-&gt;vertices[2]].pos,tex-&gt;xend,tex-&gt;yend,ps-&gt;normals[2]);
+			va2-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[0]].pos,tex-&gt;xstart,tex-&gt;ystart,ps-&gt;normals[0]);
+			va2-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[1]].pos,tex-&gt;xend,tex-&gt;ystart,ps-&gt;normals[1]);
+			va2-&gt;AddVertexTN(o3-&gt;vertices[ps-&gt;vertices[2]].pos,tex-&gt;xend,tex-&gt;yend,ps-&gt;normals[2]);
 		} else {
 			glNormal3f(ps-&gt;normal.x,ps-&gt;normal.y,ps-&gt;normal.z);
 			glBegin(GL_TRIANGLE_FAN);
 			glTexCoord2f(tex-&gt;xstart,tex-&gt;ystart);
 			for(std::vector&lt;int&gt;::iterator fi=ps-&gt;vertices.begin();fi!=ps-&gt;vertices.end();fi++){
-				float3 t=o-&gt;vertices[(*fi)].pos;
+				float3 t=o3-&gt;vertices[(*fi)].pos;
 				glNormalf3(ps-&gt;normal);
 				glVertex3f(t.x,t.y,t.z);
 			}
@@ -504,38 +439,10 @@
 	va-&gt;DrawArrayTN(GL_QUADS);
 	if(va2-&gt;drawIndex()!=0)
 		va2-&gt;DrawArrayTN(GL_TRIANGLES);
+	//glFrontFace(GL_CCW);
 }
 
 
-void C3DOParser::Update() {
-//	GML_STDMUTEX_LOCK(model); // Update
-	for(std::vector&lt;S3DO *&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
-		CreateListsNow(*i);
-	createLists.clear();
-}
-
-void C3DOParser::CreateLists(S3DO *o) {
-//	GML_STDMUTEX_LOCK(model); // CreateLists
-	createLists.push_back(o);
-}
-
-
-void C3DOParser::CreateListsNow(S3DO *o)
-{
-	o-&gt;displist = glGenLists(1);
-	PUSH_CODE_MODE;
-	ENTER_MIXED;
-	glNewList(o-&gt;displist,GL_COMPILE);
-	DrawSub(o);
-	glEndList();
-	POP_CODE_MODE;
-
-	for(std::vector&lt;S3DO*&gt;::iterator bs=o-&gt;childs.begin();bs!=o-&gt;childs.end();bs++){
-		CreateListsNow(*bs);
-	}
-}
-
-
 void C3DOParser::SimStreamRead(void *buf, int length)
 {
 	memcpy(buf,&amp;fileBuf[curOffset],length);
@@ -543,11 +450,11 @@
 }
 
 
-void C3DOParser::FindCenter(S3DO *object)
+void C3DOParser::FindCenter(S3DOPiece* object)
 {
-	std::vector&lt;S3DO*&gt;::iterator si;
+	std::vector&lt;S3DModelPiece*&gt;::iterator si;
 	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		FindCenter(*si);
+		FindCenter((S3DOPiece*)*si);
 	}
 
 	float maxSize=0;
@@ -587,20 +494,21 @@
 		maxSize=max(maxSize,object-&gt;relMidPos.distance(vi-&gt;pos));
 	}
 	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		maxSize=max(maxSize,object-&gt;relMidPos.distance((*si)-&gt;offset+(*si)-&gt;relMidPos)+(*si)-&gt;radius);
+		S3DOPiece* p3do = (S3DOPiece*)(*si);
+		maxSize=max(maxSize,object-&gt;relMidPos.distance(p3do-&gt;offset+p3do-&gt;relMidPos)+p3do-&gt;radius);
 	}
 	object-&gt;radius=maxSize;
 }
 
 
-float C3DOParser::FindRadius(S3DO *object,float3 offset)
+float C3DOParser::FindRadius(S3DOPiece* object,float3 offset)
 {
 	float maxSize=0;
 	offset+=object-&gt;offset;
 
-	std::vector&lt;S3DO*&gt;::iterator si;
+	std::vector&lt;S3DModelPiece*&gt;::iterator si;
 	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		float maxChild=FindRadius(*si,offset);
+		float maxChild = FindRadius((S3DOPiece*)*si,offset);
 		if(maxChild&gt;maxSize)
 			maxSize=maxChild;
 	}
@@ -615,14 +523,14 @@
 }
 
 
-float C3DOParser::FindHeight(S3DO* object,float3 offset)
+float C3DOParser::FindHeight(S3DOPiece* object,float3 offset)
 {
 	float height=0;
 	offset+=object-&gt;offset;
 
-	std::vector&lt;S3DO*&gt;::iterator si;
+	std::vector&lt;S3DModelPiece*&gt;::iterator si;
 	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		float maxChild=FindHeight(*si,offset);
+		float maxChild=FindHeight((S3DOPiece*)*si,offset);
 		if(maxChild&gt;height)
 			height=maxChild;
 	}
@@ -633,99 +541,3 @@
 	}
 	return height;
 }
-
-
-void C3DOParser::CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum)
-{
-	PUSH_CODE_MODE;
-	ENTER_SYNCED;
-	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
-	lmodel-&gt;pieces[*piecenum].offset = model-&gt;offset;
-	lmodel-&gt;pieces[*piecenum].name = model-&gt;name;
-	lmodel-&gt;pieces[*piecenum].original3do = model;
-	lmodel-&gt;pieces[*piecenum].originals3o = 0;
-
-	lmodel-&gt;pieces[*piecenum].anim = NULL;
-	unsigned int cur;
-
-	//Map this piecename to an index in the script's pieceinfo
-	for (cur = 0; cur &lt; pieces-&gt;size(); cur++) {
-		if (lmodel-&gt;pieces[*piecenum].name.compare((*pieces)[cur].name) == 0) {
-			break;
-		}
-	}
-
-	//Not found? Try again with partial matching
-	if (cur == pieces-&gt;size()) {
-		string &amp;s1 = lmodel-&gt;pieces[*piecenum].name;
-		for (cur = 0; cur &lt; pieces-&gt;size(); ++cur) {
-			string &amp;s2 = (*pieces)[cur].name;
-			int maxcompare = min(s1.size(), s2.size());
-			int j;
-			for (j = 0; j &lt; maxcompare; ++j) {
-				if (s1[j] != s2[j]) {
-					break;
-				}
-			}
-			//Match now?
-			if (j == maxcompare) {
-				break;
-			}
-		}
-	}
-
-	//Did we find it now?
-	if (cur &lt; pieces-&gt;size()) {
-		lmodel-&gt;pieces[*piecenum].anim = &amp;((*pieces)[cur]);
-		lmodel-&gt;scritoa[cur] = *piecenum;
-	}
-	else {
-//		logOutput.Print(&quot;CreateLocalModel: Could not map %s to script&quot;, lmodel-&gt;pieces[*piecenum].name.c_str());
-	}
-
-	int thispiece = *piecenum;
-	for(unsigned int i=0; i&lt;model-&gt;childs.size(); i++)
-	{
-
-		(*piecenum)++;
-		lmodel-&gt;pieces[thispiece].childs.push_back(&amp;lmodel-&gt;pieces[*piecenum]);
-		lmodel-&gt;pieces[*piecenum].parent = &amp;lmodel-&gt;pieces[thispiece];
-		CreateLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
-	}
-	POP_CODE_MODE;
-}
-
-
-void C3DOParser::FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces) {
-	int piecenum=0;
-	FixLocalModel(model-&gt;rootobject3do, lmodel, pieces, &amp;piecenum);
-}
-
-void C3DOParser::FixLocalModel(S3DO *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces, int *piecenum) {
-	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
-
-	for(unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
-		(*piecenum)++;
-		FixLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
-	}
-}
-
-
-LocalS3DOModel *C3DOParser::CreateLocalModel(S3DOModel *model, vector&lt;struct PieceInfo&gt; *pieces)
-{
-	LocalS3DOModel *lmodel = SAFE_NEW LocalS3DOModel;
-	lmodel-&gt;numpieces = model-&gt;numobjects;
-
-	int piecenum=0;
-	lmodel-&gt;pieces = SAFE_NEW LocalS3DO[model-&gt;numobjects];
-	lmodel-&gt;pieces-&gt;parent = NULL;
-	lmodel-&gt;scritoa = SAFE_NEW int[pieces-&gt;size()];
-	for(int a=0;a&lt;pieces-&gt;size();++a)
-		lmodel-&gt;scritoa[a]=-1;
-
-	CreateLocalModel(model-&gt;rootobject3do, lmodel, pieces, &amp;piecenum);
-
-	return lmodel;
-}
-
-

Modified: trunk/rts/Rendering/UnitModels/3DOParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/3DOParser.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/3DOParser.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -7,11 +7,12 @@
 #include &lt;vector&gt;
 #include &lt;string&gt;
 #include &quot;float3.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
 #include &lt;map&gt;
 #include &lt;set&gt;
-#include &quot;3DModelParser.h&quot;
+#include &quot;IModelParser.h&quot;
 
+
 class CMatrix44f;
 class CFileHandler;
 
@@ -26,27 +27,19 @@
 	std::vector&lt;float3&gt; normals;		//normals per vertex
 	float3 normal;
 	int numVertex;
-	CTextureHandler::UnitTexture* texture;
+	C3DOTextureHandler::UnitTexture* texture;
 };
 
-struct S3DO {
-	std::string name;
-	std::vector&lt;S3DO*&gt; childs;
-	std::vector&lt;S3DOPrimitive&gt; prims;
+struct S3DOPiece : public S3DModelPiece {
+	const float3&amp; GetVertexPos(const int&amp; idx) const { return vertices[idx].pos; };
+
 	std::vector&lt;S3DOVertex&gt; vertices;
-	float3 offset;
-	unsigned int displist;
-	bool isEmpty;
+	std::vector&lt;S3DOPrimitive&gt; prims;
 	float radius;
 	float3 relMidPos;
-	float maxx,maxy,maxz;
-	float minx,miny,minz;
-
-	void DrawStatic();
-	~S3DO();
 };
 
-class C3DOParser
+class C3DOParser : public IModelParser
 {
 	typedef struct _3DObject
 	{
@@ -88,34 +81,21 @@
 
 public:
 	C3DOParser();
-	virtual ~C3DOParser();
-	S3DOModel* Load3DO(std::string name, float scale = 1, int side = 1);
-	// S3DOModel* Load3DO(std::string name,float scale,int side,const float3&amp; offsets);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
-	void Update();
-	void FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, vector&lt;struct PieceInfo&gt; *pieces);
 
+	S3DModel* Load(std::string name);
+	void Draw(S3DModelPiece *o);
+
 private:
-	void FindCenter(S3DO* object);
-	float FindRadius(S3DO* object,float3 offset);
-	float FindHeight(S3DO* object,float3 offset);
-	void CalcNormals(S3DO* o);
+	void FindCenter(S3DOPiece* object);
+	float FindRadius(S3DOPiece* object,float3 offset);
+	float FindHeight(S3DOPiece* object,float3 offset);
+	void CalcNormals(S3DOPiece* o);
 
-	void DeleteS3DO(S3DO* o);
-	std::vector&lt;S3DO*&gt; createLists;
-	void CreateLists(S3DO* o);
-	void CreateListsNow(S3DO* o);
-	float scaleFactor;
-
-	void GetPrimitives(S3DO* obj,int pos,int num,vertex_vector* vv,int excludePrim,int side);
-	void GetVertexes(_3DObject* o,S3DO* object);
+	void GetPrimitives(S3DOPiece* obj,int pos,int num,vertex_vector* vv,int excludePrim);
+	void GetVertexes(_3DObject* o,S3DOPiece* object);
 	std::string GetText(int pos);
-	bool ReadChild(int pos,S3DO* root,int side, int *numobj);
-	void DrawSub(S3DO* o);
-	void CreateLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
-	void FixLocalModel(S3DO *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
+	bool ReadChild(int pos,S3DOPiece* root, int *numobj);
 
-	std::map&lt;std::string, S3DOModel*&gt; units;
 	std::set&lt;std::string&gt; teamtex;
 
 	int curOffset;

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -4,7 +4,6 @@
 #include &quot;UnitDrawer.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;3DModelParser.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/GameSetup.h&quot;
@@ -27,7 +26,8 @@
 #include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
+#include &quot;Rendering/Textures/S3OTextureHandler.h&quot;
 
 #include &quot;ExternalAI/Group.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
@@ -72,9 +72,12 @@
 :	showHealthBars(true),
 	updateFace(0)
 {
-	if (texturehandler == 0) {
-		texturehandler = SAFE_NEW CTextureHandler;
+	if (texturehandler3DO == 0) {
+		texturehandler3DO = SAFE_NEW C3DOTextureHandler;
 	}
+	if (texturehandlerS3O == 0) {
+		texturehandlerS3O = SAFE_NEW CS3OTextureHandler;
+	}
 
 	SetUnitDrawDist((float)configHandler.Get(&quot;UnitLodDist&quot;,  200));
 	SetUnitIconDist((float)configHandler.Get(&quot;UnitIconDist&quot;, 200));
@@ -93,7 +96,7 @@
 		white.mem[a] = 255;
 	}
 
-	whiteTex=white.CreateTexture(false);
+	whiteTex = white.CreateTexture(false);
 
 	unitAmbientColor = mapInfo-&gt;light.unitAmbientColor;
 	unitSunColor = mapInfo-&gt;light.unitSunColor;
@@ -108,18 +111,14 @@
 	}
 
 	if (advShading) {
-		unitVP = LoadVertexProgram(&quot;unit.vp&quot;);
-		unitFP = LoadFragmentProgram(&quot;unit.fp&quot;);
-		unitS3oVP = LoadVertexProgram(&quot;units3o.vp&quot;);
-		unitS3oFP = LoadFragmentProgram(&quot;units3o.fp&quot;);
+		unitVP = LoadVertexProgram(&quot;units3o.vp&quot;);
+		unitFP = LoadFragmentProgram(&quot;units3o.fp&quot;);
 
 		if (shadowHandler-&gt;canUseShadows) {
-			unitShadowFP    = LoadFragmentProgram(&quot;unit_shadow.fp&quot;);
-			unitShadowS3oFP = LoadFragmentProgram(&quot;units3o_shadow.fp&quot;);
+			unitShadowFP = LoadFragmentProgram(&quot;units3o_shadow.fp&quot;);
 			unitShadowGenVP = LoadVertexProgram(&quot;unit_genshadow.vp&quot;);
 		} else {
 			unitShadowFP    = 0;
-			unitShadowS3oFP = 0;
 			unitShadowGenVP = 0;
 		}
 
@@ -151,6 +150,7 @@
 		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB,specTexSize,float3(-1, 1, 1),float3( 2, 0, 0),float3(0,-2, 0),mapInfo-&gt;light.sunDir,100,specularSunColor);
 		CreateSpecularFace(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB,specTexSize,float3( 1, 1,-1),float3(-2, 0, 0),float3(0,-2, 0),mapInfo-&gt;light.sunDir,100,specularSunColor);
 	}
+
 #ifdef USE_GML
 	multiThreadDrawUnit=configHandler.Get(&quot;MultiThreadDrawUnit&quot;, 1);
 	multiThreadDrawUnitShadow=configHandler.Get(&quot;MultiThreadDrawUnitShadow&quot;, 1);
@@ -165,11 +165,7 @@
 	if (advShading) {
 		glSafeDeleteProgram(unitVP);
 		glSafeDeleteProgram(unitFP);
-
 		glSafeDeleteProgram(unitShadowFP);
-		glSafeDeleteProgram(unitS3oVP);
-		glSafeDeleteProgram(unitS3oFP);
-		glSafeDeleteProgram(unitShadowS3oFP);
 		glSafeDeleteProgram(unitShadowGenVP);
 
 		glDeleteTextures(1, &amp;boxtex);
@@ -193,6 +189,7 @@
 		delete *gbi;
 		gbi = ghostBuildingsS3O.erase(gbi);
 	}
+
 #ifdef USE_GML
 	configHandler.Set(&quot;MultiThreadDrawUnit&quot;, multiThreadDrawUnit);
 	configHandler.Set(&quot;MultiThreadDrawUnitShadow&quot;, multiThreadDrawUnitShadow);
@@ -246,7 +243,7 @@
 		if ((lodMat != NULL) &amp;&amp; lodMat-&gt;IsActive()) {
 			lodMat-&gt;AddUnit(unit);
 		} else {
-			if (unit-&gt;model-&gt;textureType) {
+			if (unit-&gt;model-&gt;type==MODELTYPE_S3O) {
 				drawCloakedS3O.push_back(unit);
 			} else {
 				drawCloaked.push_back(unit);
@@ -264,7 +261,7 @@
 		if ((lodMat != NULL) &amp;&amp; lodMat-&gt;IsActive()) {
 			lodMat-&gt;AddUnit(unit);
 		} else {
-			if (unit-&gt;model-&gt;textureType) {
+			if (unit-&gt;model-&gt;type==MODELTYPE_S3O) {
 				QueS3ODraw(unit, unit-&gt;model-&gt;textureType);
 			} else {
 				DrawUnitNow(unit);
@@ -281,7 +278,7 @@
 		return;
 	}
 
-	if (unit-&gt;model-&gt;textureType) {
+	if (unit-&gt;model-&gt;type==MODELTYPE_S3O) {
 		if (unit-&gt;isCloaked) {
 			drawCloakedS3O.push_back(unit);
 		} else {
@@ -307,17 +304,17 @@
 	if (unit-&gt;noDraw) {
 		return;
 	}
-	if (camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 30)) {
+	if (camera-&gt;InView(unit-&gt;drawMidPos, unit-&gt;radius + 30)) {
 		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
 		if ((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
 			if (drawReflection) {
 				float3 zeroPos;
-				if (unit-&gt;midPos.y &lt; 0.0f) {
-					zeroPos = unit-&gt;midPos;
+				if (unit-&gt;drawMidPos.y &lt; 0.0f) {
+					zeroPos = unit-&gt;drawMidPos;
 				} else {
-					const float dif = unit-&gt;midPos.y - camera-&gt;pos.y;
-					zeroPos = camera-&gt;pos  * (unit-&gt;midPos.y / dif) +
-						unit-&gt;midPos * (-camera-&gt;pos.y / dif);
+					const float dif = unit-&gt;drawMidPos.y - camera-&gt;pos.y;
+					zeroPos = camera-&gt;pos  * (unit-&gt;drawMidPos.y / dif) +
+						unit-&gt;drawMidPos * (-camera-&gt;pos.y / dif);
 				}
 				if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; unit-&gt;radius) {
 					return;
@@ -344,6 +341,7 @@
 				if (sqDist &gt; farLength) {
 					drawFar.push_back(unit);
 				} else {
+					SetTeamColour(unit-&gt;team);
 					DrawUnit(unit);
 				}
 
@@ -363,7 +361,7 @@
 				float realIconLength = iconLength * (iconDistMult * iconDistMult);
 
 				if (sqDist &lt; realIconLength) {
-					if (unit-&gt;model-&gt;textureType) {
+					if (unit-&gt;model-&gt;type==MODELTYPE_S3O) {
 						drawCloakedS3O.push_back(unit);
 					} else {
 						drawCloaked.push_back(unit);
@@ -408,6 +406,7 @@
 	}
 
 	SetupForUnitDrawing();
+	SetupFor3DO();
 
 #ifdef DIRECT_CONTROL_ALLOWED
 	CUnit* excludeUnit = drawReflection ? NULL : gu-&gt;directControl;
@@ -444,6 +443,8 @@
 #endif
 
 	{
+		//FIXME: s3o's + teamcolor
+
 		GML_STDMUTEX_LOCK(temp); // Draw
 
 		std::multimap&lt;int, TempDrawUnit&gt;::iterator ti;
@@ -452,14 +453,16 @@
 				glPushMatrix();
 				glTranslatef3(ti-&gt;second.pos);
 				glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
-				ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team)-&gt;DrawStatic();
+				LoadModel(ti-&gt;second.unitdef)-&gt;DrawStatic();
 				glPopMatrix();
 			}
 		}
 	}
 
-	CleanUpUnitDrawing();
+	CleanUp3DO();
 	DrawQuedS3O();
+	CleanUpUnitDrawing();
+
 	DrawOpaqueShaderUnits();
 
 	va = GetVertexArray();
@@ -540,7 +543,7 @@
 
 			lodMat-&gt;uniforms.Execute(unit);
 			// we are inside a static function, so must invoke on unitDrawer instance
-			unitDrawer-&gt;SetS3OTeamColour(unit-&gt;team);
+			unitDrawer-&gt;SetTeamColour(unit-&gt;team);
 			unitDrawer-&gt;DrawUnitWithLists(unit, lodMat-&gt;preDisplayList, lodMat-&gt;postDisplayList);
 		}
 	}
@@ -558,6 +561,8 @@
 
 static void SetupShadowDrawing()
 {
+	//FIXME setup face culling for s3o?
+
 	glColor3f(1.0f, 1.0f, 1.0f);
 	glDisable(GL_TEXTURE_2D);
 	glBindProgramARB(GL_VERTEX_PROGRAM_ARB, unitDrawer-&gt;unitShadowGenVP);
@@ -584,15 +589,14 @@
 
 /******************************************************************************/
 
-static void SetupOpaque3DO() { unitDrawer-&gt;SetupForUnitDrawing(); }
-static void ResetOpaque3DO() { unitDrawer-&gt;CleanUpUnitDrawing();  }
-static void SetupOpaqueS3O() { unitDrawer-&gt;SetupForS3ODrawing();  }
-static void ResetOpaqueS3O() { unitDrawer-&gt;CleanUpS3ODrawing();   }
+static void SetupOpaque3DO() { unitDrawer-&gt;SetupForUnitDrawing();  unitDrawer-&gt;SetupFor3DO(); }
+static void ResetOpaque3DO() { unitDrawer-&gt;CleanUp3DO();   unitDrawer-&gt;CleanUpUnitDrawing();  }
+static void SetupOpaqueS3O() { unitDrawer-&gt;SetupForUnitDrawing();  }
+static void ResetOpaqueS3O() { unitDrawer-&gt;CleanUpUnitDrawing();   }
 
-static void SetupAlpha3DO()  { unitDrawer-&gt;SetupForGhostDrawing();    }
-static void ResetAlpha3DO()  { unitDrawer-&gt;CleanUpGhostDrawing();     }
-static void SetupAlphaS3O()  { unitDrawer-&gt;SetupForGhostDrawing();
-                               unitDrawer-&gt;SetupForGhostDrawingS3O(); }
+static void SetupAlpha3DO()  { unitDrawer-&gt;SetupForGhostDrawing(); unitDrawer-&gt;SetupFor3DO(); }
+static void ResetAlpha3DO()  { unitDrawer-&gt;CleanUp3DO();   unitDrawer-&gt;CleanUpGhostDrawing(); }
+static void SetupAlphaS3O()  { unitDrawer-&gt;SetupForGhostDrawing();    }
 static void ResetAlphaS3O()  { unitDrawer-&gt;CleanUpGhostDrawing();     }
 
 static void SetupShadow3DO() { SetupShadowDrawing();   }
@@ -649,7 +653,7 @@
 inline void CUnitDrawer::DoDrawUnitShadow(CUnit *unit) {
 	const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
 	if (((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) &amp;&amp;
-		camera-&gt;InView(unit-&gt;midPos, unit-&gt;radius + 700)) {
+		camera-&gt;InView(unit-&gt;drawMidPos, unit-&gt;radius + 700)) {
 
 		// FIXME: test against the shadow projection intersection
 		float sqDist = (unit-&gt;pos-camera-&gt;pos).SqLength();
@@ -702,23 +706,20 @@
 		gmlProcessor-&gt;Work(NULL, NULL, &amp;CUnitDrawer::DoDrawUnitShadowMT, this, gmlThreadCount, FALSE,
 		  &amp;uh-&gt;renderUnits, uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
-	else {
+	else
 #endif
+	{
 		std::list&lt;CUnit*&gt;::iterator usi;
 		for (usi = uh-&gt;renderUnits.begin(); usi != uh-&gt;renderUnits.end(); ++usi) {
 			CUnit* unit = *usi;
 			DoDrawUnitShadow(unit);
 		}
-#ifdef USE_GML
 	}
-#endif
 
 	glDisable(GL_VERTEX_PROGRAM_ARB);
-
 	glDisable(GL_POLYGON_OFFSET_FILL);
 
 	DrawShadowShaderUnits();
-
 //	glDisable(GL_TEXTURE_2D);
 }
 
@@ -764,7 +765,7 @@
 	//  * The unit radius, depending on whether the mod defined 'radiusadjust' is true or false.
 	float3 pos;
 	if (gu-&gt;spectatingFullView) {
-		pos = unit-&gt;midPos;
+		pos = unit-&gt;drawMidPos;
 	} else {
 		pos = helper-&gt;GetUnitErrorPos(unit, gu-&gt;myAllyTeam);
 	}
@@ -806,23 +807,8 @@
 }
 
 
-void CUnitDrawer::SetupForGhostDrawing()
+void CUnitDrawer::SetupForGhostDrawing() const
 {
-	glPushAttrib (GL_TEXTURE_BIT | GL_ENABLE_BIT);
-	glEnable(GL_TEXTURE_2D);
-
-	texturehandler-&gt;SetTATexture();
-	glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_MODULATE);
-	glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_ARB, GL_TEXTURE);
-	glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_ARB, GL_PREVIOUS);
-	glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_ARB, GL_PREVIOUS_ARB);
-	glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_ARB, GL_REPLACE);
-	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
-}
-
-
-void CUnitDrawer::SetupForGhostDrawingS3O()
-{
 	SetupBasicS3OTexture0();
 	SetupBasicS3OTexture1();
 	// use the alpha given by glColor for the outgoing alpha.
@@ -834,7 +820,7 @@
 }
 
 
-void CUnitDrawer::CleanUpGhostDrawing()
+void CUnitDrawer::CleanUpGhostDrawing() const
 {
 	glPopAttrib();
 	glDisable(GL_TEXTURE_2D);
@@ -856,7 +842,10 @@
 
 void CUnitDrawer::DrawCloakedUnits(void)
 {
+	GML_RECMUTEX_LOCK(unit); // DrawCloakedUnits
+
 	SetupForGhostDrawing();
+	SetupFor3DO();
 
 	glEnable(GL_TEXTURE_2D);
 	glDisable(GL_CULL_FACE);
@@ -867,9 +856,9 @@
 	glColor4f(1, 1, 1, 0.3f);
 	glDepthMask(0);
 
-	GML_RECMUTEX_LOCK(unit); // DrawCloakedUnits
-
 	{
+		//FIXME: doesn't support s3o's nor does it set teamcolor
+
 		GML_STDMUTEX_LOCK(temp); // DrawCloakedUnits
 		// units drawn by AI, these aren't really
 		// cloaked but the effect is the same
@@ -878,7 +867,7 @@
 				glPushMatrix();
 				glTranslatef3(ti-&gt;second.pos);
 				glRotatef(ti-&gt;second.rotation * 180 / PI, 0, 1, 0);
-				S3DOModel* model = ti-&gt;second.unitdef-&gt;LoadModel(ti-&gt;second.team);
+				S3DModel* model = LoadModel(ti-&gt;second.unitdef);
 				model-&gt;DrawStatic();
 				glPopMatrix();
 			}
@@ -909,9 +898,9 @@
 	// 3dos
 	DrawCloakedUnitsHelper(drawCloaked, ghostBuildings, false);
 
+	CleanUp3DO(); //reset faceculling
+
 	// s3os
-	SetupForGhostDrawingS3O();
-	glColor4f(1, 1, 1, 0.3f);
 	DrawCloakedUnitsHelper(drawCloakedS3O, ghostBuildingsS3O, true);
 
 	// reset gl states
@@ -922,10 +911,10 @@
 }
 
 
-void CUnitDrawer::DrawCloakedUnitsHelper(GML_VECTOR&lt;CUnit*&gt;&amp; dC, std::list&lt;GhostBuilding*&gt;&amp; gB, bool is_s3o)
+void CUnitDrawer::DrawCloakedUnitsHelper(GML_VECTOR&lt;CUnit*&gt;&amp; cloakedUnits, std::list&lt;GhostBuilding*&gt;&amp; ghostedBuildings, bool is_s3o)
 {
 	// cloaked units and living ghosted buildings (stored in same vector)
-	for (GML_VECTOR&lt;CUnit*&gt;::iterator ui = dC.begin(); ui != dC.end(); ++ui) {
+	for (GML_VECTOR&lt;CUnit*&gt;::iterator ui = cloakedUnits.begin(); ui != cloakedUnits.end(); ++ui) {
 		CUnit* unit = *ui;
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 		if(unit==NULL)
@@ -934,9 +923,9 @@
 		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
 		if ((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
 			if (is_s3o) {
-				SetBasicS3OTeamColour(unit-&gt;team);
-				texturehandler-&gt;SetS3oTexture(unit-&gt;model-&gt;textureType);
+				texturehandlerS3O-&gt;SetS3oTexture(unit-&gt;model-&gt;textureType);
 			}
+			SetBasicTeamColour(unit-&gt;team);
 			DrawUnitNow(unit);
 		} else {
 			// ghosted enemy units
@@ -950,44 +939,44 @@
 			glRotatef(unit-&gt;buildFacing * 90.0f, 0, 1, 0);
 
 			// check for decoy models
-			const int unitTeam = unit-&gt;team;
 			const UnitDef* decoyDef = unit-&gt;unitDef-&gt;decoyDef;
-			S3DOModel* model;
+			S3DModel* model;
 			if (decoyDef == NULL) {
 				model = unit-&gt;model;
 			} else {
-				model = decoyDef-&gt;LoadModel(unitTeam);
-				is_s3o = (model-&gt;rootobjects3o != NULL);
+				model = LoadModel(decoyDef);
 			}
+			SetBasicTeamColour(unit-&gt;team);
 
 			if (is_s3o) {
-				SetBasicS3OTeamColour(unitTeam);
-				texturehandler-&gt;SetS3oTexture(model-&gt;textureType);
+				texturehandlerS3O-&gt;SetS3oTexture(model-&gt;textureType);
 			}
 
 			model-&gt;DrawStatic();
 			glPopMatrix();
+
+			glColor4f(1, 1, 1, 0.3f);
 		}
 	}
 
 	// buildings that died but were still ghosted
 	glColor4f(0.6f, 0.6f, 0.6f, 0.4f);
-	for (std::list&lt;GhostBuilding*&gt;::iterator gbi = gB.begin(); gbi != gB.end();) {
+	for (std::list&lt;GhostBuilding*&gt;::iterator gbi = ghostedBuildings.begin(); gbi != ghostedBuildings.end();) {
 		if (loshandler-&gt;InLos((*gbi)-&gt;pos, gu-&gt;myAllyTeam)) {
 			if ((*gbi)-&gt;decal)
 				(*gbi)-&gt;decal-&gt;gbOwner = 0;
 
 			delete *gbi;
-			gbi = gB.erase(gbi);
+			gbi = ghostedBuildings.erase(gbi);
 		} else {
 			if (camera-&gt;InView((*gbi)-&gt;pos, (*gbi)-&gt;model-&gt;radius * 2)) {
 				glPushMatrix();
 				glTranslatef3((*gbi)-&gt;pos);
 				glRotatef((*gbi)-&gt;facing * 90.0f, 0, 1, 0);
+				SetBasicTeamColour((*gbi)-&gt;team);
 
 				if (is_s3o) {
-					SetBasicS3OTeamColour((*gbi)-&gt;team);
-					texturehandler-&gt;SetS3oTexture((*gbi)-&gt;model-&gt;textureType);
+					texturehandlerS3O-&gt;SetS3oTexture((*gbi)-&gt;model-&gt;textureType);
 				}
 
 				(*gbi)-&gt;model-&gt;DrawStatic();
@@ -999,188 +988,12 @@
 }
 
 
-void CUnitDrawer::SetupForUnitDrawing(void)
-{
-	if (shadowHandler-&gt;inShadowPass)
-		return;
 
-	if (advShading &amp;&amp; !water-&gt;drawReflection) {
-		// standard doesn't seem to support vertex program + clipplanes at once
-
-		glBindProgramARB(GL_VERTEX_PROGRAM_ARB, unitVP);
-		glEnable(GL_VERTEX_PROGRAM_ARB);
-
-		if (shadowHandler-&gt;drawShadows) {
-			glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, unitShadowFP);
-		} else {
-			glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB, unitFP);
-		}
-		glEnable(GL_FRAGMENT_PROGRAM_ARB);
-
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 10, mapInfo-&gt;light.sunDir.x, mapInfo-&gt;light.sunDir.y, mapInfo-&gt;light.sunDir.z, 0);
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 12, unitAmbientColor.x, unitAmbientColor.y, unitAmbientColor.z, 1);
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 11, unitSunColor.x, unitSunColor.y, unitSunColor.z, 0);
-		glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB, 13, camera-&gt;pos.x, camera-&gt;pos.y, camera-&gt;pos.z, 0);
-
-		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 10, 0, 0, 0, unitShadowDensity);
-		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 11, unitAmbientColor.x, unitAmbientColor.y, unitAmbientColor.z, 1);
-
-		if (shadowHandler-&gt;drawShadows) {
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-			glBindTexture(GL_TEXTURE_2D, shadowHandler-&gt;shadowTexture);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_FUNC_ARB, GL_LEQUAL);
-			glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);
-			glEnable(GL_TEXTURE_2D);
-		}
-
-		glActiveTextureARB(GL_TEXTURE1_ARB);
-		glEnable(GL_TEXTURE_2D);
-		texturehandler-&gt;SetTATexture();
-
-		glActiveTextureARB(GL_TEXTURE2_ARB);
-		glEnable(GL_TEXTURE_CUBE_MAP_ARB);
-		glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, boxtex);
-
-		glActiveTextureARB(GL_TEXTURE3_ARB);
-		glEnable(GL_TEXTURE_CUBE_MAP_ARB);
-		glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, specularTex);
-
-		glActiveTextureARB(GL_TEXTURE0_ARB);
-
-		glMatrixMode(GL_MATRIX0_ARB);
-		glLoadMatrixf(shadowHandler-&gt;shadowMatrix.m);
-		glMatrixMode(GL_PROJECTION);
-		glPushMatrix();
-		glMultMatrixd(camera-&gt;GetModelview());
-		glMatrixMode(GL_MODELVIEW);
-		glPushMatrix();
-		glLoadIdentity();
-	} else {
-		glEnable(GL_LIGHTING);
-		glLightfv(GL_LIGHT1, GL_POSITION, mapInfo-&gt;light.sunDir);
-		glEnable(GL_LIGHT1);
-	//	glDisable(GL_CULL_FACE);
-	//	glCullFace(GL_BACK);
-		glEnable(GL_TEXTURE_2D);
-		float cols[] = {1, 1, 1, 1};
-		float cols2[] = {1, 1, 1, 1};
-		glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,cols);
-		glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,cols2);
-		glColor3f(1, 1, 1);
-		texturehandler-&gt;SetTATexture();
-	}
-//	glAlphaFunc(GL_GREATER,0.05f);
-	glDisable(GL_ALPHA_TEST);
-	glDisable(GL_BLEND);
-}
-
-
-void CUnitDrawer::CleanUpUnitDrawing(void)
+void CUnitDrawer::SetupForUnitDrawing(void) const
 {
-	if (shadowHandler-&gt;inShadowPass)
-		return;
-
-	if(advShading &amp;&amp; !water-&gt;drawReflection){
-		glDisable( GL_VERTEX_PROGRAM_ARB );
-		glDisable( GL_FRAGMENT_PROGRAM_ARB );
-
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_NONE);
-		glTexParameteri(GL_TEXTURE_2D, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE);
-		glActiveTextureARB(GL_TEXTURE1_ARB);
-		glDisable(GL_TEXTURE_2D);
-
-		glActiveTextureARB(GL_TEXTURE2_ARB);
-		glDisable(GL_TEXTURE_CUBE_MAP_ARB);
-
-		glActiveTextureARB(GL_TEXTURE3_ARB);
-		glDisable(GL_TEXTURE_CUBE_MAP_ARB);
-
-		glActiveTextureARB(GL_TEXTURE0_ARB);
-
-		glMatrixMode(GL_PROJECTION);
-		glPopMatrix();
-		glMatrixMode(GL_MODELVIEW);
-		glPopMatrix();
-	} else {
-		glDisable(GL_LIGHTING);
-		glDisable(GL_LIGHT1);
-	}
-}
-
-
-void CUnitDrawer::SetS3OTeamColour(int team)
-{
-	if (advShading) {
-		unsigned char* col = teamHandler-&gt;Team(team)-&gt;color;
-		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 14, col[0] / 255.f, col[1] / 255.f, col[2] / 255.f, 1);
-		if (luaDrawing) { // FIXME?
-			SetBasicS3OTeamColour(team);
-		}
-	} else {
-		SetBasicS3OTeamColour(team);
-	}
-}
-
-
-void CUnitDrawer::SetBasicS3OTeamColour(int team)
-{
-	unsigned char* col = teamHandler-&gt;Team(team)-&gt;color;
-	float texConstant[] = {col[0] / 255.f, col[1] / 255.f, col[2] / 255.f, 1};
-	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, texConstant);
-}
-
-
-/**
- * Set up the texture environment in texture unit 0
- * to give an S3O texture its team-colour.
- *
- * Also:
- * - call SetBasicS3OTeamColour to set the team colour to transform to.
- * - Replace the output alpha channel. If not, only the team-coloured bits will show, if that. Or something.
- */
-void CUnitDrawer::SetupBasicS3OTexture0(void)
-{
-	// RGB = Texture * (1-Alpha) + Teamcolor * Alpha
-	glActiveTextureARB(GL_TEXTURE0_ARB);
-	glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB, GL_INTERPOLATE_ARB);
-	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB, GL_TEXTURE);
-	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB, GL_CONSTANT_ARB);
-	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE2_RGB_ARB, GL_TEXTURE);
-	glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND2_RGB_ARB, GL_ONE_MINUS_SRC_ALPHA);
-	glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);
-	glEnable(GL_TEXTURE_2D);
-}
-
-
-/**
- * This sets the first texture unit to GL_MODULATE the colours from the
- * first texture unit with the current glColor.
- *
- * Normal S3O drawing sets the color to full white; translucencies
- * use this setup to 'tint' the drawn model.
- *
- * - Leaves glActivateTextureARB at the first unit.
- * - This doesn't tinker with the output alpha, either.
- */
-void CUnitDrawer::SetupBasicS3OTexture1(void)
-{
-	// RGB = Primary Color * Previous
-	glActiveTextureARB(GL_TEXTURE1_ARB);
-	glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
-	glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB, GL_MODULATE);
-	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB, GL_PRIMARY_COLOR_ARB);
-	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB, GL_PREVIOUS_ARB);
-
-	glEnable(GL_TEXTURE_2D);
-	glBindTexture(GL_TEXTURE_2D, whiteTex);
-}
-
-
-void CUnitDrawer::SetupForS3ODrawing(void)
-{
 	//glDisable(GL_ALPHA_TEST);
 	//glDisable(GL_BLEND);
+
 	glCullFace(GL_BACK);
 	glEnable(GL_CULL_FACE);
 
@@ -1197,12 +1010,12 @@
 	}
 
 	if (advShading &amp;&amp; !water-&gt;drawReflection) { //standard doesnt seem to support vertex program+clipplanes at once
-		glBindProgramARB( GL_VERTEX_PROGRAM_ARB, unitS3oVP );
+		glBindProgramARB( GL_VERTEX_PROGRAM_ARB, unitVP );
 		glEnable( GL_VERTEX_PROGRAM_ARB );
 		if (shadowHandler-&gt;drawShadows) {
-			glBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, unitShadowS3oFP );
+			glBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, unitShadowFP );
 		} else {
-			glBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, unitS3oFP );
+			glBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, unitFP );
 		}
 		glEnable( GL_FRAGMENT_PROGRAM_ARB );
 
@@ -1240,7 +1053,6 @@
 		glActiveTextureARB(GL_TEXTURE0_ARB);
 
 		glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-		//glEnable(GL_BLEND);
 		glAlphaFunc(GL_GREATER,0.5f);
 		glEnable(GL_ALPHA_TEST);
 
@@ -1257,22 +1069,18 @@
 		glLightfv(GL_LIGHT1, GL_POSITION, mapInfo-&gt;light.sunDir);
 		glEnable(GL_LIGHT1);
 
+		SetupBasicS3OTexture1();
 		SetupBasicS3OTexture0();
 
-		// Set material color and fallback texture (3DO texture)
+		// Set material color
 		float cols[]={1,1,1,1};
 		glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE,cols);
 		glColor3f(1,1,1);
-		texturehandler-&gt;SetTATexture();
-
-		SetupBasicS3OTexture1();
-
-		glActiveTextureARB(GL_TEXTURE0_ARB);
 	}
 }
 
 
-void CUnitDrawer::CleanUpS3ODrawing(void)
+void CUnitDrawer::CleanUpUnitDrawing(void) const
 {
 	glDisable(GL_CULL_FACE);
 	glDisable(GL_BLEND);
@@ -1320,8 +1128,96 @@
 }
 
 
-void CUnitDrawer::CleanupBasicS3OTexture1(void)
+void CUnitDrawer::SetTeamColour(int team) const
 {
+	if (advShading) {
+		unsigned char* col = teamHandler-&gt;Team(team)-&gt;color;
+		glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB, 14, col[0] / 255.f, col[1] / 255.f, col[2] / 255.f, 1);
+		if (luaDrawing) { // FIXME?
+			SetBasicTeamColour(team);
+		}
+	} else {
+		SetBasicTeamColour(team);
+	}
+}
+
+
+void CUnitDrawer::SetBasicTeamColour(int team) const
+{
+	unsigned char* col = teamHandler-&gt;Team(team)-&gt;color;
+	float texConstant[] = {col[0] / 255.f, col[1] / 255.f, col[2] / 255.f, 1};
+	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, texConstant);
+}
+
+
+/**
+ * Binds the 3do texture atlas and deactivates face culling
+ */
+void CUnitDrawer::SetupFor3DO() const
+{
+	texturehandler3DO-&gt;Set3doAtlases();
+	glPushAttrib(GL_POLYGON_BIT);
+	glDisable(GL_CULL_FACE);
+}
+
+
+/**
+ * Reset face culling after 3do drawing
+ */
+void CUnitDrawer::CleanUp3DO() const
+{
+	glPopAttrib();
+}
+
+
+/**
+ * Set up the texture environment in texture unit 0
+ * to give an S3O texture its team-colour.
+ *
+ * Also:
+ * - call SetBasicTeamColour to set the team colour to transform to.
+ * - Replace the output alpha channel. If not, only the team-coloured bits will show, if that. Or something.
+ */
+void CUnitDrawer::SetupBasicS3OTexture0(void) const
+{
+	// RGB = Texture * (1-Alpha) + Teamcolor * Alpha
+	glActiveTextureARB(GL_TEXTURE0_ARB);
+	glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB, GL_INTERPOLATE_ARB);
+	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB, GL_TEXTURE);
+	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB, GL_CONSTANT_ARB);
+	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE2_RGB_ARB, GL_TEXTURE);
+	glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND2_RGB_ARB, GL_ONE_MINUS_SRC_ALPHA);
+	glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);
+	glEnable(GL_TEXTURE_2D);
+}
+
+
+/**
+ * This sets the first texture unit to GL_MODULATE the colours from the
+ * first texture unit with the current glColor.
+ *
+ * Normal S3O drawing sets the color to full white; translucencies
+ * use this setup to 'tint' the drawn model.
+ *
+ * - Leaves glActivateTextureARB at the first unit.
+ * - This doesn't tinker with the output alpha, either.
+ */
+void CUnitDrawer::SetupBasicS3OTexture1(void) const
+{
+	// RGB = Primary Color * Previous
+	glActiveTextureARB(GL_TEXTURE1_ARB);
+	glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
+	glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB, GL_MODULATE);
+	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB, GL_PRIMARY_COLOR_ARB);
+	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB, GL_PREVIOUS_ARB);
+
+	glEnable(GL_TEXTURE_2D);
+	glBindTexture(GL_TEXTURE_2D, whiteTex);
+}
+
+
+void CUnitDrawer::CleanupBasicS3OTexture1(void) const
+{
 	// reset texture1 state
 	glActiveTextureARB(GL_TEXTURE1_ARB);
 	glDisable(GL_TEXTURE_2D);
@@ -1330,7 +1226,7 @@
 }
 
 
-void CUnitDrawer::CleanupBasicS3OTexture0(void)
+void CUnitDrawer::CleanupBasicS3OTexture0(void) const
 {
 	// reset texture0 state
 	glActiveTextureARB(GL_TEXTURE0_ARB);
@@ -1351,56 +1247,33 @@
  * Unfortunately, it doesn't work! With advanced shading on, the green
  * is darker than usual; with shadows as well, it's almost black. -- krudat
  */
-void CUnitDrawer::UnitDrawingTexturesOff(S3DOModel *model)
+void CUnitDrawer::UnitDrawingTexturesOff(S3DModel *model)
 {
-	if (model-&gt;textureType == 0){
-		/* 3DO */
-		/* If SetupForUnitDrawing is changed, this may need tweaking too. */
-		if(advShading &amp;&amp; !water-&gt;drawReflection){
-			glDisable(GL_VERTEX_PROGRAM_ARB);
-			glDisable(GL_FRAGMENT_PROGRAM_ARB);
-			/* TEXTURE0: Shadows. */
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE1_ARB); // Unit texture.
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE2_ARB); // boxtex
-			glDisable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE3_ARB); // specularTex
-			glDisable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-			glDisable(GL_FOG);
-		} else {
-			glDisable(GL_LIGHTING);
-			glDisable(GL_TEXTURE_2D);
-		}
+	/* If SetupForUnitDrawing is changed, this may need tweaking too. */
+	if(advShading &amp;&amp; !water-&gt;drawReflection){
+		/* Odd. Units with only the first texture build cyan rather than
+		   green. Presume it's an improvement on black. :S -- krudat */
+		glDisable(GL_VERTEX_PROGRAM_ARB);
+		glDisable(GL_FRAGMENT_PROGRAM_ARB);
+		/* TEXTURE0: Colour texture. */
+		glDisable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE1_ARB); // 'Shiny' texture.
+		glDisable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE2_ARB); // Shadows.
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_NONE);
+		glDisable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE3_ARB); // boxtex
+		glDisable(GL_TEXTURE_CUBE_MAP_ARB);
+		glActiveTextureARB(GL_TEXTURE4_ARB); // specularTex
+		glDisable(GL_TEXTURE_CUBE_MAP_ARB);
+		glActiveTextureARB(GL_TEXTURE0_ARB);
 	} else {
-		/* S3O */
-		/* If SetupForS3ODrawing is changed, this may need tweaking too. */
-		if(advShading &amp;&amp; !water-&gt;drawReflection){
-			/* Odd. Units with only the first texture build cyan rather than
-			   green. Presume it's an improvement on black. :S -- krudat */
-			glDisable(GL_VERTEX_PROGRAM_ARB);
-			glDisable(GL_FRAGMENT_PROGRAM_ARB);
-			/* TEXTURE0: Colour texture. */
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE1_ARB); // 'Shiny' texture.
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE2_ARB); // Shadows.
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_NONE);
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE3_ARB); // boxtex
-			glDisable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE4_ARB); // specularTex
-			glDisable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		} else {
-			glDisable(GL_LIGHTING);
-			/* TEXTURE0: Colour texture. */
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE1_ARB); // GL lighting, I think.
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		}
+		glDisable(GL_LIGHTING);
+		/* TEXTURE0: Colour texture. */
+		glDisable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE1_ARB); // GL lighting, I think.
+		glDisable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE0_ARB);
 	}
 }
 
@@ -1411,53 +1284,30 @@
  *
  * Does *not* restore the texture bindings.
  */
-void CUnitDrawer::UnitDrawingTexturesOn(S3DOModel *model)
+void CUnitDrawer::UnitDrawingTexturesOn(S3DModel *model)
 {
-	/* If UnitDrawingTextureOff is changed, this may need tweaking too. */
-	if (model-&gt;textureType == 0){
-		/* 3DO */
-		if(advShading &amp;&amp; !water-&gt;drawReflection){
-			glEnable(GL_VERTEX_PROGRAM_ARB);
-			glEnable(GL_FRAGMENT_PROGRAM_ARB);
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE2_ARB);
-			glEnable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE3_ARB);
-			glEnable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-			glEnable(GL_FOG);
-		} else {
-			glEnable(GL_LIGHTING);
-			glColor3f(1,1,1);
-			glEnable(GL_TEXTURE_2D);
-		}
-	} else {
-		/* S3O */
-		if(advShading &amp;&amp; !water-&gt;drawReflection){
-			glEnable(GL_VERTEX_PROGRAM_ARB);
-			glEnable(GL_FRAGMENT_PROGRAM_ARB);
+	if(advShading &amp;&amp; !water-&gt;drawReflection){
+		glEnable(GL_VERTEX_PROGRAM_ARB);
+		glEnable(GL_FRAGMENT_PROGRAM_ARB);
 
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE2_ARB);
-			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE3_ARB);
-			glEnable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE4_ARB);
-			glEnable(GL_TEXTURE_CUBE_MAP_ARB);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		} else {
-			glEnable(GL_LIGHTING);
-			glColor3f(1,1,1);
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glEnable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		}
+		glEnable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE1_ARB);
+		glEnable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE2_ARB);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_COMPARE_MODE_ARB, GL_COMPARE_R_TO_TEXTURE);
+		glEnable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE3_ARB);
+		glEnable(GL_TEXTURE_CUBE_MAP_ARB);
+		glActiveTextureARB(GL_TEXTURE4_ARB);
+		glEnable(GL_TEXTURE_CUBE_MAP_ARB);
+		glActiveTextureARB(GL_TEXTURE0_ARB);
+	} else {
+		glEnable(GL_LIGHTING);
+		glColor3f(1,1,1);
+		glEnable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE1_ARB);
+		glEnable(GL_TEXTURE_2D);
+		glActiveTextureARB(GL_TEXTURE0_ARB);
 	}
 }
 
@@ -1574,13 +1424,11 @@
 
 void CUnitDrawer::DrawQuedS3O(void)
 {
-	SetupForS3ODrawing();
-
 #ifdef USE_GML
 	int sz=quedS3Os.size();
 	for(int tex=0; tex&lt;sz;++tex) {
 		if(quedS3Os[tex].size()&gt;0) {
-			texturehandler-&gt;SetS3oTexture(tex);
+			texturehandlerS3O-&gt;SetS3oTexture(tex);
 
 			for(GML_VECTOR&lt;CWorldObject*&gt;::iterator ui = quedS3Os[tex].begin(); ui != quedS3Os[tex].end(); ++ui){
 				DrawWorldObjectS3O(*ui);
@@ -1592,7 +1440,7 @@
 #else
 	for (std::set&lt;int&gt;::iterator uti = usedS3OTextures.begin(); uti != usedS3OTextures.end(); ++uti) {
 		const int tex = *uti;
-		texturehandler-&gt;SetS3oTexture(tex);
+		texturehandlerS3O-&gt;SetS3oTexture(tex);
 
 		for (GML_VECTOR&lt;CWorldObject*&gt;::iterator ui = quedS3Os[tex].begin(); ui != quedS3Os[tex].end(); ++ui) {
 			DrawWorldObjectS3O(*ui);
@@ -1600,10 +1448,8 @@
 
 		quedS3Os[tex].clear();
 	}
-
 	usedS3OTextures.clear();
 #endif
-	CleanUpS3ODrawing();
 }
 
 
@@ -1642,25 +1488,23 @@
 		mat.Execute(LuaMaterial::defMat);
 
 		lodMat-&gt;uniforms.Execute(unit);
-		SetS3OTeamColour(unit-&gt;team);
+		SetTeamColour(unit-&gt;team);
 		DrawUnitRawWithLists(unit, lodMat-&gt;preDisplayList, lodMat-&gt;postDisplayList);
 
 		LuaMaterial::defMat.Execute(mat);
 	}
-	else if (unit-&gt;model-&gt;textureType == 0){
-		/* 3DO */
+	else {
+		/* 3DO + S3O */
 		SetupForUnitDrawing();
+		if (unit-&gt;model-&gt;type==MODELTYPE_3DO){
+			texturehandler3DO-&gt;Set3doAtlases();
+		}else{
+			texturehandlerS3O-&gt;SetS3oTexture(unit-&gt;model-&gt;textureType);
+		}
+		SetTeamColour(unit-&gt;team);
 		DrawUnitRaw(unit);
 		CleanUpUnitDrawing();
 	}
-	else {
-		/* S3O */
-		SetupForS3ODrawing();
-		texturehandler-&gt;SetS3oTexture(unit-&gt;model-&gt;textureType);
-		SetS3OTeamColour(unit-&gt;team);
-		DrawUnitRaw(unit);
-		CleanUpS3ODrawing();
-	}
 
 	gu-&gt;drawdebug = origDebug;
 }
@@ -1678,33 +1522,21 @@
  */
 void CUnitDrawer::DrawBuildingSample(const UnitDef* unitdef, int side, float3 pos, int facing)
 {
-	S3DOModel* model = unitdef-&gt;LoadModel(side);
+	S3DModel* model = LoadModel(unitdef);
 
-	if (model-&gt;textureType == 0) {
-		/* 3DO */
-		SetupForGhostDrawing();		// (model, side);
-		glPushMatrix();
-		glTranslatef3(pos);
-		glRotatef(facing * 90.0f, 0, 1, 0);
-		model-&gt;DrawStatic();
-		CleanUpGhostDrawing();
-		glPopMatrix();
-		return;
-	}
-
-	/* S3O */
-
 	/* From SetupForGhostDrawing. */
 	glPushAttrib (GL_TEXTURE_BIT | GL_ENABLE_BIT);
 
 	/* *No* GL lighting. */
 
 	/* Get the team-coloured texture constructed by unit 0. */
-	SetBasicS3OTeamColour(side);
+	SetBasicTeamColour(side);
 	SetupBasicS3OTexture0();
-	texturehandler-&gt;SetS3oTexture(model-&gt;textureType);
-
-	/* Tint it with the current glColor in unit 1. */
+	if (model-&gt;type==MODELTYPE_3DO) {
+		texturehandler3DO-&gt;Set3doAtlases();
+	} else {
+		texturehandlerS3O-&gt;SetS3oTexture(model-&gt;textureType);
+	}
 	SetupBasicS3OTexture1();
 
 	/* Use the alpha given by glColor for the outgoing alpha.
@@ -1748,52 +1580,40 @@
 
 void CUnitDrawer::DrawUnitDef(const UnitDef* unitDef, int team)
 {
-	S3DOModel* model = unitDef-&gt;LoadModel(team);
+	S3DModel* model = LoadModel(unitDef);
 
 	glPushAttrib (GL_TEXTURE_BIT | GL_ENABLE_BIT);
 	glEnable(GL_TEXTURE_2D);
 
-	if (model-&gt;textureType == 0) {
-		// 3DO model
-		texturehandler-&gt;SetTATexture();
-		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_MODULATE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_ARB, GL_TEXTURE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_ARB, GL_PREVIOUS);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_ARB, GL_PREVIOUS_ARB);
-		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_ARB, GL_REPLACE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
-
-		model-&gt;DrawStatic();
+	// get the team-coloured texture constructed by unit 0
+	SetBasicTeamColour(team);
+	SetupBasicS3OTexture0();
+	if (model-&gt;type==MODELTYPE_3DO) {
+		texturehandler3DO-&gt;Set3doAtlases();
+	} else {
+		texturehandlerS3O-&gt;SetS3oTexture(model-&gt;textureType);
 	}
-	else {
-		// get the team-coloured texture constructed by unit 0
-		SetBasicS3OTeamColour(team);
-		SetupBasicS3OTexture0();
-		texturehandler-&gt;SetS3oTexture(model-&gt;textureType);
+	// tint it with the current glColor in unit 1
+	SetupBasicS3OTexture1();
 
-		// tint it with the current glColor in unit 1
-		SetupBasicS3OTexture1();
+	// use the alpha given by glColor for the outgoing alpha.
+	// (might need to change this if we ever have transparent bits on units?)
+	glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_ARB, GL_REPLACE);
+	glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_ARB, GL_PRIMARY_COLOR_ARB);
 
-		// use the alpha given by glColor for the outgoing alpha.
-		// (might need to change this if we ever have transparent bits on units?)
-		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_ARB, GL_REPLACE);
-		glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_ARB, GL_PRIMARY_COLOR_ARB);
+	glActiveTextureARB(GL_TEXTURE0_ARB);
+	model-&gt;DrawStatic();
 
-		glActiveTextureARB(GL_TEXTURE0_ARB);
+	// reset texture1 state
+	CleanupBasicS3OTexture1();
 
-		model-&gt;DrawStatic();
+	// also reset the alpha generation
+	glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB, GL_MODULATE);
+	glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB, GL_TEXTURE);
 
-		// reset texture1 state
-		CleanupBasicS3OTexture1();
+	// reset texture0 state
+	CleanupBasicS3OTexture0();
 
-		// also reset the alpha generation
-		glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB, GL_MODULATE);
-		glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB, GL_TEXTURE);
-
-		// reset texture0 state
-		CleanupBasicS3OTexture0();
-	}
-
 	glPopAttrib();
 }
 
@@ -1880,7 +1700,7 @@
 	glEnable(GL_CLIP_PLANE1);
 
 	const float col = fabs(128.0f - ((gs-&gt;frameNum * 4) &amp; 255)) / 255.0f + 0.5f;
-	float3 fc;// fc frame color
+	float3 fc;// fc := frame color
 	if (!gu-&gt;teamNanospray) {
 		fc = unit-&gt;unitDef-&gt;nanoColor;
 	}
@@ -1967,7 +1787,10 @@
 
 void CUnitDrawer::DrawUnitNow(CUnit* unit)
 {
-	glAlphaFunc(GL_GEQUAL, unit-&gt;alphaThreshold);
+	if (unit-&gt;alphaThreshold != 0.1f) {
+		//glPushAttrib(GL_COLOR_BUFFER_BIT);
+		//glAlphaFunc(GL_GREATER, unit-&gt;alphaThreshold);
+	}
 
 	glPushMatrix();
 	ApplyUnitTransformMatrix(unit);
@@ -1980,6 +1803,10 @@
 
 	DrawUnitDebug(unit);
 	glPopMatrix();
+
+	if (unit-&gt;alphaThreshold != 0.1f) {
+		//glPopAttrib();
+	}
 }
 
 
@@ -2127,19 +1954,17 @@
 
 void CUnitDrawer::DrawUnitS3O(CUnit* unit)
 {
-	SetS3OTeamColour(unit-&gt;team);
+	SetTeamColour(unit-&gt;team);
 	DrawUnitNow(unit);
 }
 
 
-void CUnitDrawer::DrawFeatureS3O(CFeature* feature)
+void CUnitDrawer::DrawFeatureStatic(CFeature* feature)
 {
 	glPushMatrix();
 	glMultMatrixf(feature-&gt;transMatrix.m);
 
-	if (feature-&gt;model-&gt;textureType) {
-		unitDrawer-&gt;SetS3OTeamColour(feature-&gt;team);
-	}
+	SetTeamColour(feature-&gt;team);
 
 	feature-&gt;model-&gt;DrawStatic();
 	glPopMatrix();
@@ -2150,7 +1975,7 @@
 {
 	if (S3OObj) {
 		// calls back to DrawUnitS3O() for units and
-		// DrawFeatureS3O() for features, projectiles
+		// DrawFeatureStatic() for features, projectiles
 		// and weapons with S3O models do not
 		S3OObj-&gt;DrawS3O();
 	}

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.h
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -10,7 +10,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 
 class CVertexArray;
-struct S3DOModel;
+struct S3DModel;
 struct UnitDef;
 class CWorldObject;
 class CUnit;
@@ -34,14 +34,19 @@
 	void DrawCloakedUnits(void);     // cloaked units must be drawn after all others
 	void DrawShadowPass(void);
 	void DoDrawUnitShadow(CUnit *unit);
-	void SetupForUnitDrawing(void);
-	void CleanUpUnitDrawing(void);
-	void SetupForS3ODrawing(void);
-	void CleanUpS3ODrawing(void);
-	void CleanUpGhostDrawing();
-	void SetupForGhostDrawing();
-	void SetupForGhostDrawingS3O();
 
+	void DrawOpaqueShaderUnits();
+	void DrawCloakedShaderUnits();
+	void DrawShadowShaderUnits();
+
+	void SetTeamColour(int team) const;
+	void SetupFor3DO() const;
+	void CleanUp3DO() const;
+	void SetupForUnitDrawing(void) const;
+	void CleanUpUnitDrawing(void) const;
+	void SetupForGhostDrawing() const;
+	void CleanUpGhostDrawing() const;
+
 #ifdef USE_GML
 	int multiThreadDrawUnit;
 	int multiThreadDrawUnitShadow;
@@ -64,10 +69,6 @@
 	static void DoDrawUnitShadowMT(void *c,CUnit *unit) {((CUnitDrawer *)c)-&gt;DoDrawUnitShadow(unit);}
 #endif
 
-	void DrawOpaqueShaderUnits();
-	void DrawCloakedShaderUnits();
-	void DrawShadowShaderUnits();
-
 	inline void DrawFar(CUnit* unit);
 
 	// note: make these static?
@@ -82,7 +83,7 @@
 	void DrawUnitRawWithLists(CUnit*, unsigned int, unsigned int);  // was CUnit::DrawRawWithLists()
 	void DrawUnitStats(CUnit*);                                     // was CUnit::DrawStats()
 	void DrawUnitS3O(CUnit*);                                       // was CUnit::DrawS3O()
-	void DrawFeatureS3O(CFeature*);                                 // was CFeature::DrawS3O()
+	void DrawFeatureStatic(CFeature*);                              // was CFeature::DrawS3O()
 	inline void DrawWorldObjectS3O(CWorldObject*);
 
 	void SetUnitDrawDist(float dist);
@@ -106,13 +107,10 @@
 	float LODScaleReflection;
 	float LODScaleRefraction;
 
-	unsigned int unitVP;             // vertex program for 3DO
-	unsigned int unitFP;             // fragment program for 3DO, shadows disabled
-	unsigned int unitShadowFP;       // fragment program for 3DO, shadows enabled
-	unsigned int unitS3oVP;          // vertex program for S3O
-	unsigned int unitS3oFP;          // fragment program for S3O, shadows disabled
-	unsigned int unitShadowS3oFP;    // fragment program for S3O, shadows enabled
-	unsigned int unitShadowGenVP;    // vertex program for shadow pass (both 3DO and S3O)
+	unsigned int unitVP;             // vertex program
+	unsigned int unitFP;             // fragment program, shadows disabled
+	unsigned int unitShadowFP;       // fragment program, shadows enabled
+	unsigned int unitShadowGenVP;    // vertex program for shadow pass
 
 	GLuint boxtex;
 	unsigned int reflTexSize;
@@ -147,7 +145,7 @@
 	struct GhostBuilding {
 		BuildingGroundDecal* decal;
 		float3 pos;
-		S3DOModel* model;
+		S3DModel* model;
 		int facing;
 		int team;
 	};
@@ -156,8 +154,6 @@
 
 	bool showHealthBars;
 
-	bool usingAtiHacks;
-
 	float3 camNorm;		//used by drawfar
 
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -172,25 +168,24 @@
 	GML_CLASSVECTOR&lt;GML_VECTOR&lt;CWorldObject*&gt; &gt; quedS3Os;
 	std::set&lt;int&gt; usedS3OTextures;
 
-	void SetS3OTeamColour(int team);
 	void DrawBuildingSample(const UnitDef* unitdef, int side, float3 pos, int facing=0);
 	void DrawUnitDef(const UnitDef* unitDef, int team);
 
 	/** CUnit::Draw **/
-	void UnitDrawingTexturesOff(S3DOModel *model);
-	void UnitDrawingTexturesOn(S3DOModel *model);
+	void UnitDrawingTexturesOff(S3DModel *model);
+	void UnitDrawingTexturesOn(S3DModel *model);
 
 	/** CGame::DrawDirectControlHud,  **/
 	void DrawIndividual(CUnit * unit);
 
 private:
-	void SetBasicS3OTeamColour(int team);
-	void SetupBasicS3OTexture0(void);
-	void SetupBasicS3OTexture1(void);
-	void CleanupBasicS3OTexture1(void);
-	void CleanupBasicS3OTexture0(void);
-	void DrawIcon(CUnit * unit, bool asRadarBlip);
-	void DrawCloakedUnitsHelper(GML_VECTOR&lt;CUnit*&gt;&amp; dC, std::list&lt;GhostBuilding*&gt;&amp; gB, bool is_s3o);
+	void SetBasicTeamColour(int team) const;
+	void SetupBasicS3OTexture0(void) const;
+	void SetupBasicS3OTexture1(void) const;
+	void CleanupBasicS3OTexture1(void) const;
+	void CleanupBasicS3OTexture0(void) const;
+	void DrawIcon(CUnit* unit, bool asRadarBlip);
+	void DrawCloakedUnitsHelper(GML_VECTOR&lt;CUnit*&gt;&amp; units, std::list&lt;GhostBuilding*&gt;&amp; ghostedBuildings, bool is_s3o);
 };
 
 extern CUnitDrawer* unitDrawer;

Modified: trunk/rts/Rendering/UnitModels/s3oParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/s3oParser.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/s3oParser.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -13,66 +13,17 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;s3o.h&quot;
-#include &quot;Rendering/FartextureHandler.h&quot;
 #include &quot;Sim/Units/COB/CobInstance.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
+#include &quot;Rendering/Textures/S3OTextureHandler.h&quot;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Util.h&quot;
 #include &quot;Exceptions.h&quot;
+#include &quot;LogOutput.h&quot;
 
-void SS3O::DrawStatic()
-{
-	glPushMatrix();
-	glTranslatef(offset.x,offset.y,offset.z);
-	glCallList(displist);
-	for(unsigned int i=0; i&lt;childs.size(); i++)
-		childs[i]-&gt;DrawStatic();
-	glPopMatrix();
-}
 
-SS3O::~SS3O()
+S3DModel* CS3OParser::Load(std::string name)
 {
-	glDeleteLists(displist, 1);
-}
-
-
-CS3OParser::CS3OParser()
-{
-
-}
-
-CS3OParser::~CS3OParser()
-{
-	std::map&lt;std::string,S3DOModel*&gt;::iterator ui;
-	for(ui=units.begin();ui!=units.end();++ui){
-		DeleteSS3O(ui-&gt;second-&gt;rootobjects3o);
-		delete ui-&gt;second;
-	}
-}
-
-void CS3OParser::DeleteSS3O(SS3O* o)
-{
-	for(std::vector&lt;SS3O*&gt;::iterator di=o-&gt;childs.begin();di!=o-&gt;childs.end();di++){
-		DeleteSS3O(*di);
-	}
-	delete o;
-}
-
-S3DOModel* CS3OParser::LoadS3O(std::string name,float scale,int side)
-{
-	GML_STDMUTEX_LOCK(model); // LoadS3O
-
-	if(name.find(&quot;.&quot;)==std::string::npos)
-		name+=&quot;.s3o&quot;;
-
-	StringToLowerInPlace(name);
-
-	std::map&lt;std::string,S3DOModel*&gt;::iterator ui;
-	if((ui=units.find(name))!=units.end()){
-		return ui-&gt;second;
-	}
-
 	PUSH_CODE_MODE;
 	ENTER_SYNCED;
 
@@ -87,26 +38,20 @@
 	memcpy(&amp;header,fileBuf,sizeof(header));
 	header.swap();
 
-	S3DOModel *model = SAFE_NEW S3DOModel;
+	S3DModel *model = SAFE_NEW S3DModel;
+	model-&gt;type=MODELTYPE_S3O;
 	model-&gt;numobjects=0;
-	SS3O* object=LoadPiece(fileBuf,header.rootPiece,model);
-	model-&gt;rootobjects3o=object;
-	model-&gt;rootobject3do=0;
-	object-&gt;isEmpty=true;
 	model-&gt;name=name;
 	model-&gt;tex1=(char*)&amp;fileBuf[header.texture1];
 	model-&gt;tex2=(char*)&amp;fileBuf[header.texture2];
-	texturehandler-&gt;LoadS3OTexture(model);
+	texturehandlerS3O-&gt;LoadS3OTexture(model);
+	SS3OPiece* object=LoadPiece(fileBuf,header.rootPiece,model);
+	object-&gt;type=MODELTYPE_S3O;
 
 	FindMinMax(object);
 
-	units[name]=model;
-
-	CreateLists(object);
-
-	// this is a hack to make aircrafts less likely to collide and get hit by nontracking weapons
-	// note: does not apply anymore, unit &lt;--&gt; projectile coldet no longer depends on model-&gt;radius
-	model-&gt;radius = header.radius * scale;
+	model-&gt;rootobject=object;
+	model-&gt;radius = header.radius;
 	model-&gt;height = header.height;
 	model-&gt;relMidPos.x=header.midx;
 	model-&gt;relMidPos.y=header.midy;
@@ -114,130 +59,35 @@
 	if(model-&gt;relMidPos.y&lt;1)
 		model-&gt;relMidPos.y=1;
 
-//	logOutput.Print(&quot;%s has height %f&quot;,name,model-&gt;height);
-	fartextureHandler-&gt;CreateFarTexture(model);
+	model-&gt;maxx=object-&gt;maxx;
+	model-&gt;maxy=object-&gt;maxy;
+	model-&gt;maxz=object-&gt;maxz;
 
-	model-&gt;maxx=model-&gt;rootobjects3o-&gt;maxx;
-	model-&gt;maxy=model-&gt;rootobjects3o-&gt;maxy;
-	model-&gt;maxz=model-&gt;rootobjects3o-&gt;maxz;
+	model-&gt;minx=object-&gt;minx;
+	model-&gt;miny=object-&gt;miny;
+	model-&gt;minz=object-&gt;minz;
 
-	model-&gt;minx=model-&gt;rootobjects3o-&gt;minx;
-	model-&gt;miny=model-&gt;rootobjects3o-&gt;miny;
-	model-&gt;minz=model-&gt;rootobjects3o-&gt;minz;
-
 	delete[] fileBuf;
 	POP_CODE_MODE;
+
 	return model;
 }
 
-LocalS3DOModel* CS3OParser::CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces)
+SS3OPiece* CS3OParser::LoadPiece(unsigned char* buf, int offset,S3DModel* model)
 {
-	LocalS3DOModel *lmodel = SAFE_NEW LocalS3DOModel;
-	lmodel-&gt;numpieces = model-&gt;numobjects;
-
-	int piecenum=0;
-	lmodel-&gt;pieces = SAFE_NEW LocalS3DO[model-&gt;numobjects];
-	lmodel-&gt;pieces-&gt;parent = NULL;
-	lmodel-&gt;scritoa = SAFE_NEW int[pieces-&gt;size()];
-	for (int a = 0; a &lt; pieces-&gt;size(); ++a) {
-		lmodel-&gt;scritoa[a]=-1;
-	}
-
-	CreateLocalModel(model-&gt;rootobjects3o, lmodel, pieces, &amp;piecenum);
-
-	return lmodel;
-}
-
-void CS3OParser::CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum)
-{
-	PUSH_CODE_MODE;
-	ENTER_SYNCED;
-	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
-	lmodel-&gt;pieces[*piecenum].offset = model-&gt;offset;
-	lmodel-&gt;pieces[*piecenum].name = model-&gt;name;
-	lmodel-&gt;pieces[*piecenum].originals3o = model;
-	lmodel-&gt;pieces[*piecenum].original3do = 0;
-
-	lmodel-&gt;pieces[*piecenum].anim = NULL;
-	unsigned int cur;
-
-	//Map this piecename to an index in the script's pieceinfo
-	for (cur=0; cur&lt;pieces-&gt;size(); cur++) {
-		if (lmodel-&gt;pieces[*piecenum].name.compare((*pieces)[cur].name) == 0) {
-			break;
-		}
-	}
-
-	//Not found? Try again with partial matching
-	if (cur == pieces-&gt;size()) {
-		std::string &amp;s1 = lmodel-&gt;pieces[*piecenum].name;
-		for (cur = 0; cur &lt; pieces-&gt;size(); ++cur) {
-			std::string &amp;s2 = (*pieces)[cur].name;
-			int maxcompare = std::min(s1.size(), s2.size());
-			int j;
-			for (j = 0; j &lt; maxcompare; ++j) {
-				if (s1[j] != s2[j]) {
-					break;
-				}
-			}
-			//Match now?
-			if (j == maxcompare) {
-				break;
-			}
-		}
-	}
-
-	//Did we find it now?
-	if (cur &lt; pieces-&gt;size()) {
-		lmodel-&gt;pieces[*piecenum].anim = &amp;((*pieces)[cur]);
-		lmodel-&gt;scritoa[cur] = *piecenum;
-	}
-	else {
-//		logOutput.Print(&quot;CreateLocalModel: Could not map %s to script&quot;, lmodel-&gt;pieces[*piecenum].name.c_str());
-	}
-
-	int thispiece = *piecenum;
-
-	for (unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
-		(*piecenum)++;
-		lmodel-&gt;pieces[thispiece].childs.push_back(&amp;lmodel-&gt;pieces[*piecenum]);
-		lmodel-&gt;pieces[*piecenum].parent = &amp;lmodel-&gt;pieces[thispiece];
-		CreateLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
-	}
-
-	POP_CODE_MODE;
-}
-
-
-void CS3OParser::FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces) {
-	int piecenum=0;
-	FixLocalModel(model-&gt;rootobjects3o, lmodel, pieces, &amp;piecenum);
-}
-
-void CS3OParser::FixLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum) {
-	lmodel-&gt;pieces[*piecenum].displist = model-&gt;displist;
-
-	for (unsigned int i=0; i&lt;model-&gt;childs.size(); i++) {
-		(*piecenum)++;
-		FixLocalModel(model-&gt;childs[i], lmodel, pieces, piecenum);
-	}
-}
-
-
-SS3O* CS3OParser::LoadPiece(unsigned char* buf, int offset,S3DOModel* model)
-{
 	model-&gt;numobjects++;
 
-	SS3O* piece=SAFE_NEW SS3O;
+	SS3OPiece* piece = SAFE_NEW SS3OPiece;
+	piece-&gt;type = MODELTYPE_S3O;
 
-	Piece* fp=(Piece*)&amp;buf[offset];
+	Piece* fp = (Piece*)&amp;buf[offset];
 	fp-&gt;swap(); // Does it matter we mess with the original buffer here? Don't hope so.
 
-	piece-&gt;offset.x=fp-&gt;xoffset;
-	piece-&gt;offset.y=fp-&gt;yoffset;
-	piece-&gt;offset.z=fp-&gt;zoffset;
-	piece-&gt;primitiveType=fp-&gt;primitiveType;
-	piece-&gt;name=(char*)&amp;buf[fp-&gt;name];
+	piece-&gt;offset.x = fp-&gt;xoffset;
+	piece-&gt;offset.y = fp-&gt;yoffset;
+	piece-&gt;offset.z = fp-&gt;zoffset;
+	piece-&gt;primitiveType = fp-&gt;primitiveType;
+	piece-&gt;name = (char*)&amp;buf[fp-&gt;name];
 
 	int vertexPointer=fp-&gt;vertices;
 	for(int a=0;a&lt;fp-&gt;numVertices;++a){
@@ -251,30 +101,33 @@
 	}
 	int vertexTablePointer=fp-&gt;vertexTable;
 	for(int a=0;a&lt;fp-&gt;vertexTableSize;++a){
-		int num=swabdword(*(int*)&amp;buf[vertexTablePointer]);
+		int num = swabdword(*(int*)&amp;buf[vertexTablePointer]);
 		piece-&gt;vertexDrawOrder.push_back(num);
-		vertexTablePointer+=sizeof(int);
+		vertexTablePointer += sizeof(int);
 
 		if(num==-1 &amp;&amp; a!=fp-&gt;vertexTableSize-1){		//for triangle strips
 			piece-&gt;vertexDrawOrder.push_back(num);
 
-			num=swabdword(*(int*)&amp;buf[vertexTablePointer]);
+			num = swabdword(*(int*)&amp;buf[vertexTablePointer]);
 			piece-&gt;vertexDrawOrder.push_back(num);
 		}
 	}
-	int childPointer=fp-&gt;childs;
+
+	piece-&gt;isEmpty = false;//piece-&gt;vertexDrawOrder.empty(); 
+	piece-&gt;vertexCount = piece-&gt;vertices.size();
+	int childPointer = fp-&gt;childs;
 	for(int a=0;a&lt;fp-&gt;numChilds;++a){
 		piece-&gt;childs.push_back(LoadPiece(buf,swabdword(*(int*)&amp;buf[childPointer]),model));
-		childPointer+=sizeof(int);
+		childPointer += sizeof(int);
 	}
 	return piece;
 }
 
-void CS3OParser::FindMinMax(SS3O *object)
+void CS3OParser::FindMinMax(SS3OPiece *object)
 {
-	std::vector&lt;SS3O*&gt;::iterator si;
-	for(si=object-&gt;childs.begin();si!=object-&gt;childs.end();++si){
-		FindMinMax(*si);
+	std::vector&lt;S3DModelPiece*&gt;::iterator si;
+	for(si=object-&gt;childs.begin(); si!=object-&gt;childs.end(); ++si){
+		FindMinMax(static_cast&lt;SS3OPiece*&gt;(*si));
 	}
 
 	float maxx=-1000,maxy=-1000,maxz=-1000;
@@ -308,59 +161,34 @@
 	object-&gt;minz=minz;
 }
 
-void CS3OParser::DrawSub(SS3O* o)
+void CS3OParser::Draw(S3DModelPiece *o)
 {
-	if (o-&gt;vertexDrawOrder.empty())
+	if (o-&gt;isEmpty)
 		return;
 
-	glVertexPointer(3,GL_FLOAT,sizeof(SS3OVertex),&amp;o-&gt;vertices[0].pos.x);
-	glTexCoordPointer(2,GL_FLOAT,sizeof(SS3OVertex),&amp;o-&gt;vertices[0].textureX);
-	glNormalPointer(GL_FLOAT,sizeof(SS3OVertex),&amp;o-&gt;vertices[0].normal.x);
+	SS3OPiece* so = static_cast&lt;SS3OPiece*&gt;(o);
+	SS3OVertex* s3ov = static_cast&lt;SS3OVertex*&gt;(&amp;so-&gt;vertices[0]);
+
+	glVertexPointer(3,GL_FLOAT,sizeof(SS3OVertex),&amp;s3ov-&gt;pos.x);
+	glTexCoordPointer(2,GL_FLOAT,sizeof(SS3OVertex),&amp;s3ov-&gt;textureX);
+	glNormalPointer(GL_FLOAT,sizeof(SS3OVertex),&amp;s3ov-&gt;normal.x);
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_NORMAL_ARRAY);
 
-	switch(o-&gt;primitiveType){
+	switch(so-&gt;primitiveType){
 	case 0:
-		glDrawElements(GL_TRIANGLES,o-&gt;vertexDrawOrder.size(),GL_UNSIGNED_INT,&amp;o-&gt;vertexDrawOrder[0]);
+		glDrawElements(GL_TRIANGLES,so-&gt;vertexDrawOrder.size(),GL_UNSIGNED_INT,&amp;so-&gt;vertexDrawOrder[0]);
 		break;
 	case 1:
-		glDrawElements(GL_TRIANGLE_STRIP,o-&gt;vertexDrawOrder.size(),GL_UNSIGNED_INT,&amp;o-&gt;vertexDrawOrder[0]);
+		glDrawElements(GL_TRIANGLE_STRIP,so-&gt;vertexDrawOrder.size(),GL_UNSIGNED_INT,&amp;so-&gt;vertexDrawOrder[0]);
 		break;
 	case 2:
-		glDrawElements(GL_QUADS,o-&gt;vertexDrawOrder.size(),GL_UNSIGNED_INT,&amp;o-&gt;vertexDrawOrder[0]);
+		glDrawElements(GL_QUADS,so-&gt;vertexDrawOrder.size(),GL_UNSIGNED_INT,&amp;so-&gt;vertexDrawOrder[0]);
 		break;
 	}
+
 	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
 	glDisableClientState(GL_VERTEX_ARRAY);
 	glDisableClientState(GL_NORMAL_ARRAY);
-
 }
-
-void CS3OParser::Update() {
-//	GML_STDMUTEX_LOCK(model); // Update
-	for(std::vector&lt;SS3O *&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
-		CreateListsNow(*i);
-	createLists.clear();
-}
-
-void CS3OParser::CreateLists(SS3O *o) {
-//	GML_STDMUTEX_LOCK(model); // CreateLists
-	createLists.push_back(o);
-}
-
-void CS3OParser::CreateListsNow(SS3O *o)
-{
-	o-&gt;displist = glGenLists(1);
-	PUSH_CODE_MODE;
-	ENTER_MIXED;
-	glNewList(o-&gt;displist,GL_COMPILE);
-	DrawSub(o);
-	glEndList();
-	POP_CODE_MODE;
-
-	for(std::vector&lt;SS3O*&gt;::iterator bs=o-&gt;childs.begin();bs!=o-&gt;childs.end();bs++){
-		CreateListsNow(*bs);
-	}
-}
-

Modified: trunk/rts/Rendering/UnitModels/s3oParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/s3oParser.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Rendering/UnitModels/s3oParser.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -4,10 +4,9 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-#include &quot;3DModelParser.h&quot;
 #include &lt;map&gt;
+#include &quot;IModelParser.h&quot;
 
-struct SS3O;
 
 struct SS3OVertex {
 	float3 pos;
@@ -16,45 +15,23 @@
 	float textureY;
 };
 
-struct SS3O {
-	std::string name;
-	std::vector&lt;SS3O*&gt; childs;
+struct SS3OPiece : public S3DModelPiece {
+	const float3&amp; GetVertexPos(const int&amp; idx) const { return vertices[idx].pos; };
+
 	std::vector&lt;SS3OVertex&gt; vertices;
 	std::vector&lt;unsigned int&gt; vertexDrawOrder;
-	float3 offset;
 	int primitiveType;
-	unsigned int displist;
-	bool isEmpty;
-	float maxx,maxy,maxz;
-	float minx,miny,minz;
-
-	void DrawStatic();
-	~SS3O();
 };
 
-class CS3OParser
+class CS3OParser : public IModelParser
 {
 public:
-	CS3OParser();
-	virtual ~CS3OParser();
+	S3DModel* Load(std::string name);
+	void Draw(S3DModelPiece *o);
 
-	S3DOModel* LoadS3O(std::string name, float scale = 1, int side = 1);
-	LocalS3DOModel *CreateLocalModel(S3DOModel *model, std::vector&lt;struct PieceInfo&gt; *pieces);
-	void FixLocalModel(S3DOModel *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces);
-	void Update();
-
 private:
-	SS3O* LoadPiece(unsigned char* buf, int offset,S3DOModel* model);
-	void DeleteSS3O(SS3O* o);
-	void FindMinMax(SS3O *object);
-	void DrawSub(SS3O* o);
-	std::vector&lt;SS3O *&gt; createLists;
-	void CreateLists(SS3O *o);
-	void CreateListsNow(SS3O *o);
-	void CreateLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
-	void FixLocalModel(SS3O *model, LocalS3DOModel *lmodel, std::vector&lt;struct PieceInfo&gt; *pieces, int *piecenum);
-
-	std::map&lt;std::string,S3DOModel*&gt; units;
+	SS3OPiece* LoadPiece(unsigned char* buf, int offset,S3DModel* model);
+	void FindMinMax(SS3OPiece *object);
 };
 
 #endif /* S3OPARSER_H */

Modified: trunk/rts/Sim/Features/Feature.cpp
===================================================================
--- trunk/rts/Sim/Features/Feature.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Features/Feature.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -108,7 +108,7 @@
 {
 	def = featureHandler-&gt;GetFeatureDef(defName);
 	if (def-&gt;drawType == DRAWTYPE_3DO) {
-		model = def-&gt;LoadModel(team);
+		model = LoadModel(def);
 		height = model-&gt;height;
 		SetRadius(model-&gt;radius);
 		midPos = pos + model-&gt;relMidPos;
@@ -136,7 +136,7 @@
 	}
 
 	if (def-&gt;drawType == DRAWTYPE_3DO){
-		model = def-&gt;LoadModel(team);
+		model = LoadModel(def);
 	}
 }
 
@@ -164,9 +164,10 @@
 	noSelect = def-&gt;noSelect;
 
 	if (def-&gt;drawType == DRAWTYPE_3DO) {
-		model = def-&gt;LoadModel(team);
+		model = LoadModel(def);
 		height = model-&gt;height;
 		SetRadius(model-&gt;radius);
+
 		midPos = pos + model-&gt;relMidPos;
 
 		// copy the FeatureDef volume archetype data
@@ -695,5 +696,5 @@
 
 void CFeature::DrawS3O()
 {
-	unitDrawer-&gt;DrawFeatureS3O(this);
+	unitDrawer-&gt;DrawFeatureStatic(this);
 }

Modified: trunk/rts/Sim/Features/Feature.h
===================================================================
--- trunk/rts/Sim/Features/Feature.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Features/Feature.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -2,7 +2,7 @@
 #define __FEATURE_H__
 
 #include &quot;Sim/Objects/SolidObject.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Matrix44f.h&quot;
 #include &lt;vector&gt;
 #include &lt;list&gt;
@@ -53,7 +53,7 @@
 	// should not be here
 	void DrawS3O();
 
-	S3DOModel* model;
+	S3DModel* model;
 
 	std::string createdFromUnit;
 	/** This flag is used to stop a potential exploit involving tripping a unit back and forth

Modified: trunk/rts/Sim/Features/FeatureDef.h
===================================================================
--- trunk/rts/Sim/Features/FeatureDef.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Features/FeatureDef.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -11,7 +11,7 @@
 #define DRAWTYPE_NONE -1
 
 
-struct S3DOModel;
+struct S3DModel;
 struct CollisionVolume;
 
 struct FeatureDef
@@ -20,12 +20,12 @@
 
 	FeatureDef():
 		metal(0), energy(0), maxHealth(0), reclaimTime(0), mass(0),
-		upright(false), drawType(0), modelType(0),
+		upright(false), drawType(0), modelType(0), model(NULL),
 		resurrectable(false), destructable(false), reclaimable(true), blocking(false),
 		burnable(false), floating(false), noSelect(false), geoThermal(false),
 		xsize(0), zsize(0) {}
 
-	S3DOModel* LoadModel(int team) const;
+	S3DModel* LoadModel();
 	CollisionVolume* collisionVolume;
 
 	std::string myName;
@@ -49,7 +49,7 @@
 
 	bool upright;
 	int drawType;
-	/// used by 3do obects
+	S3DModel* model;
 	std::string modelname;
 	/// used by tree etc
 	int modelType;
@@ -79,4 +79,10 @@
 	std::map&lt;std::string, std::string&gt; customParams;
 };
 
+//not very sweet, but still better than replacing &quot;const FeatureDef&quot; _everywhere_
+inline S3DModel* LoadModel(const FeatureDef* fdef)
+{
+	return const_cast&lt;FeatureDef*&gt;(fdef)-&gt;LoadModel();
+}
+
 #endif

Modified: trunk/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Features/FeatureHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -236,6 +236,9 @@
 	fd-&gt;drawType = DRAWTYPE_3DO;
 	fd-&gt;modelname = fdTable.GetString(&quot;object&quot;, &quot;&quot;);
 	if (!fd-&gt;modelname.empty()) {
+		if (fd-&gt;modelname.find(&quot;.&quot;) == std::string::npos) {
+			fd-&gt;modelname += &quot;.3do&quot;;
+		}
 		fd-&gt;modelname=string(&quot;objects3d/&quot;) + fd-&gt;modelname;
 	}
 
@@ -595,11 +598,12 @@
 	GML_RECMUTEX_LOCK(feat); // Draw
 
 	unitDrawer-&gt;SetupForUnitDrawing();
+	unitDrawer-&gt;SetupFor3DO();
 	DrawRaw(0, &amp;drawFar);
+	unitDrawer-&gt;CleanUp3DO();
+	unitDrawer-&gt;DrawQuedS3O();
 	unitDrawer-&gt;CleanUpUnitDrawing();
 
-	unitDrawer-&gt;DrawQuedS3O();
-
 	if (drawFar.size()&gt;0) {
 		CVertexArray* va = GetVertexArray();
 		va-&gt;Initialize();
@@ -627,10 +631,7 @@
 
 	GML_RECMUTEX_LOCK(feat); // DrawShadowPass
 
-	unitDrawer-&gt;SetupForUnitDrawing();
 	DrawRaw(1, NULL);
-	unitDrawer-&gt;CleanUpUnitDrawing();
-
 	unitDrawer-&gt;DrawQuedS3O();
 
 	glDisable(GL_POLYGON_OFFSET_FILL);
@@ -683,8 +684,8 @@
 			float farLength = f-&gt;sqRadius * unitDrawDist * unitDrawDist;
 
 			if (sqDist&lt;farLength) {
-				if (!f-&gt;model-&gt;textureType) {
-					unitDrawer-&gt;DrawFeatureS3O(f);
+				if (f-&gt;model-&gt;type==MODELTYPE_3DO) {
+					unitDrawer-&gt;DrawFeatureStatic(f);
 				} else {
 					unitDrawer-&gt;QueS3ODraw(f, f-&gt;model-&gt;textureType);
 				}
@@ -738,18 +739,9 @@
 }
 
 
-S3DOModel* FeatureDef::LoadModel(int team) const
+S3DModel* FeatureDef::LoadModel()
 {
-	return modelParser-&gt;Load3DModel(modelname.c_str(), 1.0f, team);
-
-	/*
-	if (!useCSOffset) {
-		return modelParser-&gt;Load3DO(modelname.c_str(),
-		                            collisionSphereScale, team);
-	} else {
-		return modelParser-&gt;Load3DO(modelname.c_str(),
-		                            collisionSphereScale, team,
-		                            collisionSphereOffset);
-	}
-	*/
+	if (model==NULL)
+		model = modelParser-&gt;Load3DModel(modelname);
+	return model;
 }

Modified: trunk/rts/Sim/Features/FeatureHandler.h
===================================================================
--- trunk/rts/Sim/Features/FeatureHandler.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Features/FeatureHandler.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -9,7 +9,7 @@
 #include &quot;FeatureDef.h&quot;
 #include &quot;FeatureSet.h&quot;
 
-struct S3DOModel;
+struct S3DModel;
 class CFileHandler;
 class CLoadSaveInterface;
 class CVertexArray;

Modified: trunk/rts/Sim/Misc/AirBaseHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/AirBaseHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Misc/AirBaseHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -76,7 +76,7 @@
 	// FIXME: use a set to avoid multiple bases per piece?
 	for (int p = 0; p &lt; (int)args.size(); p++) {
 		const int piece = args[p];
-		if ((piece &lt; 0) || (piece &gt;= base-&gt;cob-&gt;pieces.size())) {
+		if (!base-&gt;cob-&gt;PieceExists(piece)) {
 			continue;
 		}
 		LandingPad* pad = SAFE_NEW LandingPad(base, piece, ab);

Modified: trunk/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/MoveTypes/AirMoveType.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -8,7 +8,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;myMath.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
 #include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -195,7 +195,7 @@
 
 	if (reservedPad) {
 		CUnit* unit = reservedPad-&gt;GetUnit();
-		float3 relPos = unit-&gt;localmodel-&gt;GetPiecePos(reservedPad-&gt;GetPiece());
+		float3 relPos = unit-&gt;cob-&gt;GetPiecePos(reservedPad-&gt;GetPiece());
 		float3 pos = unit-&gt;pos + (unit-&gt;frontdir * relPos.z) + (unit-&gt;updir * relPos.y) + (unit-&gt;rightdir * relPos.x);
 
 		if (padStatus == 0) {

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -13,7 +13,7 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;MoveMath/MoveMath.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
@@ -265,7 +265,7 @@
 
 			ENTER_UNSYNCED;
 			if (gu-&gt;directControl == owner)
-				camera-&gt;rot.y += deltaHeading * PI / 32768;
+				camera-&gt;rot.y += deltaHeading * TAANG2RAD;
 			ENTER_SYNCED;
 
 			ChangeHeading(owner-&gt;heading + deltaHeading);

Modified: trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -7,7 +7,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;

Modified: trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -5,7 +5,7 @@
 
 #include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
 #include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -777,7 +777,7 @@
 
 			if (reservedPad) {
 				CUnit* unit = reservedPad-&gt;GetUnit();
-				float3 relPos = unit-&gt;localmodel-&gt;GetPiecePos(reservedPad-&gt;GetPiece());
+				float3 relPos = unit-&gt;cob-&gt;GetPiecePos(reservedPad-&gt;GetPiece());
 				float3 pos = unit-&gt;pos + unit-&gt;frontdir * relPos.z
 						+ unit-&gt;updir * relPos.y + unit-&gt;rightdir * relPos.x;
 

Modified: trunk/rts/Sim/Projectiles/PieceProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/PieceProjectile.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/PieceProjectile.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -14,7 +14,7 @@
 #include &quot;ProjectileHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
@@ -58,7 +58,7 @@
 	}
 }
 
-CPieceProjectile::CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalS3DO* piece, int f, CUnit* owner, float radius GML_PARG_C):
+CPieceProjectile::CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalModelPiece* piece, int f, CUnit* owner, float radius GML_PARG_C):
 	CProjectile(pos, speed, owner, true GML_PARG_P),
 	dispList(piece? piece-&gt;displist: 0),
 	drawTrail(true),
@@ -116,12 +116,12 @@
 	   polymorphism can stay put for the moment.
 	   */
 	if (piece) {
-		if (piece-&gt;original3do != NULL) {
-			piece3do = piece-&gt;original3do;
+		if (piece-&gt;type == MODELTYPE_3DO) {
+			piece3do = (S3DOPiece*)piece-&gt;original;
 			pieces3o = NULL;
-		} else if (piece-&gt;originals3o != NULL) {
+		} else if (piece-&gt;type == MODELTYPE_S3O) {
 			piece3do = NULL;
-			pieces3o = piece-&gt;originals3o;
+			pieces3o = (SS3OPiece*)piece-&gt;original;
 		}
 	} else {
 		piece3do = NULL;
@@ -449,19 +449,26 @@
 
 void CPieceProjectile::DrawUnitPart(void)
 {
-	glAlphaFunc(GL_GEQUAL, alphaThreshold);
+	if (alphaThreshold != 0.1f) {
+		glPushAttrib(GL_COLOR_BUFFER_BIT);
+		glAlphaFunc(GL_GEQUAL, alphaThreshold);
+	}
 	glPushMatrix();
 	glTranslatef(pos.x, pos.y, pos.z);
 	glRotatef(spinPos, spinVec.x, spinVec.y, spinVec.z);
 	glCallList(dispList);
 	glPopMatrix();
 
+	if (alphaThreshold != 0.1f) {
+		glPopAttrib();
+	}
+
 	*numCallback = 0;
 }
 
 void CPieceProjectile::DrawS3O(void)
 {
 	// copy of CWeaponProjectile::::DrawS3O()
-	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
+	unitDrawer-&gt;SetTeamColour(colorTeam);
 	DrawUnitPart();
 }

Modified: trunk/rts/Sim/Projectiles/PieceProjectile.h
===================================================================
--- trunk/rts/Sim/Projectiles/PieceProjectile.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/PieceProjectile.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -11,9 +11,9 @@
 const int PP_NoCEGTrail = (1 &lt;&lt; 6); // 64, TODO should be 16
 
 class CSmokeTrailProjectile;
-struct LocalS3DO;
-struct S3DO;
-struct SS3O;
+struct LocalModelPiece;
+struct S3DOPiece;
+struct SS3OPiece;
 
 class CPieceProjectile: public CProjectile
 {
@@ -23,8 +23,8 @@
 
 	int flags;
 	int dispList;
-	S3DO* piece3do;
-	SS3O* pieces3o;
+	S3DOPiece* piece3do;
+	SS3OPiece* pieces3o;
 	float3 spinVec;
 	float spinSpeed;
 	float spinPos;
@@ -46,7 +46,7 @@
 	int colorTeam;
 	
 public:
-	CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalS3DO* piece, int flags, CUnit* owner, float radius GML_PARG_H);
+	CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalModelPiece* piece, int flags, CUnit* owner, float radius GML_PARG_H);
 	virtual ~CPieceProjectile(void);
 	void Update();
 	void Draw();

Modified: trunk/rts/Sim/Projectiles/Projectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/Projectile.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/Projectile.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -11,7 +11,7 @@
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;GlobalUnsynced.h&quot;
 

Modified: trunk/rts/Sim/Projectiles/Projectile.h
===================================================================
--- trunk/rts/Sim/Projectiles/Projectile.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/Projectile.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -16,7 +16,7 @@
 class CUnit;
 class CFeature;
 class CVertexArray;
-struct S3DOModel;
+struct S3DModel;
 
 #define COLLISION_NOFRIENDLY	1
 #define COLLISION_NOFEATURE		2
@@ -61,7 +61,7 @@
 	virtual void DrawUnitPart(void);
 	virtual void DrawS3O() { DrawUnitPart(); }
 
-	S3DOModel* s3domodel;
+	S3DModel* s3domodel;
 };
 
 #endif /* PROJECTILE_H */

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -20,7 +20,8 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
+#include &quot;Rendering/Textures/3DOTextureHandler.h&quot;
+#include &quot;Rendering/Textures/S3OTextureHandler.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
@@ -480,11 +481,66 @@
 
 	/* Putting in, say, viewport culling will deserve refactoring. */
 
-	/* 3DO */
 	unitDrawer-&gt;SetupForUnitDrawing();
-
+	unitDrawer-&gt;SetupFor3DO();
 	GML_RECMUTEX_LOCK(proj); // Draw
 
+	Projectile_List::iterator psi;
+	distlist.clear();
+
+	// Projectiles (3do's get rendered, s3o qued)
+	for (psi = ps.begin(); psi != ps.end(); ++psi) {
+		CProjectile* pro = *psi;
+
+		pro-&gt;UpdateDrawPos();
+
+		if (camera-&gt;InView(pro-&gt;pos, pro-&gt;drawRadius) &amp;&amp; (gu-&gt;spectatingFullView || loshandler-&gt;InLos(pro, gu-&gt;myAllyTeam) ||
+			(pro-&gt;owner &amp;&amp; teamHandler-&gt;Ally(pro-&gt;owner-&gt;allyteam, gu-&gt;myAllyTeam)))) {
+
+			CUnit* owner = pro-&gt;owner;
+			CUnit* trans = owner? (CUnit*) owner-&gt;GetTransporter(): 0;
+			bool stunned = owner? owner-&gt;stunned: false;
+
+			if (owner &amp;&amp; trans &amp;&amp; stunned &amp;&amp; dynamic_cast&lt;CShieldPartProjectile*&gt;(pro)) {
+				// if the unit that fired this projectile is inside a non-firebase
+				// transport (so stunned) and the projectile forms part of a shield
+				// (ie., the unit has a CPlasmaRepulser weapon but cannot fire it),
+				// prevent the projectile (shield segment) from being drawn at the
+				// unit's pre-pickup position (since CPlasmaRepulser::Update() is
+				// responsible for updating CShieldPartProjectile::centerPos)
+				continue;
+			}
+
+
+			if (drawReflection) {
+				if (pro-&gt;pos.y &lt; -pro-&gt;drawRadius)
+					continue;
+
+				float dif = pro-&gt;pos.y - camera-&gt;pos.y;
+				float3 zeroPos = camera-&gt;pos * (pro-&gt;pos.y / dif) + pro-&gt;pos * (-camera-&gt;pos.y / dif);
+
+				if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; 3 + 0.5f * pro-&gt;drawRadius)
+					continue;
+			}
+			if (drawRefraction &amp;&amp; pro-&gt;pos.y &gt; pro-&gt;drawRadius)
+				continue;
+
+			if (pro-&gt;s3domodel) {
+				if (pro-&gt;s3domodel-&gt;textureType) {
+					unitDrawer-&gt;QueS3ODraw(pro, pro-&gt;s3domodel-&gt;textureType);
+				} else {
+					pro-&gt;DrawUnitPart();
+				}
+			}
+
+			struct projdist tmp;
+			tmp.proj = pro;
+			tmp.dist = pro-&gt;pos.dot(camera-&gt;forward);
+			distlist.push_back(tmp);
+		}
+	}
+
+	// 3DO flying pieces
 	va-&gt;Initialize();
 	va-&gt;EnlargeArrays(flying3doPieces-&gt;size()*4,0,VA_SIZE_TN);
 	numFlyingPieces += flying3doPieces-&gt;size();
@@ -492,7 +548,7 @@
 		CMatrix44f m;
 		m.Rotate((*pi)-&gt;rot,(*pi)-&gt;rotAxis);
 		float3 interPos=(*pi)-&gt;pos+(*pi)-&gt;speed*gu-&gt;timeOffset;
-		CTextureHandler::UnitTexture* tex=(*pi)-&gt;prim-&gt;texture;
+		C3DOTextureHandler::UnitTexture* tex=(*pi)-&gt;prim-&gt;texture;
 		const std::vector&lt;S3DOVertex&gt;&amp; vertices    = (*pi)-&gt;object-&gt;vertices;
 		const std::vector&lt;int&gt;&amp;        verticesIdx = (*pi)-&gt;prim-&gt;vertices;
 
@@ -521,22 +577,23 @@
 		va-&gt;AddVertexQTN(tp,tex-&gt;xstart,tex-&gt;yend,tn);
 	}
 	drawnPieces+=va-&gt;drawIndex()/32;
-	va-&gt;DrawArrayTN(GL_QUADS);
 
-	unitDrawer-&gt;CleanUpUnitDrawing();
+	unitDrawer-&gt;CleanUp3DO();
 
-	/* S3O */
-	unitDrawer-&gt;SetupForS3ODrawing();
+	// draw qued S3O projectiles
+	unitDrawer-&gt;DrawQuedS3O();
 
+	// S3O flying pieces
+	va-&gt;DrawArrayTN(GL_QUADS);
 	for (int textureType = 1; textureType &lt; flyings3oPieces.size(); textureType++){
 		/* TODO Skip this if there's no FlyingPieces. */
 
-		texturehandler-&gt;SetS3oTexture(textureType);
+		texturehandlerS3O-&gt;SetS3oTexture(textureType);
 
 		for (int team = 0; team &lt; flyings3oPieces[textureType].size(); team++){
 			FlyingPiece_List * fpl = flyings3oPieces[textureType][team];
 
-			unitDrawer-&gt;SetS3OTeamColour(team);
+			unitDrawer-&gt;SetTeamColour(team);
 
 			va-&gt;Initialize();
 			va-&gt;EnlargeArrays(fpl-&gt;size()*4,0,VA_SIZE_TN);
@@ -563,70 +620,9 @@
 			va-&gt;DrawArrayTN(GL_QUADS);
 		}
 	}
-
-	unitDrawer-&gt;CleanUpS3ODrawing();
-
-	/*
-	 * TODO Nearly cut here.
-	 */
-
-	unitDrawer-&gt;SetupForUnitDrawing();
-	Projectile_List::iterator psi;
-	distlist.clear();
-
-	for (psi = ps.begin(); psi != ps.end(); ++psi) {
-		CProjectile* pro = *psi;
-
-		pro-&gt;UpdateDrawPos();
-
-		if (camera-&gt;InView(pro-&gt;pos, pro-&gt;drawRadius) &amp;&amp; (gu-&gt;spectatingFullView || loshandler-&gt;InLos(pro, gu-&gt;myAllyTeam) ||
-			(pro-&gt;owner &amp;&amp; teamHandler-&gt;Ally(pro-&gt;owner-&gt;allyteam, gu-&gt;myAllyTeam)))) {
-
-			CUnit* owner = pro-&gt;owner;
-			CUnit* trans = owner? (CUnit*) owner-&gt;GetTransporter(): 0;
-			bool stunned = owner? owner-&gt;stunned: false;
-
-			if (owner &amp;&amp; trans &amp;&amp; stunned &amp;&amp; dynamic_cast&lt;CShieldPartProjectile*&gt;(pro)) {
-				// if the unit that fired this projectile is inside a non-firebase
-				// transport (so stunned) and the projectile forms part of a shield
-				// (ie., the unit has a CPlasmaRepulser weapon but cannot fire it),
-				// prevent the projectile (shield segment) from being drawn at the
-				// unit's pre-pickup position (since CPlasmaRepulser::Update() is
-				// responsible for updating CShieldPartProjectile::centerPos)
-				continue;
-			}
-
-
-			if (drawReflection) {
-				if (pro-&gt;pos.y &lt; -pro-&gt;drawRadius)
-					continue;
-
-				float dif = pro-&gt;pos.y - camera-&gt;pos.y;
-				float3 zeroPos = camera-&gt;pos * (pro-&gt;pos.y / dif) + pro-&gt;pos * (-camera-&gt;pos.y / dif);
-
-				if (ground-&gt;GetApproximateHeight(zeroPos.x, zeroPos.z) &gt; 3 + 0.5f * pro-&gt;drawRadius)
-					continue;
-			}
-			if (drawRefraction &amp;&amp; pro-&gt;pos.y &gt; pro-&gt;drawRadius)
-				continue;
-
-			if (pro-&gt;s3domodel) {
-				if (pro-&gt;s3domodel-&gt;textureType) {
-					unitDrawer-&gt;QueS3ODraw(pro, pro-&gt;s3domodel-&gt;textureType);
-				} else {
-					pro-&gt;DrawUnitPart();
-				}
-			}
-
-			struct projdist tmp;
-			tmp.proj = pro;
-			tmp.dist = pro-&gt;pos.dot(camera-&gt;forward);
-			distlist.push_back(tmp);
-		}
-	}
 	unitDrawer-&gt;CleanUpUnitDrawing();
-	unitDrawer-&gt;DrawQuedS3O();
 
+	// Alpha transculent particles
 	sort(distlist.begin(), distlist.end(), CompareProjDist);
 
 	glEnable(GL_BLEND);
@@ -853,6 +849,8 @@
 	groundFXAtlas-&gt;BindTexture();
 	glEnable(GL_TEXTURE_2D);
 	glDepthMask(0);
+	glEnable(GL_ALPHA_TEST);
+	glAlphaFunc(GL_GREATER, 0.01f);
 	glPolygonOffset(-20,-1000);
 	glEnable(GL_POLYGON_OFFSET_FILL);
 	glFogfv(GL_FOG_COLOR, black);
@@ -876,8 +874,8 @@
 	CGroundFlash::va-&gt;DrawArrayTC(GL_QUADS);
 
 	glFogfv(GL_FOG_COLOR,mapInfo-&gt;atmosphere.fogColor);
-	glDepthMask(1);
 	glDisable(GL_POLYGON_OFFSET_FILL);
+	glDisable(GL_ALPHA_TEST);
 	glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
 	glDisable(GL_BLEND);
 }
@@ -896,7 +894,7 @@
 }
 
 
-void CProjectileHandler::AddFlyingPiece(float3 pos,float3 speed,S3DO* object,S3DOPrimitive* piece)
+void CProjectileHandler::AddFlyingPiece(float3 pos,float3 speed,S3DOPiece* object,S3DOPrimitive* piece)
 {
 	FlyingPiece* fp=new FlyingPiece;
 	fp-&gt;pos=pos;

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.h
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -7,7 +7,7 @@
 class CProjectileHandler;
 class CProjectile;
 struct S3DOPrimitive;
-struct S3DO;
+struct S3DOPiece;
 struct SS3OVertex;
 #include &lt;list&gt;
 #include &lt;vector&gt;
@@ -20,6 +20,7 @@
 #include &quot;float3.h&quot;
 
 
+
 class CGroundFlash;
 
 
@@ -51,15 +52,15 @@
 	void SetMaxParticles(int value);
 
 	void Draw(bool drawReflection, bool drawRefraction = false);
+	void DrawShadowPass(void);
+	void DrawGroundFlashes(void);
+	void Update();
 	void UpdateTextures();
 	void AddProjectile(CProjectile* p);
-	void Update();
 	void AddGroundFlash(CGroundFlash* flash);
-	void DrawGroundFlashes(void);
 
 	void ConvertTex(unsigned char tex[512][512][4], int startx, int starty, int endx, int endy, float absorb);
-	void DrawShadowPass(void);
-	void AddFlyingPiece(float3 pos, float3 speed, S3DO* object, S3DOPrimitive* piece);
+	void AddFlyingPiece(float3 pos, float3 speed, S3DOPiece* object, S3DOPrimitive* piece);
 	void AddFlyingPiece(int textureType, int team, float3 pos, float3 speed, SS3OVertex* verts);
 
 	struct projdist {
@@ -133,7 +134,7 @@
 #endif
 
 		S3DOPrimitive* prim;
-		S3DO* object;
+		S3DOPiece* object;
 
 		SS3OVertex* verts; /* SS3OVertex[4], our deletion. */
 

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -12,13 +12,13 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
-#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
 #include &quot;Sim/Projectiles/Unsynced/SmokeTrailProjectile.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;GlobalUnsynced.h&quot;
@@ -89,10 +89,10 @@
 
 	SetRadius(0.0f);
 
-	if ((weaponDef) &amp;&amp; (!weaponDef-&gt;visuals.modelName.empty())) {
-		S3DOModel* model = modelParser-&gt;Load3DModel(string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
-		if (model) {
-			SetRadius(model-&gt;radius);
+	if (weaponDef) {
+		s3domodel = LoadModel(weaponDef);
+		if (s3domodel) {
+			SetRadius(s3domodel-&gt;radius);
 		}
 	}
 
@@ -448,7 +448,7 @@
 	CMatrix44f transMatrix(drawPos + dir * radius * 0.9f,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
-	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
+	glCallList(s3domodel-&gt;rootobject-&gt;displist); // dont cache displists because of delayed loading (GML)
 
 	glPopMatrix();
 }
@@ -480,6 +480,6 @@
 
 void CMissileProjectile::DrawS3O(void)
 {
-	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
+	unitDrawer-&gt;SetTeamColour(colorTeam);
 	DrawUnitPart();
 }

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -408,7 +408,7 @@
 	CMatrix44f transMatrix(drawPos,-rightdir,updir,dir);
 	glMultMatrixf(&amp;transMatrix[0]);
 
-	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
+	glCallList(s3domodel-&gt;rootobject-&gt;displist); // dont cache displists because of delayed loading
 	glPopMatrix();
 }
 

Modified: trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -4,11 +4,10 @@
 #include &quot;WeaponProjectile.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sound.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Map/Ground.h&quot;
@@ -98,12 +97,8 @@
 
 		alwaysVisible = weaponDef-&gt;visuals.alwaysVisible;
 
-		if (!weaponDef-&gt;visuals.modelName.empty()) {
-			S3DOModel* model = modelParser-&gt;Load3DModel(string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
-			if (model) {
-				s3domodel = model;
-			}
-		}
+		s3domodel = LoadModel(weaponDef);
+
 		collisionFlags = weaponDef-&gt;collisionFlags;
 	}
 }
@@ -292,14 +287,13 @@
 	CMatrix44f transMatrix(drawPos,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
-//	glCallList(modelDispList);
-	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
+	glCallList(s3domodel-&gt;rootobject-&gt;displist); // dont cache displists because of delayed loading
 	glPopMatrix();
 }
 
 void CWeaponProjectile::DrawS3O(void)
 {
-	unitDrawer-&gt;SetS3OTeamColour(colorTeam);
+	unitDrawer-&gt;SetTeamColour(colorTeam);
 	DrawUnitPart();
 }
 
@@ -323,16 +317,17 @@
 //	if(weaponDef-&gt;interceptedByShieldType)
 //		interceptHandler.AddShieldInterceptableProjectile(this);
 
-	if(!weaponDef-&gt;visuals.modelName.empty()){
-		S3DOModel* model = modelParser-&gt;Load3DModel(
-				string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName, 1, colorTeam);
-		if(model){
-			s3domodel = model;
-/*			if(s3domodel-&gt;rootobject3do)
-				modelDispList= model-&gt;rootobject3do-&gt;displist;
-			else
-				modelDispList= model-&gt;rootobjects3o-&gt;displist;*/
+	if (!weaponDef-&gt;visuals.modelName.empty()) {
+		if (weaponDef-&gt;visuals.model==NULL) {
+			std::string modelname = string(&quot;objects3d/&quot;) + weaponDef-&gt;visuals.modelName;
+			if (modelname.find(&quot;.&quot;) == std::string::npos) {
+				modelname += &quot;.3do&quot;;
+			}
+			const_cast&lt;WeaponDef*&gt;(weaponDef)-&gt;visuals.model = modelParser-&gt;Load3DModel(modelname);
 		}
+		if (weaponDef-&gt;visuals.model) {
+			s3domodel = weaponDef-&gt;visuals.model;
+		}
 	}
 
 //	collisionFlags = weaponDef-&gt;collisionFlags;

Modified: trunk/rts/Sim/Units/COB/CobFile.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobFile.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/COB/CobFile.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -102,6 +102,13 @@
 	COBHeader ch;
 	READ_COBHEADER(ch,cobdata);
 
+	// prepare
+	luaScripts.reserve(ch.NumberOfScripts);
+	scriptNames.reserve(ch.NumberOfScripts);
+	scriptOffsets.reserve(ch.NumberOfScripts);
+	scriptLengths.reserve(ch.NumberOfScripts);
+	pieceNames.reserve(ch.NumberOfPieces);
+
 	for (int i = 0; i &lt; ch.NumberOfScripts; ++i) {
 		int ofs;
 		
@@ -126,6 +133,7 @@
 	}
 	scriptLengths.push_back(ch.TotalScriptLen - scriptOffsets[ch.NumberOfScripts - 1]);
 
+
 	for (int i = 0; i &lt; ch.NumberOfPieces; ++i) {
 		int ofs;
 
@@ -147,6 +155,7 @@
 
 	// If this is a TA:K script, read the sound names
 	if (ch.VersionSignature == 6) {
+		sounds.reserve(ch.NumberOfSounds);
 		for (int i = 0; i &lt; ch.NumberOfSounds; ++i) {
 			int ofs;
 			ofs = *(int *)&amp;cobdata[ch.OffsetToSoundNameArray + i * 4];

Modified: trunk/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobInstance.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/COB/CobInstance.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -41,6 +41,7 @@
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;GlobalUnsynced.h&quot;
 #include &quot;Sound.h&quot;
+#include &quot;myMath.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
 
 #endif
@@ -110,7 +111,7 @@
 #define CHANGE_TARGET             98 // set, the value it's set to determines the affected weapon
 #define CEG_DAMAGE                99 // set
 #define COB_ID                   100 // get
-#define PLAY_SOUND				 101 // get, so multiple args can be passed
+#define PLAY_SOUND               101 // get, so multiple args can be passed
 #define KILL_UNIT                102 // get KILL_UNIT(unitId, SelfDestruct=true, Reclaimed=false)
 #define ALPHA_THRESHOLD          103 // set or get
 #define SET_WEAPON_UNIT_TARGET   106 // get (fake set)
@@ -143,31 +144,17 @@
 
 
 CCobInstance::CCobInstance(CCobFile&amp; _script, CUnit* _unit)
-: script(_script)
+: script(_script), unit(_unit)
 {
+	staticVars.reserve(script.numStaticVars);
 	for (int i = 0; i &lt; script.numStaticVars; ++i) {
 		staticVars.push_back(0);
 	}
-	for (unsigned int i = 0; i &lt; script.pieceNames.size(); ++i) {
-		struct PieceInfo pi;
 
-		//init from model?
-		pi.coords[0] = 0; pi.coords[1] = 0; pi.coords[2] = 0;
-		pi.rot[0] = 0; pi.rot[1] = 0; pi.rot[2] = 0;
-		pi.name = script.pieceNames[i];
-		pi.updated = false;
-		pi.visible = true;
+	memset(unitVars,int(0),UNIT_VAR_COUNT);
 
-		pieces.push_back(pi);
-	}
+	MapScriptToModelPieces(unit-&gt;localmodel);
 
-	for (int i = 0; i &lt; UNIT_VAR_COUNT; i++) {
-		unitVars[i] = 0;
-	}
-
-	unit = _unit;
-//	int mo = unit-&gt;pos.x;
-
 	yardOpen = false;
 	busy = false;
 	smoothAnim = unit-&gt;unitDef-&gt;smoothAnim;
@@ -187,7 +174,6 @@
 	GCobEngine.RemoveInstance(this);
 
 	for (std::list&lt;struct AnimInfo *&gt;::iterator i = anims.begin(); i != anims.end(); ++i) {
-
 		//All threads blocking on animations can be killed safely from here since the scheduler does not
 		//know about them
 		for (std::list&lt;CCobThread *&gt;::iterator j = (*i)-&gt;listeners.begin(); j != (*i)-&gt;listeners.end(); ++j) {
@@ -196,6 +182,55 @@
 		delete *i;
 	}
 }
+
+
+
+void CCobInstance::MapScriptToModelPieces(LocalModel* lmodel)
+{
+	pieces.clear();
+	pieces.reserve(script.pieceNames.size());
+
+	for (int piecenum=0; piecenum&lt;script.pieceNames.size(); piecenum++) {
+		std::string&amp; scriptname = script.pieceNames[piecenum];
+
+		unsigned int cur;
+
+		//Map this piecename to an index in the script's pieceinfo
+		for (cur=0; cur&lt;lmodel-&gt;pieces.size(); cur++) {
+			if (lmodel-&gt;pieces[cur]-&gt;name.compare(scriptname) == 0) {
+				break;
+			}
+		}
+
+		//Not found? Try again with partial matching
+		if (cur == lmodel-&gt;pieces.size()) {
+			for (cur = 0; cur &lt; lmodel-&gt;pieces.size(); ++cur) {
+				std::string &amp;s2 = lmodel-&gt;pieces[cur]-&gt;name;
+				int maxcompare = std::min(scriptname.size(), s2.size());
+				int j;
+				for (j = 0; j &lt; maxcompare; ++j) {
+					if (scriptname[j] != s2[j]) {
+						break;
+					}
+				}
+				//Match now?
+				if (j == maxcompare) {
+					break;
+				}
+			}
+		}
+
+		//Did we find it now?
+		if (cur &lt; lmodel-&gt;pieces.size()) {
+			pieces.push_back(lmodel-&gt;pieces[cur]);
+		} else {
+			pieces.push_back(NULL);
+			GCobEngine.ShowScriptError(&quot;Couldn't find a piece named \&quot;&quot;+scriptname+&quot;\&quot; in the model&quot;);
+		}
+	}
+}
+
+
 int CCobInstance::Call(const string &amp;fname)
 {
 	std::vector&lt;int&gt; x;
@@ -289,8 +324,17 @@
 }
 
 
-//Returns 0 if the call terminated. If the caller provides a callback and the thread does not terminate,
-//it will continue to run. Otherwise it will be killed. Returns 1 in this case.
+
+/**
+ * @brief Calls a cob script function
+ * @param functionId int cob script function id
+ * @param args vector&lt;int&gt; function arguments
+ * @param cb CBCobThreadFinish Callback function
+ * @param p1 void* callback argument #1
+ * @param p2 void* callback argument #2 
+ * @return 0 if the call terminated. If the caller provides a callback and the thread does not terminate,
+ *  it will continue to run. Otherwise it will be killed. Returns 1 in this case.
+ */
 int CCobInstance::RealCall(int functionId, vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2)
 {
 	CCobThread *t = SAFE_NEW CCobThread(script, this);
@@ -326,82 +370,97 @@
 }
 
 
-//Updates cur, returns 1 if destination was reached, 0 otherwise
-int CCobInstance::MoveToward(int &amp;cur, int dest, int speed)
+/**
+ * @brief Updates move animations
+ * @param cur float value to update
+ * @param dest float final value
+ * @param speed float max increment per tick
+ * @return returns 1 if destination was reached, 0 otherwise
+ */
+int CCobInstance::MoveToward(float &amp;cur, float dest, float speed)
 {
-	if (dest &gt; cur) {
+	const float delta = dest - cur;
+
+	if (abs(delta) &lt;= speed) {
+		cur = dest;
+		return 1;
+	}
+
+	if (delta&gt;0.0f) {
 		cur += speed;
-		if (cur &gt; dest) {
-			cur = dest;
-			return 1;
-		}
-	}
-	else {
+	} else {
 		cur -= speed;
-		if (cur &lt; dest) {
-			cur = dest;
-			return 1;
-		}
 	}
 
 	return 0;
 }
 
-//Updates cur, returns 1 if destination was reached, 0 otherwise
-int CCobInstance::TurnToward(int &amp;cur, int dest, int speed)
+
+/**
+ * @brief Updates turn animations
+ * @param cur float value to update
+ * @param dest float final value
+ * @param speed float max increment per tick
+ * @return returns 1 if destination was reached, 0 otherwise
+ */
+int CCobInstance::TurnToward(float &amp;cur, float dest, float speed)
 {
-	short int delta = dest - cur;
-	if (delta &gt; 0) {
-		if (delta &lt;= speed) {
-			cur = dest;
-			return 1;
-		}
+	ClampRad(&amp;cur);
+
+	float delta = dest - cur;
+
+	// clamp: -pi .. 0 .. +pi (remainder(x,TWOPI) would do the same but is slower due to streflop)
+	if (delta&gt;PI) {
+		delta -= TWOPI;
+	} else if (delta&lt;=-PI) {
+		delta += TWOPI;
+	}
+
+	if (fabs(delta) &lt;= speed) {
+		cur = dest;
+		return 1;
+	}
+
+	if (delta&gt;0.0f) {
 		cur += speed;
-	}
-	else {
-		if (delta &gt;= -speed) {
-			cur = dest;
-			return 1;
-		}
+	} else {
 		cur -= speed;
 	}
-	cur %= 65536;
 
-	//logOutput.Print(&quot;turning %d %d %d&quot;, cur, dest, speed);
-
 	return 0;
 }
 
-//Dest is not the final angle (obviously) but the final desired speed
-//Returns 1 if the desired speed is 0 and it is reached, otherwise 0
-//Speed is updated if it is not equal to dest
-//Divisor is the deltatime, it is not added before the call because speed may have to be updated
-int CCobInstance::DoSpin(int &amp;cur, int dest, int &amp;speed, int accel, int divisor)
+
+/**
+ * @brief Updates spin animations
+ * @param cur float value to update
+ * @param dest float the final desired speed (NOT the final angle!)
+ * @param speed float is updated if it is not equal to dest
+ * @param divisor int is the deltatime, it is not added before the call because speed may have to be updated
+ * @return 1 if the desired speed is 0 and it is reached, otherwise 0
+ */
+int CCobInstance::DoSpin(float &amp;cur, float dest, float &amp;speed, float accel, int divisor)
 {
 	//Check if we are not at the final speed
 	if (speed != dest) {
-		speed += accel * 30 / divisor;		//TA obviously defines accelerations in speed/frame (at 30 fps)
-		if (accel &gt; 0) {
-			if (speed &gt; dest)
-				speed = dest;		//We are accelerating, make sure we dont go past desired speed
-		}
-		else {
-			if (speed &lt; dest)
-				speed = dest;		//Decelerating
-			if (speed == 0)
-				return 1;
-		}
+		speed += accel * (30.0f / divisor);   //TA obviously defines accelerations in speed/frame (at 30 fps)
+		if (fabs(speed) &gt; dest)      // make sure we dont go past desired speed
+			speed = dest;
+		if ((accel &lt; 0.0f) &amp;&amp; (speed == 0.0f))
+			return 1;
 	}
 
-	//logOutput.Print(&quot;Spinning with %d %d %d %d&quot;, dest, speed, accel, divisor);
+	cur += (speed / divisor);
+	ClampRad(&amp;cur);
 
-	cur += speed / divisor;
-	cur %= 65536;
-
 	return 0;
 }
 
-// Unblocks all threads waiting on this animation
+
+/**
+ * @brief Unblocks all threads waiting on an animation
+ * @param anim AnimInfo the corresponding animation
+ */
 void CCobInstance::UnblockAll(struct AnimInfo * anim)
 {
 	std::list&lt;CCobThread *&gt;::iterator li;
@@ -421,8 +480,13 @@
 	}
 }
 
-//Called by the engine when we are registered as animating. If we return -1 it means that
-//there is no longer anything animating
+
+/**
+ * @brief Called by the engine when we are registered as animating. If we return -1 it means that
+ *        there is no longer anything animating
+ * @param deltaTime int delta time to update
+ * @return 0 if there are still animations going, -1 else
+ */
 int CCobInstance::Tick(int deltaTime)
 {
 	int done;
@@ -434,17 +498,17 @@
 		cur = it++;
 
 		done = false;
-		pieces[(*cur)-&gt;piece].updated = true;
+		pieces[(*cur)-&gt;piece]-&gt;updated = true;
 
 		switch ((*cur)-&gt;type) {
 			case AMove:
-				done = MoveToward(pieces[(*cur)-&gt;piece].coords[(*cur)-&gt;axis], (*cur)-&gt;dest, (*cur)-&gt;speed / (1000 / deltaTime));
+				done = MoveToward(pieces[(*cur)-&gt;piece]-&gt;pos[(*cur)-&gt;axis], (*cur)-&gt;dest, (*cur)-&gt;speed / (1000 / deltaTime));
 				break;
 			case ATurn:
-				done = TurnToward(pieces[(*cur)-&gt;piece].rot[(*cur)-&gt;axis], (*cur)-&gt;dest, (*cur)-&gt;speed / (1000 / deltaTime));
+				done = TurnToward(pieces[(*cur)-&gt;piece]-&gt;rot[(*cur)-&gt;axis], (*cur)-&gt;dest, (*cur)-&gt;speed / (1000 / deltaTime));
 				break;
 			case ASpin:
-				done = DoSpin(pieces[(*cur)-&gt;piece].rot[(*cur)-&gt;axis], (*cur)-&gt;dest, (*cur)-&gt;speed, (*cur)-&gt;accel, 1000 / deltaTime);
+				done = DoSpin(pieces[(*cur)-&gt;piece]-&gt;rot[(*cur)-&gt;axis], (*cur)-&gt;dest, (*cur)-&gt;speed, (*cur)-&gt;accel, 1000 / deltaTime);
 				break;
 		}
 
@@ -474,6 +538,7 @@
 	return NULL;
 }
 
+//Optimize this?
 // Returns true if an animation was found and deleted
 void CCobInstance::RemoveAnim(AnimType type, int piece, int axis)
 {
@@ -500,17 +565,49 @@
 //Other option would be to kill them. Or perhaps unblock them.
 void CCobInstance::AddAnim(AnimType type, int piece, int axis, int speed, int dest, int accel, bool interpolated)
 {
+	if (!PieceExists(piece)) {
+		GCobEngine.ShowScriptError(&quot;Invalid piecenumber&quot;);
+		return;
+	}
+
+	// translate cob piece coords into worldcoordinates
+	float destf;
+	float speedf;
+	float accelf;
+	if (type == AMove) {
+		destf  = pieces[piece]-&gt;original-&gt;offset[axis];
+		if (axis==0) {
+			destf -= dest * CORDDIV;
+		} else {
+			destf += dest * CORDDIV;
+		}
+		speedf = speed * CORDDIV;
+		accelf = accel;
+	} else {
+		destf  = dest  * TAANG2RAD;
+		speedf = speed * TAANG2RAD;
+		accelf = accel * TAANG2RAD;
+		ClampRad(&amp;destf);
+	}
+
 	struct AnimInfo *ai;
 
 	//Turns override spins.. Not sure about the other way around? If so the system should probably be redesigned
 	//to only have two types of anims.. turns and moves, with spin as a bool
-	if (type == ATurn)
-		RemoveAnim(ASpin, piece, axis);
-	if (type == ASpin)
-		RemoveAnim(ATurn, piece, axis);
+	if (type != AMove)
+		RemoveAnim(type, piece, axis); //todo: optimize, atm RemoveAnim and FindAnim search twice through all anims
 
 	ai = FindAnim(type, piece, axis);
 	if (!ai) {
+		//check if the animation is needed
+		if (type == AMove) {
+			if (pieces[piece]-&gt;pos[axis] == destf)
+				return; // no animation needed, the piece is already at the wanted pos
+		} else if (type == ATurn) {
+			if (RadsAreEqual(pieces[piece]-&gt;rot[axis],destf))
+				return; // no animation needed, the piece already points in the wanted angle
+		}
+
 		ai = SAFE_NEW struct AnimInfo;
 		ai-&gt;type = type;
 		ai-&gt;piece = piece;
@@ -521,15 +618,11 @@
 		if (anims.size() == 1) {
 			GCobEngine.AddInstance(this);
 		}
+	}
 
-		// Check to make sure the piece exists
-		if (piece &gt;= pieces.size()) {
-			logOutput.Print(&quot;Invalid piece in anim %d (%d)&quot;, piece, pieces.size());
-		}
-	}
-	ai-&gt;speed = speed;
-	ai-&gt;dest = dest;
-	ai-&gt;accel = accel;
+	ai-&gt;dest  = destf;
+	ai-&gt;speed = speedf;
+	ai-&gt;accel = accelf;
 	ai-&gt;interpolated = interpolated;
 }
 
@@ -542,16 +635,16 @@
 
 	//If we are already spinning, we may have to decelerate to the new speed
 	if (ai) {
-		ai-&gt;dest = speed;
+		ai-&gt;dest = speed * TAANG2RAD;
 		if (accel &gt; 0) {
 			if (ai-&gt;speed &gt; ai-&gt;dest)
-				ai-&gt;accel = -accel;
+				ai-&gt;accel = -accel * TAANG2RAD;
 			else
-				ai-&gt;accel = accel;
+				ai-&gt;accel = accel * TAANG2RAD;
 		}
 		else {
 			//Go there instantly. Or have a defaul accel?
-			ai-&gt;speed = speed;
+			ai-&gt;speed = speed * TAANG2RAD;
 			ai-&gt;accel = 0;
 		}
 	}
@@ -580,7 +673,7 @@
 
 void CCobInstance::Turn(int piece, int axis, int speed, int destination, bool interpolated)
 {
-	AddAnim(ATurn, piece, axis, speed, destination % 65536, 0, interpolated);
+	AddAnim(ATurn, piece, axis, speed, destination, 0, interpolated);
 }
 
 void CCobInstance::Move(int piece, int axis, int speed, int destination, bool interpolated)
@@ -590,28 +683,51 @@
 
 void CCobInstance::MoveNow(int piece, int axis, int destination)
 {
-	pieces[piece].coords[axis] = destination;
-	pieces[piece].updated = true;
+	if (!PieceExists(piece)) {
+		GCobEngine.ShowScriptError(&quot;Invalid piecenumber&quot;);
+		return;
+	}
+
+	LocalModelPiece* p = pieces[piece];
+	p-&gt;pos[axis] = pieces[piece]-&gt;original-&gt;offset[axis];
+	if (axis==0) {
+		p-&gt;pos[axis] -= destination * CORDDIV;
+	} else {
+		p-&gt;pos[axis] += destination * CORDDIV;
+	}
+	p-&gt;updated = true;
 }
 
 void CCobInstance::TurnNow(int piece, int axis, int destination)
 {
-	pieces[piece].rot[axis] = destination;
-	pieces[piece].updated = true;
+	if (!PieceExists(piece)) {
+		GCobEngine.ShowScriptError(&quot;Invalid piecenumber&quot;);
+		return;
+	}
+
+	LocalModelPiece* p = pieces[piece];
+	p-&gt;rot[axis] = destination * TAANG2RAD;
+	p-&gt;updated = true;
 	//logOutput.Print(&quot;moving %s on axis %d to %d&quot;, script.pieceNames[piece].c_str(), axis, destination);
 }
 
 void CCobInstance::SetVisibility(int piece, bool visible)
 {
-	if (pieces[piece].visible != visible) {
-		pieces[piece].visible = visible;
-		pieces[piece].updated = true;
+	if (!PieceExists(piece)) {
+		GCobEngine.ShowScriptError(&quot;Invalid piecenumber&quot;);
+		return;
 	}
+
+	LocalModelPiece* p = pieces[piece];
+	if (p-&gt;visible != visible) {
+		p-&gt;visible = visible;
+		p-&gt;updated = true;
+	}
 }
 
 void CCobInstance::EmitSfx(int type, int piece)
 {
-	if (!unit-&gt;localmodel-&gt;PieceExists(piece)) {
+	if (!PieceExists(piece)) {
 		GCobEngine.ShowScriptError(&quot;Invalid piecenumber for emit-sfx&quot;);
 		return;
 	}
@@ -625,9 +741,7 @@
 
 	float3 relPos;
 	float3 relDir(0,1,0);
-	unit-&gt;localmodel-&gt;GetEmitDirPos(piece, relPos, relDir);
-	//relPos = unit-&gt;localmodel-&gt;GetPiecePos(piece);
-//float3 relPos = unit-&gt;localmodel-&gt;GetPiecePos(piece);
+	GetEmitDirPos(piece, relPos, relDir);
 
 	float3 pos = unit-&gt;pos + unit-&gt;frontdir * relPos.z + unit-&gt;updir * relPos.y + unit-&gt;rightdir * relPos.x;
 
@@ -653,14 +767,14 @@
 	switch (type) {
 		case 4:
 		case 5:		{	//reverse wake
-			//float3 relDir = -unit-&gt;localmodel-&gt;GetPieceDirection(piece) * 0.2f;
+			//float3 relDir = -GetPieceDirection(piece) * 0.2f;
 			relDir *= 0.2f;
 			float3 dir = unit-&gt;frontdir * relDir.z + unit-&gt;updir * relDir.y + unit-&gt;rightdir * relDir.x;
 			SAFE_NEW CWakeProjectile(pos+gu-&gt;usRandVector()*2,dir*0.4f,6+gu-&gt;usRandFloat()*4,0.15f+gu-&gt;usRandFloat()*0.3f,unit, alpha, alphaFalloff,fadeupTime);
 			break;}
 		case 3:			//wake 2, in TA it lives longer..
 		case 2:		{	//regular ship wake
-			//float3 relDir = unit-&gt;localmodel-&gt;GetPieceDirection(piece) * 0.2f;
+			//float3 relDir = GetPieceDirection(piece) * 0.2f;
 			relDir *= 0.2f;
 			float3 dir = unit-&gt;frontdir * relDir.z + unit-&gt;updir * relDir.y + unit-&gt;rightdir * relDir.x;
 			SAFE_NEW CWakeProjectile(pos+gu-&gt;usRandVector()*2,dir*0.4f,6+gu-&gt;usRandFloat()*4,0.15f+gu-&gt;usRandFloat()*0.3f,unit, alpha, alphaFalloff,fadeupTime);
@@ -677,7 +791,7 @@
 			SAFE_NEW CSmokeProjectile(pos,gu-&gt;usRandVector()*0.5f+UpVector*1.1f,60,4,0.5f,unit,0.6f);
 			break;
 		case 0:{		//vtol
-			//relDir = unit-&gt;localmodel-&gt;GetPieceDirection(piece) * 0.2f;
+			//relDir = GetPieceDirection(piece) * 0.2f;
 			relDir *= 0.2f;
 			float3 dir = unit-&gt;frontdir * relDir.z + unit-&gt;updir * -fabs(relDir.y) + unit-&gt;rightdir * relDir.x;
 			CHeatCloudProjectile* hc=SAFE_NEW CHeatCloudProjectile(pos, unit-&gt;speed*0.7f+dir * 0.5f, 10 + gu-&gt;usRandFloat() * 5, 3 + gu-&gt;usRandFloat() * 2, unit);
@@ -692,7 +806,7 @@
 					GCobEngine.ShowScriptError(&quot;Invalid explosion generator index for emit-sfx&quot;);
 					break;
 				}
-				//float3 relDir = -unit-&gt;localmodel-&gt;GetPieceDirection(piece) * 0.2f;
+				//float3 relDir = -GetPieceDirection(piece) * 0.2f;
 				float3 dir = unit-&gt;frontdir * relDir.z + unit-&gt;updir * relDir.y + unit-&gt;rightdir * relDir.x;
 				dir.Normalize();
 				unit-&gt;unitDef-&gt;sfxExplGens[index]-&gt;Explosion(pos, unit-&gt;cegDamage, 1, unit, 0, 0, dir);
@@ -705,7 +819,7 @@
 					break;
 				}
 				//this is very hackish and probably has a lot of side effects, but might be usefull for something
-				//float3 relDir =-unit-&gt;localmodel-&gt;GetPieceDirection(piece);
+				//float3 relDir =-GetPieceDirection(piece);
 				float3 dir = unit-&gt;frontdir * relDir.z + unit-&gt;updir * relDir.y + unit-&gt;rightdir * relDir.x;
 				dir.Normalize();
 
@@ -749,7 +863,7 @@
 void CCobInstance::AttachUnit(int piece, int u)
 {
 	// -1 is valid, indicates that the unit should be hidden
-	if ((piece &gt;= 0) &amp;&amp; (!unit-&gt;localmodel-&gt;PieceExists(piece))) {
+	if ((piece &gt;= 0) &amp;&amp; (!PieceExists(piece))) {
 		GCobEngine.ShowScriptError(&quot;Invalid piecenumber for attach&quot;);
 		return;
 	}
@@ -812,14 +926,13 @@
 //Flags as defined by the cob standard
 void CCobInstance::Explode(int piece, int flags)
 {
-	if (!unit-&gt;localmodel-&gt;PieceExists(piece)) {
+	if (!PieceExists(piece)) {
 		GCobEngine.ShowScriptError(&quot;Invalid piecenumber for explode&quot;);
 		return;
 	}
 
-
 #ifndef _CONSOLE
-	float3 pos = unit-&gt;localmodel-&gt;GetPiecePos(piece) + unit-&gt;pos;
+	float3 pos = GetPiecePos(piece) + unit-&gt;pos;
 
 #ifdef TRACE_SYNC
 	tracefile &lt;&lt; &quot;Cob explosion: &quot;;
@@ -867,28 +980,29 @@
 
 	/* TODO Push this back. Don't forget to pass the team (color).  */
 
-	LocalS3DO * pieceData = &amp;( unit-&gt;localmodel-&gt;pieces[unit-&gt;localmodel-&gt;scritoa[piece]] );
+	LocalModelPiece* pieceData = pieces[piece]; //&amp;( unit-&gt;localmodel-&gt;pieces[unit-&gt;localmodel-&gt;scritoa[piece]] );
 	if (flags &amp; 1) {		//Shatter
 		ENTER_MIXED;
 
 		float pieceChance=1-(ph-&gt;currentParticles-(ph-&gt;maxParticles-2000))/2000;
 //		logOutput.Print(&quot;Shattering %i %f&quot;,dl-&gt;prims.size(),pieceChance);
 
-		S3DO* dl = pieceData-&gt;original3do;
-		if(dl){
+		if(pieceData-&gt;type == MODELTYPE_3DO){
 			/* 3DO */
 
+			S3DOPiece* dl = (S3DOPiece*)pieceData-&gt;original;
+
 			for(std::vector&lt;S3DOPrimitive&gt;::iterator pi=dl-&gt;prims.begin();pi!=dl-&gt;prims.end();++pi){
 				if(gu-&gt;usRandFloat()&gt;pieceChance || pi-&gt;numVertex!=4)
 					continue;
 
 				ph-&gt;AddFlyingPiece(pos,speed+gu-&gt;usRandVector()*2,dl,&amp;*pi);
 			}
-		}
-		SS3O* cookedPiece = pieceData-&gt;originals3o;
-		if (cookedPiece){
+		} else {
 			/* S3O */
 
+			SS3OPiece* cookedPiece = (SS3OPiece*)pieceData-&gt;original;
+
 			if (cookedPiece-&gt;primitiveType == 0){
 				/* GL_TRIANGLES */
 
@@ -949,7 +1063,7 @@
 		ENTER_SYNCED;
 	}
 	else {
-		if (pieceData-&gt;original3do != NULL || pieceData-&gt;originals3o != NULL) {
+		if (pieceData-&gt;original != NULL) {
 			//logOutput.Print(&quot;Exploding %s as %d&quot;, script.pieceNames[piece].c_str(), dl);
 			SAFE_NEW CPieceProjectile(pos, speed, pieceData, newflags,unit,0.5f);
 		}
@@ -966,12 +1080,12 @@
 
 void CCobInstance::ShowFlare(int piece)
 {
-	if (!unit-&gt;localmodel-&gt;PieceExists(piece)) {
+	if (!PieceExists(piece)) {
 		GCobEngine.ShowScriptError(&quot;Invalid piecenumber for show(flare)&quot;);
 		return;
 	}
 #ifndef _CONSOLE
-	float3 relpos = unit-&gt;localmodel-&gt;GetPiecePos(piece);
+	float3 relpos = GetPiecePos(piece);
 	float3 pos=unit-&gt;pos + unit-&gt;frontdir*relpos.z + unit-&gt;updir*relpos.y + unit-&gt;rightdir*relpos.x;
 	float3 dir=unit-&gt;lastMuzzleFlameDir;
 
@@ -1020,15 +1134,15 @@
 			return 0;
 		break;
 	case PIECE_XZ:{
-		if (!unit-&gt;localmodel-&gt;PieceExists(p1))
+		if (!PieceExists(p1))
 			GCobEngine.ShowScriptError(&quot;Invalid piecenumber for get piece_xz&quot;);
-		float3 relPos = unit-&gt;localmodel-&gt;GetPiecePos(p1);
+		float3 relPos = GetPiecePos(p1);
 		float3 pos = unit-&gt;pos + unit-&gt;frontdir * relPos.z + unit-&gt;updir * relPos.y + unit-&gt;rightdir * relPos.x;
 		return PACKXZ(pos.x, pos.z);}
 	case PIECE_Y:{
-		if (!unit-&gt;localmodel-&gt;PieceExists(p1))
+		if (!PieceExists(p1))
 			GCobEngine.ShowScriptError(&quot;Invalid piecenumber for get piece_y&quot;);
-		float3 relPos = unit-&gt;localmodel-&gt;GetPiecePos(p1);
+		float3 relPos = GetPiecePos(p1);
 		float3 pos = unit-&gt;pos + unit-&gt;frontdir * relPos.z + unit-&gt;updir * relPos.y + unit-&gt;rightdir * relPos.x;
 		return (int)(pos.y * COBSCALE);}
 	case UNIT_XZ: {
@@ -1057,11 +1171,11 @@
 		else
 			return (int)(u-&gt;radius * COBSCALE);}
 	case XZ_ATAN:
-		return (int)(TAANG2RAD*atan2((float)UNPACKX(p1), (float)UNPACKZ(p1)) + 32768 - unit-&gt;heading);
+		return (int)(RAD2TAANG*atan2((float)UNPACKX(p1), (float)UNPACKZ(p1)) + 32768 - unit-&gt;heading);
 	case XZ_HYPOT:
 		return (int)(hypot((float)UNPACKX(p1), (float)UNPACKZ(p1)) * COBSCALE);
 	case ATAN:
-		return (int)(TAANG2RAD*atan2((float)p1, (float)p2));
+		return (int)(RAD2TAANG*atan2((float)p1, (float)p2));
 	case HYPOT:
 		return (int)hypot((float)p1, (float)p2);
 	case GROUND_HEIGHT:
@@ -1699,6 +1813,11 @@
 
 void CCobInstance::MoveSmooth(int piece, int axis, int destination, int delta, int deltaTime)
 {
+	if (!PieceExists(piece)) {
+		GCobEngine.ShowScriptError(&quot;Invalid piecenumber&quot;);
+		return;
+	}
+
 	//Make sure we do not overwrite animations of non-interpolated origin
 	AnimInfo *ai = FindAnim(AMove, piece, axis);
 	if (ai) {
@@ -1709,18 +1828,26 @@
 		}
 	}
 
-	int cur = pieces[piece].coords[axis];
-	int dist = abs(destination - cur);
+	float cur = pieces[piece]-&gt;pos[axis] - pieces[piece]-&gt;original-&gt;offset[axis];
+	if (axis==0) {
+		cur = -cur;
+	}
+	int dist = abs(destination - (int)(cur / CORDDIV));
 	int timeFactor = (1000 * 1000) / (deltaTime * deltaTime);
 	int speed = (dist * timeFactor) / delta;
 
-	//logOutput.Print(&quot;Move %d got %d %d&quot;, cur, destination, speed);
+	//logOutput.Print(&quot;SmoothMove %d, %d got %d %d&quot;, piece, (int)(cur / CORDDIV), destination, speed);
 
 	Move(piece, axis, speed, destination, true);
 }
 
 void CCobInstance::TurnSmooth(int piece, int axis, int destination, int delta, int deltaTime)
 {
+	if (!PieceExists(piece)) {
+		GCobEngine.ShowScriptError(&quot;Invalid piecenumber&quot;);
+		return;
+	}
+
 	AnimInfo *ai = FindAnim(ATurn, piece, axis);
 	if (ai) {
 		if (!ai-&gt;interpolated) {
@@ -1730,10 +1857,9 @@
 		}
 	}
 
-	int cur = pieces[piece].rot[axis];
-	short int dist = destination - cur;
+	float cur = pieces[piece]-&gt;rot[axis];
+	short int dist = abs(destination - (short int)(cur * RAD2TAANG));
 	int timeFactor = (1000 * 1000) / (deltaTime * deltaTime);
-	dist = abs(dist);
 	int speed = (dist * timeFactor) / delta;
 
 	//logOutput.Print(&quot;Turnx %d:%d cur %d got %d %d dist %d&quot;, piece, axis, cur, destination, speed, dist);

Modified: trunk/rts/Sim/Units/COB/CobInstance.h
===================================================================
--- trunk/rts/Sim/Units/COB/CobInstance.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/COB/CobInstance.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -6,20 +6,23 @@
 #include &lt;list&gt;
 #include &lt;SDL_types.h&gt;
 
-const float TAANG2RAD = 10430.219207445624753419256949178f;
-const float  RAD2TAANG = 9.587526207370107576104371709781e-5f;
-
 #include &quot;Object.h&quot;
 #include &quot;Sim/Misc/GlobalConstants.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 
 
 #define PACKXZ(x,z) (((int)(x) &lt;&lt; 16)+((int)(z) &amp; 0xffff))
 #define UNPACKX(xz) ((signed short)((Uint32)(xz) &gt;&gt; 16))
 #define UNPACKZ(xz) ((signed short)((Uint32)(xz) &amp; 0xffff))
 
-const int COBSCALE = 65536;
 
+static const int COBSCALE = 65536;
+static const int COBSCALEHALF = COBSCALE / 2;
+static const float CORDDIV   = 1.0f / COBSCALE;
+static const float RAD2TAANG = COBSCALEHALF / PI;
+static const float TAANG2RAD = PI / COBSCALEHALF;
 
+
 class CCobThread;
 class CCobFile;
 class CCobInstance;
@@ -27,14 +30,6 @@
 
 typedef void (*CBCobThreadFinish) (int retCode, void *p1, void *p2);
 
-struct PieceInfo {
-	int coords[3];
-	int rot[3];
-	std::string name;
-	bool updated;
-	bool visible;
-};
-
 class CCobInstance : public CObject
 {
 public:
@@ -60,9 +55,9 @@
 		AnimType type;
 		int axis;
 		int piece;
-		int speed;
-		int dest;		//means final position when turning or moving, final speed when spinning
-		int accel;		//used for spinning, can be negative
+		float speed;
+		float dest;		//means final position when turning or moving, final speed when spinning
+		float accel;		//used for spinning, can be negative
 		bool interpolated;	//true if this animation is a result of interpolating a direct move/turn
 		std::list&lt;CCobThread *&gt; listeners;
 	};
@@ -78,16 +73,63 @@
 	int unitVars[UNIT_VAR_COUNT];
 
 public:
+	std::vector&lt;LocalModelPiece*&gt; pieces;
+	void MapScriptToModelPieces(LocalModel* lmodel);
+
+	inline LocalModelPiece* GetLocalModelPiece(int scriptnum) const {
+		if (scriptnum&lt;pieces.size()) {
+			return pieces[scriptnum];
+		}else{
+			return NULL;
+		}
+	};
+
+	inline int ScriptToModel(int scriptnum) const {
+		LocalModelPiece* p = GetLocalModelPiece(scriptnum);
+
+		if (p == NULL) return -1;
+
+		int i = 0;
+		std::vector&lt;LocalModelPiece*&gt; *modelpieces = &amp;unit-&gt;localmodel-&gt;pieces;
+		for(std::vector&lt;LocalModelPiece*&gt;::iterator pm=modelpieces-&gt;begin();pm!=modelpieces-&gt;end();pm++,i++) {
+			if (p == *pm) return i;
+		}
+		return -1;
+	};
+
+	inline bool PieceExists(int scriptnum) const {
+		return GetLocalModelPiece(scriptnum) != NULL;
+	};
+
+#define SCRIPT_TO_LOCALPIECE_FUNC(x,y,z,w) \
+	inline x y(int scriptnum) const { \
+		LocalModelPiece* p = GetLocalModelPiece(scriptnum); \
+		if (p != NULL) return p-&gt;z(); \
+		return w; \
+	};
+
+	SCRIPT_TO_LOCALPIECE_FUNC(float3,     GetPiecePos,       GetPos,       float3(0.0f,0.0f,0.0f))
+	SCRIPT_TO_LOCALPIECE_FUNC(CMatrix44f, GetPieceMatrix,    GetMatrix,    CMatrix44f())
+	SCRIPT_TO_LOCALPIECE_FUNC(float3,     GetPieceDirection, GetDirection, float3(1.0f,1.0f,1.0f))
+	//SCRIPT_TO_LOCALPIECE_FUNC(int,        GetPieceVertCount, GetVertCount, 0)
+
+	inline void GetEmitDirPos(int scriptnum, float3 &amp;pos, float3 &amp;dir) const {
+		LocalModelPiece* p = GetLocalModelPiece(scriptnum);
+		if (p != NULL) {
+			return p-&gt;GetEmitDirPos(pos, dir);
+		}
+	};
+
+public:
 	bool busy;
 	std::vector&lt;int&gt; staticVars;
 	std::list&lt;CCobThread *&gt; threads;
-	std::vector&lt;struct PieceInfo&gt; pieces;	
 	bool smoothAnim;
 	const CCobFile* GetScriptAddr() const { return &script; }
 
+public:
 	const int* GetUnitVars() const { return unitVars; };
 
-public:
 	static const int* GetTeamVars(int team) { return teamVars[team]; }
 	static const int* GetAllyVars(int ally) { return allyVars[ally]; }
 	static const int* GetGlobalVars()       { return globalVars; }
@@ -112,9 +154,9 @@
 	int RawCall(int fn, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
 	int RealCall(int functionId, std::vector&lt;int&gt; &amp;args, CBCobThreadFinish cb, void *p1, void *p2);
 	int Tick(int deltaTime);
-	int MoveToward(int &amp;cur, int dest, int speed);
-	int TurnToward(int &amp;cur, int dest, int speed);
-	int DoSpin(int &amp;cur, int dest, int &amp;speed, int accel, int divisor);
+	int MoveToward(float &amp;cur, float dest, float speed);
+	int TurnToward(float &amp;cur, float dest, float speed);
+	int DoSpin(float &amp;cur, float dest, float &amp;speed, float accel, int divisor);
 	void Spin(int piece, int axis, int speed, int accel);
 	void StopSpin(int piece, int axis, int decel);
 	void Turn(int piece, int axis, int speed, int destination, bool interpolated = false);

Modified: trunk/rts/Sim/Units/COB/CobThread.cpp
===================================================================
--- trunk/rts/Sim/Units/COB/CobThread.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/COB/CobThread.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -7,7 +7,6 @@
 #include &quot;CobInstance.h&quot;
 #include &quot;CobEngine.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
-
 #include &quot;LogOutput.h&quot;
 
 #include &quot;Sim/Misc/GlobalSynced.h&quot;
@@ -61,6 +60,7 @@
 	callback = NULL;
 	retCode = -1;
 
+	stack.reserve(args.size());
 	for(vector&lt;int&gt;::const_iterator i = args.begin(); i != args.end(); ++i) {
 		stack.push_back(*i);
 		paramCount++;
@@ -377,6 +377,7 @@
 				}
 
 				args.clear();
+				args.reserve(r2);
 				for (r3 = 0; r3 &lt; r2; ++r3) {
 					r4 = POP();
 					args.push_back(r4);

Modified: trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -17,8 +17,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
-#include &quot;Rendering/Textures/TextureHandler.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
@@ -269,7 +268,7 @@
 	if (cachedRadiusId == cmdId) {
 		radius = cachedRadius;
 	} else {
-		radius = ud-&gt;LoadModel(owner-&gt;team)-&gt;radius;
+		radius = LoadModel(ud)-&gt;radius;
 		cachedRadius = radius;
 		cachedRadiusId = cmdId;
 	}

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -24,6 +24,7 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Rendering/GroundFlash.h&quot;
@@ -1368,10 +1369,6 @@
 		radarhandler-&gt;MoveUnit(this);
 	}
 
-	model = unitDef-&gt;LoadModel(newteam);
-
-	modelParser-&gt;DeleteLocalModel(this);
-	modelParser-&gt;CreateLocalModel(this);
 	SetLODCount(0);
 
 	if (unitDef-&gt;isAirBase) {
@@ -2214,13 +2211,12 @@
 	unitDef = unitDefHandler-&gt;GetUnitByName(unitDefName);
 
 	yardMap = unitDef-&gt;yardmaps[buildFacing];
-	model = unitDef-&gt;LoadModel(team);
+
+	model = LoadModel(unitDef);
 	SetRadius(model-&gt;radius);
 
-	//FIXME script = SAFE_NEW CUnitScript(this);
-	//FIXME localmodel = modelParser-&gt;CreateLocalModel(model, script-&gt;GetPieces());
-	cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(unitDef-&gt;scriptPath), this);
 	modelParser-&gt;CreateLocalModel(this);
+	cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + unitDef-&gt;cobFilename), this);
 
 	// Calculate the max() of the available weapon reloadtimes
 	int relMax = 0;

Modified: trunk/rts/Sim/Units/Unit.h
===================================================================
--- trunk/rts/Sim/Units/Unit.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/Unit.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -24,9 +24,9 @@
 class CWeapon;
 class CUnitScript;
 struct DamageArray;
-struct LocalS3DOModel;
 struct LosInstance;
-struct S3DOModel;
+struct S3DModel;
+struct LocalModel;
 struct UnitDef;
 struct UnitTrackStruct;
 struct CollisionVolume;
@@ -327,11 +327,10 @@
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	unsigned lastUnitUpdate;
 #endif
-	//CUnit3DLoader::UnitModel* model;
-	S3DOModel *model;
+	S3DModel *model;
+	LocalModel *localmodel;
 	CCobInstance *cob;
 	CUnitScript* script;
-	LocalS3DOModel *localmodel;
 
 	std::string tooltip;
 

Modified: trunk/rts/Sim/Units/UnitDef.h
===================================================================
--- trunk/rts/Sim/Units/UnitDef.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitDef.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -12,7 +12,7 @@
 
 struct MoveData;
 struct WeaponDef;
-struct S3DOModel;
+struct S3DModel;
 struct UnitDefImage;
 struct CollisionVolume;
 class CExplosionGenerator;
@@ -82,6 +82,8 @@
 
 struct UnitModelDef
 {
+	UnitModelDef():model(NULL) {};
+	S3DModel* model;
 	std::string modelpath;
 	std::string modelname;
 	std::map&lt;std::string, std::string&gt; textures;
@@ -91,13 +93,14 @@
 {
 	UnitDef() : valid(false) {}
 	~UnitDef();
-	S3DOModel* LoadModel(int team) const;
+	S3DModel* LoadModel();
 
 	bool valid;
 	std::string name;
 	std::string humanName;
 	std::string filename;
 	int id;					// unique id for this type of unit
+	std::string cobFilename;
 
 	CollisionVolume* collisionVolume;
 	const UnitDef* decoyDef;
@@ -190,7 +193,7 @@
 	float  flankingBonusMin; // damage factor for the most protected direction
 	float  flankingBonusMobilityAdd; // how much the ability of the flanking bonus direction to move builds up each frame
 
-	UnitModelDef model;
+	UnitModelDef modelDef;
 	/*
 	float collisionSphereScale;
 	float3 collisionSphereOffset;
@@ -434,4 +437,11 @@
 };
 
 
+//not very sweet, but still better than replacing &quot;const UnitDef&quot; _everywhere_
+inline S3DModel* LoadModel(const UnitDef* udef)
+{
+	return const_cast&lt;UnitDef*&gt;(udef)-&gt;LoadModel();
+}
+
+
 #endif /* UNITDEF_H */

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -21,7 +21,7 @@
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Sim/Misc/ModInfo.h&quot;
 #include &quot;Sim/Misc/SideParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
@@ -255,6 +255,7 @@
 		const string errmsg = &quot;missing 'filename' parameter for the&quot; + unitName + &quot; unitdef&quot;;
 		throw content_error(errmsg);
 	}
+	ud.cobFilename = udTable.GetString(&quot;cobfilename&quot;, ud.name + &quot;.cob&quot;);
 	ud.tooltip = udTable.GetString(&quot;description&quot;, ud.name);
 
 	const string decoy = udTable.GetString(&quot;decoyFor&quot;, &quot;&quot;);
@@ -681,8 +682,11 @@
 	}
 
 	std::string objectname = udTable.GetString(&quot;objectName&quot;, &quot;&quot;);
-	ud.model.modelpath = &quot;objects3d/&quot; + objectname;
-	ud.model.modelname = objectname;
+	if (objectname.find(&quot;.&quot;) == std::string::npos) {
+		objectname += &quot;.3do&quot;;
+	}
+	ud.modelDef.modelpath = &quot;objects3d/&quot; + objectname;
+	ud.modelDef.modelname = objectname;
 
 	ud.scriptName = udTable.GetString(&quot;script&quot;, unitName + &quot;.cob&quot;);
 	ud.scriptPath = &quot;scripts/&quot; + ud.scriptName;
@@ -691,7 +695,6 @@
 	ud.deathExplosion = udTable.GetString(&quot;explodeAs&quot;, &quot;&quot;);
 	ud.selfDExplosion = udTable.GetString(&quot;selfDestructAs&quot;, &quot;&quot;);
 
-	//ud.power = (ud.metalCost + ud.energyCost/60.0f);
 	ud.power = udTable.GetFloat(&quot;power&quot;, (ud.metalCost + (ud.energyCost / 60.0f)));
 
 	// Prevent a division by zero in experience calculations.
@@ -903,6 +906,7 @@
 }
 
 
+
 const UnitDef* CUnitDefHandler::GetUnitByName(std::string name)
 {
 	StringToLowerInPlace(name);
@@ -1132,18 +1136,9 @@
 }
 
 
-S3DOModel* UnitDef::LoadModel(int team) const
+S3DModel* UnitDef::LoadModel()
 {
-	return modelParser-&gt;Load3DModel(model.modelpath.c_str(), 1.0f, team);
-
-	/*
-	if (!useCSOffset) {
-		return modelParser-&gt;Load3DO(model.modelpath.c_str(),
-		                            collisionSphereScale, team);
-	} else {
-		return modelParser-&gt;Load3DO(model.modelpath.c_str(),
-		                            collisionSphereScale, team,
-		                            collisionSphereOffset);
-	};
-	*/
+	if (modelDef.model==NULL)
+		modelDef.model = modelParser-&gt;Load3DModel(modelDef.modelpath);
+	return modelDef.model;
 }

Modified: trunk/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -611,7 +611,7 @@
 void CUnitHandler::UpdateWind(float x, float z, float strength)
 {
 	ASSERT_SYNCED_MODE;
-	//todo: save windgens in a list (would be a little faster)
+	//todo: save windgens in list (would be a little faster)
 	std::list&lt;CUnit*&gt;::iterator usi;
 	for(usi=activeUnits.begin();usi!=activeUnits.end();usi++)
 	{

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -28,7 +28,7 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/MoveTypes/AirMoveType.h&quot;
 #include &quot;Sim/MoveTypes/GroundMoveType.h&quot;
@@ -305,9 +305,7 @@
 		unit-&gt;energyTickMake += ud-&gt;tidalGenerator * mapInfo-&gt;map.tidalStrength;
 
 
-
-
-	unit-&gt;model = ud-&gt;LoadModel(team);
+	unit-&gt;model = LoadModel(ud);
 	unit-&gt;SetRadius(unit-&gt;model-&gt;radius);
 
 	// copy the UnitDef volume archetype data
@@ -338,10 +336,10 @@
 		unit-&gt;pos.y = ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z);
 	}
 
-	unit-&gt;cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(ud-&gt;scriptPath), unit);
 	modelParser-&gt;CreateLocalModel(unit);
+	unit-&gt;cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + ud-&gt;cobFilename), unit);
 
-
+	unit-&gt;weapons.reserve(ud-&gt;weapons.size());
 	for (unsigned int i = 0; i &lt; ud-&gt;weapons.size(); i++) {
 		unit-&gt;weapons.push_back(LoadWeapon(ud-&gt;weapons[i].def, unit, &amp;ud-&gt;weapons[i]));
 	}
@@ -379,7 +377,6 @@
 	if (!build) {
 		unit-&gt;FinishedBuilding();
 	}
-
 	return unit;
 }
 

Modified: trunk/rts/Sim/Units/UnitTypes/Builder.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitTypes/Builder.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -673,8 +673,8 @@
 {
 	float3 wantedDir=(pos-this-&gt;midPos).Normalize();
 	short int h=GetHeadingFromVector(wantedDir.x,wantedDir.z);
-	short int p=(short int) (asin(wantedDir.dot(updir))*(32768/PI));
-	short int pitch=(short int) (asin(frontdir.dot(updir))*(32768/PI));
+	short int p=(short int) (asin(wantedDir.dot(updir)) * RAD2TAANG);
+	short int pitch=(short int) (asin(frontdir.dot(updir)) * RAD2TAANG);
 
 	std::vector&lt;int&gt; args;
 	args.push_back(short(h-heading));
@@ -715,7 +715,7 @@
 		if (!unitDef-&gt;showNanoSpray)
 			return;
 
-		float3 relWeaponFirePos = localmodel-&gt;GetPiecePos(args[0]);
+		float3 relWeaponFirePos = cob-&gt;GetPiecePos(args[0]);
 		float3 weaponPos = pos + frontdir * relWeaponFirePos.z + updir * relWeaponFirePos.y + rightdir * relWeaponFirePos.x;
 
 		float3 dif = goal - weaponPos;

Modified: trunk/rts/Sim/Units/UnitTypes/Building.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Building.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitTypes/Building.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -9,7 +9,7 @@
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
-#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModel.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Game/GameSetup.h&quot;
@@ -46,8 +46,8 @@
 		    !gu-&gt;spectatingFullView) {
 
 			const UnitDef* decoyDef = unitDef-&gt;decoyDef;
-			S3DOModel* gbModel =
-				(decoyDef == NULL) ? model : decoyDef-&gt;LoadModel(team);
+			S3DModel* gbModel =
+				(decoyDef == NULL) ? model : LoadModel(decoyDef);
 
 			gb = SAFE_NEW CUnitDrawer::GhostBuilding;
 			gb-&gt;pos    = pos;
@@ -89,7 +89,7 @@
 }
 
 
-void CBuilding::UnitInit (const UnitDef* def, int team, const float3&amp; position)
+void CBuilding::UnitInit(const UnitDef* def, int team, const float3&amp; position)
 {
 	if (def-&gt;levelGround) {
 		blockHeightChanges = true;

Modified: trunk/rts/Sim/Units/UnitTypes/Building.h
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Building.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitTypes/Building.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -19,7 +19,7 @@
 	void PostLoad();
 
 	void Init(const CUnit* builder);
-	void UnitInit (const UnitDef* def, int team, const float3&amp; position);
+	void UnitInit(const UnitDef* def, int team, const float3&amp; position);
 
 	BuildingGroundDecal* buildingDecal;
 };

Modified: trunk/rts/Sim/Units/UnitTypes/Factory.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/Factory.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitTypes/Factory.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -96,7 +96,7 @@
 // GetBuildPiece() is called if piece &lt; 0
 float3 CFactory::CalcBuildPos(int buildPiece)
 {
-	float3 relBuildPos = localmodel-&gt;GetPiecePos(buildPiece &lt; 0 ? GetBuildPiece() : buildPiece);
+	float3 relBuildPos = cob-&gt;GetPiecePos(buildPiece &lt; 0 ? GetBuildPiece() : buildPiece);
 	float3 buildPos = pos + frontdir * relBuildPos.z + updir * relBuildPos.y + rightdir * relBuildPos.x;
 	return buildPos;
 }
@@ -163,7 +163,7 @@
 
 			// buildPiece is the rotating platform
 			const int buildPiece = GetBuildPiece();
-			CMatrix44f mat = localmodel-&gt;GetPieceMatrix(buildPiece);
+			CMatrix44f mat = cob-&gt;GetPieceMatrix(buildPiece);
 			const int h = GetHeadingFromVector(mat[2], mat[10]);
 
 			// rotate unit nanoframe with platform
@@ -343,7 +343,7 @@
 
 	if (ph-&gt;currentParticles &lt; ph-&gt;maxParticles) {
 		if (unitDef-&gt;showNanoSpray) {
-			const float3 relWeaponFirePos = localmodel-&gt;GetPiecePos(args[0]);
+			const float3 relWeaponFirePos = cob-&gt;GetPiecePos(args[0]);
 			const float3 weaponPos = pos + (frontdir * relWeaponFirePos.z)
 										 + (updir    * relWeaponFirePos.y)
 										 + (rightdir * relWeaponFirePos.x);

Modified: trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Units/UnitTypes/TransportUnit.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -4,6 +4,7 @@
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/MoveTypes/TAAirMoveType.h&quot;
 #include &quot;Sim/MoveTypes/GroundMoveType.h&quot;
+#include &quot;Sim/Units/COB/CobInstance.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
@@ -56,7 +57,7 @@
 	for (ti = transported.begin(); ti != transported.end(); ++ti) {
 		float3 relPos;
 		if (ti-&gt;piece &gt;= 0) {
-			relPos = localmodel-&gt;GetPiecePos(std::max(0, ti-&gt;piece));
+			relPos = this-&gt;cob-&gt;GetPiecePos(ti-&gt;piece);
 		} else {
 			relPos = float3(0.0f, -1000.0f, 0.0f);
 		}
@@ -167,7 +168,6 @@
 void CTransportUnit::AttachUnit(CUnit* unit, int piece)
 {
 	DetachUnit(unit);
-
 	if (!CanTransport(unit)) {
 		return;
 	}

Modified: trunk/rts/Sim/Weapons/BeamLaser.cpp
===================================================================
--- trunk/rts/Sim/Weapons/BeamLaser.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Weapons/BeamLaser.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -69,7 +69,7 @@
 			std::vector&lt;int&gt; args;
 			args.push_back(0);
 			owner-&gt;cob-&gt;Call(COBFN_QueryPrimary+weaponNum,args);
-			CMatrix44f weaponMat = owner-&gt;localmodel-&gt;GetPieceMatrix(args[0]);
+			CMatrix44f weaponMat = owner-&gt;cob-&gt;GetPieceMatrix(args[0]);
 
 			float3 relWeaponPos = weaponMat.GetPos();
 			weaponPos=owner-&gt;pos+owner-&gt;frontdir*-relWeaponPos.z+owner-&gt;updir*relWeaponPos.y+owner-&gt;rightdir*-relWeaponPos.x;

Modified: trunk/rts/Sim/Weapons/PlasmaRepulser.cpp
===================================================================
--- trunk/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -234,7 +234,7 @@
 	std::vector&lt;int&gt; args;
 	args.push_back(0);
 	owner-&gt;cob-&gt;Call(COBFN_QueryPrimary+weaponNum,args);
-	relWeaponPos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+	relWeaponPos=owner-&gt;cob-&gt;GetPiecePos(args[0]);
 	weaponPos = owner-&gt;pos + (owner-&gt;frontdir * relWeaponPos.z)
 	                       + (owner-&gt;updir    * relWeaponPos.y)
 	                       + (owner-&gt;rightdir * relWeaponPos.x);

Modified: trunk/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- trunk/rts/Sim/Weapons/Weapon.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Weapons/Weapon.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -247,10 +247,10 @@
 		} else {
 			owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary+weaponNum,args);
 		}
-		relWeaponMuzzlePos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+		relWeaponMuzzlePos=owner-&gt;cob-&gt;GetPiecePos(args[0]);
 
 		owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary+weaponNum,args);
-		relWeaponPos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+		relWeaponPos=owner-&gt;cob-&gt;GetPiecePos(args[0]);
 	}
 
 	if(targetType==Target_Unit){
@@ -296,7 +296,7 @@
 			lastRequest=gs-&gt;frameNum;
 
 			short int heading=GetHeadingFromVector(wantedDir.x,wantedDir.z);
-			short int pitch=(short int) (asin(wantedDir.dot(owner-&gt;updir))*(32768/PI));
+			short int pitch=(short int) (asin(wantedDir.dot(owner-&gt;updir))*RAD2TAANG);
 			std::vector&lt;int&gt; args;
 			args.push_back(short(heading - owner-&gt;heading));
 			args.push_back(pitch);
@@ -345,7 +345,7 @@
 			std::vector&lt;int&gt; args;
 			args.push_back(0);
 			owner-&gt;cob-&gt;Call(COBFN_QueryPrimary + weaponNum, args);
-			owner-&gt;localmodel-&gt;GetEmitDirPos(args[0], relWeaponMuzzlePos, weaponDir);
+			owner-&gt;cob-&gt;GetEmitDirPos(args[0], relWeaponMuzzlePos, weaponDir);
 			weaponMuzzlePos = owner-&gt;pos + owner-&gt;frontdir * relWeaponMuzzlePos.z +
 			                               owner-&gt;updir    * relWeaponMuzzlePos.y +
 			                               owner-&gt;rightdir * relWeaponMuzzlePos.x;
@@ -414,10 +414,10 @@
 			owner-&gt;cob-&gt;Call(COBFN_Shot+weaponNum,0);
 
 			owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary+weaponNum,args);
-			relWeaponPos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+			relWeaponPos=owner-&gt;cob-&gt;GetPiecePos(args[0]);
 
 			owner-&gt;cob-&gt;Call(/*COBFN_AimFromPrimary+weaponNum*/COBFN_QueryPrimary+weaponNum/**/,args);
-			owner-&gt;localmodel-&gt;GetEmitDirPos(args[0], relWeaponMuzzlePos, weaponDir);
+			owner-&gt;cob-&gt;GetEmitDirPos(args[0], relWeaponMuzzlePos, weaponDir);
 
 			weaponPos=owner-&gt;pos+owner-&gt;frontdir*relWeaponPos.z+owner-&gt;updir*relWeaponPos.y+owner-&gt;rightdir*relWeaponPos.x;
 
@@ -588,11 +588,11 @@
 	} else {
 		owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary+weaponNum,args);
 	}
-	relWeaponMuzzlePos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+	relWeaponMuzzlePos=owner-&gt;cob-&gt;GetPiecePos(args[0]);
 	weaponMuzzlePos=owner-&gt;pos+owner-&gt;frontdir*relWeaponMuzzlePos.z+owner-&gt;updir*relWeaponMuzzlePos.y+owner-&gt;rightdir*relWeaponMuzzlePos.x;
 
 	owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary+weaponNum,args);
-	relWeaponPos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
+	relWeaponPos=owner-&gt;cob-&gt;GetPiecePos(args[0]);
 	weaponPos=owner-&gt;pos+owner-&gt;frontdir*relWeaponPos.z+owner-&gt;updir*relWeaponPos.y+owner-&gt;rightdir*relWeaponPos.x;
 
 	if(weaponMuzzlePos.y&lt;ground-&gt;GetHeight2(weaponMuzzlePos.x,weaponMuzzlePos.z))
@@ -837,13 +837,11 @@
 	std::vector&lt;int&gt; args;
 	args.push_back(0);
 	owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary+weaponNum,args);
-	relWeaponPos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
-	weaponPos=owner-&gt;pos+owner-&gt;frontdir*relWeaponPos.z+owner-&gt;updir*relWeaponPos.y+owner-&gt;rightdir*relWeaponPos.x;
-
+	relWeaponPos = owner-&gt;cob-&gt;GetPiecePos(args[0]);
+	weaponPos = owner-&gt;pos + owner-&gt;frontdir * relWeaponPos.z + owner-&gt;updir * relWeaponPos.y + owner-&gt;rightdir * relWeaponPos.x;
 	owner-&gt;cob-&gt;Call(COBFN_QueryPrimary+weaponNum,args);
-	relWeaponMuzzlePos=owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
-	weaponMuzzlePos=owner-&gt;pos+owner-&gt;frontdir*relWeaponMuzzlePos.z+owner-&gt;updir*relWeaponMuzzlePos.y+owner-&gt;rightdir*relWeaponMuzzlePos.x;
-//	logOutput.Print(&quot;RelPos %f %f %f&quot;,relWeaponPos.x,relWeaponPos.y,relWeaponPos.z);
+	relWeaponMuzzlePos = owner-&gt;cob-&gt;GetPiecePos(args[0]);
+	weaponMuzzlePos = owner-&gt;pos + owner-&gt;frontdir * relWeaponMuzzlePos.z + owner-&gt;updir * relWeaponMuzzlePos.y + owner-&gt;rightdir * relWeaponMuzzlePos.x;
 
 	if (range &gt; owner-&gt;maxRange) {
 		owner-&gt;maxRange = range;

Modified: trunk/rts/Sim/Weapons/WeaponDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -8,6 +8,7 @@
 #include &quot;Game/Game.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
+#include &quot;Rendering/UnitModels/IModelParser.h&quot;
 #include &quot;Rendering/Textures/ColorMap.h&quot;
 #include &quot;Rendering/Textures/TAPalette.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
@@ -690,3 +691,16 @@
 {
 	delete explosionGenerator; explosionGenerator = 0;
 }
+
+
+S3DModel* WeaponDef::LoadModel()
+{
+	if ((visuals.model==NULL) &amp;&amp; (!visuals.modelName.empty())) {
+		std::string modelname = string(&quot;objects3d/&quot;) + visuals.modelName;
+		if (modelname.find(&quot;.&quot;) == std::string::npos) {
+			modelname += &quot;.3do&quot;;
+		}
+		visuals.model = modelParser-&gt;Load3DModel(modelname);
+	}
+	return visuals.model;
+}

Modified: trunk/rts/Sim/Weapons/WeaponDefHandler.h
===================================================================
--- trunk/rts/Sim/Weapons/WeaponDefHandler.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/Sim/Weapons/WeaponDefHandler.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -33,6 +33,8 @@
 
 	~WeaponDef();
 
+	S3DModel* LoadModel();
+
 	std::string name;
 	std::string type;
 	std::string description;
@@ -140,12 +142,14 @@
 
 	struct Visuals
 	{
+		Visuals() : model(NULL) {};
 		float3 color;
 		float3 color2;
 
 		//bool hasmodel;
+		S3DModel* model;
 		std::string modelName;
-		CColorMap *colorMap;
+		CColorMap* colorMap;
 
 		bool smokeTrail;
 		bool beamweapon;
@@ -253,6 +257,13 @@
 };
 
 
+//not very sweet, but still better than replacing &quot;const WeaponDef&quot; _everywhere_
+inline S3DModel* LoadModel(const WeaponDef* wdef)
+{
+	return const_cast&lt;WeaponDef*&gt;(wdef)-&gt;LoadModel();
+}
+
+
 extern CWeaponDefHandler* weaponDefHandler;
 
 

Modified: trunk/rts/System/Util.h
===================================================================
--- trunk/rts/System/Util.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/System/Util.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -37,6 +37,14 @@
 	return s;
 }
 
+static inline std::string GetFileExt(const std::string&amp; s)
+{
+   size_t i = s.rfind('.', s.length());
+   if (i != std::string::npos) {
+      return s.substr(i+1, s.length() - i);
+   }
+   return &quot;&quot;;
+}
 
 static inline std::string IntToString(int i, const std::string&amp; format = &quot;%i&quot;)
 {

Modified: trunk/rts/System/myMath.cpp
===================================================================
--- trunk/rts/System/myMath.cpp	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/System/myMath.cpp	2008-12-10 18:33:51 UTC (rev 7162)
@@ -4,6 +4,7 @@
 #include &quot;myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
+#include &quot;Sim/Units/COB/CobInstance.h&quot;
 
 float2 headingToVectorTable[NUM_HEADINGS];
 
@@ -42,8 +43,8 @@
 float3 GetVectorFromHAndPExact(short int heading,short int pitch)
 {
 	float3 ret;
-	float h=heading*PI/32768;
-	float p=pitch*PI/32768;
+	float h=heading*TAANG2RAD;
+	float p=pitch*TAANG2RAD;
 	ret.x=sin(h)*cos(p);
 	ret.y=sin(p);
 	ret.z=cos(h)*cos(p);

Modified: trunk/rts/System/myMath.h
===================================================================
--- trunk/rts/System/myMath.h	2008-12-10 11:54:59 UTC (rev 7161)
+++ trunk/rts/System/myMath.h	2008-12-10 18:33:51 UTC (rev 7162)
@@ -7,6 +7,8 @@
 
 #define MaxByAbs(a,b) (abs((a)) &gt; abs((b))) ? (a) : (b);
 
+static const float TWOPI = 2*PI;
+
 #define SHORTINT_MAXVALUE 32768
 
 #define HEADING_CHECKSUM_1024 0x617a9968
@@ -119,6 +121,7 @@
 float LinePointDist(const float3&amp; l1, const float3&amp; l2, const float3&amp; p);
 float3 ClosestPointOnLine(const float3&amp; l1, const float3&amp; l2, const float3&amp; p);
 
+
 #ifndef __GNUC__
 #  define  __attribute__(x)  /*NOTHING*/
 #endif
@@ -129,4 +132,40 @@
 	return x*x;
 }
 
+
+/**
+ * @brief Clamps an radian angle between 0 .. 2*pi
+ * @param f float* value to clamp
+ */
+float ClampRad(float f) __attribute__((const));
+inline float ClampRad(float f)
+{
+	f = fmod(f,TWOPI);
+	if (f&lt;0.0f) f += TWOPI;
+	return f;
+}
+
+
+/**
+ * @brief Clamps an radian angle between 0 .. 2*pi
+ * @param f float* value to clamp
+ */
+inline void ClampRad(float* f)
+{
+	*f = fmod(*f,TWOPI);
+	if (*f&lt;0.0f) *f += TWOPI;
+}
+
+
+/**
+ * @brief Checks if 2 radian values discribe the same angle
+ * @param f1 float* first compare value
+ * @param f2 float* second compare value
+ */
+bool RadsAreEqual(const float f1, const float f2) __attribute__((const));
+inline bool RadsAreEqual(const float f1, const float f2)
+{
+	return (fmod(f1 - f2, TWOPI)==0.0f);
+}
+
 #endif /* MYMATH_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001930.html">[Taspring-linux-commit] r7161 - branches/caiinterface
</A></li>
	<LI>Next message: <A HREF="001932.html">[Taspring-linux-commit] r7163 - in trunk/rts/Rendering: Textures	UnitModels
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1931">[ date ]</a>
              <a href="thread.html#1931">[ thread ]</a>
              <a href="subject.html#1931">[ subject ]</a>
              <a href="author.html#1931">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
