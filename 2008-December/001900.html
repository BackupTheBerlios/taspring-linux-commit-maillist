<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7131 - in branches/caiinterface:	game/LuaUI rts/Game rts/Game/UI rts/Lua rts/Map/SM3/terrain	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/Unsynced	rts/Sim/Units rts/System rts/System/Net	rts/System/Platform/Linux rts/System/Platform/Win	rts/build/scons rts/lib/gml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7131%20-%20in%20branches/caiinterface%3A%0A%09game/LuaUI%20rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map/SM3/terrain%0A%09rts/Map/SMF%20rts/Rendering%20rts/Rendering/Env%20rts/Rendering/GL%0A%09rts/Rendering/UnitModels%20rts/Sim/Misc%20rts/Sim/Path%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/Unsynced%0A%09rts/Sim/Units%20rts/System%20rts/System/Net%0A%09rts/System/Platform/Linux%20rts/System/Platform/Win%0A%09rts/build/scons%20rts/lib/gml&In-Reply-To=%3C20081205211541.C9A95476B%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001899.html">
   <LINK REL="Next"  HREF="001901.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7131 - in branches/caiinterface:	game/LuaUI rts/Game rts/Game/UI rts/Lua rts/Map/SM3/terrain	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/Unsynced	rts/Sim/Units rts/System rts/System/Net	rts/System/Platform/Linux rts/System/Platform/Win	rts/build/scons rts/lib/gml</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7131%20-%20in%20branches/caiinterface%3A%0A%09game/LuaUI%20rts/Game%20rts/Game/UI%20rts/Lua%20rts/Map/SM3/terrain%0A%09rts/Map/SMF%20rts/Rendering%20rts/Rendering/Env%20rts/Rendering/GL%0A%09rts/Rendering/UnitModels%20rts/Sim/Misc%20rts/Sim/Path%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/Unsynced%0A%09rts/Sim/Units%20rts/System%20rts/System/Net%0A%09rts/System/Platform/Linux%20rts/System/Platform/Win%0A%09rts/build/scons%20rts/lib/gml&In-Reply-To=%3C20081205211541.C9A95476B%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7131 - in branches/caiinterface:	game/LuaUI rts/Game rts/Game/UI rts/Lua rts/Map/SM3/terrain	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Rendering/GL	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/Unsynced	rts/Sim/Units rts/System rts/System/Net	rts/System/Platform/Linux rts/System/Platform/Win	rts/build/scons rts/lib/gml">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Dec  5 22:15:41 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001899.html">[Taspring-linux-commit] r7130 - in	branches/caiinterface/AI/Skirmish: . AAI AAI/data	AAI/data/cfg/mod NTai/AI/NTai/Core NTai/data
</A></li>
        <LI>Next message: <A HREF="001901.html">[Taspring-linux-commit] r7132 - Lobby/springie/Springie/PlanetWars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1900">[ date ]</a>
              <a href="thread.html#1900">[ thread ]</a>
              <a href="subject.html#1900">[ subject ]</a>
              <a href="author.html#1900">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-05 22:15:39 +0100 (Fri, 05 Dec 2008)
New Revision: 7131

Removed:
   branches/caiinterface/rts/Rendering/GL/IFramebuffer.h
Modified:
   branches/caiinterface/game/LuaUI/fonts.lua
   branches/caiinterface/rts/Game/Game.cpp
   branches/caiinterface/rts/Game/Game.h
   branches/caiinterface/rts/Game/GameServer.cpp
   branches/caiinterface/rts/Game/UI/GameSetupDrawer.cpp
   branches/caiinterface/rts/Game/UI/GameSetupDrawer.h
   branches/caiinterface/rts/Game/UI/KeyBindings.cpp
   branches/caiinterface/rts/Game/UI/MouseHandler.cpp
   branches/caiinterface/rts/Game/UI/MouseHandler.h
   branches/caiinterface/rts/Lua/LuaCallInCheck.h
   branches/caiinterface/rts/Lua/LuaOpenGL.cpp
   branches/caiinterface/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp
   branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp
   branches/caiinterface/rts/Map/SMF/BFGroundTextures.cpp
   branches/caiinterface/rts/Rendering/Env/AdvSky.cpp
   branches/caiinterface/rts/Rendering/Env/AdvSky.h
   branches/caiinterface/rts/Rendering/Env/BaseWater.cpp
   branches/caiinterface/rts/Rendering/Env/BasicSky.cpp
   branches/caiinterface/rts/Rendering/Env/BasicSky.h
   branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
   branches/caiinterface/rts/Rendering/Env/BumpWater.h
   branches/caiinterface/rts/Rendering/GL/FBO.cpp
   branches/caiinterface/rts/Rendering/GL/FBO.h
   branches/caiinterface/rts/Rendering/GL/myGL.cpp
   branches/caiinterface/rts/Rendering/GLContext.h
   branches/caiinterface/rts/Rendering/ShadowHandler.cpp
   branches/caiinterface/rts/Rendering/ShadowHandler.h
   branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/caiinterface/rts/Sim/Misc/LosHandler.cpp
   branches/caiinterface/rts/Sim/Misc/LosHandler.h
   branches/caiinterface/rts/Sim/Misc/Wind.cpp
   branches/caiinterface/rts/Sim/Path/PathManager.cpp
   branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Projectile.h
   branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp
   branches/caiinterface/rts/Sim/Units/Unit.cpp
   branches/caiinterface/rts/Sim/Units/Unit.h
   branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitHandler.h
   branches/caiinterface/rts/System/MouseInput.cpp
   branches/caiinterface/rts/System/Net/UDPConnection.cpp
   branches/caiinterface/rts/System/Net/UDPConnection.h
   branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp
   branches/caiinterface/rts/System/Platform/Win/DxSound.cpp
   branches/caiinterface/rts/System/Platform/Win/OggStream.cpp
   branches/caiinterface/rts/System/Sound.cpp
   branches/caiinterface/rts/System/SpringApp.cpp
   branches/caiinterface/rts/System/SpringApp.h
   branches/caiinterface/rts/build/scons/rts.py
   branches/caiinterface/rts/lib/gml/gml.cpp
   branches/caiinterface/rts/lib/gml/gml.h
   branches/caiinterface/rts/lib/gml/gmlcls.h
   branches/caiinterface/rts/lib/gml/gmlsrv.h
Log:
reintegrated trunk up to 7130

Modified: branches/caiinterface/game/LuaUI/fonts.lua
===================================================================
--- branches/caiinterface/game/LuaUI/fonts.lua	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/game/LuaUI/fonts.lua	2008-12-05 21:15:39 UTC (rev 7131)
@@ -2,7 +2,7 @@
 --------------------------------------------------------------------------------
 --
 --  file:    fonts.lua
---  brief:   font handler, uses texture atlases from BZFlag
+--  brief:   font handler, with automatic texture atlas generation
 --  author:  Dave Rodgers
 --
 --  Copyright (C) 2007.

Modified: branches/caiinterface/rts/Game/Game.cpp
===================================================================
--- branches/caiinterface/rts/Game/Game.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/Game.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -161,7 +161,7 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+extern gmlClientServer&lt;void, int,CUnit*&gt; *gmlProcessor;
 #endif
 
 extern Uint8 *keys;
@@ -1371,17 +1371,17 @@
 				gd-&gt;multiThreadDrawGroundShadow=0;
 			logOutput.Print(&quot;Multithreaded rendering is %s&quot;, gd-&gt;multiThreadDrawGround?&quot;enabled&quot;:&quot;disabled&quot;);
 		}
-#	if GML_ENABLE_SIMLOOP
+#	if GML_ENABLE_SIM
 		if (cmd == &quot;multithread&quot; || cmd == &quot;multithreadsim&quot;) {
-			extern volatile int multiThreadSim;
-			extern volatile int startsim;
+			extern volatile int gmlMultiThreadSim;
+			extern volatile int gmlStartSim;
 			if (action.extra.empty()) {
-				multiThreadSim = (cmd == &quot;multithread&quot;) ? !mtenabled : !multiThreadSim;
+				gmlMultiThreadSim = (cmd == &quot;multithread&quot;) ? !mtenabled : !gmlMultiThreadSim;
 			} else {
-				multiThreadSim = !!atoi(action.extra.c_str());
+				gmlMultiThreadSim = !!atoi(action.extra.c_str());
 			}
-			startsim=1;
-			logOutput.Print(&quot;Simulation threading is %s&quot;, multiThreadSim?&quot;enabled&quot;:&quot;disabled&quot;);
+			gmlStartSim=1;
+			logOutput.Print(&quot;Simulation threading is %s&quot;, gmlMultiThreadSim?&quot;enabled&quot;:&quot;disabled&quot;);
 		}
 #	endif
 	}
@@ -2669,7 +2669,7 @@
 
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_DRAW
 bool CGame::Draw() {
-	gmlProcessor.Work(&amp;CGame::DrawMTcb,NULL,NULL,this,gmlThreadCount,TRUE,NULL,1,2,2,FALSE);
+	gmlProcessor-&gt;Work(&amp;CGame::DrawMTcb,NULL,NULL,this,gmlThreadCount,TRUE,NULL,1,2,2,FALSE);
 #else
 bool CGame::DrawMT() {
 #endif
@@ -3087,53 +3087,7 @@
 }
 
 
-// This will be run by a separate thread in parallel with the Sim
-// ONLY 100% THREAD SAFE UNSYNCED STUFF HERE PLEASE
-void CGame::UnsyncedStuff() {
-	if (!skipping) {
-		infoConsole-&gt;Update();
-	}
-}
-
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
-int numNewFrames=0;
-#endif
-
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 void CGame::SimFrame() {
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-	SimFrameMT();
-#	else
-#		if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
-	if(gmlThreadCount&gt;1) { // if there is more than one cpu, run draw in parallel with sim
-		int oldgsframe=gs-&gt;frameNum;
-		gmlProcessor.AuxWork(&amp;CGame::SimFrameMTcb,this); // start sim thread
-		UnsyncedStuff();
-		if(--numNewFrames==0) {
-			gu-&gt;drawFrame++;
-			if (gu-&gt;drawFrame == 0)
-				gu-&gt;drawFrame++;
-			Draw(); // GML will use one thread less for this draw because sim is running
-		}
-		while(!gmlProcessor.PumpAux()) {
-			// could possibly make more calls to Draw here
-			boost::thread::yield();
-		}
-	}
-	else
-#		endif
-	gmlProcessor.Work(&amp;CGame::SimFrameMTcb,NULL,NULL,this,2,FALSE,NULL,1,2,2,FALSE,&amp;CGame::UnsyncedStuffcb);
-#	endif
-#else
-void CGame::SimFrameMT() {
-#endif
-}
-
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
-void CGame::SimFrameMT() {
-#else
-void CGame::SimFrame() {
-#endif
 	ScopedTimer cputimer(&quot;CPU load&quot;); // SimFrame
 
 	good_fpu_control_registers(&quot;CGame::SimFrame&quot;);
@@ -3161,10 +3115,7 @@
 	ENTER_UNSYNCED;
 
 	if (!skipping) {
-#if !defined(USE_GML) || !GML_ENABLE_SIM || GML_ENABLE_SIMLOOP
-    UnsyncedStuff();
-#endif
-//		infoConsole-&gt;Update();
+		infoConsole-&gt;Update();
 		waitCommandsAI.Update();
 		geometricObjects-&gt;Update();
 		if(!(gs-&gt;frameNum &amp; 7))
@@ -3318,9 +3269,6 @@
 	boost::shared_ptr&lt;const netcode::RawPacket&gt; packet;
 
 	// compute new timeLeft to &quot;smooth&quot; out SimFrame() calls
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
-	numNewFrames=0;
-#endif
 	if(!gameServer){
 		const unsigned int currentFrame = SDL_GetTicks();
 
@@ -3336,10 +3284,6 @@
 		int que = 0; // Number of NETMSG_NEWFRAMEs waiting to be processed.
 		unsigned ahead = 0;
 		while ((packet = net-&gt;Peek(ahead))) {
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
-			if (packet-&gt;data[0] == NETMSG_NEWFRAME)
-				++numNewFrames;
-#endif
 			if (packet-&gt;data[0] == NETMSG_NEWFRAME || packet-&gt;data[0] == NETMSG_KEYFRAME)
 				++que;
 			++ahead;
@@ -3350,14 +3294,6 @@
 	}
 	else
 	{
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW &amp;&amp; !GML_ENABLE_SIMLOOP
-		unsigned ahead = 0;
-		while ((packet = net-&gt;Peek(ahead))) {
-			if (packet-&gt;data[0] == NETMSG_NEWFRAME)
-				++numNewFrames;
-			++ahead;
-		}
-#endif
 		// make sure ClientReadNet returns at least every 15 game frames
 		// so CGame can process keyboard input, and render etc.
 		timeLeft = (float)MAX_CONSECUTIVE_SIMFRAMES;

Modified: branches/caiinterface/rts/Game/Game.h
===================================================================
--- branches/caiinterface/rts/Game/Game.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/Game.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -33,15 +33,10 @@
 	CR_DECLARE(CGame);			//Don't use CGame pointer in CR_MEMBER()!!!
 	void PostLoad();
 
-	void SimFrameMT();
-	static void SimFrameMTcb(void *c) {((CGame *)c)-&gt;SimFrameMT();}
-
 	bool Draw();
 	bool DrawMT();
 
 	static void DrawMTcb(void *c) {((CGame *)c)-&gt;DrawMT();}
-	void UnsyncedStuff();
-	static void UnsyncedStuffcb(void *c) {((CGame *)c)-&gt;UnsyncedStuff();}
 	bool Update();
 	int KeyReleased(unsigned short k);
 	int KeyPressed(unsigned short k,bool isRepeat);

Modified: branches/caiinterface/rts/Game/GameServer.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameServer.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/GameServer.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -431,8 +431,8 @@
 		if (serverframenum &gt; 0) {
 			//send info about the players
 			int curpos=0;
-			int ping[MAX_PLAYERS] = { 0 };
-			float cpu[MAX_PLAYERS] = { 0.0f };
+			int ping[MAX_PLAYERS];
+			float cpu[MAX_PLAYERS];
 			float refCpu=0.0f;
 			for (unsigned a = 0; a &lt; players.size(); ++a) {
 				if (players[a].myState &gt;= GameParticipant::INGAME) {

Modified: branches/caiinterface/rts/Game/UI/GameSetupDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/GameSetupDrawer.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/UI/GameSetupDrawer.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -158,18 +158,3 @@
 		font-&gt;glPrintOutlinedAt(xPos, yPos, fontScale, name, color);
 	}
 }
-
-
-bool GameSetupDrawer::KeyPressed(unsigned short key, bool isRepeat)
-{
-	if (keys[SDLK_LCTRL] &amp;&amp; (key == SDLK_RETURN)) {
-		// tell the server to force-start the game
-		net-&gt;Send(CBaseNetProtocol::Get().SendStartPlaying(0));
-	}
-	return false;
-}
-
-
-
-
-

Modified: branches/caiinterface/rts/Game/UI/GameSetupDrawer.h
===================================================================
--- branches/caiinterface/rts/Game/UI/GameSetupDrawer.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/UI/GameSetupDrawer.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -16,7 +16,6 @@
 	~GameSetupDrawer();
 
 	virtual void Draw();
-	virtual bool KeyPressed(unsigned short key, bool isRepeat);
 
 	static GameSetupDrawer* instance;
 	bool lctrl_pressed;

Modified: branches/caiinterface/rts/Game/UI/KeyBindings.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/KeyBindings.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/UI/KeyBindings.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -32,11 +32,11 @@
 }
 defaultBindings[] = {
 
-	{       &quot;esc&quot;, &quot;quitwarn&quot; },
-	{ &quot;Shift+esc&quot;, &quot;quit&quot;     },
+	{        &quot;esc&quot;, &quot;quitwarn&quot;    },
+	{  &quot;Shift+esc&quot;, &quot;quit&quot;        },
+	{  &quot;Any+pause&quot;, &quot;pause&quot;       },
+	{ &quot;Ctrl+enter&quot;, &quot;forcestart&quot;  },
 
-	{ &quot;Any+pause&quot;, &quot;pause&quot; },
-
 	{ &quot;Any+b&quot;, &quot;debug&quot;                },
 	{ &quot;Any+o&quot;, &quot;singlestep&quot;           },
 	{ &quot;Any+c&quot;, &quot;controlunit&quot;          },

Modified: branches/caiinterface/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -490,13 +490,13 @@
 }
 
 
-void CMouseHandler::MouseWheel(bool up)
+void CMouseHandler::MouseWheel(float delta)
 {
-	const float value = up ? +scrollWheelSpeed : -scrollWheelSpeed;
-	if (eventHandler.MouseWheel(up, value)) {
+	delta *= scrollWheelSpeed;
+	if (eventHandler.MouseWheel(delta&gt;1.0f, delta)) {
 		return;
 	}
-	camHandler-&gt;GetCurrentController().MouseWheelMove(value);
+	camHandler-&gt;GetCurrentController().MouseWheelMove(delta);
 }
 
 

Modified: branches/caiinterface/rts/Game/UI/MouseHandler.h
===================================================================
--- branches/caiinterface/rts/Game/UI/MouseHandler.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Game/UI/MouseHandler.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -33,7 +33,7 @@
 	void MouseRelease(int x,int y,int button);
 	void MousePress(int x,int y,int button);
 	void MouseMove(int x,int y);
-	void MouseWheel(bool up);
+	void MouseWheel(float delta);
 	CMouseHandler();
 	virtual ~CMouseHandler();
 

Modified: branches/caiinterface/rts/Lua/LuaCallInCheck.h
===================================================================
--- branches/caiinterface/rts/Lua/LuaCallInCheck.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Lua/LuaCallInCheck.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -29,7 +29,7 @@
 #ifdef USE_GML // hack to add some degree of thread safety to LUA
 #	include &quot;Rendering/GL/myGL.h&quot;
 #	include &quot;lib/gml/gmlsrv.h&quot;
-#	if GML_ENABLE_SIMDRAW
+#	if GML_ENABLE_SIM
 #		undef LUA_CALL_IN_CHECK
 #		if DEBUG_LUA
 #			define LUA_CALL_IN_CHECK(L) GML_RECMUTEX_LOCK(lua); LuaCallInCheck ciCheck((L), __FUNCTION__);

Modified: branches/caiinterface/rts/Lua/LuaOpenGL.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaOpenGL.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Lua/LuaOpenGL.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -44,7 +44,6 @@
 #include &quot;Rendering/Env/BaseWater.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/Textures/NamedTextures.h&quot;
 #include &quot;Rendering/Textures/TextureHandler.h&quot;

Modified: branches/caiinterface/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp
===================================================================
--- branches/caiinterface/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -33,7 +33,7 @@
 #include &quot;Terrain.h&quot;
 
 #include &quot;TerrainTextureGLSL.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;FileSystem/FileSystem.h&quot;
 #include &quot;bitops.h&quot;
@@ -147,6 +147,8 @@
 	{
 	// ATI has GL_EXT_texture_rectangle, but that has no support for GLSL texture2DRect
 	// nVidia: Use RECT,  ati: use POT
+		assert(framebuffer.IsValid());
+
 		width = gu-&gt;viewSizeX;
 		height = gu-&gt;viewSizeY;
 		if (GLEW_ARB_texture_rectangle)
@@ -157,7 +159,6 @@
 			height = closest_pot(height);
 		}
 
-		framebuffer = instantiate_fb(width, height, FBO_NEED_COLOR | FBO_NEED_DEPTH);
 		name = &quot;_buffer&quot;;
 
 		glGenTextures(1, &amp;id);
@@ -166,20 +167,22 @@
 		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
 		glTexImage2D(target, 0, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
 
-		framebuffer-&gt;attachTexture(id, target, FBO_ATTACH_COLOR);
-
-		assert (framebuffer-&gt;valid());
+		framebuffer.Bind();
+		framebuffer.CreateRenderBuffer(GL_DEPTH_ATTACHMENT_EXT, GL_DEPTH_COMPONENT24, width, height);
+		framebuffer.AttachTexture(id, target);
+		bool status = framebuffer.CheckStatus(&quot;sm3&quot;);
+		framebuffer.Unbind();
+		assert(status);
 	}
 	~BufferTexture()
 	{
-		delete framebuffer;
 		// texture is deleted by ~BaseTexture
 	}
 	bool IsRect() {	return target == GL_TEXTURE_RECTANGLE_ARB; }
 
 	int width, height;
 	uint target;
-	IFramebuffer* framebuffer;
+	FBO framebuffer;
 };
 
 struct ShaderBuilder
@@ -658,7 +661,7 @@
 void NodeGLSLShader::Setup (NodeSetupParams&amp; params)
 {/*
 	if (renderBuffer) { // use a offscreen rendering buffer
-		renderBuffer-&gt;framebuffer-&gt;select();
+		renderBuffer-&gt;framebuffer.Bind();
 		glViewport(0, 0, renderBuffer-&gt;width, renderBuffer-&gt;height);
 	}*/
 
@@ -765,12 +768,12 @@
 	if (buffer)
 	{
 		if (pass == 0) {
-			buffer-&gt;framebuffer-&gt;select();
+			buffer-&gt;framebuffer.Bind();
 			glViewport(0, 0, buffer-&gt;width, buffer-&gt;height);
 			glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);
 		}
 		else if (pass==1) {
-			buffer-&gt;framebuffer-&gt;deselect();
+			buffer-&gt;framebuffer.Unbind();
 			glViewport(gu-&gt;viewPosX, gu-&gt;viewPosY, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
 		}
 	}

Modified: branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -18,7 +18,7 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+extern gmlClientServer&lt;void, int,CUnit*&gt; *gmlProcessor;
 #endif
 
 using std::min;
@@ -126,7 +126,7 @@
 
 	const float alphainc = fastmath::PI2 / 32;
 	float alpha,r1,r2;
-	float3 p(0.0f,-200.0f,0.0f);
+	float3 p(0.0f,std::min(-200.0f, map-&gt;minheight - 400.0f),0.0f);
 	const float size = std::min(xsize,ysize);
 	for (int n = (camOufOfMap) ? 0 : 1; n &lt; 4 ; ++n) {
 
@@ -720,7 +720,7 @@
 #ifdef USE_GML
 	if(multiThreadDrawGround) {
 		mt_overrideVP=overrideVP;
-		gmlProcessor.Work(NULL,&amp;CBFGroundDrawer::DoDrawGroundRowMT,NULL,this,gmlThreadCount,FALSE,NULL,numBigTexY,50,100,TRUE,NULL);
+		gmlProcessor-&gt;Work(NULL,&amp;CBFGroundDrawer::DoDrawGroundRowMT,NULL,this,gmlThreadCount,FALSE,NULL,numBigTexY,50,100,TRUE,NULL);
 	}
 	else {
 #endif
@@ -1106,7 +1106,7 @@
 
 #ifdef USE_GML
 	if(multiThreadDrawGroundShadow) {
-		gmlProcessor.Work(NULL,&amp;CBFGroundDrawer::DoDrawGroundShadowLODMT,NULL,this,gmlThreadCount,FALSE,NULL,NUM_LODS+1,50,100,TRUE,NULL);
+		gmlProcessor-&gt;Work(NULL,&amp;CBFGroundDrawer::DoDrawGroundShadowLODMT,NULL,this,gmlThreadCount,FALSE,NULL,NUM_LODS+1,50,100,TRUE,NULL);
 	}
 	else {
 #endif
@@ -1131,6 +1131,7 @@
 		glActiveTextureARB(GL_TEXTURE1_ARB);
 		glEnable(GL_TEXTURE_2D);
 		glBindTexture(GL_TEXTURE_2D, map-&gt;GetShadingTexture());
+		glMultiTexCoord1f(GL_TEXTURE1_ARB,0); //fixes a nvidia bug with gltexgen
 		SetTexGen(1.0f / (gs-&gt;pwr2mapx * SQUARE_SIZE), 1.0f / (gs-&gt;pwr2mapy * SQUARE_SIZE), 0, 0);
 		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
 
@@ -1140,6 +1141,7 @@
 		if (map-&gt;detailTex) {
 			glEnable(GL_TEXTURE_2D);
 			glBindTexture(GL_TEXTURE_2D, map-&gt;detailTex);
+			glMultiTexCoord1f(GL_TEXTURE2_ARB,0); //fixes a nvidia bug with gltexgen
 			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
 			//SetTexGen(0.02f,0.02f, -floor(camera-&gt;pos.x * 0.02f), -floor(camera-&gt;pos.z * 0.02f));
 			GLfloat plan[]={0.02f,0.5f,0,0};
@@ -1157,6 +1159,7 @@
 		glActiveTextureARB(GL_TEXTURE3_ARB);
 		glEnable(GL_TEXTURE_2D);
 		glBindTexture(GL_TEXTURE_2D, infoTex);
+		glMultiTexCoord1f(GL_TEXTURE1_ARB,0); //fixes a nvidia bug with gltexgen
 		glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
 		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
 		SetTexGen(1.0f / (gs-&gt;pwr2mapx * SQUARE_SIZE), 1.0f / (gs-&gt;pwr2mapy * SQUARE_SIZE), 0, 0);
@@ -1184,6 +1187,7 @@
 
 		glActiveTextureARB(GL_TEXTURE0_ARB);
 		glActiveTextureARB(GL_TEXTURE1_ARB);
+		glMultiTexCoord1f(GL_TEXTURE1_ARB,0); //fixes a nvidia bug with gltexgen
 		glBindTexture(GL_TEXTURE_2D, map-&gt;GetShadingTexture());
 		glActiveTextureARB(GL_TEXTURE2_ARB);
 
@@ -1225,6 +1229,7 @@
 		glActiveTextureARB(GL_TEXTURE1_ARB);
 		glEnable(GL_TEXTURE_2D);
 		glBindTexture(GL_TEXTURE_2D, map-&gt;GetShadingTexture());
+		glMultiTexCoord1f(GL_TEXTURE1_ARB,0); //fixes a nvidia bug with gltexgen
 		SetTexGen(1.0f / (gs-&gt;pwr2mapx * SQUARE_SIZE), 1.0f / (gs-&gt;pwr2mapy * SQUARE_SIZE), 0, 0);
 		glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
 		glActiveTextureARB(GL_TEXTURE2_ARB);
@@ -1232,6 +1237,7 @@
 		if (map-&gt;detailTex) {
 			glEnable(GL_TEXTURE_2D);
 			glBindTexture(GL_TEXTURE_2D, map-&gt;detailTex);
+			glMultiTexCoord1f(GL_TEXTURE2_ARB,0); //fixes a nvidia bug with gltexgen
 			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
 			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
 			//SetTexGen(0.02f, 0.02f, -floor(camera-&gt;pos.x * 0.02f), -floor(camera-&gt;pos.z * 0.02f));

Modified: branches/caiinterface/rts/Map/SMF/BFGroundTextures.cpp
===================================================================
--- branches/caiinterface/rts/Map/SMF/BFGroundTextures.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Map/SMF/BFGroundTextures.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -250,7 +250,7 @@
 	if (usedPBO) {
 		glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
 		glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, 0);
-		glBufferData(GL_PIXEL_UNPACK_BUFFER, 0, 0, GL_STREAM_DRAW); //free it
+		//glBufferData(GL_PIXEL_UNPACK_BUFFER, 0, 0, GL_STREAM_DRAW); //free it
 		glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
 	} else {
 		glCompressedTexImage2D(GL_TEXTURE_2D, 0, GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, size, size, 0, size * size / 2, buf);

Modified: branches/caiinterface/rts/Rendering/Env/AdvSky.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/AdvSky.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/AdvSky.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -344,30 +344,25 @@
 	unsigned char* ct = cloudTexMem + 4 * ast;
 
 	int
-		am2 = (ast - 2) &amp; CLOUD_MASK,
-		am1 = (ast - 1) &amp; CLOUD_MASK,
-		aa  = (ast) &amp; CLOUD_MASK,
-		ap1 = (ast + 1) &amp; CLOUD_MASK,
-		dif = 0;
+		yam2 = ydif[(ast - 2) &amp; CLOUD_MASK],
+		yam1 = ydif[(ast - 1) &amp; CLOUD_MASK],
+		yaa  = ydif[(ast) &amp; CLOUD_MASK],
+		ap1 = (ast + 1) &amp; CLOUD_MASK;
 
 	int
 		a3c = ast + a3cstart,
 		a4c = ast + a4cstart;
 
 	for (int a = ast; a &lt; aed; ++rc, ++ct) {
-		ydif[ap1] += (int) cloudThickness[++a3c] - cloudThickness[++a] * 2 + cloudThickness[++a4c];
-		ydif2[ap1] = (ydif1[ap1] = ydif[ap1] &gt;&gt; 1) &gt;&gt; 1;
+		int yap1 = ydif[ap1] += (int) cloudThickness[++a3c] - cloudThickness[++a] * 2 + cloudThickness[++a4c];
 
-		dif = ydif2[am2];
-		am2 = am1; dif += ydif1[am2];
-		am1 = aa;  dif += ydif[am1];
-		aa = ap1;  dif += ydif1[aa];
-		ap1 += 1;  dif += ydif2[ap1];
+		int dif = yam2 &gt;&gt; 2 +
+			(yam2 = yam1) &gt;&gt; 1 +
+			(yam1 = yaa) +
+			(yaa = yap1) &gt;&gt; 1 +
+			ydif[(++ap1) &amp;= CLOUD_MASK] &gt;&gt; 2;
 		dif &gt;&gt;= 4;
 
-		if (ap1 &gt;= CLOUD_SIZE)
-			ap1 = 0;
-
 		*ct++ = 128 + dif;
 		*ct++ = thicknessTransform[(*rc) &gt;&gt; 7];
 		*ct++ = 255;
@@ -406,16 +401,14 @@
 		int ifade=(int)(fade*fade*(3-2*fade)*256);
 		int ifade2=256-ifade;
 
-		for(int y=0, **bm=blendMatrix[a], **rm=randMatrix[a], **rm8=randMatrix[a+8]; y&lt;32; ++y, ++bm, ++rm, ++rm8) {
-			int *bmx=*bm, *rmx=*rm, *rm8x=*rm8;
-			for(int x=0; x&lt;32; ++x) {
-				(*bmx++)=((*rmx++)*ifade+(*rm8x++)*ifade2)&gt;&gt;8;
-			}
+		for(int y=0;y&lt;32;y++){
+			for(int x=0;x&lt;32;x++)
+				blendMatrix[a][y][x]=(randMatrix[a][y][x]*ifade+randMatrix[a+8][y][x]*ifade2)&gt;&gt;8;
 		}
 	}
 
-	for(int *rc=*rawClouds, *ec=rc+CLOUD_SIZE*CLOUD_SIZE; rc&lt;ec; ++rc)
-		(*rc)=0;
+	for(int a=0;a&lt;CLOUD_SIZE*CLOUD_SIZE;a++)
+		rawClouds[0][a]=0;
 
 	static int kernel[CLOUD_SIZE/4*CLOUD_SIZE/4];
 	for(int a=0; a&lt;CLOUD_DETAIL; ++a) {
@@ -469,39 +462,28 @@
 		}
 	}
 
-	unsigned char *ct=cloudThickness;
-	for(int *rc=*rawClouds, *ec=rc+CLOUD_SIZE*CLOUD_SIZE; rc&lt;ec; ++ct, ++rc)
-		(*ct)=alphaTransform[(*rc)&gt;&gt;7];
+	for(int a=0;a&lt;CLOUD_SIZE*CLOUD_SIZE;a++)
+		cloudThickness[a]=alphaTransform[rawClouds[0][a]&gt;&gt;7];
 
 	cloudThickness[CLOUD_SIZE*CLOUD_SIZE]=cloudThickness[CLOUD_SIZE*CLOUD_SIZE-1];	//this one is read in one place, so to avoid reading uninitialized mem ...
 
 	//create the cloud shading
 	for(int a=0;a&lt;CLOUD_SIZE;++a){
 		ydif[a]=(int)cloudThickness[(a+3*CLOUD_SIZE)] + cloudThickness[(a+2*CLOUD_SIZE)] + cloudThickness[(a+1*CLOUD_SIZE)] + 
-			cloudThickness[(a+0*CLOUD_SIZE)] - cloudThickness[(a+(CLOUD_SIZE-1)*CLOUD_SIZE)] - 
-			cloudThickness[(a+(CLOUD_SIZE-2)*CLOUD_SIZE)] - cloudThickness[(a+(CLOUD_SIZE-3)*CLOUD_SIZE)];
-		ydif2[a]=(ydif1[a]=ydif[a]&gt;&gt;1)&gt;&gt;1;
+			cloudThickness[(a+0*CLOUD_SIZE)] - cloudThickness[(a+CLOUD_SIZE*(CLOUD_SIZE-1))] - 
+			cloudThickness[(a+CLOUD_SIZE*(CLOUD_SIZE-2))] - cloudThickness[(a+CLOUD_SIZE*(CLOUD_SIZE-3))];
 	}
 
-	int b=0;
-	ydif[(b)&amp;CLOUD_MASK]+=cloudThickness[(b+CLOUD_SIZE*(CLOUD_SIZE-3))];
-	ydif[(b)&amp;CLOUD_MASK]-=cloudThickness[(b)]*2;
-	ydif[(b)&amp;CLOUD_MASK]+=cloudThickness[(b+4*CLOUD_SIZE)];
-	ydif2[(b)&amp;CLOUD_MASK]=(ydif1[(b)&amp;CLOUD_MASK]=ydif[(b)&amp;CLOUD_MASK]&gt;&gt;1)&gt;&gt;1;
+	ydif[0] += cloudThickness[0+CLOUD_SIZE*(CLOUD_SIZE-3)] - cloudThickness[0]*2 + cloudThickness[0+4*CLOUD_SIZE];
 
 	UpdatePart(0, CLOUD_SIZE*3-1, CLOUD_SIZE*(CLOUD_SIZE-3), 4*CLOUD_SIZE);
 	UpdatePart(CLOUD_SIZE*3-1, CLOUD_SIZE*(CLOUD_SIZE-4)-1, -3*CLOUD_SIZE, 4*CLOUD_SIZE);
-	UpdatePart(CLOUD_SIZE*(CLOUD_SIZE-4)-1, CLOUD_SIZE*CLOUD_SIZE, -3*CLOUD_SIZE, (4-CLOUD_SIZE)*CLOUD_SIZE);
+	UpdatePart(CLOUD_SIZE*(CLOUD_SIZE-4)-1, CLOUD_SIZE*CLOUD_SIZE, -3*CLOUD_SIZE, CLOUD_SIZE*(4-CLOUD_SIZE));
 
 	int modDensity=(int) ((1-cloudDensity)*256);
-	ct=cloudTexMem+3;
-	for(int a=0, *rc=*rawClouds;a&lt;CLOUD_SIZE*CLOUD_SIZE; ++a, ++rc, ct+=4){
-		int f=((*rc)&gt;&gt;8)-modDensity;
-		if(f&lt;0)
-			f=0;
-		if(f&gt;255)
-			f=255;
-		(*ct)=f;
+	for(int a=0; a&lt;CLOUD_SIZE*CLOUD_SIZE; ++a){
+		int f=(rawClouds[0][a]&gt;&gt;8)-modDensity;
+		cloudTexMem[a*4+3]=std::max(0, std::min(255, f));
 	}
 
 	glBindTexture(GL_TEXTURE_2D, cloudDot3Tex);

Modified: branches/caiinterface/rts/Rendering/Env/AdvSky.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/AdvSky.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/AdvSky.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -48,8 +48,6 @@
 	int ***blendMatrix;
 
 	int ydif[CLOUD_SIZE];
-	int ydif1[CLOUD_SIZE]; // ydif &gt;&gt; 1
-	int ydif2[CLOUD_SIZE]; // ydif &gt;&gt; 2
 
 	unsigned char alphaTransform[1024];
 	unsigned char thicknessTransform[1024];

Modified: branches/caiinterface/rts/Rendering/Env/BaseWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseWater.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/BaseWater.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -53,7 +53,7 @@
 		}
 	}
 
-	if(water==NULL &amp;&amp; configValue==4 &amp;&amp; GLEW_ARB_shading_language_100) {
+	if(water==NULL &amp;&amp; configValue==4 &amp;&amp; GLEW_ARB_shading_language_100 &amp;&amp; GL_ARB_fragment_shader &amp;&amp; GL_ARB_vertex_shader) {
 		try {
 			water = SAFE_NEW CBumpWater;
 		} catch (content_error&amp; e) {

Modified: branches/caiinterface/rts/Rendering/Env/BasicSky.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BasicSky.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/BasicSky.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -396,11 +396,10 @@
 	unsigned char* ct = cloudThickness + 4 * ast;
 
 	int
-		am2 = (ast - 2) &amp; CLOUD_MASK,
-		am1 = (ast - 1) &amp; CLOUD_MASK,
-		aa  = (ast) &amp; CLOUD_MASK,
-		ap1 = (ast + 1) &amp; CLOUD_MASK,
-		dif = 0;
+		yam2 = ydif[(ast - 2) &amp; CLOUD_MASK],
+		yam1 = ydif[(ast - 1) &amp; CLOUD_MASK],
+		yaa  = ydif[(ast) &amp; CLOUD_MASK],
+		ap1 = (ast + 1) &amp; CLOUD_MASK;
 
 	aed = aed * 4 + 3;
 	ast = ast * 4 + 3;
@@ -410,19 +409,15 @@
 		a4c = ast + a4cstart * 4;
 
 	for (int a = ast; a &lt; aed; ++rc, ++ct) {
-		ydif[ap1] += (int) cloudThickness[a3c += 4] - cloudThickness[a += 4] * 2 + cloudThickness[a4c += 4];
-		ydif2[ap1] = (ydif1[ap1] = ydif[ap1] &gt;&gt; 1) &gt;&gt; 1;
+		int yap1 = ydif[ap1] += (int) cloudThickness[a3c += 4] - cloudThickness[a += 4] * 2 + cloudThickness[a4c += 4];
 
-		dif = ydif2[am2];
-		am2 = am1; dif += ydif1[am2];
-		am1 = aa;  dif += ydif[am1];
-		aa = ap1;  dif += ydif1[aa];
-		ap1 += 1;  dif += ydif2[ap1];
+		int dif = yam2 &gt;&gt; 2 +
+			(yam2 = yam1) &gt;&gt; 1 +
+			(yam1 = yaa) +
+			(yaa = yap1) &gt;&gt; 1 +
+			ydif[(++ap1) &amp;= CLOUD_MASK] &gt;&gt; 2;
 		dif &gt;&gt;= 4;
 
-		if (ap1 &gt;= CLOUD_SIZE)
-			ap1 = 0;
-
 		*ct++ = 128 + dif;
 		*ct++ = thicknessTransform[(*rc) &gt;&gt; 7];
 		*ct++ = 255;
@@ -456,16 +451,14 @@
 		int ifade=(int)(fade*fade*(3-2*fade)*256);
 		int ifade2=256-ifade;
 
-		for(int y=0, **bm=blendMatrix[a], **rm=randMatrix[a], **rm8=randMatrix[a+8]; y&lt;32; ++y, ++bm, ++rm, ++rm8) {
-			int *bmx=*bm, *rmx=*rm, *rm8x=*rm8;
-			for(int x=0; x&lt;32; ++x) {
-				(*bmx++)=((*rmx++)*ifade+(*rm8x++)*ifade2)&gt;&gt;8;
-			}
+		for(int y=0;y&lt;32;y++){
+			for(int x=0;x&lt;32;x++)
+				blendMatrix[a][y][x]=(randMatrix[a][y][x]*ifade+randMatrix[a+8][y][x]*ifade2)&gt;&gt;8;
 		}
 	}
 
-	for(int *rc=*rawClouds, *ec=rc+CLOUD_SIZE*CLOUD_SIZE; rc&lt;ec; ++rc)
-		(*rc)=0;
+	for(int a=0;a&lt;CLOUD_SIZE*CLOUD_SIZE;a++)
+		rawClouds[0][a]=0;
 
 	static int kernel[CLOUD_SIZE/4*CLOUD_SIZE/4];
 	for(int a=0; a&lt;CLOUD_DETAIL; ++a) {
@@ -519,10 +512,10 @@
 		}
 	}
 
-	unsigned char *ct=cloudThickness+3;
-	for(int *rc=*rawClouds, *ec=rc+CLOUD_SIZE*CLOUD_SIZE; rc&lt;ec; ct+=4, ++rc)
-		(*ct)=alphaTransform[(*rc)&gt;&gt;7];
 
+	for(int a=0;a&lt;CLOUD_SIZE*CLOUD_SIZE;a++)
+		cloudThickness[a*4+3]=alphaTransform[rawClouds[0][a]&gt;&gt;7];
+
 	cloudThickness[CLOUD_SIZE*CLOUD_SIZE*4+3]=alphaTransform[rawClouds[0][0]&gt;&gt;7];
 	// next line unused
 	cloudThickness[CLOUD_SIZE*CLOUD_SIZE*4+0]=cloudThickness[CLOUD_SIZE*CLOUD_SIZE*4+1]=cloudThickness[CLOUD_SIZE*CLOUD_SIZE*4+2]=0;
@@ -531,19 +524,14 @@
 	for(int a=0, a4=3; a&lt;CLOUD_SIZE; ++a, a4+=4) {
 		ydif[a]=(int)cloudThickness[(a4+3*CLOUD_SIZE*4)] + cloudThickness[(a4+2*CLOUD_SIZE*4)] + cloudThickness[(a4+1*CLOUD_SIZE*4)] + 
 			cloudThickness[(a4+0*CLOUD_SIZE*4)] - cloudThickness[(a4+(CLOUD_SIZE-1)*CLOUD_SIZE*4)] - 
-			cloudThickness[(a4+(CLOUD_SIZE-2)*CLOUD_SIZE*4)] - cloudThickness[(a4+(CLOUD_SIZE-3)*CLOUD_SIZE*4)];
-		ydif2[a]=(ydif1[a]=ydif[a]&gt;&gt;1)&gt;&gt;1;
+			cloudThickness[(a4+CLOUD_SIZE*(CLOUD_SIZE-2)*4)] - cloudThickness[(a4+CLOUD_SIZE*(CLOUD_SIZE-3)*4)];
 	}
 
-	int b=0;
-	ydif[(b)&amp;CLOUD_MASK]+=cloudThickness[(b-3*CLOUD_SIZE+CLOUD_SIZE*CLOUD_SIZE)*4+3];
-	ydif[(b)&amp;CLOUD_MASK]-=cloudThickness[(b)*4+3]*2;
-	ydif[(b)&amp;CLOUD_MASK]+=cloudThickness[(b+4*CLOUD_SIZE)*4+3];
-	ydif2[(b)&amp;CLOUD_MASK]=(ydif1[(b)&amp;CLOUD_MASK]=ydif[(b)&amp;CLOUD_MASK]&gt;&gt;1)&gt;&gt;1;
+	ydif[0] += cloudThickness[(0+CLOUD_SIZE*(CLOUD_SIZE-3))*4+3] - cloudThickness[0*4+3]*2 + cloudThickness[(0+4*CLOUD_SIZE)*4+3];
 
 	UpdatePart(0, CLOUD_SIZE*3-1, CLOUD_SIZE*(CLOUD_SIZE-3), 4*CLOUD_SIZE);
 	UpdatePart(CLOUD_SIZE*3-1, CLOUD_SIZE*(CLOUD_SIZE-4)-1, -3*CLOUD_SIZE, 4*CLOUD_SIZE);
-	UpdatePart(CLOUD_SIZE*(CLOUD_SIZE-4)-1, CLOUD_SIZE*CLOUD_SIZE, -3*CLOUD_SIZE, (4-CLOUD_SIZE)*CLOUD_SIZE);
+	UpdatePart(CLOUD_SIZE*(CLOUD_SIZE-4)-1, CLOUD_SIZE*CLOUD_SIZE, -3*CLOUD_SIZE, CLOUD_SIZE*(4-CLOUD_SIZE));
 /*
 	for(int a=0; a&lt;CLOUD_SIZE; ++a) {
 		cloudThickness[((int(48+camera-&gt;pos.z*CLOUD_SIZE*0.000025f)%256)*CLOUD_SIZE+a)*4+3]=0;

Modified: branches/caiinterface/rts/Rendering/Env/BasicSky.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BasicSky.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/BasicSky.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -44,8 +44,6 @@
 	int ***blendMatrix;
 
 	int ydif[CLOUD_SIZE];
-	int ydif1[CLOUD_SIZE]; // ydif &gt;&gt; 1
-	int ydif2[CLOUD_SIZE]; // ydif &gt;&gt; 2
 
 	unsigned char alphaTransform[1024];
 	unsigned char thicknessTransform[1024];

Modified: branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -82,39 +82,6 @@
 }
 
 
-static void PrintFboError(string fbo, GLenum error)
-{
-	switch(error) {
-		case GL_FRAMEBUFFER_COMPLETE_EXT:
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)has no images/buffers attached!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)missing a required image/buffer attachment!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)has mismatched image/buffer dimensions!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)colorbuffer attachments have different types!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)incomplete draw buffers!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)trying to read from a non-attached color buffer!&quot;);
-			break;
-		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)format is not supported by current graphics card/driver!&quot;);
-			break;
-		default:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)*UNKNOWN ERROR*&quot;);
-			break;
-	}
-}
-
-
 static string LoadShaderSource(const string&amp; file)
 {
 	CFileHandler fh(file);
@@ -309,15 +276,17 @@
 		blurDirLoc = glGetUniformLocation(blurShader, &quot;blurDir&quot;);
 		blurTexLoc = glGetUniformLocation(blurShader, &quot;texture&quot;);
 
-		glGenFramebuffersEXT(1,&amp;coastFBO);
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
-		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coastTexture[0], 0);
-		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, coastTexture[1], 0);
-		//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		coastFBO.reloadOnAltTab = true;
+		coastFBO.Bind();
+		coastFBO.AttachTexture(coastTexture[0], GL_TEXTURE_2D, GL_COLOR_ATTACHMENT0_EXT);
+		coastFBO.AttachTexture(coastTexture[1], GL_TEXTURE_2D, GL_COLOR_ATTACHMENT1_EXT);
+		//coastFBO.Unbind();
 
-		//! initialize
-		UploadCoastline(0, 0, gs-&gt;mapx, gs-&gt;mapy);
-		UpdateCoastmap(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+		if (coastFBO.CheckStatus(&quot;BUMPWATER(Coastmap)&quot;)) {
+			//! initialize
+			UploadCoastline(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+			UpdateCoastmap(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+		}else shoreWaves=false;
 	}
 
 
@@ -412,58 +381,26 @@
 		}
 
 		if (reflection) {
-			glGenRenderbuffersEXT(1, &amp;reflectRBO);
-			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, reflectRBO);
-			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, depthRBOFormat, reflTexSize, reflTexSize);
-
-			glGenFramebuffersEXT(1,&amp;reflectFBO);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
-			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, reflectRBO);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
-			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-				PrintFboError(&quot;reflection&quot;,status);
-				glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
-				glDeleteFramebuffersEXT(1,  &amp;reflectFBO);
-				reflectFBO = 0;
-			}
+			reflectFBO.Bind();
+			reflectFBO.CreateRenderBuffer(GL_DEPTH_ATTACHMENT_EXT, depthRBOFormat, reflTexSize, reflTexSize);
+			reflectFBO.AttachTexture(reflectTexture);
 		}
 
 		if (refraction&gt;0) {
-			glGenRenderbuffersEXT(1, &amp;refractRBO);
-			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, refractRBO);
-			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, depthRBOFormat, screenTextureX, screenTextureY);
-
-			glGenFramebuffersEXT(1,&amp;refractFBO);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
-			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, refractRBO);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, target, refractTexture, 0);
-			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-				PrintFboError(&quot;refraction&quot;,status);
-				glDeleteRenderbuffersEXT(1, &amp;refractRBO);
-				glDeleteFramebuffersEXT(1,  &amp;refractFBO);
-				refractFBO = 0;
-			}
+			refractFBO.Bind();
+			refractFBO.CreateRenderBuffer(GL_DEPTH_ATTACHMENT_EXT, depthRBOFormat, screenTextureX, screenTextureY);
+			refractFBO.AttachTexture(refractTexture,target);
 		}
 
 		if (dynWaves) {
-			glGenFramebuffersEXT(1,&amp;dynWavesFBO);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, normalTexture, 0);
-			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-				PrintFboError(&quot;dynamicWaves&quot;,status);
-				glDeleteFramebuffersEXT(1,  &amp;dynWavesFBO);
-				dynWavesFBO = 0;
-			}else{
+			dynWavesFBO.reloadOnAltTab = true;
+			dynWavesFBO.Bind();
+			dynWavesFBO.AttachTexture(normalTexture);
+			if (dynWavesFBO.CheckStatus(&quot;BUMPWATER(DynWaves)&quot;)) {
 				UpdateDynWaves(true); //! initialize
 			}
 		}
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		FBO::Unbind();
 	}
 
 
@@ -505,7 +442,7 @@
 		const float shadingZ = (float)gs-&gt;mapy / gs-&gt;pwr2mapy;
 
 		GLSLDefineConst4f(definitions, &quot;TexGenPlane&quot;, 1.0f/mapX, 1.0f/mapZ, shadingX/mapX, shadingZ/mapZ);
-		GLSLDefineConstf2(definitions, &quot;ShadingPlane&quot;, shadingX,shadingZ);
+		GLSLDefineConstf2(definitions, &quot;ShadingPlane&quot;, shadingX-0.2/gs-&gt;pwr2mapx,shadingZ-0.2/gs-&gt;pwr2mapy);
 	}
 
 	/** LOAD SHADERS **/
@@ -593,16 +530,6 @@
 	if (depthCopy)
 		glDeleteTextures(1, &amp;depthTexture);
 
-	if (reflectFBO) {
-		glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
-		glDeleteFramebuffersEXT(1,  &amp;reflectFBO);
-	}
-
-	if (refractFBO) {
-		glDeleteRenderbuffersEXT(1, &amp;refractRBO);
-		glDeleteFramebuffersEXT(1,  &amp;refractFBO);
-	}
-
 	glDeleteTextures(1, &amp;foamTexture);
 	glDeleteTextures(1, &amp;normalTexture);
 	for (int i = 0; i &lt; (int)caustTextures.size(); ++i) {
@@ -622,20 +549,13 @@
 		if (pboID)
 			glDeleteBuffers(1, &amp;pboID);
 
-		if (coastFBO)
-			glDeleteFramebuffersEXT(1, &amp;coastFBO);
-
 		glDeleteShader(blurFP);
 		glDeleteProgram(blurShader);
 	}
 
 	if (dynWaves) {
 		glDeleteTextures(1, &amp;normalTexture2);
-
 		delete[] tileOffsets;
-
-		if (dynWavesFBO)
-			glDeleteFramebuffersEXT(1, &amp;dynWavesFBO);
 	}
 }
 
@@ -679,8 +599,7 @@
 
 	}
 
-	if (coastmapNeedUpdate &amp;&amp; ((gs-&gt;frameNum + 14) % 15)==0)
-	{
+	if (coastmapNeedUpdate &amp;&amp; ((gs-&gt;frameNum + 14) % 15)==0) {
 		UpdateCoastmap(coastUpdateX1, coastUpdateZ1, coastUpdateX2, coastUpdateZ2);
 		coastmapNeedUpdate = false;
 	}
@@ -787,36 +706,58 @@
 	glDepthMask(GL_FALSE);
 	glDisable(GL_DEPTH_TEST);
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
-	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-	if (status == GL_FRAMEBUFFER_COMPLETE_EXT) {
-		glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
-		glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-		glMatrixMode(GL_TEXTURE);
-			glPushMatrix();
-			glLoadIdentity();
-			glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
-		glMatrixMode(GL_PROJECTION);
-			glPushMatrix();
-			glLoadIdentity();
-			glOrtho(0,1,0,1,-1,1);
-		glMatrixMode(GL_MODELVIEW);
-			glPushMatrix();
-			glLoadIdentity();
-			glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
+	coastFBO.Bind();
 
-		glViewport(0,0,gs-&gt;mapx, gs-&gt;mapy);
-		glUseProgram(blurShader);
+	glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
+	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	glMatrixMode(GL_TEXTURE);
+		glPushMatrix();
+		glLoadIdentity();
+		glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
+	glMatrixMode(GL_PROJECTION);
+		glPushMatrix();
+		glLoadIdentity();
+		glOrtho(0,1,0,1,-1,1);
+	glMatrixMode(GL_MODELVIEW);
+		glPushMatrix();
+		glLoadIdentity();
+		glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
 
-		int xmin = max(x1 - 10*2,0);
-		int xmax = min(x2 + 10*2,gs-&gt;mapx);
-		int ymin = max(y1 - 10*2,0);
-		int ymax = min(y2 + 10*2,gs-&gt;mapy);
-		int xsize = xmax - xmin;
-		int ysize = ymax - ymin;
+	glViewport(0,0,gs-&gt;mapx, gs-&gt;mapy);
+	glUseProgram(blurShader);
 
+	int xmin = max(x1 - 10*2,0);
+	int xmax = min(x2 + 10*2,gs-&gt;mapx);
+	int ymin = max(y1 - 10*2,0);
+	int ymax = min(y2 + 10*2,gs-&gt;mapy);
+	int xsize = xmax - xmin;
+	int ysize = ymax - ymin;
+
+	glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	glUniform1i(blurTexLoc,1);
+
+	glBegin(GL_QUADS);
+		glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+		glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+		glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+		glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
+	glEnd();
+
+	for (int i=0; i&lt;5; ++i){
+		glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
+		glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
+		glUniform1i(blurTexLoc,0);
+
+		glBegin(GL_QUADS);
+			glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+			glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+			glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+			glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
+		glEnd();
+
 		glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
 		glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
 		glUniform1i(blurTexLoc,1);
@@ -827,49 +768,25 @@
 			glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
 			glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
 		glEnd();
+	}
 
-		for (int i=0; i&lt;5; ++i){
-			glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
-			glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
-			glUniform1i(blurTexLoc,0);
+	glMatrixMode(GL_TEXTURE);
+		glPopMatrix();
+	glMatrixMode(GL_PROJECTION);
+		glPopMatrix();
+	glMatrixMode(GL_MODELVIEW);
+		glPopMatrix();
 
-			glBegin(GL_QUADS);
-				glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
-				glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
-				glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
-				glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
-			glEnd();
+	//glActiveTexture(GL_TEXTURE0);
+	//glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+	glGenerateMipmapEXT(GL_TEXTURE_2D);
 
-			glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
-			glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
-			glUniform1i(blurTexLoc,1);
+	glUseProgram(0);
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
-			glBegin(GL_QUADS);
-				glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
-				glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
-				glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
-				glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
-			glEnd();
-		}
-
-		glMatrixMode(GL_TEXTURE);
-			glPopMatrix();
-		glMatrixMode(GL_PROJECTION);
-			glPopMatrix();
-		glMatrixMode(GL_MODELVIEW);
-			glPopMatrix();
-
-		//glActiveTexture(GL_TEXTURE0);
-		//glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-		glGenerateMipmapEXT(GL_TEXTURE_2D);
-
-		glUseProgram(0);
-		glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	}else PrintFboError(&quot;coast&quot;,status);
-
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	coastFBO.Unbind();
 }
 
 
@@ -879,7 +796,7 @@
 
 void CBumpWater::UpdateDynWaves(const bool initialize)
 {
-	if (!dynWaves || !dynWavesFBO)
+	if (!dynWaves || !dynWavesFBO.IsValid())
 		return;
 
 	static const unsigned char tiles  = mapInfo-&gt;water.numTiles; //! (numTiles &lt;= 16)
@@ -896,7 +813,7 @@
 		}
 	}
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
+	dynWavesFBO.Bind();
 	glBindTexture(GL_TEXTURE_2D, normalTexture2);
 	glBlendFunc(GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA);
 	glBlendColor(1.0f,1.0f,1.0f, (initialize) ? 1.0f : (f + 1)/600.0f );
@@ -938,7 +855,7 @@
 		glPopMatrix();
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	dynWavesFBO.Unbind();
 
 	glBindTexture(GL_TEXTURE_2D, normalTexture);
 	glGenerateMipmapEXT(GL_TEXTURE_2D);
@@ -957,17 +874,13 @@
 	if (refraction == 1) {
 		//! _SCREENCOPY_ REFRACT TEXTURE
 		glBindTexture(target, refractTexture);
-		glEnable(target);
 		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
-		glDisable(target);
 	}
 
 	if (depthCopy) {
 		//! _SCREENCOPY_ DEPTH TEXTURE
 		glBindTexture(target, depthTexture);
-		glEnable(target);
 		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
-		glDisable(target);
 	}
 
 	glDisable(GL_ALPHA_TEST);
@@ -1005,8 +918,8 @@
 void CBumpWater::DrawRefraction(CGame* game)
 {
 	//! _RENDER_ REFRACTION TEXTURE
-	if (refractFBO)
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
+	if (refractFBO.IsValid())
+		refractFBO.Bind();
 
 	camera-&gt;Update(false);
 	glViewport(0,0,screenTextureX,screenTextureY);
@@ -1038,13 +951,11 @@
 	game-&gt;SetDrawMode(CGame::normalDraw);
 	drawRefraction=false;
 
-	if (refractFBO) {
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	if (refractFBO.IsValid()) {
+		refractFBO.Unbind();
 	}else{
 		glBindTexture(target, refractTexture);
-		glEnable(target);
 		glCopyTexSubImage2D(target,0,0,0,0,0,screenTextureX,screenTextureY);
-		glDisable(target);
 	}
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
@@ -1058,8 +969,8 @@
 void CBumpWater::DrawReflection(CGame* game)
 {
 	//! CREATE REFLECTION TEXTURE
-	if (reflectFBO)
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
+	if (reflectFBO.IsValid())
+		reflectFBO.Bind();
 
 //	CCamera *realCam = camera;
 //	camera = new CCamera(*realCam);
@@ -1094,13 +1005,11 @@
 	drawReflection=false;
 	glDisable(GL_CLIP_PLANE2);
 
-	if (reflectFBO) {
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	if (reflectFBO.IsValid()) {
+		reflectFBO.Unbind();
 	}else{
 		glBindTexture(GL_TEXTURE_2D, reflectTexture);
-		glEnable(GL_TEXTURE_2D);
 		glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,reflTexSize, reflTexSize);
-		glDisable(GL_TEXTURE_2D);
 	}
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);

Modified: branches/caiinterface/rts/Rendering/Env/BumpWater.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BumpWater.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/Env/BumpWater.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -5,6 +5,7 @@
 #ifndef __BUMP_WATER_H__
 #define __BUMP_WATER_H__
 
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;BaseWater.h&quot;
 
@@ -46,12 +47,10 @@
 	int  screenTextureX;
 	int  screenTextureY;
 
-	GLuint reflectRBO;
-	GLuint refractRBO;
-	GLuint reflectFBO;
-	GLuint refractFBO;
-	GLuint coastFBO;
-	GLuint dynWavesFBO;
+	FBO reflectFBO;
+	FBO refractFBO;
+	FBO coastFBO;
+	FBO dynWavesFBO;
 
 	GLuint displayList;
 

Modified: branches/caiinterface/rts/Rendering/GL/FBO.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GL/FBO.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/GL/FBO.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -1,10 +1,9 @@
 /**
  * @file FBO.cpp
  * @brief EXT_framebuffer_object implementation
- * @author Christopher Han &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">xiphux at gmail.com</A>&gt;
  *
  * EXT_framebuffer_object class implementation
- * Copyright (C) 2005.  Licensed under the terms of the
+ * Copyright (C) 2008.  Licensed under the terms of the
  * GNU GPL, v2 or later.
  */
 #include &quot;StdAfx.h&quot;
@@ -12,123 +11,371 @@
 #include &lt;vector&gt;
 #include &quot;mmgr.h&quot;
 
-#include &quot;IFramebuffer.h&quot;
 #include &quot;FBO.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
 
+std::vector&lt;FBO*&gt; FBO::fboList;
+std::map&lt;GLuint,FBO::TexData*&gt; FBO::texBuf;
 
-IFramebuffer::~IFramebuffer()
+
+/**
+ * Returns if the current gpu supports Framebuffer Objects
+ */
+bool FBO::IsSupported()
 {
+	return (GLEW_EXT_framebuffer_object);
 }
 
 
-IFramebuffer* instantiate_fb(const int w, const int h, const int requires)
+/**
+ * Detects the textureTarget just by the textureName/ID
+ */
+GLenum FBO::GetTextureTargetByID(const GLuint id, const unsigned int i)
 {
-	if (GLEW_EXT_framebuffer_object) {
-		//logOutput.Print(&quot;Using EXT_framebuffer_object&quot;);
-		return SAFE_NEW FBO(requires, w, h);
+	static GLenum _targets[ 4 ] = { GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_1D, GL_TEXTURE_3D };
+	GLint format;
+	glBindTexture(_targets[i],id);
+	glGetTexLevelParameteriv(_targets[i], 0, GL_TEXTURE_INTERNAL_FORMAT, &amp;format);
+
+	if (format!=1) {
+		return _targets[i];
+	} else if (i&lt;3) {
+		return GetTextureTargetByID(id, i+1);
+	} else	return -1;
+}
+
+
+/**
+ * Makes a copy of a texture/RBO in the system ram
+ */
+void FBO::DownloadAttachment(const GLenum attachment)
+{
+	GLuint target;
+	glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT, attachment,
+		GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT,
+		(GLint*)&amp;target);
+	GLuint id;
+	glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT, attachment,
+		GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT,
+		(GLint*)&amp;id);
+
+	if (target==GL_NONE || id==0)
+		return;
+
+	if (texBuf.find(id)!=texBuf.end())
+		return;
+
+	if (target==GL_TEXTURE) {
+		target = GetTextureTargetByID(id);
+
+		if (target&lt;0)
+			return;
 	}
-	//logOutput.Print(&quot;No supported pixel buffer found&quot;);
-	return NULL;
+
+	struct FBO::TexData* tex = SAFE_NEW FBO::TexData;
+	tex-&gt;id = id;
+	tex-&gt;target = target;
+
+	int bits = 0;
+
+	if (target==GL_RENDERBUFFER_EXT) {
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, id);
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_WIDTH_EXT,  &amp;tex-&gt;xsize);
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_HEIGHT_EXT, &amp;tex-&gt;ysize);
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_INTERNAL_FORMAT_EXT, (GLint*)&amp;tex-&gt;format);
+
+		GLint _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_RED_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_GREEN_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_BLUE_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_ALPHA_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_DEPTH_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_STENCIL_SIZE_EXT, &amp;_cbits); bits += _cbits;
+	} else {
+		glBindTexture(target,id);
+
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_WIDTH, &amp;tex-&gt;xsize);
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_HEIGHT, &amp;tex-&gt;ysize);
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_DEPTH, &amp;tex-&gt;zsize);
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_INTERNAL_FORMAT, (GLint*)&amp;tex-&gt;format);
+
+		GLint _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_RED_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_GREEN_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_BLUE_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_ALPHA_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_DEPTH_SIZE, &amp;_cbits); bits += _cbits;
+	}
+
+
+	switch (target) {
+		case GL_TEXTURE_3D:
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*tex-&gt;ysize*tex-&gt;zsize*(bits/8)];
+			glGetTexImage(tex-&gt;target,0,/*FIXME*/GL_RGBA,/*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			break;
+		case GL_TEXTURE_1D:
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*(bits/8)];
+			glGetTexImage(tex-&gt;target,0,/*FIXME*/GL_RGBA,/*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			break;
+		case GL_RENDERBUFFER_EXT:
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*tex-&gt;ysize*(bits/8)];
+			glReadBuffer(attachment);
+			glReadPixels(0, 0, tex-&gt;xsize, tex-&gt;ysize, /*FIXME*/GL_RGBA, /*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			break;
+		default: //GL_TEXTURE_2D &amp; GL_TEXTURE_RECTANGLE
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*tex-&gt;ysize*(bits/8)];
+			glGetTexImage(tex-&gt;target,0,/*FIXME*/GL_RGBA,/*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+	}
+	texBuf[id] = tex;
 }
 
+/**
+ * @brief GLContextLost
+ */
+void FBO::GLContextLost()
+{
+	//GML_STDMUTEX_LOCK(draw);
 
+	GLint oldReadBuffer;
+
+	for (std::vector&lt;FBO*&gt;::iterator fi=fboList.begin(); fi!=fboList.end(); ++fi) {
+		if ((*fi)-&gt;reloadOnAltTab) {
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, (*fi)-&gt;fboId);
+			glGetIntegerv(GL_READ_BUFFER,&amp;oldReadBuffer);
+
+			for(int i = 0; i &lt; 15; ++i) {
+				DownloadAttachment(GL_COLOR_ATTACHMENT0_EXT + i);
+			}
+			DownloadAttachment(GL_DEPTH_ATTACHMENT_EXT);
+			DownloadAttachment(GL_STENCIL_ATTACHMENT_EXT);
+
+			glReadBuffer(oldReadBuffer);
+		}
+	}
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+}
+
+
 /**
+ * @brief GLContextReinit
+ */
+void FBO::GLContextReinit()
+{
+	//GML_STDMUTEX_LOCK(draw);
+	for (std::map&lt;GLuint,FBO::TexData*&gt;::iterator ti=texBuf.begin(); ti!=texBuf.end(); ++ti) {
+		FBO::TexData* tex = ti-&gt;second;
+
+		if (glIsTexture(tex-&gt;id)) {
+			glBindTexture(tex-&gt;target,tex-&gt;id);
+			//todo: regen mipmaps?
+			switch (tex-&gt;target) {
+				case GL_TEXTURE_3D:
+					//glTexSubImage3D(tex-&gt;target, 0, 0,0,0, tex-&gt;xsize, tex-&gt;ysize, tex-&gt;zsize, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					glTexImage3D(tex-&gt;target, 0, tex-&gt;format, tex-&gt;xsize, tex-&gt;ysize, tex-&gt;zsize, 0, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					break;
+				case GL_TEXTURE_1D:
+					//glTexSubImage1D(tex-&gt;target, 0, 0, tex-&gt;xsize, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					glTexImage1D(tex-&gt;target, 0, tex-&gt;format, tex-&gt;xsize, /*FIXME?*/GL_RGBA, 0, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					break;
+				default: //GL_TEXTURE_2D &amp; GL_TEXTURE_RECTANGLE
+					//glTexSubImage2D(tex-&gt;target, 0, 0,0, tex-&gt;xsize, tex-&gt;ysize, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					glTexImage2D(tex-&gt;target, 0, tex-&gt;format, tex-&gt;xsize, tex-&gt;ysize, 0, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			}
+		}else if (glIsRenderbufferEXT(tex-&gt;id)) {
+			//FIXME
+		}
+
+		delete[] tex-&gt;pixels;
+		delete tex;
+	}
+	texBuf.clear();
+}
+
+
+/**
  * Tests for support of the EXT_framebuffer_object
  * extension, and generates a framebuffer if supported
  */
-FBO::FBO(int requires, int w, int h) : frameBuffer(0), depthRenderBuffer(0), requires(requires)
+FBO::FBO() : fboId(0), reloadOnAltTab(false)
 {
-	glGenFramebuffersEXT(1,&amp;frameBuffer);
-	// Is a depth renderbuffer needed?
-	if ((requires &amp; FBO_NEED_DEPTH) &amp;&amp; !(requires &amp; FBO_NEED_DEPTH_TEXTURE))
-	{
-		select();
-		glGenRenderbuffersEXT(1, &amp;depthRenderBuffer);
-		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depthRenderBuffer);
-		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, w, h);
-		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
-										GL_RENDERBUFFER_EXT, depthRenderBuffer);
-		deselect();
+	if (IsSupported()) {
+		glGenFramebuffersEXT(1,&amp;fboId);
+
+		// we need to bind it once, else it isn't valid
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboId);
+
+		//GML_STDMUTEX_LOCK(fbo);
+		fboList.push_back(this);
 	}
 }
 
+
 /**
  * Unbinds the framebuffer and deletes it
  */
 FBO::~FBO()
 {
 	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-	if (frameBuffer)
-		glDeleteFramebuffersEXT(1,&amp;frameBuffer);
+	if (fboId)
+		glDeleteFramebuffersEXT(1, &amp;fboId);
 
 	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
-	if (depthRenderBuffer)
-		glDeleteRenderbuffersEXT(1, &amp;depthRenderBuffer);
+	for (std::vector&lt;GLuint&gt;::iterator ri=myRBOs.begin(); ri!=myRBOs.end(); ++ri) {
+		glDeleteRenderbuffersEXT(1, &amp;(*ri));
+	}
+
+	//GML_STDMUTEX_LOCK(fbo);
+	for (std::vector&lt;FBO*&gt;::iterator fi=fboList.begin(); fi!=fboList.end(); ++fi) {
+		if (*fi==this) {
+			fboList.erase(fi);
+			break;
+		}
+	}
+
+	// seems the application exits and we are the last fbo left
+	// so we delete the remaining alloc'ed stuff
+	if (fboList.empty()) {
+		for (std::map&lt;GLuint,FBO::TexData*&gt;::iterator ti=texBuf.begin(); ti!=texBuf.end(); ++ti) {
+			FBO::TexData* tex = ti-&gt;second;
+			delete[] tex-&gt;pixels;
+			delete tex;
+		}
+		texBuf.clear();
+	}
 }
 
+
 /**
- * Tests whether or not we have a valid framebuffer
+ * Tests whether or not if we have a valid framebuffer
  */
-bool FBO::valid(void)
+bool FBO::IsValid()
 {
-	return frameBuffer != 0;
+	return (fboId!=0);
 }
 
+
 /**
  * Makes the framebuffer the active framebuffer context
  */
-void FBO::select(void)
+void FBO::Bind(void)
 {
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, frameBuffer);
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboId);
 }
 
+
 /**
  * Unbinds the framebuffer from the current context
  */
-void FBO::deselect(void)
+void FBO::Unbind()
 {
 	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 }
 
+
 /**
  * Tests if the framebuffer is a complete and
  * legitimate framebuffer
  */
-bool FBO::checkFBOStatus(void)
+bool FBO::CheckStatus(std::string name)
 {
-	GLenum status;
-	status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-	if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-		//logOutput.Print(&quot;FBO is not GL_FRAMEBUFFER_COMPLETE_EXT: 0x%X&quot;, status);
-		assert(false);
-		return false;
+	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+	switch(status) {
+		case GL_FRAMEBUFFER_COMPLETE_EXT:
+			return true;
+		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: has no images/buffers attached!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: missing a required image/buffer attachment!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: has mismatched image/buffer dimensions!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: colorbuffer attachments have different types!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: incomplete draw buffers!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: trying to read from a non-attached color buffer!&quot;);
+			break;
+		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot; error: GL_FRAMEBUFFER_UNSUPPORTED_EXT&quot;);
+			break;
+		default:
+			logOutput.Print(std::string(&quot;FBO-&quot;+name+&quot; error: 0x%X&quot;).c_str(),status);
+			break;
 	}
-	return true;
+	return false;
 }
 
+
 /**
+ * Returns the current framebuffer status
+ */
+GLenum FBO::GetStatus()
+{
+	return glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+}
+
+
+/**
  * Attaches a GL texture to the framebuffer
  */
-void FBO::attachTexture(GLuint tex, const unsigned int textype, FramebufferAttachType attachtype)
+void FBO::AttachTexture(const GLuint texId, const GLenum texTarget, const GLenum attachment, const int mipLevel, const int zSlice )
 {
-	GLenum glattachtype;
+	if (texTarget == GL_TEXTURE_1D) {
+		glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, attachment, GL_TEXTURE_1D, texId, mipLevel);
+	} else if (texTarget == GL_TEXTURE_3D) {
+		glFramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT, attachment, GL_TEXTURE_3D, texId, mipLevel, zSlice);
+	} else {
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, texTarget, texId, mipLevel);
+	}
+}
 
-	switch (attachtype)
-	{
-		case FBO_ATTACH_DEPTH:
-			assert (requires &amp; FBO_NEED_DEPTH_TEXTURE);
-			glattachtype = GL_DEPTH_ATTACHMENT_EXT;
-			break;
-		case FBO_ATTACH_COLOR:
-			assert (requires &amp; FBO_NEED_COLOR);
-			glattachtype = GL_COLOR_ATTACHMENT0_EXT;
-			break;
-		default:
-			assert(false);
-			break;
+
+/**
+ * Attaches a GL RenderBuffer to the framebuffer
+ */
+void FBO::AttachRenderBuffer(const GLuint rboId, const GLenum attachment)
+{
+	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, attachment, GL_RENDERBUFFER_EXT, rboId);
+}
+
+
+/**
+ * Unattaches an attachment from the framebuffer
+ */
+void FBO::Unattach(const GLenum attachment)
+{
+	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, GL_TEXTURE_2D, 0, 0);
+}
+
+
+/**
+ * Unattaches any attachments from the framebuffer
+ */
+void FBO::UnattachAll()
+{
+	for(int i = 0; i &lt; 15; ++i) {
+		Unattach(GL_COLOR_ATTACHMENT0_EXT + i);
 	}
-	select();
-	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, glattachtype, textype, tex, 0);
-	deselect();
+	Unattach(GL_DEPTH_ATTACHMENT_EXT);
+	Unattach(GL_STENCIL_ATTACHMENT_EXT);
 }
+
+
+/**
+ * Creates and attaches a RBO
+ */
+void FBO::CreateRenderBuffer(const GLenum attachment, const GLenum format, const GLsizei width, const GLsizei height)
+{
+	GLuint rbo;
+	glGenRenderbuffersEXT(1, &amp;rbo);
+	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbo);
+	glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
+	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, attachment, GL_RENDERBUFFER_EXT, rbo);
+	myRBOs.push_back(rbo);
+}

Modified: branches/caiinterface/rts/Rendering/GL/FBO.h
===================================================================
--- branches/caiinterface/rts/Rendering/GL/FBO.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/GL/FBO.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -1,79 +1,167 @@
 /**
  * @file FBO.h
  * @brief EXT_framebuffer_object
- * @author Christopher Han &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">xiphux at gmail.com</A>&gt;
  *
  * EXT_framebuffer_object class definition
- * Copyright (C) 2005.  Licensed under the terms of the
+ * Copyright (C) 2008.  Licensed under the terms of the
  * GNU GPL, v2 or later.
  *
- * Framebuffer abstraction added by Jelmer Cnossen
  */
 #ifndef FBO_H
 #define FBO_H
 
+#include &lt;map&gt;
+
 #include &quot;myGL.h&quot;
 
+//todo: add multisample buffers
+
 /**
  * @brief FBO
  *
- * Framebuffer Object class. Derived from the
- * abstract IFramebuffer class
+ * Framebuffer Object class.
  */
-class FBO : public IFramebuffer
+class FBO
 {
 public:
 	/**
-	 * @brief check FBO status
+	 * @brief IsSupported
+	 *
+	 * if FrameBuffers are supported by the current platform
 	 */
-	bool checkFBOStatus(void);
+	static bool IsSupported();
 
 	/**
-	 * @brief attach texture
-	 * @param tex texture to attach
-	 * @param textype type of texture
-	 * @param attachtype what kind of target to attach as
+	 * @brief Constructor
 	 */
-	void attachTexture(const GLuint tex, const unsigned int textype, FramebufferAttachType attachtype);
+	FBO();
 
 	/**
-	 * @brief select
+	 * @brief Destructor
 	 */
-	void select(void);
+	~FBO();
 
 	/**
-	 * @brief deselect
+	 * @brief fboId
+	 *
+	 * GLuint pointing to the current framebuffer
 	 */
-	void deselect(void);
+	GLuint fboId;
 
 	/**
-	 * @brief valid
+	 * @brief reloadOnAltTab
+	 *
+	 * bool save all attachments in system RAM and reloaded them on OpenGL-Context lost (alt-tab) (default: false)
+	 */
+	bool reloadOnAltTab;
+
+	/**
+	 * @brief check FBO status
+	 */
+	bool CheckStatus(std::string name);
+
+	/**
+	 * @brief get FBO status
+	 */
+	GLenum GetStatus();
+
+	/**
+	 * @brief IsValid
 	 * @return whether a valid framebuffer exists
 	 */
-	bool valid(void);
+	bool IsValid();
 
+	/**
+	 * @brief AttachTexture
+	 * @param texTarget texture target (GL_TEXTURE_2D etc.)
+	 * @param texId texture to attach
+	 * @param attachment (GL_COLOR_ATTACHMENT0_EXT etc.)
+	 * @param mipLevel miplevel to attach
+	 * @param zSlice z offset (3d textures only)
+	 */
+	void AttachTexture(const GLuint texId, const GLenum texTarget = GL_TEXTURE_2D, const GLenum attachment = GL_COLOR_ATTACHMENT0_EXT, const int mipLevel = 0, const int zSlice = 0);
+
+	/**
+	 * @brief AttachRenderBuffer
+	 * @param rboId RenderBuffer to attach
+	 * @param attachment
+	 */
+	void AttachRenderBuffer(const GLuint rboId, const GLenum attachment = GL_COLOR_ATTACHMENT0_EXT);
+
+	/**
+	 * @brief Creates a RenderBufferObject and attachs it to the FBO (it is also auto destructed)
+	 * @param attachment
+	 * @param format
+	 * @param width
+	 * @param height
+	 */
+	void CreateRenderBuffer(const GLenum attachment, const GLenum format, const GLsizei width, const GLsizei height);
+
+	/**
+	 * @brief Unattach
+	 * @param attachment
+	 */
+	void Unattach(const GLenum attachment);
+
+	/**
+	 * @brief UnattachAll
+	 */
+	void UnattachAll();
+
+	/**
+	 * @brief Bind
+	 */
+	void Bind();
+
+	/**
+	 * @brief Unbind
+	 */
+	static void Unbind();
+
+
+
+	/**
+	 * @brief GLContextLost (post atl-tab)
+	 */
+	static void GLContextLost();
+
+	/**
+	 * @brief GLContextReinit (pre atl-tab)
+	 */
+	static void GLContextReinit();
+
+
 private:
 	/**
-	 * @brief Constructor
+	 * @brief rbos
+	 *
+	 * List with all Renderbuffer Objects that should be destructed with the FBO
 	 */
-	FBO(int requires, int w, int h);
+	std::vector&lt;GLuint&gt; myRBOs;
 
+
+	static std::vector&lt;FBO*&gt; fboList;
+	struct TexData{
+		GLuint id;
+		unsigned char* pixels;
+		GLsizei xsize,ysize,zsize;
+		GLenum target,format,type;
+	};
+	static std::map&lt;GLuint,TexData*&gt; texBuf;
+
 	/**
-	 * @brief Destructor
+	 * @brief DownloadAttachment
+	 *
+	 * copies the attachment content to sysram
 	 */
-	~FBO();
+	static void DownloadAttachment(const GLenum attachment);
 
 	/**
-	 * @brief framebuffer
+	 * @brief GetTextureTargetByID
 	 *
-	 * GLuint pointing to the current framebuffer
+	 * detects the textureTarget just by the textureName/ID
 	 */
-	GLuint frameBuffer;
-	GLuint depthRenderBuffer;
-	int requires;
-
-	// instantiate_fb is the only code where new FBOs may be created
-	friend IFramebuffer* instantiate_fb(const int w, const int h, const int requires);
+	static GLenum GetTextureTargetByID(const GLuint id, const unsigned int i = 0);
 };
 
 #endif /* FBO_H */

Deleted: branches/caiinterface/rts/Rendering/GL/IFramebuffer.h
===================================================================
--- branches/caiinterface/rts/Rendering/GL/IFramebuffer.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/GL/IFramebuffer.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -1,38 +0,0 @@
-/*
- * IFramebuffer.h
- * IFramebuffer interface
- * Framebuffer abstraction by Jelmer Cnossen
- */
-#ifndef _IFRAMEBUFFER_H
-#define _IFRAMEBUFFER_H
-
-#include &quot;myGL.h&quot;
-
-enum FramebufferAttachType
-{
-	FBO_ATTACH_COLOR = 1,
-	FBO_ATTACH_DEPTH = 2,
-};
-
-class IFramebuffer
-{
-public:
-	virtual ~IFramebuffer();
-
-	virtual bool checkFBOStatus(void) = 0;
-	virtual void attachTexture(const GLuint tex, const unsigned int textype, FramebufferAttachType attachtype) = 0;
-	virtual void select(void) = 0;
-	virtual void deselect(void) = 0;
-	virtual bool valid(void) = 0;
-};
-
-enum FramebufferProperties
-{
-	FBO_NEED_DEPTH = 1, // zbuffering is needed, but only for rendering
-	FBO_NEED_DEPTH_TEXTURE = 2, // for shadow mapping
-	FBO_NEED_COLOR = 4
-};
-
-IFramebuffer* instantiate_fb(const int w, const int h, const int requires);
-
-#endif /* _IFRAMEBUFFER_H */

Modified: branches/caiinterface/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GL/myGL.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/GL/myGL.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -19,7 +19,7 @@
 #include &quot;Util.h&quot;
 #include &quot;Exceptions.h&quot;
 
-#include &quot;IFramebuffer.h&quot;
+#include &quot;FBO.h&quot;
 
 using namespace std;
 

Modified: branches/caiinterface/rts/Rendering/GLContext.h
===================================================================
--- branches/caiinterface/rts/Rendering/GLContext.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/GLContext.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -24,6 +24,8 @@
 //            (use &quot;data&quot; for the pointer to the instance).
 
 
+// TODO: add event driven system (like alttab, resolution changed, dualscreen, ...)
+
 namespace GLContext
 {
 	typedef void (*Func)(void* data);

Modified: branches/caiinterface/rts/Rendering/ShadowHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/ShadowHandler.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/ShadowHandler.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -13,8 +13,8 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;GL/myGL.h&quot;
-#include &quot;GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;EventHandler.h&quot;
 
@@ -28,7 +28,7 @@
 bool CShadowHandler::firstInstance = true;
 
 
-CShadowHandler::CShadowHandler(void): fb(0)
+CShadowHandler::CShadowHandler(void)
 {
 	const bool tmpFirstInstance = firstInstance;
 	firstInstance = false;
@@ -88,8 +88,6 @@
 
 	if (configValue == 0) {
 		// free any resources allocated by InitDepthTarget()
-		delete fb;
-		fb = NULL;
 		glDeleteTextures(1, &amp;shadowTexture);
 		shadowTexture = 0;
 		return; // drawShadows is still false
@@ -104,10 +102,7 @@
 	// this can be enabled for debugging
 	// it turns the shadow render buffer in a buffer with color
 	bool useColorTexture = false;
-
-	fb = instantiate_fb(shadowMapSize, shadowMapSize,
-			(useColorTexture ? FBO_NEED_COLOR | FBO_NEED_DEPTH : FBO_NEED_DEPTH_TEXTURE));
-	if (!(fb &amp;&amp; fb-&gt;valid())) {
+	if (!fb.IsValid()) {
 		logOutput.Print(&quot;framebuffer not valid!&quot;);
 		return false;
 	}
@@ -124,23 +119,23 @@
 		glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
 	}
 	glBindTexture(GL_TEXTURE_2D, 0);
-	fb-&gt;select();
+	fb.Bind();
+	if (useColorTexture)
+		fb.AttachTexture(shadowTexture);
+	else
+		fb.AttachTexture(shadowTexture, GL_TEXTURE_2D, GL_DEPTH_ATTACHMENT_EXT);
 	int buffer = useColorTexture ? GL_COLOR_ATTACHMENT0_EXT : GL_NONE;
 	glDrawBuffer(buffer);
 	glReadBuffer(buffer);
-	if (useColorTexture)
-		fb-&gt;attachTexture(shadowTexture, GL_TEXTURE_2D, FBO_ATTACH_COLOR);
-	else
-		fb-&gt;attachTexture(shadowTexture, GL_TEXTURE_2D, FBO_ATTACH_DEPTH);
-	fb-&gt;checkFBOStatus();
-	return true;
+	bool status = fb.CheckStatus(&quot;SHADOW&quot;);
+	fb.Unbind();
+	return status;
 }
 
 CShadowHandler::~CShadowHandler(void)
 {
 	if (drawShadows)
 		glDeleteTextures(1, &amp;shadowTexture);
-	delete fb;
 }
 
 void CShadowHandler::DrawShadowPasses(void)
@@ -170,7 +165,7 @@
 
 void CShadowHandler::CreateShadows(void)
 {
-	fb-&gt;select();
+	fb.Bind();
 
 	glDisable(GL_BLEND);
 	glDisable(GL_LIGHTING);
@@ -250,7 +245,7 @@
 	glShadeModel(GL_SMOOTH);
 	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
 
-	fb-&gt;deselect();
+	fb.Unbind();
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 }
 

Modified: branches/caiinterface/rts/Rendering/ShadowHandler.h
===================================================================
--- branches/caiinterface/rts/Rendering/ShadowHandler.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/ShadowHandler.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -4,9 +4,8 @@
 #include &quot;Matrix44f.h&quot;
 #include &quot;GL/myGL.h&quot;
 #include &lt;vector&gt;
+#include &quot;Rendering/GL/FBO.h&quot;
 
-class IFramebuffer;
-
 class CShadowHandler
 {
 public:
@@ -52,7 +51,7 @@
 		float maxz;
 	};
 	std::vector&lt;fline&gt; left;
-	IFramebuffer *fb;
+	FBO fb;
 
 	bool firstDraw;
 	static bool firstInstance;

Modified: branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -47,7 +47,7 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+extern gmlClientServer&lt;void, int,CUnit*&gt; *gmlProcessor;
 #endif
 
 CUnitDrawer* unitDrawer;
@@ -425,7 +425,7 @@
 	#ifdef DIRECT_CONTROL_ALLOWED
 		mt_excludeUnit=excludeUnit;
 	#endif
-		gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;renderUnits,uh-&gt;renderUnits.size(),50,100,TRUE);
+		gmlProcessor-&gt;Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;renderUnits,uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
 	else {
 #endif
@@ -699,7 +699,7 @@
 
 #ifdef USE_GML
 	if(multiThreadDrawUnitShadow) {
-		gmlProcessor.Work(NULL, NULL, &amp;CUnitDrawer::DoDrawUnitShadowMT, this, gmlThreadCount, FALSE,
+		gmlProcessor-&gt;Work(NULL, NULL, &amp;CUnitDrawer::DoDrawUnitShadowMT, this, gmlThreadCount, FALSE,
 		  &amp;uh-&gt;renderUnits, uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
 	else {
@@ -927,7 +927,7 @@
 	// cloaked units and living ghosted buildings (stored in same vector)
 	for (GML_VECTOR&lt;CUnit*&gt;::iterator ui = dC.begin(); ui != dC.end(); ++ui) {
 		CUnit* unit = *ui;
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 		if(unit==NULL)
 			continue;
 #endif

Modified: branches/caiinterface/rts/Sim/Misc/LosHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosHandler.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Misc/LosHandler.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -62,7 +62,6 @@
 		CR_MEMBER(toBeDeleted),
 		CR_MEMBER(delayQue),
 //		CR_MEMBER(Points),
-		CR_MEMBER(terrainHeight),
 //		CR_MEMBER(lostables)
 		CR_RESERVED(31),
 		CR_POSTLOAD(PostLoad)
@@ -105,22 +104,6 @@
 	for (int a=1;a&lt;=MAX_LOS_TABLE;++a) {
 		OutputTable(a);
 	}
-
-	for(int a=0;a&lt;256;++a)
-		terrainHeight[a]=-15;
-
-	terrainHeight[6]=30;
-	terrainHeight[7]=30;
-	terrainHeight[8]=30;
-
-	terrainHeight[26]=30;
-	terrainHeight[27]=30;
-	terrainHeight[28]=30;
-	terrainHeight[29]=30;
-	terrainHeight[31]=30;
-
-	for(int a=32;a&lt;64;++a)
-		terrainHeight[a]=10;
 }
 
 
@@ -210,17 +193,21 @@
 	const int allyteam  = instance-&gt;allyteam;
 	const int mapSquare = instance-&gt;baseSquare;
 
+	float* heightmap = readmap-&gt;mipHeightmap[losMipLevel];
+	vector&lt;unsigned short&gt;* allyLosMap = &amp;losMap[allyteam];
+
 	LosAddAir(instance);
 
 	const int tablenum = std::min(instance-&gt;losSize, MAX_LOS_TABLE);
 	LosTable&amp; table = lostables[tablenum - 1];
 
 	instance-&gt;losSquares.push_back(mapSquare);
-	losMap[allyteam][mapSquare]++;
+	(*allyLosMap)[mapSquare]++;
 
+	const float baseHeight = heightmap[mapSquare] + instance-&gt;baseHeight-15;
+
 	for(LosTable::iterator li=table.begin();li!=table.end();++li){
 		LosLine&amp; line=*li;
-		const float baseHeight=readmap-&gt;mipHeightmap[losMipLevel][mapSquare]+instance-&gt;baseHeight-15;
 		float maxAng1 = -1e6f;
 		float maxAng2 = -1e6f;
 		float maxAng3 = -1e6f;
@@ -228,53 +215,53 @@
 		float r = 1;
 		for(LosLine::iterator linei=line.begin();linei!=line.end();++linei){
 			float invR=1.0f/r;
-			int square=mapSquare+linei-&gt;x+linei-&gt;y*losSizeX;
-			float dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+			int square=mapSquare + linei-&gt;x + linei-&gt;y*losSizeX;
+			float dh=heightmap[square] - baseHeight;
 			float ang=dh*invR;
 			if(ang&gt;maxAng1){
 				instance-&gt;losSquares.push_back(square);
-				losMap[allyteam][square]++;
+				(*allyLosMap)[square]++;
 			}
-			dh+=terrainHeight[0];
+			dh-=15;
 			ang=dh*invR;
 			if(ang&gt;maxAng1){
 				maxAng1=ang;
 			}
 
-			square=mapSquare-linei-&gt;x-linei-&gt;y*losSizeX;
-			dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+			square=mapSquare - linei-&gt;x - linei-&gt;y*losSizeX;
+			dh=heightmap[square] - baseHeight;
 			ang=dh*invR;
 			if(ang&gt;maxAng2){
 				instance-&gt;losSquares.push_back(square);
-				losMap[allyteam][square]++;
+				(*allyLosMap)[square]++;
 			}
-			dh+=terrainHeight[0];
+			dh-=15;
 			ang=dh*invR;
 			if(ang&gt;maxAng2){
 				maxAng2=ang;
 			}
 
-			square=mapSquare-linei-&gt;x*losSizeX+linei-&gt;y;
-			dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+			square=mapSquare - linei-&gt;x*losSizeX + linei-&gt;y;
+			dh=heightmap[square] - baseHeight;
 			ang=dh*invR;
 			if(ang&gt;maxAng3){
 				instance-&gt;losSquares.push_back(square);
-				losMap[allyteam][square]++;
+				(*allyLosMap)[square]++;
 			}
-			dh+=terrainHeight[0];
+			dh-=15;
 			ang=dh*invR;
 			if(ang&gt;maxAng3){
 				maxAng3=ang;
 			}
 
-			square=mapSquare+linei-&gt;x*losSizeX-linei-&gt;y;
-			dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+			square=mapSquare + linei-&gt;x*losSizeX - linei-&gt;y;
+			dh=heightmap[square] - baseHeight;
 			ang=dh*invR;
 			if(ang&gt;maxAng4){
 				instance-&gt;losSquares.push_back(square);
-				losMap[allyteam][square]++;
+				(*allyLosMap)[square]++;
 			}
-			dh+=terrainHeight[0];
+			dh-=15;
 			ang=dh*invR;
 			if(ang&gt;maxAng4){
 				maxAng4=ang;
@@ -289,10 +276,13 @@
 {
 	int xmap=xm;
 	int ymap=ym;
-	int allyteam=instance-&gt;allyteam;
+	const int allyteam=instance-&gt;allyteam;
 
-	int mapSquare=instance-&gt;baseSquare;
+	const int mapSquare=instance-&gt;baseSquare;
 
+	float* heightmap = readmap-&gt;mipHeightmap[losMipLevel];
+	vector&lt;unsigned short&gt;* allyLosMap = &amp;losMap[allyteam];
+
 	LosAddAir(instance);
 
 	int tablenum=instance-&gt;losSize;
@@ -301,27 +291,28 @@
 	}
 	LosTable&amp; table=lostables[tablenum-1];
 
+	const float baseHeight = heightmap[mapSquare] + instance-&gt;baseHeight-15;
+
 	for (LosTable::iterator li = table.begin(); li != table.end(); ++li) {
 		LosLine&amp; line = *li;
-		float baseHeight=readmap-&gt;mipHeightmap[losMipLevel][mapSquare]+instance-&gt;baseHeight-15;
 		float maxAng1 = -1e6f;
 		float maxAng2 = -1e6f;
 		float maxAng3 = -1e6f;
 		float maxAng4 = -1e6f;
 		float r = 1;
 		instance-&gt;losSquares.push_back(mapSquare);
-		losMap[allyteam][mapSquare]++;
+		(*allyLosMap)[mapSquare]++;
 
 		for(LosLine::iterator linei=line.begin();linei!=line.end();++linei){
 			if(xmap+linei-&gt;x&lt;losSizeX &amp;&amp; ymap+linei-&gt;y&lt;losSizeY){
 				int square=mapSquare+linei-&gt;x+linei-&gt;y*losSizeX;
-				float dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+				float dh=heightmap[square] - baseHeight;
 				float ang=dh/r;
 				if(ang&gt;maxAng1){
 					instance-&gt;losSquares.push_back(square);
-					losMap[allyteam][square]++;
+					(*allyLosMap)[square]++;
 				}
-				dh+=terrainHeight[0];
+				dh-=15;
 				ang=dh/r;
 				if(ang&gt;maxAng1){
 					maxAng1=ang;
@@ -329,13 +320,13 @@
 			}
 			if(xmap-linei-&gt;x&gt;=0 &amp;&amp; ymap-linei-&gt;y&gt;=0){
 				int square=mapSquare-linei-&gt;x-linei-&gt;y*losSizeX;
-				float dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+				float dh=heightmap[square] - baseHeight;
 				float ang=dh/r;
 				if(ang&gt;maxAng2){
 					instance-&gt;losSquares.push_back(square);
-					losMap[allyteam][square]++;
+					(*allyLosMap)[square]++;
 				}
-				dh+=terrainHeight[0];
+				dh-=15;
 				ang=dh/r;
 				if(ang&gt;maxAng2){
 					maxAng2=ang;
@@ -343,13 +334,13 @@
 			}
 			if(xmap+linei-&gt;y&lt;losSizeX &amp;&amp; ymap-linei-&gt;x&gt;=0){
 				int square=mapSquare-linei-&gt;x*losSizeX+linei-&gt;y;
-				float dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+				float dh=heightmap[square] - baseHeight;
 				float ang=dh/r;
 				if(ang&gt;maxAng3){
 					instance-&gt;losSquares.push_back(square);
-					losMap[allyteam][square]++;
+					(*allyLosMap)[square]++;
 				}
-				dh+=terrainHeight[0];
+				dh-=15;
 				ang=dh/r;
 				if(ang&gt;maxAng3){
 					maxAng3=ang;
@@ -357,13 +348,13 @@
 			}
 			if(xmap-linei-&gt;y&gt;=0 &amp;&amp; ymap+linei-&gt;x&lt;losSizeY){
 				int square=mapSquare+linei-&gt;x*losSizeX-linei-&gt;y;
-				float dh=readmap-&gt;mipHeightmap[losMipLevel][square]-baseHeight;
+				float dh=heightmap[square] - baseHeight;
 				float ang=dh/r;
 				if(ang&gt;maxAng4){
 					instance-&gt;losSquares.push_back(square);
-					losMap[allyteam][square]++;
+					(*allyLosMap)[square]++;
 				}
-				dh+=terrainHeight[0];
+				dh-=15;
 				ang=dh/r;
 				if(ang&gt;maxAng4){
 					maxAng4=ang;
@@ -575,8 +566,9 @@
 
 void CLosHandler::CleanupInstance(LosInstance* instance)
 {
+	vector&lt;unsigned short&gt;&amp; allyLosMap = losMap[instance-&gt;allyteam];
 	for(std::vector&lt;int&gt;::iterator lsi=instance-&gt;losSquares.begin();lsi!=instance-&gt;losSquares.end();++lsi){
-		--losMap[instance-&gt;allyteam][*lsi];
+		--allyLosMap[*lsi];
 	}
 
 	int by=(instance-&gt;baseAirSquare/airSizeX);
@@ -592,7 +584,7 @@
 		int rrx=rr-(by-y)*(by-y);
 		for(int x=sx;x&lt;=ex;++x){
 			if((bx-x)*(bx-x)&lt;=rrx){
-				--airLosMap[instance-&gt;allyteam][y*airSizeX+x];
+				--allyLosMap[y*airSizeX+x];
 			}
 		}
 	}

Modified: branches/caiinterface/rts/Sim/Misc/LosHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosHandler.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Misc/LosHandler.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -203,7 +203,6 @@
 	};
 	typedef std::list&lt;CPoint&gt; TPoints;
 	TPoints Points;
-	float terrainHeight[256];
 
 	typedef std::vector&lt;CPoint&gt; LosLine;
 	typedef std::vector&lt;LosLine&gt; LosTable;

Modified: branches/caiinterface/rts/Sim/Misc/Wind.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/Wind.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Misc/Wind.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -63,7 +63,7 @@
 		newWind=float3(sin(nd)*ns,0,cos(nd)*ns);
 
 		// TODO: decouple
-		uh-&gt;PushNewWind(newWind.x, newWind.z, newWind.Length());
+		uh-&gt;UpdateWind(newWind.x, newWind.z, newWind.Length());
 
 		status++;
 	} else if(status&lt;=300) {

Modified: branches/caiinterface/rts/Sim/Path/PathManager.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Path/PathManager.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Path/PathManager.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -461,7 +461,7 @@
 		path-&gt;peDef-&gt;Draw();
 	}
 	glLineWidth(1);
-#if !defined(USE_GML) || !GML_ENABLE_SIMDRAW // making this threadsafe might be too costly performance wise
+#if !defined(USE_GML) || !GML_ENABLE_SIM // making this threadsafe might be too costly performance wise
 	pf-&gt;Draw();
 	pe-&gt;Draw();
 	pe2-&gt;Draw();

Modified: branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -152,7 +152,7 @@
 }
 
 void CProjectile::UpdateDrawPos() {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 		drawPos = pos + (speed * ((float)gu-&gt;lastFrameStart - (float)lastProjUpdate) * gu-&gt;weightedSpeedFactor);
 #else
 		drawPos = pos + (speed * gu-&gt;timeOffset);

Modified: branches/caiinterface/rts/Sim/Projectiles/Projectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Projectile.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Projectiles/Projectile.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -51,7 +51,7 @@
 
 	void UpdateDrawPos();
 	float3 drawPos;
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	unsigned lastProjUpdate;
 #endif
 

Modified: branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -16,7 +16,7 @@
 #include &quot;ConfigHandler.h&quot;
 #include &quot;Rendering/GroundFlash.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
@@ -316,21 +316,15 @@
 
 	drawPerlinTex=false;
 
-	if (GLEW_EXT_framebuffer_object &amp;&amp; !GLEW_ATI_envmap_bumpmap) {
-		// this seems to bug on ati cards so disable it on those
-		// (just some random ati extension to detect ati cards),
-		// should be fixed by someone that actually has a ati card
-		perlinFB = instantiate_fb(512, 512, FBO_NEED_COLOR);
-		if (perlinFB &amp;&amp; perlinFB-&gt;valid()) {
-			perlinFB-&gt;attachTexture(textureAtlas-&gt;gltex, GL_TEXTURE_2D, FBO_ATTACH_COLOR);
-			perlinFB-&gt;select();
-			drawPerlinTex=perlinFB-&gt;checkFBOStatus();
-			perlinFB-&gt;deselect();
-		}
+	if (perlinFB.IsValid()) {
+		//we never refresh the full texture (just the perlin part). So we need to reload it then.
+		perlinFB.reloadOnAltTab = true;
+
+		perlinFB.Bind();
+		perlinFB.AttachTexture(textureAtlas-&gt;gltex);
+		drawPerlinTex=perlinFB.CheckStatus(&quot;PERLIN&quot;);
+		perlinFB.Unbind();
 	}
-	else {
-		perlinFB = 0;
-	}
 }
 
 CProjectileHandler::~CProjectileHandler()
@@ -367,7 +361,6 @@
 	ph=0;
 	delete textureAtlas;
 	delete groundFXAtlas;
-	delete perlinFB;
 }
 
 void CProjectileHandler::Serialize(creg::ISerializer *s)
@@ -758,10 +751,11 @@
 
 	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		CProjectile* p = (*psi);
-		const float3 ppos0 = p-&gt;pos;
-		const float3 ppos1 = p-&gt;pos + p-&gt;speed;
 
 		if (p-&gt;checkCol &amp;&amp; !p-&gt;deleteMe) {
+			const float3 ppos0 = p-&gt;pos;
+			const float3 ppos1 = p-&gt;pos + p-&gt;speed;
+
 			float speedf = p-&gt;speed.Length();
 
 			CUnit** endUnit = tempUnits;
@@ -926,9 +920,11 @@
 
 	GML_RECMUTEX_LOCK(proj); // AddFlyingPiece
 
+	flyings3oPieces.reserve(textureType);
 	while(flyings3oPieces.size()&lt;=textureType)
 		flyings3oPieces.push_back(vector&lt;FlyingPiece_List*&gt;());
 
+	flyings3oPieces[textureType].reserve(team);
 	while(flyings3oPieces[textureType].size()&lt;=team){
 		//logOutput.Print(&quot;Creating piece list %d %d.&quot;, textureType, flyings3oPieces[textureType].size());
 
@@ -959,23 +955,12 @@
 {
 	if (numPerlinProjectiles &amp;&amp; drawPerlinTex)
 		UpdatePerlin();
-/*
-	if(gs-&gt;frameNum==300){
-		logOutput.Print(&quot;Saving tex&quot;);
-		perlinFB-&gt;select();
-		unsigned char* buf=SAFE_NEW unsigned char[512*512*4];
-		glReadPixels(0,0,512,512,GL_RGBA,GL_UNSIGNED_BYTE,buf);
-		CBitmap b(buf,512,512);
-		b.ReverseYAxis();
-		b.Save(&quot;proj2.tga&quot;);
-		delete[] buf;
-		perlinFB-&gt;deselect();
-	}*/
 }
 
+
 void CProjectileHandler::UpdatePerlin()
 {
-	perlinFB-&gt;select();
+	perlinFB.Bind();
 	glViewport(perlintex.ixstart, perlintex.iystart, 128, 128);
 
 	glMatrixMode(GL_PROJECTION);
@@ -1043,7 +1028,7 @@
 		speed*=0.6f;
 		size*=2;
 	}
-	perlinFB-&gt;deselect();
+	perlinFB.Unbind();
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

Modified: branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -9,7 +9,6 @@
 struct S3DOPrimitive;
 struct S3DO;
 struct SS3OVertex;
-
 #include &lt;list&gt;
 #include &lt;vector&gt;
 
@@ -17,11 +16,11 @@
 #include &quot;MemPool.h&quot;
 #include &quot;Rendering/Textures/TextureAtlas.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;float3.h&quot;
 
 
 class CGroundFlash;
-class IFramebuffer;
 
 
 typedef std::list&lt;CProjectile*&gt; Projectile_List;
@@ -153,7 +152,7 @@
 
 	GLuint perlinTex[8];
 	float perlinBlend[4];
-	IFramebuffer *perlinFB;
+	FBO perlinFB;
 	bool drawPerlinTex;
 	std::vector&lt;CGroundFlash*&gt; groundFlashes;
 

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -99,20 +99,21 @@
 	}
 	else
 	{
+		unsigned char color[4];
 		for(int i=0; i&lt;numParticles; i++)
 		{
-			if(particles[i].life&lt;1.0f)
+			Particle* p = &amp;particles[i];
+			if(p-&gt;life&lt;1.0f)
 			{
-				unsigned char color[4];
+				colorMap-&gt;GetColor(color, p-&gt;life);
+				float3 interPos=p-&gt;pos+p-&gt;speed*gu-&gt;timeOffset;
+				const float3 cameraRight = camera-&gt;right*p-&gt;size;
+				const float3 cameraUp    = camera-&gt;up*p-&gt;size;
 
-				colorMap-&gt;GetColor(color, particles[i].life);
-				float3 interPos=particles[i].pos+particles[i].speed*gu-&gt;timeOffset;
-				float size = particles[i].size;
-
-				va-&gt;AddVertexQTC(interPos-camera-&gt;right*size-camera-&gt;up*size,texture-&gt;xstart,texture-&gt;ystart,color);
-				va-&gt;AddVertexQTC(interPos+camera-&gt;right*size-camera-&gt;up*size,texture-&gt;xend ,texture-&gt;ystart,color);
-				va-&gt;AddVertexQTC(interPos+camera-&gt;right*size+camera-&gt;up*size,texture-&gt;xend ,texture-&gt;yend ,color);
-				va-&gt;AddVertexQTC(interPos-camera-&gt;right*size+camera-&gt;up*size,texture-&gt;xstart,texture-&gt;yend ,color);
+				va-&gt;AddVertexQTC(interPos-cameraRight-cameraUp,texture-&gt;xstart,texture-&gt;ystart,color);
+				va-&gt;AddVertexQTC(interPos+cameraRight-cameraUp,texture-&gt;xend ,texture-&gt;ystart,color);
+				va-&gt;AddVertexQTC(interPos+cameraRight+cameraUp,texture-&gt;xend ,texture-&gt;yend ,color);
+				va-&gt;AddVertexQTC(interPos-cameraRight+cameraUp,texture-&gt;xstart,texture-&gt;yend ,color);
 			}
 		}
 	}

Modified: branches/caiinterface/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -1116,7 +1116,7 @@
 
 void CUnit::UpdateDrawPos() {
 	CTransportUnit *trans=GetTransporter();
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	if (trans) {
 		drawPos = pos + (trans-&gt;speed * ((float)gu-&gt;lastFrameStart - (float)lastUnitUpdate) * gu-&gt;weightedSpeedFactor);
 	} else {

Modified: branches/caiinterface/rts/Sim/Units/Unit.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Units/Unit.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -314,7 +314,7 @@
 	bool activated;					//if the unit is in it's 'on'-state
 
 	inline CTransportUnit *GetTransporter() const {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 		return *(CTransportUnit * volatile *)&transporter; // transporter may suddenly be changed to NULL by sim
 #else
 		return transporter;
@@ -323,7 +323,7 @@
 
 	void UpdateDrawPos();
 	float3 drawPos;
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	unsigned lastUnitUpdate;
 #endif
 	//CUnit3DLoader::UnitModel* model;

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -272,7 +272,7 @@
 		}
 	}
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	for(int i=0, dcs=unitDrawer-&gt;drawCloaked.size(); i&lt;dcs; ++i)
 		if(unitDrawer-&gt;drawCloaked[i]==delUnit)
 			unitDrawer-&gt;drawCloaked[i]=NULL;
@@ -608,10 +608,10 @@
 }
 
 
-void CUnitHandler::PushNewWind(float x, float z, float strength)
+void CUnitHandler::UpdateWind(float x, float z, float strength)
 {
 	ASSERT_SYNCED_MODE;
-	//todo: fixa en lista med enbart windgenerators kanske blir lite snabbare
+	//todo: save windgens in a list (would be a little faster)
 	std::list&lt;CUnit*&gt;::iterator usi;
 	for(usi=activeUnits.begin();usi!=activeUnits.end();usi++)
 	{

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -32,7 +32,7 @@
 	void Serialize(creg::ISerializer&amp; s);
 	void PostLoad();
 	virtual ~CUnitHandler();
-	void PushNewWind(float x, float z, float strength);
+	void UpdateWind(float x, float z, float strength);
 
 	//return values for the following is
 	//0 blocked

Modified: branches/caiinterface/rts/System/MouseInput.cpp
===================================================================
--- branches/caiinterface/rts/System/MouseInput.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/MouseInput.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -16,7 +16,7 @@
 
 #include &lt;SDL_events.h&gt;
 #include &lt;SDL_syswm.h&gt;
-
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;GlobalUnsynced.h&quot;
 #include &quot;Platform/Win/win32.h&quot;
 #include &quot;MouseInput.h&quot;
@@ -53,20 +53,74 @@
 	// SDL runs the window in a different thread, hence the indirectness of the mouse pos handling
 	static LRESULT CALLBACK SpringWndProc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam)
 	{
-		if (msg==WM_MOUSEMOVE) {
-			// cast to short to preserve sign
-			inst-&gt;mousepos = int2((short)LOWORD(lparam),(short)HIWORD(lparam));
-			inst-&gt;mousemoved = true;
-			return FALSE;
-		}else if (msg==WM_SETCURSOR) {
-			if (inst-&gt;hCursor!=NULL) {
-				Uint16 hittest = LOWORD(lparam);
-				if ( hittest == HTCLIENT ) {
-					SetCursor(inst-&gt;hCursor);
+		if (mouse) {
+			switch (msg) {
+				case WM_LBUTTONDOWN:
+					mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 1);
 					return TRUE;
+				case WM_RBUTTONDOWN:
+					mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 3);
+					return TRUE;
+				case WM_MBUTTONDOWN:
+					mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 2);
+					return TRUE;
+				case WM_LBUTTONUP:
+					mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 1);
+					return TRUE;
+				case WM_RBUTTONUP:
+					mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 3);
+					return TRUE;
+				case WM_MBUTTONUP:
+					mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 2);
+					return TRUE;
+				case WM_MOUSEWHEEL: {
+					float delta = (((short)HIWORD(wparam))/120.0f);
+					mouse-&gt;MouseWheel(delta);
+					return TRUE;
 				}
-			}
+				case WM_XBUTTONDOWN:
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON1)
+						mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 4);
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON2)
+						mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 5);
+					return TRUE;
+				case WM_XBUTTONUP:
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON1)
+						mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 4);
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON2)
+						mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 5);
+					return TRUE;
+				}
+
 		}
+
+		switch (msg) {
+			case WM_MOUSEMOVE:
+				// cast to short to preserve sign
+				inst-&gt;mousepos = int2((short)LOWORD(lparam),(short)HIWORD(lparam));
+				inst-&gt;mousemoved = true;
+				return FALSE;
+			case WM_SETCURSOR:
+				if (inst-&gt;hCursor!=NULL) {
+					Uint16 hittest = LOWORD(lparam);
+					if ( hittest == HTCLIENT ) {
+						SetCursor(inst-&gt;hCursor);
+						return TRUE;
+					}
+				}
+				break;
+			case WM_ACTIVATE:
+				// FIXME: move to SpringApp somehow and use GLContext.h instead!
+				if(fullscreen) {
+					if (wparam == WA_INACTIVE) {
+						FBO::GLContextLost();
+					}else if (wparam == WA_ACTIVE) {
+						FBO::GLContextReinit();
+					}
+				}
+				break;
+		}
+
 		return CallWindowProc((WNDPROC)inst-&gt;sdl_wndproc, wnd, msg, wparam, lparam);
 	}
 
@@ -128,7 +182,7 @@
 
 	void HandleSDLMouseEvent (SDL_Event&amp; event)
 	{
-		if (!mouse)
+		/*if (!mouse)
 			return;
 
 		switch (event.type) {
@@ -140,25 +194,26 @@
 				if (msg-&gt;wParam &amp; 0x40) // MK_XBUTTON2
 					mouse-&gt;MousePress (mousepos.x, mousepos.y, 5);
 			}
+
 			break;}
-		/*case SDL_MOUSEMOTION: // the normal SDL method works fine in windowed mode
+		case SDL_MOUSEMOTION: // the normal SDL method works fine in windowed mode
 			if(!fullscreen) {
 				mousepos = int2(event.motion.x, event.motion.y);
 				mouse-&gt;MouseMove(mousepos.x, mousepos.y);
 			}
-			break;*/
+			break;
 		case SDL_MOUSEBUTTONDOWN:
 			if (event.button.button == SDL_BUTTON_WHEELUP)
-				mouse-&gt;MouseWheel(true);
+				mouse-&gt;MouseWheel(1.0f);
 			else if (event.button.button == SDL_BUTTON_WHEELDOWN)
-				mouse-&gt;MouseWheel(false);
+				mouse-&gt;MouseWheel(-1.0f);
 			else
 				mouse-&gt;MousePress(mousepos.x, mousepos.y,event.button.button);
 			break;
 		case SDL_MOUSEBUTTONUP:
 			mouse-&gt;MouseRelease(mousepos.x, mousepos.y,event.button.button);
 			break;
-		}
+		}*/
 	}
 };
 CWin32MouseInput* CWin32MouseInput::inst = 0;
@@ -194,9 +249,9 @@
 				mousepos = int2(event.button.x, event.button.y);
 				if (mouse) {
 					if (event.button.button == SDL_BUTTON_WHEELUP) {
-						mouse-&gt;MouseWheel(true);
+						mouse-&gt;MouseWheel(1.0f);
 					} else if (event.button.button == SDL_BUTTON_WHEELDOWN) {
-						mouse-&gt;MouseWheel(false);
+						mouse-&gt;MouseWheel(-1.0f);
 					} else {
 						mouse-&gt;MousePress(event.button.x, event.button.y, event.button.button);
 					}

Modified: branches/caiinterface/rts/System/Net/UDPConnection.cpp
===================================================================
--- branches/caiinterface/rts/System/Net/UDPConnection.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/Net/UDPConnection.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -48,11 +48,7 @@
 
 void UDPConnection::SendData(boost::shared_ptr&lt;const RawPacket&gt; data)
 {
-	if(outgoingLength + data-&gt;length &gt;= UDPBufferSize){
-		throw network_error(&quot;Buffer overflow in UDPConnection (SendData)&quot;);
-	}
-	memcpy(&amp;outgoingData[outgoingLength], data-&gt;data, data-&gt;length);
-	outgoingLength += data-&gt;length;
+	outgoingData.push_back(data);
 }
 
 bool UDPConnection::HasIncomingData() const
@@ -91,9 +87,9 @@
 	if (!sharedSocket)
 	{
 		unsigned recv = 0;
-		unsigned char buffer[UDPBufferSize];
+		unsigned char buffer[4096];
 		sockaddr_in fromAddr;
-		while ((recv = mySocket-&gt;RecvFrom(buffer, UDPBufferSize, &amp;fromAddr)) &gt;= hsize)
+		while ((recv = mySocket-&gt;RecvFrom(buffer, 4096, &amp;fromAddr)) &gt;= hsize)
 		{
 			RawPacket* data = new RawPacket(buffer, recv);
 			if (CheckAddress(fromAddr))
@@ -171,14 +167,14 @@
 	//process all in order packets that we have waiting
 	while ((wpi = waitingPackets.find(lastInOrder+1)) != waitingPackets.end())
 	{
-		unsigned char buf[UDPBufferSize];
+		unsigned char buf[4096];
 		unsigned bufLength = 0;
 
 		if (fragmentBuffer)
 		{
 			// combine with fragment buffer
 			bufLength += fragmentBuffer-&gt;length;
-			assert(fragmentBuffer-&gt;length &lt; UDPBufferSize);
+			assert(fragmentBuffer-&gt;length &lt; 4096);
 			memcpy(buf, fragmentBuffer-&gt;data, bufLength);
 			delete fragmentBuffer;
 			fragmentBuffer = NULL;
@@ -186,7 +182,7 @@
 
 		lastInOrder++;
 #if (BOOST_VERSION &gt;= 103400)
-		assert((wpi-&gt;second-&gt;length + bufLength) &lt; UDPBufferSize);
+		assert((wpi-&gt;second-&gt;length + bufLength) &lt; 4096);
 		memcpy(buf + bufLength, wpi-&gt;second-&gt;data, wpi-&gt;second-&gt;length);
 		bufLength += (wpi-&gt;second)-&gt;length;
 #else
@@ -259,27 +255,43 @@
 
 void UDPConnection::Flush(const bool forced)
 {
-	const float curTime = SDL_GetTicks();
-	if (forced || (outgoingLength&gt;0 &amp;&amp; (lastSendTime &lt; (curTime - 200 + outgoingLength * 10))))
+	const unsigned curTime = SDL_GetTicks();
+
+	unsigned outgoingLength = 0;
+	for (packetList::const_iterator it = outgoingData.begin(); it != outgoingData.end(); ++it)
+		outgoingLength += (*it)-&gt;length;
+
+	if (forced || (!outgoingData.empty() &amp;&amp; (lastSendTime &lt; (curTime - 200 + outgoingLength * 10))))
 	{
 		lastSendTime=SDL_GetTicks();
 
+		uint8_t buffer[1500];
+		unsigned pos = 0;
 		// Manually fragment packets to respect configured UDP_MTU.
 		// This is an attempt to fix the bug where players drop out of the game if
 		// someone in the game gives a large order.
 
-		if (outgoingLength &gt; mtu)
-			++fragmentedFlushes;
-
-		unsigned pos = 0;
-		do
+		while (!outgoingData.empty())
 		{
-			unsigned length = std::min(mtu, outgoingLength);
-			SendRawPacket(outgoingData + pos, length, currentNum++);
-			unackedPackets.push_back(new RawPacket(outgoingData + pos, length));
-			outgoingLength -= length;
-			pos += mtu;
-		} while (outgoingLength &gt; 0);
+			{
+				packetList::iterator it = outgoingData.begin();
+				unsigned numBytes = std::min(mtu-pos, (*it)-&gt;length);
+				memcpy(buffer+pos, (*it)-&gt;data, numBytes);
+				pos+= numBytes;
+				if (numBytes == (*it)-&gt;length) // full packet copied
+					outgoingData.pop_front();
+				else // partially transfered
+					(*it).reset(new RawPacket((*it)-&gt;data + numBytes, (*it)-&gt;length - numBytes));
+			} // iterator &quot;it&quot; is now invalid
+			if (pos &gt; 0 &amp;&amp; (pos == mtu || outgoingData.empty()))
+			{
+				if (pos == mtu)
+					++fragmentedFlushes;
+				SendRawPacket(buffer, pos, currentNum++);
+				unackedPackets.push_back(new RawPacket(buffer, pos));
+				pos = 0;
+			}
+		}
 	}
 }
 
@@ -342,7 +354,6 @@
 	waitingPackets.clear();
 	firstUnacked=0;
 	currentNum=0;
-	outgoingLength=0;
 	lastNak=-1;
 	lastNakTime=0;
 	lastSendTime=0;

Modified: branches/caiinterface/rts/System/Net/UDPConnection.h
===================================================================
--- branches/caiinterface/rts/System/Net/UDPConnection.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/Net/UDPConnection.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -5,16 +5,12 @@
 #include &lt;boost/ptr_container/ptr_map.hpp&gt;
 #include &lt;boost/shared_ptr.hpp&gt;
 #include &lt;deque&gt;
+#include &lt;list&gt;
 
 #include &quot;Connection.h&quot;
 #include &quot;UDPSocket.h&quot;
 
 namespace netcode {
-#ifndef SYNCDEBUG
-const unsigned UDPBufferSize = 16384;
-#else
-const unsigned UDPBufferSize = 40000;
-#endif
 
 /**
 How Spring protocolheader looks like (size in bytes):
@@ -85,6 +81,7 @@
 	unsigned lastReceiveTime;
 	
 	typedef boost::ptr_map&lt;int,RawPacket&gt; packetMap;
+	typedef std::list&lt; boost::shared_ptr&lt;const RawPacket&gt; &gt; packetList;
 	/// all packets with number &lt;= nextAck arrived at the other end
 	void AckPackets(const int nextAck);
 	/// add header to data and send it
@@ -98,8 +95,7 @@
 	bool sharedSocket;
 
 	///outgoing stuff (pure data without header) waiting to be sended
-	unsigned char outgoingData[UDPBufferSize];
-	unsigned outgoingLength;
+	packetList outgoingData;
 
 	/// packets the other side didn't ack'ed until now
 	boost::ptr_deque&lt;RawPacket&gt; unackedPackets;

Modified: branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -117,6 +117,7 @@
 
 void COpenALSound::PlayStream(const std::string&amp; path, float volume, const float3&amp; pos, bool loop)
 {
+	GML_RECMUTEX_LOCK(sound); // PlayStream
 /*
 	if (volume &lt;= 0.0f) {
 		return;
@@ -165,14 +166,38 @@
 	oggStream.Play(path, pos * posScale, volume);
 }
 
-void COpenALSound::StopStream() { oggStream.Stop(); }
-void COpenALSound::PauseStream() { oggStream.TogglePause(); }
-unsigned int COpenALSound::GetStreamTime() { return oggStream.GetTotalTime(); }
-unsigned int COpenALSound::GetStreamPlayTime() { return oggStream.GetPlayTime(); }
-void COpenALSound::SetStreamVolume(float v) { oggStream.SetVolume(v); }
+void COpenALSound::StopStream() {
+	GML_RECMUTEX_LOCK(sound); // StopStream
 
+	oggStream.Stop();
+}
 
+void COpenALSound::PauseStream() {
+	GML_RECMUTEX_LOCK(sound); // PauseStream
 
+	oggStream.TogglePause();
+}
+
+unsigned int COpenALSound::GetStreamTime() {
+	GML_RECMUTEX_LOCK(sound); // GetStreamTime
+
+	return oggStream.GetTotalTime();
+}
+
+unsigned int COpenALSound::GetStreamPlayTime() {
+	GML_RECMUTEX_LOCK(sound); // GetStreamPlayTime
+
+	return oggStream.GetPlayTime();
+}
+
+void COpenALSound::SetStreamVolume(float v) {
+	GML_RECMUTEX_LOCK(sound); // SetStreamVolume
+
+	oggStream.SetVolume(v);
+}
+
+
+
 void COpenALSound::SetVolume(float v)
 {
 	globalVolume = v;
@@ -196,6 +221,8 @@
 
 void COpenALSound::PlaySample(int id, const float3&amp; p, float volume, bool relative)
 {
+	GML_RECMUTEX_LOCK(sound); // PlaySample
+
 	assert(volume &gt;= 0.0f);
 
 	if (volume == 0.0f || globalVolume == 0.0f) return;
@@ -235,6 +262,8 @@
 
 void COpenALSound::Update()
 {
+	GML_RECMUTEX_LOCK(sound); // Update
+
 	oggStream.Update();
 
 	for (int a = 0; a &lt; maxSounds; a++) {
@@ -417,6 +446,8 @@
 
 ALuint COpenALSound::GetWaveId(const std::string&amp; path, bool _hardFail)
 {
+	GML_RECMUTEX_LOCK(sound); // GetWaveId
+
 	std::map&lt;std::string, ALuint&gt;::const_iterator it = soundMap.find(path);
 	if (it != soundMap.end()) {
 		return it-&gt;second;

Modified: branches/caiinterface/rts/System/Platform/Win/DxSound.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Win/DxSound.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/Platform/Win/DxSound.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -123,21 +123,45 @@
 
 
 
-void CDxSound::PlayStream(const std::string&amp; path, float volume,
-							const float3&amp; pos, bool)
-{
+void CDxSound::PlayStream(const std::string&amp; path, float volume, const float3&amp; pos, bool) {
+	GML_RECMUTEX_LOCK(sound); // PlayStream
+
 	oggStream.SetDSoundObject(m_pDS);
 	oggStream.Play(path, volume, pos);
 }
 
-void CDxSound::StopStream() { oggStream.Stop(); }
-void CDxSound::PauseStream() { oggStream.TogglePause(); }
-unsigned int CDxSound::GetStreamTime() { return oggStream.GetTotalTime(); }
-unsigned int CDxSound::GetStreamPlayTime() { return oggStream.GetPlayTime(); }
-void CDxSound::SetStreamVolume(float v) { oggStream.SetVolume(v); }
+void CDxSound::StopStream() {
+	GML_RECMUTEX_LOCK(sound); // StopStream
 
+	oggStream.Stop();
+}
 
+void CDxSound::PauseStream() {
+	GML_RECMUTEX_LOCK(sound); // PauseStream
 
+	oggStream.TogglePause();
+}
+
+unsigned int CDxSound::GetStreamTime() {
+	GML_RECMUTEX_LOCK(sound); // GetStreamTime
+
+	return oggStream.GetTotalTime();
+}
+
+unsigned int CDxSound::GetStreamPlayTime() {
+	GML_RECMUTEX_LOCK(sound); // GetStreamPlayTime
+
+	return oggStream.GetPlayTime();
+}
+
+void CDxSound::SetStreamVolume(float v) {
+	GML_RECMUTEX_LOCK(sound); // SetStreamVolume
+
+	oggStream.SetVolume(v);
+}
+
+
+
 int CDxSound::InitFile(const string&amp; name)
 {
 	if (m_pDS == 0) {
@@ -162,6 +186,8 @@
 
 unsigned int CDxSound::GetWaveId(const string &amp;name, bool _hardFail)
 {
+	GML_RECMUTEX_LOCK(sound); // GetWaveId
+
 	PUSH_CODE_MODE;
 	ENTER_MIXED;
 	std::map&lt;string, int&gt;::iterator si = waveid.find(name);
@@ -224,6 +250,8 @@
 
 void CDxSound::PlaySample(int id, float volume)
 {
+	GML_RECMUTEX_LOCK(sound); // PlaySample
+
 	PUSH_CODE_MODE;
 	ENTER_MIXED;
 	if (id &lt;= 0 || id &gt;= loadedSounds.size() || playingSounds.size() &gt;= maxSounds) {
@@ -260,6 +288,8 @@
 
 void CDxSound::PlaySample(int id, const float3&amp; p, float volume)
 {
+	GML_RECMUTEX_LOCK(sound); // PlaySample
+
 	PUSH_CODE_MODE;
 	ENTER_MIXED;
 
@@ -479,6 +509,8 @@
 
 void CDxSound::Update()
 {
+	GML_RECMUTEX_LOCK(sound); // Update
+
 	oggStream.Update();
 
 	float total = wantedSounds * 0.5f;

Modified: branches/caiinterface/rts/System/Platform/Win/OggStream.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Win/OggStream.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/Platform/Win/OggStream.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -218,12 +218,12 @@
 void COggStream::DisplayInfo() {
 	logOutput.Print(&quot;version:           %d&quot;, vorbisInfo-&gt;version);
 	logOutput.Print(&quot;channels:          %d&quot;, vorbisInfo-&gt;channels);
-	logOutput.Print(&quot;time (sec):        %d&quot;, ov_time_total(&amp;oggStream,-1));
-	logOutput.Print(&quot;rate (Hz):         %d&quot;, vorbisInfo-&gt;rate);
-	logOutput.Print(&quot;bitrate (upper):   %d&quot;, vorbisInfo-&gt;bitrate_upper);
-	logOutput.Print(&quot;bitrate (nominal): %d&quot;, vorbisInfo-&gt;bitrate_nominal);
-	logOutput.Print(&quot;bitrate (lower):   %d&quot;, vorbisInfo-&gt;bitrate_lower);
-	logOutput.Print(&quot;bitrate (window):  %d&quot;, vorbisInfo-&gt;bitrate_window);
+	logOutput.Print(&quot;time (sec):        %li&quot;, ov_time_total(&amp;oggStream,-1));
+	logOutput.Print(&quot;rate (Hz):         %li&quot;, vorbisInfo-&gt;rate);
+	logOutput.Print(&quot;bitrate (upper):   %li&quot;, vorbisInfo-&gt;bitrate_upper);
+	logOutput.Print(&quot;bitrate (nominal): %li&quot;, vorbisInfo-&gt;bitrate_nominal);
+	logOutput.Print(&quot;bitrate (lower):   %li&quot;, vorbisInfo-&gt;bitrate_lower);
+	logOutput.Print(&quot;bitrate (window):  %li&quot;, vorbisInfo-&gt;bitrate_window);
 	logOutput.Print(&quot;vendor:            %s&quot;, vorbisComment-&gt;vendor);
 
 	for (int i = 0; i &lt; vorbisComment-&gt;comments; i++) {

Modified: branches/caiinterface/rts/System/Sound.cpp
===================================================================
--- branches/caiinterface/rts/System/Sound.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/Sound.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -65,6 +65,8 @@
 
 void CSound::PlayUnitReply(int id, CUnit * p, float volume, bool squashDupes)
 {
+	GML_RECMUTEX_LOCK(sound); // PlayUnitReply
+
 	if (squashDupes) {
 		/* HACK Squash multiple command acknowledgements in the same frame, so
 		   we aren't deafened by the construction horde, or the metalmaker
@@ -86,6 +88,8 @@
 
 void CSound::NewFrame()
 {
+	GML_RECMUTEX_LOCK(sound); // NewFrame
+
 	repliesPlayed.clear();
 }
 

Modified: branches/caiinterface/rts/System/SpringApp.cpp
===================================================================
--- branches/caiinterface/rts/System/SpringApp.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/SpringApp.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -61,7 +61,7 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+extern gmlClientServer&lt;void, int,CUnit*&gt; *gmlProcessor;
 #endif
 
 using std::string;
@@ -118,6 +118,10 @@
 	if (keys) delete[] keys;
 
 	creg::System::FreeClasses ();
+#ifdef USE_GML
+	if(gmlProcessor)
+		delete gmlProcessor;
+#endif
 }
 
 #ifdef _CRASHRPT_H_
@@ -723,9 +727,10 @@
 
 #ifdef USE_GML
 	gmlThreadCountOverride = configHandler.Get(&quot;HardwareThreadCount&quot;, 0);
-#if GML_ENABLE_SIMLOOP
-	extern volatile int multiThreadSim;
-	multiThreadSim=configHandler.Get(&quot;MultiThreadSim&quot;, 1);
+	gmlThreadCount=GML_CPU_COUNT;
+#if GML_ENABLE_SIM
+	extern volatile int gmlMultiThreadSim;
+	gmlMultiThreadSim=configHandler.Get(&quot;MultiThreadSim&quot;, 1);
 #endif
 #endif
 }
@@ -875,33 +880,27 @@
 
 
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-volatile int multiThreadSim;
-volatile int startsim;
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
+volatile int gmlMultiThreadSim;
+volatile int gmlStartSim;
 
 int SpringApp::Sim() {
-	while(keeprunning &amp;&amp; !startsim)
+	while(gmlKeepRunning &amp;&amp; !gmlStartSim)
 		SDL_Delay(100);
-//		boost::thread::yield();
-	while(keeprunning) {
-		if(!multiThreadSim) {
-//			startsim=0;
-			while(!multiThreadSim &amp;&amp; keeprunning)
-				SDL_Delay(100);
-//			simBarrier.wait();
-//			startsim=1;
+	while(gmlKeepRunning) {
+		if(!gmlMultiThreadSim) {
+			while(!gmlMultiThreadSim &amp;&amp; gmlKeepRunning)
+				SDL_Delay(200);
 		}
 		else if (activeController) {
 			GML_STDMUTEX_LOCK(sim);
 
-			gmlProcessor.ExpandAuxQueue();
+			gmlProcessor-&gt;ExpandAuxQueue();
 			if (!activeController-&gt;Update()) {
 				return 0;
 			}
-			gmlProcessor.GetQueue();
+			gmlProcessor-&gt;GetQueue();
 		}
-//		while(!startsim)
-//			SDL_Delay(100);
 		boost::thread::yield();
 	}
 	return 1;
@@ -926,57 +925,47 @@
 
 	int ret = 1;
 	if (activeController) {
-#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
-		int frame=gu-&gt;drawFrame;
-#	endif
+#if !defined(USE_GML) || !GML_ENABLE_SIM
 		if (!activeController-&gt;Update()) {
 			ret = 0;
 		} else {
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
-			if(frame==gu-&gt;drawFrame) { // only draw if it was not done in parallel with sim
-#	endif
 #else
-				if(multiThreadSim) {
-					if(!gs-&gt;frameNum) {
-						GML_STDMUTEX_LOCK(sim);
-
-						activeController-&gt;Update();
-						if(gs-&gt;frameNum)
-							startsim=1;
-					}
-				}
-				else {
+			if(gmlMultiThreadSim) {
+				if(!gs-&gt;frameNum) {
 					GML_STDMUTEX_LOCK(sim);
 
 					activeController-&gt;Update();
+					if(gs-&gt;frameNum)
+						gmlStartSim=1;
 				}
+			}
+			else {
+				GML_STDMUTEX_LOCK(sim);
+
+				activeController-&gt;Update();
+			}
 #endif
+			gu-&gt;drawFrame++;
+			if (gu-&gt;drawFrame == 0) {
 				gu-&gt;drawFrame++;
-				if (gu-&gt;drawFrame == 0) {
-					gu-&gt;drawFrame++;
-				}
-				if(
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-					!multiThreadSim &amp;&amp;
+			}
+			if(
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
+				!gmlMultiThreadSim &amp;&amp;
 #endif
-					gs-&gt;frameNum-lastRequiredDraw &gt;= MAX_CONSECUTIVE_SIMFRAMES) {
+				gs-&gt;frameNum-lastRequiredDraw &gt;= MAX_CONSECUTIVE_SIMFRAMES) {
 
-					ScopedTimer cputimer(&quot;CPU load&quot;); // Update
+				ScopedTimer cputimer(&quot;CPU load&quot;); // Update
 
-					ret = activeController-&gt;Draw();
-					lastRequiredDraw=gs-&gt;frameNum;
-				}
-				else {
-					ret = activeController-&gt;Draw();
-				}
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-				gmlProcessor.PumpAux();
-#endif
-#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
-#	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+				ret = activeController-&gt;Draw();
+				lastRequiredDraw=gs-&gt;frameNum;
 			}
-#	endif
+			else {
+				ret = activeController-&gt;Draw();
+			}
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
+			gmlProcessor-&gt;PumpAux();
+#else
 		}
 #endif
 	}
@@ -1035,15 +1024,17 @@
 		return -1;
 
 #ifdef WIN32
-	SDL_EventState (SDL_SYSWMEVENT, SDL_ENABLE);
+	//SDL_EventState (SDL_SYSWMEVENT, SDL_ENABLE);
 #endif
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-	keeprunning=1;
-	startsim=0;
-	gmlProcessor.AuxWork(&amp;SpringApp::Simcb,this); // start sim thread
+#ifdef USE_GML
+	gmlProcessor=new gmlClientServer&lt;void, int,CUnit*&gt;;
+#	if GML_ENABLE_SIM
+	gmlKeepRunning=1;
+	gmlStartSim=0;
+	gmlProcessor-&gt;AuxWork(&amp;SpringApp::Simcb,this); // start sim thread
+#	endif
 #endif
-
 	SDL_Event event;
 	bool done = false;
 
@@ -1086,10 +1077,8 @@
 					}
 					break;
 				}
-				case SDL_MOUSEMOTION: {
-					mouseInput-&gt;HandleSDLMouseEvent (event);
-					break;
-				}
+
+				case SDL_MOUSEMOTION:
 				case SDL_MOUSEBUTTONDOWN:
 				case SDL_MOUSEBUTTONUP:
 				case SDL_SYSWMEVENT: {
@@ -1192,9 +1181,9 @@
 	}
 	ENTER_MIXED;
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-	keeprunning=0; // wait for sim to finish
-	while(!gmlProcessor.PumpAux())
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
+	gmlKeepRunning=0; // wait for sim to finish
+	while(!gmlProcessor-&gt;PumpAux())
 		boost::thread::yield();
 #endif
 

Modified: branches/caiinterface/rts/System/SpringApp.h
===================================================================
--- branches/caiinterface/rts/System/SpringApp.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/System/SpringApp.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -33,10 +33,10 @@
 	bool SetSDLVideoMode(); 			//!&lt; Sets SDL video mode
 	void Shutdown (); 				//!&lt; Shuts down application
 	int Update (); 					//!&lt; Run simulation and draw
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	int Sim (); 					//!&lt; Simulation  loop
 	static void Simcb(void *c) {((SpringApp *)c)-&gt;Sim();}
-	volatile int keeprunning;
+	volatile int gmlKeepRunning;
 #endif
 	void UpdateSDLKeys (); 				//!&lt; Update SDL key array
 	bool GetDisplayGeometry();

Modified: branches/caiinterface/rts/build/scons/rts.py
===================================================================
--- branches/caiinterface/rts/build/scons/rts.py	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/build/scons/rts.py	2008-12-05 21:15:39 UTC (rev 7131)
@@ -95,7 +95,7 @@
 		('synccheck',         'Set to yes to enable sync checker &amp; resyncer', True),
 		('synctrace',         'Enable sync tracing', False),
 		('optimize',          'Enable processor optimizations during compilation', 1),
-		('arch',	      'CPU architecture to use', 'auto'),
+		('arch',              'CPU architecture to use', 'auto'),
 		('profile',           'Set to yes to produce a binary with profiling information', False),
 		('profile_generate',  'Set to yes to compile with -fprofile-generate to generate profiling information', False),
 		('profile_use',       'Set to yes to compile with -fprofile-use to use profiling information', False),

Modified: branches/caiinterface/rts/lib/gml/gml.cpp
===================================================================
--- branches/caiinterface/rts/lib/gml/gml.cpp	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/lib/gml/gml.cpp	2008-12-05 21:15:39 UTC (rev 7131)
@@ -57,7 +57,7 @@
 #endif
 
 int gmlThreadCountOverride=0; // number of threads to use (can be manually overridden here)
-int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
+int gmlThreadCount=0; // number of threads to use
 int gmlItemsConsumed=0;
 
 int gmlNextTickUpdate=0;
@@ -187,7 +187,7 @@
 gmlMultiItemServer&lt;GLuint, GLsizei, PFNGLGENBUFFERSPROC *&gt; gmlBufferServer(&amp;glGenBuffers, 2, 0);
 
 
-#if GML_ENABLE_SIMDRAW
+#if GML_ENABLE_SIM
 #include &lt;boost/thread/mutex.hpp&gt;
 boost::mutex caimutex;
 boost::mutex decalmutex;
@@ -217,6 +217,7 @@
 boost::recursive_mutex guimutex;
 boost::recursive_mutex filemutex;
 boost::recursive_mutex &amp;qnummutex=quadmutex;
+boost::recursive_mutex soundmutex;
 #endif
 
 // GMLqueue implementation
@@ -956,7 +957,7 @@
 
 #include &quot;gmlsrv.h&quot;
 class CUnit;
-gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+gmlClientServer&lt;void, int,CUnit*&gt; *gmlProcessor=NULL;
 
 // ExecuteSynced - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points

Modified: branches/caiinterface/rts/lib/gml/gml.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gml.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/lib/gml/gml.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -151,7 +151,7 @@
 #define GML_VECTOR gmlVector
 #define GML_CLASSVECTOR gmlClassVector
 
-#if GML_ENABLE_SIMDRAW
+#if GML_ENABLE_SIM
 #include &lt;boost/thread/mutex.hpp&gt;
 extern boost::mutex caimutex;
 extern boost::mutex decalmutex;
@@ -181,6 +181,7 @@
 extern boost::recursive_mutex guimutex;
 extern boost::recursive_mutex filemutex;
 extern boost::recursive_mutex &qnummutex;
+extern boost::recursive_mutex soundmutex;
 
 #define GML_STDMUTEX_LOCK(name) boost::mutex::scoped_lock name##lock(name##mutex)
 #define GML_RECMUTEX_LOCK(name) boost::recursive_mutex::scoped_lock name##lock(name##mutex)

Modified: branches/caiinterface/rts/lib/gml/gmlcls.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlcls.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/lib/gml/gmlcls.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -28,21 +28,17 @@
 #include &lt;set&gt;
 
 #ifdef USE_GML
-#	define GML_ENABLE 1
+#	define GML_ENABLE 1 // multithreaded drawing of units and ground
 #else
 #	define GML_ENABLE 0 // manually enable opengl multithreading here
 #endif
 
 #ifdef USE_GML_SIM
-#	define GML_ENABLE_LOOP 1
+#	define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs a completely independent thread loop for the Sim
 #else
-#	define GML_ENABLE_LOOP 0
+#	define GML_ENABLE_SIM 0  // manually enable sim thread here
 #endif
 
-#define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
-#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; GML_ENABLE_LOOP) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
-#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; GML_ENABLE_LOOP) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
-
 #define GML_ENABLE_DRAW (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
 #define GML_SERVER_GLCALL 1 // allows the server thread (0) to make direct GL calls
 #define GML_INIT_QUEUE_SIZE 10 // initial queue size, will be reallocated, but must be &gt;= 4
@@ -51,7 +47,7 @@
 #define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
 //#define GML_USE_QUADRIC_SERVER 1 // use server thread to create/delete quadrics
 #define GML_AUX_PREALLOC 128*1024 // preallocation size for aux queue to reduce risk for hang if gl calls happen to be made from Sim thread
-#define GML_ENABLE_ITEMSERVER_CHECK (GML_ENABLE_SIMDRAW &amp;&amp; 1) // if calls to itemserver are made from Sim, output errors to log
+#define GML_ENABLE_ITEMSERVER_CHECK (GML_ENABLE_SIM &amp;&amp; 1) // if calls to itemserver are made from Sim, output errors to log
 #define GML_UPDSRV_INTERVAL 10
 #define GML_ALTERNATE_SYNCMODE 1 // mutex-protected synced execution, slower but more portable
 #define GML_ENABLE_TLS_CHECK 1 // check if Thread Local Storage appears to be working

Modified: branches/caiinterface/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlsrv.h	2008-12-05 19:57:33 UTC (rev 7130)
+++ branches/caiinterface/rts/lib/gml/gmlsrv.h	2008-12-05 21:15:39 UTC (rev 7131)
@@ -181,7 +181,7 @@
 			int pos=0;
 //			int nproc=0;
 			int updsrv=0;
-			if(gmlThreadCount&gt;1) {
+			if(ex-&gt;maxthreads&gt;1) {
 				while(ClientsReady&lt;=gmlThreadCount+1) {
 					if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 						gmlUpdateServers();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001899.html">[Taspring-linux-commit] r7130 - in	branches/caiinterface/AI/Skirmish: . AAI AAI/data	AAI/data/cfg/mod NTai/AI/NTai/Core NTai/data
</A></li>
	<LI>Next message: <A HREF="001901.html">[Taspring-linux-commit] r7132 - Lobby/springie/Springie/PlanetWars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1900">[ date ]</a>
              <a href="thread.html#1900">[ thread ]</a>
              <a href="subject.html#1900">[ subject ]</a>
              <a href="author.html#1900">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
