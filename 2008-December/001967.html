<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7198 - in branches/caiinterface:	AI/Skirmish/NTai/AI/NTai/Core	AI/Skirmish/NTai/AI/NTai/Helpers Documentation rts/Game
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7198%20-%20in%20branches/caiinterface%3A%0A%09AI/Skirmish/NTai/AI/NTai/Core%0A%09AI/Skirmish/NTai/AI/NTai/Helpers%20Documentation%20rts/Game&In-Reply-To=%3C20081219100449.CF5A54760%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001966.html">
   <LINK REL="Next"  HREF="001968.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7198 - in branches/caiinterface:	AI/Skirmish/NTai/AI/NTai/Core	AI/Skirmish/NTai/AI/NTai/Helpers Documentation rts/Game</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7198%20-%20in%20branches/caiinterface%3A%0A%09AI/Skirmish/NTai/AI/NTai/Core%0A%09AI/Skirmish/NTai/AI/NTai/Helpers%20Documentation%20rts/Game&In-Reply-To=%3C20081219100449.CF5A54760%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7198 - in branches/caiinterface:	AI/Skirmish/NTai/AI/NTai/Core	AI/Skirmish/NTai/AI/NTai/Helpers Documentation rts/Game">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Dec 19 11:04:49 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001966.html">[Taspring-linux-commit] r7197 - branches/gmltest/rts/lib/gml
</A></li>
        <LI>Next message: <A HREF="001968.html">[Taspring-linux-commit] r7199 - in trunk/AI/Global/NTai/AI/NTai:	Core Helpers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1967">[ date ]</a>
              <a href="thread.html#1967">[ thread ]</a>
              <a href="subject.html#1967">[ subject ]</a>
              <a href="author.html#1967">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-19 11:04:48 +0100 (Fri, 19 Dec 2008)
New Revision: 7198

Added:
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.cpp
Modified:
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.h
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/Global.cpp
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/CConfigData.cpp
   branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/Log.cpp
   branches/caiinterface/Documentation/changelog.txt
   branches/caiinterface/rts/Game/GameHelper.cpp
Log:
* reintegrated trunk up to 7197
* fixed NTai (compile and runtime bugs)

Copied: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.cpp (from rev 7197, trunk/AI/Global/NTai/AI/NTai/Core/CCached.cpp)
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.cpp	2008-12-19 10:04:48 UTC (rev 7198)
@@ -0,0 +1,35 @@
+/*
+ *  CCached.cpp
+ *  ntai-xcode
+ *
+ *  Created by Tom Nowell on 18/12/2008.
+ *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *
+ */
+
+#include &quot;include.h&quot;
+
+namespace ntai {
+	//
+	
+	CCached::CCached(Global* G){
+		//
+		comID = 0;
+		randadd = 0;
+		enemy_number = 0;
+		lastcacheupdate = 0;
+		
+		team = G-&gt;cb-&gt;GetMyTeam();
+		
+		cheating = false;
+		encache = new int[6001];
+		
+		//CLOG(&quot;Getting LOS pointer&quot;);
+		losmap = G-&gt;cb-&gt;GetLosMap();
+		
+		//CLOG(&quot;initialising enemy cache elements to zero&quot;);
+		for(int i = 0; i&lt; 6000; i++){
+			encache[i] = 0;
+		}
+	}
+}

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.h
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.h	2008-12-18 20:54:42 UTC (rev 7197)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/CCached.h	2008-12-19 10:04:48 UTC (rev 7198)
@@ -1,28 +1,36 @@
-// cached data
-// data thats held by the Global class is stored in one of these objects to make things look prettier....
-// Also should load/save be implemented it makes it easier to backup data as I can just write this object to disk then bring it back on load up
-
-//class ctri;
-class TCommand;
-
-class CCached {
-public:
-	//
-	const unsigned short* losmap;
-	set&lt;int&gt; enemies; // enemies in LOS
-	//vector&lt;ctri&gt; triangles; // contains all the triangle markers being displayed on map
-
-	bool cheating;
-
-	int allyteam; // the number of this unit ally team
-	int team; // the number of this specific team
-	unsigned int comID; // the ID of the commander
-
-	int randadd; // if 2 processes attempt to get a random variable in the same frame they'll get the same number, so everytime a random
-	//var is needed I increment this number and add it so that the results are always different.
-
-	int* encache;// cached enemy positions to speed up the process of calling the callback interface for the same data so many times
-	unsigned int enemy_number; // the number of cached enemy positions
-	int lastcacheupdate; // when the cached enemy positions where last updated
-	//set&lt;int&gt; cloaked_units;
-};
+// cached data
+// data thats held by the Global class is stored in one of these objects to make things look prettier....
+// Also should load/save be implemented it makes it easier to backup data as I can just write this object to disk then bring it back on load up
+
+//class ctri;
+class TCommand;
+
+namespace ntai {
+	//
+	class Global;
+
+	class CCached {
+	public:
+		//
+		CCached(Global* G);
+
+		const unsigned short* losmap;
+		set&lt;int&gt; enemies; // enemies in LOS
+		//vector&lt;ctri&gt; triangles; // contains all the triangle markers being displayed on map
+
+		bool cheating;
+
+		int allyteam; // the number of this unit ally team
+		int team; // the number of this specific team
+		unsigned int comID; // the ID of the commander
+
+		int randadd; // if 2 processes attempt to get a random variable in the same frame they'll get the same number, so everytime a random
+		//var is needed I increment this number and add it so that the results are always different.
+
+		int* encache;// cached enemy positions to speed up the process of calling the callback interface for the same data so many times
+		unsigned int enemy_number; // the number of cached enemy positions
+		int lastcacheupdate; // when the cached enemy positions where last updated
+		//set&lt;int&gt; cloaked_units;
+	};
+
+}

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/Global.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/Global.cpp	2008-12-18 20:54:42 UTC (rev 7197)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Core/Global.cpp	2008-12-19 10:04:48 UTC (rev 7198)
@@ -1,1496 +1,1473 @@
-//-------------------------------------------------------------------------
-// NTai
-// Copyright 2004-2007 AF
-// Released under GPL 2 license
-//-------------------------------------------------------------------------
-
-#include &quot;include.h&quot;
-
-namespace ntai {
-
-	int iterations=0;
-	bool loaded=false;
-	bool firstload=false;
-	bool saved=false;
-	map&lt;string, float&gt; efficiency;
-	map&lt;string, float&gt; builderefficiency;
-	map&lt;string, int&gt; lastbuilderefficiencyupdate;
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	TdfParser* Global::Get_mod_tdf(){
-		return info-&gt;mod_tdf;
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void trim(string &amp;str){
-		string::size_type pos = str.find_last_not_of(' ');
-		if(pos != string::npos) {
-			str.erase(pos + 1);
-			pos = str.find_first_not_of(' ');
-			if(pos != string::npos) str.erase(0, pos);
-		}
-		else str.erase(str.begin(), str.end());
-	}
-
-	bool ValidUnitID(int id){
-		if(id &lt; 0) return false;
-		if(id &gt; MAX_UNITS+1) return false;
-		return true;
-	}
-
-	Global::Global(IGlobalAICallback* callback){
-		G = this;
-		gcb = callback;
-		cb = gcb-&gt;GetAICallback();
-		if(cb == 0){
-			throw string(&quot; error cb ==0&quot;);
-		}
-		CLOG(&quot;Started Global::Global class constructor&quot;);
-		CLOG(&quot;Starting CCached initialisation&quot;);
-		Cached = new CCached;
-		Cached-&gt;comID = 0;
-		Cached-&gt;randadd = 0;
-		Cached-&gt;enemy_number = 0;
-		Cached-&gt;lastcacheupdate = 0;
-		Cached-&gt;team = 567;
-		CLOG(&quot;getting team value&quot;);
-		Cached-&gt;team = cb-&gt;GetMyTeam();
-
-		CLOG(&quot;Creating Config holder class&quot;);
-		info = new CConfigData(G);
-
-		CLOG(&quot;Setting the Logger class&quot;);
-		L.Set(this);
-
-		CLOG(&quot;Loading AI.tdf with TdfParser&quot;);
-		TdfParser cs(G);
-		cs.LoadFile(&quot;AI/AI.tdf&quot;);
-
-		CLOG(&quot;Retrieving datapath value&quot;);
-		info-&gt;datapath = cs.SGetValueDef(string(&quot;AI/NTai&quot;), &quot;AI\\data_path&quot;);
-
-		CLOG(&quot;Opening logfile in plaintext&quot;);
-		L.Open(true);
-		//L.Verbose();
-
-		CLOG(&quot;Logging class Opened&quot;);
-		L.print(&quot;logging started&quot;);
-
-		CLOG(&quot;Loading modinfo.tdf&quot;);
-		TdfParser sf(G);
-		if(sf.LoadFile(&quot;modinfo.tdf&quot;)){
-			L.print(&quot;modinfo.tdf loaded into parser&quot;);
-		} else {
-			L.eprint(&quot;error modinfo.tdf retrieval failed&quot;);
-		}
-
-		CLOG(&quot;Getting tdfpath value&quot;);
-		info-&gt;tdfpath =  sf.SGetValueDef(string(cb-&gt;GetModName()), &quot;MOD\\NTAI\\tdfpath&quot;);
-
-		CLOG(&quot;Retrieving cheat interface&quot;);
-		chcb = callback-&gt;GetCheatInterface();
-
-		CLOG(&quot;cheat interface retrieved&quot;);
-		Cached-&gt;cheating = false;
-		Cached-&gt;encache = new int[6001];
-
-		CLOG(&quot;Getting LOS pointer&quot;);
-		Cached-&gt;losmap = cb-&gt;GetLosMap();
-
-		CLOG(&quot;initialising enemy cache elements to zero&quot;);
-		for(int i = 0; i&lt; 6000; i++){
-			Cached-&gt;encache[i] = 0;
-		}
-
-		CLOG(&quot;Creating Actions class&quot;);
-		Actions = new CActions(G);
-
-		CLOG(&quot;Creating Map class&quot;);
-		Map = new CMap(G);
-
-		CLOG(&quot;Map class created&quot;);
-		if(L.FirstInstance() == true){
-			CLOG(&quot;First Instance == true&quot;);
-			loaded = false;
-			firstload = false;
-			iterations = 0;
-			saved = false;
-		}
-
-		CLOG(&quot;Creating MetalHandler class&quot;);
-		M = new CMetalHandler(G);
-
-		CLOG(&quot;Loading Metal cache&quot;);
-		M-&gt;loadState();
-
-		CLOG(&quot;View The NTai Log file from here on&quot;);
-		/*if(M-&gt;hotspot.empty() == false){
-			 for(vector&lt;float3&gt;::iterator hs = M-&gt;hotspot.begin(); hs != M-&gt;hotspot.end(); ++hs){
-				 float3 tpos = *hs;
-				 tpos.y = cb-&gt;GetElevation(tpos.x,tpos.z);
-				 ctri triangle = Tri(tpos);
-				 triangles.push_back(triangle);
-			 }
-		 }*/
-		//if(L.FirstInstance() == true){
-		L &lt;&lt; &quot; :: Found &quot; &lt;&lt; M-&gt;m-&gt;NumSpotsFound &lt;&lt; &quot; Metal Spots&quot; &lt;&lt; endline;
-		//}
-		UnitDefLoader = new CUnitDefLoader(G);
-		L.print(&quot;Unitdef loader constructed&quot;);
-
-		OrderRouter = new COrderRouter(G);
-		L.print(&quot;Order Router constructed&quot;);
-
-		DTHandler = new CDTHandler(G);
-		L.print(&quot;DTHandler constructed&quot;);
-
-		RadarHandler = new CRadarHandler(G);
-		L.print(&quot;RadarHandler constructed&quot;);
-
-		Pl = new Planning(G);
-		L.print(&quot;Planning constructed&quot;);
-
-
-		Economy = new CEconomy(G);
-		L.print(&quot;Economy constructed&quot;);
-
-		Manufacturer = boost::shared_ptr&lt;CManufacturer&gt;(new CManufacturer(this));
-		L.print(&quot;Manufacturer constructed&quot;);
-
-		BuildingPlacer = boost::shared_ptr&lt;CBuildingPlacer&gt;(new CBuildingPlacer(this));
-		L.print(&quot;BuildingPlacer constructed&quot;);
-
-		Ch = new Chaser;
-		L.print(&quot;Chaser constructed&quot;);
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	Global::~Global(){
-		SaveUnitData();
-		L.Close();
-		delete[] Cached-&gt;encache;
-		delete info;
-		delete DTHandler;
-		delete Economy;
-		delete RadarHandler;
-		delete Actions;
-		delete Map;
-		delete Ch;
-		delete Pl;
-		delete M;
-		delete Cached;
-		delete OrderRouter;
-		delete UnitDefLoader;
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	map&lt;int, const UnitDef*&gt; endefs;
-	const UnitDef* Global::GetEnemyDef(int enemy){
-		if(endefs.find(enemy) == endefs.end()){
-			const UnitDef* ud = GetUnitDef(enemy);
-			if(ud == 0){
-				return 0;
-			}else{
-				endefs[enemy] = ud;
-				return ud;
-			}
-		} else{
-			return endefs[enemy];
-		}
-		return 0;
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::EnemyDamaged(int damaged, int attacker, float damage, float3 dir){
-		/*Ch-&gt;EnemyDamaged(damaged, attacker, damage, dir);
-		START_EXCEPTION_HANDLING
-		CMessage message(&quot;enemydamaged&quot;);
-		message.AddParameter(damaged);
-		message.AddParameter(attacker);
-		message.AddParameter(damage);
-		message.AddParameter(dir);
-		FireEvent(message);
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;enemydamaged\&quot;); FireEvent(message);&quot;)*/
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::Update(){
-		bool paused = false;
-
-		NLOG(&quot;Global::Update()&quot;);
-		cb-&gt;GetValue(AIVAL_GAME_PAUSED, &amp;paused);
-		if(paused) return;
-		START_EXCEPTION_HANDLING
-
-		if(!handlers.empty()){
-			if(!msgqueue.empty()){
-				int n = 0;
-				for(vector&lt;CMessage&gt;::iterator mi = msgqueue.begin(); mi != msgqueue.end(); ++mi){
-					if(mi-&gt;IsDead(GetCurrentFrame())){
-						continue;
-					}
-
-					n++;
-
-					for(set&lt;boost::shared_ptr&lt;IModule&gt; &gt;::iterator k = handlers.begin(); k != handlers.end(); ++k){
-						if((*k)-&gt;IsValid()){
-							(*k)-&gt;RecieveMessage(*mi);
-						}else{
-							RemoveHandler((*k));
-						}
-					}
-
-					// We dont want to do everything at once if the queue is gigantic
-					if(n &gt;15){
-						// so erase what we've already parsed and exit the loop, we
-						// can do the rest of the queue in the next update call.
-						msgqueue.erase(msgqueue.begin(),mi);
-						break;
-					}
-				}
-
-				msgqueue.erase(msgqueue.begin(),msgqueue.end());
-			}
-
-		}
-
-		if(cb-&gt;GetCurrentFrame() == (1 SECOND)){
-			NLOG(&quot;STARTUP BANNER IN Global::Update()&quot;);
-
-			if(L.FirstInstance()){
-				string s = string(&quot;:: &quot;) + AI_NAME + string(&quot; by AF&quot;);
-				cb-&gt;SendTextMsg(s.c_str(), 0);
-				cb-&gt;SendTextMsg(&quot;:: Copyright (C) 2006 AF&quot;, 0);
-				string q = string(&quot; :: &quot;) + Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\message&quot;);
-				if(q != string(&quot;&quot;)){
-					cb-&gt;SendTextMsg(q.c_str(), 0);
-				}
-				cb-&gt;SendTextMsg(&quot;Please check www.darkstars.co.uk for updates&quot;, 0);
-			}
-
-			int* ax = new int[10000];
-			int anum =cb-&gt;GetFriendlyUnits(ax);
-			
-			ComName = string(&quot;&quot;);
-	        
-			if(anum !=0){
-				for(int a = 0; a&lt;anum; a++){
-					if(cb-&gt;GetUnitTeam(ax[a]) == cb-&gt;GetMyTeam()){
-						const UnitDef* ud = GetUnitDef(ax[a]);
-						if(ud!=0){
-							//
-							ComName = ud-&gt;name;
-							Cached-&gt;comID=ax[a];
-						}
-					}
-				}
-			}
-			delete[] ax;
-		}
-		END_EXCEPTION_HANDLING(&quot;Startup Banner and getting commander name&quot;)
-
-		START_EXCEPTION_HANDLING
-		OrderRouter-&gt;Update();
-		END_EXCEPTION_HANDLING(&quot;OrderRouter-&gt;Update()&quot;)
-
-		//if( EVERY_((2 SECONDS)) &amp;&amp; (Cached-&gt;cheating == true) ){
-		//	float a = cb-&gt;GetEnergyStorage() - cb-&gt;GetEnergy();
-		//	if( a &gt; 50) chcb-&gt;GiveMeEnergy(a);
-		//	a = cb-&gt;GetMetalStorage() - cb-&gt;GetMetal();
-		//	if(a &gt; 50) chcb-&gt;GiveMeMetal(a);
-		//}
-
-		START_EXCEPTION_HANDLING
-		if(EVERY_((2 MINUTES))){
-			//L.print(&quot;saving UnitData&quot;);
-			SaveUnitData();
-			/*if(!SaveUnitData()){
-			 L.print(&quot;UnitData saved&quot;);
-			 }else{
-			 L.print(&quot;UnitData not saved&quot;);
-			 }*/
-		}
-		END_EXCEPTION_HANDLING(&quot;SaveUnitData()&quot;)
-
-		//EXCEPTION_HANDLER(Pl-&gt;Update(),&quot;Pl-&gt;Update()&quot;,NA)
-
-		START_EXCEPTION_HANDLING
-		Actions-&gt;Update();
-		END_EXCEPTION_HANDLING(&quot;Actions-&gt;Update()&quot;)
-
-		START_EXCEPTION_HANDLING
-
-		CMessage message(&quot;update&quot;);
-
-		// a lifetime of 15 frames, so there should never be more than
-		// a backlog of 15 valid update messages
-		message.SetLifeTime(15);
-		
-		FireEvent(message);
-
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;update\&quot;); FireEvent(message);&quot;)
-
-		//EXCEPTION_HANDLER(Manufacturer-&gt;Update(),&quot;Manufacturer-&gt;Update()&quot;,NA)
-		Ch-&gt;Update();
-
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::SortSolobuilds(int unit){
-		Cached-&gt;enemies.erase(unit);
-		if(endefs.find(unit) != endefs.end()) endefs.erase(unit);
-
-		CUnitTypeData* u = UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
-
-		const UnitDef* ud = u-&gt;GetUnitDef();
-	    
-		if(ud != 0){
-			bool found = false;
-			string s  = u-&gt;GetName();
-
-			if(u-&gt;GetSingleBuild()){
-				u-&gt;SetSingleBuildActive(true);
-			}
-
-			if(u-&gt;GetSoloBuild()){
-				u-&gt;SetSoloBuildActive(true);
-			}
-		}
-	}
-
-	void Global::UnitCreated(int unit){
-
-		if(!ValidUnitID(unit)) return;
-		START_EXCEPTION_HANDLING
-		SortSolobuilds(unit);
-		END_EXCEPTION_HANDLING(&quot;Sorting solobuilds and singlebuilds in Global::UnitCreated&quot;)
-
-		//EXCEPTION_HANDLER(Ch-&gt;UnitCreated(unit),&quot;Ch-&gt;UnitCreated&quot;,NA)
-
-		START_EXCEPTION_HANDLING
-		Manufacturer-&gt;UnitCreated(unit);
-		END_EXCEPTION_HANDLING(&quot;Manufacturer-&gt;UnitCreated&quot;)
-
-		START_EXCEPTION_HANDLING
-		const UnitDef* udf = GetUnitDef(unit);
-		if(udf){
-			CUnitTypeData* utd = UnitDefLoader-&gt;GetUnitTypeDataById(udf-&gt;id);
-			if(!utd-&gt;IsMobile()){
-				BuildingPlacer-&gt;Block(G-&gt;GetUnitPos(unit), utd);
-			}
-		}
-		END_EXCEPTION_HANDLING(&quot;Global::UnitFinished blocking map for unit&quot;)
-
-		START_EXCEPTION_HANDLING
-		boost::shared_ptr&lt;CUnit&gt; Unit = boost::shared_ptr&lt;CUnit&gt;(new CUnit(G, unit));
-		boost::shared_ptr&lt;ITaskManager&gt; taskManager(new CConfigTaskManager(G,Unit));
-		Unit-&gt;SetTaskManager(taskManager);
-		Unit-&gt;Init();
-		units[unit] = Unit;
-		RegisterMessageHandler(Unit);
-		CMessage message(&quot;unitcreated&quot;);
-		message.AddParameter(unit);
-		FireEvent(message);
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitcreated\&quot;); FireEvent(message);&quot;)
-
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-	void Global::EnemyDestroyed(int enemy, int attacker){
-
-		if(ValidUnitID(attacker)){
-			/*if(positions.empty()==false){
-			 map&lt;int,temp_pos&gt;::iterator i = positions.find(enemy);
-			 if(i != positions.end()){
-			 positions.erase(i);
-			 }
-			 }*/
-			Cached-&gt;enemies.erase(attacker);
-			if(endefs.find(enemy) != endefs.end()) endefs.erase(enemy);
-			const UnitDef* uda = GetUnitDef(enemy);
-			if(uda != 0){
-				float e = GetEfficiency(uda-&gt;name, uda-&gt;power);
-				e =200/uda-&gt;metalCost;
-				SetEfficiency(uda-&gt;name, e);
-			}
-
-			uda = GetUnitDef(enemy);
-			if(uda != 0){
-				float e = GetEfficiency(uda-&gt;name, uda-&gt;power);
-				e -=200/uda-&gt;metalCost;
-				SetEfficiency(uda-&gt;name, e);
-			}
-
-			Ch-&gt;EnemyDestroyed(enemy, attacker);
-			START_EXCEPTION_HANDLING
-			CMessage message(&quot;enemydestroyed&quot;);
-			message.AddParameter(enemy);
-			message.AddParameter(attacker);
-			FireEvent(message);
-			END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;enemydestroyed\&quot;); FireEvent(message);&quot;)
-		}
-		//Actions-&gt;EnemyDestroyed(enemy,attacker);
-
-	}
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::UnitFinished(int unit){
-
-		//START_EXCEPTION_HANDLING
-		CUnitTypeData* u = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
-		if(u ==0){
-			return;
-		}
-		const UnitDef* ud = u-&gt;GetUnitDef();
-		if(ud!=0){
-			if(ud-&gt;isCommander){
-				G-&gt;Cached-&gt;comID = unit;
-			}
-			max_energy_use += ud-&gt;energyUpkeep;
-
-			// prepare unitname
-			string t = u-&gt;GetName();
-
-			// solo build cleanup
-
-			// Regardless of wether the unit is subject to this behaviour the value of
-			// solobuildactive will always be false, so why bother running a check?
-			u-&gt;SetSoloBuildActive(false);
-
-			if(ud-&gt;movedata == 0){
-				if(!ud-&gt;canfly){
-					if(!ud-&gt;builder){
-						float3 upos = GetUnitPos(unit);
-						if(upos != UpVector){
-							DTHandler-&gt;AddRing(upos, 500.0f, float(PI_2) / 6.0f);
-							DTHandler-&gt;AddRing(upos, 700.0f, float(-PI_2) / 6.0f);
-						}
-					}
-				}
-			}
-		}
-		//END_EXCEPTION_HANDLING(&quot;Sorting solobuild additions and DT Rings in Global::UnitFinished &quot;)
-
-		//START_EXCEPTION_HANDLING
-		Manufacturer-&gt;UnitFinished(unit);
-		//END_EXCEPTION_HANDLING(&quot;Manufacturer-&gt;UnitFinished&quot;)
-
-		//START_EXCEPTION_HANDLING
-		Ch-&gt;UnitFinished(unit);
-		//END_EXCEPTION_HANDLING(&quot;Ch-&gt;UnitFinished&quot;)
-
-		//START_EXCEPTION_HANDLING
-		CMessage message(&quot;unitfinished&quot;);
-		message.AddParameter(unit);
-		FireEvent(message);
-		//END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitfinished\&quot;);&quot;)
-
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::UnitMoveFailed(int unit){
-
-		/*
-
-		START_EXCEPTION_HANDLING
-		Manufacturer-&gt;UnitMoveFailed(unit);
-		END_EXCEPTION_HANDLING(&quot;Manufacturer-&gt;UnitIdle in UnitMoveFailed&quot;)
-
-		START_EXCEPTION_HANDLING
-		Ch-&gt;UnitMoveFailed(unit);
-		END_EXCEPTION_HANDLING(&quot;Ch-&gt;UnitIdle in UnitMoveFailed&quot;)*/
-
-		START_EXCEPTION_HANDLING
-		CMessage message(&quot;unitmovefailed&quot;);
-		message.AddParameter(unit);
-		FireEvent(message);
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitmovefailed\&quot;); FireEvent(message);&quot;)
-
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::UnitIdle(int unit){
-		if(!ValidUnitID(unit)){
-			L.print(&quot;CManufacturer::UnitIdle negative uid, aborting&quot;);
-			return;
-		}
-		if(GetCurrentFrame() &lt; 5 SECONDS){
-			return;
-		}
-		START_EXCEPTION_HANDLING
-		CMessage message(&quot;unitidle&quot;);
-		message.AddParameter(unit);
-		FireEvent(message);
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitidle\&quot;); FireEvent(message);&quot;)
-
-		//EXCEPTION_HANDLER(Manufacturer-&gt;UnitIdle(unit),&quot;Manufacturer-&gt;UnitIdle&quot;,NA)
-
-		//EXCEPTION_HANDLER(Actions-&gt;UnitIdle(unit),&quot;Actions-&gt;UnitIdle&quot;,NA)
-
-		START_EXCEPTION_HANDLING
-		Ch-&gt;UnitIdle(unit);
-		END_EXCEPTION_HANDLING(&quot;Ch-&gt;UnitIdle&quot;)
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-	void Global::Crash(){
-		NLOG(&quot; Deliberate Global::Crash routine&quot;);
-		// close the logfile
-		SaveUnitData();
-		L.header(&quot;\n :: The user has initiated a crash, terminating NTai \n&quot;);
-		L.Close();
-		START_EXCEPTION_HANDLING
-		CMessage message(&quot;crash&quot;);
-		FireEvent(message);
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;crash\&quot;); FireEvent(message);&quot;)
-	#ifndef DEBUG
-		// Create an exception forcing spring to close
-		vector&lt;string&gt; cv;
-		string n = cv.back();
-	#endif
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::UnitDamaged(int damaged, int attacker, float damage, float3 dir){
-		NLOG(&quot;Global::UnitDamaged&quot;);
-
-		if(damage &lt;= 0) return;
-		if(!ValidUnitID(damaged)) return;
-		if(!ValidUnitID(attacker)) return;
-
-		//START_EXCEPTION_HANDLING
-		if(cb-&gt;GetUnitAllyTeam(attacker) == cb-&gt;GetUnitAllyTeam(damaged)){
-			return;
-		}
-		//END_EXCEPTION_HANDLING(&quot;Global::UnitDamaged, filtering out bad calls&quot;)
-
-		//START_EXCEPTION_HANDLING
-		const UnitDef* uda = GetUnitDef(attacker);
-
-		if(uda != 0){
-			float e = GetEfficiency(uda-&gt;name, uda-&gt;power);
-			e += 10000/uda-&gt;metalCost;
-			SetEfficiency(uda-&gt;name, e);
-		}
-		const UnitDef* udb = GetUnitDef(damaged);
-
-		if(udb != 0){
-			float e = GetEfficiency(udb-&gt;name, udb-&gt;power);
-			e -= 10000/uda-&gt;metalCost;
-			SetEfficiency(udb-&gt;name, e);
-			/*if(udb-&gt;builder &amp;&amp; UnitDefHelper-&gt;IsMobile(udb)&amp;&amp;udb-&gt;weapons.empty()){
-				// if ti isnt currently building something then retreat
-				const CCommandQueue* uc = cb-&gt;GetCurrentUnitCommands(damaged);
-				if(uc != 0){
-					//
-					if(uc-&gt;front().id &gt;= 0){
-						G-&gt;Actions-&gt;Retreat(damaged);
-					}
-				}
-			}*/
-		}
-		//END_EXCEPTION_HANDLING(&quot;Global::UnitDamaged, threat value handling&quot;)
-
-		//START_EXCEPTION_HANDLING
-		Actions-&gt;UnitDamaged(damaged, attacker, damage, dir);
-		//END_EXCEPTION_HANDLING(&quot;Actions-&gt;UnitDamaged()&quot;)
-
-		Ch-&gt;UnitDamaged(damaged, attacker, damage, dir);
-
-		/*START_EXCEPTION_HANDLING*/
-		CMessage message(&quot;unitdamaged&quot;);
-		message.AddParameter(damaged);
-		message.AddParameter(attacker);
-		message.AddParameter(damage);
-		message.AddParameter(dir);
-		FireEvent(message);
-		/*END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitdamaged\&quot;); FireEvent(message);&quot;)*/
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-	void Global::GotChatMsg(const char* msg, int player){
-		L.Message(msg, player);
-		string tmsg = msg;
-		if(tmsg == string(&quot;.verbose&quot;)){
-			if(L.Verbose()){
-				L.iprint(&quot;Verbose turned on&quot;);
-			} else L.iprint(&quot;Verbose turned off&quot;);
-		}else if(tmsg == string(&quot;.crash&quot;)){
-			Crash();
-		}else if(tmsg == string(&quot;.end&quot;)){
-			exit(0);
-		}else if(tmsg == string(&quot;.break&quot;)){
-			if(L.FirstInstance() == true){
-				L.print(&quot;The user initiated debugger break&quot;);
-			}
-		}else if(tmsg == string(&quot;.isfirst&quot;)){
-			if(L.FirstInstance() == true) L.iprint(&quot; info :: This is the first NTai instance&quot;);
-		}else if(tmsg == string(&quot;.save&quot;)){
-			if(L.FirstInstance() == true) SaveUnitData();
-		}else if(tmsg == string(&quot;.reload&quot;)){
-			if(L.FirstInstance() == true) LoadUnitData();
-		}else if(tmsg == string(&quot;.flush&quot;)){
-			L.Flush();
-		}else if(tmsg == string(&quot;.threat&quot;)){
-			Ch-&gt;MakeTGA();
-		}/*else if(tmsg == string(&quot;.gridtest&quot;)){
-		 if(Ch-&gt;gridmaintainer==false) return;
-		 float cellvalue = 0;
-		 Ch-&gt;Grid-&gt;SetValuebyIndex(10,299.0f);
-		 cellvalue = Ch-&gt;Grid-&gt;GetValue(10);
-		 if(cellvalue==299.0f){
-		 G-&gt;L.iprint(&quot;Test 1 PASSED&quot;);
-		 }else{
-		 G-&gt;L.iprint(&quot;Test1 FAILED&quot;);
-		 }
-		 cellvalue=0;
-		 float3 mpos = float3(2048,0,2048);
-		 Ch-&gt;Grid-&gt;SetValuebyMap(mpos,999.0f);
-		 cellvalue=Ch-&gt;Grid-&gt;GetValuebyMap(mpos);
-		 if(cellvalue == 999.0f){
-		 L.iprint(&quot;Test 2 PASSED&quot;);
-		 }else{
-		 G-&gt;L.iprint(&quot;Test 2 FAILED&quot;);
-		 }
-		 if(Ch-&gt;Grid-&gt;GridtoMap(Ch-&gt;Grid-&gt;MaptoGrid(mpos)) == mpos){
-		 G-&gt;L.iprint(&quot;Test 3 PASSED&quot;);
-		 }else{
-		 G-&gt;L.iprint(&quot;Test 3 FAILED&quot;);
-		 }
-		 cellvalue=0;
-		 float3 gpos = float3(4,0,4);
-		 Ch-&gt;Grid-&gt;SetValuebyGrid(gpos,799.0f);
-		 cellvalue=Ch-&gt;Grid-&gt;GetValuebyGrid(gpos);
-		 if(cellvalue == 799.0f){
-		 L.iprint(&quot;Test 4 PASSED&quot;);
-		 }else{
-		 G-&gt;L.iprint(&quot;Test 4 FAILED&quot;);
-		 }
-		 if(Ch-&gt;Grid-&gt;MaptoGrid(Ch-&gt;Grid-&gt;GridtoMap(gpos)) == gpos){
-		 G-&gt;L.iprint(&quot;Test 5 PASSED&quot;);
-		 }else{
-		 G-&gt;L.iprint(&quot;Test 5 FAILED&quot;);
-		 }
-		 if(Ch-&gt;Grid-&gt;IndextoGrid(Ch-&gt;Grid-&gt;GetIndex(gpos)) == gpos){
-		 G-&gt;L.iprint(&quot;Test 6 PASSED&quot;);
-		 }else{
-		 G-&gt;L.iprint(&quot;Test 6 FAILED&quot;);
-		 }
-		 Ch-&gt;MakeTGA();
-		 }*/else if(tmsg == string(&quot;.aicheat&quot;)){
-			 //chcb = G-&gt;gcb-&gt;GetCheatInterface();
-			 if(Cached-&gt;cheating== false){
-				 Cached-&gt;cheating = true;
-				 chcb-&gt;SetMyHandicap(1000.0f);
-				 if(L.FirstInstance() == true) L.iprint(&quot;Make sure you've typed .cheat for full cheating!&quot;);
-				 // Spawn 4 commanders around the starting position
-				 CUnitTypeData* ud = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(ComName);
-				 if(ud != 0){
-					 float3 pos = Map-&gt;basepos;
-					 pos = cb-&gt;ClosestBuildSite(ud-&gt;GetUnitDef(), pos, 1000.0f, 0);
-					 int ij = chcb-&gt;CreateUnit(ComName.c_str(), pos);
-					 if(ij != 0) Actions-&gt;RandomSpiral(ij);
-					 float3 epos = pos;
-					 epos.z -= 1300.0f;
-					 float angle = float(mrand()%320);
-					 pos = G-&gt;Map-&gt;Rotate(epos, angle, pos);
-					 pos =  cb-&gt;ClosestBuildSite(ud-&gt;GetUnitDef(), pos, 1000, 300, 1);
-					 ///float3 ClosestBuildSite(const UnitDef* unitdef,float3 pos,float searchRadius,int minDist, int facing);
-					 ij = chcb-&gt;CreateUnit(ComName.c_str(), pos);
-					 if(ij != 0) Actions-&gt;RandomSpiral(ij);
-					 epos = pos;
-					 epos.z -= 900.0f;
-
-					 angle = float(mrand()%320);
-					 pos = G-&gt;Map-&gt;Rotate(epos, angle, pos);
-					 pos =  cb-&gt;ClosestBuildSite(ud-&gt;GetUnitDef(), pos, 1000, 300, 0);
-					 ///
-					 ij = chcb-&gt;CreateUnit(ComName.c_str(), pos);
-					 if(ij != 0){
-						 Actions-&gt;RandomSpiral(ij);
-					 }
-				 }
-			 }else if(Cached-&gt;cheating == true){
-				 Cached-&gt;cheating  = false;
-				 if(L.FirstInstance() == true)L.iprint(&quot;cheating is now disabled therefore NTai will no longer cheat&quot;);
-			 }
-		 }
-		//START_EXCEPTION_HANDLING
-		CMessage message(string(&quot;##&quot;)+msg);
-		message.AddParameter(player);
-		FireEvent(message);
-		//END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;msg gotmsg\&quot;); FireEvent(message);&quot;)
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::UnitDestroyed(int unit, int attacker){
-
-		if(!(ValidUnitID(unit)&amp;&amp;ValidUnitID(attacker))){
-			return;
-		}
-		units.erase(unit);
-
-		idlenextframe.erase(unit);
-
-		CUnitTypeData* u = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
-
-		const UnitDef* udu = u-&gt;GetUnitDef();
-		if(udu != 0){
-			max_energy_use -= udu-&gt;energyUpkeep;
-			u-&gt;SetSingleBuildActive(false);
-			u-&gt;SetSoloBuildActive(false);
-		}
-
-		if(ValidUnitID(attacker)){
-			CUnitTypeData* atd = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(attacker);
-			if(atd != 0){
-				const UnitDef* uda = atd-&gt;GetUnitDef();
-				if((uda != 0)&amp;&amp;(udu != 0)){
-					
-
-					if(efficiency.find(uda-&gt;name) != efficiency.end()){
-						efficiency[uda-&gt;name] += 20000/udu-&gt;metalCost;
-					}else{
-						efficiency[uda-&gt;name] = 500;
-					}
-					if(efficiency.find(udu-&gt;name) != efficiency.end()){
-						efficiency[udu-&gt;name] -= 10000/uda-&gt;metalCost;
-					}else{
-						efficiency[udu-&gt;name] = 500;
-					}
-				}
-			}
-		}
-
-		START_EXCEPTION_HANDLING
-		CMessage message(&quot;unitdestroyed&quot;);
-		message.AddParameter(unit);
-		FireEvent(message);
-		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitdestroyed\&quot;); FireEvent(message);&quot;);
-
-		//Actions-&gt;UnitDestroyed(unit);
-		Cached-&gt;enemies.erase(unit);
-		Manufacturer-&gt;UnitDestroyed(unit);
-		Ch-&gt;UnitDestroyed(unit, attacker);
-		OrderRouter-&gt;UnitDestroyed(unit);
-		units.erase(unit);
-	}
-
-	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	void Global::InitAI(IAICallback* callback, int team){
-		L.print(&quot;Initialisising&quot;);
-
-		mrand.seed(uint(time(NULL)*team));
-		string filename = info-&gt;datapath + slash + string(&quot;NTai.tdf&quot;);
-
-		filename = info-&gt;datapath + &quot;/&quot; +  info-&gt;tdfpath + string(&quot;.tdf&quot;);
-		string* buffer = new string();
-		TdfParser* q = new TdfParser(this);
-
-		if(cb-&gt;GetFileSize(filename.c_str())!=-1){
-
-			q-&gt;LoadFile(filename);
-			L.print(&quot;Mod TDF loaded&quot;);
-			filename = info-&gt;datapath + &quot;/&quot; + q-&gt;SGetValueDef(&quot;configs/default.tdf&quot;, &quot;NTai\\modconfig&quot;);
-
-		} else {/////////////////
-
-			TdfParser* w = new TdfParser(this, &quot;modinfo.tdf&quot;);
-			info-&gt;_abstract = true;
-			L.header(&quot; :: mod.tdf failed to load, assuming default values&quot;);
-			L.header(endline);
-			// must write out a config and put in it the default stuff......
-			ofstream off;
-			//string filename = info-&gt;datapath + &quot;/learn/&quot; + info-&gt;tdfpath +&quot;.tdf&quot;;
-			off.open(filename.c_str());
-			if(off.is_open() == true){
-				//off &lt;&lt;
-				off &lt;&lt; &quot;[NTai]&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;{&quot;&lt;&lt;endl;
-				off &lt;&lt; &quot;\tlearndata=&quot; &lt;&lt; &quot;learn/&quot; &lt;&lt; info-&gt;tdfpath &lt;&lt;&quot;.tdf;&quot;&lt;&lt;endl;
-				off &lt;&lt; &quot;\tmodconfig=&quot; &lt;&lt; &quot;configs/&quot; &lt;&lt; info-&gt;tdfpath &lt;&lt; &quot;.tdf;&quot; &lt;&lt; endl;
-				off &lt;&lt;&quot;\tmodname=&quot; &lt;&lt; w-&gt;SGetValueMSG(&quot;MOD\\Name&quot;) &lt;&lt; &quot;;&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;}&quot;&lt;&lt;endl;
-				off.close();
-				filename = info-&gt;datapath + slash + string(&quot;configs&quot;) + slash +  info-&gt;tdfpath + string(&quot;.tdf&quot;);
-				off.open(filename.c_str());
-				if(off.is_open() == true){
-					//off &lt;&lt;
-					filename = info-&gt;datapath + slash + string(&quot;configs&quot;) + slash + string(&quot;default.tdf&quot;);
-					string* buffer2 = new string();
-					ReadFile(filename, buffer2);
-					off &lt;&lt; *buffer2;
-					off.close();
-				}
-			}
-			delete w;
-		}
-		delete q;
-
-		//
-		if(cb-&gt;GetFileSize(filename.c_str())!=-1){
-			Get_mod_tdf()-&gt;LoadFile(filename);
-			L.print(&quot;Mod TDF loaded&quot;);
-
-		} else {/////////////////
-
-			info-&gt;_abstract = true;
-			L.header(&quot; :: mod.tdf failed to load, assuming default values&quot;);
-			L.header(endline);
-		}
-		delete buffer;
-
-		//load all the mod.tdf settings!
-		info-&gt;Load();
-		
-		if(info-&gt;_abstract == true){
-			L.print(&quot;abstract == true&quot;);
-		}
-
-		L.print(&quot;values filled&quot;);
-
-		// initial handicap
-		float x = 0;
-		Get_mod_tdf()-&gt;GetDef(x, &quot;0&quot;, &quot;AI\\normal_handicap&quot;);
-		chcb = G-&gt;gcb-&gt;GetCheatInterface();
-		chcb-&gt;SetMyHandicap(x);
-
-	    
-
-		// solobuild
-		set&lt;std::string&gt; solotemp;
-		string sb = Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\SoloBuild&quot;);
-		CTokenizer&lt;CIsComma&gt;::Tokenize(solotemp, sb, CIsComma());
-
-
-		if(!solotemp.empty()){
-			for(set&lt;string&gt;::iterator i = solotemp.begin(); i != solotemp.end(); ++i){
-				CUnitTypeData* u = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(*i);
-				if(u){
-					u-&gt;SetSoloBuild(true);
-				}
-			}
-		}
-
-		Cached-&gt;allyteam = cb-&gt;GetMyAllyTeam();
-
-		CTokenizer&lt;CIsComma&gt;::Tokenize(Pl-&gt;AlwaysAntiStall, Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\AlwaysAntiStall&quot;), CIsComma());
-		//Pl-&gt;AlwaysAntiStall = bds::set_cont(Pl-&gt;AlwaysAntiStall, Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\AlwaysAntiStall&quot;));
-
-		vector&lt;string&gt; singlebuild;
-		sb = Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\SingleBuild&quot;);
-		CTokenizer&lt;CIsComma&gt;::Tokenize(singlebuild, sb);
-
-		if(singlebuild.empty() == false){
-			for(vector&lt;string&gt;::iterator i= singlebuild.begin(); i != singlebuild.end(); ++i){
-				string s = *i;
-				trim(s);
-				tolowercase(s);
-
-				CUnitTypeData* u = UnitDefLoader-&gt;GetUnitTypeDataByName(s);
-
-				u-&gt;SetSingleBuild(true);
-			}
-		}
-
-		L.print(&quot;Arrays filled&quot;);
-		if(info-&gt;_abstract == true){
-			L.header(&quot; :: Using abstract buildtree&quot;);
-			L.header(endline);
-		}
-
-		if(info-&gt;gaia){
-			L.header(&quot; :: GAIA AI On&quot;);
-			L.header(endline);
-		}
-
-		L.header(endline);
-		if(loaded == false){
-			L.print(&quot;Loading unit data&quot;);
-			LoadUnitData();
-			L.print(&quot;Unit data loaded&quot;);
-		}
-
-		L &lt;&lt; &quot; :: &quot; &lt;&lt; cb-&gt;GetMapName() &lt;&lt; endline &lt;&lt; &quot; :: &quot; &lt;&lt; cb-&gt;GetModName() &lt;&lt; endline &lt;&lt; &quot; :: map size &quot; &lt;&lt; cb-&gt;GetMapWidth()/64 &lt;&lt; &quot; x &quot;  &lt;&lt; cb-&gt;GetMapHeight()/64 &lt;&lt; endline;
-
-		Pl-&gt;InitAI();
-		L.print(&quot;Planner Init'd&quot;);
-
-		Manufacturer-&gt;Init();
-		RegisterMessageHandler(Manufacturer);
-		L.print(&quot;Manufacturer Init'd&quot;);
-
-		BuildingPlacer-&gt;Init();
-		RegisterMessageHandler(BuildingPlacer);
-		L.print(&quot;BuildingPlacement Init'd&quot;);
-
-		Ch-&gt;InitAI(this);
-		L.print(&quot;Chaser Init'd&quot;);
-	}
-
-	int Global::GetCurrentFrame(){
-		//
-		int i = cb-&gt;GetCurrentFrame();
-		if(i  &lt; 30){
-			return i;
-		}else{
-			return i +Cached-&gt;team;
-		}
-	}
-
-	bool Global::InLOS(float3 pos){
-		const unsigned short* lmap = G-&gt;cb-&gt;GetLosMap();
-		ushort v = lmap[(int(pos.y/16))*G-&gt;cb-&gt;GetMapWidth()+(int(pos.x/16))];
-		return (v &gt;0);
-	}
-
-	void tolowercase(string &amp;str){
-		std::transform(str.begin(), str.end(), str.begin(), (int (*)(int))tolower);
-	}
-
-	bool Global::ReadFile(string filename, string* buffer){
-		char buf[1000];
-		int ebsize= 0;
-		ifstream fp;
-
-		strcpy(buf, filename.c_str());
-		cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buf);
-
-		fp.open(buf, ios::in);
-		if(fp.is_open() == false){
-			L.header(string(&quot; :: error loading file :: &quot;) + filename + endline);
-			int size = G-&gt;cb-&gt;GetFileSize(filename.c_str());
-			if(size &gt;0){
-				char* c = new char[size+1];
-				bool fg = cb-&gt;ReadFile(filename.c_str(), c, size+1);
-				if(fg==true){
-					//
-					*buffer = string(c);
-					return true;
-				}else{
-					return false;
-				}
-			}
-			return false;
-		}else{
-			*buffer = &quot;&quot;;
-			char in_char;
-			while(fp.get(in_char)){
-				buffer-&gt;push_back(in_char);
-				ebsize++;
-			}
-			if(ebsize == 0){
-				L.header(string(&quot; :: error loading contents of file :: &quot;) + filename + endline);
-				return false;
-			}else{
-				return true;
-			}
-		}
-	}
-
-	// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-	/*void Global::Draw(ctri triangle){
-	 int t1 = G-&gt;cb-&gt;CreateLineFigure(triangle.a,triangle.b,4,0,triangle.fade,0);
-	 int t2 = G-&gt;cb-&gt;CreateLineFigure(triangle.b,triangle.c,4,0,triangle.fade,0);
-	 int t3 = G-&gt;cb-&gt;CreateLineFigure(triangle.c,triangle.a,4,0,triangle.fade,0);
-	 G-&gt;cb-&gt;SetFigureColor(t1,triangle.colour.red,triangle.colour.green,triangle.colour.blue,triangle.alpha);
-	 G-&gt;cb-&gt;SetFigureColor(t2,triangle.colour.red,triangle.colour.green,triangle.colour.blue,triangle.alpha);
-	 G-&gt;cb-&gt;SetFigureColor(t3,triangle.colour.red,triangle.colour.green,triangle.colour.blue,triangle.alpha);
-	 }
-
-	 ctri Global::Tri(float3 pos, int size, float speed, int lifetime, int fade, int creation){
-	 ctri Triangle;
-	 Triangle.d = size;
-	 Triangle.position = pos;
-	 Triangle.position.y = cb-&gt;GetElevation(pos.x,pos.y) + 30;
-	 Triangle.speed = speed;
-	 Triangle.flashy = false;
-	 Triangle.a = Triangle.position;
-	 Triangle.a.z = Triangle.a.z - size;
-	 Triangle.b = Triangle.c = Triangle.a;
-	 Triangle.b = Map-&gt;Rotate(Triangle.a,120 DEGREES,Triangle.position);
-	 Triangle.c = Map-&gt;Rotate(Triangle.b,120 DEGREES,Triangle.position);
-	 Triangle.lifetime = lifetime;
-	 Triangle.creation = creation;
-	 Triangle.fade = fade;
-	 Triangle.alpha = Triangle.colour.alpha = 0.6f;
-	 Triangle.colour.red = 0.7f;
-	 Triangle.colour.green = 0.9f;
-	 Triangle.colour.blue =  0.01f;
-	 Triangle.bad = false;
-	 return Triangle;
-	 }
-
-	 void Global::Increment(vector&lt;ctri&gt;::iterator triangle, int frame){
-	 triangle-&gt;a = Map-&gt;Rotate(triangle-&gt;a,triangle-&gt;speed DEGREES,triangle-&gt;position);
-	 triangle-&gt;b = Map-&gt;Rotate(triangle-&gt;b,triangle-&gt;speed DEGREES,triangle-&gt;position);
-	 triangle-&gt;c = Map-&gt;Rotate(triangle-&gt;c,triangle-&gt;speed DEGREES,triangle-&gt;position);
-	 }*/
-
-
-	int Global::GetEnemyUnits(int* units, const float3 &amp;pos, float radius){
-		NLOG(&quot;Global::GetEnemyUnits :: A&quot;);
-		//if(Cached-&gt;cheating == true){
-		return chcb-&gt;GetEnemyUnits(units, pos, radius);
-		/*}else{
-		 return cb-&gt;GetEnemyUnits(units,pos,radius);
-		 }*/
-	}
-
-
-	int Global::GetEnemyUnitsInRadarAndLos(int* units){
-		NLOG(&quot;Global::GetEnemyUnitsinradarandLOS :: B&quot;);
-		/*if(GetCurrentFrame() - Cached-&gt;lastcacheupdate&gt;  30){
-		 if(Cached-&gt;cheating == true){
-		 Cached-&gt;enemy_number = chcb-&gt;GetEnemyUnits(Cached-&gt;encache);
-		 for(uint h = 0; h &lt; Cached-&gt;enemy_number; h++){
-		 units[h] = Cached-&gt;encache[h];
-		 }
-		 Cached-&gt;lastcacheupdate = cb-&gt;GetCurrentFrame();
-		 return Cached-&gt;enemy_number;
-		 }else{
-		 return cb-&gt;GetEnemyUnitsInRadarAndLos(Cached-&gt;encache);
-		 }
-		 }
-		 if(Cached-&gt;cheating == true){*/
-		return chcb-&gt;GetEnemyUnits(units);
-		/*	Cached-&gt;enemy_number = chcb-&gt;GetEnemyUnits(Cached-&gt;encache);
-		 for(uint h = 0; h &lt; Cached-&gt;enemy_number; h++){
-		 units[h] = Cached-&gt;encache[h];
-		 }
-		 ///*}else{
-		 Cached-&gt;enemy_number = cb-&gt;GetEnemyUnitsInRadarAndLos(Cached-&gt;encache);
-		 }*/
-		//return Cached-&gt;enemy_number;*/
-	}
-
-	int Global::GetEnemyUnits(int* units){
-		NLOG(&quot;Global::GetEnemyUnits :: B&quot;);
-		if(GetCurrentFrame() - Cached-&gt;lastcacheupdate&gt;  30){
-			//if(Cached-&gt;cheating == true){
-			Cached-&gt;enemy_number = chcb-&gt;GetEnemyUnits(Cached-&gt;encache);
-			/*	}else{
-			 Cached-&gt;enemy_number = cb-&gt;GetEnemyUnits(Cached-&gt;encache);
-			 }
-			 */	Cached-&gt;lastcacheupdate = cb-&gt;GetCurrentFrame();
-		}
-		for(uint h = 0; h &lt; Cached-&gt;enemy_number; h++){
-			units[h] = Cached-&gt;encache[h];
-		}
-		return Cached-&gt;enemy_number;
-	}
-
-
-
-	float Global::GetEfficiency(string s, float def_value){
-
-		CUnitTypeData* ud = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(s);
-		if(ud == 0){
-			return def_value;
-		}
-
-		if(efficiency.find(ud-&gt;GetName()) != efficiency.end()){
-			if(ud-&gt;CanConstruct()){
-
-				if(builderefficiency.find(ud-&gt;GetName()) != builderefficiency.end()){
-					int i = lastbuilderefficiencyupdate[ud-&gt;GetName()];
-					if(GetCurrentFrame()-(5 MINUTES) &lt; i){
-						return builderefficiency[ud-&gt;GetName()];
-					}
-				}
-
-				float e = efficiency[ud-&gt;GetName()];
-				
-				set&lt;string&gt; alreadydone;
-				alreadydone.insert(ud-&gt;GetName());
-
-				if(!ud-&gt;GetUnitDef()-&gt;buildOptions.empty()){
-					for(map&lt;int, string&gt;::const_iterator i = ud-&gt;GetUnitDef()-&gt;buildOptions.begin();i != ud-&gt;GetUnitDef()-&gt;buildOptions.end(); ++i){
-						alreadydone.insert(i-&gt;second);
-						e += efficiency[s];
-					}
-				}
-
-				lastbuilderefficiencyupdate[ud-&gt;GetName()] = GetCurrentFrame();
-				builderefficiency[ud-&gt;GetName()] = e;
-
-				return e;
-			}else{
-				return efficiency[ud-&gt;GetName()];
-			}
-
-		}else{
-			L.print(&quot;error ::   &quot; + ud-&gt;GetName() + &quot; is missing from the efficiency array&quot;);
-			return def_value;
-		}
-
-	}
-
-	void Global::SetEfficiency(std::string s, float e){
-		trim(s);
-		tolowercase(s);
-		efficiency[s] = e;
-		//
-	}
-
-	float Global::GetEfficiency(string s, set&lt;string&gt;&amp; doneconstructors, int techlevel){
-
-		CUnitTypeData* ud = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(s);
-
-		if(ud == 0){
-			return 0;
-		}
-
-		if(efficiency.find(ud-&gt;GetName()) != efficiency.end()){
-			if(ud-&gt;CanConstruct()&amp;&amp;(doneconstructors.find(ud-&gt;GetName())==doneconstructors.end())){
-
-				if(builderefficiency.find(s) != builderefficiency.end()){
-					int i = lastbuilderefficiencyupdate[ud-&gt;GetName()];
-					if(GetCurrentFrame()-(5 MINUTES) &lt; i){
-						return builderefficiency[ud-&gt;GetName()];
-					}
-				}
-
-				float e = efficiency[ud-&gt;GetName()];
-				
-				doneconstructors.insert(ud-&gt;GetName());
-
-				for(map&lt;int, string&gt;::const_iterator i = ud-&gt;GetUnitDef()-&gt;buildOptions.begin();i != ud-&gt;GetUnitDef()-&gt;buildOptions.end(); ++i){
-					CUnitTypeData* ud2 = UnitDefLoader-&gt;GetUnitTypeDataByName(i-&gt;second);
-
-					if(doneconstructors.find(i-&gt;second)==doneconstructors.end()){
-						doneconstructors.insert(i-&gt;second);
-
-						if (ud2-&gt;GetUnitDef()-&gt;techLevel&lt;techlevel){
-							e+=1.0f;
-						} else if (ud2-&gt;GetUnitDef()-&gt;techLevel != techlevel){
-							e+= efficiency[i-&gt;second]*pow(0.6f, (ud2-&gt;GetUnitDef()-&gt;techLevel-techlevel));
-						} else {
-							e+= efficiency[i-&gt;second];
-						}
-					}else{
-
-						if(ud2-&gt;GetUnitDef()-&gt;techLevel &gt; ud-&gt;GetUnitDef()-&gt;techLevel){
-							e+= 1.0f;
-						}
-
-						e += builderefficiency[i-&gt;second];
-					}
-
-				}
-
-				lastbuilderefficiencyupdate[ud-&gt;GetName()] = GetCurrentFrame();
-				builderefficiency[ud-&gt;GetName()] = e;
-
-				return e;
-			}else{
-				if(ud-&gt;GetUnitDef()-&gt;techLevel &lt; techlevel){
-					return 1.0f;
-				}else  if(ud-&gt;GetUnitDef()-&gt;techLevel &gt; techlevel){
-					return efficiency[ud-&gt;GetName()]*pow(0.6f, (ud-&gt;GetUnitDef()-&gt;techLevel-techlevel));
-				}
-
-				return efficiency[ud-&gt;GetName()];
-			}
-		}else{
-			L.print(&quot;error ::   &quot; + ud-&gt;GetName() + &quot; is missing from the efficiency array&quot;);
-			return 0.0f;
-		}
-	}
-
-	bool Global::LoadUnitData(){
-		if(G-&gt;L.FirstInstance()){
-			int unum = cb-&gt;GetNumUnitDefs();
-			const UnitDef** ulist = new const UnitDef*[unum];
-			cb-&gt;GetUnitDefList(ulist);
-			for(int i = 0; i &lt; unum; i++){
-				const UnitDef* pud = ulist[i];
-
-				if(pud == 0){
-					continue;
-				}
-
-				string eu = pud-&gt;name;
-
-				tolowercase(eu);
-				trim(eu);
-
-				float ef = pud-&gt;energyMake + pud-&gt;metalMake;
-
-				if(pud-&gt;energyCost &lt; 0){
-					ef += -pud-&gt;energyCost;
-				}
-
-				ef *= 2;
-
-				if(pud-&gt;weapons.empty() == false){
-					for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator k = pud-&gt;weapons.begin();k != pud-&gt;weapons.end();++k){
-						//ef += k-&gt;def-&gt;
-						float av=0;
-						int numTypes;// = cb-&gt;getk-&gt;def-&gt;damages.numTypes;
-						cb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numTypes);
-						for(int a=0;a&lt;numTypes;++a){
-							if(a == 0){
-								av = k-&gt;def-&gt;damages[0];//damages
-							}else{
-								av = (av+k-&gt;def-&gt;damages[a])/2;
-							}
-						}
-						ef += av;
-					}
-				}
-
-				ef += pud-&gt;power;
-
-				efficiency[eu] = ef;
-				unit_names[eu] = pud-&gt;humanName;
-				unit_descriptions[eu] = pud-&gt;tooltip;
-			}
-
-			string filename = info-&gt;datapath;
-			filename += slash;
-			filename += &quot;learn&quot;;
-			filename += slash;
-			filename += info-&gt;tdfpath;
-			filename += &quot;.tdf&quot;;
-
-			string* buffer = new string;
-
-			if(ReadFile(filename, buffer)){
-
-				TdfParser cq(this);
-
-				cq.LoadBuffer(buffer-&gt;c_str(), buffer-&gt;size());
-				iterations = atoi(cq.SGetValueDef(&quot;1&quot;, &quot;AI\\iterations&quot;).c_str());
-
-				for(map&lt;string, float&gt;::iterator i = efficiency.begin(); i != efficiency.end(); ++i){
-					string s = &quot;AI\\&quot;;
-					s += i-&gt;first;
-					float ank = (float)atof(cq.SGetValueDef(&quot;14&quot;, s.c_str()).c_str());
-					if(ank &gt; i-&gt;second) i-&gt;second = ank;
-				}
-
-				iterations = atoi(cq.SGetValueDef(&quot;1&quot;, &quot;AI\\iterations&quot;).c_str());
-				iterations++;
-
-				cq.GetDef(firstload, &quot;1&quot;, &quot;AI\\firstload&quot;);
-
-				if(firstload == true){
-					L.iprint(&quot; This is the first time this mod has been loaded, up. Take this first game to train NTai up, and be careful of throwing the same units at it over and over again&quot;);
-					firstload = false;
-
-					for(map&lt;string, float&gt;::iterator i = efficiency.begin(); i != efficiency.end(); ++i){
-						CUnitTypeData* uda = UnitDefLoader-&gt;GetUnitTypeDataByName(i-&gt;first);
-						if(uda){
-							i-&gt;second += uda-&gt;GetUnitDef()-&gt;health;
-						}
-					}
-
-				}
-
-				loaded = true;
-				return true;
-			} else{
-
-				for(int i = 0; i &lt; unum; i++){
-					float ts = 500;
-					if(ulist[i]-&gt;weapons.empty()){
-						ts += ulist[i]-&gt;health+ulist[i]-&gt;energyMake + ulist[i]-&gt;metalMake + ulist[i]-&gt;extractsMetal*50+ulist[i]-&gt;tidalGenerator*30 + ulist[i]-&gt;windGenerator*30;
-						ts *= 300;
-					}else{
-						ts += 20*ulist[i]-&gt;weapons.size();
-					}
-					string eu = ulist[i]-&gt;name;
-					tolowercase(eu);
-					trim(eu);
-					efficiency[eu] = ts;
-				}
-
-				SaveUnitData();
-
-				G-&gt;L.print(&quot;failed to load :&quot; + filename);
-
-				return false;
-			}
-		}
-		return false;
-	}
-
-	bool Global::SaveUnitData(){
-		NLOG(&quot;Global::SaveUnitData()&quot;);
-
-		if(L.FirstInstance() == true){
-			ofstream off;
-
-			string filename = info-&gt;datapath;
-			filename += slash;
-			filename += &quot;learn&quot;;
-			filename += slash;
-			filename += info-&gt;tdfpath;
-			filename += &quot;.tdf&quot;;
-
-			off.open(filename.c_str());
-
-			if(off.is_open() == true){
-				off &lt;&lt; &quot;[AI]&quot; &lt;&lt; endl &lt;&lt; &quot;{&quot; &lt;&lt; endl &lt;&lt; &quot;    // &quot; &lt;&lt; AI_NAME &lt;&lt; &quot; AF :: unit efficiency cache file&quot; &lt;&lt; endl &lt;&lt; endl;
-
-				off &lt;&lt; &quot;    version=XE9.79;&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;    firstload=&quot; &lt;&lt; firstload &lt;&lt; &quot;;&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;    modname=&quot; &lt;&lt; G-&gt;cb-&gt;GetModName() &lt;&lt; &quot;;&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;    iterations=&quot; &lt;&lt; iterations &lt;&lt; &quot;;&quot; &lt;&lt; endl;
-				off &lt;&lt; endl;
-
-				off &lt;&lt; &quot;    [VALUES]&quot; &lt;&lt; endl &lt;&lt; &quot;    {&quot; &lt;&lt; endl;
-
-				for(map&lt;string, float&gt;::const_iterator i = efficiency.begin(); i != efficiency.end(); ++i){
-					off &lt;&lt; &quot;        &quot;&lt;&lt; i-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; i-&gt;second &lt;&lt; &quot;;    // &quot; &lt;&lt; unit_names[i-&gt;first] &lt;&lt; &quot; :: &quot;&lt;&lt; unit_descriptions[i-&gt;first]&lt;&lt;endl;
-				}
-				off &lt;&lt; &quot;    }&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;    [NAMES]&quot; &lt;&lt; endl &lt;&lt; &quot;    {&quot;&lt;&lt; endl;
-
-				for(map&lt;string, float&gt;::const_iterator i = efficiency.begin(); i != efficiency.end(); ++i){
-					off &lt;&lt; &quot;        &quot;&lt;&lt; i-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; unit_names[i-&gt;first] &lt;&lt; &quot;;&quot; &lt;&lt;endl;
-				}
-
-				off &lt;&lt; &quot;    }&quot; &lt;&lt; endl;
-
-				off &lt;&lt; &quot;    [DESCRIPTIONS]&quot; &lt;&lt; endl &lt;&lt; &quot;    {&quot;&lt;&lt; endl;
-
-				for(map&lt;string, float&gt;::const_iterator i = efficiency.begin(); i != efficiency.end(); ++i){
-					off &lt;&lt; &quot;        &quot;&lt;&lt; i-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; unit_descriptions[i-&gt;first] &lt;&lt; &quot;;&quot;&lt;&lt;endl;
-				}
-
-				off &lt;&lt; &quot;    }&quot; &lt;&lt; endl;
-				off &lt;&lt; &quot;}&quot; &lt;&lt; endl;
-				off.close();
-
-				saved = true;
-				return true;
-			}else{
-				G-&gt;L.print(&quot;failed to save :&quot; + filename);
-				off.close();
-				return false;
-			}
-		}
-		return false;
-	}
-
-	float Global::GetTargettingWeight(string unit, string target){
-		float tempscore = 0;
-
-		if(info-&gt;hardtarget == false){
-			tempscore = GetEfficiency(target);
-		}else{
-			string fh = unit + &quot;\\target_weights\\&quot; + target;
-			string fg = unit + &quot;\\target_weights\\undefined&quot;;
-
-			float fz = GetEfficiency(target);
-			string tempdef = Get_mod_tdf()-&gt;SGetValueDef(to_string(fz), fg.c_str());
-			tempscore = (float)atof(Get_mod_tdf()-&gt;SGetValueDef(tempdef, fh).c_str()); // load &quot;unitname\\target_weights\\enemyunitname&quot; to retirieve targetting weights
-		}
-
-		return tempscore;
-	}
-
-
-	void Global::EnemyEnterLOS(int enemy){ // an enemy has entered LOS
-		Cached-&gt;enemies.insert(enemy);
-	}
-
-	void Global::EnemyLeaveLOS(int enemy){ // An enemy has left LOS
-		Cached-&gt;enemies.erase(enemy);
-	}
-
-	void Global::EnemyEnterRadar(int enemy){ // an enemy has entered radar
-		Cached-&gt;enemies.insert(enemy);
-	}
-
-	void Global::EnemyLeaveRadar(int enemy){ // an enemy has left radar
-		Cached-&gt;enemies.erase(enemy);
-	}
-
-	float3 Global::GetUnitPos(int unitid, int enemy){ // do 10 frame delays between updates fo different units
-		if(!ValidUnitID(unitid)){
-			return UpVector;
-		}
-
-		float3 p = chcb-&gt;GetUnitPos(unitid);
-
-		if(Map-&gt;CheckFloat3(p)==false){
-			return UpVector;
-		}else{
-			return p;
-		}
-
-	}
-
-	bool Global::HasUnit(int unit){
-		return (units.find(unit) != units.end());
-	}
-
-	boost::shared_ptr&lt;IModule&gt; Global::GetUnit(int unit){
-		if(HasUnit(unit)==false){
-			IModule* a = 0;
-			boost::shared_ptr&lt;IModule&gt; t(a);
-			return t;
-		}
-
-		return units[unit];
-	}
-
-	void Global::RegisterMessageHandler(boost::shared_ptr&lt;IModule&gt; handler){
-		handlers.insert(handler);
-	}
-
-	void Global::FireEvent(CMessage &amp;message){
-		if(message.GetType() == string(&quot;&quot;)){
-			return;
-		}
-
-		message.SetFrame(GetCurrentFrame());
-
-		msgqueue.push_back(message);
-	}
-
-	void Global::DestroyHandler(boost::shared_ptr&lt;IModule&gt; handler){
-		handler-&gt;DestroyModule();
-
-		if(!handlers.empty()){
-			handlers.erase(handler);
-		}
-
-		return;
-	}
-
-	void Global::RemoveHandler(boost::shared_ptr&lt;IModule&gt; handler){
-		dead_handlers.insert(handler);
-	}
-
-}
-
-// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
-
-/** Random note
-unitdef-&gt;type can be one of the following:
- MetalExtractor
- Transport
- Builder
- Factory
- Bomber
- Fighter
- GroundUnit
- Building
- **/
+//-------------------------------------------------------------------------
+// NTai
+// Copyright 2004-2007 AF
+// Released under GPL 2 license
+//-------------------------------------------------------------------------
+
+#include &quot;include.h&quot;
+
+namespace ntai {
+
+	int iterations=0;
+	bool loaded=false;
+	bool firstload=false;
+	bool saved=false;
+	map&lt;string, float&gt; efficiency;
+	map&lt;string, float&gt; builderefficiency;
+	map&lt;string, int&gt; lastbuilderefficiencyupdate;
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	TdfParser* Global::Get_mod_tdf(){
+		return info-&gt;mod_tdf;
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void trim(string &amp;str){
+		string::size_type pos = str.find_last_not_of(' ');
+		if(pos != string::npos) {
+			str.erase(pos + 1);
+			pos = str.find_first_not_of(' ');
+			if(pos != string::npos) str.erase(0, pos);
+		}
+		else str.erase(str.begin(), str.end());
+	}
+
+	bool ValidUnitID(int id){
+		if(id &lt; 0) return false;
+		if(id &gt; MAX_UNITS+1) return false;
+		return true;
+	}
+
+	Global::Global(IGlobalAICallback* callback){
+		G = this;
+		gcb = callback;
+		cb = gcb-&gt;GetAICallback();
+		if(cb == 0){
+			throw string(&quot; error cb ==0&quot;);
+		}
+		CLOG(&quot;Started Global::Global class constructor&quot;);
+		CLOG(&quot;Starting CCached initialisation&quot;);
+		Cached = new CCached(this);
+		CLOG(&quot;getting team value&quot;);
+
+		CLOG(&quot;Creating Config holder class&quot;);
+		info = new CConfigData(G);
+
+		CLOG(&quot;Setting the Logger class&quot;);
+		L.Set(this);
+
+		CLOG(&quot;Opening logfile in plaintext&quot;);
+		L.Open(true);
+		//L.Verbose();
+
+		CLOG(&quot;Logging class Opened&quot;);
+		L.print(&quot;logging started&quot;);
+
+		CLOG(&quot;Loading modinfo.tdf&quot;);
+		TdfParser sf(G);
+		if(sf.LoadFile(&quot;modinfo.tdf&quot;)){
+			L.print(&quot;modinfo.tdf loaded into parser&quot;);
+		} else {
+			L.eprint(&quot;error modinfo.tdf retrieval failed&quot;);
+		}
+
+		CLOG(&quot;Getting tdfpath value&quot;);
+		info-&gt;tdfpath =  sf.SGetValueDef(string(cb-&gt;GetModName()), &quot;MOD\\NTAI\\tdfpath&quot;);
+
+		CLOG(&quot;Retrieving cheat interface&quot;);
+		chcb = callback-&gt;GetCheatInterface();
+
+		CLOG(&quot;cheat interface retrieved&quot;);
+
+		CLOG(&quot;Creating Actions class&quot;);
+		Actions = new CActions(G);
+
+		CLOG(&quot;Creating Map class&quot;);
+		Map = new CMap(G);
+
+		CLOG(&quot;Map class created&quot;);
+		if(L.FirstInstance() == true){
+			CLOG(&quot;First Instance == true&quot;);
+			loaded = false;
+			firstload = false;
+			iterations = 0;
+			saved = false;
+		}
+
+		CLOG(&quot;Creating MetalHandler class&quot;);
+		M = new CMetalHandler(G);
+
+		CLOG(&quot;Loading Metal cache&quot;);
+		M-&gt;loadState();
+
+		CLOG(&quot;View The NTai Log file from here on&quot;);
+		/*if(M-&gt;hotspot.empty() == false){
+			 for(vector&lt;float3&gt;::iterator hs = M-&gt;hotspot.begin(); hs != M-&gt;hotspot.end(); ++hs){
+				 float3 tpos = *hs;
+				 tpos.y = cb-&gt;GetElevation(tpos.x,tpos.z);
+				 ctri triangle = Tri(tpos);
+				 triangles.push_back(triangle);
+			 }
+		 }*/
+		//if(L.FirstInstance() == true){
+		L &lt;&lt; &quot; :: Found &quot; &lt;&lt; M-&gt;m-&gt;NumSpotsFound &lt;&lt; &quot; Metal Spots&quot; &lt;&lt; endline;
+		//}
+		UnitDefLoader = new CUnitDefLoader(G);
+		L.print(&quot;Unitdef loader constructed&quot;);
+
+		OrderRouter = new COrderRouter(G);
+		L.print(&quot;Order Router constructed&quot;);
+
+		DTHandler = new CDTHandler(G);
+		L.print(&quot;DTHandler constructed&quot;);
+
+		RadarHandler = new CRadarHandler(G);
+		L.print(&quot;RadarHandler constructed&quot;);
+
+		Pl = new Planning(G);
+		L.print(&quot;Planning constructed&quot;);
+
+
+		Economy = new CEconomy(G);
+		L.print(&quot;Economy constructed&quot;);
+
+		Manufacturer = boost::shared_ptr&lt;CManufacturer&gt;(new CManufacturer(this));
+		L.print(&quot;Manufacturer constructed&quot;);
+
+		BuildingPlacer = boost::shared_ptr&lt;CBuildingPlacer&gt;(new CBuildingPlacer(this));
+		L.print(&quot;BuildingPlacer constructed&quot;);
+
+		Ch = new Chaser();
+		L.print(&quot;Chaser constructed&quot;);
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	Global::~Global(){
+		SaveUnitData();
+		L.Close();
+		delete[] Cached-&gt;encache;
+		delete info;
+		delete DTHandler;
+		delete Economy;
+		delete RadarHandler;
+		delete Actions;
+		delete Map;
+		delete Ch;
+		delete Pl;
+		delete M;
+		delete Cached;
+		delete OrderRouter;
+		delete UnitDefLoader;
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	map&lt;int, const UnitDef*&gt; endefs;
+	const UnitDef* Global::GetEnemyDef(int enemy){
+		if(endefs.find(enemy) == endefs.end()){
+			const UnitDef* ud = GetUnitDef(enemy);
+			if(ud == 0){
+				return 0;
+			}else{
+				endefs[enemy] = ud;
+				return ud;
+			}
+		} else{
+			return endefs[enemy];
+		}
+		return 0;
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::EnemyDamaged(int damaged, int attacker, float damage, float3 dir){
+		/*Ch-&gt;EnemyDamaged(damaged, attacker, damage, dir);
+		START_EXCEPTION_HANDLING
+		CMessage message(&quot;enemydamaged&quot;);
+		message.AddParameter(damaged);
+		message.AddParameter(attacker);
+		message.AddParameter(damage);
+		message.AddParameter(dir);
+		FireEvent(message);
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;enemydamaged\&quot;); FireEvent(message);&quot;)*/
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::Update(){
+		bool paused = false;
+
+		NLOG(&quot;Global::Update()&quot;);
+		cb-&gt;GetValue(AIVAL_GAME_PAUSED, &amp;paused);
+		if(paused) return;
+		START_EXCEPTION_HANDLING
+
+		if(!handlers.empty()){
+			if(!msgqueue.empty()){
+				int n = 0;
+				for(vector&lt;CMessage&gt;::iterator mi = msgqueue.begin(); mi != msgqueue.end(); ++mi){
+					if(mi-&gt;IsDead(GetCurrentFrame())){
+						continue;
+					}
+
+					n++;
+
+					for(set&lt;boost::shared_ptr&lt;IModule&gt; &gt;::iterator k = handlers.begin(); k != handlers.end(); ++k){
+						if((*k)-&gt;IsValid()){
+							(*k)-&gt;RecieveMessage(*mi);
+						}else{
+							RemoveHandler((*k));
+						}
+					}
+
+					// We dont want to do everything at once if the queue is gigantic
+					if(n &gt;15){
+						// so erase what we've already parsed and exit the loop, we
+						// can do the rest of the queue in the next update call.
+						msgqueue.erase(msgqueue.begin(),mi);
+						break;
+					}
+				}
+
+				msgqueue.erase(msgqueue.begin(),msgqueue.end());
+			}
+
+		}
+
+		if(cb-&gt;GetCurrentFrame() == (1 SECOND)){
+			NLOG(&quot;STARTUP BANNER IN Global::Update()&quot;);
+
+			if(L.FirstInstance()){
+				string s = string(&quot;:: &quot;) + AI_NAME + string(&quot; by AF&quot;);
+				cb-&gt;SendTextMsg(s.c_str(), 0);
+				cb-&gt;SendTextMsg(&quot;:: Copyright (C) 2006 AF&quot;, 0);
+				string q = string(&quot; :: &quot;) + Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\message&quot;);
+				if(q != string(&quot;&quot;)){
+					cb-&gt;SendTextMsg(q.c_str(), 0);
+				}
+				cb-&gt;SendTextMsg(&quot;Please check www.darkstars.co.uk for updates&quot;, 0);
+			}
+
+			int* ax = new int[10000];
+			int anum =cb-&gt;GetFriendlyUnits(ax);
+			
+			ComName = string(&quot;&quot;);
+	        
+			if(anum !=0){
+				for(int a = 0; a&lt;anum; a++){
+					if(cb-&gt;GetUnitTeam(ax[a]) == cb-&gt;GetMyTeam()){
+						const UnitDef* ud = GetUnitDef(ax[a]);
+						if(ud!=0){
+							//
+							ComName = ud-&gt;name;
+							Cached-&gt;comID=ax[a];
+						}
+					}
+				}
+			}
+			delete[] ax;
+		}
+		END_EXCEPTION_HANDLING(&quot;Startup Banner and getting commander name&quot;)
+
+		START_EXCEPTION_HANDLING
+		OrderRouter-&gt;Update();
+		END_EXCEPTION_HANDLING(&quot;OrderRouter-&gt;Update()&quot;)
+
+		//if( EVERY_((2 SECONDS)) &amp;&amp; (Cached-&gt;cheating == true) ){
+		//	float a = cb-&gt;GetEnergyStorage() - cb-&gt;GetEnergy();
+		//	if( a &gt; 50) chcb-&gt;GiveMeEnergy(a);
+		//	a = cb-&gt;GetMetalStorage() - cb-&gt;GetMetal();
+		//	if(a &gt; 50) chcb-&gt;GiveMeMetal(a);
+		//}
+
+		START_EXCEPTION_HANDLING
+		if(EVERY_((2 MINUTES))){
+			//L.print(&quot;saving UnitData&quot;);
+			SaveUnitData();
+			/*if(!SaveUnitData()){
+			 L.print(&quot;UnitData saved&quot;);
+			 }else{
+			 L.print(&quot;UnitData not saved&quot;);
+			 }*/
+		}
+		END_EXCEPTION_HANDLING(&quot;SaveUnitData()&quot;)
+
+		//EXCEPTION_HANDLER(Pl-&gt;Update(),&quot;Pl-&gt;Update()&quot;,NA)
+
+		START_EXCEPTION_HANDLING
+		Actions-&gt;Update();
+		END_EXCEPTION_HANDLING(&quot;Actions-&gt;Update()&quot;)
+
+		START_EXCEPTION_HANDLING
+
+		CMessage message(&quot;update&quot;);
+
+		// a lifetime of 15 frames, so there should never be more than
+		// a backlog of 15 valid update messages
+		message.SetLifeTime(15);
+		
+		FireEvent(message);
+
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;update\&quot;); FireEvent(message);&quot;)
+
+		//EXCEPTION_HANDLER(Manufacturer-&gt;Update(),&quot;Manufacturer-&gt;Update()&quot;,NA)
+		Ch-&gt;Update();
+
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::SortSolobuilds(int unit){
+		Cached-&gt;enemies.erase(unit);
+		if(endefs.find(unit) != endefs.end()) endefs.erase(unit);
+
+		CUnitTypeData* u = UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
+
+		const UnitDef* ud = u-&gt;GetUnitDef();
+	    
+		if(ud != 0){
+			bool found = false;
+			string s  = u-&gt;GetName();
+
+			if(u-&gt;GetSingleBuild()){
+				u-&gt;SetSingleBuildActive(true);
+			}
+
+			if(u-&gt;GetSoloBuild()){
+				u-&gt;SetSoloBuildActive(true);
+			}
+		}
+	}
+
+	void Global::UnitCreated(int unit){
+
+		if(!ValidUnitID(unit)) return;
+		START_EXCEPTION_HANDLING
+		SortSolobuilds(unit);
+		END_EXCEPTION_HANDLING(&quot;Sorting solobuilds and singlebuilds in Global::UnitCreated&quot;)
+
+		//EXCEPTION_HANDLER(Ch-&gt;UnitCreated(unit),&quot;Ch-&gt;UnitCreated&quot;,NA)
+
+		START_EXCEPTION_HANDLING
+		Manufacturer-&gt;UnitCreated(unit);
+		END_EXCEPTION_HANDLING(&quot;Manufacturer-&gt;UnitCreated&quot;)
+
+		START_EXCEPTION_HANDLING
+		const UnitDef* udf = GetUnitDef(unit);
+		if(udf){
+			CUnitTypeData* utd = UnitDefLoader-&gt;GetUnitTypeDataById(udf-&gt;id);
+			if(!utd-&gt;IsMobile()){
+				BuildingPlacer-&gt;Block(G-&gt;GetUnitPos(unit), utd);
+			}
+		}
+		END_EXCEPTION_HANDLING(&quot;Global::UnitFinished blocking map for unit&quot;)
+
+		START_EXCEPTION_HANDLING
+		boost::shared_ptr&lt;CUnit&gt; Unit = boost::shared_ptr&lt;CUnit&gt;(new CUnit(G, unit));
+		boost::shared_ptr&lt;ITaskManager&gt; taskManager(new CConfigTaskManager(G,Unit));
+		Unit-&gt;SetTaskManager(taskManager);
+		Unit-&gt;Init();
+		units[unit] = Unit;
+		RegisterMessageHandler(Unit);
+		CMessage message(&quot;unitcreated&quot;);
+		message.AddParameter(unit);
+		FireEvent(message);
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitcreated\&quot;); FireEvent(message);&quot;)
+
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	void Global::EnemyDestroyed(int enemy, int attacker){
+
+		if(ValidUnitID(attacker)){
+			/*if(positions.empty()==false){
+			 map&lt;int,temp_pos&gt;::iterator i = positions.find(enemy);
+			 if(i != positions.end()){
+			 positions.erase(i);
+			 }
+			 }*/
+			Cached-&gt;enemies.erase(attacker);
+			if(endefs.find(enemy) != endefs.end()) endefs.erase(enemy);
+			const UnitDef* uda = GetUnitDef(enemy);
+			if(uda != 0){
+				float e = GetEfficiency(uda-&gt;name, uda-&gt;power);
+				e =200/uda-&gt;metalCost;
+				SetEfficiency(uda-&gt;name, e);
+			}
+
+			uda = GetUnitDef(enemy);
+			if(uda != 0){
+				float e = GetEfficiency(uda-&gt;name, uda-&gt;power);
+				e -=200/uda-&gt;metalCost;
+				SetEfficiency(uda-&gt;name, e);
+			}
+
+			Ch-&gt;EnemyDestroyed(enemy, attacker);
+			START_EXCEPTION_HANDLING
+			CMessage message(&quot;enemydestroyed&quot;);
+			message.AddParameter(enemy);
+			message.AddParameter(attacker);
+			FireEvent(message);
+			END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;enemydestroyed\&quot;); FireEvent(message);&quot;)
+		}
+		//Actions-&gt;EnemyDestroyed(enemy,attacker);
+
+	}
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::UnitFinished(int unit){
+
+		//START_EXCEPTION_HANDLING
+		CUnitTypeData* u = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
+		if(u ==0){
+			return;
+		}
+		const UnitDef* ud = u-&gt;GetUnitDef();
+		if(ud!=0){
+			if(ud-&gt;isCommander){
+				G-&gt;Cached-&gt;comID = unit;
+			}
+			max_energy_use += ud-&gt;energyUpkeep;
+
+			// prepare unitname
+			string t = u-&gt;GetName();
+
+			// solo build cleanup
+
+			// Regardless of wether the unit is subject to this behaviour the value of
+			// solobuildactive will always be false, so why bother running a check?
+			u-&gt;SetSoloBuildActive(false);
+
+			if(ud-&gt;movedata == 0){
+				if(!ud-&gt;canfly){
+					if(!ud-&gt;builder){
+						float3 upos = GetUnitPos(unit);
+						if(upos != UpVector){
+							DTHandler-&gt;AddRing(upos, 500.0f, float(PI_2) / 6.0f);
+							DTHandler-&gt;AddRing(upos, 700.0f, float(-PI_2) / 6.0f);
+						}
+					}
+				}
+			}
+		}
+		//END_EXCEPTION_HANDLING(&quot;Sorting solobuild additions and DT Rings in Global::UnitFinished &quot;)
+
+		//START_EXCEPTION_HANDLING
+		Manufacturer-&gt;UnitFinished(unit);
+		//END_EXCEPTION_HANDLING(&quot;Manufacturer-&gt;UnitFinished&quot;)
+
+		//START_EXCEPTION_HANDLING
+		Ch-&gt;UnitFinished(unit);
+		//END_EXCEPTION_HANDLING(&quot;Ch-&gt;UnitFinished&quot;)
+
+		//START_EXCEPTION_HANDLING
+		CMessage message(&quot;unitfinished&quot;);
+		message.AddParameter(unit);
+		FireEvent(message);
+		//END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitfinished\&quot;);&quot;)
+
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::UnitMoveFailed(int unit){
+
+		/*
+
+		START_EXCEPTION_HANDLING
+		Manufacturer-&gt;UnitMoveFailed(unit);
+		END_EXCEPTION_HANDLING(&quot;Manufacturer-&gt;UnitIdle in UnitMoveFailed&quot;)
+
+		START_EXCEPTION_HANDLING
+		Ch-&gt;UnitMoveFailed(unit);
+		END_EXCEPTION_HANDLING(&quot;Ch-&gt;UnitIdle in UnitMoveFailed&quot;)*/
+
+		START_EXCEPTION_HANDLING
+		CMessage message(&quot;unitmovefailed&quot;);
+		message.AddParameter(unit);
+		FireEvent(message);
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitmovefailed\&quot;); FireEvent(message);&quot;)
+
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::UnitIdle(int unit){
+		if(!ValidUnitID(unit)){
+			L.print(&quot;CManufacturer::UnitIdle negative uid, aborting&quot;);
+			return;
+		}
+		if(GetCurrentFrame() &lt; 5 SECONDS){
+			return;
+		}
+		START_EXCEPTION_HANDLING
+		CMessage message(&quot;unitidle&quot;);
+		message.AddParameter(unit);
+		FireEvent(message);
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitidle\&quot;); FireEvent(message);&quot;)
+
+		//EXCEPTION_HANDLER(Manufacturer-&gt;UnitIdle(unit),&quot;Manufacturer-&gt;UnitIdle&quot;,NA)
+
+		//EXCEPTION_HANDLER(Actions-&gt;UnitIdle(unit),&quot;Actions-&gt;UnitIdle&quot;,NA)
+
+		START_EXCEPTION_HANDLING
+		Ch-&gt;UnitIdle(unit);
+		END_EXCEPTION_HANDLING(&quot;Ch-&gt;UnitIdle&quot;)
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	void Global::Crash(){
+		NLOG(&quot; Deliberate Global::Crash routine&quot;);
+		// close the logfile
+		SaveUnitData();
+		L.header(&quot;\n :: The user has initiated a crash, terminating NTai \n&quot;);
+		L.Close();
+		START_EXCEPTION_HANDLING
+		CMessage message(&quot;crash&quot;);
+		FireEvent(message);
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;crash\&quot;); FireEvent(message);&quot;)
+	#ifndef DEBUG
+		// Create an exception forcing spring to close
+		vector&lt;string&gt; cv;
+		string n = cv.back();
+	#endif
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::UnitDamaged(int damaged, int attacker, float damage, float3 dir){
+		NLOG(&quot;Global::UnitDamaged&quot;);
+
+		if(damage &lt;= 0) return;
+		if(!ValidUnitID(damaged)) return;
+		if(!ValidUnitID(attacker)) return;
+
+		//START_EXCEPTION_HANDLING
+		if(cb-&gt;GetUnitAllyTeam(attacker) == cb-&gt;GetUnitAllyTeam(damaged)){
+			return;
+		}
+		//END_EXCEPTION_HANDLING(&quot;Global::UnitDamaged, filtering out bad calls&quot;)
+
+		//START_EXCEPTION_HANDLING
+		const UnitDef* uda = GetUnitDef(attacker);
+
+		if(uda != 0){
+			float e = GetEfficiency(uda-&gt;name, uda-&gt;power);
+			e += 10000/uda-&gt;metalCost;
+			SetEfficiency(uda-&gt;name, e);
+		}
+		const UnitDef* udb = GetUnitDef(damaged);
+
+		if(udb != 0){
+			float e = GetEfficiency(udb-&gt;name, udb-&gt;power);
+			e -= 10000/uda-&gt;metalCost;
+			SetEfficiency(udb-&gt;name, e);
+			/*if(udb-&gt;builder &amp;&amp; UnitDefHelper-&gt;IsMobile(udb)&amp;&amp;udb-&gt;weapons.empty()){
+				// if ti isnt currently building something then retreat
+				const CCommandQueue* uc = cb-&gt;GetCurrentUnitCommands(damaged);
+				if(uc != 0){
+					//
+					if(uc-&gt;front().id &gt;= 0){
+						G-&gt;Actions-&gt;Retreat(damaged);
+					}
+				}
+			}*/
+		}
+		//END_EXCEPTION_HANDLING(&quot;Global::UnitDamaged, threat value handling&quot;)
+
+		//START_EXCEPTION_HANDLING
+		Actions-&gt;UnitDamaged(damaged, attacker, damage, dir);
+		//END_EXCEPTION_HANDLING(&quot;Actions-&gt;UnitDamaged()&quot;)
+
+		Ch-&gt;UnitDamaged(damaged, attacker, damage, dir);
+
+		/*START_EXCEPTION_HANDLING*/
+		CMessage message(&quot;unitdamaged&quot;);
+		message.AddParameter(damaged);
+		message.AddParameter(attacker);
+		message.AddParameter(damage);
+		message.AddParameter(dir);
+		FireEvent(message);
+		/*END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitdamaged\&quot;); FireEvent(message);&quot;)*/
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+	void Global::GotChatMsg(const char* msg, int player){
+		L.Message(msg, player);
+		string tmsg = msg;
+		if(tmsg == string(&quot;.verbose&quot;)){
+			if(L.Verbose()){
+				L.iprint(&quot;Verbose turned on&quot;);
+			} else L.iprint(&quot;Verbose turned off&quot;);
+		}else if(tmsg == string(&quot;.crash&quot;)){
+			Crash();
+		}else if(tmsg == string(&quot;.end&quot;)){
+			exit(0);
+		}else if(tmsg == string(&quot;.break&quot;)){
+			if(L.FirstInstance() == true){
+				L.print(&quot;The user initiated debugger break&quot;);
+			}
+		}else if(tmsg == string(&quot;.isfirst&quot;)){
+			if(L.FirstInstance() == true) L.iprint(&quot; info :: This is the first NTai instance&quot;);
+		}else if(tmsg == string(&quot;.save&quot;)){
+			if(L.FirstInstance() == true) SaveUnitData();
+		}else if(tmsg == string(&quot;.reload&quot;)){
+			if(L.FirstInstance() == true) LoadUnitData();
+		}else if(tmsg == string(&quot;.flush&quot;)){
+			L.Flush();
+		}else if(tmsg == string(&quot;.threat&quot;)){
+			Ch-&gt;MakeTGA();
+		}/*else if(tmsg == string(&quot;.gridtest&quot;)){
+		 if(Ch-&gt;gridmaintainer==false) return;
+		 float cellvalue = 0;
+		 Ch-&gt;Grid-&gt;SetValuebyIndex(10,299.0f);
+		 cellvalue = Ch-&gt;Grid-&gt;GetValue(10);
+		 if(cellvalue==299.0f){
+		 G-&gt;L.iprint(&quot;Test 1 PASSED&quot;);
+		 }else{
+		 G-&gt;L.iprint(&quot;Test1 FAILED&quot;);
+		 }
+		 cellvalue=0;
+		 float3 mpos = float3(2048,0,2048);
+		 Ch-&gt;Grid-&gt;SetValuebyMap(mpos,999.0f);
+		 cellvalue=Ch-&gt;Grid-&gt;GetValuebyMap(mpos);
+		 if(cellvalue == 999.0f){
+		 L.iprint(&quot;Test 2 PASSED&quot;);
+		 }else{
+		 G-&gt;L.iprint(&quot;Test 2 FAILED&quot;);
+		 }
+		 if(Ch-&gt;Grid-&gt;GridtoMap(Ch-&gt;Grid-&gt;MaptoGrid(mpos)) == mpos){
+		 G-&gt;L.iprint(&quot;Test 3 PASSED&quot;);
+		 }else{
+		 G-&gt;L.iprint(&quot;Test 3 FAILED&quot;);
+		 }
+		 cellvalue=0;
+		 float3 gpos = float3(4,0,4);
+		 Ch-&gt;Grid-&gt;SetValuebyGrid(gpos,799.0f);
+		 cellvalue=Ch-&gt;Grid-&gt;GetValuebyGrid(gpos);
+		 if(cellvalue == 799.0f){
+		 L.iprint(&quot;Test 4 PASSED&quot;);
+		 }else{
+		 G-&gt;L.iprint(&quot;Test 4 FAILED&quot;);
+		 }
+		 if(Ch-&gt;Grid-&gt;MaptoGrid(Ch-&gt;Grid-&gt;GridtoMap(gpos)) == gpos){
+		 G-&gt;L.iprint(&quot;Test 5 PASSED&quot;);
+		 }else{
+		 G-&gt;L.iprint(&quot;Test 5 FAILED&quot;);
+		 }
+		 if(Ch-&gt;Grid-&gt;IndextoGrid(Ch-&gt;Grid-&gt;GetIndex(gpos)) == gpos){
+		 G-&gt;L.iprint(&quot;Test 6 PASSED&quot;);
+		 }else{
+		 G-&gt;L.iprint(&quot;Test 6 FAILED&quot;);
+		 }
+		 Ch-&gt;MakeTGA();
+		 }*/else if(tmsg == string(&quot;.aicheat&quot;)){
+			 //chcb = G-&gt;gcb-&gt;GetCheatInterface();
+			 if(Cached-&gt;cheating== false){
+				 Cached-&gt;cheating = true;
+				 chcb-&gt;SetMyHandicap(1000.0f);
+				 if(L.FirstInstance() == true) L.iprint(&quot;Make sure you've typed .cheat for full cheating!&quot;);
+				 // Spawn 4 commanders around the starting position
+				 CUnitTypeData* ud = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(ComName);
+				 if(ud != 0){
+					 float3 pos = Map-&gt;basepos;
+					 pos = cb-&gt;ClosestBuildSite(ud-&gt;GetUnitDef(), pos, 1000.0f, 0);
+					 int ij = chcb-&gt;CreateUnit(ComName.c_str(), pos);
+					 if(ij != 0) Actions-&gt;RandomSpiral(ij);
+					 float3 epos = pos;
+					 epos.z -= 1300.0f;
+					 float angle = float(mrand()%320);
+					 pos = G-&gt;Map-&gt;Rotate(epos, angle, pos);
+					 pos =  cb-&gt;ClosestBuildSite(ud-&gt;GetUnitDef(), pos, 1000, 300, 1);
+					 ///float3 ClosestBuildSite(const UnitDef* unitdef,float3 pos,float searchRadius,int minDist, int facing);
+					 ij = chcb-&gt;CreateUnit(ComName.c_str(), pos);
+					 if(ij != 0) Actions-&gt;RandomSpiral(ij);
+					 epos = pos;
+					 epos.z -= 900.0f;
+
+					 angle = float(mrand()%320);
+					 pos = G-&gt;Map-&gt;Rotate(epos, angle, pos);
+					 pos =  cb-&gt;ClosestBuildSite(ud-&gt;GetUnitDef(), pos, 1000, 300, 0);
+					 ///
+					 ij = chcb-&gt;CreateUnit(ComName.c_str(), pos);
+					 if(ij != 0){
+						 Actions-&gt;RandomSpiral(ij);
+					 }
+				 }
+			 }else if(Cached-&gt;cheating == true){
+				 Cached-&gt;cheating  = false;
+				 if(L.FirstInstance() == true)L.iprint(&quot;cheating is now disabled therefore NTai will no longer cheat&quot;);
+			 }
+		 }
+		//START_EXCEPTION_HANDLING
+		CMessage message(string(&quot;##&quot;)+msg);
+		message.AddParameter(player);
+		FireEvent(message);
+		//END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;msg gotmsg\&quot;); FireEvent(message);&quot;)
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::UnitDestroyed(int unit, int attacker){
+
+		if(!(ValidUnitID(unit)&amp;&amp;ValidUnitID(attacker))){
+			return;
+		}
+		units.erase(unit);
+
+		idlenextframe.erase(unit);
+
+		CUnitTypeData* u = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(unit);
+
+		const UnitDef* udu = u-&gt;GetUnitDef();
+		if(udu != 0){
+			max_energy_use -= udu-&gt;energyUpkeep;
+			u-&gt;SetSingleBuildActive(false);
+			u-&gt;SetSoloBuildActive(false);
+		}
+
+		if(ValidUnitID(attacker)){
+			CUnitTypeData* atd = G-&gt;UnitDefLoader-&gt;GetUnitTypeDataByUnitId(attacker);
+			if(atd != 0){
+				const UnitDef* uda = atd-&gt;GetUnitDef();
+				if((uda != 0)&amp;&amp;(udu != 0)){
+					
+
+					if(efficiency.find(uda-&gt;name) != efficiency.end()){
+						efficiency[uda-&gt;name] += 20000/udu-&gt;metalCost;
+					}else{
+						efficiency[uda-&gt;name] = 500;
+					}
+					if(efficiency.find(udu-&gt;name) != efficiency.end()){
+						efficiency[udu-&gt;name] -= 10000/uda-&gt;metalCost;
+					}else{
+						efficiency[udu-&gt;name] = 500;
+					}
+				}
+			}
+		}
+
+		START_EXCEPTION_HANDLING
+		CMessage message(&quot;unitdestroyed&quot;);
+		message.AddParameter(unit);
+		FireEvent(message);
+		END_EXCEPTION_HANDLING(&quot;CMessage message(\&quot;unitdestroyed\&quot;); FireEvent(message);&quot;);
+
+		//Actions-&gt;UnitDestroyed(unit);
+		Cached-&gt;enemies.erase(unit);
+		Manufacturer-&gt;UnitDestroyed(unit);
+		Ch-&gt;UnitDestroyed(unit, attacker);
+		OrderRouter-&gt;UnitDestroyed(unit);
+		units.erase(unit);
+	}
+
+	// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	void Global::InitAI(IAICallback* callback, int team){
+		L.print(&quot;Initialisising&quot;);
+
+		mrand.seed(uint(time(NULL)*team));
+		string filename = info-&gt;datapath + slash + string(&quot;NTai.tdf&quot;);
+
+		filename = info-&gt;datapath + &quot;/&quot; +  info-&gt;tdfpath + string(&quot;.tdf&quot;);
+		string* buffer = new string();
+		TdfParser* q = new TdfParser(this);
+
+		if(cb-&gt;GetFileSize(filename.c_str())!=-1){
+
+			q-&gt;LoadFile(filename);
+			L.print(&quot;Mod TDF loaded&quot;);
+			filename = info-&gt;datapath + &quot;/&quot; + q-&gt;SGetValueDef(&quot;configs/default.tdf&quot;, &quot;NTai\\modconfig&quot;);
+
+		} else {/////////////////
+
+			TdfParser* w = new TdfParser(this, &quot;modinfo.tdf&quot;);
+			info-&gt;_abstract = true;
+			L.header(&quot; :: mod.tdf failed to load, assuming default values&quot;);
+			L.header(endline);
+			// must write out a config and put in it the default stuff......
+			ofstream off;
+			//string filename = info-&gt;datapath + &quot;/learn/&quot; + info-&gt;tdfpath +&quot;.tdf&quot;;
+			off.open(filename.c_str());
+			if(off.is_open() == true){
+				//off &lt;&lt;
+				off &lt;&lt; &quot;[NTai]&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;{&quot;&lt;&lt;endl;
+				off &lt;&lt; &quot;\tlearndata=&quot; &lt;&lt; &quot;learn/&quot; &lt;&lt; info-&gt;tdfpath &lt;&lt;&quot;.tdf;&quot;&lt;&lt;endl;
+				off &lt;&lt; &quot;\tmodconfig=&quot; &lt;&lt; &quot;configs/&quot; &lt;&lt; info-&gt;tdfpath &lt;&lt; &quot;.tdf;&quot; &lt;&lt; endl;
+				off &lt;&lt;&quot;\tmodname=&quot; &lt;&lt; w-&gt;SGetValueMSG(&quot;MOD\\Name&quot;) &lt;&lt; &quot;;&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;}&quot;&lt;&lt;endl;
+				off.close();
+				filename = info-&gt;datapath + slash + string(&quot;configs&quot;) + slash +  info-&gt;tdfpath + string(&quot;.tdf&quot;);
+				off.open(filename.c_str());
+				if(off.is_open() == true){
+					//off &lt;&lt;
+					filename = info-&gt;datapath + slash + string(&quot;configs&quot;) + slash + string(&quot;default.tdf&quot;);
+					string* buffer2 = new string();
+					ReadFile(filename, buffer2);
+					off &lt;&lt; *buffer2;
+					off.close();
+				}
+			}
+			delete w;
+		}
+		delete q;
+
+		//
+		if(cb-&gt;GetFileSize(filename.c_str())!=-1){
+			Get_mod_tdf()-&gt;LoadFile(filename);
+			L.print(&quot;Mod TDF loaded&quot;);
+
+		} else {/////////////////
+
+			info-&gt;_abstract = true;
+			L.header(&quot; :: mod.tdf failed to load, assuming default values&quot;);
+			L.header(endline);
+		}
+		delete buffer;
+
+		//load all the mod.tdf settings!
+		info-&gt;Load();
+		
+		if(info-&gt;_abstract == true){
+			L.print(&quot;abstract == true&quot;);
+		}
+
+		L.print(&quot;values filled&quot;);
+
+		// initial handicap
+		float x = 0;
+		Get_mod_tdf()-&gt;GetDef(x, &quot;0&quot;, &quot;AI\\normal_handicap&quot;);
+		chcb = G-&gt;gcb-&gt;GetCheatInterface();
+		chcb-&gt;SetMyHandicap(x);
+
+	    
+
+		// solobuild
+		set&lt;std::string&gt; solotemp;
+		string sb = Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\SoloBuild&quot;);
+		CTokenizer&lt;CIsComma&gt;::Tokenize(solotemp, sb, CIsComma());
+
+
+		if(!solotemp.empty()){
+			for(set&lt;string&gt;::iterator i = solotemp.begin(); i != solotemp.end(); ++i){
+				CUnitTypeData* u = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(*i);
+				if(u){
+					u-&gt;SetSoloBuild(true);
+				}
+			}
+		}
+
+		Cached-&gt;allyteam = cb-&gt;GetMyAllyTeam();
+
+		CTokenizer&lt;CIsComma&gt;::Tokenize(Pl-&gt;AlwaysAntiStall, Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\AlwaysAntiStall&quot;), CIsComma());
+		//Pl-&gt;AlwaysAntiStall = bds::set_cont(Pl-&gt;AlwaysAntiStall, Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\AlwaysAntiStall&quot;));
+
+		vector&lt;string&gt; singlebuild;
+		sb = Get_mod_tdf()-&gt;SGetValueMSG(&quot;AI\\SingleBuild&quot;);
+		CTokenizer&lt;CIsComma&gt;::Tokenize(singlebuild, sb);
+
+		if(singlebuild.empty() == false){
+			for(vector&lt;string&gt;::iterator i= singlebuild.begin(); i != singlebuild.end(); ++i){
+				string s = *i;
+				trim(s);
+				tolowercase(s);
+
+				CUnitTypeData* u = UnitDefLoader-&gt;GetUnitTypeDataByName(s);
+
+				u-&gt;SetSingleBuild(true);
+			}
+		}
+
+		L.print(&quot;Arrays filled&quot;);
+		if(info-&gt;_abstract == true){
+			L.header(&quot; :: Using abstract buildtree&quot;);
+			L.header(endline);
+		}
+
+		if(info-&gt;gaia){
+			L.header(&quot; :: GAIA AI On&quot;);
+			L.header(endline);
+		}
+
+		L.header(endline);
+		if(loaded == false){
+			L.print(&quot;Loading unit data&quot;);
+			LoadUnitData();
+			L.print(&quot;Unit data loaded&quot;);
+		}
+
+		L &lt;&lt; &quot; :: &quot; &lt;&lt; cb-&gt;GetMapName() &lt;&lt; endline &lt;&lt; &quot; :: &quot; &lt;&lt; cb-&gt;GetModName() &lt;&lt; endline &lt;&lt; &quot; :: map size &quot; &lt;&lt; cb-&gt;GetMapWidth()/64 &lt;&lt; &quot; x &quot;  &lt;&lt; cb-&gt;GetMapHeight()/64 &lt;&lt; endline;
+
+		Pl-&gt;InitAI();
+		L.print(&quot;Planner Init'd&quot;);
+
+		Manufacturer-&gt;Init();
+		RegisterMessageHandler(Manufacturer);
+		L.print(&quot;Manufacturer Init'd&quot;);
+
+		BuildingPlacer-&gt;Init();
+		RegisterMessageHandler(BuildingPlacer);
+		L.print(&quot;BuildingPlacement Init'd&quot;);
+
+		Ch-&gt;InitAI(this);
+		L.print(&quot;Chaser Init'd&quot;);
+	}
+
+	int Global::GetCurrentFrame(){
+		//
+		int i = cb-&gt;GetCurrentFrame();
+		if(i  &lt; 30){
+			return i;
+		}else{
+			return i +Cached-&gt;team;
+		}
+	}
+
+	bool Global::InLOS(float3 pos){
+		const unsigned short* lmap = G-&gt;cb-&gt;GetLosMap();
+		ushort v = lmap[(int(pos.y/16))*G-&gt;cb-&gt;GetMapWidth()+(int(pos.x/16))];
+		return (v &gt;0);
+	}
+
+	void tolowercase(string &amp;str){
+		std::transform(str.begin(), str.end(), str.begin(), (int (*)(int))tolower);
+	}
+
+	bool Global::ReadFile(string filename, string* buffer){
+		char buf[1000];
+		int ebsize= 0;
+		ifstream fp;
+
+		strcpy(buf, filename.c_str());
+		cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buf);
+
+		fp.open(buf, ios::in);
+		if(fp.is_open() == false){
+			L.header(string(&quot; :: error loading file :: &quot;) + filename + endline);
+			int size = G-&gt;cb-&gt;GetFileSize(filename.c_str());
+			if(size &gt;0){
+				char* c = new char[size+1];
+				bool fg = cb-&gt;ReadFile(filename.c_str(), c, size+1);
+				if(fg==true){
+					//
+					*buffer = string(c);
+					return true;
+				}else{
+					return false;
+				}
+			}
+			return false;
+		}else{
+			*buffer = &quot;&quot;;
+			char in_char;
+			while(fp.get(in_char)){
+				buffer-&gt;push_back(in_char);
+				ebsize++;
+			}
+			if(ebsize == 0){
+				L.header(string(&quot; :: error loading contents of file :: &quot;) + filename + endline);
+				return false;
+			}else{
+				return true;
+			}
+		}
+	}
+
+	// |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+	/*void Global::Draw(ctri triangle){
+	 int t1 = G-&gt;cb-&gt;CreateLineFigure(triangle.a,triangle.b,4,0,triangle.fade,0);
+	 int t2 = G-&gt;cb-&gt;CreateLineFigure(triangle.b,triangle.c,4,0,triangle.fade,0);
+	 int t3 = G-&gt;cb-&gt;CreateLineFigure(triangle.c,triangle.a,4,0,triangle.fade,0);
+	 G-&gt;cb-&gt;SetFigureColor(t1,triangle.colour.red,triangle.colour.green,triangle.colour.blue,triangle.alpha);
+	 G-&gt;cb-&gt;SetFigureColor(t2,triangle.colour.red,triangle.colour.green,triangle.colour.blue,triangle.alpha);
+	 G-&gt;cb-&gt;SetFigureColor(t3,triangle.colour.red,triangle.colour.green,triangle.colour.blue,triangle.alpha);
+	 }
+
+	 ctri Global::Tri(float3 pos, int size, float speed, int lifetime, int fade, int creation){
+	 ctri Triangle;
+	 Triangle.d = size;
+	 Triangle.position = pos;
+	 Triangle.position.y = cb-&gt;GetElevation(pos.x,pos.y) + 30;
+	 Triangle.speed = speed;
+	 Triangle.flashy = false;
+	 Triangle.a = Triangle.position;
+	 Triangle.a.z = Triangle.a.z - size;
+	 Triangle.b = Triangle.c = Triangle.a;
+	 Triangle.b = Map-&gt;Rotate(Triangle.a,120 DEGREES,Triangle.position);
+	 Triangle.c = Map-&gt;Rotate(Triangle.b,120 DEGREES,Triangle.position);
+	 Triangle.lifetime = lifetime;
+	 Triangle.creation = creation;
+	 Triangle.fade = fade;
+	 Triangle.alpha = Triangle.colour.alpha = 0.6f;
+	 Triangle.colour.red = 0.7f;
+	 Triangle.colour.green = 0.9f;
+	 Triangle.colour.blue =  0.01f;
+	 Triangle.bad = false;
+	 return Triangle;
+	 }
+
+	 void Global::Increment(vector&lt;ctri&gt;::iterator triangle, int frame){
+	 triangle-&gt;a = Map-&gt;Rotate(triangle-&gt;a,triangle-&gt;speed DEGREES,triangle-&gt;position);
+	 triangle-&gt;b = Map-&gt;Rotate(triangle-&gt;b,triangle-&gt;speed DEGREES,triangle-&gt;position);
+	 triangle-&gt;c = Map-&gt;Rotate(triangle-&gt;c,triangle-&gt;speed DEGREES,triangle-&gt;position);
+	 }*/
+
+
+	int Global::GetEnemyUnits(int* units, const float3 &amp;pos, float radius){
+		NLOG(&quot;Global::GetEnemyUnits :: A&quot;);
+		//if(Cached-&gt;cheating == true){
+		return chcb-&gt;GetEnemyUnits(units, pos, radius);
+		/*}else{
+		 return cb-&gt;GetEnemyUnits(units,pos,radius);
+		 }*/
+	}
+
+
+	int Global::GetEnemyUnitsInRadarAndLos(int* units){
+		NLOG(&quot;Global::GetEnemyUnitsinradarandLOS :: B&quot;);
+		/*if(GetCurrentFrame() - Cached-&gt;lastcacheupdate&gt;  30){
+		 if(Cached-&gt;cheating == true){
+		 Cached-&gt;enemy_number = chcb-&gt;GetEnemyUnits(Cached-&gt;encache);
+		 for(uint h = 0; h &lt; Cached-&gt;enemy_number; h++){
+		 units[h] = Cached-&gt;encache[h];
+		 }
+		 Cached-&gt;lastcacheupdate = cb-&gt;GetCurrentFrame();
+		 return Cached-&gt;enemy_number;
+		 }else{
+		 return cb-&gt;GetEnemyUnitsInRadarAndLos(Cached-&gt;encache);
+		 }
+		 }
+		 if(Cached-&gt;cheating == true){*/
+		return chcb-&gt;GetEnemyUnits(units);
+		/*	Cached-&gt;enemy_number = chcb-&gt;GetEnemyUnits(Cached-&gt;encache);
+		 for(uint h = 0; h &lt; Cached-&gt;enemy_number; h++){
+		 units[h] = Cached-&gt;encache[h];
+		 }
+		 ///*}else{
+		 Cached-&gt;enemy_number = cb-&gt;GetEnemyUnitsInRadarAndLos(Cached-&gt;encache);
+		 }*/
+		//return Cached-&gt;enemy_number;*/
+	}
+
+	int Global::GetEnemyUnits(int* units){
+		NLOG(&quot;Global::GetEnemyUnits :: B&quot;);
+		if(GetCurrentFrame() - Cached-&gt;lastcacheupdate&gt;  30){
+			//if(Cached-&gt;cheating == true){
+			Cached-&gt;enemy_number = chcb-&gt;GetEnemyUnits(Cached-&gt;encache);
+			/*	}else{
+			 Cached-&gt;enemy_number = cb-&gt;GetEnemyUnits(Cached-&gt;encache);
+			 }
+			 */	Cached-&gt;lastcacheupdate = cb-&gt;GetCurrentFrame();
+		}
+		for(uint h = 0; h &lt; Cached-&gt;enemy_number; h++){
+			units[h] = Cached-&gt;encache[h];
+		}
+		return Cached-&gt;enemy_number;
+	}
+
+
+
+	float Global::GetEfficiency(string s, float def_value){
+
+		CUnitTypeData* ud = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(s);
+		if(ud == 0){
+			return def_value;
+		}
+
+		if(efficiency.find(ud-&gt;GetName()) != efficiency.end()){
+			if(ud-&gt;CanConstruct()){
+
+				if(builderefficiency.find(ud-&gt;GetName()) != builderefficiency.end()){
+					int i = lastbuilderefficiencyupdate[ud-&gt;GetName()];
+					if(GetCurrentFrame()-(5 MINUTES) &lt; i){
+						return builderefficiency[ud-&gt;GetName()];
+					}
+				}
+
+				float e = efficiency[ud-&gt;GetName()];
+				
+				set&lt;string&gt; alreadydone;
+				alreadydone.insert(ud-&gt;GetName());
+
+				if(!ud-&gt;GetUnitDef()-&gt;buildOptions.empty()){
+					for(map&lt;int, string&gt;::const_iterator i = ud-&gt;GetUnitDef()-&gt;buildOptions.begin();i != ud-&gt;GetUnitDef()-&gt;buildOptions.end(); ++i){
+						alreadydone.insert(i-&gt;second);
+						e += efficiency[s];
+					}
+				}
+
+				lastbuilderefficiencyupdate[ud-&gt;GetName()] = GetCurrentFrame();
+				builderefficiency[ud-&gt;GetName()] = e;
+
+				return e;
+			}else{
+				return efficiency[ud-&gt;GetName()];
+			}
+
+		}else{
+			L.print(&quot;error ::   &quot; + ud-&gt;GetName() + &quot; is missing from the efficiency array&quot;);
+			return def_value;
+		}
+
+	}
+
+	void Global::SetEfficiency(std::string s, float e){
+		trim(s);
+		tolowercase(s);
+		efficiency[s] = e;
+		//
+	}
+
+	float Global::GetEfficiency(string s, set&lt;string&gt;&amp; doneconstructors, int techlevel){
+
+		CUnitTypeData* ud = this-&gt;UnitDefLoader-&gt;GetUnitTypeDataByName(s);
+
+		if(ud == 0){
+			return 0;
+		}
+
+		if(efficiency.find(ud-&gt;GetName()) != efficiency.end()){
+			if(ud-&gt;CanConstruct()&amp;&amp;(doneconstructors.find(ud-&gt;GetName())==doneconstructors.end())){
+
+				if(builderefficiency.find(s) != builderefficiency.end()){
+					int i = lastbuilderefficiencyupdate[ud-&gt;GetName()];
+					if(GetCurrentFrame()-(5 MINUTES) &lt; i){
+						return builderefficiency[ud-&gt;GetName()];
+					}
+				}
+
+				float e = efficiency[ud-&gt;GetName()];
+				
+				doneconstructors.insert(ud-&gt;GetName());
+
+				for(map&lt;int, string&gt;::const_iterator i = ud-&gt;GetUnitDef()-&gt;buildOptions.begin();i != ud-&gt;GetUnitDef()-&gt;buildOptions.end(); ++i){
+					CUnitTypeData* ud2 = UnitDefLoader-&gt;GetUnitTypeDataByName(i-&gt;second);
+
+					if(doneconstructors.find(i-&gt;second)==doneconstructors.end()){
+						doneconstructors.insert(i-&gt;second);
+
+						if (ud2-&gt;GetUnitDef()-&gt;techLevel&lt;techlevel){
+							e+=1.0f;
+						} else if (ud2-&gt;GetUnitDef()-&gt;techLevel != techlevel){
+							e+= efficiency[i-&gt;second]*pow(0.6f, (ud2-&gt;GetUnitDef()-&gt;techLevel-techlevel));
+						} else {
+							e+= efficiency[i-&gt;second];
+						}
+					}else{
+
+						if(ud2-&gt;GetUnitDef()-&gt;techLevel &gt; ud-&gt;GetUnitDef()-&gt;techLevel){
+							e+= 1.0f;
+						}
+
+						e += builderefficiency[i-&gt;second];
+					}
+
+				}
+
+				lastbuilderefficiencyupdate[ud-&gt;GetName()] = GetCurrentFrame();
+				builderefficiency[ud-&gt;GetName()] = e;
+
+				return e;
+			}else{
+				if(ud-&gt;GetUnitDef()-&gt;techLevel &lt; techlevel){
+					return 1.0f;
+				}else  if(ud-&gt;GetUnitDef()-&gt;techLevel &gt; techlevel){
+					return efficiency[ud-&gt;GetName()]*pow(0.6f, (ud-&gt;GetUnitDef()-&gt;techLevel-techlevel));
+				}
+
+				return efficiency[ud-&gt;GetName()];
+			}
+		}else{
+			L.print(&quot;error ::   &quot; + ud-&gt;GetName() + &quot; is missing from the efficiency array&quot;);
+			return 0.0f;
+		}
+	}
+
+	bool Global::LoadUnitData(){
+		if(G-&gt;L.FirstInstance()){
+			int unum = cb-&gt;GetNumUnitDefs();
+			const UnitDef** ulist = new const UnitDef*[unum];
+			cb-&gt;GetUnitDefList(ulist);
+			for(int i = 0; i &lt; unum; i++){
+				const UnitDef* pud = ulist[i];
+
+				if(pud == 0){
+					continue;
+				}
+
+				string eu = pud-&gt;name;
+
+				tolowercase(eu);
+				trim(eu);
+
+				float ef = pud-&gt;energyMake + pud-&gt;metalMake;
+
+				if(pud-&gt;energyCost &lt; 0){
+					ef += -pud-&gt;energyCost;
+				}
+
+				ef *= 2;
+
+				if(pud-&gt;weapons.empty() == false){
+					for(vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator k = pud-&gt;weapons.begin();k != pud-&gt;weapons.end();++k){
+						//ef += k-&gt;def-&gt;
+						float av=0;
+						int numTypes;// = cb-&gt;getk-&gt;def-&gt;damages.numTypes;
+						cb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numTypes);
+						for(int a=0;a&lt;numTypes;++a){
+							if(a == 0){
+								av = k-&gt;def-&gt;damages[0];//damages
+							}else{
+								av = (av+k-&gt;def-&gt;damages[a])/2;
+							}
+						}
+						ef += av;
+					}
+				}
+
+				ef += pud-&gt;power;
+
+				efficiency[eu] = ef;
+				unit_names[eu] = pud-&gt;humanName;
+				unit_descriptions[eu] = pud-&gt;tooltip;
+			}
+
+			string filename = info-&gt;datapath;
+			filename += slash;
+			filename += &quot;learn&quot;;
+			filename += slash;
+			filename += info-&gt;tdfpath;
+			filename += &quot;.tdf&quot;;
+
+			string* buffer = new string;
+
+			if(ReadFile(filename, buffer)){
+
+				TdfParser cq(this);
+
+				cq.LoadBuffer(buffer-&gt;c_str(), buffer-&gt;size());
+				iterations = atoi(cq.SGetValueDef(&quot;1&quot;, &quot;AI\\iterations&quot;).c_str());
+
+				for(map&lt;string, float&gt;::iterator i = efficiency.begin(); i != efficiency.end(); ++i){
+					string s = &quot;AI\\&quot;;
+					s += i-&gt;first;
+					float ank = (float)atof(cq.SGetValueDef(&quot;14&quot;, s.c_str()).c_str());
+					if(ank &gt; i-&gt;second) i-&gt;second = ank;
+				}
+
+				iterations = atoi(cq.SGetValueDef(&quot;1&quot;, &quot;AI\\iterations&quot;).c_str());
+				iterations++;
+
+				cq.GetDef(firstload, &quot;1&quot;, &quot;AI\\firstload&quot;);
+
+				if(firstload == true){
+					L.iprint(&quot; This is the first time this mod has been loaded, up. Take this first game to train NTai up, and be careful of throwing the same units at it over and over again&quot;);
+					firstload = false;
+
+					for(map&lt;string, float&gt;::iterator i = efficiency.begin(); i != efficiency.end(); ++i){
+						CUnitTypeData* uda = UnitDefLoader-&gt;GetUnitTypeDataByName(i-&gt;first);
+						if(uda){
+							i-&gt;second += uda-&gt;GetUnitDef()-&gt;health;
+						}
+					}
+
+				}
+
+				loaded = true;
+				return true;
+			} else{
+
+				for(int i = 0; i &lt; unum; i++){
+					float ts = 500;
+					if(ulist[i]-&gt;weapons.empty()){
+						ts += ulist[i]-&gt;health+ulist[i]-&gt;energyMake + ulist[i]-&gt;metalMake + ulist[i]-&gt;extractsMetal*50+ulist[i]-&gt;tidalGenerator*30 + ulist[i]-&gt;windGenerator*30;
+						ts *= 300;
+					}else{
+						ts += 20*ulist[i]-&gt;weapons.size();
+					}
+					string eu = ulist[i]-&gt;name;
+					tolowercase(eu);
+					trim(eu);
+					efficiency[eu] = ts;
+				}
+
+				SaveUnitData();
+
+				G-&gt;L.print(&quot;failed to load :&quot; + filename);
+
+				return false;
+			}
+		}
+		return false;
+	}
+
+	bool Global::SaveUnitData(){
+		NLOG(&quot;Global::SaveUnitData()&quot;);
+
+		if(L.FirstInstance() == true){
+			ofstream off;
+
+			string filename = info-&gt;datapath;
+			filename += slash;
+			filename += &quot;learn&quot;;
+			filename += slash;
+			filename += info-&gt;tdfpath;
+			filename += &quot;.tdf&quot;;
+
+			off.open(filename.c_str());
+
+			if(off.is_open() == true){
+				off &lt;&lt; &quot;[AI]&quot; &lt;&lt; endl &lt;&lt; &quot;{&quot; &lt;&lt; endl &lt;&lt; &quot;    // &quot; &lt;&lt; AI_NAME &lt;&lt; &quot; AF :: unit efficiency cache file&quot; &lt;&lt; endl &lt;&lt; endl;
+
+				off &lt;&lt; &quot;    version=XE9.79;&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;    firstload=&quot; &lt;&lt; firstload &lt;&lt; &quot;;&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;    modname=&quot; &lt;&lt; G-&gt;cb-&gt;GetModName() &lt;&lt; &quot;;&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;    iterations=&quot; &lt;&lt; iterations &lt;&lt; &quot;;&quot; &lt;&lt; endl;
+				off &lt;&lt; endl;
+
+				off &lt;&lt; &quot;    [VALUES]&quot; &lt;&lt; endl &lt;&lt; &quot;    {&quot; &lt;&lt; endl;
+
+				for(map&lt;string, float&gt;::const_iterator i = efficiency.begin(); i != efficiency.end(); ++i){
+					off &lt;&lt; &quot;        &quot;&lt;&lt; i-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; i-&gt;second &lt;&lt; &quot;;    // &quot; &lt;&lt; unit_names[i-&gt;first] &lt;&lt; &quot; :: &quot;&lt;&lt; unit_descriptions[i-&gt;first]&lt;&lt;endl;
+				}
+				off &lt;&lt; &quot;    }&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;    [NAMES]&quot; &lt;&lt; endl &lt;&lt; &quot;    {&quot;&lt;&lt; endl;
+
+				for(map&lt;string, float&gt;::const_iterator i = efficiency.begin(); i != efficiency.end(); ++i){
+					off &lt;&lt; &quot;        &quot;&lt;&lt; i-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; unit_names[i-&gt;first] &lt;&lt; &quot;;&quot; &lt;&lt;endl;
+				}
+
+				off &lt;&lt; &quot;    }&quot; &lt;&lt; endl;
+
+				off &lt;&lt; &quot;    [DESCRIPTIONS]&quot; &lt;&lt; endl &lt;&lt; &quot;    {&quot;&lt;&lt; endl;
+
+				for(map&lt;string, float&gt;::const_iterator i = efficiency.begin(); i != efficiency.end(); ++i){
+					off &lt;&lt; &quot;        &quot;&lt;&lt; i-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; unit_descriptions[i-&gt;first] &lt;&lt; &quot;;&quot;&lt;&lt;endl;
+				}
+
+				off &lt;&lt; &quot;    }&quot; &lt;&lt; endl;
+				off &lt;&lt; &quot;}&quot; &lt;&lt; endl;
+				off.close();
+
+				saved = true;
+				return true;
+			}else{
+				G-&gt;L.print(&quot;failed to save :&quot; + filename);
+				off.close();
+				return false;
+			}
+		}
+		return false;
+	}
+
+	float Global::GetTargettingWeight(string unit, string target){
+		float tempscore = 0;
+
+		if(info-&gt;hardtarget == false){
+			tempscore = GetEfficiency(target);
+		}else{
+			string fh = unit + &quot;\\target_weights\\&quot; + target;
+			string fg = unit + &quot;\\target_weights\\undefined&quot;;
+
+			float fz = GetEfficiency(target);
+			string tempdef = Get_mod_tdf()-&gt;SGetValueDef(to_string(fz), fg.c_str());
+			tempscore = (float)atof(Get_mod_tdf()-&gt;SGetValueDef(tempdef, fh).c_str()); // load &quot;unitname\\target_weights\\enemyunitname&quot; to retirieve targetting weights
+		}
+
+		return tempscore;
+	}
+
+
+	void Global::EnemyEnterLOS(int enemy){ // an enemy has entered LOS
+		Cached-&gt;enemies.insert(enemy);
+	}
+
+	void Global::EnemyLeaveLOS(int enemy){ // An enemy has left LOS
+		Cached-&gt;enemies.erase(enemy);
+	}
+
+	void Global::EnemyEnterRadar(int enemy){ // an enemy has entered radar
+		Cached-&gt;enemies.insert(enemy);
+	}
+
+	void Global::EnemyLeaveRadar(int enemy){ // an enemy has left radar
+		Cached-&gt;enemies.erase(enemy);
+	}
+
+	float3 Global::GetUnitPos(int unitid, int enemy){ // do 10 frame delays between updates fo different units
+		if(!ValidUnitID(unitid)){
+			return UpVector;
+		}
+
+		float3 p = chcb-&gt;GetUnitPos(unitid);
+
+		if(Map-&gt;CheckFloat3(p)==false){
+			return UpVector;
+		}else{
+			return p;
+		}
+
+	}
+
+	bool Global::HasUnit(int unit){
+		return (units.find(unit) != units.end());
+	}
+
+	boost::shared_ptr&lt;IModule&gt; Global::GetUnit(int unit){
+		if(HasUnit(unit)==false){
+			IModule* a = 0;
+			boost::shared_ptr&lt;IModule&gt; t(a);
+			return t;
+		}
+
+		return units[unit];
+	}
+
+	void Global::RegisterMessageHandler(boost::shared_ptr&lt;IModule&gt; handler){
+		handlers.insert(handler);
+	}
+
+	void Global::FireEvent(CMessage &amp;message){
+		if(message.GetType() == string(&quot;&quot;)){
+			return;
+		}
+
+		message.SetFrame(GetCurrentFrame());
+
+		msgqueue.push_back(message);
+	}
+
+	void Global::DestroyHandler(boost::shared_ptr&lt;IModule&gt; handler){
+		handler-&gt;DestroyModule();
+
+		if(!handlers.empty()){
+			handlers.erase(handler);
+		}
+
+		return;
+	}
+
+	void Global::RemoveHandler(boost::shared_ptr&lt;IModule&gt; handler){
+		dead_handlers.insert(handler);
+	}
+
+}
+
+// ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
+
+/** Random note
+unitdef-&gt;type can be one of the following:
+ MetalExtractor
+ Transport
+ Builder
+ Factory
+ Bomber
+ Fighter
+ GroundUnit
+ Building
+ **/

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/CConfigData.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/CConfigData.cpp	2008-12-18 20:54:42 UTC (rev 7197)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/CConfigData.cpp	2008-12-19 10:04:48 UTC (rev 7198)
@@ -13,6 +13,13 @@
 		scout_speed = 60;
 		rule_extreme_interpolate= true;
 		mod_tdf = new TdfParser(G);
+		
+		//CLOG(&quot;Loading AI.tdf with TdfParser&quot;);
+		TdfParser cs(G);
+		cs.LoadFile(&quot;AI/AI.tdf&quot;);
+		
+		//CLOG(&quot;Retrieving datapath value&quot;);
+		datapath = cs.SGetValueDef(string(&quot;AI/NTai&quot;), &quot;AI\\data_path&quot;);
 	}
 
 	CConfigData::~CConfigData(){

Modified: branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/Log.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/Log.cpp	2008-12-18 20:54:42 UTC (rev 7197)
+++ branches/caiinterface/AI/Skirmish/NTai/AI/NTai/Helpers/Log.cpp	2008-12-19 10:04:48 UTC (rev 7198)
@@ -3,7 +3,7 @@
 namespace ntai {
 	int Lmagic;
 
-	Log::Log(){
+	Log::Log() : G(NULL) {
 		verbose = false;
 		First = false;
 	}
@@ -169,6 +169,10 @@
 
 	void Log::print(string message){
 		if(message.empty() == true) return;
+		if (!G) {
+			CLOG(message);
+			return;
+		}
 		string gtime;
 		if(plaintext == true){
 			gtime = GameTime() + GetSysTime() +FrameTime() + message + &quot;\n&quot;;
@@ -286,4 +290,4 @@
 	bool Log::IsVerbose(){
 		return verbose;
 	}
-}
+}

Modified: branches/caiinterface/Documentation/changelog.txt
===================================================================
--- branches/caiinterface/Documentation/changelog.txt	2008-12-18 20:54:42 UTC (rev 7197)
+++ branches/caiinterface/Documentation/changelog.txt	2008-12-19 10:04:48 UTC (rev 7198)
@@ -13,18 +13,17 @@
  - use SSE instead of X87 for FP-calculations
  - if in Choose ingame startposition mode its possible to play a map with more players than startpositions
  - fix the aircraft hovering / drifting
- - fix random start positions not beeing random
+ - fix random start positions not being random
  - fix area-attack for aircraft (#1144 again)
  - GenerateTargets no longer has much information that the team requesting targets doesn't have
  - fix spikes / lags in hosting demos
  - don't allow gunships to drift off the map
  - make planes bobble in place gently by default, and make hoverfactor work as intended
- - fix unti reply sound
+ - fix unit reply sound
  - don't open a (unused) network socket in single player mode
  - Don't let static beamlasers overshoot
  - Added new collision volume types: sphere, footprint.
  - Units/features with no collision volume defined get 'footprint' type by default now, this restores the 0.76b1 behaviour as default
- -Don't put factories on patrol and don't give a stop order
 
 
 Spring start / script.txt changes:
@@ -34,14 +33,12 @@
 
 User Interface:
  - enable startboxes by default
- - decreased CPU laod and increase drawing speed lines
+ - decreased CPU load and increase drawing speed lines
  - fix small memleak when resizing the window
  - The protection ring shows up for non-stockpile interceptors
  - fix detection of units under mouse for spectators
  - fix the CTeam statistics tracking
  - do not force useFPShadows to true unless they are supported (to prevent crashes during map-loading)
- - The protection ring shows up for non-stockpile interceptors
- - fix detection of units under mouse for spectators
  - fix for annoying flickering of the grounddetail texture in CA if some LUPS fx were visible
  - fixed a bug with waterplane on centerrock (the terrain is deeper than the water plane was drawn)
  - made forcestart a real shortcut, so you can unbind it
@@ -54,6 +51,7 @@
  - moved Spring.GetSoundStreamTime() LuaUnsyncedCtrl -&gt; LuaUnsyncedRead
  - added a 2nd return value to Spring.GetSoundStreamTime() (total sound stream length in seconds)
  - Made it possible to specify start positions in map with LUA .smd file
+ - Immobile Builders doesn't put factories on patrol and doesn't give a stop order
 
 Unitsync:
  - Don't crash/abort() on invalid handles, but throw exception instead
@@ -64,7 +62,7 @@
  - added SetSpringConfigFile(char*): reinitialise config handler to use the provided path
  - added char* GetSpringConfigFile(): return the currently used path to the config file
 
- -Deprecated APIs:
+ - Deprecated APIs:
    - GetCurrentList
    - AddClient
    - RemoveClient
@@ -84,7 +82,7 @@
  - Remove old CA shortcuts
 
 AAI v0.875	
-- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order water factories on a land map anymore)
+- Current amount of land/water within the base is taken into account when selecting factories (e.g. don't order water factories on a land map anymore)
 - Improved AAIs behaviour on water maps with start positions on islands/land masses
 - Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, works better if there are land and sea spots available at the same time)
 - Continent file version bumped to 0.87

Modified: branches/caiinterface/rts/Game/GameHelper.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.cpp	2008-12-18 20:54:42 UTC (rev 7197)
+++ branches/caiinterface/rts/Game/GameHelper.cpp	2008-12-19 10:04:48 UTC (rev 7198)
@@ -859,7 +859,7 @@
 	float3 pos = unit-&gt;midPos;
 	if (teamHandler-&gt;Ally(allyteam,unit-&gt;allyteam) || (unit-&gt;losStatus[allyteam] &amp; LOS_INLOS)) {
 		// ^ it's one of our own, or it's in LOS, so don't add an error ^
-	} else if ((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_PREVLOS) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_CONTRADAR) &amp;&amp; !unit-&gt;mobility) {
+	} else if ((!gameSetup || gameSetup-&gt;ghostedBuildings) &amp;&amp; (unit-&gt;losStatus[allyteam] &amp; LOS_PREVLOS) &amp;&amp; !unit-&gt;mobility) {
 		// ^ this is a ghosted building, so don't add an error ^
 	} else if ((unit-&gt;losStatus[allyteam] &amp; LOS_INRADAR)) {
 		pos += unit-&gt;posErrorVector * radarhandler-&gt;radarErrorSize[allyteam];


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001966.html">[Taspring-linux-commit] r7197 - branches/gmltest/rts/lib/gml
</A></li>
	<LI>Next message: <A HREF="001968.html">[Taspring-linux-commit] r7199 - in trunk/AI/Global/NTai/AI/NTai:	Core Helpers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1967">[ date ]</a>
              <a href="thread.html#1967">[ thread ]</a>
              <a href="subject.html#1967">[ subject ]</a>
              <a href="author.html#1967">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
