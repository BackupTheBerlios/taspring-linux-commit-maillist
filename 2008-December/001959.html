<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7190 - in trunk: . AI/Global/AAI	AI/Global/KAIK-0.13 AI/Global/RAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7190%20-%20in%20trunk%3A%20.%20AI/Global/AAI%0A%09AI/Global/KAIK-0.13%20AI/Global/RAI&In-Reply-To=%3C20081217195201.3F92147BA%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001958.html">
   <LINK REL="Next"  HREF="001960.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7190 - in trunk: . AI/Global/AAI	AI/Global/KAIK-0.13 AI/Global/RAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7190%20-%20in%20trunk%3A%20.%20AI/Global/AAI%0A%09AI/Global/KAIK-0.13%20AI/Global/RAI&In-Reply-To=%3C20081217195201.3F92147BA%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7190 - in trunk: . AI/Global/AAI	AI/Global/KAIK-0.13 AI/Global/RAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Dec 17 20:52:01 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001958.html">[Taspring-linux-commit] r7189 - in branches/caiinterface:	Documentation rts/ExternalAI rts/Game rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/Units/COB rts/System	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/build/vstudio8 rts/lib/gml	tools/unitsync
</A></li>
        <LI>Next message: <A HREF="001960.html">[Taspring-linux-commit] r7191 - trunk/Documentation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1959">[ date ]</a>
              <a href="thread.html#1959">[ thread ]</a>
              <a href="subject.html#1959">[ subject ]</a>
              <a href="author.html#1959">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-12-17 20:52:00 +0100 (Wed, 17 Dec 2008)
New Revision: 7190

Modified:
   trunk/AI/Global/AAI/AAI.cpp
   trunk/AI/Global/KAIK-0.13/AIExports.cpp
   trunk/AI/Global/KAIK-0.13/DefenseMatrix.cpp
   trunk/AI/Global/KAIK-0.13/Defines.h
   trunk/AI/Global/KAIK-0.13/GlobalAI.cpp
   trunk/AI/Global/KAIK-0.13/SunParser.cpp
   trunk/AI/Global/KAIK-0.13/SunParser.h
   trunk/AI/Global/KAIK-0.13/UnitTable.cpp
   trunk/AI/Global/RAI/GResourceMap.cpp
   trunk/AI/Global/RAI/GTerrainMap.cpp
   trunk/AI/Global/RAI/LogFile.cpp
   trunk/AI/Global/RAI/LogFile.h
   trunk/AI/Global/RAI/RAI.cpp
   trunk/SConstruct
Log:
prepared AAI, KAIK and RAI for dynamic root folder location (where they look for or write config-, log- or cache-files)

Modified: trunk/AI/Global/AAI/AAI.cpp
===================================================================
--- trunk/AI/Global/AAI/AAI.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/AAI/AAI.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -3,7 +3,7 @@
 //
 // A skirmish AI for the TA Spring engine.
 // Copyright Alexander Seizinger
-// 
+//
 // Released under GPL license: see LICENSE.html for more information.
 // -------------------------------------------------------------------------
 
@@ -26,7 +26,7 @@
 	map = 0;
 	af = 0;
 	am = 0;
-	
+
 	side = 0;
 
 	initialized = false;
@@ -50,7 +50,7 @@
 	fprintf(file, &quot;\nHover Groups:     %i\n&quot;, group_list[HOVER_ASSAULT].size());
 	fprintf(file, &quot;\nSea Groups:       %i\n&quot;, group_list[SEA_ASSAULT].size());
 	fprintf(file, &quot;\nSubmarine Groups: %i\n\n&quot;, group_list[SUBMARINE_ASSAULT].size());
-	
+
 	fprintf(file, &quot;Future metal/energy request: %i / %i\n&quot;, (int)execute-&gt;futureRequestedMetal, (int)execute-&gt;futureRequestedEnergy);
 	fprintf(file, &quot;Future metal/energy supply:    %i / %i\n\n&quot;, (int)execute-&gt;futureAvailableMetal, (int)execute-&gt;futureAvailableEnergy);
 
@@ -59,10 +59,12 @@
 	fprintf(file, &quot;Future/active factories:   %i / %i\n\n&quot;, ut-&gt;futureFactories, ut-&gt;activeFactories);
 
 	fprintf(file, &quot;Factory ratings:\n&quot;);
-	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].begin(); fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].end(); ++fac)
+	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].begin();
+			fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].end(); ++fac) {
 		fprintf(file, &quot;%-20s: %f\n&quot;, bt-&gt;unitList[*fac-1]-&gt;humanName.c_str(), bt-&gt;GetFactoryRating(*fac));
-		
+	}
 
+
 	// delete buildtasks
 	for(list&lt;AAIBuildTask*&gt;::iterator task = build_tasks.begin(); task != build_tasks.end(); task++)
 	{
@@ -72,7 +74,6 @@
 	// save mod learning data
 	bt-&gt;SaveBuildTable();
 
-		
 	// delete unit groups
 	for(int i = 0; i &lt;= MOBILE_CONSTRUCTOR; i++)
 	{
@@ -107,13 +108,13 @@
 	char filename[500];
 	char buffer[500];
 	char team_number[3];
-	
+
 	#ifdef WIN32
 		itoa(team, team_number, 10);
 	#else
 		snprintf(team_number,10,&quot;%d&quot;,team);
 	#endif
-	
+
 	strcpy(buffer, MAIN_PATH);
 	strcat(buffer, AILOG_PATH);
 	strcat(buffer, &quot;AAI_log_team_&quot;);
@@ -169,7 +170,7 @@
 {
 	const UnitDef *def, *att_def;
 	UnitCategory att_cat, cat;
-	
+
 	// filter out commander
 	if(ut-&gt;cmdr != -1)
 	{
@@ -187,7 +188,7 @@
 	// assault grups may be ordered to retreat
 	if(cat &gt;= GROUND_ASSAULT &amp;&amp; cat &lt;= SUBMARINE_ASSAULT) 
 			execute-&gt;CheckFallBack(damaged, def-&gt;id);
-	
+
 	// known attacker
 	if(attacker &gt;= 0)
 	{
@@ -208,7 +209,7 @@
 			else
 			{
 				//if(att_cat &gt;= GROUND_ASSAULT &amp;&amp; att_cat &lt;= SUBMARINE_ASSAULT)
-		
+
 				float3 pos = cb-&gt;GetUnitPos(attacker);
 				AAISector *sector = map-&gt;GetSectorOfPos(&amp;pos);
 
@@ -255,7 +256,7 @@
 	if(!cfg-&gt;initialized)
 		return;
 
-	// get unit&#180;s id
+	// get unit&#239;&#191;&#189;s id
 	const UnitDef *def = cb-&gt;GetUnitDef(unit);
 	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
 
@@ -339,7 +340,7 @@
 	if(!initialized)
 		return;
 
-	// get unit&#180;s id
+	// get unit&#239;&#191;&#189;s id
 	const UnitDef *def = cb-&gt;GetUnitDef(unit);
 
 	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
@@ -448,7 +449,7 @@
 
 void AAI::UnitDestroyed(int unit, int attacker) 
 {
-	// get unit&#180;s id 
+	// get unit&#239;&#191;&#189;s id 
 	const UnitDef *def = cb-&gt;GetUnitDef(unit);
 
 	// get unit's category and position
@@ -728,7 +729,7 @@
 
 	if(attacker)
 	{	
-		// get unit&#180;s id 
+		// get unit&#239;&#191;&#189;s id 
 		const UnitDef *def = cb-&gt;GetUnitDef(enemy);
 		const UnitDef *def_att = cb-&gt;GetUnitDef(attacker);
 
@@ -866,14 +867,14 @@
 
 int AAI::HandleEvent(int msg, const void* data)
 {
-   switch (msg)
-   {
-   case AI_EVENT_UNITCAPTURED: // 2
-      {
-         const IGlobalAI::ChangeTeamEvent* cte = (const IGlobalAI::ChangeTeamEvent*) data;
-         UnitDestroyed(cte-&gt;unit,-1);
-      }
-      break;
-   }
-   return 0;
-} 
+	switch (msg)
+	{
+		case AI_EVENT_UNITCAPTURED: // 2
+		{
+			const IGlobalAI::ChangeTeamEvent* cte = (const IGlobalAI::ChangeTeamEvent*) data;
+			UnitDestroyed(cte-&gt;unit,-1);
+		}
+		break;
+	}
+	return 0;
+}

Modified: trunk/AI/Global/KAIK-0.13/AIExports.cpp
===================================================================
--- trunk/AI/Global/KAIK-0.13/AIExports.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/AIExports.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1,37 +1,39 @@
-#include &quot;GlobalAI.h&quot;
-
-std::set&lt;IGlobalAI*&gt; ais;
-
-
-SHARED_EXPORT int GetGlobalAiVersion() {
-	return GLOBAL_AI_INTERFACE_VERSION;
-}
-
-SHARED_EXPORT void GetAiName(char* name) {
-	strcpy(name, AI_VERSION);
-}
-
-SHARED_EXPORT IGlobalAI* GetNewAI() {
-	if (ais.empty())
-		creg::System::InitializeClasses();
-
-	CGlobalAI* ai = new CGlobalAI();
-	ais.insert(ai);
-	return ai;
-}
-
-SHARED_EXPORT void ReleaseAI(IGlobalAI* i) {
-	ais.erase(i);
-	delete (CGlobalAI*) i;
-
-	if (ais.empty())
-		creg::System::FreeClasses();
-}
-
-SHARED_EXPORT int IsCInterface(void) {
-	return 0;
-}
-
-SHARED_EXPORT int IsLoadSupported() {
-	return 1;
-}
+#include &quot;GlobalAI.h&quot;
+
+std::set&lt;IGlobalAI*&gt; ais;
+
+
+SHARED_EXPORT int GetGlobalAiVersion() {
+	return GLOBAL_AI_INTERFACE_VERSION;
+}
+
+SHARED_EXPORT void GetAiName(char* name) {
+
+	static std::string vers = AI_VERSION;
+	strcpy(name, vers.c_str());
+}
+
+SHARED_EXPORT IGlobalAI* GetNewAI() {
+	if (ais.empty())
+		creg::System::InitializeClasses();
+
+	CGlobalAI* ai = new CGlobalAI();
+	ais.insert(ai);
+	return ai;
+}
+
+SHARED_EXPORT void ReleaseAI(IGlobalAI* i) {
+	ais.erase(i);
+	delete (CGlobalAI*) i;
+
+	if (ais.empty())
+		creg::System::FreeClasses();
+}
+
+SHARED_EXPORT int IsCInterface(void) {
+	return 0;
+}
+
+SHARED_EXPORT int IsLoadSupported() {
+	return 1;
+}

Modified: trunk/AI/Global/KAIK-0.13/DefenseMatrix.cpp
===================================================================
--- trunk/AI/Global/KAIK-0.13/DefenseMatrix.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/DefenseMatrix.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1,207 +1,207 @@
-#include &quot;DefenseMatrix.h&quot;
-
-
-CR_BIND(CDefenseMatrix, (NULL));
-CR_REG_METADATA(CDefenseMatrix, (
-	CR_MEMBER(ChokeMapsByMovetype),
-	CR_MEMBER(ChokePointArray),
-	CR_MEMBER(BuildMaskArray),
-
-	// CR_MEMBER(spotFinder),
-	CR_MEMBER(ThreatMapXSize),
-	CR_MEMBER(ThreatMapYSize),
-	CR_MEMBER(TotalCells),
-	CR_MEMBER(ai),
-	CR_RESERVED(16),
-	CR_POSTLOAD(PostLoad)
-));
-
-
-CDefenseMatrix::CDefenseMatrix(AIClasses *ai) {
-	this-&gt;ai = ai;
-}
-CDefenseMatrix::~CDefenseMatrix() {
-}
-
-void CDefenseMatrix::PostLoad() {
-	spotFinder = new CSpotFinder(ai, ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
-	spotFinder-&gt;SetBackingArray(&amp;ChokePointArray.front(), ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
-}
-
-
-void CDefenseMatrix::Init() {
-	ChokePointArray.resize(ai-&gt;pather-&gt;totalcells);
-	// temp only, will be used to mask bad spots that workers can't build at
-	BuildMaskArray.resize(ai-&gt;pather-&gt;totalcells,0);
-
-	ai-&gt;pather-&gt;CreateDefenseMatrix();
-
-	spotFinder = new CSpotFinder(ai, ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
-	spotFinder-&gt;SetBackingArray(&amp;ChokePointArray.front(), ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
-}
-
-void CDefenseMatrix::MaskBadBuildSpot(float3 pos) {
-	int f3multiplier = 8 * THREATRES;
-	int x = (int) (pos.x / f3multiplier);
-	int y = (int) (pos.z / f3multiplier);
-
-	BuildMaskArray[y * ai-&gt;pather-&gt;PathMapXSize + x] = 1;
-}
-
-float3 CDefenseMatrix::GetDefensePos(const UnitDef* def, float3 builderpos) {
-	ai-&gt;ut-&gt;UpdateChokePointArray();
-	int f3multiplier = 8 * THREATRES;
-	int Range = int(ai-&gt;ut-&gt;GetMaxRange(def) / f3multiplier);
-	int bestspotx = 0;
-	int bestspoty = 0;
-	float averagemapsize = sqrt(float(ai-&gt;pather-&gt;PathMapXSize * ai-&gt;pather-&gt;PathMapYSize)) * f3multiplier;
-	float bestscore_fast = 0.0f;
-	int bestspotx_fast = 0;
-	int bestspoty_fast = 0;
-	ai-&gt;math-&gt;TimerStart();
-
-	spotFinder-&gt;SetRadius(Range);
-	float* sumMap = spotFinder-&gt;GetSumMap();
-
-	// hack to find a good start
-	{
-		int x = (int) (builderpos.x / f3multiplier);
-		int y = (int) (builderpos.z / f3multiplier);
-		float fastSumMap = sumMap[y * ai-&gt;pather-&gt;PathMapXSize + x];
-		float3 spotpos = float3(x * f3multiplier, 0, y * f3multiplier);
-		float myscore = fastSumMap / (builderpos.distance2D(spotpos) + averagemapsize / 8) * ((ai-&gt;pather-&gt;HeightMap[y * ai-&gt;pather-&gt;PathMapXSize + x] + 200) / (ai-&gt;pather-&gt;AverageHeight + 10)) / (ai-&gt;tm-&gt;ThreatAtThisPoint(spotpos) + 0.01);
-		bestscore_fast = myscore;
-		bestspotx_fast = x;
-		bestspoty_fast = y;
-	}
-
-	int skipCount = 0;
-	int testCount = 0;
-
-	for (int x = 0; x &lt; ai-&gt;pather-&gt;PathMapXSize / CACHEFACTOR; x++) {
-		for (int y = 0; y &lt; ai-&gt;pather-&gt;PathMapYSize / CACHEFACTOR; y++) {
-			// KLOOTNOTE: SOMETIMES RETURNS UNINITIALIZED CRAP?
-			// (gdb) print cachePoint-&gt;y   $2 = 219024104
-			// (gdb) print cachePoint-&gt;x   $3 = -1215908928
-			CachePoint* cachePoint = spotFinder-&gt;GetBestCachePoint(x, y);
-
-			if (!cachePoint) {
-				return ZeroVector;
-			}
-
-			float bestScoreInThisBox = cachePoint-&gt;maxValueInBox;
-
-			// guess that this point is as good as posible
-			// make best posible build spot (nearest to builder)
-			float bestX = builderpos.x / f3multiplier;
-			float bestY = builderpos.z / f3multiplier;
-
-			if (bestX &gt; x * CACHEFACTOR) {
-				if (bestX &gt; (x * CACHEFACTOR + CACHEFACTOR)) {
-					bestX = x * CACHEFACTOR + CACHEFACTOR;
-				}
-			}
-			else {
-				bestX = x * CACHEFACTOR;
-			}
-
-			if (bestY &gt; y * CACHEFACTOR) {
-				if (bestY &gt; (y * CACHEFACTOR + CACHEFACTOR)) {
-					bestY = y * CACHEFACTOR + CACHEFACTOR;
-				}
-			}
-			else {
-				bestY = y * CACHEFACTOR;
-			}
-
-			float3 bestPosibleSpotpos = float3(bestX * f3multiplier, 0, bestY * f3multiplier);
- 			// this must be guessed, set it to the best possible (slow)
-			float bestThreatAtThisPoint = 0.01 + ai-&gt;tm-&gt;GetAverageThreat() - 1;
-			float bestDistance = builderpos.distance2D(bestPosibleSpotpos);
-			float bestHeight = ai-&gt;pather-&gt;HeightMap[cachePoint-&gt;y * ai-&gt;pather-&gt;PathMapXSize + cachePoint-&gt;x] + 200;
-			float bestPosibleMyScore = bestScoreInThisBox / (bestDistance + averagemapsize / 4) * (bestHeight + 200) / bestThreatAtThisPoint;
-			// have a best posible score for all points inside the size of the cache box
-			// if this is better than the current known best, test if any point inside the box is better
-
-			if (bestPosibleMyScore &gt; bestscore_fast) {
-				testCount++;
-				// must test all the points inside this box
-				for (int sx = x * CACHEFACTOR; sx &lt; ai-&gt;pather-&gt;PathMapXSize &amp;&amp; sx &lt; (x * CACHEFACTOR + CACHEFACTOR); sx++) {
-					for (int sy = y * CACHEFACTOR; sy &lt; ai-&gt;pather-&gt;PathMapYSize &amp;&amp; sy &lt; (y * CACHEFACTOR + CACHEFACTOR); sy++) {
-						float fastSumMap = sumMap[sy * ai-&gt;pather-&gt;PathMapXSize + sx];
-						float3 spotpos = float3(sx * f3multiplier, 0, sy * f3multiplier);
-						float myscore = fastSumMap / (builderpos.distance2D(spotpos) + averagemapsize / 4) * (ai-&gt;pather-&gt;HeightMap[sy * ai-&gt;pather-&gt;PathMapXSize + sx]+200) / (ai-&gt;tm-&gt;ThreatAtThisPoint(spotpos) + 0.01);
-						// THIS COULD BE REALLY SLOW!
-						if (myscore &gt; bestscore_fast &amp;&amp; BuildMaskArray[sy * ai-&gt;pather-&gt;PathMapXSize + sx] == 0 &amp;&amp; ai-&gt;cb-&gt;CanBuildAt(def, spotpos)) {
-							bestscore_fast = myscore;
-							bestspotx_fast = sx;
-							bestspoty_fast = sy;
-						}
-					}
-				}
-			}
-			else {
-				// skip box
-				skipCount++;
-			}
-		}
-	}
-
-	bestspotx = bestspotx_fast;
-	bestspoty = bestspoty_fast;
-
-	return float3(bestspotx * f3multiplier, 0, bestspoty * f3multiplier);
-}
-
-
-
-void CDefenseMatrix::AddDefense(float3 pos, const UnitDef* def) {
-	int f3multiplier = 8 * THREATRES;
-	int Range = int(ai-&gt;ut-&gt;GetMaxRange(def) / f3multiplier);
-	int squarerange = Range * Range;
-	int x, y;
-	ai-&gt;math-&gt;F32XY(pos, &amp;x, &amp;y, 8);
-
-	// TODO: test if this works
-	for (int myx = x - Range; myx &lt;= x + Range; myx++) {
-		if (myx &gt;= 0 &amp;&amp; myx &lt; ai-&gt;pather-&gt;PathMapXSize) {
-			for (int myy = y - Range; myy &lt;= y + Range; myy++) {
-				int distance = int((x - myx) * (x - myx) + (y - myy) * (y - myy) - 0.5);
-				if (myy &gt;= 0 &amp;&amp; myy &lt; ai-&gt;pather-&gt;PathMapYSize &amp;&amp; (distance) &lt;= squarerange) {
-					for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes;i++) {
-						ChokeMapsByMovetype[i][myy * ai-&gt;pather-&gt;PathMapXSize + myx] /= 2;
-					}
-				}
-			}
-		}
-	}
-
-	spotFinder-&gt;InvalidateSumMap(x, y, Range + 1);
-	// ai-&gt;debug-&gt;MakeBWTGA(Chokepointmap, ai-&gt;tm-&gt;ThreatMapWidth, ai-&gt;tm-&gt;ThreatMapHeight, &quot;DebugPathMatrix&quot;, 1);
-}
-
-
-void CDefenseMatrix::RemoveDefense(float3 pos, const UnitDef* def) {
-	int f3multiplier = 8 * THREATRES;
-	int Range = int(ai-&gt;ut-&gt;GetMaxRange(def) / f3multiplier);
-	int squarerange = Range * Range;
-	int x, y;
-	ai-&gt;math-&gt;F32XY(pos, &amp;x, &amp;y, 8);
-
-	// TODO: test if this works
-	for (int myx = x - Range; myx &lt;= x + Range; myx++) {
-		if (myx &gt;= 0 &amp;&amp; myx &lt; ai-&gt;pather-&gt;PathMapXSize) {
-			for (int myy = y - Range; myy &lt;= y + Range; myy++) {
-				int distance = int((x - myx) * (x - myx) + (y - myy) * (y - myy) - 0.5);
-
-				if (myy &gt;= 0 &amp;&amp; myy &lt; ai-&gt;pather-&gt;PathMapYSize &amp;&amp; (distance) &lt;= squarerange) {
-					for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes;i++) {
-						ChokeMapsByMovetype[i][myy * ai-&gt;pather-&gt;PathMapXSize + myx] *= 2;
-					}
-				}
-			}
-		}
-	}
-
-	spotFinder-&gt;InvalidateSumMap(x, y, Range);
-}
+#include &quot;DefenseMatrix.h&quot;
+
+
+CR_BIND(CDefenseMatrix, (NULL));
+CR_REG_METADATA(CDefenseMatrix, (
+	CR_MEMBER(ChokeMapsByMovetype),
+	CR_MEMBER(ChokePointArray),
+	CR_MEMBER(BuildMaskArray),
+
+	// CR_MEMBER(spotFinder),
+	CR_MEMBER(ThreatMapXSize),
+	CR_MEMBER(ThreatMapYSize),
+	CR_MEMBER(TotalCells),
+	CR_MEMBER(ai),
+	CR_RESERVED(16),
+	CR_POSTLOAD(PostLoad)
+));
+
+
+CDefenseMatrix::CDefenseMatrix(AIClasses *ai) {
+	this-&gt;ai = ai;
+}
+CDefenseMatrix::~CDefenseMatrix() {
+}
+
+void CDefenseMatrix::PostLoad() {
+	spotFinder = new CSpotFinder(ai, ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
+	spotFinder-&gt;SetBackingArray(&amp;ChokePointArray.front(), ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
+}
+
+
+void CDefenseMatrix::Init() {
+	ChokePointArray.resize(ai-&gt;pather-&gt;totalcells);
+	// temp only, will be used to mask bad spots that workers can't build at
+	BuildMaskArray.resize(ai-&gt;pather-&gt;totalcells,0);
+
+	ai-&gt;pather-&gt;CreateDefenseMatrix();
+
+	spotFinder = new CSpotFinder(ai, ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
+	spotFinder-&gt;SetBackingArray(&amp;ChokePointArray.front(), ai-&gt;pather-&gt;PathMapYSize, ai-&gt;pather-&gt;PathMapXSize);
+}
+
+void CDefenseMatrix::MaskBadBuildSpot(float3 pos) {
+	int f3multiplier = 8 * THREATRES;
+	int x = (int) (pos.x / f3multiplier);
+	int y = (int) (pos.z / f3multiplier);
+
+	BuildMaskArray[y * ai-&gt;pather-&gt;PathMapXSize + x] = 1;
+}
+
+float3 CDefenseMatrix::GetDefensePos(const UnitDef* def, float3 builderpos) {
+	ai-&gt;ut-&gt;UpdateChokePointArray();
+	int f3multiplier = 8 * THREATRES;
+	int Range = int(ai-&gt;ut-&gt;GetMaxRange(def) / f3multiplier);
+	int bestspotx = 0;
+	int bestspoty = 0;
+	float averagemapsize = sqrt(float(ai-&gt;pather-&gt;PathMapXSize * ai-&gt;pather-&gt;PathMapYSize)) * f3multiplier;
+	float bestscore_fast = 0.0f;
+	int bestspotx_fast = 0;
+	int bestspoty_fast = 0;
+	ai-&gt;math-&gt;TimerStart();
+
+	spotFinder-&gt;SetRadius(Range);
+	float* sumMap = spotFinder-&gt;GetSumMap();
+
+	// hack to find a good start
+	{
+		int x = (int) (builderpos.x / f3multiplier);
+		int y = (int) (builderpos.z / f3multiplier);
+		float fastSumMap = sumMap[y * ai-&gt;pather-&gt;PathMapXSize + x];
+		float3 spotpos = float3(x * f3multiplier, 0, y * f3multiplier);
+		float myscore = fastSumMap / (builderpos.distance2D(spotpos) + averagemapsize / 8) * ((ai-&gt;pather-&gt;HeightMap[y * ai-&gt;pather-&gt;PathMapXSize + x] + 200) / (ai-&gt;pather-&gt;AverageHeight + 10)) / (ai-&gt;tm-&gt;ThreatAtThisPoint(spotpos) + 0.01);
+		bestscore_fast = myscore;
+		bestspotx_fast = x;
+		bestspoty_fast = y;
+	}
+
+	int skipCount = 0;
+	int testCount = 0;
+
+	for (int x = 0; x &lt; ai-&gt;pather-&gt;PathMapXSize / CACHEFACTOR; x++) {
+		for (int y = 0; y &lt; ai-&gt;pather-&gt;PathMapYSize / CACHEFACTOR; y++) {
+			// KLOOTNOTE: SOMETIMES RETURNS UNINITIALIZED CRAP?
+			// (gdb) print cachePoint-&gt;y   $2 = 219024104
+			// (gdb) print cachePoint-&gt;x   $3 = -1215908928
+			CachePoint* cachePoint = spotFinder-&gt;GetBestCachePoint(x, y);
+
+			if (!cachePoint) {
+				return ZeroVector;
+			}
+
+			float bestScoreInThisBox = cachePoint-&gt;maxValueInBox;
+
+			// guess that this point is as good as posible
+			// make best posible build spot (nearest to builder)
+			float bestX = builderpos.x / f3multiplier;
+			float bestY = builderpos.z / f3multiplier;
+
+			if (bestX &gt; x * CACHEFACTOR) {
+				if (bestX &gt; (x * CACHEFACTOR + CACHEFACTOR)) {
+					bestX = x * CACHEFACTOR + CACHEFACTOR;
+				}
+			}
+			else {
+				bestX = x * CACHEFACTOR;
+			}
+
+			if (bestY &gt; y * CACHEFACTOR) {
+				if (bestY &gt; (y * CACHEFACTOR + CACHEFACTOR)) {
+					bestY = y * CACHEFACTOR + CACHEFACTOR;
+				}
+			}
+			else {
+				bestY = y * CACHEFACTOR;
+			}
+
+			float3 bestPosibleSpotpos = float3(bestX * f3multiplier, 0, bestY * f3multiplier);
+ 			// this must be guessed, set it to the best possible (slow)
+			float bestThreatAtThisPoint = 0.01 + ai-&gt;tm-&gt;GetAverageThreat() - 1;
+			float bestDistance = builderpos.distance2D(bestPosibleSpotpos);
+			float bestHeight = ai-&gt;pather-&gt;HeightMap[cachePoint-&gt;y * ai-&gt;pather-&gt;PathMapXSize + cachePoint-&gt;x] + 200;
+			float bestPosibleMyScore = bestScoreInThisBox / (bestDistance + averagemapsize / 4) * (bestHeight + 200) / bestThreatAtThisPoint;
+			// have a best posible score for all points inside the size of the cache box
+			// if this is better than the current known best, test if any point inside the box is better
+
+			if (bestPosibleMyScore &gt; bestscore_fast) {
+				testCount++;
+				// must test all the points inside this box
+				for (int sx = x * CACHEFACTOR; sx &lt; ai-&gt;pather-&gt;PathMapXSize &amp;&amp; sx &lt; (x * CACHEFACTOR + CACHEFACTOR); sx++) {
+					for (int sy = y * CACHEFACTOR; sy &lt; ai-&gt;pather-&gt;PathMapYSize &amp;&amp; sy &lt; (y * CACHEFACTOR + CACHEFACTOR); sy++) {
+						float fastSumMap = sumMap[sy * ai-&gt;pather-&gt;PathMapXSize + sx];
+						float3 spotpos = float3(sx * f3multiplier, 0, sy * f3multiplier);
+						float myscore = fastSumMap / (builderpos.distance2D(spotpos) + averagemapsize / 4) * (ai-&gt;pather-&gt;HeightMap[sy * ai-&gt;pather-&gt;PathMapXSize + sx]+200) / (ai-&gt;tm-&gt;ThreatAtThisPoint(spotpos) + 0.01);
+						// THIS COULD BE REALLY SLOW!
+						if (myscore &gt; bestscore_fast &amp;&amp; BuildMaskArray[sy * ai-&gt;pather-&gt;PathMapXSize + sx] == 0 &amp;&amp; ai-&gt;cb-&gt;CanBuildAt(def, spotpos)) {
+							bestscore_fast = myscore;
+							bestspotx_fast = sx;
+							bestspoty_fast = sy;
+						}
+					}
+				}
+			}
+			else {
+				// skip box
+				skipCount++;
+			}
+		}
+	}
+
+	bestspotx = bestspotx_fast;
+	bestspoty = bestspoty_fast;
+
+	return float3(bestspotx * f3multiplier, 0, bestspoty * f3multiplier);
+}
+
+
+
+void CDefenseMatrix::AddDefense(float3 pos, const UnitDef* def) {
+	int f3multiplier = 8 * THREATRES;
+	int Range = int(ai-&gt;ut-&gt;GetMaxRange(def) / f3multiplier);
+	int squarerange = Range * Range;
+	int x, y;
+	ai-&gt;math-&gt;F32XY(pos, &amp;x, &amp;y, 8);
+
+	// TODO: test if this works
+	for (int myx = x - Range; myx &lt;= x + Range; myx++) {
+		if (myx &gt;= 0 &amp;&amp; myx &lt; ai-&gt;pather-&gt;PathMapXSize) {
+			for (int myy = y - Range; myy &lt;= y + Range; myy++) {
+				int distance = int((x - myx) * (x - myx) + (y - myy) * (y - myy) - 0.5);
+				if (myy &gt;= 0 &amp;&amp; myy &lt; ai-&gt;pather-&gt;PathMapYSize &amp;&amp; (distance) &lt;= squarerange) {
+					for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes;i++) {
+						ChokeMapsByMovetype[i][myy * ai-&gt;pather-&gt;PathMapXSize + myx] /= 2;
+					}
+				}
+			}
+		}
+	}
+
+	spotFinder-&gt;InvalidateSumMap(x, y, Range + 1);
+	// ai-&gt;debug-&gt;MakeBWTGA(Chokepointmap, ai-&gt;tm-&gt;ThreatMapWidth, ai-&gt;tm-&gt;ThreatMapHeight, &quot;DebugPathMatrix&quot;, 1);
+}
+
+
+void CDefenseMatrix::RemoveDefense(float3 pos, const UnitDef* def) {
+	int f3multiplier = 8 * THREATRES;
+	int Range = int(ai-&gt;ut-&gt;GetMaxRange(def) / f3multiplier);
+	int squarerange = Range * Range;
+	int x, y;
+	ai-&gt;math-&gt;F32XY(pos, &amp;x, &amp;y, 8);
+
+	// TODO: test if this works
+	for (int myx = x - Range; myx &lt;= x + Range; myx++) {
+		if (myx &gt;= 0 &amp;&amp; myx &lt; ai-&gt;pather-&gt;PathMapXSize) {
+			for (int myy = y - Range; myy &lt;= y + Range; myy++) {
+				int distance = int((x - myx) * (x - myx) + (y - myy) * (y - myy) - 0.5);
+
+				if (myy &gt;= 0 &amp;&amp; myy &lt; ai-&gt;pather-&gt;PathMapYSize &amp;&amp; (distance) &lt;= squarerange) {
+					for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes;i++) {
+						ChokeMapsByMovetype[i][myy * ai-&gt;pather-&gt;PathMapXSize + myx] *= 2;
+					}
+				}
+			}
+		}
+	}
+
+	spotFinder-&gt;InvalidateSumMap(x, y, Range);
+}

Modified: trunk/AI/Global/KAIK-0.13/Defines.h
===================================================================
--- trunk/AI/Global/KAIK-0.13/Defines.h	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/Defines.h	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1,109 +1,110 @@
-#ifndef DEFINES_H
-#define DEFINES_H
-
-#define AI_NAME			&quot;KAIK 0.13 Unofficial&quot;
-#define AI_DATE			&quot;20/10/2008&quot;
-#define AI_VERSION		AI_NAME &quot; (rev. &quot; AI_DATE &quot;)&quot;
-#define AI_CREDITS		&quot;(original developer: Krogothe, current maintainer: Kloot)&quot;
-
-// Logger
-#define L(a)			(*ai-&gt;LOGGER &lt;&lt; a &lt;&lt; std::endl)
-#define LN(a)			(*ai-&gt;LOGGER &lt;&lt; a)
-
-// Shortcuts
-#define GCAT(a)			(ai-&gt;ut-&gt;GetCategory(a))
-#define GUG(a)			(ai-&gt;MyUnits[a]-&gt;groupID)
-
-// RNGs
-#define RANDINT			ai-&gt;math-&gt;RandInt()
-#define RANDFLOAT		ai-&gt;math-&gt;MTRandFloat()
-
-// Timer
-#define TIMER_START		ai-&gt;math-&gt;TimerStart()
-#define TIMER_TICKS		ai-&gt;math-&gt;TimerTicks()
-#define TIMER_SECS		ai-&gt;math-&gt;TimerSecs()
-
-// Folders
-#define ROOTFOLDER		&quot;AI/KAIK013/&quot;
-
-#define LOGFOLDER		ROOTFOLDER&quot;Logs/&quot;
-#define METALFOLDER		ROOTFOLDER&quot;Metal/&quot;
-#define TGAFOLDER		ROOTFOLDER&quot;TGAs/&quot;
-#define CFGFOLDER		ROOTFOLDER&quot;CFGs/&quot;
-
-// Error outputs
-#define ZEROVECTOR		float3( 0, 0, 0)
-#define ERRORVECTOR		float3(-1, 0, 0)
-
-// Maths
-#define DEG2RAD			0.01745329252f
-#define RAD2DEG			57.2957795f
-
-
-// Unit Categories
-enum {
-	CAT_COMM, CAT_ENERGY, CAT_MEX, CAT_MMAKER,
-	CAT_BUILDER, CAT_ESTOR, CAT_MSTOR, CAT_FACTORY,
-	CAT_DEFENCE, CAT_G_ATTACK, CAT_NUKE, /* CAT_SHIELD, */
-	LASTCATEGORY
-};
-
-
-
-// Map sizing multipliers
-#define METALMAP2MAPUNIT		 2
-#define MAPUNIT2POS				 8
-#define METALMAP2POS			16
-
-// Threatmap / pathfinder resolution
-#define THREATRES				8
-
-// Maximum Builders helping each factory
-#define MAXBUILDERSPERFACTORY	2
-#define BUILDERFACTORYCOSTRATIO	0.5
-// #define DEFENSEFACTORYRATIO		5
-#define DEFENSEFACTORYRATIO		4
-
-// Metal to energy ratio for cost calculations
-#define METAL2ENERGY			45
-
-// Minimum stocks for a &quot;feasible&quot; construction (ratio of storage)
-#define FEASIBLEMSTORRATIO		0.3
-#define FEASIBLEESTORRATIO		0.6
-
-// Time idle units stay in limbo mode (in frames)
-#define LIMBOTIME				40
-// Income multiplier for tech tree advancement
-#define INCOMEMULTIPLIER		5
-// Seconds of storage to be had
-#define STORAGETIME				6
-// Think that your econ is this much for factory feasible
-#define ECONRATIO				0.85
-// Hacky stuff: use only one movetype
-#define PATHTOUSE				ai-&gt;pather-&gt;NumOfMoveTypes - 1
-
-// ClosestBuildsite Stuff
-#define DEFCBS_SEPARATION		8
-#define DEFCBS_RADIUS			2000
-
-// Command lag acceptance 5 sec (30 * 5)
-#define LAG_ACCEPTANCE			150
-
-// SpotFinder stuff
-#define CACHEFACTOR				8
-
-
-// hub build-placement stuff
-#define QUADRANT_TOP_LEFT	0
-#define QUADRANT_TOP_RIGHT	1
-#define QUADRANT_BOT_RIGHT	2
-#define QUADRANT_BOT_LEFT	3
-#define FACING_DOWN			0
-#define FACING_RIGHT		1
-#define FACING_UP			2
-#define FACING_LEFT			3
-
-#define MAX_NUKE_SILOS		16
-
-
-#endif
+#ifndef DEFINES_H
+#define DEFINES_H
+
+#define AI_VERSION_NUMBER &quot;0.13&quot;
+#define AI_NAME			std::string(&quot;KAIK &quot;) + AI_VERSION_NUMBER + &quot; Unofficial&quot;
+#define AI_DATE			&quot;20/10/2008&quot;
+#define AI_VERSION		AI_NAME + &quot; (rev. &quot; + AI_DATE + &quot;)&quot;
+#define AI_CREDITS		&quot;(original developer: Krogothe, current maintainer: Kloot)&quot;
+
+// Logger
+#define L(a)			(*ai-&gt;LOGGER &lt;&lt; a &lt;&lt; std::endl)
+#define LN(a)			(*ai-&gt;LOGGER &lt;&lt; a)
+
+// Shortcuts
+#define GCAT(a)			(ai-&gt;ut-&gt;GetCategory(a))
+#define GUG(a)			(ai-&gt;MyUnits[a]-&gt;groupID)
+
+// RNGs
+#define RANDINT			ai-&gt;math-&gt;RandInt()
+#define RANDFLOAT		ai-&gt;math-&gt;MTRandFloat()
+
+// Timer
+#define TIMER_START		ai-&gt;math-&gt;TimerStart()
+#define TIMER_TICKS		ai-&gt;math-&gt;TimerTicks()
+#define TIMER_SECS		ai-&gt;math-&gt;TimerSecs()
+
+// Folders
+#define ROOTFOLDER		&quot;AI/KAIK013/&quot;
+
+#define LOGFOLDER		std::string(ROOTFOLDER) + &quot;Logs/&quot;
+#define METALFOLDER		std::string(ROOTFOLDER) + &quot;Metal/&quot;
+#define TGAFOLDER		std::string(ROOTFOLDER) + &quot;TGAs/&quot;
+#define CFGFOLDER		std::string(ROOTFOLDER) + &quot;CFGs/&quot;
+
+// Error outputs
+#define ZEROVECTOR		float3( 0, 0, 0)
+#define ERRORVECTOR		float3(-1, 0, 0)
+
+// Maths
+#define DEG2RAD			0.01745329252f
+#define RAD2DEG			57.2957795f
+
+
+// Unit Categories
+enum {
+	CAT_COMM, CAT_ENERGY, CAT_MEX, CAT_MMAKER,
+	CAT_BUILDER, CAT_ESTOR, CAT_MSTOR, CAT_FACTORY,
+	CAT_DEFENCE, CAT_G_ATTACK, CAT_NUKE, /* CAT_SHIELD, */
+	LASTCATEGORY
+};
+
+
+
+// Map sizing multipliers
+#define METALMAP2MAPUNIT		 2
+#define MAPUNIT2POS				 8
+#define METALMAP2POS			16
+
+// Threatmap / pathfinder resolution
+#define THREATRES				8
+
+// Maximum Builders helping each factory
+#define MAXBUILDERSPERFACTORY	2
+#define BUILDERFACTORYCOSTRATIO	0.5
+// #define DEFENSEFACTORYRATIO		5
+#define DEFENSEFACTORYRATIO		4
+
+// Metal to energy ratio for cost calculations
+#define METAL2ENERGY			45
+
+// Minimum stocks for a &quot;feasible&quot; construction (ratio of storage)
+#define FEASIBLEMSTORRATIO		0.3
+#define FEASIBLEESTORRATIO		0.6
+
+// Time idle units stay in limbo mode (in frames)
+#define LIMBOTIME				40
+// Income multiplier for tech tree advancement
+#define INCOMEMULTIPLIER		5
+// Seconds of storage to be had
+#define STORAGETIME				6
+// Think that your econ is this much for factory feasible
+#define ECONRATIO				0.85
+// Hacky stuff: use only one movetype
+#define PATHTOUSE				ai-&gt;pather-&gt;NumOfMoveTypes - 1
+
+// ClosestBuildsite Stuff
+#define DEFCBS_SEPARATION		8
+#define DEFCBS_RADIUS			2000
+
+// Command lag acceptance 5 sec (30 * 5)
+#define LAG_ACCEPTANCE			150
+
+// SpotFinder stuff
+#define CACHEFACTOR				8
+
+
+// hub build-placement stuff
+#define QUADRANT_TOP_LEFT	0
+#define QUADRANT_TOP_RIGHT	1
+#define QUADRANT_BOT_RIGHT	2
+#define QUADRANT_BOT_LEFT	3
+#define FACING_DOWN			0
+#define FACING_RIGHT		1
+#define FACING_UP			2
+#define FACING_LEFT			3
+
+#define MAX_NUKE_SILOS		16
+
+
+#endif

Modified: trunk/AI/Global/KAIK-0.13/GlobalAI.cpp
===================================================================
--- trunk/AI/Global/KAIK-0.13/GlobalAI.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/GlobalAI.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1,441 +1,445 @@
-#include &quot;GlobalAI.h&quot;
-#include &quot;Unit.h&quot;
-
-
-
-// TODO: move to GlobalAI.h
-CR_BIND(CGlobalAI, );
-CR_REG_METADATA(CGlobalAI, (
-	CR_SERIALIZER(Serialize),
-	CR_POSTLOAD(PostLoad)
-));
-
-
-
-// TODO: move to Containers.h
-CR_BIND(AIClasses, );
-CR_REG_METADATA(AIClasses, (
-	CR_MEMBER(econTracker),
-	CR_MEMBER(bu),
-	CR_MEMBER(tm),
-	CR_MEMBER(uh),
-	CR_MEMBER(dm),
-	CR_MEMBER(ah),
-	CR_MEMBER(dgunController),
-	CR_RESERVED(16)
-));
-
-// TODO: move to Containers.h
-CR_BIND(integer2, );
-CR_REG_METADATA(integer2, (
-	CR_MEMBER(x),
-	CR_MEMBER(y)
-));
-
-// TODO: move to Containers.h
-CR_BIND(BuilderTracker, );
-CR_REG_METADATA(BuilderTracker, (
-	CR_MEMBER(builderID),
-	CR_MEMBER(buildTaskId),
-	CR_MEMBER(taskPlanId),
-	CR_MEMBER(factoryId),
-	CR_MEMBER(customOrderId),
-	CR_MEMBER(stuckCount),
-	CR_MEMBER(idleStartFrame),
-	CR_MEMBER(commandOrderPushFrame),
-	CR_MEMBER(categoryMaker),
-	CR_MEMBER(estimateRealStartFrame),
-	CR_MEMBER(estimateFramesForNanoBuildActivation),
-	CR_MEMBER(estimateETAforMoveingToBuildSite),
-	CR_MEMBER(distanceToSiteBeforeItCanStartBuilding),
-	CR_RESERVED(16)
-));
-
-// TODO: move to Containers.h
-CR_BIND(BuildTask, );
-CR_REG_METADATA(BuildTask, (
-	CR_MEMBER(id),
-	CR_MEMBER(category),
-	CR_MEMBER(builders),
-	CR_MEMBER(builderTrackers),
-	CR_MEMBER(currentBuildPower),
-	// CR_MEMBER(def),
-	CR_MEMBER(pos),
-	CR_RESERVED(16),
-	CR_POSTLOAD(PostLoad)
-));
-
-// TODO: move to Containers.h
-CR_BIND(TaskPlan, );
-CR_REG_METADATA(TaskPlan, (
-	CR_MEMBER(id),
-	CR_MEMBER(builders),
-	CR_MEMBER(builderTrackers),
-	CR_MEMBER(currentBuildPower),
-	// CR_MEMBER(def),
-	CR_MEMBER(defName),
-	CR_MEMBER(pos),
-	CR_RESERVED(8),
-	CR_POSTLOAD(PostLoad)
-));
-
-// TODO: move to Containers.h
-CR_BIND(Factory, );
-CR_REG_METADATA(Factory, (
-	CR_MEMBER(id),
-	CR_MEMBER(supportbuilders),
-	CR_MEMBER(supportBuilderTrackers),
-	CR_RESERVED(8)
-));
-
-// TODO: move to Containers.h
-CR_BIND(NukeSilo, );
-CR_REG_METADATA(NukeSilo, (
-	CR_MEMBER(id),
-	CR_MEMBER(numNukesReady),
-	CR_MEMBER(numNukesQueued),
-	CR_RESERVED(8)
-));
-
-// TODO: move to Containers.h
-CR_BIND(MetalExtractor, );
-CR_REG_METADATA(MetalExtractor, (
-	CR_MEMBER(id),
-	CR_MEMBER(buildFrame),
-	CR_RESERVED(8)
-));
-
-
-
-CREX_REG_STATE_COLLECTOR(KAIK, CGlobalAI);
-
-
-// TODO: move to Containers.h
-void BuildTask::PostLoad(void) { def = KAIKState-&gt;ai-&gt;cb-&gt;GetUnitDef(id); }
-void TaskPlan::PostLoad(void) { def = KAIKState-&gt;ai-&gt;cb-&gt;GetUnitDef(defName.c_str()); }
-void EconomyUnitTracker::PostLoad() { unitDef = KAIKState-&gt;ai-&gt;cb-&gt;GetUnitDef(economyUnitId); }
-
-
-
-
-
-
-
-CGlobalAI::CGlobalAI() {
-}
-
-CGlobalAI::~CGlobalAI() {
-	for (int i = 0; i &lt; MAX_UNITS; i++) {
-		delete ai-&gt;MyUnits[i]; ai-&gt;MyUnits[i] = 0x0;
-	}
-
-	delete ai-&gt;LOGGER;
-	delete ai-&gt;ah;
-	delete ai-&gt;bu;
-	delete ai-&gt;econTracker;
-	delete ai-&gt;parser;
-	delete ai-&gt;math;
-	delete ai-&gt;debug;
-	delete ai-&gt;pather;
-	delete ai-&gt;tm;
-	delete ai-&gt;ut;
-	delete ai-&gt;mm;
-	delete ai-&gt;uh;
-	delete ai-&gt;dgunController;
-	delete ai;
-}
-
-
-
-
-
-// called instead of InitAI() on load if IsLoadSupported() returns 1
-void CGlobalAI::Load(IGlobalAICallback* callback, std::istream* ifs) {
-	ai = new AIClasses;
-	ai-&gt;cb = callback-&gt;GetAICallback();
-	ai-&gt;cheat = callback-&gt;GetCheatInterface();
-
-	// initialize log filename
-	string mapname = string(callback-&gt;GetAICallback()-&gt;GetMapName());
-	mapname.resize(mapname.size() - 4);
-
-	time_t now1;
-	time(&amp;now1);
-	struct tm* now2 = localtime(&amp;now1);
-
-	int team = ai-&gt;cb-&gt;GetMyTeam();
-
-	sprintf(c, &quot;%s%s %2.2d-%2.2d-%4.4d %2.2d%2.2d (team %d).log&quot;,
-		string(LOGFOLDER).c_str(), mapname.c_str(), now2-&gt;tm_mon + 1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour, now2-&gt;tm_min, team);
-
-	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, CFGFOLDER);
-
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, this-&gt;c);
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, cfgFolder);
-	ai-&gt;LOGGER = new std::ofstream(this-&gt;c);
-
-	CREX_SC_LOAD(KAIK, ifs);
-}
-
-void CGlobalAI::Save(std::ostream* ofs) {
-	CREX_SC_SAVE(KAIK, ofs);
-}
-
-
-
-void CGlobalAI::PostLoad(void) {
-	// init non-serialized objects after Load()
-	ai-&gt;debug	= new CDebug(ai);
-	ai-&gt;math	= new CMaths(ai);
-	ai-&gt;parser	= new CSunParser(ai);
-	ai-&gt;ut		= new CUnitTable(ai);
-	ai-&gt;mm		= new CMetalMap(ai);
-	ai-&gt;pather	= new CPathFinder(ai);
-	ai-&gt;em		= new CEconomyManager(ai);
-
-	ai-&gt;mm-&gt;Init();
-	ai-&gt;ut-&gt;Init();
-	ai-&gt;pather-&gt;Init();
-}
-
-void CGlobalAI::Serialize(creg::ISerializer* s) {
-	if (!s-&gt;IsWriting()) {
-		// if de-serializing a saved state, allocate
-		// here instead of in InitAI() which we skip
-		ai-&gt;MyUnits.resize(MAX_UNITS, new CUNIT(ai));
-	}
-
-	for (int i = 0; i &lt; MAX_UNITS; i++) {
-		if (ai-&gt;cheat-&gt;GetUnitDef(i)) {
-			// do not save non-existing units
-			s-&gt;SerializeObjectInstance(ai-&gt;MyUnits[i], ai-&gt;MyUnits[i]-&gt;GetClass());
-			if (!s-&gt;IsWriting()) {
-				ai-&gt;MyUnits[i]-&gt;myid = i;
-			}
-		} else if (!s-&gt;IsWriting()) {
-			ai-&gt;MyUnits[i]-&gt;myid = i;
-			ai-&gt;MyUnits[i]-&gt;groupID = -1;
-		}
-	}
-
-	s-&gt;SerializeObjectInstance(ai, ai-&gt;GetClass());
-}
-
-
-
-
-
-
-void CGlobalAI::InitAI(IGlobalAICallback* callback, int team) {
-	// initialize log filename
-	string mapname = string(callback-&gt;GetAICallback()-&gt;GetMapName());
-	mapname.resize(mapname.size() - 4);
-
-	time_t now1;
-	time(&amp;now1);
-	struct tm* now2 = localtime(&amp;now1);
-
-	// timestamp logfile name
-	sprintf(this-&gt;c, &quot;%s%s %2.2d-%2.2d-%4.4d %2.2d%2.2d (team %d).log&quot;,
-		string(LOGFOLDER).c_str(), mapname.c_str(), (now2-&gt;tm_mon + 1), now2-&gt;tm_mday, (now2-&gt;tm_year + 1900), now2-&gt;tm_hour, now2-&gt;tm_min, team);
-
-	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, CFGFOLDER);
-
-	// initialize class wrapper struct
-	ai = new AIClasses;
-	ai-&gt;cb = callback-&gt;GetAICallback();
-	ai-&gt;cheat = callback-&gt;GetCheatInterface();
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, this-&gt;c);
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, cfgFolder);
-
-
-	ai-&gt;MyUnits.resize(MAX_UNITS, 0x0);
-
-	// initialize MAX_UNITS CUNIT objects
-	for (int i = 0; i &lt; MAX_UNITS; i++) {
-		ai-&gt;MyUnits[i] = new CUNIT(ai);
-		ai-&gt;MyUnits[i]-&gt;myid = i;
-		ai-&gt;MyUnits[i]-&gt;groupID = -1;
-	}
-
-
-	ai-&gt;debug			= new CDebug(ai);
-	ai-&gt;math			= new CMaths(ai);
-	ai-&gt;LOGGER			= new std::ofstream(this-&gt;c);
-	ai-&gt;parser			= new CSunParser(ai);
-	ai-&gt;ut				= new CUnitTable(ai);
-	ai-&gt;mm				= new CMetalMap(ai);
-	ai-&gt;pather			= new CPathFinder(ai);
-	ai-&gt;tm				= new CThreatMap(ai);
-	ai-&gt;uh				= new CUnitHandler(ai);
-	ai-&gt;dm				= new CDefenseMatrix(ai);
-	ai-&gt;econTracker		= new CEconomyTracker(ai);
-	ai-&gt;bu				= new CBuildUp(ai);
-	ai-&gt;ah				= new CAttackHandler(ai);
-	ai-&gt;dgunController	= new DGunController(ai);
-
-	ai-&gt;mm-&gt;Init();
-	ai-&gt;ut-&gt;Init();
-	ai-&gt;pather-&gt;Init();
-
-	ai-&gt;cb-&gt;SendTextMsg(AI_VERSION &quot; initialized succesfully!&quot;, 0);
-	ai-&gt;cb-&gt;SendTextMsg(AI_CREDITS, 0);
-}
-
-
-void CGlobalAI::UnitCreated(int unitID) {
-	ai-&gt;uh-&gt;UnitCreated(unitID);
-	ai-&gt;econTracker-&gt;UnitCreated(unitID);
-}
-
-void CGlobalAI::UnitFinished(int unit) {
-	ai-&gt;econTracker-&gt;UnitFinished(unit);
-	int frame = ai-&gt;cb-&gt;GetCurrentFrame();
-	const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(unit);
-
-	if (udef) {
-		// let attackhandler handle cat_g_attack units
-		if (GCAT(unit) == CAT_G_ATTACK) {
-			ai-&gt;ah-&gt;AddUnit(unit);
-		} else {
-			ai-&gt;uh-&gt;IdleUnitAdd(unit, frame);
-		}
-
-		ai-&gt;uh-&gt;BuildTaskRemove(unit);
-	}
-}
-
-void CGlobalAI::UnitDestroyed(int unit, int attacker) {
-	attacker = attacker;
-	ai-&gt;econTracker-&gt;UnitDestroyed(unit);
-
-	if (GUG(unit) != -1) {
-		ai-&gt;ah-&gt;UnitDestroyed(unit);
-	}
-
-	ai-&gt;uh-&gt;UnitDestroyed(unit);
-}
-
-void CGlobalAI::UnitIdle(int unit) {
-	if (ai-&gt;uh-&gt;lastCapturedUnitFrame == ai-&gt;cb-&gt;GetCurrentFrame()) {
-		if (unit == ai-&gt;uh-&gt;lastCapturedUnitID) {
-			// KLOOTNOTE: for some reason this also gets called when one
-			// of our units is captured (in the same frame as, but after
-			// HandleEvent(AI_EVENT_UNITCAPTURED)), *before* the unit has
-			// actually changed teams (ie. for any unit that is no longer
-			// on our team but still registers as such)
-			ai-&gt;uh-&gt;lastCapturedUnitFrame = -1;
-			ai-&gt;uh-&gt;lastCapturedUnitID = -1;
-			return;
-		}
-	}
-
-	// AttackHandler handles cat_g_attack units
-	if (GCAT(unit) == CAT_G_ATTACK &amp;&amp; ai-&gt;MyUnits[unit]-&gt;groupID != -1) {
-		// attackHandler-&gt;UnitIdle(unit);
-	} else {
-		ai-&gt;uh-&gt;IdleUnitAdd(unit, ai-&gt;cb-&gt;GetCurrentFrame());
-	}
-}
-
-void CGlobalAI::UnitDamaged(int damaged, int attacker, float damage, float3 dir) {
-	attacker = attacker;
-	dir = dir;
-	ai-&gt;econTracker-&gt;UnitDamaged(damaged, damage);
-}
-
-void CGlobalAI::UnitMoveFailed(int unit) {
-	unit = unit;
-}
-
-
-
-void CGlobalAI::EnemyEnterLOS(int enemy) {
-	enemy = enemy;
-}
-
-void CGlobalAI::EnemyLeaveLOS(int enemy) {
-	enemy = enemy;
-}
-
-void CGlobalAI::EnemyEnterRadar(int enemy) {
-	enemy = enemy;
-}
-
-void CGlobalAI::EnemyLeaveRadar(int enemy) {
-	enemy = enemy;
-}
-
-void CGlobalAI::EnemyDestroyed(int enemy, int attacker) {
-	ai-&gt;dgunController-&gt;handleDestroyEvent(attacker, enemy);
-}
-
-void CGlobalAI::EnemyDamaged(int damaged, int attacker, float damage, float3 dir) {
-	damaged = damaged;
-	attacker = attacker;
-	damage = damage;
-	dir = dir;
-}
-
-
-
-void CGlobalAI::GotChatMsg(const char* msg, int player) {
-	msg = msg;
-	player = player;
-}
-
-
-int CGlobalAI::HandleEvent(int msg, const void* data) {
-	switch (msg) {
-		case AI_EVENT_UNITGIVEN: {
-			const ChangeTeamEvent* cte = (const ChangeTeamEvent*) data;
-
-			if ((cte-&gt;newteam) == (ai-&gt;cb-&gt;GetMyTeam())) {
-				// got a unit
-				UnitCreated(cte-&gt;unit);
-				UnitFinished(cte-&gt;unit);
-				ai-&gt;uh-&gt;IdleUnitAdd(cte-&gt;unit, ai-&gt;cb-&gt;GetCurrentFrame());
-			}
-		} break;
-		case AI_EVENT_UNITCAPTURED: {
-			const ChangeTeamEvent* cte = (const ChangeTeamEvent*) data;
-
-			if ((cte-&gt;oldteam) == (ai-&gt;cb-&gt;GetMyTeam())) {
-				// lost a unit
-				UnitDestroyed(cte-&gt;unit, 0);
-
-				// FIXME: multiple units captured during same frame?
-				ai-&gt;uh-&gt;lastCapturedUnitFrame = ai-&gt;cb-&gt;GetCurrentFrame();
-				ai-&gt;uh-&gt;lastCapturedUnitID = cte-&gt;unit;
-			}
-		} break;
-	}
-
-	return 0;
-}
-
-
-
-
-void CGlobalAI::Update() {
-	int frame = ai-&gt;cb-&gt;GetCurrentFrame();
-
-	// call economy tracker update routine
-	ai-&gt;econTracker-&gt;frameUpdate(frame);
-
-	if (frame == 1) {
-		// init defense matrix
-		ai-&gt;dm-&gt;Init();
-	}
-	if (frame &gt; 60) {
-		// call buildup manager and unit handler (idle) update routine
-		ai-&gt;bu-&gt;Update(frame);
-		ai-&gt;uh-&gt;IdleUnitUpdate(frame);
-	}
-
-	ai-&gt;dgunController-&gt;update(frame);
-
-	// call attack handler and unit handler (metal maker) update routines
-	ai-&gt;ah-&gt;Update(frame);
-	ai-&gt;uh-&gt;MMakerUpdate(frame);
-}
+#include &quot;GlobalAI.h&quot;
+#include &quot;Unit.h&quot;
+
+
+
+// TODO: move to GlobalAI.h
+CR_BIND(CGlobalAI, );
+CR_REG_METADATA(CGlobalAI, (
+	CR_SERIALIZER(Serialize),
+	CR_POSTLOAD(PostLoad)
+));
+
+
+
+// TODO: move to Containers.h
+CR_BIND(AIClasses, );
+CR_REG_METADATA(AIClasses, (
+	CR_MEMBER(econTracker),
+	CR_MEMBER(bu),
+	CR_MEMBER(tm),
+	CR_MEMBER(uh),
+	CR_MEMBER(dm),
+	CR_MEMBER(ah),
+	CR_MEMBER(dgunController),
+	CR_RESERVED(16)
+));
+
+// TODO: move to Containers.h
+CR_BIND(integer2, );
+CR_REG_METADATA(integer2, (
+	CR_MEMBER(x),
+	CR_MEMBER(y)
+));
+
+// TODO: move to Containers.h
+CR_BIND(BuilderTracker, );
+CR_REG_METADATA(BuilderTracker, (
+	CR_MEMBER(builderID),
+	CR_MEMBER(buildTaskId),
+	CR_MEMBER(taskPlanId),
+	CR_MEMBER(factoryId),
+	CR_MEMBER(customOrderId),
+	CR_MEMBER(stuckCount),
+	CR_MEMBER(idleStartFrame),
+	CR_MEMBER(commandOrderPushFrame),
+	CR_MEMBER(categoryMaker),
+	CR_MEMBER(estimateRealStartFrame),
+	CR_MEMBER(estimateFramesForNanoBuildActivation),
+	CR_MEMBER(estimateETAforMoveingToBuildSite),
+	CR_MEMBER(distanceToSiteBeforeItCanStartBuilding),
+	CR_RESERVED(16)
+));
+
+// TODO: move to Containers.h
+CR_BIND(BuildTask, );
+CR_REG_METADATA(BuildTask, (
+	CR_MEMBER(id),
+	CR_MEMBER(category),
+	CR_MEMBER(builders),
+	CR_MEMBER(builderTrackers),
+	CR_MEMBER(currentBuildPower),
+	// CR_MEMBER(def),
+	CR_MEMBER(pos),
+	CR_RESERVED(16),
+	CR_POSTLOAD(PostLoad)
+));
+
+// TODO: move to Containers.h
+CR_BIND(TaskPlan, );
+CR_REG_METADATA(TaskPlan, (
+	CR_MEMBER(id),
+	CR_MEMBER(builders),
+	CR_MEMBER(builderTrackers),
+	CR_MEMBER(currentBuildPower),
+	// CR_MEMBER(def),
+	CR_MEMBER(defName),
+	CR_MEMBER(pos),
+	CR_RESERVED(8),
+	CR_POSTLOAD(PostLoad)
+));
+
+// TODO: move to Containers.h
+CR_BIND(Factory, );
+CR_REG_METADATA(Factory, (
+	CR_MEMBER(id),
+	CR_MEMBER(supportbuilders),
+	CR_MEMBER(supportBuilderTrackers),
+	CR_RESERVED(8)
+));
+
+// TODO: move to Containers.h
+CR_BIND(NukeSilo, );
+CR_REG_METADATA(NukeSilo, (
+	CR_MEMBER(id),
+	CR_MEMBER(numNukesReady),
+	CR_MEMBER(numNukesQueued),
+	CR_RESERVED(8)
+));
+
+// TODO: move to Containers.h
+CR_BIND(MetalExtractor, );
+CR_REG_METADATA(MetalExtractor, (
+	CR_MEMBER(id),
+	CR_MEMBER(buildFrame),
+	CR_RESERVED(8)
+));
+
+
+
+CREX_REG_STATE_COLLECTOR(KAIK, CGlobalAI);
+
+
+// TODO: move to Containers.h
+void BuildTask::PostLoad(void) { def = KAIKState-&gt;ai-&gt;cb-&gt;GetUnitDef(id); }
+void TaskPlan::PostLoad(void) { def = KAIKState-&gt;ai-&gt;cb-&gt;GetUnitDef(defName.c_str()); }
+void EconomyUnitTracker::PostLoad() { unitDef = KAIKState-&gt;ai-&gt;cb-&gt;GetUnitDef(economyUnitId); }
+
+
+
+
+
+
+
+CGlobalAI::CGlobalAI() {
+}
+
+CGlobalAI::~CGlobalAI() {
+	for (int i = 0; i &lt; MAX_UNITS; i++) {
+		delete ai-&gt;MyUnits[i]; ai-&gt;MyUnits[i] = 0x0;
+	}
+
+	delete ai-&gt;LOGGER;
+	delete ai-&gt;ah;
+	delete ai-&gt;bu;
+	delete ai-&gt;econTracker;
+	delete ai-&gt;parser;
+	delete ai-&gt;math;
+	delete ai-&gt;debug;
+	delete ai-&gt;pather;
+	delete ai-&gt;tm;
+	delete ai-&gt;ut;
+	delete ai-&gt;mm;
+	delete ai-&gt;uh;
+	delete ai-&gt;dgunController;
+	delete ai;
+}
+
+
+
+
+
+// called instead of InitAI() on load if IsLoadSupported() returns 1
+void CGlobalAI::Load(IGlobalAICallback* callback, std::istream* ifs) {
+	ai = new AIClasses;
+	ai-&gt;cb = callback-&gt;GetAICallback();
+	ai-&gt;cheat = callback-&gt;GetCheatInterface();
+
+	// initialize log filename
+	string mapname = string(callback-&gt;GetAICallback()-&gt;GetMapName());
+	mapname.resize(mapname.size() - 4);
+
+	time_t now1;
+	time(&amp;now1);
+	struct tm* now2 = localtime(&amp;now1);
+
+	int team = ai-&gt;cb-&gt;GetMyTeam();
+
+	sprintf(c, &quot;%s%s %2.2d-%2.2d-%4.4d %2.2d%2.2d (team %d).log&quot;,
+		string(LOGFOLDER).c_str(), mapname.c_str(), now2-&gt;tm_mon + 1, now2-&gt;tm_mday, now2-&gt;tm_year + 1900, now2-&gt;tm_hour, now2-&gt;tm_min, team);
+
+	string cfgFolderStr = CFGFOLDER;
+	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, cfgFolderStr.c_str());
+
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, this-&gt;c);
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, cfgFolder);
+	ai-&gt;LOGGER = new std::ofstream(this-&gt;c);
+
+	CREX_SC_LOAD(KAIK, ifs);
+}
+
+void CGlobalAI::Save(std::ostream* ofs) {
+	CREX_SC_SAVE(KAIK, ofs);
+}
+
+
+
+void CGlobalAI::PostLoad(void) {
+	// init non-serialized objects after Load()
+	ai-&gt;debug	= new CDebug(ai);
+	ai-&gt;math	= new CMaths(ai);
+	ai-&gt;parser	= new CSunParser(ai);
+	ai-&gt;ut		= new CUnitTable(ai);
+	ai-&gt;mm		= new CMetalMap(ai);
+	ai-&gt;pather	= new CPathFinder(ai);
+	ai-&gt;em		= new CEconomyManager(ai);
+
+	ai-&gt;mm-&gt;Init();
+	ai-&gt;ut-&gt;Init();
+	ai-&gt;pather-&gt;Init();
+}
+
+void CGlobalAI::Serialize(creg::ISerializer* s) {
+	if (!s-&gt;IsWriting()) {
+		// if de-serializing a saved state, allocate
+		// here instead of in InitAI() which we skip
+		ai-&gt;MyUnits.resize(MAX_UNITS, new CUNIT(ai));
+	}
+
+	for (int i = 0; i &lt; MAX_UNITS; i++) {
+		if (ai-&gt;cheat-&gt;GetUnitDef(i)) {
+			// do not save non-existing units
+			s-&gt;SerializeObjectInstance(ai-&gt;MyUnits[i], ai-&gt;MyUnits[i]-&gt;GetClass());
+			if (!s-&gt;IsWriting()) {
+				ai-&gt;MyUnits[i]-&gt;myid = i;
+			}
+		} else if (!s-&gt;IsWriting()) {
+			ai-&gt;MyUnits[i]-&gt;myid = i;
+			ai-&gt;MyUnits[i]-&gt;groupID = -1;
+		}
+	}
+
+	s-&gt;SerializeObjectInstance(ai, ai-&gt;GetClass());
+}
+
+
+
+
+
+
+void CGlobalAI::InitAI(IGlobalAICallback* callback, int team) {
+	// initialize log filename
+	string mapname = string(callback-&gt;GetAICallback()-&gt;GetMapName());
+	mapname.resize(mapname.size() - 4);
+
+	time_t now1;
+	time(&amp;now1);
+	struct tm* now2 = localtime(&amp;now1);
+
+	// timestamp logfile name
+	string logFolder = LOGFOLDER;
+	sprintf(this-&gt;c, &quot;%s%s %2.2d-%2.2d-%4.4d %2.2d%2.2d (team %d).log&quot;,
+		logFolder.c_str(), mapname.c_str(), (now2-&gt;tm_mon + 1), now2-&gt;tm_mday, (now2-&gt;tm_year + 1900), now2-&gt;tm_hour, now2-&gt;tm_min, team);
+
+	string cfgFolderStr = CFGFOLDER;
+	char cfgFolder[256]; sprintf(cfgFolder, &quot;%s&quot;, cfgFolderStr.c_str());
+
+	// initialize class wrapper struct
+	ai = new AIClasses;
+	ai-&gt;cb = callback-&gt;GetAICallback();
+	ai-&gt;cheat = callback-&gt;GetCheatInterface();
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, this-&gt;c);
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, cfgFolder);
+
+
+	ai-&gt;MyUnits.resize(MAX_UNITS, 0x0);
+
+	// initialize MAX_UNITS CUNIT objects
+	for (int i = 0; i &lt; MAX_UNITS; i++) {
+		ai-&gt;MyUnits[i] = new CUNIT(ai);
+		ai-&gt;MyUnits[i]-&gt;myid = i;
+		ai-&gt;MyUnits[i]-&gt;groupID = -1;
+	}
+
+
+	ai-&gt;debug			= new CDebug(ai);
+	ai-&gt;math			= new CMaths(ai);
+	ai-&gt;LOGGER			= new std::ofstream(this-&gt;c);
+	ai-&gt;parser			= new CSunParser(ai);
+	ai-&gt;ut				= new CUnitTable(ai);
+	ai-&gt;mm				= new CMetalMap(ai);
+	ai-&gt;pather			= new CPathFinder(ai);
+	ai-&gt;tm				= new CThreatMap(ai);
+	ai-&gt;uh				= new CUnitHandler(ai);
+	ai-&gt;dm				= new CDefenseMatrix(ai);
+	ai-&gt;econTracker		= new CEconomyTracker(ai);
+	ai-&gt;bu				= new CBuildUp(ai);
+	ai-&gt;ah				= new CAttackHandler(ai);
+	ai-&gt;dgunController	= new DGunController(ai);
+
+	ai-&gt;mm-&gt;Init();
+	ai-&gt;ut-&gt;Init();
+	ai-&gt;pather-&gt;Init();
+
+	std::string versMsg = std::string(AI_VERSION) + &quot; initialized succesfully!&quot;;
+	ai-&gt;cb-&gt;SendTextMsg(versMsg.c_str(), 0);
+	ai-&gt;cb-&gt;SendTextMsg(AI_CREDITS, 0);
+}
+
+
+void CGlobalAI::UnitCreated(int unitID) {
+	ai-&gt;uh-&gt;UnitCreated(unitID);
+	ai-&gt;econTracker-&gt;UnitCreated(unitID);
+}
+
+void CGlobalAI::UnitFinished(int unit) {
+	ai-&gt;econTracker-&gt;UnitFinished(unit);
+	int frame = ai-&gt;cb-&gt;GetCurrentFrame();
+	const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(unit);
+
+	if (udef) {
+		// let attackhandler handle cat_g_attack units
+		if (GCAT(unit) == CAT_G_ATTACK) {
+			ai-&gt;ah-&gt;AddUnit(unit);
+		} else {
+			ai-&gt;uh-&gt;IdleUnitAdd(unit, frame);
+		}
+
+		ai-&gt;uh-&gt;BuildTaskRemove(unit);
+	}
+}
+
+void CGlobalAI::UnitDestroyed(int unit, int attacker) {
+	attacker = attacker;
+	ai-&gt;econTracker-&gt;UnitDestroyed(unit);
+
+	if (GUG(unit) != -1) {
+		ai-&gt;ah-&gt;UnitDestroyed(unit);
+	}
+
+	ai-&gt;uh-&gt;UnitDestroyed(unit);
+}
+
+void CGlobalAI::UnitIdle(int unit) {
+	if (ai-&gt;uh-&gt;lastCapturedUnitFrame == ai-&gt;cb-&gt;GetCurrentFrame()) {
+		if (unit == ai-&gt;uh-&gt;lastCapturedUnitID) {
+			// KLOOTNOTE: for some reason this also gets called when one
+			// of our units is captured (in the same frame as, but after
+			// HandleEvent(AI_EVENT_UNITCAPTURED)), *before* the unit has
+			// actually changed teams (ie. for any unit that is no longer
+			// on our team but still registers as such)
+			ai-&gt;uh-&gt;lastCapturedUnitFrame = -1;
+			ai-&gt;uh-&gt;lastCapturedUnitID = -1;
+			return;
+		}
+	}
+
+	// AttackHandler handles cat_g_attack units
+	if (GCAT(unit) == CAT_G_ATTACK &amp;&amp; ai-&gt;MyUnits[unit]-&gt;groupID != -1) {
+		// attackHandler-&gt;UnitIdle(unit);
+	} else {
+		ai-&gt;uh-&gt;IdleUnitAdd(unit, ai-&gt;cb-&gt;GetCurrentFrame());
+	}
+}
+
+void CGlobalAI::UnitDamaged(int damaged, int attacker, float damage, float3 dir) {
+	attacker = attacker;
+	dir = dir;
+	ai-&gt;econTracker-&gt;UnitDamaged(damaged, damage);
+}
+
+void CGlobalAI::UnitMoveFailed(int unit) {
+	unit = unit;
+}
+
+
+
+void CGlobalAI::EnemyEnterLOS(int enemy) {
+	enemy = enemy;
+}
+
+void CGlobalAI::EnemyLeaveLOS(int enemy) {
+	enemy = enemy;
+}
+
+void CGlobalAI::EnemyEnterRadar(int enemy) {
+	enemy = enemy;
+}
+
+void CGlobalAI::EnemyLeaveRadar(int enemy) {
+	enemy = enemy;
+}
+
+void CGlobalAI::EnemyDestroyed(int enemy, int attacker) {
+	ai-&gt;dgunController-&gt;handleDestroyEvent(attacker, enemy);
+}
+
+void CGlobalAI::EnemyDamaged(int damaged, int attacker, float damage, float3 dir) {
+	damaged = damaged;
+	attacker = attacker;
+	damage = damage;
+	dir = dir;
+}
+
+
+
+void CGlobalAI::GotChatMsg(const char* msg, int player) {
+	msg = msg;
+	player = player;
+}
+
+
+int CGlobalAI::HandleEvent(int msg, const void* data) {
+	switch (msg) {
+		case AI_EVENT_UNITGIVEN: {
+			const ChangeTeamEvent* cte = (const ChangeTeamEvent*) data;
+
+			if ((cte-&gt;newteam) == (ai-&gt;cb-&gt;GetMyTeam())) {
+				// got a unit
+				UnitCreated(cte-&gt;unit);
+				UnitFinished(cte-&gt;unit);
+				ai-&gt;uh-&gt;IdleUnitAdd(cte-&gt;unit, ai-&gt;cb-&gt;GetCurrentFrame());
+			}
+		} break;
+		case AI_EVENT_UNITCAPTURED: {
+			const ChangeTeamEvent* cte = (const ChangeTeamEvent*) data;
+
+			if ((cte-&gt;oldteam) == (ai-&gt;cb-&gt;GetMyTeam())) {
+				// lost a unit
+				UnitDestroyed(cte-&gt;unit, 0);
+
+				// FIXME: multiple units captured during same frame?
+				ai-&gt;uh-&gt;lastCapturedUnitFrame = ai-&gt;cb-&gt;GetCurrentFrame();
+				ai-&gt;uh-&gt;lastCapturedUnitID = cte-&gt;unit;
+			}
+		} break;
+	}
+
+	return 0;
+}
+
+
+
+
+void CGlobalAI::Update() {
+	int frame = ai-&gt;cb-&gt;GetCurrentFrame();
+
+	// call economy tracker update routine
+	ai-&gt;econTracker-&gt;frameUpdate(frame);
+
+	if (frame == 1) {
+		// init defense matrix
+		ai-&gt;dm-&gt;Init();
+	}
+	if (frame &gt; 60) {
+		// call buildup manager and unit handler (idle) update routine
+		ai-&gt;bu-&gt;Update(frame);
+		ai-&gt;uh-&gt;IdleUnitUpdate(frame);
+	}
+
+	ai-&gt;dgunController-&gt;update(frame);
+
+	// call attack handler and unit handler (metal maker) update routines
+	ai-&gt;ah-&gt;Update(frame);
+	ai-&gt;uh-&gt;MMakerUpdate(frame);
+}

Modified: trunk/AI/Global/KAIK-0.13/SunParser.cpp
===================================================================
--- trunk/AI/Global/KAIK-0.13/SunParser.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/SunParser.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1,424 +1,424 @@
-#include &quot;SunParser.h&quot;
-
-CSunParser::CSunParser(AIClasses* ai) {
-	this-&gt;ai = ai;
-}
-CSunParser::~CSunParser() {
-	DeleteSection(&amp;sections);
-}
-
-void CSunParser::DeleteSection(map&lt;string, SSection*&gt;* section) {
-	map&lt;string, SSection*&gt;::iterator ui;
-
-	for (ui = section-&gt;begin(); ui != section-&gt;end(); ui++) {
-		DeleteSection(&amp;ui-&gt;second-&gt;sections);
-		delete ui-&gt;second;
-	}
-}
-
-void CSunParser::LoadVirtualFile(string filename) {
-	this-&gt;filename = filename;
-	int size = ai-&gt;cb-&gt;GetFileSize(filename.c_str());
-
-	if (size == -1) {
-		return;
-	}
-
-	char* filebuf = new char[size + 1];
-	ai-&gt;cb-&gt;ReadFile(filename.c_str(), filebuf, size);
-	 // append newline at end to avoid parsing error at EOF
-	filebuf[size] = '\0';
-
-	try {
-		Parse(filebuf, size);
-	} catch(...) {
-	}
-
-	delete[] filebuf;
-}
-
-void CSunParser::LoadRealFile(string filename) {
-	char filename_buf[1024];
-	strcpy(filename_buf, filename.c_str());
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename_buf);
-
-	this-&gt;filename = filename_buf;
-	std::ifstream RealFile(filename_buf);
-
-	if (RealFile.fail()) {
-		return;
-	}
-
-	RealFile.seekg(0, std::ios_base::end);
-	int size = RealFile.tellg();
-	RealFile.seekg(0, std::ios_base::beg);
-
-	char* filebuf = new char[size + 1];
-	RealFile.get(filebuf, size, '\0');
-	RealFile.close();
-	// append newline at end to avoid parsing error at EOF
-	filebuf[size] = '\0';
-
-	try {
-		Parse(filebuf, size);
-	} catch(...) {
-	}
-
-	delete[] filebuf;
-}
-
-void CSunParser::LoadBuffer(char* buf, int size) {
-    this-&gt;filename = &quot;\'Buffer\'&quot;;
-
-	try {
-		Parse(buf,size);
-	} catch(...) {
-	}
-}
-
-void CSunParser::Parse(char* buf, int size) {
-	string thissection;
-	SSection* section = NULL;
-
-	char* endptr = buf + size;
-
-	while (buf&lt;=endptr) {
-		if (buf[0] == '/' &amp;&amp; buf[1] == '/') {
-			// comment
-			while ((buf != endptr) &amp;&amp; *buf!='\n' &amp;&amp; *buf!='\r') {
-				buf++;
-			}
-		}
-		else if (buf[0] == '/' &amp;&amp; buf[1] == '*') {
-			// comment
-			while ((buf != endptr) &amp;&amp; buf[0] != '*' || buf[1] != '/') {
-				buf++;
-			}
-		}
-		else if (*buf == '[') {
-			// sectionname
-			thissection = &quot;&quot;;
-
-			while (*(++buf) != ']') {
-				thissection += *buf;
-			}
-		}
-		else if (*buf == '{') {
-			// section
-			buf++;
-			section = new SSection;
-			transform(thissection.begin(), thissection.end(), thissection.begin(), (int (*)(int)) tolower);
-			map&lt;string, SSection*&gt;::iterator ui = sections.find(thissection);
-
-			if (ui != sections.end()) {
-				DeleteSection(&amp;ui-&gt;second-&gt;sections);
-				delete ui-&gt;second;
-			}
-			sections[thissection] = section;
-			buf = ParseSection(buf, endptr - buf, section);
-		}
-
-		// We can possible hit endptr from somewhere that increases, so don't go past it
-		if (buf &lt;= endptr)
-			buf++;
-	}
-}
-
-char* CSunParser::ParseSection(char* buf, int size, SSection* section) {
-	string thissection;
-	char* endptr = buf + size;
-
-	while (buf &lt;= endptr) {
-
-		if (buf[0] == '/' &amp;&amp; buf[1] == '/') {
-			// comment
-			while (*buf != '\n' &amp;&amp; *buf != '\r') {
-				buf++;
-			}
-		}
-
-		else if (buf[0] == '/' &amp;&amp; buf[1] == '*') {
-			// comment
-			while (buf[0] != '*' || buf[1] != '/') {
-				buf++;
-			}
-		}
-
-		else if (*buf == '[') {
-			// sectionname
-			thissection = &quot;&quot;;
-
-			while (*(++buf) != ']') {
-				thissection += *buf;
-			}
-		}
-
-		else if (*buf == '{') {
-			// section
-			buf++;
-			SSection* newsection = new SSection;
-			transform(thissection.begin(), thissection.end(), thissection.begin(), (int (*)(int)) tolower);
-			map&lt;string, SSection*&gt;::iterator ui = section-&gt;sections.find(thissection);
-
-			if (ui != section-&gt;sections.end()) {
-				DeleteSection(&amp;ui-&gt;second-&gt;sections);
-				delete ui-&gt;second;
-			}
-
-			section-&gt;sections[thissection] = newsection;
-			buf = ParseSection(buf, endptr - buf, newsection);
-		}
-
-		else if (*buf == '}') {
-			// endsection
-			// buf++;
-			return buf;
-		}
-
-		else if (*buf &gt;= '0' &amp;&amp; *buf &lt;= 'z') {
-			string name;
-			string value;
-
-			while (*buf != '=') {
-				name += *buf;
-				buf++;
-			}
-
-			buf++;
-
-			while (*buf != ';') {
-				value += *buf;
-				buf++;
-			}
-
-			transform(name.begin(), name.end(), name.begin(), (int (*)(int)) tolower);
-			section-&gt;values[name] = value;
-		}
-
-		buf++;
-	}
-
-	return buf;
-}
-
-// find value, display messagebox if no such value found
-string CSunParser::SGetValueMSG(string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	string value;
-
-	SGetValue(value, location);
-	return value;
-}
-
-// find value, return default value if no such value found
-string CSunParser::SGetValueDef(string defaultvalue, string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	string value;
-
-	bool found = SGetValue(value, location);
-
-	if (!found) {
-		value = defaultvalue;
-	}
-
-	return value;
-}
-
-
-//finds a value in the file, if not found returns false
-// errormessages is returned in value
-bool CSunParser::GetValue(string &amp;value, ...) {
-	string searchpath;
-
-	va_list loc;
-	va_start(loc, value);
-	int numargs = 0;
-
-	while (va_arg(loc, char*)) {
-		// determine number of arguments
-		numargs++;
-	}
-
-	va_start(loc, value);
-	SSection* sectionptr = 0x0;
-
-	for (int i = 0; i &lt; numargs - 1; i++) {
-		char* arg = va_arg(loc, char*);
-
-		searchpath += '\\';
-		searchpath += arg;
-		sectionptr = sections[arg];
-
-		if (sectionptr == NULL) {
-			value = &quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename;
-			return false;
-		}
-	}
-
-	char* arg = va_arg(loc, char*);
-	string svalue = sectionptr-&gt;values[arg];
-
-	searchpath += '\\';
-	searchpath += arg;
-
-	if (svalue == &quot;&quot;) {
-		value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
-		return false;
-	}
-
-	value = svalue;
-	return true;
-}
-
-void CSunParser::Test() {
-	SSection* unitinfo = sections[&quot;UNITINFO&quot;];
-	SSection* weapons = unitinfo-&gt;sections[&quot;WEAPONS&quot;];
-
-	string mo = weapons-&gt;values[&quot;weapon1&quot;];
-}
-
-
-// finds a value in the file , if not found returns false
-// errormessage is returned in value, location of value is
-// sent as a string &quot;section\section\value&quot;
-bool CSunParser::SGetValue(string &amp;value, string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	string searchpath;
-
-	//split the location string
-	vector&lt;string&gt; loclist = GetLocationVector(location);
-
-	if (sections.find(loclist[0]) == sections.end()) {
-		value = &quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename;
-		return false;
-	}
-
-	SSection* sectionptr = sections[loclist[0]];
-	searchpath = loclist[0];
-
-	for (unsigned int i = 1; i &lt; loclist.size() - 1; i++) {
-		searchpath += '\\';
-		searchpath += loclist[i];
-
-		if (sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()) {
-			value = &quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename;
-			return false;
-		}
-		sectionptr = sectionptr-&gt;sections[loclist[i]];
-	}
-
-	searchpath += '\\';
-	searchpath += loclist[loclist.size()-1];
-
-	if (sectionptr-&gt;values.find(loclist[loclist.size()-1]) == sectionptr-&gt;values.end()) {
-		value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
-
-		return false;
-	}
-
-	string svalue = sectionptr-&gt;values[loclist[loclist.size() - 1]];
-	value = svalue;
-	return true;
-}
-
-//return a map with all values in section
-const map&lt;string, string&gt; CSunParser::GetAllValues(string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	map&lt;string, string&gt; emptymap;
-	string searchpath;
-	vector&lt;string&gt; loclist = GetLocationVector(location);
-
-	if (sections.find(loclist[0]) == sections.end()) {
-		return emptymap;
-	}
-
-	SSection* sectionptr = sections[loclist[0]];
-	searchpath = loclist[0];
-
-	for (unsigned int i = 1; i &lt; loclist.size(); i++) {
-		searchpath += '\\';
-		searchpath += loclist[i];
-
-		if (sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()) {
-			return emptymap;
-		}
-
-		sectionptr = sectionptr-&gt;sections[loclist[i]];
-	}
-
-	return sectionptr-&gt;values;
-}
-
-// return vector with all section names in it
-vector&lt;string&gt; CSunParser::GetSectionList(string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	vector&lt;string&gt; loclist = GetLocationVector(location);
-	vector&lt;string&gt; returnvec;
-	map&lt;string, SSection*&gt;* sectionsptr = &sections;
-
-	if (loclist[0].compare(&quot;&quot;) != 0) {
- 		string searchpath;
-		for (unsigned int i = 0; i &lt; loclist.size(); i++) {
-			searchpath += loclist[i];
-
-			if (sectionsptr-&gt;find(loclist[i]) == sectionsptr-&gt;end()) {
-				return returnvec;
-			}
-
-			sectionsptr = &amp;sectionsptr-&gt;find(loclist[i])-&gt;second-&gt;sections;
-			searchpath += '\\';
-		}
-	}
-
-	map&lt;string,SSection*&gt;::iterator it;
-	for (it = sectionsptr-&gt;begin(); it != sectionsptr-&gt;end(); it++) {
-		returnvec.push_back(it-&gt;first);
-		transform(returnvec.back().begin(), returnvec.back().end(), returnvec.back().begin(), (int (*)(int)) tolower);
-	}
-
-	return returnvec;
-}
-
-bool CSunParser::SectionExist(string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	vector&lt;string&gt; loclist = GetLocationVector(location);
-
-	if (sections.find(loclist[0]) == sections.end()) {
-		return false;
-	}
-
-	SSection* sectionptr = sections[loclist[0]];
-
-	for (unsigned int i = 1; i &lt; loclist.size(); i++) {
-		if (sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()) {
-			return false;
-		}
-
-		sectionptr = sectionptr-&gt;sections[loclist[i]];
-	}
-
-	return true;
-}
-
-vector&lt;string&gt; CSunParser::GetLocationVector(string location) {
-	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
-	vector&lt;string&gt; loclist;
-
-	unsigned long start = 0;
-	unsigned long next = 0;
-
-	while ((next = location.find_first_of(&quot;\\&quot;, start)) != std::string::npos) {
-		loclist.push_back(location.substr(start, next - start));
-		start = next + 1;
-	}
-
-	loclist.push_back(location.substr(start));
-
-	return loclist;
-}
-
-float3 CSunParser::GetFloat3(float3 def, string location) {
-	def = def;
-	location = location;
-	return float3(0, 0, 0);
-}
+#include &quot;SunParser.h&quot;
+
+CSunParser::CSunParser(AIClasses* ai) {
+	this-&gt;ai = ai;
+}
+CSunParser::~CSunParser() {
+	DeleteSection(&amp;sections);
+}
+
+void CSunParser::DeleteSection(map&lt;string, SSection*&gt;* section) {
+	map&lt;string, SSection*&gt;::iterator ui;
+
+	for (ui = section-&gt;begin(); ui != section-&gt;end(); ui++) {
+		DeleteSection(&amp;ui-&gt;second-&gt;sections);
+		delete ui-&gt;second;
+	}
+}
+
+void CSunParser::LoadVirtualFile(string filename) {
+	this-&gt;filename = filename;
+	int size = ai-&gt;cb-&gt;GetFileSize(filename.c_str());
+
+	if (size == -1) {
+		return;
+	}
+
+	char* filebuf = new char[size + 1];
+	ai-&gt;cb-&gt;ReadFile(filename.c_str(), filebuf, size);
+	 // append newline at end to avoid parsing error at EOF
+	filebuf[size] = '\0';
+
+	try {
+		Parse(filebuf, size);
+	} catch(...) {
+	}
+
+	delete[] filebuf;
+}
+
+void CSunParser::LoadRealFile(string filename) {
+	char filename_buf[1024];
+	strcpy(filename_buf, filename.c_str());
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename_buf);
+
+	this-&gt;filename = filename_buf;
+	std::ifstream RealFile(filename_buf);
+
+	if (RealFile.fail()) {
+		return;
+	}
+
+	RealFile.seekg(0, std::ios_base::end);
+	int size = RealFile.tellg();
+	RealFile.seekg(0, std::ios_base::beg);
+
+	char* filebuf = new char[size + 1];
+	RealFile.get(filebuf, size, '\0');
+	RealFile.close();
+	// append newline at end to avoid parsing error at EOF
+	filebuf[size] = '\0';
+
+	try {
+		Parse(filebuf, size);
+	} catch(...) {
+	}
+
+	delete[] filebuf;
+}
+
+void CSunParser::LoadBuffer(char* buf, int size) {
+    this-&gt;filename = &quot;\'Buffer\'&quot;;
+
+	try {
+		Parse(buf,size);
+	} catch(...) {
+	}
+}
+
+void CSunParser::Parse(char* buf, int size) {
+	string thissection;
+	SSection* section = NULL;
+
+	char* endptr = buf + size;
+
+	while (buf&lt;=endptr) {
+		if (buf[0] == '/' &amp;&amp; buf[1] == '/') {
+			// comment
+			while ((buf != endptr) &amp;&amp; *buf!='\n' &amp;&amp; *buf!='\r') {
+				buf++;
+			}
+		}
+		else if (buf[0] == '/' &amp;&amp; buf[1] == '*') {
+			// comment
+			while ((buf != endptr) &amp;&amp; buf[0] != '*' || buf[1] != '/') {
+				buf++;
+			}
+		}
+		else if (*buf == '[') {
+			// sectionname
+			thissection = &quot;&quot;;
+
+			while (*(++buf) != ']') {
+				thissection += *buf;
+			}
+		}
+		else if (*buf == '{') {
+			// section
+			buf++;
+			section = new SSection;
+			transform(thissection.begin(), thissection.end(), thissection.begin(), (int (*)(int)) tolower);
+			map&lt;string, SSection*&gt;::iterator ui = sections.find(thissection);
+
+			if (ui != sections.end()) {
+				DeleteSection(&amp;ui-&gt;second-&gt;sections);
+				delete ui-&gt;second;
+			}
+			sections[thissection] = section;
+			buf = ParseSection(buf, endptr - buf, section);
+		}
+
+		// We can possible hit endptr from somewhere that increases, so don't go past it
+		if (buf &lt;= endptr)
+			buf++;
+	}
+}
+
+char* CSunParser::ParseSection(char* buf, int size, SSection* section) {
+	string thissection;
+	char* endptr = buf + size;
+
+	while (buf &lt;= endptr) {
+
+		if (buf[0] == '/' &amp;&amp; buf[1] == '/') {
+			// comment
+			while (*buf != '\n' &amp;&amp; *buf != '\r') {
+				buf++;
+			}
+		}
+
+		else if (buf[0] == '/' &amp;&amp; buf[1] == '*') {
+			// comment
+			while (buf[0] != '*' || buf[1] != '/') {
+				buf++;
+			}
+		}
+
+		else if (*buf == '[') {
+			// sectionname
+			thissection = &quot;&quot;;
+
+			while (*(++buf) != ']') {
+				thissection += *buf;
+			}
+		}
+
+		else if (*buf == '{') {
+			// section
+			buf++;
+			SSection* newsection = new SSection;
+			transform(thissection.begin(), thissection.end(), thissection.begin(), (int (*)(int)) tolower);
+			map&lt;string, SSection*&gt;::iterator ui = section-&gt;sections.find(thissection);
+
+			if (ui != section-&gt;sections.end()) {
+				DeleteSection(&amp;ui-&gt;second-&gt;sections);
+				delete ui-&gt;second;
+			}
+
+			section-&gt;sections[thissection] = newsection;
+			buf = ParseSection(buf, endptr - buf, newsection);
+		}
+
+		else if (*buf == '}') {
+			// endsection
+			// buf++;
+			return buf;
+		}
+
+		else if (*buf &gt;= '0' &amp;&amp; *buf &lt;= 'z') {
+			string name;
+			string value;
+
+			while (*buf != '=') {
+				name += *buf;
+				buf++;
+			}
+
+			buf++;
+
+			while (*buf != ';') {
+				value += *buf;
+				buf++;
+			}
+
+			transform(name.begin(), name.end(), name.begin(), (int (*)(int)) tolower);
+			section-&gt;values[name] = value;
+		}
+
+		buf++;
+	}
+
+	return buf;
+}
+
+// find value, display messagebox if no such value found
+string CSunParser::SGetValueMSG(string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	string value;
+
+	SGetValue(value, location);
+	return value;
+}
+
+// find value, return default value if no such value found
+string CSunParser::SGetValueDef(string defaultvalue, string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	string value;
+
+	bool found = SGetValue(value, location);
+
+	if (!found) {
+		value = defaultvalue;
+	}
+
+	return value;
+}
+
+
+//finds a value in the file, if not found returns false
+// errormessages is returned in value
+bool CSunParser::GetValue(string &amp;value, void* amJustHereForIntelCompilerCompatibility, ...) {
+	string searchpath;
+
+	va_list loc;
+	va_start(loc, amJustHereForIntelCompilerCompatibility);
+	int numargs = 0;
+
+	while (va_arg(loc, char*)) {
+		// determine number of arguments
+		numargs++;
+	}
+
+	va_start(loc, amJustHereForIntelCompilerCompatibility);
+	SSection* sectionptr = 0x0;
+
+	for (int i = 0; i &lt; numargs - 1; i++) {
+		char* arg = va_arg(loc, char*);
+
+		searchpath += '\\';
+		searchpath += arg;
+		sectionptr = sections[arg];
+
+		if (sectionptr == NULL) {
+			value = &quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename;
+			return false;
+		}
+	}
+
+	char* arg = va_arg(loc, char*);
+	string svalue = sectionptr-&gt;values[arg];
+
+	searchpath += '\\';
+	searchpath += arg;
+
+	if (svalue == &quot;&quot;) {
+		value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
+		return false;
+	}
+
+	value = svalue;
+	return true;
+}
+
+void CSunParser::Test() {
+	SSection* unitinfo = sections[&quot;UNITINFO&quot;];
+	SSection* weapons = unitinfo-&gt;sections[&quot;WEAPONS&quot;];
+
+	string mo = weapons-&gt;values[&quot;weapon1&quot;];
+}
+
+
+// finds a value in the file , if not found returns false
+// errormessage is returned in value, location of value is
+// sent as a string &quot;section\section\value&quot;
+bool CSunParser::SGetValue(string &amp;value, string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	string searchpath;
+
+	//split the location string
+	vector&lt;string&gt; loclist = GetLocationVector(location);
+
+	if (sections.find(loclist[0]) == sections.end()) {
+		value = &quot;Section &quot; + loclist[0] + &quot; missing in file &quot; + filename;
+		return false;
+	}
+
+	SSection* sectionptr = sections[loclist[0]];
+	searchpath = loclist[0];
+
+	for (unsigned int i = 1; i &lt; loclist.size() - 1; i++) {
+		searchpath += '\\';
+		searchpath += loclist[i];
+
+		if (sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()) {
+			value = &quot;Section &quot; + searchpath + &quot; missing in file &quot; + filename;
+			return false;
+		}
+		sectionptr = sectionptr-&gt;sections[loclist[i]];
+	}
+
+	searchpath += '\\';
+	searchpath += loclist[loclist.size()-1];
+
+	if (sectionptr-&gt;values.find(loclist[loclist.size()-1]) == sectionptr-&gt;values.end()) {
+		value = &quot;Value &quot; + searchpath + &quot; missing in file &quot; + filename;
+
+		return false;
+	}
+
+	string svalue = sectionptr-&gt;values[loclist[loclist.size() - 1]];
+	value = svalue;
+	return true;
+}
+
+//return a map with all values in section
+const map&lt;string, string&gt; CSunParser::GetAllValues(string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	map&lt;string, string&gt; emptymap;
+	string searchpath;
+	vector&lt;string&gt; loclist = GetLocationVector(location);
+
+	if (sections.find(loclist[0]) == sections.end()) {
+		return emptymap;
+	}
+
+	SSection* sectionptr = sections[loclist[0]];
+	searchpath = loclist[0];
+
+	for (unsigned int i = 1; i &lt; loclist.size(); i++) {
+		searchpath += '\\';
+		searchpath += loclist[i];
+
+		if (sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()) {
+			return emptymap;
+		}
+
+		sectionptr = sectionptr-&gt;sections[loclist[i]];
+	}
+
+	return sectionptr-&gt;values;
+}
+
+// return vector with all section names in it
+vector&lt;string&gt; CSunParser::GetSectionList(string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	vector&lt;string&gt; loclist = GetLocationVector(location);
+	vector&lt;string&gt; returnvec;
+	map&lt;string, SSection*&gt;* sectionsptr = &sections;
+
+	if (loclist[0].compare(&quot;&quot;) != 0) {
+ 		string searchpath;
+		for (unsigned int i = 0; i &lt; loclist.size(); i++) {
+			searchpath += loclist[i];
+
+			if (sectionsptr-&gt;find(loclist[i]) == sectionsptr-&gt;end()) {
+				return returnvec;
+			}
+
+			sectionsptr = &amp;sectionsptr-&gt;find(loclist[i])-&gt;second-&gt;sections;
+			searchpath += '\\';
+		}
+	}
+
+	map&lt;string,SSection*&gt;::iterator it;
+	for (it = sectionsptr-&gt;begin(); it != sectionsptr-&gt;end(); it++) {
+		returnvec.push_back(it-&gt;first);
+		transform(returnvec.back().begin(), returnvec.back().end(), returnvec.back().begin(), (int (*)(int)) tolower);
+	}
+
+	return returnvec;
+}
+
+bool CSunParser::SectionExist(string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	vector&lt;string&gt; loclist = GetLocationVector(location);
+
+	if (sections.find(loclist[0]) == sections.end()) {
+		return false;
+	}
+
+	SSection* sectionptr = sections[loclist[0]];
+
+	for (unsigned int i = 1; i &lt; loclist.size(); i++) {
+		if (sectionptr-&gt;sections.find(loclist[i]) == sectionptr-&gt;sections.end()) {
+			return false;
+		}
+
+		sectionptr = sectionptr-&gt;sections[loclist[i]];
+	}
+
+	return true;
+}
+
+vector&lt;string&gt; CSunParser::GetLocationVector(string location) {
+	transform(location.begin(), location.end(), location.begin(), (int (*)(int)) tolower);
+	vector&lt;string&gt; loclist;
+
+	unsigned long start = 0;
+	unsigned long next = 0;
+
+	while ((next = location.find_first_of(&quot;\\&quot;, start)) != std::string::npos) {
+		loclist.push_back(location.substr(start, next - start));
+		start = next + 1;
+	}
+
+	loclist.push_back(location.substr(start));
+
+	return loclist;
+}
+
+float3 CSunParser::GetFloat3(float3 def, string location) {
+	def = def;
+	location = location;
+	return float3(0, 0, 0);
+}

Modified: trunk/AI/Global/KAIK-0.13/SunParser.h
===================================================================
--- trunk/AI/Global/KAIK-0.13/SunParser.h	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/SunParser.h	2008-12-17 19:52:00 UTC (rev 7190)
@@ -18,10 +18,11 @@
 
 		  /**
 			*  @param value pointer to string to store the value in.
+			*  @param amJustHereForIntelCompilerCompatibility should always be NULL
 			*  @param ... location of value, terminate with NULL.
 			*  @return true on success.
 			*/
-		bool GetValue(string &amp;value, ...);
+		bool GetValue(string &amp;value, void* amJustHereForIntelCompilerCompatibility, ...);
 
 		  /**
 			*  Retreive a specific value from the file and returns it, gives an error messagebox if value not found.

Modified: trunk/AI/Global/KAIK-0.13/UnitTable.cpp
===================================================================
--- trunk/AI/Global/KAIK-0.13/UnitTable.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/KAIK-0.13/UnitTable.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1,1111 +1,1114 @@
-// Based on Submarine's BuildTable Class from AAI. Thanks sub!
-
-#include &quot;UnitTable.h&quot;
-
-#include &quot;Sim/Misc/GlobalConstants.h&quot;
-#include &quot;System/Util.h&quot;
-
-/// CR_BIND(CUnitTable, );
-/// CR_REG_METADATA(CUnitTable, (
-/// 	CR_MEMBER(all_lists),
-/// 	CR_MEMBER(ground_factories),
-/// 	CR_MEMBER(ground_builders),
-/// 	CR_MEMBER(ground_attackers),
-/// 	CR_MEMBER(metal_extractors),
-/// 	CR_MEMBER(metal_makers),
-/// 	CR_MEMBER(ground_energy),
-/// 	CR_MEMBER(ground_defences),
-/// 	CR_MEMBER(metal_storages),
-/// 	CR_MEMBER(energy_storages),
-/// 	CR_MEMBER(nuke_silos),
-///
-/// 	CR_MEMBER(numOfSides),
-/// 	CR_MEMBER(sideNames),
-/// 	CR_MEMBER(modSideMap),
-/// 	CR_MEMBER(teamSides),
-///
-/// 	CR_MEMBER(unitTypes)
-/// ));
-
-
-CUnitTable::CUnitTable(AIClasses* ai) {
-	this-&gt;ai = ai;
-
-	numOfUnits = 0;
-	unitList = 0;
-
-	BuildModSideMap();
-	ReadTeamSides();
-
-	// now set up the unit lists
-	ground_factories = new vector&lt;int&gt;[numOfSides];
-	ground_builders = new vector&lt;int&gt;[numOfSides];
-	ground_attackers = new vector&lt;int&gt;[numOfSides];
-	metal_extractors = new vector&lt;int&gt;[numOfSides];
-	metal_makers = new vector&lt;int&gt;[numOfSides];
-	ground_energy = new vector&lt;int&gt;[numOfSides];
-	ground_defences = new vector&lt;int&gt;[numOfSides];
-	metal_storages = new vector&lt;int&gt;[numOfSides];
-	energy_storages = new vector&lt;int&gt;[numOfSides];
-	nuke_silos = new vector&lt;int&gt;[numOfSides];
-
-	all_lists.push_back(ground_factories);	// CAT_FACTORY  (idx: 0, cat enum:  7)
-	all_lists.push_back(ground_builders);	// CAT_BUILDER  (idx: 1, cat enum:  4)
-	all_lists.push_back(ground_attackers);	// CAT_G_ATTACK (idx: 2, cat enum:  9)
-	all_lists.push_back(metal_extractors);	// CAT_MEX      (idx: 3, cat enum:  2)
-	all_lists.push_back(metal_makers);		// CAT_MMAKER   (idx: 4, cat enum:  3)
-	all_lists.push_back(ground_energy);		// CAT_ENERGY   (idx: 5, cat enum:  1)
-	all_lists.push_back(ground_defences);	// CAT_DEFENCE  (idx: 6, cat enum:  8)
-	all_lists.push_back(metal_storages);	// CAT_MSTOR    (idx: 7, cat enum:  6)
-	all_lists.push_back(energy_storages);	// CAT_ESTOR    (idx: 8, cat enum:  5)
-	all_lists.push_back(nuke_silos);		// CAT_NUKE     (idx: 9, cat enum: 10)
-}
-
-CUnitTable::~CUnitTable() {
-	delete[] unitTypes;
-	delete[] unitList;
-
-	delete[] ground_factories;
-	delete[] ground_builders;
-	delete[] ground_attackers;
-	delete[] metal_extractors;
-	delete[] metal_makers;
-	delete[] ground_energy;
-	delete[] ground_defences;
-	delete[] metal_storages;
-	delete[] energy_storages;
-	delete[] nuke_silos;
-}
-
-
-int CUnitTable::BuildModSideMap() {
-	L(&quot;[CUnitTable::BuildModSideMap()]&quot;);
-
-	// get all sides and commanders
-	std::string commKey;	// eg. &quot;SIDE4\\commander&quot;
-	std::string commName;	// eg. &quot;arm_commander&quot;
-	std::string sideKey;	// eg. &quot;SIDE4\\name&quot;
-	std::string sideName;	// eg. &quot;Arm&quot;
-	char sideNum[64] = {0};
-
-	// FIXME: can be a .lua script now
-	ai-&gt;parser-&gt;LoadVirtualFile(&quot;gamedata\\SIDEDATA.tdf&quot;);
-
-	// look at SIDE0 through SIDE9
-	// (should be enough for any mod)
-	for (int side = 0; side &lt; 10; side++) {
-		sprintf(sideNum, &quot;%i&quot;, side);
-
-		commKey = &quot;SIDE&quot; + std::string(sideNum) + &quot;\\commander&quot;;
-		sideKey = &quot;SIDE&quot; + std::string(sideNum) + &quot;\\name&quot;;
-
-		ai-&gt;parser-&gt;GetDef(commName, &quot;-1&quot;, commKey);
-		const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(commName.c_str());
-
-		if (udef) {
-			// if this unit exists, the side is valid too
-			startUnits.push_back(udef-&gt;id);
-			ai-&gt;parser-&gt;GetDef(sideName, &quot;-1&quot;, sideKey);
-
-			// transform the side string to lower-case
-			StringToLowerInPlace(sideName);
-
-			sideNames.push_back(sideName);
-			modSideMap[sideName] = side;
-			numOfSides = side + 1;
-
-			L(&quot;\tside index: &quot; &lt;&lt; side &lt;&lt; &quot;, root unit: &quot; &lt;&lt; udef-&gt;name &lt;&lt; &quot;, side name: &quot; &lt;&lt; sideName &lt;&lt; &quot;, &quot; &lt;&lt; sideName &lt;&lt; &quot; ==&gt; &quot; &lt;&lt; side);
-		} else {
-			L(&quot;\tside &quot; &lt;&lt; side &lt;&lt; &quot; not defined&quot;);
-		}
-	}
-
-	return numOfSides;
-}
-
-int CUnitTable::ReadTeamSides() {
-	L(&quot;[CUnitTable::ReadTeamSides()]&quot;);
-
-	teamSides.resize(MAX_TEAMS, 0);
-	teamSides[0] = 0;	// team 0 defaults to side 0 (in GlobalAI startscript)
-	teamSides[1] = 1;	// team 1 defaults to side 1 (in GlobalAI startscript)
-
-	for (int team = 0; team &lt; MAX_TEAMS; team++) {
-		const char* sideKey = ai-&gt;cb-&gt;GetTeamSide(team);
-
-		if (sideKey) {
-			// FIXME: Gaia-team side?
-			// team index was valid (and we are in a GameSetup-type
-			// game), override the default side index for this team
-			teamSides[team] = modSideMap[sideKey];
-
-			L(&quot;\tteam: &quot; &lt;&lt; team &lt;&lt; &quot;, side: &quot; &lt;&lt; modSideMap[sideKey] &lt;&lt; &quot; (index: &quot; &lt;&lt; teamSides[team] &lt;&lt; &quot;)&quot;);
-		} else {
-			L(&quot;\tno \&quot;game\\team\\side\&quot; value found for team &quot; &lt;&lt; team);
-		}
-	}
-
-	return teamSides[ai-&gt;cb-&gt;GetMyTeam()];
-}
-
-// called at the end of Init()
-void CUnitTable::ReadModConfig() {
-	L(&quot;[CUnitTable::ReadModConfig()]&quot;);
-
-	const char* modName = ai-&gt;cb-&gt;GetModName();
-	char configFileName[1024] = {0};
-	char logMsg[2048] = {0};
-	snprintf(configFileName, 1023, &quot;%s%s.cfg&quot;, CFGFOLDER, modName);
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, configFileName);
-
-	FILE* f = fopen(configFileName, &quot;r&quot;);
-
-	if (f) {
-		L(&quot;\tparsing existing mod configuration file &quot; &lt;&lt; configFileName);
-
-		// read the mod's .cfg file
-		char str[1024];
-		char name[512];
-		float costMult = 1.0f;
-		int techLvl = -1;
-		int category = -1;
-
-		while (fgets(str, 1024, f) != 0x0) {
-			if (str[0] == '/' &amp;&amp; str[1] == '/') {
-				continue;
-			}
-
-			int i = sscanf(str, &quot;%s %f %d %d&quot;, name, &amp;costMult, &amp;techLvl, &amp;category);
-			const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(name);
-
-			if ((i == 4) &amp;&amp; udef) {
-				UnitType* utype = &amp;unitTypes[udef-&gt;id];
-				utype-&gt;costMultiplier = costMult;
-				utype-&gt;techLevel = techLvl;
-
-				L(&quot;\t\tudef-&gt;id: &quot; &lt;&lt; udef-&gt;id &lt;&lt; &quot;, udef-&gt;name: &quot; &lt;&lt; udef-&gt;name &lt;&lt; &quot;, utype-&gt;category: &quot; &lt;&lt; utype-&gt;category &lt;&lt; &quot;, .cfg category: &quot; &lt;&lt; category);
-
-				// TODO: look for any possible side-effects that might arise
-				// from overriding categories like this, then enable overrides
-				// other than builder --&gt; attacker?
-				// FIXME: SEGV when unarmed CAT_BUILDER units masquerading as
-				// CAT_G_ATTACK'ers want to or are attacked
-				if (category &gt;= 0 &amp;&amp; category &lt; LASTCATEGORY) {
-					if (category == CAT_G_ATTACK &amp;&amp; utype-&gt;category == CAT_BUILDER) {
-						L(&quot;\t\t\t.cfg category (CAT_G_ATTACK) overrides utype-&gt;category (CAT_BUILDER)&quot;);
-
-						// maps unit categories to indices into all_lists
-						// FIXME: hackish, poorly maintainable, bad style
-						int catLstIdx[11] = {0, 5, 3, 4, 1, 8, 7, 0, 6, 2, 9};
-
-						// index of sublist (eg. ground_builders) that ::Init() thinks it belongs to
-						int idx1 = catLstIdx[utype-&gt;category];
-						// index of sublist (eg. ground_attackers) that mod .cfg says it belongs to
-						int idx2 = catLstIdx[category];
-
-						if (idx1 != idx2) {
-							std::vector&lt;int&gt;* oldLst = all_lists[idx1];	// old category list
-							std::vector&lt;int&gt;* newLst = all_lists[idx2];	// new category list
-							std::set&lt;int&gt;::iterator sit;
-							std::vector&lt;int&gt;::iterator vit;
-
-							for (sit = utype-&gt;sides.begin(); sit != utype-&gt;sides.end(); sit++) {
-								int side = *sit;
-
-								for (vit = oldLst[side].begin(); vit != oldLst[side].end(); vit++) {
-									int udefID = *vit;
-
-									if (udefID == udef-&gt;id) {
-										oldLst[side].erase(vit);
-										newLst[side].push_back(udef-&gt;id);
-										vit--;
-									}
-								}
-							}
-
-							utype-&gt;category = category;
-						}
-					}
-				}
-			}
-		}
-
-		sprintf(logMsg, &quot;read mod configuration file %s&quot;, configFileName);
-	} else {
-		L(&quot;\tcreating new mod configuration file &quot; &lt;&lt; configFileName);
-
-		// write a new .cfg file with default values
-		f = fopen(configFileName, &quot;w&quot;);
-		fprintf(f, &quot;// unitName costMultiplier techLevel category\n&quot;);
-
-		for (int i = 1; i &lt;= numOfUnits; i++) {
-			UnitType* utype = &amp;unitTypes[i];
-			// assign and write default values for costMultiplier
-			// and techLevel, category is already set in ::Init()
-			utype-&gt;costMultiplier = 1.0f;
-			utype-&gt;techLevel = -1;
-			fprintf(f, &quot;%s %.2f %d %d\n&quot;, utype-&gt;def-&gt;name.c_str(), utype-&gt;costMultiplier, utype-&gt;techLevel, utype-&gt;category);
-
-			L(&quot;\t\tname: &quot; &lt;&lt; (utype-&gt;def-&gt;name) &lt;&lt; &quot;, .cfg category: &quot; &lt;&lt; (utype-&gt;category));
-		}
-
-		sprintf(logMsg, &quot;wrote mod configuration file %s&quot;, configFileName);
-	}
-
-	ai-&gt;cb-&gt;SendTextMsg(logMsg, 0);
-	fclose(f);
-}
-
-
-
-int CUnitTable::GetSide(int unitID) {
-	int team = ai-&gt;cb-&gt;GetUnitTeam(unitID);
-	int side = teamSides[team];
-
-	return side;
-}
-
-int CUnitTable::GetCategory(const UnitDef* unitdef) {
-	return unitTypes[unitdef-&gt;id].category;
-}
-
-int CUnitTable::GetCategory(int unit) {
-	const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(unit);
-
-	if (udef != NULL) {
-		UnitType&amp; utype = unitTypes[udef-&gt;id];
-		return (utype.category);
-	} else {
-		return -1;
-	}
-}
-
-
-
-// used to update threat-map, should probably
-// use cost multipliers too (but in that case
-// non-squad units like Flashes could become
-// artifically overrated by a massive amount)
-float CUnitTable::GetDPS(const UnitDef* unit) {
-	if (unit) {
-		float totaldps = 0.0f;
-
-		for (vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = unit-&gt;weapons.begin(); i != unit-&gt;weapons.end(); i++) {
-			float dps = 0.0f;
-
-			if (!i-&gt;def-&gt;paralyzer) {
-				float reloadtime = i-&gt;def-&gt;reload;
-				int numberofdamages;
-				ai-&gt;cb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numberofdamages);
-
-				for (int k = 0; k &lt; numberofdamages; k++) {
-					dps += i-&gt;def-&gt;damages[k];
-				}
-
-				dps = dps * i-&gt;def-&gt;salvosize / numberofdamages / reloadtime;
-			}
-
-			totaldps += dps;
-		}
-
-		return totaldps;
-	}
-
-	return 0.0f;
-}
-
-
-
-float CUnitTable::GetDPSvsUnit(const UnitDef* unit, const UnitDef* victim) {
-	if (unit-&gt;weapons.size()) {
-		ai-&gt;math-&gt;TimerStart();
-
-		float dps = 0.0f;
-		bool canhit = false;
-		int armortype = victim-&gt;armorType;
-		int numberofdamages = 0;
-		ai-&gt;cb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numberofdamages);
-
-		for (unsigned int i = 0; i != unit-&gt;weapons.size(); i++) {
-			if (!unit-&gt;weapons[i].def-&gt;paralyzer) {
-				unsigned int a = victim-&gt;category;
-				unsigned int b = unit-&gt;weapons[i].def-&gt;onlyTargetCategory;	// what the weapon can target
-				unsigned int c = unit-&gt;weapons[i].onlyTargetCat;			// what the unit accepts as this weapons target
-//				unsigned int d = unit-&gt;weapons[i].badTargetCat;				// what the unit thinks this weapon must be used for (?)
-				bool canWeaponTarget = (a &amp; b) &gt; 0;
-				bool canUnitTarget = (a &amp; c) &gt; 0;							// how is this used?
-//				bool badUnitTarget = (a &amp; d) &gt; 0;							// probably means that it has low priority
-
-				canhit = (canWeaponTarget &amp;&amp; canUnitTarget);
-
-				if (!unit-&gt;weapons[i].def-&gt;waterweapon &amp;&amp; ai-&gt;cb-&gt;GetUnitDefHeight(victim-&gt;id) - victim-&gt;waterline &lt; 0) {
-					// weapon cannot hit this sub
-					canhit = false;
-				}
-
-				if (unit-&gt;weapons[i].def-&gt;waterweapon &amp;&amp; victim-&gt;minWaterDepth == 0) {
-					// anti-sub weapon cannot kill this unit
-					canhit = false;
-				}
-
-				// bombers are useless against air
-				if (unit-&gt;weapons[i].def-&gt;dropped &amp;&amp; victim-&gt;canfly &amp;&amp; unit-&gt;canfly &amp;&amp; unit-&gt;wantedHeight &lt;= victim-&gt;wantedHeight) {
-					canhit = false;
-				}
-
-				if (canhit) {
-					float accuracy = unit-&gt;weapons[i].def-&gt;accuracy * 2.8;
-
-					if (victim-&gt;speed != 0) {
-						accuracy *= 1 - (unit-&gt;weapons[i].def-&gt;targetMoveError);
-					}
-
-					float basedamage = unit-&gt;weapons[i].def-&gt;damages[armortype] * unit-&gt;weapons[i].def-&gt;salvosize / unit-&gt;weapons[i].def-&gt;reload;
-					float AOE = unit-&gt;weapons[i].def-&gt;areaOfEffect * 0.7;
-					float tohitprobability = 0.0f;
-					float impactarea = 0.0f;
-					float targetarea = 0.0f;
-					float distancetravelled = 0.7f * unit-&gt;weapons[i].def-&gt;range;
-					float firingangle = 0.0f;
-					float gravity = -(ai-&gt;cb-&gt;GetGravity() * 900);
-					float timetoarrive = 0.0f;
-					float u = unit-&gt;weapons[i].def-&gt;projectilespeed * 30;
-
-					if (unit-&gt;weapons[i].def-&gt;type == string(&quot;Cannon&quot;)) {
-						float sinoid = (distancetravelled * gravity) / (u * u);
-						sinoid = std::min(sinoid, 1.0f);
-						firingangle = asin(sinoid) / 2;
-
-						if (unit-&gt;highTrajectoryType == 1) {
-							firingangle = (PI / 2) - firingangle;
-						}
-
-						float heightreached = pow(u * sin(firingangle), 2) / (2 * gravity);
-						float halfd = distancetravelled / 2;
-						distancetravelled = 2 * sqrt(halfd * halfd + heightreached * heightreached) * 1.1;
-					}
-
-					if ((victim-&gt;canfly &amp;&amp; unit-&gt;weapons[i].def-&gt;selfExplode) || !victim-&gt;canfly) {
-						impactarea = pow((accuracy * distancetravelled) + AOE, 2);
-						targetarea = ((victim-&gt;xsize * 16) + AOE) * ((victim-&gt;zsize * 16) + AOE);
-					} else {
-						impactarea = pow((accuracy) * (0.7f * distancetravelled), 2);
-						targetarea = (victim-&gt;xsize * victim-&gt;zsize * 256);
-					}
-
-					if (impactarea &gt; targetarea) {
-						tohitprobability = targetarea / impactarea;
-					} else {
-						tohitprobability = 1;
-					}
-
-					if (unit-&gt;weapons[i].def-&gt;turnrate == 0.0f &amp;&amp; unit-&gt;weapons[i].def-&gt;projectilespeed != 0 &amp;&amp; victim-&gt;speed != 0 &amp;&amp; unit-&gt;weapons[i].def-&gt;beamtime == 1) {
-						if (unit-&gt;weapons[i].def-&gt;type == string(&quot;Cannon&quot;)) {
-							timetoarrive = (2 * u * sin(firingangle)) / gravity;
-						} else {
-							timetoarrive = distancetravelled / (unit-&gt;weapons[i].def-&gt;projectilespeed * 30);
-						}
-
-						float shotwindow = sqrt(targetarea) / victim-&gt;speed * 1.3;
-
-						if (shotwindow &lt; timetoarrive) {
-							tohitprobability *= shotwindow / timetoarrive;
-						}
-					}
-
-					dps += basedamage * tohitprobability;
-				}
-			}
-		}
-
-		return dps;
-	}
-
-	return 0.0f;
-}
-
-
-
-float CUnitTable::GetCurrentDamageScore(const UnitDef* unit) {
-	int enemies[MAX_UNITS];
-	int numEnemies = ai-&gt;cheat-&gt;GetEnemyUnits(enemies);
-	vector&lt;int&gt; enemiesOfType;
-	float score = 0.01f;
-	float totalCost = 0.01f;
-	enemiesOfType.resize(ai-&gt;cb-&gt;GetNumUnitDefs() + 1, 0);
-
-	for (int i = 0; i &lt; numEnemies; i++) {
-		const UnitDef* udef = ai-&gt;cheat-&gt;GetUnitDef(enemies[i]);
-
-		if (udef) {
-			enemiesOfType[udef-&gt;id]++;
-		}
-	}
-
-	for (unsigned int i = 1; i &lt; enemiesOfType.size(); i++) {
-		bool b1 = unitTypes[i].def-&gt;builder;
-		bool b2 = (enemiesOfType[i] &gt; 0);
-		bool b3 = (unitTypes[i].sides.size() &gt; 0);
-		// bool b4 = (!unit-&gt;speed &amp;&amp; !unitTypes[i].def-&gt;speed);
-
-		if (!b1 &amp;&amp; b2 &amp;&amp; b3 /* &amp;&amp; !b4 */) {
-			float currentScore = 0.0f;
-			float costOfEnemiesOfThisType = ((unitTypes[i].def-&gt;metalCost * METAL2ENERGY) + unitTypes[i].def-&gt;energyCost) * enemiesOfType[i];
-			currentScore = unitTypes[unit-&gt;id].DPSvsUnit[i] * costOfEnemiesOfThisType;
-			totalCost += costOfEnemiesOfThisType;
-
-			/*
-			if (unitTypes[i].DPSvsUnit[unit-&gt;id] * costofenemiesofthistype &gt; 0) {
-				currentscore -= (unitTypes[i].DPSvsUnit[unit-&gt;id] * costofenemiesofthistype);
-			}
-			*/
-
-			score += currentScore;
-		}
-	}
-
-	if (totalCost &lt;= 0)
-		return 0.0f;
-
-	return (score / totalCost);
-}
-
-
-
-
-void CUnitTable::UpdateChokePointArray() {
-	vector&lt;float&gt; EnemyCostsByMoveType;
-	EnemyCostsByMoveType.resize(ai-&gt;pather-&gt;NumOfMoveTypes);
-	vector&lt;int&gt; enemiesOfType;
-	float totalCost = 1.0f;
-	int enemies[MAX_UNITS];
-	int numEnemies = ai-&gt;cheat-&gt;GetEnemyUnits(enemies);
-	enemiesOfType.resize(ai-&gt;cb-&gt;GetNumUnitDefs() + 1, 0);
-
-	for (int i = 0; i &lt; ai-&gt;pather-&gt;totalcells; i++) {
-		ai-&gt;dm-&gt;ChokePointArray[i] = 0;
-	}
-	for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes; i++) {
-		EnemyCostsByMoveType[i] = 0;
-	}
-	for (int i = 0; i &lt; numEnemies; i++) {
-		enemiesOfType[ai-&gt;cheat-&gt;GetUnitDef(enemies[i])-&gt;id]++;
-	}
-
-	for (unsigned int i = 1; i &lt; enemiesOfType.size(); i++) {
-		if (unitTypes[i].sides.size() &gt; 0 &amp;&amp; !unitTypes[i].def-&gt;canfly &amp;&amp; unitTypes[i].def-&gt;speed &gt; 0) {
-			float currentcosts = ((unitTypes[i].def-&gt;metalCost * METAL2ENERGY) + unitTypes[i].def-&gt;energyCost) * (enemiesOfType[i]);
-			EnemyCostsByMoveType[unitTypes[i].def-&gt;moveType] += currentcosts;
-			totalCost += currentcosts;
-		}
-	}
-
-	for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes; i++) {
-		EnemyCostsByMoveType[i] /= totalCost;
-
-		for (int c = 0; c &lt; ai-&gt;pather-&gt;totalcells; c++) {
-			ai-&gt;dm-&gt;ChokePointArray[c] += ai-&gt;dm-&gt;ChokeMapsByMovetype[i][c] * EnemyCostsByMoveType[i];
-		}
-	}
-}
-
-
-
-
-
-
-float CUnitTable::GetScore(const UnitDef* udef, int category) {
-	int m = (ai-&gt;uh-&gt;AllUnitsByType[udef-&gt;id]).size();
-	int n = udef-&gt;maxThisUnit;
-
-	if (m &gt;= n) {
-		// if we've hit the build-limit for this
-		// type of unit, make sure GetUnitByScore()
-		// won't pick it for construction anyway
-		return 0.0f;
-	}
-
-	if (udef-&gt;minWaterDepth &gt; 0) {
-		// we can't swim yet
-		return 0.0f;
-	}
-
-	int frame = ai-&gt;cb-&gt;GetCurrentFrame();
-	float Cost = ((udef-&gt;metalCost * METAL2ENERGY) + udef-&gt;energyCost) + 0.1f;
-	float CurrentIncome = INCOMEMULTIPLIER * (ai-&gt;cb-&gt;GetEnergyIncome() + (ai-&gt;cb-&gt;GetMetalIncome() * METAL2ENERGY)) + frame / 2;
-	float Hitpoints = udef-&gt;health;
-	float buildTime = udef-&gt;buildTime + 0.1f;
-	float benefit = 0.0f;
-	float aoe = 0.0f;
-	float dps = 0.0f;
-	int unitcounter = 0;
-	bool candevelop = false;
-
-	float RandNum = ai-&gt;math-&gt;RandNormal(4, 3, 1) + 1;
-	float randMult = float((rand() % 2) + 1);
-
-	switch (category) {
-		case CAT_ENERGY: {
-			// KLOOTNOTE: factor build-time into this as well
-			// (so benefit values generally lie closer together)
-			// benefit = (udef-&gt;energyMake - udef-&gt;energyUpkeep);
-			// benefit = (udef-&gt;energyMake - udef-&gt;energyUpkeep) * randMult;
-			benefit = ((udef-&gt;energyMake - udef-&gt;energyUpkeep) / buildTime) * randMult;
-
-			if (udef-&gt;windGenerator) {
-				const float minWind = ai-&gt;cb-&gt;GetMinWind();
-				const float maxWind = ai-&gt;cb-&gt;GetMaxWind();
-				const float avgWind = (minWind + maxWind) * 0.5f;
-				if (minWind &gt;= 8.0f || (minWind &gt;= 4.0f &amp;&amp; avgWind &gt;= 8.0f)) {
-					benefit += avgWind;
-				}
-			}
-			if (udef-&gt;tidalGenerator) {
-				benefit += ai-&gt;cb-&gt;GetTidalStrength();
-			}
-
-			// filter geothermals
-			if (udef-&gt;needGeo) {
-				benefit = 0.0f;
-			}
-
-			// KLOOTNOTE: dividing by cost here as well means
-			// benefit is inversely proportional to square of
-			// cost, so expensive generators are quadratically
-			// less likely to be built if original calculation
-			// of score is used
-			// benefit /= Cost;
-		} break;
-
-		case CAT_MEX: {
-			benefit = pow(udef-&gt;extractsMetal, 4.0f);
-		} break;
-		case CAT_MMAKER: {
-			// benefit = ((udef-&gt;metalMake - udef-&gt;metalUpkeep) / udef-&gt;energyUpkeep) + 0.01f;
-			benefit = (udef-&gt;metalMake - udef-&gt;metalUpkeep) / (udef-&gt;energyUpkeep + 0.01f);
-		} break;
-
-		case CAT_G_ATTACK: {
-			dps = GetCurrentDamageScore(udef);
-			aoe = ((udef-&gt;weapons.size())? ((udef-&gt;weapons.front()).def)-&gt;areaOfEffect: 0.0f);
-
-			if (udef-&gt;canfly &amp;&amp; !udef-&gt;hoverAttack) {
-				// TODO: improve to set reload-time to the bomber's
-				// turnspeed vs. movespeed (eg. time taken for a run)
-				dps /= 6;
-			}
-
-			benefit = pow((aoe + 80), 1.5f)
-					* pow(GetMaxRange(udef) + 200, 1.5f)
-					* pow(dps, 1.0f)
-					* pow(udef-&gt;speed + 40, 1.0f)
-					* pow(Hitpoints, 1.0f)
-					* pow(RandNum, 2.5f)
-					* pow(Cost, -0.5f);
-
-			if (udef-&gt;canfly || udef-&gt;canhover) {
-				// general hack: reduce feasibility of aircraft for 20 mins
-				// and that of hovercraft permanently, should mostly prefer
-				// real L2 units to hovers
-				benefit = (udef-&gt;canfly &amp;&amp; frame &gt;= (30 * 60 * 20))? benefit: benefit * 0.01f;
-			}
-		} break;
-
-		case CAT_DEFENCE: {
-			aoe = ((udef-&gt;weapons.size())? ((udef-&gt;weapons.front()).def)-&gt;areaOfEffect: 0.0f);
-			benefit = pow((aoe + 80), 1.5f)
-					* pow(GetMaxRange(udef), 2.0f)
-					* pow(GetCurrentDamageScore(udef), 1.5f)
-					* pow(Hitpoints, 0.5f)
-					* pow(RandNum, 2.5f)
-					* pow(Cost, -1.0f);
-		} break;
-
-		case CAT_BUILDER: {
-			for (unsigned int i = 0; i != unitTypes[udef-&gt;id].canBuildList.size(); i++) {
-				if (unitTypes[unitTypes[udef-&gt;id].canBuildList[i]].category == CAT_FACTORY) {
-					candevelop = true;
-				}
-			}
-
-			// builder units that cannot construct any
-			// factories are worthless, prevent them
-			// from being chosen via GetUnitByScore()
-			// (they might have other uses though, eg.
-			// nano-towers)
-			if (!candevelop) {
-				benefit = 0.0f;
-			} else {
-				benefit = pow(udef-&gt;buildSpeed, 1.0f)
-						* pow(udef-&gt;speed, 0.5f)
-						* pow(Hitpoints, 0.3f)
-						* pow(RandNum, 0.4f);
-			}
-		} break;
-
-		case CAT_FACTORY: {
-			// benefit of a factory is dependant on the kind of
-			// offensive units it can build, but EE-hubs are only
-			// capable of building other buildings
-			for (unsigned int i = 0; i != unitTypes[udef-&gt;id].canBuildList.size(); i++) {
-				int buildOption = unitTypes[udef-&gt;id].canBuildList[i];
-				int buildOptionCategory = unitTypes[buildOption].category;
-
-				if (buildOptionCategory == CAT_G_ATTACK || buildOptionCategory == CAT_FACTORY) {
-					if (unitTypes[buildOption].def != udef) {
-						// KLOOTNOTE: guard against infinite recursion (BuildTowers in
-						// PURE trigger this since they are able to build themselves)
-						benefit += GetScore(unitTypes[buildOption].def, buildOptionCategory);
-						unitcounter++;
-					}
-				}
-			}
-
-			if (unitcounter &gt; 0) {
-				benefit /= (unitcounter * pow(float(ai-&gt;uh-&gt;AllUnitsByType[udef-&gt;id].size() + 1), 3.0f));
-			} else {
-				benefit = 0.0f;
-			}
-		} break;
-
-		case CAT_MSTOR: {
-			benefit = pow((udef-&gt;metalStorage), 1.0f) * pow(Hitpoints, 1.0f);
-		} break;
-		case CAT_ESTOR: {
-			benefit = pow((udef-&gt;energyStorage), 1.0f) * pow(Hitpoints, 1.0f);
-		} break;
-		case CAT_NUKE: {
-			// KLOOTNOTE: should factor damage into this as well
-			float metalcost = udef-&gt;stockpileWeaponDef-&gt;metalcost;
-			float energycost = udef-&gt;stockpileWeaponDef-&gt;energycost;
-			float supplycost = udef-&gt;stockpileWeaponDef-&gt;supplycost;
-			float denom = metalcost + energycost + supplycost + 1.0f;
-			float range = udef-&gt;stockpileWeaponDef-&gt;range;
-			benefit = (udef-&gt;stockpileWeaponDef-&gt;areaOfEffect + range) / denom;
-		} break;
-		/*
-		case CAT_ANTINUKE: {
-			benefit = udef-&gt;stockpileWeaponDef-&gt;coverageRange;
-		} break;
-		case CAT_SHIELD: {
-			benefit = udef-&gt;shieldWeaponDef-&gt;shieldRadius;
-		} break;
-		*/
-		default:
-			benefit = 0.0f;
-	}
-
-	benefit *= unitTypes[udef-&gt;id].costMultiplier;
-	// return (benefit / (CurrentIncome + Cost));
-	// return ((benefit / Cost) * CurrentIncome);
-	return ((CurrentIncome / Cost) * benefit);
-}
-
-
-
-// operates in terms of GetScore() (which is recursive for factories)
-const UnitDef* CUnitTable::GetUnitByScore(int builderUnitID, int category) {
-	if (category == LASTCATEGORY)
-		return 0x0;
-
-	vector&lt;int&gt;* tempList = 0;
-	const UnitDef* builderDef = ai-&gt;cb-&gt;GetUnitDef(builderUnitID);
-	const UnitDef* tempUnitDef = 0;
-	int side = GetSide(builderUnitID);
-	float tempScore = 0.0f;
-	float bestScore = 0.0f;
-
-	switch (category) {
-		case CAT_ENERGY:
-			tempList = ground_energy;
-			break;
-		case CAT_MEX:
-			tempList = metal_extractors;
-			break;
-		case CAT_MMAKER:
-			tempList = metal_makers;
-			break;
-		case CAT_G_ATTACK:
-			tempList = ground_attackers;
-			break;
-		case CAT_DEFENCE:
-			tempList = ground_defences;
-			break;
-		case CAT_BUILDER:
-			tempList = ground_builders;
-			break;
-		case CAT_FACTORY:
-			tempList = ground_factories;
-			break;
-		case CAT_MSTOR:
-			tempList = metal_storages;
-			break;
-		case CAT_ESTOR:
-			tempList = energy_storages;
-			break;
-		case CAT_NUKE:
-			tempList = nuke_silos;
-			break;
-	}
-
-	// if we are a builder on side i, then templist must have
-	// at least i + 1 elements (templist[0], ..., templist[i])
-	// but if a mod is not symmetric (eg. no builders for side
-	// 1) this assumption fails; enabling this breaks PURE 0.6
-	// however
-	//
-	// if (tempList-&gt;size() &gt;= side + 1) {
-		// iterate over all units for &lt;side&gt; in tempList (eg. Core ground_defences)
-		for (unsigned int i = 0; i != tempList[side].size(); i++) {
-			int tempUnitDefID = tempList[side][i];
-
-			// if our builder can build the i-th unit
-			if (CanBuildUnit(builderDef-&gt;id, tempUnitDefID)) {
-				// get the unit's heuristic score (based on current income)
-				tempScore = GetScore(unitTypes[tempUnitDefID].def, category);
-
-				if (tempScore &gt; bestScore) {
-					bestScore = tempScore;
-					tempUnitDef = unitTypes[tempUnitDefID].def;
-				}
-			}
-		}
-	// }
-
-	// if we didn't find a unit to build with score &gt; 0 (ie.
-	// if builder has no build-option matching this category)
-	// then return NULL instead of first option on build menu
-	// (to prevent radar farms and other bizarro side-effects)
-	return ((bestScore &gt; 0.0f)? tempUnitDef: NULL);
-}
-
-
-
-
-
-
-/*
- * find and return the unit that's best to make for this builder
- * (returns NULL if no buildings/units are better than minUsefulness
- * or buidler can't make any economy units)
- * TODO: make it, look at how to integrate into the main economy manager
- */
-/*
-const UnitDef* CUnitTable::GetBestEconomyBuilding(int builder, float minUsefulness) {
-	return 0;
-}
-*/
-
-
-
-
-void CUnitTable::Init() {
-	// get the unitdefs and stick them in the unitTypes[] array
-	numOfUnits = ai-&gt;cb-&gt;GetNumUnitDefs();
-	unitList = new const UnitDef*[numOfUnits];
-	ai-&gt;cb-&gt;GetUnitDefList(unitList);
-
-	// one more than needed because [0] is a dummy object (so
-	// UnitDef-&gt;id can be used to adress that unit in array)
-	unitTypes = new UnitType[numOfUnits + 1];
-
-	// add units to UnitTable
-	for (int i = 1; i &lt;= numOfUnits; i++) {
-		unitTypes[i].def = unitList[i - 1];
-		// side has not been assigned - will be done later
-		unitTypes[i].category = -1;
-
-		// GetUnitDefList() filled our unitList
-		// partially with null UnitDef*'s (bad,
-		// nothing much to do if this happens)
-		assert(unitTypes[i].def != 0x0);
-
-		// get build options
-		for (map&lt;int, string&gt;::const_iterator j = unitTypes[i].def-&gt;buildOptions.begin(); j != unitTypes[i].def-&gt;buildOptions.end(); j++) {
-			const char* buildOptionName = j-&gt;second.c_str();
-			const UnitDef* buildOptionDef = ai-&gt;cb-&gt;GetUnitDef(buildOptionName);
-			unitTypes[i].canBuildList.push_back(buildOptionDef-&gt;id);
-		}
-	}
-
-	// now set sides and create buildtree for each
-	// note: this skips Lua commanders completely!
-	for (int s = 0; s &lt; numOfSides; s++) {
-		// set side of start unit (eg. commander) and continue recursively
-		int unitDefID = startUnits[s];
-		unitTypes[unitDefID].sides.insert(s);
-
-		CalcBuildTree(unitDefID, s);
-	}
-
-	// add unit to different groups
-	for (int i = 1; i &lt;= numOfUnits; i++) {
-		UnitType* me = &amp;unitTypes[i];
-
-		// KLOOTNOTE: this is a hack to make KAIK recognize Lua
-		// commanders ((which are unreachable from the starting
-		// units in the mod hierarchy and so will be skipped by
-		// CalcBuildTree(), meaning me-&gt;sides stays empty)) as
-		// builders, but the ground_builders[side] list for this
-		// unit might not exist (and will never actually contain
-		// this unitDef ID)
-		if (/* me-&gt;def-&gt;isCommander &amp;&amp; */ me-&gt;def-&gt;buildOptions.size() &gt; 0) {
-			me-&gt;category = CAT_BUILDER;
-		}
-
-		for (std::set&lt;int&gt;::iterator it = me-&gt;sides.begin(); it != me-&gt;sides.end(); it++) {
-			int mySide = *it;
-			int UnitCost = int(me-&gt;def-&gt;metalCost * METAL2ENERGY + me-&gt;def-&gt;energyCost);
-			me-&gt;TargetCategories.resize(me-&gt;def-&gt;weapons.size());
-
-			if (me-&gt;def-&gt;filename.find(&quot;.lua&quot;) != std::string::npos) {
-				// can't parse these without a Lua parser
-				for (unsigned int w = 0; w != me-&gt;def-&gt;weapons.size(); w++) {
-					me-&gt;TargetCategories[w] = &quot;&quot;;
-				}
-			} else {
-				CSunParser attackerParser(ai);
-				attackerParser.LoadVirtualFile(me-&gt;def-&gt;filename.c_str());
-
-				for (unsigned int w = 0; w != me-&gt;def-&gt;weapons.size(); w++) {
-					char weaponnumber[10] = &quot;&quot;;
-					itoa(w, weaponnumber, 10);
-					attackerParser.GetDef(me-&gt;TargetCategories[w], &quot;-1&quot;, string(&quot;UNITINFO\\OnlyTargetCategory&quot;) + string(weaponnumber));
-				}
-			}
-
-
-			me-&gt;DPSvsUnit.resize(numOfUnits + 1);
-
-			// calculate this unit type's DPS against all other unit types
-			for (int v = 1; v &lt;= numOfUnits; v++) {
-				me-&gt;DPSvsUnit[v] = GetDPSvsUnit(me-&gt;def, unitTypes[v].def);
-			}
-
-			// speed &gt; 0 means we are mobile, minWaterDepth &lt;= 0 means we
-			// are allergic to water and cannot be in it (positive values
-			// are inverted internally)
-			if (me-&gt;def-&gt;speed &gt; 0.0f /* &amp;&amp; me-&gt;def-&gt;minWaterDepth &lt;= 0 */) {
-				if (me-&gt;def-&gt;buildOptions.size() &gt; 0) {
-					ground_builders[mySide].push_back(i);
-					me-&gt;category = CAT_BUILDER;
-				}
-				else if (!me-&gt;def-&gt;weapons.empty() &amp;&amp; !me-&gt;def-&gt;weapons.begin()-&gt;def-&gt;stockpile) {
-					ground_attackers[mySide].push_back(i);
-					me-&gt;category = CAT_G_ATTACK;
-				}
-			}
-
-
-
-			else if (!me-&gt;def-&gt;canfly) {
-				if (true /* me-&gt;def-&gt;minWaterDepth &lt;= 0 */) {
-					if (me-&gt;def-&gt;buildOptions.size() &gt;= 1 &amp;&amp; me-&gt;def-&gt;builder) {
-						if ((((me-&gt;def)-&gt;TEDClassString) == &quot;PLANT&quot;) || (((me-&gt;def)-&gt;speed) &gt; 0.0f)) {
-							me-&gt;isHub = false;
-						} else {
-							me-&gt;isHub = true;
-						}
-
-						ground_factories[mySide].push_back(i);
-						me-&gt;category = CAT_FACTORY;
-					}
-					else {
-						const WeaponDef* weapon = (me-&gt;def-&gt;weapons.empty())? 0: me-&gt;def-&gt;weapons.begin()-&gt;def;
-
-						if (weapon &amp;&amp; !weapon-&gt;stockpile &amp;&amp; me-&gt;def-&gt;extractsMetal == 0.0f) {
-							// we don't want armed extractors to be seen as general-purpose defense
-							if (!weapon-&gt;waterweapon) {
-								// filter out depth-charge launchers etc
-								ground_defences[mySide].push_back(i);
-								me-&gt;category = CAT_DEFENCE;
-							}
-						}
-
-						if (me-&gt;def-&gt;stockpileWeaponDef) {
-							if (me-&gt;def-&gt;stockpileWeaponDef-&gt;targetable) {
-								// nuke
-								nuke_silos[mySide].push_back(i);
-								me-&gt;category = CAT_NUKE;
-							}
-							if (me-&gt;def-&gt;stockpileWeaponDef-&gt;interceptor) {
-								// anti-nuke, not implemented yet
-							}
-						}
-
-						if (me-&gt;def-&gt;shieldWeaponDef &amp;&amp; me-&gt;def-&gt;shieldWeaponDef-&gt;isShield) {
-							// shield, not implemented yet
-							// me-&gt;category = CAT_SHIELD;
-						}
-
-						if (me-&gt;def-&gt;makesMetal) {
-							metal_makers[mySide].push_back(i);
-							me-&gt;category = CAT_MMAKER;
-						}
-						if (me-&gt;def-&gt;extractsMetal &gt; 0.0f) {
-							metal_extractors[mySide].push_back(i);
-							me-&gt;category = CAT_MEX;
-						}
-						if (((me-&gt;def-&gt;energyMake - me-&gt;def-&gt;energyUpkeep) / UnitCost) &gt; 0.002 || me-&gt;def-&gt;tidalGenerator || me-&gt;def-&gt;windGenerator) {
-							if (/* me-&gt;def-&gt;minWaterDepth &lt;= 0 &amp;&amp; */ !me-&gt;def-&gt;needGeo) {
-								// filter tidals and geothermals
-								ground_energy[mySide].push_back(i);
-								me-&gt;category = CAT_ENERGY;
-							}
-						}
-						if (me-&gt;def-&gt;energyStorage / UnitCost &gt; 0.2) {
-							energy_storages[mySide].push_back(i);
-							me-&gt;category = CAT_ESTOR;
-						}
-						if (me-&gt;def-&gt;metalStorage / UnitCost &gt; 0.1) {
-							metal_storages[mySide].push_back(i);
-							me-&gt;category = CAT_MSTOR;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	ReadModConfig();
-	// dump generated unit table to file
-	DebugPrint();
-}
-
-
-
-
-
-bool CUnitTable::CanBuildUnit(int id_builder, int id_unit) {
-	// look in build options of builder for unit
-	for (unsigned int i = 0; i != unitTypes[id_builder].canBuildList.size(); i++) {
-		if (unitTypes[id_builder].canBuildList[i] == id_unit) {
-			return true;
-		}
-	}
-
-	// unit not found in builder's buildoptions
-	return false;
-}
-
-// determines sides of unitTypes by recursion
-void CUnitTable::CalcBuildTree(int unitDefID, int rootSide) {
-	UnitType* utype = &amp;unitTypes[unitDefID];
-
-	// go through all possible build options
-	for (unsigned int i = 0; i != utype-&gt;canBuildList.size(); i++) {
-		// add this unit to target's built-by list
-		int buildOptionIndex = utype-&gt;canBuildList[i];
-		UnitType* buildOptionType = &amp;unitTypes[buildOptionIndex];
-
-		// KLOOTNOTE: techLevel will not make much sense if
-		// unit has multiple ancestors at different depths
-		// in tree (eg. Adv. Vehicle Plants in XTA)
-		//
-		// buildOptionType-&gt;techLevel = utype-&gt;techLevel;
-		// buildOptionType-&gt;techLevel = utype-&gt;def-&gt;techLevel;
-		// FIXME: causes duplicated entries in PURE
-		// buildOptionType-&gt;builtByList.push_back(unitDefID);
-
-		if (buildOptionType-&gt;sides.find(rootSide) == buildOptionType-&gt;sides.end()) {
-			// unit has not been checked yet, set side
-			// as side of its builder and continue
-			buildOptionType-&gt;sides.insert(rootSide);
-			CalcBuildTree(buildOptionIndex, rootSide);
-		}
-	}
-}
-
-
-
-void CUnitTable::DebugPrint() {
-	if (!unitList)
-		return;
-
-	// NOTE: same order as all_lists, not as CAT_* enum
-	const char* listCategoryNames[12] = {
-		&quot;GROUND-FACTORY&quot;, &quot;GROUND-BUILDER&quot;, &quot;GROUND-ATTACKER&quot;, &quot;METAL-EXTRACTOR&quot;,
-		&quot;METAL-MAKER&quot;, &quot;GROUND-ENERGY&quot;, &quot;GROUND-DEFENSE&quot;, &quot;METAL-STORAGE&quot;,
-		&quot;ENERGY-STORAGE&quot;, &quot;NUKE-SILO&quot;, &quot;SHIELD-GENERATOR&quot;, &quot;LAST-CATEGORY&quot;
-	};
-
-	char filename[1024] = ROOTFOLDER&quot;CUnitTable.log&quot;;
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
-	FILE* file = fopen(filename, &quot;w&quot;);
-
-	for (int i = 1; i &lt;= numOfUnits; i++) {
-		UnitType* utype = &amp;unitTypes[i];
-
-		fprintf(file, &quot;UnitDef ID: %i\n&quot;, i);
-		fprintf(file, &quot;Name:       %s\n&quot;, unitList[i - 1]-&gt;humanName.c_str());
-		fprintf(file, &quot;Sides:      &quot;);
-
-		for (std::set&lt;int&gt;::iterator it = utype-&gt;sides.begin(); it != utype-&gt;sides.end(); it++) {
-			fprintf(file, &quot;%d (%s) &quot;, *it, sideNames[*it].c_str());
-		}
-
-		fprintf(file, &quot;\n&quot;);
-		fprintf(file, &quot;Can Build:  &quot;);
-
-		for (unsigned int j = 0; j != utype-&gt;canBuildList.size(); j++) {
-			UnitType* buildOption = &amp;unitTypes[utype-&gt;canBuildList[j]];
-
-			for (std::set&lt;int&gt;::iterator it = buildOption-&gt;sides.begin(); it != buildOption-&gt;sides.end(); it++) {
-				const char* sideName = sideNames[*it].c_str();
-				const char* buildOptionName = buildOption-&gt;def-&gt;humanName.c_str();
-				fprintf(file, &quot;'(%s) %s' &quot;, sideName, buildOptionName);
-			}
-		}
-
-		fprintf(file, &quot;\n&quot;);
-		fprintf(file, &quot;Built by:   &quot;);
-
-		for (unsigned int k = 0; k != utype-&gt;builtByList.size(); k++) {
-			UnitType* parent = &amp;unitTypes[utype-&gt;builtByList[k]];
-
-			for (std::set&lt;int&gt;::iterator it = parent-&gt;sides.begin(); it != parent-&gt;sides.end(); it++) {
-				const char* sideName = sideNames[*it].c_str();
-				const char* parentName = parent-&gt;def-&gt;humanName.c_str();
-				fprintf(file, &quot;'(%s) %s' &quot;, sideName, parentName);
-			}
-		}
-
-		fprintf(file, &quot;\n\n&quot;);
-	}
-
-	for (int s = 0; s &lt; numOfSides; s++) {
-		for (unsigned int l = 0; l != all_lists.size(); l++) {
-			fprintf(file, &quot;\n\n%s (side %d) units of category %s:\n&quot;, sideNames[s].c_str(), s, listCategoryNames[l]);
-
-			for (unsigned int i = 0; i != all_lists[l][s].size(); i++)
-				fprintf(file, &quot;\t%s\n&quot;, unitTypes[all_lists[l][s][i]].def-&gt;humanName.c_str());
-		}
-	}
-
-	fclose(file);
-}
-
-
-
-
-float CUnitTable::GetMaxRange(const UnitDef* unit) {
-	float max_range = 0.0f;
-
-	for (vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = unit-&gt;weapons.begin(); i != unit-&gt;weapons.end(); i++) {
-		if ((i-&gt;def-&gt;range) &gt; max_range)
-			max_range = i-&gt;def-&gt;range;
-	}
-
-	return max_range;
-}
-
-float CUnitTable::GetMinRange(const UnitDef* unit) {
-	float min_range = FLT_MAX;
-
-	for (vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = unit-&gt;weapons.begin(); i != unit-&gt;weapons.end(); i++) {
-		if ((i-&gt;def-&gt;range) &lt; min_range)
-			min_range = i-&gt;def-&gt;range;
-	}
-
-	return min_range;
-}
+// Based on Submarine's BuildTable Class from AAI. Thanks sub!
+
+#include &quot;UnitTable.h&quot;
+
+#include &quot;Sim/Misc/GlobalConstants.h&quot;
+#include &quot;System/Util.h&quot;
+
+/// CR_BIND(CUnitTable, );
+/// CR_REG_METADATA(CUnitTable, (
+/// 	CR_MEMBER(all_lists),
+/// 	CR_MEMBER(ground_factories),
+/// 	CR_MEMBER(ground_builders),
+/// 	CR_MEMBER(ground_attackers),
+/// 	CR_MEMBER(metal_extractors),
+/// 	CR_MEMBER(metal_makers),
+/// 	CR_MEMBER(ground_energy),
+/// 	CR_MEMBER(ground_defences),
+/// 	CR_MEMBER(metal_storages),
+/// 	CR_MEMBER(energy_storages),
+/// 	CR_MEMBER(nuke_silos),
+///
+/// 	CR_MEMBER(numOfSides),
+/// 	CR_MEMBER(sideNames),
+/// 	CR_MEMBER(modSideMap),
+/// 	CR_MEMBER(teamSides),
+///
+/// 	CR_MEMBER(unitTypes)
+/// ));
+
+
+CUnitTable::CUnitTable(AIClasses* ai) {
+	this-&gt;ai = ai;
+
+	numOfUnits = 0;
+	unitList = 0;
+
+	BuildModSideMap();
+	ReadTeamSides();
+
+	// now set up the unit lists
+	ground_factories = new vector&lt;int&gt;[numOfSides];
+	ground_builders = new vector&lt;int&gt;[numOfSides];
+	ground_attackers = new vector&lt;int&gt;[numOfSides];
+	metal_extractors = new vector&lt;int&gt;[numOfSides];
+	metal_makers = new vector&lt;int&gt;[numOfSides];
+	ground_energy = new vector&lt;int&gt;[numOfSides];
+	ground_defences = new vector&lt;int&gt;[numOfSides];
+	metal_storages = new vector&lt;int&gt;[numOfSides];
+	energy_storages = new vector&lt;int&gt;[numOfSides];
+	nuke_silos = new vector&lt;int&gt;[numOfSides];
+
+	all_lists.push_back(ground_factories);	// CAT_FACTORY  (idx: 0, cat enum:  7)
+	all_lists.push_back(ground_builders);	// CAT_BUILDER  (idx: 1, cat enum:  4)
+	all_lists.push_back(ground_attackers);	// CAT_G_ATTACK (idx: 2, cat enum:  9)
+	all_lists.push_back(metal_extractors);	// CAT_MEX      (idx: 3, cat enum:  2)
+	all_lists.push_back(metal_makers);		// CAT_MMAKER   (idx: 4, cat enum:  3)
+	all_lists.push_back(ground_energy);		// CAT_ENERGY   (idx: 5, cat enum:  1)
+	all_lists.push_back(ground_defences);	// CAT_DEFENCE  (idx: 6, cat enum:  8)
+	all_lists.push_back(metal_storages);	// CAT_MSTOR    (idx: 7, cat enum:  6)
+	all_lists.push_back(energy_storages);	// CAT_ESTOR    (idx: 8, cat enum:  5)
+	all_lists.push_back(nuke_silos);		// CAT_NUKE     (idx: 9, cat enum: 10)
+}
+
+CUnitTable::~CUnitTable() {
+	delete[] unitTypes;
+	delete[] unitList;
+
+	delete[] ground_factories;
+	delete[] ground_builders;
+	delete[] ground_attackers;
+	delete[] metal_extractors;
+	delete[] metal_makers;
+	delete[] ground_energy;
+	delete[] ground_defences;
+	delete[] metal_storages;
+	delete[] energy_storages;
+	delete[] nuke_silos;
+}
+
+
+int CUnitTable::BuildModSideMap() {
+	L(&quot;[CUnitTable::BuildModSideMap()]&quot;);
+
+	// get all sides and commanders
+	std::string commKey;	// eg. &quot;SIDE4\\commander&quot;
+	std::string commName;	// eg. &quot;arm_commander&quot;
+	std::string sideKey;	// eg. &quot;SIDE4\\name&quot;
+	std::string sideName;	// eg. &quot;Arm&quot;
+	char sideNum[64] = {0};
+
+	// FIXME: can be a .lua script now
+	ai-&gt;parser-&gt;LoadVirtualFile(&quot;gamedata\\SIDEDATA.tdf&quot;);
+
+	// look at SIDE0 through SIDE9
+	// (should be enough for any mod)
+	for (int side = 0; side &lt; 10; side++) {
+		sprintf(sideNum, &quot;%i&quot;, side);
+
+		commKey = &quot;SIDE&quot; + std::string(sideNum) + &quot;\\commander&quot;;
+		sideKey = &quot;SIDE&quot; + std::string(sideNum) + &quot;\\name&quot;;
+
+		ai-&gt;parser-&gt;GetDef(commName, &quot;-1&quot;, commKey);
+		const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(commName.c_str());
+
+		if (udef) {
+			// if this unit exists, the side is valid too
+			startUnits.push_back(udef-&gt;id);
+			ai-&gt;parser-&gt;GetDef(sideName, &quot;-1&quot;, sideKey);
+
+			// transform the side string to lower-case
+			StringToLowerInPlace(sideName);
+
+			sideNames.push_back(sideName);
+			modSideMap[sideName] = side;
+			numOfSides = side + 1;
+
+			L(&quot;\tside index: &quot; &lt;&lt; side &lt;&lt; &quot;, root unit: &quot; &lt;&lt; udef-&gt;name &lt;&lt; &quot;, side name: &quot; &lt;&lt; sideName &lt;&lt; &quot;, &quot; &lt;&lt; sideName &lt;&lt; &quot; ==&gt; &quot; &lt;&lt; side);
+		} else {
+			L(&quot;\tside &quot; &lt;&lt; side &lt;&lt; &quot; not defined&quot;);
+		}
+	}
+
+	return numOfSides;
+}
+
+int CUnitTable::ReadTeamSides() {
+	L(&quot;[CUnitTable::ReadTeamSides()]&quot;);
+
+	teamSides.resize(MAX_TEAMS, 0);
+	teamSides[0] = 0;	// team 0 defaults to side 0 (in GlobalAI startscript)
+	teamSides[1] = 1;	// team 1 defaults to side 1 (in GlobalAI startscript)
+
+	for (int team = 0; team &lt; MAX_TEAMS; team++) {
+		const char* sideKey = ai-&gt;cb-&gt;GetTeamSide(team);
+
+		if (sideKey) {
+			// FIXME: Gaia-team side?
+			// team index was valid (and we are in a GameSetup-type
+			// game), override the default side index for this team
+			teamSides[team] = modSideMap[sideKey];
+
+			L(&quot;\tteam: &quot; &lt;&lt; team &lt;&lt; &quot;, side: &quot; &lt;&lt; modSideMap[sideKey] &lt;&lt; &quot; (index: &quot; &lt;&lt; teamSides[team] &lt;&lt; &quot;)&quot;);
+		} else {
+			L(&quot;\tno \&quot;game\\team\\side\&quot; value found for team &quot; &lt;&lt; team);
+		}
+	}
+
+	return teamSides[ai-&gt;cb-&gt;GetMyTeam()];
+}
+
+// called at the end of Init()
+void CUnitTable::ReadModConfig() {
+	L(&quot;[CUnitTable::ReadModConfig()]&quot;);
+
+	const char* modName = ai-&gt;cb-&gt;GetModName();
+	char configFileName[1024] = {'\0'};
+	char logMsg[2048] = {'\0'};
+	std::string cfgFolderStr = CFGFOLDER;
+	snprintf(configFileName, 1023, &quot;%s%s.cfg&quot;, cfgFolderStr.c_str(), modName);
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, configFileName);
+
+	FILE* f = fopen(configFileName, &quot;r&quot;);
+
+	if (f) {
+		L(&quot;\tparsing existing mod configuration file &quot; &lt;&lt; configFileName);
+
+		// read the mod's .cfg file
+		char str[1024];
+		char name[512];
+		float costMult = 1.0f;
+		int techLvl = -1;
+		int category = -1;
+
+		while (fgets(str, 1024, f) != 0x0) {
+			if (str[0] == '/' &amp;&amp; str[1] == '/') {
+				continue;
+			}
+
+			int i = sscanf(str, &quot;%s %f %d %d&quot;, name, &amp;costMult, &amp;techLvl, &amp;category);
+			const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(name);
+
+			if ((i == 4) &amp;&amp; udef) {
+				UnitType* utype = &amp;unitTypes[udef-&gt;id];
+				utype-&gt;costMultiplier = costMult;
+				utype-&gt;techLevel = techLvl;
+
+				L(&quot;\t\tudef-&gt;id: &quot; &lt;&lt; udef-&gt;id &lt;&lt; &quot;, udef-&gt;name: &quot; &lt;&lt; udef-&gt;name &lt;&lt; &quot;, utype-&gt;category: &quot; &lt;&lt; utype-&gt;category &lt;&lt; &quot;, .cfg category: &quot; &lt;&lt; category);
+
+				// TODO: look for any possible side-effects that might arise
+				// from overriding categories like this, then enable overrides
+				// other than builder --&gt; attacker?
+				// FIXME: SEGV when unarmed CAT_BUILDER units masquerading as
+				// CAT_G_ATTACK'ers want to or are attacked
+				if (category &gt;= 0 &amp;&amp; category &lt; LASTCATEGORY) {
+					if (category == CAT_G_ATTACK &amp;&amp; utype-&gt;category == CAT_BUILDER) {
+						L(&quot;\t\t\t.cfg category (CAT_G_ATTACK) overrides utype-&gt;category (CAT_BUILDER)&quot;);
+
+						// maps unit categories to indices into all_lists
+						// FIXME: hackish, poorly maintainable, bad style
+						int catLstIdx[11] = {0, 5, 3, 4, 1, 8, 7, 0, 6, 2, 9};
+
+						// index of sublist (eg. ground_builders) that ::Init() thinks it belongs to
+						int idx1 = catLstIdx[utype-&gt;category];
+						// index of sublist (eg. ground_attackers) that mod .cfg says it belongs to
+						int idx2 = catLstIdx[category];
+
+						if (idx1 != idx2) {
+							std::vector&lt;int&gt;* oldLst = all_lists[idx1];	// old category list
+							std::vector&lt;int&gt;* newLst = all_lists[idx2];	// new category list
+							std::set&lt;int&gt;::iterator sit;
+							std::vector&lt;int&gt;::iterator vit;
+
+							for (sit = utype-&gt;sides.begin(); sit != utype-&gt;sides.end(); sit++) {
+								int side = *sit;
+
+								for (vit = oldLst[side].begin(); vit != oldLst[side].end(); vit++) {
+									int udefID = *vit;
+
+									if (udefID == udef-&gt;id) {
+										oldLst[side].erase(vit);
+										newLst[side].push_back(udef-&gt;id);
+										vit--;
+									}
+								}
+							}
+
+							utype-&gt;category = category;
+						}
+					}
+				}
+			}
+		}
+
+		sprintf(logMsg, &quot;read mod configuration file %s&quot;, configFileName);
+	} else {
+		L(&quot;\tcreating new mod configuration file &quot; &lt;&lt; configFileName);
+
+		// write a new .cfg file with default values
+		f = fopen(configFileName, &quot;w&quot;);
+		fprintf(f, &quot;// unitName costMultiplier techLevel category\n&quot;);
+
+		for (int i = 1; i &lt;= numOfUnits; i++) {
+			UnitType* utype = &amp;unitTypes[i];
+			// assign and write default values for costMultiplier
+			// and techLevel, category is already set in ::Init()
+			utype-&gt;costMultiplier = 1.0f;
+			utype-&gt;techLevel = -1;
+			fprintf(f, &quot;%s %.2f %d %d\n&quot;, utype-&gt;def-&gt;name.c_str(), utype-&gt;costMultiplier, utype-&gt;techLevel, utype-&gt;category);
+
+			L(&quot;\t\tname: &quot; &lt;&lt; (utype-&gt;def-&gt;name) &lt;&lt; &quot;, .cfg category: &quot; &lt;&lt; (utype-&gt;category));
+		}
+
+		sprintf(logMsg, &quot;wrote mod configuration file %s&quot;, configFileName);
+	}
+
+	ai-&gt;cb-&gt;SendTextMsg(logMsg, 0);
+	fclose(f);
+}
+
+
+
+int CUnitTable::GetSide(int unitID) {
+	int team = ai-&gt;cb-&gt;GetUnitTeam(unitID);
+	int side = teamSides[team];
+
+	return side;
+}
+
+int CUnitTable::GetCategory(const UnitDef* unitdef) {
+	return unitTypes[unitdef-&gt;id].category;
+}
+
+int CUnitTable::GetCategory(int unit) {
+	const UnitDef* udef = ai-&gt;cb-&gt;GetUnitDef(unit);
+
+	if (udef != NULL) {
+		UnitType&amp; utype = unitTypes[udef-&gt;id];
+		return (utype.category);
+	} else {
+		return -1;
+	}
+}
+
+
+
+// used to update threat-map, should probably
+// use cost multipliers too (but in that case
+// non-squad units like Flashes could become
+// artifically overrated by a massive amount)
+float CUnitTable::GetDPS(const UnitDef* unit) {
+	if (unit) {
+		float totaldps = 0.0f;
+
+		for (vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = unit-&gt;weapons.begin(); i != unit-&gt;weapons.end(); i++) {
+			float dps = 0.0f;
+
+			if (!i-&gt;def-&gt;paralyzer) {
+				float reloadtime = i-&gt;def-&gt;reload;
+				int numberofdamages;
+				ai-&gt;cb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numberofdamages);
+
+				for (int k = 0; k &lt; numberofdamages; k++) {
+					dps += i-&gt;def-&gt;damages[k];
+				}
+
+				dps = dps * i-&gt;def-&gt;salvosize / numberofdamages / reloadtime;
+			}
+
+			totaldps += dps;
+		}
+
+		return totaldps;
+	}
+
+	return 0.0f;
+}
+
+
+
+float CUnitTable::GetDPSvsUnit(const UnitDef* unit, const UnitDef* victim) {
+	if (unit-&gt;weapons.size()) {
+		ai-&gt;math-&gt;TimerStart();
+
+		float dps = 0.0f;
+		bool canhit = false;
+		int armortype = victim-&gt;armorType;
+		int numberofdamages = 0;
+		ai-&gt;cb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numberofdamages);
+
+		for (unsigned int i = 0; i != unit-&gt;weapons.size(); i++) {
+			if (!unit-&gt;weapons[i].def-&gt;paralyzer) {
+				unsigned int a = victim-&gt;category;
+				unsigned int b = unit-&gt;weapons[i].def-&gt;onlyTargetCategory;	// what the weapon can target
+				unsigned int c = unit-&gt;weapons[i].onlyTargetCat;			// what the unit accepts as this weapons target
+//				unsigned int d = unit-&gt;weapons[i].badTargetCat;				// what the unit thinks this weapon must be used for (?)
+				bool canWeaponTarget = (a &amp; b) &gt; 0;
+				bool canUnitTarget = (a &amp; c) &gt; 0;							// how is this used?
+//				bool badUnitTarget = (a &amp; d) &gt; 0;							// probably means that it has low priority
+
+				canhit = (canWeaponTarget &amp;&amp; canUnitTarget);
+
+				if (!unit-&gt;weapons[i].def-&gt;waterweapon &amp;&amp; ai-&gt;cb-&gt;GetUnitDefHeight(victim-&gt;id) - victim-&gt;waterline &lt; 0) {
+					// weapon cannot hit this sub
+					canhit = false;
+				}
+
+				if (unit-&gt;weapons[i].def-&gt;waterweapon &amp;&amp; victim-&gt;minWaterDepth == 0) {
+					// anti-sub weapon cannot kill this unit
+					canhit = false;
+				}
+
+				// bombers are useless against air
+				if (unit-&gt;weapons[i].def-&gt;dropped &amp;&amp; victim-&gt;canfly &amp;&amp; unit-&gt;canfly &amp;&amp; unit-&gt;wantedHeight &lt;= victim-&gt;wantedHeight) {
+					canhit = false;
+				}
+
+				if (canhit) {
+					float accuracy = unit-&gt;weapons[i].def-&gt;accuracy * 2.8;
+
+					if (victim-&gt;speed != 0) {
+						accuracy *= 1 - (unit-&gt;weapons[i].def-&gt;targetMoveError);
+					}
+
+					float basedamage = unit-&gt;weapons[i].def-&gt;damages[armortype] * unit-&gt;weapons[i].def-&gt;salvosize / unit-&gt;weapons[i].def-&gt;reload;
+					float AOE = unit-&gt;weapons[i].def-&gt;areaOfEffect * 0.7;
+					float tohitprobability = 0.0f;
+					float impactarea = 0.0f;
+					float targetarea = 0.0f;
+					float distancetravelled = 0.7f * unit-&gt;weapons[i].def-&gt;range;
+					float firingangle = 0.0f;
+					float gravity = -(ai-&gt;cb-&gt;GetGravity() * 900);
+					float timetoarrive = 0.0f;
+					float u = unit-&gt;weapons[i].def-&gt;projectilespeed * 30;
+
+					if (unit-&gt;weapons[i].def-&gt;type == string(&quot;Cannon&quot;)) {
+						float sinoid = (distancetravelled * gravity) / (u * u);
+						sinoid = std::min(sinoid, 1.0f);
+						firingangle = asin(sinoid) / 2;
+
+						if (unit-&gt;highTrajectoryType == 1) {
+							firingangle = (PI / 2) - firingangle;
+						}
+
+						float heightreached = pow(u * sin(firingangle), 2) / (2 * gravity);
+						float halfd = distancetravelled / 2;
+						distancetravelled = 2 * sqrt(halfd * halfd + heightreached * heightreached) * 1.1;
+					}
+
+					if ((victim-&gt;canfly &amp;&amp; unit-&gt;weapons[i].def-&gt;selfExplode) || !victim-&gt;canfly) {
+						impactarea = pow((accuracy * distancetravelled) + AOE, 2);
+						targetarea = ((victim-&gt;xsize * 16) + AOE) * ((victim-&gt;zsize * 16) + AOE);
+					} else {
+						impactarea = pow((accuracy) * (0.7f * distancetravelled), 2);
+						targetarea = (victim-&gt;xsize * victim-&gt;zsize * 256);
+					}
+
+					if (impactarea &gt; targetarea) {
+						tohitprobability = targetarea / impactarea;
+					} else {
+						tohitprobability = 1;
+					}
+
+					if (unit-&gt;weapons[i].def-&gt;turnrate == 0.0f &amp;&amp; unit-&gt;weapons[i].def-&gt;projectilespeed != 0 &amp;&amp; victim-&gt;speed != 0 &amp;&amp; unit-&gt;weapons[i].def-&gt;beamtime == 1) {
+						if (unit-&gt;weapons[i].def-&gt;type == string(&quot;Cannon&quot;)) {
+							timetoarrive = (2 * u * sin(firingangle)) / gravity;
+						} else {
+							timetoarrive = distancetravelled / (unit-&gt;weapons[i].def-&gt;projectilespeed * 30);
+						}
+
+						float shotwindow = sqrt(targetarea) / victim-&gt;speed * 1.3;
+
+						if (shotwindow &lt; timetoarrive) {
+							tohitprobability *= shotwindow / timetoarrive;
+						}
+					}
+
+					dps += basedamage * tohitprobability;
+				}
+			}
+		}
+
+		return dps;
+	}
+
+	return 0.0f;
+}
+
+
+
+float CUnitTable::GetCurrentDamageScore(const UnitDef* unit) {
+	int enemies[MAX_UNITS];
+	int numEnemies = ai-&gt;cheat-&gt;GetEnemyUnits(enemies);
+	vector&lt;int&gt; enemiesOfType;
+	float score = 0.01f;
+	float totalCost = 0.01f;
+	enemiesOfType.resize(ai-&gt;cb-&gt;GetNumUnitDefs() + 1, 0);
+
+	for (int i = 0; i &lt; numEnemies; i++) {
+		const UnitDef* udef = ai-&gt;cheat-&gt;GetUnitDef(enemies[i]);
+
+		if (udef) {
+			enemiesOfType[udef-&gt;id]++;
+		}
+	}
+
+	for (unsigned int i = 1; i &lt; enemiesOfType.size(); i++) {
+		bool b1 = unitTypes[i].def-&gt;builder;
+		bool b2 = (enemiesOfType[i] &gt; 0);
+		bool b3 = (unitTypes[i].sides.size() &gt; 0);
+		// bool b4 = (!unit-&gt;speed &amp;&amp; !unitTypes[i].def-&gt;speed);
+
+		if (!b1 &amp;&amp; b2 &amp;&amp; b3 /* &amp;&amp; !b4 */) {
+			float currentScore = 0.0f;
+			float costOfEnemiesOfThisType = ((unitTypes[i].def-&gt;metalCost * METAL2ENERGY) + unitTypes[i].def-&gt;energyCost) * enemiesOfType[i];
+			currentScore = unitTypes[unit-&gt;id].DPSvsUnit[i] * costOfEnemiesOfThisType;
+			totalCost += costOfEnemiesOfThisType;
+
+			/*
+			if (unitTypes[i].DPSvsUnit[unit-&gt;id] * costofenemiesofthistype &gt; 0) {
+				currentscore -= (unitTypes[i].DPSvsUnit[unit-&gt;id] * costofenemiesofthistype);
+			}
+			*/
+
+			score += currentScore;
+		}
+	}
+
+	if (totalCost &lt;= 0)
+		return 0.0f;
+
+	return (score / totalCost);
+}
+
+
+
+
+void CUnitTable::UpdateChokePointArray() {
+	vector&lt;float&gt; EnemyCostsByMoveType;
+	EnemyCostsByMoveType.resize(ai-&gt;pather-&gt;NumOfMoveTypes);
+	vector&lt;int&gt; enemiesOfType;
+	float totalCost = 1.0f;
+	int enemies[MAX_UNITS];
+	int numEnemies = ai-&gt;cheat-&gt;GetEnemyUnits(enemies);
+	enemiesOfType.resize(ai-&gt;cb-&gt;GetNumUnitDefs() + 1, 0);
+
+	for (int i = 0; i &lt; ai-&gt;pather-&gt;totalcells; i++) {
+		ai-&gt;dm-&gt;ChokePointArray[i] = 0;
+	}
+	for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes; i++) {
+		EnemyCostsByMoveType[i] = 0;
+	}
+	for (int i = 0; i &lt; numEnemies; i++) {
+		enemiesOfType[ai-&gt;cheat-&gt;GetUnitDef(enemies[i])-&gt;id]++;
+	}
+
+	for (unsigned int i = 1; i &lt; enemiesOfType.size(); i++) {
+		if (unitTypes[i].sides.size() &gt; 0 &amp;&amp; !unitTypes[i].def-&gt;canfly &amp;&amp; unitTypes[i].def-&gt;speed &gt; 0) {
+			float currentcosts = ((unitTypes[i].def-&gt;metalCost * METAL2ENERGY) + unitTypes[i].def-&gt;energyCost) * (enemiesOfType[i]);
+			EnemyCostsByMoveType[unitTypes[i].def-&gt;moveType] += currentcosts;
+			totalCost += currentcosts;
+		}
+	}
+
+	for (int i = 0; i &lt; ai-&gt;pather-&gt;NumOfMoveTypes; i++) {
+		EnemyCostsByMoveType[i] /= totalCost;
+
+		for (int c = 0; c &lt; ai-&gt;pather-&gt;totalcells; c++) {
+			ai-&gt;dm-&gt;ChokePointArray[c] += ai-&gt;dm-&gt;ChokeMapsByMovetype[i][c] * EnemyCostsByMoveType[i];
+		}
+	}
+}
+
+
+
+
+
+
+float CUnitTable::GetScore(const UnitDef* udef, int category) {
+	int m = (ai-&gt;uh-&gt;AllUnitsByType[udef-&gt;id]).size();
+	int n = udef-&gt;maxThisUnit;
+
+	if (m &gt;= n) {
+		// if we've hit the build-limit for this
+		// type of unit, make sure GetUnitByScore()
+		// won't pick it for construction anyway
+		return 0.0f;
+	}
+
+	if (udef-&gt;minWaterDepth &gt; 0) {
+		// we can't swim yet
+		return 0.0f;
+	}
+
+	int frame = ai-&gt;cb-&gt;GetCurrentFrame();
+	float Cost = ((udef-&gt;metalCost * METAL2ENERGY) + udef-&gt;energyCost) + 0.1f;
+	float CurrentIncome = INCOMEMULTIPLIER * (ai-&gt;cb-&gt;GetEnergyIncome() + (ai-&gt;cb-&gt;GetMetalIncome() * METAL2ENERGY)) + frame / 2;
+	float Hitpoints = udef-&gt;health;
+	float buildTime = udef-&gt;buildTime + 0.1f;
+	float benefit = 0.0f;
+	float aoe = 0.0f;
+	float dps = 0.0f;
+	int unitcounter = 0;
+	bool candevelop = false;
+
+	float RandNum = ai-&gt;math-&gt;RandNormal(4, 3, 1) + 1;
+	float randMult = float((rand() % 2) + 1);
+
+	switch (category) {
+		case CAT_ENERGY: {
+			// KLOOTNOTE: factor build-time into this as well
+			// (so benefit values generally lie closer together)
+			// benefit = (udef-&gt;energyMake - udef-&gt;energyUpkeep);
+			// benefit = (udef-&gt;energyMake - udef-&gt;energyUpkeep) * randMult;
+			benefit = ((udef-&gt;energyMake - udef-&gt;energyUpkeep) / buildTime) * randMult;
+
+			if (udef-&gt;windGenerator) {
+				const float minWind = ai-&gt;cb-&gt;GetMinWind();
+				const float maxWind = ai-&gt;cb-&gt;GetMaxWind();
+				const float avgWind = (minWind + maxWind) * 0.5f;
+				if (minWind &gt;= 8.0f || (minWind &gt;= 4.0f &amp;&amp; avgWind &gt;= 8.0f)) {
+					benefit += avgWind;
+				}
+			}
+			if (udef-&gt;tidalGenerator) {
+				benefit += ai-&gt;cb-&gt;GetTidalStrength();
+			}
+
+			// filter geothermals
+			if (udef-&gt;needGeo) {
+				benefit = 0.0f;
+			}
+
+			// KLOOTNOTE: dividing by cost here as well means
+			// benefit is inversely proportional to square of
+			// cost, so expensive generators are quadratically
+			// less likely to be built if original calculation
+			// of score is used
+			// benefit /= Cost;
+		} break;
+
+		case CAT_MEX: {
+			benefit = pow(udef-&gt;extractsMetal, 4.0f);
+		} break;
+		case CAT_MMAKER: {
+			// benefit = ((udef-&gt;metalMake - udef-&gt;metalUpkeep) / udef-&gt;energyUpkeep) + 0.01f;
+			benefit = (udef-&gt;metalMake - udef-&gt;metalUpkeep) / (udef-&gt;energyUpkeep + 0.01f);
+		} break;
+
+		case CAT_G_ATTACK: {
+			dps = GetCurrentDamageScore(udef);
+			aoe = ((udef-&gt;weapons.size())? ((udef-&gt;weapons.front()).def)-&gt;areaOfEffect: 0.0f);
+
+			if (udef-&gt;canfly &amp;&amp; !udef-&gt;hoverAttack) {
+				// TODO: improve to set reload-time to the bomber's
+				// turnspeed vs. movespeed (eg. time taken for a run)
+				dps /= 6;
+			}
+
+			benefit = pow((aoe + 80), 1.5f)
+					* pow(GetMaxRange(udef) + 200, 1.5f)
+					* pow(dps, 1.0f)
+					* pow(udef-&gt;speed + 40, 1.0f)
+					* pow(Hitpoints, 1.0f)
+					* pow(RandNum, 2.5f)
+					* pow(Cost, -0.5f);
+
+			if (udef-&gt;canfly || udef-&gt;canhover) {
+				// general hack: reduce feasibility of aircraft for 20 mins
+				// and that of hovercraft permanently, should mostly prefer
+				// real L2 units to hovers
+				benefit = (udef-&gt;canfly &amp;&amp; frame &gt;= (30 * 60 * 20))? benefit: benefit * 0.01f;
+			}
+		} break;
+
+		case CAT_DEFENCE: {
+			aoe = ((udef-&gt;weapons.size())? ((udef-&gt;weapons.front()).def)-&gt;areaOfEffect: 0.0f);
+			benefit = pow((aoe + 80), 1.5f)
+					* pow(GetMaxRange(udef), 2.0f)
+					* pow(GetCurrentDamageScore(udef), 1.5f)
+					* pow(Hitpoints, 0.5f)
+					* pow(RandNum, 2.5f)
+					* pow(Cost, -1.0f);
+		} break;
+
+		case CAT_BUILDER: {
+			for (unsigned int i = 0; i != unitTypes[udef-&gt;id].canBuildList.size(); i++) {
+				if (unitTypes[unitTypes[udef-&gt;id].canBuildList[i]].category == CAT_FACTORY) {
+					candevelop = true;
+				}
+			}
+
+			// builder units that cannot construct any
+			// factories are worthless, prevent them
+			// from being chosen via GetUnitByScore()
+			// (they might have other uses though, eg.
+			// nano-towers)
+			if (!candevelop) {
+				benefit = 0.0f;
+			} else {
+				benefit = pow(udef-&gt;buildSpeed, 1.0f)
+						* pow(udef-&gt;speed, 0.5f)
+						* pow(Hitpoints, 0.3f)
+						* pow(RandNum, 0.4f);
+			}
+		} break;
+
+		case CAT_FACTORY: {
+			// benefit of a factory is dependant on the kind of
+			// offensive units it can build, but EE-hubs are only
+			// capable of building other buildings
+			for (unsigned int i = 0; i != unitTypes[udef-&gt;id].canBuildList.size(); i++) {
+				int buildOption = unitTypes[udef-&gt;id].canBuildList[i];
+				int buildOptionCategory = unitTypes[buildOption].category;
+
+				if (buildOptionCategory == CAT_G_ATTACK || buildOptionCategory == CAT_FACTORY) {
+					if (unitTypes[buildOption].def != udef) {
+						// KLOOTNOTE: guard against infinite recursion (BuildTowers in
+						// PURE trigger this since they are able to build themselves)
+						benefit += GetScore(unitTypes[buildOption].def, buildOptionCategory);
+						unitcounter++;
+					}
+				}
+			}
+
+			if (unitcounter &gt; 0) {
+				benefit /= (unitcounter * pow(float(ai-&gt;uh-&gt;AllUnitsByType[udef-&gt;id].size() + 1), 3.0f));
+			} else {
+				benefit = 0.0f;
+			}
+		} break;
+
+		case CAT_MSTOR: {
+			benefit = pow((udef-&gt;metalStorage), 1.0f) * pow(Hitpoints, 1.0f);
+		} break;
+		case CAT_ESTOR: {
+			benefit = pow((udef-&gt;energyStorage), 1.0f) * pow(Hitpoints, 1.0f);
+		} break;
+		case CAT_NUKE: {
+			// KLOOTNOTE: should factor damage into this as well
+			float metalcost = udef-&gt;stockpileWeaponDef-&gt;metalcost;
+			float energycost = udef-&gt;stockpileWeaponDef-&gt;energycost;
+			float supplycost = udef-&gt;stockpileWeaponDef-&gt;supplycost;
+			float denom = metalcost + energycost + supplycost + 1.0f;
+			float range = udef-&gt;stockpileWeaponDef-&gt;range;
+			benefit = (udef-&gt;stockpileWeaponDef-&gt;areaOfEffect + range) / denom;
+		} break;
+		/*
+		case CAT_ANTINUKE: {
+			benefit = udef-&gt;stockpileWeaponDef-&gt;coverageRange;
+		} break;
+		case CAT_SHIELD: {
+			benefit = udef-&gt;shieldWeaponDef-&gt;shieldRadius;
+		} break;
+		*/
+		default:
+			benefit = 0.0f;
+	}
+
+	benefit *= unitTypes[udef-&gt;id].costMultiplier;
+	// return (benefit / (CurrentIncome + Cost));
+	// return ((benefit / Cost) * CurrentIncome);
+	return ((CurrentIncome / Cost) * benefit);
+}
+
+
+
+// operates in terms of GetScore() (which is recursive for factories)
+const UnitDef* CUnitTable::GetUnitByScore(int builderUnitID, int category) {
+	if (category == LASTCATEGORY)
+		return 0x0;
+
+	vector&lt;int&gt;* tempList = 0;
+	const UnitDef* builderDef = ai-&gt;cb-&gt;GetUnitDef(builderUnitID);
+	const UnitDef* tempUnitDef = 0;
+	int side = GetSide(builderUnitID);
+	float tempScore = 0.0f;
+	float bestScore = 0.0f;
+
+	switch (category) {
+		case CAT_ENERGY:
+			tempList = ground_energy;
+			break;
+		case CAT_MEX:
+			tempList = metal_extractors;
+			break;
+		case CAT_MMAKER:
+			tempList = metal_makers;
+			break;
+		case CAT_G_ATTACK:
+			tempList = ground_attackers;
+			break;
+		case CAT_DEFENCE:
+			tempList = ground_defences;
+			break;
+		case CAT_BUILDER:
+			tempList = ground_builders;
+			break;
+		case CAT_FACTORY:
+			tempList = ground_factories;
+			break;
+		case CAT_MSTOR:
+			tempList = metal_storages;
+			break;
+		case CAT_ESTOR:
+			tempList = energy_storages;
+			break;
+		case CAT_NUKE:
+			tempList = nuke_silos;
+			break;
+	}
+
+	// if we are a builder on side i, then templist must have
+	// at least i + 1 elements (templist[0], ..., templist[i])
+	// but if a mod is not symmetric (eg. no builders for side
+	// 1) this assumption fails; enabling this breaks PURE 0.6
+	// however
+	//
+	// if (tempList-&gt;size() &gt;= side + 1) {
+		// iterate over all units for &lt;side&gt; in tempList (eg. Core ground_defences)
+		for (unsigned int i = 0; i != tempList[side].size(); i++) {
+			int tempUnitDefID = tempList[side][i];
+
+			// if our builder can build the i-th unit
+			if (CanBuildUnit(builderDef-&gt;id, tempUnitDefID)) {
+				// get the unit's heuristic score (based on current income)
+				tempScore = GetScore(unitTypes[tempUnitDefID].def, category);
+
+				if (tempScore &gt; bestScore) {
+					bestScore = tempScore;
+					tempUnitDef = unitTypes[tempUnitDefID].def;
+				}
+			}
+		}
+	// }
+
+	// if we didn't find a unit to build with score &gt; 0 (ie.
+	// if builder has no build-option matching this category)
+	// then return NULL instead of first option on build menu
+	// (to prevent radar farms and other bizarro side-effects)
+	return ((bestScore &gt; 0.0f)? tempUnitDef: NULL);
+}
+
+
+
+
+
+
+/*
+ * find and return the unit that's best to make for this builder
+ * (returns NULL if no buildings/units are better than minUsefulness
+ * or buidler can't make any economy units)
+ * TODO: make it, look at how to integrate into the main economy manager
+ */
+/*
+const UnitDef* CUnitTable::GetBestEconomyBuilding(int builder, float minUsefulness) {
+	return 0;
+}
+*/
+
+
+
+
+void CUnitTable::Init() {
+	// get the unitdefs and stick them in the unitTypes[] array
+	numOfUnits = ai-&gt;cb-&gt;GetNumUnitDefs();
+	unitList = new const UnitDef*[numOfUnits];
+	ai-&gt;cb-&gt;GetUnitDefList(unitList);
+
+	// one more than needed because [0] is a dummy object (so
+	// UnitDef-&gt;id can be used to adress that unit in array)
+	unitTypes = new UnitType[numOfUnits + 1];
+
+	// add units to UnitTable
+	for (int i = 1; i &lt;= numOfUnits; i++) {
+		unitTypes[i].def = unitList[i - 1];
+		// side has not been assigned - will be done later
+		unitTypes[i].category = -1;
+
+		// GetUnitDefList() filled our unitList
+		// partially with null UnitDef*'s (bad,
+		// nothing much to do if this happens)
+		assert(unitTypes[i].def != 0x0);
+
+		// get build options
+		for (map&lt;int, string&gt;::const_iterator j = unitTypes[i].def-&gt;buildOptions.begin(); j != unitTypes[i].def-&gt;buildOptions.end(); j++) {
+			const char* buildOptionName = j-&gt;second.c_str();
+			const UnitDef* buildOptionDef = ai-&gt;cb-&gt;GetUnitDef(buildOptionName);
+			unitTypes[i].canBuildList.push_back(buildOptionDef-&gt;id);
+		}
+	}
+
+	// now set sides and create buildtree for each
+	// note: this skips Lua commanders completely!
+	for (int s = 0; s &lt; numOfSides; s++) {
+		// set side of start unit (eg. commander) and continue recursively
+		int unitDefID = startUnits[s];
+		unitTypes[unitDefID].sides.insert(s);
+
+		CalcBuildTree(unitDefID, s);
+	}
+
+	// add unit to different groups
+	for (int i = 1; i &lt;= numOfUnits; i++) {
+		UnitType* me = &amp;unitTypes[i];
+
+		// KLOOTNOTE: this is a hack to make KAIK recognize Lua
+		// commanders ((which are unreachable from the starting
+		// units in the mod hierarchy and so will be skipped by
+		// CalcBuildTree(), meaning me-&gt;sides stays empty)) as
+		// builders, but the ground_builders[side] list for this
+		// unit might not exist (and will never actually contain
+		// this unitDef ID)
+		if (/* me-&gt;def-&gt;isCommander &amp;&amp; */ me-&gt;def-&gt;buildOptions.size() &gt; 0) {
+			me-&gt;category = CAT_BUILDER;
+		}
+
+		for (std::set&lt;int&gt;::iterator it = me-&gt;sides.begin(); it != me-&gt;sides.end(); it++) {
+			int mySide = *it;
+			int UnitCost = int(me-&gt;def-&gt;metalCost * METAL2ENERGY + me-&gt;def-&gt;energyCost);
+			me-&gt;TargetCategories.resize(me-&gt;def-&gt;weapons.size());
+
+			if (me-&gt;def-&gt;filename.find(&quot;.lua&quot;) != std::string::npos) {
+				// can't parse these without a Lua parser
+				for (unsigned int w = 0; w != me-&gt;def-&gt;weapons.size(); w++) {
+					me-&gt;TargetCategories[w] = &quot;&quot;;
+				}
+			} else {
+				CSunParser attackerParser(ai);
+				attackerParser.LoadVirtualFile(me-&gt;def-&gt;filename.c_str());
+
+				for (unsigned int w = 0; w != me-&gt;def-&gt;weapons.size(); w++) {
+					char weaponnumber[10] = &quot;&quot;;
+					itoa(w, weaponnumber, 10);
+					attackerParser.GetDef(me-&gt;TargetCategories[w], &quot;-1&quot;, string(&quot;UNITINFO\\OnlyTargetCategory&quot;) + string(weaponnumber));
+				}
+			}
+
+
+			me-&gt;DPSvsUnit.resize(numOfUnits + 1);
+
+			// calculate this unit type's DPS against all other unit types
+			for (int v = 1; v &lt;= numOfUnits; v++) {
+				me-&gt;DPSvsUnit[v] = GetDPSvsUnit(me-&gt;def, unitTypes[v].def);
+			}
+
+			// speed &gt; 0 means we are mobile, minWaterDepth &lt;= 0 means we
+			// are allergic to water and cannot be in it (positive values
+			// are inverted internally)
+			if (me-&gt;def-&gt;speed &gt; 0.0f /* &amp;&amp; me-&gt;def-&gt;minWaterDepth &lt;= 0 */) {
+				if (me-&gt;def-&gt;buildOptions.size() &gt; 0) {
+					ground_builders[mySide].push_back(i);
+					me-&gt;category = CAT_BUILDER;
+				}
+				else if (!me-&gt;def-&gt;weapons.empty() &amp;&amp; !me-&gt;def-&gt;weapons.begin()-&gt;def-&gt;stockpile) {
+					ground_attackers[mySide].push_back(i);
+					me-&gt;category = CAT_G_ATTACK;
+				}
+			}
+
+
+
+			else if (!me-&gt;def-&gt;canfly) {
+				if (true /* me-&gt;def-&gt;minWaterDepth &lt;= 0 */) {
+					if (me-&gt;def-&gt;buildOptions.size() &gt;= 1 &amp;&amp; me-&gt;def-&gt;builder) {
+						if ((((me-&gt;def)-&gt;TEDClassString) == &quot;PLANT&quot;) || (((me-&gt;def)-&gt;speed) &gt; 0.0f)) {
+							me-&gt;isHub = false;
+						} else {
+							me-&gt;isHub = true;
+						}
+
+						ground_factories[mySide].push_back(i);
+						me-&gt;category = CAT_FACTORY;
+					}
+					else {
+						const WeaponDef* weapon = (me-&gt;def-&gt;weapons.empty())? 0: me-&gt;def-&gt;weapons.begin()-&gt;def;
+
+						if (weapon &amp;&amp; !weapon-&gt;stockpile &amp;&amp; me-&gt;def-&gt;extractsMetal == 0.0f) {
+							// we don't want armed extractors to be seen as general-purpose defense
+							if (!weapon-&gt;waterweapon) {
+								// filter out depth-charge launchers etc
+								ground_defences[mySide].push_back(i);
+								me-&gt;category = CAT_DEFENCE;
+							}
+						}
+
+						if (me-&gt;def-&gt;stockpileWeaponDef) {
+							if (me-&gt;def-&gt;stockpileWeaponDef-&gt;targetable) {
+								// nuke
+								nuke_silos[mySide].push_back(i);
+								me-&gt;category = CAT_NUKE;
+							}
+							if (me-&gt;def-&gt;stockpileWeaponDef-&gt;interceptor) {
+								// anti-nuke, not implemented yet
+							}
+						}
+
+						if (me-&gt;def-&gt;shieldWeaponDef &amp;&amp; me-&gt;def-&gt;shieldWeaponDef-&gt;isShield) {
+							// shield, not implemented yet
+							// me-&gt;category = CAT_SHIELD;
+						}
+
+						if (me-&gt;def-&gt;makesMetal) {
+							metal_makers[mySide].push_back(i);
+							me-&gt;category = CAT_MMAKER;
+						}
+						if (me-&gt;def-&gt;extractsMetal &gt; 0.0f) {
+							metal_extractors[mySide].push_back(i);
+							me-&gt;category = CAT_MEX;
+						}
+						if (((me-&gt;def-&gt;energyMake - me-&gt;def-&gt;energyUpkeep) / UnitCost) &gt; 0.002 || me-&gt;def-&gt;tidalGenerator || me-&gt;def-&gt;windGenerator) {
+							if (/* me-&gt;def-&gt;minWaterDepth &lt;= 0 &amp;&amp; */ !me-&gt;def-&gt;needGeo) {
+								// filter tidals and geothermals
+								ground_energy[mySide].push_back(i);
+								me-&gt;category = CAT_ENERGY;
+							}
+						}
+						if (me-&gt;def-&gt;energyStorage / UnitCost &gt; 0.2) {
+							energy_storages[mySide].push_back(i);
+							me-&gt;category = CAT_ESTOR;
+						}
+						if (me-&gt;def-&gt;metalStorage / UnitCost &gt; 0.1) {
+							metal_storages[mySide].push_back(i);
+							me-&gt;category = CAT_MSTOR;
+						}
+					}
+				}
+			}
+		}
+	}
+
+	ReadModConfig();
+	// dump generated unit table to file
+	DebugPrint();
+}
+
+
+
+
+
+bool CUnitTable::CanBuildUnit(int id_builder, int id_unit) {
+	// look in build options of builder for unit
+	for (unsigned int i = 0; i != unitTypes[id_builder].canBuildList.size(); i++) {
+		if (unitTypes[id_builder].canBuildList[i] == id_unit) {
+			return true;
+		}
+	}
+
+	// unit not found in builder's buildoptions
+	return false;
+}
+
+// determines sides of unitTypes by recursion
+void CUnitTable::CalcBuildTree(int unitDefID, int rootSide) {
+	UnitType* utype = &amp;unitTypes[unitDefID];
+
+	// go through all possible build options
+	for (unsigned int i = 0; i != utype-&gt;canBuildList.size(); i++) {
+		// add this unit to target's built-by list
+		int buildOptionIndex = utype-&gt;canBuildList[i];
+		UnitType* buildOptionType = &amp;unitTypes[buildOptionIndex];
+
+		// KLOOTNOTE: techLevel will not make much sense if
+		// unit has multiple ancestors at different depths
+		// in tree (eg. Adv. Vehicle Plants in XTA)
+		//
+		// buildOptionType-&gt;techLevel = utype-&gt;techLevel;
+		// buildOptionType-&gt;techLevel = utype-&gt;def-&gt;techLevel;
+		// FIXME: causes duplicated entries in PURE
+		// buildOptionType-&gt;builtByList.push_back(unitDefID);
+
+		if (buildOptionType-&gt;sides.find(rootSide) == buildOptionType-&gt;sides.end()) {
+			// unit has not been checked yet, set side
+			// as side of its builder and continue
+			buildOptionType-&gt;sides.insert(rootSide);
+			CalcBuildTree(buildOptionIndex, rootSide);
+		}
+	}
+}
+
+
+
+void CUnitTable::DebugPrint() {
+	if (!unitList)
+		return;
+
+	// NOTE: same order as all_lists, not as CAT_* enum
+	const char* listCategoryNames[12] = {
+		&quot;GROUND-FACTORY&quot;, &quot;GROUND-BUILDER&quot;, &quot;GROUND-ATTACKER&quot;, &quot;METAL-EXTRACTOR&quot;,
+		&quot;METAL-MAKER&quot;, &quot;GROUND-ENERGY&quot;, &quot;GROUND-DEFENSE&quot;, &quot;METAL-STORAGE&quot;,
+		&quot;ENERGY-STORAGE&quot;, &quot;NUKE-SILO&quot;, &quot;SHIELD-GENERATOR&quot;, &quot;LAST-CATEGORY&quot;
+	};
+
+	char filename[1024];
+	strcpy(filename, ROOTFOLDER);
+	strcat(filename, &quot;CUnitTable.log&quot;);
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
+	FILE* file = fopen(filename, &quot;w&quot;);
+
+	for (int i = 1; i &lt;= numOfUnits; i++) {
+		UnitType* utype = &amp;unitTypes[i];
+
+		fprintf(file, &quot;UnitDef ID: %i\n&quot;, i);
+		fprintf(file, &quot;Name:       %s\n&quot;, unitList[i - 1]-&gt;humanName.c_str());
+		fprintf(file, &quot;Sides:      &quot;);
+
+		for (std::set&lt;int&gt;::iterator it = utype-&gt;sides.begin(); it != utype-&gt;sides.end(); it++) {
+			fprintf(file, &quot;%d (%s) &quot;, *it, sideNames[*it].c_str());
+		}
+
+		fprintf(file, &quot;\n&quot;);
+		fprintf(file, &quot;Can Build:  &quot;);
+
+		for (unsigned int j = 0; j != utype-&gt;canBuildList.size(); j++) {
+			UnitType* buildOption = &amp;unitTypes[utype-&gt;canBuildList[j]];
+
+			for (std::set&lt;int&gt;::iterator it = buildOption-&gt;sides.begin(); it != buildOption-&gt;sides.end(); it++) {
+				const char* sideName = sideNames[*it].c_str();
+				const char* buildOptionName = buildOption-&gt;def-&gt;humanName.c_str();
+				fprintf(file, &quot;'(%s) %s' &quot;, sideName, buildOptionName);
+			}
+		}
+
+		fprintf(file, &quot;\n&quot;);
+		fprintf(file, &quot;Built by:   &quot;);
+
+		for (unsigned int k = 0; k != utype-&gt;builtByList.size(); k++) {
+			UnitType* parent = &amp;unitTypes[utype-&gt;builtByList[k]];
+
+			for (std::set&lt;int&gt;::iterator it = parent-&gt;sides.begin(); it != parent-&gt;sides.end(); it++) {
+				const char* sideName = sideNames[*it].c_str();
+				const char* parentName = parent-&gt;def-&gt;humanName.c_str();
+				fprintf(file, &quot;'(%s) %s' &quot;, sideName, parentName);
+			}
+		}
+
+		fprintf(file, &quot;\n\n&quot;);
+	}
+
+	for (int s = 0; s &lt; numOfSides; s++) {
+		for (unsigned int l = 0; l != all_lists.size(); l++) {
+			fprintf(file, &quot;\n\n%s (side %d) units of category %s:\n&quot;, sideNames[s].c_str(), s, listCategoryNames[l]);
+
+			for (unsigned int i = 0; i != all_lists[l][s].size(); i++)
+				fprintf(file, &quot;\t%s\n&quot;, unitTypes[all_lists[l][s][i]].def-&gt;humanName.c_str());
+		}
+	}
+
+	fclose(file);
+}
+
+
+
+
+float CUnitTable::GetMaxRange(const UnitDef* unit) {
+	float max_range = 0.0f;
+
+	for (vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = unit-&gt;weapons.begin(); i != unit-&gt;weapons.end(); i++) {
+		if ((i-&gt;def-&gt;range) &gt; max_range)
+			max_range = i-&gt;def-&gt;range;
+	}
+
+	return max_range;
+}
+
+float CUnitTable::GetMinRange(const UnitDef* unit) {
+	float min_range = FLT_MAX;
+
+	for (vector&lt;UnitDef::UnitDefWeapon&gt;::const_iterator i = unit-&gt;weapons.begin(); i != unit-&gt;weapons.end(); i++) {
+		if ((i-&gt;def-&gt;range) &lt; min_range)
+			min_range = i-&gt;def-&gt;range;
+	}
+
+	return min_range;
+}

Modified: trunk/AI/Global/RAI/GResourceMap.cpp
===================================================================
--- trunk/AI/Global/RAI/GResourceMap.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/RAI/GResourceMap.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -98,7 +98,7 @@
 				fList[i] = fList[--fSize];
 	}
 
-	resourceFileName = RAIDirectory + &quot;cache/&quot; + string(cb-&gt;GetModName());
+	resourceFileName = cLogFile::GetRAIRootDirectory() + &quot;cache/&quot; + string(cb-&gt;GetModName());
 	resourceFileName.resize(resourceFileName.size()-4);
 	resourceFileName += &quot;-&quot; + string(cb-&gt;GetMapName());
 	resourceFileName.resize(resourceFileName.size()-3);

Modified: trunk/AI/Global/RAI/GTerrainMap.cpp
===================================================================
--- trunk/AI/Global/RAI/GTerrainMap.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/RAI/GTerrainMap.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -14,7 +14,7 @@
 	const int mapFileVersion = 2;
 	waterIsHarmful = false;
 	string mapFileName = cb-&gt;GetMapName();
-	mapFileName = RAIDirectory + &quot;cache/&quot; + mapFileName.substr(0,int(mapFileName.size())-3) + &quot;res&quot;;
+	mapFileName = cLogFile::GetRAIRootDirectory() + &quot;cache/&quot; + mapFileName.substr(0,int(mapFileName.size())-3) + &quot;res&quot;;
 	FILE *mapFile = fopen(mapFileName.c_str(),&quot;rb&quot;);
 	bool mapFileLoaded = false;
 	if( mapFile )

Modified: trunk/AI/Global/RAI/LogFile.cpp
===================================================================
--- trunk/AI/Global/RAI/LogFile.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/RAI/LogFile.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -9,7 +9,7 @@
 
 cLogFile::cLogFile(string sFilename, bool bAppend)
 {
-	logFileName=RAIDirectory+sFilename;
+	logFileName = cLogFile::GetRAIRootDirectory() + sFilename;
 	if( bAppend )
 		logFile = fopen(logFileName.c_str(),&quot;a&quot;);
 //		logFile = new ofstream();
@@ -83,3 +83,9 @@
 //	logFile-&gt;flush();
 }
 */
+
+const std::string&amp; cLogFile::GetRAIRootDirectory() {
+
+	static std::string raiRootDir = &quot;AI/RAI/&quot;;
+	return raiRootDir;
+}

Modified: trunk/AI/Global/RAI/LogFile.h
===================================================================
--- trunk/AI/Global/RAI/LogFile.h	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/RAI/LogFile.h	2008-12-17 19:52:00 UTC (rev 7190)
@@ -10,8 +10,6 @@
 #include &quot;ExternalAI/IAICallback.h&quot;
 using std::string;
 
-const string RAIDirectory = &quot;AI/RAI/&quot;;
-
 class cLogFile
 {
 public:
@@ -21,6 +19,8 @@
 	cLogFile&amp; operator&lt;&lt;(float message);
 	cLogFile&amp; operator&lt;&lt;(string message);
 
+	static const std::string&amp; GetRAIRootDirectory();
+
 private:
 	string logFileName;
 	FILE *logFile;

Modified: trunk/AI/Global/RAI/RAI.cpp
===================================================================
--- trunk/AI/Global/RAI/RAI.cpp	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/AI/Global/RAI/RAI.cpp	2008-12-17 19:52:00 UTC (rev 7190)
@@ -1083,8 +1083,8 @@
 
 void cRAI::ClearLogFiles()
 {
-	const string dataDirectory = RAIDirectory + &quot;cache/&quot;;
-	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)RAIDirectory.c_str() );
+	const string dataDirectory = cLogFile::GetRAIRootDirectory() + &quot;cache/&quot;;
+	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)cLogFile::GetRAIRootDirectory().c_str() );
 	cb-&gt;GetValue( AIVAL_LOCATE_FILE_W, (char*)dataDirectory.c_str() );
 
 	string logFileName;
@@ -1092,22 +1092,22 @@
 	{	
 		char c[2];
 		sprintf(c, &quot;%i&quot;,i);
-		logFileName = RAIDirectory+&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;;
+		logFileName = cLogFile::GetRAIRootDirectory()+&quot;RAI&quot;+string(c)+&quot;_LastGame.log&quot;;
 		remove(logFileName.c_str());
 	}
 
-	logFileName=RAIDirectory+&quot;RAIGlobal_LastGame.log&quot;;
+	logFileName=cLogFile::GetRAIRootDirectory()+&quot;RAIGlobal_LastGame.log&quot;;
 	remove(logFileName.c_str());
-	logFileName=RAIDirectory+&quot;TerrainMapDebug.log&quot;;
+	logFileName=cLogFile::GetRAIRootDirectory()+&quot;TerrainMapDebug.log&quot;;
 	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;PathfinderDebug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;PathfinderDebug.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;PathFinderAPNDebug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;PathFinderAPNDebug.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;PathFinderNPNDebug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;PathFinderNPNDebug.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;Prerequisite.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;Prerequisite.log&quot;;
 //	remove(logFileName.c_str());
-//	logFileName=RAIDirectory+&quot;Debug.log&quot;;
+//	logFileName=cLogFile::GetRAIRootDirectory()+&quot;Debug.log&quot;;
 //	remove(logFileName.c_str());
 }

Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-12-17 13:20:41 UTC (rev 7189)
+++ trunk/SConstruct	2008-12-17 19:52:00 UTC (rev 7190)
@@ -28,10 +28,12 @@
 
 if sys.platform == 'win32':
 	# force to mingw, otherwise picks up msvc
-	env = Environment(tools = ['mingw', 'rts', 'gch'], toolpath = ['.', 'rts/build/scons'])
+	myTools = ['mingw', 'rts', 'gch']
 else:
-	env = Environment(tools = ['default', 'rts',  'gch'], toolpath = ['.', 'rts/build/scons'])
+	myTools = ['default', 'rts', 'gch']
 
+env = Environment(tools = myTools, toolpath = ['.', 'rts/build/scons'])
+
 if env['use_gch']:
 	env['Gch'] = env.Gch('rts/System/StdAfx.h', CPPDEFINES=env['CPPDEFINES']+env['spring_defines'])[0]
 else:
@@ -61,7 +63,7 @@
 	datadir = []
 else:
 	datadir = ['SPRING_DATADIR=&quot;\\&quot;'+os.path.join(env['prefix'], env['datadir'])+'\\&quot;&quot;',
-		   'SPRING_DATADIR_2=&quot;\\&quot;'+os.path.join(env['prefix'], env['libdir'])+'\\&quot;&quot;']
+			'SPRING_DATADIR_2=&quot;\\&quot;'+os.path.join(env['prefix'], env['libdir'])+'\\&quot;&quot;']
 
 # Build DataDirLocater.cpp separately from the other sources.  This is to prevent recompilation of
 # the entire source if one wants to change just the install installprefix (and hence the datadir).
@@ -164,7 +166,7 @@
 # Make a copy of the build environment for the AIs, but remove libraries and add include path.
 # TODO: make separate SConstructs for AIs
 aienv = env.Clone()
-aienv.Append(CPPPATH = ['rts/ExternalAI'])
+aienv.AppendUnique(CPPPATH = ['rts/ExternalAI'])
 aienv.AppendUnique(CPPDEFINES=['USING_CREG'])
 
 # Use subst() to substitute $installprefix in datadir.
@@ -250,6 +252,11 @@
 	else:
 		print &quot;Success building streflop!&quot;
 
+
+################################################################################
+### Run Tests
+################################################################################
+
 # Use this to avoid an error message 'how to make target test ?'
 env.Alias('test', None)
 
@@ -264,7 +271,7 @@
 
 
 ################################################################################
-### Build gamedata zip archives
+### Build gamedata zip archives &amp; misc.
 ################################################################################
 # Can't use these, we can't set the working directory and putting a SConscript
 # in the respective directories doesn't work either because then the SConstript


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001958.html">[Taspring-linux-commit] r7189 - in branches/caiinterface:	Documentation rts/ExternalAI rts/Game rts/Rendering/Env	rts/Rendering/Textures rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/Units/COB rts/System	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/build/vstudio8 rts/lib/gml	tools/unitsync
</A></li>
	<LI>Next message: <A HREF="001960.html">[Taspring-linux-commit] r7191 - trunk/Documentation
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1959">[ date ]</a>
              <a href="thread.html#1959">[ thread ]</a>
              <a href="subject.html#1959">[ subject ]</a>
              <a href="author.html#1959">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
