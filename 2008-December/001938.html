<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7169 - in trunk/rts: Rendering/Env	Rendering/Textures Rendering/UnitModels System/Net	build/vstudio8 lib/gml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7169%20-%20in%20trunk/rts%3A%20Rendering/Env%0A%09Rendering/Textures%20Rendering/UnitModels%20System/Net%0A%09build/vstudio8%20lib/gml&In-Reply-To=%3C20081211143433.C5D9E4760%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001937.html">
   <LINK REL="Next"  HREF="001939.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7169 - in trunk/rts: Rendering/Env	Rendering/Textures Rendering/UnitModels System/Net	build/vstudio8 lib/gml</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7169%20-%20in%20trunk/rts%3A%20Rendering/Env%0A%09Rendering/Textures%20Rendering/UnitModels%20System/Net%0A%09build/vstudio8%20lib/gml&In-Reply-To=%3C20081211143433.C5D9E4760%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7169 - in trunk/rts: Rendering/Env	Rendering/Textures Rendering/UnitModels System/Net	build/vstudio8 lib/gml">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Dec 11 15:34:33 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001937.html">[Taspring-linux-commit] r7168 - in branches/caiinterface: installer	rts rts/build/cmake
</A></li>
        <LI>Next message: <A HREF="001939.html">[Taspring-linux-commit] r7170 - in branches/caiinterface: .	AI/Interfaces/C rts rts/Sim/Misc rts/Sim/Path rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Sync rts/lib/streflop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1938">[ date ]</a>
              <a href="thread.html#1938">[ thread ]</a>
              <a href="subject.html#1938">[ subject ]</a>
              <a href="author.html#1938">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-12-11 15:34:32 +0100 (Thu, 11 Dec 2008)
New Revision: 7169

Modified:
   trunk/rts/Rendering/Env/AdvSky.cpp
   trunk/rts/Rendering/Env/BasicSky.cpp
   trunk/rts/Rendering/Textures/S3OTextureHandler.cpp
   trunk/rts/Rendering/UnitModels/IModelParser.cpp
   trunk/rts/Rendering/UnitModels/IModelParser.h
   trunk/rts/System/Net/UDPConnection.cpp
   trunk/rts/build/vstudio8/rts.vcproj
   trunk/rts/lib/gml/gml.cpp
   trunk/rts/lib/gml/gmldef.h
   trunk/rts/lib/gml/gmlfun.h
Log:
* Fixed GML compatibility with new 3dmodelparser
* Fixed 3dmodelparser memory allocation crash
* Added support for 7 new GL functions to GML

Modified: trunk/rts/Rendering/Env/AdvSky.cpp
===================================================================
--- trunk/rts/Rendering/Env/AdvSky.cpp	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/Rendering/Env/AdvSky.cpp	2008-12-11 14:34:32 UTC (rev 7169)
@@ -356,11 +356,11 @@
 	for (int a = ast; a &lt; aed; ++rc, ++ct) {
 		int yap1 = ydif[ap1] += (int) cloudThickness[++a3c] - cloudThickness[++a] * 2 + cloudThickness[++a4c];
 
-		int dif = yam2 &gt;&gt; 2 +
-			(yam2 = yam1) &gt;&gt; 1 +
+		int dif = (yam2 &gt;&gt; 2) +
+			((yam2 = yam1) &gt;&gt; 1) +
 			(yam1 = yaa) +
-			(yaa = yap1) &gt;&gt; 1 +
-			ydif[(++ap1) &amp;= CLOUD_MASK] &gt;&gt; 2;
+			((yaa = yap1) &gt;&gt; 1) +
+			(ydif[(++ap1) &amp;= CLOUD_MASK] &gt;&gt; 2);
 		dif &gt;&gt;= 4;
 
 		*ct++ = 128 + dif;

Modified: trunk/rts/Rendering/Env/BasicSky.cpp
===================================================================
--- trunk/rts/Rendering/Env/BasicSky.cpp	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/Rendering/Env/BasicSky.cpp	2008-12-11 14:34:32 UTC (rev 7169)
@@ -411,11 +411,11 @@
 	for (int a = ast; a &lt; aed; ++rc, ++ct) {
 		int yap1 = ydif[ap1] += (int) cloudThickness[a3c += 4] - cloudThickness[a += 4] * 2 + cloudThickness[a4c += 4];
 
-		int dif = yam2 &gt;&gt; 2 +
-			(yam2 = yam1) &gt;&gt; 1 +
+		int dif = (yam2 &gt;&gt; 2) +
+			((yam2 = yam1) &gt;&gt; 1) +
 			(yam1 = yaa) +
-			(yaa = yap1) &gt;&gt; 1 +
-			ydif[(++ap1) &amp;= CLOUD_MASK] &gt;&gt; 2;
+			((yaa = yap1) &gt;&gt; 1) +
+			(ydif[(++ap1) &amp;= CLOUD_MASK] &gt;&gt; 2);
 		dif &gt;&gt;= 4;
 
 		*ct++ = 128 + dif;

Modified: trunk/rts/Rendering/Textures/S3OTextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/Textures/S3OTextureHandler.cpp	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/Rendering/Textures/S3OTextureHandler.cpp	2008-12-11 14:34:32 UTC (rev 7169)
@@ -45,9 +45,9 @@
 }
 
 void CS3OTextureHandler::LoadS3OTexture(S3DModel* model) {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	model-&gt;textureType=0;
-	GML_STDMUTEX_LOCK(model); // LoadS3OTexture
+//	GML_STDMUTEX_LOCK(model); // LoadS3OTexture
 	loadTextures.push_back(model);
 #else
 	model-&gt;textureType=LoadS3OTextureNow(model-&gt;tex1, model-&gt;tex2);
@@ -55,7 +55,7 @@
 }
 
 void CS3OTextureHandler::Update() {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	GML_STDMUTEX_LOCK(model); // Update
 	for(std::vector&lt;S3DModel *&gt;::iterator i=loadTextures.begin(); i!=loadTextures.end();++i)
 		(*i)-&gt;textureType=LoadS3OTextureNow((char*)(*i)-&gt;tex1.c_str(),(char*)(*i)-&gt;tex2.c_str());

Modified: trunk/rts/Rendering/UnitModels/IModelParser.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/IModelParser.cpp	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/Rendering/UnitModels/IModelParser.cpp	2008-12-11 14:34:32 UTC (rev 7169)
@@ -49,7 +49,7 @@
 	}
 	parsers.clear();
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	createLists.clear();
 	fixLocalModels.clear();
 	Update(); // delete remaining local models
@@ -65,6 +65,8 @@
 
 S3DModel* C3DModelParser::Load3DModel(std::string name)
 {
+	GML_STDMUTEX_LOCK(model); // Load3DModel
+
 	StringToLowerInPlace(name);
 
 	//search in cache first
@@ -90,7 +92,7 @@
 }
 
 void C3DModelParser::Update() {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	GML_STDMUTEX_LOCK(model); // Update
 	for(std::vector&lt;ModelParserPair&gt;::iterator i=createLists.begin(); i!=createLists.end(); ++i)
 		CreateListsNow(i-&gt;parser,i-&gt;model);
@@ -119,7 +121,7 @@
 
 void C3DModelParser::DeleteLocalModel(CUnit* unit)
 {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	GML_STDMUTEX_LOCK(model); // DeleteLocalModel
 	fixLocalModels.erase(unit);
 	deleteLocalModels.push_back(unit-&gt;localmodel);
@@ -131,7 +133,7 @@
 
 void C3DModelParser::CreateLocalModel(CUnit* unit)
 {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	GML_STDMUTEX_LOCK(model); // CreateLocalModel
 
 	unit-&gt;localmodel = CreateLocalModel(unit-&gt;model);
@@ -148,9 +150,9 @@
 	LocalModel *lmodel = SAFE_NEW LocalModel;
 	lmodel-&gt;type = model-&gt;type;
 	lmodel-&gt;pieces.reserve(model-&gt;numobjects);
-	LocalModelPiece* localpieces = SAFE_NEW LocalModelPiece[model-&gt;numobjects];
+
 	for (unsigned int i=0; i &lt; model-&gt;numobjects; i++) {
-		lmodel-&gt;pieces.push_back(&amp;localpieces[i]);
+		lmodel-&gt;pieces.push_back(SAFE_NEW LocalModelPiece);
 	}
 	lmodel-&gt;pieces[0]-&gt;parent = NULL;
 
@@ -220,8 +222,8 @@
 
 
 void C3DModelParser::CreateLists(IModelParser* parser, S3DModelPiece* o) {
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
-	GML_STDMUTEX_LOCK(model); // CreateLists
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
+//	GML_STDMUTEX_LOCK(model); // CreateLists
 	createLists.push_back(ModelParserPair(o,parser));
 #else
 	CreateListsNow(parser, o);

Modified: trunk/rts/Rendering/UnitModels/IModelParser.h
===================================================================
--- trunk/rts/Rendering/UnitModels/IModelParser.h	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/Rendering/UnitModels/IModelParser.h	2008-12-11 14:34:32 UTC (rev 7169)
@@ -43,7 +43,7 @@
 	std::map&lt;std::string,S3DModel*&gt; cache;
 	std::map&lt;std::string,IModelParser*&gt; parsers;
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIM
 	struct ModelParserPair {
 		ModelParserPair(S3DModelPiece* o,IModelParser* p) : model(o),parser(p) {};
 		S3DModelPiece* model;

Modified: trunk/rts/System/Net/UDPConnection.cpp
===================================================================
--- trunk/rts/System/Net/UDPConnection.cpp	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/System/Net/UDPConnection.cpp	2008-12-11 14:34:32 UTC (rev 7169)
@@ -19,6 +19,7 @@
 
 #include &quot;ProtocolDef.h&quot;
 #include &quot;Exception.h&quot;
+#include &lt;boost/cstdint.hpp&gt;
 
 namespace netcode {
 
@@ -265,7 +266,7 @@
 	{
 		lastSendTime=SDL_GetTicks();
 
-		uint8_t buffer[1500];
+		boost::uint8_t buffer[1500];
 		unsigned pos = 0;
 		// Manually fragment packets to respect configured UDP_MTU.
 		// This is an attempt to fix the bug where players drop out of the game if

Modified: trunk/rts/build/vstudio8/rts.vcproj
===================================================================
--- trunk/rts/build/vstudio8/rts.vcproj	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/build/vstudio8/rts.vcproj	2008-12-11 14:34:32 UTC (rev 7169)
@@ -1911,11 +1911,11 @@
 				Name=&quot;Unit Models&quot;
 				&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\UnitModels\3DModelParser.cpp&quot;
+					RelativePath=&quot;..\..\Rendering\UnitModels\3DModel.cpp&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\UnitModels\3DModelParser.h&quot;
+					RelativePath=&quot;..\..\Rendering\UnitModels\3DModel.h&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
@@ -1927,6 +1927,14 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Rendering\UnitModels\IModelParser.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\Rendering\UnitModels\IModelParser.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Rendering\UnitModels\s3o.h&quot;
 					&gt;
 				&lt;/File&gt;
@@ -2195,6 +2203,14 @@
 				Name=&quot;Textures&quot;
 				&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Rendering\Textures\3DOTextureHandler.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\Rendering\Textures\3DOTextureHandler.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Rendering\Textures\Bitmap.cpp&quot;
 					&gt;
 				&lt;/File&gt;
@@ -2275,27 +2291,27 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\Textures\TAPalette.cpp&quot;
+					RelativePath=&quot;..\..\Rendering\Textures\S3OTextureHandler.cpp&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\Textures\TAPalette.h&quot;
+					RelativePath=&quot;..\..\Rendering\Textures\S3OTextureHandler.h&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\Textures\TextureAtlas.cpp&quot;
+					RelativePath=&quot;..\..\Rendering\Textures\TAPalette.cpp&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\Textures\TextureAtlas.h&quot;
+					RelativePath=&quot;..\..\Rendering\Textures\TAPalette.h&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\Textures\TextureHandler.cpp&quot;
+					RelativePath=&quot;..\..\Rendering\Textures\TextureAtlas.cpp&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Rendering\Textures\TextureHandler.h&quot;
+					RelativePath=&quot;..\..\Rendering\Textures\TextureAtlas.h&quot;
 					&gt;
 				&lt;/File&gt;
 			&lt;/Filter&gt;
@@ -3323,6 +3339,14 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
+					RelativePath=&quot;..\..\Sim\Misc\LosMap.cpp&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
+					RelativePath=&quot;..\..\Sim\Misc\LosMap.h&quot;
+					&gt;
+				&lt;/File&gt;
+				&lt;File
 					RelativePath=&quot;..\..\Sim\Misc\ModInfo.cpp&quot;
 					&gt;
 				&lt;/File&gt;

Modified: trunk/rts/lib/gml/gml.cpp
===================================================================
--- trunk/rts/lib/gml/gml.cpp	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/lib/gml/gml.cpp	2008-12-11 14:34:32 UTC (rev 7169)
@@ -101,6 +101,7 @@
 #endif
 }
 
+#define GML_NOP 0
 const char *gmlFunctionNames[512];
 inline int gmlResetNames() {
     for(int i=0; i&lt;512; ++i)
@@ -257,6 +258,8 @@
 	*(BYTE * volatile *)&amp;WritePos=Write+oldpos;
 	*(BYTE * volatile *)&amp;WriteSize=Write+newsize;
 
+	GML_MEMBAR; //#
+
 	Reloc=FALSE;
 	if(e)
 		*e=Write+olde;
@@ -272,6 +275,8 @@
 	while(Reloc)
 		boost::thread::yield();
 
+	GML_MEMBAR; //#
+
 	if(e)
 		*e=(BYTE *)*(BYTE * volatile *)&amp;Write+olde;
 	return (BYTE *)*(BYTE * volatile *)&WritePos;
@@ -282,7 +287,7 @@
 		return;
 #if GML_ALTERNATE_SYNCMODE
 	if(WritePos==Write) {
-		*(int *)WritePos=0;
+		*(int *)WritePos=GML_NOP;
 		WritePos+=sizeof(int);
 	}
 
@@ -431,7 +436,6 @@
 
 
 void gmlQueue::SyncRequest() {
-#if GML_ALTERNATE_SYNCMODE
 	// make sure server is finished with other queue
 	if(Write==Queue1) {
 		while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
@@ -442,6 +446,7 @@
 			boost::thread::yield();
 	}
 
+#if GML_ALTERNATE_SYNCMODE
 	WasSynced=TRUE;
 	Sync=EXEC_SYNC;
 	while(Sync==EXEC_SYNC) // wait for syncmode confirmation before release
@@ -450,16 +455,11 @@
 	GetWrite(TRUE); // get new queue so server can get the old one
 	while(Sync!=EXEC_RES) // waiting for result
 		boost::thread::yield();
+
+	GML_MEMBAR; //#
+
 	Sync=EXEC_RUN; // server may proceed (avoid entering sync again)
 #else
-	if(Write==Queue1) {
-		while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
-			boost::thread::yield();
-	}
-	if(Write==Queue2) {
-		while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
-			boost::thread::yield();
-	}
 	BYTE *wp=WritePos;
 	*(BYTE * volatile *)&amp;WritePos=wp;
 	WasSynced=TRUE;
@@ -470,162 +470,179 @@
 }
 
 #define GML_DT(name) ((gml##name##Data *)p)
-#define GML_D(name,x) (GML_DT(name)-&gt;x)
+#define GML_DATA(name,x) (GML_DT(name)-&gt;x)
+#define GML_DATA_A(name) GML_DATA(name,A)
+#define GML_DATA_B(name) GML_DATA_A(name),GML_DATA(name,B)
+#define GML_DATA_C(name) GML_DATA_B(name),GML_DATA(name,C)
+#define GML_DATA_D(name) GML_DATA_C(name),GML_DATA(name,D)
+#define GML_DATA_E(name) GML_DATA_D(name),GML_DATA(name,E)
+#define GML_DATA_F(name) GML_DATA_E(name),GML_DATA(name,F)
+#define GML_DATA_G(name) GML_DATA_F(name),GML_DATA(name,G)
+#define GML_DATA_H(name) GML_DATA_G(name),GML_DATA(name,H)
+#define GML_DATA_I(name) GML_DATA_H(name),GML_DATA(name,I)
+#define GML_DATA_J(name) GML_DATA_I(name),GML_DATA(name,J)
+
 #define GML_NEXT(name) p+=sizeof(gml##name##Data); break;
-#define GML_NEXT_SIZE(name) p+=GML_D(name,size); break;
+#define GML_NEXT_SIZE(name) p+=GML_DATA(name,size); break;
+#define GML_CASE(name) case gml##name##Enum
+#define GML_CALL(name,...) gl##name(__VA_ARGS__);
+#define GML_EXEC(name,...) GML_CASE(name): GML_CALL(name,__VA_ARGS__)
+#define GML_EXEC_RET(name,...) GML_CASE(name): GML_DATA(name,ret)=GML_CALL(name,__VA_ARGS__)
 
 // Handler definition macros
 // These handlers execute GL commands from the queues
-#define GML_MAKEHANDLER0(name) case gml##name##Enum:\
-	gl##name();\
+#define GML_MAKEHANDLER0(name)\
+	GML_EXEC(name)\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER0R(name) case gml##name##Enum:\
-	GML_D(name,ret)=gl##name();\
+#define GML_MAKEHANDLER0R(name)\
+	GML_EXEC_RET(name)\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER1(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A));\
+#define GML_MAKEHANDLER1(name)\
+	GML_EXEC(name,GML_DATA_A(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER1R(name) case gml##name##Enum:\
-	GML_D(name,ret)=gl##name(GML_D(name,A));\
+#define GML_MAKEHANDLER1R(name)\
+	GML_EXEC_RET(name,GML_DATA_A(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER2(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B));\
+#define GML_MAKEHANDLER2(name)\
+	GML_EXEC(name,GML_DATA_B(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER2R(name) case gml##name##Enum:\
-	GML_D(name,ret)=gl##name(GML_D(name,A),GML_D(name,B));\
+#define GML_MAKEHANDLER2R(name)\
+	GML_EXEC_RET(name,GML_DATA_B(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER3(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C));\
+#define GML_MAKEHANDLER3(name)\
+	GML_EXEC(name,GML_DATA_C(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER4(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D));\
+#define GML_MAKEHANDLER4(name)\
+	GML_EXEC(name,GML_DATA_D(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER5(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E));\
+#define GML_MAKEHANDLER5(name)\
+	GML_EXEC(name,GML_DATA_E(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER6(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F));\
+#define GML_MAKEHANDLER6(name)\
+	GML_EXEC(name,GML_DATA_F(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER7(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G));\
+#define GML_MAKEHANDLER7(name)\
+	GML_EXEC(name,GML_DATA_G(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER8(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H));\
+#define GML_MAKEHANDLER8(name)\
+	GML_EXEC(name,GML_DATA_H(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER9(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I));\
+#define GML_MAKEHANDLER9(name)\
+	GML_EXEC(name,GML_DATA_I(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER9R(name) case gml##name##Enum:\
-	GML_D(name,ret)=gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I));\
+#define GML_MAKEHANDLER9R(name)\
+	GML_EXEC_RET(name,GML_DATA_I(name))\
 	GML_NEXT(name)
 
-#define GML_MAKEHANDLER10(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I),GML_D(name,J));\
+#define GML_MAKEHANDLER10(name)\
+	GML_EXEC(name,GML_DATA_J(name))\
 	GML_NEXT(name)
 //glTexImage1D
-#define GML_MAKEHANDLER8S(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H)?((BYTE *)(GML_D(name,H)))-1:(BYTE *)(GML_DT(name)+1));\
+#define GML_MAKEHANDLER8S(name)\
+	GML_EXEC(name,GML_DATA_G(name),GML_DATA(name,H)?((BYTE *)(GML_DATA(name,H)))-1:(BYTE *)(GML_DT(name)+1))\
 	GML_NEXT_SIZE(name)
 //glTexImage2D
-#define GML_MAKEHANDLER9S(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I)?((BYTE *)(GML_D(name,I)))-1:(BYTE *)(GML_DT(name)+1));\
+#define GML_MAKEHANDLER9S(name)\
+	GML_EXEC(name,GML_DATA_H(name),GML_DATA(name,I)?((BYTE *)(GML_DATA(name,I)))-1:(BYTE *)(GML_DT(name)+1))\
 	GML_NEXT_SIZE(name)
 //glTexImage3D
-#define GML_MAKEHANDLER10S(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I),GML_D(name,J)?((BYTE *)(GML_D(name,J)))-1:(BYTE *)(GML_DT(name)+1));\
+#define GML_MAKEHANDLER10S(name)\
+	GML_EXEC(name,GML_DATA_I(name),GML_DATA(name,J)?((BYTE *)(GML_DATA(name,J)))-1:(BYTE *)(GML_DT(name)+1))\
 	GML_NEXT_SIZE(name)
 //glColor4fv
-#define GML_MAKEHANDLER1V(name) case gml##name##Enum:\
-	gl##name(&amp;(GML_D(name,A)));\
+#define GML_MAKEHANDLER1V(name)\
+	GML_EXEC(name,&amp;(GML_DATA(name,A)))\
 	GML_NEXT_SIZE(name)
 //glFogfv
-#define GML_MAKEHANDLER2V(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),&amp;(GML_D(name,B)));\
+#define GML_MAKEHANDLER2V(name)\
+	GML_EXEC(name,GML_DATA_A(name),&amp;(GML_DATA(name,B)))\
 	GML_NEXT_SIZE(name)
 //glLight
-#define GML_MAKEHANDLER3V(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),&amp;(GML_D(name,C)));\
+#define GML_MAKEHANDLER3V(name)\
+	GML_EXEC(name,GML_DATA_B(name),&amp;(GML_DATA(name,C)))\
 	GML_NEXT_SIZE(name)
 //glUniformMatrix4fv
-#define GML_MAKEHANDLER4V(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),&amp;(GML_D(name,D)));\
+#define GML_MAKEHANDLER4V(name)\
+	GML_EXEC(name,GML_DATA_C(name),&amp;(GML_DATA(name,D)))\
 	GML_NEXT_SIZE(name)
 //glBufferDataARB
-#define GML_MAKEHANDLER4VS(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),&amp;(GML_D(name,C)),GML_D(name,D));\
+#define GML_MAKEHANDLER4VS(name)\
+	GML_EXEC(name,GML_DATA_B(name),&amp;(GML_DATA(name,C)),GML_DATA(name,D))\
 	GML_NEXT_SIZE(name)
 //glShaderSource
-#define GML_MAKEHANDLER4VSS(name,type) case gml##name##Enum:\
-	ptr=(BYTE *)GML_DT(name)+GML_D(name,lensize);\
-	for(int i=0; i&lt;GML_D(name,B); ++i) {\
-		GLint j=((intptr_t *)&amp;GML_D(name,C))[i];\
-		(&amp;(GML_D(name,C)))[i]=(type *)ptr;\
+#define GML_MAKEHANDLER4VSS(name,type)\
+	GML_CASE(name):\
+	ptr=(BYTE *)GML_DT(name)+GML_DATA(name,lensize);\
+	for(int i=0; i&lt;GML_DATA(name,B); ++i) {\
+		GLint j=((intptr_t *)&amp;GML_DATA(name,C))[i];\
+		(&amp;(GML_DATA(name,C)))[i]=(type *)ptr;\
 		ptr+=j;\
 	}\
-	gl##name(GML_D(name,A),GML_D(name,B),&amp;(GML_D(name,C)),NULL);\
+	GML_CALL(name,GML_DATA(name,A),GML_DATA(name,B),&amp;(GML_DATA(name,C)),NULL)\
 	GML_NEXT_SIZE(name)
 //glMap1
-#define GML_MAKEHANDLER6V(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),&amp;(GML_D(name,F)));\
+#define GML_MAKEHANDLER6V(name)\
+	GML_EXEC(name,GML_DATA_E(name),&amp;(GML_DATA(name,F)))\
 	GML_NEXT_SIZE(name)
 //glMap2
-#define GML_MAKEHANDLER10V(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,I),&amp;(GML_D(name,J)));\
+#define GML_MAKEHANDLER10V(name)\
+	GML_EXEC(name,GML_DATA_I(name),&amp;(GML_DATA(name,J)))\
 	GML_NEXT_SIZE(name)
 //glCompressedTexImage1DARB
-#define GML_MAKEHANDLER7VP(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,GP)?GML_D(name,GP)-1:&amp;(GML_D(name,G)));\
+#define GML_MAKEHANDLER7VP(name)\
+	GML_EXEC(name,GML_DATA_F(name),GML_DATA(name,GP)?GML_DATA(name,GP)-1:&amp;(GML_DATA(name,G)))\
 	GML_NEXT_SIZE(name)
 //glCompressedTexImage2DARB
-#define GML_MAKEHANDLER8VP(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,HP)?GML_D(name,HP)-1:&amp;(GML_D(name,H)));\
+#define GML_MAKEHANDLER8VP(name)\
+	GML_EXEC(name,GML_DATA_G(name),GML_DATA(name,HP)?GML_DATA(name,HP)-1:&amp;(GML_DATA(name,H)))\
 	GML_NEXT_SIZE(name)
 //glCompressedTexImage3DARB
-#define GML_MAKEHANDLER9VP(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_D(name,G),GML_D(name,H),GML_D(name,IP)?GML_D(name,IP)-1:&amp;(GML_D(name,I)));\
+#define GML_MAKEHANDLER9VP(name)\
+	GML_EXEC(name,GML_DATA_H(name),GML_DATA(name,IP)?GML_DATA(name,IP)-1:&amp;(GML_DATA(name,I)))\
 	GML_NEXT_SIZE(name)
 //gluBuild2DMipmaps
-#define GML_MAKEHANDLER7S(name) case gml##name##Enum:\
-	gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D),GML_D(name,E),GML_D(name,F),GML_DT(name)+1);\
+#define GML_MAKEHANDLER7S(name)\
+	GML_EXEC(name,GML_DATA_F(name),GML_DT(name)+1)\
 	GML_NEXT_SIZE(name)
 //glLight
 #define GML_MAKESUBHANDLER2(flag,fun,arg,name)\
-	if(GML_D(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
-		fun(0,(GLboolean *)((GML_D(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_D(name,arg##pointer):ptr));\
-		ptr+=GML_D(name,arg##totalsize);\
+	if(GML_DATA(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+		fun(0,(GLboolean *)((GML_DATA(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_DATA(name,arg##pointer):ptr));\
+		ptr+=GML_DATA(name,arg##totalsize);\
 	}
 #define GML_MAKESUBHANDLER3(flag,fun,arg,name)\
-	if(GML_D(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
-		fun(GML_D(name,arg##type),0,(GML_D(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_D(name,arg##pointer):ptr);\
-		ptr+=GML_D(name,arg##totalsize);\
+	if(GML_DATA(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+		fun(GML_DATA(name,arg##type),0,(GML_DATA(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_DATA(name,arg##pointer):ptr);\
+		ptr+=GML_DATA(name,arg##totalsize);\
 	}
 #define GML_MAKESUBHANDLER4(flag,fun,arg,name)\
-	if(GML_D(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
-		fun(GML_D(name,arg##size),GML_D(name,arg##type),0,(GML_D(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_D(name,arg##pointer):ptr);\
-		ptr+=GML_D(name,arg##totalsize);\
+	if(GML_DATA(name,ClientState) &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
+		fun(GML_DATA(name,arg##size),GML_DATA(name,arg##type),0,(GML_DATA(name,ClientState) &amp; GML_##arg##_ARRAY_BUFFER)?GML_DATA(name,arg##pointer):ptr);\
+		ptr+=GML_DATA(name,arg##totalsize);\
 	}
 #define GML_MAKESUBHANDLERVA(name)\
-	for(int i=0; i&lt;GML_D(name,VAcount); ++i) {\
+	for(int i=0; i&lt;GML_DATA(name,VAcount); ++i) {\
 		VAstruct *va=(VAstruct *)ptr;\
-		glVertexAttribPointer(va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,va-&gt;buffer?va-&gt;pointer:(ptr+sizeof(VAstruct)));\
+		GML_CALL(VertexAttribPointer,va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,va-&gt;buffer?va-&gt;pointer:(ptr+sizeof(VAstruct)));\
 		ptr+=va-&gt;totalsize;\
 	}
 
 
-#define GML_MAKEHANDLER3VDA(name) case gml##name##Enum:\
+#define GML_MAKEHANDLER3VDA(name)\
+	GML_CASE(name):\
 	ptr=(BYTE *)(GML_DT(name)+1);\
 	GML_MAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
 	GML_MAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
@@ -634,10 +651,11 @@
 	GML_MAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
 	GML_MAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
 	GML_MAKESUBHANDLERVA(name)\
-	gl##name(GML_D(name,A),0,GML_D(name,C));\
+	GML_CALL(name,GML_DATA(name,A),0,GML_DATA(name,C))\
 	GML_NEXT_SIZE(name)
 
-#define GML_MAKEHANDLER4VDE(name) case gml##name##Enum:\
+#define GML_MAKEHANDLER4VDE(name)\
+	GML_CASE(name):\
 	ptr=(BYTE *)(GML_DT(name)+1);\
 	GML_MAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
 	GML_MAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
@@ -646,13 +664,13 @@
 	GML_MAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
 	GML_MAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
 	GML_MAKESUBHANDLERVA(name)\
-	if(GML_D(name,ClientState) &amp; GML_ELEMENT_ARRAY_BUFFER)\
-		gl##name(GML_D(name,A),GML_D(name,B),GML_D(name,C),GML_D(name,D));\
+	if(GML_DATA(name,ClientState) &amp; GML_ELEMENT_ARRAY_BUFFER)\
+		GML_CALL(name,GML_DATA(name,A),GML_DATA(name,B),GML_DATA(name,C),GML_DATA(name,D))\
 	else\
-		glDrawArrays(GML_D(name,A),0,GML_D(name,B));\
+		GML_CALL(DrawArrays,GML_DATA(name,A),0,GML_DATA(name,B))\
 	GML_NEXT_SIZE(name)
 
-const char *gmlNOPDummy=(gmlFunctionNames[0]=&quot;gmlNOP&quot;);
+const char *gmlNOPDummy=(gmlFunctionNames[GML_NOP]=&quot;gmlNOP&quot;);
 #define GML_QUOTE(x) #x
 #define GML_MAKENAME(name) EXTERN const char *gml##name##Dummy=(gmlFunctionNames[gml##name##Enum]=GML_QUOTE(gml##name));
 #include &quot;gmlfun.h&quot;
@@ -664,7 +682,7 @@
 inline void QueueHandler(BYTE *&amp;p, BYTE *&amp;ptr) {
 	switch(*(int *)p) {
 #if GML_ALTERNATE_SYNCMODE
-		case 0: p+=sizeof(int); break;
+		case GML_NOP: p+=sizeof(int); break;
 #endif
 		GML_MAKEHANDLER1(Disable)
 		GML_MAKEHANDLER1(Enable)
@@ -921,6 +939,13 @@
 		GML_MAKEHANDLER1(LoadName)
 		GML_MAKEHANDLER1(PushName)
 		GML_MAKEHANDLER0(PopName)
+		GML_MAKEHANDLER4(GetTexLevelParameteriv)
+		GML_MAKEHANDLER4(GetFramebufferAttachmentParameterivEXT)
+		GML_MAKEHANDLER3(GetRenderbufferParameterivEXT)
+		GML_MAKEHANDLER5(GetTexImage)
+		GML_MAKEHANDLER1R(IsTexture)
+		GML_MAKEHANDLER5(FramebufferTexture1DEXT)
+		GML_MAKEHANDLER6(FramebufferTexture3DEXT)
 	}
 }
 
@@ -946,18 +971,18 @@
 	BYTE *ptr=NULL;
 
 	while(p&lt;e) {
-		if(*(int *)p!=0)
+		if(*(int *)p!=GML_NOP)
 			logOutput.Print(&quot;GML error: Sim thread called %s&quot;,gmlFunctionNames[*(int *)p]);
 		QueueHandler(p,ptr);
 //		++procs;
 	}
-//	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
+//	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=GML_NOP))
 //		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
 }
 
 #include &quot;gmlsrv.h&quot;
 class CUnit;
-gmlClientServer&lt;void, int,CUnit*&gt; *gmlProcessor=NULL;
+gmlClientServer&lt;void, int, CUnit*&gt; *gmlProcessor=NULL;
 
 // ExecuteSynced - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points
@@ -992,6 +1017,9 @@
 		Sync=EXEC_RUN; // sync confirmed
 		GetRead(TRUE);
 		(this-&gt;*execfun)();
+
+		GML_MEMBAR; //#
+
 		Sync=EXEC_RES; // result available
 		ReleaseRead();
 		while(Sync==EXEC_RES) // waiting for worker to acquire result
@@ -1010,7 +1038,6 @@
 			while(TRUE) {
 				if(Reloc)
 					e=Realloc(&amp;p);
-//				if(((++updsrv)%GML_UPDSRV_INTERVAL)==0)
 				if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 					gmlUpdateServers();
 				BYTE *s=(BYTE *)Sync;

Modified: trunk/rts/lib/gml/gmldef.h
===================================================================
--- trunk/rts/lib/gml/gmldef.h	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/lib/gml/gmldef.h	2008-12-11 14:34:32 UTC (rev 7169)
@@ -275,6 +275,13 @@
 #undef glLoadName
 #undef glPushName
 #undef glPopName
+#undef glGetTexLevelParameteriv
+#undef glGetFramebufferAttachmentParameterivEXT
+#undef glGetRenderbufferParameterivEXT
+#undef glGetTexImage
+#undef glIsTexture
+#undef glFramebufferTexture1DEXT
+#undef glFramebufferTexture3DEXT
 
 
 
@@ -547,3 +554,10 @@
 #define glLoadName gmlLoadName
 #define glPushName gmlPushName
 #define glPopName gmlPopName
+#define glGetTexLevelParameteriv gmlGetTexLevelParameteriv
+#define glGetFramebufferAttachmentParameterivEXT gmlGetFramebufferAttachmentParameterivEXT
+#define glGetRenderbufferParameterivEXT gmlGetRenderbufferParameterivEXT
+#define glGetTexImage gmlGetTexImage
+#define glIsTexture gmlIsTexture
+#define glFramebufferTexture1DEXT gmlFramebufferTexture1DEXT
+#define glFramebufferTexture3DEXT gmlFramebufferTexture3DEXT

Modified: trunk/rts/lib/gml/gmlfun.h
===================================================================
--- trunk/rts/lib/gml/gmlfun.h	2008-12-11 11:49:55 UTC (rev 7168)
+++ trunk/rts/lib/gml/gmlfun.h	2008-12-11 14:34:32 UTC (rev 7169)
@@ -250,17 +250,17 @@
 }
 
 
-#define GML_MAKEVAR() int type;
-#define GML_MAKEVAR_A(ftype1) GML_MAKEVAR() ftype1 A;
-#define GML_MAKEVAR_B(ftype1,ftype2) GML_MAKEVAR_A(ftype1) ftype2 B;
-#define GML_MAKEVAR_C(ftype1,ftype2,ftype3) GML_MAKEVAR_B(ftype1,ftype2) ftype3 C;
-#define GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4) GML_MAKEVAR_C(ftype1,ftype2,ftype3) ftype4 D;
-#define GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5) GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4) ftype5 E;
-#define GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5) ftype6 F;
-#define GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7) GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) ftype7 G;
-#define GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7) ftype8 H;
-#define GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) ftype9 I;
-#define GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10) GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) ftype10 J;
+#define GML_MAKEDATA(name) struct gml##name##Data { int type;
+#define GML_MAKEDATA_A(name,tA) GML_MAKEDATA(name) tA A;
+#define GML_MAKEDATA_B(name,tA,tB) GML_MAKEDATA_A(name,tA) tB B;
+#define GML_MAKEDATA_C(name,tA,tB,tC) GML_MAKEDATA_B(name,tA,tB) tC C;
+#define GML_MAKEDATA_D(name,tA,tB,tC,tD) GML_MAKEDATA_C(name,tA,tB,tC) tD D;
+#define GML_MAKEDATA_E(name,tA,tB,tC,tD,tE) GML_MAKEDATA_D(name,tA,tB,tC,tD) tE E;
+#define GML_MAKEDATA_F(name,tA,tB,tC,tD,tE,tF) GML_MAKEDATA_E(name,tA,tB,tC,tD,tE) tF F;
+#define GML_MAKEDATA_G(name,tA,tB,tC,tD,tE,tF,tG) GML_MAKEDATA_F(name,tA,tB,tC,tD,tE,tF) tG G;
+#define GML_MAKEDATA_H(name,tA,tB,tC,tD,tE,tF,tG,tH) GML_MAKEDATA_G(name,tA,tB,tC,tD,tE,tF,tG) tH H;
+#define GML_MAKEDATA_I(name,tA,tB,tC,tD,tE,tF,tG,tH,tI) GML_MAKEDATA_H(name,tA,tB,tC,tD,tE,tF,tG,tH) tI I;
+#define GML_MAKEDATA_J(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tJ) GML_MAKEDATA_I(name,tA,tB,tC,tD,tE,tF,tG,tH,tI) tJ J;
 #define GML_MAKEVAR_SIZE() int size;
 #define GML_MAKEVAR_RET(ft) volatile ft ret;
 
@@ -306,15 +306,15 @@
 	GML_PREP_VAR(name,sizefun)\
 	GML_UPD_SIZE()
 
-#define GML_COND(stmt)\
+#define GML_COND(name,...)\
 	GML_IF_SERVER_THREAD() {\
-		stmt;\
+		gl##name(__VA_ARGS__);\
 		return;\
 	}
 
-#define GML_COND_RET(stmt)\
+#define GML_COND_RET(name,...)\
 	GML_IF_SERVER_THREAD() {\
-		return stmt;\
+		return gl##name(__VA_ARGS__);\
 	}
 
 EXTERN inline void gmlSync(gmlQueue *qd) {
@@ -329,9 +329,10 @@
 #	define GML_MAKENAME(name)
 #endif
 
-#define GML_FUN(name,ftype) EXTERN const int gml##name##Enum=(__LINE__-__FIRSTLINE__);\
+#define GML_FUN(ftype,name,...) };\
+	EXTERN const int gml##name##Enum=(__LINE__-__FIRSTLINE__);\
 	GML_MAKENAME(name)\
-	EXTERN inline ftype gml##name
+	EXTERN inline ftype gml##name(__VA_ARGS__)
 
 #ifdef _MSC_VER
 #define GML_FUNCTION __FUNCTION__
@@ -347,57 +348,52 @@
 #define GML_ITEMSERVER_CHECK()
 #endif
 
-#define GML_MAKEFUN0(name) struct gml##name##Data {\
-	GML_MAKEVAR()\
-};\
-GML_FUN(name,void)() {\
-	GML_COND(gl##name())\
+#define GML_MAKEFUN0(name)\
+	GML_MAKEDATA(name)\
+GML_FUN(void, name) {\
+	GML_COND(name)\
 	GML_PREP_FIXED(name)\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN0R(name,ftypeR,cache) struct gml##name##Data {\
-	GML_MAKEVAR()\
-	GML_MAKEVAR_RET(ftypeR)\
-};\
-GML_FUN(name,ftypeR)() {\
-	GML_COND_RET(gl##name())\
+#define GML_MAKEFUN0R(name,tR,cache)\
+	GML_MAKEDATA(name)\
+	GML_MAKEVAR_RET(tR)\
+GML_FUN(tR, name) {\
+	GML_COND_RET(name)\
 	cache\
 	GML_PREP_FIXED(name)\
 	GML_UPD_POS()\
 	GML_SYNC();\
-	GML_RETVAL(ftypeR)\
+	GML_RETVAL(tR)\
 }
 
-#define GML_MAKEFUN1(name,ftype1) struct gml##name##Data {\
-	GML_MAKEVAR_A(ftype1)\
-};\
-GML_FUN(name,void)(ftype1 A) {\
-	GML_COND(gl##name(A))\
+#define GML_MAKEFUN1(name,tA)\
+	GML_MAKEDATA_A(name,tA)\
+GML_FUN(void, name, tA A) {\
+	GML_COND(name,A)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_A()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN1R(name,ftype1,ftypeR,cache) struct gml##name##Data {\
-	GML_MAKEVAR_A(ftype1)\
-	GML_MAKEVAR_RET(ftypeR)\
-};\
-GML_FUN(name,ftypeR)(ftype1 A) {\
-	GML_COND_RET(gl##name(A))\
+#define GML_MAKEFUN1R(name,tA,tR,cache)\
+	GML_MAKEDATA_A(name,tA)\
+	GML_MAKEVAR_RET(tR)\
+GML_FUN(tR, name, tA A) {\
+	GML_COND_RET(name,A)\
 	cache\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_A()\
 	GML_UPD_POS()\
 	GML_SYNC();\
-	GML_RETVAL(ftypeR)\
+	GML_RETVAL(tR)\
 }
 
-#define GML_MAKEFUN2(name,ftype1,ftype2,cache,...) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B) {\
-	GML_COND(gl##name(A,B))\
+#define GML_MAKEFUN2(name,tA,tB,cache,...)\
+	GML_MAKEDATA_B(name,tA,tB)\
+GML_FUN(void, name, tA A, tB B) {\
+	GML_COND(name,A,B)\
 	cache\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_B()\
@@ -405,11 +401,10 @@
 	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
-#define GML_MAKEFUN2B(name,ftype1,ftype2) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B) {\
-	GML_COND(gl##name(A,B))\
+#define GML_MAKEFUN2B(name,tA,tB)\
+	GML_MAKEDATA_B(name,tA,tB)\
+GML_FUN(void, name, tA A, tB B) {\
+	GML_COND(name,A,B)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_B()\
 	switch(A) {\
@@ -426,24 +421,22 @@
 }
 
 
-#define GML_MAKEFUN2R(name,ftype1,ftype2,ftypeR) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2)\
-	GML_MAKEVAR_RET(ftypeR)\
-};\
-GML_FUN(name,ftypeR)(ftype1 A,ftype2 B) {\
-	GML_COND_RET(gl##name(A,B))\
+#define GML_MAKEFUN2R(name,tA,tB,tR)\
+	GML_MAKEDATA_B(name,tA,tB)\
+	GML_MAKEVAR_RET(tR)\
+GML_FUN(tR, name, tA A,tB B) {\
+	GML_COND_RET(name,A,B)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_B()\
 	GML_UPD_POS()\
 	GML_SYNC();\
-	GML_RETVAL(ftypeR)\
+	GML_RETVAL(tR)\
 }
 
-#define GML_MAKEFUN3(name,ftype1,ftype2,ftype3,cache,...) struct gml##name##Data {\
-	GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C) {\
-	GML_COND(gl##name(A,B,C))\
+#define GML_MAKEFUN3(name,tA,tB,tC,cache,...)\
+	GML_MAKEDATA_C(name,tA,tB,tC)\
+GML_FUN(void, name, tA A, tB B, tC C) {\
+	GML_COND(name,A,B,C)\
 	cache\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_C()\
@@ -451,98 +444,90 @@
 	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
-#define GML_MAKEFUN4(name,ftype1,ftype2,ftype3,ftype4,...) struct gml##name##Data {\
-	GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
-	GML_COND(gl##name(A,B,C,D))\
+#define GML_MAKEFUN4(name,tA,tB,tC,tD,...)\
+	GML_MAKEDATA_D(name,tA,tB,tC,tD)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D) {\
+	GML_COND(name,A,B,C,D)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_D()\
 	GML_UPD_POS()\
 	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
-#define GML_MAKEFUN5(name,ftype1,ftype2,ftype3,ftype4,ftype5) struct gml##name##Data {\
-	GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E) {\
-	GML_COND(gl##name(A,B,C,D,E))\
+#define GML_MAKEFUN5(name,tA,tB,tC,tD,tE,...)\
+	GML_MAKEDATA_E(name,tA,tB,tC,tD,tE)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E) {\
+	GML_COND(name,A,B,C,D,E)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_E()\
 	GML_UPD_POS()\
+	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
-#define GML_MAKEFUN6(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6) struct gml##name##Data {\
-	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F) {\
-	GML_COND(gl##name(A,B,C,D,E,F))\
+#define GML_MAKEFUN6(name,tA,tB,tC,tD,tE,tF)\
+	GML_MAKEDATA_F(name,tA,tB,tC,tD,tE,tF)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F) {\
+	GML_COND(name,A,B,C,D,E,F)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_F()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN7(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,...) struct gml##name##Data {\
-	GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G))\
+#define GML_MAKEFUN7(name,tA,tB,tC,tD,tE,tF,tG,...)\
+	GML_MAKEDATA_G(name,tA,tB,tC,tD,tE,tF,tG)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G) {\
+	GML_COND(name,A,B,C,D,E,F,G)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_G()\
 	GML_UPD_POS()\
 	GML_SYNC_COND(__VA_ARGS__,)\
 }
 
-#define GML_MAKEFUN8(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8) struct gml##name##Data {\
-	GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+#define GML_MAKEFUN8(name,tA,tB,tC,tD,tE,tF,tG,tH)\
+	GML_MAKEDATA_H(name,tA,tB,tC,tD,tE,tF,tG,tH)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H) {\
+	GML_COND(name,A,B,C,D,E,F,G,H)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_H()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN9(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9) struct gml##name##Data {\
-	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+#define GML_MAKEFUN9(name,tA,tB,tC,tD,tE,tF,tG,tH,tI)\
+	GML_MAKEDATA_I(name,tA,tB,tC,tD,tE,tF,tG,tH,tI)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI I) {\
+	GML_COND(name,A,B,C,D,E,F,G,H,I)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_I()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN9R(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftypeR) struct gml##name##Data {\
-	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
-	GML_MAKEVAR_RET(ftypeR)\
-};\
-GML_FUN(name,ftypeR)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
-	GML_COND_RET(gl##name(A,B,C,D,E,F,G,H,I))\
+#define GML_MAKEFUN9R(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tR)\
+	GML_MAKEDATA_I(name,tA,tB,tC,tD,tE,tF,tG,tH,tI)\
+	GML_MAKEVAR_RET(tR)\
+GML_FUN(tR, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI I) {\
+	GML_COND_RET(name,A,B,C,D,E,F,G,H,I)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_I()\
 	GML_UPD_POS()\
 	GML_SYNC();\
-	GML_RETVAL(ftypeR)\
+	GML_RETVAL(tR)\
 }
 
 
-#define GML_MAKEFUN10(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10) struct gml##name##Data {\
-	GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 J) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+#define GML_MAKEFUN10(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tJ)\
+	GML_MAKEDATA_J(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tJ)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI I, tJ J) {\
+	GML_COND(name,A,B,C,D,E,F,G,H,I,J)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_J()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN7S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,sizefun) struct gml##name##Data {\
-	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+#define GML_MAKEFUN7S(name,tA,tB,tC,tD,tE,tF,tG,sizefun)\
+	GML_MAKEDATA_F(name,tA,tB,tC,tD,tE,tF)\
 	GML_MAKEVAR_SIZE()\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G))\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG *G) {\
+	GML_COND(name,A,B,C,D,E,F,G)\
 	GML_PREP_VAR_SIZE(name,sizefun)\
 	GML_MAKEASS_F()\
 	memcpy(p+1,G,size);\
@@ -558,121 +543,112 @@
 	else if(var!=NULL)\
 		memcpy(p+1,var,size);
 
-#define GML_MAKEFUN8S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,sizefun) struct gml##name##Data {\
-	GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8 *)\
+#define GML_MAKEFUN8S(name,tA,tB,tC,tD,tE,tF,tG,tH,sizefun)\
+	GML_MAKEDATA_H(name,tA,tB,tC,tD,tE,tF,tG,tH *)\
 	GML_MAKEVAR_SIZE()\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H))\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH *H) {\
+	GML_COND(name,A,B,C,D,E,F,G,H)\
 	GML_PREP_VAR(name,sizefun)\
 	GML_MAKEASS_G()\
-	GML_PUB_COPY(name,H,ftype8 *)\
+	GML_PUB_COPY(name,H,tH *)\
 	GML_UPD_SIZE()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN9S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,sizefun) struct gml##name##Data {\
-	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9 *)\
+#define GML_MAKEFUN9S(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,sizefun)\
+	GML_MAKEDATA_I(name,tA,tB,tC,tD,tE,tF,tG,tH,tI *)\
 	GML_MAKEVAR_SIZE()\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI *I) {\
+	GML_COND(name,A,B,C,D,E,F,G,H,I)\
 	GML_PREP_VAR(name,sizefun)\
 	GML_MAKEASS_H()\
-	GML_PUB_COPY(name,I,ftype9 *)\
+	GML_PUB_COPY(name,I,tI *)\
 	GML_UPD_SIZE()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN10S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10,sizefun) struct gml##name##Data {\
-	GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10 *)\
+#define GML_MAKEFUN10S(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tJ,sizefun)\
+	GML_MAKEDATA_J(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tJ *)\
 	GML_MAKEVAR_SIZE()\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 *J) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI I, tJ *J) {\
+	GML_COND(name,A,B,C,D,E,F,G,H,I,J)\
 	GML_PREP_VAR(name,sizefun)\
 	GML_MAKEASS_I()\
-	GML_PUB_COPY(name,J,ftype10 *)\
+	GML_PUB_COPY(name,J,tJ *)\
 	GML_UPD_SIZE()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN1V(name,ftype1,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR()\
+#define GML_MAKEFUN1V(name,tA,tX,count)\
+	GML_MAKEDATA(name)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX A;\
-};\
-GML_FUN(name,void)(ftype1* A) {\
-	GML_COND(gl##name(A))\
-	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
-	memcpy(&amp;(p-&gt;A),A,size+sizeof(ftypeX));\
+	tX A;\
+GML_FUN(void, name, tA* A) {\
+	GML_COND(name,A)\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(tX))\
+	memcpy(&amp;(p-&gt;A),A,size+sizeof(tX));\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN2V(name,ftype1,ftype2,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_A(ftype1)\
+#define GML_MAKEFUN2V(name,tA,tB,tX,count)\
+	GML_MAKEDATA_A(name,tA)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX B;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2* B) {\
-	GML_COND(gl##name(A,B))\
-	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	tX B;\
+GML_FUN(void, name, tA A, tB* B) {\
+	GML_COND(name,A,B)\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_A()\
-	memcpy(&amp;(p-&gt;B),B,size+sizeof(ftypeX));\
+	memcpy(&amp;(p-&gt;B),B,size+sizeof(tX));\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN3V(name,ftype1,ftype2,ftype3,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2)\
+#define GML_MAKEFUN3V(name,tA,tB,tC,tX,count)\
+	GML_MAKEDATA_B(name,tA,tB)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX C;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3* C) {\
-	GML_COND(gl##name(A,B,C))\
-	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	tX C;\
+GML_FUN(void, name, tA A, tB B, tC* C) {\
+	GML_COND(name,A,B,C)\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_B()\
-	memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
+	memcpy(&amp;(p-&gt;C),C,size+sizeof(tX));\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN4V(name,ftype1,ftype2,ftype3,ftype4,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+#define GML_MAKEFUN4V(name,tA,tB,tC,tD,tX,count)\
+	GML_MAKEDATA_C(name,tA,tB,tC)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX D;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
-	GML_COND(gl##name(A,B,C,D))\
-	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	tX D;\
+GML_FUN(void, name, tA A, tB B, tC C, tD *D) {\
+	GML_COND(name,A,B,C,D)\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_C()\
-	memcpy(&amp;(p-&gt;D),D,size+sizeof(ftypeX));\
+	memcpy(&amp;(p-&gt;D),D,size+sizeof(tX));\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN4VS(name,ftype1,ftype2,ftype3,ftype4,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2)\
-	ftype4 D;\
+#define GML_MAKEFUN4VS(name,tA,tB,tC,tD,tX,count)\
+	GML_MAKEDATA_B(name,tA,tB)\
+	tD D;\
 	GML_MAKEVAR_SIZE()\
-	ftypeX C;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 *C, ftype4 D) {\
-	GML_COND(gl##name(A,B,C,D))\
-	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+	tX C;\
+GML_FUN(void, name, tA A, tB B, tC *C, tD D) {\
+	GML_COND(name,A,B,C,D)\
+	GML_PREP_VAR_SIZE(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_B()\
 	p-&gt;D=D;\
 	if(C!=NULL)\
-		memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
+		memcpy(&amp;(p-&gt;C),C,size+sizeof(tX));\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN4VSS(name,ftype1,ftype2,ftype3,ftype4,count) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2)\
+#define GML_MAKEFUN4VSS(name,tA,tB,tC,tD,count)\
+	GML_MAKEDATA_B(name,tA,tB)\
 	int lensize;\
 	GML_MAKEVAR_SIZE()\
-	ftype3 *C;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 **C, ftype4 *D) {\
-	GML_COND(gl##name(A,B,C,D))\
-	GML_PREP_VAR(name,(count-1)*sizeof(ftype3 *))\
+	tC *C;\
+GML_FUN(void, name, tA A, tB B, tC **C, tD *D) {\
+	GML_COND(name,A,B,C,D)\
+	GML_PREP_VAR(name,(count-1)*sizeof(tC *))\
 	GML_MAKEASS_B()\
 	p-&gt;lensize=datasize;\
 	BYTE *e=(BYTE *)p+datasize;\
@@ -713,20 +689,19 @@
 		v+=stride;\
 	}
 
-#define GML_MAKEFUN6VST(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftypeX,count,stride,numargs) struct gml##name##Data {\
-	GML_MAKEVAR_E(ftype1,ftype2,ftype3,ftype4,ftype5)\
+#define GML_MAKEFUN6VST(name,tA,tB,tC,tD,tE,tF,tX,count,stride,numargs)\
+	GML_MAKEDATA_E(name,tA,tB,tC,tD,tE)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX F;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 *F) {\
-	GML_COND(gl##name(A,B,C,D,E,F))\
+	tX F;\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF *F) {\
+	GML_COND(name,A,B,C,D,E,F)\
 	int nargs=numargs;\
-	GML_PREP_VAR_SIZE(name,(nargs*count-1)*sizeof(ftypeX))\
+	GML_PREP_VAR_SIZE(name,(nargs*count-1)*sizeof(tX))\
 	GML_MAKEASS_E()\
 	p-&gt;stride=nargs;\
-	ftypeX *e=&amp;(p-&gt;F);\
-	ftype6 *v=F;\
-	GML_STDCOPY1(ftype6,count,stride,nargs)\
+	tX *e=&amp;(p-&gt;F);\
+	tF *v=F;\
+	GML_STDCOPY1(tF,count,stride,nargs)\
 	GML_UPD_POS()\
 }
 
@@ -745,85 +720,79 @@
 		v+=stride1;\
 	}
 
-#define GML_MAKEFUN10VST(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10,ftypeX,count1,stride1,count2,stride2,numargs) struct gml##name##Data {\
-	GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+#define GML_MAKEFUN10VST(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tJ,tX,count1,stride1,count2,stride2,numargs)\
+	GML_MAKEDATA_I(name,tA,tB,tC,tD,tE,tF,tG,tH,tI)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX J;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 *J) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
+	tX J;\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI I, tJ *J) {\
+	GML_COND(name,A,B,C,D,E,F,G,H,I,J)\
 	int nargs=numargs;\
-	GML_PREP_VAR_SIZE(name,(nargs*count1*count2-1)*sizeof(ftypeX))\
+	GML_PREP_VAR_SIZE(name,(nargs*count1*count2-1)*sizeof(tX))\
 	GML_MAKEASS_I()\
 	p-&gt;stride1=nargs*count2;\
 	p-&gt;stride2=nargs;\
-	ftypeX *e=&amp;(p-&gt;J);\
-	ftype10 *v=J;\
-	GML_STDCOPY2(ftype10,count1,stride1,count2,stride2,nargs)\
+	tX *e=&amp;(p-&gt;J);\
+	tJ *v=J;\
+	GML_STDCOPY2(tJ,count1,stride1,count2,stride2,nargs)\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN7VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+#define GML_MAKEFUN7VP(name,tA,tB,tC,tD,tE,tF,tG,tX,count)\
+	GML_MAKEDATA_F(name,tA,tB,tC,tD,tE,tF)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX *GP;\
-	ftypeX G;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G))\
-	GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
+	tX *GP;\
+	tX G;\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG *G) {\
+	GML_COND(name,A,B,C,D,E,F,G)\
+	GML_PREP_VAR(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_F()\
-	GML_PUB_PCOPY(name,G,GP,ftypeX)\
+	GML_PUB_PCOPY(name,G,GP,tX)\
 	GML_UPD_SIZE()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN8VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+#define GML_MAKEFUN8VP(name,tA,tB,tC,tD,tE,tF,tG,tH,tX,count)\
+	GML_MAKEDATA_G(name,tA,tB,tC,tD,tE,tF,tG)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX *HP;\
-	ftypeX H;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H))\
-	GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
+	tX *HP;\
+	tX H;\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH *H) {\
+	GML_COND(name,A,B,C,D,E,F,G,H)\
+	GML_PREP_VAR(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_G()\
-	GML_PUB_PCOPY(name,H,HP,ftypeX)\
+	GML_PUB_PCOPY(name,H,HP,tX)\
 	GML_UPD_SIZE()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN9VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftypeX,count) struct gml##name##Data {\
-	GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+#define GML_MAKEFUN9VP(name,tA,tB,tC,tD,tE,tF,tG,tH,tI,tX,count)\
+	GML_MAKEDATA_H(name,tA,tB,tC,tD,tE,tF,tG,tH)\
 	GML_MAKEVAR_SIZE()\
-	ftypeX *IP;\
-	ftypeX I;\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
-	GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
-	GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
+	tX *IP;\
+	tX I;\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF F, tG G, tH H, tI *I) {\
+	GML_COND(name,A,B,C,D,E,F,G,H,I)\
+	GML_PREP_VAR(name,(count-1)*sizeof(tX))\
 	GML_MAKEASS_H()\
-	GML_PUB_PCOPY(name,I,IP,ftypeX)\
+	GML_PUB_PCOPY(name,I,IP,tX)\
 	GML_UPD_SIZE()\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN1CS(name,ftype1,arg) struct gml##name##Data {\
-	GML_MAKEVAR_A(ftype1)\
-};\
-GML_FUN(name,void)(ftype1 A) {\
-	GML_COND(gl##name(A))\
+#define GML_MAKEFUN1CS(name,tA,arg)\
+	GML_MAKEDATA_A(name,tA)\
+GML_FUN(void, name, tA A) {\
+	GML_COND(name,A)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_A()\
 	qd-&gt;ClientState arg (1&lt;&lt;(A-GL_VERTEX_ARRAY));\
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN1VA(name,ftype1,arg,fun) struct gml##name##Data {\
-	GML_MAKEVAR_A(ftype1)\
-};\
-GML_FUN(name,void)(ftype1 A) {\
-	GML_COND(gl##name(A))\
+#define GML_MAKEFUN1VA(name,tA,arg,fun)\
+	GML_MAKEDATA_A(name,tA)\
+GML_FUN(void, name, tA A) {\
+	GML_COND(name,A)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_A()\
 	qd-&gt;arg##set.fun(A);\
@@ -836,11 +805,10 @@
 	else\
 		qd-&gt;ClientState &amp;= ~GML_##arg##_ARRAY_BUFFER;
 
-#define GML_MAKEFUN2P(name,ftype1,ftype2,arg) struct gml##name##Data {\
-	GML_MAKEVAR_B(ftype1,ftype2 *)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 *B) {\
-	GML_COND(gl##name(A,B))\
+#define GML_MAKEFUN2P(name,tA,tB,arg)\
+	GML_MAKEDATA_B(name,tA,tB *)\
+GML_FUN(void, name, tA A, tB *B) {\
+	GML_COND(name,A,B)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_B()\
 	qd-&gt;arg##stride=A;\
@@ -849,11 +817,10 @@
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN3P(name,ftype1,ftype2,ftype3,arg) struct gml##name##Data {\
-	GML_MAKEVAR_C(ftype1,ftype2,ftype3 *)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 *C) {\
-	GML_COND(gl##name(A,B,C))\
+#define GML_MAKEFUN3P(name,tA,tB,tC,arg)\
+	GML_MAKEDATA_C(name,tA,tB,tC *)\
+GML_FUN(void, name, tA A, tB B, tC *C) {\
+	GML_COND(name,A,B,C)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_C()\
 	qd-&gt;arg##type=A;\
@@ -863,11 +830,10 @@
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN4P(name,ftype1,ftype2,ftype3,ftype4,arg) struct gml##name##Data {\
-	GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
-	GML_COND(gl##name(A,B,C,D))\
+#define GML_MAKEFUN4P(name,tA,tB,tC,tD,arg)\
+	GML_MAKEDATA_D(name,tA,tB,tC,tD *)\
+GML_FUN(void, name, tA A, tB B, tC C, tD *D) {\
+	GML_COND(name,A,B,C,D)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_D()\
 	qd-&gt;arg##size=A;\
@@ -878,11 +844,10 @@
 	GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN6P(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,arg) struct gml##name##Data {\
-	GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6 *)\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 *F) {\
-	GML_COND(gl##name(A,B,C,D,E,F))\
+#define GML_MAKEFUN6P(name,tA,tB,tC,tD,tE,tF,arg)\
+	GML_MAKEDATA_F(name,tA,tB,tC,tD,tE,tF *)\
+GML_FUN(void, name, tA A, tB B, tC C, tD D, tE E, tF *F) {\
+	GML_COND(name,A,B,C,D,E,F)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_F()\
 	qd-&gt;arg##map[A]=arg##data(B,C,D,E,F,qd-&gt;ArrayBuffer);\
@@ -1002,13 +967,12 @@
 	}
 
 
-#define GML_MAKEFUN3VDA(name,ftype1,ftype2,ftype3) struct gml##name##Data {\
-	GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+#define GML_MAKEFUN3VDA(name,tA,tB,tC)\
+	GML_MAKEDATA_C(name,tA,tB,tC)\
 	GML_MAKEPOINTERDATA()\
 	GML_MAKEVAR_SIZE()\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C) {\
-	GML_COND(gl##name(A,B,C))\
+GML_FUN(void, name, tA A, tB B, tC C) {\
+	GML_COND(name,A,B,C)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_C()\
 	GLenum clientstate=qd-&gt;ClientState &amp; ~(qd-&gt;ClientState&gt;&gt;16);\
@@ -1026,13 +990,12 @@
 }
 
 
-#define GML_MAKEFUN4VDE(name,ftype1,ftype2,ftype3,ftype4) struct gml##name##Data {\
-	GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
+#define GML_MAKEFUN4VDE(name,tA,tB,tC,tD)\
+	GML_MAKEDATA_D(name,tA,tB,tC,tD *)\
 	GML_MAKEPOINTERDATA()\
 	GML_MAKEVAR_SIZE()\
-};\
-GML_FUN(name,void)(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
-	GML_COND(gl##name(A,B,C,D))\
+GML_FUN(void, name, tA A, tB B, tC C, tD *D) {\
+	GML_COND(name,A,B,C,D)\
 	GML_PREP_FIXED(name)\
 	GML_MAKEASS_D()\
 	BYTE *e=(BYTE *)(p+1);\
@@ -1309,5 +1272,12 @@
 GML_MAKEFUN1(LoadName,GLuint)
 GML_MAKEFUN1(PushName,GLuint)
 GML_MAKEFUN0(PopName)
+GML_MAKEFUN4(GetTexLevelParameteriv,GLenum,GLint,GLenum,GLint *,GML_SYNC())
+GML_MAKEFUN4(GetFramebufferAttachmentParameterivEXT,GLenum,GLenum,GLenum,GLint *,GML_SYNC())
+GML_MAKEFUN3(GetRenderbufferParameterivEXT,GLenum,GLenum,GLint *,,GML_SYNC())
+GML_MAKEFUN5(GetTexImage,GLenum,GLint,GLenum,GLenum,GLvoid *,GML_SYNC())
+GML_MAKEFUN1R(IsTexture,GLuint,GLboolean,)
+GML_MAKEFUN5(FramebufferTexture1DEXT,GLenum,GLenum,GLenum,GLuint,GLint)
+GML_MAKEFUN6(FramebufferTexture3DEXT,GLenum,GLenum,GLenum,GLuint,GLint,GLint)
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001937.html">[Taspring-linux-commit] r7168 - in branches/caiinterface: installer	rts rts/build/cmake
</A></li>
	<LI>Next message: <A HREF="001939.html">[Taspring-linux-commit] r7170 - in branches/caiinterface: .	AI/Interfaces/C rts rts/Sim/Misc rts/Sim/Path rts/System	rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Sync rts/lib/streflop
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1938">[ date ]</a>
              <a href="thread.html#1938">[ thread ]</a>
              <a href="subject.html#1938">[ subject ]</a>
              <a href="author.html#1938">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
