<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7125 - in trunk/rts: Game/UI Lua	Map/SM3/terrain Rendering Rendering/Env Rendering/GL	Sim/Projectiles System
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-December/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7125%20-%20in%20trunk/rts%3A%20Game/UI%20Lua%0A%09Map/SM3/terrain%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Sim/Projectiles%20System&In-Reply-To=%3C20081205125438.7981746EC%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001893.html">
   <LINK REL="Next"  HREF="001895.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7125 - in trunk/rts: Game/UI Lua	Map/SM3/terrain Rendering Rendering/Env Rendering/GL	Sim/Projectiles System</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7125%20-%20in%20trunk/rts%3A%20Game/UI%20Lua%0A%09Map/SM3/terrain%20Rendering%20Rendering/Env%20Rendering/GL%0A%09Sim/Projectiles%20System&In-Reply-To=%3C20081205125438.7981746EC%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7125 - in trunk/rts: Game/UI Lua	Map/SM3/terrain Rendering Rendering/Env Rendering/GL	Sim/Projectiles System">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Dec  5 13:54:38 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001893.html">[Taspring-linux-commit] r7124 - in trunk/rts: Game/UI Map/SMF	Rendering/Env Sim/Misc Sim/Projectiles/Unsynced Sim/Units	System/Platform/Win build/scons
</A></li>
        <LI>Next message: <A HREF="001895.html">[Taspring-linux-commit] r7126 - Lobby/springie/Springie/PlanetWars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1894">[ date ]</a>
              <a href="thread.html#1894">[ thread ]</a>
              <a href="subject.html#1894">[ subject ]</a>
              <a href="author.html#1894">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: jk
Date: 2008-12-05 13:54:36 +0100 (Fri, 05 Dec 2008)
New Revision: 7125

Removed:
   trunk/rts/Rendering/GL/IFramebuffer.h
Modified:
   trunk/rts/Game/UI/MouseHandler.cpp
   trunk/rts/Game/UI/MouseHandler.h
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp
   trunk/rts/Rendering/Env/BumpWater.cpp
   trunk/rts/Rendering/Env/BumpWater.h
   trunk/rts/Rendering/GL/FBO.cpp
   trunk/rts/Rendering/GL/FBO.h
   trunk/rts/Rendering/GL/myGL.cpp
   trunk/rts/Rendering/GLContext.h
   trunk/rts/Rendering/ShadowHandler.cpp
   trunk/rts/Rendering/ShadowHandler.h
   trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
   trunk/rts/Sim/Projectiles/ProjectileHandler.h
   trunk/rts/System/MouseInput.cpp
   trunk/rts/System/SpringApp.cpp
Log:
2nd cutout:
 * redid the whole FBO class:
  * it is now much more flexible
  * it has an AltTab-fix (-&gt; garbled particle atlas), so the content of any texture bind to a fbo won't get lost when alttabbing (fix is windows only :&lt;)
 * use interpolation for the mousewheel (windows only :&lt;)
 * try to make mouse a bit more responsive (again windows only :&lt;)

Modified: trunk/rts/Game/UI/MouseHandler.cpp
===================================================================
--- trunk/rts/Game/UI/MouseHandler.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Game/UI/MouseHandler.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -490,13 +490,13 @@
 }
 
 
-void CMouseHandler::MouseWheel(bool up)
+void CMouseHandler::MouseWheel(float delta)
 {
-	const float value = up ? +scrollWheelSpeed : -scrollWheelSpeed;
-	if (eventHandler.MouseWheel(up, value)) {
+	delta *= scrollWheelSpeed;
+	if (eventHandler.MouseWheel(delta&gt;1.0f, delta)) {
 		return;
 	}
-	camHandler-&gt;GetCurrentController().MouseWheelMove(value);
+	camHandler-&gt;GetCurrentController().MouseWheelMove(delta);
 }
 
 

Modified: trunk/rts/Game/UI/MouseHandler.h
===================================================================
--- trunk/rts/Game/UI/MouseHandler.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Game/UI/MouseHandler.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -33,7 +33,7 @@
 	void MouseRelease(int x,int y,int button);
 	void MousePress(int x,int y,int button);
 	void MouseMove(int x,int y);
-	void MouseWheel(bool up);
+	void MouseWheel(float delta);
 	CMouseHandler();
 	virtual ~CMouseHandler();
 

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -44,7 +44,6 @@
 #include &quot;Rendering/Env/BaseWater.h&quot;
 #include &quot;Rendering/GL/glExtra.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/Textures/NamedTextures.h&quot;
 #include &quot;Rendering/Textures/TextureHandler.h&quot;

Modified: trunk/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp
===================================================================
--- trunk/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Map/SM3/terrain/TerrainTextureGLSL.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -33,7 +33,7 @@
 #include &quot;Terrain.h&quot;
 
 #include &quot;TerrainTextureGLSL.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;FileSystem/FileSystem.h&quot;
 #include &quot;bitops.h&quot;
@@ -147,6 +147,8 @@
 	{
 	// ATI has GL_EXT_texture_rectangle, but that has no support for GLSL texture2DRect
 	// nVidia: Use RECT,  ati: use POT
+		assert(framebuffer.IsValid());
+
 		width = gu-&gt;viewSizeX;
 		height = gu-&gt;viewSizeY;
 		if (GLEW_ARB_texture_rectangle)
@@ -157,7 +159,6 @@
 			height = closest_pot(height);
 		}
 
-		framebuffer = instantiate_fb(width, height, FBO_NEED_COLOR | FBO_NEED_DEPTH);
 		name = &quot;_buffer&quot;;
 
 		glGenTextures(1, &amp;id);
@@ -166,20 +167,22 @@
 		glTexParameteri(target,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
 		glTexImage2D(target, 0, 4, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
 
-		framebuffer-&gt;attachTexture(id, target, FBO_ATTACH_COLOR);
-
-		assert (framebuffer-&gt;valid());
+		framebuffer.Bind();
+		framebuffer.CreateRenderBuffer(GL_DEPTH_ATTACHMENT_EXT, GL_DEPTH_COMPONENT24, width, height);
+		framebuffer.AttachTexture(id, target);
+		bool status = framebuffer.CheckStatus(&quot;sm3&quot;);
+		framebuffer.Unbind();
+		assert(status);
 	}
 	~BufferTexture()
 	{
-		delete framebuffer;
 		// texture is deleted by ~BaseTexture
 	}
 	bool IsRect() {	return target == GL_TEXTURE_RECTANGLE_ARB; }
 
 	int width, height;
 	uint target;
-	IFramebuffer* framebuffer;
+	FBO framebuffer;
 };
 
 struct ShaderBuilder
@@ -658,7 +661,7 @@
 void NodeGLSLShader::Setup (NodeSetupParams&amp; params)
 {/*
 	if (renderBuffer) { // use a offscreen rendering buffer
-		renderBuffer-&gt;framebuffer-&gt;select();
+		renderBuffer-&gt;framebuffer.Bind();
 		glViewport(0, 0, renderBuffer-&gt;width, renderBuffer-&gt;height);
 	}*/
 
@@ -765,12 +768,12 @@
 	if (buffer)
 	{
 		if (pass == 0) {
-			buffer-&gt;framebuffer-&gt;select();
+			buffer-&gt;framebuffer.Bind();
 			glViewport(0, 0, buffer-&gt;width, buffer-&gt;height);
 			glClear(GL_DEPTH_BUFFER_BIT|GL_COLOR_BUFFER_BIT);
 		}
 		else if (pass==1) {
-			buffer-&gt;framebuffer-&gt;deselect();
+			buffer-&gt;framebuffer.Unbind();
 			glViewport(gu-&gt;viewPosX, gu-&gt;viewPosY, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
 		}
 	}

Modified: trunk/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/Env/BumpWater.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -82,39 +82,6 @@
 }
 
 
-static void PrintFboError(string fbo, GLenum error)
-{
-	switch(error) {
-		case GL_FRAMEBUFFER_COMPLETE_EXT:
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)has no images/buffers attached!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)missing a required image/buffer attachment!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)has mismatched image/buffer dimensions!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)colorbuffer attachments have different types!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)incomplete draw buffers!&quot;);
-			break;
-		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)trying to read from a non-attached color buffer!&quot;);
-			break;
-		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)format is not supported by current graphics card/driver!&quot;);
-			break;
-		default:
-			logOutput.Print(&quot;BumpWater-FBO: (&quot;+fbo+&quot;)*UNKNOWN ERROR*&quot;);
-			break;
-	}
-}
-
-
 static string LoadShaderSource(const string&amp; file)
 {
 	CFileHandler fh(file);
@@ -309,15 +276,17 @@
 		blurDirLoc = glGetUniformLocation(blurShader, &quot;blurDir&quot;);
 		blurTexLoc = glGetUniformLocation(blurShader, &quot;texture&quot;);
 
-		glGenFramebuffersEXT(1,&amp;coastFBO);
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
-		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coastTexture[0], 0);
-		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, coastTexture[1], 0);
-		//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		coastFBO.reloadOnAltTab = true;
+		coastFBO.Bind();
+		coastFBO.AttachTexture(coastTexture[0], GL_TEXTURE_2D, GL_COLOR_ATTACHMENT0_EXT);
+		coastFBO.AttachTexture(coastTexture[1], GL_TEXTURE_2D, GL_COLOR_ATTACHMENT1_EXT);
+		//coastFBO.Unbind();
 
-		//! initialize
-		UploadCoastline(0, 0, gs-&gt;mapx, gs-&gt;mapy);
-		UpdateCoastmap(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+		if (coastFBO.CheckStatus(&quot;BUMPWATER(Coastmap)&quot;)) {
+			//! initialize
+			UploadCoastline(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+			UpdateCoastmap(0, 0, gs-&gt;mapx, gs-&gt;mapy);
+		}else shoreWaves=false;
 	}
 
 
@@ -412,58 +381,26 @@
 		}
 
 		if (reflection) {
-			glGenRenderbuffersEXT(1, &amp;reflectRBO);
-			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, reflectRBO);
-			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, depthRBOFormat, reflTexSize, reflTexSize);
-
-			glGenFramebuffersEXT(1,&amp;reflectFBO);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
-			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, reflectRBO);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
-			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-				PrintFboError(&quot;reflection&quot;,status);
-				glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
-				glDeleteFramebuffersEXT(1,  &amp;reflectFBO);
-				reflectFBO = 0;
-			}
+			reflectFBO.Bind();
+			reflectFBO.CreateRenderBuffer(GL_DEPTH_ATTACHMENT_EXT, depthRBOFormat, reflTexSize, reflTexSize);
+			reflectFBO.AttachTexture(reflectTexture);
 		}
 
 		if (refraction&gt;0) {
-			glGenRenderbuffersEXT(1, &amp;refractRBO);
-			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, refractRBO);
-			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, depthRBOFormat, screenTextureX, screenTextureY);
-
-			glGenFramebuffersEXT(1,&amp;refractFBO);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
-			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, refractRBO);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, target, refractTexture, 0);
-			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-				PrintFboError(&quot;refraction&quot;,status);
-				glDeleteRenderbuffersEXT(1, &amp;refractRBO);
-				glDeleteFramebuffersEXT(1,  &amp;refractFBO);
-				refractFBO = 0;
-			}
+			refractFBO.Bind();
+			refractFBO.CreateRenderBuffer(GL_DEPTH_ATTACHMENT_EXT, depthRBOFormat, screenTextureX, screenTextureY);
+			refractFBO.AttachTexture(refractTexture,target);
 		}
 
 		if (dynWaves) {
-			glGenFramebuffersEXT(1,&amp;dynWavesFBO);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
-			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, normalTexture, 0);
-			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-				PrintFboError(&quot;dynamicWaves&quot;,status);
-				glDeleteFramebuffersEXT(1,  &amp;dynWavesFBO);
-				dynWavesFBO = 0;
-			}else{
+			dynWavesFBO.reloadOnAltTab = true;
+			dynWavesFBO.Bind();
+			dynWavesFBO.AttachTexture(normalTexture);
+			if (dynWavesFBO.CheckStatus(&quot;BUMPWATER(DynWaves)&quot;)) {
 				UpdateDynWaves(true); //! initialize
 			}
 		}
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		FBO::Unbind();
 	}
 
 
@@ -505,7 +442,7 @@
 		const float shadingZ = (float)gs-&gt;mapy / gs-&gt;pwr2mapy;
 
 		GLSLDefineConst4f(definitions, &quot;TexGenPlane&quot;, 1.0f/mapX, 1.0f/mapZ, shadingX/mapX, shadingZ/mapZ);
-		GLSLDefineConstf2(definitions, &quot;ShadingPlane&quot;, shadingX,shadingZ);
+		GLSLDefineConstf2(definitions, &quot;ShadingPlane&quot;, shadingX-0.2/gs-&gt;pwr2mapx,shadingZ-0.2/gs-&gt;pwr2mapy);
 	}
 
 	/** LOAD SHADERS **/
@@ -593,16 +530,6 @@
 	if (depthCopy)
 		glDeleteTextures(1, &amp;depthTexture);
 
-	if (reflectFBO) {
-		glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
-		glDeleteFramebuffersEXT(1,  &amp;reflectFBO);
-	}
-
-	if (refractFBO) {
-		glDeleteRenderbuffersEXT(1, &amp;refractRBO);
-		glDeleteFramebuffersEXT(1,  &amp;refractFBO);
-	}
-
 	glDeleteTextures(1, &amp;foamTexture);
 	glDeleteTextures(1, &amp;normalTexture);
 	for (int i = 0; i &lt; (int)caustTextures.size(); ++i) {
@@ -622,20 +549,13 @@
 		if (pboID)
 			glDeleteBuffers(1, &amp;pboID);
 
-		if (coastFBO)
-			glDeleteFramebuffersEXT(1, &amp;coastFBO);
-
 		glDeleteShader(blurFP);
 		glDeleteProgram(blurShader);
 	}
 
 	if (dynWaves) {
 		glDeleteTextures(1, &amp;normalTexture2);
-
 		delete[] tileOffsets;
-
-		if (dynWavesFBO)
-			glDeleteFramebuffersEXT(1, &amp;dynWavesFBO);
 	}
 }
 
@@ -679,8 +599,7 @@
 
 	}
 
-	if (coastmapNeedUpdate &amp;&amp; ((gs-&gt;frameNum + 14) % 15)==0)
-	{
+	if (coastmapNeedUpdate &amp;&amp; ((gs-&gt;frameNum + 14) % 15)==0) {
 		UpdateCoastmap(coastUpdateX1, coastUpdateZ1, coastUpdateX2, coastUpdateZ2);
 		coastmapNeedUpdate = false;
 	}
@@ -787,36 +706,58 @@
 	glDepthMask(GL_FALSE);
 	glDisable(GL_DEPTH_TEST);
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
-	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-	if (status == GL_FRAMEBUFFER_COMPLETE_EXT) {
-		glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
-		glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
-		glMatrixMode(GL_TEXTURE);
-			glPushMatrix();
-			glLoadIdentity();
-			glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
-		glMatrixMode(GL_PROJECTION);
-			glPushMatrix();
-			glLoadIdentity();
-			glOrtho(0,1,0,1,-1,1);
-		glMatrixMode(GL_MODELVIEW);
-			glPushMatrix();
-			glLoadIdentity();
-			glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
+	coastFBO.Bind();
 
-		glViewport(0,0,gs-&gt;mapx, gs-&gt;mapy);
-		glUseProgram(blurShader);
+	glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, coastTexture[1]);
+	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	glMatrixMode(GL_TEXTURE);
+		glPushMatrix();
+		glLoadIdentity();
+		glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
+	glMatrixMode(GL_PROJECTION);
+		glPushMatrix();
+		glLoadIdentity();
+		glOrtho(0,1,0,1,-1,1);
+	glMatrixMode(GL_MODELVIEW);
+		glPushMatrix();
+		glLoadIdentity();
+		glScalef(1.0f/gs-&gt;mapx, 1.0f/gs-&gt;mapy, 1);
 
-		int xmin = max(x1 - 10*2,0);
-		int xmax = min(x2 + 10*2,gs-&gt;mapx);
-		int ymin = max(y1 - 10*2,0);
-		int ymax = min(y2 + 10*2,gs-&gt;mapy);
-		int xsize = xmax - xmin;
-		int ysize = ymax - ymin;
+	glViewport(0,0,gs-&gt;mapx, gs-&gt;mapy);
+	glUseProgram(blurShader);
 
+	int xmin = max(x1 - 10*2,0);
+	int xmax = min(x2 + 10*2,gs-&gt;mapx);
+	int ymin = max(y1 - 10*2,0);
+	int ymax = min(y2 + 10*2,gs-&gt;mapy);
+	int xsize = xmax - xmin;
+	int ysize = ymax - ymin;
+
+	glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
+	glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
+	glUniform1i(blurTexLoc,1);
+
+	glBegin(GL_QUADS);
+		glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+		glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+		glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+		glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
+	glEnd();
+
+	for (int i=0; i&lt;5; ++i){
+		glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
+		glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
+		glUniform1i(blurTexLoc,0);
+
+		glBegin(GL_QUADS);
+			glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
+			glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
+			glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
+			glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
+		glEnd();
+
 		glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
 		glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
 		glUniform1i(blurTexLoc,1);
@@ -827,49 +768,25 @@
 			glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
 			glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
 		glEnd();
+	}
 
-		for (int i=0; i&lt;5; ++i){
-			glUniform2f(blurDirLoc,0.0f,1.0f/gs-&gt;mapy);
-			glDrawBuffer(GL_COLOR_ATTACHMENT1_EXT);
-			glUniform1i(blurTexLoc,0);
+	glMatrixMode(GL_TEXTURE);
+		glPopMatrix();
+	glMatrixMode(GL_PROJECTION);
+		glPopMatrix();
+	glMatrixMode(GL_MODELVIEW);
+		glPopMatrix();
 
-			glBegin(GL_QUADS);
-				glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
-				glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
-				glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
-				glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
-			glEnd();
+	//glActiveTexture(GL_TEXTURE0);
+	//glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
+	glGenerateMipmapEXT(GL_TEXTURE_2D);
 
-			glUniform2f(blurDirLoc,1.0f/gs-&gt;mapx,0.0f);
-			glDrawBuffer(GL_COLOR_ATTACHMENT0_EXT);
-			glUniform1i(blurTexLoc,1);
+	glUseProgram(0);
+	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
-			glBegin(GL_QUADS);
-				glTexCoord2f(xmin,ymin); glVertex2f(xmin,ymin);
-				glTexCoord2f(xmin,ymax); glVertex2f(xmin,ymax);
-				glTexCoord2f(xmax,ymax); glVertex2f(xmax,ymax);
-				glTexCoord2f(xmax,ymin); glVertex2f(xmax,ymin);
-			glEnd();
-		}
-
-		glMatrixMode(GL_TEXTURE);
-			glPopMatrix();
-		glMatrixMode(GL_PROJECTION);
-			glPopMatrix();
-		glMatrixMode(GL_MODELVIEW);
-			glPopMatrix();
-
-		//glActiveTexture(GL_TEXTURE0);
-		//glBindTexture(GL_TEXTURE_2D, coastTexture[0]);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
-		glGenerateMipmapEXT(GL_TEXTURE_2D);
-
-		glUseProgram(0);
-		glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
-	}else PrintFboError(&quot;coast&quot;,status);
-
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	coastFBO.Unbind();
 }
 
 
@@ -879,7 +796,7 @@
 
 void CBumpWater::UpdateDynWaves(const bool initialize)
 {
-	if (!dynWaves || !dynWavesFBO)
+	if (!dynWaves || !dynWavesFBO.IsValid())
 		return;
 
 	static const unsigned char tiles  = mapInfo-&gt;water.numTiles; //! (numTiles &lt;= 16)
@@ -896,7 +813,7 @@
 		}
 	}
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
+	dynWavesFBO.Bind();
 	glBindTexture(GL_TEXTURE_2D, normalTexture2);
 	glBlendFunc(GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA);
 	glBlendColor(1.0f,1.0f,1.0f, (initialize) ? 1.0f : (f + 1)/600.0f );
@@ -938,7 +855,7 @@
 		glPopMatrix();
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	dynWavesFBO.Unbind();
 
 	glBindTexture(GL_TEXTURE_2D, normalTexture);
 	glGenerateMipmapEXT(GL_TEXTURE_2D);
@@ -957,17 +874,13 @@
 	if (refraction == 1) {
 		//! _SCREENCOPY_ REFRACT TEXTURE
 		glBindTexture(target, refractTexture);
-		glEnable(target);
 		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
-		glDisable(target);
 	}
 
 	if (depthCopy) {
 		//! _SCREENCOPY_ DEPTH TEXTURE
 		glBindTexture(target, depthTexture);
-		glEnable(target);
 		glCopyTexSubImage2D(target, 0, 0, 0, gu-&gt;viewPosX, 0, gu-&gt;viewSizeX, gu-&gt;viewSizeY);
-		glDisable(target);
 	}
 
 	glDisable(GL_ALPHA_TEST);
@@ -1005,8 +918,8 @@
 void CBumpWater::DrawRefraction(CGame* game)
 {
 	//! _RENDER_ REFRACTION TEXTURE
-	if (refractFBO)
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, refractFBO);
+	if (refractFBO.IsValid())
+		refractFBO.Bind();
 
 	camera-&gt;Update(false);
 	glViewport(0,0,screenTextureX,screenTextureY);
@@ -1038,13 +951,11 @@
 	game-&gt;SetDrawMode(CGame::normalDraw);
 	drawRefraction=false;
 
-	if (refractFBO) {
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	if (refractFBO.IsValid()) {
+		refractFBO.Unbind();
 	}else{
 		glBindTexture(target, refractTexture);
-		glEnable(target);
 		glCopyTexSubImage2D(target,0,0,0,0,0,screenTextureX,screenTextureY);
-		glDisable(target);
 	}
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
@@ -1058,8 +969,8 @@
 void CBumpWater::DrawReflection(CGame* game)
 {
 	//! CREATE REFLECTION TEXTURE
-	if (reflectFBO)
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, reflectFBO);
+	if (reflectFBO.IsValid())
+		reflectFBO.Bind();
 
 //	CCamera *realCam = camera;
 //	camera = new CCamera(*realCam);
@@ -1094,13 +1005,11 @@
 	drawReflection=false;
 	glDisable(GL_CLIP_PLANE2);
 
-	if (reflectFBO) {
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+	if (reflectFBO.IsValid()) {
+		reflectFBO.Unbind();
 	}else{
 		glBindTexture(GL_TEXTURE_2D, reflectTexture);
-		glEnable(GL_TEXTURE_2D);
 		glCopyTexSubImage2D(GL_TEXTURE_2D,0,0,0,0,0,reflTexSize, reflTexSize);
-		glDisable(GL_TEXTURE_2D);
 	}
 
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);

Modified: trunk/rts/Rendering/Env/BumpWater.h
===================================================================
--- trunk/rts/Rendering/Env/BumpWater.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/Env/BumpWater.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -5,6 +5,7 @@
 #ifndef __BUMP_WATER_H__
 #define __BUMP_WATER_H__
 
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;BaseWater.h&quot;
 
@@ -46,12 +47,10 @@
 	int  screenTextureX;
 	int  screenTextureY;
 
-	GLuint reflectRBO;
-	GLuint refractRBO;
-	GLuint reflectFBO;
-	GLuint refractFBO;
-	GLuint coastFBO;
-	GLuint dynWavesFBO;
+	FBO reflectFBO;
+	FBO refractFBO;
+	FBO coastFBO;
+	FBO dynWavesFBO;
 
 	GLuint displayList;
 

Modified: trunk/rts/Rendering/GL/FBO.cpp
===================================================================
--- trunk/rts/Rendering/GL/FBO.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/GL/FBO.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -1,10 +1,9 @@
 /**
  * @file FBO.cpp
  * @brief EXT_framebuffer_object implementation
- * @author Christopher Han &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">xiphux at gmail.com</A>&gt;
  *
  * EXT_framebuffer_object class implementation
- * Copyright (C) 2005.  Licensed under the terms of the
+ * Copyright (C) 2008.  Licensed under the terms of the
  * GNU GPL, v2 or later.
  */
 #include &quot;StdAfx.h&quot;
@@ -12,123 +11,371 @@
 #include &lt;vector&gt;
 #include &quot;mmgr.h&quot;
 
-#include &quot;IFramebuffer.h&quot;
 #include &quot;FBO.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Rendering/Textures/Bitmap.h&quot;
 
+std::vector&lt;FBO*&gt; FBO::fboList;
+std::map&lt;GLuint,FBO::TexData*&gt; FBO::texBuf;
 
-IFramebuffer::~IFramebuffer()
+
+/**
+ * Returns if the current gpu supports Framebuffer Objects
+ */
+bool FBO::IsSupported()
 {
+	return (GLEW_EXT_framebuffer_object);
 }
 
 
-IFramebuffer* instantiate_fb(const int w, const int h, const int requires)
+/**
+ * Detects the textureTarget just by the textureName/ID
+ */
+GLenum FBO::GetTextureTargetByID(const GLuint id, const unsigned int i)
 {
-	if (GLEW_EXT_framebuffer_object) {
-		//logOutput.Print(&quot;Using EXT_framebuffer_object&quot;);
-		return SAFE_NEW FBO(requires, w, h);
+	static GLenum _targets[ 4 ] = { GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_1D, GL_TEXTURE_3D };
+	GLint format;
+	glBindTexture(_targets[i],id);
+	glGetTexLevelParameteriv(_targets[i], 0, GL_TEXTURE_INTERNAL_FORMAT, &amp;format);
+
+	if (format!=1) {
+		return _targets[i];
+	} else if (i&lt;3) {
+		return GetTextureTargetByID(id, i+1);
+	} else	return -1;
+}
+
+
+/**
+ * Makes a copy of a texture/RBO in the system ram
+ */
+void FBO::DownloadAttachment(const GLenum attachment)
+{
+	GLuint target;
+	glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT, attachment,
+		GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT,
+		(GLint*)&amp;target);
+	GLuint id;
+	glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT, attachment,
+		GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT,
+		(GLint*)&amp;id);
+
+	if (target==GL_NONE || id==0)
+		return;
+
+	if (texBuf.find(id)!=texBuf.end())
+		return;
+
+	if (target==GL_TEXTURE) {
+		target = GetTextureTargetByID(id);
+
+		if (target&lt;0)
+			return;
 	}
-	//logOutput.Print(&quot;No supported pixel buffer found&quot;);
-	return NULL;
+
+	struct FBO::TexData* tex = SAFE_NEW FBO::TexData;
+	tex-&gt;id = id;
+	tex-&gt;target = target;
+
+	int bits = 0;
+
+	if (target==GL_RENDERBUFFER_EXT) {
+		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, id);
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_WIDTH_EXT,  &amp;tex-&gt;xsize);
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_HEIGHT_EXT, &amp;tex-&gt;ysize);
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_INTERNAL_FORMAT_EXT, (GLint*)&amp;tex-&gt;format);
+
+		GLint _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_RED_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_GREEN_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_BLUE_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_ALPHA_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_DEPTH_SIZE_EXT, &amp;_cbits); bits += _cbits;
+		glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_STENCIL_SIZE_EXT, &amp;_cbits); bits += _cbits;
+	} else {
+		glBindTexture(target,id);
+
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_WIDTH, &amp;tex-&gt;xsize);
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_HEIGHT, &amp;tex-&gt;ysize);
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_DEPTH, &amp;tex-&gt;zsize);
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_INTERNAL_FORMAT, (GLint*)&amp;tex-&gt;format);
+
+		GLint _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_RED_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_GREEN_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_BLUE_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_ALPHA_SIZE, &amp;_cbits); bits += _cbits;
+		glGetTexLevelParameteriv(target, 0, GL_TEXTURE_DEPTH_SIZE, &amp;_cbits); bits += _cbits;
+	}
+
+
+	switch (target) {
+		case GL_TEXTURE_3D:
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*tex-&gt;ysize*tex-&gt;zsize*(bits/8)];
+			glGetTexImage(tex-&gt;target,0,/*FIXME*/GL_RGBA,/*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			break;
+		case GL_TEXTURE_1D:
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*(bits/8)];
+			glGetTexImage(tex-&gt;target,0,/*FIXME*/GL_RGBA,/*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			break;
+		case GL_RENDERBUFFER_EXT:
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*tex-&gt;ysize*(bits/8)];
+			glReadBuffer(attachment);
+			glReadPixels(0, 0, tex-&gt;xsize, tex-&gt;ysize, /*FIXME*/GL_RGBA, /*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			break;
+		default: //GL_TEXTURE_2D &amp; GL_TEXTURE_RECTANGLE
+			tex-&gt;pixels = SAFE_NEW unsigned char[tex-&gt;xsize*tex-&gt;ysize*(bits/8)];
+			glGetTexImage(tex-&gt;target,0,/*FIXME*/GL_RGBA,/*FIXME*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+	}
+	texBuf[id] = tex;
 }
 
+/**
+ * @brief GLContextLost
+ */
+void FBO::GLContextLost()
+{
+	//GML_STDMUTEX_LOCK(draw);
 
+	GLint oldReadBuffer;
+
+	for (std::vector&lt;FBO*&gt;::iterator fi=fboList.begin(); fi!=fboList.end(); ++fi) {
+		if ((*fi)-&gt;reloadOnAltTab) {
+			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, (*fi)-&gt;fboId);
+			glGetIntegerv(GL_READ_BUFFER,&amp;oldReadBuffer);
+
+			for(int i = 0; i &lt; 15; ++i) {
+				DownloadAttachment(GL_COLOR_ATTACHMENT0_EXT + i);
+			}
+			DownloadAttachment(GL_DEPTH_ATTACHMENT_EXT);
+			DownloadAttachment(GL_STENCIL_ATTACHMENT_EXT);
+
+			glReadBuffer(oldReadBuffer);
+		}
+	}
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+}
+
+
 /**
+ * @brief GLContextReinit
+ */
+void FBO::GLContextReinit()
+{
+	//GML_STDMUTEX_LOCK(draw);
+	for (std::map&lt;GLuint,FBO::TexData*&gt;::iterator ti=texBuf.begin(); ti!=texBuf.end(); ++ti) {
+		FBO::TexData* tex = ti-&gt;second;
+
+		if (glIsTexture(tex-&gt;id)) {
+			glBindTexture(tex-&gt;target,tex-&gt;id);
+			//todo: regen mipmaps?
+			switch (tex-&gt;target) {
+				case GL_TEXTURE_3D:
+					//glTexSubImage3D(tex-&gt;target, 0, 0,0,0, tex-&gt;xsize, tex-&gt;ysize, tex-&gt;zsize, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					glTexImage3D(tex-&gt;target, 0, tex-&gt;format, tex-&gt;xsize, tex-&gt;ysize, tex-&gt;zsize, 0, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					break;
+				case GL_TEXTURE_1D:
+					//glTexSubImage1D(tex-&gt;target, 0, 0, tex-&gt;xsize, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					glTexImage1D(tex-&gt;target, 0, tex-&gt;format, tex-&gt;xsize, /*FIXME?*/GL_RGBA, 0, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					break;
+				default: //GL_TEXTURE_2D &amp; GL_TEXTURE_RECTANGLE
+					//glTexSubImage2D(tex-&gt;target, 0, 0,0, tex-&gt;xsize, tex-&gt;ysize, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+					glTexImage2D(tex-&gt;target, 0, tex-&gt;format, tex-&gt;xsize, tex-&gt;ysize, 0, /*FIXME?*/GL_RGBA, /*FIXME?*/GL_UNSIGNED_BYTE, tex-&gt;pixels);
+			}
+		}else if (glIsRenderbufferEXT(tex-&gt;id)) {
+			//FIXME
+		}
+
+		delete[] tex-&gt;pixels;
+		delete tex;
+	}
+	texBuf.clear();
+}
+
+
+/**
  * Tests for support of the EXT_framebuffer_object
  * extension, and generates a framebuffer if supported
  */
-FBO::FBO(int requires, int w, int h) : frameBuffer(0), depthRenderBuffer(0), requires(requires)
+FBO::FBO() : fboId(0), reloadOnAltTab(false)
 {
-	glGenFramebuffersEXT(1,&amp;frameBuffer);
-	// Is a depth renderbuffer needed?
-	if ((requires &amp; FBO_NEED_DEPTH) &amp;&amp; !(requires &amp; FBO_NEED_DEPTH_TEXTURE))
-	{
-		select();
-		glGenRenderbuffersEXT(1, &amp;depthRenderBuffer);
-		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depthRenderBuffer);
-		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, w, h);
-		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT,
-										GL_RENDERBUFFER_EXT, depthRenderBuffer);
-		deselect();
+	if (IsSupported()) {
+		glGenFramebuffersEXT(1,&amp;fboId);
+
+		// we need to bind it once, else it isn't valid
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboId);
+
+		//GML_STDMUTEX_LOCK(fbo);
+		fboList.push_back(this);
 	}
 }
 
+
 /**
  * Unbinds the framebuffer and deletes it
  */
 FBO::~FBO()
 {
 	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
-	if (frameBuffer)
-		glDeleteFramebuffersEXT(1,&amp;frameBuffer);
+	if (fboId)
+		glDeleteFramebuffersEXT(1, &amp;fboId);
 
 	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);
-	if (depthRenderBuffer)
-		glDeleteRenderbuffersEXT(1, &amp;depthRenderBuffer);
+	for (std::vector&lt;GLuint&gt;::iterator ri=myRBOs.begin(); ri!=myRBOs.end(); ++ri) {
+		glDeleteRenderbuffersEXT(1, &amp;(*ri));
+	}
+
+	//GML_STDMUTEX_LOCK(fbo);
+	for (std::vector&lt;FBO*&gt;::iterator fi=fboList.begin(); fi!=fboList.end(); ++fi) {
+		if (*fi==this) {
+			fboList.erase(fi);
+			break;
+		}
+	}
+
+	// seems the application exits and we are the last fbo left
+	// so we delete the remaining alloc'ed stuff
+	if (fboList.empty()) {
+		for (std::map&lt;GLuint,FBO::TexData*&gt;::iterator ti=texBuf.begin(); ti!=texBuf.end(); ++ti) {
+			FBO::TexData* tex = ti-&gt;second;
+			delete[] tex-&gt;pixels;
+			delete tex;
+		}
+		texBuf.clear();
+	}
 }
 
+
 /**
- * Tests whether or not we have a valid framebuffer
+ * Tests whether or not if we have a valid framebuffer
  */
-bool FBO::valid(void)
+bool FBO::IsValid()
 {
-	return frameBuffer != 0;
+	return (fboId!=0);
 }
 
+
 /**
  * Makes the framebuffer the active framebuffer context
  */
-void FBO::select(void)
+void FBO::Bind(void)
 {
-	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, frameBuffer);
+	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboId);
 }
 
+
 /**
  * Unbinds the framebuffer from the current context
  */
-void FBO::deselect(void)
+void FBO::Unbind()
 {
 	glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 }
 
+
 /**
  * Tests if the framebuffer is a complete and
  * legitimate framebuffer
  */
-bool FBO::checkFBOStatus(void)
+bool FBO::CheckStatus(std::string name)
 {
-	GLenum status;
-	status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-	if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
-		//logOutput.Print(&quot;FBO is not GL_FRAMEBUFFER_COMPLETE_EXT: 0x%X&quot;, status);
-		assert(false);
-		return false;
+	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+	switch(status) {
+		case GL_FRAMEBUFFER_COMPLETE_EXT:
+			return true;
+		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: has no images/buffers attached!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: missing a required image/buffer attachment!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: has mismatched image/buffer dimensions!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: colorbuffer attachments have different types!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: incomplete draw buffers!&quot;);
+			break;
+		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot;: trying to read from a non-attached color buffer!&quot;);
+			break;
+		case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
+			logOutput.Print(&quot;FBO-&quot;+name+&quot; error: GL_FRAMEBUFFER_UNSUPPORTED_EXT&quot;);
+			break;
+		default:
+			logOutput.Print(std::string(&quot;FBO-&quot;+name+&quot; error: 0x%X&quot;).c_str(),status);
+			break;
 	}
-	return true;
+	return false;
 }
 
+
 /**
+ * Returns the current framebuffer status
+ */
+GLenum FBO::GetStatus()
+{
+	return glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
+}
+
+
+/**
  * Attaches a GL texture to the framebuffer
  */
-void FBO::attachTexture(GLuint tex, const unsigned int textype, FramebufferAttachType attachtype)
+void FBO::AttachTexture(const GLuint texId, const GLenum texTarget, const GLenum attachment, const int mipLevel, const int zSlice )
 {
-	GLenum glattachtype;
+	if (texTarget == GL_TEXTURE_1D) {
+		glFramebufferTexture1DEXT(GL_FRAMEBUFFER_EXT, attachment, GL_TEXTURE_1D, texId, mipLevel);
+	} else if (texTarget == GL_TEXTURE_3D) {
+		glFramebufferTexture3DEXT(GL_FRAMEBUFFER_EXT, attachment, GL_TEXTURE_3D, texId, mipLevel, zSlice);
+	} else {
+		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, texTarget, texId, mipLevel);
+	}
+}
 
-	switch (attachtype)
-	{
-		case FBO_ATTACH_DEPTH:
-			assert (requires &amp; FBO_NEED_DEPTH_TEXTURE);
-			glattachtype = GL_DEPTH_ATTACHMENT_EXT;
-			break;
-		case FBO_ATTACH_COLOR:
-			assert (requires &amp; FBO_NEED_COLOR);
-			glattachtype = GL_COLOR_ATTACHMENT0_EXT;
-			break;
-		default:
-			assert(false);
-			break;
+
+/**
+ * Attaches a GL RenderBuffer to the framebuffer
+ */
+void FBO::AttachRenderBuffer(const GLuint rboId, const GLenum attachment)
+{
+	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, attachment, GL_RENDERBUFFER_EXT, rboId);
+}
+
+
+/**
+ * Unattaches an attachment from the framebuffer
+ */
+void FBO::Unattach(const GLenum attachment)
+{
+	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, attachment, GL_TEXTURE_2D, 0, 0);
+}
+
+
+/**
+ * Unattaches any attachments from the framebuffer
+ */
+void FBO::UnattachAll()
+{
+	for(int i = 0; i &lt; 15; ++i) {
+		Unattach(GL_COLOR_ATTACHMENT0_EXT + i);
 	}
-	select();
-	glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, glattachtype, textype, tex, 0);
-	deselect();
+	Unattach(GL_DEPTH_ATTACHMENT_EXT);
+	Unattach(GL_STENCIL_ATTACHMENT_EXT);
 }
+
+
+/**
+ * Creates and attaches a RBO
+ */
+void FBO::CreateRenderBuffer(const GLenum attachment, const GLenum format, const GLsizei width, const GLsizei height)
+{
+	GLuint rbo;
+	glGenRenderbuffersEXT(1, &amp;rbo);
+	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, rbo);
+	glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, format, width, height);
+	glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, attachment, GL_RENDERBUFFER_EXT, rbo);
+	myRBOs.push_back(rbo);
+}

Modified: trunk/rts/Rendering/GL/FBO.h
===================================================================
--- trunk/rts/Rendering/GL/FBO.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/GL/FBO.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -1,79 +1,165 @@
 /**
  * @file FBO.h
  * @brief EXT_framebuffer_object
- * @author Christopher Han &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">xiphux at gmail.com</A>&gt;
  *
  * EXT_framebuffer_object class definition
- * Copyright (C) 2005.  Licensed under the terms of the
+ * Copyright (C) 2008.  Licensed under the terms of the
  * GNU GPL, v2 or later.
  *
- * Framebuffer abstraction added by Jelmer Cnossen
  */
 #ifndef FBO_H
 #define FBO_H
 
 #include &quot;myGL.h&quot;
 
+//todo: add multisample buffers
+
 /**
  * @brief FBO
  *
- * Framebuffer Object class. Derived from the
- * abstract IFramebuffer class
+ * Framebuffer Object class.
  */
-class FBO : public IFramebuffer
+class FBO
 {
 public:
 	/**
-	 * @brief check FBO status
+	 * @brief IsSupported
+	 *
+	 * if FrameBuffers are supported by the current platform
 	 */
-	bool checkFBOStatus(void);
+	static bool IsSupported();
 
 	/**
-	 * @brief attach texture
-	 * @param tex texture to attach
-	 * @param textype type of texture
-	 * @param attachtype what kind of target to attach as
+	 * @brief Constructor
 	 */
-	void attachTexture(const GLuint tex, const unsigned int textype, FramebufferAttachType attachtype);
+	FBO();
 
 	/**
-	 * @brief select
+	 * @brief Destructor
 	 */
-	void select(void);
+	~FBO();
 
 	/**
-	 * @brief deselect
+	 * @brief fboId
+	 *
+	 * GLuint pointing to the current framebuffer
 	 */
-	void deselect(void);
+	GLuint fboId;
 
 	/**
-	 * @brief valid
+	 * @brief reloadOnAltTab
+	 *
+	 * bool save all attachments in system RAM and reloaded them on OpenGL-Context lost (alt-tab) (default: false)
+	 */
+	bool reloadOnAltTab;
+
+	/**
+	 * @brief check FBO status
+	 */
+	bool CheckStatus(std::string name);
+
+	/**
+	 * @brief get FBO status
+	 */
+	GLenum GetStatus();
+
+	/**
+	 * @brief IsValid
 	 * @return whether a valid framebuffer exists
 	 */
-	bool valid(void);
+	bool IsValid();
 
+	/**
+	 * @brief AttachTexture
+	 * @param texTarget texture target (GL_TEXTURE_2D etc.)
+	 * @param texId texture to attach
+	 * @param attachment (GL_COLOR_ATTACHMENT0_EXT etc.)
+	 * @param mipLevel miplevel to attach
+	 * @param zSlice z offset (3d textures only)
+	 */
+	void AttachTexture(const GLuint texId, const GLenum texTarget = GL_TEXTURE_2D, const GLenum attachment = GL_COLOR_ATTACHMENT0_EXT, const int mipLevel = 0, const int zSlice = 0);
+
+	/**
+	 * @brief AttachRenderBuffer
+	 * @param rboId RenderBuffer to attach
+	 * @param attachment
+	 */
+	void AttachRenderBuffer(const GLuint rboId, const GLenum attachment = GL_COLOR_ATTACHMENT0_EXT);
+
+	/**
+	 * @brief Creates a RenderBufferObject and attachs it to the FBO (it is also auto destructed)
+	 * @param attachment
+	 * @param format
+	 * @param width
+	 * @param height
+	 */
+	void CreateRenderBuffer(const GLenum attachment, const GLenum format, const GLsizei width, const GLsizei height);
+
+	/**
+	 * @brief Unattach
+	 * @param attachment
+	 */
+	void Unattach(const GLenum attachment);
+
+	/**
+	 * @brief UnattachAll
+	 */
+	void UnattachAll();
+
+	/**
+	 * @brief Bind
+	 */
+	void Bind();
+
+	/**
+	 * @brief Unbind
+	 */
+	static void Unbind();
+
+
+
+	/**
+	 * @brief GLContextLost (post atl-tab)
+	 */
+	static void GLContextLost();
+
+	/**
+	 * @brief GLContextReinit (pre atl-tab)
+	 */
+	static void GLContextReinit();
+
+
 private:
 	/**
-	 * @brief Constructor
+	 * @brief rbos
+	 *
+	 * List with all Renderbuffer Objects that should be destructed with the FBO
 	 */
-	FBO(int requires, int w, int h);
+	std::vector&lt;GLuint&gt; myRBOs;
 
+
+	static std::vector&lt;FBO*&gt; fboList;
+	struct TexData{
+		GLuint id;
+		unsigned char* pixels;
+		GLsizei xsize,ysize,zsize;
+		GLenum target,format,type;
+	};
+	static std::map&lt;GLuint,TexData*&gt; texBuf;
+
 	/**
-	 * @brief Destructor
+	 * @brief DownloadAttachment
+	 *
+	 * copies the attachment content to sysram
 	 */
-	~FBO();
+	static void DownloadAttachment(const GLenum attachment);
 
 	/**
-	 * @brief framebuffer
+	 * @brief GetTextureTargetByID
 	 *
-	 * GLuint pointing to the current framebuffer
+	 * detects the textureTarget just by the textureName/ID
 	 */
-	GLuint frameBuffer;
-	GLuint depthRenderBuffer;
-	int requires;
-
-	// instantiate_fb is the only code where new FBOs may be created
-	friend IFramebuffer* instantiate_fb(const int w, const int h, const int requires);
+	static GLenum GetTextureTargetByID(const GLuint id, const unsigned int i = 0);
 };
 
 #endif /* FBO_H */

Deleted: trunk/rts/Rendering/GL/IFramebuffer.h
===================================================================
--- trunk/rts/Rendering/GL/IFramebuffer.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/GL/IFramebuffer.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -1,38 +0,0 @@
-/*
- * IFramebuffer.h
- * IFramebuffer interface
- * Framebuffer abstraction by Jelmer Cnossen
- */
-#ifndef _IFRAMEBUFFER_H
-#define _IFRAMEBUFFER_H
-
-#include &quot;myGL.h&quot;
-
-enum FramebufferAttachType
-{
-	FBO_ATTACH_COLOR = 1,
-	FBO_ATTACH_DEPTH = 2,
-};
-
-class IFramebuffer
-{
-public:
-	virtual ~IFramebuffer();
-
-	virtual bool checkFBOStatus(void) = 0;
-	virtual void attachTexture(const GLuint tex, const unsigned int textype, FramebufferAttachType attachtype) = 0;
-	virtual void select(void) = 0;
-	virtual void deselect(void) = 0;
-	virtual bool valid(void) = 0;
-};
-
-enum FramebufferProperties
-{
-	FBO_NEED_DEPTH = 1, // zbuffering is needed, but only for rendering
-	FBO_NEED_DEPTH_TEXTURE = 2, // for shadow mapping
-	FBO_NEED_COLOR = 4
-};
-
-IFramebuffer* instantiate_fb(const int w, const int h, const int requires);
-
-#endif /* _IFRAMEBUFFER_H */

Modified: trunk/rts/Rendering/GL/myGL.cpp
===================================================================
--- trunk/rts/Rendering/GL/myGL.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/GL/myGL.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -19,7 +19,7 @@
 #include &quot;Util.h&quot;
 #include &quot;Exceptions.h&quot;
 
-#include &quot;IFramebuffer.h&quot;
+#include &quot;FBO.h&quot;
 
 using namespace std;
 

Modified: trunk/rts/Rendering/GLContext.h
===================================================================
--- trunk/rts/Rendering/GLContext.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/GLContext.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -24,6 +24,8 @@
 //            (use &quot;data&quot; for the pointer to the instance).
 
 
+// TODO: add event driven system (like alttab, resolution changed, dualscreen, ...)
+
 namespace GLContext
 {
 	typedef void (*Func)(void* data);

Modified: trunk/rts/Rendering/ShadowHandler.cpp
===================================================================
--- trunk/rts/Rendering/ShadowHandler.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/ShadowHandler.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -13,8 +13,8 @@
 #include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;GL/myGL.h&quot;
-#include &quot;GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;EventHandler.h&quot;
 
@@ -28,7 +28,7 @@
 bool CShadowHandler::firstInstance = true;
 
 
-CShadowHandler::CShadowHandler(void): fb(0)
+CShadowHandler::CShadowHandler(void)
 {
 	const bool tmpFirstInstance = firstInstance;
 	firstInstance = false;
@@ -88,8 +88,6 @@
 
 	if (configValue == 0) {
 		// free any resources allocated by InitDepthTarget()
-		delete fb;
-		fb = NULL;
 		glDeleteTextures(1, &amp;shadowTexture);
 		shadowTexture = 0;
 		return; // drawShadows is still false
@@ -104,10 +102,7 @@
 	// this can be enabled for debugging
 	// it turns the shadow render buffer in a buffer with color
 	bool useColorTexture = false;
-
-	fb = instantiate_fb(shadowMapSize, shadowMapSize,
-			(useColorTexture ? FBO_NEED_COLOR | FBO_NEED_DEPTH : FBO_NEED_DEPTH_TEXTURE));
-	if (!(fb &amp;&amp; fb-&gt;valid())) {
+	if (!fb.IsValid()) {
 		logOutput.Print(&quot;framebuffer not valid!&quot;);
 		return false;
 	}
@@ -124,23 +119,23 @@
 		glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, shadowMapSize, shadowMapSize, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
 	}
 	glBindTexture(GL_TEXTURE_2D, 0);
-	fb-&gt;select();
+	fb.Bind();
+	if (useColorTexture)
+		fb.AttachTexture(shadowTexture);
+	else
+		fb.AttachTexture(shadowTexture, GL_TEXTURE_2D, GL_DEPTH_ATTACHMENT_EXT);
 	int buffer = useColorTexture ? GL_COLOR_ATTACHMENT0_EXT : GL_NONE;
 	glDrawBuffer(buffer);
 	glReadBuffer(buffer);
-	if (useColorTexture)
-		fb-&gt;attachTexture(shadowTexture, GL_TEXTURE_2D, FBO_ATTACH_COLOR);
-	else
-		fb-&gt;attachTexture(shadowTexture, GL_TEXTURE_2D, FBO_ATTACH_DEPTH);
-	fb-&gt;checkFBOStatus();
-	return true;
+	bool status = fb.CheckStatus(&quot;SHADOW&quot;);
+	fb.Unbind();
+	return status;
 }
 
 CShadowHandler::~CShadowHandler(void)
 {
 	if (drawShadows)
 		glDeleteTextures(1, &amp;shadowTexture);
-	delete fb;
 }
 
 void CShadowHandler::DrawShadowPasses(void)
@@ -170,7 +165,7 @@
 
 void CShadowHandler::CreateShadows(void)
 {
-	fb-&gt;select();
+	fb.Bind();
 
 	glDisable(GL_BLEND);
 	glDisable(GL_LIGHTING);
@@ -250,7 +245,7 @@
 	glShadeModel(GL_SMOOTH);
 	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
 
-	fb-&gt;deselect();
+	fb.Unbind();
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 }
 

Modified: trunk/rts/Rendering/ShadowHandler.h
===================================================================
--- trunk/rts/Rendering/ShadowHandler.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Rendering/ShadowHandler.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -4,9 +4,8 @@
 #include &quot;Matrix44f.h&quot;
 #include &quot;GL/myGL.h&quot;
 #include &lt;vector&gt;
+#include &quot;Rendering/GL/FBO.h&quot;
 
-class IFramebuffer;
-
 class CShadowHandler
 {
 public:
@@ -52,7 +51,7 @@
 		float maxz;
 	};
 	std::vector&lt;fline&gt; left;
-	IFramebuffer *fb;
+	FBO fb;
 
 	bool firstDraw;
 	static bool firstInstance;

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -16,7 +16,7 @@
 #include &quot;ConfigHandler.h&quot;
 #include &quot;Rendering/GroundFlash.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
-#include &quot;Rendering/GL/IFramebuffer.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/GL/VertexArray.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
@@ -316,21 +316,15 @@
 
 	drawPerlinTex=false;
 
-	if (GLEW_EXT_framebuffer_object &amp;&amp; !GLEW_ATI_envmap_bumpmap) {
-		// this seems to bug on ati cards so disable it on those
-		// (just some random ati extension to detect ati cards),
-		// should be fixed by someone that actually has a ati card
-		perlinFB = instantiate_fb(512, 512, FBO_NEED_COLOR);
-		if (perlinFB &amp;&amp; perlinFB-&gt;valid()) {
-			perlinFB-&gt;attachTexture(textureAtlas-&gt;gltex, GL_TEXTURE_2D, FBO_ATTACH_COLOR);
-			perlinFB-&gt;select();
-			drawPerlinTex=perlinFB-&gt;checkFBOStatus();
-			perlinFB-&gt;deselect();
-		}
+	if (perlinFB.IsValid()) {
+		//we never refresh the full texture (just the perlin part). So we need to reload it then.
+		perlinFB.reloadOnAltTab = true;
+
+		perlinFB.Bind();
+		perlinFB.AttachTexture(textureAtlas-&gt;gltex);
+		drawPerlinTex=perlinFB.CheckStatus(&quot;PERLIN&quot;);
+		perlinFB.Unbind();
 	}
-	else {
-		perlinFB = 0;
-	}
 }
 
 CProjectileHandler::~CProjectileHandler()
@@ -367,7 +361,6 @@
 	ph=0;
 	delete textureAtlas;
 	delete groundFXAtlas;
-	delete perlinFB;
 }
 
 void CProjectileHandler::Serialize(creg::ISerializer *s)
@@ -758,10 +751,11 @@
 
 	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		CProjectile* p = (*psi);
-		const float3 ppos0 = p-&gt;pos;
-		const float3 ppos1 = p-&gt;pos + p-&gt;speed;
 
 		if (p-&gt;checkCol &amp;&amp; !p-&gt;deleteMe) {
+			const float3 ppos0 = p-&gt;pos;
+			const float3 ppos1 = p-&gt;pos + p-&gt;speed;
+
 			float speedf = p-&gt;speed.Length();
 
 			CUnit** endUnit = tempUnits;
@@ -926,9 +920,11 @@
 
 	GML_RECMUTEX_LOCK(proj); // AddFlyingPiece
 
+	flyings3oPieces.reserve(textureType);
 	while(flyings3oPieces.size()&lt;=textureType)
 		flyings3oPieces.push_back(vector&lt;FlyingPiece_List*&gt;());
 
+	flyings3oPieces[textureType].reserve(team);
 	while(flyings3oPieces[textureType].size()&lt;=team){
 		//logOutput.Print(&quot;Creating piece list %d %d.&quot;, textureType, flyings3oPieces[textureType].size());
 
@@ -959,23 +955,12 @@
 {
 	if (numPerlinProjectiles &amp;&amp; drawPerlinTex)
 		UpdatePerlin();
-/*
-	if(gs-&gt;frameNum==300){
-		logOutput.Print(&quot;Saving tex&quot;);
-		perlinFB-&gt;select();
-		unsigned char* buf=SAFE_NEW unsigned char[512*512*4];
-		glReadPixels(0,0,512,512,GL_RGBA,GL_UNSIGNED_BYTE,buf);
-		CBitmap b(buf,512,512);
-		b.ReverseYAxis();
-		b.Save(&quot;proj2.tga&quot;);
-		delete[] buf;
-		perlinFB-&gt;deselect();
-	}*/
 }
 
+
 void CProjectileHandler::UpdatePerlin()
 {
-	perlinFB-&gt;select();
+	perlinFB.Bind();
 	glViewport(perlintex.ixstart, perlintex.iystart, 128, 128);
 
 	glMatrixMode(GL_PROJECTION);
@@ -1043,7 +1028,7 @@
 		speed*=0.6f;
 		size*=2;
 	}
-	perlinFB-&gt;deselect();
+	perlinFB.Unbind();
 	glViewport(gu-&gt;viewPosX,0,gu-&gt;viewSizeX,gu-&gt;viewSizeY);
 
 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

Modified: trunk/rts/Sim/Projectiles/ProjectileHandler.h
===================================================================
--- trunk/rts/Sim/Projectiles/ProjectileHandler.h	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/Sim/Projectiles/ProjectileHandler.h	2008-12-05 12:54:36 UTC (rev 7125)
@@ -9,7 +9,6 @@
 struct S3DOPrimitive;
 struct S3DO;
 struct SS3OVertex;
-
 #include &lt;list&gt;
 #include &lt;vector&gt;
 
@@ -17,11 +16,11 @@
 #include &quot;MemPool.h&quot;
 #include &quot;Rendering/Textures/TextureAtlas.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;float3.h&quot;
 
 
 class CGroundFlash;
-class IFramebuffer;
 
 
 typedef std::list&lt;CProjectile*&gt; Projectile_List;
@@ -153,7 +152,7 @@
 
 	GLuint perlinTex[8];
 	float perlinBlend[4];
-	IFramebuffer *perlinFB;
+	FBO perlinFB;
 	bool drawPerlinTex;
 	std::vector&lt;CGroundFlash*&gt; groundFlashes;
 

Modified: trunk/rts/System/MouseInput.cpp
===================================================================
--- trunk/rts/System/MouseInput.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/System/MouseInput.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -16,7 +16,7 @@
 
 #include &lt;SDL_events.h&gt;
 #include &lt;SDL_syswm.h&gt;
-
+#include &quot;Rendering/GL/FBO.h&quot;
 #include &quot;GlobalUnsynced.h&quot;
 #include &quot;Platform/Win/win32.h&quot;
 #include &quot;MouseInput.h&quot;
@@ -53,20 +53,74 @@
 	// SDL runs the window in a different thread, hence the indirectness of the mouse pos handling
 	static LRESULT CALLBACK SpringWndProc(HWND wnd, UINT msg, WPARAM wparam, LPARAM lparam)
 	{
-		if (msg==WM_MOUSEMOVE) {
-			// cast to short to preserve sign
-			inst-&gt;mousepos = int2((short)LOWORD(lparam),(short)HIWORD(lparam));
-			inst-&gt;mousemoved = true;
-			return FALSE;
-		}else if (msg==WM_SETCURSOR) {
-			if (inst-&gt;hCursor!=NULL) {
-				Uint16 hittest = LOWORD(lparam);
-				if ( hittest == HTCLIENT ) {
-					SetCursor(inst-&gt;hCursor);
+		if (mouse) {
+			switch (msg) {
+				case WM_LBUTTONDOWN:
+					mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 1);
 					return TRUE;
+				case WM_RBUTTONDOWN:
+					mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 3);
+					return TRUE;
+				case WM_MBUTTONDOWN:
+					mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 2);
+					return TRUE;
+				case WM_LBUTTONUP:
+					mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 1);
+					return TRUE;
+				case WM_RBUTTONUP:
+					mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 3);
+					return TRUE;
+				case WM_MBUTTONUP:
+					mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 2);
+					return TRUE;
+				case WM_MOUSEWHEEL: {
+					float delta = (((short)HIWORD(wparam))/120.0f);
+					mouse-&gt;MouseWheel(delta);
+					return TRUE;
 				}
-			}
+				case WM_XBUTTONDOWN:
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON1)
+						mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 4);
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON2)
+						mouse-&gt;MousePress((short)LOWORD(lparam), (short)HIWORD(lparam), 5);
+					return TRUE;
+				case WM_XBUTTONUP:
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON1)
+						mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 4);
+					if ((short)LOWORD(wparam) &amp; MK_XBUTTON2)
+						mouse-&gt;MouseRelease((short)LOWORD(lparam), (short)HIWORD(lparam), 5);
+					return TRUE;
+				}
+
 		}
+
+		switch (msg) {
+			case WM_MOUSEMOVE:
+				// cast to short to preserve sign
+				inst-&gt;mousepos = int2((short)LOWORD(lparam),(short)HIWORD(lparam));
+				inst-&gt;mousemoved = true;
+				return FALSE;
+			case WM_SETCURSOR:
+				if (inst-&gt;hCursor!=NULL) {
+					Uint16 hittest = LOWORD(lparam);
+					if ( hittest == HTCLIENT ) {
+						SetCursor(inst-&gt;hCursor);
+						return TRUE;
+					}
+				}
+				break;
+			case WM_ACTIVATE:
+				// FIXME: move to SpringApp somehow and use GLContext.h instead!
+				if(fullscreen) {
+					if (wparam == WA_INACTIVE) {
+						FBO::GLContextLost();
+					}else if (wparam == WA_ACTIVE) {
+						FBO::GLContextReinit();
+					}
+				}
+				break;
+		}
+
 		return CallWindowProc((WNDPROC)inst-&gt;sdl_wndproc, wnd, msg, wparam, lparam);
 	}
 
@@ -128,7 +182,7 @@
 
 	void HandleSDLMouseEvent (SDL_Event&amp; event)
 	{
-		if (!mouse)
+		/*if (!mouse)
 			return;
 
 		switch (event.type) {
@@ -140,25 +194,26 @@
 				if (msg-&gt;wParam &amp; 0x40) // MK_XBUTTON2
 					mouse-&gt;MousePress (mousepos.x, mousepos.y, 5);
 			}
+
 			break;}
-		/*case SDL_MOUSEMOTION: // the normal SDL method works fine in windowed mode
+		case SDL_MOUSEMOTION: // the normal SDL method works fine in windowed mode
 			if(!fullscreen) {
 				mousepos = int2(event.motion.x, event.motion.y);
 				mouse-&gt;MouseMove(mousepos.x, mousepos.y);
 			}
-			break;*/
+			break;
 		case SDL_MOUSEBUTTONDOWN:
 			if (event.button.button == SDL_BUTTON_WHEELUP)
-				mouse-&gt;MouseWheel(true);
+				mouse-&gt;MouseWheel(1.0f);
 			else if (event.button.button == SDL_BUTTON_WHEELDOWN)
-				mouse-&gt;MouseWheel(false);
+				mouse-&gt;MouseWheel(-1.0f);
 			else
 				mouse-&gt;MousePress(mousepos.x, mousepos.y,event.button.button);
 			break;
 		case SDL_MOUSEBUTTONUP:
 			mouse-&gt;MouseRelease(mousepos.x, mousepos.y,event.button.button);
 			break;
-		}
+		}*/
 	}
 };
 CWin32MouseInput* CWin32MouseInput::inst = 0;
@@ -194,9 +249,9 @@
 				mousepos = int2(event.button.x, event.button.y);
 				if (mouse) {
 					if (event.button.button == SDL_BUTTON_WHEELUP) {
-						mouse-&gt;MouseWheel(true);
+						mouse-&gt;MouseWheel(1.0f);
 					} else if (event.button.button == SDL_BUTTON_WHEELDOWN) {
-						mouse-&gt;MouseWheel(false);
+						mouse-&gt;MouseWheel(-1.0f);
 					} else {
 						mouse-&gt;MousePress(event.button.x, event.button.y, event.button.button);
 					}

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-12-05 12:42:49 UTC (rev 7124)
+++ trunk/rts/System/SpringApp.cpp	2008-12-05 12:54:36 UTC (rev 7125)
@@ -1011,7 +1011,7 @@
 		return -1;
 
 #ifdef WIN32
-	SDL_EventState (SDL_SYSWMEVENT, SDL_ENABLE);
+	//SDL_EventState (SDL_SYSWMEVENT, SDL_ENABLE);
 #endif
 
 #ifdef USE_GML
@@ -1064,10 +1064,8 @@
 					}
 					break;
 				}
-				case SDL_MOUSEMOTION: {
-					mouseInput-&gt;HandleSDLMouseEvent (event);
-					break;
-				}
+
+				case SDL_MOUSEMOTION:
 				case SDL_MOUSEBUTTONDOWN:
 				case SDL_MOUSEBUTTONUP:
 				case SDL_SYSWMEVENT: {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001893.html">[Taspring-linux-commit] r7124 - in trunk/rts: Game/UI Map/SMF	Rendering/Env Sim/Misc Sim/Projectiles/Unsynced Sim/Units	System/Platform/Win build/scons
</A></li>
	<LI>Next message: <A HREF="001895.html">[Taspring-linux-commit] r7126 - Lobby/springie/Springie/PlanetWars
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1894">[ date ]</a>
              <a href="thread.html#1894">[ thread ]</a>
              <a href="subject.html#1894">[ subject ]</a>
              <a href="author.html#1894">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
