<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5970 - in trunk: AI/Global/AAI game/AI/AAI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5970%20-%20in%20trunk%3A%20AI/Global/AAI%20game/AI/AAI&In-Reply-To=%3C20080601204851.D384046DD%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000749.html">
   <LINK REL="Next"  HREF="000751.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5970 - in trunk: AI/Global/AAI game/AI/AAI</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5970%20-%20in%20trunk%3A%20AI/Global/AAI%20game/AI/AAI&In-Reply-To=%3C20080601204851.D384046DD%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r5970 - in trunk: AI/Global/AAI game/AI/AAI">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sun Jun  1 22:48:51 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000749.html">[Taspring-linux-commit] r5969 - trunk/AI/Global/NTai/AI/NTai/Units
</A></li>
        <LI>Next message: <A HREF="000751.html">[Taspring-linux-commit] r5971 - in trunk: . AI/Global/AAI installer	installer/builddata installer/builddata/maphelper	installer/builddata/maphelper/maphelper	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Map rts/Map/SM3	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Sim/Features	rts/Sim/Misc rts/Sim/Projectiles rts/Sim/Units	rts/Sim/Units/CommandAI rts/System rts/System/FileSystem	rts/System/Script tools/unitsync tools/unitsync/test
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#750">[ date ]</a>
              <a href="thread.html#750">[ thread ]</a>
              <a href="subject.html#750">[ subject ]</a>
              <a href="author.html#750">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: submarine
Date: 2008-06-01 22:48:49 +0200 (Sun, 01 Jun 2008)
New Revision: 5970

Modified:
   trunk/AI/Global/AAI/AAI ReadMe.txt
   trunk/AI/Global/AAI/AAI.cpp
   trunk/AI/Global/AAI/AAI.h
   trunk/AI/Global/AAI/AAIBuildTask.cpp
   trunk/AI/Global/AAI/AAIBuildTask.h
   trunk/AI/Global/AAI/AAIConstructor.cpp
   trunk/AI/Global/AAI/AAIExecute.cpp
   trunk/AI/Global/AAI/AAIExecute.h
   trunk/AI/Global/AAI/AAIMap.cpp
   trunk/AI/Global/AAI/AAIUnitTable.cpp
   trunk/AI/Global/AAI/aidef.h
   trunk/game/AI/AAI/AAI ReadMe.txt
Log:
AAI v0.869:

- Added proper handling of resurrected units (however AAI does not build resurrectors atm)
		
- Fixed a bug that could prevent AAI from rebuilding destroyed factories

Modified: trunk/AI/Global/AAI/AAI ReadMe.txt
===================================================================
--- trunk/AI/Global/AAI/AAI ReadMe.txt	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAI ReadMe.txt	2008-06-01 20:48:49 UTC (rev 5970)
@@ -83,11 +83,11 @@
 
 
 
-Thanks to: 	- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
-
-		- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
+Thanks to: 	- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
 		  and coding contributions (since AAI v0.83) 
 
+		- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
+
 		- TA Spring devs for creating the best open source rts game I know
 
 		- Jelmer 'JC' Cnossen for some functions and a lot of helpful discussions
@@ -106,29 +106,23 @@
 
 
 
-AAI v0.868	- Improved fall back behaviour: units with turnrate below MIN_FALLBACK turnrate will not fall back anymore, long ranged 
-		  units (e.g. snipers) will not fall back to their maximum weapons range anymore; added keywords:	
-  		  MIN_FALLBACK_TURNRATE 250	  
-		  MAX_FALLBACK_RANGE 800  
+AAI v0.869	- Added proper handling of resurrected units (however AAI does not build resurrectors atm)
+		
+		- Fixed a bug that could prevent AAI from rebuilding destroyed factories	
 
-		- Fixed another possible freeze when AAI's attack manager was flooding the interface with orders
-	
 
-AAI v0.867	- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
-		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
+AAI v0.868	- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
+		  their turnrate is not too low)
 
-		- Fixed a bug that caused builders to leave the buildsite during construction 
+		- Added some new variables to mod config file:
 
-		- Various changes to issued orders; temporarily removed reclaiming. Reclaim orders were given multiple times per frame 
-		  thus flooding the interface with orders and causing Spring to freeze/huge drop in FPS 
-
-		- Added some unit specific combat behaviour: Units with high ranged weapons will now try to keep enemies distant
-
-		- Added two new variables to mod config file:
-
 		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
 		  
-		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all 
+		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
+		 
+		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
+	
+  		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
 
 		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 
 		  naval units
@@ -136,6 +130,14 @@
 		- AAI now takes continents into account when sending scouts to positions (e.g. it does not try send ground scouts to 
 		  positions on other islands/continents anymore)
 
+		- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
+		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
+
+		- Fixed a bug that caused builders to leave the buildsite during construction 
+
+		- Fixed various freezes that have been caused by AAI flooding the ai interface with thousands of orders per frame
+
+
 		- Bumped mod learning file version to 0.86 due to some changes in handling of amphibious units
 
 

Modified: trunk/AI/Global/AAI/AAI.cpp
===================================================================
--- trunk/AI/Global/AAI/AAI.cpp	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAI.cpp	2008-06-01 20:48:49 UTC (rev 5970)
@@ -33,6 +33,7 @@
 	{
 		activeUnits[i] = 0;
 		futureUnits[i] = 0;
+		requestedUnits[i] = 0;
 	}
 
 	activeScouts = futureScouts = 0;
@@ -262,128 +263,192 @@
 	const UnitDef *def = cb-&gt;GetUnitDef(unit);
 	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
 
+	bt-&gt;units_dynamic[def-&gt;id].requested -= 1;
+	bt-&gt;units_dynamic[def-&gt;id].under_construction += 1;
+
+	requestedUnits[category] -= 1;
+	futureUnits[category] += 1;
+
 	// add to unittable 
 	ut-&gt;AddUnit(unit, def-&gt;id);
 
 	// get commander a startup
 	if(!initialized &amp;&amp; ut-&gt;IsDefCommander(def-&gt;id))
 	{
-		++futureUnits[COMMANDER];
+		// UnitFinished() will decrease it later -&gt; prevents AAI from having -1 future commanders 
+		requestedUnits[COMMANDER] += 1;
+		bt-&gt;units_dynamic[def-&gt;id].under_construction += 1;
 
-		// set side
-		int side = bt-&gt;GetSideByID(def-&gt;id)-1;
-		this-&gt;side = side+1;
+		execute-&gt;InitAI(unit, def);
 
-		//debug
-		fprintf(file, &quot;Playing as %s\n&quot;, bt-&gt;sideNames[side+1].c_str());
+		initialized = true;
+		return;
+	}
 
-		if(this-&gt;side &lt; 1 || this-&gt;side &gt; bt-&gt;numOfSides)
-		{
-			cb-&gt;SendTextMsg(&quot;Error: side not properly set&quot;, 0);
-			fprintf(file, &quot;ERROR: invalid side id %i\n&quot;, this-&gt;side);
-			return;
-		}
-
-		// tell the brain about the starting sector
-		float3 pos = cb-&gt;GetUnitPos(unit);
-		int x = pos.x/map-&gt;xSectorSize;
-		int y = pos.z/map-&gt;ySectorSize;
-
-		if(x &lt; 0)
-			x = 0;
-		if(y &lt; 0 ) 
-			y = 0;
-		if(x &gt;= map-&gt;xSectors)
-			x = map-&gt;xSectors-1;
-		if(y &gt;= map-&gt;ySectors)
-			y = map-&gt;ySectors-1;
+	// resurrected units will be handled differently
+	if( !cb-&gt;UnitBeingBuilt(unit))
+	{
+		cb-&gt;SendTextMsg(&quot;ressurected&quot;, 0);
 		
-		// set sector as part of the base
-		if(map-&gt;team_sector_map[x][y] &lt; 0)
+		UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
+		
+		// UnitFinished() will decrease it later 
+		requestedUnits[category] += 1;	
+		bt-&gt;units_dynamic[def-&gt;id].requested += 1;
+
+		if(category == SCOUT)
+			futureScouts += 1;
+		else if(category &lt;= METAL_MAKER &amp;&amp; category &gt; UNKNOWN)
 		{
-			brain-&gt;AddSector(&amp;map-&gt;sector[x][y]);
-			brain-&gt;start_pos = pos;
-			brain-&gt;UpdateNeighbouringSectors();
-			brain-&gt;UpdateBaseCenter();
+			float3 pos = cb-&gt;GetUnitPos(unit);
+			map-&gt;Pos2FinalBuildPos(&amp;pos, def);
+
+			execute-&gt;InitBuildingAt(def, pos);
 		}
-		else
+	}
+	else
+	{
+		// construction of building started
+		if(category &lt;= METAL_MAKER &amp;&amp; category &gt; UNKNOWN)
 		{
-			// sector already occupied by another aai team (coms starting too close to each other)
-			// choose next free sector
-			execute-&gt;ChooseDifferentStartingSector(x, y);
-		}
+			float3 pos = cb-&gt;GetUnitPos(unit);
 
-		if(map-&gt;mapType == WATER_MAP)
-			brain-&gt;ExpandBase(WATER_SECTOR);
-		else 
-			brain-&gt;ExpandBase(LAND_SECTOR);
-	
-		// now that we know the side, init buildques
-		execute-&gt;InitBuildques();
+			// create new buildtask
+			execute-&gt;CreateBuildTask(unit, def, &amp;pos);
 
-		bt-&gt;InitCombatEffCache(this-&gt;side);
+			// add defence buildings to the sector
+			if(category == STATIONARY_DEF)
+			{
+				int x = pos.x/map-&gt;xSectorSize;
+				int y = pos.z/map-&gt;ySectorSize;
 
-		ut-&gt;AddCommander(unit, def-&gt;id);
+				if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; map-&gt;xSectors &amp;&amp; y &lt; map-&gt;ySectors)
+					map-&gt;sector[x][y].AddDefence(unit, def-&gt;id);
+			}
+			else if(category == EXTRACTOR)
+			{
+				int x = pos.x/map-&gt;xSectorSize;
+				int y = pos.z/map-&gt;ySectorSize;
 
-		// add the highest rated, buildable factory
-		execute-&gt;AddStartFactory();
+				map-&gt;sector[x][y].AddExtractor(unit, def-&gt;id, &amp;pos);
+			}
+		}
+	}
+}
 
-		// get economy working
-		execute-&gt;CheckRessources();
-
-		initialized = true;
+void AAI::UnitFinished(int unit) 
+{
+	if(!initialized)
 		return;
-	}
-	// construction of building started
-	else if(category &lt;= METAL_MAKER &amp;&amp; category &gt; UNKNOWN)
-	{
-		// create new buildtask
-		AAIBuildTask *task;
-		
-		try
-		{
-			task = new AAIBuildTask(this, unit, def-&gt;id, cb-&gt;GetUnitPos(unit), cb-&gt;GetCurrentFrame());
-		}
-		catch(...) 
-		{
-			fprintf(file, &quot;Exception thrown when allocating memory for buildtask&quot;);
-		}
 
-		build_tasks.push_back(task);
+	// get unit&#180;s id
+	const UnitDef *def = cb-&gt;GetUnitDef(unit);
 
-		float3 pos = cb-&gt;GetUnitPos(unit);
-		// find builder and associate building with that builder
-		task-&gt;builder_id = -1;
+	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
+	
+	futureUnits[category] -= 1;
+	activeUnits[category] += 1;
+	
+	bt-&gt;units_dynamic[def-&gt;id].under_construction -= 1;
+	bt-&gt;units_dynamic[def-&gt;id].active += 1;
 
-		for(set&lt;int&gt;::iterator i = ut-&gt;constructors.begin(); i != ut-&gt;constructors.end(); ++i)
+	// building was completed
+	if(!def-&gt;movedata &amp;&amp; !def-&gt;canfly)
+	{
+		// delete buildtask
+		for(list&lt;AAIBuildTask*&gt;::iterator task = build_tasks.begin(); task != build_tasks.end(); task++)
 		{
-			if(ut-&gt;units[*i].cons-&gt;build_pos.x == pos.x &amp;&amp; ut-&gt;units[*i].cons-&gt;build_pos.z == pos.z)
+			if((*task)-&gt;unit_id == unit)
 			{
-				ut-&gt;units[*i].cons-&gt;construction_unit_id = unit;
-				task-&gt;builder_id = ut-&gt;units[*i].cons-&gt;unit_id;
-				ut-&gt;units[*i].cons-&gt;build_task = task;
-				ut-&gt;units[*i].cons-&gt;CheckAssistance();
+				AAIBuildTask *build_task = *task;
+				
+				if((*task)-&gt;builder_id &gt;= 0 &amp;&amp; ut-&gt;units[(*task)-&gt;builder_id].cons)
+					ut-&gt;units[(*task)-&gt;builder_id].cons-&gt;ConstructionFinished();
+				
+				build_tasks.erase(task);
+				delete build_task;
 				break;
 			}
 		}
 
-		// add defence buildings to the sector
-		if(category == STATIONARY_DEF)
+		// check if building belongs to one of this groups
+		if(category == EXTRACTOR)
 		{
-			int x = pos.x/map-&gt;xSectorSize;
-			int y = pos.z/map-&gt;ySectorSize;
+			ut-&gt;AddExtractor(unit);
 
-			if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; map-&gt;xSectors &amp;&amp; y &lt; map-&gt;ySectors)
-				map-&gt;sector[x][y].AddDefence(unit, def-&gt;id);
+			// order defence if necessary
+			execute-&gt;DefendMex(unit, def-&gt;id);
 		}
-		else if(category == EXTRACTOR)
+		else if(category == POWER_PLANT)
 		{
-			int x = pos.x/map-&gt;xSectorSize;
-			int y = pos.z/map-&gt;ySectorSize;
+			ut-&gt;AddPowerPlant(unit, def-&gt;id);
+		}
+		else if(category == STORAGE)
+		{
+			execute-&gt;futureStoredEnergy -= bt-&gt;unitList[def-&gt;id-1]-&gt;energyStorage;
+			execute-&gt;futureStoredMetal -= bt-&gt;unitList[def-&gt;id-1]-&gt;metalStorage;
+		}
+		else if(category == METAL_MAKER)
+		{
+			ut-&gt;AddMetalMaker(unit, def-&gt;id);
+		}
+		else if(category == STATIONARY_RECON)
+		{
+			ut-&gt;AddRecon(unit, def-&gt;id);
+		}
+		else if(category == STATIONARY_JAMMER)
+		{
+			ut-&gt;AddJammer(unit, def-&gt;id);
+		}
+		else if(category == STATIONARY_ARTY)
+		{
+			ut-&gt;AddStationaryArty(unit, def-&gt;id);
+		}
+		else if(category == STATIONARY_CONSTRUCTOR)
+		{
+			ut-&gt;AddConstructor(unit, def-&gt;id);
 
-			map-&gt;sector[x][y].AddExtractor(unit, def-&gt;id, &amp;pos);
+			ut-&gt;units[unit].cons-&gt;Update();
 		}
+		return;
 	}
+	else	// unit was completed
+	{
+		// unit 
+		if(category &gt;= GROUND_ASSAULT &amp;&amp; category &lt;= SUBMARINE_ASSAULT)
+		{
+			execute-&gt;AddUnitToGroup(unit, def-&gt;id, category);
+
+			brain-&gt;AddDefenceCapabilities(def-&gt;id, category);
+
+			ut-&gt;SetUnitStatus(unit, HEADING_TO_RALLYPOINT);
+		}
+		// scout
+		else if(category == SCOUT)
+		{
+			++activeScouts;
+			--futureScouts;
+
+			scouts.push_back(unit);
+
+			// cloak scout if cloakable
+			if(def-&gt;canCloak)
+			{
+				Command c;
+				c.id = CMD_CLOAK;
+				c.params.push_back(1);
+
+				cb-&gt;GiveOrder(unit, &amp;c);
+			}
+		}
+		// builder 
+		else if(bt-&gt;IsBuilder(def-&gt;id))
+		{
+			ut-&gt;AddConstructor(unit, def-&gt;id);
+
+			ut-&gt;units[unit].cons-&gt;Update();
+		}
+	}
 }
 
 void AAI::UnitDestroyed(int unit, int attacker) 
@@ -416,8 +481,8 @@
 	// unfinished unit has been killed
 	if(cb-&gt;UnitBeingBuilt(unit))
 	{
-		--futureUnits[category];
-		--bt-&gt;units_dynamic[def-&gt;id].requested;
+		futureUnits[category] -= 1;
+		bt-&gt;units_dynamic[def-&gt;id].under_construction -= 1;
 
 		// unfinished building
 		if(!def-&gt;canfly &amp;&amp; !def-&gt;movedata)
@@ -451,11 +516,11 @@
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 					--bt-&gt;units_dynamic[*unit].buildersRequested;
 			}
-
-			if(bt-&gt;IsFactory(def-&gt;id))
+			else if(bt-&gt;IsFactory(def-&gt;id))
 			{
-				--futureFactories;
-
+				if(category == STATIONARY_CONSTRUCTOR)
+					--futureFactories;
+	
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 					--bt-&gt;units_dynamic[*unit].buildersRequested;
 			}
@@ -670,129 +735,6 @@
 	ut-&gt;RemoveUnit(unit);
 }
 
-void AAI::UnitFinished(int unit) 
-{
-	if(!initialized)
-		return;
-
-	// get unit&#180;s id
-	const UnitDef *def = cb-&gt;GetUnitDef(unit);
-
-	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
-	futureUnits[category] -= 1;
-	activeUnits[category] += 1;
-	
-	bt-&gt;units_dynamic[def-&gt;id].requested -= 1;
-	bt-&gt;units_dynamic[def-&gt;id].active += 1;
-
-	// check if unit has been resurrected
-	float health = cb-&gt;GetUnitHealth(unit);
-	float max_health = cb-&gt;GetUnitMaxHealth(unit);
-	
-	/*if( health / max_health &lt; 0.1f)
-	{
-		cb-&gt;SendTextMsg(&quot;ressurected&quot;, 0);
-	}*/
-
-	// building was completed
-	if(!def-&gt;movedata &amp;&amp; !def-&gt;canfly)
-	{
-		// delete buildtask
-		for(list&lt;AAIBuildTask*&gt;::iterator task = build_tasks.begin(); task != build_tasks.end(); task++)
-		{
-			if((*task)-&gt;unit_id == unit)
-			{
-				AAIBuildTask *build_task = *task;
-				
-				if((*task)-&gt;builder_id &gt;= 0 &amp;&amp; ut-&gt;units[(*task)-&gt;builder_id].cons)
-					ut-&gt;units[(*task)-&gt;builder_id].cons-&gt;ConstructionFinished();
-				
-				build_tasks.erase(task);
-				delete build_task;
-				break;
-			}
-		}
-
-		// check if building belongs to one of this groups
-		if(category == EXTRACTOR)
-		{
-			ut-&gt;AddExtractor(unit);
-
-			// order defence if necessary
-			execute-&gt;DefendMex(unit, def-&gt;id);
-		}
-		else if(category == POWER_PLANT)
-		{
-			ut-&gt;AddPowerPlant(unit, def-&gt;id);
-		}
-		else if(category == STORAGE)
-		{
-			execute-&gt;futureStoredEnergy -= bt-&gt;unitList[def-&gt;id-1]-&gt;energyStorage;
-			execute-&gt;futureStoredMetal -= bt-&gt;unitList[def-&gt;id-1]-&gt;metalStorage;
-		}
-		else if(category == METAL_MAKER)
-		{
-			ut-&gt;AddMetalMaker(unit, def-&gt;id);
-		}
-		else if(category == STATIONARY_RECON)
-		{
-			ut-&gt;AddRecon(unit, def-&gt;id);
-		}
-		else if(category == STATIONARY_JAMMER)
-		{
-			ut-&gt;AddJammer(unit, def-&gt;id);
-		}
-		else if(category == STATIONARY_ARTY)
-		{
-			ut-&gt;AddStationaryArty(unit, def-&gt;id);
-		}
-		else if(category == STATIONARY_CONSTRUCTOR)
-		{
-			ut-&gt;AddConstructor(unit, def-&gt;id);
-
-			ut-&gt;units[unit].cons-&gt;Update();
-		}
-		return;
-	}
-	else	// unit was completed
-	{
-		// unit 
-		if(category &gt;= GROUND_ASSAULT &amp;&amp; category &lt;= SUBMARINE_ASSAULT)
-		{
-			execute-&gt;AddUnitToGroup(unit, def-&gt;id, category);
-
-			brain-&gt;AddDefenceCapabilities(def-&gt;id, category);
-
-			ut-&gt;SetUnitStatus(unit, HEADING_TO_RALLYPOINT);
-		}
-		// scout
-		else if(category == SCOUT)
-		{
-			++activeScouts;
-			--futureScouts;
-
-			scouts.push_back(unit);
-
-			// cloak scout if cloakable
-			if(def-&gt;canCloak)
-			{
-				Command c;
-				c.id = CMD_CLOAK;
-				c.params.push_back(1);
-
-				cb-&gt;GiveOrder(unit, &amp;c);
-			}
-		}
-		// builder 
-		else if(bt-&gt;IsBuilder(def-&gt;id))
-		{
-			ut-&gt;AddConstructor(unit, def-&gt;id);
-
-			ut-&gt;units[unit].cons-&gt;Update();
-		}
-	}
-}
-
 void AAI::UnitIdle(int unit)
 {
 	// if factory is idle, start construction of further units

Modified: trunk/AI/Global/AAI/AAI.h
===================================================================
--- trunk/AI/Global/AAI/AAI.h	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAI.h	2008-06-01 20:48:49 UTC (rev 5970)
@@ -74,6 +74,7 @@
 	// number of active/under construction units of all different types
 	int activeUnits[(int)MOBILE_CONSTRUCTOR+1];
 	int futureUnits[(int)MOBILE_CONSTRUCTOR+1];
+	int requestedUnits[(int)MOBILE_CONSTRUCTOR+1];
 
 	int activeScouts, futureScouts;
 	int activeBuilders, futureBuilders;

Modified: trunk/AI/Global/AAI/AAIBuildTask.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIBuildTask.cpp	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIBuildTask.cpp	2008-06-01 20:48:49 UTC (rev 5970)
@@ -11,7 +11,7 @@
 #include &quot;AAI.h&quot;
 #include &quot;AAIConstructor.h&quot;
 
-AAIBuildTask::AAIBuildTask(AAI *ai, int unit_id, int def_id, float3 pos, int tick)
+AAIBuildTask::AAIBuildTask(AAI *ai, int unit_id, int def_id, float3 *pos, int tick)
 {
 	this-&gt;ai = ai;
 	this-&gt;unit_id = unit_id;
@@ -21,7 +21,7 @@
 
 	builder_id = -1;
 
-	build_pos = pos;
+	build_pos = *pos;
 }
 
 AAIBuildTask::~AAIBuildTask(void)

Modified: trunk/AI/Global/AAI/AAIBuildTask.h
===================================================================
--- trunk/AI/Global/AAI/AAIBuildTask.h	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIBuildTask.h	2008-06-01 20:48:49 UTC (rev 5970)
@@ -6,7 +6,7 @@
 class AAIBuildTask
 {
 public:
-	AAIBuildTask(AAI *ai, int unit_id, int def_id, float3 pos, int tick);
+	AAIBuildTask(AAI *ai, int unit_id, int def_id, float3 *pos, int tick);
 	~AAIBuildTask(void);
 
 	void BuilderDestroyed();

Modified: trunk/AI/Global/AAI/AAIConstructor.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIConstructor.cpp	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIConstructor.cpp	2008-06-01 20:48:49 UTC (rev 5970)
@@ -349,83 +349,39 @@
 	// get def and final position
 	const UnitDef *def = ai-&gt;bt-&gt;unitList[id_building-1];
 	ai-&gt;map-&gt;Pos2FinalBuildPos(&amp;pos, def);
-	build_pos = pos;
-
-	// determine target sector
-	int x = build_pos.x/ai-&gt;map-&gt;xSectorSize;
-	int y = build_pos.z/ai-&gt;map-&gt;ySectorSize;
-
-	// drop bad sectors (should only happen when defending mexes at the edge of the map)
-	if(x &lt; 0 || y &lt; 0 || x &gt;= ai-&gt;map-&gt;xSectors || y &gt;= ai-&gt;map-&gt;ySectors)
-		return;
-
-	order_tick = cb-&gt;GetCurrentFrame();
-
-	// check if builder was previously assisting other builders/factories
-	if(assistance &gt;= 0)
+	
+	// give order if building can be placed at the desired position (position lies within a valid sector)
+	if(ai-&gt;execute-&gt;InitBuildingAt(def, pos))
 	{
-		ai-&gt;ut-&gt;units[assistance].cons-&gt;RemoveAssitant(unit_id);
+		order_tick = cb-&gt;GetCurrentFrame();
 
-		assistance = -1;
-	}
+		// check if builder was previously assisting other builders/factories
+		if(assistance &gt;= 0)
+		{
+			ai-&gt;ut-&gt;units[assistance].cons-&gt;RemoveAssitant(unit_id);
+			assistance = -1;
+		}
 
-	// set building as current task and order construction
-	construction_def_id = id_building;
-	task = BUILDING;
-	construction_category = ai-&gt;bt-&gt;units_static[id_building].category;
+		// set building as current task and order construction
+		build_pos = pos;
+		construction_def_id = id_building;
+		task = BUILDING;
+		construction_category = bt-&gt;units_static[id_building].category;
 
-	// order builder to construct building
-	Command c;
-	c.id = - id_building;
-	c.params.resize(3);
-	c.params[0] = build_pos.x;
-	c.params[1] = build_pos.y;
-	c.params[2] = build_pos.z;
+		// order builder to construct building
+		Command c;
+		c.id = - id_building;
+		c.params.resize(3);
+		c.params[0] = build_pos.x;
+		c.params[1] = build_pos.y;
+		c.params[2] = build_pos.z;
 
-	cb-&gt;GiveOrder(unit_id, &amp;c);
+		cb-&gt;GiveOrder(unit_id, &amp;c);
 
-	// increase number of active units of that type/category
-	ai-&gt;bt-&gt;units_dynamic[def-&gt;id].active += 1;
-	ai-&gt;futureUnits[construction_category] += 1;
-
-	if(bt-&gt;IsFactory(id_building))
-		++ai-&gt;futureFactories;
-
-	// increase number of units of that category in the target sector
-	++ai-&gt;map-&gt;sector[x][y].unitsOfType[construction_category];
-	ai-&gt;map-&gt;sector[x][y].own_structures += ai-&gt;bt-&gt;units_static[construction_def_id].cost;
-
-	// update buildmap of sector
-	ai-&gt;map-&gt;Pos2BuildMapPos(&amp;pos, def);
-
-	// factory
-	if(construction_category == STATIONARY_CONSTRUCTOR) 
-	{
-		bool water = false;
-		int value = 1;
-
-		if(!bt-&gt;CanPlacedLand(id_building))
-		{
-			water = true;
-			value = 5;
-		}
-
-		ai-&gt;map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, value);
-		ai-&gt;map-&gt;BlockCells(pos.x, pos.z - 8, def-&gt;xsize, 8, true, water);
-		ai-&gt;map-&gt;BlockCells(pos.x + def-&gt;xsize, pos.z - 8, cfg-&gt;X_SPACE, def-&gt;ysize + 1.5 * cfg-&gt;Y_SPACE, true, water);
-		ai-&gt;map-&gt;BlockCells(pos.x, pos.z + def-&gt;ysize, def-&gt;xsize, 1.5 * cfg-&gt;Y_SPACE - 8, true, water);
+		// increase number of active units of that type/category
+		bt-&gt;units_dynamic[def-&gt;id].requested += 1;
+		ai-&gt;requestedUnits[construction_category] += 1;
 	}
-	// normal building
-	else
-	{
-		if(water)
-			ai-&gt;map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 5);
-		else
-			ai-&gt;map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 1);
-	}
-	
-	// prevent ai from building too many things in a row
-	ai-&gt;map-&gt;CheckRows(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, true, water);
 }
 
 void AAIConstructor::AssistConstruction(int constructor, int target_unit)
@@ -545,7 +501,7 @@
 			if(construction_unit_id == -1)
 			{
 				ai-&gt;bt-&gt;units_dynamic[construction_def_id].requested -= 1; 
-				ai-&gt;futureUnits[construction_category] -= 1;
+				ai-&gt;requestedUnits[construction_category] -= 1;
 
 				// killed on the way to the buildsite 
 				int x = build_pos.x / ai-&gt;map-&gt;xSectorSize;

Modified: trunk/AI/Global/AAI/AAIExecute.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIExecute.cpp	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIExecute.cpp	2008-06-01 20:48:49 UTC (rev 5970)
@@ -29,8 +29,6 @@
 
 	brain-&gt;execute = this;
 
-//	buildques = 0;
-//	factory_table = 0;
 	unitProductionRate = 1;
 
 	futureRequestedMetal = 0;
@@ -76,6 +74,143 @@
 //		delete [] factory_table;
 }
 
+
+void AAIExecute::InitAI(int commander_unit_id, const UnitDef* commander_def)
+{	
+	// set side
+	ai-&gt;side = bt-&gt;GetSideByID(commander_def-&gt;id);
+
+	//debug
+	fprintf(ai-&gt;file, &quot;Playing as %s\n&quot;, bt-&gt;sideNames[ai-&gt;side].c_str());
+
+	if(ai-&gt;side &lt; 1 || ai-&gt;side &gt; bt-&gt;numOfSides)
+	{
+		cb-&gt;SendTextMsg(&quot;Error: side not properly set&quot;, 0);
+		fprintf(ai-&gt;file, &quot;ERROR: invalid side id %i\n&quot;, ai-&gt;side);
+		return;
+	}
+
+	// tell the brain about the starting sector
+	float3 pos = cb-&gt;GetUnitPos(commander_unit_id);
+	int x = pos.x/map-&gt;xSectorSize;
+	int y = pos.z/map-&gt;ySectorSize;
+
+	if(x &lt; 0)
+		x = 0;
+	if(y &lt; 0 ) 
+		y = 0;
+	if(x &gt;= map-&gt;xSectors)
+		x = map-&gt;xSectors-1;
+	if(y &gt;= map-&gt;ySectors)
+		y = map-&gt;ySectors-1;
+		
+	// set sector as part of the base
+	if(map-&gt;team_sector_map[x][y] &lt; 0)
+	{
+		brain-&gt;AddSector(&amp;map-&gt;sector[x][y]);
+		brain-&gt;start_pos = pos;
+		brain-&gt;UpdateNeighbouringSectors();
+		brain-&gt;UpdateBaseCenter();
+	}
+	else
+	{
+		// sector already occupied by another aai team (coms starting too close to each other)
+		// choose next free sector
+		ChooseDifferentStartingSector(x, y);
+	}
+
+	if(map-&gt;mapType == WATER_MAP)
+		brain-&gt;ExpandBase(WATER_SECTOR);
+	else 
+		brain-&gt;ExpandBase(LAND_SECTOR);
+	
+	// now that we know the side, init buildques
+	InitBuildques();
+
+	bt-&gt;InitCombatEffCache(ai-&gt;side);
+
+	ai-&gt;ut-&gt;AddCommander(commander_unit_id, commander_def-&gt;id);
+
+	// add the highest rated, buildable factory
+	AddStartFactory();
+
+	// get economy working
+	CheckRessources();
+}
+
+void AAIExecute::CreateBuildTask(int unit, const UnitDef *def, float3 *pos)
+{
+	AAIBuildTask *task = new AAIBuildTask(ai, unit, def-&gt;id, pos, cb-&gt;GetCurrentFrame());
+	ai-&gt;build_tasks.push_back(task);
+
+	// find builder and associate building with that builder
+	task-&gt;builder_id = -1;
+
+	for(set&lt;int&gt;::iterator i = ut-&gt;constructors.begin(); i != ut-&gt;constructors.end(); ++i)
+	{
+		if(ut-&gt;units[*i].cons-&gt;build_pos.x == pos-&gt;x &amp;&amp; ut-&gt;units[*i].cons-&gt;build_pos.z == pos-&gt;z)
+		{
+			ut-&gt;units[*i].cons-&gt;construction_unit_id = unit;
+			task-&gt;builder_id = ut-&gt;units[*i].cons-&gt;unit_id;
+			ut-&gt;units[*i].cons-&gt;build_task = task;
+			ut-&gt;units[*i].cons-&gt;CheckAssistance();
+			break;
+		}
+	}
+}
+
+bool AAIExecute::InitBuildingAt(const UnitDef *def, float3 pos)
+{			
+	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
+
+	bool water = false;
+
+	if(pos.y &lt; 0) 
+		water = true;
+
+	// determine target sector
+	int x = pos.x/map-&gt;xSectorSize;
+	int y = pos.z/map-&gt;ySectorSize;
+
+	// drop bad sectors (should only happen when defending mexes at the edge of the map)
+	if(x &lt; 0 || y &lt; 0 || x &gt;= map-&gt;xSectors || y &gt;= map-&gt;ySectors)
+		return false;
+	
+	// increase number of units of that category in the target sector
+	map-&gt;sector[x][y].unitsOfType[category] += 1;
+	map-&gt;sector[x][y].own_structures += bt-&gt;units_static[def-&gt;id].cost;
+
+	// update buildmap of sector
+	map-&gt;Pos2BuildMapPos(&amp;pos, def);
+
+	// factory
+	if(bt-&gt;IsFactory(def-&gt;id))
+	{
+		ai-&gt;futureFactories += 1;
+
+		if(water)
+			map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 5);
+		else
+			map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 1);
+
+		map-&gt;BlockCells(pos.x, pos.z - 8, def-&gt;xsize, 8, true, water);
+		map-&gt;BlockCells(pos.x + def-&gt;xsize, pos.z - 8, cfg-&gt;X_SPACE, def-&gt;ysize + 1.5 * cfg-&gt;Y_SPACE, true, water);
+		map-&gt;BlockCells(pos.x, pos.z + def-&gt;ysize, def-&gt;xsize, 1.5 * cfg-&gt;Y_SPACE - 8, true, water);
+	}
+	// normal building
+	else
+	{
+		if(water)
+			map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 5);
+		else
+			map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 1);
+	}
+	
+	// prevent ai from building too many things in a row
+	map-&gt;CheckRows(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, true, water);
+
+	return true;
+}
 void AAIExecute::moveUnitTo(int unit, float3 *position)
 {
 	Command c;
@@ -864,7 +999,7 @@
 			else
 			{	
 				// check mex upgrade
-				if(ai-&gt;futureUnits[EXTRACTOR] &lt; 1)
+				if(ai-&gt;futureUnits[EXTRACTOR] + ai-&gt;requestedUnits[EXTRACTOR] &lt; 1)
 					CheckMexUpgrade();
 
 				// request metal makers if no spot found
@@ -879,7 +1014,7 @@
 
 bool AAIExecute::BuildPowerPlant()
 {	
-	if(ai-&gt;futureUnits[POWER_PLANT] &gt; 1)
+	if(ai-&gt;futureUnits[POWER_PLANT] + ai-&gt;requestedUnits[POWER_PLANT] &gt; 1)
 		return true;
 	else if(ai-&gt;futureUnits[POWER_PLANT] &gt; 0)
 	{
@@ -941,7 +1076,7 @@
 	float energy = cb-&gt;GetEnergyIncome()+1;
 
 	// check if already one power_plant under construction and energy short 
-	if(ai-&gt;futureUnits[POWER_PLANT] &gt; 0 &amp;&amp; ai-&gt;activeUnits[POWER_PLANT] &gt; 9 &amp;&amp; averageEnergySurplus &lt; 100)
+	if(ai-&gt;futureUnits[POWER_PLANT] + ai-&gt;requestedUnits[POWER_PLANT]&gt; 0 &amp;&amp; ai-&gt;activeUnits[POWER_PLANT] &gt; 9 &amp;&amp; averageEnergySurplus &lt; 100)
 	{
 		urgency = 0.4f + GetEnergyUrgency();
 		max_power = 0.5f;
@@ -1083,7 +1218,7 @@
 	if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
 		return true;
 
-	if(ai-&gt;futureUnits[METAL_MAKER] &gt; 0 || disabledMMakers &gt;= 1)
+	if(ai-&gt;futureUnits[METAL_MAKER] + ai-&gt;requestedUnits[METAL_MAKER] &gt; 0 || disabledMMakers &gt;= 1)
 		return true;
 
 	bool checkWater, checkGround;
@@ -1212,7 +1347,7 @@
 
 bool AAIExecute::BuildStorage()
 {
-	if(ai-&gt;futureUnits[STORAGE] &gt; 0 || ai-&gt;activeUnits[STORAGE] &gt;= cfg-&gt;MAX_STORAGE)
+	if(ai-&gt;futureUnits[STORAGE] + ai-&gt;requestedUnits[STORAGE]&gt; 0 || ai-&gt;activeUnits[STORAGE] &gt;= cfg-&gt;MAX_STORAGE)
 		return true;
 
 	if(ai-&gt;activeFactories &lt; 2)
@@ -1227,7 +1362,7 @@
 	float energy = 2 / (cb-&gt;GetEnergyStorage() + futureStoredMetal - cb-&gt;GetEnergy() + 1);
 
 	// urgency &lt; 4
-	float urgency = 16.0 / (ai-&gt;activeUnits[METAL_MAKER]+ai-&gt;futureUnits[METAL_MAKER]+4);
+	float urgency = 16.0 / (ai-&gt;activeUnits[METAL_MAKER] + ai-&gt;futureUnits[METAL_MAKER] + 4);
 
 	for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[0].begin(); sector != brain-&gt;sectors[0].end(); sector++)
 	{
@@ -1327,7 +1462,7 @@
 
 bool AAIExecute::BuildAirBase()
 {
-	if(ai-&gt;futureUnits[AIR_BASE] &gt; 0 || ai-&gt;activeUnits[AIR_BASE] &gt;= cfg-&gt;MAX_AIR_BASE)
+	if(ai-&gt;futureUnits[AIR_BASE] + ai-&gt;requestedUnits[AIR_BASE] &gt; 0 || ai-&gt;activeUnits[AIR_BASE] &gt;= cfg-&gt;MAX_AIR_BASE)
 		return true;
 
 	int airbase = 0;
@@ -1438,7 +1573,7 @@
 
 bool AAIExecute::BuildDefences()
 {
-	if(ai-&gt;futureUnits[STATIONARY_DEF] &gt; 2 || next_defence &lt;= 0)
+	if(ai-&gt;futureUnits[STATIONARY_DEF] + ai-&gt;requestedUnits[STATIONARY_DEF] &gt; 2 || next_defence &lt;= 0)
 		return true;
 
 	BuildOrderStatus status = BuildStationaryDefenceVS(def_category, next_defence);
@@ -1668,7 +1803,7 @@
 
 bool AAIExecute::BuildArty()
 {
-	if(ai-&gt;futureUnits[STATIONARY_ARTY])
+	if(ai-&gt;futureUnits[STATIONARY_ARTY] || ai-&gt;requestedUnits[STATIONARY_ARTY])
 		return true;
 
 	AAIConstructor *builder;
@@ -1770,7 +1905,7 @@
 
 bool AAIExecute::BuildFactory()
 {
-	if(ai-&gt;futureUnits[STATIONARY_CONSTRUCTOR] &gt; 0)
+	if(ai-&gt;futureUnits[STATIONARY_CONSTRUCTOR] + ai-&gt;requestedUnits[STATIONARY_CONSTRUCTOR] &gt; 0)
 		return true;
 
 	AAIConstructor *builder = 0, *temp_builder;
@@ -1883,6 +2018,8 @@
 			
 			if(builder)
 			{
+				bt-&gt;units_dynamic[building].requested -= 1;
+
 				// give build order
 				builder-&gt;GiveConstructionOrder(building, pos, water);
 		
@@ -2034,7 +2171,7 @@
 
 bool AAIExecute::BuildRecon()
 {
-	if(ai-&gt;futureUnits[STATIONARY_RECON])
+	if(ai-&gt;futureUnits[STATIONARY_RECON] + ai-&gt;requestedUnits[STATIONARY_RECON])
 		return true;
 
 	int radar = 0;
@@ -2140,7 +2277,7 @@
 
 bool AAIExecute::BuildJammer()
 {
-	if(ai-&gt;futureUnits[STATIONARY_JAMMER])
+	if(ai-&gt;futureUnits[STATIONARY_JAMMER] + ai-&gt;requestedUnits[STATIONARY_JAMMER] &gt; 0)
 		return true;
 
 	int jammer = 0;
@@ -2362,7 +2499,7 @@
 	if(cfg-&gt;MAX_STAT_ARTY == 0)
 		return;
 
-	if(ai-&gt;futureUnits[STATIONARY_ARTY] &gt; 0)
+	if(ai-&gt;futureUnits[STATIONARY_ARTY] +  ai-&gt;requestedUnits[STATIONARY_ARTY]&gt; 0)
 		return;
 
 	if(ai-&gt;activeUnits[STATIONARY_ARTY] &gt;= cfg-&gt;MAX_STAT_ARTY)
@@ -2411,7 +2548,7 @@
 
 void AAIExecute::CheckDefences()
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES || ai-&gt;futureUnits[STATIONARY_DEF] &gt; 2)
+	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES || ai-&gt;futureUnits[STATIONARY_DEF] +  ai-&gt;requestedUnits[STATIONARY_DEF] &gt; 2)
 		return;
 
 	int t = brain-&gt;GetGamePeriod();
@@ -2504,7 +2641,7 @@
 		urgency[POWER_PLANT] = temp;
 
 	// build storages if needed
-	if(ai-&gt;activeUnits[STORAGE] + ai-&gt;futureUnits[STORAGE] &lt; cfg-&gt;MAX_STORAGE 
+	if(ai-&gt;activeUnits[STORAGE] + ai-&gt;requestedUnits[STORAGE] + ai-&gt;futureUnits[STORAGE] &lt; cfg-&gt;MAX_STORAGE 
 		&amp;&amp; ai-&gt;activeFactories &gt;= cfg-&gt;MIN_FACTORIES_FOR_STORAGE)
 	{
 		float temp = max(GetMetalStorageUrgency(), GetEnergyStorageUrgency());
@@ -2517,7 +2654,7 @@
 	if(averageEnergySurplus &lt; 1.5 * cfg-&gt;METAL_ENERGY_RATIO)
 	{
 		// try to accelerate power plant construction
-		if(ai-&gt;futureUnits[POWER_PLANT] &gt; 0)
+		if(ai-&gt;futureUnits[POWER_PLANT] +  ai-&gt;requestedUnits[POWER_PLANT]&gt; 0)
 			AssistConstructionOfCategory(POWER_PLANT, 10);
 
 		// try to disbale some metal makers
@@ -2669,7 +2806,7 @@
 
 void AAIExecute::CheckRadarUpgrade()
 {
-	if(ai-&gt;futureUnits[STATIONARY_RECON] &gt; 0)
+	if(ai-&gt;futureUnits[STATIONARY_RECON] + ai-&gt;requestedUnits[STATIONARY_RECON]  &gt; 0)
 		return;
 
 	float cost = brain-&gt;Affordable();
@@ -2732,7 +2869,7 @@
 
 void AAIExecute::CheckJammerUpgrade()
 {
-	if(ai-&gt;futureUnits[STATIONARY_JAMMER] &gt; 0)
+	if(ai-&gt;futureUnits[STATIONARY_JAMMER] + ai-&gt;requestedUnits[STATIONARY_JAMMER]  &gt; 0)
 		return;
 
 	float cost = brain-&gt;Affordable();
@@ -2836,7 +2973,7 @@
 
 void AAIExecute::CheckFactories()
 {
-	if(ai-&gt;futureUnits[STATIONARY_CONSTRUCTOR] &gt; 0)
+	if(ai-&gt;futureUnits[STATIONARY_CONSTRUCTOR] + ai-&gt;requestedUnits[STATIONARY_CONSTRUCTOR] &gt; 0)
 		return;
 
 	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][ai-&gt;side-1].begin(); fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][ai-&gt;side-1].end(); ++fac)
@@ -2847,7 +2984,7 @@
 			float urgency;
 
 			if(ai-&gt;activeFactories &gt; 0)
-				urgency = 0.3f;
+				urgency = 0.4f;
 			else
 				urgency = 3.0f;
 
@@ -2873,12 +3010,10 @@
 
 void AAIExecute::CheckAirBase()
 {
-	if(cfg-&gt;MAX_AIR_BASE &gt; 0)
-	{
-		// only build repair pad if any air units have been built yet
-		if(ai-&gt;activeUnits[AIR_BASE] + ai-&gt;futureUnits[AIR_BASE] &lt; cfg-&gt;MAX_AIR_BASE &amp;&amp; ai-&gt;group_list[AIR_ASSAULT].size() &gt; 0)
+	// only build repair pad if any air units have been built yet
+	if(ai-&gt;activeUnits[AIR_BASE] +  ai-&gt;requestedUnits[AIR_BASE] + ai-&gt;futureUnits[AIR_BASE] &lt; cfg-&gt;MAX_AIR_BASE &amp;&amp; ai-&gt;group_list[AIR_ASSAULT].size() &gt; 0)
 			urgency[AIR_BASE] = 0.5f;	
-	}
+
 }
 
 void AAIExecute::CheckJammer()

Modified: trunk/AI/Global/AAI/AAIExecute.h
===================================================================
--- trunk/AI/Global/AAI/AAIExecute.h	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIExecute.h	2008-06-01 20:48:49 UTC (rev 5970)
@@ -16,8 +16,15 @@
 	AAIExecute(AAI* ai, AAIBrain *brain);
 	~AAIExecute(void);
 
+	void InitAI(int commander_unit_id, const UnitDef *commander_def);
+
+	// return true if building will be placed at a valid pos = inside sectors
+	bool InitBuildingAt(const UnitDef *def, float3 pos);
+
 	void ConstructBuildingAt(int building, int builder, float3 position); 
 
+	void CreateBuildTask(int unit, const UnitDef *def, float3 *pos);
+
 	void moveUnitTo(int unit, float3 *position);  
 
 	void stopUnit(int unit);

Modified: trunk/AI/Global/AAI/AAIMap.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIMap.cpp	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIMap.cpp	2008-06-01 20:48:49 UTC (rev 5970)
@@ -2411,9 +2411,9 @@
 		{
 			cell = x + xDefMapSize*y;
 			
-			defence_map[cell] += 64.0f;
-			air_defence_map[cell] += 64.0f;
-			submarine_defence_map[cell] += 64.0f;
+			defence_map[cell] += 1000.0f;
+			air_defence_map[cell] += 1000.0f;
+			submarine_defence_map[cell] += 1000.0f;
 		}
 	}
 }
@@ -2469,9 +2469,9 @@
 		{
 			cell = x + xDefMapSize*y;
 			
-			defence_map[cell] -= 64.0f;
-			air_defence_map[cell] -= 64.0f;
-			submarine_defence_map[cell] -= 64.0f;
+			defence_map[cell] -= 1000.0f;
+			air_defence_map[cell] -= 1000.0f;
+			submarine_defence_map[cell] -= 1000.0f;
 		}
 	}
 

Modified: trunk/AI/Global/AAI/AAIUnitTable.cpp
===================================================================
--- trunk/AI/Global/AAI/AAIUnitTable.cpp	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/AAIUnitTable.cpp	2008-06-01 20:48:49 UTC (rev 5970)
@@ -147,10 +147,10 @@
 void AAIUnitTable::RemoveConstructor(int unit_id, int def_id)
 {
 	if(units[unit_id].cons-&gt;builder)
-		--ai-&gt;activeBuilders;
+		ai-&gt;activeBuilders -= 1;
 
-	if(units[unit_id].cons-&gt;factory)
-		--ai-&gt;activeFactories;
+	if(units[unit_id].cons-&gt;factory &amp;&amp; bt-&gt;IsStatic(def_id))
+		ai-&gt;activeFactories -= 1;
 	
 	// decrease number of available builders for all buildoptions of the builder
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)		

Modified: trunk/AI/Global/AAI/aidef.h
===================================================================
--- trunk/AI/Global/AAI/aidef.h	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/AI/Global/AAI/aidef.h	2008-06-01 20:48:49 UTC (rev 5970)
@@ -32,7 +32,7 @@
 #ifndef AIDEF_H
 #define AIDEF_H
 
-#define AAI_VERSION &quot;0.868&quot;
+#define AAI_VERSION &quot;0.869&quot;
 #define MAP_FILE_VERSION &quot;MAP_LEARN_0_80&quot;
 #define TABLE_FILE_VERSION &quot;MOD_LEARN_0_86&quot;
 #define MAP_DATA_VERSION &quot;MAP_DATA_0_86&quot;
@@ -133,6 +133,7 @@
 
 struct UnitTypeDynamic
 {
+	int under_construction;	// how many units of that type are under construction
 	int requested;			// how many units of that type have been requested
 	int active;				// how many units of that type are currently alive
 	int buildersAvailable;	// how many factories/builders available being able to build that unit

Modified: trunk/game/AI/AAI/AAI ReadMe.txt
===================================================================
--- trunk/game/AI/AAI/AAI ReadMe.txt	2008-06-01 00:23:53 UTC (rev 5969)
+++ trunk/game/AI/AAI/AAI ReadMe.txt	2008-06-01 20:48:49 UTC (rev 5970)
@@ -83,11 +83,11 @@
 
 
 
-Thanks to: 	- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
-
-		- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
+Thanks to: 	- Yuritch for testing and providing me with improved mod config files, numerous ideas and suggestions
 		  and coding contributions (since AAI v0.83) 
 
+		- Nicklas Marcusson for porting/compiling the linux version of AAI, lots of help with debugging
+
 		- TA Spring devs for creating the best open source rts game I know
 
 		- Jelmer 'JC' Cnossen for some functions and a lot of helpful discussions
@@ -106,29 +106,23 @@
 
 
 
-AAI v0.868	- Improved fall back behaviour: units with turnrate below MIN_FALLBACK turnrate will not fall back anymore, long ranged 
-		  units (e.g. snipers) will not fall back to their maximum weapons range anymore; added keywords:	
-  		  MIN_FALLBACK_TURNRATE 250	  
-		  MAX_FALLBACK_RANGE 800  
+AAI v0.869	- Added proper handling of resurrected units (however AAI does not build resurrectors atm)
+		
+		- Fixed a bug that could prevent AAI from rebuilding destroyed factories	
 
-		- Fixed another possible freeze when AAI's attack manager was flooding the interface with orders
-	
 
-AAI v0.867	- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
-		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
+AAI v0.868	- Added some unit specific combat behaviour: Units with high ranged weapons  will now try to keep enemies distant (if 
+		  their turnrate is not too low)
 
-		- Fixed a bug that caused builders to leave the buildsite during construction 
+		- Added some new variables to mod config file:
 
-		- Various changes to issued orders; temporarily removed reclaiming. Reclaim orders were given multiple times per frame 
-		  thus flooding the interface with orders and causing Spring to freeze/huge drop in FPS 
-
-		- Added some unit specific combat behaviour: Units with high ranged weapons will now try to keep enemies distant
-
-		- Added two new variables to mod config file:
-
 		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
 		  
-		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all 
+		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
+		 
+		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
+	
+  		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
 
 		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 
 		  naval units
@@ -136,6 +130,14 @@
 		- AAI now takes continents into account when sending scouts to positions (e.g. it does not try send ground scouts to 
 		  positions on other islands/continents anymore)
 
+		- AAI now takes continents into account when sending builder/assistant builders to positions (e.g. it does not try send 
+		  ground builders to positions on other islands/continents anymore (unless they are amphibious))
+
+		- Fixed a bug that caused builders to leave the buildsite during construction 
+
+		- Fixed various freezes that have been caused by AAI flooding the ai interface with thousands of orders per frame
+
+
 		- Bumped mod learning file version to 0.86 due to some changes in handling of amphibious units
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000749.html">[Taspring-linux-commit] r5969 - trunk/AI/Global/NTai/AI/NTai/Units
</A></li>
	<LI>Next message: <A HREF="000751.html">[Taspring-linux-commit] r5971 - in trunk: . AI/Global/AAI installer	installer/builddata installer/builddata/maphelper	installer/builddata/maphelper/maphelper	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Map rts/Map/SM3	rts/Map/SMF rts/Rendering rts/Rendering/Env rts/Sim/Features	rts/Sim/Misc rts/Sim/Projectiles rts/Sim/Units	rts/Sim/Units/CommandAI rts/System rts/System/FileSystem	rts/System/Script tools/unitsync tools/unitsync/test
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#750">[ date ]</a>
              <a href="thread.html#750">[ thread ]</a>
              <a href="subject.html#750">[ subject ]</a>
              <a href="author.html#750">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
