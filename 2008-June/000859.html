<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6079 - in trunk: . game game/LuaUI	game/LuaUI/Widgets installer/builddata/maphelper	installer/builddata/maphelper/maphelper	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Map rts/Map/SMF	rts/Rendering rts/Sim rts/Sim/Misc rts/Sim/Path rts/Sim/Units	rts/System rts/System/FileSystem rts/System/Platform	rts/lib/lua rts/lib/lua/include tools/unitsync tools/unitsync/test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6079%20-%20in%20trunk%3A%20.%20game%20game/LuaUI%0A%09game/LuaUI/Widgets%20installer/builddata/maphelper%0A%09installer/builddata/maphelper/maphelper%0A%09installer/builddata/springcontent/LuaGadgets%0A%09installer/builddata/springcontent/gamedata%20rts/Game%0A%09rts/Game/StartScripts%20rts/Game/UI%20rts/Lua%20rts/Map%20rts/Map/SMF%0A%09rts/Rendering%20rts/Sim%20rts/Sim/Misc%20rts/Sim/Path%20rts/Sim/Units%0A%09rts/System%20rts/System/FileSystem%20rts/System/Platform%0A%09rts/lib/lua%20rts/lib/lua/include%20tools/unitsync%20tools/unitsync/test&In-Reply-To=%3C20080627033527.7FE754636%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000858.html">
   <LINK REL="Next"  HREF="000860.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6079 - in trunk: . game game/LuaUI	game/LuaUI/Widgets installer/builddata/maphelper	installer/builddata/maphelper/maphelper	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Map rts/Map/SMF	rts/Rendering rts/Sim rts/Sim/Misc rts/Sim/Path rts/Sim/Units	rts/System rts/System/FileSystem rts/System/Platform	rts/lib/lua rts/lib/lua/include tools/unitsync tools/unitsync/test</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6079%20-%20in%20trunk%3A%20.%20game%20game/LuaUI%0A%09game/LuaUI/Widgets%20installer/builddata/maphelper%0A%09installer/builddata/maphelper/maphelper%0A%09installer/builddata/springcontent/LuaGadgets%0A%09installer/builddata/springcontent/gamedata%20rts/Game%0A%09rts/Game/StartScripts%20rts/Game/UI%20rts/Lua%20rts/Map%20rts/Map/SMF%0A%09rts/Rendering%20rts/Sim%20rts/Sim/Misc%20rts/Sim/Path%20rts/Sim/Units%0A%09rts/System%20rts/System/FileSystem%20rts/System/Platform%0A%09rts/lib/lua%20rts/lib/lua/include%20tools/unitsync%20tools/unitsync/test&In-Reply-To=%3C20080627033527.7FE754636%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6079 - in trunk: . game game/LuaUI	game/LuaUI/Widgets installer/builddata/maphelper	installer/builddata/maphelper/maphelper	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua rts/Map rts/Map/SMF	rts/Rendering rts/Sim rts/Sim/Misc rts/Sim/Path rts/Sim/Units	rts/System rts/System/FileSystem rts/System/Platform	rts/lib/lua rts/lib/lua/include tools/unitsync tools/unitsync/test">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Jun 27 05:35:27 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000858.html">[Taspring-linux-commit] r6078 - trunk/Lobby/TASClient
</A></li>
        <LI>Next message: <A HREF="000860.html">[Taspring-linux-commit] r6080 - trunk/tools/unitsync/test
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#859">[ date ]</a>
              <a href="thread.html#859">[ thread ]</a>
              <a href="subject.html#859">[ subject ]</a>
              <a href="author.html#859">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: trepan
Date: 2008-06-27 05:35:24 +0200 (Fri, 27 Jun 2008)
New Revision: 6079

Added:
   trunk/installer/builddata/maphelper/maphelper/mapdefaults.lua
   trunk/installer/builddata/maphelper/maphelper/setupopts.lua
   trunk/rts/Lua/LuaInputReceiver.cpp
   trunk/rts/Lua/LuaInputReceiver.h
   trunk/rts/Sim/SideParser.cpp
   trunk/rts/Sim/SideParser.h
   trunk/tools/unitsync/LuaParserAPI.cpp
   trunk/tools/unitsync/LuaParserAPI.h
   trunk/tools/unitsync/test/test.cxx
Modified:
   trunk/SConstruct
   trunk/game/LuaUI/Widgets/camera_ctrl.lua
   trunk/game/LuaUI/Widgets/gui_clock.lua
   trunk/game/LuaUI/Widgets/gui_comm_ends.lua
   trunk/game/LuaUI/Widgets/gui_eyes.lua
   trunk/game/LuaUI/Widgets/gui_modeltest.lua
   trunk/game/LuaUI/Widgets/gui_mousetrail.lua
   trunk/game/LuaUI/Widgets/gui_tooltip.lua
   trunk/game/LuaUI/Widgets/ico_customicons.lua
   trunk/game/LuaUI/Widgets/snd_chatterbox.lua
   trunk/game/LuaUI/actions.lua
   trunk/game/LuaUI/callins.lua
   trunk/game/LuaUI/fonts.lua
   trunk/game/LuaUI/layout.lua
   trunk/game/LuaUI/widgets.lua
   trunk/game/teamcolors.lua
   trunk/installer/builddata/maphelper/MapOptions.lua
   trunk/installer/builddata/maphelper/maphelper/applyopts.lua
   trunk/installer/builddata/springcontent/LuaGadgets/actions.lua
   trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua
   trunk/installer/builddata/springcontent/gamedata/explosions.lua
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/Game.h
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/GameServer.cpp
   trunk/rts/Game/GameSetup.cpp
   trunk/rts/Game/GameSetupData.h
   trunk/rts/Game/Player.cpp
   trunk/rts/Game/Player.h
   trunk/rts/Game/PreGame.cpp
   trunk/rts/Game/PreGame.h
   trunk/rts/Game/SelectedUnits.cpp
   trunk/rts/Game/SelectedUnits.h
   trunk/rts/Game/SelectedUnitsAI.cpp
   trunk/rts/Game/StartScripts/CommanderScript.cpp
   trunk/rts/Game/StartScripts/CommanderScript2.cpp
   trunk/rts/Game/StartScripts/GlobalAITestScript.cpp
   trunk/rts/Game/StartScripts/SpawnScript.cpp
   trunk/rts/Game/Team.cpp
   trunk/rts/Game/Team.h
   trunk/rts/Game/UI/EndGameBox.cpp
   trunk/rts/Game/UI/EndGameBox.h
   trunk/rts/Game/UI/GameSetupDrawer.cpp
   trunk/rts/Game/UI/GuiHandler.cpp
   trunk/rts/Game/UI/GuiHandler.h
   trunk/rts/Game/UI/LuaUI.cpp
   trunk/rts/Game/UI/LuaUI.h
   trunk/rts/Game/UI/MouseHandler.cpp
   trunk/rts/Game/UI/ShareBox.cpp
   trunk/rts/Game/UI/TooltipConsole.cpp
   trunk/rts/Lua/LuaCallInHandler.cpp
   trunk/rts/Lua/LuaCallInHandler.h
   trunk/rts/Lua/LuaConstGame.cpp
   trunk/rts/Lua/LuaHandle.cpp
   trunk/rts/Lua/LuaHandle.h
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaParser.cpp
   trunk/rts/Lua/LuaParser.h
   trunk/rts/Lua/LuaSyncedRead.cpp
   trunk/rts/Lua/LuaSyncedRead.h
   trunk/rts/Lua/LuaTextures.h
   trunk/rts/Lua/LuaUnitRendering.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.cpp
   trunk/rts/Lua/LuaUnsyncedCtrl.h
   trunk/rts/Lua/LuaUnsyncedRead.cpp
   trunk/rts/Lua/LuaUnsyncedRead.h
   trunk/rts/Lua/LuaWeaponDefs.cpp
   trunk/rts/Map/BaseGroundDrawer.cpp
   trunk/rts/Map/MapInfo.cpp
   trunk/rts/Map/MapInfo.h
   trunk/rts/Map/ReadMap.cpp
   trunk/rts/Map/ReadMap.h
   trunk/rts/Map/SMF/SmfReadMap.cpp
   trunk/rts/Rendering/IconHandler.cpp
   trunk/rts/Sim/Misc/LosHandler.cpp
   trunk/rts/Sim/Misc/LosHandler.h
   trunk/rts/Sim/Misc/RadarHandler.cpp
   trunk/rts/Sim/Misc/RadarHandler.h
   trunk/rts/Sim/ModInfo.cpp
   trunk/rts/Sim/ModInfo.h
   trunk/rts/Sim/Path/PathEstimator.cpp
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/Unit.h
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/Sim/Units/UnitLoader.cpp
   trunk/rts/System/FileSystem/ArchiveFactory.cpp
   trunk/rts/System/FileSystem/ArchiveFactory.h
   trunk/rts/System/FileSystem/ArchiveScanner.cpp
   trunk/rts/System/FileSystem/ArchiveScanner.h
   trunk/rts/System/FileSystem/VFSHandler.cpp
   trunk/rts/System/FileSystem/VFSHandler.h
   trunk/rts/System/GlobalStuff.cpp
   trunk/rts/System/MouseInput.cpp
   trunk/rts/System/Platform/ConfigHandler.cpp
   trunk/rts/System/Platform/ConfigHandler.h
   trunk/rts/System/SpringApp.cpp
   trunk/rts/lib/lua/README_SPRING
   trunk/rts/lib/lua/include/luaconf.h
   trunk/tools/unitsync/test/test.cpp
   trunk/tools/unitsync/unitsync.cpp
Log:

// UNITSYNC
- added LuaParser API to unitsync
  (and some test code to unitsync/test/test.cpp, needs more testing)

- added OpenArchiveType(name, type) to unitsync  (at Satirik's request)
  (type can be &quot;zip&quot;, &quot;7z&quot;, &quot;dir&quot;, or &quot;hpi&quot;)

- added 'const char* GetSideStartUnit(int side)' to unitsync


// GAME
- changed the order of selections for scriptless execution:
    was:  map, script, mod
    now:  mod, script, map
  this was done so that ValidMaps.lua could be implemented
  properly for scriptless execution, which should help implement
  scriptless execution missions

- added the '-C &lt;filename&gt;' command line option
  (for using alternate config files, or registry paths (right term?))

- added separate sonarJammer LOS maps
  (#define SONAR_JAMMER_MAPS in RadarHandler.h to enable)

- added the CPlayer::controlledTeams set

- added the SideParser.cpp parser  (unifies the side parsing)

- did some more cleanup in ArchiveScanner


// MAP
- added SMF height overrides in the SMD file, example:
    smf = {
      minheight = -100.0f,
      maxheight =  200.0f,
    }
  (note:  these values can be changed by MapOptions)


// LUAUI migration
- moved most of the LuaUI call-outs into LuaUnsyncedRead
  and LuaUnsyncedCtrl. The LuaUnsyncedCtrl call-outs require
  that the modUICtrl variable be enabled for non-user scripts
  to use them. I've also considered adding a user controlled
  file that lists the call-ins and call-outs the the unsynced
  global scripts can use. The handling for net message related
  call-outs might also change...

- moved most of the LuaUI call-ins into LuaCallInHandler and
  LuaHandle. The moved call-ins require that the modUICtrl
  variable be enabled for non-user scripts to receive them.

- added the /luamoduictrl [0|1] command

- added the &quot;LuaModUICtrl&quot; (default = 1) config variable

// SYNCED call-ins
- added UnitEnteredWater(unitID, unitDefID, unitTeam) call-in
- added UnitEnteredAir(unitID, unitDefID, unitTeam) call-in
- added UnitLeftWater(unitID, unitDefID, unitTeam) call-in
- added UnitLeftAir(unitID, unitDefID, unitTeam) call-in

// SYNCED call-outs
- added Spring.ValidUnitID(number id)    -&gt; boolean
- added Spring.ValidFeatureID(number id) -&gt; boolean

// UNSYNCED call-ins
- added a real ViewResize() call-in

// UNSYNCED call-outs
- added Spring.GetModUICtrl()
- added Spring.GetViewGeometry()   -&gt; sizeX, sizeY, posX, posY
- added Spring.GetWindowGeometry() -&gt; sizeX, sizeY, posX, posY
- added Spring.GetScreenGeometry() -&gt; sizeX, sizeY, posX, posY

- modified Spring.GetVisibleUnits() so that the team specifier can
  use the ALL_UNITS, ALLY_UNITS, ENEMY_UNITS, and MY_UNITS values.

- removed the following compatibility defines from luaconf.h:
    LUA_COMPAT_VARARG              
    LUA_COMPAT_MOD
    LUA_COMPAT_LSTR
    LUA_COMPAT_GFIND
    LUA_COMPAT_OPENLIB

- adjusted the lua scripts in SVN for the compatibility changes



Modified: trunk/SConstruct
===================================================================
--- trunk/SConstruct	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/SConstruct	2008-06-27 03:35:24 UTC (rev 6079)
@@ -91,7 +91,7 @@
 	'rts/Map/MapParser.cpp',
 	'rts/Rendering/Textures/Bitmap.cpp',
 	'rts/Rendering/Textures/nv_dds.cpp',
-	'rts/System/TdfParser.cpp',
+	'rts/Sim/SideParser.cpp',
 	'rts/System/Platform/ConfigHandler.cpp',
 	'rts/System/Platform/FileSystem.cpp',
 ]

Modified: trunk/game/LuaUI/Widgets/camera_ctrl.lua
===================================================================
--- trunk/game/LuaUI/Widgets/camera_ctrl.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/camera_ctrl.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -90,7 +90,8 @@
       Spring.Echo('  bad parameter name: ' .. words[1])
       return true
     end
-    cs[words[1]] = tonumber(words[2])
+    local newValue = tonumber(words[2])
+    cs[words[1]] = newValue
     local camTime = 0
     if (wc &gt;= 3) then  --  specified transition time?
       camTime = tonumber(words[3])
@@ -100,7 +101,7 @@
       end
     end
     Spring.SetCameraState(cs, camTime)
-    Spring.Echo('  set ' .. words[1] .. ' to ' .. value)
+    Spring.Echo('  set ' .. words[1] .. ' to ' .. newValue)
   end
 
   return true

Modified: trunk/game/LuaUI/Widgets/gui_clock.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_clock.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/gui_clock.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -82,8 +82,8 @@
   if (timeSecs ~= secs) then
     timeSecs = secs
     local h = math.floor(secs / 3600)
-    local m = math.floor(math.mod(secs, 3600) / 60)
-    local s = math.floor(math.mod(secs, 60))
+    local m = math.floor((secs % 3600) / 60)
+    local s = math.floor(secs % 60)
     if (h &gt; 0) then
       timeString = string.format('%02i:%02i:%02i', h, m, s)
     else

Modified: trunk/game/LuaUI/Widgets/gui_comm_ends.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_comm_ends.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/gui_comm_ends.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -65,7 +65,7 @@
   if (Game.commEnds) then
     local timer = widgetHandler:GetHourTimer()
     local colorStr
-    if (math.mod(timer, 0.5) &lt; 0.25) then
+    if ((timer % 0.5) &lt; 0.25) then
       colorStr = RedStr
     else
       colorStr = YellowStr

Modified: trunk/game/LuaUI/Widgets/gui_eyes.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_eyes.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/gui_eyes.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -150,7 +150,7 @@
 
 function widget:GetTooltip(x, y)
   local r = 0.333
-  local toggle = (math.mod(widgetHandler:GetHourTimer(), r) &lt; (r * 0.5))
+  local toggle = ((widgetHandler:GetHourTimer() % r) &lt; (r * 0.5))
   local cs1 = (toggle and '\255\64\255\64') or '\255\64\128\64'
   local w = WhiteStr
   local tt = w
@@ -246,7 +246,7 @@
   local timer = widgetHandler:GetHourTimer()
   gl.MatrixMode(GL.TEXTURE)
   gl.PushMatrix()
-  gl.Rotate(math.mod(e.td * timer * 60, 360), 0.0, 0.0, 1.0)
+  gl.Rotate((e.td * timer * 60) % 360, 0.0, 0.0, 1.0)
   gl.MatrixMode(GL.MODELVIEW)
   DrawLists(e.x, e.y, e.sx * 0.5, e.sy * 0.5, {
     { circlePolyList, color}, { circleLineList, black }
@@ -271,7 +271,7 @@
   -- an unmissable message
   local htime = widgetHandler:GetHourTimer()
   local r = 0.333
-  local toggle = math.mod(htime, r) &lt; (r * 0.5)
+  local toggle = (htime % r) &lt; (r * 0.5)
   local cs1 = (toggle and '\255\255\255\64') or '\255\128\128\64'
   local tt = ''
   tt = tt .. WhiteStr .. 'Use'

Modified: trunk/game/LuaUI/Widgets/gui_modeltest.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_modeltest.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/gui_modeltest.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -178,7 +178,7 @@
   local cx = 0.5 * Game.mapSizeX
   local cz = 0.5 * Game.mapSizeZ
   local time = widgetHandler:GetHourTimer()
-  radians = math.mod(math.pi * 2 * time * 0.1, math.pi * 2)
+  radians = (math.pi * 2 * time * 0.1) % (math.pi * 2)
   if (revolve) then
     local cos_val = math.cos(radians)
     local sin_val = math.sin(radians)
@@ -203,7 +203,7 @@
   if (clip) then
     local hourTime = widgetHandler:GetHourTimer()
     local rate = 4
-    local dist = msx * (0.5 - (math.mod(hourTime, rate) / rate))
+    local dist = msx * (0.5 - ((hourTime % rate) / rate))
     gl.ClipPlane(1,  1, 0, 0, dist)
     gl.ClipPlane(2, -1, 0, 0, -dist + (msx * 0.1))
   end

Modified: trunk/game/LuaUI/Widgets/gui_mousetrail.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_mousetrail.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/gui_mousetrail.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -56,7 +56,7 @@
   local elements = {}
   local h = head
   while h do
-    local timeLeft = math.mod((h[4] - timer) + 3600.0, 3600.0)
+    local timeLeft = ((h[4] - timer) + 3600.0) % 3600.0
     if (timeLeft &gt; lifeTime) then
       if (h == head) then
         head = nil

Modified: trunk/game/LuaUI/Widgets/gui_tooltip.lua
===================================================================
--- trunk/game/LuaUI/Widgets/gui_tooltip.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/gui_tooltip.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -135,7 +135,7 @@
     fontHandler.DisableCache()  -- ground tooltips change too much for caching
   end
 
-  for line in string.gfind(tooltip, &quot;([^\n]*)\n?&quot;) do
+  for line in string.gmatch(tooltip, &quot;([^\n]*)\n?&quot;) do
     if (unitTip and (i == 0)) then
       line = &quot;\255\255\128\255&quot; .. line
     else

Modified: trunk/game/LuaUI/Widgets/ico_customicons.lua
===================================================================
--- trunk/game/LuaUI/Widgets/ico_customicons.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/ico_customicons.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -73,7 +73,7 @@
   if (commanderUnitDefs) then
     local timer = widgetHandler:GetHourTimer()
     local iconName
-    if (math.mod(timer, 0.5) &gt; 0.25) then
+    if ((timer % 0.5) &gt; 0.25) then
       iconName = &quot;star.user&quot;
     else
       iconName = &quot;star-dark.user&quot;

Modified: trunk/game/LuaUI/Widgets/snd_chatterbox.lua
===================================================================
--- trunk/game/LuaUI/Widgets/snd_chatterbox.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/Widgets/snd_chatterbox.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -30,7 +30,7 @@
 
 
 local function playSound(filename, ...)
-  Spring.PlaySoundFile(SOUND_DIRNAME .. filename, unpack(arg))
+  Spring.PlaySoundFile(SOUND_DIRNAME .. filename, ...)
 end
 
 

Modified: trunk/game/LuaUI/actions.lua
===================================================================
--- trunk/game/LuaUI/actions.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/actions.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -152,7 +152,7 @@
 
 local function MakeWords(line)
   local words = {}
-  for w in string.gfind(line, &quot;[^%s]+&quot;) do
+  for w in string.gmatch(line, &quot;[^%s]+&quot;) do
     table.insert(words, w)
   end
   return words

Modified: trunk/game/LuaUI/callins.lua
===================================================================
--- trunk/game/LuaUI/callins.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/callins.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -49,6 +49,11 @@
   &quot;UnitLoaded&quot;,
   &quot;UnitUnloaded&quot;,
 
+  &quot;UnitEnteredWater&quot;,
+  &quot;UnitEnteredAir&quot;,
+  &quot;UnitLeftWater&quot;,
+  &quot;UnitLeftAir&quot;,
+
   &quot;FeatureCreated&quot;,
   &quot;FeatureDestroyed&quot;,
 

Modified: trunk/game/LuaUI/fonts.lua
===================================================================
--- trunk/game/LuaUI/fonts.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/fonts.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -43,13 +43,13 @@
 --  Local speedups
 --
 
-local floor    = math.floor
-local strlen   = string.len
-local strsub   = string.sub
-local strbyte  = string.byte
-local strchar  = string.char
-local strfind  = string.find
-local strgfind = string.gfind
+local floor     = math.floor
+local strlen    = string.len
+local strsub    = string.sub
+local strbyte   = string.byte
+local strchar   = string.char
+local strfind   = string.find
+local strgmatch = string.gmatch
 
 
 --------------------------------------------------------------------------------
@@ -69,7 +69,7 @@
 local origPrint = print
 local print = function(...)
   if (debug) then
-    origPrint(unpack(arg))
+    origPrint(...)
   end
 end
 
@@ -205,7 +205,7 @@
 
 local function StripColorCodes(text)
   local stripped = &quot;&quot;
-  for txt, color in strgfind(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
+  for txt, color in strgmatch(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
     if (strlen(txt) &gt; 0) then
       stripped = stripped .. txt
     end
@@ -269,7 +269,7 @@
 
 
 local function RawColorDraw(text)
-  for txt, color in strgfind(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
+  for txt, color in strgmatch(text, &quot;([^\255]*)(\255?.?.?.?)&quot;) do
     if (strlen(txt) &gt; 0) then
       RawDraw(txt)
     end

Modified: trunk/game/LuaUI/layout.lua
===================================================================
--- trunk/game/LuaUI/layout.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/layout.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -129,10 +129,10 @@
   for cmdSlot = 1, (cmdCount - 2) do
 
     -- fill the last row with special buttons
-    while (math.mod(pos, ipp) &gt;= firstSpecial) do
+    while ((pos % ipp) &gt;= firstSpecial) do
       pos = pos + 1
     end
-    local onLastRow = (math.abs(math.mod(pos, ipp)) &lt; 0.1)
+    local onLastRow = (math.abs(pos % ipp) &lt; 0.1)
 
     if (onLastRow) then
       local pageStart = math.floor(ipp * math.floor(pos / ipp))

Modified: trunk/game/LuaUI/widgets.lua
===================================================================
--- trunk/game/LuaUI/widgets.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/LuaUI/widgets.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -124,6 +124,10 @@
   'UnitEnteredLos',
   'UnitLeftRadar',
   'UnitLeftLos',
+  'UnitEnteredWater',
+  'UnitEnteredAir',
+  'UnitLeftWater',
+  'UnitLeftAir',
   'UnitSeismicPing',
   'UnitLoaded',
   'UnitUnloaded',
@@ -283,6 +287,42 @@
 
 --------------------------------------------------------------------------------
 
+
+local function GetWidgetInfo(name, mode)
+  local lines = VFS.LoadFile(name, mode)
+
+  local infoLines = {}
+
+  for line in lines:gmatch('([^\n]*)\n') do
+    if (not line:find('^%s*%-%-')) then
+      if (line:find('[^\r]')) then
+        break -- not commented, not a blank line
+      end
+    end
+    local s, e, source = line:find('^%s*%-%-%&gt;%&gt;(.*)')
+    if (source) then
+      table.insert(infoLines, source)
+    end
+  end
+
+  local info = {}
+  local chunk, err = loadstring(table.concat(infoLines, '\n'))
+  if (not chunk) then
+    Spring.Echo('not loading ' .. name .. ': ' .. err)
+  else
+    setfenv(chunk, info)
+    local success, err = pcall(chunk)
+    if (not success) then
+      Spring.Echo('not loading ' .. name .. ': ' .. err)
+    end
+  end
+
+  for k,v in pairs(info) do
+    Spring.Echo(name, k, 'type: ' .. type(v), '&lt;'..tostring(v)..'&gt;')
+  end
+end
+
+
 function widgetHandler:Initialize()
   self:LoadOrderList()
   self:LoadConfigData()
@@ -298,6 +338,7 @@
   -- stuff the raw widgets into unsortedWidgets
   local widgetFiles = VFS.DirList(WIDGET_DIRNAME, &quot;*.lua&quot;, VFS.RAW_ONLY)
   for k,wf in ipairs(widgetFiles) do
+    GetWidgetInfo(wf, VFS.RAW_ONLY)
     local widget = self:LoadWidget(wf, false)
     if (widget) then
       table.insert(unsortedWidgets, widget)
@@ -307,6 +348,7 @@
   -- stuff the zip widgets into unsortedWidgets
   local widgetFiles = VFS.DirList(WIDGET_DIRNAME, &quot;*.lua&quot;, VFS.ZIP_ONLY)
   for k,wf in ipairs(widgetFiles) do
+    GetWidgetInfo(wf, VFS.ZIP_ONLY)
     local widget = self:LoadWidget(wf, true)
     if (widget) then
       table.insert(unsortedWidgets, widget)
@@ -561,7 +603,7 @@
 
   return function(w, ...)
 
-    local r = { pcall(func, w, unpack(arg)) }
+    local r = { pcall(func, w, ...) }
 
     if (r[1]) then
       table.remove(r, 1)
@@ -588,7 +630,7 @@
   return function(w, ...)
 
     glPushAttrib(GL.ALL_ATTRIB_BITS)
-    local r = { pcall(func, w, unpack(arg)) }
+    local r = { pcall(func, w, ...) }
     glPopAttrib()
 
     if (r[1]) then
@@ -733,7 +775,7 @@
     -- always assign these call-ins
     local selffunc = self[name]
     _G[name] = function(...)
-      return selffunc(self, unpack(arg))
+      return selffunc(self, ...)
     end
   else
     _G[name] = nil
@@ -1024,7 +1066,7 @@
 function widgetHandler:Update()
   local deltaTime = Spring.GetLastUpdateSeconds()  
   -- update the hour timer
-  hourTimer = math.mod(hourTimer + deltaTime, 3600.0)
+  hourTimer = (hourTimer + deltaTime) % 3600.0
   for _,w in ipairs(self.UpdateList) do
     w:Update(deltaTime)
   end
@@ -1131,6 +1173,12 @@
 
 
 function widgetHandler:ViewResize(vsx, vsy)
+  if (type(vsx) == 'table') then
+    vsy = vsx.viewSizeY
+    vsx = vsx.viewSizeX
+    print('real ViewResize') -- FIXME
+  end
+    
   for _,w in ipairs(self.ViewResizeList) do
     w:ViewResize(vsx, vsy)
   end
@@ -1502,7 +1550,7 @@
 
 function widgetHandler:DefaultCommand(...)
   for _,w in ripairs(self.DefaultCommandList) do
-    local result = w:DefaultCommand(unpack(arg))
+    local result = w:DefaultCommand(...)
     if (type(result) == 'number') then
       return result
     end
@@ -1599,9 +1647,9 @@
 end
 
 
-function widgetHandler:UnitEnteredLos(unitID, unitDefID, unitTeam)
+function widgetHandler:UnitEnteredLos(unitID, unitTeam)
   for _,w in ipairs(self.UnitEnteredLosList) do
-    w:UnitEnteredLos(unitID, unitDefID, unitTeam)
+    w:UnitEnteredLos(unitID, unitTeam)
   end
   return
 end
@@ -1615,14 +1663,46 @@
 end
 
 
-function widgetHandler:UnitLeftLos(unitID, unitDefID, unitTeam)
+function widgetHandler:UnitLeftLos(unitID, unitTeam)
   for _,w in ipairs(self.UnitLeftLosList) do
-    w:UnitLeftLos(unitID, unitDefID, unitTeam)
+    w:UnitLeftLos(unitID, unitTeam)
   end
   return
 end
 
 
+function widgetHandler:UnitEnteredWater(unitID, unitDefID, unitTeam)
+  for _,w in ipairs(self.UnitEnteredWaterList) do
+    w:UnitEnteredWater(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function widgetHandler:UnitEnteredAir(unitID, unitDefID, unitTeam)
+  for _,w in ipairs(self.UnitEnteredAirList) do
+    w:UnitEnteredAir(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function widgetHandler:UnitLeftWater(unitID, unitDefID, unitTeam)
+  for _,w in ipairs(self.UnitLeftWaterList) do
+    w:UnitLeftWater(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
+function widgetHandler:UnitLeftAir(unitID, unitDefID, unitTeam)
+  for _,w in ipairs(self.UnitLeftAirList) do
+    w:UnitLeftAir(unitID, unitDefID, unitTeam)
+  end
+  return
+end
+
+
 function widgetHandler:UnitSeismicPing(x, y, z, strength)
   for _,w in ipairs(self.UnitSeismicPingList) do
     w:UnitSeismicPing(x, y, z, strength)

Modified: trunk/game/teamcolors.lua
===================================================================
--- trunk/game/teamcolors.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/game/teamcolors.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -35,11 +35,11 @@
   { 0.0, 1.0, 0.4 },
   { 0.0, 1.0, 0.8 },
   { 0.0, 0.7, 0.0 },
-  { 0.0, 0.7, 0.4 },
-  { 0.0, 0.7, 0.8 },
+  { 0.0, 0.7, 0.3 },
+  { 0.0, 0.7, 0.6 },
   { 0.0, 0.4, 0.0 },
-  { 0.0, 0.4, 0.3 },
-  { 0.0, 0.4, 0.6 },
+  { 0.0, 0.4, 0.2 },
+  { 0.0, 0.4, 0.4 },
 }
 
 local enemyColors = { -- reds

Modified: trunk/installer/builddata/maphelper/MapOptions.lua
===================================================================
--- trunk/installer/builddata/maphelper/MapOptions.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/installer/builddata/maphelper/MapOptions.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -2,7 +2,7 @@
 --------------------------------------------------------------------------------
 --
 --  file:    MapOptions.lua
---  brief:   example MapOptions.lua
+--  brief:   default MapOptions file
 --  author:  Dave Rodgers
 --
 --  Copyright (C) 2008.
@@ -11,199 +11,13 @@
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 
---  Custom Options Definition Table format
-
---  NOTES:
---  - using an enumerated table lets you specify the options order
-
---
---  These keywords must be lowercase for LuaParser to read them.
---
---  key:      the string used in the script.txt
---  name:     the displayed name
---  desc:     the description (could be used as a tooltip)
---  type:     the option type (bool, number, string, list)
---  def:      the default value
---  min:      minimum value for number options
---  max:      maximum value for number options
---  step:     quantization step, aligned to the def value
---  maxlen:   the maximum string length for string options
---  items:    array of item strings for list options
---
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  Map config parsing utilities
---
-
 local mapInfo = VFS.Include('maphelper/mapinfo.lua')
-
 if (not mapInfo.defaultoptions) then
-  return {}
+  return {} -- only load the default options if they've been requested
 end
 
+local setupFunc = VFS.Include('maphelper/setupopts.lua')
+return setupFunc(mapInfo)
 
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
---
---  Option creation utilities
---
-
-local options = {}
-
-local function ItemNumbers(min, max, step)
-  local t = {}
-  for i = min,max,step do
-    t[#t + 1] = { key = i }
-    -- 'name' is set to 'key'  when missing
-    -- 'desc' is set to 'name' when missing
-  end
-  return t
-end
-
-
-local function BoolOption(key, name, desc, value, default)
-  if (value == nil) then
-    value = default
-  end
-  local opt = {
-    type = 'bool',
-    key = key, name = name, desc = desc,
-    def = value
-  }
-  return opt
-end
-
-
-local function NumberOption(key, name, desc, value, default, min, max, step)
-  if (value == nil) then
-    value = default
-  end
-  local opt = {
-    type = 'number',
-    key = key, name = name, desc = desc,
-    def = value, min = min, max = max, step = step
-  }
-  return opt
-end
-
-
--- a 'list' option based on numbers
-local function RangeOption(key, name, desc, value, default, min, max, step)
-  if (value == nil) then
-    value = default
-  end
-  local opt = {
-    type = 'number',
-    key = key, name = name, desc = desc,
-    def = value, min = min, max = max, step = step
-  }
-  return opt
-end
-
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
-
---------------------------------------------------------------------------------
---------------------------------------------------------------------------------
---
---  Example MapOptions.lua 
---
-
-local optionDefs = {
-  gravity = {
-    'gravity', 'Gravity', 'Map Gravity',
-    NumberOption,  mapInfo.gravity, mapDefaults.gravity, 1.0, 1000.0
-  },
-  notdeformable = {
-    'notdeformable', 'NotDeformable', 
-    BoolOption, mapInfo.hardness, true
-  }
-}
-
-for _, opt in ipairs(selOpts) do
-  local optDef = optionDefs[opt]
-  if (optDef) then
-    optDef[4](optDef)
-  end
-end
-
-local options = {
-  BoolOption(
-    'softground', 'SoftGround', 'Allow for terrain height map to be adjusted',
-    mapInfo.hardness, true
-  ),
-  NumberOption(
-    'gravity', 'Gravity', 'World gravity',
-    mapInfo.gravity, 130, 1.0, 1000.0, 10.0
-  ),
-  {
-    key = 'softground',
-    name = 'SoftGround',
-    desc = 'Allow for terrain height map to be adjusted',
-    type = 'bool',
-    def = true,
-  },
-  {
-    key = 'gravity',
-    name = 'Gravity',
-    desc = 'World gravity',
-    type = 'number',
-    def = defGravity,
-    min = 1.0,
-    max = 1000.0,
-    step = 10.0,
-  },
-  {
-    key = 'windmin',
-    name = 'Wind Minimum',
-    desc = 'Controls the minimum amount of wind',
-    type = 'number',
-    def = defMinWind,
-    min = 0.0,
-    max = 250.0,
-    step = 5.0,
-  },
-  {
-    key = 'windmin2',
-    name = 'Wind Minimum',
-    desc = 'Controls the minimum amount of wind',
-    type = 'list',
-    def = defMinWind, items = ItemNumbers(0, 35, 5),
-  },
-  {
-    key = 'windmax',
-    name = 'Wind Maximum',
-    desc = 'Controls the maximum amount of wind',
-    type = 'number',
-    def = defMaxWind,
-    min = 0.0,
-    max = 250.0,
-    step = 5.0,
-  },
-  {
-    key = 'tidal',
-    name = 'Tidal',
-    desc = 'Controls the amount of tidal generation',
-    type = 'number',
-    def = defTidal,
-    min = 0.0,
-    max = 250.0,
-    step = 5.0,
-  },
-
---[[
-  {
-    key    = 'string_opt',
-    name   = 'String Option',
-    desc   = 'an unused string option',
-    type   = 'string',
-    def    = 'BiteMe',
-    maxlen = 12,
-  },
---]]
-}
-
-return options

Modified: trunk/installer/builddata/maphelper/maphelper/applyopts.lua
===================================================================
--- trunk/installer/builddata/maphelper/maphelper/applyopts.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/installer/builddata/maphelper/maphelper/applyopts.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -38,10 +38,60 @@
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 
+local function ParseFloat3(value)
+  local t = type(value)
+  if (t == 'table') then
+    if (tonumber(value[1]) and
+        tonumber(value[2]) and
+        tonumber(value[3])) then
+      return value
+    else
+      return nil
+    end
+  elseif (t == 'string') then
+    local s, e, v1, v2, v3 = value:find('^%s*(%S)%s+(%S)%s+(%S)%s*$')
+    v1 = tonumber(v1)
+    v2 = tonumber(v2)
+    v3 = tonumber(v3)
+    if (v1 and v2 and v3) then
+      return { v1, v2, v3 }
+    else
+      return nil
+    end
+  end
+  return nil
+end
+
+
 local function TintColor(color, tint)
+  return {
+    color[1] * tint[1],
+    color[2] * tint[2],
+    color[3] * tint[3],
+  }
 end
 
 
+local function SetColorComponent(color, component, value)
+  color = ParseFloat3(color)
+  if (not color) then
+    return false
+  end
+
+  if ((component == 1) or (component == 'r')) then
+    color[1] = tonumber(value)
+  elseif ((component == 2) or (component == 'g')) then
+    color[2] = tonumber(value)
+  elseif ((component == 3) or (component == 'b')) then
+    color[3] = tonumber(value)
+  else
+    return false
+  end
+
+  return true
+end
+
+
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 
@@ -101,6 +151,10 @@
   if (mapOptions.tint) then
     if (tint == 'dark') then end
   end
+  if (mapOptions.grounddiffusecolor_r) then
+    lighting.grounddiffusecolor =
+      SetColorPart(lighting.grounddiffusecolor, 'r', mapOptions.grounddiffusecolor_r)
+  end
 end
 
 

Added: trunk/installer/builddata/maphelper/maphelper/mapdefaults.lua
===================================================================
--- trunk/installer/builddata/maphelper/maphelper/mapdefaults.lua	                        (rev 0)
+++ trunk/installer/builddata/maphelper/maphelper/mapdefaults.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,106 @@
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  file:    mapDefaults.lua
+--  brief:   engine map defaults values
+--  author:  Dave Rodgers
+--
+--  Copyright (C) 2008.
+--  Licensed under the terms of the GNU GPL, v2 or later.
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local mapDefaults = {
+
+  hardness        = 100.0,
+  gravity         = 130.0,
+  tidalStrength   = 0.0,
+  maxMetal        = 0.02,
+  extractorRadius = 500.0,
+
+  notDeformable = false,
+  voidWater     = false,
+
+  autoShowMetal = true,
+
+  atmosphere = {
+    minWind  = 5.0,
+    maxWind  = 25.0,
+
+    fogStart = 0.1,
+    fogColor   = { 0.7, 0.7,  0.8 },
+    skyColor   = { 0.1, 0.15, 0.7 },
+    cloudColor = { 1.0, 1.0,  1.0 },
+    cloudDensity = 0.5,
+
+    skyBox = '',
+  },
+
+  water = {
+    damage = 0.0,
+
+    repeatX = 0.0,
+    repeatY = 0.0,
+
+    absorb    = { 0.0, 0.0, 0.0 },
+    baseColor = { 0.0, 0.0, 0.0 },
+    minColor  = { 0.0, 0.0, 0.0 },
+
+    surfaceColor = { 0.75, 0.8, 0.85 },
+    surfaceAlpha = 0.55,
+
+    planeColor = { 0.0, 0.4, 0.0 },
+
+    specularColor = { 0.5, 0.5, 0.5 }, -- tracks groundDiffuseColor
+    specularFactor = 20,
+
+    fresnelMin   = 0.2,
+    fresnelMax   = 0.3,
+    fresnelPower = 4.0,
+
+    texture = '',
+    foamTexture = '',
+    normalTexture = '',
+
+    caustics = nil, -- a nil value results in using the defaults
+  },
+
+  lighting = {
+    sunDir = { 0.0, 1.0, 2.0 },
+
+    groundAmbientColor  = { 0.5, 0.5, 0.5 },
+    groundDiffuseColor  = { 0.5, 0.5, 0.5 },
+    groundSpecularColor = { 0.1, 0.1, 0.1 },
+    groundShadowDensity = 0.8,
+
+    unitAmbientColor  = { 0.4, 0.4, 0.4 },
+    unitDiffuseColor  = { 0.7, 0.7, 0.7 },
+    unitSpecularColor = { 0.7, 0.7, 0.7 }, -- tracks unitDiffuseColor
+    unitShadowDensity = 0.8,
+  },
+
+  resources = {
+    detailTex = '',
+  },
+
+  defaultTerrainType = {
+    name = '',
+    hardness = 1.0,
+    moveSpeeds = {
+      tank  = 1.0,
+      kbot  = 1.0,
+      hover = 1.0,
+      ship  = 1.0,
+    },
+  },  
+}
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+return mapDefaults
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------

Added: trunk/installer/builddata/maphelper/maphelper/setupopts.lua
===================================================================
--- trunk/installer/builddata/maphelper/maphelper/setupopts.lua	                        (rev 0)
+++ trunk/installer/builddata/maphelper/maphelper/setupopts.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,294 @@
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  file:    setupopts.lua
+--  brief:   returns a function that creates a MapOptions table
+--  author:  Dave Rodgers
+--
+--  Copyright (C) 2008.
+--  Licensed under the terms of the GNU GPL, v2 or later.
+--
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+--  Custom Options Definition Table format
+
+--  NOTES:
+--  - using an enumerated table lets you specify the options order
+
+--
+--  These keywords must be lowercase for LuaParser to read them.
+--
+--  key:      the string used in the script.txt
+--  name:     the displayed name
+--  desc:     the description (could be used as a tooltip)
+--  type:     the option type (bool, number, string, list)
+--  def:      the default value
+--  min:      minimum value for number options
+--  max:      maximum value for number options
+--  step:     quantization step, aligned to the def value
+--  maxlen:   the maximum string length for string options
+--  items:    array of item strings for list options
+--  scope:    'all', 'player', 'team', 'allyteam'      &lt;&lt;&lt; not supported yet &gt;&gt;&gt;
+--
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Parse the desired options
+--
+
+local function AddBasic(opts)
+  table.insert(opts, 'notdeformable')
+  table.insert(opts, 'hardness')
+  table.insert(opts, 'voidwater')
+  table.insert(opts, 'waterdamage')
+  table.insert(opts, 'maxmetal')
+  table.insert(opts, 'extractorradius')
+  table.insert(opts, 'minwind')
+  table.insert(opts, 'maxwind')
+  table.insert(opts, 'tidalstrength')
+end
+
+
+local function AddAdvanced(opts)
+  AddBasic(opts)
+end
+
+
+local function CreateWantedOpts(optSel)
+  local wantedOpts = {}
+  if (type(optSel) == 'string') then
+    if (string
+  elseif (type(optSel) == 'boolean') then
+    if (optSet) then
+      AddBasic(wantedOpts)
+    else
+      return nil
+    end
+  elseif (type(optSel) == 'table') then
+  
+  end
+  return wantedOpts
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Option definition utilities
+--
+
+local function ItemNumbers(optDef)
+  local t = {}
+  for i = min,max,step do
+    t[#t + 1] = { key = i }
+    -- 'name' is set to 'key'  when missing
+    -- 'desc' is set to 'name' when missing
+  end
+  return t
+end
+
+
+local function BoolOption(optDef)
+  if (value == nil) then
+    value = default
+  end
+  local opt = {
+    type = 'bool',
+    key = optDef[1], name = optDef[2], desc = optDef[3],
+    def = optDef[4] or optDef[5]
+  }
+  return opt
+end
+
+
+local function NumberOption(optDef)
+  local opt = {
+    type = 'number',
+    key = optDef[1], name = optDef[2], desc = optDef[3],
+    def = optDef[4] or optDef[5],
+    min = optDef[6], max = optDef[7], step = optDef[8]
+  }
+  return opt
+end
+
+
+local function ColorOption(optDef)
+  local opt = {
+    type = 'string',
+    key = optDef[1], name = optDef[2], desc = optDef[3],
+    def = optDef[4] or optDef[5],
+  }
+  return opt
+end
+
+
+local function ParseFloat3(value)
+  local t = type(value)
+  if (t == 'table') then
+    if (tonumber(value[1]) and
+        tonumber(value[2]) and
+        tonumber(value[3])) then
+      return value
+    else
+      return nil
+    end
+  elseif (t = 'string') then
+    local s, e, v1, v2, v3 = value:find('^%s*(%S+)%s+(%S+)%s+(%S+)%s*')
+    v1 = tonumber(v1)
+    v2 = tonumber(v2)
+    v3 = tonumber(v3)
+    if (v1 and v2 and v3) then
+      return { v1, v2, v3 }
+    else
+      return nil
+    end
+  end
+  return nil
+end
+
+
+local function TintColor(color, tint)
+  return {
+    color[1] * tint[1],
+    color[2] * tint[2],
+    color[3] * tint[3],
+  }
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+--
+--  Option Definitions
+--
+
+-- key: option selector key 
+--   1: option key
+--   2: option name
+--   3: option description
+--   4: option generator function
+--   5: map value
+--   6: default value
+--   7: min
+--   8: max
+--   9: step
+
+local function CreateOptionDefs(mapInfo, defaultVals)
+
+  local optionDefs = {
+
+    -- basics
+
+    notdeformable = {
+      'notdeformable', 'NotDeformable', 'Ground can not be deformed',
+      BoolOption, mapInfo.hardness, true
+    },
+    hardness = {
+      'hardness', 'Hardness', 'Terrain hardness',
+      NumberOption, mapInfo.hardness, defValues.hardness,
+      0.0, 10000.0
+    },
+    voidwater = {
+      'voidwater', 'Void Water', 'Draw holes instead of water',
+      mapInfo.voidwater, defValues.voidwater
+    },
+    gravity = {
+      'gravity', 'Gravity', 'Map Gravity',
+      NumberOption,  mapInfo.gravity, defValues.gravity,
+      1.0, 1000.0
+    },
+    maxmetal = {
+      'maxmetal', 'Max Metal', 'Maximum metal density',
+      NumberOption, mapInfo.maxmetal, defValues.maxMetal,
+      0.0, 10.0
+    },
+    extractorradius = {
+      'extractorradius', 'Extractor Radius',
+      'Sets the default metal extractor radius',
+      NumberOption, mapInfo.extractorradius, defValues.extractorRadius,
+      1.0, 10000.0
+    },
+    tidalstrength = {
+      'tidalstrength', 'Tidal Strength', 'Tidal energy level',
+      mapInfo.tidalstrength, defValues.tidalStrength,
+      0.0, 1000.0
+    },
+
+    -- atmosphere
+
+    windmin = {
+      'windmin', 'Wind Minimum', 'Minimum amount of wind',
+      NumberOption,
+      mapInfo.atmosphere.windmin, defValues.atmosphere.windmin,
+      0.0, 1000.0
+    },
+    windmax = {
+      'windmax', 'Wind Maximum', 'Maximum amount of wind',
+      NumberOption,
+      mapInfo.atmosphere.windmax, defValues.atmosphere.windmax,
+      0.0, 1000.0
+    },
+
+    -- water
+
+    waterdamage = {
+      'waterdamage', 'Water Damage', 'Damage rate for units in the water',
+      NumberOption,
+      mapInfo.water.damage, defValues.water.damage,
+      0.0, 1000.0
+    },
+  }
+
+  return optionDefs
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+local function SetupOpts(mapInfo)
+
+  local wantedOpts = CreateWantedOpts(mapInfo.defaultoptions)
+  if (not wantedOpts) then
+    Spring.Echo('could not parse default map options')
+    return {}
+  end
+
+  local defaultVals = VFS.Include('maphelper/mapdefaults.lua')
+  if (not defaultVals) then
+    Spring.Echo('could not load default map values')
+    return {}
+  end
+
+  local optionDefs = CreateOptionDefs(mapInfo, defaultVals)
+  if (not optionDefs) then
+    Spring.Echo('could not create map options')
+    return {}
+  end  
+
+  local options = {}
+
+  for _, opt in ipairs(wantedOpts) do
+    local optDef = optionDefs[opt]
+    if (optDef) then
+      if (type(optDef[4]) ~= 'function') then
+        Spring.Echo('bad option definition in MapOptions.lua: ' .. opt)
+      else
+        table.insert(options, optDef[4](optDef))
+      end
+    end
+  end
+
+  return options
+end
+
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+return SetupOpts
+
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------

Modified: trunk/installer/builddata/springcontent/LuaGadgets/actions.lua
===================================================================
--- trunk/installer/builddata/springcontent/LuaGadgets/actions.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/installer/builddata/springcontent/LuaGadgets/actions.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -30,7 +30,7 @@
 
 local function MakeWords(line)
   local words = {}
-  for w in string.gfind(line, &quot;[^%s]+&quot;) do
+  for w in string.gmatch(line, &quot;[^%s]+&quot;) do
     table.insert(words, w)
   end   
   return words
@@ -151,7 +151,7 @@
 --------------------------------------------------------------------------------
 
 local function EchoLines(msg)
-  for line in string.gfind(msg, '([^\n]+)\n?') do
+  for line in string.gmatch(msg, '([^\n]+)\n?') do
     Spring.Echo(line)
   end
 end
@@ -233,9 +233,10 @@
 
 
 local function RecvFromSynced(...)
-  if (type(arg[1]) == 'string') then
+  local arg1, arg2 = ...
+  if (type(arg1) == 'string') then
     -- a raw sync msg
-    local callInfoList = syncActions[arg[1]]
+    local callInfoList = syncActions[arg1]
     if (callInfoList == nil) then
       return false
     end
@@ -243,17 +244,17 @@
     for i,callInfo in ipairs(callInfoList) do
       local func = callInfo[1]
       -- local gadget = callInfo[2]
-      if (func(unpack(arg))) then
+      if (func(...)) then
         return true
       end
     end
     return false
   end
 
-  if (type(arg[1]) == 'number') then
+  if (type(arg1) == 'number') then
     -- a proxied chat msg
-    if (type(arg[2]) == 'string') then
-      return GotChatMsg(arg[2], arg[1])
+    if (type(arg2) == 'string') then
+      return GotChatMsg(arg2, arg1)
     end
     return false
   end

Modified: trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua
===================================================================
--- trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -162,7 +162,7 @@
   'DrawInMiniMap',
   'RecvFromSynced',
 
-  -- proxied call-ins
+  -- moved from LuaUI
   'KeyPress',
   'KeyRelease',
   'MousePress',
@@ -171,6 +171,12 @@
   'MouseWheel',
   'IsAbove',
   'GetTooltip',
+
+  -- FIXME -- not implemented  (more of these?)
+  'WorldTooltip',
+  'MapDrawCmd',
+  'GameSetup',
+  'DefaultCommand',
 }
 
 
@@ -475,7 +481,7 @@
 local function SafeWrap(func, funcName)
   local gh = gadgetHandler
   return function(g, ...)
-    local r = { pcall(func, g, unpack(arg)) }
+    local r = { pcall(func, g, ...) }
     if (r[1]) then
       table.remove(r, 1)
       return unpack(r)
@@ -602,7 +608,7 @@
       (name == 'RecvFromSynced')) then
     local selffunc = self[name]
     _G[name] = function(...)
-      return selffunc(self, unpack(arg))
+      return selffunc(self, ...)
     end
   else
     _G[name] = nil
@@ -920,11 +926,11 @@
 
 
 function gadgetHandler:RecvFromSynced(...)
-  if (actionHandler.RecvFromSynced(unpack(arg))) then
+  if (actionHandler.RecvFromSynced(...)) then
     return
   end
   for _,g in ipairs(self.RecvFromSyncedList) do
-    if (g:RecvFromSynced(unpack(arg))) then
+    if (g:RecvFromSynced(...)) then
       return
     end
   end
@@ -1317,17 +1323,21 @@
 end
 
 
-function gadgetHandler:UnitLoaded(x, y, z, strength)
+function gadgetHandler:UnitLoaded(unitID, unitDefID, unitTeam,
+                                  transportID, transportTeam)
   for _,g in ipairs(self.UnitLoadedList) do
-    g:UnitLoaded(x, y, z, strength)
+    g:UnitLoaded(unitID, unitDefID, unitTeam,
+                 transportID, transportTeam)
   end
   return
 end
 
 
-function gadgetHandler:UnitUnloaded(x, y, z, strength)
+function gadgetHandler:UnitUnloaded(unitID, unitDefID, unitTeam,
+                                    transportID, transportTeam)
   for _,g in ipairs(self.UnitUnloadedList) do
-    g:UnitUnloaded(x, y, z, strength)
+    g:UnitUnloaded(unitID, unitDefID, unitTeam,
+                   transportID, transportTeam)
   end
   return
 end

Modified: trunk/installer/builddata/springcontent/gamedata/explosions.lua
===================================================================
--- trunk/installer/builddata/springcontent/gamedata/explosions.lua	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/installer/builddata/springcontent/gamedata/explosions.lua	2008-06-27 03:35:24 UTC (rev 6079)
@@ -47,7 +47,7 @@
 local function ParseColorString(str)
   local color = { 1.0, 1.0, 0.8 }
   local i = 1
-  for word in string.gfind(str, '[^,]+') do
+  for word in string.gmatch(str, '[^,]+') do
     local val = tonumber(word)
     if (val) then
       color[i] = val

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/Game.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -77,12 +77,16 @@
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;Lua/LuaInputReceiver.h&quot;
+#include &quot;Lua/LuaHandle.h&quot;
 #include &quot;Lua/LuaGaia.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Lua/LuaOpenGL.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Lua/LuaSyncedRead.h&quot;
 #include &quot;Lua/LuaUnsyncedCtrl.h&quot;
+#include &quot;Sim/ModInfo.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -92,7 +96,6 @@
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
-#include &quot;Sim/ModInfo.h&quot;
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/Path/PathManager.h&quot;
 #include &quot;Sim/Projectiles/Projectile.h&quot;
@@ -209,6 +212,8 @@
 	game = this;
 	boost::thread thread(boost::bind&lt;void, CNetProtocol, CNetProtocol*&gt;(&amp;CNetProtocol::UpdateLoop, net));
 
+	CPlayer::UpdateControlledTeams();
+
 	leastQue = 0;
 	timeLeft = 0.0f;
 	consumeSpeed = 1.0f;
@@ -269,6 +274,8 @@
 	writingPos = 0;
 	userPrompt = &quot;&quot;;
 
+	CLuaHandle::SetModUICtrl(!!configHandler.GetInt(&quot;LuaModUICtrl&quot;, 1));
+
 	consoleHistory = SAFE_NEW CConsoleHistory;
 	wordCompletion = SAFE_NEW CWordCompletion;
 	for (int pp = 0; pp &lt; MAX_PLAYERS; pp++) {
@@ -297,6 +304,8 @@
 	tooltip = SAFE_NEW CTooltipConsole();
 	iconHandler = SAFE_NEW CIconHandler();
 
+	selectedUnits.Init();
+
 	ENTER_MIXED;
 
 	helper = SAFE_NEW CGameHelper(this);
@@ -305,6 +314,10 @@
 
 	modInfo.Init(modName.c_str());
 
+	if (!sideParser.Load()) {
+		throw content_error(sideParser.GetErrorLog());
+	}
+
 	defsParser = SAFE_NEW LuaParser(&quot;gamedata/defs.lua&quot;,
 	                                SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
 	// customize the defs environment
@@ -440,9 +453,7 @@
 	CPlayer* p = gs-&gt;players[gu-&gt;myPlayerNum];
 	if(!gameSetup || net-&gt;localDemoPlayback) {
 		p-&gt;playerName = configHandler.GetString(&quot;name&quot;, &quot;&quot;);
-	}
-	else
-	{
+	} else {
 		GameSetupDrawer::Enable();
 	}
 
@@ -494,6 +505,9 @@
 	lastCpuUsageTime = gu-&gt;gameTime + 10;
 
 	mouse-&gt;ShowMouse();
+
+	// last in, first served
+	luaInputReceiver = SAFE_NEW LuaInputReceiver();
 }
 
 
@@ -547,6 +561,7 @@
 	delete pathManager;        pathManager        = NULL;
 	delete groundDecals;       groundDecals       = NULL;
 	delete ground;             ground             = NULL;
+	delete luaInputReceiver;   luaInputReceiver   = NULL; 
 	delete inMapDrawer;        inMapDrawer        = NULL;
 	delete net;                net                = NULL;
 	delete radarhandler;       radarhandler       = NULL;
@@ -604,6 +619,8 @@
 	// Fix water renderer, they depend on screen resolution...
 	delete water;
 	water = CBaseWater::GetWater();
+
+	luaCallIns.ViewResize();
 }
 
 
@@ -854,6 +871,7 @@
 }
 
 
+// FOR UNSYNCED MESSAGES
 bool CGame::ActionPressed(const Action&amp; action,
                           const CKeySet&amp; ks, bool isRepeat)
 {
@@ -1688,12 +1706,21 @@
 			}
 		}
 	}
-
 	else if (cmd == &quot;luaui&quot;) {
 		if (guihandler != NULL) {
 			guihandler-&gt;RunLayoutCommand(action.extra);
 		}
 	}
+	else if (cmd == &quot;luamoduictrl&quot;) {
+		bool modUICtrl;
+		if (action.extra.empty()) {
+			modUICtrl = !CLuaHandle::GetModUICtrl();
+		} else {
+			modUICtrl = !!atoi(action.extra.c_str());
+		}
+		CLuaHandle::SetModUICtrl(modUICtrl);
+		configHandler.SetInt(&quot;LuaModUICtrl&quot;, modUICtrl ? 1 : 0);
+	}
 	else if (cmd == &quot;minimap&quot;) {
 		if (minimap != NULL) {
 			minimap-&gt;ConfigCommand(action.extra);
@@ -1947,6 +1974,7 @@
 	return 0;
 }
 
+
 void SetBoolArg(bool&amp; value, const std::string&amp; str)
 {
 	if (str.empty()) // toggle
@@ -1960,6 +1988,8 @@
 	}
 }
 
+
+// FOR SYNCED MESSAGES
 void CGame::ActionReceived(const Action&amp; action, int playernum)
 {
 	if (action.command == &quot;cheat&quot;) {
@@ -1992,10 +2022,12 @@
 		else {
 			SetBoolArg(gs-&gt;godMode, action.extra);
 			CLuaUI::UpdateTeams();
-			if (gs-&gt;godMode)
+			if (gs-&gt;godMode) {
 				logOutput.Print(&quot;God Mode Enabled&quot;);
-			else
+			} else {
 				logOutput.Print(&quot;God Mode Disabled&quot;);
+			}
+			CPlayer::UpdateControlledTeams();
 		}
 	}
 	else if (action.command == &quot;nocost&quot; &amp;&amp; gs-&gt;cheatEnabled) {
@@ -2400,6 +2432,16 @@
 		GameEnd();
 	}
 
+	// send out new console lines
+	if (infoConsole) {
+		vector&lt;CInfoConsole::RawLine&gt; lines;
+		infoConsole-&gt;GetNewRawLines(lines);
+		for (unsigned int i = 0; i &lt; lines.size(); i++) {
+			const CInfoConsole::RawLine&amp; rawLine = lines[i];
+			luaCallIns.AddConsoleLine(rawLine.text, rawLine.zone);
+		}
+	}
+
 	if (gameServer &amp;&amp; !gameServer-&gt;GameHasStarted() &amp;&amp; !gameSetup) {
 		bool allReady = true;
 		for (int a = 0; a &lt; gs-&gt;activePlayers; a++) {
@@ -2573,10 +2615,6 @@
 
 	LuaUnsyncedCtrl::ClearUnitCommandQueues();
 
-	if (luaUI) {
-		luaUI-&gt;AddConsoleLines();
-	}
-
 	luaCallIns.Update();
 
 	luaCallIns.DrawGenesis();
@@ -2719,20 +2757,14 @@
 		}
 		else {
 			std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
-			if (!inputReceivers.empty()) {
-				std::deque&lt;CInputReceiver*&gt;::reverse_iterator ri;
-				for(ri = inputReceivers.rbegin(); ri != inputReceivers.rend(); ++ri) {
-					CInputReceiver* rcvr = *ri;
-					if (rcvr) {
-						rcvr-&gt;Draw();
-					}
+			std::deque&lt;CInputReceiver*&gt;::reverse_iterator ri;
+			for (ri = inputReceivers.rbegin(); ri != inputReceivers.rend(); ++ri) {
+				CInputReceiver* rcvr = *ri;
+				if (rcvr) {
+					rcvr-&gt;Draw();
 				}
 			}
 		}
-
-		if (!hideInterface) {
-			luaCallIns.DrawScreen();
-		}
 	}
 
 	glEnable(GL_TEXTURE_2D);
@@ -3519,7 +3551,7 @@
 					c.params.push_back(*((float*) &amp;inbuf[11 + a * 4]));
 				}
 
-				selectedUnits.AiOrder(unitid,c);
+				selectedUnits.AiOrder(unitid, c, player);
 				AddTraffic(player, packetCode, dataLength);
 				break;
 			}
@@ -3561,7 +3593,7 @@
 				// apply the commands
 				for (c = 0; c &lt; commandCount; c++) {
 					for (u = 0; u &lt; unitCount; u++) {
-						selectedUnits.AiOrder(unitIDs[u], commands[c]);
+						selectedUnits.AiOrder(unitIDs[u], commands[c], player);
 					}
 				}
 				AddTraffic(player, packetCode, dataLength);
@@ -3722,6 +3754,7 @@
 						} else {
 							gs-&gt;players[player]-&gt;StartSpectating();
 						}
+						CPlayer::UpdateControlledTeams();
 						break;
 					}
 					case TEAMMSG_GIVEAWAY: {
@@ -3732,6 +3765,7 @@
 						} else {
 							gs-&gt;players[player]-&gt;StartSpectating();
 						}
+						CPlayer::UpdateControlledTeams();
 						break;
 					}
 					case TEAMMSG_RESIGN: {
@@ -3745,6 +3779,7 @@
 							gs-&gt;Team(fromTeam)-&gt;leader = -1;
 						}
 						logOutput.Print(&quot;Player %i resigned and is now spectating!&quot;, player);
+						CPlayer::UpdateControlledTeams();
 						break;
 					}
 					case TEAMMSG_JOIN_TEAM: {
@@ -3766,6 +3801,7 @@
 						if (gs-&gt;Team(newTeam)-&gt;leader == -1) {
 							gs-&gt;Team(newTeam)-&gt;leader = player;
 						}
+						CPlayer::UpdateControlledTeams();
 						break;
 					}
 					default: {

Modified: trunk/rts/Game/Game.h
===================================================================
--- trunk/rts/Game/Game.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/Game.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -20,6 +20,7 @@
 class CKeySet;
 class CInfoConsole;
 class LuaParser;
+class LuaInputReceiver;
 class CLoadSaveHandler;
 class Action;
 class ChatMessage;

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/GameHelper.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -121,7 +121,7 @@
 			dist = fudgeRad;
 		}
 		// dist2 = distance from boundary of unit's hitsphere to center of explosion,
-		// unless unit-&gt;isUnderwater and explosion is above water: then it's center to center distance
+		// unless unit-&gt;isUnderWater and explosion is above water: then it's center to center distance
 		float dist2 = dist - unit-&gt;radius;
 		if (unit-&gt;isUnderWater &amp;&amp; (pos.y &gt; -1.0f)) {	//should make it harder to damage subs with above water weapons
 			dist2 += unit-&gt;radius;

Modified: trunk/rts/Game/GameServer.cpp
===================================================================
--- trunk/rts/Game/GameServer.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/GameServer.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -7,7 +7,6 @@
 #include &lt;boost/format.hpp&gt;
 #include &lt;boost/version.hpp&gt;
 #include &lt;SDL_timer.h&gt;
-#include &lt;cmath&gt;
 #if defined DEDICATED || defined DEBUG
 #include &lt;iostream&gt;
 #endif
@@ -791,8 +790,7 @@
 						}
 						break;
 					}
-					case TEAMMSG_TEAM_DIED: {
-									// don't send to clients, they don't need it
+					case TEAMMSG_TEAM_DIED: { // don't send to clients, they don't need it
 						unsigned char team = inbuf[3];
 						if (teams[team] &amp;&amp; players[player]-&gt;isLocal) // currently only host is allowed
 						{
@@ -1207,7 +1205,7 @@
 				hasPlayer = true;
 			}
 		}
-		if (!setup || !setup-&gt;aiDlls[a].empty())
+		if (!setup || !gs-&gt;Team(a)-&gt;dllAI.empty())
 			hasPlayer = true;
 
 		if (!gs-&gt;Team(a)-&gt;isDead &amp;&amp; !gs-&gt;Team(a)-&gt;gaia &amp;&amp; hasPlayer)
@@ -1268,7 +1266,7 @@
 
 		timeLeft += GAME_SPEED * internalSpeed * float(timeElapsed) / 1000.0f;
 		lastTick=currentTick;
-		newFrames = (timeLeft &gt; 0)? int(std::ceil(timeLeft)): 0;
+		newFrames = (timeLeft &gt; 0)? int(ceil(timeLeft)): 0;
 		timeLeft -= newFrames;
 	}
 

Modified: trunk/rts/Game/GameSetup.cpp
===================================================================
--- trunk/rts/Game/GameSetup.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/GameSetup.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -205,8 +205,9 @@
 		sprintf(section, &quot;GAME\\TEAM%i\\&quot;, a);
 		string s(section);
 
-		if (!file.SectionExist(s.substr(0, s.length() - 1)))
+		if (!file.SectionExist(s.substr(0, s.length() - 1))) {
 			continue;
+		}
 
 		// Get default color from palette (based on &quot;color&quot; tag)
 		int colorNum = atoi(file.SGetValueDef(&quot;0&quot;, s + &quot;color&quot;).c_str());
@@ -233,11 +234,12 @@
 		const string aiDll = file.SGetValueDef(&quot;&quot;, s + &quot;aidll&quot;);
 		if (aiDll.substr(0, 6) == &quot;LuaAI:&quot;) {
 			gs-&gt;Team(i)-&gt;luaAI = aiDll.substr(6);
-		} else {
+		}
+		else {
 			if (hostDemo) {
-				aiDlls[i] = &quot;&quot;;
+				gs-&gt;Team(i)-&gt;dllAI = &quot;&quot;;
 			} else {
-				aiDlls[i] = aiDll;
+				gs-&gt;Team(i)-&gt;dllAI = aiDll;
 			}
 		}
 

Modified: trunk/rts/Game/GameSetupData.h
===================================================================
--- trunk/rts/Game/GameSetupData.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/GameSetupData.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -64,8 +64,6 @@
 	
 	std::map&lt;std::string, int&gt; restrictedUnits;
 	
-	std::string aiDlls[MAX_TEAMS];
-	
 	std::map&lt;std::string, std::string&gt; mapOptions;
 	std::map&lt;std::string, std::string&gt; modOptions;
 	

Modified: trunk/rts/Game/Player.cpp
===================================================================
--- trunk/rts/Game/Player.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/Player.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -8,6 +8,7 @@
 #include &quot;UI/MouseHandler.h&quot;
 #include &quot;CameraHandler.h&quot;
 #include &quot;Camera.h&quot;
+#include &quot;Team.h&quot;
 #include &lt;assert.h&gt;
 #endif
 #include &quot;mmgr.h&quot;
@@ -25,6 +26,8 @@
 //				CR_MEMBER(cpuUsage),
 //				CR_MEMBER(ping),
 				CR_MEMBER(currentStats),
+				CR_MEMBER(playerNum),
+//				CR_MEMBER(controlledTeams),
 				CR_RESERVED(32)
 				));
 
@@ -84,24 +87,67 @@
 	delete currentStats;
 }
 
+
+void CPlayer::SetControlledTeams()
+{
+	controlledTeams.clear();
+
+	if (gs-&gt;godMode) {
+		// anyone can control any unit
+		for (int t = 0; t &lt; MAX_TEAMS; t++) {
+			controlledTeams.insert(t);
+		}
+		return;
+	}
+
+	if (spectator) {
+		return; // spectators can't control any units
+	}
+
+	// my team
+	controlledTeams.insert(team);
+
+	// AI teams
+	for (int t = 0; t &lt; MAX_TEAMS; t++) {
+		const CTeam* team = gs-&gt;Team(t);
+		if (team &amp;&amp; team-&gt;isAI &amp;&amp;
+		    !team-&gt;dllAI.empty() &amp;&amp; // luaAI does not require client control
+		    (team-&gt;leader == playerNum)) {
+			controlledTeams.insert(t);
+		}
+	}
+}
+
+
+void CPlayer::UpdateControlledTeams()
+{
+	for (int p = 0; p &lt; MAX_PLAYERS; p++) {
+		CPlayer* player = gs-&gt;players[p];
+		if (player) {
+			player-&gt;SetControlledTeams();
+		}
+	}
+}
+
+
 void CPlayer::StartSpectating()
 {
-	spectator=true;
-	if (gs-&gt;players[gu-&gt;myPlayerNum] == this) //TODO bad hack
-	{
+	spectator = true;
+	if (gs-&gt;players[gu-&gt;myPlayerNum] == this) { //TODO bad hack
 		gu-&gt;spectating           = true;
 		gu-&gt;spectatingFullView   = true;
 		gu-&gt;spectatingFullSelect = true;
 	}
 }
 
+
 #ifdef DIRECT_CONTROL_ALLOWED
 void CPlayer::StopControllingUnit()
 {
 	ENTER_UNSYNCED;
-	if(gu-&gt;directControl==playerControlledUnit){
+	if (gu-&gt;directControl == playerControlledUnit) {
 		assert(gs-&gt;players[gu-&gt;myPlayerNum] == this);
-		gu-&gt;directControl=0;
+		gu-&gt;directControl = 0;
 
 		/* Switch back to the camera we were using before. */
 		camHandler-&gt;PopMode();
@@ -113,6 +159,6 @@
 	}
 	ENTER_SYNCED;
 
-	playerControlledUnit=0;
+	playerControlledUnit = 0;
 }
 #endif

Modified: trunk/rts/Game/Player.h
===================================================================
--- trunk/rts/Game/Player.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/Player.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -5,9 +5,11 @@
 //////////////////////////////////////////////////////////////////////
 
 #include &lt;string&gt;
+#include &lt;set&gt;
 #include &quot;Platform/byteorder.h&quot;
 #include &quot;float3.h&quot;
 
+
 #ifdef DIRECT_CONTROL_ALLOWED
 class CPlayer;
 class CUnit;
@@ -27,6 +29,7 @@
 };
 #endif
 
+
 class CPlayer  
 {
 public:
@@ -35,6 +38,13 @@
 	CPlayer();
 	~CPlayer();
 	
+	std::set&lt;int&gt; controlledTeams;
+	bool CanControlTeam(int teamID) const {
+		return (controlledTeams.find(teamID) != controlledTeams.end());
+	}
+	void SetControlledTeams();
+	static void UpdateControlledTeams(); // SetControlledTeams() for all players
+
 	void StartSpectating();
 
 	bool active;
@@ -42,10 +52,12 @@
 	std::string countryCode;
 	int rank;
 
+	int playerNum;
 	bool spectator;
 	int team;
 	bool readyToStart;
 
+
 	float cpuUsage;
 	int ping;
 

Modified: trunk/rts/Game/PreGame.cpp
===================================================================
--- trunk/rts/Game/PreGame.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/PreGame.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -5,7 +5,6 @@
 #include &lt;SDL_timer.h&gt;
 #include &lt;SDL_types.h&gt;
 #include &lt;set&gt;
-#include &lt;cmath&gt;
 #include &quot;Game.h&quot;
 #include &quot;Team.h&quot;
 #include &quot;FPUCheck.h&quot;
@@ -45,17 +44,19 @@
 
 const int springDefaultPort = 8452;
 
-CPreGame* pregame=0;
+CPreGame* pregame = NULL;
 using netcode::RawPacket;
 
-extern Uint8 *keys;
+extern Uint8* keys;
 extern bool globalQuit;
 std::string stupidGlobalMapname;
 
-CglList* CPreGame::showList = 0;
+CglList* CPreGame::showList = NULL;
 std::string CPreGame::userScript;
 std::string CPreGame::userMap;
+std::string CPreGame::userMod;
 
+
 CPreGame::CPreGame(bool server, const string&amp; demo, const std::string&amp; save)
 : server(server),
   state(UNKNOWN),
@@ -94,7 +95,7 @@
 			StartServer(gameSetup-&gt;mapName, gameSetup-&gt;baseMod, gameSetup-&gt;scriptName);
 			state = WAIT_CONNECTING;
 		} else {
-			ShowMapList();
+			ShowModList();
 			state = WAIT_ON_USERINPUT;
 		}
 	} else {
@@ -111,8 +112,7 @@
 				if (gameSetup) {	// we read a gameSetup from the demofiles
 					logOutput.Print(&quot;Read GameSetup from Demofile&quot;);
 				}
-				else	// we dont read a GameSetup from demofile (this code was copied from CDemoReader)
-				{
+				else { // we dont read a GameSetup from demofile (this code was copied from CDemoReader)
 					logOutput.Print(&quot;Demo file does not contain a setupscript&quot;);
 					// Didn't get a CGameSetup script
 					// FIXME: duplicated in Main.cpp
@@ -147,6 +147,7 @@
 	assert(state != UNKNOWN);
 }
 
+
 CPreGame::~CPreGame()
 {
 	delete gameData;
@@ -154,6 +155,7 @@
 	infoConsole = 0;
 }
 
+
 int CPreGame::KeyPressed(unsigned short k,bool isRepeat)
 {
 	if (k == SDLK_ESCAPE){
@@ -163,12 +165,12 @@
 		} else
 			logOutput.Print(&quot;Use shift-esc to quit&quot;);
 	}
-	if(showList){					//are we currently showing a list?
+	if (showList) { //are we currently showing a list?
 		showList-&gt;KeyPressed(k, isRepeat);
 		return 0;
 	}
 
-	if (userWriting){
+	if (userWriting) {
 		keys[k] = true;
 		if (k == SDLK_v &amp;&amp; keys[SDLK_LCTRL]){
 			CClipboard clipboard;
@@ -184,26 +186,26 @@
 			}
 			return 0;
 		}
-		if(k == SDLK_DELETE){
+		if (k == SDLK_DELETE) {
 			if (!userInput.empty() &amp;&amp; (writingPos &lt; (int)userInput.size())) {
 				userInput.erase(writingPos, 1);
 			}
 			return 0;
 		}
-		else if(k==SDLK_LEFT) {
+		else if (k == SDLK_LEFT) {
 			writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
 		}
-		else if(k==SDLK_RIGHT) {
+		else if (k == SDLK_RIGHT) {
 			writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
 		}
-		else if(k==SDLK_HOME) {
+		else if (k == SDLK_HOME) {
 			writingPos = 0;
 		}
-		else if(k==SDLK_END) {
+		else if (k == SDLK_END) {
 			writingPos = (int)userInput.length();
 		}
-		if(k == SDLK_RETURN){
-			userWriting=false;
+		if (k == SDLK_RETURN){
+			userWriting = false;
 			return 0;
 		}
 		return 0;
@@ -212,6 +214,7 @@
 	return 0;
 }
 
+
 bool CPreGame::Draw()
 {
 	SDL_Delay(10); // milliseconds
@@ -219,7 +222,10 @@
 		return true;
 	}
 
-	if (!showList) {
+	if (showList) {
+		PrintLoadMsg(&quot;&quot;, false); // just clear screen and set up matrices etc.
+	}
+	else {
 		switch (state) {
 			case WAIT_ON_GAMEDATA:
 				PrintLoadMsg(&quot;Waiting on game data&quot;, false);
@@ -238,13 +244,11 @@
 				PrintLoadMsg(&quot;&quot;, false); // just clear screen and set up matrices etc.
 				break;
 		}
-	} else {
-		PrintLoadMsg(&quot;&quot;, false); // just clear screen and set up matrices etc.
 	}
 
 	infoConsole-&gt;Draw();
 
-	if(userWriting){
+	if (userWriting) {
 		const std::string tempstring = userPrompt + userInput;
 
 		const float xStart = 0.10f;
@@ -261,7 +265,7 @@
 		const float cw = fontScale * font-&gt;CalcCharWidth(c);
 		const float csx = xStart + (fontScale * caretWidth);
 		glDisable(GL_TEXTURE_2D);
-		const float f = 0.5f * (1.0f + std::sin((float)SDL_GetTicks() * 0.015f));
+		const float f = 0.5f * (1.0f + sin((float)SDL_GetTicks() * 0.015f));
 		glColor4f(f, f, f, 0.75f);
 		glRectf(csx, yStart, csx + cw, yStart + fontScale * font-&gt;GetHeight());
 		glEnable(GL_TEXTURE_2D);
@@ -277,6 +281,7 @@
 	return true;
 }
 
+
 bool CPreGame::Update()
 {
 	good_fpu_control_registers(&quot;CPreGame::Update&quot;);
@@ -319,8 +324,9 @@
 			const int teamID = gs-&gt;players[gu-&gt;myPlayerNum]-&gt;team;
 			const CTeam* team = gs-&gt;Team(teamID);
 			assert(team);
-			if (net-&gt;localDemoPlayback)
+			if (net-&gt;localDemoPlayback) {
 				gs-&gt;players[gu-&gt;myPlayerNum]-&gt;StartSpectating();
+			}
 			LoadStartPicture(team-&gt;side);
 
 			game = SAFE_NEW CGame(gameData-&gt;GetMap(), modArchive, infoConsole, savefile);
@@ -349,6 +355,7 @@
 	return true;
 }
 
+
 void CPreGame::StartServer(std::string map, std::string mod, std::string script)
 {
 	assert(!gameServer);
@@ -425,6 +432,7 @@
 	good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 }
 
+
 void CPreGame::UpdateClientNet()
 {
 	if (gameData)
@@ -460,6 +468,7 @@
 	}
 }
 
+
 void CPreGame::ReadDataFromDemo(const std::string&amp; demoName)
 {
 	logOutput.Print(&quot;Pre-scanning demo file for game data...&quot;);
@@ -488,6 +497,7 @@
 	}
 }
 
+
 /** Create a CglList for selecting the map. */
 void CPreGame::ShowMapList()
 {
@@ -515,6 +525,7 @@
 	showList = list;
 }
 
+
 /** Create a CglList for selecting the script. */
 void CPreGame::ShowScriptList()
 {
@@ -522,6 +533,7 @@
 	showList = list;
 }
 
+
 /** Create a CglList for selecting the mod. */
 void CPreGame::ShowModList()
 {
@@ -545,37 +557,47 @@
 	showList = list;
 }
 
+
 void CPreGame::SelectMap(std::string s)
 {
+	delete showList;
+	showList = NULL;
+
 	if (s == &quot;Random map&quot;) {
 		s = pregame-&gt;showList-&gt;items[1 + gu-&gt;usRandInt() % (showList-&gt;items.size() - 1)];
 	}
-	delete showList;
-	showList = 0;
+
 	userMap = s;
-	pregame-&gt;ShowScriptList();
+	pregame-&gt;StartServer(userMap, userMod, userScript);
+	pregame-&gt;state = WAIT_CONNECTING;
 }
 
+
 void CPreGame::SelectScript(std::string s)
 {
 	delete showList;
-	showList = 0;
+	showList = NULL;
+
 	userScript = s;
-	pregame-&gt;ShowModList();
+	pregame-&gt;ShowMapList();
 }
 
+
 void CPreGame::SelectMod(std::string s)
 {
+	delete showList;
+	showList = NULL;
+
 	if (s == &quot;Random mod&quot;) {
 		const int index = 1 + (gu-&gt;usRandInt() % (showList-&gt;items.size() - 1));
 		s = showList-&gt;items[index];
 	}
-	delete showList;
-	showList = 0;
-	pregame-&gt;StartServer(userMap, s, userScript);
-	pregame-&gt;state = WAIT_CONNECTING;
+
+	userMod = s;
+	pregame-&gt;ShowScriptList();
 }
 
+
 void CPreGame::LoadMap(const std::string&amp; mapName, const bool forceReload)
 {
 	static bool alreadyLoaded = false;
@@ -599,6 +621,7 @@
 	}
 }
 
+
 void CPreGame::LoadMod(const std::string&amp; modName)
 {
 	static bool alreadyLoaded = false;
@@ -620,6 +643,7 @@
 	}
 }
 
+
 void CPreGame::GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet)
 {
 	gameData = new GameData(packet);
@@ -628,8 +652,9 @@
 	logOutput &lt;&lt; &quot;Using map &quot; &lt;&lt; gameData-&gt;GetMap() &lt;&lt; &quot;\n&quot;;
 	stupidGlobalMapname = gameData-&gt;GetMap();
 	
-	if (net &amp;&amp; net-&gt;GetDemoRecorder())
+	if (net &amp;&amp; net-&gt;GetDemoRecorder()) {
 		net-&gt;GetDemoRecorder()-&gt;SetName(gameData-&gt;GetMap());
+	}
 	LoadMap(gameData-&gt;GetMap());
 	archiveScanner-&gt;CheckMap(gameData-&gt;GetMap(), gameData-&gt;GetMapChecksum());
 
@@ -641,8 +666,7 @@
 	modArchive = archiveScanner-&gt;ModNameToModArchive(gameData-&gt;GetMod());
 	archiveScanner-&gt;CheckMod(modArchive, gameData-&gt;GetModChecksum());
 	
-	if (gameSetup)
-	{
+	if (gameSetup) {
 		gameSetup-&gt;scriptName = gameData-&gt;GetScript();
 		gameSetup-&gt;mapName = gameData-&gt;GetMap();
 		gameSetup-&gt;baseMod = gameData-&gt;GetMod();

Modified: trunk/rts/Game/PreGame.h
===================================================================
--- trunk/rts/Game/PreGame.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/PreGame.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -59,7 +59,10 @@
 	static void SelectScript(std::string s);
 	static void SelectMap(std::string s);
 	static void SelectMod(std::string s);
-	static std::string userScript, userMap;
+	static std::string userScript;
+	static std::string userMap;
+	static std::string userMod;
+
 	/// Load map and dependend archives into archive scanner
 	static void LoadMap(const std::string&amp; mapName, const bool forceReload = false);
 	

Modified: trunk/rts/Game/SelectedUnits.cpp
===================================================================
--- trunk/rts/Game/SelectedUnits.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/SelectedUnits.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -45,12 +45,13 @@
 //////////////////////////////////////////////////////////////////////
 CSelectedUnits selectedUnits;
 
+
 CSelectedUnits::CSelectedUnits()
 : selectionChanged(false),
 	possibleCommandsChanged(true),
-	selectedGroup(-1)
+	selectedGroup(-1),
+	buildIconsFirst(false)
 {
-	buildIconsFirst = !!configHandler.GetInt(&quot;BuildIconsFirst&quot;, 0);
 }
 
 
@@ -59,6 +60,12 @@
 }
 
 
+void CSelectedUnits::Init()
+{
+	buildIconsFirst = !!configHandler.GetInt(&quot;BuildIconsFirst&quot;, 0);
+}
+
+
 void CSelectedUnits::ToggleBuildIconsFirst()
 {
 	buildIconsFirst = !buildIconsFirst;
@@ -427,28 +434,25 @@
 	if (cmdColors.unitBox[3] &gt; 0.0f) {
 		glColor4fv(cmdColors.unitBox);
 
+		const CUnitSet* unitSet;
+		if (selectedGroup != -1) {
+			unitSet = &amp;grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;units;
+		} else {
+			unitSet = &selectedUnits;
+		}
+
 		glBegin(GL_QUADS);
-		CUnitSet::iterator ui;
-		if(selectedGroup!=-1){
-			for(ui=grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;units.begin();ui!=grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;units.end();++ui){
-				if((*ui)-&gt;isIcon)
-					continue;
-				float3 pos((*ui)-&gt;pos+(*ui)-&gt;speed*gu-&gt;timeOffset);
-				glVertexf3(pos+float3((*ui)-&gt;xsize*4,0,(*ui)-&gt;ysize*4));
-				glVertexf3(pos+float3(-(*ui)-&gt;xsize*4,0,(*ui)-&gt;ysize*4));
-				glVertexf3(pos+float3(-(*ui)-&gt;xsize*4,0,-(*ui)-&gt;ysize*4));
-				glVertexf3(pos+float3((*ui)-&gt;xsize*4,0,-(*ui)-&gt;ysize*4));
+		CUnitSet::const_iterator ui;
+		for (ui = unitSet-&gt;begin(); ui != unitSet-&gt;end(); ++ui) {
+			const CUnit* unit = *ui;
+			if (unit-&gt;isIcon) {
+				continue;
 			}
-		} else {
-			for(ui=selectedUnits.begin();ui!=selectedUnits.end();++ui){
-				if((*ui)-&gt;isIcon)
-					continue;
-				float3 pos((*ui)-&gt;pos+(*ui)-&gt;speed*gu-&gt;timeOffset);
-				glVertexf3(pos+float3((*ui)-&gt;xsize*4,0,(*ui)-&gt;ysize*4));
-				glVertexf3(pos+float3(-(*ui)-&gt;xsize*4,0,(*ui)-&gt;ysize*4));
-				glVertexf3(pos+float3(-(*ui)-&gt;xsize*4,0,-(*ui)-&gt;ysize*4));
-				glVertexf3(pos+float3((*ui)-&gt;xsize*4,0,-(*ui)-&gt;ysize*4));
-			}
+			const float3 pos(unit-&gt;pos + unit-&gt;speed * gu-&gt;timeOffset);
+			glVertexf3(pos + float3( unit-&gt;xsize * 4, 0,  unit-&gt;ysize * 4));
+			glVertexf3(pos + float3(-unit-&gt;xsize * 4, 0,  unit-&gt;ysize * 4));
+			glVertexf3(pos + float3(-unit-&gt;xsize * 4, 0, -unit-&gt;ysize * 4));
+			glVertexf3(pos + float3( unit-&gt;xsize * 4, 0, -unit-&gt;ysize * 4));
 		}
 		glEnd();
 	}
@@ -505,15 +509,37 @@
 }
 
 
-void CSelectedUnits::NetOrder(Command &amp;c, int player)
+void CSelectedUnits::NetOrder(Command &amp;c, int playerID)
 {
-	selectedUnitsAI.GiveCommandNet(c,player);
+	selectedUnitsAI.GiveCommandNet(c, playerID);
 
-	if (netSelected[player].size() &gt; 0)
-		globalAI-&gt;PlayerCommandGiven(netSelected[player],c,player);
+	if (netSelected[playerID].size() &gt; 0) {
+		globalAI-&gt;PlayerCommandGiven(netSelected[playerID], c, playerID);
+	}
 }
 
 
+void CSelectedUnits::AiOrder(int unitid, const Command &amp;c, int playerID)
+{
+	CUnit* unit = uh-&gt;units[unitid];
+	if (unit == NULL) {
+		return;
+	}
+
+	const CPlayer* player = gs-&gt;players[playerID];
+	if (player == NULL) {
+		return;
+	}
+	if (!player-&gt;CanControlTeam(unit-&gt;team)) {
+		logOutput.Print(&quot;Invalid order from player %i for (unit %i, team %i)&quot;,
+		                playerID, unitid, unit-&gt;team);
+		return;
+	}
+	
+	unit-&gt;commandAI-&gt;GiveCommand(c, false);
+}
+
+
 bool CSelectedUnits::CommandsChanged()
 {
 	return possibleCommandsChanged;
@@ -623,13 +649,6 @@
 
 /******************************************************************************/
 
-void CSelectedUnits::AiOrder(int unitid, Command &amp;c)
-{
-	if(uh-&gt;units[unitid]!=0)
-		uh-&gt;units[unitid]-&gt;commandAI-&gt;GiveCommand(c,false);
-}
-
-
 void CSelectedUnits::PossibleCommandChange(CUnit* sender)
 {
 	if (sender == NULL || selectedUnits.find(sender) != selectedUnits.end())
@@ -787,7 +806,8 @@
 }
 
 
-void CSelectedUnits::SendCommandsToUnits(const vector&lt;int&gt;&amp; unitIDs, const vector&lt;Command&gt;&amp; commands)
+void CSelectedUnits::SendCommandsToUnits(const vector&lt;int&gt;&amp; unitIDs,
+                                         const vector&lt;Command&gt;&amp; commands)
 {
 	// NOTE: does not check for invalid unitIDs
 
@@ -820,7 +840,9 @@
 		return; // drop the oversized packet
 	}
 	netcode::PackPacket* packet = new netcode::PackPacket(msgLen);
-	*packet &lt;&lt; static_cast&lt;unsigned char&gt;(NETMSG_AICOMMANDS) &lt;&lt; static_cast&lt;unsigned short&gt;(msgLen) &lt;&lt; static_cast&lt;unsigned char&gt;(gu-&gt;myPlayerNum);
+	*packet &lt;&lt; static_cast&lt;unsigned char&gt;(NETMSG_AICOMMANDS)
+	        &lt;&lt; static_cast&lt;unsigned short&gt;(msgLen)
+	        &lt;&lt; static_cast&lt;unsigned char&gt;(gu-&gt;myPlayerNum);
 	
 	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(unitIDCount);
 	for (std::vector&lt;int&gt;::const_iterator it = unitIDs.begin(); it != unitIDs.end(); ++it)
@@ -831,7 +853,9 @@
 	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(commandCount);
 	for (unsigned i = 0; i &lt; commandCount; ++i) {
 		const Command&amp; cmd = commands[i];
-		*packet &lt;&lt; static_cast&lt;unsigned int&gt;(cmd.id) &lt;&lt; cmd.options &lt;&lt; static_cast&lt;unsigned short&gt;(cmd.params.size()) &lt;&lt; cmd.params;
+		*packet &lt;&lt; static_cast&lt;unsigned int&gt;(cmd.id)
+		        &lt;&lt; cmd.options
+		        &lt;&lt; static_cast&lt;unsigned short&gt;(cmd.params.size()) &lt;&lt; cmd.params;
 	}
 
 	net-&gt;Send(boost::shared_ptr&lt;netcode::RawPacket&gt;(packet));

Modified: trunk/rts/Game/SelectedUnits.h
===================================================================
--- trunk/rts/Game/SelectedUnits.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/SelectedUnits.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -14,8 +14,9 @@
 class CSelectedUnits : public CObject
 {
 public:
+	void Init();
 	void SelectGroup(int num);
-	void AiOrder(int unitid,Command&amp; c);
+	void AiOrder(int unitid, const Command&amp; c, int playerID);
 	void SendOrdersToUnits(const vector&lt;int&gt;&amp; unitIDs,
 	                       const vector&lt;Command&gt;&amp; commands);
 	int GetDefaultCmd(CUnit* unit,CFeature* feature);

Modified: trunk/rts/Game/SelectedUnitsAI.cpp
===================================================================
--- trunk/rts/Game/SelectedUnitsAI.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/SelectedUnitsAI.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -109,7 +109,7 @@
 }
 
 
-void CSelectedUnitsAI::GiveCommandNet(Command &amp;c,int player)
+void CSelectedUnitsAI::GiveCommandNet(Command &amp;c, int player)
 {
 	const vector&lt;int&gt;&amp; netSelected = selectedUnits.netSelected[player];
 	vector&lt;int&gt;::const_iterator ui;

Modified: trunk/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/CommanderScript.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/StartScripts/CommanderScript.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -12,6 +12,7 @@
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
@@ -37,26 +38,6 @@
 void CCommanderScript::GameStart()
 {
 	if (gameSetup) {
-		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-		if (!luaParser.Execute()) {
-			logOutput.Print(luaParser.GetErrorLog());
-		}
-
-		const LuaTable sideData = luaParser.GetRoot();
-
-		// make a map of all side names  (assumes contiguous sections)
-		std::map&lt;std::string, std::string&gt; sideMap;
-		for (int i = 1; true; i++) {
-			const LuaTable side = sideData.SubTable(i);
-			if (!side.IsValid()) {
-				break;
-			}
-			const std::string sideName  = side.GetString(&quot;name&quot;, &quot;unknown&quot;);
-			const std::string startUnit = side.GetString(&quot;startUnit&quot;, &quot;&quot;);
-			sideMap[StringToLower(sideName)] = StringToLower(startUnit);
-		}
-
 		// setup the teams
 		for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
 
@@ -74,49 +55,35 @@
 			team-&gt;energyStorage = 20;
 
 			// create a GlobalAI if required
-			if (!gameSetup-&gt;aiDlls[a].empty() &amp;&amp;
-			    (gu-&gt;myPlayerNum == team-&gt;leader)) {
-				globalAI-&gt;CreateGlobalAI(a, gameSetup-&gt;aiDlls[a].c_str());
+			if (!team-&gt;dllAI.empty() &amp;&amp; (gu-&gt;myPlayerNum == team-&gt;leader)) {
+				globalAI-&gt;CreateGlobalAI(a, team-&gt;dllAI.c_str());
 			}
 
-			std::map&lt;std::string, std::string&gt;::const_iterator it =
-				sideMap.find(team-&gt;side);
+			// get the team startup info
+			const std::string&amp; side = team-&gt;side;
+			const std::string&amp; startUnit = sideParser.GetStartUnit(side);
+			if (startUnit.empty()) {
+				throw content_error( &quot;Unable to load a commander for side: &quot; + side);
+			}
 
-			if (it != sideMap.end()) {
-				const std::string&amp; sideName  = it-&gt;first;
-				const std::string&amp; startUnit = it-&gt;second;
-				if (startUnit.length() == 0) {
-					throw content_error(
-						&quot;Unable to load a commander for side: &quot; + sideName
-					);
-				}
-				CUnit* unit = unitLoader.LoadUnit(startUnit,
-				                                  team-&gt;startPos, a, false, 0, NULL);
+			CUnit* unit =
+				unitLoader.LoadUnit(startUnit, team-&gt;startPos, a, false, 0, NULL);
 
-				team-&gt;lineageRoot = unit-&gt;id;
+			team-&gt;lineageRoot = unit-&gt;id;
 
-				// FIXME this shouldn't be here, but no better place exists currently
-				if (a == gu-&gt;myTeam) {
-					minimap-&gt;AddNotification(team-&gt;startPos,
-					                         float3(1.0f, 1.0f, 1.0f), 1.0f);
-					game-&gt;infoConsole-&gt;SetLastMsgPos(team-&gt;startPos);
-				}
+			// FIXME this shouldn't be here, but no better place exists currently
+			if (a == gu-&gt;myTeam) {
+				minimap-&gt;AddNotification(team-&gt;startPos,
+																 float3(1.0f, 1.0f, 1.0f), 1.0f);
+				game-&gt;infoConsole-&gt;SetLastMsgPos(team-&gt;startPos);
 			}
 		}
 	}
 	else {
-		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-		if (!luaParser.Execute()) {
-			logOutput.Print(luaParser.GetErrorLog());
-		}
-		const LuaTable sideData = luaParser.GetRoot();
-		const LuaTable side1 = sideData.SubTable(1);
-		const LuaTable side2 = sideData.SubTable(2);
-		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
-		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+		const std::string startUnit0 = sideParser.GetStartUnit(0, &quot;&quot;);
+		const std::string startUnit1 = sideParser.GetStartUnit(1, startUnit0);
 
-		if (su1.length() == 0) {
+		if (startUnit0.length() == 0) {
 			throw content_error(&quot;Unable to load a startUnit for the first side&quot;);
 		}
 		
@@ -129,8 +96,8 @@
 		mapParser.GetStartPos(0, startPos0);
 		mapParser.GetStartPos(1, startPos1);
 
-		unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
-		unitLoader.LoadUnit(su2, startPos1, 1, false, 0, NULL);
+		unitLoader.LoadUnit(startUnit0, startPos0, 0, false, 0, NULL);
+		unitLoader.LoadUnit(startUnit1, startPos1, 1, false, 0, NULL);
 
 		// FIXME this shouldn't be here, but no better place exists currently
 		minimap-&gt;AddNotification(startPos0, float3(1.0f, 1.0f, 1.0f), 1.0f);

Modified: trunk/rts/Game/StartScripts/CommanderScript2.cpp
===================================================================
--- trunk/rts/Game/StartScripts/CommanderScript2.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/StartScripts/CommanderScript2.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -4,6 +4,7 @@
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
@@ -39,18 +40,10 @@
 	gs-&gt;Team(1)-&gt;metalIncome=1000;
 	gs-&gt;Team(1)-&gt;metalStorage=1000;
 
-	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-						SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-	if (!luaParser.Execute()) {
-		logOutput.Print(luaParser.GetErrorLog());
-	}
-	const LuaTable sideData = luaParser.GetRoot();
-	const LuaTable side1 = sideData.SubTable(1);
-	const LuaTable side2 = sideData.SubTable(2);
-	const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
-	const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+	const std::string startUnit0 = sideParser.GetStartUnit(0, &quot;&quot;);
+	const std::string startUnit1 = sideParser.GetStartUnit(1, startUnit0);
 
-	if (su1.length() == 0) {
+	if (startUnit0.length() == 0) {
 		throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
 	}
 
@@ -63,7 +56,7 @@
 	mapParser.GetStartPos(0, startPos0);
 	mapParser.GetStartPos(1, startPos1);
 
-	unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
-	unitLoader.LoadUnit(su2, startPos1, 1, false, 0, NULL);
+	unitLoader.LoadUnit(startUnit0, startPos0, 0, false, 0, NULL);
+	unitLoader.LoadUnit(startUnit1, startPos1, 1, false, 0, NULL);
 }
 

Modified: trunk/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -7,6 +7,7 @@
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;System/LogOutput.h&quot;
@@ -44,19 +45,11 @@
 	gs-&gt;Team(1)-&gt;metal         = 1000;
 	gs-&gt;Team(1)-&gt;metalStorage  = 1000;
 
-	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-											SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-	if (!luaParser.Execute()) {
-		logOutput.Print(luaParser.GetErrorLog());
-	}
-	const LuaTable sideData = luaParser.GetRoot();
-	const LuaTable side1 = sideData.SubTable(1);
-	const LuaTable side2 = sideData.SubTable(2);
-	const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
-	const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+	const std::string startUnit0 = sideParser.GetStartUnit(0, &quot;&quot;);
+	const std::string startUnit1 = sideParser.GetStartUnit(1, startUnit0);
 	// default to side 1, in case mod has only 1 side
 
-	if (su1.length() == 0) {
+	if (startUnit0.length() == 0) {
 		throw content_error (&quot;Unable to load a commander for the first side&quot;);
 	}
 
@@ -69,6 +62,6 @@
 	mapParser.GetStartPos(0, startPos0);
 	mapParser.GetStartPos(1, startPos1);
 
-	unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
-	unitLoader.LoadUnit(su2, startPos1, 1, false, 0, NULL);
+	unitLoader.LoadUnit(startUnit0, startPos0, 0, false, 0, NULL);
+	unitLoader.LoadUnit(startUnit1, startPos1, 1, false, 0, NULL);
 }

Modified: trunk/rts/Game/StartScripts/SpawnScript.cpp
===================================================================
--- trunk/rts/Game/StartScripts/SpawnScript.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/StartScripts/SpawnScript.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -6,6 +6,7 @@
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
@@ -34,18 +35,9 @@
 	case 0:
 		LoadSpawns();
 
-		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-		if (!luaParser.Execute()) {
-			logOutput.Print(luaParser.GetErrorLog());
-		}
-		const LuaTable sideData = luaParser.GetRoot();
-		const LuaTable side1 = sideData.SubTable(1);
-		const LuaTable side2 = sideData.SubTable(2);
-		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
-		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+		const std::string startUnit0 = sideParser.GetStartUnit(0);
 
-		if (su1.length() == 0) {
+		if (startUnit0.length() == 0) {
 			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
 		}
 
@@ -61,7 +53,7 @@
 		if (autonomous) {
 			spawnPos.push_back(startPos0);
 		} else {
-			unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
+			unitLoader.LoadUnit(startUnit0, startPos0, 0, false, 0, NULL);
 		}
 
 		// load the start positions for teams 1 - 3

Modified: trunk/rts/Game/Team.cpp
===================================================================
--- trunk/rts/Game/Team.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/Team.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -33,7 +33,9 @@
 				CR_MEMBER(lineageRoot),
 				CR_MEMBER(handicap),
 				CR_MEMBER(side),
+				CR_MEMBER(isAI),
 				CR_MEMBER(luaAI),
+				CR_MEMBER(dllAI),
 				CR_MEMBER(units),
 				CR_MEMBER(startPos),
 				CR_MEMBER(metal),
@@ -125,7 +127,9 @@
   energySent(0),
   energyReceived(0),
   side(&quot;arm&quot;),
+  isAI(false),
   luaAI(&quot;&quot;),
+  dllAI(&quot;&quot;),
   startPos(100,100,100),
   handicap(1),
   leader(-1),
@@ -138,90 +142,98 @@
 	statHistory.push_back(currentStats);
 }
 
+
 CTeam::~CTeam()
 {
-
 }
 
+
 bool CTeam::UseMetal(float amount)
 {
-	if(metal-prevMetalUpkeep*10&gt;=amount){
-		metal-=amount;
-		metalExpense+=amount;
+	if ((metal - (prevMetalUpkeep * 10)) &gt;= amount) {
+		metal -= amount;
+		metalExpense += amount;
 		return true;
 	}
 	return false;
 }
 
+
 bool CTeam::UseEnergy(float amount)
 {
-	if(energy-prevEnergyUpkeep*10&gt;=amount){
-		energy-=amount;
-		energyExpense+=amount;
+	if ((energy - (prevEnergyUpkeep * 10)) &gt;= amount) {
+		energy -= amount;
+		energyExpense += amount;
 		return true;
 	}
 	return false;
 }
 
+
 bool CTeam::UseMetalUpkeep(float amount)
 {
-	if(metal&gt;=amount){
-		metal-=amount;
-		metalExpense+=amount;
-		metalUpkeep+=amount;
+	if (metal &gt;= amount) {
+		metal -= amount;
+		metalExpense += amount;
+		metalUpkeep += amount;
 		return true;
 	}
 	return false;
 }
 
+
 bool CTeam::UseEnergyUpkeep(float amount)
 {
-	if(energy&gt;=amount){
-		energy-=amount;
-		energyExpense+=amount;
-		energyUpkeep+=amount;
+	if (energy &gt;= amount) {
+		energy -= amount;
+		energyExpense += amount;
+		energyUpkeep += amount;
 		return true;
 	}
 	return false;
 }
 
+
 void CTeam::AddMetal(float amount)
 {
-	amount*=handicap;
-	metal+=amount;
-	metalIncome+=amount;
-	if(metal&gt;metalStorage){
+	amount *= handicap;
+	metal += amount;
+	metalIncome += amount;
+	if (metal &gt; metalStorage) {
 		delayedMetalShare += metal - metalStorage;
-		metal=metalStorage;
+		metal = metalStorage;
 	}
 }
 
+
 void CTeam::AddEnergy(float amount)
 {
-	amount*=handicap;
-	energy+=amount;
-	energyIncome+=amount;
-	if(energy&gt;energyStorage){
+	amount *= handicap;
+	energy += amount;
+	energyIncome += amount;
+	if (energy &gt; energyStorage) {
 		delayedEnergyShare += energy - energyStorage;
-		energy=energyStorage;
+		energy = energyStorage;
 	}
 }
 
+
 void CTeam::SelfDestruct()
 {
-	for(CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui) {
-		if ((*ui) != NULL &amp;&amp; (*ui)-&gt;unitDef-&gt;canSelfD) {
-			if ((*ui)-&gt;beingBuilt) {
-				(*ui)-&gt;KillUnit(false, true, NULL); // kill units under construction without explosion
+	for (CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui) {
+		CUnit* unit = (*ui);
+		if (unit != NULL &amp;&amp; unit-&gt;unitDef-&gt;canSelfD) {
+			if (unit-&gt;beingBuilt) {
+				unit-&gt;KillUnit(false, true, NULL); // kill units under construction without explosion
+			} else {
+				unit-&gt;KillUnit(true, false, NULL);
 			}
-			else {
-				(*ui)-&gt;KillUnit(true, false, NULL);
-			}
 		}
 	}
 	Died();
 }
 
+
 void CTeam::GiveEverythingTo(const unsigned toTeam)
 {
 	CTeam* target = gs-&gt;Team(toTeam);
@@ -248,6 +260,7 @@
 	Died();
 }
 
+
 void CTeam::Died()
 {
 	if (leader &gt;= 0) {
@@ -257,20 +270,26 @@
 		logOutput.Print(CMessages::Tr(&quot;Team%i is no more&quot;).c_str(), teamNum);
 	}
 	isDead = true;
-	luaCallIns.TeamDied(teamNum);
+
+	// this message is not relayed to clients, it's only for the server
 	net-&gt;Send(CBaseNetProtocol::Get().SendTeamDied(gu-&gt;myPlayerNum, teamNum));
+
 	for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
-		if (gs-&gt;players[a]-&gt;active &amp;&amp; gs-&gt;players[a]-&gt;team == teamNum) {
+		if (gs-&gt;players[a]-&gt;active &amp;&amp; (gs-&gt;players[a]-&gt;team == teamNum)) {
 			gs-&gt;players[a]-&gt;StartSpectating();
 		}
 	}
 	if (globalAI-&gt;ais[teamNum]) {
 		delete globalAI-&gt;ais[teamNum];
-		globalAI-&gt;ais[teamNum] = 0;
+		globalAI-&gt;ais[teamNum] = NULL;
 	}
+
 	CLuaUI::UpdateTeams();
+  CPlayer::UpdateControlledTeams();
+	luaCallIns.TeamDied(teamNum);
 }
 
+
 void CTeam::SlowUpdate()
 {
 	currentStats.metalProduced  += metalIncome;
@@ -376,6 +395,7 @@
 	}
 }
 
+
 void CTeam::AddUnit(CUnit* unit,AddType type)
 {
 	units.insert(unit);
@@ -398,6 +418,7 @@
 	}
 }
 
+
 void CTeam::RemoveUnit(CUnit* unit,RemoveType type)
 {
 	units.erase(unit);
@@ -421,12 +442,14 @@
 	}
 }
 
+
 void CTeam::CommanderDied(CUnit* commander)
 {
 	assert(commander-&gt;unitDef-&gt;isCommander);
 	--numCommanders;
 }
 
+
 void CTeam::LeftLineage(CUnit* unit)
 {
 	if (gs-&gt;gameMode == 2 &amp;&amp; unit-&gt;id == this-&gt;lineageRoot) {

Modified: trunk/rts/Game/Team.h
===================================================================
--- trunk/rts/Game/Team.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/Team.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -59,7 +59,10 @@
 
 	float handicap;
 	std::string side;
+
+	bool isAI;
 	std::string luaAI;
+	std::string dllAI;
 
 	// color info is unsynced
 	unsigned char color[4];

Modified: trunk/rts/Game/UI/EndGameBox.cpp
===================================================================
--- trunk/rts/Game/UI/EndGameBox.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/EndGameBox.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -19,16 +19,16 @@
 static string FloatToSmallString(float num,float mul=1){
 	char c[50];
 
-	if(num==0)
+	if (num == 0) {
 		return &quot;0&quot;;
-	if(std::fabs(num)&lt;10*mul){
+	} else if (fabs(num) &lt; 10 * mul) {
 		sprintf(c,&quot;%.1f&quot;,num);
-	} else if(std::fabs(num)&lt;10000*mul){
+	} else if (fabs(num) &lt; 10000 * mul) {
 		sprintf(c,&quot;%.0f&quot;,num);
-	} else if(std::fabs(num)&lt;10000000*mul){
-		sprintf(c,&quot;%.0fk&quot;,num/1000);
+	} else if (fabs(num) &lt; 10000000 * mul) {
+		sprintf(c,&quot;%.0fk&quot;, num / 1000);
 	} else {
-		sprintf(c,&quot;%.0fM&quot;,num/1000000);
+		sprintf(c,&quot;%.0fM&quot;, num / 1000000);
 	}
 	return c;
 };
@@ -145,7 +145,7 @@
 
 	if(dispMode&gt;0){
 		if(mx&gt;box.x1+0.01f &amp;&amp; mx&lt;box.x1+0.12f &amp;&amp; my&lt;box.y1+0.57f &amp;&amp; my&gt;box.y1+0.571f-stats.size()*0.02f){
-			int sel=(int)std::floor(-(my-box.y1-0.57f)*50);
+			int sel=(int)floor(-(my-box.y1-0.57f)*50);
 
 			if(button==1) {
 				stat1=sel;
@@ -277,7 +277,7 @@
 
 		if(mx&gt;box.x1+0.01f &amp;&amp; mx&lt;box.x1+0.12f &amp;&amp; my&lt;box.y1+0.57f &amp;&amp; my&gt;box.y1+0.571f-stats.size()*0.02f){
 
-			int sel=(int)std::floor(-(my-box.y1-0.57f)*50);
+			int sel=(int)floor(-(my-box.y1-0.57f)*50);
 
 			glColor4f(0.7f,0.2f,0.2f,guiAlpha);
 			glDisable(GL_TEXTURE_2D);

Modified: trunk/rts/Game/UI/EndGameBox.h
===================================================================
--- trunk/rts/Game/UI/EndGameBox.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/EndGameBox.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -5,7 +5,6 @@
 #include &lt;list&gt;
 #include &lt;vector&gt;
 #include &quot;Rendering/GL/myGL.h&quot;
-#include &lt;cmath&gt;
 
 
 // msvc behaves really strange
@@ -58,8 +57,8 @@
 		void AddStat(int team,float value){
 			if(value&gt;max)
 				max=value;
-			if(values[team].size()&gt;0 &amp;&amp; std::fabs(value-values[team].back())&gt;maxdif)
-				maxdif=std::fabs(value-values[team].back());
+			if(values[team].size()&gt;0 &amp;&amp; fabs(value-values[team].back())&gt;maxdif)
+				maxdif = fabs(value-values[team].back());
 
 			values[team].push_back(value);
 		}

Modified: trunk/rts/Game/UI/GameSetupDrawer.cpp
===================================================================
--- trunk/rts/Game/UI/GameSetupDrawer.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/GameSetupDrawer.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -12,7 +12,7 @@
 #include &quot;../Player.h&quot;
 #include &quot;../GameSetup.h&quot;
 #include &quot;StartPosSelecter.h&quot;
-#include &quot;LuaUI.h&quot;
+#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 
 extern Uint8 *keys;
@@ -107,7 +107,7 @@
 
 	CStartPosSelecter* selector = CStartPosSelecter::selector;
 	bool ready = (selector == NULL);
-	if (luaUI &amp;&amp; luaUI-&gt;GameSetup(state, ready, playerStates)) {
+	if (luaCallIns.GameSetup(state, ready, playerStates)) {
 		if (selector) {
 			selector-&gt;ShowReady(false);
 			if (ready) {

Modified: trunk/rts/Game/UI/GuiHandler.cpp
===================================================================
--- trunk/rts/Game/UI/GuiHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/GuiHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -19,6 +19,7 @@
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/GameHelper.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
+#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
@@ -59,9 +60,6 @@
 CGuiHandler* guihandler = NULL;
 
 
-const char* CGuiHandler::luaUiFile = &quot;luaui.lua&quot;;
-
-
 CGuiHandler::CGuiHandler()
 : inCommand(-1),
   activeMousePress(false),
@@ -74,7 +72,6 @@
   buildSpacing(0),
   buildFacing(0),
   actionOffset(0),
-  luaUIClick(false),
   gatherMode(false)
 {
 	icons = SAFE_NEW IconInfo[16];
@@ -857,10 +854,8 @@
 
 void CGuiHandler::GiveCommand(const Command&amp; cmd, bool fromUser) const
 {
-	if (luaUI != NULL) {
-		if (luaUI-&gt;CommandNotify(cmd)) {
-			return;
-		}
+	if (luaCallIns.CommandNotify(cmd)) {
+		return;
 	}
 
 	selectedUnits.GiveCommand(cmd, fromUser);
@@ -920,11 +915,9 @@
 
 	// Notify LuaUI about groups that have changed
 	if (!changedGroups.empty()) {
-		if (luaUI != NULL) {
-			set&lt;int&gt;::const_iterator it;
-			for (it = changedGroups.begin(); it != changedGroups.end(); ++it) {
-				luaUI-&gt;GroupChanged(*it);
-			}
+		set&lt;int&gt;::const_iterator it;
+		for (it = changedGroups.begin(); it != changedGroups.end(); ++it) {
+			luaCallIns.GroupChanged(*it);
 		}
 		changedGroups.clear();
 	}
@@ -1026,13 +1019,6 @@
 
 bool CGuiHandler::MousePress(int x, int y, int button)
 {
-	if (luaUI != NULL) {
-		luaUIClick = luaUI-&gt;MousePress(x, y, button);
-		if (luaUIClick) {
-			return true;
-		}
-	}
-
 	if (button == SDL_BUTTON_MIDDLE) {
 		return false;
 	}
@@ -1074,9 +1060,6 @@
 
 void CGuiHandler::MouseMove(int x, int y, int dx, int dy, int button)
 {
-	if (luaUI != NULL) {
-		luaUI-&gt;MouseMove(x, y, dx, dy, button);
-	}
 }
 
 
@@ -1084,20 +1067,8 @@
 {
 	int iconCmd = -1;
 
-	if (luaUIClick) {
-		luaUIClick = false;
-		if (luaUI != NULL) {
-			iconCmd = luaUI-&gt;MouseRelease(x, y, button);
-		}
-		if ((iconCmd &lt; 0) || (iconCmd &gt;= commands.size())) {
-			return;
-		} else {
-			activeMousePress = true;
-		}
-	}
-
 	if (activeMousePress) {
-		activeMousePress=false;
+		activeMousePress = false;
 	} else {
 		return;
 	}
@@ -1654,14 +1625,14 @@
 			return;
 		}
 		if (luaUI == NULL) {
-			logOutput.Print(&quot;Loading: \&quot;%s\&quot;\n&quot;, luaUiFile);
+			logOutput.Print(&quot;Loading: \&quot;%s\&quot;\n&quot;, &quot;luaui.lua&quot;); // FIXME
 			CLuaUI::LoadHandler();
 			if (luaUI == NULL) {
 				LoadConfig(&quot;ctrlpanel.txt&quot;);
 				logOutput.Print(&quot;Loading failed\n&quot;);
 			}
 		} else {
-			logOutput.Print(&quot;Reloading: \&quot;%s\&quot;\n&quot;, luaUiFile);
+			logOutput.Print(&quot;Reloading: \&quot;%s\&quot;\n&quot;, &quot;luaui.lua&quot;); // FIXME
 			CLuaUI::FreeHandler();
 			CLuaUI::LoadHandler();
 			if (luaUI == NULL) {
@@ -1769,12 +1740,6 @@
 
 bool CGuiHandler::KeyPressed(unsigned short key, bool isRepeat)
 {
-	if (luaUI != NULL) {
-		if (luaUI-&gt;KeyPress(key, isRepeat)) {
-			return true;
-		}
-	}
-
 	if (key == SDLK_ESCAPE &amp;&amp; activeMousePress) {
 		activeMousePress = false;
 		inCommand = -1;
@@ -2028,9 +1993,6 @@
 
 bool CGuiHandler::KeyReleased(unsigned short key)
 {
-	if (luaUI != NULL) {
-		return luaUI-&gt;KeyRelease(key);
-	}
 	return false;
 }
 
@@ -2089,11 +2051,6 @@
 
 bool CGuiHandler::IsAbove(int x, int y)
 {
-	if (luaUI != NULL) {
-		if (luaUI-&gt;IsAbove(x, y)) {
-			return true;
-		}
-	}
 	return AboveGui(x, y);
 }
 
@@ -2101,12 +2058,6 @@
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
 	std::string s;
-	if (luaUI != NULL) {
-		s = luaUI-&gt;GetTooltip(x, y);
-		if (!s.empty()) {
-			return s;
-		}
-	}
 
 	const int iconPos = IconAtPos(x, y);
 	const int iconCmd = (iconPos &gt;= 0) ? icons[iconPos].commandsID : -1;

Modified: trunk/rts/Game/UI/GuiHandler.h
===================================================================
--- trunk/rts/Game/UI/GuiHandler.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/GuiHandler.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -14,7 +14,6 @@
 
 class CUnit;
 class CglList;
-class CLuaUI;
 struct UnitDef;
 struct BuildInfo;
 
@@ -161,8 +160,6 @@
 		int actionOffset;
 		CKeySet lastKeySet;
 
-		bool luaUIClick;
-
 		std::string menuName;
 		int xIcons, yIcons;
 		float xPos, yPos;
@@ -217,8 +214,6 @@
 		std::map&lt;std::string, unsigned int&gt; textureMap; // filename, glTextureID
 
 		std::set&lt;int&gt; changedGroups;
-
-		static const char* luaUiFile;
 };
 
 

Modified: trunk/rts/Game/UI/LuaUI.cpp
===================================================================
--- trunk/rts/Game/UI/LuaUI.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/LuaUI.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -129,9 +129,6 @@
 	shockFrontMinPower = 0.0f;
 	shockFrontDistAdj  = 100.0f;
 
-	haveWorldTooltip = false;
-	haveMapDrawCmd = false;
-
 	const string code = LoadFile(&quot;luaui.lua&quot;);
 	if (code.empty()) {
 		KillLua();
@@ -266,16 +263,6 @@
 		return false;
 	}
 
-	if (name == &quot;WorldTooltip&quot;) {
-		haveWorldTooltip = HasCallIn(name);
-		return true;
-	}
-
-	if (name == &quot;MapDrawCmd&quot;) {
-		haveMapDrawCmd = HasCallIn(name);
-		return true;
-	}
-
 	if (HasCallIn(name)) {
 		luaCallIns.InsertCallIn(this, name);
 	} else {
@@ -311,96 +298,8 @@
 	lua_pushcfunction(L, x);    \
 	lua_rawset(L, -3)
 
-	REGISTER_LUA_CFUNC(SendCommands);
-	REGISTER_LUA_CFUNC(GiveOrder);
-	REGISTER_LUA_CFUNC(GiveOrderToUnit);
-	REGISTER_LUA_CFUNC(GiveOrderToUnitMap);
-	REGISTER_LUA_CFUNC(GiveOrderToUnitArray);
-	REGISTER_LUA_CFUNC(GiveOrderArrayToUnitMap);
-	REGISTER_LUA_CFUNC(GiveOrderArrayToUnitArray);
-
-	REGISTER_LUA_CFUNC(SendLuaUIMsg);
-	REGISTER_LUA_CFUNC(SendLuaGaiaMsg);
-	REGISTER_LUA_CFUNC(SendLuaRulesMsg);
-
-	REGISTER_LUA_CFUNC(GetFPS);
-
-	REGISTER_LUA_CFUNC(SetActiveCommand);
-	REGISTER_LUA_CFUNC(GetActiveCommand);
-	REGISTER_LUA_CFUNC(GetDefaultCommand);
-	REGISTER_LUA_CFUNC(GetActiveCmdDescs);
-	REGISTER_LUA_CFUNC(GetActiveCmdDesc);
-	REGISTER_LUA_CFUNC(GetCmdDescIndex);
-
-	REGISTER_LUA_CFUNC(GetBuildFacing);
-	REGISTER_LUA_CFUNC(GetBuildSpacing);
-
-	REGISTER_LUA_CFUNC(GetGatherMode);
-
-	REGISTER_LUA_CFUNC(GetActivePage);
-	REGISTER_LUA_CFUNC(ForceLayoutUpdate);
-
-	REGISTER_LUA_CFUNC(GetMouseState);
-	REGISTER_LUA_CFUNC(GetMouseMiniMapState);
-	REGISTER_LUA_CFUNC(GetMouseStartPosition);
-	REGISTER_LUA_CFUNC(GetMouseCursor);
-	REGISTER_LUA_CFUNC(SetMouseCursor);
-	REGISTER_LUA_CFUNC(WarpMouse);
-
-	REGISTER_LUA_CFUNC(SetCameraOffset);
-
 	REGISTER_LUA_CFUNC(SetShockFrontFactors);
 
-	REGISTER_LUA_CFUNC(SetLosViewColors);
-
-	REGISTER_LUA_CFUNC(GetKeyState);
-	REGISTER_LUA_CFUNC(GetModKeyState);
-	REGISTER_LUA_CFUNC(GetPressedKeys);
-	REGISTER_LUA_CFUNC(GetInvertQueueKey);
-
-	REGISTER_LUA_CFUNC(GetKeyCode);
-	REGISTER_LUA_CFUNC(GetKeySymbol);
-	REGISTER_LUA_CFUNC(GetKeyBindings);
-	REGISTER_LUA_CFUNC(GetActionHotKeys);
-
-	REGISTER_LUA_CFUNC(GetConsoleBuffer);
-	REGISTER_LUA_CFUNC(GetCurrentTooltip);
-
-	REGISTER_LUA_CFUNC(GetConfigInt);
-	REGISTER_LUA_CFUNC(SetConfigInt);
-	REGISTER_LUA_CFUNC(GetConfigString);
-	REGISTER_LUA_CFUNC(SetConfigString);
-
-	REGISTER_LUA_CFUNC(CreateDir);
-	REGISTER_LUA_CFUNC(MakeFont);
-	REGISTER_LUA_CFUNC(SetUnitDefIcon);
-
-	REGISTER_LUA_CFUNC(GetMyAllyTeamID);
-	REGISTER_LUA_CFUNC(GetMyTeamID);
-	REGISTER_LUA_CFUNC(GetMyPlayerID);
-
-	REGISTER_LUA_CFUNC(GetGroupList);
-	REGISTER_LUA_CFUNC(GetSelectedGroup);
-	REGISTER_LUA_CFUNC(GetGroupAIName);
-	REGISTER_LUA_CFUNC(GetGroupAIList);
-
-	REGISTER_LUA_CFUNC(GetUnitGroup);
-	REGISTER_LUA_CFUNC(SetUnitGroup);
-
-	REGISTER_LUA_CFUNC(GetGroupUnits);
-	REGISTER_LUA_CFUNC(GetGroupUnitsSorted);
-	REGISTER_LUA_CFUNC(GetGroupUnitsCounts);
-	REGISTER_LUA_CFUNC(GetGroupUnitsCount);
-
-	REGISTER_LUA_CFUNC(SetShareLevel);
-	REGISTER_LUA_CFUNC(ShareResources);
-
-	REGISTER_LUA_CFUNC(MarkerAddPoint);
-	REGISTER_LUA_CFUNC(MarkerAddLine);
-	REGISTER_LUA_CFUNC(MarkerErasePosition);
-
-	REGISTER_LUA_CFUNC(GetPlayerTraffic);
-
 	lua_setglobal(L, &quot;Spring&quot;);
 
 	return true;
@@ -497,73 +396,6 @@
 }
 
 
-bool CLuaUI::CommandNotify(const Command&amp; cmd)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;CommandNotify&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined
-	}
-
-	// push the command id
-	lua_pushnumber(L, cmd.id);
-
-	// push the params list
-	lua_newtable(L);
-	for (int p = 0; p &lt; (int)cmd.params.size(); p++) {
-		lua_pushnumber(L, p + 1);
-		lua_pushnumber(L, cmd.params[p]);
-		lua_rawset(L, -3);
-	}
-
-	// push the options table
-	lua_newtable(L);
-	HSTR_PUSH_NUMBER(L, &quot;coded&quot;, cmd.options);
-	HSTR_PUSH_BOOL(L, &quot;alt&quot;,   !!(cmd.options &amp; ALT_KEY));
-	HSTR_PUSH_BOOL(L, &quot;ctrl&quot;,  !!(cmd.options &amp; CONTROL_KEY));
-	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!(cmd.options &amp; SHIFT_KEY));
-	HSTR_PUSH_BOOL(L, &quot;right&quot;, !!(cmd.options &amp; RIGHT_MOUSE_KEY));
-
-	// call the function
-	if (!RunCallIn(cmdStr, 3, 1)) {
-		return false;
-	}
-
-	// get the results
-	const int args = lua_gettop(L);
-	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;CommandNotify() bad return value (%i)\n&quot;, args);
-		lua_pop(L, 1);
-		return false;
-	}
-
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::GroupChanged(int groupID)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 3);
-	static const LuaHashString cmdStr(&quot;GroupChanged&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined
-	}
-
-	lua_pushnumber(L, groupID);
-
-	// call the routine
-	if (!RunCallIn(cmdStr, 1, 0)) {
-		return false;
-	}
-
-	return true;
-}
-
-
 static inline float fuzzRand(float fuzz)
 {
 	return (1.0f + fuzz) - ((2.0f * fuzz) * (float)rand() / (float)RAND_MAX);
@@ -618,416 +450,8 @@
 }
 
 
-string CLuaUI::WorldTooltip(const CUnit* unit,
-                             const CFeature* feature,
-                             const float3* groundPos)
-{
-	if (!haveWorldTooltip) {
-		return &quot;&quot;;
-	}
-
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 6);
-	static const LuaHashString cmdStr(&quot;WorldTooltip&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		haveWorldTooltip = false;
-		return &quot;&quot;; // the call is not defined
-	}
-
-	int args;
-	if (unit) {
-		HSTR_PUSH(L, &quot;unit&quot;);
-		lua_pushnumber(L, unit-&gt;id);
-		args = 2;
-	}
-	else if (feature) {
-		HSTR_PUSH(L, &quot;feature&quot;);
-		lua_pushnumber(L, feature-&gt;id);
-		args = 2;
-	}
-	else if (groundPos) {
-		HSTR_PUSH(L, &quot;ground&quot;);
-		lua_pushnumber(L, groundPos-&gt;x);
-		lua_pushnumber(L, groundPos-&gt;y);
-		lua_pushnumber(L, groundPos-&gt;z);
-		args = 4;
-	}
-	else {
-		HSTR_PUSH(L, &quot;selection&quot;);
-		args = 1;
-	}
-
-	// call the routinea
-	if (!RunCallIn(cmdStr, args, 1)) {
-		return &quot;&quot;;
-	}
-
-	if (!lua_isstring(L, -1)) {
-		lua_pop(L, 1);
-		return &quot;&quot;;
-	}
-	const string retval = lua_tostring(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::MapDrawCmd(int playerID, int type,
-                        const float3* pos0,
-                        const float3* pos1,
-                        const string* label)
-{
-	if (!haveMapDrawCmd) {
-		return false;
-	}
-
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 9);
-	static const LuaHashString cmdStr(&quot;MapDrawCmd&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		haveMapDrawCmd = false;
-		return false; // the call is not defined
-	}
-
-	int args;
-
-	lua_pushnumber(L, playerID);
-
-	if (type == CInMapDraw::NET_POINT) {
-		HSTR_PUSH(L, &quot;point&quot;);
-		lua_pushnumber(L, pos0-&gt;x);
-		lua_pushnumber(L, pos0-&gt;y);
-		lua_pushnumber(L, pos0-&gt;z);
-		lua_pushstring(L, label-&gt;c_str());
-		args = 6;
-	}
-	else if (type == CInMapDraw::NET_LINE) {
-		HSTR_PUSH(L, &quot;line&quot;);
-		lua_pushnumber(L, pos0-&gt;x);
-		lua_pushnumber(L, pos0-&gt;y);
-		lua_pushnumber(L, pos0-&gt;z);
-		lua_pushnumber(L, pos1-&gt;x);
-		lua_pushnumber(L, pos1-&gt;y);
-		lua_pushnumber(L, pos1-&gt;z);
-		args = 8;
-	}
-	else if (type == CInMapDraw::NET_ERASE) {
-		HSTR_PUSH(L, &quot;erase&quot;);
-		lua_pushnumber(L, pos0-&gt;x);
-		lua_pushnumber(L, pos0-&gt;y);
-		lua_pushnumber(L, pos0-&gt;z);
-		lua_pushnumber(L, 100.0f);  // radius
-		args = 6;
-	}
-	else {
-		logOutput.Print(&quot;Unknown MapDrawCmd() type&quot;);
-		lua_pop(L, 2); // pop the function and playerID
-		return false;
-	}
-
-	// call the routine
-	if (!RunCallIn(cmdStr, args, 1)) {
-		return false;
-	}
-
-	// take the event?
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::GameSetup(const string&amp; state, bool&amp; ready,
-                       const map&lt;int, string&gt;&amp; playerStates)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;GameSetup&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false;
-	}
-
-	lua_pushstring(L, state.c_str());
-
-	lua_pushboolean(L, ready);
-
-	lua_newtable(L);
-	map&lt;int, string&gt;::const_iterator it;
-	for (it = playerStates.begin(); it != playerStates.end(); ++it) {
-		lua_pushnumber(L, it-&gt;first);
-		lua_pushstring(L, it-&gt;second.c_str());
-		lua_rawset(L, -3);
-	}
-
-	// call the routinea
-	if (!RunCallIn(cmdStr, 3, 2)) {
-		return false;
-	}
-
-	if (lua_isboolean(L, -2)) {
-		if (lua_toboolean(L, -2)) {
-			if (lua_isboolean(L, -1)) {
-				ready = lua_toboolean(L, -1);
-			}
-			lua_pop(L, 2);
-			return true;
-		}
-	}
-	lua_pop(L, 2);
-	return false;
-}
-
-
 /******************************************************************************/
 
-bool CLuaUI::KeyPress(unsigned short key, bool isRepeat)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 6);
-	static const LuaHashString cmdStr(&quot;KeyPress&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined, do not take the event
-	}
-
-	lua_pushnumber(L, key);
-
-	lua_newtable(L);
-	HSTR_PUSH_BOOL(L, &quot;alt&quot;,   !!keys[SDLK_LALT]);
-	HSTR_PUSH_BOOL(L, &quot;ctrl&quot;,  !!keys[SDLK_LCTRL]);
-	HSTR_PUSH_BOOL(L, &quot;meta&quot;,  !!keys[SDLK_LMETA]);
-	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!keys[SDLK_LSHIFT]);
-
-	lua_pushboolean(L, isRepeat);
-
-	CKeySet ks(key, false);
-	lua_pushstring(L, ks.GetString(true).c_str());
-
-	lua_pushnumber(L, currentUnicode);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 5, 1)) {
-		return false;
-	}
-
-	// const int args = lua_gettop(L); unused
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::KeyRelease(unsigned short key)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;KeyRelease&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined, do not take the event
-	}
-
-	lua_pushnumber(L, key);
-
-	lua_newtable(L);
-	HSTR_PUSH_BOOL(L, &quot;alt&quot;,   !!keys[SDLK_LALT]);
-	HSTR_PUSH_BOOL(L, &quot;ctrl&quot;,  !!keys[SDLK_LCTRL]);
-	HSTR_PUSH_BOOL(L, &quot;meta&quot;,  !!keys[SDLK_LMETA]);
-	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!keys[SDLK_LSHIFT]);
-
-	CKeySet ks(key, false);
-	lua_pushstring(L, ks.GetString(true).c_str());
-
-	lua_pushnumber(L, currentUnicode);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 4, 1)) {
-		return false;
-	}
-
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::MouseMove(int x, int y, int dx, int dy, int button)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 7);
-	static const LuaHashString cmdStr(&quot;MouseMove&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined, do not take the event
-	}
-
-	lua_pushnumber(L, x - gu-&gt;viewPosX);
-	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
-	lua_pushnumber(L, dx);
-	lua_pushnumber(L, -dy);
-	lua_pushnumber(L, button);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 5, 1)) {
-		return false;
-	}
-
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::MousePress(int x, int y, int button)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;MousePress&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined, do not take the event
-	}
-
-	lua_pushnumber(L, x - gu-&gt;viewPosX);
-	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
-	lua_pushnumber(L, button);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 3, 1)) {
-		return false;
-	}
-
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-int CLuaUI::MouseRelease(int x, int y, int button)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;MouseRelease&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined, do not take the event
-	}
-
-	lua_pushnumber(L, x - gu-&gt;viewPosX);
-	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
-	lua_pushnumber(L, button);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 3, 1)) {
-		return false;
-	}
-
-	if (!lua_isnumber(L, -1)) {
-		lua_pop(L, 1);
-		return -1;
-	}
-	const int retval = (int)lua_tonumber(L, -1) - 1;
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::MouseWheel(bool up, float value)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 4);
-	static const LuaHashString cmdStr(&quot;MouseWheel&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined, do not take the event
-	}
-
-	lua_pushboolean(L, up);
-	lua_pushnumber(L, value);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 2, 1)) {
-		return false;
-	}
-
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-bool CLuaUI::IsAbove(int x, int y)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 4);
-	static const LuaHashString cmdStr(&quot;IsAbove&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined
-	}
-
-	lua_pushnumber(L, x - gu-&gt;viewPosX);
-	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 2, 1)) {
-		return false;
-	}
-
-	if (!lua_isboolean(L, -1)) {
-		lua_pop(L, 1);
-		return false;
-	}
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
-string CLuaUI::GetTooltip(int x, int y)
-{
-	LUA_CALL_IN_CHECK(L);
-	lua_checkstack(L, 4);
-	static const LuaHashString cmdStr(&quot;GetTooltip&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return &quot;&quot;; // the call is not defined
-	}
-
-	lua_pushnumber(L, x - gu-&gt;viewPosX);
-	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 2, 1)) {
-		return &quot;&quot;;
-	}
-
-	if (!lua_isstring(L, -1)) {
-		lua_pop(L, 1);
-		return &quot;&quot;;
-	}
-	const string retval = lua_tostring(L, -1);
-	lua_pop(L, 1);
-	return retval;
-}
-
-
 bool CLuaUI::HasLayoutButtons()
 {
 	static const LuaHashString cmdStr(&quot;LayoutButtons&quot;);
@@ -1338,10 +762,11 @@
 					logOutput.Print(&quot;GetLuaCmdDescList() unknown key  (%s)\n&quot;, key.c_str());
 				}
 			}
-			else if (lua_isstring(L, -2) &amp;&amp; lua_istable(L, -1)) {
+			else if (lua_israwstring(L, -2) &amp;&amp; lua_istable(L, -1)) {
 				const string key = StringToLower(lua_tostring(L, -2));
 				if (key != &quot;actions&quot;) {
-					logOutput.Print(&quot;GetLuaCmdDescList() non \&quot;actions\&quot; table\n&quot;);
+					logOutput.Print(&quot;GetLuaCmdDescList() non \&quot;actions\&quot; table: %s&quot;,
+					                key.c_str());
 					continue;
 				}
 				const int actionsTable = lua_gettop(L);
@@ -1434,532 +859,10 @@
 
 /******************************************************************************/
 /******************************************************************************/
-
-static inline CUnit* ParseRawUnit(lua_State* L, const char* caller, int index)
-{
-	if (!lua_isnumber(L, index)) {
-		if (caller != NULL) {
-			luaL_error(L, &quot;Bad unitID parameter in %s()\n&quot;, caller);
-		} else {
-			return NULL;
-		}
-	}
-	const int unitID = (int)lua_tonumber(L, index);
-	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
-		luaL_error(L, &quot;Bad unitID in %s() %i\n&quot;, caller, unitID);
-	}
-	CUnit* unit = uh-&gt;units[unitID];
-	if (unit == NULL) {
-		luaL_error(L, &quot;Bad unitID pointer in %s() %i\n&quot;, caller, unitID);
-	}
-	return unit;
-}
-
-
-static inline CUnit* ParseReadUnit(lua_State* L, const char* caller, int index)
-{
-	CUnit* unit = ParseRawUnit(L, caller, index);
-	if (unit == NULL) {
-		return NULL;
-	}
-	static const int&amp;  readAllyTeam = CLuaHandle::GetActiveReadAllyTeam();
-	if (readAllyTeam &lt; 0) {
-		return (readAllyTeam == CLuaHandle::AllAccessTeam) ? unit : NULL;
-	}
-	if ((unit-&gt;losStatus[readAllyTeam] &amp; (LOS_INLOS | LOS_INRADAR)) == 0) {
-		return NULL;
-	}
-	return unit;
-}
-
-
-static inline CUnit* ParseCtrlUnit(lua_State* L, const char* caller, int index)
-{
-	CUnit* unit = ParseRawUnit(L, caller, index);
-	if (unit == NULL) {
-		return NULL;
-	}
-	const int ctrlTeam = CLuaHandle::GetActiveHandle()-&gt;GetCtrlTeam();
-	if (ctrlTeam &lt; 0) {
-		return (ctrlTeam == CLuaHandle::AllAccessTeam) ? unit : NULL;
-	}
-	if (ctrlTeam != unit-&gt;team) {
-		return NULL;
-	}
-	return unit;
-}
-
-
-static inline void CheckNoArgs(lua_State* L, const char* funcName)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if (args != 0) {
-		luaL_error(L, &quot;%s() takes no arguments&quot;, funcName);
-	}
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
 //
 // Lua Callbacks
 //
 
-int CLuaUI::CreateDir(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to CreateDir()&quot;);
-	}
-
-	// keep directories within the Spring directory
-	const string dir = lua_tostring(L, 1);
-	if ((dir[0] == '/') || (dir[0] == '\\') ||
-	    (strstr(dir.c_str(), &quot;..&quot;) != NULL) ||
-	    ((dir.size() &gt; 0) &amp;&amp; (dir[1] == ':'))) {
-		luaL_error(L, &quot;Invalid CreateDir() access: %s&quot;, dir.c_str());
-	}
-
-	const bool success = filesystem.CreateDirectory(dir);
-	lua_pushboolean(L, success);
-	return 1;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetFPS(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	if (game) {
-		lua_pushnumber(L, game-&gt;fps);
-	} else {
-		lua_pushnumber(L, 0);
-	}
-	return 1;
-}
-
-
-int CLuaUI::SendCommands(lua_State* L)
-{
-	if ((guihandler == NULL) || gs-&gt;noHelperAIs) {
-		return 0;
-	}
-
-	vector&lt;string&gt; cmds;
-
-	if (lua_istable(L, 1)) { // old style -- table
-		const int table = 1;
-		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-			if (lua_israwstring(L, -1)) {
-				string action = lua_tostring(L, -1);
-				if (action[0] != '@') {
-					action = &quot;@@&quot; + action;
-				}
-				cmds.push_back(action);
-			}
-		}
-	}
-	else if (lua_israwstring(L, 1)) { // new style -- function parameters
-		for (int i = 1; lua_israwstring(L, i); i++) {
-			string action = lua_tostring(L, i);
-			if (action[0] != '@') {
-				action = &quot;@@&quot; + action;
-			}
-			cmds.push_back(action);
-		}
-	}
-	else {
-		luaL_error(L, &quot;Incorrect arguments to SendCommands()&quot;);
-	}
-
-	lua_settop(L, 0); // pop the input arguments
-
-	guihandler-&gt;RunCustomCommands(cmds, false);
-
-	return 0;
-}
-
-
-/******************************************************************************/
-
-static int SetActiveCommandByIndex(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	const int cmdIndex = (int)lua_tonumber(L, 1) - CMD_INDEX_OFFSET;
-	int button = 1; // LMB
-	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
-		button = (int)lua_tonumber(L, 2);
-	}
-
-	if (args &lt;= 2) {
-		const bool rmb = (button == SDL_BUTTON_LEFT) ? false : true;
-		const bool success = guihandler-&gt;SetActiveCommand(cmdIndex, rmb);
-		lua_pushboolean(L, success);
-		return 1;
-	}
-
-	// cmdIndex, button, lmb, rmb, alt, ctrl, meta, shift
-	if ((args &lt; 8) ||
-	    !lua_isboolean(L, 3) || !lua_isboolean(L, 4) || !lua_isboolean(L, 5) ||
-	    !lua_isboolean(L, 6) || !lua_isboolean(L, 7) || !lua_isboolean(L, 8)) {
-		lua_pushstring(L, &quot;Incorrect arguments to SetActiveCommand()&quot;);
-	}
-	const bool lmb   = lua_toboolean(L, 3);
-	const bool rmb   = lua_toboolean(L, 4);
-	const bool alt   = lua_toboolean(L, 5);
-	const bool ctrl  = lua_toboolean(L, 6);
-	const bool meta  = lua_toboolean(L, 7);
-	const bool shift = lua_toboolean(L, 8);
-
-	const bool success = guihandler-&gt;SetActiveCommand(cmdIndex, button, lmb, rmb,
-	                                                  alt, ctrl, meta, shift);
-	lua_pushboolean(L, success);
-	return 1;
-}
-
-
-static int SetActiveCommandByAction(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	const string text = lua_tostring(L, 1);
-	const Action action(text);
-	CKeySet ks;
-	if (args &gt;= 2) {
-		const string ksText = lua_tostring(L, 2);
-		ks.Parse(ksText);
-	}
-	const bool success = guihandler-&gt;SetActiveCommand(action, ks, 0);
-	lua_pushboolean(L, success);
-	return 1;
-}
-
-
-int CLuaUI::SetActiveCommand(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	if (args &lt; 1) {
-		luaL_error(L, &quot;Incorrect arguments to SetActiveCommand()&quot;);
-	}
-	if (lua_isnumber(L, 1)) {
-		return SetActiveCommandByIndex(L);
-	}
-	if (lua_isstring(L, 1)) {
-		return SetActiveCommandByAction(L);
-	}
-	luaL_error(L, &quot;Incorrect arguments to SetActiveCommand()&quot;);
-	return 0;
-}
-
-
-int CLuaUI::GetActiveCommand(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	CheckNoArgs(L, __FUNCTION__);
-
-	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
-	const int cmdDescCount = (int)cmdDescs.size();
-
-	const int inCommand = guihandler-&gt;inCommand;
-	lua_pushnumber(L, inCommand + CMD_INDEX_OFFSET);
-	if ((inCommand &lt; 0) || (inCommand &gt;= cmdDescCount)) {
-		return 1;
-	}
-	lua_pushnumber(L, cmdDescs[inCommand].id);
-	lua_pushnumber(L, cmdDescs[inCommand].type);
-	lua_pushstring(L, cmdDescs[inCommand].name.c_str());
-	return 4;
-}
-
-
-int CLuaUI::GetDefaultCommand(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	CheckNoArgs(L, __FUNCTION__);
-
-	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
-	const int cmdDescCount = (int)cmdDescs.size();
-
-	const int defCmd = guihandler-&gt;GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty);
-	lua_pushnumber(L, defCmd + CMD_INDEX_OFFSET);
-	if ((defCmd &lt; 0) || (defCmd &gt;= cmdDescCount)) {
-		return 1;
-	}
-	lua_pushnumber(L, cmdDescs[defCmd].id);
-	lua_pushnumber(L, cmdDescs[defCmd].type);
-	lua_pushstring(L, cmdDescs[defCmd].name.c_str());
-	return 4;
-}
-
-
-// FIXME: duplicated in LuaSyncedRead.cpp
-static void PushCommandDesc(lua_State* L, const CommandDescription&amp; cd)
-{
-	lua_newtable(L);
-
-	HSTR_PUSH_NUMBER(L, &quot;id&quot;,          cd.id);
-	HSTR_PUSH_NUMBER(L, &quot;type&quot;,        cd.type);
-	HSTR_PUSH_STRING(L, &quot;name&quot;,        cd.name);
-	HSTR_PUSH_STRING(L, &quot;action&quot;,      cd.action);
-	HSTR_PUSH_STRING(L, &quot;tooltip&quot;,     cd.tooltip);
-	HSTR_PUSH_STRING(L, &quot;texture&quot;,     cd.iconname);
-	HSTR_PUSH_STRING(L, &quot;cursor&quot;,      cd.mouseicon);
-	HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,      cd.onlyKey);
-	HSTR_PUSH_BOOL(L,   &quot;disabled&quot;,    cd.disabled);
-	HSTR_PUSH_BOOL(L,   &quot;showUnique&quot;,  cd.showUnique);
-	HSTR_PUSH_BOOL(L,   &quot;onlyTexture&quot;, cd.onlyTexture);
-
-	HSTR_PUSH(L, &quot;params&quot;);
-	lua_newtable(L);
-	const int pCount = (int)cd.params.size();
-	for (int p = 0; p &lt; pCount; p++) {
-		lua_pushnumber(L, p + 1);
-		lua_pushstring(L, cd.params[p].c_str());
-		lua_rawset(L, -3);
-	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, pCount);
-	lua_rawset(L, -3);
-}
-
-
-int CLuaUI::GetActiveCmdDescs(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	CheckNoArgs(L, __FUNCTION__);
-	lua_newtable(L);
-	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
-	const int cmdDescCount = (int)cmdDescs.size();
-	for (int i = 0; i &lt; cmdDescCount; i++) {
-		lua_pushnumber(L, i + CMD_INDEX_OFFSET);
-		PushCommandDesc(L, cmdDescs[i]);
-		lua_rawset(L, -3);
-	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, cmdDescCount);
-	return 1;
-}
-
-
-int CLuaUI::GetActiveCmdDesc(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetActiveCmdDesc()&quot;);
-	}
-	const int cmdIndex = (int)lua_tonumber(L, 1) - CMD_INDEX_OFFSET;
-
-	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
-	const int cmdDescCount = (int)cmdDescs.size();
-	if ((cmdIndex &lt; 0) || (cmdIndex &gt;= cmdDescCount)) {
-		return 0;
-	}
-	PushCommandDesc(L, cmdDescs[cmdIndex]);
-	return 1;
-}
-
-
-int CLuaUI::GetCmdDescIndex(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	const int cmdId = (int)luaL_checknumber(L, 1);
-
-	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
-	const int cmdDescCount = (int)cmdDescs.size();
-	for (int i = 0; i &lt; cmdDescCount; i++) {
-		if (cmdId == cmdDescs[i].id) {
-			lua_pushnumber(L, i + CMD_INDEX_OFFSET);
-			return 1;
-		}
-	}
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetBuildFacing(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, guihandler-&gt;buildFacing);
-	return 1;
-}
-
-
-int CLuaUI::GetBuildSpacing(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, guihandler-&gt;buildSpacing);
-	return 1;
-}
-
-
-int CLuaUI::GetGatherMode(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, guihandler-&gt;GetGatherMode());
-	return 1;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetActivePage(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	lua_pushnumber(L, guihandler-&gt;GetActivePage());
-	lua_pushnumber(L, guihandler-&gt;GetMaxPage());
-	return 2;
-}
-
-
-int CLuaUI::ForceLayoutUpdate(lua_State* L)
-{
-	if (guihandler == NULL) {
-		return 0;
-	}
-	guihandler-&gt;ForceLayoutUpdate();
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetMouseState(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, mouse-&gt;lastx - gu-&gt;viewPosX);
-	lua_pushnumber(L, gu-&gt;viewSizeY - mouse-&gt;lasty - 1);
-	lua_pushboolean(L, mouse-&gt;buttons[SDL_BUTTON_LEFT].pressed);
-	lua_pushboolean(L, mouse-&gt;buttons[SDL_BUTTON_MIDDLE].pressed);
-	lua_pushboolean(L, mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed);
-	return 5;
-}
-
-
-int CLuaUI::GetMouseMiniMapState(lua_State* L) //FIXME
-{
-	if (minimap == NULL) {
-		return 0;
-	}
-	lua_pushnumber(L, minimap-&gt;GetPosX());
-	lua_pushnumber(L, minimap-&gt;GetPosY());
-	lua_pushnumber(L, minimap-&gt;GetSizeX());
-	lua_pushnumber(L, minimap-&gt;GetSizeY());
-	lua_pushboolean(L, minimap-&gt;GetMinimized());
-	lua_pushboolean(L, minimap-&gt;GetMaximized());
-	return 6;
-}
-
-
-int CLuaUI::GetMouseStartPosition(lua_State* L) //FIXME
-{
-	if (mouse == NULL) {
-		return 0;
-	}
-	const int button = luaL_checkint(L, 1);
-	if ((button &lt;= 0) || (button &gt; NUM_BUTTONS)) {
-		return 0;
-	}
-	const CMouseHandler::ButtonPress&amp; bp = mouse-&gt;buttons[button];
-	lua_pushnumber(L, bp.x);
-	lua_pushnumber(L, bp.y);
-	lua_pushnumber(L, bp.camPos.x);
-	lua_pushnumber(L, bp.camPos.y);
-	lua_pushnumber(L, bp.camPos.z);
-	lua_pushnumber(L, bp.dir.x);
-	lua_pushnumber(L, bp.dir.y);
-	lua_pushnumber(L, bp.dir.z);
-	return 8;
-}
-
-
-int CLuaUI::WarpMouse(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to WarpMouse()&quot;);
-	}
-	const int x = (int)lua_tonumber(L, 1);
-	const int y = gu-&gt;viewSizeY - (int)lua_tonumber(L, 2) - 1;
-	mouse-&gt;WarpMouse(x, y);
-	return 0;
-}
-
-
-int CLuaUI::GetMouseCursor(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushstring(L, mouse-&gt;cursorText.c_str());
-	lua_pushnumber(L, mouse-&gt;cursorScale);
-	return 2;
-}
-
-
-int CLuaUI::SetMouseCursor(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isstring(L, 1) ||
-	    ((args &gt;= 2) &amp;&amp; !lua_isnumber(L, 2))) {
-		luaL_error(L,
-			&quot;Incorrect arguments to SetMouseCursor(\&quot;name\&quot;, [scale])&quot;);
-	}
-	mouse-&gt;cursorText = lua_tostring(L, 1);
-	if (args &gt;= 2) {
-		mouse-&gt;cursorScale = lua_tonumber(L, 2);
-	}
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::SetCameraOffset(lua_State* L)
-{
-	if (camera == NULL) {
-		return 0;
-	}
-	const float px = (float)luaL_optnumber(L, 1, 0.0f);
-	const float py = (float)luaL_optnumber(L, 2, 0.0f);
-	const float pz = (float)luaL_optnumber(L, 3, 0.0f);
-	const float tx = (float)luaL_optnumber(L, 4, 0.0f);
-	const float ty = (float)luaL_optnumber(L, 5, 0.0f);
-	const float tz = (float)luaL_optnumber(L, 6, 0.0f);
-	camera-&gt;posOffset = float3(px, py, pz);
-	camera-&gt;tiltOffset = float3(tx, ty, tz);
-	return 0;
-}
-
-
 int CLuaUI::SetShockFrontFactors(lua_State* L)
 {
 	luaUI-&gt;haveShockFront = true;
@@ -1979,1122 +882,5 @@
 }
 
 
-static int ParseFloatArray(lua_State* L, int index, float* array, int size)
-{
-	if (!lua_istable(L, index)) {
-		return -1;
-	}
-	const int table = (index &gt; 0) ? index : (lua_gettop(L) + index + 1);
-	for (int i = 0; i &lt; size; i++) {
-		lua_rawgeti(L, table, (i + 1));
-		if (lua_isnumber(L, -1)) {
-			array[i] = (float)lua_tonumber(L, -1);
-			lua_pop(L, 1);
-		} else {
-			lua_pop(L, 1);
-			return i;
-		}
-	}
-	return size;
-}
-
-
-int CLuaUI::SetLosViewColors(lua_State* L)
-{
-	float red[4];
-	float green[4];
-	float blue[4];
-	if ((ParseFloatArray(L, 1, red,   4) != 4) ||
-	    (ParseFloatArray(L, 2, green, 4) != 4) ||
-	    (ParseFloatArray(L, 3, blue,  4) != 4)) {
-		luaL_error(L, &quot;Incorrect arguments to SetLosViewColors()&quot;);
-	}
-	const int scale = CBaseGroundDrawer::losColorScale;
-	CBaseGroundDrawer *gd = readmap-&gt;GetGroundDrawer();
-	gd-&gt;alwaysColor[0] = (int)(scale *   red[0]);
-	gd-&gt;alwaysColor[1] = (int)(scale * green[0]);
-	gd-&gt;alwaysColor[2] = (int)(scale *  blue[0]);
-	gd-&gt;losColor[0]    = (int)(scale *   red[1]);
-	gd-&gt;losColor[1]    = (int)(scale * green[1]);
-	gd-&gt;losColor[2]    = (int)(scale *  blue[1]);
-	gd-&gt;radarColor[0]  = (int)(scale *   red[2]);
-	gd-&gt;radarColor[1]  = (int)(scale * green[2]);
-	gd-&gt;radarColor[2]  = (int)(scale *  blue[2]);
-	gd-&gt;jamColor[0]    = (int)(scale *   red[3]);
-	gd-&gt;jamColor[1]    = (int)(scale * green[3]);
-	gd-&gt;jamColor[2]    = (int)(scale *  blue[3]);
-	return 0;
-}
-
-
 /******************************************************************************/
 /******************************************************************************/
-
-int CLuaUI::GetKeyState(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetKeyState(keycode)&quot;);
-	}
-	const int key = (int)lua_tonumber(L, 1);
-	if ((key &lt; 0) || (key &gt;= SDLK_LAST)) {
-		lua_pushboolean(L, 0);
-	} else {
-		lua_pushboolean(L, keys[key]);
-	}
-	return 1;
-}
-
-
-int CLuaUI::GetModKeyState(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushboolean(L, keys[SDLK_LALT]);
-	lua_pushboolean(L, keys[SDLK_LCTRL]);
-	lua_pushboolean(L, keys[SDLK_LMETA]);
-	lua_pushboolean(L, keys[SDLK_LSHIFT]);
-	return 4;
-}
-
-
-int CLuaUI::GetPressedKeys(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_newtable(L);
-	int count = 0;
-	for (int i = 0; i &lt; SDLK_LAST; i++) {
-		if (keys[i]) {
-			lua_pushnumber(L, i);
-			lua_pushboolean(L, 1);
-			lua_rawset(L, -3);
-			count++;
-		}
-	}
-	lua_pushstring(L, &quot;n&quot;);
-	lua_pushnumber(L, count);
-	lua_rawset(L, -3);
-	return 1;
-}
-
-
-int CLuaUI::GetInvertQueueKey(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	if (guihandler == NULL) {
-		return 0;
-	}
-	lua_pushboolean(L, guihandler-&gt;GetInvertQueueKey());
-	return 1;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetConsoleBuffer(lua_State* L)
-{
-	CInfoConsole* ic = game-&gt;infoConsole;
-	if (ic == NULL) {
-		return true;
-	}
-
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 0) &amp;&amp; ((args != 1) || !lua_isnumber(L, 1))) {
-		luaL_error(L, &quot;Incorrect arguments to GetConsoleBuffer([count])&quot;);
-	}
-
-	deque&lt;CInfoConsole::RawLine&gt; lines;
-	ic-&gt;GetRawLines(lines);
-	const int lineCount = (int)lines.size();
-
-	int start = 0;
-	if (args &gt;= 1) {
-		const int maxLines = (int)lua_tonumber(L, 1);
-		if (maxLines &lt; lineCount) {
-			start = (lineCount - maxLines);
-		}
-	}
-
-	// table = { [1] = { text = string, zone = number}, etc... }
-	lua_newtable(L);
-	int count = 0;
-	for (int i = start; i &lt; lineCount; i++) {
-		count++;
-		lua_pushnumber(L, count);
-		lua_newtable(L); {
-			lua_pushstring(L, &quot;text&quot;);
-			lua_pushstring(L, lines[i].text.c_str());
-			lua_rawset(L, -3);
-			// FIXME: how to migrate 'priority' to 'zone', will it break widgets?
-			lua_pushstring(L, &quot;priority&quot;);
-			lua_pushnumber(L, lines[i].zone);
-			lua_rawset(L, -3);
-		}
-		lua_rawset(L, -3);
-	}
-	lua_pushstring(L, &quot;n&quot;);
-	lua_pushnumber(L, count);
-	lua_rawset(L, -3);
-
-	return 1;
-}
-
-
-int CLuaUI::GetCurrentTooltip(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	const string tooltip = mouse-&gt;GetCurrentTooltip();
-	lua_pushstring(L, tooltip.c_str());
-	return 1;
-}
-
-
-int CLuaUI::GetKeyCode(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetKeyCode(\&quot;keysym\&quot;)&quot;);
-	}
-	const string keysym = lua_tostring(L, 1);
-	lua_pushnumber(L, keyCodes-&gt;GetCode(keysym));
-	return 1;
-}
-
-
-int CLuaUI::GetKeySymbol(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetKeySymbol(keycode)&quot;);
-	}
-	const int keycode = (int)lua_tonumber(L, 1);
-	lua_pushstring(L, keyCodes-&gt;GetName(keycode).c_str());
-	lua_pushstring(L, keyCodes-&gt;GetDefaultName(keycode).c_str());
-	return 2;
-}
-
-
-int CLuaUI::GetKeyBindings(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetKeyBindings(\&quot;keyset\&quot;)&quot;);
-	}
-	const string keysetStr = lua_tostring(L, 1);
-	CKeySet ks;
-	if (!ks.Parse(keysetStr)) {
-		return 0;
-	}
-	const CKeyBindings::ActionList&amp;	actions = keyBindings-&gt;GetActionList(ks);
-	lua_newtable(L);
-	for (int i = 0; i &lt; (int)actions.size(); i++) {
-		const Action&amp; action = actions[i];
-		lua_pushnumber(L, i + 1);
-		lua_newtable(L);
-		lua_pushstring(L, action.command.c_str());
-		lua_pushstring(L, action.extra.c_str());
-		lua_rawset(L, -3);
-		lua_rawset(L, -3);
-	}
-	lua_pushstring(L, &quot;n&quot;);
-	lua_pushnumber(L, actions.size());
-	lua_rawset(L, -3);
-	return 1;
-}
-
-
-int CLuaUI::GetActionHotKeys(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetActionHotKeys(\&quot;command\&quot;)&quot;);
-	}
-	const string command = lua_tostring(L, 1);
-	const CKeyBindings::HotkeyList&amp;	hotkeys = keyBindings-&gt;GetHotkeys(command);
-	lua_newtable(L);
-	for (int i = 0; i &lt; (int)hotkeys.size(); i++) {
-		const string&amp; hotkey = hotkeys[i];
-		lua_pushnumber(L, i + 1);
-		lua_pushstring(L, hotkey.c_str());
-		lua_rawset(L, -3);
-	}
-	lua_pushstring(L, &quot;n&quot;);
-	lua_pushnumber(L, hotkeys.size());
-	lua_rawset(L, -3);
-	return 1;
-}
-
-
-int CLuaUI::GetConfigInt(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || (args &gt; 2) || !lua_isstring(L, 1) ||
-	    ((args == 2) &amp;&amp; !lua_isnumber(L, 2))) {
-		luaL_error(L, &quot;Incorrect arguments to GetConfigInt()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	int def = 0;
-	if (args == 2) {
-		def = (int)lua_tonumber(L, 2);
-	}
-	const int value = configHandler.GetInt(name, def);
-	lua_pushnumber(L, value);
-	return 1;
-}
-
-
-int CLuaUI::SetConfigInt(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isstring(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetConfigInt()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	const int value = (int)lua_tonumber(L, 2);
-	configHandler.SetInt(name, value);
-	return 0;
-}
-
-
-int CLuaUI::GetConfigString(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || (args &gt; 2) || !lua_isstring(L, 1) ||
-	    ((args == 2) &amp;&amp; !lua_isstring(L, 2))) {
-		luaL_error(L, &quot;Incorrect arguments to GetConfigString()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	string def;
-	if (args == 2) {
-		def = lua_tostring(L, 2);
-	}
-	const string value = configHandler.GetString(name, def);
-	lua_pushstring(L, value.c_str());
-	return 1;
-}
-
-
-int CLuaUI::SetConfigString(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isstring(L, 1) || !lua_isstring(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetConfigString()&quot;);
-	}
-	const string name = lua_tostring(L, 1);
-	const string value = lua_tostring(L, 2);
-	configHandler.SetString(name, value);
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::MakeFont(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 1) || !lua_isstring(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to MakeFont()&quot;);
-	}
-	FontTexture::Reset();
-	FontTexture::SetInFileName(lua_tostring(L, 1));
-	if ((args &gt;= 2) &amp;&amp; lua_istable(L, 2)) {
-		const int table = 2;
-		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-			if (lua_israwstring(L, -2)) {
-				const string key = lua_tostring(L, -2);
-				if (lua_type(L, -1) == LUA_TSTRING) {//lua_isstring(L, -1)) {
-					if ((key == &quot;outName&quot;) &amp;&amp; lua_isstring(L, -1)) {
-						FontTexture::SetOutBaseName(lua_tostring(L, -1));
-					}
-				}
-				else if (lua_isnumber(L, -1)) {
-					const unsigned int value = (unsigned int)lua_tonumber(L, -1);
-					if (key == &quot;height&quot;) {
-						FontTexture::SetFontHeight(value);
-					} else if (key == &quot;texWidth&quot;) {
-						FontTexture::SetTextureWidth(value);
-					} else if (key == &quot;minChar&quot;) {
-						FontTexture::SetMinChar(value);
-					} else if (key == &quot;maxChar&quot;) {
-						FontTexture::SetMaxChar(value);
-					} else if (key == &quot;outlineMode&quot;) {
-						FontTexture::SetOutlineMode(value);
-					} else if (key == &quot;outlineRadius&quot;) {
-						FontTexture::SetOutlineRadius(value);
-					} else if (key == &quot;outlineWeight&quot;) {
-						FontTexture::SetOutlineWeight(value);
-					} else if (key == &quot;padding&quot;) {
-						FontTexture::SetPadding(value);
-					} else if (key == &quot;stuffing&quot;) {
-						FontTexture::SetStuffing(value);
-					} else if (key == &quot;debug&quot;) {
-						FontTexture::SetDebugLevel(value);
-					}
-				}
-			}
-		}
-	}
-	lua_pushboolean(L, FontTexture::Execute());
-	return 1;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::SetUnitDefIcon(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2)) {
-		luaL_error(L,
-			&quot;Incorrect arguments to SetUnitDefIcon(unitDefID, \&quot;icon\&quot;)&quot;);
-	}
-	const int unitDefID = (int)lua_tonumber(L, 1);
-	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
-	if (ud == NULL) {
-		return 0;
-	}
-
-	ud-&gt;iconType = iconHandler-&gt;GetIcon(lua_tostring(L, 2));
-
-	// set decoys to the same icon
-	map&lt;int, set&lt;int&gt; &gt;::const_iterator fit;
-
-	if (ud-&gt;decoyDef) {
-		ud-&gt;decoyDef-&gt;iconType = ud-&gt;iconType;
-		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;decoyDef-&gt;id);
-	} else {
-		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;id);
-	}
-	if (fit != unitDefHandler-&gt;decoyMap.end()) {
-		const set&lt;int&gt;&amp; decoySet = fit-&gt;second;
-		set&lt;int&gt;::const_iterator dit;
-		for (dit = decoySet.begin(); dit != decoySet.end(); ++dit) {
-  		const UnitDef* decoyDef = unitDefHandler-&gt;GetUnitByID(*dit);
-			decoyDef-&gt;iconType = ud-&gt;iconType;
-		}
-	}
-
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetGroupList(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	if (grouphandlers[gu-&gt;myTeam] == NULL) {
-		return 0;
-	}
-	lua_newtable(L);
-	int count = 0;
-	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
-	vector&lt;CGroup*&gt;::const_iterator git;
-	for (git = groups.begin(); git != groups.end(); ++git) {
-		const CGroup* group = *git;
-		if ((group != NULL) &amp;&amp; !group-&gt;units.empty()) {
-			lua_pushnumber(L, group-&gt;id);
-			lua_pushnumber(L, group-&gt;units.size());
-			lua_rawset(L, -3);
-			count++;
-		}
-	}
-	lua_pushnumber(L, count);
-	return 2;
-}
-
-
-int CLuaUI::GetSelectedGroup(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, selectedUnits.selectedGroup);
-	return 1;
-}
-
-
-int CLuaUI::GetGroupAIList(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_newtable(L);
-	const map&lt;AIKey, string&gt;&amp; availableAI = grouphandlers[gu-&gt;myTeam]-&gt;availableAI;
-	map&lt;AIKey, string&gt;::const_iterator it;
-	int count = 0;
-	for (it = availableAI.begin(); it != availableAI.end(); ++it) {
-		count++;
-		lua_pushnumber(L, count);
-		lua_pushstring(L, it-&gt;second.c_str());
-		lua_rawset(L, -3);
-	}
-	lua_pushstring(L, &quot;n&quot;);
-	lua_pushnumber(L, count);
-	lua_rawset(L, -3);
-	return 1;
-}
-
-
-int CLuaUI::GetGroupAIName(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to GetGroupAIName(groupID)&quot;);
-	}
-
-	const int groupID = (int)lua_tonumber(L, 1);
-	if ((groupID &lt; 0) || (groupID &gt;= (int)grouphandlers[gu-&gt;myTeam]-&gt;groups.size())) {
-		return 0; // bad group
-	}
-
-	const CGroup* group = grouphandlers[gu-&gt;myTeam]-&gt;groups[groupID];
-	if (group-&gt;ai == NULL) {
-		lua_pushstring(L, &quot;&quot;);
-		return 1;
-	}
-
-	const AIKey&amp; aikey = group-&gt;currentAiKey;
-	const map&lt;AIKey, string&gt;&amp; availableAI = grouphandlers[gu-&gt;myTeam]-&gt;availableAI;
-	map&lt;AIKey, string&gt;::const_iterator fit = availableAI.find(aikey);
-	if (fit == availableAI.end()) {
-		lua_pushstring(L, &quot;&quot;); // should not happen?
-	} else {
-		lua_pushstring(L, fit-&gt;second.c_str());
-	}
-	return 1;
-}
-
-
-int CLuaUI::GetUnitGroup(lua_State* L)
-{
-	CUnit* unit = ParseRawUnit(L, __FUNCTION__, 1);
-	if (unit == NULL) {
-		return 0;
-	}
-	if ((unit-&gt;team == gu-&gt;myTeam) &amp;&amp; (unit-&gt;group)) {
-		lua_pushnumber(L, unit-&gt;group-&gt;id);
-		return 1;
-	}
-	return 0;
-}
-
-
-int CLuaUI::SetUnitGroup(lua_State* L)
-{
-	if (gs-&gt;noHelperAIs) {
-		return 0;
-	}
-
-	CUnit* unit = ParseRawUnit(L, __FUNCTION__, 1);
-	if (unit == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L);
-	if ((args &lt; 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetUnitGroup()&quot;);
-	}
-	const int groupID = (int)lua_tonumber(L, 2);
-
-	if (groupID == -1) {
-		unit-&gt;SetGroup(NULL);
-		return 0;
-	}
-
-	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
-	if ((groupID &lt; 0) || (groupID &gt;= (int)groups.size())) {
-		return 0;
-	}
-
-	CGroup* group = groups[groupID];
-	if (group != NULL) {
-		unit-&gt;SetGroup(group);
-	}
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetGroupUnits(lua_State* L)
-{
-	const int groupID = (int)luaL_checknumber(L, 1);
-	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
-	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
-	    (groups[groupID] == NULL)) {
-		return 0; // nils
-	}
-
-	lua_newtable(L);
-	int count = 0;
-	const CUnitSet&amp; groupUnits = groups[groupID]-&gt;units;
-	CUnitSet::const_iterator it;
-	for (it = groupUnits.begin(); it != groupUnits.end(); ++it) {
-		count++;
-		lua_pushnumber(L, count);
-		lua_pushnumber(L, (*it)-&gt;id);
-		lua_rawset(L, -3);
-	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, count);
-
-	return 1;
-}
-
-
-int CLuaUI::GetGroupUnitsSorted(lua_State* L)
-{
-	const int groupID = (int)luaL_checknumber(L, 1);
-	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
-	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
-	    (groups[groupID] == NULL)) {
-		return 0; // nils
-	}
-
-	map&lt;int, vector&lt;CUnit*&gt; &gt; unitDefMap;
-	const CUnitSet&amp; groupUnits = groups[groupID]-&gt;units;
-	CUnitSet::const_iterator it;
-	for (it = groupUnits.begin(); it != groupUnits.end(); ++it) {
-		CUnit* unit = *it;
-		unitDefMap[unit-&gt;unitDef-&gt;id].push_back(unit);
-	}
-
-	lua_newtable(L);
-	map&lt;int, vector&lt;CUnit*&gt; &gt;::const_iterator mit;
-	for (mit = unitDefMap.begin(); mit != unitDefMap.end(); mit++) {
-		lua_pushnumber(L, mit-&gt;first); // push the UnitDef index
-		lua_newtable(L); {
-			const vector&lt;CUnit*&gt;&amp; v = mit-&gt;second;
-			for (int i = 0; i &lt; (int)v.size(); i++) {
-				CUnit* unit = v[i];
-				lua_pushnumber(L, i + 1);
-				lua_pushnumber(L, unit-&gt;id);
-				lua_rawset(L, -3);
-			}
-			HSTR_PUSH_NUMBER(L, &quot;n&quot;, v.size());
-		}
-		lua_rawset(L, -3);
-	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, unitDefMap.size());
-
-	return 1;
-}
-
-
-int CLuaUI::GetGroupUnitsCounts(lua_State* L)
-{
-	const int groupID = (int)luaL_checknumber(L, 1);
-	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
-	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
-	    (groups[groupID] == NULL)) {
-		return 0; // nils
-	}
-
-	map&lt;int, int&gt; countMap;
-	const CUnitSet&amp; groupUnits = groups[groupID]-&gt;units;
-	CUnitSet::const_iterator it;
-	for (it = groupUnits.begin(); it != groupUnits.end(); ++it) {
-		CUnit* unit = *it;
-		const int udID = unit-&gt;unitDef-&gt;id;
-		map&lt;int, int&gt;::iterator mit = countMap.find(udID);
-		if (mit == countMap.end()) {
-			countMap[udID] = 1;
-		} else {
-			mit-&gt;second++;
-		}
-	}
-
-	lua_newtable(L);
-	map&lt;int, int&gt;::const_iterator mit;
-	for (mit = countMap.begin(); mit != countMap.end(); mit++) {
-		lua_pushnumber(L, mit-&gt;first);  // push the UnitDef index
-		lua_pushnumber(L, mit-&gt;second); // push the UnitDef unit count
-		lua_rawset(L, -3);
-	}
-	HSTR_PUSH_NUMBER(L, &quot;n&quot;, countMap.size());
-
-	return 1;
-}
-
-
-int CLuaUI::GetGroupUnitsCount(lua_State* L)
-{
-	const int groupID = (int)luaL_checknumber(L, 1);
-	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
-	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
-	    (groups[groupID] == NULL)) {
-		return 0; // nils
-	}
-	lua_pushnumber(L, groups[groupID]-&gt;units.size());
-	return 1;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-int CLuaUI::GetMyPlayerID(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, gu-&gt;myPlayerNum);
-	return 1;
-}
-
-
-int CLuaUI::GetMyTeamID(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, gu-&gt;myTeam);
-	return 1;
-}
-
-
-int CLuaUI::GetMyAllyTeamID(lua_State* L)
-{
-	CheckNoArgs(L, __FUNCTION__);
-	lua_pushnumber(L, gu-&gt;myAllyTeam);
-	return 1;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-
-static void ParseUnitMap(lua_State* L, const char* caller,
-                         int table, vector&lt;int&gt;&amp; unitIDs)
-{
-	if (!lua_istable(L, table)) {
-		luaL_error(L, &quot;%s(): error parsing unit map&quot;, caller);
-	}
-	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2)) {
-			CUnit* unit = ParseCtrlUnit(L, __FUNCTION__, -2); // the key
-			if (unit != NULL) {
-				unitIDs.push_back(unit-&gt;id);
-			}
-		}
-	}
-}
-
-
-static void ParseUnitArray(lua_State* L, const char* caller,
-                           int table, vector&lt;int&gt;&amp; unitIDs)
-{
-	if (!lua_istable(L, table)) {
-		luaL_error(L, &quot;%s(): error parsing unit array&quot;, caller);
-	}
-	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
-		if (lua_israwnumber(L, -2) &amp;&amp; lua_isnumber(L, -1)) {   // avoid 'n'
-			CUnit* unit = ParseCtrlUnit(L, __FUNCTION__, -1); // the value
-			if (unit != NULL) {
-				unitIDs.push_back(unit-&gt;id);
-			}
-		}
-	}
-	return;
-}
-
-
-/******************************************************************************/
-
-static bool CanGiveOrders()
-{
-	if (gu-&gt;spectating &amp;&amp; !gs-&gt;godMode) {
-		return false;
-	}
-	if (gs-&gt;noHelperAIs) {
-		return false;
-	}
-	if (gs-&gt;frameNum &lt;= 0) {
-		return false;
-	}
-	return true;
-}
-
-
-int CLuaUI::GiveOrder(lua_State* L)
-{
-	if (!CanGiveOrders()) {
-		return 1;
-	}
-
-	Command cmd;
-	LuaUtils::ParseCommand(L, __FUNCTION__, 1, cmd);
-
-	selectedUnits.GiveCommand(cmd);
-
-	lua_pushboolean(L, true);
-
-	return 1;
-}
-
-
-int CLuaUI::GiveOrderToUnit(lua_State* L)
-{
-	if (!CanGiveOrders()) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	CUnit* unit = ParseCtrlUnit(L, __FUNCTION__, 1);
-	if (unit == NULL) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	Command cmd;
-	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
-
-	net-&gt;Send(CBaseNetProtocol::Get().SendAICommand(gu-&gt;myPlayerNum, unit-&gt;id, cmd.id, cmd.options, cmd.params));
-
-	lua_pushboolean(L, true);
-	return 1;
-}
-
-
-int CLuaUI::GiveOrderToUnitMap(lua_State* L)
-{
-	if (!CanGiveOrders()) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	// unitIDs
-	vector&lt;int&gt; unitIDs;
-	ParseUnitMap(L, __FUNCTION__, 1, unitIDs);
-	const int count = (int)unitIDs.size();
-
-	if (count &lt;= 0) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	Command cmd;
-	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
-
-	vector&lt;Command&gt; commands;
-	commands.push_back(cmd);
-	selectedUnits.SendCommandsToUnits(unitIDs, commands);
-
-	lua_pushboolean(L, true);
-	return 1;
-}
-
-
-int CLuaUI::GiveOrderToUnitArray(lua_State* L)
-{
-	if (!CanGiveOrders()) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	// unitIDs
-	vector&lt;int&gt; unitIDs;
-	ParseUnitArray(L, __FUNCTION__, 1, unitIDs);
-	const int count = (int)unitIDs.size();
-
-	if (count &lt;= 0) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	Command cmd;
-	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
-
-	vector&lt;Command&gt; commands;
-	commands.push_back(cmd);
-	selectedUnits.SendCommandsToUnits(unitIDs, commands);
-
-	lua_pushboolean(L, true);
-	return 1;
-}
-
-
-int CLuaUI::GiveOrderArrayToUnitMap(lua_State* L)
-{
-	if (!CanGiveOrders()) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	// unitIDs
-	vector&lt;int&gt; unitIDs;
-	ParseUnitMap(L, __FUNCTION__, 1, unitIDs);
-
-	// commands
-	vector&lt;Command&gt; commands;
-	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
-
-	if ((unitIDs.size() &lt;= 0) || (commands.size() &lt;= 0)) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	selectedUnits.SendCommandsToUnits(unitIDs, commands);
-
-	lua_pushboolean(L, true);
-	return 1;
-}
-
-
-int CLuaUI::GiveOrderArrayToUnitArray(lua_State* L)
-{
-	if (!CanGiveOrders()) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	// unitIDs
-	vector&lt;int&gt; unitIDs;
-	ParseUnitArray(L, __FUNCTION__, 1, unitIDs);
-
-	// commands
-	vector&lt;Command&gt; commands;
-	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
-
-	if ((unitIDs.size() &lt;= 0) || (commands.size() &lt;= 0)) {
-		lua_pushboolean(L, false);
-		return 1;
-	}
-
-	selectedUnits.SendCommandsToUnits(unitIDs, commands);
-
-	lua_pushboolean(L, true);
-	return 1;
-}
-
-
-/******************************************************************************/
-
-static string GetRawMsg(lua_State* L, const char* caller, int index)
-{
-	if (!lua_israwstring(L, index)) {
-		luaL_error(L, &quot;Incorrect arguments to %s&quot;, caller);
-	}
-	size_t len;
-	const char* str = lua_tolstring(L, index, &amp;len);
-	const string tmpMsg(str, len);
-	return tmpMsg;
-}
-
-
-int CLuaUI::SendLuaUIMsg(lua_State* L)
-{
-	const string msg = GetRawMsg(L, __FUNCTION__, 1);
-	const string mode = luaL_optstring(L, 2, &quot;&quot;);
-	unsigned char modeNum = 0;
-	if ((mode == &quot;s&quot;) || (mode == &quot;specs&quot;)) {
-		modeNum = 's';
-	}
-	else if ((mode == &quot;a&quot;) || (mode == &quot;allies&quot;)) {
-		modeNum = 'a';
-	}
-	else if (!mode.empty()) {
-		luaL_error(L, &quot;Unknown SendLuaUIMsg() mode&quot;);
-	}
-	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_UI, modeNum, msg));
-	return 0;
-}
-
-
-int CLuaUI::SendLuaGaiaMsg(lua_State* L)
-{
-	const string msg = GetRawMsg(L, __FUNCTION__, 1);
-	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_GAIA, 0, msg));
-	return 0;
-}
-
-
-int CLuaUI::SendLuaRulesMsg(lua_State* L)
-{
-	const string msg = GetRawMsg(L, __FUNCTION__, 1);
-	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_RULES, 0, msg));
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::SetShareLevel(lua_State* L)
-{
-	if (gu-&gt;spectating || gs-&gt;noHelperAIs || (gs-&gt;frameNum &lt;= 0)) {
-		return 0;
-	}
-
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isstring(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to SetShareLevel(\&quot;type\&quot;, level&quot;);
-	}
-
-	const string shareType = lua_tostring(L, 1);
-	const float shareLevel = max(0.0f, min(1.0f, (float)lua_tonumber(L, 2)));
-
-	if (shareType == &quot;metal&quot;) {
-		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, shareLevel, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare));
-	}
-	else if (shareType == &quot;energy&quot;) {
-		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam,	gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, shareLevel));
-	}
-	else {
-		logOutput.Print(&quot;SetShareLevel() unknown resource: %s&quot;, shareType.c_str());
-	}
-	return 0;
-}
-
-
-int CLuaUI::ShareResources(lua_State* L)
-{
-	if (gu-&gt;spectating || gs-&gt;noHelperAIs || (gs-&gt;frameNum &lt;= 0)) {
-		return 0;
-	}
-
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2) ||
-	    ((args &gt;= 3) &amp;&amp; !lua_isnumber(L, 3))) {
-		luaL_error(L, &quot;Incorrect arguments to ShareResources()&quot;);
-	}
-	const int teamID = (int)lua_tonumber(L, 1);
-	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
-		return 0;
-	}
-	const CTeam* team = gs-&gt;Team(teamID);
-	if ((team == NULL) || team-&gt;isDead) {
-		return 0;
-	}
-	const string&amp; type = lua_tostring(L, 2);
-	if (type == &quot;units&quot;) {
-		// update the selection, and clear the unit command queues
-		Command c;
-		c.id = CMD_STOP;
-		selectedUnits.GiveCommand(c, false);
-		net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 1, 0.0f, 0.0f));
-		selectedUnits.ClearSelected();
-	}
-	else if (args &gt;= 3) {
-		const float amount = (float)lua_tonumber(L, 3);
-		if (type == &quot;metal&quot;) {
-			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, amount, 0.0f));
-		}
-		else if (type == &quot;energy&quot;) {
-			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, 0.0f, amount));
-		}
-	}
-	return 0;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
-
-int CLuaUI::MarkerAddPoint(lua_State* L)
-{
-	if (inMapDrawer == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2)  || !lua_isnumber(L, 3) ||
-	    ((args &gt;= 4) &amp;&amp; !lua_isstring(L, 4))) {
-		luaL_error(L, &quot;Incorrect arguments to MarkerAddPoint(x, y, z[, text])&quot;);
-	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
-	string text = &quot;&quot;;
-	if (args &gt;= 4) {
-	  text = lua_tostring(L, 4);
-	}
-
-	inMapDrawer-&gt;SendPoint(pos, text);
-
-	return 0;
-}
-
-
-int CLuaUI::MarkerAddLine(lua_State* L)
-{
-	if (inMapDrawer == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 6) ||
-	    !lua_isstring(L, 1) || !lua_isnumber(L, 2) ||
-	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4) ||
-	    !lua_isnumber(L, 5) || !lua_isnumber(L, 6)) {
-		luaL_error(L,
-			&quot;Incorrect arguments to MarkerAddLine(x1, y1, z1, x2, y2, z2)&quot;);
-	}
-	const float3 pos1((float)lua_tonumber(L, 1),
-	                  (float)lua_tonumber(L, 2),
-	                  (float)lua_tonumber(L, 3));
-	const float3 pos2((float)lua_tonumber(L, 4),
-	                  (float)lua_tonumber(L, 5),
-	                  (float)lua_tonumber(L, 6));
-
-	inMapDrawer-&gt;SendLine(pos1, pos2);
-
-	return 0;
-}
-
-
-int CLuaUI::MarkerErasePosition(lua_State* L)
-{
-	if (inMapDrawer == NULL) {
-		return 0;
-	}
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 3) ||
-	    !lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to MarkerDeletePositionl(x, y, z)&quot;);
-	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
-
-	inMapDrawer-&gt;SendErase(pos);
-
-	return 0;
-}
-
-
-/******************************************************************************/
-
-int CLuaUI::GetPlayerTraffic(lua_State* L)
-{
-	const int playerID = (int)luaL_checknumber(L, 1);
-	const int packetID =   (int)luaL_optnumber(L, 2, -1);
-
-	const std::map&lt;int, CGame::PlayerTrafficInfo&gt;&amp; traffic
-		= game-&gt;GetPlayerTraffic();
-	std::map&lt;int, CGame::PlayerTrafficInfo&gt;::const_iterator it;
-	it = traffic.find(playerID);
-	if (it == traffic.end()) {
-		lua_pushnumber(L, -1);
-		return 1;
-	}
-
-	// only allow viewing stats for specific packet types
-	if ((playerID != -1) &amp;&amp;              // all system counts can be read
-	    (playerID != gu-&gt;myPlayerNum) &amp;&amp; // all  self  counts can be read
-	    (packetID != -1) &amp;&amp;
-	    (packetID != NETMSG_CHAT)     &amp;&amp;
-	    (packetID != NETMSG_PAUSE)    &amp;&amp;
-	    (packetID != NETMSG_LUAMSG)   &amp;&amp;
-	    (packetID != NETMSG_STARTPOS) &amp;&amp;
-	    (packetID != NETMSG_USER_SPEED)) {
-    lua_pushnumber(L, -1);
-    return 1;
-  }
-
-	const CGame::PlayerTrafficInfo&amp; pti = it-&gt;second;
-	if (packetID == -1) {
-		lua_pushnumber(L, pti.total);
-		return 1;
-	}
-	std::map&lt;int, int&gt;::const_iterator pit = pti.packets.find(packetID);
-	if (pit == pti.packets.end()) {
-		lua_pushnumber(L, -1);
-		return 1;
-	}
-	lua_pushnumber(L, pit-&gt;second);
-	return 1;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/

Modified: trunk/rts/Game/UI/LuaUI.h
===================================================================
--- trunk/rts/Game/UI/LuaUI.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/LuaUI.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -64,35 +64,10 @@
 
 		bool ConfigCommand(const string&amp; command);
 
-		bool CommandNotify(const Command&amp; cmd);
-
-		bool KeyPress(unsigned short key, bool isRepeat);
-		bool KeyRelease(unsigned short key);
-		bool MouseMove(int x, int y, int dx, int dy, int button);
-		bool MousePress(int x, int y, int button);
-		int  MouseRelease(int x, int y, int button); // return a cmd index, or -1
-		bool MouseWheel(bool up, float value);
-		bool IsAbove(int x, int y);
-		string GetTooltip(int x, int y);
-
 		bool AddConsoleLines();
 
-		bool GroupChanged(int groupID);
-
 		void ShockFront(float power, const float3&amp; pos, float areaOfEffect);
 
-		bool GameSetup(const string&amp; state, bool&amp; ready,
-		               const map&lt;int, string&gt;&amp; playerStates);
-
-		string WorldTooltip(const CUnit* unit,
-		                     const CFeature* feature,
-		                     const float3* groundPos);
-
-		bool MapDrawCmd(int playerID, int type,
-		                const float3* pos0,
-		                const float3* pos1,
-		                const string* labe);
-
 	public: // custom call-in
 		bool HasUnsyncedXCall(const string&amp; funcName);
 		int UnsyncedXCall(lua_State* srcState, const string&amp; funcName);
@@ -127,101 +102,8 @@
 		float shockFrontMinPower;
 		float shockFrontDistAdj;
 
-		bool haveWorldTooltip;
-		bool haveMapDrawCmd;
-
 	private: // call-outs
-		static int GetConfigInt(lua_State* L);
-		static int SetConfigInt(lua_State* L);
-		static int GetConfigString(lua_State* L);
-		static int SetConfigString(lua_State* L);
-
-		static int CreateDir(lua_State* L);
-		static int MakeFont(lua_State* L);
-		static int SetUnitDefIcon(lua_State* L);
-
-		static int GetFPS(lua_State* L);
-
-		static int GetMouseState(lua_State* L);
-		static int GetMouseMiniMapState(lua_State* L);
-		static int GetMouseStartPosition(lua_State* L);
-		static int WarpMouse(lua_State* L);
-
-		static int SetCameraOffset(lua_State* L);
-
 		static int SetShockFrontFactors(lua_State* L);
-
-		static int SetLosViewColors(lua_State* L);
-
-		static int SetMouseCursor(lua_State* L);
-		static int GetMouseCursor(lua_State* L);
-
-		static int GetKeyState(lua_State* L);
-		static int GetModKeyState(lua_State* L);
-		static int GetPressedKeys(lua_State* L);
-		static int GetInvertQueueKey(lua_State* L);
-
-		static int SetActiveCommand(lua_State* L);
-		static int GetActiveCommand(lua_State* L);
-		static int GetDefaultCommand(lua_State* L);
-		static int GetActiveCmdDescs(lua_State* L);
-		static int GetActiveCmdDesc(lua_State* L);
-		static int GetCmdDescIndex(lua_State* L);
-
-		static int GetGatherMode(lua_State* L);
-
-		static int GetBuildFacing(lua_State* L);
-		static int GetBuildSpacing(lua_State* L);
-
-		static int GetActivePage(lua_State* L);
-		static int ForceLayoutUpdate(lua_State* L);
-
-		static int GetConsoleBuffer(lua_State* L);
-		static int GetCurrentTooltip(lua_State* L);
-
-		static int GetKeyCode(lua_State* L);
-		static int GetKeySymbol(lua_State* L);
-		static int GetKeyBindings(lua_State* L);
-		static int GetActionHotKeys(lua_State* L);
-
-		static int GetGroupList(lua_State* L);
-		static int GetSelectedGroup(lua_State* L);
-		static int GetGroupAIName(lua_State* L);
-		static int GetGroupAIList(lua_State* L);
-
-		static int SendCommands(lua_State* L);
-
-		static int SetShareLevel(lua_State* L);
-		static int ShareResources(lua_State* L);
-
-		static int GetMyAllyTeamID(lua_State* L);
-		static int GetMyTeamID(lua_State* L);
-		static int GetMyPlayerID(lua_State* L);
-
-		static int SetUnitGroup(lua_State* L);
-		static int GetUnitGroup(lua_State* L);
-
-		static int GetGroupUnits(lua_State* L);
-		static int GetGroupUnitsSorted(lua_State* L);
-		static int GetGroupUnitsCounts(lua_State* L);
-		static int GetGroupUnitsCount(lua_State* L);
-
-		static int GiveOrder(lua_State* L);
-		static int GiveOrderToUnit(lua_State* L);
-		static int GiveOrderToUnitMap(lua_State* L);
-		static int GiveOrderToUnitArray(lua_State* L);
-		static int GiveOrderArrayToUnitMap(lua_State* L);
-		static int GiveOrderArrayToUnitArray(lua_State* L);
-
-		static int SendLuaUIMsg(lua_State* L);
-		static int SendLuaGaiaMsg(lua_State* L);
-		static int SendLuaRulesMsg(lua_State* L);
-
-		static int MarkerAddPoint(lua_State* L);
-		static int MarkerAddLine(lua_State* L);
-		static int MarkerErasePosition(lua_State* L);
-
-		static int GetPlayerTraffic(lua_State* L);
 };
 
 

Modified: trunk/rts/Game/UI/MouseHandler.cpp
===================================================================
--- trunk/rts/Game/UI/MouseHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/MouseHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -14,7 +14,6 @@
 #include &quot;CommandColors.h&quot;
 #include &quot;InputReceiver.h&quot;
 #include &quot;GuiHandler.h&quot;
-#include &quot;LuaUI.h&quot;
 #include &quot;MiniMap.h&quot;
 #include &quot;MouseCursor.h&quot;
 #include &quot;MouseInput.h&quot;
@@ -27,6 +26,8 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapDamage.h&quot;
+#include &quot;Lua/LuaCallInHandler.h&quot;
+#include &quot;Lua/LuaInputReceiver.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Rendering/glFont.h&quot;
@@ -242,10 +243,9 @@
 					return;
 				}
 			}
-			if (guihandler != NULL) {
-				// this includes LuaUI
-				if (guihandler-&gt;MousePress(x, y, button)) {
-					activeReceiver = guihandler;
+			if (luaInputReceiver != NULL) {
+				if (luaInputReceiver-&gt;MousePress(x, y, button)) {
+					activeReceiver = luaInputReceiver;
 					return;
 				}
 			}
@@ -473,7 +473,7 @@
 void CMouseHandler::MouseWheel(bool up)
 {
 	const float value = up ? +scrollWheelSpeed : -scrollWheelSpeed;
-	if (luaUI &amp;&amp; luaUI-&gt;MouseWheel(up, value)) {
+	if (luaCallIns.MouseWheel(up, value)) {
 		return;
 	}
 	camHandler-&gt;GetCurrentController().MouseWheelMove(value);

Modified: trunk/rts/Game/UI/ShareBox.cpp
===================================================================
--- trunk/rts/Game/UI/ShareBox.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/ShareBox.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -181,7 +181,6 @@
 		if (team &gt;= gu-&gt;myTeam) {
 			actualTeam++;
 		}
-		//if (gs-&gt;Team(actualTeam)-&gt;gaia) continue;
 
 		const float alpha = (shareTeam == actualTeam) ? 0.8f : 0.4f;
 		std::string teamName;

Modified: trunk/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- trunk/rts/Game/UI/TooltipConsole.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Game/UI/TooltipConsole.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -1,6 +1,5 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;TooltipConsole.h&quot;
-#include &quot;LuaUI.h&quot;
 #include &quot;MouseHandler.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/glFont.h&quot;
@@ -11,6 +10,7 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Lua/LuaCallInHandler.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -180,11 +180,9 @@
 
 std::string CTooltipConsole::MakeUnitString(const CUnit* unit)
 {
-	if (luaUI) {
-		string custom = luaUI-&gt;WorldTooltip(unit, NULL, NULL);
-		if (!custom.empty()) {
-			return custom;
-		}
+	string custom = luaCallIns.WorldTooltip(unit, NULL, NULL);
+	if (!custom.empty()) {
+		return custom;
 	}
 
 	std::string s;
@@ -299,11 +297,9 @@
 
 std::string CTooltipConsole::MakeFeatureString(const CFeature* feature)
 {
-	if (luaUI) {
-		string custom = luaUI-&gt;WorldTooltip(NULL, feature, NULL);
-		if (!custom.empty()) {
-			return custom;
-		}
+	string custom = luaCallIns.WorldTooltip(NULL, feature, NULL);
+	if (!custom.empty()) {
+		return custom;
 	}
 
 	std::string s;
@@ -333,11 +329,9 @@
 
 std::string CTooltipConsole::MakeGroundString(const float3&amp; pos)
 {
-	if (luaUI) {
-		string custom = luaUI-&gt;WorldTooltip(NULL, NULL, &amp;pos);
-		if (!custom.empty()) {
-			return custom;
-		}
+	string custom = luaCallIns.WorldTooltip(NULL, NULL, &amp;pos);
+	if (!custom.empty()) {
+		return custom;
 	}
 
 	char tmp[512];

Modified: trunk/rts/Lua/LuaCallInHandler.cpp
===================================================================
--- trunk/rts/Lua/LuaCallInHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaCallInHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -19,8 +19,10 @@
 
 CLuaCallInHandler::CLuaCallInHandler()
 {
+	mouseOwner = NULL;
+
 	callInMap[&quot;GamePreload&quot;]         = &listGamePreload;
-	callInMap[&quot;GameStart&quot;]    = &listGameStart;
+	callInMap[&quot;GameStart&quot;]           = &listGameStart;
 	callInMap[&quot;GameOver&quot;]            = &listGameOver;
 	callInMap[&quot;TeamDied&quot;]            = &listTeamDied;
 
@@ -41,6 +43,11 @@
 	callInMap[&quot;UnitLeftRadar&quot;]       = &listUnitLeftRadar;
 	callInMap[&quot;UnitLeftLos&quot;]         = &listUnitLeftLos;
 
+	callInMap[&quot;UnitEnteredWater&quot;]    = &listUnitEnteredWater;
+	callInMap[&quot;UnitEnteredAir&quot;]      = &listUnitEnteredAir;
+	callInMap[&quot;UnitLeftWater&quot;]       = &listUnitLeftWater;
+	callInMap[&quot;UnitLeftAir&quot;]         = &listUnitLeftAir;
+
 	callInMap[&quot;UnitLoaded&quot;]          = &listUnitLoaded;
 	callInMap[&quot;UnitUnloaded&quot;]        = &listUnitUnloaded;
 
@@ -56,6 +63,8 @@
 
 	callInMap[&quot;Update&quot;]              = &listUpdate;
 
+	callInMap[&quot;ViewResize&quot;]          = &listViewResize;
+
 	callInMap[&quot;DefaultCommand&quot;]      = &listDefaultCommand;
 
 	callInMap[&quot;DrawGenesis&quot;]         = &listDrawGenesis;
@@ -67,6 +76,22 @@
 	callInMap[&quot;DrawScreenEffects&quot;]   = &listDrawScreenEffects;
 	callInMap[&quot;DrawScreen&quot;]          = &listDrawScreen;
 	callInMap[&quot;DrawInMiniMap&quot;]       = &listDrawInMiniMap;
+
+  // from LuaUI
+  callInMap[&quot;KeyPress&quot;]        = &listKeyPress;
+  callInMap[&quot;KeyRelease&quot;]      = &listKeyRelease;
+  callInMap[&quot;MouseMove&quot;]       = &listMouseMove;
+  callInMap[&quot;MousePress&quot;]      = &listMousePress;
+  callInMap[&quot;MouseRelease&quot;]    = &listMouseRelease;
+  callInMap[&quot;MouseWheel&quot;]      = &listMouseWheel;
+  callInMap[&quot;IsAbove&quot;]         = &listIsAbove;
+  callInMap[&quot;GetTooltip&quot;]      = &listGetTooltip;
+  callInMap[&quot;CommandNotify&quot;]   = &listCommandNotify;
+  callInMap[&quot;AddConsoleLine&quot;]  = &listAddConsoleLine;
+  callInMap[&quot;GroupChanged&quot;]    = &listGroupChanged;
+  callInMap[&quot;GameSetup&quot;]       = &listGameSetup;
+  callInMap[&quot;WorldTooltip&quot;]    = &listWorldTooltip;
+  callInMap[&quot;MapDrawCmd&quot;]      = &listMapDrawCmd;
 }
 
 
@@ -108,6 +133,11 @@
 	ADDHANDLE(UnitLeftRadar);
 	ADDHANDLE(UnitLeftLos);
 
+	ADDHANDLE(UnitEnteredWater);
+	ADDHANDLE(UnitEnteredAir);
+	ADDHANDLE(UnitLeftWater);
+	ADDHANDLE(UnitLeftAir);
+
 	ADDHANDLE(UnitLoaded);
 	ADDHANDLE(UnitUnloaded);
 
@@ -123,6 +153,8 @@
 
 	ADDHANDLE(Update);
 
+	ADDHANDLE(ViewResize);
+
 	ADDHANDLE(DefaultCommand);
 
 	ADDHANDLE(DrawGenesis);
@@ -134,11 +166,31 @@
 	ADDHANDLE(DrawScreenEffects);
 	ADDHANDLE(DrawScreen);
 	ADDHANDLE(DrawInMiniMap);
+
+  // from LuaUI
+  ADDHANDLE(KeyPress);
+  ADDHANDLE(KeyRelease);
+  ADDHANDLE(MouseMove);
+  ADDHANDLE(MousePress);
+  ADDHANDLE(MouseRelease);
+  ADDHANDLE(MouseWheel);
+  ADDHANDLE(IsAbove);
+  ADDHANDLE(GetTooltip);
+  ADDHANDLE(CommandNotify);
+  ADDHANDLE(AddConsoleLine);
+  ADDHANDLE(GroupChanged);
+  ADDHANDLE(GameSetup);
+  ADDHANDLE(WorldTooltip);
+  ADDHANDLE(MapDrawCmd);
 }
 
 
 void CLuaCallInHandler::RemoveHandle(CLuaHandle* lh)
 {
+	if (mouseOwner == lh) {
+		mouseOwner == NULL;
+	}
+
 	ListRemove(handles, lh);
 
 	ListRemove(listGamePreload, lh);
@@ -165,6 +217,11 @@
 	ListRemove(listUnitLeftRadar, lh);
 	ListRemove(listUnitLeftLos, lh);
 
+	ListRemove(listUnitEnteredWater, lh);
+	ListRemove(listUnitEnteredAir, lh);
+	ListRemove(listUnitLeftWater, lh);
+	ListRemove(listUnitLeftAir, lh);
+
 	ListRemove(listUnitLoaded, lh);
 	ListRemove(listUnitUnloaded, lh);
 
@@ -180,6 +237,8 @@
 
 	ListRemove(listUpdate, lh);
 
+	ListRemove(listViewResize, lh);
+
 	ListRemove(listDefaultCommand, lh);
 
 	ListRemove(listDrawGenesis, lh);
@@ -191,6 +250,22 @@
 	ListRemove(listDrawScreenEffects, lh);
 	ListRemove(listDrawScreen, lh);
 	ListRemove(listDrawInMiniMap, lh);
+
+  // from LuaUI
+  ListRemove(listKeyPress, lh);
+  ListRemove(listKeyRelease, lh);
+  ListRemove(listMouseMove, lh);
+  ListRemove(listMousePress, lh);
+  ListRemove(listMouseRelease, lh);
+  ListRemove(listMouseWheel, lh);
+  ListRemove(listIsAbove, lh);
+  ListRemove(listGetTooltip, lh);
+  ListRemove(listCommandNotify, lh);
+  ListRemove(listAddConsoleLine, lh);
+  ListRemove(listGroupChanged, lh);
+  ListRemove(listGameSetup, lh);
+  ListRemove(listWorldTooltip, lh);
+  ListRemove(listMapDrawCmd, lh);
 }
 
 
@@ -207,6 +282,7 @@
 {
 	if ((ciName == &quot;Update&quot;)              ||
 	    (ciName == &quot;DefaultCommand&quot;)      ||
+	    (ciName == &quot;ViewResize&quot;)          ||
 	    (ciName == &quot;DrawGenesis&quot;)         ||
 	    (ciName == &quot;DrawWorld&quot;)           ||
 	    (ciName == &quot;DrawWorldPreUnit&quot;)    ||
@@ -217,7 +293,22 @@
 	    (ciName == &quot;DrawScreen&quot;)          ||
 	    (ciName == &quot;DrawInMiniMap&quot;)       ||
 	    (ciName == &quot;DrawUnit&quot;)            ||
-	    (ciName == &quot;AICallIn&quot;)) {
+	    (ciName == &quot;AICallIn&quot;)            ||
+      // from LuaUI
+      (ciName == &quot;KeyPress&quot;)            ||
+      (ciName == &quot;KeyRelease&quot;)          ||
+      (ciName == &quot;MouseMove&quot;)           ||
+      (ciName == &quot;MousePress&quot;)          ||
+      (ciName == &quot;MouseRelease&quot;)        ||
+      (ciName == &quot;MouseWheel&quot;)          ||
+      (ciName == &quot;IsAbove&quot;)             ||
+      (ciName == &quot;GetTooltip&quot;)          ||
+      (ciName == &quot;CommandNotify&quot;)       ||
+      (ciName == &quot;AddConsoleLine&quot;)      ||
+      (ciName == &quot;GroupChanged&quot;)        ||
+      (ciName == &quot;GameSetup&quot;)           ||
+      (ciName == &quot;WorldTooltip&quot;)        ||
+      (ciName == &quot;MapDrawCmd&quot;)) {
 		return true;
 	}
 	return false;
@@ -333,6 +424,16 @@
 }
 
 
+void CLuaCallInHandler::ViewResize()
+{
+	const int count = listViewResize.size();
+	for (int i = 0; i &lt; count; i++) {
+		CLuaHandle* lh = listViewResize[i];
+		lh-&gt;ViewResize();
+	}
+}
+
+
 #define DRAW_CALLIN(name)                         \
   void CLuaCallInHandler:: Draw ## name ()        \
   {                                               \
@@ -366,3 +467,235 @@
 
 /******************************************************************************/
 /******************************************************************************/
+//
+// from LuaUI
+//
+
+
+static inline bool CheckModUICtrl(const CLuaHandle* lh)
+{
+	return CLuaHandle::GetModUICtrl() || 
+	       CLuaHandle::GetActiveHandle()-&gt;GetUserMode();
+}
+
+
+
+
+bool CLuaCallInHandler::CommandNotify(const Command&amp; cmd)
+{
+	// reverse order, user has the override
+	const int count = listCommandNotify.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listCommandNotify[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;CommandNotify(cmd)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+bool CLuaCallInHandler::KeyPress(unsigned short key, bool isRepeat)
+{
+	// reverse order, user has the override
+	const int count = listKeyPress.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listKeyPress[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;KeyPress(key, isRepeat)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+bool CLuaCallInHandler::KeyRelease(unsigned short key)
+{
+	// reverse order, user has the override
+	const int count = listKeyRelease.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listKeyRelease[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;KeyRelease(key)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+bool CLuaCallInHandler::MousePress(int x, int y, int button)
+{
+	// reverse order, user has the override
+	const int count = listMousePress.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listMousePress[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;MousePress(x, y, button)) {
+				mouseOwner = lh;
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+// return a cmd index, or -1
+int CLuaCallInHandler::MouseRelease(int x, int y, int button)
+{
+	if (mouseOwner == NULL) {
+		return -1;
+	}
+	const int retval = mouseOwner-&gt;MouseRelease(x, y, button);
+	mouseOwner = NULL;
+	return retval;
+}
+
+
+bool CLuaCallInHandler::MouseMove(int x, int y, int dx, int dy, int button)
+{
+	if (mouseOwner == NULL) {
+		return false;
+	}
+	return mouseOwner-&gt;MouseMove(x, y, dx, dy, button);
+}
+
+
+bool CLuaCallInHandler::MouseWheel(bool up, float value)
+{
+	// reverse order, user has the override
+	const int count = listMouseWheel.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listMouseWheel[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;MouseWheel(up, value)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+bool CLuaCallInHandler::IsAbove(int x, int y)
+{
+	// reverse order, user has the override
+	const int count = listIsAbove.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listIsAbove[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;IsAbove(x, y)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+string CLuaCallInHandler::GetTooltip(int x, int y)
+{
+	// reverse order, user has the override
+	const int count = listGetTooltip.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listGetTooltip[i];
+		if (CheckModUICtrl(lh)) {
+			const string tt = lh-&gt;GetTooltip(x, y);
+			if (!tt.empty()) {
+				return tt;
+			}
+		}
+	}
+	return &quot;&quot;;
+}
+
+
+bool CLuaCallInHandler::AddConsoleLine(const string&amp; msg, int zone)
+{
+	const int count = listAddConsoleLine.size();
+	for (int i = 0; i &lt; count; i++) {
+		CLuaHandle* lh = listAddConsoleLine[i];
+		if (CheckModUICtrl(lh)) {
+			lh-&gt;AddConsoleLine(msg, zone);
+		}
+	}
+	return true;
+}
+
+
+bool CLuaCallInHandler::GroupChanged(int groupID)
+{
+	const int count = listGroupChanged.size();
+	for (int i = 0; i &lt; count; i++) {
+		CLuaHandle* lh = listGroupChanged[i];
+		if (CheckModUICtrl(lh)) {
+			lh-&gt;GroupChanged(groupID);
+		}
+	}
+	return false;
+}
+
+
+
+bool CLuaCallInHandler::GameSetup(const string&amp; state, bool&amp; ready,
+                                  const map&lt;int, string&gt;&amp; playerStates)
+{
+	// reverse order, user has the override
+	const int count = listGameSetup.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listGameSetup[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;GameSetup(state, ready, playerStates)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+string CLuaCallInHandler::WorldTooltip(const CUnit* unit,
+                                       const CFeature* feature,
+                                       const float3* groundPos)
+{
+	// reverse order, user has the override
+	const int count = listWorldTooltip.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listWorldTooltip[i];
+		if (CheckModUICtrl(lh)) {
+			const string tt = lh-&gt;WorldTooltip(unit, feature, groundPos);
+			if (!tt.empty()) {
+				return tt;
+			}
+		}
+	}
+	return &quot;&quot;;
+}
+
+
+bool CLuaCallInHandler::MapDrawCmd(int playerID, int type,
+                                   const float3* pos0, const float3* pos1,
+                                   const string* label)
+{
+	// reverse order, user has the override
+	const int count = listMapDrawCmd.size();
+	for (int i = (count - 1); i &gt;= 0; i--) {
+		CLuaHandle* lh = listMapDrawCmd[i];
+		if (CheckModUICtrl(lh)) {
+			if (lh-&gt;MapDrawCmd(playerID, type, pos0, pos1, label)) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Modified: trunk/rts/Lua/LuaCallInHandler.h
===================================================================
--- trunk/rts/Lua/LuaCallInHandler.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaCallInHandler.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -21,6 +21,8 @@
 
 class CUnit;
 class CWeapon;
+class CFeature;
+struct Command;
 
 
 class CLuaCallInHandler
@@ -68,6 +70,11 @@
 		void UnitLeftRadar(const CUnit* unit, int allyTeam);
 		void UnitLeftLos(const CUnit* unit, int allyTeam);
 
+		void UnitEnteredWater(const CUnit* unit);
+		void UnitEnteredAir(const CUnit* unit);
+		void UnitLeftWater(const CUnit* unit);
+		void UnitLeftAir(const CUnit* unit);
+
 		void UnitLoaded(const CUnit* unit, const CUnit* transport);
 		void UnitUnloaded(const CUnit* unit, const CUnit* transport);
 
@@ -85,6 +92,8 @@
 		// Unsynced
 		void Update();
 
+		void ViewResize();
+
 		bool DefaultCommand(const CUnit* unit, const CFeature* feature, int&amp; cmd);
 
 		void DrawGenesis();
@@ -97,6 +106,36 @@
 		void DrawScreen();
 		void DrawInMiniMap();
 
+		// from LuaUI
+		bool KeyPress(unsigned short key, bool isRepeat);
+		bool KeyRelease(unsigned short key);
+		bool MouseMove(int x, int y, int dx, int dy, int button);
+		bool MousePress(int x, int y, int button);
+		int  MouseRelease(int x, int y, int button); // return a cmd index, or -1
+		bool MouseWheel(bool up, float value);
+		bool IsAbove(int x, int y);
+		string GetTooltip(int x, int y);
+
+		bool CommandNotify(const Command&amp; cmd);
+
+		bool AddConsoleLine(const string&amp; msg, int zone);
+
+		bool GroupChanged(int groupID);
+
+		bool GameSetup(const string&amp; state, bool&amp; ready,
+		               const map&lt;int, string&gt;&amp; playerStates);
+
+		string WorldTooltip(const CUnit* unit,
+		                    const CFeature* feature,
+		                    const float3* groundPos);
+
+		bool MapDrawCmd(int playerID, int type,
+		                const float3* pos0,
+		                const float3* pos1,
+		                const string* labe);
+
+//FIXME		void ShockFront(float power, const float3&amp; pos, float areaOfEffect);
+
 	private:
 		typedef vector&lt;CLuaHandle*&gt; CallInList;
 
@@ -105,6 +144,9 @@
 		void ListRemove(CallInList&amp; ciList, CLuaHandle* lh);
 
 	private:
+		CLuaHandle* mouseOwner;
+
+	private:
 		map&lt;string, CallInList*&gt; callInMap;
 
 		CallInList handles;
@@ -132,6 +174,11 @@
 		CallInList listUnitLeftRadar;
 		CallInList listUnitLeftLos;
 
+		CallInList listUnitEnteredWater;
+		CallInList listUnitEnteredAir;
+		CallInList listUnitLeftWater;
+		CallInList listUnitLeftAir;
+
 		CallInList listUnitLoaded;
 		CallInList listUnitUnloaded;
 
@@ -147,6 +194,8 @@
 
 		CallInList listUpdate;
 
+		CallInList listViewResize;
+
 		CallInList listDefaultCommand;
 
 		CallInList listDrawGenesis;
@@ -158,6 +207,23 @@
 		CallInList listDrawScreenEffects;
 		CallInList listDrawScreen;
 		CallInList listDrawInMiniMap;
+
+		// from LuaUI
+		CallInList listKeyPress;
+		CallInList listKeyRelease;
+		CallInList listMouseMove;
+		CallInList listMousePress;
+		CallInList listMouseRelease;
+		CallInList listMouseWheel;
+		CallInList listIsAbove;
+		CallInList listGetTooltip;
+		CallInList listConfigCommand;
+		CallInList listCommandNotify;
+		CallInList listAddConsoleLine;
+		CallInList listGroupChanged;
+		CallInList listGameSetup;
+		CallInList listWorldTooltip;
+		CallInList listMapDrawCmd;
 };
 
 
@@ -199,6 +265,10 @@
 UNIT_CALLIN_NO_PARAM(Idle)
 UNIT_CALLIN_NO_PARAM(Cloaked)
 UNIT_CALLIN_NO_PARAM(Decloaked)
+UNIT_CALLIN_NO_PARAM(EnteredWater)
+UNIT_CALLIN_NO_PARAM(EnteredAir)
+UNIT_CALLIN_NO_PARAM(LeftWater)
+UNIT_CALLIN_NO_PARAM(LeftAir)
 
 
 #define UNIT_CALLIN_INT_PARAM(name)                                       \

Modified: trunk/rts/Lua/LuaConstGame.cpp
===================================================================
--- trunk/rts/Lua/LuaConstGame.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaConstGame.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -135,6 +135,8 @@
 	LuaPushNamedNumber(L, &quot;fireAtKilled&quot;,    modInfo.fireAtKilled);
 	LuaPushNamedNumber(L, &quot;fireAtCrashing&quot;,  modInfo.fireAtCrashing);
 
+	LuaPushNamedNumber(L, &quot;requireSonarUnderWater&quot;, modInfo.requireSonarUnderWater);
+
 	char buf[64];
 	SNPRINTF(buf, sizeof(buf), &quot;0x%08X&quot;,
 	         archiveScanner-&gt;GetMapChecksum(mapInfo-&gt;map.name));

Modified: trunk/rts/Lua/LuaHandle.cpp
===================================================================
--- trunk/rts/Lua/LuaHandle.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaHandle.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -5,6 +5,9 @@
 
 #include &quot;LuaHandle.h&quot;
 #include &lt;string&gt;
+#include &lt;SDL_keysym.h&gt;
+#include &lt;SDL_mouse.h&gt;
+#include &lt;SDL_timer.h&gt;
 
 #include &quot;Game/UI/LuaUI.h&quot;
 #include &quot;Lua/LuaGaia.h&quot;
@@ -15,20 +18,28 @@
 #include &quot;LuaHashString.h&quot;
 #include &quot;LuaOpenGL.h&quot;
 #include &quot;LuaBitOps.h&quot;
+#include &quot;LuaUtils.h&quot;
 #include &quot;Game/Player.h&quot;
+#include &quot;Game/UI/KeyCodes.h&quot;
+#include &quot;Game/UI/KeySet.h&quot;
+#include &quot;Game/UI/KeyBindings.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
+#include &quot;Rendering/InMapDraw.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;System/LogOutput.h&quot;
+#include &quot;System/SpringApp.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 
 #include &quot;LuaInclude.h&quot;
 
+extern Uint8 *keys;
 
 bool CLuaHandle::devMode = false;
+bool CLuaHandle::modUICtrl = true;
 
 CLuaHandle* CLuaHandle::activeHandle = NULL;
 bool CLuaHandle::activeFullRead    = false;
@@ -168,7 +179,6 @@
 
 bool CLuaHandle::RunCallIn(const LuaHashString&amp; hs, int inArgs, int outArgs)
 {
-//	logOutput.Print(&quot;RunCallIn: %s %s\n&quot;, hs.GetString().c_str(), name.c_str());fflush(stdout);//FIXME
 	CLuaHandle* orig = activeHandle;
 	SetActiveHandle();
 	const int error = lua_pcall(L, inArgs, outArgs, 0);
@@ -186,6 +196,16 @@
 }
 
 
+inline bool CLuaHandle::RunCallInUnsynced(const LuaHashString&amp; hs,
+                                          int inArgs, int outArgs)
+{
+	synced = false;
+	const bool retval = RunCallIn(hs, inArgs, outArgs);
+	synced = !userMode;
+	return retval;
+}
+
+
 /******************************************************************************/
 
 void CLuaHandle::Shutdown()
@@ -264,33 +284,30 @@
 
 /******************************************************************************/
 
-void CLuaHandle::UnitCreated(const CUnit* unit, const CUnit* builder)
+inline void CLuaHandle::UnitCallIn(const LuaHashString&amp; hs, const CUnit* unit)
 {
 	LUA_CALL_IN_CHECK(L);	
-	lua_checkstack(L, 6);
-	static const LuaHashString cmdStr(&quot;UnitCreated&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
+	lua_checkstack(L, 5);
+	if (!hs.GetGlobalFunc(L)) {
 		return; // the call is not defined
 	}
 
 	lua_pushnumber(L, unit-&gt;id);
 	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
 	lua_pushnumber(L, unit-&gt;team);
-	if (builder != NULL) {
-		lua_pushnumber(L, builder-&gt;id);
-	}
 
 	// call the routine
-	RunCallIn(cmdStr, (builder != NULL) ? 4 : 3, 0);
+	RunCallIn(hs, 3, 0);
+
 	return;
 }
 
 
-void CLuaHandle::UnitFinished(const CUnit* unit)
+void CLuaHandle::UnitCreated(const CUnit* unit, const CUnit* builder)
 {
 	LUA_CALL_IN_CHECK(L);	
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;UnitFinished&quot;);
+	lua_checkstack(L, 6);
+	static const LuaHashString cmdStr(&quot;UnitCreated&quot;);
 	if (!cmdStr.GetGlobalFunc(L)) {
 		return; // the call is not defined
 	}
@@ -298,13 +315,24 @@
 	lua_pushnumber(L, unit-&gt;id);
 	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
 	lua_pushnumber(L, unit-&gt;team);
+	if (builder != NULL) {
+		lua_pushnumber(L, builder-&gt;id);
+	}
 
 	// call the routine
-	RunCallIn(cmdStr, 3, 0);
+	RunCallIn(cmdStr, (builder != NULL) ? 4 : 3, 0);
 	return;
 }
 
 
+void CLuaHandle::UnitFinished(const CUnit* unit)
+{
+	static const LuaHashString cmdStr(&quot;UnitFinished&quot;);
+	UnitCallIn(cmdStr, unit);
+	return;
+}
+
+
 void CLuaHandle::UnitFromFactory(const CUnit* unit,
                                  const CUnit* factory, bool userOrders)
 {
@@ -396,19 +424,8 @@
 
 void CLuaHandle::UnitIdle(const CUnit* unit)
 {
-	LUA_CALL_IN_CHECK(L);	
-	lua_checkstack(L, 5);
 	static const LuaHashString cmdStr(&quot;UnitIdle&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return; // the call is not defined
-	}
-
-	lua_pushnumber(L, unit-&gt;id);
-	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
-	lua_pushnumber(L, unit-&gt;team);
-
-	// call the routine
-	RunCallIn(cmdStr, 3, 0);
+	UnitCallIn(cmdStr, unit);
 	return;
 }
 
@@ -618,46 +635,58 @@
 
 /******************************************************************************/
 
-void CLuaHandle::UnitCloaked(const CUnit* unit)
+void CLuaHandle::UnitEnteredWater(const CUnit* unit)
 {
-	LUA_CALL_IN_CHECK(L);	
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;UnitCloaked&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return; // the call is not defined
-	}
+	static const LuaHashString cmdStr(&quot;UnitEnteredWater&quot;);
+	UnitCallIn(cmdStr, unit);
+	return;
+}
 
-	lua_pushnumber(L, unit-&gt;id);
-	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
-	lua_pushnumber(L, unit-&gt;team);
 
-	// call the routine
-	RunCallIn(cmdStr, 3, 0);
+void CLuaHandle::UnitEnteredAir(const CUnit* unit)
+{
+	static const LuaHashString cmdStr(&quot;UnitEnteredAir&quot;);
+	UnitCallIn(cmdStr, unit);
 	return;
 }
 
 
-void CLuaHandle::UnitDecloaked(const CUnit* unit)
+void CLuaHandle::UnitLeftWater(const CUnit* unit)
 {
-	LUA_CALL_IN_CHECK(L);	
-	lua_checkstack(L, 5);
-	static const LuaHashString cmdStr(&quot;UnitDecloaked&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return; // the call is not defined
-	}
+	static const LuaHashString cmdStr(&quot;UnitLeftWater&quot;);
+	UnitCallIn(cmdStr, unit);
+	return;
+}
 
-	lua_pushnumber(L, unit-&gt;id);
-	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
-	lua_pushnumber(L, unit-&gt;team);
 
-	// call the routine
-	RunCallIn(cmdStr, 3, 0);
+void CLuaHandle::UnitLeftAir(const CUnit* unit)
+{
+	static const LuaHashString cmdStr(&quot;UnitLeftAir&quot;);
+	UnitCallIn(cmdStr, unit);
 	return;
 }
 
 
 /******************************************************************************/
 
+void CLuaHandle::UnitCloaked(const CUnit* unit)
+{
+	static const LuaHashString cmdStr(&quot;UnitCloaked&quot;);
+	UnitCallIn(cmdStr, unit);
+	return;
+}
+
+
+void CLuaHandle::UnitDecloaked(const CUnit* unit)
+{
+	static const LuaHashString cmdStr(&quot;UnitDecloaked&quot;);
+	UnitCallIn(cmdStr, unit);
+	return;
+}
+
+
+/******************************************************************************/
+
 void CLuaHandle::FeatureCreated(const CFeature* feature)
 {
 	LUA_CALL_IN_CHECK(L);	
@@ -858,13 +887,39 @@
 		return;
 	}
 
-	synced = false;
+	// call the routine
+	RunCallInUnsynced(cmdStr, 0, 0);
 
+	return;
+}
+
+
+void CLuaHandle::ViewResize()
+{
+	LUA_CALL_IN_CHECK(L);	
+	lua_checkstack(L, 5);
+	static const LuaHashString cmdStr(&quot;ViewResize&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return;
+	}
+
+	lua_newtable(L);
+	LuaPushNamedNumber(L, &quot;screenSizeX&quot;, gu-&gt;screenSizeX);
+	LuaPushNamedNumber(L, &quot;screenSizeY&quot;, gu-&gt;screenSizeY);
+	LuaPushNamedNumber(L, &quot;screenPosX&quot;,  0.0f);
+	LuaPushNamedNumber(L, &quot;screenPosY&quot;,  0.0f);
+	LuaPushNamedNumber(L, &quot;windowSizeX&quot;, gu-&gt;winSizeX);
+	LuaPushNamedNumber(L, &quot;windowSizeY&quot;, gu-&gt;winSizeY);
+	LuaPushNamedNumber(L, &quot;windowPosX&quot;,  gu-&gt;winPosX);
+	LuaPushNamedNumber(L, &quot;windowPosY&quot;,  gu-&gt;winPosY);
+	LuaPushNamedNumber(L, &quot;viewSizeX&quot;,   gu-&gt;viewSizeX);
+	LuaPushNamedNumber(L, &quot;viewSizeY&quot;,   gu-&gt;viewSizeY);
+	LuaPushNamedNumber(L, &quot;viewPosX&quot;,    gu-&gt;viewPosX);
+	LuaPushNamedNumber(L, &quot;viewPosY&quot;,    gu-&gt;viewPosY);
+
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 1, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -904,13 +959,9 @@
 	}
 */
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, args, 1);
+	RunCallInUnsynced(cmdStr, args, 1);
 
-	synced = !userMode;
-
 	if (!lua_isnumber(L, 1)) {
 		lua_pop(L, 1);
 		return false;
@@ -933,13 +984,9 @@
 		return;
 	}
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 0, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -953,13 +1000,9 @@
 		return;
 	}
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 0, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -973,13 +1016,9 @@
 		return;
 	}
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 0, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -993,13 +1032,9 @@
 		return;
 	}
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 0, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -1013,13 +1048,9 @@
 		return;
 	}
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 0, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -1033,13 +1064,9 @@
 		return;
 	}
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 0, 0);
+	RunCallInUnsynced(cmdStr, 0, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -1056,13 +1083,9 @@
 	lua_pushnumber(L, gu-&gt;viewSizeX);
 	lua_pushnumber(L, gu-&gt;viewSizeY);
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 2, 0);
+	RunCallInUnsynced(cmdStr, 2, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -1079,13 +1102,9 @@
 	lua_pushnumber(L, gu-&gt;viewSizeX);
 	lua_pushnumber(L, gu-&gt;viewSizeY);
 
-	synced = false;
-
 	// call the routine
-	RunCallIn(cmdStr, 2, 0);
+	RunCallInUnsynced(cmdStr, 2, 0);
 
-	synced = !userMode;
-
 	return;
 }
 
@@ -1110,18 +1129,524 @@
 	lua_pushnumber(L, xSize);
 	lua_pushnumber(L, ySize);
 
-	synced = false;
+	// call the routine
+	RunCallInUnsynced(cmdStr, 2, 0);
 
+	return;
+}
+
+/******************************************************************************/
+/******************************************************************************/
+
+bool CLuaHandle::KeyPress(unsigned short key, bool isRepeat)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 6);
+	static const LuaHashString cmdStr(&quot;KeyPress&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined, do not take the event
+	}
+
+	lua_pushnumber(L, key);
+
+	lua_newtable(L);
+	HSTR_PUSH_BOOL(L, &quot;alt&quot;,   !!keys[SDLK_LALT]);
+	HSTR_PUSH_BOOL(L, &quot;ctrl&quot;,  !!keys[SDLK_LCTRL]);
+	HSTR_PUSH_BOOL(L, &quot;meta&quot;,  !!keys[SDLK_LMETA]);
+	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!keys[SDLK_LSHIFT]);
+
+	lua_pushboolean(L, isRepeat);
+
+	CKeySet ks(key, false);
+	lua_pushstring(L, ks.GetString(true).c_str());
+
+	lua_pushnumber(L, currentUnicode);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 5, 1)) {
+		return false;
+	}
+
+	// const int args = lua_gettop(L); unused
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::KeyRelease(unsigned short key)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 5);
+	static const LuaHashString cmdStr(&quot;KeyRelease&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined, do not take the event
+	}
+
+	lua_pushnumber(L, key);
+
+	lua_newtable(L);
+	HSTR_PUSH_BOOL(L, &quot;alt&quot;,   !!keys[SDLK_LALT]);
+	HSTR_PUSH_BOOL(L, &quot;ctrl&quot;,  !!keys[SDLK_LCTRL]);
+	HSTR_PUSH_BOOL(L, &quot;meta&quot;,  !!keys[SDLK_LMETA]);
+	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!keys[SDLK_LSHIFT]);
+
+	CKeySet ks(key, false);
+	lua_pushstring(L, ks.GetString(true).c_str());
+
+	lua_pushnumber(L, currentUnicode);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 4, 1)) {
+		return false;
+	}
+
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::MousePress(int x, int y, int button)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 5);
+	static const LuaHashString cmdStr(&quot;MousePress&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined, do not take the event
+	}
+
+	lua_pushnumber(L, x - gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
+	lua_pushnumber(L, button);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 3, 1)) {
+		return false;
+	}
+
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+int CLuaHandle::MouseRelease(int x, int y, int button)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 5);
+	static const LuaHashString cmdStr(&quot;MouseRelease&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined, do not take the event
+	}
+
+	lua_pushnumber(L, x - gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
+	lua_pushnumber(L, button);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 3, 1)) {
+		return false;
+	}
+
+	if (!lua_isnumber(L, -1)) {
+		lua_pop(L, 1);
+		return -1;
+	}
+	const int retval = (int)lua_tonumber(L, -1) - 1;
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::MouseMove(int x, int y, int dx, int dy, int button)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 7);
+	static const LuaHashString cmdStr(&quot;MouseMove&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined, do not take the event
+	}
+
+	lua_pushnumber(L, x - gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
+	lua_pushnumber(L, dx);
+	lua_pushnumber(L, -dy);
+	lua_pushnumber(L, button);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 5, 1)) {
+		return false;
+	}
+
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::MouseWheel(bool up, float value)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 4);
+	static const LuaHashString cmdStr(&quot;MouseWheel&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined, do not take the event
+	}
+
+	lua_pushboolean(L, up);
+	lua_pushnumber(L, value);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 2, 1)) {
+		return false;
+	}
+
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::IsAbove(int x, int y)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 4);
+	static const LuaHashString cmdStr(&quot;IsAbove&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined
+	}
+
+	lua_pushnumber(L, x - gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 2, 1)) {
+		return false;
+	}
+
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+string CLuaHandle::GetTooltip(int x, int y)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 4);
+	static const LuaHashString cmdStr(&quot;GetTooltip&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return &quot;&quot;; // the call is not defined
+	}
+
+	lua_pushnumber(L, x - gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewSizeY - y - 1);
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 2, 1)) {
+		return &quot;&quot;;
+	}
+
+	if (!lua_isstring(L, -1)) {
+		lua_pop(L, 1);
+		return &quot;&quot;;
+	}
+	const string retval = lua_tostring(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::ConfigCommand(const string&amp; command)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 2);
+	static const LuaHashString cmdStr(&quot;ConfigureLayout&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return true; // the call is not defined
+	}
+
+	lua_pushstring(L, command.c_str());
+
 	// call the routine
-	RunCallIn(cmdStr, 2, 0);
+	if (!RunCallInUnsynced(cmdStr, 1, 0)) {
+		return false;
+	}
+	return true;
+}
 
-	synced = !userMode;
 
-	return;
+bool CLuaHandle::CommandNotify(const Command&amp; cmd)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 5);
+	static const LuaHashString cmdStr(&quot;CommandNotify&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined
+	}
+
+	// push the command id
+	lua_pushnumber(L, cmd.id);
+
+	// push the params list
+	lua_newtable(L);
+	for (int p = 0; p &lt; (int)cmd.params.size(); p++) {
+		lua_pushnumber(L, p + 1);
+		lua_pushnumber(L, cmd.params[p]);
+		lua_rawset(L, -3);
+	}
+
+	// push the options table
+	lua_newtable(L);
+	HSTR_PUSH_NUMBER(L, &quot;coded&quot;, cmd.options);
+	HSTR_PUSH_BOOL(L, &quot;alt&quot;,   !!(cmd.options &amp; ALT_KEY));
+	HSTR_PUSH_BOOL(L, &quot;ctrl&quot;,  !!(cmd.options &amp; CONTROL_KEY));
+	HSTR_PUSH_BOOL(L, &quot;shift&quot;, !!(cmd.options &amp; SHIFT_KEY));
+	HSTR_PUSH_BOOL(L, &quot;right&quot;, !!(cmd.options &amp; RIGHT_MOUSE_KEY));
+
+	// call the function
+	if (!RunCallInUnsynced(cmdStr, 3, 1)) {
+		return false;
+	}
+
+	// get the results
+	const int args = lua_gettop(L);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;CommandNotify() bad return value (%i)\n&quot;, args);
+		lua_pop(L, 1);
+		return false;
+	}
+
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
 }
 
 
+bool CLuaHandle::AddConsoleLine(const string&amp; msg, int zone)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 4);
+	static const LuaHashString cmdStr(&quot;AddConsoleLine&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return true; // the call is not defined
+	}
+
+	lua_pushstring(L, msg.c_str());
+	lua_pushnumber(L, zone);
+
+	// call the function
+	if (!RunCallIn(cmdStr, 2, 0)) {
+		return false;
+	}
+
+	return true;
+}
+
+
+
+bool CLuaHandle::GroupChanged(int groupID)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 3);
+	static const LuaHashString cmdStr(&quot;GroupChanged&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined
+	}
+
+	lua_pushnumber(L, groupID);
+
+	// call the routine
+	if (!RunCallInUnsynced(cmdStr, 1, 0)) {
+		return false;
+	}
+
+	return true;
+}
+
+
+
+string CLuaHandle::WorldTooltip(const CUnit* unit,
+                                const CFeature* feature,
+                                const float3* groundPos)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 6);
+	static const LuaHashString cmdStr(&quot;WorldTooltip&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return &quot;&quot;; // the call is not defined
+	}
+
+	int args;
+	if (unit) {
+		HSTR_PUSH(L, &quot;unit&quot;);
+		lua_pushnumber(L, unit-&gt;id);
+		args = 2;
+	}
+	else if (feature) {
+		HSTR_PUSH(L, &quot;feature&quot;);
+		lua_pushnumber(L, feature-&gt;id);
+		args = 2;
+	}
+	else if (groundPos) {
+		HSTR_PUSH(L, &quot;ground&quot;);
+		lua_pushnumber(L, groundPos-&gt;x);
+		lua_pushnumber(L, groundPos-&gt;y);
+		lua_pushnumber(L, groundPos-&gt;z);
+		args = 4;
+	}
+	else {
+		HSTR_PUSH(L, &quot;selection&quot;);
+		args = 1;
+	}
+
+	// call the routine
+	if (!RunCallInUnsynced(cmdStr, args, 1)) {
+		return &quot;&quot;;
+	}
+
+	if (!lua_isstring(L, -1)) {
+		lua_pop(L, 1);
+		return &quot;&quot;;
+	}
+	const string retval = lua_tostring(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::MapDrawCmd(int playerID, int type,
+                            const float3* pos0,
+                            const float3* pos1,
+                            const string* label)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 9);
+	static const LuaHashString cmdStr(&quot;MapDrawCmd&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false; // the call is not defined
+	}
+
+	int args;
+
+	lua_pushnumber(L, playerID);
+
+	if (type == CInMapDraw::NET_POINT) {
+		HSTR_PUSH(L, &quot;point&quot;);
+		lua_pushnumber(L, pos0-&gt;x);
+		lua_pushnumber(L, pos0-&gt;y);
+		lua_pushnumber(L, pos0-&gt;z);
+		lua_pushstring(L, label-&gt;c_str());
+		args = 6;
+	}
+	else if (type == CInMapDraw::NET_LINE) {
+		HSTR_PUSH(L, &quot;line&quot;);
+		lua_pushnumber(L, pos0-&gt;x);
+		lua_pushnumber(L, pos0-&gt;y);
+		lua_pushnumber(L, pos0-&gt;z);
+		lua_pushnumber(L, pos1-&gt;x);
+		lua_pushnumber(L, pos1-&gt;y);
+		lua_pushnumber(L, pos1-&gt;z);
+		args = 8;
+	}
+	else if (type == CInMapDraw::NET_ERASE) {
+		HSTR_PUSH(L, &quot;erase&quot;);
+		lua_pushnumber(L, pos0-&gt;x);
+		lua_pushnumber(L, pos0-&gt;y);
+		lua_pushnumber(L, pos0-&gt;z);
+		lua_pushnumber(L, 100.0f);  // radius
+		args = 6;
+	}
+	else {
+		logOutput.Print(&quot;Unknown MapDrawCmd() type&quot;);
+		lua_pop(L, 2); // pop the function and playerID
+		return false;
+	}
+
+	// call the routine
+	if (!RunCallInUnsynced(cmdStr, args, 1)) {
+		return false;
+	}
+
+	// take the event?
+	if (!lua_isboolean(L, -1)) {
+		lua_pop(L, 1);
+		return false;
+	}
+	const bool retval = lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
+bool CLuaHandle::GameSetup(const string&amp; state, bool&amp; ready,
+                           const map&lt;int, string&gt;&amp; playerStates)
+{
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 5);
+	static const LuaHashString cmdStr(&quot;GameSetup&quot;);
+	if (!PushUnsyncedCallIn(cmdStr)) {
+		return false;
+	}
+
+	lua_pushstring(L, state.c_str());
+
+	lua_pushboolean(L, ready);
+
+	lua_newtable(L);
+	map&lt;int, string&gt;::const_iterator it;
+	for (it = playerStates.begin(); it != playerStates.end(); ++it) {
+		lua_pushnumber(L, it-&gt;first);
+		lua_pushstring(L, it-&gt;second.c_str());
+		lua_rawset(L, -3);
+	}
+
+	// call the routine
+	if (!RunCallInUnsynced(cmdStr, 3, 2)) {
+		return false;
+	}
+
+	if (lua_isboolean(L, -2)) {
+		if (lua_toboolean(L, -2)) {
+			if (lua_isboolean(L, -1)) {
+				ready = lua_toboolean(L, -1);
+			}
+			lua_pop(L, 2);
+			return true;
+		}
+	}
+	lua_pop(L, 2);
+	return false;
+}
+
+
 /******************************************************************************/
+/******************************************************************************/
 
 bool CLuaHandle::AddBasicCalls()
 {

Modified: trunk/rts/Lua/LuaHandle.h
===================================================================
--- trunk/rts/Lua/LuaHandle.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaHandle.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -26,8 +26,9 @@
 
 
 class CUnit;
+class CWeapon;
 class CFeature;
-class CWeapon;
+struct Command;
 struct LuaHashString;
 struct lua_State;
 
@@ -42,7 +43,6 @@
 		int GetCallInErrors() const { return callinErrors; }
 		void ResetCallinErrors() { callinErrors = 0; }
 		
-
 	public:
 		enum SpecialTeams {
 			NoAccessTeam   = -1,
@@ -74,7 +74,7 @@
 		int  GetCtrlTeam()     const { return ctrlTeam; }
 		int  GetSelectTeam()   const { return selectTeam; }
 
-		bool WantsToDie()      const { return killMe; }
+		bool WantsToDie() const { return killMe; }
 
 		const LuaCobCallback  GetCallback() { return cobCallback; }
 
@@ -98,6 +98,8 @@
 
 		void Update();
 
+		void ViewResize();
+
 		void Shutdown();
 
 		void GamePreload();
@@ -126,6 +128,11 @@
 		void UnitLeftRadar(const CUnit* unit, int allyTeam);
 		void UnitLeftLos(const CUnit* unit, int allyTeam);
 
+		void UnitEnteredWater(const CUnit* unit);
+		void UnitEnteredAir(const CUnit* unit);
+		void UnitLeftWater(const CUnit* unit);
+		void UnitLeftAir(const CUnit* unit);
+
 		void UnitLoaded(const CUnit* unit, const CUnit* transport);
 		void UnitUnloaded(const CUnit* unit, const CUnit* transport);
 
@@ -155,6 +162,37 @@
 		void DrawScreen();
 		void DrawInMiniMap();
 
+		// moved from LuaUI
+		bool KeyPress(unsigned short key, bool isRepeat);
+		bool KeyRelease(unsigned short key);
+		bool MouseMove(int x, int y, int dx, int dy, int button);
+		bool MousePress(int x, int y, int button);
+		int  MouseRelease(int x, int y, int button); // return a cmd index, or -1
+		bool MouseWheel(bool up, float value);
+		bool IsAbove(int x, int y);
+		string GetTooltip(int x, int y);
+
+		bool ConfigCommand(const string&amp; command);
+
+		bool CommandNotify(const Command&amp; cmd);
+
+		bool AddConsoleLine(const string&amp; msg, int zone);
+
+		bool GroupChanged(int groupID);
+
+		bool GameSetup(const string&amp; state, bool&amp; ready,
+		               const map&lt;int, string&gt;&amp; playerStates);
+
+		string WorldTooltip(const CUnit* unit,
+		                    const CFeature* feature,
+		                    const float3* groundPos);
+
+		bool MapDrawCmd(int playerID, int type,
+		                const float3* pos0,
+		                const float3* pos1,
+		                const string* labe);
+
+
 	public: // custom call-in  (inter-script calls)
 		virtual bool HasSyncedXCall(const string&amp; funcName) { return false; }
 		virtual bool HasUnsyncedXCall(const string&amp; funcName) { return false; }
@@ -181,7 +219,9 @@
 		                       bool (*entriesFunc)(lua_State*));
 
 		bool RunCallIn(const LuaHashString&amp; hs, int inArgs, int outArgs);
+		bool RunCallInUnsynced(const LuaHashString&amp; hs, int inArgs, int outArgs);
 		void LosCallIn(const LuaHashString&amp; hs, const CUnit* unit, int allyTeam);
+		void UnitCallIn(const LuaHashString&amp; hs, const CUnit* unit);
 		bool PushUnsyncedCallIn(const LuaHashString&amp; hs);
 
 	protected:
@@ -241,7 +281,7 @@
 		static const CLuaHandle* GetActiveHandle() { return activeHandle; }
 
 		static bool ActiveCanCtrlTeam(int team) {
-			return activeHandle-&gt;CanReadAllyTeam(team);
+			return activeHandle-&gt;CanCtrlTeam(team);
 		}
 		static bool ActiveCanReadAllyTeam(int allyTeam) {
 			return activeHandle-&gt;CanReadAllyTeam(allyTeam);
@@ -265,6 +305,9 @@
 		static void SetDevMode(bool value) { devMode = value; }
 		static bool GetDevMode() { return devMode; }
 
+		static void SetModUICtrl(bool value) { modUICtrl = value; }
+		static bool GetModUICtrl() { return modUICtrl; }
+
 		static void HandleLuaMsg(int playerID, int script, int mode,
 		                         const string&amp; msg);
 
@@ -274,6 +317,7 @@
 		static int  activeReadAllyTeam;
 
 		static bool devMode; // allows real file access
+		static bool modUICtrl; // allows non-user scripts to use UI controls
 };
 
 

Added: trunk/rts/Lua/LuaInputReceiver.cpp
===================================================================
--- trunk/rts/Lua/LuaInputReceiver.cpp	                        (rev 0)
+++ trunk/rts/Lua/LuaInputReceiver.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,71 @@
+#include &quot;StdAfx.h&quot;
+// LuaInputReceiver.cpp: implementation of the LuaInputReceiver class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &lt;string&gt;
+
+#include &quot;LuaInputReceiver.h&quot;
+#include &quot;LuaCallInHandler.h&quot;
+
+
+LuaInputReceiver* luaInputReceiver = NULL;
+
+
+LuaInputReceiver::LuaInputReceiver()
+: CInputReceiver(FRONT)
+{
+}
+
+
+LuaInputReceiver::~LuaInputReceiver()
+{
+}
+
+
+bool LuaInputReceiver::KeyPressed(unsigned short key, bool isRepeat)
+{
+	return luaCallIns.KeyPress(key, isRepeat);
+}
+
+
+bool LuaInputReceiver::KeyReleased(unsigned short key)
+{
+	return luaCallIns.KeyRelease(key);
+}
+
+
+bool LuaInputReceiver::MousePress(int x, int y, int button)
+{
+	return luaCallIns.MousePress(x, y, button);
+}
+
+
+void LuaInputReceiver::MouseMove(int x, int y, int dx, int dy, int button)
+{
+	luaCallIns.MouseMove(x, y, dx, dy, button);
+}
+
+
+void LuaInputReceiver::MouseRelease(int x, int y, int button)
+{
+	luaCallIns.MouseRelease(x, y, button);
+}
+
+
+bool LuaInputReceiver::IsAbove(int x, int y)
+{
+	return luaCallIns.IsAbove(x, y);
+}
+
+
+std::string LuaInputReceiver::GetTooltip(int x, int y)
+{
+	return luaCallIns.GetTooltip(x, y);
+}
+
+
+void LuaInputReceiver::Draw()
+{
+	return luaCallIns.DrawScreen();
+}

Added: trunk/rts/Lua/LuaInputReceiver.h
===================================================================
--- trunk/rts/Lua/LuaInputReceiver.h	                        (rev 0)
+++ trunk/rts/Lua/LuaInputReceiver.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,33 @@
+#ifndef LUA_INPUT_RECEIVER
+#define LUA_INPUT_RECEIVER
+
+
+#include &lt;string&gt;
+
+#include &quot;Game/UI/InputReceiver.h&quot;
+
+
+class LuaInputReceiver : public CInputReceiver
+{
+	public:
+		LuaInputReceiver();
+		~LuaInputReceiver();
+
+		bool KeyPressed(unsigned short key, bool isRepeat);
+		bool KeyReleased(unsigned short key);
+
+		bool MousePress(int x, int y, int button);
+		void MouseMove(int x, int y, int dx, int dy, int button);
+		void MouseRelease(int x, int y, int button);
+		bool IsAbove(int x, int y);
+		std::string GetTooltip(int x,int y);
+
+		void Draw();
+};
+
+
+extern LuaInputReceiver* luaInputReceiver;
+
+
+#endif /* LUA_INPUT_RECEIVER */
+

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -221,6 +221,7 @@
 	REGISTER_LUA_CFUNC(TextureInfo);
 	REGISTER_LUA_CFUNC(CopyToTexture);
 	if (GLEW_EXT_framebuffer_object) {
+		// FIXME: obsolete
 		REGISTER_LUA_CFUNC(DeleteTextureFBO);
 		REGISTER_LUA_CFUNC(RenderToTexture);
 	}
@@ -3495,6 +3496,7 @@
 }
 
 
+// FIXME: obsolete
 int LuaOpenGL::DeleteTextureFBO(lua_State* L)
 {
 	if (lua_isnil(L, 1)) {
@@ -3676,6 +3678,7 @@
 }
 
 
+// FIXME: obsolete
 int LuaOpenGL::RenderToTexture(lua_State* L)
 {
 	CheckDrawingEnabled(L, __FUNCTION__);

Modified: trunk/rts/Lua/LuaParser.cpp
===================================================================
--- trunk/rts/Lua/LuaParser.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaParser.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -886,6 +886,43 @@
 /******************************************************************************/
 /******************************************************************************/
 //
+//  Object lengths
+//
+
+int LuaTable::GetLength() const
+{
+	if (!PushTable()) {
+		return 0;
+	}
+	return lua_objlen(L, -1);
+}
+
+
+int LuaTable::GetLength(int key) const
+{
+	if (!PushValue(key)) {
+		return 0;
+	}
+	const int len = lua_objlen(L, -1);
+	lua_pop(L, 1);
+	return len;
+}
+
+
+int LuaTable::GetLength(const string&amp; key) const
+{
+	if (!PushValue(key)) {
+		return 0;
+	}
+	const int len = lua_objlen(L, -1);
+	lua_pop(L, 1);
+	return len;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
 //  Key list functions
 //
 

Modified: trunk/rts/Lua/LuaParser.h
===================================================================
--- trunk/rts/Lua/LuaParser.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaParser.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -41,7 +41,9 @@
 
 		const string&amp; GetPath() const { return path; }
 
-		int GetLength() const; // lua '#' operator
+		int GetLength() const;                  // lua '#' operator
+		int GetLength(int key) const;           // lua '#' operator
+		int GetLength(const string&amp; key) const; // lua '#' operator
 
 		bool GetKeys(vector&lt;int&gt;&amp; data) const;
 		bool GetKeys(vector&lt;string&gt;&amp; data) const;

Modified: trunk/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaSyncedRead.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -32,6 +32,7 @@
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;Rendering/UnitModels/s3oParser.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
@@ -129,6 +130,8 @@
 	REGISTER_LUA_CFUNC(GetHeadingFromVector);
 	REGISTER_LUA_CFUNC(GetVectorFromHeading);
 
+	REGISTER_LUA_CFUNC(GetSideData);
+
 	REGISTER_LUA_CFUNC(GetAllyTeamStartBox);
 	REGISTER_LUA_CFUNC(GetTeamStartPosition);
 
@@ -150,6 +153,9 @@
 	REGISTER_LUA_CFUNC(AreTeamsAllied);
 	REGISTER_LUA_CFUNC(ArePlayersAllied);
 
+	REGISTER_LUA_CFUNC(ValidUnitID);
+	REGISTER_LUA_CFUNC(ValidFeatureID);
+
 	REGISTER_LUA_CFUNC(GetAllUnits);
 	REGISTER_LUA_CFUNC(GetTeamUnits);
 	REGISTER_LUA_CFUNC(GetTeamUnitsSorted);
@@ -375,7 +381,11 @@
 	}
 	const int unitID = (int)lua_tonumber(L, index);
 	if ((unitID &lt; 0) || (unitID &gt;= MAX_UNITS)) {
-		luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
+		if (caller != NULL) {
+			luaL_error(L, &quot;%s(): Bad unitID: %i\n&quot;, caller, unitID);
+		} else {
+			return NULL;
+		}
 	}
 	CUnit* unit = uh-&gt;units[unitID];
 	if (unit == NULL) {
@@ -800,6 +810,49 @@
 
 /******************************************************************************/
 
+int LuaSyncedRead::GetSideData(lua_State* L)
+{
+	if (lua_israwstring(L, 1)) {
+		const string sideName = lua_tostring(L, 1);
+		const string&amp; startUnit = sideParser.GetStartUnit(sideName);
+		const string&amp; caseName  = sideParser.GetCaseName(sideName);
+		if (startUnit.empty()) {
+			return 0;
+		}
+		lua_pushstring(L, startUnit.c_str());
+		lua_pushstring(L, caseName.c_str());
+		return 2;
+	}
+	else if (lua_israwnumber(L, 1)) {
+		const unsigned int index = (int)lua_tonumber(L, 1) - 1;
+		if (!sideParser.ValidSide(index)) {
+			return 0;
+		}
+		lua_pushstring(L, sideParser.GetSideName(index).c_str());
+		lua_pushstring(L, sideParser.GetStartUnit(index).c_str());
+		lua_pushstring(L, sideParser.GetCaseName(index).c_str());
+		return 3;
+	}
+	else {
+		lua_newtable(L);
+		const unsigned int sideCount = sideParser.GetCount();
+		for (unsigned int i = 0; i &lt; sideCount; i++) {
+			lua_pushnumber(L, i + 1);
+			lua_newtable(L); {
+				LuaPushNamedString(L, &quot;sideName&quot;,  sideParser.GetSideName(i));
+				LuaPushNamedString(L, &quot;caseName&quot;,  sideParser.GetCaseName(i));
+				LuaPushNamedString(L, &quot;startUnit&quot;, sideParser.GetStartUnit(i));
+			}
+			lua_rawset(L, -3);
+		}
+		return 1;
+	}
+	return 0;
+}
+
+
+/******************************************************************************/
+
 int LuaSyncedRead::GetAllyTeamStartBox(lua_State* L)
 {
 	if (gameSetup == NULL) {
@@ -2236,6 +2289,14 @@
 /******************************************************************************/
 /******************************************************************************/
 
+int LuaSyncedRead::ValidUnitID(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, NULL, 1); // note the NULL
+	lua_pushboolean(L, unit != NULL);
+	return 1;
+}
+
+
 int LuaSyncedRead::GetUnitStates(lua_State* L)
 {
 	CUnit* unit = ParseAllyUnit(L, __FUNCTION__, 1);
@@ -3365,14 +3426,19 @@
 {
 	const int args = lua_gettop(L); // number of arguments
 	if ((args &lt; 1) || !lua_isnumber(L, index)) {
-		luaL_error(L, &quot;Incorrect arguments to %s(featureID)&quot;, caller);
+		if (caller != NULL) {
+			luaL_error(L, &quot;Incorrect arguments to %s(featureID)&quot;, caller);
+		} else {
+			return NULL;
+		}
 	}
 	const int featureID = (int)lua_tonumber(L, index);
 	const CFeatureSet&amp; fset = featureHandler-&gt;GetActiveFeatures();
 	CFeatureSet::const_iterator it = fset.find(featureID);
 
-	if (it == fset.end())
+	if (it == fset.end()) {
 		return NULL;
+	}
 
 	if (!IsFeatureVisible(*it)) {
 		return NULL;
@@ -3381,6 +3447,14 @@
 }
 
 
+int LuaSyncedRead::ValidFeatureID(lua_State* L)
+{
+	CFeature* feature = ParseFeature(L, NULL, 1); // note the NULL
+	lua_pushboolean(L, feature != NULL);
+	return 1;
+}
+
+
 int LuaSyncedRead::GetAllFeatures(lua_State* L)
 {
 	CheckNoArgs(L, __FUNCTION__);
@@ -3579,40 +3653,28 @@
 
 int LuaSyncedRead::GetGroundHeight(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetGroundHeight(x, z)&quot;);
-	}
-	const float x = lua_tonumber(L, 1);
-	const float y = lua_tonumber(L, 2);
+	const float x = (float)luaL_checknumber(L, 1);
+	const float z = (float)luaL_checknumber(L, 2);
 	// GetHeight2() does not clamp the value to (&gt;= 0)
-	lua_pushnumber(L, ground-&gt;GetHeight2(x, y));
+	lua_pushnumber(L, ground-&gt;GetHeight2(x, z));
 	return 1;
 }
 
 
 int LuaSyncedRead::GetGroundOrigHeight(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetGroundOrigHeight(x, z)&quot;);
-	}
-	const float x = lua_tonumber(L, 1);
-	const float y = lua_tonumber(L, 2);
-	lua_pushnumber(L, ground-&gt;GetOrigHeight(x, y));
+	const float x = (float)luaL_checknumber(L, 1);
+	const float z = (float)luaL_checknumber(L, 2);
+	lua_pushnumber(L, ground-&gt;GetOrigHeight(x, z));
 	return 1;
 }
 
 
 int LuaSyncedRead::GetGroundNormal(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetGroundNormal(x, z)&quot;);
-	}
-	const float x = lua_tonumber(L, 1);
-	const float y = lua_tonumber(L, 2);
-	const float3 normal = ground-&gt;GetSmoothNormal(x, y);
+	const float x = (float)luaL_checknumber(L, 1);
+	const float z = (float)luaL_checknumber(L, 2);
+	const float3 normal = ground-&gt;GetSmoothNormal(x, z);
 	lua_pushnumber(L, normal.x);
 	lua_pushnumber(L, normal.y);
 	lua_pushnumber(L, normal.z);
@@ -3622,14 +3684,9 @@
 
 int LuaSyncedRead::GetGroundInfo(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
-		luaL_error(L, &quot;Incorrect arguments to GetGroundInfo(x, z)&quot;);
-	}
+	const float x = (float)luaL_checknumber(L, 1);
+	const float z = (float)luaL_checknumber(L, 2);
 
-	const float x = lua_tonumber(L, 1);
-	const float z = lua_tonumber(L, 2);
-
 	const int ix = (int)(max(0.0f, min(float3::maxxpos, x)) / 16.0f);
 	const int iz = (int)(max(0.0f, min(float3::maxzpos, z)) / 16.0f);
 

Modified: trunk/rts/Lua/LuaSyncedRead.h
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaSyncedRead.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -42,6 +42,8 @@
 		static int GetHeadingFromVector(lua_State* L);
 		static int GetVectorFromHeading(lua_State* L);
 
+		static int GetSideData(lua_State* L);
+
 		static int GetAllyTeamStartBox(lua_State* L);
 		static int GetTeamStartPosition(lua_State* L);
 
@@ -82,6 +84,7 @@
 
 		static int GetFeaturesInRectangle(lua_State* L);
 
+		static int ValidUnitID(lua_State* L);
 		static int GetUnitTooltip(lua_State* L);
 		static int GetUnitDefID(lua_State* L);
 		static int GetUnitTeam(lua_State* L);
@@ -135,6 +138,7 @@
 		static int GetAllFeatures(lua_State* L);
 		static int GetFeatureList(lua_State* L);
 
+		static int ValidFeatureID(lua_State* L);
 		static int GetFeatureDefID(lua_State* L);
 		static int GetFeatureTeam(lua_State* L);
 		static int GetFeatureAllyTeam(lua_State* L);

Modified: trunk/rts/Lua/LuaTextures.h
===================================================================
--- trunk/rts/Lua/LuaTextures.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaTextures.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -33,6 +33,7 @@
 
 			GLuint id;
 
+			// FIXME: obsolete, use raw FBO's
 			GLuint fbo;
 			GLuint fboDepth;
 

Modified: trunk/rts/Lua/LuaUnitRendering.cpp
===================================================================
--- trunk/rts/Lua/LuaUnitRendering.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaUnitRendering.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -3,8 +3,6 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-#include &lt;cmath&gt;
-
 #include &quot;LuaUnitRendering.h&quot;
 #include &quot;LuaMaterial.h&quot;
 
@@ -140,7 +138,7 @@
 		return 0;
 	}
 	// adjusted for 45 degree FOV with a 1024x768 screen
-	const float scale = 2.0f * (float)std::tanf((45.0 * 0.5) * (PI / 180.0)) / 768.0f;
+	const float scale = 2.0f * (float)streflop::tanf((45.0 * 0.5) * (PI / 180.0)) / 768.0f;
 	const float dist = (float)luaL_checknumber(L, 3);
 	unit-&gt;lodLengths[lod] = dist * scale;
 	return 0;

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -11,12 +11,19 @@
 #include &lt;fstream&gt;
 using namespace std;
 
+#include &lt;SDL_keysym.h&gt;
+#include &lt;SDL_mouse.h&gt;
+#include &lt;SDL_timer.h&gt;
+
 #include &quot;LuaInclude.h&quot;
 
 #include &quot;LuaHandle.h&quot;
 #include &quot;LuaHashString.h&quot;
 #include &quot;LuaUtils.h&quot;
 
+#include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;ExternalAI/Group.h&quot;
+#include &quot;ExternalAI/GroupHandler.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/CameraHandler.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
@@ -26,21 +33,37 @@
 #include &quot;Game/Player.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;
 #include &quot;Game/UI/CursorIcons.h&quot;
+#include &quot;Game/UI/GuiHandler.h&quot;
+#include &quot;Game/UI/InfoConsole.h&quot;
+#include &quot;Game/UI/KeyCodes.h&quot;
+#include &quot;Game/UI/KeySet.h&quot;
+#include &quot;Game/UI/KeyBindings.h&quot;
+#include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;Game/UI/MouseHandler.h&quot;
+#include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/FontTexture.h&quot;
 #include &quot;Rendering/IconHandler.h&quot;
+#include &quot;Rendering/InMapDraw.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;Sim/Units/CommandAI/LineDrawer.h&quot;
 #include &quot;System/LogOutput.h&quot;
+#include &quot;System/NetProtocol.h&quot;
 #include &quot;System/Sound.h&quot;
 
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
 
 
+extern Uint8 *keys;
+
+const int CMD_INDEX_OFFSET = 1; // starting index for command descriptions
+
+
 /******************************************************************************/
 /******************************************************************************/
 
@@ -106,6 +129,53 @@
 	REGISTER_LUA_CFUNC(FreeUnitIcon);
 
 	REGISTER_LUA_CFUNC(ExtractModArchiveFile);
+
+	// moved from LuaUI
+
+//FIXME	REGISTER_LUA_CFUNC(SetShockFrontFactors);
+
+	REGISTER_LUA_CFUNC(GetConfigInt);
+	REGISTER_LUA_CFUNC(SetConfigInt);
+	REGISTER_LUA_CFUNC(GetConfigString);
+	REGISTER_LUA_CFUNC(SetConfigString);
+
+	REGISTER_LUA_CFUNC(CreateDir);
+	REGISTER_LUA_CFUNC(MakeFont);
+
+	REGISTER_LUA_CFUNC(SendCommands);
+	REGISTER_LUA_CFUNC(GiveOrder);
+	REGISTER_LUA_CFUNC(GiveOrderToUnit);
+	REGISTER_LUA_CFUNC(GiveOrderToUnitMap);
+	REGISTER_LUA_CFUNC(GiveOrderToUnitArray);
+	REGISTER_LUA_CFUNC(GiveOrderArrayToUnitMap);
+	REGISTER_LUA_CFUNC(GiveOrderArrayToUnitArray);
+
+	REGISTER_LUA_CFUNC(SendLuaUIMsg);
+	REGISTER_LUA_CFUNC(SendLuaGaiaMsg);
+	REGISTER_LUA_CFUNC(SendLuaRulesMsg);
+
+	REGISTER_LUA_CFUNC(SetActiveCommand);
+
+	REGISTER_LUA_CFUNC(ForceLayoutUpdate);
+
+	REGISTER_LUA_CFUNC(SetMouseCursor);
+	REGISTER_LUA_CFUNC(WarpMouse);
+
+	REGISTER_LUA_CFUNC(SetCameraOffset);
+
+	REGISTER_LUA_CFUNC(SetLosViewColors);
+
+	REGISTER_LUA_CFUNC(SetUnitDefIcon);
+
+	REGISTER_LUA_CFUNC(SetUnitGroup);
+
+	REGISTER_LUA_CFUNC(SetShareLevel);
+	REGISTER_LUA_CFUNC(ShareResources);
+
+	REGISTER_LUA_CFUNC(MarkerAddPoint);
+	REGISTER_LUA_CFUNC(MarkerAddLine);
+	REGISTER_LUA_CFUNC(MarkerErasePosition);
+
 	return true;
 }
 
@@ -1006,5 +1076,974 @@
 	return 1;
 }
 
+
 /******************************************************************************/
 /******************************************************************************/
+//
+// moved from LuaUI
+//
+/******************************************************************************/
+/******************************************************************************/
+
+static inline bool CheckModUICtrl()
+{
+	return CLuaHandle::GetModUICtrl() || 
+	       CLuaHandle::GetActiveHandle()-&gt;GetUserMode();
+}
+
+
+static inline void CheckNoArgs(lua_State* L, const char* funcName)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if (args != 0) {
+		luaL_error(L, &quot;%s() takes no arguments&quot;, funcName);
+	}
+}
+
+
+int LuaUnsyncedCtrl::SendCommands(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if ((guihandler == NULL) || gs-&gt;noHelperAIs) {
+		return 0;
+	}
+
+	vector&lt;string&gt; cmds;
+
+	if (lua_istable(L, 1)) { // old style -- table
+		const int table = 1;
+		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+			if (lua_israwstring(L, -1)) {
+				string action = lua_tostring(L, -1);
+				if (action[0] != '@') {
+					action = &quot;@@&quot; + action;
+				}
+				cmds.push_back(action);
+			}
+		}
+	}
+	else if (lua_israwstring(L, 1)) { // new style -- function parameters
+		for (int i = 1; lua_israwstring(L, i); i++) {
+			string action = lua_tostring(L, i);
+			if (action[0] != '@') {
+				action = &quot;@@&quot; + action;
+			}
+			cmds.push_back(action);
+		}
+	}
+	else {
+		luaL_error(L, &quot;Incorrect arguments to SendCommands()&quot;);
+	}
+
+	lua_settop(L, 0); // pop the input arguments
+
+	guihandler-&gt;RunCustomCommands(cmds, false);
+
+	return 0;
+}
+
+
+/******************************************************************************/
+
+static int SetActiveCommandByIndex(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (guihandler == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	const int cmdIndex = (int)lua_tonumber(L, 1) - CMD_INDEX_OFFSET;
+	int button = 1; // LMB
+	if ((args &gt;= 2) &amp;&amp; lua_isnumber(L, 2)) {
+		button = (int)lua_tonumber(L, 2);
+	}
+
+	if (args &lt;= 2) {
+		const bool rmb = (button == SDL_BUTTON_LEFT) ? false : true;
+		const bool success = guihandler-&gt;SetActiveCommand(cmdIndex, rmb);
+		lua_pushboolean(L, success);
+		return 1;
+	}
+
+	// cmdIndex, button, lmb, rmb, alt, ctrl, meta, shift
+	if ((args &lt; 8) ||
+	    !lua_isboolean(L, 3) || !lua_isboolean(L, 4) || !lua_isboolean(L, 5) ||
+	    !lua_isboolean(L, 6) || !lua_isboolean(L, 7) || !lua_isboolean(L, 8)) {
+		lua_pushstring(L, &quot;Incorrect arguments to SetActiveCommand()&quot;);
+	}
+	const bool lmb   = lua_toboolean(L, 3);
+	const bool rmb   = lua_toboolean(L, 4);
+	const bool alt   = lua_toboolean(L, 5);
+	const bool ctrl  = lua_toboolean(L, 6);
+	const bool meta  = lua_toboolean(L, 7);
+	const bool shift = lua_toboolean(L, 8);
+
+	const bool success = guihandler-&gt;SetActiveCommand(cmdIndex, button, lmb, rmb,
+	                                                  alt, ctrl, meta, shift);
+	lua_pushboolean(L, success);
+	return 1;
+}
+
+
+static int SetActiveCommandByAction(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (guihandler == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	const string text = lua_tostring(L, 1);
+	const Action action(text);
+	CKeySet ks;
+	if (args &gt;= 2) {
+		const string ksText = lua_tostring(L, 2);
+		ks.Parse(ksText);
+	}
+	const bool success = guihandler-&gt;SetActiveCommand(action, ks, 0);
+	lua_pushboolean(L, success);
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::SetActiveCommand(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (guihandler == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if (args &lt; 1) {
+		luaL_error(L, &quot;Incorrect arguments to SetActiveCommand()&quot;);
+	}
+	if (lua_isnumber(L, 1)) {
+		return SetActiveCommandByIndex(L);
+	}
+	if (lua_isstring(L, 1)) {
+		return SetActiveCommandByAction(L);
+	}
+	luaL_error(L, &quot;Incorrect arguments to SetActiveCommand()&quot;);
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::ForceLayoutUpdate(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (guihandler == NULL) {
+		return 0;
+	}
+	guihandler-&gt;ForceLayoutUpdate();
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::WarpMouse(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isnumber(L, 2)) {
+		luaL_error(L, &quot;Incorrect arguments to WarpMouse()&quot;);
+	}
+	const int x = (int)lua_tonumber(L, 1);
+	const int y = gu-&gt;viewSizeY - (int)lua_tonumber(L, 2) - 1;
+	mouse-&gt;WarpMouse(x, y);
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::SetMouseCursor(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 1) || !lua_isstring(L, 1) ||
+	    ((args &gt;= 2) &amp;&amp; !lua_isnumber(L, 2))) {
+		luaL_error(L,
+			&quot;Incorrect arguments to SetMouseCursor(\&quot;name\&quot;, [scale])&quot;);
+	}
+	mouse-&gt;cursorText = lua_tostring(L, 1);
+	if (args &gt;= 2) {
+		mouse-&gt;cursorScale = lua_tonumber(L, 2);
+	}
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::SetCameraOffset(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (camera == NULL) {
+		return 0;
+	}
+	const float px = (float)luaL_optnumber(L, 1, 0.0f);
+	const float py = (float)luaL_optnumber(L, 2, 0.0f);
+	const float pz = (float)luaL_optnumber(L, 3, 0.0f);
+	const float tx = (float)luaL_optnumber(L, 4, 0.0f);
+	const float ty = (float)luaL_optnumber(L, 5, 0.0f);
+	const float tz = (float)luaL_optnumber(L, 6, 0.0f);
+	camera-&gt;posOffset = float3(px, py, pz);
+	camera-&gt;tiltOffset = float3(tx, ty, tz);
+	return 0;
+}
+
+
+/******************************************************************************/
+
+static int ParseFloatArray(lua_State* L, int index, float* array, int size)
+{
+	if (!lua_istable(L, index)) {
+		return -1;
+	}
+	const int table = (index &gt; 0) ? index : (lua_gettop(L) + index + 1);
+	for (int i = 0; i &lt; size; i++) {
+		lua_rawgeti(L, table, (i + 1));
+		if (lua_isnumber(L, -1)) {
+			array[i] = (float)lua_tonumber(L, -1);
+			lua_pop(L, 1);
+		} else {
+			lua_pop(L, 1);
+			return i;
+		}
+	}
+	return size;
+}
+
+
+int LuaUnsyncedCtrl::SetLosViewColors(lua_State* L)
+{
+	float red[4];
+	float green[4];
+	float blue[4];
+	if ((ParseFloatArray(L, 1, red,   4) != 4) ||
+	    (ParseFloatArray(L, 2, green, 4) != 4) ||
+	    (ParseFloatArray(L, 3, blue,  4) != 4)) {
+		luaL_error(L, &quot;Incorrect arguments to SetLosViewColors()&quot;);
+	}
+	const int scale = CBaseGroundDrawer::losColorScale;
+	CBaseGroundDrawer *gd = readmap-&gt;GetGroundDrawer();
+	gd-&gt;alwaysColor[0] = (int)(scale *   red[0]);
+	gd-&gt;alwaysColor[1] = (int)(scale * green[0]);
+	gd-&gt;alwaysColor[2] = (int)(scale *  blue[0]);
+	gd-&gt;losColor[0]    = (int)(scale *   red[1]);
+	gd-&gt;losColor[1]    = (int)(scale * green[1]);
+	gd-&gt;losColor[2]    = (int)(scale *  blue[1]);
+	gd-&gt;radarColor[0]  = (int)(scale *   red[2]);
+	gd-&gt;radarColor[1]  = (int)(scale * green[2]);
+	gd-&gt;radarColor[2]  = (int)(scale *  blue[2]);
+	gd-&gt;jamColor[0]    = (int)(scale *   red[3]);
+	gd-&gt;jamColor[1]    = (int)(scale * green[3]);
+	gd-&gt;jamColor[2]    = (int)(scale *  blue[3]);
+	return 0;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::GetConfigInt(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 1) || (args &gt; 2) || !lua_isstring(L, 1) ||
+	    ((args == 2) &amp;&amp; !lua_isnumber(L, 2))) {
+		luaL_error(L, &quot;Incorrect arguments to GetConfigInt()&quot;);
+	}
+	const string name = lua_tostring(L, 1);
+	int def = 0;
+	if (args == 2) {
+		def = (int)lua_tonumber(L, 2);
+	}
+	const int value = configHandler.GetInt(name, def);
+	lua_pushnumber(L, value);
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::SetConfigInt(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 2) || !lua_isstring(L, 1) || !lua_isnumber(L, 2)) {
+		luaL_error(L, &quot;Incorrect arguments to SetConfigInt()&quot;);
+	}
+	const string name = lua_tostring(L, 1);
+	const int value = (int)lua_tonumber(L, 2);
+	configHandler.SetInt(name, value);
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::GetConfigString(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 1) || (args &gt; 2) || !lua_isstring(L, 1) ||
+	    ((args == 2) &amp;&amp; !lua_isstring(L, 2))) {
+		luaL_error(L, &quot;Incorrect arguments to GetConfigString()&quot;);
+	}
+	const string name = lua_tostring(L, 1);
+	string def;
+	if (args == 2) {
+		def = lua_tostring(L, 2);
+	}
+	const string value = configHandler.GetString(name, def);
+	lua_pushstring(L, value.c_str());
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::SetConfigString(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 2) || !lua_isstring(L, 1) || !lua_isstring(L, 2)) {
+		luaL_error(L, &quot;Incorrect arguments to SetConfigString()&quot;);
+	}
+	const string name = lua_tostring(L, 1);
+	const string value = lua_tostring(L, 2);
+	configHandler.SetString(name, value);
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::CreateDir(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 1) || !lua_isstring(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to CreateDir()&quot;);
+	}
+
+	// keep directories within the Spring directory
+	const string dir = lua_tostring(L, 1);
+	if ((dir[0] == '/') || (dir[0] == '\\') ||
+	    (strstr(dir.c_str(), &quot;..&quot;) != NULL) ||
+	    ((dir.size() &gt; 0) &amp;&amp; (dir[1] == ':'))) {
+		luaL_error(L, &quot;Invalid CreateDir() access: %s&quot;, dir.c_str());
+	}
+
+	const bool success = filesystem.CreateDirectory(dir);
+	lua_pushboolean(L, success);
+	return 1;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::MakeFont(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 1) || !lua_isstring(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to MakeFont()&quot;);
+	}
+	FontTexture::Reset();
+	FontTexture::SetInFileName(lua_tostring(L, 1));
+	if ((args &gt;= 2) &amp;&amp; lua_istable(L, 2)) {
+		const int table = 2;
+		for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+			if (lua_israwstring(L, -2)) {
+				const string key = lua_tostring(L, -2);
+				if (lua_type(L, -1) == LUA_TSTRING) {//lua_isstring(L, -1)) {
+					if ((key == &quot;outName&quot;) &amp;&amp; lua_isstring(L, -1)) {
+						FontTexture::SetOutBaseName(lua_tostring(L, -1));
+					}
+				}
+				else if (lua_isnumber(L, -1)) {
+					const unsigned int value = (unsigned int)lua_tonumber(L, -1);
+					if (key == &quot;height&quot;) {
+						FontTexture::SetFontHeight(value);
+					} else if (key == &quot;texWidth&quot;) {
+						FontTexture::SetTextureWidth(value);
+					} else if (key == &quot;minChar&quot;) {
+						FontTexture::SetMinChar(value);
+					} else if (key == &quot;maxChar&quot;) {
+						FontTexture::SetMaxChar(value);
+					} else if (key == &quot;outlineMode&quot;) {
+						FontTexture::SetOutlineMode(value);
+					} else if (key == &quot;outlineRadius&quot;) {
+						FontTexture::SetOutlineRadius(value);
+					} else if (key == &quot;outlineWeight&quot;) {
+						FontTexture::SetOutlineWeight(value);
+					} else if (key == &quot;padding&quot;) {
+						FontTexture::SetPadding(value);
+					} else if (key == &quot;stuffing&quot;) {
+						FontTexture::SetStuffing(value);
+					} else if (key == &quot;debug&quot;) {
+						FontTexture::SetDebugLevel(value);
+					}
+				}
+			}
+		}
+	}
+	lua_pushboolean(L, FontTexture::Execute());
+	return 1;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::SetUnitDefIcon(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2)) {
+		luaL_error(L,
+			&quot;Incorrect arguments to SetUnitDefIcon(unitDefID, \&quot;icon\&quot;)&quot;);
+	}
+	const int unitDefID = (int)lua_tonumber(L, 1);
+	const UnitDef* ud = unitDefHandler-&gt;GetUnitByID(unitDefID);
+	if (ud == NULL) {
+		return 0;
+	}
+
+	ud-&gt;iconType = iconHandler-&gt;GetIcon(lua_tostring(L, 2));
+
+	// set decoys to the same icon
+	map&lt;int, set&lt;int&gt; &gt;::const_iterator fit;
+
+	if (ud-&gt;decoyDef) {
+		ud-&gt;decoyDef-&gt;iconType = ud-&gt;iconType;
+		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;decoyDef-&gt;id);
+	} else {
+		fit = unitDefHandler-&gt;decoyMap.find(ud-&gt;id);
+	}
+	if (fit != unitDefHandler-&gt;decoyMap.end()) {
+		const set&lt;int&gt;&amp; decoySet = fit-&gt;second;
+		set&lt;int&gt;::const_iterator dit;
+		for (dit = decoySet.begin(); dit != decoySet.end(); ++dit) {
+  		const UnitDef* decoyDef = unitDefHandler-&gt;GetUnitByID(*dit);
+			decoyDef-&gt;iconType = ud-&gt;iconType;
+		}
+	}
+
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::SetUnitGroup(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (gs-&gt;noHelperAIs) {
+		return 0;
+	}
+
+	CUnit* unit = ParseRawUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L);
+	if ((args &lt; 1) || !lua_isnumber(L, 2)) {
+		luaL_error(L, &quot;Incorrect arguments to SetUnitGroup()&quot;);
+	}
+	const int groupID = (int)lua_tonumber(L, 2);
+
+	if (groupID == -1) {
+		unit-&gt;SetGroup(NULL);
+		return 0;
+	}
+
+	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
+	if ((groupID &lt; 0) || (groupID &gt;= (int)groups.size())) {
+		return 0;
+	}
+
+	CGroup* group = groups[groupID];
+	if (group != NULL) {
+		unit-&gt;SetGroup(group);
+	}
+	return 0;
+}
+
+
+/******************************************************************************/
+
+static void ParseUnitMap(lua_State* L, const char* caller,
+                         int table, vector&lt;int&gt;&amp; unitIDs)
+{
+	if (!lua_istable(L, table)) {
+		luaL_error(L, &quot;%s(): error parsing unit map&quot;, caller);
+	}
+	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+		if (lua_israwnumber(L, -2)) {
+			CUnit* unit = ParseCtrlUnit(L, __FUNCTION__, -2); // the key
+			if (unit != NULL) {
+				unitIDs.push_back(unit-&gt;id);
+			}
+		}
+	}
+}
+
+
+static void ParseUnitArray(lua_State* L, const char* caller,
+                           int table, vector&lt;int&gt;&amp; unitIDs)
+{
+	if (!lua_istable(L, table)) {
+		luaL_error(L, &quot;%s(): error parsing unit array&quot;, caller);
+	}
+	for (lua_pushnil(L); lua_next(L, table) != 0; lua_pop(L, 1)) {
+		if (lua_israwnumber(L, -2) &amp;&amp; lua_isnumber(L, -1)) {   // avoid 'n'
+			CUnit* unit = ParseCtrlUnit(L, __FUNCTION__, -1); // the value
+			if (unit != NULL) {
+				unitIDs.push_back(unit-&gt;id);
+			}
+		}
+	}
+	return;
+}
+
+
+/******************************************************************************/
+
+static bool CanGiveOrders()
+{
+	if (gs-&gt;frameNum &lt;= 0) {
+		return false;
+	}
+	if (gs-&gt;noHelperAIs) {
+		return false;
+	}
+	const CLuaHandle* lh = CLuaHandle::GetActiveHandle();
+	const int ctrlTeam = lh-&gt;GetCtrlTeam();
+	if ((ctrlTeam &gt;= 0) || (ctrlTeam == CLuaHandle::AllAccessTeam)) {
+	}
+	if (gu-&gt;spectating &amp;&amp; !gs-&gt;godMode) {
+		return false;
+	}
+	// FIXME ? (correct? warning / error?)
+	if ((ctrlTeam != gu-&gt;myTeam) || (ctrlTeam &lt; 0)) {
+		return false;
+	}
+	return true;
+}
+
+
+int LuaUnsyncedCtrl::GiveOrder(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (!CanGiveOrders()) {
+		return 1;
+	}
+
+	Command cmd;
+	LuaUtils::ParseCommand(L, __FUNCTION__, 1, cmd);
+
+	selectedUnits.GiveCommand(cmd);
+
+	lua_pushboolean(L, true);
+
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::GiveOrderToUnit(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (!CanGiveOrders()) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	CUnit* unit = ParseCtrlUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	Command cmd;
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
+
+	net-&gt;Send(CBaseNetProtocol::Get().SendAICommand(gu-&gt;myPlayerNum, unit-&gt;id, cmd.id, cmd.options, cmd.params));
+
+	lua_pushboolean(L, true);
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::GiveOrderToUnitMap(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (!CanGiveOrders()) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	// unitIDs
+	vector&lt;int&gt; unitIDs;
+	ParseUnitMap(L, __FUNCTION__, 1, unitIDs);
+	const int count = (int)unitIDs.size();
+
+	if (count &lt;= 0) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	Command cmd;
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
+
+	vector&lt;Command&gt; commands;
+	commands.push_back(cmd);
+	selectedUnits.SendCommandsToUnits(unitIDs, commands);
+
+	lua_pushboolean(L, true);
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::GiveOrderToUnitArray(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (!CanGiveOrders()) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	// unitIDs
+	vector&lt;int&gt; unitIDs;
+	ParseUnitArray(L, __FUNCTION__, 1, unitIDs);
+	const int count = (int)unitIDs.size();
+
+	if (count &lt;= 0) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	Command cmd;
+	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
+
+	vector&lt;Command&gt; commands;
+	commands.push_back(cmd);
+	selectedUnits.SendCommandsToUnits(unitIDs, commands);
+
+	lua_pushboolean(L, true);
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::GiveOrderArrayToUnitMap(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (!CanGiveOrders()) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	// unitIDs
+	vector&lt;int&gt; unitIDs;
+	ParseUnitMap(L, __FUNCTION__, 1, unitIDs);
+
+	// commands
+	vector&lt;Command&gt; commands;
+	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
+
+	if ((unitIDs.size() &lt;= 0) || (commands.size() &lt;= 0)) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	selectedUnits.SendCommandsToUnits(unitIDs, commands);
+
+	lua_pushboolean(L, true);
+	return 1;
+}
+
+
+int LuaUnsyncedCtrl::GiveOrderArrayToUnitArray(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (!CanGiveOrders()) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	// unitIDs
+	vector&lt;int&gt; unitIDs;
+	ParseUnitArray(L, __FUNCTION__, 1, unitIDs);
+
+	// commands
+	vector&lt;Command&gt; commands;
+	LuaUtils::ParseCommandArray(L, __FUNCTION__, 2, commands);
+
+	if ((unitIDs.size() &lt;= 0) || (commands.size() &lt;= 0)) {
+		lua_pushboolean(L, false);
+		return 1;
+	}
+
+	selectedUnits.SendCommandsToUnits(unitIDs, commands);
+
+	lua_pushboolean(L, true);
+	return 1;
+}
+
+
+/******************************************************************************/
+
+static string GetRawMsg(lua_State* L, const char* caller, int index)
+{
+	if (!lua_israwstring(L, index)) {
+		luaL_error(L, &quot;Incorrect arguments to %s&quot;, caller);
+	}
+	size_t len;
+	const char* str = lua_tolstring(L, index, &amp;len);
+	const string tmpMsg(str, len);
+	return tmpMsg;
+}
+
+
+int LuaUnsyncedCtrl::SendLuaUIMsg(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const string msg = GetRawMsg(L, __FUNCTION__, 1);
+	const string mode = luaL_optstring(L, 2, &quot;&quot;);
+	unsigned char modeNum = 0;
+	if ((mode == &quot;s&quot;) || (mode == &quot;specs&quot;)) {
+		modeNum = 's';
+	}
+	else if ((mode == &quot;a&quot;) || (mode == &quot;allies&quot;)) {
+		modeNum = 'a';
+	}
+	else if (!mode.empty()) {
+		luaL_error(L, &quot;Unknown SendLuaUIMsg() mode&quot;);
+	}
+	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_UI, modeNum, msg));
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::SendLuaGaiaMsg(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const string msg = GetRawMsg(L, __FUNCTION__, 1);
+	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_GAIA, 0, msg));
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::SendLuaRulesMsg(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	const string msg = GetRawMsg(L, __FUNCTION__, 1);
+	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_RULES, 0, msg));
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::SetShareLevel(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (gu-&gt;spectating || gs-&gt;noHelperAIs || (gs-&gt;frameNum &lt;= 0)) {
+		return 0;
+	}
+
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 2) || !lua_isstring(L, 1) || !lua_isnumber(L, 2)) {
+		luaL_error(L, &quot;Incorrect arguments to SetShareLevel(\&quot;type\&quot;, level&quot;);
+	}
+
+	const string shareType = lua_tostring(L, 1);
+	const float shareLevel = max(0.0f, min(1.0f, (float)lua_tonumber(L, 2)));
+
+	if (shareType == &quot;metal&quot;) {
+		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, shareLevel, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare));
+	}
+	else if (shareType == &quot;energy&quot;) {
+		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam,	gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, shareLevel));
+	}
+	else {
+		logOutput.Print(&quot;SetShareLevel() unknown resource: %s&quot;, shareType.c_str());
+	}
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::ShareResources(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (gu-&gt;spectating || gs-&gt;noHelperAIs || (gs-&gt;frameNum &lt;= 0)) {
+		return 0;
+	}
+
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 2) || !lua_isnumber(L, 1) || !lua_isstring(L, 2) ||
+	    ((args &gt;= 3) &amp;&amp; !lua_isnumber(L, 3))) {
+		luaL_error(L, &quot;Incorrect arguments to ShareResources()&quot;);
+	}
+	const int teamID = (int)lua_tonumber(L, 1);
+	if ((teamID &lt; 0) || (teamID &gt;= gs-&gt;activeTeams)) {
+		return 0;
+	}
+	const CTeam* team = gs-&gt;Team(teamID);
+	if ((team == NULL) || team-&gt;isDead) {
+		return 0;
+	}
+	const string&amp; type = lua_tostring(L, 2);
+	if (type == &quot;units&quot;) {
+		// update the selection, and clear the unit command queues
+		Command c;
+		c.id = CMD_STOP;
+		selectedUnits.GiveCommand(c, false);
+		net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 1, 0.0f, 0.0f));
+		selectedUnits.ClearSelected();
+	}
+	else if (args &gt;= 3) {
+		const float amount = (float)lua_tonumber(L, 3);
+		if (type == &quot;metal&quot;) {
+			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, amount, 0.0f));
+		}
+		else if (type == &quot;energy&quot;) {
+			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, 0.0f, amount));
+		}
+	}
+	return 0;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+int LuaUnsyncedCtrl::MarkerAddPoint(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (inMapDrawer == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 3) ||
+	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2)  || !lua_isnumber(L, 3) ||
+	    ((args &gt;= 4) &amp;&amp; !lua_isstring(L, 4))) {
+		luaL_error(L, &quot;Incorrect arguments to MarkerAddPoint(x, y, z[, text])&quot;);
+	}
+	const float3 pos((float)lua_tonumber(L, 1),
+	                 (float)lua_tonumber(L, 2),
+	                 (float)lua_tonumber(L, 3));
+	string text = &quot;&quot;;
+	if (args &gt;= 4) {
+	  text = lua_tostring(L, 4);
+	}
+
+	inMapDrawer-&gt;SendPoint(pos, text);
+
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::MarkerAddLine(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (inMapDrawer == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 6) ||
+	    !lua_isstring(L, 1) || !lua_isnumber(L, 2) ||
+	    !lua_isnumber(L, 3) || !lua_isnumber(L, 4) ||
+	    !lua_isnumber(L, 5) || !lua_isnumber(L, 6)) {
+		luaL_error(L,
+			&quot;Incorrect arguments to MarkerAddLine(x1, y1, z1, x2, y2, z2)&quot;);
+	}
+	const float3 pos1((float)lua_tonumber(L, 1),
+	                  (float)lua_tonumber(L, 2),
+	                  (float)lua_tonumber(L, 3));
+	const float3 pos2((float)lua_tonumber(L, 4),
+	                  (float)lua_tonumber(L, 5),
+	                  (float)lua_tonumber(L, 6));
+
+	inMapDrawer-&gt;SendLine(pos1, pos2);
+
+	return 0;
+}
+
+
+int LuaUnsyncedCtrl::MarkerErasePosition(lua_State* L)
+{
+	if (!CheckModUICtrl()) {
+		return 0;
+	}
+	if (inMapDrawer == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 3) ||
+	    !lua_isstring(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
+		luaL_error(L, &quot;Incorrect arguments to MarkerDeletePositionl(x, y, z)&quot;);
+	}
+	const float3 pos((float)lua_tonumber(L, 1),
+	                 (float)lua_tonumber(L, 2),
+	                 (float)lua_tonumber(L, 3));
+
+	inMapDrawer-&gt;SendErase(pos);
+
+	return 0;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+

Modified: trunk/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCtrl.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaUnsyncedCtrl.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -66,6 +66,55 @@
 		static int FreeUnitIcon(lua_State* L);
 
 		static int ExtractModArchiveFile(lua_State* L);
+
+
+		// moved from LuaUI
+
+//FIXME		static int SetShockFrontFactors(lua_State* L);
+
+		static int GetConfigInt(lua_State* L);
+		static int SetConfigInt(lua_State* L);
+		static int GetConfigString(lua_State* L);
+		static int SetConfigString(lua_State* L);
+
+		static int CreateDir(lua_State* L);
+		static int MakeFont(lua_State* L);
+
+		static int SetUnitDefIcon(lua_State* L);
+
+		static int SetActiveCommand(lua_State* L);
+
+		static int ForceLayoutUpdate(lua_State* L);
+
+		static int SetLosViewColors(lua_State* L);
+
+		static int WarpMouse(lua_State* L);
+
+		static int SetMouseCursor(lua_State* L);
+
+		static int SetCameraOffset(lua_State* L);
+
+		static int SendCommands(lua_State* L);
+
+		static int SetShareLevel(lua_State* L);
+		static int ShareResources(lua_State* L);
+
+		static int SetUnitGroup(lua_State* L);
+
+		static int GiveOrder(lua_State* L);
+		static int GiveOrderToUnit(lua_State* L);
+		static int GiveOrderToUnitMap(lua_State* L);
+		static int GiveOrderToUnitArray(lua_State* L);
+		static int GiveOrderArrayToUnitMap(lua_State* L);
+		static int GiveOrderArrayToUnitArray(lua_State* L);
+
+		static int SendLuaUIMsg(lua_State* L);
+		static int SendLuaGaiaMsg(lua_State* L);
+		static int SendLuaRulesMsg(lua_State* L);
+
+		static int MarkerAddPoint(lua_State* L);
+		static int MarkerAddLine(lua_State* L);
+		static int MarkerErasePosition(lua_State* L);
 };
 
 

Modified: trunk/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaUnsyncedRead.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -11,11 +11,16 @@
 
 #include &quot;SDL_timer.h&quot;
 #include &quot;SDL_types.h&quot;
+#include &quot;SDL_keysym.h&quot;
+#include &quot;SDL_mouse.h&quot;
 
 #include &quot;LuaInclude.h&quot;
 
 #include &quot;LuaHandle.h&quot;
 #include &quot;LuaHashString.h&quot;
+#include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;ExternalAI/Group.h&quot;
+#include &quot;ExternalAI/GroupHandler.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/Camera/CameraController.h&quot;
 #include &quot;Game/Game.h&quot;
@@ -26,6 +31,13 @@
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Game/CameraHandler.h&quot;
 #include &quot;Game/Team.h&quot;
+#include &quot;Game/UI/GuiHandler.h&quot;
+#include &quot;Game/UI/InfoConsole.h&quot;
+#include &quot;Game/UI/KeyCodes.h&quot;
+#include &quot;Game/UI/KeySet.h&quot;
+#include &quot;Game/UI/KeyBindings.h&quot;
+#include &quot;Game/UI/MiniMap.h&quot;
+#include &quot;Game/UI/MouseHandler.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/IconHandler.h&quot;
@@ -36,11 +48,17 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
+#include &quot;System/NetProtocol.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;System/FileSystem/VFSHandler.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
 
 
+extern Uint8 *keys;
+
+const int CMD_INDEX_OFFSET = 1; // starting index for command descriptions
+
+
 /******************************************************************************/
 /******************************************************************************/
 
@@ -59,11 +77,16 @@
 	lua_rawset(L, -3)
 
 	REGISTER_LUA_CFUNC(IsReplay);
+	REGISTER_LUA_CFUNC(GetModUICtrl);
 
 	REGISTER_LUA_CFUNC(GetFrameTimeOffset);
 	REGISTER_LUA_CFUNC(GetLastUpdateSeconds);
 	REGISTER_LUA_CFUNC(GetHasLag);
 
+	REGISTER_LUA_CFUNC(GetViewGeometry);
+	REGISTER_LUA_CFUNC(GetWindowGeometry);
+	REGISTER_LUA_CFUNC(GetScreenGeometry);
+
 	REGISTER_LUA_CFUNC(IsAABBInView);
 	REGISTER_LUA_CFUNC(IsSphereInView);
 
@@ -114,6 +137,59 @@
 	REGISTER_LUA_CFUNC(GetTimer);
 	REGISTER_LUA_CFUNC(DiffTimers);
 
+	// moved from LuaUI
+
+	REGISTER_LUA_CFUNC(GetFPS);
+
+	REGISTER_LUA_CFUNC(GetActiveCommand);
+	REGISTER_LUA_CFUNC(GetDefaultCommand);
+	REGISTER_LUA_CFUNC(GetActiveCmdDescs);
+	REGISTER_LUA_CFUNC(GetActiveCmdDesc);
+	REGISTER_LUA_CFUNC(GetCmdDescIndex);
+
+	REGISTER_LUA_CFUNC(GetBuildFacing);
+	REGISTER_LUA_CFUNC(GetBuildSpacing);
+
+	REGISTER_LUA_CFUNC(GetGatherMode);
+
+	REGISTER_LUA_CFUNC(GetActivePage);
+
+	REGISTER_LUA_CFUNC(GetMouseState);
+	REGISTER_LUA_CFUNC(GetMouseMiniMapState);
+	REGISTER_LUA_CFUNC(GetMouseStartPosition);
+	REGISTER_LUA_CFUNC(GetMouseCursor);
+
+	REGISTER_LUA_CFUNC(GetKeyState);
+	REGISTER_LUA_CFUNC(GetModKeyState);
+	REGISTER_LUA_CFUNC(GetPressedKeys);
+	REGISTER_LUA_CFUNC(GetInvertQueueKey);
+
+	REGISTER_LUA_CFUNC(GetKeyCode);
+	REGISTER_LUA_CFUNC(GetKeySymbol);
+	REGISTER_LUA_CFUNC(GetKeyBindings);
+	REGISTER_LUA_CFUNC(GetActionHotKeys);
+
+	REGISTER_LUA_CFUNC(GetConsoleBuffer);
+	REGISTER_LUA_CFUNC(GetCurrentTooltip);
+
+	REGISTER_LUA_CFUNC(GetMyAllyTeamID);
+	REGISTER_LUA_CFUNC(GetMyTeamID);
+	REGISTER_LUA_CFUNC(GetMyPlayerID);
+
+	REGISTER_LUA_CFUNC(GetGroupList);
+	REGISTER_LUA_CFUNC(GetSelectedGroup);
+	REGISTER_LUA_CFUNC(GetGroupAIName);
+	REGISTER_LUA_CFUNC(GetGroupAIList);
+
+	REGISTER_LUA_CFUNC(GetUnitGroup);
+
+	REGISTER_LUA_CFUNC(GetGroupUnits);
+	REGISTER_LUA_CFUNC(GetGroupUnitsSorted);
+	REGISTER_LUA_CFUNC(GetGroupUnitsCounts);
+	REGISTER_LUA_CFUNC(GetGroupUnitsCount);
+
+	REGISTER_LUA_CFUNC(GetPlayerTraffic);
+
 	return true;
 }
 
@@ -175,8 +251,51 @@
 }
 
 
+int LuaUnsyncedRead::GetModUICtrl(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushboolean(L, CLuaHandle::GetModUICtrl());
+	return 1;
+}
+
+
 /******************************************************************************/
 
+int LuaUnsyncedRead::GetViewGeometry(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;viewSizeX);
+	lua_pushnumber(L, gu-&gt;viewSizeY);
+	lua_pushnumber(L, gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewPosY);
+	return 4;
+}
+
+
+int LuaUnsyncedRead::GetWindowGeometry(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;winSizeX);
+	lua_pushnumber(L, gu-&gt;winSizeY);
+	lua_pushnumber(L, gu-&gt;winPosX);
+	lua_pushnumber(L, gu-&gt;winPosY);
+	return 4;
+}
+
+
+int LuaUnsyncedRead::GetScreenGeometry(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;screenSizeX);
+	lua_pushnumber(L, gu-&gt;screenSizeY);
+	lua_pushnumber(L, 0.0f);
+	lua_pushnumber(L, 0.0f);
+	return 4;
+}
+
+
+/******************************************************************************/
+
 int LuaUnsyncedRead::GetFrameTimeOffset(lua_State* L)
 {
 	CheckNoArgs(L, __FUNCTION__);
@@ -364,11 +483,41 @@
 /******************************************************************************/
 /******************************************************************************/
 
+// FIXME -- copied from LuaSyncedRead.cpp, commonize
+enum UnitAllegiance {
+	AllUnits   = -1,
+	MyUnits    = -2,
+	AllyUnits  = -3,
+	EnemyUnits = -4
+};
+
+
 int LuaUnsyncedRead::GetVisibleUnits(lua_State* L)
 {
-	// FIXME: implement ALL_UNITS / ENEMY_UNITS / ALLY_UNITS / MY_UNITS
-	const int teamID = luaL_optint(L, 1, -1);
+	// arg 1 - teamID
+	int teamID = luaL_optint(L, 1, -1);
+	if (teamID == MyUnits) {
+		const int scriptTeamID = CLuaHandle::GetActiveHandle()-&gt;GetReadTeam();
+		if (scriptTeamID &gt;= 0) {
+			teamID = scriptTeamID;
+		} else {
+			teamID = AllUnits;
+		}
+	}
+	int allyTeamID = readAllyTeam;
+	if (teamID &gt;= 0) {
+		allyTeamID = gs-&gt;AllyTeam(teamID);
+	}
+	if (allyTeamID &lt; 0) {
+		allyTeamID = 0; // safety
+	}
+	if (!fullRead) {
+		if (allyTeamID &lt; 0) {
+			return 0;
+		}
+	}
 
+	// arg 2 - unit radius
 	bool fixedRadius = false;
 	float radius = 30.0f; // value from UnitDrawer.cpp
 	if (lua_israwnumber(L, 2)) {
@@ -379,51 +528,69 @@
 		}
 	}
 
+	// arg 3 - noIcons
 	const bool noIcons = lua_isboolean(L, 3) &amp;&amp; !lua_toboolean(L, 3);
 
+	// setup the list of unit sets
+	vector&lt;const CUnitSet*&gt; unitSets;
+	if (teamID &gt;= 0) {
+		unitSets.push_back(&amp;gs-&gt;Team(teamID)-&gt;units);
+	}
+	else {
+		for (int t = 0; t &lt; gs-&gt;activeTeams; t++) {
+			if ((teamID == AllUnits) ||
+			    ((teamID == AllyUnits)  &amp;&amp; (allyTeamID == gs-&gt;AllyTeam(t))) ||
+			    ((teamID == EnemyUnits) &amp;&amp; (allyTeamID != gs-&gt;AllyTeam(t)))) {
+				unitSets.push_back(&amp;gs-&gt;Team(t)-&gt;units);
+			}
+		}
+	}
+
 	const float iconLength = unitDrawer-&gt;iconLength;
 
 	int count = 0;
 	lua_newtable(L);
 
-	list&lt;CUnit*&gt;::iterator usi;
-	for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
-		const CUnit* unit = *usi;
+	vector&lt;const CUnitSet*&gt;::const_iterator setIt;
+	for (setIt = unitSets.begin(); setIt != unitSets.end(); ++setIt) {
+		const CUnitSet* unitSet = *setIt;
 
-		if (unit-&gt;noDraw) {
-			continue;
-		}
+		CUnitSet::const_iterator unitIt;
+		for (unitIt = unitSet-&gt;begin(); unitIt != unitSet-&gt;end(); ++unitIt) {
+			const CUnit* unit = *unitIt;
 
-		if ((teamID &gt;= 0) &amp;&amp; (unit-&gt;team != teamID)) {
-			continue;
-		}
+			if (unit-&gt;noDraw) {
+				continue;
+			}
 
-		if (!gs-&gt;Ally(unit-&gt;allyteam, gu-&gt;myAllyTeam) &amp;&amp;
-			  !(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) &amp;&amp;
-				!gu-&gt;spectatingFullView) {
-			continue;
-		}
+			if (allyTeamID &gt;= 0) {
+				if (!(unit-&gt;losStatus[allyTeamID] &amp; LOS_INLOS)) {
+					continue;
+				}
+			}
 
-		if (noIcons) {
-			const float sqDist = (unit-&gt;pos - camera-&gt;pos).SqLength();
-			const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
-			const float realIconLength = iconLength * iconDistSqrMult;
-			if (sqDist &gt; realIconLength) {
+			if (noIcons) {
+				const float sqDist = (unit-&gt;pos - camera-&gt;pos).SqLength();
+				const float iconDistSqrMult = unit-&gt;unitDef-&gt;iconType-&gt;GetDistanceSqr();
+				const float realIconLength = iconLength * iconDistSqrMult;
+				if (sqDist &gt; realIconLength) {
+					continue;
+				}
+			}
+
+			const float testRadius = fixedRadius ? radius : (unit-&gt;radius + radius); 
+			if (!camera-&gt;InView(unit-&gt;midPos, testRadius)) {
 				continue;
 			}
-		}
 
-		const float testRadius = fixedRadius ? radius : (unit-&gt;radius + radius); 
-		if (!camera-&gt;InView(unit-&gt;midPos, testRadius)) {
-			continue;
+			// add the unit
+			count++;
+			lua_pushnumber(L, count);
+			lua_pushnumber(L, unit-&gt;id);
+			lua_rawset(L, -3);
 		}
+	}
 
-		// add the unit
-		count++;
-		lua_pushnumber(L, count);
-		lua_pushnumber(L, unit-&gt;id);
-		lua_rawset(L, -3);
-	}
 	return 1;
 }
 
@@ -937,3 +1104,751 @@
 
 /******************************************************************************/
 /******************************************************************************/
+//
+// moved from LuaUI
+//
+/******************************************************************************/
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetFPS(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	if (game) {
+		lua_pushnumber(L, game-&gt;fps);
+	} else {
+		lua_pushnumber(L, 0);
+	}
+	return 1;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetActiveCommand(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	CheckNoArgs(L, __FUNCTION__);
+
+	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
+	const int cmdDescCount = (int)cmdDescs.size();
+
+	const int inCommand = guihandler-&gt;inCommand;
+	lua_pushnumber(L, inCommand + CMD_INDEX_OFFSET);
+	if ((inCommand &lt; 0) || (inCommand &gt;= cmdDescCount)) {
+		return 1;
+	}
+	lua_pushnumber(L, cmdDescs[inCommand].id);
+	lua_pushnumber(L, cmdDescs[inCommand].type);
+	lua_pushstring(L, cmdDescs[inCommand].name.c_str());
+	return 4;
+}
+
+
+int LuaUnsyncedRead::GetDefaultCommand(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	CheckNoArgs(L, __FUNCTION__);
+
+	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
+	const int cmdDescCount = (int)cmdDescs.size();
+
+	const int defCmd = guihandler-&gt;GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty);
+	lua_pushnumber(L, defCmd + CMD_INDEX_OFFSET);
+	if ((defCmd &lt; 0) || (defCmd &gt;= cmdDescCount)) {
+		return 1;
+	}
+	lua_pushnumber(L, cmdDescs[defCmd].id);
+	lua_pushnumber(L, cmdDescs[defCmd].type);
+	lua_pushstring(L, cmdDescs[defCmd].name.c_str());
+	return 4;
+}
+
+
+// FIXME: duplicated in LuaSyncedRead.cpp
+static void PushCommandDesc(lua_State* L, const CommandDescription&amp; cd)
+{
+	lua_newtable(L);
+
+	HSTR_PUSH_NUMBER(L, &quot;id&quot;,          cd.id);
+	HSTR_PUSH_NUMBER(L, &quot;type&quot;,        cd.type);
+	HSTR_PUSH_STRING(L, &quot;name&quot;,        cd.name);
+	HSTR_PUSH_STRING(L, &quot;action&quot;,      cd.action);
+	HSTR_PUSH_STRING(L, &quot;tooltip&quot;,     cd.tooltip);
+	HSTR_PUSH_STRING(L, &quot;texture&quot;,     cd.iconname);
+	HSTR_PUSH_STRING(L, &quot;cursor&quot;,      cd.mouseicon);
+	HSTR_PUSH_BOOL(L,   &quot;hidden&quot;,      cd.onlyKey);
+	HSTR_PUSH_BOOL(L,   &quot;disabled&quot;,    cd.disabled);
+	HSTR_PUSH_BOOL(L,   &quot;showUnique&quot;,  cd.showUnique);
+	HSTR_PUSH_BOOL(L,   &quot;onlyTexture&quot;, cd.onlyTexture);
+
+	HSTR_PUSH(L, &quot;params&quot;);
+	lua_newtable(L);
+	const int pCount = (int)cd.params.size();
+	for (int p = 0; p &lt; pCount; p++) {
+		lua_pushnumber(L, p + 1);
+		lua_pushstring(L, cd.params[p].c_str());
+		lua_rawset(L, -3);
+	}
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, pCount);
+	lua_rawset(L, -3);
+}
+
+
+int LuaUnsyncedRead::GetActiveCmdDescs(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	CheckNoArgs(L, __FUNCTION__);
+	lua_newtable(L);
+	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
+	const int cmdDescCount = (int)cmdDescs.size();
+	for (int i = 0; i &lt; cmdDescCount; i++) {
+		lua_pushnumber(L, i + CMD_INDEX_OFFSET);
+		PushCommandDesc(L, cmdDescs[i]);
+		lua_rawset(L, -3);
+	}
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, cmdDescCount);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetActiveCmdDesc(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isnumber(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetActiveCmdDesc()&quot;);
+	}
+	const int cmdIndex = (int)lua_tonumber(L, 1) - CMD_INDEX_OFFSET;
+
+	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
+	const int cmdDescCount = (int)cmdDescs.size();
+	if ((cmdIndex &lt; 0) || (cmdIndex &gt;= cmdDescCount)) {
+		return 0;
+	}
+	PushCommandDesc(L, cmdDescs[cmdIndex]);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetCmdDescIndex(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	const int cmdId = (int)luaL_checknumber(L, 1);
+
+	const vector&lt;CommandDescription&gt;&amp; cmdDescs = guihandler-&gt;commands;
+	const int cmdDescCount = (int)cmdDescs.size();
+	for (int i = 0; i &lt; cmdDescCount; i++) {
+		if (cmdId == cmdDescs[i].id) {
+			lua_pushnumber(L, i + CMD_INDEX_OFFSET);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetBuildFacing(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, guihandler-&gt;buildFacing);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetBuildSpacing(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, guihandler-&gt;buildSpacing);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetGatherMode(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, guihandler-&gt;GetGatherMode());
+	return 1;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetActivePage(lua_State* L)
+{
+	if (guihandler == NULL) {
+		return 0;
+	}
+	lua_pushnumber(L, guihandler-&gt;GetActivePage());
+	lua_pushnumber(L, guihandler-&gt;GetMaxPage());
+	return 2;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetMouseState(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, mouse-&gt;lastx - gu-&gt;viewPosX);
+	lua_pushnumber(L, gu-&gt;viewSizeY - mouse-&gt;lasty - 1);
+	lua_pushboolean(L, mouse-&gt;buttons[SDL_BUTTON_LEFT].pressed);
+	lua_pushboolean(L, mouse-&gt;buttons[SDL_BUTTON_MIDDLE].pressed);
+	lua_pushboolean(L, mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed);
+	return 5;
+}
+
+
+int LuaUnsyncedRead::GetMouseMiniMapState(lua_State* L)
+{
+	if (minimap == NULL) {
+		return 0;
+	}
+	lua_pushnumber(L, minimap-&gt;GetPosX());
+	lua_pushnumber(L, minimap-&gt;GetPosY());
+	lua_pushnumber(L, minimap-&gt;GetSizeX());
+	lua_pushnumber(L, minimap-&gt;GetSizeY());
+	lua_pushboolean(L, minimap-&gt;GetMinimized());
+	lua_pushboolean(L, minimap-&gt;GetMaximized());
+	return 6;
+}
+
+
+int LuaUnsyncedRead::GetMouseStartPosition(lua_State* L)
+{
+	if (mouse == NULL) {
+		return 0;
+	}
+	const int button = luaL_checkint(L, 1);
+	if ((button &lt;= 0) || (button &gt; NUM_BUTTONS)) {
+		return 0;
+	}
+	const CMouseHandler::ButtonPress&amp; bp = mouse-&gt;buttons[button];
+	lua_pushnumber(L, bp.x);
+	lua_pushnumber(L, bp.y);
+	lua_pushnumber(L, bp.camPos.x);
+	lua_pushnumber(L, bp.camPos.y);
+	lua_pushnumber(L, bp.camPos.z);
+	lua_pushnumber(L, bp.dir.x);
+	lua_pushnumber(L, bp.dir.y);
+	lua_pushnumber(L, bp.dir.z);
+	return 8;
+}
+
+
+int LuaUnsyncedRead::GetMouseCursor(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushstring(L, mouse-&gt;cursorText.c_str());
+	lua_pushnumber(L, mouse-&gt;cursorScale);
+	return 2;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetKeyState(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isnumber(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetKeyState(keycode)&quot;);
+	}
+	const int key = (int)lua_tonumber(L, 1);
+	if ((key &lt; 0) || (key &gt;= SDLK_LAST)) {
+		lua_pushboolean(L, 0);
+	} else {
+		lua_pushboolean(L, keys[key]);
+	}
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetModKeyState(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushboolean(L, keys[SDLK_LALT]);
+	lua_pushboolean(L, keys[SDLK_LCTRL]);
+	lua_pushboolean(L, keys[SDLK_LMETA]);
+	lua_pushboolean(L, keys[SDLK_LSHIFT]);
+	return 4;
+}
+
+
+int LuaUnsyncedRead::GetPressedKeys(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_newtable(L);
+	int count = 0;
+	for (int i = 0; i &lt; SDLK_LAST; i++) {
+		if (keys[i]) {
+			lua_pushnumber(L, i);
+			lua_pushboolean(L, 1);
+			lua_rawset(L, -3);
+			count++;
+		}
+	}
+	lua_pushstring(L, &quot;n&quot;);
+	lua_pushnumber(L, count);
+	lua_rawset(L, -3);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetInvertQueueKey(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	if (guihandler == NULL) {
+		return 0;
+	}
+	lua_pushboolean(L, guihandler-&gt;GetInvertQueueKey());
+	return 1;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetConsoleBuffer(lua_State* L)
+{
+	CInfoConsole* ic = game-&gt;infoConsole;
+	if (ic == NULL) {
+		return true;
+	}
+
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 0) &amp;&amp; ((args != 1) || !lua_isnumber(L, 1))) {
+		luaL_error(L, &quot;Incorrect arguments to GetConsoleBuffer([count])&quot;);
+	}
+
+	deque&lt;CInfoConsole::RawLine&gt; lines;
+	ic-&gt;GetRawLines(lines);
+	const int lineCount = (int)lines.size();
+
+	int start = 0;
+	if (args &gt;= 1) {
+		const int maxLines = (int)lua_tonumber(L, 1);
+		if (maxLines &lt; lineCount) {
+			start = (lineCount - maxLines);
+		}
+	}
+
+	// table = { [1] = { text = string, zone = number}, etc... }
+	lua_newtable(L);
+	int count = 0;
+	for (int i = start; i &lt; lineCount; i++) {
+		count++;
+		lua_pushnumber(L, count);
+		lua_newtable(L); {
+			lua_pushstring(L, &quot;text&quot;);
+			lua_pushstring(L, lines[i].text.c_str());
+			lua_rawset(L, -3);
+			// FIXME: how to migrate 'priority' to 'zone', will it break widgets?
+			lua_pushstring(L, &quot;priority&quot;);
+			lua_pushnumber(L, lines[i].zone);
+			lua_rawset(L, -3);
+		}
+		lua_rawset(L, -3);
+	}
+	lua_pushstring(L, &quot;n&quot;);
+	lua_pushnumber(L, count);
+	lua_rawset(L, -3);
+
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetCurrentTooltip(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	const string tooltip = mouse-&gt;GetCurrentTooltip();
+	lua_pushstring(L, tooltip.c_str());
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetKeyCode(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isstring(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetKeyCode(\&quot;keysym\&quot;)&quot;);
+	}
+	const string keysym = lua_tostring(L, 1);
+	lua_pushnumber(L, keyCodes-&gt;GetCode(keysym));
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetKeySymbol(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isnumber(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetKeySymbol(keycode)&quot;);
+	}
+	const int keycode = (int)lua_tonumber(L, 1);
+	lua_pushstring(L, keyCodes-&gt;GetName(keycode).c_str());
+	lua_pushstring(L, keyCodes-&gt;GetDefaultName(keycode).c_str());
+	return 2;
+}
+
+
+int LuaUnsyncedRead::GetKeyBindings(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isstring(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetKeyBindings(\&quot;keyset\&quot;)&quot;);
+	}
+	const string keysetStr = lua_tostring(L, 1);
+	CKeySet ks;
+	if (!ks.Parse(keysetStr)) {
+		return 0;
+	}
+	const CKeyBindings::ActionList&amp;	actions = keyBindings-&gt;GetActionList(ks);
+	lua_newtable(L);
+	for (int i = 0; i &lt; (int)actions.size(); i++) {
+		const Action&amp; action = actions[i];
+		lua_pushnumber(L, i + 1);
+		lua_newtable(L);
+		lua_pushstring(L, action.command.c_str());
+		lua_pushstring(L, action.extra.c_str());
+		lua_rawset(L, -3);
+		lua_rawset(L, -3);
+	}
+	lua_pushstring(L, &quot;n&quot;);
+	lua_pushnumber(L, actions.size());
+	lua_rawset(L, -3);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetActionHotKeys(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isstring(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetActionHotKeys(\&quot;command\&quot;)&quot;);
+	}
+	const string command = lua_tostring(L, 1);
+	const CKeyBindings::HotkeyList&amp;	hotkeys = keyBindings-&gt;GetHotkeys(command);
+	lua_newtable(L);
+	for (int i = 0; i &lt; (int)hotkeys.size(); i++) {
+		const string&amp; hotkey = hotkeys[i];
+		lua_pushnumber(L, i + 1);
+		lua_pushstring(L, hotkey.c_str());
+		lua_rawset(L, -3);
+	}
+	lua_pushstring(L, &quot;n&quot;);
+	lua_pushnumber(L, hotkeys.size());
+	lua_rawset(L, -3);
+	return 1;
+}
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetGroupList(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	if (grouphandlers[gu-&gt;myTeam] == NULL) {
+		return 0;
+	}
+	lua_newtable(L);
+	int count = 0;
+	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
+	vector&lt;CGroup*&gt;::const_iterator git;
+	for (git = groups.begin(); git != groups.end(); ++git) {
+		const CGroup* group = *git;
+		if ((group != NULL) &amp;&amp; !group-&gt;units.empty()) {
+			lua_pushnumber(L, group-&gt;id);
+			lua_pushnumber(L, group-&gt;units.size());
+			lua_rawset(L, -3);
+			count++;
+		}
+	}
+	lua_pushnumber(L, count);
+	return 2;
+}
+
+
+int LuaUnsyncedRead::GetSelectedGroup(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, selectedUnits.selectedGroup);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetGroupAIList(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_newtable(L);
+	const map&lt;AIKey, string&gt;&amp; availableAI = grouphandlers[gu-&gt;myTeam]-&gt;availableAI;
+	map&lt;AIKey, string&gt;::const_iterator it;
+	int count = 0;
+	for (it = availableAI.begin(); it != availableAI.end(); ++it) {
+		count++;
+		lua_pushnumber(L, count);
+		lua_pushstring(L, it-&gt;second.c_str());
+		lua_rawset(L, -3);
+	}
+	lua_pushstring(L, &quot;n&quot;);
+	lua_pushnumber(L, count);
+	lua_rawset(L, -3);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetGroupAIName(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if ((args != 1) || !lua_isnumber(L, 1)) {
+		luaL_error(L, &quot;Incorrect arguments to GetGroupAIName(groupID)&quot;);
+	}
+
+	const int groupID = (int)lua_tonumber(L, 1);
+	if ((groupID &lt; 0) || (groupID &gt;= (int)grouphandlers[gu-&gt;myTeam]-&gt;groups.size())) {
+		return 0; // bad group
+	}
+
+	const CGroup* group = grouphandlers[gu-&gt;myTeam]-&gt;groups[groupID];
+	if (group-&gt;ai == NULL) {
+		lua_pushstring(L, &quot;&quot;);
+		return 1;
+	}
+
+	const AIKey&amp; aikey = group-&gt;currentAiKey;
+	const map&lt;AIKey, string&gt;&amp; availableAI = grouphandlers[gu-&gt;myTeam]-&gt;availableAI;
+	map&lt;AIKey, string&gt;::const_iterator fit = availableAI.find(aikey);
+	if (fit == availableAI.end()) {
+		lua_pushstring(L, &quot;&quot;); // should not happen?
+	} else {
+		lua_pushstring(L, fit-&gt;second.c_str());
+	}
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetUnitGroup(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	if ((unit-&gt;team == gu-&gt;myTeam) &amp;&amp; (unit-&gt;group)) {
+		lua_pushnumber(L, unit-&gt;group-&gt;id);
+		return 1;
+	}
+	return 0;
+}
+
+
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetGroupUnits(lua_State* L)
+{
+	const int groupID = (int)luaL_checknumber(L, 1);
+	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
+	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
+	    (groups[groupID] == NULL)) {
+		return 0; // nils
+	}
+
+	lua_newtable(L);
+	int count = 0;
+	const CUnitSet&amp; groupUnits = groups[groupID]-&gt;units;
+	CUnitSet::const_iterator it;
+	for (it = groupUnits.begin(); it != groupUnits.end(); ++it) {
+		count++;
+		lua_pushnumber(L, count);
+		lua_pushnumber(L, (*it)-&gt;id);
+		lua_rawset(L, -3);
+	}
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, count);
+
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetGroupUnitsSorted(lua_State* L)
+{
+	const int groupID = (int)luaL_checknumber(L, 1);
+	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
+	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
+	    (groups[groupID] == NULL)) {
+		return 0; // nils
+	}
+
+	map&lt;int, vector&lt;CUnit*&gt; &gt; unitDefMap;
+	const CUnitSet&amp; groupUnits = groups[groupID]-&gt;units;
+	CUnitSet::const_iterator it;
+	for (it = groupUnits.begin(); it != groupUnits.end(); ++it) {
+		CUnit* unit = *it;
+		unitDefMap[unit-&gt;unitDef-&gt;id].push_back(unit);
+	}
+
+	lua_newtable(L);
+	map&lt;int, vector&lt;CUnit*&gt; &gt;::const_iterator mit;
+	for (mit = unitDefMap.begin(); mit != unitDefMap.end(); mit++) {
+		lua_pushnumber(L, mit-&gt;first); // push the UnitDef index
+		lua_newtable(L); {
+			const vector&lt;CUnit*&gt;&amp; v = mit-&gt;second;
+			for (int i = 0; i &lt; (int)v.size(); i++) {
+				CUnit* unit = v[i];
+				lua_pushnumber(L, i + 1);
+				lua_pushnumber(L, unit-&gt;id);
+				lua_rawset(L, -3);
+			}
+			HSTR_PUSH_NUMBER(L, &quot;n&quot;, v.size());
+		}
+		lua_rawset(L, -3);
+	}
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, unitDefMap.size());
+
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetGroupUnitsCounts(lua_State* L)
+{
+	const int groupID = (int)luaL_checknumber(L, 1);
+	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
+	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
+	    (groups[groupID] == NULL)) {
+		return 0; // nils
+	}
+
+	map&lt;int, int&gt; countMap;
+	const CUnitSet&amp; groupUnits = groups[groupID]-&gt;units;
+	CUnitSet::const_iterator it;
+	for (it = groupUnits.begin(); it != groupUnits.end(); ++it) {
+		CUnit* unit = *it;
+		const int udID = unit-&gt;unitDef-&gt;id;
+		map&lt;int, int&gt;::iterator mit = countMap.find(udID);
+		if (mit == countMap.end()) {
+			countMap[udID] = 1;
+		} else {
+			mit-&gt;second++;
+		}
+	}
+
+	lua_newtable(L);
+	map&lt;int, int&gt;::const_iterator mit;
+	for (mit = countMap.begin(); mit != countMap.end(); mit++) {
+		lua_pushnumber(L, mit-&gt;first);  // push the UnitDef index
+		lua_pushnumber(L, mit-&gt;second); // push the UnitDef unit count
+		lua_rawset(L, -3);
+	}
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, countMap.size());
+
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetGroupUnitsCount(lua_State* L)
+{
+	const int groupID = (int)luaL_checknumber(L, 1);
+	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
+	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
+	    (groups[groupID] == NULL)) {
+		return 0; // nils
+	}
+	lua_pushnumber(L, groups[groupID]-&gt;units.size());
+	return 1;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetMyPlayerID(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;myPlayerNum);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetMyTeamID(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;myTeam);
+	return 1;
+}
+
+
+int LuaUnsyncedRead::GetMyAllyTeamID(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_pushnumber(L, gu-&gt;myAllyTeam);
+	return 1;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+int LuaUnsyncedRead::GetPlayerTraffic(lua_State* L)
+{
+	const int playerID = (int)luaL_checknumber(L, 1);
+	const int packetID = (int)luaL_optnumber(L, 2, -1);
+
+	const std::map&lt;int, CGame::PlayerTrafficInfo&gt;&amp; traffic
+		= game-&gt;GetPlayerTraffic();
+	std::map&lt;int, CGame::PlayerTrafficInfo&gt;::const_iterator it;
+	it = traffic.find(playerID);
+	if (it == traffic.end()) {
+		lua_pushnumber(L, -1);
+		return 1;
+	}
+
+	// only allow viewing stats for specific packet types
+	if ((playerID != -1) &amp;&amp;              // all system counts can be read
+	    (playerID != gu-&gt;myPlayerNum) &amp;&amp; // all  self  counts can be read
+	    (packetID != -1) &amp;&amp;
+	    (packetID != NETMSG_CHAT)     &amp;&amp;
+	    (packetID != NETMSG_PAUSE)    &amp;&amp;
+	    (packetID != NETMSG_LUAMSG)   &amp;&amp;
+	    (packetID != NETMSG_STARTPOS) &amp;&amp;
+	    (packetID != NETMSG_USER_SPEED)) {
+    lua_pushnumber(L, -1);
+    return 1;
+  }
+
+	const CGame::PlayerTrafficInfo&amp; pti = it-&gt;second;
+	if (packetID == -1) {
+		lua_pushnumber(L, pti.total);
+		return 1;
+	}
+	std::map&lt;int, int&gt;::const_iterator pit = pti.packets.find(packetID);
+	if (pit == pti.packets.end()) {
+		lua_pushnumber(L, -1);
+		return 1;
+	}
+	lua_pushnumber(L, pit-&gt;second);
+	return 1;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+
+
+

Modified: trunk/rts/Lua/LuaUnsyncedRead.h
===================================================================
--- trunk/rts/Lua/LuaUnsyncedRead.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaUnsyncedRead.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -13,11 +13,16 @@
 
 	private:
 		static int IsReplay(lua_State* L);
+		static int GetModUICtrl(lua_State* L);
 
 		static int GetFrameTimeOffset(lua_State* L);
 		static int GetLastUpdateSeconds(lua_State* L);
 		static int GetHasLag(lua_State* L);
 
+		static int GetViewGeometry(lua_State* L);
+		static int GetWindowGeometry(lua_State* L);
+		static int GetScreenGeometry(lua_State* L);
+
 		static int IsAABBInView(lua_State* L);
 		static int IsSphereInView(lua_State* L);
 
@@ -67,6 +72,59 @@
 
 		static int GetTimer(lua_State* L);
 		static int DiffTimers(lua_State* L);
+
+		// moved from LuaUI
+		static int GetFPS(lua_State* L);
+
+		static int GetMouseState(lua_State* L);
+		static int GetMouseMiniMapState(lua_State* L);
+		static int GetMouseStartPosition(lua_State* L);
+
+		static int GetMouseCursor(lua_State* L);
+
+		static int GetKeyState(lua_State* L);
+		static int GetModKeyState(lua_State* L);
+		static int GetPressedKeys(lua_State* L);
+		static int GetInvertQueueKey(lua_State* L);
+
+		static int GetActiveCommand(lua_State* L);
+		static int GetDefaultCommand(lua_State* L);
+		static int GetActiveCmdDescs(lua_State* L);
+		static int GetActiveCmdDesc(lua_State* L);
+		static int GetCmdDescIndex(lua_State* L);
+
+		static int GetGatherMode(lua_State* L);
+
+		static int GetBuildFacing(lua_State* L);
+		static int GetBuildSpacing(lua_State* L);
+
+		static int GetActivePage(lua_State* L);
+
+		static int GetConsoleBuffer(lua_State* L);
+		static int GetCurrentTooltip(lua_State* L);
+
+		static int GetKeyCode(lua_State* L);
+		static int GetKeySymbol(lua_State* L);
+		static int GetKeyBindings(lua_State* L);
+		static int GetActionHotKeys(lua_State* L);
+
+		static int GetGroupList(lua_State* L);
+		static int GetSelectedGroup(lua_State* L);
+		static int GetGroupAIName(lua_State* L);
+		static int GetGroupAIList(lua_State* L);
+
+		static int GetMyAllyTeamID(lua_State* L);
+		static int GetMyTeamID(lua_State* L);
+		static int GetMyPlayerID(lua_State* L);
+
+		static int GetUnitGroup(lua_State* L);
+
+		static int GetGroupUnits(lua_State* L);
+		static int GetGroupUnitsSorted(lua_State* L);
+		static int GetGroupUnitsCounts(lua_State* L);
+		static int GetGroupUnitsCount(lua_State* L);
+
+		static int GetPlayerTraffic(lua_State* L);
 };
 
 

Modified: trunk/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- trunk/rts/Lua/LuaWeaponDefs.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Lua/LuaWeaponDefs.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -447,14 +447,14 @@
 	ADD_FLOAT(&quot;predictBoost&quot;, wd.predictBoost);
 	ADD_INT(&quot;highTrajectory&quot;, wd.highTrajectory);
 
-	ADD_BOOL(&quot;noSelfDamage&quot;, wd.noSelfDamage);
-	ADD_BOOL(&quot;impactOnly&quot;,   wd.impactOnly);
+	ADD_BOOL(&quot;noSelfDamage&quot;,  wd.noSelfDamage);
+	ADD_BOOL(&quot;impactOnly&quot;,    wd.impactOnly);
 	ADD_FLOAT(&quot;areaOfEffect&quot;, wd.areaOfEffect);
-	ADD_FLOAT(&quot;fireStarter&quot;, wd.fireStarter);
+	ADD_FLOAT(&quot;fireStarter&quot;,  wd.fireStarter);
+	ADD_FLOAT(&quot;size&quot;,          wd.size);
+	ADD_FLOAT(&quot;sizeGrowth&quot;,    wd.sizeGrowth);
+	ADD_FLOAT(&quot;collisionSize&quot;, wd.collisionSize);
 	ADD_FLOAT(&quot;edgeEffectiveness&quot;, wd.edgeEffectiveness);
-	ADD_FLOAT(&quot;size&quot;, wd.size);
-	ADD_FLOAT(&quot;sizeGrowth&quot;, wd.sizeGrowth);
-	ADD_FLOAT(&quot;collisionSize&quot;, wd.collisionSize);
 
 	ADD_INT(&quot;salvoSize&quot;,    wd.salvosize);
 	ADD_INT(&quot;projectiles&quot;,  wd.projectilespershot);
@@ -463,11 +463,11 @@
 	ADD_FLOAT(&quot;beamtime&quot;,   wd.beamtime);
 	ADD_BOOL(&quot;beamburst&quot;,   wd.beamburst);
 
-	ADD_BOOL(&quot;waterbounce&quot;, wd.waterBounce);
-	ADD_BOOL(&quot;groundbounce&quot;, wd.groundBounce);
-	ADD_FLOAT(&quot;groundslip&quot;, wd.bounceSlip);
+	ADD_BOOL(&quot;waterbounce&quot;,    wd.waterBounce);
+	ADD_BOOL(&quot;groundbounce&quot;,   wd.groundBounce);
+	ADD_FLOAT(&quot;groundslip&quot;,    wd.bounceSlip);
 	ADD_FLOAT(&quot;bouncerebound&quot;, wd.bounceRebound);
-	ADD_INT(&quot;numbounce&quot;, wd.numBounce);
+	ADD_INT(&quot;numbounce&quot;,       wd.numBounce);
 
 	ADD_FLOAT(&quot;maxAngle&quot;, wd.maxAngle);
 	ADD_FLOAT(&quot;restTime&quot;, wd.restTime);

Modified: trunk/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- trunk/rts/Map/BaseGroundDrawer.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Map/BaseGroundDrawer.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -1,45 +1,50 @@
 #include &quot;StdAfx.h&quot;
+
 #include &quot;BaseGroundDrawer.h&quot;
-#include &quot;Platform/ConfigHandler.h&quot;
-#include &quot;Rendering/GL/myGL.h&quot;
+
 #include &quot;Game/Camera.h&quot;
+#include &quot;Game/SelectedUnits.h&quot;
+#include &quot;Game/UI/GuiHandler.h&quot;
+#include &quot;Map/Ground.h&quot;
+#include &quot;Map/HeightLinePalette.h&quot;
 #include &quot;Map/ReadMap.h&quot;
-#include &quot;Map/HeightLinePalette.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
-#include &quot;Game/SelectedUnits.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+#include &quot;Sim/MoveTypes/MoveMath/MoveMath.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;Rendering/GroundDecalHandler.h&quot;
-#include &quot;Game/UI/GuiHandler.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
-#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
-#include &quot;Sim/MoveTypes/MoveMath/MoveMath.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
+#include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 CBaseGroundDrawer::CBaseGroundDrawer(void)
 {
-	updateFov=true;
+	updateFov = true;
 
-	striptype=GL_TRIANGLE_STRIP;
+	striptype = GL_TRIANGLE_STRIP;
 
-	infoTexAlpha=0.25f;
-	infoTex=0;
+	infoTexAlpha = 0.25f;
+	infoTex = 0;
 
-	drawMode=drawNormal;
-	drawLineOfSight=false;
-	drawRadarAndJammer=true;
-	wireframe=false;
+	drawMode = drawNormal;
+	drawLineOfSight = false;
+	drawRadarAndJammer = true;
+	wireframe = false;
 
-	extraTex=0;
-	extraTexPal=0;
-	extractDepthMap=0;
+	extraTex = 0;
+	extraTexPal = 0;
+	extractDepthMap = 0;
 
-	infoTexMem=SAFE_NEW unsigned char[gs-&gt;pwr2mapx*gs-&gt;pwr2mapy*4];
-	for(int a=0;a&lt;gs-&gt;pwr2mapx*gs-&gt;pwr2mapy*4;++a)
-		infoTexMem[a]=255;
+	infoTexMem = SAFE_NEW unsigned char[gs-&gt;pwr2mapx*gs-&gt;pwr2mapy*4];
+	for (int a = 0; a &lt; (gs-&gt;pwr2mapx * gs-&gt;pwr2mapy * 4); ++a) {
+		infoTexMem[a] = 255;
+	}
 
-	highResInfoTexWanted=false;
+	highResInfoTexWanted = false;
 
 	highResLosTex = !!configHandler.GetInt(&quot;HighResLos&quot;, 0);
 // 	smoothLosTex = !!configHandler.GetInt(&quot;SmoothLos&quot;, 1);
@@ -63,6 +68,7 @@
 	heightLinePal = SAFE_NEW CHeightLinePalette();
 }
 
+
 CBaseGroundDrawer::~CBaseGroundDrawer(void)
 {
 	delete[] infoTexMem;
@@ -73,14 +79,17 @@
 	delete heightLinePal;
 }
 
+
 void CBaseGroundDrawer::DrawShadowPass(void)
 {}
 
+
 void CBaseGroundDrawer::SetDrawMode (DrawMode dm)
 {
 	drawMode = dm;
 }
 
+
 //todo: this part of extra textures is a mess really ...
 void CBaseGroundDrawer::DisableExtraTexture()
 {
@@ -95,6 +104,7 @@
 	while(!UpdateExtraTexture());
 }
 
+
 void CBaseGroundDrawer::SetHeightTexture()
 {
 	if (drawMode == drawHeight)
@@ -108,6 +118,7 @@
 	}
 }
 
+
 void CBaseGroundDrawer::SetMetalTexture(unsigned char* tex,float* extractMap,unsigned char* pal,bool highRes)
 {
 	if (drawMode == drawMetal)
@@ -124,6 +135,7 @@
 	}
 }
 
+
 void CBaseGroundDrawer::SetPathMapTexture()
 {
 	if (drawMode==drawPath)
@@ -137,6 +149,7 @@
 	}
 }
 
+
 void CBaseGroundDrawer::ToggleLosTexture()
 {
 	if (drawMode==drawLos) {
@@ -152,6 +165,7 @@
 	}
 }
 
+
 void CBaseGroundDrawer::ToggleRadarAndJammer()
 {
 	drawRadarAndJammer=!drawRadarAndJammer;
@@ -161,7 +175,9 @@
 	}
 }
 
-static inline int InterpolateLos(unsigned short* p, int xsize, int ysize, int mip, int factor, int x, int y)
+
+static inline int InterpolateLos(const unsigned short* p, int xsize, int ysize,
+                                 int mip, int factor, int x, int y)
 {
 	const int x1 = (x &gt;&gt; mip);
 	const int y1 = (y &gt;&gt; mip);
@@ -184,28 +200,35 @@
 	return factor * s1;
 }
 
+
 // Gradually calculate the extra texture based on updateTextureState:
 //   updateTextureState &lt; 50:   Calculate the texture color values and copy them in a buffer
 //   updateTextureState &gt;= 50:  Copy the buffer into a texture
 //   updateTextureState = 57:   Reset to 0 and restart updating
 bool CBaseGroundDrawer::UpdateExtraTexture()
 {
-	if(drawMode == drawNormal)
+	if (drawMode == drawNormal) {
 		return true;
+	}
 
-	unsigned short* myLos    = &amp;loshandler-&gt;losMap[gu-&gt;myAllyTeam].front();
-	unsigned short* myAirLos = &amp;loshandler-&gt;airLosMap[gu-&gt;myAllyTeam].front();
-	unsigned short* myRadar  = &amp;radarhandler-&gt;radarMaps[gu-&gt;myAllyTeam].front();
-	unsigned short* myJammer = &amp;radarhandler-&gt;jammerMaps[gu-&gt;myAllyTeam].front();
-	if(updateTextureState&lt;50){
+	const unsigned short* myLos         = &amp;loshandler-&gt;losMap[gu-&gt;myAllyTeam].front();
+	const unsigned short* myAirLos      = &amp;loshandler-&gt;airLosMap[gu-&gt;myAllyTeam].front();
+	const unsigned short* myRadar       = &amp;radarhandler-&gt;radarMaps[gu-&gt;myAllyTeam].front();
+	const unsigned short* myJammer      = &amp;radarhandler-&gt;jammerMaps[gu-&gt;myAllyTeam].front();
+#ifdef SONAR_JAMMER_MAPS
+	const unsigned short* mySonar       = &amp;radarhandler-&gt;sonarMaps[gu-&gt;myAllyTeam].front();
+	const unsigned short* mySonarJammer = &amp;radarhandler-&gt;sonarJammerMaps[gu-&gt;myAllyTeam].front();
+#endif
+
+	if (updateTextureState &lt; 50) {
 		int starty;
 		int endy;
-		if(highResInfoTexWanted){
-			starty=updateTextureState*gs-&gt;mapy/50;
-			endy=(updateTextureState+1)*gs-&gt;mapy/50;
+		if (highResInfoTexWanted) {
+			starty = updateTextureState * gs-&gt;mapy / 50;
+			endy = (updateTextureState + 1) * gs-&gt;mapy / 50;
 		} else {
-			starty=updateTextureState*gs-&gt;hmapy/50;
-			endy=(updateTextureState+1)*gs-&gt;hmapy/50;
+			starty = updateTextureState * gs-&gt;hmapy / 50;
+			endy = (updateTextureState + 1) * gs-&gt;hmapy / 50;
 		}
 
 		switch(drawMode) {
@@ -309,14 +332,27 @@
 				if (drawRadarAndJammer) {
 					const int rxsize = radarhandler-&gt;xsize;
 					const int rysize = radarhandler-&gt;ysize;
+					const int posScale = highResInfoTexWanted ? SQUARE_SIZE : (SQUARE_SIZE * 2);
 					for (int y = starty; y &lt; endy; ++y) {
+						const float zPos = y * posScale;
 						for (int x = 0; x &lt; endx; ++x) {
+							const float xPos = x * posScale;
 							int a = (y * pwr2mapx) + x;
 							const int inLos = InterpolateLos(myLos,    losSizeX, losSizeY, losMipLevel + lowRes, 255, x, y);
 							const int inAir = InterpolateLos(myAirLos, airSizeX, airSizeY, airMipLevel + lowRes, 255, x, y);
 							const int totalLos = (inLos + inAir) / 2;
-							const int inJam   = InterpolateLos(myJammer, rxsize, rysize, 3 + lowRes, 255, x, y);
-							const int inRadar = InterpolateLos(myRadar,  rxsize, rysize, 3 + lowRes, 255, x, y);
+
+#ifdef SONAR_JAMMER_MAPS
+							const bool useRadar = (ground-&gt;GetHeight2(xPos, zPos) &gt;= 0.0f);
+							const unsigned short* radarMap  = useRadar ? myRadar  : mySonar;
+							const unsigned short* jammerMap = useRadar ? myJammer : mySonarJammer;
+#else
+							const unsigned short* radarMap  = myRadar;
+							const unsigned short* jammerMap = myJammer;
+#endif // SONAR_JAMMER_MAPS
+							const int inRadar = InterpolateLos(radarMap,  rxsize, rysize, 3 + lowRes, 255, x, y);
+							const int inJam   = InterpolateLos(jammerMap, rxsize, rysize, 3 + lowRes, 255, x, y);
+
 							const int index = (a * 4);
 							for (int c = 0; c &lt; 3; c++) {
 								int val = alwaysColor[c] * 255;
@@ -387,7 +423,6 @@
 }
 
 
-
 void CBaseGroundDrawer::SetTexGen(float scalex,float scaley, float offsetx, float offsety)
 {
 	GLfloat plan[]={scalex,0,0,offsetx};

Modified: trunk/rts/Map/MapInfo.cpp
===================================================================
--- trunk/rts/Map/MapInfo.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Map/MapInfo.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -241,6 +241,13 @@
 		smf.detailTexName = resGfxMaps.GetString(&quot;detailtex&quot;, &quot;detailtex2.bmp&quot;);
 		smf.detailTexName = &quot;bitmaps/&quot; + smf.detailTexName;
 	}
+
+	// height overrides
+	const LuaTable smfTable = mapRoot-&gt;SubTable(&quot;smf&quot;);
+	smf.minHeightOverride = smfTable.KeyExists(&quot;minHeight&quot;);
+	smf.maxHeightOverride = smfTable.KeyExists(&quot;maxHeight&quot;);
+	smf.minHeight = smfTable.GetFloat(&quot;minHeight&quot;, 0.0f);
+	smf.maxHeight = smfTable.GetFloat(&quot;maxHeight&quot;, 0.0f);
 }
 
 

Modified: trunk/rts/Map/MapInfo.h
===================================================================
--- trunk/rts/Map/MapInfo.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Map/MapInfo.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -131,6 +131,10 @@
 	/** SMF specific settings */
 	struct smf_t {
 		std::string detailTexName; ///&lt; &quot;MAP\DetailTex&quot;
+		float minHeight;
+		bool  minHeightOverride;
+		float maxHeight;
+		bool  maxHeightOverride;
 	} smf;
 
 	/** SM3 specific settings

Modified: trunk/rts/Map/ReadMap.cpp
===================================================================
--- trunk/rts/Map/ReadMap.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Map/ReadMap.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -145,17 +145,16 @@
 {
 	float* heightmap = GetHeightmap();
 
-	minheight=1000;
-	maxheight=-1000;
-	mapChecksum=0;
-	for(int y=0;y&lt;(gs-&gt;mapy+1)*(gs-&gt;mapx+1);++y){
-		orgheightmap[y]=heightmap[y];
-		if(heightmap[y]&lt;minheight)
-			minheight=heightmap[y];
-		if(heightmap[y]&gt;maxheight)
-			maxheight=heightmap[y];
-		mapChecksum+=(unsigned int)(heightmap[y]*100);
-		mapChecksum^=*(unsigned int*)&amp;heightmap[y];
+	minheight = +123456.0f;
+	maxheight = -123456.0f;
+
+	mapChecksum = 0;
+	for (int y = 0; y &lt; ((gs-&gt;mapy + 1) * (gs-&gt;mapx + 1)); ++y) {
+		orgheightmap[y] = heightmap[y];
+		if (heightmap[y] &lt; minheight) { minheight = heightmap[y]; }
+		if (heightmap[y] &gt; maxheight) { maxheight = heightmap[y]; }
+		mapChecksum +=  (unsigned int)(heightmap[y] * 100);
+		mapChecksum ^= *(unsigned int*)&amp;heightmap[y];
 	}
 
 //	PrintLoadMsg(&quot;Creating surface normals&quot;);

Modified: trunk/rts/Map/ReadMap.h
===================================================================
--- trunk/rts/Map/ReadMap.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Map/ReadMap.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -96,7 +96,7 @@
 	};
 	virtual void GridVisibility(CCamera *cam, int quadSize, float maxdist, IQuadDrawer *cb, int extraSize=0) = 0;
 
-	float minheight,maxheight;
+	float minheight, maxheight;
 };
 
 extern CReadMap* readmap;

Modified: trunk/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- trunk/rts/Map/SMF/SmfReadMap.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Map/SMF/SmfReadMap.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -76,25 +76,30 @@
 
 	//CFileHandler ifs((string(&quot;maps/&quot;)+stupidGlobalMapname).c_str());
 
-	float base=header.minHeight;
-	float mod=(header.maxHeight-header.minHeight)/65536.0f;
+	const CMapInfo::smf_t&amp; smf = mapInfo-&gt;smf;
+	const float minH = smf.minHeightOverride ? smf.minHeight : header.minHeight;
+	const float maxH = smf.maxHeightOverride ? smf.maxHeight : header.maxHeight;
 
-	int hmx=gs-&gt;mapx+1, hmy=gs-&gt;mapy+1;
-	unsigned short* temphm=SAFE_NEW unsigned short[hmx * hmy];
+	const float base = minH;
+	const float mod = (maxH - minH) / 65536.0f;
+
+	const int hmx = gs-&gt;mapx + 1;
+	const int hmy = gs-&gt;mapy + 1;
+	unsigned short* temphm = SAFE_NEW unsigned short[hmx * hmy];
 	ifs-&gt;Seek(header.heightmapPtr);
-	ifs-&gt;Read(temphm,hmx*hmy*2);
+	ifs-&gt;Read(temphm, hmx * hmy * 2);
 
-	for(int y=0;y&lt;hmx*hmy;++y){
-		heightmap[y]=base+swabword(temphm[y])*mod;
+	for (int y = 0; y &lt; hmx * hmy; ++y) {
+		heightmap[y] = base + swabword(temphm[y]) * mod;
 	}
 
 	delete[] temphm;
 
 	CReadMap::Initialize();
 
-	for(unsigned int a=0;a&lt;mapname.size();++a){
-		mapChecksum+=mapname[a];
-		mapChecksum*=mapname[a];
+	for (unsigned int a = 0; a &lt; mapname.size(); ++a) {
+		mapChecksum += mapname[a];
+		mapChecksum *= mapname[a];
 	}
 
 	PrintLoadMsg(&quot;Loading detail textures&quot;);
@@ -102,8 +107,9 @@
 	detailTexName = mapInfo-&gt;smf.detailTexName;
 
 	CBitmap bm;
-	if (!bm.Load(detailTexName))
+	if (!bm.Load(detailTexName)) {
 		throw content_error(&quot;Could not load detail texture from file &quot; + detailTexName);
+	}
 	glGenTextures(1, &amp;detailTex);
 	glBindTexture(GL_TEXTURE_2D, detailTex);
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
@@ -124,8 +130,7 @@
 	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
 	//glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8 ,512, 512, 0, GL_RGBA, GL_UNSIGNED_BYTE, buf);
 	int offset=0;
-	for(unsigned int i=0; i&lt;MINIMAP_NUM_MIPMAP; i++)
-	{
+	for (unsigned int i = 0; i &lt; MINIMAP_NUM_MIPMAP; i++) {
 		int mipsize = 1024&gt;&gt;i;
 
 		int size = ((mipsize+3)/4)*((mipsize+3)/4)*8;

Modified: trunk/rts/Rendering/IconHandler.cpp
===================================================================
--- trunk/rts/Rendering/IconHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Rendering/IconHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -5,7 +5,6 @@
 #include &lt;assert.h&gt;
 #include &lt;locale&gt;
 #include &lt;cctype&gt;
-#include &lt;cmath&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
 #include &quot;GlobalStuff.h&quot;

Modified: trunk/rts/Sim/Misc/LosHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/LosHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Misc/LosHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -68,7 +68,8 @@
 //		CR_MEMBER(Points),
 		CR_MEMBER(terrainHeight),
 //		CR_MEMBER(lostables)
-		CR_RESERVED(32),
+		CR_MEMBER(requireSonarUnderWater),
+		CR_RESERVED(31),
 		CR_POSTLOAD(PostLoad)
 		));
 
@@ -99,13 +100,16 @@
 	invLosDiv = 1 / ((float)SQUARE_SIZE * (1 &lt;&lt; losMipLevel));
 	invAirDiv = 1 / ((float)SQUARE_SIZE * (1 &lt;&lt; airMipLevel));
 
-	for(int a=0;a&lt;gs-&gt;activeAllyTeams;++a){
-		losMap[a].resize(losSizeX*losSizeY,0);
-		airLosMap[a].resize(airSizeX*airSizeY,0);
+	requireSonarUnderWater = modInfo.requireSonarUnderWater;
+
+	for (int a = 0; a &lt; gs-&gt;activeAllyTeams; ++a) {
+		losMap[a].resize(losSizeX * losSizeY, 0);
+		airLosMap[a].resize(airSizeX * airSizeY, 0);
 	}
 
-	for(int a=1;a&lt;=MAX_LOS_TABLE;++a)
+	for (int a=1;a&lt;=MAX_LOS_TABLE;++a) {
 		OutputTable(a);
+	}
 
 	for(int a=0;a&lt;256;++a)
 		terrainHeight[a]=-15;

Modified: trunk/rts/Sim/Misc/LosHandler.h
===================================================================
--- trunk/rts/Sim/Misc/LosHandler.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Misc/LosHandler.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -87,6 +87,7 @@
 		// NOTE: units are treated differently than world objects in 2 ways:
 		//       1. they can be cloaked 
 		//       2. when underwater, they only get LOS if they also have sonar
+		//          (when the requireSonarUnderWater variable is enabled)
 		if (unit-&gt;alwaysVisible) {
 			return true;
 		}
@@ -103,7 +104,8 @@
 			return !!airLosMap[allyTeam][square];
 		}
 		else {
-			if (unit-&gt;isUnderWater &amp;&amp; !radarhandler-&gt;InRadar(unit, allyTeam)) {
+			if (unit-&gt;isUnderWater &amp;&amp; requireSonarUnderWater &amp;&amp;
+			    !radarhandler-&gt;InRadar(unit, allyTeam)) {
 				return false;
 			}
 			const int gx = (int)(unit-&gt;pos.x * invLosDiv);
@@ -149,6 +151,8 @@
 	int losSizeX;
 	int losSizeY;
 
+	bool requireSonarUnderWater;
+
 private:
 
 	void PostLoad();

Modified: trunk/rts/Sim/Misc/RadarHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/RadarHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Misc/RadarHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -6,11 +6,12 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;mmgr.h&quot;
 
+
 CR_BIND(CRadarHandler, (false));
 
 CR_REG_METADATA(CRadarHandler, (
 	CR_SERIALIZER(Serialize),
-	// radarMaps, airRadarMaps, sonarMaps, jammerMaps,
+	// radarMaps, airRadarMaps, sonarMaps, jammerMaps, sonarJammerMaps,
 	// seismicMaps, commonJammerMap, commonSonarJammerMap
 	CR_MEMBER(circularRadar),
 	CR_MEMBER(radarErrorSize),
@@ -22,17 +23,24 @@
 ));
 
 
+CRadarHandler* radarhandler = NULL;
+
+
 void CRadarHandler::Serialize(creg::ISerializer&amp; s)
 {
 	const int size = xsize*ysize*2;
 
 	// NOTE This could be tricky if gs is serialized after radarHandler.
-	for(int a = 0; a &lt; gs-&gt;activeAllyTeams; ++a) {
+	for (int a = 0; a &lt; gs-&gt;activeAllyTeams; ++a) {
 		s.Serialize(&amp;radarMaps[a].front(), size);
-		if (!circularRadar)
+		if (!circularRadar) {
 			s.Serialize(&amp;airRadarMaps[a].front(), size);
+		}
 		s.Serialize(&amp;sonarMaps[a].front(), size);
 		s.Serialize(&amp;jammerMaps[a].front(), size);
+#ifdef SONAR_JAMMER_MAPS
+		s.Serialize(&amp;sonarJammerMaps[a].front(), size);
+#endif
 		s.Serialize(&amp;seismicMaps[a].front(), size);
 	}
 	s.Serialize(&amp;commonJammerMap.front(), size);
@@ -40,203 +48,222 @@
 }
 
 
-CRadarHandler* radarhandler;
+CRadarHandler::CRadarHandler(bool circularRadar)
+: circularRadar(circularRadar),
+  baseRadarErrorSize(96),
+  xsize(gs-&gt;mapx / RADAR_SIZE),
+  ysize(gs-&gt;mapy / RADAR_SIZE),
+  targFacEffect(2)
+{
+	const int size = xsize * ysize;
 
+	commonJammerMap.resize(size, 0);
+	commonSonarJammerMap.resize(size, 0);
 
-CRadarHandler::CRadarHandler(bool circularRadar):
-		circularRadar(circularRadar),
-		baseRadarErrorSize(96),
-		xsize(gs-&gt;mapx / RADAR_SIZE),
-		ysize(gs-&gt;mapy / RADAR_SIZE),
-		targFacEffect(2)
-{
-	commonJammerMap.resize(xsize*ysize,0);
-	commonSonarJammerMap.resize(xsize*ysize,0);
-
-	for(int a=0;a&lt;gs-&gt;activeAllyTeams;++a){
-		radarMaps[a].resize(xsize*ysize,0);
-		sonarMaps[a].resize(xsize*ysize,0);
-		seismicMaps[a].resize(xsize*ysize,0);
-		airRadarMaps[a].resize(xsize*ysize,0);
-		jammerMaps[a].resize(xsize*ysize,0);
-		radarErrorSize[a]=96;
+	for (int a = 0; a &lt; gs-&gt;activeAllyTeams; ++a) {
+		radarMaps[a].resize(size, 0);
+		sonarMaps[a].resize(size, 0);
+		seismicMaps[a].resize(size, 0);
+		airRadarMaps[a].resize(size, 0);
+		jammerMaps[a].resize(size, 0);
+#ifdef SONAR_JAMMER_MAPS
+		sonarJammerMaps[a].resize(size, 0);
+#endif
+		radarErrorSize[a] = 96;
 	}
 }
 
+
 CRadarHandler::~CRadarHandler()
 {
 }
 
+
 //todo: add the optimizations that is in loshandler
 void CRadarHandler::MoveUnit(CUnit* unit)
 {
 	int2 newPos;
-	newPos.x=(int) (unit-&gt;pos.x/(SQUARE_SIZE*RADAR_SIZE));
-	newPos.y=(int) (unit-&gt;pos.z/(SQUARE_SIZE*RADAR_SIZE));
+	newPos.x = (int) (unit-&gt;pos.x / (SQUARE_SIZE * RADAR_SIZE));
+	newPos.y = (int) (unit-&gt;pos.z / (SQUARE_SIZE * RADAR_SIZE));
 
-	if(newPos.x!=unit-&gt;oldRadarPos.x || newPos.y!=unit-&gt;oldRadarPos.y){
+	if ((newPos.x != unit-&gt;oldRadarPos.x) ||
+	    (newPos.y != unit-&gt;oldRadarPos.y)) {
 		RemoveUnit(unit);
 		SCOPED_TIMER(&quot;Radar&quot;);
-		if(unit-&gt;jammerRadius){
-			AddMapArea(newPos,unit-&gt;jammerRadius,jammerMaps[unit-&gt;allyteam],1);
-			AddMapArea(newPos,unit-&gt;jammerRadius,commonJammerMap,1);
+		if (unit-&gt;jammerRadius) {
+			AddMapArea(newPos, unit-&gt;jammerRadius, jammerMaps[unit-&gt;allyteam], 1);
+			AddMapArea(newPos, unit-&gt;jammerRadius, commonJammerMap, 1);
 		}
-		if(unit-&gt;sonarJamRadius){
-			AddMapArea(newPos,unit-&gt;sonarJamRadius,commonSonarJammerMap,1);
+		if (unit-&gt;sonarJamRadius) {
+#ifdef SONAR_JAMMER_MAPS
+			AddMapArea(newPos, unit-&gt;sonarJamRadius, sonarJammerMaps[unit-&gt;allyteam], 1);
+#endif
+			AddMapArea(newPos, unit-&gt;sonarJamRadius, commonSonarJammerMap, 1);
 		}
-		if(unit-&gt;radarRadius){
-			AddMapArea(newPos,unit-&gt;radarRadius,airRadarMaps[unit-&gt;allyteam],1);
-			if(!circularRadar){
+		if (unit-&gt;radarRadius) {
+			AddMapArea(newPos, unit-&gt;radarRadius, airRadarMaps[unit-&gt;allyteam], 1);
+			if (!circularRadar) {
 				SafeLosRadarAdd(unit);
 			}
 		}
-		if(unit-&gt;sonarRadius){
-			AddMapArea(newPos,unit-&gt;sonarRadius,sonarMaps[unit-&gt;allyteam],1);
+		if (unit-&gt;sonarRadius) {
+			AddMapArea(newPos, unit-&gt;sonarRadius, sonarMaps[unit-&gt;allyteam], 1);
 		}
-		if(unit-&gt;seismicRadius){
-			AddMapArea(newPos,unit-&gt;seismicRadius,seismicMaps[unit-&gt;allyteam],1);
+		if (unit-&gt;seismicRadius) {
+			AddMapArea(newPos, unit-&gt;seismicRadius, seismicMaps[unit-&gt;allyteam], 1);
 		}
-		unit-&gt;oldRadarPos=newPos;
+		unit-&gt;oldRadarPos = newPos;
 	}
 }
 
+
 void CRadarHandler::RemoveUnit(CUnit* unit)
 {
 	SCOPED_TIMER(&quot;Radar&quot;);
 
-	if(unit-&gt;oldRadarPos.x&gt;=0){
-		if(unit-&gt;jammerRadius){
-			AddMapArea(unit-&gt;oldRadarPos,unit-&gt;jammerRadius,jammerMaps[unit-&gt;allyteam],-1);
-			AddMapArea(unit-&gt;oldRadarPos,unit-&gt;jammerRadius,commonJammerMap,-1);
+	if (unit-&gt;oldRadarPos.x &gt;= 0) {
+		if (unit-&gt;jammerRadius) {
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;jammerRadius, jammerMaps[unit-&gt;allyteam], -1);
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;jammerRadius, commonJammerMap, -1);
 		}
-		if(unit-&gt;sonarJamRadius){
-			AddMapArea(unit-&gt;oldRadarPos,unit-&gt;sonarJamRadius,commonSonarJammerMap,-1);
+		if (unit-&gt;sonarJamRadius) {
+#ifdef SONAR_JAMMER_MAPS
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarJamRadius, sonarJammerMaps[unit-&gt;allyteam], -1);
+#endif
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarJamRadius, commonSonarJammerMap, -1);
 		}
-		if(unit-&gt;radarRadius){
-			AddMapArea(unit-&gt;oldRadarPos,unit-&gt;radarRadius,airRadarMaps[unit-&gt;allyteam],-1);
-			if(!circularRadar){
-				for(std::vector&lt;int&gt;::iterator ri=unit-&gt;radarSquares.begin();ri!=unit-&gt;radarSquares.end();++ri){
+		if (unit-&gt;radarRadius) {
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;radarRadius, airRadarMaps[unit-&gt;allyteam], -1);
+			if (!circularRadar) {
+				for(std::vector&lt;int&gt;::iterator ri = unit-&gt;radarSquares.begin(); ri != unit-&gt;radarSquares.end(); ++ri) {
 					--radarMaps[unit-&gt;allyteam][*ri];
 				}
 				unit-&gt;radarSquares.clear();
 			}
 		}
-		if(unit-&gt;sonarRadius){
-			AddMapArea(unit-&gt;oldRadarPos,unit-&gt;sonarRadius,sonarMaps[unit-&gt;allyteam],-1);
+		if (unit-&gt;sonarRadius) {
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;sonarRadius, sonarMaps[unit-&gt;allyteam], -1);
 		}
-		if(unit-&gt;seismicRadius){
-			AddMapArea(unit-&gt;oldRadarPos,unit-&gt;seismicRadius,seismicMaps[unit-&gt;allyteam],-1);
+		if (unit-&gt;seismicRadius) {
+			AddMapArea(unit-&gt;oldRadarPos, unit-&gt;seismicRadius, seismicMaps[unit-&gt;allyteam], -1);
 		}
-		unit-&gt;oldRadarPos.x=-1;
+		unit-&gt;oldRadarPos.x = -1;
 	}
 }
 
+
 void CRadarHandler::AddMapArea(int2 pos, int radius, std::vector&lt;unsigned short&gt;&amp; map, int amount)
 {
-	int sx = std::max(0,pos.x-radius);
-	int ex = std::min(xsize-1,pos.x+radius);
-	int sy = std::max(0,pos.y-radius);
-	int ey = std::min(ysize-1,pos.y+radius);
+	const int sx = std::max(0, pos.x - radius);
+	const int ex = std::min(xsize - 1, pos.x + radius);
+	const int sy = std::max(0, pos.y - radius);
+	const int ey = std::min(ysize - 1, pos.y + radius);
 
-	int rr = radius * radius;
+	const int rr = (radius * radius);
+
 	for (int y = sy; y &lt;= ey; ++y) {
-		int rrx = rr - (pos.y - y) * (pos.y - y);
+		const int rrx = rr - ((pos.y - y) * (pos.y - y));
 		for (int x = sx; x &lt;= ex; ++x) {
-			if ((pos.x - x) * (pos.x - x) &lt;= rrx) {
-				map[y * xsize + x] += amount;
+			if (((pos.x - x) * (pos.x - x)) &lt;= rrx) {
+				map[(y * xsize) + x] += amount;
 			}
 		}
 	}
 }
 
+
 void CRadarHandler::SafeLosRadarAdd(CUnit* unit)
 {
-	float3 pos=unit-&gt;pos;
+	float3 pos = unit-&gt;pos;
 	pos.CheckInBounds();
-	int xradar=(int) (pos.x/(SQUARE_SIZE*RADAR_SIZE));
-	int yradar=(int) (pos.z/(SQUARE_SIZE*RADAR_SIZE));
-	int xmap=(int) (pos.x/(SQUARE_SIZE*2));
-	int ymap=(int) (pos.z/(SQUARE_SIZE*2));
-	int allyteam=unit-&gt;allyteam;
+	int xradar = (int) (pos.x / (SQUARE_SIZE * RADAR_SIZE));
+	int yradar = (int) (pos.z / (SQUARE_SIZE * RADAR_SIZE));
+	int xmap = (int) (pos.x / (SQUARE_SIZE * 2));
+	int ymap = (int) (pos.z / (SQUARE_SIZE * 2));
+	int allyteam = unit-&gt;allyteam;
 
-	int tablenum=unit-&gt;radarRadius;
-	if(tablenum&gt;MAX_LOS_TABLE){
-		tablenum=MAX_LOS_TABLE;
+	int tablenum = unit-&gt;radarRadius;
+	if (tablenum &gt; MAX_LOS_TABLE) {
+		tablenum = MAX_LOS_TABLE;
 	}
-	CLosHandler::LosTable&amp; table=loshandler-&gt;lostables[tablenum-1];
+	CLosHandler::LosTable&amp; table = loshandler-&gt;lostables[tablenum-1];
 
 	CLosHandler::LosTable::iterator li;
-	for(li=table.begin();li!=table.end();++li){
-		CLosHandler::LosLine&amp; line=*li;
+	for (li = table.begin(); li != table.end(); ++li) {
+		CLosHandler::LosLine&amp; line = *li;
 		CLosHandler::LosLine::iterator linei;
-		float baseHeight=pos.y+unit-&gt;model-&gt;height-20;
-		float maxAng1=-1000;
-		float maxAng2=-1000;
-		float maxAng3=-1000;
-		float maxAng4=-1000;
-		float r=1;
-		unit-&gt;radarSquares.push_back(yradar*xsize+xradar);
-		radarMaps[allyteam][yradar*xsize+xradar]++;
+		float baseHeight = pos.y + unit-&gt;model-&gt;height - 20;
+		float maxAng1 = -1000;
+		float maxAng2 = -1000;
+		float maxAng3 = -1000;
+		float maxAng4 = -1000;
+		float r = 1;
+		unit-&gt;radarSquares.push_back(yradar * xsize + xradar);
+		radarMaps[allyteam][yradar * xsize + xradar]++;
 
-		for(linei=line.begin();linei!=line.end();++linei){
-			if(xradar+linei-&gt;x &lt; xsize &amp;&amp; yradar+linei-&gt;y &lt; ysize){
-				int rsquare=(xradar+linei-&gt;x)+(yradar+linei-&gt;y)*xsize;
-				int msquare=(xmap+linei-&gt;x*4)+(ymap+linei-&gt;y*4)*gs-&gt;hmapx;
-				float dh=readmap-&gt;mipHeightmap[1][msquare]-baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng1){
+		for (linei = line.begin(); linei != line.end(); ++linei) {
+			if (((xradar + linei-&gt;x) &lt; xsize) &amp;&amp;
+			    ((yradar + linei-&gt;y) &lt; ysize)) {
+				int rsquare = (xradar + linei-&gt;x) + (yradar + linei-&gt;y) * xsize;
+				int msquare = (xmap + linei-&gt;x * 4) + (ymap + linei-&gt;y * 4) * gs-&gt;hmapx;
+				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
+				float ang = dh / r;
+				if (ang &gt; maxAng1) {
 					unit-&gt;radarSquares.push_back(rsquare);
 					radarMaps[allyteam][rsquare]++;
 				}
-				dh-=20;
-				ang=dh/r;
-				if(ang&gt;maxAng1){
-					maxAng1=ang;
+				dh -= 20;
+				ang = dh / r;
+				if (ang &gt; maxAng1) {
+					maxAng1 = ang;
 				}
 			}
-			if(xradar-linei-&gt;x &gt;= 0 &amp;&amp; yradar-linei-&gt;y &gt;= 0){
-				int rsquare=(xradar-linei-&gt;x)+(yradar-linei-&gt;y)*xsize;
-				int msquare=(xmap-linei-&gt;x*4)+(ymap-linei-&gt;y*4)*gs-&gt;hmapx;
-				float dh=readmap-&gt;mipHeightmap[1][msquare]-baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng2){
+			if (((xradar - linei-&gt;x) &gt;= 0) &amp;&amp;
+			    ((yradar - linei-&gt;y) &gt;= 0)) {
+				int rsquare = (xradar - linei-&gt;x) + (yradar - linei-&gt;y) * xsize;
+				int msquare = (xmap - linei-&gt;x*4) + (ymap - linei-&gt;y * 4) * gs-&gt;hmapx;
+				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
+				float ang = dh / r;
+				if (ang &gt; maxAng2) {
 					unit-&gt;radarSquares.push_back(rsquare);
 					radarMaps[allyteam][rsquare]++;
 				}
-				dh-=20;
-				ang=dh/r;
-				if(ang&gt;maxAng2){
-					maxAng2=ang;
+				dh -= 20;
+				ang = dh / r;
+				if (ang &gt; maxAng2) {
+					maxAng2 = ang;
 				}
 			}
-			if(xradar+linei-&gt;y &lt; xsize &amp;&amp; yradar-linei-&gt;x &gt;= 0){
-				int rsquare=(xradar+linei-&gt;y)+(yradar-linei-&gt;x)*xsize;
-				int msquare=(xmap+linei-&gt;y*4)+(ymap-linei-&gt;x*4)*gs-&gt;hmapx;
-				float dh=readmap-&gt;mipHeightmap[1][msquare]-baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng3){
+			if (((xradar + linei-&gt;y) &lt; xsize) &amp;&amp;
+			    ((yradar - linei-&gt;x) &gt;= 0)) {
+				int rsquare = (xradar + linei-&gt;y) + (yradar - linei-&gt;x) * xsize;
+				int msquare = (xmap + linei-&gt;y * 4) + (ymap - linei-&gt;x * 4) * gs-&gt;hmapx;
+				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
+				float ang = dh / r;
+				if (ang &gt; maxAng3) {
 					unit-&gt;radarSquares.push_back(rsquare);
 					radarMaps[allyteam][rsquare]++;
 				}
-				dh-=20;
-				ang=dh/r;
-				if(ang&gt;maxAng3){
-					maxAng3=ang;
+				dh -= 20;
+				ang = dh / r;
+				if (ang &gt; maxAng3) {
+					maxAng3 = ang;
 				}
 			}
-			if(xradar-linei-&gt;y &gt;= 0 &amp;&amp; yradar+linei-&gt;x &lt; ysize){
-				int rsquare=(xradar-linei-&gt;y)+(yradar+linei-&gt;x)*xsize;
-				int msquare=(xmap-linei-&gt;y*4)+(ymap+linei-&gt;x*4)*gs-&gt;hmapx;
-				float dh=readmap-&gt;mipHeightmap[1][msquare]-baseHeight;
-				float ang=dh/r;
-				if(ang&gt;maxAng4){
+			if (((xradar - linei-&gt;y) &gt;= 0) &amp;&amp;
+			    ((yradar + linei-&gt;x) &lt; ysize)) {
+				int rsquare = (xradar - linei-&gt;y) + (yradar + linei-&gt;x) * xsize;
+				int msquare = (xmap - linei-&gt;y * 4) + (ymap + linei-&gt;x * 4) * gs-&gt;hmapx;
+				float dh = readmap-&gt;mipHeightmap[1][msquare] - baseHeight;
+				float ang = dh / r;
+				if (ang&gt;maxAng4) {
 					unit-&gt;radarSquares.push_back(rsquare);
 					radarMaps[allyteam][rsquare]++;
 				}
-				dh-=20;
-				ang=dh/r;
-				if(ang&gt;maxAng4){
-					maxAng4=ang;
+				dh -= 20;
+				ang = dh / r;
+				if (ang &gt; maxAng4) {
+					maxAng4 = ang;
 				}
 			}
 			r++;

Modified: trunk/rts/Sim/Misc/RadarHandler.h
===================================================================
--- trunk/rts/Sim/Misc/RadarHandler.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Misc/RadarHandler.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -6,8 +6,20 @@
 #include &quot;Object.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 
+
 #define RADAR_SIZE 8
 
+
+// Because submerged units are only given LOS if they are also
+// in sonar range (see LosHandler.h), sonar stealth and sonar
+// jammed units can not be detected (probably why those 2 features
+// are not being used by most mods). Uncommenting the following
+// line will allow the LOS display mode to differentiate between
+// radar and sonar coverage, and radar and sonar jammer coverage.
+
+//#define SONAR_JAMMER_MAPS
+
+
 class CRadarHandler : public boost::noncopyable
 {
 	CR_DECLARE(CRadarHandler);
@@ -90,6 +102,9 @@
 	std::vector&lt;unsigned short&gt; airRadarMaps[MAX_TEAMS];
 	std::vector&lt;unsigned short&gt; sonarMaps[MAX_TEAMS];
 	std::vector&lt;unsigned short&gt; jammerMaps[MAX_TEAMS];
+#ifdef SONAR_JAMMER_MAPS
+	std::vector&lt;unsigned short&gt; sonarJammerMaps[MAX_TEAMS];
+#endif
 	std::vector&lt;unsigned short&gt; seismicMaps[MAX_TEAMS];
 	std::vector&lt;unsigned short&gt; commonJammerMap;
 	std::vector&lt;unsigned short&gt; commonSonarJammerMap;

Modified: trunk/rts/Sim/ModInfo.cpp
===================================================================
--- trunk/rts/Sim/ModInfo.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/ModInfo.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -87,6 +87,7 @@
 	
 	// sensors
 	const LuaTable sensors = root.SubTable(&quot;sensors&quot;);
+	requireSonarUnderWater = sensors.GetBool(&quot;requireSonarUnderWater&quot;, true);
 	/// LoS
 	const LuaTable los = sensors.SubTable(&quot;los&quot;);
 	// losMipLevel is used as index to readmap-&gt;mipHeightmap,

Modified: trunk/rts/Sim/ModInfo.h
===================================================================
--- trunk/rts/Sim/ModInfo.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/ModInfo.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -50,6 +50,8 @@
 	float losMul;
 	/// units airsightdistance will be multiplied with this, for testing purposes
 	float airLosMul;
+	/// when underwater, units are not in LOS unless also in sonar
+	bool requireSonarUnderWater;
 };
 
 extern CModInfo modInfo;

Modified: trunk/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- trunk/rts/Sim/Path/PathEstimator.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Path/PathEstimator.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -870,10 +870,12 @@
 /*
 Gives a hash-code identifying the dataset of this estimator.
 */
-unsigned int CPathEstimator::Hash() {
+unsigned int CPathEstimator::Hash()
+{
 	return (readmap-&gt;mapChecksum + moveinfo-&gt;moveInfoChecksum + BLOCK_SIZE + moveMathOptions + PATHESTIMATOR_VERSION);
 }
 
+
 void CPathEstimator::Draw(void)
 {
 	MoveData* md = moveinfo-&gt;GetMoveDataFromName(&quot;TANKSH2&quot;);

Added: trunk/rts/Sim/SideParser.cpp
===================================================================
--- trunk/rts/Sim/SideParser.cpp	                        (rev 0)
+++ trunk/rts/Sim/SideParser.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,145 @@
+
+#include &quot;StdAfx.h&quot;
+
+#include &lt;string&gt;
+#include &lt;set&gt;
+using std::string;
+using std::set;
+
+#include &quot;SideParser.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Lua/LuaSyncedRead.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
+
+
+SideParser sideParser;
+
+
+/******************************************************************************/
+
+SideParser::SideParser()
+{
+}
+
+
+SideParser::~SideParser()
+{
+}
+
+
+bool SideParser::Load()
+{
+	dataVec.clear();
+	errorLog.clear();
+
+	LuaParser parser(&quot;gamedata/sidedata.lua&quot;,
+	                 SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!parser.Execute()) {
+		errorLog = parser.GetErrorLog();
+		return false;
+	}
+
+	set&lt;string&gt; sideSet;
+
+	const LuaTable root = parser.GetRoot();
+	for (int i = 1; /* no-op */; i++) {
+		const LuaTable sideTable = root.SubTable(i);
+		if (!sideTable.IsValid()) {
+			break;
+		}
+
+		Data data;
+		data.caseName  = sideTable.GetString(&quot;name&quot;, &quot;&quot;);
+		data.sideName  = StringToLower(data.caseName);
+		data.startUnit = sideTable.GetString(&quot;startUnit&quot;, &quot;&quot;);
+		data.startUnit = StringToLower(data.startUnit);
+
+		if (data.sideName.empty()) {
+			logOutput.Print(&quot;Missing side name: %i&quot;, i);
+		}
+		else if (data.startUnit.empty()) {
+			logOutput.Print(&quot;Missing side start unit: &quot; + data.sideName);
+		}
+		else {
+			if (sideSet.find(data.sideName) != sideSet.end()) {
+				logOutput.Print(&quot;Duplicate side name: &quot; + data.sideName);
+			}
+			else {
+				sideSet.insert(data.sideName);
+				dataVec.push_back(data);
+			}
+		}
+	}
+	return true;
+}
+
+ 
+/******************************************************************************/
+
+const SideParser::Data* SideParser::FindSide(const string&amp; sideName) const
+{
+	const string name = StringToLower(sideName);
+	for (unsigned int i = 0; i &lt; dataVec.size(); i++) {
+		const Data&amp; data = dataVec[i];
+		if (name == data.sideName) {
+			return &data;
+		}
+	}
+	return NULL;
+}
+
+
+const string&amp; SideParser::GetSideName(unsigned int index,
+                                      const string&amp; def) const
+{
+	if (!ValidSide(index)) {
+		return def;
+	}
+	return dataVec[index].sideName;
+}
+
+
+const string&amp; SideParser::GetCaseName(unsigned int index,
+                                      const string&amp; def) const
+{
+	if (!ValidSide(index)) {
+		return def;
+	}
+	return dataVec[index].caseName;
+}
+
+
+const string&amp; SideParser::GetCaseName(const string&amp; name,
+                                      const string&amp; def) const
+{
+	const Data* data = FindSide(name);
+	if (data == NULL) {
+		return def;
+	}
+	return data-&gt;caseName;
+}
+
+
+const string&amp; SideParser::GetStartUnit(unsigned int index,
+                                       const string&amp; def) const
+{
+	if (!ValidSide(index)) {
+		return def;
+	}
+	return dataVec[index].startUnit;
+}
+
+
+const string&amp; SideParser::GetStartUnit(const string&amp; name,
+                                       const string&amp; def) const
+{
+	const Data* data = FindSide(name);
+	if (data == NULL) {
+		return def;
+	}
+	return data-&gt;startUnit;
+}
+
+
+/******************************************************************************/

Added: trunk/rts/Sim/SideParser.h
===================================================================
--- trunk/rts/Sim/SideParser.h	                        (rev 0)
+++ trunk/rts/Sim/SideParser.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,54 @@
+
+#ifndef SIDE_PARSER_H
+#define SIDE_PARSER_H
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+
+
+class SideParser
+{
+	public:
+		SideParser();
+		~SideParser();
+
+		bool Load();
+		const std::string&amp; GetErrorLog() const { return errorLog; }
+
+		const unsigned int GetCount() const { return dataVec.size(); }
+
+		const std::string&amp; GetSideName(unsigned int index,
+		                               const std::string&amp; def = &quot;&quot;) const;
+		const std::string&amp; GetCaseName(unsigned int index,
+		                               const std::string&amp; def = &quot;&quot;) const;
+		const std::string&amp; GetCaseName(const std::string&amp; name,
+		                               const std::string&amp; def = &quot;&quot;) const;
+		const std::string&amp; GetStartUnit(unsigned int index,
+		                                const std::string&amp; def = &quot;&quot;) const;
+		const std::string&amp; GetStartUnit(const std::string&amp; name,
+		                                const std::string&amp; def = &quot;&quot;) const;
+
+		bool ValidSide(unsigned int index) const {
+			return (index &lt; dataVec.size());
+		}
+
+	private:
+		struct Data {
+			std::string caseName;  // full  case
+			std::string sideName;  // lower case
+			std::string startUnit; // lower case
+		};
+		typedef std::vector&lt;Data&gt; DataVec;
+
+		const Data* FindSide(const std::string&amp; sideName) const;
+
+	private:
+		DataVec dataVec;
+		std::string errorLog;
+};
+
+
+extern SideParser sideParser;
+
+
+#endif // SIDE_PARSER_H

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -116,6 +116,8 @@
 	upright(true),
 	falling(false),
 	fallSpeed(0.2),
+	inAir(false),
+	inWater(false),
 	maxRange(0),
 	haveTarget(false),
 	lastAttacker(0),
@@ -499,13 +501,34 @@
 		return;
 	}
 
-
 	if (beingBuilt) {
 		return;
 	}
 
+	const bool oldInAir   = inAir;
+	const bool oldInWater = inWater;
+
 	moveType-&gt;Update();
 
+	const float top = (pos.y + height);
+	inAir   = ((pos.y + height) &gt;= 0.0f);
+	inWater =  (pos.y           &lt;= 0.0f);
+
+	if (inAir != oldInAir) {
+		if (inAir) {
+			luaCallIns.UnitEnteredAir(this);
+		} else {
+			luaCallIns.UnitLeftAir(this);
+		}
+	}
+	if (inWater != oldInWater) {
+		if (inWater) {
+			luaCallIns.UnitEnteredWater(this);
+		} else {
+			luaCallIns.UnitLeftWater(this);
+		}
+	}
+
 	if (travelPeriod != 0.0f) {
 		travel += speed.Length();
 		travel = fmod(travel, travelPeriod);
@@ -2294,6 +2317,8 @@
 				CR_MEMBER(isDead),
 				CR_MEMBER(falling),
 				CR_MEMBER(fallSpeed),
+				CR_MEMBER(fallSpeed),
+				CR_MEMBER(fallSpeed),
 
 				CR_MEMBER(flankingBonusMode),
 				CR_MEMBER(flankingBonusDir),
@@ -2338,7 +2363,10 @@
 				CR_MEMBER(maxSpeed),
 				CR_MEMBER(weaponHitMod),
 
-				CR_RESERVED(128),
+				CR_MEMBER(inAir),
+				CR_MEMBER(inWater),
 
+				CR_RESERVED(126),
+
 				CR_POSTLOAD(PostLoad)
 				));

Modified: trunk/rts/Sim/Units/Unit.h
===================================================================
--- trunk/rts/Sim/Units/Unit.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Units/Unit.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -319,6 +319,9 @@
 	bool	falling;  // for units being dropped from transports (parachute drops)
 	float	fallSpeed; 
 
+	bool inAir;
+	bool inWater;
+
 	int flankingBonusMode;  // 0 = no flanking bonus
 	                        // 1 = global coords, mobile
 	                        // 2 = unit coords, mobile

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -21,10 +21,11 @@
 #include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 #include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Sim/ModInfo.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 #include &quot;Sim/Misc/CategoryHandler.h&quot;
 #include &quot;Sim/Misc/CollisionVolume.h&quot;
 #include &quot;Sim/Misc/DamageArrayHandler.h&quot;
-#include &quot;Sim/ModInfo.h&quot;
 #include &quot;Sim/Projectiles/ExplosionGenerator.h&quot;
 #include &quot;Sim/Units/COB/CobFile.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
@@ -222,23 +223,8 @@
 
 void CUnitDefHandler::FindStartUnits()
 {
-	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-	                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-	if (!luaParser.Execute()) {
-		logOutput.Print(luaParser.GetErrorLog());
-	}
-
-	const LuaTable sideData = luaParser.GetRoot();
-	// get the startUnit UnitDef IDs
-	startUnitIDs.clear();
-	std::vector&lt;std::string&gt; sides;
-	for (int i = 1; true; i++) {
-		const LuaTable side = sideData.SubTable(i);
-		if (!side.IsValid()) {
-			break;
-		}
-		std::string startUnit = side.GetString(&quot;startUnit&quot;, &quot;&quot;);
-		StringToLowerInPlace(startUnit);
+	for (unsigned int i = 0; i &lt; sideParser.GetCount(); i++) {
+		const std::string&amp; startUnit = sideParser.GetStartUnit(i);
 		if (!startUnit.empty()) {
 			std::map&lt;std::string, int&gt;::iterator it = unitID.find(startUnit);
 			if (it != unitID.end()) {

Modified: trunk/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitLoader.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/Sim/Units/UnitLoader.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -325,10 +325,11 @@
 
 
 
-	if (ud-&gt;floater)
+	if (ud-&gt;floater) {
 		unit-&gt;pos.y = std::max(-ud-&gt;waterline, ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z));
-	else
+	} else {
 		unit-&gt;pos.y = ground-&gt;GetHeight2(unit-&gt;pos.x, unit-&gt;pos.z);
+	}
 
 	unit-&gt;cob = SAFE_NEW CCobInstance(GCobEngine.GetCobFile(&quot;scripts/&quot; + name + &quot;.cob&quot;), unit);
 	unit-&gt;localmodel = modelParser-&gt;CreateLocalModel(unit-&gt;model, &amp;unit-&gt;cob-&gt;pieces);
@@ -348,8 +349,9 @@
 	relMax *= 30;		// convert ticks to milliseconds
 
 	// TA does some special handling depending on weapon count
-	if (unit-&gt;weapons.size() &gt; 1)
+	if (unit-&gt;weapons.size() &gt; 1) {
 		relMax = std::max(relMax, 3000);
+	}
 
 	// Call initializing script functions
 	unit-&gt;cob-&gt;Call(COBFN_Create);
@@ -364,8 +366,9 @@
 
 	unit-&gt;Init(builder);
 
-	if(!build)
+	if (!build) {
 		unit-&gt;FinishedBuilding();
+	}
 
 	return unit;
 }

Modified: trunk/rts/System/FileSystem/ArchiveFactory.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveFactory.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/FileSystem/ArchiveFactory.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -8,38 +8,58 @@
 #include &lt;algorithm&gt;
 #include &quot;mmgr.h&quot;
 
+
 // Returns true if the indicated file is in fact an archive
-bool CArchiveFactory::IsArchive(const std::string&amp; fileName)
+bool CArchiveFactory::IsScanArchive(const std::string&amp; fileName)
 {
 	std::string ext = StringToLower(filesystem.GetExtension(fileName));
 
 	return  (ext == &quot;sd7&quot;) || (ext == &quot;sdz&quot;) || (ext == &quot;sdd&quot;) ||
-			(ext == &quot;ccx&quot;) || (ext == &quot;hpi&quot;) || (ext == &quot;ufo&quot;) || (ext == &quot;gp3&quot;) || (ext == &quot;gp4&quot;) || (ext == &quot;swx&quot;);
+	        (ext == &quot;ccx&quot;) || (ext == &quot;hpi&quot;) || (ext == &quot;ufo&quot;) ||
+	        (ext == &quot;gp3&quot;) || (ext == &quot;gp4&quot;) || (ext == &quot;swx&quot;);
 }
 
+
 // Returns a pointer to a newly created suitable subclass of CArchiveBase
-CArchiveBase* CArchiveFactory::OpenArchive(const std::string&amp; fileName)
+CArchiveBase* CArchiveFactory::OpenArchive(const std::string&amp; fileName,
+                                           const std::string&amp; type)
 {
-	std::string ext = StringToLower(filesystem.GetExtension(fileName));
+	std::string ext = type;
+	if (type.empty()) {
+		ext = StringToLower(filesystem.GetExtension(fileName));
+	}
+
+	     if (ext == &quot;sd7&quot;) { ext = &quot;7z&quot;;  }
+	else if (ext == &quot;sdz&quot;) { ext = &quot;zip&quot;; }
+	else if (ext == &quot;sdd&quot;) { ext = &quot;dir&quot;; }
+	else if ((ext == &quot;ccx&quot;) || (ext == &quot;hpi&quot;) || (ext == &quot;ufo&quot;) ||
+	         (ext == &quot;gp3&quot;) || (ext == &quot;gp4&quot;) || (ext == &quot;swx&quot;)) {
+		ext = &quot;hpi&quot;;
+	}
+	
+
 	std::string fn = filesystem.LocateFile(fileName);
 
 	CArchiveBase* ret = NULL;
 
-	if (ext == &quot;sd7&quot;)
+	if (ext == &quot;7z&quot;) {
 		ret = SAFE_NEW CArchive7Zip(fn);
-	else if (ext == &quot;sdz&quot;)
+	} else if (ext == &quot;zip&quot;) {
 		ret = SAFE_NEW CArchiveZip(fn);
-	else if (ext == &quot;sdd&quot;)
+	} else if (ext == &quot;dir&quot;) {
 		ret = SAFE_NEW CArchiveDir(fn);
-	else if ((ext == &quot;ccx&quot;) || (ext == &quot;hpi&quot;) || (ext == &quot;ufo&quot;) || (ext == &quot;gp3&quot;) || (ext == &quot;gp4&quot;) || (ext == &quot;swx&quot;))
+	} else if (ext == &quot;hpi&quot;) {
 		ret = SAFE_NEW CArchiveHPI(fn);
+	}
 
-	if (ret &amp;&amp; ret-&gt;IsOpen())
+	if (ret &amp;&amp; ret-&gt;IsOpen()) {
 		return ret;
+	}
 
 	delete ret;
 	return NULL;
 }
 
+
 CArchiveBase::~CArchiveBase() {
 }

Modified: trunk/rts/System/FileSystem/ArchiveFactory.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveFactory.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/FileSystem/ArchiveFactory.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -7,8 +7,9 @@
 class CArchiveFactory
 {
 public:
-	static bool IsArchive(const std::string&amp; fileName);
-	static CArchiveBase* OpenArchive(const std::string&amp; fileName);
+	static bool IsScanArchive(const std::string&amp; fileName);
+	static CArchiveBase* OpenArchive(const std::string&amp; fileName,
+	                                 const std::string&amp; type = &quot;&quot;);
 };
 
 #endif

Modified: trunk/rts/System/FileSystem/ArchiveScanner.cpp
===================================================================
--- trunk/rts/System/FileSystem/ArchiveScanner.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/FileSystem/ArchiveScanner.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -112,30 +112,34 @@
 {
 	const int flags = (FileSystem::INCLUDE_DIRS | FileSystem::RECURSE);
 	vector&lt;string&gt; found = filesystem.FindFiles(curPath, &quot;springcontent.sdz&quot;, flags);
-	if (!found.empty()) {
-		CArchiveBase* ar = CArchiveFactory::OpenArchive(found[0]);
-		if (ar) {
-			string name;
-			int size;
-			for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
-				if (name == &quot;gamedata/parse_tdf.lua&quot;) {
-					const int fh = ar-&gt;OpenFile(name);
-					if (fh != 0) {
-						parse_tdf_path = found[0];
-						ar-&gt;CloseFile(fh);
-					}
-				}
-				else if (name == &quot;gamedata/scanutils.lua&quot;) {
-					const int fh = ar-&gt;OpenFile(name);
-					if (fh != 0) {
-						scanutils_path = found[0];
-						ar-&gt;CloseFile(fh);
-					}
-				}
+	if (found.empty()) {
+		return;
+	}
+	CArchiveBase* ar = CArchiveFactory::OpenArchive(found[0]);
+	if (ar == NULL) {
+		return;
+	}
+
+	string name;
+	int size;
+	for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+		if (name == &quot;gamedata/parse_tdf.lua&quot;) {
+			const int fh = ar-&gt;OpenFile(name);
+			if (fh != 0) {
+				parse_tdf_path = found[0];
+				ar-&gt;CloseFile(fh);
 			}
-			delete ar;
 		}
+		else if (name == &quot;gamedata/scanutils.lua&quot;) {
+			const int fh = ar-&gt;OpenFile(name);
+			if (fh != 0) {
+				scanutils_path = found[0];
+				ar-&gt;CloseFile(fh);
+			}
+		}
 	}
+
+	delete ar;
 }
 
 
@@ -157,8 +161,7 @@
 	char* buf = SAFE_NEW char[fsize];
 	ar-&gt;ReadFile(fh, buf, fsize);
 	ar-&gt;CloseFile(fh);
-	source.clear();
-	source.append(buf, fsize);
+	source.assign(buf, fsize);
 	delete [] buf;
 
 	delete ar;
@@ -167,7 +170,7 @@
 }
 
 
-void CArchiveScanner::ScanDirs(const vector&lt;string&gt;&amp; scanDirs, bool checksum)
+void CArchiveScanner::ScanDirs(const vector&lt;string&gt;&amp; scanDirs, bool doChecksum)
 {
 	// pre-scan for the modinfo utils
 	for (unsigned int d = 0; d &lt; scanDirs.size(); d++) {
@@ -192,12 +195,12 @@
 	// add the archives
 	for (unsigned int d = 0; d &lt; scanDirs.size(); d++) {
 		logOutput.Print(&quot;Scanning: %s\n&quot;, scanDirs[d].c_str());
-		Scan(scanDirs[d], checksum);
+		Scan(scanDirs[d], doChecksum);
 	}
 }
 
 
-void CArchiveScanner::Scan(const string&amp; curPath, bool checksum)
+void CArchiveScanner::Scan(const string&amp; curPath, bool doChecksum)
 {
 	isDirty = true;
 
@@ -230,8 +233,8 @@
 		}
 
 		// Is this an archive we should look into?
-		if (CArchiveFactory::IsArchive(fullName)) {
-			ScanArchive(fullName, checksum);
+		if (CArchiveFactory::IsScanArchive(fullName)) {
+			ScanArchive(fullName, doChecksum);
 		}
 	}
 
@@ -263,7 +266,7 @@
 }
 
 
-void CArchiveScanner::ScanArchive(const string&amp; fullName, bool checksum)
+void CArchiveScanner::ScanArchive(const string&amp; fullName, bool doChecksum)
 {
 	struct stat info;
 
@@ -322,7 +325,7 @@
 	// Time to parse the info we are interested in
 	if (cached) {
 		// If cached is true, aii will point to the archive
-		if ((checksum) &amp;&amp; (aii-&gt;second.checksum == 0)) {
+		if (doChecksum &amp;&amp; (aii-&gt;second.checksum == 0)) {
 			aii-&gt;second.checksum = GetCRC(fullName);
 		}
 	}
@@ -334,7 +337,6 @@
 			string name;
 			int size;
 			for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
-				//printf(&quot;found %s %d\n&quot;, name.c_str(), size);
 				string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
 
 				// only accept new format maps
@@ -360,7 +362,7 @@
 			// To prevent reading all files in all directory (.sdd) archives
 			// every time this function is called, directory archive checksums
 			// are calculated on the fly.
-			if (checksum) {
+			if (doChecksum) {
 				ai.checksum = GetCRC(fullName);
 			} else {
 				ai.checksum = 0;
@@ -372,7 +374,7 @@
 }
 
 
-void CArchiveScanner::ScanMap(CArchiveBase* ar, const string&amp; fileName,
+bool CArchiveScanner::ScanMap(CArchiveBase* ar, const string&amp; fileName,
                               ArchiveInfo&amp; ai)
 {
 	MapData md;
@@ -394,64 +396,71 @@
 		}
 	}
 	ai.mapData.push_back(md);
+	return true;
 }
 
 
-void CArchiveScanner::ScanModLua(CArchiveBase* ar, const string&amp; fileName,
+bool CArchiveScanner::ScanModLua(CArchiveBase* ar, const string&amp; fileName,
                                  ArchiveInfo&amp; ai)
 {
 	const int fh = ar-&gt;OpenFile(fileName);
-	if (fh) {
-		const int fsize = ar-&gt;FileSize(fh);
+	if (fh == 0) {
+		return false;
+	}
+	const int fsize = ar-&gt;FileSize(fh);
 
-		char* buf = SAFE_NEW char[fsize];
-		ar-&gt;ReadFile(fh, buf, fsize);
-		ar-&gt;CloseFile(fh);
-		
-		string cleanbuf;
-		cleanbuf.append(buf, fsize);
-		delete [] buf;
-		LuaParser p(cleanbuf, SPRING_VFS_MOD);
-		if (!p.Execute()) {
-			logOutput.Print(p.GetErrorLog());
-		}
-		const LuaTable modTable = p.GetRoot();
-		ai.modData = GetModData(modTable);
+	char* buf = SAFE_NEW char[fsize];
+	ar-&gt;ReadFile(fh, buf, fsize);
+	ar-&gt;CloseFile(fh);
+	
+	const string cleanbuf(buf, fsize);
+	delete [] buf;
+	LuaParser p(cleanbuf, SPRING_VFS_MOD);
+	if (!p.Execute()) {
+		logOutput.Print(&quot;ERROR in &quot; + fileName + &quot;: &quot; + p.GetErrorLog());
+		return false;
 	}
+	const LuaTable modTable = p.GetRoot();
+	ai.modData = GetModData(modTable);
+
+	return true;
 }
 
 
-void CArchiveScanner::ScanModTdf(CArchiveBase* ar, const string&amp; fileName,
+bool CArchiveScanner::ScanModTdf(CArchiveBase* ar, const string&amp; fileName,
                                  ArchiveInfo&amp; ai)
 {
 	const int fh = ar-&gt;OpenFile(fileName);
-	if (fh) {
-		const int fsize = ar-&gt;FileSize(fh);
+	if (fh == 0) {
+		return false;
+	}
+	const int fsize = ar-&gt;FileSize(fh);
 
-		char* buf = SAFE_NEW char[fsize];
-		ar-&gt;ReadFile(fh, buf, fsize);
-		ar-&gt;CloseFile(fh);
-		string cleanbuf;
-		cleanbuf.append(buf, fsize);
-		delete [] buf;
-		const string luaFile =
-				parse_tdf_code + &quot;\n\n&quot;
-			+ scanutils_code + &quot;\n\n&quot;
-			+ &quot;local tdfModinfo, err = TDFparser.ParseText([[\n&quot; 
-			+ cleanbuf + &quot;]])\n\n&quot;
-			+ &quot;if (tdfModinfo == nil) then\n&quot;
-			+ &quot;    error('Error parsing modinfo.tdf: ' .. err)\n&quot;
-			+ &quot;end\n\n&quot;
-			+ &quot;tdfModinfo.mod.depend  = MakeArray(tdfModinfo.mod, 'depend')\n&quot;
-			+ &quot;tdfModinfo.mod.replace = MakeArray(tdfModinfo.mod, 'replace')\n\n&quot;
-			+ &quot;return tdfModinfo.mod\n&quot;;
-		LuaParser p(luaFile, SPRING_VFS_MOD);
-		if (!p.Execute()) {
-			logOutput.Print(p.GetErrorLog());
-		}
-		const LuaTable modTable = p.GetRoot();
-		ai.modData = GetModData(modTable);
+	char* buf = SAFE_NEW char[fsize];
+	ar-&gt;ReadFile(fh, buf, fsize);
+	ar-&gt;CloseFile(fh);
+	const string cleanbuf(buf, fsize);
+	delete [] buf;
+	const string luaCode =
+			parse_tdf_code + &quot;\n\n&quot;
+		+ scanutils_code + &quot;\n\n&quot;
+		+ &quot;local tdfModinfo, err = TDFparser.ParseText([[\n&quot; 
+		+ cleanbuf + &quot;]])\n\n&quot;
+		+ &quot;if (tdfModinfo == nil) then\n&quot;
+		+ &quot;    error('Error parsing modinfo.tdf: ' .. err)\n&quot;
+		+ &quot;end\n\n&quot;
+		+ &quot;tdfModinfo.mod.depend  = MakeArray(tdfModinfo.mod, 'depend')\n&quot;
+		+ &quot;tdfModinfo.mod.replace = MakeArray(tdfModinfo.mod, 'replace')\n\n&quot;
+		+ &quot;return tdfModinfo.mod\n&quot;;
+	LuaParser p(luaCode, SPRING_VFS_MOD);
+	if (!p.Execute()) {
+		logOutput.Print(&quot;ERROR in &quot; + fileName + &quot;: &quot; + p.GetErrorLog());
+		return false;
 	}
+	const LuaTable modTable = p.GetRoot();
+	ai.modData = GetModData(modTable);
+
+	return true;
 }
 
 
@@ -481,7 +490,6 @@
 unsigned int CArchiveScanner::GetCRC(const string&amp; arcName)
 {
 	CRC crc;
-	unsigned int digest = 0;
 	CArchiveBase* ar;
 	std::list&lt;string&gt; files;
 
@@ -508,15 +516,16 @@
 
 	// Add all files in sorted order
 	for (std::list&lt;string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
-		digest = CRC().Update(i-&gt;data(), i-&gt;size()).GetDigest();
-		crc.Update(digest);
-		crc.Update(ar-&gt;GetCrc32(*i));
+		const unsigned int nameCRC = CRC().Update(i-&gt;data(), i-&gt;size()).GetDigest();
+		const unsigned int dataCRC = ar-&gt;GetCrc32(*i);
+		crc.Update(nameCRC);
+		crc.Update(dataCRC);
 	}
 
 	delete ignore;
 	delete ar;
 
-	digest = crc.GetDigest();
+	unsigned int digest = crc.GetDigest();
 
 	// A value of 0 is used to indicate no crc.. so never return that
 	// Shouldn't happen all that often
@@ -530,16 +539,16 @@
 
 void CArchiveScanner::ReadCacheData(const string&amp; filename)
 {
-  LuaParser p(filename, SPRING_VFS_RAW, SPRING_VFS_ALL);
+  LuaParser p(filename, SPRING_VFS_RAW, SPRING_VFS_BASE);
 	
 	if (!p.Execute()) {
-		logOutput.Print(p.GetErrorLog());
+		logOutput.Print(&quot;ERROR in &quot; + filename + &quot;: &quot; + p.GetErrorLog());
 	}
 	const LuaTable archiveCache = p.GetRoot();
 	const LuaTable archives = archiveCache.SubTable(&quot;archives&quot;);
 	
 	// Do not load old version caches
-	const int ver = archiveCache.GetInt(&quot;internalVer&quot;, 0);
+	const int ver = archiveCache.GetInt(&quot;internalVer&quot;, (INTERNAL_VER + 1));
 	if (ver != INTERNAL_VER) {
 		return;
 	}
@@ -551,8 +560,11 @@
 		ArchiveInfo ai;
 
 		ai.origName = curArchive.GetString(&quot;name&quot;, &quot;&quot;);
-		ai.path = curArchive.GetString(&quot;path&quot;, &quot;&quot;);
-		// don't use GetInt for modified and checksum as lua uses 32bit ints, no longs
+		ai.path     = curArchive.GetString(&quot;path&quot;, &quot;&quot;);
+
+		// do not use LuaTable.GetInt() for 32-bit integers, the Spring lua
+		// library uses 32-bit floats to represent numbers, which can only
+		// represent 2^24 consecutive integers
 		ai.modified = strtoul(curArchive.GetString(&quot;modified&quot;, &quot;0&quot;).c_str(), 0, 10);
 		ai.checksum = strtoul(curArchive.GetString(&quot;checksum&quot;, &quot;0&quot;).c_str(), 0, 10);
 		ai.updated = false;
@@ -613,18 +625,22 @@
 	}
 
 	fprintf(out, &quot;local archiveCache = {\n\n&quot;);
-	fprintf(out, &quot;\tinternalver = %d,\n\n&quot;, INTERNAL_VER);
-	fprintf(out, &quot;\tarchives = {\n&quot;);
+	fprintf(out, &quot;\tinternalver = %i,\n\n&quot;, INTERNAL_VER);
+	fprintf(out, &quot;\tarchives = {  -- count = %i\n&quot;, archiveInfo.size());
+
 	std::map&lt;string, ArchiveInfo&gt;::const_iterator arcIt;
 	for (arcIt = archiveInfo.begin(); arcIt != archiveInfo.end(); ++arcIt) {
+		const ArchiveInfo&amp; arcInfo = arcIt-&gt;second;
+
 		fprintf(out, &quot;\t\t{\n&quot;);
-		SafeStr(out, &quot;\t\t\tname = &quot;,            arcIt-&gt;second.origName);
-		SafeStr(out, &quot;\t\t\tpath = &quot;,            arcIt-&gt;second.path); 
-		fprintf(out, &quot;\t\t\tmodified = \&quot;%u\&quot;,\n&quot;, arcIt-&gt;second.modified);
-		fprintf(out, &quot;\t\t\tchecksum = \&quot;%u\&quot;,\n&quot;, arcIt-&gt;second.checksum);
-		SafeStr(out, &quot;\t\t\treplaced = &quot;,        arcIt-&gt;second.replaced);
+		SafeStr(out, &quot;\t\t\tname = &quot;,              arcInfo.origName);
+		SafeStr(out, &quot;\t\t\tpath = &quot;,              arcInfo.path); 
+		fprintf(out, &quot;\t\t\tmodified = \&quot;%u\&quot;,\n&quot;, arcInfo.modified);
+		fprintf(out, &quot;\t\t\tchecksum = \&quot;%u\&quot;,\n&quot;, arcInfo.checksum);
+		SafeStr(out, &quot;\t\t\treplaced = &quot;,          arcInfo.replaced);
 
-		const vector&lt;MapData&gt;&amp; mapData = arcIt-&gt;second.mapData;
+		// map info?
+		const vector&lt;MapData&gt;&amp; mapData = arcInfo.mapData;
 		if (!mapData.empty()) {
 			fprintf(out, &quot;\t\t\tmaps = {\n&quot;);
 			vector&lt;MapData&gt;::const_iterator mapIt;
@@ -637,8 +653,8 @@
 			fprintf(out, &quot;\t\t\t},\n&quot;);
 		}
 
-		// Any mod info? or just a map archive?
-		const ModData&amp; modData = arcIt-&gt;second.modData;
+		// mod info?
+		const ModData&amp; modData = arcInfo.modData;
 		if (modData.name != &quot;&quot;) {
 			fprintf(out, &quot;\t\t\tmoddata = {\n&quot;);
 			SafeStr(out, &quot;\t\t\t\tname = &quot;,         modData.name);

Modified: trunk/rts/System/FileSystem/ArchiveScanner.h
===================================================================
--- trunk/rts/System/FileSystem/ArchiveScanner.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/FileSystem/ArchiveScanner.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -83,9 +83,9 @@
 	void PreScan(const std::string&amp; curPath);
 	void Scan(const std::string&amp; curPath, bool checksum = false);
 	void ScanArchive(const std::string&amp; fullName, bool checksum = false);
-	void ScanMap(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
-	void ScanModLua(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
-	void ScanModTdf(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
+	bool ScanMap(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
+	bool ScanModLua(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
+	bool ScanModTdf(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
 
 protected:
 	std::map&lt;std::string, ArchiveInfo&gt; archiveInfo;

Modified: trunk/rts/System/FileSystem/VFSHandler.cpp
===================================================================
--- trunk/rts/System/FileSystem/VFSHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/FileSystem/VFSHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -8,18 +8,22 @@
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;mmgr.h&quot;
 
-CVFSHandler* hpiHandler=0;
 
+CVFSHandler* hpiHandler = NULL;
+
+
 CVFSHandler::CVFSHandler()
 {
 }
 
+
 // Override determines whether if conflicts overwrites an existing entry in the virtual filesystem or not
-bool CVFSHandler::AddArchive(std::string arName, bool override)
+bool CVFSHandler::AddArchive(const std::string&amp; arName, bool override,
+                             const std::string&amp; type)
 {
 	CArchiveBase* ar = archives[arName];
 	if (!ar) {
-		ar = CArchiveFactory::OpenArchive(arName);
+		ar = CArchiveFactory::OpenArchive(arName, type);
 		if (!ar) {
 			return false;
 		}
@@ -45,6 +49,7 @@
 	return true;
 }
 
+
 CVFSHandler::~CVFSHandler(void)
 {
 	for (std::map&lt;std::string, CArchiveBase*&gt;::iterator i = archives.begin(); i != archives.end(); ++i) {
@@ -52,9 +57,10 @@
 	}
 }
 
-int CVFSHandler::LoadFile(std::string name, void* buffer)
+
+int CVFSHandler::LoadFile(const std::string&amp; rawName, void* buffer)
 {
-	StringToLowerInPlace(name);
+	std::string name = StringToLower(rawName);
 	filesystem.ForwardSlashes(name);
 
 	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
@@ -75,9 +81,10 @@
 	return fsize;
 }
 
-int CVFSHandler::GetFileSize(std::string name)
+
+int CVFSHandler::GetFileSize(const std::string&amp; rawName)
 {
-	StringToLowerInPlace(name);
+	std::string name = StringToLower(rawName);
 	filesystem.ForwardSlashes(name);
 
 	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
@@ -102,11 +109,12 @@
 	return -1;
 }
 
+
 // Returns all the files in the given (virtual) directory without the preceeding pathname
-std::vector&lt;std::string&gt; CVFSHandler::GetFilesInDir(std::string dir)
+std::vector&lt;std::string&gt; CVFSHandler::GetFilesInDir(const std::string&amp; rawDir)
 {
 	std::vector&lt;std::string&gt; ret;
-	StringToLowerInPlace(dir);
+	std::string dir = StringToLower(rawDir);
 	filesystem.ForwardSlashes(dir);
 
 	std::map&lt;std::string, FileData&gt;::const_iterator filesStart = files.begin();
@@ -149,10 +157,10 @@
 
 
 // Returns all the sub-directories in the given (virtual) directory without the preceeding pathname
-std::vector&lt;std::string&gt; CVFSHandler::GetDirsInDir(std::string dir)
+std::vector&lt;std::string&gt; CVFSHandler::GetDirsInDir(const std::string&amp; rawDir)
 {
 	std::vector&lt;std::string&gt; ret;
-	StringToLowerInPlace(dir);
+	std::string dir = StringToLower(rawDir);
 	filesystem.ForwardSlashes(dir);
 
 	std::map&lt;std::string, FileData&gt;::const_iterator filesStart = files.begin();

Modified: trunk/rts/System/FileSystem/VFSHandler.h
===================================================================
--- trunk/rts/System/FileSystem/VFSHandler.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/FileSystem/VFSHandler.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -10,7 +10,7 @@
 class CVFSHandler
 {
 protected:
-	struct FileData{
+	struct FileData {
 		CArchiveBase *ar;
 		int size;
 		bool dynamic;
@@ -21,13 +21,14 @@
 	CVFSHandler();
 	virtual ~CVFSHandler();
 
-	int LoadFile(std::string name, void* buffer);
-	int GetFileSize(std::string name);
+	int LoadFile(const std::string&amp; name, void* buffer);
+	int GetFileSize(const std::string&amp; name);
 
-	std::vector&lt;std::string&gt; GetFilesInDir(std::string dir);
-	std::vector&lt;std::string&gt; GetDirsInDir(std::string dir);
+	std::vector&lt;std::string&gt; GetFilesInDir(const std::string&amp; dir);
+	std::vector&lt;std::string&gt; GetDirsInDir(const std::string&amp; dir);
 
-	bool AddArchive(std::string arName, bool override);
+	bool AddArchive(const std::string&amp; arName, bool override,
+	                const std::string&amp; type = &quot;&quot;);
 };
 
 extern CVFSHandler* hpiHandler;

Modified: trunk/rts/System/GlobalStuff.cpp
===================================================================
--- trunk/rts/System/GlobalStuff.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/GlobalStuff.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -118,6 +118,7 @@
 	}
 	for(int a = 0; a &lt; MAX_PLAYERS; ++a) {
 		players[a] = SAFE_NEW CPlayer();
+		players[a]-&gt;playerNum = a;
 		players[a]-&gt;team = 0;
 	}
 

Modified: trunk/rts/System/MouseInput.cpp
===================================================================
--- trunk/rts/System/MouseInput.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/MouseInput.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -18,14 +18,18 @@
 #include &lt;SDL_events.h&gt;
 #include &lt;SDL_syswm.h&gt;
 
-IMouseInput *mouseInput = 0;
 
+IMouseInput* mouseInput = NULL;
+
+
 IMouseInput::IMouseInput()
 {}
 
+
 IMouseInput::~IMouseInput()
 {}
 
+
 //////////////////////////////////////////////////////////////////////
 
 #ifdef WIN32

Modified: trunk/rts/System/Platform/ConfigHandler.cpp
===================================================================
--- trunk/rts/System/Platform/ConfigHandler.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/Platform/ConfigHandler.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -29,6 +29,9 @@
 ConfigHandler* ConfigHandler::instance = NULL;
 
 
+std::string ConfigHandler::configSource;
+
+
 /**
  * Returns reference to the current platform's config class.
  * If none exists, create one.
@@ -36,18 +39,29 @@
 ConfigHandler&amp; ConfigHandler::GetInstance()
 {
 	if (!instance) {
+		if (configSource.empty()) {
 #ifdef _WIN32
-		instance = SAFE_NEW RegHandler(&quot;Software\\SJ\\spring&quot;);
+			configSource = &quot;Software\\SJ\\spring&quot;;
 #elif defined(__APPLE__)
+			configSource = &quot;this string is not currently used&quot;;
+#else
+			configSource = DotfileHandler::GetDefaultConfig();
+#endif
+		}
+
+#ifdef _WIN32
+		instance = SAFE_NEW RegHandler(configSource);
+#elif defined(__APPLE__)
 		PreInitMac();
 		instance = SAFE_NEW UserDefsHandler(); // Config path is based on bundle id
 #else
-		instance = SAFE_NEW DotfileHandler(DotfileHandler::GetDefaultConfig());
+		instance = SAFE_NEW DotfileHandler(configSource);
 #endif
 	}
 	return *instance;
 }
 
+
 /**
  * Destroys existing ConfigHandler instance.
  */
@@ -58,10 +72,12 @@
 	instance = 0;
 }
 
+
 ConfigHandler::~ConfigHandler()
 {
 }
 
+
 float ConfigHandler::GetFloat(const std::string&amp; name, const float def)
 {
 	std::ostringstream buf1;
@@ -73,6 +89,7 @@
 	return val;
 }
 
+
 void ConfigHandler::SetFloat(const std::string&amp; name, float value)
 {
 	std::ostringstream buffer;
@@ -80,3 +97,16 @@
 
 	SetString(name, buffer.str());
 }
+
+
+bool ConfigHandler::SetConfigSource(const std::string&amp; source)
+{
+	configSource = source;
+	return true;
+}
+
+
+const std::string&amp; ConfigHandler::GetConfigSource()
+{
+	return configSource;
+}

Modified: trunk/rts/System/Platform/ConfigHandler.h
===================================================================
--- trunk/rts/System/Platform/ConfigHandler.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/Platform/ConfigHandler.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -76,6 +76,9 @@
 	 */
 	static ConfigHandler&amp; GetInstance();
 
+	static bool SetConfigSource(const std::string&amp; name);
+	static const std::string&amp; GetConfigSource();
+
 	/**
 	 * @brief deallocate
 	 */
@@ -84,6 +87,8 @@
 	virtual ~ConfigHandler();
 
 protected:
+	static std::string configSource;
+
 	/**
 	 * @brief instance
 	 *

Modified: trunk/rts/System/SpringApp.cpp
===================================================================
--- trunk/rts/System/SpringApp.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/System/SpringApp.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -5,6 +5,9 @@
 #include &lt;SDL.h&gt;
 #include &lt;SDL_syswm.h&gt;
 
+#undef KeyPress
+#undef KeyRelease
+
 #include &quot;Game/GameVersion.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/GameController.h&quot;
@@ -138,12 +141,10 @@
  * @brief Initializes the SpringApp instance
  * @return whether initialization was successful
  */
-bool SpringApp::Initialize ()
+bool SpringApp::Initialize()
 {
-	logOutput.SetMirrorToStdout(!!configHandler.GetInt(&quot;StdoutDebug&quot;,0));
-
 	// Initialize class system
-	creg::System::InitializeClasses ();
+	creg::System::InitializeClasses();
 
 	// Initialize crash reporting
 #ifdef _WIN32
@@ -161,6 +162,9 @@
 #endif
 
 	ParseCmdLine();
+
+	logOutput.SetMirrorToStdout(!!configHandler.GetInt(&quot;StdoutDebug&quot;,0));
+
 	FileSystemHandler::Initialize(true);
 
 	if (!InitWindow((&quot;Spring &quot; + std::string(VERSION_STRING)).c_str())) {
@@ -172,9 +176,9 @@
 
 	// Global structures
 	ENTER_SYNCED;
-	gs=SAFE_NEW CGlobalSyncedStuff();
+	gs = SAFE_NEW CGlobalSyncedStuff();
 	ENTER_UNSYNCED;
-	gu=SAFE_NEW CGlobalUnsyncedStuff();
+	gu = SAFE_NEW CGlobalUnsyncedStuff();
 
 	if (cmdline-&gt;result(&quot;minimise&quot;)) {
 		gu-&gt;active = false;
@@ -568,8 +572,14 @@
 	cmdline-&gt;addoption('t', &quot;textureatlas&quot;,   OPTPARM_NONE,   &quot;&quot;,  &quot;Dump each finalized textureatlas in textureatlasN.tga&quot;);
 	cmdline-&gt;addoption('q', &quot;quit&quot;,           OPTPARM_INT,    &quot;T&quot;, &quot;Quit immediately on game over or after T seconds&quot;);
 	cmdline-&gt;addoption('n', &quot;name&quot;,           OPTPARM_STRING, &quot;&quot;,  &quot;Set your player name&quot;);
+	cmdline-&gt;addoption('C', &quot;config&quot;,         OPTPARM_STRING, &quot;&quot;,  &quot;Configuration file&quot;);
 	cmdline-&gt;parse();
 
+	string configSource;
+	if (cmdline-&gt;result(&quot;config&quot;, configSource)) {
+		ConfigHandler::SetConfigSource(configSource);
+	}
+
 #ifdef _DEBUG
 	fullscreen = false;
 #else

Modified: trunk/rts/lib/lua/README_SPRING
===================================================================
--- trunk/rts/lib/lua/README_SPRING	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/lib/lua/README_SPRING	2008-06-27 03:35:24 UTC (rev 6079)
@@ -36,5 +36,12 @@
   7. Changed the return type of lua_toboolean from int to bool to prevent
      compiler performance warnings on Visual Studio 2005.
 
-	8. Modified lbaselib.cpp:luaB_tostring() and lvm.cpp:luaV_tostring()
+  8. Modified lbaselib.cpp:luaB_tostring() and lvm.cpp:luaV_tostring()
      so that the tostring() lua function would be sync safe.
+
+  9. Undefined (in include/luaconf.h):
+       LUA_COMPAT_VARARG
+       LUA_COMPAT_MOD
+       LUA_COMPAT_LSTR
+       LUA_COMPAT_GFIND
+       LUA_COMPAT_OPENLIB

Modified: trunk/rts/lib/lua/include/luaconf.h
===================================================================
--- trunk/rts/lib/lua/include/luaconf.h	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/rts/lib/lua/include/luaconf.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -333,14 +333,16 @@
 ** CHANGE it to undefined as soon as your programs use only '...' to
 ** access vararg parameters (instead of the old 'arg' table).
 */
-#define LUA_COMPAT_VARARG
+//SPRING
+#undef LUA_COMPAT_VARARG
 
 /*
 @@ LUA_COMPAT_MOD controls compatibility with old math.mod function.
 ** CHANGE it to undefined as soon as your programs use 'math.fmod' or
 ** the new '%' operator instead of 'math.mod'.
 */
-#define LUA_COMPAT_MOD
+//SPRING
+#undef LUA_COMPAT_MOD
 
 /*
 @@ LUA_COMPAT_LSTR controls compatibility with old long string nesting
@@ -348,14 +350,17 @@
 ** CHANGE it to 2 if you want the old behaviour, or undefine it to turn
 ** off the advisory error when nesting [[...]].
 */
-#define LUA_COMPAT_LSTR		1
+//SPRING
+#undef LUA_COMPAT_LSTR
+//#undef LUA_COMPAT_LSTR		1
 
 /*
 @@ LUA_COMPAT_GFIND controls compatibility with old 'string.gfind' name.
 ** CHANGE it to undefined as soon as you rename 'string.gfind' to
 ** 'string.gmatch'.
 */
-#define LUA_COMPAT_GFIND
+//SPRING
+#undef LUA_COMPAT_GFIND
 
 /*
 @@ LUA_COMPAT_OPENLIB controls compatibility with old 'luaL_openlib'
@@ -363,7 +368,8 @@
 ** CHANGE it to undefined as soon as you replace to 'luaL_register'
 ** your uses of 'luaL_openlib'
 */
-#define LUA_COMPAT_OPENLIB
+//SPRING
+#undef LUA_COMPAT_OPENLIB
 
 
 

Added: trunk/tools/unitsync/LuaParserAPI.cpp
===================================================================
--- trunk/tools/unitsync/LuaParserAPI.cpp	                        (rev 0)
+++ trunk/tools/unitsync/LuaParserAPI.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,347 @@
+/******************************************************************************/
+/******************************************************************************/
+//
+// file:   LuaParserAPI.cpp
+// desc:   LuaParser C interface
+// author: Dave Rodgers (aka: trepan)
+// 
+// LuaParser C interface
+//
+// Copyright (C) 2008.
+// Licensed under the terms of the GNU GPL, v2 or later
+//
+/******************************************************************************/
+/******************************************************************************/
+
+#include &quot;StdAfx.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;System/FileSystem/ArchiveScanner.h&quot;
+#include &quot;System/FileSystem/VFSHandler.h&quot;
+#include &quot;unitsync.h&quot;
+#include &lt;string&gt;
+#include &lt;vector&gt;
+using std::string;
+using std::vector;
+
+
+/******************************************************************************/
+
+static LuaParser* luaParser = NULL;
+
+static LuaTable rootTable;
+static LuaTable currTable;
+static vector&lt;LuaTable&gt; luaTables;
+
+static vector&lt;int&gt; intKeys;
+static vector&lt;string&gt; stringKeys;
+
+
+/******************************************************************************/
+//
+//  Primary calls
+//
+
+DLL_EXPORT void __stdcall lpClose()
+{
+	rootTable = LuaTable();
+	currTable = LuaTable();
+
+	luaTables.clear();
+
+	intKeys.clear();
+	stringKeys.clear();
+
+	delete luaParser;
+	luaParser = NULL;
+
+	return;
+}
+
+
+DLL_EXPORT int __stdcall lpOpenFile(const char* filename,
+                                    const char* fileModes,
+                                    const char* accessModes)
+{
+	lpClose();
+	luaParser = new LuaParser(filename, fileModes, accessModes);
+	return 1;
+}
+
+
+DLL_EXPORT int __stdcall lpOpenSource(const char* source,
+                                      const char* accessModes)
+{
+	lpClose();
+	luaParser = new LuaParser(source, accessModes);
+	return 1;
+}
+
+
+DLL_EXPORT int __stdcall lpExecute()
+{
+	if (!luaParser) {
+		return 0;
+	}
+	const bool success = luaParser-&gt;Execute();
+	rootTable = luaParser-&gt;GetRoot();
+	currTable = rootTable;
+	return success ? 1 : 0;
+}
+
+
+DLL_EXPORT const char* __stdcall lpErrorLog()
+{
+	if (luaParser) {
+		return GetStr(luaParser-&gt;GetErrorLog());
+	}
+	return GetStr(&quot;no LuaParser is loaded&quot;);
+}
+
+
+/******************************************************************************/
+//
+//  Environment additions
+//
+
+DLL_EXPORT void __stdcall lpAddTableInt(int key, int override)
+{
+	if (luaParser) { luaParser-&gt;GetTable(key, override); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddTableStr(const char* key, int override)
+{
+	if (luaParser) { luaParser-&gt;GetTable(key, override); }
+}
+
+
+DLL_EXPORT void __stdcall lpEndTable()
+{
+	if (luaParser) { luaParser-&gt;EndTable(); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddIntKeyIntVal(int key, int val)
+{
+	if (luaParser) { luaParser-&gt;AddInt(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddStrKeyIntVal(const char* key, int val)
+{
+	if (luaParser) { luaParser-&gt;AddInt(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddIntKeyBoolVal(int key, int val)
+{
+	if (luaParser) { luaParser-&gt;AddBool(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddStrKeyBoolVal(const char* key, int val)
+{
+	if (luaParser) { luaParser-&gt;AddBool(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddIntKeyFloatVal(int key, float val)
+{
+	if (luaParser) { luaParser-&gt;AddFloat(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddStrKeyFloatVal(const char* key, float val)
+{
+	if (luaParser) { luaParser-&gt;AddFloat(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddIntKeyStrVal(int key, const char* val)
+{
+	if (luaParser) { luaParser-&gt;AddString(key, val); }
+}
+
+
+DLL_EXPORT void __stdcall lpAddStrKeyStrVal(const char* key, const char* val)
+{
+	if (luaParser) { luaParser-&gt;AddString(key, val); }
+}
+
+
+/******************************************************************************/
+//
+//  Table manipulation
+//
+
+DLL_EXPORT int __stdcall lpRootTable()
+{
+	currTable = rootTable;
+	luaTables.clear();
+	return currTable.IsValid() ? 1 : 0;
+}
+
+
+DLL_EXPORT int __stdcall lpRootTableExpr(const char* expr)
+{
+	currTable = rootTable.SubTableExpr(expr);
+	luaTables.clear();
+	return currTable.IsValid() ? 1 : 0;
+}
+
+
+DLL_EXPORT int __stdcall lpSubTableInt(int key)
+{
+	luaTables.push_back(currTable);
+	currTable = currTable.SubTable(key);
+	return currTable.IsValid() ? 1 : 0;
+}
+
+
+DLL_EXPORT int __stdcall lpSubTableStr(const char* key)
+{
+	luaTables.push_back(currTable);
+	currTable = currTable.SubTable(key);
+	return currTable.IsValid() ? 1 : 0;
+}
+
+
+DLL_EXPORT int __stdcall lpSubTableExpr(const char* expr)
+{
+	luaTables.push_back(currTable);
+	currTable = currTable.SubTableExpr(expr);
+	return currTable.IsValid() ? 1 : 0;
+}
+
+
+DLL_EXPORT void __stdcall lpPopTable()
+{
+	if (luaTables.empty()) {
+		currTable = rootTable;
+		return;
+	}
+	const unsigned popSize = luaTables.size() - 1;
+	currTable = luaTables[popSize];
+	luaTables.resize(popSize);
+}
+
+
+/******************************************************************************/
+//
+//  Key existance
+//
+
+DLL_EXPORT int __stdcall lpGetKeyExistsInt(int key)
+{
+	return currTable.KeyExists(key) ? 1 : 0;
+}
+
+
+DLL_EXPORT int __stdcall lpGetKeyExistsStr(const char* key)
+{
+	return currTable.KeyExists(key) ? 1 : 0;
+}
+
+
+/******************************************************************************/
+//
+// Key lists
+//
+
+DLL_EXPORT int __stdcall lpGetIntKeyListCount()
+{
+	if (!currTable.IsValid()) {
+		intKeys.clear();
+		return 0;
+	}
+	currTable.GetKeys(intKeys);
+	return (int)intKeys.size();
+}
+
+
+DLL_EXPORT int __stdcall lpGetIntKeyListEntry(int index)
+{
+	if ((index &lt; 0) || (index &gt;= intKeys.size())) {
+		return 0;
+	}
+	return intKeys[index];
+}
+
+
+DLL_EXPORT int __stdcall lpGetStrKeyListCount()
+{
+	if (!currTable.IsValid()) {
+		stringKeys.clear();
+		return 0;
+	}
+	currTable.GetKeys(stringKeys);
+	return (int)stringKeys.size();
+}
+
+
+DLL_EXPORT const char* __stdcall lpGetStrKeyListEntry(int index)
+{
+	if ((index &lt; 0) || (index &gt;= stringKeys.size())) {
+		return GetStr(&quot;&quot;);
+	}
+	return GetStr(stringKeys[index]);
+}
+
+
+/******************************************************************************/
+//
+//  Value queries
+//
+
+DLL_EXPORT int __stdcall lpGetIntKeyIntVal(int key, int defVal)
+{
+	return currTable.GetInt(key, defVal);
+}
+
+
+DLL_EXPORT int __stdcall lpGetStrKeyIntVal(const char* key, int defVal)
+{
+	return currTable.GetInt(key, defVal);
+}
+
+
+DLL_EXPORT int __stdcall lpGetIntKeyBoolVal(int key, int defVal)
+{
+	return currTable.GetBool(key, defVal) ? 1 : 0;
+}
+
+
+DLL_EXPORT int __stdcall lpGetStrKeyBoolVal(const char* key, int defVal)
+{
+	return currTable.GetBool(key, defVal) ? 1 : 0;
+}
+
+
+DLL_EXPORT float __stdcall lpGetIntKeyFloatVal(int key, float defVal)
+{
+	return currTable.GetFloat(key, defVal);
+}
+
+
+DLL_EXPORT float __stdcall lpGetStrKeyFloatVal(const char* key, float defVal)
+{
+	return currTable.GetFloat(key, defVal);
+}
+
+
+DLL_EXPORT const char* __stdcall lpGetIntKeyStrVal(int key,
+                                                   const char* defVal)
+{
+	return GetStr(currTable.GetString(key, defVal));
+}
+
+
+DLL_EXPORT const char* __stdcall lpGetStrKeyStrVal(const char* key,
+                                                   const char* defVal)
+{
+	return GetStr(currTable.GetString(key, defVal));
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/tools/unitsync/LuaParserAPI.h
===================================================================
--- trunk/tools/unitsync/LuaParserAPI.h	                        (rev 0)
+++ trunk/tools/unitsync/LuaParserAPI.h	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,8 @@
+#ifndef LUA_PARSER_API_H
+#define LUA_PARSER_API_H
+
+#include &quot;unitsync.h&quot;
+
+DLL_EXPORT void __stdcall lpClose();
+
+#endif /* LUA_PARSER_API_H */

Modified: trunk/tools/unitsync/test/test.cpp
===================================================================
--- trunk/tools/unitsync/test/test.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/tools/unitsync/test/test.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -47,8 +47,8 @@
 
 DLL_EXPORT void         __stdcall Message(const char* p_szMessage);
 
+DLL_EXPORT int          __stdcall Init(bool isServer, int id);
 DLL_EXPORT void         __stdcall UnInit();
-DLL_EXPORT int          __stdcall Init(bool isServer, int id);
 
 DLL_EXPORT int          __stdcall ProcessUnits(void);
 DLL_EXPORT int          __stdcall ProcessUnitsNoChecksum(void);
@@ -92,6 +92,7 @@
 
 DLL_EXPORT int          __stdcall GetSideCount();
 DLL_EXPORT const char*  __stdcall GetSideName(int side);
+DLL_EXPORT const char*  __stdcall GetSideStartUnit(int side);
 
 DLL_EXPORT int          __stdcall GetLuaAICount();
 DLL_EXPORT const char*  __stdcall GetLuaAIName(int aiIndex);
@@ -127,6 +128,7 @@
 DLL_EXPORT int          __stdcall FindFilesVFS(int handle, char* nameBuf, int size);
 
 DLL_EXPORT int          __stdcall OpenArchive(const char* name);
+DLL_EXPORT int          __stdcall OpenArchiveType(const char* name, const char* type);
 DLL_EXPORT void         __stdcall CloseArchive(int archive);
 DLL_EXPORT int          __stdcall FindFilesArchive(int archive, int cur, char* nameBuf, int* size);
 DLL_EXPORT int          __stdcall OpenArchiveFile(int archive, const char* name);
@@ -134,11 +136,59 @@
 DLL_EXPORT void         __stdcall CloseArchiveFile(int archive, int handle);
 DLL_EXPORT int          __stdcall SizeArchiveFile(int archive, int handle);
 
+DLL_EXPORT void        __stdcall lpClose();
+DLL_EXPORT int         __stdcall lpOpenFile(const char* filename,
+                                            const char* fileModes,
+                                            const char* accessModes);
+DLL_EXPORT int         __stdcall lpOpenSource(const char* source,
+                                              const char* accessModes);
+DLL_EXPORT int         __stdcall lpExecute();
+DLL_EXPORT const char* __stdcall lpErrorLog();
 
+DLL_EXPORT void        __stdcall lpAddTableInt(int key, int override);
+DLL_EXPORT void        __stdcall lpAddTableStr(const char* key, int override);
+DLL_EXPORT void        __stdcall lpEndTable();
+DLL_EXPORT void        __stdcall lpAddIntKeyIntVal(int key, int val);
+DLL_EXPORT void        __stdcall lpAddStrKeyIntVal(const char* key, int val);
+DLL_EXPORT void        __stdcall lpAddIntKeyBoolVal(int key, int val);
+DLL_EXPORT void        __stdcall lpAddStrKeyBoolVal(const char* key, int val);
+DLL_EXPORT void        __stdcall lpAddIntKeyFloatVal(int key, float val);
+DLL_EXPORT void        __stdcall lpAddStrKeyFloatVal(const char* key, float val);
+DLL_EXPORT void        __stdcall lpAddIntKeyStrVal(int key, const char* val);
+DLL_EXPORT void        __stdcall lpAddStrKeyStrVal(const char* key, const char* val);
+
+DLL_EXPORT int         __stdcall lpRootTable();
+DLL_EXPORT int         __stdcall lpRootTableExpr(const char* expr);
+DLL_EXPORT int         __stdcall lpSubTableInt(int key);
+DLL_EXPORT int         __stdcall lpSubTableStr(const char* key);
+DLL_EXPORT int         __stdcall lpSubTableExpr(const char* expr);
+DLL_EXPORT void        __stdcall lpPopTable();
+
+DLL_EXPORT int         __stdcall lpGetKeyExistsInt(int key);
+DLL_EXPORT int         __stdcall lpGetKeyExistsStr(const char* key);
+
+DLL_EXPORT int         __stdcall lpGetIntKeyListCount();
+DLL_EXPORT int         __stdcall lpGetIntKeyListEntry(int index);
+DLL_EXPORT int         __stdcall lpGetStrKeyListCount();
+DLL_EXPORT const char* __stdcall lpGetStrKeyListEntry(int index);
+
+DLL_EXPORT int         __stdcall lpGetIntKeyIntVal(int key, int defVal);
+DLL_EXPORT int         __stdcall lpGetStrKeyIntVal(const char* key, int defVal);
+DLL_EXPORT int         __stdcall lpGetIntKeyBoolVal(int key, int defVal);
+DLL_EXPORT int         __stdcall lpGetStrKeyBoolVal(const char* key, int defVal);
+DLL_EXPORT float       __stdcall lpGetIntKeyFloatVal(int key, float defVal);
+DLL_EXPORT float       __stdcall lpGetStrKeyFloatVal(const char* key, float defVal);
+DLL_EXPORT const char* __stdcall lpGetIntKeyStrVal(int key, const char* defVal);
+DLL_EXPORT const char* __stdcall lpGetStrKeyStrVal(const char* key, const char* defVal);
+
+
+
+
 /******************************************************************************/
 /******************************************************************************/
 
 static void DisplayOptions(int optionCount);
+static bool TestLuaParser();
 
 
 /******************************************************************************/
@@ -189,10 +239,12 @@
   printf(&quot;MOD = %s\n&quot;, mod.c_str());
 
   Init(false, 0);
-  InitArchiveScanner();
 
   printf(&quot;GetSpringVersion() = %s\n&quot;, GetSpringVersion());
 
+  // test the lua parser interface
+  TestLuaParser();
+
   // map names
   printf(&quot;  MAPS\n&quot;);
   vector&lt;string&gt; mapNames;
@@ -213,7 +265,7 @@
   // map info
   PrintMapInfo(map);
 
-  if (true) { // FIXME -- debugging
+  if (true &amp;&amp; false) { // FIXME -- debugging
     for (int i = 0; i &lt; mapNames.size(); i++) {
       PrintMapInfo(mapNames[i]);
     }
@@ -256,8 +308,10 @@
   printf(&quot;  SIDES\n&quot;);
   const int sideCount = GetSideCount();
   for (int i = 0; i &lt; sideCount; i++) {
-    const string sideName= GetSideName(i);
-    printf(&quot;    side %i = '%s'\n&quot;, i, sideName.c_str());
+    const string sideName  = GetSideName(i);
+    const string startUnit = GetSideStartUnit(i);
+    printf(&quot;    side %i = '%s' &lt;%s&gt;\n&quot;,
+           i, sideName.c_str(), startUnit.c_str());
   }
 
   // LuaAI options
@@ -347,3 +401,100 @@
 
 /******************************************************************************/
 /******************************************************************************/
+
+static bool TestLuaParser()
+{
+  const string source =
+    &quot;for k, v in pairs(Test) do\n&quot;
+    &quot;  print('LUA Test Table:  '..tostring(k)..' = '..tostring(v))\n&quot;
+    &quot;end\n&quot;
+    &quot;return {\n&quot;
+    &quot;  [0] = 'ZERO',\n&quot;
+    &quot;  [1] = 'ONE',\n&quot;
+    &quot;  [2] = 'TWO',\n&quot;
+    &quot;  [3] = 'THREE',\n&quot;
+    &quot;  [4] = 4.4,\n&quot;
+    &quot;  [5] = 5.5,\n&quot;
+    &quot;  [6] = 6.6,\n&quot;
+    &quot;  [11] = { 'one', 'two', 'three' },\n&quot;
+    &quot;  [12] = { 'one', 'success1', three = { 'success2', 'crap' }, four = { 'success3' }},\n&quot;
+    &quot;  string = 'string',\n&quot;
+    &quot;  number = 12345678,\n&quot;
+    &quot;}\n&quot;;
+
+  if (!lpOpenSource(source.c_str(), &quot;r&quot;)) {
+    printf(&quot;LuaParser API test failed  --  should not happen here\n&quot;);
+    return false;
+  }
+
+  lpAddTableStr(&quot;Test&quot;, 1);
+    lpAddIntKeyFloatVal(1, 111.1f);
+    lpAddIntKeyFloatVal(2, 222.2f);
+    lpAddIntKeyFloatVal(3, 333.3f);
+    lpAddTableStr(&quot;Sub&quot;, 1);
+      lpAddStrKeyStrVal(&quot;test&quot;, &quot;value1&quot;);
+    lpEndTable();
+    lpAddTableInt(4, 1);
+      lpAddStrKeyStrVal(&quot;test&quot;, &quot;value2&quot;);
+    lpEndTable();
+    lpAddTableInt(5, 1);
+      lpAddStrKeyStrVal(&quot;test&quot;, &quot;value3&quot;);
+    lpEndTable();
+    lpAddIntKeyStrVal(6, &quot;hello&quot;);
+    lpAddIntKeyStrVal(7, &quot;world&quot;);
+  lpEndTable();  
+
+  if (!lpExecute()) {
+    printf(&quot;LuaParser API test failed: %s\n&quot;, lpErrorLog());
+    return false;
+  }
+
+  const int intCount = lpGetIntKeyListCount();
+  for (int i = 0; i &lt; intCount; i++) {
+    const char* str = lpGetIntKeyStrVal(i, &quot;&quot;);
+    const float num = lpGetIntKeyFloatVal(i, 666.666f);
+    printf(&quot;  int-key = %i, val = '%s'  (%f)\n&quot;, i, str, num);
+  }
+
+  const int strCount = lpGetStrKeyListCount();
+  for (int i = 0; i &lt; strCount; i++) {
+    const string key = lpGetStrKeyListEntry(i);
+    const char* str  = lpGetStrKeyStrVal(key.c_str(), &quot;&quot;);
+    const float num  = lpGetStrKeyFloatVal(key.c_str(), 666.666f);
+    printf(&quot;  str-key = '%s', val = '%s'  (%f)\n&quot;, key.c_str(), str, num);
+  }
+
+  lpRootTable();
+    lpSubTableInt(12);
+      const char* result;
+      printf(&quot;SubTable test1: '%s'\n&quot;, lpGetIntKeyStrVal(2, &quot;FAILURE&quot;));
+      lpSubTableStr(&quot;three&quot;);
+        printf(&quot;SubTable test2: '%s'\n&quot;, lpGetIntKeyStrVal(1, &quot;FAILURE&quot;));
+      lpPopTable();
+      lpSubTableStr(&quot;four&quot;);
+        printf(&quot;SubTable test3: '%s'\n&quot;, lpGetIntKeyStrVal(1, &quot;FAILURE&quot;));
+      lpPopTable();
+    lpPopTable();
+    lpPopTable();
+    lpPopTable();
+    lpPopTable();
+    lpPopTable();
+    lpPopTable();
+    lpSubTableInt(12);
+      printf(&quot;SubTable test1: '%s'\n&quot;, lpGetIntKeyStrVal(2, &quot;FAILURE&quot;));
+    lpPopTable();
+  lpRootTable();
+  lpSubTableExpr(&quot;[12].four&quot;);
+      printf(&quot;SubTable sub-expr: '%s'\n&quot;, lpGetIntKeyStrVal(1, &quot;FAILURE&quot;));
+  lpRootTableExpr(&quot;[12].four&quot;);
+      printf(&quot;SubTable root-expr: '%s'\n&quot;, lpGetIntKeyStrVal(1, &quot;FAILURE&quot;));
+  lpRootTableExpr(&quot;[12].four&quot;);
+      printf(&quot;SubTable root-expr: '%s'\n&quot;, lpGetIntKeyStrVal(1, &quot;FAILURE&quot;));
+  
+  return true;  
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+

Copied: trunk/tools/unitsync/test/test.cxx (from rev 6015, trunk/tools/unitsync/test/test.cpp)
===================================================================
--- trunk/tools/unitsync/test/test.cxx	                        (rev 0)
+++ trunk/tools/unitsync/test/test.cxx	2008-06-27 03:35:24 UTC (rev 6079)
@@ -0,0 +1,350 @@
+#/*START
+#//##########################################################################//#
+
+file=test.cpp
+
+start=`grep -n '^#END' $file | grep -o '^[^:]*'`
+start=`expr $start + 1`
+tail -n +$start $file &gt; test.tmp.cxx
+echo Clipped $start lines
+
+g++ -I../../../rts/System test.tmp.cxx ../../../game/unitsync.so
+
+echo ./a.out Castles.smf ba621.sd7
+./a.out Castles.smf ba621.sd7
+
+exit
+
+#//##########################################################################//#
+#END*/
+
+
+/******************************************************************************/
+/******************************************************************************/
+//  Simple file to help test unitsync, compile with:
+//
+//    g++ -I../../../rts/System test.cxx ../../../game/unitsync.so
+//
+
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string&gt;
+#include &lt;vector&gt;
+using namespace std;
+
+#include &quot;../unitsync.h&quot;
+
+
+/******************************************************************************/
+/******************************************************************************/
+//
+//  Generated using:  'grep DLL_EXPORT unitsync.cpp'
+//
+
+DLL_EXPORT const char*  __stdcall GetSpringVersion();
+
+DLL_EXPORT void         __stdcall Message(const char* p_szMessage);
+
+DLL_EXPORT void         __stdcall UnInit();
+DLL_EXPORT int          __stdcall Init(bool isServer, int id);
+DLL_EXPORT int          __stdcall InitArchiveScanner(void);
+
+DLL_EXPORT int          __stdcall ProcessUnits(void);
+DLL_EXPORT int          __stdcall ProcessUnitsNoChecksum(void);
+DLL_EXPORT const char*  __stdcall GetCurrentList();
+
+DLL_EXPORT void         __stdcall AddClient(int id, const char *unitList);
+DLL_EXPORT void         __stdcall RemoveClient(int id);
+
+DLL_EXPORT const char*  __stdcall GetClientDiff(int id);
+DLL_EXPORT void         __stdcall InstallClientDiff(const char *diff);
+
+DLL_EXPORT int          __stdcall GetUnitCount();
+DLL_EXPORT const char*  __stdcall GetUnitName(int unit);
+DLL_EXPORT const char*  __stdcall GetFullUnitName(int unit);
+DLL_EXPORT int          __stdcall IsUnitDisabled(int unit);
+DLL_EXPORT int          __stdcall IsUnitDisabledByClient(int unit, int clientId);
+
+DLL_EXPORT void         __stdcall AddArchive(const char* name);
+DLL_EXPORT void         __stdcall AddAllArchives(const char* root);
+DLL_EXPORT unsigned int __stdcall GetArchiveChecksum(const char* arname);
+
+DLL_EXPORT int          __stdcall GetMapCount();
+DLL_EXPORT const char*  __stdcall GetMapName(int index);
+DLL_EXPORT int          __stdcall GetMapInfoEx(const char* name, MapInfo* outInfo, int version);
+DLL_EXPORT int          __stdcall GetMapInfo(const char* name, MapInfo* outInfo);
+DLL_EXPORT int          __stdcall GetMapArchiveCount(const char* mapName);
+DLL_EXPORT const char*  __stdcall GetMapArchiveName(int index);
+DLL_EXPORT unsigned int __stdcall GetMapChecksum(int index);
+DLL_EXPORT void*        __stdcall GetMinimap(const char* filename, int miplevel);
+
+DLL_EXPORT int          __stdcall GetPrimaryModCount();
+DLL_EXPORT const char*  __stdcall GetPrimaryModName(int index);
+DLL_EXPORT const char*  __stdcall GetPrimaryModShortName(int index);
+DLL_EXPORT const char*  __stdcall GetPrimaryModVersion(int index);
+DLL_EXPORT const char*  __stdcall GetPrimaryModMutator(int index);
+DLL_EXPORT const char*  __stdcall GetPrimaryModArchive(int index);
+DLL_EXPORT int          __stdcall GetPrimaryModArchiveCount(int index);
+DLL_EXPORT const char*  __stdcall GetPrimaryModArchiveList(int arnr);
+DLL_EXPORT int          __stdcall GetPrimaryModIndex(const char* name);
+DLL_EXPORT unsigned int __stdcall GetPrimaryModChecksum(int index);
+
+DLL_EXPORT int          __stdcall GetSideCount();
+DLL_EXPORT const char*  __stdcall GetSideName(int side);
+
+DLL_EXPORT int          __stdcall GetLuaAICount();
+DLL_EXPORT const char*  __stdcall GetLuaAIName(int aiIndex);
+DLL_EXPORT const char*  __stdcall GetLuaAIDesc(int aiIndex);
+
+DLL_EXPORT int          __stdcall GetMapOptionCount(const char* name);
+DLL_EXPORT int          __stdcall GetModOptionCount();
+DLL_EXPORT const char*  __stdcall GetOptionKey(int optIndex);
+DLL_EXPORT const char*  __stdcall GetOptionName(int optIndex);
+DLL_EXPORT const char*  __stdcall GetOptionDesc(int optIndex);
+DLL_EXPORT int          __stdcall GetOptionType(int optIndex);
+DLL_EXPORT int          __stdcall GetOptionBoolDef(int optIndex);
+DLL_EXPORT float        __stdcall GetOptionNumberDef(int optIndex);
+DLL_EXPORT float        __stdcall GetOptionNumberMin(int optIndex);
+DLL_EXPORT float        __stdcall GetOptionNumberMax(int optIndex);
+DLL_EXPORT float        __stdcall GetOptionNumberStep(int optIndex);
+DLL_EXPORT const char*  __stdcall GetOptionStringDef(int optIndex);
+DLL_EXPORT int          __stdcall GetOptionStringMaxLen(int optIndex);
+DLL_EXPORT int          __stdcall GetOptionListCount(int optIndex);
+DLL_EXPORT const char*  __stdcall GetOptionListDef(int optIndex);
+DLL_EXPORT const char*  __stdcall GetOptionListItemKey(int optIndex, int itemIndex);
+DLL_EXPORT const char*  __stdcall GetOptionListItemName(int optIndex, int itemIndex);
+DLL_EXPORT const char*  __stdcall GetOptionListItemDesc(int optIndex, int itemIndex);
+
+DLL_EXPORT int          __stdcall GetModValidMapCount();
+DLL_EXPORT const char*  __stdcall GetModValidMap(int index);
+
+DLL_EXPORT int          __stdcall OpenFileVFS(const char* name);
+DLL_EXPORT void         __stdcall CloseFileVFS(int handle);
+DLL_EXPORT void         __stdcall ReadFileVFS(int handle, void* buf, int length);
+DLL_EXPORT int          __stdcall FileSizeVFS(int handle);
+DLL_EXPORT int          __stdcall InitFindVFS(const char* pattern);
+DLL_EXPORT int          __stdcall FindFilesVFS(int handle, char* nameBuf, int size);
+
+DLL_EXPORT int          __stdcall OpenArchive(const char* name);
+DLL_EXPORT void         __stdcall CloseArchive(int archive);
+DLL_EXPORT int          __stdcall FindFilesArchive(int archive, int cur, char* nameBuf, int* size);
+DLL_EXPORT int          __stdcall OpenArchiveFile(int archive, const char* name);
+DLL_EXPORT int          __stdcall ReadArchiveFile(int archive, int handle, void* buffer, int numBytes);
+DLL_EXPORT void         __stdcall CloseArchiveFile(int archive, int handle);
+DLL_EXPORT int          __stdcall SizeArchiveFile(int archive, int handle);
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+static void DisplayOptions(int optionCount);
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+static bool PrintMapInfo(const string&amp; mapName)
+{
+  printf(&quot;  MAP INFO  (for %s)\n&quot;, mapName.c_str());
+  MapInfo mi;
+  char auth[256];
+  char desc[256];
+  mi.author = auth;
+  mi.author[0] = 0;
+  mi.description = desc;
+  mi.description[0] = 0;
+  if (!GetMapInfoEx(mapName.c_str(), &amp;mi, 1)) {
+    printf(&quot;ERROR getting info for map %s  (%s)\n&quot;,
+    mapName.c_str(), mi.description);
+  }
+  else {
+    printf(&quot;    author:    '%s'\n&quot;, mi.author);
+    printf(&quot;    desc:      '%s'\n&quot;, mi.description);
+    printf(&quot;    gravity:   %i\n&quot;,   mi.gravity);
+    printf(&quot;    tidal:     %i\n&quot;,   mi.tidalStrength);
+    printf(&quot;    maxMetal:  %f\n&quot;,   mi.maxMetal);
+    printf(&quot;    mexRad:    %i\n&quot;,   mi.extractorRadius);
+    printf(&quot;    minWind:   %i\n&quot;,   mi.minWind);
+    printf(&quot;    maxWind:   %i\n&quot;,   mi.maxWind);
+    printf(&quot;    width:     %i\n&quot;,   mi.width);
+    printf(&quot;    height:    %i\n&quot;,   mi.height);
+    for (int p = 0; p &lt; mi.posCount; p++) {
+      const StartPos&amp; sp = mi.positions[p];
+      printf(&quot;    pos %i:     &lt;%5i, %5i&gt;\n&quot;, p, sp.x, sp.z);
+    }
+  }
+}
+
+
+int main(int argc, char** argv)
+{
+  if (argc &lt; 3) {
+    printf(&quot;usage:  %s &lt;map&gt; &lt;mod&gt;\n&quot;, argv[0]);
+    exit(1);
+  }
+  const string map = argv[1];
+  const string mod = argv[2];
+  printf(&quot;MAP = %s\n&quot;, map.c_str());
+  printf(&quot;MOD = %s\n&quot;, mod.c_str());
+
+  Init(false, 0);
+  InitArchiveScanner();
+
+  printf(&quot;GetSpringVersion() = %s\n&quot;, GetSpringVersion());
+
+  // map names
+  printf(&quot;  MAPS\n&quot;);
+  vector&lt;string&gt; mapNames;
+  const int mapCount = GetMapCount();
+  for (int i = 0; i &lt; mapCount; i++) {
+    const string mapName = GetMapName(i);
+    mapNames.push_back(mapName);
+    printf(&quot;    [map %3i]   %s\n&quot;, i, mapName.c_str());
+  }
+
+  // map archives
+  printf(&quot;  MAP ARCHIVES  (for %s)\n&quot;, map.c_str());
+  const int mapArcCount = GetMapArchiveCount(map.c_str());
+  for (int a = 0; a &lt; mapArcCount; a++) {
+    printf(&quot;      arc %i: %s\n&quot;, a, GetMapArchiveName(a));
+  }
+  
+  // map info
+  PrintMapInfo(map);
+
+  if (true) { // FIXME -- debugging
+    for (int i = 0; i &lt; mapNames.size(); i++) {
+      PrintMapInfo(mapNames[i]);
+    }
+  }
+    
+  // mod names
+  printf(&quot;  MODS\n&quot;);
+  const int modCount = GetPrimaryModCount();
+  for (int i = 0; i &lt; modCount; i++) {
+    const string modName      = GetPrimaryModName(i);
+    const string modShortName = GetPrimaryModShortName(i);
+    const string modVersion   = GetPrimaryModVersion(i);
+    const string modMutator   = GetPrimaryModMutator(i);
+    const string modArchive = GetPrimaryModArchive(i);
+    printf(&quot;    [mod %3i]   %-32s  &lt;%s&gt; %s %s %s\n&quot;, i,
+           modName.c_str(), modArchive.c_str(),
+           modShortName.c_str(), modVersion.c_str(), modMutator.c_str());
+  }
+
+  // load the mod archives
+  AddAllArchives(mod.c_str());
+
+  // unit names
+  while (true) {
+  //const int left = ProcessUnits();
+    const int left = ProcessUnitsNoChecksum();
+  //printf(&quot;unitsLeft = %i\n&quot;, left);
+    if (left &lt;= 0) {
+      break;
+    }
+  }
+  printf(&quot;  UNITS\n&quot;);
+  const int unitCount = GetUnitCount();
+  for (int i = 0; i &lt; unitCount; i++) {
+    const string unitName     = GetUnitName(i);
+    const string unitFullName = GetFullUnitName(i);
+    printf(&quot;    [unit %3i]   %-16s  &lt;%s&gt;\n&quot;, i,
+           unitName.c_str(), unitFullName.c_str());
+  }
+  printf(&quot;  SIDES\n&quot;);
+  const int sideCount = GetSideCount();
+  for (int i = 0; i &lt; sideCount; i++) {
+    const string sideName= GetSideName(i);
+    printf(&quot;    side %i = '%s'\n&quot;, i, sideName.c_str());
+  }
+
+  // LuaAI options
+  printf(&quot;  LuaAI\n&quot;);
+  const int luaAICount = GetLuaAICount();
+  for (int i = 0; i &lt; luaAICount; i++) {
+    printf(&quot;    %i: name = %s\n&quot;, i, GetLuaAIName(i));
+    printf(&quot;       desc = %s\n&quot;,     GetLuaAIDesc(i));
+  }
+
+  // MapOptions
+  printf(&quot;  MapOptions\n&quot;);
+  const int mapOptCount = GetMapOptionCount(map.c_str());
+  DisplayOptions(mapOptCount);
+
+  // ModOptions
+  printf(&quot;  ModOptions\n&quot;);
+  const int modOptCount = GetModOptionCount();
+  DisplayOptions(modOptCount);
+
+  // ModValidMaps
+  printf(&quot;  ModValidMaps\n&quot;);
+  const int modValidMapCount = GetModValidMapCount();
+  if (modValidMapCount == 0) {
+    printf(&quot;    * ALL MAPS *\n&quot;);
+  }
+  else {
+    for (int i = 0; i &lt; modValidMapCount; i++) {
+      printf(&quot;    %i: %s\n&quot;, i, GetModValidMap(i));
+    }
+  }
+
+  UnInit();
+
+  return 0;
+}
+
+
+/******************************************************************************/
+/******************************************************************************/
+
+static void DisplayOptions(int optionCount)
+{
+  for (int i = 0; i &lt; optionCount; i++) {
+    printf(&quot;    Option #%i\n&quot;, i);
+    printf(&quot;      key  = '%s'\n&quot;, GetOptionKey(i));
+    printf(&quot;      name = '%s'\n&quot;, GetOptionName(i));
+    printf(&quot;      desc = '%s'\n&quot;, GetOptionDesc(i));
+    printf(&quot;      type = %i\n&quot;, GetOptionType(i));
+
+    const int type = GetOptionType(i);
+
+    if (type == opt_error) {
+      printf(&quot;      BAD OPTION\n&quot;);
+    }
+    else if (type == opt_bool) {
+      printf(&quot;      BOOL: def = %s\n&quot;,
+             GetOptionBoolDef(i) ? &quot;true&quot; : &quot;false&quot;);
+    }
+    else if (type == opt_string) {
+      printf(&quot;      STRING: def = '%s', maxlen = %i\n&quot;,
+             GetOptionStringDef(i),
+             GetOptionStringMaxLen(i));
+    }
+    else if (type == opt_number) {
+      printf(&quot;      NUMBER: def = %f, min = %f, max = %f, step = %f\n&quot;,
+             GetOptionNumberDef(i),
+             GetOptionNumberMin(i),
+             GetOptionNumberMax(i),
+             GetOptionNumberStep(i));
+    }
+    else if (type == opt_list) {
+      printf(&quot;      LIST: def = '%s'\n&quot;,
+             GetOptionListDef(i));
+
+      const int listCount = GetOptionListCount(i);
+      for (int li = 0; li &lt; listCount; li++) {
+        printf(&quot;      %3i: key  = '%s'\n&quot;, li,
+                                         GetOptionListItemKey(i, li));
+        printf(&quot;           name = '%s'\n&quot;, GetOptionListItemName(i, li));
+        printf(&quot;           desc = '%s'\n&quot;, GetOptionListItemDesc(i, li));
+      }
+    }
+  }
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Modified: trunk/tools/unitsync/unitsync.cpp
===================================================================
--- trunk/tools/unitsync/unitsync.cpp	2008-06-26 21:26:02 UTC (rev 6078)
+++ trunk/tools/unitsync/unitsync.cpp	2008-06-27 03:35:24 UTC (rev 6079)
@@ -13,7 +13,9 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
+#include &quot;Sim/SideParser.h&quot;
 
+#include &quot;LuaParserAPI.h&quot;
 #include &quot;Syncer.h&quot;
 #include &quot;SyncServer.h&quot;
 #include &quot;unitsyncLogOutput.h&quot;
@@ -150,6 +152,8 @@
 
 DLL_EXPORT void __stdcall UnInit()
 {
+	lpClose();
+
 	FileSystemHandler::Cleanup();
 
 	if ( syncer )
@@ -941,48 +945,30 @@
 //////////////////////////
 //////////////////////////
 
-struct SideData {
-	string name;
-};
-
-vector&lt;SideData&gt; sideData;
-
 DLL_EXPORT int __stdcall GetSideCount()
 {
-	sideData.clear();
-
-	logOutput.Print(&quot;get side count: &quot;);
-
-	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-	                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-	if (!luaParser.Execute()) {
-		logOutput.Print(&quot;failed: %s\n&quot;, luaParser.GetErrorLog().c_str());
+	if (!sideParser.Load()) {
+		logOutput.Print(&quot;failed: %s\n&quot;, sideParser.GetErrorLog().c_str());
 		return 0;
 	}
+	return sideParser.GetCount();
+}
 
-	const LuaTable sideDataTbl = luaParser.GetRoot();
-	if (!sideDataTbl.IsValid()) {
-		logOutput.Print(&quot;failed: missing 'sideData' table\n&quot;);
-		return 0;
-	}
 
-	for (int i = 1; true; i++) {
-		const LuaTable sideTbl = sideDataTbl.SubTable(i);
-		if (!sideTbl.IsValid()) {
-			break;
-		}
-		SideData sd;
-		sd.name = sideTbl.GetString(&quot;name&quot;, &quot;unknown&quot;);
-		sideData.push_back(sd);
-	}
-
-	return sideData.size();
+DLL_EXPORT const char* __stdcall GetSideName(int side)
+{
+	ASSERT((unsigned int)side &lt; sideParser.GetCount(),
+	       &quot;Array index out of bounds. Call GetSideCount before GetSideName.&quot;);
+	// the full case name  (not the lowered version)
+	return GetStr(sideParser.GetCaseName(side));
 }
 
-DLL_EXPORT const char* __stdcall GetSideName(int side)
+
+DLL_EXPORT const char* __stdcall GetSideStartUnit(int side)
 {
-	ASSERT((unsigned)side &lt; sideData.size(), &quot;Array index out of bounds. Call GetSideCount before GetSideName.&quot;);
-	return GetStr(sideData[side].name);
+	ASSERT((unsigned int)side &lt; sideParser.GetCount(),
+	       &quot;Array index out of bounds. Call GetSideCount before GetSideStartUnit.&quot;);
+	return GetStr(sideParser.GetStartUnit(side));
 }
 
 
@@ -1679,6 +1665,22 @@
 	}
 }
 
+// returns 0 on error, a handle otherwise
+DLL_EXPORT int __stdcall OpenArchiveType(const char* name, const char* type)
+{
+	ASSERT(name &amp;&amp; *name &amp;&amp; type &amp;&amp; *type,
+	       &quot;Don't pass a NULL pointer or an empty string to OpenArchiveType.&quot;);
+	CArchiveBase* a = CArchiveFactory::OpenArchive(name, type);
+	if (a) {
+		nextArchive++;
+		openArchives[nextArchive] = a;
+		return nextArchive;
+	}
+	else {
+		return 0;
+	}
+}
+
 DLL_EXPORT void __stdcall CloseArchive(int archive)
 {
 	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to CloseArchive.&quot;);
@@ -1801,7 +1803,7 @@
  * @param name name of key to set
  * @param value string value to set
  */
-DLL_EXPORT void __stdcall SetSpringConfigString( const char* name, const char* value )
+DLL_EXPORT void __stdcall SetSpringConfigString(const char* name, const char* value)
 {
 	configHandler.SetString( name, value );
 }
@@ -1811,7 +1813,7 @@
  * @param name name of key to set
  * @param value integer value to set
  */
-DLL_EXPORT void __stdcall SetSpringConfigInt( const char* name, const int value )
+DLL_EXPORT void __stdcall SetSpringConfigInt(const char* name, const int value)
 {
 	configHandler.SetInt( name, value );
 }
@@ -1821,7 +1823,8 @@
  * @param name name of key to set
  * @param value float value to set
  */
-DLL_EXPORT void __stdcall SetSpringConfigFloat( const char* name, const float value )
+DLL_EXPORT void __stdcall SetSpringConfigFloat(const char* name, const float value)
 {
 	configHandler.SetFloat( name, value );
 }
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000858.html">[Taspring-linux-commit] r6078 - trunk/Lobby/TASClient
</A></li>
	<LI>Next message: <A HREF="000860.html">[Taspring-linux-commit] r6080 - trunk/tools/unitsync/test
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#859">[ date ]</a>
              <a href="thread.html#859">[ thread ]</a>
              <a href="subject.html#859">[ subject ]</a>
              <a href="author.html#859">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
