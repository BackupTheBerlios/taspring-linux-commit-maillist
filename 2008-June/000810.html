<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6030 - in branches/gml/rts: . ExternalAI	Game Game/StartScripts Game/UI Lua Map Map/SM3 Map/SMF	Rendering Rendering/Env Rendering/GL Rendering/Textures	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/Unsynced Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Weapons System System/FileSystem	System/Net System/Platform/Linux System/Platform/Win	System/Script build/cmake build/vstudio8 lib lib/gml	lib/luabind/luabind/detail lib/streflop
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-June/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6030%20-%20in%20branches/gml/rts%3A%20.%20ExternalAI%0A%09Game%20Game/StartScripts%20Game/UI%20Lua%20Map%20Map/SM3%20Map/SMF%0A%09Rendering%20Rendering/Env%20Rendering/GL%20Rendering/Textures%0A%09Sim/Features%20Sim/Misc%20Sim/MoveTypes%20Sim/Projectiles%0A%09Sim/Projectiles/Unsynced%20Sim/Units%20Sim/Units/COB%0A%09Sim/Units/CommandAI%20Sim/Weapons%20System%20System/FileSystem%0A%09System/Net%20System/Platform/Linux%20System/Platform/Win%0A%09System/Script%20build/cmake%20build/vstudio8%20lib%20lib/gml%0A%09lib/luabind/luabind/detail%20lib/streflop&In-Reply-To=%3C20080614220641.6E1DF449E%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000809.html">
   <LINK REL="Next"  HREF="000811.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6030 - in branches/gml/rts: . ExternalAI	Game Game/StartScripts Game/UI Lua Map Map/SM3 Map/SMF	Rendering Rendering/Env Rendering/GL Rendering/Textures	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/Unsynced Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Weapons System System/FileSystem	System/Net System/Platform/Linux System/Platform/Win	System/Script build/cmake build/vstudio8 lib lib/gml	lib/luabind/luabind/detail lib/streflop</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6030%20-%20in%20branches/gml/rts%3A%20.%20ExternalAI%0A%09Game%20Game/StartScripts%20Game/UI%20Lua%20Map%20Map/SM3%20Map/SMF%0A%09Rendering%20Rendering/Env%20Rendering/GL%20Rendering/Textures%0A%09Sim/Features%20Sim/Misc%20Sim/MoveTypes%20Sim/Projectiles%0A%09Sim/Projectiles/Unsynced%20Sim/Units%20Sim/Units/COB%0A%09Sim/Units/CommandAI%20Sim/Weapons%20System%20System/FileSystem%0A%09System/Net%20System/Platform/Linux%20System/Platform/Win%0A%09System/Script%20build/cmake%20build/vstudio8%20lib%20lib/gml%0A%09lib/luabind/luabind/detail%20lib/streflop&In-Reply-To=%3C20080614220641.6E1DF449E%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6030 - in branches/gml/rts: . ExternalAI	Game Game/StartScripts Game/UI Lua Map Map/SM3 Map/SMF	Rendering Rendering/Env Rendering/GL Rendering/Textures	Sim/Features Sim/Misc Sim/MoveTypes Sim/Projectiles	Sim/Projectiles/Unsynced Sim/Units Sim/Units/COB	Sim/Units/CommandAI Sim/Weapons System System/FileSystem	System/Net System/Platform/Linux System/Platform/Win	System/Script build/cmake build/vstudio8 lib lib/gml	lib/luabind/luabind/detail lib/streflop">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sun Jun 15 00:06:40 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000809.html">[Taspring-linux-commit] r6029 - in trunk: . installer	installer/sections
</A></li>
        <LI>Next message: <A HREF="000811.html">[Taspring-linux-commit] r6031 - in trunk/rts/Sim/Units: CommandAI	UnitTypes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#810">[ date ]</a>
              <a href="thread.html#810">[ thread ]</a>
              <a href="subject.html#810">[ subject ]</a>
              <a href="author.html#810">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zerver
Date: 2008-06-15 00:06:38 +0200 (Sun, 15 Jun 2008)
New Revision: 6030

Added:
   branches/gml/rts/Map/MapParser.cpp
   branches/gml/rts/Map/MapParser.h
Removed:
   branches/gml/rts/Game/UI/OutlineFont.cpp
   branches/gml/rts/Game/UI/OutlineFont.h
   branches/gml/rts/System/Net/Net.cpp
   branches/gml/rts/System/Net/Net.h
   branches/gml/rts/build/cmake/FindBoost.cmake
Modified:
   branches/gml/rts/CMakeLists.txt
   branches/gml/rts/ExternalAI/AICallback.cpp
   branches/gml/rts/Game/Game.cpp
   branches/gml/rts/Game/GameHelper.h
   branches/gml/rts/Game/GameServer.cpp
   branches/gml/rts/Game/GameServer.h
   branches/gml/rts/Game/GameSetup.cpp
   branches/gml/rts/Game/GameSetupData.h
   branches/gml/rts/Game/PreGame.cpp
   branches/gml/rts/Game/SelectedUnits.cpp
   branches/gml/rts/Game/StartScripts/AirScript.cpp
   branches/gml/rts/Game/StartScripts/AirScript.h
   branches/gml/rts/Game/StartScripts/CommanderScript.cpp
   branches/gml/rts/Game/StartScripts/CommanderScript2.cpp
   branches/gml/rts/Game/StartScripts/CommanderScript2.h
   branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp
   branches/gml/rts/Game/StartScripts/GlobalAITestScript.h
   branches/gml/rts/Game/StartScripts/LoadScript.cpp
   branches/gml/rts/Game/StartScripts/SpawnScript.cpp
   branches/gml/rts/Game/StartScripts/TestScript.cpp
   branches/gml/rts/Game/Team.cpp
   branches/gml/rts/Game/Team.h
   branches/gml/rts/Game/UI/CursorIcons.cpp
   branches/gml/rts/Game/UI/CursorIcons.h
   branches/gml/rts/Game/UI/GameSetupDrawer.cpp
   branches/gml/rts/Game/UI/GuiHandler.cpp
   branches/gml/rts/Game/UI/GuiHandler.h
   branches/gml/rts/Game/UI/InfoConsole.cpp
   branches/gml/rts/Game/UI/LuaUI.cpp
   branches/gml/rts/Game/UI/MiniMap.cpp
   branches/gml/rts/Game/UI/MouseHandler.cpp
   branches/gml/rts/Game/UI/QuitBox.cpp
   branches/gml/rts/Game/UI/ResourceBar.cpp
   branches/gml/rts/Game/UI/ShareBox.cpp
   branches/gml/rts/Game/UI/StartPosSelecter.cpp
   branches/gml/rts/Game/UI/TooltipConsole.cpp
   branches/gml/rts/Lua/LuaConstGame.cpp
   branches/gml/rts/Lua/LuaFeatureDefs.cpp
   branches/gml/rts/Lua/LuaHandle.cpp
   branches/gml/rts/Lua/LuaOpenGL.cpp
   branches/gml/rts/Lua/LuaParser.cpp
   branches/gml/rts/Lua/LuaParser.h
   branches/gml/rts/Lua/LuaRules.cpp
   branches/gml/rts/Lua/LuaRules.h
   branches/gml/rts/Lua/LuaSyncedCtrl.cpp
   branches/gml/rts/Lua/LuaSyncedCtrl.h
   branches/gml/rts/Lua/LuaSyncedRead.cpp
   branches/gml/rts/Lua/LuaUnitDefs.cpp
   branches/gml/rts/Lua/LuaWeaponDefs.cpp
   branches/gml/rts/Map/BasicMapDamage.cpp
   branches/gml/rts/Map/MapInfo.cpp
   branches/gml/rts/Map/MapInfo.h
   branches/gml/rts/Map/MetalMap.cpp
   branches/gml/rts/Map/MetalMap.h
   branches/gml/rts/Map/SM3/Sm3Map.cpp
   branches/gml/rts/Map/SMF/BFGroundDrawer.cpp
   branches/gml/rts/Map/SMF/BFGroundDrawer.h
   branches/gml/rts/Map/SMF/BFGroundTextures.cpp
   branches/gml/rts/Map/SMF/SmfReadMap.cpp
   branches/gml/rts/Map/SMF/SmfReadMap.h
   branches/gml/rts/Map/SMF/mapfile.h
   branches/gml/rts/Rendering/Env/BumpWater.cpp
   branches/gml/rts/Rendering/Env/BumpWater.h
   branches/gml/rts/Rendering/GL/myGL.cpp
   branches/gml/rts/Rendering/GroundDecalHandler.cpp
   branches/gml/rts/Rendering/IconHandler.cpp
   branches/gml/rts/Rendering/InMapDraw.cpp
   branches/gml/rts/Rendering/InMapDraw.h
   branches/gml/rts/Rendering/Textures/Bitmap.cpp
   branches/gml/rts/Rendering/Textures/TextureAtlas.h
   branches/gml/rts/Rendering/Textures/nv_dds.cpp
   branches/gml/rts/Rendering/glFont.cpp
   branches/gml/rts/Rendering/glFont.h
   branches/gml/rts/Sim/Features/FeatureDef.h
   branches/gml/rts/Sim/Features/FeatureHandler.cpp
   branches/gml/rts/Sim/Misc/DamageArrayHandler.cpp
   branches/gml/rts/Sim/Misc/LosHandler.h
   branches/gml/rts/Sim/Misc/RadarHandler.cpp
   branches/gml/rts/Sim/Misc/RadarHandler.h
   branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp
   branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp
   branches/gml/rts/Sim/Projectiles/FireProjectile.cpp
   branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/gml/rts/Sim/Projectiles/ProjectileHandler.h
   branches/gml/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp
   branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp
   branches/gml/rts/Sim/Units/COB/CobInstance.cpp
   branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp
   branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp
   branches/gml/rts/Sim/Units/Unit.cpp
   branches/gml/rts/Sim/Units/Unit.h
   branches/gml/rts/Sim/Units/UnitDef.h
   branches/gml/rts/Sim/Units/UnitDefHandler.cpp
   branches/gml/rts/Sim/Units/UnitDefHandler.h
   branches/gml/rts/Sim/Units/UnitLoader.cpp
   branches/gml/rts/Sim/Weapons/StarburstLauncher.cpp
   branches/gml/rts/Spring.psd
   branches/gml/rts/System/AutohostInterface.cpp
   branches/gml/rts/System/BaseNetProtocol.cpp
   branches/gml/rts/System/BaseNetProtocol.h
   branches/gml/rts/System/FileSystem/Archive7Zip.cpp
   branches/gml/rts/System/FileSystem/ArchiveDir.cpp
   branches/gml/rts/System/FileSystem/ArchiveScanner.cpp
   branches/gml/rts/System/FileSystem/ArchiveScanner.h
   branches/gml/rts/System/FileSystem/ArchiveZip.cpp
   branches/gml/rts/System/FileSystem/FileHandler.cpp
   branches/gml/rts/System/GlobalStuff.cpp
   branches/gml/rts/System/GlobalStuff.h
   branches/gml/rts/System/LogOutput.h
   branches/gml/rts/System/Net/Connection.h
   branches/gml/rts/System/Net/LocalConnection.cpp
   branches/gml/rts/System/Net/LocalConnection.h
   branches/gml/rts/System/Net/ProtocolDef.h
   branches/gml/rts/System/Net/Socket.cpp
   branches/gml/rts/System/Net/Socket.h
   branches/gml/rts/System/Net/UDPConnection.cpp
   branches/gml/rts/System/Net/UDPConnection.h
   branches/gml/rts/System/Net/UDPListener.cpp
   branches/gml/rts/System/Net/UDPListener.h
   branches/gml/rts/System/NetProtocol.cpp
   branches/gml/rts/System/NetProtocol.h
   branches/gml/rts/System/Platform/Linux/DataDirLocater.cpp
   branches/gml/rts/System/Platform/Linux/DotfileHandler.cpp
   branches/gml/rts/System/Platform/Linux/PosixCmd.cpp
   branches/gml/rts/System/Platform/Linux/UnixFileSystemHandler.cpp
   branches/gml/rts/System/Platform/Win/WinFileSystemHandler.cpp
   branches/gml/rts/System/Script/LuaFunctions.cpp
   branches/gml/rts/System/StdAfx.h
   branches/gml/rts/build/cmake/FindWin32Libs.cmake
   branches/gml/rts/build/vstudio8/rts.vcproj
   branches/gml/rts/lib/CMakeLists.txt
   branches/gml/rts/lib/gml/gml.cpp
   branches/gml/rts/lib/gml/gml.h
   branches/gml/rts/lib/gml/gmlcls.h
   branches/gml/rts/lib/gml/gmlfun.h
   branches/gml/rts/lib/gml/gmlsrv.h
   branches/gml/rts/lib/luabind/luabind/detail/policy.hpp
   branches/gml/rts/lib/streflop/CMakeLists.txt
   branches/gml/rts/spring.png
Log:
Added VBO support
Misc bugfixes
Updated to trunk rev 6028

Modified: branches/gml/rts/CMakeLists.txt
===================================================================
--- branches/gml/rts/CMakeLists.txt	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/CMakeLists.txt	2008-06-14 22:06:38 UTC (rev 6030)
@@ -2,7 +2,7 @@
 cmake_minimum_required(VERSION 2.6)
 PROJECT(Spring)
 
-LIST(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_SOURCE_DIR}/build/cmake&quot;)
+LIST(APPEND CMAKE_MODULE_PATH &quot;${CMAKE_CURRENT_SOURCE_DIR}/build/cmake&quot;)
 
 ### Compiler flags and defines based on build type
 INCLUDE(TestCXXAcceptsVisibilityFlag)
@@ -10,26 +10,53 @@
 IF (UNIX)
 	SET(BASE_FLAGS &quot;${BASE_FLAGS} -pthread&quot;)
 ENDIF (UNIX)
-SET(CMAKE_CXX_FLAGS_DEBUG1  &quot;${BASE_FLAGS} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG   &quot;${BASE_FLAGS} -ggdb1 -O1 -Wall -DDEBUG -D_DEBUG&quot;)
 SET(CMAKE_CXX_FLAGS_DEBUG2  &quot;${BASE_FLAGS} -ggdb2 -O0 -Wall -DDEBUG -D_DEBUG&quot;)
 SET(CMAKE_CXX_FLAGS_DEBUG3  &quot;${BASE_FLAGS} -ggdb3 -O0 -Wall -DDEBUG -D_DEBUG&quot;)
-SET(CMAKE_CXX_FLAGS_RELEASE &quot;${BASE_FLAGS} ${VISIBILITY_HIDDEN} -O2 -DNDEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_RELEASE &quot;${BASE_FLAGS} ${VISIBILITY_HIDDEN} -O2 -DNDEBUG -fomit-frame-pointer&quot;)
 
 ### Spring defines
-ADD_DEFINITIONS( -D_SZ_ONE_DIRECTORY -DSYNCCHECK -DSTREFLOP_X87 -DDIRECT_CONTROL_ALLOWED)
+SET(USE_MMGR FALSE CACHE BOOL &quot;Use memory manager?&quot;)
+if (USE_MMGR)
+	ADD_DEFINITIONS(-DUSE_MMGR)
+endif (USE_MMGR)
+
+SET(SYNCCHECK TRUE CACHE BOOL &quot;Check sync during gameplay (Required for online play!)&quot;)
+if (SYNCCHECK)
+	ADD_DEFINITIONS(-DSYNCCHECK)
+endif (SYNCCHECK)
+
+SET(DIRECT_CONTROL TRUE CACHE BOOL &quot;Allow controling units in first-person-mode&quot;)
+if (DIRECT_CONTROL)
+	ADD_DEFINITIONS(-DDIRECT_CONTROL_ALLOWED)
+endif (DIRECT_CONTROL)
+
 IF (UNIX)
 	ADD_DEFINITIONS(-DNO_AVI)
-ELSE(UNIX)
+	
+	SET(SPRING_DATADIR CACHE STRING &quot;Path to game content (in addition to /etc/spring/datadir)&quot;)
+	if (SPRING_DATADIR)
+		ADD_DEFINITIONS(-DSPRING_DATADIR=${SPRING_DATADIR})
+	endif (SPRING_DATADIR)
+ELSEIF (UNIX)
+	SET(NO_AVI FALSE CACHE BOOL &quot;Disable in-game video recording&quot;)
+	if (NO_AVI)
+		ADD_DEFINITIONS(-DNO_AVI)
+	endif (NO_AVI)
 ENDIF(UNIX)
 
-### Find include directories
+ADD_DEFINITIONS(-DSTREFLOP_X87)
+
+### Find include directories and add platform specific libraries
 IF (MINGW)
 	SET(MINGWLIBS ${CMAKE_SOURCE_DIR}/mingwlibs CACHE PATH &quot;Location of the mingwlibs (you can't build windows executables without them)&quot;)
 	FIND_PACKAGE(Win32Libs REQUIRED)
+	LIST(APPEND spring_libraries glu32 ilu opengl32 ${WIN32_LIBRARIES} glew32 mingw32 devil)
 
 	### add mingwlibs to link- and include-directories
 	INCLUDE_DIRECTORIES(${MINGWLIBS}/include ${MINGWLIBS}/include/SDL)
 	LINK_DIRECTORIES(${MINGWLIBS}/lib ${MINGWLIBS}/dll)
+	LIST(APPEND spring_libraries boost_thread-mt boost_regex-mt)
 ELSE (MINGW)
 	FIND_PACKAGE(SDL REQUIRED)
 	INCLUDE_DIRECTORIES(${SDL_INCLUDE_DIR})
@@ -48,10 +75,15 @@
 
 	FIND_PACKAGE(Freetype REQUIRED)
 	INCLUDE_DIRECTORIES(${FREETYPE_INCLUDE_DIR})
+	LIST(APPEND spring_libraries openal GL GLU IL ILU X11 Xcursor ${GLEW_LIBRARIES} ${Boost_REGEX_LIBRARY} ${Boost_THREAD_LIBRARY})
 ENDIF (MINGW)
 
-# build all libraries in lib (has its own CMakeLists.txt)
+### libraries needed on all platforms
+LIST(APPEND spring_libraries SDL vorbisfile vorbis ogg freetype)
+
+### build all libraries in lib (has its own CMakeLists.txt)
 ADD_SUBDIRECTORY(lib)
+LIST(APPEND spring_libraries lua 7zip hpiutil2 minizip streflop luabind)
 
 ### include directories needed for compiling spring
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR} System)
@@ -117,20 +149,6 @@
 	LIST(APPEND sysfiles icon.o)
 ENDIF (MINGW)
 
-
 ADD_EXECUTABLE(spring ${gamefiles} ${luafiles} ${mapfiles} ${fsfiles} ${renderfiles} ${simfiles} ${sysfiles} ${aifiles})
 
-### libraries in lib/
-SET(spring_libraries lua 7zip hpiutil2 minizip streflop luabind)
-### libraries needed on all platforms
-# ${BOOST_THREAD_LIBRARY} doesn't work
-LIST(APPEND spring_libraries SDL boost_thread-mt boost_regex-mt vorbisfile vorbis ogg freetype)
-
-### platform specific libraries
-IF (UNIX)
-	LIST(APPEND spring_libraries openal GL GLU IL ILU X11 Xcursor ${GLEW_LIBRARIES})
-ELSE (UNIX)
-	LIST(APPEND spring_libraries glu32 ilu opengl32 ${WIN32_LIBRARIES} glew32 mingw32 devil)
-ENDIF (UNIX)
-
 TARGET_LINK_LIBRARIES(spring ${spring_libraries})

Modified: branches/gml/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/gml/rts/ExternalAI/AICallback.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/ExternalAI/AICallback.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -80,7 +80,7 @@
 		startPos.x = gameSetup-&gt;startRectRight[GetMyAllyTeam()] * gs-&gt;mapx * 8;
 
 	unsigned char readyness = ready? 1: 0;
-	net-&gt;SendStartPos(gu-&gt;myPlayerNum, team, readyness, startPos.x, startPos.y, startPos.z);
+	net-&gt;Send(CBaseNetProtocol::Get().SendStartPos(gu-&gt;myPlayerNum, team, readyness, startPos.x, startPos.y, startPos.z));
 }
 
 void CAICallback::SendTextMsg(const char* text, int zone)
@@ -124,7 +124,7 @@
 					eAmount = std::max(0.0f, std::min(eAmount, GetEnergy()));
 					std::vector&lt;short&gt; empty;
 
-					net-&gt;SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), mAmount, eAmount, empty);
+					net-&gt;Send(CBaseNetProtocol::Get().SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), mAmount, eAmount, empty));
 				}
 			}
 		}
@@ -166,7 +166,7 @@
 					if (sentUnitIDs.size() &gt; 0) {
 						// we can't use SendShare() here either, since
 						// AI's don't have a notion of &quot;selected units&quot;
-						net-&gt;SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), 0.0f, 0.0f, sentUnitIDs);
+						net-&gt;Send(CBaseNetProtocol::Get().SendAIShare(ubyte(gu-&gt;myPlayerNum), ubyte(team), ubyte(receivingTeam), 0.0f, 0.0f, sentUnitIDs));
 					}
 				}
 			}
@@ -338,7 +338,7 @@
 	if (unit-&gt;team != team)
 		return -1;
 
-	net-&gt;SendAICommand(gu-&gt;myPlayerNum, unitid, c-&gt;id, c-&gt;options, c-&gt;params);
+	net-&gt;Send(CBaseNetProtocol::Get().SendAICommand(gu-&gt;myPlayerNum, unitid, c-&gt;id, c-&gt;options, c-&gt;params));
 	return 0;
 }
 
@@ -1343,18 +1343,13 @@
 	case AIHCQuerySubVersionId:
 		return 1; // current version of Handle Command interface
 	case AIHCAddMapPointId:
-		net-&gt;SendMapDrawPoint(team,
-			(short)((AIHCAddMapPoint *)data)-&gt;pos.x, (short)((AIHCAddMapPoint *)data)-&gt;pos.z,
-			std::string(((AIHCAddMapPoint *)data)-&gt;label));
+		net-&gt;Send(CBaseNetProtocol::Get().SendMapDrawPoint(team, (short)((AIHCAddMapPoint *)data)-&gt;pos.x, (short)((AIHCAddMapPoint *)data)-&gt;pos.z, std::string(((AIHCAddMapPoint *)data)-&gt;label)));
 		return 1;
 	case AIHCAddMapLineId:
-		net-&gt;SendMapDrawLine(team,
-			(short)((AIHCAddMapLine *)data)-&gt;posfrom.x, (short)((AIHCAddMapLine *)data)-&gt;posfrom.z,
-			(short)((AIHCAddMapLine *)data)-&gt;posto.x, (short)((AIHCAddMapLine *)data)-&gt;posto.z);
+		net-&gt;Send(CBaseNetProtocol::Get().SendMapDrawLine(team, (short)((AIHCAddMapLine *)data)-&gt;posfrom.x, (short)((AIHCAddMapLine *)data)-&gt;posfrom.z, (short)((AIHCAddMapLine *)data)-&gt;posto.x, (short)((AIHCAddMapLine *)data)-&gt;posto.z));
 		return 1;
 	case AIHCRemoveMapPointId:
-		net-&gt;SendMapErase(team,
-			(short)((AIHCRemoveMapPoint *)data)-&gt;pos.x, (short)((AIHCRemoveMapPoint *)data)-&gt;pos.z);
+		net-&gt;Send(CBaseNetProtocol::Get().SendMapErase(team, (short)((AIHCRemoveMapPoint *)data)-&gt;pos.x, (short)((AIHCRemoveMapPoint *)data)-&gt;pos.z));
 		return 1;
 	case AIHCSendStartPosId:
 		SendStartPos(((AIHCSendStartPos *)data)-&gt;ready,((AIHCSendStartPos *)data)-&gt;pos);

Modified: branches/gml/rts/Game/Game.cpp
===================================================================
--- branches/gml/rts/Game/Game.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/Game.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -8,6 +8,7 @@
 #include &lt;time.h&gt;
 #include &lt;cctype&gt;
 #include &lt;locale&gt;
+#include &lt;sstream&gt;
 
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;SDL_keyboard.h&gt;
@@ -110,6 +111,7 @@
 #include &quot;System/FileSystem/SimpleParser.h&quot;
 #include &quot;System/Sound.h&quot;
 #include &quot;System/Platform/NullSound.h&quot;
+#include &quot;System/Net/RawPacket.h&quot;
 #include &quot;Platform/Clipboard.h&quot;
 #include &quot;UI/CommandColors.h&quot;
 #include &quot;UI/CursorIcons.h&quot;
@@ -123,7 +125,6 @@
 #include &quot;UI/LuaUI.h&quot;
 #include &quot;UI/MiniMap.h&quot;
 #include &quot;UI/MouseHandler.h&quot;
-#include &quot;UI/OutlineFont.h&quot;
 #include &quot;UI/QuitBox.h&quot;
 #include &quot;UI/ResourceBar.h&quot;
 #include &quot;UI/SelectionKeyHandler.h&quot;
@@ -305,7 +306,7 @@
 	modInfo.Init(modName.c_str());
 
 	defsParser = SAFE_NEW LuaParser(&quot;gamedata/defs.lua&quot;,
-	                                 SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	                                SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
 	// customize the defs environment
 	defsParser-&gt;GetTable(&quot;Spring&quot;);
 	defsParser-&gt;AddFunc(&quot;GetModOptions&quot;, LuaSyncedRead::GetModOptions);
@@ -485,10 +486,10 @@
 	thread.join();
 	logOutput.Print(&quot;Spring %s&quot;,VERSION_STRING);
 	//sending your playername to the server indicates that you are finished loading
-	net-&gt;SendPlayerName(gu-&gt;myPlayerNum, p-&gt;playerName);
+	net-&gt;Send(CBaseNetProtocol::Get().SendPlayerName(gu-&gt;myPlayerNum, p-&gt;playerName));
 
 	if (net-&gt;localDemoPlayback) // auto-start when playing a demo in local mode
-		net-&gt;SendStartPlaying(0);
+		net-&gt;Send(CBaseNetProtocol::Get().SendStartPlaying(0));
 
 	lastCpuUsageTime = gu-&gt;gameTime + 10;
 
@@ -1040,12 +1041,12 @@
 		{
 			int team=atoi(action.extra.c_str());
 			if ((team &gt;= 0) &amp;&amp; (team &lt;gs-&gt;activeTeams)) {
-				net-&gt;SendJoinTeam(gu-&gt;myPlayerNum, team);
+				net-&gt;Send(CBaseNetProtocol::Get().SendJoinTeam(gu-&gt;myPlayerNum, team));
 			}
 		}
 	}
 	else if (cmd == &quot;spectator&quot;){
-		net-&gt;SendResign(gu-&gt;myPlayerNum);
+		net-&gt;Send(CBaseNetProtocol::Get().SendResign(gu-&gt;myPlayerNum));
 	}
 	else if ((cmd == &quot;specteam&quot;) &amp;&amp; gu-&gt;spectating) {
 		const int team = atoi(action.extra.c_str());
@@ -1077,7 +1078,7 @@
 				int state = -1;
 				is &gt;&gt; state;
 				if (state &gt;= 0 &amp;&amp; state &lt; 2 &amp;&amp; otherAllyTeam &gt;= 0 &amp;&amp; otherAllyTeam != gu-&gt;myAllyTeam)
-					net-&gt;SendSetAllied(gu-&gt;myPlayerNum, otherAllyTeam, state);
+					net-&gt;Send(CBaseNetProtocol::Get().SendSetAllied(gu-&gt;myPlayerNum, otherAllyTeam, state));
 			}
 		}
 	}
@@ -1169,7 +1170,7 @@
 			} else {
 				newPause = !!atoi(action.extra.c_str());
 			}
-			net-&gt;SendPause(gu-&gt;myPlayerNum, newPause);
+			net-&gt;Send(CBaseNetProtocol::Get().SendPause(gu-&gt;myPlayerNum, newPause));
 			lastframe = SDL_GetTicks(); // this required here?
 		}
 	}
@@ -1347,7 +1348,7 @@
 		} else {
 			speed += 0.5f;
 		}
-		net-&gt;SendUserSpeed(gu-&gt;myPlayerNum, speed);
+		net-&gt;Send(CBaseNetProtocol::Get().SendUserSpeed(gu-&gt;myPlayerNum, speed));
 	}
 	else if (cmd == &quot;slowdown&quot;) {
 		float speed = gs-&gt;userSpeedFactor;
@@ -1359,7 +1360,7 @@
 		} else {
 			speed -= 0.5f;
 		}
-		net-&gt;SendUserSpeed(gu-&gt;myPlayerNum, speed);
+		net-&gt;Send(CBaseNetProtocol::Get().SendUserSpeed(gu-&gt;myPlayerNum, speed));
 	}
 
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -1368,7 +1369,7 @@
 		c.id=CMD_STOP;
 		c.options=0;
 		selectedUnits.GiveCommand(c,false);		//force it to update selection and clear order que
-		net-&gt;SendDirectControl(gu-&gt;myPlayerNum);
+		net-&gt;Send(CBaseNetProtocol::Get().SendDirectControl(gu-&gt;myPlayerNum));
 	}
 #endif
 
@@ -1839,16 +1840,16 @@
 			SNPRINTF(buf, sizeof(buf), &quot; @%.0f,%.0f,%.0f&quot;, p.x, p.y, p.z);
 			msg += buf;
 			CommandMessage pckt(msg, gu-&gt;myPlayerNum);
-			net-&gt;SendData(pckt.Pack());
+			net-&gt;Send(pckt.Pack());
 		}
 		else {
 			CommandMessage pckt(action, gu-&gt;myPlayerNum);
-			net-&gt;SendData(pckt.Pack());
+			net-&gt;Send(pckt.Pack());
 		}
 	}
 	else if (cmd == &quot;send&quot;) {
 		CommandMessage pckt(Action(action.extra), gu-&gt;myPlayerNum);
-		net-&gt;SendData(pckt.Pack());
+		net-&gt;Send(pckt.Pack());
 	}
 	else if (cmd == &quot;save&quot;) {// /save [-y ]&lt;savename&gt;
 		if (filesystem.CreateDirectory(&quot;Saves&quot;)) {
@@ -1875,7 +1876,7 @@
 			cmd == &quot;luarules&quot;) {
 		//these are synced commands, forward only
 		CommandMessage pckt(action, gu-&gt;myPlayerNum);
-		net-&gt;SendData(pckt.Pack());
+		net-&gt;Send(pckt.Pack());
 	}
 	else {
 		if (!Console::Instance().ExecuteAction(action))
@@ -2085,12 +2086,13 @@
 				float posx = pos.x + (a % sqSize - sqSize / 2) * 10 * SQUARE_SIZE;
 				float posz = pos.z + (a / sqSize - sqSize / 2) * 10 * SQUARE_SIZE;
 				float3 pos2 = float3(posx, pos.y, posz);
-				const string&amp; defName = unitDefHandler-&gt;unitDefs[a].name;
-				const CUnit* unit =
-						unitLoader.LoadUnit(defName, pos2, team, false, 0, NULL);
-
-				if (unit) {
-					unitLoader.FlattenGround(unit);
+				const UnitDef* ud = &amp;unitDefHandler-&gt;unitDefs[a];
+				if (ud-&gt;valid) {
+					const CUnit* unit =
+						unitLoader.LoadUnit(ud-&gt;name, pos2, team, false, 0, NULL);
+					if (unit) {
+						unitLoader.FlattenGround(unit);
+					}
 				}
 			}
 		}
@@ -2391,7 +2393,7 @@
 	}
 
 	ClientReadNet();
-	if (!net-&gt;IsActiveConnection() &amp;&amp; !gameOver) {
+	if (!net-&gt;Active() &amp;&amp; !gameOver) {
 		logOutput.Print(&quot;Lost connection to gameserver&quot;);
 		gameOver = true;
 		luaCallIns.GameOver();
@@ -2410,7 +2412,7 @@
 			chatting = false;
 			userWriting = false;
 			writingPos = 0;
-			net-&gt;SendStartPlaying(0);
+			net-&gt;Send(CBaseNetProtocol::Get().SendStartPlaying(0));
 		}
 	}
 
@@ -2778,7 +2780,7 @@
 		const float fontScale = 1.0f;
 
 		glColor4f(1,1,1,1);
-		if (!outlineFont.IsEnabled()) {
+		if (!guihandler-&gt;GetOutlineFonts()) {
 			smallFont-&gt;glPrintRight(0.99f, 0.94f, fontScale, buf);
 		} else {
 			const float white[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
@@ -2792,7 +2794,7 @@
 
 		const float fontScale = 1.0f;
 
-		if (!outlineFont.IsEnabled()) {
+		if (!guihandler-&gt;GetOutlineFonts()) {
 			glColor4f(1.0f, 1.0f, 0.25f, 1.0f);
 			smallFont-&gt;glPrintRight(0.99f, 0.92f, fontScale, buf);
 		} else {
@@ -2835,7 +2837,7 @@
 						p-&gt;team, prefix, p-&gt;playerName.c_str(), p-&gt;cpuUsage * 100.0f,
 						(int)(((p-&gt;ping) * 1000) / (GAME_SPEED * gs-&gt;speedFactor)));
 
-			if (!outlineFont.IsEnabled()) {
+			if (!guihandler-&gt;GetOutlineFonts()) {
 				glColor4fv(color);
 				smallFont-&gt;glPrintAt(0.76f, 0.01f + (0.02f * (count - a - 1)), fontScale, buf);
 			} else {
@@ -2930,7 +2932,7 @@
 	}
 
 	// draw the text
-	if (!outlineFont.IsEnabled()) {
+	if (!guihandler-&gt;GetOutlineFonts()) {
 		glColor4fv(textColor);
 		font-&gt;glPrintAt(inputTextPosX, inputTextPosY, fontScale, tempstring.c_str());
 	} else {
@@ -3035,7 +3037,7 @@
 				oldHeading=hp.x;
 				oldPitch=hp.y;
 				oldStatus=status;
-				net-&gt;SendDirectControlUpdate(gu-&gt;myPlayerNum, status, hp.x, hp.y);
+				net-&gt;Send(CBaseNetProtocol::Get().SendDirectControlUpdate(gu-&gt;myPlayerNum, status, hp.x, hp.y));
 			}
 		}
 #endif
@@ -3144,12 +3146,9 @@
 
 void CGame::ClientReadNet()
 {
-	if (!net-&gt;IsActiveConnection())
-		return; // should not happen
-
 	if (gu-&gt;gameTime - lastCpuUsageTime &gt;= 1) {
 		lastCpuUsageTime = gu-&gt;gameTime;
-		net-&gt;SendCPUUsage(profiler.profile[&quot;Sim time&quot;].percent);
+		net-&gt;Send(CBaseNetProtocol::Get().SendCPUUsage(profiler.profile[&quot;Sim time&quot;].percent));
 	}
 
 	PUSH_CODE_MODE;
@@ -3279,7 +3278,7 @@
 				logOutput.Print(&quot;Game over&quot;);
 			// Warning: using CPlayer::Statistics here may cause endianness problems
 			// once net-&gt;SendData is endian aware!
-				net-&gt;SendPlayerStat(gu-&gt;myPlayerNum, *gs-&gt;players[gu-&gt;myPlayerNum]-&gt;currentStats);
+				net-&gt;Send(CBaseNetProtocol::Get().SendPlayerStat(gu-&gt;myPlayerNum, *gs-&gt;players[gu-&gt;myPlayerNum]-&gt;currentStats));
 				ENTER_SYNCED;
 				AddTraffic(-1, packetCode, dataLength);
 				break;
@@ -3389,19 +3388,26 @@
 				if ((team &gt;= gs-&gt;activeTeams) || (team &lt; 0) || !gameSetup) {
 					logOutput.Print(&quot;Got invalid team num %i in startpos msg&quot;,team);
 				} else {
-					if (inbuf[3] != 2) {
-						gameSetup-&gt;readyTeams[team] = !!inbuf[3];
+					float3 pos(*(float*)&amp;inbuf[4],
+					           *(float*)&amp;inbuf[8],
+					           *(float*)&amp;inbuf[12]);
+					if (!luaRules || luaRules-&gt;AllowStartPosition(player, pos)) {
+						if (inbuf[3] != 2) {
+							gameSetup-&gt;readyTeams[team] = !!inbuf[3];
+						}
+						gs-&gt;Team(team)-&gt;startPos = pos;
+						char label[128];
+						SNPRINTF(label, sizeof(label), &quot;Start %i&quot;, team);
+						inMapDrawer-&gt;LocalPoint(pos, label, player);
+						// FIXME - erase old pos ?
 					}
-					gs-&gt;Team(team)-&gt;startPos.x = *(float*)&amp;inbuf[4];
-					gs-&gt;Team(team)-&gt;startPos.y = *(float*)&amp;inbuf[8];
-					gs-&gt;Team(team)-&gt;startPos.z = *(float*)&amp;inbuf[12];
 				}
 				AddTraffic(player, packetCode, dataLength);
 				break;
 			}
 
 			case NETMSG_RANDSEED: {
-				gs-&gt;SetRandSeed(*((unsigned int*)&amp;inbuf[1]));
+				gs-&gt;SetRandSeed(*((unsigned int*)&amp;inbuf[1]), true);
 				AddTraffic(-1, packetCode, dataLength);
 				break;
 			}
@@ -3424,7 +3430,7 @@
 			case NETMSG_KEYFRAME: {
 				int serverframenum = *(int*)(inbuf+1);
 #ifndef SYNCCHECK
-				net-&gt;SendKeyFrame(serverframenum-1);
+				net-&gt;Send(CBaseNetProtocol::Get().SendKeyFrame(serverframenum-1));
 #endif
 				if (gs-&gt;frameNum == (serverframenum - 1)) {
 					// everything ok, fall through
@@ -3437,7 +3443,7 @@
 				SimFrame();
 				// both NETMSG_SYNCRESPONSE and NETMSG_NEWFRAME are used for ping calculation by server
 #ifdef SYNCCHECK
-				net-&gt;SendSyncResponse(gu-&gt;myPlayerNum, gs-&gt;frameNum, CSyncChecker::GetChecksum());
+				net-&gt;Send(CBaseNetProtocol::Get().SendSyncResponse(gu-&gt;myPlayerNum, gs-&gt;frameNum, CSyncChecker::GetChecksum()));
 				if ((gs-&gt;frameNum &amp; 4095) == 0) // reset checksum every ~2.5 minute gametime
 					CSyncChecker::NewFrame();
 #endif
@@ -3625,7 +3631,7 @@
 				if (frame != gs-&gt;frameNum) {
 					logOutput.Print(&quot;Sync request for wrong frame (%i instead of %i)&quot;, frame, gs-&gt;frameNum);
 				}
-				net-&gt;SendCPUUsage(profiler.profile[&quot;Sim time&quot;].percent);
+				net-&gt;Send(CBaseNetProtocol::Get().SendCPUUsage(profiler.profile[&quot;Sim time&quot;].percent));
 				ENTER_SYNCED;
 				AddTraffic(-1, packetCode, dataLength);
 				break;
@@ -4005,7 +4011,7 @@
 			userInput = userInput.substr(0, 200);
 			writingPos = (int)userInput.length();
 		}
-		inMapDrawer-&gt;CreatePoint(inMapDrawer-&gt;waitingPoint,userInput);
+		inMapDrawer-&gt;SendPoint(inMapDrawer-&gt;waitingPoint, userInput);
 		inMapDrawer-&gt;wantLabel = false;
 		userInput = &quot;&quot;;
 		writingPos = 0;
@@ -4325,7 +4331,7 @@
 		message.resize(128); // safety
 	}
 	ChatMessage buf(gu-&gt;myPlayerNum, destination, message);
-	net-&gt;SendData(buf.Pack());
+	net-&gt;Send(buf.Pack());
 }
 
 
@@ -4639,31 +4645,31 @@
 
 	LuaParser luaParser(&quot;teamcolors.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW_FIRST);
 
-	luaParser.AddParam(&quot;myPlayer&quot;, gu-&gt;myPlayerNum);
+	luaParser.AddInt(&quot;myPlayer&quot;, gu-&gt;myPlayerNum);
 
-	luaParser.AddParam(&quot;modName&quot;,      modInfo.humanName);
-	luaParser.AddParam(&quot;modShortName&quot;, modInfo.shortName);
-	luaParser.AddParam(&quot;modVersion&quot;,   modInfo.version);
+	luaParser.AddString(&quot;modName&quot;,      modInfo.humanName);
+	luaParser.AddString(&quot;modShortName&quot;, modInfo.shortName);
+	luaParser.AddString(&quot;modVersion&quot;,   modInfo.version);
 
-	luaParser.AddParam(&quot;mapName&quot;,      mapInfo-&gt;map.name);
-	luaParser.AddParam(&quot;mapHumanName&quot;, mapInfo-&gt;map.humanName);
+	luaParser.AddString(&quot;mapName&quot;,      mapInfo-&gt;map.name);
+	luaParser.AddString(&quot;mapHumanName&quot;, mapInfo-&gt;map.humanName);
 
-	luaParser.AddParam(&quot;gameMode&quot;,     gs-&gt;gameMode);
+	luaParser.AddInt(&quot;gameMode&quot;, gs-&gt;gameMode);
 
 	luaParser.GetTable(&quot;teams&quot;);
 	for(int t = 0; t &lt; gs-&gt;activeTeams; ++t) {
 		luaParser.GetTable(t); {
 			const CTeam* team = gs-&gt;Team(t);
 			const unsigned char* color = gs-&gt;Team(t)-&gt;color;
-			luaParser.AddParam(&quot;allyTeam&quot;, gs-&gt;AllyTeam(t));
-			luaParser.AddParam(&quot;gaia&quot;,     team-&gt;gaia);
-			luaParser.AddParam(&quot;leader&quot;,   team-&gt;leader);
-			luaParser.AddParam(&quot;side&quot;,     team-&gt;side);
+			luaParser.AddInt(&quot;allyTeam&quot;, gs-&gt;AllyTeam(t));
+			luaParser.AddBool(&quot;gaia&quot;,    team-&gt;gaia);
+			luaParser.AddInt(&quot;leader&quot;,   team-&gt;leader);
+			luaParser.AddString(&quot;side&quot;,  team-&gt;side);
 			luaParser.GetTable(&quot;color&quot;); {
-				luaParser.AddParam(1, float(color[0]) / 255.0f);
-				luaParser.AddParam(2, float(color[1]) / 255.0f);
-				luaParser.AddParam(3, float(color[2]) / 255.0f);
-				luaParser.AddParam(4, float(color[3]) / 255.0f);
+				luaParser.AddFloat(1, float(color[0]) / 255.0f);
+				luaParser.AddFloat(2, float(color[1]) / 255.0f);
+				luaParser.AddFloat(3, float(color[2]) / 255.0f);
+				luaParser.AddFloat(4, float(color[3]) / 255.0f);
 			}
 			luaParser.EndTable(); // color
 		}
@@ -4675,10 +4681,10 @@
 	for(int p = 0; p &lt; gs-&gt;activePlayers; ++p) {
 		luaParser.GetTable(p); {
 			const CPlayer* player = gs-&gt;players[p];
-			luaParser.AddParam(&quot;name&quot;,       player-&gt;playerName);
-			luaParser.AddParam(&quot;team&quot;,       player-&gt;team);
-			luaParser.AddParam(&quot;active&quot;,     player-&gt;active);
-			luaParser.AddParam(&quot;spectating&quot;, player-&gt;spectator);
+			luaParser.AddString(&quot;name&quot;,     player-&gt;playerName);
+			luaParser.AddInt(&quot;team&quot;,        player-&gt;team);
+			luaParser.AddBool(&quot;active&quot;,     player-&gt;active);
+			luaParser.AddBool(&quot;spectating&quot;, player-&gt;spectator);
 		}
 		luaParser.EndTable(); // player#
 	}

Modified: branches/gml/rts/Game/GameHelper.h
===================================================================
--- branches/gml/rts/Game/GameHelper.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/GameHelper.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -66,11 +66,11 @@
 		inline void operator delete(void* p,size_t size){mempool.Free(p,size);};
 #endif
 		WaitingDamage(int attacker,int target,const DamageArray&amp; damage,const float3&amp; impulse, const int weaponId)
-			:	attacker(attacker),
-				target(target),
+			:	target(target),
+				attacker(attacker),
+				weaponId(weaponId),
 				damage(damage),
-				impulse(impulse),
-				weaponId(weaponId)
+				impulse(impulse)
 		{}
 
 		int target;

Modified: branches/gml/rts/Game/GameServer.cpp
===================================================================
--- branches/gml/rts/Game/GameServer.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/GameServer.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -8,7 +8,7 @@
 #include &lt;boost/version.hpp&gt;
 #include &lt;SDL_timer.h&gt;
 #include &lt;cmath&gt;
-#ifdef DEDICATED
+#if defined DEDICATED || defined DEBUG
 #include &lt;iostream&gt;
 #endif
 #ifndef NO_AVI
@@ -21,6 +21,9 @@
 #include &quot;CommandMessage.h&quot;
 #include &quot;System/StdAfx.h&quot;
 #include &quot;System/BaseNetProtocol.h&quot;
+#include &quot;System/Net/UDPListener.h&quot;
+#include &quot;System/Net/Connection.h&quot;
+#include &quot;System/Net/LocalConnection.h&quot;
 #include &quot;System/DemoReader.h&quot;
 #include &quot;System/AutohostInterface.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
@@ -29,13 +32,11 @@
 #include &quot;Team.h&quot;
 #include &quot;Server/MsgStrings.h&quot;
 
-#ifdef DEDICATED
-#include &lt;iostream&gt;
-#endif
 
 #if _MSC_VER 
 namespace std { using ::ceil; }
 #endif
+using netcode::RawPacket;
 
 
 /// frames until a syncchech will time out and a warning is given out
@@ -58,13 +59,13 @@
 
 using boost::format;
 
-GameParticipant::GameParticipant(bool willHaveRights)
+GameParticipant::GameParticipant(bool local)
 : name(&quot;unnamed&quot;)
 , readyToStart(false)
 , cpuUsage (0.0f)
 , ping (0)
-, hasRights(willHaveRights)
 , team(0)
+, isLocal(local)
 {
 }
 namespace {
@@ -85,7 +86,7 @@
 
 CGameServer* gameServer=0;
 
-CGameServer::CGameServer(int port, const GameData* const newGameData, const CGameSetupData* const mysetup = 0, const std::string&amp; demoName)
+CGameServer::CGameServer(int port, bool onlyLocal, const GameData* const newGameData, const CGameSetupData* const mysetup = 0, const std::string&amp; demoName)
 : setup(mysetup)
 {
 	serverStartTime = SDL_GetTicks();
@@ -104,8 +105,8 @@
 #ifdef DEBUG
 	gameClientUpdated=false;
 #endif
-	demoReader = 0;
-	hostif = 0;
+	hasLocalClient = false;
+	localClientNumber = 0;
 	IsPaused = false;
 	userSpeedFactor = 1.0f;
 	internalSpeed = 1.0f;
@@ -113,8 +114,10 @@
 	noHelperAIs = false;
 	cheating = false;
 	sentGameOverMsg = false;
-	serverNet = new CBaseNetProtocol();
-	serverNet-&gt;InitServer(port);
+	
+	if (!onlyLocal)
+		UDPNet.reset(new netcode::UDPListener(port));
+	
 	rng.Seed(SDL_GetTicks());
 	Message(str( format(ServerStart) %port) );
 
@@ -135,7 +138,7 @@
 	if (!demoName.empty())
 	{
 		Message(str( format(PlayingDemo) %demoName ));
-		demoReader = new CDemoReader(demoName, modGameTime+0.1f);
+		demoReader.reset(new CDemoReader(demoName, modGameTime+0.1f));
 	}
 
 	RestrictedAction(&quot;kick&quot;);			RestrictedAction(&quot;kickbynum&quot;);
@@ -170,30 +173,22 @@
 	quitServer=true;
 	thread-&gt;join();
 	delete thread;
-	if (demoReader)
-		delete demoReader;
-
-	delete serverNet;
-	serverNet=0;
-	if (hostif)
-	{
-		hostif-&gt;SendQuit();
-		delete hostif;
-	}
 }
 
-void CGameServer::AddLocalClient()
+void CGameServer::AddLocalClient(unsigned wantedNumber)
 {
 	boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
-	serverNet-&gt;ServerInitLocalClient();
+	assert(!hasLocalClient);
+	hasLocalClient = true;
+	localClientNumber = BindConnection(wantedNumber, true, boost::shared_ptr&lt;netcode::CConnection&gt;(new netcode::CLocalConnection()));
 }
 
 void CGameServer::AddAutohostInterface(const int remotePort)
 {
-	if (hostif == 0)
+	if (!hostif)
 	{
 		boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
-		hostif = new AutohostInterface(remotePort);
+		hostif.reset(new AutohostInterface(remotePort));
 		hostif-&gt;SendStart();
 		Message(str(format(ConnectAutohost) %remotePort));
 	}
@@ -211,18 +206,20 @@
 	if (targetframe &gt; serverframenum &amp;&amp; demoReader)
 	{
 		CommandMessage msg(str( boost::format(&quot;skip start %d&quot;) %targetframe ), SERVER_PLAYER);
-		serverNet-&gt;SendData(msg.Pack());
+		Broadcast(boost::shared_ptr&lt;const netcode::RawPacket&gt;(msg.Pack()));
 		// fast-read and send demo data
 		while (serverframenum &lt; targetframe)
 		{
 			modGameTime = demoReader-&gt;GetNextReadTime()+0.1f; // skip time
 			SendDemoData(true);
-			if (serverframenum % 20 == 0)
-				serverNet-&gt;Update(); // send some data
+			if (serverframenum % 20 == 0 &amp;&amp; UDPNet)
+				UDPNet-&gt;Update(); // send some data (otherwise packets will grow too big)
 		}
 		CommandMessage msg2(&quot;skip end&quot;, SERVER_PLAYER);
-		serverNet-&gt;SendData(msg2.Pack());
-		serverNet-&gt;Update();
+		Broadcast(boost::shared_ptr&lt;const netcode::RawPacket&gt;(msg2.Pack()));
+		
+		if (UDPNet)
+			UDPNet-&gt;Update();
 	}
 	else
 	{
@@ -244,7 +241,7 @@
 
 void CGameServer::SendDemoData(const bool skipping)
 {
-	RawPacket* buf = 0;
+	netcode::RawPacket* buf = 0;
 	while ( (buf = demoReader-&gt;GetData(modGameTime)) )
 	{
 		unsigned msgCode = static_cast&lt;unsigned&gt;(buf-&gt;data[0]);
@@ -257,7 +254,7 @@
 			if (!skipping)
 				outstandingSyncFrames.push_back(serverframenum);
 #endif
-			serverNet-&gt;SendData(buf);
+			Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(buf));
 		}
 		else if ( msgCode != NETMSG_GAMEDATA &amp;&amp;
 						msgCode != NETMSG_SETPLAYERNUM &amp;&amp;
@@ -267,18 +264,26 @@
 		{
 			if (msgCode == NETMSG_GAMEOVER)
 				sentGameOverMsg = true;
-			serverNet-&gt;SendData(buf);
+			Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(buf));
 		}
 	}
 
 	if (demoReader-&gt;ReachedEnd()) {
-		delete demoReader;
-		demoReader = 0;
+		demoReader.reset();
 		Message(DemoEnd);
 		gameEndTime = SDL_GetTicks();
 	}
 }
 
+void CGameServer::Broadcast(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet)
+{
+	for (unsigned p = 0; p &lt; static_cast&lt;unsigned&gt;(MAX_PLAYERS); ++p)
+	{
+		if (players[p])
+			players[p]-&gt;link-&gt;SendData(packet);
+	}
+}
+
 void CGameServer::Message(const std::string&amp; message)
 {
 	Warning(message);
@@ -286,10 +291,10 @@
 
 void CGameServer::Warning(const std::string&amp; message)
 {
-	serverNet-&gt;SendSystemMessage(SERVER_PLAYER, message);
+	Broadcast(CBaseNetProtocol::Get().SendSystemMessage(SERVER_PLAYER, message));
 	if (hostif)
 		hostif-&gt;Message(message);
-#ifdef DEDICATED
+#if defined DEDICATED || defined DEBUG
 	std::cout &lt;&lt; message &lt;&lt; std::endl;
 #endif
 }
@@ -392,7 +397,7 @@
 			float maxCpu = 0.0f;
 			for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
 				if (players[a]) {
-					serverNet-&gt;SendPlayerInfo(a, players[a]-&gt;cpuUsage, players[a]-&gt;ping);
+					Broadcast(CBaseNetProtocol::Get().SendPlayerInfo(a, players[a]-&gt;cpuUsage, players[a]-&gt;ping));
 					if (players[a]-&gt;cpuUsage &gt; maxCpu) {
 						maxCpu = players[a]-&gt;cpuUsage;
 					}
@@ -410,20 +415,18 @@
 				if(newSpeed&lt;0.1f)
 					newSpeed=0.1f;
 				if(newSpeed!=internalSpeed)
-					serverNet-&gt;SendInternalSpeed(newSpeed);
+					Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(newSpeed));
 			}
 		}
 	}
 
 	// when hosting a demo, read from file and broadcast data
-	if (demoReader != 0)
+	if (demoReader)
 	{
 		CheckSync();
 		SendDemoData();
 	}
 
-	ServerReadNet();
-
 	if (!gameStartTime)
 	{
 		CheckForGameStart();
@@ -434,7 +437,6 @@
 		if (!sentGameOverMsg)
 			CheckForGameEnd();
 	}
-	serverNet-&gt;Update();
 
 	if (hostif)
 	{
@@ -458,458 +460,460 @@
 		}
 	}
 	
-	if ((SDL_GetTicks() - serverStartTime) &gt; serverTimeout &amp;&amp; serverNet-&gt;MaxConnectionID() == -1)
+	if ((SDL_GetTicks() - serverStartTime) &gt; serverTimeout)
 	{
-		Message(NoClientsExit);
-		quitServer = true;
-	}
-}
-
-void CGameServer::ServerReadNet()
-{
-	// handle new connections
-	while (serverNet-&gt;HasIncomingConnection())
-	{
-		boost::shared_ptr&lt;const RawPacket&gt; packet = serverNet-&gt;GetData();
-		
-		if (packet-&gt;length &gt;= 3 &amp;&amp; packet-&gt;data[0] == NETMSG_ATTEMPTCONNECT &amp;&amp; packet-&gt;data[2] == NETWORK_VERSION)
+		bool hasPlayers = false;
+		for (unsigned i = 0; i &lt; static_cast&lt;unsigned&gt;(MAX_PLAYERS); ++i)
 		{
-			const unsigned wantedNumber = packet-&gt;data[1];
-			BindConnection(wantedNumber);
+			if (players[i])
+				hasPlayers = true;
 		}
-		else
+		
+		if (!hasPlayers)
 		{
-			if (packet-&gt;length &gt;= 3) {
-				Warning(str(format(ConnectionReject) %packet-&gt;data[0] %packet-&gt;data[2] %packet-&gt;length));
-			}
-			else {
-				Warning(&quot;Connection attempt rejected: Packet too short&quot;);
-			}
-			serverNet-&gt;RejectIncomingConnection();
+			Message(NoClientsExit);
+			quitServer = true;
 		}
 	}
+}
 
-	for(unsigned a=0; (int)a &lt;= serverNet-&gt;MaxConnectionID(); a++)
-	{
-		if (serverNet-&gt;IsActiveConnection(a))
-		{
-			boost::shared_ptr&lt;const RawPacket&gt; packet;
-			bool quit = false;
-			while (!quit &amp;&amp; (packet = serverNet-&gt;GetData(a)))
-			{
-				const unsigned char* inbuf = packet-&gt;data;
-				switch (inbuf[0]){
-					case NETMSG_KEYFRAME:
-						players[a]-&gt;ping = serverframenum-*(int*)&amp;inbuf[1];
-						break;
+void CGameServer::ProcessPacket(const unsigned playernum, boost::shared_ptr&lt;const netcode::RawPacket&gt; packet)
+{
+	const unsigned char* inbuf = packet-&gt;data;
+	const unsigned a = playernum;
 
-					case NETMSG_PAUSE:
-						if(inbuf[1]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							if (!inbuf[2])  // reset sync checker
-								syncErrorFrame = 0;
-							if(gamePausable || players[a]-&gt;hasRights) // allow host to pause even if nopause is set
-							{
-								timeLeft=0;
-								if (IsPaused != !!inbuf[2]) {
-									IsPaused ? IsPaused = false : IsPaused = true;
-								}
-								serverNet-&gt;SendPause(inbuf[1],inbuf[2]);
-							}
-						}
-						break;
+	switch (inbuf[0]){
+		case NETMSG_KEYFRAME:
+			players[a]-&gt;ping = serverframenum-*(int*)&amp;inbuf[1];
+			break;
 
-					case NETMSG_USER_SPEED: {
-						unsigned char playerNum = inbuf[1];
-						float speed = *((float*) &amp;inbuf[2]);
+		case NETMSG_PAUSE:
+			if(inbuf[1]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				if (!inbuf[2])  // reset sync checker
+					syncErrorFrame = 0;
+				if(gamePausable || players[a]-&gt;isLocal) // allow host to pause even if nopause is set
+				{
+					timeLeft=0;
+					if (IsPaused != !!inbuf[2]) {
+						IsPaused ? IsPaused = false : IsPaused = true;
+					}
+					Broadcast(CBaseNetProtocol::Get().SendPause(inbuf[1],inbuf[2]));
+				}
+			}
+			break;
 
-						if (speed &gt; maxUserSpeed)
-							speed = maxUserSpeed;
-						if (speed &lt; minUserSpeed)
-							speed = minUserSpeed;
-						if (userSpeedFactor != speed)
-						{
-							if (internalSpeed == userSpeedFactor || internalSpeed&gt;speed)
-							{
-								serverNet-&gt;SendInternalSpeed(speed);
-								internalSpeed = speed;
-							}
-							// forward data
-							serverNet-&gt;SendUserSpeed(playerNum, speed);
-							userSpeedFactor = speed;
-						}
-					} break;
+		case NETMSG_USER_SPEED: {
+			unsigned char playerNum = inbuf[1];
+			float speed = *((float*) &amp;inbuf[2]);
 
+			if (speed &gt; maxUserSpeed)
+				speed = maxUserSpeed;
+			if (speed &lt; minUserSpeed)
+				speed = minUserSpeed;
+			if (userSpeedFactor != speed)
+			{
+				if (internalSpeed == userSpeedFactor || internalSpeed&gt;speed)
+				{
+					Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(speed));
+					internalSpeed = speed;
+				}
+				// forward data
+				Broadcast(CBaseNetProtocol::Get().SendUserSpeed(playerNum, speed));
+				userSpeedFactor = speed;
+			}
+		} break;
 
-					case NETMSG_CPU_USAGE:
-						players[a]-&gt;cpuUsage = *((float*)&amp;inbuf[1]);
-						break;
+		case NETMSG_CPU_USAGE:
+			players[a]-&gt;cpuUsage = *((float*)&amp;inbuf[1]);
+			break;
 
-					case NETMSG_QUIT: {
-						Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; normal quit&quot;));
-						serverNet-&gt;SendPlayerLeft(a, 1);
-						serverNet-&gt;Kill(a);
-						quit = true;
-						players[a].reset();
-						if (hostif)
-						{
-							hostif-&gt;SendPlayerLeft(a, 1);
-						}
-						break;
-					}
+		case NETMSG_QUIT: {
+			Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; normal quit&quot;));
+			Broadcast(CBaseNetProtocol::Get().SendPlayerLeft(a, 1));
+			players[a].reset();
+			if (hostif)
+			{
+				hostif-&gt;SendPlayerLeft(a, 1);
+			}
+			break;
+		}
 
-					case NETMSG_PLAYERNAME: {
-						unsigned playerNum = inbuf[2];
-						if(playerNum!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %playerNum));
-						} else {
-							players[playerNum]-&gt;name = (std::string)((char*)inbuf+3);
-							players[playerNum]-&gt;readyToStart = true;
-							Message(str(format(PlayerJoined) %players[playerNum]-&gt;name %playerNum));
-							serverNet-&gt;SendPlayerName(playerNum, players[playerNum]-&gt;name);
-							if (hostif)
-							{
-								hostif-&gt;SendPlayerJoined(playerNum, players[playerNum]-&gt;name);
-							}
-						}
-						break;
-					}
+		case NETMSG_PLAYERNAME: {
+			unsigned playerNum = inbuf[2];
+			if(playerNum!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %playerNum));
+			} else {
+				players[playerNum]-&gt;name = (std::string)((char*)inbuf+3);
+				players[playerNum]-&gt;readyToStart = true;
+				Message(str(format(PlayerJoined) %players[playerNum]-&gt;name %playerNum));
+				Broadcast(CBaseNetProtocol::Get().SendPlayerName(playerNum, players[playerNum]-&gt;name));
+				if (hostif)
+				{
+					hostif-&gt;SendPlayerJoined(playerNum, players[playerNum]-&gt;name);
+				}
+			}
+			break;
+		}
 
-					case NETMSG_CHAT: {
-						ChatMessage msg(packet);
-						if (static_cast&lt;unsigned&gt;(msg.fromPlayer) != a ) {
-							Warning(str(format(WrongPlayer) %(unsigned)NETMSG_CHAT %a %(unsigned)msg.fromPlayer));
-						} else {
-							GotChatMessage(msg);
-						}
-						break;
-					}
-					case NETMSG_SYSTEMMSG:
-						if(inbuf[2]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[2]));
-						} else {
-							serverNet-&gt;SendSystemMessage(inbuf[2], (char*)(&amp;inbuf[3]));
-						}
-						break;
+		case NETMSG_CHAT: {
+			ChatMessage msg(packet);
+			if (static_cast&lt;unsigned&gt;(msg.fromPlayer) != a ) {
+				Warning(str(format(WrongPlayer) %(unsigned)NETMSG_CHAT %a %(unsigned)msg.fromPlayer));
+			} else {
+				GotChatMessage(msg);
+			}
+			break;
+		}
+		case NETMSG_SYSTEMMSG:
+			if(inbuf[2]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[2]));
+			} else {
+				Broadcast(CBaseNetProtocol::Get().SendSystemMessage(inbuf[2], (char*)(&amp;inbuf[3])));
+			}
+			break;
 
-					case NETMSG_STARTPOS:
-						if(inbuf[1] != a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						}
-						else if (setup &amp;&amp; setup-&gt;startPosType == CGameSetupData::StartPos_ChooseInGame)
-						{
-							unsigned team = (unsigned)inbuf[2];
-							if (teams[team])
-							{
-								teams[team]-&gt;startpos = SFloat3(*((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]), *((float*)&amp;inbuf[12]));
-								teams[team]-&gt;readyToStart = static_cast&lt;bool&gt;(inbuf[3]);
-							}
-							serverNet-&gt;SendStartPos(inbuf[1],team, inbuf[3], *((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]), *((float*)&amp;inbuf[12])); //forward data
-							if (hostif)
-							{
-								hostif-&gt;SendPlayerReady(a, inbuf[3]);
-							}
-						}
-						else
-						{
-							Warning(str(format(NoStartposChange) %a));
-						}
-						break;
+		case NETMSG_STARTPOS:
+			if(inbuf[1] != a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			}
+			else if (setup &amp;&amp; setup-&gt;startPosType == CGameSetupData::StartPos_ChooseInGame)
+			{
+				unsigned team = (unsigned)inbuf[2];
+				if (teams[team])
+				{
+					teams[team]-&gt;startpos = SFloat3(*((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]), *((float*)&amp;inbuf[12]));
+					teams[team]-&gt;readyToStart = static_cast&lt;bool&gt;(inbuf[3]);
+				}
+				Broadcast(CBaseNetProtocol::Get().SendStartPos(inbuf[1],team, inbuf[3], *((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]), *((float*)&amp;inbuf[12]))); //forward data
+				if (hostif)
+				{
+					hostif-&gt;SendPlayerReady(a, inbuf[3]);
+				}
+			}
+			else
+			{
+				Warning(str(format(NoStartposChange) %a));
+			}
+			break;
 
-					case NETMSG_COMMAND:
-						if(inbuf[3]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
-						} else {
-							if (!demoReader)
-								serverNet-&gt;SendData(packet); //forward data
-						}
-						break;
+		case NETMSG_COMMAND:
+			if(inbuf[3]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
+			} else {
+				if (!demoReader)
+					Broadcast(packet); //forward data
+			}
+			break;
 
-					case NETMSG_SELECT:
-						if(inbuf[3]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
-						} else {
-							if (!demoReader)
-								serverNet-&gt;SendData(packet); //forward data
-						}
-						break;
+		case NETMSG_SELECT:
+			if(inbuf[3]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
+			} else {
+				if (!demoReader)
+					Broadcast(packet); //forward data
+			}
+			break;
 
+		case NETMSG_AICOMMAND: {
+			if (inbuf[3] != a) {
+				Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
+			}
+			else if (noHelperAIs) {
+				Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
+			}
+			else if (!demoReader) {
+				Broadcast(packet); //forward data
+			}
+		} break;
 
-					case NETMSG_AICOMMAND: {
-						if (inbuf[3] != a) {
-							Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
-						}
-						else if (noHelperAIs) {
-							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
-						}
-						else if (!demoReader) {
-							serverNet-&gt;SendData(packet); //forward data
-						}
-					} break;
+		case NETMSG_AICOMMANDS: {
+			if (inbuf[3] != a) {
+				Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
+			}
+			else if (noHelperAIs) {
+				Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
+			}
+			else if (!demoReader) {
+				Broadcast(packet); //forward data
+			}
+		} break;
 
-					case NETMSG_AICOMMANDS: {
-						if (inbuf[3] != a) {
-							Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
-						}
-						else if (noHelperAIs) {
-							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
-						}
-						else if (!demoReader) {
-							serverNet-&gt;SendData(packet); //forward data
-						}
-					} break;
+		case NETMSG_AISHARE: {
+			if (inbuf[3] != a) {
+				Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
+			} else if (noHelperAIs) {
+				Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
+			} else if (!demoReader) {
+				Broadcast(packet); //forward data
+			}
+		} break;
 
-					case NETMSG_AISHARE: {
-						if (inbuf[3] != a) {
-							Warning(str(format(WrongPlayer) %(unsigned) inbuf[0]  %a  %(unsigned) inbuf[3]));
-						} else if (noHelperAIs) {
-							Warning(str(format(NoHelperAI) %players[a]-&gt;name %a));
-						} else if (!demoReader) {
-							serverNet-&gt;SendData(packet); //forward data
-						}
-					} break;
+		case NETMSG_LUAMSG:
+			if(inbuf[3]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
+			}
+			else if (!demoReader) {
+				Broadcast(packet); //forward data
+			}
+			break;
 
-
-					case NETMSG_LUAMSG:
-						if(inbuf[3]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[3]));
-						}
-						else if (!demoReader) {
-							serverNet-&gt;SendData(packet); //forward data
-						}
-						break;
-
-					case NETMSG_SYNCRESPONSE:
+		case NETMSG_SYNCRESPONSE:
 #ifdef SYNCCHECK
-						if(inbuf[1]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							int frameNum = *(int*)&amp;inbuf[2];
-							if (outstandingSyncFrames.empty() || frameNum &gt;= outstandingSyncFrames.front())
-								players[a]-&gt;syncResponse[frameNum] = *(unsigned*)&amp;inbuf[6];
-							else if (serverframenum - delayedSyncResponseFrame &gt; SYNCCHECK_MSG_TIMEOUT) {
-								delayedSyncResponseFrame = serverframenum;
-								Warning(str(format(DelayedSyncResponse) %players[a]-&gt;name %frameNum %serverframenum));
-							}
+			if(inbuf[1]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				int frameNum = *(int*)&amp;inbuf[2];
+				if (outstandingSyncFrames.empty() || frameNum &gt;= outstandingSyncFrames.front())
+					players[a]-&gt;syncResponse[frameNum] = *(unsigned*)&amp;inbuf[6];
+				else if (serverframenum - delayedSyncResponseFrame &gt; SYNCCHECK_MSG_TIMEOUT) {
+					delayedSyncResponseFrame = serverframenum;
+					Warning(str(format(DelayedSyncResponse) %players[a]-&gt;name %frameNum %serverframenum));
+				}
 							// update players' ping (if !defined(SYNCCHECK) this is done in NETMSG_KEYFRAME)
-							players[a]-&gt;ping = serverframenum - frameNum;
-						}
+				players[a]-&gt;ping = serverframenum - frameNum;
+			}
 #endif
-						break;
+			break;
 
-					case NETMSG_SHARE:
-						if(inbuf[1]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							if (!demoReader)
-								serverNet-&gt;SendShare(inbuf[1], inbuf[2], inbuf[3], *((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8]));
-						}
-						break;
+		case NETMSG_SHARE:
+			if(inbuf[1]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				if (!demoReader)
+					Broadcast(CBaseNetProtocol::Get().SendShare(inbuf[1], inbuf[2], inbuf[3], *((float*)&amp;inbuf[4]), *((float*)&amp;inbuf[8])));
+			}
+			break;
 
-					case NETMSG_SETSHARE:
-						if(inbuf[1]!= a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							if (!demoReader)
-								serverNet-&gt;SendSetShare(inbuf[1], inbuf[2], *((float*)&amp;inbuf[3]), *((float*)&amp;inbuf[7]));
-						}
-						break;
+		case NETMSG_SETSHARE:
+			if(inbuf[1]!= a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				if (!demoReader)
+					Broadcast(CBaseNetProtocol::Get().SendSetShare(inbuf[1], inbuf[2], *((float*)&amp;inbuf[3]), *((float*)&amp;inbuf[7])));
+			}
+			break;
 
-					case NETMSG_PLAYERSTAT:
-						if(inbuf[1]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							serverNet-&gt;SendData(packet); //forward data
-						}
-						break;
+		case NETMSG_PLAYERSTAT:
+			if(inbuf[1]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				Broadcast(packet); //forward data
+			}
+			break;
 
-					case NETMSG_MAPDRAW:
-						serverNet-&gt;SendData(packet); //forward data
-						break;
+		case NETMSG_MAPDRAW:
+			Broadcast(packet); //forward data
+			break;
 
 #ifdef DIRECT_CONTROL_ALLOWED
-					case NETMSG_DIRECT_CONTROL:
-						if(inbuf[1]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							if (!demoReader)
-								serverNet-&gt;SendDirectControl(inbuf[1]);
-						}
-						break;
+		case NETMSG_DIRECT_CONTROL:
+			if(inbuf[1]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				if (!demoReader)
+					Broadcast(CBaseNetProtocol::Get().SendDirectControl(inbuf[1]));
+			}
+			break;
 
-					case NETMSG_DC_UPDATE:
-						if(inbuf[1]!=a){
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
-						} else {
-							if (!demoReader)
-								serverNet-&gt;SendDirectControlUpdate(inbuf[1], inbuf[2], *((short*)&amp;inbuf[3]), *((short*)&amp;inbuf[5]));
-						}
-						break;
+		case NETMSG_DC_UPDATE:
+			if(inbuf[1]!=a){
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)inbuf[1]));
+			} else {
+				if (!demoReader)
+					Broadcast(CBaseNetProtocol::Get().SendDirectControlUpdate(inbuf[1], inbuf[2], *((short*)&amp;inbuf[3]), *((short*)&amp;inbuf[5])));
+			}
+			break;
 #endif
 
-					case NETMSG_STARTPLAYING:
-					{
-						if (players[a]-&gt;hasRights &amp;&amp; !gameStartTime)
-							CheckForGameStart(true);
-						break;
-					}
-					case NETMSG_TEAM:
-					{
+		case NETMSG_STARTPLAYING:
+		{
+			if (players[a]-&gt;isLocal &amp;&amp; !gameStartTime)
+				CheckForGameStart(true);
+			break;
+		}
+		case NETMSG_TEAM:
+		{
 						//TODO update players[] and teams[] and send to hostif
-						const unsigned player = (unsigned)inbuf[1];
-						if (player != a)
+			const unsigned player = (unsigned)inbuf[1];
+			if (player != a)
+			{
+				Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)player));
+			}
+			else
+			{
+				const unsigned action = inbuf[2];
+				const unsigned fromTeam = players[player]-&gt;team;
+				unsigned numPlayersInTeam = 0;
+				for (int a = 0; a &lt; MAX_PLAYERS; ++a)
+					if (players[a] &amp;&amp; players[a]-&gt;team == fromTeam)
+						++numPlayersInTeam;
+							
+				switch (action)
+				{
+					case TEAMMSG_SELFD: {
+						Broadcast(CBaseNetProtocol::Get().SendSelfD(player));
+						if (numPlayersInTeam &lt;= 1 &amp;&amp; teams[fromTeam])
 						{
-							Warning(str(format(WrongPlayer) %(unsigned)inbuf[0] %a %(unsigned)player));
+							teams[fromTeam].reset();
 						}
-						else
+						players[player]-&gt;team = 0;
+						break;
+					}
+					case TEAMMSG_GIVEAWAY: {
+						const unsigned toTeam = inbuf[3];
+						Broadcast(CBaseNetProtocol::Get().SendGiveAwayEverything(player, toTeam));
+						if (numPlayersInTeam &lt;= 1 &amp;&amp; teams[fromTeam])
 						{
-							const unsigned action = inbuf[2];
-							const unsigned fromTeam = players[player]-&gt;team;
-							unsigned numPlayersInTeam = 0;
-							for (int a = 0; a &lt; MAX_PLAYERS; ++a)
-								if (players[a] &amp;&amp; players[a]-&gt;team == fromTeam)
-									++numPlayersInTeam;
-							
-							switch (action)
-							{
-								case TEAMMSG_SELFD: {
-									serverNet-&gt;SendSelfD(player);
-									if (numPlayersInTeam &lt;= 1 &amp;&amp; teams[fromTeam])
-									{
-										teams[fromTeam].reset();
-									}
-									players[player]-&gt;team = 0;
-									break;
-								}
-								case TEAMMSG_GIVEAWAY: {
-									const unsigned toTeam = inbuf[3];
-									serverNet-&gt;SendGiveAwayEverything(player, toTeam);
-									if (numPlayersInTeam &lt;= 1 &amp;&amp; teams[fromTeam])
-									{
-										teams[fromTeam].reset();
-									}
-									players[player]-&gt;team = 0;
-									break;
-								}
-								case TEAMMSG_RESIGN: {
-									serverNet-&gt;SendResign(player);
-									players[player]-&gt;team = 0;
-									break;
-								}
-								case TEAMMSG_JOIN_TEAM: {
-									unsigned newTeam = inbuf[3];
-									if (cheating)
-									{
-										serverNet-&gt;SendJoinTeam(player, newTeam);
-										players[player]-&gt;team = newTeam;
-										if (!teams[newTeam])
-											teams[newTeam].reset(new GameTeam);
-									}
-									else
-									{
-										Warning(str(format(NoTeamChange) %players[player]-&gt;name %player));
-									}
-									break;
-								}
-								case TEAMMSG_TEAM_DIED: {
-									// don't send to clients, they don't need it
-									unsigned char team = inbuf[3];
-									if (teams[team] &amp;&amp; players[player]-&gt;hasRights) // currently only host is allowed
-									{
-										teams[fromTeam].reset();
-										for (int i = 0; i &lt; MAX_PLAYERS; ++i)
-										{
-											if (players[i] &amp;&amp; players[i]-&gt;team == team)
-											{
-												players[i]-&gt;team = 0;
-											}
-										}
-									}
-									break;
-								}
-								default: {
-									Warning(str(format(UnknownTeammsg) %action %player));
-								}
-							}
-							break;
+							teams[fromTeam].reset();
 						}
+						players[player]-&gt;team = 0;
+						break;
 					}
-					case NETMSG_ALLIANCE: {
-						const unsigned char player = inbuf[1];
-						const unsigned char whichAllyTeam = inbuf[2];
-						const unsigned char allied = inbuf[3];
-						if (setup &amp;&amp; !setup-&gt;fixedAllies)
+					case TEAMMSG_RESIGN: {
+						Broadcast(CBaseNetProtocol::Get().SendResign(player));
+						players[player]-&gt;team = 0;
+						break;
+					}
+					case TEAMMSG_JOIN_TEAM: {
+						unsigned newTeam = inbuf[3];
+						if (cheating)
 						{
-							serverNet-&gt;SendSetAllied(player, whichAllyTeam, allied);
+							Broadcast(CBaseNetProtocol::Get().SendJoinTeam(player, newTeam));
+							players[player]-&gt;team = newTeam;
+							if (!teams[newTeam])
+								teams[newTeam].reset(new GameTeam);
 						}
 						else
-						{ // not allowed
+						{
+							Warning(str(format(NoTeamChange) %players[player]-&gt;name %player));
 						}
 						break;
 					}
-					case NETMSG_CCOMMAND: {
-						CommandMessage msg(packet);
-						if (static_cast&lt;unsigned&gt;(msg.player) == a)
+					case TEAMMSG_TEAM_DIED: {
+									// don't send to clients, they don't need it
+						unsigned char team = inbuf[3];
+						if (teams[team] &amp;&amp; players[player]-&gt;isLocal) // currently only host is allowed
 						{
-							if ((commandBlacklist.find(msg.action.command) != commandBlacklist.end()) &amp;&amp; players[a]-&gt;hasRights)
+							teams[fromTeam].reset();
+							for (int i = 0; i &lt; MAX_PLAYERS; ++i)
 							{
-								// command is restricted to server but player is allowed to execute it
-								PushAction(msg.action);
+								if (players[i] &amp;&amp; players[i]-&gt;team == team)
+								{
+									players[i]-&gt;team = 0;
+								}
 							}
-							else if (commandBlacklist.find(msg.action.command) == commandBlacklist.end())
-							{
-								// command is save
-								serverNet-&gt;SendData(msg.Pack());
-							}
-							else
-							{
-								// hack!
-								Warning(str(boost::format(CommandNotAllowed) %msg.player %msg.action.command.c_str()));
-							}
 						}
 						break;
 					}
-
-					// CGameServer should never get these messages
-					case NETMSG_GAMEID:
-					case NETMSG_INTERNAL_SPEED:
-					case NETMSG_ATTEMPTCONNECT:
-					case NETMSG_GAMEDATA:
-					case NETMSG_RANDSEED:
-						break;
-					default:
-						{
-							Warning(str(format(UnknownNetmsg) %(unsigned)inbuf[0] %a));
-						}
-						break;
+					default: {
+						Warning(str(format(UnknownTeammsg) %action %player));
+					}
 				}
+				break;
 			}
 		}
-		else if (players[a])
-		{
-			Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;)); //this must happen BEFORE the reset!
-			players[a].reset();
-			serverNet-&gt;SendPlayerLeft(a, 0);
-			if (hostif)
+		case NETMSG_ALLIANCE: {
+			const unsigned char player = inbuf[1];
+			const unsigned char whichAllyTeam = inbuf[2];
+			const unsigned char allied = inbuf[3];
+			if (setup &amp;&amp; !setup-&gt;fixedAllies)
 			{
-				hostif-&gt;SendPlayerLeft(a, 0);
+				Broadcast(CBaseNetProtocol::Get().SendSetAllied(player, whichAllyTeam, allied));
 			}
+			else
+			{ // not allowed
+			}
+			break;
 		}
+		case NETMSG_CCOMMAND: {
+			CommandMessage msg(packet);
+			if (static_cast&lt;unsigned&gt;(msg.player) == a)
+			{
+				if ((commandBlacklist.find(msg.action.command) != commandBlacklist.end()) &amp;&amp; players[a]-&gt;isLocal)
+				{
+								// command is restricted to server but player is allowed to execute it
+					PushAction(msg.action);
+				}
+				else if (commandBlacklist.find(msg.action.command) == commandBlacklist.end())
+				{
+								// command is save
+					Broadcast(packet);
+				}
+				else
+				{
+								// hack!
+					Warning(str(boost::format(CommandNotAllowed) %msg.player %msg.action.command.c_str()));
+				}
+			}
+			break;
+		}
+
+					// CGameServer should never get these messages
+		case NETMSG_GAMEID:
+		case NETMSG_INTERNAL_SPEED:
+		case NETMSG_ATTEMPTCONNECT:
+		case NETMSG_GAMEDATA:
+		case NETMSG_RANDSEED:
+#ifdef DEBUG
+			Warning(str(format(UnknownNetmsg) %(unsigned)inbuf[0] %a));
+#endif
+			break;
+		default:
+		{
+			Warning(str(format(UnknownNetmsg) %(unsigned)inbuf[0] %a));
+		}
+		break;
 	}
+}
 
-	for (int a = (serverNet-&gt;MaxConnectionID() + 1); a &lt; MAX_PLAYERS; ++a)
+void CGameServer::ServerReadNet()
+{
+	// handle new connections
+	while (UDPNet &amp;&amp; UDPNet-&gt;HasIncomingConnections())
 	{
-		//HACK check if we lost connection to the last player(s)
+		boost::shared_ptr&lt;netcode::UDPConnection&gt; prev = UDPNet-&gt;PreviewConnection().lock();
+		boost::shared_ptr&lt;const RawPacket&gt; packet = prev-&gt;GetData();
+		
+		if (packet &amp;&amp; packet-&gt;length &gt;= 3 &amp;&amp; packet-&gt;data[0] == NETMSG_ATTEMPTCONNECT &amp;&amp; packet-&gt;data[2] == NETWORK_VERSION)
+		{
+			const unsigned wantedNumber = packet-&gt;data[1];
+			BindConnection(wantedNumber, false, UDPNet-&gt;AcceptConnection());
+		}
+		else
+		{
+			if (packet &amp;&amp; packet-&gt;length &gt;= 3) {
+				Warning(str(format(ConnectionReject) %packet-&gt;data[0] %packet-&gt;data[2] %packet-&gt;length));
+			}
+			else {
+				Warning(&quot;Connection attempt rejected: Packet too short&quot;);
+			}
+			UDPNet-&gt;RejectConnection();
+		}
+	}
+
+	for(unsigned a=0; (int)a &lt; MAX_PLAYERS; a++)
+	{
 		if (players[a])
 		{
-			Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;)); //this must happen BEFORE the reset!
-			players[a].reset();
-			serverNet-&gt;SendPlayerLeft(a, 0);
-			if (hostif)
+			if (players[a]-&gt;link-&gt;CheckTimeout())
 			{
-				hostif-&gt;SendPlayerLeft(a, 0);
+				Message(str(format(PlayerLeft) %players[a]-&gt;name %&quot; timeout&quot;)); //this must happen BEFORE the reset!
+				players[a].reset();
+				Broadcast(CBaseNetProtocol::Get().SendPlayerLeft(a, 0));
+				if (hostif)
+				{
+					hostif-&gt;SendPlayerLeft(a, 0);
+				}
+				continue;
 			}
+			
+			boost::shared_ptr&lt;const RawPacket&gt; packet;
+			while (players[a] &amp;&amp; (packet = players[a]-&gt;link-&gt;GetData()))
+			{
+				ProcessPacket(a, packet);
+			}
 		}
 	}
 
@@ -944,7 +948,7 @@
 	entropy.Update(lastTick);
 	gameID.intArray[3] = entropy.GetDigest();
 
-	serverNet-&gt;SendGameID(gameID.charArray);
+	Broadcast(CBaseNetProtocol::Get().SendGameID(gameID.charArray));
 }
 
 void CGameServer::CheckForGameStart(bool forced)
@@ -993,7 +997,7 @@
 		if (readyTime == 0) {
 			readyTime = SDL_GetTicks();
 			rng.Seed(readyTime);
-			serverNet-&gt;SendStartPlaying(GameStartDelay);
+			Broadcast(CBaseNetProtocol::Get().SendStartPlaying(GameStartDelay));
 		}
 	}
 	if (readyTime &amp;&amp; (SDL_GetTicks() - readyTime) &gt; GameStartDelay)
@@ -1005,22 +1009,24 @@
 void CGameServer::StartGame()
 {
 	gameStartTime = SDL_GetTicks();
-	serverNet-&gt;Listening(false);
+	
+	if (UDPNet)
+		UDPNet-&gt;Listen(false); // don't accept new connections
 
 	for(int a=0; a &lt; MAX_PLAYERS; ++a) {
 		if(players[a])
-			serverNet-&gt;SendPlayerName(a, players[a]-&gt;name);
+			Broadcast(CBaseNetProtocol::Get().SendPlayerName(a, players[a]-&gt;name));
 	}
 
 	// make sure initial game speed is within allowed range and sent a new speed if not
 	if(userSpeedFactor&gt;maxUserSpeed)
 	{
-		serverNet-&gt;SendUserSpeed(SERVER_PLAYER, maxUserSpeed);
+		Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, maxUserSpeed));
 		userSpeedFactor = maxUserSpeed;
 	}
 	else if(userSpeedFactor&lt;minUserSpeed)
 	{
-		serverNet-&gt;SendUserSpeed(SERVER_PLAYER, minUserSpeed);
+		Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, minUserSpeed));
 		userSpeedFactor = minUserSpeed;
 	}
 
@@ -1036,14 +1042,14 @@
 		for (int a = 0; a &lt; setup-&gt;numTeams; ++a)
 		{
 			if (teams[a]) // its a player
-				serverNet-&gt;SendStartPos(SERVER_PLAYER, a, 1, teams[a]-&gt;startpos.x, teams[a]-&gt;startpos.y, teams[a]-&gt;startpos.z);
+				Broadcast(CBaseNetProtocol::Get().SendStartPos(SERVER_PLAYER, a, 1, teams[a]-&gt;startpos.x, teams[a]-&gt;startpos.y, teams[a]-&gt;startpos.z));
 			else // maybe an AI?
-				serverNet-&gt;SendStartPos(SERVER_PLAYER, a, 1, setup-&gt;startPos[a].x, setup-&gt;startPos[a].y, setup-&gt;startPos[a].z);
+				Broadcast(CBaseNetProtocol::Get().SendStartPos(SERVER_PLAYER, a, 1, setup-&gt;startPos[a].x, setup-&gt;startPos[a].y, setup-&gt;startPos[a].z));
 		}
 	}
 
-	serverNet-&gt;SendRandSeed(rng());
-	serverNet-&gt;SendStartPlaying(0);
+	Broadcast(CBaseNetProtocol::Get().SendRandSeed(rng()));
+	Broadcast(CBaseNetProtocol::Get().SendStartPlaying(0));
 	if (hostif)
 	{
 		hostif-&gt;SendStartPlaying();
@@ -1097,16 +1103,16 @@
 		SetBoolArg(noHelperAIs, action.extra);
 		// sent it because clients have to do stuff when this changes
 		CommandMessage msg(action, SERVER_PLAYER);
-		serverNet-&gt;SendData(msg.Pack());
+		Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(msg.Pack()));
 	}
 	else if (action.command == &quot;setmaxspeed&quot;)
 	{
 		maxUserSpeed = atof(action.extra.c_str());
 		if (userSpeedFactor &gt; maxUserSpeed) {
-			serverNet-&gt;SendUserSpeed(SERVER_PLAYER, maxUserSpeed);
+			Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, maxUserSpeed));
 			userSpeedFactor = maxUserSpeed;
 			if (internalSpeed &gt; maxUserSpeed) {
-				serverNet-&gt;SendInternalSpeed(userSpeedFactor);
+				Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(userSpeedFactor));
 				internalSpeed = userSpeedFactor;
 			}
 		}
@@ -1115,10 +1121,10 @@
 	{
 		minUserSpeed = atof(action.extra.c_str());
 		if (userSpeedFactor &lt; minUserSpeed) {
-			serverNet-&gt;SendUserSpeed(SERVER_PLAYER, minUserSpeed);
+			Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, minUserSpeed));
 			userSpeedFactor = minUserSpeed;
 			if (internalSpeed &lt; minUserSpeed) {
-				serverNet-&gt;SendInternalSpeed(userSpeedFactor);
+				Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(userSpeedFactor));
 				internalSpeed = userSpeedFactor;
 			}
 		}
@@ -1149,7 +1155,7 @@
 	{
 		SetBoolArg(cheating, action.extra);
 		CommandMessage msg(action, SERVER_PLAYER);
-		serverNet-&gt;SendData(msg.Pack());
+		Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(msg.Pack()));
 	}
 	else if (action.command == &quot;singlestep&quot;)
 	{
@@ -1160,7 +1166,7 @@
 	{
 		// only forward to players (send over network)
 		CommandMessage msg(action, SERVER_PLAYER);
-		serverNet-&gt;SendData(msg.Pack());
+		Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(msg.Pack()));
 	}
 }
 
@@ -1175,7 +1181,7 @@
 	if (gameEndTime &gt; 0) {
 		if (gameEndTime &lt; SDL_GetTicks() - 2000) {
 			Message(GameEnd);
-			serverNet-&gt;SendGameOver();
+			Broadcast(CBaseNetProtocol::Get().SendGameOver());
 			if (hostif) {
 				hostif-&gt;SendGameOver();
 			}
@@ -1192,8 +1198,8 @@
 	for (unsigned a = 0; (int)a &lt; gs-&gt;activeTeams; ++a)
 	{
 		bool hasPlayer = false;
-		for (int b = 0; b &lt; gs-&gt;activePlayers; ++b) {
-			if (gs-&gt;players[b]-&gt;active &amp;&amp; gs-&gt;players[b]-&gt;team==a &amp;&amp; !gs-&gt;players[b]-&gt;spectator) {
+		for (unsigned b = 0; b &lt; static_cast&lt;unsigned&gt;(gs-&gt;activePlayers); ++b) {
+			if (gs-&gt;players[b]-&gt;active &amp;&amp; gs-&gt;players[b]-&gt;team == static_cast&lt;int&gt;(a) &amp;&amp; !gs-&gt;players[b]-&gt;spectator) {
 				hasPlayer = true;
 			}
 		}
@@ -1226,7 +1232,7 @@
 	if (numActiveAllyTeams &lt;= 1)
 	{
 		gameEndTime=SDL_GetTicks();
-		serverNet-&gt;SendSendPlayerStat();
+		Broadcast(CBaseNetProtocol::Get().SendSendPlayerStat());
 	}
 }
 
@@ -1275,9 +1281,9 @@
 			++serverframenum;
 			//Send out new frame messages.
 			if (0 == (serverframenum % serverKeyframeIntervall))
-				serverNet-&gt;SendKeyFrame(serverframenum);
+				Broadcast(CBaseNetProtocol::Get().SendKeyFrame(serverframenum));
 			else
-				serverNet-&gt;SendNewFrame();
+				Broadcast(CBaseNetProtocol::Get().SendNewFrame());
 #ifdef SYNCCHECK
 			outstandingSyncFrames.push_back(serverframenum);
 #endif
@@ -1289,17 +1295,31 @@
 {
 	while (!quitServer)
 	{
+		bool hasData = false;
+		if (hasLocalClient)
 		{
-			boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
-			Update();
+			SDL_Delay(10); // don't take 100% cpu time
+			hasData = true;
 		}
-		SDL_Delay(10);
+		else
+		{
+			assert(UDPNet);
+			hasData = UDPNet-&gt;HasIncomingData(10); // may block up to 10 ms if there is no data (don't need a lock)
+		}
+		
+		if (UDPNet)
+			UDPNet-&gt;Update();
+		
+		boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
+		if (hasData)
+			ServerReadNet(); // new data arrived, we may have new packets
+		Update();
 	}
 }
 
 bool CGameServer::WaitsOnCon() const
 {
-	return serverNet-&gt;Listening();
+	return (UDPNet &amp;&amp; UDPNet-&gt;Listen());
 }
 
 bool CGameServer::GameHasStarted() const
@@ -1311,9 +1331,8 @@
 {
 	if (players[playerNum]) {
 		Message(str(format(PlayerLeft) %playerNum %&quot;kicked&quot;));
-		serverNet-&gt;SendPlayerLeft(playerNum, 2);
-		serverNet-&gt;SendQuit(playerNum);
-		serverNet-&gt;Kill(playerNum);
+		Broadcast(CBaseNetProtocol::Get().SendPlayerLeft(playerNum, 2));
+		Broadcast(CBaseNetProtocol::Get().SendQuit());
 		if (hostif)
 		{
 			hostif-&gt;SendPlayerLeft(playerNum, 2);
@@ -1322,25 +1341,34 @@
 	}
 }
 
-void CGameServer::BindConnection(unsigned wantedNumber)
+unsigned CGameServer::BindConnection(unsigned wantedNumber, bool isLocal, boost::shared_ptr&lt;netcode::CConnection&gt; link)
 {
 	unsigned hisNewNumber = wantedNumber;
 	if (demoReader) {
 		hisNewNumber = std::max(wantedNumber, (unsigned)demoReader-&gt;GetFileHeader().maxPlayerNum+1);
 	}
-	hisNewNumber = serverNet-&gt;AcceptIncomingConnection(hisNewNumber);
+	if (players[hisNewNumber])
+	{
+		for (unsigned p = 0; p &lt; static_cast&lt;unsigned&gt;(MAX_PLAYERS); ++p)
+		{
+			if (!players[p])
+			{
+				hisNewNumber = p;
+				break;
+			}
+		}
+	}
 
-	serverNet-&gt;SendSetPlayerNum((unsigned char)hisNewNumber, (unsigned char)hisNewNumber);
-	serverNet-&gt;SendData(gameData-&gt;Pack(), hisNewNumber);
+	players[hisNewNumber].reset(new GameParticipant(isLocal)); // give him rights to change speed, kick players etc
+	players[hisNewNumber]-&gt;link = link;
+	link-&gt;SendData(CBaseNetProtocol::Get().SendSetPlayerNum((unsigned char)hisNewNumber));
+	link-&gt;SendData(boost::shared_ptr&lt;const RawPacket&gt;(gameData-&gt;Pack()));
 
 	for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
 		if(players[a] &amp;&amp; players[a]-&gt;readyToStart)
-			serverNet-&gt;SendPlayerName(a, players[a]-&gt;name);
+			Broadcast(CBaseNetProtocol::Get().SendPlayerName(a, players[a]-&gt;name));
 	}
 
-	// is this is the local player (== host) then he can kick, set options etc.
-	bool grantRights = setup ? (hisNewNumber == (unsigned)setup-&gt;myPlayerNum) : (wantedNumber == 0);
-	players[hisNewNumber].reset(new GameParticipant(grantRights)); // give him rights to change speed, kick players etc
 	if (setup)
 	{
 		unsigned hisTeam = setup-&gt;playerStartingTeam[hisNewNumber];
@@ -1352,11 +1380,11 @@
 			teams[hisTeam]-&gt;allyTeam = setup-&gt;teamAllyteam[hisTeam];
 		}
 		players[hisNewNumber]-&gt;team = hisTeam;
-		serverNet-&gt;SendJoinTeam(hisNewNumber, hisTeam);
+		Broadcast(CBaseNetProtocol::Get().SendJoinTeam(hisNewNumber, hisTeam));
 		for (int a = 0; a &lt; MAX_TEAMS; ++a)
 		{
 			if (teams[a])
-				serverNet-&gt;SendStartPos(SERVER_PLAYER, a, 1, teams[a]-&gt;startpos.x, teams[a]-&gt;startpos.y, teams[a]-&gt;startpos.z);
+				Broadcast(CBaseNetProtocol::Get().SendStartPos(SERVER_PLAYER, a, 1, teams[a]-&gt;startpos.x, teams[a]-&gt;startpos.y, teams[a]-&gt;startpos.z));
 		}
 	}
 	else
@@ -1366,22 +1394,23 @@
 		{
 			teams[hisTeam].reset(new GameTeam());
 			players[hisNewNumber]-&gt;team = hisTeam;
-			serverNet-&gt;SendJoinTeam(hisNewNumber, hisTeam);
+			Broadcast(CBaseNetProtocol::Get().SendJoinTeam(hisNewNumber, hisTeam));
 			for (int a = 0; a &lt; MAX_TEAMS; ++a)
 			{
 				if (teams[a] &amp;&amp; a != (int)hisNewNumber)
-					serverNet-&gt;SendJoinTeam(a, players[a]-&gt;team);
+					Broadcast(CBaseNetProtocol::Get().SendJoinTeam(a, players[a]-&gt;team));
 			}
 		}
 	}
 	Message(str(format(NewConnection) %hisNewNumber %wantedNumber));
 
-	serverNet-&gt;FlushNet(hisNewNumber);
+	link-&gt;Flush(true);
+	return hisNewNumber;
 }
 
 void CGameServer::GotChatMessage(const ChatMessage&amp; msg)
 {
-	serverNet-&gt;SendData(msg.Pack());
+	Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(msg.Pack()));
 	if (hostif &amp;&amp; static_cast&lt;unsigned&gt;(msg.fromPlayer) != SERVER_PLAYER) {
 		// don't echo packets to autohost
 		hostif-&gt;SendPlayerChat(msg.fromPlayer, msg.msg);

Modified: branches/gml/rts/Game/GameServer.h
===================================================================
--- branches/gml/rts/Game/GameServer.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/GameServer.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -16,6 +16,12 @@
 #include &quot;SFloat3.h&quot;
 
 class CBaseNetProtocol;
+namespace netcode
+{
+	class RawPacket;
+	class CConnection;
+	class UDPListener;
+}
 class CDemoReader;
 class AutohostInterface;
 class CGameSetupData;
@@ -23,6 +29,7 @@
 
 const unsigned SERVER_PLAYER = 255; //server generated message which needs a playernumber
 
+
 //TODO: move to seperate file
 class GameParticipant
 {
@@ -36,7 +43,8 @@
 	
 	unsigned team;
 
-	bool hasRights;
+	bool isLocal;
+	boost::shared_ptr&lt;netcode::CConnection&gt; link;
 #ifdef SYNCCHECK
 	std::map&lt;int, unsigned&gt; syncResponse; // syncResponse[frameNum] = checksum
 #endif
@@ -58,10 +66,10 @@
 {
 	friend class CLoadSaveHandler;     //For initialize server state after load
 public:
-	CGameServer(int port, const GameData* const gameData, const CGameSetupData* const setup, const std::string&amp; demoName = &quot;&quot;);
+	CGameServer(int port, bool onlyLocal, const GameData* const gameData, const CGameSetupData* const setup, const std::string&amp; demoName = &quot;&quot;);
 	virtual ~CGameServer();
 
-	void AddLocalClient();
+	void AddLocalClient(unsigned wantedNumber);
 
 	void AddAutohostInterface(const int remotePort);
 
@@ -101,12 +109,13 @@
 	*/
 	void KickPlayer(const int playerNum);
 
-	void BindConnection(unsigned wantedNumber);
+	unsigned BindConnection(unsigned wantedNumber, bool isLocal, boost::shared_ptr&lt;netcode::CConnection&gt; link);
 
 	void CheckForGameStart(bool forced=false);
 	void StartGame();
 	void UpdateLoop();
 	void Update();
+	void ProcessPacket(const unsigned playernum, boost::shared_ptr&lt;const netcode::RawPacket&gt; packet);
 	void CheckSync();
 	void ServerReadNet();
 	void CheckForGameEnd();
@@ -117,6 +126,8 @@
 	/// read data from demo and send it to clients
 	void SendDemoData(const bool skipping=false);
 	
+	void Broadcast(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet);
+	
 	/**
 	@brief skip frames
 	
@@ -174,13 +185,17 @@
 	int delayedSyncResponseFrame;
 
 	///////////////// internal stuff //////////////////
+	
+	bool hasLocalClient;
+	unsigned localClientNumber;
+	
 	void RestrictedAction(const std::string&amp; action);
 	
 	/// If the server recieves a command, it will forward it to clients if it is not in this set
 	std::set&lt;std::string&gt; commandBlacklist;
-	CBaseNetProtocol* serverNet;
-	CDemoReader* demoReader;
-	AutohostInterface* hostif;
+	boost::scoped_ptr&lt;netcode::UDPListener&gt; UDPNet;
+	boost::scoped_ptr&lt;CDemoReader&gt; demoReader;
+	boost::scoped_ptr&lt;AutohostInterface&gt; hostif;
 	UnsyncedRNG rng;
 	boost::thread* thread;
 	mutable boost::recursive_mutex gameServerMutex;

Modified: branches/gml/rts/Game/GameSetup.cpp
===================================================================
--- branches/gml/rts/Game/GameSetup.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/GameSetup.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -13,7 +13,7 @@
 #include &quot;Lua/LuaGaia.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
-#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Rendering/Textures/TAPalette.h&quot;
 #include &quot;System/UnsyncedRNG.h&quot;
@@ -78,17 +78,13 @@
  */
 void CGameSetup::LoadStartPositionsFromMap()
 {
-	TdfParser p2;
-	CMapInfo::OpenTDF (mapName, p2);
+	MapParser mapParser(mapName);
 
-	for(int a=0;a&lt;numTeams;++a){
-		float x,z;
-		char teamName[20];
-		sprintf(teamName, &quot;TEAM%i&quot;, teamStartNum[a]);
-		p2.GetDef(x, &quot;1000&quot;, string(&quot;MAP\\&quot;) + teamName + &quot;\\StartPosX&quot;);
-		p2.GetDef(z, &quot;1000&quot;, string(&quot;MAP\\&quot;) + teamName + &quot;\\StartPosZ&quot;);
-		gs-&gt;Team(a)-&gt;startPos = float3(x, 100, z);
-		startPos[a] = SFloat3(x, 100, z);
+	for(int a = 0; a &lt; numTeams; ++a) {
+		float3 pos(1000.0f, 100.0f, 1000.0f);
+		mapParser.GetStartPos(a, pos);
+		gs-&gt;Team(a)-&gt;startPos = pos;
+		startPos[a] = SFloat3(pos.x, pos.y, pos.z);
 	}
 }
 
@@ -121,8 +117,7 @@
 
 	// Show that we havent selected start pos yet
 	if (startPosType == StartPos_ChooseInGame) {
-		for (int a = 0; a &lt; numTeams; ++a)
-		{
+		for (int a = 0; a &lt; numTeams; ++a) {
 			gs-&gt;Team(a)-&gt;startPos.y = -500;
 			startPos[a].y = -500;
 		}
@@ -289,8 +284,9 @@
 		++i;
 	}
 
-	if (allyteamRemap.size() != numAllyTeams)
+	if (allyteamRemap.size() != numAllyTeams) {
 		throw content_error(&quot;incorrect number of allyteams in GameSetup script&quot;);
+	}
 }
 
 /** @brief Update all player indices to refer to the right player. */
@@ -298,14 +294,16 @@
 {
 	// relocate Team.TeamLeader field
 	for (int a = 0; a &lt; numTeams; ++a) {
-		if (playerRemap.find(gs-&gt;Team(a)-&gt;leader) == playerRemap.end())
+		if (playerRemap.find(gs-&gt;Team(a)-&gt;leader) == playerRemap.end()) {
 			throw content_error(&quot;invalid Team.TeamLeader in GameSetup script&quot;);
+		};
 		gs-&gt;Team(a)-&gt;leader = playerRemap[gs-&gt;Team(a)-&gt;leader];
 	}
 
 	// relocate myPlayerNum
-	if (playerRemap.find(myPlayerNum) == playerRemap.end())
+	if (playerRemap.find(myPlayerNum) == playerRemap.end()) {
 		throw content_error(&quot;invalid MyPlayerNum in GameSetup script&quot;);
+	}
 	myPlayerNum = playerRemap[myPlayerNum];
 }
 
@@ -326,8 +324,9 @@
 {
 	// relocate Team.Allyteam field
 	for (int a = 0; a &lt; numTeams; ++a) {
-		if (allyteamRemap.find(gs-&gt;AllyTeam(a)) == allyteamRemap.end())
+		if (allyteamRemap.find(gs-&gt;AllyTeam(a)) == allyteamRemap.end()) {
 			throw content_error(&quot;invalid Team.Allyteam in GameSetup script&quot;);
+		}
 		gs-&gt;SetAllyTeam(a, allyteamRemap[gs-&gt;AllyTeam(a)]);
 		teamAllyteam[a] = allyteamRemap[teamAllyteam[a]];
 	}

Modified: branches/gml/rts/Game/GameSetupData.h
===================================================================
--- branches/gml/rts/Game/GameSetupData.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/GameSetupData.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -7,7 +7,6 @@
 #include &quot;SFloat3.h&quot;
 #include &quot;GlobalStuff.h&quot;
 
-class TdfParser;
 
 class CGameSetupData
 {

Modified: branches/gml/rts/Game/PreGame.cpp
===================================================================
--- branches/gml/rts/Game/PreGame.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/PreGame.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -13,6 +13,7 @@
 #include &quot;GameSetup.h&quot;
 #include &quot;GameData.h&quot;
 #include &quot;NetProtocol.h&quot;
+#include &quot;Net/RawPacket.h&quot;
 #include &quot;DemoRecorder.h&quot;
 #include &quot;DemoReader.h&quot;
 #include &quot;LoadSaveHandler.h&quot;
@@ -21,6 +22,8 @@
 #include &quot;FileSystem/VFSHandler.h&quot;
 #include &quot;Lua/LuaGaia.h&quot;
 #include &quot;Lua/LuaRules.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Platform/Clipboard.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
@@ -31,13 +34,11 @@
 #include &quot;StartScripts/ScriptHandler.h&quot;
 #include &quot;UI/InfoConsole.h&quot;
 #include &quot;UI/MouseHandler.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;mmgr.h&quot;
 
 // msvc behaves really strange
 #if _MSC_VER
 namespace std {
-	using ::cos;
 	using ::sin;
 }
 #endif
@@ -45,6 +46,7 @@
 const int springDefaultPort = 8452;
 
 CPreGame* pregame=0;
+using netcode::RawPacket;
 
 extern Uint8 *keys;
 extern bool globalQuit;
@@ -59,8 +61,8 @@
   state(UNKNOWN),
   hasDemo(!demo.empty()),
   hasSave(!save.empty()),
-  savefile(NULL),
-  gameData(0)
+  gameData(0),
+  savefile(NULL)
 {
 	demoFile = gameSetup? gameSetup-&gt;demoName : demo;
 
@@ -366,14 +368,14 @@
 		else
 			throw std::runtime_error(&quot;CPreGame::StartServer(): Unknown extension: &quot; + extension);
 
-		TdfParser mapDefParser(mapDefFile);
-		std::string mapWantedScript, scriptFile;
-		mapDefParser.GetDef(mapWantedScript, &quot;&quot;, &quot;MAP\\Script&quot;);
-		mapDefParser.GetDef(scriptFile, &quot;&quot;, &quot;MAP\\Scriptfile&quot;);
-		if (!scriptFile.empty())
+		MapParser mp(map);
+		LuaTable mapRoot = mp.GetRoot();
+		const std::string mapWantedScript = mapRoot.GetString(&quot;script&quot;,     &quot;&quot;);
+		const std::string scriptFile      = mapRoot.GetString(&quot;scriptFile&quot;, &quot;&quot;);
+		if (!scriptFile.empty()) {
 			CScriptHandler::Instance().LoadScriptFile(scriptFile);
-		if (!mapWantedScript.empty())
-		{
+		}
+		if (!mapWantedScript.empty()) {
 			script = mapWantedScript;
 			mapHasStartscript = true;
 		}
@@ -381,18 +383,16 @@
 	startupData-&gt;SetScript(script);
 	// here we now the name of the script to use
 
-	try // to load the script 
-	{
+	try { // to load the script 
 		CScriptHandler::SelectScript(script);
 		std::string scriptWantedMod;
 		scriptWantedMod = CScriptHandler::Instance().chosenScript-&gt;GetModName();
-		if (!scriptWantedMod.empty())
+		if (!scriptWantedMod.empty()) {
 			mod = scriptWantedMod;
-
+		}
 		LoadMod(mod);
 	}
-	catch (const std::runtime_error&amp; err) // script not found, so it may be in the modarchive?
-	{
+	catch (const std::runtime_error&amp; err) { // script not found, so it may be in the modarchive?
 		LoadMod(mod); // new map into VFS
 		CScriptHandler::SelectScript(script);
 	}
@@ -401,26 +401,27 @@
 	std::string modArchive = archiveScanner-&gt;ModNameToModArchive(mod);
 	startupData-&gt;SetMod(mod, archiveScanner-&gt;GetModChecksum(modArchive));
 	
-	if (!mapHasStartscript)
-	{
+	if (!mapHasStartscript) {
 		std::string mapFromScript = CScriptHandler::Instance().chosenScript-&gt;GetMapName();
-		if (!mapFromScript.empty() &amp;&amp; map != mapFromScript)
-		{
+		if (!mapFromScript.empty() &amp;&amp; map != mapFromScript) {
 			//TODO unload old map
 			LoadMap(mapFromScript, true);
 		}
 	}
 	startupData-&gt;SetMap(map, archiveScanner-&gt;GetMapChecksum(map));
 
-	if (gameSetup)
-		gameSetup-&gt;LoadStartPositions(); // only host needs to do this, because client will recieve startpos msg from server
+	if (gameSetup) {
+		gameSetup-&gt;LoadStartPositions(); // only host needs to do this, because
+		                                 // client will receive startpos msg from server
+	}
 	
 	good_fpu_control_registers(&quot;before CGameServer creation&quot;);
 	int myPort = gameSetup? gameSetup-&gt;hostport : springDefaultPort;
-	gameServer = new CGameServer(myPort, startupData, gameSetup, demoFile);
-	if (gameSetup &amp;&amp; gameSetup-&gt;autohostport &gt; 0)
+	gameServer = new CGameServer(myPort, false, startupData, gameSetup, demoFile);
+	if (gameSetup &amp;&amp; gameSetup-&gt;autohostport &gt; 0) {
 		gameServer-&gt;AddAutohostInterface(gameSetup-&gt;autohostport);
-	gameServer-&gt;AddLocalClient();
+	}
+	gameServer-&gt;AddLocalClient(gameSetup? gameSetup-&gt;myPlayerNum : 0);
 	good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 }
 
@@ -431,7 +432,7 @@
 		logOutput.Print(&quot;Warning: game should have started before&quot;);
 		return;
 	}
-	if (!net-&gt;IsActiveConnection())
+	if (!net-&gt;Active())
 	{
 		logOutput.Print(&quot;Server not reachable&quot;);
 		globalQuit = true;
@@ -473,8 +474,8 @@
 		{
 			GameData *data = new GameData(boost::shared_ptr&lt;const RawPacket&gt;(buf));
 			good_fpu_control_registers(&quot;before CGameServer creation&quot;);
-			gameServer = new CGameServer(springDefaultPort, data, gameSetup, demoName);
-			gameServer-&gt;AddLocalClient();
+			gameServer = new CGameServer(springDefaultPort, false, data, gameSetup, demoName);
+			gameServer-&gt;AddLocalClient(gameSetup ? gameSetup-&gt;myPlayerNum : 0);
 			good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 			break;
 		}
@@ -584,11 +585,13 @@
 		CFileHandler* f = SAFE_NEW CFileHandler(&quot;maps/&quot; + mapName);
 		if (!f-&gt;FileExists()) {
 			vector&lt;string&gt; ars = archiveScanner-&gt;GetArchivesForMap(mapName);
-			if (ars.empty())
+			if (ars.empty()) {
 				throw content_error(&quot;Couldn't find any archives for map '&quot; + mapName + &quot;'.&quot;);
+			}
 			for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
-				if (!hpiHandler-&gt;AddArchive(*i, false))
+				if (!hpiHandler-&gt;AddArchive(*i, false)) {
 					throw content_error(&quot;Couldn't load archive '&quot; + *i + &quot;' for map '&quot; + mapName + &quot;'.&quot;);
+				}
 			}
 		}
 		delete f;
@@ -600,21 +603,19 @@
 {
 	static bool alreadyLoaded = false;
 	
-	if (!alreadyLoaded)
-	{
+	if (!alreadyLoaded) {
+		// Map all required archives depending on selected mod(s)
 		std::string modArchive = archiveScanner-&gt;ModNameToModArchive(modName);
-		// Map all required archives depending on selected mod(s)
 		vector&lt;string&gt; ars = archiveScanner-&gt;GetArchives(modArchive);
-		if (ars.empty())
+		if (ars.empty()) {
 			throw content_error(&quot;Couldn't find any archives for mod '&quot; + modName + &quot;'&quot;);
-		for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
-		{
-			if (!hpiHandler-&gt;AddArchive(*i, false))
+		}
+		for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
+
+			if (!hpiHandler-&gt;AddArchive(*i, false)) {
 				throw content_error(&quot;Couldn't load archive '&quot; + *i + &quot;' for mod '&quot; + modName + &quot;'.&quot;);
+			}
 		}
-	
-		// always load springcontent.sdz
-		hpiHandler-&gt;AddArchive(&quot;base/springcontent.sdz&quot;, false);
 		alreadyLoaded = true;
 	}
 }
@@ -623,7 +624,7 @@
 {
 	gameData = new GameData(packet);
 	
-	gs-&gt;SetRandSeed(gameData-&gt;GetRandomSeed());
+	gs-&gt;SetRandSeed(gameData-&gt;GetRandomSeed(), true);
 	logOutput &lt;&lt; &quot;Using map &quot; &lt;&lt; gameData-&gt;GetMap() &lt;&lt; &quot;\n&quot;;
 	stupidGlobalMapname = gameData-&gt;GetMap();
 	

Modified: branches/gml/rts/Game/SelectedUnits.cpp
===================================================================
--- branches/gml/rts/Game/SelectedUnits.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/SelectedUnits.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -773,7 +773,7 @@
 	std::vector&lt;short&gt;::iterator i = selectedUnitIDs.begin();
 	CUnitSet::const_iterator ui = selectedUnits.begin();
 	for(; ui != selectedUnits.end(); ++i, ++ui) *i = (*ui)-&gt;id;
-	net-&gt;SendSelect(gu-&gt;myPlayerNum, selectedUnitIDs);
+	net-&gt;Send(CBaseNetProtocol::Get().SendSelect(gu-&gt;myPlayerNum, selectedUnitIDs));
 	selectionChanged=false;
 }
 
@@ -783,7 +783,7 @@
 	if(selectionChanged){		//send new selection
 		SendSelection();
 	}
-	net-&gt;SendCommand(gu-&gt;myPlayerNum, c.id, c.options, c.params);
+	net-&gt;Send(CBaseNetProtocol::Get().SendCommand(gu-&gt;myPlayerNum, c.id, c.options, c.params));
 }
 
 
@@ -834,6 +834,6 @@
 		*packet &lt;&lt; static_cast&lt;unsigned int&gt;(cmd.id) &lt;&lt; cmd.options &lt;&lt; static_cast&lt;unsigned short&gt;(cmd.params.size()) &lt;&lt; cmd.params;
 	}
 
-	net-&gt;SendData(packet);
+	net-&gt;Send(boost::shared_ptr&lt;netcode::RawPacket&gt;(packet));
 	return;
 }

Modified: branches/gml/rts/Game/StartScripts/AirScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/AirScript.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/AirScript.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -14,6 +14,10 @@
 #include &quot;mmgr.h&quot;
 
 
+const char* armhawk_name[] = { &quot;arm_hawk&quot;, &quot;ARMHAWK&quot;, NULL };
+const char* armfig_name [] = { &quot;arm_freedom_fighter&quot;, &quot;ARMFIG&quot;, NULL };
+const char* corvamp_name[] = { &quot;core_vamp&quot;, &quot;CORVAMP&quot;, NULL };
+const char* corape_name [] = { &quot;core_rapier&quot;, &quot;CORAPE&quot;, NULL };
 
 CAirScript::CAirScript()
 : CScript(std::string(&quot;Air combat test&quot;)),
@@ -44,90 +48,83 @@
 	return name[0];
 }
 
-void CAirScript::Update()
+void CAirScript::GameStart()
 {
-	static const char* armhawk_name[] = { &quot;arm_hawk&quot;, &quot;ARMHAWK&quot;, NULL };
-	static const char* armfig_name [] = { &quot;arm_freedom_fighter&quot;, &quot;ARMFIG&quot;, NULL };
-	static const char* corvamp_name[] = { &quot;core_vamp&quot;, &quot;CORVAMP&quot;, NULL };
-	static const char* corape_name [] = { &quot;core_rapier&quot;, &quot;CORAPE&quot;, NULL };
+	doRoll=!configHandler.GetInt(&quot;ReflectiveWater&quot;,1);
 
-	switch(gs-&gt;frameNum){
-	case 0:
-		doRoll=!configHandler.GetInt(&quot;ReflectiveWater&quot;,1);
+	ENTER_MIXED;
+	tcp=camera-&gt;pos;
+	tcf=camera-&gt;forward;
+	ENTER_SYNCED;
+	for(int a=0;a&lt;10;++a){
+		CUnit* u;
+		if(gs-&gt;randFloat()&lt;0.5f)
+			u=unitLoader.LoadUnit(FindUnit(armhawk_name),float3(1650,300,2100+a*150),0,false,0,NULL);
+		else
+			u=unitLoader.LoadUnit(FindUnit(armfig_name),float3(1650,300,2100+a*150),0,false,0,NULL);
+		u-&gt;pos.y=350;
+		u-&gt;experience=0.3f;
+		((CAirMoveType*)u-&gt;moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_FLYING);
+		planes.push_back(u-&gt;id);
+		Command c2;
+		c2.id=CMD_MOVE_STATE;
+		c2.params.push_back(1);
+		u-&gt;commandAI-&gt;GiveCommand(c2);
 
-		ENTER_MIXED;
-		tcp=camera-&gt;pos;
-		tcf=camera-&gt;forward;
-		ENTER_SYNCED;
-		for(int a=0;a&lt;10;++a){
+		Command c;
+		c.id=CMD_PATROL;
+		c.options=0;
+		c.params.push_back(6570);
+		c.params.push_back(0);
+		c.params.push_back(2560);
+		u-&gt;commandAI-&gt;GiveCommand(c);
+
+		if(gs-&gt;randFloat()&lt;0.5f){
+			u=unitLoader.LoadUnit(FindUnit(corvamp_name),float3(3880,300,2100+a*150),1,false,0,NULL);
+			((CAirMoveType*)u-&gt;moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_FLYING);
+		}else{
+			u=unitLoader.LoadUnit(FindUnit(corape_name),float3(3880,300,2100+a*150),1,false,0,NULL);
+		}
+		u-&gt;pos.y=350;
+		u-&gt;experience=0.3f;
+		planes.push_back(u-&gt;id);
+		u-&gt;commandAI-&gt;GiveCommand(c2);
+		c.params[0]=500;
+		u-&gt;commandAI-&gt;GiveCommand(c);
+	}
+}
+
+void CAirScript::Update()
+{
+	std::deque&lt;int&gt;::iterator pi;
+	int num=0;
+	for(pi=planes.begin();pi!=planes.end();++pi){
+		if(uh-&gt;units[*pi]==0){
 			CUnit* u;
-			if(gs-&gt;randFloat()&lt;0.5f)
-				u=unitLoader.LoadUnit(FindUnit(armhawk_name),float3(1650,300,2100+a*150),0,false,0,NULL);
+			if(!(num&amp;1))
+				u=unitLoader.LoadUnit(FindUnit(armhawk_name),float3(1000+(num&amp;1)*5000,500,2100+num*120),(num&amp;1),false,0,NULL);
 			else
-				u=unitLoader.LoadUnit(FindUnit(armfig_name),float3(1650,300,2100+a*150),0,false,0,NULL);
-			u-&gt;pos.y=350;
+				u=unitLoader.LoadUnit(FindUnit(corvamp_name),float3(1000+(num&amp;1)*5000,500,2100+num*120),(num&amp;1),false,0,NULL);
+			u-&gt;pos.y=ground-&gt;GetHeight(1000+(num&amp;1)*5000,2100+num*120)+350;
 			u-&gt;experience=0.3f;
+			u-&gt;speed.x=2.8f;
 			((CAirMoveType*)u-&gt;moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_FLYING);
-			planes.push_back(u-&gt;id);
-			Command c2;
-			c2.id=CMD_MOVE_STATE;
-			c2.params.push_back(1);
-			u-&gt;commandAI-&gt;GiveCommand(c2);
+			*pi=u-&gt;id;
 
 			Command c;
 			c.id=CMD_PATROL;
 			c.options=0;
-			c.params.push_back(6570);
-			c.params.push_back(0);
-			c.params.push_back(2560);
-			u-&gt;commandAI-&gt;GiveCommand(c);
+			c.params.push_back(7000-(num&amp;1)*6500);
+			c.params.push_back(200);
+			c.params.push_back(2500+num*60);
 
-			if(gs-&gt;randFloat()&lt;0.5f){
-				u=unitLoader.LoadUnit(FindUnit(corvamp_name),float3(3880,300,2100+a*150),1,false,0,NULL);
-				((CAirMoveType*)u-&gt;moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_FLYING);
-			}else{
-				u=unitLoader.LoadUnit(FindUnit(corape_name),float3(3880,300,2100+a*150),1,false,0,NULL);
-			}
-			u-&gt;pos.y=350;
-			u-&gt;experience=0.3f;
-			planes.push_back(u-&gt;id);
+			Command c2;
+			c2.id=CMD_MOVE_STATE;
+			c2.params.push_back(1);
 			u-&gt;commandAI-&gt;GiveCommand(c2);
-			c.params[0]=500;
 			u-&gt;commandAI-&gt;GiveCommand(c);
 		}
-		break;
-	default:
-		std::deque&lt;int&gt;::iterator pi;
-		int num=0;
-		for(pi=planes.begin();pi!=planes.end();++pi){
-			if(uh-&gt;units[*pi]==0){
-				CUnit* u;
-				if(!(num&amp;1))
-					u=unitLoader.LoadUnit(FindUnit(armhawk_name),float3(1000+(num&amp;1)*5000,500,2100+num*120),(num&amp;1),false,0,NULL);
-				else
-					u=unitLoader.LoadUnit(FindUnit(corvamp_name),float3(1000+(num&amp;1)*5000,500,2100+num*120),(num&amp;1),false,0,NULL);
-				u-&gt;pos.y=ground-&gt;GetHeight(1000+(num&amp;1)*5000,2100+num*120)+350;
-				u-&gt;experience=0.3f;
-				u-&gt;speed.x=2.8f;
-				((CAirMoveType*)u-&gt;moveType)-&gt;SetState(AAirMoveType::AIRCRAFT_FLYING);
-				*pi=u-&gt;id;
-
-				Command c;
-				c.id=CMD_PATROL;
-				c.options=0;
-				c.params.push_back(7000-(num&amp;1)*6500);
-				c.params.push_back(200);
-				c.params.push_back(2500+num*60);
-
-				Command c2;
-				c2.id=CMD_MOVE_STATE;
-				c2.params.push_back(1);
-				u-&gt;commandAI-&gt;GiveCommand(c2);
-				u-&gt;commandAI-&gt;GiveCommand(c);
-			}
-			num++;
-		}
-		break;
+		num++;
 	}
 }
 

Modified: branches/gml/rts/Game/StartScripts/AirScript.h
===================================================================
--- branches/gml/rts/Game/StartScripts/AirScript.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/AirScript.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -13,6 +13,7 @@
 public:
 	CAirScript(void);
 	~CAirScript(void);
+	void GameStart();
 	void Update(void);
 
 	std::deque&lt;int&gt; planes;

Modified: branches/gml/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/CommanderScript.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -10,13 +10,12 @@
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;Game/UI/InfoConsole.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
-#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;System/LogOutput.h&quot;
-#include &quot;System/TdfParser.h&quot; // still required for parsing map SMD for start positions
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -87,7 +86,7 @@
 				const std::string&amp; sideName  = it-&gt;first;
 				const std::string&amp; startUnit = it-&gt;second;
 				if (startUnit.length() == 0) {
-					throw content_error (
+					throw content_error(
 						&quot;Unable to load a commander for side: &quot; + sideName
 					);
 				}
@@ -118,25 +117,24 @@
 		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
 		if (su1.length() == 0) {
-			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+			throw content_error(&quot;Unable to load a startUnit for the first side&quot;);
 		}
 		
-		TdfParser p2;
-		CMapInfo::OpenTDF(stupidGlobalMapname, p2);
+		MapParser mapParser(stupidGlobalMapname);
+		if (!mapParser.IsValid()) {
+			throw content_error(&quot;MapParser: &quot; + mapParser.GetErrorLog());
+		}
+		float3 startPos0(1000.0f, 80.0f, 1000.0f);
+		float3 startPos1(1200.0f, 80.0f, 1200.0f);
+		mapParser.GetStartPos(0, startPos0);
+		mapParser.GetStartPos(1, startPos1);
 
-		float x0, x1, z0, z1;
-		p2.GetDef(x0, &quot;1000&quot;, &quot;MAP\\TEAM0\\StartPosX&quot;);
-		p2.GetDef(z0, &quot;1000&quot;, &quot;MAP\\TEAM0\\StartPosZ&quot;);
-		p2.GetDef(x1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosX&quot;);
-		p2.GetDef(z1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosZ&quot;);
+		unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
+		unitLoader.LoadUnit(su2, startPos1, 1, false, 0, NULL);
 
-		unitLoader.LoadUnit(su1, float3(x0, 80.0f, z0), 0, false, 0, NULL);
-		unitLoader.LoadUnit(su2, float3(x1, 80.0f, z1), 1, false, 0, NULL);
-
 		// FIXME this shouldn't be here, but no better place exists currently
-		minimap-&gt;AddNotification(float3(x0, 80.0f, z0),
-				float3(1.0f, 1.0f, 1.0f), 1.0f);
-		game-&gt;infoConsole-&gt;SetLastMsgPos(float3(x0, 80.0f, z0));
+		minimap-&gt;AddNotification(startPos0, float3(1.0f, 1.0f, 1.0f), 1.0f);
+		game-&gt;infoConsole-&gt;SetLastMsgPos(startPos0);
 	}
 }
 

Modified: branches/gml/rts/Game/StartScripts/CommanderScript2.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript2.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/CommanderScript2.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -2,11 +2,10 @@
 #include &quot;CommanderScript2.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
-#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;System/LogOutput.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -19,60 +18,52 @@
 }
 
 
-CCommanderScript2::~CCommanderScript2(void)
+CCommanderScript2::~CCommanderScript2()
 {
 }
 
 
-void CCommanderScript2::Update(void)
+void CCommanderScript2::GameStart()
 {
-	switch(gs-&gt;frameNum){
-	case 0:
-		gs-&gt;Team(0)-&gt;energy=1000;
-		gs-&gt;Team(0)-&gt;energyIncome=1000;	//for the endgame statistics
-		gs-&gt;Team(0)-&gt;energyStorage=1000;
-		gs-&gt;Team(0)-&gt;metal=1000;
-		gs-&gt;Team(0)-&gt;metalIncome=1000;
-		gs-&gt;Team(0)-&gt;metalStorage=1000;
+	gs-&gt;Team(0)-&gt;energy=1000;
+	gs-&gt;Team(0)-&gt;energyIncome=1000;	//for the endgame statistics
+	gs-&gt;Team(0)-&gt;energyStorage=1000;
+	gs-&gt;Team(0)-&gt;metal=1000;
+	gs-&gt;Team(0)-&gt;metalIncome=1000;
+	gs-&gt;Team(0)-&gt;metalStorage=1000;
 
-		gs-&gt;Team(1)-&gt;energy=1000;
-		gs-&gt;Team(1)-&gt;energyIncome=1000;
-		gs-&gt;Team(1)-&gt;energyStorage=1000;
-		gs-&gt;Team(1)-&gt;metal=1000;
-		gs-&gt;Team(1)-&gt;metalIncome=1000;
-		gs-&gt;Team(1)-&gt;metalStorage=1000;
+	gs-&gt;Team(1)-&gt;energy=1000;
+	gs-&gt;Team(1)-&gt;energyIncome=1000;
+	gs-&gt;Team(1)-&gt;energyStorage=1000;
+	gs-&gt;Team(1)-&gt;metal=1000;
+	gs-&gt;Team(1)-&gt;metalIncome=1000;
+	gs-&gt;Team(1)-&gt;metalStorage=1000;
 
-		LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-		                    SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-		if (!luaParser.Execute()) {
-			logOutput.Print(luaParser.GetErrorLog());
-		}
-		const LuaTable sideData = luaParser.GetRoot();
-		const LuaTable side1 = sideData.SubTable(1);
-		const LuaTable side2 = sideData.SubTable(2);
-		const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
-		const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+						SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(luaParser.GetErrorLog());
+	}
+	const LuaTable sideData = luaParser.GetRoot();
+	const LuaTable side1 = sideData.SubTable(1);
+	const LuaTable side2 = sideData.SubTable(2);
+	const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+	const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
 
-		if (su1.length() == 0) {
-			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
-		}
+	if (su1.length() == 0) {
+		throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
+	}
 
-		TdfParser p2;
-		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
-
-		float x0,x1,z0,z1;
-		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM0\\StartPosX&quot;);
-		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM0\\StartPosZ&quot;);
-		p2.GetDef(x1,&quot;1200&quot;,&quot;MAP\\TEAM1\\StartPosX&quot;);
-		p2.GetDef(z1,&quot;1200&quot;,&quot;MAP\\TEAM1\\StartPosZ&quot;);
-
-		unitLoader.LoadUnit(su1, float3(x0, 80, z0), 0, false, 0, NULL);
-		unitLoader.LoadUnit(su2, float3(x1, 80, z1), 1, false, 0, NULL);
-
-//		unitLoader.LoadUnit(&quot;armsam&quot;,float3(2650,10,2600),0,false);
-//		unitLoader.LoadUnit(&quot;armflash&quot;,float3(2450,10,2600),1,false);
-
-		break;
+	MapParser mapParser(stupidGlobalMapname);
+	if (!mapParser.IsValid()) {
+		throw content_error(&quot;MapParser: &quot; + mapParser.GetErrorLog());
 	}
+	float3 startPos0(1000.0f, 80.0f, 1000.0f);
+	float3 startPos1(1200.0f, 80.0f, 1200.0f);
+	mapParser.GetStartPos(0, startPos0);
+	mapParser.GetStartPos(1, startPos1);
+
+	unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
+	unitLoader.LoadUnit(su2, startPos1, 1, false, 0, NULL);
 }
 

Modified: branches/gml/rts/Game/StartScripts/CommanderScript2.h
===================================================================
--- branches/gml/rts/Game/StartScripts/CommanderScript2.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/CommanderScript2.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -3,13 +3,12 @@
 
 #include &quot;Script.h&quot;
 
-class CCommanderScript2 :
-	public CScript
+class CCommanderScript2 : public CScript
 {
 public:
-	CCommanderScript2(void);
-	virtual ~CCommanderScript2(void);
-	void Update(void);
+	CCommanderScript2();
+	virtual ~CCommanderScript2();
+	void GameStart();
 };
 
 

Modified: branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/GlobalAITestScript.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -5,12 +5,11 @@
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
-#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/UnitDefHandler.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;System/LogOutput.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;System/Platform/FileSystem.h&quot;
 #include &quot;mmgr.h&quot;
@@ -31,53 +30,45 @@
 }
 
 
-void CGlobalAITestScript::Update(void)
+void CGlobalAITestScript::GameStart(void)
 {
-	switch (gs-&gt;frameNum) {
-		case 0: {
-			globalAI-&gt;CreateGlobalAI(1, dllName.c_str());
+	globalAI-&gt;CreateGlobalAI(1, dllName.c_str());
 
-			gs-&gt;Team(0)-&gt;energy        = 1000;
-			gs-&gt;Team(0)-&gt;energyStorage = 1000;
-			gs-&gt;Team(0)-&gt;metal         = 1000;
-			gs-&gt;Team(0)-&gt;metalStorage  = 1000;
+	gs-&gt;Team(0)-&gt;energy        = 1000;
+	gs-&gt;Team(0)-&gt;energyStorage = 1000;
+	gs-&gt;Team(0)-&gt;metal         = 1000;
+	gs-&gt;Team(0)-&gt;metalStorage  = 1000;
 
-			gs-&gt;Team(1)-&gt;energy        = 1000;
-			gs-&gt;Team(1)-&gt;energyStorage = 1000;
-			gs-&gt;Team(1)-&gt;metal         = 1000;
-			gs-&gt;Team(1)-&gt;metalStorage  = 1000;
+	gs-&gt;Team(1)-&gt;energy        = 1000;
+	gs-&gt;Team(1)-&gt;energyStorage = 1000;
+	gs-&gt;Team(1)-&gt;metal         = 1000;
+	gs-&gt;Team(1)-&gt;metalStorage  = 1000;
 
-			LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
-													SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-			if (!luaParser.Execute()) {
-				logOutput.Print(luaParser.GetErrorLog());
-			}
-			const LuaTable sideData = luaParser.GetRoot();
-			const LuaTable side1 = sideData.SubTable(1);
-			const LuaTable side2 = sideData.SubTable(2);
-			const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
-			const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
-			// default to side 1, in case mod has only 1 side
+	LuaParser luaParser(&quot;gamedata/sidedata.lua&quot;,
+											SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+	if (!luaParser.Execute()) {
+		logOutput.Print(luaParser.GetErrorLog());
+	}
+	const LuaTable sideData = luaParser.GetRoot();
+	const LuaTable side1 = sideData.SubTable(1);
+	const LuaTable side2 = sideData.SubTable(2);
+	const std::string su1 = StringToLower(side1.GetString(&quot;startUnit&quot;, &quot;&quot;));
+	const std::string su2 = StringToLower(side2.GetString(&quot;startUnit&quot;, su1));
+	// default to side 1, in case mod has only 1 side
 
-			if (su1.length() == 0) {
-				throw content_error (&quot;Unable to load a commander for the first side&quot;);
-			}
+	if (su1.length() == 0) {
+		throw content_error (&quot;Unable to load a commander for the first side&quot;);
+	}
 
-			TdfParser p2;
-			CMapInfo::OpenTDF(stupidGlobalMapname, p2);
-
-			float x0, x1, z0, z1;
-			p2.GetDef(x0, &quot;1000&quot;, &quot;MAP\\TEAM0\\StartPosX&quot;);
-			p2.GetDef(z0, &quot;1000&quot;, &quot;MAP\\TEAM0\\StartPosZ&quot;);
-			p2.GetDef(x1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosX&quot;);
-			p2.GetDef(z1, &quot;1200&quot;, &quot;MAP\\TEAM1\\StartPosZ&quot;);
-
-			unitLoader.LoadUnit(su1, float3(x0, 80, z0), 0, false, 0, NULL);
-			unitLoader.LoadUnit(su2, float3(x1, 80, z1), 1, false, 0, NULL);
-			break;
-		}
-		default: {
-			break;
-		}
+	MapParser mapParser(stupidGlobalMapname);
+	if (!mapParser.IsValid()) {
+		throw content_error(&quot;MapParser: &quot; + mapParser.GetErrorLog());
 	}
+	float3 startPos0(1000.0f, 80.0f, 1000.0f);
+	float3 startPos1(1200.0f, 80.0f, 1200.0f);
+	mapParser.GetStartPos(0, startPos0);
+	mapParser.GetStartPos(1, startPos1);
+
+	unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
+	unitLoader.LoadUnit(su2, startPos1, 1, false, 0, NULL);
 }

Modified: branches/gml/rts/Game/StartScripts/GlobalAITestScript.h
===================================================================
--- branches/gml/rts/Game/StartScripts/GlobalAITestScript.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/GlobalAITestScript.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -11,7 +11,7 @@
 	CGlobalAITestScript(std::string dll);
 	~CGlobalAITestScript(void);
 
-	void Update(void);
+	void GameStart(void);
 };
 
 #endif

Modified: branches/gml/rts/Game/StartScripts/LoadScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/LoadScript.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/LoadScript.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -13,8 +13,8 @@
 extern std::string stupidGlobalMapname;
 
 CLoadScript::CLoadScript(std::string file)
-	: CScript(std::string(&quot;Load &quot;) + filesystem.GetFilename(file)),
-	file(file)
+: CScript(std::string(&quot;Load &quot;) + filesystem.GetFilename(file)),
+  file(file)
 {
 }
 
@@ -25,39 +25,8 @@
 void CLoadScript::Update(void)
 {
 	if(!started) {
-/*
-		if(gameSetup){
-			TdfParser p(&quot;gamedata/SIDEDATA.TDF&quot;);
-			for(int a=0;a&lt;gs-&gt;activeTeams;++a){		
-				CTeam* team = gs-&gt;Team(a);
-				if (team-&gt;gaia) continue;
-//				if(!gameSetup-&gt;aiDlls[a].empty()){
-//					if (gu-&gt;myPlayerNum == gs-&gt;Team (a)-&gt;leader)
-//						globalAI-&gt;CreateGlobalAI(a,gameSetup-&gt;aiDlls[a].c_str());
-//				}
-
-				for(int b=0;b&lt;8;++b){					//loop over all sides
-					char sideText[50];
-					sprintf(sideText,&quot;side%i&quot;,b);
-					if(p.SectionExist(sideText)){
-						string sideName = StringToLower(p.SGetValueDef(&quot;arm&quot;,string(sideText)+&quot;\\name&quot;));
-						if(sideName==gs-&gt;Team(a)-&gt;side){		//ok found the right side
-							string cmdType=p.SGetValueDef(&quot;armcom&quot;,string(sideText)+&quot;\\commander&quot;);
-							
-							UnitDef* ud= unitDefHandler-&gt;GetUnitByName(cmdType);
-							ud-&gt;metalStorage=gs-&gt;Team(a)-&gt;metalStorage;			//make sure the cmd has the right amount of storage
-							ud-&gt;energyStorage=gs-&gt;Team(a)-&gt;energyStorage;
-							break;
-						}
-					}
-				}
-//				gs-&gt;Team(a)-&gt;metalStorage=/ *gs-&gt;Team(a)-&gt;metalStorage/2+* /20;		//now remove the preexisting storage except for a small amount
-//				gs-&gt;Team(a)-&gt;energyStorage=/ *gs-&gt;Team(a)-&gt;energyStorage/2+* /20;
-			}
-		}
-*/
 		loader.LoadGame();
-		started=true;
+		started = true;
 	}
 }
 
@@ -65,7 +34,7 @@
 {
 	loader.LoadGameStartInfo(file);		//this is the first time we get called after getting choosen
 	started = false;
-	loadGame=true;
+	loadGame = true;
 }
 
 std::string CLoadScript::GetMapName(void)

Modified: branches/gml/rts/Game/StartScripts/SpawnScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/SpawnScript.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/SpawnScript.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -4,7 +4,7 @@
 #include &quot;SpawnScript.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
-#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Sim/Units/UnitLoader.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
@@ -12,7 +12,6 @@
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;System/LogOutput.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
@@ -50,29 +49,27 @@
 			throw content_error (&quot;Unable to load a startUnit for the first side&quot;);
 		}
 
-		TdfParser p2;
-		CMapInfo::OpenTDF (stupidGlobalMapname, p2);
+		MapParser mapParser(stupidGlobalMapname);
+		if (!mapParser.IsValid()) {
+			throw content_error(&quot;MapParser: &quot; + mapParser.GetErrorLog());
+		}
+		float3 startPos0(1000.0f, 80.0f, 1000.0f);
+		mapParser.GetStartPos(0, startPos0);
 
-		float x0,z0;
-		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM0\\StartPosX&quot;);
-		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM0\\StartPosZ&quot;);
-
 		// Set the TEAM0 startpos as spawnpos if we're supposed to be
 		// autonomous, load the commander for the player if not.
-		if (autonomous) spawnPos.push_back(float3(x0,80,z0));
-		else unitLoader.LoadUnit(su1, float3(x0,80,z0),0,false,0,NULL);
+		if (autonomous) {
+			spawnPos.push_back(startPos0);
+		} else {
+			unitLoader.LoadUnit(su1, startPos0, 0, false, 0, NULL);
+		}
 
-		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM1\\StartPosX&quot;);
-		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM1\\StartPosZ&quot;);
-		spawnPos.push_back(float3(x0,80,z0));
-
-		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM2\\StartPosX&quot;);
-		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM2\\StartPosZ&quot;);
-		spawnPos.push_back(float3(x0,80,z0));
-
-		p2.GetDef(x0,&quot;1000&quot;,&quot;MAP\\TEAM3\\StartPosX&quot;);
-		p2.GetDef(z0,&quot;1000&quot;,&quot;MAP\\TEAM3\\StartPosZ&quot;);
-		spawnPos.push_back(float3(x0,80,z0));
+		// load the start positions for teams 1 - 3
+		for (int teamID = 1; teamID &lt;= 3; teamID++) {
+			float3 sp(1000.0f, 80.0f, 1000.0f);
+			mapParser.GetStartPos(teamID, sp);
+			spawnPos.push_back(sp);
+		}
 	}
 
 	if(!spawns.empty()){

Modified: branches/gml/rts/Game/StartScripts/TestScript.cpp
===================================================================
--- branches/gml/rts/Game/StartScripts/TestScript.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/StartScripts/TestScript.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -10,7 +10,6 @@
 #include &quot;Map/ReadMap.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Game/SelectedUnits.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;

Modified: branches/gml/rts/Game/Team.cpp
===================================================================
--- branches/gml/rts/Game/Team.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/Team.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -258,7 +258,7 @@
 	}
 	isDead = true;
 	luaCallIns.TeamDied(teamNum);
-	net-&gt;SendTeamDied(gu-&gt;myPlayerNum, teamNum);
+	net-&gt;Send(CBaseNetProtocol::Get().SendTeamDied(gu-&gt;myPlayerNum, teamNum));
 	for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
 		if (gs-&gt;players[a]-&gt;active &amp;&amp; gs-&gt;players[a]-&gt;team == teamNum) {
 			gs-&gt;players[a]-&gt;StartSpectating();

Modified: branches/gml/rts/Game/Team.h
===================================================================
--- branches/gml/rts/Game/Team.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/Team.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -113,25 +113,25 @@
 
 		/// Change structure from host endian to little endian or vice versa.
 		void swab() {
-			metalUsed = swabfloat(metalUsed);
-			energyUsed = swabfloat(energyUsed);
-			metalProduced = swabfloat(metalProduced);
-			energyProduced = swabfloat(energyProduced);
-			metalExcess = swabfloat(metalExcess);
-			energyExcess = swabfloat(energyExcess);
-			metalReceived = swabfloat(metalReceived);
-			energyReceived = swabfloat(energyReceived);
-			metalSent = swabfloat(metalSent);
-			energySent = swabfloat(energySent);
-			damageDealt = swabfloat(damageDealt);
-			damageReceived = swabfloat(damageReceived);
-			unitsProduced = swabdword(unitsProduced);
-			unitsDied = swabdword(unitsDied);
-			unitsReceived = swabdword(unitsReceived);
-			unitsSent = swabdword(unitsSent);
-			unitsCaptured = swabdword(unitsCaptured);
+			metalUsed        = swabfloat(metalUsed);
+			energyUsed       = swabfloat(energyUsed);
+			metalProduced    = swabfloat(metalProduced);
+			energyProduced   = swabfloat(energyProduced);
+			metalExcess      = swabfloat(metalExcess);
+			energyExcess     = swabfloat(energyExcess);
+			metalReceived    = swabfloat(metalReceived);
+			energyReceived   = swabfloat(energyReceived);
+			metalSent        = swabfloat(metalSent);
+			energySent       = swabfloat(energySent);
+			damageDealt      = swabfloat(damageDealt);
+			damageReceived   = swabfloat(damageReceived);
+			unitsProduced    = swabdword(unitsProduced);
+			unitsDied        = swabdword(unitsDied);
+			unitsReceived    = swabdword(unitsReceived);
+			unitsSent        = swabdword(unitsSent);
+			unitsCaptured    = swabdword(unitsCaptured);
 			unitsOutCaptured = swabdword(unitsOutCaptured);
-			unitsKilled = swabdword(unitsKilled);
+			unitsKilled      = swabdword(unitsKilled);
 		}
 	};
 	Statistics currentStats;

Modified: branches/gml/rts/Game/UI/CursorIcons.cpp
===================================================================
--- branches/gml/rts/Game/UI/CursorIcons.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/CursorIcons.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -2,10 +2,10 @@
 #include &quot;CursorIcons.h&quot;
 #include &quot;CommandColors.h&quot;
 #include &quot;MouseHandler.h&quot;
+#include &quot;GuiHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/GameHelper.h&quot;
-#include &quot;Game/UI/OutlineFont.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
@@ -135,7 +135,7 @@
 			const float x = (winPos.x * gu-&gt;pixelX) - (0.5f * tWidth);
 			const float y = (winPos.y * gu-&gt;pixelY) + tHeight + yOffset;
 
-			if (outlineFont.IsEnabled()) {
+			if (guihandler-&gt;GetOutlineFonts()) {
 				const float white[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
 				//const float black[4] = { 0.0f, 0.0f, 0.0f, 1.0f };
 				font-&gt;glPrintOutlinedAt(x, y, fontScale, text, white);

Modified: branches/gml/rts/Game/UI/CursorIcons.h
===================================================================
--- branches/gml/rts/Game/UI/CursorIcons.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/CursorIcons.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -79,7 +79,7 @@
 
 		struct BuildIcon {
 			BuildIcon(int c, const float3&amp; p, int t, int f)
-			: cmd(c), pos(p), team(t), facing(f) {}
+			: pos(p), cmd(c), team(t), facing(f) {}
 
 			bool operator&lt;(const BuildIcon&amp; i) const
 			{

Modified: branches/gml/rts/Game/UI/GameSetupDrawer.cpp
===================================================================
--- branches/gml/rts/Game/UI/GameSetupDrawer.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/GameSetupDrawer.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -158,7 +158,7 @@
 {
 	if (keys[SDLK_LCTRL] &amp;&amp; (key == SDLK_RETURN)) {
 		// tell the server to force-start the game
-		net-&gt;SendStartPlaying(0);
+		net-&gt;Send(CBaseNetProtocol::Get().SendStartPlaying(0));
 	}
 	return false;
 }

Modified: branches/gml/rts/Game/UI/GuiHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/GuiHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/GuiHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -15,7 +15,6 @@
 #include &quot;LuaUI.h&quot;
 #include &quot;MiniMap.h&quot;
 #include &quot;MouseHandler.h&quot;
-#include &quot;OutlineFont.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/GameHelper.h&quot;
@@ -60,7 +59,7 @@
 CGuiHandler* guihandler = NULL;
 
 
-const char* CGuiHandler::luaUiFile = &quot;gui.lua&quot;;
+const char* CGuiHandler::luaUiFile = &quot;luaui.lua&quot;;
 
 
 CGuiHandler::CGuiHandler()
@@ -146,7 +145,7 @@
 
 	menuName = &quot;&quot;;
 
-	outlineFont.Enable(false);
+	outlineFonts = false;
 
 	attackRect = true;
 	newAttackMode = true;
@@ -254,7 +253,7 @@
 			SafeAtoF(textureAlpha, words[1]);
 		}
 		else if ((command == &quot;outlinefont&quot;) &amp;&amp; (words.size() &gt; 1)) {
-			outlineFont.Enable(!!atoi(words[1].c_str()));
+			outlineFonts = !!atoi(words[1].c_str());
 		}
 		else if ((command == &quot;attackrect&quot;) &amp;&amp; (words.size() &gt; 1)) {
 			attackRect = !!atoi(words[1].c_str());
@@ -2657,13 +2656,7 @@
 	if (ud != NULL) {
 		const Box&amp; b = icon.visual;
 		glEnable(GL_TEXTURE_2D);
-
-		if (ud-&gt;maxThisUnit &lt;= 0) {
-			glColor4f(0.5f, 0.5f, 0.5f, textureAlpha);
-		} else {
-			glColor4f(1.0f, 1.0f, 1.0f, textureAlpha);
-		}
-
+		glColor4f(1.0f, 1.0f, 1.0f, textureAlpha);
 		glBindTexture(GL_TEXTURE_2D, unitDefHandler-&gt;GetUnitImage(ud));
 		glBegin(GL_QUADS);
 		glTexCoord2f(0.0f, 0.0f); glVertex2f(b.x1, b.y1);
@@ -2673,6 +2666,7 @@
 		glEnd();
 		return true;
 	}
+
 	return false;
 }
 
@@ -3116,7 +3110,7 @@
 		const float xp = 0.5f * (buttonBox.x1 + buttonBox.x2 - textWidth);
 		const float yp = buttonBox.y2 + (yIconSize * 0.125f);
 
-		if (!outlineFont.IsEnabled()) {
+		if (!outlineFonts) {
 			glDisable(GL_TEXTURE_2D);
 			glColor4f(0.2f, 0.2f, 0.2f, guiAlpha);
 			glRectf(buttonBox.x1,
@@ -3152,7 +3146,7 @@
 
 		const float fontScale = 1.0f;
 
-		if (!outlineFont.IsEnabled()) {
+		if (!outlineFonts) {
 			const float textWidth  = fontScale * smallFont-&gt;CalcTextWidth(buf);
 			const float textHeight = fontScale * smallFont-&gt;CalcTextHeight(buf);
 

Modified: branches/gml/rts/Game/UI/GuiHandler.h
===================================================================
--- branches/gml/rts/Game/UI/GuiHandler.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/GuiHandler.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -61,6 +61,8 @@
 
  		bool GetGatherMode() const { return gatherMode; }
  		void SetGatherMode(bool value) { gatherMode = value; }
+		
+		bool GetOutlineFonts() const { return outlineFonts; }
 
 		int  GetDefaultCommand(int x, int y) const;
 
@@ -176,6 +178,7 @@
 		bool useOptionLEDs;
 		bool selectGaps;
 		bool selectThrough;
+		bool outlineFonts;
 		float frameAlpha;
 		float textureAlpha;
 		std::vector&lt;int&gt; fillOrder;

Modified: branches/gml/rts/Game/UI/InfoConsole.cpp
===================================================================
--- branches/gml/rts/Game/UI/InfoConsole.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/InfoConsole.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -5,7 +5,7 @@
 
 #include &quot;InfoConsole.h&quot;
 #include &lt;fstream&gt;
-#include &quot;OutlineFont.h&quot;
+#include &quot;GuiHandler.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 
@@ -64,7 +64,7 @@
 
 	boost::recursive_mutex::scoped_lock scoped_lock(infoConsoleMutex);
 
-	if(!data.empty() &amp;&amp; !outlineFont.IsEnabled()){
+	if(!data.empty() &amp;&amp; (guihandler &amp;&amp; !guihandler-&gt;GetOutlineFonts())){
 		glDisable(GL_TEXTURE_2D);
 		glEnable(GL_BLEND);
 		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
@@ -84,7 +84,7 @@
 	float curX = xpos + 0.01f;
 	float curY = ypos - 0.026f;
 
-	if (!outlineFont.IsEnabled()) {
+	if (guihandler &amp;&amp; !guihandler-&gt;GetOutlineFonts()) {
 		glColor4f(1,1,1,1);
 
 		std::deque&lt;InfoLine&gt;::iterator ili;

Modified: branches/gml/rts/Game/UI/LuaUI.cpp
===================================================================
--- branches/gml/rts/Game/UI/LuaUI.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/LuaUI.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -132,7 +132,7 @@
 	haveWorldTooltip = false;
 	haveMapDrawCmd = false;
 
-	const string code = LoadFile(&quot;gui.lua&quot;);
+	const string code = LoadFile(&quot;luaui.lua&quot;);
 	if (code.empty()) {
 		KillLua();
 		return;
@@ -188,7 +188,7 @@
 
 	lua_settop(L, 0);
 
-	if (!LoadCode(code, &quot;gui.lua&quot;)) {
+	if (!LoadCode(code, &quot;luaui.lua&quot;)) {
 		KillLua();
 		return;
 	}
@@ -2740,8 +2740,7 @@
 	Command cmd;
 	LuaUtils::ParseCommand(L, __FUNCTION__, 2, cmd);
 
-	net-&gt;SendAICommand(gu-&gt;myPlayerNum,
-	                   unit-&gt;id, cmd.id, cmd.options, cmd.params);
+	net-&gt;Send(CBaseNetProtocol::Get().SendAICommand(gu-&gt;myPlayerNum, unit-&gt;id, cmd.id, cmd.options, cmd.params));
 
 	lua_pushboolean(L, true);
 	return 1;
@@ -2888,7 +2887,7 @@
 	else if (!mode.empty()) {
 		luaL_error(L, &quot;Unknown SendLuaUIMsg() mode&quot;);
 	}
-	net-&gt;SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_UI, modeNum, msg);
+	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_UI, modeNum, msg));
 	return 0;
 }
 
@@ -2896,7 +2895,7 @@
 int CLuaUI::SendLuaGaiaMsg(lua_State* L)
 {
 	const string msg = GetRawMsg(L, __FUNCTION__, 1);
-	net-&gt;SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_GAIA, 0, msg);
+	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_GAIA, 0, msg));
 	return 0;
 }
 
@@ -2904,7 +2903,7 @@
 int CLuaUI::SendLuaRulesMsg(lua_State* L)
 {
 	const string msg = GetRawMsg(L, __FUNCTION__, 1);
-	net-&gt;SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_RULES, 0, msg);
+	net-&gt;Send(CBaseNetProtocol::Get().SendLuaMsg(gu-&gt;myPlayerNum, LUA_HANDLE_ORDER_RULES, 0, msg));
 	return 0;
 }
 
@@ -2926,12 +2925,10 @@
 	const float shareLevel = max(0.0f, min(1.0f, (float)lua_tonumber(L, 2)));
 
 	if (shareType == &quot;metal&quot;) {
-		net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam,
-		                  shareLevel, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare);
+		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, shareLevel, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare));
 	}
 	else if (shareType == &quot;energy&quot;) {
-		net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam,
-		                  gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, shareLevel);
+		net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam,	gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, shareLevel));
 	}
 	else {
 		logOutput.Print(&quot;SetShareLevel() unknown resource: %s&quot;, shareType.c_str());
@@ -2965,16 +2962,16 @@
 		Command c;
 		c.id = CMD_STOP;
 		selectedUnits.GiveCommand(c, false);
-		net-&gt;SendShare(gu-&gt;myPlayerNum, teamID, 1, 0.0f, 0.0f);
+		net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 1, 0.0f, 0.0f));
 		selectedUnits.ClearSelected();
 	}
 	else if (args &gt;= 3) {
 		const float amount = (float)lua_tonumber(L, 3);
 		if (type == &quot;metal&quot;) {
-			net-&gt;SendShare(gu-&gt;myPlayerNum, teamID, 0, amount, 0.0f);
+			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, amount, 0.0f));
 		}
 		else if (type == &quot;energy&quot;) {
-			net-&gt;SendShare(gu-&gt;myPlayerNum, teamID, 0, 0.0f, amount);
+			net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, teamID, 0, 0.0f, amount));
 		}
 	}
 	return 0;
@@ -3003,7 +3000,7 @@
 	  text = lua_tostring(L, 4);
 	}
 
-	inMapDrawer-&gt;CreatePoint(pos, text);
+	inMapDrawer-&gt;SendPoint(pos, text);
 
 	return 0;
 }
@@ -3029,7 +3026,7 @@
 	                  (float)lua_tonumber(L, 5),
 	                  (float)lua_tonumber(L, 6));
 
-	inMapDrawer-&gt;AddLine(pos1, pos2);
+	inMapDrawer-&gt;SendLine(pos1, pos2);
 
 	return 0;
 }
@@ -3049,7 +3046,7 @@
 	                 (float)lua_tonumber(L, 2),
 	                 (float)lua_tonumber(L, 3));
 
-	inMapDrawer-&gt;ErasePos(pos);
+	inMapDrawer-&gt;SendErase(pos);
 
 	return 0;
 }

Modified: branches/gml/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/gml/rts/Game/UI/MiniMap.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/MiniMap.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -451,7 +451,11 @@
 		if ((fullProxy &amp;&amp; (button == SDL_BUTTON_MIDDLE)) ||
 				(!fullProxy &amp;&amp; (button == SDL_BUTTON_RIGHT))) {
 			MoveView(x, y);
-			mouseLook = true;
+			if (maximized) {
+				ToggleMaximized(false);
+			} else {
+				mouseLook = true;
+			}
 			return true;
 		}
 		else if (fullProxy &amp;&amp; (button == SDL_BUTTON_RIGHT)) {

Modified: branches/gml/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/gml/rts/Game/UI/MouseHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/MouseHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -275,8 +275,8 @@
 	if (button &gt; NUM_BUTTONS)
 		return;
 
-	dir = hide? camera-&gt;forward: camera-&gt;CalcPixelDir(x, y);
-	buttons[button].pressed=false;
+	dir = hide ? camera-&gt;forward: camera-&gt;CalcPixelDir(x, y);
+	buttons[button].pressed = false;
 
 	if (inMapDrawer &amp;&amp; inMapDrawer-&gt;keyPressed){
 		inMapDrawer-&gt;MouseRelease(x, y, button);
@@ -299,10 +299,11 @@
 	//  &lt;= 0.3 s means a camera mode switch, &gt; 0.3 s means a drag scroll)
 	if (button == SDL_BUTTON_MIDDLE) {
 		if (buttons[SDL_BUTTON_MIDDLE].time &gt; (gu-&gt;gameTime - 0.3f)) {
-			if (keys[SDLK_LSHIFT] || keys[SDLK_LCTRL])
+			if (keys[SDLK_LSHIFT] || keys[SDLK_LCTRL]) {
 				camHandler-&gt;ToggleState();
-			else
+			} else {
 				ToggleState();
+			}
 		}
 		return;
 	}
@@ -547,9 +548,9 @@
 void CMouseHandler::WarpMouse(int x, int y)
 {
 	if (!locked) {
-		lastx = x;
-		lasty = y;
-		mouseInput-&gt;SetPos(int2(x, y));
+		lastx = x + gu-&gt;viewPosX;
+		lasty = y + gu-&gt;viewPosY;
+		mouseInput-&gt;SetPos(int2(lastx, lasty));
 	}
 }
 
@@ -667,11 +668,11 @@
 
 void CMouseHandler::ToggleState()
 {
-	if(locked){
-		locked=false;
+	if (locked) {
+		locked = false;
 		ShowMouse();
 	} else {
-		locked=true;
+		locked = true;
 		HideMouse();
 	}
 }

Deleted: branches/gml/rts/Game/UI/OutlineFont.cpp
===================================================================
--- branches/gml/rts/Game/UI/OutlineFont.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/OutlineFont.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,23 +0,0 @@
-#include &quot;StdAfx.h&quot;
-// OutlineFont.cpp: implementation of the COutlineFont class.
-//
-//////////////////////////////////////////////////////////////////////
-
-#include &quot;OutlineFont.h&quot;
-#include &lt;string&gt;
-#include &quot;Rendering/glFont.h&quot;
-
-/******************************************************************************/
-
-
-COutlineFont outlineFont;
-
-
-COutlineFont::COutlineFont() : enabled(true)
-{
-}
-
-
-COutlineFont::~COutlineFont()
-{
-}

Deleted: branches/gml/rts/Game/UI/OutlineFont.h
===================================================================
--- branches/gml/rts/Game/UI/OutlineFont.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/OutlineFont.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,26 +0,0 @@
-#ifndef __OUTLINE_FONT_H__
-#define __OUTLINE_FONT_H__
-
-#include &quot;Rendering/glFont.h&quot;
-
-// OutlineFont.h: interface for the COutlineFont class.
-//
-//////////////////////////////////////////////////////////////////////
-
-class COutlineFont {
-	public:
-		COutlineFont();
-		~COutlineFont();
-
-		void Enable(bool value) { enabled = value; }
-		bool IsEnabled() const { return enabled; }
-
-	private:
-		bool enabled;
-};
-
-
-extern COutlineFont outlineFont;
-
-
-#endif // __OUTLINE_FONT_H__

Modified: branches/gml/rts/Game/UI/QuitBox.cpp
===================================================================
--- branches/gml/rts/Game/UI/QuitBox.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/QuitBox.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -219,17 +219,17 @@
 	if(InBox(mx,my,box+resignBox) || InBox(mx,my,box+giveAwayBox) &amp;&amp; !gs-&gt;Team(shareTeam)-&gt;isDead &amp;&amp; !gs-&gt;Team(gu-&gt;myTeam)-&gt;isDead){
 		// give away all units (and resources)
 		if(InBox(mx,my,box+giveAwayBox)) {
-			net-&gt;SendGiveAwayEverything(gu-&gt;myPlayerNum, shareTeam);
+			net-&gt;Send(CBaseNetProtocol::Get().SendGiveAwayEverything(gu-&gt;myPlayerNum, shareTeam));
 			// inform other users of the giving away of units
 			char givenAwayMsg[200];
 			sprintf(givenAwayMsg,&quot;%s gave everything to %s.&quot;,
 				gs-&gt;players[gu-&gt;myPlayerNum]-&gt;playerName.c_str(),
 				gs-&gt;players[gs-&gt;Team(shareTeam)-&gt;leader]-&gt;playerName.c_str());
-			net-&gt;SendSystemMessage(gu-&gt;myPlayerNum, givenAwayMsg);
+			net-&gt;Send(CBaseNetProtocol::Get().SendSystemMessage(gu-&gt;myPlayerNum, givenAwayMsg));
 		}
 		// resign, so self-d all units
 		if (InBox(mx,my,box+resignBox)) {
-			net-&gt;SendResign(gu-&gt;myPlayerNum);
+			net-&gt;Send(CBaseNetProtocol::Get().SendResign(gu-&gt;myPlayerNum));
 		}
 	}
 	else if(InBox(mx,my,box+quitBox))

Modified: branches/gml/rts/Game/UI/ResourceBar.cpp
===================================================================
--- branches/gml/rts/Game/UI/ResourceBar.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/ResourceBar.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -245,12 +245,12 @@
 			if(InBox(mx,my,box+metalBox)){
 				moveBox = false;
 				float metalShare = std::max(0.f, std::min(1.f,(mx-(box.x1+metalBox.x1))/(metalBox.x2-metalBox.x1)));
-				net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, metalShare, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare);
+				net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, metalShare, gs-&gt;Team(gu-&gt;myTeam)-&gt;energyShare));
 			}
 			if(InBox(mx,my,box+energyBox)){
 				moveBox = false;
 				float energyShare = std::max(0.f, std::min(1.f,(mx-(box.x1+energyBox.x1))/(energyBox.x2-energyBox.x1)));
-				net-&gt;SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, energyShare);
+				net-&gt;Send(CBaseNetProtocol::Get().SendSetShare(gu-&gt;myPlayerNum, gu-&gt;myTeam, gs-&gt;Team(gu-&gt;myTeam)-&gt;metalShare, energyShare));
 			}
 		}
 		return true;

Modified: branches/gml/rts/Game/UI/ShareBox.cpp
===================================================================
--- branches/gml/rts/Game/UI/ShareBox.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/ShareBox.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -294,8 +294,7 @@
 			// make sure the units are stopped and that the selection is transmitted
 			selectedUnits.GiveCommand(c, false);
 		}
-		net-&gt;SendShare(gu-&gt;myPlayerNum, shareTeam, shareUnits,
-				metalShare * gs-&gt;Team(gu-&gt;myTeam)-&gt;metal, energyShare * gs-&gt;Team(gu-&gt;myTeam)-&gt;energy);
+		net-&gt;Send(CBaseNetProtocol::Get().SendShare(gu-&gt;myPlayerNum, shareTeam, shareUnits, metalShare * gs-&gt;Team(gu-&gt;myTeam)-&gt;metal, energyShare * gs-&gt;Team(gu-&gt;myTeam)-&gt;energy));
 		if (shareUnits)
 			selectedUnits.ClearSelected();
 		lastShareTeam = shareTeam;

Modified: branches/gml/rts/Game/UI/StartPosSelecter.cpp
===================================================================
--- branches/gml/rts/Game/UI/StartPosSelecter.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/StartPosSelecter.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -37,7 +37,7 @@
 	if (!startPosSet) // Player doesn't set startpos yet, so don't let him ready up
 		return false;
 
-	net-&gt;SendStartPos(gu-&gt;myPlayerNum, gu-&gt;myTeam, 1, startPos.x, startPos.y, startPos.z);
+	net-&gt;Send(CBaseNetProtocol::Get().SendStartPos(gu-&gt;myPlayerNum, gu-&gt;myTeam, 1, startPos.x, startPos.y, startPos.z));
 
 	delete this;
 	return true;
@@ -57,7 +57,7 @@
 		return true;
 
 	startPosSet = true;
-	inMapDrawer-&gt;ErasePos(startPos);
+	inMapDrawer-&gt;SendErase(startPos);
 	startPos = camera-&gt;pos + mouse-&gt;dir * dist;
 
 	if(startPos.z&lt;gameSetup-&gt;startRectTop[gu-&gt;myAllyTeam]*gs-&gt;mapy*8)
@@ -72,12 +72,8 @@
 	if(startPos.x&gt;gameSetup-&gt;startRectRight[gu-&gt;myAllyTeam]*gs-&gt;mapx*8)
 		startPos.x=gameSetup-&gt;startRectRight[gu-&gt;myAllyTeam]*gs-&gt;mapx*8;
 
-	net-&gt;SendStartPos(gu-&gt;myPlayerNum, gu-&gt;myTeam, 0, startPos.x, startPos.y, startPos.z);
+	net-&gt;Send(CBaseNetProtocol::Get().SendStartPos(gu-&gt;myPlayerNum, gu-&gt;myTeam, 0, startPos.x, startPos.y, startPos.z));
 
-	char t[128];
-	sprintf(t,&quot;Start %i&quot;,gu-&gt;myTeam);
-	inMapDrawer-&gt;CreatePoint(startPos,t);
-
 	return true;
 }
 

Modified: branches/gml/rts/Game/UI/TooltipConsole.cpp
===================================================================
--- branches/gml/rts/Game/UI/TooltipConsole.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Game/UI/TooltipConsole.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -2,7 +2,6 @@
 #include &quot;TooltipConsole.h&quot;
 #include &quot;LuaUI.h&quot;
 #include &quot;MouseHandler.h&quot;
-#include &quot;OutlineFont.h&quot;
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Game/Player.h&quot;

Modified: branches/gml/rts/Lua/LuaConstGame.cpp
===================================================================
--- branches/gml/rts/Lua/LuaConstGame.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaConstGame.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -109,10 +109,10 @@
 	LuaPushNamedColor(L,  &quot;groundSpecularColor&quot;, mi-&gt;light.groundSpecularColor);
 	LuaPushNamedColor(L,  &quot;groundSunColor&quot;,      mi-&gt;light.groundSunColor);
 
-	const string* causticTexs = mi-&gt;water.causticTextures;
+	const vector&lt;string&gt;&amp; causticTexs = mi-&gt;water.causticTextures;
 	lua_pushstring(L, &quot;waterCausticTextures&quot;);
 	lua_newtable(L);
-	for (int i = 0; i &lt; CMapInfo::causticTextureCount; i++) {
+	for (int i = 0; i &lt; (int)causticTexs.size(); i++) {
 		lua_pushnumber(L, i + 1);
 		lua_pushstring(L, causticTexs[i].c_str());
 		lua_rawset(L, -3);

Modified: branches/gml/rts/Lua/LuaFeatureDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaFeatureDefs.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaFeatureDefs.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -169,7 +169,7 @@
 	ParamMap::const_iterator it = paramMap.find(name);
 
 	// not a default value
-	if (paramMap.find(name) == paramMap.end()) {
+	if (it == paramMap.end()) {
 	  lua_rawget(L, 1);
 	  return 1;
 	}
@@ -222,7 +222,7 @@
 	ParamMap::const_iterator it = paramMap.find(name);
 
 	// not a default value, set it
-	if (paramMap.find(name) == paramMap.end()) {
+	if (it == paramMap.end()) {
 		lua_rawset(L, 1);
 		return 0;
 	}

Modified: branches/gml/rts/Lua/LuaHandle.cpp
===================================================================
--- branches/gml/rts/Lua/LuaHandle.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaHandle.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -807,7 +807,10 @@
 				if (player == NULL) {
 					return;
 				}
-				if (player-&gt;spectator) {
+				if (gu-&gt;spectatingFullView) {
+					sendMsg = true;
+				}
+				else if (player-&gt;spectator) {
 					sendMsg = gu-&gt;spectating;
 				} else {
 					const int msgAllyTeam = gs-&gt;AllyTeam(player-&gt;team);

Modified: branches/gml/rts/Lua/LuaOpenGL.cpp
===================================================================
--- branches/gml/rts/Lua/LuaOpenGL.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaOpenGL.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1192,17 +1192,15 @@
 		const float noshow[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
 
 		if (lightOut) {
-			font-&gt;Outline(true, noshow, lightOutline);
+			font-&gt;OutlineS(true, lightOutline);
 		} else {
-			font-&gt;Outline(true, noshow, darkOutline);
+			font-&gt;OutlineS(true, darkOutline);
 		}
-		font-&gt;glPrintAt(xj, y, fontScale, text.c_str());
 	}
 
 	if (colorCodes) {
 		font-&gt;glPrintColorAt(xj, y, fontScale, text.c_str());
 	} else {
-		//glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
 		font-&gt;glPrintAt(xj, y, fontScale, text.c_str());
 	}
 
@@ -4818,7 +4816,7 @@
 		return 3;
 	}
 
-	const bool unitMode = lua_isstring(L, 2) &amp;&amp;
+	const bool unitMode = lua_israwstring(L, 2) &amp;&amp;
 	                      (strcmp(lua_tostring(L, 2), &quot;unit&quot;) == 0);
 
 	const float3* data = NULL;
@@ -4835,14 +4833,14 @@
 		if (!unitMode) {
 			data = &amp;mapInfo-&gt;light.groundSunColor;
 		} else {
-			data = &amp;unitDrawer-&gt;unitSunColor;
+			data = &amp;mapInfo-&gt;light.unitSunColor;
 		}
 	}
 	else if (param == &quot;ambient&quot;) {
 		if (!unitMode) {
-			data = &amp;mapInfo-&gt;light.groundSunColor;
+			data = &amp;mapInfo-&gt;light.groundAmbientColor;
 		} else {
-			data = &amp;unitDrawer-&gt;unitAmbientColor;
+			data = &amp;mapInfo-&gt;light.unitAmbientColor;
 		}
 	}
 	else if (param == &quot;specular&quot;) {

Modified: branches/gml/rts/Lua/LuaParser.cpp
===================================================================
--- branches/gml/rts/Lua/LuaParser.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaParser.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -34,45 +34,11 @@
 
 static const bool lowerKeys = true;
 
-
-/******************************************************************************/
-/******************************************************************************/
-
 LuaParser* LuaParser::currentParser = NULL;
 
 
 /******************************************************************************/
 /******************************************************************************/
-
-static void SetupStdLibs(lua_State* L)
-{
-	LUA_OPEN_LIB(L, luaopen_base);
-	LUA_OPEN_LIB(L, luaopen_math);
-	LUA_OPEN_LIB(L, luaopen_table);
-	LUA_OPEN_LIB(L, luaopen_string);
-	//LUA_OPEN_LIB(L, luaopen_io);
-	//LUA_OPEN_LIB(L, luaopen_os);
-	//LUA_OPEN_LIB(L, luaopen_package);
-	//LUA_OPEN_LIB(L, luaopen_debug);
-
-	// delete some dangerous/unsynced functions
-	lua_pushnil(L); lua_setglobal(L, &quot;dofile&quot;);
-	lua_pushnil(L); lua_setglobal(L, &quot;loadfile&quot;);
-	lua_pushnil(L); lua_setglobal(L, &quot;loadlib&quot;);
-	lua_pushnil(L); lua_setglobal(L, &quot;require&quot;);
-	lua_pushnil(L); lua_setglobal(L, &quot;gcinfo&quot;);
-	lua_pushnil(L); lua_setglobal(L, &quot;collectgarbage&quot;);
-
-	// FIXME: replace &quot;random&quot; as in LuaHandleSynced (can write your own for now)
-	lua_getglobal(L, &quot;math&quot;);
-	lua_pushstring(L, &quot;random&quot;);     lua_pushnil(L); lua_rawset(L, -3);
-	lua_pushstring(L, &quot;randomseed&quot;); lua_pushnil(L); lua_rawset(L, -3);
-	lua_pop(L, 1); // pop &quot;math&quot;
-}
-
-
-/******************************************************************************/
-/******************************************************************************/
 //
 //  LuaParser
 //
@@ -92,19 +58,7 @@
 	L = lua_open();
 
 	if (L != NULL) {
-		SetupStdLibs(L);
-
-		GetTable(&quot;Spring&quot;);
-		AddFunc(&quot;Echo&quot;, Echo);
-		AddFunc(&quot;TimeCheck&quot;, TimeCheck);
-		EndTable();
-
-		GetTable(&quot;VFS&quot;);
-		AddFunc(&quot;DirList&quot;,    DirList);
-		AddFunc(&quot;Include&quot;,    Include);
-		AddFunc(&quot;LoadFile&quot;,   LoadFile);
-		AddFunc(&quot;FileExists&quot;, FileExists);
-		EndTable();
+		SetupEnv();
 	}
 }
 
@@ -123,19 +77,7 @@
 	L = lua_open();
 
 	if (L != NULL) {
-		SetupStdLibs(L);
-
-		GetTable(&quot;Spring&quot;);
-		AddFunc(&quot;Echo&quot;, Echo);
-		AddFunc(&quot;TimeCheck&quot;, TimeCheck);
-		EndTable();
-
-		GetTable(&quot;VFS&quot;);
-		AddFunc(&quot;DirList&quot;,    DirList);
-		AddFunc(&quot;Include&quot;,    Include);
-		AddFunc(&quot;LoadFile&quot;,   LoadFile);
-		AddFunc(&quot;FileExists&quot;, FileExists);
-		EndTable();
+		SetupEnv();
 	}
 }
 
@@ -156,8 +98,146 @@
 }
 
 
+void LuaParser::SetupEnv()
+{
+	LUA_OPEN_LIB(L, luaopen_base);
+	LUA_OPEN_LIB(L, luaopen_math);
+	LUA_OPEN_LIB(L, luaopen_table);
+	LUA_OPEN_LIB(L, luaopen_string);
+	//LUA_OPEN_LIB(L, luaopen_io);
+	//LUA_OPEN_LIB(L, luaopen_os);
+	//LUA_OPEN_LIB(L, luaopen_package);
+	//LUA_OPEN_LIB(L, luaopen_debug);
+
+	// delete some dangerous/unsynced functions
+	lua_pushnil(L); lua_setglobal(L, &quot;dofile&quot;);
+	lua_pushnil(L); lua_setglobal(L, &quot;loadfile&quot;);
+	lua_pushnil(L); lua_setglobal(L, &quot;loadlib&quot;);
+	lua_pushnil(L); lua_setglobal(L, &quot;require&quot;);
+	lua_pushnil(L); lua_setglobal(L, &quot;gcinfo&quot;);
+	lua_pushnil(L); lua_setglobal(L, &quot;collectgarbage&quot;);
+
+	// FIXME: replace &quot;random&quot; as in LuaHandleSynced (can write your own for now)
+	lua_getglobal(L, &quot;math&quot;);
+	lua_pushstring(L, &quot;random&quot;);     lua_pushnil(L); lua_rawset(L, -3);
+	lua_pushstring(L, &quot;randomseed&quot;); lua_pushnil(L); lua_rawset(L, -3);
+	lua_pop(L, 1); // pop &quot;math&quot;
+
+	GetTable(&quot;Spring&quot;);
+	AddFunc(&quot;Echo&quot;, Echo);
+	AddFunc(&quot;TimeCheck&quot;, TimeCheck);
+	EndTable();
+
+	GetTable(&quot;VFS&quot;);
+	AddFunc(&quot;DirList&quot;,    DirList);
+	AddFunc(&quot;Include&quot;,    Include);
+	AddFunc(&quot;LoadFile&quot;,   LoadFile);
+	AddFunc(&quot;FileExists&quot;, FileExists);
+	EndTable();
+}
+
+
 /******************************************************************************/
 
+bool LuaParser::Execute()
+{
+	if (L == NULL) {
+		errorLog = &quot;could not initialize LUA library&quot;;
+		return false;
+	}
+
+	rootRef = LUA_NOREF;
+
+	assert(initDepth == 0);
+	initDepth = -1;
+
+	string code;
+	string codeLabel;
+	if (!textChunk.empty()) {
+		code = textChunk;
+		codeLabel = &quot;text chunk&quot;;
+	}
+	else if (!fileName.empty()) {
+		codeLabel = fileName;
+		CFileHandler fh(fileName, fileModes);
+		if (!fh.LoadStringData(code)) {
+			errorLog = &quot;could not open file: &quot; + fileName;
+			lua_close(L);
+			L = NULL;
+			return false;
+		}
+	}
+	else {
+		errorLog = &quot;no source file or text&quot;;
+		lua_close(L);
+		L = NULL;
+		return false;
+	}
+
+	int error;
+	error = luaL_loadbuffer(L, code.c_str(), code.size(), codeLabel.c_str());
+	if (error != 0) {
+		errorLog = lua_tostring(L, -1);
+		logOutput.Print(&quot;error = %i, %s, %s\n&quot;,
+		                error, codeLabel.c_str(), errorLog.c_str());
+		lua_close(L);
+		L = NULL;
+		return false;
+	}
+
+	currentParser = this;
+
+	error = lua_pcall(L, 0, 1, 0);
+
+	currentParser = NULL;
+
+	if (error != 0) {
+		errorLog = lua_tostring(L, -1);
+		logOutput.Print(&quot;error = %i, %s, %s\n&quot;,
+		                error, fileName.c_str(), errorLog.c_str());
+		lua_close(L);
+		L = NULL;
+		return false;
+	}
+
+	if (!lua_istable(L, 1)) {
+		errorLog = &quot;missing return table from &quot; + fileName + &quot;\n&quot;;
+		logOutput.Print(&quot;missing return table from %s\n&quot;, fileName.c_str());
+		lua_close(L);
+		L = NULL;
+		return false;
+	}
+
+	rootRef = luaL_ref(L, LUA_REGISTRYINDEX);
+
+	lua_settop(L, 0);
+
+	valid = true;
+
+	return true;
+}
+
+
+void LuaParser::AddTable(LuaTable* tbl)
+{
+	tables.insert(tbl);
+}
+
+
+void LuaParser::RemoveTable(LuaTable* tbl)
+{
+	tables.erase(tbl);
+}
+
+
+LuaTable LuaParser::GetRoot()
+{
+	return LuaTable(this);
+}
+
+
+/******************************************************************************/
+
 void LuaParser::PushParam()
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
@@ -234,25 +314,25 @@
 }
 
 
-void LuaParser::AddParam(const string&amp; key, const string&amp; value)
+void LuaParser::AddInt(const string&amp; key, int value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushstring(L, key.c_str());
-	lua_pushstring(L, value.c_str());
+	lua_pushnumber(L, value);
 	PushParam();
 }
 
 
-void LuaParser::AddParam(const string&amp; key, float value)
+void LuaParser::AddBool(const string&amp; key, bool value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushstring(L, key.c_str());
-	lua_pushnumber(L, value);
+	lua_pushboolean(L, value);
 	PushParam();
 }
 
 
-void LuaParser::AddParam(const string&amp; key, int value)
+void LuaParser::AddFloat(const string&amp; key, float value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushstring(L, key.c_str());
@@ -261,11 +341,11 @@
 }
 
 
-void LuaParser::AddParam(const string&amp; key, bool value)
+void LuaParser::AddString(const string&amp; key, const string&amp; value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushstring(L, key.c_str());
-	lua_pushboolean(L, value);
+	lua_pushstring(L, value.c_str());
 	PushParam();
 }
 
@@ -282,25 +362,25 @@
 }
 
 
-void LuaParser::AddParam(int key, const string&amp; value)
+void LuaParser::AddInt(int key, int value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushnumber(L, key);
-	lua_pushstring(L, value.c_str());
+	lua_pushnumber(L, value);
 	PushParam();
 }
 
 
-void LuaParser::AddParam(int key, float value)
+void LuaParser::AddBool(int key, bool value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushnumber(L, key);
-	lua_pushnumber(L, value);
+	lua_pushboolean(L, value);
 	PushParam();
 }
 
 
-void LuaParser::AddParam(int key, int value)
+void LuaParser::AddFloat(int key, float value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushnumber(L, key);
@@ -309,110 +389,17 @@
 }
 
 
-void LuaParser::AddParam(int key, bool value)
+void LuaParser::AddString(int key, const string&amp; value)
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 	lua_pushnumber(L, key);
-	lua_pushboolean(L, value);
+	lua_pushstring(L, value.c_str());
 	PushParam();
 }
 
 
 /******************************************************************************/
-
-bool LuaParser::Execute()
-{
-	if (L == NULL) {
-		errorLog = &quot;could not initialize LUA library&quot;;
-		return false;
-	}
-
-	rootRef = LUA_NOREF;
-
-	assert(initDepth == 0);
-	initDepth = -1;
-
-	string code;
-	string codeLabel;
-	if (textChunk.size() &gt; 0) {
-		code = textChunk;
-		codeLabel = &quot;text chunk&quot;;
-	}
-	else {
-		codeLabel = fileName;
-		CFileHandler fh(fileName, fileModes);
-		if (!fh.LoadStringData(code)) {
-			errorLog = &quot;could not open file: &quot; + fileName;
-			lua_close(L);
-			L = NULL;
-			return false;
-		}
-	}
-
-	int error;
-	error = luaL_loadbuffer(L, code.c_str(), code.size(), codeLabel.c_str());
-	if (error != 0) {
-		errorLog = lua_tostring(L, -1);
-		logOutput.Print(&quot;error = %i, %s, %s\n&quot;,
-		                error, codeLabel.c_str(), errorLog.c_str());
-		lua_close(L);
-		L = NULL;
-		return false;
-	}
-
-	currentParser = this;
-
-	error = lua_pcall(L, 0, 1, 0);
-
-	currentParser = NULL;
-
-	if (error != 0) {
-		errorLog = lua_tostring(L, -1);
-		logOutput.Print(&quot;error = %i, %s, %s\n&quot;,
-		                error, fileName.c_str(), errorLog.c_str());
-		lua_close(L);
-		L = NULL;
-		return false;
-	}
-
-	if (!lua_istable(L, 1)) {
-		errorLog = &quot;missing return table from &quot; + fileName + &quot;\n&quot;;
-		logOutput.Print(&quot;missing return table from %s\n&quot;, fileName.c_str());
-		lua_close(L);
-		L = NULL;
-		return false;
-	}
-
-	rootRef = luaL_ref(L, LUA_REGISTRYINDEX);
-
-	lua_settop(L, 0);
-
-	valid = true;
-
-	return true;
-}
-
-
-void LuaParser::AddTable(LuaTable* tbl)
-{
-	tables.insert(tbl);
-}
-
-
-void LuaParser::RemoveTable(LuaTable* tbl)
-{
-	tables.erase(tbl);
-}
-
-
-LuaTable LuaParser::GetRoot()
-{
-	return LuaTable(this);
-}
-
-
 /******************************************************************************/
-/******************************************************************************/
 //
 //  call-outs
 //
@@ -748,6 +735,47 @@
 }
 
 
+LuaTable LuaTable::SubTableExpr(const string&amp; expr) const
+{
+	if (expr.empty()) {
+		return LuaTable(*this);
+	}
+	if (!isValid) {
+		return LuaTable();
+	}
+
+	string::size_type endPos;
+	LuaTable nextTable;
+
+	if (expr[0] == '[') { // numeric key
+    endPos = expr.find(']');
+    if (endPos == string::npos) {
+      return LuaTable(); // missing brace
+    }
+    const char* startPtr = expr.c_str() + 1; // skip the '['
+    char* endPtr;
+    const int index = strtol(startPtr, &amp;endPtr, 10);
+    if (endPtr == startPtr) {
+      return LuaTable(); // invalid index
+    }
+    endPos++; // eat the ']'
+    nextTable = SubTable(index);
+	}
+	else { // string key
+		endPos = expr.find_first_of(&quot;.[&quot;);
+		if (endPos == string::npos) {
+			return SubTable(expr);
+		}
+		nextTable = SubTable(expr.substr(0, endPos));
+	}
+
+	if (expr[endPos] == '.') {
+		endPos++; // eat the dot
+	}
+	return nextTable.SubTableExpr(expr.substr(endPos));
+}
+
+
 LuaTable::~LuaTable()
 {
 	if (L &amp;&amp; (refnum != LUA_NOREF)) {

Modified: branches/gml/rts/Lua/LuaParser.h
===================================================================
--- branches/gml/rts/Lua/LuaParser.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaParser.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -35,6 +35,7 @@
 
 		LuaTable SubTable(int key) const;
 		LuaTable SubTable(const string&amp; key) const;
+		LuaTable SubTableExpr(const string&amp; expr) const;
 
 		bool IsValid() const { return (parser != NULL); }
 
@@ -118,6 +119,10 @@
 
 		LuaTable GetRoot();
 
+		LuaTable SubTableExpr(const string&amp; expr) {
+			return GetRoot().SubTableExpr(expr);
+		}
+
 		const string&amp; GetErrorLog() const { return errorLog; }
 	
 		const set&lt;string&gt;&amp; GetAccessedFiles() const { return accessedFiles; }
@@ -127,15 +132,15 @@
 		void GetTable(const string&amp; name, bool overwrite = false);
 		void EndTable();
 		void AddFunc(int key, int (*func)(lua_State*));
-		void AddParam(int key, const string&amp; value);
-		void AddParam(int key, float value);
-		void AddParam(int key, int value);
-		void AddParam(int key, bool value);
+		void AddInt(int key, int value);
+		void AddBool(int key, bool value);
+		void AddFloat(int key, float value);
+		void AddString(int key, const string&amp; value);
 		void AddFunc(const string&amp; key, int (*func)(lua_State*));
-		void AddParam(const string&amp; key, const string&amp; value);
-		void AddParam(const string&amp; key, float value);
-		void AddParam(const string&amp; key, int value);
-		void AddParam(const string&amp; key, bool value);
+		void AddInt(const string&amp; key, int value);
+		void AddBool(const string&amp; key, bool value);
+		void AddFloat(const string&amp; key, float value);
+		void AddString(const string&amp; key, const string&amp; value);
 
 	public:
 		const string fileName;
@@ -144,6 +149,8 @@
 		const string accessModes;
 
 	private:
+		void SetupEnv();
+
 		void PushParam();
 
 		void AddTable(LuaTable* tbl);

Modified: branches/gml/rts/Lua/LuaRules.cpp
===================================================================
--- branches/gml/rts/Lua/LuaRules.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaRules.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -119,6 +119,7 @@
 	haveAllowResourceLevel       = HasCallIn(&quot;AllowResourceLevel&quot;);
 	haveAllowResourceTransfer    = HasCallIn(&quot;AllowResourceTransfer&quot;);
 	haveAllowDirectUnitControl   = HasCallIn(&quot;AllowDirectUnitControl&quot;);
+	haveAllowStartPosition       = HasCallIn(&quot;AllowStartPosition&quot;);
 	haveMoveCtrlNotify           = HasCallIn(&quot;MoveCtrlNotify&quot;);
 	haveBuilderTerraformComplete = HasCallIn(&quot;BuilderTerraformComplete&quot;);
 	haveDrawUnit                 = HasCallIn(&quot;DrawUnit&quot;);
@@ -242,6 +243,8 @@
 		haveAllowResourceTransfer    = HasCallIn(&quot;AllowResourceTransfer&quot;);
 	} else if (name == &quot;AllowDirectUnitControl&quot;) {
 		haveAllowDirectUnitControl   = HasCallIn(&quot;AllowDirectUnitControl&quot;);
+	} else if (name == &quot;AllowStartPosition&quot;) {
+		haveAllowStartPosition       = HasCallIn(&quot;AllowStartPosition&quot;);
 	} else if (name == &quot;MoveCtrlNotify&quot;) {
 		haveMoveCtrlNotify           = HasCallIn(&quot;MoveCtrlNotify&quot;);
 	} else if (name == &quot;BuilderTerraformComplete&quot;) {
@@ -700,6 +703,44 @@
 }
 
 
+bool CLuaRules::AllowStartPosition(int playerID, const float3&amp; pos)
+{
+	if (!haveAllowStartPosition) {
+		return true; // the call is not defined
+	}
+
+	LUA_CALL_IN_CHECK(L);
+	lua_checkstack(L, 9);
+	static const LuaHashString cmdStr(&quot;AllowStartPosition&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return true; // the call is not defined
+	}
+
+	// push the start position and playerID
+	lua_pushnumber(L, pos.x);
+	lua_pushnumber(L, pos.y);
+	lua_pushnumber(L, pos.z);
+	lua_pushnumber(L, playerID);
+
+	// call the function
+	if (!RunCallIn(cmdStr, 4, 1)) {
+		return true;
+	}
+
+	// get the results
+	const int args = lua_gettop(L);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
+		                cmdStr.GetString().c_str(), args);
+		lua_pop(L, 1);
+		return true;
+	}
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+	return retval;
+}
+
+
 bool CLuaRules::MoveCtrlNotify(const CUnit* unit, int data)
 {
 	if (!haveMoveCtrlNotify) {
@@ -815,7 +856,7 @@
 	}
 
 	const int args = lua_gettop(L);
-	if ((args != 1) || !lua_isboolean(L, -1)) {
+	if (!lua_isboolean(L, -1)) {
 		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
 		                cmdStr.GetString().c_str(), args);
 		lua_pop(L, 1);

Modified: branches/gml/rts/Lua/LuaRules.h
===================================================================
--- branches/gml/rts/Lua/LuaRules.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaRules.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -58,6 +58,7 @@
 		bool AllowResourceTransfer(int oldTeam, int newTeam,
 		                           const string&amp; type, float amount);
 		bool AllowDirectUnitControl(int playerID, const CUnit* unit);
+		bool AllowStartPosition(int playerID, const float3&amp; pos);
 
 		bool MoveCtrlNotify(const CUnit* unit, int data);
 
@@ -115,6 +116,7 @@
 		bool haveAllowResourceLevel;
 		bool haveAllowResourceTransfer;
 		bool haveAllowDirectUnitControl;
+		bool haveAllowStartPosition;
 		bool haveMoveCtrlNotify;
 		bool haveBuilderTerraformComplete;
 		bool haveDrawUnit;

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -121,6 +121,7 @@
 	REGISTER_LUA_CFUNC(SetUnitLosState);
 	REGISTER_LUA_CFUNC(SetUnitCloak);
 	REGISTER_LUA_CFUNC(SetUnitStealth);
+	REGISTER_LUA_CFUNC(SetUnitSonarStealth);
 	REGISTER_LUA_CFUNC(SetUnitAlwaysVisible);
 	REGISTER_LUA_CFUNC(SetUnitMetalExtraction);
 	REGISTER_LUA_CFUNC(SetUnitBuildSpeed);
@@ -1337,6 +1338,21 @@
 }
 
 
+int LuaSyncedCtrl::SetUnitSonarStealth(lua_State* L)
+{
+	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
+	if (unit == NULL) {
+		return 0;
+	}
+	const int args = lua_gettop(L); // number of arguments
+	if ((args &lt; 2) || !lua_isboolean(L, 2)) {
+		luaL_error(L, &quot;Incorrect arguments to SetUnitSonarStealth()&quot;);
+	}
+	unit-&gt;sonarStealth = lua_toboolean(L, 2);
+	return 0;
+}
+
+
 int LuaSyncedCtrl::SetUnitAlwaysVisible(lua_State* L)
 {
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);

Modified: branches/gml/rts/Lua/LuaSyncedCtrl.h
===================================================================
--- branches/gml/rts/Lua/LuaSyncedCtrl.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaSyncedCtrl.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -60,6 +60,7 @@
 		static int SetUnitLosState(lua_State* L);
 		static int SetUnitCloak(lua_State* L);
 		static int SetUnitStealth(lua_State* L);
+		static int SetUnitSonarStealth(lua_State* L);
 		static int SetUnitAlwaysVisible(lua_State* L);
 		static int SetUnitMetalExtraction(lua_State* L);
 		static int SetUnitBuildSpeed(lua_State* L);

Modified: branches/gml/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaSyncedRead.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1130,7 +1130,8 @@
 			count++;
 			lua_pushnumber(L, count);
 			lua_newtable(L); {
-				HSTR_PUSH_NUMBER(L, &quot;frame&quot;,            (start + 1) * statsFrames);
+				HSTR_PUSH_NUMBER(L, &quot;time&quot;,             i * CTeam::statsPeriod);
+				HSTR_PUSH_NUMBER(L, &quot;frame&quot;,            i * statsFrames);
 				HSTR_PUSH_NUMBER(L, &quot;metalUsed&quot;,        stats.metalUsed);
 				HSTR_PUSH_NUMBER(L, &quot;metalProduced&quot;,    stats.metalProduced);
 				HSTR_PUSH_NUMBER(L, &quot;metalExcess&quot;,      stats.metalExcess);
@@ -4140,7 +4141,7 @@
 	}
 	float3 dir(0,0,0);
 	float3 pos(0,0,0);
-	localModel-&gt;GetRawEmitDirPos(piece,pos,dir);
+	localModel-&gt;GetRawEmitDirPos(piece, pos, dir);
 	pos = unit-&gt;pos + unit-&gt;frontdir * pos.z
 	                + unit-&gt;updir    * pos.y
 	                + unit-&gt;rightdir * pos.x;

Modified: branches/gml/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaUnitDefs.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -157,7 +157,7 @@
 	ParamMap::const_iterator it = paramMap.find(name);
 
 	// not a default value
-	if (paramMap.find(name) == paramMap.end()) {
+	if (it == paramMap.end()) {
 	  lua_rawget(L, 1);
 	  return 1;
 	}
@@ -210,7 +210,7 @@
 	ParamMap::const_iterator it = paramMap.find(name);
 
 	// not a default value, set it
-	if (paramMap.find(name) == paramMap.end()) {
+	if (it == paramMap.end()) {
 		lua_rawset(L, 1);
 		return 0;
 	}
@@ -724,7 +724,8 @@
 
 	ADD_FLOAT(&quot;seismicSignature&quot;, ud.seismicSignature);
 
-	ADD_BOOL(&quot;stealth&quot;, ud.stealth);
+	ADD_BOOL(&quot;stealth&quot;,      ud.stealth);
+	ADD_BOOL(&quot;sonarStealth&quot;, ud.sonarStealth);
 
 	ADD_FLOAT(&quot;mass&quot;, ud.mass);
 

Modified: branches/gml/rts/Lua/LuaWeaponDefs.cpp
===================================================================
--- branches/gml/rts/Lua/LuaWeaponDefs.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Lua/LuaWeaponDefs.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -123,7 +123,7 @@
 	ParamMap::const_iterator it = paramMap.find(name);
 
 	// not a default value
-	if (paramMap.find(name) == paramMap.end()) {
+	if (it == paramMap.end()) {
 		lua_rawget(L, 1);
 		return 1;
 	}
@@ -176,7 +176,7 @@
 	ParamMap::const_iterator it = paramMap.find(name);
 
 	// not a default value, set it
-	if (paramMap.find(name) == paramMap.end()) {
+	if (it == paramMap.end()) {
 		lua_rawset(L, 1);
 		return 0;
 	}

Modified: branches/gml/rts/Map/BasicMapDamage.cpp
===================================================================
--- branches/gml/rts/Map/BasicMapDamage.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/BasicMapDamage.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -155,15 +155,15 @@
 	for(int y=y1/2;y&lt;=hy2;y++)
 		for(int x=x1/2;x&lt;=hx2;x++)
 			readmap-&gt;mipHeightmap[1][y*gs-&gt;hmapx+x]=heightmap[(y*2+1)*(gs-&gt;mapx+1)+(x*2+1)];*/
-	for(int i=0; i&lt;readmap-&gt;numHeightMipMaps-1; i++){
-		int hmapx = gs-&gt;mapx&gt;&gt;i;
-		for(int y=(y1&gt;&gt;i)&amp;(~1);y&lt;y2&gt;&gt;i;y+=2){
-			for(int x=(x1&gt;&gt;i)&amp;(~1);x&lt;x2&gt;&gt;i;x+=2){
+	for (int i = 0; i &lt; readmap-&gt;numHeightMipMaps - 1; i++) {
+		int hmapx = gs-&gt;mapx &gt;&gt; i;
+		for (int y = ((y1 &gt;&gt; i) &amp; (~1)); y &lt; (y2 &gt;&gt; i); y += 2) {
+			for (int x = ((x1 &gt;&gt; i) &amp; (~1)); x &lt; (x2 &gt;&gt; i); x += 2) {
 				float height = readmap-&gt;mipHeightmap[i][(x)+(y)*hmapx];
-				height += readmap-&gt;mipHeightmap[i][(x)+(y+1)*hmapx];
-				height += readmap-&gt;mipHeightmap[i][(x+1)+(y)*hmapx];
+				height += readmap-&gt;mipHeightmap[i][(x)  +(y+1)*hmapx];
+				height += readmap-&gt;mipHeightmap[i][(x+1)+(y)  *hmapx];
 				height += readmap-&gt;mipHeightmap[i][(x+1)+(y+1)*hmapx];
-				readmap-&gt;mipHeightmap[i+1][(x/2)+(y/2)*hmapx/2] = height/4.0f;
+				readmap-&gt;mipHeightmap[i+1][(x/2)+(y/2)*hmapx/2] = height * 0.25f;
 			}
 		}
 	}
@@ -174,66 +174,65 @@
 	int decx=std::max(0,x1-1);
 	int incx=std::min(gs-&gt;mapx-1,x2+1);
 
-	for(int y=decy;y&lt;=incy;y++) {
-		for(int x=decx;x&lt;=incx;x++)
-		{
+	for (int y = decy; y &lt;= incy; y++) {
+		for (int x = decx; x &lt;= incx; x++) {
 			float3 e1(-SQUARE_SIZE,heightmap[y*(gs-&gt;mapx+1)+x]-heightmap[y*(gs-&gt;mapx+1)+x+1],0);
 			float3 e2( 0,heightmap[y*(gs-&gt;mapx+1)+x]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],-SQUARE_SIZE);
 
 			float3 n=e2.cross(e1);
 			n.Normalize();
 
-			readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2]=n;
+			readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2] = n;
 
-			e1=float3( SQUARE_SIZE,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],0);
-			e2=float3( 0,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y)*(gs-&gt;mapx+1)+x+1],SQUARE_SIZE);
+			e1 = float3( SQUARE_SIZE,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y+1)*(gs-&gt;mapx+1)+x],0);
+			e2 = float3( 0,heightmap[(y+1)*(gs-&gt;mapx+1)+x+1]-heightmap[(y)*(gs-&gt;mapx+1)+x+1],SQUARE_SIZE);
 
-			n=e2.cross(e1);
+			n = e2.cross(e1);
 			n.Normalize();
 
-			readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2+1]=n;
+			readmap-&gt;facenormals[(y*gs-&gt;mapx+x)*2+1] = n;
 		}
 	}
 
-	for(int y=std::max(2,(y1&amp;0xfffffe));y&lt;=std::min(gs-&gt;mapy-3,y2);y+=2)
-	{
-		for(int x=std::max(2,(x1&amp;0xfffffe));x&lt;=std::min(gs-&gt;mapx-3,x2);x+=2)
-		{
+	for(int y = std::max(2,(y1&amp;0xfffffe)); y &lt;= std::min(gs-&gt;mapy-3,y2); y += 2) {
+		for(int x = std::max(2,(x1&amp;0xfffffe)); x &lt;= std::min(gs-&gt;mapx-3,x2); x += 2) {
 			float3 e1(-SQUARE_SIZE*4,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],0);
 			float3 e2( 0,heightmap[(y-1)*(gs-&gt;mapx+1)+x-1]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],-SQUARE_SIZE*4);
 
-			float3 n=e2.cross(e1);
+			float3 n = e2.cross(e1);
 			n.Normalize();
 
-			e1=float3( SQUARE_SIZE*4,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],0);
-			e2=float3( 0,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],SQUARE_SIZE*4);
+			e1 = float3( SQUARE_SIZE*4,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y+3)*(gs-&gt;mapx+1)+x-1],0);
+			e2 = float3( 0,heightmap[(y+3)*(gs-&gt;mapx+1)+x+3]-heightmap[(y-1)*(gs-&gt;mapx+1)+x+3],SQUARE_SIZE*4);
 
-			float3 n2=e2.cross(e1);
+			float3 n2 = e2.cross(e1);
 			n2.Normalize();
 
-			readmap-&gt;slopemap[(y/2)*gs-&gt;hmapx+(x/2)]=1-(n.y+n2.y)*0.5f;
+			readmap-&gt;slopemap[(y/2)*gs-&gt;hmapx+(x/2)] = 1-(n.y+n2.y)*0.5f;
 		}
 	}
-	pathManager-&gt;TerrainChange(x1,y1,x2,y2);
-	featureHandler-&gt;TerrainChanged(x1,y1,x2,y2);
-	readmap-&gt;HeightmapUpdated(x1,x2,y1,y2);
 
-	decy=std::max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incy=std::min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
-	decx=std::max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
-	incx=std::min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	pathManager-&gt;TerrainChange(x1, y1, x2, y2);
+	featureHandler-&gt;TerrainChanged(x1, y1, x2, y2);
+	readmap-&gt;HeightmapUpdated(x1, x2, y1, y2);
 
-	for(int y=decy;y&lt;=incy;y++){
-		for(int x=decx;x&lt;=incx;x++){
-			if(inRelosQue[y*qf-&gt;GetNumQuadsX()+x])
+	decy = std::max(0,(y1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
+	incy = std::min(qf-&gt;GetNumQuadsZ()-1,(y2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+	decx = std::max(0,(x1*SQUARE_SIZE-QUAD_SIZE/2)/QUAD_SIZE);
+	incx = std::min(qf-&gt;GetNumQuadsX()-1,(x2*SQUARE_SIZE+QUAD_SIZE/2)/QUAD_SIZE);
+
+	for (int y = decy; y &lt;= incy; y++) {
+		for (int x = decx; x &lt;= incx; x++) {
+			if (inRelosQue[y*qf-&gt;GetNumQuadsX()+x]) {
 				continue;
+			}
 			RelosSquare rs;
-			rs.x=x;
-			rs.y=y;
-			rs.neededUpdate=gs-&gt;frameNum;
+			rs.x = x;
+			rs.y = y;
+			rs.neededUpdate = gs-&gt;frameNum;
 			rs.numUnits = qf-&gt;GetQuadAt(x, y).units.size();
-			relosSize+=rs.numUnits;
-			inRelosQue[y*qf-&gt;GetNumQuadsX()+x]=true;
+			relosSize += rs.numUnits;
+			inRelosQue[y*qf-&gt;GetNumQuadsX()+x] = true;
 			relosQue.push_back(rs);
 		}
 	}

Modified: branches/gml/rts/Map/MapInfo.cpp
===================================================================
--- branches/gml/rts/Map/MapInfo.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/MapInfo.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,10 +1,16 @@
+#include &quot;StdAfx.h&quot;
+
 #include &quot;MapInfo.h&quot;
 
+#include &quot;MapParser.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;System/LogOutput.h&quot;
-#include &quot;System/TdfParser.h&quot;
 #include &quot;System/FileSystem/FileHandler.h&quot;
 
+
+using namespace std;
+
+
 float4::float4()
 {
 	float tmp[4];
@@ -27,16 +33,26 @@
 const CMapInfo* mapInfo;
 
 
-CMapInfo::CMapInfo(const std::string&amp; mapname)
+CMapInfo::CMapInfo(const string&amp; mapName)
 {
-	map.name = mapname;
-	mapDefParser = new TdfParser(GetTDFName(mapname));
-	resourcesParser = new LuaParser (&quot;gamedata/resources.lua&quot;,
-	                                 SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
-	if (!resourcesParser-&gt;Execute()) {
-		logOutput.Print(resourcesParser-&gt;GetErrorLog());
+	map.name = mapName;
+
+	MapParser mapParser(mapName);
+	if (!mapParser.IsValid()) {
+		throw content_error(&quot;MapInfo: &quot; + mapParser.GetErrorLog());
 	}
-	
+
+	LuaTable mapTbl = mapParser.GetRoot();
+	mapRoot = &mapTbl;
+
+	LuaParser resParser(&quot;gamedata/resources.lua&quot;,
+	                    SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
+	if (!resParser.Execute()) {
+		logOutput.Print(resParser.GetErrorLog());
+	}
+	LuaTable resTbl = resParser.GetRoot();
+	resRoot = &resTbl;
+
 	ReadGlobal();
 	ReadAtmosphere();
 	ReadGui();
@@ -45,197 +61,257 @@
 	ReadSmf();
 	ReadSm3();
 	ReadTerrainTypes();
-
-	delete resourcesParser;
-	resourcesParser = NULL;
 }
 
 
 CMapInfo::~CMapInfo()
 {
-	delete mapDefParser;
-	mapDefParser = NULL;
 }
 
 
-/** @brief Opens the TDF file from the given map in parser.
-	FIXME: This is mostly a hack to supply CGameSetup with start positions,
-	when no CMapInfo object has yet been created.
- */
-void CMapInfo::OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser)
-{
-	parser.LoadFile(GetTDFName(mapname));
-}
-
-
-/** @brief Get the name of the TDF file with map settings.
-	@return &quot;maps/%.smd&quot; for &quot;%.smf&quot; and &quot;maps/%.sm3&quot; for &quot;%.sm3&quot;
- */
-std::string CMapInfo::GetTDFName(const std::string&amp; mapname)
-{
-	if (mapname.length() &lt; 3)
-		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): mapname '&quot; + mapname + &quot;' too short&quot;);
-
-	std::string extension = mapname.substr(mapname.length() - 3);
-	if (extension == &quot;smf&quot;)
-		return std::string(&quot;maps/&quot;) + mapname.substr(0, mapname.find_last_of('.')) + &quot;.smd&quot;;
-	else if(extension == &quot;sm3&quot;)
-		return std::string(&quot;maps/&quot;) + mapname;
-	else
-		throw std::runtime_error(&quot;CMapInfo::GetTDFName(): Unknown extension: &quot; + extension);
-}
-
-
 void CMapInfo::ReadGlobal()
 {
-	map.humanName = mapDefParser-&gt;SGetValueDef(map.name, &quot;MAP\\Description&quot;);
-	map.wantedScript = mapDefParser-&gt;SGetValueDef(map.wantedScript, &quot;MAP\\Script&quot;);
+	const LuaTable topTable = *mapRoot;
+	
+	map.humanName    = topTable.GetString(&quot;description&quot;, map.name);
+	map.wantedScript = topTable.GetString(&quot;script&quot;, map.wantedScript);
 
-	mapDefParser-&gt;GetTDef(map.hardness, 100.0f, &quot;MAP\\MapHardness&quot;);
-	map.notDeformable = mapDefParser-&gt;SGetValueDef(&quot;0&quot;, &quot;MAP\\NotDeformable&quot;) != &quot;0&quot;;
+	map.hardness      = topTable.GetFloat(&quot;maphardness&quot;, 100.0f);
+	map.notDeformable = topTable.GetBool(&quot;notDeformable&quot;, false);
 
-	mapDefParser-&gt;GetTDef(map.gravity, 130.0f, &quot;MAP\\Gravity&quot;);
+	map.gravity = topTable.GetFloat(&quot;gravity&quot;, 130.0f);
+	map.gravity = max(0.001f, map.gravity);
 	map.gravity = -map.gravity / (GAME_SPEED * GAME_SPEED);
 
-	mapDefParser-&gt;GetTDef(map.tidalStrength, 0.0f, &quot;MAP\\TidalStrength&quot;);
-	mapDefParser-&gt;GetTDef(map.maxMetal, 0.02f, &quot;MAP\\MaxMetal&quot;);
-	mapDefParser-&gt;GetTDef(map.extractorRadius, 500.0f, &quot;MAP\\ExtractorRadius&quot;);
+	map.tidalStrength   = topTable.GetFloat(&quot;tidalStrength&quot;, 0.0f);
+	map.maxMetal        = topTable.GetFloat(&quot;maxMetal&quot;, 0.02f);
+	map.extractorRadius = topTable.GetFloat(&quot;extractorRadius&quot;, 500.0f);
 
-	mapDefParser-&gt;GetDef(map.voidWater, &quot;0&quot;, &quot;MAP\\voidWater&quot;);
+	map.voidWater = topTable.GetBool(&quot;voidWater&quot;, false);
+
+	// clamps
+	map.hardness        = max(0.0f, map.hardness);
+	map.tidalStrength   = max(0.0f, map.tidalStrength);
+	map.maxMetal        = max(0.0f, map.maxMetal);
+	map.extractorRadius = max(0.0f, map.extractorRadius);
 }
 
 
 void CMapInfo::ReadGui()
 {
 	// GUI
-	mapDefParser-&gt;GetTDef(gui.autoShowMetal, true, &quot;MAP\\autoShowMetal&quot;);
+	gui.autoShowMetal = mapRoot-&gt;GetBool(&quot;autoShowMetal&quot;, true);
 }
 
 
 void CMapInfo::ReadAtmosphere()
 {
 	// MAP\ATMOSPHERE
-	mapDefParser-&gt;GetTDef(atmosphere.cloudDensity, 0.5f, &quot;MAP\\ATMOSPHERE\\CloudDensity&quot;);
-	mapDefParser-&gt;GetTDef(atmosphere.fogStart, 0.1f, &quot;MAP\\ATMOSPHERE\\FogStart&quot;);
-	atmosphere.fogColor = mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.8f), &quot;MAP\\ATMOSPHERE\\FogColor&quot;);
-	atmosphere.skyColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.15f, 0.7f), &quot;MAP\\ATMOSPHERE\\SkyColor&quot;);
-	atmosphere.sunColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\SunColor&quot;);
-	atmosphere.cloudColor = mapDefParser-&gt;GetFloat3(float3(1.0f, 1.0f, 1.0f), &quot;MAP\\ATMOSPHERE\\CloudColor&quot;);
-	mapDefParser-&gt;GetTDef(atmosphere.minWind, 5.0f, &quot;MAP\\ATMOSPHERE\\MinWind&quot;);
-	mapDefParser-&gt;GetTDef(atmosphere.maxWind, 25.0f, &quot;MAP\\ATMOSPHERE\\MaxWind&quot;);
-	mapDefParser-&gt;GetDef(atmosphere.skyBox, &quot;&quot;, &quot;MAP\\ATMOSPHERE\\SkyBox&quot;);
+	const LuaTable atmoTable = mapRoot-&gt;SubTable(&quot;atmosphere&quot;);
+	atmosphere_t&amp; atmo = atmosphere;
+	atmo.cloudDensity = atmoTable.GetFloat(&quot;cloudDensity&quot;, 0.5f);
+	atmo.minWind      = atmoTable.GetFloat(&quot;minWind&quot;, 5.0f);
+	atmo.maxWind      = atmoTable.GetFloat(&quot;maxWind&quot;, 25.0f);
+	atmo.fogStart     = atmoTable.GetFloat(&quot;fogStart&quot;, 0.1f);
+	atmo.fogColor   = atmoTable.GetFloat3(&quot;fogColor&quot;, float3(0.7f, 0.7f, 0.8f));
+	atmo.skyColor   = atmoTable.GetFloat3(&quot;skyColor&quot;, float3(0.1f, 0.15f, 0.7f));
+	atmo.sunColor   = atmoTable.GetFloat3(&quot;sunColor&quot;, float3(1.0f, 1.0f, 1.0f));
+	atmo.cloudColor = atmoTable.GetFloat3(&quot;cloudColor&quot;, float3(1.0f, 1.0f, 1.0f));
+	atmo.skyBox = atmoTable.GetString(&quot;skyBox&quot;, &quot;&quot;);
+
+	// clamps
+	atmo.cloudDensity = max(0.0f, atmo.cloudDensity);
+	atmo.maxWind      = max(0.0f, atmo.maxWind);
+	atmo.minWind      = max(0.0f, atmo.minWind);
+	atmo.minWind      = min(atmo.maxWind, atmo.minWind);
 }
 
 
 void CMapInfo::ReadLight()
 {
-	// MAP\LIGHT
-	light.sunDir = mapDefParser-&gt;GetFloat3(float3(0.0f, 1.0f, 2.0f), &quot;MAP\\LIGHT\\SunDir&quot;);
+	const LuaTable lightTable = mapRoot-&gt;SubTable(&quot;lighting&quot;);
+
+	light.sunDir = lightTable.GetFloat3(&quot;sunDir&quot;, float3(0.0f, 1.0f, 2.0f));
 	light.sunDir.Normalize();
 
-	light.groundAmbientColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundAmbientColor&quot;);
-	light.groundSunColor = mapDefParser-&gt;GetFloat3(float3(0.5f, 0.5f, 0.5f), &quot;MAP\\LIGHT\\GroundSunColor&quot;);
-	light.groundSpecularColor = mapDefParser-&gt;GetFloat3(float3(0.1f, 0.1f, 0.1f), &quot;MAP\\LIGHT\\GroundSpecularColor&quot;);
-	mapDefParser-&gt;GetTDef(light.groundShadowDensity, 0.8f, &quot;MAP\\LIGHT\\GroundShadowDensity&quot;);
+	light.groundAmbientColor  = lightTable.GetFloat3(&quot;groundAmbientColor&quot;,
+	                                                float3(0.5f, 0.5f, 0.5f));
+	light.groundSunColor      = lightTable.GetFloat3(&quot;groundDiffuseColor&quot;,
+	                                                float3(0.5f, 0.5f, 0.5f));
+	light.groundSpecularColor = lightTable.GetFloat3(&quot;groundSpecularColor&quot;,
+	                                                float3(0.1f, 0.1f, 0.1f));
+	light.groundShadowDensity = lightTable.GetFloat(&quot;groundShadowDensity&quot;, 0.8f);
 
-	light.unitAmbientColor = float4(mapDefParser-&gt;GetFloat3(float3(0.4f, 0.4f, 0.4f), &quot;MAP\\LIGHT\\UnitAmbientColor&quot;), 1.0f);
-	light.unitSunColor = float4(mapDefParser-&gt;GetFloat3(float3(0.7f, 0.7f, 0.7f), &quot;MAP\\LIGHT\\UnitSunColor&quot;), 1.0f);
-	light.specularSunColor = mapDefParser-&gt;GetFloat3(light.unitSunColor, &quot;MAP\\LIGHT\\SpecularSunColor&quot;);
-	mapDefParser-&gt;GetTDef(light.unitShadowDensity, 0.8f, &quot;MAP\\LIGHT\\UnitShadowDensity&quot;);
+	light.unitAmbientColor  = lightTable.GetFloat3(&quot;unitAmbientColor&quot;,
+	                                                float3(0.4f, 0.4f, 0.4f));
+	light.unitSunColor      = lightTable.GetFloat3(&quot;unitDiffuseColor&quot;,
+	                                                float3(0.7f, 0.7f, 0.7f));
+	light.specularSunColor = lightTable.GetFloat3(&quot;unitSpecularColor&quot;,
+	                                               light.unitSunColor);
+	light.unitShadowDensity = lightTable.GetFloat(&quot;unitShadowDensity&quot;, 0.8f);
 }
 
 
 void CMapInfo::ReadWater()
 {
-	// MAP\WATER
-	mapDefParser-&gt;GetTDef(water.repeatX, 0.0f, &quot;MAP\\WATER\\WaterRepeatX&quot;);
-	mapDefParser-&gt;GetTDef(water.repeatY, 0.0f, &quot;MAP\\WATER\\WaterRepeatY&quot;);
-	mapDefParser-&gt;GetTDef(water.damage, 0.0f, &quot;MAP\\WATER\\WaterDamage&quot;);
-	water.damage *= 16.0f / 30.0f;
-	
-	std::string tmp;
-	mapDefParser-&gt;GetDef(tmp, &quot;&quot;, &quot;MAP\\WATER\\WaterPlaneColor&quot;);
-	hasWaterPlane = !tmp.empty();
-	water.planeColor = mapDefParser-&gt;GetFloat3(float3(0.0f, 0.4f, 0.0f), &quot;MAP\\WATER\\WaterPlaneColor&quot;);
+	const LuaTable wt = mapRoot-&gt;SubTable(&quot;water&quot;);
 
-	mapDefParser-&gt;GetDef(water.fresnelMin,&quot;0.2&quot;,&quot;MAP\\WATER\\FresnelMin&quot;);
-	mapDefParser-&gt;GetDef(water.fresnelMax,&quot;0.3&quot;,&quot;MAP\\WATER\\FresnelMax&quot;);
-	mapDefParser-&gt;GetDef(water.fresnelPower,&quot;4.0&quot;,&quot;MAP\\WATER\\FresnelPower&quot;);
+	water.repeatX = wt.GetFloat(&quot;repeatX&quot;, 0.0f);
+	water.repeatY = wt.GetFloat(&quot;repeatY&quot;, 0.0f);
+	water.damage  = wt.GetFloat(&quot;damage&quot;,  0.0f) * (16.0f / 30.0f);
 
-	mapDefParser-&gt;GetDef(water.specularFactor,&quot;20.0&quot;,&quot;MAP\\WATER\\WaterSpecularFactor&quot;);
+	water.absorb    = wt.GetFloat3(&quot;absorb&quot;,    float3(0.0f, 0.0f, 0.0f));
+	water.baseColor = wt.GetFloat3(&quot;baseColor&quot;, float3(0.0f, 0.0f, 0.0f));
+	water.minColor  = wt.GetFloat3(&quot;minColor&quot;,  float3(0.0f, 0.0f, 0.0f));
 
-	water.specularColor = mapDefParser-&gt;GetFloat3(light.groundSunColor,&quot;MAP\\WATER\\WaterSpecularColor&quot;);
-	water.surfaceColor = mapDefParser-&gt;GetFloat3(float3(0.75f, 0.8f, 0.85f), &quot;MAP\\WATER\\WaterSurfaceColor&quot;);
-	mapDefParser-&gt;GetDef(water.surfaceAlpha,&quot;0.55&quot;,&quot;MAP\\WATER\\WaterSurfaceAlpha&quot;);
-	water.absorb = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterAbsorb&quot;);
-	water.baseColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterBaseColor&quot;);
-	water.minColor = mapDefParser-&gt;GetFloat3(float3(0, 0, 0), &quot;MAP\\WATER\\WaterMinColor&quot;);
+	water.surfaceColor = wt.GetFloat3(&quot;surfaceColor&quot;, float3(0.75f, 0.8f, 0.85f));
+	water.surfaceAlpha = wt.GetFloat(&quot;surfaceAlpha&quot;,  0.55f);
 
-	mapDefParser-&gt;GetDef(water.texture, &quot;&quot;, &quot;MAP\\WATER\\WaterTexture&quot;);
-	mapDefParser-&gt;GetDef(water.foamTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterFoamTexture&quot;);
-	mapDefParser-&gt;GetDef(water.normalTexture, &quot;&quot;, &quot;MAP\\WATER\\WaterNormalTexture&quot;);
+	water.planeColor = wt.GetFloat3(&quot;planeColor&quot;, float3(0.0f, 0.4f, 0.0f));
+	hasWaterPlane    = wt.KeyExists(&quot;planeColor&quot;);
 
-	//default water is ocean.jpg in bitmaps, map specific water textures is saved in the map dir
-	const LuaTable mapsTable = resourcesParser-&gt;GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
-	const LuaTable causticsTable = resourcesParser-&gt;GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;caustics&quot;);
-	
-	if(water.texture.empty())
-		water.texture = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;watertex&quot;, &quot;ocean.jpg&quot;);
-	else
+	water.specularColor  = wt.GetFloat3(&quot;specularColor&quot;, light.groundSunColor);
+	water.specularFactor = wt.GetFloat(&quot;specularFactor&quot;, 20.0f);
+
+	water.fresnelMin   = wt.GetFloat(&quot;fresnelMin&quot;,   0.2f);
+	water.fresnelMax   = wt.GetFloat(&quot;fresnelMax&quot;,   0.3f);
+	water.fresnelPower = wt.GetFloat(&quot;fresnelPower&quot;, 4.0f);
+
+	water.texture       = wt.GetString(&quot;texture&quot;,       &quot;&quot;);
+	water.foamTexture   = wt.GetString(&quot;foamTexture&quot;,   &quot;&quot;);
+	water.normalTexture = wt.GetString(&quot;normalTexture&quot;, &quot;&quot;);
+
+	// use 'resources.lua' for missing fields  (our the engine defaults)
+	const LuaTable resGfxMaps = resRoot-&gt;SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
+
+	if (!water.texture.empty()) {
 		water.texture = &quot;maps/&quot; + water.texture;
+	} else {
+		water.texture = &quot;bitmaps/&quot; + resGfxMaps.GetString(&quot;watertex&quot;, &quot;ocean.jpg&quot;);
+	}
 
-	if(water.foamTexture.empty())
-		water.foamTexture = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;waterfoamtex&quot;, &quot;foam.jpg&quot;);
-	else
+	if (!water.foamTexture.empty()) {
 		water.foamTexture = &quot;maps/&quot; + water.foamTexture;
+	} else {
+		water.foamTexture = &quot;bitmaps/&quot; + resGfxMaps.GetString(&quot;waterfoamtex&quot;, &quot;foam.jpg&quot;);
+	}
 
-	if(water.normalTexture.empty())
-		water.normalTexture = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;waternormaltex&quot;, &quot;waterbump.png&quot;);
-	else
+	if (!water.normalTexture.empty()) {
 		water.normalTexture = &quot;maps/&quot; + water.normalTexture;
+	} else {
+		water.normalTexture = &quot;bitmaps/&quot; + resGfxMaps.GetString(&quot;waternormaltex&quot;, &quot;waterbump.png&quot;);
+	}
 
-	char num[10];
-	for (int i = 0; i &lt; causticTextureCount; i++) {
-		sprintf(num, &quot;%02i&quot;, i);
-		water.causticTextures[i] = std::string(&quot;bitmaps/&quot;) + causticsTable.GetString(std::string(&quot;caustic&quot;)+num, 
-															 std::string(&quot;caustic&quot;)+num+&quot;.jpg&quot;);
+	// water caustic textures
+	LuaTable caustics = wt.SubTable(&quot;caustics&quot;);
+	string causticPrefix = &quot;maps/&quot;;
+	if (!caustics.IsValid()) {
+		caustics = resRoot-&gt;SubTable(&quot;graphics&quot;).SubTable(&quot;caustics&quot;);
+		causticPrefix = &quot;bitmaps/&quot;;
 	}
+	if (caustics.IsValid()) {
+		for (int i = 1; true; i++) {
+			const string texName = caustics.GetString(i, &quot;&quot;);
+			if (texName.empty()) {
+				break;
+			}
+			water.causticTextures.push_back(causticPrefix + texName);
+		}
+	} else {
+		// load the default 32 textures
+		for (int i = 0; i &lt; 32; i++) {
+			char defTex[256];
+			sprintf(defTex, &quot;bitmaps/caustics/caustic%02i.jpg&quot;, i);
+			water.causticTextures.push_back(defTex);
+		}
+	}
 }
 
 
 void CMapInfo::ReadSmf()
 {
 	// SMF specific settings
-	mapDefParser-&gt;GetDef(smf.detailTexName, &quot;&quot;, &quot;MAP\\DetailTex&quot;);
-
-	const LuaTable mapsTable = resourcesParser-&gt;GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
-	
-	if (smf.detailTexName.empty())
-		smf.detailTexName = &quot;bitmaps/&quot; + mapsTable.GetString(&quot;detailtex&quot;,&quot;detailtex2.bmp&quot;);
-	else
+	const LuaTable mapResTable = mapRoot-&gt;SubTable(&quot;resources&quot;);
+	smf.detailTexName = mapResTable.GetString(&quot;detailTex&quot;, &quot;&quot;);
+	if (!smf.detailTexName.empty()) {
 		smf.detailTexName = &quot;maps/&quot; + smf.detailTexName;
+	}
+	else {
+		const LuaTable resGfxMaps = resRoot-&gt;SubTable(&quot;graphics&quot;).SubTable(&quot;maps&quot;);
+		smf.detailTexName = resGfxMaps.GetString(&quot;detailtex&quot;, &quot;detailtex2.bmp&quot;);
+		smf.detailTexName = &quot;bitmaps/&quot; + smf.detailTexName;
+	}
 }
 
 
 void CMapInfo::ReadSm3()
 {
 	// SM3 specific settings
-	sm3.minimap = mapDefParser-&gt;SGetValueDef(&quot;&quot;, &quot;MAP\\minimap&quot;);
+	sm3.minimap = mapRoot-&gt;GetString(&quot;minimap&quot;, &quot;&quot;);
 }
 
 
 void CMapInfo::ReadTerrainTypes()
 {
-	for (int a = 0; a &lt; 256; ++a) {
-		char tname[200];
-		sprintf(tname, &quot;MAP\\TerrainType%i\\&quot;, a);
-		std::string section = tname;
-		mapDefParser-&gt;GetDef (terrainTypes[a].name,  &quot;Default&quot;, section + &quot;name&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].hardness,   1.0f, section + &quot;hardness&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].tankSpeed,  1.0f, section + &quot;tankmovespeed&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].kbotSpeed,  1.0f, section + &quot;kbotmovespeed&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].hoverSpeed, 1.0f, section + &quot;hovermovespeed&quot;);
-		mapDefParser-&gt;GetTDef(terrainTypes[a].shipSpeed,  1.0f, section + &quot;shipmovespeed&quot;);
-		mapDefParser-&gt;GetDef(terrainTypes[a].receiveTracks, &quot;1&quot;, section + &quot;receivetracks&quot;);
+	const LuaTable terrTypeTable =
+		mapRoot-&gt;SubTable(&quot;terrainTypes&quot;);
+
+	for (int tt = 0; tt &lt; 256; tt++) {
+		TerrainType&amp; terrType = terrainTypes[tt];
+		const LuaTable terrain = terrTypeTable.SubTable(tt);
+		terrType.name          = terrain.GetString(&quot;name&quot;, &quot;Default&quot;);
+		terrType.hardness      = terrain.GetFloat(&quot;hardness&quot;,   1.0f);
+		terrType.receiveTracks = terrain.GetBool(&quot;receiveTracks&quot;, true);
+		const LuaTable moveTable = terrain.SubTable(&quot;moveSpeeds&quot;);
+		terrType.tankSpeed  = moveTable.GetFloat(&quot;tank&quot;,  1.0f);
+		terrType.kbotSpeed  = moveTable.GetFloat(&quot;kbot&quot;,  1.0f);
+		terrType.hoverSpeed = moveTable.GetFloat(&quot;hover&quot;, 1.0f);
+		terrType.shipSpeed  = moveTable.GetFloat(&quot;ship&quot;,  1.0f);
+
+		// clamps
+		terrType.hardness   = max(0.0f, terrType.hardness);
+		terrType.tankSpeed  = max(0.0f, terrType.tankSpeed);
+		terrType.kbotSpeed  = max(0.0f, terrType.kbotSpeed);
+		terrType.hoverSpeed = max(0.0f, terrType.hoverSpeed);
+		terrType.shipSpeed  = max(0.0f, terrType.shipSpeed);
 	}
 }
+
+
+void CMapInfo::ReadStartPos()
+{
+	const float defX = 1000.0f;
+	const float defZ = 1000.0f;
+	const float defXStep = 100.0f;
+	const float defZStep = 100.0f;
+
+	const LuaTable teamsTable = mapRoot-&gt;SubTable(&quot;teams&quot;);
+
+	for (int t = 0; t &lt; MAX_TEAMS; ++t) {
+		float3 pos;
+		pos.x = defX + (defXStep * t);
+		pos.z = defZ + (defZStep * t);
+		pos.y = 0.0f;
+		const LuaTable posTable = teamsTable.SubTable(t).SubTable(&quot;startPos&quot;);
+		if (posTable.KeyExists(&quot;x&quot;) &amp;&amp;
+		    posTable.KeyExists(&quot;z&quot;)) {
+			pos.x = posTable.GetFloat(&quot;x&quot;, pos.x);
+			pos.z = posTable.GetFloat(&quot;z&quot;, pos.z);
+			havePos.push_back(true);
+		} else {
+			havePos.push_back(false);
+		}
+		startPos.push_back(pos);		
+	}
+}
+
+
+bool CMapInfo::GetStartPos(int team, float3&amp; pos) const
+{
+	if ((team &lt; 0) || (team &gt;= startPos.size()) || !havePos[team]) {
+		return false;
+	}
+	pos = startPos[team];
+	return true;
+}
+

Modified: branches/gml/rts/Map/MapInfo.h
===================================================================
--- branches/gml/rts/Map/MapInfo.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/MapInfo.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -2,10 +2,10 @@
 #define MAPINFO_H
 
 #include &lt;string&gt;
+#include &lt;vector&gt;
 #include &quot;float3.h&quot;
 
-class TdfParser;
-class LuaParser;
+class LuaTable;
 
 
 /** Float3 with a fourth data member, which is basically unused but required
@@ -27,16 +27,9 @@
 {
 public:
 
-	static void OpenTDF(const std::string&amp; mapname, TdfParser&amp; parser);
-	static std::string GetTDFName(const std::string&amp; mapname);
-
-	CMapInfo(const std::string&amp; mapname);
+	CMapInfo(const std::string&amp; mapName);
 	~CMapInfo();
 
-	/** @brief Get a readonly reference to the TDF parser.
-	    This is needed by SM3 code to load feature and layer data. */
-	const TdfParser&amp; GetMapDefParser() const { return *mapDefParser; }
-
 	/* The settings are just public members because:
 
 	   1) it's quite some work to encapsulate all of them, and
@@ -107,13 +100,12 @@
 		float  groundShadowDensity;
 		float4 unitAmbientColor;
 		float4 unitSunColor;
-		float3 specularSunColor;
 		float  unitShadowDensity;
+		float3 specularSunColor;
 	} light;
 
 	/** settings read from &quot;MAP\WATER&quot; section
 	    prefix their name with &quot;Water&quot; to get the TDF variable */
-	static const int causticTextureCount = 32;
 	struct water_t {
 		float  repeatX; ///&lt; (calculated default is in CBaseWater)
 		float  repeatY; ///&lt; (calculated default is in CBaseWater)
@@ -132,7 +124,7 @@
 		std::string texture;
 		std::string foamTexture;
 		std::string normalTexture;
-		std::string causticTextures[causticTextureCount];
+		std::vector&lt;std::string&gt; causticTextures;
 	} water;
 	bool hasWaterPlane; ///&lt; true if &quot;MAP\WATER\WaterPlaneColor&quot; is set
 
@@ -161,8 +153,13 @@
 	};
 	TerrainType terrainTypes[256];
 
+	bool GetStartPos(int team, float3&amp; pos) const; // FIXME: MapParser duplicate?
+	
 private:
+	std::vector&lt;bool&gt;   havePos;
+	std::vector&lt;float3&gt; startPos;
 
+private:
 	void ReadGlobal();
 	void ReadGui();
 	void ReadAtmosphere();
@@ -171,9 +168,10 @@
 	void ReadSmf();
 	void ReadSm3();
 	void ReadTerrainTypes();
+	void ReadStartPos();
 
-	LuaParser* resourcesParser;
-	TdfParser* mapDefParser;
+	LuaTable* mapRoot; // map       parser root table
+	LuaTable* resRoot; // resources parser root table
 };
 
 extern const CMapInfo* mapInfo;

Copied: branches/gml/rts/Map/MapParser.cpp (from rev 6029, trunk/rts/Map/MapParser.cpp)
===================================================================
--- branches/gml/rts/Map/MapParser.cpp	                        (rev 0)
+++ branches/gml/rts/Map/MapParser.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -0,0 +1,109 @@
+#include &quot;StdAfx.h&quot;
+
+#include &lt;string&gt;
+#include &lt;ctype.h&gt;
+using namespace std;
+
+#include &quot;MapParser.h&quot;
+#include &quot;Lua/LuaSyncedRead.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
+
+
+string MapParser::GetMapConfigName(const string&amp; mapName)
+{
+	if (mapName.length() &lt; 3) {
+		return &quot;&quot;;
+	}
+
+	const string extension = mapName.substr(mapName.length() - 3);
+
+	if (extension == &quot;sm3&quot;) {
+		return string(&quot;maps/&quot;) + mapName;
+	}
+	else if (extension == &quot;smf&quot;) {
+		return string(&quot;maps/&quot;) +
+		       mapName.substr(0, mapName.find_last_of('.')) + &quot;.smd&quot;;
+	}
+	else {
+		return &quot;&quot;;
+	}
+}
+
+
+MapParser::MapParser(const string&amp; mapName) : parser(NULL)
+{
+	const string mapConfig = GetMapConfigName(mapName);
+
+	parser = SAFE_NEW LuaParser(&quot;maphelper/mapinfo.lua&quot;,
+															SPRING_VFS_MAP_BASE, SPRING_VFS_MAP_BASE);
+	parser-&gt;GetTable(&quot;Map&quot;);
+	parser-&gt;AddString(&quot;fileName&quot;, mapName);
+	parser-&gt;AddString(&quot;fullName&quot;, &quot;maps/&quot; + mapName);
+	parser-&gt;AddString(&quot;configFile&quot;, mapConfig);
+	parser-&gt;EndTable();
+#ifndef UNITSYNC
+	// this should not be included with unitsync:
+	// 1. avoids linkage with LuaSyncedRead
+	// 2. MapOptions are not valid during unitsync map parsing
+	parser-&gt;GetTable(&quot;Spring&quot;);
+	parser-&gt;AddFunc(&quot;GetMapOptions&quot;, LuaSyncedRead::GetMapOptions);
+	parser-&gt;EndTable();
+#endif
+	if (!parser-&gt;Execute()) {
+		// do nothing
+	}
+}
+
+
+MapParser::~MapParser()
+{
+	delete parser;
+}
+
+
+bool MapParser::GetStartPos(int team, float3&amp; pos) const
+{
+	if (!parser-&gt;IsValid()) {
+		return false;
+	}
+	const LuaTable teamsTable = parser-&gt;GetRoot().SubTable(&quot;teams&quot;);
+	const LuaTable posTable = teamsTable.SubTable(team).SubTable(&quot;startPos&quot;);
+	if (!posTable.IsValid()) {
+		return false;
+	}
+
+	pos.x = posTable.GetFloat(&quot;x&quot;, pos.x);
+	pos.z = posTable.GetFloat(&quot;z&quot;, pos.z);
+	
+	return true;
+}
+
+
+LuaTable MapParser::GetRoot()
+{
+	if (parser) {
+		return parser-&gt;GetRoot();
+	} else {
+		return LuaTable();
+	}
+}
+
+
+bool MapParser::IsValid() const
+{
+	if (parser) {
+		return parser-&gt;IsValid();
+	} else {
+		return false;
+	}
+}
+
+
+std::string MapParser::GetErrorLog() const
+{
+	if (parser) {
+		return parser-&gt;GetErrorLog();
+	} else {
+		return &quot;could not find file&quot;;
+	}
+}

Copied: branches/gml/rts/Map/MapParser.h (from rev 6029, trunk/rts/Map/MapParser.h)
===================================================================
--- branches/gml/rts/Map/MapParser.h	                        (rev 0)
+++ branches/gml/rts/Map/MapParser.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -0,0 +1,31 @@
+#ifndef MAP_PARSER_H
+#define MAP_PARSER_H
+
+#include &lt;string&gt;
+#include &quot;float3.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+
+
+class MapParser
+{
+	public:
+		static std::string GetMapConfigName(const std::string&amp; mapName);
+
+	public:
+		MapParser(const std::string&amp; mapName);
+		~MapParser();
+
+		LuaParser* GetParser() { return parser; }
+
+		LuaTable GetRoot();
+		bool IsValid() const;
+		std::string GetErrorLog() const;
+
+		bool GetStartPos(int team, float3&amp; pos) const;
+
+	private:
+		LuaParser* parser;
+};
+
+
+#endif // MAP_PARSER_H

Modified: branches/gml/rts/Map/MetalMap.cpp
===================================================================
--- branches/gml/rts/Map/MetalMap.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/MetalMap.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -5,7 +5,7 @@
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;mmgr.h&quot;
 
-CR_BIND(CMetalMap,(0,0,0,0.0));
+CR_BIND(CMetalMap,(NULL, 0, 0, 0.0f));
 
 CR_REG_METADATA(CMetalMap,(
 				CR_MEMBER(extractionMap)
@@ -13,20 +13,20 @@
 
 /*
 Constructor
-Reciving a map over all metal, and creating a map over extraction.
+Receiving a map over all metal, and creating a map over extraction.
 */
-CMetalMap::CMetalMap(unsigned char *map, int sizex, int sizez, float metalscale)
+CMetalMap::CMetalMap(unsigned char* map,
+                     int _sizeX, int _sizeZ, float _metalScale)
+: metalMap(map),
+  sizeX(_sizeX),
+  sizeZ(_sizeZ),
+  metalScale(_metalScale)
 {
-	this-&gt;metalMap = map;
-	this-&gt;sizex = sizex;
-	this-&gt;sizez = sizez;
-	this-&gt;metalscale = metalscale;
-	
-	//Creating an empty map over extraction.
-//	extractionMap = SAFE_NEW float[sizex * sizez];
-	extractionMap.resize(sizex * sizez,0.0);
+	// Creating an empty map over extraction.
+//	extractionMap = SAFE_NEW float[sizeX * sizeZ];
+	extractionMap.resize(sizeX * sizeZ, 0.0f);
 //	int i;
-//	for(i = 0; i &lt; (sizex * sizez); i++) {
+//	for(i = 0; i &lt; (sizeX * sizeZ); i++) {
 //		extractionMap[i] = 0.0f;
 //	}
 	
@@ -36,17 +36,17 @@
 		/* Swap the green and blue channels. making metal go
 		   black -&gt; blue -&gt; cyan,
 		   rather than the usual black -&gt; green -&gt; cyan. */
-		for(int a=0;a&lt;256;++a){
-			metalPal[a*3+0]=a;
-			metalPal[a*3+1]=std::max(0,a*2-255);
-			metalPal[a*3+2]=std::min(255,a*2);
+		for (int a = 0; a &lt; 256; ++a) {
+			metalPal[a * 3 + 0] = a;
+			metalPal[a * 3 + 1] = std::max(0, a * 2 - 255);
+			metalPal[a * 3 + 2] = std::min(255, a * 2);
 		}
 	}
 	else {
-		for(int a=0;a&lt;256;++a){
-			metalPal[a*3+0]=a;
-			metalPal[a*3+1]=std::min(255,a*2);
-			metalPal[a*3+2]=std::max(0,a*2-255);//a/2+((a*4)&amp;127);
+		for(int a = 0; a &lt; 256; ++a) {
+			metalPal[a * 3 + 0] = a;
+			metalPal[a * 3 + 1] = std::min(255, a * 2);
+			metalPal[a * 3 + 2] = std::max(0, a * 2 - 255);
 		}
 	}
 	
@@ -64,37 +64,34 @@
 }
 
 
+static inline void ClampInt(int&amp; var, int min, int maxPlusOne)
+{
+	if (var &lt; min) {
+		var = min;
+	} else if (var &gt;= maxPlusOne) {
+		var = maxPlusOne - 1;
+	}
+}
+
+
 /*
 Gives the amount of metal over an area.
 */
 float CMetalMap::getMetalAmount(int x1, int z1, int x2, int z2) 
 {
-	if(x1&lt;0)
-		x1=0;
-	else if(x1&gt;=sizex)
-		x1=sizex-1;
-	if(x2&lt;0)
-		x2=0;
-	else if(x2&gt;=sizex)
-		x2=sizex-1;
-
-	if(z1&lt;0)
-		z1=0;
-	else if(z1&gt;=sizez)
-		z1=sizez-1;
-	if(z2&lt;0)
-		z2=0;
-	else if(z2&gt;=sizez)
-		z2=sizez-1;
-
+	ClampInt(x1, 0, sizeX);
+	ClampInt(x2, 0, sizeX);
+	ClampInt(z1, 0, sizeZ);
+	ClampInt(z2, 0, sizeZ);
+	
 	float metal = 0.0f;
 	int x, z;
-	for(x = x1; x &lt; x2; x++) {
-		for(z = z1; z &lt; z2; z++) {
-			metal += metalMap[x + z*sizex];
+	for (x = x1; x &lt; x2; x++) {
+		for (z = z1; z &lt; z2; z++) {
+			metal += metalMap[(z * sizeX) + x];
 		}
 	}
-	return metal * metalscale;
+	return metal * metalScale;
 }
 
 
@@ -103,17 +100,10 @@
 */
 float CMetalMap::getMetalAmount(int x, int z) 
 {
-	if(x&lt;0)
-		x=0;
-	else if(x&gt;=sizex)
-		x=sizex-1;
+	ClampInt(x, 0, sizeX);
+	ClampInt(z, 0, sizeZ);
 
-	if(z&lt;0)
-		z=0;
-	else if(z&gt;=sizez)
-		z=sizez-1;
-
-	return metalMap[x + z*sizex] * metalscale;
+	return metalMap[(z * sizeX) + x] * metalScale;
 }
 
 
@@ -127,21 +117,19 @@
 */
 float CMetalMap::requestExtraction(int x, int z, float toDepth) 
 {
-	if(x&lt;0)
-		x=0;
-	else if(x&gt;=sizex)
-		x=sizex-1;
+	ClampInt(x, 0, sizeX);
+	ClampInt(z, 0, sizeZ);
 
-	if(z&lt;0)
-		z=0;
-	else if(z&gt;=sizez)
-		z=sizez-1;
+	const float current = extractionMap[(z * sizeX) + x];
 
-	if(toDepth &lt;= extractionMap[x + z*sizex])
-		return 0;
+	if (toDepth &lt;= current) {
+		return 0.0f;
+	}
 
-	float available = toDepth - extractionMap[x + z*sizex];
-	extractionMap[x + z*sizex] = toDepth;
+	const float available = toDepth - current;
+
+	extractionMap[(z * sizeX) + x] = toDepth;
+
 	return available;
 }
 
@@ -153,15 +141,8 @@
 */
 void CMetalMap::removeExtraction(int x, int z, float depth) 
 {
-	if(x&lt;0)
-		x=0;
-	else if(x&gt;=sizex)
-		x=sizex-1;
+	ClampInt(x, 0, sizeX);
+	ClampInt(z, 0, sizeZ);
 
-	if(z&lt;0)
-		z=0;
-	else if(z&gt;=sizez)
-		z=sizez-1;
-
-	extractionMap[x + z*sizex] -= depth;
+	extractionMap[(z * sizeX) + x] -= depth;
 }

Modified: branches/gml/rts/Map/MetalMap.h
===================================================================
--- branches/gml/rts/Map/MetalMap.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/MetalMap.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -3,31 +3,35 @@
 
 #include &quot;GlobalStuff.h&quot;
 
-const float METAL_MAP_SQUARE_SIZE = SQUARE_SIZE * 2;	//Each square on metalmap is a 2x2 square on normal map.
 
+// Each square on metalmap is a 2x2 square on normal map.
+const float METAL_MAP_SQUARE_SIZE = SQUARE_SIZE * 2;
+
+
 class CMetalMap
 {
 public:
 	CR_DECLARE(CMetalMap);
-	CMetalMap(unsigned char *map, int sizex, int sizez, float metalscale);
+	CMetalMap(unsigned char* map, int sizeX, int sizeZ, float metalScale);
 	virtual ~CMetalMap(void);
 
 	float getMetalAmount(int x1, int z1, int x2, int z2);
 	float getMetalAmount(int x, int z);
 	float requestExtraction(int x, int z, float toDepth);
-	void removeExtraction(int x, int z, float depth);
+	void  removeExtraction(int x, int z, float depth);
 
-	unsigned char *metalMap;
-	unsigned char metalPal[768];
+	unsigned char* metalMap;
+	unsigned char  metalPal[768];
 	std::vector&lt;float&gt; extractionMap;
-	float metalscale;
 
-	int GetSizeX() const { return sizex; }
-	int GetSizeZ() const { return sizez; }
+	int GetSizeX() const { return sizeX; }
+	int GetSizeZ() const { return sizeZ; }
 
 protected:
-	int sizex;
-	int sizez;
+	float metalScale;
+	int sizeX;
+	int sizeZ;
 };
 
+
 #endif /* METALMAP_H */

Modified: branches/gml/rts/Map/SM3/Sm3Map.cpp
===================================================================
--- branches/gml/rts/Map/SM3/Sm3Map.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SM3/Sm3Map.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -8,6 +8,7 @@
 #include &lt;IL/il.h&gt;
 #include &lt;SDL_types.h&gt;
 #include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
@@ -22,6 +23,16 @@
 #include &lt;fstream&gt;
 #include &quot;bitops.h&quot;
 
+
+// FIXME - temporary, until the LuaParser change is done
+static const TdfParser&amp; GetMapDefParser()
+{
+	extern std::string stupidGlobalMapname;
+	static TdfParser tdf(MapParser::GetMapConfigName(stupidGlobalMapname));
+	return tdf;
+}
+
+
 CR_BIND_DERIVED(CSm3ReadMap, CReadMap, ())
 
 //CR_REG_METADATA(CSmfReadMap, (
@@ -100,7 +111,7 @@
 		light.directional = false;
 		light.position = mapInfo-&gt;light.sunDir *1000000;
 		lightInfo.staticLights.push_back (light);
-		renderer-&gt;Load (mapInfo-&gt;GetMapDefParser(), &amp;lightInfo, &amp;loadcb);
+		renderer-&gt;Load (GetMapDefParser(), &amp;lightInfo, &amp;loadcb);
 
 		height = width = renderer-&gt;GetHeightmapWidth ()-1;
 
@@ -118,7 +129,7 @@
 
 		CReadMap::Initialize();
 
-		const TdfParser&amp; mapDefParser = mapInfo-&gt;GetMapDefParser();
+		const TdfParser&amp; mapDefParser = GetMapDefParser();
 		if (mapDefParser.SectionExist(&quot;map\\featuretypes&quot;)) {
 			int numTypes = atoi(mapDefParser.SGetValueDef(&quot;0&quot;, &quot;map\\featuretypes\\numtypes&quot;).c_str());
 			for (int a=0;a&lt;numTypes;a++) {
@@ -250,7 +261,7 @@
 void CSm3ReadMap::LoadFeatureData()
 {
 		// returns MapFeatureInfo[GetNumFeatures()]
-	std::string fd = mapInfo-&gt;GetMapDefParser().SGetValueDef(std::string(),&quot;map\\featuredata&quot;);
+	std::string fd = GetMapDefParser().SGetValueDef(std::string(),&quot;map\\featuredata&quot;);
 	if (!fd.empty()) {
 		CFileHandler fh(fd);
 		if (!fh.FileExists())
@@ -311,7 +322,7 @@
 unsigned char *CSm3ReadMap::GetInfoMap (const std::string&amp; name, MapBitmapInfo* bm)
 {
 	std::string map;
-	if (!mapInfo-&gt;GetMapDefParser().SGetValue(map, &quot;MAP\\INFOMAPS\\&quot; + name))
+	if (!GetMapDefParser().SGetValue(map, &quot;MAP\\INFOMAPS\\&quot; + name))
 		return 0;
 
 	CBitmap img;

Modified: branches/gml/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundDrawer.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SMF/BFGroundDrawer.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -20,16 +20,15 @@
 using std::min;
 using std::max;
 
-CBFGroundDrawer::CBFGroundDrawer(CSmfReadMap* rm)
+CBFGroundDrawer::CBFGroundDrawer(CSmfReadMap* rm) :
+	bigSquareSize(128),
+	numBigTexX(gs-&gt;mapx / bigSquareSize),
+	numBigTexY(gs-&gt;mapy / bigSquareSize),
+	heightDataX(gs-&gt;mapx + 1)
 {
 	map = rm;
 
-	bigSquareSize = 128;
-	numBigTexX = gs-&gt;mapx / bigSquareSize;
-	numBigTexY = gs-&gt;mapy / bigSquareSize;
-
 	heightData = map-&gt;heightmap;
-	heightDataX = gs-&gt;mapx + 1;
 
 	if (shadowHandler-&gt;canUseShadows) {
 		groundVP = LoadVertexProgram(&quot;ground.vp&quot;);

Modified: branches/gml/rts/Map/SMF/BFGroundDrawer.h
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundDrawer.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SMF/BFGroundDrawer.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -30,12 +30,12 @@
 	CSmfReadMap* map;
 	CBFGroundTextures* textures;
 
-	int numBigTexX;
-	int numBigTexY;
-	int bigSquareSize;
+	const int bigSquareSize;
+	const int numBigTexX;
+	const int numBigTexY;
 
 	float* heightData;
-	int heightDataX;
+	const int heightDataX;
 
 	CVertexArray* va;
 

Modified: branches/gml/rts/Map/SMF/BFGroundTextures.cpp
===================================================================
--- branches/gml/rts/Map/SMF/BFGroundTextures.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SMF/BFGroundTextures.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -29,7 +29,7 @@
 	numBigTexX = gs-&gt;mapx / bigSquareSize;
 	numBigTexY = gs-&gt;mapy / bigSquareSize;
 
-	MapHeader* header = &amp;map-&gt;header;
+	SMFHeader* header = &amp;map-&gt;header;
 	ifs-&gt;Seek(header-&gt;tilesPtr);
 
 	tileSize = header-&gt;tilesize;

Modified: branches/gml/rts/Map/SMF/SmfReadMap.cpp
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SMF/SmfReadMap.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -426,7 +426,7 @@
 void CSmfReadMap::ReadGrassMap(void *data)
 {
 	CFileHandler* fh=ifs;
-	fh-&gt;Seek(sizeof(MapHeader));
+	fh-&gt;Seek(sizeof(SMFHeader));
 
 	for(int a=0;a&lt;header.numExtraHeaders;++a){
 		int size;

Modified: branches/gml/rts/Map/SMF/SmfReadMap.h
===================================================================
--- branches/gml/rts/Map/SMF/SmfReadMap.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SMF/SmfReadMap.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -33,7 +33,7 @@
 
 	std::string detailTexName;
 	GLuint detailTex;
-	MapHeader header;
+	SMFHeader header;
 	CFileHandler *ifs;
 
 	bool usePBO;

Modified: branches/gml/rts/Map/SMF/mapfile.h
===================================================================
--- branches/gml/rts/Map/SMF/mapfile.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Map/SMF/mapfile.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -13,7 +13,7 @@
 properties for the map.
 
 The SMF file is the main file for the map, containing the tilemap and a lot of
-additional data. See MapHeader for details.
+additional data. See SMFHeader for details.
 
 The SMT file, for which the filename is stored in the SMF file, contains the
 tiles used by the map. This file can be shared between different maps. See
@@ -37,7 +37,7 @@
 
 Map file (.smf) layout is like this:
 
-	- MapHeader
+	- SMFHeader
 	- ExtraHeader
 	- ExtraHeader
 	- ...
@@ -45,7 +45,7 @@
 	- Chunk of data pointed to by header or extra headers
 	- ...
 */
-struct MapHeader {
+struct SMFHeader {
 	char magic[16];      ///&lt; &quot;spring map file\0&quot;
 	int version;         ///&lt; Must be 1 for now
 	int mapid;           ///&lt; Sort of a GUID of the file, just set to a random value when writing a map
@@ -68,7 +68,7 @@
 	int numExtraHeaders; ///&lt; Numbers of extra headers following main header
 };
 
-/// Read MapHeader mh from CFileHandler srcptr (endian aware)
+/// Read SMFHeader mh from CFileHandler srcptr (endian aware)
 #define READPTR_MAPHEADER(mh,srcptr)			\
 do {							\
 	unsigned int __tmpdw;				\
@@ -145,7 +145,7 @@
 // Some structures used in the chunks of data later in the file
 
 /**
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">- at brief</A> The header at offset MapHeader.tilesPtr in the .smf
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">+ at brief</A> The header at offset SMFHeader.tilesPtr in the .smf
 
 MapTileHeader is followed by numTileFiles file definition where each file
 definition is an int followed by a zero terminated file name. On loading,
@@ -177,7 +177,7 @@
 } while (0)
 
 /**
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">- at brief</A> The header at offset MapHeader.featurePtr in the .smf
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">+ at brief</A> The header at offset SMFHeader.featurePtr in the .smf
 
 MapFeatureHeader is followed by numFeatureType zero terminated strings indicating the names
 of the features in the map. Then follow numFeatures MapFeatureStructs.

Modified: branches/gml/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/gml/rts/Rendering/Env/BumpWater.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/Env/BumpWater.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -28,6 +28,7 @@
 #include &lt;boost/format.hpp&gt;
 
 using std::string;
+using std::vector;
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -217,16 +218,18 @@
 	}
 
 
-	foamTexture = LoadTexture( mapInfo-&gt;water.foamTexture );
-	normalTexture = LoadTexture( mapInfo-&gt;water.normalTexture );
-	for (int i = 0; i &lt; CMapInfo::causticTextureCount; i++) {
-		caustTextures[i] = LoadTexture( mapInfo-&gt;water.causticTextures[i] );
-	}
-
+	foamTexture = LoadTexture(mapInfo-&gt;water.foamTexture);
+	normalTexture = LoadTexture(mapInfo-&gt;water.normalTexture);
 	//heightTexture = readmap-&gt;GetShadingTexture();
-	/*
 
-	*/
+	// caustic textures
+	const vector&lt;string&gt;&amp; causticNames = mapInfo-&gt;water.causticTextures;
+	if (causticNames.size() &lt;= 0) {
+		throw content_error(&quot;no caustic textures&quot;);
+	}
+	for (int i = 0; i &lt; (int)causticNames.size(); i++) {
+		caustTextures.push_back(LoadTexture(causticNames[i]));
+	}
 
 	/* DEFINE SOME RUNTIME CONSTANTS (I don't use Uniforms for that, 'cos the glsl compiler can't optimize those!) */
 	string definitions;
@@ -305,8 +308,10 @@
 		glDeleteTextures(1, &amp;refractTexture);
 
 	glDeleteTextures(1, &amp;foamTexture);
-	glDeleteTextures(CMapInfo::causticTextureCount, caustTextures);
 	glDeleteTextures(1, &amp;normalTexture);
+	for (int i = 0; i &lt; (int)caustTextures.size(); i++) {
+		glDeleteTextures(1, &amp;caustTextures[i]);
+	}
 
 	glDeleteShader(waterVP);
 	glDeleteShader(waterFP);
@@ -332,7 +337,7 @@
 	if (refraction&lt;2)
 		glDepthMask(0);
 
-	const int causticTexNum = (gs-&gt;frameNum % CMapInfo::causticTextureCount);
+	const int causticTexNum = (gs-&gt;frameNum % caustTextures.size());
 	glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, readmap-&gt;GetShadingTexture());
 	glActiveTexture(GL_TEXTURE2); glBindTexture(GL_TEXTURE_2D, caustTextures[causticTexNum]);
 	glActiveTexture(GL_TEXTURE3); glBindTexture(GL_TEXTURE_2D, foamTexture);
@@ -341,8 +346,8 @@
 	glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, normalTexture);
 
 	glUseProgram(waterShader);
-	glUniform1f(frameLoc,gs-&gt;frameNum/15000.0f);
-	glUniformf3(eyePosLoc,camera-&gt;pos);
+	glUniform1f(frameLoc, gs-&gt;frameNum / 15000.0f);
+	glUniformf3(eyePosLoc, camera-&gt;pos);
 
 	glBegin(GL_QUADS);
 		glTexCoord4f(0.0f,0.0f,0.0f,0.0f);

Modified: branches/gml/rts/Rendering/Env/BumpWater.h
===================================================================
--- branches/gml/rts/Rendering/Env/BumpWater.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/Env/BumpWater.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -41,8 +41,8 @@
 
 	GLuint foamTexture;
 	GLuint normalTexture;
-	GLuint caustTextures[32];
 	GLuint* heightTexture;
+	std::vector&lt;GLuint&gt; caustTextures;
 
 	GLuint waterFP;
 	GLuint waterVP;

Modified: branches/gml/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/gml/rts/Rendering/GL/myGL.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/GL/myGL.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -115,12 +115,14 @@
 		ofs.write(s.c_str(), s.length());
 }
 
+
 void UnloadExtensions()
 {
 	delete vertexArray1;
 	delete vertexArray2;
 }
 
+
 /******************************************************************************/
 
 void glBuildMipmaps(const GLenum target,GLint internalFormat,const GLsizei width,const GLsizei height,const GLenum format,const GLenum type,const void *data)
@@ -269,7 +271,7 @@
 	glEnable(GL_TEXTURE_2D);
 	glColor3f(1,1,1);
 
-	if(startupTexture){
+	if (startupTexture) {
 		glBindTexture(GL_TEXTURE_2D,startupTexture);
 		glBegin(GL_QUADS);
 			glTexCoord2f(0,1);glVertex2f(0,0);
@@ -281,8 +283,9 @@
 	font-&gt;glPrintCentered (0.5f,0.48f, 2.0f, text);
 	font-&gt;glPrintCentered(0.5f,0.06f,1.0f,&quot;Spring %s&quot;, VERSION_STRING);
 	font-&gt;glPrintCentered(0.5f,0.02f,0.6f,&quot;This program is distributed under the GNU General Public License, see license.html for more info&quot;);
-	if (swapbuffers)
+	if (swapbuffers) {
 		SDL_GL_SwapBuffers();
+	}
 	POP_CODE_MODE;
 }
 
@@ -396,17 +399,20 @@
 	return ret;
 }
 
+
 unsigned int LoadVertexProgram(const char* filename)
 {
 	return LoadProgram(GL_VERTEX_PROGRAM_ARB, filename, &quot;vertex&quot;);
 }
 
+
 unsigned int LoadFragmentProgram(const char* filename)
 {
 
 	return LoadProgram(GL_FRAGMENT_PROGRAM_ARB, filename, &quot;fragment&quot;);
 }
 
+
 void glSafeDeleteProgram(GLuint program)
 {
 	if (!GLEW_ARB_vertex_program || (program == 0)) {

Modified: branches/gml/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/GroundDecalHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -48,10 +48,10 @@
 	}
 	
 	const LuaTable scarsTable = resourcesParser.GetRoot().SubTable(&quot;graphics&quot;).SubTable(&quot;scars&quot;);
-	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar2&quot;, &quot;scars/scar2.bmp&quot;), buf, 0,   0);
-	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar3&quot;, &quot;scars/scar3.bmp&quot;), buf, 256, 0);
-	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar1&quot;, &quot;scars/scar1.bmp&quot;), buf, 0,   256);
-	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(&quot;scar4&quot;, &quot;scars/scar4.bmp&quot;), buf, 256, 256);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(2, &quot;scars/scar2.bmp&quot;), buf, 0,   0);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(3, &quot;scars/scar3.bmp&quot;), buf, 256, 0);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(1, &quot;scars/scar1.bmp&quot;), buf, 0,   256);
+	LoadScar(&quot;bitmaps/&quot; + scarsTable.GetString(4, &quot;scars/scar4.bmp&quot;), buf, 256, 256);
 	
 	glGenTextures(1, &amp;scarTex);
 	glBindTexture(GL_TEXTURE_2D, scarTex);

Modified: branches/gml/rts/Rendering/IconHandler.cpp
===================================================================
--- branches/gml/rts/Rendering/IconHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/IconHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -134,6 +134,9 @@
 	if (it == iconMap.end()) {
 		return false;
 	}
+	if (iconName == &quot;default&quot;) {
+		return false;
+	}
 
 	CIconData* iconData = it-&gt;second.data;
 	iconData-&gt;CopyData(defIconData);

Modified: branches/gml/rts/Rendering/InMapDraw.cpp
===================================================================
--- branches/gml/rts/Rendering/InMapDraw.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/InMapDraw.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -63,7 +63,9 @@
 ));
 
 
+const float quadScale = 1.0f / (DRAW_QUAD_SIZE * SQUARE_SIZE);
 
+
 CInMapDraw::CInMapDraw(void)
 {
 	keyPressed = false;
@@ -313,18 +315,21 @@
 		return;
 
 	switch (button) {
-	case SDL_BUTTON_LEFT:
-		if (lastLeftClickTime &gt; gu-&gt;gameTime - 0.3f) {
-			PromptLabel(pos);
+		case SDL_BUTTON_LEFT: {
+			if (lastLeftClickTime &gt; gu-&gt;gameTime - 0.3f) {
+				PromptLabel(pos);
+			}
+			lastLeftClickTime = gu-&gt;gameTime;
+			break;
 		}
-		lastLeftClickTime = gu-&gt;gameTime;
-		break;
-	case SDL_BUTTON_RIGHT:
-		ErasePos(pos);
-		break;
-	case SDL_BUTTON_MIDDLE:{
-		CreatePoint(pos, &quot;&quot;);
-		break;}
+		case SDL_BUTTON_RIGHT: {
+			SendErase(pos);
+			break;
+		}
+		case SDL_BUTTON_MIDDLE:{
+			SendPoint(pos, &quot;&quot;);
+			break;
+		}
 	}
 
 	lastPos = pos;
@@ -333,23 +338,23 @@
 
 void CInMapDraw::MouseRelease(int x, int y, int button)
 {
-
 }
 
 
 void CInMapDraw::MouseMove(int x, int y, int dx,int dy, int button)
 {
 	float3 pos = GetMouseMapPos();
-	if (pos.x &lt; 0)
+	if (pos.x &lt; 0) {
 		return;
-
+	}
 	if (mouse-&gt;buttons[SDL_BUTTON_LEFT].pressed &amp;&amp; lastLineTime &lt; gu-&gt;gameTime - 0.05f) {
-		AddLine(pos, lastPos);
+		SendLine(pos, lastPos);
 		lastLineTime = gu-&gt;gameTime;
 		lastPos = pos;
 	}
-	if (mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed)
-		ErasePos(pos);
+	if (mouse-&gt;buttons[SDL_BUTTON_RIGHT].pressed) {
+		SendErase(pos);
+	}
 
 }
 
@@ -369,6 +374,32 @@
 void CInMapDraw::GotNetMsg(const unsigned char* msg)
 {
 	const int playerID = msg[2];
+
+	switch (msg[3]) {
+		case NET_POINT: {
+			float3 pos(*(short*) &amp;msg[4], 0, *(short*) &amp;msg[6]);
+			const string label = (char*) &amp;msg[8];
+			LocalPoint(pos, label, playerID);
+			break;
+		}
+		case NET_LINE: {
+			float3 pos1(*(short*) &amp;msg[4], 0, *(short*) &amp;msg[6]);
+			float3 pos2(*(short*) &amp;msg[8], 0, *(short*) &amp;msg[10]);
+			LocalLine(pos1, pos2, playerID);
+			break;
+		}
+		case NET_ERASE: {
+			float3 pos(*(short*) &amp;msg[4], 0, *(short*) &amp;msg[6]);
+			LocalErase(pos, playerID);
+			break;
+		}
+	}
+}
+
+
+void CInMapDraw::LocalPoint(const float3&amp; constPos, const std::string&amp; label,
+                            int playerID)
+{
 	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
 		return;
 	}
@@ -376,9 +407,10 @@
 	if (sender == NULL) {
 		return;
 	}
-	const int team = sender-&gt;team;
-	const int allyteam = gs-&gt;AllyTeam(team);
-	const bool alliedMsg = (gs-&gt;Ally(gu-&gt;myAllyTeam, allyteam) &amp;&amp; gs-&gt;Ally(allyteam, gu-&gt;myAllyTeam));
+	const int  team      = sender-&gt;team;
+	const int  allyteam  = gs-&gt;AllyTeam(team);
+	const bool alliedMsg = (gs-&gt;Ally(gu-&gt;myAllyTeam, allyteam) &amp;&amp;
+	                        gs-&gt;Ally(allyteam, gu-&gt;myAllyTeam));
 	bool allowed = true;
 
 	if (!gu-&gt;spectating &amp;&amp; (sender-&gt;spectator || !alliedMsg)) {
@@ -389,130 +421,149 @@
 		allowed = false;
 	}
 
-	const float quadScale = 1.0f / (DRAW_QUAD_SIZE * SQUARE_SIZE);
+	float3 pos = constPos;
+	pos.CheckInBounds();
+	pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 2.0f;
 
-	switch (msg[3]) {
-		case NET_POINT: {
-			float3 pos(*(short*) &amp;msg[4], 0, *(short*) &amp;msg[6]);
-			pos.CheckInBounds();
-			pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 2.0f;
+	if (luaUI &amp;&amp; luaUI-&gt;MapDrawCmd(playerID, NET_POINT, &amp;pos, NULL, &amp;label)) {
+		return;
+	}
 
-			const string label = (char*) &amp;msg[8];
-			if (luaUI &amp;&amp; luaUI-&gt;MapDrawCmd(playerID, NET_POINT, &amp;pos, NULL, &amp;label)) {
-				return;
-			}
+	MapPoint point;
+	point.pos = pos;
+	point.color = gs-&gt;Team(team)-&gt;color;
+	point.label = label;
+	point.senderAllyTeam = allyteam;
+	point.senderSpectator = sender-&gt;spectator;
 
-			MapPoint p;
-			p.pos = pos;
-			p.color = gs-&gt;Team(team)-&gt;color;
-			p.label = label;
-			p.senderAllyTeam = allyteam;
-			p.senderSpectator = sender-&gt;spectator;
+	const int quad = int(pos.z * quadScale) * drawQuadsX +
+	                 int(pos.x * quadScale);
+	drawQuads[quad].points.push_back(point);
 
-			const int quad = int(pos.z * quadScale) * drawQuadsX + int(pos.x * quadScale);
-			drawQuads[quad].points.push_back(p);
+	if (allowed || drawAll) {
+		// if we happen to be in drawAll mode, notify us now
+		// even if this message is not intented for our ears
+		logOutput.Print(&quot;%s added point: %s&quot;,
+		                sender-&gt;playerName.c_str(), point.label.c_str());
+		logOutput.SetLastMsgPos(pos);
+		sound-&gt;PlaySample(blippSound);
+		minimap-&gt;AddNotification(pos, float3(1.0f, 1.0f, 1.0f), 1.0f);
+	}
+}
 
-			if (allowed || drawAll) {
-				// if we happen to be in drawAll mode, notify us now
-				// even if this message is not intented for our ears
-				logOutput.Print(&quot;%s added point: %s&quot;, sender-&gt;playerName.c_str(), p.label.c_str());
-				logOutput.SetLastMsgPos(pos);
-				sound-&gt;PlaySample(blippSound);
-				minimap-&gt;AddNotification(pos, float3(1.0f, 1.0f, 1.0f), 1.0f);
-			}
 
-			break;
-		}
+void CInMapDraw::LocalLine(const float3&amp; constPos1, const float3&amp; constPos2,
+                           int playerID)
+{
+	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
+		return;
+	}
+	const CPlayer* sender = gs-&gt;players[playerID];
+	if (sender == NULL) {
+		return;
+	}
+	const int  team      = sender-&gt;team;
+	const int  allyteam  = gs-&gt;AllyTeam(team);
+	const bool alliedMsg = (gs-&gt;Ally(gu-&gt;myAllyTeam, allyteam) &amp;&amp;
+	                        gs-&gt;Ally(allyteam, gu-&gt;myAllyTeam));
 
-		case NET_ERASE: {
-			float3 pos(*(short*) &amp;msg[4], 0, *(short*) &amp;msg[6]);
-			pos.CheckInBounds();
-			pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 2.0f;
-			if (luaUI &amp;&amp; luaUI-&gt;MapDrawCmd(playerID, NET_ERASE, &amp;pos, NULL, NULL)) {
-				return;
-			}
+	float3 pos1 = constPos1;
+	float3 pos2 = constPos2;
+	pos1.CheckInBounds();
+	pos2.CheckInBounds();
+	pos1.y = ground-&gt;GetHeight(pos1.x, pos1.z) + 2.0f;
+	pos2.y = ground-&gt;GetHeight(pos2.x, pos2.z) + 2.0f;
 
-			const float radius = 100.0f;
-			const int maxY = drawQuadsY - 1;
-			const int maxX = drawQuadsX - 1;
-			const int yStart = (int) std::max(0,    int((pos.z - radius) * quadScale));
-			const int xStart = (int) std::max(0,    int((pos.x - radius) * quadScale));
-			const int yEnd   = (int) std::min(maxY, int((pos.z + radius) * quadScale));
-			const int xEnd   = (int) std::min(maxX, int((pos.x + radius) * quadScale));
+	if (luaUI &amp;&amp; luaUI-&gt;MapDrawCmd(playerID, NET_LINE, &amp;pos1, &amp;pos2, NULL)) {
+		return;
+	}
 
-			for (int y = yStart; y &lt;= yEnd; ++y) {
-				for (int x = xStart; x &lt;= xEnd; ++x) {
-					DrawQuad* dq = &amp;drawQuads[(y * drawQuadsX) + x];
+	MapLine line;
+	line.pos  = pos1;
+	line.pos2 = pos2;
+	line.color = gs-&gt;Team(team)-&gt;color;
+	line.senderAllyTeam = allyteam;
+	line.senderSpectator = sender-&gt;spectator;
 
-					std::list&lt;MapPoint&gt;::iterator pi;
-					for (pi = dq-&gt;points.begin(); pi != dq-&gt;points.end(); /* none */) {
-						if (pi-&gt;pos.distance2D(pos) &lt; radius) {
-							pi = dq-&gt;points.erase(pi);
-						} else {
-							++pi;
-						}
-					}
-					std::list&lt;MapLine&gt;::iterator li;
-					for (li = dq-&gt;lines.begin(); li != dq-&gt;lines.end(); /* none */) {
-						if (li-&gt;pos.distance2D(pos) &lt; radius) {
-							li = dq-&gt;lines.erase(li);
-						} else {
-							++li;
-						}
-					}
-				}
-			}
+	const int quad = int(pos1.z * quadScale) * drawQuadsX +
+	                 int(pos1.x * quadScale);
+	drawQuads[quad].lines.push_back(line);
+}
 
-			break;
-		}
 
-		case NET_LINE: {
-			float3 pos(*(short*) &amp;msg[4], 0, *(short*) &amp;msg[6]);
-			float3 pos2(*(short*) &amp;msg[8], 0, *(short*) &amp;msg[10]);
-			pos.CheckInBounds();
-			pos2.CheckInBounds();
-			pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 2.0f;
-			pos2.y = ground-&gt;GetHeight(pos2.x, pos2.z) + 2.0f;
+void CInMapDraw::LocalErase(const float3&amp; constPos, int playerID)
+{
+	if ((playerID &lt; 0) || (playerID &gt;= MAX_PLAYERS)) {
+		return;
+	}
+	const CPlayer* sender = gs-&gt;players[playerID];
+	if (sender == NULL) {
+		return;
+	}
+	const int  team      = sender-&gt;team;
+	const int  allyteam  = gs-&gt;AllyTeam(team);
+	const bool alliedMsg = (gs-&gt;Ally(gu-&gt;myAllyTeam, allyteam) &amp;&amp;
+	                        gs-&gt;Ally(allyteam, gu-&gt;myAllyTeam));
 
-			if (luaUI &amp;&amp; luaUI-&gt;MapDrawCmd(playerID, NET_LINE, &amp;pos, &amp;pos2, NULL)) {
-				return;
-			}
+	float3 pos = constPos;
+	pos.CheckInBounds();
+	pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 2.0f;
+	if (luaUI &amp;&amp; luaUI-&gt;MapDrawCmd(playerID, NET_ERASE, &amp;pos, NULL, NULL)) {
+		return;
+	}
 
-			MapLine l;
-			l.pos = pos;
-			l.pos2 = pos2;
-			l.color = gs-&gt;Team(team)-&gt;color;
-			l.senderAllyTeam = allyteam;
-			l.senderSpectator = sender-&gt;spectator;
+	const float radius = 100.0f;
+	const int maxY = drawQuadsY - 1;
+	const int maxX = drawQuadsX - 1;
+	const int yStart = (int) std::max(0,    int((pos.z - radius) * quadScale));
+	const int xStart = (int) std::max(0,    int((pos.x - radius) * quadScale));
+	const int yEnd   = (int) std::min(maxY, int((pos.z + radius) * quadScale));
+	const int xEnd   = (int) std::min(maxX, int((pos.x + radius) * quadScale));
 
-			const int quad = int(pos.z * quadScale) * drawQuadsX + int(pos.x * quadScale);
-			drawQuads[quad].lines.push_back(l);
+	for (int y = yStart; y &lt;= yEnd; ++y) {
+		for (int x = xStart; x &lt;= xEnd; ++x) {
+			DrawQuad* dq = &amp;drawQuads[(y * drawQuadsX) + x];
 
-			break;
+			std::list&lt;MapPoint&gt;::iterator pi;
+			for (pi = dq-&gt;points.begin(); pi != dq-&gt;points.end(); /* none */) {
+				if (pi-&gt;pos.distance2D(pos) &lt; radius) {
+					pi = dq-&gt;points.erase(pi);
+				} else {
+					++pi;
+				}
+			}
+			std::list&lt;MapLine&gt;::iterator li;
+			for (li = dq-&gt;lines.begin(); li != dq-&gt;lines.end(); /* none */) {
+				if (li-&gt;pos.distance2D(pos) &lt; radius) {
+					li = dq-&gt;lines.erase(li);
+				} else {
+					++li;
+				}
+			}
 		}
 	}
 }
 
 
-void CInMapDraw::ErasePos(const float3&amp; pos)
+void CInMapDraw::SendErase(const float3&amp; pos)
 {
-	net-&gt;SendMapErase(gu-&gt;myPlayerNum, (short)pos.x, (short)pos.z);
+	net-&gt;Send(CBaseNetProtocol::Get().SendMapErase(gu-&gt;myPlayerNum, (short)pos.x, (short)pos.z));
 }
 
 
-void CInMapDraw::CreatePoint(const float3&amp; pos, std::string label)
+void CInMapDraw::SendPoint(const float3&amp; pos, const std::string&amp; label)
 {
-	net-&gt;SendMapDrawPoint(gu-&gt;myPlayerNum, (short)pos.x, (short)pos.z, label);
+	net-&gt;Send(CBaseNetProtocol::Get().SendMapDrawPoint(gu-&gt;myPlayerNum, (short)pos.x, (short)pos.z, label));
 }
 
 
-void CInMapDraw::AddLine(const float3&amp; pos, const float3&amp; pos2)
+void CInMapDraw::SendLine(const float3&amp; pos, const float3&amp; pos2)
 {
-	net-&gt;SendMapDrawLine(gu-&gt;myPlayerNum, (short)pos.x, (short)pos.z, (short)pos2.x, (short)pos2.z);
+	net-&gt;Send(CBaseNetProtocol::Get().SendMapDrawLine(gu-&gt;myPlayerNum, (short)pos.x, (short)pos.z, (short)pos2.x, (short)pos2.z));
 }
 
 
-void CInMapDraw::PromptLabel (const float3&amp; pos)
+void CInMapDraw::PromptLabel(const float3&amp; pos)
 {
 	waitingPoint = pos;
 	game-&gt;userWriting = true;

Modified: branches/gml/rts/Rendering/InMapDraw.h
===================================================================
--- branches/gml/rts/Rendering/InMapDraw.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/InMapDraw.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -16,9 +16,10 @@
 public:
 	CInMapDraw(void);
 	~CInMapDraw(void);
-	void Draw(void);
 	void PostLoad();
 
+	void Draw(void);
+
 	void MousePress(int x, int y, int button);
 	void MouseRelease(int x,int y,int button);
 	void MouseMove(int x, int y, int dx, int dy, int button);
@@ -27,8 +28,15 @@
 	void SetAllVisible(bool b) { drawAll = b; }
 
 	float3 GetMouseMapPos(void);
-	void ErasePos(const float3&amp; pos);
 
+	void LocalPoint(const float3&amp; pos, const std::string&amp; label, int playerID);
+	void LocalLine(const float3&amp; pos1, const float3&amp; pos2, int playerID);
+	void LocalErase(const float3&amp; pos, int playerID);
+
+	void SendPoint(const float3&amp; pos, const std::string&amp; label);
+	void SendLine(const float3&amp; pos1, const float3&amp; pos2);
+	void SendErase(const float3&amp; pos);
+
 	bool keyPressed;
 
 	struct MapPoint {
@@ -80,10 +88,9 @@
 	int blippSound;
 	bool drawAll;
 
-	static void InMapDrawVisCallback (int x,int y,void *userData);
-	void CreatePoint(const float3&amp; pos, std::string label);
-	void AddLine(const float3&amp; pos, const float3&amp; pos2);
-	void PromptLabel (const float3&amp; pos);;
+	static void InMapDrawVisCallback(int x, int y, void* userData);
+
+	void PromptLabel(const float3&amp; pos);;
 };
 
 extern CInMapDraw* inMapDrawer;

Modified: branches/gml/rts/Rendering/Textures/Bitmap.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/Bitmap.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/Textures/Bitmap.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -13,6 +13,7 @@
 #include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;ostream&gt;
 #include &lt;fstream&gt;
+#include &lt;string.h&gt;
 #include &quot;FileSystem/FileHandler.h&quot;
 #if defined(USE_QUICKTIME)
 #include &lt;QuickTime/ImageCompression.h&gt;

Modified: branches/gml/rts/Rendering/Textures/TextureAtlas.h
===================================================================
--- branches/gml/rts/Rendering/Textures/TextureAtlas.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/Textures/TextureAtlas.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -18,7 +18,8 @@
 	float ystart;
 	float yend;
 
-	int ixstart,iystart;
+	int ixstart;
+	int iystart;
 };
 
 /** @brief Same as AtlasedTexture but different name so the explosiongenerator
@@ -76,8 +77,9 @@
 		int xsize;
 		int ysize;
 		TextureType texType;
-		int xpos,ypos;
-		void *data;
+		int xpos;
+		int ypos;
+		void* data;
 	};
 
 	//temporary storage of all textures

Modified: branches/gml/rts/Rendering/Textures/nv_dds.cpp
===================================================================
--- branches/gml/rts/Rendering/Textures/nv_dds.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/Textures/nv_dds.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -186,6 +186,7 @@
 //#endif
 
 #include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
 #include &lt;assert.h&gt;
 #include &quot;nv_dds.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;

Modified: branches/gml/rts/Rendering/glFont.cpp
===================================================================
--- branches/gml/rts/Rendering/glFont.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/glFont.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -325,6 +325,14 @@
 	}
 }
 
+void CglFont::OutlineS(bool enable, const float *outlineColor)
+{
+	this-&gt;outline = enable;
+	if (enable) {;
+		this-&gt;outlineColor = outlineColor ? outlineColor : ChooseOutlineColor(color);
+	}
+}
+
 float CglFont::RenderString(float x, float y, float s, const unsigned char *text) const
 {
 //	glPushAttrib(GL_LIST_BIT | GL_CURRENT_BIT  | GL_ENABLE_BIT | GL_TRANSFORM_BIT);	
@@ -548,19 +556,33 @@
 
 void CglFont::glPrintColorAt(GLfloat x, GLfloat y, float s, const char *str)
 {
-	glColor3f(1, 1, 1);
+	//TODO both glColor and float* color is set, make RenderString respect the float *color
+	const float *oldcolor = color;
+	float newcolor[4] = {1.0, 1.0, 1.0, 1.0};
+	color = const_cast&lt;const float*&gt;(newcolor);
+	glColor4fv(color);
 	size_t lf;
 	string temp=str;
 	while((lf=temp.find(&quot;\xff&quot;))!=string::npos) {
-		x = RenderString(x, y, s, (const unsigned char*)temp.substr(0, lf).c_str());
+		if (outline)
+		{
+			x = RenderStringOutlined(x, y, s, (const unsigned char*)temp.substr(0, lf).c_str());
+			outline = true; //HACK RenderStringOutlined resets outline
+		}
+		else
+			x = RenderString(x, y, s, (const unsigned char*)temp.substr(0, lf).c_str());
 		temp=temp.substr(lf, string::npos);
-		float r=((unsigned char)temp[1])/255.0f;
-		float g=((unsigned char)temp[2])/255.0f;
-		float b=((unsigned char)temp[3])/255.0f;
-		glColor3f(r, g, b);
+		newcolor[0] = ((unsigned char)temp[1])/255.0f;
+		newcolor[1] = ((unsigned char)temp[2])/255.0f;
+		newcolor[2] = ((unsigned char)temp[3])/255.0f;
+		glColor4fv(color);
 		temp=temp.substr(4, string::npos);
 	}
-	RenderString(x, y, s, (const unsigned char*)temp.c_str());
+	if (outline)
+		RenderStringOutlined(x, y, s, (const unsigned char*)temp.c_str());
+	else
+		RenderString(x, y, s, (const unsigned char*)temp.c_str());
+	color = oldcolor;
 }
 
 void CglFont::glFormatAt(GLfloat x, GLfloat y, float s, const char *fmt, ...)

Modified: branches/gml/rts/Rendering/glFont.h
===================================================================
--- branches/gml/rts/Rendering/glFont.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Rendering/glFont.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -27,6 +27,7 @@
 	void glPrintRight (float x,float y, float s, const char *fmt,...);
 	void glPrintCentered (float x,float y, float s, const char *fmt,...);
 	void Outline(bool enable, const float *color, const float *outlineColor = 0);		/// Enable outlining for the next drawing operation.
+	void OutlineS(bool enable, const float *outlineColor = 0);		/// Enable outlining for the next drawing operation.
 
 	// The &quot;outlined&quot; functions are for convenience; their functionality may be obtained by calling Outline() before rendering text.
 	void glPrintOutlinedAt(float x, float y, float scale, const char* text, const float* normalColor);

Modified: branches/gml/rts/Sim/Features/FeatureDef.h
===================================================================
--- branches/gml/rts/Sim/Features/FeatureDef.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Features/FeatureDef.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -18,11 +18,11 @@
 	CR_DECLARE(FeatureDef);
 
 	FeatureDef():
-		metal(0), energy(0), maxHealth(0), mass(0),
+		metal(0), energy(0), maxHealth(0), reclaimTime(0), mass(0),
 		upright(false), drawType(0), modelType(0),
 		destructable(false), reclaimable(true), blocking(false),
-		burnable(false), floating(false), geoThermal(false), noSelect(false),
-		xsize(0), ysize(0), reclaimTime(0) {}
+		burnable(false), floating(false), noSelect(false), geoThermal(false),
+		xsize(0), ysize(0) {}
 
 	S3DOModel* LoadModel(int team) const;
 	CollisionVolume* collisionVolume;

Modified: branches/gml/rts/Sim/Features/FeatureHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Features/FeatureHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -394,7 +394,7 @@
 
 	if (feature-&gt;def-&gt;drawType == DRAWTYPE_3DO) {
 		int quad = int(feature-&gt;pos.z / DRAW_QUAD_SIZE / SQUARE_SIZE) * drawQuadsX +
-				   int(feature-&gt;pos.x / DRAW_QUAD_SIZE / SQUARE_SIZE);
+		           int(feature-&gt;pos.x / DRAW_QUAD_SIZE / SQUARE_SIZE);
 		DrawQuad* dq = &amp;drawQuads[quad];
 		dq-&gt;features.insert(feature);
 		feature-&gt;drawQuad = quad;

Modified: branches/gml/rts/Sim/Misc/DamageArrayHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/DamageArrayHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Misc/DamageArrayHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,7 +1,6 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;DamageArrayHandler.h&quot;
 #include &quot;DamageArray.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;Lua/LuaParser.h&quot;

Modified: branches/gml/rts/Sim/Misc/LosHandler.h
===================================================================
--- branches/gml/rts/Sim/Misc/LosHandler.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Misc/LosHandler.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -21,7 +21,9 @@
 	CR_DECLARE_STRUCT(LosInstance);
  	std::vector&lt;int&gt; losSquares;
 	LosInstance() {} // default constructor for creg
-	LosInstance(int lossize,int allyteam,int baseX,int baseY,int baseSquare,int baseAirSquare,int hashNum,float baseHeight,int airLosSize)
+	LosInstance(int lossize, int allyteam, int baseX, int baseY,
+	            int baseSquare, int baseAirSquare, int hashNum,
+	            float baseHeight, int airLosSize)
 		: losSize(lossize),
 			airLosSize(airLosSize),
 			refCount(1),
@@ -32,7 +34,7 @@
 			baseAirSquare(baseAirSquare),
 			hashNum(hashNum),
 			baseHeight(baseHeight),
-			toBeDeleted(false){}
+			toBeDeleted(false) {}
 	int losSize;
 	int airLosSize;
 	int refCount;
@@ -58,50 +60,75 @@
 	void FreeInstance(LosInstance* instance);
 
 	bool InLos(const CWorldObject* object, int allyTeam) {
-		if (object-&gt;alwaysVisible)
+		if (object-&gt;alwaysVisible) {
 			return true;
-		if (object-&gt;useAirLos) {
-			const int rowIdx = std::max(0, std::min(airSizeY - 1, ((int (object-&gt;pos.z * invAirDiv))))) * airSizeX;
-			const int colIdx = std::max(0, std::min(airSizeX - 1, ((int (object-&gt;pos.x * invAirDiv)))));
-			const int square = rowIdx + colIdx;
-			#ifdef DEBUG
-			assert(square &lt; airLosMap[allyTeam].size());
-			#endif
+		}
+		else if (object-&gt;useAirLos) {
+			const int gx = (int)(object-&gt;pos.x * invAirDiv);
+			const int gz = (int)(object-&gt;pos.z * invAirDiv);
+			const int rowIdx = std::max(0, std::min(airSizeY - 1, gz));
+			const int colIdx = std::max(0, std::min(airSizeX - 1, gx));
+			const int square = (rowIdx * airSizeX) + colIdx;
+			assert(static_cast&lt;unsigned&gt;(square) &lt; airLosMap[allyTeam].size());
 			return !!airLosMap[allyTeam][square];
-		} else {
-			const int rowIdx = std::max(0, std::min(losSizeY - 1, ((int) (object-&gt;pos.z * invLosDiv)))) * losSizeX;
-			const int colIdx = std::max(0, std::min(losSizeX - 1, ((int) (object-&gt;pos.x * invLosDiv))));
-			const int square = rowIdx + colIdx;
-			#ifdef DEBUG
-			assert(square &lt; losMap[allyTeam].size());
-			#endif
+		}
+		else {
+			const int gx = (int)(object-&gt;pos.x * invLosDiv);
+			const int gz = (int)(object-&gt;pos.z * invLosDiv);
+			const int rowIdx = std::max(0, std::min(losSizeY - 1, gz));
+			const int colIdx = std::max(0, std::min(losSizeX - 1, gx));
+			const int square = (rowIdx * losSizeX) + colIdx;
+			assert(static_cast&lt;unsigned&gt;(square) &lt; losMap[allyTeam].size());
 			return !!losMap[allyTeam][square];
 		}
 	}
 
 	bool InLos(const CUnit* unit, int allyTeam) {
-		if (unit-&gt;alwaysVisible)
+		// NOTE: units are treated differently than world objects in 2 ways:
+		//       1. they can be cloaked 
+		//       2. when underwater, they only get LOS if they also have sonar
+		if (unit-&gt;alwaysVisible) {
 			return true;
-		if (unit-&gt;isCloaked)
+		}
+		else if (unit-&gt;isCloaked) {
 			return false;
-		return InLos(static_cast&lt;const CWorldObject*&gt;(unit), allyTeam);
+		}
+		else if (unit-&gt;useAirLos) {
+			const int gx = (int)(unit-&gt;pos.x * invAirDiv);
+			const int gz = (int)(unit-&gt;pos.z * invAirDiv);
+			const int rowIdx = std::max(0, std::min(airSizeY - 1, gz));
+			const int colIdx = std::max(0, std::min(airSizeX - 1, gx));
+			const int square = (rowIdx * airSizeX) + colIdx;
+			assert(static_cast&lt;unsigned&gt;(square) &lt; airLosMap[allyTeam].size());
+			return !!airLosMap[allyTeam][square];
+		}
+		else {
+			if (unit-&gt;isUnderWater &amp;&amp; !radarhandler-&gt;InRadar(unit, allyTeam)) {
+				return false;
+			}
+			const int gx = (int)(unit-&gt;pos.x * invLosDiv);
+			const int gz = (int)(unit-&gt;pos.z * invLosDiv);
+			const int rowIdx = std::max(0, std::min(losSizeY - 1, gz));
+			const int colIdx = std::max(0, std::min(losSizeX - 1, gx));
+			const int square = (rowIdx * losSizeX) + colIdx;
+			assert(static_cast&lt;unsigned&gt;(square) &lt; losMap[allyTeam].size());
+			return !!losMap[allyTeam][square];
+		}
 	}
 
 	bool InLos(float3 pos, int allyTeam) {
 		pos.CheckInBounds();
-		const int square = ((int) (pos.z * invLosDiv)) * losSizeX + ((int) (pos.x * invLosDiv));
-		#ifdef DEBUG
-		assert(square &lt; losMap[allyTeam].size());
-		#endif
+		const int square = ((int)(pos.z * invLosDiv)) * losSizeX
+		                 + ((int)(pos.x * invLosDiv));
+		assert(static_cast&lt;unsigned&gt;(square) &lt; losMap[allyTeam].size());
 		return !!losMap[allyTeam][square];
 	}
 
 	bool InAirLos(float3 pos, int allyTeam) {
 		pos.CheckInBounds();
-		const int square = ((int) (pos.z * invAirDiv)) * airSizeX + ((int) (pos.x * invAirDiv));
-		#ifdef DEBUG
-		assert(square &lt; airLosMap[allyTeam].size());
-		#endif
+		const int square = ((int)(pos.z * invAirDiv)) * airSizeX
+		                 + ((int)(pos.x * invAirDiv));
+		assert(static_cast&lt;unsigned&gt;(square) &lt; airLosMap[allyTeam].size());
 		return !!airLosMap[allyTeam][square];
 	}
 

Modified: branches/gml/rts/Sim/Misc/RadarHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Misc/RadarHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Misc/RadarHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -9,7 +9,9 @@
 CR_BIND(CRadarHandler, (false));
 
 CR_REG_METADATA(CRadarHandler, (
-	CR_SERIALIZER(Serialize), // radarMaps, airRadarMaps, sonarMaps, jammerMaps, seismicMaps, commonJammerMap, commonSonarJammerMap
+	CR_SERIALIZER(Serialize),
+	// radarMaps, airRadarMaps, sonarMaps, jammerMaps,
+	// seismicMaps, commonJammerMap, commonSonarJammerMap
 	CR_MEMBER(circularRadar),
 	CR_MEMBER(radarErrorSize),
 	CR_MEMBER(baseRadarErrorSize),

Modified: branches/gml/rts/Sim/Misc/RadarHandler.h
===================================================================
--- branches/gml/rts/Sim/Misc/RadarHandler.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Misc/RadarHandler.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -12,6 +12,7 @@
 {
 	CR_DECLARE(CRadarHandler);
 
+
 public:
 	CRadarHandler(bool circularRadar);
 	~CRadarHandler();
@@ -19,66 +20,67 @@
 	void MoveUnit(CUnit* unit);
 	void RemoveUnit(CUnit* unit);
 
+	inline int GetSquare(const float3&amp; pos) const
+	{
+		const int gx = (int)pos.x / (SQUARE_SIZE * RADAR_SIZE);
+		const int gz = (int)pos.z / (SQUARE_SIZE * RADAR_SIZE);
+		const int rowIdx = std::max(0, std::min(ysize - 1, gz));
+		const int colIdx = std::max(0, std::min(xsize - 1, gx));
+		return (rowIdx * xsize) + colIdx;
+	}
+
 	bool InRadar(const float3&amp; pos, int allyTeam) {
-		const int gx = (int) pos.x / (SQUARE_SIZE * RADAR_SIZE);
-		const int gz = (int) pos.z / (SQUARE_SIZE * RADAR_SIZE);
-		const int rowIdx = std::max(0, std::min(ysize - 1, gz)) * xsize;
-		const int colIdx = std::max(0, std::min(xsize - 1, gx));
-		const int square = rowIdx + colIdx;
+		const int square = GetSquare(pos);
 		if (pos.y &lt; -0.5f) {
-			#ifdef DEBUG
-			assert(square &lt; sonarMaps[allyTeam].size());
-			#endif
+			assert(static_cast&lt;unsigned&gt;(square) &lt; sonarMaps[allyTeam].size());
 			return (sonarMaps[allyTeam][square] &amp;&amp; !commonSonarJammerMap[square]);
 		}
-		else if (!circularRadar &amp;&amp; pos.y &gt; 0.5f) {
-			#ifdef DEBUG
-			assert(square &lt; airRadarMaps[allyTeam].size());
-			#endif
+		else if (!circularRadar &amp;&amp; (pos.y &gt; 0.5f)) {
+			assert(static_cast&lt;unsigned&gt;(square) &lt; airRadarMaps[allyTeam].size());
 			return (airRadarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square]);
 		}
 		else {
-			#ifdef DEBUG
-			assert(square &lt; radarMaps[allyTeam].size());
-			#endif
+			assert(static_cast&lt;unsigned&gt;(square) &lt; radarMaps[allyTeam].size());
 			return (radarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square]);
 		}
 	}
 
 	bool InRadar(const CUnit* unit, int allyTeam) {
-		if (unit-&gt;stealth)
-			return false;
 
-		const int rowIdx = std::max(0, std::min(ysize - 1, (int) unit-&gt;pos.z / (SQUARE_SIZE * RADAR_SIZE))) * xsize;
-		const int colIdx = std::max(0, std::min(xsize - 1, (int) unit-&gt;pos.x / (SQUARE_SIZE * RADAR_SIZE)));
-		const int square = rowIdx + colIdx;
-
 		if (unit-&gt;isUnderWater) {
-			#ifdef DEBUG
-			assert(square &lt; sonarMaps[allyTeam].size());
-			#endif
-			return (!!sonarMaps[allyTeam][square]) &amp;&amp; !commonSonarJammerMap[square];
+			if (unit-&gt;sonarStealth) {
+				return false;
+			}
+			const int square = GetSquare(unit-&gt;pos);
+			assert(static_cast&lt;unsigned&gt;(square) &lt; sonarMaps[allyTeam].size());
+			return !!sonarMaps[allyTeam][square] &amp;&amp; !commonSonarJammerMap[square];
 		}
-		if (!circularRadar &amp;&amp; unit-&gt;useAirLos) {
-			#ifdef DEBUG
-			assert(square &lt; airRadarMaps[allyTeam].size());
-			#endif
+		else if (!circularRadar &amp;&amp; unit-&gt;useAirLos) {
+			if (unit-&gt;stealth) {
+				return false;
+			}
+			const int square = GetSquare(unit-&gt;pos);
+			assert(static_cast&lt;unsigned&gt;(square) &lt; airRadarMaps[allyTeam].size());
 			return airRadarMaps[allyTeam][square] &amp;&amp; !commonJammerMap[square];
-		} else {
-			#ifdef DEBUG
-			assert(square &lt; radarMaps[allyTeam].size() &amp;&amp; square &lt; sonarMaps[allyTeam].size());
-			#endif
-			return (radarMaps[allyTeam][square] || (unit-&gt;pos.y &lt;= 1 &amp;&amp; sonarMaps[allyTeam][square])) &amp;&amp; !commonJammerMap[square];
 		}
+		else {
+			const int square = GetSquare(unit-&gt;pos);
+			assert((static_cast&lt;unsigned&gt;(square) &lt; radarMaps[allyTeam].size()) &amp;&amp;
+					(static_cast&lt;unsigned&gt;(square) &lt; sonarMaps[allyTeam].size()));
+			return (radarMaps[allyTeam][square]
+			        &amp;&amp; !unit-&gt;stealth
+			        &amp;&amp; !commonJammerMap[square])
+			       ||
+			       ((unit-&gt;pos.y &lt;= 1.0f)
+			        &amp;&amp; sonarMaps[allyTeam][square]
+			        &amp;&amp; !unit-&gt;sonarStealth
+			        &amp;&amp; !commonSonarJammerMap[square]);
+		}
 	}
 
 	bool InSeismicDistance(const CUnit* unit, int allyTeam) {
-		const int rowIdx = std::max(0, std::min(ysize - 1, (int) unit-&gt;pos.z / (SQUARE_SIZE * RADAR_SIZE))) * xsize;
-		const int colIdx = std::max(0, std::min(xsize - 1, (int) unit-&gt;pos.x / (SQUARE_SIZE * RADAR_SIZE)));
-		const int square = rowIdx + colIdx;
-		#ifdef DEBUG
-		assert(square &lt; seismicMaps[allyTeam].size());
-		#endif
+		const int square = GetSquare(unit-&gt;pos);
+		assert(static_cast&lt;unsigned&gt;(square) &lt; seismicMaps[allyTeam].size());
 		return !!seismicMaps[allyTeam][square];
 	}
 

Modified: branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/MoveTypes/AirMoveType.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -7,7 +7,7 @@
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Mobility.h&quot;
 #include &quot;myMath.h&quot;
-#include &quot;Rendering/UnitModels/3DOParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/GeometricObjects.h&quot;
 #include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;

Modified: branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -10,7 +10,7 @@
 #include &quot;LogOutput.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
-#include &quot;Rendering/UnitModels/3DOParser.h&quot;
+#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
 #include &quot;Sim/Units/COB/CobInstance.h&quot;

Modified: branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,10 +1,13 @@
 
 #include &quot;StdAfx.h&quot;
+
 #include &quot;ScriptMoveType.h&quot;
+
 #include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Map/MapInfo.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
+#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
 #include &quot;Sim/Misc/AirBaseHandler.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
@@ -14,7 +17,7 @@
 #include &quot;Sim/Units/UnitTypes/Building.h&quot;
 #include &quot;System/Matrix44f.h&quot;
 #include &quot;System/myMath.h&quot;
-#include &quot;mmgr.h&quot;
+#include &quot;System/mmgr.h&quot;
 
 CR_BIND_DERIVED(CScriptMoveType, AMoveType, (NULL));
 
@@ -152,6 +155,8 @@
 		}
 	}
 	qf-&gt;MovedUnit(owner);
+
+	owner-&gt;isUnderWater = ((owner-&gt;pos.y + owner-&gt;model-&gt;height) &lt; 0.0f);
 };
 
 

Modified: branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,22 +1,24 @@
 #include &quot;StdAfx.h&quot;
+
 #include &quot;TAAirMoveType.h&quot;
-#include &quot;Sim/Misc/QuadField.h&quot;
+
+#include &quot;Mobility.h&quot;
+#include &quot;Game/Player.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Rendering/UnitModels/3DModelParser.h&quot;
+#include &quot;Sim/Misc/GeometricObjects.h&quot;
+#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
 #include &quot;Sim/Misc/LosHandler.h&quot;
 #include &quot;Sim/Misc/RadarHandler.h&quot;
-#include &quot;Sim/Units/COB/CobFile.h&quot;
-#include &quot;Sim/Units/COB/CobInstance.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &quot;myMath.h&quot;
-#include &quot;Matrix44f.h&quot;
-#include &quot;Rendering/UnitModels/3DOParser.h&quot;
-#include &quot;Game/Player.h&quot;
+#include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;Sim/Misc/GeometricObjects.h&quot;
-#include &quot;Mobility.h&quot;
 #include &quot;Sim/Units/UnitTypes/TransportUnit.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
-#include &quot;Sim/Misc/GroundBlockingObjectMap.h&quot;
+#include &quot;Sim/Units/COB/CobFile.h&quot;
+#include &quot;Sim/Units/COB/CobInstance.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/myMath.h&quot;
+#include &quot;System/Matrix44f.h&quot;
 
 
 CR_BIND_DERIVED(CTAAirMoveType, AAirMoveType, (NULL));

Modified: branches/gml/rts/Sim/Projectiles/FireProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/FireProjectile.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Projectiles/FireProjectile.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -75,7 +75,7 @@
 			sub.pos.y+=sub.posDif.y;
 			sub.posDif.y=0;
 			sub.rotSpeed=(gu-&gt;usRandFloat()-0.5f)*4;
-			sub.smokeType=gu-&gt;usRandInt()%6;
+			sub.smokeType=gu-&gt;usRandInt()% ph-&gt;smoketex.size();
 			subParticles.push_front(sub);
 
 			sub.maxSize=(0.7f+gu-&gt;usRandFloat()*0.3f)*particleSize;

Modified: branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -67,7 +67,7 @@
 	textureAtlas = SAFE_NEW CTextureAtlas(2048, 2048);
 
 	// used to block resources_map.tdf from loading textures
-	std::set&lt;std::string&gt; blockMapTexNames;
+	set&lt;string&gt; blockMapTexNames;
 
 	LuaParser resourcesParser(&quot;gamedata/resources.lua&quot;,
 	                          SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
@@ -75,40 +75,61 @@
 		logOutput.Print(resourcesParser.GetErrorLog());
 	}
 	const LuaTable rootTable = resourcesParser.GetRoot();
-	const LuaTable ptTable = rootTable.SubTable(&quot;graphics&quot;).SubTable(&quot;projectileTextures&quot;);
-	//add all textures in projectiletextures section
-	std::map&lt;std::string, std::string&gt; ptex;
+	const LuaTable gfxTable = rootTable.SubTable(&quot;graphics&quot;);
+
+	const LuaTable ptTable = gfxTable.SubTable(&quot;projectileTextures&quot;);
+	// add all textures in projectiletextures section
+	map&lt;string, string&gt; ptex;
 	ptTable.GetMap(ptex);
 
-	for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex.begin(); pi!=ptex.end(); ++pi)
-	{
+	for (map&lt;string, string&gt;::iterator pi=ptex.begin(); pi!=ptex.end(); ++pi) {
 		textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 		blockMapTexNames.insert(StringToLower(pi-&gt;first));
 	}
-	//add all texture from sections within projectiletextures section
-	std::vector&lt;std::string&gt; seclist; 
+
+	// add all texture from sections within projectiletextures section
+	vector&lt;string&gt; seclist; 
 	ptTable.GetKeys(seclist);
-	for(int i=0; i&lt;seclist.size(); i++)
-	{
+	for (int i = 0; i &lt; seclist.size(); i++) {
 		const LuaTable ptSubTable = ptTable.SubTable(seclist[i]);
 		if (ptSubTable.IsValid()) {
-			std::map&lt;std::string,std::string&gt; ptex2;
+			map&lt;string, string&gt; ptex2;
 			ptSubTable.GetMap(ptex2);
-			for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
-			{
+			for (map&lt;string, string&gt;::iterator pi = ptex2.begin(); pi != ptex2.end(); ++pi) {
 				textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 				blockMapTexNames.insert(StringToLower(pi-&gt;first));
 			}
 		}
 	}
 
-	const LuaTable smokeTable = rootTable.SubTable(&quot;smoke&quot;);
-	for (int i = 0; i &lt; 12; i++) {
-		char num[10];
-		sprintf(num, &quot;%02i&quot;, i);
-		textureAtlas-&gt;AddTexFromFile(std::string(&quot;ismoke&quot;) + num, std::string(&quot;bitmaps/&quot;)+smokeTable.GetString(std::string(&quot;smoke&quot;)+num, std::string(&quot;smoke/smoke&quot;) + num +&quot;.tga&quot;));
-		blockMapTexNames.insert(StringToLower(std::string(&quot;ismoke&quot;) + num));
+	// get the smoke textures, hold the count in 'smokeCount'
+	const LuaTable smokeTable = gfxTable.SubTable(&quot;smoke&quot;);
+	int smokeCount;
+	if (smokeTable.IsValid()) {
+		for (smokeCount = 0; true; smokeCount++) {
+			const string tex = smokeTable.GetString(smokeCount + 1, &quot;&quot;);
+			if (tex.empty()) {
+				break;
+			}
+			const string texName = &quot;bitmaps/&quot; + tex;
+			const string smokeName = &quot;ismoke&quot; + IntToString(smokeCount, &quot;%02i&quot;);
+			textureAtlas-&gt;AddTexFromFile(smokeName, texName);
+			blockMapTexNames.insert(StringToLower(smokeName));
+		}
 	}
+	else {
+		// setup the defaults
+		for (smokeCount = 0; smokeCount &lt; 12; smokeCount++) {
+			const string smokeNum = IntToString(smokeCount, &quot;%02i&quot;);
+			const string smokeName = &quot;ismoke&quot; + smokeNum;
+			const string texName = &quot;bitmaps/smoke/smoke&quot; + smokeNum + &quot;.tga&quot;;
+			textureAtlas-&gt;AddTexFromFile(smokeName, texName);
+			blockMapTexNames.insert(StringToLower(smokeName));
+		}
+	}
+	if (smokeCount &lt;= 0) {
+		throw content_error(&quot;missing smoke textures&quot;);
+	}
 
 	char tex[128][128][4];
 	for (int y = 0; y &lt; 128; y++) { // shield
@@ -160,9 +181,9 @@
 		const LuaTable mapRoot = mapResParser.GetRoot();
 		const LuaTable mapTable = mapRoot.SubTable(&quot;projectileTextures&quot;);
 		//add all textures in projectiletextures section 
-		std::map&lt;std::string,std::string&gt; mptex;
+		map&lt;string, string&gt; mptex;
 		mapTable.GetMap(mptex);
-		std::map&lt;std::string,std::string&gt;::iterator pi;
+		map&lt;string, string&gt;::iterator pi;
 		for (pi = mptex.begin(); pi != mptex.end(); ++pi) {
 			if (blockMapTexNames.find(StringToLower(pi-&gt;first)) == blockMapTexNames.end()) {
 				textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
@@ -170,14 +191,12 @@
 		}
 		//add all texture from sections within projectiletextures section
 		mapTable.GetKeys(seclist);
-		for(int i=0; i&lt;seclist.size(); i++)
-		{
+		for (int i = 0; i &lt; seclist.size(); i++) {
 			const LuaTable mapSubTable = mapTable.SubTable(seclist[i]);
 			if (mapSubTable.IsValid()) {
-				std::map&lt;std::string,std::string&gt; ptex2;
+				map&lt;string, string&gt; ptex2;
 				mapSubTable.GetMap(ptex2);
-				for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
-				{
+				for (map&lt;string, string&gt;::iterator pi = ptex2.begin(); pi != ptex2.end(); ++pi) {
 					if (blockMapTexNames.find(StringToLower(pi-&gt;first)) == blockMapTexNames.end()) {
 						textureAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 					}
@@ -202,10 +221,9 @@
 	perlintex       = textureAtlas-&gt;GetTexture(&quot;perlintex&quot;);
 	flametex        = textureAtlas-&gt;GetTexture(&quot;flame&quot;);
 
-	for (int i = 0; i &lt; 12; i++) {
-		char num[10];
-		sprintf(num, &quot;%02i&quot;, i);
-		smoketex[i] = textureAtlas-&gt;GetTexture(std::string(&quot;ismoke&quot;) + num);
+	for (int i = 0; i &lt; smokeCount; i++) {
+		const string smokeName = &quot;ismoke&quot; + IntToString(i, &quot;%02i&quot;);
+		smoketex.push_back(textureAtlas-&gt;GetTexture(smokeName));
 	}
 
 #define GETTEX(t, b) textureAtlas-&gt;GetTextureWithBackup((t), (b))
@@ -231,49 +249,49 @@
 
 	groundFXAtlas = SAFE_NEW CTextureAtlas(2048, 2048);
 	//add all textures in groundfx section
-	const LuaTable groundfxTable = resourcesParser.GetRoot().SubTable(&quot;resources&quot;).SubTable(&quot;graphics&quot;).SubTable(&quot;groundfx&quot;);
+	const LuaTable groundfxTable = gfxTable.SubTable(&quot;groundfx&quot;);
 	groundfxTable.GetMap(ptex);
-	for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex.begin(); pi!=ptex.end(); ++pi)
-	{
+	for (map&lt;string, string&gt;::iterator pi = ptex.begin(); pi != ptex.end(); ++pi) {
 		groundFXAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 	}
 	//add all texture from sections within groundfx section
 	groundfxTable.GetKeys(seclist);
-	for(int i=0; i&lt;seclist.size(); i++)
-	{
+	for (int i = 0; i &lt; seclist.size(); i++) {
 		const LuaTable gfxSubTable = groundfxTable.SubTable(seclist[i]);
 		if (gfxSubTable.IsValid()) {
-			std::map&lt;std::string,std::string&gt; ptex2;
+			map&lt;string, string&gt; ptex2;
 			gfxSubTable.GetMap(ptex2);
-			for(std::map&lt;std::string,std::string&gt;::iterator pi=ptex2.begin(); pi!=ptex2.end(); ++pi)
-			{
+			for (map&lt;string, string&gt;::iterator pi = ptex2.begin(); pi != ptex2.end(); ++pi) {
 				groundFXAtlas-&gt;AddTexFromFile(pi-&gt;first, &quot;bitmaps/&quot; + pi-&gt;second);
 			}
 		}
 	}
 
-	if (!groundFXAtlas-&gt;Finalize())
+	if (!groundFXAtlas-&gt;Finalize()) {
 		logOutput.Print(&quot;Could not finalize groundFX texture atlas. Use less/smaller textures.&quot;);
+	}
 
 	groundflashtex = groundFXAtlas-&gt;GetTexture(&quot;groundflash&quot;);
 	groundringtex = groundFXAtlas-&gt;GetTexture(&quot;groundring&quot;);
 	seismictex = groundFXAtlas-&gt;GetTexture(&quot;seismic&quot;);
 
-	if(shadowHandler-&gt;canUseShadows){
-		projectileShadowVP=LoadVertexProgram(&quot;projectileshadow.vp&quot;);
+	if (shadowHandler-&gt;canUseShadows) {
+		projectileShadowVP = LoadVertexProgram(&quot;projectileshadow.vp&quot;);
 	}
 
 
 	flying3doPieces = SAFE_NEW FlyingPiece_List;
 	flyingPieces.push_back(flying3doPieces);
 
-	for(int a=0;a&lt;4;++a){
+	for (int a = 0; a &lt; 4; ++a) {
 		perlinBlend[a]=0;
 	}
+
 	unsigned char tempmem[4*16*16];
-	for(int a=0;a&lt;4*16*16;++a)
-		tempmem[a]=0;
-	for(int a=0;a&lt;8;++a){
+	for (int a = 0; a &lt; 4 * 16 * 16; ++a) {
+		tempmem[a] = 0;
+	}
+	for (int a = 0; a &lt; 8; ++a) {
 		glGenTextures(1, &amp;perlinTex[a]);
 		glBindTexture(GL_TEXTURE_2D, perlinTex[a]);
 		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
@@ -283,39 +301,47 @@
 
 	drawPerlinTex=false;
 
-	if(shadowHandler &amp;&amp; shadowHandler-&gt;drawShadows &amp;&amp; GLEW_EXT_framebuffer_object &amp;&amp; !GLEW_ATI_envmap_bumpmap){	//this seems to bug on ati cards so disable it on those (just some random ati extension to detect ati cards), should be fixed by someone that actually has a ati card
+	if (shadowHandler &amp;&amp; shadowHandler-&gt;drawShadows &amp;&amp;
+	    GLEW_EXT_framebuffer_object &amp;&amp; !GLEW_ATI_envmap_bumpmap) {
+		// this seems to bug on ati cards so disable it on those
+		// (just some random ati extension to detect ati cards),
+		// should be fixed by someone that actually has a ati card
 		perlinFB = instantiate_fb(512, 512, FBO_NEED_COLOR);
-		if (perlinFB &amp;&amp; perlinFB-&gt;valid()){
+		if (perlinFB &amp;&amp; perlinFB-&gt;valid()) {
 			drawPerlinTex=true;
 			perlinFB-&gt;attachTexture(textureAtlas-&gt;gltex, GL_TEXTURE_2D, FBO_ATTACH_COLOR);
 			perlinFB-&gt;checkFBOStatus();
 		}
 	}
-	else
+	else {
 		perlinFB = 0;
+	}
 }
 
 CProjectileHandler::~CProjectileHandler()
 {
-	for(int a=0;a&lt;8;++a)
+	for (int a = 0; a &lt; 8; ++a) {
 		glDeleteTextures (1, &amp;perlinTex[a]);
+	}
 
 	Projectile_List::iterator psi;
-	for(psi=ps.begin();psi!=ps.end();++psi)
+	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		delete *psi;
-	std::vector&lt;CGroundFlash*&gt;::iterator gfi;
-	for(gfi=groundFlashes.begin();gfi!=groundFlashes.end();++gfi)
+	}
+	vector&lt;CGroundFlash*&gt;::iterator gfi;
+	for(gfi = groundFlashes.begin(); gfi != groundFlashes.end(); ++gfi) {
 		delete *gfi;
+	}
 	distlist.clear();
 
-	if(shadowHandler-&gt;canUseShadows){
+	if (shadowHandler-&gt;canUseShadows) {
 		glSafeDeleteProgram(projectileShadowVP);
 	}
 
 	/* Also invalidates flying3doPieces and flyings3oPieces. */
-	for(std::list&lt;FlyingPiece_List*&gt;::iterator pti=flyingPieces.begin();pti!=flyingPieces.end();++pti){
+	for (list&lt;FlyingPiece_List*&gt;::iterator pti = flyingPieces.begin(); pti != flyingPieces.end(); ++pti) {
 		FlyingPiece_List * fpl = *pti;
-		for(std::list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();++pi){
+		for(list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();++pi){
 			if ((*pi)-&gt;verts != NULL){
 				delete[] ((*pi)-&gt;verts);
 			}
@@ -365,7 +391,7 @@
 	SCOPED_TIMER(&quot;Projectile handler&quot;);
 
 	Projectile_List::iterator psi=ps.begin();
-	while(psi!= ps.end()){
+	while (psi != ps.end()) {
 		CProjectile *p = *psi;
 		if(p-&gt;deleteMe){
 			Projectile_List::iterator prev=psi++;
@@ -377,23 +403,24 @@
 		}
 	}
 
-	for(unsigned int i = 0; i &lt; groundFlashes.size();)
-	{
+	for (unsigned int i = 0; i &lt; groundFlashes.size(); /* do nothing */) {
 		CGroundFlash *gf = groundFlashes[i];
-		if (!gf-&gt;Update ())
-		{
+		if (!gf-&gt;Update ()) {
 			// swap gf with the groundflash at the end of the list, so pop_back() can be used to erase it
-			if ( i &lt; groundFlashes.size()-1 )
-				std::swap (groundFlashes.back(), groundFlashes[i]);
+			if (i &lt; groundFlashes.size() - 1) {
+				std::swap(groundFlashes.back(), groundFlashes[i]);
+			}
 			groundFlashes.pop_back();
 			delete gf;
-		} else i++;
+		} else {
+			i++;
+		}
 	}
 
-	for(std::list&lt;FlyingPiece_List*&gt;::iterator pti=flyingPieces.begin();pti!=flyingPieces.end();++pti){
+	for(list&lt;FlyingPiece_List*&gt;::iterator pti=flyingPieces.begin();pti!=flyingPieces.end();++pti){
 		FlyingPiece_List * fpl = *pti;
 		/* Note: nothing in the third clause of this loop. TODO Rewrite it as a while */
-		for(std::list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();){
+		for(list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();){
 			(*pi)-&gt;pos+=(*pi)-&gt;speed;
 			(*pi)-&gt;speed*=0.996f;
 			(*pi)-&gt;speed.y+=mapInfo-&gt;map.gravity;
@@ -432,7 +459,7 @@
 
 	va-&gt;Initialize();
 	numFlyingPieces += flying3doPieces-&gt;size();
-	for(std::list&lt;FlyingPiece*&gt;::iterator pi=flying3doPieces-&gt;begin();pi!=flying3doPieces-&gt;end();++pi){
+	for(list&lt;FlyingPiece*&gt;::iterator pi=flying3doPieces-&gt;begin();pi!=flying3doPieces-&gt;end();++pi){
 		CMatrix44f m;
 		m.Rotate((*pi)-&gt;rot,(*pi)-&gt;rotAxis);
 		float3 interPos=(*pi)-&gt;pos+(*pi)-&gt;speed*gu-&gt;timeOffset;
@@ -484,7 +511,7 @@
 
 			numFlyingPieces += fpl-&gt;size();
 
-			for(std::list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();++pi){
+			for(list&lt;FlyingPiece*&gt;::iterator pi=fpl-&gt;begin();pi!=fpl-&gt;end();++pi){
 				CMatrix44f m;
 				m.Rotate((*pi)-&gt;rot,(*pi)-&gt;rotAxis);
 				float3 interPos=(*pi)-&gt;pos+(*pi)-&gt;speed*gu-&gt;timeOffset;
@@ -731,7 +758,7 @@
 	CGroundFlash::va=GetVertexArray();
 	CGroundFlash::va-&gt;Initialize();
 
-	std::vector&lt;CGroundFlash*&gt;::iterator gfi;
+	vector&lt;CGroundFlash*&gt;::iterator gfi;
 	for(gfi=groundFlashes.begin();gfi!=groundFlashes.end();++gfi){
 		if ((*gfi)-&gt;alwaysVisible || gu-&gt;spectatingFullView ||
 		    loshandler-&gt;InAirLos((*gfi)-&gt;pos,gu-&gt;myAllyTeam))
@@ -781,7 +808,7 @@
 	FlyingPiece_List * pieceList = NULL;
 
 	while(flyings3oPieces.size()&lt;=textureType)
-		flyings3oPieces.push_back(std::vector&lt;FlyingPiece_List*&gt;());
+		flyings3oPieces.push_back(vector&lt;FlyingPiece_List*&gt;());
 
 	while(flyings3oPieces[textureType].size()&lt;=team){
 		//logOutput.Print(&quot;Creating piece list %d %d.&quot;, textureType, flyings3oPieces[textureType].size());

Modified: branches/gml/rts/Sim/Projectiles/ProjectileHandler.h
===================================================================
--- branches/gml/rts/Sim/Projectiles/ProjectileHandler.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Projectiles/ProjectileHandler.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -99,7 +99,7 @@
 	AtlasedTexture randdotstex;
 	AtlasedTexture smoketrailtex;
 	AtlasedTexture waketex;
-	AtlasedTexture smoketex[12];
+	std::vector&lt;AtlasedTexture&gt; smoketex;
 	AtlasedTexture perlintex;
 	AtlasedTexture flametex;
 

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -66,8 +66,8 @@
 	float alpha=std::max(0.f,1-age/(4+size*30));
 	float modAge=sqrtf(age+2);
 
-	for(int a=0;a&lt;numSmoke;++a){
-		int tex=a%12;
+	for (int a = 0; a &lt; numSmoke; ++a) {
+		int tex = a % ph-&gt;smoketex.size();
 		//float xmod=0.125f+(float(int(tex%6)))/16;
 		//float ymod=(int(tex/6))/16.0f;
 

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -40,7 +40,7 @@
 
 void CSmokeProjectile::Init(const float3&amp; pos, CUnit *owner)
 {
-	textureNum=(int)(gu-&gt;usRandFloat()*12);
+	textureNum=(int)(gu-&gt;usRandInt() % ph-&gt;smoketex.size());
 
 	if(pos.y-ground-&gt;GetApproximateHeight(pos.x,pos.z)&gt;10)
 		useAirLos=true;
@@ -62,7 +62,7 @@
 	ageSpeed=1.0f/ttl;
 	checkCol=false;
 	castShadow=true;
-	textureNum=(int)(gu-&gt;usRandFloat()*12);
+	textureNum=(int)(gu-&gt;usRandInt() % ph-&gt;smoketex.size());
 
 	if(pos.y-ground-&gt;GetApproximateHeight(pos.x,pos.z)&gt;10)
 		useAirLos=true;

Modified: branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp
===================================================================
--- branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -43,7 +43,7 @@
 
 void CSmokeProjectile2::Init(const float3&amp; pos, CUnit *owner)
 {
-	textureNum=(int)(gu-&gt;usRandFloat()*12);
+	textureNum=(int)(gu-&gt;usRandInt() % ph-&gt;smoketex.size());
 
 	if(pos.y-ground-&gt;GetApproximateHeight(pos.x,pos.z)&gt;10)
 		useAirLos=true;
@@ -73,7 +73,7 @@
 	PUSH_CODE_MODE;
 	ENTER_MIXED;
 	glowFalloff=4.5f+gu-&gt;usRandFloat()*6;
-	textureNum=(int)(gu-&gt;usRandFloat()*12);
+	textureNum=(int)(gu-&gt;usRandInt() % ph-&gt;smoketex.size());
 	POP_CODE_MODE;
 }
 

Modified: branches/gml/rts/Sim/Units/COB/CobInstance.cpp
===================================================================
--- branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/COB/CobInstance.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -111,6 +111,7 @@
 #define ALPHA_THRESHOLD          103 // set or get
 #define SET_WEAPON_UNIT_TARGET   106 // get (fake set)
 #define SET_WEAPON_GROUND_TARGET 107 // get (fake set)
+#define SONAR_STEALTH            108 // set or get
 
 // NOTE: [LUA0 - LUA9] are defined in CobThread.cpp as [110 - 119]
 
@@ -1177,6 +1178,9 @@
 	case STEALTH: {
 		return unit-&gt;stealth ? 1 : 0;
 	}
+	case SONAR_STEALTH: {
+		return unit-&gt;sonarStealth ? 1 : 0;
+	}
 	case CRASHING:
 		return !!unit-&gt;crashing;
 	case ALPHA_THRESHOLD: {
@@ -1615,6 +1619,10 @@
 			unit-&gt;stealth = !!param;
 			break;
 		}
+		case SONAR_STEALTH: {
+			unit-&gt;sonarStealth = !!param;
+			break;
+		}
 		case CRASHING: {
 			if(dynamic_cast&lt;CAirMoveType*&gt;(unit-&gt;moveType)){
 				if(!!param){

Modified: branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -81,65 +81,66 @@
 	lastPC2(-1)
 {
 	CommandDescription c;
-	if(owner-&gt;unitDef-&gt;canRepair){
-		c.id=CMD_REPAIR;
-		c.action=&quot;repair&quot;;
-		c.type=CMDTYPE_ICON_UNIT_OR_AREA;
-		c.name=&quot;Repair&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Repair: Repairs another unit&quot;;
+	if (owner-&gt;unitDef-&gt;canRepair) {
+		c.id = CMD_REPAIR;
+		c.action = &quot;repair&quot;;
+		c.type = CMDTYPE_ICON_UNIT_OR_AREA;
+		c.name = &quot;Repair&quot;;
+		c.mouseicon = c.name;
+		c.tooltip = &quot;Repair: Repairs another unit&quot;;
 		possibleCommands.push_back(c);
-	} else if(owner-&gt;unitDef-&gt;canAssist){
-		c.id=CMD_REPAIR;
-		c.action=&quot;assist&quot;;
-		c.type=CMDTYPE_ICON_UNIT_OR_AREA;
-		c.name=&quot;Assist&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Assist: Help build something&quot;;
+	}
+	else if (owner-&gt;unitDef-&gt;canAssist) {
+		c.id = CMD_REPAIR;
+		c.action = &quot;assist&quot;;
+		c.type = CMDTYPE_ICON_UNIT_OR_AREA;
+		c.name = &quot;Assist&quot;;
+		c.mouseicon = c.name;
+		c.tooltip = &quot;Assist: Help build something&quot;;
 		possibleCommands.push_back(c);
 	}
 
-	if(owner-&gt;unitDef-&gt;canReclaim){
-		c.id=CMD_RECLAIM;
-		c.action=&quot;reclaim&quot;;
-		c.type=CMDTYPE_ICON_UNIT_FEATURE_OR_AREA;
-		c.name=&quot;Reclaim&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Reclaim: Sucks in the metal/energy content of a unit/feature and add it to your storage&quot;;
+	if (owner-&gt;unitDef-&gt;canReclaim) {
+		c.id = CMD_RECLAIM;
+		c.action = &quot;reclaim&quot;;
+		c.type = CMDTYPE_ICON_UNIT_FEATURE_OR_AREA;
+		c.name = &quot;Reclaim&quot;;
+		c.mouseicon = c.name;
+		c.tooltip = &quot;Reclaim: Sucks in the metal/energy content of a unit/feature and add it to your storage&quot;;
 		possibleCommands.push_back(c);
 	}
 
-	if(owner-&gt;unitDef-&gt;canRestore){
-		c.id=CMD_RESTORE;
-		c.action=&quot;restore&quot;;
-		c.type=CMDTYPE_ICON_AREA;
-		c.name=&quot;Restore&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Restore: Restores an area of the map to its original height&quot;;
+	if (owner-&gt;unitDef-&gt;canRestore) {
+		c.id = CMD_RESTORE;
+		c.action = &quot;restore&quot;;
+		c.type = CMDTYPE_ICON_AREA;
+		c.name = &quot;Restore&quot;;
+		c.mouseicon = c.name;
+		c.tooltip = &quot;Restore: Restores an area of the map to its original height&quot;;
 		c.params.push_back(&quot;200&quot;);
 		possibleCommands.push_back(c);
 	}
 	c.params.clear();
 
-	if(owner-&gt;unitDef-&gt;canResurrect){
-		c.id=CMD_RESURRECT;
-		c.action=&quot;resurrect&quot;;
-		c.type=CMDTYPE_ICON_UNIT_FEATURE_OR_AREA;
-		c.name=&quot;Resurrect&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Resurrect: Resurrects a unit from a feature&quot;;
+	if (owner-&gt;unitDef-&gt;canResurrect) {
+		c.id = CMD_RESURRECT;
+		c.action = &quot;resurrect&quot;;
+		c.type = CMDTYPE_ICON_UNIT_FEATURE_OR_AREA;
+		c.name = &quot;Resurrect&quot;;
+		c.mouseicon = c.name;
+		c.tooltip = &quot;Resurrect: Resurrects a unit from a feature&quot;;
 		possibleCommands.push_back(c);
 	}
-	if(owner-&gt;unitDef-&gt;canCapture){
-		c.id=CMD_CAPTURE;
-		c.action=&quot;capture&quot;;
-		c.type=CMDTYPE_ICON_UNIT_OR_AREA;
-		c.name=&quot;Capture&quot;;
-		c.mouseicon=c.name;
-		c.tooltip=&quot;Capture: Captures a unit from the enemy&quot;;
+	if (owner-&gt;unitDef-&gt;canCapture) {
+		c.id = CMD_CAPTURE;
+		c.action = &quot;capture&quot;;
+		c.type = CMDTYPE_ICON_UNIT_OR_AREA;
+		c.name = &quot;Capture&quot;;
+		c.mouseicon = c.name;
+		c.tooltip = &quot;Capture: Captures a unit from the enemy&quot;;
 		possibleCommands.push_back(c);
 	}
-	CBuilder* fac=(CBuilder*)owner;
+	CBuilder* fac = (CBuilder*)owner;
 
 	map&lt;int, string&gt;::const_iterator bi;
 	for (bi = fac-&gt;unitDef-&gt;buildOptions.begin(); bi != fac-&gt;unitDef-&gt;buildOptions.end(); ++bi) {
@@ -153,18 +154,25 @@
 			throw content_error(errmsg);
 		}
 		CommandDescription c;
-		c.id=-ud-&gt;id; //build options are always negative
-		c.action=&quot;buildunit_&quot; + StringToLower(ud-&gt;name);
-		c.type=CMDTYPE_ICON_BUILDING;
-		c.name=name;
-		c.mouseicon=c.name;
+		c.id = -ud-&gt;id; //build options are always negative
+		c.action = &quot;buildunit_&quot; + StringToLower(ud-&gt;name);
+		c.type = CMDTYPE_ICON_BUILDING;
+		c.name = name;
+		c.mouseicon = c.name;
+		c.disabled = (ud-&gt;maxThisUnit &lt;= 0);
 
-		char tmp[500];
-		sprintf(tmp,&quot;\nHealth %.0f\nMetal cost %.0f\nEnergy cost %.0f Build time %.0f&quot;,ud-&gt;health,ud-&gt;metalCost,ud-&gt;energyCost,ud-&gt;buildTime);
-		c.tooltip = string(&quot;Build: &quot;) + ud-&gt;humanName + &quot; - &quot; + ud-&gt;tooltip + tmp;
+		char tmp[1024];
+		sprintf(tmp, &quot;\nHealth %.0f\nMetal cost %.0f\nEnergy cost %.0f Build time %.0f&quot;,
+		        ud-&gt;health, ud-&gt;metalCost, ud-&gt;energyCost, ud-&gt;buildTime);
+		if (c.disabled) {
+			c.tooltip = &quot;\xff\xff\x22\x22&quot; &quot;DISABLED: &quot; &quot;\xff\xff\xff\xff&quot;;
+		} else {
+			c.tooltip = &quot;Build: &quot;;
+		}
+		c.tooltip += ud-&gt;humanName + &quot; - &quot; + ud-&gt;tooltip + tmp;
 
 		possibleCommands.push_back(c);
-		buildOptions[c.id]=name;
+		buildOptions[c.id] = name;
 	}
 	uh-&gt;AddBuilderCAI(this);
 }

Modified: branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/CommandAI/FactoryCAI.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -39,12 +39,14 @@
 				CR_MEMBER(numQued)
 				));
 
+
 CFactoryCAI::CFactoryCAI()
 : CCommandAI(),
 	building(false),
 	lastRestrictedWarning(0)
 {}
 
+
 CFactoryCAI::CFactoryCAI(CUnit* owner)
 : CCommandAI(owner),
 	building(false),
@@ -111,33 +113,43 @@
 		}
 
 		CommandDescription c;
-		c.id=-ud-&gt;id; //build options are always negative
-		c.action=&quot;buildunit_&quot; + StringToLower(ud-&gt;name);
-		c.type=CMDTYPE_ICON;
-		c.name=name;
-		c.mouseicon=c.name;
+		c.id = -ud-&gt;id; //build options are always negative
+		c.action = &quot;buildunit_&quot; + StringToLower(ud-&gt;name);
+		c.type = CMDTYPE_ICON;
+		c.name = name;
+		c.mouseicon = c.name;
+		c.disabled = (ud-&gt;maxThisUnit &lt;= 0);
 
-		char tmp[500];
-		sprintf(tmp,&quot;\nHealth %.0f\nMetal cost %.0f\nEnergy cost %.0f Build time %.0f&quot;,ud-&gt;health,ud-&gt;metalCost,ud-&gt;energyCost,ud-&gt;buildTime);
-		c.tooltip = string(&quot;Build: &quot;) + ud-&gt;humanName + &quot; - &quot; + ud-&gt;tooltip + tmp;
+		char tmp[1024];
+		sprintf(tmp, &quot;\nHealth %.0f\nMetal cost %.0f\nEnergy cost %.0f Build time %.0f&quot;,
+		        ud-&gt;health, ud-&gt;metalCost, ud-&gt;energyCost, ud-&gt;buildTime);
+		if (c.disabled) {
+			c.tooltip = &quot;\xff\xff\x22\x22&quot; &quot;DISABLED: &quot; &quot;\xff\xff\xff\xff&quot;;
+		} else {
+			c.tooltip = &quot;Build: &quot;;
+		}
+		c.tooltip += ud-&gt;humanName + &quot; - &quot; + ud-&gt;tooltip + tmp;
 
 		possibleCommands.push_back(c);
 		BuildOption bo;
-		bo.name=name;
-		bo.fullName=name;
-		bo.numQued=0;
-		buildOptions[c.id]=bo;
+		bo.name = name;
+		bo.fullName = name;
+		bo.numQued = 0;
+		buildOptions[c.id] = bo;
 	}
 }
 
+
 CFactoryCAI::~CFactoryCAI()
 {
 }
 
+
 void CFactoryCAI::PostLoad()
 {
 }
 
+
 void CFactoryCAI::GiveCommandReal(const Command&amp; c)
 {
 	// move is always allowed for factories (passed to units it produces)
@@ -203,65 +215,65 @@
 		return;
 	}
 
-	BuildOption &amp;bo=boi-&gt;second;
+	BuildOption &amp;bo = boi-&gt;second;
 
-	int numItems=1;
-	if(c.options&amp; SHIFT_KEY)
-		numItems*=5;
-	if(c.options &amp; CONTROL_KEY)
-		numItems*=20;
+	int numItems = 1;
+	if (c.options &amp; SHIFT_KEY)   { numItems *= 5; }
+	if (c.options &amp; CONTROL_KEY) { numItems *= 20; }
 
-	if(c.options &amp; RIGHT_MOUSE_KEY){
-		bo.numQued-=numItems;
-		if(bo.numQued&lt;0)
-			bo.numQued=0;
+	if (c.options &amp; RIGHT_MOUSE_KEY) {
+		bo.numQued -= numItems;
+		if (bo.numQued &lt; 0) {
+			bo.numQued = 0;
+		}
 
-		int numToErase=numItems;
-		if(c.options &amp; ALT_KEY){
-			for(unsigned int cmdNum=0;cmdNum&lt;commandQue.size() &amp;&amp; numToErase;++cmdNum){
-				if(commandQue[cmdNum].id==c.id){
-					commandQue[cmdNum].id=CMD_STOP;
+		int numToErase = numItems;
+		if (c.options &amp; ALT_KEY) {
+			for (unsigned int cmdNum = 0; cmdNum &lt; commandQue.size() &amp;&amp; numToErase; ++cmdNum) {
+				if (commandQue[cmdNum].id == c.id) {
+					commandQue[cmdNum].id = CMD_STOP;
 					numToErase--;
 				}
 			}
-		} else {
-			for(int cmdNum=commandQue.size()-1;cmdNum!=-1 &amp;&amp; numToErase;--cmdNum){
-				if(commandQue[cmdNum].id==c.id){
-					commandQue[cmdNum].id=CMD_STOP;
+		}
+		else {
+			for (int cmdNum = commandQue.size() - 1; cmdNum != -1 &amp;&amp; numToErase; --cmdNum) {
+				if (commandQue[cmdNum].id == c.id) {
+					commandQue[cmdNum].id = CMD_STOP;
 					numToErase--;
 				}
 			}
 		}
 		UpdateIconName(c.id,bo);
 		SlowUpdate();
-
-	} else {
-		if(c.options &amp; ALT_KEY){
-			for(int a=0;a&lt;numItems;++a){
+	}
+	else {
+		if (c.options &amp; ALT_KEY) {
+			for (int a = 0; a &lt; numItems; ++a) {
 				if (repeatOrders) {
 					Command nc(c);
 					nc.options |= DONT_REPEAT;
-					if (commandQue.empty())
+					if (commandQue.empty()) {
 						commandQue.push_front(nc);
-					else
+					} else {
 						commandQue.insert(commandQue.begin()+1, nc);
+					}
 				} else {
 					commandQue.push_front(c);
 				}
-
 			}
 			if (!repeatOrders) {
 				building=false;
-				CFactory* fac=(CFactory*)owner;
+				CFactory* fac = (CFactory*)owner;
 				fac-&gt;StopBuild();
 			}
 		} else {
-			for(int a=0;a&lt;numItems;++a){
+			for (int a = 0; a &lt; numItems; ++a) {
 				commandQue.push_back(c);
 			}
 		}
-		bo.numQued+=numItems;
-		UpdateIconName(c.id,bo);
+		bo.numQued += numItems;
+		UpdateIconName(c.id, bo);
 
 		SlowUpdate();
 	}
@@ -392,6 +404,7 @@
 	return;
 }
 
+
 void CFactoryCAI::ExecuteStop(Command &amp;c)
 {
 	CFactory* fac=(CFactory*)owner;
@@ -401,6 +414,7 @@
 	return;
 }
 
+
 int CFactoryCAI::GetDefaultCmd(CUnit* pointed, CFeature* feature)
 {
 	if (pointed) {
@@ -413,6 +427,7 @@
 	return CMD_MOVE;
 }
 
+
 void CFactoryCAI::UpdateIconName(int id,BuildOption&amp; bo)
 {
 	vector&lt;CommandDescription&gt;::iterator pci;

Modified: branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1009,7 +1009,22 @@
 void CMobileCAI::IdleCheck(void)
 {
 	if(owner-&gt;unitDef-&gt;canAttack &amp;&amp; owner-&gt;moveState &amp;&amp; owner-&gt;fireState
-			&amp;&amp; !owner-&gt;weapons.empty() &amp;&amp; (!owner-&gt;haveTarget || owner-&gt;weapons[0]-&gt;onlyForward)){
+			&amp;&amp; !owner-&gt;weapons.empty() &amp;&amp; owner-&gt;haveTarget) {
+		if(!owner-&gt;userTarget) {
+			owner-&gt;haveTarget = false;
+		} else if(owner-&gt;pos.distance2D(owner-&gt;userTarget-&gt;pos) &lt; 
+				owner-&gt;maxRange + 200*owner-&gt;moveState*owner-&gt;moveState) {
+			Command c;
+			c.id = CMD_ATTACK;
+			c.options=INTERNAL_ORDER;
+			c.params.push_back(owner-&gt;userTarget-&gt;id);
+			c.timeOut = gs-&gt;frameNum + 140;
+			commandQue.push_front(c);
+			return;
+		}
+	}
+	if(owner-&gt;unitDef-&gt;canAttack &amp;&amp; owner-&gt;moveState &amp;&amp; owner-&gt;fireState
+				&amp;&amp; !owner-&gt;weapons.empty() &amp;&amp; !owner-&gt;haveTarget) {
 		if(owner-&gt;lastAttacker &amp;&amp; owner-&gt;lastAttack + 200 &gt; gs-&gt;frameNum
 				&amp;&amp; !(owner-&gt;unitDef-&gt;noChaseCategory &amp; owner-&gt;lastAttacker-&gt;category)){
 			float3 apos=owner-&gt;lastAttacker-&gt;pos;
@@ -1027,8 +1042,7 @@
 	}
 	if (owner-&gt;unitDef-&gt;canAttack &amp;&amp; (gs-&gt;frameNum &gt;= lastIdleCheck+10)
 			&amp;&amp; owner-&gt;moveState &amp;&amp; owner-&gt;fireState&gt;=2 &amp;&amp;
-			!owner-&gt;weapons.empty() &amp;&amp;
-			(!owner-&gt;haveTarget || owner-&gt;weapons[0]-&gt;onlyForward))
+			!owner-&gt;weapons.empty() &amp;&amp; !owner-&gt;haveTarget)
 	{
 		CUnit* u = helper-&gt;GetClosestEnemyUnit(owner-&gt;pos,
 				owner-&gt;maxRange + 150 * owner-&gt;moveState * owner-&gt;moveState, owner-&gt;allyteam);

Modified: branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -424,9 +424,6 @@
 				continue;
 
 			dropSpots.push_front(nextPos);
-			//float3 p = nextPos; //test to make intended land spots visible
-			//inMapDrawer-&gt;CreatePoint(p,ti-&gt;unit-&gt;unitDef-&gt;name);
-			//p.z +=transport-&gt;transportCapacityUsed*5;
 			nextPos += dir*(gap + ti-&gt;unit-&gt;radius);
 			ti++;
 		}

Modified: branches/gml/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/gml/rts/Sim/Units/Unit.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/Unit.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1125,8 +1125,6 @@
 /******************************************************************************/
 /******************************************************************************/
 
-
-
 void CUnit::AddExperience(float exp)
 {
 	const float oldExp = experience;
@@ -1385,6 +1383,7 @@
 	return r;
 }
 
+
 bool CUnit::AttackGround(const float3 &amp;pos, bool dgun)
 {
 	bool r=false;
@@ -1403,6 +1402,7 @@
 	return r;
 }
 
+
 void CUnit::SetLastAttacker(CUnit* attacker)
 {
 	if(gs-&gt;Ally(team, attacker-&gt;team) || gs-&gt;AlliedTeams(team, attacker-&gt;team)){
@@ -1417,6 +1417,7 @@
 		AddDeathDependence(attacker);
 }
 
+
 void CUnit::DependentDied(CObject* o)
 {
 	if (o == userTarget)   { userTarget   = NULL; }
@@ -1429,16 +1430,19 @@
 	CSolidObject::DependentDied(o);
 }
 
+
 void CUnit::SetUserTarget(CUnit* target)
 {
-	if(userTarget &amp;&amp; lastAttacker!=userTarget)
+	if (userTarget &amp;&amp; (lastAttacker != userTarget)) {
 		DeleteDeathDependence(userTarget);
+	}
 
 	userTarget=target;
-	for(vector&lt;CWeapon*&gt;::iterator wi=weapons.begin();wi!=weapons.end();++wi)
-		(*wi)-&gt;haveUserTarget=false;
+	for(vector&lt;CWeapon*&gt;::iterator wi=weapons.begin();wi!=weapons.end();++wi) {
+		(*wi)-&gt;haveUserTarget = false;
+	}
 
-	if(target){
+	if (target) {
 		AddDeathDependence(target);
 	}
 }
@@ -1446,39 +1450,50 @@
 
 void CUnit::Init(const CUnit* builder)
 {
-	relMidPos=model-&gt;relMidPos;
-	midPos=pos+frontdir*relMidPos.z + updir*relMidPos.y + rightdir*relMidPos.x;
-	losHeight=relMidPos.y+radius*0.5f;
-	height = model-&gt;height;		//TODO: This one would be much better to have either in Constructor or UnitLoader!//why this is always called in unitloader
-	currentFuel=unitDef-&gt;maxFuel;
+	relMidPos = model-&gt;relMidPos;
+	midPos = pos + (frontdir * relMidPos.z)
+	             + (updir    * relMidPos.y)
+	             + (rightdir * relMidPos.x);
+	losHeight = relMidPos.y + (radius * 0.5f);
+	height = model-&gt;height;
+	// TODO: This one would be much better to have either in Constructor
+	//       or UnitLoader! // why this is always called in unitloader
+	currentFuel = unitDef-&gt;maxFuel;
 
-	//All ships starts on water, all other on ground.
-	//TODO: Improve this. There might be cases when this is not correct.
-	if(unitDef-&gt;movedata &amp;&amp; unitDef-&gt;movedata-&gt;moveType==MoveData::Hover_Move){
+	// all ships starts on water, all other on ground.
+	// TODO: Improve this. There might be cases when this is not correct.
+	if (unitDef-&gt;movedata &amp;&amp;
+	    (unitDef-&gt;movedata-&gt;moveType == MoveData::Hover_Move)) {
 		physicalState = Hovering;
-	} else if(floatOnWater) {
+	} else if (floatOnWater) {
 		physicalState = Floating;
 	} else {
 		physicalState = OnGround;
 	}
 
-	//All units are set as ground-blocking.
+	// all units are set as ground-blocking.
 	blocking = true;
 
-	if(pos.y+model-&gt;height&lt;1)	//some torp launchers etc are exactly in the surface and should be considered uw anyway
-		isUnderWater=true;
+	// some torp launchers etc are exactly in the surface and should be considered uw anyway
+	if ((pos.y + model-&gt;height) &lt; 1) {
+		isUnderWater = true;
+	}
 
-	if(!unitDef-&gt;canKamikaze || unitDef-&gt;type==&quot;Building&quot; || unitDef-&gt;type==&quot;Factory&quot;)	//semi hack to make mines not block ground
+	// semi hack to make mines not block ground
+	if (!unitDef-&gt;canKamikaze ||
+	    (unitDef-&gt;type == &quot;Building&quot;) ||
+	    (unitDef-&gt;type == &quot;Factory&quot;)) {
 		Block();
+	}
 
 	UpdateTerrainType();
 
 	Command c;
 	if (unitDef-&gt;canmove || unitDef-&gt;builder) {
-		if (unitDef-&gt;moveState&lt;0) {
+		if (unitDef-&gt;moveState &lt; 0) {
 			if (builder!=NULL) {
 				moveState = builder-&gt;moveState;
-			}else{
+			} else {
 				moveState = 1;
 			}
 		} else {
@@ -1492,10 +1507,10 @@
 	}
 
 	if (commandAI-&gt;CanChangeFireState()) {
-		if (unitDef-&gt;fireState&lt;0) {
-			if (builder!=NULL) {
+		if (unitDef-&gt;fireState &lt; 0) {
+			if (builder != NULL) {
 				fireState = builder-&gt;fireState;
-			}else{
+			} else {
 				fireState = 2;
 			}
 		} else {
@@ -1512,6 +1527,7 @@
 	globalAI-&gt;UnitCreated(this); // FIXME -- add builder?
 }
 
+
 void CUnit::UpdateTerrainType()
 {
 	if (curTerrainType != lastTerrainType) {
@@ -1520,6 +1536,7 @@
 	}
 }
 
+
 void CUnit::CalculateTerrainType()
 {
 	//Optimization: there's only about one unit that actually needs this information
@@ -1551,6 +1568,7 @@
 	}
 }
 
+
 bool CUnit::SetGroup(CGroup* newGroup)
 {
 	if (group != 0) {
@@ -1651,6 +1669,7 @@
 	return false;
 }
 
+
 void CUnit::FinishedBuilding(void)
 {
 	beingBuilt = false;
@@ -1719,7 +1738,6 @@
 }
 
 
-
 // Called when a unit's Killed script finishes executing
 static void CUnitKilledCB(int retCode, void* p1, void* p2)
 {
@@ -1728,6 +1746,7 @@
 	self-&gt;delayedWreckLevel = retCode;
 }
 
+
 void CUnit::KillUnit(bool selfDestruct, bool reclaimed, CUnit* attacker, bool showDeathSequence)
 {
 	if (isDead) {
@@ -1814,7 +1833,6 @@
 }
 
 
-
 bool CUnit::UseMetal(float metal)
 {
 	if (metal &lt; 0) {
@@ -1828,6 +1846,7 @@
 	return canUse;
 }
 
+
 void CUnit::AddMetal(float metal)
 {
 	if (metal &lt; 0) {
@@ -1838,6 +1857,7 @@
 	gs-&gt;Team(team)-&gt;AddMetal(metal);
 }
 
+
 bool CUnit::UseEnergy(float energy)
 {
 	if (energy &lt; 0) {
@@ -1851,6 +1871,7 @@
 	return canUse;
 }
 
+
 void CUnit::AddEnergy(float energy)
 {
 	if (energy &lt; 0) {
@@ -1887,6 +1908,7 @@
 	}
 }
 
+
 void CUnit::Deactivate()
 {
 	if (!activated)
@@ -1909,6 +1931,7 @@
 	}
 }
 
+
 void CUnit::PushWind(float x, float z, float strength)
 {
 	if(strength &gt; unitDef-&gt;windGenerator)
@@ -1923,6 +1946,7 @@
 	cob-&gt;Call(COBFN_SetDirection, (int)GetHeadingFromVector(-x, -z));
 }
 
+
 void CUnit::LoadSave(CLoadSaveInterface* file, bool loading)
 {
 	file-&gt;lsShort(heading);
@@ -1942,6 +1966,7 @@
 	commandAI-&gt;LoadSave(file, loading);
 }
 
+
 void CUnit::IncomingMissile(CMissileProjectile* missile)
 {
 	if (unitDef-&gt;canDropFlare) {
@@ -1955,12 +1980,14 @@
 	}
 }
 
+
 void CUnit::TempHoldFire(void)
 {
 	dontFire = true;
 	AttackUnit(0, true);
 }
 
+
 void CUnit::ReleaseTempHoldFire(void)
 {
 	dontFire = false;
@@ -2191,7 +2218,8 @@
 				CR_MEMBER(radarSquares),
 				CR_MEMBER(oldRadarPos),
 				CR_MEMBER(stealth),
-				CR_RESERVED(16),
+				CR_MEMBER(sonarStealth),
+				CR_RESERVED(15),
 
 				CR_MEMBER(commandAI),
 				CR_MEMBER(moveType),

Modified: branches/gml/rts/Sim/Units/Unit.h
===================================================================
--- branches/gml/rts/Sim/Units/Unit.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/Unit.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -245,6 +245,7 @@
 	std::vector&lt;int&gt; radarSquares;
 	int2 oldRadarPos;
 	bool stealth;
+	bool sonarStealth;
 
 	AMoveType* moveType;
 	AMoveType* prevMoveType;

Modified: branches/gml/rts/Sim/Units/UnitDef.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitDef.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/UnitDef.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -150,6 +150,7 @@
 	int seismicRadius;
 	float seismicSignature;
 	bool stealth;
+	bool sonarStealth;
 
 	bool  buildRange3D;
 	float buildDistance;

Modified: branches/gml/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/UnitDefHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -420,6 +420,7 @@
 	ud.sonarJamRadius = udTable.GetInt(&quot;sonarDistanceJam&quot;, 0);
 
 	ud.stealth        = udTable.GetBool(&quot;stealth&quot;,            false);
+	ud.sonarStealth   = udTable.GetBool(&quot;sonarStealth&quot;,       false);
 	ud.targfac        = udTable.GetBool(&quot;isTargetingUpgrade&quot;, false);
 	ud.isFeature      = udTable.GetBool(&quot;isFeature&quot;,          false);
 	ud.canResurrect   = udTable.GetBool(&quot;canResurrect&quot;,       false);

Modified: branches/gml/rts/Sim/Units/UnitDefHandler.h
===================================================================
--- branches/gml/rts/Sim/Units/UnitDefHandler.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/UnitDefHandler.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -6,25 +6,19 @@
 #include &lt;map&gt;
 #include &lt;set&gt;
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;UnitDef.h&quot;
 
-class CUnitDefHandler;
+
 struct WeaponDef;
+
 class LuaTable;
 
 
-#define TA_UNIT     1
-#define SPRING_UNIT 2
-
-
 //this class takes care of all the unit definitions
 class CUnitDefHandler
 {
 public:
-
-
-	UnitDef *unitDefs;
+	UnitDef* unitDefs;
 	int numUnitDefs;
 	std::map&lt;std::string, int&gt; unitID;
 	std::map&lt;int, std::set&lt;int&gt; &gt; decoyMap;

Modified: branches/gml/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/gml/rts/Sim/Units/UnitLoader.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Units/UnitLoader.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -152,6 +152,7 @@
 	                         unit-&gt;jammerRadius || unit-&gt;sonarJamRadius ||
 	                         unit-&gt;seismicRadius;
 	unit-&gt;stealth = ud-&gt;stealth;
+	unit-&gt;sonarStealth = ud-&gt;sonarStealth;
 	unit-&gt;category = ud-&gt;category;
 	unit-&gt;armorType = ud-&gt;armorType;
 	unit-&gt;floatOnWater =

Modified: branches/gml/rts/Sim/Weapons/StarburstLauncher.cpp
===================================================================
--- branches/gml/rts/Sim/Weapons/StarburstLauncher.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/Sim/Weapons/StarburstLauncher.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -91,5 +91,5 @@
 
 float CStarburstLauncher::GetRange2D(float yDiff) const
 {
-	return range+yDiff*heightMod;
+	return range + (yDiff * heightMod);
 }

Modified: branches/gml/rts/Spring.psd
===================================================================
(Binary files differ)

Modified: branches/gml/rts/System/AutohostInterface.cpp
===================================================================
--- branches/gml/rts/System/AutohostInterface.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/AutohostInterface.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,5 +1,6 @@
 #include &quot;AutohostInterface.h&quot;
 
+#include &lt;string.h&gt;
 #include &quot;Net/UDPConnectedSocket.h&quot; 
 
 namespace {

Modified: branches/gml/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/BaseNetProtocol.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -2,369 +2,314 @@
 #include &lt;set&gt;
 #include &quot;BaseNetProtocol.h&quot;
 
+#include &quot;Net/RawPacket.h&quot;
 #include &quot;Rendering/InMapDraw.h&quot;
 #include &quot;Net/PackPacket.h&quot;
+#include &quot;Net/ProtocolDef.h&quot;
+
 using netcode::PackPacket;
+typedef boost::shared_ptr&lt;const netcode::RawPacket&gt; PacketType;
 
-CBaseNetProtocol::CBaseNetProtocol()
+CBaseNetProtocol&amp; CBaseNetProtocol::Get()
 {
-  // RegisterMessage() length parameter:
-  //   &gt; 0:  if its fixed length
-  //   &lt; 0:  means the next x bytes represent the length
-
-	RegisterMessage(NETMSG_KEYFRAME, 5);
-	RegisterMessage(NETMSG_NEWFRAME, 1);
-	RegisterMessage(NETMSG_QUIT, 1);
-	RegisterMessage(NETMSG_STARTPLAYING, 5);
-	RegisterMessage(NETMSG_SETPLAYERNUM, 2);
-	RegisterMessage(NETMSG_PLAYERNAME, -1);
-	RegisterMessage(NETMSG_CHAT, -1);
-	RegisterMessage(NETMSG_RANDSEED, 5);
-	RegisterMessage(NETMSG_GAMEID, 17);
-	RegisterMessage(NETMSG_COMMAND, -2);
-	RegisterMessage(NETMSG_SELECT, -2);
-	RegisterMessage(NETMSG_PAUSE, 3);
-
-	RegisterMessage(NETMSG_AICOMMAND, -2);
-	RegisterMessage(NETMSG_AICOMMANDS, -2);
-	RegisterMessage(NETMSG_AISHARE, -2);
-
-	RegisterMessage(NETMSG_USER_SPEED, 6);
-	RegisterMessage(NETMSG_INTERNAL_SPEED, 5);
-	RegisterMessage(NETMSG_CPU_USAGE, 5);
-	RegisterMessage(NETMSG_DIRECT_CONTROL, 2);
-	RegisterMessage(NETMSG_DC_UPDATE, 7);
-	RegisterMessage(NETMSG_ATTEMPTCONNECT, 3);
-	RegisterMessage(NETMSG_SHARE, 12);
-	RegisterMessage(NETMSG_SETSHARE, 11);
-	RegisterMessage(NETMSG_SENDPLAYERSTAT, 1);
-	RegisterMessage(NETMSG_PLAYERSTAT, 2 + sizeof(CPlayer::Statistics));
-	RegisterMessage(NETMSG_GAMEOVER, 1);
-	RegisterMessage(NETMSG_MAPDRAW, -1);
-	RegisterMessage(NETMSG_SYNCREQUEST, 5);
-	RegisterMessage(NETMSG_SYNCRESPONSE, 10);
-	RegisterMessage(NETMSG_SYSTEMMSG, -1);
-	RegisterMessage(NETMSG_STARTPOS, 16);
-	RegisterMessage(NETMSG_PLAYERINFO, 10);
-	RegisterMessage(NETMSG_PLAYERLEFT, 3);
-	RegisterMessage(NETMSG_LUAMSG, -2);
-	RegisterMessage(NETMSG_TEAM, 4);
-	RegisterMessage(NETMSG_GAMEDATA, -2);
-	RegisterMessage(NETMSG_ALLIANCE, 4);
-	RegisterMessage(NETMSG_CCOMMAND, -2);
+	static CBaseNetProtocol instance;
+	return instance;
 }
 
-CBaseNetProtocol::~CBaseNetProtocol()
+PacketType CBaseNetProtocol::SendKeyFrame(int frameNum)
 {
-	SendQuit();
-}
-
-void CBaseNetProtocol::SendKeyFrame(int frameNum)
-{
 	PackPacket* packet = new PackPacket(5, NETMSG_KEYFRAME);
 	*packet &lt;&lt; frameNum;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendNewFrame()
+PacketType CBaseNetProtocol::SendNewFrame()
 {
-	SendData(new PackPacket(1, NETMSG_NEWFRAME));
+	return PacketType(new PackPacket(1, NETMSG_NEWFRAME));
 }
 
 
-void CBaseNetProtocol::SendQuit()
+PacketType CBaseNetProtocol::SendQuit()
 {
-	SendData(new PackPacket(1, NETMSG_QUIT));
+	return PacketType(new PackPacket(1, NETMSG_QUIT));
 }
 
-void CBaseNetProtocol::SendQuit(unsigned playerNum)
+PacketType CBaseNetProtocol::SendStartPlaying(unsigned countdown)
 {
-	SendData(new PackPacket(5, NETMSG_QUIT), playerNum);
-}
-
-void CBaseNetProtocol::SendStartPlaying(unsigned countdown)
-{
 	PackPacket* packet = new PackPacket(5, NETMSG_STARTPLAYING);
 	*packet &lt;&lt; countdown;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSetPlayerNum(uchar myPlayerNum, uchar connNumber)
+PacketType CBaseNetProtocol::SendSetPlayerNum(uchar myPlayerNum)
 {
 	PackPacket* packet = new PackPacket(2, NETMSG_SETPLAYERNUM);
 	*packet &lt;&lt; myPlayerNum;
-	SendData(packet, connNumber);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendPlayerName(uchar myPlayerNum, const std::string&amp; playerName)
+PacketType CBaseNetProtocol::SendPlayerName(uchar myPlayerNum, const std::string&amp; playerName)
 {
 	unsigned size = 3 + playerName.size() + 1;
 	PackPacket* packet = new PackPacket(size, NETMSG_PLAYERNAME);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; playerName;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendRandSeed(unsigned randSeed)
+PacketType CBaseNetProtocol::SendRandSeed(unsigned randSeed)
 {
 	PackPacket* packet = new PackPacket(5, NETMSG_RANDSEED);
 	*packet &lt;&lt; randSeed;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendRandSeed(unsigned randSeed, int toPlayer)
-{
-	PackPacket* packet = new PackPacket(5, NETMSG_RANDSEED);
-	*packet &lt;&lt; randSeed;
-	SendData(packet, toPlayer);
-}
-
 // NETMSG_GAMEID = 9, char gameID[16];
-void CBaseNetProtocol::SendGameID(const uchar* buf)
+PacketType CBaseNetProtocol::SendGameID(const uchar* buf)
 {
 	PackPacket* packet = new PackPacket(17, NETMSG_GAMEID);
 	memcpy(packet-&gt;GetWritingPos(), buf, 16);
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
-void CBaseNetProtocol::SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
+PacketType CBaseNetProtocol::SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
 {
 	unsigned size = 9 + params.size() * sizeof(float);
 	PackPacket* packet = new PackPacket(size, NETMSG_COMMAND);
 	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; id &lt;&lt; options &lt;&lt; params;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs)
+PacketType CBaseNetProtocol::SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs)
 {
 	unsigned size = 4 + selectedUnitIDs.size() * sizeof(short);
 	PackPacket* packet = new PackPacket(size, NETMSG_SELECT);
 	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; selectedUnitIDs;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
-void CBaseNetProtocol::SendPause(uchar myPlayerNum, uchar bPaused)
+PacketType CBaseNetProtocol::SendPause(uchar myPlayerNum, uchar bPaused)
 {
 	PackPacket* packet = new PackPacket(3, NETMSG_PAUSE);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; bPaused;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
 
-void CBaseNetProtocol::SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
+PacketType CBaseNetProtocol::SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params)
 {
 	unsigned size = 11 + params.size() * sizeof(float);
 	PackPacket* packet = new PackPacket(size, NETMSG_AICOMMAND);
 	*packet &lt;&lt; static_cast&lt;unsigned short&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; unitID &lt;&lt; id &lt;&lt; options &lt;&lt; params;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs)
+PacketType CBaseNetProtocol::SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs)
 {
 	short totalNumBytes = (1 + sizeof(short)) + (3 + (2 * sizeof(float)) + (unitIDs.size() * sizeof(short)));
 
 	PackPacket* packet = new PackPacket(totalNumBytes, NETMSG_AISHARE);
 	*packet &lt;&lt; totalNumBytes &lt;&lt; myPlayerNum &lt;&lt; sourceTeam &lt;&lt; destTeam &lt;&lt; metal &lt;&lt; energy &lt;&lt; unitIDs;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendUserSpeed(uchar myPlayerNum, float userSpeed)
+PacketType CBaseNetProtocol::SendUserSpeed(uchar myPlayerNum, float userSpeed)
 {
 	PackPacket* packet = new PackPacket(6, NETMSG_USER_SPEED);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; userSpeed;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendInternalSpeed(float internalSpeed)
+PacketType CBaseNetProtocol::SendInternalSpeed(float internalSpeed)
 {
 	PackPacket* packet = new PackPacket(5, NETMSG_INTERNAL_SPEED);
 	*packet &lt;&lt; internalSpeed;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendCPUUsage(float cpuUsage)
+PacketType CBaseNetProtocol::SendCPUUsage(float cpuUsage)
 {
 	PackPacket* packet = new PackPacket(5, NETMSG_CPU_USAGE);
 	*packet &lt;&lt; cpuUsage;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
-void CBaseNetProtocol::SendDirectControl(uchar myPlayerNum)
+PacketType CBaseNetProtocol::SendDirectControl(uchar myPlayerNum)
 {
 	PackPacket* packet = new PackPacket(2, NETMSG_DIRECT_CONTROL);
 	*packet &lt;&lt; myPlayerNum;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch)
+PacketType CBaseNetProtocol::SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch)
 {
 	PackPacket* packet = new PackPacket(7, NETMSG_DC_UPDATE);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; status &lt;&lt; heading &lt;&lt; pitch;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
-void CBaseNetProtocol::SendAttemptConnect(uchar myPlayerNum, uchar networkVersion)
+PacketType CBaseNetProtocol::SendAttemptConnect(uchar myPlayerNum, uchar networkVersion)
 {
 	PackPacket* packet = new PackPacket(3, NETMSG_ATTEMPTCONNECT);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; networkVersion;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
-void CBaseNetProtocol::SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy)
+PacketType CBaseNetProtocol::SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy)
 {
 	PackPacket* packet = new PackPacket(12, NETMSG_SHARE);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; shareTeam &lt;&lt; bShareUnits &lt;&lt; shareMetal &lt;&lt; shareEnergy;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction)
+PacketType CBaseNetProtocol::SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction)
 {
 	PackPacket* packet = new PackPacket(11, NETMSG_SETSHARE);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; myTeam &lt;&lt; metalShareFraction &lt;&lt; energyShareFraction;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 
-void CBaseNetProtocol::SendSendPlayerStat()
+PacketType CBaseNetProtocol::SendSendPlayerStat()
 {
-	SendData(new PackPacket(1, NETMSG_SENDPLAYERSTAT));
+	return PacketType(new PackPacket(1, NETMSG_SENDPLAYERSTAT));
 }
 
-void CBaseNetProtocol::SendPlayerStat(uchar myPlayerNum, const CPlayer::Statistics&amp; currentStats)
+PacketType CBaseNetProtocol::SendPlayerStat(uchar myPlayerNum, const CPlayer::Statistics&amp; currentStats)
 {
 	PackPacket* packet = new PackPacket(2 + sizeof(CPlayer::Statistics), NETMSG_PLAYERSTAT);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; currentStats;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendGameOver()
+PacketType CBaseNetProtocol::SendGameOver()
 {
-	SendData(new PackPacket(1, NETMSG_GAMEOVER));
+	return PacketType(new PackPacket(1, NETMSG_GAMEOVER));
 }
 
 // NETMSG_MAPDRAW = 31, uchar messageSize =  8, myPlayerNum, command = CInMapDraw::NET_ERASE; short x, z;
-void CBaseNetProtocol::SendMapErase(uchar myPlayerNum, short x, short z)
+PacketType CBaseNetProtocol::SendMapErase(uchar myPlayerNum, short x, short z)
 {
 	PackPacket* packet = new PackPacket(8, NETMSG_MAPDRAW);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(8) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_ERASE) &lt;&lt; x &lt;&lt; z;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 // NETMSG_MAPDRAW = 31, uchar messageSize = 12, myPlayerNum, command = CInMapDraw::NET_LINE; short x1, z1, x2, z2;
-void CBaseNetProtocol::SendMapDrawLine(uchar myPlayerNum, short x1, short z1, short x2, short z2)
+PacketType CBaseNetProtocol::SendMapDrawLine(uchar myPlayerNum, short x1, short z1, short x2, short z2)
 {
 	PackPacket* packet = new PackPacket(12, NETMSG_MAPDRAW);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(12) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_LINE) &lt;&lt; x1 &lt;&lt; z1 &lt;&lt; x2 &lt;&lt; z2;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 // NETMSG_MAPDRAW = 31, uchar messageSize, uchar myPlayerNum, command = CInMapDraw::NET_POINT; short x, z; std::string label;
-void CBaseNetProtocol::SendMapDrawPoint(uchar myPlayerNum, short x, short z, const std::string&amp; label)
+PacketType CBaseNetProtocol::SendMapDrawPoint(uchar myPlayerNum, short x, short z, const std::string&amp; label)
 {
 	unsigned size = 8 + label.size() + 1;
 	PackPacket* packet = new PackPacket(size, NETMSG_MAPDRAW);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(CInMapDraw::NET_POINT) &lt;&lt; x &lt;&lt; z &lt;&lt; label;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSyncRequest(int frameNum)
+PacketType CBaseNetProtocol::SendSyncRequest(int frameNum)
 {
 	PackPacket* packet = new PackPacket(5, NETMSG_SYNCREQUEST);
 	*packet &lt;&lt; frameNum;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSyncResponse(uchar myPlayerNum, int frameNum, uint checksum)
+PacketType CBaseNetProtocol::SendSyncResponse(uchar myPlayerNum, int frameNum, uint checksum)
 {
 	PackPacket* packet = new PackPacket(10, NETMSG_SYNCRESPONSE);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; frameNum &lt;&lt; checksum;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSystemMessage(uchar myPlayerNum, const std::string&amp; message)
+PacketType CBaseNetProtocol::SendSystemMessage(uchar myPlayerNum, const std::string&amp; message)
 {
 	unsigned size = 3 + message.size() + 1;
 	PackPacket* packet = new PackPacket(size, NETMSG_SYSTEMMSG);
 	*packet &lt;&lt; static_cast&lt;uchar&gt;(size) &lt;&lt; myPlayerNum &lt;&lt; message;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z)
+PacketType CBaseNetProtocol::SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z)
 {
 	PackPacket* packet = new PackPacket(16, NETMSG_STARTPOS);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; teamNum &lt;&lt; ready &lt;&lt; x &lt;&lt; y &lt;&lt; z;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping)
+PacketType CBaseNetProtocol::SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping)
 {
 	PackPacket* packet = new PackPacket(10, NETMSG_PLAYERINFO);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; cpuUsage &lt;&lt; ping;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendPlayerLeft(uchar myPlayerNum, uchar bIntended)
+PacketType CBaseNetProtocol::SendPlayerLeft(uchar myPlayerNum, uchar bIntended)
 {
 	PackPacket* packet = new PackPacket(3, NETMSG_PLAYERLEFT);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; bIntended;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 // NETMSG_LUAMSG = 50, uchar myPlayerNum; std::string modName; (e.g. `custom msg')
-void CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode,
+PacketType CBaseNetProtocol::SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode,
                                   const std::string&amp; msg)
 {
 	unsigned short size = 6 + msg.size()+1;
 	PackPacket* packet = new PackPacket(size, NETMSG_LUAMSG);
 	*packet &lt;&lt; size &lt;&lt; myPlayerNum &lt;&lt; script &lt;&lt; mode &lt;&lt; msg;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSelfD(uchar myPlayerNum)
+PacketType CBaseNetProtocol::SendSelfD(uchar myPlayerNum)
 {
 	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_SELFD) &lt;&lt; static_cast&lt;uchar&gt;(0);
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendGiveAwayEverything(uchar myPlayerNum, uchar giveTo)
+PacketType CBaseNetProtocol::SendGiveAwayEverything(uchar myPlayerNum, uchar giveTo)
 {
 	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_GIVEAWAY) &lt;&lt; giveTo;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendResign(uchar myPlayerNum)
+PacketType CBaseNetProtocol::SendResign(uchar myPlayerNum)
 {
 	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_RESIGN) &lt;&lt; static_cast&lt;uchar&gt;(0);
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendJoinTeam(uchar myPlayerNum, uchar wantedTeamNum)
+PacketType CBaseNetProtocol::SendJoinTeam(uchar myPlayerNum, uchar wantedTeamNum)
 {
 	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_JOIN_TEAM) &lt;&lt; wantedTeamNum;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendTeamDied(uchar myPlayerNum, uchar whichTeam)
+PacketType CBaseNetProtocol::SendTeamDied(uchar myPlayerNum, uchar whichTeam)
 {
 	PackPacket* packet = new PackPacket(4, NETMSG_TEAM);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; static_cast&lt;uchar&gt;(TEAMMSG_TEAM_DIED) &lt;&lt; whichTeam;
-	SendData(packet);
+	return PacketType(packet);
 }
 
-void CBaseNetProtocol::SendSetAllied(uchar myPlayerNum, uchar whichAllyTeam, uchar state)
+PacketType CBaseNetProtocol::SendSetAllied(uchar myPlayerNum, uchar whichAllyTeam, uchar state)
 {
 	PackPacket* packet = new PackPacket(4, NETMSG_ALLIANCE);
 	*packet &lt;&lt; myPlayerNum &lt;&lt; whichAllyTeam &lt;&lt; state;
-	SendData(packet);
+	return PacketType(packet);
 }
 
 /* FIXME: add these:
@@ -378,3 +323,57 @@
 #endif // SYNCDEBUG
 
 */
+
+CBaseNetProtocol::CBaseNetProtocol()
+{
+	netcode::ProtocolDef* proto = netcode::ProtocolDef::instance();
+  // proto-&gt;AddType() length parameter:
+  //   &gt; 0:  if its fixed length
+  //   &lt; 0:  means the next x bytes represent the length
+
+	proto-&gt;AddType(NETMSG_KEYFRAME, 5);
+	proto-&gt;AddType(NETMSG_NEWFRAME, 1);
+	proto-&gt;AddType(NETMSG_QUIT, 1);
+	proto-&gt;AddType(NETMSG_STARTPLAYING, 5);
+	proto-&gt;AddType(NETMSG_SETPLAYERNUM, 2);
+	proto-&gt;AddType(NETMSG_PLAYERNAME, -1);
+	proto-&gt;AddType(NETMSG_CHAT, -1);
+	proto-&gt;AddType(NETMSG_RANDSEED, 5);
+	proto-&gt;AddType(NETMSG_GAMEID, 17);
+	proto-&gt;AddType(NETMSG_COMMAND, -2);
+	proto-&gt;AddType(NETMSG_SELECT, -2);
+	proto-&gt;AddType(NETMSG_PAUSE, 3);
+
+	proto-&gt;AddType(NETMSG_AICOMMAND, -2);
+	proto-&gt;AddType(NETMSG_AICOMMANDS, -2);
+	proto-&gt;AddType(NETMSG_AISHARE, -2);
+
+	proto-&gt;AddType(NETMSG_USER_SPEED, 6);
+	proto-&gt;AddType(NETMSG_INTERNAL_SPEED, 5);
+	proto-&gt;AddType(NETMSG_CPU_USAGE, 5);
+	proto-&gt;AddType(NETMSG_DIRECT_CONTROL, 2);
+	proto-&gt;AddType(NETMSG_DC_UPDATE, 7);
+	proto-&gt;AddType(NETMSG_ATTEMPTCONNECT, 3);
+	proto-&gt;AddType(NETMSG_SHARE, 12);
+	proto-&gt;AddType(NETMSG_SETSHARE, 11);
+	proto-&gt;AddType(NETMSG_SENDPLAYERSTAT, 1);
+	proto-&gt;AddType(NETMSG_PLAYERSTAT, 2 + sizeof(CPlayer::Statistics));
+	proto-&gt;AddType(NETMSG_GAMEOVER, 1);
+	proto-&gt;AddType(NETMSG_MAPDRAW, -1);
+	proto-&gt;AddType(NETMSG_SYNCREQUEST, 5);
+	proto-&gt;AddType(NETMSG_SYNCRESPONSE, 10);
+	proto-&gt;AddType(NETMSG_SYSTEMMSG, -1);
+	proto-&gt;AddType(NETMSG_STARTPOS, 16);
+	proto-&gt;AddType(NETMSG_PLAYERINFO, 10);
+	proto-&gt;AddType(NETMSG_PLAYERLEFT, 3);
+	proto-&gt;AddType(NETMSG_LUAMSG, -2);
+	proto-&gt;AddType(NETMSG_TEAM, 4);
+	proto-&gt;AddType(NETMSG_GAMEDATA, -2);
+	proto-&gt;AddType(NETMSG_ALLIANCE, 4);
+	proto-&gt;AddType(NETMSG_CCOMMAND, -2);
+}
+
+CBaseNetProtocol::~CBaseNetProtocol()
+{
+	//SendQuit();
+}

Modified: branches/gml/rts/System/BaseNetProtocol.h
===================================================================
--- branches/gml/rts/System/BaseNetProtocol.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/BaseNetProtocol.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,9 +1,14 @@
 #ifndef BASENETPROTOCOL_H
 #define BASENETPROTOCOL_H
 
-#include &quot;Net/Net.h&quot;
+#include &lt;boost/shared_ptr.hpp&gt;
+
 #include &quot;Game/Player.h&quot;
 
+namespace netcode
+{
+	class RawPacket;
+}
 
 const unsigned char NETWORK_VERSION = 1;
 
@@ -94,62 +99,65 @@
 @brief High level network code layer
 Provides protocoldependent functions over our CNet-Class. It includes all functions needed to send stuff without handling with the internals.
  */
-class CBaseNetProtocol : public netcode::CNet {
+class CBaseNetProtocol
+{
 public:
 	typedef unsigned char uchar;
 	typedef unsigned int uint;
+	typedef boost::shared_ptr&lt;const netcode::RawPacket&gt; PacketType;
+	
+	static CBaseNetProtocol&amp; Get();
 
-	CBaseNetProtocol();
-	~CBaseNetProtocol();
+	PacketType SendKeyFrame(int frameNum);
+	PacketType SendNewFrame();
+	PacketType SendQuit();
+	PacketType SendStartPlaying(unsigned countdown); /// client can send these to force-start the game
+	PacketType SendSetPlayerNum(uchar myPlayerNum);
+	PacketType SendPlayerName(uchar myPlayerNum, const std::string&amp; playerName);
+	PacketType SendRandSeed(uint randSeed);
+	PacketType SendGameID(const uchar* buf);
+	PacketType SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
+	PacketType SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs);
+	PacketType SendPause(uchar myPlayerNum, uchar bPaused);
 
-	void SendKeyFrame(int frameNum);
-	void SendNewFrame();
-	void SendQuit();
-	void SendQuit(unsigned playerNum);
-	void SendStartPlaying(unsigned countdown); /// client can send these to force-start the game
-	void SendSetPlayerNum(uchar myPlayerNum, uchar connNumber);
-	void SendPlayerName(uchar myPlayerNum, const std::string&amp; playerName);
-	void SendRandSeed(uint randSeed);
-	void SendRandSeed(uint randSeed, int toPlayer);
-	void SendGameID(const uchar* buf);
-	void SendCommand(uchar myPlayerNum, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
-	void SendSelect(uchar myPlayerNum, const std::vector&lt;short&gt;&amp; selectedUnitIDs);
-	void SendPause(uchar myPlayerNum, uchar bPaused);
+	PacketType SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
+	PacketType SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs);
 
-	void SendAICommand(uchar myPlayerNum, short unitID, int id, uchar options, const std::vector&lt;float&gt;&amp; params);
-	void SendAIShare(uchar myPlayerNum, uchar sourceTeam, uchar destTeam, float metal, float energy, const std::vector&lt;short&gt;&amp; unitIDs);
-
-	void SendUserSpeed(uchar myPlayerNum, float userSpeed);
-	void SendInternalSpeed(float internalSpeed);
-	void SendCPUUsage(float cpuUsage);
-	void SendDirectControl(uchar myPlayerNum);
-	void SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch);
-	void SendAttemptConnect(uchar myPlayerNum, uchar networkVersion);
-	void SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy);
-	void SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction);
-	void SendSendPlayerStat();
-	void SendPlayerStat(uchar myPlayerNum, const CPlayer::Statistics&amp; currentStats);
-	void SendGameOver();
-	void SendMapErase(uchar myPlayerNum, short x, short z);
-	void SendMapDrawLine(uchar myPlayerNum, short x1, short z1, short x2, short z2);
-	void SendMapDrawPoint(uchar myPlayerNum, short x, short z, const std::string&amp; label);
-	void SendSyncRequest(int frameNum);
-	void SendSyncResponse(uchar myPlayerNum, int frameNum, uint checksum);
-	void SendSystemMessage(uchar myPlayerNum, const std::string&amp; message);
-	void SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z);
-	void SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping);
-	void SendPlayerLeft(uchar myPlayerNum, uchar bIntended);
-	void SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode, const std::string&amp; msg);
+	PacketType SendUserSpeed(uchar myPlayerNum, float userSpeed);
+	PacketType SendInternalSpeed(float internalSpeed);
+	PacketType SendCPUUsage(float cpuUsage);
+	PacketType SendDirectControl(uchar myPlayerNum);
+	PacketType SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch);
+	PacketType SendAttemptConnect(uchar myPlayerNum, uchar networkVersion);
+	PacketType SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy);
+	PacketType SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction);
+	PacketType SendSendPlayerStat();
+	PacketType SendPlayerStat(uchar myPlayerNum, const CPlayer::Statistics&amp; currentStats);
+	PacketType SendGameOver();
+	PacketType SendMapErase(uchar myPlayerNum, short x, short z);
+	PacketType SendMapDrawLine(uchar myPlayerNum, short x1, short z1, short x2, short z2);
+	PacketType SendMapDrawPoint(uchar myPlayerNum, short x, short z, const std::string&amp; label);
+	PacketType SendSyncRequest(int frameNum);
+	PacketType SendSyncResponse(uchar myPlayerNum, int frameNum, uint checksum);
+	PacketType SendSystemMessage(uchar myPlayerNum, const std::string&amp; message);
+	PacketType SendStartPos(uchar myPlayerNum, uchar teamNum, uchar ready, float x, float y, float z);
+	PacketType SendPlayerInfo(uchar myPlayerNum, float cpuUsage, int ping);
+	PacketType SendPlayerLeft(uchar myPlayerNum, uchar bIntended);
+	PacketType SendLuaMsg(uchar myPlayerNum, uchar script, uchar mode, const std::string&amp; msg);
 	
-	void SendSelfD(uchar myPlayerNum);
-	void SendGiveAwayEverything(uchar myPlayerNum, uchar giveTo);
-	void SendResign(uchar myPlayerNum);
-	void SendJoinTeam(uchar myPlayerNum, uchar wantedTeamNum);
+	PacketType SendSelfD(uchar myPlayerNum);
+	PacketType SendGiveAwayEverything(uchar myPlayerNum, uchar giveTo);
+	PacketType SendResign(uchar myPlayerNum);
+	PacketType SendJoinTeam(uchar myPlayerNum, uchar wantedTeamNum);
 	// currently only used to inform the server about its death
 	// it may have some problems when desync because the team may not die on every client
-	void SendTeamDied(uchar myPlayerNum, uchar whichTeam);
+	PacketType SendTeamDied(uchar myPlayerNum, uchar whichTeam);
 
-	void SendSetAllied(uchar myPlayerNum, uchar whichAllyTeam, uchar state);
+	PacketType SendSetAllied(uchar myPlayerNum, uchar whichAllyTeam, uchar state);
+	
+private:
+	CBaseNetProtocol();
+	~CBaseNetProtocol();
 };
 
 #endif

Modified: branches/gml/rts/System/FileSystem/Archive7Zip.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/Archive7Zip.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/FileSystem/Archive7Zip.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -55,9 +55,7 @@
 	// Get contents of archive and store name-&gt;int mapping
 	for (unsigned i = 0; i &lt; db.Database.NumFiles; ++i) {
 		CFileItem* fi = db.Database.Files + i;
-		// NOTE: fix this on next CArchiveScanner INTERNAL_VER bump.
-		// It should be `if (fi-&gt;Size &gt;= 0) {' because now zero-size files are ignored.
-		if (fi-&gt;Size &gt; 0) {
+		if (fi-&gt;Size &gt;= 0) { 		//  zero-size files are ignored.
 			std::string name = fi-&gt;Name;
 			//SetSlashesForwardToBack(name);
 

Modified: branches/gml/rts/System/FileSystem/ArchiveDir.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveDir.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/FileSystem/ArchiveDir.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -4,6 +4,7 @@
 #include &quot;ArchiveDir.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 
+
 inline CFileHandler* CArchiveDir::GetFileHandler(int handle)
 {
 	std::map&lt;int, CFileHandler*&gt;::iterator it = fileHandles.find(handle);
@@ -11,6 +12,7 @@
 	return it-&gt;second;
 }
 
+
 inline std::vector&lt;std::string&gt;::iterator&amp; CArchiveDir::GetSearchHandle(int handle)
 {
 	std::map&lt;int, std::vector&lt;std::string&gt;::iterator&gt;::iterator it = searchHandles.find(handle);
@@ -18,6 +20,7 @@
 	return it-&gt;second;
 }
 
+
 CArchiveDir::CArchiveDir(const std::string&amp; archivename) :
 		CArchiveBase(archivename),
 		archiveName(archivename + '/'),
@@ -39,15 +42,18 @@
 	}
 }
 
+
 CArchiveDir::~CArchiveDir(void)
 {
 }
 
+
 bool CArchiveDir::IsOpen()
 {
 	return true;
 }
 
+
 int CArchiveDir::OpenFile(const std::string&amp; fileName)
 {
 	CFileHandler* f = SAFE_NEW CFileHandler(archiveName + lcNameToOrigName[StringToLower(fileName)]);
@@ -60,38 +66,45 @@
 	return curFileHandle;
 }
 
+
 int CArchiveDir::ReadFile(int handle, void* buffer, int numBytes)
 {
 	CFileHandler* f = GetFileHandler(handle);
 	return f-&gt;Read(buffer, numBytes);
 }
 
+
 void CArchiveDir::CloseFile(int handle)
 {
 	delete GetFileHandler(handle);
 	fileHandles.erase(handle);
 }
 
+
 void CArchiveDir::Seek(int handle, int pos)
 {
 	GetFileHandler(handle)-&gt;Seek(pos);
 }
 
+
 int CArchiveDir::Peek(int handle)
 {
 	return GetFileHandler(handle)-&gt;Peek();
 }
 
+
 bool CArchiveDir::Eof(int handle)
 {
 	return GetFileHandler(handle)-&gt;Eof();
 }
 
+
 int CArchiveDir::FileSize(int handle)
 {
 	return GetFileHandler(handle)-&gt;FileSize();
 }
 
+
 int CArchiveDir::FindFiles(int cur, std::string* name, int* size)
 {
 	if (cur == 0) {

Modified: branches/gml/rts/System/FileSystem/ArchiveScanner.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveScanner.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/FileSystem/ArchiveScanner.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -6,16 +6,21 @@
 #include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 
-#include &quot;ArchiveFactory.h&quot;
-#include &quot;ArchiveBuffered.h&quot;
-#include &quot;CRC.h&quot;
-#include &quot;FileFilter.h&quot;
-#include &quot;FileHandler.h&quot;
-#include &quot;Platform/FileSystem.h&quot;
-#include &quot;TdfParser.h&quot;
-#include &quot;LogOutput.h&quot;
+#include &quot;StdAfx.h&quot;
+#include &quot;Lua/LuaParser.h&quot;
+#include &quot;System/LogOutput.h&quot;
+#include &quot;System/FileSystem/ArchiveFactory.h&quot;
+#include &quot;System/FileSystem/ArchiveBuffered.h&quot;
+#include &quot;System/FileSystem/CRC.h&quot;
+#include &quot;System/FileSystem/FileFilter.h&quot;
+#include &quot;System/FileSystem/FileHandler.h&quot;
+#include &quot;System/Platform/FileSystem.h&quot;
 #include &quot;mmgr.h&quot;
 
+using std::string;
+using std::vector;
+
+
 // fix for windows
 #ifndef S_ISDIR
 #define S_ISDIR(x) (((x) &amp; 0170000) == 0040000) /* directory */
@@ -30,61 +35,60 @@
  * is not slow, but mapping them all every time to make the list is)
  */
 
-// NOTE: on the next version bump, be sure to fix the zero-file-size bug in
-// Archive7zip.cpp and ArchiveZip.cpp  (search for NOTE)
-#define INTERNAL_VER	6
+#define INTERNAL_VER	7
 
+
 CArchiveScanner* archiveScanner = NULL;
 
-CArchiveScanner::CArchiveScanner(void) :
-	isDirty(false)
+
+CArchiveScanner::CArchiveScanner(void)
+: isDirty(false)
 {
 }
 
+
 CArchiveScanner::~CArchiveScanner(void)
 {
-	if (isDirty)
+	if (isDirty) {
 		WriteCacheData(filesystem.LocateFile(GetFilename(), FileSystem::WRITE));
+	}
 }
 
-std::string CArchiveScanner::GetFilename()
+
+string CArchiveScanner::GetFilename()
 {
 	char buf[32];
-	sprintf(buf, &quot;ArchiveCacheV%i.txt&quot;, INTERNAL_VER);
-	return std::string(buf);
+	sprintf(buf, &quot;ArchiveCacheV%i.lua&quot;, INTERNAL_VER);
+	return string(buf);
 }
 
-CArchiveScanner::ModData CArchiveScanner::GetModData(TdfParser* p, const std::string&amp; section)
+
+CArchiveScanner::ModData CArchiveScanner::GetModData(const LuaTable&amp; modTable)
 {
 	ModData md;
 	md.name = &quot;&quot;;
 
-	if (!p-&gt;SectionExist(section)) {
+	if (!modTable.IsValid()) {
 		return md;
 	}
 
-	md.name        = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\Name&quot;);
-	md.shortName   = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\ShortName&quot;);
-	md.version     = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\Version&quot;);
-	md.mutator     = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\Mutator&quot;);
-	md.game        = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\Game&quot;);
-	md.shortGame   = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\ShortGame&quot;);
-	md.description = p-&gt;SGetValueDef(&quot;&quot;, section + &quot;\\Description&quot;);
+	md.name        = modTable.GetString(&quot;name&quot;,        &quot;&quot;);
+	md.shortName   = modTable.GetString(&quot;shortName&quot;,   &quot;&quot;);
+	md.version     = modTable.GetString(&quot;version&quot;,     &quot;&quot;);
+	md.mutator     = modTable.GetString(&quot;mutator&quot;,     &quot;&quot;);
+	md.game        = modTable.GetString(&quot;game&quot;,        &quot;&quot;);
+	md.shortGame   = modTable.GetString(&quot;shortGame&quot;,   &quot;&quot;);
+	md.description = modTable.GetString(&quot;description&quot;, &quot;&quot;);
+	md.modType     = modTable.GetInt(&quot;modType&quot;, 0);
 
-	md.modType = atoi(p-&gt;SGetValueDef(&quot;0&quot;, section + &quot;\\ModType&quot;).c_str());
-
-	int numDep = atoi(p-&gt;SGetValueDef(&quot;0&quot;, section + &quot;\\NumDependencies&quot;).c_str());
-	for (int dep = 0; dep &lt; numDep; ++dep) {
-		char key[100];
-		sprintf(key, &quot;%s\\Depend%d&quot;, section.c_str(), dep);
-		md.dependencies.push_back(p-&gt;SGetValueDef(&quot;&quot;, key));
+	const LuaTable dependencies = modTable.SubTable(&quot;depend&quot;);
+	for (int dep = 1; dependencies.KeyExists(dep); ++dep) {
+		md.dependencies.push_back(dependencies.GetString(dep, &quot;&quot;));
 	}
 
-	int numReplace = atoi(p-&gt;SGetValueDef(&quot;0&quot;, (section + &quot;\\NumReplaces&quot;).c_str()).c_str());
-	for (int rep = 0; rep &lt; numReplace; ++rep) {
-		char key[100];
-		sprintf(key, &quot;%s\\Replace%d&quot;, section.c_str(), rep);
-		md.replaces.push_back(p-&gt;SGetValueDef(&quot;&quot;, key));
+	const LuaTable replaces = modTable.SubTable(&quot;replace&quot;);
+	for (int rep = 1; replaces.KeyExists(rep); ++rep) {
+		md.replaces.push_back(replaces.GetString(rep, &quot;&quot;));
 	}
 
 	// HACK needed until lobbies, lobbyserver and unitsync are sorted out
@@ -92,26 +96,116 @@
 	// (at time of this writing they use name only)
 
 	// NOTE when changing this, this function is used both by the code that
-	// reads ArchiveCache.txt and the code that reads modinfo.tdf from the mod.
+	// reads ArchiveCacheV#.lua and the code that reads modinfo.lua from the mod.
 	// so make sure it doesn't keep adding stuff to the name everytime
 	// Spring/unitsync is loaded.
 
-	if (md.name.find(md.version) == std::string::npos) {
+	if (md.name.find(md.version) == string::npos) {
 		md.name += &quot; &quot; + md.version;
 	}
 
 	return md;
 }
 
-void CArchiveScanner::Scan(const std::string&amp; curPath, bool checksum)
+
+void CArchiveScanner::PreScan(const string&amp; curPath)
 {
+	const int flags = (FileSystem::INCLUDE_DIRS | FileSystem::RECURSE);
+	vector&lt;string&gt; found = filesystem.FindFiles(curPath, &quot;springcontent.sdz&quot;, flags);
+	if (!found.empty()) {
+		CArchiveBase* ar = CArchiveFactory::OpenArchive(found[0]);
+		if (ar) {
+			string name;
+			int size;
+			for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+				if (name == &quot;gamedata/parse_tdf.lua&quot;) {
+					const int fh = ar-&gt;OpenFile(name);
+					if (fh != 0) {
+						parse_tdf_path = found[0];
+						ar-&gt;CloseFile(fh);
+					}
+				}
+				else if (name == &quot;gamedata/scanutils.lua&quot;) {
+					const int fh = ar-&gt;OpenFile(name);
+					if (fh != 0) {
+						scanutils_path = found[0];
+						ar-&gt;CloseFile(fh);
+					}
+				}
+			}
+			delete ar;
+		}
+	}
+}
+
+
+static bool LoadSourceFile(const string&amp; archive,
+                           const string&amp; fileName, string&amp; source)
+{
+	CArchiveBase* ar = CArchiveFactory::OpenArchive(archive);
+	if (ar == NULL) {
+		return false;
+	}
+
+	const int fh = ar-&gt;OpenFile(fileName);
+	if (!fh) {
+		delete ar;
+		return false;
+	}
+
+	const int fsize = ar-&gt;FileSize(fh);
+	char* buf = SAFE_NEW char[fsize];
+	ar-&gt;ReadFile(fh, buf, fsize);
+	ar-&gt;CloseFile(fh);
+	source.clear();
+	source.append(buf, fsize);
+	delete [] buf;
+
+	delete ar;
+
+	return true;
+}
+
+
+void CArchiveScanner::ScanDirs(const vector&lt;string&gt;&amp; scanDirs, bool checksum)
+{
+	// pre-scan for the modinfo utils
+	for (unsigned int d = 0; d &lt; scanDirs.size(); d++) {
+		PreScan(scanDirs[d]);
+	}
+
+	LoadSourceFile(parse_tdf_path, &quot;gamedata/parse_tdf.lua&quot;, parse_tdf_code);
+	if (parse_tdf_code.empty()) {
+		throw content_error(&quot;could not find 'gamedata/parse_tdf.lua' code&quot;);
+	}
+
+	LoadSourceFile(scanutils_path, &quot;gamedata/scanutils.lua&quot;, scanutils_code);
+	if (scanutils_code.empty()) {
+		throw content_error(&quot;could not find 'gamedata/scanutils.lua' code&quot;);
+	}
+
+	// we don't want to return the parse_tdf table
+	parse_tdf_code.erase(parse_tdf_code.find_last_of(&quot;}&quot;) + 1);
+	// NOTE: this is a dangerous game to play,
+	//       better to use a tag in the source file
+
+	// add the archives
+	for (unsigned int d = 0; d &lt; scanDirs.size(); d++) {
+		logOutput.Print(&quot;Scanning: %s\n&quot;, scanDirs[d].c_str());
+		Scan(scanDirs[d], checksum);
+	}
+}
+
+
+void CArchiveScanner::Scan(const string&amp; curPath, bool checksum)
+{
 	isDirty = true;
 
 	const int flags = (FileSystem::INCLUDE_DIRS | FileSystem::RECURSE);
-	std::vector&lt;std::string&gt; found = filesystem.FindFiles(curPath, &quot;*&quot;, flags);
+	vector&lt;string&gt; found = filesystem.FindFiles(curPath, &quot;*&quot;, flags);
 
-	for (std::vector&lt;std::string&gt;::iterator it = found.begin(); it != found.end(); ++it) {
-		std::string fullName = *it;
+	for (vector&lt;string&gt;::iterator it = found.begin(); it != found.end(); ++it) {
+		string fullName = *it;
 
 		// Strip
 		const char lastFullChar = fullName[fullName.size() - 1];
@@ -119,185 +213,244 @@
 			fullName = fullName.substr(0, fullName.size() - 1);
 		}
 
-		const std::string fn    = filesystem.GetFilename(fullName);
-		const std::string fpath = filesystem.GetDirectory(fullName);
-		const std::string lcfn    = StringToLower(fn);
-		const std::string lcfpath = StringToLower(fpath);
+		const string fn    = filesystem.GetFilename(fullName);
+		const string fpath = filesystem.GetDirectory(fullName);
+		const string lcfn    = StringToLower(fn);
+		const string lcfpath = StringToLower(fpath);
 
 		// Exclude archivefiles found inside directory archives (.sdd)
-		if (lcfpath.find(&quot;.sdd&quot;) != std::string::npos) {
+		if (lcfpath.find(&quot;.sdd&quot;) != string::npos) {
 			continue;
 		}
 
 		// Exclude archivefiles found inside hidden directories
-		if ((lcfpath.find(&quot;/hidden/&quot;)   != std::string::npos) ||
-		    (lcfpath.find(&quot;\\hidden\\&quot;) != std::string::npos)) {
+		if ((lcfpath.find(&quot;/hidden/&quot;)   != string::npos) ||
+		    (lcfpath.find(&quot;\\hidden\\&quot;) != string::npos)) {
 			continue;
 		}
 
 		// Is this an archive we should look into?
 		if (CArchiveFactory::IsArchive(fullName)) {
-			struct stat info;
+			ScanArchive(fullName, checksum);
+		}
+	}
 
-			stat(fullName.c_str(), &amp;info);
+	// Now we'll have to parse the replaces-stuff found in the mods
+	for (std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.replaces.begin(); i != aii-&gt;second.modData.replaces.end(); ++i) {
 
-			// Determine whether to rely on the cached info or not
-			bool cached = false;
+			const string lcname = StringToLower(*i);
+			std::map&lt;string, ArchiveInfo&gt;::iterator ar = archiveInfo.find(lcname);
 
-			std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcfn);
-			if (aii != archiveInfo.end()) {
+			// If it's not there, we will create a new entry
+			if (ar == archiveInfo.end()) {
+				ArchiveInfo tmp;
+				archiveInfo[lcname] = tmp;
+				ar = archiveInfo.find(lcname);
+			}
 
-				// This archive may have been obsoleted, do not process it if so
-				if (aii-&gt;second.replaced.length() &gt; 0)
-					continue;
+			// Overwrite the info for this archive with a replaced pointer
+			ar-&gt;second.path = &quot;&quot;;
+			ar-&gt;second.origName = lcname;
+			ar-&gt;second.modified = 1;
+			ar-&gt;second.mapData.clear();
+			ar-&gt;second.modData.name = &quot;&quot;;
+			ar-&gt;second.modData.replaces.clear();
+			ar-&gt;second.updated = true;
+			ar-&gt;second.replaced = aii-&gt;first;
+		}
+	}
+}
 
-				/*
-					For truely correct updating of .sdd archives, this code should
-					be enabled. Unfortunately it has as side effect that all files
-					in all .sdd's always need to be stat()'ed, which really slows
-					down program startup.
 
-					An update can be forced anyway by removing ArchiveCacheV*.txt
-					or renaming the archive.
-				*/
+void CArchiveScanner::ScanArchive(const string&amp; fullName, bool checksum)
+{
+	struct stat info;
 
-				/*if (S_ISDIR(info.st_mode)) {
-					struct stat info2;
-					std::vector&lt;std::string&gt; sddfiles = filesystem.FindFiles(fpath, &quot;*&quot;, FileSystem::RECURSE | FileSystem::INCLUDE_DIRS);
-					for (std::vector&lt;std::string&gt;::iterator sddit = found.begin(); sddit != found.end(); ++sddit) {
-						stat(sddit-&gt;c_str(), &amp;info2);
-						if (info.st_mtime &lt; info2.st_mtime) {
-							info.st_mtime = info2.st_mtime;
-						}
-					}
-				}*/
+	stat(fullName.c_str(), &amp;info);
 
-				if ((unsigned)info.st_mtime == aii-&gt;second.modified &amp;&amp; fpath == aii-&gt;second.path) {
-					cached = true;
-					aii-&gt;second.updated = true;
-				}
+	const string fn    = filesystem.GetFilename(fullName);
+	const string fpath = filesystem.GetDirectory(fullName);
+	const string lcfn    = StringToLower(fn);
+	const string lcfpath = StringToLower(fpath);
 
-				// If we are here, we could have invalid info in the cache
-				// Force a reread if it's a directory archive, as st_mtime only
-				// reflects changes to the directory itself, not the contents.
-				if (!cached) {
-					archiveInfo.erase(aii);
+	// Determine whether to rely on the cached info or not
+	bool cached = false;
+
+	std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcfn);
+	if (aii != archiveInfo.end()) {
+
+		// This archive may have been obsoleted, do not process it if so
+		if (aii-&gt;second.replaced.length() &gt; 0) {
+			return;
+		}
+
+		/*
+			For truely correct updating of .sdd archives, this code should
+			be enabled. Unfortunately it has as side effect that all files
+			in all .sdd's always need to be stat()'ed, which really slows
+			down program startup.
+
+			An update can be forced anyway by removing ArchiveCacheV*.lua
+			or renaming the archive.
+		*/
+
+		/*if (S_ISDIR(info.st_mode)) {
+			struct stat info2;
+			vector&lt;string&gt; sddfiles = filesystem.FindFiles(fpath, &quot;*&quot;, FileSystem::RECURSE | FileSystem::INCLUDE_DIRS);
+			for (vector&lt;string&gt;::iterator sddit = found.begin(); sddit != found.end(); ++sddit) {
+				stat(sddit-&gt;c_str(), &amp;info2);
+				if (info.st_mtime &lt; info2.st_mtime) {
+					info.st_mtime = info2.st_mtime;
 				}
 			}
+		}*/
 
-			// Time to parse the info we are interested in
-			if (!cached) {
+		if ((unsigned)info.st_mtime == aii-&gt;second.modified &amp;&amp; fpath == aii-&gt;second.path) {
+			cached = true;
+			aii-&gt;second.updated = true;
+		}
 
-				//printf(&quot;scanning archive: %s\n&quot;, fullName.c_str());
+		// If we are here, we could have invalid info in the cache
+		// Force a reread if it's a directory archive, as st_mtime only
+		// reflects changes to the directory itself, not the contents.
+		if (!cached) {
+			archiveInfo.erase(aii);
+		}
+	}
 
-				CArchiveBase* ar = CArchiveFactory::OpenArchive(fullName);
-				if (ar) {
-					int cur;
-					std::string name;
-					int size;
-					ArchiveInfo ai;
+	// Time to parse the info we are interested in
+	if (cached) {
+		// If cached is true, aii will point to the archive
+		if ((checksum) &amp;&amp; (aii-&gt;second.checksum == 0)) {
+			aii-&gt;second.checksum = GetCRC(fullName);
+		}
+	}
+	else {
+		CArchiveBase* ar = CArchiveFactory::OpenArchive(fullName);
+		if (ar) {
+			ArchiveInfo ai;
 
-					cur = ar-&gt;FindFiles(0, &amp;name, &amp;size);
-					while (cur != 0) {
-						//printf(&quot;found %s %d\n&quot;, name.c_str(), size);
+			string name;
+			int size;
+			for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+				//printf(&quot;found %s %d\n&quot;, name.c_str(), size);
+				string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
 
-						std::string ext = StringToLower(name.substr(name.find_last_of('.') + 1));
+				// only accept new format maps
+				if ((ext == &quot;smf&quot;) || (ext == &quot;sm3&quot;)) {
+					ScanMap(ar, name, ai);
+				}
+				else if (name == &quot;modinfo.lua&quot;) {
+					ScanModLua(ar, name, ai);
+				}
+				else if (name == &quot;modinfo.tdf&quot;) {
+					ScanModTdf(ar, name, ai);
+				}
+			}
 
-						// only accept new format maps
-						if (ext == &quot;smf&quot; || ext == &quot;sm3&quot;) {
-							MapData md;
-							if (name.find_last_of('\\') == std::string::npos &amp;&amp; name.find_last_of('/') == std::string::npos) {
-								md.name = name;
-								md.virtualPath = &quot;/&quot;;
-							}
-							else {
-								if (name.find_last_of('\\') == std::string::npos) {
-									md.name = name.substr(name.find_last_of('/') + 1);
-									md.virtualPath = name.substr(0, name.find_last_of('/') + 1);	// include the backslash
-								} else {
-									md.name = name.substr(name.find_last_of('\\') + 1);
-									md.virtualPath = name.substr(0, name.find_last_of('\\') + 1);	// include the backslash
-								}
-								//md.name = md.name.substr(0, md.name.find_last_of('.'));
-							}
-							ai.mapData.push_back(md);
-						}
+			ai.path = fpath;
+			ai.modified = info.st_mtime;
+			ai.origName = fn;
+			ai.updated = true;
 
-						if (name == &quot;modinfo.tdf&quot;) {
-							int fh = ar-&gt;OpenFile(name);
-							if (fh) {
-								int fsize = ar-&gt;FileSize(fh);
+			delete ar;
 
-								char* buf = SAFE_NEW char[fsize];
-								ar-&gt;ReadFile(fh, buf, fsize);
-								ar-&gt;CloseFile(fh);
-								try {
-									TdfParser p( buf, fsize );
-									ai.modData = GetModData(&amp;p, &quot;mod&quot;);
-								} catch (const TdfParser::parse_error&amp;) {
-									// Silently ignore mods with parse errors
-								}
-								delete [] buf;
-							}
+			// Optionally calculate a checksum for the file
+			// To prevent reading all files in all directory (.sdd) archives
+			// every time this function is called, directory archive checksums
+			// are calculated on the fly.
+			if (checksum) {
+				ai.checksum = GetCRC(fullName);
+			} else {
+				ai.checksum = 0;
+			}
 
-						}
+			archiveInfo[lcfn] = ai;
+		}
+	}
+}
 
-						cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size);
-					}
 
-					ai.path = fpath;
-					ai.modified = info.st_mtime;
-					ai.origName = fn;
-					ai.updated = true;
+void CArchiveScanner::ScanMap(CArchiveBase* ar, const string&amp; fileName,
+                              ArchiveInfo&amp; ai)
+{
+	MapData md;
+	if ((fileName.find_last_of('\\') == string::npos) &amp;&amp;
+			(fileName.find_last_of('/') == string::npos)) {
+		md.name = fileName;
+		md.virtualPath = &quot;/&quot;;
+	}
+	else {
+		if (fileName.find_last_of('\\') == string::npos) {
+			md.name = fileName.substr(fileName.find_last_of('/') + 1);
+			// include the backslash
+			md.virtualPath = fileName.substr(0, fileName.find_last_of('/') + 1);
+		}
+		else {
+			md.name = fileName.substr(fileName.find_last_of('\\') + 1);
+			// include the backslash
+			md.virtualPath = fileName.substr(0, fileName.find_last_of('\\') + 1);
+		}
+	}
+	ai.mapData.push_back(md);
+}
 
-					delete ar;
 
-					// Optionally calculate a checksum for the file
-					// To prevent reading all files in all directory (.sdd) archives every time this function
-					// is called, directory archive checksums are calculated on the fly.
-					if (checksum) {
-						ai.checksum = GetCRC(fullName);
-					}
-					else {
-						ai.checksum = 0;
-					}
+void CArchiveScanner::ScanModLua(CArchiveBase* ar, const string&amp; fileName,
+                                 ArchiveInfo&amp; ai)
+{
+	const int fh = ar-&gt;OpenFile(fileName);
+	if (fh) {
+		const int fsize = ar-&gt;FileSize(fh);
 
-					archiveInfo[lcfn] = ai;
-				}
-			}
-			else {
-				// If cached is true, aii will point to the archive
-				if ((checksum) &amp;&amp; (aii-&gt;second.checksum == 0)) {
-					aii-&gt;second.checksum = GetCRC(fullName);
-				}
-			}
+		char* buf = SAFE_NEW char[fsize];
+		ar-&gt;ReadFile(fh, buf, fsize);
+		ar-&gt;CloseFile(fh);
+		
+		string cleanbuf;
+		cleanbuf.append(buf, fsize);
+		delete [] buf;
+		LuaParser p(cleanbuf, SPRING_VFS_MOD);
+		if (!p.Execute()) {
+			logOutput.Print(p.GetErrorLog());
 		}
+		const LuaTable modTable = p.GetRoot();
+		ai.modData = GetModData(modTable);
 	}
+}
 
-	// Now we'll have to parse the replaces-stuff found in the mods
-	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (std::vector&lt;std::string&gt;::iterator i = aii-&gt;second.modData.replaces.begin(); i != aii-&gt;second.modData.replaces.end(); ++i) {
 
-			std::string lcname = StringToLower(*i);
-			std::map&lt;std::string, ArchiveInfo&gt;::iterator ar = archiveInfo.find(lcname);
+void CArchiveScanner::ScanModTdf(CArchiveBase* ar, const string&amp; fileName,
+                                 ArchiveInfo&amp; ai)
+{
+	const int fh = ar-&gt;OpenFile(fileName);
+	if (fh) {
+		const int fsize = ar-&gt;FileSize(fh);
 
-			// If it's not there, we will create a new entry
-			if (ar == archiveInfo.end()) {
-				ArchiveInfo tmp;
-				archiveInfo[lcname] = tmp;
-				ar = archiveInfo.find(lcname);
-			}
-
-			// Overwrite the info for this archive with a replaced pointer
-			ar-&gt;second.path = &quot;&quot;;
-			ar-&gt;second.origName = lcname;
-			ar-&gt;second.modified = 1;
-			ar-&gt;second.mapData.clear();
-			ar-&gt;second.modData.name = &quot;&quot;;
-			ar-&gt;second.modData.replaces.clear();
-			ar-&gt;second.updated = true;
-			ar-&gt;second.replaced = aii-&gt;first;
+		char* buf = SAFE_NEW char[fsize];
+		ar-&gt;ReadFile(fh, buf, fsize);
+		ar-&gt;CloseFile(fh);
+		string cleanbuf;
+		cleanbuf.append(buf, fsize);
+		delete [] buf;
+		const string luaFile =
+				parse_tdf_code + &quot;\n\n&quot;
+			+ scanutils_code + &quot;\n\n&quot;
+			+ &quot;local tdfModinfo, err = TDFparser.ParseText([[\n&quot; 
+			+ cleanbuf + &quot;]])\n\n&quot;
+			+ &quot;if (tdfModinfo == nil) then\n&quot;
+			+ &quot;    error('Error parsing modinfo.tdf: ' .. err)\n&quot;
+			+ &quot;end\n\n&quot;
+			+ &quot;tdfModinfo.mod.depend  = MakeArray(tdfModinfo.mod, 'depend')\n&quot;
+			+ &quot;tdfModinfo.mod.replace = MakeArray(tdfModinfo.mod, 'replace')\n\n&quot;
+			+ &quot;return tdfModinfo.mod\n&quot;;
+		LuaParser p(luaFile, SPRING_VFS_MOD);
+		if (!p.Execute()) {
+			logOutput.Print(p.GetErrorLog());
 		}
+		const LuaTable modTable = p.GetRoot();
+		ai.modData = GetModData(modTable);
 	}
 }
 
@@ -315,7 +468,7 @@
 		ar-&gt;CloseFile(fh);
 
 		// this automatically splits lines
-		ignore-&gt;AddRule(std::string(buf, fsize));
+		ignore-&gt;AddRule(string(buf, fsize));
 
 		delete[] buf;
 	}
@@ -323,43 +476,43 @@
 }
 
 
-/** Get CRC of the data in the specified archive. Returns 0 if file could not be opened. */
-
-unsigned int CArchiveScanner::GetCRC(const std::string&amp; filename)
+/** Get CRC of the data in the specified archive.
+    Returns 0 if file could not be opened. */
+unsigned int CArchiveScanner::GetCRC(const string&amp; arcName)
 {
 	CRC crc;
 	unsigned int digest;
 	CArchiveBase* ar;
-	std::list&lt;std::string&gt; files;
-	std::string innerName;
-	std::string lowerName;
-	int innerSize;
-	int cur = 0;
+	std::list&lt;string&gt; files;
 
 	// Try to open an archive
-	ar = CArchiveFactory::OpenArchive(filename);
-	if (!ar)
+	ar = CArchiveFactory::OpenArchive(arcName);
+	if (!ar) {
 		return 0; // It wasn't an archive
+	}
 
 	// Load ignore list.
 	IFileFilter* ignore = CreateIgnoreFilter(ar);
 
+	string name;
+	int size;
 	// Sort all file paths for deterministic behaviour
-	while (true) {
-		cur = ar-&gt;FindFiles(cur, &amp;innerName, &amp;innerSize);
-		if (cur == 0) break;
-		if (ignore-&gt;Match(innerName)) continue;
-		lowerName = StringToLower(innerName); // case insensitive hash
-		files.push_back(lowerName);
+	for (int cur = 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size); /* no-op */) {
+		if (ignore-&gt;Match(name)) {
+			continue;
+		}
+		const string lower = StringToLower(name); // case insensitive hash
+		files.push_back(lower);
 	}
 	files.sort();
 
 	// Add all files in sorted order
-	for (std::list&lt;std::string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
+	for (std::list&lt;string&gt;::iterator i = files.begin(); i != files.end(); i++ ) {
 		digest = CRC().Update(i-&gt;data(), i-&gt;size()).GetDigest();
 		crc.Update(digest);
 		crc.Update(ar-&gt;GetCrc32(*i));
 	}
+
 	delete ignore;
 	delete ar;
 
@@ -367,59 +520,56 @@
 
 	// A value of 0 is used to indicate no crc.. so never return that
 	// Shouldn't happen all that often
-	if (digest == 0)
+	if (digest == 0) {
 		return 4711;
-	else
+	} else {
 		return digest;
+	}
 }
 
-void CArchiveScanner::ReadCacheData(const std::string&amp; filename)
+
+void CArchiveScanner::ReadCacheData(const string&amp; filename)
 {
-	TdfParser p;
-
-	try {
-		p.LoadFile(filename);
-	} catch (const content_error&amp;) {
-		return;
+  LuaParser p(filename, SPRING_VFS_RAW, SPRING_VFS_ALL);
+	
+	if (!p.Execute()) {
+		logOutput.Print(p.GetErrorLog());
 	}
-
+	const LuaTable archiveCache = p.GetRoot();
+	const LuaTable archives = archiveCache.SubTable(&quot;archives&quot;);
+	
 	// Do not load old version caches
-	int ver = atoi(p.SGetValueDef(&quot;0&quot;, &quot;archivecache\\internalver&quot;).c_str());
-	if (ver != INTERNAL_VER)
+	const int ver = archiveCache.GetInt(&quot;internalVer&quot;, 0);
+	if (ver != INTERNAL_VER) {
 		return;
+	}
 
-	int numArs = atoi(p.SGetValueDef(&quot;0&quot;, &quot;archivecache\\numarchives&quot;).c_str());
-	for (int i = 0; i &lt; numArs; ++i) {
+	for (int i = 1; archives.KeyExists(i); ++i) {
+	  const LuaTable curArchive = archives.SubTable(i);
+		const LuaTable maps = curArchive.SubTable(&quot;maps&quot;);
+		const LuaTable mod = curArchive.SubTable(&quot;modData&quot;);
 		ArchiveInfo ai;
-		char keyb[100];
-		sprintf(keyb, &quot;ArchiveCache\\Archive%d\\&quot;, i);
-		std::string key = keyb;
 
-		ai.origName = p.SGetValueDef(&quot;&quot;, key + &quot;Name&quot;);
-
-		ai.path = p.SGetValueDef(&quot;&quot;, key + &quot;Path&quot;);
-		ai.modified = strtoul(p.SGetValueDef(&quot;0&quot;, key + &quot;Modified&quot;).c_str(), 0, 10);
-		ai.checksum = strtoul(p.SGetValueDef(&quot;0&quot;, key + &quot;Checksum&quot;).c_str(), 0, 10);
+		ai.origName = curArchive.GetString(&quot;name&quot;, &quot;&quot;);
+		ai.path = curArchive.GetString(&quot;path&quot;, &quot;&quot;);
+		// don't use GetInt for modified and checksum as lua uses 32bit ints, no longs
+		ai.modified = strtoul(curArchive.GetString(&quot;modified&quot;, &quot;0&quot;).c_str(), 0, 10);
+		ai.checksum = strtoul(curArchive.GetString(&quot;checksum&quot;, &quot;0&quot;).c_str(), 0, 10);
 		ai.updated = false;
 
-		int numMaps = atoi(p.SGetValueDef(&quot;0&quot;, key + &quot;NumMaps&quot;).c_str());
-		for (int m = 0; m &lt; numMaps; ++m) {
-			char mapb[100];
-			sprintf(mapb, &quot;%sMap%d\\&quot;, key.c_str(), m);
-			std::string map = mapb;
+		for (int m = 1; maps.KeyExists(m); ++m) {
+			const LuaTable curMap = maps.SubTable(m);
 
 			MapData md;
-			md.name = p.SGetValueDef(&quot;&quot;, map + &quot;Name&quot;);
-			md.virtualPath = p.SGetValueDef(&quot;&quot;, map + &quot;VirtualPath&quot;);
+			md.name = curMap.GetString(&quot;name&quot;, &quot;&quot;);
+			md.virtualPath = curMap.GetString(&quot;virtualPath&quot;, &quot;&quot;);
 
 			ai.mapData.push_back(md);
 		}
 
-		if (p.SectionExist(key + &quot;Mod&quot;)) {
-			ai.modData = GetModData(&amp;p, key + &quot;Mod&quot;);
-		}
+		ai.modData = GetModData(mod);
 
-		std::string lcname = StringToLower(ai.origName);
+		string lcname = StringToLower(ai.origName);
 
 		archiveInfo[lcname] = ai;
 	}
@@ -427,18 +577,34 @@
 	isDirty = false;
 }
 
-void CArchiveScanner::WriteCacheData(const std::string&amp; filename)
+
+static inline void SafeStr(FILE* out, const char* prefix, const string&amp; str)
 {
-	if (!isDirty)
+	if (str.empty()) {
 		return;
+	}
+	if (str.find_first_of(&quot;\\\&quot;&quot;) == string::npos) {
+		fprintf(out, &quot;%s\&quot;%s\&quot;,\n&quot;, prefix, str.c_str());
+	} else {
+		fprintf(out, &quot;%s[[%s]],\n&quot;, prefix, str.c_str());
+	}
+}
 
+
+void CArchiveScanner::WriteCacheData(const string&amp; filename)
+{
+	if (!isDirty) {
+		return;
+	}
+
 	FILE* out = fopen(filename.c_str(), &quot;wt&quot;);
-	if (!out)
+	if (!out) {
 		return;
+	}
 
 	// First delete all outdated information
-	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ) {
-		std::map&lt;std::string, ArchiveInfo&gt;::iterator next = i;
+	for (std::map&lt;string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ) {
+		std::map&lt;string, ArchiveInfo&gt;::iterator next = i;
 		next++;
 		if (!i-&gt;second.updated) {
 			archiveInfo.erase(i);
@@ -446,91 +612,90 @@
 		i = next;
 	}
 
-	fprintf(out, &quot;[ARCHIVECACHE]\n{\n&quot;);
-	fprintf(out, &quot;\tNumArchives=%d;\n&quot;, archiveInfo.size());
-	fprintf(out, &quot;\tInternalVer=%d;\n&quot;, INTERNAL_VER);
-	int cur = 0;
-	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
-		fprintf(out, &quot;\t[ARCHIVE%d]\n\t{\n&quot;, cur);
-		fprintf(out, &quot;\t\tName=%s;\n&quot;, i-&gt;second.origName.c_str());
-		fprintf(out, &quot;\t\tPath=%s;\n&quot;, i-&gt;second.path.c_str());
-		fprintf(out, &quot;\t\tModified=%u;\n&quot;, i-&gt;second.modified);
-		fprintf(out, &quot;\t\tChecksum=%u;\n&quot;, i-&gt;second.checksum);
-		fprintf(out, &quot;\t\tReplaced=%s;\n&quot;, i-&gt;second.replaced.c_str());
+	fprintf(out, &quot;local archiveCache = {\n\n&quot;);
+	fprintf(out, &quot;\tinternalver = %d,\n\n&quot;, INTERNAL_VER);
+	fprintf(out, &quot;\tarchives = {\n&quot;);
+	std::map&lt;string, ArchiveInfo&gt;::const_iterator arcIt;
+	for (arcIt = archiveInfo.begin(); arcIt != archiveInfo.end(); ++arcIt) {
+		fprintf(out, &quot;\t\t{\n&quot;);
+		SafeStr(out, &quot;\t\t\tname = &quot;,            arcIt-&gt;second.origName);
+		SafeStr(out, &quot;\t\t\tpath = &quot;,            arcIt-&gt;second.path); 
+		fprintf(out, &quot;\t\t\tmodified = \&quot;%u\&quot;,\n&quot;, arcIt-&gt;second.modified);
+		fprintf(out, &quot;\t\t\tchecksum = \&quot;%u\&quot;,\n&quot;, arcIt-&gt;second.checksum);
+		SafeStr(out, &quot;\t\t\treplaced = &quot;,        arcIt-&gt;second.replaced);
 
-		fprintf(out, &quot;\t\tNumMaps=%d;\n&quot;, i-&gt;second.mapData.size());
-		int curmap = 0;
-		for (std::vector&lt;MapData&gt;::iterator mi = i-&gt;second.mapData.begin(); mi != i-&gt;second.mapData.end(); ++mi) {
-			fprintf(out, &quot;\t\t[MAP%d]\n\t\t{\n&quot;, curmap);
-			//WriteData(out, *mi);
-			fprintf(out, &quot;\t\t\tName=%s;\n&quot;, (*mi).name.c_str());
-			fprintf(out, &quot;\t\t\tVirtualPath=%s;\n&quot;, (*mi).virtualPath.c_str());
-			//fprintf(out, &quot;\t\t\tDescription=%s;\n&quot;, (*mi).description.c_str());
-			fprintf(out, &quot;\t\t}\n&quot;);
-			curmap++;
+		const vector&lt;MapData&gt;&amp; mapData = arcIt-&gt;second.mapData;
+		if (!mapData.empty()) {
+			fprintf(out, &quot;\t\t\tmaps = {\n&quot;);
+			vector&lt;MapData&gt;::const_iterator mapIt;
+			for (mapIt = mapData.begin(); mapIt != mapData.end(); ++mapIt) {
+				fprintf(out, &quot;\t\t\t\t{\n&quot;);
+				SafeStr(out, &quot;\t\t\t\t\tname = &quot;,        mapIt-&gt;name);
+				SafeStr(out, &quot;\t\t\t\t\tvirtualpath = &quot;, mapIt-&gt;virtualPath);
+				fprintf(out, &quot;\t\t\t\t},\n&quot;);
+			}
+			fprintf(out, &quot;\t\t\t},\n&quot;);
 		}
 
 		// Any mod info? or just a map archive?
-		if (i-&gt;second.modData.name != &quot;&quot;) {
-			const ModData&amp; md = i-&gt;second.modData;
-			fprintf(out, &quot;\t\t[MOD]\n\t\t{\n&quot;);
-			fprintf(out, &quot;\t\t\tName=%s;\n&quot;,          md.name.c_str());
+		const ModData&amp; modData = arcIt-&gt;second.modData;
+		if (modData.name != &quot;&quot;) {
+			fprintf(out, &quot;\t\t\tmoddata = {\n&quot;);
+			SafeStr(out, &quot;\t\t\t\tname = &quot;,         modData.name);
+			SafeStr(out, &quot;\t\t\t\tshortname = &quot;,    modData.shortName);
+			SafeStr(out, &quot;\t\t\t\tversion = &quot;,      modData.version);
+			SafeStr(out, &quot;\t\t\t\tmutator = &quot;,      modData.mutator);
+			SafeStr(out, &quot;\t\t\t\tgame = &quot;,         modData.game);
+			SafeStr(out, &quot;\t\t\t\tshortgame = &quot;,    modData.shortGame);
+			SafeStr(out, &quot;\t\t\t\tdescription = &quot;,  modData.description);
+			fprintf(out, &quot;\t\t\t\tmodtype = %d,\n&quot;, modData.modType);
 
-			if (!md.shortName.empty()) {
-				fprintf(out, &quot;\t\t\tShortName=%s;\n&quot;,   md.shortName.c_str());
+			const vector&lt;string&gt;&amp; modDeps = modData.dependencies;
+			if (!modDeps.empty()) {
+				fprintf(out, &quot;\t\t\t\tdepend = {\n&quot;);
+				vector&lt;string&gt;::const_iterator depIt;
+				for (depIt = modDeps.begin(); depIt != modDeps.end(); ++depIt) {
+					SafeStr(out, &quot;\t\t\t\t\t&quot;, *depIt);
+				}
+				fprintf(out, &quot;\t\t\t\t},\n&quot;);
 			}
-			if (!md.version.empty()) {
-				fprintf(out, &quot;\t\t\tVersion=%s;\n&quot;,     md.version.c_str());
+			
+			const vector&lt;string&gt;&amp; modReps = modData.replaces;
+			if (!modReps.empty())  {
+				fprintf(out, &quot;\t\t\t\treplace = {\n&quot;);
+				vector&lt;string&gt;::const_iterator repIt;
+				for (repIt = modReps.begin(); repIt != modReps.end(); ++repIt) {
+					SafeStr(out, &quot;\t\t\t\t\t&quot;, *repIt);
+				}
+				fprintf(out, &quot;\t\t\t\t},\n&quot;);
 			}
-			if (!md.mutator.empty()) {
-				fprintf(out, &quot;\t\t\tMutator=%s;\n&quot;,     md.mutator.c_str());
-			}
-			if (!md.game.empty()) {
-				fprintf(out, &quot;\t\t\tGame=%s;\n&quot;,        md.game.c_str());
-			}
-			if (!md.shortGame.empty()) {
-				fprintf(out, &quot;\t\t\tShortGame=%s;\n&quot;,   md.shortGame.c_str());
-			}
-			if (!md.description.empty()) {
-				fprintf(out, &quot;\t\t\tDescription=%s;\n&quot;, md.description.c_str());
-			}
 
-			fprintf(out, &quot;\t\t\tModType=%d;\n&quot;,     md.modType);
+			fprintf(out, &quot;\t\t\t},\n&quot;);
+		}
 
-			fprintf(out, &quot;\t\t\tNumDependencies=%d;\n&quot;, i-&gt;second.modData.dependencies.size());
-			int curdep = 0;
-			for (std::vector&lt;std::string&gt;::iterator dep = i-&gt;second.modData.dependencies.begin(); dep != i-&gt;second.modData.dependencies.end(); ++dep) {
-				fprintf(out, &quot;\t\t\tDepend%d=%s;\n&quot;, curdep, (*dep).c_str());
-				curdep++;
-			}
+		fprintf(out, &quot;\t\t},\n&quot;);
+	}
 
-			fprintf(out, &quot;\t\t\tNumReplaces=%d;\n&quot;, i-&gt;second.modData.replaces.size());
-			int currep = 0;
-			for (std::vector&lt;std::string&gt;::iterator rep = i-&gt;second.modData.replaces.begin(); rep != i-&gt;second.modData.replaces.end(); ++rep) {
-				fprintf(out, &quot;\t\t\tReplace%d=%s;\n&quot;, currep++, (*rep).c_str());
-			}
+	fprintf(out, &quot;\t},\n&quot;); // close 'archives'
+	fprintf(out, &quot;}\n\n&quot;); // close 'archiveCache'
+	fprintf(out, &quot;return archiveCache\n&quot;);
 
-			fprintf(out, &quot;\t\t}\n&quot;);
-		}
-
-		fprintf(out, &quot;\t}\n&quot;);
-		cur++;
-	}
-	fprintf(out, &quot;}\n&quot;);
 	fclose(out);
 
 	isDirty = false;
 }
 
-std::vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetPrimaryMods() const
+
+vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetPrimaryMods() const
 {
-	std::vector&lt;ModData&gt; ret;
+	vector&lt;ModData&gt; ret;
 
-	for (std::map&lt;std::string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		if (i-&gt;second.modData.name != &quot;&quot;) {
 
-			if (i-&gt;second.modData.modType != 1)
+			if (i-&gt;second.modData.modType != 1) {
 				continue;
+			}
 
 			// Add the archive the mod is in as the first dependency
 			ModData md = i-&gt;second.modData;
@@ -542,11 +707,12 @@
 	return ret;
 }
 
-std::vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetAllMods() const
+
+vector&lt;CArchiveScanner::ModData&gt; CArchiveScanner::GetAllMods() const
 {
-	std::vector&lt;ModData&gt; ret;
+	vector&lt;ModData&gt; ret;
 
-	for (std::map&lt;std::string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
+	for (std::map&lt;string, ArchiveInfo&gt;::const_iterator i = archiveInfo.begin(); i != archiveInfo.end(); ++i) {
 		if (i-&gt;second.modData.name != &quot;&quot;) {
 			// Add the archive the mod is in as the first dependency
 			ModData md = i-&gt;second.modData;
@@ -558,7 +724,8 @@
 	return ret;
 }
 
-std::vector&lt;std::string&gt; CArchiveScanner::GetArchives(const std::string&amp; root, int depth)
+
+vector&lt;string&gt; CArchiveScanner::GetArchives(const string&amp; root, int depth)
 {
 	// Protect against circular dependencies
 	// (worst case depth is if all archives form one huge dependency chain)
@@ -566,41 +733,56 @@
 		throw content_error(&quot;Circular dependency&quot;);
 	}
 
-	std::vector&lt;std::string&gt; ret;
-	std::string lcname = StringToLower(ModNameToModArchive(root));
-	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
-	if (aii == archiveInfo.end())
+	vector&lt;string&gt; ret;
+	string lcname = StringToLower(ModNameToModArchive(root));
+	std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	if (aii == archiveInfo.end()) {
 		return ret;
+	}
 
 	// Check if this archive has been replaced
 	while (aii-&gt;second.replaced.length() &gt; 0) {
 		aii = archiveInfo.find(aii-&gt;second.replaced);
-		if (aii == archiveInfo.end())
+		if (aii == archiveInfo.end()) {
 			return ret;
+		}
 	}
 
 	ret.push_back(aii-&gt;second.path + aii-&gt;second.origName);
 
-	if (aii-&gt;second.modData.name == &quot;&quot;)
+	if (aii-&gt;second.modData.name == &quot;&quot;) {
 		return ret;
+	}
 
 	// add depth-first
-	for (std::vector&lt;std::string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
-		std::vector&lt;std::string&gt; dep = GetArchives(*i, depth + 1);
-		for (std::vector&lt;std::string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
+	for (vector&lt;string&gt;::iterator i = aii-&gt;second.modData.dependencies.begin(); i != aii-&gt;second.modData.dependencies.end(); ++i) {
+		vector&lt;string&gt; dep = GetArchives(*i, depth + 1);
+		for (vector&lt;string&gt;::iterator j = dep.begin(); j != dep.end(); ++j) {
 			ret.push_back(*j);
 		}
 	}
 
+	// add springcontent.sdz for primary mod archives
+	if ((depth == 0) &amp;&amp; (aii-&gt;second.modData.modType == 1)) {
+		const string springContentPath = GetArchivePath(&quot;springcontent.sdz&quot;);
+		if (springContentPath.empty()) {
+			throw content_error(&quot;missing springcontent.sdz&quot;);
+		} else {
+			printf(&quot;Added springcontent.sdz for %s\n&quot;, root.c_str());
+			ret.push_back(springContentPath + &quot;springcontent.sdz&quot;);
+		}
+	}
+
 	return ret;
 }
 
-std::vector&lt;std::string&gt; CArchiveScanner::GetMaps()
+
+vector&lt;string&gt; CArchiveScanner::GetMaps()
 {
-	std::vector&lt;std::string&gt; ret;
+	vector&lt;string&gt; ret;
 
-	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (std::vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
+	for (std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
 			ret.push_back((*i).name);
 		}
 	}
@@ -608,14 +790,22 @@
 	return ret;
 }
 
-std::vector&lt;std::string&gt; CArchiveScanner::GetArchivesForMap(const std::string&amp; mapName)
+
+vector&lt;string&gt; CArchiveScanner::GetArchivesForMap(const string&amp; mapName)
 {
-	std::vector&lt;std::string&gt; ret;
+	vector&lt;string&gt; ret;
 
-	for (std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
-		for (std::vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
+	for (std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.begin(); aii != archiveInfo.end(); ++aii) {
+		for (vector&lt;MapData&gt;::iterator i = aii-&gt;second.mapData.begin(); i != aii-&gt;second.mapData.end(); ++i) {
 			if (mapName == (*i).name) {
-				return GetArchives(aii-&gt;first);
+				ret = GetArchives(aii-&gt;first);
+				const string mapHelperPath = GetArchivePath(&quot;maphelper.sdz&quot;);
+				if (mapHelperPath.empty()) {
+					throw content_error(&quot;missing maphelper.sdz&quot;);
+				} else {
+					ret.push_back(mapHelperPath + &quot;maphelper.sdz&quot;);
+				}
+				break;
 			}
 		}
 	}
@@ -623,19 +813,22 @@
 	return ret;
 }
 
-unsigned int CArchiveScanner::GetArchiveChecksum(const std::string&amp; name)
+
+unsigned int CArchiveScanner::GetArchiveChecksum(const string&amp; name)
 {
-	std::string lcname = name;
+	string lcname = name;
 
 	// Strip path-info if present
-	if (lcname.find_last_of('\\') != std::string::npos)
+	if (lcname.find_last_of('\\') != string::npos) {
 		lcname = lcname.substr(lcname.find_last_of('\\') + 1);
-	if (lcname.find_last_of('/') != std::string::npos)
+	}
+	if (lcname.find_last_of('/') != string::npos) {
 		lcname = lcname.substr(lcname.find_last_of('/') + 1);
+	}
 
 	StringToLowerInPlace(lcname);
 
-	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
 		return 0;
 	}
@@ -643,19 +836,22 @@
 	return aii-&gt;second.checksum;
 }
 
-std::string CArchiveScanner::GetArchivePath(const std::string&amp; name)
+
+string CArchiveScanner::GetArchivePath(const string&amp; name)
 {
-	std::string lcname = name;
+	string lcname = name;
 
 	// Strip path-info if present
-	if (lcname.find_last_of('\\') != std::string::npos)
+	if (lcname.find_last_of('\\') != string::npos) {
 		lcname = lcname.substr(lcname.find_last_of('\\') + 1);
-	if (lcname.find_last_of('/') != std::string::npos)
+	}
+	if (lcname.find_last_of('/') != string::npos) {
 		lcname = lcname.substr(lcname.find_last_of('/') + 1);
+	}
 
 	StringToLowerInPlace(lcname);
 
-	std::map&lt;std::string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
+	std::map&lt;string, ArchiveInfo&gt;::iterator aii = archiveInfo.find(lcname);
 	if (aii == archiveInfo.end()) {
 		return 0;
 	}
@@ -663,14 +859,14 @@
 	return aii-&gt;second.path;
 }
 
+
 /** Get checksum of all required archives depending on selected mod. */
-unsigned int CArchiveScanner::GetModChecksum(const std::string&amp; root)
+unsigned int CArchiveScanner::GetModChecksum(const string&amp; root)
 {
 	unsigned int checksum = 0;
-	std::vector&lt;std::string&gt; ars = GetArchives(root);
+	vector&lt;string&gt; ars = GetArchives(root);
 
-	for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
-	{
+	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
 		unsigned tmp = GetArchiveChecksum(*i);
 		logOutput.Print(&quot;mod checksum %s: %u/%d&quot;, i-&gt;c_str(), tmp, (int)tmp);
 		checksum ^= tmp;
@@ -678,13 +874,14 @@
 	return checksum;
 }
 
+
 /** Get checksum of all required archives depending on selected map. */
-unsigned int CArchiveScanner::GetMapChecksum(const std::string&amp; mapName)
+unsigned int CArchiveScanner::GetMapChecksum(const string&amp; mapName)
 {
 	unsigned int checksum = 0;
-	std::vector&lt;std::string&gt; ars = GetArchivesForMap(mapName);
+	vector&lt;string&gt; ars = GetArchivesForMap(mapName);
 
-	for (std::vector&lt;std::string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
+	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
 		unsigned tmp = GetArchiveChecksum(*i);
 		logOutput.Print(&quot;map checksum %s: %u/%d&quot;, i-&gt;c_str(), tmp, (int)tmp);
 		checksum ^= tmp;
@@ -692,8 +889,9 @@
 	return checksum;
 }
 
+
 /** Check if calculated mod checksum equals given checksum. Throws content_error if not equal. */
-void CArchiveScanner::CheckMod(const std::string&amp; root, unsigned checksum)
+void CArchiveScanner::CheckMod(const string&amp; root, unsigned checksum)
 {
 	unsigned localChecksum = GetModChecksum(root);
 	if (localChecksum != checksum) {
@@ -710,8 +908,9 @@
 	}
 }
 
+
 /** Check if calculated map checksum equals given checksum. Throws content_error if not equal. */
-void CArchiveScanner::CheckMap(const std::string&amp; mapName, unsigned checksum)
+void CArchiveScanner::CheckMap(const string&amp; mapName, unsigned checksum)
 {
 	unsigned localChecksum = GetMapChecksum(mapName);
 	if (localChecksum != checksum) {
@@ -728,24 +927,27 @@
 	}
 }
 
+
 /** Convert mod name to mod primary archive, e.g. ModNameToModArchive(&quot;XTA v8.1&quot;) returns &quot;xtape.sd7&quot;. */
-std::string CArchiveScanner::ModNameToModArchive(const std::string&amp; s) const
+string CArchiveScanner::ModNameToModArchive(const string&amp; s) const
 {
 	// Convert mod name to mod archive
-	std::vector&lt;ModData&gt; found = GetAllMods();
-	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
-		if (it-&gt;name == s)
+	vector&lt;ModData&gt; found = GetAllMods();
+	for (vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
+		if (it-&gt;name == s) {
 			return it-&gt;dependencies.front();
+		}
 	}
 	return s;
 }
 
+
 /** The reverse of ModNameToModArchive() */
-std::string CArchiveScanner::ModArchiveToModName(const std::string&amp; s) const
+string CArchiveScanner::ModArchiveToModName(const string&amp; s) const
 {
 	// Convert mod archive to mod name
-	std::vector&lt;ModData&gt; found = GetAllMods();
-	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
+	vector&lt;ModData&gt; found = GetAllMods();
+	for (vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		if (it-&gt;dependencies.front() == s) {
 			return it-&gt;name;
 		}
@@ -753,12 +955,13 @@
 	return s;
 }
 
+
 /** Convert mod name to mod data struct, can return empty ModData */
-CArchiveScanner::ModData CArchiveScanner::ModNameToModData(const std::string&amp; s) const
+CArchiveScanner::ModData CArchiveScanner::ModNameToModData(const string&amp; s) const
 {
 	// Convert mod name to mod archive
-	std::vector&lt;ModData&gt; found = GetAllMods();
-	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
+	vector&lt;ModData&gt; found = GetAllMods();
+	for (vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		const ModData&amp; md = *it;
 		if (md.name == s) {
 			return md;
@@ -767,12 +970,13 @@
 	return ModData();
 }
 
+
 /** Convert mod archive to mod data struct, can return empty ModData */
-CArchiveScanner::ModData CArchiveScanner::ModArchiveToModData(const std::string&amp; s) const
+CArchiveScanner::ModData CArchiveScanner::ModArchiveToModData(const string&amp; s) const
 {
 	// Convert mod archive to mod name
-	std::vector&lt;ModData&gt; found = GetAllMods();
-	for (std::vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
+	vector&lt;ModData&gt; found = GetAllMods();
+	for (vector&lt;ModData&gt;::iterator it = found.begin(); it != found.end(); ++it) {
 		const ModData&amp; md = *it;
 		if (md.dependencies.front() == s) {
 			return md;

Modified: branches/gml/rts/System/FileSystem/ArchiveScanner.h
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveScanner.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/FileSystem/ArchiveScanner.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -7,7 +7,8 @@
 
 class CArchiveBase;
 class IFileFilter;
-class TdfParser;
+class LuaParser;
+class LuaTable;
 
 /*
  * This class searches through a given directory and its subdirectories looking for archive files.
@@ -26,6 +27,7 @@
 		std::string name;
 		std::string virtualPath;					// Where in the archive the map can be found
 	};
+
 	struct ModData {
 		std::string name;							// ex:  Original Total Annihilation v2.3
 		std::string shortName;						// ex:  OTA
@@ -38,12 +40,17 @@
 		std::vector&lt;std::string&gt; dependencies;		// Archives it depends on
 		std::vector&lt;std::string&gt; replaces;			// This archive obsoletes these ones
 	};
+
 	CArchiveScanner(void);
+	virtual ~CArchiveScanner(void);
+
 	std::string GetFilename();
+
+	void ScanDirs(const std::vector&lt;std::string&gt;&amp; dirs, bool checksum = false);
+
 	void ReadCacheData(const std::string&amp; filename);
 	void WriteCacheData(const std::string&amp; filename);
-	virtual ~CArchiveScanner(void);
-	void Scan(const std::string&amp; curPath, bool checksum = false);
+
 	std::vector&lt;ModData&gt; GetPrimaryMods() const;
 	std::vector&lt;ModData&gt; GetAllMods() const;
 	std::vector&lt;std::string&gt; GetArchives(const std::string&amp; root, int depth = 0);
@@ -71,11 +78,25 @@
 		bool updated;
 		std::string replaced;					// If not empty, use that archive instead
 	};
+
+protected:
+	void PreScan(const std::string&amp; curPath);
+	void Scan(const std::string&amp; curPath, bool checksum = false);
+	void ScanArchive(const std::string&amp; fullName, bool checksum = false);
+	void ScanMap(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
+	void ScanModLua(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
+	void ScanModTdf(CArchiveBase* ar, const std::string&amp; fileName, ArchiveInfo&amp; ai);
+
+protected:
 	std::map&lt;std::string, ArchiveInfo&gt; archiveInfo;
-	ModData GetModData(TdfParser* p, const std::string&amp; section);
+	ModData GetModData(const LuaTable&amp; modTable);
 	IFileFilter* CreateIgnoreFilter(CArchiveBase* ar);
 	unsigned int GetCRC(const std::string&amp; filename);
 	bool isDirty;
+	std::string parse_tdf_path;
+	std::string parse_tdf_code;
+	std::string scanutils_path;
+	std::string scanutils_code;
 };
 
 extern CArchiveScanner* archiveScanner;

Modified: branches/gml/rts/System/FileSystem/ArchiveZip.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/ArchiveZip.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/FileSystem/ArchiveZip.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -25,10 +25,8 @@
 
 		unzGetCurrentFileInfo(zip, &amp;info, fname, 512, NULL, 0, NULL, 0);
 
-		// NOTE: fix this on next CArchiveScanner INTERNAL_VER bump.
-		// It should be `if (info.uncompressed_size &gt;= 0) {' because now
 		// zero-size files are ignored.
-		if (info.uncompressed_size &gt; 0) {
+		if (info.uncompressed_size &gt;= 0) {
 			name = StringToLower(fname);
 //			SetSlashesForwardToBack(name);
 

Modified: branches/gml/rts/System/FileSystem/FileHandler.cpp
===================================================================
--- branches/gml/rts/System/FileSystem/FileHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/FileSystem/FileHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -16,13 +16,15 @@
 /******************************************************************************/
 /******************************************************************************/
 
-CFileHandler::CFileHandler(const char* filename, const char* modes) : ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
+CFileHandler::CFileHandler(const char* filename, const char* modes)
+: ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
 {
 	Init(filename, modes);
 }
 
 
-CFileHandler::CFileHandler(const string&amp; filename, const string&amp; modes) : ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
+CFileHandler::CFileHandler(const string&amp; filename, const string&amp; modes)
+: ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
 {
 	Init(filename, modes);
 }

Modified: branches/gml/rts/System/GlobalStuff.cpp
===================================================================
--- branches/gml/rts/System/GlobalStuff.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/GlobalStuff.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -41,6 +41,7 @@
 
 CR_REG_METADATA(CGlobalSyncedStuff, (
 				CR_MEMBER(randSeed),
+				CR_MEMBER(initRandSeed),
 				CR_MEMBER(frameNum),
 				CR_MEMBER(speedFactor),
 				CR_MEMBER(userSpeedFactor),
@@ -91,44 +92,45 @@
  */
 CGlobalSyncedStuff::CGlobalSyncedStuff()
 {
-	hmapx=256;
-	hmapy=256;
-	randSeed=18655;//li.LowPart;
-	frameNum=0;
-	speedFactor=1;
-	userSpeedFactor=1;
-	paused=false;
-	godMode=false;
-	cheatEnabled=false;
-	noHelperAIs=false;
-	editDefsEnabled=false;
-	tempNum=2;
-	gameMode=0;
-	useLuaGaia=true;
-	gaiaTeamID=-1;
-	gaiaAllyTeamID=-1;
-	useLuaRules=true;
+	hmapx = 256;
+	hmapy = 256;
+	randSeed = 18655; //li.LowPart;
+	initRandSeed = randSeed;
+	frameNum = 0;
+	speedFactor = 1;
+	userSpeedFactor = 1;
+	paused = false;
+	godMode = false;
+	cheatEnabled = false;
+	noHelperAIs = false;
+	editDefsEnabled = false;
+	tempNum = 2;
+	gameMode = 0;
+	useLuaGaia = true;
+	gaiaTeamID = -1;
+	gaiaAllyTeamID = -1;
+	useLuaRules = true;
 	
-	for(int a=0; a &lt; MAX_TEAMS; ++a){
-		teams[a]=SAFE_NEW CTeam();
-		teams[a]-&gt;teamNum=a;
-		team2allyteam[a]=a;
+	for(int a = 0; a &lt; MAX_TEAMS; ++a) {
+		teams[a] = SAFE_NEW CTeam();
+		teams[a]-&gt;teamNum = a;
+		team2allyteam[a] = a;
 	}
-	for(int a=0; a &lt; MAX_PLAYERS; ++a){
-		players[a]=SAFE_NEW CPlayer();
-		players[a]-&gt;team=0;
+	for(int a = 0; a &lt; MAX_PLAYERS; ++a) {
+		players[a] = SAFE_NEW CPlayer();
+		players[a]-&gt;team = 0;
 	}
 
-	for(int a=0; a &lt; MAX_TEAMS; ++a){
-		for(int b=0;b&lt;MAX_TEAMS;++b){
-			allies[a][b]=false;
+	for (int a = 0; a &lt; MAX_TEAMS; ++a) {
+		for (int b = 0; b &lt; MAX_TEAMS; ++b) {
+			allies[a][b] = false;
 		}
-		allies[a][a]=true;
+		allies[a][a] = true;
 	}
 
-	activeTeams=2;
-	activeAllyTeams=2;
-	activePlayers=MAX_PLAYERS;
+	activeTeams = 2;
+	activeAllyTeams = 2;
+	activePlayers = MAX_PLAYERS;
 }
 
 /**
@@ -136,10 +138,12 @@
  */
 CGlobalSyncedStuff::~CGlobalSyncedStuff()
 {
-	for(int a=0;a&lt;MAX_TEAMS;a++)
+	for(int a = 0; a &lt; MAX_TEAMS; a++) {
 		delete teams[a];
-	for(int a=0;a&lt;gs-&gt;activePlayers;a++)
+	}
+	for(int a = 0; a &lt; gs-&gt;activePlayers; a++) {
 		delete players[a];
+	}
 }
 
 /**
@@ -172,10 +176,10 @@
 float3 CGlobalSyncedStuff::randVector()
 {
 	float3 ret;
-	do{
-		ret.x=randFloat()*2-1;
-		ret.y=randFloat()*2-1;
-		ret.z=randFloat()*2-1;
+	do {
+		ret.x = randFloat()*2-1;
+		ret.y = randFloat()*2-1;
+		ret.z = randFloat()*2-1;
 	} while(ret.SqLength()&gt;1);
 
 	return ret;
@@ -183,10 +187,10 @@
 
 int CGlobalSyncedStuff::Player(const std::string&amp; name)
 {
-	for (int i = 0; i &lt; MAX_PLAYERS; ++i)
-	{
-		if (players[i] &amp;&amp; players[i]-&gt;playerName == name)
+	for (int i = 0; i &lt; MAX_PLAYERS; ++i) {
+		if (players[i] &amp;&amp; players[i]-&gt;playerName == name) {
 			return i;
+		}
 	}
 	return -1;
 }
@@ -198,32 +202,32 @@
 {
 	Uint64 randnum;
 	randnum = SDL_GetTicks();
-	usRandSeed=randnum&amp;0xffffffff;
-	modGameTime=0;
-	gameTime=0;
-	lastFrameTime=0;
-	viewSizeX=100;
-	viewSizeY=100;
-	pixelX=0.01f;
-	pixelY=0.01f;
-	aspectRatio=1.0f;
-	myPlayerNum=0;
-	myTeam=1;
-	myAllyTeam=1;
+	usRandSeed = randnum&amp;0xffffffff;
+	modGameTime = 0;
+	gameTime = 0;
+	lastFrameTime = 0;
+	viewSizeX = 100;
+	viewSizeY = 100;
+	pixelX = 0.01f;
+	pixelY = 0.01f;
+	aspectRatio = 1.0f;
+	myPlayerNum = 0;
+	myTeam = 1;
+	myAllyTeam = 1;
 	spectating           = false;
 	spectatingFullView   = false;
 	spectatingFullSelect = false;
-	drawdebug=false;
-	active=true;
-	viewRange=MAX_VIEW_RANGE;
-	timeOffset=0;
-	drawFog=true;
-	compressTextures=false;
-	teamNanospray=false;
-	autoQuit=false;
-	quitTime=0;
+	drawdebug = false;
+	active = true;
+	viewRange = MAX_VIEW_RANGE;
+	timeOffset = 0;
+	drawFog = true;
+	compressTextures = false;
+	teamNanospray = false;
+	autoQuit = false;
+	quitTime = 0;
 #ifdef DIRECT_CONTROL_ALLOWED
-	directControl=0;
+	directControl = 0;
 #endif
 }
 
@@ -264,11 +268,11 @@
 float3 CGlobalUnsyncedStuff::usRandVector()
 {
 	float3 ret;
-	do{
-		ret.x=usRandFloat()*2-1;
-		ret.y=usRandFloat()*2-1;
-		ret.z=usRandFloat()*2-1;
-	} while(ret.SqLength()&gt;1);
+	do {
+		ret.x = usRandFloat() * 2 - 1;
+		ret.y = usRandFloat() * 2 - 1;
+		ret.z = usRandFloat() * 2 - 1;
+	} while (ret.SqLength() &gt; 1);
 
 	return ret;
 }

Modified: branches/gml/rts/System/GlobalStuff.h
===================================================================
--- branches/gml/rts/System/GlobalStuff.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/GlobalStuff.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -138,14 +138,20 @@
 {
 public:
 	CR_DECLARE(CGlobalSyncedStuff);
-	CGlobalSyncedStuff(); 		//!&lt; Constructor
-	~CGlobalSyncedStuff(); 	//!&lt; Destructor
+	CGlobalSyncedStuff();  //!&lt; Constructor
+	~CGlobalSyncedStuff(); //!&lt; Destructor
 
-	int randInt();			//!&lt; synced random int
-	float randFloat(); 		//!&lt; synced random float
-	float3 randVector(); 		//!&lt; synced random vector
-	void SetRandSeed(unsigned seed) {randSeed = seed; };
+	int    randInt();    //!&lt; synced random int
+	float  randFloat();  //!&lt; synced random float
+	float3 randVector(); //!&lt; synced random vector
 
+	void SetRandSeed(unsigned int seed, bool init = false) {
+		randSeed = seed;
+		if (init) { initRandSeed = randSeed; }
+	}
+	unsigned int GetRandSeed()     const { return randSeed; }
+	unsigned int GetInitRandSeed() const { return initRandSeed; }
+
 	/**
 	 * @brief frame number
 	 *
@@ -408,6 +414,13 @@
 	int randSeed;
 
 	/**
+	* @brief initial random seed
+	*
+	* Holds the synced initial random seed
+	*/
+	int initRandSeed;
+
+	/**
 	 * @brief allies array
 	 *
 	 * Array indicates whether teams are allied,
@@ -441,12 +454,12 @@
 {
 public:
 	CR_DECLARE(CGlobalUnsyncedStuff);
-	CGlobalUnsyncedStuff(); 		//!&lt; Constructor
-	~CGlobalUnsyncedStuff();	 	//!&lt; Destructor
+	CGlobalUnsyncedStuff();  //!&lt; Constructor
+	~CGlobalUnsyncedStuff(); //!&lt; Destructor
 
-	int usRandInt(); 			//!&lt; Unsynced random int
-	float usRandFloat(); 			//!&lt; Unsynced random float
-	float3 usRandVector(); 			//!&lt; Unsynced random vector
+	int    usRandInt();    //!&lt; Unsynced random int
+	float  usRandFloat();  //!&lt; Unsynced random float
+	float3 usRandVector(); //!&lt; Unsynced random vector
 
 	/**
 	 * Does the user want team colored nanospray if the mod allows it?

Modified: branches/gml/rts/System/LogOutput.h
===================================================================
--- branches/gml/rts/System/LogOutput.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/LogOutput.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -8,6 +8,7 @@
 
 #include &lt;stdarg.h&gt;
 #include &lt;vector&gt;
+#include &lt;string&gt;
 
 // format string error checking
 #ifdef __GNUC__

Modified: branches/gml/rts/System/Net/Connection.h
===================================================================
--- branches/gml/rts/System/Net/Connection.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/Connection.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -28,6 +28,8 @@
 	
 	virtual void SendData(boost::shared_ptr&lt;const RawPacket&gt; data)=0;
 
+	virtual bool HasIncomingData() const = 0;
+
 	/**
 	@brief Take a look at the messages that will be returned by GetData().
 	@return A RawPacket holding the data, or 0 if no data
@@ -49,6 +51,7 @@
 	
 	virtual std::string Statistics() const = 0;
 	virtual NetAddress GetPeerName() const = 0;
+	virtual void Update() {};
 
 protected:
 	unsigned dataSent;

Modified: branches/gml/rts/System/Net/LocalConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/LocalConnection.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/LocalConnection.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -90,6 +90,12 @@
 	return addr;
 }
 
+bool CLocalConnection::HasIncomingData() const
+{
+	boost::mutex::scoped_lock scoped_lock(Mutex[instance]);
+	return (!Data[instance].empty());
+}
+
 unsigned CLocalConnection::OtherInstance() const
 {
 	if (instance == 0)

Modified: branches/gml/rts/System/Net/LocalConnection.h
===================================================================
--- branches/gml/rts/System/Net/LocalConnection.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/LocalConnection.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -46,6 +46,7 @@
 	
 	virtual std::string Statistics() const;
 	virtual NetAddress GetPeerName() const;
+	virtual bool HasIncomingData() const;
 
 private:
 	static std::deque&lt; boost::shared_ptr&lt;const RawPacket&gt; &gt; Data[2];

Deleted: branches/gml/rts/System/Net/Net.cpp
===================================================================
--- branches/gml/rts/System/Net/Net.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/Net.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,324 +0,0 @@
-//
-// Net.cpp: implementation of the CNet class.
-//
-//////////////////////////////////////////////////////////////////////
-
-
-#include &quot;Net.h&quot;
-
-#include &lt;boost/format.hpp&gt;
-#include &lt;boost/weak_ptr.hpp&gt;
-
-#include &quot;Connection.h&quot;
-#include &quot;UDPConnection.h&quot;
-#include &quot;UDPListener.h&quot;
-#include &quot;LocalConnection.h&quot;
-#include &quot;ProtocolDef.h&quot;
-#include &quot;RawPacket.h&quot;
-#include &quot;Exception.h&quot;
-
-
-namespace netcode {
-
-CNet::CNet()
-{
-	SetMTU();
-}
-
-CNet::~CNet()
-{
-	FlushNet();
-}
-
-void CNet::InitServer(unsigned portnum)
-{
-	udplistener.reset(new UDPListener(portnum));
-}
-
-unsigned CNet::InitClient(const char *server, unsigned portnum,unsigned sourceport, unsigned playerNum)
-{
-	udplistener.reset(new UDPListener(sourceport));
-	boost::shared_ptr&lt;UDPConnection&gt; incoming(udplistener-&gt;SpawnConnection(std::string(server), portnum));
-
-	return InitNewConn(incoming, playerNum);
-}
-
-unsigned CNet::InitLocalClient(const unsigned wantedNumber)
-{
-	boost::shared_ptr&lt;CLocalConnection&gt; conn(new CLocalConnection());	
-	return InitNewConn(conn, wantedNumber);
-}
-
-void CNet::ServerInitLocalClient()
-{
-	boost::shared_ptr&lt;CLocalConnection&gt; conn(new CLocalConnection());
-	localConnBuf = conn;
-}
-
-void CNet::RegisterMessage(unsigned char id, int length)
-{
-	ProtocolDef::instance()-&gt;AddType(id, length);
-}
-
-void CNet::SetMTU(unsigned mtu)
-{
-	ProtocolDef::instance()-&gt;UDP_MTU = mtu;
-}
-
-bool CNet::Listening()
-{
-	if (udplistener)
-	{
-		return udplistener-&gt;Listen();
-	}
-	else
-	{
-		return false;
-	}
-}
-
-void CNet::Listening(const bool state)
-{
-	if (udplistener)
-	{
-		udplistener-&gt;Listen(state);
-	}
-}
-
-void CNet::Kill(const unsigned connNumber)
-{
-	if (int(connNumber) &gt; MaxConnectionID() || !connections[connNumber])
-		throw network_error(&quot;Wrong connection ID in CNet::Kill()&quot;);
-	
-	connections[connNumber]-&gt;Flush(true);
-	connections[connNumber].reset();
-}
-
-bool CNet::Connected() const
-{
-	for (connVec::const_iterator  i = connections.begin(); i &lt; connections.end(); ++i)
-	{
-		if ((*i) &amp;&amp; (*i)-&gt;GetDataReceived() &gt; 0)
-		{
-			return true;
-		}
-	}
-	
-	return false;
-}
-
-int CNet::MaxConnectionID() const
-{
-	return connections.size()-1;
-}
-
-bool CNet::IsActiveConnection(const unsigned number) const
-{
-	if (int(number) &gt; MaxConnectionID())
-		return false;
-	else
-		return connections[number];
-}
-
-std::string CNet::GetConnectionStatistics(const unsigned number) const
-{
-	return connections[number]-&gt;Statistics();
-}
-
-NetAddress CNet::GetConnectedAddress(const unsigned number)
-{
-	return connections[number]-&gt;GetPeerName();
-}
-
-boost::shared_ptr&lt;const RawPacket&gt; CNet::Peek(const unsigned conNum, unsigned ahead) const
-{
-	if (int(conNum) &lt;= MaxConnectionID() &amp;&amp; (bool)connections[conNum])
-	{
-		return connections[conNum]-&gt;Peek(ahead);
-	}
-	else
-	{
-		throw network_error(str( boost::format(&quot;Wrong connection ID in CNet::Peek(): %1%&quot;) %conNum ));
-	}
-}
-
-boost::shared_ptr&lt;const RawPacket&gt; CNet::GetData(const unsigned conNum)
-{
-	if (int(conNum) &lt;= MaxConnectionID() &amp;&amp; (bool)connections[conNum])
-	{
-		return connections[conNum]-&gt;GetData();
-	}
-	else
-	{
-		throw network_error(str( boost::format(&quot;Wrong connection ID in CNet::GetData(): %1%&quot;) %conNum ));
-	}
-}
-
-void CNet::SendData(boost::shared_ptr&lt;const RawPacket&gt; data)
-{
-#ifdef DEBUG
-	{
-		unsigned int msglength = 0;
-		unsigned char msgid = data-&gt;data[0];
-		ProtocolDef* proto = ProtocolDef::instance();
-		if (proto-&gt;HasFixedLength(msgid))
-		{
-			msglength = proto-&gt;GetLength(msgid);
-		}
-		else
-		{
-			int length_t = proto-&gt;GetLength(msgid);
-			if (length_t == -1)
-			{
-				msglength = (unsigned int)(data-&gt;data[1]);
-			}
-			else if (length_t == -2)
-			{
-				msglength = *((short*)(data-&gt;data+1));
-			}
-		}
-		
-		if (data-&gt;length != msglength || data-&gt;length == 0)
-		{
-			throw network_error( str( boost::format(&quot;Message length error (ID %1% with length %2% should be %3%) while sending (CNet::SendData(char*, unsigned))&quot;) % (unsigned int)(data-&gt;data[0]) % data-&gt;length % msglength ) );
-		}
-	}
-#endif
-	for (connVec::iterator it = connections.begin(); it != connections.end(); ++it)
-	{
-		if(*it)
-			(*it)-&gt;SendData(data);
-	}
-}
-
-void CNet::SendData(boost::shared_ptr&lt;const RawPacket&gt; data, const unsigned playerNum)
-{
-	if (int(playerNum) &lt;= MaxConnectionID() &amp;&amp; connections[playerNum])
-		connections[playerNum]-&gt;SendData(data);
-	else
-		throw network_error(&quot;Can't send data (wrong connection number)&quot;);
-}
-
-void CNet::FlushNet()
-{
-	for (connVec::const_iterator i = connections.begin(); i != connections.end(); ++i)
-	{
-		if((*i)){
-			(*i)-&gt;Flush(true);
-		}
-	}
-}
-
-void CNet::FlushNet(const unsigned connection)
-{
-	connections[connection]-&gt;Flush(true);
-}
-
-void CNet::Update()
-{
-	if (udplistener)
-	{
-		udplistener-&gt;Update();
-	}
-	
-	for (connVec::iterator i = connections.begin(); i != connections.end(); ++i)
-	{
-		if((*i) &amp;&amp; (*i)-&gt;CheckTimeout())
-		{
-			(*i)-&gt;Flush(true);
-			i-&gt;reset();
-		}
-	}
-	
-	// remove the last pointer from the vector if it doesn't store a connection
-	if (!connections.empty() &amp;&amp; !(connections.back()))
-		connections.pop_back();
-}
-
-unsigned CNet::InitNewConn(const connPtr&amp; newClient, const unsigned wantedNumber)
-{
-	unsigned freeConn = wantedNumber;
-	
-	if(int(wantedNumber) &lt;= MaxConnectionID() &amp;&amp; connections[wantedNumber])
-	{
-		// ID is already in use
-		freeConn = 0;
-	}
-
-	if (freeConn == 0) // look for first free ID
-	{
-		for(freeConn = 0; int(freeConn) &lt;= MaxConnectionID(); ++freeConn)
-		{
-			if(!connections[freeConn])
-			{
-				break;
-			}
-		}
-	}
-	
-	if (int(freeConn) &gt; MaxConnectionID())
-	{
-		// expand the vector
-		connections.resize(freeConn+1);
-	}
-	connections[freeConn] = newClient;
-
-	return freeConn;
-}
-
-bool CNet::HasIncomingConnection() const
-{
-	return (localConnBuf || (udplistener &amp;&amp; udplistener-&gt;HasIncomingConnections()));
-}
-
-boost::shared_ptr&lt;const RawPacket&gt; CNet::GetData()
-{
-	if (localConnBuf)
-		return localConnBuf-&gt;GetData();
-	else if (udplistener &amp;&amp; udplistener-&gt;HasIncomingConnections())
-	{
-		boost::shared_ptr&lt;UDPConnection&gt; locked(udplistener-&gt;PreviewConnection());
-		return locked-&gt;GetData();
-	}
-	else
-		throw network_error(&quot;No Connection waiting (no data recieved)&quot;);
-}
-
-unsigned CNet::AcceptIncomingConnection(const unsigned wantedNumber)
-{
-	if (localConnBuf)
-	{
-		unsigned buffer = InitNewConn(localConnBuf, wantedNumber);
-		localConnBuf.reset();
-		return buffer;
-	}
-	else if (udplistener &amp;&amp; udplistener-&gt;HasIncomingConnections())
-	{
-		unsigned buffer = InitNewConn(udplistener-&gt;AcceptConnection(), wantedNumber);
-		return buffer;
-	}
-	else
-	{
-		throw network_error(&quot;No Connection waiting (no connection accepted)&quot;);
-	}
-}
-
-void CNet::RejectIncomingConnection()
-{
-	if (localConnBuf)
-	{
-		localConnBuf.reset();
-	}
-	else if (udplistener &amp;&amp; udplistener-&gt;HasIncomingConnections())
-	{
-		udplistener-&gt;RejectConnection();
-	}
-	else
-	{
-		throw network_error(&quot;No connection found to reject&quot;);
-	}
-}
-
-} // namespace netcode
-
-

Deleted: branches/gml/rts/System/Net/Net.h
===================================================================
--- branches/gml/rts/System/Net/Net.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/Net.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,226 +0,0 @@
-#ifndef NET_H
-#define NET_H
-
-#include &lt;string&gt;
-#include &lt;vector&gt;
-#include &lt;boost/shared_ptr.hpp&gt;
-#include &lt;boost/scoped_ptr.hpp&gt;
-
-#include &quot;RawPacket.h&quot;
-
-using netcode::RawPacket;
-
-namespace netcode {
-class CConnection;
-struct NetAddress;
-class UDPListener;
-
-/**
<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">- at brief</A> Interface for low level networking
-Low level network connection (basically a fast TCP-like layer on top of UDP)
-*/
-class CNet
-{
-public:
-	/**
-	@brief Initialise the networking layer
-	
-	Only sets maximum mtu to 500.
-	*/
-	CNet();
-	
-	/**
-	@brief Send all remaining data and exit.
-	*/
-	~CNet();
-	
-	/**
-	@brief Listen for incoming connections
-	
-	Creates an UDPListener to listen for clients which want to connect.
-	*/
-	void InitServer(unsigned portnum);
-	
-	/**
-	@brief Initialise Client
-	@param server Address of the server, either IP or hostname
-	@param portnum The port we have to connect to
-	@param sourceport The port we will use here
-	@param playernum The number this connection should get
-	@return The number the new connection was assigned to (will be playerNum if this number is free, otherwise it will pick the first free number, starting from 0)
-	
-	This will spawn a new connection. Only do this when you cannot use a local connection, because they are somewhat faster.
-	*/
-	unsigned InitClient(const char* server,unsigned portnum,unsigned sourceport, unsigned playerNum);
-	
-	/** 
-	@brief Init a local client
-	@param wantedNumber The number this connection should get
-	@return Like in InitClient, this will return the number thi connection was assigned to
-	
-	To increase performance, use this for local communication. You need to call ServerInitLocalClient() from inside the server too.
-	*/
-	unsigned InitLocalClient(const unsigned wantedNumber);
-	
-	/** 
-	@brief Init a local client (call from inside the server)
-	@todo This is only a workaround because we have no listener for local connections
-	 */
-	void ServerInitLocalClient();
-	
-	/**
-	@brief register a new message type to the networking layer
-	@param id Message identifier (has to be unique)
-	@param length the length of the message (&gt;0 if its fixed length, &lt;0 means the next x bytes represent the length)
-	
-	Its not allowed to send unregistered messages. In this process you tell how big the messages are.
-	*/
-	void RegisterMessage(unsigned char id, int length);
-	
-	/**
-	@brief Set maximum message size
-	
-	Default will be 500. Bigger messages will be truncated.
-	*/
-	void SetMTU(unsigned mtu = 500);
-	
-	/**
-	@brief Check if new connections got accepted
-	@return if new connections got accepted, it will return true. When its false, all packets from unknown sources will get dropped.
-	*/
-	bool Listening();
-	
-	/**
-	@brief Set listening state
-	@param state Wheter we accept packets from unknown sources (and create a new connection when we recieve one)
-	*/
-	void Listening(const bool state);
-	
-	/**
-	@brief Kick a client
-	@param connNumber client that should be kicked
-	@throw network_error when there is no such connection
-	
-	Send all remaining data from buffer and then delete the connection.
-	*/
-	void Kill(const unsigned connNumber);
-
-	/**
-	@brief Are we already connected?
-	@return true when we recieved data from someone
-	
-	This checks all connections if they recieved any data.
-	*/
-	bool Connected() const;
-
-	/**
-	@return The maximum connection number which is in use
-	*/
-	int MaxConnectionID() const;
-	
-	/**
-	@brief Check if it is a valid connenction
-	@return true when its valid, false when not
-	@throw network_error When number is bigger then MaxConenctionID
-	*/
-	bool IsActiveConnection(const unsigned number) const;
-	
-	/**
-	@brief Gives some usefull statistics
-	@return string with statistics
-	 */
-	std::string GetConnectionStatistics(const unsigned number) const;
-	NetAddress GetConnectedAddress(const unsigned number);
-
-	/**
-	@brief Take a look at the messages that will be returned by GetData().
-	@return A RawPacket holding the data, or 0 if no data
-	@param conNum The number to recieve from
-	@param ahead How many packets to look ahead. A typical usage would be:
-	for (int ahead = 0; (packet = net-&gt;Peek(conNum, ahead)); ++ahead) {}
-	*/
-	boost::shared_ptr&lt;const RawPacket&gt; Peek(const unsigned conNum, unsigned ahead) const;
-
-	/**
-	@brief Receive data from a client
-	@param conNum The number to recieve from
-	@return a smart RawPacket pointer with the data inside (or empty when no data)
-	@throw network_error When conNum is not a valid connection ID
-	*/
-	boost::shared_ptr&lt;const RawPacket&gt; GetData(const unsigned conNum);
-	
-	/**
-	@brief Broadcast data to all clients
-	@param data The smart packet pointer
-	@throw network_error Only when DEBUG is set: When the message identifier (data[0]) is not registered (through RegisterMessage())
-	*/
-	void SendData(boost::shared_ptr&lt;const RawPacket&gt; data);
-	void SendData(const RawPacket* const data)
-	{
-		SendData(boost::shared_ptr&lt;const RawPacket&gt;(data));
-	};
-
-	/**
-	@brief Send data to one client in particular
-	@param data The smart packet pointer
-	@throw network_error When playerNum is no valid connection ID
-	 */
-	void SendData(boost::shared_ptr&lt;const RawPacket&gt; data, const unsigned playerNum);
-	void SendData(const RawPacket* const data, const unsigned playerNum)
-	{
-		SendData(boost::shared_ptr&lt;const RawPacket&gt;(data), playerNum);
-	};
-	
-	/**
-	@brief send all waiting data
-	*/
-	void FlushNet();
-	void FlushNet(const unsigned connection);
-	
-	/** 
-	@brief Do this from time to time
-	
-	Updates the UDPlistener to recieve data from UDP and check for new connections. It also removes connections which are timed out.
-	*/
-	void Update();
-	
-	/// did someone tried to connect?
-	bool HasIncomingConnection() const;
-	
-	/// Receive data from first unbound connection to check if we allow him in our game
-	boost::shared_ptr&lt;const RawPacket&gt; GetData();
-	
-	/// everything seems fine, accept him
-	unsigned AcceptIncomingConnection(const unsigned wantedNumber=0);
-	
-	/// we dont want you in our game
-	void RejectIncomingConnection();
-	
-private:
-	typedef boost::shared_ptr&lt;CConnection&gt; connPtr;
-	typedef std::vector&lt; connPtr &gt; connVec;
-	
-	/**
-	@brief Insert your Connection here to become connected
-	@param newClient Connection to be inserted in the array
-	@param wantedNumber 
-	*/
-	unsigned InitNewConn(const connPtr&amp; newClient, const unsigned wantedNumber=0);
-	
-	/**
-	@brief Holds the UDPListener for networking
-	@todo make it more generic to allow for different protocols like TCP
-	*/
-	boost::scoped_ptr&lt;UDPListener&gt; udplistener;
-	
-	connPtr localConnBuf;
-	
-	/**
-	@brief All active connections
-	*/
-	connVec connections;
-};
-
-} // namespace netcode
-
-#endif /* NET_H */

Modified: branches/gml/rts/System/Net/ProtocolDef.h
===================================================================
--- branches/gml/rts/System/Net/ProtocolDef.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/ProtocolDef.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -16,7 +16,6 @@
 	int GetLength(unsigned char id) const;
 	unsigned IsComplete(const unsigned char* const buf, const unsigned bufLength) const;
 
-	unsigned UDP_MTU;
 private:
 	ProtocolDef();
 	ProtocolDef( const ProtocolDef&amp; );

Modified: branches/gml/rts/System/Net/Socket.cpp
===================================================================
--- branches/gml/rts/System/Net/Socket.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/Socket.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -4,11 +4,13 @@
 #include &lt;direct.h&gt;
 #include &lt;io.h&gt;
 #else
+#include &lt;poll.h&gt;
 #include &lt;fcntl.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;arpa/inet.h&gt;
 #include &lt;netdb.h&gt;
 #include &lt;netinet/in.h&gt;
+#include &lt;string.h&gt;
 #endif
 
 #include &quot;Exception.h&quot;
@@ -87,6 +89,33 @@
 	}
 }
 
+bool Socket::HasIncomingData(int timeout) const
+{
+#ifndef _WIN32
+	// linux has poll() which is faster and easier to use than select()
+	pollfd pd;
+	pd.fd = mySocket;
+	pd.events = POLLIN | POLLPRI;
+	const int ret = poll(&amp;pd, 1, timeout);
+#else
+	// Windows only provides poll() in Vista, so use select() here
+	fd_set pd;
+	FD_ZERO(&amp;pd);
+	FD_SET(mySocket, &amp;pd);
+	struct timeval tv;
+	tv.tv_sec = 0;
+	tv.tv_usec = timeout;
+	const int ret = select(mySocket+1, &amp;pd, 0, 0, &amp;tv);
+#endif
+	
+	if (ret &gt; 0)
+		return true;
+	else if (ret == 0)
+		return false;
+	else
+		throw network_error(std::string(&quot;Poll for data failed: &quot;) + GetErrorMsg());
+}
+
 void Socket::Bind(unsigned short port) const
 {
 	sockaddr_in myAddr;

Modified: branches/gml/rts/System/Net/Socket.h
===================================================================
--- branches/gml/rts/System/Net/Socket.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/Socket.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -36,6 +36,13 @@
 	/// Set the blocking state of the socket
 	void SetBlocking(const bool block) const;
 	
+	/**
+	@brief wait for incoming data
+	@param timeout if there is no data to read, this call blocks for x miliseconds
+	@return Wheter there is any data to read
+	**/
+	bool HasIncomingData(int timeout) const;
+	
 	void Bind(unsigned short port /** in host byte order */) const;
 	
 	/**

Modified: branches/gml/rts/System/Net/UDPConnection.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/UDPConnection.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -21,12 +21,14 @@
 
 UDPConnection::UDPConnection(boost::shared_ptr&lt;UDPSocket&gt; NetSocket, const sockaddr_in&amp; MyAddr) : mySocket(NetSocket)
 {
+	sharedSocket = true;
 	addr = MyAddr;
 	Init();
 }
 
 UDPConnection::UDPConnection(boost::shared_ptr&lt;UDPSocket&gt; NetSocket, const std::string&amp; address, const unsigned port) : mySocket(NetSocket)
 {
+	sharedSocket = false;
 	addr = mySocket-&gt;ResolveHost(address, port);
 	Init();
 }
@@ -35,6 +37,7 @@
 {
 	if (fragmentBuffer)
 		delete fragmentBuffer;
+	Flush(true);
 }
 
 void UDPConnection::SendData(boost::shared_ptr&lt;const RawPacket&gt; data)
@@ -46,6 +49,11 @@
 	outgoingLength += data-&gt;length;
 }
 
+bool UDPConnection::HasIncomingData() const
+{
+	return !msgQueue.empty();
+}
+
 boost::shared_ptr&lt;const RawPacket&gt; UDPConnection::Peek(unsigned ahead) const
 {
 	if (ahead &lt; msgQueue.size())
@@ -74,6 +82,21 @@
 
 void UDPConnection::Update()
 {
+	if (!sharedSocket)
+	{
+		unsigned recv = 0;
+		unsigned char buffer[4096];
+		sockaddr_in fromAddr;
+		while ((recv = mySocket-&gt;RecvFrom(buffer, 4096, &amp;fromAddr)) &gt;= hsize)
+		{
+			RawPacket* data = new RawPacket(buffer, recv);
+			if (CheckAddress(fromAddr))
+				ProcessRawPacket(data);
+			else
+				; // silently drop
+		}
+	}
+	
 	const unsigned curTime = SDL_GetTicks();
 	bool force = false;	// should we force to send a packet?
 
@@ -231,25 +254,24 @@
 	const float curTime = SDL_GetTicks();
 	if (forced || (outgoingLength&gt;0 &amp;&amp; (lastSendTime &lt; (curTime - 200 + outgoingLength * 10))))
 	{
-		ProtocolDef* proto = ProtocolDef::instance();
 		lastSendTime=SDL_GetTicks();
 
 		// Manually fragment packets to respect configured UDP_MTU.
 		// This is an attempt to fix the bug where players drop out of the game if
 		// someone in the game gives a large order.
 
-		if (outgoingLength &gt; proto-&gt;UDP_MTU)
+		if (outgoingLength &gt; mtu)
 			++fragmentedFlushes;
 
 		unsigned pos = 0;
 		do
 		{
-			unsigned length = std::min(proto-&gt;UDP_MTU, outgoingLength);
+			unsigned length = std::min(mtu, outgoingLength);
 			SendRawPacket(outgoingData + pos, length, currentNum++);
 			unackedPackets.push_back(new RawPacket(outgoingData + pos, length));
 			outgoingLength -= length;
-			pos += proto-&gt;UDP_MTU;
-		} while (outgoingLength != 0);
+			pos += mtu;
+		} while (outgoingLength &gt; 0);
 	}
 }
 
@@ -299,6 +321,12 @@
 		return false;
 }
 
+void UDPConnection::SetMTU(unsigned mtu2)
+{
+	if (mtu2 &gt; 20 &amp;&amp; mtu2 &lt; 4096)
+		mtu = mtu2;
+}
+
 void UDPConnection::Init()
 {
 	lastReceiveTime = SDL_GetTicks();
@@ -317,6 +345,7 @@
 	resentPackets = 0;
 	sentPackets = recvPackets = 0;
 	droppedPackets = 0;
+	mtu = 500;
 }
 
 void UDPConnection::AckPackets(const int nextAck)

Modified: branches/gml/rts/System/Net/UDPConnection.h
===================================================================
--- branches/gml/rts/System/Net/UDPConnection.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/UDPConnection.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -6,9 +6,9 @@
 #include &lt;boost/shared_ptr.hpp&gt;
 #include &lt;deque&gt;
 
-#include &quot;Connection.h&quot;
 #include &quot;UDPSocket.h&quot;
 #include &quot;RawPacket.h&quot;
+#include &quot;Connection.h&quot;
 
 namespace netcode {
 
@@ -37,6 +37,8 @@
 	*/
 	virtual void SendData(boost::shared_ptr&lt;const RawPacket&gt; data);
 
+	virtual bool HasIncomingData() const;
+
 	virtual boost::shared_ptr&lt;const RawPacket&gt; Peek(unsigned ahead) const;
 
 	/**
@@ -50,7 +52,7 @@
 	@brief update internals
 	Check for unack'd packets, timeout etc.
 	*/
-	void Update();
+	virtual void Update();
 	
 	/**
 	@brief strip and parse header data and add data to waitingPackets
@@ -68,6 +70,8 @@
 
 	/// do we have these address?
 	bool CheckAddress(const sockaddr_in&amp;) const;
+	
+	void SetMTU(unsigned mtu);
 
 	/// The size of the protocol-header (Packets smaller than this get rejected)
 	static const unsigned hsize;
@@ -86,6 +90,11 @@
 	/// address of the other end
 	sockaddr_in addr;
 
+	/// maximum size of packets to send
+	unsigned mtu;
+	
+	bool sharedSocket;
+
 	///outgoing stuff (pure data without header) waiting to be sended
 	unsigned char outgoingData[UDPBufferSize];
 	unsigned outgoingLength;

Modified: branches/gml/rts/System/Net/UDPListener.cpp
===================================================================
--- branches/gml/rts/System/Net/UDPListener.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/UDPListener.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -97,6 +97,11 @@
 	return !waiting.empty();
 }
 
+bool UDPListener::HasIncomingData(int timeout)
+{
+	return mySocket-&gt;HasIncomingData(timeout);
+}
+
 boost::weak_ptr&lt;UDPConnection&gt; UDPListener::PreviewConnection()
 {
 	return waiting.front();

Modified: branches/gml/rts/System/Net/UDPListener.h
===================================================================
--- branches/gml/rts/System/Net/UDPListener.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Net/UDPListener.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -51,11 +51,11 @@
 	bool Listen() const;
 	
 	bool HasIncomingConnections() const;
+	bool HasIncomingData(int timeout);
 	boost::weak_ptr&lt;UDPConnection&gt; PreviewConnection();
 	boost::shared_ptr&lt;UDPConnection&gt; AcceptConnection();
 	void RejectConnection();
 	
-	
 private:
 	/**
 	@brief Do we accept packets from unknown sources?

Modified: branches/gml/rts/System/NetProtocol.cpp
===================================================================
--- branches/gml/rts/System/NetProtocol.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/NetProtocol.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,70 +1,78 @@
 #include &quot;NetProtocol.h&quot;
 
 #include &lt;SDL_timer.h&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
 
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;DemoRecorder.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
+#include &quot;Net/UDPConnection.h&quot;
+#include &quot;Net/LocalConnection.h&quot;
+#include &quot;Net/UDPSocket.h&quot;
 
 
 CNetProtocol::CNetProtocol()
 {
-	serverSlot = 0;
-	record = 0;
 	localDemoPlayback = false;
 }
 
 CNetProtocol::~CNetProtocol()
 {
-	if (record != 0)
-		delete record;
-	
-	if (IsActiveConnection())
-		logOutput.Print(GetConnectionStatistics(serverSlot));
+	Send(CBaseNetProtocol::Get().SendQuit());
+	logOutput.Print(server-&gt;Statistics());
 }
 
-void CNetProtocol::InitClient(const char *server, unsigned portnum,unsigned sourceport, const unsigned wantedNumber)
+void CNetProtocol::InitClient(const char *server_addr, unsigned portnum,unsigned sourceport, const unsigned wantedNumber)
 {
-	unsigned myNum = CNet::InitClient(server, portnum, sourceport,wantedNumber);
-	Listening(false);
-	SendAttemptConnect(myNum, NETWORK_VERSION);
-	FlushNet();
+	boost::shared_ptr&lt;netcode::UDPSocket&gt; sock(new netcode::UDPSocket(sourceport));
+	sock-&gt;SetBlocking(false);
+	netcode::UDPConnection* conn = new netcode::UDPConnection(sock, server_addr, portnum);
+	conn-&gt;SetMTU(configHandler.GetInt(&quot;MaximumTransmissionUnit&quot;, 0));
+	server.reset(conn);
+	server-&gt;SendData(CBaseNetProtocol::Get().SendAttemptConnect(wantedNumber, NETWORK_VERSION));
+	server-&gt;Flush(true);
+	isLocal = false;
 
 	if (!gameSetup || !gameSetup-&gt;hostDemo)	//TODO do we really want this?
 	{
-		record = new CDemoRecorder();
+		record.reset(new CDemoRecorder());
 	}
 	
-	logOutput.Print(&quot;Connected to %s:%i using number %i&quot;, server, portnum, myNum);
-
-	serverSlot = myNum;
+	logOutput.Print(&quot;Connecting to %s:%i using number %i&quot;, server_addr, portnum, wantedNumber);
 }
 
 void CNetProtocol::InitLocalClient(const unsigned wantedNumber)
 {
+	server.reset(new netcode::CLocalConnection);
+	server-&gt;Flush();
+	isLocal = true;
 	if (!localDemoPlayback)
 	{
-		record = new CDemoRecorder();
+		record.reset(new CDemoRecorder());
 	}
+	
+	logOutput.Print(&quot;Connecting to local server using number %i&quot;, wantedNumber);
+}
 
-	unsigned myNum = CNet::InitLocalClient(wantedNumber);
-	SendAttemptConnect(myNum, NETWORK_VERSION);
-	serverSlot = myNum;
+bool CNetProtocol::Active() const
+{
+	return !server-&gt;CheckTimeout();
 }
 
-bool CNetProtocol::IsActiveConnection() const
+bool CNetProtocol::Connected() const
 {
-	return CNet::IsActiveConnection(serverSlot);
+	return (server-&gt;GetDataReceived() &gt; 0);
 }
 
 boost::shared_ptr&lt;const netcode::RawPacket&gt; CNetProtocol::Peek(unsigned ahead) const
 {
-	return CNet::Peek(serverSlot, ahead);
+	return server-&gt;Peek(ahead);
 }
 
 boost::shared_ptr&lt;const netcode::RawPacket&gt; CNetProtocol::GetData()
 {
-	boost::shared_ptr&lt;const netcode::RawPacket&gt; ret = CNet::GetData(serverSlot);
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; ret = server-&gt;GetData();
 	
 	if (record &amp;&amp; ret)
 		record-&gt;SaveToDemo(ret-&gt;data, ret-&gt;length);
@@ -72,6 +80,17 @@
 	return ret;
 }
 
+void CNetProtocol::Send(boost::shared_ptr&lt;const netcode::RawPacket&gt; pkt)
+{
+	server-&gt;SendData(pkt);
+}
+
+void CNetProtocol::Send(const netcode::RawPacket* pkt)
+{
+	boost::shared_ptr&lt;const netcode::RawPacket&gt; ptr(pkt);
+	Send(ptr);
+}
+
 void CNetProtocol::UpdateLoop()
 {
 	loading = true;
@@ -82,4 +101,9 @@
 	}
 }
 
+void CNetProtocol::Update()
+{
+	server-&gt;Update();
+}
+
 CNetProtocol* net=0;

Modified: branches/gml/rts/System/NetProtocol.h
===================================================================
--- branches/gml/rts/System/NetProtocol.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/NetProtocol.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,16 +1,24 @@
 #ifndef NETPROTOCOL_H
 #define NETPROTOCOL_H
 
+#include &lt;boost/scoped_ptr.hpp&gt;
+#include &lt;boost/shared_ptr.hpp&gt;
+
 #include &quot;BaseNetProtocol.h&quot;
 
 class CDemoRecorder;
+namespace netcode
+{
+	class RawPacket;
+	class CConnection;
+};
 
 /**
 @brief Even higher level network code layer
 
 The top of the networking stack.
 */
-class CNetProtocol : public CBaseNetProtocol
+class CNetProtocol
 {
 public:
 	CNetProtocol();
@@ -26,7 +34,8 @@
 	 */
 	void InitLocalClient(const unsigned wantedNumber);
 
-	bool IsActiveConnection() const;
+	bool Active() const;
+	bool Connected() const;
 
 	bool localDemoPlayback;
 
@@ -47,16 +56,20 @@
 	 */
 	boost::shared_ptr&lt;const netcode::RawPacket&gt; GetData();
 	
-	CDemoRecorder* GetDemoRecorder() const { return record; }
+	void Send(boost::shared_ptr&lt;const netcode::RawPacket&gt; pkt);
+	void Send(const netcode::RawPacket* pkt);
+	
+	CDemoRecorder* GetDemoRecorder() const { return record.get(); }
 
 	/// updates our network while the game loads to prevent timeouts
 	void UpdateLoop();
+	void Update();
 	volatile bool loading;
 
 private:
-	/// the connection number used for communicating with the server
-	unsigned serverSlot;
-	CDemoRecorder* record;
+	bool isLocal;
+	boost::scoped_ptr&lt;netcode::CConnection&gt; server;
+	boost::scoped_ptr&lt;CDemoRecorder&gt; record;
 };
 
 extern CNetProtocol* net;

Modified: branches/gml/rts/System/Platform/Linux/DataDirLocater.cpp
===================================================================
--- branches/gml/rts/System/Platform/Linux/DataDirLocater.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Platform/Linux/DataDirLocater.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -9,6 +9,7 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;DataDirLocater.h&quot;
 #include &lt;sstream&gt;
+#include &lt;string.h&gt;
 #include &quot;System/FileSystem/VFSHandler.h&quot;
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;

Modified: branches/gml/rts/System/Platform/Linux/DotfileHandler.cpp
===================================================================
--- branches/gml/rts/System/Platform/Linux/DotfileHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Platform/Linux/DotfileHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -15,6 +15,7 @@
 #include &lt;fcntl.h&gt;
 #include &lt;math.h&gt;
 #include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
 #include &quot;Game/GameVersion.h&quot;
 
 

Modified: branches/gml/rts/System/Platform/Linux/PosixCmd.cpp
===================================================================
--- branches/gml/rts/System/Platform/Linux/PosixCmd.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Platform/Linux/PosixCmd.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -9,6 +9,7 @@
  */
 #include &quot;PosixCmd.h&quot;
 
+#include &lt;stdlib.h&gt;
 
 /**
  * Just stores the arguments and calls the parent class's

Modified: branches/gml/rts/System/Platform/Linux/UnixFileSystemHandler.cpp
===================================================================
--- branches/gml/rts/System/Platform/Linux/UnixFileSystemHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Platform/Linux/UnixFileSystemHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -43,12 +43,17 @@
 	const std::vector&lt;DataDir&gt;&amp; datadirs = locater.GetDataDirs();
 
 	archiveScanner = new CArchiveScanner();
+
 	archiveScanner-&gt;ReadCacheData(writedir-&gt;path + archiveScanner-&gt;GetFilename());
+
+	std::vector&lt;std::string&gt; scanDirs;
 	for (std::vector&lt;DataDir&gt;::const_reverse_iterator d = datadirs.rbegin(); d != datadirs.rend(); ++d) {
-		archiveScanner-&gt;Scan(d-&gt;path + &quot;maps&quot;, true);
-		archiveScanner-&gt;Scan(d-&gt;path + &quot;base&quot;, true);
-		archiveScanner-&gt;Scan(d-&gt;path + &quot;mods&quot;, true);
+		scanDirs.push_back(d-&gt;path + &quot;maps&quot;);
+		scanDirs.push_back(d-&gt;path + &quot;base&quot;);
+		scanDirs.push_back(d-&gt;path + &quot;mods&quot;);
 	}
+	archiveScanner-&gt;ScanDirs(scanDirs, true);
+
 	archiveScanner-&gt;WriteCacheData(writedir-&gt;path + archiveScanner-&gt;GetFilename());
 
 	hpiHandler = new CVFSHandler();

Modified: branches/gml/rts/System/Platform/Win/WinFileSystemHandler.cpp
===================================================================
--- branches/gml/rts/System/Platform/Win/WinFileSystemHandler.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Platform/Win/WinFileSystemHandler.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -36,9 +36,11 @@
 	// Create the archive scanner and vfs handler
 	archiveScanner = new CArchiveScanner();
 	archiveScanner-&gt;ReadCacheData(archiveScanner-&gt;GetFilename());
-	archiveScanner-&gt;Scan(&quot;./maps&quot;, true);
-	archiveScanner-&gt;Scan(&quot;./base&quot;, true);
-	archiveScanner-&gt;Scan(&quot;./mods&quot;, true);
+	std::vector&lt;std::string&gt; scanDirs;
+	scanDirs.push_back(&quot;./maps&quot;);
+	scanDirs.push_back(&quot;./base&quot;);
+	scanDirs.push_back(&quot;./mods&quot;);
+	archiveScanner-&gt;ScanDirs(scanDirs, true);
 	archiveScanner-&gt;WriteCacheData(archiveScanner-&gt;GetFilename());
 	hpiHandler = new CVFSHandler();
 }

Modified: branches/gml/rts/System/Script/LuaFunctions.cpp
===================================================================
--- branches/gml/rts/System/Script/LuaFunctions.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/Script/LuaFunctions.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -7,7 +7,6 @@
 #include &quot;GlobalStuff.h&quot;
 #include &quot;float3.h&quot;
 #include &quot;LogOutput.h&quot;
-#include &quot;TdfParser.h&quot;
 #include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
 #include &quot;Game/Game.h&quot;
@@ -15,7 +14,7 @@
 #include &quot;Game/StartScripts/Script.h&quot;
 #include &quot;Game/UI/EndGameBox.h&quot;
 #include &quot;Lua/LuaCallInHandler.h&quot;
-#include &quot;Map/MapInfo.h&quot;
+#include &quot;Map/MapParser.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
 #include &quot;Sim/Features/FeatureHandler.h&quot;
@@ -179,6 +178,6 @@
 
 	string MapGetTDFName()
 	{
-		return CMapInfo::GetTDFName(stupidGlobalMapname);
+		return MapParser::GetMapConfigName(stupidGlobalMapname);
 	}
 }

Modified: branches/gml/rts/System/StdAfx.h
===================================================================
--- branches/gml/rts/System/StdAfx.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/System/StdAfx.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -77,27 +77,36 @@
 
 /**
  * content_error
- * thrown when content couldn't be found/loaded.
- * any other type of exception will cause a crashreport box appearing (if it is installed).
+ *   thrown when content couldn't be found/loaded.
+ *   any other type of exception will cause a crashreport box appearing
+ *     (if it is installed).
  */
 class content_error : public std::runtime_error
 {
-public:
-	content_error(const std::string&amp; msg) :
-	  std::runtime_error(msg) {}
+	public:
+		content_error(const std::string&amp; msg) : std::runtime_error(msg) {}
 };
 
-static inline void
-StringToLowerInPlace(std::string &amp;s)
+
+static inline void StringToLowerInPlace(std::string &amp;s)
 {
-	std::transform (s.begin(), s.end(), s.begin(), (int (*)(int))tolower);
+	std::transform(s.begin(), s.end(), s.begin(), (int (*)(int))tolower);
 }
 
-static inline std::string
-StringToLower(std::string s)
+
+static inline std::string StringToLower(std::string s)
 {
 	StringToLowerInPlace(s);
 	return s;
 }
 
+
+static inline std::string IntToString(int i, const std::string&amp; format = &quot;%i&quot;)
+{
+	char buf[64];
+	SNPRINTF(buf, sizeof(buf), format.c_str(), i);
+	return std::string(buf);
+}
+
+
 #endif // __STD_AFX_H__

Deleted: branches/gml/rts/build/cmake/FindBoost.cmake
===================================================================
--- branches/gml/rts/build/cmake/FindBoost.cmake	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/build/cmake/FindBoost.cmake	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1,168 +0,0 @@
-# copied from KDE svn sources
-
-# - Find the Boost includes and libraries.
-# The following variables are set if Boost is found.  If Boost is not
-# found, Boost_FOUND is set to false.
-#  Boost_FOUND        - True when the Boost include directory is found.
-#  Boost_INCLUDE_DIRS - the path to where the boost include files are.
-#  Boost_LIBRARY_DIRS - The path to where the boost library files are.
-#  Boost_LIB_DIAGNOSTIC_DEFINITIONS - Only set if using Windows.
-
-# !!!!!!!!!!!!!!!!!!!
-# this is FindBoost.cmake from cmake 2.4.4 to 2.4.8
-# it is here because the one in 2.6.0RC9 is slightly broken
-# and will be removed again once 2.6.0 or 2.6.0RC10 is released
-# Alex
-# !!!!!!!!!!!!!!!!!!!!!!
-
-# ----------------------------------------------------------------------------
-# If you have installed Boost in a non-standard location or you have
-# just staged the boost files using bjam then you have three
-# options. In the following comments, it is assumed that &lt;Your Path&gt;
-# points to the root directory of the include directory of Boost. e.g
-# If you have put boost in C:\development\Boost then &lt;Your Path&gt; is
-# &quot;C:/development/Boost&quot; and in this directory there will be two
-# directories called &quot;include&quot; and &quot;lib&quot;.
-# 1) After CMake runs, set Boost_INCLUDE_DIR to &lt;Your Path&gt;/include/boost&lt;-version&gt;
-# 2) Use CMAKE_INCLUDE_PATH to set a path to &lt;Your Path&gt;/include. This will allow FIND_PATH()
-#    to locate Boost_INCLUDE_DIR by utilizing the PATH_SUFFIXES option. e.g.
-#    SET(CMAKE_INCLUDE_PATH ${CMAKE_INCLUDE_PATH} &quot;&lt;Your Path&gt;/include&quot;)
-# 3) Set an environment variable called ${BOOST_ROOT} that points to the root of where you have
-#    installed Boost, e.g. &lt;Your Path&gt;. It is assumed that there is at least a subdirectory called
-#    include in this path.
-#
-# Note:
-#  1) If you are just using the boost headers, then you do not need to use
-#     Boost_LIBRARY_DIRS in your CMakeLists.txt file.
-#  2) If Boost has not been installed, then when setting Boost_LIBRARY_DIRS
-#     the script will look for /lib first and, if this fails, then for /stage/lib.
-#
-# Usage:
-# In your CMakeLists.txt file do something like this:
-# ...
-# # Boost
-# FIND_PACKAGE(Boost)
-# ...
-# INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})
-# LINK_DIRECTORIES(${Boost_LIBRARY_DIRS})
-#
-# In Windows, we make the assumption that, if the Boost files are installed, the default directory
-# will be C:\boost.
-
-#
-# TODO:
-#
-# 1) Automatically find the Boost library files and eliminate the need
-#    to use Link Directories.
-#
-
-IF(WIN32)
-  # In windows, automatic linking is performed, so you do not have to specify the libraries.
-  # If you are linking to a dynamic runtime, then you can choose to link to either a static or a
-  # dynamic Boost library, the default is to do a static link.  You can alter this for a specific
-  # library &quot;whatever&quot; by defining BOOST_WHATEVER_DYN_LINK to force Boost library &quot;whatever&quot; to
-  # be linked dynamically.  Alternatively you can force all Boost libraries to dynamic link by
-  # defining BOOST_ALL_DYN_LINK.
-
-  # This feature can be disabled for Boost library &quot;whatever&quot; by defining BOOST_WHATEVER_NO_LIB,
-  # or for all of Boost by defining BOOST_ALL_NO_LIB.
-
-  # If you want to observe which libraries are being linked against then defining
-  # BOOST_LIB_DIAGNOSTIC will cause the auto-linking code to emit a #pragma message each time
-  # a library is selected for linking.
-  SET(Boost_LIB_DIAGNOSTIC_DEFINITIONS &quot;-DBOOST_LIB_DIAGNOSTIC&quot;)
-ENDIF(WIN32)
-
-
-SET(BOOST_INCLUDE_PATH_DESCRIPTION &quot;directory containing the boost include files. E.g /usr/local/include/boost-1_33_1 or c:\\boost\\include\\boost-1_33_1&quot;)
-
-SET(BOOST_DIR_MESSAGE &quot;Set the Boost_INCLUDE_DIR cmake cache entry to the ${BOOST_INCLUDE_PATH_DESCRIPTION}&quot;)
-
-SET(BOOST_DIR_SEARCH $ENV{BOOST_ROOT})
-IF(BOOST_DIR_SEARCH)
-  FILE(TO_CMAKE_PATH ${BOOST_DIR_SEARCH} BOOST_DIR_SEARCH)
-  SET(BOOST_DIR_SEARCH ${BOOST_DIR_SEARCH}/include)
-ENDIF(BOOST_DIR_SEARCH)
-
-IF(WIN32)
-  SET(BOOST_DIR_SEARCH
-    ${BOOST_DIR_SEARCH}
-    C:/boost/include
-    D:/boost/include
-  )
-ENDIF(WIN32)
-
-# Add in some path suffixes. These will have to be updated whenever a new Boost version comes out.
-SET(SUFFIX_FOR_PATH
- boost-1_34_1
- boost-1_34_0
- boost-1_34
- boost-1_33_1
- boost-1_33_0
- boost-1_33
-)
-
-#
-# Look for an installation.
-#
-FIND_PATH(Boost_INCLUDE_DIR NAMES boost/config.hpp PATH_SUFFIXES ${SUFFIX_FOR_PATH} PATHS
-
-  # Look in other places.
-  ${BOOST_DIR_SEARCH}
-
-  # Help the user find it if we cannot.
-  DOC &quot;The ${BOOST_INCLUDE_PATH_DESCRIPTION}&quot;
-)
-
-# Assume we didn't find it.
-SET(Boost_FOUND 0)
-
-# Now try to get the include and library path.
-IF(Boost_INCLUDE_DIR)
-
-  # Look for the boost library path.
-  # Note that the user may not have installed any libraries
-  # so it is quite possible the Boost_LIBRARY_PATH may not exist.
-  SET(Boost_LIBRARY_DIR ${Boost_INCLUDE_DIR})
-
-  IF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;boost-[0-9]+&quot;)
-    GET_FILENAME_COMPONENT(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR} PATH)
-  ENDIF (&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;boost-[0-9]+&quot;)
-
-  IF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;/include$&quot;)
-    # Strip off the trailing &quot;/include&quot; in the path.
-    GET_FILENAME_COMPONENT(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR} PATH)
-  ENDIF(&quot;${Boost_LIBRARY_DIR}&quot; MATCHES &quot;/include$&quot;)
-
-  IF(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
-    SET (Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR}/lib)
-  ELSE(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
-    IF(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
-      SET(Boost_LIBRARY_DIR ${Boost_LIBRARY_DIR}/stage/lib)
-    ELSE(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
-      SET(Boost_LIBRARY_DIR &quot;&quot;)
-    ENDIF(EXISTS &quot;${Boost_LIBRARY_DIR}/stage/lib&quot;)
-  ENDIF(EXISTS &quot;${Boost_LIBRARY_DIR}/lib&quot;)
-
-  IF(EXISTS &quot;${Boost_INCLUDE_DIR}&quot;)
-    SET(Boost_INCLUDE_DIRS ${Boost_INCLUDE_DIR})
-    # We have found boost. It is possible that the user has not
-    # compiled any libraries so we set Boost_FOUND to be true here.
-    SET(Boost_FOUND 1)
-  ENDIF(EXISTS &quot;${Boost_INCLUDE_DIR}&quot;)
-
-  IF(Boost_LIBRARY_DIR AND EXISTS &quot;${Boost_LIBRARY_DIR}&quot;)
-    SET(Boost_LIBRARY_DIRS ${Boost_LIBRARY_DIR})
-  ENDIF(Boost_LIBRARY_DIR AND EXISTS &quot;${Boost_LIBRARY_DIR}&quot;)
-ENDIF(Boost_INCLUDE_DIR)
-
-IF(NOT Boost_FOUND)
-  IF(NOT Boost_FIND_QUIETLY)
-    MESSAGE(STATUS &quot;Boost was not found. ${BOOST_DIR_MESSAGE}&quot;)
-  ELSE(NOT Boost_FIND_QUIETLY)
-    IF(Boost_FIND_REQUIRED)
-      MESSAGE(FATAL_ERROR &quot;Boost was not found. ${BOOST_DIR_MESSAGE}&quot;)
-    ENDIF(Boost_FIND_REQUIRED)
-  ENDIF(NOT Boost_FIND_QUIETLY)
-ENDIF(NOT Boost_FOUND)
-

Modified: branches/gml/rts/build/cmake/FindWin32Libs.cmake
===================================================================
--- branches/gml/rts/build/cmake/FindWin32Libs.cmake	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/build/cmake/FindWin32Libs.cmake	2008-06-14 22:06:38 UTC (rev 6030)
@@ -55,14 +55,6 @@
 	ENDIF(NOT WS2_32_LIBRARY)
 ENDIF(NOT WS2_32_LIBRARY)
 
-IF(NOT GDI32_LIBRARY)
-	FIND_LIBRARY(GDI32_LIBRARY gdi32 PATHS ${WIN32_LIBRARY_SEARCHPATHS})
-	IF(NOT GDI32_LIBRARY)
-		MESSAGE(SEND_ERROR &quot;Could not find win32 GDI32 library.&quot;)
-		SET(WIN32_FOUND FALSE)
-	ENDIF(NOT GDI32_LIBRARY)
-ENDIF(NOT GDI32_LIBRARY)
-
 IF(NOT WINMM_LIBRARY)
 	FIND_LIBRARY(WINMM_LIBRARY winmm PATHS ${WIN32_LIBRARY_SEARCHPATHS})
 	IF(NOT WINMM_LIBRARY)
@@ -77,7 +69,6 @@
 		${DSOUND_LIBRARY}   # for System/Platform/Win/DxSound.cpp
 		${OLE32_LIBRARY}    # for System/Platform/Win/DxSound.cpp
 		${WS2_32_LIBRARY}	  # for System/Net/
-		#${GDI32_LIBRARY}    # FIXME: possibly for AVI recording?
 		${WINMM_LIBRARY}
 	)
 
@@ -89,6 +80,5 @@
 	DSOUND_LIBRARY
 	OLE32_LIBRARY
 	WS2_32_LIBRARY
-	GDI32_LIBRARY
 	WINMM_LIBRARY
 ) 

Modified: branches/gml/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/gml/rts/build/vstudio8/rts.vcproj	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/build/vstudio8/rts.vcproj	2008-06-14 22:06:38 UTC (rev 6030)
@@ -254,7 +254,7 @@
 			&lt;Tool
 				Name=&quot;VCLinkerTool&quot;
 				AdditionalDependencies=&quot;dsound.lib freetype2110.lib zlibwapi.lib glew32s.lib opengl32.lib glu32.lib ogg.lib vorbis.lib vorbisfile.lib SDL.lib DevIL.lib winmm.lib wsock32.lib ilu.lib imagehlp.lib advapi32.lib ole32.lib&quot;
-				OutputFile=&quot;d:/program files/spring/springdev.exe&quot;
+				OutputFile=&quot;../../../game/spring.exe&quot;
 				LinkIncremental=&quot;1&quot;
 				SuppressStartupBanner=&quot;true&quot;
 				AdditionalLibraryDirectories=&quot;../../../vclibs/DevIL/lib;&quot;../../../vclibs/freetype-2.1.10/objs&quot;;../../../vclibs/OpenAL/libs;../../../vclibs/glew/lib;../../../vclibs/zlibwapi/lib;&quot;../../../vclibs/SDL-1.2.9/lib&quot;;../../../vclibs/boost/lib;../../../vclibs/libjpeg;../../../vclibs/ogg_vorbis/lib&quot;
@@ -1031,14 +1031,6 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Game\Ui\OutlineFont.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Game\Ui\OutlineFont.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
 					RelativePath=&quot;..\..\Game\UI\ProfileDrawer.cpp&quot;
 					&gt;
 					&lt;FileConfiguration
@@ -3067,14 +3059,6 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\Sim\Misc\SensorHandler.cpp&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\Sim\Misc\SensorHandler.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
 					RelativePath=&quot;..\..\Sim\Misc\Wind.cpp&quot;
 					&gt;
 				&lt;/File&gt;
@@ -5287,54 +5271,6 @@
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;..\..\System\Net\Net.cpp&quot;
-					&gt;
-					&lt;FileConfiguration
-						Name=&quot;Debug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-							ObjectFile=&quot;$(IntDir)\$(InputName)1.obj&quot;
-							XMLDocumentationFileName=&quot;$(IntDir)\$(InputName)1.xdc&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;No debug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-							ObjectFile=&quot;$(IntDir)\$(InputName)1.obj&quot;
-							XMLDocumentationFileName=&quot;$(IntDir)\$(InputName)1.xdc&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;Release with error catching|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-							ObjectFile=&quot;$(IntDir)\$(InputName)1.obj&quot;
-							XMLDocumentationFileName=&quot;$(IntDir)\$(InputName)1.xdc&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-					&lt;FileConfiguration
-						Name=&quot;Syncdebug|Win32&quot;
-						&gt;
-						&lt;Tool
-							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;0&quot;
-							ObjectFile=&quot;$(IntDir)\$(InputName)1.obj&quot;
-							XMLDocumentationFileName=&quot;$(IntDir)\$(InputName)1.xdc&quot;
-						/&gt;
-					&lt;/FileConfiguration&gt;
-				&lt;/File&gt;
-				&lt;File
-					RelativePath=&quot;..\..\System\Net\Net.h&quot;
-					&gt;
-				&lt;/File&gt;
-				&lt;File
 					RelativePath=&quot;..\..\System\Net\PackPacket.cpp&quot;
 					&gt;
 					&lt;FileConfiguration
@@ -5796,6 +5732,14 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;..\..\Map\MapParser.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;..\..\Map\MapParser.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;..\..\Map\MetalMap.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Modified: branches/gml/rts/lib/CMakeLists.txt
===================================================================
--- branches/gml/rts/lib/CMakeLists.txt	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/CMakeLists.txt	2008-06-14 22:06:38 UTC (rev 6030)
@@ -8,6 +8,7 @@
 ADD_LIBRARY(luabind STATIC ${luabindfiles})
 TARGET_LINK_LIBRARIES(luabind lua)
 
+ADD_DEFINITIONS(-D_SZ_ONE_DIRECTORY)
 AUX_SOURCE_DIRECTORY(7zip 7zipfiles)
 ADD_LIBRARY(7zip STATIC ${7zipfiles})
 
@@ -15,11 +16,11 @@
 ADD_LIBRARY(hpiutil2 STATIC ${hpifiles})
 TARGET_LINK_LIBRARIES(hpiutil2 z)
 
-IF (NOT MINGW)
+IF (UNIX)
 	ADD_LIBRARY(minizip STATIC  minizip/unzip minizip/zip minizip/ioapi)
-ELSE (NOT MINGW)
+ELSE (UNIX)
 	ADD_LIBRARY(minizip STATIC  minizip/unzip minizip/zip minizip/iowin32 minizip/ioapi)
-ENDIF (NOT MINGW)
+ENDIF (UNIX)
 TARGET_LINK_LIBRARIES(minizip z)
 
 ADD_SUBDIRECTORY(streflop)
\ No newline at end of file

Modified: branches/gml/rts/lib/gml/gml.cpp
===================================================================
--- branches/gml/rts/lib/gml/gml.cpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/gml/gml.cpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -8,7 +8,7 @@
 
 // GML works by &quot;patching&quot; all OpenGL calls. It is injected via a #include &quot;gml.h&quot; statement located in myGL.h.
 // All files that need GL should therefore include myGL.h. INCLUDING gl.h, glu.h, glext.h ... IS FORBIDDEN.
-// When a client thead (gmlThreadNumber &gt; 0) executes a GL call, it is redirected into a queue.
+// When a client thread (gmlThreadNumber &gt; 0) executes a GL call, it is redirected into a queue.
 // The server thread (gmlThreadNumber = 0) will then consume GL calls from the queues of each thread.
 // When the server thread makes a GL call, it calls directly into OpenGL of course.
 
@@ -46,9 +46,8 @@
 #endif
 int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
 int gmlThreadCountOverride=0; // number of threads to use (can be manually overridden here)
+int gmlItemsConsumed=0;
 
-BOOL_ gmlExperimentalMode=false;
-
 // gmlCPUCount returns the number of CPU cores
 // it was taken from the latest version of boost
 // boost::thread::hardware_concurrency()
@@ -165,7 +164,8 @@
 EFPstride(0), EFPpointer(NULL), 
 IPtype(0), IPstride(0), IPpointer(NULL), 
 NPtype(0), NPstride(0), NPpointer(NULL), 
-TCPsize(0), TCPtype(0), TCPstride(0), TCPpointer(NULL) 
+TCPsize(0), TCPtype(0), TCPstride(0), TCPpointer(NULL),
+ArrayBuffer(0), ElementArrayBuffer(0), PixelPackBuffer(0),PixelUnpackBuffer(0)
 {
 	Queue1=(BYTE *)malloc(GML_INIT_QUEUE_SIZE*sizeof(BYTE));
 	Queue2=(BYTE *)malloc(GML_INIT_QUEUE_SIZE*sizeof(BYTE));
@@ -217,36 +217,50 @@
 	if(Write==NULL)
 		return;
 #if GML_ALTERNATE_SYNCMODE
+	if(WritePos==Write) {
+		*(int *)WritePos=0;
+		WritePos+=sizeof(int);
+	}
+
 	if(Write==Queue1) {
 		if(final) {
 			while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
 				boost::thread::yield();
+
+			if(WasSynced) {
+				Sync=WritePos;
+				while(Sync==WritePos)
+					boost::thread::yield();
+			}
 		}
+
 		Pos1=WritePos;
 		Locks1.Unlock();
 		Locked1=FALSE;
-		if(final &amp;&amp; WasSynced) {
-			Sync=WritePos;
-			while(Sync==WritePos)
-				boost::thread::yield();
-			WasSynced=FALSE;
-		}
 	}
 	else {
 		if(final) {
 			while(*(BYTE * volatile *)&amp;Pos1!=Queue1)
 				boost::thread::yield();
+
+			if(WasSynced) {
+				Sync=WritePos;
+				while(Sync==WritePos)
+					boost::thread::yield();
+			}
 		}
+
 		Pos2=WritePos;
 		Locks2.Unlock();
 		Locked2=FALSE;
-		if(final &amp;&amp; WasSynced) {
-			Sync=WritePos;
-			while(Sync==WritePos)
-				boost::thread::yield();
-			WasSynced=FALSE;
-		}
 	}
+
+	if(final &amp;&amp; WasSynced) {
+		while(Sync!=EXEC_RUN)
+			boost::thread::yield();
+		WasSynced=FALSE;
+	}
+
 #else
 	if(Write==Queue1) {
 		if(final) {
@@ -289,7 +303,7 @@
 		if(!Locked1 &amp;&amp; Pos1==Queue1) {
 			if(Locks1.Lock()) {
 				Locked1=TRUE;
-				ReleaseWrite(FALSE);
+				ReleaseWrite(critical==2);
 				WritePos=Write=Queue1;
 				WriteSize=Size1;
 				return TRUE;
@@ -298,7 +312,7 @@
 		if(!Locked2 &amp;&amp; Pos2==Queue2) {
 			if(Locks2.Lock()) {
 				Locked2=TRUE;
-				ReleaseWrite(FALSE);
+				ReleaseWrite(critical==2);
 				WritePos=Write=Queue2;
 				WriteSize=Size2;
 				return TRUE;
@@ -354,7 +368,7 @@
 
 void gmlQueue::SyncRequest() {
 #if GML_ALTERNATE_SYNCMODE
-        // make sure server is finished with other queue
+  // make sure server is finished with other queue
 	if(Write==Queue1) {
 		while(*(BYTE * volatile *)&amp;Pos2!=Queue2)
 			boost::thread::yield();
@@ -368,6 +382,7 @@
 	Sync=EXEC_SYNC;
 	while(Sync==EXEC_SYNC) // wait for syncmode confirmation before release
 		boost::thread::yield();
+
 	GetWrite(TRUE); // get new queue so server can get the old one
 	while(Sync!=EXEC_RES) // waiting for result
 		boost::thread::yield();
@@ -469,17 +484,17 @@
         break;
 //glTexImage1D
 #define GML_MAKEHANDLER8S(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)+1);\
+  gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H?((BYTE *)(((gml##name##Data *)p)-&gt;H))-1:(BYTE *)(((gml##name##Data *)p)+1));\
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //glTexImage2D
 #define GML_MAKEHANDLER9S(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)+1);\
+  gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I?((BYTE *)(((gml##name##Data *)p)-&gt;I))-1:(BYTE *)(((gml##name##Data *)p)+1));\
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //glTexImage3D
 #define GML_MAKEHANDLER10S(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I,((gml##name##Data *)p)+1);\
+  gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;I,((gml##name##Data *)p)-&gt;J?((BYTE *)(((gml##name##Data *)p)-&gt;J))-1:(BYTE *)(((gml##name##Data *)p)+1));\
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //glColor4fv
@@ -511,7 +526,7 @@
 #define GML_MAKEHANDLER4VSS(name,type) case gml##name##Enum:\
 	ptr=(BYTE *)((gml##name##Data *)p)+((gml##name##Data *)p)-&gt;lensize;\
 	for(int i=0; i&lt;((gml##name##Data *)p)-&gt;B; ++i) {\
-		GLint j=((GLint *)&amp;((gml##name##Data *)p)-&gt;C)[i];\
+		GLint j=((intptr_t *)&amp;((gml##name##Data *)p)-&gt;C)[i];\
 		(&amp;((gml##name##Data *)p)-&gt;C)[i]=(type *)ptr;\
 		ptr+=j;\
 	}\
@@ -519,18 +534,18 @@
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //glCompressedTexImage1DARB
-#define GML_MAKEHANDLER7V(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,(&amp;((gml##name##Data *)p)-&gt;G));\
+#define GML_MAKEHANDLER7VP(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;GP?((gml##name##Data *)p)-&gt;GP-1:(&amp;((gml##name##Data *)p)-&gt;G));\
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //glCompressedTexImage2DARB
-#define GML_MAKEHANDLER8V(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,(&amp;((gml##name##Data *)p)-&gt;H));\
+#define GML_MAKEHANDLER8VP(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;HP?((gml##name##Data *)p)-&gt;HP-1:(&amp;((gml##name##Data *)p)-&gt;H));\
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //glCompressedTexImage3DARB
-#define GML_MAKEHANDLER9V(name) case gml##name##Enum:\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,(&amp;((gml##name##Data *)p)-&gt;I));\
+#define GML_MAKEHANDLER9VP(name) case gml##name##Enum:\
+	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)-&gt;D,((gml##name##Data *)p)-&gt;E,((gml##name##Data *)p)-&gt;F,((gml##name##Data *)p)-&gt;G,((gml##name##Data *)p)-&gt;H,((gml##name##Data *)p)-&gt;IP?((gml##name##Data *)p)-&gt;IP-1:(&amp;((gml##name##Data *)p)-&gt;I));\
         p+=((gml##name##Data *)p)-&gt;size;\
         break;
 //gluBuild2DMipmaps
@@ -541,25 +556,25 @@
 //glLight
 #define GMLMAKESUBHANDLER2(flag,fun,arg,name)\
 	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
- 	  fun(0,ptr);\
+ 	  fun(0,(((gml##name##Data *)p)-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)?((gml##name##Data *)p)-&gt;arg##pointer:ptr);\
 	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
 	}
 #define GMLMAKESUBHANDLER3(flag,fun,arg,name)\
 	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
- 	  fun(((gml##name##Data *)p)-&gt;arg##type,0,ptr);\
+ 	  fun(((gml##name##Data *)p)-&gt;arg##type,0,(((gml##name##Data *)p)-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)?((gml##name##Data *)p)-&gt;arg##pointer:ptr);\
 	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
 	}
 #define GMLMAKESUBHANDLER4(flag,fun,arg,name)\
 	if(((gml##name##Data *)p)-&gt;ClientState &amp; (1&lt;&lt;(flag-GL_VERTEX_ARRAY))) {\
- 	  fun(((gml##name##Data *)p)-&gt;arg##size,((gml##name##Data *)p)-&gt;arg##type,0,ptr);\
+ 	  fun(((gml##name##Data *)p)-&gt;arg##size,((gml##name##Data *)p)-&gt;arg##type,0,(((gml##name##Data *)p)-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)?((gml##name##Data *)p)-&gt;arg##pointer:ptr);\
 	  ptr+=((gml##name##Data *)p)-&gt;arg##totalsize;\
 	}
 #define GMLMAKESUBHANDLERVA(name)\
-	for(int i=0; i&lt;((gml##name##Data *)p)-&gt;VAcount; ++i) {\
-	  VAstruct *va=(VAstruct *)ptr;\
- 	  glVertexAttribPointer(va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,ptr+sizeof(VAstruct));\
-	  ptr+=va-&gt;totalsize;\
-	}
+  for(int i=0; i&lt;((gml##name##Data *)p)-&gt;VAcount; ++i) {\
+    VAstruct *va=(VAstruct *)ptr;\
+ 	  glVertexAttribPointer(va-&gt;target,va-&gt;size,va-&gt;type,va-&gt;normalized,0,va-&gt;buffer?va-&gt;pointer:(ptr+sizeof(VAstruct)));\
+    ptr+=va-&gt;totalsize;\
+  }
 
 
 #define GML_MAKEHANDLER3VDA(name) case gml##name##Enum:\
@@ -571,13 +586,12 @@
 	GMLMAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
 	GMLMAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
 	GMLMAKESUBHANDLERVA(name)\
-	gl##name(((gml##name##Data *)p)-&gt;A,0/*((gml##name##Data *)p)-&gt;B*/,((gml##name##Data *)p)-&gt;C);\
-        p+=((gml##name##Data *)p)-&gt;size;\
+	gl##name(((gml##name##Data *)p)-&gt;A,0,((gml##name##Data *)p)-&gt;C);\
+  p+=((gml##name##Data *)p)-&gt;size;\
         break;
 
 #define GML_MAKEHANDLER4VDE(name) case gml##name##Enum:\
 	ptr=(BYTE *)(((gml##name##Data *)p)+1);\
-	ptr+=((gml##name##Data *)p)-&gt;IDXtotalsize;\
 	GMLMAKESUBHANDLER4(GL_VERTEX_ARRAY,glVertexPointer,VP,name)\
 	GMLMAKESUBHANDLER4(GL_COLOR_ARRAY,glColorPointer,CP,name)\
 	GMLMAKESUBHANDLER4(GL_TEXTURE_COORD_ARRAY,glTexCoordPointer,TCP,name)\
@@ -585,8 +599,12 @@
 	GMLMAKESUBHANDLER3(GL_NORMAL_ARRAY,glNormalPointer,NP,name)\
 	GMLMAKESUBHANDLER2(GL_EDGE_FLAG_ARRAY,glEdgeFlagPointer,EFP,name)\
 	GMLMAKESUBHANDLERVA(name)\
-	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,((gml##name##Data *)p)+1);\
-        p+=((gml##name##Data *)p)-&gt;size;\
+  if(((gml##name##Data *)p)-&gt;ClientState &amp; GML_ELEMENT_ARRAY_BUFFER)\
+  	gl##name(((gml##name##Data *)p)-&gt;A,((gml##name##Data *)p)-&gt;B,((gml##name##Data *)p)-&gt;C,\
+	           ((gml##name##Data *)p)-&gt;D);\
+  else\
+    glDrawArrays(((gml##name##Data *)p)-&gt;A,0,((gml##name##Data *)p)-&gt;B);\
+  p+=((gml##name##Data *)p)-&gt;size;\
         break;
 
 
@@ -598,6 +616,9 @@
 // ptr is a temporary variable used inside the handlers
 inline void QueueHandler(BYTE *&amp;p, BYTE *&amp;ptr) {
 		switch(*(int *)p) {
+#if GML_ALTERNATE_SYNCMODE
+			  case 0: p+=sizeof(int); break;
+#endif
   			GML_MAKEHANDLER1(Disable)
 				GML_MAKEHANDLER1(Enable)
 				GML_MAKEHANDLER2(BindTexture)
@@ -676,7 +697,7 @@
 				GML_MAKEHANDLER0(Flush)
 				GML_MAKEHANDLER3(Normal3f)
 				GML_MAKEHANDLER1(UseProgramObjectARB)
-				GML_MAKEHANDLER8V(CompressedTexImage2DARB)
+				GML_MAKEHANDLER8VP(CompressedTexImage2DARB)
 				GML_MAKEHANDLER1(DeleteObjectARB)
 				GML_MAKEHANDLER2(Fogi)
 				GML_MAKEHANDLER1V(MultMatrixd)
@@ -722,8 +743,8 @@
 				GML_MAKEHANDLER4VS(BufferDataARB)
 				GML_MAKEHANDLER1(ClearDepth)
 				GML_MAKEHANDLER3(Color3ub)
-				GML_MAKEHANDLER7V(CompressedTexImage1DARB)
-				GML_MAKEHANDLER9V(CompressedTexImage3DARB)
+				GML_MAKEHANDLER7VP(CompressedTexImage1DARB)
+				GML_MAKEHANDLER9VP(CompressedTexImage3DARB)
 				GML_MAKEHANDLER1(DrawBuffer)
 				GML_MAKEHANDLER1(FrontFace)
 				GML_MAKEHANDLER6(Frustum)
@@ -808,7 +829,7 @@
 				GML_MAKEHANDLER4VS(BufferData)
 				GML_MAKEHANDLER2R(MapBuffer)
 				GML_MAKEHANDLER1R(UnmapBuffer)
-				GML_MAKEHANDLER8V(CompressedTexImage2D)
+				GML_MAKEHANDLER8VP(CompressedTexImage2D)
 				GML_MAKEHANDLER1R(IsShader)
 				GML_MAKEHANDLER3(Vertex3i)
 
@@ -868,14 +889,21 @@
 #if GML_ALTERNATE_SYNCMODE
 	BYTE *s;
 	while(1) {
+  	int updsrv=0;
 		while((s=(BYTE *)Sync)==EXEC_RUN) {
 			if(Reloc)
 				Realloc();
-			gmlUpdateServers();
+      if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
+			  gmlUpdateServers();
+			if(GetRead()) {
+  			Execute();
+	  		ReleaseRead();
+			}
 			boost::thread::yield();
 		}
 
 		if(s!=EXEC_SYNC) { // end addr
+			Sync=EXEC_SYNC; //NEW
 			GetRead(TRUE);
 			Sync=EXEC_RUN; // cannot allow worker to continue before right queue acquired
 			Execute();
@@ -897,14 +925,15 @@
   BYTE *ptr=NULL;
 	BOOL_ isq1=Write==Queue1;
 	BOOL_ end=FALSE;
-  int updserv=0;
+  int updsrv=0;
 
   while(TRUE) {
 		if(!end) {
 			while(TRUE) {
   			if(Reloc)
 	  			e=Realloc(&amp;p);
-				if(((++updserv)%GML_UPDSRV_INTERVAL)==0)
+//				if(((++updsrv)%GML_UPDSRV_INTERVAL)==0)
+        if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
 					gmlUpdateServers();
 				BYTE *s=(BYTE *)Sync;
 				if(s!=EXEC_RUN) {

Modified: branches/gml/rts/lib/gml/gml.h
===================================================================
--- branches/gml/rts/lib/gml/gml.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/gml/gml.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -101,6 +101,7 @@
 }
 
 EXTERN inline void gmlUpdateServers() {
+	gmlItemsConsumed=0;
 	gmlProgramServer.GenerateItems();
 	gmlProgramObjectARBServer.GenerateItems();
 	gmlShaderServer_VERTEX.GenerateItems();
@@ -131,20 +132,4 @@
 #define GML_CLASSVECTOR std::vector
 #endif
 
-extern bool gmlExperimentalMode;
-
-#if GML_ENABLE &amp;&amp; GML_EXPERIMENTAL
-#define GML_VECTOR_EXP gmlVector
-#define GML_CLASSVECTOR_EXP gmlClassVector
-#define GML_EXP_MODE() gmlExperimentalMode
-#define GML_EXP_MODE_ENABLE() gmlExperimentalMode=true;
-#define GML_EXP_MODE_DISABLE() gmlExperimentalMode=false;
-#else
-#define GML_VECTOR_EXP std::vector
-#define GML_CLASSVECTOR_EXP std::vector
-#define GML_EXP_MODE() 0
-#define GML_EXP_MODE_ENABLE()
-#define GML_EXP_MODE_DISABLE()
 #endif
-
-#endif

Modified: branches/gml/rts/lib/gml/gmlcls.h
===================================================================
--- branches/gml/rts/lib/gml/gmlcls.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/gml/gmlcls.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -33,7 +33,6 @@
 #define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
 //#define GML_USE_QUADRIC_SERVER 1 // use server thread to create/delete quadrics
 #define GML_UPDSRV_INTERVAL 10
-#define GML_EXPERIMENTAL 0
 #define GML_ALTERNATE_SYNCMODE 1 // mutex-protected synced execution, slower but more portable
 
 #ifdef _MSC_VER
@@ -72,6 +71,7 @@
 #define GML_CPU_COUNT (gmlThreadCountOverride?gmlThreadCountOverride:gmlCPUCount())
 #define GML_MAX_NUM_THREADS 32
 #define GML_IF_SERVER_THREAD() if(GML_SERVER_GLCALL &amp;&amp; (!GML_ENABLE || gmlThreadNumber==0))
+extern int gmlItemsConsumed;
 
 typedef unsigned char       BYTE;
 typedef int                 BOOL_;
@@ -79,6 +79,13 @@
 #define TRUE 1
 #define FALSE 0
 #define EXTERN
+#define GML_VP_ARRAY_BUFFER (1&lt;&lt;(16+GL_VERTEX_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;20)
+#define GML_CP_ARRAY_BUFFER (1&lt;&lt;(16+GL_COLOR_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;21)
+#define GML_TCP_ARRAY_BUFFER (1&lt;&lt;(16+GL_TEXTURE_COORD_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;22)
+#define GML_IP_ARRAY_BUFFER (1&lt;&lt;(16+GL_INDEX_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;23)
+#define GML_NP_ARRAY_BUFFER (1&lt;&lt;(16+GL_NORMAL_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;24)
+#define GML_EFP_ARRAY_BUFFER (1&lt;&lt;(16+GL_EDGE_FLAG_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;25)
+#define GML_ELEMENT_ARRAY_BUFFER (1&lt;&lt;29)
 
 #if defined(_WIN32)
 #  if defined(__MINGW32__)
@@ -544,10 +551,11 @@
   }
   bool Lock() {
 		boost::try_mutex::scoped_try_lock *lock=((boost::try_mutex::scoped_try_lock *)sl_lock)+gmlThreadNumber;
-    new (lock) boost::try_mutex::scoped_try_lock(sl_mutex);
 #if (BOOST_VERSION &gt;= 103500)
+		new (lock) boost::try_mutex::scoped_try_lock(sl_mutex,boost::try_to_lock);
 		if(lock-&gt;owns_lock())
 #else
+		new (lock) boost::try_mutex::scoped_try_lock(sl_mutex);
 		if(lock-&gt;locked())
 #endif
 			return true;
@@ -573,10 +581,11 @@
   GLenum type;
   GLboolean normalized;
   GLsizei stride;
-  void *pointer;
+  const GLvoid *pointer;
+  GLuint buffer;
   VAdata(){}
-  VAdata(GLint si, GLenum ty, GLboolean no, GLsizei st, void *po):
-  size(si),type(ty),normalized(no),stride(st),pointer(po) {}
+  VAdata(GLint si, GLenum ty, GLboolean no, GLsizei st, const GLvoid *po, GLuint buf):
+  size(si),type(ty),normalized(no),stride(st),pointer(po),buffer(buf) {}
 };
 
 struct VAstruct {
@@ -584,7 +593,8 @@
   GLint size;
   GLenum type;
   GLboolean normalized;
-  GLsizei stride;
+  GLvoid * pointer;
+  GLuint buffer;
   int totalsize;
 };
 
@@ -643,6 +653,11 @@
   GLenum TCPtype;
   GLsizei TCPstride;
   GLvoid *TCPpointer;
+
+	GLuint ArrayBuffer;
+	GLuint ElementArrayBuffer;
+	GLuint PixelPackBuffer;
+	GLuint PixelUnpackBuffer;
   
   gmlQueue();
   
@@ -724,6 +739,7 @@
     GML_IF_SERVER_THREAD() {
       return (*genfun)(n);
     }
+  	++gmlItemsConsumed;
     if(n==1) {
       long num=++req;
       while(avail&lt;num) // waiting
@@ -798,6 +814,7 @@
     GML_IF_SERVER_THREAD() {
       return (*genfun)();
     }
+  	++gmlItemsConsumed;
     long num=++req;
     while(avail&lt;num) // waiting
       boost::thread::yield();
@@ -851,6 +868,7 @@
       (*genfun)(n,data);
       return;
     }
+		gmlItemsConsumed+=n;
     for(int i=0; i&lt;n; ++i) {
       long num=++req;
       while(avail&lt;num) // waiting

Modified: branches/gml/rts/lib/gml/gmlfun.h
===================================================================
--- branches/gml/rts/lib/gml/gmlfun.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/gml/gmlfun.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -359,6 +359,28 @@
   GML_SYNC_COND(__VA_ARGS__,)\
 }
 
+#define GML_MAKEFUN2B(name,ftype1,ftype2) struct gml##name##Data {\
+  GML_MAKEVAR_B(ftype1,ftype2)\
+};\
+EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+EXTERN inline void gml##name(ftype1 A, ftype2 B) {\
+  GML_COND(gl##name(A,B))\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_B()\
+	switch(A) {\
+	  case GL_ARRAY_BUFFER:\
+		  qd-&gt;ArrayBuffer=B; break;\
+	  case GL_ELEMENT_ARRAY_BUFFER:\
+      qd-&gt;ElementArrayBuffer=B; break;\
+	  case GL_PIXEL_PACK_BUFFER:\
+      qd-&gt;PixelPackBuffer=B; break;\
+	  case GL_PIXEL_UNPACK_BUFFER:\
+      qd-&gt;PixelUnpackBuffer=B; break;\
+  }\
+  GML_UPD_POS()\
+}
+
+
 #define GML_MAKEFUN2R(name,ftype1,ftype2,ftypeR) struct gml##name##Data {\
   GML_MAKEVAR_B(ftype1,ftype2)\
   GML_MAKEVAR_RET(ftypeR)\
@@ -485,7 +507,7 @@
   GML_MAKEVAR_SIZE()\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
   GML_COND(gl##name(A,B,C,D,E,F,G))\
   GML_PREP_VAR_SIZE(name,sizefun)\
   GML_MAKEASS_F()\
@@ -493,114 +515,126 @@
   GML_UPD_POS()\
 }
 
+#define GML_PUB_COPY(name,var,ftype)\
+	p-&gt;var=NULL;\
+	if(qd-&gt;PixelUnpackBuffer) {\
+	  datasize=sizeof(gml##name##Data);\
+		p-&gt;var=(ftype)((BYTE *)var+1);\
+	}\
+	else if(var!=NULL)\
+    memcpy(p+1,var,size);
+
 #define GML_MAKEFUN8S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,sizefun) struct gml##name##Data {\
-  GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
+  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8 *)\
   GML_MAKEVAR_SIZE()\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
   GML_COND(gl##name(A,B,C,D,E,F,G,H))\
-  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_PREP_VAR(name,sizefun)\
   GML_MAKEASS_G()\
-  memcpy(p+1,H,size);\
+	GML_PUB_COPY(name,H,ftype8 *)\
+  GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN9S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,sizefun,nullok) struct gml##name##Data {\
-  GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
+#define GML_MAKEFUN9S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,sizefun) struct gml##name##Data {\
+  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9 *)\
   GML_MAKEVAR_SIZE()\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
   GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
-  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_PREP_VAR(name,sizefun)\
   GML_MAKEASS_H()\
-	if(!nullok || I!=NULL)\
-    memcpy(p+1,I,size);\
+	GML_PUB_COPY(name,I,ftype9 *)\
+  GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN10S(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10,sizefun) struct gml##name##Data {\
-  GML_MAKEVAR_I(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9)\
+  GML_MAKEVAR_J(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftype10 *)\
   GML_MAKEVAR_SIZE()\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 J) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 I, ftype10 *J) {\
   GML_COND(gl##name(A,B,C,D,E,F,G,H,I,J))\
-  GML_PREP_VAR_SIZE(name,sizefun)\
+  GML_PREP_VAR(name,sizefun)\
   GML_MAKEASS_I()\
-  memcpy(p+1,J,size);\
+	GML_PUB_COPY(name,J,ftype10 *)\
+  GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN1V(name,ftype1,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN1V(name,ftype1,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR()\
   GML_MAKEVAR_SIZE()\
-  ftype1 A;\
+  ftypeX A;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(cnst ftype1* A) {\
+EXTERN inline void gml##name(ftype1* A) {\
   GML_COND(gl##name(A))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype1))\
-  memcpy(&amp;(p-&gt;A),A,size+sizeof(ftype1));\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
+  memcpy(&amp;(p-&gt;A),A,size+sizeof(ftypeX));\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN2V(name,ftype1,ftype2,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN2V(name,ftype1,ftype2,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_A(ftype1)\
   GML_MAKEVAR_SIZE()\
-  ftype2 B;\
+  ftypeX B;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, cnst ftype2* B) {\
+EXTERN inline void gml##name(ftype1 A, ftype2* B) {\
   GML_COND(gl##name(A,B))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype2))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_A()\
-  memcpy(&amp;(p-&gt;B),B,size+sizeof(ftype2));\
+  memcpy(&amp;(p-&gt;B),B,size+sizeof(ftypeX));\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN3V(name,ftype1,ftype2,ftype3,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN3V(name,ftype1,ftype2,ftype3,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_B(ftype1,ftype2)\
   GML_MAKEVAR_SIZE()\
-  ftype3 C;\
+  ftypeX C;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, cnst ftype3* C) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3* C) {\
   GML_COND(gl##name(A,B,C))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype3))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_B()\
-  memcpy(&amp;(p-&gt;C),C,size+sizeof(ftype3));\
+  memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN4V(name,ftype1,ftype2,ftype3,ftype4,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN4V(name,ftype1,ftype2,ftype3,ftype4,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
   GML_MAKEVAR_SIZE()\
-  ftype4 D;\
+  ftypeX D;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, cnst ftype4 *D) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
   GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype4))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_C()\
-  memcpy(&amp;(p-&gt;D),D,size+sizeof(ftype4));\
+  memcpy(&amp;(p-&gt;D),D,size+sizeof(ftypeX));\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN4VS(name,ftype1,ftype2,ftype3,ftype4,count) struct gml##name##Data {\
+#define GML_MAKEFUN4VS(name,ftype1,ftype2,ftype3,ftype4,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_B(ftype1,ftype2)\
   ftype4 D;\
   GML_MAKEVAR_SIZE()\
-  ftype3 C;\
+  ftypeX C;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
 EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C, ftype4 D) {\
   GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype3))\
+  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_B()\
   p-&gt;D=D;\
-  memcpy(&amp;(p-&gt;C),C,size+sizeof(ftype3));\
+	if(C!=NULL)\
+    memcpy(&amp;(p-&gt;C),C,size+sizeof(ftypeX));\
   GML_UPD_POS()\
 }
 
@@ -608,75 +642,86 @@
   GML_MAKEVAR_B(ftype1,ftype2)\
   int lensize;\
   GML_MAKEVAR_SIZE()\
-  ftype3 C;\
+  ftype3 *C;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C, ftype4 *D) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 **C, ftype4 *D) {\
   GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR(name,(count-1)*sizeof(ftype3))\
+  GML_PREP_VAR(name,(count-1)*sizeof(ftype3 *))\
   GML_MAKEASS_B()\
-  /*p-&gt;C=D;*/\
-/*  memcpy(&amp;(p-&gt;D),D,size+sizeof(ftype4));*/\
   p-&gt;lensize=datasize;\
   BYTE *e=(BYTE *)p+datasize;\
   for(int i=0; i&lt;B; ++i) {\
 	  BOOL_ len=!D || D[i]&lt;0;\
 	  GLint sl=(len?strlen(C[i]):D[i])+1;\
 	  datasize+=sl;\
-	  ((GLint *)&amp;(p-&gt;C))[i]=sl;\
+	  ((intptr_t *)&amp;(p-&gt;C))[i]=sl;\
       --sl;\
-      while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-        p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
-      memcpy(e,C[i],sl);\
+    while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+      p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+    memcpy(e,C[i],sl);\
 	  e+=sl;\
 	  *e='\0';\
-      ++e;\
+    ++e;\
   }\
   GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
+#define GML_PUB_PCOPY(name,var,pvar,ftype)\
+	p-&gt;pvar=NULL;\
+	if(qd-&gt;PixelUnpackBuffer) {\
+	  datasize=sizeof(gml##name##Data);\
+		p-&gt;pvar=(ftype *)var+1;\
+	}\
+	else if(var!=NULL)\
+    memcpy(&amp;(p-&gt;var),var,size+sizeof(ftype));
 
-#define GML_MAKEFUN7V(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN7VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
   GML_MAKEVAR_SIZE()\
-  ftype7 G;\
+  ftypeX *GP;\
+  ftypeX G;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, cnst ftype7 *G) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 *G) {\
   GML_COND(gl##name(A,B,C,D,E,F,G))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype7))\
+  GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_F()\
-  memcpy(&amp;(p-&gt;G),G,size+sizeof(ftype7));\
+	GML_PUB_PCOPY(name,G,GP,ftypeX)\
+  GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
-
-#define GML_MAKEFUN8V(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN8VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_G(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7)\
   GML_MAKEVAR_SIZE()\
-  ftype8 H;\
+  ftypeX *HP;\
+  ftypeX H;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, cnst /*ftype8*/void* H) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 *H) {\
   GML_COND(gl##name(A,B,C,D,E,F,G,H))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype8))\
+  GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_G()\
-  memcpy(&amp;(p-&gt;H),H,size+sizeof(ftype8));\
+	GML_PUB_PCOPY(name,H,HP,ftypeX)\
+  GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
-#define GML_MAKEFUN9V(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,count,cnst) struct gml##name##Data {\
+#define GML_MAKEFUN9VP(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8,ftype9,ftypeX,count) struct gml##name##Data {\
   GML_MAKEVAR_H(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,ftype7,ftype8)\
   GML_MAKEVAR_SIZE()\
-  ftype9 I;\
+  ftypeX *IP;\
+  ftypeX I;\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, cnst ftype9 *I) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F, ftype7 G, ftype8 H, ftype9 *I) {\
   GML_COND(gl##name(A,B,C,D,E,F,G,H,I))\
-  GML_PREP_VAR_SIZE(name,(count-1)*sizeof(ftype9))\
+  GML_PREP_VAR(name,(count-1)*sizeof(ftypeX))\
   GML_MAKEASS_H()\
-  memcpy(&amp;(p-&gt;I),I,size+sizeof(ftype9));\
+	GML_PUB_PCOPY(name,I,IP,ftypeX)\
+  GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
@@ -704,38 +749,46 @@
   GML_UPD_POS()\
 }
 
+#define GML_UPD_CS(arg)\
+	if(qd-&gt;ArrayBuffer)\
+  	qd-&gt;ClientState |= GML_##arg##_ARRAY_BUFFER;\
+	else\
+  	qd-&gt;ClientState &amp;= ~GML_##arg##_ARRAY_BUFFER;
+
 #define GML_MAKEFUN2P(name,ftype1,ftype2,arg) struct gml##name##Data {\
-  GML_MAKEVAR_B(ftype1,ftype2)\
+  GML_MAKEVAR_B(ftype1,ftype2 *)\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 *B) {\
   GML_COND(gl##name(A,B))\
   GML_PREP_FIXED(name)\
   GML_MAKEASS_B()\
   qd-&gt;arg##stride=A;\
   qd-&gt;arg##pointer=B;\
+	GML_UPD_CS(arg)\
   GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN3P(name,ftype1,ftype2,ftype3,arg) struct gml##name##Data {\
-  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
+  GML_MAKEVAR_C(ftype1,ftype2,ftype3 *)\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 *C) {\
   GML_COND(gl##name(A,B,C))\
   GML_PREP_FIXED(name)\
   GML_MAKEASS_C()\
   qd-&gt;arg##type=A;\
   qd-&gt;arg##stride=B;\
   qd-&gt;arg##pointer=C;\
+	GML_UPD_CS(arg)\
   GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN4P(name,ftype1,ftype2,ftype3,ftype4,arg) struct gml##name##Data {\
-  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4)\
+  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
   GML_COND(gl##name(A,B,C,D))\
   GML_PREP_FIXED(name)\
   GML_MAKEASS_D()\
@@ -743,107 +796,145 @@
   qd-&gt;arg##type=B;\
   qd-&gt;arg##stride=C;\
   qd-&gt;arg##pointer=D;\
+	GML_UPD_CS(arg)\
   GML_UPD_POS()\
 }
 
 #define GML_MAKEFUN6P(name,ftype1,ftype2,ftype3,ftype4,ftype5,ftype6,arg) struct gml##name##Data {\
-  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6)\
+  GML_MAKEVAR_F(ftype1,ftype2,ftype3,ftype4,ftype5,ftype6 *)\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 F) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D, ftype5 E, ftype6 *F) {\
   GML_COND(gl##name(A,B,C,D,E,F))\
   GML_PREP_FIXED(name)\
   GML_MAKEASS_F()\
-  qd-&gt;arg##map[A]=arg##data(B,C,D,E,F);\
+  qd-&gt;arg##map[A]=arg##data(B,C,D,E,F,qd-&gt;ArrayBuffer);\
   GML_UPD_POS()\
 }
 
 #define GML_MEMCOPY()\
 	for(int i=0; i&lt;C; ++i) {\
-  	  BYTE *e2=e;\
-  	  BYTE *v2=v;\
+  	BYTE *e2=e;\
+  	BYTE *v2=v;\
 	  for(int j=0; j&lt;itemsize; ++j) {\
 	    *e2=*v2;\
-		++e2;\
-		++v2;\
+		  ++e2;\
+		  ++v2;\
 	  }\
-/*    	   memcpy(e,v,itemsize);*/\
 	  e+=itemsize;\
 	  v+=itemstride;\
-    }\
+  }\
 
+#define GML_IDXLOOP(ltype)\
+	for(int i=0; i&lt;B; ++i) {\
+  	BYTE *e2=e;\
+  	BYTE *v2=v+(*(ltype *)dt)*itemstride;\
+		dt+=sizeof(ltype);\
+	  for(int j=0; j&lt;itemsize; ++j) {\
+	    *e2=*v2;\
+		  ++e2;\
+		  ++v2;\
+	  }\
+	  e+=itemsize;\
+  }
 
-#define GML_MAKESUBFUNDA(name,pre,arg,sizefun,sizeass,typeass)\
-  if(qd-&gt;ClientState &amp; (1&lt;&lt;(pre-GL_VERTEX_ARRAY))) {\
+#define GML_IDXCOPY()\
+	BYTE *dt=(BYTE *)D;\
+  switch(C) {\
+    case GL_UNSIGNED_INT:\
+      GML_IDXLOOP(GLuint)\
+      break;\
+    case GL_UNSIGNED_SHORT:\
+	    GML_IDXLOOP(GLushort)\
+	    break;\
+    case GL_UNSIGNED_BYTE:\
+	    GML_IDXLOOP(GLubyte)\
+	    break;\
+  }
+
+#define GML_MAKESUBFUNDA(name,pre,arg,sizefun,sizeass,typeass,first,count,copyfun)\
+	if(clientstate &amp; (1&lt;&lt;(pre-GL_VERTEX_ARRAY))) {\
+  	int itemsize=sizefun;\
+	  int itemstride=qd-&gt;arg##stride;\
+    if(itemstride==0)\
+      itemstride=itemsize;\
+  	p-&gt;arg##totalsize=0;\
+    p-&gt;arg##pointer=(GLvoid *)((BYTE *)qd-&gt;arg##pointer+first*itemstride);\
     sizeass;\
     typeass;\
-	int itemsize=sizefun;\
-	p-&gt;arg##totalsize=itemsize*C;\
-    datasize+=p-&gt;arg##totalsize;\
-    while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-      p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
-	int itemstride=qd-&gt;arg##stride;\
-	if(itemstride==0)\
-    itemstride=itemsize;\
-    BYTE *v=(BYTE *)qd-&gt;arg##pointer+B*itemstride;\
-	GML_MEMCOPY()\
-  }
+	  if(!(qd-&gt;ClientState &amp; GML_##arg##_ARRAY_BUFFER)) {\
+	    p-&gt;arg##totalsize=itemsize*count;\
+      datasize+=p-&gt;arg##totalsize;\
+      while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+        p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+      BYTE *v=(BYTE *)p-&gt;arg##pointer;\
+	    copyfun\
+    }\
+	}
 
 #define GML_MAKEPOINTERDATA()\
   GLenum ClientState;\
   GLint VPsize;\
   GLenum VPtype;\
+  GLvoid * VPpointer;\
   int VPtotalsize;\
   GLint CPsize;\
   GLenum CPtype;\
+  GLvoid * CPpointer;\
   int CPtotalsize;\
   GLint TCPsize;\
   GLenum TCPtype;\
+  GLvoid * TCPpointer;\
   int TCPtotalsize;\
   GLenum IPtype;\
+  GLvoid * IPpointer;\
   int IPtotalsize;\
   GLenum NPtype;\
+  GLvoid *NPpointer;\
   int NPtotalsize;\
+  GLvoid * EFPpointer;\
   int EFPtotalsize;\
   int VAcount;
 
-#define GML_MAKESUBFUNVA(name)\
-  p-&gt;VAcount=qd-&gt;VAset.size();\
+#define GML_MAKESUBFUNVA(name,first,count,copyfun)\
+	p-&gt;VAcount=qd-&gt;VAset.size();\
   std::set&lt;GLuint&gt;::iterator si=qd-&gt;VAset.begin();\
   while(si!=qd-&gt;VAset.end()) {\
     std::map&lt;GLuint,VAdata&gt;::iterator mi=qd-&gt;VAmap.find(*si);\
-/*	if(mi!=qd-&gt;VAmap.end()) {*/\
 \
     VAdata *vd=&amp;(mi-&gt;second);\
-	int itemsize=vd-&gt;size*gmlSizeOf(vd-&gt;type);\
-	int totalsize=itemsize*C+sizeof(VAstruct);\
-  datasize+=totalsize;\
-	while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
-    p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
+	  int itemstride=vd-&gt;stride;\
+ 	  int itemsize=vd-&gt;size*gmlSizeOf(vd-&gt;type);\
+		if(itemstride==0)\
+      itemstride=itemsize;\
+		if(vd-&gt;buffer)\
+      itemsize=0;\
+	  int totalsize=itemsize*count+sizeof(VAstruct);\
+    datasize+=totalsize;\
+	  while(qd-&gt;WritePos+datasize&gt;=qd-&gt;WriteSize)\
+      p=(gml##name##Data *)qd-&gt;WaitRealloc(&amp;e);\
 \
-  VAstruct *vs=(VAstruct *)e;\
-  e+=sizeof(VAstruct);\
-  vs-&gt;target=*si;\
-  vs-&gt;size=vd-&gt;size;\
-  vs-&gt;type=vd-&gt;type;\
-  vs-&gt;normalized=vd-&gt;normalized;\
-  vs-&gt;totalsize=totalsize;\
-	int itemstride=vd-&gt;stride;\
-	if(itemstride==0)\
-    itemstride=itemsize;\
+    VAstruct *vs=(VAstruct *)e;\
+    e+=sizeof(VAstruct);\
+    vs-&gt;target=*si;\
+    vs-&gt;size=vd-&gt;size;\
+    vs-&gt;type=vd-&gt;type;\
+    vs-&gt;normalized=vd-&gt;normalized;\
+    vs-&gt;totalsize=totalsize;\
+    vs-&gt;pointer=(GLvoid *)((BYTE *)vd-&gt;pointer+first*itemstride);\
+		vs-&gt;buffer=vd-&gt;buffer;\
 \
-  BYTE *v=(BYTE *)vd-&gt;pointer+B*itemstride;\
-	GML_MEMCOPY()\
-  \
-/*	}*/\
+	  if(!vd-&gt;buffer) {\
+      BYTE *v=(BYTE *)vs-&gt;pointer;\
+  	  copyfun\
+	  }\
+\
     ++si;\
   }
 
 
 #define GML_MAKEFUN3VDA(name,ftype1,ftype2,ftype3) struct gml##name##Data {\
-  GML_MAKEVAR_A(ftype1)\
-/*  ftype2 B;*/\
-  ftype3 C;\
+  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
   GML_MAKEPOINTERDATA()\
   GML_MAKEVAR_SIZE()\
 };\
@@ -851,48 +942,44 @@
 EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C) {\
   GML_COND(gl##name(A,B,C))\
   GML_PREP_FIXED(name)\
-  GML_MAKEASS_A()\
-/*p-&gt;B=B;*/\
-  p-&gt;C=C;\
+  GML_MAKEASS_C()\
+	GLenum clientstate=qd-&gt;ClientState &amp; ~(qd-&gt;ClientState&gt;&gt;16);\
   p-&gt;ClientState=qd-&gt;ClientState;\
   BYTE *e=(BYTE *)(p+1);\
-  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype)\
-  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype)\
-  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype)\
-  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype)\
-  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype)\
-  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,)\
-  GML_MAKESUBFUNVA(name)\
+  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype,B,C,GML_MEMCOPY())\
+  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype,B,C,GML_MEMCOPY())\
+  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype,B,C,GML_MEMCOPY())\
+  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype,B,C,GML_MEMCOPY())\
+  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype,B,C,GML_MEMCOPY())\
+  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,,B,C,GML_MEMCOPY())\
+  GML_MAKESUBFUNVA(name,B,C,GML_MEMCOPY())\
   GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
 
 
 #define GML_MAKEFUN4VDE(name,ftype1,ftype2,ftype3,ftype4) struct gml##name##Data {\
-  GML_MAKEVAR_C(ftype1,ftype2,ftype3)\
-/*  ftype4 D;*/\
+  GML_MAKEVAR_D(ftype1,ftype2,ftype3,ftype4 *)\
   GML_MAKEPOINTERDATA()\
-  int IDXtotalsize;\
   GML_MAKEVAR_SIZE()\
 };\
 EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
-EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 D) {\
+EXTERN inline void gml##name(ftype1 A, ftype2 B, ftype3 C, ftype4 *D) {\
   GML_COND(gl##name(A,B,C,D))\
-  GML_PREP_VAR(name,B*gmlSizeOf(C))\
-  p-&gt;IDXtotalsize=size;\
-  GML_MAKEASS_C()\
-/*p-&gt;D=D;*/\
+  GML_PREP_FIXED(name)\
+  GML_MAKEASS_D()\
+  BYTE *e=(BYTE *)(p+1);\
+	GLenum clientstate=qd-&gt;ClientState &amp; ~(qd-&gt;ClientState&gt;&gt;16);\
   p-&gt;ClientState=qd-&gt;ClientState;\
-  BYTE *e=(BYTE *)(p+1);\
-  memcpy(e,D,size);\
-  e+=size;\
-  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype)\
-  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype)\
-  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype)\
-  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype)\
-  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype)\
-  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,)\
-  GML_MAKESUBFUNVA(name)\
+	if(qd-&gt;ElementArrayBuffer)\
+	  p-&gt;ClientState |= GML_ELEMENT_ARRAY_BUFFER;\
+  GML_MAKESUBFUNDA(name,GL_VERTEX_ARRAY,VP,qd-&gt;VPsize*gmlSizeOf(qd-&gt;VPtype),p-&gt;VPsize=qd-&gt;VPsize,p-&gt;VPtype=qd-&gt;VPtype,0,B,GML_IDXCOPY())\
+  GML_MAKESUBFUNDA(name,GL_COLOR_ARRAY,CP,qd-&gt;CPsize*gmlSizeOf(qd-&gt;CPtype),p-&gt;CPsize=qd-&gt;CPsize,p-&gt;CPtype=qd-&gt;CPtype,0,B,GML_IDXCOPY())\
+  GML_MAKESUBFUNDA(name,GL_TEXTURE_COORD_ARRAY,TCP,qd-&gt;TCPsize*gmlSizeOf(qd-&gt;TCPtype),p-&gt;TCPsize=qd-&gt;TCPsize,p-&gt;TCPtype=qd-&gt;TCPtype,0,B,GML_IDXCOPY())\
+  GML_MAKESUBFUNDA(name,GL_INDEX_ARRAY,IP,gmlSizeOf(qd-&gt;IPtype),,p-&gt;IPtype=qd-&gt;IPtype,0,B,GML_IDXCOPY())\
+  GML_MAKESUBFUNDA(name,GL_NORMAL_ARRAY,NP,3*gmlSizeOf(qd-&gt;NPtype),,p-&gt;NPtype=qd-&gt;NPtype,0,B,GML_IDXCOPY())\
+  GML_MAKESUBFUNDA(name,GL_EDGE_FLAG_ARRAY,EFP,sizeof(GLboolean),,,0,B,GML_IDXCOPY())\
+  GML_MAKESUBFUNVA(name,0,B,GML_IDXCOPY())\
   GML_UPD_SIZE()\
   GML_UPD_POS()\
 }
@@ -921,12 +1008,12 @@
 GML_MAKEFUN2(BlendFunc,GLenum,GLenum,)
 GML_MAKEFUN1(CallList,GLuint)
 GML_MAKEFUN3(Color3f,GLfloat,GLfloat,GLfloat,)
-GML_MAKEFUN9S(TexImage2D,GLenum,GLint,GLint,GLsizei,GLsizei,GLint,GLenum,GLenum,const GLvoid *,D*E*gmlNumArgsTexImage(G)*gmlSizeOf(H),TRUE)
-GML_MAKEFUN1V(Color4fv,GLfloat,4,const)
+GML_MAKEFUN9S(TexImage2D,GLenum,GLint,GLint,GLsizei,GLsizei,GLint,GLenum,GLenum,const GLvoid,D*E*gmlNumArgsTexImage(G)*gmlSizeOf(H))
+GML_MAKEFUN1V(Color4fv,const GLfloat,GLfloat,4)
 GML_MAKEFUN2(BindProgramARB,GLenum,GLuint,)
 GML_MAKEFUN3(Scalef,GLfloat,GLfloat,GLfloat,)
 GML_MAKEFUN4(Viewport,GLint,GLint,GLsizei,GLsizei)
-GML_MAKEFUN2V(DeleteTextures,GLsizei,GLuint,A,const)
+GML_MAKEFUN2V(DeleteTextures,GLsizei,const GLuint,GLuint,A)
 GML_MAKEFUN3(MultiTexCoord2fARB,GLenum,GLfloat,GLfloat,)
 GML_MAKEFUN2(AlphaFunc,GLenum,GLclampf,)
 GML_MAKEFUN1(DepthMask,GLboolean)
@@ -937,8 +1024,8 @@
 GML_MAKEFUN1CS(DisableClientState,GLenum,&amp;=~)
 GML_MAKEFUN1CS(EnableClientState,GLenum,|=)
 GML_MAKEFUN4(Rectf,GLfloat,GLfloat,GLfloat,GLfloat)
-GML_MAKEFUN3V(Lightfv,GLenum,GLenum,GLfloat,gmlNumArgsLightMat(B),const)
-GML_MAKEFUN7S(uBuild2DMipmaps,GLenum,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid *,C*D*gmlNumArgsTexImage(E)*gmlSizeOf(F))
+GML_MAKEFUN3V(Lightfv,GLenum,GLenum,const GLfloat,GLfloat,gmlNumArgsLightMat(B))
+GML_MAKEFUN7S(uBuild2DMipmaps,GLenum,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid,C*D*gmlNumArgsTexImage(E)*gmlSizeOf(F))
 GML_MAKEFUN1(Clear,GLbitfield)
 GML_MAKEFUN0(EndList)
 GML_MAKEFUN2(NewList,GLuint,GLenum,)
@@ -946,74 +1033,74 @@
 GML_MAKEFUN2(PolygonMode,GLenum,GLenum,)
 GML_MAKEFUN1(ActiveTexture,GLenum)
 GML_MAKEFUN2(Fogf,GLenum,GLfloat,)
-GML_MAKEFUN1V(MultMatrixf,GLfloat,16,const)
+GML_MAKEFUN1V(MultMatrixf,const GLfloat,GLfloat,16)
 GML_MAKEFUN6(Ortho,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
 GML_MAKEFUN0(PopAttrib)
-GML_MAKEFUN3V(Materialfv,GLenum,GLenum,GLfloat,gmlNumArgsLightMat(B),const)
+GML_MAKEFUN3V(Materialfv,GLenum,GLenum,const GLfloat,GLfloat,gmlNumArgsLightMat(B))
 GML_MAKEFUN2(PolygonOffset,GLfloat,GLfloat,)
 GML_MAKEFUN1(PushAttrib,GLbitfield)
 GML_MAKEFUN1(CullFace,GLenum)
 GML_MAKEFUN4(ColorMask,GLboolean,GLboolean,GLboolean,GLboolean)
-GML_MAKEFUN1V(Vertex3fv,GLfloat,3,)
-GML_MAKEFUN3V(TexGenfv,GLenum,GLenum,GLfloat,gmlNumArgsTexGen(B),)
+GML_MAKEFUN1V(Vertex3fv,const GLfloat,GLfloat,3)
+GML_MAKEFUN3V(TexGenfv,GLenum,GLenum,const GLfloat,GLfloat,gmlNumArgsTexGen(B))
 GML_MAKEFUN2(Vertex2d,GLdouble,GLdouble,)
-GML_MAKEFUN4P(VertexPointer,GLint,GLenum,GLsizei,GLvoid *, VP)
+GML_MAKEFUN4P(VertexPointer,GLint,GLenum,GLsizei,GLvoid, VP)
 GML_MAKEFUN3VDA(DrawArrays,GLenum,GLint,GLsizei)
-GML_MAKEFUN2V(Fogfv,GLenum,GLfloat,gmlNumArgsFog(A),const)
+GML_MAKEFUN2V(Fogfv,GLenum,const GLfloat,GLfloat,gmlNumArgsFog(A))
 GML_MAKEFUN5(FramebufferTexture2DEXT,GLenum,GLenum,GLenum,GLuint,GLint)
-GML_MAKEFUN4P(TexCoordPointer,GLint,GLenum,GLsizei,GLvoid *, TCP)
-GML_MAKEFUN9S(TexSubImage2D,GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid *,E*F*gmlNumArgsTexImage(G)*gmlSizeOf(H),FALSE)
-GML_MAKEFUN2V(ClipPlane,GLenum,GLdouble,4,const)
+GML_MAKEFUN4P(TexCoordPointer,GLint,GLenum,GLsizei,GLvoid, TCP)
+GML_MAKEFUN9S(TexSubImage2D,GLenum,GLint,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,const GLvoid,E*F*gmlNumArgsTexImage(G)*gmlSizeOf(H))
+GML_MAKEFUN2V(ClipPlane,GLenum,const GLdouble,GLdouble,4)
 GML_MAKEFUN4(Color4d,GLdouble,GLdouble,GLdouble,GLdouble)
 GML_MAKEFUN2(LightModeli,GLenum,GLint,)
 GML_MAKEFUN3(TexGeni,GLenum,GLenum,GLint,)
 GML_MAKEFUN3(TexParameterf,GLenum,GLenum,GLfloat,)
 GML_MAKEFUN8(CopyTexSubImage2D,GLenum,GLint,GLint,GLint,GLint,GLint,GLsizei,GLsizei)
-GML_MAKEFUN2V(DeleteFramebuffersEXT,GLsizei,GLuint,A,const)
-GML_MAKEFUN1V(LoadMatrixf,GLfloat,16,)
+GML_MAKEFUN2V(DeleteFramebuffersEXT,GLsizei,const GLuint,GLuint,A)
+GML_MAKEFUN1V(LoadMatrixf,const GLfloat,GLfloat,16)
 GML_MAKEFUN1(ShadeModel,GLenum)
 GML_MAKEFUN1(UseProgram,GLuint)
 GML_MAKEFUN1(ClientActiveTextureARB,GLenum)
-GML_MAKEFUN2V(DeleteRenderbuffersEXT,GLsizei,GLuint,A,const)
+GML_MAKEFUN2V(DeleteRenderbuffersEXT,GLsizei,const GLuint,GLuint,A)
 GML_MAKEFUN0(Flush)
 GML_MAKEFUN3(Normal3f,GLfloat,GLfloat,GLfloat,)
 GML_MAKEFUN1(UseProgramObjectARB,GLhandleARB)
-GML_MAKEFUN8V(CompressedTexImage2DARB,GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,char,G,)
+GML_MAKEFUN8VP(CompressedTexImage2DARB,GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,const GLvoid,BYTE,G)
 GML_MAKEFUN1(DeleteObjectARB,GLhandleARB)
 GML_MAKEFUN2(Fogi,GLenum,GLint,)
-GML_MAKEFUN1V(MultMatrixd,GLdouble,16,const)
+GML_MAKEFUN1V(MultMatrixd,const GLdouble,GLdouble,16)
 GML_MAKEFUN2(PixelStorei,GLenum,GLint,)
 GML_MAKEFUN2(PointParameterf,GLenum,GLfloat,)
 GML_MAKEFUN3(TexCoord3f,GLfloat,GLfloat,GLfloat,)
 GML_MAKEFUN2(Uniform1i,GLint,GLint,)
 GML_MAKEFUN2(BindRenderbufferEXT,GLenum,GLuint,)
-GML_MAKEFUN1V(Color3fv,GLfloat,3,const)
+GML_MAKEFUN1V(Color3fv,const GLfloat,GLfloat,3)
 GML_MAKEFUN1(DepthFunc,GLenum)
 GML_MAKEFUN2(Hint,GLenum,GLenum,)
 GML_MAKEFUN1(LogicOp,GLenum)
 GML_MAKEFUN3(StencilOp,GLenum,GLenum,GLenum,)
-GML_MAKEFUN3V(TexEnvfv,GLenum,GLenum,GLfloat,gmlNumArgsTexEnv(B),)
-GML_MAKEFUN4V(UniformMatrix4fv,GLint,GLsizei,GLboolean,GLfloat,16*B,)
+GML_MAKEFUN3V(TexEnvfv,GLenum,GLenum,const GLfloat,GLfloat,gmlNumArgsTexEnv(B))
+GML_MAKEFUN4V(UniformMatrix4fv,GLint,GLsizei,GLboolean,const GLfloat,GLfloat,16*B)
 GML_MAKEFUN4(uOrtho2D,GLdouble,GLdouble,GLdouble,GLdouble)
 GML_MAKEFUN2(AttachObjectARB,GLhandleARB,GLhandleARB,)
-GML_MAKEFUN2(BindBufferARB,GLenum,GLuint,)
-GML_MAKEFUN1V(Color3ubv,GLubyte,3,)
+GML_MAKEFUN2B(BindBufferARB,GLenum,GLuint)
+GML_MAKEFUN1V(Color3ubv,const GLubyte,GLubyte,3)
 GML_MAKEFUN2(DetachObjectARB,GLhandleARB,GLhandleARB,)
 GML_MAKEFUN4(FramebufferRenderbufferEXT,GLenum,GLenum,GLenum,GLuint)
 GML_MAKEFUN2(LineStipple,GLint,GLushort,)
-GML_MAKEFUN1V(LoadMatrixd,GLdouble,16,const)
+GML_MAKEFUN1V(LoadMatrixd,const GLdouble,GLdouble,16)
 GML_MAKEFUN2(SetFenceNV,GLuint,GLenum,)
 GML_MAKEFUN3(StencilFunc,GLenum,GLint,GLuint,)
-GML_MAKEFUN10S(TexImage3D,GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLenum,GLenum,const GLvoid *,D*E*F*gmlNumArgsTexImage(H)*gmlSizeOf(I))
+GML_MAKEFUN10S(TexImage3D,GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLenum,GLenum,const GLvoid,D*E*F*gmlNumArgsTexImage(H)*gmlSizeOf(I))
 GML_MAKEFUN2(Uniform1f,GLint,GLfloat,)
 GML_MAKEFUN1(ClearStencil,GLint)
-GML_MAKEFUN4P(ColorPointer,GLint,GLenum,GLsizei,GLvoid *, CP)
+GML_MAKEFUN4P(ColorPointer,GLint,GLenum,GLsizei,GLvoid, CP)
 GML_MAKEFUN1(DeleteShader,GLuint)
-GML_MAKEFUN4VDE(DrawElements,GLenum,GLsizei,GLenum,GLvoid *)
+GML_MAKEFUN4VDE(DrawElements,GLenum,GLsizei,GLenum,GLvoid)
 GML_MAKEFUN1(GenerateMipmapEXT,GLenum)
 GML_MAKEFUN3(Materialf,GLenum,GLenum,GLfloat,)
-GML_MAKEFUN3P(NormalPointer,GLenum,GLsizei,GLvoid *, NP)
-GML_MAKEFUN3V(ProgramEnvParameter4fvARB,GLenum,GLuint,GLfloat,4,)
+GML_MAKEFUN3P(NormalPointer,GLenum,GLsizei,GLvoid, NP)
+GML_MAKEFUN3V(ProgramEnvParameter4fvARB,GLenum,GLuint,const GLfloat,GLfloat,4)
 GML_MAKEFUN4(RenderbufferStorageEXT,GLenum,GLenum,GLsizei,GLsizei)
 GML_MAKEFUN1(StencilMask,GLuint)
 GML_MAKEFUN4(Uniform3f,GLint,GLfloat,GLfloat,GLfloat)
@@ -1021,11 +1108,11 @@
 GML_MAKEFUN1(ActiveStencilFaceEXT,GLenum)
 GML_MAKEFUN2(AttachShader,GLuint,GLuint,)
 GML_MAKEFUN10(BlitFramebufferEXT,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLint,GLbitfield,GLenum)
-GML_MAKEFUN4VS(BufferDataARB,GLenum,GLsizei,char,GLenum,B)
+GML_MAKEFUN4VS(BufferDataARB,GLenum,GLsizei,const GLvoid,GLenum,BYTE,B)
 GML_MAKEFUN1(ClearDepth,GLclampd)
 GML_MAKEFUN3(Color3ub,GLubyte,GLubyte,GLubyte,)
-GML_MAKEFUN7V(CompressedTexImage1DARB,GLenum,GLint,GLenum,GLsizei,GLint,GLsizei,char,F,)
-GML_MAKEFUN9V(CompressedTexImage3DARB,GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLsizei,char,H,)
+GML_MAKEFUN7VP(CompressedTexImage1DARB,GLenum,GLint,GLenum,GLsizei,GLint,GLsizei,const GLvoid,BYTE,F)
+GML_MAKEFUN9VP(CompressedTexImage3DARB,GLenum,GLint,GLenum,GLsizei,GLsizei,GLsizei,GLint,GLsizei,const GLvoid,BYTE,H)
 GML_MAKEFUN1(DrawBuffer,GLenum)
 GML_MAKEFUN1(FrontFace,GLenum)
 GML_MAKEFUN6(Frustum,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
@@ -1034,15 +1121,15 @@
 GML_MAKEFUN3(MultiTexCoord2f,GLenum,GLfloat,GLfloat,)
 GML_MAKEFUN4(MultiTexCoord3f,GLenum,GLfloat,GLfloat,GLfloat)
 GML_MAKEFUN5(MultiTexCoord4f,GLenum,GLfloat,GLfloat,GLfloat,GLfloat)
-GML_MAKEFUN2V(PointParameterfv,GLenum,GLfloat,gmlNumArgsPointParam(A),)
+GML_MAKEFUN2V(PointParameterfv,GLenum,GLfloat,GLfloat,gmlNumArgsPointParam(A))
 GML_MAKEFUN1(PointSize,GLfloat)
-GML_MAKEFUN4V(ProgramStringARB,GLenum,GLenum,GLsizei,char,C,)
+GML_MAKEFUN4V(ProgramStringARB,GLenum,GLenum,GLsizei,const GLvoid,BYTE,C)
 GML_MAKEFUN3(SecondaryColor3f,GLfloat,GLfloat,GLfloat,)
 GML_MAKEFUN1(TexCoord1f,GLfloat)
 GML_MAKEFUN4(TexCoord4f,GLfloat,GLfloat,GLfloat,GLfloat)
 GML_MAKEFUN3(TexEnvf,GLenum,GLenum,GLfloat,)
 GML_MAKEFUN3(TexGenf,GLenum,GLenum,GLfloat,)
-GML_MAKEFUN8S(TexImage1D,GLenum,GLint,GLint,GLsizei,GLint,GLenum,GLenum,const GLvoid *,D*gmlNumArgsTexImage(F)*gmlSizeOf(G))
+GML_MAKEFUN8S(TexImage1D,GLenum,GLint,GLint,GLsizei,GLint,GLenum,GLenum,const GLvoid,D*gmlNumArgsTexImage(F)*gmlSizeOf(G))
 GML_MAKEFUN2(Uniform1iARB,GLint,GLint,)
 GML_MAKEFUN3(Uniform2f,GLint,GLfloat,GLfloat,)
 GML_MAKEFUN3(Uniform2fARB,GLint,GLfloat,GLfloat,)
@@ -1051,25 +1138,25 @@
 GML_MAKEFUN4(Uniform3i,GLint,GLint,GLint,GLint)
 GML_MAKEFUN5(Uniform4f,GLint,GLfloat,GLfloat,GLfloat,GLfloat)
 GML_MAKEFUN5(Uniform4i,GLint,GLint,GLint,GLint,GLint)
-GML_MAKEFUN4V(UniformMatrix2fv,GLint,GLsizei,GLboolean,GLfloat,4*B,)
-GML_MAKEFUN4V(UniformMatrix3fv,GLint,GLsizei,GLboolean,GLfloat,9*B,)
+GML_MAKEFUN4V(UniformMatrix2fv,GLint,GLsizei,GLboolean,const GLfloat,GLfloat,4*B)
+GML_MAKEFUN4V(UniformMatrix3fv,GLint,GLsizei,GLboolean,const GLfloat,GLfloat,9*B)
 GML_MAKEFUN4(Vertex4f,GLfloat,GLfloat,GLfloat,GLfloat)
 GML_MAKEFUN1(uDeleteQuadric,GLUquadric *)
 GML_MAKEFUN2(uQuadricDrawStyle,GLUquadric *,GLenum,)
 GML_MAKEFUN4(uSphere,GLUquadric *,GLdouble,GLint,GLint)
 GML_MAKEFUN4(ClearAccum,GLfloat,GLfloat,GLfloat,GLfloat)
 GML_MAKEFUN4(Color4ub,GLubyte,GLubyte,GLubyte,GLubyte)
-GML_MAKEFUN1V(Color4ubv,GLubyte,4,)
+GML_MAKEFUN1V(Color4ubv,const GLubyte,GLubyte,4)
 GML_MAKEFUN1(CompileShader,GLuint)
 GML_MAKEFUN1(CompileShaderARB,GLhandleARB)
 GML_MAKEFUN8(CopyTexImage2D,GLenum,GLint,GLenum,GLint,GLint,GLsizei,GLsizei,GLint)
-GML_MAKEFUN2V(DeleteBuffersARB,GLsizei,GLuint,A,)
-GML_MAKEFUN2V(DeleteFencesNV,GLsizei,GLuint,A,)
+GML_MAKEFUN2V(DeleteBuffersARB,GLsizei,const GLuint,GLuint,A)
+GML_MAKEFUN2V(DeleteFencesNV,GLsizei,const GLuint,GLuint,A)
 GML_MAKEFUN1(DeleteProgram,GLuint)
-GML_MAKEFUN2V(DeleteProgramsARB,GLsizei,GLuint,A,)
+GML_MAKEFUN2V(DeleteProgramsARB,GLsizei,const GLuint,GLuint,A)
 GML_MAKEFUN2(DetachShader,GLuint,GLuint,)
 GML_MAKEFUN1VA(DisableVertexAttribArrayARB,GLuint,VA,erase)
-GML_MAKEFUN2V(DrawBuffersARB,GLsizei,GLenum,A,)
+GML_MAKEFUN2V(DrawBuffersARB,GLsizei,const GLenum,GLenum,A)
 GML_MAKEFUN1(EdgeFlag,GLboolean)
 GML_MAKEFUN1VA(EnableVertexAttribArrayARB,GLuint,VA,insert)
 GML_MAKEFUN0(Finish)
@@ -1077,23 +1164,22 @@
 GML_MAKEFUN1(FogCoordf,GLfloat)
 GML_MAKEFUN3(Lightf,GLenum,GLenum,GLfloat,)
 GML_MAKEFUN1(LinkProgram,GLuint)
-GML_MAKEFUN1V(Normal3fv,GLfloat,3,)
+GML_MAKEFUN1V(Normal3fv,const GLfloat,GLfloat,3)
 GML_MAKEFUN2(RasterPos2i,GLint,GLint,)
 GML_MAKEFUN1(ReadBuffer,GLenum)
 GML_MAKEFUN4(Scissor,GLint,GLint,GLsizei,GLsizei)
-GML_MAKEFUN4VSS(ShaderSource,GLuint,GLsizei,const GLchar*,GLint,B)
-GML_MAKEFUN4VSS(ShaderSourceARB,GLhandleARB,GLsizei,const GLcharARB*,GLint,B)
-GML_MAKEFUN1V(TexCoord2fv,GLfloat,2,)
-GML_MAKEFUN3V(TexParameterfv,GLenum,GLenum,GLfloat,gmlNumArgsTexParam(B),)
+GML_MAKEFUN4VSS(ShaderSource,GLuint,GLsizei,const GLchar,GLint,B)
+GML_MAKEFUN4VSS(ShaderSourceARB,GLhandleARB,GLsizei,const GLcharARB,GLint,B)
+GML_MAKEFUN1V(TexCoord2fv,const GLfloat,GLfloat,2)
+GML_MAKEFUN3V(TexParameterfv,GLenum,GLenum,const GLfloat,GLfloat,gmlNumArgsTexParam(B))
 GML_MAKEFUN3(Translated,GLdouble,GLdouble,GLdouble,)
-GML_MAKEFUN3V(Uniform1fv,GLint,GLsizei,GLfloat,B,)
+GML_MAKEFUN3V(Uniform1fv,GLint,GLsizei,const GLfloat,GLfloat,B)
 GML_MAKEFUN5(Uniform4fARB,GLint,GLfloat,GLfloat,GLfloat,GLfloat)
-GML_MAKEFUN4V(UniformMatrix4fvARB,GLint,GLsizei,GLboolean,GLfloat,16*B,);
-GML_MAKEFUN6P(VertexAttribPointerARB,GLuint,GLint,GLenum,GLboolean,GLsizei,void *,VA)
+GML_MAKEFUN4V(UniformMatrix4fvARB,GLint,GLsizei,GLboolean,const GLfloat,GLfloat,16*B);
+GML_MAKEFUN6P(VertexAttribPointerARB,GLuint,GLint,GLenum,GLboolean,GLsizei,const GLvoid,VA)
 GML_MAKEFUN9(uLookAt,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble,GLdouble)
-GML_MAKEFUN2V(LightModelfv,GLenum,GLfloat,gmlNumArgsLightModel(A),const)
-
-GML_MAKEFUN2V(DeleteQueries,GLsizei,GLuint,A,const)
+GML_MAKEFUN2V(LightModelfv,GLenum,const GLfloat,GLfloat,gmlNumArgsLightModel(A))
+GML_MAKEFUN2V(DeleteQueries,GLsizei,const GLuint,GLuint,A)//
 GML_MAKEFUN1(BlendEquation,GLenum)
 GML_MAKEFUN2(StencilMaskSeparate,GLenum,GLuint,)
 GML_MAKEFUN4(StencilFuncSeparate,GLenum,GLenum,GLint,GLuint)
@@ -1104,29 +1190,27 @@
 GML_MAKEFUN2(BlendEquationSeparate,GLenum,GLenum,)
 GML_MAKEFUN4(BlendFuncSeparate,GLenum,GLenum,GLenum,GLenum)
 GML_MAKEFUN6(uCylinder,GLUquadric *,GLdouble,GLdouble,GLdouble,GLint,GLint)
-
-GML_MAKEFUN2V(DeleteBuffers,GLsizei,GLuint,A,const)
-GML_MAKEFUN2(BindBuffer,GLenum,GLuint,)
-GML_MAKEFUN4VS(BufferData,GLenum,GLsizeiptr,char,GLenum,B)
-GML_MAKEFUN2R(MapBuffer,GLenum, GLenum, void *)
-GML_MAKEFUN1R(UnmapBuffer,GLenum, GLboolean,)
-GML_MAKEFUN8V(CompressedTexImage2D,GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,char,G,)
+GML_MAKEFUN2V(DeleteBuffers,GLsizei,const GLuint,GLuint,A)//
+GML_MAKEFUN2B(BindBuffer,GLenum,GLuint)
+GML_MAKEFUN4VS(BufferData,GLenum,GLsizeiptr,const GLvoid,GLenum,BYTE,B)
+GML_MAKEFUN2R(MapBuffer,GLenum,GLenum,GLvoid *)
+GML_MAKEFUN1R(UnmapBuffer,GLenum,GLboolean,)
+GML_MAKEFUN8VP(CompressedTexImage2D,GLenum,GLint,GLenum,GLsizei,GLsizei,GLint,GLsizei,const GLvoid,BYTE,G)
 GML_MAKEFUN1R(IsShader,GLuint, GLboolean,)
 GML_MAKEFUN3(Vertex3i,GLint,GLint,GLint,)
-
-GML_MAKEFUN2(GetIntegerv,GLenum, GLint *,GML_CACHE(GLenum,GLint,gmlGetIntegervCache,A,B),GML_SYNC())
+GML_MAKEFUN2(GetIntegerv,GLenum,GLint *,GML_CACHE(GLenum,GLint,gmlGetIntegervCache,A,B),GML_SYNC())//
 GML_MAKEFUN1R(CheckFramebufferStatusEXT,GLenum, GLenum,GML_DEFAULT_RET(A==GL_FRAMEBUFFER_EXT,GL_FRAMEBUFFER_COMPLETE_EXT))
-GML_MAKEFUN2(GetFloatv,GLenum, GLfloat *,GML_CACHE(GLenum,GLfloat,gmlGetFloatvCache,A,B),GML_SYNC())
-GML_MAKEFUN1R(GetString,GLenum, const GLubyte *,GML_CACHE_RET_STR(GLenum,std::string,gmlGetStringCache,A))
-GML_MAKEFUN2R(GetUniformLocationARB,GLhandleARB, const GLcharARB *, GLint)
+GML_MAKEFUN2(GetFloatv,GLenum,GLfloat *,GML_CACHE(GLenum,GLfloat,gmlGetFloatvCache,A,B),GML_SYNC())
+GML_MAKEFUN1R(GetString,GLenum,const GLubyte *,GML_CACHE_RET_STR(GLenum,std::string,gmlGetStringCache,A))
+GML_MAKEFUN2R(GetUniformLocationARB,GLhandleARB,const GLcharARB *, GLint)
 GML_MAKEFUN7(ReadPixels,GLint,GLint,GLsizei,GLsizei,GLenum,GLenum,GLvoid *,GML_SYNC())
 GML_MAKEFUN0R(GetError,GLenum,GML_DEFAULT_ERROR())
 GML_MAKEFUN3(GetObjectParameterivARB,GLhandleARB,GLenum,GLint *,GML_DEFAULT(B==GL_OBJECT_COMPILE_STATUS_ARB || B==GL_OBJECT_LINK_STATUS_ARB,*C=GL_TRUE),GML_SYNC())
-GML_MAKEFUN2R(GetUniformLocation,GLint, const GLchar *, GLint)
+GML_MAKEFUN2R(GetUniformLocation,GLint,const GLchar *, GLint)
 GML_MAKEFUN2(GetDoublev,GLenum, GLdouble *,,GML_SYNC())
 GML_MAKEFUN3(GetProgramiv,GLuint,GLenum,GLint *,,GML_SYNC())
 GML_MAKEFUN7(GetActiveUniform,GLuint,GLuint,GLsizei,GLsizei *,GLint *,GLenum *,GLchar *,GML_SYNC())
-GML_MAKEFUN2R(GetAttribLocationARB,GLhandleARB, const GLcharARB *, GLint)
+GML_MAKEFUN2R(GetAttribLocationARB,GLhandleARB,const GLcharARB *, GLint)
 GML_MAKEFUN4(GetInfoLogARB,GLhandleARB,GLsizei,GLsizei *,GLcharARB *,GML_SYNC())
 GML_MAKEFUN4(GetProgramInfoLog,GLuint,GLsizei,GLsizei *,GLchar *,GML_SYNC())
 GML_MAKEFUN3(GetProgramivARB,GLenum,GLenum,GLint *,,GML_SYNC())
@@ -1137,9 +1221,8 @@
 GML_MAKEFUN9R(uProject,GLdouble,GLdouble,GLdouble,const GLdouble *,const GLdouble *,const GLint *,GLdouble *,GLdouble *,GLdouble *,int)
 GML_MAKEFUN9R(uScaleImage,GLenum,GLint,GLint,GLenum,const void *,GLint,GLint,GLenum,void *,int)
 GML_MAKEFUN1R(TestFenceNV,GLuint,GLboolean,)
-
-GML_MAKEFUN3P(IndexPointer,GLenum,GLsizei,GLvoid *, IP)
-GML_MAKEFUN2P(EdgeFlagPointer,GLsizei,GLboolean *, EFP)
+GML_MAKEFUN3P(IndexPointer,GLenum,GLsizei,GLvoid, IP)//
+GML_MAKEFUN2P(EdgeFlagPointer,GLsizei,GLboolean, EFP)
 GML_MAKEFUN4(TrackMatrixNV,GLenum,GLuint,GLenum,GLenum)
 
 #endif

Modified: branches/gml/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/gml/rts/lib/gml/gmlsrv.h	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/gml/gmlsrv.h	2008-06-14 22:06:38 UTC (rev 6030)
@@ -126,9 +126,11 @@
 				it=ex-&gt;iter-&gt;begin();
 			int pos=0;
 //      int nproc=0;
+			int updsrv=0;
 			if(gmlThreadCount&gt;1) {
 				while(ClientsReady&lt;=gmlThreadCount+1) {
-					gmlUpdateServers();
+					if((updsrv++%GML_UPDSRV_INTERVAL)==0 || *(volatile int *)&amp;gmlItemsConsumed&gt;=GML_UPDSRV_INTERVAL)
+  					gmlUpdateServers();
 					BOOL_ processed=FALSE;
 					for(int i=1; i&lt;gmlThreadCount; ++i) {
 						gmlQueue *qd=&amp;gmlQueues[i];
@@ -233,7 +235,11 @@
 			++processed;
 
 //			int exproc=processed;
+#if GML_ALTERNATE_SYNCMODE
+			if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(ex-&gt;syncmode?TRUE:2))
+#else
 			if(qd-&gt;WasSynced &amp;&amp; qd-&gt;GetWrite(TRUE))
+#endif
 				processed=0;
 			if(processed&gt;=ex-&gt;limit1 &amp;&amp; qd-&gt;GetWrite(processed&gt;=ex-&gt;limit2))
 				processed=0;

Modified: branches/gml/rts/lib/luabind/luabind/detail/policy.hpp
===================================================================
--- branches/gml/rts/lib/luabind/luabind/detail/policy.hpp	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/luabind/luabind/detail/policy.hpp	2008-06-14 22:06:38 UTC (rev 6030)
@@ -1282,7 +1282,7 @@
 namespace luabind { namespace
 {
 #if defined(__BORLANDC__) || (BOOST_VERSION &gt;= 103400 &amp;&amp; defined(__GNUC__))
-# if (BOOST_VERSION &gt;= 103500 &amp;&amp; __GNUC__ &gt;= 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3)
+# if (BOOST_VERSION &gt;= 103500 &amp;&amp; __GNUC__ &gt;= 4 &amp;&amp; __GNUC_MINOR__ &gt;= 2)
   static boost::arg&lt;0&gt; return_value;
   static boost::arg&lt;0&gt; result;
 #  define LUABIND_PLACEHOLDER_ARG(N) boost::arg&lt;N&gt;&amp;

Modified: branches/gml/rts/lib/streflop/CMakeLists.txt
===================================================================
--- branches/gml/rts/lib/streflop/CMakeLists.txt	2008-06-14 14:40:09 UTC (rev 6029)
+++ branches/gml/rts/lib/streflop/CMakeLists.txt	2008-06-14 22:06:38 UTC (rev 6030)
@@ -6,7 +6,6 @@
 # th&lt;ts why it is set in cxxflags as a workaround
 #INCLUDE_DIRECTORIES(libm/headers)
 
-ADD_DEFINITIONS(-DSTREFLOP_X87=1)
 SET(cxxflags &quot;-w -O3 -frounding-math -fsignaling-nans -fno-strict-aliasing -mieee-fp -Wall -mfpmath=387 -I${CMAKE_CURRENT_SOURCE_DIR}/libm/headers&quot;)
 SET_SOURCE_FILES_PROPERTIES(${libm_flt32_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_FLT32 ${cxxflags}&quot;)
 SET_SOURCE_FILES_PROPERTIES(${libm_dbl64_source} PROPERTIES COMPILE_FLAGS &quot;-DLIBM_COMPILING_DBL64 ${cxxflags}&quot;)
@@ -20,12 +19,3 @@
 #	${libm_dbl64_source}
 #	${libm_ldbl96_source}
 )
-
-
-### Old streflop buildcode - use streflops makefile
-### streflop has its own Makefile, but $(RM) seems to be rm even on windows, so overwrite it with windows &quot;del&quot;
-#IF (CMAKE_HOST_WIN32)
-#	SET(RM_OVERRIDE RM=del)
-#ENDIF(CMAKE_HOST_WIN32)
-
-#ADD_CUSTOM_TARGET(strefloplib COMMAND make STREFLOP_X87=1 CXX=${CMAKE_C_COMPILER} ${RM_OVERRIDE} AR=${CMAKE_AR} WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/streflop) 

Modified: branches/gml/rts/spring.png
===================================================================
(Binary files differ)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000809.html">[Taspring-linux-commit] r6029 - in trunk: . installer	installer/sections
</A></li>
	<LI>Next message: <A HREF="000811.html">[Taspring-linux-commit] r6031 - in trunk/rts/Sim/Units: CommandAI	UnitTypes
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#810">[ date ]</a>
              <a href="thread.html#810">[ thread ]</a>
              <a href="subject.html#810">[ subject ]</a>
              <a href="author.html#810">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
