<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6942 - in branches/caiinterface:	AI/Interfaces rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6942%20-%20in%20branches/caiinterface%3A%0A%09AI/Interfaces%20rts/ExternalAI%20rts/ExternalAI/Interface%0A%09rts/ExternalAI/Interface/LegacyCppWrapper&In-Reply-To=%3C20081101123722.9B2C74743%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="001712.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6942 - in branches/caiinterface:	AI/Interfaces rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6942%20-%20in%20branches/caiinterface%3A%0A%09AI/Interfaces%20rts/ExternalAI%20rts/ExternalAI/Interface%0A%09rts/ExternalAI/Interface/LegacyCppWrapper&In-Reply-To=%3C20081101123722.9B2C74743%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6942 - in branches/caiinterface:	AI/Interfaces rts/ExternalAI rts/ExternalAI/Interface	rts/ExternalAI/Interface/LegacyCppWrapper">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Nov  1 13:37:22 CET 2008</I>
    <P><UL>
        
        <LI>Next message: <A HREF="001712.html">[Taspring-linux-commit] r6943 - in branches/gmltest/rts: System	lib/gml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1711">[ date ]</a>
              <a href="thread.html#1711">[ thread ]</a>
              <a href="subject.html#1711">[ subject ]</a>
              <a href="author.html#1711">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-11-01 13:37:21 +0100 (Sat, 01 Nov 2008)
New Revision: 6942

Modified:
   branches/caiinterface/AI/Interfaces/CMakeLists.txt
   branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
   branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
   branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h
   branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp
   branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h
   branches/caiinterface/rts/ExternalAI/SAICallback.cpp
Log:
* small cleanup
* removed all multi-dimensional arrays from the AI callback (except char*[])

Modified: branches/caiinterface/AI/Interfaces/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/AI/Interfaces/CMakeLists.txt	2008-11-01 12:37:21 UTC (rev 6942)
@@ -18,7 +18,7 @@
 		file(STRINGS &quot;${C_AIINTERFACE_SRC}/VERSION&quot; C_AIINTERFACE_VERS LIMIT_COUNT 1)
 	endif (EXISTS ${C_AIINTERFACE_SRC}/VERSION)
 	set(C_AIINTERFACE_TARGET &quot;C-${C_AIINTERFACE_VERS}&quot;)
-	message(&quot;${C_AIINTERFACE_VERS}\t(C AI Interface Version)&quot;)
+	message(STATUS &quot;${C_AIINTERFACE_VERS}\t(C AI Interface Version)&quot;)
 
 	aux_source_directory(${C_AIINTERFACE_SRC} cAIInterface)
 	list (APPEND cAIInterface ${CMAKE_SOURCE_DIR}/rts/System/Platform/SharedLib)
@@ -57,12 +57,30 @@
 		file(STRINGS &quot;${Java_AIINTERFACE_SRC}/VERSION&quot; Java_AIINTERFACE_VERS LIMIT_COUNT 1)
 	endif (EXISTS ${Java_AIINTERFACE_SRC}/VERSION)
 	set(Java_AIINTERFACE_TARGET &quot;Java-${Java_AIINTERFACE_VERS}&quot;)
-	message(&quot;${Java_AIINTERFACE_VERS}\t(Java AI Interface Version)&quot;)
+	message(STATUS &quot;${Java_AIINTERFACE_VERS}\t(Java AI Interface Version)&quot;)
 
 	aux_source_directory(${Java_AIINTERFACE_SRC} javaAIInterface)
 	add_library(${Java_AIINTERFACE_TARGET} MODULE ${javaAIInterface} ${aienv})
 	target_link_libraries(${Java_AIINTERFACE_TARGET} ${JAVA_JVM_LIBRARY})
 	install (FILES ${Java_AIINTERFACE_SRC}/InterfaceInfo.lua DESTINATION ${AI_INTERFACES_DATA}/Java/${Java_AIINTERFACE_VERS})
 	install (TARGETS ${Java_AIINTERFACE_TARGET} DESTINATION ${AI_INTERFACES_LIBS})
+	INCLUDE_DIRECTORIES(BEFORE ${CMAKE_SOURCE_DIR}/rts/lib/streflop)
+	TARGET_LINK_LIBRARIES(${Java_AIINTERFACE_TARGET} streflop)
+	set_target_properties(${Java_AIINTERFACE_TARGET} PROPERTIES COMPILE_FLAGS &quot;-DSTREFLOP_X87&quot;)
+
+	# Compile the Java sources of this interface and the test AI
+	IF (UNIX)
+		execute_process(COMMAND compile.sh WORKING_DIRECTORY ${Java_AIINTERFACE_SRC}/java)
+	ELSEIF (UNIX)
+		execute_process(COMMAND compile.bat WORKING_DIRECTORY ${Java_AIINTERFACE_SRC}/java)
+	ENDIF(UNIX)
+
+	# Install the Java part of the interface
+	install (FILES ${Java_AIINTERFACE_SRC}/java/interface.jar DESTINATION ${AI_INTERFACES_DATA}/Java/${Java_AIINTERFACE_VERS}/jlib)
+	install (FILES ${Java_AIINTERFACE_SRC}/jlib/*.jar DESTINATION ${AI_INTERFACES_DATA}/Java/${Java_AIINTERFACE_VERS}/jlib)
+
+	# Install the Java test Skirmish AI
+	install (FILES ${Java_AIINTERFACE_SRC}/java/ai.jar DESTINATION ${CMAKE_SOURCE_DIR}/AI/Skirmish/hoijuiAI/jlib)
+	install (FILES ${Java_AIINTERFACE_SRC}/AIInfo.lua DESTINATION ${CMAKE_SOURCE_DIR}/AI/Skirmish/hoijuiAI)
 endif (JAVA_FOUND AND EXISTS ${Java_AIINTERFACE_SRC})
 

Modified: branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h	2008-11-01 12:37:21 UTC (rev 6942)
@@ -230,8 +230,7 @@
 	const char* ret_outData;
 };
 
-struct SSendStartPosCommand ///&lt; result of HandleCommand is 1 - ok supported
-{
+struct SSendStartPosCommand {///&lt; result of HandleCommand is 1 - ok supported
 	bool ready;
 	struct SAIFloat3 pos;
 };
@@ -563,7 +562,7 @@
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
-	int timeOut; // command execution-time in ?seconds?
+	int timeOut; // command execution-time in ?milli-seconds?
 
 	int* toLoadUnitIds;
 	int numToLoadUnits;
@@ -789,7 +788,7 @@
 /**
  * @brief Allocates memory for a C Command struct
  */
-void* mallocSUnitCommand(int unitId, int groupId, const Command* c, int sCommandId[0]);
+void* mallocSUnitCommand(int unitId, int groupId, const Command* c, int* sCommandId);
 /**
  * @brief Frees memory of a C Command struct
  */

Modified: branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/LegacyCppWrapper/AIAICallback.cpp	2008-11-01 12:37:21 UTC (rev 6942)
@@ -614,25 +614,26 @@
 }
 
 
+/*
 const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
 	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
-int ids[numCmds];
-const char* names[numCmds];
-const char* toolTips[numCmds];
-bool showUniques[numCmds];
-bool disableds[numCmds];
-int numParams[numCmds];
-const char** params[numCmds];
-sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
-sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
-sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
-sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
-sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
-sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
-for (int c=0; c &lt; numCmds; c++) {
-	params[c] = new const char*[numParams[c]];
-}
-sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, params);
+	int ids[numCmds];
+	const char* names[numCmds];
+	const char* toolTips[numCmds];
+	bool showUniques[numCmds];
+	bool disableds[numCmds];
+	int numParams[numCmds];
+	const char** params[numCmds];
+	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
+	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
+	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
+	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
+	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
+	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
+	for (int c=0; c &lt; numCmds; c++) {
+		params[c] = new const char*[numParams[c]];
+	}
+	sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, params);
 	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
 	for (int c=0; c &lt; numCmds; c++) {
 		CommandDescription commandDescription;
@@ -655,29 +656,75 @@
 	
 	return cmdDescVec;
 }
+*/
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
+	
+	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
+	
+	int ids[numCmds];
+	const char* names[numCmds];
+	const char* toolTips[numCmds];
+	bool showUniques[numCmds];
+	bool disableds[numCmds];
+	int numParams[numCmds];
+	
+	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
+	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
+	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
+	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
+	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
+	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
+	
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		const char* params[numParams[c]];
+		sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, c, params);
+		
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+	
+	// to prevent memory wholes
+	if (groupPossibleCommands[groupId] != NULL) {
+		delete groupPossibleCommands[groupId];
+	}
+	groupPossibleCommands[groupId] = cmdDescVec;
+	
+	return cmdDescVec;
+}
 
 
 const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+	
 	int numCmds = sAICallback-&gt;Unit_getNumSupportedCommands(teamId, unitId);
-int* ids = new int[numCmds];
-const char* names[numCmds];
-const char* toolTips[numCmds];
-bool showUniques[numCmds];
-bool disableds[numCmds];
-int numParams[numCmds];
-const char** params[numCmds];
-sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
-sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
-sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
-sAICallback-&gt;Unit_SupportedCommands_isShowUnique(teamId, unitId, showUniques);
-sAICallback-&gt;Unit_SupportedCommands_isDisabled(teamId, unitId, disableds);
-sAICallback-&gt;Unit_SupportedCommands_getNumParams(teamId, unitId, numParams);
-for (int c=0; c &lt; numCmds; c++) {
-	params[c] = new const char*[numParams[c]];
-}
-sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, params);
+	
+	int* ids = new int[numCmds];
+	const char* names[numCmds];
+	const char* toolTips[numCmds];
+	bool showUniques[numCmds];
+	bool disableds[numCmds];
+	int numParams[numCmds];
+	
+	sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
+	sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
+	sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
+	sAICallback-&gt;Unit_SupportedCommands_isShowUnique(teamId, unitId, showUniques);
+	sAICallback-&gt;Unit_SupportedCommands_isDisabled(teamId, unitId, disableds);
+	sAICallback-&gt;Unit_SupportedCommands_getNumParams(teamId, unitId, numParams);
+
 	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
 	for (int c=0; c &lt; numCmds; c++) {
+		const char* params[numParams[c]];
+		sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, c, params);
+		
 		CommandDescription commandDescription;
 		commandDescription.id = ids[c];
 		commandDescription.name = names[c];
@@ -685,7 +732,7 @@
 		commandDescription.showUnique = showUniques[c];
 		commandDescription.disabled = disableds[c];
 		for (int p=0; p &lt; numParams[c]; p++) {
-			commandDescription.params.push_back(params[c][p]);
+			commandDescription.params.push_back(params[p]);
 		}
 		cmdDescVec-&gt;push_back(commandDescription);
 	}
@@ -700,32 +747,34 @@
 }
 
 const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+
 	int numCmds = sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
-int ids[numCmds];
-unsigned char options[numCmds];
-unsigned int tags[numCmds];
-int timeOuts[numCmds];
-int numParams[numCmds];
-float* params[numCmds];
-sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
-sAICallback-&gt;Unit_CurrentCommands_getIds(teamId, unitId, ids);
-sAICallback-&gt;Unit_CurrentCommands_getOptions(teamId, unitId, options);
-sAICallback-&gt;Unit_CurrentCommands_getTag(teamId, unitId, tags);
-sAICallback-&gt;Unit_CurrentCommands_getTimeOut(teamId, unitId, timeOuts);
-sAICallback-&gt;Unit_CurrentCommands_getNumParams(teamId, unitId, numParams);
-for (int c=0; c &lt; numCmds; c++) {
-	params[c] = new float[numParams[c]];
-}	
-sAICallback-&gt;Unit_CurrentCommands_getParams(teamId, unitId, params);
+
+	int ids[numCmds];
+	unsigned char options[numCmds];
+	unsigned int tags[numCmds];
+	int timeOuts[numCmds];
+	int numParams[numCmds];
+
+	sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+	sAICallback-&gt;Unit_CurrentCommands_getIds(teamId, unitId, ids);
+	sAICallback-&gt;Unit_CurrentCommands_getOptions(teamId, unitId, options);
+	sAICallback-&gt;Unit_CurrentCommands_getTag(teamId, unitId, tags);
+	sAICallback-&gt;Unit_CurrentCommands_getTimeOut(teamId, unitId, timeOuts);
+	sAICallback-&gt;Unit_CurrentCommands_getNumParams(teamId, unitId, numParams);
+
 	CCommandQueue* cc = new CCommandQueue();
 	for (int c=0; c &lt; numCmds; c++) {
+		float params[numParams[c]];
+		sAICallback-&gt;Unit_CurrentCommands_getParams(teamId, unitId, c, params);
+
 		Command command;
 		command.id = ids[c];
 		command.options = options[c];
 		command.tag = tags[c];
 		command.timeOut = timeOuts[c];
 		for (int p=0; p &lt; numParams[c]; p++) {
-			command.params.push_back(params[c][p]);
+			command.params.push_back(params[p]);
 		}
 		cc-&gt;push_back(command);
 	}
@@ -1050,11 +1099,13 @@
 }
 {
 	int size = sAICallback-&gt;UnitDef_getNumCustomParams(teamId, unitDefId);
-	const char* cMap[size][2];
-	sAICallback-&gt;UnitDef_getCustomParams(teamId, unitDefId, cMap);
+	const char* cKeys[size];
+	const char* cValues[size];
+	sAICallback-&gt;UnitDef_getCustomParamKeys(teamId, unitDefId, cKeys);
+	sAICallback-&gt;UnitDef_getCustomParamValues(teamId, unitDefId, cValues);
 	int i;
 	for (i=0; i &lt; size; ++i) {
-		unitDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+		unitDef-&gt;customParams[cKeys[i]] = cValues[i];
 	}
 }
 if (sAICallback-&gt;UnitDef_hasMoveData(teamId, unitDefId)) {
@@ -1323,13 +1374,20 @@
 }
 
 int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+	
 	SAIFloat3* positions = new SAIFloat3[maxPoints];
-	unsigned char** colors = new unsigned char*[maxPoints];
+//	unsigned char** colors = new unsigned char*[maxPoints];
+	SAIFloat3* colors = new SAIFloat3[maxPoints];
 	const char** labels = new const char*[maxPoints];
+	
 	int numPoints = sAICallback-&gt;Map_getPoints(teamId, positions, colors, labels, maxPoints);
 	for (int i=0; i &lt; numPoints; ++i) {
 		pm[i].pos = float3(positions[i]);
-		pm[i].color = colors[i];
+		//pm[i].color = colors[i];
+		pm[i].color = (unsigned char*) calloc(3, sizeof(unsigned char));
+		pm[i].color[0] = (unsigned char) colors[i].x;
+		pm[i].color[1] = (unsigned char) colors[i].y;
+		pm[i].color[2] = (unsigned char) colors[i].z;
 		pm[i].label = labels[i];
 	}
 	delete [] positions;
@@ -1339,14 +1397,19 @@
 }
 
 int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+	
 	SAIFloat3* firstPositions = new SAIFloat3[maxLines];
 	SAIFloat3* secondPositions = new SAIFloat3[maxLines];
-	unsigned char** colors = new unsigned char*[maxLines];
+	SAIFloat3* colors = new SAIFloat3[maxLines];
+	
 	int numLines = sAICallback-&gt;Map_getLines(teamId, firstPositions, secondPositions, colors, maxLines);
 	for (int i=0; i &lt; numLines; ++i) {
 		lm[i].pos = float3(firstPositions[i]);
 		lm[i].pos2 = float3(secondPositions[i]);
-		lm[i].color = colors[i];
+		lm[i].color = (unsigned char*) calloc(3, sizeof(unsigned char));
+		lm[i].color[0] = (unsigned char) colors[i].x;
+		lm[i].color[1] = (unsigned char) colors[i].y;
+		lm[i].color[2] = (unsigned char) colors[i].z;
 	}
 	delete [] firstPositions;
 	delete [] secondPositions;
@@ -1442,11 +1505,13 @@
 {
 	int size = sAICallback-&gt;FeatureDef_getNumCustomParams(teamId, featureDefId);
 	featureDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
-	const char* cMap[size][2];
-	sAICallback-&gt;FeatureDef_getCustomParams(teamId, featureDefId, cMap);
+	const char* cKeys[size];
+	const char* cValues[size];
+	sAICallback-&gt;FeatureDef_getCustomParamKeys(teamId, featureDefId, cKeys);
+	sAICallback-&gt;FeatureDef_getCustomParamValues(teamId, featureDefId, cValues);
 	int i;
 	for (i=0; i &lt; size; ++i) {
-		featureDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+		featureDef-&gt;customParams[cKeys[i]] = cValues[i];
 	}
 }
 	if (featureDefs[featureDefId] != NULL) {
@@ -1684,14 +1749,16 @@
 ////		free(entry);
 //	}
 //	const char*** cMap = (const char***) malloc(size*2*sizeof(char*));
-	const char* cMap[size][2];
-	sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId, cMap);
+	const char* cKeys[size];
+	const char* cValues[size];
+	sAICallback-&gt;WeaponDef_getCustomParamKeys(teamId, weaponDefId, cKeys);
+	sAICallback-&gt;WeaponDef_getCustomParamValues(teamId, weaponDefId, cValues);
 //	logT(&quot;GetWeaponDefById 8&quot;);
 //	logI(&quot;GetWeaponDefById 8 size: %d&quot;, size);
 	int i;
 	for (i=0; i &lt; size; ++i) {
 //	logI(&quot;GetWeaponDefById 8 i: %d&quot;, i);
-		weaponDef-&gt;customParams[cMap[i][0]] = cMap[i][1];
+		weaponDef-&gt;customParams[cKeys[i]] = cValues[i];
 	}
 //	free(cMap);
 }

Modified: branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h	2008-11-01 12:37:21 UTC (rev 6942)
@@ -112,7 +112,7 @@
 
 
 // BEGINN OBJECT UnitDef
-int (CALLING_CONV *UnitDef_STATIC_getIds)(int teamId, int* unitDefIds);
+int (CALLING_CONV *UnitDef_STATIC_getIds)(int teamId, int unitDefIds[]);
 int (CALLING_CONV *UnitDef_STATIC_getNumIds)(int teamId);
 int (CALLING_CONV *UnitDef_STATIC_getIdByName)(int teamId, const char* unitName);
 
@@ -254,7 +254,7 @@
 float (CALLING_CONV *UnitDef_getMaxElevator)(int teamId, int unitDefId);
 float (CALLING_CONV *UnitDef_getMaxRudder)(int teamId, int unitDefId);
 ///* returned size is 4 */
-//const unsigned char** (CALLING_CONV *UnitDef_getYardMaps)(int teamId, int unitDefId);
+//const unsigned char*[] (CALLING_CONV *UnitDef_getYardMaps)(int teamId, int unitDefId);
 int (CALLING_CONV *UnitDef_getXSize)(int teamId, int unitDefId);
 int (CALLING_CONV *UnitDef_getYSize)(int teamId, int unitDefId);
 int (CALLING_CONV *UnitDef_getBuildAngle)(int teamId, int unitDefId);
@@ -326,9 +326,11 @@
 int (CALLING_CONV *UnitDef_getShieldWeaponDefId)(int teamId, int unitDefId);
 int (CALLING_CONV *UnitDef_getStockpileWeaponDefId)(int teamId, int unitDefId);
 int (CALLING_CONV *UnitDef_getNumBuildOptions)(int teamId, int unitDefId);
-int (CALLING_CONV *UnitDef_getBuildOptions)(int teamId, int unitDefId, int* unitDefIds);
+int (CALLING_CONV *UnitDef_getBuildOptions)(int teamId, int unitDefId, int unitDefIds[]);
 int (CALLING_CONV *UnitDef_getNumCustomParams)(int teamId, int unitDefId);
-int (CALLING_CONV *UnitDef_getCustomParams)(int teamId, int unitDefId, const char* map[][2]);
+//int (CALLING_CONV *UnitDef_getCustomParams)(int teamId, int unitDefId, const char* map[][2]);
+int (CALLING_CONV *UnitDef_getCustomParamKeys)(int teamId, int unitDefId, const char* keys[]);
+int (CALLING_CONV *UnitDef_getCustomParamValues)(int teamId, int unitDefId, const char* values[]);
 bool (CALLING_CONV *UnitDef_hasMoveData)(int teamId, int unitDefId);
 /* enum MoveType { Ground_Move, Hover_Move, Ship_Move }; */
 int (CALLING_CONV *UnitDef_MoveData_getMoveType)(int teamId, int unitDefId);
@@ -360,14 +362,14 @@
 
 
 // BEGINN OBJECT Unit
-int (CALLING_CONV *Unit_STATIC_getEnemies)(int teamId, int* unitIds);
-int (CALLING_CONV *Unit_STATIC_getEnemiesIn)(int teamId, int* unitIds, struct SAIFloat3 pos, float radius);
-int (CALLING_CONV *Unit_STATIC_getEnemiesInRadarAndLos)(int teamId, int* units);
-int (CALLING_CONV *Unit_STATIC_getFriendlies)(int teamId, int* unitIds);
-int (CALLING_CONV *Unit_STATIC_getFriendliesIn)(int teamId, int* unitIds, struct SAIFloat3 pos, float radius);
-int (CALLING_CONV *Unit_STATIC_getNeutrals)(int teamId, int* unitIds);
-int (CALLING_CONV *Unit_STATIC_getNeutralsIn)(int teamId, int* unitIds, struct SAIFloat3 pos, float radius);
-int (CALLING_CONV *Unit_STATIC_getSelected)(int teamId, int* unitIds);
+int (CALLING_CONV *Unit_STATIC_getEnemies)(int teamId, int unitIds[]);
+int (CALLING_CONV *Unit_STATIC_getEnemiesIn)(int teamId, int unitIds[], struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Unit_STATIC_getEnemiesInRadarAndLos)(int teamId, int unitIds[]);
+int (CALLING_CONV *Unit_STATIC_getFriendlies)(int teamId, int unitIds[]);
+int (CALLING_CONV *Unit_STATIC_getFriendliesIn)(int teamId, int unitIds[], struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Unit_STATIC_getNeutrals)(int teamId, int unitIds[]);
+int (CALLING_CONV *Unit_STATIC_getNeutralsIn)(int teamId, int unitIds[], struct SAIFloat3 pos, float radius);
+int (CALLING_CONV *Unit_STATIC_getSelected)(int teamId, int unitIds[]);
 
 int (CALLING_CONV *Unit_getDefId)(int teamId, int unitId);
 int (CALLING_CONV *Unit_getAiHint)(int teamId, int unitId);
@@ -386,21 +388,23 @@
 /* for the type of the command queue, see CCommandQueue::CommandQueueType CommandQueue.h */
 int (CALLING_CONV *Unit_CurrentCommands_getType)(int teamId, int unitId);
 /* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
-int (CALLING_CONV *Unit_CurrentCommands_getIds)(int teamId, int unitId, int* ids);
-int (CALLING_CONV *Unit_CurrentCommands_getOptions)(int teamId, int unitId, unsigned char* options);
-int (CALLING_CONV *Unit_CurrentCommands_getTag)(int teamId, int unitId, unsigned int* tags);
-int (CALLING_CONV *Unit_CurrentCommands_getTimeOut)(int teamId, int unitId, int* timeOuts);
-int (CALLING_CONV *Unit_CurrentCommands_getNumParams)(int teamId, int unitId, int* numParams);
-int (CALLING_CONV *Unit_CurrentCommands_getParams)(int teamId, int unitId, float** params);
+int (CALLING_CONV *Unit_CurrentCommands_getIds)(int teamId, int unitId, int ids[]);
+int (CALLING_CONV *Unit_CurrentCommands_getOptions)(int teamId, int unitId, unsigned char options[]);
+int (CALLING_CONV *Unit_CurrentCommands_getTag)(int teamId, int unitId, unsigned int tags[]);
+int (CALLING_CONV *Unit_CurrentCommands_getTimeOut)(int teamId, int unitId, int timeOuts[]);
+int (CALLING_CONV *Unit_CurrentCommands_getNumParams)(int teamId, int unitId, int numParams[]);
+//int (CALLING_CONV *Unit_CurrentCommands_getParams)(int teamId, int unitId, float params[][2]);
+int (CALLING_CONV *Unit_CurrentCommands_getParams)(int teamId, int unitId, unsigned int commandIndex, float params[]);
 int (CALLING_CONV *Unit_getNumSupportedCommands)(int teamId, int unitId);
 /* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
-int (CALLING_CONV *Unit_SupportedCommands_getId)(int teamId, int unitId, int* ids);
-int (CALLING_CONV *Unit_SupportedCommands_getName)(int teamId, int unitId, const char** names);
-int (CALLING_CONV *Unit_SupportedCommands_getToolTip)(int teamId, int unitId, const char** toolTips);
-int (CALLING_CONV *Unit_SupportedCommands_isShowUnique)(int teamId, int unitId, bool* showUniques);
-int (CALLING_CONV *Unit_SupportedCommands_isDisabled)(int teamId, int unitId, bool* disableds);
-int (CALLING_CONV *Unit_SupportedCommands_getNumParams)(int teamId, int unitId, int* numParams);
-int (CALLING_CONV *Unit_SupportedCommands_getParams)(int teamId, int unitId, const char*** params);
+int (CALLING_CONV *Unit_SupportedCommands_getId)(int teamId, int unitId, int ids[]);
+int (CALLING_CONV *Unit_SupportedCommands_getName)(int teamId, int unitId, const char* names[]);
+int (CALLING_CONV *Unit_SupportedCommands_getToolTip)(int teamId, int unitId, const char* toolTips[]);
+int (CALLING_CONV *Unit_SupportedCommands_isShowUnique)(int teamId, int unitId, bool showUniques[]);
+int (CALLING_CONV *Unit_SupportedCommands_isDisabled)(int teamId, int unitId, bool disableds[]);
+int (CALLING_CONV *Unit_SupportedCommands_getNumParams)(int teamId, int unitId, int numParams[]);
+//int (CALLING_CONV *Unit_SupportedCommands_getParams)(int teamId, int unitId, const char* params[][2]);
+int (CALLING_CONV *Unit_SupportedCommands_getParams)(int teamId, int unitId, unsigned int commandIndex, const char* params[]);
 float (CALLING_CONV *Unit_getHealth)(int teamId, int unitId);
 float (CALLING_CONV *Unit_getSpeed)(int teamId, int unitId);
 float (CALLING_CONV *Unit_getPower)(int teamId, int unitId);
@@ -421,13 +425,14 @@
 // BEGINN OBJECT Group
 int (CALLING_CONV *Group_getNumSupportedCommands)(int teamId, int groupId);
 /* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
-int (CALLING_CONV *Group_SupportedCommands_getId)(int teamId, int groupId, int* ids);
-int (CALLING_CONV *Group_SupportedCommands_getName)(int teamId, int groupId, const char** names);
-int (CALLING_CONV *Group_SupportedCommands_getToolTip)(int teamId, int groupId, const char** toolTips);
-int (CALLING_CONV *Group_SupportedCommands_isShowUnique)(int teamId, int groupId, bool* showUniques);
-int (CALLING_CONV *Group_SupportedCommands_isDisabled)(int teamId, int groupId, bool* disableds);
-int (CALLING_CONV *Group_SupportedCommands_getNumParams)(int teamId, int groupId, int* numParams);
-int (CALLING_CONV *Group_SupportedCommands_getParams)(int teamId, int groupId, const char*** params);
+int (CALLING_CONV *Group_SupportedCommands_getId)(int teamId, int groupId, int ids[]);
+int (CALLING_CONV *Group_SupportedCommands_getName)(int teamId, int groupId, const char* names[]);
+int (CALLING_CONV *Group_SupportedCommands_getToolTip)(int teamId, int groupId, const char* toolTips[]);
+int (CALLING_CONV *Group_SupportedCommands_isShowUnique)(int teamId, int groupId, bool showUniques[]);
+int (CALLING_CONV *Group_SupportedCommands_isDisabled)(int teamId, int groupId, bool disableds[]);
+int (CALLING_CONV *Group_SupportedCommands_getNumParams)(int teamId, int groupId, int numParams[]);
+//int (CALLING_CONV *Group_SupportedCommands_getParams)(int teamId, int groupId, const char* params[][2]);
+int (CALLING_CONV *Group_SupportedCommands_getParams)(int teamId, int groupId, unsigned int commandIndex, const char* params[]);
 // END OBJECT Group
 
 
@@ -460,8 +465,10 @@
 float (CALLING_CONV *Map_getMaxWind)(int teamId);
 float (CALLING_CONV *Map_getTidalStrength)(int teamId);
 float (CALLING_CONV *Map_getGravity)(int teamId);
-int (CALLING_CONV *Map_getPoints)(int teamId, struct SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints);
-int (CALLING_CONV *Map_getLines)(int teamId, struct SAIFloat3* firstPositions, struct SAIFloat3* secondPositions, unsigned char** colors, int maxLines);
+//int (CALLING_CONV *Map_getPoints)(int teamId, struct SAIFloat3 positions[], unsigned char colors[][3], const char* labels[], int maxPoints);
+//int (CALLING_CONV *Map_getLines)(int teamId, struct SAIFloat3 firstPositions[], struct SAIFloat3 secondPositions[], unsigned char colors[][3], int maxLines);
+int (CALLING_CONV *Map_getPoints)(int teamId, struct SAIFloat3 positions[], struct SAIFloat3 colors[], const char* labels[], int maxPoints);
+int (CALLING_CONV *Map_getLines)(int teamId, struct SAIFloat3 firstPositions[], struct SAIFloat3 secondPositions[], struct SAIFloat3 colors[], int maxLines);
 bool (CALLING_CONV *Map_canBuildAt)(int teamId, int unitDefId, struct SAIFloat3 pos, int facing);
 struct SAIFloat3 (CALLING_CONV *Map_findClosestBuildSite)(int teamId, int unitDefId, struct SAIFloat3 pos, float searchRadius, int minDist, int facing);
 // BEGINN OBJECT Map
@@ -479,10 +486,10 @@
 float (CALLING_CONV *FeatureDef_getMaxHealth)(int teamId, int weaponDefId);
 float (CALLING_CONV *FeatureDef_getReclaimTime)(int teamId, int weaponDefId);
 float (CALLING_CONV *FeatureDef_getMass)(int teamId, int weaponDefId);
-const char* (CALLING_CONV *FeatureDef_getCollisionVolumeType)(int teamId, int weaponDefId);	
-struct SAIFloat3 (CALLING_CONV *FeatureDef_getCollisionVolumeScales)(int teamId, int weaponDefId);		
-struct SAIFloat3 (CALLING_CONV *FeatureDef_getCollisionVolumeOffsets)(int teamId, int weaponDefId);		
-int (CALLING_CONV *FeatureDef_getCollisionVolumeTest)(int teamId, int weaponDefId);			
+const char* (CALLING_CONV *FeatureDef_getCollisionVolumeType)(int teamId, int weaponDefId);
+struct SAIFloat3 (CALLING_CONV *FeatureDef_getCollisionVolumeScales)(int teamId, int weaponDefId);
+struct SAIFloat3 (CALLING_CONV *FeatureDef_getCollisionVolumeOffsets)(int teamId, int weaponDefId);
+int (CALLING_CONV *FeatureDef_getCollisionVolumeTest)(int teamId, int weaponDefId);
 bool (CALLING_CONV *FeatureDef_isUpright)(int teamId, int weaponDefId);
 int (CALLING_CONV *FeatureDef_getDrawType)(int teamId, int weaponDefId);
 const char* (CALLING_CONV *FeatureDef_getModelName)(int teamId, int weaponDefId);
@@ -501,7 +508,9 @@
 int (CALLING_CONV *FeatureDef_getXsize)(int teamId, int weaponDefId);
 int (CALLING_CONV *FeatureDef_getYsize)(int teamId, int weaponDefId);
 int (CALLING_CONV *FeatureDef_getNumCustomParams)(int teamId, int weaponDefId);
-int (CALLING_CONV *FeatureDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+//int (CALLING_CONV *FeatureDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+int (CALLING_CONV *FeatureDef_getCustomParamKeys)(int teamId, int weaponDefId, const char* keys[]);
+int (CALLING_CONV *FeatureDef_getCustomParamValues)(int teamId, int weaponDefId, const char* values[]);
 // END OBJECT FeatureDef
 
 
@@ -544,7 +553,7 @@
 float (CALLING_CONV *WeaponDef_Damages_getCraterBoost)(int teamId, int weaponDefId);
 int (CALLING_CONV *WeaponDef_Damages_getNumTypes)(int teamId, int weaponDefId);
 //float (CALLING_CONV *WeaponDef_Damages_getType)(int teamId, int weaponDefId, int typeIndex);
-void (CALLING_CONV *WeaponDef_Damages_getTypeDamages)(int teamId, int weaponDefId, float* typeDamages);
+void (CALLING_CONV *WeaponDef_Damages_getTypeDamages)(int teamId, int weaponDefId, float typeDamages[]);
 
 float (CALLING_CONV *WeaponDef_getAreaOfEffect)(int teamId, int weaponDefId);
 bool (CALLING_CONV *WeaponDef_isNoSelfDamage)(int teamId, int weaponDefId);
@@ -653,8 +662,10 @@
 float (CALLING_CONV *WeaponDef_getDynDamageRange)(int teamId, int weaponDefId);
 bool (CALLING_CONV *WeaponDef_isDynDamageInverted)(int teamId, int weaponDefId);
 int (CALLING_CONV *WeaponDef_getNumCustomParams)(int teamId, int weaponDefId);
-//const char** (CALLING_CONV *WeaponDef_getCustomParam)(int teamId, int weaponDefId, int index);
-int (CALLING_CONV *WeaponDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+//const char*[] (CALLING_CONV *WeaponDef_getCustomParam)(int teamId, int weaponDefId, int index);
+//int (CALLING_CONV *WeaponDef_getCustomParams)(int teamId, int weaponDefId, const char* map[][2]);
+int (CALLING_CONV *WeaponDef_getCustomParamKeys)(int teamId, int weaponDefId, const char* keys[]);
+int (CALLING_CONV *WeaponDef_getCustomParamValues)(int teamId, int weaponDefId, const char* values[]);
 // END OBJECT WeaponDef
 
 };
@@ -663,11 +674,10 @@
 }	// extern &quot;C&quot;
 #endif
 
-
-#ifdef	__cplusplus
+#if defined __cplusplus &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 class IGlobalAICallback;
 SAICallback* initSAICallback(int teamId, IGlobalAICallback* aiGlobalCallback);
-#endif	// __cplusplus
+#endif	// defined __cplusplus &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 
+#endif	// _SAICALLBACK_H
 
-#endif	// _SAICALLBACK_H

Modified: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.cpp	2008-11-01 12:37:21 UTC (rev 6942)
@@ -15,6 +15,7 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
+#if !defined BUILDING_AI
 #include &quot;SAIInterfaceLibrary.h&quot;
 
 #include &lt;string.h&gt;
@@ -131,5 +132,5 @@
 	return empty;
 }
 
-#endif /* __cplusplus */
-
+#endif	// __cplusplus
+#endif	// !defined BUILDING_AI

Modified: branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAIInterfaceLibrary.h	2008-11-01 12:37:21 UTC (rev 6942)
@@ -17,6 +17,7 @@
 
 #ifndef _SAIINTERFACELIBRARY_H
 #define	_SAIINTERFACELIBRARY_H
+#if !defined BUILDING_AI
 
 #include &quot;creg/creg_cond.h&quot;
 
@@ -227,4 +228,5 @@
 };
 #endif	// __cplusplus
 
+#endif	// !defined BUILDING_AI
 #endif	// _SAIINTERFACELIBRARY_H

Modified: branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.cpp	2008-11-01 12:37:21 UTC (rev 6942)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -21,6 +21,7 @@
 #include &lt;stdlib.h&gt;
 
 
+#if !defined BUILDING_AI
 struct SGAISpecifier copySGAISpecifier(const struct SGAISpecifier* const orig) {
 	
 	struct SGAISpecifier copy;
@@ -70,4 +71,5 @@
 	return empty;
 }
 
-#endif /* __cplusplus */
+#endif	// defined __cplusplus
+#endif	// !defined BUILDING_AI

Modified: branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SGAILibrary.h	2008-11-01 12:37:21 UTC (rev 6942)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -38,6 +38,7 @@
 #define GROUP_AI_PROPERTY_INTERFACE_SHORT_NAME &quot;interfaceShortName&quot; // [string: [a-zA-Z0-9_.]*] this interface has to be used to load the AI
 #define GROUP_AI_PROPERTY_INTERFACE_VERSION &quot;interfaceVersion&quot;      // [string: [a-zA-Z0-9_.]*] the interface version number the AI was compiled, but may work with newer or older ones too
 
+#if !defined BUILDING_AI
 /**
  * @brief struct Group Artificial Intelligence Specifier
  */
@@ -49,6 +50,21 @@
 struct SGAISpecifier copySGAISpecifier(const struct SGAISpecifier* const orig);
 void deleteSGAISpecifier(const struct SGAISpecifier* const spec);
 
+#if defined __cplusplus
+struct SGAISpecifier_Comparator {
+	/**
+	 * The key comparison function, a Strict Weak Ordering;
+	 * it returns true if its first argument is less
+	 * than its second argument, and false otherwise.
+	 * This is also defined as map::key_compare.
+	 */
+	bool operator()(const struct SGAISpecifier&amp; a,
+			const struct SGAISpecifier&amp; b) const;
+	static bool IsEmpty(const struct SGAISpecifier&amp; spec);
+};
+#endif	// defined __cplusplus
+#endif	// !defined BUILDING_AI
+
 /**
  * This is the interface between the engine and an implementation of a Group AI.
  *
@@ -185,18 +201,4 @@
 }	// extern &quot;C&quot;
 #endif
 
-#ifdef	__cplusplus
-struct SGAISpecifier_Comparator {
-	/**
-	 * The key comparison function, a Strict Weak Ordering;
-	 * it returns true if its first argument is less
-	 * than its second argument, and false otherwise.
-	 * This is also defined as map::key_compare.
-	 */
-	bool operator()(const struct SGAISpecifier&amp; a,
-			const struct SGAISpecifier&amp; b) const;
-	static bool IsEmpty(const struct SGAISpecifier&amp; spec);
-};
-#endif	// __cplusplus
-
 #endif	// _SGAILIBRARY_H

Modified: branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SOption.cpp	2008-11-01 12:37:21 UTC (rev 6942)
@@ -28,8 +28,6 @@
 
 #include &lt;set&gt;
 
-static const char* badKeyChars = &quot; =;\r\n\t&quot;;
-
 bool ParseOption(const LuaTable&amp; root, int index, Option&amp; opt, std::set&lt;std::string&gt; optionsSet)
 {
 	const LuaTable&amp; optTbl = root.SubTable(index);
@@ -40,7 +38,7 @@
 	// common options properties
 	std::string opt_key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
 	if (opt_key.empty() ||
-	    (opt_key.find_first_of(badKeyChars) != std::string::npos)) {
+	    (opt_key.find_first_of(Option_badKeyChars) != std::string::npos)) {
 		return false;
 	}
 	opt_key = StringToLower(opt_key);
@@ -100,7 +98,7 @@
 			// string format
 			std::string item_key = listTbl.GetString(i, &quot;&quot;);
 			if (!item_key.empty() &amp;&amp;
-			    (item_key.find_first_of(badKeyChars) == string::npos)) {
+			    (item_key.find_first_of(Option_badKeyChars) == string::npos)) {
 				item.key = mallocCopyString(item_key.c_str());
 				item.name = item.key;
 				item.desc = item.name;
@@ -115,7 +113,7 @@
 			}
 			item_key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
 			if (item_key.empty() ||
-			    (item_key.find_first_of(badKeyChars) != string::npos)) {
+				(item_key.find_first_of(Option_badKeyChars) != string::npos)) {
 				return false;
 			}
 			item_key = StringToLower(item_key);

Modified: branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.cpp	2008-11-01 12:37:21 UTC (rev 6942)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -21,6 +21,7 @@
 #include &lt;stdlib.h&gt;
 
 
+#if !defined BUILDING_AI
 struct SSAISpecifier copySSAISpecifier(const struct SSAISpecifier* const orig) {
 	
 	struct SSAISpecifier copy;
@@ -70,4 +71,5 @@
 	return empty;
 }
 
-#endif /* __cplusplus */
+#endif	// defined __cplusplus
+#endif	// !defined BUILDING_AI

Modified: branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/Interface/SSAILibrary.h	2008-11-01 12:37:21 UTC (rev 6942)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -38,6 +38,7 @@
 #define SKIRMISH_AI_PROPERTY_INTERFACE_SHORT_NAME &quot;interfaceShortName&quot; // [string: [a-zA-Z0-9_.]*] this interface has to be used to load the AI
 #define SKIRMISH_AI_PROPERTY_INTERFACE_VERSION &quot;interfaceVersion&quot;      // [string: [a-zA-Z0-9_.]*] the interface version number the AI was compiled, but may work with newer or older ones too
 
+#if !defined BUILDING_AI
 /**
  * @brief struct Skirmish Artificial Intelligence Specifier
  */
@@ -49,7 +50,7 @@
 struct SSAISpecifier copySSAISpecifier(const struct SSAISpecifier* const orig);
 void deleteSSAISpecifier(const struct SSAISpecifier* const spec);
 
-#ifdef	__cplusplus
+#if defined __cplusplus
 struct SSAISpecifier_Comparator {
 	/**
 	 * The key comparison function, a Strict Weak Ordering;
@@ -61,7 +62,8 @@
 			const struct SSAISpecifier&amp; b) const;
 	static bool IsEmpty(const struct SSAISpecifier&amp; spec);
 };
-#endif /* __cplusplus */
+#endif	// defined __cplusplus
+#endif	// !defined BUILDING_AI
 
 /**
  * This is the interface between the engine and an implementation of a
@@ -200,4 +202,4 @@
 }
 #endif
 
-#endif	/* _SSAILIBRARY_H */
+#endif	// _SSAILIBRARY_H

Modified: branches/caiinterface/rts/ExternalAI/SAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-10-31 17:43:28 UTC (rev 6941)
+++ branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-11-01 12:37:21 UTC (rev 6942)
@@ -32,6 +32,7 @@
 bool team_cheatingEnabled[MAX_SKIRMISH_AIS];
 IAICheats* team_cheatCallback[MAX_SKIRMISH_AIS];
 
+/*
 int fillCMap(const std::map&lt;std::string,std::string&gt;* map, const char* cMap[][2]) {
 	std::map&lt;std::string,std::string&gt;::const_iterator it;
 	int i;
@@ -41,6 +42,23 @@
 	}
 	return i;
 }
+*/
+int fillCMapKeys(const std::map&lt;std::string,std::string&gt;* map, const char* cMapKeys[]) {
+	std::map&lt;std::string,std::string&gt;::const_iterator it;
+	int i;
+	for (i=0, it=map-&gt;begin(); it != map-&gt;end(); ++i, it++) {
+		cMapKeys[i] = it-&gt;first.c_str();
+	}
+	return i;
+}
+int fillCMapValues(const std::map&lt;std::string,std::string&gt;* map, const char* cMapValues[]) {
+	std::map&lt;std::string,std::string&gt;::const_iterator it;
+	int i;
+	for (i=0, it=map-&gt;begin(); it != map-&gt;end(); ++i, it++) {
+		cMapValues[i] = it-&gt;second.c_str();
+	}
+	return i;
+}
 void toFloatArr(const SAIFloat3* color, float alpha, float arrColor[4]) {
 	arrColor[0] = color-&gt;x;
 	arrColor[1] = color-&gt;y;
@@ -1767,9 +1785,19 @@
 Export(int) _UnitDef_getNumCustomParams(int teamId, int unitDefId) {
 	return getUnitDefById(teamId, unitDefId)-&gt;customParams.size();
 }
+/*
 Export(int) _UnitDef_getCustomParams(int teamId, int unitDefId, const char* map[][2]) {
 	return fillCMap(&amp;(getUnitDefById(teamId, unitDefId)-&gt;customParams), map);
 }
+*/
+// UNSAFE: because the map may not iterate over its elements in the same order every time
+Export(int) _UnitDef_getCustomParamKeys(int teamId, int unitDefId, const char* keys[]) {
+	return fillCMapKeys(&amp;(getUnitDefById(teamId, unitDefId)-&gt;customParams), keys);
+}
+// UNSAFE: because the map may not iterate over its elements in the same order every time
+Export(int) _UnitDef_getCustomParamValues(int teamId, int unitDefId, const char* values[]) {
+	return fillCMapValues(&amp;(getUnitDefById(teamId, unitDefId)-&gt;customParams), values);
+}
 Export(bool) _UnitDef_hasMoveData(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata != NULL;}
 Export(int) _UnitDef_MoveData_getMoveType(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveType;}
 Export(int) _UnitDef_MoveData_getMoveFamily(int teamId, int unitDefId) {return getUnitDefById(teamId, unitDefId)-&gt;movedata-&gt;moveFamily;}
@@ -1889,16 +1917,21 @@
 	}
 	return numComDescs;
 }
-Export(int) _Unit_SupportedCommands_getNumParams(int teamId, int unitId, int* numParams) {
+Export(int) _Unit_SupportedCommands_getNumParams(int teamId, int unitId, int numParams[]) {
+	
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	
 	int numComDescs = comDescs-&gt;size();
+	
 	for (int i=0; i &lt; numComDescs; i++) {
 		numParams[i] = comDescs-&gt;at(i).params.size();
 	}
+	
 	return numComDescs;
 }
-Export(int) _Unit_SupportedCommands_getParams(int teamId, int unitId, const char*** params) {
+/*
+Export(int) _Unit_SupportedCommands_getParams(int teamId, int unitId, const char* params[][2]) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
 	int numComDescs = comDescs-&gt;size();
@@ -1910,6 +1943,26 @@
 	}
 	return numComDescs;
 }
+*/
+Export(int) _Unit_SupportedCommands_getParams(int teamId, int unitId, unsigned int commandIndex, const char* params[]) {
+	
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetUnitCommands(unitId);
+	
+	if (commandIndex &gt;= comDescs-&gt;size()) {
+		return -1;
+	}
+	
+	const std::vector&lt;std::string&gt; ps = comDescs-&gt;at(commandIndex).params;
+	unsigned int size = ps.size();
+	
+	unsigned int p;
+	for (p=0; p &lt; size; p++) {
+		params[p] = ps.at(p).c_str();
+	}
+	
+	return size;
+}
 
 Export(int) _Unit_getStockpile(int teamId, int unitId) {
     IAICallback* clb = team_callback[teamId];
@@ -2040,9 +2093,8 @@
 	}
 	return numCommands;
 }
-Export(int) _Unit_CurrentCommands_getNumParams(int teamId, int unitId, int* numParams) {
-//	IAICallback* clb = team_callback[teamId];
-//	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
+Export(int) _Unit_CurrentCommands_getNumParams(int teamId, int unitId, int numParams[]) {
+	
 	const CCommandQueue* cc = NULL;
 	if (_Cheats_isEnabled(teamId)) {
 		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
@@ -2055,7 +2107,8 @@
 	}
 	return numCommands;
 }
-Export(int) _Unit_CurrentCommands_getParams(int teamId, int unitId, float** params) {
+/*
+Export(int) _Unit_CurrentCommands_getParams(int teamId, int unitId, float params[][]) {
 //	IAICallback* clb = team_callback[teamId];
 //	const CCommandQueue* cc = clb-&gt;GetCurrentUnitCommands(unitId);
 	const CCommandQueue* cc = NULL;
@@ -2073,7 +2126,31 @@
 	}
 	return numCommands;
 }
+*/
+Export(int) _Unit_CurrentCommands_getParams(int teamId, int unitId, unsigned int commandIndex, float params[]) {
 
+	const CCommandQueue* cc = NULL;
+	if (_Cheats_isEnabled(teamId)) {
+		cc = team_cheatCallback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	} else {
+		cc = team_callback[teamId]-&gt;GetCurrentUnitCommands(unitId);
+	}
+
+	if (commandIndex &gt;= cc-&gt;size()) {
+		return -1;
+	}
+
+	const std::vector&lt;float&gt; ps = cc-&gt;at(commandIndex).params;
+	unsigned int numParams = ps.size();
+
+	unsigned int p;
+	for (p=0; p &lt; numParams; p++) {
+		params[p] = ps.at(p);
+	}
+
+	return numParams;
+}
+
 Export(float) _Unit_getExperience(int teamId, int unitId) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetUnitExperience(unitId);
 	if (_Cheats_isEnabled(teamId)) {
@@ -2374,7 +2451,8 @@
 	return clb-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing).toSAIFloat3();
 }
 
-Export(int) _Map_getPoints(int teamId, SAIFloat3* positions, unsigned char** colors, const char** labels, int maxPoints) {
+/*
+Export(int) _Map_getPoints(int teamId, SAIFloat3 positions[], unsigned char colors[][3], const char* labels[], int maxPoints) {
 	IAICallback* clb = team_callback[teamId];
 	PointMarker* pm = new PointMarker[maxPoints];
 	int numPoints = clb-&gt;GetMapPoints(pm, maxPoints);
@@ -2387,7 +2465,7 @@
 	return numPoints;
 }
 
-Export(int) _Map_getLines(int teamId, SAIFloat3* firstPositions, SAIFloat3* secondPositions, unsigned char** colors, int maxLines) {
+Export(int) _Map_getLines(int teamId, SAIFloat3 firstPositions[], SAIFloat3 secondPositions[], unsigned char colors[][3], int maxLines) {
 	IAICallback* clb = team_callback[teamId];
 	LineMarker* lm = new LineMarker[maxLines];
 	int numLines = clb-&gt;GetMapLines(lm, maxLines);
@@ -2399,6 +2477,36 @@
 	delete [] lm;
 	return numLines;
 }
+*/
+Export(int) _Map_getPoints(int teamId, SAIFloat3 positions[], SAIFloat3 colors[], const char* labels[], int maxPoints) {
+	
+	IAICallback* clb = team_callback[teamId];
+	PointMarker* pm = new PointMarker[maxPoints];
+	int numPoints = clb-&gt;GetMapPoints(pm, maxPoints);
+	for (int i=0; i &lt; numPoints; ++i) {
+		positions[i] = pm[i].pos.toSAIFloat3();
+		SAIFloat3 f3color = {pm[i].color[0], pm[i].color[1], pm[i].color[2]};
+		colors[i] = f3color;
+		labels[i] = pm[i].label;
+	}
+	delete [] pm;
+	return numPoints;
+}
+
+Export(int) _Map_getLines(int teamId, SAIFloat3 firstPositions[], SAIFloat3 secondPositions[], SAIFloat3 colors[], int maxLines) {
+	
+	IAICallback* clb = team_callback[teamId];
+	LineMarker* lm = new LineMarker[maxLines];
+	int numLines = clb-&gt;GetMapLines(lm, maxLines);
+	for (int i=0; i &lt; numLines; ++i) {
+		firstPositions[i] = lm[i].pos.toSAIFloat3();
+		secondPositions[i] = lm[i].pos2.toSAIFloat3();
+		SAIFloat3 f3color = {lm[i].color[0], lm[i].color[1], lm[i].color[2]};
+		colors[i] = f3color;
+	}
+	delete [] lm;
+	return numLines;
+}
 //########### END Map
 
 
@@ -2511,9 +2619,19 @@
 Export(int) _FeatureDef_getNumCustomParams(int teamId, int featureDefId) {
 	return getFeatureDefById(teamId, featureDefId)-&gt;customParams.size();
 }
+/*
 Export(int) _FeatureDef_getCustomParams(int teamId, int featureDefId, const char* map[][2]) {
 	return fillCMap(&amp;(getFeatureDefById(teamId, featureDefId)-&gt;customParams), map);
 }
+*/
+// UNSAFE: because the map may not iterate over its elements in the same order every time
+Export(int) _FeatureDef_getCustomParamKeys(int teamId, int featureDefId, const char* keys[]) {
+	return fillCMapKeys(&amp;(getFeatureDefById(teamId, featureDefId)-&gt;customParams), keys);
+}
+// UNSAFE: because the map may not iterate over its elements in the same order every time
+Export(int) _FeatureDef_getCustomParamValues(int teamId, int featureDefId, const char* values[]) {
+	return fillCMapValues(&amp;(getFeatureDefById(teamId, featureDefId)-&gt;customParams), values);
+}
 //########### END FeatureDef
 
 Export(int) _Feature_getDefId(int teamId, int featureId) {
@@ -2708,9 +2826,19 @@
 Export(int) _WeaponDef_getNumCustomParams(int teamId, int weaponDefId) {
 	return getWeaponDefById(teamId, weaponDefId)-&gt;customParams.size();
 }
+/*
 Export(int) _WeaponDef_getCustomParams(int teamId, int weaponDefId, const char* map[][2]) {
 	return fillCMap(&amp;(getWeaponDefById(teamId, weaponDefId)-&gt;customParams), map);
 }
+*/
+// UNSAFE: because the map may not iterate over its elements in the same order every time
+Export(int) _WeaponDef_getCustomParamKeys(int teamId, int weaponDefId, const char* keys[]) {
+	return fillCMapKeys(&amp;(getWeaponDefById(teamId, weaponDefId)-&gt;customParams), keys);
+}
+// UNSAFE: because the map may not iterate over its elements in the same order every time
+Export(int) _WeaponDef_getCustomParamValues(int teamId, int weaponDefId, const char* values[]) {
+	return fillCMapValues(&amp;(getWeaponDefById(teamId, weaponDefId)-&gt;customParams), values);
+}
 //########### END WeaponDef
 
 
@@ -2831,7 +2959,8 @@
 	}
 	return numComDescs;
 }
-Export(int) _Group_SupportedCommands_getParams(int teamId, int groupId, const char*** params) {
+/*
+Export(int) _Group_SupportedCommands_getParams(int teamId, int groupId, const char* params[][2]) {
 	IAICallback* clb = team_callback[teamId];
 	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
 	int numComDescs = comDescs-&gt;size();
@@ -2843,6 +2972,26 @@
 	}
 	return numComDescs;
 }
+*/
+Export(int) _Group_SupportedCommands_getParams(int teamId, int groupId, unsigned int commandIndex, const char* params[]) {
+	
+	IAICallback* clb = team_callback[teamId];
+	const std::vector&lt;CommandDescription&gt;* comDescs = clb-&gt;GetGroupCommands(groupId);
+	
+	if (commandIndex &gt;= comDescs-&gt;size()) {
+		return -1;
+	}
+	
+	const std::vector&lt;std::string&gt; ps = comDescs-&gt;at(commandIndex).params;
+	unsigned int size = ps.size();
+	
+	unsigned int p;
+	for (p=0; p &lt; size; p++) {
+		params[p] = ps.at(p).c_str();
+	}
+	
+	return size;
+}
 
 /*
 Export(bool) _Unit_addToGroup(int teamId, int unitId, int groupId) {
@@ -3195,7 +3344,9 @@
 	sAICallback-&gt;UnitDef_getNumBuildOptions = _UnitDef_getNumBuildOptions;
 	sAICallback-&gt;UnitDef_getBuildOptions = _UnitDef_getBuildOptions;
 	sAICallback-&gt;UnitDef_getNumCustomParams = _UnitDef_getNumCustomParams;
-	sAICallback-&gt;UnitDef_getCustomParams = _UnitDef_getCustomParams;
+//	sAICallback-&gt;UnitDef_getCustomParams = _UnitDef_getCustomParams;
+	sAICallback-&gt;UnitDef_getCustomParamKeys = _UnitDef_getCustomParamKeys;
+	sAICallback-&gt;UnitDef_getCustomParamValues = _UnitDef_getCustomParamValues;
 	sAICallback-&gt;UnitDef_hasMoveData = _UnitDef_hasMoveData;
 	sAICallback-&gt;UnitDef_MoveData_getMoveType = _UnitDef_MoveData_getMoveType;
 	sAICallback-&gt;UnitDef_MoveData_getMoveFamily = _UnitDef_MoveData_getMoveFamily;
@@ -3334,7 +3485,9 @@
 	sAICallback-&gt;FeatureDef_getXsize = _FeatureDef_getXsize;
 	sAICallback-&gt;FeatureDef_getYsize = _FeatureDef_getYsize;
 	sAICallback-&gt;FeatureDef_getNumCustomParams = _FeatureDef_getNumCustomParams;
-	sAICallback-&gt;FeatureDef_getCustomParams = _FeatureDef_getCustomParams;
+//	sAICallback-&gt;FeatureDef_getCustomParams = _FeatureDef_getCustomParams;
+	sAICallback-&gt;FeatureDef_getCustomParamKeys = _FeatureDef_getCustomParamKeys;
+	sAICallback-&gt;FeatureDef_getCustomParamValues = _FeatureDef_getCustomParamValues;
 	sAICallback-&gt;Feature_STATIC_getIds = _Feature_STATIC_getIds;
 	sAICallback-&gt;Feature_STATIC_getIdsIn = _Feature_STATIC_getIdsIn;
 	sAICallback-&gt;Feature_getDefId = _Feature_getDefId;
@@ -3470,7 +3623,9 @@
 	sAICallback-&gt;WeaponDef_getDynDamageRange = _WeaponDef_getDynDamageRange;
 	sAICallback-&gt;WeaponDef_isDynDamageInverted = _WeaponDef_isDynDamageInverted;
 	sAICallback-&gt;WeaponDef_getNumCustomParams = _WeaponDef_getNumCustomParams;
-	sAICallback-&gt;WeaponDef_getCustomParams = _WeaponDef_getCustomParams;
+//	sAICallback-&gt;WeaponDef_getCustomParams = _WeaponDef_getCustomParams;
+	sAICallback-&gt;WeaponDef_getCustomParamKeys = _WeaponDef_getCustomParamKeys;
+	sAICallback-&gt;WeaponDef_getCustomParamValues = _WeaponDef_getCustomParamValues;
 	
 	team_globalCallback[teamId] = aiGlobalCallback;
 //	team_callback[teamId] = aiCallback;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="001712.html">[Taspring-linux-commit] r6943 - in branches/gmltest/rts: System	lib/gml
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1711">[ date ]</a>
              <a href="thread.html#1711">[ thread ]</a>
              <a href="subject.html#1711">[ subject ]</a>
              <a href="author.html#1711">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
