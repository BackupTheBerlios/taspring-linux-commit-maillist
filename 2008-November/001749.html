<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6980 - in branches/caiinterface:	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Weapons rts/System rts/build/vstudio8
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6980%20-%20in%20branches/caiinterface%3A%0A%09installer/builddata/springcontent/gamedata%20rts/Game%0A%09rts/Game/StartScripts%20rts/Game/UI%20rts/Lua%0A%09rts/Rendering/UnitModels%20rts/Sim/Misc%20rts/Sim/Projectiles%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Weapons%20rts/System%20rts/build/vstudio8&In-Reply-To=%3C20081105154417.D6E9D4763%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001748.html">
   <LINK REL="Next"  HREF="001750.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6980 - in branches/caiinterface:	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Weapons rts/System rts/build/vstudio8</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6980%20-%20in%20branches/caiinterface%3A%0A%09installer/builddata/springcontent/gamedata%20rts/Game%0A%09rts/Game/StartScripts%20rts/Game/UI%20rts/Lua%0A%09rts/Rendering/UnitModels%20rts/Sim/Misc%20rts/Sim/Projectiles%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Weapons%20rts/System%20rts/build/vstudio8&In-Reply-To=%3C20081105154417.D6E9D4763%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6980 - in branches/caiinterface:	installer/builddata/springcontent/gamedata rts/Game	rts/Game/StartScripts rts/Game/UI rts/Lua	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/Projectiles	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Weapons rts/System rts/build/vstudio8">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Wed Nov  5 16:44:17 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001748.html">[Taspring-linux-commit] r6979 - in branches/caiinterface:	AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/CSAILoader rts/ExternalAI rts/ExternalAI/Interface
</A></li>
        <LI>Next message: <A HREF="001750.html">[Taspring-linux-commit] r6981 - in branches/gmltest/rts/Game: . UI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1749">[ date ]</a>
              <a href="thread.html#1749">[ thread ]</a>
              <a href="subject.html#1749">[ subject ]</a>
              <a href="author.html#1749">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-11-05 16:44:16 +0100 (Wed, 05 Nov 2008)
New Revision: 6980

Added:
   branches/caiinterface/rts/Sim/Misc/CollisionVolume.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.h
   branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp
   branches/caiinterface/rts/Sim/Weapons/LightningCannon.h
Removed:
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h
   branches/caiinterface/rts/Sim/Weapons/LightingCannon.cpp
   branches/caiinterface/rts/Sim/Weapons/LightingCannon.h
Modified:
   branches/caiinterface/installer/builddata/springcontent/gamedata/weapondefs_post.lua
   branches/caiinterface/rts/Game/GameHelper.cpp
   branches/caiinterface/rts/Game/PreGame.cpp
   branches/caiinterface/rts/Game/PreGame.h
   branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp
   branches/caiinterface/rts/Game/StartScripts/SkirmishAITestScript.cpp
   branches/caiinterface/rts/Game/UI/GameInfo.cpp
   branches/caiinterface/rts/Game/UI/MiniMap.cpp
   branches/caiinterface/rts/Lua/LuaSyncedRead.cpp
   branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp
   branches/caiinterface/rts/Sim/Misc/CollisionHandler.h
   branches/caiinterface/rts/Sim/Misc/CollisionVolume.h
   branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp
   branches/caiinterface/rts/Sim/Misc/LosHandler.cpp
   branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/caiinterface/rts/Sim/Units/Unit.h
   branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitLoader.cpp
   branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp
   branches/caiinterface/rts/Sim/Weapons/WeaponDefHandler.cpp
   branches/caiinterface/rts/System/SpringApp.cpp
   branches/caiinterface/rts/build/vstudio8/rts.vcproj
Log:
reintegrated trunk up to 6979

Modified: branches/caiinterface/installer/builddata/springcontent/gamedata/weapondefs_post.lua
===================================================================
--- branches/caiinterface/installer/builddata/springcontent/gamedata/weapondefs_post.lua	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/installer/builddata/springcontent/gamedata/weapondefs_post.lua	2008-11-05 15:44:16 UTC (rev 6980)
@@ -59,7 +59,7 @@
       wd.weaponType = &quot;DGun&quot;
     elseif (tobool(wd.lineofsight)) then
       if (rendertype==7) then
-        wd.weapontype = &quot;LightingCannon&quot;;
+        wd.weapontype = &quot;LightningCannon&quot;;
 
       -- swta fix (outdated?)
       elseif (wd.model and wd.model:lower():find(&quot;laser&quot;,1,true)) then

Modified: branches/caiinterface/rts/Game/GameHelper.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/GameHelper.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -84,9 +84,9 @@
 	// position of its collision volume and &quot;unit radius&quot; by
 	// the volume's minimally-bounding sphere
 	//
-	float3 dif = (unit-&gt;midPos + unit-&gt;collisionVolume-&gt;axisOffsets) - expPos;
+	float3 dif = (unit-&gt;midPos + unit-&gt;collisionVolume-&gt;GetOffsets()) - expPos;
 	float expDist = dif.Length();
-	const float volRad = unit-&gt;collisionVolume-&gt;volumeBoundingRadius;
+	const float volRad = unit-&gt;collisionVolume-&gt;GetBoundingRadius();
 
 	expDist = std::max(expDist, volRad + 0.1f);
 
@@ -140,7 +140,7 @@
 	CollisionVolume* cv = feature-&gt;collisionVolume;
 
 	if (cv) {
-		float3 dif = (feature-&gt;midPos + cv-&gt;axisOffsets) - expPos;
+		float3 dif = (feature-&gt;midPos + cv-&gt;GetOffsets()) - expPos;
 		float expDist = std::max(dif.Length(), 0.1f);
 		float expMod = (expRad - expDist) / expRad;
 
@@ -149,7 +149,7 @@
 		// be damaged otherwise, even by BB shells)
 		// NOTE: this will also be only approximate
 		// for non-spherical volumes
-		if ((expRad &gt; 8.0f) &amp;&amp; (expDist &lt; (cv-&gt;volumeBoundingRadius * 1.1f)) &amp;&amp; (expMod &lt; 0.1f)) {
+		if ((expRad &gt; 8.0f) &amp;&amp; (expDist &lt; (cv-&gt;GetBoundingRadius() * 1.1f)) &amp;&amp; (expMod &lt; 0.1f)) {
 			expMod = 0.1f;
 		}
 		if (expMod &gt; 0.0f) {
@@ -250,7 +250,7 @@
 }
 
 
-// called by {CRifle, CBeamLaser, CLightingCannon}::Fire()
+// called by {CRifle, CBeamLaser, CLightningCannon}::Fire()
 float CGameHelper::TraceRay(const float3&amp; start, const float3&amp; dir, float length, float power, CUnit* owner, CUnit *&amp;hit, int collisionFlags)
 {
 	float groundLength = ground-&gt;LineGroundCol(start, start + dir * length);
@@ -353,7 +353,7 @@
 				(unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; (LOS_INLOS | LOS_CONTRADAR)) ||
 				(useRadar &amp;&amp; radarhandler-&gt;InRadar(unit, gu-&gt;myAllyTeam))) {
 
-				CollisionVolume* cv = 0x0;
+				const CollisionVolume* cv = NULL;
 
 				if (unit-&gt;isIcon) {
 					// for iconified units, just pretend the collision
@@ -406,10 +406,10 @@
 			if (u == exclude)
 				continue;
 
-			CollisionVolume* cv = u-&gt;collisionVolume;
+			const CollisionVolume* cv = u-&gt;collisionVolume;
 
 			if (gs-&gt;Ally(u-&gt;allyteam, allyteam) || (u-&gt;losStatus[allyteam] &amp; LOS_INLOS)) {
-				float3 dif = (u-&gt;midPos + cv-&gt;axisOffsets) - start;
+				float3 dif = (u-&gt;midPos + cv-&gt;GetOffsets()) - start;
 				float closeLength = dif.dot(dir);
 
 				if (closeLength &lt; 0)
@@ -419,13 +419,13 @@
 
 				float3 closeVect = dif - dir * closeLength;
 
-				if (closeVect.SqLength() &lt; cv-&gt;volumeBoundingRadiusSq) {
+				if (closeVect.SqLength() &lt; cv-&gt;GetBoundingRadiusSq()) {
 					length = closeLength;
 					hit = u;
 				}
 			} else if (useRadar &amp;&amp; radarhandler-&gt;InRadar(u, allyteam)) {
 				float3 dif =
-					(u-&gt;midPos + cv-&gt;axisOffsets) +
+					(u-&gt;midPos + cv-&gt;GetOffsets()) +
 					u-&gt;posErrorVector * radarhandler-&gt;radarErrorSize[allyteam] -
 					start;
 				float closeLength = dif.dot(dir);
@@ -437,7 +437,7 @@
 
 				float3 closeVect = dif - dir * closeLength;
 
-				if (closeVect.SqLength() &lt; cv-&gt;volumeBoundingRadiusSq) {
+				if (closeVect.SqLength() &lt; cv-&gt;GetBoundingRadiusSq()) {
 					length = closeLength;
 					hit = u;
 				}
@@ -767,7 +767,7 @@
 }
 
 
-// called by {CFlameThrower, CLaserCannon, CEmgCannon, CBeamLaser, CLightingCannon}::TryTarget()
+// called by {CFlameThrower, CLaserCannon, CEmgCannon, CBeamLaser, CLightningCannon}::TryTarget()
 bool CGameHelper::LineFeatureCol(const float3&amp; start, const float3&amp; dir, float length)
 {
 	int quads[1000];
@@ -825,7 +825,7 @@
 			}
 
 			CollisionVolume* cv = f-&gt;collisionVolume;
-			const float3&amp; midPosOffset = cv? cv-&gt;axisOffsets: ZeroVector;
+			const float3&amp; midPosOffset = cv? cv-&gt;GetOffsets(): ZeroVector;
 			const float3 dif = (f-&gt;midPos + midPosOffset) - start;
 			float closeLength = dif.dot(dir);
 
@@ -976,7 +976,7 @@
 bool CGameHelper::TestConeHelper(const float3&amp; from, const float3&amp; weaponDir, float length, float spread, const CUnit* u)
 {
 	// account for any offset, since we want to know if our shots might hit
-	float3 unitDir = (u-&gt;midPos + u-&gt;collisionVolume-&gt;axisOffsets) - from;
+	float3 unitDir = (u-&gt;midPos + u-&gt;collisionVolume-&gt;GetOffsets()) - from;
 	// weaponDir defines the center of the cone
 	float closeLength = unitDir.dot(weaponDir);
 
@@ -989,7 +989,7 @@
 	// NOTE: same caveat wrt. use of volumeBoundingRadius
 	// as for ::Explosion(), this will result in somewhat
 	// over-conservative tests for non-spherical volumes
-	float r = u-&gt;collisionVolume-&gt;volumeBoundingRadius + spread * closeLength + 1;
+	float r = u-&gt;collisionVolume-&gt;GetBoundingRadius() + spread * closeLength + 1;
 
 	return (closeVect.SqLength() &lt; r * r);
 }
@@ -1049,8 +1049,8 @@
     @return true if the unit u is in the firing trajectory, false otherwise */
 bool CGameHelper::TestTrajectoryConeHelper(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, const CUnit* u)
 {
-	CollisionVolume* cv = u-&gt;collisionVolume;
-	float3 dif = (u-&gt;midPos + cv-&gt;axisOffsets) - from;
+	const CollisionVolume* cv = u-&gt;collisionVolume;
+	float3 dif = (u-&gt;midPos + cv-&gt;GetOffsets()) - from;
 	float3 flatdif(dif.x, 0, dif.z);
 	float closeFlatLength = flatdif.dot(flatdir);
 
@@ -1065,7 +1065,7 @@
 
 		// NOTE: overly conservative for non-spherical volumes
 		float3 closeVect = dif - flatdir * closeFlatLength;
-		float r = cv-&gt;volumeBoundingRadius + spread * closeFlatLength + baseSize;
+		float r = cv-&gt;GetBoundingRadius() + spread * closeFlatLength + baseSize;
 		if (closeVect.SqLength() &lt; r * r) {
 			return true;
 		}
@@ -1076,12 +1076,12 @@
 		dir.y = linear + quadratic * closeFlatLength;
 		dir.Normalize();
 
-		dif = (u-&gt;midPos + cv-&gt;axisOffsets) - newfrom;
+		dif = (u-&gt;midPos + cv-&gt;GetOffsets()) - newfrom;
 		float closeLength = dif.dot(dir);
 
 		// NOTE: overly conservative for non-spherical volumes
 		float3 closeVect = dif - dir * closeLength;
-		float r = cv-&gt;volumeBoundingRadius + spread * closeFlatLength + baseSize;
+		float r = cv-&gt;GetBoundingRadius() + spread * closeFlatLength + baseSize;
 		if (closeVect.SqLength() &lt; r * r) {
 			return true;
 		}

Modified: branches/caiinterface/rts/Game/PreGame.cpp
===================================================================
--- branches/caiinterface/rts/Game/PreGame.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/PreGame.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -206,11 +206,6 @@
 	startupData-&gt;SetMap(map, archiveScanner-&gt;GetMapChecksum(map));
 	setup-&gt;LoadStartPositions();
 
-	if (gameSetup) {
-		const_cast&lt;CGameSetup*&gt;(gameSetup)-&gt;LoadStartPositions(); // only host needs to do this, because
-		                                 // client will receive startpos msg from server
-	}
-	
 	good_fpu_control_registers(&quot;before CGameServer creation&quot;);
 	startupData-&gt;SetSetup(setup-&gt;gameSetupText);
 	gameServer = new CGameServer(settings.get(), false, startupData, setup);
@@ -233,7 +228,11 @@
 	{
 		const unsigned char* inbuf = packet-&gt;data;
 		switch (inbuf[0]) {
-			case NETMSG_SETPLAYERNUM: {
+			case NETMSG_GAMEDATA: { // server first sends this to let us know about teams, allyteams etc.
+				GameDataReceived(packet);
+				break;
+			}
+			case NETMSG_SETPLAYERNUM: { // this is sent afterwards to let us know which playernum we have
 				gu-&gt;SetMyPlayer(packet-&gt;data[1]);
 				logOutput.Print(&quot;Became player %i&quot;, gu-&gt;myPlayerNum);
 				
@@ -252,10 +251,6 @@
 				delete this;
 				return;
 			}
-			case NETMSG_GAMEDATA: {
-				GameDataReceived(packet);
-				break;
-			}
 			default: {
 				logOutput.Print(&quot;Unknown net-msg recieved from CPreGame: %i&quot;, int(packet-&gt;data[0]));
 				break;
@@ -366,27 +361,6 @@
 	}
 }
 
-void CPreGame::LoadLua()
-{
-	const string luaGaiaStr  = configHandler.GetString(&quot;LuaGaia&quot;,  &quot;1&quot;);
-	const string luaRulesStr = configHandler.GetString(&quot;LuaRules&quot;, &quot;1&quot;);
-	gs-&gt;useLuaGaia  = CLuaGaia::SetConfigString(luaGaiaStr);
-	gs-&gt;useLuaRules = CLuaRules::SetConfigString(luaRulesStr);
-	if (gs-&gt;useLuaGaia) {
-		gs-&gt;gaiaTeamID = gs-&gt;activeTeams;
-		gs-&gt;gaiaAllyTeamID = gs-&gt;activeAllyTeams;
-		gs-&gt;activeTeams++;
-		gs-&gt;activeAllyTeams++;
-		CTeam* team = gs-&gt;Team(gs-&gt;gaiaTeamID);
-		team-&gt;color[0] = 255;
-		team-&gt;color[1] = 255;
-		team-&gt;color[2] = 255;
-		team-&gt;color[3] = 255;
-		team-&gt;gaia = true;
-		gs-&gt;SetAllyTeam(gs-&gt;gaiaTeamID, gs-&gt;gaiaAllyTeamID);
-	}
-}
-
 void CPreGame::GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet)
 {
 	gameData.reset(new GameData(packet));
@@ -417,7 +391,6 @@
 		}
 		gameSetup = const_cast&lt;const CGameSetup*&gt;(temp);
 		gs-&gt;LoadFromSetup(gameSetup);
-		LoadLua();
 	}
 	else
 	{

Modified: branches/caiinterface/rts/Game/PreGame.h
===================================================================
--- branches/caiinterface/rts/Game/PreGame.h	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/PreGame.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -60,8 +60,6 @@
 	
 	/// Map all required archives depending on selected mod(s)
 	void LoadMod(const std::string&amp; modName);
-	
-	void LoadLua();
 
 	void GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet);
 

Modified: branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp
===================================================================
--- branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/StartScripts/CommanderScript.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -41,77 +41,51 @@
 
 void CCommanderScript::GameStart()
 {
-	if (gameSetup) {
-		// setup the teams
-		for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
+	// setup the teams
+	for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
 
-			// don't spawn a commander for the gaia team
-			if (gs-&gt;useLuaGaia &amp;&amp; (a == gs-&gt;gaiaTeamID)) {
-				continue;
-			}
+		// don't spawn a commander for the gaia team
+		if (gs-&gt;useLuaGaia &amp;&amp; (a == gs-&gt;gaiaTeamID)) {
+			continue;
+		}
 
-			CTeam* team = gs-&gt;Team(a);
+		CTeam* team = gs-&gt;Team(a);
 
-			if (team-&gt;gaia) continue;
+		if (team-&gt;gaia) continue;
 
-			// remove the pre-existing storage except for a small amount
-			team-&gt;metalStorage = 20;
-			team-&gt;energyStorage = 20;
+		// remove the pre-existing storage except for a small amount
+		team-&gt;metalStorage = 20;
+		team-&gt;energyStorage = 20;
 
-			// create a Skirmish AI if required
-			if (!SSAIKey_Comparator::IsEmpty(team-&gt;skirmishAISpecifier) // is an AI specifyed?
-					&amp;&amp; (gu-&gt;myPlayerNum == team-&gt;leader)) {
-				globalAI-&gt;CreateSkirmishAI(a, team-&gt;skirmishAISpecifier, team-&gt;skirmishAIOptions);
-			}
+		// create a Skirmish AI if required
+		if (!SSAIKey_Comparator::IsEmpty(team-&gt;skirmishAISpecifier) // is an AI specifyed?
+				&amp;&amp; (gu-&gt;myPlayerNum == team-&gt;leader)) {
+			globalAI-&gt;CreateSkirmishAI(a, team-&gt;skirmishAISpecifier, team-&gt;skirmishAIOptions);
+		}
 
-			// get the team startup info
-			// NOTE: team-&gt;side isn't set when playing GameSetup-type demos
-			// (CGlobalStuff::LoadFromSetup() doesn't get called for them),
-			// this needs to be sorted out properly
-			const std::string&amp; tside = team-&gt;side;
-			const std::string&amp; gside = gameSetup-&gt;teamStartingData[a].side;
-			const std::string&amp; rside = (tside == gside)? tside: gside;
-			const std::string&amp; startUnit = sideParser.GetStartUnit(rside);
+		// get the team startup info
+		// NOTE: team-&gt;side isn't set when playing GameSetup-type demos
+		// (CGlobalStuff::LoadFromSetup() doesn't get called for them),
+		// this needs to be sorted out properly
+		const std::string&amp; tside = team-&gt;side;
+		const std::string&amp; gside = gameSetup-&gt;teamStartingData[a].side;
+		const std::string&amp; rside = (tside == gside)? tside: gside;
+		const std::string&amp; startUnit = sideParser.GetStartUnit(rside);
 
-			if (startUnit.empty()) {
-				throw content_error( &quot;Unable to load a commander for side: &quot; + rside);
-			}
-
-			CUnit* unit =
-				unitLoader.LoadUnit(startUnit, team-&gt;startPos, a, false, 0, NULL);
-
-			team-&gt;lineageRoot = unit-&gt;id;
-
-			// FIXME this shouldn't be here, but no better place exists currently
-			if (a == gu-&gt;myTeam) {
-				minimap-&gt;AddNotification(team-&gt;startPos, float3(1.0f, 1.0f, 1.0f), 1.0f);
-				game-&gt;infoConsole-&gt;SetLastMsgPos(team-&gt;startPos);
-			}
+		if (startUnit.empty()) {
+			throw content_error( &quot;Unable to load a commander for side: &quot; + rside);
 		}
-	}
-	else {
-		const std::string startUnit0 = sideParser.GetStartUnit(0, &quot;&quot;);
-		const std::string startUnit1 = sideParser.GetStartUnit(1, startUnit0);
 
-		if (startUnit0.length() == 0) {
-			throw content_error(&quot;Unable to load a startUnit for the first side&quot;);
-		}
-		
-		MapParser mapParser(stupidGlobalMapname);
-		if (!mapParser.IsValid()) {
-			throw content_error(&quot;MapParser: &quot; + mapParser.GetErrorLog());
-		}
-		float3 startPos0(1000.0f, 80.0f, 1000.0f);
-		float3 startPos1(1200.0f, 80.0f, 1200.0f);
-		mapParser.GetStartPos(0, startPos0);
-		mapParser.GetStartPos(1, startPos1);
+		CUnit* unit =
+			unitLoader.LoadUnit(startUnit, team-&gt;startPos, a, false, 0, NULL);
 
-		unitLoader.LoadUnit(startUnit0, startPos0, 0, false, 0, NULL);
-		unitLoader.LoadUnit(startUnit1, startPos1, 1, false, 0, NULL);
+		team-&gt;lineageRoot = unit-&gt;id;
 
 		// FIXME this shouldn't be here, but no better place exists currently
-		minimap-&gt;AddNotification(startPos0, float3(1.0f, 1.0f, 1.0f), 1.0f);
-		game-&gt;infoConsole-&gt;SetLastMsgPos(startPos0);
+		if (a == gu-&gt;myTeam) {
+			minimap-&gt;AddNotification(team-&gt;startPos, float3(1.0f, 1.0f, 1.0f), 1.0f);
+			game-&gt;infoConsole-&gt;SetLastMsgPos(team-&gt;startPos);
+		}
 	}
 }
 

Modified: branches/caiinterface/rts/Game/StartScripts/SkirmishAITestScript.cpp
===================================================================
--- branches/caiinterface/rts/Game/StartScripts/SkirmishAITestScript.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/StartScripts/SkirmishAITestScript.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -30,14 +30,12 @@
 		key(key),
 		options(options)
 {
-	if (!gameSetup) {
-		// make sure CSelectedUnits::AiOrder()
-		// still works without a setup script
-		gs-&gt;Team(1)-&gt;isAI = true;
-		gs-&gt;Team(1)-&gt;skirmishAISpecifier = key;
-		gs-&gt;Team(1)-&gt;skirmishAIOptions = options;
-		gs-&gt;Team(1)-&gt;leader = 0;
-	}
+	// make sure CSelectedUnits::AiOrder()
+	// still works without a setup script
+	gs-&gt;Team(1)-&gt;isAI = true;
+	gs-&gt;Team(1)-&gt;skirmishAISpecifier = key;
+	gs-&gt;Team(1)-&gt;skirmishAIOptions = options;
+	gs-&gt;Team(1)-&gt;leader = 0;
 }
 
 

Modified: branches/caiinterface/rts/Game/UI/GameInfo.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/GameInfo.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/UI/GameInfo.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -190,13 +190,11 @@
 	labels.push_back(&quot;Max Wind:&quot;);
 	values.push_back(wind.GetMaxWind());
 
-	if (gameSetup) {
-		labels.push_back(&quot;Limited DGun:&quot;);
-		values.push_back(gameSetup-&gt;limitDgun);
+	labels.push_back(&quot;Limited DGun:&quot;);
+	values.push_back(gameSetup-&gt;limitDgun);
 
-		labels.push_back(&quot;Diminishing Metal:&quot;);
-		values.push_back(gameSetup-&gt;diminishingMMs);
-	}
+	labels.push_back(&quot;Diminishing Metal:&quot;);
+	values.push_back(gameSetup-&gt;diminishingMMs);
 
 	labels.push_back(&quot;Map Size:&quot;);
 	sprintf(buf, &quot;%ix%i&quot;, readmap-&gt;width / 64, readmap-&gt;height / 64);

Modified: branches/caiinterface/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -44,7 +44,7 @@
 #include &quot;Sim/Projectiles/Unsynced/WreckProjectile.h&quot;
 #include &quot;Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.h&quot;
 #include &quot;Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.h&quot;
-#include &quot;Sim/Projectiles/WeaponProjectiles/LightingProjectile.h&quot;
+#include &quot;Sim/Projectiles/WeaponProjectiles/LightningProjectile.h&quot;
 #include &quot;Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
 #include &quot;Sim/Units/CommandAI/LineDrawer.h&quot;
@@ -1138,8 +1138,8 @@
 							unsigned char color[4] = {beam.kocolstart[0],beam.kocolstart[1],beam.kocolstart[2],255};
 							lines-&gt;AddVertexQC(beam.startPos,color);
 							lines-&gt;AddVertexQC(beam.endPos,color);
-						} else if (dynamic_cast&lt;CLightingProjectile*&gt;(p)) {
-							CLightingProjectile&amp; beam = *(CLightingProjectile*)p;
+						} else if (dynamic_cast&lt;CLightningProjectile*&gt;(p)) {
+							CLightningProjectile&amp; beam = *(CLightningProjectile*)p;
 							unsigned char color[4] = {(unsigned char)beam.color[0]*255,(unsigned char)beam.color[1]*255,(unsigned char)beam.color[2]*255,255};
 							lines-&gt;AddVertexQC(beam.pos,color);
 							lines-&gt;AddVertexQC(beam.endPos,color);

Modified: branches/caiinterface/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaSyncedRead.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Lua/LuaSyncedRead.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -870,8 +870,8 @@
 	}
 
 	const int allyTeam = (int)luaL_checkint(L, 1);
-	if ((allyTeam &lt; 0) || (allyTeam &gt;= gs-&gt;activeAllyTeams)) {
-		luaL_error(L, &quot;Bad allyTeam (%i) in GetAllyTeamStartBox()&quot;, allyTeam);
+	if ((allyTeam &lt; 0) || (allyTeam &gt;= gameSetup-&gt;allyStartingData.size())) {
+		return 0;
 	}
 	const float xmin = (gs-&gt;mapx * 8.0f) * gameSetup-&gt;allyStartingData[allyTeam].startRectLeft;
 	const float zmin = (gs-&gt;mapy * 8.0f) * gameSetup-&gt;allyStartingData[allyTeam].startRectTop;

Modified: branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -800,7 +800,7 @@
 	const float3 vpn = vp - dy;
 	const float3 vnp = vn + dy;
 	const float3 vpp = vp + dy;
-	
+
 	// Draw the icon.
 	iconData-&gt;Draw(vnn, vpn, vnp, vpp);
 }
@@ -958,7 +958,7 @@
 			} else {
 				model = decoyDef-&gt;LoadModel(unitTeam);
 				is_s3o = (model-&gt;rootobjects3o != NULL);
-			}				
+			}
 
 			if (is_s3o) {
 				SetBasicS3OTeamColour(unitTeam);
@@ -1812,6 +1812,10 @@
 		CollisionVolume* vol = unit-&gt;collisionVolume;
 
 		switch (vol-&gt;GetVolumeType()) {
+			case COLVOL_TYPE_FOOTPRINT:
+				// fall through, this is too hard to render correctly so just render sphere :)
+			case COLVOL_TYPE_SPHERE:
+				// fall through, sphere is special case of ellipsoid
 			case COLVOL_TYPE_ELLIPSOID: {
 				// scaled sphere: radius, slices, stacks
 				glTranslatef(vol-&gt;GetOffset(0), vol-&gt;GetOffset(1), vol-&gt;GetOffset(2));

Modified: branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -7,29 +7,16 @@
 
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Features/Feature.h&quot;
+#include &quot;GroundBlockingObjectMap.h&quot;
 
+#include &quot;Game/GlobalSynced.h&quot;
+
 #include &quot;CollisionHandler.h&quot;
 #include &quot;CollisionVolume.h&quot;
 
 #define ZVEC ZeroVector
 
 CR_BIND(CCollisionHandler, );
-CR_BIND(CollisionVolume, );
-	CR_REG_METADATA(CollisionVolume, (
-		CR_MEMBER(axisScales),
-		CR_MEMBER(axisHScales),
-		CR_MEMBER(axisHScalesSq),
-		CR_MEMBER(axisHIScales),
-		CR_MEMBER(axisOffsets),
-		CR_MEMBER(volumeBoundingRadius),
-		CR_MEMBER(volumeBoundingRadiusSq),
-		CR_MEMBER(volumeType),
-		CR_MEMBER(testType),
-		CR_MEMBER(primaryAxis),
-		CR_MEMBER(secondaryAxes),
-		CR_MEMBER(spherical),
-		CR_MEMBER(disabled)
-	));
 
 unsigned int CCollisionHandler::numCollisionTests = 0;
 unsigned int CCollisionHandler::numIntersectionTests = 0;
@@ -77,10 +64,16 @@
 
 	if (((u-&gt;midPos + v-&gt;axisOffsets) - p).SqLength() &gt; v-&gt;volumeBoundingRadiusSq) {
 		return false;
-	} else {
-		if (v-&gt;spherical) {
+	}
+
+	switch (u-&gt;collisionVolume-&gt;volumeType) {
+		case COLVOL_TYPE_SPHERE: {
 			return true;
-		} else {
+		}
+		case COLVOL_TYPE_FOOTPRINT: {
+			return CCollisionHandler::CollisionFootprint(u, p);
+		}
+		default: {
 			// NOTE: we have to translate by relMidPos to get to midPos
 			// (which is where the collision volume gets drawn) because
 			// GetTransformMatrix() only uses pos
@@ -93,16 +86,23 @@
 	}
 }
 
+
 bool CCollisionHandler::Collision(const CFeature* f, const float3&amp; p)
 {
 	const CollisionVolume* v = f-&gt;collisionVolume;
 
 	if (((f-&gt;midPos + v-&gt;axisOffsets) - p).SqLength() &gt; v-&gt;volumeBoundingRadiusSq) {
 		return false;
-	} else {
-		if (v-&gt;spherical) {
+	}
+
+	switch (f-&gt;collisionVolume-&gt;volumeType) {
+		case COLVOL_TYPE_SPHERE: {
 			return true;
-		} else {
+		}
+		case COLVOL_TYPE_FOOTPRINT: {
+			return CCollisionHandler::CollisionFootprint(f, p);
+		}
+		default: {
 			// NOTE: CFeature does not have a relMidPos member so
 			// calculate and apply the translation from pos (used
 			// by transMatrix) to midPos manually
@@ -117,7 +117,24 @@
 }
 
 
+bool CCollisionHandler::CollisionFootprint(const CSolidObject* o, const float3&amp; p)
+{
+	if (o-&gt;isMarkedOnBlockingMap &amp;&amp; o-&gt;physicalState != CSolidObject::Flying) {
+		const float invSquareSize = 1.0f / SQUARE_SIZE;
+		const int square = int(p.x * invSquareSize) + int(p.z * invSquareSize) * gs-&gt;mapx;
 
+		if (square &gt;= 0 &amp;&amp; square &lt; gs-&gt;mapSquares) {
+			const BlockingMapCell&amp; cell = groundBlockingObjectMap-&gt;GetCell(square);
+			return cell.find(o-&gt;GetBlockingMapID()) != cell.end();
+		}
+	}
+	// If the object isn't marked on blocking map, or it is flying,
+	// effecively only the sphere check (in Collision(CUnit*) or
+	// Collision(CFeature*)) is performed.
+	return true;
+}
+
+
 // test if point &lt;p&gt; (in world-coors) lies inside the
 // volume whose transformation matrix is given by &lt;m&gt;
 bool CCollisionHandler::Collision(const CollisionVolume* v, const CMatrix44f&amp; m, const float3&amp; p)
@@ -131,15 +148,17 @@
 	bool hit = false;
 
 	switch (v-&gt;volumeType) {
+		case COLVOL_TYPE_SPHERE: {
+			// normally, this code is never executed, because the higher level
+			// Collision(CFeature*) and Collision(CUnit*) already optimize
+			// for volumeType == COLVOL_TYPE_SPHERE.
+			hit = (pi.dot(pi) &lt;= v-&gt;axisHScalesSq.x);
+		} break;
 		case COLVOL_TYPE_ELLIPSOID: {
-			if (v-&gt;spherical) {
-				hit = (pi.dot(pi) &lt;= v-&gt;axisHScalesSq.x);
-			} else {
-				const float f1 = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
-				const float f2 = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
-				const float f3 = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
-				hit = ((f1 + f2 + f3) &lt;= 1.0f);
-			}
+			const float f1 = (pi.x * pi.x) / v-&gt;axisHScalesSq.x;
+			const float f2 = (pi.y * pi.y) / v-&gt;axisHScalesSq.y;
+			const float f3 = (pi.z * pi.z) / v-&gt;axisHScalesSq.z;
+			hit = ((f1 + f2 + f3) &lt;= 1.0f);
 		} break;
 		case COLVOL_TYPE_CYLINDER: {
 			switch (v-&gt;primaryAxis) {
@@ -254,6 +273,11 @@
 	if (rmaxz &lt; vminz || rminz &gt; vmaxz) { return false; }
 
 	switch (v-&gt;volumeType) {
+		case COLVOL_TYPE_FOOTPRINT:
+			// fall through, intersection with footprint collision volume
+			// is not supported yet, so only test against sphere/ellipsoid
+		case COLVOL_TYPE_SPHERE:
+			// fall through, sphere is special case of ellipsoid
 		case COLVOL_TYPE_ELLIPSOID: {
 			intersect = CCollisionHandler::IntersectEllipsoid(v, pi0, pi1, q);
 		} break;

Modified: branches/caiinterface/rts/Sim/Misc/CollisionHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionHandler.h	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Misc/CollisionHandler.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -39,10 +39,11 @@
 		static bool Collision(const CUnit*, const float3&amp;);
 		static bool Collision(const CFeature*, const float3&amp;);
 		static bool Collision(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;);
+		static bool CollisionFootprint(const CSolidObject*, const float3&amp;);
 
 	public:
-		static bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
-		static bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
+		static bool Intersect(const CUnit*, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q);
+		static bool Intersect(const CFeature*, const float3&amp; p0, const float3&amp; p1, CollisionQuery* q);
 	private:
 		static bool Intersect(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q);
 

Copied: branches/caiinterface/rts/Sim/Misc/CollisionVolume.cpp (from rev 6979, trunk/rts/Sim/Misc/CollisionVolume.cpp)
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionVolume.cpp	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Misc/CollisionVolume.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -0,0 +1,187 @@
+#include &quot;StdAfx.h&quot;
+#include &quot;CollisionVolume.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;mmgr.h&quot;
+
+
+static CLogSubsystem LOG_COLVOL(&quot;CollisionVolume&quot;);
+
+
+CR_BIND(CollisionVolume, );
+	CR_REG_METADATA(CollisionVolume, (
+		CR_MEMBER(axisScales),
+		CR_MEMBER(axisHScales),
+		CR_MEMBER(axisHScalesSq),
+		CR_MEMBER(axisHIScales),
+		CR_MEMBER(axisOffsets),
+		CR_MEMBER(volumeBoundingRadius),
+		CR_MEMBER(volumeBoundingRadiusSq),
+		CR_MEMBER(volumeType),
+		CR_MEMBER(testType),
+		CR_MEMBER(primaryAxis),
+		CR_MEMBER(secondaryAxes),
+		CR_MEMBER(disabled)
+	));
+
+
+CollisionVolume::CollisionVolume(const CollisionVolume* src)
+{
+	//logOutput.Print(LOG_COLVOL, &quot;CollisionVolume::CollisionVolume(src = 0x%p)&quot;, src);
+
+	axisScales             = src? src-&gt;axisScales:             float3(2.0f, 2.0f, 2.0f);
+	axisHScales            = src? src-&gt;axisHScales:            float3(1.0f, 1.0f, 1.0f);
+	axisHScalesSq          = src? src-&gt;axisHScalesSq:          float3(1.0f, 1.0f, 1.0f);
+	axisHIScales           = src? src-&gt;axisHIScales:           float3(1.0f, 1.0f, 1.0f);
+	axisOffsets            = src? src-&gt;axisOffsets:            ZeroVector;
+	volumeBoundingRadius   = src? src-&gt;volumeBoundingRadius:   1.0f;
+	volumeBoundingRadiusSq = src? src-&gt;volumeBoundingRadiusSq: 1.0f;
+	volumeType             = src? src-&gt;volumeType:             COLVOL_TYPE_ELLIPSOID;
+	testType               = src? src-&gt;testType:               COLVOL_TEST_DISC;
+	primaryAxis            = src? src-&gt;primaryAxis:            COLVOL_AXIS_Z;
+	secondaryAxes[0]       = src? src-&gt;secondaryAxes[0]:       COLVOL_AXIS_X;
+	secondaryAxes[1]       = src? src-&gt;secondaryAxes[1]:       COLVOL_AXIS_Y;
+	disabled               = src? src-&gt;disabled:               false;
+}
+
+
+CollisionVolume::CollisionVolume(const std::string&amp; typeStr, const float3&amp; scales, const float3&amp; offsets, int testType)
+{
+	primaryAxis = COLVOL_AXIS_Z;
+
+	if (typeStr.size() &gt; 0) {
+		std::string typeStrLC(StringToLower(typeStr));
+
+		if (typeStrLC.find(&quot;ell&quot;) != std::string::npos) {
+			logOutput.Print(LOG_COLVOL, &quot;New ellipsoid&quot;);
+			volumeType = COLVOL_TYPE_ELLIPSOID;
+		}
+
+		if (typeStrLC.find(&quot;cyl&quot;) != std::string::npos) {
+			logOutput.Print(LOG_COLVOL, &quot;New cylinder&quot;);
+			volumeType = COLVOL_TYPE_CYLINDER;
+
+			if (typeStrLC.size() == 4) {
+				if (typeStrLC[3] == 'x') { primaryAxis = COLVOL_AXIS_X; }
+				if (typeStrLC[3] == 'y') { primaryAxis = COLVOL_AXIS_Y; }
+				if (typeStrLC[3] == 'z') { primaryAxis = COLVOL_AXIS_Z; }
+			}
+		}
+
+		if (typeStrLC.find(&quot;box&quot;) != std::string::npos) {
+			logOutput.Print(LOG_COLVOL, &quot;New box&quot;);
+			volumeType = COLVOL_TYPE_BOX;
+		}
+
+		if (typeStrLC.find(&quot;footprint&quot;) != std::string::npos) {
+			logOutput.Print(LOG_COLVOL, &quot;New footprint&quot;);
+			volumeType = COLVOL_TYPE_FOOTPRINT;
+		}
+
+	} else {
+		logOutput.Print(LOG_COLVOL, &quot;New footprint (default)&quot;);
+		volumeType = COLVOL_TYPE_FOOTPRINT;
+	}
+
+	Init(scales, offsets, volumeType, testType, primaryAxis);
+}
+
+
+void CollisionVolume::SetDefaultScale(const float s)
+{
+	//logOutput.Print(LOG_COLVOL, &quot;SetDefaultScale(s = %g)&quot;, s);
+
+	// called iif unit or feature defines no custom volume,
+	// &lt;s&gt; is the object's default RADIUS (not its diameter)
+	// so we need to double it to get the full-length scales
+	const float3 scales(s * 2.0f, s * 2.0f, s * 2.0f);
+
+	Init(scales, ZeroVector, volumeType, testType, primaryAxis);
+}
+
+
+void CollisionVolume::Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis)
+{
+	//logOutput.Print(LOG_COLVOL, &quot;Init(scales={%g,%g,%g}, offsets={%g,%g,%g}, vType=%d, tType=%d, pAxis=%d)&quot;,
+	//                scales.x, scales.y, scales.z, offsets.x, offsets.y, offsets.z, vType, tType, pAxis);
+
+	disabled = (tType &lt; 0);
+
+	// assign these here, since we can be
+	// called from outside the constructor
+	primaryAxis = std::max(pAxis, 0) % COLVOL_NUM_AXES;
+	volumeType = std::max(vType, 0) % COLVOL_NUM_TYPES;
+	testType = std::max(tType, 0) % COLVOL_NUM_TESTS;
+
+	axisScales.x = (scales.x &lt; 1.0f)? 1.0f: scales.x;
+	axisScales.y = (scales.y &lt; 1.0f)? 1.0f: scales.y;
+	axisScales.z = (scales.z &lt; 1.0f)? 1.0f: scales.z;
+
+	axisHScales.x = axisScales.x * 0.5f;  axisHScalesSq.x = axisHScales.x * axisHScales.x;
+	axisHScales.y = axisScales.y * 0.5f;  axisHScalesSq.y = axisHScales.y * axisHScales.y;
+	axisHScales.z = axisScales.z * 0.5f;  axisHScalesSq.z = axisHScales.z * axisHScales.z;
+
+	axisHIScales.x = 1.0f / axisHScales.x;  axisOffsets.x = offsets.x;
+	axisHIScales.y = 1.0f / axisHScales.y;  axisOffsets.y = offsets.y;
+	axisHIScales.z = 1.0f / axisHScales.z;  axisOffsets.z = offsets.z;
+
+	// if all axes (or half-axes) are equal in scale, volume is a sphere
+	const bool spherical =
+		((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
+		(streflop::fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
+		(streflop::fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
+
+	if (spherical) {
+		logOutput.Print(LOG_COLVOL, &quot;Auto converting spherical ellipsoid to sphere&quot;);
+		volumeType = COLVOL_TYPE_SPHERE;
+	}
+
+	// secondaryAxes[0] = (primaryAxis + 1) % 3;
+	// secondaryAxes[1] = (primaryAxis + 2) % 3;
+
+	switch (primaryAxis) {
+		case COLVOL_AXIS_X: {
+			secondaryAxes[0] = COLVOL_AXIS_Y;
+			secondaryAxes[1] = COLVOL_AXIS_Z;
+		} break;
+		case COLVOL_AXIS_Y: {
+			secondaryAxes[0] = COLVOL_AXIS_X;
+			secondaryAxes[1] = COLVOL_AXIS_Z;
+		} break;
+		case COLVOL_AXIS_Z: {
+			secondaryAxes[0] = COLVOL_AXIS_X;
+			secondaryAxes[1] = COLVOL_AXIS_Y;
+		} break;
+	}
+
+	// set the radius of the minimum bounding sphere
+	// that encompasses this custom collision volume
+	// (for early-out testing)
+	switch (volumeType) {
+		case COLVOL_TYPE_BOX: {
+			// would be an over-estimation for cylinders
+			volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
+			volumeBoundingRadius = streflop::sqrt(volumeBoundingRadiusSq);
+		} break;
+		case COLVOL_TYPE_CYLINDER: {
+			const float prhs = axisHScales[primaryAxis     ];   // primary axis half-scale
+			const float sahs = axisHScales[secondaryAxes[0]];   // 1st secondary axis half-scale
+			const float sbhs = axisHScales[secondaryAxes[1]];   // 2nd secondary axis half-scale
+			const float mshs = std::max(sahs, sbhs);            // max. secondary axis half-scale
+
+			volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
+			volumeBoundingRadius = streflop::sqrtf(volumeBoundingRadiusSq);
+		} break;
+		case COLVOL_TYPE_ELLIPSOID: {
+			volumeBoundingRadius = std::max(axisHScales.x, std::max(axisHScales.y, axisHScales.z));
+			volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
+		} break;
+		case COLVOL_TYPE_FOOTPRINT:
+			// fall through, this is intersection of footprint-prism
+			// and sphere, so it has same bounding radius as sphere.
+		case COLVOL_TYPE_SPHERE: {
+			// max{x, y, z} would suffice here too (see ellipsoid)
+			volumeBoundingRadius = axisHScales.x;
+			volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
+		} break;
+	}
+}

Modified: branches/caiinterface/rts/Sim/Misc/CollisionVolume.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionVolume.h	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Misc/CollisionVolume.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -1,154 +1,47 @@
 #ifndef COLLISION_VOLUME_H
 #define COLLISION_VOLUME_H
 
+#include &quot;float3.h&quot;
 #include &quot;creg/creg.h&quot;
 #include &quot;Util.h&quot;
 
 const float EPS = 0.0000000001f;
 
-enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
-enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
-enum COLVOL_TESTS {COLVOL_TEST_DISC, COLVOL_TEST_CONT};
+enum COLVOL_TYPES {
+	COLVOL_TYPE_DISABLED = -1,
+	COLVOL_TYPE_ELLIPSOID = 0,
+	COLVOL_TYPE_CYLINDER,
+	COLVOL_TYPE_BOX,
+	COLVOL_TYPE_SPHERE,
+	COLVOL_TYPE_FOOTPRINT, // intersection of sphere and footprint-prism
+	COLVOL_NUM_TYPES       // number of non-disabled collision volume types
+};
 
-struct CollisionVolume {
+enum COLVOL_AXES {
+	COLVOL_AXIS_X,
+	COLVOL_AXIS_Y,
+	COLVOL_AXIS_Z,
+	COLVOL_NUM_AXES     // number of collision volume axes
+};
+enum COLVOL_TESTS {
+	COLVOL_TEST_DISC,
+	COLVOL_TEST_CONT,
+	COLVOL_NUM_TESTS    // number of tests
+};
+
+struct CollisionVolume
+{
 	CR_DECLARE_STRUCT(CollisionVolume);
 
-	CollisionVolume(const CollisionVolume* src = 0x0) {
-		axisScales             = src? src-&gt;axisScales:             float3(2.0f, 2.0f, 2.0f);
-		axisHScales            = src? src-&gt;axisHScales:            float3(1.0f, 1.0f, 1.0f);
-		axisHScalesSq          = src? src-&gt;axisHScalesSq:          float3(1.0f, 1.0f, 1.0f);
-		axisHIScales           = src? src-&gt;axisHIScales:           float3(1.0f, 1.0f, 1.0f);
-		axisOffsets            = src? src-&gt;axisOffsets:            ZeroVector;
-		volumeBoundingRadius   = src? src-&gt;volumeBoundingRadius:   1.0f;
-		volumeBoundingRadiusSq = src? src-&gt;volumeBoundingRadiusSq: 1.0f;
-		volumeType             = src? src-&gt;volumeType:             COLVOL_TYPE_ELLIPSOID;
-		testType               = src? src-&gt;testType:               COLVOL_TEST_DISC;
-		primaryAxis            = src? src-&gt;primaryAxis:            COLVOL_AXIS_Z;
-		secondaryAxes[0]       = src? src-&gt;secondaryAxes[0]:       COLVOL_AXIS_X;
-		secondaryAxes[1]       = src? src-&gt;secondaryAxes[1]:       COLVOL_AXIS_Y;
-		spherical              = src? src-&gt;spherical:              true;
-		disabled               = src? src-&gt;disabled:               false;
-	}
+	CollisionVolume(const CollisionVolume* src = NULL);
+	CollisionVolume(const std::string&amp; typeStr, const float3&amp; scales, const float3&amp; offsets, int testType);
 
-	CollisionVolume(const std::string&amp; typeStr, const float3&amp; scales, const float3&amp; offsets, int testType) {
-		if (typeStr.size() &gt; 0) {
-			std::string typeStrLC(StringToLower(typeStr));
+	void SetDefaultScale(const float s);
+	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis);
 
-			if (typeStrLC.find(&quot;ell&quot;) != std::string::npos) {
-				volumeType = COLVOL_TYPE_ELLIPSOID;
-			}
-
-			if (typeStrLC.find(&quot;cyl&quot;) != std::string::npos) {
-				volumeType = COLVOL_TYPE_CYLINDER;
-
-				if (typeStrLC.size() == 4) {
-					if (typeStrLC[3] == 'x') { primaryAxis = COLVOL_AXIS_X; }
-					if (typeStrLC[3] == 'y') { primaryAxis = COLVOL_AXIS_Y; }
-					if (typeStrLC[3] == 'z') { primaryAxis = COLVOL_AXIS_Z; }
-				}
-			}
-
-			if (typeStrLC.find(&quot;box&quot;) != std::string::npos) {
-				volumeType = COLVOL_TYPE_BOX;
-			}
-		} else {
-			volumeType = COLVOL_TYPE_ELLIPSOID;
-			primaryAxis = COLVOL_AXIS_Z;
-		}
-
-		Init(scales, offsets, volumeType, testType, primaryAxis);
-	}
-
-
-	void SetDefaultScale(const float s) {
-		// called iif unit or feature defines no custom volume,
-		// &lt;s&gt; is the object's default RADIUS (not its diameter)
-		// so we need to double it to get the full-length scales
-		const float3 scales(s * 2.0f, s * 2.0f, s * 2.0f);
-
-		Init(scales, ZeroVector, volumeType, testType, primaryAxis);
-	}
-
-
-	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis) {
-		disabled = (tType &lt; 0);
-		tType = std::max(tType, 0);
-
-		// assign these here, since we can be
-		// called from outside the constructor
-		primaryAxis = pAxis % 3;
-		volumeType = vType % 3;
-		testType = tType % 2;
-
-		axisScales.x = (scales.x &lt; 1.0f)? 1.0f: scales.x;
-		axisScales.y = (scales.y &lt; 1.0f)? 1.0f: scales.y;
-		axisScales.z = (scales.z &lt; 1.0f)? 1.0f: scales.z;
-
-		axisHScales.x = axisScales.x * 0.5f;  axisHScalesSq.x = axisHScales.x * axisHScales.x;
-		axisHScales.y = axisScales.y * 0.5f;  axisHScalesSq.y = axisHScales.y * axisHScales.y;
-		axisHScales.z = axisScales.z * 0.5f;  axisHScalesSq.z = axisHScales.z * axisHScales.z;
-
-		axisHIScales.x = 1.0f / axisHScales.x;  axisOffsets.x = offsets.x;
-		axisHIScales.y = 1.0f / axisHScales.y;  axisOffsets.y = offsets.y;
-		axisHIScales.z = 1.0f / axisHScales.z;  axisOffsets.z = offsets.z;
-
-		// if all axes (or half-axes) are equal in scale, volume is a sphere
-		spherical =
-			((volumeType == COLVOL_TYPE_ELLIPSOID) &amp;&amp;
-			(streflop::fabsf(axisHScales.x - axisHScales.y) &lt; EPS) &amp;&amp;
-			(streflop::fabsf(axisHScales.y - axisHScales.z) &lt; EPS));
-
-		// secondaryAxes[0] = (primaryAxis + 1) % 3;
-		// secondaryAxes[1] = (primaryAxis + 2) % 3;
-
-		switch (primaryAxis) {
-			case COLVOL_AXIS_X: {
-				secondaryAxes[0] = COLVOL_AXIS_Y;
-				secondaryAxes[1] = COLVOL_AXIS_Z;
-			} break;
-			case COLVOL_AXIS_Y: {
-				secondaryAxes[0] = COLVOL_AXIS_X;
-				secondaryAxes[1] = COLVOL_AXIS_Z;
-			} break;
-			case COLVOL_AXIS_Z: {
-				secondaryAxes[0] = COLVOL_AXIS_X;
-				secondaryAxes[1] = COLVOL_AXIS_Y;
-			} break;
-		}
-
-		// set the radius of the minimum bounding sphere
-		// that encompasses this custom collision volume
-		// (for early-out testing)
-		switch (volumeType) {
-			case COLVOL_TYPE_BOX: {
-				// would be an over-estimation for cylinders
-				volumeBoundingRadiusSq = axisHScalesSq.x + axisHScalesSq.y + axisHScalesSq.z;
-				volumeBoundingRadius = streflop::sqrt(volumeBoundingRadiusSq);
-			} break;
-			case COLVOL_TYPE_CYLINDER: {
-				const float prhs = axisHScales[primaryAxis     ];   // primary axis half-scale
-				const float sahs = axisHScales[secondaryAxes[0]];   // 1st secondary axis half-scale
-				const float sbhs = axisHScales[secondaryAxes[1]];   // 2nd secondary axis half-scale
-				const float mshs = std::max(sahs, sbhs);            // max. secondary axis half-scale
-
-				volumeBoundingRadiusSq = prhs * prhs + mshs * mshs;
-				volumeBoundingRadius = streflop::sqrtf(volumeBoundingRadiusSq);
-			} break;
-			case COLVOL_TYPE_ELLIPSOID: {
-				if (spherical) {
-					// max{x, y, z} would suffice here too
-					volumeBoundingRadius = axisHScales.x;
-				} else {
-					volumeBoundingRadius = std::max(axisHScales.x, std::max(axisHScales.y, axisHScales.z));
-				}
-
-				volumeBoundingRadiusSq = volumeBoundingRadius * volumeBoundingRadius;
-			} break;
-		}
-	}
-
 	int GetVolumeType() const { return volumeType; }
 	int GetTestType() const { return testType; }
+	void SetTestType(int type) { testType = type; }
 	int GetPrimaryAxis() const { return primaryAxis; }
 	float GetBoundingRadius() const { return volumeBoundingRadius; }
 	float GetBoundingRadiusSq() const { return volumeBoundingRadiusSq; }
@@ -156,9 +49,11 @@
 	float GetHScale(int axis) const { return axisHScales[axis]; }
 	float GetHScaleSq(int axis) const { return axisHScalesSq[axis]; }
 	float GetOffset(int axis) const { return axisOffsets[axis]; }
-	bool IsSphere() const { return spherical; }
+	const float3&amp; GetOffsets() const { return axisOffsets; }
+	bool IsSphere() const { return volumeType == COLVOL_TYPE_SPHERE; }
+	bool UseFootprint() const { return volumeType == COLVOL_TYPE_FOOTPRINT; }
 
-
+private:
 	float3 axisScales;					// full-length axis scales
 	float3 axisHScales;					// half-length axis scales
 	float3 axisHScalesSq;				// half-length axis scales (squared)
@@ -171,8 +66,9 @@
 	int testType;
 	int primaryAxis;
 	int secondaryAxes[2];
-	bool spherical;
 	bool disabled;
+
+	friend class CCollisionHandler;     // TODO: refactor
 };
 
 #endif

Modified: branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Misc/GroundBlockingObjectMap.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -154,7 +154,7 @@
   */
 CSolidObject* CGroundBlockingObjectMap::GroundBlockedUnsafe(int mapSquare, bool topMost) {
 	if (groundBlockingMap[mapSquare].empty()) {
-		return 0x0;
+		return NULL;
 	}
 
 	const BlockingMapCell&amp; cell = groundBlockingMap[mapSquare];
@@ -174,7 +174,7 @@
 
 CSolidObject* CGroundBlockingObjectMap::GroundBlocked(int mapSquare, bool topMost) {
 	if (mapSquare &lt; 0 || mapSquare &gt;= gs-&gt;mapSquares) {
-		return 0x0;
+		return NULL;
 	}
 
 	return GroundBlockedUnsafe(mapSquare);

Modified: branches/caiinterface/rts/Sim/Misc/LosHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/LosHandler.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Misc/LosHandler.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -220,10 +220,10 @@
 	for(LosTable::iterator li=table.begin();li!=table.end();++li){
 		LosLine&amp; line=*li;
 		const float baseHeight=readmap-&gt;mipHeightmap[losMipLevel][mapSquare]+instance-&gt;baseHeight-15;
-		float maxAng1 = -1000;
-		float maxAng2 = -1000;
-		float maxAng3 = -1000;
-		float maxAng4 = -1000;
+		float maxAng1 = -1e6f;
+		float maxAng2 = -1e6f;
+		float maxAng3 = -1e6f;
+		float maxAng4 = -1e6f;
 		float r = 1;
 		for(LosLine::iterator linei=line.begin();linei!=line.end();++linei){
 			float invR=1.0f/r;
@@ -303,10 +303,10 @@
 	for (LosTable::iterator li = table.begin(); li != table.end(); ++li) {
 		LosLine&amp; line = *li;
 		float baseHeight=readmap-&gt;mipHeightmap[losMipLevel][mapSquare]+instance-&gt;baseHeight-15;
-		float maxAng1 = -1000;
-		float maxAng2 = -1000;
-		float maxAng3 = -1000;
-		float maxAng4 = -1000;
+		float maxAng1 = -1e6f;
+		float maxAng2 = -1e6f;
+		float maxAng3 = -1e6f;
+		float maxAng4 = -1e6f;
 		float r = 1;
 		instance-&gt;losSquares.push_back(mapSquare);
 		losMap[allyteam][mapSquare]++;

Modified: branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -102,7 +102,7 @@
 	}
 
 	// add all texture from sections within projectiletextures section
-	vector&lt;string&gt; seclist; 
+	vector&lt;string&gt; seclist;
 	ptTable.GetKeys(seclist);
 	for (int i = 0; i &lt; seclist.size(); i++) {
 		const LuaTable ptSubTable = ptTable.SubTable(seclist[i]);
@@ -194,7 +194,7 @@
 	if (mapResParser.IsValid()) {
 		const LuaTable mapRoot = mapResParser.GetRoot();
 		const LuaTable mapTable = mapRoot.SubTable(&quot;projectileTextures&quot;);
-		//add all textures in projectiletextures section 
+		//add all textures in projectiletextures section
 		map&lt;string, string&gt; mptex;
 		mapTable.GetMap(mptex);
 		map&lt;string, string&gt;::iterator pi;
@@ -772,7 +772,7 @@
 				const bool friendlyShot = (p-&gt;owner &amp;&amp; (unit-&gt;allyteam == p-&gt;owner-&gt;allyteam));
 				const bool raytraced =
 					(unit-&gt;collisionVolume &amp;&amp;
-					unit-&gt;collisionVolume-&gt;testType == COLVOL_TEST_CONT);
+					unit-&gt;collisionVolume-&gt;GetTestType() == COLVOL_TEST_CONT);
 
 				// if this unit fired this projectile or (this unit is in the
 				// same allyteam as the unit that shot this projectile and we
@@ -815,7 +815,7 @@
 					CFeature* feature = *fi;
 					const bool raytraced =
 						(feature-&gt;collisionVolume &amp;&amp;
-						feature-&gt;collisionVolume-&gt;testType == COLVOL_TEST_CONT);
+						feature-&gt;collisionVolume-&gt;GetTestType() == COLVOL_TEST_CONT);
 
 					// geothermals do not have a collision volume, skip them
 					if (!feature-&gt;blocking || feature-&gt;def-&gt;geoThermal || !feature-&gt;collisionVolume) {

Deleted: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -1,127 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;mmgr.h&quot;
-
-#include &quot;Game/Camera.h&quot;
-#include &quot;LightingProjectile.h&quot;
-#include &quot;Rendering/GL/VertexArray.h&quot;
-#include &quot;Sim/Weapons/Weapon.h&quot;
-#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
-#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
-#include &quot;Game/GlobalSynced.h&quot;
-
-#ifdef TRACE_SYNC
-	#include &quot;Sync/SyncTracer.h&quot;
-#endif
-
-CR_BIND_DERIVED(CLightingProjectile, CWeaponProjectile, (float3(0,0,0),float3(0,0,0),NULL,float3(0,0,0),NULL,0,NULL));
-
-CR_REG_METADATA(CLightingProjectile,(
-	CR_MEMBER(color),
-	CR_MEMBER(endPos),
-	CR_MEMBER(weapon),
-	CR_MEMBER(displacements),
-	CR_MEMBER(displacements2),
-	CR_RESERVED(16)
-	));
-
-CLightingProjectile::CLightingProjectile(const float3&amp; pos, const float3&amp; end,
-		CUnit* owner, const float3&amp; color, const WeaponDef *weaponDef,
-		int ttl, CWeapon* weap GML_PARG_C):
-	CWeaponProjectile(pos, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
-	color(color),
-	endPos(end),
-	weapon(weap)
-{
-	checkCol=false;
-	drawRadius=pos.distance(endPos);
-
-	displacements[0]=0;
-	for(int a=1;a&lt;10;++a)
-		displacements[a]=(gs-&gt;randFloat()-0.5f)*drawRadius*0.05f;
-
-	displacements2[0]=0;
-	for(int a=1;a&lt;10;++a)
-		displacements2[a]=(gs-&gt;randFloat()-0.5f)*drawRadius*0.05f;
-
-	if(weapon)
-		AddDeathDependence(weapon);
-
-#ifdef TRACE_SYNC
-	tracefile &lt;&lt; &quot;New lighting: &quot;;
-	tracefile &lt;&lt; pos.x &lt;&lt; &quot; &quot; &lt;&lt; pos.y &lt;&lt; &quot; &quot; &lt;&lt; pos.z &lt;&lt; &quot; &quot; &lt;&lt; end.x &lt;&lt; &quot; &quot; &lt;&lt; end.y &lt;&lt; &quot; &quot; &lt;&lt; end.z &lt;&lt; &quot;\n&quot;;
-#endif
-
-	if (cegTag.size() &gt; 0) {
-		ceg.Load(explGenHandler, cegTag);
-	}
-}
-
-CLightingProjectile::~CLightingProjectile(void)
-{
-}
-
-void CLightingProjectile::Update(void)
-{
-	ttl--;
-
-	if (ttl &lt;= 0) {
-		deleteMe = true;
-	} else {
-		if (cegTag.size() &gt; 0) {
-			ceg.Explosion(pos + ((endPos - pos) / ttl), 0.0f, displacements[0], 0x0, 0.0f, 0x0, endPos - pos);
-		}
-	}
-
-	if (weapon) {
-		pos = weapon-&gt;weaponMuzzlePos;
-	}
-	for (int a = 1; a &lt; 10; ++a) {
-		displacements[a] += (gs-&gt;randFloat() - 0.5f) * 0.3f;
-		displacements2[a] += (gs-&gt;randFloat() - 0.5f) * 0.3f;
-	}
-}
-
-void CLightingProjectile::Draw(void)
-{
-	inArray=true;
-	unsigned char col[4];
-	col[0]=(unsigned char) (color.x*255);
-	col[1]=(unsigned char) (color.y*255);
-	col[2]=(unsigned char) (color.z*255);
-	col[3]=1;//intensity*255;
-
-	float3 dir=(endPos-pos).Normalize();
-	float3 dif(pos-camera-&gt;pos);
-	float camDist=dif.Length();
-	dif/=camDist;
-	float3 dir1(dif.cross(dir));
-	dir1.Normalize();
-	float3 tempPos=pos;
-
-	va-&gt;EnlargeArrays(18*4,0,VA_SIZE_TC);
-	for(int a=0;a&lt;9;++a){
-		float f=(a+1)*0.111f;
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,    col);
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
-		tempPos=pos*(1-f)+endPos*f;
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a+1]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a+1]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart    ,col);
-	}
-
-	tempPos=pos;
-	for(int a=0;a&lt;9;++a){
-		float f=(a+1)*0.111f;
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,    col);
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
-		tempPos=pos*(1-f)+endPos*f;
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a+1]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
-		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a+1]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart    ,col);
-	}
-}
-
-void CLightingProjectile::DependentDied(CObject* o)
-{
-	if(o==weapon)
-		weapon=0;
-	CProjectile::DependentDied(o);
-}

Deleted: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -1,30 +0,0 @@
-#ifndef LIGHTINGPROJECTILE_H
-#define LIGHTINGPROJECTILE_H
-
-#include &quot;WeaponProjectile.h&quot;
-
-class CWeapon;
-
-class CLightingProjectile :
-	public CWeaponProjectile
-{
-	CR_DECLARE(CLightingProjectile);
-public:
-	CLightingProjectile(const float3&amp; pos, const float3&amp; end, CUnit* owner, const float3&amp; color,
-		const WeaponDef *weaponDef, int ttl = 10, CWeapon* weap = 0 GML_PARG_H);
-	~CLightingProjectile(void);
-
-	float3 color;
-	float3 endPos;
-	CWeapon* weapon;
-
-	float displacements[10];
-	float displacements2[10];
-
-	void Update(void);
-	void Draw(void);
-	void DependentDied(CObject* o);
-};
-
-
-#endif /* LIGHTINGPROJECTILE_H */

Copied: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.cpp (from rev 6979, trunk/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.cpp)
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.cpp	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -0,0 +1,127 @@
+#include &quot;StdAfx.h&quot;
+#include &quot;mmgr.h&quot;
+
+#include &quot;Game/Camera.h&quot;
+#include &quot;LightningProjectile.h&quot;
+#include &quot;Rendering/GL/VertexArray.h&quot;
+#include &quot;Sim/Weapons/Weapon.h&quot;
+#include &quot;Sim/Projectiles/ProjectileHandler.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+#include &quot;Game/GlobalSynced.h&quot;
+
+#ifdef TRACE_SYNC
+	#include &quot;Sync/SyncTracer.h&quot;
+#endif
+
+CR_BIND_DERIVED(CLightningProjectile, CWeaponProjectile, (float3(0,0,0),float3(0,0,0),NULL,float3(0,0,0),NULL,0,NULL));
+
+CR_REG_METADATA(CLightningProjectile,(
+	CR_MEMBER(color),
+	CR_MEMBER(endPos),
+	CR_MEMBER(weapon),
+	CR_MEMBER(displacements),
+	CR_MEMBER(displacements2),
+	CR_RESERVED(16)
+	));
+
+CLightningProjectile::CLightningProjectile(const float3&amp; pos, const float3&amp; end,
+		CUnit* owner, const float3&amp; color, const WeaponDef *weaponDef,
+		int ttl, CWeapon* weap GML_PARG_C):
+	CWeaponProjectile(pos, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
+	color(color),
+	endPos(end),
+	weapon(weap)
+{
+	checkCol=false;
+	drawRadius=pos.distance(endPos);
+
+	displacements[0]=0;
+	for(int a=1;a&lt;10;++a)
+		displacements[a]=(gs-&gt;randFloat()-0.5f)*drawRadius*0.05f;
+
+	displacements2[0]=0;
+	for(int a=1;a&lt;10;++a)
+		displacements2[a]=(gs-&gt;randFloat()-0.5f)*drawRadius*0.05f;
+
+	if(weapon)
+		AddDeathDependence(weapon);
+
+#ifdef TRACE_SYNC
+	tracefile &lt;&lt; &quot;New lightning: &quot;;
+	tracefile &lt;&lt; pos.x &lt;&lt; &quot; &quot; &lt;&lt; pos.y &lt;&lt; &quot; &quot; &lt;&lt; pos.z &lt;&lt; &quot; &quot; &lt;&lt; end.x &lt;&lt; &quot; &quot; &lt;&lt; end.y &lt;&lt; &quot; &quot; &lt;&lt; end.z &lt;&lt; &quot;\n&quot;;
+#endif
+
+	if (cegTag.size() &gt; 0) {
+		ceg.Load(explGenHandler, cegTag);
+	}
+}
+
+CLightningProjectile::~CLightningProjectile(void)
+{
+}
+
+void CLightningProjectile::Update(void)
+{
+	ttl--;
+
+	if (ttl &lt;= 0) {
+		deleteMe = true;
+	} else {
+		if (cegTag.size() &gt; 0) {
+			ceg.Explosion(pos + ((endPos - pos) / ttl), 0.0f, displacements[0], 0x0, 0.0f, 0x0, endPos - pos);
+		}
+	}
+
+	if (weapon) {
+		pos = weapon-&gt;weaponMuzzlePos;
+	}
+	for (int a = 1; a &lt; 10; ++a) {
+		displacements[a] += (gs-&gt;randFloat() - 0.5f) * 0.3f;
+		displacements2[a] += (gs-&gt;randFloat() - 0.5f) * 0.3f;
+	}
+}
+
+void CLightningProjectile::Draw(void)
+{
+	inArray=true;
+	unsigned char col[4];
+	col[0]=(unsigned char) (color.x*255);
+	col[1]=(unsigned char) (color.y*255);
+	col[2]=(unsigned char) (color.z*255);
+	col[3]=1;//intensity*255;
+
+	float3 dir=(endPos-pos).Normalize();
+	float3 dif(pos-camera-&gt;pos);
+	float camDist=dif.Length();
+	dif/=camDist;
+	float3 dir1(dif.cross(dir));
+	dir1.Normalize();
+	float3 tempPos=pos;
+
+	va-&gt;EnlargeArrays(18*4,0,VA_SIZE_TC);
+	for(int a=0;a&lt;9;++a){
+		float f=(a+1)*0.111f;
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,    col);
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+		tempPos=pos*(1-f)+endPos*f;
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a+1]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements[a+1]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart    ,col);
+	}
+
+	tempPos=pos;
+	for(int a=0;a&lt;9;++a){
+		float f=(a+1)*0.111f;
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,    col);
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+		tempPos=pos*(1-f)+endPos*f;
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a+1]-weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+		va-&gt;AddVertexQTC(tempPos+dir1*(displacements2[a+1]+weaponDef-&gt;thickness),weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart    ,col);
+	}
+}
+
+void CLightningProjectile::DependentDied(CObject* o)
+{
+	if(o==weapon)
+		weapon=0;
+	CProjectile::DependentDied(o);
+}

Copied: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.h (from rev 6979, trunk/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.h)
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.h	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightningProjectile.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -0,0 +1,30 @@
+#ifndef LIGHTNINGPROJECTILE_H
+#define LIGHTNINGPROJECTILE_H
+
+#include &quot;WeaponProjectile.h&quot;
+
+class CWeapon;
+
+class CLightningProjectile :
+	public CWeaponProjectile
+{
+	CR_DECLARE(CLightningProjectile);
+public:
+	CLightningProjectile(const float3&amp; pos, const float3&amp; end, CUnit* owner, const float3&amp; color,
+		const WeaponDef *weaponDef, int ttl = 10, CWeapon* weap = 0 GML_PARG_H);
+	~CLightningProjectile(void);
+
+	float3 color;
+	float3 endPos;
+	CWeapon* weapon;
+
+	float displacements[10];
+	float displacements2[10];
+
+	void Update(void);
+	void Draw(void);
+	void DependentDied(CObject* o);
+};
+
+
+#endif /* LIGHTNINGPROJECTILE_H */

Modified: branches/caiinterface/rts/Sim/Units/Unit.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.h	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Units/Unit.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -7,7 +7,6 @@
 #include &lt;map&gt;
 #include &lt;vector&gt;
 #include &lt;string&gt;
-#include &lt;deque&gt;
 
 #include &quot;Lua/LuaUnitMaterial.h&quot;
 #include &quot;Sim/Objects/SolidObject.h&quot;

Modified: branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -84,11 +84,9 @@
 	numUnitDefs = unitDefNames.size();
 
 	/*
-	if (gameSetup) {
-		// ?? &quot;restricted&quot; does not automatically mean &quot;cannot be built
-		// at all, so we don't need the unitdef for this unit&quot; -- Kloot
-		numUnitDefs -= gameSetup-&gt;restrictedUnits.size();
-	}
+	// ?? &quot;restricted&quot; does not automatically mean &quot;cannot be built
+	// at all, so we don't need the unitdef for this unit&quot; -- Kloot
+	numUnitDefs -= gameSetup-&gt;restrictedUnits.size();
 	*/
 
 	// This could be wasteful if there is a lot of restricted units, but that is not that likely
@@ -101,17 +99,15 @@
 		const string unitName = unitDefNames[a];
 
 		/*
-		if (gameSetup) {
-			// Restrictions may tell us not to use this unit at all
-			// FIXME: causes mod errors when a unit is restricted to
-			// 0, since GetUnitByName() will return NULL if its UnitDef
-			// has not been loaded -- Kloot
-			const std::map&lt;std::string, int&gt;&amp; resUnits = gameSetup-&gt;restrictedUnits;
+		// Restrictions may tell us not to use this unit at all
+		// FIXME: causes mod errors when a unit is restricted to
+		// 0, since GetUnitByName() will return NULL if its UnitDef
+		// has not been loaded -- Kloot
+		const std::map&lt;std::string, int&gt;&amp; resUnits = gameSetup-&gt;restrictedUnits;
 
-			if ((resUnits.find(unitName) != resUnits.end()) &amp;&amp;
-				(resUnits.find(unitName)-&gt;second == 0)) {
-				continue;
-			}
+		if ((resUnits.find(unitName) != resUnits.end()) &amp;&amp;
+			(resUnits.find(unitName)-&gt;second == 0)) {
+			continue;
 		}
 		*/
 
@@ -504,12 +500,10 @@
 	ud.minAirBasePower = udTable.GetFloat(&quot;minAirBasePower&quot;, 0.0f);
 	ud.maxThisUnit = udTable.GetInt(&quot;unitRestricted&quot;, MAX_UNITS);
 
-	if (gameSetup) {
-		string lname = StringToLower(ud.name);
+	string lname = StringToLower(ud.name);
 
-		if (gameSetup-&gt;restrictedUnits.find(lname) != gameSetup-&gt;restrictedUnits.end()) {
-			ud.maxThisUnit = std::min(ud.maxThisUnit, gameSetup-&gt;restrictedUnits.find(lname)-&gt;second);
-		}
+	if (gameSetup-&gt;restrictedUnits.find(lname) != gameSetup-&gt;restrictedUnits.end()) {
+		ud.maxThisUnit = std::min(ud.maxThisUnit, gameSetup-&gt;restrictedUnits.find(lname)-&gt;second);
 	}
 
 	ud.categoryString = udTable.GetString(&quot;category&quot;, &quot;&quot;);

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -149,22 +149,19 @@
 
 	waterDamage = mapInfo-&gt;water.damage;
 
-	if (gameSetup) {
-		maxUnits = gameSetup-&gt;maxUnits;
-	}
+	maxUnits = gameSetup-&gt;maxUnits;
+
 	if (maxUnits &gt; ((MAX_UNITS / gs-&gt;activeTeams) - 5)) {
 		maxUnits = (MAX_UNITS / gs-&gt;activeTeams) -5;
 	}
 
-	if (gameSetup) {
-		if (gameSetup-&gt;limitDgun) {
-			limitDgun = true;
-			dgunRadius = gs-&gt;mapx * 3;
-		}
-		if (gameSetup-&gt;diminishingMMs) {
-			diminishingMetalMakers = true;
-		}
+	if (gameSetup-&gt;limitDgun) {
+		limitDgun = true;
+		dgunRadius = gs-&gt;mapx * 3;
 	}
+	if (gameSetup-&gt;diminishingMMs) {
+		diminishingMetalMakers = true;
+	}
 
 	if (!serializing) {
 		airBaseHandler = SAFE_NEW CAirBaseHandler;

Modified: branches/caiinterface/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitLoader.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Units/UnitLoader.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -40,7 +40,7 @@
 #include &quot;Sim/Weapons/EmgCannon.h&quot;
 #include &quot;Sim/Weapons/FlameThrower.h&quot;
 #include &quot;Sim/Weapons/LaserCannon.h&quot;
-#include &quot;Sim/Weapons/LightingCannon.h&quot;
+#include &quot;Sim/Weapons/LightningCannon.h&quot;
 #include &quot;Sim/Weapons/MeleeWeapon.h&quot;
 #include &quot;Sim/Weapons/MissileLauncher.h&quot;
 #include &quot;Sim/Weapons/NoWeapon.h&quot;
@@ -324,10 +324,10 @@
 		const float scaleFactor = (ud-&gt;canfly)? 0.5f: 1.0f;
 		unit-&gt;collisionVolume-&gt;SetDefaultScale(unit-&gt;model-&gt;radius * scaleFactor);
 
-		if (unit-&gt;collisionVolume-&gt;volumeBoundingRadius &lt;= 30.0f) {
+		if (unit-&gt;collisionVolume-&gt;GetBoundingRadius() &lt;= 30.0f) {
 			// the interval-based method fails too easily for units
 			// with small default volumes, force use of raytracing
-			unit-&gt;collisionVolume-&gt;testType = COLVOL_TEST_CONT;
+			unit-&gt;collisionVolume-&gt;SetTestType(COLVOL_TEST_CONT);
 		}
 	}
 
@@ -426,9 +426,9 @@
 	} else if (weapondef-&gt;type == &quot;BeamLaser&quot;) {
 		weapon = SAFE_NEW CBeamLaser(owner);
 		((CBeamLaser*) weapon)-&gt;color = weapondef-&gt;visuals.color;
-	} else if (weapondef-&gt;type == &quot;LightingCannon&quot;) {
-		weapon = SAFE_NEW CLightingCannon(owner);
-		((CLightingCannon*) weapon)-&gt;color = weapondef-&gt;visuals.color;
+	} else if (weapondef-&gt;type == &quot;LightningCannon&quot;) {
+		weapon = SAFE_NEW CLightningCannon(owner);
+		((CLightningCannon*) weapon)-&gt;color = weapondef-&gt;visuals.color;
 	} else if (weapondef-&gt;type == &quot;EmgCannon&quot;) {
 		weapon = SAFE_NEW CEmgCannon(owner);
 	} else if (weapondef-&gt;type == &quot;DGun&quot;) {

Modified: branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Weapons/BeamLaser.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -14,6 +14,7 @@
 #include &quot;Sim/Units/COB/CobFile.h&quot;
 #include &quot;Sim/Units/COB/CobInstance.h&quot;
 #include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Units/UnitTypes/Building.h&quot;
 #include &quot;Sim/Weapons/PlasmaRepulser.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;WeaponDefHandler.h&quot;
@@ -179,7 +180,12 @@
 
 void CBeamLaser::FireInternal(float3 dir, bool sweepFire)
 {
-	float rangeMod=1.3f;
+	float rangeMod=1.0f;
+	CBuilding* building = dynamic_cast&lt;CBuilding*&gt;(owner);
+	if (!building) {
+		rangeMod=1.3f;  //help units fire while chasing
+	}
+
 #ifdef DIRECT_CONTROL_ALLOWED
 	if(owner-&gt;directControl)
 		rangeMod=0.95f;

Deleted: branches/caiinterface/rts/Sim/Weapons/LightingCannon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/LightingCannon.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Weapons/LightingCannon.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -1,132 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;Game/GameHelper.h&quot;
-#include &quot;LightingCannon.h&quot;
-#include &quot;Map/Ground.h&quot;
-#include &quot;PlasmaRepulser.h&quot;
-#include &quot;Sim/Misc/InterceptHandler.h&quot;
-#include &quot;Sim/Projectiles/WeaponProjectiles/LightingProjectile.h&quot;
-#include &quot;Sim/Units/Unit.h&quot;
-#include &quot;Sound.h&quot;
-#include &quot;WeaponDefHandler.h&quot;
-#include &quot;mmgr.h&quot;
-
-CR_BIND_DERIVED(CLightingCannon, CWeapon, (NULL));
-
-CR_REG_METADATA(CLightingCannon,(
-	CR_MEMBER(color),
-	CR_RESERVED(8)
-	));
-
-CLightingCannon::CLightingCannon(CUnit* owner)
-: CWeapon(owner)
-{
-}
-
-CLightingCannon::~CLightingCannon(void)
-{
-}
-
-void CLightingCannon::Update(void)
-{
-	if(targetType!=Target_None){
-		weaponPos=owner-&gt;pos+owner-&gt;frontdir*relWeaponPos.z+owner-&gt;updir*relWeaponPos.y+owner-&gt;rightdir*relWeaponPos.x;
-		weaponMuzzlePos=owner-&gt;pos+owner-&gt;frontdir*relWeaponMuzzlePos.z+owner-&gt;updir*relWeaponMuzzlePos.y+owner-&gt;rightdir*relWeaponMuzzlePos.x;
-		if(!onlyForward){
-			wantedDir=targetPos-weaponPos;
-			wantedDir.Normalize();
-		}
-	}
-	CWeapon::Update();
-}
-
-bool CLightingCannon::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
-{
-	if (!CWeapon::TryTarget(pos, userTarget, unit))
-		return false;
-
-	if (!weaponDef-&gt;waterweapon) {
-		if (unit) {
-			if (unit-&gt;isUnderWater)
-				return false;
-		} else {
-			if (pos.y &lt; 0)
-				return false;
-		}
-	}
-
-	float3 dir = pos - weaponMuzzlePos;
-	float length = dir.Length();
-	if (length == 0)
-		return true;
-
-	dir /= length;
-
-	float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
-	if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
-		return false;
-
-	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
-		return false;
-	}
-	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, (accuracy + sprayAngle), owner-&gt;allyteam, owner)) {
-		return false;
-	}
-	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, (accuracy + sprayAngle), owner)) {
-		return false;
-	}
-
-	return true;
-}
-
-void CLightingCannon::Init(void)
-{
-	CWeapon::Init();
-}
-
-void CLightingCannon::Fire(void)
-{
-	float3 dir=targetPos-weaponMuzzlePos;
-	dir.Normalize();
-	dir+=(gs-&gt;randVector()*sprayAngle+salvoError)*(1-owner-&gt;limExperience*0.5f);
-	dir.Normalize();
-	CUnit* u=0;
-	float r=helper-&gt;TraceRay(weaponMuzzlePos,dir,range,0,owner,u,collisionFlags);
-
-	float3 newDir;
-	CPlasmaRepulser* shieldHit;
-	float shieldLength=interceptHandler.AddShieldInterceptableBeam(this,weaponMuzzlePos,dir,range,newDir,shieldHit);
-	if(shieldLength&lt;r){
-		r=shieldLength;
-		if(shieldHit) {
-			shieldHit-&gt;BeamIntercepted(this);
-		}
-	}
-
-//	if(u)
-//		u-&gt;DoDamage(damages,owner,ZeroVector);
-
-	// Dynamic Damage
-	DamageArray dynDamages;
-	if (weaponDef-&gt;dynDamageExp &gt; 0)
-		dynDamages = weaponDefHandler-&gt;DynamicDamages(weaponDef-&gt;damages, weaponMuzzlePos, targetPos, weaponDef-&gt;dynDamageRange&gt;0?weaponDef-&gt;dynDamageRange:weaponDef-&gt;range, weaponDef-&gt;dynDamageExp, weaponDef-&gt;dynDamageMin, weaponDef-&gt;dynDamageInverted);
-
-	helper-&gt;Explosion(weaponMuzzlePos+dir*r,weaponDef-&gt;dynDamageExp&gt;0?dynDamages:weaponDef-&gt;damages,areaOfEffect,weaponDef-&gt;edgeEffectiveness,weaponDef-&gt;explosionSpeed,owner,true,0.5f,weaponDef-&gt;noSelfDamage,weaponDef-&gt;explosionGenerator, u,dir, weaponDef-&gt;id);
-
-	SAFE_NEW CLightingProjectile(weaponMuzzlePos,
-		weaponMuzzlePos + dir * (r + 10), owner, color, weaponDef, 10, this);
-
-	if (fireSoundId &amp;&amp; (!weaponDef-&gt;soundTrigger || salvoLeft == salvoSize - 1))
-		sound-&gt;PlaySample(fireSoundId, owner, fireSoundVolume);
-
-}
-
-
-
-void CLightingCannon::SlowUpdate(void)
-{
-	CWeapon::SlowUpdate();
-	//We don't do hardcoded inaccuracies, use targetMoveError if you want inaccuracy!
-//	if(targetType==Target_Unit){
-//		predict=(gs-&gt;randFloat()-0.5f)*20*range/weaponPos.distance(targetUnit-&gt;midPos)*(1.2f-owner-&gt;limExperience);		//make the weapon somewhat less effecient against aircrafts hopefully
-//	}
-}

Deleted: branches/caiinterface/rts/Sim/Weapons/LightingCannon.h
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/LightingCannon.h	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Weapons/LightingCannon.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -1,25 +0,0 @@
-#ifndef LIGHTINGCANNON_H
-#define LIGHTINGCANNON_H
-
-#include &quot;Weapon.h&quot;
-
-class CLightingCannon :
-	public CWeapon
-{
-	CR_DECLARE(CLightingCannon);
-public:
-	CLightingCannon(CUnit* owner);
-	~CLightingCannon(void);
-
-	void Update(void);
-	bool TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit);
-
-	void Init(void);
-	void Fire(void);
-
-	float3 color;
-	void SlowUpdate(void);
-};
-
-
-#endif /* LIGHTINGCANNON_H */

Copied: branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp (from rev 6979, trunk/rts/Sim/Weapons/LightningCannon.cpp)
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Weapons/LightningCannon.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -0,0 +1,132 @@
+#include &quot;StdAfx.h&quot;
+#include &quot;Game/GameHelper.h&quot;
+#include &quot;LightningCannon.h&quot;
+#include &quot;Map/Ground.h&quot;
+#include &quot;PlasmaRepulser.h&quot;
+#include &quot;Sim/Misc/InterceptHandler.h&quot;
+#include &quot;Sim/Projectiles/WeaponProjectiles/LightningProjectile.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sound.h&quot;
+#include &quot;WeaponDefHandler.h&quot;
+#include &quot;mmgr.h&quot;
+
+CR_BIND_DERIVED(CLightningCannon, CWeapon, (NULL));
+
+CR_REG_METADATA(CLightningCannon,(
+	CR_MEMBER(color),
+	CR_RESERVED(8)
+	));
+
+CLightningCannon::CLightningCannon(CUnit* owner)
+: CWeapon(owner)
+{
+}
+
+CLightningCannon::~CLightningCannon(void)
+{
+}
+
+void CLightningCannon::Update(void)
+{
+	if(targetType!=Target_None){
+		weaponPos=owner-&gt;pos+owner-&gt;frontdir*relWeaponPos.z+owner-&gt;updir*relWeaponPos.y+owner-&gt;rightdir*relWeaponPos.x;
+		weaponMuzzlePos=owner-&gt;pos+owner-&gt;frontdir*relWeaponMuzzlePos.z+owner-&gt;updir*relWeaponMuzzlePos.y+owner-&gt;rightdir*relWeaponMuzzlePos.x;
+		if(!onlyForward){
+			wantedDir=targetPos-weaponPos;
+			wantedDir.Normalize();
+		}
+	}
+	CWeapon::Update();
+}
+
+bool CLightningCannon::TryTarget(const float3&amp; pos, bool userTarget, CUnit* unit)
+{
+	if (!CWeapon::TryTarget(pos, userTarget, unit))
+		return false;
+
+	if (!weaponDef-&gt;waterweapon) {
+		if (unit) {
+			if (unit-&gt;isUnderWater)
+				return false;
+		} else {
+			if (pos.y &lt; 0)
+				return false;
+		}
+	}
+
+	float3 dir = pos - weaponMuzzlePos;
+	float length = dir.Length();
+	if (length == 0)
+		return true;
+
+	dir /= length;
+
+	float g = ground-&gt;LineGroundCol(weaponMuzzlePos, pos);
+	if (g &gt; 0 &amp;&amp; g &lt; length * 0.9f)
+		return false;
+
+	if (avoidFeature &amp;&amp; helper-&gt;LineFeatureCol(weaponMuzzlePos, dir, length)) {
+		return false;
+	}
+	if (avoidFriendly &amp;&amp; helper-&gt;TestAllyCone(weaponMuzzlePos, dir, length, (accuracy + sprayAngle), owner-&gt;allyteam, owner)) {
+		return false;
+	}
+	if (avoidNeutral &amp;&amp; helper-&gt;TestNeutralCone(weaponMuzzlePos, dir, length, (accuracy + sprayAngle), owner)) {
+		return false;
+	}
+
+	return true;
+}
+
+void CLightningCannon::Init(void)
+{
+	CWeapon::Init();
+}
+
+void CLightningCannon::Fire(void)
+{
+	float3 dir=targetPos-weaponMuzzlePos;
+	dir.Normalize();
+	dir+=(gs-&gt;randVector()*sprayAngle+salvoError)*(1-owner-&gt;limExperience*0.5f);
+	dir.Normalize();
+	CUnit* u=0;
+	float r=helper-&gt;TraceRay(weaponMuzzlePos,dir,range,0,owner,u,collisionFlags);
+
+	float3 newDir;
+	CPlasmaRepulser* shieldHit;
+	float shieldLength=interceptHandler.AddShieldInterceptableBeam(this,weaponMuzzlePos,dir,range,newDir,shieldHit);
+	if(shieldLength&lt;r){
+		r=shieldLength;
+		if(shieldHit) {
+			shieldHit-&gt;BeamIntercepted(this);
+		}
+	}
+
+//	if(u)
+//		u-&gt;DoDamage(damages,owner,ZeroVector);
+
+	// Dynamic Damage
+	DamageArray dynDamages;
+	if (weaponDef-&gt;dynDamageExp &gt; 0)
+		dynDamages = weaponDefHandler-&gt;DynamicDamages(weaponDef-&gt;damages, weaponMuzzlePos, targetPos, weaponDef-&gt;dynDamageRange&gt;0?weaponDef-&gt;dynDamageRange:weaponDef-&gt;range, weaponDef-&gt;dynDamageExp, weaponDef-&gt;dynDamageMin, weaponDef-&gt;dynDamageInverted);
+
+	helper-&gt;Explosion(weaponMuzzlePos+dir*r,weaponDef-&gt;dynDamageExp&gt;0?dynDamages:weaponDef-&gt;damages,areaOfEffect,weaponDef-&gt;edgeEffectiveness,weaponDef-&gt;explosionSpeed,owner,true,0.5f,weaponDef-&gt;noSelfDamage,weaponDef-&gt;explosionGenerator, u,dir, weaponDef-&gt;id);
+
+	SAFE_NEW CLightningProjectile(weaponMuzzlePos,
+		weaponMuzzlePos + dir * (r + 10), owner, color, weaponDef, 10, this);
+
+	if (fireSoundId &amp;&amp; (!weaponDef-&gt;soundTrigger || salvoLeft == salvoSize - 1))
+		sound-&gt;PlaySample(fireSoundId, owner, fireSoundVolume);
+
+}
+
+
+
+void CLightningCannon::SlowUpdate(void)
+{
+	CWeapon::SlowUpdate();
+	//We don't do hardcoded inaccuracies, use targetMoveError if you want inaccuracy!
+//	if(targetType==Target_Unit){
+//		predict=(gs-&gt;randFloat()-0.5f)*20*range/weaponPos.distance(targetUnit-&gt;midPos)*(1.2f-owner-&gt;limExperience);		//make the weapon somewhat less effecient against aircrafts hopefully
+//	}
+}

Copied: branches/caiinterface/rts/Sim/Weapons/LightningCannon.h (from rev 6979, trunk/rts/Sim/Weapons/LightningCannon.h)
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/LightningCannon.h	                        (rev 0)
+++ branches/caiinterface/rts/Sim/Weapons/LightningCannon.h	2008-11-05 15:44:16 UTC (rev 6980)
@@ -0,0 +1,25 @@
+#ifndef LIGHTNINGCANNON_H
+#define LIGHTNINGCANNON_H
+
+#include &quot;Weapon.h&quot;
+
+class CLightningCannon :
+	public CWeapon
+{
+	CR_DECLARE(CLightningCannon);
+public:
+	CLightningCannon(CUnit* owner);
+	~CLightningCannon(void);
+
+	void Update(void);
+	bool TryTarget(const float3&amp; pos,bool userTarget,CUnit* unit);
+
+	void Init(void);
+	void Fire(void);
+
+	float3 color;
+	void SlowUpdate(void);
+};
+
+
+#endif /* LIGHTNINGCANNON_H */

Modified: branches/caiinterface/rts/Sim/Weapons/WeaponDefHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/Sim/Weapons/WeaponDefHandler.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -427,7 +427,8 @@
 			wd.visuals.texture2 = &amp;ph-&gt;laserendtex;
 			wd.visuals.texture3 = &amp;ph-&gt;beamlaserflaretex;
 		}
-	} else if (wd.type == &quot;LightingCannon&quot;) {
+	} else if (wd.type == &quot;LightingCannon&quot; || wd.type == &quot;LightningCannon&quot;) {
+		wd.type = &quot;LightningCannon&quot;;
 		wd.visuals.texture1 = &amp;ph-&gt;laserfallofftex;
 		wd.thickness = wdTable.GetFloat(&quot;thickness&quot;, 0.8f);
 	} else if (wd.type == &quot;EmgCannon&quot;) {

Modified: branches/caiinterface/rts/System/SpringApp.cpp
===================================================================
--- branches/caiinterface/rts/System/SpringApp.cpp	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/System/SpringApp.cpp	2008-11-05 15:44:16 UTC (rev 6980)
@@ -1197,8 +1197,7 @@
 		delete pregame;			//in case we exit during init
 	if (game)
 		delete game;
-	if (gameSetup)
-		delete gameSetup;
+	delete gameSetup;
 	delete font;
 	CNamedTextures::Kill();
 	GLContext::Free();

Modified: branches/caiinterface/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/caiinterface/rts/build/vstudio8/rts.vcproj	2008-11-05 15:13:01 UTC (rev 6979)
+++ branches/caiinterface/rts/build/vstudio8/rts.vcproj	2008-11-05 15:44:16 UTC (rev 6980)
@@ -48,7 +48,7 @@
 				BasicRuntimeChecks=&quot;3&quot;
 				RuntimeLibrary=&quot;3&quot;
 				RuntimeTypeInfo=&quot;true&quot;
-				UsePrecompiledHeader=&quot;2&quot;
+				UsePrecompiledHeader=&quot;0&quot;
 				WarningLevel=&quot;3&quot;
 				Detect64BitPortabilityProblems=&quot;true&quot;
 				DebugInformationFormat=&quot;3&quot;
@@ -519,7 +519,7 @@
 				BasicRuntimeChecks=&quot;3&quot;
 				RuntimeLibrary=&quot;3&quot;
 				RuntimeTypeInfo=&quot;true&quot;
-				UsePrecompiledHeader=&quot;2&quot;
+				UsePrecompiledHeader=&quot;0&quot;
 				WarningLevel=&quot;3&quot;
 				Detect64BitPortabilityProblems=&quot;true&quot;
 				DebugInformationFormat=&quot;3&quot;
@@ -2810,11 +2810,11 @@
 						&gt;
 					&lt;/File&gt;
 					&lt;File
-						RelativePath=&quot;..\..\Sim\Projectiles\WeaponProjectiles\LightingProjectile.cpp&quot;
+						RelativePath=&quot;..\..\Sim\Projectiles\WeaponProjectiles\LightningProjectile.cpp&quot;
 						&gt;
 					&lt;/File&gt;
 					&lt;File
-						RelativePath=&quot;..\..\Sim\Projectiles\WeaponProjectiles\LightingProjectile.h&quot;
+						RelativePath=&quot;..\..\Sim\Projectiles\WeaponProjectiles\LightningProjectile.h&quot;
 						&gt;
 					&lt;/File&gt;
 					&lt;File
@@ -2922,11 +2922,11 @@
 						&gt;
 					&lt;/File&gt;
 					&lt;File
-						RelativePath=&quot;..\..\Sim\Weapons\LightingCannon.cpp&quot;
+						RelativePath=&quot;..\..\Sim\Weapons\LightningCannon.cpp&quot;
 						&gt;
 					&lt;/File&gt;
 					&lt;File
-						RelativePath=&quot;..\..\Sim\Weapons\LightingCannon.h&quot;
+						RelativePath=&quot;..\..\Sim\Weapons\LightningCannon.h&quot;
 						&gt;
 					&lt;/File&gt;
 					&lt;File
@@ -5749,7 +5749,7 @@
 						&gt;
 						&lt;Tool
 							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;2&quot;
+							useprecompiledheader=&quot;0&quot;
 						/&gt;
 					&lt;/FileConfiguration&gt;
 					&lt;FileConfiguration
@@ -5757,7 +5757,7 @@
 						&gt;
 						&lt;Tool
 							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;2&quot;
+							useprecompiledheader=&quot;0&quot;
 						/&gt;
 					&lt;/FileConfiguration&gt;
 					&lt;FileConfiguration
@@ -5765,7 +5765,7 @@
 						&gt;
 						&lt;Tool
 							Name=&quot;VCCLCompilerTool&quot;
-							UsePrecompiledHeader=&quot;2&quot;
+							useprecompiledheader=&quot;0&quot;
 						/&gt;
 					&lt;/FileConfiguration&gt;
 				&lt;/File&gt;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001748.html">[Taspring-linux-commit] r6979 - in branches/caiinterface:	AI/Interfaces AI/Interfaces/C AI/Skirmish	AI/Skirmish/CSAI/ABICompatibilityLayer	AI/Skirmish/CSAI/CSAILoader rts/ExternalAI rts/ExternalAI/Interface
</A></li>
	<LI>Next message: <A HREF="001750.html">[Taspring-linux-commit] r6981 - in branches/gmltest/rts/Game: . UI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1749">[ date ]</a>
              <a href="thread.html#1749">[ thread ]</a>
              <a href="subject.html#1749">[ subject ]</a>
              <a href="author.html#1749">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
