<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r6956 - in branches/caiinterface: .	AI/Skirmish/AAI Documentation game/AI/AAI game/LuaUI/Widgets	installer/builddata/springcontent	installer/builddata/springcontent/shaders rts/ExternalAI	rts/Game rts/Game/Server rts/Game/UI rts/Lua rts/Map	rts/Map/SM3 rts/Map/SM3/terrain rts/Map/SMF rts/Rendering	rts/Rendering/Env rts/Rendering/GL rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/Unsynced	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/CommandAI rts/Sim/Units/UnitTypes	rts/Sim/Weapons rts/System rts/System/FileSystem	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/System/Sync	rts/build/scons rts/build/vstudio8 rts/lib/gml	rts/lib/hpiutil2 tools/DedicatedServer tools/unitsync
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6956%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Skirmish/AAI%20Documentation%20game/AI/AAI%20game/LuaUI/Widgets%0A%09installer/builddata/springcontent%0A%09installer/builddata/springcontent/shaders%20rts/ExternalAI%0A%09rts/Game%20rts/Game/Server%20rts/Game/UI%20rts/Lua%20rts/Map%0A%09rts/Map/SM3%20rts/Map/SM3/terrain%20rts/Map/SMF%20rts/Rendering%0A%09rts/Rendering/Env%20rts/Rendering/GL%20rts/Rendering/UnitModels%0A%09rts/Sim/Features%20rts/Sim/Misc%20rts/Sim/MoveTypes%20rts/Sim/Path%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/Unsynced%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Units/CommandAI%20rts/Sim/Units/UnitTypes%0A%09rts/Sim/Weapons%20rts/System%20rts/System/FileSystem%0A%09rts/System/Net%20rts/System/Platform%20rts/System/Platform/Linux%0A%09rts/System/Platform/Win%20rts/System/Script%20rts/System/Sync%0A%09rts/build/scons%20rts/build/vstudio8%20rts/lib/gml%0A%09rts/lib/hpiutil2%20tools/DedicatedServer%20tools/unitsync&In-Reply-To=%3C20081102102942.721E44762%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001724.html">
   <LINK REL="Next"  HREF="001726.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r6956 - in branches/caiinterface: .	AI/Skirmish/AAI Documentation game/AI/AAI game/LuaUI/Widgets	installer/builddata/springcontent	installer/builddata/springcontent/shaders rts/ExternalAI	rts/Game rts/Game/Server rts/Game/UI rts/Lua rts/Map	rts/Map/SM3 rts/Map/SM3/terrain rts/Map/SMF rts/Rendering	rts/Rendering/Env rts/Rendering/GL rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/Unsynced	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/CommandAI rts/Sim/Units/UnitTypes	rts/Sim/Weapons rts/System rts/System/FileSystem	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/System/Sync	rts/build/scons rts/build/vstudio8 rts/lib/gml	rts/lib/hpiutil2 tools/DedicatedServer tools/unitsync</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r6956%20-%20in%20branches/caiinterface%3A%20.%0A%09AI/Skirmish/AAI%20Documentation%20game/AI/AAI%20game/LuaUI/Widgets%0A%09installer/builddata/springcontent%0A%09installer/builddata/springcontent/shaders%20rts/ExternalAI%0A%09rts/Game%20rts/Game/Server%20rts/Game/UI%20rts/Lua%20rts/Map%0A%09rts/Map/SM3%20rts/Map/SM3/terrain%20rts/Map/SMF%20rts/Rendering%0A%09rts/Rendering/Env%20rts/Rendering/GL%20rts/Rendering/UnitModels%0A%09rts/Sim/Features%20rts/Sim/Misc%20rts/Sim/MoveTypes%20rts/Sim/Path%0A%09rts/Sim/Projectiles%20rts/Sim/Projectiles/Unsynced%0A%09rts/Sim/Projectiles/WeaponProjectiles%20rts/Sim/Units%0A%09rts/Sim/Units/CommandAI%20rts/Sim/Units/UnitTypes%0A%09rts/Sim/Weapons%20rts/System%20rts/System/FileSystem%0A%09rts/System/Net%20rts/System/Platform%20rts/System/Platform/Linux%0A%09rts/System/Platform/Win%20rts/System/Script%20rts/System/Sync%0A%09rts/build/scons%20rts/build/vstudio8%20rts/lib/gml%0A%09rts/lib/hpiutil2%20tools/DedicatedServer%20tools/unitsync&In-Reply-To=%3C20081102102942.721E44762%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r6956 - in branches/caiinterface: .	AI/Skirmish/AAI Documentation game/AI/AAI game/LuaUI/Widgets	installer/builddata/springcontent	installer/builddata/springcontent/shaders rts/ExternalAI	rts/Game rts/Game/Server rts/Game/UI rts/Lua rts/Map	rts/Map/SM3 rts/Map/SM3/terrain rts/Map/SMF rts/Rendering	rts/Rendering/Env rts/Rendering/GL rts/Rendering/UnitModels	rts/Sim/Features rts/Sim/Misc rts/Sim/MoveTypes rts/Sim/Path	rts/Sim/Projectiles rts/Sim/Projectiles/Unsynced	rts/Sim/Projectiles/WeaponProjectiles rts/Sim/Units	rts/Sim/Units/CommandAI rts/Sim/Units/UnitTypes	rts/Sim/Weapons rts/System rts/System/FileSystem	rts/System/Net rts/System/Platform rts/System/Platform/Linux	rts/System/Platform/Win rts/System/Script rts/System/Sync	rts/build/scons rts/build/vstudio8 rts/lib/gml	rts/lib/hpiutil2 tools/DedicatedServer tools/unitsync">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sun Nov  2 11:29:41 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001724.html">[Taspring-linux-commit] r6955 - in trunk/rts/Game: . Server
</A></li>
        <LI>Next message: <A HREF="001726.html">[Taspring-linux-commit] r6957 - trunk/rts/Game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1725">[ date ]</a>
              <a href="thread.html#1725">[ thread ]</a>
              <a href="subject.html#1725">[ subject ]</a>
              <a href="author.html#1725">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-11-02 11:29:36 +0100 (Sun, 02 Nov 2008)
New Revision: 6956

Added:
   branches/caiinterface/rts/Game/SelectMenu.cpp
   branches/caiinterface/rts/Game/SelectMenu.h
Removed:
   branches/caiinterface/tools/unitsync/SyncServer.cpp
   branches/caiinterface/tools/unitsync/SyncServer.h
   branches/caiinterface/tools/unitsync/unitsyncLogOutput.h
Modified:
   branches/caiinterface/AI/Skirmish/AAI/AAI ReadMe.txt
   branches/caiinterface/AI/Skirmish/AAI/AAI.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAI.h
   branches/caiinterface/AI/Skirmish/AAI/AAIAttackManager.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIBrain.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIBrain.h
   branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.h
   branches/caiinterface/AI/Skirmish/AAI/AAIConstructor.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIExecute.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIExecute.h
   branches/caiinterface/AI/Skirmish/AAI/AAIGroup.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIMap.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIMap.h
   branches/caiinterface/AI/Skirmish/AAI/AAISector.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.cpp
   branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.h
   branches/caiinterface/AI/Skirmish/AAI/aidef.h
   branches/caiinterface/Documentation/Spring start.txt
   branches/caiinterface/Documentation/changelog.txt
   branches/caiinterface/SConstruct
   branches/caiinterface/game/AI/AAI/AAI ReadMe.txt
   branches/caiinterface/game/LuaUI/Widgets/minimap_startbox.lua
   branches/caiinterface/installer/builddata/springcontent/EngineOptions.lua
   branches/caiinterface/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
   branches/caiinterface/rts/ExternalAI/AICallback.cpp
   branches/caiinterface/rts/ExternalAI/GroupHandler.cpp
   branches/caiinterface/rts/Game/Camera.cpp
   branches/caiinterface/rts/Game/ChatMessage.cpp
   branches/caiinterface/rts/Game/CommandMessage.cpp
   branches/caiinterface/rts/Game/Game.cpp
   branches/caiinterface/rts/Game/Game.h
   branches/caiinterface/rts/Game/GameData.cpp
   branches/caiinterface/rts/Game/GameHelper.cpp
   branches/caiinterface/rts/Game/GameHelper.h
   branches/caiinterface/rts/Game/GameServer.cpp
   branches/caiinterface/rts/Game/GameServer.h
   branches/caiinterface/rts/Game/GameSetup.cpp
   branches/caiinterface/rts/Game/GameSetup.h
   branches/caiinterface/rts/Game/GlobalSynced.cpp
   branches/caiinterface/rts/Game/PreGame.cpp
   branches/caiinterface/rts/Game/PreGame.h
   branches/caiinterface/rts/Game/SelectedUnits.cpp
   branches/caiinterface/rts/Game/SelectedUnits.h
   branches/caiinterface/rts/Game/Server/MsgStrings.h
   branches/caiinterface/rts/Game/Team.cpp
   branches/caiinterface/rts/Game/UI/GuiHandler.cpp
   branches/caiinterface/rts/Game/UI/InfoConsole.cpp
   branches/caiinterface/rts/Game/UI/InfoConsole.h
   branches/caiinterface/rts/Game/UI/InputReceiver.cpp
   branches/caiinterface/rts/Game/UI/LuaUI.cpp
   branches/caiinterface/rts/Game/UI/MiniMap.cpp
   branches/caiinterface/rts/Game/UI/MouseHandler.cpp
   branches/caiinterface/rts/Game/UI/SelectionKeyHandler.cpp
   branches/caiinterface/rts/Game/WaitCommandsAI.cpp
   branches/caiinterface/rts/Lua/LuaHandle.cpp
   branches/caiinterface/rts/Lua/LuaHandle.h
   branches/caiinterface/rts/Lua/LuaOpenGL.cpp
   branches/caiinterface/rts/Lua/LuaParser.cpp
   branches/caiinterface/rts/Lua/LuaUnitDefs.cpp
   branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp
   branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.h
   branches/caiinterface/rts/Lua/LuaUnsyncedRead.cpp
   branches/caiinterface/rts/Lua/LuaUnsyncedRead.h
   branches/caiinterface/rts/Map/BaseGroundDrawer.cpp
   branches/caiinterface/rts/Map/BaseGroundDrawer.h
   branches/caiinterface/rts/Map/Ground.cpp
   branches/caiinterface/rts/Map/MapInfo.cpp
   branches/caiinterface/rts/Map/MapInfo.h
   branches/caiinterface/rts/Map/SM3/Sm3GroundDrawer.cpp
   branches/caiinterface/rts/Map/SM3/terrain/TerrainBase.h
   branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp
   branches/caiinterface/rts/Map/SMF/BFGroundDrawer.h
   branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp
   branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp
   branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h
   branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
   branches/caiinterface/rts/Rendering/Env/DynWater.cpp
   branches/caiinterface/rts/Rendering/GL/VertexArray.cpp
   branches/caiinterface/rts/Rendering/GL/VertexArray.h
   branches/caiinterface/rts/Rendering/GL/glExtra.cpp
   branches/caiinterface/rts/Rendering/GL/myGL.cpp
   branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp
   branches/caiinterface/rts/Rendering/GroundFlash.cpp
   branches/caiinterface/rts/Rendering/GroundFlash.h
   branches/caiinterface/rts/Rendering/IconHandler.cpp
   branches/caiinterface/rts/Rendering/InMapDraw.cpp
   branches/caiinterface/rts/Rendering/ShadowHandler.cpp
   branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
   branches/caiinterface/rts/Rendering/glFont.cpp
   branches/caiinterface/rts/Sim/Features/Feature.cpp
   branches/caiinterface/rts/Sim/Misc/AirBaseHandler.cpp
   branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp
   branches/caiinterface/rts/Sim/Misc/CollisionHandler.h
   branches/caiinterface/rts/Sim/Misc/CollisionVolume.h
   branches/caiinterface/rts/Sim/Misc/DamageArrayHandler.cpp
   branches/caiinterface/rts/Sim/Misc/InterceptHandler.cpp
   branches/caiinterface/rts/Sim/Misc/QuadField.cpp
   branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp
   branches/caiinterface/rts/Sim/MoveTypes/GroundMoveType.cpp
   branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp
   branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h
   branches/caiinterface/rts/Sim/Path/PathEstimator.cpp
   branches/caiinterface/rts/Sim/Path/PathManager.cpp
   branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.cpp
   branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.h
   branches/caiinterface/rts/Sim/Projectiles/FireProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/FireProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Projectile.h
   branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.h
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
   branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
   branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.h
   branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h
   branches/caiinterface/rts/Sim/Units/CommandAI/LineDrawer.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp
   branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp
   branches/caiinterface/rts/Sim/Units/Unit.cpp
   branches/caiinterface/rts/Sim/Units/Unit.h
   branches/caiinterface/rts/Sim/Units/UnitDef.h
   branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
   branches/caiinterface/rts/Sim/Units/UnitHandler.h
   branches/caiinterface/rts/Sim/Units/UnitLoader.cpp
   branches/caiinterface/rts/Sim/Units/UnitTracker.cpp
   branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.cpp
   branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.h
   branches/caiinterface/rts/Sim/Units/UnitTypes/Building.cpp
   branches/caiinterface/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
   branches/caiinterface/rts/Sim/Units/UnitTypes/Factory.cpp
   branches/caiinterface/rts/Sim/Weapons/Cannon.cpp
   branches/caiinterface/rts/Sim/Weapons/DGunWeapon.cpp
   branches/caiinterface/rts/Sim/Weapons/PlasmaRepulser.cpp
   branches/caiinterface/rts/Sim/Weapons/Weapon.cpp
   branches/caiinterface/rts/Sim/Weapons/bombdropper.cpp
   branches/caiinterface/rts/System/BaseNetProtocol.cpp
   branches/caiinterface/rts/System/BaseNetProtocol.h
   branches/caiinterface/rts/System/EventClient.cpp
   branches/caiinterface/rts/System/EventClient.h
   branches/caiinterface/rts/System/EventHandler.cpp
   branches/caiinterface/rts/System/EventHandler.h
   branches/caiinterface/rts/System/FileSystem/Archive7Zip.cpp
   branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.cpp
   branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.h
   branches/caiinterface/rts/System/FileSystem/ArchiveDir.cpp
   branches/caiinterface/rts/System/FileSystem/ArchiveHPI.cpp
   branches/caiinterface/rts/System/FileSystem/ArchiveZip.cpp
   branches/caiinterface/rts/System/FileSystem/FileHandler.cpp
   branches/caiinterface/rts/System/FileSystem/VFSHandler.cpp
   branches/caiinterface/rts/System/GlobalUnsynced.cpp
   branches/caiinterface/rts/System/GlobalUnsynced.h
   branches/caiinterface/rts/System/LogOutput.cpp
   branches/caiinterface/rts/System/LogOutput.h
   branches/caiinterface/rts/System/Net/UnpackPacket.cpp
   branches/caiinterface/rts/System/Net/UnpackPacket.h
   branches/caiinterface/rts/System/NetProtocol.cpp
   branches/caiinterface/rts/System/NetProtocol.h
   branches/caiinterface/rts/System/Object.cpp
   branches/caiinterface/rts/System/Platform/ConfigHandler.cpp
   branches/caiinterface/rts/System/Platform/FileSystem.cpp
   branches/caiinterface/rts/System/Platform/FileSystem.h
   branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp
   branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp
   branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.cpp
   branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.h
   branches/caiinterface/rts/System/Platform/Win/DxSound.cpp
   branches/caiinterface/rts/System/Script/LuaFunctions.cpp
   branches/caiinterface/rts/System/SpringApp.cpp
   branches/caiinterface/rts/System/SpringApp.h
   branches/caiinterface/rts/System/Sync/SyncedFloat3.h
   branches/caiinterface/rts/System/Util.h
   branches/caiinterface/rts/System/float3.h
   branches/caiinterface/rts/System/myMath.h
   branches/caiinterface/rts/build/scons/rts.py
   branches/caiinterface/rts/build/vstudio8/rts.vcproj
   branches/caiinterface/rts/lib/gml/gml.cpp
   branches/caiinterface/rts/lib/gml/gml.h
   branches/caiinterface/rts/lib/gml/gmlcls.h
   branches/caiinterface/rts/lib/gml/gmlfun.h
   branches/caiinterface/rts/lib/gml/gmlsrv.h
   branches/caiinterface/rts/lib/hpiutil2/hpiutil.h
   branches/caiinterface/tools/DedicatedServer/main.cpp
   branches/caiinterface/tools/unitsync/CMakeLists.txt
   branches/caiinterface/tools/unitsync/Syncer.cpp
   branches/caiinterface/tools/unitsync/Syncer.h
   branches/caiinterface/tools/unitsync/javabind.cpp
   branches/caiinterface/tools/unitsync/pybind.cpp
   branches/caiinterface/tools/unitsync/unitsync.cpp
   branches/caiinterface/tools/unitsync/unitsync.h
   branches/caiinterface/tools/unitsync/unitsync_api.h
Log:
reintegrated trunk to 6941

Modified: branches/caiinterface/AI/Skirmish/AAI/AAI ReadMe.txt
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAI ReadMe.txt	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAI ReadMe.txt	2008-11-02 10:29:36 UTC (rev 6956)
@@ -106,7 +106,19 @@
 		- Brandon Potter for his TBT 12 cfg file
 
 
+AAI v0.875	- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order 
+		  water factories on a land map anymore)
 
+		- Improved AAIs behaviour on water maps with start positions on islands/land masses
+
+		- Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, 
+		  works better if there are land and sea spots available at the same time)
+
+		- Continent file version bumped to 0.87
+
+		- Fixed a crash on shut down introduced in Spring v0.77
+
+
 AAI v0.872	- Refactored code for getting rally points and positions to withdraw units and made 
 
 		- Construction units that are member of the DONT_BUILD list will not be built anymore
@@ -126,11 +138,11 @@
 		- Added some new variables to mod config file:
 
 		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
-		  
+
 		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
-		 
+
 		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
-	
+
   		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
 
 		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 

Modified: branches/caiinterface/AI/Skirmish/AAI/AAI.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -36,10 +36,6 @@
 		requestedUnits[i] = 0;
 	}
 
-	activeScouts = futureScouts = 0;
-	activeBuilders = futureBuilders = 0;
-	activeFactories = futureFactories = 0;
-
 	initialized = false;
 }
 
@@ -65,9 +61,9 @@
 	fprintf(file, &quot;Future metal/energy request: %i / %i\n&quot;, (int)execute-&gt;futureRequestedMetal, (int)execute-&gt;futureRequestedEnergy);
 	fprintf(file, &quot;Future metal/energy supply:    %i / %i\n\n&quot;, (int)execute-&gt;futureAvailableMetal, (int)execute-&gt;futureAvailableEnergy);
 
-	fprintf(file, &quot;Future/active scouts:      %i / %i\n&quot;, futureScouts, activeScouts);
-	fprintf(file, &quot;Future/active builders:    %i / %i\n&quot;, futureBuilders, activeBuilders);
-	fprintf(file, &quot;Future/active factories:   %i / %i\n\n&quot;, futureFactories, activeFactories);
+	fprintf(file, &quot;Future/active scouts:      %i / %i\n&quot;, ut-&gt;futureScouts, ut-&gt;activeScouts);
+	fprintf(file, &quot;Future/active builders:    %i / %i\n&quot;, ut-&gt;futureBuilders, ut-&gt;activeBuilders);
+	fprintf(file, &quot;Future/active factories:   %i / %i\n\n&quot;, ut-&gt;futureFactories, ut-&gt;activeFactories);
 
 	fprintf(file, &quot;Factory ratings:\n&quot;);
 	for(list&lt;int&gt;::iterator fac = bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].begin(); fac != bt-&gt;units_of_category[STATIONARY_CONSTRUCTOR][side-1].end(); ++fac)
@@ -178,9 +174,6 @@
 
 void AAI::UnitDamaged(int damaged, int attacker, float damage, float3 dir)
 {
-	if(damaged &lt; 0)
-		return;
-
 	const UnitDef *def, *att_def;
 	UnitCategory att_cat, cat;
 	
@@ -197,29 +190,32 @@
 		cat =  bt-&gt;units_static[def-&gt;id].category;
 	else
 		cat = UNKNOWN;
+
+	// assault grups may be ordered to retreat
+	if(cat &gt;= GROUND_ASSAULT &amp;&amp; cat &lt;= SUBMARINE_ASSAULT) 
+			execute-&gt;CheckFallBack(damaged, def-&gt;id);
 	
 	// known attacker
 	if(attacker &gt;= 0)
 	{
-		if(cat &gt;= GROUND_ASSAULT &amp;&amp; cat &lt;= SUBMARINE_ASSAULT) 
-			execute-&gt;CheckFallBack(damaged, def-&gt;id);
-
-		att_def = cb-&gt;GetUnitDef(attacker);
-
 		// filter out friendly fire
 		if(cb-&gt;GetUnitTeam(attacker) == cb-&gt;GetMyTeam())
 			return;
 
+		att_def = cb-&gt;GetUnitDef(attacker);
+
 		if(att_def)
 		{
+			unsigned int att_movement_type = bt-&gt;units_static[att_def-&gt;id].movement_type;
 			att_cat = bt-&gt;units_static[att_def-&gt;id].category;
 
 			// retreat builders
 			if(ut-&gt;IsBuilder(damaged))
 				ut-&gt;units[damaged].cons-&gt;Retreat(att_cat);
-			
-			if(att_cat &gt;= GROUND_ASSAULT &amp;&amp; att_cat &lt;= SUBMARINE_ASSAULT)
+			else
 			{
+				//if(att_cat &gt;= GROUND_ASSAULT &amp;&amp; att_cat &lt;= SUBMARINE_ASSAULT)
+		
 				float3 pos = cb-&gt;GetUnitPos(attacker);
 				AAISector *sector = map-&gt;GetSectorOfPos(&amp;pos);
 
@@ -227,13 +223,13 @@
 				{
 					// building has been attacked
 					if(cat &lt;= METAL_MAKER)
-						execute-&gt;DefendUnitVS(damaged, def, att_cat, &amp;pos, 115);
+						execute-&gt;DefendUnitVS(damaged, att_movement_type, &amp;pos, 115);
 					// builder
 					else if(ut-&gt;IsBuilder(damaged))
-						execute-&gt;DefendUnitVS(damaged, def, att_cat, &amp;pos, 110);
+						execute-&gt;DefendUnitVS(damaged, att_movement_type, &amp;pos, 110);
 					// normal units
 					else 
-						execute-&gt;DefendUnitVS(damaged, def, att_cat, &amp;pos, 105);
+						execute-&gt;DefendUnitVS(damaged, att_movement_type, &amp;pos, 105);
 				}
 			}
 		}
@@ -284,7 +280,7 @@
 	{
 		// UnitFinished() will decrease it later -&gt; prevents AAI from having -1 future commanders 
 		requestedUnits[COMMANDER] += 1;
-		futureBuilders += 1;
+		ut-&gt;futureBuilders += 1;
 		bt-&gt;units_dynamic[def-&gt;id].under_construction += 1;
 
 		execute-&gt;InitAI(unit, def);
@@ -305,13 +301,16 @@
 		bt-&gt;units_dynamic[def-&gt;id].requested += 1;
 
 		if(category == SCOUT)
-			futureScouts += 1;
+			ut-&gt;futureScouts += 1;
 		else if(category &lt;= METAL_MAKER &amp;&amp; category &gt; UNKNOWN)
 		{
 			float3 pos = cb-&gt;GetUnitPos(unit);
 			map-&gt;Pos2FinalBuildPos(&amp;pos, def);
 
-			execute-&gt;InitBuildingAt(def, pos);
+			if(pos.y &lt; 0)
+				execute-&gt;InitBuildingAt(def, pos, true);
+			else
+				execute-&gt;InitBuildingAt(def, pos, false);
 		}
 	}
 	else
@@ -434,11 +433,8 @@
 		// scout
 		else if(category == SCOUT)
 		{
-			++activeScouts;
-			--futureScouts;
+			ut-&gt;AddScout(unit);
 
-			scouts.push_back(unit);
-
 			// cloak scout if cloakable
 			if(def-&gt;canCloak)
 			{
@@ -515,11 +511,11 @@
 		else
 		{
 			if(category == SCOUT)
-				--futureScouts;	
+				--ut-&gt;futureScouts;	
 
 			if(bt-&gt;IsBuilder(def-&gt;id))
 			{
-				--futureBuilders;
+				--ut-&gt;futureBuilders;
 
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 					--bt-&gt;units_dynamic[*unit].constructorsRequested;
@@ -527,7 +523,7 @@
 			else if(bt-&gt;IsFactory(def-&gt;id))
 			{
 				if(category == STATIONARY_CONSTRUCTOR)
-					--futureFactories;
+					--ut-&gt;futureFactories;
 	
 				for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 					--bt-&gt;units_dynamic[*unit].constructorsRequested;
@@ -702,19 +698,9 @@
 			// scout
 			if(category == SCOUT)
 			{
-				--activeScouts;
+				ut-&gt;RemoveScout(unit);
 
-				// remove from scout list
-				for(list&lt;int&gt;::iterator i = scouts.begin(); i != scouts.end(); i++)
-				{
-					if(*i == unit)
-					{
-						scouts.erase(i);
-						break;
-					}
-				}
-
-				// add building to sector
+				// add enemy building to sector
 				if(validSector &amp;&amp; map-&gt;sector[x][y].distance_to_base &gt; 0)
 					map-&gt;sector[x][y].enemy_structures += 5;
 				
@@ -841,9 +827,7 @@
 
 	// scouting
 	if(!(tick%cfg-&gt;SCOUT_UPDATE_FREQUENCY))
-	{
 		execute-&gt;UpdateRecon(); // update threat values for all sectors, move scouts...
-	}
 	
 	// update groups
 	if(!(tick%169))
@@ -874,9 +858,7 @@
 
 	// ressource management
 	if(!(tick%199))
-	{
 		execute-&gt;CheckRessources();
-	}
 
 	// update sectors
 	if(!(tick%423))
@@ -887,21 +869,15 @@
 
 	// builder management
 	if(!(tick%917))
-	{
 		brain-&gt;UpdateDefenceCapabilities();
-	}
 
 	// update income 
 	if(!(tick%45))
-	{
 		execute-&gt;UpdateRessources();
-	}
 
 	// building management
 	if(!(tick%97))
-	{
 		execute-&gt;CheckConstruction();
-	}
 
 	// builder/factory management
 	if(!(tick%677))
@@ -910,16 +886,11 @@
 			ut-&gt;units[(*builder)].cons-&gt;Update();
 	}
 
-	
 	if(!(tick%437))
-	{
 		execute-&gt;CheckFactories();
-	}
 
 	if(!(tick%1079))
-	{
 		execute-&gt;CheckDefences(); 
-	}
 
 	// build radar/jammer
 	if(!(tick%1177))
@@ -956,7 +927,7 @@
 	}
 }
 
-int AAI::HandleEvent(int msg,const void* data)
+int AAI::HandleEvent(int msg, const void* data)
 {
    switch (msg)
    {

Modified: branches/caiinterface/AI/Skirmish/AAI/AAI.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAI.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAI.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -66,20 +66,14 @@
 	// side 1= arm, 2 = core, 0 = neutral
 	int side;
 
+	// if there is more than one instance of AAI, make sure to allocate/free memory only once
 	int aai_instance;
 
-	// units, buildings etc.
-	list&lt;int&gt; scouts;
-
 	// number of active/under construction units of all different types
 	int activeUnits[(int)MOBILE_CONSTRUCTOR+1];
 	int futureUnits[(int)MOBILE_CONSTRUCTOR+1];
 	int requestedUnits[(int)MOBILE_CONSTRUCTOR+1];
 
-	int activeScouts, futureScouts;
-	int activeBuilders, futureBuilders;
-	int activeFactories, futureFactories;
-
 	// list of buildtasks
 	list&lt;AAIBuildTask*&gt; build_tasks;
 

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIAttackManager.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIAttackManager.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIAttackManager.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -83,17 +83,17 @@
 	}
 	else
 	{
-		if(map-&gt;mapType == LAND_MAP)
+		if(map-&gt;map_type == LAND_MAP)
 		{
 			land = true;
 			water = false;
 		}
-		else if(map-&gt;mapType == LAND_WATER_MAP)
+		else if(map-&gt;map_type == LAND_WATER_MAP)
 		{
 			land = true;
 			water = true;
 		}
-		else if(map-&gt;mapType == WATER_MAP)
+		else if(map-&gt;map_type == WATER_MAP)
 		{
 			land = false;
 			water = true;
@@ -167,16 +167,7 @@
 		{
 			AAIAttack *attack;
 			
-			try
-			{
-				attack = new AAIAttack(ai);
-			}
-			catch(...)
-			{
-				fprintf(ai-&gt;file, &quot;Exception thrown when allocating memory for AAIAttack&quot;);
-				return;
-			}
-
+			attack = new AAIAttack(ai);
 			attacks.push_back(attack);
 
 			attack-&gt;land = land;

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIBrain.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIBrain.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIBrain.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -21,9 +21,6 @@
 	freeBaseSpots = false;
 	expandable = true;
 
-	land_sectors = 0;
-	water_sectors = 0;
-
 	// initialize random numbers generator
 	srand ( time(NULL) );
 
@@ -261,37 +258,45 @@
 
 void AAIBrain::AddSector(AAISector *sector)
 {
-	if(sector-&gt;water_ratio &lt; 0.4)
-		++land_sectors;
-	else if(sector-&gt;water_ratio &lt; 0.6)
+	sectors[0].push_back(sector);
+
+	sector-&gt;SetBase(true);
+
+	// update base land/water ratio
+	baseLandRatio = 0;
+	baseWaterRatio = 0;
+
+	for(list&lt;AAISector*&gt;::iterator s = sectors[0].begin(); s != sectors[0].end(); ++s)
 	{
-		++land_sectors;
-		++water_sectors;
+		baseLandRatio += (*s)-&gt;GetFlatRatio();
+		baseWaterRatio += (*s)-&gt;GetWaterRatio();
 	}
-	else
-		++water_sectors;
 
-	sectors[0].push_back(sector);
-	
-	sector-&gt;SetBase(true);
+	baseLandRatio /= (float)sectors[0].size();
+	baseWaterRatio /= (float)sectors[0].size();
 }
 
 void AAIBrain::RemoveSector(AAISector *sector)
 {
-	if(sector-&gt;water_ratio &lt; 0.4)
-		--land_sectors;
-	else if(sector-&gt;water_ratio &lt; 0.6)
-	{
-		--land_sectors;
-		--water_sectors;
-	}
-	else
-		--water_sectors;
-
-
 	sectors[0].remove(sector);
 	
 	sector-&gt;SetBase(false);
+
+	// update base land/water ratio
+	baseLandRatio = 0;
+	baseWaterRatio = 0;
+
+	if(sectors[0].size() &gt; 0)
+	{
+		for(list&lt;AAISector*&gt;::iterator s = sectors[0].begin(); s != sectors[0].end(); ++s)
+		{
+			baseLandRatio += (*s)-&gt;GetFlatRatio();
+			baseWaterRatio += (*s)-&gt;GetWaterRatio();
+		}
+
+		baseLandRatio /= (float)sectors[0].size();
+		baseWaterRatio /= (float)sectors[0].size();
+	}
 }
 
 
@@ -398,7 +403,7 @@
 bool AAIBrain::SectorInList(list&lt;AAISector*&gt; mylist, AAISector *sector)
 {
 	// check if sector already added to list
-	for(list&lt;AAISector*&gt;::iterator t = mylist.begin(); t != mylist.end(); t++)
+	for(list&lt;AAISector*&gt;::iterator t = mylist.begin(); t != mylist.end(); ++t)
 	{
 		if(*t == sector)
 			return true;
@@ -406,6 +411,36 @@
 	return false;
 }
 
+float AAIBrain::GetBaseBuildspaceRatio(unsigned int building_move_type)
+{
+	if(building_move_type &amp; MOVE_TYPE_STATIC_LAND)
+		return baseLandRatio;
+	else if(building_move_type &amp; MOVE_TYPE_STATIC_WATER)
+		return baseWaterRatio;
+	else
+		return 1.0f;
+}
+
+bool AAIBrain::CommanderAllowedForConstructionAt(AAISector *sector, float3 *pos)
+{
+	// commander is always allowed in base
+	if(sector-&gt;distance_to_base &lt;= 0)
+		return true;
+	// allow construction close to base for small bases 
+	else if(sectors[0].size() &lt; 3 &amp;&amp; sector-&gt;distance_to_base &lt;= 1)
+		return true;
+	// allow construction on islands close to base on water maps
+	else if(map-&gt;map_type == WATER_MAP &amp;&amp; cb-&gt;GetElevation(pos-&gt;x, pos-&gt;z) &gt;= 0 &amp;&amp; sector-&gt;distance_to_base &lt;= 3)
+		return true;
+	else 
+		return false;
+}
+
+bool AAIBrain::MexConstructionAllowedInSector(AAISector *sector)
+{
+	return sector-&gt;freeMetalSpots &amp;&amp; sector-&gt;enemy_structures &lt;= 0  &amp;&amp; sector-&gt;lost_units[MOBILE_CONSTRUCTOR-COMMANDER]  &lt; 0.5 &amp;&amp; sector-&gt;threat &lt;= 0;
+}
+
 bool AAIBrain::ExpandBase(SectorType sectorType)
 {
 	if(sectors[0].size() &gt;= cfg-&gt;MAX_BASE_SIZE)
@@ -420,9 +455,9 @@
 
 	int max_search_dist = 1;
 
-	// if aai is looking for a water sector to expand into ocean, allow bigger serach_dist
-	if(sectorType == WATER_SECTOR &amp;&amp;  water_sectors == 0 &amp;&amp; land_sectors &gt; 1)
-		max_search_dist = 2;
+	// if aai is looking for a water sector to expand into ocean, allow greater search_dist
+	if(sectorType == WATER_SECTOR &amp;&amp;  baseWaterRatio &lt; 0.1)
+		max_search_dist = 3;
 
 	for(int search_dist = 1; search_dist &lt;= max_search_dist; ++search_dist)
 	{
@@ -454,16 +489,21 @@
 				}
 				else if(sectorType == WATER_SECTOR)
 				{
-					my_rating += 8.0f * (*t)-&gt;water_ratio;
-					my_rating /= dist;
-
+					
 					// check for continent size (to prevent aai to expand into little ponds instead of big ocean)
-					if((*t)-&gt;water_ratio &gt; 0.3 &amp;&amp; !(*t)-&gt;ConnectedToOcean())
+					if((*t)-&gt;water_ratio &gt; 0.1 &amp;&amp;  (*t)-&gt;ConnectedToOcean())
+					{
+						my_rating += 8.0f * (*t)-&gt;water_ratio;
+						my_rating /= dist;	
+					}
+					else
 						my_rating = 0;
 				}
-				else
-					my_rating = 0;
-
+				else // LAND_WATER_SECTOR
+				{
+					my_rating += ((*t)-&gt;flat_ratio + (*t)-&gt;water_ratio) * 8.0f;
+					my_rating /= dist;
+				}
 			
 				// choose higher rated sector
 				if(my_rating &gt; best_rating)
@@ -482,9 +522,15 @@
 
 		// debug purposes:
 		if(sectorType == LAND_SECTOR)
-			fprintf(ai-&gt;file, &quot;\nAdding land sector %i,%i to base; base size: %i \n\n&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+		{
+			fprintf(ai-&gt;file, &quot;\nAdding land sector %i,%i to base; base size: %i&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+			fprintf(ai-&gt;file, &quot;\nNew land : water ratio within base: %f : %f\n\n&quot;, baseLandRatio, baseWaterRatio);
+		}
 		else
-			fprintf(ai-&gt;file, &quot;\nAdding water sector %i,%i to base; base size: %i \n\n&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+		{
+			fprintf(ai-&gt;file, &quot;\nAdding water sector %i,%i to base; base size: %i&quot;, best_sector-&gt;x, best_sector-&gt;y, sectors[0].size());
+			fprintf(ai-&gt;file, &quot;\nNew land : water ratio within base: %f : %f\n\n&quot;, baseLandRatio, baseWaterRatio);
+		}
 
 		// update neighbouring sectors
 		UpdateNeighbouringSectors();
@@ -675,13 +721,13 @@
 	// todo: improve selection
 	category = UNKNOWN;
 
-	MapType mapType = map-&gt;mapType;
+	MapType map_type = map-&gt;map_type;
 
-	float ground_usefulness = map-&gt;map_usefulness[0][side] + bt-&gt;mod_usefulness[0][side][mapType];
-	float air_usefulness = map-&gt;map_usefulness[1][side] + bt-&gt;mod_usefulness[1][side][mapType];
-	float hover_usefulness = map-&gt;map_usefulness[2][side] + bt-&gt;mod_usefulness[2][side][mapType];
-	float sea_usefulness = map-&gt;map_usefulness[3][side] + bt-&gt;mod_usefulness[3][side][mapType];
-	float submarine_usefulness = map-&gt;map_usefulness[4][side] + bt-&gt;mod_usefulness[4][side][mapType];
+	float ground_usefulness = map-&gt;map_usefulness[0][side] + bt-&gt;mod_usefulness[0][side][map_type];
+	float air_usefulness = map-&gt;map_usefulness[1][side] + bt-&gt;mod_usefulness[1][side][map_type];
+	float hover_usefulness = map-&gt;map_usefulness[2][side] + bt-&gt;mod_usefulness[2][side][map_type];
+	float sea_usefulness = map-&gt;map_usefulness[3][side] + bt-&gt;mod_usefulness[3][side][map_type];
+	float submarine_usefulness = map-&gt;map_usefulness[4][side] + bt-&gt;mod_usefulness[4][side][map_type];
 
 	if(cfg-&gt;AIR_ONLY_MOD)
 	{
@@ -738,7 +784,7 @@
 	else
 	{
 		// choose unit category dependend on map type
-		if(mapType == LAND_MAP)
+		if(map_type == LAND_MAP)
 		{
 			// determine effectiveness vs several other units
 			anti_ground_urgency = (int)( 2 + (0.05f + bt-&gt;attacked_by_category[1][0][t]) * ground_usefulness * (2.0f * attacked_by[0] + 1.0f) * (4.0f * max_units_spotted[0] + 0.2f) / (4.0f * defence_power_vs[0] + 1));
@@ -813,7 +859,7 @@
 			fprintf(ai-&gt;file, &quot;Air assault:    %f %f %f %i \n&quot;, defence_power_vs[1], attacked_by[1], max_units_spotted[1], anti_air_urgency);
 			fprintf(ai-&gt;file, &quot;Hover assault:  %f %f %f %i \n&quot;, defence_power_vs[2], attacked_by[2], max_units_spotted[1], anti_hover_urgency);*/
 		}
-		else if(mapType == LAND_WATER_MAP)
+		else if(map_type == LAND_WATER_MAP)
 		{
 			// determine effectiveness vs several other units
 			anti_ground_urgency = (int)( 2 + (0.05f + bt-&gt;attacked_by_category[1][0][t]) * ground_usefulness * (2.0f * attacked_by[0] + 1.0f) * (4.0f * max_units_spotted[0] + 0.2f) / (4.0f * defence_power_vs[0] + 1));
@@ -913,7 +959,7 @@
 				BuildUnitOfCategory(category, cost, ground_eff, air_eff, hover_eff, sea_eff, submarine_eff,stat_eff, urgent);
 			}
 		}
-		else if(mapType == WATER_MAP)
+		else if(map_type == WATER_MAP)
 		{
 			// determine effectiveness vs several other units
 			anti_air_urgency = (int)( 2 + (0.05f + bt-&gt;attacked_by_category[1][1][t]) * air_usefulness * (2.0f * attacked_by[1] + 1.0f) * (4.0f * max_units_spotted[1] + 0.2f) / (4.0f * defence_power_vs[1] + 1));
@@ -1003,7 +1049,7 @@
 				BuildUnitOfCategory(category, cost, ground_eff, air_eff, hover_eff, sea_eff, submarine_eff,stat_eff, urgent);
 			}
 		}
-		else if(mapType == AIR_MAP)
+		else if(map_type == AIR_MAP)
 		{
 			category = AIR_ASSAULT;	
 

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIBrain.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIBrain.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIBrain.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -81,6 +81,15 @@
 	// returns how much ressources can be spent for unit construction atm 
 	float Affordable();
 
+	// returns true if commander is allowed for construction at the specified position in the sector 
+	bool CommanderAllowedForConstructionAt(AAISector *sector, float3 *pos);
+
+	// returns true if AAI may build a mex in this sector (e.g. safe sector)
+	bool MexConstructionAllowedInSector(AAISector *sector);
+
+	// returns ratio of cells in the current base sectors that match movement_type (e.g. 0.3 if 30% of base is covered with water and building is naval)
+	float GetBaseBuildspaceRatio(unsigned int building_move_type);
+
 	void DefendCommander(int attacker);
 
 	void BuildUnits();
@@ -93,11 +102,13 @@
 	//  0 = sectors the ai uses to build its base, 1 = direct neighbours etc.
 	vector&lt;list&lt;AAISector*&gt; &gt; sectors; 
 
-	int land_sectors;
-	int water_sectors;
+	// ratio of land/water cells in all base sectors
+	float baseLandRatio;
+	float baseWaterRatio;
 
 	int max_distance;
 
+	// center of base (mean value of centers of all base sectors)
 	float3 base_center;
 
 	// are there any free metal spots within the base

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -15,6 +15,7 @@
 const UnitDef** AAIBuildTable::unitList = 0;
 list&lt;int&gt;* AAIBuildTable::units_of_category[MOBILE_CONSTRUCTOR+1];
 int AAIBuildTable::aai_instances = 0; 
+char AAIBuildTable::buildtable_filename[500];
 float* AAIBuildTable::avg_cost[MOBILE_CONSTRUCTOR+1]; 
 float* AAIBuildTable::avg_buildtime[MOBILE_CONSTRUCTOR+1];
 float* AAIBuildTable::avg_value[MOBILE_CONSTRUCTOR+1];
@@ -2057,8 +2058,6 @@
 	float best_ranking = -10000, my_ranking;
 	int best_unit = 0;
 
-	int c = 0;
-	
 	float max_cost = this-&gt;max_cost[GROUND_ASSAULT][side-1];
 	float max_range = max_value[GROUND_ASSAULT][side-1];
 	float max_speed = this-&gt;max_speed[0][side-1];
@@ -2069,6 +2068,8 @@
 	UnitTypeStatic *unit;
 
 	// precache eff
+	int c = 0;
+
 	for(list&lt;int&gt;::iterator i = units_of_category[GROUND_ASSAULT][side].begin(); i != units_of_category[GROUND_ASSAULT][side].end(); ++i)
 	{
 		unit = &amp;units_static[*i];
@@ -2091,7 +2092,7 @@
 		max_power = 1;
 
 	if(max_efficiency &lt;= 0)
-		max_efficiency = 0;
+		max_efficiency = 1;
 
 	// TODO: improve algorithm
 	for(list&lt;int&gt;::iterator i = units_of_category[GROUND_ASSAULT][side].begin(); i != units_of_category[GROUND_ASSAULT][side].end(); ++i)
@@ -2641,21 +2642,20 @@
 	else	// load data
 	{
 		// get filename
-		char filename[500];
 		char buffer[500];
 		strcpy(buffer, MAIN_PATH);
 		strcat(buffer, MOD_LEARN_PATH);
 		strcat(buffer, cb-&gt;GetModName());
-		ReplaceExtension (buffer, filename, sizeof(filename), &quot;.dat&quot;);
+		ReplaceExtension (buffer, buildtable_filename, sizeof(buildtable_filename), &quot;.dat&quot;);
 
-		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename); 
+		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, buildtable_filename); 
 
 		FILE *load_file;
 
 		int tmp = 0, bo = 0, bb = 0, cat = 0;
 	
 		// load units if file exists
-		if((load_file = fopen(filename, &quot;r&quot;)))
+		if((load_file = fopen(buildtable_filename, &quot;r&quot;)))
 		{
 			// check if correct version
 			fscanf(load_file, &quot;%s&quot;, buffer);
@@ -2686,9 +2686,7 @@
 				}
 			}
 
-//			units_static = new UnitTypeStatic[numOfUnits+1];
 			units_static.resize(numOfUnits+1);
-//			units_dynamic = new UnitTypeDynamic[numOfUnits+1];
 			units_dynamic.resize(numOfUnits+1);
 			fixed_eff.resize(numOfUnits+1, vector&lt;float&gt;(combat_categories));
 
@@ -2703,7 +2701,6 @@
 									&amp;cat, &amp;bo, &amp;bb);
 
 				// get memory for eff
-//				units_static[i].efficiency = new float[combat_categories];
 				units_static[i].efficiency.resize(combat_categories);
 
 				// load eff
@@ -2794,28 +2791,17 @@
 	}
 
 	// get filename
-	char filename[500];
-	char buffer[500];
-	strcpy(buffer, MAIN_PATH);
-	strcat(buffer, MOD_LEARN_PATH);
-	strcat(buffer, cb-&gt;GetModName());
-	ReplaceExtension (buffer, filename, sizeof(filename), &quot;.dat&quot;);
+	FILE *save_file = fopen(buildtable_filename, &quot;w+&quot;);
 
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename); 
-
-	//fprintf(ai-&gt;file, &quot;Saving buildtable to %s\n&quot;, filename);
-
-	FILE *save_file = fopen(filename, &quot;w+&quot;);
-
 	// file version
 	fprintf(save_file, &quot;%s \n&quot;, TABLE_FILE_VERSION);
 	
-	MapType mapType;
+	MapType map_type;
 	
 	if(ai-&gt;map)
-		mapType = ai-&gt;map-&gt;mapType;
+		map_type = ai-&gt;map-&gt;map_type;
 	else
-		mapType = LAND_MAP;
+		map_type = LAND_MAP;
 
 	float sum = 0;
 
@@ -2825,19 +2811,19 @@
 		// rebalance mod_usefulness
 		if(cfg-&gt;AIR_ONLY_MOD)
 		{
-			sum = mod_usefulness[0][i][mapType] + mod_usefulness[2][i][mapType] + mod_usefulness[3][i][mapType] + mod_usefulness[4][i][mapType];
-			mod_usefulness[0][i][mapType] *= (100.0/sum);
-			mod_usefulness[2][i][mapType] *= (100.0/sum);
-			mod_usefulness[3][i][mapType] *= (100.0/sum);
-			mod_usefulness[4][i][mapType] *= (100.0/sum);
+			sum = mod_usefulness[0][i][map_type] + mod_usefulness[2][i][map_type] + mod_usefulness[3][i][map_type] + mod_usefulness[4][i][map_type];
+			mod_usefulness[0][i][map_type] *= (100.0/sum);
+			mod_usefulness[2][i][map_type] *= (100.0/sum);
+			mod_usefulness[3][i][map_type] *= (100.0/sum);
+			mod_usefulness[4][i][map_type] *= (100.0/sum);
 		}
-		else if(mapType == LAND_MAP)
+		else if(map_type == LAND_MAP)
 		{
 			sum = mod_usefulness[0][i][LAND_MAP] + mod_usefulness[2][i][LAND_MAP];
 			mod_usefulness[0][i][LAND_MAP] *= (100.0/sum);
 			mod_usefulness[2][i][LAND_MAP] *= (100.0/sum);
 		}
-		else if(mapType == LAND_WATER_MAP)
+		else if(map_type == LAND_WATER_MAP)
 		{
 			sum = mod_usefulness[0][i][LAND_WATER_MAP] + mod_usefulness[2][i][LAND_WATER_MAP] + mod_usefulness[3][i][LAND_WATER_MAP] + mod_usefulness[4][i][LAND_WATER_MAP];
 			mod_usefulness[0][i][LAND_WATER_MAP] *= (100.0/sum);
@@ -2845,7 +2831,7 @@
 			mod_usefulness[3][i][LAND_WATER_MAP] *= (100.0/sum);
 			mod_usefulness[4][i][LAND_WATER_MAP] *= (100.0/sum);
 		}
-		else if(mapType == WATER_MAP)
+		else if(map_type == WATER_MAP)
 		{
 			sum = mod_usefulness[2][i][WATER_MAP] + mod_usefulness[3][i][WATER_MAP] + mod_usefulness[4][i][WATER_MAP];
 			mod_usefulness[2][i][WATER_MAP] *= (100.0/sum);
@@ -3159,11 +3145,11 @@
 	bool scout = false;
 	double rating = 1;
 	double combat_units = 0;
-	float ground = (ai-&gt;map-&gt;map_usefulness[0][ai-&gt;side-1] + mod_usefulness[0][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
-	float hover = (ai-&gt;map-&gt;map_usefulness[2][ai-&gt;side-1] + mod_usefulness[2][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
+	float ground = (ai-&gt;map-&gt;map_usefulness[0][ai-&gt;side-1] + mod_usefulness[0][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) / 10.0f;
+	float hover = (ai-&gt;map-&gt;map_usefulness[2][ai-&gt;side-1] + mod_usefulness[2][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) / 10.0f;
 	float air = 10/((float)(cfg-&gt;AIRCRAFT_RATE));
-	float sea = (ai-&gt;map-&gt;map_usefulness[3][ai-&gt;side-1] + mod_usefulness[3][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) / 10.0f;
-	float submarine = (ai-&gt;map-&gt;map_usefulness[4][ai-&gt;side-1] + mod_usefulness[4][ai-&gt;side-1][ai-&gt;map-&gt;mapType]) /10.0f;
+	float sea = (ai-&gt;map-&gt;map_usefulness[3][ai-&gt;side-1] + mod_usefulness[3][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) / 10.0f;
+	float submarine = (ai-&gt;map-&gt;map_usefulness[4][ai-&gt;side-1] + mod_usefulness[4][ai-&gt;side-1][ai-&gt;map-&gt;map_type]) /10.0f;
 
 	if(cfg-&gt;AIR_ONLY_MOD)
 	{
@@ -3200,7 +3186,7 @@
 			}
 		}
 	}
-	else if(ai-&gt;map-&gt;mapType == LAND_MAP)
+	else if(ai-&gt;map-&gt;map_type == LAND_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3230,7 +3216,7 @@
 			}
 		}	
 	}
-	else if(ai-&gt;map-&gt;mapType == AIR_MAP)
+	else if(ai-&gt;map-&gt;map_type == AIR_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3250,7 +3236,7 @@
 			}
 		}	
 	}
-	else if(ai-&gt;map-&gt;mapType == LAND_WATER_MAP)
+	else if(ai-&gt;map-&gt;map_type == LAND_WATER_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3290,7 +3276,7 @@
 			}
 		}
 	}
-	else if(ai-&gt;map-&gt;mapType == WATER_MAP)
+	else if(ai-&gt;map-&gt;map_type == WATER_MAP)
 	{
 		for(list&lt;int&gt;::iterator unit = units_static[def_id].canBuildList.begin(); unit != units_static[def_id].canBuildList.end(); ++unit)	
 		{
@@ -3369,7 +3355,7 @@
 		int buildings = 10;
 
 		// only cout buildings that are likely to be built on that type of map
-		if(ai-&gt;map-&gt;mapType == LAND_MAP)
+		if(ai-&gt;map-&gt;map_type == LAND_MAP)
 		{
 			for(list&lt;int&gt;::iterator building = units_static[def_id].canBuildList.begin(); building != units_static[def_id].canBuildList.end(); ++building)
 			{
@@ -3377,7 +3363,7 @@
 					++buildings;
 			}
 		}
-		else if(ai-&gt;map-&gt;mapType == WATER_MAP)
+		else if(ai-&gt;map-&gt;map_type == WATER_MAP)
 		{
 			for(list&lt;int&gt;::iterator building = units_static[def_id].canBuildList.begin(); building != units_static[def_id].canBuildList.end(); ++building)
 			{
@@ -3418,6 +3404,9 @@
 			if(units_dynamic[*unit].constructorsAvailable &gt; 0)
 				my_rating += 4.0f;
 
+			// apply terrain modifier
+			my_rating *= ai-&gt;brain-&gt;GetBaseBuildspaceRatio(units_static[*unit].movement_type);
+
 			if(my_rating &gt; best_rating)
 			{	
 				best_rating = my_rating;
@@ -3458,7 +3447,7 @@
 				
 				// increase counter if mobile factory is a builder as well
 				if(units_static[constructor].unit_type &amp; UNIT_TYPE_BUILDER)
-					ai-&gt;futureBuilders += 1;
+					ai-&gt;ut-&gt;futureBuilders += 1;
 
 				for(list&lt;int&gt;::iterator j = units_static[constructor].canBuildList.begin(); j != units_static[constructor].canBuildList.end(); ++j)
 				{
@@ -3521,7 +3510,7 @@
 		if(ai-&gt;execute-&gt;AddUnitToBuildqueue(builder, 1, true))
 		{
 			units_dynamic[builder].requested += 1;
-			ai-&gt;futureBuilders += 1;
+			ai-&gt;ut-&gt;futureBuilders += 1;
 
 			// set all its buildoptions buildable
 			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); j++)
@@ -3543,7 +3532,7 @@
 
 	float cost = ai-&gt;brain-&gt;Affordable()/2.0f; 
 	float buildspeed = 3.0f;
-	float urgency = 12.0f / (ai-&gt;activeBuilders + ai-&gt;futureBuilders + 3);
+	float urgency = 12.0f / (ai-&gt;ut-&gt;activeBuilders + ai-&gt;ut-&gt;futureBuilders + 3);
 
 	float max_buildtime = max_builder_buildtime[ai-&gt;side-1]/256.0;
 		
@@ -3579,7 +3568,7 @@
 		if(ai-&gt;execute-&gt;AddUnitToBuildqueue(builder, 1, true))
 		{
 			units_dynamic[builder].requested += 1;
-			ai-&gt;futureBuilders += 1;
+			ai-&gt;ut-&gt;futureBuilders += 1;
 
 			// increase number of requested builders of all buildoptions
 			for(list&lt;int&gt;::iterator j = units_static[builder].canBuildList.begin(); j != units_static[builder].canBuildList.end(); ++j)

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIBuildTable.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -205,6 +205,9 @@
 	// how many aai instances have been initialized
 	static int aai_instances; 
 
+	// path/name of the file in which AAI stores the build table
+	static char buildtable_filename[500];
+
 	// all the unit defs
 	static const UnitDef **unitList;
 	

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIConstructor.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIConstructor.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIConstructor.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -349,7 +349,7 @@
 	ai-&gt;map-&gt;Pos2FinalBuildPos(&amp;pos, def);
 	
 	// give order if building can be placed at the desired position (position lies within a valid sector)
-	if(ai-&gt;execute-&gt;InitBuildingAt(def, pos))
+	if(ai-&gt;execute-&gt;InitBuildingAt(def, pos, water))
 	{
 		order_tick = cb-&gt;GetCurrentFrame();
 

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIExecute.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIExecute.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIExecute.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -119,10 +119,12 @@
 		ChooseDifferentStartingSector(x, y);
 	}
 
-	if(map-&gt;mapType == WATER_MAP)
+	if(map-&gt;map_type == WATER_MAP)
 		brain-&gt;ExpandBase(WATER_SECTOR);
-	else 
+	else if(map-&gt;map_type == LAND_MAP)
 		brain-&gt;ExpandBase(LAND_SECTOR);
+	else 
+		brain-&gt;ExpandBase(LAND_WATER_SECTOR);
 	
 	// now that we know the side, init buildques
 	InitBuildques();
@@ -159,15 +161,8 @@
 	}
 }
 
-bool AAIExecute::InitBuildingAt(const UnitDef *def, float3 pos)
+bool AAIExecute::InitBuildingAt(const UnitDef *def, float3 pos, bool water)
 {			
-	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
-
-	bool water = false;
-
-	if(pos.y &lt; 0) 
-		water = true;
-
 	// determine target sector
 	int x = pos.x/map-&gt;xSectorSize;
 	int y = pos.z/map-&gt;ySectorSize;
@@ -175,8 +170,10 @@
 	// drop bad sectors (should only happen when defending mexes at the edge of the map)
 	if(x &lt; 0 || y &lt; 0 || x &gt;= map-&gt;xSectors || y &gt;= map-&gt;ySectors)
 		return false;
-	
+
 	// increase number of units of that category in the target sector
+	UnitCategory category = bt-&gt;units_static[def-&gt;id].category;
+	
 	map-&gt;sector[x][y].unitsOfType[category] += 1;
 	map-&gt;sector[x][y].own_structures += bt-&gt;units_static[def-&gt;id].cost;
 
@@ -186,7 +183,7 @@
 	// factory
 	if(bt-&gt;IsFactory(def-&gt;id))
 	{
-		ai-&gt;futureFactories += 1;
+		ut-&gt;futureFactories += 1;
 
 		if(water)
 			map-&gt;SetBuildMap(pos.x, pos.z, def-&gt;xsize, def-&gt;ysize, 5);
@@ -255,10 +252,8 @@
 	// determine continent if necessary
 	int continent_id = -1;
 
-	if(bt-&gt;units_static[def_id].movement_type &amp; MOVE_TYPE_CONTINENT_BOUND) {
-		float3 unitPos = cb-&gt;GetUnitPos(unit_id);
-		continent_id = map-&gt;GetContinentID(&amp;unitPos);
-	}
+	if(bt-&gt;units_static[def_id].movement_type &amp; MOVE_TYPE_CONTINENT_BOUND) 
+		continent_id = map-&gt;GetContinentID(&amp;cb-&gt;GetUnitPos(unit_id));
 
 	// try to add unit to an existing group 
 	for(list&lt;AAIGroup*&gt;::iterator group = ai-&gt;group_list[category].begin(); group != ai-&gt;group_list[category].end(); ++group)
@@ -274,10 +269,8 @@
 	// -&gt; create new one
 
 	// get continent for ground assault units, even if they are amphibious (otherwise non amphib ground units will be added no matter which continent they are on)
-	if(category == GROUND_ASSAULT  &amp;&amp; continent_id == 1) {
-		float3 unitPos = cb-&gt;GetUnitPos(unit_id);
-		continent_id = map-&gt;GetContinentID(&amp;unitPos);
-	}
+	if(category == GROUND_ASSAULT  &amp;&amp; continent_id == -1)
+		continent_id = map-&gt;GetContinentID(&amp;cb-&gt;GetUnitPos(unit_id));
 
 	AAIGroup *new_group = new AAIGroup(ai, bt-&gt;unitList[def_id-1], unit_type, continent_id);
 
@@ -295,7 +288,7 @@
 
 	// explore map -&gt; send scouts to different sectors, build new scouts if needed etc.
 	// check number of scouts and order new ones if necessary
-	if(ai-&gt;activeScouts + ai-&gt;futureScouts &lt; cfg-&gt;MAX_SCOUTS)
+	if(ut-&gt;activeScouts + ut-&gt;futureScouts &lt; cfg-&gt;MAX_SCOUTS)
 	{
 		int scout = 0;
 
@@ -324,14 +317,14 @@
 		// always: MOVE_TYPE_AIR, MOVE_TYPE_HOVER, MOVE_TYPE_AMPHIB
 		unsigned int allowed_movement_types = 22;
 		
-		if(map-&gt;mapType == LAND_MAP)
+		if(map-&gt;map_type == LAND_MAP)
 			allowed_movement_types |= MOVE_TYPE_GROUND;
-		else if(map-&gt;mapType == LAND_WATER_MAP)
+		else if(map-&gt;map_type == LAND_WATER_MAP)
 		{
 			allowed_movement_types |= MOVE_TYPE_GROUND;
 			allowed_movement_types |= MOVE_TYPE_SEA;
 		}
-		else if(map-&gt;mapType == WATER_MAP)
+		else if(map-&gt;map_type == WATER_MAP)
 			allowed_movement_types |= MOVE_TYPE_SEA;
 		
 
@@ -345,19 +338,19 @@
 		{
 			bool urgent = true;
 
-			if(ai-&gt;activeScouts &gt;= 2)
+			if(ut-&gt;activeScouts &gt;= 2)
 				urgent = false;
 
 			if(AddUnitToBuildqueue(scout, 1, urgent))
 			{
-				++ai-&gt;futureScouts;
+				++ut-&gt;futureScouts;
 				++bt-&gt;units_dynamic[scout].requested;
 			}
 		}
 	}
 
 	// get idle scouts and let them explore the map
-	for(list&lt;int&gt;::iterator scout = ai-&gt;scouts.begin(); scout != ai-&gt;scouts.end(); ++scout)
+	for(set&lt;int&gt;::iterator scout = ut-&gt;scouts.begin(); scout != ut-&gt;scouts.end(); ++scout)
 	{
 		if(!IsBusy(*scout))
 		{
@@ -437,107 +430,6 @@
 	return best_pos;
 }
 
-AAIMetalSpot* AAIExecute::FindMetalSpot(bool land, bool water)
-{
-	// prevent crashes on smaller maps 
-	int max_distance = min(cfg-&gt;MAX_MEX_DISTANCE, brain-&gt;max_distance);
-
-	for(int sector_dist = 0; sector_dist &lt; max_distance; ++sector_dist)
-	{
-		for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[sector_dist].begin();sector != brain-&gt;sectors[sector_dist].end(); sector++)
-		{
-			if(sector_dist == 0)
-			{
-				if((*sector)-&gt;freeMetalSpots)
-				{
-					for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
-					{
-						if(!(*spot)-&gt;occupied)	
-						{
-							if( (land &amp;&amp; (*spot)-&gt;pos.y &gt;= 0) ||(water &amp;&amp; (*spot)-&gt;pos.y &lt; 0) )
-								return *spot;
-						}
-					}
-				}
-			}
-			else
-			{
-				if((*sector)-&gt;freeMetalSpots &amp;&amp; brain-&gt;IsSafeSector(*sector) &amp;&amp; map-&gt;team_sector_map[(*sector)-&gt;x][(*sector)-&gt;y] == -1 )
-				{
-					for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
-					{
-						if(!(*spot)-&gt;occupied)	
-						{
-							if( (land &amp;&amp; (*spot)-&gt;pos.y &gt;= 0) ||(water &amp;&amp; (*spot)-&gt;pos.y &lt; 0) )
-								return *spot;
-						}
-					}
-				}
-			}
-		}
-	}
-
-	return 0;
-}
-
-AAIMetalSpot* AAIExecute::FindMetalSpotClosestToBuilder(int land_mex, int water_mex)
-{
-	AAIMetalSpot *best_spot = 0;
-	float shortest_dist = 10000.0f, dist;
-	float3 builder_pos;
-	AAIConstructor *builder = 0;
-
-	// prevent crashes on smaller maps 
-	int max_distance = min(cfg-&gt;MAX_MEX_DISTANCE, brain-&gt;max_distance);
-
-	// dont search for too long if possible spot already found
-	int min_spot_dist = -1;
-
-	// look for free spots in all sectors within max range
-	for(int sector_dist = 0; sector_dist &lt; max_distance; ++sector_dist)
-	{
-		// skip search if spot already found 
-		if(min_spot_dist &gt;= 0 &amp;&amp; sector_dist - min_spot_dist &gt; 2)
-			return best_spot;
-
-		for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[sector_dist].begin(); sector != brain-&gt;sectors[sector_dist].end(); sector++)
-		{
-			if((*sector)-&gt;freeMetalSpots &amp;&amp; (*sector)-&gt;enemy_structures &lt;= 0  &amp;&amp; (*sector)-&gt;lost_units[MOBILE_CONSTRUCTOR-COMMANDER]  &lt; 0.5 &amp;&amp; (*sector)-&gt;threat &lt;= 0)
-			{
-				for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
-				{
-					if(!(*spot)-&gt;occupied)	
-					{
-						if((*spot)-&gt;pos.y &gt; 0)
-							builder = ut-&gt;FindClosestBuilder(land_mex, (*spot)-&gt;pos, true);
-						else
-							builder = ut-&gt;FindClosestBuilder(water_mex, (*spot)-&gt;pos, true);
-
-						if(builder)
-						{
-							// get distance to pos
-							builder_pos = cb-&gt;GetUnitPos(builder-&gt;unit_id);
-
-							dist = sqrt( pow(((*spot)-&gt;pos.x - builder_pos.x), 2) + pow(((*spot)-&gt;pos.z - builder_pos.z),2) ) / bt-&gt;unitList[builder-&gt;def_id-1]-&gt;speed;
-
-							if(dist &lt; shortest_dist)
-							{
-								best_spot = *spot;
-								shortest_dist = dist;
-
-								min_spot_dist = sector_dist;
-							}	
-						}
-					}	
-				}
-			}
-		}
-	}
-
-	return best_spot;
-}
-
-
 float AAIExecute::GetTotalGroundPower()
 {
 	float power = 0;
@@ -592,7 +484,7 @@
 			{
 				my_rating = (1 + 2 * (float) bt-&gt;units_dynamic[*fac].active) / (temp_buildqueue-&gt;size() + 3);
 
-				if(map-&gt;mapType == WATER_MAP &amp;&amp; !bt-&gt;CanPlacedWater(*fac))
+				if(map-&gt;map_type == WATER_MAP &amp;&amp; !bt-&gt;CanPlacedWater(*fac))
 					my_rating /= 10.0;
 			}
 			else 
@@ -815,15 +707,13 @@
 
 bool AAIExecute::BuildExtractor()
 {
-	if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
+	if(ai-&gt;futureUnits[POWER_PLANT] + ai-&gt;requestedUnits[POWER_PLANT] &gt; 2)
 		return true;
 
-	AAIConstructor *builder; 
-	AAIMetalSpot *spot = 0;
+	AAIConstructor *builder, *land_builder = 0, *water_builder = 0; 
 	float3 pos;
-	int land_mex;
-	int water_mex;
-	bool water;
+	int land_mex, water_mex;
+	float min_dist;
 
 	float cost = 0.25f + brain-&gt;Affordable() / 6.0f;
 	float efficiency = 6.0 / (cost + 0.75f);
@@ -840,16 +730,15 @@
 			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
 		}
 
-		builder = ut-&gt;FindBuilder(land_mex, true);
+		land_builder = ut-&gt;FindBuilder(land_mex, true);
 
-		if(builder)
+		if(land_builder)
 		{
-			pos = GetBuildsite(builder-&gt;unit_id, land_mex, EXTRACTOR);
+			pos = GetBuildsite(land_builder-&gt;unit_id, land_mex, EXTRACTOR);
 
 			if(pos.x != 0)
-			{
-				builder-&gt;GiveConstructionOrder(land_mex, pos, false);
-			}
+				land_builder-&gt;GiveConstructionOrder(land_mex, pos, false);
+			
 			return true;
 		}
 		else
@@ -858,156 +747,141 @@
 			return false;
 		}
 	}
-	else // normal map
+	
+	// normal map
+
+	// select a land/water mex 
+	if(map-&gt;land_metal_spots &gt; 0)
 	{
-		// different behaviour dependent on number of builders (to save time in late game)
-		if(ut-&gt;constructors.size() &lt; 4)
+		land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, false);
+
+		if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsRequested &lt;= 0)
 		{
-			// get id of an extractor and look for suitable builder
-			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, false);
+			bt-&gt;BuildConstructorFor(land_mex);
+			land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
+		}
+	}
 
-			if(land_mex &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[land_mex].constructorsRequested &lt;= 0)
-			{
-				bt-&gt;BuildConstructorFor(land_mex);
-				land_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, false, true);
-			}
+	if(map-&gt;water_metal_spots &gt; 0)
+	{
+		water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, false);
 
-			water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, false);
+		if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsRequested &lt;= 0)
+		{
+			bt-&gt;BuildConstructorFor(water_mex);
+			water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, true);
+		}
+	}
 
-			if(water_mex &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[water_mex].constructorsRequested &lt;= 0)
-			{
-				bt-&gt;BuildConstructorFor(water_mex);
-				water_mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, false, true, true);
-			}
+	// check if there is any builder for at least one of the selected extractors available
+	land_builder = ut-&gt;FindBuilder(land_mex, true);
+	water_builder = ut-&gt;FindBuilder(water_mex, true);
 
-			// find metal spot with lowest distance to available builders
-			spot = FindMetalSpotClosestToBuilder(land_mex, water_mex);
-	
-			if(spot)
-			{	
-				// check if land or sea spot
-				if(cb-&gt;GetElevation(spot-&gt;pos.x, spot-&gt;pos.z) &lt; 0)
-				{
-					water = true;
+	if(!land_builder &amp;&amp; !water_builder)
+		return false;
 
-					// build the water mex instead of land mex
-					land_mex = water_mex;	
-				}
-				else
-					water = false;
-		
-				// look for suitable builder
-				int x = spot-&gt;pos.x/map-&gt;xSectorSize;
-				int y = spot-&gt;pos.z/map-&gt;ySectorSize;
+	// check the first 10 free spots for the one with least distance to available builder
+	int max_spots = 10;
+	int current_spot = 0;
+	bool free_spot_found = false;
 
-				// only allow commander if spot is close to own base
-				if(map-&gt;sector[x][y].distance_to_base &lt;= 0 || (brain-&gt;sectors[0].size() &lt; 3 &amp;&amp; map-&gt;sector[x][y].distance_to_base &lt;= 1) )
-					builder = ut-&gt;FindClosestBuilder(land_mex, spot-&gt;pos, true);
-				else
-					builder = ut-&gt;FindClosestBuilder(land_mex, spot-&gt;pos, false);
-		
-				if(builder)
-				{
-					builder-&gt;GiveConstructionOrder(land_mex, spot-&gt;pos, water);
-					spot-&gt;occupied = true;
-				}
-				else
-				{
-					bt-&gt;AddBuilder(land_mex);
-					return false;
-				}
-			}
-			else
-			{	
-				// request metal makers if no spot found (only if spot was not found due to no buidlers available)
-				builder = ut-&gt;FindClosestBuilder(land_mex, brain-&gt;base_center, true);
+	vector&lt;AAIMetalSpot*&gt; spots;
+	spots.resize(max_spots);
+	vector&lt;AAIConstructor*&gt; builders;
+	builders.resize(max_spots, 0);
 
-				if(!builder)	
-					builder = ut-&gt;FindClosestBuilder(water_mex, brain-&gt;base_center, true);
-		
-				if(!builder)
-				{
-					if(map-&gt;mapType == WATER_MAP &amp;&amp; !cfg-&gt;AIR_ONLY_MOD)
-						bt-&gt;AddBuilder(water_mex);
-					else
-						bt-&gt;AddBuilder(land_mex);
-				
-					return false;
-				}
-				else
-				{
-					if(ai-&gt;activeUnits[METAL_MAKER] &lt; cfg-&gt;MAX_METAL_MAKERS &amp;&amp; urgency[METAL_MAKER] &lt;= GetMetalUrgency() / 2.0f)
-						urgency[METAL_MAKER] = GetMetalUrgency() / 2.0f;
-				}
-			}
-		}
-		else
-		{
-			bool land = true, water = true;
+	vector&lt;float&gt; dist_to_builder;
 
-			// get next free metal spot
-			AAIMetalSpot *spot = FindMetalSpot(land, water);
+	// determine max search dist - prevent crashes on smaller maps 
+	int max_search_dist = min(cfg-&gt;MAX_MEX_DISTANCE, brain-&gt;max_distance);
 
-			if(spot)
+	for(int sector_dist = 0; sector_dist &lt; max_search_dist; ++sector_dist)
+	{
+		for(list&lt;AAISector*&gt;::iterator sector = brain-&gt;sectors[sector_dist].begin(); sector != brain-&gt;sectors[sector_dist].end(); ++sector)
+		{
+			if(brain-&gt;MexConstructionAllowedInSector(*sector))
 			{
-				int x = spot-&gt;pos.x/map-&gt;xSectorSize;
-				int y = spot-&gt;pos.z/map-&gt;ySectorSize;
+				for(list&lt;AAIMetalSpot*&gt;::iterator spot = (*sector)-&gt;metalSpots.begin(); spot != (*sector)-&gt;metalSpots.end(); ++spot)
+				{
+					if(!(*spot)-&gt;occupied)
+					{
+						//
+						if((*spot)-&gt;pos.y &gt;= 0 &amp;&amp; land_builder)
+						{
+							free_spot_found = true;
 
-				if(cb-&gt;GetElevation(spot-&gt;pos.x, spot-&gt;pos.z) &gt;= 0) 
-					water = false;	
-				else
-					water = true;
-				
-				// choose mex dependend on safety
-				bool armed = false;
+							builder = ut-&gt;FindClosestBuilder(land_mex, &amp;(*spot)-&gt;pos, brain-&gt;CommanderAllowedForConstructionAt(*sector, &amp;(*spot)-&gt;pos), &amp;min_dist);
 
-				//if(map-&gt;sector[x][y].lost_units[EXTRACTOR-COMMANDER] &gt; 0.01f || map-&gt;sector[x][y].distance_to_base &gt; 2)
-				if(map-&gt;sector[x][y].distance_to_base &gt; 2)
-				{
-					cost = 6.0f;
-					armed = true;
-					efficiency = 1.0f;
-				}
+							if(builder)
+							{
+								dist_to_builder.push_back(min_dist);
+								spots[current_spot] = *spot;
+								builders[current_spot] = builder;
 
-				int mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, armed, water, false);
+								++current_spot;
+							}
+						}
+						else if((*spot)-&gt;pos.y &lt; 0 &amp;&amp; water_builder)
+						{
+							free_spot_found = true;
 
-				if(mex &amp;&amp; bt-&gt;units_dynamic[mex].constructorsAvailable &lt;= 0 &amp;&amp; bt-&gt;units_dynamic[mex].constructorsAvailable &lt;= 0)
-				{
-					bt-&gt;BuildConstructorFor(mex);
+							builder = ut-&gt;FindClosestBuilder(water_mex, &amp;(*spot)-&gt;pos, brain-&gt;CommanderAllowedForConstructionAt(*sector, &amp;(*spot)-&gt;pos), &amp;min_dist);
 
-					mex = bt-&gt;GetMex(ai-&gt;side, cost, efficiency, armed, water, true);
-				}
+							if(builder)
+							{
+								dist_to_builder.push_back(min_dist);
+								spots[current_spot] = *spot;
+								builders[current_spot] = builder;
 
-				if(mex)
-				{
-					if(map-&gt;sector[x][y].distance_to_base &lt;= 0 || (brain-&gt;sectors[0].size() &lt; 3 &amp;&amp; map-&gt;sector[x][y].distance_to_base &lt;= 1) )
-						builder = ut-&gt;FindClosestBuilder(mex, spot-&gt;pos, true);
-					else
-						builder = ut-&gt;FindClosestBuilder(mex, spot-&gt;pos, false);
+								++current_spot;
+							}
+						}
 
-					if(builder)
-					{
-						builder-&gt;GiveConstructionOrder(mex, spot-&gt;pos, water);
-						spot-&gt;occupied = true;
+						if(current_spot &gt;= max_spots)
+							break;
 					}
-					else //try to request more builders if none available	
-						bt-&gt;AddBuilder(mex);
 				}
 			}
-			else
-			{	
-				// check mex upgrade
-				if(ai-&gt;futureUnits[EXTRACTOR] + ai-&gt;requestedUnits[EXTRACTOR] + ai-&gt;requestedUnits[EXTRACTOR] &lt; 1)
-					CheckMexUpgrade();
 
-				// request metal makers if no spot found
-				if(ai-&gt;activeUnits[METAL_MAKER] &lt; cfg-&gt;MAX_METAL_MAKERS &amp;&amp; urgency[METAL_MAKER] &lt;= GetMetalUrgency() / 2.0f)
-					urgency[METAL_MAKER] = GetMetalUrgency() / 2.0f;
-			}
+			if(current_spot &gt;= max_spots)
+				break;
 		}
+
+		if(current_spot &gt;= max_spots)
+			break;
 	}
 
-	return true;
+	// look for spot with minimum dist to available builder
+	int best = -1;
+	min_dist = 1000000.0f;
+
+	for(int i = 0; i &lt; dist_to_builder.size(); ++i)
+	{
+		if(dist_to_builder[i] &lt; min_dist)
+		{
+			best = i;
+			min_dist = dist_to_builder[i];
+		}
+	}
+
+	// order mex construction for best spot
+	if(best &gt;= 0)
+	{
+		if(spots[best]-&gt;pos.y &gt;= 0)
+			builders[best]-&gt;GiveConstructionOrder(land_mex, spots[best]-&gt;pos, false);
+		else
+			builders[best]-&gt;GiveConstructionOrder(water_mex, spots[best]-&gt;pos, true);
+				
+		spots[best]-&gt;occupied = true;
+
+		return true;		
+	}
+	
+	// dont build other things if construction could not be started due to unavailable builders
+	if(free_spot_found)
+		return false;
+	else
+		return true;
 }
 
 bool AAIExecute::BuildPowerPlant()
@@ -1055,7 +929,7 @@
 		// power plant construction has not started -&gt; builder is still on its way to constrcution site, wait until starting a new power plant
 		return false;
 	}
-	else if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[POWER_PLANT] &gt;= 2)
+	else if(ut-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[POWER_PLANT] &gt;= 2)
 		return true;
 
 	// stop building power plants if already to much available energy
@@ -1146,7 +1020,8 @@
 
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(ground_plant, pos, true);
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(ground_plant, &amp;pos, true, &amp;min_dist);
 
 				if(builder)
 				{
@@ -1188,7 +1063,8 @@
 
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(water_plant, pos, true);
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(water_plant, &amp;pos, true, &amp;min_dist);
 
 				if(builder)
 				{
@@ -1215,7 +1091,7 @@
 
 bool AAIExecute::BuildMetalMaker()
 {
-	if(ai-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
+	if(ut-&gt;activeFactories &lt; 1 &amp;&amp; ai-&gt;activeUnits[EXTRACTOR] &gt;= 2)
 		return true;
 
 	if(ai-&gt;futureUnits[METAL_MAKER] + ai-&gt;requestedUnits[METAL_MAKER] &gt; 0 || disabledMMakers &gt;= 1)
@@ -1278,7 +1154,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(maker, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(maker, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1319,7 +1196,8 @@
 	
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(maker, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(maker, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1350,7 +1228,7 @@
 	if(ai-&gt;futureUnits[STORAGE] + ai-&gt;requestedUnits[STORAGE]&gt; 0 || ai-&gt;activeUnits[STORAGE] &gt;= cfg-&gt;MAX_STORAGE)
 		return true;
 
-	if(ai-&gt;activeFactories &lt; 2)
+	if(ut-&gt;activeFactories &lt; 2)
 		return true;
 
 	int storage = 0;
@@ -1400,7 +1278,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(storage, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(storage, &amp;pos, true, &amp;min_dist);
 	
 					if(builder)
 					{
@@ -1439,7 +1318,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(storage, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(storage, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1511,7 +1391,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(airbase, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(airbase, &amp;pos, true, &amp;min_dist);
 	
 					if(builder)
 					{
@@ -1550,7 +1431,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(airbase, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(airbase, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1725,7 +1607,8 @@
 				
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(building, pos, true);	
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(building, &amp;pos, true,&amp;min_dist);	
 
 				if(builder)
 				{
@@ -1784,7 +1667,8 @@
 				
 			if(pos.x &gt; 0)
 			{
-				builder = ut-&gt;FindClosestBuilder(building, pos, true);
+				float min_dist;
+				builder = ut-&gt;FindClosestBuilder(building, &amp;pos, true, &amp;min_dist);
 
 				if(builder)
 				{
@@ -1857,7 +1741,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(arty, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(arty, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1891,7 +1776,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(arty, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(arty, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -1929,7 +1815,7 @@
 			my_rating = bt-&gt;GetFactoryRating(*fac) / pow( (float) (1 + bt-&gt;units_dynamic[*fac].active), 2.0f);
 			my_rating *= (1 + sqrt(2.0 + (float) GetBuildqueueOfFactory(*fac)-&gt;size())); 
 
-			if(ai-&gt;activeFactories &lt; 1)
+			if(ut-&gt;activeFactories &lt; 1)
 				my_rating /= bt-&gt;units_static[*fac].cost;
 
 			// skip factories that could not be built 
@@ -2022,7 +1908,9 @@
 			
 		if(pos.x &gt; 0)
 		{
-			builder = ut-&gt;FindClosestBuilder(building, pos, true);
+			float min_dist;
+
+			builder = ut-&gt;FindClosestBuilder(building, &amp;pos, true, &amp;min_dist);
 			
 			if(builder)
 			{
@@ -2232,7 +2120,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(radar, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(radar, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2267,7 +2156,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(radar, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(radar, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2342,7 +2232,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(jammer, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(jammer, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2377,7 +2268,8 @@
 
 				if(pos.x &gt; 0)
 				{
-					builder = ut-&gt;FindClosestBuilder(jammer, pos, true);
+					float min_dist;
+					builder = ut-&gt;FindClosestBuilder(jammer, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 					{
@@ -2399,7 +2291,7 @@
 
 void AAIExecute::DefendMex(int mex, int def_id)
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES)
+	if(ut-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES)
 		return;
 
 	float3 pos = cb-&gt;GetUnitPos(mex);
@@ -2433,7 +2325,7 @@
 					defence = bt-&gt;GetDefenceBuilding(ai-&gt;side, 2, 1, 1, 1, 0.5, 0, 0, 0, 4, 0.1, 1, false, true);
 				else
 				{
-					if(map-&gt;mapType == AIR_MAP)
+					if(map-&gt;map_type == AIR_MAP)
 						defence = bt-&gt;GetDefenceBuilding(ai-&gt;side, 2, 1, 1, 0, 2, 0, 0, 0, 4, 0.1, 1, false, true); 
 					else
 						defence = bt-&gt;GetDefenceBuilding(ai-&gt;side, 2, 1, 1, 1.5, 0.5, 0, 0, 0, 4, 0.1, 3, false, true); 
@@ -2470,11 +2362,12 @@
 				if(pos.x &gt; 0)
 				{
 					AAIConstructor *builder;
+					float min_dist;
 
 					if(brain-&gt;sectors[0].size() &gt; 2)
-						builder = ut-&gt;FindClosestBuilder(defence, pos, false);
+						builder = ut-&gt;FindClosestBuilder(defence, &amp;pos, false, &amp;min_dist);
 					else
-						builder = ut-&gt;FindClosestBuilder(defence, pos, true);
+						builder = ut-&gt;FindClosestBuilder(defence, &amp;pos, true, &amp;min_dist);
 
 					if(builder)
 						builder-&gt;GiveConstructionOrder(defence, pos, water);	
@@ -2564,7 +2457,7 @@
 
 void AAIExecute::CheckDefences()
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES || ai-&gt;futureUnits[STATIONARY_DEF] +  ai-&gt;requestedUnits[STATIONARY_DEF] &gt; 2)
+	if(ut-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_DEFENCES || ai-&gt;futureUnits[STATIONARY_DEF] +  ai-&gt;requestedUnits[STATIONARY_DEF] &gt; 2)
 		return;
 
 	int t = brain-&gt;GetGamePeriod();
@@ -2591,10 +2484,10 @@
 					{
 						// anti air defences may be built anywhere
 						if(cfg-&gt;AIR_ONLY_MOD || *cat == AIR_ASSAULT)
-							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.5f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );
+							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.25f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );
 						// dont build anti ground/hover/sea defences in interior sectors
 						else if(!(*sector)-&gt;interior)
-							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.5f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );		
+							rating = (1.0f + sqrt((*sector)-&gt;own_structures)) * (0.25f + bt-&gt;attacked_by_category[1][*cat][t]) * (*sector)-&gt;GetThreatByID(*cat, learned, current) / ( (*sector)-&gt;GetDefencePowerVsID(*cat) );		
 						else
 							rating = 0;
 								
@@ -2625,7 +2518,7 @@
 
 		if(status == BUILDORDER_NOBUILDER)
 		{
-			float temp = 0.05f + 1.5f / ( (float) first-&gt;defences.size() + 0.5f); 
+			float temp = 0.03f + 1.0f / ( (float) first-&gt;defences.size() + 0.5f); 
 
 			if(urgency[STATIONARY_DEF] &lt; temp)
 				urgency[STATIONARY_DEF] = temp;
@@ -2649,6 +2542,7 @@
 
 	// determine how much metal/energy is needed based on net surplus
 	float temp = GetMetalUrgency();
+
 	if(urgency[EXTRACTOR] &lt; temp) // &amp;&amp; urgency[EXTRACTOR] &gt; 0.05) 
 		urgency[EXTRACTOR] = temp;
 
@@ -2658,7 +2552,7 @@
 
 	// build storages if needed
 	if(ai-&gt;activeUnits[STORAGE] + ai-&gt;requestedUnits[STORAGE] + ai-&gt;futureUnits[STORAGE] &lt; cfg-&gt;MAX_STORAGE 
-		&amp;&amp; ai-&gt;activeFactories &gt;= cfg-&gt;MIN_FACTORIES_FOR_STORAGE)
+		&amp;&amp; ut-&gt;activeFactories &gt;= cfg-&gt;MIN_FACTORIES_FOR_STORAGE)
 	{
 		float temp = max(GetMetalStorageUrgency(), GetEnergyStorageUrgency());
 		
@@ -2999,7 +2893,7 @@
 			// at least one requested factory has not been built yet
 			float urgency;
 
-			if(ai-&gt;activeFactories &gt; 0)
+			if(ut-&gt;activeFactories &gt; 0)
 				urgency = 0.4f;
 			else
 				urgency = 3.0f;
@@ -3014,7 +2908,7 @@
 
 void AAIExecute::CheckRecon()
 {
-	if(ai-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_RADAR_JAMMER
+	if(ut-&gt;activeFactories &lt; cfg-&gt;MIN_FACTORIES_FOR_RADAR_JAMMER
 		|| ai-&gt;activeUnits[STATIONARY_RECON] &gt;= brain-&gt;sectors[0].size())
 		return;
 
@@ -3034,7 +2928,7 @@
 
 void AAIExecute::CheckJammer()
 {
-	if(ai-&gt;activeFactories &lt; 2 || ai-&gt;activeUnits[STATIONARY_JAMMER] &gt; brain-&gt;sectors[0].size())
+	if(ut-&gt;activeFactories &lt; 2 || ai-&gt;activeUnits[STATIONARY_JAMMER] &gt; brain-&gt;sectors[0].size())
 	{
 		this-&gt;urgency[STATIONARY_JAMMER] = 0;
 	}
@@ -3129,8 +3023,8 @@
 	{
 		urgency[i] *= 1.035f;
 		
-		if(urgency[i] &gt; 18.0f)
-			urgency[i] -= 2.0f;
+		if(urgency[i] &gt; 20.0f)
+			urgency[i] -= 1.0f;
 	}
 }
 
@@ -3163,20 +3057,20 @@
 
 bool AAIExecute::least_dangerous(AAISector *left, AAISector *right)
 {
-	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;mapType == AIR_MAP)
+	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;map_type == AIR_MAP)
 		return (left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) &lt; right-&gt;GetThreatBy(AIR_ASSAULT, learned, current));  
 	else
 	{
-		if(left-&gt;map-&gt;mapType == LAND_MAP)
+		if(left-&gt;map-&gt;map_type == LAND_MAP)
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)));  
 	
-		else if(left-&gt;map-&gt;mapType == LAND_WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == LAND_WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)));  
 		}
-		else if(left-&gt;map-&gt;mapType == WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)) 
 					&lt; (right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current)));  
@@ -3186,20 +3080,20 @@
 
 bool AAIExecute::suitable_for_power_plant(AAISector *left, AAISector *right)
 {
-	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;mapType == AIR_MAP)
+	if(cfg-&gt;AIR_ONLY_MOD || left-&gt;map-&gt;map_type == AIR_MAP)
 		return (left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) * left-&gt;GetMapBorderDist()  &lt; right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) * right-&gt;GetMapBorderDist());  
 	else
 	{
-		if(left-&gt;map-&gt;mapType == LAND_MAP)
+		if(left-&gt;map-&gt;map_type == LAND_MAP)
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * left-&gt;GetMapBorderDist() ) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * right-&gt;GetMapBorderDist()));  
 	
-		else if(left-&gt;map-&gt;mapType == LAND_WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == LAND_WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * left-&gt;GetMapBorderDist() ) 
 					&lt; (right-&gt;GetThreatBy(GROUND_ASSAULT, learned, current) + right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * right-&gt;GetMapBorderDist()));  
 		}
-		else if(left-&gt;map-&gt;mapType == WATER_MAP)
+		else if(left-&gt;map-&gt;map_type == WATER_MAP)
 		{
 			return ((left-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + left-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + left-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * left-&gt;GetMapBorderDist()) 
 					&lt; (right-&gt;GetThreatBy(SEA_ASSAULT, learned, current) + right-&gt;GetThreatBy(AIR_ASSAULT, learned, current) + right-&gt;GetThreatBy(HOVER_ASSAULT, learned, current) * right-&gt;GetMapBorderDist()));  
@@ -3360,7 +3254,7 @@
 			value = 4;
 		}
 
-		--ai-&gt;futureFactories;
+		--ut-&gt;futureFactories;
 
 		for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def-&gt;id].canBuildList.begin();  unit != bt-&gt;units_static[def-&gt;id].canBuildList.end(); ++unit)		
 			bt-&gt;units_dynamic[*unit].constructorsRequested -= 1;
@@ -3426,27 +3320,32 @@
 	}
 }
 
-
-AAIGroup* AAIExecute::GetClosestGroupOfCategory(UnitCategory category, UnitType type, float3 pos, int importance)
+AAIGroup* AAIExecute::GetClosestGroupForDefence(UnitType group_type, float3 *pos, int continent, int importance)
 {
 	AAIGroup *best_group = 0;
 	float best_rating = 0, my_rating;
 	float3 group_pos; 
 
-	for(list&lt;AAIGroup*&gt;::iterator group = ai-&gt;group_list[category].begin(); group != ai-&gt;group_list[category].end(); ++group)
+	for(list&lt;UnitCategory&gt;::iterator category = bt-&gt;assault_categories.begin(); category != bt-&gt;assault_categories.end(); ++category)
 	{
-		if((*group)-&gt;group_unit_type == type &amp;&amp; !(*group)-&gt;attack)
+		for(list&lt;AAIGroup*&gt;::iterator group = ai-&gt;group_list[*category].begin(); group != ai-&gt;group_list[*category].end(); ++group)
 		{
-			if((*group)-&gt;task == GROUP_IDLE || (*group)-&gt;task_importance &lt; importance)
+			if((*group)-&gt;group_unit_type == group_type &amp;&amp; !(*group)-&gt;attack)
 			{
-				group_pos = (*group)-&gt;GetGroupPos();
+				if((*group)-&gt;continent == -1 || (*group)-&gt;continent == continent)
+				{
+					if((*group)-&gt;task == GROUP_IDLE) // || (*group)-&gt;task_importance &lt; importance)
+					{
+						group_pos = (*group)-&gt;GetGroupPos();
 
-				my_rating = (*group)-&gt;avg_speed / sqrt(1 +  pow(pos.x - group_pos.x, 2.0f) + pow(pos.z - group_pos.z, 2.0f) );
+						my_rating = (*group)-&gt;avg_speed / ( 1.0 + fastmath::sqrt((pos-&gt;x - group_pos.x) * (pos-&gt;x - group_pos.x)  + (pos-&gt;z - group_pos.z) * (pos-&gt;z - group_pos.z) ));
 
-				if(my_rating &gt; best_rating)
-				{
-					best_group = *group;
-					best_rating = my_rating;
+						if(my_rating &gt; best_rating)
+						{
+							best_group = *group;
+							best_rating = my_rating;
+						}
+					}
 				}
 			}
 		}
@@ -3455,157 +3354,24 @@
 	return best_group;
 }
 
-void AAIExecute::DefendUnitVS(int unit, const UnitDef *def, UnitCategory category, float3 *enemy_pos, int importance)
+void AAIExecute::DefendUnitVS(int unit, unsigned int enemy_movement_type, float3 *enemy_pos, int importance)
 {
-	if(unit &lt; 0)
-		return;
-
-	float3 pos = cb-&gt;GetUnitPos(unit);
-
-	AAISector *sector = map-&gt;GetSectorOfPos(&amp;pos);
-
-	// unit/building located in invalid sector
-	if(!sector)
-		return;
-
 	AAIGroup *support = 0;
-
-	// anti air mods have special behaviour
-	if(cfg-&gt;AIR_ONLY_MOD)
-	{
-		support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-		if(!support)
-			support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-		if(!support)
-			support = GetClosestGroupOfCategory(GROUND_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-		if(support)
-			support-&gt;Defend(unit, enemy_pos, importance);
-	}
-	// normal mods
-	else  
-	{
-		bool land, water;
-
-		if(sector-&gt;water_ratio &gt; 0.6)
-		{
-			land = false;
-			water = true;
-		}
-		else
-		{
-			land = true;
-			water = false;
-		}
-
-		// find possible defenders depending on category of attacker
-
-		// anti air 
-		if(category == AIR_ASSAULT)
-		{
-			// try to call fighters first
-			support = GetClosestGroupOfCategory(AIR_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-				
-			// no fighters available
-			if(!support)
-			{	
-				// try to get ground or hover aa support
-				if(land)
-				{
-					support = GetClosestGroupOfCategory(GROUND_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-
-					if(!support)
-						support = GetClosestGroupOfCategory(HOVER_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-				}
-
-				// try to get sea or hover aa support
-				if(water)
-				{
-					support = GetClosestGroupOfCategory(SEA_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-
-					if(!support)
-						support = GetClosestGroupOfCategory(HOVER_ASSAULT, ANTI_AIR_UNIT, pos, 100);
-				}
-			}
-
-			if(support)
-			{
-				// dont defend units too far away from own base
-				if(sector-&gt;distance_to_base &gt; 3 &amp;&amp; support-&gt;category != AIR_ASSAULT)
-					return;
 	
-				support-&gt;Defend(unit, NULL, importance);
-			}
-		}
-		// ground unit attacked
-		else if(land)
-		{
-			if(category == GROUND_ASSAULT || category == HOVER_ASSAULT || category == GROUND_ARTY || category == HOVER_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
+	int continent = map-&gt;GetContinentID(enemy_pos);
 
-				if(!support)
-					support = GetClosestGroupOfCategory(GROUND_ASSAULT, ASSAULT_UNIT, pos, 100);
+	UnitType group_type;
 
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-			else if(category == SEA_ASSAULT || category == SEA_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
+	// anti air needed
+	if(enemy_movement_type &amp; MOVE_TYPE_AIR &amp;&amp; !cfg-&gt;AIR_ONLY_MOD)
+		group_type = ANTI_AIR_UNIT;
+	else
+		group_type = ASSAULT_UNIT;
 
-				if(!support)
-					support = GetClosestGroupOfCategory(SEA_ASSAULT, ASSAULT_UNIT, pos, 100);
+	support = GetClosestGroupForDefence(group_type, enemy_pos, continent, 100);
 
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-
-			if(support)
-			{
-				// dont defend units too far away from own base
-				if(sector-&gt;distance_to_base &gt; 3 &amp;&amp; support-&gt;category != AIR_ASSAULT)
-					return;
-
-				support-&gt;Defend(unit, enemy_pos, importance);
-			}
-		}
-		// water unit attacked
-		else if(water)
-		{
-			if(category == GROUND_ASSAULT || category == GROUND_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(GROUND_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-			else if(category == SEA_ASSAULT || category == HOVER_ASSAULT || category == SEA_ARTY || category == HOVER_ARTY)
-			{
-				support = GetClosestGroupOfCategory(AIR_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(SEA_ASSAULT, ASSAULT_UNIT, pos, 100);
-
-				if(!support)
-					support = GetClosestGroupOfCategory(HOVER_ASSAULT, ASSAULT_UNIT, pos, 100);
-			}
-
-			if(support)
-			{
-				// dont defend units too far away from own base
-				if(sector-&gt;distance_to_base &gt; 3 &amp;&amp; support-&gt;category != AIR_ASSAULT)
-					return;
-
-				support-&gt;Defend(unit, enemy_pos, importance);
-			}
-		}	
-	}
+	if(support)
+		support-&gt;Defend(unit, enemy_pos, importance);
 }
 
 float3 AAIExecute::GetSafePos(int def_id, float3 unit_pos)
@@ -3790,4 +3556,4 @@
 	//	fprintf(ai-&gt;file, &quot;%i th order has been given by %s in frame %i\n&quot;, issued_orders, owner,  cb-&gt;GetCurrentFrame());
 
 	cb-&gt;GiveOrder(unit, c);
-}
+}
\ No newline at end of file

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIExecute.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIExecute.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIExecute.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -28,7 +28,7 @@
 	void InitAI(int commander_unit_id, const UnitDef *commander_def);
 
 	// return true if building will be placed at a valid pos = inside sectors
-	bool InitBuildingAt(const UnitDef *def, float3 pos);
+	bool InitBuildingAt(const UnitDef *def, float3 pos, bool water);
 
 	void ConstructBuildingAt(int building, int builder, float3 position); 
 
@@ -110,7 +110,7 @@
 	BuildOrderStatus BuildStationaryDefenceVS(UnitCategory category, AAISector *dest);
 
 	// tries to call support vs air (returns true if succesful)
-	void DefendUnitVS(int unit, const UnitDef *def, UnitCategory category, float3 *enemy_pos, int importance);
+	void DefendUnitVS(int unit, unsigned int enemy_movement_type, float3 *enemy_pos, int importance);
 
 	// returns true if succesfully assisting construction
 	bool AssistConstructionOfCategory(UnitCategory category, int importance = 5);
@@ -127,18 +127,15 @@
 	// returns the the total air defence power of all units
 	float GetTotalAirPower();
 	
-	// chooses a stzarting sector close to specified sector
+	// chooses a starting sector close to specified sector
 	void ChooseDifferentStartingSector(int x, int y);
 
-	// 
-	AAIGroup* GetClosestGroupOfCategory(UnitCategory category, UnitType type, float3 pos, int importance); 
+	// returns closest (taking into account movement speed) group with units of specified unit type that may reach the location 
+	AAIGroup* GetClosestGroupForDefence(UnitType group_type, float3 *pos, int continent, int importance);
 
 	float3 GetRallyPoint(unsigned int unit_movement_type, int continent_id, int min_dist, int max_dist);
 	float3 GetRallyPointCloseTo(UnitCategory category, unsigned int unit_movement_type, int continent_id, float3 pos, int min_dist, int max_dist);
 
-	AAIMetalSpot* FindMetalSpotClosestToBuilder(int land_mex, int water_mex);
-	AAIMetalSpot* FindMetalSpot(bool land, bool water);
-
 	float3 GetBuildsite(int builder, int building, UnitCategory category);
 	float3 GetUnitBuildsite(int builder, int unit);
 

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIGroup.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIGroup.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIGroup.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -14,7 +14,6 @@
 
 AAIGroup::AAIGroup(AAI *ai, const UnitDef *def, UnitType unit_type, int continent_id)
 {
-	
 	this-&gt;ai = ai;
 	cb = ai-&gt;cb;
 	bt = ai-&gt;bt;
@@ -165,7 +164,7 @@
 bool AAIGroup::RemoveUnit(int unit, int attacker)
 {
 	// look for unit with that id
-	for(list&lt;int2&gt;::iterator i = units.begin(); i != units.end(); i++)
+	for(list&lt;int2&gt;::iterator i = units.begin(); i != units.end(); ++i)
 	{
 		if(i-&gt;x == unit)
 		{
@@ -210,11 +209,13 @@
 						ai-&gt;af-&gt;CheckTarget(attacker, def);
 					else if(category == AIR_ASSAULT)
 					{
+						float3 enemy_pos = cb-&gt;GetUnitPos(attacker);
+
 						// get a random unit of the group
 						int unit = GetRandomUnit();
 
 						if(unit)
-							ai-&gt;execute-&gt;DefendUnitVS(unit, cb-&gt;GetUnitDef(unit), category, NULL, 110);
+							ai-&gt;execute-&gt;DefendUnitVS(unit, bt-&gt;units_static[def-&gt;id].movement_type, &amp;enemy_pos, 100);
 					}
 				}
 			}

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIMap.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIMap.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIMap.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -14,29 +14,33 @@
 
 // all the static vars
 int AAIMap::aai_instances = 0;
+char AAIMap::map_filename[500];
 int AAIMap::xSize;
-int AAIMap::ySize;
+int AAIMap::ySize;	
 int AAIMap::xMapSize;
-int AAIMap::yMapSize;
+int AAIMap::yMapSize;				
 int AAIMap::xDefMapSize;
 int AAIMap::yDefMapSize;
 int AAIMap::xContMapSize;
-int AAIMap::yContMapSize;
+int AAIMap::yContMapSize;	
 int AAIMap::xSectors;
-int AAIMap::ySectors;
+int AAIMap::ySectors;				
 int AAIMap::xSectorSize; 
-int AAIMap::ySectorSize;
+int AAIMap::ySectorSize;		
 int AAIMap::xSectorSizeMap; 
 int AAIMap::ySectorSizeMap;
 
 list&lt;AAIMetalSpot&gt;  AAIMap::metal_spots;
 
+int AAIMap::land_metal_spots;
+int AAIMap::water_metal_spots;
+
 bool AAIMap::metalMap;
-MapType AAIMap::mapType;
+MapType AAIMap::map_type;	
 
 vector&lt; vector&lt;int&gt; &gt; AAIMap::team_sector_map;
-vector&lt;int&gt; AAIMap::buildmap;
-vector&lt;int&gt; AAIMap::blockmap;
+vector&lt;int&gt; AAIMap::buildmap;	
+vector&lt;int&gt; AAIMap::blockmap;	
 vector&lt;float&gt; AAIMap::plateau_map;
 vector&lt;int&gt; AAIMap::continent_map;	
 
@@ -45,7 +49,12 @@
 int AAIMap::water_continents;
 int AAIMap::avg_land_continent_size;
 int AAIMap::avg_water_continent_size;
+int AAIMap::max_land_continent_size;
+int AAIMap::max_water_continent_size;
+int AAIMap::min_land_continent_size;
+int AAIMap::min_water_continent_size;
 
+
 list&lt;UnitCategory&gt; AAIMap::map_categories;
 list&lt;int&gt; AAIMap::map_categories_id;
 vector&lt;vector&lt;float&gt; &gt; AAIMap::map_usefulness;
@@ -82,23 +91,12 @@
 		Learn();
 
 		// save map data
-		char filename[500];
-		char buffer[500];
-		strcpy(buffer, MAIN_PATH);
-		strcat(buffer, MAP_LEARN_PATH);
-		strcat(buffer, cb-&gt;GetMapName());
-		ReplaceExtension(buffer, filename, sizeof(filename), &quot;_&quot;);
-		strcat(filename, cb-&gt;GetModName());
-		ReplaceExtension(filename, buffer, sizeof(filename), &quot;.dat&quot;);
+		FILE *save_file = fopen(map_filename, &quot;w+&quot;);
 
-		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, buffer);
-	
-		FILE *save_file = fopen(buffer, &quot;w+&quot;);
-
 		fprintf(save_file, &quot;%s \n&quot;,MAP_FILE_VERSION);
 
 		// save map type
-		fprintf(save_file, &quot;%s \n&quot;, GetMapTypeString(mapType));
+		fprintf(save_file, &quot;%s \n&quot;, GetMapTypeString(map_type));
 
 		// save units map_usefulness
 		float sum;
@@ -106,13 +104,13 @@
 		for(int i = 0; i &lt; cfg-&gt;SIDES; ++i)
 		{
 			// rebalance map_usefulness
-			if(mapType == LAND_MAP)
+			if(map_type == LAND_MAP)
 			{
 				sum = map_usefulness[0][i] + map_usefulness[2][i];
 				map_usefulness[0][i] *= (100.0/sum);
 				map_usefulness[2][i] *= (100.0/sum);
 			}
-			else if(mapType == LAND_WATER_MAP)
+			else if(map_type == LAND_WATER_MAP)
 			{
 				sum = map_usefulness[0][i] + map_usefulness[2][i] + map_usefulness[3][i] + map_usefulness[4][i];
 				map_usefulness[0][i] *= (100.0/sum);
@@ -120,7 +118,7 @@
 				map_usefulness[3][i] *= (100.0/sum);
 				map_usefulness[4][i] *= (100.0/sum);
 			}
-			else if(mapType == WATER_MAP)
+			else if(map_type == WATER_MAP)
 			{
 				sum = map_usefulness[2][i] + map_usefulness[3][i] + map_usefulness[4][i];
 				map_usefulness[2][i] *= (100.0/sum);
@@ -202,9 +200,9 @@
 		for(int x = 0; x &lt; xSectors; ++x)
 			team_sector_map[x].resize(ySectors, -1);
 
-		ReadCacheFile();
+		ReadContinentFile();
 
-		ReadContinentFile();
+		ReadMapCacheFile();
 	}
 
 	// create field of sectors
@@ -245,12 +243,13 @@
 
 	// for log file
 	fprintf(ai-&gt;file, &quot;Map: %s\n&quot;,cb-&gt;GetMapName());
+	fprintf(ai-&gt;file, &quot;Maptype: %s\n&quot;, GetMapTypeTextString(map_type));
 	fprintf(ai-&gt;file, &quot;Mapsize is %i x %i\n&quot;, cb-&gt;GetMapWidth(),cb-&gt;GetMapHeight());
 	fprintf(ai-&gt;file, &quot;%i sectors in x direction\n&quot;, xSectors);
 	fprintf(ai-&gt;file, &quot;%i sectors in y direction\n&quot;, ySectors);
 	fprintf(ai-&gt;file, &quot;x-sectorsize is %i (Map %i)\n&quot;, xSectorSize, xSectorSizeMap);
 	fprintf(ai-&gt;file, &quot;y-sectorsize is %i (Map %i)\n&quot;, ySectorSize, ySectorSizeMap);
-	fprintf(ai-&gt;file, &quot;%i metal spots found \n \n&quot;,metal_spots.size());
+	fprintf(ai-&gt;file, &quot;%i metal spots found (%i are on land, %i under water) \n \n&quot;,metal_spots.size(), land_metal_spots, water_metal_spots);
 	fprintf(ai-&gt;file, &quot;%i continents found on map\n&quot;, continents.size());
 	fprintf(ai-&gt;file, &quot;%i land and %i water continents\n&quot;, land_continents, water_continents);
 	fprintf(ai-&gt;file, &quot;Average land continent size is %i\n&quot;, avg_land_continent_size);
@@ -273,31 +272,30 @@
 	}*/
 }
 
-void AAIMap::ReadCacheFile()
+void AAIMap::ReadMapCacheFile()
 {
 	// try to read cache file
 	bool loaded = false;
 	
-	char filename[500];
 	char buffer[500];
 	strcpy(buffer, MAIN_PATH);
 	strcat(buffer, MAP_CACHE_PATH);
 	strcat(buffer, cb-&gt;GetMapName());
-	ReplaceExtension(buffer, filename, sizeof(filename), &quot;.dat&quot;);
+	ReplaceExtension(buffer, map_filename, sizeof(map_filename), &quot;.dat&quot;);
 
-	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename);
+	ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_R, map_filename);
 
 	FILE *file;
 
-	if(file = fopen(filename, &quot;r&quot;))
+	if(file = fopen(map_filename, &quot;r&quot;))
 	{
 		// check if correct version
 		fscanf(file, &quot;%s &quot;, buffer);
 
-		if(strcmp(buffer, MAP_DATA_VERSION))
+		if(strcmp(buffer, MAP_CACHE_VERSION))
 		{
 			cb-&gt;SendTextMsg(&quot;Mapcache out of date - creating new one&quot;, 0);
-			fprintf(ai-&gt;file, &quot;Map cache-file out of date - new one has been created\n&quot;);
+			fprintf(ai-&gt;file, &quot;Map cache file out of date - new one has been created\n&quot;);
 			fclose(file);
 		}
 		else
@@ -336,6 +334,8 @@
 				metal_spots.push_back(spot);
 			}
 
+			fscanf(file, &quot;%i %i &quot;, &amp;land_metal_spots, &amp;water_metal_spots); 
+
 			fclose(file);
 
 			fprintf(ai-&gt;file, &quot;Map cache file succesfully loaded\n&quot;);
@@ -357,13 +357,13 @@
 		strcpy(buffer, MAIN_PATH);
 		strcat(buffer, MAP_CACHE_PATH);
 		strcat(buffer, cb-&gt;GetMapName());
-		ReplaceExtension(buffer, filename, sizeof(filename), &quot;.dat&quot;);
+		ReplaceExtension(buffer, map_filename, sizeof(map_filename), &quot;.dat&quot;);
 
-		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
+		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, map_filename);
 
-		file = fopen(filename, &quot;w+&quot;);
+		file = fopen(map_filename, &quot;w+&quot;);
 
-		fprintf(file, &quot;%s\n&quot;, MAP_DATA_VERSION);
+		fprintf(file, &quot;%s\n&quot;, MAP_CACHE_VERSION);
 
 		// save if its a metal map
 		fprintf(file, &quot;%i\n&quot;, (int)metalMap);
@@ -379,11 +379,23 @@
 			fprintf(file, &quot;%f &quot;, plateau_map[i]); 
 
 		// save mex spots
+		land_metal_spots = 0;
+		water_metal_spots = 0;
+
 		fprintf(file, &quot;\n%i \n&quot;, metal_spots.size());
 
-		for(list&lt;AAIMetalSpot&gt;::iterator spot = metal_spots.begin(); spot != metal_spots.end(); spot++)
+		for(list&lt;AAIMetalSpot&gt;::iterator spot = metal_spots.begin(); spot != metal_spots.end(); ++spot)
+		{
 			fprintf(file, &quot;%f %f %f %f \n&quot;, spot-&gt;pos.x, spot-&gt;pos.y, spot-&gt;pos.z, spot-&gt;amount);
 
+			if(spot-&gt;pos.y &gt;= 0)
+				++land_metal_spots;
+			else
+				++water_metal_spots;
+		}
+
+		fprintf(file, &quot;%i %i\n&quot;, land_metal_spots, water_metal_spots);
+
 		fclose(file);
 
 		fprintf(ai-&gt;file, &quot;New map cache-file created\n&quot;);
@@ -391,6 +403,9 @@
 
 	// determine map type
 	loaded = true;
+
+	char filename[500];
+
 	strcpy(buffer, MAIN_PATH);
 	strcat(buffer, MAP_CFG_PATH);
 	strcat(buffer, cb-&gt;GetMapName());
@@ -404,26 +419,22 @@
 		fscanf(file, &quot;%s &quot;, buffer);
 
 		if(!strcmp(buffer, &quot;LAND_MAP&quot;))
-			mapType = LAND_MAP;
+			map_type = LAND_MAP;
 		else if(!strcmp(buffer, &quot;AIR_MAP&quot;))
-			mapType = AIR_MAP;
+			map_type = AIR_MAP;
 		else if(!strcmp(buffer, &quot;LAND_WATER_MAP&quot;))
-			mapType = LAND_WATER_MAP;
+			map_type = LAND_WATER_MAP;
 		else if(!strcmp(buffer, &quot;WATER_MAP&quot;))
-			mapType = WATER_MAP;
+			map_type = WATER_MAP;
 		else
-			mapType = UNKNOWN_MAP;
+			map_type = UNKNOWN_MAP;
 
-		if(mapType &gt;= 0 &amp;&amp; mapType &lt;= WATER_MAP)
+		if(map_type &gt;= 0 &amp;&amp; map_type &lt;= WATER_MAP)
 		{
-			this-&gt;mapType = (MapType) mapType;
+			this-&gt;map_type = (MapType) map_type;
 
-			// logging
-			sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(mapType));
-			fprintf(ai-&gt;file, &quot;\nLoading map type:\n&quot;);
-			fprintf(ai-&gt;file, buffer);
-			fprintf(ai-&gt;file, &quot;\n\n&quot;);
-
+			sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(map_type));
+	
 			if(bt-&gt;aai_instances == 1)
 				ai-&gt;cb-&gt;SendTextMsg(buffer, 0);
 		}
@@ -450,16 +461,18 @@
 
 		water_ratio = water_ratio / ((float)(xMapSize*yMapSize));
 
-		if(water_ratio &gt; 0.80f)
-			this-&gt;mapType = WATER_MAP;
+
+		//
+		if( (float)max_land_continent_size &lt; 0.5f * (float)max_water_continent_size || water_ratio &gt; 0.80f)
+			this-&gt;map_type = WATER_MAP;
 		else if(water_ratio &gt; 0.25f)
-			this-&gt;mapType = LAND_WATER_MAP;
+			this-&gt;map_type = LAND_WATER_MAP;
 		else
-			this-&gt;mapType = LAND_MAP;
+			this-&gt;map_type = LAND_MAP;
 
 
 		// logging
-		sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(this-&gt;mapType));
+		sprintf(buffer, &quot;%s detected&quot;, GetMapTypeTextString(this-&gt;map_type));
 		ai-&gt;cb-&gt;SendTextMsg(buffer, 0);
 		fprintf(ai-&gt;file, &quot;\nAutodetecting map type:\n&quot;);
 		fprintf(ai-&gt;file, buffer);
@@ -474,7 +487,7 @@
 		ai-&gt;cb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
 
 		file = fopen(filename, &quot;w+&quot;);
-		fprintf(file, &quot;%s\n&quot;, GetMapTypeString(this-&gt;mapType));
+		fprintf(file, &quot;%s\n&quot;, GetMapTypeString(this-&gt;map_type));
 		fclose(file);
 	}
 
@@ -493,7 +506,7 @@
 	}
 	else
 	{
-		if(mapType == LAND_MAP)
+		if(map_type == LAND_MAP)
 		{
 			map_categories.push_back(GROUND_ASSAULT);
 			map_categories.push_back(AIR_ASSAULT);
@@ -503,7 +516,7 @@
 			map_categories_id.push_back(1);
 			map_categories_id.push_back(2);
 		}
-		else if(mapType == LAND_WATER_MAP)
+		else if(map_type == LAND_WATER_MAP)
 		{
 			map_categories.push_back(GROUND_ASSAULT);
 			map_categories.push_back(AIR_ASSAULT);
@@ -517,7 +530,7 @@
 			map_categories_id.push_back(3);
 			map_categories_id.push_back(4);
 		}
-		else if(mapType == WATER_MAP)
+		else if(map_type == WATER_MAP)
 		{
 			map_categories.push_back(AIR_ASSAULT);
 			map_categories.push_back(HOVER_ASSAULT);
@@ -592,7 +605,9 @@
 			}
 
 			// load statistical data
-			fscanf(file, &quot;%i %i %i %i&quot;, &amp;land_continents, &amp;water_continents, &amp;avg_land_continent_size, &amp;avg_water_continent_size);
+			fscanf(file, &quot;%i %i %i %i %i %i %i %i&quot;, &amp;land_continents, &amp;water_continents, &amp;avg_land_continent_size, &amp;avg_water_continent_size, 
+																			&amp;max_land_continent_size, &amp;max_water_continent_size, 
+																			&amp;min_land_continent_size, &amp;min_water_continent_size);
 
 			fclose(file);
 
@@ -639,7 +654,9 @@
 		fprintf(file, &quot;%i %i \n&quot;, continents[c].size, (int)continents[c].water);
 
 	// save statistical data
-	fprintf(file, &quot;%i %i %i %i\n&quot;, land_continents, water_continents, avg_land_continent_size, avg_water_continent_size);
+	fprintf(file, &quot;%i %i %i %i %i %i %i %i\n&quot;, land_continents, water_continents, avg_land_continent_size, avg_water_continent_size, 
+																	max_land_continent_size, max_water_continent_size, 
+																	min_land_continent_size, min_water_continent_size);
 
 	fclose(file);
 }
@@ -681,7 +698,7 @@
 			fscanf(load_file, &quot;%s&quot;, buffer);
 
 			// map type does not match
-			if(strcmp(buffer, GetMapTypeString(mapType)))
+			if(strcmp(buffer, GetMapTypeString(map_type)))
 			{
 				cb-&gt;SendTextMsg(&quot;Map type has changed - creating new map learning file&quot;, 0);
 				fclose(load_file);
@@ -728,7 +745,7 @@
 		for(int i = 0; i &lt; cfg-&gt;SIDES; ++i)
 		{
 			for(int j = 0; j &lt; bt-&gt;assault_categories.size(); ++j)
-				map_usefulness[j][i] = bt-&gt;mod_usefulness[j][i][mapType];
+				map_usefulness[j][i] = bt-&gt;mod_usefulness[j][i][map_type];
 		}
 	}
 
@@ -1239,9 +1256,9 @@
 	// check horizontal space
 	if(xPos+xSize+cfg-&gt;MAX_XROW &lt;= xMapSize &amp;&amp; xPos - cfg-&gt;MAX_XROW &gt;= 0)
 	{
-		for(int y = yPos; y &lt; yPos + ySize; y++)
+		for(int y = yPos; y &lt; yPos + ySize; ++y)
 		{
-			if(y&gt;= yMapSize)
+			if(y &gt;= yMapSize)
 			{
 				fprintf(ai-&gt;file, &quot;ERROR: y = %i index out of range when checking horizontal rows&quot;, y);
 				return;
@@ -1380,10 +1397,6 @@
 
 void AAIMap::BlockCells(int xPos, int yPos, int width, int height, bool block, bool water)
 {
-	// check range
-	if(xPos &lt; 0 || yPos &lt; 0 || xPos+width &gt; xMapSize || yPos + height &gt; yMapSize)
-		return;
-
 	//float3 my_pos;
 	int empty, cell;
 
@@ -1394,59 +1407,58 @@
 
 	if(block)	// block cells
 	{
-		for(int x = xPos; x &lt; xPos + width; x++)
+		for(int x = xPos; x &lt; xPos + width; ++x)
 		{
-			for(int y = yPos; y &lt; yPos + height; y++)
+			for(int y = yPos; y &lt; yPos + height; ++y)
 			{
 				cell = x + xMapSize*y;
 
 				// if no building ordered that cell to be blocked, update buildmap
 				// (only if space is not already occupied by a building)
-				if(!(blockmap[cell]++))
+				if(blockmap[cell] == 0 &amp;&amp; buildmap[cell] == empty)
 				{
-					if(buildmap[cell] == empty)
+					buildmap[cell] = 2;
+
+					// debug
+					/*if(x%2 == 0 &amp;&amp; y%2 == 0)
 					{
-						buildmap[cell] = 2;
+						my_pos.x = x * 8;
+						my_pos.z = y * 8;
+						my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
+						cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
+					}*/
+				}
 
-						/*// debug
-						if(x%2 == 0 &amp;&amp; y%2 == 0)
-						{
-							my_pos.x = x * 8;
-							my_pos.z = y * 8;
-							my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
-							cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
-						}*/
-					}
-				}
+				++blockmap[cell];
 			}
 		}
 	}
 	else		// unblock cells
 	{
-		for(int x = xPos; x &lt; xPos + width; x++)
+		for(int x = xPos; x &lt; xPos + width; ++x)
 		{
-			for(int y = yPos; y &lt; yPos + height; y++)
+			for(int y = yPos; y &lt; yPos + height; ++y)
 			{
 				cell = x + xMapSize*y;
 
-				if(blockmap[cell])
+				if(blockmap[cell] &gt; 0)
 				{
-					// if cell is not blocked anymore, update buildmap
-					if(!(--blockmap[cell]))
+					--blockmap[cell];
+
+					// if cell is not blocked anymore, mark cell on buildmap as empty (only if it has been marked bloked 
+					//					- if it is not marked as blocked its occupied by another building or unpassable)
+					if(blockmap[cell] == 0 &amp;&amp; buildmap[cell] == 2)
 					{
-						if(buildmap[cell] == 2)
+						buildmap[cell] = empty;
+
+						// debug
+						/*if(x%2 == 0 &amp;&amp; y%2 == 0)
 						{
-							buildmap[cell] = empty;
-
-							// debug
-							/*if(x%2 == 0 &amp;&amp; y%2 == 0)
-							{
-								my_pos.x = x * 8;
-								my_pos.z = y * 8;
-								my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
-								cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
-							}*/
-						}
+							my_pos.x = x * 8;
+							my_pos.z = y * 8;
+							my_pos.y = cb-&gt;GetElevation(my_pos.x, my_pos.z);
+							cb-&gt;DrawUnit(&quot;ARMMINE1&quot;, my_pos, 0.0f, 1500, cb-&gt;GetMyAllyTeam(), true, true);
+						}*/
 					}
 				}
 			}
@@ -1475,9 +1487,9 @@
 	while(buildmap[x+yPos*xMapSize] == value)
 	{
 		if(direction)
-			x++;
+			++x;
 		else
-			x--;
+			--x;
 
 		// search went out of map
 		if(x &lt; 0 || x &gt;= xMapSize)
@@ -1494,9 +1506,9 @@
 	while(buildmap[xPos+y*xMapSize] == value)
 	{
 		if(direction)
-			y++;
+			++y;
 		else
-			y--;
+			--y;
 
 		// search went out of map
 		if(y &lt; 0 || y &gt;= yMapSize)
@@ -1792,7 +1804,6 @@
 						y = ((*cell) - x) / xContMapSize;
 
 						// check edges
-						
 						if(x &gt; 0 &amp;&amp; continent_map[y * xContMapSize + x - 1] &lt; 0)
 						{
 							if(height_map[4 * (y * xMapSize + x - 1)] &lt; 0)
@@ -1860,8 +1871,13 @@
 	// calculate some statistical data
 	land_continents = 0;
 	water_continents = 0;
+
 	avg_land_continent_size = 0;
 	avg_water_continent_size = 0;
+	max_land_continent_size = 0;
+	max_water_continent_size = 0;
+	min_land_continent_size = xContMapSize * yContMapSize;
+	min_water_continent_size = xContMapSize * yContMapSize;
 
 	for(int i = 0; i &lt; continents.size(); ++i)
 	{
@@ -1869,11 +1885,23 @@
 		{
 			++water_continents;
 			avg_water_continent_size += continents[i].size;
+
+			if(continents[i].size &gt; max_water_continent_size)
+				max_water_continent_size = continents[i].size;
+
+			if(continents[i].size &lt; min_water_continent_size)
+				min_water_continent_size = continents[i].size;
 		}
 		else
 		{
 			++land_continents;
 			avg_land_continent_size += continents[i].size;
+
+			if(continents[i].size &gt; max_land_continent_size)
+				max_land_continent_size = continents[i].size;
+
+			if(continents[i].size &lt; min_land_continent_size)
+				min_land_continent_size = continents[i].size;
 		}
 	}
 
@@ -1884,8 +1912,7 @@
 		avg_land_continent_size /= land_continents;
 }
 
-// algorithm more or less by krogothe
-// thx very much
+// algorithm more or less by krogothe - thx very much
 void AAIMap::SearchMetalSpots()
 {
 	const UnitDef* def = bt-&gt;unitList[bt-&gt;GetBiggestMex()-1];
@@ -2060,26 +2087,13 @@
 		fprintf(ai-&gt;file, &quot;Map is considered to be a metal map\n&quot;,0);
 	}
 	else
-	{
 		metalMap = false;
 
-		// debug
-		/*for(list&lt;AAIMetalSpot&gt;::iterator spot = metal_spots.begin(); spot != metal_spots.end(); spot++)
-		{
-			cb-&gt;DrawUnit(&quot;ARMMEX&quot;, spot-&gt;pos, 0.0f, 200000, cb-&gt;GetMyAllyTeam(), false, true);
-		}*/
-	}
-
-
 	delete [] MexArrayA;
 	delete [] MexArrayB;
 	delete [] TempAverage;
 }
 
-void AAIMap::GetMapData()
-{
-}
-
 void AAIMap::UpdateRecon()
 {
 	const UnitDef *def;
@@ -2257,47 +2271,47 @@
 
 	if(killer &lt; 5)
 	{
-		bt-&gt;mod_usefulness[killer][killer_type-&gt;side-1][mapType] += change;
+		bt-&gt;mod_usefulness[killer][killer_type-&gt;side-1][map_type] += change;
 		map_usefulness[killer][killer_type-&gt;side-1] += change;
 	}
 
 	if(killed &lt; 5)
 	{
 		map_usefulness[killed][killed_type-&gt;side-1] -= change;
-		bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][mapType] -= change;
+		bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][map_type] -= change;
 
 		if(map_usefulness[killed][killed_type-&gt;side-1] &lt; 1)
 			map_usefulness[killed][killed_type-&gt;side-1] = 1;
 
-		if(bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][mapType] &lt; 1)
-			bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][mapType] = 1;
+		if(bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][map_type] &lt; 1)
+			bt-&gt;mod_usefulness[killed][killed_type-&gt;side-1][map_type] = 1;
 	}
 }
 
 
-const char* AAIMap::GetMapTypeString(int mapType)
+const char* AAIMap::GetMapTypeString(int map_type)
 {
-	if(mapType == 1)
+	if(map_type == 1)
 		return &quot;LAND_MAP&quot;;
-	else if(mapType == 2)
+	else if(map_type == 2)
 		return &quot;AIR_MAP&quot;;
-	else if(mapType == 3)
+	else if(map_type == 3)
 		return &quot;LAND_WATER_MAP&quot;;
-	else if(mapType == 4)
+	else if(map_type == 4)
 		return &quot;WATER_MAP&quot;;
 	else
 		return &quot;UNKNOWN_MAP&quot;;
 }
 
-const char* AAIMap::GetMapTypeTextString(int mapType)
+const char* AAIMap::GetMapTypeTextString(int map_type)
 {
-	if(mapType == 1)
+	if(map_type == 1)
 		return &quot;land map&quot;;
-	else if(mapType == 2)
+	else if(map_type == 2)
 		return &quot;air map&quot;;
-	else if(mapType == 3)
+	else if(map_type == 3)
 		return &quot;land-water map&quot;;
-	else if(mapType == 4)
+	else if(map_type == 4)
 		return &quot;water map&quot;;
 	else
 		return &quot;unknown map type&quot;;
@@ -2665,4 +2679,4 @@
 		y = yContMapSize - 1;
 
 	return continent_map[y * xContMapSize + x];
-}
+}
\ No newline at end of file

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIMap.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIMap.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIMap.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -26,7 +26,7 @@
 	int GetContinentID(int x, int y);
 	int GetContinentID(float3 *pos);
 
-	// returns continent id with respect to the units movement type (eg land, non amphib unit being in shallow water will return id of nearest land continent)
+	// returns continent id with respect to the units movement type (e.g. land, non amphib unit being in shallow water will return id of nearest land continent)
 	int GetSmartContinentID(float3 *pos, unsigned int unit_movement_type);
 
 	// true if x/y are a valid sector
@@ -52,7 +52,7 @@
 	// prevents ai from building too many buildings in a row
 	void CheckRows(int xPos, int yPos, int xSize, int ySize, bool add, bool water);
 
-	// adds or removes blocked cells (to prevent aai from packing buildings too close to each other)
+	// blocks/unblocks cells (to prevent AAI from packing buildings too close to each other)
 	void BlockCells(int xPos, int yPos, int width, int height, bool block, bool water);
 
 	// returns number of cells with big slope
@@ -67,8 +67,8 @@
 	// increases/decreases usefulness of the category of the killer/killed unit 
 	void UpdateCategoryUsefulness(const UnitDef *killer_def, int killer, const UnitDef *killed_def, int killed);
 
-	const char* GetMapTypeTextString(int mapType);
-	const char* GetMapTypeString(int mapType);
+	const char* GetMapTypeTextString(int map_type);
+	const char* GetMapTypeString(int map_type);
 
 	// return next cell in direction with a certain value
 	int GetNextX(int direction, int xPos, int yPos, int value);	// 0 means left, other right; returns -1 if not found 
@@ -78,7 +78,8 @@
 	bool CanBuildAt(int xPos, int yPos, int xSize, int ySize, bool water = false);
 
 	// reads map cache file (and creates new one if necessary)
-	void ReadCacheFile();
+	// loads mex spots, cliffs etc. from file or creates new one
+	void ReadMapCacheFile();
 
 	// reads continent cache file (and creates new one if necessary)
 	void ReadContinentFile();
@@ -86,15 +87,13 @@
 	// if auto_set == true, the loaded values are assigned to the current sectordata as well 
 	void ReadMapLearnFile(bool auto_set);
 
-	// loads mex spots, cliffs etc. from file or creates new one
-	void GetMapData();
-
 	// calculates learning effect
 	void Learn();
 
-	// get water, high slopes, defence map
+	// determines water, high slopes, defence map
 	void AnalyseMap();
 
+	// calculates which parts of the are connected
 	void CalculateContinentMaps();
 
 	// adds/removes a defence buidling to the defence map (air == true -&gt; add to air defence map)
@@ -130,6 +129,7 @@
 public:
 
 	static int aai_instances;	// how many aai instances have been initialized
+	static char map_filename[500];
 
 	static int xSize, ySize;					// x and y size of the map (unit coordinates)
 	static int xMapSize, yMapSize;				// x and y size of the map (map coordinates)
@@ -141,10 +141,13 @@
 
 	static list&lt;AAIMetalSpot&gt; metal_spots;
 
+	static int land_metal_spots;
+	static int water_metal_spots;
+
 	static bool metalMap;
-	static MapType mapType;	// 0 -&gt; unknown ,1-&gt; land map (default), 2 -&gt; air map, 
-							// 3 -&gt; water map with land connections 
-							// 4 -&gt; &quot;full water map
+	static MapType map_type;	// 0 -&gt; unknown ,1-&gt; land map (default), 2 -&gt; air map, 
+								// 3 -&gt; water map with land connections 
+								// 4 -&gt; &quot;full water map
 
 	static vector&lt; vector&lt;int&gt; &gt; team_sector_map;	// stores the number of ai player which has taken that sector (-1 if none)
 											// this helps preventing aai from expanding into sectors of other aai players
@@ -170,8 +173,13 @@
 	static vector&lt;AAIContinent&gt; continents;
 	static int land_continents;
 	static int water_continents;
+	
 	static int avg_land_continent_size;
 	static int avg_water_continent_size;
+	static int max_land_continent_size;
+	static int max_water_continent_size;
+	static int min_land_continent_size;
+	static int min_water_continent_size;
 
 	static list&lt;UnitCategory&gt; map_categories;
 	static list&lt;int&gt; map_categories_id;

Modified: branches/caiinterface/AI/Skirmish/AAI/AAISector.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAISector.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAISector.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,9 +16,9 @@
 }
 
 AAISector::~AAISector(void)
-{
+{	
 	defences.clear();
-
+	
 	attacked_by_this_game.clear(); 
 	attacked_by_learned.clear(); 
 
@@ -52,14 +52,14 @@
 	distance_to_base = -1;
 	last_scout = 1;
 	rally_points = 0;
-
+	
 	// nothing sighted in that sector
 	enemy_structures = 0;
 	own_structures = 0;
 	allied_structures = 0;
 	threat = 0;
 	failed_defences = 0;
-
+	
 	int categories = ai-&gt;bt-&gt;assault_categories.size();
 
 	combats_learned.resize(categories, 0);
@@ -498,7 +498,7 @@
 
 float AAISector::GetThreatByID(int combat_cat_id, float learned, float current)
 {
-	return 1.0f + (learned * attacked_by_learned[combat_cat_id] + current * attacked_by_this_game[combat_cat_id] ) / (learned + current);
+	return 0.25f + (learned * attacked_by_learned[combat_cat_id] + current * attacked_by_this_game[combat_cat_id] ) / (learned + current);
 }
 
 float AAISector::GetThreatTo(float ground, float air, float hover, float sea, float submarine)
@@ -770,4 +770,4 @@
 	}
 
 	*pos = ZeroVector;
-}
+}
\ No newline at end of file

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.cpp
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -18,7 +18,6 @@
 	this-&gt;bt = bt;
 	this-&gt;cb = ai-&gt;cb;
 
-//	units = new AAIUnit[cfg-&gt;MAX_UNITS];
 	units.resize(cfg-&gt;MAX_UNITS);
 
 	// fill buildtable 
@@ -31,6 +30,10 @@
 		units[i].status = UNIT_KILLED;
 	}
 
+	activeScouts = futureScouts = 0;
+	activeBuilders = futureBuilders = 0;
+	activeFactories = futureFactories = 0;
+
 	cmdr = -1;
 }
 
@@ -129,14 +132,14 @@
 
 	if(builder)
 	{
-		--ai-&gt;futureBuilders;
-		++ai-&gt;activeBuilders;
+		--futureBuilders;
+		++activeBuilders;
 	}
 
 	if(factory &amp;&amp; bt-&gt;IsStatic(def_id))
 	{
-		--ai-&gt;futureFactories;
-		++ai-&gt;activeFactories;
+		--futureFactories;
+		++activeFactories;
 
 		// remove future ressource demand now factory has been finished
 		ai-&gt;execute-&gt;futureRequestedMetal -= bt-&gt;units_static[def_id].efficiency[0];
@@ -147,10 +150,10 @@
 void AAIUnitTable::RemoveConstructor(int unit_id, int def_id)
 {
 	if(units[unit_id].cons-&gt;builder)
-		ai-&gt;activeBuilders -= 1;
+		activeBuilders -= 1;
 
 	if(units[unit_id].cons-&gt;factory &amp;&amp; bt-&gt;IsStatic(def_id))
-		ai-&gt;activeFactories -= 1;
+		activeFactories -= 1;
 	
 	// decrease number of available builders for all buildoptions of the builder
 	for(list&lt;int&gt;::iterator unit = bt-&gt;units_static[def_id].canBuildList.begin();  unit != bt-&gt;units_static[def_id].canBuildList.end(); ++unit)		
@@ -224,10 +227,24 @@
 
 void AAIUnitTable::RemoveExtractor(int unit_id)
 {
-	// delete mex from list
 	extractors.erase(unit_id);
 }
 
+void AAIUnitTable::AddScout(int unit_id)
+{
+	++activeScouts;
+	--futureScouts;
+
+	scouts.insert(unit_id);
+}
+
+void AAIUnitTable::RemoveScout(int unit_id)
+{
+	--activeScouts;
+
+	scouts.erase(unit_id);
+}
+
 void AAIUnitTable::AddPowerPlant(int unit_id, int def_id)
 {
 	power_plants.insert(unit_id);
@@ -320,14 +337,15 @@
 	return 0;
 }
 
-AAIConstructor* AAIUnitTable::FindClosestBuilder(int building, float3 pos, bool commander)
+AAIConstructor* AAIUnitTable::FindClosestBuilder(int building, float3 *pos, bool commander, float *min_dist)
 {	
-	float min_dist = 1000000, my_dist;
+	float my_dist;
 	AAIConstructor *best_builder = 0, *builder;
 	float3 builder_pos;
 	bool suitable;
 
-	int continent = ai-&gt;map-&gt;GetContinentID(&amp;pos);
+	int continent = ai-&gt;map-&gt;GetContinentID(pos);
+	*min_dist = 100000.0f;
 
 	// look for idle builder
 	for(set&lt;int&gt;::iterator i = constructors.begin(); i != constructors.end(); ++i)
@@ -356,15 +374,15 @@
 				// filter out commander
 				if(suitable &amp;&amp; ( commander || !bt-&gt;IsCommander(builder-&gt;def_id) ) )
 				{
-					my_dist = fastmath::sqrt( (builder_pos.x - pos.x) * (builder_pos.x - pos.x) + (builder_pos.z - pos.z) * (builder_pos.z - pos.z) );
+					my_dist = fastmath::sqrt( (builder_pos.x - pos-&gt;x) * (builder_pos.x - pos-&gt;x) + (builder_pos.z - pos-&gt;z) * (builder_pos.z - pos-&gt;z) );
 					
 					if(bt-&gt;unitList[builder-&gt;def_id-1]-&gt;speed &gt; 0)
 						my_dist /= bt-&gt;unitList[builder-&gt;def_id-1]-&gt;speed;
 
-					if(my_dist &lt; min_dist)
+					if(my_dist &lt; *min_dist)
 					{
 						best_builder = builder;
-						min_dist = my_dist;
+						*min_dist = my_dist;
 					}
 				}
 			}

Modified: branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/AAIUnitTable.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -17,6 +17,9 @@
 
 	bool AddUnit(int unit_id, int def_id, AAIGroup *group = 0, AAIConstructor *cons = 0);
 	void RemoveUnit(int unit_id);
+	
+	void AddScout(int unit_id);
+	void RemoveScout(int unit_id);
 
 	void AddConstructor(int unit_id, int def_id);
 	void RemoveConstructor(int unit_id, int def_id);
@@ -43,7 +46,10 @@
 	void RemoveStationaryArty(int unit_id);
 
 	AAIConstructor* FindBuilder(int building, bool commander);
-	AAIConstructor* FindClosestBuilder(int building, float3 pos, bool commander);
+
+	// finds closest builder and stores its distance to pos in min_dist
+	AAIConstructor* FindClosestBuilder(int building, float3 *pos, bool commander, float *min_dist);
+
 	AAIConstructor* FindClosestAssistant(float3 pos, int importance, bool commander);
 
 	void EnemyKilled(int unit);
@@ -62,12 +68,18 @@
 	AAIBuildTable *bt;
 	IAICallback* cb;
 
+	// units[i].unitId = -1 -&gt; not used , -2 -&gt; enemy unit
 	vector&lt;AAIUnit&gt; units;
-	// units[i].unitId = -1 -&gt; not used , -2 -&gt; enemy unit
 
+	// number of active/under construction units of all different types
+	int activeScouts, futureScouts;
+	int activeBuilders, futureBuilders;
+	int activeFactories, futureFactories;
+
 	// commanders id
 	int cmdr;
-
+		
+	set&lt;int&gt; scouts;
 	set&lt;int&gt; constructors;
 	set&lt;int&gt; metal_makers;
 	set&lt;int&gt; jammers; 

Modified: branches/caiinterface/AI/Skirmish/AAI/aidef.h
===================================================================
--- branches/caiinterface/AI/Skirmish/AAI/aidef.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/AI/Skirmish/AAI/aidef.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -3,7 +3,7 @@
 //
 // A skirmish AI for the TA Spring engine.
 // Copyright Alexander Seizinger
-// 
+//
 // Released under GPL license: see LICENSE.html for more information.
 // -------------------------------------------------------------------------
 
@@ -18,10 +18,10 @@
 #include &quot;ExternalAI/IGlobalAICallback.h&quot;
 #include &quot;ExternalAI/IAICallback.h&quot;
 #include &quot;ExternalAI/aibase.h&quot;
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;System/Vec2.h&quot;
 #include &quot;Game/GlobalConstants.h&quot;
-#include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/CommandQueue.h&quot;
 #include &quot;AAIConfig.h&quot;
@@ -30,20 +30,20 @@
 
 #ifdef _MSC_VER
 #pragma warning(disable: 4244 4018) // signed/unsigned and loss of precision...
-#endif 
+#endif
 
 void ReplaceExtension (const char *n, char *dst,int s, const char *ext);
 
 #ifndef AIDEF_H
 #define AIDEF_H
 
-#define AAI_VERSION &quot;0.872&quot;
+#define AAI_VERSION &quot;0.875&quot;
 #define MAP_FILE_VERSION &quot;MAP_LEARN_0_80&quot;
 #define TABLE_FILE_VERSION &quot;MOD_LEARN_0_87&quot;
-#define MAP_DATA_VERSION &quot;MAP_DATA_0_86&quot;
-#define CONTINENT_DATA_VERSION &quot;MOVEMENT_MAPS_0_86&quot;
+#define MAP_CACHE_VERSION &quot;MAP_DATA_0_87&quot;
+#define CONTINENT_DATA_VERSION &quot;MOVEMENT_MAPS_0_87&quot;
 
-// all paths 
+// all paths
 #define MAIN_PATH &quot;AI/AAI/&quot;
 #define AILOG_PATH &quot;log/&quot;
 #define MOD_CFG_PATH &quot;cfg/mod/&quot;
@@ -61,7 +61,7 @@
 public:
 	AAIMetalSpot(float3 pos, float amount) {this-&gt;pos = pos; this-&gt;amount = amount; occupied = false; extractor = -1; extractor_def = -1;}
 	AAIMetalSpot() {pos = ZeroVector; amount = 0; occupied = false; extractor = -1; extractor_def = -1;}
-	
+
 	float3 pos;
 	bool occupied;
 	int extractor;		// -1 if unocuppied
@@ -106,9 +106,9 @@
 enum SectorType {UNKNOWN_SECTOR, LAND_SECTOR, LAND_WATER_SECTOR, WATER_SECTOR};
 
 enum UnitCategory {UNKNOWN, STATIONARY_DEF, STATIONARY_ARTY, STORAGE, STATIONARY_CONSTRUCTOR, AIR_BASE,
-STATIONARY_RECON, STATIONARY_JAMMER, STATIONARY_LAUNCHER, DEFLECTION_SHIELD, POWER_PLANT, EXTRACTOR, METAL_MAKER, 
-COMMANDER, GROUND_ASSAULT, AIR_ASSAULT, HOVER_ASSAULT, SEA_ASSAULT, SUBMARINE_ASSAULT, GROUND_ARTY, SEA_ARTY, HOVER_ARTY, 
-SCOUT, MOBILE_TRANSPORT, MOBILE_JAMMER, MOBILE_LAUNCHER, MOBILE_CONSTRUCTOR}; 
+STATIONARY_RECON, STATIONARY_JAMMER, STATIONARY_LAUNCHER, DEFLECTION_SHIELD, POWER_PLANT, EXTRACTOR, METAL_MAKER,
+COMMANDER, GROUND_ASSAULT, AIR_ASSAULT, HOVER_ASSAULT, SEA_ASSAULT, SUBMARINE_ASSAULT, GROUND_ARTY, SEA_ARTY, HOVER_ARTY,
+SCOUT, MOBILE_TRANSPORT, MOBILE_JAMMER, MOBILE_LAUNCHER, MOBILE_CONSTRUCTOR};
 
 enum GroupTask {GROUP_IDLE, GROUP_ATTACKING, GROUP_DEFENDING, GROUP_PATROLING, GROUP_BOMBING, GROUP_RETREATING};
 
@@ -148,7 +148,7 @@
 struct UnitTypeStatic
 {
 	int def_id;
-	int side;				// 0 if side has not been set 
+	int side;				// 0 if side has not been set
 	list&lt;int&gt; canBuildList;
 	list&lt;int&gt; builtByList;
 	vector&lt;float&gt; efficiency;		// 0 -&gt; ground assault, 1 -&gt; air assault, 2 -&gt; hover assault

Modified: branches/caiinterface/Documentation/Spring start.txt
===================================================================
--- branches/caiinterface/Documentation/Spring start.txt	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/Documentation/Spring start.txt	2008-11-02 10:29:36 UTC (rev 6956)
@@ -37,6 +37,7 @@
 	AutohostPort=X;     // communicate with spring, specify the port you are listening (as host)
 
 	MyPlayerNum=x;      //only variable that should vary between different players
+	MyPlayerName=somename; //can be used instead of MyPlayerNum (will overwrite it in fact)
 
 	NumPlayers=x;       // not mandatory, but can be used for debugging purposes
 	NumTeams=y;         // same here, set this to check if the script is right

Modified: branches/caiinterface/Documentation/changelog.txt
===================================================================
--- branches/caiinterface/Documentation/changelog.txt	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/Documentation/changelog.txt	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,5 +1,56 @@
 Spring change log
 
+0.77b6:
+
+Crashes:
+ - fix crash on window resizing
+ - do not force useFPShadows to true unless they are supported (to prevent crashes during map-loading)
+
+Engine:
+ - if in Choose ingame startposition mode its possible to play a map with more players than startpositions
+ - fix the aircraft hovering / drifting
+ - fix random start positions not beeing random
+ - fix area-attack for aircraft (#1144 again)
+ - GenerateTargets no longer has much information that the team requesting targets doesn't have
+
+User Interface:
+ - enable startboxes by default
+ - decreased CPU laod and increase drawing speed lines
+ - fix small memleak when resizing the window
+ - The protection ring shows up for non-stockpile interceptors
+ - fix detection of units under mouse for spectators
+
+Lua:
+ - added Spring.GetLastMessagePositions() (returns the 10 last message positions)
+ - moved Spring.GetDrawSelectionInfo() LuaUnsyncedCtrl -&gt; LuaUnsyncedRead
+
+Unitsync:
+ - Don't crash/abort() on invalid handles, but throw exception instead
+ - Fix crash bug in unitsync when UnInit/Init was called after an earlier Init which returned error code
+ - Doesn't leak exceptions anymore over C interface.
+ - Doesn't just crash by design anymore after something goes wrong.
+ - Added API GetNextError, can be used to get error queue (currently limited to 1 error)
+ -Deprecated APIs:
+   - GetCurrentList
+   - AddClient
+   - RemoveClient
+   - GetClientDiff
+   - InstallClientDiff
+   - IsUnitDisabled
+   - IsUnitDisabledByClient
+ - Removed all code supporting those functions.
+ - These deprecated functions pop up MessageBox once on windows to nag lobby devs.
+ - Use engine's logOutput, still writes to unitsync.log (overwrites, doesn't append)
+ - ProcessUnitsNoChecksum is now identical to ProcessUnits.
+ - ProcessUnits now returns 0 immediately (but should still be called in loop until it returns 0, in case it's changed sometime later)
+
+Installer:
+ - Fix groups.ini being overwritten by installer
+ - Update to Kernel Panic 3.0
+ - Remove old CA shortcuts
+
+
+
 0.77b5
 Installer:
  - check if common unitsync users are running, abort installation if any is found

Modified: branches/caiinterface/SConstruct
===================================================================
--- branches/caiinterface/SConstruct	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/SConstruct	2008-11-02 10:29:36 UTC (rev 6956)
@@ -119,6 +119,7 @@
 	'rts/Sim/SideParser.cpp',
 	'rts/System/Platform/ConfigHandler.cpp',
 	'rts/System/Platform/FileSystem.cpp',
+	'rts/System/LogOutput.cpp',
 ]
 for f in unitsync_fs_files:       unitsync_files += f
 for f in unitsync_lua_files:      unitsync_files += f

Modified: branches/caiinterface/game/AI/AAI/AAI ReadMe.txt
===================================================================
--- branches/caiinterface/game/AI/AAI/AAI ReadMe.txt	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/game/AI/AAI/AAI ReadMe.txt	2008-11-02 10:29:36 UTC (rev 6956)
@@ -106,7 +106,19 @@
 		- Brandon Potter for his TBT 12 cfg file
 
 
+AAI v0.875	- Current ammount of land/water within the base is taken into account when selecting factories (e.g. dont order 
+		  water factories on a land map anymore)
 
+		- Improved AAIs behaviour on water maps with start positions on islands/land masses
+
+		- Improved metal extractor construction algorithm (spots closer to available builder, faster algorithm, 
+		  works better if there are land and sea spots available at the same time)
+
+		- Continent file version bumped to 0.87
+
+		- Fixed a crash on shut down introduced in Spring v0.77
+
+
 AAI v0.872	- Refactored code for getting rally points and positions to withdraw units and made 
 
 		- Construction units that are member of the DONT_BUILD list will not be built anymore
@@ -126,11 +138,11 @@
 		- Added some new variables to mod config file:
 
 		  FALLBACK_DIST_RATIO 0.9 - units will try keep enemies at this ratio of their maximum weapons' range
-		  
+
 		  MIN_FALLBACK_RANGE 500  - units with lower weapons' range will not try fall back at all
-		 
+
 		  MAX_FALLBACK_RANGE 800  - units with higher weapons' range will not try fall back at all   
-	
+
   		  MIN_FALLBACK_TURNRATE 250 - units with lower turnrate will not try fall back at all	
 
 		- Added submarine defence map -&gt; AAI will now store its defence capabilities vs submarines separately from other 

Modified: branches/caiinterface/game/LuaUI/Widgets/minimap_startbox.lua
===================================================================
--- branches/caiinterface/game/LuaUI/Widgets/minimap_startbox.lua	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/game/LuaUI/Widgets/minimap_startbox.lua	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,7 +19,7 @@
     date      = &quot;Mar 17, 2007&quot;,
     license   = &quot;GNU GPL, v2 or later&quot;,
     layer     = 0,
-    enabled   = false  --  loaded by default?
+    enabled   = true  --  loaded by default?
   }
 end
 

Modified: branches/caiinterface/installer/builddata/springcontent/EngineOptions.lua
===================================================================
--- branches/caiinterface/installer/builddata/springcontent/EngineOptions.lua	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/installer/builddata/springcontent/EngineOptions.lua	2008-11-02 10:29:36 UTC (rev 6956)
@@ -38,7 +38,7 @@
       { 
         key  = '0',
         name = 'Kill everything',
-        desc = 'The player will lose when only after all units of the player will be killed',
+        desc = 'The player will lose only after all units of the player will be killed',
       },
       {
         key  = '1',
@@ -75,7 +75,7 @@
   {
     key    = 'StartEnergy',
     name   = 'Starting energy',
-    desc   = 'Determines amount of metal and metal storage that each player will start with',
+    desc   = 'Determines amount of energy and energy storage that each player will start with',
     type   = 'number',
     section= 'StartingResources',
     def    = 500,
@@ -88,7 +88,7 @@
   {
     key    = 'MaxUnits',
     name   = 'Max units',
-    desc   = 'Determines the ceiling of how many units and buildings a player is allowed  to own at the same time',
+    desc   = 'Determines the ceiling of how many units and buildings a player is allowed to own at the same time',
     type   = 'number',
     def    = 1000,
     min    = 1,
@@ -108,13 +108,13 @@
   {
     key    = 'GhostedBuildings',
     name   = 'Ghosted buildings',
-    desc   = &quot;Once an enemy building will be spotted\n a ghost trail will be placed to memorize location even after the loss of the line of sight&quot;,
+    desc   = &quot;Once an enemy building will be spotted\na ghost trail will be placed to memorize location even after the loss of the line of sight&quot;,
     type   = 'bool',
     def    = true,
   },
   {
     key    = 'DiminishingMMs',
-    name   = 'Diminishing efficiency MetalMakers',
+    name   = 'Diminishing metal makers efficiency',
     desc   = &quot;Everytime a new metal maker will be built, the energy/metal efficiency ratio will decrease&quot;,
     type   = 'bool',
     def    = false,
@@ -123,7 +123,7 @@
   {
     key    = 'FixedAllies',
     name   = 'Fixed ingame alliances',
-    desc   = 'Disables the possibility of players to dynamically change allies ingame',
+    desc   = 'Disables the possibility of players to dynamically change alliances ingame',
     type   = 'bool',
     def    = true,
   },
@@ -163,7 +163,7 @@
   
   {
     key    = 'DisableMapDamage',
-    name   = 'Underformable map',
+    name   = 'Undeformable map',
     desc   = 'Prevents the map shape from being changed by weapons',
     type   = 'bool',
     def    = false,

Modified: branches/caiinterface/installer/builddata/springcontent/shaders/bumpWaterFS.glsl
===================================================================
--- branches/caiinterface/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/installer/builddata/springcontent/shaders/bumpWaterFS.glsl	2008-11-02 10:29:36 UTC (rev 6956)
@@ -8,256 +8,8 @@
  * GNU GPL, v2 or later.
  */
 
-//////////////////////////////////////////////////
-// runtime defined constants are:
-// #define SurfaceColor     vec4
-// #define DiffuseColor     vec3
-// #define PlaneColor       vec4  (unused)
-// #define AmbientFactor    float
-// #define DiffuseFactor    float   (note: it is the map defined value multipled with 15x!)
-// #define SpecularColor    vec3
-// #define SpecularPower    float
-// #define SpecularFactor   float
-// #define PerlinStartFreq  float
-// #define PerlinFreq       float
-// #define PerlinAmp        float
-// #define Speed            float
-// #define FresnelMin       float
-// #define FresnelMax       float
-// #define FresnelPower     float
-// #define ScreenInverse    vec2
-// #define ViewPos          vec2
-// #define MapMid           vec3
-// #define SunDir           vec3
-// #define ReflDistortion   float
-// #define BlurBase         vec2
-// #define BlurExponent     float
-// #define PerlinStartFreq  float
-// #define PerlinLacunarity float
-// #define PerlinAmp        float
 
 //////////////////////////////////////////////////
-// possible flags are:
-// //#define use_heightmap
-// #define use_reflection
-// #define use_refraction
-// #define use_shorewaves
-// #define use_depth
-// #define blur_reflection
-
-#extension GL_ARB_texture_rectangle : enable
-
-#define CausticDepth 0.5
-#define CausticRange 0.45
-#define WavesLength  0.15
-
-//////////////////////////////////////////////////
-// Uniforms + Varyings
-
-  uniform sampler2D normalmap;
-  uniform sampler2D heightmap;
-  uniform sampler2D caustic;
-  uniform sampler2D foam;
-  uniform sampler2D reflection;
-  uniform sampler2DRect refraction;
-  uniform sampler2D coastmap;
-  uniform sampler2DRect depthmap;
-  uniform sampler2D waverand;
-  uniform float frame;
-  uniform vec3 eyePos;
-
-  varying vec3 eyeVec;
-  varying vec3 ligVec;
-
-//////////////////////////////////////////////////
-// Depth conversion
-
-  float pm15 = gl_ProjectionMatrix[2][3];
-  float pm11 = gl_ProjectionMatrix[2][3];
-  float convertDepthToZ(float d) {
-    return pm15 / (((d * 2.0) - 1.0) + pm11);
-  }
-
-
-//////////////////////////////////////////////////
-// shorewaves functions
-const float InvWavesLength = 1.0/WavesLength;
-
-float smoothlimit(const float x, const float step) {
-  if (x&gt;step)
-    //return step * smoothstep(1.0,step,x);
-    return step - (mod(x,step)*step)/(1.0-step);
-  else
-    return x;
-}
-
-
-float waveIntensity(const float x, const float step) {
-  float front = 1.0-(abs(x-step))/(1.0-step);
-  //float front = smoothstep(1.0-step,0.0,abs(x-step));
-  if (x&lt;step)
-    return max(front,x*0.5);
-  else
-    return front;
-}
-
-//////////////////////////////////////////////////
-// MAIN()
-
-  void main(void) {
-// GET WATERDEPTH
-#ifdef use_heightmap
-    float waterdepth = -texture2D(heightmap,gl_TexCoord[0].st).r;
-    if (waterdepth&lt;0.0) discard;
-#else
-    float waterdepth = 1.0-texture2D(heightmap,gl_TexCoord[0].pq).a; //heightmap in alpha channel
-    if (waterdepth==0.0) discard;
-    //float invwaterdepth = 1.0-waterdepth;
-#endif
-
-#ifdef use_depth
-    float tz = texture2DRect(depthmap, gl_FragCoord.xy-ViewPos ).r;
-    float shallowScale = clamp( abs( convertDepthToZ(tz) - convertDepthToZ(gl_FragCoord.z) )/3.0, 0.0,1.0);
-#else
-    float shallowScale = waterdepth;
-#endif
-
-    gl_FragColor.a = 1.0;
-
-// NORMALMAP
-    vec3 octave1 = texture2D(normalmap,gl_TexCoord[1].st).rgb;
-    vec3 octave2 = texture2D(normalmap,gl_TexCoord[1].pq).rgb;
-    vec3 octave3 = texture2D(normalmap,gl_TexCoord[2].st).rgb;
-    vec3 octave4 = texture2D(normalmap,gl_TexCoord[2].pq).rgb;
-
-    const float a = PerlinAmp;
-    octave1 = (octave1*2.0-1.0)*a;
-    octave2 = (octave2*2.0-1.0)*a*a;
-    octave3 = (octave3*2.0-1.0)*a*a*a;
-    octave4 = (octave4*2.0-1.0)*a*a*a*a;
-
-    vec3 normal = octave1+octave2+octave3+octave4;
-    normal = normalize( normal ).xzy;
-
-    vec3 eVec   = normalize(eyeVec); // wait for texture fetches
-    float eyeNormalCos = dot(-eVec, normal);
-    float angle = (1.0-abs(eyeNormalCos));
-
-
-// AMBIENT &amp; DIFFUSE
-    vec3 reflectDir   = reflect(normalize(-ligVec), normal);
-    float specular    = SpecularFactor * angle * pow( max(dot(reflectDir,eVec), 0.0) , SpecularPower) * shallowScale;
-    const vec3 SunLow = SunDir * vec3(1.0,0.1,1.0);
-    float diffuse     = pow( max( dot(normal,SunLow) ,0.0 ) ,3.0)*DiffuseFactor;
-    float ambient     = smoothstep(-1.3,0.0,eyeNormalCos)*AmbientFactor;
-    vec3 waterSurface = SurfaceColor.rgb + DiffuseColor*diffuse + vec3(ambient);
-#ifdef use_heightmap
-    float maxWaterDepth= -30.0;
-    float surfaceMix   = (SurfaceColor.a + diffuse)*(waterdepth/maxWaterDepth);
-    float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*(waterdepth/maxWaterDepth);
-#else
-    float surfaceMix   = (SurfaceColor.a + diffuse)*shallowScale;
-    float refractDistortion = 60.0*(1.0-pow(gl_FragCoord.z,80.0))*shallowScale;
-#endif
-
-
-// REFRACTION
-#ifdef use_refraction
-    vec3 refrColor = texture2DRect(refraction, gl_FragCoord.xy-ViewPos + normal.xz*refractDistortion ).rgb;
-    gl_FragColor.rgb = mix(refrColor,waterSurface, 0.1+surfaceMix);
-#else
-    gl_FragColor.rgb = waterSurface;
-    gl_FragColor.a   = surfaceMix + specular;
-#endif
-
-
-// CAUSTICS
-#ifdef use_heightmap
-    if ((waterdepth/maxWaterDepth)&lt;1.0) {
-      vec3 caust = texture2D(caustic,gl_TexCoord[0].st*80.0).rgb;
-      gl_FragColor.rgb = mix(gl_FragColor.rgb,refrColor+(caust*(waterdepth/maxWaterDepth)*0.25),1.0-(waterdepth/maxWaterDepth));
-    }
-#else
-    if (waterdepth&gt;0.0) {
-      vec3 caust = texture2D(caustic,gl_TexCoord[0].st*75.0).rgb;
-  #ifdef use_refraction
-      float caustBlend = smoothstep(CausticRange,0.0,abs(waterdepth-CausticDepth));
-      gl_FragColor.rgb += caust*caustBlend*0.08;  
-  #else
-      gl_FragColor.a *= min(waterdepth*4.0,1.0);
-      gl_FragColor.rgb += caust*(1.0-waterdepth)*0.6;
-  #endif
-    }
-#endif
-
-
-// SHORE WAVES
-#ifdef use_shorewaves
-    vec3 shorewavesColor = vec3(0.0);
-    float inwaterdepth = 1.0-waterdepth;
-    //if (waterdepth&lt;1.0) {
-      float coastdist = texture2D(coastmap, gl_TexCoord[0].st ).r;
-      //if (coastdist&gt;0.0 &amp;&amp; coastdist&lt;0.25) {
-        vec3 wavefoam  = texture2D(foam, gl_TexCoord[0].st*160.0+frame ).rgb;
-        wavefoam += texture2D(foam, gl_TexCoord[0].st*90.0+frame ).rgb;
-        wavefoam *= 0.5;
-
-        float fframe = fract(frame);
-        for (float i=0.0; i&lt;1.0; i+=1.0) {
-          float frac = fract(i+fframe*40.0)*1.4-0.2;
-          float f = frac-coastdist;
-          if (abs(f)&gt;WavesLength) continue;
-          float rand = texture2D(waverand, gl_TexCoord[0].st*2.0+frame+i ).r;
-          float f2 = waveIntensity( min(1.0,(WavesLength-f)*InvWavesLength) ,0.93);
-          shorewavesColor += wavefoam*f2*rand*rand;
-        }
-
-        shorewavesColor *= coastdist;
-      //}
-    //}
-    float iwd = smoothlimit(inwaterdepth, 0.8);
-    gl_FragColor.rgb += shorewavesColor*iwd*1.5;
-#endif
-
-
-// REFLECTION
-#ifdef use_reflection
-    float fresnel    = FresnelMin + FresnelMax * pow(angle,FresnelPower);
-    vec2 reftexcoord = vec2(0.0,1.0) - (gl_FragCoord.xy-ViewPos)*ScreenInverse + vec2(0.0,3.0*ScreenInverse.y) + normal.xz*0.09*ReflDistortion;
-    vec3 reflColor   = texture2D(reflection,reftexcoord.st).rgb;
-
-  #ifdef blur_reflection
-    const vec2  v = BlurBase;
-    const float s = BlurExponent;
-    reflColor   += texture2D(reflection,reftexcoord.st+v).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s).rgb;
-    reflColor   += texture2D(reflection,reftexcoord.st+v*s*s*s*s*s*s).rgb;
-    reflColor   *= 0.125;
-  #endif
-
-    gl_FragColor.rgb = mix(gl_FragColor.rgb, reflColor, fresnel*shallowScale);
-#endif
-
-
-// SPECULAR
-    gl_FragColor.rgb += specular*SpecularColor;
-  }=======
-/**
- * @project Spring RTS
- * @file bumpWaterFS.glsl
- * @brief An extended bumpmapping water shader
- * @author jK
- *
- * Copyright (C) 2008.  Licensed under the terms of the
- * GNU GPL, v2 or later.
- */
-
-
-//////////////////////////////////////////////////
 // runtime defined constants are:
 // #define SurfaceColor     vec4
 // #define DiffuseColor     vec3
@@ -284,6 +36,8 @@
 // #define PerlinStartFreq  float
 // #define PerlinLacunarity float
 // #define PerlinAmp        float
+// #define TexGenPlane      vec4
+// #define ShadingPlane     vec2
 
 #define CausticDepth 0.5
 #define CausticRange 0.45
@@ -384,7 +138,8 @@
     if (waterdepth&lt;0.0) discard;
 #else
     float waterdepth;
-    if ( any(greaterThanEqual(gl_TexCoord[0].pq,vec2(1.0,1.0))) ||
+
+    if ( any(greaterThanEqual(gl_TexCoord[0].pq,ShadingPlane.xy)) ||
          any(lessThanEqual(gl_TexCoord[0].pq,vec2(0.0,0.0)))
        )
     {
@@ -543,4 +298,4 @@
 // FOG
     float fog = clamp( (gl_Fog.end - abs(gl_FogFragCoord)) * gl_Fog.scale ,0.0,1.0);
     gl_FragColor.rgb = mix(gl_Fog.color.rgb, gl_FragColor.rgb, fog );
-  }&gt;&gt;&gt;&gt;&gt;&gt;&gt; .merge-right.r6568
+  }
\ No newline at end of file

Modified: branches/caiinterface/rts/ExternalAI/AICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/ExternalAI/AICallback.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -87,9 +87,9 @@
 void CAICallback::SendTextMsg(const char* text, int zone)
 {
 	if (group)
-		logOutput.Print(zone, &quot;Group%i: %s&quot;, group-&gt;id, text);
+		logOutput.Print(&quot;Group%i: %s&quot;, group-&gt;id, text);
 	else
-		logOutput.Print(zone, &quot;GlobalAI%i: %s&quot;, team, text);
+		logOutput.Print(&quot;GlobalAI%i: %s&quot;, team, text);
 }
 
 void CAICallback::SetLastMsgPos(float3 pos)
@@ -995,7 +995,7 @@
 	CUnitDrawer::TempDrawUnit tdu;
 	tdu.unitdef=unitDefHandler-&gt;GetUnitByName(unitName);
 	if(!tdu.unitdef){
-		logOutput.Print(&quot;Uknown unit in CAICallback::DrawUnit %s&quot;,unitName);
+		logOutput.Print(&quot;Unknown unit in CAICallback::DrawUnit %s&quot;,unitName);
 		return;
 	}
 	tdu.pos=pos;
@@ -1535,6 +1535,7 @@
 	verify();
 	int a = 0;
 
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnit
 	// check if the allyteam of the player running
 	// the AI lib matches the AI's actual allyteam
 	if (gu-&gt;myAllyTeam == gs-&gt;AllyTeam(team)) {

Modified: branches/caiinterface/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/ExternalAI/GroupHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -87,7 +87,7 @@
 
 void CGroupHandler::DrawCommands()
 {
-	GML_STDMUTEX_LOCK(cai);
+//	GML_STDMUTEX_LOCK(cai); // not needed, protected via SelectedUnits::DrawCommands
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)!=0)
 			(*ai)-&gt;DrawCommands();
@@ -153,6 +153,9 @@
 
 void CGroupHandler::GroupCommand(int num)
 {
+	GML_RECMUTEX_LOCK(sel); // GroupCommand
+	GML_STDMUTEX_LOCK(group); // GroupCommand
+
 	if (keys[SDLK_LCTRL]) {
 		if (!keys[SDLK_LSHIFT]) {
 			groups[num]-&gt;ClearUnits();
@@ -199,6 +202,9 @@
 
 void CGroupHandler::GroupCommand(int num, const std::string&amp; cmd)
 {
+	GML_RECMUTEX_LOCK(sel); // GroupCommand
+	GML_STDMUTEX_LOCK(group); // GroupCommand
+
 	if ((cmd == &quot;set&quot;) || (cmd == &quot;add&quot;)) {
 		if (cmd == &quot;set&quot;) {
 			groups[num]-&gt;ClearUnits();
@@ -263,6 +269,8 @@
 
 CGroup* CGroupHandler::CreateNewGroup(AIKey aiKey)
 {
+	GML_STDMUTEX_LOCK(group); // GroupCommand
+
 	if(freeGroups.empty()){
 		CGroup* group=SAFE_NEW CGroup(aiKey,firstUnusedGroup++,this);
 		groups.push_back(group);
@@ -281,6 +289,9 @@
 
 void CGroupHandler::RemoveGroup(CGroup* group)
 {
+	GML_RECMUTEX_LOCK(sel); // RemoveGroup
+	GML_STDMUTEX_LOCK(group); // RemoveGroup
+
 	if(group-&gt;id&lt;10){
 		logOutput.Print(&quot;Warning trying to remove hotkey group %i&quot;,group-&gt;id);
 		return;
@@ -294,6 +305,8 @@
 
 std::map&lt;AIKey, std::string&gt; CGroupHandler::GetSuitedAis(const CUnitSet&amp; units)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSuitedAis
+
 	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
 	ISUNITSUITED IsUnitSuited;
 

Modified: branches/caiinterface/rts/Game/Camera.cpp
===================================================================
--- branches/caiinterface/rts/Game/Camera.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/Camera.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -5,6 +5,7 @@
 
 #include &quot;mmgr.h&quot;
 
+#include &quot;System/myMath.h&quot;
 #include &quot;System/GlobalUnsynced.h&quot;
 #include &quot;Camera.h&quot;
 #include &quot;Map/Ground.h&quot;
@@ -256,13 +257,13 @@
 
 bool CCamera::InView(const float3 &amp;p, float radius)
 {
-	const float3 t = (p - pos);
-	const float  l = t.Length();
+	const float3 t   = (p - pos);
+	const float  lsq = t.SqLength();
 
-	if (l &lt; 50.0f) {
+	if (lsq &lt; 2500.0f) {
 		return true;
 	}
-	else if (l &gt; gu-&gt;viewRange) {
+	else if (lsq &gt; Square(gu-&gt;viewRange)) {
 		return false;
 	}
 	

Modified: branches/caiinterface/rts/Game/ChatMessage.cpp
===================================================================
--- branches/caiinterface/rts/Game/ChatMessage.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/ChatMessage.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,14 +16,10 @@
 
 ChatMessage::ChatMessage(boost::shared_ptr&lt;const netcode::RawPacket&gt; data)
 {
-	UnpackPacket packet(data);
-	unsigned char ID;
-	unsigned char length;
+	assert(data-&gt;data[0] == NETMSG_CHAT);
+	UnpackPacket packet(data, 2);
 	unsigned char from;
 	unsigned char dest;
-	packet &gt;&gt; ID;
-	assert(ID == NETMSG_CHAT);
-	packet &gt;&gt; length;
 	packet &gt;&gt; from;
 	packet &gt;&gt; dest;
 	packet &gt;&gt; msg;
@@ -34,8 +30,7 @@
 const netcode::RawPacket* ChatMessage::Pack() const
 {
 	unsigned char size = 4*sizeof(unsigned char) + msg.size()+1;
-	PackPacket* buffer = new PackPacket(size);
-	*buffer &lt;&lt; (unsigned char)NETMSG_CHAT;
+	PackPacket* buffer = new PackPacket(size, NETMSG_CHAT);
 	*buffer &lt;&lt; size;
 	*buffer &lt;&lt; (unsigned char)fromPlayer;
 	*buffer &lt;&lt; (unsigned char)destination;

Modified: branches/caiinterface/rts/Game/CommandMessage.cpp
===================================================================
--- branches/caiinterface/rts/Game/CommandMessage.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/CommandMessage.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -25,12 +25,8 @@
 
 CommandMessage::CommandMessage(boost::shared_ptr&lt;const netcode::RawPacket&gt; pckt)
 {
-	UnpackPacket packet(pckt);
-	unsigned char ID;
-	unsigned short length;
-	packet &gt;&gt; ID;
-	assert(ID == NETMSG_CCOMMAND);
-	packet &gt;&gt; length;
+	assert(pckt-&gt;data[0] == NETMSG_CCOMMAND);
+	UnpackPacket packet(pckt, 3);
 	packet &gt;&gt; player;
 	packet &gt;&gt; action.command;
 	packet &gt;&gt; action.extra;
@@ -39,8 +35,7 @@
 const netcode::RawPacket* CommandMessage::Pack() const
 {
 	unsigned short size = 3 + sizeof(player) + action.command.size() + action.extra.size() + 2;
-	PackPacket* buffer = new PackPacket(size);
-	*buffer &lt;&lt; (unsigned char)NETMSG_CCOMMAND;
+	PackPacket* buffer = new PackPacket(size, NETMSG_CCOMMAND);
 	*buffer &lt;&lt; size;
 	*buffer &lt;&lt; player;
 	*buffer &lt;&lt; action.command;

Modified: branches/caiinterface/rts/Game/Game.cpp
===================================================================
--- branches/caiinterface/rts/Game/Game.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/Game.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -160,7 +160,7 @@
 
 #ifdef USE_GML
 #include &quot;lib/gml/gmlsrv.h&quot;
-gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
+extern gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 #endif
 
 extern Uint8 *keys;
@@ -204,6 +204,8 @@
 
 	CR_MEMBER(moveWarnings),
 
+	CR_MEMBER(lastSimFrame),
+
 //	CR_MEMBER(script),
 	CR_RESERVED(64),
 	CR_POSTLOAD(PostLoad)
@@ -250,6 +252,8 @@
 	thisFps = 0;
 	totalGameTime = 0;
 
+	lastSimFrame=-1;
+
 	creatingVideo = false;
 
 	playing  = false;
@@ -539,14 +543,12 @@
 
 	ENTER_MIXED;
 
-	delete guihandler;
-	guihandler = NULL;
+	SafeDelete(guihandler);
 
 #ifndef NO_AVI
-	if(creatingVideo){
-		creatingVideo=false;
-		delete aviGenerator;
-		aviGenerator = NULL;
+	if(creatingVideo) {
+		creatingVideo = false;
+		SafeDelete(aviGenerator);
 	}
 #endif
 
@@ -559,63 +561,62 @@
 	LuaOpenGL::Free();
 	heightMapTexture.Kill();
 
-	if (gameServer)delete gameServer;gameServer         = NULL;
+	SafeDelete(gameServer);
 
 	globalAI-&gt;PreDestroy ();
-	delete globalAI;           globalAI           = NULL;
+	SafeDelete(globalAI);
 
 	for(int a=0;a&lt;MAX_TEAMS;a++) {
-		delete grouphandlers[a]; grouphandlers[a] = NULL;
+		SafeDelete(grouphandlers[a]);
 	}
 
-	delete water;              water              = NULL;
-	delete sky;                sky                = NULL;
-	delete resourceBar;        resourceBar        = NULL;
+	SafeDelete(water);
+	SafeDelete(sky);
+	SafeDelete(resourceBar);
 
-	delete uh;                 uh                 = NULL;
-	delete unitDrawer;         unitDrawer         = NULL;
-	delete featureHandler;     featureHandler     = NULL;
-	delete geometricObjects;   geometricObjects   = NULL;
-	delete ph;                 ph                 = NULL;
-	delete minimap;            minimap            = NULL;
-	delete pathManager;        pathManager        = NULL;
-	delete groundDecals;       groundDecals       = NULL;
-	delete ground;             ground             = NULL;
-	delete luaInputReceiver;   luaInputReceiver   = NULL;
-	delete inMapDrawer;        inMapDrawer        = NULL;
-	delete net;                net                = NULL;
-	delete radarhandler;       radarhandler       = NULL;
-	delete loshandler;         loshandler         = NULL;
-	delete mapDamage;          mapDamage          = NULL;
-	delete qf;                 qf                 = NULL;
-	delete tooltip;            tooltip            = NULL;
-	delete keyBindings;        keyBindings        = NULL;
-	delete keyCodes;           keyCodes           = NULL;
-	delete sound;              sound              = NULL;
-	delete selectionKeys;      selectionKeys      = NULL;
-	delete mouse;              mouse              = NULL;
-	delete camHandler;         camHandler         = NULL;
-	delete helper;             helper             = NULL;
-	delete shadowHandler;      shadowHandler      = NULL;
-	delete moveinfo;           moveinfo           = NULL;
-	delete unitDefHandler;     unitDefHandler     = NULL;
-	delete damageArrayHandler; damageArrayHandler = NULL;
-	delete vfsHandler;         vfsHandler         = NULL;
-	delete archiveScanner;     archiveScanner     = NULL;
-	delete modelParser;        modelParser        = NULL;
-	delete iconHandler;        iconHandler        = NULL;
-	delete fartextureHandler;  fartextureHandler  = NULL;
-	delete camera;             camera             = NULL;
-	delete cam2;               cam2               = NULL;
-	delete infoConsole;        infoConsole        = NULL;
-	delete consoleHistory;     consoleHistory     = NULL;
-	delete wordCompletion;     wordCompletion     = NULL;
-	delete explGenHandler;     explGenHandler     = NULL;
+	SafeDelete(uh);
+	SafeDelete(unitDrawer);
+	SafeDelete(featureHandler);
+	SafeDelete(geometricObjects);
+	SafeDelete(ph);
+	SafeDelete(minimap);
+	SafeDelete(pathManager);
+	SafeDelete(groundDecals);
+	SafeDelete(ground);
+	SafeDelete(luaInputReceiver);
+	SafeDelete(inMapDrawer);
+	SafeDelete(net);
+	SafeDelete(radarhandler);
+	SafeDelete(loshandler);
+	SafeDelete(mapDamage);
+	SafeDelete(qf);
+	SafeDelete(tooltip);
+	SafeDelete(keyBindings);
+	SafeDelete(keyCodes);
+	SafeDelete(sound);
+	SafeDelete(selectionKeys);
+	SafeDelete(mouse);
+	SafeDelete(camHandler);
+	SafeDelete(helper);
+	SafeDelete(shadowHandler);
+	SafeDelete(moveinfo);
+	SafeDelete(unitDefHandler);
+	SafeDelete(damageArrayHandler);
+	SafeDelete(vfsHandler);
+	SafeDelete(archiveScanner);
+	SafeDelete(modelParser);
+	SafeDelete(iconHandler);
+	SafeDelete(fartextureHandler);
+	SafeDelete(camera);
+	SafeDelete(cam2);
+	SafeDelete(infoConsole);
+	SafeDelete(consoleHistory);
+	SafeDelete(wordCompletion);
+	SafeDelete(explGenHandler);
 
 	delete const_cast&lt;CMapInfo*&gt;(mapInfo);
 	mapInfo = NULL;
-	delete groundBlockingObjectMap;
-	groundBlockingObjectMap = NULL;
+	SafeDelete(groundBlockingObjectMap);
 
 	CCategoryHandler::RemoveInstance();
 	CColorMap::DeleteColormaps();
@@ -842,7 +843,8 @@
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
-		if ((*ri) &amp;&amp; (*ri)-&gt;KeyPressed(k, isRepeat)) {
+		CInputReceiver* recv=*ri;
+		if (recv &amp;&amp; recv-&gt;KeyPressed(k, isRepeat)) {
 			return 0;
 		}
 	}
@@ -871,7 +873,8 @@
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
-		if ((*ri) &amp;&amp; (*ri)-&gt;KeyReleased(k)) {
+		CInputReceiver* recv=*ri;
+		if (recv &amp;&amp; recv-&gt;KeyReleased(k)) {
 			return 0;
 		}
 	}
@@ -1035,6 +1038,8 @@
 		mouse-&gt;MousePress (mouse-&gt;lastx, mouse-&gt;lasty, 5);
 	}
 	else if (cmd == &quot;viewselection&quot;) {
+		GML_RECMUTEX_LOCK(sel); // ActionPressed
+
 		const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 		if (!selUnits.empty()) {
 			float3 pos(0.0f, 0.0f, 0.0f);
@@ -1323,6 +1328,60 @@
 			sky-&gt;dynamicSky = !!atoi(action.extra.c_str());
 		}
 	}
+#ifdef USE_GML
+	else if (cmd == &quot;multithreaddrawground&quot;) {
+		if (action.extra.empty()) {
+			gd-&gt;multiThreadDrawGround = !gd-&gt;multiThreadDrawGround;
+		} else {
+			gd-&gt;multiThreadDrawGround = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithreaddrawgroundshadow&quot;) {
+		if (action.extra.empty()) {
+			gd-&gt;multiThreadDrawGroundShadow = !gd-&gt;multiThreadDrawGroundShadow;
+		} else {
+			gd-&gt;multiThreadDrawGroundShadow = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithreaddrawunit&quot;) {
+		if (action.extra.empty()) {
+			unitDrawer-&gt;multiThreadDrawUnit = !unitDrawer-&gt;multiThreadDrawUnit;
+		} else {
+			unitDrawer-&gt;multiThreadDrawUnit = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithreaddrawunitshadow&quot;) {
+		if (action.extra.empty()) {
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !unitDrawer-&gt;multiThreadDrawUnitShadow;
+		} else {
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !!atoi(action.extra.c_str());
+		}
+	}
+	else if (cmd == &quot;multithread&quot;) {
+		if (action.extra.empty()) {
+			int mtenabled=gd-&gt;multiThreadDrawGround + unitDrawer-&gt;multiThreadDrawUnit + unitDrawer-&gt;multiThreadDrawUnitShadow &gt; 1;
+			gd-&gt;multiThreadDrawGround = !mtenabled;
+			unitDrawer-&gt;multiThreadDrawUnit = !mtenabled;
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !mtenabled;
+		} else {
+			gd-&gt;multiThreadDrawGround = !!atoi(action.extra.c_str());
+			unitDrawer-&gt;multiThreadDrawUnit = !!atoi(action.extra.c_str());
+			unitDrawer-&gt;multiThreadDrawUnitShadow = !!atoi(action.extra.c_str());
+		}
+	}
+#endif
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	else if (cmd == &quot;multithreadsim&quot;) {
+		extern volatile int multiThreadSim;
+		extern volatile int startsim;
+		if (action.extra.empty()) {
+			multiThreadSim = !multiThreadSim;
+		} else {
+			multiThreadSim = !!atoi(action.extra.c_str());
+		}
+		startsim=1;
+	}
+#endif
 	else if (!isRepeat &amp;&amp; (cmd == &quot;gameinfo&quot;)) {
 		if (!CGameInfo::IsActive()) {
 			CGameInfo::Enable();
@@ -2401,8 +2460,6 @@
 {
 	good_fpu_control_registers(&quot;CGame::Update&quot;);
 
-	mouse-&gt;EmptyMsgQueUpdate();
-
 	unsigned timeNow = SDL_GetTicks();
 
 	const unsigned difTime = (timeNow - lastModGameTimeMeasure);
@@ -2441,12 +2498,10 @@
 		tracefile.DeleteInterval();
 		tracefile.NewInterval();
 #endif
-		CInputReceiver::CollectGarbage();
 	}
 
-	if (!skipping) {
-		UpdateUI();
-	}
+	if (!skipping)
+		UpdateUI(false);
 
 	net-&gt;Update();
 
@@ -2481,7 +2536,7 @@
 		infoConsole-&gt;GetNewRawLines(lines);
 		for (unsigned int i = 0; i &lt; lines.size(); i++) {
 			const CInfoConsole::RawLine&amp; rawLine = lines[i];
-			eventHandler.AddConsoleLine(rawLine.text, rawLine.zone);
+			eventHandler.AddConsoleLine(rawLine.text, *rawLine.subsystem);
 		}
 	}
 
@@ -2514,13 +2569,16 @@
 	if (drawSky) {
 		sky-&gt;Draw();
 	}
+
 	if (drawGround) {
 		{
 		SCOPED_TIMER(&quot;ExtraTexture&quot;);
 		gd-&gt;UpdateExtraTexture();
 		}
 		gd-&gt;Draw();
+		treeDrawer-&gt;DrawGrass();
 	}
+
 	if (drawWater) {
 		if (!mapInfo-&gt;map.voidWater &amp;&amp; water-&gt;drawSolid) {
 			water-&gt;Draw();
@@ -2530,6 +2588,10 @@
 	selectedUnits.Draw();
 	eventHandler.DrawWorldPreUnit();
 
+	if (drawGround) {
+		gd-&gt;DrawTrees();
+	}
+
 	unitDrawer-&gt;Draw(false);
 	featureHandler-&gt;Draw();
 
@@ -2541,11 +2603,6 @@
 	glEnable(GL_BLEND);
 	glDepthFunc(GL_LEQUAL);
 
-	if (drawGround) {
-		if (treeDrawer-&gt;drawTrees) {
-			treeDrawer-&gt;DrawGrass();
-		}
-	}
 	if (drawWater) {
 		if (!mapInfo-&gt;map.voidWater &amp;&amp; !water-&gt;drawSolid) {
 			water-&gt;Draw();
@@ -2646,6 +2703,18 @@
 bool CGame::Draw() {
 #endif
 
+	mouse-&gt;EmptyMsgQueUpdate();
+
+	if(lastSimFrame!=gs-&gt;frameNum) {
+		CInputReceiver::CollectGarbage();
+		if(!skipping)
+			water-&gt;Update();
+		lastSimFrame=gs-&gt;frameNum;
+	}
+
+	if(!skipping)
+		UpdateUI(true);
+
 	thisFps++;
 
 	ASSERT_UNSYNCED_MODE;
@@ -2691,9 +2760,9 @@
 
 //	logOutput &lt;&lt; mouse-&gt;lastx &lt;&lt; &quot;\n&quot;;
 	if(!gs-&gt;paused &amp;&amp; !HasLag() &amp;&amp; gs-&gt;frameNum&gt;1 &amp;&amp; !creatingVideo){
-		unsigned startDraw = SDL_GetTicks();
-		gu-&gt;timeOffset = ((float)(startDraw - lastUpdate) * 0.001f)
-		                 * (float)(GAME_SPEED * gs-&gt;speedFactor);
+		gu-&gt;lastFrameStart = SDL_GetTicks();
+		gu-&gt;weightedSpeedFactor = 0.001f * GAME_SPEED * gs-&gt;speedFactor;
+		gu-&gt;timeOffset = (float)(gu-&gt;lastFrameStart - lastUpdate) * gu-&gt;weightedSpeedFactor;
 	} else  {
 		gu-&gt;timeOffset=0;
 		lastUpdate = SDL_GetTicks();
@@ -2995,7 +3064,7 @@
 	const float cw = fontScale * font-&gt;CalcCharWidth(c);
 	const float csx = inputTextPosX + (fontScale * caretWidth);
 	glDisable(GL_TEXTURE_2D);
-	const float f = 0.5f * (1.0f + streflop::sin((float)SDL_GetTicks() * 0.015f));
+	const float f = 0.5f * (1.0f + fastmath::sin((float)SDL_GetTicks() * 0.015f));
 	glColor4f(f, f, f, 0.75f);
 	glRectf(csx, inputTextPosY, csx + cw, inputTextPosY + font-&gt;GetHeight() * fontScale);
 	glEnable(GL_TEXTURE_2D);
@@ -3154,7 +3223,6 @@
 			}
 		}
 #endif
-		water-&gt;Update();
 	}
 
 	ENTER_SYNCED;
@@ -3751,7 +3819,7 @@
 				}
 				const int script = *reinterpret_cast&lt;const unsigned short*&gt;(inbuf+4);
 				const int mode = inbuf[6];
-				const int msglen = *((short*)(inbuf + 1)) - 7;
+				const int msglen = *((short*)(inbuf + 1)) - 8;
 				const string msg((char*)&amp;inbuf[7], msglen); // allow embedded 0's
 				CLuaHandle::HandleLuaMsg(player, script, mode, msg);
 				AddTraffic(player, packetCode, dataLength);
@@ -4029,13 +4097,17 @@
 	return;
 }
 
+#ifdef DIRECT_CONTROL_ALLOWED
+float3 lastDCpos;
+float3 *plastDCpos=NULL;
+#endif
 
-void CGame::UpdateUI()
+void CGame::UpdateUI(bool cam)
 {
 	ASSERT_UNSYNCED_MODE;
 	//move camera if arrow keys pressed
 #ifdef DIRECT_CONTROL_ALLOWED
-	if (gu-&gt;directControl) {
+	if (gu-&gt;directControl &amp;&amp; !cam) {
 		CUnit* owner = gu-&gt;directControl;
 
 		std::vector&lt;int&gt; args;
@@ -4043,12 +4115,22 @@
 		owner-&gt;cob-&gt;Call(COBFN_AimFromPrimary/*/COBFN_QueryPrimary+weaponNum/ **/,args);
 		float3 relPos = owner-&gt;localmodel-&gt;GetPiecePos(args[0]);
 		float3 pos = owner-&gt;pos + owner-&gt;frontdir * relPos.z
-		                        + owner-&gt;updir    * relPos.y
-		                        + owner-&gt;rightdir * relPos.x;
+			+ owner-&gt;updir    * relPos.y
+			+ owner-&gt;rightdir * relPos.x;
 		pos += UpVector * 7;
-
-		camHandler-&gt;GetCurrentController().SetPos(pos);
-	} else
+		//camHandler-&gt;GetCurrentController().SetPos(pos); // in case of multithreading, avoid setting the cam from sim thread
+		GML_STDMUTEX_LOCK(pos); // UpdateUI
+		lastDCpos=pos;
+		plastDCpos=&lastDCpos;
+	}
+	if (plastDCpos &amp;&amp; cam) {
+		GML_STDMUTEX_LOCK(pos); // UpdateUI
+		if(plastDCpos) {
+			camHandler-&gt;GetCurrentController().SetPos(*plastDCpos);
+			plastDCpos=NULL;
+		}
+	}
+	if (!gu-&gt;directControl)
 #endif
 	{
 		float cameraSpeed=1;
@@ -4078,73 +4160,82 @@
 			disableTracker = true;
 		}
 
-		if (disableTracker &amp;&amp; camHandler-&gt;GetCurrentController().DisableTrackingByKey()) {
+		if (!cam &amp;&amp; disableTracker &amp;&amp; camHandler-&gt;GetCurrentController().DisableTrackingByKey()) {
 			unitTracker.Disable();
 		}
-		movement.z = cameraSpeed;
-		camHandler-&gt;GetCurrentController().KeyMove(movement);
-
+		if(cam) {
+			movement.z = cameraSpeed;
+			camHandler-&gt;GetCurrentController().KeyMove(movement);
+		}
 		movement=float3(0,0,0);
 
 		if (( fullscreen &amp;&amp; fullscreenEdgeMove) ||
 		    (!fullscreen &amp;&amp; windowedEdgeMove)) {
 			int screenW = gu-&gt;dualScreenMode ? gu-&gt;viewSizeX*2 : gu-&gt;viewSizeX;
+			disableTracker = false;
 			if (mouse-&gt;lasty &lt; 2){
 				movement.y+=gu-&gt;lastFrameTime;
-				unitTracker.Disable();
+				disableTracker = true;
 			}
 			if (mouse-&gt;lasty &gt; (gu-&gt;viewSizeY - 2)){
 				movement.y-=gu-&gt;lastFrameTime;
-				unitTracker.Disable();
+				disableTracker = true;
 			}
 			if (mouse-&gt;lastx &gt; (screenW - 2)){
 				movement.x+=gu-&gt;lastFrameTime;
-				unitTracker.Disable();
+				disableTracker = true;
 			}
 			if (mouse-&gt;lastx &lt; 2){
 				movement.x-=gu-&gt;lastFrameTime;
+				disableTracker = true;
+			}
+			if (!cam &amp;&amp; disableTracker) {
 				unitTracker.Disable();
 			}
 		}
-		movement.z=cameraSpeed;
-		camHandler-&gt;GetCurrentController().ScreenEdgeMove(movement);
-
-		if(camMove[4])
-			camHandler-&gt;GetCurrentController().MouseWheelMove(gu-&gt;lastFrameTime*200*cameraSpeed);
-		if(camMove[5])
-			camHandler-&gt;GetCurrentController().MouseWheelMove(-gu-&gt;lastFrameTime*200*cameraSpeed);
+		if(cam) {
+			movement.z=cameraSpeed;
+			camHandler-&gt;GetCurrentController().ScreenEdgeMove(movement);
+			if(camMove[4])
+				camHandler-&gt;GetCurrentController().MouseWheelMove(gu-&gt;lastFrameTime*200*cameraSpeed);
+			if(camMove[5])
+				camHandler-&gt;GetCurrentController().MouseWheelMove(-gu-&gt;lastFrameTime*200*cameraSpeed);
+		}
 	}
 
-	camHandler-&gt;GetCurrentController().Update();
+	if(cam)
+		camHandler-&gt;GetCurrentController().Update();
 
-	if (chatting &amp;&amp; !userWriting) {
-		consoleHistory-&gt;AddLine(userInput);
-		string msg = userInput;
-		string pfx = &quot;&quot;;
-		if ((userInput.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (userInput[1] == ':')) {
-			pfx = userInput.substr(0, 2);
-			msg = userInput.substr(2);
+	if(!cam) {
+		if (chatting &amp;&amp; !userWriting) {
+			consoleHistory-&gt;AddLine(userInput);
+			string msg = userInput;
+			string pfx = &quot;&quot;;
+			if ((userInput.find_first_of(&quot;aAsS&quot;) == 0) &amp;&amp; (userInput[1] == ':')) {
+				pfx = userInput.substr(0, 2);
+				msg = userInput.substr(2);
+			}
+			if ((msg[0] == '/') &amp;&amp; (msg[1] == '/')) {
+				msg = msg.substr(1);
+			}
+			userInput = pfx + msg;
+			SendNetChat(userInput);
+			chatting=false;
+			userInput=&quot;&quot;;
+			writingPos = 0;
 		}
-		if ((msg[0] == '/') &amp;&amp; (msg[1] == '/')) {
-			msg = msg.substr(1);
-		}
-		userInput = pfx + msg;
-		SendNetChat(userInput);
-		chatting=false;
-		userInput=&quot;&quot;;
-		writingPos = 0;
-	}
 
-	if (inMapDrawer-&gt;wantLabel &amp;&amp; !userWriting) {
-		if (userInput.size() &gt; 200) {	//avoid troubles with to long lines
-			userInput = userInput.substr(0, 200);
-			writingPos = (int)userInput.length();
+		if (inMapDrawer-&gt;wantLabel &amp;&amp; !userWriting) {
+			if (userInput.size() &gt; 200) {	//avoid troubles with to long lines
+				userInput = userInput.substr(0, 200);
+				writingPos = (int)userInput.length();
+			}
+			inMapDrawer-&gt;SendPoint(inMapDrawer-&gt;waitingPoint, userInput);
+			inMapDrawer-&gt;wantLabel = false;
+			userInput = &quot;&quot;;
+			writingPos = 0;
+			ignoreChar = 0;
 		}
-		inMapDrawer-&gt;SendPoint(inMapDrawer-&gt;waitingPoint, userInput);
-		inMapDrawer-&gt;wantLabel = false;
-		userInput = &quot;&quot;;
-		writingPos = 0;
-		ignoreChar = 0;
 	}
 }
 
@@ -4235,7 +4326,7 @@
 			             float3(camera-&gt;right.z, camera-&gt;up.z, camera-&gt;forward.z));
 			glMultMatrixf(m.m);
 		}
-		glTranslatef3(-unit-&gt;pos - (unit-&gt;speed * gu-&gt;timeOffset));
+		glTranslatef3(-unit-&gt;drawPos);
 		glDisable(GL_BLEND);
 		unit-&gt;currentLOD = 0;
 		unitDrawer-&gt;DrawIndividual(unit); // draw the unit
@@ -4355,7 +4446,7 @@
 
 			glBegin(GL_LINE_STRIP);
 			for(int b=0;b&lt;=80;++b){
-				glVertexf3(pos+(v2*streflop::sin(b*2*PI/80)+v3*streflop::cos(b*2*PI/80))*radius);
+				glVertexf3(pos+(v2*fastmath::sin(b*2*PI/80)+v3*fastmath::cos(b*2*PI/80))*radius);
 			}
 			glEnd();
 
@@ -4369,7 +4460,7 @@
 
 				glBegin(GL_LINE_STRIP);
 				for(int b=0;b&lt;=80;++b){
-					glVertexf3(pos+(v2*streflop::sin(b*2*PI/80)+v3*streflop::cos(b*2*PI/80))*radius);
+					glVertexf3(pos+(v2*fastmath::sin(b*2*PI/80)+v3*fastmath::cos(b*2*PI/80))*radius);
 				}
 				glEnd();
 			}
@@ -4378,11 +4469,11 @@
 				glVertexf3(pos);
 				glVertexf3(w-&gt;targetPos);
 
-				glVertexf3(pos+(v2*streflop::sin(PI*0.25f)+v3*streflop::cos(PI*0.25f))*radius);
-				glVertexf3(pos+(v2*streflop::sin(PI*1.25f)+v3*streflop::cos(PI*1.25f))*radius);
+				glVertexf3(pos+(v2*fastmath::sin(PI*0.25f)+v3*fastmath::cos(PI*0.25f))*radius);
+				glVertexf3(pos+(v2*fastmath::sin(PI*1.25f)+v3*fastmath::cos(PI*1.25f))*radius);
 
-				glVertexf3(pos+(v2*streflop::sin(PI*-0.25f)+v3*streflop::cos(PI*-0.25f))*radius);
-				glVertexf3(pos+(v2*streflop::sin(PI*-1.25f)+v3*streflop::cos(PI*-1.25f))*radius);
+				glVertexf3(pos+(v2*fastmath::sin(PI*-0.25f)+v3*fastmath::cos(PI*-0.25f))*radius);
+				glVertexf3(pos+(v2*fastmath::sin(PI*-1.25f)+v3*fastmath::cos(PI*-1.25f))*radius);
 			}
 			if((w-&gt;targetPos-camera-&gt;pos).ANormalize().dot(camera-&gt;forward)&lt;0.7f){
 				glVertexf3(w-&gt;targetPos);
@@ -4696,6 +4787,8 @@
 	static set&lt;int&gt; unitIDs;
 	static int lastID = -1;
 
+	GML_RECMUTEX_LOCK(sel); // SelectCycle
+
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 
 	if (command == &quot;restore&quot;) {

Modified: branches/caiinterface/rts/Game/Game.h
===================================================================
--- branches/caiinterface/rts/Game/Game.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/Game.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -71,6 +71,8 @@
 	unsigned int fps;
 	unsigned int thisFps;
 
+	int lastSimFrame;
+
 	time_t fpstimer, starttime;
 	unsigned lastUpdate;
 	unsigned lastMoveUpdate;
@@ -181,7 +183,7 @@
 
 private:
 	void ClientReadNet();
-	void UpdateUI();
+	void UpdateUI(bool cam);
 	bool DrawWorld();
 	
 	void SimFrame();

Modified: branches/caiinterface/rts/Game/GameData.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameData.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameData.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,12 +19,8 @@
 
 GameData::GameData(boost::shared_ptr&lt;const RawPacket&gt; pckt)
 {
-	UnpackPacket packet(pckt);
-	unsigned char ID;
-	unsigned short length;
-	packet &gt;&gt; ID;
-	assert(ID == NETMSG_GAMEDATA);
-	packet &gt;&gt; length;
+	assert(pckt-&gt;data[0] == NETMSG_GAMEDATA);
+	UnpackPacket packet(pckt, 3);
 	packet &gt;&gt; script;
 	packet &gt;&gt; map;
 	packet &gt;&gt; mapChecksum;
@@ -36,8 +32,7 @@
 const netcode::RawPacket* GameData::Pack() const
 {
 	unsigned short size = 3 + 2*sizeof(unsigned) + map.size() + mod.size() + script.size() + 4 + 3;
-	PackPacket* buffer = new PackPacket(size);
-	*buffer &lt;&lt; (unsigned char)NETMSG_GAMEDATA;
+	PackPacket* buffer = new PackPacket(size, NETMSG_GAMEDATA);
 	*buffer &lt;&lt; size;
 	*buffer &lt;&lt; script;
 	*buffer &lt;&lt; map;

Modified: branches/caiinterface/rts/Game/GameHelper.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameHelper.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -38,6 +38,7 @@
 #include &quot;Sound.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
 #include &quot;System/EventHandler.h&quot;
+#include &quot;System/myMath.h&quot;
 
 //////////////////////////////////////////////////////////////////////
 // Construction/Destruction
@@ -67,9 +68,102 @@
 }
 
 
-void CGameHelper::Explosion(float3 pos, const DamageArray&amp; damages,
-                            float radius, float edgeEffectiveness,
-                            float explosionSpeed, CUnit* owner,
+
+void CGameHelper::DoExplosionDamage(CUnit* unit,
+	const float3&amp; expPos, float expRad, float expSpeed,
+	bool ignoreOwner, CUnit* owner, float edgeEffectiveness,
+	const DamageArray&amp; damages, int weaponId)
+{
+	if (ignoreOwner &amp;&amp; (unit == owner)) {
+		return;
+	}
+
+	// dist is equal to the maximum of &quot;distance from center
+	// of unit to center of explosion&quot; and &quot;unit radius + 0.1&quot;,
+	// where &quot;center of unit&quot; is determined by the relative
+	// position of its collision volume and &quot;unit radius&quot; by
+	// the volume's minimally-bounding sphere
+	//
+	float3 dif = (unit-&gt;midPos + unit-&gt;collisionVolume-&gt;axisOffsets) - expPos;
+	float expDist = dif.Length();
+	const float volRad = unit-&gt;collisionVolume-&gt;volumeBoundingRadius;
+
+	expDist = std::max(expDist, volRad + 0.1f);
+
+	// expDist2 is the distance from the boundary of the
+	// _volume's_ minimally-bounding sphere (!) to the
+	// explosion center, unless unit-&gt;isUnderWater and
+	// the explosion is above water: then center2center
+	// distance is used
+	//
+	// NOTE #1: this will be only an approximation when
+	// the unit's collision volume is not a sphere, but
+	// a better one than when using unit-&gt;radius
+	//
+	// NOTE #2: if an explosion occurs right underneath
+	// a unit's map footprint, it can cause damage even
+	// if the unit's collision volume is greatly offset
+	// (because CQuadField is again based exclusively on
+	// unit-&gt;radius, so the iteration will include units
+	// that should not be touched)
+	float expDist2 = expDist - volRad;
+
+	if (unit-&gt;isUnderWater &amp;&amp; (expPos.y &gt; -1.0f)) {
+		// should make it harder to damage subs with above-water weapons
+		expDist2 += volRad;
+		expDist2 = std::min(expDist2, expRad);
+	}
+
+	// Clamp expDist to radius to prevent division by zero
+	// (expDist2 can never be &gt; radius). We still need the
+	// original expDist later to normalize dif.
+	float expDist1 = std::min(expDist, expRad);
+	float mod  = (expRad - expDist1) / (expRad - expDist1 * edgeEffectiveness);
+	float mod2 = (expRad - expDist2) / (expRad - expDist2 * edgeEffectiveness);
+	dif /= expDist;
+	dif.y += 0.12f;
+
+	DamageArray damageDone = damages * mod2;
+	float3 addedImpulse = dif * (damages.impulseFactor * mod * (damages[0] + damages.impulseBoost) * 3.2f);
+
+	if (expDist2 &lt; (expSpeed * 4.0f)) { //damage directly
+		unit-&gt;DoDamage(damageDone, owner, addedImpulse, weaponId);
+	} else { //damage later
+		WaitingDamage* wd = SAFE_NEW WaitingDamage((owner? owner-&gt;id: -1), unit-&gt;id, damageDone, addedImpulse, weaponId);
+		waitingDamages[(gs-&gt;frameNum + int(expDist2 / expSpeed) - 3) &amp; 127].push_front(wd);
+	}
+}
+
+void CGameHelper::DoExplosionDamage(CFeature* feature,
+	const float3&amp; expPos, float expRad, CUnit* owner, const DamageArray&amp; damages)
+{
+	CollisionVolume* cv = feature-&gt;collisionVolume;
+
+	if (cv) {
+		float3 dif = (feature-&gt;midPos + cv-&gt;axisOffsets) - expPos;
+		float expDist = std::max(dif.Length(), 0.1f);
+		float expMod = (expRad - expDist) / expRad;
+
+		// always do some damage with explosive stuff
+		// (DDM wreckage etc. is too big to normally
+		// be damaged otherwise, even by BB shells)
+		// NOTE: this will also be only approximate
+		// for non-spherical volumes
+		if ((expRad &gt; 8.0f) &amp;&amp; (expDist &lt; (cv-&gt;volumeBoundingRadius * 1.1f)) &amp;&amp; (expMod &lt; 0.1f)) {
+			expMod = 0.1f;
+		}
+		if (expMod &gt; 0.0f) {
+			feature-&gt;DoDamage(damages * expMod, owner,
+				dif * (damages.impulseFactor * expMod / expDist *
+				(damages[0] + damages.impulseBoost)));
+		}
+	}
+}
+
+
+void CGameHelper::Explosion(float3 expPos, const DamageArray&amp; damages,
+                            float expRad, float edgeEffectiveness,
+                            float expSpeed, CUnit* owner,
                             bool damageGround, float gfxMod, bool ignoreOwner,
                             CExplosionGenerator* explosionGraphics, CUnit* hit,
                             const float3&amp; impactDir, int weaponId)
@@ -79,112 +173,65 @@
 			WeaponDef&amp; wd = weaponDefHandler-&gt;weaponDefs[weaponId];
 			const float cameraShake = wd.cameraShake;
 			if (cameraShake &gt; 0.0f) {
-				luaUI-&gt;ShockFront(cameraShake, pos, radius);
+				luaUI-&gt;ShockFront(cameraShake, expPos, expRad);
 			}
 		}
 	}
-	bool noGfx = eventHandler.Explosion(weaponId, pos, owner);
 
+	bool noGfx = eventHandler.Explosion(weaponId, expPos, owner);
+
 #ifdef TRACE_SYNC
 	tracefile &lt;&lt; &quot;Explosion: &quot;;
-	tracefile &lt;&lt; pos.x &lt;&lt; &quot; &quot; &lt;&lt; damages[0] &lt;&lt;  &quot; &quot; &lt;&lt; radius &lt;&lt; &quot;\n&quot;;
+	tracefile &lt;&lt; expPos.x &lt;&lt; &quot; &quot; &lt;&lt; damages[0] &lt;&lt;  &quot; &quot; &lt;&lt; expRad &lt;&lt; &quot;\n&quot;;
 #endif
-/*	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
-		logOutput.Print(&quot;Explosion outside map %.0f %.0f&quot;,pos.x,pos.z);
-		return;
-	}
-*/
-//	logOutput.Print(&quot;Explosion %i&quot;,damageGround);
-	if (radius &lt; 1.0f) {
-		radius = 1.0f;
-	}
 
-	float h2 = ground-&gt;GetHeight2(pos.x, pos.z);
-	if (pos.y &lt; h2) {
-		pos.y = h2;
-	}
+	float h2 = ground-&gt;GetHeight2(expPos.x, expPos.z);
+	expPos.y = std::max(expPos.y, h2);
+	expRad = std::max(expRad, 1.0f);
+	float height = std::max(expPos.y - h2, 0.0f);
 
-	float height = pos.y - h2;
-	if (height &lt; 0.0f) {
-		height = 0.0f;
-	}
 
-	vector&lt;CUnit*&gt; units = qf-&gt;GetUnitsExact(pos, radius);
-	//float gd=max(30.f,damages[0]/20);
-	//float explosionSpeed=(8+gd*2.5f)/(9+sqrtf(gd)*0.7f)*0.5f;	//this is taken from the explosion graphics and could probably be simplified a lot
+	// damage all units within the explosion radius
+	vector&lt;CUnit*&gt; units = qf-&gt;GetUnitsExact(expPos, expRad);
+	vector&lt;CUnit*&gt;::iterator ui;
+	bool hitUnitDamaged = false;
 
-	// Damage Units
-	for (vector&lt;CUnit*&gt;::iterator ui = units.begin(); ui != units.end(); ++ui) {
+	for (ui = units.begin(); ui != units.end(); ++ui) {
 		CUnit* unit = *ui;
-		if (ignoreOwner &amp;&amp; (unit == owner)) {
-			continue;
+
+		if (unit == hit) {
+			hitUnitDamaged = true;
 		}
-		// dist = max(distance from center of unit to center of explosion, unit-&gt;radius+0.1)
-		float3 dif = unit-&gt;midPos - pos;
-		float dist = dif.Length();
-		const float fudgeRad = unit-&gt;radius + 0.1f;
-		if (dist &lt; fudgeRad) {
-			dist = fudgeRad;
-		}
-		// dist2 = distance from boundary of unit's hitsphere to center of explosion,
-		// unless unit-&gt;isUnderWater and explosion is above water: then it's center to center distance
-		float dist2 = dist - unit-&gt;radius;
-		if (unit-&gt;isUnderWater &amp;&amp; (pos.y &gt; -1.0f)) {	//should make it harder to damage subs with above water weapons
-			dist2 += unit-&gt;radius;
-			if (dist2 &gt; radius) {
-				dist2 = radius;
-			}
-		}
-		// Clamp dist to radius to prevent division by zero. (dist2 can never be &gt; radius)
-		// We still need the original dist later to normalize dif.
-		float dist1 = dist;
-		if (dist1 &gt; radius) {
-			dist1 = radius;
-		}
-		float mod =(radius-dist1)/(radius-dist1*edgeEffectiveness);
-		float mod2=(radius-dist2)/(radius-dist2*edgeEffectiveness);
-		dif /= dist; // dist &gt; unit-&gt;radius+0.1f, see above
-		dif.y += 0.12f;
 
-		DamageArray damageDone = damages*mod2;
-		float3 addedImpulse = dif * (damages.impulseFactor * mod * (damages[0] + damages.impulseBoost) * 3.2f);
+		DoExplosionDamage(unit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
+	}
 
-		if (dist2 &lt; (explosionSpeed * 4.0f)) { //damage directly
-			unit-&gt;DoDamage(damageDone,owner,addedImpulse, weaponId);
-		} else { //damage later
-			WaitingDamage* wd = SAFE_NEW WaitingDamage(owner ? owner-&gt;id : -1, unit-&gt;id, damageDone, addedImpulse, weaponId);
-			waitingDamages[(gs-&gt;frameNum+int(dist2/explosionSpeed)-3)&amp;127].push_front(wd);
-		}
+	// HACK: for a unit with an offset coldet volume, the explosion
+	// (from an impacting projectile) position might not correspond
+	// to its quadfield position so we need to damage it separately
+	if (hit &amp;&amp; !hitUnitDamaged) {
+		DoExplosionDamage(hit, expPos, expRad, expSpeed, ignoreOwner, owner, edgeEffectiveness, damages, weaponId);
 	}
 
-	vector&lt;CFeature*&gt; features=qf-&gt;GetFeaturesExact(pos,radius);
+
+	// damage all features within the explosion radius
+	vector&lt;CFeature*&gt; features = qf-&gt;GetFeaturesExact(expPos, expRad);
 	vector&lt;CFeature*&gt;::iterator fi;
+
 	for (fi = features.begin(); fi != features.end(); ++fi) {
 		CFeature* feature = *fi;
-		float3 dif= feature-&gt;midPos -pos;
-		float dist = dif.Length();
-		if (dist &lt; 0.1f) {
-			dist = 0.1f;
-		}
-		float mod = (radius - dist) / radius;
-		// always do some damage with explosive stuff
-		// (ddm wreckage etc is to big to normally be damaged otherwise, even by bb shells)
-		if ((radius &gt; 8.0f) &amp;&amp; (dist &lt; (feature-&gt;radius * 1.1f)) &amp;&amp; (mod &lt; 0.1f)) {
-			mod = 0.1f;
-		}
-		if (mod &gt; 0.0f) {
-			feature-&gt;DoDamage(damages * mod, owner,
-			                  dif * (damages.impulseFactor * mod / dist * (damages[0] + damages.impulseBoost)));
-		}
+
+		DoExplosionDamage(feature, expPos, expRad, owner, damages);
 	}
 
+	// deform the map
 	if (damageGround &amp;&amp; !mapDamage-&gt;disabled &amp;&amp;
-	    (radius &gt; height) &amp;&amp; (damages.craterMult &gt; 0.0f)) {
-		float damage = damages[0] * (1.0f - (height / radius));
-		if (damage &gt; (radius * 10.0f)) {
-			damage = radius * 10.0f;  // limit the depth somewhat
+	    (expRad &gt; height) &amp;&amp; (damages.craterMult &gt; 0.0f)) {
+		float damage = damages[0] * (1.0f - (height / expRad));
+		if (damage &gt; (expRad * 10.0f)) {
+			damage = expRad * 10.0f; // limit the depth somewhat
 		}
-		mapDamage-&gt;Explosion(pos,(damage + damages.craterBoost)*damages.craterMult,radius-height);
+		mapDamage-&gt;Explosion(expPos, (damage + damages.craterBoost) * damages.craterMult, expRad - height);
 	}
 
 	// use CStdExplosionGenerator by default
@@ -192,26 +239,30 @@
 		if (!explosionGraphics) {
 			explosionGraphics = stdExplosionGenerator;
 		}
-		explosionGraphics-&gt;Explosion(pos, damages[0], radius, owner, gfxMod, hit, impactDir);
+		explosionGraphics-&gt;Explosion(expPos, damages[0], expRad, owner, gfxMod, hit, impactDir);
 	}
-	groundDecals-&gt;AddExplosion(pos, damages[0], radius);
-	// sound-&gt;PlaySample(explosionSounds[rand()*4/(RAND_MAX+1)],pos,damage*2);
+
+	groundDecals-&gt;AddExplosion(expPos, damages[0], expRad);
+
 	ENTER_UNSYNCED;
-	water-&gt;AddExplosion(pos,damages[0],radius);
+	water-&gt;AddExplosion(expPos, damages[0], expRad);
 	ENTER_SYNCED;
 }
 
 
-float CGameHelper::TraceRay(const float3 &amp;start, const float3 &amp;dir, float length, float power, CUnit* owner, CUnit *&amp;hit, int collisionFlags)
+// called by {CRifle, CBeamLaser, CLightingCannon}::Fire()
+float CGameHelper::TraceRay(const float3&amp; start, const float3&amp; dir, float length, float power, CUnit* owner, CUnit *&amp;hit, int collisionFlags)
 {
 	float groundLength = ground-&gt;LineGroundCol(start, start + dir * length);
 	const bool ignoreAllies = !!(collisionFlags &amp; COLLISION_NOFRIENDLY);
 	const bool ignoreFeatures = !!(collisionFlags &amp; COLLISION_NOFEATURE);
 	const bool ignoreNeutrals = !!(collisionFlags &amp; COLLISION_NONEUTRAL);
 
-	if (length &gt; groundLength &amp;&amp; groundLength &gt; 0)
+	if (length &gt; groundLength &amp;&amp; groundLength &gt; 0) {
 		length = groundLength;
+	}
 
+	CollisionQuery cq;
 
 	int quads[1000];
 	int* endQuad = quads;
@@ -222,21 +273,21 @@
 			const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 
 			for (std::list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
-				if (!(*ui)-&gt;blocking)
-					continue;
+				CFeature* f = *ui;
 
-				float3 dif = (*ui)-&gt;midPos - start;
-				float closeLength = dif.dot(dir);
-
-				if (closeLength &lt; 0)
+				if (!f-&gt;blocking || !f-&gt;collisionVolume) {
+					// NOTE: why check the blocking property?
 					continue;
-				if (closeLength &gt; length)
-					continue;
+				}
 
-				float3 closeVect = dif - dir * closeLength;
+				if (CCollisionHandler::Intersect(f, start, start + dir * length, &amp;cq)) {
+					const float3&amp; intPos = (cq.b0)? cq.p0: cq.p1;
+					const float tmpLen = (intPos - start).Length();
 
-				if (closeVect.SqLength() &lt; (*ui)-&gt;sqRadius) {
-					length = closeLength;
+					// we want the closest feature (intersection point) on the ray
+					if (tmpLen &lt; length) {
+						length = tmpLen;
+					}
 				}
 			}
 		}
@@ -258,20 +309,15 @@
 				continue;
 			}
 
-			float3 dif = u-&gt;midPos - start;
-			float closeLength = dif.dot(dir);
+			if (CCollisionHandler::Intersect(u, start, start + dir * length, &amp;cq)) {
+				const float3&amp; intPos = (cq.b0)? cq.p0: cq.p1;
+				const float tmpLen = (intPos - start).Length();
 
-			if (closeLength &lt; 0)
-				continue;
-			if (closeLength &gt; length)
-				closeLength = length;
-
-			float3 closeVect = dif - dir * closeLength;
-
-			// FIXME: deal with the new collision volumes
-			if (closeVect.SqLength() &lt; u-&gt;sqRadius) {
-				length = closeLength;
-				hit = u;
+				// we want the closest unit (intersection point) on the ray
+				if (tmpLen &lt; length) {
+					length = tmpLen;
+					hit = u;
+				}
 			}
 		}
 	}
@@ -279,11 +325,11 @@
 	return length;
 }
 
-float CGameHelper::GuiTraceRay(const float3 &amp;start, const float3 &amp;dir, float length, CUnit*&amp; hit, float _, bool useRadar, CUnit* exclude)
+float CGameHelper::GuiTraceRay(const float3 &amp;start, const float3 &amp;dir, float length, CUnit*&amp; hit, bool useRadar, CUnit* exclude)
 {
 	// distance from start to ground intersection point + fudge
-	float groundLen = ground-&gt;LineGroundCol(start, start + dir * length);
-	float returnLen = (groundLen &gt; 0.0f)? groundLen + 200.0f: length;
+	float groundLen   = ground-&gt;LineGroundCol(start, start + dir * length);
+	float returnLenSq = Square( (groundLen &gt; 0.0f)? groundLen + 200.0f: length );
 
 	hit = 0x0;
 	CollisionQuery cq;
@@ -322,10 +368,10 @@
 				if (CCollisionHandler::MouseHit(unit, start, start + dir * length, cv, &amp;cq)) {
 					// get the distance to the ray-volume egress point
 					// so we can still select stuff inside factories
-					const float len = (cq.p1 - start).Length();
+					const float len = (cq.p1 - start).SqLength();
 
-					if (len &lt; returnLen) {
-						returnLen = len;
+					if (len &lt; returnLenSq) {
+						returnLenSq = len;
 						hit = unit;
 					}
 				}
@@ -333,71 +379,90 @@
 		}
 	}
 
-	return ((hit)? returnLen: (returnLen - 200.0f));
+	return ((hit)? math::sqrt(returnLenSq): (math::sqrt(returnLenSq) - 200.0f));
 }
 
-float CGameHelper::TraceRayTeam(const float3&amp; start,const float3&amp; dir,float length, CUnit*&amp; hit,bool useRadar,CUnit* exclude,int allyteam)
+float CGameHelper::TraceRayTeam(const float3&amp; start, const float3&amp; dir, float length, CUnit*&amp; hit, bool useRadar, CUnit* exclude, int allyteam)
 {
-	float groundLength=ground-&gt;LineGroundCol(start,start+dir*length);
+	float groundLength = ground-&gt;LineGroundCol(start, start + dir * length);
 
-//	logOutput.Print(&quot;gl %f&quot;,groundLength);
-	if(length&gt;groundLength &amp;&amp; groundLength&gt;0)
-		length=groundLength;
+	if (length &gt; groundLength &amp;&amp; groundLength &gt; 0) {
+		length = groundLength;
+	}
 
-	vector&lt;int&gt; quads=qf-&gt;GetQuadsOnRay(start,dir,length);
+	vector&lt;int&gt; quads = qf-&gt;GetQuadsOnRay(start, dir, length);
+	hit = 0;
 
-//	float minLength=length;
-	hit=0;
-
 	vector&lt;int&gt;::iterator qi;
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		std::list&lt;CUnit*&gt;::const_iterator ui;
+
+		// NOTE: switch this to custom volumes fully? (only
+		// used in FPS unit control mode, maybe unnecessary)
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
-			if ((*ui)==exclude)
+			CUnit* u = *ui;
+
+			if (u == exclude)
 				continue;
-			if (gs-&gt;Ally((*ui)-&gt;allyteam,allyteam) || ((*ui)-&gt;losStatus[allyteam] &amp; LOS_INLOS)){
-				float3 dif=(*ui)-&gt;midPos-start;
-				float closeLength=dif.dot(dir);
-				if(closeLength&lt;0)
+
+			CollisionVolume* cv = u-&gt;collisionVolume;
+
+			if (gs-&gt;Ally(u-&gt;allyteam, allyteam) || (u-&gt;losStatus[allyteam] &amp; LOS_INLOS)) {
+				float3 dif = (u-&gt;midPos + cv-&gt;axisOffsets) - start;
+				float closeLength = dif.dot(dir);
+
+				if (closeLength &lt; 0)
 					continue;
-				if(closeLength&gt;length)
+				if (closeLength &gt; length)
 					continue;
-				float3 closeVect=dif-dir*closeLength;
-				if(closeVect.SqLength() &lt; (*ui)-&gt;sqRadius){
-					length=closeLength;
-					hit=*ui;
+
+				float3 closeVect = dif - dir * closeLength;
+
+				if (closeVect.SqLength() &lt; cv-&gt;volumeBoundingRadiusSq) {
+					length = closeLength;
+					hit = u;
 				}
-			} else if (useRadar &amp;&amp; radarhandler-&gt;InRadar(*ui,allyteam)){
-				float3 dif=(*ui)-&gt;midPos+(*ui)-&gt;posErrorVector*radarhandler-&gt;radarErrorSize[allyteam]-start;
-				float closeLength=dif.dot(dir);
-				if(closeLength&lt;0)
+			} else if (useRadar &amp;&amp; radarhandler-&gt;InRadar(u, allyteam)) {
+				float3 dif =
+					(u-&gt;midPos + cv-&gt;axisOffsets) +
+					u-&gt;posErrorVector * radarhandler-&gt;radarErrorSize[allyteam] -
+					start;
+				float closeLength = dif.dot(dir);
+
+				if (closeLength &lt; 0)
 					continue;
-				if(closeLength&gt;length)
+				if (closeLength &gt; length)
 					continue;
-				float3 closeVect=dif-dir*closeLength;
-				if(closeVect.SqLength() &lt; (*ui)-&gt;sqRadius){
-					length=closeLength;
-					hit=*ui;
+
+				float3 closeVect = dif - dir * closeLength;
+
+				if (closeVect.SqLength() &lt; cv-&gt;volumeBoundingRadiusSq) {
+					length = closeLength;
+					hit = u;
 				}
 			}
 		}
 	}
+
 	return length;
 }
 
 void CGameHelper::GenerateTargets(const CWeapon *weapon, CUnit* lastTarget,
                                   std::map&lt;float,CUnit*&gt; &amp;targets)
 {
+	GML_RECMUTEX_LOCK(qnum); // GenerateTargets
+
 	CUnit* attacker = weapon-&gt;owner;
 	float radius = weapon-&gt;range;
 	float3 pos = attacker-&gt;pos;
 	float heightMod = weapon-&gt;heightMod;
 	float aHeight = pos.y;
-	float secDamage = weapon-&gt;weaponDef-&gt;damages[0]*weapon-&gt;salvoSize/weapon-&gt;reloadTime*30;			//how much damage the weapon deal over 1 seconds
+	// how much damage the weapon deals over 1 second
+	float secDamage = weapon-&gt;weaponDef-&gt;damages[0] * weapon-&gt;salvoSize / weapon-&gt;reloadTime * 30;
 	bool paralyzer = !!weapon-&gt;weaponDef-&gt;damages.paralyzeDamageTime;
 
-	std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos,radius+(aHeight - std::max(0.f,readmap-&gt;minheight))*heightMod);
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius + (aHeight - std::max(0.f, readmap-&gt;minheight)) * heightMod);
 
 	int tempNum = gs-&gt;tempNum++;
 	std::vector&lt;int&gt;::iterator qi;
@@ -420,9 +485,10 @@
 					}
 					float3 targPos;
 					float value = 1.0f;
-					if (unit-&gt;losStatus[attacker-&gt;allyteam] &amp; LOS_INLOS) {
+					unsigned short unitLos = unit-&gt;losStatus[attacker-&gt;allyteam];
+					if (unitLos &amp; LOS_INLOS) {
 						targPos = unit-&gt;midPos;
-					} else if (unit-&gt;losStatus[attacker-&gt;allyteam] &amp; LOS_INRADAR) {
+					} else if (unitLos &amp; LOS_INRADAR) {
 						const float radErr = radarhandler-&gt;radarErrorSize[attacker-&gt;allyteam];
 						targPos = unit-&gt;midPos + (unit-&gt;posErrorVector * radErr);
 						value *= 10.0f;
@@ -432,27 +498,32 @@
 					const float modRange = radius + (aHeight - targPos.y) * heightMod;
 					if ((pos - targPos).SqLength2D() &lt;= modRange * modRange){
 						float dist2d = (pos - targPos).Length2D();
-						value *= (secDamage + unit-&gt;health);
 						value *= (dist2d * weapon-&gt;weaponDef-&gt;proximityPriority + modRange * 0.4f + 100.0f);
-						value *= (0.01f + unit-&gt;crashing);
-						value /= weapon-&gt;weaponDef-&gt;damages[unit-&gt;armorType]
-										 * unit-&gt;curArmorMultiple
-						         * unit-&gt;power * (0.7f + gs-&gt;randFloat() * 0.6f);
-						if (unit == lastTarget) {
-							value *= weapon-&gt;avoidTarget ? 10.0f : 0.4f;
+						if (unitLos &amp; LOS_INLOS) {
+							value *= (secDamage + unit-&gt;health);
+							if (unit == lastTarget) {
+								value *= weapon-&gt;avoidTarget ? 10.0f : 0.4f;
+							}
+							if (paralyzer &amp;&amp; unit-&gt;health - unit-&gt;paralyzeDamage &lt; unit-&gt;maxHealth * 0.09f) {
+								value *= 4.0f;
+							}
+							if (weapon-&gt;hasTargetWeight) {
+								value *= weapon-&gt;TargetWeight(unit);
+							}
+						} else {
+							value *= (secDamage + 10000.0f);
 						}
-						if (unit-&gt;category &amp; weapon-&gt;badTargetCategory) {
-							value *= 100.0f;
+						if (unitLos &amp; LOS_PREVLOS) {
+							value /= weapon-&gt;weaponDef-&gt;damages[unit-&gt;armorType]
+											 * unit-&gt;curArmorMultiple
+									 * unit-&gt;power * (0.7f + gs-&gt;randFloat() * 0.6f);
+							if (unit-&gt;category &amp; weapon-&gt;badTargetCategory) {
+								value *= 100.0f;
+							}
+							if (unit-&gt;crashing) {
+								value *= 1000.0f;
+							}
 						}
-						if (paralyzer &amp;&amp; unit-&gt;health-unit-&gt;paralyzeDamage &lt; unit-&gt;maxHealth * 0.09f) {
-							value *= 4.0f;
-						}
-						if (unit-&gt;crashing) {
-							value *= 10.0f;
-						}
-						if (weapon-&gt;hasTargetWeight) {
-							value *= weapon-&gt;TargetWeight(unit);
-						}
 						targets.insert(std::pair&lt;float, CUnit*&gt;(value, unit));
 					}
 				}
@@ -472,10 +543,12 @@
 
 CUnit* CGameHelper::GetClosestUnit(const float3 &amp;pos, float radius)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetClosestUnit
+
 	float closeDist = (radius * radius);
 	CUnit* closeUnit = NULL;
 
-	GML_RECMUTEX_LOCK(quad); //GetClosestUnit
+//	GML_RECMUTEX_LOCK(quad); //GetClosestUnit
 
 	vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
 
@@ -509,24 +582,31 @@
 	return closeUnit;
 }
 
-CUnit* CGameHelper::GetClosestEnemyUnit(const float3 &amp;pos, float radius,int searchAllyteam)
+CUnit* CGameHelper::GetClosestEnemyUnit(const float3&amp; pos, float searchRadius, int searchAllyteam)
 {
-	float closeDist=radius*radius;
-	CUnit* closeUnit=0;
-	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
+	GML_RECMUTEX_LOCK(qnum); // GetClosestEnemyUnit
 
-	int tempNum=gs-&gt;tempNum++;
+	float closeDist = searchRadius * searchRadius;
+	CUnit* closeUnit = 0;
+	vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, searchRadius);
+
+	int tempNum = gs-&gt;tempNum++;
 	vector&lt;int&gt;::iterator qi;
+
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		std::list&lt;CUnit*&gt;::const_iterator ui;
+
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
-			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
-				(*ui)-&gt;tempNum=tempNum;
-				float sqDist=(pos-(*ui)-&gt;midPos).SqLength2D();
-				if(sqDist &lt;= closeDist){
-					closeDist=sqDist;
-					closeUnit=*ui;
+			if ((*ui)-&gt;tempNum != tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam, (*ui)-&gt;allyteam) &amp;&amp;
+				(((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))) {
+
+				(*ui)-&gt;tempNum = tempNum;
+				float sqDist = (pos - (*ui)-&gt;midPos).SqLength2D();
+
+				if (sqDist &lt;= closeDist) {
+					closeDist = sqDist;
+					closeUnit = *ui;
 				}
 			}
 		}
@@ -537,49 +617,61 @@
 CUnit* CGameHelper::GetClosestEnemyUnitNoLosTest(const float3 &amp;pos, float radius,
                                                  int searchAllyteam, bool sphere, bool canBeBlind)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetClosestEnemyUnitNoLosTest
+
 	const int tempNum = gs-&gt;tempNum++;
-
 	CUnit* closeUnit = NULL;
-
 	float losFactor = (SQUARE_SIZE * (1 &lt;&lt; modInfo.losMipLevel));
 
-	if (sphere) {  // includes target radius
+	if (sphere) { // includes target radius
 		float closeDist = radius;
 		std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius + uh-&gt;maxUnitRadius);
 		std::vector&lt;int&gt;::const_iterator qi;
+
 		for (qi = quads.begin(); qi != quads.end(); ++qi) {
 			const std::list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
 			std::list&lt;CUnit*&gt;::const_iterator ui;
+
 			for (ui = quadUnits.begin(); ui!= quadUnits.end(); ++ui) {
 				CUnit* unit = *ui;
+
 				if (unit-&gt;tempNum != tempNum &amp;&amp;
 				    !gs-&gt;Ally(searchAllyteam, unit-&gt;allyteam)) {
 					unit-&gt;tempNum = tempNum;
-					const float dist = (pos - unit-&gt;midPos).Length() - unit-&gt;radius;
+
+					// FIXME: use volumeBoundingRadius?
+					// (more for consistency than need)
+					const float dist =
+						(pos - unit-&gt;midPos).Length() -
+						unit-&gt;radius;
+
 					if (dist &lt;= closeDist &amp;&amp;
-						(canBeBlind || unit-&gt;losRadius * losFactor &gt; dist)){
+						(canBeBlind || unit-&gt;losRadius * losFactor &gt; dist)) {
 						closeDist = dist;
 						closeUnit = unit;
 					}
 				}
 			}
 		}
-	}
-	else { // cylinder  (doesn't included target radius)
+	} else { // cylinder  (doesn't include target radius)
 		float closeDistSq = radius * radius;
 		std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
 		std::vector&lt;int&gt;::const_iterator qi;
+
 		for (qi = quads.begin(); qi != quads.end(); ++qi) {
 			const std::list&lt;CUnit*&gt;&amp; quadUnits = qf-&gt;GetQuad(*qi).units;
 			std::list&lt;CUnit*&gt;::const_iterator ui;
+
 			for (ui = quadUnits.begin(); ui!= quadUnits.end(); ++ui) {
 				CUnit* unit = *ui;
+
 				if (unit-&gt;tempNum != tempNum &amp;&amp;
 				    !gs-&gt;Ally(searchAllyteam, unit-&gt;allyteam)) {
 					unit-&gt;tempNum = tempNum;
 					const float sqDist = (pos - unit-&gt;midPos).SqLength2D();
+
 					if (sqDist &lt;= closeDistSq &amp;&amp;
-						(canBeBlind || unit-&gt;losRadius * losFactor &gt; sqDist)){
+						(canBeBlind || unit-&gt;losRadius * losFactor &gt; sqDist)) {
 						closeDistSq = sqDist;
 						closeUnit = unit;
 					}
@@ -592,6 +684,8 @@
 
 CUnit* CGameHelper::GetClosestFriendlyUnit(const float3 &amp;pos, float radius,int searchAllyteam)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetClosestFriendlyUnit
+
 	float closeDist=radius*radius;
 	CUnit* closeUnit=0;
 	std::vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
@@ -617,6 +711,8 @@
 
 CUnit* CGameHelper::GetClosestEnemyAircraft(const float3 &amp;pos, float radius,int searchAllyteam)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetClosestEnemyAircraft
+
 	float closeDist=radius*radius;
 	CUnit* closeUnit=0;
 	vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
@@ -642,19 +738,28 @@
 
 void CGameHelper::GetEnemyUnits(const float3 &amp;pos, float radius, int searchAllyteam, vector&lt;int&gt; &amp;found)
 {
-	float sqRadius=radius*radius;
-	std::vector&lt;int&gt; quads=qf-&gt;GetQuads(pos,radius);
+	GML_RECMUTEX_LOCK(qnum); // GetEnemyUnits
 
-	int tempNum=gs-&gt;tempNum++;
+	float sqRadius = radius * radius;
+	std::vector&lt;int&gt; quads = qf-&gt;GetQuads(pos, radius);
+
+	int tempNum = gs-&gt;tempNum++;
 	std::vector&lt;int&gt;::iterator qi;
+
 	for (qi = quads.begin(); qi != quads.end(); ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		std::list&lt;CUnit*&gt;::const_iterator ui;
+
 		for (ui = quad.units.begin(); ui != quad.units.end(); ++ui) {
-			if((*ui)-&gt;tempNum!=tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam,(*ui)-&gt;allyteam) &amp;&amp; (((*ui)-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))){
-				(*ui)-&gt;tempNum=tempNum;
-				if((pos-(*ui)-&gt;midPos).SqLength2D() &lt;= sqRadius){
-					found.push_back((*ui)-&gt;id);
+			CUnit* u = *ui;
+
+			if (u-&gt;tempNum != tempNum &amp;&amp; !gs-&gt;Ally(searchAllyteam, u-&gt;allyteam) &amp;&amp;
+				((u-&gt;losStatus[searchAllyteam] &amp; (LOS_INLOS | LOS_INRADAR)))) {
+
+				u-&gt;tempNum = tempNum;
+
+				if ((pos - u-&gt;midPos).SqLength2D() &lt;= sqRadius) {
+					found.push_back(u-&gt;id);
 				}
 			}
 		}
@@ -662,29 +767,28 @@
 }
 
 
-
+// called by {CFlameThrower, CLaserCannon, CEmgCannon, CBeamLaser, CLightingCannon}::TryTarget()
 bool CGameHelper::LineFeatureCol(const float3&amp; start, const float3&amp; dir, float length)
 {
 	int quads[1000];
 	int* endQuad = quads;
 	qf-&gt;GetQuadsOnRay(start, dir, length, endQuad);
 
+	CollisionQuery cq;
+
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
+
 		for (std::list&lt;CFeature*&gt;::const_iterator ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
-			if (!(*ui)-&gt;blocking)
-				continue;
+			CFeature* f = *ui;
+			CollisionVolume* cv = f-&gt;collisionVolume;
 
-			float3 dif = (*ui)-&gt;midPos - start;
-			float closeLength = dif.dot(dir);
-
-			if (closeLength &lt; 0)
+			if (!f-&gt;blocking || !cv) {
+				// NOTE: why check the blocking property?
 				continue;
-			if (closeLength &gt; length)
-				continue;
+			}
 
-			float3 closeVect = dif - dir * closeLength;
-			if (closeVect.SqLength() &lt; (*ui)-&gt;sqRadius) {
+			if (CCollisionHandler::Intersect(f, start, start + dir * length, &amp;cq)) {
 				return true;
 			}
 		}
@@ -706,6 +810,8 @@
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
 		std::list&lt;CFeature*&gt;::const_iterator ui;
 
+		// NOTE: switch this to custom volumes fully?
+		// (not used for any LOF checks, maybe wasteful)
 		for (ui = quad.features.begin(); ui != quad.features.end(); ++ui) {
 			CFeature* f = *ui;
 
@@ -717,7 +823,10 @@
 			if (f-&gt;noSelect) {
 				continue;
 			}
-			float3 dif = f-&gt;midPos-start;
+
+			CollisionVolume* cv = f-&gt;collisionVolume;
+			const float3&amp; midPosOffset = cv? cv-&gt;axisOffsets: ZeroVector;
+			const float3 dif = (f-&gt;midPos + midPosOffset) - start;
 			float closeLength = dif.dot(dir);
 
 			if (closeLength &lt; 0)
@@ -812,13 +921,14 @@
 
 
 
+
 /** @return true if there is an allied unit within
     the firing cone of &lt;owner&gt; (that might be hit) */
-bool CGameHelper::TestAllyCone(const float3&amp; from, const float3&amp; dir, float length, float spread, int allyteam, CUnit* owner)
+bool CGameHelper::TestAllyCone(const float3&amp; from, const float3&amp; weaponDir, float length, float spread, int allyteam, CUnit* owner)
 {
 	int quads[1000];
 	int* endQuad = quads;
-	qf-&gt;GetQuadsOnRay(from, dir, length, endQuad);
+	qf-&gt;GetQuadsOnRay(from, weaponDir, length, endQuad);
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
@@ -828,21 +938,19 @@
 			if (u == owner)
 				continue;
 
-			if (TestConeHelper(from, dir, length, spread, u))
+			if (TestConeHelper(from, weaponDir, length, spread, u))
 				return true;
 		}
 	}
 	return false;
 }
 
-
-
 /** same as TestAllyCone, but looks for neutral units */
-bool CGameHelper::TestNeutralCone(const float3&amp; from, const float3&amp; dir, float length, float spread, CUnit* owner)
+bool CGameHelper::TestNeutralCone(const float3&amp; from, const float3&amp; weaponDir, float length, float spread, CUnit* owner)
 {
 	int quads[1000];
 	int* endQuad = quads;
-	qf-&gt;GetQuadsOnRay(from, dir, length, endQuad);
+	qf-&gt;GetQuadsOnRay(from, weaponDir, length, endQuad);
 
 	for (int* qi = quads; qi != endQuad; ++qi) {
 		const CQuadField::Quad&amp; quad = qf-&gt;GetQuad(*qi);
@@ -854,7 +962,7 @@
 				continue;
 
 			if (u-&gt;IsNeutral()) {
-				if (TestConeHelper(from, dir, length, spread, u))
+				if (TestConeHelper(from, weaponDir, length, spread, u))
 					return true;
 			}
 		}
@@ -863,30 +971,32 @@
 }
 
 
-
 /** helper for TestAllyCone and TestNeutralCone
     @return true if the unit u is in the firing cone, false otherwise */
-bool CGameHelper::TestConeHelper(const float3&amp; from, const float3&amp; dir, float length, float spread, const CUnit* u)
+bool CGameHelper::TestConeHelper(const float3&amp; from, const float3&amp; weaponDir, float length, float spread, const CUnit* u)
 {
-	float3 dif = u-&gt;midPos - from;
-	float closeLength = dif.dot(dir);
+	// account for any offset, since we want to know if our shots might hit
+	float3 unitDir = (u-&gt;midPos + u-&gt;collisionVolume-&gt;axisOffsets) - from;
+	// weaponDir defines the center of the cone
+	float closeLength = unitDir.dot(weaponDir);
 
 	if (closeLength &lt;= 0)
 		return false;
 	if (closeLength &gt; length)
 		closeLength = length;
 
-	float3 closeVect = dif - dir * closeLength;
-	float r = u-&gt;radius + spread * closeLength + 1;
+	float3 closeVect = unitDir - weaponDir * closeLength;
+	// NOTE: same caveat wrt. use of volumeBoundingRadius
+	// as for ::Explosion(), this will result in somewhat
+	// over-conservative tests for non-spherical volumes
+	float r = u-&gt;collisionVolume-&gt;volumeBoundingRadius + spread * closeLength + 1;
 
-	if (closeVect.SqLength() &lt; r * r) {
-		return true;
-	}
-	return false;
+	return (closeVect.SqLength() &lt; r * r);
 }
 
 
 
+
 /** @return true if there is an allied unit within
     the firing trajectory of &lt;owner&gt; (that might be hit) */
 bool CGameHelper::TestTrajectoryAllyCone(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, int allyteam, CUnit* owner)
@@ -910,8 +1020,6 @@
 	return false;
 }
 
-
-
 /** same as TestTrajectoryAllyCone, but looks for neutral units */
 bool CGameHelper::TestTrajectoryNeutralCone(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, CUnit* owner)
 {
@@ -937,12 +1045,12 @@
 }
 
 
-
 /** helper for TestTrajectoryAllyCone and TestTrajectoryNeutralCone
     @return true if the unit u is in the firing trajectory, false otherwise */
 bool CGameHelper::TestTrajectoryConeHelper(const float3&amp; from, const float3&amp; flatdir, float length, float linear, float quadratic, float spread, float baseSize, const CUnit* u)
 {
-	float3 dif = u-&gt;midPos - from;
+	CollisionVolume* cv = u-&gt;collisionVolume;
+	float3 dif = (u-&gt;midPos + cv-&gt;axisOffsets) - from;
 	float3 flatdif(dif.x, 0, dif.z);
 	float closeFlatLength = flatdif.dot(flatdir);
 
@@ -955,8 +1063,9 @@
 		// relatively flat region -&gt; use approximation
 		dif.y -= (linear + quadratic * closeFlatLength) * closeFlatLength;
 
+		// NOTE: overly conservative for non-spherical volumes
 		float3 closeVect = dif - flatdir * closeFlatLength;
-		float r = u-&gt;radius + spread * closeFlatLength + baseSize;
+		float r = cv-&gt;volumeBoundingRadius + spread * closeFlatLength + baseSize;
 		if (closeVect.SqLength() &lt; r * r) {
 			return true;
 		}
@@ -967,11 +1076,12 @@
 		dir.y = linear + quadratic * closeFlatLength;
 		dir.Normalize();
 
-		dif = u-&gt;midPos - newfrom;
+		dif = (u-&gt;midPos + cv-&gt;axisOffsets) - newfrom;
 		float closeLength = dif.dot(dir);
 
+		// NOTE: overly conservative for non-spherical volumes
 		float3 closeVect = dif - dir * closeLength;
-		float r = u-&gt;radius + spread * closeFlatLength + baseSize;
+		float r = cv-&gt;volumeBoundingRadius + spread * closeFlatLength + baseSize;
 		if (closeVect.SqLength() &lt; r * r) {
 			return true;
 		}

Modified: branches/caiinterface/rts/Game/GameHelper.h
===================================================================
--- branches/caiinterface/rts/Game/GameHelper.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameHelper.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -41,9 +41,13 @@
 	CUnit* GetClosestEnemyAircraft(const float3&amp; pos,float radius,int searchAllyteam);
 	void GenerateTargets(const CWeapon *attacker, CUnit* lastTarget,std::map&lt;float,CUnit*&gt; &amp;targets);
 	float TraceRay(const float3&amp; start,const float3&amp; dir,float length,float power,CUnit* owner, CUnit*&amp; hit,int collisionFlags=0);
-	float GuiTraceRay(const float3&amp; start,const float3&amp; dir,float length, CUnit*&amp; hit,float sizeMod,bool useRadar,CUnit* exclude=0);
+	float GuiTraceRay(const float3&amp; start,const float3&amp; dir,float length, CUnit*&amp; hit,bool useRadar,CUnit* exclude=0);
 	float GuiTraceRayFeature(const float3&amp; start, const float3&amp; dir, float length,CFeature*&amp; feature);
-	void Explosion(float3 pos,const DamageArray&amp; damages,float radius, float edgeEffectiveness, float explosionSpeed, CUnit* owner,bool damageGround,float gfxMod,bool ignoreOwner, CExplosionGenerator *explosionGraphics,CUnit *hit, const float3 &amp;impactDir, int weaponId);
+
+	void DoExplosionDamage(CUnit*, const float3&amp;, float, float, bool, CUnit*, float, const DamageArray&amp;, int);
+	void DoExplosionDamage(CFeature*, const float3&amp;, float, CUnit*, const DamageArray&amp;);
+	void Explosion(float3 pos, const DamageArray&amp; damages,float radius, float edgeEffectiveness, float explosionSpeed, CUnit* owner,bool damageGround,float gfxMod,bool ignoreOwner, CExplosionGenerator *explosionGraphics,CUnit *hit, const float3 &amp;impactDir, int weaponId);
+
 	float TraceRayTeam(const float3&amp; start,const float3&amp; dir,float length, CUnit*&amp; hit,bool useRadar,CUnit* exclude,int allyteam);
 	void BuggerOff(float3 pos, float radius,CUnit* exclude=0);
 	float3 Pos2BuildPos(const BuildInfo&amp; buildInfo);

Modified: branches/caiinterface/rts/Game/GameServer.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameServer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameServer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -37,6 +37,7 @@
 #include &quot;System/Net/Connection.h&quot;
 #include &quot;System/Net/UDPConnection.h&quot;
 #include &quot;System/Net/LocalConnection.h&quot;
+#include &quot;System/Net/UnpackPacket.h&quot;
 #include &quot;System/DemoReader.h&quot;
 #include &quot;System/AutohostInterface.h&quot;
 #include &quot;System/Util.h&quot;
@@ -192,12 +193,12 @@
 	delete thread;
 }
 
-void CGameServer::AddLocalClient(unsigned wantedNumber)
+void CGameServer::AddLocalClient(const std::string&amp; myName, const std::string&amp; myVersion)
 {
 	boost::recursive_mutex::scoped_lock scoped_lock(gameServerMutex);
 	assert(!hasLocalClient);
 	hasLocalClient = true;
-	localClientNumber = BindConnection(wantedNumber, true, boost::shared_ptr&lt;netcode::CConnection&gt;(new netcode::CLocalConnection()));
+	localClientNumber = BindConnection(myName, myVersion, true, boost::shared_ptr&lt;netcode::CConnection&gt;(new netcode::CLocalConnection()));
 }
 
 void CGameServer::AddAutohostInterface(const int remotePort)
@@ -275,8 +276,6 @@
 			CheckSync();
 #endif
 			Broadcast(boost::shared_ptr&lt;const RawPacket&gt;(buf));
-			if (!skipping)
-				return;
 		}
 		else if ( msgCode != NETMSG_GAMEDATA &amp;&amp;
 						msgCode != NETMSG_SETPLAYERNUM &amp;&amp;
@@ -443,10 +442,7 @@
 				if(newSpeed&lt;0.1f)
 					newSpeed=0.1f;
 				if(newSpeed!=internalSpeed)
-				{
-					internalSpeed = newSpeed;
-					Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(newSpeed));
-				}
+					InternalSpeedChange(newSpeed);
 			}
 		}
 	}
@@ -531,22 +527,7 @@
 		case NETMSG_USER_SPEED: {
 			unsigned char playerNum = inbuf[1];
 			float speed = *((float*) &amp;inbuf[2]);
-
-			if (speed &gt; maxUserSpeed)
-				speed = maxUserSpeed;
-			if (speed &lt; minUserSpeed)
-				speed = minUserSpeed;
-			if (userSpeedFactor != speed)
-			{
-				if (internalSpeed == userSpeedFactor || internalSpeed&gt;speed)
-				{
-					Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(speed));
-					internalSpeed = speed;
-				}
-				// forward data
-				Broadcast(CBaseNetProtocol::Get().SendUserSpeed(playerNum, speed));
-				userSpeedFactor = speed;
-			}
+			UserSpeedChange(speed, playerNum);
 		} break;
 
 		case NETMSG_CPU_USAGE:
@@ -908,10 +889,13 @@
 		boost::shared_ptr&lt;netcode::UDPConnection&gt; prev = UDPNet-&gt;PreviewConnection().lock();
 		boost::shared_ptr&lt;const RawPacket&gt; packet = prev-&gt;GetData();
 		
-		if (packet &amp;&amp; packet-&gt;length &gt;= 3 &amp;&amp; packet-&gt;data[0] == NETMSG_ATTEMPTCONNECT &amp;&amp; packet-&gt;data[2] == NETWORK_VERSION)
+		if (packet &amp;&amp; packet-&gt;length &gt;= 3 &amp;&amp; packet-&gt;data[0] == NETMSG_ATTEMPTCONNECT)
 		{
-			const unsigned wantedNumber = packet-&gt;data[1];
-			BindConnection(wantedNumber, false, UDPNet-&gt;AcceptConnection());
+			netcode::UnpackPacket msg(packet, 3);
+			std::string name, version;
+			msg &gt;&gt; name;
+			msg &gt;&gt; version;
+			BindConnection(name, version, false, UDPNet-&gt;AcceptConnection());
 		}
 		else
 		{
@@ -996,7 +980,7 @@
 		// Lobby-protocol doesn't support creating games without players inside
 		// so in dedicated mode there will always be the host-player in the script
 		// which doesn't exist and will never join, so skip it in this case
-		if (setup &amp;&amp; (unsigned)setup-&gt;myPlayerNum == start)
+		if (setup &amp;&amp; 0 == start)
 			start++;
 #endif
 		for (int a = start; a &lt; setup-&gt;numPlayers; a++) {
@@ -1051,17 +1035,8 @@
 	}
 
 	// make sure initial game speed is within allowed range and sent a new speed if not
-	if(userSpeedFactor&gt;maxUserSpeed)
-	{
-		Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, maxUserSpeed));
-		userSpeedFactor = maxUserSpeed;
-	}
-	else if(userSpeedFactor&lt;minUserSpeed)
-	{
-		Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, minUserSpeed));
-		userSpeedFactor = minUserSpeed;
-	}
-
+	UserSpeedChange(userSpeedFactor, SERVER_PLAYER);
+	
 	if (demoReader) {
 		// the client told us to start a demo
 		// no need to send startpos and startplaying since its in the demo
@@ -1139,31 +1114,17 @@
 	}
 	else if (action.command == &quot;setmaxspeed&quot; &amp;&amp; !action.extra.empty())
 	{
-		float newUserSpeed = atof(action.extra.c_str());
+		float newUserSpeed = std::max(static_cast&lt;float&gt;(atof(action.extra.c_str())), minUserSpeed);
 		if (newUserSpeed &gt; 0.2)
 		{
-			maxUserSpeed = atof(action.extra.c_str());
-			if (userSpeedFactor &gt; maxUserSpeed) {
-				Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, maxUserSpeed));
-				userSpeedFactor = maxUserSpeed;
-				if (internalSpeed &gt; maxUserSpeed) {
-					Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(userSpeedFactor));
-					internalSpeed = userSpeedFactor;
-				}
-			}
+			maxUserSpeed = newUserSpeed;
+			UserSpeedChange(userSpeedFactor, SERVER_PLAYER);
 		}
 	}
 	else if (action.command == &quot;setminspeed&quot; &amp;&amp; !action.extra.empty())
 	{
-		minUserSpeed = atof(action.extra.c_str());
-		if (userSpeedFactor &lt; minUserSpeed) {
-			Broadcast(CBaseNetProtocol::Get().SendUserSpeed(SERVER_PLAYER, minUserSpeed));
-			userSpeedFactor = minUserSpeed;
-			if (internalSpeed &lt; minUserSpeed) {
-				Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(userSpeedFactor));
-				internalSpeed = userSpeedFactor;
-			}
-		}
+		minUserSpeed = std::min(static_cast&lt;float&gt;(atof(action.extra.c_str())), maxUserSpeed);
+		UserSpeedChange(userSpeedFactor, SERVER_PLAYER);
 	}
 	else if (action.command == &quot;forcestart&quot;)
 	{
@@ -1398,11 +1359,26 @@
 	}
 }
 
-unsigned CGameServer::BindConnection(unsigned wantedNumber, bool isLocal, boost::shared_ptr&lt;netcode::CConnection&gt; link)
+unsigned CGameServer::BindConnection(const std::string&amp; name, const std::string&amp; version, bool isLocal, boost::shared_ptr&lt;netcode::CConnection&gt; link)
 {
-	unsigned hisNewNumber = wantedNumber;
+	unsigned hisNewNumber = 0;
+	bool found = false;
+
+	if (setup)
+	{
+		for (unsigned i = 0; i &lt; setup-&gt;numPlayers; ++i)
+		{
+			if (name == setup-&gt;playerStartingData[i].name)
+			{
+				hisNewNumber = i;
+				found = true;
+				break;
+			}
+		}
+	}
+
 	if (demoReader) {
-		hisNewNumber = std::max(wantedNumber, (unsigned)demoReader-&gt;GetFileHeader().maxPlayerNum+1);
+		hisNewNumber = std::max(hisNewNumber, (unsigned)demoReader-&gt;GetFileHeader().maxPlayerNum+1);
 	}
 	if (players[hisNewNumber])
 	{
@@ -1416,10 +1392,10 @@
 		}
 	}
 
-	if (setup &amp;&amp; hisNewNumber &gt;= static_cast&lt;unsigned&gt;(setup-&gt;numPlayers) &amp;&amp; !demoReader)
+	if (setup &amp;&amp; (hisNewNumber &gt;= static_cast&lt;unsigned&gt;(setup-&gt;numPlayers) || !found) &amp;&amp; !demoReader)
 	{
-		// number not in setup, drop connection
-		Message(str(format(&quot;Connection rejected because of number %i not in setup (wanted number %i).&quot;) %hisNewNumber %wantedNumber));
+		// player not found
+		Message(str(format(&quot;Player %s not found, rejecting connection attempt&quot;) %name));
 		return 0;
 	}
 	
@@ -1470,7 +1446,7 @@
 			}
 		}
 	}
-	Message(str(format(NewConnection) %hisNewNumber %wantedNumber));
+	Message(str(format(NewConnection) %name %hisNewNumber %version));
 
 	link-&gt;Flush(true);
 	return hisNewNumber;
@@ -1485,6 +1461,28 @@
 	}
 }
 
+void CGameServer::InternalSpeedChange(float newSpeed)
+{
+	if (internalSpeed == newSpeed)
+		; //TODO some error here
+	Broadcast(CBaseNetProtocol::Get().SendInternalSpeed(newSpeed));
+	internalSpeed = newSpeed;
+}
+
+void CGameServer::UserSpeedChange(float newSpeed, int player)
+{
+	newSpeed = std::min(maxUserSpeed, std::max(newSpeed, minUserSpeed));
+	
+	if (userSpeedFactor != newSpeed)
+	{
+		if (internalSpeed &gt; newSpeed || internalSpeed == userSpeedFactor) // insta-raise speed when not slowed down
+			InternalSpeedChange(newSpeed);
+
+		Broadcast(CBaseNetProtocol::Get().SendUserSpeed(player, newSpeed));
+		userSpeedFactor = newSpeed;
+	}
+}
+
 void CGameServer::RestrictedAction(const std::string&amp; action)
 {
 	RegisterAction(action);

Modified: branches/caiinterface/rts/Game/GameServer.h
===================================================================
--- branches/caiinterface/rts/Game/GameServer.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameServer.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -66,7 +66,7 @@
 	CGameServer(int port, bool onlyLocal, const GameData* const gameData, const CGameSetup* const setup, const std::string&amp; demoName = &quot;&quot;);
 	virtual ~CGameServer();
 
-	void AddLocalClient(unsigned wantedNumber);
+	void AddLocalClient(const std::string&amp; myName, const std::string&amp; myVersion);
 
 	void AddAutohostInterface(const int remotePort);
 
@@ -106,7 +106,7 @@
 	*/
 	void KickPlayer(const int playerNum);
 
-	unsigned BindConnection(unsigned wantedNumber, bool isLocal, boost::shared_ptr&lt;netcode::CConnection&gt; link);
+	unsigned BindConnection(const std::string&amp; name, const std::string&amp; version, bool isLocal, boost::shared_ptr&lt;netcode::CConnection&gt; link);
 
 	void CheckForGameStart(bool forced=false);
 	void StartGame();
@@ -182,6 +182,8 @@
 	int delayedSyncResponseFrame;
 
 	///////////////// internal stuff //////////////////
+	void InternalSpeedChange(float newSpeed);
+	void UserSpeedChange(float newSpeed, int player);
 
 	bool hasLocalClient;
 	unsigned localClientNumber;

Modified: branches/caiinterface/rts/Game/GameSetup.cpp
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameSetup.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -28,14 +28,88 @@
 
 const CGameSetup* gameSetup = NULL;
 
+LocalSetup::LocalSetup() :
+		autohostport(0),
+		hostport(8452),
+		myPlayerNum(0),
+		sourceport(0),
+		isHost(true)
+{
+}
 
+void LocalSetup::Init(const std::string&amp; setup)
+{
+	TdfParser file;
+	file.LoadBuffer(setup.c_str(), setup.length());
+	
+	if(!file.SectionExist(&quot;GAME&quot;))
+		throw content_error(&quot;GAME-section didn't exist in setupscript&quot;);
+
+	// Technical parameters
+	file.GetDef(hostip,     &quot;0&quot;, &quot;GAME\\HostIP&quot;);
+	file.GetDef(hostport,   &quot;0&quot;, &quot;GAME\\HostPort&quot;);
+	file.GetDef(sourceport, &quot;0&quot;, &quot;GAME\\SourcePort&quot;);
+	file.GetDef(autohostport, &quot;0&quot;, &quot;GAME\\AutohostPort&quot;);
+	
+	file.GetDef(myPlayerName,  &quot;&quot;, &quot;GAME\\MyPlayerName&quot;);
+	file.GetDef(myPlayerNum,  &quot;0&quot;, &quot;GAME\\MyPlayerNum&quot;);
+	if (myPlayerName.empty())
+	{
+		char section[50];
+		sprintf(section, &quot;GAME\\PLAYER%i&quot;, myPlayerNum);
+		string s(section);
+
+		if (!file.SectionExist(s))
+			throw content_error(&quot;myPlayer not found&quot;);
+
+		std::map&lt;std::string, std::string&gt; setup = file.GetAllValues(s);
+		std::map&lt;std::string, std::string&gt;::iterator it = setup.find(&quot;name&quot;);
+		if (it != setup.end())
+			myPlayerName = it-&gt;second;
+		else
+			throw content_error(&quot;Player doesn't have a name&quot;);
+	}
+	
+	int tmp_isHost;
+	file.GetDef(myPlayerNum,  &quot;-1&quot;, &quot;GAME\\IsHost&quot;);
+	if (tmp_isHost == 1)
+		isHost = true;
+	else if (tmp_isHost == 0)
+		isHost = false;
+	else
+	{
+		for (int a = 0; a &lt; MAX_PLAYERS; ++a) {
+			char section[50];
+			sprintf(section, &quot;GAME\\PLAYER%i&quot;, a);
+			string s(section);
+
+			if (!file.SectionExist(s)) {
+				continue;
+			}
+			bool fromdemo;
+			std::string name;
+			std::map&lt;std::string, std::string&gt; setup = file.GetAllValues(s);
+			std::map&lt;std::string, std::string&gt;::iterator it;
+			if ((it = setup.find(&quot;name&quot;)) != setup.end())
+				name = it-&gt;second;
+			if ((it = setup.find(&quot;isfromdemo&quot;)) != setup.end())
+				fromdemo = static_cast&lt;bool&gt;(atoi(it-&gt;second.c_str()));
+			
+			if (!fromdemo)
+			{
+				isHost = (myPlayerName == name);
+				break;
+			}
+		}
+	}
+}
+
 CGameSetup::CGameSetup()
 {
 	gameSetupText=0;
 	startPosType=StartPos_Fixed;
 	numDemoPlayers=0;
 	hostDemo=false;
-	autohostport = 0;
 }
 
 CGameSetup::~CGameSetup()
@@ -92,7 +166,7 @@
 
 	for(int a = 0; a &lt; numTeams; ++a) {
 		float3 pos(1000.0f, 100.0f, 1000.0f);
-		if (!mapParser.GetStartPos(a, pos))
+		if (!mapParser.GetStartPos(teamStartingData[a].teamStartNum, pos) &amp;&amp; (startPosType == StartPos_Fixed || startPosType == StartPos_Random)) // don't fail when playing with more players than startpositions and we didn't use them anyway
 			throw content_error(mapParser.GetErrorLog());
 		teamStartingData[a].startPos = SFloat3(pos.x, pos.y, pos.z);
 	}
@@ -109,9 +183,6 @@
 {
 	TdfParser file;
 	file.LoadBuffer(gameSetupText, gameSetupTextLength-1);
-	for (int a = 0; a &lt; numTeams; ++a) {
-		teamStartingData[a].teamStartNum = a;
-	}
 
 	if (startPosType == StartPos_Random) {
 		// Server syncs these later, so we can use unsynced rng
@@ -124,6 +195,12 @@
 		for (unsigned int i = 0; i &lt; teamStartingData.size(); ++i)
 			teamStartingData[i].teamStartNum = teamStartNum[i];
 	}
+	else
+	{
+		for (int a = 0; a &lt; numTeams; ++a) {
+		teamStartingData[a].teamStartNum = a;
+		}
+	}
 
 	LoadStartPositionsFromMap();
 
@@ -330,12 +407,6 @@
 		};
 		teamStartingData[a].leader = playerRemap[teamStartingData[a].leader];
 	}
-
-	// relocate myPlayerNum
-	if (playerRemap.find(myPlayerNum) == playerRemap.end()) {
-		throw content_error(&quot;invalid MyPlayerNum in GameSetup script&quot;);
-	}
-	myPlayerNum = playerRemap[myPlayerNum];
 }
 
 /** @brief Update all team indices to refer to the right team. */
@@ -386,12 +457,6 @@
 	if(!file.SectionExist(&quot;GAME&quot;))
 		return false;
 
-	// Technical parameters
-	file.GetDef(hostip,     &quot;0&quot;, &quot;GAME\\HostIP&quot;);
-	file.GetDef(hostport,   &quot;0&quot;, &quot;GAME\\HostPort&quot;);
-	file.GetDef(sourceport, &quot;0&quot;, &quot;GAME\\SourcePort&quot;);
-	file.GetDef(autohostport, &quot;0&quot;, &quot;GAME\\AutohostPort&quot;);
-
 	// Game parameters
 	scriptName  = file.SGetValueDef(&quot;Commanders&quot;, &quot;GAME\\ScriptName&quot;);
 
@@ -427,7 +492,6 @@
 	file.GetDef(maxSpeed, &quot;3.0&quot;, &quot;GAME\\ModOptions\\MaxSpeed&quot;);
 	file.GetDef(minSpeed, &quot;0.3&quot;, &quot;GAME\\ModOptions\\MinSpeed&quot;);
 
-	file.GetDef(myPlayerNum,  &quot;0&quot;, &quot;GAME\\MyPlayerNum&quot;);
 	file.GetDef(fixedAllies, &quot;1&quot;, &quot;GAME\\ModOptions\\FixedAllies&quot;);
 
 	// Read the map &amp; mod options

Modified: branches/caiinterface/rts/Game/GameSetup.h
===================================================================
--- branches/caiinterface/rts/Game/GameSetup.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GameSetup.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -11,6 +11,24 @@
 
 class TdfParser;
 
+class LocalSetup
+{
+public:
+	LocalSetup();
+
+	void Init(const std::string&amp; setup);
+
+	int myPlayerNum;
+	std::string myPlayerName;
+	
+	std::string hostip;
+	int hostport;
+	int sourceport; //the port clients will try to connect from
+	int autohostport;
+	
+	bool isHost;
+};
+
 class CGameSetup
 {
 public:
@@ -29,7 +47,6 @@
 		StartPos_Last = 3  // last entry in enum (for user input check)
 	};
 
-	int myPlayerNum;
 	int numPlayers; //the expected amount of players
 	int numTeams;
 	int numAllyTeams;
@@ -43,11 +60,6 @@
 	std::string luaGaiaStr;
 	std::string luaRulesStr;
 	
-	std::string hostip;
-	int hostport;
-	int sourceport; //the port clients will try to connect from
-	int autohostport;
-	
 	char* gameSetupText;
 	int gameSetupTextLength;
 	

Modified: branches/caiinterface/rts/Game/GlobalSynced.cpp
===================================================================
--- branches/caiinterface/rts/Game/GlobalSynced.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/GlobalSynced.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,3 +1,4 @@
+#include &quot;StdAfx.h&quot;
 #include &quot;GlobalSynced.h&quot;
 
 #include &lt;assert.h&gt;
@@ -183,7 +184,7 @@
 	}
 
 	if (useLuaGaia) {
-		//TODO duplicated in SpringApp::CreateGameSetup()
+		//TODO duplicated in SpringApp::Startup()
 		// Gaia adjustments
 		gaiaTeamID = activeTeams;
 		gaiaAllyTeamID = activeAllyTeams;

Modified: branches/caiinterface/rts/Game/PreGame.cpp
===================================================================
--- branches/caiinterface/rts/Game/PreGame.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/PreGame.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,6 +10,7 @@
 
 #include &quot;PreGame.h&quot;
 #include &quot;Game.h&quot;
+#include &quot;GameVersion.h&quot;
 #include &quot;Team.h&quot;
 #include &quot;FPUCheck.h&quot;
 #include &quot;GameServer.h&quot;
@@ -61,8 +62,8 @@
 std::string CPreGame::userMod;
 
 
-CPreGame::CPreGame(bool server, const string&amp; demo, const std::string&amp; save)
-: server(server),
+CPreGame::CPreGame(const LocalSetup* setup, const string&amp; demo, const std::string&amp; save)
+: settings(setup),
   state(UNKNOWN),
   hasDemo(!demo.empty()),
   hasSave(!save.empty()),
@@ -71,6 +72,11 @@
 {
 	demoFile = gameSetup? gameSetup-&gt;demoName : demo;
 
+	if (!gameSetup &amp;&amp; demoFile.empty()) {
+		gs-&gt;noHelperAIs = !!configHandler.GetInt(&quot;NoHelperAIs&quot;, 0);
+		LoadLua();
+	}
+
 	infoConsole = SAFE_NEW CInfoConsole;
 
 	pregame = this; // prevent crashes if Select* is called from ctor
@@ -88,8 +94,8 @@
 		}
 	}
 
-	if(server){
-		net-&gt;InitLocalClient(gameSetup ? gameSetup-&gt;myPlayerNum : 0);
+	if(settings-&gt;isHost){
+		net-&gt;InitLocalClient();
 		if (!demoFile.empty())
 		{
 			ReadDataFromDemo(demoFile);
@@ -110,46 +116,26 @@
 	} else {
 		if(gameSetup){
 			PrintLoadMsg(&quot;Connecting to server&quot;);
-			net-&gt;InitClient(gameSetup-&gt;hostip.c_str(),gameSetup-&gt;hostport,gameSetup-&gt;sourceport, gameSetup-&gt;myPlayerNum);
+			net-&gt;InitClient(settings-&gt;hostip.c_str(), settings-&gt;hostport, settings-&gt;sourceport, settings-&gt;myPlayerName, std::string(VERSION_STRING_DETAILED));
 			state = WAIT_CONNECTING;
 		} else {
 			if (hasDemo) {
 				net-&gt;localDemoPlayback = true;
 				state = WAIT_CONNECTING;
 				ReadDataFromDemo(demoFile); // scan for GameData
-				net-&gt;InitLocalClient(0);
+				net-&gt;InitLocalClient();
 				if (gameSetup) {	// we read a gameSetup from the demofiles
 					logOutput.Print(&quot;Read GameSetup from Demofile&quot;);
 				}
 				else { // we dont read a GameSetup from demofile (this code was copied from CDemoReader)
 					logOutput.Print(&quot;Demo file does not contain a setupscript&quot;);
-					// Didn't get a CGameSetup script
-					// FIXME: duplicated in Main.cpp
-					const string luaGaiaStr  = configHandler.GetString(&quot;LuaGaia&quot;,  &quot;1&quot;);
-					const string luaRulesStr = configHandler.GetString(&quot;LuaRules&quot;, &quot;1&quot;);
-					gs-&gt;useLuaGaia  = CLuaGaia::SetConfigString(luaGaiaStr);
-					gs-&gt;useLuaRules = CLuaRules::SetConfigString(luaRulesStr);
-					if (gs-&gt;useLuaGaia) {
-						gs-&gt;gaiaTeamID = gs-&gt;activeTeams;
-						gs-&gt;gaiaAllyTeamID = gs-&gt;activeAllyTeams;
-						gs-&gt;activeTeams++;
-						gs-&gt;activeAllyTeams++;
-						CTeam* team = gs-&gt;Team(gs-&gt;gaiaTeamID);
-						team-&gt;color[0] = 255;
-						team-&gt;color[1] = 255;
-						team-&gt;color[2] = 255;
-						team-&gt;color[3] = 255;
-						team-&gt;gaia = true;
-						gs-&gt;SetAllyTeam(gs-&gt;gaiaTeamID, gs-&gt;gaiaAllyTeamID);
-					}
+					LoadLua();
 				}
 			}
 			else {
-				userInput=configHandler.GetString(&quot;address&quot;,&quot;&quot;);
-				writingPos = userInput.length();
-				userPrompt = &quot;Enter server address: &quot;;
-				state = WAIT_ON_ADDRESS;
-				userWriting = true;
+				PrintLoadMsg(&quot;Connecting to server&quot;);
+				net-&gt;InitClient(settings-&gt;hostip.c_str(), settings-&gt;hostport, settings-&gt;sourceport, settings-&gt;myPlayerName, std::string(VERSION_STRING_DETAILED));
+				state = WAIT_CONNECTING;
 			}
 		}
 	}
@@ -179,47 +165,6 @@
 		return 0;
 	}
 
-	if (userWriting) {
-		keys[k] = true;
-		if (k == SDLK_v &amp;&amp; keys[SDLK_LCTRL]){
-			CClipboard clipboard;
-			const string text = clipboard.GetContents();
-			userInput.insert(writingPos, text);
-			writingPos += text.length();
-			return 0;
-		}
-		if(k == SDLK_BACKSPACE){
-			if (!userInput.empty() &amp;&amp; (writingPos &gt; 0)) {
-				userInput.erase(writingPos - 1, 1);
-				writingPos--;
-			}
-			return 0;
-		}
-		if (k == SDLK_DELETE) {
-			if (!userInput.empty() &amp;&amp; (writingPos &lt; (int)userInput.size())) {
-				userInput.erase(writingPos, 1);
-			}
-			return 0;
-		}
-		else if (k == SDLK_LEFT) {
-			writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
-		}
-		else if (k == SDLK_RIGHT) {
-			writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
-		}
-		else if (k == SDLK_HOME) {
-			writingPos = 0;
-		}
-		else if (k == SDLK_END) {
-			writingPos = (int)userInput.length();
-		}
-		if (k == SDLK_RETURN){
-			userWriting = false;
-			return 0;
-		}
-		return 0;
-	}
-
 	return 0;
 }
 
@@ -246,7 +191,6 @@
 					PrintLoadMsg(&quot;Connecting to server  &quot;, false);
 				break;
 			case UNKNOWN:
-			case WAIT_ON_ADDRESS:
 			case WAIT_ON_USERINPUT:
 			case ALL_READY:
 			default:
@@ -257,32 +201,6 @@
 
 	infoConsole-&gt;Draw();
 
-	if (userWriting) {
-		const std::string tempstring = userPrompt + userInput;
-
-		const float xStart = 0.10f;
-		const float yStart = 0.75f;
-
-		const float fontScale = 1.0f;
-
-		// draw the caret
-		const int caretPos = userPrompt.length() + writingPos;
-		const string caretStr = tempstring.substr(0, caretPos);
-		const float caretWidth = font-&gt;CalcTextWidth(caretStr.c_str());
-		char c = userInput[writingPos];
-		if (c == 0) { c = ' '; }
-		const float cw = fontScale * font-&gt;CalcCharWidth(c);
-		const float csx = xStart + (fontScale * caretWidth);
-		glDisable(GL_TEXTURE_2D);
-		const float f = 0.5f * (1.0f + sin((float)SDL_GetTicks() * 0.015f));
-		glColor4f(f, f, f, 0.75f);
-		glRectf(csx, yStart, csx + cw, yStart + fontScale * font-&gt;GetHeight());
-		glEnable(GL_TEXTURE_2D);
-
-		glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
-		font-&gt;glPrintAt(xStart, yStart, fontScale, tempstring.c_str());
-	}
-
 	if (showList) {
 		showList-&gt;Draw();
 	}
@@ -301,16 +219,6 @@
 			logOutput.Print(&quot;Internal error in CPreGame&quot;);
 			return false;
 
-		case WAIT_ON_ADDRESS: {
-			if (userWriting)
-				break;
-
-			configHandler.SetString(&quot;address&quot;,userInput);
-			net-&gt;InitClient(userInput.c_str(),springDefaultPort,0, 0);
-			state = WAIT_CONNECTING;
-			// fall trough
-		}
-
 		case WAIT_ON_USERINPUT: {
 			break;
 		}
@@ -356,7 +264,7 @@
 			break;
 	}
 
-	if(state &gt; WAIT_ON_ADDRESS){
+	if(state &gt;= WAIT_CONNECTING){
 		net-&gt;Update();
 		UpdateClientNet();
 	}
@@ -432,12 +340,12 @@
 	}
 	
 	good_fpu_control_registers(&quot;before CGameServer creation&quot;);
-	int myPort = gameSetup? gameSetup-&gt;hostport : springDefaultPort;
+	int myPort = settings-&gt;hostport;
 	gameServer = new CGameServer(myPort, false, startupData, gameSetup, demoFile);
-	if (gameSetup &amp;&amp; gameSetup-&gt;autohostport &gt; 0) {
-		gameServer-&gt;AddAutohostInterface(gameSetup-&gt;autohostport);
+	if (settings-&gt;autohostport &gt; 0) {
+		gameServer-&gt;AddAutohostInterface(settings-&gt;autohostport);
 	}
-	gameServer-&gt;AddLocalClient(gameSetup? gameSetup-&gt;myPlayerNum : 0);
+	gameServer-&gt;AddLocalClient(settings-&gt;myPlayerName, std::string(VERSION_STRING_DETAILED));
 	good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 }
 
@@ -462,7 +370,7 @@
 		const unsigned char* inbuf = packet-&gt;data;
 		switch (inbuf[0]) {
 			case NETMSG_SETPLAYERNUM: {
-				gu-&gt;myPlayerNum = packet-&gt;data[1];
+				gu-&gt;SetMyPlayer(packet-&gt;data[1]);
 				logOutput.Print(&quot;Became player %i&quot;, gu-&gt;myPlayerNum);
 			} break;
 			case NETMSG_GAMEDATA: {
@@ -489,11 +397,11 @@
 	{
 		//HACK: make gs read the setup if we just read it out of the demofile
 		gs-&gt;LoadFromSetup(gameSetup);
-		gu-&gt;LoadFromSetup(gameSetup);
+		gu-&gt;SetMyPlayer(0); //HACK load data for player 0
 	}
 
 	if (!hasSetup)
-		gu-&gt;myPlayerNum = scanner.GetFileHeader().maxPlayerNum + 1;
+		gu-&gt;SetMyPlayer(scanner.GetFileHeader().maxPlayerNum + 1); //HACK pt. #2: set real player num
 
 	boost::shared_ptr&lt;const RawPacket&gt; buf(scanner.GetData(static_cast&lt;float&gt;(INT_MAX)));
 	while ( buf )
@@ -502,8 +410,8 @@
 		{
 			GameData *data = new GameData(boost::shared_ptr&lt;const RawPacket&gt;(buf));
 			good_fpu_control_registers(&quot;before CGameServer creation&quot;);
-			gameServer = new CGameServer(hasSetup ? gameSetup-&gt;hostport : springDefaultPort, false, data, gameSetup, demoName);
-			gameServer-&gt;AddLocalClient(gameSetup ? gameSetup-&gt;myPlayerNum : 0);
+			gameServer = new CGameServer(settings-&gt;hostport, false, data, gameSetup, demoName);
+			gameServer-&gt;AddLocalClient(settings-&gt;myPlayerName, std::string(VERSION_STRING_DETAILED));
 			good_fpu_control_registers(&quot;after CGameServer creation&quot;);
 			break;
 		}
@@ -663,6 +571,26 @@
 	}
 }
 
+void CPreGame::LoadLua()
+{
+	const string luaGaiaStr  = configHandler.GetString(&quot;LuaGaia&quot;,  &quot;1&quot;);
+	const string luaRulesStr = configHandler.GetString(&quot;LuaRules&quot;, &quot;1&quot;);
+	gs-&gt;useLuaGaia  = CLuaGaia::SetConfigString(luaGaiaStr);
+	gs-&gt;useLuaRules = CLuaRules::SetConfigString(luaRulesStr);
+	if (gs-&gt;useLuaGaia) {
+		gs-&gt;gaiaTeamID = gs-&gt;activeTeams;
+		gs-&gt;gaiaAllyTeamID = gs-&gt;activeAllyTeams;
+		gs-&gt;activeTeams++;
+		gs-&gt;activeAllyTeams++;
+		CTeam* team = gs-&gt;Team(gs-&gt;gaiaTeamID);
+		team-&gt;color[0] = 255;
+		team-&gt;color[1] = 255;
+		team-&gt;color[2] = 255;
+		team-&gt;color[3] = 255;
+		team-&gt;gaia = true;
+		gs-&gt;SetAllyTeam(gs-&gt;gaiaTeamID, gs-&gt;gaiaAllyTeamID);
+	}
+}
 
 void CPreGame::GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet)
 {

Modified: branches/caiinterface/rts/Game/PreGame.h
===================================================================
--- branches/caiinterface/rts/Game/PreGame.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/PreGame.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -3,6 +3,7 @@
 
 #include &lt;string&gt;
 #include &lt;boost/shared_ptr.hpp&gt;
+#include &lt;boost/scoped_ptr.hpp&gt;
 
 #include &quot;GameController.h&quot;
 
@@ -10,6 +11,7 @@
 class CInfoConsole;
 class CLoadSaveHandler;
 class GameData;
+class LocalSetup;
 namespace netcode {
 	class RawPacket;
 }
@@ -32,7 +34,7 @@
 class CPreGame : public CGameController
 {
 public:
-	CPreGame(bool server, const std::string&amp; demo, const std::string&amp; save);
+	CPreGame(const LocalSetup* setup, const std::string&amp; demo, const std::string&amp; save);
 	virtual ~CPreGame();
 
 	bool Draw();
@@ -68,13 +70,13 @@
 	
 	/// Map all required archives depending on selected mod(s)
 	static void LoadMod(const std::string&amp; modName);
+	
+	void LoadLua();
 
 	void GameDataReceived(boost::shared_ptr&lt;const netcode::RawPacket&gt; packet);
 	
-	const bool server;
 	enum State {
 		UNKNOWN,
-		WAIT_ON_ADDRESS, // wait for user to write server address
 		WAIT_ON_USERINPUT, // wait for user to set script, map, mod
 		WAIT_CONNECTING, // connecting to server
 		WAIT_ON_GAMEDATA, // wait for the server to send us the GameData
@@ -90,7 +92,7 @@
 	We won't start until we recieved this
 	*/
 	const GameData* gameData;
-
+	boost::scoped_ptr&lt;const LocalSetup&gt; settings;
 	std::string modArchive;
 	std::string demoFile;
 	CLoadSaveHandler *savefile;

Copied: branches/caiinterface/rts/Game/SelectMenu.cpp (from rev 6941, trunk/rts/Game/SelectMenu.cpp)
===================================================================
--- branches/caiinterface/rts/Game/SelectMenu.cpp	                        (rev 0)
+++ branches/caiinterface/rts/Game/SelectMenu.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -0,0 +1,149 @@
+#include &quot;SelectMenu.h&quot;
+
+#include &lt;SDL_keysym.h&gt;
+#include &lt;SDL_timer.h&gt;
+#include &lt;SDL_types.h&gt;
+
+#include &quot;GameSetup.h&quot;
+#include &quot;PreGame.h&quot;
+#include &quot;Platform/Clipboard.h&quot;
+#include &quot;Platform/ConfigHandler.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;Util.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;Rendering/glFont.h&quot;
+
+using std::string;
+
+extern Uint8* keys;
+extern bool globalQuit;
+
+
+SelectMenu::SelectMenu(bool server) : isServer(server)
+{
+	if (!isServer)
+	{
+		userInput=configHandler.GetString(&quot;address&quot;,&quot;&quot;);
+		writingPos = userInput.length();
+		userPrompt = &quot;Enter server address: &quot;;
+		userWriting = true;
+	}
+}
+
+
+int SelectMenu::KeyPressed(unsigned short k,bool isRepeat)
+{
+	if (k == SDLK_ESCAPE){
+		if(keys[SDLK_LSHIFT]){
+			logOutput.Print(&quot;User exited&quot;);
+			globalQuit=true;
+		} else
+			logOutput.Print(&quot;Use shift-esc to quit&quot;);
+	}
+
+	if (userWriting) {
+		keys[k] = true;
+		if (k == SDLK_v &amp;&amp; keys[SDLK_LCTRL]){
+			CClipboard clipboard;
+			const string text = clipboard.GetContents();
+			userInput.insert(writingPos, text);
+			writingPos += text.length();
+			return 0;
+		}
+		if(k == SDLK_BACKSPACE){
+			if (!userInput.empty() &amp;&amp; (writingPos &gt; 0)) {
+				userInput.erase(writingPos - 1, 1);
+				writingPos--;
+			}
+			return 0;
+		}
+		if (k == SDLK_DELETE) {
+			if (!userInput.empty() &amp;&amp; (writingPos &lt; (int)userInput.size())) {
+				userInput.erase(writingPos, 1);
+			}
+			return 0;
+		}
+		else if (k == SDLK_LEFT) {
+			writingPos = std::max(0, std::min((int)userInput.length(), writingPos - 1));
+		}
+		else if (k == SDLK_RIGHT) {
+			writingPos = std::max(0, std::min((int)userInput.length(), writingPos + 1));
+		}
+		else if (k == SDLK_HOME) {
+			writingPos = 0;
+		}
+		else if (k == SDLK_END) {
+			writingPos = (int)userInput.length();
+		}
+		if (k == SDLK_RETURN){
+			userWriting = false;
+			return 0;
+		}
+		return 0;
+	}
+
+	return 0;
+}
+
+bool SelectMenu::Draw()
+{
+	SDL_Delay(10); // milliseconds
+	PrintLoadMsg(&quot;&quot;, false); // just clear screen and set up matrices etc.
+
+	if (userWriting) {
+		const std::string tempstring = userPrompt + userInput;
+
+		const float xStart = 0.10f;
+		const float yStart = 0.75f;
+
+		const float fontScale = 1.0f;
+
+		// draw the caret
+		const int caretPos = userPrompt.length() + writingPos;
+		const string caretStr = tempstring.substr(0, caretPos);
+		const float caretWidth = font-&gt;CalcTextWidth(caretStr.c_str());
+		char c = userInput[writingPos];
+		if (c == 0) { c = ' '; }
+		const float cw = fontScale * font-&gt;CalcCharWidth(c);
+		const float csx = xStart + (fontScale * caretWidth);
+		glDisable(GL_TEXTURE_2D);
+		const float f = 0.5f * (1.0f + fastmath::sin((float)SDL_GetTicks() * 0.015f));
+		glColor4f(f, f, f, 0.75f);
+		glRectf(csx, yStart, csx + cw, yStart + fontScale * font-&gt;GetHeight());
+		glEnable(GL_TEXTURE_2D);
+
+		glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+		font-&gt;glPrintAt(xStart, yStart, fontScale, tempstring.c_str());
+	}
+
+	return true;
+}
+
+bool SelectMenu::Update()
+{
+	if (isServer)
+	{
+		LocalSetup* mySettings = new LocalSetup();
+		mySettings-&gt;myPlayerName = configHandler.GetString(&quot;name&quot;, &quot;unnamed&quot;);
+		mySettings-&gt;isHost = true;
+		pregame = new CPreGame(mySettings, &quot;&quot;, &quot;&quot;);
+		delete this;
+	}
+	else
+	{
+		// we are a client, wait for user to type address
+		if (!userWriting)
+		{
+			configHandler.SetString(&quot;address&quot;,userInput);
+			LocalSetup* mySettings = new LocalSetup();
+			mySettings-&gt;myPlayerName = configHandler.GetString(&quot;name&quot;, &quot;unnamed&quot;);
+			mySettings-&gt;hostip = userInput;
+			mySettings-&gt;isHost = false;
+			pregame = new CPreGame(mySettings, &quot;&quot;, &quot;&quot;);
+			delete this;
+		}
+	}
+
+
+	return true;
+}

Copied: branches/caiinterface/rts/Game/SelectMenu.h (from rev 6941, trunk/rts/Game/SelectMenu.h)
===================================================================
--- branches/caiinterface/rts/Game/SelectMenu.h	                        (rev 0)
+++ branches/caiinterface/rts/Game/SelectMenu.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -0,0 +1,19 @@
+#ifndef SELECT_MENU
+#define SELECT_MENU
+
+#include &quot;GameController.h&quot;
+
+class SelectMenu : public CGameController
+{
+public:
+	SelectMenu(bool server);
+	
+	bool Draw();
+	int KeyPressed(unsigned short k, bool isRepeat);
+	bool Update();
+	
+private:
+	bool isServer;
+};
+
+#endif
\ No newline at end of file

Modified: branches/caiinterface/rts/Game/SelectedUnits.cpp
===================================================================
--- branches/caiinterface/rts/Game/SelectedUnits.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/SelectedUnits.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -78,6 +78,9 @@
 
 CSelectedUnits::AvailableCommandsStruct CSelectedUnits::GetAvailableCommands()
 {
+	GML_RECMUTEX_LOCK(sel); // GetAvailableCommands
+	GML_STDMUTEX_LOCK(group); // GetAvailableCommands
+
 	possibleCommandsChanged = false;
 
 	if (selectedGroup != -1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
@@ -248,6 +251,9 @@
 
 void CSelectedUnits::GiveCommand(Command c, bool fromUser)
 {
+	GML_RECMUTEX_LOCK(sel); // GiveCommand
+	GML_STDMUTEX_LOCK(group); // GiveCommand
+
 //	logOutput.Print(&quot;Command given %i&quot;,c.id);
 	if ((gu-&gt;spectating &amp;&amp; !gs-&gt;godMode) || selectedUnits.empty()) {
 		return;
@@ -360,7 +366,8 @@
 {
 	// if unit is being transported by eg. Hulk or Atlas
 	// then we should not be able to select it
-	if (unit-&gt;transporter != NULL &amp;&amp; !unit-&gt;transporter-&gt;unitDef-&gt;isFirePlatform) {
+	CTransportUnit *trans=unit-&gt;GetTransporter();
+	if (trans != NULL &amp;&amp; !trans-&gt;unitDef-&gt;isFirePlatform) {
 		return;
 	}
 
@@ -423,7 +430,7 @@
 void CSelectedUnits::SelectGroup(int num)
 {
 	GML_RECMUTEX_LOCK(sel); // SelectGroup
-//	GML_STDMUTEX_LOCK(group); // SelectGroup. not needed? only reading group
+	GML_STDMUTEX_LOCK(group); // SelectGroup. not needed? only reading group
 
 	ClearSelected();
 	selectedGroup=num;
@@ -445,6 +452,8 @@
 
 void CSelectedUnits::Draw()
 {
+	glDisable(GL_TEXTURE_2D);
+	glDepthMask(false);
 	glDisable(GL_DEPTH_TEST);
 	glEnable(GL_BLEND); // for line smoothing
 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
@@ -471,11 +480,11 @@
 			if (unit-&gt;isIcon) {
 				continue;
 			}
-			const float3 pos(unit-&gt;pos + unit-&gt;speed * gu-&gt;timeOffset);
-			glVertexf3(pos + float3( unit-&gt;xsize * 4, 0,  unit-&gt;ysize * 4));
-			glVertexf3(pos + float3(-unit-&gt;xsize * 4, 0,  unit-&gt;ysize * 4));
-			glVertexf3(pos + float3(-unit-&gt;xsize * 4, 0, -unit-&gt;ysize * 4));
-			glVertexf3(pos + float3( unit-&gt;xsize * 4, 0, -unit-&gt;ysize * 4));
+
+			glVertexf3(unit-&gt;drawPos + float3( unit-&gt;xsize * 4, 0,  unit-&gt;ysize * 4));
+			glVertexf3(unit-&gt;drawPos + float3(-unit-&gt;xsize * 4, 0,  unit-&gt;ysize * 4));
+			glVertexf3(unit-&gt;drawPos + float3(-unit-&gt;xsize * 4, 0, -unit-&gt;ysize * 4));
+			glVertexf3(unit-&gt;drawPos + float3( unit-&gt;xsize * 4, 0, -unit-&gt;ysize * 4));
 		}
 		glEnd();
 	}
@@ -483,6 +492,7 @@
 	// highlight queued build sites if we are about to build something
 	// (or old-style, whenever the shift key is being held down)
 	if (cmdColors.buildBox[3] &gt; 0.0f) {
+		//GML_RECMUTEX_LOCK(gui); // Draw. Not needed because of draw thread.
 		if (!selectedUnits.empty() &amp;&amp;
 				((cmdColors.BuildBoxesOnShift() &amp;&amp; keys[SDLK_LSHIFT]) ||
 				 ((guihandler-&gt;inCommand &gt;= 0) &amp;&amp;
@@ -516,6 +526,8 @@
 	glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
 	glDisable(GL_BLEND);
 	glEnable(GL_DEPTH_TEST);
+	glDepthMask(true);
+	glEnable(GL_TEXTURE_2D);
 }
 
 
@@ -683,6 +695,8 @@
 
 void CSelectedUnits::PossibleCommandChange(CUnit* sender)
 {
+	GML_RECMUTEX_LOCK(sel); // PossibleCommandChange
+
 	if (sender == NULL || selectedUnits.find(sender) != selectedUnits.end())
 		possibleCommandsChanged = true;
 }
@@ -742,6 +756,7 @@
 {
 	GML_RECMUTEX_LOCK(sel); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
 	GML_STDMUTEX_LOCK(group); // GetTooltip
+
 	std::string s;
 	if ((selectedGroup != -1) &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai) {
 		s = &quot;Group selected&quot;;
@@ -819,6 +834,7 @@
 {
 	GML_RECMUTEX_LOCK(sel); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc --&gt; SetCommandPage
 	GML_STDMUTEX_LOCK(group); // SetCommandPage
+
 	if(selectedGroup!=-1 &amp;&amp; grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;ai){
 		grouphandlers[gu-&gt;myTeam]-&gt;groups[selectedGroup]-&gt;lastCommandPage=page;
 	}
@@ -832,6 +848,8 @@
 
 void CSelectedUnits::SendSelection(void)
 {
+	GML_RECMUTEX_LOCK(sel); // SendSelection
+
 	// first, convert CUnit* to unit IDs.
 	std::vector&lt;short&gt; selectedUnitIDs(selectedUnits.size());
 	std::vector&lt;short&gt;::iterator i = selectedUnitIDs.begin();

Modified: branches/caiinterface/rts/Game/SelectedUnits.h
===================================================================
--- branches/caiinterface/rts/Game/SelectedUnits.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/SelectedUnits.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -17,8 +17,6 @@
 	void Init();
 	void SelectGroup(int num);
 	void AiOrder(int unitid, const Command&amp; c, int playerID);
-	void SendOrdersToUnits(const vector&lt;int&gt;&amp; unitIDs,
-	                       const vector&lt;Command&gt;&amp; commands);
 	int GetDefaultCmd(CUnit* unit,CFeature* feature);
 	bool CommandsChanged();
 	void NetOrder(Command&amp; c,int player);

Modified: branches/caiinterface/rts/Game/Server/MsgStrings.h
===================================================================
--- branches/caiinterface/rts/Game/Server/MsgStrings.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/Server/MsgStrings.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -18,10 +18,10 @@
 const std::string SyncError = &quot;Sync error for %s in frame %d (%x)&quot;;
 const std::string NoSyncCheck = &quot;Warning: Sync checking disabled!&quot;;
 
-const std::string NewConnection = &quot;New connection established in %d (wanted number was %d)&quot;;
+const std::string NewConnection = &quot;Player %s with number %d connected (client version %s)&quot;;
 const std::string ConnectionReject = &quot;Connection attempt rejected (Message ID: %d Network version: %d Datalength: %d)&quot;;
 const std::string WrongPlayer = &quot;Got message %d from %d claiming to be from %d&quot;;
-const std::string PlayerJoined = &quot;Player %s joined as %d&quot;;
+const std::string PlayerJoined = &quot;Player %s finished loading and joined as player %d&quot;;
 const std::string PlayerLeft = &quot;Player %s left the game: %s&quot;;
 
 const std::string NoStartposChange = &quot;%s tried to change his startposition illegally&quot;;

Modified: branches/caiinterface/rts/Game/Team.cpp
===================================================================
--- branches/caiinterface/rts/Game/Team.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/Team.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -318,10 +318,10 @@
 
 void CTeam::SlowUpdate()
 {
-	currentStats.metalProduced  += metalIncome;
-	currentStats.energyProduced += energyIncome;
-	currentStats.metalUsed  += metalUpkeep + metalExpense;
-	currentStats.energyUsed += energyUpkeep + energyExpense;
+	currentStats.metalProduced  += prevMetalIncome;
+	currentStats.energyProduced += prevEnergyIncome;
+	currentStats.metalUsed  += prevMetalUpkeep + prevMetalExpense;
+	currentStats.energyUsed += prevEnergyUpkeep + prevEnergyExpense;
 
 	float eShare = 0.0f, mShare = 0.0f;
 	for (int a = 0; a &lt; gs-&gt;activeTeams; ++a) {
@@ -370,11 +370,11 @@
 	}
 
 	if (metal &gt; metalStorage) {
-		currentStats.metalExcess+=metal-metalStorage;
+		currentStats.metalExcess += (metal - metalStorage);
 		metal = metalStorage;
 	}
 	if (energy &gt; energyStorage) {
-		currentStats.energyExcess+=energy-energyStorage;
+		currentStats.energyExcess += (energy - energyStorage);
 		energy = energyStorage;
 	}
 

Modified: branches/caiinterface/rts/Game/UI/GuiHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/GuiHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/GuiHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -55,6 +55,7 @@
 #include &quot;System/LogOutput.h&quot;
 #include &quot;System/Platform/ConfigHandler.h&quot;
 #include &quot;System/Util.h&quot;
+#include &quot;System/myMath.h&quot;
 
 extern Uint8 *keys;
 
@@ -451,7 +452,7 @@
 
 int CGuiHandler::FindInCommandPage()
 {
-	GML_RECMUTEX_LOCK(gui); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; FindInCommandPage
+//	GML_RECMUTEX_LOCK(gui); // CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; FindInCommandPage. Not needed, Draw thread.
 
 	if ((inCommand &lt; 0) || (inCommand &gt;= commands.size())) {
 		return -1;
@@ -469,7 +470,7 @@
 void CGuiHandler::RevertToCmdDesc(const CommandDescription&amp; cmdDesc,
                                   bool defaultCommand, bool samePage)
 {
-	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc
+//	GML_RECMUTEX_LOCK(gui); // updates inCommand, CGame::Draw --&gt; RunLayoutCommand --&gt; LayoutIcons --&gt; RevertToCmdDesc. Not needed, protected via other func.
 
 	for (int a = 0; a &lt; commands.size(); ++a) {
 		if (commands[a].id == cmdDesc.id) {
@@ -966,6 +967,7 @@
 
 void CGuiHandler::SetCursorIcon() const
 {
+//	GML_RECMUTEX_LOCK(gui); // SetCursorIcon. Not needed, protected via Update
 	string newCursor = &quot;cursornormal&quot;;
 	mouse-&gt;cursorScale = 1.0f;
 
@@ -1081,6 +1083,7 @@
 
 void CGuiHandler::MouseRelease(int x, int y, int button, float3&amp; camerapos, float3&amp; mousedir)
 {
+//	GML_RECMUTEX_LOCK(gui); // not needed, draw thread + read only
 	int iconCmd = -1;
 
 	if (activeMousePress) {
@@ -1398,6 +1401,8 @@
 
 void CGuiHandler::RunCustomCommands(const std::vector&lt;std::string&gt;&amp; cmds, bool rmb)
 {
+	GML_RECMUTEX_LOCK(gui); // LuaUnsyncedCtrl::SendCommands --&gt; RunCustomCommands
+
 	static int depth = 0;
 	if (depth &gt; 8) {
 		return; // recursion protection
@@ -1513,6 +1518,7 @@
 		return -1;
 	}
 
+	GML_RECMUTEX_LOCK(sel); // anti deadlock
 	GML_RECMUTEX_LOCK(quad); // GetDefaultCommand
 	CUnit* unit = NULL;
 //	GML_RECMUTEX_LOCK(unit); // GetDefaultCommand
@@ -1525,7 +1531,7 @@
 		const float3 camPos = camerapos;
 		const float3 camDir = mousedir;
 		const float viewRange = gu-&gt;viewRange*1.4f;
-		const float dist = helper-&gt;GuiTraceRay(camPos, camDir, viewRange, unit, 20, true);
+		const float dist = helper-&gt;GuiTraceRay(camPos, camDir, viewRange, unit, true);
 		const float dist2 = helper-&gt;GuiTraceRayFeature(camPos, camDir, viewRange, feature);
 		const float3 hit = camPos + camDir*dist;
 
@@ -1560,6 +1566,7 @@
 
 bool CGuiHandler::ProcessLocalActions(const Action&amp; action)
 {
+//	GML_RECMUTEX_LOCK(gui); // not needed, protected via other functions
 	// do not process these actions if the control panel is not visible
 	if (iconsCount &lt;= 0) {
 		return false;
@@ -1817,7 +1824,7 @@
 bool CGuiHandler::SetActiveCommand(const Action&amp; action,
                                    const CKeySet&amp; ks, int actionIndex)
 {
-	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand
+	GML_RECMUTEX_LOCK(gui); // SetActiveCommand - updates inCommand, called by LuaUnsyncedCtrl
 
 	if (ProcessLocalActions(action)) {
 		return true;
@@ -2092,7 +2099,7 @@
 
 std::string CGuiHandler::GetTooltip(int x, int y)
 {
-	GML_RECMUTEX_LOCK(gui); // GetTooltip
+	GML_RECMUTEX_LOCK(gui); // LuaUnsyncedRead::GetCurrentTooltip --&gt; CMouseHandler::GetCurrentTooltip --&gt; GetTooltip
 
 	std::string s;
 
@@ -2119,11 +2126,13 @@
 }
 
 // CALLINFO:
-// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
-// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; CMiniMap::gettooltip --&gt; GetBuildTooltip
+// luaunsyncedread::getcurrenttooltip --&gt; mousehandler::getcurrenttooltip
+// tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
+// mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+// mousehandler::getcurrenttooltip --&gt; CMiniMap::gettooltip --&gt; GetBuildTooltip
 std::string CGuiHandler::GetBuildTooltip() const
 {
-	GML_RECMUTEX_LOCK(gui); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
+	GML_RECMUTEX_LOCK(gui); // luaunsyncedread::getcurrenttooltip --&gt; mousehandler::getcurrenttooltip --&gt; GetBuildTooltip
 
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size()) &amp;&amp;
 	    (commands[inCommand].type == CMDTYPE_ICON_BUILDING)) {
@@ -2133,7 +2142,7 @@
 }
 
 
-Command CGuiHandler::GetOrderPreview(void)
+Command CGuiHandler::GetOrderPreview(void) // Called from GroupAICallback
 {
 	return GetCommand(mouse-&gt;lastx, mouse-&gt;lasty, -1, true);
 }
@@ -2245,7 +2254,7 @@
 			Command c;
 
 			c.id=commands[tempInCommand].id;
-			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
+			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,true);
 			if (!unit){
 				return defaultRet;
 			}
@@ -2259,7 +2268,7 @@
 			c.id=commands[tempInCommand].id;
 
 			CUnit* unit=0;
-			float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
+			float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,true);
 			if(dist2&gt;gu-&gt;viewRange*1.4f-300){
 				return defaultRet;
 			}
@@ -2304,7 +2313,7 @@
 				c.params[2] = pos.z;
 
 				if (!commands[tempInCommand].params.empty() &amp;&amp;
-				    pos.distance2D(pos2) &gt; atof(commands[tempInCommand].params[0].c_str())) {
+				    pos.SqDistance2D(pos2) &gt; Square(atof(commands[tempInCommand].params[0].c_str()))) {
 					float3 dif=pos2-pos;
 					dif.ANormalize();
 					pos2=pos+dif*atoi(commands[tempInCommand].params[0].c_str());
@@ -2330,7 +2339,7 @@
 			if(mouse-&gt;buttons[button].movement&lt;4){
 				CUnit* unit=0;
 				CFeature* feature=0;
-				float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
+				float dist2=helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,true);
 				float dist3=helper-&gt;GuiTraceRayFeature(camerapos,mousedir,gu-&gt;viewRange*1.4f,feature);
 
 				if(dist2&gt;gu-&gt;viewRange*1.4f-300 &amp;&amp; (commands[tempInCommand].type!=CMDTYPE_ICON_UNIT_FEATURE_OR_AREA || dist3&gt;gu-&gt;viewRange*1.4f-300)){
@@ -2374,8 +2383,7 @@
 			if (mouse-&gt;buttons[button].movement &lt; 16) {
 				CUnit* unit=0;
 
-				float dist2=helper-&gt;GuiTraceRay(
-					camerapos, mousedir, gu-&gt;viewRange*1.4f, unit, 20, true);
+				float dist2=helper-&gt;GuiTraceRay(camerapos, mousedir, gu-&gt;viewRange*1.4f, unit, true);
 
 				if(dist2&gt;gu-&gt;viewRange*1.4f-300) {
 					return defaultRet;
@@ -2426,9 +2434,10 @@
 
 
 static bool WouldCancelAnyQueued(const BuildInfo&amp; b) {
+	GML_RECMUTEX_LOCK(sel); //drawmapstuff -&gt; getbuildpos --&gt; fillrowofbuildpos -&gt; wouldcancelanyqueued
+
 	Command c;
 	b.FillCmd(c);
-	GML_RECMUTEX_LOCK(sel); //drawmapstuff -&gt; getbuildpos --&gt; fillrowofbuildpos -&gt; wouldcancelanyqueued
 	CUnitSet::iterator ui = selectedUnits.selectedUnits.begin();
 	for(;ui != selectedUnits.selectedUnits.end(); ++ui){
 		if((*ui)-&gt;commandAI-&gt;WillCancelQueued(c))
@@ -2462,8 +2471,10 @@
 	if(GetQueueKeystate() &amp;&amp; keys[SDLK_LCTRL])
 	{
 		CUnit* unit=0;
-		GML_RECMUTEX_LOCK(unit); // GetBuildCommand accesses activeunits. drawmapstuff -&gt; getbuildpos
-		helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,true);
+
+		GML_RECMUTEX_LOCK(quad); //unit); // GetBuildCommand accesses activeunits. drawmapstuff -&gt; getbuildpos
+
+		helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,true);
 		if(unit){
 			other.def = unit-&gt;unitDef;
 			other.pos = unit-&gt;pos;
@@ -2562,7 +2573,7 @@
 
 void CGuiHandler::Draw()
 {
-	GML_RECMUTEX_LOCK(gui); // accesses iconsCount. Draw
+//	GML_RECMUTEX_LOCK(gui); // accesses iconsCount. Draw
 //	GML_RECMUTEX_LOCK(quad); // update accesses setcursoricon-&gt;getdefaultcommand-&gt;guitraceray which accesses the quadfield
 
 	Update();
@@ -3232,7 +3243,8 @@
 
 void CGuiHandler::DrawNumberInput() // Only called by drawbuttons
 {
-	GML_RECMUTEX_LOCK(gui); // DrawNumberInput
+//	GML_RECMUTEX_LOCK(gui); // DrawNumberInput
+
 	// draw the value for CMDTYPE_NUMBER commands
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		const CommandDescription&amp; cd = commands[inCommand];
@@ -3456,7 +3468,7 @@
 
 void CGuiHandler::DrawMapStuff(int onMinimap)
 {
-	GML_RECMUTEX_LOCK(gui); // DrawMapStuff
+//	GML_RECMUTEX_LOCK(gui); // DrawMapStuff
 
 	if (!onMinimap) {
 		glEnable(GL_DEPTH_TEST);
@@ -3566,8 +3578,8 @@
 							for(int i = 0; i &lt;= divs; ++i) {
 								const float radians = (2 * PI) * (float)i / (float)divs;
 								float3 p(pos.x, 0.0f, pos.z);
-								p.x += sin(radians) * radius;
-								p.z += cos(radians) * radius;
+								p.x += fastmath::sin(radians) * radius;
+								p.z += fastmath::cos(radians) * radius;
 								if (!onMinimap) {
 									p.y = ground-&gt;GetHeight(pos.x, pos.z) + 5.0f;
 								}
@@ -3626,7 +3638,7 @@
 			unit = minimap-&gt;GetSelectUnit(camerapos);
 		} else {
 			// ignoring the returned distance
-			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,20,false);
+			helper-&gt;GuiTraceRay(camerapos,mousedir,gu-&gt;viewRange*1.4f,unit,false);
 		}
 		if (unit &amp;&amp; ((unit-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) || gu-&gt;spectatingFullView)) {
 			pointedAt = unit;
@@ -3692,23 +3704,20 @@
 				DrawSensorRange(unitdef-&gt;sonarJamRadius, cmdColors.rangeSonarJammer, p);
 			}
 			// draw interceptor range
-			const WeaponDef* wd = NULL;
-			const CWeapon* w = NULL;
-			if (enemyUnit) {
-				wd = unitdef-&gt;stockpileWeaponDef;
-			} else {
-				w = unit-&gt;stockpileWeapon;
-				if (w != NULL) {
-					wd = w-&gt;weaponDef;
-				}
-			}
-			if ((wd != NULL) &amp;&amp; wd-&gt;interceptor) {
-				if (enemyUnit || w-&gt;numStockpiled) {
+			if (unitdef-&gt;maxCoverage &gt; 0.0f) {
+				const CWeapon* w = NULL; //will be checked if any missiles are ready
+				if (!enemyUnit) {
+					w = unit-&gt;stockpileWeapon;
+					if (w != NULL &amp;&amp; !w-&gt;weaponDef-&gt;interceptor) {
+						w = NULL; //if this isn't the interceptor, then don't use it
+					}
+				} //shows as on if enemy, a non-stockpiled weapon, or if the stockpile has a missile
+				if (enemyUnit || (w == NULL) || w-&gt;numStockpiled) {
 					glColor4fv(cmdColors.rangeInterceptorOn);
 				} else {
 					glColor4fv(cmdColors.rangeInterceptorOff);
 				}
-				glSurfaceCircle(unit-&gt;pos, wd-&gt;coverageRange, 40);
+				glSurfaceCircle(unit-&gt;pos, unitdef-&gt;maxCoverage, 40);
 			}
 		}
 	}
@@ -3804,7 +3813,9 @@
 
 					std::vector&lt;Command&gt; cv;
 					if (GetQueueKeystate()) {
+
 						GML_RECMUTEX_LOCK(sel); // DrawMapStuff
+
 						Command c;
 						bpi-&gt;FillCmd(c);
 						std::vector&lt;Command&gt; temp;
@@ -3839,7 +3850,9 @@
 	int defcmd = GetDefaultCommand(mouse-&gt;lastx, mouse-&gt;lasty, camerapos, mousedir);
 	if ((inCommand&gt;=0 &amp;&amp; inCommand&lt;commands.size() &amp;&amp; commands[inCommand].id==CMD_ATTACK) ||
 	    (inCommand==-1 &amp;&amp; defcmd&gt;0 &amp;&amp; commands[defcmd].id==CMD_ATTACK)){
+
 		GML_RECMUTEX_LOCK(sel); // DrawMapStuff
+
 		for(CUnitSet::iterator si=selectedUnits.selectedUnits.begin(); si!=selectedUnits.selectedUnits.end(); ++si) {
 			CUnit* unit = *si;
 			if (unit == pointedAt) {
@@ -3923,12 +3936,14 @@
 void CGuiHandler::DrawCentroidCursor()
 {
 	GML_RECMUTEX_LOCK(sel); // CMouseHandler::DrawCursor --&gt; DrawCentroidCursor
+
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 	if (selUnits.size() &lt; 2) {
 		return;
 	}
 
-	GML_RECMUTEX_LOCK(gui); // DrawCentroidCursor
+//	GML_RECMUTEX_LOCK(gui); // DrawCentroidCursor. Not needed, Draw thread.
+
 	int cmd = -1;
 	if ((inCommand &gt;= 0) &amp;&amp; (inCommand &lt; commands.size())) {
 		cmd = commands[inCommand].id;
@@ -3996,7 +4011,7 @@
 	glBegin(GL_TRIANGLE_FAN);
 		glVertexf3(pos);
 		for(int a=0;a&lt;=40;++a){
-			float3 p(cos(a*2*PI/40)*radius,0,sin(a*2*PI/40)*radius);
+			float3 p(fastmath::cos(a*2*PI/40)*radius,0,fastmath::sin(a*2*PI/40)*radius);
 			p+=pos;
 			p.y=ground-&gt;GetHeight(p.x,p.z);
 			glVertexf3(p);
@@ -4029,7 +4044,7 @@
 	float3 forward=(pos1-pos2).cross(UpVector);
 	forward.ANormalize();
 	float3 side=forward.cross(UpVector);
-	if(pos1.distance2D(pos2)&gt;maxSize){
+	if(pos1.SqDistance2D(pos2)&gt;maxSize*maxSize){
 		pos2=pos1+side*maxSize;
 		pos2.y=ground-&gt;GetHeight(pos2.x,pos2.z);
 	}
@@ -4289,8 +4304,8 @@
 	for (i = 0; i &lt;= cyl.divs; i++) {
 		const float radians =
 		  float(2.0 * PI) * float(i % cyl.divs) / (float)cyl.divs;
-		const float x = cyl.xc + (cyl.radius * sin(radians));
-		const float z = cyl.zc + (cyl.radius * cos(radians));
+		const float x = cyl.xc + (cyl.radius * fastmath::sin(radians));
+		const float z = cyl.zc + (cyl.radius * fastmath::cos(radians));
 		glVertex3f(x, cyl.yp, z);
 		glVertex3f(x, cyl.yn, z);
 	}
@@ -4298,16 +4313,16 @@
 	glBegin(GL_TRIANGLE_FAN); // the top
 	for (i = 0; i &lt; cyl.divs; i++) {
 		const float radians = float(2.0 * PI) * float(i) / (float)cyl.divs;
-		const float x = cyl.xc + (cyl.radius * sin(radians));
-		const float z = cyl.zc + (cyl.radius * cos(radians));
+		const float x = cyl.xc + (cyl.radius * fastmath::sin(radians));
+		const float z = cyl.zc + (cyl.radius * fastmath::cos(radians));
 		glVertex3f(x, cyl.yp, z);
 	}
 	glEnd();
 	glBegin(GL_TRIANGLE_FAN); // the bottom
 	for (i = (cyl.divs - 1); i &gt;= 0; i--) {
 		const float radians = float(2.0 * PI) * float(i) / (float)cyl.divs;
-		const float x = cyl.xc + (cyl.radius * sin(radians));
-		const float z = cyl.zc + (cyl.radius * cos(radians));
+		const float x = cyl.xc + (cyl.radius * fastmath::sin(radians));
+		const float z = cyl.zc + (cyl.radius * fastmath::cos(radians));
 		glVertex3f(x, cyl.yn, z);
 	}
 	glEnd();

Modified: branches/caiinterface/rts/Game/UI/InfoConsole.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/InfoConsole.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/InfoConsole.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -24,9 +24,9 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-const int CInfoConsole::maxRawLines = 1024;
+const int CInfoConsole::maxRawLines   = 1024;
+const int CInfoConsole::maxLastMsgPos = 10;
 
-
 CInfoConsole::CInfoConsole():
 	disabled(false), newLines(0), rawId(0),
 	lastMsgIter(lastMsgPositions.begin())
@@ -60,9 +60,8 @@
 
 void CInfoConsole::Draw()
 {
-	if (disabled) {
-		return;
-	}
+	if (disabled) return;
+	if (!font) return;
 
 	boost::recursive_mutex::scoped_lock scoped_lock(infoConsoleMutex);
 
@@ -145,17 +144,15 @@
 }
 
 
-void CInfoConsole::NotifyLogMsg(int zone, const char *text)
+void CInfoConsole::NotifyLogMsg(CLogSubsystem&amp; subsystem, const char* text)
 {
+	if (!font) return;
+
 	PUSH_CODE_MODE;
 	ENTER_MIXED;
 	boost::recursive_mutex::scoped_lock scoped_lock(infoConsoleMutex);
 
-	RawLine rl;
-	rl.text = text;
-	rl.zone = zone;
-	rl.time = 0; // filled in later
-	rl.id = rawId;
+	RawLine rl(text, &amp;subsystem, rawId);
 	rawId++;
 	rawData.push_back(rl);
 	if (rawData.size() &gt; maxRawLines) {
@@ -210,7 +207,7 @@
 
 void CInfoConsole::SetLastMsgPos(const float3&amp; pos)
 {
-	if (lastMsgPositions.size() &lt; 10) {
+	if (lastMsgPositions.size() &lt; maxLastMsgPos) {
 		lastMsgPositions.push_front(pos);
 	} else {
 		lastMsgPositions.push_front(pos);

Modified: branches/caiinterface/rts/Game/UI/InfoConsole.h
===================================================================
--- branches/caiinterface/rts/Game/UI/InfoConsole.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/InfoConsole.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -23,7 +23,7 @@
 	void Draw();
 
 	// ILogSubscriber interface implementation
-	void NotifyLogMsg(int zone, const char* txt);
+	void NotifyLogMsg(CLogSubsystem&amp; subsystem, const char* txt);
 
 
 	void SetLastMsgPos(const float3&amp; pos);
@@ -42,6 +42,9 @@
 
 		return p;
 	}
+	int GetMsgPosCount() const{
+		return lastMsgPositions.size();
+	}
 
 
 	int lifetime;
@@ -53,10 +56,14 @@
 	bool disabled;
 
 public:
+	static const int maxLastMsgPos;
+
 	static const int maxRawLines;
 	struct RawLine {
+		RawLine(const std::string&amp; text, CLogSubsystem* subsystem, int id)
+		: text(text), subsystem(subsystem), id(id), time(0) {}
 		std::string text;
-		int zone;
+		CLogSubsystem* subsystem;
 		int id;
 		Uint32 time;
 	};

Modified: branches/caiinterface/rts/Game/UI/InputReceiver.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/InputReceiver.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/InputReceiver.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -62,8 +62,9 @@
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for(ri=inputReceivers.begin();ri!=inputReceivers.end();++ri){
-		if((*ri) &amp;&amp; (*ri)-&gt;IsAbove(x,y))
-			return *ri;
+		CInputReceiver* recv= *ri;
+		if(recv &amp;&amp; recv-&gt;IsAbove(x,y))
+			return recv;
 	}
 	return 0;
 }

Modified: branches/caiinterface/rts/Game/UI/LuaUI.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/LuaUI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/LuaUI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -405,8 +405,10 @@
 			return true; // the call is not defined
 		}
 
+		// FIXME: migrate priority to subsystem...
 		lua_pushstring(L, rl.text.c_str());
-		lua_pushnumber(L, rl.zone);
+		lua_pushnumber(L, 0 /*priority*/ );
+		//lua_pushstring(L, rl.subsystem-&gt;name);
 
 		// call the function
 		if (!RunCallIn(cmdStr, 2, 0)) {

Modified: branches/caiinterface/rts/Game/UI/MiniMap.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/MiniMap.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -594,7 +594,7 @@
 
 	unitSizeX = dpr * (mapx / w);
 	unitSizeY = dpr * (mapy / h);
-	unitSelectRadius = sqrt(unitSizeX * unitSizeY);
+	unitSelectRadius = fastmath::sqrt(unitSizeX * unitSizeY);
 
 	// in mouse coordinates
 	mapBox.xmin = xpos;
@@ -662,6 +662,8 @@
 
 void CMiniMap::SelectUnits(int x, int y) const
 {
+	GML_RECMUTEX_LOCK(sel); // SelectUnits
+
 	if (!keys[SDLK_LSHIFT] &amp;&amp; !keys[SDLK_LCTRL]) {
 		selectedUnits.ClearSelected();
 	}
@@ -913,7 +915,7 @@
 		return buildTip;
 	}
 
-	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
+	GML_RECMUTEX_LOCK(quad); //unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip --&gt; gettooltip
 
 	const CUnit* unit = GetSelectUnit(GetMapPosition(x, y));
 	if (unit) {
@@ -1044,7 +1046,7 @@
 	GML_RECMUTEX_LOCK(unit); // DrawForReal
 	// draw the units
 	std::list&lt;CUnit*&gt;::iterator ui;
-	for (ui = uh-&gt;activeUnits.begin(); ui != uh-&gt;activeUnits.end(); ui++) {
+	for (ui = uh-&gt;renderUnits.begin(); ui != uh-&gt;renderUnits.end(); ui++) {
 		DrawUnit(*ui);
 	}
 //	GML_RECMUTEX_LOCK(quad);  // getselectunit accesses quadfield
@@ -1537,8 +1539,11 @@
 
 void CMiniMap::DrawNotes(void)
 {
+	if (notes.size()&lt;=0) return;
+
 	const float baseSize = gs-&gt;mapx * SQUARE_SIZE;
-	glBegin(GL_LINES);
+	CVertexArray* va=GetVertexArray();
+	va-&gt;Initialize();
 	std::list&lt;Notification&gt;::iterator ni = notes.begin();
 	while (ni != notes.end()) {
 		const float age = gu-&gt;gameTime - ni-&gt;creationTime;
@@ -1546,7 +1551,6 @@
 			ni = notes.erase(ni);
 			continue;
 		}
-		glColor4fv(ni-&gt;color);
 		for (int a = 0; a &lt; 3; ++a) {
 			const float modage = age + a * 0.1f;
 			const float rot = modage * 3;
@@ -1560,21 +1564,27 @@
 					size = baseSize * 1.4f - modage * baseSize * 0.9f;
 				}
 			}
-			const float sinSize = sin(rot) * size;
-			const float cosSize = cos(rot) * size;
+			const float sinSize = fastmath::sin(rot) * size;
+			const float cosSize = fastmath::cos(rot) * size;
 
-			DrawInMap2D(ni-&gt;pos.x + sinSize, ni-&gt;pos.z + cosSize);
-			DrawInMap2D(ni-&gt;pos.x + cosSize, ni-&gt;pos.z - sinSize);
-			DrawInMap2D(ni-&gt;pos.x + cosSize, ni-&gt;pos.z - sinSize);
-			DrawInMap2D(ni-&gt;pos.x - sinSize, ni-&gt;pos.z - cosSize);
-			DrawInMap2D(ni-&gt;pos.x - sinSize, ni-&gt;pos.z - cosSize);
-			DrawInMap2D(ni-&gt;pos.x - cosSize, ni-&gt;pos.z + sinSize);
-			DrawInMap2D(ni-&gt;pos.x - cosSize, ni-&gt;pos.z + sinSize);
-			DrawInMap2D(ni-&gt;pos.x + sinSize, ni-&gt;pos.z + cosSize);
+			const unsigned char color[4]    = {
+			      (unsigned char)(ni-&gt;color[0] * 255),
+			      (unsigned char)(ni-&gt;color[1] * 255),
+			      (unsigned char)(ni-&gt;color[2] * 255),
+			      (unsigned char)(ni-&gt;color[3] * 255)
+			};
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x + sinSize, ni-&gt;pos.z + cosSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x + cosSize, ni-&gt;pos.z - sinSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x + cosSize, ni-&gt;pos.z - sinSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x - sinSize, ni-&gt;pos.z - cosSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x - sinSize, ni-&gt;pos.z - cosSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x - cosSize, ni-&gt;pos.z + sinSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x - cosSize, ni-&gt;pos.z + sinSize, 0.0f),color);
+			va-&gt;AddVertexC(float3(ni-&gt;pos.x + sinSize, ni-&gt;pos.z + cosSize, 0.0f),color);
 		}
 		++ni;
 	}
-	glEnd();
+	va-&gt;DrawArrayC(GL_LINES);
 }
 
 

Modified: branches/caiinterface/rts/Game/UI/MouseHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/MouseHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -267,8 +267,9 @@
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	if (!game-&gt;hideInterface) {
 		for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
-			if ((*ri) &amp;&amp; (*ri)-&gt;MousePress(x, y, button)) {
-				activeReceiver = *ri;
+			CInputReceiver* recv=*ri;
+			if (recv &amp;&amp; recv-&gt;MousePress(x, y, button)) {
+				activeReceiver = recv;
 				return;
 			}
 		}
@@ -287,6 +288,8 @@
 
 void CMouseHandler::MouseRelease(int x, int y, int button)
 {
+	GML_RECMUTEX_LOCK(sel); // MouseRelease
+
 	if (button &gt; NUM_BUTTONS)
 		return;
 
@@ -437,7 +440,7 @@
 				sound-&gt;PlaySample(soundMultiselID);
 		} else {
 			CUnit* unit;
-			helper-&gt;GuiTraceRay(camera-&gt;pos,dir,gu-&gt;viewRange*1.4f,unit,20,false);
+			helper-&gt;GuiTraceRay(camera-&gt;pos,dir,gu-&gt;viewRange*1.4f,unit,false);
 			if(unit &amp;&amp; ((unit-&gt;team == gu-&gt;myTeam) || gu-&gt;spectatingFullSelect)){
 				if(buttons[button].lastRelease &lt; (gu-&gt;gameTime - doubleClickTime)){
 					if (keys[SDLK_LCTRL] &amp;&amp; selectedUnits.selectedUnits.find(unit) != selectedUnits.selectedUnits.end()) {
@@ -571,15 +574,18 @@
 	}
 }
 
-
+// CALLINFO:
+// LuaUnsyncedRead::GetCurrentTooltip
+// CTooltipConsole::Draw --&gt; CMouseHandler::GetCurrentTooltip
 std::string CMouseHandler::GetCurrentTooltip(void)
 {
 	std::string s;
 	std::deque&lt;CInputReceiver*&gt;&amp; inputReceivers = GetInputReceivers();
 	std::deque&lt;CInputReceiver*&gt;::iterator ri;
 	for (ri = inputReceivers.begin(); ri != inputReceivers.end(); ++ri) {
-		if ((*ri) &amp;&amp; (*ri)-&gt;IsAbove(lastx, lasty)) {
-			s = (*ri)-&gt;GetTooltip(lastx, lasty);
+		CInputReceiver* recv=*ri;
+		if (recv &amp;&amp; recv-&gt;IsAbove(lastx, lasty)) {
+			s = recv-&gt;GetTooltip(lastx, lasty);
 			if (s != &quot;&quot;) {
 				return s;
 			}
@@ -591,11 +597,13 @@
 		return buildTip;
 	}
 
+	GML_RECMUTEX_LOCK(sel); // anti deadlock
 	GML_RECMUTEX_LOCK(quad); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
+
 	const float range = (gu-&gt;viewRange * 1.4f);
 	CUnit* unit = NULL;
 //	GML_RECMUTEX_LOCK(unit); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
-	float udist = helper-&gt;GuiTraceRay(camera-&gt;pos, dir, range, unit, 20, true);
+	float udist = helper-&gt;GuiTraceRay(camera-&gt;pos, dir, range, unit, true);
 	CFeature* feature = NULL;
 //	GML_RECMUTEX_LOCK(feat); // tooltipconsole::draw --&gt; mousehandler::getcurrenttooltip
 	float fdist = helper-&gt;GuiTraceRayFeature(camera-&gt;pos, dir, range, feature);

Modified: branches/caiinterface/rts/Game/UI/SelectionKeyHandler.cpp
===================================================================
--- branches/caiinterface/rts/Game/UI/SelectionKeyHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/UI/SelectionKeyHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -20,6 +20,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/UnitTypes/Building.h&quot;
+#include &quot;System/myMath.h&quot;
 
 CSelectionKeyHandler *selectionKeys;
 
@@ -140,6 +141,8 @@
 
 void CSelectionKeyHandler::DoSelection(std::string selectString)
 {
+	GML_RECMUTEX_LOCK(sel); // DoSelection
+
 	std::list&lt;CUnit*&gt; selection;
 
 //	guicontroller-&gt;AddText(selectString.c_str());
@@ -188,7 +191,7 @@
 		  // team units in mouse range
 			CUnitSet* tu=&amp;gs-&gt;Team(gu-&gt;myTeam)-&gt;units;
 			for(CUnitSet::iterator ui=tu-&gt;begin();ui!=tu-&gt;end();++ui){
-				if(mp.distance((*ui)-&gt;pos)&lt;maxDist){
+				if(mp.SqDistance((*ui)-&gt;pos)&lt;Square(maxDist)){
 					selection.push_back(*ui);
 				}
 			}
@@ -196,7 +199,7 @@
 		  // all units in mouse range
 			std::list&lt;CUnit*&gt;* au=&amp;uh-&gt;activeUnits;
 			for(std::list&lt;CUnit*&gt;::iterator ui=au-&gt;begin();ui!=au-&gt;end();++ui){
-				if(mp.distance((*ui)-&gt;pos)&lt;maxDist){
+				if(mp.SqDistance((*ui)-&gt;pos)&lt;Square(maxDist)){
 					selection.push_back(*ui);
 				}
 			}

Modified: branches/caiinterface/rts/Game/WaitCommandsAI.cpp
===================================================================
--- branches/caiinterface/rts/Game/WaitCommandsAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Game/WaitCommandsAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -159,6 +159,8 @@
 
 void CWaitCommandsAI::AddTimeWait(const Command&amp; cmd)
 {
+	GML_RECMUTEX_LOCK(sel); // AddTimeWait
+
 	// save the current selection
 	const CUnitSet tmpSet = selectedUnits.selectedUnits;
 	CUnitSet::const_iterator it;
@@ -464,6 +466,8 @@
 void CWaitCommandsAI::Wait::SendCommand(const Command&amp; cmd,
 																				const CUnitSet&amp; unitSet)
 {
+	GML_RECMUTEX_LOCK(sel); // SendCommand
+
 	if (unitSet.empty()) {
 		return;
 	}
@@ -694,6 +698,8 @@
 CWaitCommandsAI::DeathWait::DeathWait(const Command&amp; cmd)
 : Wait(CMD_WAITCODE_DEATHWAIT)
 {
+	GML_RECMUTEX_LOCK(sel); // DeathWait
+
 	const CUnitSet&amp; selUnits = selectedUnits.selectedUnits;
 
 	if (cmd.params.size() == 1) {
@@ -922,6 +928,8 @@
 CWaitCommandsAI::SquadWait::SquadWait(const Command&amp; cmd)
 : Wait(CMD_WAITCODE_SQUADWAIT)
 {
+	GML_RECMUTEX_LOCK(sel); // SquadWait
+
 	if (cmd.params.size() != 1) {
 		return;
 	}
@@ -1093,6 +1101,8 @@
 CWaitCommandsAI::GatherWait::GatherWait(const Command&amp; cmd)
 : Wait(CMD_WAITCODE_GATHERWAIT)
 {
+	GML_RECMUTEX_LOCK(sel); // GatherWait
+
 	if (cmd.params.size() != 0) {
 		return;
 	}

Modified: branches/caiinterface/rts/Lua/LuaHandle.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaHandle.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaHandle.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1732,7 +1732,7 @@
 }
 
 
-bool CLuaHandle::AddConsoleLine(const string&amp; msg, int zone)
+bool CLuaHandle::AddConsoleLine(const string&amp; msg, CLogSubsystem&amp; /**/)
 {
 	if (!CheckModUICtrl()) {
 		return true; // FIXME?
@@ -1745,7 +1745,8 @@
 	}
 
 	lua_pushstring(L, msg.c_str());
-	lua_pushnumber(L, zone);
+	// FIXME: makes no sense now, but *gets might expect this
+	lua_pushnumber(L, 0);
 
 	// call the function
 	if (!RunCallIn(cmdStr, 2, 0)) {

Modified: branches/caiinterface/rts/Lua/LuaHandle.h
===================================================================
--- branches/caiinterface/rts/Lua/LuaHandle.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaHandle.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -37,6 +37,7 @@
 struct Command;
 struct LuaHashString;
 struct lua_State;
+class CLogSubsystem;
 
 
 typedef void (*LuaCobCallback)(int retCode, void* unitID, void* data);
@@ -170,7 +171,7 @@
 
 		bool CommandNotify(const Command&amp; cmd);
 
-		bool AddConsoleLine(const string&amp; msg, int zone);
+		bool AddConsoleLine(const string&amp; msg, CLogSubsystem&amp;);
 
 		bool GroupChanged(int groupID);
 

Modified: branches/caiinterface/rts/Lua/LuaOpenGL.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaOpenGL.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaOpenGL.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1968,7 +1968,7 @@
 	}
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	CTransportUnit *trans=unit-&gt;transporter;
+	CTransportUnit *trans=unit-&gt;GetTransporter();
 	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
@@ -2017,7 +2017,7 @@
 	}
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	CTransportUnit *trans=unit-&gt;transporter;
+	CTransportUnit *trans=unit-&gt;GetTransporter();
 	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {

Modified: branches/caiinterface/rts/Lua/LuaParser.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaParser.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaParser.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -32,7 +32,7 @@
 #else
 #  define LUA_OPEN_LIB(L, lib) \
      lua_pushcfunction((L), lib); \
-     lua_pcall((L), 0, 0, 0); 
+     lua_pcall((L), 0, 0, 0);
 #endif
 
 
@@ -287,7 +287,7 @@
 {
 	if ((L == NULL) || (initDepth &lt; 0)) { return; }
 
-	lua_pushnumber(L, index); 
+	lua_pushnumber(L, index);
 
 	if (overwrite) {
 		lua_newtable(L);
@@ -423,7 +423,7 @@
 
 
 int LuaParser::TimeCheck(lua_State* L)
-{	
+{
 	if (!lua_isstring(L, 1) || !lua_isfunction(L, 2)) {
 		luaL_error(L, &quot;Invalid arguments to TimeCheck('string', func, ...)&quot;);
 	}
@@ -462,7 +462,7 @@
 	const vector&lt;string&gt; files = CFileHandler::DirList(dir, pat, modes);
 
 	lua_newtable(L);
-	int count = 0;	
+	int count = 0;
 	vector&lt;string&gt;::const_iterator fi;
 	for (fi = files.begin(); fi != files.end(); ++fi) {
 		count++;
@@ -533,7 +533,7 @@
 		luaL_error(L, &quot;Include(): error with setfenv&quot;);
 	}
 
-	const int paramTop = lua_gettop(L) - 1;	
+	const int paramTop = lua_gettop(L) - 1;
 
 	error = lua_pcall(L, 0, LUA_MULTRET, 0);
 
@@ -634,9 +634,9 @@
 	isValid = _parser-&gt;IsValid();
 	path    = &quot;ROOT&quot;;
 	parser  = _parser;
-  L       = parser-&gt;L;
+	L       = parser-&gt;L;
 	refnum  = parser-&gt;rootRef;
-	
+
 	if (PushTable()) {
 		lua_pushvalue(L, -1); // copy
 		refnum = luaL_ref(L, LUA_REGISTRYINDEX);
@@ -660,7 +660,7 @@
 		refnum = luaL_ref(L, LUA_REGISTRYINDEX);
 	} else {
 		refnum = LUA_NOREF;
-	}	
+	}
 	isValid = (refnum != LUA_NOREF);
 
 	if (parser) {
@@ -691,13 +691,13 @@
 
 	L    = tbl.L;
 	path = tbl.path;
-	
+
 	if (tbl.PushTable()) {
 		lua_pushvalue(L, -1); // copy
 		refnum = luaL_ref(L, LUA_REGISTRYINDEX);
 	} else {
 		refnum = LUA_NOREF;
-	}	
+	}
 
 	isValid = (refnum != LUA_NOREF);
 
@@ -736,7 +736,7 @@
 
 LuaTable LuaTable::SubTable(const string&amp; mixedKey) const
 {
-	
+
 	const string key = !lowerCppKeys ? mixedKey : StringToLower(mixedKey);
 
 	LuaTable subTable;
@@ -866,7 +866,7 @@
 		lua_pop(L, 1);
 		return false;
 	}
-	return true;	
+	return true;
 }
 
 
@@ -882,7 +882,7 @@
 		lua_pop(L, 1);
 		return false;
 	}
-	return true;	
+	return true;
 }
 
 

Modified: branches/caiinterface/rts/Lua/LuaUnitDefs.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnitDefs.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaUnitDefs.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -754,6 +754,7 @@
 	ADD_FLOAT(&quot;slideTolerance&quot;,    ud.slideTolerance);
 
 	ADD_FLOAT(&quot;maxWeaponRange&quot;, ud.maxWeaponRange);
+	ADD_FLOAT(&quot;maxCoverage&quot;, ud.maxCoverage);
 
 	ADD_BOOL( &quot;buildRange3D&quot;,   ud.buildRange3D);
 	ADD_FLOAT(&quot;buildDistance&quot;,  ud.buildDistance);

Modified: branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -186,7 +186,6 @@
 	REGISTER_LUA_CFUNC(MarkerErasePosition);
 
 	REGISTER_LUA_CFUNC(SetDrawSelectionInfo);
-	REGISTER_LUA_CFUNC(GetDrawSelectionInfo);
 
 	return true;
 }
@@ -333,7 +332,8 @@
 
 	glLineWidth(cmdColors.QueuedLineWidth());
 
-	GML_STDMUTEX_LOCK(cai);
+	GML_STDMUTEX_LOCK(cai); // DrawUnitCommandQueues
+
 	const CUnitSet&amp; units = drawCmdQueueUnits;
 	CUnitSet::const_iterator ui;
 	for (ui = units.begin(); ui != units.end(); ++ui) {
@@ -979,6 +979,8 @@
 
 int LuaUnsyncedCtrl::SetUnitNoSelect(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // SetUnitNoSelect
+
 	if (CLuaHandle::GetActiveHandle()-&gt;GetUserMode()) {
 		return 0;
 	}
@@ -1590,6 +1592,8 @@
 
 int LuaUnsyncedCtrl::SetUnitGroup(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // SetUnitGroup
+
 	if (!CheckModUICtrl()) {
 		return 0;
 	}
@@ -2098,7 +2102,6 @@
 /******************************************************************************/
 /******************************************************************************/
 
-
 int LuaUnsyncedCtrl::SetDrawSelectionInfo(lua_State* L)
 {
 	if (!CheckModUICtrl()) {
@@ -2110,22 +2113,12 @@
 		luaL_error(L, &quot;Incorrect arguments to SetDrawSelectionInfo(bool)&quot;);
 	}
 
-	guihandler-&gt;SetDrawSelectionInfo(lua_toboolean(L, 1));
+	if (guihandler)
+		guihandler-&gt;SetDrawSelectionInfo(lua_toboolean(L, 1));
 
 	return 0;
 }
 
 
-int LuaUnsyncedCtrl::GetDrawSelectionInfo(lua_State* L)
-{
-	const int args = lua_gettop(L); // number of arguments
-	if (args != 0) {
-		luaL_error(L, &quot;Incorrect arguments to GetDrawSelectionInfo()&quot;);
-	}
-
-	lua_pushboolean(L, guihandler-&gt;GetDrawSelectionInfo());
-	return 1;
-}
-
 /******************************************************************************/
 /******************************************************************************/

Modified: branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.h
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaUnsyncedCtrl.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -122,7 +122,6 @@
 		static int MarkerErasePosition(lua_State* L);
 
 		static int SetDrawSelectionInfo(lua_State* L);
-		static int GetDrawSelectionInfo(lua_State* L);
 };
 
 

Modified: branches/caiinterface/rts/Lua/LuaUnsyncedRead.cpp
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnsyncedRead.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaUnsyncedRead.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -177,6 +177,8 @@
 	REGISTER_LUA_CFUNC(GetKeyBindings);
 	REGISTER_LUA_CFUNC(GetActionHotKeys);
 
+	REGISTER_LUA_CFUNC(GetLastMessagePositions);
+
 	REGISTER_LUA_CFUNC(GetConsoleBuffer);
 	REGISTER_LUA_CFUNC(GetCurrentTooltip);
 
@@ -198,6 +200,8 @@
 
 	REGISTER_LUA_CFUNC(GetPlayerTraffic);
 
+	REGISTER_LUA_CFUNC(GetDrawSelectionInfo);
+
 	return true;
 }
 
@@ -356,7 +360,7 @@
 
 	lua_pushboolean(L, (x &gt;= x0) &amp;&amp; (x &lt; x1) &amp;&amp;
 	                   (y &gt;= y0) &amp;&amp; (y &lt; y1));
-		
+
 	return 1;
 }
 
@@ -499,6 +503,8 @@
 
 int LuaUnsyncedRead::IsUnitSelected(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // IsUnitSelected
+
 	CUnit* unit = ParseUnit(L, __FUNCTION__, 1);
 	if (unit == NULL) {
 		return 0;
@@ -562,10 +568,11 @@
 	const bool midPos = (lua_isboolean(L, 2) &amp;&amp; lua_toboolean(L, 2));
 
 	float3 pos = midPos ? (float3)unit-&gt;midPos : (float3)unit-&gt;pos;
-	if (unit-&gt;transporter == NULL) {
+	CTransportUnit *trans=unit-&gt;GetTransporter();
+	if (trans == NULL) {
 		pos += (unit-&gt;speed * gu-&gt;timeOffset);
 	} else {
-		pos += (unit-&gt;transporter-&gt;speed * gu-&gt;timeOffset);
+		pos += (trans-&gt;speed * gu-&gt;timeOffset);
 	}
 
 	lua_pushnumber(L, pos.x);
@@ -670,7 +677,7 @@
 				}
 			}
 
-			const float testRadius = fixedRadius ? radius : (unit-&gt;radius + radius); 
+			const float testRadius = fixedRadius ? radius : (unit-&gt;radius + radius);
 			if (!camera-&gt;InView(unit-&gt;midPos, testRadius)) {
 				continue;
 			}
@@ -729,6 +736,8 @@
 
 int LuaUnsyncedRead::GetSelectedUnits(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnits
+
 	CheckNoArgs(L, __FUNCTION__);
 	lua_newtable(L);
 	int count = 0;
@@ -747,6 +756,8 @@
 
 int LuaUnsyncedRead::GetSelectedUnitsSorted(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnitsSorted
+
 	CheckNoArgs(L, __FUNCTION__);
 
 	map&lt;int, vector&lt;CUnit*&gt; &gt; unitDefMap;
@@ -780,6 +791,8 @@
 
 int LuaUnsyncedRead::GetSelectedUnitsCounts(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(sel); // GetSelectedUnitsCounts
+
 	CheckNoArgs(L, __FUNCTION__);
 
 	// tally the types
@@ -826,7 +839,7 @@
 		return 0;
 	}
 	lua_pushboolean(L, game-&gt;hideInterface);
-	return 1;	
+	return 1;
 }
 
 
@@ -837,7 +850,7 @@
 		return 0;
 	}
 	lua_pushboolean(L, shadowHandler-&gt;drawShadows);
-	return 1;	
+	return 1;
 }
 
 
@@ -848,7 +861,7 @@
 		return 0;
 	}
 	lua_pushboolean(L, unitDrawer-&gt;advShading);
-	return 1;	
+	return 1;
 }
 
 
@@ -869,7 +882,7 @@
 	}
 	lua_pushnumber(L, mode);
 	lua_pushstring(L, modeName);
-	return 2;	
+	return 2;
 }
 
 
@@ -1048,7 +1061,7 @@
 
 // FIXME	const int origAllyTeam = gu-&gt;myAllyTeam;
 //	gu-&gt;myAllyTeam = readAllyTeam;
-	const float udist = helper-&gt;GuiTraceRay(pos, dir, range, unit, 20.0f, true);
+	const float udist = helper-&gt;GuiTraceRay(pos, dir, range, unit, true);
 	const float fdist = helper-&gt;GuiTraceRayFeature(pos, dir, range, feature);
 //	gu-&gt;myAllyTeam = origAllyTeam;
 
@@ -1235,6 +1248,8 @@
 
 int LuaUnsyncedRead::GetActiveCommand(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetActiveCommand
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1257,6 +1272,8 @@
 
 int LuaUnsyncedRead::GetDefaultCommand(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetDefaultCommand
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1309,6 +1326,8 @@
 
 int LuaUnsyncedRead::GetActiveCmdDescs(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetActiveCmdDescs
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1328,6 +1347,8 @@
 
 int LuaUnsyncedRead::GetActiveCmdDesc(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetActiveCmdDesc
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1349,6 +1370,8 @@
 
 int LuaUnsyncedRead::GetCmdDescIndex(lua_State* L)
 {
+	GML_RECMUTEX_LOCK(gui); // GetCmdDescIndex
+
 	if (guihandler == NULL) {
 		return 0;
 	}
@@ -1519,7 +1542,31 @@
 	return 1;
 }
 
+/******************************************************************************/
 
+int LuaUnsyncedRead::GetLastMessagePositions(lua_State* L)
+{
+	CheckNoArgs(L, __FUNCTION__);
+	lua_newtable(L);
+	for (int i=1; i&lt;=game-&gt;infoConsole-&gt;GetMsgPosCount(); i++) {
+		lua_pushnumber(L, i);
+		lua_newtable(L); {
+			const float3 msgpos = game-&gt;infoConsole-&gt;GetMsgPos();
+			lua_pushnumber(L, 1);
+			lua_pushnumber(L, msgpos.x);
+			lua_rawset(L, -3);
+			lua_pushnumber(L, 2);
+			lua_pushnumber(L, msgpos.y);
+			lua_rawset(L, -3);
+			lua_pushnumber(L, 3);
+			lua_pushnumber(L, msgpos.z);
+			lua_rawset(L, -3);
+		}
+		lua_rawset(L, -3);
+	}
+	return 1;
+}
+
 /******************************************************************************/
 
 int LuaUnsyncedRead::GetConsoleBuffer(lua_State* L)
@@ -1556,9 +1603,10 @@
 			lua_pushstring(L, &quot;text&quot;);
 			lua_pushstring(L, lines[i].text.c_str());
 			lua_rawset(L, -3);
-			// FIXME: how to migrate 'priority' to 'zone', will it break widgets?
+			// FIXME: migrate priority to subsystem...
 			lua_pushstring(L, &quot;priority&quot;);
-			lua_pushnumber(L, lines[i].zone);
+			lua_pushnumber(L, 0 /*priority*/ );
+			//lua_pushstring(L, lines[i].subsystem-&gt;name);
 			lua_rawset(L, -3);
 		}
 		lua_rawset(L, -3);
@@ -1659,6 +1707,8 @@
 
 int LuaUnsyncedRead::GetGroupList(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupList
+
 	CheckNoArgs(L, __FUNCTION__);
 	if (grouphandlers[gu-&gt;myTeam] == NULL) {
 		return 0;
@@ -1691,6 +1741,8 @@
 
 int LuaUnsyncedRead::GetGroupAIList(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupAIList
+
 	CheckNoArgs(L, __FUNCTION__);
 	lua_newtable(L);
 	const map&lt;AIKey, string&gt;&amp; availableAI = grouphandlers[gu-&gt;myTeam]-&gt;availableAI;
@@ -1711,6 +1763,8 @@
 
 int LuaUnsyncedRead::GetGroupAIName(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupAIName
+
 	const int args = lua_gettop(L); // number of arguments
 	if ((args != 1) || !lua_isnumber(L, 1)) {
 		luaL_error(L, &quot;Incorrect arguments to GetGroupAIName(groupID)&quot;);
@@ -1757,6 +1811,8 @@
 
 int LuaUnsyncedRead::GetGroupUnits(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnits
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1782,6 +1838,8 @@
 
 int LuaUnsyncedRead::GetGroupUnitsSorted(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnitsSorted
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1821,6 +1879,8 @@
 
 int LuaUnsyncedRead::GetGroupUnitsCounts(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnitsCounts
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1857,6 +1917,8 @@
 
 int LuaUnsyncedRead::GetGroupUnitsCount(lua_State* L)
 {
+	GML_STDMUTEX_LOCK(group); // GetGroupUnitsCount
+
 	const int groupID = luaL_checkint(L, 1);
 	const vector&lt;CGroup*&gt;&amp; groups = grouphandlers[gu-&gt;myTeam]-&gt;groups;
 	if ((groupID &lt; 0) || (groupID &gt;= groups.size()) ||
@@ -1943,6 +2005,21 @@
 /******************************************************************************/
 /******************************************************************************/
 
+int LuaUnsyncedRead::GetDrawSelectionInfo(lua_State* L)
+{
+	const int args = lua_gettop(L); // number of arguments
+	if (args != 0) {
+		luaL_error(L, &quot;Incorrect arguments to GetDrawSelectionInfo()&quot;);
+	}
 
+	lua_pushboolean(L, guihandler ? guihandler-&gt;GetDrawSelectionInfo() : 0);
+	return 1;
+}
 
 
+/******************************************************************************/
+/******************************************************************************/
+
+
+
+

Modified: branches/caiinterface/rts/Lua/LuaUnsyncedRead.h
===================================================================
--- branches/caiinterface/rts/Lua/LuaUnsyncedRead.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Lua/LuaUnsyncedRead.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -103,6 +103,8 @@
 
 		static int GetActivePage(lua_State* L);
 
+		static int GetLastMessagePositions(lua_State* L);
+
 		static int GetConsoleBuffer(lua_State* L);
 		static int GetCurrentTooltip(lua_State* L);
 
@@ -128,6 +130,8 @@
 		static int GetGroupUnitsCount(lua_State* L);
 
 		static int GetPlayerTraffic(lua_State* L);
+
+		static int GetDrawSelectionInfo(lua_State* L);
 };
 
 

Modified: branches/caiinterface/rts/Map/BaseGroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/BaseGroundDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/BaseGroundDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -86,6 +86,49 @@
 {}
 
 
+void CBaseGroundDrawer::DrawTrees(bool drawReflection) const
+{
+	glEnable(GL_ALPHA_TEST);
+	glAlphaFunc(GL_GREATER, 0.005f);
+	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+	glEnable(GL_BLEND);
+
+	if (treeDrawer-&gt;drawTrees) {
+		if (DrawExtraTex()) {
+			glActiveTextureARB(GL_TEXTURE1_ARB);
+			glEnable(GL_TEXTURE_2D);
+			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
+			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_ARB, GL_PREVIOUS_ARB);
+			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_ARB, GL_TEXTURE);
+			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_ARB, GL_MODULATE);
+			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_ARB, GL_PREVIOUS_ARB);
+			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_ARB, GL_TEXTURE);
+			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
+			glBindTexture(GL_TEXTURE_2D, infoTex);
+			SetTexGen(1.0f / (gs-&gt;pwr2mapx * SQUARE_SIZE), 1.0f / (gs-&gt;pwr2mapy * SQUARE_SIZE), 0, 0);
+			glActiveTextureARB(GL_TEXTURE0_ARB);
+		}
+
+		treeDrawer-&gt;Draw(drawReflection);
+
+		if (DrawExtraTex()) {
+			glActiveTextureARB(GL_TEXTURE1_ARB);
+			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_ARB, GL_TEXTURE);
+			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_ARB, GL_PREVIOUS_ARB);
+			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
+			glDisable(GL_TEXTURE_GEN_S);
+			glDisable(GL_TEXTURE_GEN_T);
+			glDisable(GL_TEXTURE_2D);
+			glActiveTextureARB(GL_TEXTURE0_ARB);
+		}
+	}
+
+	glDisable(GL_ALPHA_TEST);
+	glDisable(GL_BLEND);
+}
+
+
 void CBaseGroundDrawer::SetDrawMode (DrawMode dm)
 {
 	drawMode = dm;
@@ -235,7 +278,9 @@
 
 		switch(drawMode) {
 			case drawPath: {
-				GML_RECMUTEX_LOCK(gui); // UpdateExtraTexture
+
+//				GML_RECMUTEX_LOCK(gui); // UpdateExtraTexture. Not needed in draw thread
+
 				if (guihandler-&gt;inCommand &gt; 0 &amp;&amp; guihandler-&gt;inCommand &lt; guihandler-&gt;commands.size() &amp;&amp;
 						guihandler-&gt;commands[guihandler-&gt;inCommand].type == CMDTYPE_ICON_BUILDING) {
 					// use the current build order
@@ -267,7 +312,9 @@
 				}
 				else {
 					// use the first selected unit
+
 					GML_RECMUTEX_LOCK(sel); // UpdateExtraTexture
+
 					if (selectedUnits.selectedUnits.empty()) {
 						return true;
 					}
@@ -281,7 +328,7 @@
 							if (gs-&gt;cheatEnabled &amp;&amp; md-&gt;moveMath-&gt;IsBlocked2(*md, x*2+1, y*2+1) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN)) {
 								m = 0.0f;
 							}
-							m = std::min(1.0f, (float)sqrt(m));
+							m = std::min(1.0f, (float)fastmath::sqrt(m));
 							const int a=y*gs-&gt;pwr2mapx/2+x;
 							infoTexMem[a*4+0]=255-int(m*255.0f);
 							infoTexMem[a*4+1]=int(m*255.0f);
@@ -433,7 +480,7 @@
 }
 
 
-void CBaseGroundDrawer::SetTexGen(float scalex,float scaley, float offsetx, float offsety)
+void CBaseGroundDrawer::SetTexGen(float scalex,float scaley, float offsetx, float offsety) const
 {
 	GLfloat plan[]={scalex,0,0,offsetx};
 	glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,GL_EYE_LINEAR);

Modified: branches/caiinterface/rts/Map/BaseGroundDrawer.h
===================================================================
--- branches/caiinterface/rts/Map/BaseGroundDrawer.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/BaseGroundDrawer.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -24,6 +24,11 @@
 	virtual void IncreaseDetail()=0;
 	virtual void DecreaseDetail()=0;
 
+#ifdef USE_GML
+	int multiThreadDrawGround;
+	int multiThreadDrawGroundShadow;
+#endif
+
 	enum DrawMode
 	{
 		drawNormal,
@@ -36,6 +41,8 @@
 protected:
 	virtual void SetDrawMode(DrawMode dm);
 public:
+	void DrawTrees(bool drawReflection=false) const;
+
 	// Everything that deals with drawing extra textures on top
 	void DisableExtraTexture();
 	void SetHeightTexture();
@@ -46,7 +53,7 @@
 	bool UpdateExtraTexture();
 	bool DrawExtraTex() const { return drawMode!=drawNormal; };
 
-	void SetTexGen(float scalex,float scaley, float offsetx, float offsety);
+	void SetTexGen(float scalex,float scaley, float offsetx, float offsety) const;
 
 	bool updateFov;
 	bool drawRadarAndJammer;

Modified: branches/caiinterface/rts/Map/Ground.cpp
===================================================================
--- branches/caiinterface/rts/Map/Ground.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/Ground.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -89,8 +89,7 @@
 	if (from.z &gt; float3::maxzpos &amp;&amp; to.z &lt; float3::maxzpos) {
 		// a special case since the camera in overhead mode can often do this
 		float3 dir = to - from;
-		float maxLength = dir.Length();
-		dir /= maxLength;
+		dir.Normalize();
 
 		savedLength = -(from.z - float3::maxzpos) / dir.z;
 		from += dir * savedLength;

Modified: branches/caiinterface/rts/Map/MapInfo.cpp
===================================================================
--- branches/caiinterface/rts/Map/MapInfo.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/MapInfo.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -15,6 +15,9 @@
 using namespace std;
 
 
+static CLogSubsystem LOG_MAPINFO(&quot;mapinfo&quot;);
+
+
 float4::float4()
 {
 	float tmp[4];
@@ -78,7 +81,7 @@
 void CMapInfo::ReadGlobal()
 {
 	const LuaTable topTable = *mapRoot;
-	
+
 	map.humanName    = topTable.GetString(&quot;description&quot;, map.name);
 	map.author       = topTable.GetString(&quot;author&quot;, &quot;&quot;);
 	map.wantedScript = topTable.GetString(&quot;script&quot;, &quot;&quot;);
@@ -315,42 +318,3 @@
 		terrType.shipSpeed  = max(0.0f, terrType.shipSpeed);
 	}
 }
-
-
-void CMapInfo::ReadStartPos()
-{
-	const float defX = 1000.0f;
-	const float defZ = 1000.0f;
-	const float defXStep = 100.0f;
-	const float defZStep = 100.0f;
-
-	const LuaTable teamsTable = mapRoot-&gt;SubTable(&quot;teams&quot;);
-
-	for (int t = 0; t &lt; MAX_TEAMS; ++t) {
-		float3 pos;
-		pos.x = defX + (defXStep * t);
-		pos.z = defZ + (defZStep * t);
-		pos.y = 0.0f;
-		const LuaTable posTable = teamsTable.SubTable(t).SubTable(&quot;startPos&quot;);
-		if (posTable.KeyExists(&quot;x&quot;) &amp;&amp;
-		    posTable.KeyExists(&quot;z&quot;)) {
-			pos.x = posTable.GetFloat(&quot;x&quot;, pos.x);
-			pos.z = posTable.GetFloat(&quot;z&quot;, pos.z);
-			havePos.push_back(true);
-		} else {
-			havePos.push_back(false);
-		}
-		startPos.push_back(pos);		
-	}
-}
-
-
-bool CMapInfo::GetStartPos(int team, float3&amp; pos) const
-{
-	if ((team &lt; 0) || (team &gt;= startPos.size()) || !havePos[team]) {
-		return false;
-	}
-	pos = startPos[team];
-	return true;
-}
-

Modified: branches/caiinterface/rts/Map/MapInfo.h
===================================================================
--- branches/caiinterface/rts/Map/MapInfo.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/MapInfo.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -171,13 +171,7 @@
 	};
 	TerrainType terrainTypes[256];
 
-	bool GetStartPos(int team, float3&amp; pos) const; // FIXME: MapParser duplicate?
-	
 private:
-	std::vector&lt;bool&gt;   havePos;
-	std::vector&lt;float3&gt; startPos;
-
-private:
 	void ReadGlobal();
 	void ReadGui();
 	void ReadAtmosphere();
@@ -186,7 +180,6 @@
 	void ReadSmf();
 	void ReadSm3();
 	void ReadTerrainTypes();
-	void ReadStartPos();
 
 	LuaTable* mapRoot; // map       parser root table
 	LuaTable* resRoot; // resources parser root table

Modified: branches/caiinterface/rts/Map/SM3/Sm3GroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/SM3/Sm3GroundDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -211,36 +211,11 @@
 //	if(drawWaterReflection)
 //		treeDistance*=0.5f;
 
-	if(groundDecals &amp;&amp; !(drawWaterReflection || drawUnitReflection))
+	if(groundDecals &amp;&amp; !(drawWaterReflection || drawUnitReflection)) {
 		groundDecals-&gt;Draw();
-	ph-&gt;DrawGroundFlashes();
-	if(treeDrawer-&gt;drawTrees){
-		if(DrawExtraTex()){
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glEnable(GL_TEXTURE_2D);
-			glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_ADD_SIGNED_ARB);
-			glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_PREVIOUS_ARB);
-			glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_TEXTURE);
-			glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_MODULATE);
-			glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_PREVIOUS_ARB);
-			glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_TEXTURE);
-			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);
-			glBindTexture(GL_TEXTURE_2D, infoTex);
-			SetTexGen(1.0f/(gs-&gt;pwr2mapx*SQUARE_SIZE),1.0f/(gs-&gt;pwr2mapy*SQUARE_SIZE),0,0);
-		  glActiveTextureARB(GL_TEXTURE0_ARB);
-		}
-		treeDrawer-&gt;Draw(drawWaterReflection || drawUnitReflection);
-		if(DrawExtraTex()){
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
-			glDisable(GL_TEXTURE_GEN_S);
-			glDisable(GL_TEXTURE_GEN_T);
-			glDisable(GL_TEXTURE_2D);
-		  glActiveTextureARB(GL_TEXTURE0_ARB);
-		}
+		ph-&gt;DrawGroundFlashes();
+		glDepthMask(1);
 	}
-	
-	glDisable(GL_ALPHA_TEST);
 }
 
 const int maxQuadDepth = 4;

Modified: branches/caiinterface/rts/Map/SM3/terrain/TerrainBase.h
===================================================================
--- branches/caiinterface/rts/Map/SM3/terrain/TerrainBase.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/SM3/terrain/TerrainBase.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -43,7 +43,7 @@
 typedef unsigned short ushort;
 typedef unsigned char uchar;
 
-#define d_puts(_C) logOutput.Print(0, std::string(_C));
+#define d_puts(_C) logOutput.Print(std::string(_C));
 #define d_trace logOutput.Print
 
 

Modified: branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/SMF/BFGroundDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -692,8 +692,10 @@
 	//	viewRadius = ((int)(viewRadius * LODScaleRefraction)) &amp; 0xfffffe;
 	//}
 
+	viewRadius = max(4, viewRadius);
+
 	float zoom = 45.0f / camera-&gt;GetFov();
-	viewRadius = (int) (viewRadius * sqrt(zoom));
+	viewRadius = (int) (viewRadius * fastmath::sqrt(zoom));
 	viewRadius += (viewRadius &amp; 1);
 
 	neededLod = int((gu-&gt;viewRange * 0.125f) / viewRadius) &lt;&lt; 1;
@@ -740,59 +742,22 @@
 		glDisable(GL_ALPHA_TEST);
 	}
 
-	if (mapInfo-&gt;hasWaterPlane) {
-		DrawWaterPlane(drawWaterReflection);
-	}
+	if (!(drawWaterReflection || drawUnitReflection)) {
+		if (mapInfo-&gt;hasWaterPlane) {
+			DrawWaterPlane(drawWaterReflection);
+		}
 
-	if (groundDecals &amp;&amp; !(drawWaterReflection || drawUnitReflection)) {
-		groundDecals-&gt;Draw();
+		if (groundDecals) {
+			groundDecals-&gt;Draw();
+			ph-&gt;DrawGroundFlashes();
+			glDepthMask(1);
+		}
 	}
 
-	glEnable(GL_ALPHA_TEST);
-	glEnable(GL_TEXTURE_2D);
-	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-	glEnable(GL_BLEND);
-
 //	sky-&gt;SetCloudShadow(1);
 //	if (drawWaterReflection)
 //		treeDistance *= 0.5f;
 
-	ph-&gt;DrawGroundFlashes();
-
-
-	if (treeDrawer-&gt;drawTrees) {
-		if (DrawExtraTex()) {
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glEnable(GL_TEXTURE_2D);
-			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
-			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_ARB, GL_PREVIOUS_ARB);
-			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_ARB, GL_TEXTURE);
-			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA_ARB, GL_MODULATE);
-			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA_ARB, GL_PREVIOUS_ARB);
-			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA_ARB, GL_TEXTURE);
-			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
-			glBindTexture(GL_TEXTURE_2D, infoTex);
-			SetTexGen(1.0f / (gs-&gt;pwr2mapx * SQUARE_SIZE), 1.0f / (gs-&gt;pwr2mapy * SQUARE_SIZE), 0, 0);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		}
-
-		treeDrawer-&gt;Draw(drawWaterReflection || drawUnitReflection);
-
-		if (DrawExtraTex()) {
-			glActiveTextureARB(GL_TEXTURE1_ARB);
-			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB_ARB, GL_TEXTURE);
-			glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB_ARB, GL_PREVIOUS_ARB);
-			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-
-			glDisable(GL_TEXTURE_GEN_S);
-			glDisable(GL_TEXTURE_GEN_T);
-			glDisable(GL_TEXTURE_2D);
-			glActiveTextureARB(GL_TEXTURE0_ARB);
-		}
-	}
-
-	glDisable(GL_ALPHA_TEST);
-	glDisable(GL_TEXTURE_2D);
 	viewRadius = baseViewRadius;
 }
 
@@ -1176,7 +1141,15 @@
 			glEnable(GL_TEXTURE_2D);
 			glBindTexture(GL_TEXTURE_2D, map-&gt;detailTex);
 			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
-			SetTexGen(0.02f,0.02f, -floor(camera-&gt;pos.x * 0.02f), -floor(camera-&gt;pos.z * 0.02f));
+			//SetTexGen(0.02f,0.02f, -floor(camera-&gt;pos.x * 0.02f), -floor(camera-&gt;pos.z * 0.02f));
+			GLfloat plan[]={0.02f,0.5f,0,0};
+			glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,GL_OBJECT_LINEAR);
+			glTexGenfv(GL_S,GL_EYE_PLANE,plan);
+			glEnable(GL_TEXTURE_GEN_S);
+			GLfloat plan2[]={0,0.5f,0.02f,0};
+			glTexGeni(GL_T,GL_TEXTURE_GEN_MODE,GL_OBJECT_LINEAR);
+			glTexGenfv(GL_T,GL_EYE_PLANE,plan2);
+			glEnable(GL_TEXTURE_GEN_T);
 		} else {
 			glDisable (GL_TEXTURE_2D);
 		}
@@ -1261,7 +1234,15 @@
 			glBindTexture(GL_TEXTURE_2D, map-&gt;detailTex);
 			glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB_ARB, GL_ADD_SIGNED_ARB);
 			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE_ARB);
-			SetTexGen(0.02f, 0.02f, -floor(camera-&gt;pos.x * 0.02f), -floor(camera-&gt;pos.z * 0.02f));
+			//SetTexGen(0.02f, 0.02f, -floor(camera-&gt;pos.x * 0.02f), -floor(camera-&gt;pos.z * 0.02f));
+			GLfloat plan[]={0.02f,0,0,0};
+			glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,GL_OBJECT_LINEAR);
+			glTexGenfv(GL_S,GL_OBJECT_PLANE,plan);
+			glEnable(GL_TEXTURE_GEN_S);
+			GLfloat plan2[]={0,0,0.02f,0};
+			glTexGeni(GL_T,GL_TEXTURE_GEN_MODE,GL_OBJECT_LINEAR);
+			glTexGenfv(GL_T,GL_OBJECT_PLANE,plan2);
+			glEnable(GL_TEXTURE_GEN_T);
 		} else {
 			glDisable (GL_TEXTURE_2D);
 		}

Modified: branches/caiinterface/rts/Map/SMF/BFGroundDrawer.h
===================================================================
--- branches/caiinterface/rts/Map/SMF/BFGroundDrawer.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Map/SMF/BFGroundDrawer.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -60,9 +60,6 @@
 	bool waterDrawn;
 
 #ifdef USE_GML
-	int multiThreadDrawGround;
-	int multiThreadDrawGroundShadow;
-
 	volatile unsigned int mt_overrideVP;
 	static void DoDrawGroundRowMT(void *c,int bty) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundRow(bty,((CBFGroundDrawer *)c)-&gt;mt_overrideVP);}
 	static void DoDrawGroundShadowLODMT(void *c,int nlod) {((CBFGroundDrawer *)c)-&gt;DoDrawGroundShadowLOD(nlod);}

Modified: branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/Env/AdvTreeDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -771,7 +771,9 @@
 
 void CAdvTreeDrawer::DrawGrass(void)
 {
-	grassDrawer-&gt;Draw();
+	if (drawTrees) {
+		grassDrawer-&gt;Draw();
+	}
 }
 
 void CAdvTreeDrawer::ResetPos(const float3&amp; pos)

Modified: branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -47,7 +47,7 @@
 void CBaseTreeDrawer::Draw (bool drawReflection)
 {
 	float zoom=45/camera-&gt;GetFov();
-	float treeDistance=baseTreeDistance*sqrt((zoom));
+	float treeDistance=baseTreeDistance*fastmath::sqrt(zoom);
 	if(treeDistance&gt;MAX_VIEW_RANGE/(SQUARE_SIZE*TREE_SQUARE_SIZE))
 		treeDistance=MAX_VIEW_RANGE/(SQUARE_SIZE*TREE_SQUARE_SIZE);
 

Modified: branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/Env/BaseTreeDrawer.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -22,7 +22,7 @@
 	virtual void DeleteTree(float3 pos)=0;
 
 	std::vector&lt;GLuint&gt; delDispLists;
-  virtual void UpdateDraw();
+	virtual void UpdateDraw();
 
 	float baseTreeDistance;
 	bool drawTrees;

Modified: branches/caiinterface/rts/Rendering/Env/BumpWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/Env/BumpWater.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -119,7 +119,7 @@
 {
 	CFileHandler fh(file);
 	if (!fh.FileExists())
-		throw content_error(&quot;Can't load shader &quot; + file);
+		throw content_error(&quot;BumpWater: Can't load shader &quot; + file);
 	string text;
 	text.resize(fh.FileSize());
 	fh.Read(&amp;text[0], text.length());
@@ -313,7 +313,7 @@
 		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, coastFBO);
 		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, coastTexture[0], 0);
 		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT1_EXT, GL_TEXTURE_2D, coastTexture[1], 0);
-		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+		//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 
 		//! initialize
 		UploadCoastline(0, 0, gs-&gt;mapx, gs-&gt;mapy);
@@ -421,7 +421,7 @@
 			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, reflectRBO);
 			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, reflectTexture, 0);
 			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
 				PrintFboError(&quot;reflection&quot;,status);
 				glDeleteRenderbuffersEXT(1, &amp;reflectRBO);
@@ -440,7 +440,7 @@
 			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, refractRBO);
 			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, target, refractTexture, 0);
 			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
 				PrintFboError(&quot;refraction&quot;,status);
 				glDeleteRenderbuffersEXT(1, &amp;refractRBO);
@@ -454,7 +454,7 @@
 			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, dynWavesFBO);
 			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT, GL_TEXTURE_2D, normalTexture, 0);
 			GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
-			glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
+			//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 			if (status != GL_FRAMEBUFFER_COMPLETE_EXT) {
 				PrintFboError(&quot;dynamicWaves&quot;,status);
 				glDeleteFramebuffersEXT(1,  &amp;dynWavesFBO);
@@ -463,7 +463,7 @@
 				UpdateDynWaves(true); //! initialize
 			}
 		}
-
+		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
 	}
 
 
@@ -505,6 +505,7 @@
 		const float shadingZ = (float)gs-&gt;mapy / gs-&gt;pwr2mapy;
 
 		GLSLDefineConst4f(definitions, &quot;TexGenPlane&quot;, 1.0f/mapX, 1.0f/mapZ, shadingX/mapX, shadingZ/mapZ);
+		GLSLDefineConstf2(definitions, &quot;ShadingPlane&quot;, shadingX,shadingZ);
 	}
 
 	/** LOAD SHADERS **/

Modified: branches/caiinterface/rts/Rendering/Env/DynWater.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/Env/DynWater.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/Env/DynWater.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1123,11 +1123,13 @@
 	CVertexArray* va2=GetVertexArray();		//never try to get more than 2 at once
 	va2-&gt;Initialize();
 
-	int nadd=uh-&gt;activeUnits.size()*4;
+	GML_STDMUTEX_LOCK(render);
+
+	int nadd=uh-&gt;renderUnits.size()*4;
 	va-&gt;EnlargeArrays(nadd,0,VA_SIZE_TN);
 	va2-&gt;EnlargeArrays(nadd,0,VA_SIZE_TN);
 
-	for(std::list&lt;CUnit*&gt;::iterator ui=uh-&gt;activeUnits.begin(); ui!=uh-&gt;activeUnits.end();++ui){
+	for(std::list&lt;CUnit*&gt;::iterator ui=uh-&gt;renderUnits.begin(); ui!=uh-&gt;renderUnits.end();++ui){
 		CUnit* unit=*ui;
 		if(unit-&gt;moveType &amp;&amp; unit-&gt;mobility) {
 			if(unit-&gt;unitDef-&gt;canhover){	//hover

Modified: branches/caiinterface/rts/Rendering/GL/VertexArray.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GL/VertexArray.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GL/VertexArray.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -42,7 +42,7 @@
 	*stripArrayPos++=((char *)drawArrayPos-(char *)drawArray);
 }
 
-void CVertexArray::DrawArray0(int drawType,int stride) {
+void CVertexArray::DrawArray0(const int drawType,int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glVertexPointer(3,GL_FLOAT,stride,drawArray);
@@ -50,7 +50,7 @@
 	glDisableClientState(GL_VERTEX_ARRAY);
 }
 
-void CVertexArray::DrawArrayC(int drawType,int stride) {
+void CVertexArray::DrawArrayC(const int drawType,int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_VERTEX_ARRAY);
 	glEnableClientState(GL_COLOR_ARRAY);
@@ -61,7 +61,7 @@
 	glDisableClientState(GL_COLOR_ARRAY);
 }
 
-void CVertexArray::DrawArrayT(int drawType,int stride) {
+void CVertexArray::DrawArrayT(const int drawType,int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
@@ -72,7 +72,7 @@
 	glDisableClientState(GL_VERTEX_ARRAY);
 }
 
-void CVertexArray::DrawArrayT2(int drawType,int stride) {
+void CVertexArray::DrawArrayT2(const int drawType,int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
@@ -92,7 +92,7 @@
 	glDisableClientState(GL_VERTEX_ARRAY);
 }
 
-void CVertexArray::DrawArrayTN(int drawType, int stride) {
+void CVertexArray::DrawArrayTN(const int drawType, int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);
@@ -106,7 +106,7 @@
 	glDisableClientState(GL_NORMAL_ARRAY);
 }
 
-void CVertexArray::DrawArrayTC(int drawType, int stride) {
+void CVertexArray::DrawArrayTC(const int drawType, int stride) {
 	CheckEndStrip();
 	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 	glEnableClientState(GL_VERTEX_ARRAY);

Modified: branches/caiinterface/rts/Rendering/GL/VertexArray.h
===================================================================
--- branches/caiinterface/rts/Rendering/GL/VertexArray.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GL/VertexArray.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -20,39 +20,40 @@
 	CVertexArray();
 	~CVertexArray();
 	void Initialize();
-	inline void CheckInitSize(int vertexes, int strips=0);
+	inline void CheckInitSize(const int vertexes, const int strips=0);
 
-	inline void AddVertexTC(const float3 &amp;pos,float tx,float ty,unsigned char* color);
-	void DrawArrayTC(int drawType,int stride=24);
-	inline void AddVertexTN(const float3 &amp;pos,float tx,float ty,const float3&amp; norm);
-	void DrawArrayTN(int drawType,int stride=32);
-	inline void AddVertexT2(const float3&amp; pos,float t1x,float t1y,float t2x,float t2y);
-	void DrawArrayT2(int drawType,int stride=28);
-	inline void AddVertexT(const float3&amp; pos,float tx,float ty);
-	void DrawArrayT(int drawType,int stride=20);
+	inline void AddVertexTC(const float3 &amp;pos,const float tx,const float ty,const unsigned char* color);
+	void DrawArrayTC(const int drawType,int stride=24);
+	inline void AddVertexTN(const float3 &amp;pos,const float tx,const float ty,const float3&amp; norm);
+	void DrawArrayTN(const int drawType,int stride=32);
+	inline void AddVertexT2(const float3&amp; pos,const float t1x,const float t1y,const float t2x,const float t2y);
+	void DrawArrayT2(const int drawType,int stride=28);
+	inline void AddVertexT(const float3&amp; pos,const float tx,const float ty);
+	void DrawArrayT(const int drawType,int stride=20);
 	inline void AddVertex0(const float3&amp; pos);
-	void DrawArray0(int drawType,int stride=12);
-	inline void AddVertexC(const float3&amp; pos,unsigned char* color);
-	void DrawArrayC(int drawType,int stride=16);
+	inline void AddVertex0(const float x, const float y, const float z);
+	void DrawArray0(const int drawType,int stride=12);
+	inline void AddVertexC(const float3&amp; pos,const unsigned char* color);
+	void DrawArrayC(const int drawType,int stride=16);
 
 	//! same as AddVertex0, but without automated CheckEnlargeDrawArray
-	inline void AddVertexQ0(float x, float y, float z);
+	inline void AddVertexQ0(const float x, const float y, const float z);
 	//! same as AddVertexC, but without automated CheckEnlargeDrawArray
-	inline void AddVertexQC(const float3&amp; pos,unsigned char* color);
+	inline void AddVertexQC(const float3&amp; pos,const unsigned char* color);
 	//! same as AddVertexT, but without automated CheckEnlargeDrawArray
-	inline void AddVertexQT(const float3&amp; pos,float tx,float ty);
+	inline void AddVertexQT(const float3&amp; pos,const float tx,const float ty);
 	//! same as AddVertexTN, but without automated CheckEnlargeDrawArray
-	inline void AddVertexQTN(const float3 &amp;pos,float tx,float ty,const float3&amp; norm);
+	inline void AddVertexQTN(const float3 &amp;pos,const float tx,const float ty,const float3&amp; norm);
 	//! same as AddVertexTC, but without automated CheckEnlargeDrawArray
-	inline void AddVertexQTC(const float3 &amp;pos,float tx,float ty,unsigned char* color);
+	inline void AddVertexQTC(const float3 &amp;pos,const float tx,const float ty,const unsigned char* color);
 
 	//! same as EndStrip, but without automated EnlargeStripArray
 	inline void EndStripQ();
 
 	bool IsReady();
-	inline int drawIndex();
+	inline int drawIndex() const;
 	void EndStrip();
-	inline void EnlargeArrays(int vertexes, int strips, int stripsize=VA_SIZE_0);
+	inline void EnlargeArrays(const int vertexes, const int strips, const int stripsize=VA_SIZE_0);
 
 	float* drawArray;
 	float* drawArrayPos;
@@ -63,14 +64,14 @@
 	int* stripArraySize;
 
 protected:
-	inline void DrawArrays(int drawType, int stride);
+	inline void DrawArrays(const int drawType, const int stride);
 	inline void CheckEnlargeDrawArray();
 	void EnlargeStripArray();
 	void EnlargeDrawArray();
 	void CheckEndStrip();
 };
 
-inline void CVertexArray::DrawArrays(int drawType, int stride) {
+inline void CVertexArray::DrawArrays(const int drawType, const int stride) {
 	int newIndex,oldIndex=0;
 	int *stripArrayPtr=stripArray;
 	while(stripArrayPtr&lt;stripArrayPos) {
@@ -81,7 +82,7 @@
 }
 
 // calls to this function will be removed by the optimizer unless the size is too small
-inline void CVertexArray::CheckInitSize(int vertexes, int strips) {
+inline void CVertexArray::CheckInitSize(const int vertexes, const int strips) {
 	if(vertexes&gt;VA_INIT_VERTEXES || strips&gt;VA_INIT_STRIPS) { 
 		handleerror(drawArrayPos=NULL, &quot;Vertex array initial size is too small&quot;, &quot;Rendering error&quot;, MBF_OK | MBF_EXCL);
 	}
@@ -92,7 +93,7 @@
 		EnlargeDrawArray();
 }
 
-inline void CVertexArray::EnlargeArrays(int vertexes, int strips, int stripsize) {
+inline void CVertexArray::EnlargeArrays(const int vertexes, const int strips, const int stripsize) {
 	while((char *)drawArrayPos&gt;(char *)drawArraySize-stripsize*sizeof(float)*vertexes)
 		EnlargeDrawArray();
 
@@ -100,14 +101,14 @@
 		EnlargeStripArray();
 }
 
-inline void CVertexArray::AddVertexQ0(float x, float y, float z) {
+inline void CVertexArray::AddVertexQ0(const float x, const float y, const float z) {
 	assert(drawArraySize&gt;=drawArrayPos+VA_SIZE_0);
 	*drawArrayPos++=x;
 	*drawArrayPos++=y;
 	*drawArrayPos++=z;
 }
 
-inline void CVertexArray::AddVertexQC(const float3&amp; pos,unsigned char* color) {
+inline void CVertexArray::AddVertexQC(const float3&amp; pos,const unsigned char* color) {
 	assert(drawArraySize&gt;=drawArrayPos+VA_SIZE_C);
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -115,7 +116,7 @@
 	*drawArrayPos++=*((float*)(color));
 }
 
-inline void CVertexArray::AddVertexQT(const float3&amp; pos,float tx,float ty) {
+inline void CVertexArray::AddVertexQT(const float3&amp; pos,const float tx,const float ty) {
 	assert(drawArraySize&gt;=drawArrayPos+VA_SIZE_T);
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -124,7 +125,7 @@
 	*drawArrayPos++=ty;
 }
 
-inline void CVertexArray::AddVertexQTN(const float3&amp; pos,float tx,float ty,const float3&amp; norm) {
+inline void CVertexArray::AddVertexQTN(const float3&amp; pos,const float tx,const float ty,const float3&amp; norm) {
 	assert(drawArraySize&gt;=drawArrayPos+VA_SIZE_TN);
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -136,7 +137,7 @@
 	*drawArrayPos++=norm.z;
 }
 
-inline void CVertexArray::AddVertexQTC(const float3&amp; pos,float tx,float ty,unsigned char* col) {
+inline void CVertexArray::AddVertexQTC(const float3&amp; pos,const float tx,const float ty,const unsigned char* col) {
 	assert(drawArraySize&gt;=drawArrayPos+VA_SIZE_TC);
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -155,7 +156,16 @@
 	*drawArrayPos++=pos.z;
 }
 
-inline void CVertexArray::AddVertexC(const float3&amp; pos,unsigned char* color) {
+inline void CVertexArray::AddVertex0(const float x, const float y, const float z) {
+	if(drawArrayPos&gt;drawArraySize-10)
+		EnlargeDrawArray();
+
+	*drawArrayPos++=x;
+	*drawArrayPos++=y;
+	*drawArrayPos++=z;
+}
+
+inline void CVertexArray::AddVertexC(const float3&amp; pos,const unsigned char* color) {
 	CheckEnlargeDrawArray();
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -163,7 +173,7 @@
 	*drawArrayPos++=*((float*)(color));
 }
 
-inline void CVertexArray::AddVertexT(const float3&amp; pos,float tx,float ty) {
+inline void CVertexArray::AddVertexT(const float3&amp; pos,const float tx,const float ty) {
 	CheckEnlargeDrawArray();
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -172,7 +182,7 @@
 	*drawArrayPos++=ty;
 }
 
-inline void CVertexArray::AddVertexT2(const float3&amp; pos,float tx,float ty,float t2x,float t2y) {
+inline void CVertexArray::AddVertexT2(const float3&amp; pos,const float tx,const float ty,const float t2x,const float t2y) {
 	CheckEnlargeDrawArray();
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -183,7 +193,7 @@
 	*drawArrayPos++=t2y;
 }
 
-inline void CVertexArray::AddVertexTN(const float3&amp; pos,float tx,float ty,const float3&amp; norm) {
+inline void CVertexArray::AddVertexTN(const float3&amp; pos,const float tx,const float ty,const float3&amp; norm) {
 	CheckEnlargeDrawArray();
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -195,7 +205,7 @@
 	*drawArrayPos++=norm.z;
 }
 
-inline void CVertexArray::AddVertexTC(const float3&amp; pos,float tx,float ty,unsigned char* col) {
+inline void CVertexArray::AddVertexTC(const float3&amp; pos,const float tx,const float ty,const unsigned char* col) {
 	CheckEnlargeDrawArray();
 	*drawArrayPos++=pos.x;
 	*drawArrayPos++=pos.y;
@@ -211,7 +221,7 @@
 		EndStrip();
 }
 
-inline int CVertexArray::drawIndex() {
+inline int CVertexArray::drawIndex() const {
 	return drawArrayPos-drawArray;
 }
 

Modified: branches/caiinterface/rts/Rendering/GL/glExtra.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GL/glExtra.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GL/glExtra.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -2,6 +2,8 @@
 #include &quot;mmgr.h&quot;
 
 #include &quot;glExtra.h&quot;
+#include &quot;VertexArray.h&quot;
+#include &quot;myGL.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Sim/Weapons/Weapon.h&quot;
 #include &quot;LogOutput.h&quot;
@@ -12,16 +14,17 @@
  */
 static void defSurfaceCircle(const float3&amp; center, float radius, unsigned int res)
 {
-	glBegin(GL_LINE_LOOP);
+	CVertexArray* va=GetVertexArray();
+	va-&gt;Initialize();
 	for (int i = 0; i &lt; res; ++i) {
 		const float radians = (2.0f * PI) * (float)i / (float)res;
 		float3 pos;
-		pos.x = center.x + (sin(radians) * radius);
-		pos.z = center.z + (cos(radians) * radius);
+		pos.x = center.x + (fastmath::sin(radians) * radius);
+		pos.z = center.z + (fastmath::cos(radians) * radius);
 		pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 5.0f;
-		glVertexf3(pos);
+		va-&gt;AddVertex0(pos);
 	}
-	glEnd();
+	va-&gt;DrawArray0(GL_LINE_LOOP);
 }
 
 static void defSurfaceSquare(const float3&amp; center, float xsize, float zsize)
@@ -32,12 +35,13 @@
 	const float3 p2 = center + float3( xsize, 0.0f,  zsize);
 	const float3 p3 = center + float3(-xsize, 0.0f,  zsize);
 
-	glBegin(GL_LINE_LOOP);
-		glVertex3f(p0.x, ground-&gt;GetHeight(p0.x, p0.z), p0.z);
-		glVertex3f(p1.x, ground-&gt;GetHeight(p1.x, p1.z), p1.z);
-		glVertex3f(p2.x, ground-&gt;GetHeight(p2.x, p2.z), p2.z);
-		glVertex3f(p3.x, ground-&gt;GetHeight(p3.x, p3.z), p3.z);
-	glEnd();
+	CVertexArray* va=GetVertexArray();
+	va-&gt;Initialize();
+		va-&gt;AddVertex0(p0.x, ground-&gt;GetHeight(p0.x, p0.z), p0.z);
+		va-&gt;AddVertex0(p1.x, ground-&gt;GetHeight(p1.x, p1.z), p1.z);
+		va-&gt;AddVertex0(p2.x, ground-&gt;GetHeight(p2.x, p2.z), p2.z);
+		va-&gt;AddVertex0(p3.x, ground-&gt;GetHeight(p3.x, p3.z), p3.z);
+	va-&gt;DrawArray0(GL_LINE_LOOP);
 }
 
 
@@ -63,13 +67,14 @@
                        const CWeapon* weapon,
                        unsigned int resolution, float slope)
 {
-	glBegin(GL_LINE_LOOP);
+	CVertexArray* va=GetVertexArray();
+	va-&gt;Initialize();
 	for (int i = 0; i &lt; resolution; ++i) {
 		const float radians = (2.0f * PI) * (float)i / (float)resolution;
 		float rad = radius;
 		float3 pos;
-		float sinR = sin(radians);
-		float cosR = cos(radians);
+		float sinR = fastmath::sin(radians);
+		float cosR = fastmath::cos(radians);
 		pos.x = center.x + (sinR * rad);
 		pos.z = center.z + (cosR * rad);
 		pos.y = ground-&gt;GetHeight(pos.x, pos.z);
@@ -97,9 +102,9 @@
 		pos.x = center.x + (sinR * adjRadius);
 		pos.z = center.z + (cosR * adjRadius);
 		pos.y = ground-&gt;GetHeight(pos.x, pos.z) + 5.0f;
-		glVertexf3(pos);
+		va-&gt;AddVertex0(pos);
 	}
-	glEnd();
+	va-&gt;DrawArray0(GL_LINE_LOOP);
 }
 
 

Modified: branches/caiinterface/rts/Rendering/GL/myGL.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GL/myGL.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GL/myGL.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -42,13 +42,13 @@
 CVertexArray* GetVertexArray()
 {
 #ifdef USE_GML // each thread gets its own array to avoid conflicts
-		int thread=gmlThreadNumber;
-		if(currentVertexArrays[thread]==&amp;vertexArrays1[thread]){
-			currentVertexArrays[thread]=&amp;vertexArrays2[thread];
-		} else {
-			currentVertexArrays[thread]=&amp;vertexArrays1[thread];
-		}
-		return currentVertexArrays[thread];
+	int thread=gmlThreadNumber;
+	if(currentVertexArrays[thread]==&amp;vertexArrays1[thread]){
+		currentVertexArrays[thread]=&amp;vertexArrays2[thread];
+	} else {
+		currentVertexArrays[thread]=&amp;vertexArrays1[thread];
+	}
+	return currentVertexArrays[thread];
 #else
 	if(currentVertexArray==vertexArray1){
 		currentVertexArray=vertexArray2;

Modified: branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GroundDecalHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -117,17 +117,20 @@
 
 
 
-inline void AddQuadVertices(CVertexArray* va, int x, float* yv, int z, const float* uv, unsigned char* color) {
+static inline void AddQuadVertices(CVertexArray* va, int x, float* yv, int z, const float* uv, unsigned char* color)
+{
 	#define HEIGHT2WORLD(x) ((x) &lt;&lt; 3)
-	#define WORLD2HEIGHT(x) ((x) &gt;&gt; 3)
 	#define VERTEX(x, y, z) float3(HEIGHT2WORLD((x)), (y), HEIGHT2WORLD((z)))
 	va-&gt;AddVertexTC( VERTEX(x    , yv[0], z    ),   uv[0], uv[1],   color);
 	va-&gt;AddVertexTC( VERTEX(x + 1, yv[1], z    ),   uv[2], uv[3],   color);
 	va-&gt;AddVertexTC( VERTEX(x + 1, yv[2], z + 1),   uv[4], uv[5],   color);
 	va-&gt;AddVertexTC( VERTEX(x    , yv[3], z + 1),   uv[6], uv[7],   color);
+	#undef VERTEX
+	#undef HEIGHT2WORLD
 }
 
-inline void DrawBuildingDecal(BuildingGroundDecal* decal) {
+static inline void DrawBuildingDecal(BuildingGroundDecal* decal)
+{
 	const float* hm = readmap-&gt;GetHeightmap();
 	const int gsmx = gs-&gt;mapx;
 	const int gsmx1 = gsmx + 1;
@@ -137,7 +140,11 @@
 	float uv[8] = {0.0f};
 	unsigned char color[4] = {255, 255, 255, int(decal-&gt;alpha * 255)};
 
+	#ifndef DEBUG
 	#define HEIGHT(z, x) (hm[((z) * gsmx1) + (x)])
+	#else
+	#define HEIGHT(z, x) (assert((z) &lt;= gsmy), assert((x) &lt;= gsmx), (hm[((z) * gsmx1) + (x)]))
+	#endif
 
 	if (!decal-&gt;va) {
 		// NOTE: this really needs CLOD'ing
@@ -164,9 +171,13 @@
 
 				for (int x = xMin; x &lt; xMax; x++) {
 					const int xh = tlx + x;
+					if (xh &gt;= gsmx)
+						break;
 
 					for (int z = zMin; z &lt; zMax; z++) {
 						const int zh = tlz + z;
+						if (zh &gt;= gsmy)
+							break;
 
 						// (htl, htr, hbr, hbl)
 						yv[0] = HEIGHT(zh,     xh    ); yv[1] = HEIGHT(zh,     xh + 1);
@@ -192,9 +203,13 @@
 
 				for (int x = xMin; x &lt; xMax; x++) {
 					const int xh = tlx + x;
+					if (xh &gt;= gsmx)
+						break;
 
 					for (int z = zMin; z &lt; zMax; z++) {
 						const int zh = tlz + z;
+						if (zh &gt;= gsmy)
+							break;
 
 						yv[0] = HEIGHT(zh,     xh    ); yv[1] = HEIGHT(zh,     xh + 1);
 						yv[2] = HEIGHT(zh + 1, xh + 1); yv[3] = HEIGHT(zh + 1, xh    );
@@ -217,9 +232,13 @@
 
 				for (int x = xMin; x &lt; xMax; x++) {
 					const int xh = tlx + x;
+					if (xh &gt;= gsmx)
+						break;
 
 					for (int z = zMin; z &lt; zMax; z++) {
 						const int zh = tlz + z;
+						if (zh &gt;= gsmy)
+							break;
 
 						yv[0] = HEIGHT(zh,     xh    ); yv[1] = HEIGHT(zh,     xh + 1);
 						yv[2] = HEIGHT(zh + 1, xh + 1); yv[3] = HEIGHT(zh + 1, xh    );
@@ -242,9 +261,13 @@
 
 				for (int x = xMin; x &lt; xMax; x++) {
 					const int xh = tlx + x;
+					if (xh &gt;= gsmx)
+						break;
 
 					for (int z = zMin; z &lt; zMax; z++) {
 						const int zh = tlz + z;
+						if (zh &gt;= gsmy)
+							break;
 
 						yv[0] = HEIGHT(zh,     xh    ); yv[1] = HEIGHT(zh,     xh + 1);
 						yv[2] = HEIGHT(zh + 1, xh + 1); yv[3] = HEIGHT(zh + 1, xh    );
@@ -277,9 +300,12 @@
 
 		decal-&gt;va-&gt;DrawArrayTC(GL_QUADS);
 	}
+
+	#undef HEIGHT
 }
 
-inline void DrawGroundScar(CGroundDecalHandler::Scar* scar, bool fade) {
+static inline void DrawGroundScar(CGroundDecalHandler::Scar* scar, bool fade)
+{
 	const float* hm = readmap-&gt;GetHeightmap();
 	const int gsmx = gs-&gt;mapx;
 	const int gsmx1 = gsmx + 1;
@@ -558,9 +584,7 @@
 	}
 
 
-
 	glDisable(GL_POLYGON_OFFSET_FILL);
-	glDepthMask(1);
 	glDisable(GL_BLEND);
 
 	glActiveTextureARB(GL_TEXTURE1_ARB);
@@ -638,7 +662,7 @@
 		--pi;
 		list&lt;TrackPart&gt;::iterator pi2=pi;
 		--pi;
-		if(((tp.pos1+pi-&gt;pos1)*0.5f).distance(pi2-&gt;pos1)&lt;1){
+		if(((tp.pos1+pi-&gt;pos1)*0.5f).SqDistance(pi2-&gt;pos1)&lt;1){
 			unit-&gt;myTrack-&gt;parts.back()=tp;
 			return;
 		}
@@ -916,9 +940,7 @@
 
 	if (building-&gt;buildFacing == 1 || building-&gt;buildFacing == 3) {
 		// swap xsize and ysize if building faces East or West
-		int tmp = decal-&gt;xsize;
-		decal-&gt;xsize = decal-&gt;ysize;
-		decal-&gt;ysize = tmp;
+		std::swap(decal-&gt;xsize, decal-&gt;ysize);
 	}
 
 	decal-&gt;posx = posx - (decal-&gt;xsize / 2);
@@ -929,7 +951,7 @@
 }
 
 
-void CGroundDecalHandler::RemoveBuilding(CBuilding* building,CUnitDrawer::GhostBuilding* gb)
+void CGroundDecalHandler::RemoveBuilding(CBuilding* building, CUnitDrawer::GhostBuilding* gb)
 {
 	GML_STDMUTEX_LOCK(decal); // RemoveBuilding
 

Modified: branches/caiinterface/rts/Rendering/GroundFlash.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/GroundFlash.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GroundFlash.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -55,7 +55,7 @@
 
 CVertexArray* CGroundFlash::va=0;
 
-CGroundFlash::CGroundFlash(const float3&amp; p)
+CGroundFlash::CGroundFlash(const float3&amp; p GML_PARG_C)
 {
 	pos=p;
 	alwaysVisible=false;
@@ -69,8 +69,8 @@
 {
 }
 
-CStandardGroundFlash::CStandardGroundFlash(const float3&amp; p,float circleAlpha,float flashAlpha,float flashSize,float circleSpeed,float ttl, const float3&amp; col)
-	: CGroundFlash(p),
+CStandardGroundFlash::CStandardGroundFlash(const float3&amp; p,float circleAlpha,float flashAlpha,float flashSize,float circleSpeed,float ttl, const float3&amp; col GML_PARG_C)
+	: CGroundFlash(p GML_PARG_P),
 	circleAlpha(circleAlpha),
 	flashAlpha(flashAlpha),
 	flashSize(flashSize),
@@ -175,8 +175,8 @@
 	}
 }
 
-CSeismicGroundFlash::CSeismicGroundFlash(const float3&amp; p, AtlasedTexture texture, int ttl, int fade, float size, float sizeGrowth, float alpha, const float3&amp; col)
-	: CGroundFlash(p),
+CSeismicGroundFlash::CSeismicGroundFlash(const float3&amp; p, AtlasedTexture texture, int ttl, int fade, float size, float sizeGrowth, float alpha, const float3&amp; col GML_PARG_C)
+	: CGroundFlash(p GML_PARG_P),
 	sizeGrowth(sizeGrowth),
 	size(size),
 	texture(texture),
@@ -251,7 +251,7 @@
 {
 }
 
-void CSimpleGroundFlash::Init(const float3&amp; explosionPos, CUnit *owner)
+void CSimpleGroundFlash::Init(const float3&amp; explosionPos, CUnit *owner GML_PARG_C)
 {
 	pos += explosionPos;
 

Modified: branches/caiinterface/rts/Rendering/GroundFlash.h
===================================================================
--- branches/caiinterface/rts/Rendering/GroundFlash.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/GroundFlash.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -12,12 +12,12 @@
 public:
 	CR_DECLARE(CGroundFlash);
 
-	CGroundFlash(const float3&amp; p);
+	CGroundFlash(const float3&amp; p GML_PARG_H);
 	CGroundFlash();
 	virtual ~CGroundFlash(){};
 	virtual void Draw(){};
 	virtual bool Update(){return false;}; // returns false when it should be deleted
-	virtual void Init(const float3&amp; pos, CUnit *owner){};
+	virtual void Init(const float3&amp; pos, CUnit *owner GML_PARG_H){};
 
 	//bool alwaysVisible;
 	//float3 pos;
@@ -31,7 +31,7 @@
 	CR_DECLARE(CStandardGroundFlash);
 
 	CStandardGroundFlash();
-	CStandardGroundFlash(const float3&amp; pos, float circleAlpha,float flashAlpha,float flashSize,float circleSpeed,float ttl, const float3&amp; color=float3(1.0f,1.0f,0.7f));
+	CStandardGroundFlash(const float3&amp; pos, float circleAlpha,float flashAlpha,float flashSize,float circleSpeed,float ttl, const float3&amp; color=float3(1.0f,1.0f,0.7f) GML_PARG_H);
 	~CStandardGroundFlash();
 	void Draw();
 	bool Update(); // returns false when it should be deleted
@@ -58,7 +58,7 @@
 public:
 	CR_DECLARE(CSeismicGroundFlash);
 	~CSeismicGroundFlash();
-	CSeismicGroundFlash(const float3&amp; pos, AtlasedTexture texture, int ttl, int fade, float size, float sizeGrowth, float alpha, const float3&amp; col);
+	CSeismicGroundFlash(const float3&amp; pos, AtlasedTexture texture, int ttl, int fade, float size, float sizeGrowth, float alpha, const float3&amp; col GML_PARG_H);
 	void Draw();
 	bool Update(); // returns false when it should be deleted
 
@@ -82,7 +82,7 @@
 	CSimpleGroundFlash();
 	~CSimpleGroundFlash();
 
-	void Init(const float3&amp; explosionPos, CUnit *owner);
+	void Init(const float3&amp; explosionPos, CUnit *owner GML_PARG_H);
 	void Draw();
 	bool Update(); // returns false when it should be deleted
 

Modified: branches/caiinterface/rts/Rendering/IconHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/IconHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/IconHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -184,7 +184,7 @@
 				si[index + 2] = 0;
 				si[index + 3] = 0;
 			} else {
-				const unsigned char val = (255 - (r * r * r * 255));
+				const unsigned char val = (unsigned char)(255 - (r * r * r * 255));
 				si[index + 0] = val;
 				si[index + 1] = val;
 				si[index + 2] = val;

Modified: branches/caiinterface/rts/Rendering/InMapDraw.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/InMapDraw.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/InMapDraw.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -246,8 +246,7 @@
 		if (maySee) {
 			float3 pos = pi-&gt;pos;
 			float3 dif(pos - camera-&gt;pos);
-			float camDist = dif.Length();
-			dif /= camDist;
+			dif.ANormalize();
 			float3 dir1(dif.cross(UpVector));
 			dir1.ANormalize();
 			float3 dir2(dif.cross(dir1));
@@ -567,7 +566,7 @@
 
 			std::list&lt;MapPoint&gt;::iterator pi;
 			for (pi = dq-&gt;points.begin(); pi != dq-&gt;points.end(); /* none */) {
-				if (pi-&gt;pos.distance2D(pos) &lt; radius) {
+				if (pi-&gt;pos.SqDistance2D(pos) &lt; (radius*radius)) {
 					pi = dq-&gt;points.erase(pi);
 				} else {
 					++pi;
@@ -575,7 +574,7 @@
 			}
 			std::list&lt;MapLine&gt;::iterator li;
 			for (li = dq-&gt;lines.begin(); li != dq-&gt;lines.end(); /* none */) {
-				if (li-&gt;pos.distance2D(pos) &lt; radius) {
+				if (li-&gt;pos.SqDistance2D(pos) &lt; (radius*radius)) {
 					li = dq-&gt;lines.erase(li);
 				} else {
 					++li;

Modified: branches/caiinterface/rts/Rendering/ShadowHandler.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/ShadowHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/ShadowHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -24,7 +24,7 @@
 
 
 bool CShadowHandler::canUseShadows = false;
-bool CShadowHandler::useFPShadows  = true;  // FIXME -- this was being forced to true
+bool CShadowHandler::useFPShadows  = false;
 bool CShadowHandler::firstInstance = true;
 
 
@@ -43,44 +43,39 @@
 		return;
 	}
 
+	const bool haveShadowExts =
+		GLEW_ARB_vertex_program &amp;&amp;
+		GLEW_ARB_shadow &amp;&amp;
+		GLEW_ARB_depth_texture &amp;&amp;
+		GLEW_ARB_texture_env_combine;
 	const int configValue = configHandler.GetInt(&quot;Shadows&quot;, 0);
-	if (configValue &lt; 0) {
+
+	if (configValue &lt; 0 || !haveShadowExts) {
+		logOutput.Print(&quot;shadows disabled or required OpenGL extension missing&quot;);
 		return;
 	}
 
-	shadowMapSize=configHandler.GetInt(&quot;ShadowMapSize&quot;,DEFAULT_SHADOWMAPSIZE);
+	shadowMapSize = configHandler.GetInt(&quot;ShadowMapSize&quot;, DEFAULT_SHADOWMAPSIZE);
 
 	if (tmpFirstInstance) {
-		if(!(GLEW_ARB_fragment_program)){
-			logOutput.Print(&quot;You are missing an OpenGL extension needed to use shadowmaps (fragment_program)&quot;);
+		// this already checks for GLEW_ARB_fragment_program
+		if (!ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB, &quot;unit.fp&quot;)) {
+			logOutput.Print(&quot;Your GFX card does not support the fragment programs needed for shadows&quot;);
 			return;
 		}
 
-		if(!ProgramStringIsNative(GL_FRAGMENT_PROGRAM_ARB,&quot;unit.fp&quot;)){
-			logOutput.Print(&quot;Your GFX card doesnt support the fragment programs needed to run in shadowed mode&quot;);
-			return;
-		}
+		// this was previously set to true (redundantly since
+		// it was actually never made false anywhere) if either
+		//      1. (!GLEW_ARB_texture_env_crossbar &amp;&amp; haveShadowExts)
+		//      2. (!GLEW_ARB_shadow_ambient &amp;&amp; GLEW_ARB_shadow)
+		// but the non-FP result isn't nice anyway so just always
+		// use the program if we are guaranteed of shadow support
+		useFPShadows = true;
 
-		if(!(GLEW_ARB_shadow &amp;&amp; GLEW_ARB_depth_texture &amp;&amp; GLEW_ARB_vertex_program &amp;&amp; GLEW_ARB_texture_env_combine &amp;&amp; GLEW_ARB_texture_env_crossbar)){
-			if(GLEW_ARB_shadow &amp;&amp; GLEW_ARB_depth_texture &amp;&amp; GLEW_ARB_vertex_program &amp;&amp; GLEW_ARB_texture_env_combine &amp;&amp; GLEW_ARB_fragment_program){
-				//logOutput.Print(&quot;Using ARB_fragment_program_shadow&quot;);
-				useFPShadows=true; // FIXME -- always true
-			} else {
-				logOutput.Print(&quot;You are missing an OpenGL extension needed to use shadowmaps&quot;);
-				return;
-			}
+		if (!GLEW_ARB_shadow_ambient) {
+			// can't use arbitrary texvals in case the depth comparison op fails (only 0)
+			logOutput.Print(&quot;You are missing the \&quot;ARB_shadow_ambient\&quot; extension (this will probably make shadows darker than they should be)&quot;);
 		}
-
-		if(!GLEW_ARB_shadow_ambient){
-			if(GLEW_ARB_fragment_program){
-				if(!useFPShadows){
-					//logOutput.Print(&quot;Using ARB_fragment_program_shadow&quot;);
-				}
-				useFPShadows = true; // FIXME -- always true
-			} else {
-				logOutput.Print(&quot;You are missing the extension ARB_shadow_ambient, this will make shadows darker than they should be&quot;);
-			}
-		}
 	}
 
 	if (!InitDepthTarget()) {
@@ -101,7 +96,6 @@
 	}
 
 	drawShadows = true;
-//	useFPShadows = true; // FIXME -- why was this being forced?
 }
 
 
@@ -144,14 +138,14 @@
 
 CShadowHandler::~CShadowHandler(void)
 {
-	if(drawShadows)
+	if (drawShadows)
 		glDeleteTextures(1, &amp;shadowTexture);
 	delete fb;
 }
 
 void CShadowHandler::DrawShadowPasses(void)
 {
-	inShadowPass=true;
+	inShadowPass = true;
 
 	ph-&gt;DrawShadowPass();
 	unitDrawer-&gt;DrawShadowPass();
@@ -160,17 +154,17 @@
 	treeDrawer-&gt;DrawShadowPass();
 	eventHandler.DrawWorldShadow();
 
-	inShadowPass=false;
+	inShadowPass = false;
 }
 
-void CShadowHandler::GetShadowMapSizeFactors (float &amp;p17, float &amp;p18)
+void CShadowHandler::GetShadowMapSizeFactors(float&amp; p17, float&amp; p18)
 {
-	if(shadowMapSize==2048){
-		p17=0.01f;
-		p18=-0.1f;
+	if (shadowMapSize == 2048) {
+		p17 =  0.01f;
+		p18 = -0.1f;
 	} else {
-		p17=0.0025f;
-		p18=-0.05f;
+		p17 =  0.0025f;
+		p18 = -0.05f;
 	}
 }
 
@@ -403,4 +397,3 @@
 		left.push_back(temp);
 	}
 }
-

Modified: branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -224,6 +224,12 @@
 	while (!tempTransparentDrawUnits.empty() &amp;&amp; tempTransparentDrawUnits.begin()-&gt;first &lt;= gs-&gt;frameNum) {
 		tempTransparentDrawUnits.erase(tempTransparentDrawUnits.begin());
 	}
+
+	GML_STDMUTEX_LOCK(render);
+
+	for(std::set&lt;CUnit *&gt;::iterator ui=uh-&gt;toBeAdded.begin(); ui!=uh-&gt;toBeAdded.end(); ++ui)
+		uh-&gt;renderUnits.push_back(*ui);
+	uh-&gt;toBeAdded.clear();
 }
 
 
@@ -292,6 +298,7 @@
 
 
 inline void CUnitDrawer::DoDrawUnit(CUnit *unit, bool drawReflection, bool drawRefraction, CUnit *excludeUnit) {
+	unit-&gt;UpdateDrawPos();
 #ifdef DIRECT_CONTROL_ALLOWED
 	if (unit == excludeUnit) {
 		return;
@@ -386,9 +393,6 @@
 	drawFar.clear();
 	drawStat.clear();
 
-	drawCloaked.clear();
-	drawCloakedS3O.clear();
-
 	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
 	glFogfv(GL_FOG_COLOR, mapInfo-&gt;atmosphere.fogColor);
 
@@ -411,6 +415,9 @@
 
 	GML_RECMUTEX_LOCK(unit); // Draw
 
+	drawCloaked.clear();
+	drawCloakedS3O.clear();
+
 #ifdef USE_GML
 	if(multiThreadDrawUnit) {
 		mt_drawReflection=drawReflection; // these member vars will be accessed by DoDrawUnitMT
@@ -418,11 +425,11 @@
 	#ifdef DIRECT_CONTROL_ALLOWED
 		mt_excludeUnit=excludeUnit;
 	#endif
-		gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;activeUnits,uh-&gt;activeUnits.size(),50,100,TRUE);
+		gmlProcessor.Work(NULL,NULL,&amp;CUnitDrawer::DoDrawUnitMT,this,gmlThreadCount,FALSE,&amp;uh-&gt;renderUnits,uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
 	else {
 #endif
-		for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
+		for (std::list&lt;CUnit*&gt;::iterator usi = uh-&gt;renderUnits.begin(); usi != uh-&gt;renderUnits.end(); ++usi) {
 			CUnit* unit = *usi;
 			DoDrawUnit(unit,drawReflection,drawRefraction,
 		#ifdef DIRECT_CONTROL_ALLOWED
@@ -693,12 +700,12 @@
 #ifdef USE_GML
 	if(multiThreadDrawUnitShadow) {
 		gmlProcessor.Work(NULL, NULL, &amp;CUnitDrawer::DoDrawUnitShadowMT, this, gmlThreadCount, FALSE,
-		  &amp;uh-&gt;activeUnits, uh-&gt;activeUnits.size(),50,100,TRUE);
+		  &amp;uh-&gt;renderUnits, uh-&gt;renderUnits.size(),50,100,TRUE);
 	}
 	else {
 #endif
 		std::list&lt;CUnit*&gt;::iterator usi;
-		for (usi = uh-&gt;activeUnits.begin(); usi != uh-&gt;activeUnits.end(); ++usi) {
+		for (usi = uh-&gt;renderUnits.begin(); usi != uh-&gt;renderUnits.end(); ++usi) {
 			CUnit* unit = *usi;
 			DoDrawUnitShadow(unit);
 		}
@@ -718,7 +725,7 @@
 
 inline void CUnitDrawer::DrawFar(CUnit *unit)
 {
-	float3 interPos = unit-&gt;pos + unit-&gt;speed * gu-&gt;timeOffset + UpVector * unit-&gt;model-&gt;height * 0.5f;
+	float3 interPos = unit-&gt;drawPos + UpVector * unit-&gt;model-&gt;height * 0.5f;
 	int snurr =- unit-&gt;heading + GetHeadingFromVector(camera-&gt;pos.x - unit-&gt;pos.x, camera-&gt;pos.z - unit-&gt;pos.z) + (0xffff &gt;&gt; 4);
 
 	if (snurr &lt; 0)
@@ -761,7 +768,7 @@
 	} else {
 		pos = helper-&gt;GetUnitErrorPos(unit, gu-&gt;myAllyTeam);
 	}
-	float dist = sqrt((pos - camera-&gt;pos).Length());
+	float dist = fastmath::sqrt2((pos - camera-&gt;pos).Length());
 	float scale = 0.4f * iconData-&gt;GetSize() * dist;
 	if (iconData-&gt;GetRadiusAdjust() &amp;&amp; !asRadarBlip) {
 		// I take the standard unit radius to be 30
@@ -920,6 +927,10 @@
 	// cloaked units and living ghosted buildings (stored in same vector)
 	for (GML_VECTOR&lt;CUnit*&gt;::iterator ui = dC.begin(); ui != dC.end(); ++ui) {
 		CUnit* unit = *ui;
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+		if(unit==NULL)
+			continue;
+#endif
 		const unsigned short losStatus = unit-&gt;losStatus[gu-&gt;myAllyTeam];
 		if ((losStatus &amp; LOS_INLOS) || gu-&gt;spectatingFullView) {
 			if (is_s3o) {
@@ -2037,15 +2048,8 @@
 		return;
 	}
 
-	float3 interPos;
+	float3 interPos = unit-&gt;drawPos;
 
-	CTransportUnit *trans=unit-&gt;transporter;
-	if (!trans) {
-		interPos = unit-&gt;pos + (unit-&gt;speed * gu-&gt;timeOffset);
-	} else {
-		interPos = unit-&gt;pos + (trans-&gt;speed * gu-&gt;timeOffset);
-	}
-
 	interPos.y += unit-&gt;model-&gt;height + 5.0f;
 
 	// setup the billboard transformation

Modified: branches/caiinterface/rts/Rendering/glFont.cpp
===================================================================
--- branches/caiinterface/rts/Rendering/glFont.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Rendering/glFont.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -9,6 +9,7 @@
 #include &lt;stdexcept&gt;
 #include &quot;mmgr.h&quot;
 
+#include &quot;LogOutput.h&quot;
 #include &quot;Game/Camera.h&quot;
 #include &quot;myMath.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
@@ -53,20 +54,16 @@
 };
 
 CFontTextureRenderer::CFontTextureRenderer(int width, int height)
+: width(width), height(height), buffer(NULL), cur(NULL), curX(0), curY(0), curHeight(0)
 {
-	this-&gt;width = width;
-	this-&gt;height = height;
 	buffer = SAFE_NEW unsigned char[2*width*height];		// luminance and alpha per pixel
 	memset(buffer, 0xFF00, width*height);
 	cur = buffer;
-	curX = curY = 0;
-	curHeight = 0;
 }
 
 CFontTextureRenderer::~CFontTextureRenderer()
 {
-	if (buffer)
-		delete [] buffer;
+	delete [] buffer;
 }
 
 void CFontTextureRenderer::AddGlyph(FT_GlyphSlot slot, int &amp;outX, int &amp;outY)
@@ -109,37 +106,31 @@
 
 GLuint CFontTextureRenderer::CreateTexture()
 {
+	glGetError();
 	GLuint tex;
 	glGenTextures(1, &amp;tex);
 
 	glBindTexture(GL_TEXTURE_2D, tex);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+	const GLfloat borderColor[4] = {1.0f,1.0f,1.0f,0.0f};
+	glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
 
-	if (GLEW_EXT_texture_edge_clamp) {
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-	} else {
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
-		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
-	}
-
 	glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE_ALPHA,
 		width, height, 0, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE, buffer);
 
 	delete [] buffer;
-	buffer = 0;
+	buffer = NULL;
 
-	int glError = glGetError();
-	if (glError != GL_NO_ERROR &amp;&amp; glError != GL_INVALID_ENUM) {
-		throw std::runtime_error(&quot;Could not allocate font texture.&quot;);
-	}
 	return tex;
 }
 
 
 
 CglFont::CglFont(int start, int end, const char* fontfile, float size, int texWidth, int texHeight)
+: color(NULL), outlineColor(NULL), glyphs(NULL)
 {
 	FT_Library library;
 	FT_Face face;
@@ -158,8 +149,8 @@
 		throw content_error(msg);
 	}
 
-	const float height = gu-&gt;viewSizeY*size*64.0f;
-	FT_Set_Char_Size(face, (int)(height * gu-&gt;aspectRatio/(4.0f/3.0f)), (int)height, 72, 72);
+	const float height = gu-&gt;viewSizeY * size * 64.0f;
+	FT_Set_Char_Size(face, (int)(height * gu-&gt;aspectRatio / (4.0f/3.0f)), (int)height, 72, 72);
 
 	// clamp the char range
 	end = min(254, end);
@@ -188,16 +179,22 @@
 
 		error = FT_Load_Glyph(face, glyph_index, FT_LOAD_DEFAULT);
 		if ( error ) {
-			string msg = &quot;FT_Load_Glyph failed:&quot;;
-			msg += GetFTError(error);
-			throw std::runtime_error(msg);
+			// skip this glyph
+			g-&gt;advance = 1;
+			g-&gt;height = 1;
+			g-&gt;u0 = g-&gt;u1 = g-&gt;v0 = g-&gt;v1 = 0;
+			g-&gt;x0 = g-&gt;x1 = g-&gt;y0 = g-&gt;y1 = 0;
+			continue;
 		}
 		// convert to an anti-aliased bitmap
 		error = FT_Render_Glyph( face-&gt;glyph, ft_render_mode_normal);
 		if (error) {
-			string msg = &quot;FT_Render_Glyph failed:&quot;;
-			msg += GetFTError(error);
-			throw std::runtime_error(msg);
+			// skip this glyph
+			g-&gt;advance = 1;
+			g-&gt;height = 0;
+			g-&gt;u0 = g-&gt;u1 = g-&gt;v0 = g-&gt;v1 = 0;
+			g-&gt;x0 = g-&gt;x1 = g-&gt;y0 = g-&gt;y1 = 0;
+			continue;
 		}
 		FT_GlyphSlot slot = face-&gt;glyph;
 
@@ -205,7 +202,7 @@
 		try {
 			texRenderer.AddGlyph(slot, texture_x, texture_y);
 		} catch (texture_size_exception&amp;) {
-			FT_Done_Face(face);			// destructor does not run when re-throwing
+			FT_Done_Face(face);			// destructor does not run when throwing from constructor
 			FT_Done_FreeType(library);
 			delete [] glyphs;
 			throw;
@@ -239,7 +236,6 @@
 	fontTexture = texRenderer.CreateTexture();
 
 	outline = false;
-	color = outlineColor = 0;
 
 	defaultColor[0] = 1.0f;
 	defaultColor[1] = 1.0f;
@@ -270,6 +266,7 @@
 
 CglFont::~CglFont()
 {
+	glDeleteTextures(1, &amp;fontTexture);
 	delete[] glyphs;
 }
 
@@ -621,8 +618,8 @@
 
 const float* CglFont::ChooseOutlineColor(const float *textColor)
 {
-	static const float darkOutline[4]  = { 0.25f, 0.25f, 0.25f, 0.8f };
-	static const float lightOutline[4] = { 0.85f, 0.85f, 0.85f, 0.8f };
+	static const GLfloat darkOutline[4]  = { 0.25f, 0.25f, 0.25f, 0.8f };
+	static const GLfloat lightOutline[4] = { 0.85f, 0.85f, 0.85f, 0.8f };
 
 	const float luminance = (textColor[0] * 0.299f) +
 	                        (textColor[1] * 0.587f) +

Modified: branches/caiinterface/rts/Sim/Features/Feature.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Features/Feature.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Features/Feature.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -388,7 +388,7 @@
 		blockHeightChanges = false;
 
 		if (def-&gt;drawType == DRAWTYPE_TREE) {
-			if (impulse.Length2D() &gt; 0.5f) {
+			if (impulse.SqLength2D() &gt; 0.25f) {
 				treeDrawer-&gt;AddFallingTree(pos, impulse, def-&gt;modelType);
 			}
 		}

Modified: branches/caiinterface/rts/Sim/Misc/AirBaseHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/AirBaseHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/AirBaseHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -127,12 +127,12 @@
 			continue;
 		}
 
-		if (baseUnit-&gt;pos.distance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
+		if (baseUnit-&gt;pos.SqDistance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
 			continue;
 		}
 
+		closest = baseUnit-&gt;pos.SqDistance(unit-&gt;pos);
 		for (padLstIt pi = (*bi)-&gt;freePads.begin(); pi != (*bi)-&gt;freePads.end(); ++pi) {
-			closest = baseUnit-&gt;pos.distance(unit-&gt;pos);
 			foundPad = pi;
 			foundBase = bi;
 		}
@@ -169,11 +169,11 @@
 			continue;
 		}
 
-		if (baseUnit-&gt;pos.distance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
+		if (baseUnit-&gt;pos.SqDistance(unit-&gt;pos) &gt;= closest || baseUnit-&gt;unitDef-&gt;buildSpeed &lt; minPower) {
 			continue;
 		}
 
-		closest = baseUnit-&gt;pos.distance(unit-&gt;pos);
+		closest = baseUnit-&gt;pos.SqDistance(unit-&gt;pos);
 		foundBase = bi;
 	}
 

Modified: branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/CollisionHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -27,7 +27,8 @@
 		CR_MEMBER(testType),
 		CR_MEMBER(primaryAxis),
 		CR_MEMBER(secondaryAxes),
-		CR_MEMBER(spherical)
+		CR_MEMBER(spherical),
+		CR_MEMBER(disabled)
 	));
 
 unsigned int CCollisionHandler::numCollisionTests = 0;
@@ -39,10 +40,12 @@
 {
 	bool r = false;
 
-	switch (u-&gt;collisionVolume-&gt;testType) {
-		// Collision(CUnit*) does not need p1 or q
-		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(u, p0       ); numCollisionTests    += 1; } break;
-		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(u, p0, p1, q); numIntersectionTests += 1; } break;
+	if (!u-&gt;collisionVolume-&gt;disabled) {
+		switch (u-&gt;collisionVolume-&gt;testType) {
+			// Collision(CUnit*) does not need p1 or q
+			case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(u, p0       ); numCollisionTests    += 1; } break;
+			case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(u, p0, p1, q); numIntersectionTests += 1; } break;
+		}
 	}
 
 	return r;
@@ -52,10 +55,12 @@
 {
 	bool r = false;
 
-	switch (f-&gt;collisionVolume-&gt;testType) {
-		// Collision(CFeature*) does not need p1 or q
-		case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(f, p0       ); numCollisionTests    += 1; } break;
-		case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(f, p0, p1, q); numIntersectionTests += 1; } break;
+	if (!f-&gt;collisionVolume-&gt;disabled) {
+		switch (f-&gt;collisionVolume-&gt;testType) {
+			// Collision(CFeature*) does not need p1 or q
+			case COLVOL_TEST_DISC: { r = CCollisionHandler::Collision(f, p0       ); numCollisionTests    += 1; } break;
+			case COLVOL_TEST_CONT: { r = CCollisionHandler::Intersect(f, p0, p1, q); numIntersectionTests += 1; } break;
+		}
 	}
 
 	return r;
@@ -170,10 +175,6 @@
 }
 
 
-
-
-
-
 bool CCollisionHandler::MouseHit(const CUnit* u, const float3&amp; p0, const float3&amp; p1, const CollisionVolume* v, CollisionQuery* q)
 {
 	CMatrix44f m = u-&gt;GetTransformMatrix(false, true);

Modified: branches/caiinterface/rts/Sim/Misc/CollisionHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionHandler.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/CollisionHandler.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -40,8 +40,10 @@
 		static bool Collision(const CFeature*, const float3&amp;);
 		static bool Collision(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;);
 
+	public:
 		static bool Intersect(const CUnit*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
 		static bool Intersect(const CFeature*, const float3&amp; p1, const float3&amp; p2, CollisionQuery* q);
+	private:
 		static bool Intersect(const CollisionVolume*, const CMatrix44f&amp;, const float3&amp;, const float3&amp;, CollisionQuery* q);
 
 		static bool IntersectEllipsoid(const CollisionVolume*, const float3&amp;, const float3&amp;, CollisionQuery* q);

Modified: branches/caiinterface/rts/Sim/Misc/CollisionVolume.h
===================================================================
--- branches/caiinterface/rts/Sim/Misc/CollisionVolume.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/CollisionVolume.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -4,7 +4,7 @@
 #include &quot;creg/creg.h&quot;
 #include &quot;Util.h&quot;
 
-const float EPS = 0.000001f;
+const float EPS = 0.0000000001f;
 
 enum COLVOL_TYPES {COLVOL_TYPE_ELLIPSOID, COLVOL_TYPE_CYLINDER, COLVOL_TYPE_BOX};
 enum COLVOL_AXES {COLVOL_AXIS_X, COLVOL_AXIS_Y, COLVOL_AXIS_Z};
@@ -27,6 +27,7 @@
 		secondaryAxes[0]       = src? src-&gt;secondaryAxes[0]:       COLVOL_AXIS_X;
 		secondaryAxes[1]       = src? src-&gt;secondaryAxes[1]:       COLVOL_AXIS_Y;
 		spherical              = src? src-&gt;spherical:              true;
+		disabled               = src? src-&gt;disabled:               false;
 	}
 
 	CollisionVolume(const std::string&amp; typeStr, const float3&amp; scales, const float3&amp; offsets, int testType) {
@@ -70,6 +71,9 @@
 
 
 	void Init(const float3&amp; scales, const float3&amp; offsets, int vType, int tType, int pAxis) {
+		disabled = (tType &lt; 0);
+		tType = std::max(tType, 0);
+
 		// assign these here, since we can be
 		// called from outside the constructor
 		primaryAxis = pAxis % 3;
@@ -168,6 +172,7 @@
 	int primaryAxis;
 	int secondaryAxes[2];
 	bool spherical;
+	bool disabled;
 };
 
 #endif

Modified: branches/caiinterface/rts/Sim/Misc/DamageArrayHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/DamageArrayHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/DamageArrayHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -43,7 +43,7 @@
 		typeList.insert(typeList.begin(), &quot;default&quot;);
 		name2type[&quot;default&quot;] = 0;
 
-		logOutput.Print(1, &quot;Number of damage types: %d&quot;, numTypes);
+		logOutput.Print(&quot;Number of damage types: %d&quot;, numTypes);
 
 		for (int armorID = 1; armorID &lt; (int)typeList.size(); armorID++) {
 			const string armorName = StringToLower(typeList[armorID]);

Modified: branches/caiinterface/rts/Sim/Misc/InterceptHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/InterceptHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/InterceptHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,6 +10,7 @@
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
 #include &quot;Sim/Weapons/PlasmaRepulser.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;creg/STL_List.h&quot;
 
 CR_BIND(CInterceptHandler, )
@@ -53,7 +54,7 @@
 
 	for(std::list&lt;CWeapon*&gt;::iterator wi=interceptors.begin();wi!=interceptors.end();++wi){
 		CWeapon* w=*wi;
-		if ((targTeam==-1 || !gs-&gt;Ally(w-&gt;owner-&gt;allyteam,targTeam)) &amp;&amp; (target-&gt;weaponDef-&gt;targetable &amp; w-&gt;weaponDef-&gt;interceptor) &amp;&amp; w-&gt;weaponPos.distance2D(destination) &lt; w-&gt;weaponDef-&gt;coverageRange){
+		if ((targTeam==-1 || !gs-&gt;Ally(w-&gt;owner-&gt;allyteam,targTeam)) &amp;&amp; (target-&gt;weaponDef-&gt;targetable &amp; w-&gt;weaponDef-&gt;interceptor) &amp;&amp; w-&gt;weaponPos.SqDistance2D(destination) &lt; Square(w-&gt;weaponDef-&gt;coverageRange)){
 			w-&gt;incoming.push_back(target);
 			w-&gt;AddDeathDependence(target);
 		}

Modified: branches/caiinterface/rts/Sim/Misc/QuadField.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Misc/QuadField.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Misc/QuadField.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -154,6 +154,8 @@
 
 std::vector&lt;CUnit*&gt; CQuadField::GetUnits(const float3&amp; pos,float radius)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetUnits
+
 	std::vector&lt;CUnit*&gt; units;
 
 	int* endQuad=tempQuads;
@@ -176,6 +178,8 @@
 
 std::vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; pos,float radius)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetUnitsExact
+
 	std::vector&lt;CUnit*&gt; units;
 
 	int* endQuad=tempQuads;
@@ -199,6 +203,8 @@
 
 std::vector&lt;CUnit*&gt; CQuadField::GetUnitsExact(const float3&amp; mins, const float3&amp; maxs)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetUnitsExact
+
 	std::vector&lt;CUnit*&gt; units;
 	std::vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
 
@@ -410,6 +416,8 @@
 
 vector&lt;CFeature*&gt; CQuadField::GetFeaturesExact(const float3&amp; pos,float radius)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetFeaturesExact
+
 	vector&lt;CFeature*&gt; features;
 /*	if(pos.x&lt;0 || pos.z&lt;0 || pos.x&gt;gs-&gt;mapx*SQUARE_SIZE || pos.z&gt;gs-&gt;mapy*SQUARE_SIZE){
 		logOutput.Print(&quot;Trying to get units outside map %.0f %.0f&quot;,pos.x,pos.z);
@@ -438,6 +446,8 @@
 std::vector&lt;CFeature*&gt; CQuadField::GetFeaturesExact(const float3&amp; mins,
                                                const float3&amp; maxs)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetFeaturesExact
+
 	std::vector&lt;CFeature*&gt; features;
 	std::vector&lt;int&gt; quads = GetQuadsRectangle(mins, maxs);
 
@@ -464,6 +474,8 @@
 
 std::vector&lt;CSolidObject*&gt; CQuadField::GetSolidsExact(const float3&amp; pos,float radius)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetSolidsExact
+
 	std::vector&lt;CSolidObject*&gt; solids;
 	std::vector&lt;int&gt; quads = GetQuads(pos,radius);
 	int tempNum = gs-&gt;tempNum++;
@@ -522,6 +534,8 @@
 // optimization specifically for projectile collisions
 void CQuadField::GetUnitsAndFeaturesExact(const float3&amp; pos, float radius, CUnit**&amp; dstUnit, CFeature**&amp; dstFeature)
 {
+	GML_RECMUTEX_LOCK(qnum); // GetUnitsAndFeaturesExact
+
 	int tempNum=gs-&gt;tempNum++;
 
 	int* endQuad = tempQuads;

Modified: branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/MoveTypes/AirMoveType.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -205,7 +205,7 @@
 
 			goalPos = pos;
 
-			if (pos.distance2D(owner-&gt;pos) &lt; 400) {
+			if (pos.SqDistance2D(owner-&gt;pos) &lt; (400*400)) {
 				padStatus = 1;
 			}
 		} else if (padStatus == 1) {
@@ -216,7 +216,7 @@
 			goalPos = pos;
 			reservedLandingPos = pos;
 
-			if (owner-&gt;pos.distance(pos) &lt; 3 || aircraftState == AIRCRAFT_LANDED) {
+			if (owner-&gt;pos.SqDistance(pos) &lt; 9 || aircraftState == AIRCRAFT_LANDED) {
 				padStatus = 2;
 			}
 		} else {
@@ -249,6 +249,8 @@
 	switch (aircraftState) {
 		case AIRCRAFT_FLYING: {
 	#ifdef DEBUG_AIRCRAFT
+			GML_RECMUTEX_LOCK(sel); // Update
+
 			if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
 				logOutput.Print(&quot;Flying %i %i %.1f %i&quot;, moveState, fireState, inefficientAttackTime, (int) isFighter);
 			}
@@ -273,7 +275,7 @@
 				if (maneuver) {
 					UpdateManeuver();
 					inefficientAttackTime = 0;
-				} else if (isFighter &amp;&amp; goalPos.distance(pos) &lt; owner-&gt;maxRange * 4) {
+				} else if (isFighter &amp;&amp; goalPos.SqDistance(pos) &lt; Square(owner-&gt;maxRange * 4)) {
 					inefficientAttackTime++;
 					UpdateFighterAttack();
 				} else {
@@ -437,6 +439,8 @@
 void CAirMoveType::UpdateManeuver(void)
 {
 #ifdef DEBUG_AIRCRAFT
+	GML_RECMUTEX_LOCK(sel); // UpdateManuever
+
 	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
 		logOutput.Print(&quot;UpdataMan %i %i&quot;, maneuver, maneuverSubState);
 	}
@@ -658,6 +662,8 @@
 			elevator = minPitch * upside;
 	}
 #ifdef DEBUG_AIRCRAFT
+	GML_RECMUTEX_LOCK(sel); // UpdateFighterAttack
+
 	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()){
 		logOutput.Print(&quot;FAttack %.1f %.1f %.2f&quot;, pos.y - gHeight, goalLength, goalDir.dot(frontdir));
 	}
@@ -1084,6 +1090,8 @@
 	owner-&gt;UpdateMidPos();
 
 #ifdef DEBUG_AIRCRAFT
+	GML_RECMUTEX_LOCK(sel); // UpdateAirPhysics
+
 	if (selectedUnits.selectedUnits.find(this) != selectedUnits.selectedUnits.end()) {
 		logOutput.Print(&quot;UpdataAP %.1f %.1f %.1f %.1f&quot;, speedf, pos.x, pos.y, pos.z);
 		// logOutput.Print(&quot;Rudders %.1f %.1f %.1f %.1f&quot;, rudder, aileron, elevator, engine);

Modified: branches/caiinterface/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -286,7 +286,7 @@
 					logOutput.Print(&quot;eta failure %i %i %i %i %i&quot;, owner-&gt;id, pathId, !atGoal, currentDistanceToWaypoint &lt; MinDistanceToWaypoint(), gs-&gt;frameNum &gt; etaWaypoint);
 			}
 			if (pathId &amp;&amp; !atGoal &amp;&amp; gs-&gt;frameNum &gt; etaWaypoint2) {
-				if (owner-&gt;pos.distance2D(goalPos) &gt; 200 || CheckGoalFeasability()) {
+				if (owner-&gt;pos.SqDistance2D(goalPos) &gt; (200*200) || CheckGoalFeasability()) {
 					etaWaypoint2 += 100;
 				} else {
 					if (DEBUG_CONTROLLER)
@@ -402,7 +402,7 @@
 
 	// if we've strayed too far away from path, then need to reconsider
 	if (progressState == Active &amp;&amp; etaFailures &gt; 8) {
-		if (owner-&gt;pos.distance2D(goalPos) &gt; 200 || CheckGoalFeasability()) {
+		if (owner-&gt;pos.SqDistance2D(goalPos) &gt; (200*200) || CheckGoalFeasability()) {
 			if (DEBUG_CONTROLLER)
 				logOutput.Print(&quot;ETA failure for unit %i&quot;, owner-&gt;id);
 
@@ -684,10 +684,10 @@
 	if(impulse.dot(groundNormal)&lt;0)
 		impulse-=groundNormal*impulse.dot(groundNormal);
 
-	float strength=impulse.Length();
+	const float sqstrength=impulse.SqLength();
 //	logOutput.Print(&quot;strength %f&quot;,strength);
 
-	if(strength&gt;3 || impulse.dot(groundNormal)&gt;0.3f){
+	if(sqstrength&gt;9 || impulse.dot(groundNormal)&gt;0.3f){
 		skidding=true;
 		speed+=impulse;
 		impulse=ZeroVector;
@@ -1091,9 +1091,12 @@
 							(o-&gt;mobility || Distance2D(owner, o) &gt;= 0)) {
 							// Avoid collision by turning the heading to left or right.
 							// Using the object thats needs the most adjustment.
-							if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end())
+#if DEBUG_CONTROLLER
+							GML_RECMUTEX_LOCK(sel); // ObstacleAvoidance
+
+							if (selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end())
 								geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, o-&gt;pos + UpVector * 20, 3, 1, 4);
-
+#endif
 							if (objectDistToAvoidDirCenter &gt; 0.0f) {
 								avoidRight += (radiusSum - objectDistToAvoidDirCenter) * AVOIDANCE_STRENGTH / distanceToObject;
 								avoidanceDir += (rightOfAvoid * avoidRight);
@@ -1116,13 +1119,18 @@
 
 			// Sum up avoidance.
 			avoidanceVec = (desiredDir.cross(float3(0.0f, 1.0f, 0.0f)) * (avoidRight - avoidLeft));
-			if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end()) {
+
+#if DEBUG_CONTROLLER
+			GML_RECMUTEX_LOCK(sel); //ObstacleAvoidance
+
+			if (selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end()) {
 				int a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + avoidanceVec * 40, 7, 1, 4);
 				geometricObjects-&gt;SetColor(a, 1, 0.3f, 0.3f, 0.6f);
 
 				a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + desiredDir * 40, 7, 1, 4);
 				geometricObjects-&gt;SetColor(a, 0.3f, 0.3f, 1, 0.6f);
 			}
+#endif
 		}
 
 		// Return the resulting recommended velocity.
@@ -1177,7 +1185,7 @@
 // Creates a path to the goal.
 void CGroundMoveType::GetNewPath()
 {
-	if (owner-&gt;pos.distance2D(lastGetPathPos) &lt; 20) {
+	if (owner-&gt;pos.SqDistance2D(lastGetPathPos) &lt; 400) {
 		if (DEBUG_CONTROLLER)
 			logOutput.Print(&quot;Non-moving path failures for unit %i: %i&quot;, owner-&gt;id, nonMovingFailures);
 		nonMovingFailures++;
@@ -1236,7 +1244,7 @@
 			nextWaypoint = waypoint;
 		}
 		// If the waypoint is very close to the goal, then correct it into the goal.
-		if (waypoint.distance2D(goalPos) &lt; CPathManager::PATH_RESOLUTION) {
+		if (waypoint.SqDistance2D(goalPos) &lt; Square(CPathManager::PATH_RESOLUTION)) {
 			waypoint = goalPos;
 			haveFinalWaypoint = true;
 		}
@@ -1407,7 +1415,7 @@
 				owner-&gt;unitDef-&gt;sounds.cant.getVolume(soundIdx));
 		}
 		if (!owner-&gt;commandAI-&gt;unimportantMove &amp;&amp;
-		    (owner-&gt;pos.distance(goalPos) &gt; (goalRadius + 150.0f))) {
+		    (owner-&gt;pos.SqDistance(goalPos) &gt; Square(goalRadius + 150.0f))) {
 			logOutput.Print(owner-&gt;unitDef-&gt;humanName + &quot;: Can't reach destination!&quot;);
 			logOutput.SetLastMsgPos(owner-&gt;pos);
 		}

Modified: branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -55,7 +55,10 @@
 	CR_MEMBER(forceHeadingTo),
 
 	CR_MEMBER(maxDrift),
-	CR_RESERVED(63)
+
+	CR_MEMBER(randomWind),
+
+	CR_RESERVED(59)
 	));
 
 
@@ -306,26 +309,34 @@
 
 
 
-// Move the unit around a bit.. and when it gets too far away from goal position
-// it switches to normal flying instead
+// Move the unit around a bit..
 void CTAAirMoveType::UpdateHovering()
 {
-	float driftSpeed = owner-&gt;unitDef-&gt;dlHoverFactor;
+	const float driftSpeed = fabs(owner-&gt;unitDef-&gt;dlHoverFactor);
 	float3 deltaVec = goalPos - owner-&gt;pos;
-	float3 deltaDir = float3(deltaVec).Normalize();
+	float3 deltaDir = float3(deltaVec.x, 0, deltaVec.z);
+	const float l   = deltaDir.Length2D();
+	deltaDir       /= std::max(l,0.0001f);
+	float moveFactor  = math::sqrt(std::max(0.0f, l - 4.0f));
 
 	// move towards goal position if it's not immediately
 	// behind us when we have more waypoints to get to
-	if (aircraftState != AIRCRAFT_LANDING &amp;&amp; (owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
-		deltaVec.Length2D() &lt; 120) &amp;&amp; deltaDir.distance(deltaVec) &gt; 1.0f) {
+	if (aircraftState != AIRCRAFT_LANDING &amp;&amp; owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
+		(l &lt; 120) &amp;&amp; (deltaDir.SqDistance(deltaVec) &gt; 1.0f)) {
 		deltaDir = owner-&gt;frontdir;
+		moveFactor = 1.0f;
 	}
 
-	wantedSpeed += float3(deltaDir.x, 0.0f, deltaDir.z) * driftSpeed * 0.03f;
 	// damping
-	wantedSpeed *= 0.97f;
+	wantedSpeed = owner-&gt;speed * 0.95f;
+
+	wantedSpeed += deltaDir * moveFactor * 0.05f;
+
 	// random movement (a sort of fake wind effect)
-	wantedSpeed += float3(gs-&gt;randFloat() - 0.5f, 0.0f, gs-&gt;randFloat() - 0.5f) * driftSpeed * 0.5f;
+	// random drift values are in range -0.5 ... 0.5
+	randomWind = float3(randomWind.x * 0.9f + (gs-&gt;randFloat() - 0.5f) * 0.5f, 0,
+		            randomWind.z * 0.9f + (gs-&gt;randFloat() - 0.5f) * 0.5f);
+	wantedSpeed += randomWind * driftSpeed * 0.5f;
 
 	UpdateAirPhysics();
 }
@@ -341,8 +352,8 @@
 	owner-&gt;restTime = 0;
 
 	// don't change direction for waypoints we just flew over and missed slightly
-	if (flyState != FLY_LANDING &amp;&amp; (owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
-		dir.Length2D() &lt; 100) &amp;&amp; (goalPos - pos).Normalize().distance(dir) &lt; 1) {
+	if (flyState != FLY_LANDING &amp;&amp; owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
+		(dir.SqLength2D() &lt; 10000) &amp;&amp; (float3(dir).Normalize().SqDistance(dir) &lt; 1)) {
 		dir = owner-&gt;frontdir;
 	}
 
@@ -356,12 +367,18 @@
 	if (closeToGoal) {
 		// pretty close
 		switch (flyState) {
-			case FLY_CRUISING:
-				if (dontLand || (++waitCounter &lt; 55 &amp;&amp; dynamic_cast&lt;CTransportUnit*&gt;(owner))
-						|| !autoLand) {
+			case FLY_CRUISING: {
+				bool trans = dynamic_cast&lt;CTransportUnit*&gt;(owner);
+				bool noland = dontLand || !autoLand;
+				// should CMD_LOAD_ONTO be here?
+				bool hasLoadCmds = trans
+						&amp;&amp; (owner-&gt;commandAI-&gt;commandQue.front().id == CMD_LOAD_ONTO
+							|| owner-&gt;commandAI-&gt;commandQue.front().id == CMD_LOAD_UNITS);
+				if (noland || (trans &amp;&amp; ++waitCounter &lt; 55 &amp;&amp; hasLoadCmds)) {
 					// transport aircraft need some time to detect that they can pickup
-					if (dynamic_cast&lt;CTransportUnit*&gt;(owner)) {
+					if (trans) {
 						wantedSpeed = ZeroVector;
+						SetState(AIRCRAFT_HOVERING);
 						if (waitCounter &gt; 60) {
 							wantedHeight = orgWantedHeight;
 						}
@@ -376,6 +393,7 @@
 					SetState(AIRCRAFT_LANDING);
 				}
 				return;
+			}
 			case FLY_CIRCLING:
 				// break;
 				waitCounter++;
@@ -446,7 +464,7 @@
 	if ((flyState == FLY_ATTACKING) || (flyState == FLY_CIRCLING)) {
 		dir = circlingPos - pos;
 	} else if (flyState != FLY_LANDING &amp;&amp; (owner-&gt;commandAI-&gt;HasMoreMoveCommands() &amp;&amp;
-			   dist &lt; 120) &amp;&amp; (goalPos - pos).Normalize().distance(dir) &gt; 1) {
+			   dist &lt; 120) &amp;&amp; (goalPos - pos).Normalize().SqDistance(dir) &gt; 1) {
 		dir = owner-&gt;frontdir;
 	} else {
 		dir = goalPos - pos;
@@ -487,7 +505,7 @@
 			owner-&gt;Deactivate();
 			owner-&gt;cob-&gt;Call(COBFN_StopMoving);
 		} else {
-			if (goalPos.distance2D(pos) &lt; 30) {
+			if (goalPos.SqDistance2D(pos) &lt; 900) {
 				goalPos = goalPos + gs-&gt;randVector() * 300;
 				goalPos.CheckInBounds();
 			}
@@ -662,11 +680,15 @@
 			ws = 0.0f;
 	}
 
-	if (speed.y &gt; ws) {
-		speed.y = std::max(ws, speed.y - accRate * 1.5f);
+	if (fabs(wh - h) &gt; 2.0f) {
+		if (speed.y &gt; ws) {
+			speed.y = std::max(ws, speed.y - accRate * 1.5f);
+		} else {
+			// let them accelerate upward faster if close to ground
+			speed.y = std::min(ws, speed.y + accRate * (h &lt; 20.0f? 2.0f: 0.7f));
+		}
 	} else {
-		// let them accelerate upward faster if close to ground
-		speed.y = std::min(ws, speed.y + accRate * (h &lt; 20.0f? 2.0f: 0.7f));
+		speed.y = speed.y * 0.95;
 	}
 
 	pos += speed;
@@ -765,7 +787,7 @@
 
 					goalPos = pos;
 
-					if (pos.distance2D(owner-&gt;pos) &lt; 400) {
+					if (pos.SqDistance2D(owner-&gt;pos) &lt; 400*400) {
 						padStatus = 1;
 					}
 				} else if (padStatus == 1) {
@@ -777,7 +799,7 @@
 					reservedLandingPos = pos;
 					wantedHeight = pos.y - ground-&gt;GetHeight(pos.x, pos.z);
 
-					if (owner-&gt;pos.distance(pos) &lt; 3 || aircraftState == AIRCRAFT_LANDED) {
+					if (owner-&gt;pos.SqDistance(pos) &lt; 9 || aircraftState == AIRCRAFT_LANDED) {
 						padStatus = 2;
 					}
 				} else {

Modified: branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h
===================================================================
--- branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/MoveTypes/TAAirMoveType.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -51,9 +51,9 @@
 
 	float maxDrift;
 
+	float3 randomWind;			//buffets the plane when idling
 
 
-
 	CTAAirMoveType(CUnit* owner);
 	~CTAAirMoveType(void);
 

Modified: branches/caiinterface/rts/Sim/Path/PathEstimator.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Path/PathEstimator.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Path/PathEstimator.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -911,7 +911,8 @@
 
 void CPathEstimator::Draw(void)
 {
-//	GML_RECMUTEX_LOCK(sel); // Draw
+	GML_RECMUTEX_LOCK(sel); // Draw
+
 	MoveData* md = moveinfo-&gt;GetMoveDataFromName(&quot;TANKSH2&quot;);
 	if (!selectedUnits.selectedUnits.empty() &amp;&amp; (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata)
 		md = (*selectedUnits.selectedUnits.begin())-&gt;unitDef-&gt;movedata;
@@ -989,7 +990,7 @@
 					glColor3f(1, 1 / (cost/BLOCK_SIZE), blue);
 
 					p2 = (p1 + p2) / 2;
-					if (camera-&gt;pos.distance(p2) &lt; 500) {
+					if (camera-&gt;pos.SqDistance(p2) &lt; 250000) {
 						glPushMatrix();
 						glTranslatef3(p2);
 						glScalef(5, 5, 5);
@@ -1049,7 +1050,7 @@
 		p1.z=(ob-&gt;block.y * BLOCK_SIZE + blockState[blocknr].sqrCenter[md-&gt;pathType].y)*SQUARE_SIZE;
 		p1.y=ground-&gt;GetHeight(p1.x,p1.z)+15;
 
-		if(camera-&gt;pos.distance(p1)&lt;500){
+		if(camera-&gt;pos.SqDistance(p1)&lt;250000){
 			glPushMatrix();
 			glTranslatef3(p1);
 			glScalef(5,5,5);

Modified: branches/caiinterface/rts/Sim/Path/PathManager.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Path/PathManager.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Path/PathManager.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -6,6 +6,7 @@
 
 #include &quot;PathManager.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/MoveTypes/MoveMath/GroundMoveMath.h&quot;
 #include &quot;Sim/MoveTypes/MoveMath/HoverMoveMath.h&quot;
@@ -235,7 +236,7 @@
 	//Remove estimate waypoints until
 	//the next one is far enought.
 	while(!path.estimatedPath.path.empty()
-	&amp;&amp; path.estimatedPath.path.back().distance2D(startPos) &lt; DETAILED_DISTANCE * SQUARE_SIZE)
+	&amp;&amp; path.estimatedPath.path.back().SqDistance2D(startPos) &lt; Square(DETAILED_DISTANCE * SQUARE_SIZE))
 		path.estimatedPath.path.pop_back();
 
 	//Get the goal of the detailed search.
@@ -275,7 +276,7 @@
 	//Remove estimate2 waypoints until
 	//the next one is far enought.
 	while(!path.estimatedPath2.path.empty()
-	&amp;&amp; path.estimatedPath2.path.back().distance2D(startPos) &lt; ESTIMATE_DISTANCE * SQUARE_SIZE)
+	&amp;&amp; path.estimatedPath2.path.back().SqDistance2D(startPos) &lt; Square(ESTIMATE_DISTANCE * SQUARE_SIZE))
 		path.estimatedPath2.path.pop_back();
 
 	//Get the goal of the detailed search.
@@ -330,11 +331,11 @@
 
 	//check if detailed path need bettering
 	if(!multiPath-&gt;estimatedPath.path.empty()
-	&amp;&amp; (multiPath-&gt;estimatedPath.path.back().distance2D(callerPos) &lt; MIN_DETAILED_DISTANCE * SQUARE_SIZE
+	&amp;&amp; (multiPath-&gt;estimatedPath.path.back().SqDistance2D(callerPos) &lt; Square(MIN_DETAILED_DISTANCE * SQUARE_SIZE)
 	|| multiPath-&gt;detailedPath.path.size() &lt;= 2)){
 
 		if(!multiPath-&gt;estimatedPath2.path.empty()		//if so check if estimated path also need bettering
-			&amp;&amp; (multiPath-&gt;estimatedPath2.path.back().distance2D(callerPos) &lt; MIN_ESTIMATE_DISTANCE * SQUARE_SIZE
+			&amp;&amp; (multiPath-&gt;estimatedPath2.path.back().SqDistance2D(callerPos) &lt; Square(MIN_ESTIMATE_DISTANCE * SQUARE_SIZE)
 			|| multiPath-&gt;estimatedPath.path.size() &lt;= 2)){
 				Estimate2ToEstimate(*multiPath, callerPos);
 		}
@@ -359,7 +360,7 @@
 			waypoint = multiPath-&gt;detailedPath.path.back();
 			multiPath-&gt;detailedPath.path.pop_back();
 		}
-	} while(callerPos.distance2D(waypoint) &lt; minDistance &amp;&amp; waypoint != multiPath-&gt;detailedPath.pathGoal);
+	} while(callerPos.SqDistance2D(waypoint) &lt; Square(minDistance) &amp;&amp; waypoint != multiPath-&gt;detailedPath.pathGoal);
 
 	return waypoint;
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -311,7 +311,7 @@
 
 CCustomExplosionGenerator::CCustomExplosionGenerator()
 {
-	currentCEG = 0;
+	currentCEG = cachedCEGs.end();
 }
 
 CCustomExplosionGenerator::~CCustomExplosionGenerator()
@@ -606,9 +606,11 @@
 
 void CCustomExplosionGenerator::Load(CExplosionGeneratorHandler* h, const string&amp; tag)
 {
-	static std::map&lt;string, CEGData&gt; cachedCEGs;
-	std::map&lt;string, CEGData&gt;::iterator it = cachedCEGs.find(tag);
+	typedef std::map&lt;string, CEGData&gt; CEGMap;
+	typedef std::map&lt;string, CEGData&gt;::iterator CEGMapIt;
 
+	CEGMapIt it = cachedCEGs.find(tag);
+
 	if (it == cachedCEGs.end()) {
 		CEGData cegData;
 
@@ -686,19 +688,18 @@
 		}
 
 		cegData.useDefaultExplosions = expTable.GetBool(&quot;useDefaultExplosions&quot;, false);
+		it = cachedCEGs.insert(std::make_pair(tag, cegData)).first;
+	}
 
-		cachedCEGs[tag] = cegData;
-		currentCEG = &amp;cachedCEGs[tag];
-	} else {
-		currentCEG = &amp;(it-&gt;second);
-	}
+	currentCEG = it;
 }
 
 
 void CCustomExplosionGenerator::Explosion(const float3&amp; pos, float damage, float radius, CUnit* owner, float gfxMod, CUnit* hit, const float3&amp; dir)
 {
-	if (currentCEG == 0) {
-		// Explosion() called before Load()'ing a CEG
+	if (currentCEG == cachedCEGs.end()) {
+		// Explosion() called before Load()'ing a CEG (after
+		// constructing a CCustomExplosionGenerator object)
 		return;
 	}
 
@@ -713,29 +714,29 @@
 	if (hit) flags |= SPW_UNIT;
 	else     flags |= SPW_NO_UNIT;
 
-	for (int a = 0; a &lt; currentCEG-&gt;projectileSpawn.size(); a++) {
-		ProjectileSpawnInfo* psi = &amp;currentCEG-&gt;projectileSpawn[a];
+	for (int a = 0; a &lt; (currentCEG-&gt;second).projectileSpawn.size(); a++) {
+		ProjectileSpawnInfo&amp; psi = (currentCEG-&gt;second).projectileSpawn[a];
 
-		if (!(psi-&gt;flags &amp; flags)) {
+		if (!(psi.flags &amp; flags)) {
 			continue;
 		}
 
-		for (int c = 0; c &lt; psi-&gt;count; c++) {
-			CExpGenSpawnable* projectile = (CExpGenSpawnable*) psi-&gt;projectileClass-&gt;CreateInstance();
+		for (int c = 0; c &lt; psi.count; c++) {
+			CExpGenSpawnable* projectile = (CExpGenSpawnable*) (psi.projectileClass)-&gt;CreateInstance();
 
-			ExecuteExplosionCode(&amp;psi-&gt;code[0], damage, (char*) projectile, c, dir);
+			ExecuteExplosionCode(&amp;psi.code[0], damage, (char*) projectile, c, dir);
 			projectile-&gt;Init(pos, owner);
 		}
 	}
 
-	const GroundFlashInfo&amp; groundFlash = currentCEG-&gt;groundFlash;
+	const GroundFlashInfo&amp; groundFlash = (currentCEG-&gt;second).groundFlash;
 
 	if ((flags &amp; SPW_GROUND) &amp;&amp; groundFlash.ttl &gt; 0) {
 		SAFE_NEW CStandardGroundFlash(pos, groundFlash.circleAlpha, groundFlash.flashAlpha,
 			groundFlash.flashSize, groundFlash.circleGrowth, groundFlash.ttl, groundFlash.color);
 	}
 
-	if (currentCEG-&gt;useDefaultExplosions) {
+	if ((currentCEG-&gt;second).useDefaultExplosions) {
 		CStdExplosionGenerator::Explosion(pos, damage, radius, owner, gfxMod, hit, dir);
 	}
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/ExplosionGenerator.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,6 +1,7 @@
 #ifndef EXPLOSION_GRAPHICS_H
 #define EXPLOSION_GRAPHICS_H
 
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &quot;Sim/Misc/DamageArray.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
 #include &quot;Sim/Objects/WorldObject.h&quot;
@@ -18,7 +19,7 @@
 	CExpGenSpawnable(): CWorldObject(){};
 	CExpGenSpawnable(const float3&amp; pos): CWorldObject(pos) {};
 	virtual ~CExpGenSpawnable() {};
-	virtual void Init(const float3&amp; pos, CUnit* owner) = 0;
+	virtual void Init(const float3&amp; pos, CUnit* owner GML_PARG_H) = 0;
 };
 
 
@@ -111,7 +112,9 @@
 		bool useDefaultExplosions;
 	};
 
-	CEGData* currentCEG;
+	std::map&lt;string, CEGData&gt; cachedCEGs;
+	std::map&lt;string, CEGData&gt;::iterator currentCEG;
+
 	void ParseExplosionCode(ProjectileSpawnInfo* psi, int baseOffset, boost::shared_ptr&lt;creg::IType&gt; type, const std::string&amp; script, std::string&amp; code);
 	void ExecuteExplosionCode (const char* code, float damage, char* instance, int spawnIndex, const float3&amp; dir);
 

Modified: branches/caiinterface/rts/Sim/Projectiles/FireProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/FireProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/FireProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -39,8 +39,8 @@
 	));
 
 
-CFireProjectile::CFireProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int emitTtl,float emitRadius,int particleTtl,float particleSize)
-: CProjectile(pos,speed,owner, true),
+CFireProjectile::CFireProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int emitTtl,float emitRadius,int particleTtl,float particleSize GML_PARG_C)
+: CProjectile(pos,speed,owner, true GML_PARG_P),
 	ttl(emitTtl),
 	emitPos(pos),
 	emitRadius(emitRadius),
@@ -137,8 +137,8 @@
 		float size=pi-&gt;maxSize*(age);
 		float rot=pi-&gt;rotSpeed*age;
 
-		float sinRot=sin(rot);
-		float cosRot=cos(rot);
+		float sinRot=fastmath::sin(rot);
+		float cosRot=fastmath::cos(rot);
 		float3 dir1=(camera-&gt;right*cosRot+camera-&gt;up*sinRot)*size;
 		float3 dir2=(camera-&gt;right*sinRot-camera-&gt;up*cosRot)*size;
 
@@ -155,11 +155,11 @@
 	}
 	for(std::list&lt;SubParticle&gt;::iterator pi=subParticles.begin();pi!=subParticles.end();++pi){
 		float age=pi-&gt;age+ageSpeed*gu-&gt;timeOffset;
-		float size=pi-&gt;maxSize*sqrt(age);
+		float size=pi-&gt;maxSize*fastmath::sqrt(age);
 		float rot=pi-&gt;rotSpeed*age;
 
-		float sinRot=sin(rot);
-		float cosRot=cos(rot);
+		float sinRot=fastmath::sin(rot);
+		float cosRot=fastmath::cos(rot);
 		float3 dir1=(camera-&gt;right*cosRot+camera-&gt;up*sinRot)*size;
 		float3 dir2=(camera-&gt;right*sinRot-camera-&gt;up*cosRot)*size;
 

Modified: branches/caiinterface/rts/Sim/Projectiles/FireProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/FireProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/FireProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 	CR_DECLARE(CFireProjectile);
 	CR_DECLARE_SUB(SubParticle);
 public:
-	CFireProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int emitTtl,float emitRadius,int particleTtl,float particleSize);
+	CFireProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int emitTtl,float emitRadius,int particleTtl,float particleSize GML_PARG_H);
 	~CFireProjectile(void);
 
 	void Draw(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -28,8 +28,8 @@
 				CR_RESERVED(8)
 				));
 
-CFlareProjectile::CFlareProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int activateFrame)
-:	CProjectile(pos,speed,owner, true),
+CFlareProjectile::CFlareProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int activateFrame GML_PARG_C)
+:	CProjectile(pos,speed,owner, true GML_PARG_P),
 	activateFrame(activateFrame),
 	deathFrame(activateFrame+(owner?owner-&gt;unitDef-&gt;flareTime:1)),
 	numSub(0),

Modified: branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/FlareProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -9,7 +9,7 @@
 {
 public:
 	CR_DECLARE(CFlareProjectile);
-	CFlareProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int activateFrame);
+	CFlareProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner,int activateFrame GML_PARG_H);
 	~CFlareProjectile();
 	void Update(void);
 	void Draw(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -58,8 +58,8 @@
 	}
 }
 
-CPieceProjectile::CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalS3DO* piece, int f, CUnit* owner, float radius):
-	CProjectile(pos, speed, owner, true),
+CPieceProjectile::CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalS3DO* piece, int f, CUnit* owner, float radius GML_PARG_C):
+	CProjectile(pos, speed, owner, true GML_PARG_P),
 	dispList(piece? piece-&gt;displist: 0),
 	drawTrail(true),
 	oldSmoke(pos),
@@ -181,7 +181,7 @@
 
 void CPieceProjectile::Collision()
 {
-	if (speed.Length() &gt; gs-&gt;randFloat() * 5 + 1 &amp;&amp; pos.y &gt; radius + 2) {
+	if (speed.SqLength() &gt; Square(gs-&gt;randFloat() * 5 + 1) &amp;&amp; pos.y &gt; radius + 2) {
 		float3 norm = ground-&gt;GetNormal(pos.x, pos.z);
 		float ns = speed.dot(norm);
 		speed -= norm * ns * 1.6f;
@@ -334,7 +334,6 @@
 	if (flags &amp; PP_NoCEGTrail) {
 		if (flags &amp; PP_Smoke) {
 			// this piece leaves a default (non-CEG) smoketrail
-			float3 interPos = pos + speed * gu-&gt;timeOffset;
 			inArray = true;
 			float age2 = (age &amp; 7) + gu-&gt;timeOffset;
 			float color = 0.5f;
@@ -347,7 +346,7 @@
 			va-&gt;EnlargeArrays(4+4*numParts,0,VA_SIZE_TC);
 			if (drawTrail) {
 				// draw the trail as a single quad if camera close enough
-				float3 dif(interPos - camera-&gt;pos);
+				float3 dif(drawPos - camera-&gt;pos);
 				dif.Normalize();
 				float3 dir1(dif.cross(dir));
 				dir1.Normalize();
@@ -379,8 +378,8 @@
 				float size2 = 1 + (age2 * (1 / Smoke_Time)) * 14;
 				float txs = ph-&gt;smoketrailtex.xstart - (ph-&gt;smoketrailtex.xend - ph-&gt;smoketrailtex.xstart) * (age2 / 8.0f);
 
-				va-&gt;AddVertexQTC(interPos - dir1 * size, txs, ph-&gt;smoketrailtex.ystart, col);
-				va-&gt;AddVertexQTC(interPos + dir1 * size, txs, ph-&gt;smoketrailtex.yend,   col);
+				va-&gt;AddVertexQTC(drawPos - dir1 * size, txs, ph-&gt;smoketrailtex.ystart, col);
+				va-&gt;AddVertexQTC(drawPos + dir1 * size, txs, ph-&gt;smoketrailtex.yend,   col);
 				va-&gt;AddVertexQTC(oldSmoke + dir2 * size2, ph-&gt;smoketrailtex.xend, ph-&gt;smoketrailtex.yend,   col2);
 				va-&gt;AddVertexQTC(oldSmoke - dir2 * size2, ph-&gt;smoketrailtex.xend, ph-&gt;smoketrailtex.ystart, col2);
 			} else {

Modified: branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/PieceProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -46,7 +46,7 @@
 	int colorTeam;
 	
 public:
-	CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalS3DO* piece, int flags, CUnit* owner, float radius);
+	CPieceProjectile(const float3&amp; pos, const float3&amp; speed, LocalS3DO* piece, int flags, CUnit* owner, float radius GML_PARG_H);
 	virtual ~CPieceProjectile(void);
 	void Update();
 	void Draw();

Modified: branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Projectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -23,7 +23,8 @@
 	CR_MEMBER(castShadow),
 	CR_MEMBER(owner),
 	CR_MEMBER(synced),
-
+//	CR_MEMBER(drawPos),
+//	CR_RESERVED(4),
 	CR_MEMBER_BEGINFLAG(CM_Config),
 		CR_MEMBER(speed),
 	CR_MEMBER_ENDFLAG(CM_Config),
@@ -43,10 +44,12 @@
 	castShadow(false),
 	s3domodel(0),
 	collisionFlags(0)
-{}
+{
+	GML_GET_TICKS(lastProjUpdate);
+}
 
 
-void CProjectile::Init(const float3&amp; explosionPos, CUnit* owner)
+void CProjectile::Init(const float3&amp; explosionPos, CUnit* owner GML_PARG_C)
 {
 	pos += explosionPos;
 	SetRadius(1.7f);
@@ -58,7 +61,7 @@
 }
 
 
-CProjectile::CProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, bool synced, bool weapon)
+CProjectile::CProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, bool synced, bool weapon GML_PARG_C)
 :	CExpGenSpawnable(pos),
 	owner(owner),
 	speed(speed),
@@ -75,6 +78,8 @@
 
 	if (owner)
 		AddDeathDependence(owner);
+
+	GML_GET_TICKS(lastProjUpdate);
 }
 
 CProjectile::~CProjectile()
@@ -116,11 +121,10 @@
 	col[1]=(unsigned char) (0.5f*255);
 	col[2]=0*255;
 	col[3]=10;
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;projectiletex.xstart,ph-&gt;projectiletex.ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;projectiletex.xend,ph-&gt;projectiletex.ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;projectiletex.xend,ph-&gt;projectiletex.yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;projectiletex.xstart,ph-&gt;projectiletex.yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;projectiletex.xstart,ph-&gt;projectiletex.ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;projectiletex.xend,ph-&gt;projectiletex.ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;projectiletex.xend,ph-&gt;projectiletex.yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;projectiletex.xstart,ph-&gt;projectiletex.yend,col);
 }
 
 void CProjectile::DrawArray()
@@ -146,3 +150,11 @@
 void CProjectile::DrawUnitPart(void)
 {
 }
+
+void CProjectile::UpdateDrawPos() {
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+		drawPos = pos + (speed * ((float)gu-&gt;lastFrameStart - (float)lastProjUpdate) * gu-&gt;weightedSpeedFactor);
+#else
+		drawPos = pos + (speed * gu-&gt;timeOffset);
+#endif
+}

Modified: branches/caiinterface/rts/Sim/Projectiles/Projectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Projectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Projectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,5 +1,6 @@
 #ifndef PROJECTILE_H
 #define PROJECTILE_H
+#include &quot;Rendering/GL/myGL.h&quot;
 // Projectile.h: interface for the CProjectile class.
 //
 //////////////////////////////////////////////////////////////////////
@@ -32,14 +33,14 @@
 
 	virtual void Draw();
 	CProjectile(); // default constructor is needed for creg
-	CProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, bool synced, bool weapon = false);
+	CProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, bool synced, bool weapon = false GML_PARG_H);
 	virtual void Collision();
 	virtual void Collision(CUnit* unit);
 	virtual void Collision(CFeature* feature);
 	virtual ~CProjectile();
 	virtual void Update();
 	void DependentDied(CObject* o);
-	virtual void Init(const float3&amp; pos, CUnit* owner);
+	virtual void Init(const float3&amp; pos, CUnit* owner GML_PARG_H);
 
 	bool synced;
 	bool weapon;
@@ -48,6 +49,12 @@
 	bool castShadow;
 	unsigned int collisionFlags;
 
+	void UpdateDrawPos();
+	float3 drawPos;
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	unsigned lastProjUpdate;
+#endif
+
 	CUnit* owner;
 	float3 speed;
 	virtual void DrawCallback(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/ProjectileHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -322,7 +322,9 @@
 		perlinFB = instantiate_fb(512, 512, FBO_NEED_COLOR);
 		if (perlinFB &amp;&amp; perlinFB-&gt;valid()) {
 			perlinFB-&gt;attachTexture(textureAtlas-&gt;gltex, GL_TEXTURE_2D, FBO_ATTACH_COLOR);
+			perlinFB-&gt;select();
 			drawPerlinTex=perlinFB-&gt;checkFBOStatus();
+			perlinFB-&gt;deselect();
 		}
 	}
 	else {
@@ -362,9 +364,9 @@
 		delete fpl;
 	}
 	ph=0;
-	delete perlinFB;
 	delete textureAtlas;
 	delete groundFXAtlas;
+	delete perlinFB;
 }
 
 void CProjectileHandler::Serialize(creg::ISerializer *s)
@@ -404,6 +406,8 @@
 
 	SCOPED_TIMER(&quot;Projectile handler&quot;);
 
+	GML_UPDATE_TICKS();
+
 	Projectile_List::iterator psi = ps.begin();
 	while (psi != ps.end()) {
 		CProjectile* p = *psi;
@@ -427,6 +431,7 @@
 			delete p;
 		} else {
 			p-&gt;Update();
+			GML_GET_TICKS(p-&gt;lastProjUpdate);
 			++psi;
 		}
 	}
@@ -578,11 +583,13 @@
 	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		CProjectile* pro = *psi;
 
+		pro-&gt;UpdateDrawPos();
+
 		if (camera-&gt;InView(pro-&gt;pos, pro-&gt;drawRadius) &amp;&amp; (gu-&gt;spectatingFullView || loshandler-&gt;InLos(pro, gu-&gt;myAllyTeam) ||
 			(pro-&gt;owner &amp;&amp; gs-&gt;Ally(pro-&gt;owner-&gt;allyteam, gu-&gt;myAllyTeam)))) {
 
 			CUnit* owner = pro-&gt;owner;
-			CUnit* trans = owner? (CUnit*) owner-&gt;transporter: 0;
+			CUnit* trans = owner? (CUnit*) owner-&gt;GetTransporter(): 0;
 			bool stunned = owner? owner-&gt;stunned: false;
 
 			if (owner &amp;&amp; trans &amp;&amp; stunned &amp;&amp; dynamic_cast&lt;CShieldPartProjectile*&gt;(pro)) {
@@ -712,7 +719,7 @@
 
 void CProjectileHandler::AddProjectile(CProjectile* p)
 {
-	GML_RECMUTEX_LOCK(proj); // AddProjectile
+//	GML_RECMUTEX_LOCK(proj); // AddProjectile
 
 	ps.push_back(p);
 
@@ -750,7 +757,8 @@
 
 	for (psi = ps.begin(); psi != ps.end(); ++psi) {
 		CProjectile* p = (*psi);
-		const float3 ppos = p-&gt;pos;
+		const float3 ppos0 = p-&gt;pos;
+		const float3 ppos1 = p-&gt;pos + p-&gt;speed;
 
 		if (p-&gt;checkCol &amp;&amp; !p-&gt;deleteMe) {
 			float speedf = p-&gt;speed.Length();
@@ -780,7 +788,7 @@
 					}
 				}
 
-				if (CCollisionHandler::DetectHit(unit, p-&gt;pos, p-&gt;pos + p-&gt;speed, &amp;q)) {
+				if (CCollisionHandler::DetectHit(unit, ppos0, ppos1, &amp;q)) {
 					// this projectile won't reach the raytraced surface impact pos
 					// until Update() is called (right after we return, same frame)
 					// which is a problem when dealing with fast low-AOE projectiles
@@ -788,11 +796,16 @@
 					// volume, so smuggle a bit (&quot;rolling back&quot; its pos in Update()
 					// and waiting for the next-frame CheckUnitCol() is problematic
 					// for noExplode projectiles)
-					const float3&amp; pimp = (q.b0)? q.p0: q.p1;
 
-					p-&gt;pos = (raytraced)? pimp: p-&gt;pos;
+					// const float3&amp; pimpp = (q.b0)? q.p0: q.p1;
+					const float3 pimpp =
+						(q.b0 &amp;&amp; q.b1)? (q.p0 + q.p1) * 0.5f:
+						(q.b0        )? (q.p0 + ppos1) * 0.5f:
+						                (ppos0 + q.p1) * 0.5f;
+
+					p-&gt;pos = (raytraced)? pimpp: ppos0;
 					p-&gt;Collision(unit);
-					p-&gt;pos = (raytraced)? ppos: p-&gt;pos;
+					p-&gt;pos = (raytraced)? ppos0: p-&gt;pos;
 					break;
 				}
 			}
@@ -809,10 +822,15 @@
 						continue;
 					}
 
-					if (CCollisionHandler::DetectHit(feature, p-&gt;pos, p-&gt;pos + p-&gt;speed, &amp;q)) {
-						p-&gt;pos = (raytraced)? q.p0: p-&gt;pos;
+					if (CCollisionHandler::DetectHit(feature, ppos0, ppos1, &amp;q)) {
+						const float3 pimpp =
+							(q.b0 &amp;&amp; q.b1)? (q.p0 + q.p1) * 0.5f:
+							(q.b0        )? (q.p0 + ppos1) * 0.5f:
+							                (ppos0 + q.p1) * 0.5f;
+
+						p-&gt;pos = (raytraced)? pimpp: ppos0;
 						p-&gt;Collision(feature);
-						p-&gt;pos = (raytraced)? ppos: p-&gt;pos;
+						p-&gt;pos = (raytraced)? ppos0: p-&gt;pos;
 						break;
 					}
 				}
@@ -825,7 +843,7 @@
 
 void CProjectileHandler::AddGroundFlash(CGroundFlash* flash)
 {
-	GML_RECMUTEX_LOCK(proj); // AddGroundFlash
+//	GML_RECMUTEX_LOCK(proj); // AddGroundFlash
 	groundFlashes.push_back(flash);
 }
 

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -81,9 +81,9 @@
 		deleteMe = true;
 }
 
-void CBitmapMuzzleFlame::Init(const float3 &amp;pos, CUnit *owner)
+void CBitmapMuzzleFlame::Init(const float3 &amp;pos, CUnit *owner GML_PARG_C)
 {
-	CProjectile::Init(pos, owner);
+	CProjectile::Init(pos, owner GML_PARG_P);
 	life = 0;
 	createTime = gs-&gt;frameNum;
 	invttl = 1.0f/(float)ttl;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/BitmapMuzzleFlame.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -13,7 +13,7 @@
 	~CBitmapMuzzleFlame(void);
 	void Draw(void);
 	void Update(void);
-	virtual void Init(const float3 &amp;pos, CUnit *owner);
+	virtual void Init(const float3 &amp;pos, CUnit *owner GML_PARG_H);
 
 	AtlasedTexture *sideTexture;
 	AtlasedTexture *frontTexture;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,8 +19,8 @@
 	));
 
 
-CBubbleProjectile::CBubbleProjectile(float3 pos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner, float alpha)
-: CProjectile(pos,speed,owner, false),
+CBubbleProjectile::CBubbleProjectile(float3 pos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner, float alpha GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P),
 	alpha(alpha),
 	startSize(startSize),
 	size(startSize*0.4f),
@@ -67,10 +67,9 @@
 	col[2]=(unsigned char)(255*alpha);
 	col[3]=(unsigned char)(255*alpha);
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	float interSize=size+sizeExpansion*gu-&gt;timeOffset;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*interSize-camera-&gt;up*interSize,ph-&gt;bubbletex.xstart    ,ph-&gt;bubbletex.ystart    ,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*interSize-camera-&gt;up*interSize,ph-&gt;bubbletex.xend,ph-&gt;bubbletex.ystart    ,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*interSize+camera-&gt;up*interSize,ph-&gt;bubbletex.xend,ph-&gt;bubbletex.yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*interSize+camera-&gt;up*interSize,ph-&gt;bubbletex.xstart    ,ph-&gt;bubbletex.yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*interSize-camera-&gt;up*interSize,ph-&gt;bubbletex.xstart    ,ph-&gt;bubbletex.ystart    ,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*interSize-camera-&gt;up*interSize,ph-&gt;bubbletex.xend,ph-&gt;bubbletex.ystart    ,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*interSize+camera-&gt;up*interSize,ph-&gt;bubbletex.xend,ph-&gt;bubbletex.yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*interSize+camera-&gt;up*interSize,ph-&gt;bubbletex.xstart    ,ph-&gt;bubbletex.yend,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/BubbleProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -8,7 +8,7 @@
 {
 	CR_DECLARE(CBubbleProjectile);
 public:
-	CBubbleProjectile(float3 pos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner,float alpha);
+	CBubbleProjectile(float3 pos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner,float alpha GML_PARG_H);
 	virtual ~CBubbleProjectile();
 	void Update();
 	void Draw();

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -32,8 +32,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CDirtProjectile::CDirtProjectile(const float3 pos,const float3 speed,const float ttl,const float size,const float expansion,float slowdown,CUnit* owner,const float3&amp; color)
-: CProjectile(pos,speed,owner, false),
+CDirtProjectile::CDirtProjectile(const float3 pos,const float3 speed,const float ttl,const float size,const float expansion,float slowdown,CUnit* owner,const float3&amp; color GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P),
 	alpha(255),
 	size(size),
 	sizeExpansion(expansion),
@@ -90,12 +90,11 @@
 	col[2]=(unsigned char) (color.z*alpha);
 	col[3]=(unsigned char) (alpha)/*-gu-&gt;timeOffset*alphaFalloff*/;
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	float interSize=size+gu-&gt;timeOffset*sizeExpansion;
 	float texx = texture-&gt;xstart + (texture-&gt;xend-texture-&gt;xstart)*((1-partAbove)*0.5f);//0.25f*(1-partAbove)
 
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*interSize-camera-&gt;up*interSize*partAbove,texx,texture-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*interSize-camera-&gt;up*interSize*partAbove,texx,texture-&gt;yend,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*interSize+camera-&gt;up*interSize,texture-&gt;xend,texture-&gt;yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*interSize+camera-&gt;up*interSize,texture-&gt;xend,texture-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*interSize-camera-&gt;up*interSize*partAbove,texx,texture-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*interSize-camera-&gt;up*interSize*partAbove,texx,texture-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*interSize+camera-&gt;up*interSize,texture-&gt;xend,texture-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*interSize+camera-&gt;up*interSize,texture-&gt;xend,texture-&gt;ystart,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/DirtProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,7 +16,7 @@
 	virtual void Draw();
 	virtual void Update();
 	CDirtProjectile();
-	CDirtProjectile(const float3 pos,const float3 speed,const float ttl,const float size,const float expansion,float slowdown,CUnit* owner,const float3&amp; color);
+	CDirtProjectile(const float3 pos,const float3 speed,const float ttl,const float size,const float expansion,float slowdown,CUnit* owner,const float3&amp; color GML_PARG_H);
 	virtual ~CDirtProjectile();
 
 	float alpha;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -28,8 +28,8 @@
 	synced=false;
 }
 
-CExploSpikeProjectile::CExploSpikeProjectile(const float3&amp; pos,const float3&amp; speed,float length,float width,float alpha,float alphaDecay,CUnit* owner)
-:	CProjectile(pos,speed,owner, false),
+CExploSpikeProjectile::CExploSpikeProjectile(const float3&amp; pos,const float3&amp; speed,float length,float width,float alpha,float alphaDecay,CUnit* owner GML_PARG_C)
+:	CProjectile(pos,speed,owner, false GML_PARG_P),
 	length(length),
 	width(width),
 	alpha(alpha),
@@ -77,19 +77,18 @@
 	col[2]=(unsigned char)(a*color.z);
 	col[3]=1;
 
-	float3 interpos=pos+speed*gu-&gt;timeOffset;
 	float3 l=dir*length+lengthGrowth*gu-&gt;timeOffset;
 	float3 w=dir2*width;
 
-	va-&gt;AddVertexTC(interpos+l+w, ph-&gt;laserendtex.xend, ph-&gt;laserendtex.yend, col);
-	va-&gt;AddVertexTC(interpos+l-w, ph-&gt;laserendtex.xend, ph-&gt;laserendtex.ystart, col);
-	va-&gt;AddVertexTC(interpos-l-w, ph-&gt;laserendtex.xstart, ph-&gt;laserendtex.ystart, col);
-	va-&gt;AddVertexTC(interpos-l+w, ph-&gt;laserendtex.xstart, ph-&gt;laserendtex.yend, col);
+	va-&gt;AddVertexTC(drawPos+l+w, ph-&gt;laserendtex.xend, ph-&gt;laserendtex.yend, col);
+	va-&gt;AddVertexTC(drawPos+l-w, ph-&gt;laserendtex.xend, ph-&gt;laserendtex.ystart, col);
+	va-&gt;AddVertexTC(drawPos-l-w, ph-&gt;laserendtex.xstart, ph-&gt;laserendtex.ystart, col);
+	va-&gt;AddVertexTC(drawPos-l+w, ph-&gt;laserendtex.xstart, ph-&gt;laserendtex.yend, col);
 }
 
-void CExploSpikeProjectile::Init(const float3&amp; pos, CUnit *owner)
+void CExploSpikeProjectile::Init(const float3&amp; pos, CUnit *owner GML_PARG_C)
 {
-	CProjectile::Init(pos, owner);
+	CProjectile::Init(pos, owner GML_PARG_P);
 
 	lengthGrowth=dir.Length()*(0.5f+gu-&gt;usRandFloat()*0.4f);
 	dir/=lengthGrowth;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/ExploSpikeProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -9,7 +9,7 @@
 	CR_DECLARE(CExploSpikeProjectile);
 public:
 	CExploSpikeProjectile();
-	CExploSpikeProjectile(const float3&amp; pos,const float3&amp; speed,float length,float width,float alpha,float alphaDecay,CUnit* owner);
+	CExploSpikeProjectile(const float3&amp; pos,const float3&amp; speed,float length,float width,float alpha,float alphaDecay,CUnit* owner GML_PARG_H);
 	~CExploSpikeProjectile(void);
 	void Update(void);
 	void Draw(void);
@@ -22,7 +22,7 @@
 	float3 dir;
 	float3 color;
 
-	virtual void Init(const float3&amp; pos, CUnit *owner);
+	virtual void Init(const float3&amp; pos, CUnit *owner GML_PARG_H);
 };
 
 #endif

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -24,8 +24,8 @@
 	CR_RESERVED(8)
 	));
 
-CGenericParticleProjectile::CGenericParticleProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner) :
-	CProjectile(pos, speed, owner, false)
+CGenericParticleProjectile::CGenericParticleProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner GML_PARG_C) :
+	CProjectile(pos, speed, owner, false GML_PARG_P)
 {
 	deleteMe=false;
 	checkCol=false;
@@ -57,8 +57,7 @@
 	if(directional)
 	{
 		float3 dif(pos-camera-&gt;pos);
-		float camDist=dif.Length();
-		dif/=camDist;
+		dif.ANormalize();
 		float3 dir1(dif.cross(speed));
 		dir1.ANormalize();
 		float3 dir2(dif.cross(dir1));
@@ -66,23 +65,21 @@
 		unsigned char color[4];
 
 		colorMap-&gt;GetColor(color, life);
-		float3 interPos=pos+speed*gu-&gt;timeOffset;
 
-		va-&gt;AddVertexTC(interPos-dir1*size-dir2*size,texture-&gt;xstart,texture-&gt;ystart,color);
-		va-&gt;AddVertexTC(interPos-dir1*size+dir2*size,texture-&gt;xend ,texture-&gt;ystart,color);
-		va-&gt;AddVertexTC(interPos+dir1*size+dir2*size,texture-&gt;xend ,texture-&gt;yend ,color);
-		va-&gt;AddVertexTC(interPos+dir1*size-dir2*size,texture-&gt;xstart,texture-&gt;yend ,color);
+		va-&gt;AddVertexTC(drawPos-dir1*size-dir2*size,texture-&gt;xstart,texture-&gt;ystart,color);
+		va-&gt;AddVertexTC(drawPos-dir1*size+dir2*size,texture-&gt;xend ,texture-&gt;ystart,color);
+		va-&gt;AddVertexTC(drawPos+dir1*size+dir2*size,texture-&gt;xend ,texture-&gt;yend ,color);
+		va-&gt;AddVertexTC(drawPos+dir1*size-dir2*size,texture-&gt;xstart,texture-&gt;yend ,color);
 	}
 	else
 	{
 		unsigned char color[4];
 
 		colorMap-&gt;GetColor(color, life);
-		float3 interPos=pos+speed*gu-&gt;timeOffset;
 
-		va-&gt;AddVertexTC(interPos-camera-&gt;right*size-camera-&gt;up*size,texture-&gt;xstart,texture-&gt;ystart,color);
-		va-&gt;AddVertexTC(interPos+camera-&gt;right*size-camera-&gt;up*size,texture-&gt;xend ,texture-&gt;ystart,color);
-		va-&gt;AddVertexTC(interPos+camera-&gt;right*size+camera-&gt;up*size,texture-&gt;xend ,texture-&gt;yend ,color);
-		va-&gt;AddVertexTC(interPos-camera-&gt;right*size+camera-&gt;up*size,texture-&gt;xstart,texture-&gt;yend ,color);
+		va-&gt;AddVertexTC(drawPos-camera-&gt;right*size-camera-&gt;up*size,texture-&gt;xstart,texture-&gt;ystart,color);
+		va-&gt;AddVertexTC(drawPos+camera-&gt;right*size-camera-&gt;up*size,texture-&gt;xend ,texture-&gt;ystart,color);
+		va-&gt;AddVertexTC(drawPos+camera-&gt;right*size+camera-&gt;up*size,texture-&gt;xend ,texture-&gt;yend ,color);
+		va-&gt;AddVertexTC(drawPos-camera-&gt;right*size+camera-&gt;up*size,texture-&gt;xstart,texture-&gt;yend ,color);
 	}
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GenericParticleProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -9,7 +9,7 @@
 {
 	CR_DECLARE(CGenericParticleProjectile);
 public:
-	CGenericParticleProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner);
+	CGenericParticleProjectile(const float3&amp; pos,const float3&amp; speed,CUnit* owner GML_PARG_H);
 	~CGenericParticleProjectile(void);
 
 	virtual void Update();

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -23,8 +23,8 @@
 	CR_RESERVED(8)
 	));
 
-CGeoSquareProjectile::CGeoSquareProjectile(const float3&amp; p1,const float3&amp; p2,const float3&amp; v1,const float3&amp; v2,float w1,float w2)
-: CProjectile((p1+p2)*0.5f,ZeroVector,0, false),
+CGeoSquareProjectile::CGeoSquareProjectile(const float3&amp; p1,const float3&amp; p2,const float3&amp; v1,const float3&amp; v2,float w1,float w2 GML_PARG_C)
+: CProjectile((p1+p2)*0.5f,ZeroVector,0, false GML_PARG_P),
 	p1(p1),
 	p2(p2),
 	v1(v1),

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoSquareProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -7,7 +7,7 @@
 {
 	CR_DECLARE(CGeoSquareProjectile);
 public:
-	CGeoSquareProjectile(const float3&amp; p1,const float3&amp; p2,const float3&amp; v1,const float3&amp; v2,float w1,float w2);
+	CGeoSquareProjectile(const float3&amp; p1,const float3&amp; p2,const float3&amp; v1,const float3&amp; v2,float w1,float w2 GML_PARG_H);
 	virtual ~CGeoSquareProjectile(void);
 
 	float3 p1,p2,v1,v2;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -12,8 +12,8 @@
 	CR_RESERVED(8)
 	));
 
-CGeoThermSmokeProjectile::CGeoThermSmokeProjectile(const float3&amp; pos,const float3&amp; speed,int ttl, CFeature* geo)
-: CSmokeProjectile(pos,speed,ttl,6,0.35f,0,0.8f), geo(geo)
+CGeoThermSmokeProjectile::CGeoThermSmokeProjectile(const float3&amp; pos,const float3&amp; speed,int ttl, CFeature* geo GML_PARG_C)
+: CSmokeProjectile(pos,speed,ttl,6,0.35f,0,0.8f GML_PARG_P), geo(geo)
 {}
 
 void CGeoThermSmokeProjectile::Update()
@@ -26,7 +26,7 @@
 		float sql = d.SqLength();
 		if (sql &gt; 0.0f &amp;&amp; sql &lt; o-&gt;radius*o-&gt;radius &amp;&amp; o-&gt;blocking)
 		{
-			d *= o-&gt;radius / sqrt(sql);
+			d *= o-&gt;radius * fastmath::isqrt2(sql);
 			pos = pos * 0.3f + (o-&gt;pos + d) * 0.7f;
 
 			if(d.y &lt; o-&gt;radius*0.4f)

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GeoThermSmokeProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -9,7 +9,7 @@
 {
 	CR_DECLARE(CGeoThermSmokeProjectile)
 public:
-	CGeoThermSmokeProjectile(const float3&amp; pos,const float3&amp; speed,int ttl,CFeature *geo);
+	CGeoThermSmokeProjectile(const float3&amp; pos,const float3&amp; speed,int ttl,CFeature *geo GML_PARG_H);
 	void Update();
 	CFeature *geo;
 

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -35,8 +35,8 @@
 	synced=false;
 }
 
-CGfxProjectile::CGfxProjectile(const float3&amp; pos,const float3&amp; speed,int lifeTime,const float3&amp; color)
-: CProjectile(pos,speed,0, false),
+CGfxProjectile::CGfxProjectile(const float3&amp; pos,const float3&amp; speed,int lifeTime,const float3&amp; color GML_PARG_C)
+: CProjectile(pos,speed,0, false GML_PARG_P),
 	lifeTime(lifeTime),
 	creationTime(gs-&gt;frameNum)
 {
@@ -65,9 +65,8 @@
 {
 	inArray=true;
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;gfxtex.xstart,ph-&gt;gfxtex.ystart,color);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;gfxtex.xend,ph-&gt;gfxtex.ystart,color);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;gfxtex.xend,ph-&gt;gfxtex.yend,color);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;gfxtex.xstart,ph-&gt;gfxtex.yend,color);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;gfxtex.xstart,ph-&gt;gfxtex.ystart,color);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;gfxtex.xend,ph-&gt;gfxtex.ystart,color);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;gfxtex.xend,ph-&gt;gfxtex.yend,color);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;gfxtex.xstart,ph-&gt;gfxtex.yend,color);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/GfxProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -14,7 +14,7 @@
 	void Update();
 	void Draw();
 	CGfxProjectile();
-	CGfxProjectile(const float3&amp; pos,const float3&amp; speed,int lifeTime,const float3&amp; color);
+	CGfxProjectile(const float3&amp; pos,const float3&amp; speed,int lifeTime,const float3&amp; color GML_PARG_H);
 	virtual ~CGfxProjectile();
 
 	int creationTime;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -40,8 +40,8 @@
 	texture = &amp;ph-&gt;heatcloudtex;
 }
 
-CHeatCloudProjectile::CHeatCloudProjectile(const float3 pos,const float3 speed,const  float temperature,const float size, CUnit* owner)
-: CProjectile(pos,speed,owner, false),
+CHeatCloudProjectile::CHeatCloudProjectile(const float3 pos,const float3 speed,const  float temperature,const float size, CUnit* owner GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P),
 	heat(temperature),
 	maxheat(temperature),
 	heatFalloff(1),
@@ -87,9 +87,8 @@
 	col[2]=(unsigned char)alpha;
 	col[3]=1;//(dheat/maxheat)*255.0f;
 	float drawsize=(size+sizeGrowth*gu-&gt;timeOffset)*(1-sizemod);
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawsize-camera-&gt;up*drawsize,texture-&gt;xstart,texture-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawsize-camera-&gt;up*drawsize,texture-&gt;xend,texture-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawsize+camera-&gt;up*drawsize,texture-&gt;xend,texture-&gt;yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawsize+camera-&gt;up*drawsize,texture-&gt;xstart,texture-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawsize-camera-&gt;up*drawsize,texture-&gt;xstart,texture-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawsize-camera-&gt;up*drawsize,texture-&gt;xend,texture-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawsize+camera-&gt;up*drawsize,texture-&gt;xend,texture-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawsize+camera-&gt;up*drawsize,texture-&gt;xstart,texture-&gt;yend,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/HeatCloudProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -15,7 +15,7 @@
 	virtual void Draw();
 	virtual void Update();
 	CHeatCloudProjectile();
-	CHeatCloudProjectile(const float3 pos,const float3 speed,const float temperature,const float size, CUnit* owner);  //projectile start at size 0 and ends at size size
+	CHeatCloudProjectile(const float3 pos,const float3 speed,const float temperature,const float size, CUnit* owner GML_PARG_H);  //projectile start at size 0 and ends at size size
 	virtual ~CHeatCloudProjectile();
 
 	float heat;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -26,8 +26,8 @@
 //	s.Serialize(randSmokeDir, numSmoke*sizeof(float3));
 }
 
-CMuzzleFlame::CMuzzleFlame(const float3&amp; pos,const float3&amp; speed,const float3&amp; dir,float size)
-: CProjectile(pos,speed,0, false),
+CMuzzleFlame::CMuzzleFlame(const float3&amp; pos,const float3&amp; speed,const float3&amp; dir,float size GML_PARG_C)
+: CProjectile(pos,speed,0, false GML_PARG_P),
 	size(size),
 	dir(dir),
 	age(0)
@@ -67,7 +67,7 @@
 	inArray=true;
 	unsigned char col[4];
 	float alpha=std::max(0.f,1-age/(4+size*30));
-	float modAge=sqrt(static_cast&lt;float&gt;(age+2));
+	float modAge=fastmath::sqrt(static_cast&lt;float&gt;(age+2));
 
 	va-&gt;EnlargeArrays(numSmoke*8,0,VA_SIZE_TC);
 

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/MuzzleFlame.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 
 	void creg_Serialize(creg::ISerializer&amp; s);
 public:
-	CMuzzleFlame(const float3&amp; pos,const float3&amp; speed,const float3&amp; dir,float size);
+	CMuzzleFlame(const float3&amp; pos,const float3&amp; speed,const float3&amp; dir,float size GML_PARG_H);
 	~CMuzzleFlame(void);
 
 	void Draw(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,8 +19,8 @@
 	CR_RESERVED(8)
 	));
 
-CRepulseGfx::CRepulseGfx(CUnit* owner,CProjectile* repulsed,float maxDist,float3 color)
-: CProjectile(repulsed?repulsed-&gt;pos:float3(0,0,0),repulsed?repulsed-&gt;speed:float3(0,0,0),owner, false),
+CRepulseGfx::CRepulseGfx(CUnit* owner,CProjectile* repulsed,float maxDist,float3 color GML_PARG_C)
+: CProjectile(repulsed?repulsed-&gt;pos:float3(0,0,0),repulsed?repulsed-&gt;speed:float3(0,0,0),owner, false GML_PARG_P),
 	repulsed(repulsed),
 	age(0),
 	sqMaxDist(maxDist*maxDist+100),
@@ -39,8 +39,8 @@
 		float yp=(y/4.0f-0.5f);
 		for(int x=0;x&lt;5;++x){
 			float xp=(x/4.0f-0.5f);
-			float d=sqrt(xp*xp+yp*yp);
-			difs[y*5+x]=(1-cos(d*2))*20;
+			float d=fastmath::sqrt2(xp*xp+yp*yp);
+			difs[y*5+x]=(1-fastmath::cos(d*2))*20;
 		}
 	}
 }
@@ -84,7 +84,6 @@
 	col[2]=(unsigned char)(color.z*alpha);
 	col[3]=(unsigned char)(alpha*0.2f);
 	float drawsize=10;
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 
 	AtlasedTexture&amp; et=ph-&gt;repulsetex;
 	float txo=et.xstart;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/RepulseGfx.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 {
 	CR_DECLARE(CRepulseGfx);
 public:
-	CRepulseGfx(CUnit* owner,CProjectile* repulsed,float maxDist,float3 color);
+	CRepulseGfx(CUnit* owner,CProjectile* repulsed,float maxDist,float3 color GML_PARG_H);
 	~CRepulseGfx(void);
 
 	void DependentDied(CObject* o);

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -22,8 +22,8 @@
 
 CShieldPartProjectile::CShieldPartProjectile(
 	const float3&amp; centerPos, int xpart, int ypart, float sphereSize,
-	float3 color, float alpha, AtlasedTexture* texture, CUnit* owner):
-	CProjectile(centerPos, ZeroVector, owner, false),
+	float3 color, float alpha, AtlasedTexture* texture, CUnit* owner GML_PARG_C):
+	CProjectile(centerPos, ZeroVector, owner, false GML_PARG_P),
 	centerPos(centerPos),
 	sphereSize(sphereSize),
 	baseAlpha(alpha),
@@ -57,7 +57,9 @@
 
 CShieldPartProjectile::~CShieldPartProjectile(void)
 {
-	ph-&gt;numPerlinProjectiles--;
+	if (ph) {
+		ph-&gt;numPerlinProjectiles--;
+	}
 }
 
 void CShieldPartProjectile::Update(void)

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/ShieldPartProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 {
 	CR_DECLARE(CShieldPartProjectile);
 public:
-	CShieldPartProjectile(const float3&amp; centerPos,int xpart,int ypart,float size,float3 color,float alpha, AtlasedTexture *texture,CUnit* owner);
+	CShieldPartProjectile(const float3&amp; centerPos,int xpart,int ypart,float size,float3 color,float alpha, AtlasedTexture *texture,CUnit* owner GML_PARG_H);
 	~CShieldPartProjectile(void);
 	void Draw(void);
 	void Update(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -80,8 +80,7 @@
 			if(particles[i].life&lt;1.0f)
 			{
 				float3 dif(particles[i].pos-camera-&gt;pos);
-				float camDist=dif.Length();
-				dif/=camDist;
+				dif.ANormalize();
 				float3 dir1(dif.cross(particles[i].speed));
 				dir1.ANormalize();
 				float3 dir2(dif.cross(dir1));
@@ -141,9 +140,9 @@
 
 }
 
-void CSimpleParticleSystem::Init(const float3&amp; explosionPos, CUnit *owner)
+void CSimpleParticleSystem::Init(const float3&amp; explosionPos, CUnit *owner GML_PARG_C)
 {
-	CProjectile::Init(explosionPos, owner);
+	CProjectile::Init(explosionPos, owner GML_PARG_P);
 
 	particles = new Particle[numParticles];
 

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SimpleParticleSystem.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,7 +16,7 @@
 
 	CSimpleParticleSystem(void);
 	virtual ~CSimpleParticleSystem(void);
-	virtual void Init(const float3&amp; explosionPos, CUnit *owner);
+	virtual void Init(const float3&amp; explosionPos, CUnit *owner GML_PARG_H);
 
 	float3 emitVector;
 	float3 emitMul;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -41,7 +41,7 @@
 	synced=false;
 }
 
-void CSmokeProjectile::Init(const float3&amp; pos, CUnit *owner)
+void CSmokeProjectile::Init(const float3&amp; pos, CUnit *owner GML_PARG_C)
 {
 	textureNum=(int)(gu-&gt;usRandInt() % ph-&gt;smoketex.size());
 
@@ -51,11 +51,11 @@
 	if(!owner)
 		alwaysVisible=true;
 
-	CProjectile::Init(pos, owner);
+	CProjectile::Init(pos, owner GML_PARG_P);
 }
 
-CSmokeProjectile::CSmokeProjectile(const float3&amp; pos,const float3&amp; speed,float ttl,float startSize,float sizeExpansion, CUnit* owner, float color)
-: CProjectile(pos, speed, owner, false),
+CSmokeProjectile::CSmokeProjectile(const float3&amp; pos,const float3&amp; speed,float ttl,float startSize,float sizeExpansion, CUnit* owner, float color GML_PARG_C)
+: CProjectile(pos, speed, owner, false GML_PARG_P),
 	color(color),
 	age(0),
 	startSize(startSize),
@@ -108,12 +108,11 @@
 	//float xmod=0.125f+(float(int(frame%6)))/16;
 	//float ymod=(int(frame/6))/16.0f;
 
-	const float3 interPos(pos+speed*gu-&gt;timeOffset);
 	const float interSize=size+sizeExpansion*gu-&gt;timeOffset;
 	const float3 pos1 ((camera-&gt;right - camera-&gt;up) * interSize);
 	const float3 pos2 ((camera-&gt;right + camera-&gt;up) * interSize);
-	va-&gt;AddVertexTC(interPos-pos2,ph-&gt;smoketex[textureNum].xstart,ph-&gt;smoketex[textureNum].ystart,col);
-	va-&gt;AddVertexTC(interPos+pos1,ph-&gt;smoketex[textureNum].xend,ph-&gt;smoketex[textureNum].ystart,col);
-	va-&gt;AddVertexTC(interPos+pos2,ph-&gt;smoketex[textureNum].xend,ph-&gt;smoketex[textureNum].yend,col);
-	va-&gt;AddVertexTC(interPos-pos1,ph-&gt;smoketex[textureNum].xstart,ph-&gt;smoketex[textureNum].yend,col);
+	va-&gt;AddVertexTC(drawPos-pos2,ph-&gt;smoketex[textureNum].xstart,ph-&gt;smoketex[textureNum].ystart,col);
+	va-&gt;AddVertexTC(drawPos+pos1,ph-&gt;smoketex[textureNum].xend,ph-&gt;smoketex[textureNum].ystart,col);
+	va-&gt;AddVertexTC(drawPos+pos2,ph-&gt;smoketex[textureNum].xend,ph-&gt;smoketex[textureNum].yend,col);
+	va-&gt;AddVertexTC(drawPos-pos1,ph-&gt;smoketex[textureNum].xstart,ph-&gt;smoketex[textureNum].yend,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -13,9 +13,9 @@
 
 	void Update();
 	void Draw();
-	void Init(const float3&amp; pos, CUnit *owner);
+	void Init(const float3&amp; pos, CUnit *owner GML_PARG_H);
 	CSmokeProjectile();
-	CSmokeProjectile(const float3&amp; pos,const float3&amp; speed,float ttl,float startSize,float sizeExpansion, CUnit* owner,float color=0.7f);
+	CSmokeProjectile(const float3&amp; pos,const float3&amp; speed,float ttl,float startSize,float sizeExpansion, CUnit* owner,float color=0.7f GML_PARG_H);
 	virtual ~CSmokeProjectile();
 
 	float color;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -44,7 +44,7 @@
 	synced=false;
 }
 
-void CSmokeProjectile2::Init(const float3&amp; pos, CUnit *owner)
+void CSmokeProjectile2::Init(const float3&amp; pos, CUnit *owner GML_PARG_C)
 {
 	textureNum=(int)(gu-&gt;usRandInt() % ph-&gt;smoketex.size());
 
@@ -56,11 +56,11 @@
 
 	wantedPos += pos;
 
-	CProjectile::Init(pos, owner);
+	CProjectile::Init(pos, owner GML_PARG_P);
 }
 
-CSmokeProjectile2::CSmokeProjectile2(float3 pos,float3 wantedPos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner, float color)
-: CProjectile(pos,speed,owner, false),
+CSmokeProjectile2::CSmokeProjectile2(float3 pos,float3 wantedPos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner, float color GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P),
 	wantedPos(wantedPos),
 	color(color),
 	age(0),

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeProjectile2.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -13,9 +13,9 @@
 
 	void Update();
 	void Draw();
-	void Init(const float3&amp; pos, CUnit *owner);
+	void Init(const float3&amp; pos, CUnit *owner GML_PARG_H);
 	CSmokeProjectile2();
-	CSmokeProjectile2(float3 pos,float3 wantedPos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner,float color=0.7f);
+	CSmokeProjectile2(float3 pos,float3 wantedPos,float3 speed,float ttl,float startSize,float sizeExpansion, CUnit* owner,float color=0.7f GML_PARG_H);
 	virtual ~CSmokeProjectile2();
 
 	float color;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -45,8 +45,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CSmokeTrailProjectile::CSmokeTrailProjectile(const float3&amp; pos1,const float3&amp; pos2,const float3&amp; dir1,const float3&amp; dir2, CUnit* owner,bool firstSegment,bool lastSegment,float size,float time,float color,bool drawTrail,CProjectile* drawCallback,AtlasedTexture* texture)
-: CProjectile((pos1+pos2)*0.5f,ZeroVector,owner, false),
+CSmokeTrailProjectile::CSmokeTrailProjectile(const float3&amp; pos1,const float3&amp; pos2,const float3&amp; dir1,const float3&amp; dir2, CUnit* owner,bool firstSegment,bool lastSegment,float size,float time,float color,bool drawTrail,CProjectile* drawCallback,AtlasedTexture* texture GML_PARG_C)
+: CProjectile((pos1+pos2)*0.5f,ZeroVector,owner, false GML_PARG_P),
 	pos1(pos1),
 	pos2(pos2),
 	creationTime(gs-&gt;frameNum),

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SmokeTrailProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -14,7 +14,7 @@
 public:
 	void Update();
 	void Draw();
-	CSmokeTrailProjectile(const float3&amp; pos1,const float3&amp; pos2,const float3&amp; dir1,const float3&amp; dir2, CUnit* owner,bool firstSegment,bool lastSegment,float size=1,float time=80,float color=0.7f,bool drawTrail=true,CProjectile* drawCallback=0,AtlasedTexture* texture=0);
+	CSmokeTrailProjectile(const float3&amp; pos1,const float3&amp; pos2,const float3&amp; dir1,const float3&amp; dir2, CUnit* owner,bool firstSegment,bool lastSegment,float size=1,float time=80,float color=0.7f,bool drawTrail=true,CProjectile* drawCallback=0,AtlasedTexture* texture=0 GML_PARG_H);
 	virtual ~CSmokeTrailProjectile();
 
 	float3 pos1;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -29,8 +29,8 @@
 	CR_RESERVED(16)
 	));
 
-CSpherePartProjectile::CSpherePartProjectile(const float3&amp; centerPos,int xpart,int ypart,float expansionSpeed,float alpha,int ttl,CUnit* owner,const float3 &amp;color)
-: CProjectile(centerPos,ZeroVector,owner, false),
+CSpherePartProjectile::CSpherePartProjectile(const float3&amp; centerPos,int xpart,int ypart,float expansionSpeed,float alpha,int ttl,CUnit* owner,const float3 &amp;color GML_PARG_C)
+: CProjectile(centerPos,ZeroVector,owner, false GML_PARG_P),
 	centerPos(centerPos),
 	expansionSpeed(expansionSpeed),
 	sphereSize(expansionSpeed),
@@ -129,9 +129,9 @@
 	CR_MEMBER_ENDFLAG(CM_Config)
 ));
 
-void CSpherePartSpawner::Init(const float3&amp; pos, CUnit *owner)
+void CSpherePartSpawner::Init(const float3&amp; pos, CUnit *owner GML_PARG_C)
 {
-	CProjectile::Init(pos, owner);
+	CProjectile::Init(pos, owner GML_PARG_P);
 	deleteMe = true;
 	CSpherePartProjectile::CreateSphere(pos, alpha, ttl, expansionSpeed, owner, color);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/SpherePartProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -8,7 +8,7 @@
 {
 	CR_DECLARE(CSpherePartProjectile);
 public:
-	CSpherePartProjectile(const float3&amp; centerPos,int xpart,int ypart,float expansionSpeed,float alpha,int ttl,CUnit* owner,const float3 &amp;color);
+	CSpherePartProjectile(const float3&amp; centerPos,int xpart,int ypart,float expansionSpeed,float alpha,int ttl,CUnit* owner,const float3 &amp;color GML_PARG_H);
 	~CSpherePartProjectile(void);
 
 	float3 centerPos;
@@ -44,7 +44,7 @@
 	CSpherePartSpawner();
 	~CSpherePartSpawner();
 
-	virtual void Init(const float3&amp; pos, CUnit *owner);
+	virtual void Init(const float3&amp; pos, CUnit *owner GML_PARG_H);
 };
 
 #endif /* SPHEREPARTPROJECTILE_H */

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -26,8 +26,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CTracerProjectile::CTracerProjectile(const float3 pos, const float3 speed,const float range,CUnit* owner)
-: CProjectile(pos,speed,owner, false)
+CTracerProjectile::CTracerProjectile(const float3 pos, const float3 speed,const float range,CUnit* owner GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P)
 {
 	SetRadius(1);
 	speedf=this-&gt;speed.Length();
@@ -44,13 +44,13 @@
 	checkCol=false;
 }
 
-void CTracerProjectile::Init(const float3&amp; pos, CUnit* owner)
+void CTracerProjectile::Init(const float3&amp; pos, CUnit* owner GML_PARG_C)
 {
 	speedf=this-&gt;speed.Length();
 	if (speedf==0.0f) speed=float3(1.0f,0.0f,0.0f);
 	dir=this-&gt;speed/speedf;
 
-	CProjectile::Init (pos, owner);
+	CProjectile::Init (pos, owner GML_PARG_P);
 }
 
 CTracerProjectile::~CTracerProjectile()
@@ -76,11 +76,10 @@
 	if(drawLength&gt;3)
 		drawLength=3;
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	glTexCoord2f(1.0f/16,1.0f/16);
 	glColor4f(1,1,0.1f,0.4f);
 	glBegin(GL_LINES);
-		glVertexf3( interPos);				
-		glVertexf3( interPos-dir*drawLength);				
+		glVertexf3( drawPos);				
+		glVertexf3( drawPos-dir*drawLength);				
 	glEnd();
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/TracerProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -13,9 +13,9 @@
 
 	void Draw();
 	void Update();
-	void Init(const float3&amp; pos, CUnit *owner);
+	void Init(const float3&amp; pos, CUnit *owner GML_PARG_H);
 	CTracerProjectile();
-	CTracerProjectile(const float3 pos,const float3 speed,const float range,CUnit* owner);
+	CTracerProjectile(const float3 pos,const float3 speed,const float range,CUnit* owner GML_PARG_H);
 	virtual ~CTracerProjectile();
 	float speedf;
 	float length;

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -28,8 +28,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CWakeProjectile::CWakeProjectile(const float3 pos,const float3 speed,float startSize,float sizeExpansion, CUnit* owner, float alpha,float alphaFalloff,float fadeupTime)
-: CProjectile(pos,speed,owner, false),
+CWakeProjectile::CWakeProjectile(const float3 pos,const float3 speed,float startSize,float sizeExpansion, CUnit* owner, float alpha,float alphaFalloff,float fadeupTime GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P),
 	alpha(0),
 	alphaAdd(alpha/fadeupTime),
 	alphaAddTime((int)fadeupTime),
@@ -81,14 +81,13 @@
 	col[2]=(unsigned char) (255*alpha);
 	col[3]=(unsigned char) (255*alpha)/*-alphaFalloff*gu-&gt;timeOffset*/;
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	float interSize=size+sizeExpansion*gu-&gt;timeOffset;
 	float interRot=rotation+rotSpeed*gu-&gt;timeOffset;
 
 	float3 dir1=float3(cos(interRot),0,sin(interRot))*interSize;
 	float3 dir2=dir1.cross(UpVector);
-	va-&gt;AddVertexTC(interPos+dir1+dir2, ph-&gt;waketex.xstart,ph-&gt;waketex.ystart,col);
-	va-&gt;AddVertexTC(interPos+dir1-dir2, ph-&gt;waketex.xstart,ph-&gt;waketex.yend,col);
-	va-&gt;AddVertexTC(interPos-dir1-dir2, ph-&gt;waketex.xend,ph-&gt;waketex.yend,col);
-	va-&gt;AddVertexTC(interPos-dir1+dir2, ph-&gt;waketex.xend,ph-&gt;waketex.ystart,col);
+	va-&gt;AddVertexTC(drawPos+dir1+dir2, ph-&gt;waketex.xstart,ph-&gt;waketex.ystart,col);
+	va-&gt;AddVertexTC(drawPos+dir1-dir2, ph-&gt;waketex.xstart,ph-&gt;waketex.yend,col);
+	va-&gt;AddVertexTC(drawPos-dir1-dir2, ph-&gt;waketex.xend,ph-&gt;waketex.yend,col);
+	va-&gt;AddVertexTC(drawPos-dir1+dir2, ph-&gt;waketex.xend,ph-&gt;waketex.ystart,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/WakeProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -8,7 +8,7 @@
 {
 	CR_DECLARE(CWakeProjectile);
 public:
-	CWakeProjectile(const float3 pos,const float3 speed,float startSize,float sizeExpansion, CUnit* owner,float alpha,float alphaFalloff,float fadeupTime);
+	CWakeProjectile(const float3 pos,const float3 speed,float startSize,float sizeExpansion, CUnit* owner,float alpha,float alphaFalloff,float fadeupTime GML_PARG_H);
 	virtual ~CWakeProjectile();
 	void Update();
 	void Draw();

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -25,8 +25,8 @@
 // Construction/Destruction
 //////////////////////////////////////////////////////////////////////
 
-CWreckProjectile::CWreckProjectile(float3 pos,float3 speed,float temperature,CUnit* owner)
-: CProjectile(pos,speed,owner, false)
+CWreckProjectile::CWreckProjectile(float3 pos,float3 speed,float temperature,CUnit* owner GML_PARG_C)
+: CProjectile(pos,speed,owner, false GML_PARG_P)
 {
 	checkCol=false;
 	drawRadius=2;
@@ -63,9 +63,8 @@
 	col[2]=(unsigned char) (0.05f*200);
 	col[3]=200;
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;wrecktex.xstart,ph-&gt;wrecktex.ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;wrecktex.xend,ph-&gt;wrecktex.ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;wrecktex.xend,ph-&gt;wrecktex.yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;wrecktex.xstart,ph-&gt;wrecktex.yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;wrecktex.xstart,ph-&gt;wrecktex.ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,ph-&gt;wrecktex.xend,ph-&gt;wrecktex.ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;wrecktex.xend,ph-&gt;wrecktex.yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,ph-&gt;wrecktex.xstart,ph-&gt;wrecktex.yend,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/Unsynced/WreckProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -11,7 +11,7 @@
 public:
 	CR_DECLARE(CWreckProjectile);
 	void Update();
-	CWreckProjectile(float3 pos,float3 speed,float temperature,CUnit* owner);
+	CWreckProjectile(float3 pos,float3 speed,float temperature,CUnit* owner GML_PARG_H);
 	virtual ~CWreckProjectile();
 
 	void Draw(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -29,9 +29,9 @@
 CBeamLaserProjectile::CBeamLaserProjectile(const float3&amp; startPos, const float3&amp; endPos,
 	float startAlpha, float endAlpha, const float3&amp; color, const float3&amp; color2,
 	CUnit* owner, float thickness, float corethickness, float flaresize,
-	const WeaponDef* weaponDef, int ttl, float decay):
+	const WeaponDef* weaponDef, int ttl, float decay GML_PARG_C):
 
-	CWeaponProjectile((startPos + endPos) * 0.5f, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, false,  ttl),
+	CWeaponProjectile((startPos + endPos) * 0.5f, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, false,  ttl GML_PARG_P),
 	startPos(startPos),
 	endPos(endPos),
 	thickness(thickness),

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/BeamLaserProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 	CBeamLaserProjectile(const float3&amp; startPos, const float3&amp; endPos,
 		float startAlpha, float endAlpha, const float3&amp; color, const float3&amp; color2,
 		CUnit* owner, float thickness, float corethickness, float flaresize,
-		const WeaponDef* weaponDef, int ttl, float decay);
+		const WeaponDef* weaponDef, int ttl, float decay GML_PARG_H);
 	~CBeamLaserProjectile(void);
 
 	float3 startPos;

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -20,8 +20,8 @@
 
 CEmgProjectile::CEmgProjectile(const float3&amp; pos, const float3&amp; speed,
 		CUnit* owner, const float3&amp; color, float intensity, int ttl,
-		const WeaponDef* weaponDef):
-	CWeaponProjectile(pos, speed, owner, 0, ZeroVector, weaponDef, 0, true,  ttl),
+		const WeaponDef* weaponDef GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, 0, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
 	color(color),
 	intensity(intensity)
 {
@@ -82,11 +82,10 @@
 	col[1]=(unsigned char) (color.y*intensity*255);
 	col[2]=(unsigned char) (color.z*intensity*255);
 	col[3]=5;//intensity*255;
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius-camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*drawRadius+camera-&gt;up*drawRadius,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
 }
 
 int CEmgProjectile::ShieldRepulse(CPlasmaRepulser* shield,float3 shieldPos, float shieldForce, float shieldMaxSpeed)

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/EmgProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 	CR_DECLARE(CEmgProjectile);
 public:
 	CEmgProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, const float3&amp; color,
-		float intensity, int ttl, const WeaponDef *weaponDef);
+		float intensity, int ttl, const WeaponDef *weaponDef GML_PARG_H);
 	virtual ~CEmgProjectile();
 	void Update(void);
 	void Draw(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -34,8 +34,8 @@
 
 CExplosiveProjectile::CExplosiveProjectile(const float3&amp; pos,
 		const float3&amp; speed, CUnit* owner, const WeaponDef *weaponDef, int ttl,
-		float areaOfEffect, float gravity):
-	CWeaponProjectile(pos, speed, owner, 0, ZeroVector, weaponDef, 0, true,  ttl),
+		float areaOfEffect, float gravity GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, 0, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
 	areaOfEffect(areaOfEffect),
 	curTime(0),
 	gravity(gravity)
@@ -139,7 +139,6 @@
 	const bool   noGap      = weaponDef-&gt;visuals.noGap;
 	const int    stages     = weaponDef-&gt;visuals.stages;
 	const float  invStages  = 1.0f / (float)stages;
-	const float3 interPos   = pos + (speed * gu-&gt;timeOffset);
 
 	float3 dir = speed;
 	dir.Normalize();
@@ -156,7 +155,7 @@
 		const float  size  = drawRadius * (1.0f - (a * sizeDecay));
 		const float3 up    = camera-&gt;up    * size;
 		const float3 right = camera-&gt;right * size;
-		const float3 interPos2 = interPos - ((noGap)?(dir * size * a):(dir * drawRadius * a));
+		const float3 interPos2 = drawPos - ((noGap)?(dir * size * a):(dir * drawRadius * a));
 
 		va-&gt;AddVertexQTC(interPos2 - right - up, tex-&gt;xstart, tex-&gt;ystart, col);
 		va-&gt;AddVertexQTC(interPos2 + right - up, tex-&gt;xend,   tex-&gt;ystart, col);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/ExplosiveProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -14,7 +14,7 @@
 public:
 	CExplosiveProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,
 		const WeaponDef *weaponDef, int ttl = 100000, float areaOfEffect = 8,
-		float gravity = 0);
+		float gravity = 0 GML_PARG_H);
 	virtual ~CExplosiveProjectile();
 	virtual void Update();
 	void Draw(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -28,8 +28,8 @@
 	));
 
 CFireBallProjectile::CFireBallProjectile(const float3&amp; pos, const float3&amp; speed,
-		CUnit* owner, CUnit* target, const float3 &amp;targetPos, const WeaponDef* weaponDef):
-	CWeaponProjectile(pos, speed, owner, target, targetPos, weaponDef, 0, true,  1)
+		CUnit* owner, CUnit* target, const float3 &amp;targetPos, const WeaponDef* weaponDef GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, target, targetPos, weaponDef, 0, true,  1 GML_PARG_P)
 {
 	if (weaponDef) {
 		SetRadius(weaponDef-&gt;collisionSize);
@@ -50,9 +50,7 @@
 	inArray=true;
 	unsigned char col[4] = {255,150, 100, 1};
 
-	float3 interPos = pos;
-	if(checkCol)
-		interPos+=speed*gu-&gt;timeOffset;
+	float3 interPos = checkCol ? drawPos : pos;
 	float size = radius*1.3f;
 
 	int numSparks=sparks.size();

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FireBallProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -11,7 +11,7 @@
 	CR_DECLARE_SUB(Spark);
 public:
 	CFireBallProjectile(const float3&amp; pos,const float3&amp; speed, CUnit* owner,
-			CUnit *target, const float3 &amp;targetPos, const WeaponDef* weaponDef);
+			CUnit *target, const float3 &amp;targetPos, const WeaponDef* weaponDef GML_PARG_H);
 	~CFireBallProjectile(void);
 
 	void Draw();

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -25,8 +25,8 @@
 
 
 CFlameProjectile::CFlameProjectile(const float3&amp; pos, const float3&amp; speed, const float3&amp; spread,
-		CUnit* owner, const WeaponDef* weaponDef, int ttl):
-	CWeaponProjectile(pos, speed, owner, 0, ZeroVector, weaponDef, 0, true,  ttl),
+		CUnit* owner, const WeaponDef* weaponDef, int ttl GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, 0, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
 	color(color),
 	color2(color2),
 	intensity(intensity),
@@ -95,12 +95,11 @@
 	inArray = true;
 	unsigned char col[4];
 	weaponDef-&gt;visuals.colorMap-&gt;GetColor(col, curTime);
-	float3 interPos = pos + speed * gu-&gt;timeOffset;
 
-	va-&gt;AddVertexTC(interPos - camera-&gt;right * radius - camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;ystart, col);
-	va-&gt;AddVertexTC(interPos + camera-&gt;right * radius - camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;ystart, col);
-	va-&gt;AddVertexTC(interPos + camera-&gt;right * radius + camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;yend,   col);
-	va-&gt;AddVertexTC(interPos - camera-&gt;right * radius + camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;yend,   col);
+	va-&gt;AddVertexTC(drawPos - camera-&gt;right * radius - camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;ystart, col);
+	va-&gt;AddVertexTC(drawPos + camera-&gt;right * radius - camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;ystart, col);
+	va-&gt;AddVertexTC(drawPos + camera-&gt;right * radius + camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;yend,   col);
+	va-&gt;AddVertexTC(drawPos - camera-&gt;right * radius + camera-&gt;up * radius, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;yend,   col);
 }
 
 int CFlameProjectile::ShieldRepulse(CPlasmaRepulser* shield,float3 shieldPos, float shieldForce, float shieldMaxSpeed)

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/FlameProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 	CR_DECLARE(CFlameProjectile);
 public:
 	CFlameProjectile(const float3&amp; pos, const float3&amp; speed, const float3&amp; spread,
-		CUnit* owner, const WeaponDef* weaponDef, int ttl = 50);
+		CUnit* owner, const WeaponDef* weaponDef, int ttl = 50 GML_PARG_H);
 	~CFlameProjectile(void);
 	float3 color;
 	float3 color2;

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -29,8 +29,8 @@
 	));
 
 CLargeBeamLaserProjectile::CLargeBeamLaserProjectile(const float3&amp; startPos, const float3&amp; endPos,
-		const float3&amp; color, const float3&amp; color2, CUnit* owner, const WeaponDef* weaponDef):
-	CWeaponProjectile(startPos + (endPos - startPos) * 0.5f, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, false,  1),
+		const float3&amp; color, const float3&amp; color2, CUnit* owner, const WeaponDef* weaponDef GML_PARG_C):
+	CWeaponProjectile(startPos + (endPos - startPos) * 0.5f, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, false,  1 GML_PARG_P),
 	startPos(startPos),
 	endPos(endPos),
 	decay(1.0f)

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LargeBeamLaserProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -9,7 +9,7 @@
 	CR_DECLARE(CLargeBeamLaserProjectile);
 public:
 	CLargeBeamLaserProjectile(const float3&amp; startPos, const float3&amp; endPos, const float3&amp; color, const float3&amp; color2,
-		CUnit* owner, const WeaponDef* weaponDef);
+		CUnit* owner, const WeaponDef* weaponDef GML_PARG_H);
 	~CLargeBeamLaserProjectile(void);
 
 	float3 startPos;

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -33,8 +33,8 @@
 
 CLaserProjectile::CLaserProjectile(const float3&amp; pos, const float3&amp; speed,
 		CUnit* owner, float length, const float3&amp; color, const float3&amp; color2,
-		float intensity, const WeaponDef *weaponDef, int ttl)
-: CWeaponProjectile(pos,speed,owner,0,ZeroVector,weaponDef,0, true,  ttl),
+		float intensity, const WeaponDef *weaponDef, int ttl GML_PARG_C)
+: CWeaponProjectile(pos,speed,owner,0,ZeroVector,weaponDef,0, true,  ttl GML_PARG_P),
 	color(color),
 	color2(color2),
 	length(length),
@@ -231,8 +231,7 @@
 
 	va-&gt;EnlargeArrays(32,0,VA_SIZE_TC);
 	if(camDist&lt;weaponDef-&gt;lodDistance){
-		float3 pos1=pos+speed*gu-&gt;timeOffset;
-		float3 pos2=pos1-dir*curLength;
+		float3 pos2=drawPos-dir*curLength;
 		float texStartOffset;
 		float texEndOffset;
 		if (checkCol) { //expanding or contracting?
@@ -244,21 +243,21 @@
 			texEndOffset= ((float)stayTime * speedf/length)*(weaponDef-&gt;visuals.texture1-&gt;xstart - weaponDef-&gt;visuals.texture1-&gt;xend);
 		}
 
-		va-&gt;AddVertexQTC(pos1-dir1*size,	midtexx,weaponDef-&gt;visuals.texture2-&gt;ystart,    col);
-		va-&gt;AddVertexQTC(pos1+dir1*size,	midtexx,weaponDef-&gt;visuals.texture2-&gt;yend,col);
-		va-&gt;AddVertexQTC(pos1+dir1*size-dir2*size, weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;yend,col);
-		va-&gt;AddVertexQTC(pos1-dir1*size-dir2*size, weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;ystart,col);
-		va-&gt;AddVertexQTC(pos1-dir1*coresize,midtexx,weaponDef-&gt;visuals.texture2-&gt;ystart,    col2);
-		va-&gt;AddVertexQTC(pos1+dir1*coresize,midtexx,weaponDef-&gt;visuals.texture2-&gt;yend,col2);
-		va-&gt;AddVertexQTC(pos1+dir1*coresize-dir2*coresize,weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;yend,col2);
-		va-&gt;AddVertexQTC(pos1-dir1*coresize-dir2*coresize,weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;ystart,col2);
+		va-&gt;AddVertexQTC(drawPos-dir1*size,	midtexx,weaponDef-&gt;visuals.texture2-&gt;ystart,    col);
+		va-&gt;AddVertexQTC(drawPos+dir1*size,	midtexx,weaponDef-&gt;visuals.texture2-&gt;yend,col);
+		va-&gt;AddVertexQTC(drawPos+dir1*size-dir2*size, weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;yend,col);
+		va-&gt;AddVertexQTC(drawPos-dir1*size-dir2*size, weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;ystart,col);
+		va-&gt;AddVertexQTC(drawPos-dir1*coresize,midtexx,weaponDef-&gt;visuals.texture2-&gt;ystart,    col2);
+		va-&gt;AddVertexQTC(drawPos+dir1*coresize,midtexx,weaponDef-&gt;visuals.texture2-&gt;yend,col2);
+		va-&gt;AddVertexQTC(drawPos+dir1*coresize-dir2*coresize,weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;yend,col2);
+		va-&gt;AddVertexQTC(drawPos-dir1*coresize-dir2*coresize,weaponDef-&gt;visuals.texture2-&gt;xstart,weaponDef-&gt;visuals.texture2-&gt;ystart,col2);
 
-		va-&gt;AddVertexQTC(pos1-dir1*size,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;ystart,		col);
-		va-&gt;AddVertexQTC(pos1+dir1*size,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;yend,			col);
+		va-&gt;AddVertexQTC(drawPos-dir1*size,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;ystart,		col);
+		va-&gt;AddVertexQTC(drawPos+dir1*size,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;yend,			col);
 		va-&gt;AddVertexQTC(pos2+dir1*size,weaponDef-&gt;visuals.texture1-&gt;xend + texEndOffset,weaponDef-&gt;visuals.texture1-&gt;yend,			col);
 		va-&gt;AddVertexQTC(pos2-dir1*size,weaponDef-&gt;visuals.texture1-&gt;xend + texEndOffset,weaponDef-&gt;visuals.texture1-&gt;ystart,			col);
-		va-&gt;AddVertexQTC(pos1-dir1*coresize,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;ystart,	col2);
-		va-&gt;AddVertexQTC(pos1+dir1*coresize,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;yend,	col2);
+		va-&gt;AddVertexQTC(drawPos-dir1*coresize,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;ystart,	col2);
+		va-&gt;AddVertexQTC(drawPos+dir1*coresize,weaponDef-&gt;visuals.texture1-&gt;xstart + texStartOffset,weaponDef-&gt;visuals.texture1-&gt;yend,	col2);
 		va-&gt;AddVertexQTC(pos2+dir1*coresize,weaponDef-&gt;visuals.texture1-&gt;xend + texEndOffset,weaponDef-&gt;visuals.texture1-&gt;yend,		col2);
 		va-&gt;AddVertexQTC(pos2-dir1*coresize,weaponDef-&gt;visuals.texture1-&gt;xend + texEndOffset,weaponDef-&gt;visuals.texture1-&gt;ystart,		col2);
 
@@ -271,7 +270,7 @@
 		va-&gt;AddVertexQTC(pos2+dir1*coresize+dir2*coresize,weaponDef-&gt;visuals.texture2-&gt;xend,weaponDef-&gt;visuals.texture2-&gt;yend,col2);
 		va-&gt;AddVertexQTC(pos2-dir1*coresize+dir2*coresize,weaponDef-&gt;visuals.texture2-&gt;xend,weaponDef-&gt;visuals.texture2-&gt;ystart,col2);
 	} else {
-		float3 pos1=pos+speed*gu-&gt;timeOffset+dir*(size*0.5f);
+		float3 pos1=drawPos+dir*(size*0.5f);
 		float3 pos2=pos1-dir*(curLength+size);
 		float texStartOffset;
 		float texEndOffset;

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LaserProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -11,7 +11,7 @@
 public:
 	CLaserProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,float length,
 		const float3&amp; color, const float3&amp; color2, float intensity, const WeaponDef *weaponDef,
-		int ttl = 1000);
+		int ttl = 1000 GML_PARG_H);
 	virtual ~CLaserProjectile();
 	void Draw(void);
 	void Update(void);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -26,8 +26,8 @@
 
 CLightingProjectile::CLightingProjectile(const float3&amp; pos, const float3&amp; end,
 		CUnit* owner, const float3&amp; color, const WeaponDef *weaponDef,
-		int ttl, CWeapon* weap):
-	CWeaponProjectile(pos, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, true,  ttl),
+		int ttl, CWeapon* weap GML_PARG_C):
+	CWeaponProjectile(pos, ZeroVector, owner, 0, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
 	color(color),
 	endPos(end),
 	weapon(weap)

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/LightingProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -11,7 +11,7 @@
 	CR_DECLARE(CLightingProjectile);
 public:
 	CLightingProjectile(const float3&amp; pos, const float3&amp; end, CUnit* owner, const float3&amp; color,
-		const WeaponDef *weaponDef, int ttl = 10, CWeapon* weap = 0);
+		const WeaponDef *weaponDef, int ttl = 10, CWeapon* weap = 0 GML_PARG_H);
 	~CLightingProjectile(void);
 
 	float3 color;

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -57,8 +57,8 @@
 
 CMissileProjectile::CMissileProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,
 		float areaOfEffect, float maxSpeed, int ttl, CUnit* target, const WeaponDef *weaponDef,
-		float3 targetPos):
-	CWeaponProjectile(pos, speed, owner, target, targetPos, weaponDef, 0, true,  ttl),
+		float3 targetPos GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, target, targetPos, weaponDef, 0, true,  ttl GML_PARG_P),
 	maxSpeed(maxSpeed),
 	target(target),
 	dir(speed),
@@ -263,7 +263,7 @@
 		float3 dif2 = dif - dir;
 		float tracking = weaponDef-&gt;turnrate;
 
-		if (dif2.Length() &lt; tracking) {
+		if (dif2.SqLength() &lt; Square(tracking)) {
 			dir = dif;
 		} else {
 			dif2 -= (dir * (dif2.dot(dir)));
@@ -330,7 +330,6 @@
 
 void CMissileProjectile::Draw(void)
 {
-	float3 interPos = pos + speed * gu-&gt;timeOffset;
 	inArray = true;
 	float age2 = (age &amp; 7) + gu-&gt;timeOffset;
 
@@ -341,7 +340,7 @@
 	if (weaponDef-&gt;visuals.smokeTrail) {
 		if (drawTrail) {
 			// draw the trail as a single quad
-			float3 dif(interPos - camera-&gt;pos);
+			float3 dif(drawPos - camera-&gt;pos);
 			dif.ANormalize();
 			float3 dir1(dif.cross(dir));
 			dir1.ANormalize();
@@ -375,8 +374,8 @@
 			float size2 = (1 + (age2 * (1 / Smoke_Time)) * 7);
 			float txs = weaponDef-&gt;visuals.texture2-&gt;xend - (weaponDef-&gt;visuals.texture2-&gt;xend - weaponDef-&gt;visuals.texture2-&gt;xstart) * (age2 / 8.0f);
 
-			va-&gt;AddVertexQTC(interPos - dir1 * size,  txs,                               weaponDef-&gt;visuals.texture2-&gt;ystart, col);
-			va-&gt;AddVertexQTC(interPos + dir1 * size,  txs,                               weaponDef-&gt;visuals.texture2-&gt;yend,   col);
+			va-&gt;AddVertexQTC(drawPos - dir1 * size,  txs,                               weaponDef-&gt;visuals.texture2-&gt;ystart, col);
+			va-&gt;AddVertexQTC(drawPos + dir1 * size,  txs,                               weaponDef-&gt;visuals.texture2-&gt;yend,   col);
 			va-&gt;AddVertexQTC(oldSmoke + dir2 * size2, weaponDef-&gt;visuals.texture2-&gt;xend, weaponDef-&gt;visuals.texture2-&gt;yend,   col2);
 			va-&gt;AddVertexQTC(oldSmoke - dir2 * size2, weaponDef-&gt;visuals.texture2-&gt;xend, weaponDef-&gt;visuals.texture2-&gt;ystart, col2);
 		} else {
@@ -409,10 +408,10 @@
 	col[2] = 180;
 	col[3] = 1;
 	float fsize = radius * 0.4f;
-	va-&gt;AddVertexQTC(interPos - camera-&gt;right * fsize-camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;ystart, col);
-	va-&gt;AddVertexQTC(interPos + camera-&gt;right * fsize-camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;ystart, col);
-	va-&gt;AddVertexQTC(interPos + camera-&gt;right * fsize+camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;yend,   col);
-	va-&gt;AddVertexQTC(interPos - camera-&gt;right * fsize+camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;yend,   col);
+	va-&gt;AddVertexQTC(drawPos - camera-&gt;right * fsize-camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;ystart, col);
+	va-&gt;AddVertexQTC(drawPos + camera-&gt;right * fsize-camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;ystart, col);
+	va-&gt;AddVertexQTC(drawPos + camera-&gt;right * fsize+camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xend,   weaponDef-&gt;visuals.texture1-&gt;yend,   col);
+	va-&gt;AddVertexQTC(drawPos - camera-&gt;right * fsize+camera-&gt;up * fsize, weaponDef-&gt;visuals.texture1-&gt;xstart, weaponDef-&gt;visuals.texture1-&gt;yend,   col);
 
 /*	col[0]=200;
 	col[1]=200;
@@ -434,7 +433,6 @@
 
 void CMissileProjectile::DrawUnitPart(void)
 {
-	float3 interPos = pos + speed * gu-&gt;timeOffset;
 	glPushMatrix();
 	float3 rightdir;
 
@@ -447,7 +445,7 @@
 	rightdir.Normalize();
 	float3 updir = rightdir.cross(dir);
 
-	CMatrix44f transMatrix(interPos + dir * radius * 0.9f,-rightdir,updir,dir);
+	CMatrix44f transMatrix(drawPos + dir * radius * 0.9f,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
 	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading
@@ -465,7 +463,7 @@
 		float3 dif2 = sdir - dir;
 		float tracking = std::max(shieldForce * 0.05f, weaponDef-&gt;turnrate * 2);
 
-		if (dif2.Length() &lt; tracking) {
+		if (dif2.SqLength() &lt; Square(tracking)) {
 			dir = sdir;
 		} else {
 			dif2 -= dir * (dif2.dot(dir));

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/MissileProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -14,7 +14,7 @@
 	void UpdateGroundBounce();
 public:
 	CMissileProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, float areaOfEffect,
-		float maxSpeed, int ttl, CUnit* target, const WeaponDef *weaponDef, float3 targetPos);
+		float maxSpeed, int ttl, CUnit* target, const WeaponDef *weaponDef, float3 targetPos GML_PARG_H);
 	~CMissileProjectile(void);
 	void DependentDied(CObject* o);
 	void Collision(CUnit* unit);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -56,8 +56,8 @@
 
 CStarburstProjectile::CStarburstProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,
 		float3 targetPos, float areaOfEffect, float maxSpeed, float tracking, int uptime, CUnit* target,
-		const WeaponDef* weaponDef, CWeaponProjectile* interceptTarget, float maxdistance, float3 aimError):
-	CWeaponProjectile(pos, speed, owner, target, targetPos, weaponDef, interceptTarget, true,  200),
+		const WeaponDef* weaponDef, CWeaponProjectile* interceptTarget, float maxdistance, float3 aimError GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, target, targetPos, weaponDef, interceptTarget, true,  200 GML_PARG_P),
 	maxSpeed(maxSpeed),
 	tracking(tracking),
 	dir(speed),
@@ -160,7 +160,7 @@
 	}
 	if (interceptTarget) {
 		targetPos = interceptTarget-&gt;pos;
-		if (targetPos.distance(pos) &lt; areaOfEffect * 2) {
+		if (targetPos.SqDistance(pos) &lt; Square(areaOfEffect * 2)) {
 			interceptTarget-&gt;Collision();
 			Collision();
 		}
@@ -260,7 +260,6 @@
 
 void CStarburstProjectile::Draw(void)
 {
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	inArray=true;
 	float age2=(age&amp;7)+gu-&gt;timeOffset;
 
@@ -272,7 +271,7 @@
 		va-&gt;EnlargeArrays(4+4*numParts,0,VA_SIZE_TC);
 		if(drawTrail){		//draw the trail as a single quad
 
-			float3 dif(interPos-camera-&gt;pos);
+			float3 dif(drawPos-camera-&gt;pos);
 			dif.Normalize();
 			float3 dir1(dif.cross(dir));
 			dir1.Normalize();
@@ -304,8 +303,8 @@
 			float size2=(1+age2*(1/Smoke_Time)*7);
 
 			float txs=weaponDef-&gt;visuals.texture2-&gt;xend - (weaponDef-&gt;visuals.texture2-&gt;xend-weaponDef-&gt;visuals.texture2-&gt;xstart)*(age2/8.0f);//(1-age2/8.0f);
-			va-&gt;AddVertexQTC(interPos-dir1*size, txs, weaponDef-&gt;visuals.texture2-&gt;ystart, col);
-			va-&gt;AddVertexQTC(interPos+dir1*size, txs, weaponDef-&gt;visuals.texture2-&gt;yend, col);
+			va-&gt;AddVertexQTC(drawPos-dir1*size, txs, weaponDef-&gt;visuals.texture2-&gt;ystart, col);
+			va-&gt;AddVertexQTC(drawPos+dir1*size, txs, weaponDef-&gt;visuals.texture2-&gt;yend, col);
 			va-&gt;AddVertexQTC(oldSmoke+dir2*size2, weaponDef-&gt;visuals.texture2-&gt;xend, weaponDef-&gt;visuals.texture2-&gt;yend, col2);
 			va-&gt;AddVertexQTC(oldSmoke-dir2*size2, weaponDef-&gt;visuals.texture2-&gt;xend, weaponDef-&gt;visuals.texture2-&gt;ystart, col2);
 		} else {	//draw the trail as particles
@@ -336,8 +335,6 @@
 
 void CStarburstProjectile::DrawCallback(void)
 {
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
-
 	(*numCallback)++;
 	if(*numCallback&lt;2)
 		return;
@@ -391,15 +388,14 @@
 	col[2]=180;
 	col[3]=1;
 	float fsize = 25.0f;
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*fsize-camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*fsize-camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
-	va-&gt;AddVertexTC(interPos+camera-&gt;right*fsize+camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
-	va-&gt;AddVertexTC(interPos-camera-&gt;right*fsize+camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*fsize-camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*fsize-camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;ystart,col);
+	va-&gt;AddVertexTC(drawPos+camera-&gt;right*fsize+camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xend,weaponDef-&gt;visuals.texture1-&gt;yend,col);
+	va-&gt;AddVertexTC(drawPos-camera-&gt;right*fsize+camera-&gt;up*fsize,weaponDef-&gt;visuals.texture1-&gt;xstart,weaponDef-&gt;visuals.texture1-&gt;yend,col);
 }
 
 void CStarburstProjectile::DrawUnitPart(void)
 {
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	glPushMatrix();
 	float3 rightdir;
 	if(dir.y!=1)
@@ -409,7 +405,7 @@
 	rightdir.Normalize();
 	float3 updir=rightdir.cross(dir);
 
-	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
+	CMatrix44f transMatrix(drawPos,-rightdir,updir,dir);
 	glMultMatrixf(&amp;transMatrix[0]);
 
 	glCallList(s3domodel-&gt;rootobject3do?s3domodel-&gt;rootobject3do-&gt;displist:s3domodel-&gt;rootobjects3o-&gt;displist); // dont cache displists because of delayed loading

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/StarburstProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,7 +16,7 @@
 	CStarburstProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,
 			float3 targetPos,float areaOfEffect, float maxSpeed,float tracking,
 			int uptime, CUnit* target, const WeaponDef* weaponDef,
-			CWeaponProjectile* interceptTarget, float maxdistance, float3 aimError);
+			CWeaponProjectile* interceptTarget, float maxdistance, float3 aimError GML_PARG_H);
 	~CStarburstProjectile(void);
 	void Collision(CUnit* unit);
 	void Collision();

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -36,8 +36,8 @@
 
 CTorpedoProjectile::CTorpedoProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,
 		float areaOfEffect, float maxSpeed, float tracking, int ttl, CUnit* target,
-		const WeaponDef *weaponDef):
-	CWeaponProjectile(pos, speed, owner, target, ZeroVector, weaponDef, 0, true,  ttl),
+		const WeaponDef *weaponDef GML_PARG_C):
+	CWeaponProjectile(pos, speed, owner, target, ZeroVector, weaponDef, 0, true,  ttl GML_PARG_P),
 	maxSpeed(maxSpeed),
 	tracking(tracking),
 	target(target),
@@ -173,7 +173,6 @@
 	if(s3domodel)	//dont draw if a 3d model has been defined for us
 		return;
 
-	float3 interPos=pos+speed*gu-&gt;timeOffset;
 	inArray=true;
 
 	unsigned char col[4];
@@ -192,44 +191,44 @@
 
 	va-&gt;EnlargeArrays(32,0,VA_SIZE_TC);
 
-	va-&gt;AddVertexQTC(interPos+r*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+u*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+u*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+r*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+u*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+r*w+dir*h, texx,texy,col);
 
-	va-&gt;AddVertexQTC(interPos+u*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-r*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-r*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+u*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-r*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+u*w+dir*h, texx,texy,col);
 
-	va-&gt;AddVertexQTC(interPos-r*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-u*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-u*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-r*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-u*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-r*w+dir*h, texx,texy,col);
 
-	va-&gt;AddVertexQTC(interPos-u*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+r*w, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+r*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-u*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+r*w, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-u*w+dir*h, texx,texy,col);
 
 
-	va-&gt;AddVertexQTC(interPos+r*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+u*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
 
-	va-&gt;AddVertexQTC(interPos+u*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-r*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
 
-	va-&gt;AddVertexQTC(interPos-r*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos-u*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
 
-	va-&gt;AddVertexQTC(interPos-u*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+r*w+dir*h, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
-	va-&gt;AddVertexQTC(interPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos-u*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+r*w+dir*h, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
+	va-&gt;AddVertexQTC(drawPos+dir*h*1.2f, texx,texy,col);
 }

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/TorpedoProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,7 +10,7 @@
 	CR_DECLARE(CTorpedoProjectile);
 public:
 	CTorpedoProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner, float areaOfEffect,
-		float maxSpeed, float tracking, int ttl, CUnit* target, const WeaponDef* weaponDef);
+		float maxSpeed, float tracking, int ttl, CUnit* target, const WeaponDef* weaponDef GML_PARG_H);
 	~CTorpedoProjectile(void);
 	void DependentDied(CObject* o);
 	void Collision(CUnit* unit);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -64,8 +64,8 @@
 CWeaponProjectile::CWeaponProjectile(const float3&amp; pos, const float3&amp; speed,
 		CUnit* owner, CUnit* target, const float3 &amp;targetPos,
 		const WeaponDef* weaponDef, CWeaponProjectile* interceptTarget,
-		bool synced, int ttl):
-	CProjectile(pos, speed, owner, synced, true),
+		bool synced, int ttl GML_PARG_C):
+	CProjectile(pos, speed, owner, synced, true GML_PARG_P),
 	weaponDef(weaponDef),
 	weaponDefName(weaponDef? weaponDef-&gt;name: std::string(&quot;&quot;)),
 	target(target),
@@ -291,7 +291,6 @@
 
 void CWeaponProjectile::DrawUnitPart()
 {
-	float3 interPos = pos + speed * gu-&gt;timeOffset;
 	float3 dir(speed);
 	dir.Normalize();
 	glPushMatrix();
@@ -305,7 +304,7 @@
 	rightdir.Normalize();
 	float3 updir(rightdir.cross(dir));
 
-	CMatrix44f transMatrix(interPos,-rightdir,updir,dir);
+	CMatrix44f transMatrix(drawPos,-rightdir,updir,dir);
 
 	glMultMatrixf(&amp;transMatrix[0]);
 //	glCallList(modelDispList);

Modified: branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h
===================================================================
--- branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Projectiles/WeaponProjectiles/WeaponProjectile.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,7 +16,7 @@
 	CWeaponProjectile();
 	CWeaponProjectile(const float3&amp; pos, const float3&amp; speed, CUnit* owner,
 			CUnit* target, const float3 &amp;targetPos, const WeaponDef *weaponDef,
-			CWeaponProjectile* interceptTarget, bool synced, int ttl = 1);
+			CWeaponProjectile* interceptTarget, bool synced, int ttl = 1 GML_PARG_H);
 	virtual ~CWeaponProjectile();
 
 	virtual void Collision();

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/AirCAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -512,21 +512,21 @@
 {
 	assert(owner-&gt;unitDef-&gt;canAttack);
 	AAirMoveType* myPlane = (AAirMoveType*) owner-&gt;moveType;
-	if(targetDied){
+	if (targetDied){
 		targetDied = false;
 		inCommand = false;
 	}
 	const float3 pos(c.params[0], c.params[1], c.params[2]);
 	const float radius = c.params[3];
-	if(inCommand){
-		if(myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDED)
+	if (inCommand) {
+		if (myPlane-&gt;aircraftState == AAirMoveType::AIRCRAFT_LANDED)
 			inCommand = false;
-		if(orderTarget &amp;&amp; orderTarget-&gt;pos.distance2D(pos) &gt; radius){
+		if (orderTarget &amp;&amp; orderTarget-&gt;pos.SqDistance2D(pos) &gt; Square(radius)) {
 			inCommand = false;
 			DeleteDeathDependence(orderTarget);
 			orderTarget = 0;
 		}
-		if (owner-&gt;commandShotCount &gt; 0) {
+		if (owner-&gt;commandShotCount &lt; 0) {
 			if ((c.params.size() == 4) &amp;&amp; (commandQue.size() &gt; 1)) {
 				owner-&gt;AttackUnit(0, true);
 				FinishCommand();
@@ -541,11 +541,13 @@
 		}
 	} else {
 		owner-&gt;commandShotCount = -1;
-		if(myPlane-&gt;aircraftState != AAirMoveType::AIRCRAFT_LANDED){
+
+		if (myPlane-&gt;aircraftState != AAirMoveType::AIRCRAFT_LANDED) {
 			inCommand = true;
 			std::vector&lt;int&gt; eu;
 			helper-&gt;GetEnemyUnits(pos, radius, owner-&gt;allyteam, eu);
-			if(eu.empty()){
+
+			if (eu.empty()) {
 				float3 attackPos = pos + gs-&gt;randVector() * radius;
 				attackPos.y = ground-&gt;GetHeight(attackPos.x, attackPos.z);
 				owner-&gt;AttackGround(attackPos, false);

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -186,9 +186,12 @@
 
 CBuilderCAI::~CBuilderCAI()
 {
-	RemoveUnitFromReclaimers(owner);
-	RemoveUnitFromFeatureReclaimers(owner);
-	uh-&gt;RemoveBuilderCAI(this);
+	// if uh == NULL then all pointers to units should be considered dangling pointers
+	if (uh) {
+		RemoveUnitFromReclaimers(owner);
+		RemoveUnitFromFeatureReclaimers(owner);
+		uh-&gt;RemoveBuilderCAI(this);
+	}
 }
 
 void CBuilderCAI::PostLoad()
@@ -371,7 +374,7 @@
 		const float radius = GetUnitDefRadius(ud, c.id);
 		if (inCommand) {
 			if (building) {
-				if (f3Dist(build.pos, fac-&gt;pos) &gt; fac-&gt;buildDistance + radius - 8.0f) {
+				if (f3SqDist(build.pos, fac-&gt;pos) &gt; Square(fac-&gt;buildDistance + radius - 8.0f)) {
 					owner-&gt;moveType-&gt;StartMoving(build.pos, fac-&gt;buildDistance * 0.5f + radius);
 				} else {
 					StopMove();
@@ -404,10 +407,10 @@
 					StopMove();
 				} else {
 					build.pos = helper-&gt;Pos2BuildPos(build);
-					const float dist = f3Dist(build.pos, fac-&gt;pos);
+					const float sqdist = f3SqDist(build.pos, fac-&gt;pos);
 
-					if ((dist &lt; (fac-&gt;buildDistance * 0.6f + radius)) ||
-						(!owner-&gt;unitDef-&gt;canmove &amp;&amp; (dist &lt;= (fac-&gt;buildDistance + radius - 8.0f)))) {
+					if ((sqdist &lt; Square(fac-&gt;buildDistance * 0.6f + radius)) ||
+						(!owner-&gt;unitDef-&gt;canmove &amp;&amp; (sqdist &lt;= Square(fac-&gt;buildDistance + radius - 8.0f)))) {
 						StopMove();
 
 						if (luaRules &amp;&amp; !luaRules-&gt;AllowUnitCreation(build.def, owner, &amp;build.pos)) {
@@ -528,12 +531,12 @@
 		    ((unit != owner) || owner-&gt;unitDef-&gt;canSelfRepair) &amp;&amp;
 		    (!unit-&gt;soloBuilder || (unit-&gt;soloBuilder == owner)) &amp;&amp;
 		    UpdateTargetLostTimer((int)c.params[0])) {
-			if (f3Dist(unit-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance+unit-&gt;radius-8) {
+			if (f3SqDist(unit-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance+unit-&gt;radius-8)) {
 				StopMove();
 				fac-&gt;SetRepairTarget(unit);
 				owner-&gt;moveType-&gt;KeepPointingTo(unit-&gt;pos, fac-&gt;buildDistance*0.9f+unit-&gt;radius, false);
 			} else {
-				if (f3Dist(goalPos, unit-&gt;pos) &gt; 1) {
+				if (f3SqDist(goalPos, unit-&gt;pos) &gt; 1) {
 					SetGoal(unit-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance*0.9f+unit-&gt;radius);
 				}
 			}
@@ -567,12 +570,12 @@
 		CUnit* unit = uh-&gt;units[(int)c.params[0]];
 
 		if (unit &amp;&amp; unit-&gt;unitDef-&gt;capturable &amp;&amp; unit-&gt;team != owner-&gt;team &amp;&amp; UpdateTargetLostTimer((int) c.params[0])) {
-			if (f3Dist(unit-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance + unit-&gt;radius - 8) {
+			if (f3SqDist(unit-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance + unit-&gt;radius - 8)) {
 				StopMove();
 				fac-&gt;SetCaptureTarget(unit);
 				owner-&gt;moveType-&gt;KeepPointingTo(unit-&gt;pos, fac-&gt;buildDistance * 0.9f + unit-&gt;radius, false);
 			} else {
-				if (f3Dist(goalPos, unit-&gt;pos) &gt; 1) {
+				if (f3SqDist(goalPos, unit-&gt;pos) &gt; 1) {
 					SetGoal(unit-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance * 0.9f + unit-&gt;radius);
 				}
 			}
@@ -605,8 +608,8 @@
 	if (guarded &amp;&amp; guarded!=owner &amp;&amp; UpdateTargetLostTimer((int)c.params[0])) {
 		if (CBuilder* b=dynamic_cast&lt;CBuilder*&gt;(guarded)) {
 			if (b-&gt;terraforming) {
-				if (f3Dist(fac-&gt;pos, b-&gt;terraformCenter) &lt;
-						(fac-&gt;buildDistance * 0.8f) + (b-&gt;terraformRadius * 0.7f)) {
+				if (f3SqDist(fac-&gt;pos, b-&gt;terraformCenter) &lt;
+						Square((fac-&gt;buildDistance * 0.8f) + (b-&gt;terraformRadius * 0.7f))) {
 					StopMove();
 					owner-&gt;moveType-&gt;KeepPointingTo(b-&gt;terraformCenter, fac-&gt;buildDistance*0.9f, false);
 					fac-&gt;HelpTerraform(b);
@@ -778,12 +781,12 @@
 			CFeatureSet::const_iterator it = featureHandler-&gt;GetActiveFeatures().find(id - MAX_UNITS);
 			if (it != featureHandler-&gt;GetActiveFeatures().end() &amp;&amp; (*it)-&gt;createdFromUnit != &quot;&quot;) {
 				CFeature* feature = *it;
-				if (f3Dist(feature-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance*0.9f+feature-&gt;radius) {
+				if (f3SqDist(feature-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance*0.9f+feature-&gt;radius)) {
 					StopMove();
 					owner-&gt;moveType-&gt;KeepPointingTo(feature-&gt;pos, fac-&gt;buildDistance*0.9f+feature-&gt;radius, false);
 					fac-&gt;SetResurrectTarget(feature);
 				} else {
-					if (f3Dist(goalPos, feature-&gt;pos) &gt; 1) {
+					if (f3SqDist(goalPos, feature-&gt;pos) &gt; 1) {
 						SetGoal(feature-&gt;pos,owner-&gt;pos, fac-&gt;buildDistance*0.8f+feature-&gt;radius);
 					} else {
 						if(owner-&gt;moveType-&gt;progressState==AMoveType::Failed){
@@ -937,7 +940,7 @@
 		pos.y = ground-&gt;GetHeight2(pos.x,pos.y);
 		float radius(c.params[3]);
 		if (radius&gt;200) radius = 200;
-		if (f3Dist(fac-&gt;pos, pos) &lt; fac-&gt;buildDistance-1) {
+		if (f3SqDist(fac-&gt;pos, pos) &lt; Square(fac-&gt;buildDistance-1)) {
 			StopMove();
 			fac-&gt;StartRestore(pos,radius);
 			owner-&gt;moveType-&gt;KeepPointingTo(pos, fac-&gt;buildDistance*0.9f, false);
@@ -1080,12 +1083,12 @@
 
 bool CBuilderCAI::ReclaimObject(CSolidObject* object){
 	CBuilder* fac=(CBuilder*)owner;
-	if (f3Dist(object-&gt;pos, fac-&gt;pos) &lt; fac-&gt;buildDistance-1+object-&gt;radius) {
+	if (f3SqDist(object-&gt;pos, fac-&gt;pos) &lt; Square(fac-&gt;buildDistance-1+object-&gt;radius)) {
 		StopMove();
 		owner-&gt;moveType-&gt;KeepPointingTo(object-&gt;pos, fac-&gt;buildDistance*0.9f+object-&gt;radius, false);
 		fac-&gt;SetReclaimTarget(object);
 	} else {
-		if (f3Dist(goalPos, object-&gt;pos) &gt; 1) {
+		if (f3SqDist(goalPos, object-&gt;pos) &gt; 1) {
 			SetGoal(object-&gt;pos, owner-&gt;pos);
 		} else {
 			if (owner-&gt;moveType-&gt;progressState == AMoveType::Failed) {

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/BuilderCAI.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -66,6 +66,9 @@
 	inline float f3Dist(const float3&amp; a, const float3&amp; b) const {
 		return range3D ? a.distance(b) : a.distance2D(b);
 	}
+	inline float f3SqDist(const float3&amp; a, const float3&amp; b) const {
+		return range3D ? a.SqDistance(b) : a.SqDistance2D(b);
+	}
 	inline float f3Len(const float3&amp; a) const {
 		return range3D ? a.Length() : a.Length2D();
 	}

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/CommandAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -308,7 +308,7 @@
 
 CCommandAI::~CCommandAI()
 {
-	if(orderTarget){
+	if (orderTarget) {
 		DeleteDeathDependence(orderTarget);
 		orderTarget = 0;
 	}

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/CommandQueue.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -45,18 +45,27 @@
 
 		inline iterator insert(iterator pos, const Command&amp; cmd);
 
-		inline void pop_back()  { GML_STDMUTEX_LOCK(cai); queue.pop_back(); }
-		inline void pop_front() { GML_STDMUTEX_LOCK(cai); queue.pop_front(); }
+		inline void pop_back()  { 
+			GML_STDMUTEX_LOCK(cai); // pop_back
+			queue.pop_back(); 
+		}
+		inline void pop_front() { 
+			GML_STDMUTEX_LOCK(cai); // pop_front
+			queue.pop_front(); 
+		}
 
 		inline iterator erase(iterator pos) {
-			GML_STDMUTEX_LOCK(cai); // Erase
+			GML_STDMUTEX_LOCK(cai); // erase
 			return queue.erase(pos);
 		}
 		inline iterator erase(iterator first, iterator last) {
-			GML_STDMUTEX_LOCK(cai); // Erase
+			GML_STDMUTEX_LOCK(cai); // erase
 			return queue.erase(first, last);
 		}
-		inline void clear() { GML_STDMUTEX_LOCK(cai); queue.clear(); }
+		inline void clear() { 
+			GML_STDMUTEX_LOCK(cai); // clear 
+			queue.clear(); 
+		}
 
 		inline iterator       end()         { return queue.end(); }
 		inline const_iterator end()   const { return queue.end(); }

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/LineDrawer.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/LineDrawer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/LineDrawer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,3 +1,5 @@
+// TODO: move this out of Sim, this is rendering code!
+
 #include &quot;StdAfx.h&quot;
 #include &quot;LineDrawer.h&quot;
 #include &quot;Game/UI/CommandColors.h&quot;

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/MobileCAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -633,7 +633,7 @@
 void CMobileCAI::ExecuteDGun(Command &amp;c)
 {
 	if (uh-&gt;limitDgun &amp;&amp; owner-&gt;unitDef-&gt;isCommander
-			&amp;&amp; owner-&gt;pos.distance(gs-&gt;Team(owner-&gt;team)-&gt;startPos) &gt; uh-&gt;dgunRadius) {
+			&amp;&amp; owner-&gt;pos.SqDistance(gs-&gt;Team(owner-&gt;team)-&gt;startPos) &gt; Square(uh-&gt;dgunRadius)) {
 		StopMove();
 		return FinishCommand();
 	}
@@ -734,8 +734,8 @@
 			// if we have at least one weapon then check if we
 			// can hit target with our first (meanest) one
 			b2 = w-&gt;TryTargetRotate(orderTarget, c.id == CMD_DGUN);
-			b3 = (w-&gt;range - (w-&gt;relWeaponPos).Length())
-					&gt; (orderTarget-&gt;pos.distance(owner-&gt;pos));
+			b3 = Square(w-&gt;range - (w-&gt;relWeaponPos).Length())
+					&gt; (orderTarget-&gt;pos.SqDistance(owner-&gt;pos));
 			b4 = w-&gt;TryTargetHeading(GetHeadingFromVector(-diff.x, -diff.z),
 					orderTarget-&gt;pos, orderTarget != NULL);
 			edgeFactor = fabs(w-&gt;targetBorder);
@@ -804,8 +804,8 @@
 		// to goal position greater than
 		// (10 plus 20% of 2D distance between attacker and target) then we need to close
 		// in on target more
-		else if ((orderTarget-&gt;pos + owner-&gt;posErrorVector * 128).distance2D(goalPos)
-				&gt; (10 + orderTarget-&gt;pos.distance2D(owner-&gt;pos) * 0.2f)) {
+		else if ((orderTarget-&gt;pos + owner-&gt;posErrorVector * 128).SqDistance2D(goalPos)
+				&gt; Square(10 + orderTarget-&gt;pos.distance2D(owner-&gt;pos) * 0.2f)) {
 			// if the target isn't in LOS, go to its approximate position
 			// otherwise try to go precisely to the target
 			// this should fix issues with low range weapons (mainly melee)
@@ -866,7 +866,7 @@
 		}
 
 		// if we are more than 10 units distant from target position then keeping moving closer
-		else if (pos.distance2D(goalPos) &gt; 10) {
+		else if (pos.SqDistance2D(goalPos) &gt; 100) {
 			SetGoal(pos, owner-&gt;pos);
 		}
 	}
@@ -1041,8 +1041,8 @@
 			&amp;&amp; !owner-&gt;weapons.empty() &amp;&amp; owner-&gt;haveTarget) {
 		if(!owner-&gt;userTarget) {
 			owner-&gt;haveTarget = false;
-		} else if(owner-&gt;pos.distance2D(owner-&gt;userTarget-&gt;pos) &lt;
-				owner-&gt;maxRange + 200*owner-&gt;moveState*owner-&gt;moveState) {
+		} else if(owner-&gt;pos.SqDistance2D(owner-&gt;userTarget-&gt;pos) &lt;
+				Square(owner-&gt;maxRange + 200*owner-&gt;moveState*owner-&gt;moveState)) {
 			Command c;
 			c.id = CMD_ATTACK;
 			c.options=INTERNAL_ORDER;
@@ -1057,8 +1057,8 @@
 		if(owner-&gt;lastAttacker &amp;&amp; owner-&gt;lastAttack + 200 &gt; gs-&gt;frameNum
 				&amp;&amp; !(owner-&gt;unitDef-&gt;noChaseCategory &amp; owner-&gt;lastAttacker-&gt;category)){
 			float3 apos=owner-&gt;lastAttacker-&gt;pos;
-			float dist=apos.distance2D(owner-&gt;pos);
-			if(dist&lt;owner-&gt;maxRange+200*owner-&gt;moveState*owner-&gt;moveState){
+			float dist=apos.SqDistance2D(owner-&gt;pos);
+			if(dist&lt;Square(owner-&gt;maxRange+200*owner-&gt;moveState*owner-&gt;moveState)){
 				Command c;
 				c.id=CMD_ATTACK;
 				c.options=INTERNAL_ORDER;

Modified: branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/CommandAI/TransportCAI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -20,6 +20,7 @@
 #include &quot;Rendering/UnitModels/3DOParser.h&quot;
 #include &quot;creg/STL_List.h&quot;
 #include &quot;System/GlobalUnsynced.h&quot;
+#include &quot;System/myMath.h&quot;
 
 #define AIRTRANSPORT_DOCKING_RADIUS 16
 #define AIRTRANSPORT_DOCKING_ANGLE 50
@@ -87,10 +88,11 @@
 
 CTransportCAI::~CTransportCAI(void)
 {
-	if(toBeTransportedUnitId!=-1){
-		if(uh-&gt;units[toBeTransportedUnitId])
-			uh-&gt;units[toBeTransportedUnitId]-&gt;toBeTransported=false;
-		toBeTransportedUnitId=-1;
+	// if uh == NULL then all pointers to units should be considered dangling pointers
+	if (uh &amp;&amp; toBeTransportedUnitId != -1) {
+		if (uh-&gt;units[toBeTransportedUnitId])
+			uh-&gt;units[toBeTransportedUnitId]-&gt;toBeTransported = false;
+		toBeTransportedUnitId = -1;
 	}
 }
 
@@ -158,11 +160,11 @@
 				FinishCommand();
 				return;
 			}
-			if(goalPos.distance2D(unit-&gt;pos)&gt;10){
+			if(goalPos.SqDistance2D(unit-&gt;pos)&gt;100){
 				float3 fix = unit-&gt;pos;
 				SetGoal(fix,owner-&gt;pos,64);
 			}
-			if(unit-&gt;pos.distance2D(owner-&gt;pos)&lt;owner-&gt;unitDef-&gt;loadingRadius*0.9f){
+			if(unit-&gt;pos.SqDistance2D(owner-&gt;pos)&lt;Square(owner-&gt;unitDef-&gt;loadingRadius*0.9f)){
 				if(CTAAirMoveType* am=dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType)){		//handle air transports differently
 					float3 wantedPos=unit-&gt;pos+UpVector*unit-&gt;model-&gt;height;
 					SetGoal(wantedPos,owner-&gt;pos);
@@ -171,7 +173,7 @@
 					am-&gt;SetWantedAltitude(unit-&gt;model-&gt;height);
 					am-&gt;maxDrift=1;
 					//logOutput.Print(&quot;cai dist %f %f %f&quot;,owner-&gt;pos.distance(wantedPos),owner-&gt;pos.distance2D(wantedPos),owner-&gt;pos.y-wantedPos.y);
-					if(owner-&gt;pos.distance(wantedPos)&lt;AIRTRANSPORT_DOCKING_RADIUS &amp;&amp; abs(owner-&gt;heading-unit-&gt;heading)&lt;AIRTRANSPORT_DOCKING_ANGLE &amp;&amp; owner-&gt;updir.dot(UpVector)&gt;0.995f){
+					if(owner-&gt;pos.SqDistance(wantedPos)&lt;Square(AIRTRANSPORT_DOCKING_RADIUS) &amp;&amp; abs(owner-&gt;heading-unit-&gt;heading)&lt;AIRTRANSPORT_DOCKING_ANGLE &amp;&amp; owner-&gt;updir.dot(UpVector)&gt;0.995f){
 						am-&gt;dontCheckCol=false;
 						am-&gt;dontLand=true;
 						std::vector&lt;int&gt; args;
@@ -449,7 +451,7 @@
 
 	// remaining spots
 	if (dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType)) {
-		while (ti != transport-&gt;transported.end() &amp;&amp; startpos.distance(nextPos) &lt; startpos.distance(endpos)) {
+		while (ti != transport-&gt;transported.end() &amp;&amp; startpos.SqDistance(nextPos) &lt; startpos.SqDistance(endpos)) {
 			nextPos += dir*(ti-&gt;unit-&gt;radius);
 			nextPos.y = ground-&gt;GetHeight(nextPos.x, nextPos.z);
 
@@ -632,7 +634,7 @@
 		}
 
 		float3 pos(c.params[0], c.params[1], c.params[2]);
-		if(goalPos.distance2D(pos) &gt; 20){
+		if(goalPos.SqDistance2D(pos) &gt; 400){
 			SetGoal(pos, owner-&gt;pos);
 		}
 
@@ -655,7 +657,7 @@
 			}
 		}
 
-		if (pos.distance2D(owner-&gt;pos) &lt; (owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
+		if (pos.SqDistance2D(owner-&gt;pos) &lt; Square(owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
 			CTAAirMoveType* am = dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType);
 			if (am != NULL) {
 				// handle air transports differently
@@ -664,7 +666,7 @@
 				SetGoal(wantedPos, owner-&gt;pos);
 				am-&gt;SetWantedAltitude(unit-&gt;model-&gt;height);
 				am-&gt;maxDrift = 1;
-				if ((owner-&gt;pos.distance(wantedPos) &lt; 8) &amp;&amp;
+				if ((owner-&gt;pos.SqDistance(wantedPos) &lt; 64) &amp;&amp;
 						(owner-&gt;updir.dot(UpVector) &gt; 0.99f)) {
 					if (!SpotIsClearIgnoreSelf(wantedPos, unit)) {
 						// chosen spot is no longer clear to land, choose a new one
@@ -719,7 +721,7 @@
 		float3 pos(c.params[0],c.params[1],c.params[2]); //head towards goal
 
 		//note that taairmovetype must be modified to allow non stop movement through goals for this to work well
-		if(goalPos.distance2D(pos)&gt;20){
+		if(goalPos.SqDistance2D(pos)&gt;400){
 			SetGoal(pos,owner-&gt;pos);
 			lastDropPos = pos;
 		}
@@ -731,7 +733,7 @@
 			am-&gt;maxDrift=1;
 
 			//if near target or have past it accidentally- drop unit
-			if(owner-&gt;pos.distance2D(pos) &lt; 40 || (((pos - owner-&gt;pos).Normalize()).distance(owner-&gt;frontdir.Normalize()) &gt; 0.5 &amp;&amp; owner-&gt;pos.distance2D(pos)&lt; 205)) {
+			if(owner-&gt;pos.SqDistance2D(pos) &lt; 1600 || (((pos - owner-&gt;pos).Normalize()).SqDistance(owner-&gt;frontdir.Normalize()) &gt; 0.25 &amp;&amp; owner-&gt;pos.SqDistance2D(pos)&lt; (205*205))) {
 				am-&gt;dontLand=true;
 				owner-&gt;cob-&gt;Call(&quot;EndTransport&quot;); //test
 				((CTransportUnit*)owner)-&gt;DetachUnitFromAir(unit,pos);
@@ -797,11 +799,11 @@
 		//move to position
 		float3 pos(c.params[0], c.params[1], c.params[2]);
 		if (isFirstIteration) {
-			if(goalPos.distance2D(pos) &gt; 20)
+			if(goalPos.SqDistance2D(pos) &gt; 400)
 				SetGoal(startingDropPos, owner-&gt;pos);
 		}
 
-		if (startingDropPos.distance2D(owner-&gt;pos) &lt; (owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
+		if (startingDropPos.SqDistance2D(owner-&gt;pos) &lt; Square(owner-&gt;unitDef-&gt;loadingRadius * 0.9f)) {
 			//create aircraft movetype instance
 			CTAAirMoveType* am = dynamic_cast&lt;CTAAirMoveType*&gt;(owner-&gt;moveType);
 
@@ -865,7 +867,7 @@
 	std::vector&lt;CUnit*&gt; units=qf-&gt;GetUnitsExact(center,radius);
 	for(std::vector&lt;CUnit*&gt;::iterator ui=units.begin();ui!=units.end();++ui){
 		CUnit* unit=(*ui);
-		float dist=unit-&gt;pos.distance2D(owner-&gt;pos);
+		float dist=unit-&gt;pos.SqDistance2D(owner-&gt;pos);
 		if(CanTransport(unit) &amp;&amp; dist&lt;bestDist &amp;&amp; !unit-&gt;toBeTransported &amp;&amp;
 				 (unit-&gt;losStatus[owner-&gt;allyteam] &amp; (LOS_INRADAR|LOS_INLOS))){
 			bestDist=dist;
@@ -1021,8 +1023,8 @@
 	}
 	Command cmd = commandQue[1];
 	return !(cmd.id == CMD_LOAD_UNITS &amp;&amp; cmd.params.size() == 4
-		&amp;&amp; unit-&gt;pos.distance2D(
-		float3(cmd.params[0], cmd.params[1], cmd.params[2])) &gt; cmd.params[3]*2);
+		&amp;&amp; unit-&gt;pos.SqDistance2D(
+		float3(cmd.params[0], cmd.params[1], cmd.params[2])) &gt; Square(cmd.params[3]*2));
 }
 
 bool CTransportCAI::AllowedCommand(const Command&amp; c)

Modified: branches/caiinterface/rts/Sim/Units/Unit.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/Unit.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -237,6 +237,7 @@
 	directControl = NULL;
 #endif
 	activated = false;
+	GML_GET_TICKS(lastUnitUpdate);
 }
 
 CUnit::~CUnit()
@@ -530,6 +531,7 @@
 	const bool oldInWater = inWater;
 
 	moveType-&gt;Update();
+	GML_GET_TICKS(lastUnitUpdate);
 
 	inAir   = ((pos.y + height) &gt;= 0.0f);
 	inWater =  (pos.y           &lt;= 0.0f);
@@ -868,9 +870,9 @@
 				KillUnit(true, false, NULL);
 			}
 		}
-		if (userTarget &amp;&amp; userTarget-&gt;pos.distance(pos) &lt; unitDef-&gt;kamikazeDist)
+		if (userTarget &amp;&amp; (userTarget-&gt;pos.SqDistance(pos) &lt; Square(unitDef-&gt;kamikazeDist)))
 			KillUnit(true, false, NULL);
-		if (userAttackGround &amp;&amp; userAttackPos.distance(pos) &lt; unitDef-&gt;kamikazeDist)
+		if (userAttackGround &amp;&amp; (userAttackPos.distance(pos)) &lt; Square(unitDef-&gt;kamikazeDist))
 			KillUnit(true, false, NULL);
 	}
 
@@ -1112,23 +1114,35 @@
 }
 
 
-
+void CUnit::UpdateDrawPos() {
+	CTransportUnit *trans=GetTransporter(); 
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	if (trans) {
+		drawPos = pos + (trans-&gt;speed * ((float)gu-&gt;lastFrameStart - (float)lastUnitUpdate) * gu-&gt;weightedSpeedFactor);
+	} else {
+		drawPos = pos + (speed * ((float)gu-&gt;lastFrameStart - (float)lastUnitUpdate) * gu-&gt;weightedSpeedFactor);
+	}
+#else
+	if (trans) {
+		drawPos = pos + (trans-&gt;speed * gu-&gt;timeOffset);
+	} else {
+		drawPos = pos + (speed * gu-&gt;timeOffset);
+	}
+#endif
+}
 /******************************************************************************/
 /******************************************************************************/
 
 CMatrix44f CUnit::GetTransformMatrix(const bool synced, const bool error) const
 {
-	float3 interPos;
-	if (!transporter) {
-		interPos = (synced? pos: pos + (speed * gu-&gt;timeOffset));
-	} else {
-		interPos = (synced? pos: pos + (transporter-&gt;speed * gu-&gt;timeOffset));
-	}
+	float3 interPos = synced ? pos : drawPos;
 
-	if (!synced &amp;&amp; error) {
+	if (error &amp;&amp; !synced &amp;&amp; !gu-&gt;spectatingFullView) {
 		interPos += helper-&gt;GetUnitErrorPos(this, gu-&gt;myAllyTeam) - midPos;
 	}
 
+	CTransportUnit *trans;
+
 	if (usingScriptMoveType ||
 	    (!beingBuilt &amp;&amp; (physicalState == Flying) &amp;&amp; unitDef-&gt;canmove)) {
 		// aircraft, skidding ground unit, or active ScriptMoveType
@@ -1136,7 +1150,7 @@
 		// use this matrix, or their nanoframes won't spin on pad
 		return CMatrix44f(interPos, -rightdir, updir, frontdir);
 	}
-	else if (transporter &amp;&amp; transporter-&gt;unitDef-&gt;holdSteady) {
+	else if ((trans=GetTransporter()) &amp;&amp; trans-&gt;unitDef-&gt;holdSteady) {
 		// making local copies of vectors
 		float3 frontDir = GetVectorFromHeading(heading);
 		float3 upDir    = updir;
@@ -1660,6 +1674,8 @@
 			group=0;									//group ai didnt accept us
 			return false;
 		} else { // add us to selected units if group is selected
+			GML_RECMUTEX_LOCK(sel); // SetGroup
+
 			if(selectedUnits.selectedGroup == group-&gt;id)
 				selectedUnits.AddUnit(this);
 		}
@@ -2458,6 +2474,8 @@
 
 	CR_MEMBER(inAir),
 	CR_MEMBER(inWater),
+//	CR_MEMBER(drawPos),
+//	CR_RESERVED(4),
 
 	CR_RESERVED(126),
 

Modified: branches/caiinterface/rts/Sim/Units/Unit.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/Unit.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/Unit.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -314,6 +314,19 @@
 
 	bool activated;					//if the unit is in it's 'on'-state
 
+	inline CTransportUnit *GetTransporter() const {
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+		return *(CTransportUnit * volatile *)&transporter; // transporter may suddenly be changed to NULL by sim
+#else
+		return transporter;
+#endif
+	}
+
+	void UpdateDrawPos();
+	float3 drawPos;
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	unsigned lastUnitUpdate;
+#endif
 	//CUnit3DLoader::UnitModel* model;
 	S3DOModel *model;
 	CCobInstance *cob;

Modified: branches/caiinterface/rts/Sim/Units/UnitDef.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitDef.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitDef.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -221,6 +221,7 @@
 	const WeaponDef* shieldWeaponDef;
 	const WeaponDef* stockpileWeaponDef;
 	float maxWeaponRange;
+	float maxCoverage;
 
 	std::map&lt;int, std::string&gt; buildOptions;
 

Modified: branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitDefHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -524,6 +524,7 @@
 	ud.stockpileWeaponDef = NULL;
 
 	ud.maxWeaponRange = 0.0f;
+	ud.maxCoverage = 0.0f;
 
 	const WeaponDef* noWeaponDef = weaponDefHandler-&gt;GetWeapon(&quot;NOWEAPON&quot;);
 
@@ -584,6 +585,9 @@
 		if (wd-&gt;range &gt; ud.maxWeaponRange) {
 			ud.maxWeaponRange = wd-&gt;range;
 		}
+		if (wd-&gt;interceptor &amp;&amp; wd-&gt;coverageRange &gt; ud.maxCoverage) {
+			ud.maxCoverage = wd-&gt;coverageRange;
+		}
 		if (wd-&gt;isShield) {
 			if (!ud.shieldWeaponDef || // use the biggest shield
 			    (ud.shieldWeaponDef-&gt;shieldRadius &lt; wd-&gt;shieldRadius)) {
@@ -830,7 +834,7 @@
 {
 	string fileName = soundsTable.GetString(soundName, &quot;&quot;);
 	if (!fileName.empty()) {
-		LoadSound(gsound, fileName, 5.0f);
+		LoadSound(gsound, fileName, 1.0f);
 		return;
 	}
 
@@ -840,7 +844,7 @@
 		if (sndFileTable.IsValid()) {
 			fileName = sndFileTable.GetString(&quot;file&quot;, &quot;&quot;);
 			if (!fileName.empty()) {
-				const float volume = sndFileTable.GetFloat(&quot;volume&quot;, 5.0f);
+				const float volume = sndFileTable.GetFloat(&quot;volume&quot;, 1.0f);
 				if (volume &gt; 0.0f) {
 					LoadSound(gsound, fileName, volume);
 				}
@@ -850,7 +854,7 @@
 			if (fileName.empty()) {
 				break;
 			}
-			LoadSound(gsound, fileName, 5.0f);
+			LoadSound(gsound, fileName, 1.0f);
 		}
 	}
 }

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -38,6 +38,7 @@
 #include &quot;System/creg/STL_Deque.h&quot;
 #include &quot;System/creg/STL_List.h&quot;
 #include &quot;System/creg/STL_Set.h&quot;
+#include &quot;Rendering/UnitModels/UnitDrawer.h&quot;
 
 using std::min;
 using std::max;
@@ -103,7 +104,9 @@
 	CR_MEMBER(metalMakerEfficiency),
 	CR_MEMBER(toBeRemoved),
 	CR_MEMBER(morphUnitToFeature),
-	CR_MEMBER(toBeRemoved),
+//	CR_MEMBER(toBeRemoved),
+	CR_MEMBER(toBeAdded),
+	CR_MEMBER(renderUnits),
 	CR_MEMBER(builderCAIs),
 	CR_MEMBER(unitsByDefs),
 	CR_POSTLOAD(PostLoad),
@@ -186,7 +189,8 @@
 
 int CUnitHandler::AddUnit(CUnit *unit)
 {
-	GML_RECMUTEX_LOCK(unit); // AddUnit
+//	GML_RECMUTEX_LOCK(unit); // AddUnit. Not needed, protected via LoadUnit. 
+
 	ASSERT_SYNCED_MODE;
 	int num = (int)(gs-&gt;randFloat()) * ((int)activeUnits.size() - 1);
 	std::list&lt;CUnit*&gt;::iterator ui = activeUnits.begin();
@@ -213,6 +217,10 @@
 
 	maxUnitRadius = max(unit-&gt;radius, maxUnitRadius);
 
+	GML_STDMUTEX_LOCK(render);
+
+	toBeAdded.insert(unit);
+
 	return unit-&gt;id;
 }
 
@@ -257,6 +265,27 @@
 			++usi;
 		}
 	}
+
+	GML_STDMUTEX_LOCK(render);
+
+	for(usi=renderUnits.begin(); usi!=renderUnits.end(); ++usi) {
+		if(*usi==delUnit) {
+			renderUnits.erase(usi);
+			break;
+		}
+	}
+
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
+	for(int i=0, dcs=unitDrawer-&gt;drawCloaked.size(); i&lt;dcs; ++i)
+		if(unitDrawer-&gt;drawCloaked[i]==delUnit)
+			unitDrawer-&gt;drawCloaked[i]=NULL;
+
+	for(int i=0, dcs=unitDrawer-&gt;drawCloakedS3O.size(); i&lt;dcs; ++i)
+		if(unitDrawer-&gt;drawCloakedS3O[i]==delUnit)
+			unitDrawer-&gt;drawCloakedS3O[i]=NULL;
+#endif
+
+	toBeAdded.erase(delUnit);
 }
 
 
@@ -266,9 +295,9 @@
 	SCOPED_TIMER(&quot;Unit handler&quot;);
 
 	if(!toBeRemoved.empty()) {
-		GML_RECMUTEX_LOCK(unit); // Update. Possibly not needed, activeUnits.erase is synchronized.
+		GML_RECMUTEX_LOCK(unit); // Update. For anti-deadlock purposes.
+		GML_RECMUTEX_LOCK(sel); // Update. Unit is removed from selectedUnits in ~CObject, which is too late.
 		GML_RECMUTEX_LOCK(quad); // Update. Make sure unit does not get partially deleted before before being removed from the quadfield
-		GML_RECMUTEX_LOCK(sel); // Update. Unit is removed from selectedUnits in ~CObject, which is too late.
 
 		while (!toBeRemoved.empty()) {
 			CUnit* delUnit = toBeRemoved.back();
@@ -278,6 +307,8 @@
 		}
 	}
 
+	GML_UPDATE_TICKS();
+
 	std::list&lt;CUnit*&gt;::iterator usi;
 	for (usi = activeUnits.begin(); usi != activeUnits.end(); usi++) {
 		(*usi)-&gt;Update();

Modified: branches/caiinterface/rts/Sim/Units/UnitHandler.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitHandler.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitHandler.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -61,6 +61,9 @@
 
 	std::vector&lt;CUnit*&gt; toBeRemoved;			//units that will be removed at start of next update
 
+	std::set&lt;CUnit*&gt; toBeAdded;			//rendering units that will be added at start of next draw
+	std::list&lt;CUnit*&gt; renderUnits;				//units being rendered
+
 	std::list&lt;CUnit*&gt;::iterator slowUpdateIterator;
 
 	std::list&lt;CBuilderCAI*&gt; builderCAIs;

Modified: branches/caiinterface/rts/Sim/Units/UnitLoader.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitLoader.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitLoader.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -74,7 +74,8 @@
 CUnit* CUnitLoader::LoadUnit(const string&amp; name, float3 pos, int team,
                              bool build, int facing, const CUnit* builder)
 {
-	GML_RECMUTEX_LOCK(unit); // LoadUnit. Unitinit puts unit in the quadfield and activeUnits -
+//	GML_RECMUTEX_LOCK(unit); // LoadUnit. Unitinit puts unit in the quadfield and activeUnits -
+	GML_RECMUTEX_LOCK(sel); // LoadUnit. For anti deadlock purposes.
 	GML_RECMUTEX_LOCK(quad); // LoadUnit. - make sure other threads cannot access an incomplete unit
 
 	CUnit* unit;

Modified: branches/caiinterface/rts/Sim/Units/UnitTracker.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitTracker.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitTracker.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -85,6 +85,8 @@
 
 void CUnitTracker::Track()
 {
+	GML_RECMUTEX_LOCK(sel); // Track
+
 	CUnitSet&amp; units = selectedUnits.selectedUnits;
 
 	CleanTrackGroup();
@@ -119,6 +121,8 @@
 
 void CUnitTracker::MakeTrackGroup()
 {
+	GML_RECMUTEX_LOCK(sel); // MakeTrackGroup
+
 	trackGroup.clear();
 	CUnitSet&amp; units = selectedUnits.selectedUnits;
 	CUnitSet::const_iterator it;

Modified: branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -257,7 +257,7 @@
 				StopBuild(true);
 			}
 		}
-		else if (curBuild &amp;&amp; f3Dist(curBuild-&gt;pos, pos) &lt; buildDistance + curBuild-&gt;radius) {
+		else if (curBuild &amp;&amp; f3SqDist(curBuild-&gt;pos, pos) &lt; Square(buildDistance + curBuild-&gt;radius)) {
 			if (curBuild-&gt;soloBuilder &amp;&amp; (curBuild-&gt;soloBuilder != this)) {
 				StopBuild();
 			} else {
@@ -292,7 +292,7 @@
 				}
 			}
 		}
-		else if(curReclaim &amp;&amp; f3Dist(curReclaim-&gt;pos, pos)&lt;buildDistance+curReclaim-&gt;radius &amp;&amp; inBuildStance){
+		else if(curReclaim &amp;&amp; f3SqDist(curReclaim-&gt;pos, pos)&lt;Square(buildDistance+curReclaim-&gt;radius) &amp;&amp; inBuildStance){
 			if (scriptCloak &lt;= 2) {
 				if (isCloaked) {
 					isCloaked = false;
@@ -304,7 +304,7 @@
 				CreateNanoParticle(curReclaim-&gt;midPos, curReclaim-&gt;radius * 0.7f, true);
 			}
 		}
-		else if(curResurrect &amp;&amp; f3Dist(curResurrect-&gt;pos, pos)&lt;buildDistance+curResurrect-&gt;radius &amp;&amp; inBuildStance){
+		else if(curResurrect &amp;&amp; f3SqDist(curResurrect-&gt;pos, pos)&lt;Square(buildDistance+curResurrect-&gt;radius) &amp;&amp; inBuildStance){
 			const UnitDef* ud=unitDefHandler-&gt;GetUnitByName(curResurrect-&gt;createdFromUnit);
 			if(ud){
 				if ((modInfo.reclaimMethod != 1) &amp;&amp; (curResurrect-&gt;reclaimLeft &lt; 1)) {
@@ -338,7 +338,7 @@
 				StopBuild(true);
 			}
 		}
-		else if(curCapture &amp;&amp; f3Dist(curCapture-&gt;pos, pos)&lt;buildDistance+curCapture-&gt;radius &amp;&amp; inBuildStance){
+		else if(curCapture &amp;&amp; f3SqDist(curCapture-&gt;pos, pos)&lt;Square(buildDistance+curCapture-&gt;radius) &amp;&amp; inBuildStance){
 			if(curCapture-&gt;team!=team){
 
 				float captureProgressTemp = curCapture-&gt;captureProgress + 1.0f/(150+curCapture-&gt;buildTime/captureSpeed*(curCapture-&gt;health+curCapture-&gt;maxHealth)/curCapture-&gt;maxHealth*0.4f);
@@ -719,7 +719,7 @@
 		float3 weaponPos = pos + frontdir * relWeaponFirePos.z + updir * relWeaponFirePos.y + rightdir * relWeaponFirePos.x;
 
 		float3 dif = goal - weaponPos;
-		float l = dif.Length();
+		const float l = fastmath::sqrt2(dif.SqLength());
 		dif /= l;
 		float3 error = gu-&gt;usRandVector() * (radius / l);
 		float3 color = unitDef-&gt;nanoColor;

Modified: branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.h
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitTypes/Builder.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -20,6 +20,9 @@
 	inline float f3Dist(const float3&amp; a, const float3&amp; b) const {
 		return range3D ? a.distance(b) : a.distance2D(b);
 	}
+	inline float f3SqDist(const float3&amp; a, const float3&amp; b) const {
+		return range3D ? a.SqDistance(b) : a.SqDistance2D(b);
+	}
 	inline float f3Len(const float3&amp; a) const {
 		return range3D ? a.Length() : a.Length2D();
 	}

Modified: branches/caiinterface/rts/Sim/Units/UnitTypes/Building.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitTypes/Building.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitTypes/Building.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -40,7 +40,7 @@
 {
 	CUnitDrawer::GhostBuilding* gb = NULL;
 
-	if (!gameSetup || gameSetup-&gt;ghostedBuildings) {
+	if (unitDrawer &amp;&amp; (!gameSetup || gameSetup-&gt;ghostedBuildings)) {
 		if (!(losStatus[gu-&gt;myAllyTeam] &amp; (LOS_INLOS | LOS_CONTRADAR)) &amp;&amp;
 		     (losStatus[gu-&gt;myAllyTeam] &amp; (LOS_PREVLOS)) &amp;&amp;
 		    !gu-&gt;spectatingFullView) {
@@ -63,7 +63,7 @@
 		}
 	}
 
-	if (buildingDecal) {
+	if (groundDecals &amp;&amp; buildingDecal) {
 		groundDecals-&gt;RemoveBuilding(this, gb);
 	}
 }

Modified: branches/caiinterface/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitTypes/ExtractorBuilding.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -18,6 +18,7 @@
 #include &quot;Sim/Misc/QuadField.h&quot;
 #include &quot;Sync/SyncTracer.h&quot;
 #include &quot;creg/STL_List.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CExtractorBuilding, CBuilding, );
@@ -49,7 +50,10 @@
 
 CExtractorBuilding::~CExtractorBuilding()
 {
-	ResetExtraction();
+	// if uh == NULL then all pointers to units should be considered dangling pointers
+	if (uh) {
+		ResetExtraction();
+	}
 }
 
 /* CReg PostLoad */
@@ -105,10 +109,10 @@
 		const float3 p7 = circle-&gt;pos + float3(                    0.0f, 0.0f,  circle-&gt;extractionRange); // 270
 
 		// square corners must all lie outside circle
-		const bool b0 = (p0.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
-		const bool b1 = (p1.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
-		const bool b2 = (p2.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
-		const bool b3 = (p3.distance2D(circle-&gt;pos) &gt; circle-&gt;extractionRange);
+		const bool b0 = (p0.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
+		const bool b1 = (p1.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
+		const bool b2 = (p2.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
+		const bool b3 = (p3.SqDistance2D(circle-&gt;pos) &gt; Square(circle-&gt;extractionRange));
 		// circle &quot;corners&quot; must all lie outside square
 		const bool b4 = ((p4.x &lt; p0.x || p4.x &gt; p1.x) &amp;&amp; (p4.z &lt; p0.z || p4.z &gt; p3.z));
 		const bool b5 = ((p5.x &lt; p0.x || p5.x &gt; p1.x) &amp;&amp; (p5.z &lt; p0.z || p5.z &gt; p3.z));
@@ -119,7 +123,7 @@
 	}
 	if (sum == 0) {
 		// circle vs. circle
-		return (this-&gt;pos.distance2D(other-&gt;pos) &lt; (this-&gt;extractionRange + other-&gt;extractionRange));
+		return (this-&gt;pos.SqDistance2D(other-&gt;pos) &lt; Square(this-&gt;extractionRange + other-&gt;extractionRange));
 	}
 
 	return false;
@@ -161,9 +165,9 @@
 			// center of metalsquare at (x, z)
 			const float3 msqrPos((x + 0.5f) * METAL_MAP_SQUARE_SIZE, pos.y,
 			                     (z + 0.5f) * METAL_MAP_SQUARE_SIZE);
-			const float sqrCenterDistance = msqrPos.distance2D(this-&gt;pos);
+			const float sqrCenterDistance = msqrPos.SqDistance2D(this-&gt;pos);
 
-			if (unitDef-&gt;extractSquare || sqrCenterDistance &lt; extractionRange) {
+			if (unitDef-&gt;extractSquare || sqrCenterDistance &lt; Square(extractionRange)) {
 				MetalSquareOfControl msqr;
 				msqr.x = x;
 				msqr.z = z;

Modified: branches/caiinterface/rts/Sim/Units/UnitTypes/Factory.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Units/UnitTypes/Factory.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Units/UnitTypes/Factory.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -59,11 +59,13 @@
 {
 }
 
+
 CFactory::~CFactory()
 {
-	if(curBuild){
-		curBuild-&gt;KillUnit(false,true,0);
-		curBuild=0;
+	// if uh == NULL then all pointers to units should be considered dangling pointers
+	if (uh &amp;&amp; curBuild) {
+		curBuild-&gt;KillUnit(false, true, 0);
+		curBuild = 0;
 	}
 }
 
@@ -159,26 +161,26 @@
 			// factory not under construction and
 			// nanolathing unit: continue building
 			lastBuild = gs-&gt;frameNum;
-	
+
 			// buildPiece is the rotating platform
 			const int buildPiece = GetBuildPiece();
 			CMatrix44f mat = localmodel-&gt;GetPieceMatrix(buildPiece);
 			const int h = GetHeadingFromVector(mat[2], mat[10]);
-	
+
 			// rotate unit nanoframe with platform
 			curBuild-&gt;heading = (h + GetHeadingFromFacing(buildFacing)) &amp; 65535;
-	
+
 			const float3 buildPos = CalcBuildPos(buildPiece);
 			curBuild-&gt;pos = buildPos;
-	
+
 			if (curBuild-&gt;floatOnWater) {
 				curBuild-&gt;pos.y  = ground-&gt;GetHeight(buildPos.x, buildPos.z);
 				curBuild-&gt;pos.y -= curBuild-&gt;unitDef-&gt;waterline;
 			}
 			curBuild-&gt;midPos = curBuild-&gt;pos + (UpVector * curBuild-&gt;relMidPos.y);
-	
+
 			const CCommandQueue&amp; queue = commandAI-&gt;commandQue;
-	
+
 			if(!queue.empty() &amp;&amp; (queue.front().id == CMD_WAIT)) {
 				curBuild-&gt;AddBuildPower(0, this);
 			} else {
@@ -347,7 +349,7 @@
 										 + (updir    * relWeaponFirePos.y)
 										 + (rightdir * relWeaponFirePos.x);
 			float3 dif = (curBuild-&gt;midPos - weaponPos);
-			const float l = dif.Length();
+			const float l = fastmath::sqrt2(dif.SqLength());
 			dif /= l;
 			dif += gu-&gt;usRandVector() * 0.15f;
 			float3 color = unitDef-&gt;nanoColor;

Modified: branches/caiinterface/rts/Sim/Weapons/Cannon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/Cannon.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Weapons/Cannon.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -155,7 +155,7 @@
 void CCannon::Fire(void)
 {
 	float3 diff = targetPos-weaponMuzzlePos;
-	float3 dir=(diff.Length() &gt; 2.0) ? GetWantedDir(diff) : diff; //prevent vertical aim when emit-sfx firing the weapon
+	float3 dir=(diff.SqLength() &gt; 4.0) ? GetWantedDir(diff) : diff; //prevent vertical aim when emit-sfx firing the weapon
 	dir+=(gs-&gt;randVector()*sprayAngle+salvoError)*(1-owner-&gt;limExperience*0.9f);
 	dir.Normalize();
 #ifdef TRACE_SYNC

Modified: branches/caiinterface/rts/Sim/Weapons/DGunWeapon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/DGunWeapon.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Weapons/DGunWeapon.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -7,6 +7,7 @@
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;WeaponDefHandler.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CDGunWeapon, CWeapon, (NULL));
@@ -40,7 +41,7 @@
 
 void CDGunWeapon::Fire(void)
 {
-	if(uh-&gt;limitDgun &amp;&amp; owner-&gt;unitDef-&gt;isCommander &amp;&amp; owner-&gt;pos.distance(gs-&gt;Team(owner-&gt;team)-&gt;startPos)&gt;uh-&gt;dgunRadius){
+	if(uh-&gt;limitDgun &amp;&amp; owner-&gt;unitDef-&gt;isCommander &amp;&amp; owner-&gt;pos.SqDistance(gs-&gt;Team(owner-&gt;team)-&gt;startPos)&gt;Square(uh-&gt;dgunRadius)){
 		return;		//prevents dgunning using fps view if outside dgunlimit
 	}
 

Modified: branches/caiinterface/rts/Sim/Weapons/PlasmaRepulser.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Weapons/PlasmaRepulser.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -17,6 +17,7 @@
 #include &quot;WeaponDefHandler.h&quot;
 #include &quot;Weapon.h&quot;
 #include &quot;mmgr.h&quot;
+#include &quot;System/myMath.h&quot;
 
 CR_BIND_DERIVED(CPlasmaRepulser, CWeapon, (NULL));
 
@@ -270,7 +271,7 @@
 	}
 	float3 closeVect=dif-dir*closeLength;
 
-	if (closeVect.Length2D() &lt; (radius * 1.5f + 400)) {
+	if (closeVect.SqLength2D() &lt; Square(radius * 1.5f + 400)) {
 		incoming.push_back(p);
 		AddDeathDependence(p);
 	}

Modified: branches/caiinterface/rts/Sim/Weapons/Weapon.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/Weapon.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Weapons/Weapon.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -267,7 +267,7 @@
 
 		float3 lead = targetUnit-&gt;speed * (weaponDef-&gt;predictBoost+predictSpeedMod * (1.0f - weaponDef-&gt;predictBoost)) * predict;
 
-		if (weaponDef-&gt;leadLimit &gt;= 0.0f &amp;&amp; lead.Length() &gt; weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus * owner-&gt;experience) {
+		if (weaponDef-&gt;leadLimit &gt;= 0.0f &amp;&amp; lead.SqLength() &gt; Square(weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus * owner-&gt;experience)) {
 			lead *= (weaponDef-&gt;leadLimit + weaponDef-&gt;leadBonus*owner-&gt;experience) / (lead.Length() + 0.01f);
 		}
 

Modified: branches/caiinterface/rts/Sim/Weapons/bombdropper.cpp
===================================================================
--- branches/caiinterface/rts/Sim/Weapons/bombdropper.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/Sim/Weapons/bombdropper.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -16,6 +16,7 @@
 #include &quot;Sim/Units/Unit.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;WeaponDefHandler.h&quot;
+#include &quot;System/myMath.h&quot;
 #include &quot;mmgr.h&quot;
 
 CR_BIND_DERIVED(CBombDropper, CWeapon, (NULL, false));
@@ -65,7 +66,7 @@
 				predict=0;
 			float3 hitpos=owner-&gt;pos+owner-&gt;speed*predict;
 			float speedf=owner-&gt;speed.Length();
-			if(hitpos.distance2D(targetPos)&lt;std::max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange){
+			if(hitpos.SqDistance2D(targetPos)&lt;Square(std::max(1,(salvoSize-1))*speedf*salvoDelay*0.5f+bombMoveRange)){
 				subClassReady=true;
 			}
 		}

Modified: branches/caiinterface/rts/System/BaseNetProtocol.cpp
===================================================================
--- branches/caiinterface/rts/System/BaseNetProtocol.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/BaseNetProtocol.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -156,10 +156,11 @@
 }
 
 
-PacketType CBaseNetProtocol::SendAttemptConnect(uchar myPlayerNum, uchar networkVersion)
+PacketType CBaseNetProtocol::SendAttemptConnect(const std::string name, const std::string version)
 {
-	PackPacket* packet = new PackPacket(3, NETMSG_ATTEMPTCONNECT);
-	*packet &lt;&lt; myPlayerNum &lt;&lt; networkVersion;
+	uint16_t size = 5 + name.size() + version.size();
+	PackPacket* packet = new PackPacket(size , NETMSG_ATTEMPTCONNECT);
+	*packet &lt;&lt; size &lt;&lt; name &lt;&lt; version;
 	return PacketType(packet);
 }
 
@@ -382,7 +383,7 @@
 	proto-&gt;AddType(NETMSG_CPU_USAGE, 5);
 	proto-&gt;AddType(NETMSG_DIRECT_CONTROL, 2);
 	proto-&gt;AddType(NETMSG_DC_UPDATE, 7);
-	proto-&gt;AddType(NETMSG_ATTEMPTCONNECT, 3);
+	proto-&gt;AddType(NETMSG_ATTEMPTCONNECT, -2);
 	proto-&gt;AddType(NETMSG_SHARE, 12);
 	proto-&gt;AddType(NETMSG_SETSHARE, 11);
 	proto-&gt;AddType(NETMSG_SENDPLAYERSTAT, 1);

Modified: branches/caiinterface/rts/System/BaseNetProtocol.h
===================================================================
--- branches/caiinterface/rts/System/BaseNetProtocol.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/BaseNetProtocol.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -52,7 +52,7 @@
 	NETMSG_CPU_USAGE        = 21, // float cpuUsage;
 	NETMSG_DIRECT_CONTROL   = 22, // uchar myPlayerNum;
 	NETMSG_DC_UPDATE        = 23, // uchar myPlayerNum, status; short heading, pitch;
-	NETMSG_ATTEMPTCONNECT   = 25, // uchar myPlayerNum, networkVersion;
+	NETMSG_ATTEMPTCONNECT   = 25, // ushort msgsize, string playername, string VERSION_STRING_DETAILED
 	NETMSG_SHARE            = 26, // uchar myPlayerNum, shareTeam, bShareUnits; float shareMetal, shareEnergy;
 	NETMSG_SETSHARE         = 27, // uchar myPlayerNum, uchar myTeam; float metalShareFraction, energyShareFraction;
 	NETMSG_SENDPLAYERSTAT   = 28, //
@@ -128,7 +128,7 @@
 	PacketType SendCPUUsage(float cpuUsage);
 	PacketType SendDirectControl(uchar myPlayerNum);
 	PacketType SendDirectControlUpdate(uchar myPlayerNum, uchar status, short heading, short pitch);
-	PacketType SendAttemptConnect(uchar myPlayerNum, uchar networkVersion);
+	PacketType SendAttemptConnect(const std::string name, const std::string version);
 	PacketType SendShare(uchar myPlayerNum, uchar shareTeam, uchar bShareUnits, float shareMetal, float shareEnergy);
 	PacketType SendSetShare(uchar myPlayerNum, uchar myTeam, float metalShareFraction, float energyShareFraction);
 	PacketType SendSendPlayerStat();

Modified: branches/caiinterface/rts/System/EventClient.cpp
===================================================================
--- branches/caiinterface/rts/System/EventClient.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/EventClient.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -123,7 +123,7 @@
 
 bool CEventClient::CommandNotify(const Command&amp; cmd) { return false; }
 
-bool CEventClient::AddConsoleLine(const string&amp; msg, int zone) { return false; }
+bool CEventClient::AddConsoleLine(const string&amp; msg, CLogSubsystem&amp; subsystem) { return false; }
 
 bool CEventClient::GroupChanged(int groupID) { return false; }
 

Modified: branches/caiinterface/rts/System/EventClient.h
===================================================================
--- branches/caiinterface/rts/System/EventClient.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/EventClient.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,6 +19,7 @@
 class CFeature;
 class CProjectile;
 struct Command;
+class CLogSubsystem;
 
 
 class CEventClient
@@ -27,7 +28,7 @@
 		enum SpecialTeams {
 			NoAccessTeam   = -1,
 			AllAccessTeam  = -2,
-			MinSpecialTeam = AllAccessTeam 
+			MinSpecialTeam = AllAccessTeam
 		};
 
 	public:
@@ -108,7 +109,7 @@
 
 		virtual void StockpileChanged(const CUnit* unit,
 		                              const CWeapon* weapon, int oldCount);
-	
+
 		virtual bool Explosion(int weaponID, const float3&amp; pos, const CUnit* owner);
 
 		// Unsynced events
@@ -127,7 +128,7 @@
 
 		virtual bool CommandNotify(const Command&amp; cmd);
 
-		virtual bool AddConsoleLine(const std::string&amp; msg, int zone);
+		virtual bool AddConsoleLine(const std::string&amp; msg, CLogSubsystem&amp; subsystem);
 
 		virtual bool GroupChanged(int groupID);
 

Modified: branches/caiinterface/rts/System/EventHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/EventHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/EventHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -85,22 +85,22 @@
 	// unsynced call-ins
 	SETUP_EVENT(Update,         MANAGED_BIT | UNSYNCED_BIT);
 
-  SETUP_EVENT(KeyPress,       MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(KeyRelease,     MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(MouseMove,      MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(MousePress,     MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(MouseRelease,   MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(MouseWheel,     MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(IsAbove,        MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(GetTooltip,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(KeyPress,       MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(KeyRelease,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(MouseMove,      MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(MousePress,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(MouseRelease,   MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(MouseWheel,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(IsAbove,        MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(GetTooltip,     MANAGED_BIT | UNSYNCED_BIT);
 
 	SETUP_EVENT(DefaultCommand, MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(CommandNotify,  MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(AddConsoleLine, MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(GroupChanged,   MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(GameSetup,      MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(WorldTooltip,   MANAGED_BIT | UNSYNCED_BIT);
-  SETUP_EVENT(MapDrawCmd,     MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(CommandNotify,  MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(AddConsoleLine, MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(GroupChanged,   MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(GameSetup,      MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(WorldTooltip,   MANAGED_BIT | UNSYNCED_BIT);
+	SETUP_EVENT(MapDrawCmd,     MANAGED_BIT | UNSYNCED_BIT);
 
 	SETUP_EVENT(ViewResize,     MANAGED_BIT | UNSYNCED_BIT);
 
@@ -278,8 +278,8 @@
 	}
 	ecList = newList;
 }
-		
 
+
 /******************************************************************************/
 /******************************************************************************/
 
@@ -289,7 +289,7 @@
 	for (int i = 0; i &lt; count; i++) {
 		CEventClient* ec = listGamePreload[i];
 		ec-&gt;GamePreload();
-	}	
+	}
 }
 
 void CEventHandler::GameStart()
@@ -298,7 +298,7 @@
 	for (int i = 0; i &lt; count; i++) {
 		CEventClient* ec = listGameStart[i];
 		ec-&gt;GameStart();
-	}	
+	}
 }
 
 void CEventHandler::GameOver()
@@ -519,12 +519,12 @@
 }
 
 
-bool CEventHandler::AddConsoleLine(const string&amp; msg, int zone)
+bool CEventHandler::AddConsoleLine(const string&amp; msg, CLogSubsystem&amp; subsystem)
 {
 	const int count = listAddConsoleLine.size();
 	for (int i = 0; i &lt; count; i++) {
 		CEventClient* ec = listAddConsoleLine[i];
-		ec-&gt;AddConsoleLine(msg, zone);
+		ec-&gt;AddConsoleLine(msg, subsystem);
 	}
 	return true;
 }

Modified: branches/caiinterface/rts/System/EventHandler.h
===================================================================
--- branches/caiinterface/rts/System/EventHandler.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/EventHandler.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -18,6 +18,7 @@
 class CFeature;
 class CProjectile;
 struct Command;
+class CLogSubsystem;
 
 
 class CEventHandler
@@ -95,7 +96,7 @@
 
 		void StockpileChanged(const CUnit* unit,
 		                      const CWeapon* weapon, int oldCount);
-	
+
 	public:
 		// Unsynced events
 		void Update();
@@ -113,7 +114,7 @@
 
 		bool CommandNotify(const Command&amp; cmd);
 
-		bool AddConsoleLine(const std::string&amp; msg, int zone);
+		bool AddConsoleLine(const std::string&amp; msg, CLogSubsystem&amp; zone);
 
 		bool GroupChanged(int groupID);
 
@@ -151,7 +152,7 @@
 			UNSYNCED_BIT = (1 &lt;&lt; 1), // delivers unsynced information
 			CONTROL_BIT  = (1 &lt;&lt; 2)  // controls synced information
 		};
-		
+
 		class EventInfo {
 			public:
 				EventInfo() : list(NULL), propBits(0) {}
@@ -163,7 +164,7 @@
 				inline EventClientList* GetList() const { return list; }
 				inline int GetPropBits() const { return propBits; }
 				inline bool HasPropBit(int bit) const { return propBits &amp; bit; }
-				
+
 			private:
 				std::string name;
 				EventClientList* list;

Modified: branches/caiinterface/rts/System/FileSystem/Archive7Zip.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/Archive7Zip.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/Archive7Zip.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,12 +1,12 @@
 #include &quot;StdAfx.h&quot;
-#include &quot;mmgr.h&quot;
 #include &quot;Archive7Zip.h&quot;
-
 #include &lt;algorithm&gt;
+#include &lt;stdexcept&gt;
 #include &lt;string.h&gt;
-
 #include &quot;Util.h&quot;
+#include &quot;mmgr.h&quot;
 
+
 // Most of this code is taken from 7zMain.c
 
 SZ_RESULT SzFileReadImp(void *object, void *buffer, size_t size, size_t *processedSize)
@@ -96,7 +96,7 @@
 
 	// Figure out the file index
 	std::string fileName = StringToLower(fName);
-	
+
 	if (fileData.find(fileName) == fileData.end())
 		return NULL;
 
@@ -105,13 +105,13 @@
 	// Get 7zip to decompress it
 	size_t offset;
 	size_t outSizeProcessed;
-	
+
 	SZ_RESULT res;
 
 	// We don't really support solid archives anyway, so these can be reset for each file
-	UInt32 blockIndex = 0xFFFFFFFF; // it can have any value before first call (if outBuffer = 0) 
-	Byte *outBuffer = 0; // it must be 0 before first call for each new archive. 
-	size_t outBufferSize = 0;  // it can have any value before first call (if outBuffer = 0) 
+	UInt32 blockIndex = 0xFFFFFFFF; // it can have any value before first call (if outBuffer = 0)
+	Byte *outBuffer = 0; // it must be 0 before first call for each new archive.
+	size_t outBufferSize = 0;  // it can have any value before first call (if outBuffer = 0)
 
 	res = SzExtract(&amp;archiveStream.InStream, &amp;db, fd.fp, &amp;blockIndex, &amp;outBuffer, &amp;outBufferSize, &amp;offset, &amp;outSizeProcessed, &amp;allocImp, &amp;allocTempImp);
 
@@ -120,7 +120,7 @@
 		of = SAFE_NEW ABOpenFile_t;
 		of-&gt;pos = 0;
 		of-&gt;size = outSizeProcessed;
-		of-&gt;data = (char*)malloc(of-&gt;size); 
+		of-&gt;data = (char*)malloc(of-&gt;size);
 
 		memcpy(of-&gt;data, outBuffer + offset, outSizeProcessed);
 	}
@@ -149,6 +149,9 @@
 		searchHandles[cur] = fileData.begin();
 	}
 
+	if (searchHandles.find(cur) == searchHandles.end())
+		throw std::runtime_error(&quot;Unregistered handle. Pass a handle returned by CArchive7Zip::FindFiles.&quot;);
+
 	if (searchHandles[cur] == fileData.end()) {
 		searchHandles.erase(cur);
 		return 0;

Modified: branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,11 +1,21 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;ArchiveBuffered.h&quot;
+#include &lt;stdexcept&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
 #include &quot;mmgr.h&quot;
 
-#include &quot;ArchiveBuffered.h&quot;
 
-#include &lt;string.h&gt;
-#include &lt;cstdlib&gt;
+inline ABOpenFile_t* CArchiveBuffered::GetOpenFile(int handle)
+{
+	std::map&lt;int, ABOpenFile_t*&gt;::iterator it = fileHandles.find(handle);
 
+	if (it == fileHandles.end())
+		throw std::runtime_error(&quot;Unregistered handle. Pass a handle returned by CArchiveBuffered::OpenFile.&quot;);
+
+	return it-&gt;second;
+}
+
 CArchiveBuffered::CArchiveBuffered(const std::string&amp; name):
 	CArchiveBase(name),
 	curFileHandle(1)
@@ -34,7 +44,7 @@
 
 int CArchiveBuffered::ReadFile(int handle, void* buffer, int numBytes)
 {
-	ABOpenFile_t* of = fileHandles[handle];
+	ABOpenFile_t* of = GetOpenFile(handle);
 
 	int maxRead = std::min(numBytes, of-&gt;size - of-&gt;pos);
 	memcpy(buffer, of-&gt;data + of-&gt;pos, maxRead);
@@ -45,20 +55,22 @@
 
 void CArchiveBuffered::CloseFile(int handle)
 {
-	free(fileHandles[handle]-&gt;data);
-	delete fileHandles[handle];
+	ABOpenFile_t* of = GetOpenFile(handle);
+
+	free(of-&gt;data);
+	delete of;
 	fileHandles.erase(handle);
 }
 
 void CArchiveBuffered::Seek(int handle, int pos)
 {
-	ABOpenFile_t* of = fileHandles[handle];
+	ABOpenFile_t* of = GetOpenFile(handle);
 	of-&gt;pos = std::min(pos, of-&gt;size);
 }
 
 int CArchiveBuffered::Peek(int handle)
 {
-	ABOpenFile_t* of = fileHandles[handle];
+	ABOpenFile_t* of = GetOpenFile(handle);
 	if (of-&gt;pos &gt;= of-&gt;size)
 		return -1;
 	return of-&gt;data[of-&gt;pos];
@@ -66,11 +78,12 @@
 
 bool CArchiveBuffered::Eof(int handle)
 {
-	ABOpenFile_t* of = fileHandles[handle];
+	ABOpenFile_t* of = GetOpenFile(handle);
 	return (of-&gt;pos &gt;= of-&gt;size);
 }
 
 int CArchiveBuffered::FileSize(int handle)
 {
-	return fileHandles[handle]-&gt;size;
+	ABOpenFile_t* of = GetOpenFile(handle);
+	return of-&gt;size;
 }

Modified: branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.h
===================================================================
--- branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/ArchiveBuffered.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,6 +19,7 @@
 	int curFileHandle;
 	std::map&lt;int, ABOpenFile_t*&gt; fileHandles;
 	virtual ABOpenFile_t* GetEntireFile(const std::string&amp; fileName) = 0;
+	ABOpenFile_t* GetOpenFile(int handle);
 public:
 	CArchiveBuffered(const std::string&amp; name);
 	virtual ~CArchiveBuffered(void);

Modified: branches/caiinterface/rts/System/FileSystem/ArchiveDir.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/ArchiveDir.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/ArchiveDir.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,18 +1,21 @@
 /* Author: Tobi Vollebregt */
 
 #include &quot;StdAfx.h&quot;
+#include &quot;ArchiveDir.h&quot;
 #include &lt;assert.h&gt;
+#include &lt;stdexcept&gt;
+#include &quot;Platform/FileSystem.h&quot;
+#include &quot;Util.h&quot;
 #include &quot;mmgr.h&quot;
 
-#include &quot;ArchiveDir.h&quot;
-#include &quot;Platform/FileSystem.h&quot;
 
-#include &quot;Util.h&quot;
-
 inline CFileHandler* CArchiveDir::GetFileHandler(int handle)
 {
 	std::map&lt;int, CFileHandler*&gt;::iterator it = fileHandles.find(handle);
-	assert(it != fileHandles.end());
+
+	if (it == fileHandles.end())
+		throw std::runtime_error(&quot;Unregistered handle. Pass a handle returned by CArchiveDir::OpenFile.&quot;);
+
 	return it-&gt;second;
 }
 
@@ -20,7 +23,10 @@
 inline std::vector&lt;std::string&gt;::iterator&amp; CArchiveDir::GetSearchHandle(int handle)
 {
 	std::map&lt;int, std::vector&lt;std::string&gt;::iterator&gt;::iterator it = searchHandles.find(handle);
-	assert(it != searchHandles.end());
+
+	if (it == searchHandles.end())
+		throw std::runtime_error(&quot;Unregistered handle. Pass a handle returned by CArchiveDir::FindFiles.&quot;);
+
 	return it-&gt;second;
 }
 

Modified: branches/caiinterface/rts/System/FileSystem/ArchiveHPI.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/ArchiveHPI.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/ArchiveHPI.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,12 +1,12 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;ArchiveHPI.h&quot;
 #include &lt;algorithm&gt;
+#include &lt;stdexcept&gt;
+#include &quot;Util.h&quot;
 #include &quot;mmgr.h&quot;
+using namespace hpiutil;
 
-#include &quot;ArchiveHPI.h&quot;
 
-#include &quot;Util.h&quot;
-using namespace hpiutil;
-
 CArchiveHPI::CArchiveHPI(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1)
@@ -67,6 +67,9 @@
 		searchHandles[cur] = fileSizes.begin();
 	}
 
+	if (searchHandles.find(cur) == searchHandles.end())
+		throw std::runtime_error(&quot;Unregistered handle. Pass a handle returned by CArchiveHPI::FindFiles.&quot;);
+
 	if (searchHandles[cur] == fileSizes.end()) {
 		searchHandles.erase(cur);
 		return 0;

Modified: branches/caiinterface/rts/System/FileSystem/ArchiveZip.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/ArchiveZip.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/ArchiveZip.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,11 +1,11 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;ArchiveZip.h&quot;
 #include &lt;algorithm&gt;
+#include &lt;stdexcept&gt;
+#include &quot;Util.h&quot;
 #include &quot;mmgr.h&quot;
 
-#include &quot;ArchiveZip.h&quot;
 
-#include &quot;Util.h&quot;
-
 CArchiveZip::CArchiveZip(const std::string&amp; name):
 	CArchiveBuffered(name),
 	curSearchHandle(1)
@@ -75,7 +75,7 @@
 
 	std::string fileName = StringToLower(fName);
 
-	//if (unzLocateFile(zip, fileName.c_str(), 2) != UNZ_OK) 
+	//if (unzLocateFile(zip, fileName.c_str(), 2) != UNZ_OK)
 	//	return 0;
 
 	if (fileData.find(fileName) == fileData.end())
@@ -90,16 +90,16 @@
 	ABOpenFile_t* of = SAFE_NEW ABOpenFile_t;
 	of-&gt;pos = 0;
 	of-&gt;size = fi.uncompressed_size;
-	of-&gt;data = (char*)malloc(of-&gt;size); 
+	of-&gt;data = (char*)malloc(of-&gt;size);
 
 	// If anything fails, we abort
 	try {
 		if (unzOpenCurrentFile(zip) != UNZ_OK)
 			throw zip_exception();
-		if (unzReadCurrentFile(zip, of-&gt;data, of-&gt;size) &lt; 0) 
+		if (unzReadCurrentFile(zip, of-&gt;data, of-&gt;size) &lt; 0)
 			throw zip_exception();
 		if (unzCloseCurrentFile(zip) == UNZ_CRCERROR)
-			throw zip_exception(); 
+			throw zip_exception();
 	}
 	catch (zip_exception) {
 		free(of-&gt;data);
@@ -118,6 +118,9 @@
 		searchHandles[cur] = fileData.begin();
 	}
 
+	if (searchHandles.find(cur) == searchHandles.end())
+		throw std::runtime_error(&quot;Unregistered handle. Pass a handle returned by CArchiveZip::FindFiles.&quot;);
+
 	if (searchHandles[cur] == fileData.end()) {
 		searchHandles.erase(cur);
 		return 0;

Modified: branches/caiinterface/rts/System/FileSystem/FileHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/FileHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/FileHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,4 +1,5 @@
 #include &quot;StdAfx.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
 #include &lt;fstream&gt;
 #include &lt;algorithm&gt;
 #include &lt;cctype&gt;
@@ -21,6 +22,8 @@
 CFileHandler::CFileHandler(const char* filename, const char* modes)
 : ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	Init(filename, modes);
 }
 
@@ -28,12 +31,16 @@
 CFileHandler::CFileHandler(const string&amp; filename, const string&amp; modes)
 : ifs(NULL), hpiFileBuffer(NULL), hpiOffset(0), filesize(-1)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	Init(filename, modes);
 }
 
 
 CFileHandler::~CFileHandler(void)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		delete ifs;
 	}
@@ -120,6 +127,8 @@
 
 int CFileHandler::Read(void* buf,int length)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		ifs-&gt;read((char*)buf, length);
 		return ifs-&gt;gcount ();
@@ -141,6 +150,8 @@
 
 void CFileHandler::Seek(int length)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		ifs-&gt;seekg(length);
 	} else if (hpiFileBuffer){
@@ -151,6 +162,8 @@
 
 int CFileHandler::Peek() const
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		return ifs-&gt;peek();
 	}
@@ -167,6 +180,8 @@
 
 bool CFileHandler::Eof() const
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		return ifs-&gt;eof();
 	}
@@ -185,6 +200,8 @@
 
 int CFileHandler::GetPos() const
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (ifs) {
 		return ifs-&gt;tellg();
 	} else {
@@ -195,6 +212,8 @@
 
 bool CFileHandler::LoadStringData(string&amp; data)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	if (!FileExists()) {
 		return false;
 	}
@@ -211,6 +230,8 @@
 vector&lt;string&gt; CFileHandler::FindFiles(const string&amp; path,
                                        const string&amp; pattern)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	vector&lt;string&gt; found = filesystem.FindFiles(path, pattern);
 	boost::regex regexpattern(filesystem.glob_to_regex(pattern),
 	                          boost::regex::icase);
@@ -235,6 +256,8 @@
                                      const string&amp; pattern,
                                      const string&amp; modes)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	const string pat = pattern.empty() ? &quot;*&quot; : pattern;
 
 	set&lt;string&gt; fileSet;
@@ -323,6 +346,8 @@
                                      const string&amp; pattern,
                                      const string&amp; modes)
 {
+	GML_RECMUTEX_LOCK(file);
+
 	const string pat = pattern.empty() ? &quot;*&quot; : pattern;
 
 	set&lt;string&gt; dirSet;

Modified: branches/caiinterface/rts/System/FileSystem/VFSHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/FileSystem/VFSHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/FileSystem/VFSHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -7,26 +7,35 @@
 #include &quot;ArchiveFactory.h&quot;
 #include &quot;ArchiveBase.h&quot;
 #include &quot;ArchiveDir.h&quot; // for FileData::dynamic
+#include &quot;LogOutput.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;Util.h&quot;
 
 
+static CLogSubsystem LOG_VFS(&quot;VFS&quot;);
+static CLogSubsystem LOG_VFS_DETAIL(&quot;VFS-detail&quot;);
+
+
 CVFSHandler* vfsHandler = NULL;
 
 
 CVFSHandler::CVFSHandler()
 {
+	logOutput.Print(LOG_VFS, &quot;CVFSHandler::CVFSHandler()&quot;);
 }
 
 
 // Override determines whether if conflicts overwrites an existing entry in the virtual filesystem or not
-bool CVFSHandler::AddArchive(const std::string&amp; arName, bool override,
-                             const std::string&amp; type)
+bool CVFSHandler::AddArchive(const std::string&amp; arName, bool override, const std::string&amp; type)
 {
+	logOutput.Print(LOG_VFS, &quot;AddArchive(arName = \&quot;%s\&quot;, override = %s, type = \&quot;%s\&quot;)&quot;,
+	                arName.c_str(), override ? &quot;true&quot; : &quot;false&quot;, type.c_str());
+
 	CArchiveBase* ar = archives[arName];
 	if (!ar) {
 		ar = CArchiveFactory::OpenArchive(arName, type);
 		if (!ar) {
+			logOutput.Print(LOG_VFS, &quot;AddArchive: Failed to open archive '%s'.&quot;, arName.c_str());
 			return false;
 		}
 		archives[arName] = ar;
@@ -38,9 +47,17 @@
 
 	for (cur = ar-&gt;FindFiles(0, &amp;name, &amp;size); cur != 0; cur = ar-&gt;FindFiles(cur, &amp;name, &amp;size)) {
 		StringToLowerInPlace(name);
-		if ((!override) &amp;&amp; (files.find(name) != files.end())) {
-			continue;
+
+		if (!override) {
+			if (files.find(name) != files.end()) {
+				logOutput.Print(LOG_VFS_DETAIL, &quot;%s (skipping, exists)&quot;, name.c_str());
+				continue;
+			}
+			else
+				logOutput.Print(LOG_VFS_DETAIL, &quot;%s (adding, doesn't exist)&quot;, name.c_str());
 		}
+		else
+			logOutput.Print(LOG_VFS_DETAIL, &quot;%s (overriding)&quot;, name.c_str());
 
 		FileData d;
 		d.ar = ar;
@@ -52,8 +69,10 @@
 }
 
 
-CVFSHandler::~CVFSHandler(void)
+CVFSHandler::~CVFSHandler()
 {
+	logOutput.Print(LOG_VFS, &quot;CVFSHandler::~CVFSHandler()&quot;);
+
 	for (std::map&lt;std::string, CArchiveBase*&gt;::iterator i = archives.begin(); i != archives.end(); ++i) {
 		delete i-&gt;second;
 	}
@@ -62,17 +81,21 @@
 
 int CVFSHandler::LoadFile(const std::string&amp; rawName, void* buffer)
 {
+	logOutput.Print(LOG_VFS, &quot;LoadFile(rawName = \&quot;%s\&quot;, )&quot;, rawName.c_str());
+
 	std::string name = StringToLower(rawName);
 	filesystem.ForwardSlashes(name);
 
 	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
 	if (fi == files.end()) {
+		logOutput.Print(LOG_VFS, &quot;LoadFile: File '%s' does not exist in VFS.&quot;, rawName.c_str());
 		return -1;
 	}
 	FileData&amp; fd = fi-&gt;second;
 
 	int fh = fd.ar-&gt;OpenFile(name);
 	if (!fh) {
+		logOutput.Print(LOG_VFS, &quot;LoadFile: File '%s' does not exist in archive.&quot;, rawName.c_str());
 		return -1;
 	}
 	const int fsize = fd.dynamic ? fd.ar-&gt;FileSize(fh) : fd.size;
@@ -86,13 +109,17 @@
 
 int CVFSHandler::GetFileSize(const std::string&amp; rawName)
 {
+	logOutput.Print(LOG_VFS, &quot;GetFileSize(rawName = \&quot;%s\&quot;)&quot;, rawName.c_str());
+
 	std::string name = StringToLower(rawName);
 	filesystem.ForwardSlashes(name);
 
 	std::map&lt;std::string, FileData&gt;::iterator fi = files.find(name);
 	if (fi == files.end()) {
+		logOutput.Print(LOG_VFS, &quot;GetFileSize: File '%s' does not exist in VFS.&quot;, rawName.c_str());
 		return -1;
 	}
+
 	FileData&amp; fd = fi-&gt;second;
 
 	if (!fd.dynamic) {
@@ -101,6 +128,7 @@
 	else {
 		const int fh = fd.ar-&gt;OpenFile(name);
 		if (fh == 0) {
+			logOutput.Print(LOG_VFS, &quot;GetFileSize: File '%s' does not exist in archive.&quot;, rawName.c_str());
 			return -1;
 		} else {
 			const int fsize = fd.ar-&gt;FileSize(fh);
@@ -108,13 +136,14 @@
 			return fsize;
 		}
 	}
-	return -1;
 }
 
 
 // Returns all the files in the given (virtual) directory without the preceeding pathname
 std::vector&lt;std::string&gt; CVFSHandler::GetFilesInDir(const std::string&amp; rawDir)
 {
+	logOutput.Print(LOG_VFS, &quot;GetFilesInDir(rawDir = \&quot;%s\&quot;)&quot;, rawDir.c_str());
+
 	std::vector&lt;std::string&gt; ret;
 	std::string dir = StringToLower(rawDir);
 	filesystem.ForwardSlashes(dir);
@@ -149,6 +178,7 @@
 			if ((name.find('/') == std::string::npos) &amp;&amp;
 			    (name.find('\\') == std::string::npos)) {
 				ret.push_back(name);
+				logOutput.Print(LOG_VFS_DETAIL, &quot;%s&quot;, name.c_str());
 			}
 		}
 		filesStart++;
@@ -161,6 +191,8 @@
 // Returns all the sub-directories in the given (virtual) directory without the preceeding pathname
 std::vector&lt;std::string&gt; CVFSHandler::GetDirsInDir(const std::string&amp; rawDir)
 {
+	logOutput.Print(LOG_VFS, &quot;GetDirsInDir(rawDir = \&quot;%s\&quot;)&quot;, rawDir.c_str());
+
 	std::vector&lt;std::string&gt; ret;
 	std::string dir = StringToLower(rawDir);
 	filesystem.ForwardSlashes(dir);
@@ -200,6 +232,7 @@
 
 	for (std::set&lt;std::string&gt;::const_iterator it = dirs.begin(); it != dirs.end(); ++it) {
 		ret.push_back(*it);
+		logOutput.Print(LOG_VFS_DETAIL, &quot;%s&quot;, it-&gt;c_str());
 	}
 
 	return ret;

Modified: branches/caiinterface/rts/System/GlobalUnsynced.cpp
===================================================================
--- branches/caiinterface/rts/System/GlobalUnsynced.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/GlobalUnsynced.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -140,18 +140,20 @@
 	return ret;
 }
 
-void CGlobalUnsyncedStuff::LoadFromSetup(const CGameSetup* setup)
+void CGlobalUnsyncedStuff::SetMyPlayer(const int mynumber)
 {
-	myPlayerNum = setup-&gt;myPlayerNum;
-	myTeam = setup-&gt;playerStartingData[myPlayerNum].team;
-	myAllyTeam = setup-&gt;teamStartingData[myTeam].teamAllyteam;
-
-	spectating = setup-&gt;playerStartingData[myPlayerNum].spectator;
-	spectatingFullView   = setup-&gt;playerStartingData[myPlayerNum].spectator;
-	spectatingFullSelect = setup-&gt;playerStartingData[myPlayerNum].spectator;
+	myPlayerNum = mynumber;
+	if (gameSetup &amp;&amp; gameSetup-&gt;numPlayers &lt; mynumber)
+	{
+		myTeam = gameSetup-&gt;playerStartingData[myPlayerNum].team;
+		myAllyTeam = gameSetup-&gt;teamStartingData[myTeam].teamAllyteam;
 	
-	assert(myPlayerNum &gt;= 0 &amp;&amp; myPlayerNum &lt; MAX_PLAYERS &amp;&amp;
-			setup-&gt;playerStartingData.size() &gt;= myPlayerNum &amp;&amp;
-			setup-&gt;teamStartingData.size() &gt;= myTeam);
+		spectating = gameSetup-&gt;playerStartingData[myPlayerNum].spectator;
+		spectatingFullView   = gameSetup-&gt;playerStartingData[myPlayerNum].spectator;
+		spectatingFullSelect = gameSetup-&gt;playerStartingData[myPlayerNum].spectator;
+		
+		assert(myPlayerNum &gt;= 0 &amp;&amp; myPlayerNum &lt; MAX_PLAYERS &amp;&amp;
+				gameSetup-&gt;playerStartingData.size() &gt;= myPlayerNum &amp;&amp;
+				gameSetup-&gt;teamStartingData.size() &gt;= myTeam);
+	}
 }
-

Modified: branches/caiinterface/rts/System/GlobalUnsynced.h
===================================================================
--- branches/caiinterface/rts/System/GlobalUnsynced.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/GlobalUnsynced.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -33,7 +33,7 @@
 	float  usRandFloat();  //!&lt; Unsynced random float
 	float3 usRandVector(); //!&lt; Unsynced random vector
 
-	void LoadFromSetup(const CGameSetup*);
+	void SetMyPlayer(const int mynumber);
 
 	/**
 	 * Does the user want team colored nanospray if the mod allows it?
@@ -63,6 +63,12 @@
 	 */
 	float lastFrameTime;
 
+	// the starting time in tick for last draw frame
+	unsigned lastFrameStart;
+
+	// 0.001f * GAME_SPEED * gs-&gt;speedFactor, used for rendering
+	float weightedSpeedFactor;
+
 	// the draw frame number (never 0)
 	unsigned int drawFrame;
 

Modified: branches/caiinterface/rts/System/LogOutput.cpp
===================================================================
--- branches/caiinterface/rts/System/LogOutput.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/LogOutput.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -3,7 +3,6 @@
 #include &quot;LogOutput.h&quot;
 
 #include &lt;assert.h&gt;
-#include &lt;cstdarg&gt;
 #include &lt;fstream&gt;
 #include &lt;string.h&gt;
 #include &lt;boost/thread/recursive_mutex.hpp&gt;
@@ -12,31 +11,78 @@
 #include &lt;windows.h&gt;
 #endif
 
-#include &quot;mmgr.h&quot;
 #include &quot;Util.h&quot;
 #include &quot;float3.h&quot;
-#if !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
+//#if !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 #include &quot;Game/GlobalSynced.h&quot;
-#endif	/* !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
+//#endif	// !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
+#include &quot;Platform/ConfigHandler.h&quot;
+#include &quot;mmgr.h&quot;
 
+using std::string;
+using std::vector;
 
-#if defined BUILDING_AI_INTERFACE
-#define LOG_FILE_PREFIX &quot;infolog_aiinterface&quot;
-#else
-#define LOG_FILE_PREFIX &quot;infolog&quot;
-#endif
-#define LOG_FILE_SUFFIX &quot;.txt&quot;
-//static std::ofstream* filelog = 0;
-//static bool initialized = false;
-static int infologIndex = 0;
-#define FILE_LOG filelog
+//#if defined BUILDING_AI_INTERFACE
+//#define LOG_FILE_PREFIX &quot;infolog_aiinterface&quot;
+//#else
+//#define LOG_FILE_PREFIX &quot;infolog&quot;
+//#endif
+//#define LOG_FILE_SUFFIX &quot;.txt&quot;
+////static std::ofstream* filelog = 0;
+////static bool initialized = false;
+//static int infologIndex = 0;
+//#define FILE_LOG filelog
+
+/******************************************************************************/
+/******************************************************************************/
+
+CLogSubsystem* CLogSubsystem::linkedList;
+static CLogSubsystem LOG_DEFAULT(&quot;&quot;, true);
+
+
+CLogSubsystem::CLogSubsystem(const char* name, bool enabled)
+: name(name), next(linkedList), enabled(enabled)
+{
+	linkedList = this;
+}
+
+/******************************************************************************/
+/******************************************************************************/
+
+//CLogOutput logOutput;
+
+namespace
+{
+	struct PreInitLogEntry
+	{
+		PreInitLogEntry(CLogSubsystem* subsystem, string text)
+			: subsystem(subsystem), text(text) {}
+
+		CLogSubsystem* subsystem;
+		string text;
+	};
+}
+
+// wrapped in a function to prevent order of initialization problems
+// when logOutput is used before main() is entered.
+static vector&lt;PreInitLogEntry&gt;&amp; preInitLog()
+{
+	static vector&lt;PreInitLogEntry&gt; preInitLog;
+	return preInitLog;
+}
+
+static vector&lt;ILogSubscriber*&gt; subscribers;
+static const char* filename = &quot;infolog.txt&quot;;
+static std::ofstream* filelog = 0;
+static bool initialized = false;
 static bool stdoutDebug = false;
 CLogOutput&amp; logOutput = CLogOutput::GetInstance();
 static boost::recursive_mutex tempstrMutex;
-static std::string tempstr;
+static string tempstr;
 
-static const int bufferSize = 2048;
+static const int BUFFER_SIZE = 2048;
 
+
 CLogOutput CLogOutput::myLogOutput = CLogOutput();
 //std::ofstream* CLogOutput::filelog = NULL;
 
@@ -46,37 +92,145 @@
 
 CLogOutput::CLogOutput()
 {
+	// multiple infologs can't exist together!
 	assert(this == &amp;logOutput);
-	FILE_LOG = NULL;
-	//assert(!(FILE_LOG)); // multiple infologs can't exist together!
+//	FILE_LOG = NULL;
+//	assert(!(FILE_LOG)); // multiple infologs can't exist together!
+	assert(!filelog);
 }
 
+
 CLogOutput::~CLogOutput()
 {
 	End();
 }
 
+
 void CLogOutput::End()
 {
-	delete FILE_LOG;
-	FILE_LOG = 0;
+//	delete FILE_LOG;
+//	FILE_LOG = 0;
+	SafeDelete(filelog);
 }
 
+
 void CLogOutput::SetMirrorToStdout(bool value)
 {
 	stdoutDebug = value;
 }
 
-void CLogOutput::Output(int zone, const char *str)
+
+void CLogOutput::SetFilename(const char* fname)
 {
+	assert(!initialized);
+	filename = fname;
+}
+
+
+/**
+ * @brief initialize logOutput
+ *
+ * Only after calling this method, logOutput starts writing to disk.
+ * The log file is written in the current directory so this may only be called
+ * after the engine chdir'ed to the correct directory.
+ */
+void CLogOutput::Initialize()
+{
+	if (initialized) return;
+
+	filelog = new std::ofstream(filename);
+	if (filelog-&gt;bad())
+		SafeDelete(filelog);
+
+	initialized = true;
+	(*this) &lt;&lt; &quot;LogOutput initialized.\n&quot;;
+
+	InitializeSubsystems();
+
+	for (vector&lt;PreInitLogEntry&gt;::iterator it = preInitLog().begin(); it != preInitLog().end(); ++it)
+		Output(*it-&gt;subsystem, it-&gt;text.c_str());
+	preInitLog().clear();
+}
+
+
+/**
+ * @brief initialize the log subsystems
+ *
+ * This writes list of all available and all enabled subsystems to the log.
+ *
+ * Log subsystems can be enabled using the configuration key &quot;LogSubsystems&quot;,
+ * or the environment variable &quot;SPRING_LOG_SUBSYSTEMS&quot;.
+ *
+ * Both specify a comma separated list of subsystems that should be enabled.
+ * The lists from both sources are combined, there is no overriding.
+ *
+ * A subsystem that is by default enabled, can not be disabled.
+ */
+void CLogOutput::InitializeSubsystems()
+{
+	(*this) &lt;&lt; &quot;Available log subsystems: &quot;;
+	for (CLogSubsystem* sys = CLogSubsystem::GetList(); sys; sys = sys-&gt;next) {
+		if (sys-&gt;name &amp;&amp; *sys-&gt;name) {
+			(*this) &lt;&lt; sys-&gt;name;
+			if (sys-&gt;next)
+				(*this) &lt;&lt; &quot;, &quot;;
+		}
+	}
+	(*this) &lt;&lt; &quot;\n&quot;;
+
+	// enabled subsystems is superset of the ones specified in environment
+	// and the ones specified in the configuration file.
+	string subsystems = &quot;,&quot; + StringToLower(configHandler.GetString(&quot;LogSubsystems&quot;, &quot;&quot;)) + &quot;,&quot;;
+
+	const char* const env = getenv(&quot;SPRING_LOG_SUBSYSTEMS&quot;);
+	if (env)
+		subsystems += StringToLower(env) + &quot;,&quot;;
+
+	(*this) &lt;&lt; &quot;Enabled log subsystems: &quot;;
+	for (CLogSubsystem* sys = CLogSubsystem::GetList(); sys; sys = sys-&gt;next) {
+		if (sys-&gt;name &amp;&amp; *sys-&gt;name) {
+			const string name = StringToLower(sys-&gt;name);
+			const string::size_type index = subsystems.find(&quot;,&quot; + name + &quot;,&quot;);
+
+			// log subsystems which are enabled by default can not be disabled
+			// (&quot;enabled by default&quot; wouldn't make sense otherwise...)
+			if (!sys-&gt;enabled &amp;&amp; index != string::npos)
+				sys-&gt;enabled = true;
+
+			if (sys-&gt;enabled) {
+				(*this) &lt;&lt; sys-&gt;name;
+				if (sys-&gt;next)
+					(*this) &lt;&lt; &quot;, &quot;;
+			}
+		}
+	}
+	(*this) &lt;&lt; &quot;\n&quot;;
+
+	(*this) &lt;&lt; &quot;Enable or disable log subsystems using the LogSubsystems configuration key\n&quot;;
+	(*this) &lt;&lt; &quot;  or the SPRING_LOG_SUBSYSTEMS environment variable (both comma separated).\n&quot;;
+}
+
+
+/**
+ * @brief core log output method, used by all others
+ *
+ * Note that, when logOutput isn't initialized yet, the logging is done to the
+ * global std::vector preInitLog(), and is only written to disk in the call to
+ * Initialize().
+ *
+ * This method notifies all registered ILogSubscribers, calls OutputDebugString
+ * (for MSVC builds) and prints the message to stdout and the file log.
+ */
+void CLogOutput::Output(CLogSubsystem&amp; subsystem, const char* str)
+{
 /*
 	if (!INITIALIZED) {
 		FILE_LOG = new std::ofstream(LOG_FILE_NAME);
 		INITIALIZED = true;
 	}
 */
-	#if !defined BUILDING_AI_INTERFACE
-	if (FILE_LOG == NULL) {
+#if !defined BUILDING_AI_INTERFACE
+/*	if (FILE_LOG == NULL) {
 		#if defined BUILDING_AI_INTERFACE
 		const int MAX_STR_LENGTH = 511;
 		char logFileName[MAX_STR_LENGTH + 1];
@@ -85,111 +239,144 @@
 		const char* logFileName = &quot;infolog.txt&quot;;
 		#endif
 		FILE_LOG = new std::ofstream(logFileName);
+	}*/
+	if (!initialized) {
+		preInitLog().push_back(PreInitLogEntry(&amp;subsystem, str));
+		return;
 	}
 
+	if (!subsystem.enabled) return;
+
 	// Output to subscribers
 #if !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
-	for(std::vector&lt;ILogSubscriber*&gt;::iterator lsi=subscribers.begin(); lsi!=subscribers.end();++lsi)
-		(*lsi)-&gt;NotifyLogMsg(zone, str);
-#endif	/* !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
+	for(vector&lt;ILogSubscriber*&gt;::iterator lsi = subscribers.begin(); lsi != subscribers.end(); ++lsi)
+		(*lsi)-&gt;NotifyLogMsg(subsystem, str);
+#endif	// !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 
-	int nl = strlen(str) - 1;
+	int index = strlen(str) - 1;
+	bool newline = ((index &lt; 0) || (str[index] != '\n'));
 
 #ifdef _MSC_VER
 	OutputDebugString(str);
-	if (nl &lt; 0 || str[nl] != '\n')
+	if (newline)
 		OutputDebugString(&quot;\n&quot;);
 #endif
 
-	if (FILE_LOG) {
+//	if (FILE_LOG) {
+	if (filelog) {
 #if !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE
 		if (gs) {
-			(*FILE_LOG) &lt;&lt; IntToString(gs-&gt;frameNum, &quot;[%7d] &quot;);
+			(*filelog) &lt;&lt; IntToString(gs-&gt;frameNum, &quot;[%7d] &quot;);
+//			(*FILE_LOG) &lt;&lt; IntToString(gs-&gt;frameNum, &quot;[%7d] &quot;);
 		}
 #endif	/* !defined DEDICATED &amp;&amp; !defined BUILDING_AI &amp;&amp; !defined BUILDING_AI_INTERFACE */
-		(*FILE_LOG) &lt;&lt; str;
-		if (nl &lt; 0 || str[nl] != '\n')
-			(*FILE_LOG) &lt;&lt; &quot;\n&quot;;
-		FILE_LOG-&gt;flush();
+//		(*FILE_LOG) &lt;&lt; str;
+//		if (newline)
+//			(*FILE_LOG) &lt;&lt; &quot;\n&quot;;
+//		FILE_LOG-&gt;flush();
+		if (subsystem.name &amp;&amp; *subsystem.name)
+			(*filelog) &lt;&lt; subsystem.name &lt;&lt; &quot;: &quot;;
+		(*filelog) &lt;&lt; str;
+		if (newline)
+			(*filelog) &lt;&lt; &quot;\n&quot;;
+		filelog-&gt;flush();
 	}
 
 	if (stdoutDebug) {
+		if (subsystem.name &amp;&amp; *subsystem.name) {
+			fputs(subsystem.name, stdout);
+			fputs(&quot;: &quot;, stdout);
+		}
 		fputs(str, stdout);
-		if (nl &lt; 0 || str[nl] != '\n') {
+		if (newline)
 			putchar('\n');
-		}
 		fflush(stdout);
 	}
-	#endif	/* !defined BUILDING_AI_INTERFACE */
+#endif	// !defined BUILDING_AI_INTERFACE
 }
 
+
 void CLogOutput::SetLastMsgPos(const float3&amp; pos)
 {
-	for(std::vector&lt;ILogSubscriber*&gt;::iterator lsi=subscribers.begin();lsi!=subscribers.end();++lsi)
+	for(vector&lt;ILogSubscriber*&gt;::iterator lsi = subscribers.begin(); lsi != subscribers.end(); ++lsi)
 		(*lsi)-&gt;SetLastMsgPos(pos);
 }
 
+
 void CLogOutput::AddSubscriber(ILogSubscriber* ls)
 {
 	subscribers.push_back(ls);
 }
 
+
 void CLogOutput::RemoveAllSubscribers()
 {
 	subscribers.clear();
 }
 
+
 void CLogOutput::RemoveSubscriber(ILogSubscriber *ls)
 {
-	subscribers.erase(std::find(subscribers.begin(),subscribers.end(),ls));
+	subscribers.erase(std::find(subscribers.begin(), subscribers.end(), ls));
 }
 
+
 // ----------------------------------------------------------------------
 // Printing functions
 // ----------------------------------------------------------------------
 
-void CLogOutput::Print(int zone, const char *fmt, ...)
+
+void CLogOutput::Print(CLogSubsystem&amp; subsystem, const char* fmt, ...)
 {
+	// if logOutput isn't initialized then subsystem.enabled still has it's default value
+	if (initialized &amp;&amp; !subsystem.enabled) return;
+
 	va_list argp;
 
 	va_start(argp, fmt);
-	Printv(zone, fmt, argp);
+	Printv(subsystem, fmt, argp);
 	va_end(argp);
 }
 
-void CLogOutput::Printv(int zone, const char *fmt, va_list argp)
+
+void CLogOutput::Printv(CLogSubsystem&amp; subsystem, const char* fmt, va_list argp)
 {
-	char text[bufferSize];
+	// if logOutput isn't initialized then subsystem.enabled still has it's default value
+	if (initialized &amp;&amp; !subsystem.enabled) return;
 
+	char text[BUFFER_SIZE];
+
 	VSNPRINTF(text, sizeof(text), fmt, argp);
-	Output(zone, text);
+	Output(subsystem, text);
 }
 
-void CLogOutput::Print(const char *fmt, ...)
+
+void CLogOutput::Print(const char* fmt, ...)
 {
 	va_list argp;
 
 	va_start(argp, fmt);
-	Printv(0, fmt, argp);
+	Printv(LOG_DEFAULT, fmt, argp);
 	va_end(argp);
 }
 
+
 void CLogOutput::Print(const std::string&amp; text)
 {
-	Output(0, text.c_str());
+	Output(LOG_DEFAULT, text.c_str());
 }
 
 
-void CLogOutput::Print(int zone, const std::string&amp; text)
+void CLogOutput::Print(CLogSubsystem&amp; subsystem, const std::string&amp; text)
 {
-	Output(zone, text.c_str());
+	Output(subsystem, text.c_str());
 }
 
 
 CLogOutput&amp; CLogOutput::operator&lt;&lt; (const int i)
 {
 	char t[50];
-	sprintf(t,&quot;%d &quot;,i);
+	sprintf(t, &quot;%d &quot;, i);
 	boost::recursive_mutex::scoped_lock scoped_lock(tempstrMutex);
 	tempstr += t;
 	return *this;
@@ -199,7 +386,7 @@
 CLogOutput&amp; CLogOutput::operator&lt;&lt; (const float f)
 {
 	char t[50];
-	sprintf(t,&quot;%f &quot;,f);
+	sprintf(t, &quot;%f &quot;, f);
 	boost::recursive_mutex::scoped_lock scoped_lock(tempstrMutex);
 	tempstr += t;
 	return *this;
@@ -214,18 +401,19 @@
 {
 	boost::recursive_mutex::scoped_lock scoped_lock(tempstrMutex);
 
-	for(int a=0;c[a];a++) {
+	for(int a = 0; c[a]; ++a) {
 		if (c[a] == '\n') {
-			Output(0, tempstr.c_str());
+			Output(LOG_DEFAULT, tempstr.c_str());
 			tempstr.clear();
 			break;
-		} else
+		} else {
 			tempstr += c[a];
+		}
 	}
 	return *this;
 }
 
-CLogOutput&amp; CLogOutput::operator&lt;&lt; (const std::string &amp;s)
+CLogOutput&amp; CLogOutput::operator&lt;&lt; (const std::string&amp; s)
 {
-	return this-&gt;operator &lt;&lt;(s.c_str());
+	return this-&gt;operator&lt;&lt; (s.c_str());
 }

Modified: branches/caiinterface/rts/System/LogOutput.h
===================================================================
--- branches/caiinterface/rts/System/LogOutput.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/LogOutput.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -7,7 +7,6 @@
 #define LOGOUTPUT_H
 
 #include &lt;stdarg.h&gt;
-#include &lt;vector&gt;
 #include &lt;string&gt;
 
 // format string error checking
@@ -19,31 +18,72 @@
 
 class float3;
 
+
+/**
+ * @brief defines a logging subsystem
+ *
+ * Each logging subsystem can be independently enabled/disabled, this allows
+ * for adding e.g. very detailed logging that's by default off, but can be
+ * turned on when troubleshooting.  (example: the virtual file system)
+ *
+ * A logging subsystem should be defined as a global variable, so it can be
+ * used as argument to logOutput.Print similarly to a simple enum constant:
+ *
+ *	static CLogSubsystem LOG_MYSUBSYS(&quot;mysubsystem&quot;);
+ *
+ * ...then, in the actual code of your engine subsystem, use:
+ *
+ *		logOutput.Print(LOG_MYSUBSYS, &quot;blah&quot;);
+ *
+ * All subsystems are linked together in a global list, allowing CLogOutput
+ * to enable/disable subsystems based on env var and configuration key.
+ */
+class CLogSubsystem
+{
+public:
+	static CLogSubsystem* GetList() { return linkedList; }
+	CLogSubsystem* GetNext() { return next; }
+
+	CLogSubsystem(const char* name, bool enabled = false);
+
+	const char* const name;
+	CLogSubsystem* const next;
+
+	bool enabled;
+
+private:
+	static CLogSubsystem* linkedList;
+};
+
+
+/** @brief implement this interface to be able to observe CLogOutput */
 class ILogSubscriber
 {
 public:
 	// Notification of log messages to subscriber
-	virtual void NotifyLogMsg(int zone, const char *str) = 0;
+	virtual void NotifyLogMsg(CLogSubsystem&amp; subsystem, const char* str) = 0;
 	virtual void SetLastMsgPos(const float3&amp; pos) {}
 };
 
+
+/** @brief logging class */
 class CLogOutput
 {
+public:
 	CLogOutput();
 	~CLogOutput();
 
-public:
-	void Print(int zone, const char *fmt, ...) FORMATSTRING(3);
-	void Print(const char *fmt, ...) FORMATSTRING(2);
+	void Print(CLogSubsystem&amp; subsystem, const char* fmt, ...) FORMATSTRING(3);
+	void Print(const char* fmt, ...) FORMATSTRING(2);
 	void Print(const std::string&amp; text);
-	void Print(int zone, const std::string&amp; text);
-	void Printv(int zone, const char* fmt, va_list argp);
+	void Print(CLogSubsystem&amp; subsystem, const std::string&amp; text);
+	void Printv(CLogSubsystem&amp; subsystem, const char* fmt, va_list argp);
 
 	CLogOutput&amp; operator&lt;&lt;(const int i);
 	CLogOutput&amp; operator&lt;&lt;(const float f);
 	CLogOutput&amp; operator&lt;&lt;(const char* c);
 	CLogOutput&amp; operator&lt;&lt;(const float3&amp; f);
-	CLogOutput&amp; operator&lt;&lt;(const std::string &amp;f);	
+	CLogOutput&amp; operator&lt;&lt;(const std::string &amp;f);
 
 	void SetLastMsgPos(const float3&amp; pos);
 
@@ -53,20 +93,20 @@
 	// Close the output file, so the crash reporter can copy it
 	void End();
 
-	void AddSubscriber(ILogSubscriber *ls);
-	void RemoveSubscriber(ILogSubscriber *ls);
+	void AddSubscriber(ILogSubscriber* ls);
+	void RemoveSubscriber(ILogSubscriber* ls);
 
 	void SetMirrorToStdout(bool);
-	
+
 	static CLogOutput&amp; GetInstance();
-private:
 	static CLogOutput myLogOutput;
-	std::ofstream* filelog;
 
+	void SetFilename(const char* filename);
+	void Initialize();
+
 protected:
-	void Output(int zone, const char *str);
-
-	std::vector&lt;ILogSubscriber*&gt; subscribers;
+	void InitializeSubsystems();
+	void Output(CLogSubsystem&amp; subsystem, const char* str);
 };
 
 

Modified: branches/caiinterface/rts/System/Net/UnpackPacket.cpp
===================================================================
--- branches/caiinterface/rts/System/Net/UnpackPacket.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Net/UnpackPacket.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -3,7 +3,7 @@
 namespace netcode
 {
 
-UnpackPacket::UnpackPacket(boost::shared_ptr&lt;const RawPacket&gt; packet) : pckt(packet), pos(0)
+UnpackPacket::UnpackPacket(boost::shared_ptr&lt;const RawPacket&gt; packet, unsigned skipBytes) : pckt(packet), pos(skipBytes)
 {
 }
 

Modified: branches/caiinterface/rts/System/Net/UnpackPacket.h
===================================================================
--- branches/caiinterface/rts/System/Net/UnpackPacket.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Net/UnpackPacket.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -12,7 +12,7 @@
 class UnpackPacket
 {
 public:
-	UnpackPacket(boost::shared_ptr&lt;const RawPacket&gt;);
+	UnpackPacket(boost::shared_ptr&lt;const RawPacket&gt;, unsigned skipBytes = 0);
 	
 	template &lt;typename T&gt;
 	void operator&gt;&gt;(T&amp; t) {t = *(T*)(pckt-&gt;data+pos); pos += sizeof(T);};

Modified: branches/caiinterface/rts/System/NetProtocol.cpp
===================================================================
--- branches/caiinterface/rts/System/NetProtocol.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/NetProtocol.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -32,14 +32,14 @@
 	logOutput.Print(server-&gt;Statistics());
 }
 
-void CNetProtocol::InitClient(const char *server_addr, unsigned portnum,unsigned sourceport, const unsigned wantedNumber)
+void CNetProtocol::InitClient(const char *server_addr, unsigned portnum,unsigned sourceport, const std::string&amp; myName, const std::string&amp; myVersion)
 {
 	boost::shared_ptr&lt;netcode::UDPSocket&gt; sock(new netcode::UDPSocket(sourceport));
 	sock-&gt;SetBlocking(false);
 	netcode::UDPConnection* conn = new netcode::UDPConnection(sock, server_addr, portnum);
 	conn-&gt;SetMTU(configHandler.GetInt(&quot;MaximumTransmissionUnit&quot;, 0));
 	server.reset(conn);
-	server-&gt;SendData(CBaseNetProtocol::Get().SendAttemptConnect(wantedNumber, NETWORK_VERSION));
+	server-&gt;SendData(CBaseNetProtocol::Get().SendAttemptConnect(myName, myVersion));
 	server-&gt;Flush(true);
 
 	if (!gameSetup || !gameSetup-&gt;hostDemo)	//TODO do we really want this?
@@ -47,10 +47,10 @@
 		record.reset(new CDemoRecorder());
 	}
 	
-	logOutput.Print(&quot;Connecting to %s:%i using number %i&quot;, server_addr, portnum, wantedNumber);
+	logOutput.Print(&quot;Connecting to %s:%i using name %s&quot;, server_addr, portnum, myName.c_str());
 }
 
-void CNetProtocol::InitLocalClient(const unsigned wantedNumber)
+void CNetProtocol::InitLocalClient()
 {
 	server.reset(new netcode::CLocalConnection);
 	server-&gt;Flush();
@@ -59,7 +59,7 @@
 		record.reset(new CDemoRecorder());
 	}
 	
-	logOutput.Print(&quot;Connecting to local server using number %i&quot;, wantedNumber);
+	logOutput.Print(&quot;Connecting to local server&quot;);
 }
 
 bool CNetProtocol::Active() const

Modified: branches/caiinterface/rts/System/NetProtocol.h
===================================================================
--- branches/caiinterface/rts/System/NetProtocol.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/NetProtocol.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -27,12 +27,12 @@
 	/**
 	@brief Initialise in client mode (remote server)
 	*/
-	void InitClient(const char* server,unsigned portnum,unsigned sourceport, const unsigned wantedNumber);
+	void InitClient(const char* server,unsigned portnum,unsigned sourceport, const std::string&amp; myName, const std::string&amp; myVersion);
 	
 	/**
 	@brief Initialise in client mode (local server)
 	 */
-	void InitLocalClient(const unsigned wantedNumber);
+	void InitLocalClient();
 
 	/// Are we still connected (or did the connection timed out)?
 	bool Active() const;

Modified: branches/caiinterface/rts/System/Object.cpp
===================================================================
--- branches/caiinterface/rts/System/Object.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Object.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -8,6 +8,11 @@
 #include &quot;creg/STL_Set.h&quot;
 #include &quot;LogOutput.h&quot;
 
+#ifndef USE_MMGR
+# define m_setOwner(file, line, func)
+# define m_resetGlobals()
+#endif
+
 CR_BIND(CObject, )
 
 CR_REG_METADATA(CObject, (
@@ -29,24 +34,16 @@
 {
 	std::list&lt;CObject*&gt;::iterator di;
 	for(di=listeners.begin();di!=listeners.end();++di){
-#ifdef USE_MMGR
  		m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 		(*di)-&gt;DependentDied(this);
-#ifdef USE_MMGR
 		m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 		ListErase&lt;CObject*&gt;((*di)-&gt;listening, this);
 	}
 	for(di=listening.begin();di!=listening.end();++di){
-#ifdef USE_MMGR
 		m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 		ListErase&lt;CObject*&gt;((*di)-&gt;listeners, this);
 	}
-#ifdef USE_MMGR
 	m_resetGlobals();
-#endif
 }
 
 void CObject::Serialize(creg::ISerializer *s)
@@ -77,14 +74,10 @@
 void CObject::PostLoad()
 {
 	for (std::list&lt;CObject*&gt;::iterator i=listening.begin();i!=listening.end();i++) {
-#ifdef USE_MMGR
 		m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 		(*i)-&gt;listeners.insert((*i)-&gt;listeners.end(),this);
 	}
-#ifdef USE_MMGR
 	m_resetGlobals();
-#endif
 }
 
 void CObject::DependentDied(CObject* o)
@@ -94,31 +87,19 @@
 
 void CObject::AddDeathDependence(CObject *o)
 {
-#ifdef USE_MMGR
 	m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 	o-&gt;listeners.insert(o-&gt;listeners.end(),this);
-#ifdef USE_MMGR
 	m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 	listening.insert(listening.end(),o);
-#ifdef USE_MMGR
 	m_resetGlobals();
-#endif
 }
 
 void CObject::DeleteDeathDependence(CObject *o)
 {
 	//note that we can be listening to a single object from several different places (like curreclaim in CBuilder and lastAttacker in CUnit, grr) so we should only remove one of them
-#ifdef USE_MMGR
 	m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 	ListErase&lt;CObject*&gt;(listening, o);
-#ifdef USE_MMGR
 	m_setOwner(__FILE__, __LINE__, __FUNCTION__);
-#endif
 	ListErase&lt;CObject*&gt;(o-&gt;listeners, this);
-#ifdef USE_MMGR
 	m_resetGlobals();
-#endif
 }

Modified: branches/caiinterface/rts/System/Platform/ConfigHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/ConfigHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/ConfigHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -2,7 +2,7 @@
  * @file ConfigHandler.cpp
  * @brief config implementation
  * @author Christopher Han &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">xiphux at gmail.com</A>&gt;
- * 
+ *
  * Implementation of config structure class
  * Copyright (C) 2005.  Licensed under the terms of the
  * GNU GPL, v2 or later.
@@ -27,12 +27,11 @@
  * Default instantiation of ConfigHandler instance
  * is NULL.
  */
+#ifndef USE_GML // GML calls GetInstance() from a global scope and needs these to be initialized in gml.cpp instead to avoid crash
 ConfigHandler* ConfigHandler::instance = NULL;
-
-
 std::string ConfigHandler::configSource;
+#endif
 
-
 /**
  * Returns reference to the current platform's config class.
  * If none exists, create one.
@@ -86,7 +85,7 @@
 {
 	std::ostringstream buf1;
 	buf1 &lt;&lt; def;
-	
+
 	std::istringstream buffer(GetString(name, buf1.str()));
 	float val;
 	buffer &gt;&gt; val;

Modified: branches/caiinterface/rts/System/Platform/FileSystem.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/FileSystem.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/FileSystem.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -29,6 +29,7 @@
 #include &quot;FileSystem/ArchiveScanner.h&quot;
 #include &quot;FileSystem/VFSHandler.h&quot;
 #include &quot;LogOutput.h&quot;
+#include &quot;Util.h&quot;
 #include &quot;mmgr.h&quot;
 
 
@@ -69,29 +70,41 @@
 #else
 		instance = new UnixFileSystemHandler(verbose);
 #endif
+		try {
+			instance-&gt;Initialize();
+		}
+		catch (...) {
+			SafeDelete(instance);
+			throw;
+		}
 	}
 }
 
 void FileSystemHandler::Cleanup()
 {
-	delete instance;
-	instance = NULL;
+	SafeDelete(instance);
 }
 
 FileSystemHandler::~FileSystemHandler()
 {
-	delete archiveScanner;
-	delete vfsHandler;
-	archiveScanner = NULL;
-	vfsHandler = NULL;
+	SafeDelete(archiveScanner);
+	SafeDelete(vfsHandler);
 }
 
 FileSystemHandler::FileSystemHandler(int native_path_sep): native_path_separator(native_path_sep)
 {
-	// need to set this here already or we get stuck in an infinite loop
-	// because WinFileSystemHandler/UnixFileSystemHandler ctor initializes the
-	// ArchiveScanner (which uses FileSystemHandler::GetInstance again...).
-	instance = this;
+	// NOTE TO SELF: NEVER EVAR DO THIS AGAIN THIS WAY
+
+	// combined with init code in constructor and exceptions being thrown
+	// when this init code fails it results in dangling pointers.
+
+	// (if constructor throws exception object doesn't exist, by definition,
+	//  but global variable instance would still point to it....)
+
+//	// need to set this here already or we get stuck in an infinite loop
+//	// because WinFileSystemHandler/UnixFileSystemHandler ctor initializes the
+//	// ArchiveScanner (which uses FileSystemHandler::GetInstance again...).
+//	instance = this;
 }
 
 ////////////////////////////////////////

Modified: branches/caiinterface/rts/System/Platform/FileSystem.h
===================================================================
--- branches/caiinterface/rts/System/Platform/FileSystem.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/FileSystem.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -31,6 +31,7 @@
 
 		virtual ~FileSystemHandler();
 		FileSystemHandler(int native_path_sep = '/');
+		virtual void Initialize() = 0;
 
 		// almost direct wrappers to system calls
 		virtual bool mkdir(const std::string&amp; dir) const = 0;

Modified: branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/Linux/DataDirLocater.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -321,8 +321,11 @@
 #else
 	_chdir(GetWriteDir()-&gt;path.c_str());
 #endif
+	// Initialize the log. Only after this moment log will be written to file.
+	logOutput.Initialize();
 	// Logging MAY NOT start before the chdir, otherwise the logfile ends up
 	// in the wrong directory.
+	// Update: now it actually may start before, log has preInitLog.
 	for (std::vector&lt;DataDir&gt;::const_iterator d = datadirs.begin(); d != datadirs.end(); ++d) {
 		if (d-&gt;writable)
 			logOutput.Print(&quot;Using read-write data directory: %s&quot;, d-&gt;path.c_str());

Modified: branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/Linux/OpenALSound.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -195,6 +195,8 @@
 {
 	assert(volume &gt;= 0.0f);
 
+	if (volume == 0.0f || globalVolume == 0.0f) return;
+
 	ALuint source;
 	alGenSources(1, &amp;source);
 

Modified: branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -71,20 +71,23 @@
  *
  * Locates data directories and initializes the VFS.
  */
-UnixFileSystemHandler::UnixFileSystemHandler(bool verbose, bool initialize) :
+UnixFileSystemHandler::UnixFileSystemHandler(bool verbose) :
 #ifndef _WIN32
 		FileSystemHandler('/')
 #else
 		FileSystemHandler('\\')
 #endif
 {
-	if (initialize) {
-		locater.LocateDataDirs();
-		InitVFS();
-	}
 }
 
 
+void UnixFileSystemHandler::Initialize()
+{
+	locater.LocateDataDirs();
+	InitVFS();
+}
+
+
 UnixFileSystemHandler::~UnixFileSystemHandler()
 {
 	configHandler.Deallocate();

Modified: branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.h
===================================================================
--- branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/Linux/UnixFileSystemHandler.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -25,7 +25,8 @@
 	public:
 
 		virtual ~UnixFileSystemHandler();
-		UnixFileSystemHandler(bool verbose, bool initialize = true);
+		UnixFileSystemHandler(bool verbose);
+		virtual void Initialize();
 
 		virtual bool mkdir(const std::string&amp; dir) const;
 

Modified: branches/caiinterface/rts/System/Platform/Win/DxSound.cpp
===================================================================
--- branches/caiinterface/rts/System/Platform/Win/DxSound.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Platform/Win/DxSound.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -230,6 +230,8 @@
 		return;
 	}
 
+	if (volume == 0.0f || globalVolume == 0.0f) return;
+
 	const float v = 1.0f - (globalVolume * max(0.0f, min(1.0f, volume)));
 	int num = GetBuf(id, v);
 
@@ -265,6 +267,8 @@
 		return;
 	}
 
+	if (volume == 0.0f || globalVolume == 0.0f) return;
+
 	float3 dif = p - camera-&gt;pos;
 	float dl = dif.Length();
 	float pan = dif.dot(camera-&gt;right) * DSBPAN_RIGHT / dl;

Modified: branches/caiinterface/rts/System/Script/LuaFunctions.cpp
===================================================================
--- branches/caiinterface/rts/System/Script/LuaFunctions.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Script/LuaFunctions.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -168,6 +168,8 @@
 
 	void SendSelectedUnits()
 	{
+		GML_RECMUTEX_LOCK(sel); // SendSelectedUnits
+
 		if (selectedUnits.selectionChanged)
 			selectedUnits.SendSelection();
 	}

Modified: branches/caiinterface/rts/System/SpringApp.cpp
===================================================================
--- branches/caiinterface/rts/System/SpringApp.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/SpringApp.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -18,17 +18,17 @@
 #include &quot;Game/GameVersion.h&quot;
 #include &quot;Game/GameSetup.h&quot;
 #include &quot;Game/GameController.h&quot;
+#include &quot;Game/SelectMenu.h&quot;
 #include &quot;Game/PreGame.h&quot;
 #include &quot;Game/Game.h&quot;
 #include &quot;Game/Team.h&quot;
 #include &quot;Game/UI/KeyBindings.h&quot;
-#include &quot;Lua/LuaGaia.h&quot;
-#include &quot;Lua/LuaRules.h&quot;
 #include &quot;Lua/LuaOpenGL.h&quot;
 #include &quot;Platform/BaseCmd.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
 #include &quot;Platform/errorhandler.h&quot;
 #include &quot;Platform/FileSystem.h&quot;
+#include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;ExternalAI/IAILibraryManager.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Rendering/GLContext.h&quot;
@@ -105,6 +105,10 @@
 	FSAA = false;
 
 	signal(SIGABRT, SigAbrtHandler);
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+	extern volatile int multiThreadSim;
+	multiThreadSim=configHandler.GetInt(&quot;MultiThreadSim&quot;, 1);
+#endif
 }
 
 /**
@@ -292,7 +296,7 @@
 	LuaOpenGL::Init();
 
 	// Create CGameSetup and CPreGame objects
-	CreateGameSetup ();
+	Startup ();
 
 	return true;
 }
@@ -616,6 +620,9 @@
 	const float fontSize = 0.027f;      // ~20 pixels at 1024x768
 	const float smallFontSize = 0.016f; // ~12 pixels at 1024x768
 
+	SafeDelete(font);
+	SafeDelete(smallFont);
+
 	try {
 		font = CglFont::TryConstructFont(fontFile, charFirst, charLast, fontSize);
 		smallFont = CglFont::TryConstructFont(fontFile, charFirst, charLast, smallFontSize);
@@ -804,72 +811,109 @@
 /**
  * Initializes instance of GameSetup
  */
-void SpringApp::CreateGameSetup()
+void SpringApp::Startup()
 {
 	ENTER_SYNCED;
 
-	if (!startscript.empty()) {
+	LocalSetup* startsetup = 0;
+	startsetup = new LocalSetup();
+	if (!startscript.empty())
+	{
+		CFileHandler fh(startscript);
+		if (!fh.FileExists())
+			throw content_error(&quot;Setupscript doesn't exists in given location: &quot;+startscript);
+		
+		std::string buf;
+		if (!fh.LoadStringData(buf))
+			throw content_error(&quot;Setupscript cannot be read: &quot;+startscript);
+		startsetup-&gt;Init(buf);
+
+		// commandline parameters overwrite setup
+		if (cmdline-&gt;result(&quot;client&quot;))
+			startsetup-&gt;isHost = false;
+		else if (cmdline-&gt;result(&quot;server&quot;))
+			startsetup-&gt;isHost = true;
+
 		CGameSetup* temp = SAFE_NEW CGameSetup();
-		if (!temp-&gt;Init(startscript)) {
-			delete temp;
-			temp = 0;
-		}
-		else
+		if (temp-&gt;Init(startscript))
 		{
 			gameSetup = const_cast&lt;const CGameSetup*&gt;(temp);
 			gs-&gt;LoadFromSetup(gameSetup);
-			gu-&gt;LoadFromSetup(gameSetup);
 		}
-	}
-
-	if (!gameSetup &amp;&amp; demofile.empty()) {
-		gs-&gt;noHelperAIs = !!configHandler.GetInt(&quot;NoHelperAIs&quot;, 0);
-		const string luaGaiaStr  = configHandler.GetString(&quot;LuaGaia&quot;,  &quot;1&quot;);
-		const string luaRulesStr = configHandler.GetString(&quot;LuaRules&quot;, &quot;1&quot;);
-		gs-&gt;useLuaGaia  = CLuaGaia::SetConfigString(luaGaiaStr);
-		gs-&gt;useLuaRules = CLuaRules::SetConfigString(luaRulesStr);
-		if (gs-&gt;useLuaGaia) {
-			gs-&gt;gaiaTeamID = gs-&gt;activeTeams;
-			gs-&gt;gaiaAllyTeamID = gs-&gt;activeAllyTeams;
-			gs-&gt;activeTeams++;
-			gs-&gt;activeAllyTeams++;
-			CTeam* team = gs-&gt;Team(gs-&gt;gaiaTeamID);
-			team-&gt;color[0] = 255;
-			team-&gt;color[1] = 255;
-			team-&gt;color[2] = 255;
-			team-&gt;color[3] = 255;
-			team-&gt;gaia = true;
-			gs-&gt;SetAllyTeam(gs-&gt;gaiaTeamID, gs-&gt;gaiaAllyTeamID);
+		else
+		{
+			throw content_error(&quot;Setupscript parse error: &quot;+startscript);
 		}
+#ifdef SYNCDEBUG
+		CSyncDebugger::GetInstance()-&gt;Initialize(startsetup-&gt;isHost);
+#endif
+		pregame = SAFE_NEW CPreGame(startsetup, &quot;&quot;, &quot;&quot;);
 	}
-
-	ENTER_MIXED;
-
-	bool server = true;
-
-	if (!demofile.empty()) {
-		server = false;
+	else if (!demofile.empty())
+	{
+		startsetup-&gt;isHost = false;
+#ifdef SYNCDEBUG
+		CSyncDebugger::GetInstance()-&gt;Initialize(false);
+#endif
+		pregame = SAFE_NEW CPreGame(startsetup, demofile, &quot;&quot;);
 	}
-	else if (gameSetup) {
-		// first real player is demo host
-		server = (gameSetup-&gt;myPlayerNum == gameSetup-&gt;numDemoPlayers) &amp;&amp; !cmdline-&gt;result(&quot;client&quot;);
+	else if (!savefile.empty())
+	{
+		startsetup-&gt;isHost = false;
+#ifdef SYNCDEBUG
+		CSyncDebugger::GetInstance()-&gt;Initialize(false);
+#endif
+		pregame = SAFE_NEW CPreGame(startsetup, &quot;&quot;, savefile);
 	}
-	else {
-		server = !cmdline-&gt;result(&quot;client&quot;) || cmdline-&gt;result(&quot;server&quot;);
-	}
-
+	else
+	{
+		bool server = !cmdline-&gt;result(&quot;client&quot;) || cmdline-&gt;result(&quot;server&quot;);
 #ifdef SYNCDEBUG
-	// initialize sync debugger as soon as we know whether we will be server
-	CSyncDebugger::GetInstance()-&gt;Initialize(server);
+		CSyncDebugger::GetInstance()-&gt;Initialize(server);
 #endif
+		activeController = new SelectMenu(server);
+	}
+}
 
-	if (!demofile.empty()) {
-		pregame = SAFE_NEW CPreGame(false, demofile, &quot;&quot;);
-	} else {
-		pregame = SAFE_NEW CPreGame(server, &quot;&quot;, savefile);
+
+
+
+#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
+volatile int multiThreadSim;
+volatile int startsim;
+
+int SpringApp::Sim() {
+	while(keeprunning &amp;&amp; !startsim)
+		SDL_Delay(100);
+//		boost::thread::yield();
+	while(keeprunning) {
+		if(!multiThreadSim) {
+//			startsim=0;
+			while(!multiThreadSim &amp;&amp; keeprunning)
+				SDL_Delay(100);
+//			simBarrier.wait();
+//			startsim=1;
+		}
+		else if (activeController) {
+			GML_STDMUTEX_LOCK(sim);
+
+			gmlProcessor.ExpandAuxQueue();
+			if (!activeController-&gt;Update()) {
+				return 0;
+			}
+			gmlProcessor.GetQueue();
+		}
+//		while(!startsim)
+//			SDL_Delay(100);
+		boost::thread::yield();
 	}
+	return 1;
 }
+#endif
 
+
+
+
 /**
  * @return return code of activecontroller draw function
  *
@@ -881,9 +925,8 @@
 	if (FSAA)
 		glEnable(GL_MULTISAMPLE_ARB);
 
-#if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
 	mouseInput-&gt;Update();
-#endif
+
 	int ret = 1;
 	if (activeController) {
 #if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
@@ -897,11 +940,19 @@
 			if(frame==gu-&gt;drawFrame) { // only draw if it was not done in parallel with sim
 #	endif
 #else
-				if(!gs-&gt;frameNum) {
-					mouseInput-&gt;Update();
+				if(multiThreadSim) {
+					if(!gs-&gt;frameNum) {
+						GML_STDMUTEX_LOCK(sim);
+
+						activeController-&gt;Update();
+						if(gs-&gt;frameNum)
+							startsim=1;
+					}
+				}
+				else {
+					GML_STDMUTEX_LOCK(sim);
+
 					activeController-&gt;Update();
-					if(gs-&gt;frameNum)
-						startsim=1;
 				}
 #endif
 				gu-&gt;drawFrame++;
@@ -910,7 +961,7 @@
 				}
 				ret = activeController-&gt;Draw();
 #if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-				gmlProcessor.PumpAux(); 
+				gmlProcessor.PumpAux();
 #endif
 #if !defined(USE_GML) || !GML_ENABLE_SIMLOOP
 #	if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMDRAW
@@ -929,27 +980,6 @@
 	return ret;
 }
 
-#if defined(USE_GML) &amp;&amp; GML_ENABLE_SIMLOOP
-int SpringApp::Sim() {
-	while(keeprunning &amp;&amp; !startsim)
-		boost::thread::yield();
-	unsigned lastSim = SDL_GetTicks();
-	while(keeprunning) {
-		mouseInput-&gt;Update();
-		if (activeController) {
-			if (!activeController-&gt;Update()) {
-				return 0;
-			}
-			gmlProcessor.GetQueue();
-		}
-		unsigned lastSimDiff=SDL_GetTicks()-lastSim;
-		if(lastSimDiff&lt;=10)
-			SDL_Delay(10-lastSimDiff);
-		lastSim = SDL_GetTicks();
-	}
-	return 1;
-}
-#endif
 
 /**
  * Tests SDL keystates and sets values
@@ -1012,6 +1042,8 @@
 		while (SDL_PollEvent(&amp;event)) {
 			switch (event.type) {
 				case SDL_VIDEORESIZE: {
+					GML_STDMUTEX_LOCK(sim);
+
 					screenWidth = event.resize.w;
 					screenHeight = event.resize.h;
 #ifndef WIN32
@@ -1025,6 +1057,8 @@
 					break;
 				}
 				case SDL_VIDEOEXPOSE: {
+					GML_STDMUTEX_LOCK(sim);
+
 					// re-initialize the stencil
 					glClearStencil(0);
 					glClear(GL_STENCIL_BUFFER_BIT); SDL_GL_SwapBuffers();

Modified: branches/caiinterface/rts/System/SpringApp.h
===================================================================
--- branches/caiinterface/rts/System/SpringApp.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/SpringApp.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -26,7 +26,7 @@
 	bool Initialize (); 	//!&lt; Initialize app
 	void CheckCmdLineFile (int argc,char *argv[]); 	//!&lt; Check command line for files
 	void ParseCmdLine(); 				//!&lt; Parse command line
-	void CreateGameSetup (); 			//!&lt; Creates GameSetup
+	void Startup (); 		//!&lt; Parses startup data (script etc.) and starts SelectMenu or PreGame
 	bool InitWindow (const char* title); 		//!&lt; Initializes window
 	void InitOpenGL (); 				//!&lt; Initializes OpenGL
 	void LoadFonts();
@@ -37,7 +37,6 @@
 	int Sim (); 					//!&lt; Simulation  loop
 	static void Simcb(void *c) {((SpringApp *)c)-&gt;Sim();}
 	volatile int keeprunning;
-	volatile int startsim;
 #endif
 	void UpdateSDLKeys (); 				//!&lt; Update SDL key array
 	bool GetDisplayGeometry();

Modified: branches/caiinterface/rts/System/Sync/SyncedFloat3.h
===================================================================
--- branches/caiinterface/rts/System/Sync/SyncedFloat3.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Sync/SyncedFloat3.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -496,6 +496,47 @@
 		return x*x+z*z;
 	}
 
+
+	/**
+	 * @brief SqDistance between float3s squared
+	 * @param f float3 to compare against
+	 * @return float squared distance between float3s
+	 *
+	 * Returns the squared distance of 2 float3s
+	 */
+	inline float SqDistance(const SyncedFloat3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dy = y - f.y;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dy*dy + dz*dz);
+	}
+	inline float SqDistance(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dy = y - f.y;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dy*dy + dz*dz);
+	}
+
+
+	/**
+	 * @brief SqDistance2D between float3s (only x and z)
+	 * @param f float3 to compare against
+	 * @return 2D squared distance between float3s
+	 *
+	 * Returns the squared 2d-distance of 2 float3s
+	 */
+	inline float SqDistance2D(const SyncedFloat3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dz*dz);
+	}
+	inline float SqDistance2D(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dz*dz);
+	}
+
+
 	SyncedFloat x; ///&lt; x component
 	SyncedFloat y; ///&lt; y component
 	SyncedFloat z; ///&lt; z component

Modified: branches/caiinterface/rts/System/Util.h
===================================================================
--- branches/caiinterface/rts/System/Util.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/Util.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -45,7 +45,7 @@
 }
 
 
-#ifdef	__cplusplus
+#ifdef __cplusplus
 
 #include &lt;string&gt;
 #include &lt;algorithm&gt;
@@ -70,6 +70,16 @@
 	return std::string(buf);
 }
 
-#endif	/* __cplusplus */
+/** @brief Safely delete object by first setting pointer to NULL and then deleting.
+	This way it is guaranteed other objects can not access the object through the
+	pointer while the object is running it's destructor. */
+template&lt;class T&gt; void SafeDelete(T &amp;a)
+{
+	T tmp = a;
+	a = NULL;
+	delete tmp;
+}
 
+#endif	// __cplusplus
+
 #endif

Modified: branches/caiinterface/rts/System/float3.h
===================================================================
--- branches/caiinterface/rts/System/float3.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/float3.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -456,7 +456,37 @@
 		return x*x + z*z;
 	}
 
+
 	/**
+	 * @brief SqDistance between float3s squared
+	 * @param f float3 to compare against
+	 * @return float squared distance between float3s
+	 *
+	 * Returns the squared distance of 2 float3s
+	 */
+	inline float SqDistance(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dy = y - f.y;
+		const float dz = z - f.z;
+		return (float) (dx*dx + dy*dy + dz*dz);
+	}
+
+
+	/**
+	 * @brief SqDistance2D between float3s (only x and z)
+	 * @param f float3 to compare against
+	 * @return 2D squared distance between float3s
+	 *
+	 * Returns the squared 2d-distance of 2 float3s
+	 */
+	inline float SqDistance2D(const float3 &amp;f) const{
+		const float dx = x - f.x;
+		const float dz = z - f.z;
+		return (float)(dx*dx + dz*dz);
+	}
+
+
+	/**
 	 * @brief max x pos
 	 *
 	 * Static value containing the maximum

Modified: branches/caiinterface/rts/System/myMath.h
===================================================================
--- branches/caiinterface/rts/System/myMath.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/System/myMath.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -123,4 +123,9 @@
 float LinePointDist(const float3&amp; l1, const float3&amp; l2, const float3&amp; p);
 float3 ClosestPointOnLine(const float3&amp; l1, const float3&amp; l2, const float3&amp; p);
 
+inline float Square(const float&amp; x)
+{
+	return x*x;
+}
+
 #endif /* MYMATH_H */

Modified: branches/caiinterface/rts/build/scons/rts.py
===================================================================
--- branches/caiinterface/rts/build/scons/rts.py	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/build/scons/rts.py	2008-11-02 10:29:36 UTC (rev 6956)
@@ -87,7 +87,8 @@
 	usropts.AddOptions(
 		#permanent options
 		('platform',          'Set to linux, freebsd or windows', None),
-		('gml',               'Set to false to disable OpenGL thread library', False),
+		('gml',               'Set to yes to enable the OpenGL Multithreading Library', False),
+		('gmlsim',            'Set to yes to enable parallel threads for Sim/Draw', False),
 		('debug',             'Set to yes to produce a binary with debug information', 0),
 		('debugdefines',      'Set to no to suppress DEBUG and _DEBUG preprocessor #defines (use to add symbols to release build)', True),
 		('syncdebug',         'Set to yes to enable the sync debugger', False),
@@ -152,7 +153,7 @@
 	if 'configure' in sys.argv:
 
 		# be paranoid, unset existing variables
-		for key in ['platform', 'gml', 'debug', 'optimize', 'profile', 'profile_use', 'profile_generate', 'cpppath',
+		for key in ['platform', 'gml', 'gmlsim', 'debug', 'optimize', 'profile', 'profile_use', 'profile_generate', 'cpppath',
 			'libpath', 'prefix', 'installprefix', 'datadir', 'bindir', 'libdir', 'cachedir', 'strip',
 			'disable_avi', 'use_tcmalloc', 'use_mmgr', 'use_gch', 'LINKFLAGS', 'LIBPATH', 'LIBS', 'CCFLAGS',
 			'CXXFLAGS', 'CPPDEFINES', 'CPPPATH', 'CC', 'CXX', 'is_configured', 'spring_defines', 'arch']:
@@ -373,6 +374,7 @@
 			#	env['CXXFLAGS'] = env['CCFLAGS']
 
 		bool_opt('gml', False)
+		bool_opt('gmlsim', False)
 		bool_opt('strip', False)
 		bool_opt('disable_avi', env['platform'] != 'windows')
 		bool_opt('use_tcmalloc', False)
@@ -401,9 +403,14 @@
 		if env['gml']:
 			env.AppendUnique(CCFLAGS = ['-mno-tls-direct-seg-refs'], CXXFLAGS = ['-mno-tls-direct-seg-refs'], LINKFLAGS = ['-mno-tls-direct-seg-refs'])		
 			spring_defines += ['USE_GML']
-			print 'GML OpenGL thread library is enabled'
+			print 'OpenGL Multithreading Library is enabled'
+			if env['gmlsim']:
+				spring_defines += ['USE_GML_SIM']
+				print 'Parallel threads for Sim/Draw is enabled'
+			else:
+				print 'Parallel threads for Sim/Draw is NOT enabled'
 		else:
-			print 'GML OpenGL thread library NOT enabled'
+			print 'OpenGL Multithreading Library and parallel threads for Sim/Draw are NOT enabled'
 
 		# Add define specifying type of floating point math to use.
 		if env['fpmath']:

Modified: branches/caiinterface/rts/build/vstudio8/rts.vcproj
===================================================================
--- branches/caiinterface/rts/build/vstudio8/rts.vcproj	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/build/vstudio8/rts.vcproj	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
 &lt;VisualStudioProject
 	ProjectType=&quot;Visual C++&quot;
-	Version=&quot;8,00&quot;
+	Version=&quot;8.00&quot;
 	Name=&quot;rts&quot;
 	ProjectGUID=&quot;{A0F70264-A7B7-4FE7-A5BE-298CD3A0758F}&quot;
 	RootNamespace=&quot;rts&quot;
@@ -419,7 +419,7 @@
 				EnableIntrinsicFunctions=&quot;true&quot;
 				FavorSizeOrSpeed=&quot;1&quot;
 				AdditionalIncludeDirectories=&quot;../../;../../System;../../lib/streflop;../../lib/crashrpt/include;&quot;../../../vclibs/freetype-2.1.10/include&quot;;../../../vclibs/DevIL/include;../../../vclibs/boost/Include;../../../vclibs/OpenAL/include;../../../vclibs/glew/include;../../../vclibs/zlibwapi/include;&quot;../../../vclibs/SDL-1.2.9/include&quot;;&quot;../../../vclibs/libjpeg/libjpeg-include&quot;;../../lib/lua/include;../../lib/luabind;../../../vclibs/ogg_vorbis/include&quot;
-				PreprocessorDefinitions=&quot;_CMATH_;_WIN32;WIN32;NDEBUG;_WINDOWS;ZLIB_WINAPI;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;SYNCCHECK;USE_GML&quot;
+				PreprocessorDefinitions=&quot;_CMATH_;_WIN32;WIN32;NDEBUG;_WINDOWS;ZLIB_WINAPI;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;SYNCCHECK;USE_GML;USE_GML_SIM&quot;
 				StringPooling=&quot;true&quot;
 				ExceptionHandling=&quot;2&quot;
 				RuntimeLibrary=&quot;2&quot;
@@ -514,7 +514,7 @@
 				AdditionalOptions=&quot;/vmg&quot;
 				Optimization=&quot;0&quot;
 				AdditionalIncludeDirectories=&quot;../../;../../System;../../lib/streflop;../../lib/crashrpt/include;&quot;../../../vclibs/freetype-2.1.10/include&quot;;../../../vclibs/DevIL/include;../../../vclibs/boost/Include;../../../vclibs/OpenAL/include;../../../vclibs/glew/include;../../../vclibs/zlibwapi/include;&quot;../../../vclibs/SDL-1.2.9/include&quot;;&quot;../../../vclibs/libjpeg/libjpeg-include&quot;;../../lib/lua/include;../../lib/luabind;../../../vclibs/ogg_vorbis/include&quot;
-				PreprocessorDefinitions=&quot;_CMATH_;NO_CATCH_EXCEPTIONS;_WIN32;WIN32;_DEBUG;_WINDOWS;ZLIB_WINAPI;_SZ_ONE_DIRECTORY;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;USE_GML&quot;
+				PreprocessorDefinitions=&quot;_CMATH_;NO_CATCH_EXCEPTIONS;_WIN32;WIN32;_DEBUG;_WINDOWS;ZLIB_WINAPI;_SZ_ONE_DIRECTORY;DIRECT_CONTROL_ALLOWED;BUILDING_SPRING;STREFLOP_X87;USE_GML;USE_GML_SIM&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
 				RuntimeLibrary=&quot;3&quot;

Modified: branches/caiinterface/rts/lib/gml/gml.cpp
===================================================================
--- branches/caiinterface/rts/lib/gml/gml.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/lib/gml/gml.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -32,10 +32,13 @@
 // If a function is not yet supported by GML, a compile error pointing to 'GML_FUNCTION_NOT_IMPLEMENTED' will occur
 
 #include &quot;StdAfx.h&quot;
+
 #ifdef USE_GML
 #include &quot;gmlcls.h&quot;
 #include &quot;LogOutput.h&quot;
 #include &quot;Platform/ConfigHandler.h&quot;
+ConfigHandler* ConfigHandler::instance = NULL;
+std::string ConfigHandler::configSource;
 
 #define EXEC_RUN (BYTE *)NULL
 #define EXEC_SYNC (BYTE *)-1
@@ -55,10 +58,14 @@
 #else
 int gmlThreadNumber=0;
 #endif
+
+int gmlThreadCountOverride=configHandler.GetInt(&quot;HardwareThreadCount&quot;, 0); // number of threads to use (can be manually overridden here)
 int gmlThreadCount=GML_CPU_COUNT; // number of threads to use
-int gmlThreadCountOverride=0; //configHandler.GetInt(&quot;HardwareThreadCount&quot;, 0); // number of threads to use (can be manually overridden here)
 int gmlItemsConsumed=0;
 
+int gmlNextTickUpdate=0;
+unsigned gmlCurrentTicks;
+
 // gmlCPUCount returns the number of CPU cores
 // it was taken from the latest version of boost
 // boost::thread::hardware_concurrency()
@@ -97,6 +104,14 @@
 #endif
 }
 
+const char *gmlFunctionNames[512];
+inline int gmlResetNames() {
+    for(int i=0; i&lt;512; ++i)
+        gmlFunctionNames[i]=&quot;&quot;;
+    return 0;
+}
+int gmlNamesDummy=gmlResetNames();
+
 // cache maps for gmlInit
 std::map&lt;GLenum,GLint&gt; gmlGetIntegervCache;
 std::map&lt;GLenum,GLfloat&gt; gmlGetFloatvCache;
@@ -186,26 +201,31 @@
 boost::mutex groupmutex;
 boost::mutex inmapmutex;
 boost::mutex tempmutex;
+boost::mutex posmutex;
+boost::mutex rendermutex;
+boost::mutex simmutex;
 
 #include &lt;boost/thread/recursive_mutex.hpp&gt;
 boost::recursive_mutex unitmutex;
+boost::recursive_mutex selmutex;
+boost::recursive_mutex &amp;luamutex=selmutex;
 boost::recursive_mutex quadmutex;
-boost::recursive_mutex selmutex;
-boost::recursive_mutex luamutex;
 boost::recursive_mutex featmutex;
 boost::recursive_mutex projmutex;
 boost::recursive_mutex grassmutex;
 boost::recursive_mutex guimutex;
+boost::recursive_mutex filemutex;
+boost::recursive_mutex &amp;qnummutex=quadmutex;
 #endif
 
 // GMLqueue implementation
 gmlQueue::gmlQueue():
 ReadPos(0),WritePos(0),WriteSize(0),Read(0),Write(0),Locked1(FALSE),Locked2(FALSE),Reloc(FALSE),Sync(EXEC_RUN),WasSynced(FALSE),
 ClientState(0),
-CPsize(0), CPtype(0), CPstride(0), CPpointer(NULL), 
-EFPstride(0), EFPpointer(NULL), 
-IPtype(0), IPstride(0), IPpointer(NULL), 
-NPtype(0), NPstride(0), NPpointer(NULL), 
+CPsize(0), CPtype(0), CPstride(0), CPpointer(NULL),
+EFPstride(0), EFPpointer(NULL),
+IPtype(0), IPstride(0), IPpointer(NULL),
+NPtype(0), NPstride(0), NPpointer(NULL),
 TCPsize(0), TCPtype(0), TCPstride(0), TCPpointer(NULL),
 ArrayBuffer(0), ElementArrayBuffer(0), PixelPackBuffer(0),PixelUnpackBuffer(0)
 {
@@ -630,7 +650,9 @@
 		glDrawArrays(GML_D(name,A),0,GML_D(name,B));\
 	GML_NEXT_SIZE(name)
 
-
+const char *gmlNOPDummy=(gmlFunctionNames[0]=&quot;gmlNOP&quot;);
+#define GML_QUOTE(x) #x
+#define GML_MAKENAME(name) EXTERN const char *gml##name##Dummy=(gmlFunctionNames[gml##name##Enum]=GML_QUOTE(gml##name));
 #include &quot;gmlfun.h&quot;
 // this item server instance needs gmlDeleteLists from gmlfun.h, that is why it is declared down here
 gmlItemSequenceServer&lt;GLuint, GLsizei,GLuint (GML_GLAPIENTRY *)(GLsizei)&gt; gmlListServer(&amp;glGenLists, &amp;gmlDeleteLists, 100, 25, 20, 5);
@@ -916,22 +938,24 @@
 }
 
 void gmlQueue::ExecuteDebug() {
-	int procs=0;
+//	int procs=0;
 	BYTE *p=Read;
 	BYTE *e=ReadPos;
 	BYTE *ptr=NULL;
 
 	while(p&lt;e) {
 		if(*(int *)p!=0)
-			logOutput.Print(&quot;GML error: OpenGL call #%d in SimFrame()&quot;,*(int *)p);
+			logOutput.Print(&quot;GML error: Sim thread called %s&quot;,gmlFunctionNames[*(int *)p]);
 		QueueHandler(p,ptr);
-		++procs;
+//		++procs;
 	}
-	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
-		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
+//	if(procs&gt;1 || (procs==1 &amp;&amp; *(int *)Read!=0))
+//		logOutput.Print(&quot;GML error: %d OpenGL calls detected in SimFrame()&quot;,procs);
 }
 
 #include &quot;gmlsrv.h&quot;
+class CUnit;
+gmlClientServer&lt;void, int,CUnit*&gt; gmlProcessor;
 
 // ExecuteSynced - executes all GL commands in the current read queue.
 // Execution is synced (this means it will stop at certain points

Modified: branches/caiinterface/rts/lib/gml/gml.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gml.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/lib/gml/gml.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -74,12 +74,15 @@
 extern void gmlInit();
 
 EXTERN inline GLhandleARB gmlCreateProgram() {
+	GML_ITEMSERVER_CHECK();
 	return gmlProgramServer.GetItems();
 }
 EXTERN inline GLhandleARB gmlCreateProgramObjectARB() {
+	GML_ITEMSERVER_CHECK();
 	return gmlProgramObjectARBServer.GetItems();
 }
 EXTERN inline GLhandleARB gmlCreateShader(GLenum type) {
+	GML_ITEMSERVER_CHECK();
 	if(type==GL_VERTEX_SHADER)
 		return gmlShaderServer_VERTEX.GetItems();
 	if(type==GL_FRAGMENT_SHADER)
@@ -89,6 +92,7 @@
 	return 0;
 }
 EXTERN inline GLhandleARB gmlCreateShaderObjectARB(GLenum type) {
+	GML_ITEMSERVER_CHECK();
 	if(type==GL_VERTEX_SHADER_ARB)
 		return gmlShaderObjectARBServer_VERTEX.GetItems();
 	if(type==GL_FRAGMENT_SHADER_ARB)
@@ -98,36 +102,46 @@
 	return 0;
 }
 EXTERN inline GLUquadric *gmluNewQuadric() {
+	GML_ITEMSERVER_CHECK();
 	return gmlQuadricServer.GetItems();
 }
 
 
 EXTERN inline void gmlGenTextures(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlTextureServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenBuffersARB(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlBufferARBServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenFencesNV(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlFencesNVServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenProgramsARB(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlProgramsARBServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenRenderbuffersEXT(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlRenderbuffersEXTServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenFramebuffersEXT(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlFramebuffersEXTServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenQueries(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlQueryServer.GetItems(n, items);
 }
 EXTERN inline void gmlGenBuffers(GLsizei n, GLuint *items) {
+	GML_ITEMSERVER_CHECK();
 	gmlBufferServer.GetItems(n, items);
 }
 
 EXTERN inline GLuint gmlGenLists(GLsizei items) {
+	GML_ITEMSERVER_CHECK();
 	return gmlListServer.GetItems(items);
 }
 
@@ -148,25 +162,60 @@
 extern boost::mutex groupmutex;
 extern boost::mutex inmapmutex;
 extern boost::mutex tempmutex;
+extern boost::mutex posmutex;
+extern boost::mutex rendermutex;
+extern boost::mutex simmutex;
 
 #include &lt;boost/thread/recursive_mutex.hpp&gt;
 extern boost::recursive_mutex unitmutex;
 extern boost::recursive_mutex quadmutex;
 extern boost::recursive_mutex selmutex;
-extern boost::recursive_mutex luamutex;
+extern boost::recursive_mutex &luamutex;
 extern boost::recursive_mutex featmutex;
 extern boost::recursive_mutex projmutex;
 extern boost::recursive_mutex grassmutex;
 extern boost::recursive_mutex guimutex;
+extern boost::recursive_mutex filemutex;
+extern boost::recursive_mutex &qnummutex;
 
 #define GML_STDMUTEX_LOCK(name) boost::mutex::scoped_lock name##lock(name##mutex)
 #define GML_RECMUTEX_LOCK(name) boost::recursive_mutex::scoped_lock name##lock(name##mutex)
 
+extern int gmlNextTickUpdate;
+extern unsigned gmlCurrentTicks;
+
+#include &lt;SDL_timer.h&gt;
+
+inline unsigned gmlUpdateTicks() {
+	gmlNextTickUpdate = 100;
+	return gmlCurrentTicks=SDL_GetTicks();
+}
+
+inline unsigned gmlGetTicks() {
+	if(--gmlNextTickUpdate &gt; 0)
+		return gmlCurrentTicks;
+	return gmlUpdateTicks();
+}
+
+#define GML_GET_TICKS(var) var=gmlGetTicks()
+#define GML_UPDATE_TICKS() gmlUpdateTicks()
+
+#define GML_PARG_H , boost::recursive_mutex::scoped_lock&amp; projlock = boost::recursive_mutex::scoped_lock(projmutex)
+#define GML_PARG_C , boost::recursive_mutex::scoped_lock&amp; projlock
+#define GML_PARG_P , projlock
+
 #else
 
 #define GML_STDMUTEX_LOCK(name)
 #define GML_RECMUTEX_LOCK(name)
 
+#define GML_GET_TICKS(var)
+#define GML_UPDATE_TICKS()
+
+#define GML_PARG_H
+#define GML_PARG_C
+#define GML_PARG_P
+
 #endif
 
 #else
@@ -177,6 +226,13 @@
 #define GML_STDMUTEX_LOCK(name)
 #define GML_RECMUTEX_LOCK(name)
 
+#define GML_GET_TICKS(var)
+#define GML_UPDATE_TICKS()
+
+#define GML_PARG_H
+#define GML_PARG_C
+#define GML_PARG_P
+
 #endif // USE_GML
 
 #endif

Modified: branches/caiinterface/rts/lib/gml/gmlcls.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlcls.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/lib/gml/gmlcls.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -33,9 +33,15 @@
 #	define GML_ENABLE 0 // manually enable opengl multithreading here
 #endif
 
+#ifdef USE_GML_SIM
+#	define GML_ENABLE_LOOP 1
+#else
+#	define GML_ENABLE_LOOP 0
+#endif
+
 #define GML_ENABLE_SIM (GML_ENABLE &amp;&amp; 1) // runs the sim in a separate thread
-#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; 0) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
-#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; 0) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
+#define GML_ENABLE_SIMDRAW (GML_ENABLE_SIM &amp;&amp; GML_ENABLE_LOOP) // runs Draw() in parallel with ceratain SimFrame() calls. Highly experimental, not fully working yet.
+#define GML_ENABLE_SIMLOOP (GML_ENABLE_SIMDRAW &amp;&amp; GML_ENABLE_LOOP) // runs a completely independent loop for the Sim. Highly experimental, not fully working yet.
 
 #define GML_ENABLE_DRAW (GML_ENABLE &amp;&amp; 0) // draws everything in a separate thread (for testing only, will degrade performance)
 #define GML_SERVER_GLCALL 1 // allows the server thread (0) to make direct GL calls
@@ -44,6 +50,8 @@
 #define GML_USE_DEFAULT 1// compile/link/buffer status always returns TRUE/COMPLETE (to improve performance)
 #define GML_USE_CACHE 1 // certain glGet calls may use data cached during gmlInit (to improve performance)
 //#define GML_USE_QUADRIC_SERVER 1 // use server thread to create/delete quadrics
+#define GML_AUX_PREALLOC 128*1024 // preallocation size for aux queue to reduce risk for hang if gl calls happen to be made from Sim thread
+#define GML_ENABLE_ITEMSERVER_CHECK (GML_ENABLE_SIMDRAW &amp;&amp; 1) // if calls to itemserver are made from Sim, output errors to log
 #define GML_UPDSRV_INTERVAL 10
 #define GML_ALTERNATE_SYNCMODE 1 // mutex-protected synced execution, slower but more portable
 #define GML_ENABLE_TLS_CHECK 1 // check if Thread Local Storage appears to be working
@@ -189,7 +197,7 @@
 extern int gmlThreadCountOverride;
 extern unsigned gmlCPUCount();
 #define GML_CPU_COUNT (gmlThreadCountOverride?gmlThreadCountOverride:gmlCPUCount())
-#define GML_MAX_NUM_THREADS 32
+#define GML_MAX_NUM_THREADS (32+1) // one extra for the aux (Sim) thread
 #define GML_IF_SERVER_THREAD() if(GML_SERVER_GLCALL &amp;&amp; (!GML_ENABLE || gmlThreadNumber==0))
 extern int gmlItemsConsumed;
 
@@ -199,12 +207,12 @@
 #define TRUE 1
 #define FALSE 0
 #define EXTERN
-#define GML_VP_ARRAY_BUFFER (1&lt;&lt;(16+GL_VERTEX_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;20)
-#define GML_CP_ARRAY_BUFFER (1&lt;&lt;(16+GL_COLOR_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;21)
-#define GML_TCP_ARRAY_BUFFER (1&lt;&lt;(16+GL_TEXTURE_COORD_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;22)
-#define GML_IP_ARRAY_BUFFER (1&lt;&lt;(16+GL_INDEX_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;23)
-#define GML_NP_ARRAY_BUFFER (1&lt;&lt;(16+GL_NORMAL_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;24)
-#define GML_EFP_ARRAY_BUFFER (1&lt;&lt;(16+GL_EDGE_FLAG_ARRAY-GL_VERTEX_ARRAY)) //(1&lt;&lt;25)
+#define GML_VP_ARRAY_BUFFER (1&lt;&lt;(16+GL_VERTEX_ARRAY-GL_VERTEX_ARRAY))
+#define GML_CP_ARRAY_BUFFER (1&lt;&lt;(16+GL_COLOR_ARRAY-GL_VERTEX_ARRAY))
+#define GML_TCP_ARRAY_BUFFER (1&lt;&lt;(16+GL_TEXTURE_COORD_ARRAY-GL_VERTEX_ARRAY))
+#define GML_IP_ARRAY_BUFFER (1&lt;&lt;(16+GL_INDEX_ARRAY-GL_VERTEX_ARRAY))
+#define GML_NP_ARRAY_BUFFER (1&lt;&lt;(16+GL_NORMAL_ARRAY-GL_VERTEX_ARRAY))
+#define GML_EFP_ARRAY_BUFFER (1&lt;&lt;(16+GL_EDGE_FLAG_ARRAY-GL_VERTEX_ARRAY))
 #define GML_ELEMENT_ARRAY_BUFFER (1&lt;&lt;29)
 
 #ifdef _WIN32
@@ -828,7 +836,7 @@
 	int pregen_large;	
 	int large_arr_size;
 	T *large_item_arr;
-	T *large_size_arr;
+	S *large_size_arr;
 	GML_MUTEX;
 	
 public:
@@ -843,9 +851,9 @@
 		pregen_large=pg_l;
 		large_arr_size=sz_l;
 		large_item_arr=new T[large_arr_size];
-		large_size_arr=new T[large_arr_size];
+		large_size_arr=new S[large_arr_size];
 		memset(large_item_arr,0,large_arr_size*sizeof(T));
-		memset(large_size_arr,0,large_arr_size*sizeof(T));
+		memset(large_size_arr,0,large_arr_size*sizeof(S));
 	}
 	
 	virtual ~gmlItemSequenceServer() {
@@ -866,11 +874,11 @@
 		}
 		// large
 		while(avail_large&lt;req_large+pregen_large &amp;&amp; large_size_arr[i=(avail_large%large_arr_size)]==0) {
-			int gensize=size_large;
+			S gensize=(S)size_large;
 			GML_MUTEX_LOCK();
 			*(volatile T *)(large_item_arr+i)=(*genfun)(gensize);
 			GML_MEMBAR;
-			*(volatile T *)(large_size_arr+i)=gensize;
+			*(volatile S *)(large_size_arr+i)=gensize;
 			GML_MEMBAR; // perhaps not needed, because ++avail_large acts as a barrier
 			GML_MUTEX_UNLOCK();
 			++avail_large;
@@ -904,16 +912,16 @@
 			int idx=(num-1)%large_arr_size;
 			GML_MUTEX_LOCK();
 			T ip=*(volatile T *)(large_item_arr+idx);
-			T *sz=large_size_arr+idx;
-			T szv=*(volatile T *)sz;
+			S *sz=large_size_arr+idx;
+			S szv=*(volatile S *)sz;
 			GML_MEMBAR;
-			*(volatile T *)sz=0;
+			*(volatile S *)sz=0;
 			GML_MUTEX_UNLOCK();
-			if(szv&gt;static_cast&lt;T&gt;(n))
-				(*delfun)(ip+szv,szv-n); // del excessive
-			if(szv&lt;static_cast&lt;T&gt;(n))
+			if(szv&gt;n)
+				(*delfun)(ip+n,szv-n); // del excessive
+			if(szv&lt;n)
 				(*delfun)(ip,szv); // del all
-			if(szv&gt;=static_cast&lt;T&gt;(n))
+			if(szv&gt;=n)
 				return ip;
 		}
 	}

Modified: branches/caiinterface/rts/lib/gml/gmlfun.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlfun.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/lib/gml/gmlfun.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -11,6 +11,7 @@
 
 #include &lt;set&gt;
 #include &lt;map&gt;
+#include &quot;LogOutput.h&quot;
 
 #define GML_ENABLE_DEBUG 0
 
@@ -324,11 +325,28 @@
 
 #define GML_SYNC() gmlSync(qd)
 
-#define GML_FUN(name,ftype) EXTERN const int gml##name##Enum=__LINE__-__FIRSTLINE__;\
+#ifndef GML_MAKENAME
+#	define GML_MAKENAME(name)
+#endif
+
+#define GML_FUN(name,ftype) EXTERN const int gml##name##Enum=(__LINE__-__FIRSTLINE__);\
+	GML_MAKENAME(name)\
 	EXTERN inline ftype gml##name
 
-#define GML_RETFUN(name,ftr) EXTERN inline ftr gml##name
+#ifdef _MSC_VER
+#define GML_FUNCTION __FUNCTION__
+#else
+#define GML_FUNCTION __func__
+#endif
 
+#if GML_ENABLE_ITEMSERVER_CHECK
+#define GML_ITEMSERVER_CHECK()\
+    if(gmlThreadNumber==gmlThreadCount)\
+        logOutput.Print(&quot;GML error: Sim thread called %s&quot;,GML_FUNCTION);
+#else
+#define GML_ITEMSERVER_CHECK()
+#endif
+
 #define GML_MAKEFUN0(name) struct gml##name##Data {\
 	GML_MAKEVAR()\
 };\

Modified: branches/caiinterface/rts/lib/gml/gmlsrv.h
===================================================================
--- branches/caiinterface/rts/lib/gml/gmlsrv.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/lib/gml/gmlsrv.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -125,7 +125,7 @@
 	gmlCount ClientsReady;
 	BOOL_ newwork;
 
-	BOOL auxinited;
+	BOOL_ auxinited;
 	R (*auxworker)(void *);
 	void* auxworkerclass;
 	boost::barrier AuxBarrier; 
@@ -407,6 +407,12 @@
 		}
 	}
 
+	void ExpandAuxQueue() {
+		gmlQueue *qd=&amp;gmlQueues[gmlThreadNumber];
+		while(qd-&gt;WriteSize&lt;qd-&gt;Write+GML_AUX_PREALLOC)
+			qd-&gt;WaitRealloc();
+	}
+
 };
 
 #endif // USE_GML

Modified: branches/caiinterface/rts/lib/hpiutil2/hpiutil.h
===================================================================
--- branches/caiinterface/rts/lib/hpiutil2/hpiutil.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/rts/lib/hpiutil2/hpiutil.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -24,7 +24,6 @@
 #define HPIUTIL2_H
 
 #include &quot;hpifile.h&quot;
-#include &lt;SDL_types.h&gt;
 
 namespace hpiutil
 {

Modified: branches/caiinterface/tools/DedicatedServer/main.cpp
===================================================================
--- branches/caiinterface/tools/DedicatedServer/main.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/DedicatedServer/main.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -32,12 +32,23 @@
 		std::cout &lt;&lt; &quot;Loading script: &quot; &lt;&lt; script &lt;&lt; std::endl;
 
 		gameSetup = new CGameSetup();	// to store the gamedata inside
+		
 		if (!gameSetup-&gt;Init(script))	// read the script provided by cmdline
 		{
 			std::cout &lt;&lt; &quot;Failed to load script&quot; &lt;&lt; std::endl;
 			return 1;
 		}
 		
+		LocalSetup* settings = new LocalSetup();
+		CFileHandler fh(script);
+		if (!fh.FileExists())
+			throw content_error(&quot;Setupscript doesn't exists in given location: &quot;+script);
+		
+		std::string buf;
+		if (!fh.LoadStringData(buf))
+			throw content_error(&quot;Setupscript cannot be read: &quot;+script);
+		settings-&gt;Init(buf);
+		
 		std::cout &lt;&lt; &quot;Starting server...&quot; &lt;&lt; std::endl;
 		// Create the server, it will run in a separate thread
 		GameData* data = new GameData();
@@ -77,10 +88,10 @@
 		}
 
 		data-&gt;SetScript(gameSetup-&gt;scriptName);
-		server = new CGameServer(gameSetup-&gt;hostport, false, data, gameSetup);
+		server = new CGameServer(settings-&gt;hostport, false, data, gameSetup);
 		
-		if (gameSetup-&gt;autohostport &gt; 0)
-			server-&gt;AddAutohostInterface(gameSetup-&gt;autohostport);
+		if (settings-&gt;autohostport &gt; 0)
+			server-&gt;AddAutohostInterface(settings-&gt;autohostport);
 		else
 		{
 			std::cout &lt;&lt; &quot;You should specify an AutohostPort in the script&quot; &lt;&lt; std::endl;

Modified: branches/caiinterface/tools/unitsync/CMakeLists.txt
===================================================================
--- branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/CMakeLists.txt	2008-11-02 10:29:36 UTC (rev 6956)
@@ -54,6 +54,7 @@
 
 AUX_SOURCE_DIRECTORY(../../rts/System/FileSystem/ fsfiles)
 set(unitsync_files
+	../../rts/System/LogOutput
 	../../rts/System/TdfParser
 	../../rts/Sim/SideParser
 	../../rts/Game/GameVersion
@@ -71,8 +72,8 @@
 if (JAVA_FOUND)
 	list(APPEND unitsync_files javabind)
 endif (JAVA_FOUND)
-ADD_LIBRARY(unitsync SHARED ${platformfiles} ${unitsync_files} ${fsfiles} unitsync LuaParserAPI Syncer SyncServer stdafx)
-TARGET_LINK_LIBRARIES(unitsync ${unitsync_libs} hpiutil2 7zip minizip lua ${Boost_REGEX_LIBRARY} ${DEVIL_ILU_LIBRARY} ${SDL_LIBRARY})
+ADD_LIBRARY(unitsync SHARED ${platformfiles} ${unitsync_files} ${fsfiles} unitsync LuaParserAPI Syncer stdafx)
+TARGET_LINK_LIBRARIES(unitsync ${unitsync_libs} hpiutil2 7zip minizip lua ${Boost_REGEX_LIBRARY} ${Boost_THREAD_LIBRARY} ${DEVIL_ILU_LIBRARY} ${SDL_LIBRARY})
 if (PYTHONLIBS_FOUND)
 	TARGET_LINK_LIBRARIES(unitsync ${PYTHON_LIBRARIES})
 endif (PYTHONLIBS_FOUND)

Deleted: branches/caiinterface/tools/unitsync/SyncServer.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/SyncServer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/SyncServer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,210 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;SyncServer.h&quot;
-#include &lt;sstream&gt;
-
-using namespace std;
-
-CSyncServer::CSyncServer(int id) :
-	CSyncer(id)
-{
-}
-
-CSyncServer::~CSyncServer(void)
-{
-}
-
-void CSyncServer::AddClient(int id, const string&amp; unitList)
-{
-	istringstream s(unitList);
-	Unit u;
-	string name;
-
-	while (s &gt;&gt; name) {
-		s &gt;&gt; u.fbi;
-		s &gt;&gt; u.cob;
-		s &gt;&gt; u.model;
-
-		clientLists[id][name] = u;
-	}
-
-	//The time has come, to calculate diffs! ohnoes!
-	curDiff.clear();
-	lastDiffClient = id;
-	lastWasRemove = false;
-
-	for (map&lt;string, Unit&gt;::iterator i = clientLists[id].begin(); i != clientLists[id].end(); ++i) {
-
-		//Check with each other client if they have this unit
-		for (map&lt;int, unitlist_t&gt;::iterator clientId = clientLists.begin(); clientId != clientLists.end(); ++clientId) {
-			
-			//No need to compare with ourselves
-			if (clientId-&gt;first == id)
-				continue;
-
-			//Now, determine if this unit is here, and if so, if it has the same crc
-			map&lt;string, Unit&gt;::iterator curUnit = clientLists[clientId-&gt;first].find(i-&gt;first);
-			bool unitOk = false;
-			if (curUnit != clientLists[clientId-&gt;first].end()) {
-				if ((curUnit-&gt;second.fbi   == i-&gt;second.fbi) &amp;&amp;
-				    (curUnit-&gt;second.cob   == i-&gt;second.cob) &amp;&amp;
-				    (curUnit-&gt;second.model == i-&gt;second.model)) {
-					unitOk = true;
-				}
-			}
-
-			if (unitOk) {
-				//No need to say anything about this unit
-			}
-			else {
-				// If a unit has a bad crc, that client is added to the differing list
-				map&lt;string, MissingList&gt;::iterator mli = curDiff.find(i-&gt;first);
-				if (mli != curDiff.end()) {
-					curDiff[i-&gt;first].clients.insert(clientId-&gt;first);
-				}
-				else {
-					MissingList ml;
-					ml.clients.insert(clientId-&gt;first);
-					curDiff[i-&gt;first] = ml;
-				}
-			}
-		}
-	}
-
-	//Now we need to check the other way around.. If any client had a unit that we did not
-	//if we find such a unit, it must be added to the difflist for that client
-	//this could possibly be optimized by flagging everything that we do find in the above pass..
-	for (map&lt;int, unitlist_t&gt;::iterator client = clientLists.begin(); client != clientLists.end(); ++client) {
-		
-		//No need to diff with ourselves
-		if (client-&gt;first == id)
-			continue;
-
-		for (map&lt;string, Unit&gt;::iterator unit = client-&gt;second.begin(); unit != client-&gt;second.end(); ++unit) {
-			map&lt;string, Unit&gt;::iterator found = clientLists[id].find(unit-&gt;first);
-
-			//If not found, we should do things
-			if (found == clientLists[id].end()) {
-				map&lt;string, MissingList&gt;::iterator mli = curDiff.find(unit-&gt;first);
-				if (mli != curDiff.end()) {
-					curDiff[unit-&gt;first].clients.insert(client-&gt;first);
-				}
-				else {
-					MissingList ml;
-					ml.clients.insert(client-&gt;first);
-					curDiff[unit-&gt;first] = ml;
-				}
-			}
-		}
-	}
-
-	//Alright, now we have a map that for each unit contains id's of clients that need to know that
-	//this unit should now be disabled
-
-	// Since we are the server, we should install the diff for ourselves automatically
-	string diff = GetClientDiff(localId);
-	InstallClientDiff(diff);
-}
-
-void CSyncServer::RemoveClient(int id)
-{
-	//Since each client keeps a list of who caused a unit to be disabled, it should suffice to let them
-	//keep their lists in order if we just tell them who left
-
-	lastDiffClient = id;
-	lastWasRemove = true;
-
-	// Remove it from our list of units
-	clientLists.erase(id);
-
-	// We are the server (but also a client) so we will do it for ourselves automatically
-	string diff = GetClientDiff(localId);
-	InstallClientDiff(diff);
-}
-
-const string CSyncServer::GetClientDiff(int id)
-{
-	ostringstream s(&quot;&quot;);
-
-	if (id == lastDiffClient) {
-		// For us, we need to know which other clients caused our units to be disabled
-		
-		// This should not need to be called, but still..
-		if (lastWasRemove) {
-			s &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; lastWasRemove &lt;&lt; &quot; &quot;;
-		}
-		else {
-			// Go through the difflist for each client
-			for (map&lt;int, unitlist_t&gt;::iterator client = clientLists.begin(); client != clientLists.end(); ++client) {
-				int count = 0;
-				ostringstream us(&quot;&quot;);
-
-				for (map&lt;string, MissingList&gt;::iterator i = curDiff.begin(); i != curDiff.end(); ++i) {
-					set&lt;int&gt;::iterator clientId = i-&gt;second.clients.find(client-&gt;first);
-
-					//If found, add the name of the disabled unit
-					if (clientId != i-&gt;second.clients.end()) {
-						us &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot;;
-						count++;
-					}
-				}
-
-				// Only generate the list if needed
-				if (count &gt; 0) {
-					s &lt;&lt; client-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; lastWasRemove &lt;&lt; &quot; &quot; &lt;&lt; count &lt;&lt; &quot; &quot;;
-					s &lt;&lt; us.str();
-				}
-			}
-		}
-
-	}
-	else {
-
-		// For the others, it is always the new guy's fault
-		s &lt;&lt; lastDiffClient &lt;&lt; &quot; &quot;;
-
-		//and of what they are guilt
-		s &lt;&lt; lastWasRemove &lt;&lt; &quot; &quot;;
-
-		//If remove, we are done now
-		if (lastWasRemove)
-			return s.str();
-
-		ostringstream us(&quot;&quot;);
-		int count = 0;
-
-		for (map&lt;string, MissingList&gt;::iterator i = curDiff.begin(); i != curDiff.end(); ++i) {
-			set&lt;int&gt;::iterator client = i-&gt;second.clients.find(id);
-
-			//If found, add the name of the disabled unit
-			if (client != i-&gt;second.clients.end()) {
-				us &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot;;
-				count++;
-			}
-		}
-
-		s &lt;&lt; count &lt;&lt; &quot; &quot;;
-		s &lt;&lt; us.str();
-	}
-
-	return s.str();
-}
-
-void CSyncServer::InitMasterList() 
-{
-	//Add our info as a clientList to avoid special handling
-
-	for (map&lt;string, Unit&gt;::iterator i = units.begin(); i != units.end(); ++i) {
-		clientLists[localId][i-&gt;first] = i-&gt;second;
-	}
-}
-
-int CSyncServer::ProcessUnits()
-{
-	const int unitsLeft = CSyncer::ProcessUnits();
-
-	if (unitsLeft == 0) {
-		InitMasterList();
-	}
-
-	return unitsLeft;
-}

Deleted: branches/caiinterface/tools/unitsync/SyncServer.h
===================================================================
--- branches/caiinterface/tools/unitsync/SyncServer.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/SyncServer.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,32 +0,0 @@
-#ifndef SYNCSERVER_H
-#define SYNCSERVER_H
-
-#include &quot;Syncer.h&quot;
-#include &lt;string&gt;
-#include &lt;set&gt;
-
-typedef std::map&lt;std::string, Unit&gt; unitlist_t;
-
-struct MissingList {
-    std::set&lt;int&gt; clients;
-};
-
-class CSyncServer : 
-	public CSyncer
-{
-protected:
-    std::map&lt;int, unitlist_t&gt; clientLists;
-	int lastDiffClient;
-	bool lastWasRemove;
-	std::map&lt;std::string, MissingList&gt; curDiff;
-	void InitMasterList();
-public:
-	CSyncServer(int id);
-	~CSyncServer(void);
-	void AddClient(int id, const std::string&amp; unitList);
-	void RemoveClient(int id);
-	const std::string GetClientDiff(int id);
-	virtual int ProcessUnits();
-};
-
-#endif

Modified: branches/caiinterface/tools/unitsync/Syncer.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/Syncer.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/Syncer.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,9 +1,9 @@
-
 #include &quot;StdAfx.h&quot;
 #include &quot;Syncer.h&quot;
+#include &quot;Exceptions.h&quot;
 #include &quot;FileSystem/FileHandler.h&quot;
 #include &quot;Lua/LuaParser.h&quot;
-#include &quot;unitsyncLogOutput.h&quot;
+#include &quot;LogOutput.h&quot;
 #include &lt;vector&gt;
 #include &lt;string&gt;
 #include &lt;algorithm&gt;
@@ -11,55 +11,27 @@
 
 using namespace std;
 
-CSyncer::CSyncer(int id)
-: unitsLeft(-1)
+CSyncer::CSyncer()
 {
-	localId = id;
 }
 
 
-CSyncer::~CSyncer(void)
+CSyncer::~CSyncer()
 {
 }
 
 
-crc_t CSyncer::CalculateCRC(const string&amp; fileName)
+void CSyncer::LoadUnits()
 {
-	CFileHandler file(fileName);
-	if (!file.FileExists()) {
-		return 0;
-	}
-
-	long size = file.FileSize();
-	char *data = new char[size];
-	file.Read(data, size);
-
-	//todo: do a less silly algorithm
-	crc_t cur = 0;
-	for (int i = 0; i &lt; size; ++i) {
-		cur += data[i];
-	}
-
-	delete[] data;
-	return cur;
-}
-
-
-void CSyncer::LoadUnits(bool checksum)
-{
-	unitsLeft = 0;
-
 	LuaParser luaParser(&quot;gamedata/defs.lua&quot;,
 	                    SPRING_VFS_MOD_BASE, SPRING_VFS_ZIP);
 	if (!luaParser.Execute()) {
-		logOutput.Print(&quot;luaParser.Execute() failed&quot;);
-		return;
+		throw content_error(&quot;luaParser.Execute() failed: &quot; + luaParser.GetErrorLog());
 	}
 
 	LuaTable rootTable = luaParser.GetRoot().SubTable(&quot;UnitDefs&quot;);
 	if (!rootTable.IsValid()) {
-		logOutput.Print(&quot;root unitdef table invalid&quot;);
-		return;
+		throw content_error(&quot;root unitdef table invalid&quot;);
 	}
 
 	vector&lt;string&gt; unitDefNames;
@@ -75,18 +47,6 @@
 
 		u.fullName = udTable.GetString(&quot;name&quot;, udName);
 
-		if (checksum) {
-			const string fileName  = udTable.GetString(&quot;filename&quot;, &quot;&quot;);
-			const string deadName  = udTable.GetString(&quot;corpse&quot;, udName + &quot;_dead&quot;);
-			const string modelName = udTable.GetString(&quot;objectname&quot;, udName);
-
-			u.fbi    = CalculateCRC(fileName);
-			u.cob    = CalculateCRC(&quot;scripts/&quot; + udName + &quot;.cob&quot;);
-			u.model  = CalculateCRC(&quot;objects3d/&quot; + modelName); // s3o ?
-			u.model += CalculateCRC(&quot;objects3d/&quot; + modelName + &quot;.3do&quot;);
-			u.model += CalculateCRC(&quot;objects3d/&quot; +  deadName + &quot;.3do&quot;);
-		}
-
 		units[udName] = u;
 	}
 
@@ -95,94 +55,17 @@
 	for (mit = units.begin(); mit != units.end(); ++mit) {
 		unitIds.push_back(mit-&gt;first);
 	}
-
-	unitsLeft = count;
-
-	return;
 }
 
 
-int CSyncer::ProcessUnits(bool checksum)
+int CSyncer::ProcessUnits()
 {
-	if (unitsLeft &lt; 0) {
-		LoadUnits(checksum);
-	}
+	LoadUnits();
 
-	if (unitsLeft &lt;= 0) {
-		return 0;
-	}
-
-	unitsLeft--;
-
-	return unitsLeft;
+	return 0;
 }
 
 
-string CSyncer::GetCurrentList()
-{
-	ostringstream s(&quot;&quot;);
-
-	for (map&lt;string,Unit&gt;::iterator i = units.begin(); i != units.end(); ++i) {
-		s &lt;&lt; i-&gt;first &lt;&lt; &quot; &quot;;
-		s &lt;&lt; i-&gt;second.fbi &lt;&lt; &quot; &quot;;
-		s &lt;&lt; i-&gt;second.cob &lt;&lt; &quot; &quot;;
-		s &lt;&lt; i-&gt;second.model &lt;&lt; &quot; &quot;;
-	}
-
-	return s.str();
-}
-
-
-void CSyncer::InstallClientDiff(const string&amp; diff)
-{
-	istringstream i(diff);
-
-	int client;
-	string name;
-	bool wasRemove;
-	int count;
-
-	while (i &gt;&gt; client) {
-		i &gt;&gt; wasRemove;
-
-		//Handle remove if so
-		if (wasRemove) {
-			RemoveClient(client);
-			return;
-		}
-
-		// Alas, it was not..
-		i &gt;&gt; count;
-		for (int a = 0; a &lt; count; ++a) {
-			i &gt;&gt; name;
-			map&lt;string, DisabledUnit&gt;::iterator found = disabledUnits.find(name);
-			if (found != disabledUnits.end()) {
-				disabledUnits[name].clients.insert(client);
-			}
-			else {
-				DisabledUnit mu;
-				mu.clients.insert(client);
-				disabledUnits[name] = mu;
-			}
-		}
-	}
-}
-
-
-void CSyncer::RemoveClient(int id)
-{
-	for (map&lt;string, DisabledUnit&gt;::iterator i = disabledUnits.begin(); i != disabledUnits.end(); ++i) {
-		set&lt;int&gt;::iterator clientId = i-&gt;second.clients.find(id);
-		if (clientId != i-&gt;second.clients.end()) {
-			i-&gt;second.clients.erase(clientId);
-
-			//could delete the unit from the map if the list is empty now
-			//the speed increase should be insignificant though I guess
-		}
-	}
-}
-
-
 int CSyncer::GetUnitCount()
 {
 	return units.size();
@@ -201,28 +84,3 @@
 	const string&amp; unitName = unitIds[unit];
 	return units[unitName].fullName;
 }
-
-
-bool CSyncer::IsUnitDisabled(int unit)
-{
-	string unitName = unitIds[unit];
-	map&lt;string, DisabledUnit&gt;::iterator found = disabledUnits.find(unitName);
-	if (found != disabledUnits.end())
-		return found-&gt;second.clients.size() &gt; 0;
-	else
-		return false;
-}
-
-
-bool CSyncer::IsUnitDisabledByClient(int unit, int clientId)
-{
-	string unitName = unitIds[unit];
-
-	map&lt;string, DisabledUnit&gt;::iterator found = disabledUnits.find(unitName);
-	if (found == disabledUnits.end())
-		return false;
-
-	set&lt;int&gt; &amp;clients = found-&gt;second.clients;
-	set&lt;int&gt;::iterator foundId = clients.find(clientId);
-	return foundId != clients.end();
-}

Modified: branches/caiinterface/tools/unitsync/Syncer.h
===================================================================
--- branches/caiinterface/tools/unitsync/Syncer.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/Syncer.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -6,51 +6,28 @@
 #include &lt;set&gt;
 #include &lt;string&gt;
 
-typedef unsigned int crc_t;
-
-
-struct Unit
-{
-	crc_t fbi;
-	crc_t cob;
-	crc_t model;
-
-	std::string fullName;
-};
-
-
-struct DisabledUnit {
-    std::set&lt;int&gt; clients;
-};
-
-
 class CSyncer
 {
 	public:
-		CSyncer(int id);
-		~CSyncer(void);
-		std::string GetCurrentList();
-		void InstallClientDiff(const std::string&amp; diff);
-		virtual int ProcessUnits(bool checksum = true);
-		
+		CSyncer();
+		~CSyncer();
+		virtual int ProcessUnits();
+
 		int GetUnitCount();
 		std::string GetUnitName(int unit);
 		std::string GetFullUnitName(int unit);
-		bool IsUnitDisabled(int unit);
-		bool IsUnitDisabledByClient(int unit, int clientId);
 
 	protected:
-		void LoadUnits(bool checksum);
-		void RemoveClient(int id);
-		crc_t CalculateCRC(const std::string&amp; fileName);
+		void LoadUnits();
 
 	protected:
-		int localId;
-		int unitsLeft; // decrements for each ProcessUnits() call,
-		               // causes LoadUnits() to be called when set to -1
+		struct Unit
+		{
+			std::string fullName;
+		};
+
 		std::vector&lt;std::string&gt; unitIds;
 		std::map&lt;std::string, Unit&gt; units;
-		std::map&lt;std::string, DisabledUnit&gt; disabledUnits;
 };
 
 #endif

Modified: branches/caiinterface/tools/unitsync/javabind.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/javabind.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/javabind.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -10,9 +10,6 @@
 #include &quot;Platform/FileSystem.h&quot;
 #include &quot;Rendering/Textures/Bitmap.h&quot;
 
-#include &quot;Syncer.h&quot;
-#include &quot;SyncServer.h&quot;
-
 #include &lt;string&gt;
 #include &lt;string.h&gt;
 #include &lt;vector&gt;

Modified: branches/caiinterface/tools/unitsync/pybind.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/pybind.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/pybind.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -516,6 +516,8 @@
 ////////////////////////////////////////////////////////////
 ////////// Functions not in other bindings (TODO)
 
+// GetWritableDataDirectory implements half of this now in C interface
+
 static PyObject *unitsync_GetDataDirectories(PyObject *self, PyObject *args)
 {
 	// unitsync.GetDataDirectories(bool write = False)

Modified: branches/caiinterface/tools/unitsync/unitsync.cpp
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync.cpp	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/unitsync.cpp	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,14 +1,12 @@
 #include &quot;StdAfx.h&quot;
 #include &quot;unitsync.h&quot;
 
+#include &lt;algorithm&gt;
 #include &lt;string&gt;
-#include &lt;string.h&gt;
 #include &lt;vector&gt;
 #include &lt;set&gt;
-#include &lt;algorithm&gt;
-#include &lt;cstdio&gt;
-#include &lt;cstdarg&gt;
 
+// shared with spring:
 #include &quot;LuaInclude.h&quot;
 #include &quot;FileSystem/ArchiveFactory.h&quot;
 #include &quot;FileSystem/ArchiveScanner.h&quot;
@@ -24,98 +22,123 @@
 #include &quot;Sim/SideParser.h&quot;
 #include &quot;ExternalAI/Interface/aidefines.h&quot;
 #include &quot;ExternalAI/Interface/SSAILibrary.h&quot;
+#include &quot;System/Exceptions.h&quot;
+#include &quot;System/LogOutput.h&quot;
 #include &quot;System/Util.h&quot;
-#include &quot;System/Exceptions.h&quot;
 
+// unitsync only:
 #include &quot;LuaParserAPI.h&quot;
 #include &quot;Syncer.h&quot;
-#include &quot;SyncServer.h&quot;
-#include &quot;unitsyncLogOutput.h&quot;
 
-
 using std::string;
 
+//////////////////////////
+//////////////////////////
 
-#define ASSERT(condition, message) \
-	do { \
-		if (!(condition)) { \
-			char buf[256]; \
-			sprintf(buf, &quot;%s:%d: %s: %s&quot;, __FILE__, __LINE__, __FUNCTION__, message); \
-			MessageBox(0, buf, &quot;Unitsync assertion failed&quot;, MB_OK); \
-		} \
-		assert(condition); /* just crash after the error in release mode */ \
-	} while(0)
+static CLogSubsystem LOG_UNITSYNC(&quot;unitsync&quot;, true);
 
-#define CHECK_INIT() \
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call Init first.&quot;)
-
-#define CHECK_NULL(condition) \
-	ASSERT((condition) != NULL, #condition &quot; may not be null.&quot;)
-
-#define CHECK_NULL_OR_EMPTY(condition) \
-	ASSERT((condition) != NULL &amp;&amp; *(condition) != 0, #condition &quot; may not be null or empty.&quot;)
-
 //This means that the DLL can only support one instance. Don't think this should be a problem.
-static CSyncer *syncer = NULL;
+static CSyncer* syncer;
 
 // I'd rather not include globalstuff
 #define SQUARE_SIZE 8
 
-// And the following makes the hpihandler happy
-CLogOutput logOutput;
 
-CLogOutput::CLogOutput()
+#ifdef WIN32
+BOOL __stdcall DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
 {
-	file = fopen(&quot;unitsync.log&quot;, &quot;at&quot;);
-	ASSERT(file != NULL, &quot;couldn't open logfile\n&quot;);
-	setbuf(file, NULL);
+	return TRUE;
 }
+#endif
 
-CLogOutput::~CLogOutput()
+
+namespace
 {
-	fclose(file);
+	struct COneTimeInit
+	{
+		COneTimeInit()
+		{
+			logOutput.SetFilename(&quot;unitsync.log&quot;);
+			logOutput.Print(LOG_UNITSYNC, &quot;loaded, %s\n&quot;, VERSION_STRING_DETAILED);
+		}
+	};
 }
+static COneTimeInit global_initializer;
 
-void CLogOutput::Print (const string&amp; text)
+//////////////////////////
+//////////////////////////
+
+// function argument checking
+
+static void CheckInit()
 {
-	if (*text.rbegin() != '\n')
-		fprintf(file, &quot;%s\n&quot;, text.c_str());
-	else
-		fprintf(file, &quot;%s&quot;, text.c_str());
-	fflush(file);
+	if (!archiveScanner || !vfsHandler)
+		throw std::logic_error(&quot;Unitsync not initialized. Call Init first.&quot;);
 }
 
-void CLogOutput::Print(const char* fmt, ...)
+static void _CheckNull(void* condition, const char* name)
 {
-	va_list ap;
-	va_start(ap, fmt);
-	vfprintf(file, fmt, ap);
-	va_end(ap);
-	if (fmt[strlen(fmt)-1] != '\n') {
-		fputc('\n', file);
-	}
+	if (!condition)
+		throw std::invalid_argument(&quot;Argument &quot; + string(name) + &quot; may not be null.&quot;);
 }
 
-void ErrorMessageBox(const char *msg, const char *capt, unsigned int) {
-	MessageBox(0,msg,capt,MB_OK);
+static void _CheckNullOrEmpty(const char* condition, const char* name)
+{
+	if (!condition || *condition == 0)
+		throw std::invalid_argument(&quot;Argument &quot; + string(name) + &quot; may not be null or empty.&quot;);
 }
 
+static void _CheckBounds(int index, int size, const char* name)
+{
+	if (index &lt; 0 || index &gt;= size)
+		throw std::out_of_range(&quot;Argument &quot; + string(name) + &quot; out of bounds. Index: &quot; +
+		                         IntToString(index) + &quot; Array size: &quot; + IntToString(size));
+}
 
-#ifdef WIN32
-BOOL CALLING_CONV DllMain(HINSTANCE hInst,
-                       DWORD dwReason,
-                       LPVOID lpReserved) {
-	logOutput.Print(&quot;----\nunitsync loaded\n&quot;);
-	return TRUE;
+static void _CheckPositive(int value, const char* name)
+{
+	if (value &lt;= 0)
+		throw std::out_of_range(&quot;Argument &quot; + string(name) + &quot; must be positive.&quot;);
 }
-#endif
 
+#define CheckNull(arg)         _CheckNull((arg), #arg)
+#define CheckNullOrEmpty(arg)  _CheckNullOrEmpty((arg), #arg)
+#define CheckBounds(arg, size) _CheckBounds((arg), (size), #arg)
+#define CheckPositive(arg)     _CheckPositive((arg), #arg);
 
+//////////////////////////
+//////////////////////////
+
+// error handling
+
+static string lastError;
+
+static void _SetLastError(string err)
+{
+	logOutput.Print(LOG_UNITSYNC, &quot;error: &quot; + err);
+	lastError = err;
+}
+
+#define SetLastError(str) \
+	_SetLastError(string(__FUNCTION__) + &quot;: &quot; + (str))
+
+#define UNITSYNC_CATCH_BLOCKS \
+	catch (const std::exception&amp; e) { \
+		SetLastError(e.what()); \
+	} \
+	catch (...) { \
+		SetLastError(&quot;an unknown exception was thrown&quot;); \
+	}
+
+//////////////////////////
+//////////////////////////
+
 // Helper class for loading a map archive temporarily
 
 class ScopedMapLoader {
 	public:
-		ScopedMapLoader(const string&amp; mapName) : oldHandler(vfsHandler) {
+		ScopedMapLoader(const string&amp; mapName) : oldHandler(vfsHandler)
+		{
 			CFileHandler f(&quot;maps/&quot; + mapName);
 			if (f.FileExists()) {
 				return;
@@ -130,7 +153,8 @@
 			}
 		}
 
-		~ScopedMapLoader() {
+		~ScopedMapLoader()
+		{
 			if (vfsHandler != oldHandler) {
 				delete vfsHandler;
 				vfsHandler = oldHandler;
@@ -141,18 +165,78 @@
 		CVFSHandler* oldHandler;
 };
 
+//////////////////////////
+//////////////////////////
 
+/**
+ * @brief returns next error in queue of errors and removes this error from queue
+ *
+ * Use this method to get a (short) description of errors that occurred in any
+ * other unitsync methods. Call this in a loop until it returns NULL to get all
+ * errors.
+ *
+ * The error messages may be varying in detail etc.; nothing is guaranteed about
+ * them, not even whether they have terminating newline or not.
+ *
+ * Example:
+ *		const char* err;
+ *		while ((err = GetNextError()) != NULL)
+ *			printf(&quot;unitsync error: %s\n&quot;, err);
+ */
+Export(const char*) GetNextError()
+{
+	try {
+		// queue is only 1 element long now for simplicity :-)
+
+		if (lastError.empty()) return NULL;
+
+		string err = lastError;
+		lastError.clear();
+		return GetStr(err);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+
+	// Oops, can't even return errors anymore...
+	// Returning anything but NULL might cause infinite loop in lobby client...
+	//return __FUNCTION__ &quot;: fatal error: an exception was thrown in GetNextError&quot;;
+	return NULL;
+}
+
+
+/**
+ * @brief returns the version fo spring this was compiled with
+ *
+ * Returns a const char* string specifying the version of spring used to build this library with.
+ * It was added to aid in lobby creation, where checks for updates to spring occur.
+ */
 Export(const char*) GetSpringVersion()
 {
 	return VERSION_STRING;
 }
 
+
+/**
+ * @brief Creates a messagebox with said message
+ * @param p_szMessage const char* string holding the message
+ *
+ * Creates a messagebox with the title &quot;Message from DLL&quot;, an OK button, and the specified message
+ */
 Export(void) Message(const char* p_szMessage)
 {
-	MessageBox(NULL, p_szMessage, &quot;Message from DLL&quot;, MB_OK);
+	try {
+		logOutput.Print(LOG_UNITSYNC, &quot;Message from DLL: %s\n&quot;, p_szMessage);
+#ifdef WIN32
+		MessageBox(NULL, p_szMessage, &quot;Message from DLL&quot;, MB_OK);
+#else
+		// this may cause message to be printed on console twice, if StdoutDebug is on
+		fprintf(stderr, &quot;unitsync: Message from DLL: %s\n&quot;, p_szMessage);
+#endif
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
-Export(void) UnInit()
+
+static void _UnInit()
 {
 	lpClose();
 
@@ -160,219 +244,321 @@
 
 	if ( syncer )
 	{
-		delete syncer;
-		syncer = 0;
-		logOutput.Print(&quot;unitsync deinitialized\n----\n&quot;);
+		SafeDelete(syncer);
+		logOutput.Print(LOG_UNITSYNC, &quot;deinitialized&quot;);
 	}
 
 	ConfigHandler::Deallocate();
 }
 
-Export(int) Init(bool isServer, int id)
+
+/**
+ * @brief uninitialize the unitsync library
+ */
+Export(void) UnInit()
 {
-	UnInit();
-	logOutput.Print(&quot;unitsync initialized\n&quot;);
-
 	try {
-		// first call to GetInstance() initializes the VFS
-		FileSystemHandler::Initialize(false);
-
-		if (isServer) {
-			logOutput.Print(&quot;unitsync: hosting\n&quot;);
-			syncer = new CSyncServer(id);
-		}
-		else {
-			logOutput.Print(&quot;unitsync: joining\n&quot;);
-			syncer = new CSyncer(id);
-		}
+		_UnInit();
 	}
-	catch (const std::exception&amp; e) {
-		Message(e.what());
-		return 0;
-	}
-
-	return 1;
+	UNITSYNC_CATCH_BLOCKS;
 }
 
-Export(int) ProcessUnits(void)
-{
-	logOutput.Print(&quot;syncer: process units\n&quot;);
-	return syncer-&gt;ProcessUnits();
-}
 
-Export(int) ProcessUnitsNoChecksum(void)
+/**
+ * @brief initialize the unitsync library
+ *
+ * Call this function before calling any other function in unitsync.
+ * In case unitsync was already initialized, it is uninitialized and then
+ * reinitialized.
+ *
+ * @return zero on failure, non-zero on success
+ */
+Export(int) Init(bool isServer, int id)
 {
-	logOutput.Print(&quot;syncer: process units\n&quot;);
-	return syncer-&gt;ProcessUnits(false);
-}
+	try {
+		_UnInit();
 
-Export(const char*) GetCurrentList()
-{
-	logOutput.Print(&quot;syncer: get current list\n&quot;);
-	string tmp = syncer-&gt;GetCurrentList();
-/*	int tmpLen = (int)tmp.length();
+		FileSystemHandler::Initialize(false);
 
-	if (tmpLen &gt; *bufLen) {
-		*bufLen = tmpLen;
-		return -1;
-	}
+		std::vector&lt;string&gt; filesToCheck;
+		filesToCheck.push_back(&quot;base/springcontent.sdz&quot;);
+		filesToCheck.push_back(&quot;base/maphelper.sdz&quot;);
+		filesToCheck.push_back(&quot;base/spring/bitmaps.sdz&quot;);
+		filesToCheck.push_back(&quot;base/cursors.sdz&quot;);
 
-	strcpy(buffer, tmp.c_str());
-	buffer[tmpLen] = 0;
-	*bufLen = tmpLen;
+		for (std::vector&lt;string&gt;::const_iterator it = filesToCheck.begin(); it != filesToCheck.end(); ++it) {
+			CFileHandler f(*it, SPRING_VFS_RAW);
+			if (!f.FileExists()) {
+				throw content_error(&quot;Required base file '&quot; + *it + &quot;' does not exist.&quot;);
+			}
+		}
 
-	return tmpLen; */
-
-	return GetStr(tmp);
+		syncer = new CSyncer();
+		logOutput.Print(LOG_UNITSYNC, &quot;initialized, %s\n&quot;, VERSION_STRING_DETAILED);
+		logOutput.Print(LOG_UNITSYNC, &quot;%s\n&quot;, isServer ? &quot;hosting&quot; : &quot;joining&quot;);
+		return 1;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
-Export(void) AddClient(int id, const char *unitList)
-{
-	logOutput.Print(&quot;syncer: add client\n&quot;);
-	((CSyncServer *)syncer)-&gt;AddClient(id, unitList);
-}
 
-Export(void) RemoveClient(int id)
+/**
+ * @brief get the main, writable, data directory that's used by unitsync and Spring
+ */
+Export(const char*) GetWritableDataDirectory()
 {
-	logOutput.Print(&quot;syncer: remove client\n&quot;);
-	((CSyncServer *)syncer)-&gt;RemoveClient(id);
+	try {
+		CheckInit();
+		return GetStr(FileSystemHandler::GetInstance().GetWriteDir());
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
-Export(const char*) GetClientDiff(int id)
+// TODO (when needed): GetDataDirectoryCount(), GetDataDirectory(int index)
+
+
+/**
+ * @brief process another unit and return how many are left to process
+ * @return int The number of unprocessed units to be handled
+ *
+ * Call this function repeatedly until it returns 0 before calling any other function related to units.
+ *
+ * Because of risk for infinite loops, this function can not return any error code.
+ * It is advised to poll GetNextError() after calling this function.
+ */
+Export(int) ProcessUnits(void)
 {
-	logOutput.Print(&quot;syncer: get client diff\n&quot;);
-	string tmp = ((CSyncServer *)syncer)-&gt;GetClientDiff(id);
-	return GetStr(tmp);
+	try {
+		logOutput.Print(LOG_UNITSYNC, &quot;syncer: process units\n&quot;);
+		return syncer-&gt;ProcessUnits();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
-Export(void) InstallClientDiff(const char *diff)
+
+/**
+ * @brief identical to ProcessUnits, neither generates checksum anymore
+ */
+Export(int) ProcessUnitsNoChecksum(void)
 {
-	logOutput.Print(&quot;syncer: install client diff\n&quot;);
-	syncer-&gt;InstallClientDiff(diff);
+	return ProcessUnits();
 }
 
+
+/**
+ * @brief returns the number of units
+ * @return int number of units processed and available, 0 on error
+ *
+ * Will return the number of units. Remember to call processUnits() beforehand until it returns 0.
+ * As ProcessUnits is called the number of processed units goes up, and so will the value returned
+ * by this function.
+ *
+ * Example:
+ *		while (ProcessUnits()) {}
+ *		int unit_number = GetUnitCount();
+ */
 Export(int) GetUnitCount()
 {
-	logOutput.Print(&quot;syncer: get unit count\n&quot;);
-	return syncer-&gt;GetUnitCount();
+	try {
+		logOutput.Print(LOG_UNITSYNC, &quot;syncer: get unit count\n&quot;);
+		return syncer-&gt;GetUnitCount();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
+
+/**
+ * @brief returns the units internal mod name
+ * @param int the units id number
+ * @return const char* The units internal modname or NULL on error.
+ *
+ * This function returns the units internal mod name. For example it would return armck and not
+ * Arm Construction kbot.
+ */
 Export(const char*) GetUnitName(int unit)
 {
-	logOutput.Print(&quot;syncer: get unit %d name\n&quot;, unit);
-	string tmp = syncer-&gt;GetUnitName(unit);
-	return GetStr(tmp);
+	try {
+		logOutput.Print(LOG_UNITSYNC, &quot;syncer: get unit %d name\n&quot;, unit);
+		string tmp = syncer-&gt;GetUnitName(unit);
+		return GetStr(tmp);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
+
+/**
+ * @brief returns The units human readable name
+ * @param int The units id number
+ * @return const char* The Units human readable name or NULL on error.
+ *
+ * This function returns the units human name. For example it would return Arm Construction kbot
+ * and not armck.
+ */
 Export(const char*) GetFullUnitName(int unit)
 {
-	logOutput.Print(&quot;syncer: get full unit %d name\n&quot;, unit);
-	string tmp = syncer-&gt;GetFullUnitName(unit);
-	return GetStr(tmp);
+	try {
+		logOutput.Print(LOG_UNITSYNC, &quot;syncer: get full unit %d name\n&quot;, unit);
+		string tmp = syncer-&gt;GetFullUnitName(unit);
+		return GetStr(tmp);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
-Export(int) IsUnitDisabled(int unit)
-{
-	logOutput.Print(&quot;syncer: is unit %d disabled\n&quot;, unit);
-	if (syncer-&gt;IsUnitDisabled(unit))
-		return 1;
-	else
-		return 0;
-}
-
-Export(int) IsUnitDisabledByClient(int unit, int clientId)
-{
-	logOutput.Print(&quot;syncer: is unit %d disabled by client %d\n&quot;, unit, clientId);
-	if (syncer-&gt;IsUnitDisabledByClient(unit, clientId))
-		return 1;
-	else
-		return 0;
-}
-
 //////////////////////////
 //////////////////////////
 
+/**
+ * @brief adds an archive to the VFS (Virtual File System)
+ *
+ * After this, the contents of the archive are available to other unitsync functions,
+ * for example: OpenFileVFS, ReadFileVFS, FileSizeVFS, etc.
+ */
 Export(void) AddArchive(const char* name)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(name);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(name);
 
-	vfsHandler-&gt;AddArchive(name, false);
+		logOutput.Print(LOG_UNITSYNC, &quot;adding archive: %s\n&quot;, name);
+		vfsHandler-&gt;AddArchive(name, false);
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
+
+/**
+ * @brief adds an achive and all it's dependencies to the VFS
+ *
+ * After this, the contents of the archive are available to other unitsync functions,
+ * for example: OpenFileVFS, ReadFileVFS, FileSizeVFS, etc.
+ */
 Export(void) AddAllArchives(const char* root)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(root);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(root);
 
-	vector&lt;string&gt; ars = archiveScanner-&gt;GetArchives(root);
-//	Message(root);
-	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
-		logOutput.Print(&quot;adding archive: %s\n&quot;, i-&gt;c_str());
-		vfsHandler-&gt;AddArchive(*i, false);
+		vector&lt;string&gt; ars = archiveScanner-&gt;GetArchives(root);
+		for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i) {
+			logOutput.Print(LOG_UNITSYNC, &quot;adding archive: %s\n&quot;, i-&gt;c_str());
+			vfsHandler-&gt;AddArchive(*i, false);
+		}
 	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
+
+/**
+ * @brief gets checksum of an archive
+ *
+ * This checksum depends only on the contents from the archive itself, and not
+ * on the contents from dependencies of this archive (if any).
+ */
 Export(unsigned int) GetArchiveChecksum(const char* arname)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(arname);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(arname);
 
-	logOutput.Print(&quot;archive checksum: %s\n&quot;, arname);
-	return archiveScanner-&gt;GetArchiveChecksum(arname);
+		logOutput.Print(LOG_UNITSYNC, &quot;archive checksum: %s\n&quot;, arname);
+		return archiveScanner-&gt;GetArchiveChecksum(arname);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
+
+/**
+ * @brief gets the real path to the archive
+ */
 Export(const char*) GetArchivePath(const char* arname)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(arname);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(arname);
 
-	logOutput.Print(&quot;archive path: %s\n&quot;, arname);
-	return GetStr(archiveScanner-&gt;GetArchivePath(arname));
+		logOutput.Print(LOG_UNITSYNC, &quot;archive path: %s\n&quot;, arname);
+		return GetStr(archiveScanner-&gt;GetArchivePath(arname));
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
+
 // Updated on every call to GetMapCount
 static vector&lt;string&gt; mapNames;
 
+
+/**
+ * @brief gets the number of maps available
+ *
+ * Call this before any of the map functions which take a map index as parameter.
+ */
 Export(int) GetMapCount()
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapCount.&quot;);
-	//vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;{maps/*.smf,maps/*.sm3}&quot;);
-	vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;maps/&quot;, &quot;{*.smf,*.sm3}&quot;);
-	vector&lt;string&gt; ars = archiveScanner-&gt;GetMaps();
-/*	vector&lt;string&gt; files2 = CFileHandler::FindFiles(&quot;maps/*.sm3&quot;);
-	unsigned int nfiles=files.size();
-	files.resize(files.size()+files2.size());
-	copy(files2.begin(),files2.end(),files.begin()+nfiles);
-*/
-	mapNames.clear();
-	for (vector&lt;string&gt;::iterator i = files.begin(); i != files.end(); ++i) {
-		string mn = *i;
-		mn = mn.substr(mn.find_last_of('/') + 1);
-		mapNames.push_back(mn);
+	try {
+		CheckInit();
+
+		//vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;{maps/*.smf,maps/*.sm3}&quot;);
+		vector&lt;string&gt; files = CFileHandler::FindFiles(&quot;maps/&quot;, &quot;{*.smf,*.sm3}&quot;);
+		vector&lt;string&gt; ars = archiveScanner-&gt;GetMaps();
+
+		mapNames.clear();
+		for (vector&lt;string&gt;::iterator i = files.begin(); i != files.end(); ++i) {
+			string mn = *i;
+			mn = mn.substr(mn.find_last_of('/') + 1);
+			mapNames.push_back(mn);
+		}
+		for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
+			mapNames.push_back(*i);
+		sort(mapNames.begin(), mapNames.end());
+
+		return mapNames.size();
 	}
-	for (vector&lt;string&gt;::iterator i = ars.begin(); i != ars.end(); ++i)
-		mapNames.push_back(*i);
-	sort(mapNames.begin(), mapNames.end());
-
-	return mapNames.size();
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
+
+/**
+ * @brief get the name of a map, e.g. &quot;SmallDivide.smf&quot;
+ */
 Export(const char*) GetMapName(int index)
 {
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetMapName.&quot;);
-	ASSERT((unsigned)index &lt; mapNames.size(), &quot;Array index out of bounds. Call GetMapCount before GetMapName.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, mapNames.size());
 
-	return GetStr(mapNames[index]);
+		return GetStr(mapNames[index]);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
-Export(int) GetMapInfoEx(const char* name, MapInfo* outInfo, int version)
+static void safe_strzcpy(char* dst, std::string src, size_t max)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(name);
-	CHECK_NULL(outInfo);
+	if (src.length() &gt; max-1) {
+		src = src.substr(0, max-1);
+	}
+	strcpy(dst, src.c_str());
+}
 
+
+static int _GetMapInfoEx(const char* name, MapInfo* outInfo, int version)
+{
+	CheckInit();
+	CheckNullOrEmpty(name);
+	CheckNull(outInfo);
+
+	logOutput.Print(LOG_UNITSYNC, &quot;get map info: %s&quot;, name);
+
 	const string mapName = name;
 	ScopedMapLoader mapLoader(mapName);
 
@@ -417,11 +603,9 @@
 	}
 
 	// If the map didn't parse, say so now
-	if (err.length() &gt; 0) {
-		if (err.length() &gt; 254) {
-			err = err.substr(0, 254);
-		}
-		strcpy(outInfo-&gt;description, err.c_str());
+	if (!err.empty()) {
+		SetLastError(err);
+		safe_strzcpy(outInfo-&gt;description, err, 255);
 
 		// Fill in stuff so tasclient won't crash
 		outInfo-&gt;posCount = 0;
@@ -432,7 +616,7 @@
 	}
 
 	const string desc = mapTable.GetString(&quot;description&quot;, &quot;&quot;);
-	strncpy(outInfo-&gt;description, desc.c_str(), 254);
+	safe_strzcpy(outInfo-&gt;description, desc, 255);
 
 	outInfo-&gt;tidalStrength   = mapTable.GetInt(&quot;tidalstrength&quot;, 0);
 	outInfo-&gt;gravity         = mapTable.GetInt(&quot;gravity&quot;, 0);
@@ -441,7 +625,7 @@
 
 	if (version &gt;= 1) {
 		const string author = mapTable.GetString(&quot;author&quot;, &quot;&quot;);
-		strncpy(outInfo-&gt;author, author.c_str(), 200);
+		safe_strzcpy(outInfo-&gt;author, author, 200);
 	}
 
 	const LuaTable atmoTable = mapTable.SubTable(&quot;atmosphere&quot;);
@@ -457,6 +641,7 @@
 		}
 		outInfo-&gt;positions[curTeam].x = pos.x;
 		outInfo-&gt;positions[curTeam].z = pos.z;
+		logOutput.Print(LOG_UNITSYNC, &quot;  startpos: %.0f, %.0f&quot;, pos.x, pos.z);
 	}
 
 	outInfo-&gt;posCount = curTeam;
@@ -465,47 +650,89 @@
 }
 
 
+/**
+ * @brief get map info
+ * @param name name of the map, e.g. &quot;SmallDivide.smf&quot;
+ * @param outInfo pointer to structure which is filled with map info
+ * @param version this determines which fields of the MapInfo structure are filled
+ * @return zero on failure, non-zero on success
+ *
+ * If version &gt;= 1, then the author field is filled.
+ */
+Export(int) GetMapInfoEx(const char* name, MapInfo* outInfo, int version)
+{
+	try {
+		return _GetMapInfoEx(name, outInfo, version);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
+}
+
+
+/**
+ * @brief get map info, equivalent to GetMapInfoEx(name, outInfo, 0)
+ * @param name name of the map, e.g. &quot;SmallDivide.smf&quot;
+ * @param outInfo pointer to structure which is filled with map info
+ * @return zero on failure, non-zero on success
+ */
 Export(int) GetMapInfo(const char* name, MapInfo* outInfo)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(name);
-	CHECK_NULL(outInfo);
-
-	return GetMapInfoEx(name, outInfo, 0);
+	try {
+		return _GetMapInfoEx(name, outInfo, 0);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
+
 static vector&lt;string&gt; mapArchives;
 
 Export(int) GetMapArchiveCount(const char* mapName)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(mapName);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(mapName);
 
-	mapArchives = archiveScanner-&gt;GetArchivesForMap(mapName);
-	return mapArchives.size();
+		mapArchives = archiveScanner-&gt;GetArchivesForMap(mapName);
+		return mapArchives.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(const char*) GetMapArchiveName(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; mapArchives.size(), &quot;Array index out of bounds. Call GetMapArchiveCount before GetMapArchiveName.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, mapArchives.size());
 
-	return GetStr(mapArchives[index]);
+		return GetStr(mapArchives[index]);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 Export(unsigned int) GetMapChecksum(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; mapNames.size(), &quot;Array index out of bounds. Call GetMapCount before GetMapChecksum.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, mapNames.size());
 
-	return archiveScanner-&gt;GetMapChecksum(mapNames[index]);
+		return archiveScanner-&gt;GetMapChecksum(mapNames[index]);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(unsigned int) GetMapChecksumFromName(const char* mapName)
 {
-	CHECK_INIT();
+	try {
+		CheckInit();
 
-	return archiveScanner-&gt;GetMapChecksum(mapName);
+		return archiveScanner-&gt;GetMapChecksum(mapName);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 #define RM	0x0000F800
@@ -518,7 +745,7 @@
 #define PACKRGB(r, g, b) (((r&lt;&lt;11)&amp;RM) | ((g &lt;&lt; 5)&amp;GM) | (b&amp;BM) )
 
 // Used to return the image
-char* imgbuf[1024*1024*2];
+static char* imgbuf[1024*1024*2];
 
 static void* GetMinimapSM3(string mapName, int miplevel)
 {
@@ -564,8 +791,7 @@
 	int mipsize = 1024;
 	int offset = 0;
 
-	for ( int i = 0; i &lt; miplevel; i++ )
-	{
+	for ( int i = 0; i &lt; miplevel; i++ ) {
 		int size = ((mipsize+3)/4)*((mipsize+3)/4)*8;
 		offset += size;
 		mipsize &gt;&gt;= 1;
@@ -576,77 +802,62 @@
 
 	// Read the map data
 	CFileHandler in(&quot;maps/&quot; + mapName);
-	unsigned char* buffer = (unsigned char*)malloc(size);
 
-	if (in.FileExists()) {
-		SMFHeader mh;
-		in.Read(&amp;mh, sizeof(mh));
-		in.Seek(mh.minimapPtr + offset);
-		in.Read(buffer, size);
+	if (!in.FileExists()) {
+		throw content_error(&quot;File '&quot; + mapName + &quot;' does not exist&quot;);
 	}
-	else {
-		free(buffer);
-		return NULL;
-	}
 
+	unsigned char* buffer = (unsigned char*)malloc(size);
+
+	SMFHeader mh;
+	in.Read(&amp;mh, sizeof(mh));
+	in.Seek(mh.minimapPtr + offset);
+	in.Read(buffer, size);
+
 	// Do stuff
 
-	//void* ret = malloc(mipsize*mipsize*2);
 	void* ret = (void*)imgbuf;
 	unsigned short* colors = (unsigned short*)ret;
 
 	unsigned char* temp = buffer;
 
-	for ( int i = 0; i &lt; numblocks; i++ )
-	{
+	for ( int i = 0; i &lt; numblocks; i++ ) {
 		unsigned short color0 = (*(unsigned short*)&amp;temp[0]);
 		unsigned short color1 = (*(unsigned short*)&amp;temp[2]);
 		unsigned int bits = (*(unsigned int*)&amp;temp[4]);
 
-		for ( int a = 0; a &lt; 4; a++ )
-		{
-			for ( int b = 0; b &lt; 4; b++ )
-			{
+		for ( int a = 0; a &lt; 4; a++ ) {
+			for ( int b = 0; b &lt; 4; b++ ) {
 				int x = 4*(i % ((mipsize+3)/4))+b;
 				int y = 4*(i / ((mipsize+3)/4))+a;
 				unsigned char code = bits &amp; 0x3;
 				bits &gt;&gt;= 2;
 
-				if ( color0 &gt; color1 )
-				{
-					if ( code == 0 )
-					{
+				if ( color0 &gt; color1 ) {
+					if ( code == 0 ) {
 						colors[y*mipsize+x] = color0;
 					}
-					else if ( code == 1 )
-					{
+					else if ( code == 1 ) {
 						colors[y*mipsize+x] = color1;
 					}
-					else if ( code == 2 )
-					{
+					else if ( code == 2 ) {
 						colors[y*mipsize+x] = PACKRGB((2*RED_RGB565(color0)+RED_RGB565(color1))/3, (2*GREEN_RGB565(color0)+GREEN_RGB565(color1))/3, (2*BLUE_RGB565(color0)+BLUE_RGB565(color1))/3);
 					}
-					else
-					{
+					else {
 						colors[y*mipsize+x] = PACKRGB((2*RED_RGB565(color1)+RED_RGB565(color0))/3, (2*GREEN_RGB565(color1)+GREEN_RGB565(color0))/3, (2*BLUE_RGB565(color1)+BLUE_RGB565(color0))/3);
 					}
 				}
-				else
-				{
-					if ( code == 0 )
-					{
+				else {
+					if ( code == 0 ) {
 						colors[y*mipsize+x] = color0;
 					}
-					else if ( code == 1 )
-					{
+					else if ( code == 1 ) {
 						colors[y*mipsize+x] = color1;
 					}
-					else if ( code == 2 )
-					{
+					else if ( code == 2 ) {
 						colors[y*mipsize+x] = PACKRGB((RED_RGB565(color0)+RED_RGB565(color1))/2, (GREEN_RGB565(color0)+GREEN_RGB565(color1))/2, (BLUE_RGB565(color0)+BLUE_RGB565(color1))/2);
 					}
-					else
-					{
+					else {
 						colors[y*mipsize+x] = 0;
 					}
 				}
@@ -658,26 +869,48 @@
 	return (void*)ret;
 }
 
+/**
+ * @brief Retrieves a minimap image for a map.
+ * @param filename The name of the map, including extension.
+ * @param miplevel Which miplevel of the minimap to extract from the file.
+ * Set miplevel to 0 to get the largest, 1024x1024 minimap. Each increment
+ * divides the width and height by 2. The maximum miplevel is 8, resulting in a
+ * 4x4 image.
+ * @return A pointer to a static memory area containing the minimap as a 16 bit
+ * packed RGB-565 (MSB to LSB: 5 bits red, 6 bits green, 5 bits blue) linear
+ * bitmap.
+ *
+ * An example usage would be GetMinimap(&quot;SmallDivide.smf&quot;, 2).
+ * This would return a 16 bit packed RGB-565 256x256 (= 1024/2^2) bitmap.
+ *
+ * Be sure you've made a call to Init prior to using this.
+ */
 Export(void*) GetMinimap(const char* filename, int miplevel)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(filename);
-	ASSERT(miplevel &gt;= 0 &amp;&amp; miplevel &lt;= 8, &quot;Miplevel must be between 0 and 8 (inclusive) in GetMinimap.&quot;);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(filename);
 
-	const string mapName = filename;
-	ScopedMapLoader mapLoader(mapName);
+		if (miplevel &lt; 0 || miplevel &gt; 8)
+			throw std::out_of_range(&quot;Miplevel must be between 0 and 8 (inclusive) in GetMinimap.&quot;);
 
-	const string extension = mapName.substr(mapName.length() - 3);
+		const string mapName = filename;
+		ScopedMapLoader mapLoader(mapName);
 
-	void* ret = NULL;
+		const string extension = mapName.substr(mapName.length() - 3);
 
-	if (extension == &quot;smf&quot;) {
-		ret = GetMinimapSMF(mapName, miplevel);
-	} else if (extension == &quot;sm3&quot;) {
-		ret = GetMinimapSM3(mapName, miplevel);
+		void* ret = NULL;
+
+		if (extension == &quot;smf&quot;) {
+			ret = GetMinimapSMF(mapName, miplevel);
+		} else if (extension == &quot;sm3&quot;) {
+			ret = GetMinimapSM3(mapName, miplevel);
+		}
+
+		return ret;
 	}
-
-	return ret;
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
@@ -692,13 +925,13 @@
  */
 Export(int) GetInfoMapSize(const char* filename, const char* name, int* width, int* height)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(filename);
-	CHECK_NULL_OR_EMPTY(name);
-	CHECK_NULL(width);
-	CHECK_NULL(height);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(filename);
+		CheckNullOrEmpty(name);
+		CheckNull(width);
+		CheckNull(height);
 
-	try {
 		ScopedMapLoader mapLoader(filename);
 		CSmfMapFile file(filename);
 		MapBitmapInfo bmInfo = file.GetInfoMapSize(name);
@@ -708,9 +941,11 @@
 
 		return bmInfo.width &gt; 0;
 	}
-	catch (content_error&amp;) {
-	}
+	UNITSYNC_CATCH_BLOCKS;
 
+	if (width)  *width  = 0;
+	if (height) *height = 0;
+
 	return 0;
 }
 
@@ -733,14 +968,13 @@
  */
 Export(int) GetInfoMap(const char* filename, const char* name, void* data, int typeHint)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(filename);
-	CHECK_NULL_OR_EMPTY(name);
-	CHECK_NULL(data);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(filename);
+		CheckNullOrEmpty(name);
+		CheckNull(data);
 
-	string n = name;
-
-	try {
+		string n = name;
 		ScopedMapLoader mapLoader(filename);
 		CSmfMapFile file(filename);
 		int actualType = (n == &quot;height&quot; ? bm_grayscale_16 : bm_grayscale_8);
@@ -770,13 +1004,10 @@
 			return 1;
 		}
 		else if (actualType == bm_grayscale_8 &amp;&amp; typeHint == bm_grayscale_16) {
-			// converting from 8 bits per pixel to 16 bits per pixel is unsupported
-			return 0;
+			throw content_error(&quot;converting from 8 bits per pixel to 16 bits per pixel is unsupported&quot;);
 		}
 	}
-	catch (content_error&amp;) {
-	}
-
+	UNITSYNC_CATCH_BLOCKS;
 	return 0;
 }
 
@@ -787,22 +1018,45 @@
 vector&lt;CArchiveScanner::ModData&gt; modData;
 
 
+/**
+ * @brief Retrieves the name of this mod
+ * @return int The number of mods
+ *
+ * Returns the name of the mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(int) GetPrimaryModCount()
 {
-	CHECK_INIT();
+	try {
+		CheckInit();
 
-	modData = archiveScanner-&gt;GetPrimaryMods();
-	return modData.size();
+		modData = archiveScanner-&gt;GetPrimaryMods();
+		return modData.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
+/**
+ * @brief Retrieves the name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods name
+ *
+ * Returns the name of the mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(const char*) GetPrimaryModName(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModName.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].name;
-	return GetStr(x);
+		string x = modData[index].name;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
@@ -816,119 +1070,223 @@
  */
 Export(const char*) GetPrimaryModShortName(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModShortName.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].shortName;
-	return GetStr(x);
+		string x = modData[index].shortName;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
+/**
+ * @brief Retrieves the version string of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods version string
+ *
+ * Returns value of the mutator tag for the specified mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(const char*) GetPrimaryModVersion(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModMutator.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].version;
-	return GetStr(x);
+		string x = modData[index].version;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
+/**
+ * @brief Retrieves the mutator name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods mutator name
+ *
+ * Returns value of the mutator tag for the specified mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(const char*) GetPrimaryModMutator(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModMutator.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].mutator;
-	return GetStr(x);
+		string x = modData[index].mutator;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
+/**
+ * @brief Retrieves the game name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods game
+ *
+ * Returns the name of the game this mod belongs to usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(const char*) GetPrimaryModGame(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModName.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].game;
-	return GetStr(x);
+		string x = modData[index].game;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
+/**
+ * @brief Retrieves the short game name of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods abbrieviated game name
+ *
+ * Returns the abbrieviated name of the game this mod belongs to usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(const char*) GetPrimaryModShortGame(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModShortGame.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].shortGame;
-	return GetStr(x);
+		string x = modData[index].shortGame;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
+/**
+ * @brief Retrieves the description of this mod
+ * @param index in The mods index/id
+ * @return const char* The mods description
+ *
+ * Returns a description for the specified mod usually found in modinfo.tdf.
+ * Be sure you've made calls to Init and GetPrimaryModCount prior to using this.
+ */
 Export(const char*) GetPrimaryModDescription(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModDescription.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	string x = modData[index].description;
-	return GetStr(x);
+		string x = modData[index].description;
+		return GetStr(x);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetPrimaryModArchive(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModArchive.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	return GetStr(modData[index].dependencies[0]);
+		return GetStr(modData[index].dependencies[0]);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 vector&lt;string&gt; primaryArchives;
 
+/**
+ * @brief Retrieves the number of archives a mod requires
+ * @param index int The index of the mod
+ * @return the number of archives this mod depends on.
+ *
+ * This is used to get the entire list of archives that a mod requires.
+ * Call GetPrimaryModArchiveCount() with selected mod first to get number of
+ * archives, and then use GetPrimaryModArchiveList() for 0 to count-1 to get the
+ * name of each archive.
+ */
 Export(int) GetPrimaryModArchiveCount(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModArchiveCount.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	primaryArchives = archiveScanner-&gt;GetArchives(modData[index].dependencies[0]);
-	return primaryArchives.size();
+		primaryArchives = archiveScanner-&gt;GetArchives(modData[index].dependencies[0]);
+		return primaryArchives.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
+/**
+ * @brief Retrieves the name of the current mod's archive.
+ * @param arnr The mod's archive index/id.
+ * @return the name of the archive
+ * @see GetPrimaryModArchiveCount()
+ */
 Export(const char*) GetPrimaryModArchiveList(int archiveNr)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)archiveNr &lt; primaryArchives.size(), &quot;Array index out of bounds. Call GetPrimaryModArchiveCount before GetPrimaryModArchiveList.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(archiveNr, primaryArchives.size());
 
-	logOutput.Print(&quot;primary mod archive list: %s\n&quot;, primaryArchives[archiveNr].c_str());
-	return GetStr(primaryArchives[archiveNr]);
+		logOutput.Print(LOG_UNITSYNC, &quot;primary mod archive list: %s\n&quot;, primaryArchives[archiveNr].c_str());
+		return GetStr(primaryArchives[archiveNr]);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 Export(int) GetPrimaryModIndex(const char* name)
 {
-	CHECK_INIT();
+	try {
+		CheckInit();
 
-	string n(name);
-	for (unsigned i = 0; i &lt; modData.size(); ++i) {
-		if (modData[i].name == n)
-			return i;
+		string n(name);
+		for (unsigned i = 0; i &lt; modData.size(); ++i) {
+			if (modData[i].name == n)
+				return i;
+		}
 	}
+	UNITSYNC_CATCH_BLOCKS;
+
 	// if it returns -1, make sure you call GetPrimaryModCount before GetPrimaryModIndex.
 	return -1;
 }
 
 Export(unsigned int) GetPrimaryModChecksum(int index)
 {
-	CHECK_INIT();
-	ASSERT((unsigned)index &lt; modData.size(), &quot;Array index out of bounds. Call GetPrimaryModCount before GetPrimaryModChecksum.&quot;);
+	try {
+		CheckInit();
+		CheckBounds(index, modData.size());
 
-	return archiveScanner-&gt;GetModChecksum(GetPrimaryModArchive(index));
+		return archiveScanner-&gt;GetModChecksum(GetPrimaryModArchive(index));
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(unsigned int) GetPrimaryModChecksumFromName(const char* name)
 {
-	CHECK_INIT();
+	try {
+		CheckInit();
 
-	return archiveScanner-&gt;GetModChecksum(archiveScanner-&gt;ModNameToModArchive(name));
+		return archiveScanner-&gt;GetModChecksum(archiveScanner-&gt;ModNameToModArchive(name));
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
@@ -937,28 +1295,43 @@
 
 Export(int) GetSideCount()
 {
-	if (!sideParser.Load()) {
-		logOutput.Print(&quot;failed: %s\n&quot;, sideParser.GetErrorLog().c_str());
-		return 0;
+	try {
+		CheckInit();
+
+		if (!sideParser.Load()) {
+			throw content_error(&quot;failed: &quot; + sideParser.GetErrorLog());
+		}
+		return sideParser.GetCount();
 	}
-	return sideParser.GetCount();
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
 Export(const char*) GetSideName(int side)
 {
-	ASSERT((unsigned int)side &lt; sideParser.GetCount(),
-	       &quot;Array index out of bounds. Call GetSideCount before GetSideName.&quot;);
-	// the full case name  (not the lowered version)
-	return GetStr(sideParser.GetCaseName(side));
+	try {
+		CheckInit();
+		CheckBounds(side, sideParser.GetCount());
+
+		// the full case name  (not the lowered version)
+		return GetStr(sideParser.GetCaseName(side));
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetSideStartUnit(int side)
 {
-	ASSERT((unsigned int)side &lt; sideParser.GetCount(),
-	       &quot;Array index out of bounds. Call GetSideCount before GetSideStartUnit.&quot;);
-	return GetStr(sideParser.GetStartUnit(side));
+	try {
+		CheckInit();
+		CheckBounds(side, sideParser.GetCount());
+
+		return GetStr(sideParser.GetStartUnit(side));
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
@@ -980,12 +1353,12 @@
 
 	LuaParser luaParser(&quot;LuaAI.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
 	if (!luaParser.Execute()) {
-		return;
+		throw content_error(&quot;luaParser.Execute() failed: &quot; + luaParser.GetErrorLog());
 	}
 
 	const LuaTable root = luaParser.GetRoot();
 	if (!root.IsValid()) {
-		return;
+		throw content_error(&quot;root table invalid&quot;);
 	}
 
 	for (int i = 1; root.KeyExists(i); i++) {
@@ -1011,33 +1384,45 @@
 		aiData.desc = optTbl.GetString(&quot;desc&quot;, aiData.name);
 		luaAIOptions.push_back(aiData);
 	}
-
-	return;
 }
 
 
 Export(int) GetLuaAICount()
 {
-	GetLuaAIOptions();
-	return luaAIOptions.size();
+	try {
+		CheckInit();
+
+		GetLuaAIOptions();
+		return luaAIOptions.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
 Export(const char*) GetLuaAIName(int aiIndex)
 {
-	if ((aiIndex &lt; 0) || (aiIndex &gt;= (int)luaAIOptions.size())) {
-		return NULL;
+	try {
+		CheckInit();
+		CheckBounds(aiIndex, luaAIOptions.size());
+
+		return GetStr(luaAIOptions[aiIndex].name);
 	}
-	return GetStr(luaAIOptions[aiIndex].name);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetLuaAIDesc(int aiIndex)
 {
-	if ((aiIndex &lt; 0) || (aiIndex &gt;= (int)luaAIOptions.size())) {
-		return NULL;
+	try {
+		CheckInit();
+		CheckBounds(aiIndex, luaAIOptions.size());
+
+		return GetStr(luaAIOptions[aiIndex].desc);
 	}
-	return GetStr(luaAIOptions[aiIndex].desc);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
@@ -1053,23 +1438,27 @@
 {
 	const LuaTable&amp; optTbl = root.SubTable(index);
 	if (!optTbl.IsValid()) {
+		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: subtable %d invalid&quot;, index);
 		return false;
 	}
 
 	// common options properties
 	std::string opt_key = optTbl.GetString(&quot;key&quot;, &quot;&quot;);
 	if (opt_key.empty() ||
-	    (opt_key.find_first_of(Option_badKeyChars) != std::string::npos)) {
+		(opt_key.find_first_of(Option_badKeyChars) != std::string::npos)) {
+		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: empty key or key contains bad characters&quot;);
 		return false;
 	}
 	opt_key = StringToLower(opt_key);
 	if (optionsSet.find(opt_key) != optionsSet.end()) {
+		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: key %s exists already&quot;, opt_key.c_str());
 		return false;
 	}
 	opt.key = mallocCopyString(opt_key.c_str());
 	
 	std::string opt_name = optTbl.GetString(&quot;name&quot;, opt_key);
 	if (opt_name.empty()) {
+		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty name&quot;, opt.key);
 		return false;
 	}
 	opt.name = mallocCopyString(opt_name.c_str());
@@ -1109,6 +1498,7 @@
 
 		const LuaTable&amp; listTbl = optTbl.SubTable(&quot;items&quot;);
 		if (!listTbl.IsValid()) {
+			logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: subtable items invalid&quot;, opt.key);
 			return false;
 		}
 
@@ -1119,7 +1509,7 @@
 			// string format
 			std::string item_key = listTbl.GetString(i, &quot;&quot;);
 			if (!item_key.empty() &amp;&amp;
-			    (item_key.find_first_of(Option_badKeyChars) == string::npos)) {
+				(item_key.find_first_of(Option_badKeyChars) == string::npos)) {
 				item.key = mallocCopyString(item_key.c_str());
 				item.name = item.key;
 				item.desc = item.name;
@@ -1130,42 +1520,43 @@
 			// table format  (name &amp; desc)
 			const LuaTable&amp; itemTbl = listTbl.SubTable(i);
 			if (!itemTbl.IsValid()) {
+				logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: subtable %d of subtable items invalid&quot;, opt.key, i);
 				break;
 			}
 			item_key = itemTbl.GetString(&quot;key&quot;, &quot;&quot;);
 			if (item_key.empty() ||
-			    (item_key.find_first_of(Option_badKeyChars) != string::npos)) {
+				(item_key.find_first_of(Option_badKeyChars) != string::npos)) {
+				logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty key or key contains bad characters&quot;, opt.key);
 				return false;
 			}
 			item_key = StringToLower(item_key);
-			//item.key = item_key.c_str();
 			item.key = mallocCopyString(item_key.c_str());
 			std::string item_name = itemTbl.GetString(&quot;name&quot;, item_key);
 			if (item_name.empty()) {
+				logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty name&quot;, opt.key);
 				return false;
 			}
-			//item.name = item_name.c_str();
 			item.name = mallocCopyString(item_name.c_str());
 			std::string item_desc = itemTbl.GetString(&quot;desc&quot;, item_name);
-			//item.desc = item_desc.c_str();
 			item.desc = mallocCopyString(item_desc.c_str());
 			opt_list.push_back(item);
 		}
 
 		if (opt_list.size() &lt;= 0) {
+			logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: empty list&quot;, opt.key);
 			return false; // no empty lists
 		}
-		
+
 		opt.numListItems = opt_list.size();
 		opt.list = (OptionListItem*) calloc(sizeof(OptionListItem), opt.numListItems);
-        for (int i=0; i &lt; opt.numListItems; ++i) {
-            opt.list[i] = opt_list.at(i);
-        }
+		for (int i=0; i &lt; opt.numListItems; ++i) {
+			opt.list[i] = opt_list.at(i);
+		}
 
-		//opt.listDef = optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str();
 		opt.listDef = mallocCopyString(optTbl.GetString(&quot;def&quot;, opt.list[0].name).c_str());
 	}
 	else {
+		logOutput.Print(LOG_UNITSYNC, &quot;ParseOption: %s: unknown type %s&quot;, opt.key, opt_type.c_str());
 		return false; // unknown type
 	}
 
@@ -1193,14 +1584,12 @@
 	}
 
 	if (!luaParser.Execute()) {
-		logOutput.Print(&quot;ParseOptions(%s) ERROR: %s\n&quot;,
-		       fileName.c_str(), luaParser.GetErrorLog().c_str());
-		return;
+		throw content_error(&quot;luaParser.Execute() failed: &quot; + luaParser.GetErrorLog());
 	}
 
 	const LuaTable root = luaParser.GetRoot();
 	if (!root.IsValid()) {
-		return;
+		throw content_error(&quot;root table invalid&quot;);
 	}
 
 	for (int index = 1; root.KeyExists(index); index++) {
@@ -1209,63 +1598,73 @@
 			options.push_back(opt);
 		}
 	}
-
-	return;
 };
 
 
-static bool InvalidOptionIndex(int optIndex)
+static void CheckOptionIndex(int optIndex)
 {
-	if ((optIndex &lt; 0) || (optIndex &gt;= (int)options.size())) {
-		return true;
-	}
-	return false;
+	CheckInit();
+	CheckBounds(optIndex, options.size());
 }
 
+static void CheckOptionType(int optIndex, int type)
+{
+	CheckOptionIndex(optIndex);
 
-static bool WrongOptionType(int optIndex, int type)
-{
-	if (InvalidOptionIndex(optIndex)) {
-		return true;
-	}
-	if (options[optIndex].typeCode != type) {
-		return true;
-	}
-	return false;
+	if (options[optIndex].typeCode != type)
+		throw std::invalid_argument(&quot;wrong option type&quot;);
 }
 
 
 Export(int) GetMapOptionCount(const char* name)
 {
-	CHECK_INIT();
-	CHECK_NULL_OR_EMPTY(name);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(name);
 
-	ScopedMapLoader mapLoader(name);
+		ScopedMapLoader mapLoader(name);
 
-	options.clear();
-	optionsSet.clear();
+		options.clear();
+		optionsSet.clear();
 
-	ParseOptions(&quot;MapOptions.lua&quot;, SPRING_VFS_MAP, SPRING_VFS_MAP, name);
+		ParseOptions(&quot;MapOptions.lua&quot;, SPRING_VFS_MAP, SPRING_VFS_MAP, name);
 
+		optionsSet.clear();
+
+		return options.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+
+	options.clear();
 	optionsSet.clear();
 
-	return (int)options.size();
+	return 0;
 }
 
 
 Export(int) GetModOptionCount()
 {
-	options.clear();
-	optionsSet.clear();
+	try {
+		CheckInit();
 
-	// EngineOptions must be read first, so accidentally &quot;overloading&quot; engine
-	// options with mod options with identical names is not possible.
-	ParseOptions(&quot;EngineOptions.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
-	ParseOptions(&quot;ModOptions.lua&quot;, SPRING_VFS_MOD, SPRING_VFS_MOD);
+		options.clear();
+		optionsSet.clear();
 
+		// EngineOptions must be read first, so accidentally &quot;overloading&quot; engine
+		// options with mod options with identical names is not possible.
+		ParseOptions(&quot;EngineOptions.lua&quot;, SPRING_VFS_MOD_BASE, SPRING_VFS_MOD_BASE);
+		ParseOptions(&quot;ModOptions.lua&quot;, SPRING_VFS_MOD, SPRING_VFS_MOD);
+
+		optionsSet.clear();
+
+		return options.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+
+	options.clear();
 	optionsSet.clear();
 
-	return (int)options.size();
+	return 0;
 }
 
 
@@ -1276,23 +1675,30 @@
 static vector&lt;string&gt; skirmishAIDataDirs;
 
 Export(int) GetSkirmishAICount() {
-	
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetSkirmishAICount.&quot;);
-	
-	skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
-	
-	// filter out dirs not containing an AIInfo.lua file 
-	for (vector&lt;string&gt;::iterator i = skirmishAIDataDirs.begin(); i != skirmishAIDataDirs.end(); ++i) {
-		const string&amp; possibleDataDir = *i;
-		vector&lt;string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
-		if (infoFile.size() == 0) {
-			skirmishAIDataDirs.erase(i);
+
+	try {
+		CheckInit();
+
+		skirmishAIDataDirs = CFileHandler::SubDirs(SKIRMISH_AI_DATA_DIR, &quot;*&quot;, SPRING_VFS_RAW);
+
+		// filter out dirs not containing an AIInfo.lua file 
+		for (vector&lt;string&gt;::iterator i = skirmishAIDataDirs.begin(); i != skirmishAIDataDirs.end(); ++i) {
+			const string&amp; possibleDataDir = *i;
+			vector&lt;string&gt; infoFile = CFileHandler::FindFiles(possibleDataDir, &quot;AIInfo.lua&quot;);
+			if (infoFile.size() == 0) {
+				skirmishAIDataDirs.erase(i);
+			}
 		}
+
+		sort(skirmishAIDataDirs.begin(), skirmishAIDataDirs.end());
+
+		return skirmishAIDataDirs.size();
 	}
-	
-	sort(skirmishAIDataDirs.begin(), skirmishAIDataDirs.end());
+	UNITSYNC_CATCH_BLOCKS;
 
-	return skirmishAIDataDirs.size();
+	skirmishAIDataDirs.clear();
+
+	return 0;
 }
 
 Export(struct SSAISpecifier) GetSkirmishAISpecifier(int index) {
@@ -1319,111 +1725,163 @@
 		const std::string&amp; accessModes)
 {
 	std::vector&lt;InfoItem&gt; info;
-	
+
 	static const unsigned int MAX_INFOS = 128;
 	InfoItem tmpInfo[MAX_INFOS];
 	unsigned int num = ParseInfo(fileName.c_str(), fileModes.c_str(),
 			accessModes.c_str(), tmpInfo, MAX_INFOS);
 	for (unsigned int i=0; i &lt; num; ++i) {
 		info.push_back(tmpInfo[i]);
-    }
-	
+	}
+
 	return info;
 }
 
+static void CheckInfoIndex(int infIndex)
+{
+	CheckInit();
+	CheckBounds(infIndex, infos.size());
+}
+
 Export(int) GetSkirmishAIInfoCount(int index) {
-	
-	ASSERT(archiveScanner &amp;&amp; vfsHandler, &quot;Call InitArchiveScanner before GetSkirmishAIInfoCount.&quot;);
-	infos = ParseInfos(skirmishAIDataDirs[index] + &quot;/AIInfo.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
-	return (int)infos.size();
+
+	try {
+		CheckInit();
+
+		infos = ParseInfos(skirmishAIDataDirs[index] + &quot;/AIInfo.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+		return (int)infos.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+
+	infos.clear();
+
+	return 0;
 }
 Export(const char*) GetInfoKey(int index) {
-	
-	ASSERT(!infos.empty(), &quot;Call GetSkirmishAIInfoCount before GetInfoKey.&quot;);
-	return infos.at(index).key;
+
+	try {
+		CheckInfoIndex(index);
+		return GetStr(infos[index].key);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 Export(const char*) GetInfoValue(int index) {
-	
-	ASSERT(!infos.empty(), &quot;Call GetSkirmishAIInfoCount before GetInfoValue.&quot;);
-	return infos.at(index).value;
+
+	try {
+		CheckInfoIndex(index);
+		return GetStr(infos[index].value);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 Export(const char*) GetInfoDescription(int index) {
-	
-	ASSERT(!infos.empty(), &quot;Call GetSkirmishAIInfoCount before GetInfoDescription.&quot;);
-	return infos.at(index).desc;
+
+	try {
+		CheckInfoIndex(index);
+		return GetStr(infos[index].desc);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(int) GetSkirmishAIOptionCount(int index) {
 
-	options.clear();
-	optionsSet.clear();
+	try {
+		CheckInit();
 
-	ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+		options.clear();
+		optionsSet.clear();
 
+		ParseOptions(skirmishAIDataDirs[index] + &quot;/AIOptions.lua&quot;, SPRING_VFS_RAW, SPRING_VFS_RAW);
+
+		optionsSet.clear();
+
+		return options.size();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+
+	options.clear();
 	optionsSet.clear();
 
-	return (int)options.size();
+	return 0;
 }
 
 
 Export(const char*) GetOptionKey(int optIndex)
 {
-	if (InvalidOptionIndex(optIndex)) {
-		return NULL;
+	try {
+		CheckOptionIndex(optIndex);
+		return GetStr(options[optIndex].key);
 	}
-	return GetStr(options[optIndex].key);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetOptionName(int optIndex)
 {
-	if (InvalidOptionIndex(optIndex)) {
-		return NULL;
+	try {
+		CheckOptionIndex(optIndex);
+		return GetStr(options[optIndex].name);
 	}
-	return GetStr(options[optIndex].name);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 Export(const char*) GetOptionSection(int optIndex)
 {
-	if (InvalidOptionIndex(optIndex)) {
-		return NULL;
+	try {
+		CheckOptionIndex(optIndex);
+		return GetStr(options[optIndex].section);
 	}
-	return GetStr(options[optIndex].section);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 Export(const char*) GetOptionStyle(int optIndex)
 {
-	if (InvalidOptionIndex(optIndex)) {
-		return NULL;
+	try {
+		CheckOptionIndex(optIndex);
+		return GetStr(options[optIndex].style);
 	}
-	return GetStr(options[optIndex].style);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 Export(const char*) GetOptionDesc(int optIndex)
 {
-	if (InvalidOptionIndex(optIndex)) {
-		return NULL;
+	try {
+		CheckOptionIndex(optIndex);
+		return GetStr(options[optIndex].desc);
 	}
-	return GetStr(options[optIndex].desc);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(int) GetOptionType(int optIndex)
 {
-	if (InvalidOptionIndex(optIndex)) {
-		return 0;
+	try {
+		CheckOptionIndex(optIndex);
+		return options[optIndex].typeCode;
 	}
-	return options[optIndex].typeCode;
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
+// Bool Options
+
 Export(int) GetOptionBoolDef(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_bool)) {
-		return 0;
+	try {
+		CheckOptionType(optIndex, opt_bool);
+		return options[optIndex].boolDef ? 1 : 0;
 	}
-	return options[optIndex].boolDef ? 1 : 0;
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
@@ -1431,37 +1889,45 @@
 
 Export(float) GetOptionNumberDef(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_number)) {
-		return 0.0f;
+	try {
+		CheckOptionType(optIndex, opt_number);
+		return options[optIndex].numberDef;
 	}
-	return options[optIndex].numberDef;
+	UNITSYNC_CATCH_BLOCKS;
+	return 0.0f;
 }
 
 
 Export(float) GetOptionNumberMin(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_number)) {
-		return -1.0e30f; // FIXME ?
+	try {
+		CheckOptionType(optIndex, opt_number);
+		return options[optIndex].numberMin;
 	}
-	return options[optIndex].numberMin;
+	UNITSYNC_CATCH_BLOCKS;
+	return -1.0e30f; // FIXME ?
 }
 
 
 Export(float) GetOptionNumberMax(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_number)) {
-		return +1.0e30f; // FIXME ?
+	try {
+		CheckOptionType(optIndex, opt_number);
+		return options[optIndex].numberMax;
 	}
-	return options[optIndex].numberMax;
+	UNITSYNC_CATCH_BLOCKS;
+	return +1.0e30f; // FIXME ?
 }
 
 
 Export(float) GetOptionNumberStep(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_number)) {
-		return 0.0f;
+	try {
+		CheckOptionType(optIndex, opt_number);
+		return options[optIndex].numberStep;
 	}
-	return options[optIndex].numberStep;
+	UNITSYNC_CATCH_BLOCKS;
+	return 0.0f;
 }
 
 
@@ -1469,19 +1935,23 @@
 
 Export(const char*) GetOptionStringDef(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_string)) {
-		return NULL;
+	try {
+		CheckOptionType(optIndex, opt_string);
+		return GetStr(options[optIndex].stringDef);
 	}
-	return GetStr(options[optIndex].stringDef);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(int) GetOptionStringMaxLen(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_string)) {
-		return 0;
+	try {
+		CheckOptionType(optIndex, opt_string);
+		return options[optIndex].stringMaxLen;
 	}
-	return options[optIndex].stringMaxLen;
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
@@ -1489,55 +1959,59 @@
 
 Export(int) GetOptionListCount(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_list)) {
-		return 0;
+	try {
+		CheckOptionType(optIndex, opt_list);
+		return options[optIndex].numListItems;
 	}
-	return options[optIndex].numListItems;
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
 Export(const char*) GetOptionListDef(int optIndex)
 {
-	if (WrongOptionType(optIndex, opt_list)) {
-		return 0;
+	try {
+		CheckOptionType(optIndex, opt_list);
+		return GetStr(options[optIndex].listDef);
 	}
-	return GetStr(options[optIndex].listDef);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetOptionListItemKey(int optIndex, int itemIndex)
 {
-	if (WrongOptionType(optIndex, opt_list)) {
-		return NULL;
+	try {
+		CheckOptionType(optIndex, opt_list);
+		CheckBounds(itemIndex, options[optIndex].numListItems);
+		return GetStr(options[optIndex].list[itemIndex].key);
 	}
-	if ((itemIndex &lt; 0) || (itemIndex &gt;= options[optIndex].numListItems)) {
-		return NULL;
-	}
-	return GetStr(options[optIndex].list[itemIndex].key);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetOptionListItemName(int optIndex, int itemIndex)
 {
-	if (WrongOptionType(optIndex, opt_list)) {
-		return NULL;
+	try {
+		CheckOptionType(optIndex, opt_list);
+		CheckBounds(itemIndex, options[optIndex].numListItems);
+		return GetStr(options[optIndex].list[itemIndex].name);
 	}
-	if ((itemIndex &lt; 0) || (itemIndex &gt;= options[optIndex].numListItems)) {
-		return NULL;
-	}
-	return GetStr(options[optIndex].list[itemIndex].name);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
 Export(const char*) GetOptionListItemDesc(int optIndex, int itemIndex)
 {
-	if (WrongOptionType(optIndex, opt_list)) {
-		return NULL;
+	try {
+		CheckOptionType(optIndex, opt_list);
+		CheckBounds(itemIndex, options[optIndex].numListItems);
+		return GetStr(options[optIndex].list[itemIndex].desc);
 	}
-	if ((itemIndex &lt; 0) || (itemIndex &gt;= options[optIndex].numListItems)) {
-		return NULL;
-	}
-	return GetStr(options[optIndex].list[itemIndex].desc);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
@@ -1590,6 +2064,7 @@
 	mi.description[0] = 0;
 
 	if (!GetMapInfoEx(mapName.c_str(), &amp;mi, 1)) {
+		logOutput.Print(LOG_UNITSYNC, &quot;LuaGetMapInfo: _GetMapInfoEx(\&quot;%s\&quot;) failed&quot;, mapName.c_str());
 		return 0;
 	}
 
@@ -1621,42 +2096,54 @@
 	return 1;
 }
 
-
-Export(int) GetModValidMapCount()
+/**
+ * A return value of 0 means that any map can be selected
+ * Map names should be complete  (including the .smf or .sm3 extension)
+ */
+ Export(int) GetModValidMapCount()
 {
-	modValidMaps.clear();
+	try {
+		CheckInit();
 
-	LuaParser luaParser(&quot;ValidMaps.lua&quot;, SPRING_VFS_MOD, SPRING_VFS_MOD);
-	luaParser.GetTable(&quot;Spring&quot;);
-	luaParser.AddFunc(&quot;GetMapList&quot;, LuaGetMapList);
-	luaParser.AddFunc(&quot;GetMapInfo&quot;, LuaGetMapInfo);
-	luaParser.EndTable();
-	if (!luaParser.Execute()) {
-		return 0;
-	}
+		modValidMaps.clear();
 
-	const LuaTable root = luaParser.GetRoot();
-	if (!root.IsValid()) {
-		return 0;
-	}
+		LuaParser luaParser(&quot;ValidMaps.lua&quot;, SPRING_VFS_MOD, SPRING_VFS_MOD);
+		luaParser.GetTable(&quot;Spring&quot;);
+		luaParser.AddFunc(&quot;GetMapList&quot;, LuaGetMapList);
+		luaParser.AddFunc(&quot;GetMapInfo&quot;, LuaGetMapInfo);
+		luaParser.EndTable();
+		if (!luaParser.Execute()) {
+			throw content_error(&quot;luaParser.Execute() failed: &quot; + luaParser.GetErrorLog());
+		}
 
-	for (int index = 1; root.KeyExists(index); index++) {
-		const string map = root.GetString(index, &quot;&quot;);
-		if (!map.empty()) {
-			modValidMaps.push_back(map);
+		const LuaTable root = luaParser.GetRoot();
+		if (!root.IsValid()) {
+			throw content_error(&quot;root table invalid&quot;);
 		}
+
+		for (int index = 1; root.KeyExists(index); index++) {
+			const string map = root.GetString(index, &quot;&quot;);
+			if (!map.empty()) {
+				modValidMaps.push_back(map);
+			}
+		}
+
+		return modValidMaps.size();
 	}
-
-	return (int)modValidMaps.size();
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
 Export(const char*) GetModValidMap(int index)
 {
-	if ((index &lt; 0) || (index &gt;= (int)modValidMaps.size())) {
-		return NULL;
+	try {
+		CheckInit();
+		CheckBounds(index, modValidMaps.size());
+		return GetStr(modValidMaps[index]);
 	}
-	return GetStr(modValidMaps[index]);
+	UNITSYNC_CATCH_BLOCKS;
+	return NULL;
 }
 
 
@@ -1669,92 +2156,155 @@
 static int nextFile = 0;
 static vector&lt;string&gt; curFindFiles;
 
+static void CheckFileHandle(int handle)
+{
+	CheckInit();
+
+	if (openFiles.find(handle) == openFiles.end())
+		throw content_error(&quot;Unregistered handle. Pass a handle returned by OpenFileVFS.&quot;);
+}
+
 Export(int) OpenFileVFS(const char* name)
 {
-	CHECK_NULL_OR_EMPTY(name);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(name);
 
-	logOutput.Print(&quot;openfilevfs: %s\n&quot;, name);
+		logOutput.Print(LOG_UNITSYNC, &quot;openfilevfs: %s\n&quot;, name);
 
-	CFileHandler* fh = new CFileHandler(name);
-	if (!fh-&gt;FileExists()) {
-		delete fh;
-		return 0;
-	}
+		CFileHandler* fh = new CFileHandler(name);
+		if (!fh-&gt;FileExists()) {
+			delete fh;
+			throw content_error(&quot;File '&quot; + string(name) + &quot;' does not exist&quot;);
+		}
 
-	nextFile++;
-	openFiles[nextFile] = fh;
+		nextFile++;
+		openFiles[nextFile] = fh;
 
-	return nextFile;
+		return nextFile;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(void) CloseFileVFS(int handle)
 {
-	ASSERT(openFiles.find(handle) != openFiles.end(), &quot;Unregistered handle. Pass the handle returned by OpenFileVFS to CloseFileVFS.&quot;);
+	try {
+		CheckFileHandle(handle);
 
-	logOutput.Print(&quot;closefilevfs: %d\n&quot;, handle);
-	delete openFiles[handle];
-	openFiles.erase(handle);
+		logOutput.Print(LOG_UNITSYNC, &quot;closefilevfs: %d\n&quot;, handle);
+		delete openFiles[handle];
+		openFiles.erase(handle);
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
 Export(void) ReadFileVFS(int handle, void* buf, int length)
 {
-	ASSERT(openFiles.find(handle) != openFiles.end(), &quot;Unregistered handle. Pass the handle returned by OpenFileVFS to ReadFileVFS.&quot;);
-	CHECK_NULL(buf);
+	try {
+		CheckFileHandle(handle);
+		CheckNull(buf);
+		CheckPositive(length);
 
-	logOutput.Print(&quot;readfilevfs: %d\n&quot;, handle);
-	CFileHandler* fh = openFiles[handle];
-	fh-&gt;Read(buf, length);
+		logOutput.Print(LOG_UNITSYNC, &quot;readfilevfs: %d\n&quot;, handle);
+		CFileHandler* fh = openFiles[handle];
+		fh-&gt;Read(buf, length);
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
 Export(int) FileSizeVFS(int handle)
 {
-	ASSERT(openFiles.find(handle) != openFiles.end(), &quot;Unregistered handle. Pass the handle returned by OpenFileVFS to FileSizeVFS.&quot;);
+	try {
+		CheckFileHandle(handle);
 
-	logOutput.Print(&quot;filesizevfs: %d\n&quot;, handle);
-	CFileHandler* fh = openFiles[handle];
-	return fh-&gt;FileSize();
+		logOutput.Print(LOG_UNITSYNC, &quot;filesizevfs: %d\n&quot;, handle);
+		CFileHandler* fh = openFiles[handle];
+		return fh-&gt;FileSize();
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return -1;
 }
 
-
+/**
+ * Does not currently support more than one call at a time.
+ * (a new call to initfind destroys data from previous ones)
+ * pass the returned handle to findfiles to get the results
+ */
 Export(int) InitFindVFS(const char* pattern)
 {
-	string path = filesystem.GetDirectory(pattern);
-	string patt = filesystem.GetFilename(pattern);
-	logOutput.Print(&quot;initfindvfs: %s\n&quot;, pattern);
-	curFindFiles = CFileHandler::FindFiles(path, patt);
-	return 0;
+	try {
+		CheckInit();
+		CheckNullOrEmpty(pattern);
+
+		string path = filesystem.GetDirectory(pattern);
+		string patt = filesystem.GetFilename(pattern);
+		logOutput.Print(LOG_UNITSYNC, &quot;initfindvfs: %s\n&quot;, pattern);
+		curFindFiles = CFileHandler::FindFiles(path, patt);
+		return 0;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return -1;
 }
 
+/**
+ * Does not currently support more than one call at a time.
+ * (a new call to initfind destroys data from previous ones)
+ * pass the returned handle to findfiles to get the results
+ */
 Export(int) InitDirListVFS(const char* path, const char* pattern, const char* modes)
 {
-	if (path    == NULL) { path = &quot;&quot;;              }
-	if (modes   == NULL) { modes = SPRING_VFS_ALL; }
-	if (pattern == NULL) { pattern = &quot;*&quot;;          }
-	logOutput.Print(&quot;InitDirListVFS: '%s' '%s' '%s'\n&quot;, path, pattern, modes);
-	curFindFiles = CFileHandler::DirList(path, pattern, modes);
-	return 0;
+	try {
+		CheckInit();
+
+		if (path    == NULL) { path = &quot;&quot;;              }
+		if (modes   == NULL) { modes = SPRING_VFS_ALL; }
+		if (pattern == NULL) { pattern = &quot;*&quot;;          }
+		logOutput.Print(LOG_UNITSYNC, &quot;InitDirListVFS: '%s' '%s' '%s'\n&quot;, path, pattern, modes);
+		curFindFiles = CFileHandler::DirList(path, pattern, modes);
+		return 0;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return -1;
 }
 
+/**
+ * Does not currently support more than one call at a time.
+ * (a new call to initfind destroys data from previous ones)
+ * pass the returned handle to findfiles to get the results
+ */
 Export(int) InitSubDirsVFS(const char* path, const char* pattern, const char* modes)
 {
-	if (path    == NULL) { path = &quot;&quot;;              }
-	if (modes   == NULL) { modes = SPRING_VFS_ALL; }
-	if (pattern == NULL) { pattern = &quot;*&quot;;          }
-	logOutput.Print(&quot;InitSubDirsVFS: '%s' '%s' '%s'\n&quot;, path, pattern, modes);
-	curFindFiles = CFileHandler::SubDirs(path, pattern, modes);
-	return 0;
+	try {
+		CheckInit();
+		if (path    == NULL) { path = &quot;&quot;;              }
+		if (modes   == NULL) { modes = SPRING_VFS_ALL; }
+		if (pattern == NULL) { pattern = &quot;*&quot;;          }
+		logOutput.Print(LOG_UNITSYNC, &quot;InitSubDirsVFS: '%s' '%s' '%s'\n&quot;, path, pattern, modes);
+		curFindFiles = CFileHandler::SubDirs(path, pattern, modes);
+		return 0;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return -1;
 }
 
+// On first call, pass handle from initfind. pass the return value of this function on subsequent calls
+// until 0 is returned. size should be set to max namebuffer size on call
 Export(int) FindFilesVFS(int handle, char* nameBuf, int size)
 {
-	CHECK_NULL(nameBuf);
-	ASSERT(size &gt; 0, &quot;Negative or zero buffer length doesn't make sense.&quot;);
+	try {
+		CheckInit();
+		CheckNull(nameBuf);
+		CheckPositive(size);
 
-	logOutput.Print(&quot;findfilesvfs: %d\n&quot;, handle);
-	if ((unsigned)handle &gt;= curFindFiles.size())
-		return 0;
-	strncpy(nameBuf, curFindFiles[handle].c_str(), size);
-	return handle + 1;
+		logOutput.Print(LOG_UNITSYNC, &quot;findfilesvfs: %d\n&quot;, handle);
+		if ((unsigned)handle &gt;= curFindFiles.size())
+			return 0;
+		safe_strzcpy(nameBuf, curFindFiles[handle], size);
+		return handle + 1;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 
@@ -1764,97 +2314,139 @@
 static map&lt;int, CArchiveBase*&gt; openArchives;
 static int nextArchive = 0;
 
+static void CheckArchiveHandle(int handle)
+{
+	CheckInit();
+
+	if (openArchives.find(handle) == openArchives.end())
+		throw content_error(&quot;Unregistered handle. Pass a handle returned by OpenArchive.&quot;);
+}
+
+// returns 0 on error, a handle otherwise
 Export(int) OpenArchive(const char* name)
 {
-	CHECK_NULL_OR_EMPTY(name);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(name);
 
-	CArchiveBase* a = CArchiveFactory::OpenArchive(name);
-	if (a) {
+		CArchiveBase* a = CArchiveFactory::OpenArchive(name);
+
+		if (!a) {
+			throw content_error(&quot;Archive '&quot; + string(name) + &quot;' could not be opened&quot;);
+		}
+
 		nextArchive++;
 		openArchives[nextArchive] = a;
 		return nextArchive;
 	}
-	else {
-		return 0;
-	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
+// returns 0 on error, a handle otherwise
 Export(int) OpenArchiveType(const char* name, const char* type)
 {
-	CHECK_NULL_OR_EMPTY(name);
-	CHECK_NULL_OR_EMPTY(type);
+	try {
+		CheckInit();
+		CheckNullOrEmpty(name);
+		CheckNullOrEmpty(type);
 
-	CArchiveBase* a = CArchiveFactory::OpenArchive(name, type);
-	if (a) {
+		CArchiveBase* a = CArchiveFactory::OpenArchive(name, type);
+
+		if (!a) {
+			throw content_error(&quot;Archive '&quot; + string(name) + &quot;' could not be opened&quot;);
+		}
+
 		nextArchive++;
 		openArchives[nextArchive] = a;
 		return nextArchive;
 	}
-	else {
-		return 0;
-	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(void) CloseArchive(int archive)
 {
-	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to CloseArchive.&quot;);
+	try {
+		CheckArchiveHandle(archive);
 
-	delete openArchives[archive];
-	openArchives.erase(archive);
+		delete openArchives[archive];
+		openArchives.erase(archive);
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
 Export(int) FindFilesArchive(int archive, int cur, char* nameBuf, int* size)
 {
-	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to FindFilesArchive.&quot;);
-	CHECK_NULL(nameBuf);
-	CHECK_NULL(size);
+	try {
+		CheckArchiveHandle(archive);
+		CheckNull(nameBuf);
+		CheckNull(size);
 
-	CArchiveBase* a = openArchives[archive];
+		CArchiveBase* a = openArchives[archive];
 
-	logOutput.Print(&quot;findfilesarchive: %d\n&quot;, archive);
+		logOutput.Print(LOG_UNITSYNC, &quot;findfilesarchive: %d\n&quot;, archive);
 
-	string name;
-	int s;
+		string name;
+		int s;
 
-	int ret = a-&gt;FindFiles(cur, &amp;name, &amp;s);
-	strcpy(nameBuf, name.c_str());
-	*size = s;
-
-	return ret;
+		int ret = a-&gt;FindFiles(cur, &amp;name, &amp;s);
+		strcpy(nameBuf, name.c_str()); // FIXME: oops, buffer overflow
+		*size = s;
+		return ret;
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(int) OpenArchiveFile(int archive, const char* name)
 {
-	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to OpenArchiveFile.&quot;);
-	CHECK_NULL_OR_EMPTY(name);
+	try {
+		CheckArchiveHandle(archive);
+		CheckNullOrEmpty(name);
 
-	CArchiveBase* a = openArchives[archive];
-	return a-&gt;OpenFile(name);
+		CArchiveBase* a = openArchives[archive];
+		return a-&gt;OpenFile(name);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(int) ReadArchiveFile(int archive, int handle, void* buffer, int numBytes)
 {
-	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to ReadArchiveFile.&quot;);
-	CHECK_NULL(buffer);
+	try {
+		CheckArchiveHandle(archive);
+		CheckNull(buffer);
+		CheckPositive(numBytes);
 
-	CArchiveBase* a = openArchives[archive];
-	return a-&gt;ReadFile(handle, buffer, numBytes);
+		CArchiveBase* a = openArchives[archive];
+		return a-&gt;ReadFile(handle, buffer, numBytes);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return 0;
 }
 
 Export(void) CloseArchiveFile(int archive, int handle)
 {
-	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to CloseArchiveFile.&quot;);
+	try {
+		CheckArchiveHandle(archive);
 
-	CArchiveBase* a = openArchives[archive];
-	return a-&gt;CloseFile(handle);
+		CArchiveBase* a = openArchives[archive];
+		a-&gt;CloseFile(handle);
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
 Export(int) SizeArchiveFile(int archive, int handle)
 {
-	ASSERT(openArchives.find(archive) != openArchives.end(), &quot;Unregistered archive. Pass the handle returned by OpenArchive to SizeArchiveFile.&quot;);
+	try {
+		CheckArchiveHandle(archive);
 
-	CArchiveBase* a = openArchives[archive];
-	return a-&gt;FileSize(handle);
+		CArchiveBase* a = openArchives[archive];
+		return a-&gt;FileSize(handle);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return -1;
 }
 
 //////////////////////////
@@ -1885,34 +2477,159 @@
 //////////////////////////
 //////////////////////////
 
-Export(const char*) GetSpringConfigString( const char* name, const char* defValue )
+/**
+ * @brief get string from Spring configuration
+ * @param name name of key to get
+ * @param defvalue default string value to use if key is not found, may not be NULL
+ * @return string value
+ */
+Export(const char*) GetSpringConfigString(const char* name, const char* defValue)
 {
-	string res = configHandler.GetString( name, defValue );
-	return GetStr(res);
+	try {
+		string res = configHandler.GetString(name, defValue);
+		return GetStr(res);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return defValue;
 }
 
-Export(int) GetSpringConfigInt( const char* name, const int defValue )
+/**
+ * @brief get integer from Spring configuration
+ * @param name name of key to get
+ * @param defvalue default integer value to use if key is not found
+ * @return integer value
+ */
+Export(int) GetSpringConfigInt(const char* name, const int defValue)
 {
-	return configHandler.GetInt( name, defValue );
+	try {
+		return configHandler.GetInt(name, defValue);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return defValue;
 }
 
-Export(float) GetSpringConfigFloat( const char* name, const float defValue)
+/**
+ * @brief get float from Spring configuration
+ * @param name name of key to get
+ * @param defvalue default float value to use if key is not found
+ * @return float value
+ */
+Export(float) GetSpringConfigFloat(const char* name, const float defValue)
 {
-	return configHandler.GetFloat( name, defValue );
+	try {
+		return configHandler.GetFloat(name, defValue);
+	}
+	UNITSYNC_CATCH_BLOCKS;
+	return defValue;
 }
 
+/**
+ * @brief set string in Spring configuration
+ * @param name name of key to set
+ * @param value string value to set
+ */
 Export(void) SetSpringConfigString(const char* name, const char* value)
 {
-	configHandler.SetString( name, value );
+	try {
+		configHandler.SetString( name, value );
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
+/**
+ * @brief set integer in Spring configuration
+ * @param name name of key to set
+ * @param value integer value to set
+ */
 Export(void) SetSpringConfigInt(const char* name, const int value)
 {
-	configHandler.SetInt( name, value );
+	try {
+		configHandler.SetInt(name, value);
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
+/**
+ * @brief set float in Spring configuration
+ * @param name name of key to set
+ * @param value float value to set
+ */
 Export(void) SetSpringConfigFloat(const char* name, const float value)
 {
-	configHandler.SetFloat( name, value );
+	try {
+		configHandler.SetFloat( name, value );
+	}
+	UNITSYNC_CATCH_BLOCKS;
 }
 
+//////////////////////////
+//////////////////////////
+
+// Helper class for popping up a MessageBox only once
+
+class CMessageOnce
+{
+	private:
+		bool alreadyDone;
+
+	public:
+		CMessageOnce() : alreadyDone(false) {}
+		void operator() (const string&amp; msg)
+		{
+			if (alreadyDone) return;
+			alreadyDone = true;
+			Message(msg.c_str());
+		}
+};
+
+#define DEPRECATED \
+	static CMessageOnce msg; \
+	msg(string(__FUNCTION__) + &quot;: deprecated unitsync function called, please update your lobby client&quot;); \
+	SetLastError(&quot;deprecated unitsync function called&quot;)
+
+
+// deprecated 2008/10
+Export(const char*) GetCurrentList()
+{
+	DEPRECATED;
+	return NULL;
+}
+
+// deprecated 2008/10
+Export(void) AddClient(int id, const char *unitList)
+{
+	DEPRECATED;
+}
+
+// deprecated 2008/10
+Export(void) RemoveClient(int id)
+{
+	DEPRECATED;
+}
+
+// deprecated 2008/10
+Export(const char*) GetClientDiff(int id)
+{
+	DEPRECATED;
+	return NULL;
+}
+
+// deprecated 2008/10
+Export(void) InstallClientDiff(const char *diff)
+{
+	DEPRECATED;
+}
+
+// deprecated 2008/10
+Export(int) IsUnitDisabled(int unit)
+{
+	DEPRECATED;
+	return 0;
+}
+
+// deprecated 2008/10
+Export(int) IsUnitDisabledByClient(int unit, int clientId)
+{
+	DEPRECATED;
+	return 0;
+}

Modified: branches/caiinterface/tools/unitsync/unitsync.h
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/unitsync.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -19,7 +19,7 @@
 
 struct MapInfo
 {
-	char* description;
+	char* description; // max 255 chars
 	int tidalStrength;
 	int gravity;
 	float maxMetal;

Deleted: branches/caiinterface/tools/unitsync/unitsyncLogOutput.h
===================================================================
--- branches/caiinterface/tools/unitsync/unitsyncLogOutput.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/unitsyncLogOutput.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -1,18 +0,0 @@
-#ifndef UNITSYNC_LOGGING_H
-#define UNITSYNC_LOGGING_H
-
-#include &lt;cstdio&gt;
-
-class CLogOutput {
-	std::FILE* file;
-public:
-//	void AddLine(const char *, ...);
-	CLogOutput();
-	~CLogOutput();
-	void Print(const string&amp; text);
-	void Print(const char* fmt, ...);
-};
-
-extern CLogOutput logOutput;
-
-#endif

Modified: branches/caiinterface/tools/unitsync/unitsync_api.h
===================================================================
--- branches/caiinterface/tools/unitsync/unitsync_api.h	2008-11-01 23:33:44 UTC (rev 6955)
+++ branches/caiinterface/tools/unitsync/unitsync_api.h	2008-11-02 10:29:36 UTC (rev 6956)
@@ -6,6 +6,7 @@
 
 // from unitsync.cpp:
 
+Export(const char*) GetNextError();
 Export(const char*) GetSpringVersion();
 
 Export(void) Message(const char* p_szMessage);
@@ -13,21 +14,23 @@
 Export(int) Init(bool isServer, int id);
 Export(void) UnInit();
 
+Export(const char*) GetWritableDataDirectory();
+
 Export(int) ProcessUnits(void);
 Export(int) ProcessUnitsNoChecksum(void);
 Export(const char*) GetCurrentList();
 
-Export(void) AddClient(int id, const char *unitList);
-Export(void) RemoveClient(int id);
+//Export(void) AddClient(int id, const char *unitList);
+//Export(void) RemoveClient(int id);
 
-Export(const char*) GetClientDiff(int id);
-Export(void) InstallClientDiff(const char *diff);
+//Export(const char*) GetClientDiff(int id);
+//Export(void) InstallClientDiff(const char *diff);
 
 Export(int) GetUnitCount();
 Export(const char*) GetUnitName(int unit);
 Export(const char*) GetFullUnitName(int unit);
-Export(int) IsUnitDisabled(int unit);
-Export(int) IsUnitDisabledByClient(int unit, int clientId);
+//Export(int) IsUnitDisabled(int unit);
+//Export(int) IsUnitDisabledByClient(int unit, int clientId);
 
 Export(void) AddArchive(const char* name);
 Export(void) AddAllArchives(const char* root);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001724.html">[Taspring-linux-commit] r6955 - in trunk/rts/Game: . Server
</A></li>
	<LI>Next message: <A HREF="001726.html">[Taspring-linux-commit] r6957 - trunk/rts/Game
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1725">[ date ]</a>
              <a href="thread.html#1725">[ thread ]</a>
              <a href="subject.html#1725">[ subject ]</a>
              <a href="author.html#1725">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
