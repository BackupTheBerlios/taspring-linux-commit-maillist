<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7088 - in Lobby/springie: Springie	Springie/autohost Springie/client Springie/spring	Springie/utils libs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7088%20-%20in%20Lobby/springie%3A%20Springie%0A%09Springie/autohost%20Springie/client%20Springie/spring%0A%09Springie/utils%20libs&In-Reply-To=%3C20081123141245.47E504778%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001856.html">
   <LINK REL="Next"  HREF="001858.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7088 - in Lobby/springie: Springie	Springie/autohost Springie/client Springie/spring	Springie/utils libs</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7088%20-%20in%20Lobby/springie%3A%20Springie%0A%09Springie/autohost%20Springie/client%20Springie/spring%0A%09Springie/utils%20libs&In-Reply-To=%3C20081123141245.47E504778%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7088 - in Lobby/springie: Springie	Springie/autohost Springie/client Springie/spring	Springie/utils libs">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sun Nov 23 15:12:45 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001856.html">[Taspring-linux-commit] r7087 - in trunk/rts: Game Rendering
</A></li>
        <LI>Next message: <A HREF="001858.html">[Taspring-linux-commit] r7089 - in Lobby/springie/Springie: . spring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1857">[ date ]</a>
              <a href="thread.html#1857">[ thread ]</a>
              <a href="subject.html#1857">[ subject ]</a>
              <a href="author.html#1857">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: Licho
Date: 2008-11-23 15:12:44 +0100 (Sun, 23 Nov 2008)
New Revision: 7088

Added:
   Lobby/springie/libs/LinqBridge.dll
Modified:
   Lobby/springie/Springie/Main.cs
   Lobby/springie/Springie/MainConfig.cs
   Lobby/springie/Springie/Springie.csproj
   Lobby/springie/Springie/autohost/AutoHost.cs
   Lobby/springie/Springie/autohost/AutoHost_commands.cs
   Lobby/springie/Springie/autohost/Polls.cs
   Lobby/springie/Springie/client/TasClient.cs
   Lobby/springie/Springie/spring/Spring.cs
   Lobby/springie/Springie/spring/Talker.cs
   Lobby/springie/Springie/utils/Stats.cs
   Lobby/springie/libs/PlanetWarsShared.dll
Log:
upgrades for PlanetWars (customizable notifications, sendback messages, detailed error messages if something goes wrong)

Modified: Lobby/springie/Springie/Main.cs
===================================================================
--- Lobby/springie/Springie/Main.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/Main.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -77,9 +77,7 @@
 
 		public void InitializePlanetWarsServer()
 		{
-			try {
-				PlanetWars = (ISpringieServer) Activator.GetObject(typeof (ISpringieServer), String.Format(&quot;<A HREF="tcp://{0">tcp://{0</A>}:1666/IServer&quot;, config.PlanetWarsServer));
-			} catch (Exception ex) {}
+			PlanetWars = (ISpringieServer) Activator.GetObject(typeof (ISpringieServer), String.Format(&quot;<A HREF="tcp://{0">tcp://{0</A>}:1666/IServer&quot;, config.PlanetWarsServer));
 		}
 
 		public void LoadConfig()
@@ -164,8 +162,21 @@
 			}
 		}
 
-		private void spring_PlayerSaid(object sender, SpringLogEventArgs e)
+
+        private void spring_PlayerSaid(object sender, SpringLogEventArgs e)
 		{
+            const string pwPrefix = &quot;Encoded mission report:&quot;;
+            if (config.PlanetWarsEnabled &amp;&amp; PlanetWars != null &amp;&amp; e.Line.StartsWith(pwPrefix)) {
+                var substr = e.Line.Substring(pwPrefix.Length);
+                if (!string.IsNullOrEmpty(substr)) {
+                    try {
+                        PlanetWars.SubmitGameEvent(substr);
+                    } catch (Exception ex) {
+                        autoHost.SayBattle(&quot;Error sending data:&quot; + ex);
+                    }
+                }
+            }
+
 			tas.GameSaid(e.Username, e.Line);
 			if (config.RedirectGameChat &amp;&amp; e.Username != tas.UserName &amp;&amp; !e.Line.StartsWith(&quot;Allies:&quot;) &amp;&amp; !e.Line.StartsWith(&quot;Spectators:&quot;)) tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, &quot;[&quot; + e.Username + &quot;]&quot; + e.Line, false);
 		}

Modified: Lobby/springie/Springie/MainConfig.cs
===================================================================
--- Lobby/springie/Springie/MainConfig.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/MainConfig.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -11,7 +11,7 @@
 	{
 		#region Constants
 
-		public const string SpringieVersion = &quot;Springie 1.34&quot;;
+		public const string SpringieVersion = &quot;Springie 1.34b&quot;;
 		public const int TrackerCaPort = 8202;
 
 		#endregion

Modified: Lobby/springie/Springie/Springie.csproj
===================================================================
--- Lobby/springie/Springie/Springie.csproj	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/Springie.csproj	2008-11-23 14:12:44 UTC (rev 7088)
@@ -98,6 +98,10 @@
     &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
   &lt;/PropertyGroup&gt;
   &lt;ItemGroup&gt;
+    &lt;Reference Include=&quot;LinqBridge, Version=1.0.0.0, Culture=neutral, PublicKeyToken=c2b14eb747628076, processorArchitecture=MSIL&quot;&gt;
+      &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt;
+      &lt;HintPath&gt;..\libs\LinqBridge.dll&lt;/HintPath&gt;
+    &lt;/Reference&gt;
     &lt;Reference Include=&quot;PlanetWarsShared, Version=1.0.0.0, Culture=neutral, processorArchitecture=MSIL&quot;&gt;
       &lt;SpecificVersion&gt;False&lt;/SpecificVersion&gt;
       &lt;HintPath&gt;..\libs\PlanetWarsShared.dll&lt;/HintPath&gt;

Modified: Lobby/springie/Springie/autohost/AutoHost.cs
===================================================================
--- Lobby/springie/Springie/autohost/AutoHost.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/autohost/AutoHost.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -9,10 +9,13 @@
 using System.Timers;
 using System.Windows.Forms;
 using System.Xml.Serialization;
+using PlanetWarsShared;
+using PlanetWarsShared.Springie;
 using Springie.AutoHostNamespace;
 using Springie.Client;
 using Springie.SpringNamespace;
 using Timer=System.Timers.Timer;
+using System.Linq;
 
 #endregion
 
@@ -300,6 +303,7 @@
 
 		public static void SayBattle(TasClient tas, Spring spring, string text, bool ingame)
 		{
+
 			tas.Say(TasClient.SayPlace.Battle, &quot;&quot;, text, true);
 			if (spring.IsRunning &amp;&amp; ingame) spring.SayGame(text);
 		}
@@ -541,7 +545,7 @@
 					var pw = Program.main.PlanetWars;
 
 					string name = tas.GetBattle().Map.Name;
-					var mapInfo = pw.GetAttackOptions().Find(m =&gt; m.MapName == name);
+					var mapInfo = pw.GetAttackOptions().Where(m =&gt; m.MapName == name).Single();
 					if (mapInfo.StartBoxes != null &amp;&amp; mapInfo.StartBoxes.Count &gt; 0) {
 						int rectangles = tas.GetBattle().Rectangles.Count;
 						for (int i = 0; i &lt; rectangles; ++i) tas.RemoveBattleRectangle(i);
@@ -553,12 +557,12 @@
 
 					foreach (var command in mapInfo.AutohostCommands) tas.Say(TasClient.SayPlace.Channel, tas.UserName, command, false);
 
-					SayBattle(&quot;Planet changed succesfully!&quot;);
+                    SayBattle(String.Format(&quot;Welcome to {0}!  (<A HREF="http://planet-wars.eu/planet.aspx?name={1">http://planet-wars.eu/planet.aspx?name={1</A>})&quot;, mapInfo.Name, Uri.EscapeUriString(mapInfo.Name)));
 
-					var notifyList = pw.GetPlayersToNotify(name);
-					notifyList.ForEach(userName =&gt; tas.Say(TasClient.SayPlace.User, userName, string.Format(&quot;Your planet {0} is under attack! Come defend it!&quot;, mapInfo.Name), false));
+					var notifyList = pw.GetPlayersToNotify(name, ReminderEvent.OnBattlePreparing);
+                    foreach (string userName in notifyList) tas.Say(TasClient.SayPlace.User, userName, string.Format(&quot;Planet {0} is under attack! Join the fight!&quot;, mapInfo.Name), false);
 				} catch (Exception ex) {
-					SayBattle(string.Format(&quot;Error setting planet starting boxes: {0}&quot;, ex.Message));
+					SayBattle(string.Format(&quot;Error setting planet starting boxes: {0}&quot;, ex));
 				}
 			}
 		}
@@ -601,9 +605,17 @@
 			}
 
 			if (Program.main.config.PlanetWarsEnabled) {
-				var current = Program.main.PlanetWars.GetOffensiveFaction();
-				var info = Program.main.PlanetWars.GetPlayerInfo(name);
-				SayBattle(string.Format(&quot;{0} {1} {2}. Attacking faction is {3}&quot;, info.IsCommanderInChief ? &quot;All hail to&quot; : &quot;Greetings, &quot;, info.RankText, name, current.Name), false);
+                try {
+                    var current = Program.main.PlanetWars.GetOffensiveFaction();
+
+                    var info = Program.main.PlanetWars.GetPlayerInfo(name);
+                    if (info != null)
+                    {
+                        SayBattle(string.Format(&quot;{0} {1} {2}. Attacking faction is {3}&quot;, info.IsCommanderInChief ? &quot;All hail to&quot; : &quot;Greetings, &quot;, info.RankText, name, current.Name), false);
+                    }
+                } catch (Exception ex) {
+                    SayBattle(&quot;PlanetWars error: &quot; + ex);
+                }
 			}
 		}
 
@@ -638,15 +650,15 @@
         }*/
 
 
-				if (Program.main.config.PlanetWarsEnabled &amp;&amp; u.name != tas.UserName) {
+				if (Program.main.config.PlanetWarsEnabled &amp;&amp; u.name != tas.UserName &amp;&amp; !u.IsSpectator) {
 					try {
 						var pw = Program.main.PlanetWars;
 						var info = pw.GetPlayerInfo(u.name);
-						var factions = pw.GetFactions();
+						var factions = new List&lt;IFaction&gt;(pw.GetFactions());
 						if (info == null) {
 							if (!u.IsSpectator) {
 								tas.ForceSpectator(u.name);
-								SayBattle(string.Format(&quot;{0} cannot play, (s)he is not registered, register using PlanetWars client or !register command&quot;, u.name), false);
+								SayBattle(string.Format(&quot;{0} cannot play, (s)he is not registered, use !register &lt;faction&gt; &lt;password&gt; [&lt;planet&gt;]&quot;, u.name), false);
 								return;
 							}
 						} else {
@@ -658,7 +670,7 @@
 							}
 						}
 					} catch (Exception ex) {
-						SayBattle(string.Format(&quot;Warning, PlanetWars problem: {0} &quot;, ex.Message), false);
+						SayBattle(string.Format(&quot;Warning, PlanetWars problem: {0} &quot;, ex), false);
 					}
 				}
 

Modified: Lobby/springie/Springie/autohost/AutoHost_commands.cs
===================================================================
--- Lobby/springie/Springie/autohost/AutoHost_commands.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/autohost/AutoHost_commands.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -3,6 +3,8 @@
 using System;
 using System.Collections.Generic;
 using System.Globalization;
+using System.Linq;
+using System.Text;
 using System.Text.RegularExpressions;
 using System.Threading;
 using PlanetWarsShared;
@@ -14,1312 +16,1325 @@
 
 namespace Springie.autohost
 {
-	public partial class AutoHost
-	{
-		#region Fields
+    public partial class AutoHost
+    {
+        #region Constants
 
-		private List&lt;string&gt; toNotify = new List&lt;string&gt;();
+        private const int MaxMapListLength = 400;
 
-		#endregion
+        #endregion
 
-		#region Public methods
+        #region Fields
 
-		public bool AllReadyAndSynced(out List&lt;string&gt; usname)
-		{
-			usname = new List&lt;string&gt;();
-			foreach (var p in tas.GetBattle().Users) {
-				if (p.IsSpectator) continue;
-				if (p.SyncStatus != SyncStatuses.Synced || !p.IsReady) usname.Add(p.name);
-			}
-			return usname.Count == 0;
-		}
+        private List&lt;string&gt; toNotify = new List&lt;string&gt;();
 
-		public bool AllUniqueTeams(out List&lt;string&gt; username)
-		{
-			var teams = new List&lt;int&gt;();
-			username = new List&lt;string&gt;();
-			foreach (var p in tas.GetBattle().Users) {
-				if (p.IsSpectator) continue;
-				if (teams.Contains(p.TeamNumber)) username.Add(p.name);
-				else teams.Add(p.TeamNumber);
-			}
-			return username.Count == 0;
-		}
+        #endregion
 
+        #region Public methods
 
-		public bool BalancedTeams(out int allyno)
-		{
-			var counts = new int[16];
-			allyno = 0;
+        public bool AllReadyAndSynced(out List&lt;string&gt; usname)
+        {
+            usname = new List&lt;string&gt;();
+            foreach (var p in tas.GetBattle().Users) {
+                if (p.IsSpectator) continue;
+                if (p.SyncStatus != SyncStatuses.Synced || !p.IsReady) usname.Add(p.name);
+            }
+            return usname.Count == 0;
+        }
 
+        public bool AllUniqueTeams(out List&lt;string&gt; username)
+        {
+            var teams = new List&lt;int&gt;();
+            username = new List&lt;string&gt;();
+            foreach (var p in tas.GetBattle().Users) {
+                if (p.IsSpectator) continue;
+                if (teams.Contains(p.TeamNumber)) username.Add(p.name);
+                else teams.Add(p.TeamNumber);
+            }
+            return username.Count == 0;
+        }
 
-			foreach (var p in tas.GetBattle().Users) {
-				if (p.IsSpectator) continue;
-				counts[p.AllyNumber]++;
-			}
 
-			int tsize = 0;
-			for (int i = 0; i &lt; counts.Length; ++i) {
-				if (counts[i] != 0) {
-					if (tsize == 0) tsize = counts[i];
-					else if (tsize != counts[i]) {
-						allyno = i;
-						return false;
-					}
-				}
-			}
-			if (ladder != null) {
-				int mint, maxt;
-				ladder.CheckBattleDetails(null, out mint, out maxt);
-				if (tsize &lt; mint || tsize &gt; maxt) {
-					SayBattle(&quot;Ladder only allows team sizes &quot; + mint + &quot; - &quot; + maxt);
-					return false;
-				}
-			}
-			return true;
-		}
+        public bool BalancedTeams(out int allyno)
+        {
+            var counts = new int[16];
+            allyno = 0;
 
-		public void BalanceTeams(int teamCount, bool clanwise)
-		{
-			var actUsers = new List&lt;UserBattleStatus&gt;();
-			var ranker = new List&lt;UsRank&gt;();
-			var b = tas.GetBattle();
 
-			foreach (var u in b.Users) {
-				if (!u.IsSpectator) {
-					actUsers.Add(u);
-					User p;
-					if (tas.GetExistingUser(u.name, out p)) ranker.Add(new UsRank(ranker.Count, p.rank, GetClan(u.name)));
-					else ranker.Add(new UsRank(ranker.Count, 0, GetClan(u.name))); // cannot find user, assume rank 0
-				}
-			}
+            foreach (var p in tas.GetBattle().Users) {
+                if (p.IsSpectator) continue;
+                counts[p.AllyNumber]++;
+            }
 
-			var rand = new Random();
+            int tsize = 0;
+            for (int i = 0; i &lt; counts.Length; ++i) {
+                if (counts[i] != 0) {
+                    if (tsize == 0) tsize = counts[i];
+                    else if (tsize != counts[i]) {
+                        allyno = i;
+                        return false;
+                    }
+                }
+            }
+            if (ladder != null) {
+                int mint, maxt;
+                ladder.CheckBattleDetails(null, out mint, out maxt);
+                if (tsize &lt; mint || tsize &gt; maxt) {
+                    SayBattle(&quot;Ladder only allows team sizes &quot; + mint + &quot; - &quot; + maxt);
+                    return false;
+                }
+            }
+            return true;
+        }
 
-			var tempList = new List&lt;UsRank&gt;(ranker);
-			ranker.Clear();
-			while (tempList.Count &gt; 0) {
-				// find max rank value
-				int maxval = int.MinValue;
-				foreach (var u in tempList) if (u.rank &gt; maxval) maxval = u.rank;
+        public void BalanceTeams(int teamCount, bool clanwise)
+        {
+            var actUsers = new List&lt;UserBattleStatus&gt;();
+            var ranker = new List&lt;UsRank&gt;();
+            var b = tas.GetBattle();
 
-				var l2 = new List&lt;UsRank&gt;(); // pick pieces with max rank to l2
-				int j = 0;
-				while (j &lt; tempList.Count) {
-					if (tempList[j].rank == maxval) {
-						l2.Add(tempList[j]);
-						tempList.RemoveAt(j);
-						j = 0;
-					}
-					j++;
-				}
+            foreach (var u in b.Users) {
+                if (!u.IsSpectator) {
+                    actUsers.Add(u);
+                    User p;
+                    if (tas.GetExistingUser(u.name, out p)) ranker.Add(new UsRank(ranker.Count, p.rank, GetClan(u.name)));
+                    else ranker.Add(new UsRank(ranker.Count, 0, GetClan(u.name))); // cannot find user, assume rank 0
+                }
+            }
 
-				while (l2.Count &gt; 0) {
-					// randomly add pieces from l2 to ranker
-					int ind = rand.Next(l2.Count);
-					ranker.Add(l2[ind]);
-					l2.RemoveAt(ind);
-				}
-			}
+            var rand = new Random();
 
-			if (teamCount &lt; 2 || teamCount &gt; ranker.Count) teamCount = 2;
+            var tempList = new List&lt;UsRank&gt;(ranker);
+            ranker.Clear();
+            while (tempList.Count &gt; 0) {
+                // find max rank value
+                int maxval = int.MinValue;
+                foreach (var u in tempList) if (u.rank &gt; maxval) maxval = u.rank;
 
-			var teamUsers = new List&lt;UsRank&gt;[teamCount];
-			for (int i = 0; i &lt; teamUsers.Length; ++i) teamUsers[i] = new List&lt;UsRank&gt;();
-			var teamSums = new int[teamCount];
+                var l2 = new List&lt;UsRank&gt;(); // pick pieces with max rank to l2
+                int j = 0;
+                while (j &lt; tempList.Count) {
+                    if (tempList[j].rank == maxval) {
+                        l2.Add(tempList[j]);
+                        tempList.RemoveAt(j);
+                        j = 0;
+                    }
+                    j++;
+                }
 
-			var teamClans = new List&lt;string&gt;[teamCount];
-			for (int i = 0; i &lt; teamClans.Length; ++i) teamClans[i] = new List&lt;string&gt;();
+                while (l2.Count &gt; 0) {
+                    // randomly add pieces from l2 to ranker
+                    int ind = rand.Next(l2.Count);
+                    ranker.Add(l2[ind]);
+                    l2.RemoveAt(ind);
+                }
+            }
 
-			if (clanwise) {
-				string clans = &quot;&quot;;
-				// remove clans that have less than 2 members - those are irelevant
-				foreach (var u in ranker) {
-					if (u.clan != &quot;&quot;) {
-						if (ranker.FindAll(delegate(UsRank x) { return x.clan == u.clan; }).Count &lt; 2) u.clan = &quot;&quot;;
-						else clans += u.clan + &quot;, &quot;;
-					}
-				}
-				if (clans != &quot;&quot;) SayBattle(&quot;those clan are being balanced: &quot; + clans);
-			}
+            if (teamCount &lt; 2 || teamCount &gt; ranker.Count) teamCount = 2;
 
-			// this cycle performs actual user adding to teams
-			int cnt = 0;
-			while (ranker.Count &gt; 0) {
-				int minsum = int.MaxValue;
-				int minid = 0;
-				for (int i = 0; i &lt; teamCount; ++i) {
-					var l = teamUsers[i];
-					// pick only current &quot;row&quot; and find the one with least sum
-					if (l.Count == cnt/teamCount) {
-						if (teamSums[i] &lt; minsum) {
-							minid = i;
-							minsum = teamSums[i];
-						}
-					}
-				}
+            var teamUsers = new List&lt;UsRank&gt;[teamCount];
+            for (int i = 0; i &lt; teamUsers.Length; ++i) teamUsers[i] = new List&lt;UsRank&gt;();
+            var teamSums = new int[teamCount];
 
-				int picked_user = 0;
-				if (clanwise) {
-					// clanwise balancing - attempt to pick someone with same clan
-					// selected team already has some clan
-					int rank = ranker[0].rank;
-					var temp = new List&lt;int&gt;();
+            var teamClans = new List&lt;string&gt;[teamCount];
+            for (int i = 0; i &lt; teamClans.Length; ++i) teamClans[i] = new List&lt;string&gt;();
 
-					// get list of clans assigned to other teams
-					var assignedClans = new List&lt;string&gt;();
-					for (int i = 0; i &lt; teamClans.Length; ++i) if (i != minid) foreach (var clanName in teamClans[i]) assignedClans.Add(clanName);
+            if (clanwise) {
+                string clans = &quot;&quot;;
+                // remove clans that have less than 2 members - those are irelevant
+                foreach (var u in ranker) {
+                    if (u.clan != &quot;&quot;) {
+                        if (ranker.FindAll(delegate(UsRank x) { return x.clan == u.clan; }).Count &lt; 2) u.clan = &quot;&quot;;
+                        else clans += u.clan + &quot;, &quot;;
+                    }
+                }
+                if (clans != &quot;&quot;) SayBattle(&quot;those clan are being balanced: &quot; + clans);
+            }
 
-					// first try to get some with same clan
-					if (teamClans[minid].Count &gt; 0) {
-						for (int i = 0; i &lt; ranker.Count; ++i) {
-							if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
-							if (ranker[i].clan != &quot;&quot; &amp;&amp; teamClans[minid].Contains(ranker[i].clan)) temp.Add(i);
-						}
-					}
+            // this cycle performs actual user adding to teams
+            int cnt = 0;
+            while (ranker.Count &gt; 0) {
+                int minsum = int.MaxValue;
+                int minid = 0;
+                for (int i = 0; i &lt; teamCount; ++i) {
+                    var l = teamUsers[i];
+                    // pick only current &quot;row&quot; and find the one with least sum
+                    if (l.Count == cnt/teamCount) {
+                        if (teamSums[i] &lt; minsum) {
+                            minid = i;
+                            minsum = teamSums[i];
+                        }
+                    }
+                }
 
-					if (temp.Count == 0) {
-						// we dont have any candidates try to get clanner from unassigned clan
-						for (int i = 0; i &lt; ranker.Count; ++i) {
-							if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
-							if (ranker[i].clan != &quot;&quot; &amp;&amp; !assignedClans.Contains(ranker[i].clan)) temp.Add(i);
-						}
-					}
+                int picked_user = 0;
+                if (clanwise) {
+                    // clanwise balancing - attempt to pick someone with same clan
+                    // selected team already has some clan
+                    int rank = ranker[0].rank;
+                    var temp = new List&lt;int&gt;();
 
-					if (temp.Count == 0) {
-						// we still dont have any candidates try to get non-clanner
-						for (int i = 0; i &lt; ranker.Count; ++i) {
-							if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
-							if (ranker[i].clan == &quot;&quot;) temp.Add(i);
-						}
-					}
+                    // get list of clans assigned to other teams
+                    var assignedClans = new List&lt;string&gt;();
+                    for (int i = 0; i &lt; teamClans.Length; ++i) if (i != minid) foreach (var clanName in teamClans[i]) assignedClans.Add(clanName);
 
-					// if we have some candidates pick one randomly
-					if (temp.Count &gt; 0) picked_user = temp[rand.Next(temp.Count)];
-					;
-				}
+                    // first try to get some with same clan
+                    if (teamClans[minid].Count &gt; 0) {
+                        for (int i = 0; i &lt; ranker.Count; ++i) {
+                            if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
+                            if (ranker[i].clan != &quot;&quot; &amp;&amp; teamClans[minid].Contains(ranker[i].clan)) temp.Add(i);
+                        }
+                    }
 
-				var usr = ranker[picked_user];
-				teamUsers[minid].Add(usr);
-				teamSums[minid] += usr.rank;
+                    if (temp.Count == 0) {
+                        // we dont have any candidates try to get clanner from unassigned clan
+                        for (int i = 0; i &lt; ranker.Count; ++i) {
+                            if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
+                            if (ranker[i].clan != &quot;&quot; &amp;&amp; !assignedClans.Contains(ranker[i].clan)) temp.Add(i);
+                        }
+                    }
 
-				if (clanwise &amp;&amp; usr.clan != &quot;&quot;) {
-					// if we work with clans add user's clan to clan list for his team
-					if (!teamClans[minid].Contains(usr.clan)) teamClans[minid].Add(usr.clan);
-				}
+                    if (temp.Count == 0) {
+                        // we still dont have any candidates try to get non-clanner
+                        for (int i = 0; i &lt; ranker.Count; ++i) {
+                            if (temp.Count &gt; 0 &amp;&amp; ranker[i].rank != rank) break;
+                            if (ranker[i].clan == &quot;&quot;) temp.Add(i);
+                        }
+                    }
 
-				ranker.RemoveAt(picked_user);
+                    // if we have some candidates pick one randomly
+                    if (temp.Count &gt; 0) picked_user = temp[rand.Next(temp.Count)];
+                    ;
+                }
 
-				cnt++;
-			}
+                var usr = ranker[picked_user];
+                teamUsers[minid].Add(usr);
+                teamSums[minid] += usr.rank;
 
-			// alliances for allinace permutations
-			var allys = new List&lt;int&gt;();
-			for (int i = 0; i &lt; teamCount; ++i) allys.Add(i);
+                if (clanwise &amp;&amp; usr.clan != &quot;&quot;) {
+                    // if we work with clans add user's clan to clan list for his team
+                    if (!teamClans[minid].Contains(usr.clan)) teamClans[minid].Add(usr.clan);
+                }
 
-			for (int i = 0; i &lt; teamCount; ++i) {
-				// permute one alliance
-				int rdindex = rand.Next(allys.Count);
-				int allynum = allys[rdindex];
-				allys.RemoveAt(rdindex);
+                ranker.RemoveAt(picked_user);
 
-				foreach (var u in teamUsers[i]) tas.ForceAlly(actUsers[u.id].name, allynum);
-			}
+                cnt++;
+            }
 
-			string t = string.Format(&quot;{0} players balanced to {1} teams (ranks &quot;, actUsers.Count, teamCount);
-			for (int i = 0; i &lt; teamSums.Length; ++i) {
-				if (i &gt; 0) t += &quot;:&quot;;
-				t += teamSums[i].ToString();
-			}
-			t += &quot;)&quot;;
-			if (clanwise) t += &quot; respecting clans&quot;;
-			SayBattle(t);
-		}
+            // alliances for allinace permutations
+            var allys = new List&lt;int&gt;();
+            for (int i = 0; i &lt; teamCount; ++i) allys.Add(i);
 
+            for (int i = 0; i &lt; teamCount; ++i) {
+                // permute one alliance
+                int rdindex = rand.Next(allys.Count);
+                int allynum = allys[rdindex];
+                allys.RemoveAt(rdindex);
 
-		public void ComAddBox(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length &lt; 4) {
-				Respond(e, &quot;This command needs at least 4 parameters&quot;);
-				return;
-			}
-			int x, y, w, h;
-			if (!int.TryParse(words[0], out x) || !int.TryParse(words[1], out y) || !int.TryParse(words[2], out w) || !int.TryParse(words[3], out h)) {
-				Respond(e, &quot;All parameters must be numbers&quot;);
-				return;
-			}
-			int numrect = 0;
-			if (words.Length &gt; 4) int.TryParse(words[4], out numrect);
+                foreach (var u in teamUsers[i]) tas.ForceAlly(actUsers[u.id].name, allynum);
+            }
 
-			if (numrect == 0) {
-				numrect = tas.GetBattle().GetFirstEmptyRectangle();
-				if (numrect == -1) {
-					Respond(e, &quot;Cannot add more boxes&quot;);
-					return;
-				}
-				numrect++;
-			}
-			tas.AddBattleRectangle(numrect - 1, new BattleRect(x*2, y*2, (x + w)*2, (y + h)*2));
-		}
+            string t = string.Format(&quot;{0} players balanced to {1} teams (ranks &quot;, actUsers.Count, teamCount);
+            for (int i = 0; i &lt; teamSums.Length; ++i) {
+                if (i &gt; 0) t += &quot;:&quot;;
+                t += teamSums[i].ToString();
+            }
+            t += &quot;)&quot;;
+            if (clanwise) t += &quot; respecting clans&quot;;
+            SayBattle(t);
+        }
 
-		public void ComAlly(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length &lt; 2) {
-				Respond(e, &quot;this command needs 2 parameters (ally number and player name)&quot;);
-				return;
-			}
-			int allyno = 0;
-			if (!int.TryParse(words[0], out allyno) || --allyno &lt; 0 || allyno &gt;= Spring.MaxAllies) {
-				Respond(e, &quot;invalid ally number&quot;);
-				return;
-			}
-			string[] usrs;
-			int[] idx;
-			if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
-			else {
-				SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to alliance &quot; + (allyno + 1));
-				tas.ForceAlly(usrs[0], allyno);
-			}
-		}
 
-		public void ComAutoLock(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				autoLock = 0;
-				Respond(e, &quot;AutoLocking disabled&quot;);
-				return;
-			}
-			int num = 0;
-			int.TryParse(words[0], out num);
-			int maxp = tas.GetBattle().MaxPlayers;
-			if (num &lt; config.AutoLockMinPlayers || num &gt; maxp) {
-				autoLock = 0;
-				Respond(e, &quot;number of players must be between &quot; + config.AutoLockMinPlayers + &quot; and &quot; + maxp + &quot;, AutoLocking disabled&quot;);
-				return;
-			}
-			autoLock = num;
-			HandleAutoLocking();
-			Respond(e, &quot;AutoLock set to &quot; + autoLock + &quot; players&quot;);
-		}
+        public void ComAddBox(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length &lt; 4) {
+                Respond(e, &quot;This command needs at least 4 parameters&quot;);
+                return;
+            }
+            int x, y, w, h;
+            if (!int.TryParse(words[0], out x) || !int.TryParse(words[1], out y) || !int.TryParse(words[2], out w) || !int.TryParse(words[3], out h)) {
+                Respond(e, &quot;All parameters must be numbers&quot;);
+                return;
+            }
+            int numrect = 0;
+            if (words.Length &gt; 4) int.TryParse(words[4], out numrect);
 
-		public void ComBalance(TasSayEventArgs e, string[] words)
-		{
-			int teamCount = 2;
-			if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
-			else teamCount = 2;
-			ComFix(e, words);
-			BalanceTeams(teamCount, false);
-		}
+            if (numrect == 0) {
+                numrect = tas.GetBattle().GetFirstEmptyRectangle();
+                if (numrect == -1) {
+                    Respond(e, &quot;Cannot add more boxes&quot;);
+                    return;
+                }
+                numrect++;
+            }
+            tas.AddBattleRectangle(numrect - 1, new BattleRect(x*2, y*2, (x + w)*2, (y + h)*2));
+        }
 
-		public void ComBoss(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				if (bossName == &quot;&quot;) {
-					Respond(e, &quot;there is currently no active boss&quot;);
-					return;
-				}
-				SayBattle(&quot;boss &quot; + bossName + &quot; removed&quot;);
-				bossName = &quot;&quot;;
-				return;
-			} else {
-				string[] usrs;
-				int[] idx;
-				if (FilterUsers(words, out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
-				else {
-					SayBattle(&quot;New boss is &quot; + usrs[0]);
-					bossName = usrs[0];
-				}
-			}
-		}
+        public void ComAlly(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length &lt; 2) {
+                Respond(e, &quot;this command needs 2 parameters (ally number and player name)&quot;);
+                return;
+            }
+            int allyno = 0;
+            if (!int.TryParse(words[0], out allyno) || --allyno &lt; 0 || allyno &gt;= Spring.MaxAllies) {
+                Respond(e, &quot;invalid ally number&quot;);
+                return;
+            }
+            string[] usrs;
+            int[] idx;
+            if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
+            else {
+                SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to alliance &quot; + (allyno + 1));
+                tas.ForceAlly(usrs[0], allyno);
+            }
+        }
 
-		public void ComCBalance(TasSayEventArgs e, string[] words)
-		{
-			int teamCount = 2;
-			if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
-			else teamCount = 2;
-			ComFix(e, words);
-			BalanceTeams(teamCount, true);
-		}
+        public void ComAutoLock(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                autoLock = 0;
+                Respond(e, &quot;AutoLocking disabled&quot;);
+                return;
+            }
+            int num = 0;
+            int.TryParse(words[0], out num);
+            int maxp = tas.GetBattle().MaxPlayers;
+            if (num &lt; config.AutoLockMinPlayers || num &gt; maxp) {
+                autoLock = 0;
+                Respond(e, &quot;number of players must be between &quot; + config.AutoLockMinPlayers + &quot; and &quot; + maxp + &quot;, AutoLocking disabled&quot;);
+                return;
+            }
+            autoLock = num;
+            HandleAutoLocking();
+            Respond(e, &quot;AutoLock set to &quot; + autoLock + &quot; players&quot;);
+        }
 
-		public void ComClearBox(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) foreach (var i in tas.GetBattle().Rectangles.Keys) tas.RemoveBattleRectangle(i);
-			else {
-				int numrect = 0;
-				if (!int.TryParse(words[0], out numrect)) Respond(e, &quot;paramater must by a number of rectangle&quot;);
-				tas.RemoveBattleRectangle(numrect - 1);
-			}
-		}
+        public void ComBalance(TasSayEventArgs e, string[] words)
+        {
+            int teamCount = 2;
+            if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
+            else teamCount = 2;
+            ComFix(e, words);
+            BalanceTeams(teamCount, false);
+        }
 
-		public void ComCorners(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length != 2) {
-				Respond(e, &quot;This command needs 2 parameters&quot;);
-				return;
-			}
-			if (words[0] != &quot;a&quot; &amp;&amp; words[0] != &quot;b&quot;) Respond(e, &quot;first parameter must be 'a' or 'b'&quot;);
-			else {
-				int perc;
-				int.TryParse(words[1], out perc);
-				if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
-				else {
-					double p = perc/100.0;
-					if (words[0] == &quot;a&quot;) {
-						tas.AddBattleRectangle(0, new BattleRect(0, 0, p, p));
-						tas.AddBattleRectangle(1, new BattleRect(1 - p, 1 - p, 1, 1));
-						tas.AddBattleRectangle(2, new BattleRect(1 - p, 0, 1, p));
-						tas.AddBattleRectangle(3, new BattleRect(0, 1 - p, p, 1));
-					} else {
-						tas.AddBattleRectangle(0, new BattleRect(1 - p, 0, 1, p));
-						tas.AddBattleRectangle(1, new BattleRect(0, 1 - p, p, 1));
-						tas.AddBattleRectangle(2, new BattleRect(0, 0, p, p));
-						tas.AddBattleRectangle(3, new BattleRect(1 - p, 1 - p, 1, 1));
-					}
-				}
-			}
-		}
+        public void ComBoss(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                if (bossName == &quot;&quot;) {
+                    Respond(e, &quot;there is currently no active boss&quot;);
+                    return;
+                }
+                SayBattle(&quot;boss &quot; + bossName + &quot; removed&quot;);
+                bossName = &quot;&quot;;
+                return;
+            } else {
+                string[] usrs;
+                int[] idx;
+                if (FilterUsers(words, out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
+                else {
+                    SayBattle(&quot;New boss is &quot; + usrs[0]);
+                    bossName = usrs[0];
+                }
+            }
+        }
 
+        public void ComCBalance(TasSayEventArgs e, string[] words)
+        {
+            int teamCount = 2;
+            if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
+            else teamCount = 2;
+            ComFix(e, words);
+            BalanceTeams(teamCount, true);
+        }
 
+        public void ComClearBox(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) foreach (var i in tas.GetBattle().Rectangles.Keys) tas.RemoveBattleRectangle(i);
+            else {
+                int numrect = 0;
+                if (!int.TryParse(words[0], out numrect)) Respond(e, &quot;paramater must by a number of rectangle&quot;);
+                tas.RemoveBattleRectangle(numrect - 1);
+            }
+        }
 
-		public void ComExit(TasSayEventArgs e, string[] words)
-		{
-			if (spring.IsRunning) SayBattle(&quot;exiting game&quot;);
-			else Respond(e, &quot;cannot exit, not in game&quot;);
-			spring.ExitGame();
-		}
+        public void ComCorners(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length != 2) {
+                Respond(e, &quot;This command needs 2 parameters&quot;);
+                return;
+            }
+            if (words[0] != &quot;a&quot; &amp;&amp; words[0] != &quot;b&quot;) Respond(e, &quot;first parameter must be 'a' or 'b'&quot;);
+            else {
+                int perc;
+                int.TryParse(words[1], out perc);
+                if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
+                else {
+                    double p = perc/100.0;
+                    if (words[0] == &quot;a&quot;) {
+                        tas.AddBattleRectangle(0, new BattleRect(0, 0, p, p));
+                        tas.AddBattleRectangle(1, new BattleRect(1 - p, 1 - p, 1, 1));
+                        tas.AddBattleRectangle(2, new BattleRect(1 - p, 0, 1, p));
+                        tas.AddBattleRectangle(3, new BattleRect(0, 1 - p, p, 1));
+                    } else {
+                        tas.AddBattleRectangle(0, new BattleRect(1 - p, 0, 1, p));
+                        tas.AddBattleRectangle(1, new BattleRect(0, 1 - p, p, 1));
+                        tas.AddBattleRectangle(2, new BattleRect(0, 0, p, p));
+                        tas.AddBattleRectangle(3, new BattleRect(1 - p, 1 - p, 1, 1));
+                    }
+                }
+            }
+        }
 
 
-		public void ComFix(TasSayEventArgs e, string[] words)
-		{
-			var b = tas.GetBattle();
-			int cnt = 0;
-			foreach (var u in b.Users) {
-				if (!u.IsSpectator) {
-					tas.ForceTeam(u.name, cnt);
-					cnt++;
-				}
-			}
-			SayBattle(&quot;team numbers fixed&quot;);
-		}
+        public void ComExit(TasSayEventArgs e, string[] words)
+        {
+            if (spring.IsRunning) SayBattle(&quot;exiting game&quot;);
+            else Respond(e, &quot;cannot exit, not in game&quot;);
+            spring.ExitGame();
+        }
 
 
-		public void ComFixColors(TasSayEventArgs e, string[] words)
-		{
-			var cols = new List&lt;MyCol&gt;();
-			var b = tas.GetBattle();
+        public void ComFix(TasSayEventArgs e, string[] words)
+        {
+            var b = tas.GetBattle();
+            int cnt = 0;
+            foreach (var u in b.Users) {
+                if (!u.IsSpectator) {
+                    tas.ForceTeam(u.name, cnt);
+                    cnt++;
+                }
+            }
+            SayBattle(&quot;team numbers fixed&quot;);
+        }
 
-			foreach (var u in b.Users) if (!u.IsSpectator) cols.Add((MyCol) u.TeamColor);
-			var arcols = cols.ToArray();
 
-			MyCol.FixColors(arcols, 30000);
+        public void ComFixColors(TasSayEventArgs e, string[] words)
+        {
+            var cols = new List&lt;MyCol&gt;();
+            var b = tas.GetBattle();
 
-			bool changed = false;
-			int cnt = 0;
-			foreach (var u in b.Users) {
-				if (!u.IsSpectator) {
-					if (u.TeamColor != (int) arcols[cnt]) {
-						tas.ForceColor(u.name, (int) arcols[cnt]);
-						changed = true;
-					}
-					cnt++;
-				}
-			}
-			if (changed) SayBattle(&quot;colors fixed&quot;);
-		}
+            foreach (var u in b.Users) if (!u.IsSpectator) cols.Add((MyCol) u.TeamColor);
+            var arcols = cols.ToArray();
 
-		public void ComForce(TasSayEventArgs e, string[] words)
-		{
-			if (spring.IsRunning) {
-				SayBattle(&quot;forcing game start by &quot; + e.UserName);
-				spring.ForceStart();
-			} else Respond(e, &quot;cannot force, game not started&quot;);
-		}
+            MyCol.FixColors(arcols, 30000);
 
-		public void ComForceSpectator(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				Respond(e, &quot;You must specify player name&quot;);
-				return;
-			}
+            bool changed = false;
+            int cnt = 0;
+            foreach (var u in b.Users) {
+                if (!u.IsSpectator) {
+                    if (u.TeamColor != (int) arcols[cnt]) {
+                        tas.ForceColor(u.name, (int) arcols[cnt]);
+                        changed = true;
+                    }
+                    cnt++;
+                }
+            }
+            if (changed) SayBattle(&quot;colors fixed&quot;);
+        }
 
-			int[] indexes;
-			string[] usrlist;
-			if (FilterUsers(words, out usrlist, out indexes) == 0) {
-				Respond(e, &quot;Cannot find such player&quot;);
-				return;
-			}
+        public void ComForce(TasSayEventArgs e, string[] words)
+        {
+            if (spring.IsRunning) {
+                SayBattle(&quot;forcing game start by &quot; + e.UserName);
+                spring.ForceStart();
+            } else Respond(e, &quot;cannot force, game not started&quot;);
+        }
 
-			tas.ForceSpectator(usrlist[0]);
-			Respond(e, &quot;Forcing &quot; + usrlist[0] + &quot; to spectator&quot;);
-		}
+        public void ComForceSpectator(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                Respond(e, &quot;You must specify player name&quot;);
+                return;
+            }
 
-		public void ComForceSpectatorAfk(TasSayEventArgs e, string[] words)
-		{
-			var b = tas.GetBattle();
-			if (b != null) {
-				foreach (var u in b.Users) {
-					User u2;
-					if (u.name != tas.UserName &amp;&amp; !u.IsSpectator &amp;&amp; !u.IsReady &amp;&amp; tas.GetExistingUser(u.name, out u2)) if (u2.isAway) ComForceSpectator(e, new[] {u.name});
-				}
-			}
-		}
+            int[] indexes;
+            string[] usrlist;
+            if (FilterUsers(words, out usrlist, out indexes) == 0) {
+                Respond(e, &quot;Cannot find such player&quot;);
+                return;
+            }
 
-		public void ComForceStart(TasSayEventArgs e, string[] words)
-		{
-			/*string usname;
+            tas.ForceSpectator(usrlist[0]);
+            Respond(e, &quot;Forcing &quot; + usrlist[0] + &quot; to spectator&quot;);
+        }
+
+        public void ComForceSpectatorAfk(TasSayEventArgs e, string[] words)
+        {
+            var b = tas.GetBattle();
+            if (b != null) {
+                foreach (var u in b.Users) {
+                    User u2;
+                    if (u.name != tas.UserName &amp;&amp; !u.IsSpectator &amp;&amp; !u.IsReady &amp;&amp; tas.GetExistingUser(u.name, out u2)) if (u2.isAway) ComForceSpectator(e, new[] {u.name});
+                }
+            }
+        }
+
+        public void ComForceStart(TasSayEventArgs e, string[] words)
+        {
+            /*string usname;
       if (!AllReadyAndSynced(out usname)) {
         SayBattle(&quot;cannot start, &quot; + usname + &quot; not ready and synced&quot;);
         return;
       }*/
-			if (CheckAndSendPlanetWarsStart(e)) {
-				SayBattle(&quot;please wait, game is about to start&quot;);
+            if (CheckAndSendPlanetWarsStart(e)) {
+                SayBattle(&quot;please wait, game is about to start&quot;);
 
-				StopVote();
-				tas.ChangeLock(true);
-				tas.StartGame();
-			}
-		}
+                StopVote();
+                tas.ChangeLock(true);
+                tas.StartGame();
+            }
+        }
 
-		public void ComKick(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				Respond(e, &quot;You must specify player name&quot;);
-				return;
-			}
+        public void ComKick(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                Respond(e, &quot;You must specify player name&quot;);
+                return;
+            }
 
-			int[] indexes;
-			string[] usrlist;
-			if (FilterUsers(words, out usrlist, out indexes) == 0) {
-				if (spring.IsRunning) spring.Kick(Utils.Glue(words));
-				Respond(e, &quot;Cannot find such player&quot;);
-				return;
-			}
+            int[] indexes;
+            string[] usrlist;
+            if (FilterUsers(words, out usrlist, out indexes) == 0) {
+                if (spring.IsRunning) spring.Kick(Utils.Glue(words));
+                Respond(e, &quot;Cannot find such player&quot;);
+                return;
+            }
 
-			if (usrlist[0] == tas.UserName) {
-				Respond(e, &quot;won't kick myself, not in suicidal mood today&quot;);
-				return;
-			}
+            if (usrlist[0] == tas.UserName) {
+                Respond(e, &quot;won't kick myself, not in suicidal mood today&quot;);
+                return;
+            }
 
-			if (spring.IsRunning) spring.Kick(usrlist[0]);
-			tas.Kick(usrlist[0]);
-		}
+            if (spring.IsRunning) spring.Kick(usrlist[0]);
+            tas.Kick(usrlist[0]);
+        }
 
-		public void ComKickMinRank(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickMinRank = (words[0] == &quot;1&quot;);
-			else kickMinRank = !kickMinRank;
+        public void ComKickMinRank(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickMinRank = (words[0] == &quot;1&quot;);
+            else kickMinRank = !kickMinRank;
 
-			if (kickMinRank) SayBattle(&quot;automatic minrank kicking is now ENABLED&quot;);
-			else SayBattle(&quot;automatic minrank kicking is now DISABLED&quot;);
+            if (kickMinRank) SayBattle(&quot;automatic minrank kicking is now ENABLED&quot;);
+            else SayBattle(&quot;automatic minrank kicking is now DISABLED&quot;);
 
-			HandleMinRankKicking();
-		}
+            HandleMinRankKicking();
+        }
 
-		public void ComKickSpec(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickSpectators = (words[0] == &quot;1&quot;);
-			else kickSpectators = !kickSpectators;
+        public void ComKickSpec(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length &gt; 0 &amp;&amp; (words[0] == &quot;1&quot; || words[0] == &quot;0&quot;)) kickSpectators = (words[0] == &quot;1&quot;);
+            else kickSpectators = !kickSpectators;
 
-			if (kickSpectators) SayBattle(&quot;automatic spectator kicking is now ENABLED&quot;);
-			else SayBattle(&quot;automatic spectator kicking is now DISABLED&quot;);
+            if (kickSpectators) SayBattle(&quot;automatic spectator kicking is now ENABLED&quot;);
+            else SayBattle(&quot;automatic spectator kicking is now DISABLED&quot;);
 
-			if (kickSpectators) {
-				SayBattle(config.KickSpectatorText);
-				var b = tas.GetBattle();
-				if (b != null) foreach (var u in b.Users) if (u.name != tas.UserName &amp;&amp; u.IsSpectator) ComKick(e, new[] {u.name});
-			}
-		}
+            if (kickSpectators) {
+                SayBattle(config.KickSpectatorText);
+                var b = tas.GetBattle();
+                if (b != null) foreach (var u in b.Users) if (u.name != tas.UserName &amp;&amp; u.IsSpectator) ComKick(e, new[] {u.name});
+            }
+        }
 
-		public void ComManage(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length &lt; 1) {
-				Respond(e, &quot;this command needs 1 parameters (minimum number of players to manage for)&quot;);
-				return;
-			}
-			int min = 0;
-			int.TryParse(words[0], out min);
-			int max = min;
-			if (words.Length &gt; 1) int.TryParse(words[1], out max);
-			if (min == 0) Respond(e, &quot;managing disabled&quot;);
-			else Respond(e, &quot;auto managing for &quot; + min + &quot; to &quot; + max + &quot; players&quot;);
-			manager.Manage(min, max);
-		}
+        public void ComManage(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length &lt; 1) {
+                Respond(e, &quot;this command needs 1 parameters (minimum number of players to manage for)&quot;);
+                return;
+            }
+            int min = 0;
+            int.TryParse(words[0], out min);
+            int max = min;
+            if (words.Length &gt; 1) int.TryParse(words[1], out max);
+            if (min == 0) Respond(e, &quot;managing disabled&quot;);
+            else Respond(e, &quot;auto managing for &quot; + min + &quot; to &quot; + max + &quot; players&quot;);
+            manager.Manage(min, max);
+        }
 
-		public void ComPreset(TasSayEventArgs e, string[] words)
-		{
-			string[] vals;
-			int[] indexes;
-			if (FilterPresets(words, out vals, out indexes) &gt; 0) {
-				var p = presets[indexes[0]];
-				Respond(e, &quot;applying preset &quot; + p.Name + &quot; (&quot; + p.Description + &quot;)&quot;);
-				p.Apply(tas, ladder);
-			} else Respond(e, &quot;no such preset found&quot;);
-		}
+        public void ComPreset(TasSayEventArgs e, string[] words)
+        {
+            string[] vals;
+            int[] indexes;
+            if (FilterPresets(words, out vals, out indexes) &gt; 0) {
+                var p = presets[indexes[0]];
+                Respond(e, &quot;applying preset &quot; + p.Name + &quot; (&quot; + p.Description + &quot;)&quot;);
+                p.Apply(tas, ladder);
+            } else Respond(e, &quot;no such preset found&quot;);
+        }
 
-		public void ComPresetDetails(TasSayEventArgs e, string[] words)
-		{
-			string[] vals;
-			int[] indexes;
-			if (FilterPresets(words, out vals, out indexes) &gt; 0) {
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-				foreach (var line in presets[indexes[0]].ToString().Split(new[] {'\n'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			} else Respond(e, &quot;no such preset found&quot;);
-		}
+        public void ComPresetDetails(TasSayEventArgs e, string[] words)
+        {
+            string[] vals;
+            int[] indexes;
+            if (FilterPresets(words, out vals, out indexes) &gt; 0) {
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+                foreach (var line in presets[indexes[0]].ToString().Split(new[] {'\n'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            } else Respond(e, &quot;no such preset found&quot;);
+        }
 
 
-		public void ComRandom(TasSayEventArgs e, string[] words)
-		{
-			ComFix(e, words);
-			var b = tas.GetBattle();
+        public void ComRandom(TasSayEventArgs e, string[] words)
+        {
+            ComFix(e, words);
+            var b = tas.GetBattle();
 
-			var actUsers = new List&lt;UserBattleStatus&gt;();
-			foreach (var u in b.Users) if (!u.IsSpectator) actUsers.Add(u);
+            var actUsers = new List&lt;UserBattleStatus&gt;();
+            foreach (var u in b.Users) if (!u.IsSpectator) actUsers.Add(u);
 
-			int teamCount = 0;
-			if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
-			else teamCount = 2;
-			if (teamCount &lt; 2) teamCount = 2;
-			if (teamCount &gt; actUsers.Count) teamCount = 2;
-			var r = new Random();
+            int teamCount = 0;
+            if (words.Length &gt; 0) int.TryParse(words[0], out teamCount);
+            else teamCount = 2;
+            if (teamCount &lt; 2) teamCount = 2;
+            if (teamCount &gt; actUsers.Count) teamCount = 2;
+            var r = new Random();
 
-			int al = 0;
-			while (actUsers.Count &gt; 0) {
-				int index = r.Next(actUsers.Count);
-				tas.ForceAlly(actUsers[index].name, al);
-				actUsers.RemoveAt(index);
-				al++;
-				al = al%teamCount;
-			}
-			SayBattle(&quot;players assigned to &quot; + teamCount + &quot; random teams&quot;);
-		}
+            int al = 0;
+            while (actUsers.Count &gt; 0) {
+                int index = r.Next(actUsers.Count);
+                tas.ForceAlly(actUsers[index].name, al);
+                actUsers.RemoveAt(index);
+                al++;
+                al = al%teamCount;
+            }
+            SayBattle(&quot;players assigned to &quot; + teamCount + &quot; random teams&quot;);
+        }
 
-		public void ComRehost(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) Start(null, null);
-			else {
-				string[] mods;
-				int[] indexes;
-				if (FilterMods(words, out mods, out indexes) == 0) Respond(e, &quot;cannot find such mod&quot;);
-				else Start(mods[0], null);
-			}
-		}
+        public void ComRehost(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) Start(null, null);
+            else {
+                string[] mods;
+                int[] indexes;
+                if (FilterMods(words, out mods, out indexes) == 0) Respond(e, &quot;cannot find such mod&quot;);
+                else Start(mods[0], null);
+            }
+        }
 
-		public void ComRing(TasSayEventArgs e, string[] words)
-		{
-			var usrlist = new List&lt;string&gt;();
+        public void ComRing(TasSayEventArgs e, string[] words)
+        {
+            var usrlist = new List&lt;string&gt;();
 
-			if (words.Length == 0) {
-				// ringing idle
-				foreach (var p in tas.GetBattle().Users) {
-					if (p.IsSpectator) continue;
-					if (!p.IsReady &amp;&amp; (!spring.IsRunning || !spring.IsPlayerReady(p.name))) usrlist.Add(p.name);
-				}
-			} else {
-				string[] vals;
-				int[] indexes;
-				FilterUsers(words, out vals, out indexes);
-				usrlist = new List&lt;string&gt;(vals);
-			}
+            if (words.Length == 0) {
+                // ringing idle
+                foreach (var p in tas.GetBattle().Users) {
+                    if (p.IsSpectator) continue;
+                    if (!p.IsReady &amp;&amp; (!spring.IsRunning || !spring.IsPlayerReady(p.name))) usrlist.Add(p.name);
+                }
+            } else {
+                string[] vals;
+                int[] indexes;
+                FilterUsers(words, out vals, out indexes);
+                usrlist = new List&lt;string&gt;(vals);
+            }
 
-			string rang = &quot;&quot;;
-			foreach (var s in usrlist) {
-				tas.Ring(s);
-				rang += s + &quot;, &quot;;
-			}
+            string rang = &quot;&quot;;
+            foreach (var s in usrlist) {
+                tas.Ring(s);
+                rang += s + &quot;, &quot;;
+            }
 
-			if (words.Length == 0 &amp;&amp; usrlist.Count &gt; 7) SayBattle(&quot;ringing all unready&quot;);
-			else SayBattle(&quot;ringing &quot; + rang);
-		}
+            if (words.Length == 0 &amp;&amp; usrlist.Count &gt; 7) SayBattle(&quot;ringing all unready&quot;);
+            else SayBattle(&quot;ringing &quot; + rang);
+        }
 
 
-		// user and rank info
+        // user and rank info
 
 
-		public void ComSay(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				Respond(e, &quot;This command needs 1 parameter (say text)&quot;);
-				return;
-			}
-			SayBattle(&quot;[&quot; + e.UserName + &quot;]&quot; + Utils.Glue(words));
-		}
+        public void ComSay(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                Respond(e, &quot;This command needs 1 parameter (say text)&quot;);
+                return;
+            }
+            SayBattle(&quot;[&quot; + e.UserName + &quot;]&quot; + Utils.Glue(words));
+        }
 
-		public void ComSetLevel(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length != 2) {
-				Respond(e, &quot;This command needs 2 parameters&quot;);
-				return;
-			}
-			int lvl;
-			int.TryParse(words[0], out lvl);
-			config.SetPrivilegedUser(words[1], lvl);
-			SaveConfig();
-			Respond(e, words[1] + &quot; has rights level &quot; + lvl);
-		}
+        public void ComSetLevel(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length != 2) {
+                Respond(e, &quot;This command needs 2 parameters&quot;);
+                return;
+            }
+            int lvl;
+            int.TryParse(words[0], out lvl);
+            config.SetPrivilegedUser(words[1], lvl);
+            SaveConfig();
+            Respond(e, words[1] + &quot; has rights level &quot; + lvl);
+        }
 
-		public void ComSplit(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length != 2) {
-				Respond(e, &quot;This command needs 2 parameters&quot;);
-				return;
-			}
-			if (words[0] != &quot;h&quot; &amp;&amp; words[0] != &quot;v&quot;) Respond(e, &quot;first parameter must be 'h' or 'v'&quot;);
-			else {
-				int perc;
-				int.TryParse(words[1], out perc);
-				if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
-				else {
-					if (words[0] == &quot;h&quot;) {
-						tas.AddBattleRectangle(0, new BattleRect(0, 0, 1.0, perc/100.0));
-						tas.AddBattleRectangle(1, new BattleRect(0, 1.0 - perc/100.0, 1.0, 1.0));
-					} else {
-						tas.AddBattleRectangle(0, new BattleRect(0, 0, perc/100.0, 1.0));
-						tas.AddBattleRectangle(1, new BattleRect(1.0 - perc/100.0, 0, 1.0, 1.0));
-					}
-					tas.RemoveBattleRectangle(2);
-					tas.RemoveBattleRectangle(3);
-				}
-			}
-		}
+        public void ComSplit(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length != 2) {
+                Respond(e, &quot;This command needs 2 parameters&quot;);
+                return;
+            }
+            if (words[0] != &quot;h&quot; &amp;&amp; words[0] != &quot;v&quot;) Respond(e, &quot;first parameter must be 'h' or 'v'&quot;);
+            else {
+                int perc;
+                int.TryParse(words[1], out perc);
+                if (perc &lt; 0 || perc &gt; 50) Respond(e, &quot;second parameter must be between 0 and 50&quot;);
+                else {
+                    if (words[0] == &quot;h&quot;) {
+                        tas.AddBattleRectangle(0, new BattleRect(0, 0, 1.0, perc/100.0));
+                        tas.AddBattleRectangle(1, new BattleRect(0, 1.0 - perc/100.0, 1.0, 1.0));
+                    } else {
+                        tas.AddBattleRectangle(0, new BattleRect(0, 0, perc/100.0, 1.0));
+                        tas.AddBattleRectangle(1, new BattleRect(1.0 - perc/100.0, 0, 1.0, 1.0));
+                    }
+                    tas.RemoveBattleRectangle(2);
+                    tas.RemoveBattleRectangle(3);
+                }
+            }
+        }
 
 
-		public void ComSpringie(TasSayEventArgs e, string[] words)
-		{
-			var b = tas.GetBattle();
+        public void ComSpringie(TasSayEventArgs e, string[] words)
+        {
+            var b = tas.GetBattle();
 
-			var running = DateTime.Now.Subtract(Program.startupTime);
-			running = new TimeSpan((int) running.TotalHours, running.Minutes, running.Seconds);
+            var running = DateTime.Now.Subtract(Program.startupTime);
+            running = new TimeSpan((int) running.TotalHours, running.Minutes, running.Seconds);
 
-			var started = DateTime.Now.Subtract(spring.GameStarted);
-			started = new TimeSpan((int) started.TotalHours, started.Minutes, started.Seconds);
+            var started = DateTime.Now.Subtract(spring.GameStarted);
+            started = new TimeSpan((int) started.TotalHours, started.Minutes, started.Seconds);
 
-			Respond(e, tas.UserName + &quot; (&quot; + MainConfig.SpringieVersion + &quot;) running for &quot; + running);
-			Respond(e, &quot;players: &quot; + (b.Users.Count - b.CountSpectators()) + &quot;/&quot; + b.MaxPlayers);
-			Respond(e, &quot;mod: &quot; + b.Mod.Name);
-			Respond(e, &quot;map: &quot; + b.Map.Name);
-			Respond(e, &quot;game &quot; + (spring.IsRunning ? &quot;running since &quot; : &quot;not running, last started &quot;) + (spring.GameStarted != DateTime.MinValue ? started + &quot; ago&quot; : &quot;never&quot;));
-		}
+            Respond(e, tas.UserName + &quot; (&quot; + MainConfig.SpringieVersion + &quot;) running for &quot; + running);
+            Respond(e, &quot;players: &quot; + (b.Users.Count - b.CountSpectators()) + &quot;/&quot; + b.MaxPlayers);
+            Respond(e, &quot;mod: &quot; + b.Mod.Name);
+            Respond(e, &quot;map: &quot; + b.Map.Name);
+            Respond(e, &quot;game &quot; + (spring.IsRunning ? &quot;running since &quot; : &quot;not running, last started &quot;) + (spring.GameStarted != DateTime.MinValue ? started + &quot; ago&quot; : &quot;never&quot;));
+        }
 
-		public void ComStart(TasSayEventArgs e, string[] words)
-		{
-			List&lt;string&gt; usname;
-			if (!AllReadyAndSynced(out usname)) {
-				SayBattle(&quot;cannot start, &quot; + Utils.Glue(usname.ToArray()) + &quot; not ready and synced&quot;);
-				return;
-			}
+        public void ComStart(TasSayEventArgs e, string[] words)
+        {
+            List&lt;string&gt; usname;
+            if (!AllReadyAndSynced(out usname)) {
+                SayBattle(&quot;cannot start, &quot; + Utils.Glue(usname.ToArray()) + &quot; not ready and synced&quot;);
+                return;
+            }
 
-			if (!AllUniqueTeams(out usname)) {
-				SayBattle(&quot;cannot start, &quot; + Utils.Glue(usname.ToArray()) + &quot; is sharing teams. Use !forcestart to override&quot;);
-				return;
-			}
+            if (!AllUniqueTeams(out usname)) {
+                SayBattle(&quot;cannot start, &quot; + Utils.Glue(usname.ToArray()) + &quot; is sharing teams. Use !forcestart to override&quot;);
+                return;
+            }
 
-			int allyno;
-			if (!BalancedTeams(out allyno)) {
-				SayBattle(&quot;cannot start, alliance &quot; + (allyno + 1) + &quot; not fair. Use !forcestart to override&quot;);
-				return;
-			}
+            int allyno;
+            if (!BalancedTeams(out allyno)) {
+                SayBattle(&quot;cannot start, alliance &quot; + (allyno + 1) + &quot; not fair. Use !forcestart to override&quot;);
+                return;
+            }
 
-			if (CheckAndSendPlanetWarsStart(e)) {
-				SayBattle(&quot;please wait, game is about to start&quot;);
+            if (CheckAndSendPlanetWarsStart(e)) {
+                SayBattle(&quot;please wait, game is about to start&quot;);
 
-				StopVote();
+                StopVote();
 
-				var b = tas.GetBattle();
-				if (b != null) {
-					string curMap = b.Map.Name.ToLower();
+                var b = tas.GetBattle();
+                if (b != null) {
+                    string curMap = b.Map.Name.ToLower();
 
-					var nd = new Dictionary&lt;int, BattleRect&gt;();
-					foreach (var v in b.Rectangles) nd.Add(v.Key, v.Value);
+                    var nd = new Dictionary&lt;int, BattleRect&gt;();
+                    foreach (var v in b.Rectangles) nd.Add(v.Key, v.Value);
 
-					if (MapBoxes.ContainsKey(curMap)) MapBoxes[curMap] = nd;
-					else MapBoxes.Add(curMap, nd);
-					SaveConfig();
-				}
-				tas.ChangeLock(true);
-				tas.StartGame();
-			}
-		}
+                    if (MapBoxes.ContainsKey(curMap)) MapBoxes[curMap] = nd;
+                    else MapBoxes.Add(curMap, nd);
+                    SaveConfig();
+                }
+                tas.ChangeLock(true);
+                tas.StartGame();
+            }
+        }
 
-		public void ComTeam(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length &lt; 2) {
-				Respond(e, &quot;this command needs 2 parameters (team number and player name)&quot;);
-				return;
-			}
-			int teamno = 0;
-			if (!int.TryParse(words[0], out teamno) || --teamno &lt; 0 || teamno &gt;= Spring.MaxTeams) {
-				Respond(e, &quot;invalid team number&quot;);
-				return;
-			}
-			string[] usrs;
-			int[] idx;
-			if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
-			else {
-				SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to team &quot; + (teamno + 1));
-				tas.ForceTeam(usrs[0], teamno);
-			}
-		}
+        public void ComTeam(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length &lt; 2) {
+                Respond(e, &quot;this command needs 2 parameters (team number and player name)&quot;);
+                return;
+            }
+            int teamno = 0;
+            if (!int.TryParse(words[0], out teamno) || --teamno &lt; 0 || teamno &gt;= Spring.MaxTeams) {
+                Respond(e, &quot;invalid team number&quot;);
+                return;
+            }
+            string[] usrs;
+            int[] idx;
+            if (FilterUsers(Utils.ShiftArray(words, -1), out usrs, out idx) == 0) Respond(e, &quot;no such player found&quot;);
+            else {
+                SayBattle(&quot;Forcing &quot; + usrs[0] + &quot; to team &quot; + (teamno + 1));
+                tas.ForceTeam(usrs[0], teamno);
+            }
+        }
 
-		internal static int Filter(string[] source, string[] words, out string[] resultVals, out int[] resultIndexes)
-		{
-			int i;
+        internal static int Filter(string[] source, string[] words, out string[] resultVals, out int[] resultIndexes)
+        {
+            int i;
 
-			// search by direct index
-			if (words.Length == 1) {
-				if (int.TryParse(words[0], out i)) {
-					if (i &gt;= 0 &amp;&amp; i &lt; source.Length) {
-						resultVals = new[] {source[i]};
-						resultIndexes = new[] {i};
-						return 1;
-					}
-				}
+            // search by direct index
+            if (words.Length == 1) {
+                if (int.TryParse(words[0], out i)) {
+                    if (i &gt;= 0 &amp;&amp; i &lt; source.Length) {
+                        resultVals = new[] {source[i]};
+                        resultIndexes = new[] {i};
+                        return 1;
+                    }
+                }
 
-				// search by direct word
-				string glued = Utils.Glue(words);
-				for (i = 0; i &lt; source.Length; ++i) {
-					if (source[i] == glued) {
-						resultVals = new[] {source[i]};
-						resultIndexes = new[] {i};
-						return 1;
-					}
-				}
-			}
+                // search by direct word
+                string glued = Utils.Glue(words);
+                for (i = 0; i &lt; source.Length; ++i) {
+                    if (source[i] == glued) {
+                        resultVals = new[] {source[i]};
+                        resultIndexes = new[] {i};
+                        return 1;
+                    }
+                }
+            }
 
-			var res = new List&lt;string&gt;();
-			var resi = new List&lt;int&gt;();
+            var res = new List&lt;string&gt;();
+            var resi = new List&lt;int&gt;();
 
-			for (i = 0; i &lt; words.Length; ++i) words[i] = words[i].ToLower();
-			for (i = 0; i &lt; source.Length; ++i) {
-				if (source[i] + &quot;&quot; == &quot;&quot;) continue;
-				string item = source[i];
-				bool isok = true;
-				for (int j = 0; j &lt; words.Length; ++j) {
-					if (!item.ToLower().Contains(words[j])) {
-						isok = false;
-						break;
-					}
-				}
-				if (isok) {
-					res.Add(item);
-					resi.Add(i);
-				}
-			}
+            for (i = 0; i &lt; words.Length; ++i) words[i] = words[i].ToLower();
+            for (i = 0; i &lt; source.Length; ++i) {
+                if (source[i] + &quot;&quot; == &quot;&quot;) continue;
+                string item = source[i];
+                bool isok = true;
+                for (int j = 0; j &lt; words.Length; ++j) {
+                    if (!item.ToLower().Contains(words[j])) {
+                        isok = false;
+                        break;
+                    }
+                }
+                if (isok) {
+                    res.Add(item);
+                    resi.Add(i);
+                }
+            }
 
-			resultVals = res.ToArray();
-			resultIndexes = resi.ToArray();
+            resultVals = res.ToArray();
+            resultIndexes = resi.ToArray();
 
-			return res.Count;
-		}
+            return res.Count;
+        }
 
-		public int FilterMaps(string[] words, out string[] vals, out int[] indexes)
-		{
-			return FilterMaps(words, tas, spring, ladder, out vals, out indexes);
-		}
+        public int FilterMaps(string[] words, out string[] vals, out int[] indexes)
+        {
+            return FilterMaps(words, tas, spring, ladder, out vals, out indexes);
+        }
 
-		internal static int FilterMods(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
-		{
-			var temp = new string[spring.UnitSyncWrapper.ModList.Keys.Count];
-			int cnt = 0;
-			foreach (var s in spring.UnitSyncWrapper.ModList.Keys) {
-				var limit = Program.main.AutoHost.config.LimitMods;
-				if (limit != null &amp;&amp; limit.Length &gt; 0) {
-					bool allowed = false;
-					for (int i = 0; i &lt; limit.Length; ++i) {
-						if (s.ToLower().Contains(limit[i].ToLower())) {
-							allowed = true;
-							break;
-						}
-					}
-					if (allowed) temp[cnt++] = s;
-				} else temp[cnt++] = s;
-			}
+        internal static int FilterMods(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
+        {
+            var temp = new string[spring.UnitSyncWrapper.ModList.Keys.Count];
+            int cnt = 0;
+            foreach (var s in spring.UnitSyncWrapper.ModList.Keys) {
+                var limit = Program.main.AutoHost.config.LimitMods;
+                if (limit != null &amp;&amp; limit.Length &gt; 0) {
+                    bool allowed = false;
+                    for (int i = 0; i &lt; limit.Length; ++i) {
+                        if (s.ToLower().Contains(limit[i].ToLower())) {
+                            allowed = true;
+                            break;
+                        }
+                    }
+                    if (allowed) temp[cnt++] = s;
+                } else temp[cnt++] = s;
+            }
 
-			return Filter(temp, words, out vals, out indexes);
-		}
+            return Filter(temp, words, out vals, out indexes);
+        }
 
-		public int FilterPlanets(string[] words, out string[] vals, out int[] indexes)
-		{
-			var pw = Program.main.PlanetWars;
-			var options = pw.GetAttackOptions();
+        public int FilterPlanets(string[] words, out string[] vals, out int[] indexes)
+        {
+            var pw = Program.main.PlanetWars;
+            var options = pw.GetAttackOptions();
 
-			var temp = new string[options.Count];
-			int cnt = 0;
-			foreach (var planet in options) temp[cnt++] = planet.Name;
-			return Filter(temp, words, out vals, out indexes);
-		}
+            if (options != null) {
+                var temp = new string[options.Count];
+                int cnt = 0;
 
+                foreach (var planet in options) temp[cnt++] = planet.Name;
+                return Filter(temp, words, out vals, out indexes);
+            } else {
+                vals = null;
+                indexes = null;
+                return 0;
+            }
+            
+        }
 
-		internal static int FilterPresets(string[] words, AutoHost autohost, out string[] vals, out int[] indexes)
-		{
-			var temp = new string[autohost.presets.Count];
-			int cnt = 0;
-			foreach (var p in autohost.presets) temp[cnt++] = p.Name + &quot; --&gt; &quot; + p.Description;
-			return Filter(temp, words, out vals, out indexes);
-		}
 
-		internal static int FilterUsers(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
-		{
-			var b = tas.GetBattle();
-			var temp = new string[b.Users.Count];
-			int i = 0;
-			foreach (var u in b.Users) temp[i++] = u.name;
-			return Filter(temp, words, out vals, out indexes);
-		}
+        internal static int FilterPresets(string[] words, AutoHost autohost, out string[] vals, out int[] indexes)
+        {
+            var temp = new string[autohost.presets.Count];
+            int cnt = 0;
+            foreach (var p in autohost.presets) temp[cnt++] = p.Name + &quot; --&gt; &quot; + p.Description;
+            return Filter(temp, words, out vals, out indexes);
+        }
 
+        internal static int FilterUsers(string[] words, TasClient tas, Spring spring, out string[] vals, out int[] indexes)
+        {
+            var b = tas.GetBattle();
+            var temp = new string[b.Users.Count];
+            int i = 0;
+            foreach (var u in b.Users) temp[i++] = u.name;
+            return Filter(temp, words, out vals, out indexes);
+        }
 
-		public string GetOptionsString(TasSayEventArgs e, string[] words)
-		{
-			string s = Utils.Glue(words);
-			string result = &quot;&quot;;
-			var pairs = s.Split(new[] {','});
-			if (pairs.Length == 0 || pairs[0].Length == 0) {
-				Respond(e, &quot;requires key=value format&quot;);
-				return &quot;&quot;;
-			}
-			foreach (var pair in pairs) {
-				var parts = pair.Split(new[] {'='}, 2);
-				if (parts.Length != 2) {
-					Respond(e, &quot;requires key=value format&quot;);
-					return &quot;&quot;;
-				}
-				var b = tas.GetBattle();
-				string key = parts[0];
-				string val = parts[1];
 
-				bool found = false;
-				foreach (var o in b.Mod.Options) {
-					if (o.Key == key) {
-						found = true;
-						string res;
-						if (o.GetPair(val, out res)) {
-							if (result != &quot;&quot;) result += &quot;\t&quot;;
-							result += res;
-						} else Respond(e, &quot;Value &quot; + val + &quot; is not valid for this option&quot;);
+        public string GetOptionsString(TasSayEventArgs e, string[] words)
+        {
+            string s = Utils.Glue(words);
+            string result = &quot;&quot;;
+            var pairs = s.Split(new[] {','});
+            if (pairs.Length == 0 || pairs[0].Length == 0) {
+                Respond(e, &quot;requires key=value format&quot;);
+                return &quot;&quot;;
+            }
+            foreach (var pair in pairs) {
+                var parts = pair.Split(new[] {'='}, 2);
+                if (parts.Length != 2) {
+                    Respond(e, &quot;requires key=value format&quot;);
+                    return &quot;&quot;;
+                }
+                var b = tas.GetBattle();
+                string key = parts[0];
+                string val = parts[1];
 
-						break;
-					}
-				}
-				if (!found) {
-					Respond(e, &quot;No option called &quot; + key + &quot; found&quot;);
-					return &quot;&quot;;
-				}
-			}
-			return result;
-		}
+                bool found = false;
+                foreach (var o in b.Mod.Options) {
+                    if (o.Key == key) {
+                        found = true;
+                        string res;
+                        if (o.GetPair(val, out res)) {
+                            if (result != &quot;&quot;) result += &quot;\t&quot;;
+                            result += res;
+                        } else Respond(e, &quot;Value &quot; + val + &quot; is not valid for this option&quot;);
 
-		#endregion
+                        break;
+                    }
+                }
+                if (!found) {
+                    Respond(e, &quot;No option called &quot; + key + &quot; found&quot;);
+                    return &quot;&quot;;
+                }
+            }
+            return result;
+        }
 
-		#region Other methods
+        #endregion
 
-		private bool CheckAndSendPlanetWarsStart(TasSayEventArgs e)
-		{
-			if (Program.main.config.PlanetWarsEnabled) {
-				try {
-					bool ok = true;
-					var pw = Program.main.PlanetWars;
-					string currentMapName = tas.GetBattle().Map.Name;
-					var fmap = pw.GetAttackOptions().Find(p =&gt; p.MapName == currentMapName);
-					if (fmap == null) {
-						SayBattle(&quot;This planet is not currently allowed, select another one&quot;);
-						return false;
-					}
+        #region Other methods
 
-					var factions = pw.GetFactions();
+        private bool CheckAndSendPlanetWarsStart(TasSayEventArgs e)
+        {
+            if (Program.main.config.PlanetWarsEnabled) {
+                try {
+                    var pw = Program.main.PlanetWars;
+                    string currentMapName = tas.GetBattle().Map.Name;
+                    var planet = pw.GetAttackOptions().Where(p =&gt; p.MapName == currentMapName).SingleOrDefault();
 
-					var actual = new List&lt;IPlayer&gt;();
-					foreach (var user in tas.GetBattle().Users) {
-						if (!user.IsSpectator) {
-							var info = pw.GetPlayerInfo(user.name);
-							actual.Add(info);
-							string side = tas.GetBattle().Mod.Sides[user.Side];
-							string hisSide = factions.Find(f =&gt; f.Name == info.FactionName).SpringSide;
+                    if (planet == null) {
+                        SayBattle(&quot;This planet is not currently allowed, select another one&quot;);
+                        return false;
+                    }
 
-							if (!string.Equals(side, hisSide, StringComparison.InvariantCultureIgnoreCase)) {
-								SayBattle(string.Format(&quot;{0} must switch to {1}&quot;, user.name, hisSide), false);
-								ok = false;
-							}
-						}
-					}
-					if (ok) {
-						string options = pw.GetStartupModOptions(tas.GetBattle().Map.Name, actual);
-						var b = tas.GetBattle();
-						foreach (var o in b.Mod.Options) {
-							if (o.Key == &quot;planetwars&quot;) {
-								string res;
-								if (o.GetPair(options, out res)) {
-									tas.SetScriptTag(res);
-									return ok;
-								} else {
-									Respond(e, &quot;Eror setting script tag&quot;);
-									return false;
-								}
-							}
-						}
-						Respond(e, &quot;This mod does not support PlanetWars&quot;);
-						return false;
-					}
+                    var factions = pw.GetFactions();
 
-					return ok;
-				} catch (Exception ex) {
-					SayBattle(string.Format(&quot;Error when checking PlanetWars teams: {0}&quot;, ex.Message), false);
-					return false;
-				}
-			} else return true;
-		}
+                    var actual = new List&lt;IPlayer&gt;();
+                    foreach (var user in tas.GetBattle().Users) {
+                        if (!user.IsSpectator) {
+                            var info = pw.GetPlayerInfo(user.name);
+                            actual.Add(info);
+                            string side = tas.GetBattle().Mod.Sides[user.Side];
+                            string hisSide = factions.Where(f =&gt; f.Name == info.FactionName).Single().SpringSide;
 
-		private void ComAdmins(TasSayEventArgs e, string[] words)
-		{
-			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			foreach (var u in config.PrivilegedUsers) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; &quot; + u.Name + &quot; (level &quot; + u.Level + &quot;)&quot;, false);
-			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-		}
+                            if (!string.Equals(side, hisSide, StringComparison.InvariantCultureIgnoreCase)) {
+                                SayBattle(string.Format(&quot;{0} must switch to {1}&quot;, user.name, hisSide), false);
+                                return false;
+                            }
+                        }
+                    }
 
-		private void ComHelp(TasSayEventArgs e, string[] words)
-		{
-			int ulevel = GetUserLevel(e);
-			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			foreach (var c in config.Commands) if (c.Level &lt;= ulevel) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
-			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-		}
 
+                    string options = pw.GetStartupModOptions(tas.GetBattle().Map.Name, actual);
+                    //SayBattle(Encoding.ASCII.GetString(Convert.FromBase64String(options.Replace(&quot;+&quot;, &quot;=&quot;))));
+                    var b = tas.GetBattle();
+                    foreach (var o in b.Mod.Options) {
+                        if (o.Key == &quot;planetwars&quot;) {
+                            string res;
+                            if (o.GetPair(options, out res)) {
+                                tas.SetScriptTag(res);
 
-		private void ComHelpAll(TasSayEventArgs e, string[] words)
-		{
-			var copy = new List&lt;CommandConfig&gt;(config.Commands);
-			copy.Sort(delegate(CommandConfig a, CommandConfig b)
-			          	{
-			          		if (a.Level != b.Level) return a.Level.CompareTo(b.Level);
-			          		else return a.Name.CompareTo(b.Name);
-			          	});
+                                var startEvent = pw.GetPlayersToNotify(currentMapName, ReminderEvent.OnBattleStarted);
+                                foreach (string s in startEvent) tas.Say(TasClient.SayPlace.User, s, string.Format(&quot;PlanetWars battle for planet {0} owned by {1} is starting.&quot;, planet.Name, planet.OwnerName), false);
 
-			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			foreach (var c in copy) tas.Say(TasClient.SayPlace.User, e.UserName, &quot;Level &quot; + c.Level + &quot; --&gt; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
-			tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-		}
+                                return true;
+                            } else {
+                                Respond(e, &quot;Eror setting script tag&quot;);
+                                return false;
+                            }
+                        }
+                    }
+                    Respond(e, &quot;This mod does not support PlanetWars&quot;);
+                    return false;
+                } catch (Exception ex) {
+                    SayBattle(string.Format(&quot;Error when checking PlanetWars teams: {0}&quot;, ex), false);
+                    return false;
+                }
+            } else return true;
+        }
 
-		private const int MaxMapListLength = 400;
+        private void ComAdmins(TasSayEventArgs e, string[] words)
+        {
+            tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            foreach (var u in config.PrivilegedUsers) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; &quot; + u.Name + &quot; (level &quot; + u.Level + &quot;)&quot;, false);
+            tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+        }
 
-		private void ComListMaps(TasSayEventArgs e, string[] words)
-		{
-			string[] vals;
-			int[] indexes;
-			int count;
-			if ((count = FilterMaps(words, out vals, out indexes)) &gt; 0) {
-				if (count &gt; MaxMapListLength) {
-					Respond(e, string.Format(&quot;This has {0} results, please narrow down your search&quot;, count));
-					return;
-				}
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-				for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			} else Respond(e, &quot;no such map found&quot;);
-		}
+        private void ComHelp(TasSayEventArgs e, string[] words)
+        {
+            int ulevel = GetUserLevel(e);
+            tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            foreach (var c in config.Commands) if (c.Level &lt;= ulevel) tas.Say(TasClient.SayPlace.User, e.UserName, &quot; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
+            tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+        }
 
-		private void ComListMods(TasSayEventArgs e, string[] words)
-		{
-			string[] vals;
-			int[] indexes;
-			int count;
-			if ((count = FilterMods(words, out vals, out indexes)) &gt; 0) {
-				if (count &gt; MaxMapListLength)
-				{
-					Respond(e, string.Format(&quot;This has {0} results, please narrow down your search&quot;, count));
-					return;
-				}
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-				for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			} else Respond(e, &quot;no such mod found&quot;);
-		}
 
-		private void ComListOptions(TasSayEventArgs e, string[] words)
-		{
-			var b = tas.GetBattle();
-			if (b.Mod.Options.Count == 0) Respond(e, &quot;this mod has no options&quot;);
-			else foreach (var opt in b.Mod.Options) Respond(e, opt.ToString());
-		}
+        private void ComHelpAll(TasSayEventArgs e, string[] words)
+        {
+            var copy = new List&lt;CommandConfig&gt;(config.Commands);
+            copy.Sort(delegate(CommandConfig a, CommandConfig b)
+                          {
+                              if (a.Level != b.Level) return a.Level.CompareTo(b.Level);
+                              else return a.Name.CompareTo(b.Name);
+                          });
 
-		private void ComListPlanets(TasSayEventArgs e, string[] words)
-		{
-			string[] vals;
-			int[] indexes;
-			if (!Program.main.config.PlanetWarsEnabled) {
-				Respond(e, &quot;This is not PlanetWars host&quot;);
-				return;
-			}
-			try {
-				if (FilterPlanets(words, out vals, out indexes) &gt; 0) {
-					Respond(e, &quot;Planets available for attack are:&quot;);
-					for (int i = 0; i &lt; vals.Length; ++i) Respond(e, string.Format(&quot;{0}: {1}&quot;, indexes[i], vals[i]));
-				} else Respond(e, &quot;no such planet found&quot;);
-			} catch (Exception ex) {
-				Respond(e, string.Format(&quot;Error getting planets: {0}&quot;, ex.Message));
-			}
-		}
+            tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            foreach (var c in copy) tas.Say(TasClient.SayPlace.User, e.UserName, &quot;Level &quot; + c.Level + &quot; --&gt; !&quot; + c.Name + &quot; &quot; + c.HelpText, false);
+            tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+        }
 
-		private void ComListPresets(TasSayEventArgs e, string[] words)
-		{
-			string[] vals;
-			int[] indexes;
+        private void ComListMaps(TasSayEventArgs e, string[] words)
+        {
+            string[] vals;
+            int[] indexes;
+            int count;
+            if ((count = FilterMaps(words, out vals, out indexes)) &gt; 0) {
+                if (count &gt; MaxMapListLength) {
+                    Respond(e, string.Format(&quot;This has {0} results, please narrow down your search&quot;, count));
+                    return;
+                }
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+                for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            } else Respond(e, &quot;no such map found&quot;);
+        }
 
-			if (FilterPresets(words, out vals, out indexes) &gt; 0) {
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-				for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
-				tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
-			} else Respond(e, &quot;no such preset found&quot;);
-		}
+        private void ComListMods(TasSayEventArgs e, string[] words)
+        {
+            string[] vals;
+            int[] indexes;
+            int count;
+            if ((count = FilterMods(words, out vals, out indexes)) &gt; 0) {
+                if (count &gt; MaxMapListLength) {
+                    Respond(e, string.Format(&quot;This has {0} results, please narrow down your search&quot;, count));
+                    return;
+                }
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+                for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            } else Respond(e, &quot;no such mod found&quot;);
+        }
 
-		private void ComMap(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				Respond(e, &quot;You must specify a map name&quot;);
-				return;
-			}
-			string[] vals;
-			int[] indexes;
-			if (FilterMaps(words, out vals, out indexes) &gt; 0) {
-				SayBattle(&quot;changing map to &quot; + vals[0]);
-				tas.ChangeMap(spring.UnitSyncWrapper.MapList[vals[0]]);
-			} else Respond(e, &quot;Cannot find such map.&quot;);
-		}
+        private void ComListOptions(TasSayEventArgs e, string[] words)
+        {
+            var b = tas.GetBattle();
+            if (b.Mod.Options.Count == 0) Respond(e, &quot;this mod has no options&quot;);
+            else foreach (var opt in b.Mod.Options) Respond(e, opt.ToString());
+        }
 
+        private void ComListPlanets(TasSayEventArgs e, string[] words)
+        {
+            string[] vals;
+            int[] indexes;
+            if (!Program.main.config.PlanetWarsEnabled) {
+                Respond(e, &quot;This is not PlanetWars host&quot;);
+                return;
+            }
+            try {
+                if (FilterPlanets(words, out vals, out indexes) &gt; 0) {
+                    Respond(e, &quot;Planets available for attack are:&quot;);
+                    for (int i = 0; i &lt; vals.Length; ++i) Respond(e, string.Format(&quot;{0}: {1}&quot;, indexes[i], vals[i]));
+                } else Respond(e, &quot;no such planet found&quot;);
+            } catch (Exception ex) {
+                Respond(e, string.Format(&quot;Error getting planets: {0}&quot;, ex));
+            }
+        }
 
-		private void ComNotify(TasSayEventArgs e, string[] words)
-		{
-			if (!toNotify.Contains(e.UserName)) toNotify.Add(e.UserName);
-			Respond(e, &quot;I will notify you when game ends&quot;);
-		}
+        private void ComListPresets(TasSayEventArgs e, string[] words)
+        {
+            string[] vals;
+            int[] indexes;
 
-		private void ComPlanet(TasSayEventArgs e, string[] words)
-		{
-			if (!Program.main.config.PlanetWarsEnabled) {
-				Respond(e, &quot;This is not a PlanetWars host&quot;);
-				return;
-			}
+            if (FilterPresets(words, out vals, out indexes) &gt; 0) {
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+                for (int i = 0; i &lt; vals.Length; ++i) tas.Say(TasClient.SayPlace.User, e.UserName, indexes[i] + &quot;: &quot; + vals[i], false);
+                tas.Say(TasClient.SayPlace.User, e.UserName, &quot;---&quot;, false);
+            } else Respond(e, &quot;no such preset found&quot;);
+        }
 
-			if (words.Length == 0) {
-				Respond(e, &quot;You must specify planet name&quot;);
-				return;
-			}
-			string[] vals;
-			int[] indexes;
-			if (FilterPlanets(words, out vals, out indexes) &gt; 0) {
-				var pw = Program.main.PlanetWars;
-				var info = pw.GetPlayerInfo(e.UserName);
-				var fact = pw.GetOffensiveFaction();
-				if (info != null &amp;&amp; info.IsCommanderInChief) {
-					if (info.FactionName == fact.Name) {
-						SayBattle(string.Format(&quot;changing planet to {0} by {1}&quot;, vals[0], e.UserName));
-						var planet = pw.GetAttackOptions().Find((m) =&gt; m.Name == vals[0]);
-						tas.ChangeMap(spring.UnitSyncWrapper.MapList[planet.MapName]);
-					} else Respond(e, string.Format(&quot;It's currently {0} turn&quot;, fact.Name));
-				} else Respond(e, &quot;You are not a commander-in-chief&quot;);
-			} else Respond(e, &quot;Cannot find such planet.&quot;);
-		}
+        private void ComMap(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                Respond(e, &quot;You must specify a map name&quot;);
+                return;
+            }
+            string[] vals;
+            int[] indexes;
+            if (FilterMaps(words, out vals, out indexes) &gt; 0) {
+                SayBattle(&quot;changing map to &quot; + vals[0]);
+                tas.ChangeMap(spring.UnitSyncWrapper.MapList[vals[0]]);
+            } else Respond(e, &quot;Cannot find such map.&quot;);
+        }
 
-		private void ComRegister(TasSayEventArgs e, string[] words)
-		{
-			if (!Program.main.config.PlanetWarsEnabled) {
-				Respond(e, &quot;This is not PlanetWars host&quot;);
-				return;
-			}
-			if (words.Length &lt; 2) {
-				Respond(e, &quot;This command needs 2-3 parameters - side and password and optional planet name (you must PM it to me)&quot;);
-				return;
-			}
-			if (e.Place != TasSayEventArgs.Places.Normal) Respond(e, &quot;Please use a private message (double click my name in channel player list), its not secure to talk about passwords here&quot;);
 
+        private void ComNotify(TasSayEventArgs e, string[] words)
+        {
+            if (!toNotify.Contains(e.UserName)) toNotify.Add(e.UserName);
+            Respond(e, &quot;I will notify you when game ends&quot;);
+        }
 
-			try {
-				var pw = Program.main.PlanetWars;
-				string response = pw.Register(new AuthInfo {Login = e.UserName, Password = words[1]}, words[0], words.Length &gt; 2 ? Utils.Glue(words, 2) : null);
-				Respond(e, string.Format(response));
-			} catch (Exception ex) {
-				Respond(e, string.Format(&quot;Error when registering: {0}&quot;, ex.Message));
-			}
-		}
+        private void ComPlanet(TasSayEventArgs e, string[] words)
+        {
+            if (!Program.main.config.PlanetWarsEnabled) {
+                Respond(e, &quot;This is not a PlanetWars host&quot;);
+                return;
+            }
 
-		private void ComSetGameTitle(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - new game title&quot;);
-			else {
-				Program.main.AutoHost.config.GameTitle = Utils.Glue(words);
-				SaveConfig();
-				Respond(e, &quot;game title changed&quot;);
-			}
-		}
+            if (words.Length == 0) {
+                Respond(e, &quot;You must specify planet name&quot;);
+                return;
+            }
+            string[] vals;
+            int[] indexes;
+            if (FilterPlanets(words, out vals, out indexes) &gt; 0) {
+                var pw = Program.main.PlanetWars;
+                var info = pw.GetPlayerInfo(e.UserName);
+                var fact = pw.GetOffensiveFaction();
+                if (info != null &amp;&amp; info.IsCommanderInChief) {
+                    if (info.FactionName == fact.Name) {
+                        SayBattle(string.Format(&quot;changing planet to {0} by {1}&quot;, vals[0], e.UserName));
+                        var planet = pw.GetAttackOptions().Where(m =&gt; m.Name == vals[0]).Single();
+                        tas.ChangeMap(spring.UnitSyncWrapper.MapList[planet.MapName]);
+                    } else Respond(e, string.Format(&quot;It's currently {0} turn&quot;, fact.Name));
+                } else Respond(e, &quot;You are not a commander-in-chief&quot;);
+            } else Respond(e, &quot;Cannot find such planet.&quot;);
+        }
 
-		private void ComSetMaxPlayers(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - number of players&quot;);
-			else {
-				int plr;
-				int.TryParse(words[0], out plr);
-				if (plr &lt; 1) plr = 1;
-				if (plr &gt; Spring.MaxTeams) plr = Spring.MaxTeams;
-				Program.main.AutoHost.config.MaxPlayers = plr;
-				SaveConfig();
-				Respond(e, &quot;server size changed&quot;);
-			}
-		}
+        private void ComRegister(TasSayEventArgs e, string[] words)
+        {
+            if (!Program.main.config.PlanetWarsEnabled) {
+                Respond(e, &quot;This is not PlanetWars host&quot;);
+                return;
+            }
+            if (words.Length &lt; 2) {
+                Respond(e, &quot;This command needs 2-3 parameters - side and password and optional planet name (you must PM it to me)&quot;);
+                return;
+            }
+            if (e.Place != TasSayEventArgs.Places.Normal) Respond(e, &quot;Please use a private message (double click my name in channel player list), its not secure to talk about passwords here&quot;);
 
-		private void ComSetMinCpuSpeed(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - minimal CPU speed&quot;);
-			else {
-				Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
-				double minCpu;
-				double.TryParse(words[0], out minCpu);
-				minCpuSpeed = minCpu;
-				SayBattle(&quot;minimal CPU speed is now &quot; + minCpuSpeed + &quot;GHz&quot;);
-				if (minCpuSpeed &gt; 0) {
-					var b = tas.GetBattle();
-					if (b != null) {
-						foreach (var ubs in b.Users) {
-							User u;
-							if (ubs.name != tas.UserName &amp;&amp; tas.GetExistingUser(ubs.name, out u)) if (u.cpu &gt; 0 &amp;&amp; u.cpu &lt; minCpuSpeed*1000) ComKick(e, new[] {u.name});
-						}
-					}
-				}
-			}
-		}
 
-		private void ComSetMinRank(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) Respond(e, &quot;this command needs one parameter - rank number&quot;);
-			else {
-				int rank;
-				int.TryParse(words[0], out rank);
-				if (rank &lt; TasClient.MinRank) rank = TasClient.MinRank;
-				if (rank &gt; TasClient.MaxRank) rank = TasClient.MaxRank;
-				Program.main.AutoHost.config.MinRank = rank;
-				SaveConfig();
-				Respond(e, &quot;server rank changed&quot;);
-				HandleMinRankKicking();
-			}
-		}
+            try {
+                var pw = Program.main.PlanetWars;
+                string response = pw.Register(new AuthInfo {Login = Program.main.config.PlanetWarsServerLogin, Password = Program.main.config.PlanetWarsServerPassword}, new AuthInfo {Login = e.UserName, Password = words[1]}, words[0], words.Length &gt; 2 ? Utils.Glue(words, 2) : null);
+                Respond(e, string.Format(response));
+            } catch (Exception ex) {
+                Respond(e, string.Format(&quot;Error when registering: {0}&quot;, ex));
+            }
+        }
 
+        private void ComSetGameTitle(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) Respond(e, &quot;this command needs one parameter - new game title&quot;);
+            else {
+                Program.main.AutoHost.config.GameTitle = Utils.Glue(words);
+                SaveConfig();
+                Respond(e, &quot;game title changed&quot;);
+            }
+        }
 
-		private void ComSetOption(TasSayEventArgs e, string[] words)
-		{
-			string ret = GetOptionsString(e, words);
-			if (ret != &quot;&quot;) {
-				tas.SetScriptTag(ret);
-				Respond(e, &quot;Options set&quot;);
-			}
-		}
+        private void ComSetMaxPlayers(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) Respond(e, &quot;this command needs one parameter - number of players&quot;);
+            else {
+                int plr;
+                int.TryParse(words[0], out plr);
+                if (plr &lt; 1) plr = 1;
+                if (plr &gt; Spring.MaxTeams) plr = Spring.MaxTeams;
+                Program.main.AutoHost.config.MaxPlayers = plr;
+                SaveConfig();
+                Respond(e, &quot;server size changed&quot;);
+            }
+        }
 
-		private void ComSetPassword(TasSayEventArgs e, string[] words)
-		{
-			if (words.Length == 0) {
-				Program.main.AutoHost.config.Password = &quot;&quot;;
-				Respond(e, &quot;password remoded&quot;);
-			} else {
-				Program.main.AutoHost.config.Password = words[0];
-				SaveConfig();
-				Respond(e, &quot;password changed&quot;);
-			}
-		}
+        private void ComSetMinCpuSpeed(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) Respond(e, &quot;this command needs one parameter - minimal CPU speed&quot;);
+            else {
+                Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
+                double minCpu;
+                double.TryParse(words[0], out minCpu);
+                minCpuSpeed = minCpu;
+                SayBattle(&quot;minimal CPU speed is now &quot; + minCpuSpeed + &quot;GHz&quot;);
+                if (minCpuSpeed &gt; 0) {
+                    var b = tas.GetBattle();
+                    if (b != null) {
+                        foreach (var ubs in b.Users) {
+                            User u;
+                            if (ubs.name != tas.UserName &amp;&amp; tas.GetExistingUser(ubs.name, out u)) if (u.cpu &gt; 0 &amp;&amp; u.cpu &lt; minCpuSpeed*1000) ComKick(e, new[] {u.name});
+                        }
+                    }
+                }
+            }
+        }
 
-		private static int FilterMaps(string[] words, TasClient tas, Spring spring, Ladder ladder, out string[] vals, out int[] indexes)
-		{
-			var temp = new string[spring.UnitSyncWrapper.MapList.Keys.Count];
-			int cnt = 0;
-			foreach (var s in spring.UnitSyncWrapper.MapList.Keys) {
-				if (ladder != null) {
-					if (ladder.Maps.Contains(s.ToLower())) temp[cnt++] = s;
-				} else {
-					var limit = Program.main.AutoHost.config.LimitMaps;
-					if (limit != null &amp;&amp; limit.Length &gt; 0) {
-						bool allowed = false;
-						for (int i = 0; i &lt; limit.Length; ++i) {
-							if (s.ToLower().Contains(limit[i].ToLower())) {
-								allowed = true;
-								break;
-							}
-						}
-						if (allowed) temp[cnt++] = s;
-					} else temp[cnt++] = s;
-				}
-			}
-			return Filter(temp, words, out vals, out indexes);
-		}
+        private void ComSetMinRank(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) Respond(e, &quot;this command needs one parameter - rank number&quot;);
+            else {
+                int rank;
+                int.TryParse(words[0], out rank);
+                if (rank &lt; TasClient.MinRank) rank = TasClient.MinRank;
+                if (rank &gt; TasClient.MaxRank) rank = TasClient.MaxRank;
+                Program.main.AutoHost.config.MinRank = rank;
+                SaveConfig();
+                Respond(e, &quot;server rank changed&quot;);
+                HandleMinRankKicking();
+            }
+        }
 
-		private int FilterMods(string[] words, out string[] vals, out int[] indexes)
-		{
-			return FilterMods(words, tas, spring, out vals, out indexes);
-		}
 
-		private int FilterPresets(string[] words, out string[] vals, out int[] indexes)
-		{
-			return FilterPresets(words, this, out vals, out indexes);
-		}
+        private void ComSetOption(TasSayEventArgs e, string[] words)
+        {
+            string ret = GetOptionsString(e, words);
+            if (ret != &quot;&quot;) {
+                tas.SetScriptTag(ret);
+                Respond(e, &quot;Options set&quot;);
+            }
+        }
 
-		private int FilterUsers(string[] words, out string[] vals, out int[] indexes)
-		{
-			return FilterUsers(words, tas, spring, out vals, out indexes);
-		}
+        private void ComSetPassword(TasSayEventArgs e, string[] words)
+        {
+            if (words.Length == 0) {
+                Program.main.AutoHost.config.Password = &quot;&quot;;
+                Respond(e, &quot;password remoded&quot;);
+            } else {
+                Program.main.AutoHost.config.Password = words[0];
+                SaveConfig();
+                Respond(e, &quot;password changed&quot;);
+            }
+        }
 
-		private static string GetClan(string name)
-		{
-			foreach (Match m in Regex.Matches(name, &quot;^\\[([^\\]]+)\\]&quot;)) return m.Groups[1].Value;
-			return &quot;&quot;;
-		}
+        private static int FilterMaps(string[] words, TasClient tas, Spring spring, Ladder ladder, out string[] vals, out int[] indexes)
+        {
+            var temp = new string[spring.UnitSyncWrapper.MapList.Keys.Count];
+            int cnt = 0;
+            foreach (var s in spring.UnitSyncWrapper.MapList.Keys) {
+                if (ladder != null) {
+                    if (ladder.Maps.Contains(s.ToLower())) temp[cnt++] = s;
+                } else {
+                    var limit = Program.main.AutoHost.config.LimitMaps;
+                    if (limit != null &amp;&amp; limit.Length &gt; 0) {
+                        bool allowed = false;
+                        for (int i = 0; i &lt; limit.Length; ++i) {
+                            if (s.ToLower().Contains(limit[i].ToLower())) {
+                                allowed = true;
+                                break;
+                            }
+                        }
+                        if (allowed) temp[cnt++] = s;
+                    } else temp[cnt++] = s;
+                }
+            }
+            return Filter(temp, words, out vals, out indexes);
+        }
 
-		private void RemoteCommand(string scriptName, TasSayEventArgs e, string[] words)
-		{
-			if (Program.main.Stats == null) {
-				Respond(e, &quot;Stats system is disabled on this autohost.&quot;);
-				return;
-			}
-			var b = tas.GetBattle();
-			if (b != null) {
-				string query = string.Format(&quot;user={0}&amp;map={1}&amp;mod={2}&amp;p={3}&quot;, e.UserName, b.Map.Name, b.Mod.Name, Utils.Glue(words));
-				foreach (var u in b.Users) if (u.name != tas.UserName) query += string.Format(&quot;&amp;users[]={0}|{1}|{2}&quot;, u.name, (u.IsSpectator ? &quot;1&quot; : &quot;0&quot;), u.AllyNumber);
-				var response = Program.main.Stats.SendCommand(scriptName, query, false, true).Split(new[] {'\r', '\n'}, StringSplitOptions.RemoveEmptyEntries);
+        private int FilterMods(string[] words, out string[] vals, out int[] indexes)
+        {
+            return FilterMods(words, tas, spring, out vals, out indexes);
+        }
 
-				if (response.Length == 0) {
-					Respond(e, &quot;error accessing stats server&quot;);
-					return;
-				}
+        private int FilterPresets(string[] words, out string[] vals, out int[] indexes)
+        {
+            return FilterPresets(words, this, out vals, out indexes);
+        }
 
-				if (response[0].StartsWith(&quot;RESPOND&quot;)) for (int i = 1; i &lt; response.Length; ++i) Respond(e, response[i]);
-				else foreach (var line in response) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
-			}
-		}
+        private int FilterUsers(string[] words, out string[] vals, out int[] indexes)
+        {
+            return FilterUsers(words, tas, spring, out vals, out indexes);
+        }
 
-		private void SayLines(TasSayEventArgs e, string what)
-		{
-			foreach (var line in what.Split(new[] {'\n', '\r'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
-		}
+        private static string GetClan(string name)
+        {
+            foreach (Match m in Regex.Matches(name, &quot;^\\[([^\\]]+)\\]&quot;)) return m.Groups[1].Value;
+            return &quot;&quot;;
+        }
 
-		#endregion
+        private void RemoteCommand(string scriptName, TasSayEventArgs e, string[] words)
+        {
+            if (Program.main.Stats == null) {
+                Respond(e, &quot;Stats system is disabled on this autohost.&quot;);
+                return;
+            }
+            var b = tas.GetBattle();
+            if (b != null) {
+                string query = string.Format(&quot;user={0}&amp;map={1}&amp;mod={2}&amp;p={3}&quot;, e.UserName, b.Map.Name, b.Mod.Name, Utils.Glue(words));
+                foreach (var u in b.Users) if (u.name != tas.UserName) query += string.Format(&quot;&amp;users[]={0}|{1}|{2}&quot;, u.name, (u.IsSpectator ? &quot;1&quot; : &quot;0&quot;), u.AllyNumber);
+                var response = Program.main.Stats.SendCommand(scriptName, query, false, true).Split(new[] {'\r', '\n'}, StringSplitOptions.RemoveEmptyEntries);
 
-		#region Nested type: UsRank
+                if (response.Length == 0) {
+                    Respond(e, &quot;error accessing stats server&quot;);
+                    return;
+                }
 
-		private class UsRank
-		{
-			#region Properties
+                if (response[0].StartsWith(&quot;RESPOND&quot;)) for (int i = 1; i &lt; response.Length; ++i) Respond(e, response[i]);
+                else foreach (var line in response) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
+            }
+        }
 
-			public string clan;
-			public int id;
-			public int rank;
+        private void SayLines(TasSayEventArgs e, string what)
+        {
+            foreach (var line in what.Split(new[] {'\n', '\r'}, StringSplitOptions.RemoveEmptyEntries)) tas.Say(TasClient.SayPlace.User, e.UserName, line, false);
+        }
 
-			#endregion
+        #endregion
 
-			#region Constructors
+        #region Nested type: UsRank
 
-			public UsRank(int id, int rank, string clan)
-			{
-				this.id = id;
-				this.rank = rank;
-				this.clan = clan;
-			}
+        private class UsRank
+        {
+            #region Properties
 
-			#endregion
-		}
+            public string clan;
+            public int id;
+            public int rank;
 
-		#endregion
-	}
+            #endregion
+
+            #region Constructors
+
+            public UsRank(int id, int rank, string clan)
+            {
+                this.id = id;
+                this.rank = rank;
+                this.clan = clan;
+            }
+
+            #endregion
+        }
+
+        #endregion
+    }
 }
\ No newline at end of file

Modified: Lobby/springie/Springie/autohost/Polls.cs
===================================================================
--- Lobby/springie/Springie/autohost/Polls.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/autohost/Polls.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -1,6 +1,7 @@
 #region using
 
 using System.Collections.Generic;
+using System.Linq;
 using Springie.Client;
 using Springie.SpringNamespace;
 
@@ -775,7 +776,7 @@
 			if (CheckEnd(out winVote)) {
 				if (winVote == 1) {
 					ah.SayBattle(&quot;vote successful - changing planet to &quot; + planet);
-					var sel = pw.GetAttackOptions().Find((p) =&gt; p.Name == planet);
+					var sel = pw.GetAttackOptions().Where(p =&gt; p.Name == planet).Single();
 					tas.ChangeMap(spring.UnitSyncWrapper.MapList[sel.MapName]);
 				} else ah.SayBattle(&quot;not enough votes, planet stays&quot;);
 				return true;

Modified: Lobby/springie/Springie/client/TasClient.cs
===================================================================
--- Lobby/springie/Springie/client/TasClient.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/client/TasClient.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -459,26 +459,31 @@
 		/// &lt;/summary&gt;
 		/// &lt;param name=&quot;place&quot;&gt;Pick user (private message) channel or battle&lt;/param&gt;
 		/// &lt;param name=&quot;channel&quot;&gt;Channel or User name&lt;/param&gt;
-		/// &lt;param name=&quot;text&quot;&gt;chat text&lt;/param&gt;
+		/// &lt;param name=&quot;inputtext&quot;&gt;chat text&lt;/param&gt;
 		/// &lt;param name=&quot;isEmote&quot;&gt;is message emote? (channel or battle only)&lt;/param&gt;
-		public void Say(SayPlace place, string channel, string text, bool isEmote)
+		public void Say(SayPlace place, string channel, string inputtext, bool isEmote)
 		{
-			if (String.IsNullOrEmpty(text)) return;
-			switch (place) {
-				case SayPlace.Channel:
-					if (isEmote) con.SendCommand(0, &quot;SAYEX&quot;, channel, text);
-					else con.SendCommand(0, &quot;SAY&quot;, channel, text);
-					break;
+            if (String.IsNullOrEmpty(inputtext)) return;
+            var lines = inputtext.Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
 
-				case SayPlace.User:
-					con.SendCommand(0, &quot;SAYPRIVATE&quot;, channel, text);
-					break;
+            foreach (string text in lines) {
+                if (String.IsNullOrEmpty(text)) return;
+                switch (place) {
+                    case SayPlace.Channel:
+                        if (isEmote) con.SendCommand(0, &quot;SAYEX&quot;, channel, text);
+                        else con.SendCommand(0, &quot;SAY&quot;, channel, text);
+                        break;
 
-				case SayPlace.Battle:
-					if (isEmote) con.SendCommand(0, &quot;SAYBATTLEEX&quot;, text);
-					else con.SendCommand(0, &quot;SAYBATTLE&quot;, text);
-					break;
-			}
+                    case SayPlace.User:
+                        con.SendCommand(0, &quot;SAYPRIVATE&quot;, channel, text);
+                        break;
+
+                    case SayPlace.Battle:
+                        if (isEmote) con.SendCommand(0, &quot;SAYBATTLEEX&quot;, text);
+                        else con.SendCommand(0, &quot;SAYBATTLE&quot;, text);
+                        break;
+                }
+            }
 		}
 
 		public void SetScriptTag(string data)

Modified: Lobby/springie/Springie/spring/Spring.cs
===================================================================
--- Lobby/springie/Springie/spring/Spring.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/spring/Spring.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -233,14 +233,15 @@
 		{
 			switch (e.EventType) {
 				case Talker.SpringEventType.PLAYER_JOINED:
+			        //Program.main.AutoHost.SayBattle(&quot;dbg joined &quot; + e.PlayerName);
 					if (PlayerJoined != null) PlayerJoined(this, new SpringLogEventArgs(e.PlayerName));
 					break;
 
 				case Talker.SpringEventType.PLAYER_LEFT:
-					if (e.Param == 0) {
-						if (PlayerDisconnected != null) PlayerDisconnected(this, new SpringLogEventArgs(e.PlayerName));
-						else if (PlayerLeft != null) PlayerLeft(this, new SpringLogEventArgs(e.PlayerName));
-					}
+					//Program.main.AutoHost.SayBattle(&quot;dbg left &quot; + e.PlayerName);
+                    if (e.Param == 0 &amp;&amp; PlayerDisconnected != null) PlayerDisconnected(this, new SpringLogEventArgs(e.PlayerName));
+					if (PlayerLeft != null) PlayerLeft(this, new SpringLogEventArgs(e.PlayerName));
+					
 					break;
 
 				case Talker.SpringEventType.PLAYER_CHAT:
@@ -249,18 +250,22 @@
 					break;
 
 				case Talker.SpringEventType.PLAYER_DEFEATED:
+                    //Program.main.AutoHost.SayBattle(&quot;dbg defeated &quot; + e.PlayerName);
 					if (PlayerLost != null) PlayerLost(this, new SpringLogEventArgs(e.PlayerName));
 					break;
 
 				case Talker.SpringEventType.SERVER_GAMEOVER:
+                    //Program.main.AutoHost.SayBattle(&quot;dbg gameover &quot; + e.PlayerName);
 					if (GameOver != null) GameOver(this, new SpringLogEventArgs(e.PlayerName));
 					break;
 
 				case Talker.SpringEventType.PLAYER_READY:
+                    //Program.main.AutoHost.SayBattle(&quot;dbg ready &quot; + e.PlayerName);
 					if (e.Param ==1) readyPlayers.Add(e.PlayerName);
 					break;
 
 				case Talker.SpringEventType.SERVER_QUIT:
+                    //Program.main.AutoHost.SayBattle(&quot;dbg quit &quot;);
 					//if (GameOver != null) GameOver(this, new SpringLogEventArgs(e.PlayerName));
 					break;
 			}

Modified: Lobby/springie/Springie/spring/Talker.cs
===================================================================
--- Lobby/springie/Springie/spring/Talker.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/spring/Talker.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -107,8 +107,12 @@
 
 		public void SendText(string text)
 		{
-			var bytes = Encoding.ASCII.GetBytes(text);
-			if (springTalkPort != 0) udp.Send(bytes, bytes.Length, &quot;127.0.0.1&quot;, springTalkPort);
+            if (String.IsNullOrEmpty(text)) return;
+            var lines = text.Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
+            foreach (string s in lines) {
+                var bytes = Encoding.ASCII.GetBytes(s.Substring(0, Math.Min(s.Length, 250))); // take only first 250 characters to prevent crashes
+                if (springTalkPort != 0) udp.Send(bytes, bytes.Length, &quot;127.0.0.1&quot;, springTalkPort);
+            }
 		}
 
 
@@ -142,8 +146,10 @@
 							sea.Param = data[2];
 							break;
 						case SpringEventType.PLAYER_READY:
-							sea.PlayerNumber = data[1];
-							sea.Param = data[2];
+                            sea.PlayerNumber = data[1];
+                            if (data.Length &lt;= 2) {
+                                sea.EventType = SpringEventType.PLAYER_DEFEATED; // hack for spring bug
+                            } else sea.Param = data[2];
 							break;
 
 						case SpringEventType.PLAYER_CHAT:

Modified: Lobby/springie/Springie/utils/Stats.cs
===================================================================
--- Lobby/springie/Springie/utils/Stats.cs	2008-11-23 04:57:05 UTC (rev 7087)
+++ Lobby/springie/Springie/utils/Stats.cs	2008-11-23 14:12:44 UTC (rev 7088)
@@ -183,12 +183,23 @@
 				try {
 					var pw = Program.main.PlanetWars;
 
-					string response = pw.SendBattleResult(new AuthInfo {Login = Program.main.config.PlanetWarsServerLogin, Password = Program.main.config.PlanetWarsServerPassword}, battle.Map.Name, players.Values);
+                    foreach (var p in players.Values) {
+                        Program.main.AutoHost.SayBattle(string.Format(&quot;name: {0}, onvictory:{1}, alivetill: {2}, side:{3}, spec:{4}&quot;, p.Name, p.OnVictoryTeam, p.AliveTillEnd, p.Side, p.Spectator));
+                    }
 
+                    ICollection&lt;RankNotification&gt; notifications;
+				    string response = pw.SendBattleResult(new AuthInfo {Login = Program.main.config.PlanetWarsServerLogin, Password = Program.main.config.PlanetWarsServerPassword}, battle.Map.Name, players.Values, out notifications);
+
+                    
 					Program.main.AutoHost.SayBattle(response);
 					foreach (var p in players.Values) if (p.Name != tas.UserName) tas.Say(TasClient.SayPlace.User, p.Name, response, false);
+
+                    foreach (var kvp in notifications) tas.Say(TasClient.SayPlace.User, kvp.Name, kvp.Text, false);
+
+				    var toNotify = pw.GetPlayersToNotify(battle.Map.Name, ReminderEvent.OnBattleEnded);
+                    foreach (string s in toNotify) tas.Say(TasClient.SayPlace.User, s, &quot;PlanetWars battle has just ended.&quot;, false);
 				} catch (Exception ex) {
-					Program.main.AutoHost.SayBattle(string.Format(&quot;Error sending planet battle result :(( {0}&quot;, ex.Message), true);
+					Program.main.AutoHost.SayBattle(string.Format(&quot;Error sending planet battle result :(( {0}&quot;, ex), true);
 				}
 			}
 
@@ -198,7 +209,10 @@
 
 		private void spring_PlayerDisconnected(object sender, SpringLogEventArgs e)
 		{
-			if (RegisterPlayerInCombat(e.Username)) players[e.Username].DisconnectTime = DateTime.Now.Subtract(startTime);
+			if (RegisterPlayerInCombat(e.Username)) {
+			    players[e.Username].DisconnectTime = DateTime.Now.Subtract(startTime);
+                players[e.Username].AliveTillEnd = false;
+			}
 		}
 
 		private void spring_PlayerJoined(object sender, SpringLogEventArgs e)
@@ -209,7 +223,10 @@
 
 		private void spring_PlayerLeft(object sender, SpringLogEventArgs e)
 		{
-			if (RegisterPlayerInCombat(e.Username)) players[e.Username].LeaveTime = DateTime.Now.Subtract(startTime);
+			if (RegisterPlayerInCombat(e.Username)) {
+			    players[e.Username].LeaveTime = DateTime.Now.Subtract(startTime);
+                players[e.Username].AliveTillEnd = false;
+			}
 		}
 
 		private void spring_PlayerLost(object sender, SpringLogEventArgs e)

Added: Lobby/springie/libs/LinqBridge.dll
===================================================================
(Binary files differ)


Property changes on: Lobby/springie/libs/LinqBridge.dll
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: Lobby/springie/libs/PlanetWarsShared.dll
===================================================================
(Binary files differ)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001856.html">[Taspring-linux-commit] r7087 - in trunk/rts: Game Rendering
</A></li>
	<LI>Next message: <A HREF="001858.html">[Taspring-linux-commit] r7089 - in Lobby/springie/Springie: . spring
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1857">[ date ]</a>
              <a href="thread.html#1857">[ thread ]</a>
              <a href="subject.html#1857">[ subject ]</a>
              <a href="author.html#1857">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
