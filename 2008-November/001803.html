<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7034 - in branches/caiinterface: . AI	AI/Wrappers AI/Wrappers/LegacyCpp rts/build/scons
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7034%20-%20in%20branches/caiinterface%3A%20.%20AI%0A%09AI/Wrappers%20AI/Wrappers/LegacyCpp%20rts/build/scons&In-Reply-To=%3C20081113095809.41ED0475F%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001802.html">
   <LINK REL="Next"  HREF="001804.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7034 - in branches/caiinterface: . AI	AI/Wrappers AI/Wrappers/LegacyCpp rts/build/scons</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7034%20-%20in%20branches/caiinterface%3A%20.%20AI%0A%09AI/Wrappers%20AI/Wrappers/LegacyCpp%20rts/build/scons&In-Reply-To=%3C20081113095809.41ED0475F%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7034 - in branches/caiinterface: . AI	AI/Wrappers AI/Wrappers/LegacyCpp rts/build/scons">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Nov 13 10:58:09 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001802.html">[Taspring-linux-commit] r7033 - in trunk: . AI AI/Global/AAI	AI/Global/JCAI AI/Global/KAI-0.2 AI/Global/KAIK-0.13	AI/Global/NTai/AI/NTai/Agents AI/Global/NTai/AI/NTai/Helpers/Terrain	AI/Global/NTai/AI/NTai/Tasks AI/Global/NTai/AI/NTai/Units	AI/Global/RAI rts tools/DedicatedServer
</A></li>
        <LI>Next message: <A HREF="001804.html">[Taspring-linux-commit] r7035 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1803">[ date ]</a>
              <a href="thread.html#1803">[ thread ]</a>
              <a href="subject.html#1803">[ subject ]</a>
              <a href="author.html#1803">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-11-13 10:58:08 +0100 (Thu, 13 Nov 2008)
New Revision: 7034

Added:
   branches/caiinterface/AI/Wrappers/
   branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h
Removed:
   branches/caiinterface/AI/Bindings/
   branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp
   branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h
Modified:
   branches/caiinterface/AI/CMakeLists.txt
   branches/caiinterface/directories.txt
   branches/caiinterface/rts/build/scons/filelist.py
Log:
* renamed AI/Bindings to AI/Wrappers

Modified: branches/caiinterface/AI/CMakeLists.txt
===================================================================
--- branches/caiinterface/AI/CMakeLists.txt	2008-11-13 09:37:35 UTC (rev 7033)
+++ branches/caiinterface/AI/CMakeLists.txt	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,4 +1,4 @@
-include_directories(${CMAKE_SOURCE_DIR}/rts ${CMAKE_SOURCE_DIR}/rts/ExternalAI ${CMAKE_SOURCE_DIR}/AI/Bindings ${CMAKE_SOURCE_DIR}/rts/System ${SDL_INCLUDE_DIR})
+include_directories(${CMAKE_SOURCE_DIR}/rts ${CMAKE_SOURCE_DIR}/rts/ExternalAI ${CMAKE_SOURCE_DIR}/AI/Wrappers ${CMAKE_SOURCE_DIR}/rts/System ${SDL_INCLUDE_DIR})
 
 add_definitions(${PIC_FLAG} -D_REENTRANT -D_GNU_SOURCE=1)
 aux_source_directory(${CMAKE_SOURCE_DIR}/rts/System/creg creg)
@@ -15,7 +15,7 @@
 #aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Lua/LuaParser luaparsingenv)
 #aux_source_directory(${CMAKE_SOURCE_DIR}/rts/Map/MapParser luaparsingenv)
 
-aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Bindings/LegacyCpp legacycppaienv)
+aux_source_directory(${CMAKE_SOURCE_DIR}/AI/Wrappers/LegacyCpp legacycppaienv)
 list (APPEND legacycppaienv ${aienv})
 list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/System/float3)
 list (APPEND legacycppaienv ${CMAKE_SOURCE_DIR}/rts/Sim/Misc/DamageArray)

Copied: branches/caiinterface/AI/Wrappers (from rev 6976, branches/caiinterface/AI/Bindings)


Property changes on: branches/caiinterface/AI/Wrappers
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AI.cpp	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,112 +0,0 @@
-/*
-	Copyright 2008  Nicolas Wu
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;AI.h&quot;
-#include &quot;Event/AIEvents.h&quot;
-#include &quot;ExternalAI/IGlobalAI.h&quot;
-#include &quot;ExternalAI/Interface/AISEvents.h&quot;
-
-CAI::CAI() : team(0), ai(NULL) {
-
-}
-
-
-CAI::CAI(int team, IGlobalAI* ai) : team(team), ai(ai) {
-
-}
-
-int CAI::handleEvent(int topic, const void* data) {
-
-	if (ai != NULL) {
-		CAIEvent* e;
-
-		switch(topic) {
-			case EVENT_NULL:
-				e = new CAINullEvent();
-				break;
-			case EVENT_INIT:
-				e = new CAIInitEvent((const SInitEvent*) data);
-				break;
-			case EVENT_UPDATE:
-				e = new CAIUpdateEvent((const SUpdateEvent*) data);
-				break;
-			case EVENT_MESSAGE:	
-				e = new CAIMessageEvent((const SMessageEvent*) data);
-				break;
-			case EVENT_UNIT_CREATED:
-				e = new CAIUnitCreatedEvent((const SUnitCreatedEvent*) data);
-				break;
-			case EVENT_UNIT_FINISHED:
-				e = new CAIUnitFinishedEvent((const SUnitFinishedEvent*) data);
-				break;
-			case EVENT_UNIT_IDLE:
-				e = new CAIUnitIdleEvent((const SUnitIdleEvent*) data);
-				break;
-			case EVENT_UNIT_MOVE_FAILED:
-				e = new CAIUnitMoveFailedEvent((const SUnitMoveFailedEvent*) data);
-				break;
-			case EVENT_UNIT_DAMAGED:
-				e = new CAIUnitDamagedEvent((const SUnitDamagedEvent*) data);
-				break;
-			case EVENT_UNIT_DESTROYED: 
-				e = new CAIUnitDestroyedEvent((const SUnitDestroyedEvent*) data);
-				break;
-			case EVENT_UNIT_GIVEN:
-				e = new CAIUnitGivenEvent((const SUnitGivenEvent*) data);
-				break;
-			case EVENT_UNIT_CAPTURED:
-				e = new CAIUnitCapturedEvent((const SUnitCapturedEvent*) data);
-				break;
-			case EVENT_ENEMY_ENTER_LOS:
-				e = new CAIEnemyEnterLOSEvent((const SEnemyEnterLOSEvent*) data);
-				break;
-			case EVENT_ENEMY_LEAVE_LOS:
-				e = new CAIEnemyLeaveLOSEvent((const SEnemyLeaveLOSEvent*) data);
-				break;
-			case EVENT_ENEMY_ENTER_RADAR:
-				e = new CAIEnemyEnterRadarEvent((const SEnemyEnterRadarEvent*) data);
-				break;
-			case EVENT_ENEMY_LEAVE_RADAR:
-				e = new CAIEnemyLeaveRadarEvent((const SEnemyLeaveRadarEvent*) data);
-				break;
-			case EVENT_ENEMY_DAMAGED:
-				e = new CAIEnemyDamagedEvent((const SEnemyDamagedEvent*) data);
-				break;
-			case EVENT_ENEMY_DESTROYED: 
-				e = new CAIEnemyDestroyedEvent((const SEnemyDestroyedEvent*) data);
-				break;
-			case EVENT_WEAPON_FIRED: 
-				e = new CAIWeaponFiredEvent((const SWeaponFiredEvent*) data);
-				break;
-			case EVENT_PLAYER_COMMAND: 
-				e = new CAIPlayerCommandEvent((const SPlayerCommandEvent*) data);
-				break;
-			case EVENT_SEISMIC_PING: 
-				e = new CAISeismicPingEvent((const SSeismicPingEvent*) data);
-				break;
-			default:
-				e = new CAINullEvent();
-				break;
-		}
-
-		e-&gt;run(ai);
-		delete e;
-	}
-
-	// signal: ok
-	return 0;
-}

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AI.cpp)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AI.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,108 @@
+/*
+	Copyright 2008  Nicolas Wu
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AI.h&quot;
+#include &quot;Event/AIEvents.h&quot;
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;ExternalAI/Interface/AISEvents.h&quot;
+
+CAI::CAI() : team(0), ai(NULL) {}
+
+CAI::CAI(int team, IGlobalAI* ai) : team(team), ai(ai) {}
+
+
+int CAI::handleEvent(int topic, const void* data) {
+
+	if (ai != NULL) {
+		CAIEvent* e;
+
+		switch(topic) {
+			case EVENT_NULL:
+				e = new CAINullEvent();
+				break;
+			case EVENT_INIT:
+				e = new CAIInitEvent((const SInitEvent*) data);
+				break;
+			case EVENT_UPDATE:
+				e = new CAIUpdateEvent((const SUpdateEvent*) data);
+				break;
+			case EVENT_MESSAGE:	
+				e = new CAIMessageEvent((const SMessageEvent*) data);
+				break;
+			case EVENT_UNIT_CREATED:
+				e = new CAIUnitCreatedEvent((const SUnitCreatedEvent*) data);
+				break;
+			case EVENT_UNIT_FINISHED:
+				e = new CAIUnitFinishedEvent((const SUnitFinishedEvent*) data);
+				break;
+			case EVENT_UNIT_IDLE:
+				e = new CAIUnitIdleEvent((const SUnitIdleEvent*) data);
+				break;
+			case EVENT_UNIT_MOVE_FAILED:
+				e = new CAIUnitMoveFailedEvent((const SUnitMoveFailedEvent*) data);
+				break;
+			case EVENT_UNIT_DAMAGED:
+				e = new CAIUnitDamagedEvent((const SUnitDamagedEvent*) data);
+				break;
+			case EVENT_UNIT_DESTROYED: 
+				e = new CAIUnitDestroyedEvent((const SUnitDestroyedEvent*) data);
+				break;
+			case EVENT_UNIT_GIVEN:
+				e = new CAIUnitGivenEvent((const SUnitGivenEvent*) data);
+				break;
+			case EVENT_UNIT_CAPTURED:
+				e = new CAIUnitCapturedEvent((const SUnitCapturedEvent*) data);
+				break;
+			case EVENT_ENEMY_ENTER_LOS:
+				e = new CAIEnemyEnterLOSEvent((const SEnemyEnterLOSEvent*) data);
+				break;
+			case EVENT_ENEMY_LEAVE_LOS:
+				e = new CAIEnemyLeaveLOSEvent((const SEnemyLeaveLOSEvent*) data);
+				break;
+			case EVENT_ENEMY_ENTER_RADAR:
+				e = new CAIEnemyEnterRadarEvent((const SEnemyEnterRadarEvent*) data);
+				break;
+			case EVENT_ENEMY_LEAVE_RADAR:
+				e = new CAIEnemyLeaveRadarEvent((const SEnemyLeaveRadarEvent*) data);
+				break;
+			case EVENT_ENEMY_DAMAGED:
+				e = new CAIEnemyDamagedEvent((const SEnemyDamagedEvent*) data);
+				break;
+			case EVENT_ENEMY_DESTROYED: 
+				e = new CAIEnemyDestroyedEvent((const SEnemyDestroyedEvent*) data);
+				break;
+			case EVENT_WEAPON_FIRED: 
+				e = new CAIWeaponFiredEvent((const SWeaponFiredEvent*) data);
+				break;
+			case EVENT_PLAYER_COMMAND: 
+				e = new CAIPlayerCommandEvent((const SPlayerCommandEvent*) data);
+				break;
+			case EVENT_SEISMIC_PING: 
+				e = new CAISeismicPingEvent((const SSeismicPingEvent*) data);
+				break;
+			default:
+				e = new CAINullEvent();
+				break;
+		}
+
+		e-&gt;run(ai);
+		delete e;
+	}
+
+	// signal: ok
+	return 0;
+}

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AI.h	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,45 +0,0 @@
-/*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef AI_H
-#define AI_H
-
-class IGlobalAI;
-
-class CAI { 
-public:
-	CAI();
-	CAI(int team, IGlobalAI* ai);
-	
-	/**
-	 * Through this function, the AI receives events from the engine.
-	 * For details about events that may arrive here, see file AISEvents.h.
-	 *
-	 * @param	topic	unique identifyer of a message
-	 *					(see EVENT_* defines in AISEvents.h)
-	 * @param	data	an topic specific struct, which contains the data
-	 *					associatedwith the event
-	 *					(see S*Event structs in AISEvents.h)
-	 * @return	ok: 0, error: != 0
-	 */
-	virtual int handleEvent(int topic, const void* data);
-
-	int team;
-	IGlobalAI* ai;
-};
-
-#endif	// AI_H

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AI.h)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AI.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,48 @@
+/*
+	Copyright 2008  Nicolas Wu
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#ifndef	AI_H
+#define	AI_H
+
+class IGlobalAI;
+
+class CAI { 
+public:
+	CAI();
+	CAI(int team, IGlobalAI* ai);
+
+	/**
+	 * Through this function, the AI receives events from the engine.
+	 * For details about events that may arrive here, see file AISEvents.h.
+	 *
+	 * @param	topic	unique identifyer of a message
+	 *					(see EVENT_* defines in AISEvents.h)
+	 * @param	data	an topic specific struct, which contains the data
+	 *					associatedwith the event
+	 *					(see S*Event structs in AISEvents.h)
+	 * @return	ok: 0, error: != 0
+	 */
+	virtual int handleEvent(int topic, const void* data);
+
+	int team;
+	IGlobalAI* ai;
+};
+
+#endif	// _AI_H

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.cpp	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,2283 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;AIAICallback.h&quot;
-
-#include &quot;ExternalAI/Interface/AISCommands.h&quot;
-
-#include &quot;creg/creg_cond.h&quot;
-#ifdef USING_CREG
-creg::Class* CCommandQueue::GetClass() { return NULL; }
-#endif
-#include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
-UnitDef::~UnitDef() {
-	delete movedata;
-}
-CIcon::CIcon() {}
-CIcon::~CIcon() {}
-UnitDef::UnitDefWeapon::UnitDefWeapon() {}
-#include &quot;Sim/Features/FeatureDef.h&quot;
-#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
-WeaponDef::~WeaponDef() {}
-
-#include &lt;string&gt;
-
-
-CAIAICallback::CAIAICallback()
-	: IAICallback(), teamId(-1), sAICallback(NULL)/*, aiCallback(NULL)*/ {
-	init();
-}
-
-CAIAICallback::CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/)
-	: IAICallback(), teamId(teamId), sAICallback(sAICallback)/*, aiCallback(aiCallback)*/ {
-	init();
-}
-
-
-void fillWithNULL(void** arr, int size) {
-	for (int i=0; i &lt; size; ++i) {
-		arr[i] = NULL;
-	}
-}
-void fillWithMinusOne(int* arr, int size) {
-	for (int i=0; i &lt; size; ++i) {
-		arr[i] = -1;
-	}
-}
-
-void CAIAICallback::init() {
-	
-	// init caches
-	int maxCacheSize = 512;
-	int maxUnits = 10000;
-	int maxGroups = 100;
-	
-	weaponDefs = new WeaponDef*[maxCacheSize]; fillWithNULL((void**)weaponDefs, maxCacheSize);
-	weaponDefFrames = new int[maxCacheSize]; fillWithMinusOne(weaponDefFrames, maxCacheSize);
-	
-	unitDefs = new UnitDef*[maxCacheSize]; fillWithNULL((void**)unitDefs, maxCacheSize);
-	unitDefFrames = new int[maxCacheSize]; fillWithMinusOne(unitDefFrames, maxCacheSize);
-	groupPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxGroups]; fillWithNULL((void**)groupPossibleCommands, maxGroups);
-	unitPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxUnits]; fillWithNULL((void**)unitPossibleCommands, maxUnits);
-	unitCurrentCommandQueues = new CCommandQueue*[maxUnits]; fillWithNULL((void**)unitCurrentCommandQueues, maxUnits);
-	
-	featureDefs = new FeatureDef*[maxCacheSize]; fillWithNULL((void**)featureDefs, maxCacheSize);
-	featureDefFrames = new int[maxCacheSize]; fillWithMinusOne(featureDefFrames, maxCacheSize);
-}
-
-
-//bool CAIAICallback::PosInCamera(float3 pos, float radius) {
-//	return aiCallback-&gt;PosInCamera(pos, radius);
-//}
-//
-//int CAIAICallback::GetCurrentFrame() {
-//	return aiCallback-&gt;GetCurrentFrame();
-//}
-//
-//int CAIAICallback::GetMyTeam() {
-//	return aiCallback-&gt;GetMyTeam();
-//}
-//
-//int CAIAICallback::GetMyAllyTeam() {
-//	return aiCallback-&gt;GetMyAllyTeam();
-//}
-//
-//int CAIAICallback::GetPlayerTeam(int player) {
-//	return aiCallback-&gt;GetPlayerTeam(player);
-//}
-//
-//const char* CAIAICallback::GetTeamSide(int team) {
-//	return aiCallback-&gt;GetTeamSide(team);
-//}
-//
-//int CAIAICallback::GetUnitGroup(int unitId) {
-//	return aiCallback-&gt;GetUnitGroup(unitId);
-//}
-//
-//int CAIAICallback::GetUnitAiHint(int unitId) {
-//	return aiCallback-&gt;GetUnitAiHint(unitId);
-//}
-//
-//int CAIAICallback::GetUnitTeam(int unitId) {
-//	return aiCallback-&gt;GetUnitTeam(unitId);
-//}
-//
-//int CAIAICallback::GetUnitAllyTeam(int unitId) {
-//	return aiCallback-&gt;GetUnitAllyTeam(unitId);
-//}
-//
-//float CAIAICallback::GetUnitHealth(int unitId) {
-//	return aiCallback-&gt;GetUnitHealth(unitId);
-//}
-//
-//float CAIAICallback::GetUnitMaxHealth(int unitId) {
-//	return aiCallback-&gt;GetUnitMaxHealth(unitId);
-//}
-//
-//float CAIAICallback::GetUnitSpeed(int unitId) {
-//	return aiCallback-&gt;GetUnitSpeed(unitId);
-//}
-//
-//float CAIAICallback::GetUnitPower(int unitId) {
-//	return aiCallback-&gt;GetUnitPower(unitId);
-//}
-//
-//float CAIAICallback::GetUnitExperience(int unitId) {
-//	return aiCallback-&gt;GetUnitExperience(unitId);
-//}
-//
-//float CAIAICallback::GetUnitMaxRange(int unitId) {
-//	return aiCallback-&gt;GetUnitMaxRange(unitId);
-//}
-//
-//bool CAIAICallback::IsUnitActivated(int unitId) {
-//	return aiCallback-&gt;IsUnitActivated(unitId);
-//}
-//
-//bool CAIAICallback::UnitBeingBuilt(int unitId) {
-//	return aiCallback-&gt;UnitBeingBuilt(unitId);
-//}
-//
-//float3 CAIAICallback::GetUnitPos(int unitId) {
-//	return aiCallback-&gt;GetUnitPos(unitId);
-//}
-//
-//int CAIAICallback::GetBuildingFacing(int unitId) {
-//	return aiCallback-&gt;GetBuildingFacing(unitId);
-//}
-//
-//bool CAIAICallback::IsUnitCloaked(int unitId) {
-//	return aiCallback-&gt;IsUnitCloaked(unitId);
-//}
-//
-//bool CAIAICallback::IsUnitParalyzed(int unitId) {
-//	return aiCallback-&gt;IsUnitParalyzed(unitId);
-//}
-//
-//bool CAIAICallback::IsUnitNeutral(int unitId) {
-//	return aiCallback-&gt;IsUnitNeutral(unitId);
-//}
-//
-//bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
-//	return aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
-//}
-//
-//float3 CAIAICallback::GetNextWaypoint(int pathid) {
-//	return aiCallback-&gt;GetNextWaypoint(pathid);
-//}
-//
-//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
-//	return aiCallback-&gt;GetPathLength(start, end, pathType);
-//}
-//
-//int CAIAICallback::GetEnemyUnits(int* unitIds) {
-//	return aiCallback-&gt;GetEnemyUnits(unitIds);
-//}
-//
-//int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
-//	return aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
-//}
-//
-//int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
-//	return aiCallback-&gt;GetEnemyUnitsInRadarAndLos(unitIds);
-//}
-//
-//int CAIAICallback::GetFriendlyUnits(int* unitIds) {
-//	return aiCallback-&gt;GetFriendlyUnits(unitIds);
-//}
-//
-//int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
-//	return aiCallback-&gt;GetFriendlyUnits(unitIds, pos, radius);
-//}
-//
-//int CAIAICallback::GetNeutralUnits(int* unitIds) {
-//	return aiCallback-&gt;GetNeutralUnits(unitIds);
-//}
-//
-//int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
-//	return aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
-//}
-//
-//int CAIAICallback::GetMapWidth() {
-//	return aiCallback-&gt;GetMapWidth();
-//}
-//
-//int CAIAICallback::GetMapHeight() {
-//	return aiCallback-&gt;GetMapHeight();
-//}
-//
-//const float* CAIAICallback::GetHeightMap() {
-//	return aiCallback-&gt;GetHeightMap();
-//}
-//
-//float CAIAICallback::GetMinHeight() {
-//	return aiCallback-&gt;GetMinHeight();
-//}
-//
-//float CAIAICallback::GetMaxHeight() {
-//	return aiCallback-&gt;GetMaxHeight();
-//}
-//
-//const float* CAIAICallback::GetSlopeMap() {
-//	return aiCallback-&gt;GetSlopeMap();
-//}
-//
-//const unsigned short* CAIAICallback::GetLosMap() {
-//	return aiCallback-&gt;GetLosMap();
-//}
-//
-//const unsigned short* CAIAICallback::GetRadarMap() {
-//	return aiCallback-&gt;GetRadarMap();
-//}
-//
-//const unsigned short* CAIAICallback::GetJammerMap() {
-//	return aiCallback-&gt;GetJammerMap();
-//}
-//
-//const unsigned char* CAIAICallback::GetMetalMap() {
-//	return aiCallback-&gt;GetMetalMap();
-//}
-//
-//const char* CAIAICallback::GetMapName() {
-//	return aiCallback-&gt;GetMapName();
-//}
-//
-//const char* CAIAICallback::GetModName() {
-//	return aiCallback-&gt;GetModName();
-//}
-//
-//float CAIAICallback::GetElevation(float x, float z) {
-//	return aiCallback-&gt;GetElevation(x, z);
-//}
-//
-//float CAIAICallback::GetMaxMetal() {
-//	return aiCallback-&gt;GetMaxMetal();
-//}
-//
-//float CAIAICallback::GetExtractorRadius() {
-//	return aiCallback-&gt;GetExtractorRadius();
-//}
-//
-//float CAIAICallback::GetMinWind() {
-//	return aiCallback-&gt;GetMinWind();
-//}
-//
-//float CAIAICallback::GetMaxWind() {
-//	return aiCallback-&gt;GetMaxWind();
-//}
-//
-//float CAIAICallback::GetTidalStrength() {
-//	return aiCallback-&gt;GetTidalStrength();
-//}
-//
-//float CAIAICallback::GetGravity() {
-//	return aiCallback-&gt;GetGravity();
-//}
-//
-//bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
-//	return aiCallback-&gt;CanBuildAt(unitDef, pos, facing);
-//}
-//
-//float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
-//	return aiCallback-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing);
-//}
-//
-//bool CAIAICallback::GetProperty(int id, int property, void* dst) {
-//	return aiCallback-&gt;GetProperty(id, property, dst);
-//}
-//
-//bool CAIAICallback::GetValue(int id, void* dst) {
-//	return aiCallback-&gt;GetValue(id, dst);
-//}
-//
-//int CAIAICallback::GetFileSize(const char* name) {
-//	return aiCallback-&gt;GetFileSize(name);
-//}
-//
-//int CAIAICallback::GetSelectedUnits(int* unitIds) {
-//	return aiCallback-&gt;GetSelectedUnits(unitIds);
-//}
-//
-//float3 CAIAICallback::GetMousePos() {
-//	return aiCallback-&gt;GetMousePos();
-//}
-//
-//float CAIAICallback::GetMetal() {
-//	return aiCallback-&gt;GetMetal();
-//}
-//
-//float CAIAICallback::GetMetalIncome() {
-//	return aiCallback-&gt;GetMetalIncome();
-//}
-//
-//float CAIAICallback::GetMetalUsage() {
-//	return aiCallback-&gt;GetMetalUsage();
-//}
-//
-//float CAIAICallback::GetMetalStorage() {
-//	return aiCallback-&gt;GetMetalStorage();
-//}
-//
-//float CAIAICallback::GetEnergy() {
-//	return aiCallback-&gt;GetEnergy();
-//}
-//
-//float CAIAICallback::GetEnergyIncome() {
-//	return aiCallback-&gt;GetEnergyIncome();
-//}
-//
-//float CAIAICallback::GetEnergyUsage() {
-//	return aiCallback-&gt;GetEnergyUsage();
-//}
-//
-//float CAIAICallback::GetEnergyStorage() {
-//	return aiCallback-&gt;GetEnergyStorage();
-//}
-//
-//int CAIAICallback::GetFeatures(int *features, int max) {
-//	return aiCallback-&gt;GetFeatures(features, max);
-//}
-//
-//int CAIAICallback::GetFeatures(int *features, int max, const float3&amp; pos, float radius) {
-//	return aiCallback-&gt;GetFeatures(features, max, pos, radius);
-//}
-//
-//const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
-//	return aiCallback-&gt;GetFeatureDef(featureId);
-//}
-//
-//float CAIAICallback::GetFeatureHealth(int featureId) {
-//	return aiCallback-&gt;GetFeatureHealth(featureId);
-//}
-//
-//float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
-//	return aiCallback-&gt;GetFeatureReclaimLeft(featureId);
-//}
-//
-//float3 CAIAICallback::GetFeaturePos(int featureId) {
-//	return aiCallback-&gt;GetFeaturePos(featureId);
-//}
-//
-//int CAIAICallback::GetNumUnitDefs() {
-//	return aiCallback-&gt;GetNumUnitDefs();
-//}
-//
-//void CAIAICallback::GetUnitDefList(const UnitDef** list) {
-//	aiCallback-&gt;GetUnitDefList(list);
-//}
-
-//float CAIAICallback::GetUnitDefHeight(int def) {
-//	return aiCallback-&gt;GetUnitDefHeight(def);
-//}
-//
-//float CAIAICallback::GetUnitDefRadius(int def) {
-//	return aiCallback-&gt;GetUnitDefRadius(def);
-//}
-//
-//const float3* CAIAICallback::GetStartPos() {
-//	return aiCallback-&gt;GetStartPos();
-//}
-//
-//
-//
-//const WeaponDef* CAIAICallback::GetWeapon(const char* weaponname) {
-//	logT(&quot;CAIAICallback::GetWeapon() aiCallback&quot;);
-//	return aiCallback-&gt;GetWeapon(weaponname);
-//}
-//
-//const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
-//	logT(&quot;CAIAICallback::GetWeaponDefById() return NULL&quot;);
-//	return NULL;
-//}
-//
-//const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
-//	logT(&quot;CAIAICallback::GetFeatureDefById() aiCallback&quot;);
-//	return aiCallback-&gt;GetFeatureDefById(featureDefId);
-//}
-//
-//int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
-//	return aiCallback-&gt;GetMapPoints(pm, maxPoints);
-//}
-//
-//int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
-//	return aiCallback-&gt;GetMapLines(lm, maxLines);
-//}
-//
-//const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
-//	return aiCallback-&gt;GetUnitDef(unitName);
-//}
-
-//const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
-//	return aiCallback-&gt;GetUnitDefById(unitDefId);
-//}
-
-//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int unitId) {
-//	return aiCallback-&gt;GetGroupCommands(unitId);
-//}
-//
-//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
-//	return aiCallback-&gt;GetUnitCommands(unitId);
-//}
-//
-//const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
-//	return aiCallback-&gt;GetCurrentUnitCommands(unitId);
-//}
-//
-//const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
-//	return aiCallback-&gt;GetUnitDef(unitId);
-//}
-
-
-
-
-
-
-
-//void CAIAICallback::SendTextMsg(const char* text, int zone) {
-//	aiCallback-&gt;SendTextMsg(text, zone);
-//}
-//
-//void CAIAICallback::SetLastMsgPos(float3 pos) {
-//	aiCallback-&gt;SetLastMsgPos(pos);
-//}
-//
-//void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
-//	aiCallback-&gt;AddNotification(pos, color, alpha);
-//}
-//
-//bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
-//	return aiCallback-&gt;SendResources(mAmount, eAmount, receivingTeam);
-//}
-//
-//int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam) {
-//	return aiCallback-&gt;SendUnits(unitIDs, receivingTeam);
-//}
-//
-//void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
-//	return aiCallback-&gt;CreateSharedMemArea(name, size);
-//}
-//
-//void CAIAICallback::ReleasedSharedMemArea(char* name) {
-//	aiCallback-&gt;ReleasedSharedMemArea(name);
-//}
-//
-//int CAIAICallback::CreateGroup(char* dll, unsigned aiNumber) {
-//	return aiCallback-&gt;CreateGroup(dll, aiNumber);
-//}
-//
-//void CAIAICallback::EraseGroup(int groupid) {
-//	aiCallback-&gt;EraseGroup(groupid);
-//}
-//
-//bool CAIAICallback::AddUnitToGroup(int unitId, int groupid) {
-//	return aiCallback-&gt;AddUnitToGroup(unitId, groupid);
-//}
-//
-//bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
-//	return aiCallback-&gt;RemoveUnitFromGroup(unitId);
-//}
-//
-//int CAIAICallback::GiveGroupOrder(int unitId, Command* c) {
-//	return aiCallback-&gt;GiveGroupOrder(unitId, c);
-//}
-//
-//int CAIAICallback::GiveOrder(int unitId, Command* c) {
-//	return aiCallback-&gt;GiveOrder(unitId, c);
-//}
-//
-//int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
-//	return aiCallback-&gt;InitPath(start, end, pathType);
-//}
-//
-//float3 CAIAICallback::GetNextWaypoint(int pathId) {
-//	return aiCallback-&gt;GetNextWaypoint(pathId);
-//}
-//
-//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
-//	return aiCallback-&gt;GetPathLength(start, end, pathType);
-//}
-//
-//void CAIAICallback::FreePath(int pathid) {
-//	aiCallback-&gt;FreePath(pathid);
-//}
-//
-//void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
-//	aiCallback-&gt;LineDrawerStartPath(pos, color);
-//}
-//
-//void CAIAICallback::LineDrawerFinishPath() {
-//	aiCallback-&gt;LineDrawerFinishPath();
-//}
-//
-//void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
-//	aiCallback-&gt;LineDrawerDrawLine(endPos, color);
-//}
-//
-//void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color) {
-//	aiCallback-&gt;LineDrawerDrawLineAndIcon(cmdID, endPos, color);
-//}
-//
-//void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdID) {
-//	aiCallback-&gt;LineDrawerDrawIconAtLastPos(cmdID);
-//}
-//
-//void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
-//	aiCallback-&gt;LineDrawerBreak(endPos, color);
-//}
-//
-//void CAIAICallback::LineDrawerRestart() {
-//	aiCallback-&gt;LineDrawerRestart();
-//}
-//
-//void CAIAICallback::LineDrawerRestartSameColor() {
-//	aiCallback-&gt;LineDrawerRestartSameColor();
-//}
-//
-//int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group) {
-//	return aiCallback-&gt;CreateSplineFigure(pos1, pos2, pos3, pos4, width, arrow, lifetime, group);
-//}
-//
-//int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group) {
-//	return aiCallback-&gt;CreateLineFigure(pos1, pos2, width, arrow, lifetime, group);
-//}
-//
-//void CAIAICallback::SetFigureColor(int group, float red, float green, float blue, float alpha) {
-//	aiCallback-&gt;SetFigureColor(group, red, green, blue, alpha);
-//}
-//
-//void CAIAICallback::DeleteFigureGroup(int group) {
-//	aiCallback-&gt;DeleteFigureGroup(group);
-//}
-//
-//void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
-//	aiCallback-&gt;DrawUnit(name, pos, rotation, lifetime, team, transparent, drawBorder, facing);
-//}
-//
-//int CAIAICallback::HandleCommand(int commandId, void* data) {
-//	return aiCallback-&gt;HandleCommand(commandId, data);
-//}
-//
-//bool CAIAICallback::ReadFile(const char* name, void* buffer, int bufferLen) {
-//	return aiCallback-&gt;ReadFile(name, buffer, bufferLen);
-//}
-//
-//const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
-//	return aiCallback-&gt;CallLuaRules(data, inSize, outSize);
-//}
-// ################################ &lt;- OLD impl ################################
-
-
-
-
-// ################################ NEW impl -&gt; ################################
-bool CAIAICallback::PosInCamera(float3 pos, float radius) {
-	return sAICallback-&gt;Map_isPosInCamera(teamId, pos.toSAIFloat3(), radius);
-}
-
-int CAIAICallback::GetCurrentFrame() {
-	return sAICallback-&gt;Game_getCurrentFrame(teamId);
-}
-
-int CAIAICallback::GetMyTeam() {
-	return sAICallback-&gt;Game_getMyTeam(teamId);
-}
-
-int CAIAICallback::GetMyAllyTeam() {
-	return sAICallback-&gt;Game_getMyAllyTeam(teamId);
-}
-
-int CAIAICallback::GetPlayerTeam(int player) {
-	return sAICallback-&gt;Game_getPlayerTeam(teamId, player);
-}
-
-const char* CAIAICallback::GetTeamSide(int team) {
-	return sAICallback-&gt;Game_getTeamSide(teamId, team);
-}
-
-int CAIAICallback::GetUnitGroup(int unitId) {
-	return sAICallback-&gt;Unit_getGroup(teamId, unitId);
-}
-
-
-/*
-const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
-	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
-	int ids[numCmds];
-	const char* names[numCmds];
-	const char* toolTips[numCmds];
-	bool showUniques[numCmds];
-	bool disableds[numCmds];
-	int numParams[numCmds];
-	const char** params[numCmds];
-	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
-	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
-	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
-	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
-	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
-	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
-	for (int c=0; c &lt; numCmds; c++) {
-		params[c] = new const char*[numParams[c]];
-	}
-	sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, params);
-	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
-	for (int c=0; c &lt; numCmds; c++) {
-		CommandDescription commandDescription;
-		commandDescription.id = ids[c];
-		commandDescription.name = names[c];
-		commandDescription.tooltip = toolTips[c];
-		commandDescription.showUnique = showUniques[c];
-		commandDescription.disabled = disableds[c];
-		for (int p=0; p &lt; numParams[c]; p++) {
-			commandDescription.params.push_back(params[c][p]);
-		}
-		cmdDescVec-&gt;push_back(commandDescription);
-	}
-	
-	// to prevent memory wholes
-	if (groupPossibleCommands[groupId] != NULL) {
-		delete groupPossibleCommands[groupId];
-	}
-	groupPossibleCommands[groupId] = cmdDescVec;
-	
-	return cmdDescVec;
-}
-*/
-const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
-	
-	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
-	
-	int ids[numCmds];
-	const char* names[numCmds];
-	const char* toolTips[numCmds];
-	bool showUniques[numCmds];
-	bool disableds[numCmds];
-	int numParams[numCmds];
-	
-	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
-	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
-	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
-	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
-	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
-	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
-	
-	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
-	for (int c=0; c &lt; numCmds; c++) {
-		const char* params[numParams[c]];
-		sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, c, params);
-		
-		CommandDescription commandDescription;
-		commandDescription.id = ids[c];
-		commandDescription.name = names[c];
-		commandDescription.tooltip = toolTips[c];
-		commandDescription.showUnique = showUniques[c];
-		commandDescription.disabled = disableds[c];
-		for (int p=0; p &lt; numParams[c]; p++) {
-			commandDescription.params.push_back(params[p]);
-		}
-		cmdDescVec-&gt;push_back(commandDescription);
-	}
-	
-	// to prevent memory wholes
-	if (groupPossibleCommands[groupId] != NULL) {
-		delete groupPossibleCommands[groupId];
-	}
-	groupPossibleCommands[groupId] = cmdDescVec;
-	
-	return cmdDescVec;
-}
-
-
-const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
-	
-	int numCmds = sAICallback-&gt;Unit_getNumSupportedCommands(teamId, unitId);
-	
-	int* ids = new int[numCmds];
-	const char* names[numCmds];
-	const char* toolTips[numCmds];
-	bool showUniques[numCmds];
-	bool disableds[numCmds];
-	int numParams[numCmds];
-	
-	sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
-	sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
-	sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
-	sAICallback-&gt;Unit_SupportedCommands_isShowUnique(teamId, unitId, showUniques);
-	sAICallback-&gt;Unit_SupportedCommands_isDisabled(teamId, unitId, disableds);
-	sAICallback-&gt;Unit_SupportedCommands_getNumParams(teamId, unitId, numParams);
-
-	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
-	for (int c=0; c &lt; numCmds; c++) {
-		const char* params[numParams[c]];
-		sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, c, params);
-		
-		CommandDescription commandDescription;
-		commandDescription.id = ids[c];
-		commandDescription.name = names[c];
-		commandDescription.tooltip = toolTips[c];
-		commandDescription.showUnique = showUniques[c];
-		commandDescription.disabled = disableds[c];
-		for (int p=0; p &lt; numParams[c]; p++) {
-			commandDescription.params.push_back(params[p]);
-		}
-		cmdDescVec-&gt;push_back(commandDescription);
-	}
-	
-	// to prevent memory wholes
-	if (unitPossibleCommands[unitId] != NULL) {
-		delete unitPossibleCommands[unitId];
-	}
-	unitPossibleCommands[unitId] = cmdDescVec;
-	
-	return cmdDescVec;
-}
-
-const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
-
-	int numCmds = sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
-
-	int ids[numCmds];
-	unsigned char options[numCmds];
-	unsigned int tags[numCmds];
-	int timeOuts[numCmds];
-	int numParams[numCmds];
-
-	sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
-	sAICallback-&gt;Unit_CurrentCommands_getIds(teamId, unitId, ids);
-	sAICallback-&gt;Unit_CurrentCommands_getOptions(teamId, unitId, options);
-	sAICallback-&gt;Unit_CurrentCommands_getTag(teamId, unitId, tags);
-	sAICallback-&gt;Unit_CurrentCommands_getTimeOut(teamId, unitId, timeOuts);
-	sAICallback-&gt;Unit_CurrentCommands_getNumParams(teamId, unitId, numParams);
-
-	CCommandQueue* cc = new CCommandQueue();
-	for (int c=0; c &lt; numCmds; c++) {
-		float params[numParams[c]];
-		sAICallback-&gt;Unit_CurrentCommands_getParams(teamId, unitId, c, params);
-
-		Command command;
-		command.id = ids[c];
-		command.options = options[c];
-		command.tag = tags[c];
-		command.timeOut = timeOuts[c];
-		for (int p=0; p &lt; numParams[c]; p++) {
-			command.params.push_back(params[p]);
-		}
-		cc-&gt;push_back(command);
-	}
-	
-	// to prevent memory wholes
-	if (unitCurrentCommandQueues[unitId] != NULL) {
-		delete unitCurrentCommandQueues[unitId];
-	}
-	unitCurrentCommandQueues[unitId] = cc;
-	
-	return cc;
-}
-
-int CAIAICallback::GetUnitAiHint(int unitId) {
-	return sAICallback-&gt;Unit_getAiHint(teamId, unitId);
-}
-
-int CAIAICallback::GetUnitTeam(int unitId) {
-	return sAICallback-&gt;Unit_getTeam(teamId, unitId);
-}
-
-int CAIAICallback::GetUnitAllyTeam(int unitId) {
-	return sAICallback-&gt;Unit_getAllyTeam(teamId, unitId);
-}
-
-float CAIAICallback::GetUnitHealth(int unitId) {
-	return sAICallback-&gt;Unit_getHealth(teamId, unitId);
-}
-
-float CAIAICallback::GetUnitMaxHealth(int unitId) {
-	return sAICallback-&gt;Unit_getMaxHealth(teamId, unitId);
-}
-
-float CAIAICallback::GetUnitSpeed(int unitId) {
-	return sAICallback-&gt;Unit_getSpeed(teamId, unitId);
-}
-
-float CAIAICallback::GetUnitPower(int unitId) {
-	return sAICallback-&gt;Unit_getPower(teamId, unitId);
-}
-
-float CAIAICallback::GetUnitExperience(int unitId) {
-	return sAICallback-&gt;Unit_getExperience(teamId, unitId);
-}
-
-float CAIAICallback::GetUnitMaxRange(int unitId) {
-	return sAICallback-&gt;Unit_getMaxRange(teamId, unitId);
-}
-
-bool CAIAICallback::IsUnitActivated(int unitId) {
-	return sAICallback-&gt;Unit_isActivated(teamId, unitId);
-}
-
-bool CAIAICallback::UnitBeingBuilt(int unitId) {
-	return sAICallback-&gt;Unit_isBeingBuilt(teamId, unitId);
-}
-
-const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
-	int unitDefId = sAICallback-&gt;Unit_getDefId(teamId, unitId);
-	return this-&gt;GetUnitDefById(unitDefId);
-}
-
-float3 CAIAICallback::GetUnitPos(int unitId) {
-	return float3(sAICallback-&gt;Unit_getPos(teamId, unitId));
-}
-
-int CAIAICallback::GetBuildingFacing(int unitId) {
-	return sAICallback-&gt;Unit_getBuildingFacing(teamId, unitId);
-}
-
-bool CAIAICallback::IsUnitCloaked(int unitId) {
-	return sAICallback-&gt;Unit_isCloaked(teamId, unitId);
-}
-
-bool CAIAICallback::IsUnitParalyzed(int unitId) {
-	return sAICallback-&gt;Unit_isParalyzed(teamId, unitId);
-}
-
-bool CAIAICallback::IsUnitNeutral(int unitId) {
-	return sAICallback-&gt;Unit_isNeutral(teamId, unitId);
-}
-
-bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
-	resourceInfo-&gt;energyMake = sAICallback-&gt;Unit_ResourceInfo_Energy_getMake(teamId, unitId);
-	if (resourceInfo-&gt;energyMake &lt; 0) return false;
-	resourceInfo-&gt;energyUse = sAICallback-&gt;Unit_ResourceInfo_Energy_getUse(teamId, unitId);
-	resourceInfo-&gt;metalMake = sAICallback-&gt;Unit_ResourceInfo_Metal_getMake(teamId, unitId);
-	resourceInfo-&gt;metalUse = sAICallback-&gt;Unit_ResourceInfo_Metal_getUse(teamId, unitId);
-	return true;
-}
-
-const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
-	int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitName);
-	return this-&gt;GetUnitDefById(unitDefId);
-}
-
-
-const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
-	//logT(&quot;entering: GetUnitDefById sAICallback&quot;);
-	
-	if (unitDefId &lt; 0) {
-		return NULL;
-	}
-	
-	bool doRecreate = unitDefFrames[unitDefId] &lt; 0;
-	if (doRecreate) {
-//		int currentFrame = this-&gt;GetCurrentFrame();
-		int currentFrame = 1;
-	UnitDef* unitDef = new UnitDef();
-unitDef-&gt;valid = sAICallback-&gt;UnitDef_isValid(teamId, unitDefId);
-unitDef-&gt;name = sAICallback-&gt;UnitDef_getName(teamId, unitDefId);
-unitDef-&gt;humanName = sAICallback-&gt;UnitDef_getHumanName(teamId, unitDefId);
-unitDef-&gt;filename = sAICallback-&gt;UnitDef_getFilename(teamId, unitDefId);
-unitDef-&gt;id = sAICallback-&gt;UnitDef_getId(teamId, unitDefId);
-unitDef-&gt;aihint = sAICallback-&gt;UnitDef_getAiHint(teamId, unitDefId);
-unitDef-&gt;cobID = sAICallback-&gt;UnitDef_getCobID(teamId, unitDefId);
-unitDef-&gt;techLevel = sAICallback-&gt;UnitDef_getTechLevel(teamId, unitDefId);
-unitDef-&gt;gaia = sAICallback-&gt;UnitDef_getGaia(teamId, unitDefId);
-unitDef-&gt;metalUpkeep = sAICallback-&gt;UnitDef_getMetalUpkeep(teamId, unitDefId);
-unitDef-&gt;energyUpkeep = sAICallback-&gt;UnitDef_getEnergyUpkeep(teamId, unitDefId);
-unitDef-&gt;metalMake = sAICallback-&gt;UnitDef_getMetalMake(teamId, unitDefId);
-unitDef-&gt;makesMetal = sAICallback-&gt;UnitDef_getMakesMetal(teamId, unitDefId);
-unitDef-&gt;energyMake = sAICallback-&gt;UnitDef_getEnergyMake(teamId, unitDefId);
-unitDef-&gt;metalCost = sAICallback-&gt;UnitDef_getMetalCost(teamId, unitDefId);
-unitDef-&gt;energyCost = sAICallback-&gt;UnitDef_getEnergyCost(teamId, unitDefId);
-unitDef-&gt;buildTime = sAICallback-&gt;UnitDef_getBuildTime(teamId, unitDefId);
-unitDef-&gt;extractsMetal = sAICallback-&gt;UnitDef_getExtractsMetal(teamId, unitDefId);
-unitDef-&gt;extractRange = sAICallback-&gt;UnitDef_getExtractRange(teamId, unitDefId);
-unitDef-&gt;windGenerator = sAICallback-&gt;UnitDef_getWindGenerator(teamId, unitDefId);
-unitDef-&gt;tidalGenerator = sAICallback-&gt;UnitDef_getTidalGenerator(teamId, unitDefId);
-unitDef-&gt;metalStorage = sAICallback-&gt;UnitDef_getMetalStorage(teamId, unitDefId);
-unitDef-&gt;energyStorage = sAICallback-&gt;UnitDef_getEnergyStorage(teamId, unitDefId);
-unitDef-&gt;autoHeal = sAICallback-&gt;UnitDef_getAutoHeal(teamId, unitDefId);
-unitDef-&gt;idleAutoHeal = sAICallback-&gt;UnitDef_getIdleAutoHeal(teamId, unitDefId);
-unitDef-&gt;idleTime = sAICallback-&gt;UnitDef_getIdleTime(teamId, unitDefId);
-unitDef-&gt;power = sAICallback-&gt;UnitDef_getPower(teamId, unitDefId);
-unitDef-&gt;health = sAICallback-&gt;UnitDef_getHealth(teamId, unitDefId);
-unitDef-&gt;category = sAICallback-&gt;UnitDef_getCategory(teamId, unitDefId);
-unitDef-&gt;speed = sAICallback-&gt;UnitDef_getSpeed(teamId, unitDefId);
-unitDef-&gt;turnRate = sAICallback-&gt;UnitDef_getTurnRate(teamId, unitDefId);
-unitDef-&gt;turnInPlace = sAICallback-&gt;UnitDef_isTurnInPlace(teamId, unitDefId);
-unitDef-&gt;moveType = sAICallback-&gt;UnitDef_getMoveType(teamId, unitDefId);
-unitDef-&gt;upright = sAICallback-&gt;UnitDef_isUpright(teamId, unitDefId);
-unitDef-&gt;collide = sAICallback-&gt;UnitDef_isCollide(teamId, unitDefId);
-unitDef-&gt;controlRadius = sAICallback-&gt;UnitDef_getControlRadius(teamId, unitDefId);
-unitDef-&gt;losRadius = sAICallback-&gt;UnitDef_getLosRadius(teamId, unitDefId);
-unitDef-&gt;airLosRadius = sAICallback-&gt;UnitDef_getAirLosRadius(teamId, unitDefId);
-unitDef-&gt;losHeight = sAICallback-&gt;UnitDef_getLosHeight(teamId, unitDefId);
-unitDef-&gt;radarRadius = sAICallback-&gt;UnitDef_getRadarRadius(teamId, unitDefId);
-unitDef-&gt;sonarRadius = sAICallback-&gt;UnitDef_getSonarRadius(teamId, unitDefId);
-unitDef-&gt;jammerRadius = sAICallback-&gt;UnitDef_getJammerRadius(teamId, unitDefId);
-unitDef-&gt;sonarJamRadius = sAICallback-&gt;UnitDef_getSonarJamRadius(teamId, unitDefId);
-unitDef-&gt;seismicRadius = sAICallback-&gt;UnitDef_getSeismicRadius(teamId, unitDefId);
-unitDef-&gt;seismicSignature = sAICallback-&gt;UnitDef_getSeismicSignature(teamId, unitDefId);
-unitDef-&gt;stealth = sAICallback-&gt;UnitDef_isStealth(teamId, unitDefId);
-unitDef-&gt;sonarStealth = sAICallback-&gt;UnitDef_isSonarStealth(teamId, unitDefId);
-unitDef-&gt;buildRange3D = sAICallback-&gt;UnitDef_isBuildRange3D(teamId, unitDefId);
-unitDef-&gt;buildDistance = sAICallback-&gt;UnitDef_getBuildDistance(teamId, unitDefId);
-unitDef-&gt;buildSpeed = sAICallback-&gt;UnitDef_getBuildSpeed(teamId, unitDefId);
-unitDef-&gt;reclaimSpeed = sAICallback-&gt;UnitDef_getReclaimSpeed(teamId, unitDefId);
-unitDef-&gt;repairSpeed = sAICallback-&gt;UnitDef_getRepairSpeed(teamId, unitDefId);
-unitDef-&gt;maxRepairSpeed = sAICallback-&gt;UnitDef_getMaxRepairSpeed(teamId, unitDefId);
-unitDef-&gt;resurrectSpeed = sAICallback-&gt;UnitDef_getResurrectSpeed(teamId, unitDefId);
-unitDef-&gt;captureSpeed = sAICallback-&gt;UnitDef_getCaptureSpeed(teamId, unitDefId);
-unitDef-&gt;terraformSpeed = sAICallback-&gt;UnitDef_getTerraformSpeed(teamId, unitDefId);
-unitDef-&gt;mass = sAICallback-&gt;UnitDef_getMass(teamId, unitDefId);
-unitDef-&gt;pushResistant = sAICallback-&gt;UnitDef_isPushResistant(teamId, unitDefId);
-unitDef-&gt;strafeToAttack = sAICallback-&gt;UnitDef_isStrafeToAttack(teamId, unitDefId);
-unitDef-&gt;minCollisionSpeed = sAICallback-&gt;UnitDef_getMinCollisionSpeed(teamId, unitDefId);
-unitDef-&gt;slideTolerance = sAICallback-&gt;UnitDef_getSlideTolerance(teamId, unitDefId);
-unitDef-&gt;maxSlope = sAICallback-&gt;UnitDef_getMaxSlope(teamId, unitDefId);
-unitDef-&gt;maxHeightDif = sAICallback-&gt;UnitDef_getMaxHeightDif(teamId, unitDefId);
-unitDef-&gt;minWaterDepth = sAICallback-&gt;UnitDef_getMinWaterDepth(teamId, unitDefId);
-unitDef-&gt;waterline = sAICallback-&gt;UnitDef_getWaterline(teamId, unitDefId);
-unitDef-&gt;maxWaterDepth = sAICallback-&gt;UnitDef_getMaxWaterDepth(teamId, unitDefId);
-unitDef-&gt;armoredMultiple = sAICallback-&gt;UnitDef_getArmoredMultiple(teamId, unitDefId);
-unitDef-&gt;armorType = sAICallback-&gt;UnitDef_getArmorType(teamId, unitDefId);
-unitDef-&gt;flankingBonusMode = sAICallback-&gt;UnitDef_getFlankingBonusMode(teamId, unitDefId);
-unitDef-&gt;flankingBonusDir = float3(sAICallback-&gt;UnitDef_getFlankingBonusDir(teamId, unitDefId));
-unitDef-&gt;flankingBonusMax = sAICallback-&gt;UnitDef_getFlankingBonusMax(teamId, unitDefId);
-unitDef-&gt;flankingBonusMin = sAICallback-&gt;UnitDef_getFlankingBonusMin(teamId, unitDefId);
-unitDef-&gt;flankingBonusMobilityAdd = sAICallback-&gt;UnitDef_getFlankingBonusMobilityAdd(teamId, unitDefId);
-unitDef-&gt;collisionVolumeType = sAICallback-&gt;UnitDef_getCollisionVolumeType(teamId, unitDefId);
-unitDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;UnitDef_getCollisionVolumeScales(teamId, unitDefId));
-unitDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;UnitDef_getCollisionVolumeOffsets(teamId, unitDefId));
-unitDef-&gt;collisionVolumeTest = sAICallback-&gt;UnitDef_getCollisionVolumeTest(teamId, unitDefId);
-unitDef-&gt;maxWeaponRange = sAICallback-&gt;UnitDef_getMaxWeaponRange(teamId, unitDefId);
-unitDef-&gt;type = sAICallback-&gt;UnitDef_getType(teamId, unitDefId);
-unitDef-&gt;tooltip = sAICallback-&gt;UnitDef_getTooltip(teamId, unitDefId);
-unitDef-&gt;wreckName = sAICallback-&gt;UnitDef_getWreckName(teamId, unitDefId);
-unitDef-&gt;deathExplosion = sAICallback-&gt;UnitDef_getDeathExplosion(teamId, unitDefId);
-unitDef-&gt;selfDExplosion = sAICallback-&gt;UnitDef_getSelfDExplosion(teamId, unitDefId);
-unitDef-&gt;TEDClassString = sAICallback-&gt;UnitDef_getTedClassString(teamId, unitDefId);
-unitDef-&gt;categoryString = sAICallback-&gt;UnitDef_getCategoryString(teamId, unitDefId);
-unitDef-&gt;canSelfD = sAICallback-&gt;UnitDef_isCanSelfD(teamId, unitDefId);
-unitDef-&gt;selfDCountdown = sAICallback-&gt;UnitDef_getSelfDCountdown(teamId, unitDefId);
-unitDef-&gt;canSubmerge = sAICallback-&gt;UnitDef_isCanSubmerge(teamId, unitDefId);
-unitDef-&gt;canfly = sAICallback-&gt;UnitDef_isCanFly(teamId, unitDefId);
-unitDef-&gt;canmove = sAICallback-&gt;UnitDef_isCanMove(teamId, unitDefId);
-unitDef-&gt;canhover = sAICallback-&gt;UnitDef_isCanHover(teamId, unitDefId);
-unitDef-&gt;floater = sAICallback-&gt;UnitDef_isFloater(teamId, unitDefId);
-unitDef-&gt;builder = sAICallback-&gt;UnitDef_isBuilder(teamId, unitDefId);
-unitDef-&gt;activateWhenBuilt = sAICallback-&gt;UnitDef_isActivateWhenBuilt(teamId, unitDefId);
-unitDef-&gt;onoffable = sAICallback-&gt;UnitDef_isOnOffable(teamId, unitDefId);
-unitDef-&gt;fullHealthFactory = sAICallback-&gt;UnitDef_isFullHealthFactory(teamId, unitDefId);
-unitDef-&gt;factoryHeadingTakeoff = sAICallback-&gt;UnitDef_isFactoryHeadingTakeoff(teamId, unitDefId);
-unitDef-&gt;reclaimable = sAICallback-&gt;UnitDef_isReclaimable(teamId, unitDefId);
-unitDef-&gt;capturable = sAICallback-&gt;UnitDef_isCapturable(teamId, unitDefId);
-unitDef-&gt;canRestore = sAICallback-&gt;UnitDef_isCanRestore(teamId, unitDefId);
-unitDef-&gt;canRepair = sAICallback-&gt;UnitDef_isCanRepair(teamId, unitDefId);
-unitDef-&gt;canSelfRepair = sAICallback-&gt;UnitDef_isCanSelfRepair(teamId, unitDefId);
-unitDef-&gt;canReclaim = sAICallback-&gt;UnitDef_isCanReclaim(teamId, unitDefId);
-unitDef-&gt;canAttack = sAICallback-&gt;UnitDef_isCanAttack(teamId, unitDefId);
-unitDef-&gt;canPatrol = sAICallback-&gt;UnitDef_isCanPatrol(teamId, unitDefId);
-unitDef-&gt;canFight = sAICallback-&gt;UnitDef_isCanFight(teamId, unitDefId);
-unitDef-&gt;canGuard = sAICallback-&gt;UnitDef_isCanGuard(teamId, unitDefId);
-unitDef-&gt;canBuild = sAICallback-&gt;UnitDef_isCanBuild(teamId, unitDefId);
-unitDef-&gt;canAssist = sAICallback-&gt;UnitDef_isCanAssist(teamId, unitDefId);
-unitDef-&gt;canBeAssisted = sAICallback-&gt;UnitDef_isCanBeAssisted(teamId, unitDefId);
-unitDef-&gt;canRepeat = sAICallback-&gt;UnitDef_isCanRepeat(teamId, unitDefId);
-unitDef-&gt;canFireControl = sAICallback-&gt;UnitDef_isCanFireControl(teamId, unitDefId);
-unitDef-&gt;fireState = sAICallback-&gt;UnitDef_getFireState(teamId, unitDefId);
-unitDef-&gt;moveState = sAICallback-&gt;UnitDef_getMoveState(teamId, unitDefId);
-unitDef-&gt;wingDrag = sAICallback-&gt;UnitDef_getWingDrag(teamId, unitDefId);
-unitDef-&gt;wingAngle = sAICallback-&gt;UnitDef_getWingAngle(teamId, unitDefId);
-unitDef-&gt;drag = sAICallback-&gt;UnitDef_getDrag(teamId, unitDefId);
-unitDef-&gt;frontToSpeed = sAICallback-&gt;UnitDef_getFrontToSpeed(teamId, unitDefId);
-unitDef-&gt;speedToFront = sAICallback-&gt;UnitDef_getSpeedToFront(teamId, unitDefId);
-unitDef-&gt;myGravity = sAICallback-&gt;UnitDef_getMyGravity(teamId, unitDefId);
-unitDef-&gt;maxBank = sAICallback-&gt;UnitDef_getMaxBank(teamId, unitDefId);
-unitDef-&gt;maxPitch = sAICallback-&gt;UnitDef_getMaxPitch(teamId, unitDefId);
-unitDef-&gt;turnRadius = sAICallback-&gt;UnitDef_getTurnRadius(teamId, unitDefId);
-unitDef-&gt;wantedHeight = sAICallback-&gt;UnitDef_getWantedHeight(teamId, unitDefId);
-unitDef-&gt;verticalSpeed = sAICallback-&gt;UnitDef_getVerticalSpeed(teamId, unitDefId);
-unitDef-&gt;canCrash = sAICallback-&gt;UnitDef_isCanCrash(teamId, unitDefId);
-unitDef-&gt;hoverAttack = sAICallback-&gt;UnitDef_isHoverAttack(teamId, unitDefId);
-unitDef-&gt;airStrafe = sAICallback-&gt;UnitDef_isAirStrafe(teamId, unitDefId);
-unitDef-&gt;dlHoverFactor = sAICallback-&gt;UnitDef_getDlHoverFactor(teamId, unitDefId);
-unitDef-&gt;maxAcc = sAICallback-&gt;UnitDef_getMaxAcceleration(teamId, unitDefId);
-unitDef-&gt;maxDec = sAICallback-&gt;UnitDef_getMaxDeceleration(teamId, unitDefId);
-unitDef-&gt;maxAileron = sAICallback-&gt;UnitDef_getMaxAileron(teamId, unitDefId);
-unitDef-&gt;maxElevator = sAICallback-&gt;UnitDef_getMaxElevator(teamId, unitDefId);
-unitDef-&gt;maxRudder = sAICallback-&gt;UnitDef_getMaxRudder(teamId, unitDefId);
-//unitDef-&gt;yardmaps = sAICallback-&gt;UnitDef_getYardMaps(teamId, unitDefId);
-unitDef-&gt;xsize = sAICallback-&gt;UnitDef_getXSize(teamId, unitDefId);
-unitDef-&gt;ysize = sAICallback-&gt;UnitDef_getYSize(teamId, unitDefId);
-unitDef-&gt;buildangle = sAICallback-&gt;UnitDef_getBuildAngle(teamId, unitDefId);
-unitDef-&gt;loadingRadius = sAICallback-&gt;UnitDef_getLoadingRadius(teamId, unitDefId);
-unitDef-&gt;unloadSpread = sAICallback-&gt;UnitDef_getUnloadSpread(teamId, unitDefId);
-unitDef-&gt;transportCapacity = sAICallback-&gt;UnitDef_getTransportCapacity(teamId, unitDefId);
-unitDef-&gt;transportSize = sAICallback-&gt;UnitDef_getTransportSize(teamId, unitDefId);
-unitDef-&gt;minTransportSize = sAICallback-&gt;UnitDef_getMinTransportSize(teamId, unitDefId);
-unitDef-&gt;isAirBase = sAICallback-&gt;UnitDef_isAirBase(teamId, unitDefId);
-unitDef-&gt;transportMass = sAICallback-&gt;UnitDef_getTransportMass(teamId, unitDefId);
-unitDef-&gt;minTransportMass = sAICallback-&gt;UnitDef_getMinTransportMass(teamId, unitDefId);
-unitDef-&gt;holdSteady = sAICallback-&gt;UnitDef_isHoldSteady(teamId, unitDefId);
-unitDef-&gt;releaseHeld = sAICallback-&gt;UnitDef_isReleaseHeld(teamId, unitDefId);
-unitDef-&gt;cantBeTransported = sAICallback-&gt;UnitDef_isCantBeTransported(teamId, unitDefId);
-unitDef-&gt;transportByEnemy = sAICallback-&gt;UnitDef_isTransportByEnemy(teamId, unitDefId);
-unitDef-&gt;transportUnloadMethod = sAICallback-&gt;UnitDef_getTransportUnloadMethod(teamId, unitDefId);
-unitDef-&gt;fallSpeed = sAICallback-&gt;UnitDef_getFallSpeed(teamId, unitDefId);
-unitDef-&gt;unitFallSpeed = sAICallback-&gt;UnitDef_getUnitFallSpeed(teamId, unitDefId);
-unitDef-&gt;canCloak = sAICallback-&gt;UnitDef_isCanCloak(teamId, unitDefId);
-unitDef-&gt;startCloaked = sAICallback-&gt;UnitDef_isStartCloaked(teamId, unitDefId);
-unitDef-&gt;cloakCost = sAICallback-&gt;UnitDef_getCloakCost(teamId, unitDefId);
-unitDef-&gt;cloakCostMoving = sAICallback-&gt;UnitDef_getCloakCostMoving(teamId, unitDefId);
-unitDef-&gt;decloakDistance = sAICallback-&gt;UnitDef_getDecloakDistance(teamId, unitDefId);
-unitDef-&gt;decloakSpherical = sAICallback-&gt;UnitDef_isDecloakSpherical(teamId, unitDefId);
-unitDef-&gt;decloakOnFire = sAICallback-&gt;UnitDef_isDecloakOnFire(teamId, unitDefId);
-unitDef-&gt;canKamikaze = sAICallback-&gt;UnitDef_isCanKamikaze(teamId, unitDefId);
-unitDef-&gt;kamikazeDist = sAICallback-&gt;UnitDef_getKamikazeDist(teamId, unitDefId);
-unitDef-&gt;targfac = sAICallback-&gt;UnitDef_isTargetingFacility(teamId, unitDefId);
-unitDef-&gt;canDGun = sAICallback-&gt;UnitDef_isCanDGun(teamId, unitDefId);
-unitDef-&gt;needGeo = sAICallback-&gt;UnitDef_isNeedGeo(teamId, unitDefId);
-unitDef-&gt;isFeature = sAICallback-&gt;UnitDef_isFeature(teamId, unitDefId);
-unitDef-&gt;hideDamage = sAICallback-&gt;UnitDef_isHideDamage(teamId, unitDefId);
-unitDef-&gt;isCommander = sAICallback-&gt;UnitDef_isCommander(teamId, unitDefId);
-unitDef-&gt;showPlayerName = sAICallback-&gt;UnitDef_isShowPlayerName(teamId, unitDefId);
-unitDef-&gt;canResurrect = sAICallback-&gt;UnitDef_isCanResurrect(teamId, unitDefId);
-unitDef-&gt;canCapture = sAICallback-&gt;UnitDef_isCanCapture(teamId, unitDefId);
-unitDef-&gt;highTrajectoryType = sAICallback-&gt;UnitDef_getHighTrajectoryType(teamId, unitDefId);
-unitDef-&gt;noChaseCategory = sAICallback-&gt;UnitDef_getNoChaseCategory(teamId, unitDefId);
-unitDef-&gt;leaveTracks = sAICallback-&gt;UnitDef_isLeaveTracks(teamId, unitDefId);
-unitDef-&gt;trackWidth = sAICallback-&gt;UnitDef_getTrackWidth(teamId, unitDefId);
-unitDef-&gt;trackOffset = sAICallback-&gt;UnitDef_getTrackOffset(teamId, unitDefId);
-unitDef-&gt;trackStrength = sAICallback-&gt;UnitDef_getTrackStrength(teamId, unitDefId);
-unitDef-&gt;trackStretch = sAICallback-&gt;UnitDef_getTrackStretch(teamId, unitDefId);
-unitDef-&gt;trackType = sAICallback-&gt;UnitDef_getTrackType(teamId, unitDefId);
-unitDef-&gt;canDropFlare = sAICallback-&gt;UnitDef_isCanDropFlare(teamId, unitDefId);
-unitDef-&gt;flareReloadTime = sAICallback-&gt;UnitDef_getFlareReloadTime(teamId, unitDefId);
-unitDef-&gt;flareEfficiency = sAICallback-&gt;UnitDef_getFlareEfficiency(teamId, unitDefId);
-unitDef-&gt;flareDelay = sAICallback-&gt;UnitDef_getFlareDelay(teamId, unitDefId);
-unitDef-&gt;flareDropVector = float3(sAICallback-&gt;UnitDef_getFlareDropVector(teamId, unitDefId));
-unitDef-&gt;flareTime = sAICallback-&gt;UnitDef_getFlareTime(teamId, unitDefId);
-unitDef-&gt;flareSalvoSize = sAICallback-&gt;UnitDef_getFlareSalvoSize(teamId, unitDefId);
-unitDef-&gt;flareSalvoDelay = sAICallback-&gt;UnitDef_getFlareSalvoDelay(teamId, unitDefId);
-unitDef-&gt;smoothAnim = sAICallback-&gt;UnitDef_isSmoothAnim(teamId, unitDefId);
-unitDef-&gt;isMetalMaker = sAICallback-&gt;UnitDef_isMetalMaker(teamId, unitDefId);
-unitDef-&gt;canLoopbackAttack = sAICallback-&gt;UnitDef_isCanLoopbackAttack(teamId, unitDefId);
-unitDef-&gt;levelGround = sAICallback-&gt;UnitDef_isLevelGround(teamId, unitDefId);
-unitDef-&gt;useBuildingGroundDecal = sAICallback-&gt;UnitDef_isUseBuildingGroundDecal(teamId, unitDefId);
-unitDef-&gt;buildingDecalType = sAICallback-&gt;UnitDef_getBuildingDecalType(teamId, unitDefId);
-unitDef-&gt;buildingDecalSizeX = sAICallback-&gt;UnitDef_getBuildingDecalSizeX(teamId, unitDefId);
-unitDef-&gt;buildingDecalSizeY = sAICallback-&gt;UnitDef_getBuildingDecalSizeY(teamId, unitDefId);
-unitDef-&gt;buildingDecalDecaySpeed = sAICallback-&gt;UnitDef_getBuildingDecalDecaySpeed(teamId, unitDefId);
-unitDef-&gt;isFirePlatform = sAICallback-&gt;UnitDef_isFirePlatform(teamId, unitDefId);
-unitDef-&gt;maxFuel = sAICallback-&gt;UnitDef_getMaxFuel(teamId, unitDefId);
-unitDef-&gt;refuelTime = sAICallback-&gt;UnitDef_getRefuelTime(teamId, unitDefId);
-unitDef-&gt;minAirBasePower = sAICallback-&gt;UnitDef_getMinAirBasePower(teamId, unitDefId);
-unitDef-&gt;maxThisUnit = sAICallback-&gt;UnitDef_getMaxThisUnit(teamId, unitDefId);
-//unitDef-&gt;decoyDef = sAICallback-&gt;UnitDef_getDecoyDefId(teamId, unitDefId);
-unitDef-&gt;shieldWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getShieldWeaponDefId(teamId, unitDefId));
-unitDef-&gt;stockpileWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getStockpileWeaponDefId(teamId, unitDefId));
-{
-	int numBo = sAICallback-&gt;UnitDef_getNumBuildOptions(teamId, unitDefId);
-	int* bo = new int[numBo];
-	sAICallback-&gt;UnitDef_getBuildOptions(teamId, unitDefId, bo);
-	for (int b=0; b &lt; numBo; b++) {
-		unitDef-&gt;buildOptions[b] = sAICallback-&gt;UnitDef_getName(teamId, bo[b]);
-	}
-	delete [] bo;
-}
-{
-	int size = sAICallback-&gt;UnitDef_getNumCustomParams(teamId, unitDefId);
-	const char* cKeys[size];
-	const char* cValues[size];
-	sAICallback-&gt;UnitDef_getCustomParamKeys(teamId, unitDefId, cKeys);
-	sAICallback-&gt;UnitDef_getCustomParamValues(teamId, unitDefId, cValues);
-	int i;
-	for (i=0; i &lt; size; ++i) {
-		unitDef-&gt;customParams[cKeys[i]] = cValues[i];
-	}
-}
-if (sAICallback-&gt;UnitDef_hasMoveData(teamId, unitDefId)) {
-	unitDef-&gt;movedata = new MoveData(NULL, -1);
-		unitDef-&gt;movedata-&gt;moveType = (enum MoveData::MoveType)sAICallback-&gt;UnitDef_MoveData_getMoveType(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;moveFamily = (enum MoveData::MoveFamily) sAICallback-&gt;UnitDef_MoveData_getMoveFamily(teamId, unitDefId);
-        unitDef-&gt;movedata-&gt;size = sAICallback-&gt;UnitDef_MoveData_getSize(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;depth = sAICallback-&gt;UnitDef_MoveData_getDepth(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;maxSlope = sAICallback-&gt;UnitDef_MoveData_getMaxSlope(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;slopeMod = sAICallback-&gt;UnitDef_MoveData_getSlopeMod(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;depthMod = sAICallback-&gt;UnitDef_MoveData_getDepthMod(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;pathType = sAICallback-&gt;UnitDef_MoveData_getPathType(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;crushStrength = sAICallback-&gt;UnitDef_MoveData_getCrushStrength(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;maxSpeed = sAICallback-&gt;UnitDef_MoveData_getMaxSpeed(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;maxTurnRate = sAICallback-&gt;UnitDef_MoveData_getMaxTurnRate(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;maxAcceleration = sAICallback-&gt;UnitDef_MoveData_getMaxAcceleration(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;maxBreaking = sAICallback-&gt;UnitDef_MoveData_getMaxBreaking(teamId, unitDefId);
-		unitDef-&gt;movedata-&gt;subMarine = sAICallback-&gt;UnitDef_MoveData_isSubMarine(teamId, unitDefId);
-	} else {
-		unitDef-&gt;movedata = NULL;
-	}
-int numWeapons = sAICallback-&gt;UnitDef_getNumUnitDefWeapons(teamId, unitDefId);
-for (int w=0; w &lt; numWeapons; ++w) {
-	unitDef-&gt;weapons.push_back(UnitDef::UnitDefWeapon());
-	unitDef-&gt;weapons[w].name = sAICallback-&gt;UnitDef_UnitDefWeapon_getName(teamId, unitDefId, w);
-	int weaponDefId = sAICallback-&gt;UnitDef_UnitDefWeapon_getWeaponDefId(teamId, unitDefId, w);
-	unitDef-&gt;weapons[w].def = this-&gt;GetWeaponDefById(weaponDefId);
-	unitDef-&gt;weapons[w].slavedTo = sAICallback-&gt;UnitDef_UnitDefWeapon_getSlavedTo(teamId, unitDefId, w);
-	unitDef-&gt;weapons[w].mainDir = float3(sAICallback-&gt;UnitDef_UnitDefWeapon_getMainDir(teamId, unitDefId, w));
-	unitDef-&gt;weapons[w].maxAngleDif = sAICallback-&gt;UnitDef_UnitDefWeapon_getMaxAngleDif(teamId, unitDefId, w);
-	unitDef-&gt;weapons[w].fuelUsage = sAICallback-&gt;UnitDef_UnitDefWeapon_getFuelUsage(teamId, unitDefId, w);
-	unitDef-&gt;weapons[w].badTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getBadTargetCat(teamId, unitDefId, w);
-	unitDef-&gt;weapons[w].onlyTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getOnlyTargetCat(teamId, unitDefId, w);
-}
-	if (unitDefs[unitDefId] != NULL) {
-		delete unitDefs[unitDefId];
-	}
-		unitDefs[unitDefId] = unitDef;
-		unitDefFrames[unitDefId] = currentFrame;
-	}
-
-	return unitDefs[unitDefId];
-}
-
-int CAIAICallback::GetEnemyUnits(int* unitIds) {
-	return sAICallback-&gt;Unit_STATIC_getEnemies(teamId, unitIds);
-}
-
-int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
-	return sAICallback-&gt;Unit_STATIC_getEnemiesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
-}
-
-int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
-	return sAICallback-&gt;Unit_STATIC_getEnemiesInRadarAndLos(teamId, unitIds);
-}
-
-int CAIAICallback::GetFriendlyUnits(int* unitIds) {
-	return sAICallback-&gt;Unit_STATIC_getFriendlies(teamId, unitIds);
-}
-
-int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
-	return sAICallback-&gt;Unit_STATIC_getFriendliesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
-}
-
-int CAIAICallback::GetNeutralUnits(int* unitIds) {
-	return sAICallback-&gt;Unit_STATIC_getNeutrals(teamId, unitIds);
-}
-
-int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
-	return sAICallback-&gt;Unit_STATIC_getNeutralsIn(teamId, unitIds, pos.toSAIFloat3(), radius);
-}
-
-int CAIAICallback::GetMapWidth() {
-	return sAICallback-&gt;Map_getWidth(teamId);
-}
-
-int CAIAICallback::GetMapHeight() {
-	return sAICallback-&gt;Map_getHeight(teamId);
-}
-
-const float* CAIAICallback::GetHeightMap() {
-	return sAICallback-&gt;Map_getHeightMap(teamId);
-}
-
-float CAIAICallback::GetMinHeight() {
-	return sAICallback-&gt;Map_getMinHeight(teamId);
-}
-
-float CAIAICallback::GetMaxHeight() {
-	return sAICallback-&gt;Map_getMaxHeight(teamId);
-}
-
-const float* CAIAICallback::GetSlopeMap() {
-	return sAICallback-&gt;Map_getSlopeMap(teamId);
-}
-
-const unsigned short* CAIAICallback::GetLosMap() {
-	return sAICallback-&gt;Map_getLosMap(teamId);
-}
-
-const unsigned short* CAIAICallback::GetRadarMap() {
-	return sAICallback-&gt;Map_getRadarMap(teamId);
-}
-
-const unsigned short* CAIAICallback::GetJammerMap() {
-	return sAICallback-&gt;Map_getJammerMap(teamId);
-}
-
-const unsigned char* CAIAICallback::GetMetalMap() {
-	return sAICallback-&gt;Map_getMetalMap(teamId);
-}
-
-const char* CAIAICallback::GetMapName() {
-	return sAICallback-&gt;Map_getName(teamId);
-}
-
-const char* CAIAICallback::GetModName() {
-	return sAICallback-&gt;Mod_getName(teamId);
-}
-
-float CAIAICallback::GetElevation(float x, float z) {
-	return sAICallback-&gt;Map_getElevationAt(teamId, x, z);
-}
-
-float CAIAICallback::GetMaxMetal() {
-	return sAICallback-&gt;Map_getMaxMetal(teamId);
-}
-
-float CAIAICallback::GetExtractorRadius() {
-	return sAICallback-&gt;Map_getExtractorRadius(teamId);
-}
-
-float CAIAICallback::GetMinWind() {
-	return sAICallback-&gt;Map_getMinWind(teamId);
-}
-
-float CAIAICallback::GetMaxWind() {
-	return sAICallback-&gt;Map_getMaxWind(teamId);
-}
-
-float CAIAICallback::GetTidalStrength() {
-	return sAICallback-&gt;Map_getTidalStrength(teamId);
-}
-
-float CAIAICallback::GetGravity() {
-	return sAICallback-&gt;Map_getGravity(teamId);
-}
-
-bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
-	return sAICallback-&gt;Map_canBuildAt(teamId, unitDef-&gt;id, pos.toSAIFloat3(), facing);
-}
-
-float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
-	return float3(sAICallback-&gt;Map_findClosestBuildSite(teamId, unitDef-&gt;id, pos.toSAIFloat3(), searchRadius, minDist, facing));
-}
-
-/*
-bool CAIAICallback::GetProperty(int id, int property, void* dst) {
-//	return sAICallback-&gt;getProperty(teamId, id, property, dst);
-	return false;
-}
-*/
-bool CAIAICallback::GetProperty(int unitId, int propertyId, void *data)
-{
-    switch (propertyId) {
-        case AIVAL_UNITDEF: {
-            return false;
-        }
-        case AIVAL_CURRENT_FUEL: {
-            (*(float*)data) = sAICallback-&gt;Unit_getCurrentFuel(teamId, unitId);
-            return (*(float*)data) != -1.0f;
-        }
-        case AIVAL_STOCKPILED: {
-            (*(int*)data) = sAICallback-&gt;Unit_getStockpile(teamId, unitId);
-            return (*(int*)data) != -1;
-        }
-        case AIVAL_STOCKPILE_QUED: {
-            (*(int*)data) = sAICallback-&gt;Unit_getStockpileQueued(teamId, unitId);
-            return (*(int*)data) != -1;
-        }
-        case AIVAL_UNIT_MAXSPEED: {
-            (*(float*) data) = sAICallback-&gt;Unit_getMaxSpeed(teamId, unitId);
-            return (*(float*)data) != -1.0f;
-        }
-        default:
-            return false;
-	}
-	return false;
-}
-
-/*
-bool CAIAICallback::GetValue(int valueId, void* dst) {
-//	return sAICallback-&gt;getValue(teamId, valueId, dst);
-	return false;
-}
-*/
-bool CAIAICallback::GetValue(int valueId, void *data)
-{
-	switch (valueId) {
-		case AIVAL_NUMDAMAGETYPES:{
-			*((int*)data) = sAICallback-&gt;WeaponDef_STATIC_getNumDamageTypes(teamId);
-			return true;
-		}case AIVAL_EXCEPTION_HANDLING:{
-			*(bool*)data = sAICallback-&gt;Game_isExceptionHandlingEnabled(teamId);
-			return true;
-		}case AIVAL_MAP_CHECKSUM:{
-			*(unsigned int*)data = sAICallback-&gt;Map_getChecksum(teamId);
-			return true;
-		}case AIVAL_DEBUG_MODE:{
-			*(bool*)data = sAICallback-&gt;Game_isDebugModeEnabled(teamId);
-			return true;
-		}case AIVAL_GAME_MODE:{
-			*(int*)data = sAICallback-&gt;Game_getMode(teamId);
-			return true;
-		}case AIVAL_GAME_PAUSED:{
-			*(bool*)data = sAICallback-&gt;Game_isPaused(teamId);
-			return true;
-		}case AIVAL_GAME_SPEED_FACTOR:{
-			*(float*)data = sAICallback-&gt;Game_getSpeedFactor(teamId);
-			return true;
-		}case AIVAL_GUI_VIEW_RANGE:{
-			*(float*)data = sAICallback-&gt;Gui_getViewRange(teamId);
-			return true;
-		}case AIVAL_GUI_SCREENX:{
-			*(float*)data = sAICallback-&gt;Gui_getScreenX(teamId);
-			return true;
-		}case AIVAL_GUI_SCREENY:{
-			*(float*)data = sAICallback-&gt;Gui_getScreenY(teamId);
-			return true;
-		}case AIVAL_GUI_CAMERA_DIR:{
-			*(float3*)data = sAICallback-&gt;Gui_Camera_getDirection(teamId);
-			return true;
-		}case AIVAL_GUI_CAMERA_POS:{
-			*(float3*)data = sAICallback-&gt;Gui_Camera_getPosition(teamId);
-			return true;
-		}case AIVAL_LOCATE_FILE_R:{
-            sAICallback-&gt;File_locateForReading(teamId, (char*) data);
-			return true;
-		}case AIVAL_LOCATE_FILE_W:{
-            sAICallback-&gt;File_locateForWriting(teamId, (char*) data);
-			return true;
-		}
-		case AIVAL_UNIT_LIMIT: {
-			*(int*) data = sAICallback-&gt;Unit_STATIC_getLimit(teamId);
-			return true;
-		}
-		case AIVAL_SCRIPT: {
-			*(const char**) data = sAICallback-&gt;Game_getSetupScript(teamId);
-			return true;
-		}
-		default:
-			return false;
-	}
-}
-
-int CAIAICallback::GetFileSize(const char* name) {
-	return sAICallback-&gt;File_getSize(teamId, name);
-}
-
-int CAIAICallback::GetSelectedUnits(int* unitIds) {
-	return sAICallback-&gt;Unit_STATIC_getSelected(teamId, unitIds);
-}
-
-float3 CAIAICallback::GetMousePos() {
-	return float3(sAICallback-&gt;Map_getMousePos(teamId));
-}
-
-int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
-	
-	SAIFloat3* positions = new SAIFloat3[maxPoints];
-//	unsigned char** colors = new unsigned char*[maxPoints];
-	SAIFloat3* colors = new SAIFloat3[maxPoints];
-	const char** labels = new const char*[maxPoints];
-	
-	int numPoints = sAICallback-&gt;Map_getPoints(teamId, positions, colors, labels, maxPoints);
-	for (int i=0; i &lt; numPoints; ++i) {
-		pm[i].pos = float3(positions[i]);
-		//pm[i].color = colors[i];
-		pm[i].color = (unsigned char*) calloc(3, sizeof(unsigned char));
-		pm[i].color[0] = (unsigned char) colors[i].x;
-		pm[i].color[1] = (unsigned char) colors[i].y;
-		pm[i].color[2] = (unsigned char) colors[i].z;
-		pm[i].label = labels[i];
-	}
-	delete [] positions;
-	delete [] colors;
-	delete [] labels;
-	return numPoints;
-}
-
-int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
-	
-	SAIFloat3* firstPositions = new SAIFloat3[maxLines];
-	SAIFloat3* secondPositions = new SAIFloat3[maxLines];
-	SAIFloat3* colors = new SAIFloat3[maxLines];
-	
-	int numLines = sAICallback-&gt;Map_getLines(teamId, firstPositions, secondPositions, colors, maxLines);
-	for (int i=0; i &lt; numLines; ++i) {
-		lm[i].pos = float3(firstPositions[i]);
-		lm[i].pos2 = float3(secondPositions[i]);
-		lm[i].color = (unsigned char*) calloc(3, sizeof(unsigned char));
-		lm[i].color[0] = (unsigned char) colors[i].x;
-		lm[i].color[1] = (unsigned char) colors[i].y;
-		lm[i].color[2] = (unsigned char) colors[i].z;
-	}
-	delete [] firstPositions;
-	delete [] secondPositions;
-	delete [] colors;
-	return numLines;
-}
-
-float CAIAICallback::GetMetal() {
-	return sAICallback-&gt;ResourceInfo_Metal_getCurrent(teamId);
-}
-
-float CAIAICallback::GetMetalIncome() {
-	return sAICallback-&gt;ResourceInfo_Metal_getIncome(teamId);
-}
-
-float CAIAICallback::GetMetalUsage() {
-	return sAICallback-&gt;ResourceInfo_Metal_getUsage(teamId);
-}
-
-float CAIAICallback::GetMetalStorage() {
-	return sAICallback-&gt;ResourceInfo_Metal_getStorage(teamId);
-}
-
-float CAIAICallback::GetEnergy() {
-	return sAICallback-&gt;ResourceInfo_Energy_getCurrent(teamId);
-}
-
-float CAIAICallback::GetEnergyIncome() {
-	return sAICallback-&gt;ResourceInfo_Energy_getIncome(teamId);
-}
-
-float CAIAICallback::GetEnergyUsage() {
-	return sAICallback-&gt;ResourceInfo_Energy_getUsage(teamId);
-}
-
-float CAIAICallback::GetEnergyStorage() {
-	return sAICallback-&gt;ResourceInfo_Energy_getStorage(teamId);
-}
-
-int CAIAICallback::GetFeatures(int *featureIds, int max) {
-	return sAICallback-&gt;Feature_STATIC_getIds(teamId, featureIds, max);
-}
-
-int CAIAICallback::GetFeatures(int *featureIds, int max, const float3&amp; pos, float radius) {
-	return sAICallback-&gt;Feature_STATIC_getIdsIn(teamId, featureIds, max, pos.toSAIFloat3(), radius);
-}
-
-const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
-	int featureDefId = sAICallback-&gt;Feature_getDefId(teamId, featureId);
-	return this-&gt;GetFeatureDefById(featureDefId);
-}
-
-const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
-	
-	if (featureDefId &lt; 0) {
-		return NULL;
-	}
-	
-	bool doRecreate = featureDefFrames[featureDefId] &lt; 0;
-	if (doRecreate) {
-//		int currentFrame = this-&gt;GetCurrentFrame();
-		int currentFrame = 1;
-	FeatureDef* featureDef = new FeatureDef();
-featureDef-&gt;myName = sAICallback-&gt;FeatureDef_getName(teamId, featureDefId);
-featureDef-&gt;description = sAICallback-&gt;FeatureDef_getDescription(teamId, featureDefId);
-featureDef-&gt;filename = sAICallback-&gt;FeatureDef_getFilename(teamId, featureDefId);
-featureDef-&gt;id = sAICallback-&gt;FeatureDef_getId(teamId, featureDefId);
-featureDef-&gt;metal = sAICallback-&gt;FeatureDef_getMetal(teamId, featureDefId);
-featureDef-&gt;energy = sAICallback-&gt;FeatureDef_getEnergy(teamId, featureDefId);
-featureDef-&gt;maxHealth = sAICallback-&gt;FeatureDef_getMaxHealth(teamId, featureDefId);
-featureDef-&gt;reclaimTime = sAICallback-&gt;FeatureDef_getReclaimTime(teamId, featureDefId);
-featureDef-&gt;mass = sAICallback-&gt;FeatureDef_getMass(teamId, featureDefId);
-featureDef-&gt;collisionVolumeType = sAICallback-&gt;FeatureDef_getCollisionVolumeType(teamId, featureDefId);	
-featureDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeScales(teamId, featureDefId));		
-featureDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeOffsets(teamId, featureDefId));		
-featureDef-&gt;collisionVolumeTest = sAICallback-&gt;FeatureDef_getCollisionVolumeTest(teamId, featureDefId);			
-featureDef-&gt;upright = sAICallback-&gt;FeatureDef_isUpright(teamId, featureDefId);
-featureDef-&gt;drawType = sAICallback-&gt;FeatureDef_getDrawType(teamId, featureDefId);
-featureDef-&gt;modelname = sAICallback-&gt;FeatureDef_getModelName(teamId, featureDefId);
-featureDef-&gt;modelType = sAICallback-&gt;FeatureDef_getModelType(teamId, featureDefId);
-featureDef-&gt;resurrectable = sAICallback-&gt;FeatureDef_getResurrectable(teamId, featureDefId);
-featureDef-&gt;smokeTime = sAICallback-&gt;FeatureDef_getSmokeTime(teamId, featureDefId);
-featureDef-&gt;destructable = sAICallback-&gt;FeatureDef_isDestructable(teamId, featureDefId);
-featureDef-&gt;reclaimable = sAICallback-&gt;FeatureDef_isReclaimable(teamId, featureDefId);
-featureDef-&gt;blocking = sAICallback-&gt;FeatureDef_isBlocking(teamId, featureDefId);
-featureDef-&gt;burnable = sAICallback-&gt;FeatureDef_isBurnable(teamId, featureDefId);
-featureDef-&gt;floating = sAICallback-&gt;FeatureDef_isFloating(teamId, featureDefId);
-featureDef-&gt;noSelect = sAICallback-&gt;FeatureDef_isNoSelect(teamId, featureDefId);
-featureDef-&gt;geoThermal = sAICallback-&gt;FeatureDef_isGeoThermal(teamId, featureDefId);
-featureDef-&gt;deathFeature = sAICallback-&gt;FeatureDef_getDeathFeature(teamId, featureDefId);
-featureDef-&gt;xsize = sAICallback-&gt;FeatureDef_getXsize(teamId, featureDefId);
-featureDef-&gt;ysize = sAICallback-&gt;FeatureDef_getYsize(teamId, featureDefId);
-{
-	int size = sAICallback-&gt;FeatureDef_getNumCustomParams(teamId, featureDefId);
-	featureDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
-	const char* cKeys[size];
-	const char* cValues[size];
-	sAICallback-&gt;FeatureDef_getCustomParamKeys(teamId, featureDefId, cKeys);
-	sAICallback-&gt;FeatureDef_getCustomParamValues(teamId, featureDefId, cValues);
-	int i;
-	for (i=0; i &lt; size; ++i) {
-		featureDef-&gt;customParams[cKeys[i]] = cValues[i];
-	}
-}
-	if (featureDefs[featureDefId] != NULL) {
-		delete featureDefs[featureDefId];
-	}
-		featureDefs[featureDefId] = featureDef;
-		featureDefFrames[featureDefId] = currentFrame;
-	}
-
-	return featureDefs[featureDefId];
-}
-
-float CAIAICallback::GetFeatureHealth(int featureId) {
-	return sAICallback-&gt;Feature_getHealth(teamId, featureId);
-}
-
-float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
-	return sAICallback-&gt;Feature_getReclaimLeft(teamId, featureId);
-}
-
-float3 CAIAICallback::GetFeaturePos(int featureId) {
-	return float3(sAICallback-&gt;Feature_getPos(teamId, featureId));
-}
-
-int CAIAICallback::GetNumUnitDefs() {
-	return sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
-}
-
-void CAIAICallback::GetUnitDefList(const UnitDef** list) {
-	int numUnitDefs = sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
-	int* unitDefIds = new int[numUnitDefs];
-	sAICallback-&gt;UnitDef_STATIC_getIds(teamId, unitDefIds);
-	for (int i=0; i &lt; numUnitDefs; ++i) {
-		list[i] = this-&gt;GetUnitDefById(unitDefIds[i]);
-	}
-}
-
-float CAIAICallback::GetUnitDefHeight(int def) {
-	return sAICallback-&gt;UnitDef_getHeight(teamId, def);
-}
-
-float CAIAICallback::GetUnitDefRadius(int def) {
-	return sAICallback-&gt;UnitDef_getRadius(teamId, def);
-}
-
-const WeaponDef* CAIAICallback::GetWeapon(const char* weaponName) {
-	int weaponDefId = sAICallback-&gt;WeaponDef_STATIC_getIdByName(teamId, weaponName);
-	return this-&gt;GetWeaponDefById(weaponDefId);
-}
-
-const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
-	
-//	logT(&quot;entering: GetWeaponDefById sAICallback&quot;);
-	if (weaponDefId &lt; 0) {
-		return NULL;
-	}
-	
-	bool doRecreate = weaponDefFrames[weaponDefId] &lt; 0;
-	if (doRecreate) {
-//		int currentFrame = this-&gt;GetCurrentFrame();
-		int currentFrame = 1;
-//weaponDef-&gt;damages = sAICallback-&gt;WeaponDef_getDamages(teamId, weaponDefId);
-//{
-int numTypes = sAICallback-&gt;WeaponDef_Damages_getNumTypes(teamId, weaponDefId);
-//	logT(&quot;GetWeaponDefById 1&quot;);
-//float* typeDamages = new float[numTypes];
-float typeDamages[numTypes];
-sAICallback-&gt;WeaponDef_Damages_getTypeDamages(teamId, weaponDefId, typeDamages);
-//	logT(&quot;GetWeaponDefById 2&quot;);
-//for(int i=0; i &lt; numTypes; ++i) {
-//	typeDamages[i] = sAICallback-&gt;WeaponDef_Damages_getType(teamId, weaponDefId, i);
-//}
-DamageArray da(numTypes, typeDamages);
-//	logT(&quot;GetWeaponDefById 3&quot;);
-//AIDamageArray tmpDa(numTypes, typeDamages);
-//AIDamageArray tmpDa;
-//weaponDef-&gt;damages = *(reinterpret_cast&lt;DamageArray*&gt;(&amp;tmpDa));
-//tmpDa.numTypes = numTypes;
-//tmpDa.damages = typeDamages;
-//delete tmpDa;
-//da.SetTypes(numTypes, typeDamages);
-//delete [] typeDamages;
-da.paralyzeDamageTime = sAICallback-&gt;WeaponDef_Damages_getParalyzeDamageTime(teamId, weaponDefId);
-da.impulseFactor = sAICallback-&gt;WeaponDef_Damages_getImpulseFactor(teamId, weaponDefId);
-da.impulseBoost = sAICallback-&gt;WeaponDef_Damages_getImpulseBoost(teamId, weaponDefId);
-da.craterMult = sAICallback-&gt;WeaponDef_Damages_getCraterMult(teamId, weaponDefId);
-da.craterBoost = sAICallback-&gt;WeaponDef_Damages_getCraterBoost(teamId, weaponDefId);
-//	logT(&quot;GetWeaponDefById 4&quot;);
-//}
-
-	WeaponDef* weaponDef = new WeaponDef(da);
-//	WeaponDef* weaponDef = new WeaponDef();
-//	logT(&quot;GetWeaponDefById 5&quot;);
-//	logI(&quot;GetWeaponDefById 5 defId: %d&quot;, weaponDefId);
-weaponDef-&gt;name = sAICallback-&gt;WeaponDef_getName(teamId, weaponDefId);
-weaponDef-&gt;type = sAICallback-&gt;WeaponDef_getType(teamId, weaponDefId);
-weaponDef-&gt;description = sAICallback-&gt;WeaponDef_getDescription(teamId, weaponDefId);
-weaponDef-&gt;filename = sAICallback-&gt;WeaponDef_getFilename(teamId, weaponDefId);
-weaponDef-&gt;cegTag = sAICallback-&gt;WeaponDef_getCegTag(teamId, weaponDefId);
-weaponDef-&gt;range = sAICallback-&gt;WeaponDef_getRange(teamId, weaponDefId);
-weaponDef-&gt;heightmod = sAICallback-&gt;WeaponDef_getHeightMod(teamId, weaponDefId);
-weaponDef-&gt;accuracy = sAICallback-&gt;WeaponDef_getAccuracy(teamId, weaponDefId);
-weaponDef-&gt;sprayAngle = sAICallback-&gt;WeaponDef_getSprayAngle(teamId, weaponDefId);
-weaponDef-&gt;movingAccuracy = sAICallback-&gt;WeaponDef_getMovingAccuracy(teamId, weaponDefId);
-weaponDef-&gt;targetMoveError = sAICallback-&gt;WeaponDef_getTargetMoveError(teamId, weaponDefId);
-weaponDef-&gt;leadLimit = sAICallback-&gt;WeaponDef_getLeadLimit(teamId, weaponDefId);
-weaponDef-&gt;leadBonus = sAICallback-&gt;WeaponDef_getLeadBonus(teamId, weaponDefId);
-weaponDef-&gt;predictBoost = sAICallback-&gt;WeaponDef_getPredictBoost(teamId, weaponDefId);
-weaponDef-&gt;areaOfEffect = sAICallback-&gt;WeaponDef_getAreaOfEffect(teamId, weaponDefId);
-weaponDef-&gt;noSelfDamage = sAICallback-&gt;WeaponDef_isNoSelfDamage(teamId, weaponDefId);
-weaponDef-&gt;fireStarter = sAICallback-&gt;WeaponDef_getFireStarter(teamId, weaponDefId);
-weaponDef-&gt;edgeEffectiveness = sAICallback-&gt;WeaponDef_getEdgeEffectiveness(teamId, weaponDefId);
-weaponDef-&gt;size = sAICallback-&gt;WeaponDef_getSize(teamId, weaponDefId);
-weaponDef-&gt;sizeGrowth = sAICallback-&gt;WeaponDef_getSizeGrowth(teamId, weaponDefId);
-weaponDef-&gt;collisionSize = sAICallback-&gt;WeaponDef_getCollisionSize(teamId, weaponDefId);
-weaponDef-&gt;salvosize = sAICallback-&gt;WeaponDef_getSalvoSize(teamId, weaponDefId);
-weaponDef-&gt;salvodelay = sAICallback-&gt;WeaponDef_getSalvoDelay(teamId, weaponDefId);
-weaponDef-&gt;reload = sAICallback-&gt;WeaponDef_getReload(teamId, weaponDefId);
-weaponDef-&gt;beamtime = sAICallback-&gt;WeaponDef_getBeamTime(teamId, weaponDefId);
-weaponDef-&gt;beamburst = sAICallback-&gt;WeaponDef_isBeamBurst(teamId, weaponDefId);
-weaponDef-&gt;waterBounce = sAICallback-&gt;WeaponDef_isWaterBounce(teamId, weaponDefId);
-weaponDef-&gt;groundBounce = sAICallback-&gt;WeaponDef_isGroundBounce(teamId, weaponDefId);
-weaponDef-&gt;bounceRebound = sAICallback-&gt;WeaponDef_getBounceRebound(teamId, weaponDefId);
-weaponDef-&gt;bounceSlip = sAICallback-&gt;WeaponDef_getBounceSlip(teamId, weaponDefId);
-weaponDef-&gt;numBounce = sAICallback-&gt;WeaponDef_getNumBounce(teamId, weaponDefId);
-weaponDef-&gt;maxAngle = sAICallback-&gt;WeaponDef_getMaxAngle(teamId, weaponDefId);
-weaponDef-&gt;restTime = sAICallback-&gt;WeaponDef_getRestTime(teamId, weaponDefId);
-weaponDef-&gt;uptime = sAICallback-&gt;WeaponDef_getUpTime(teamId, weaponDefId);
-weaponDef-&gt;flighttime = sAICallback-&gt;WeaponDef_getFlightTime(teamId, weaponDefId);
-weaponDef-&gt;metalcost = sAICallback-&gt;WeaponDef_getMetalCost(teamId, weaponDefId);
-weaponDef-&gt;energycost = sAICallback-&gt;WeaponDef_getEnergyCost(teamId, weaponDefId);
-weaponDef-&gt;supplycost = sAICallback-&gt;WeaponDef_getSupplyCost(teamId, weaponDefId);
-weaponDef-&gt;projectilespershot = sAICallback-&gt;WeaponDef_getProjectilesPerShot(teamId, weaponDefId);
-weaponDef-&gt;id = sAICallback-&gt;WeaponDef_getId(teamId, weaponDefId);
-weaponDef-&gt;tdfId = sAICallback-&gt;WeaponDef_getTdfId(teamId, weaponDefId);
-weaponDef-&gt;turret = sAICallback-&gt;WeaponDef_isTurret(teamId, weaponDefId);
-weaponDef-&gt;onlyForward = sAICallback-&gt;WeaponDef_isOnlyForward(teamId, weaponDefId);
-weaponDef-&gt;fixedLauncher = sAICallback-&gt;WeaponDef_isFixedLauncher(teamId, weaponDefId);
-weaponDef-&gt;waterweapon = sAICallback-&gt;WeaponDef_isWaterWeapon(teamId, weaponDefId);
-weaponDef-&gt;fireSubmersed = sAICallback-&gt;WeaponDef_isFireSubmersed(teamId, weaponDefId);
-weaponDef-&gt;submissile = sAICallback-&gt;WeaponDef_isSubMissile(teamId, weaponDefId);
-weaponDef-&gt;tracks = sAICallback-&gt;WeaponDef_isTracks(teamId, weaponDefId);
-weaponDef-&gt;dropped = sAICallback-&gt;WeaponDef_isDropped(teamId, weaponDefId);
-weaponDef-&gt;paralyzer = sAICallback-&gt;WeaponDef_isParalyzer(teamId, weaponDefId);
-weaponDef-&gt;impactOnly = sAICallback-&gt;WeaponDef_isImpactOnly(teamId, weaponDefId);
-weaponDef-&gt;noAutoTarget = sAICallback-&gt;WeaponDef_isNoAutoTarget(teamId, weaponDefId);
-weaponDef-&gt;manualfire = sAICallback-&gt;WeaponDef_isManualFire(teamId, weaponDefId);
-weaponDef-&gt;interceptor = sAICallback-&gt;WeaponDef_getInterceptor(teamId, weaponDefId);
-weaponDef-&gt;targetable = sAICallback-&gt;WeaponDef_getTargetable(teamId, weaponDefId);
-weaponDef-&gt;stockpile = sAICallback-&gt;WeaponDef_isStockpileable(teamId, weaponDefId);
-weaponDef-&gt;coverageRange = sAICallback-&gt;WeaponDef_getCoverageRange(teamId, weaponDefId);
-weaponDef-&gt;stockpileTime = sAICallback-&gt;WeaponDef_getStockpileTime(teamId, weaponDefId);
-weaponDef-&gt;intensity = sAICallback-&gt;WeaponDef_getIntensity(teamId, weaponDefId);
-weaponDef-&gt;thickness = sAICallback-&gt;WeaponDef_getThickness(teamId, weaponDefId);
-weaponDef-&gt;laserflaresize = sAICallback-&gt;WeaponDef_getLaserFlareSize(teamId, weaponDefId);
-weaponDef-&gt;corethickness = sAICallback-&gt;WeaponDef_getCoreThickness(teamId, weaponDefId);
-weaponDef-&gt;duration = sAICallback-&gt;WeaponDef_getDuration(teamId, weaponDefId);
-weaponDef-&gt;lodDistance = sAICallback-&gt;WeaponDef_getLodDistance(teamId, weaponDefId);
-weaponDef-&gt;falloffRate = sAICallback-&gt;WeaponDef_getFalloffRate(teamId, weaponDefId);
-weaponDef-&gt;graphicsType = sAICallback-&gt;WeaponDef_getGraphicsType(teamId, weaponDefId);
-weaponDef-&gt;soundTrigger = sAICallback-&gt;WeaponDef_isSoundTrigger(teamId, weaponDefId);
-weaponDef-&gt;selfExplode = sAICallback-&gt;WeaponDef_isSelfExplode(teamId, weaponDefId);
-weaponDef-&gt;gravityAffected = sAICallback-&gt;WeaponDef_isGravityAffected(teamId, weaponDefId);
-weaponDef-&gt;highTrajectory = sAICallback-&gt;WeaponDef_getHighTrajectory(teamId, weaponDefId);
-weaponDef-&gt;myGravity = sAICallback-&gt;WeaponDef_getMyGravity(teamId, weaponDefId);
-weaponDef-&gt;noExplode = sAICallback-&gt;WeaponDef_isNoExplode(teamId, weaponDefId);
-weaponDef-&gt;startvelocity = sAICallback-&gt;WeaponDef_getStartVelocity(teamId, weaponDefId);
-weaponDef-&gt;weaponacceleration = sAICallback-&gt;WeaponDef_getWeaponAcceleration(teamId, weaponDefId);
-weaponDef-&gt;turnrate = sAICallback-&gt;WeaponDef_getTurnRate(teamId, weaponDefId);
-weaponDef-&gt;maxvelocity = sAICallback-&gt;WeaponDef_getMaxVelocity(teamId, weaponDefId);
-weaponDef-&gt;projectilespeed = sAICallback-&gt;WeaponDef_getProjectileSpeed(teamId, weaponDefId);
-weaponDef-&gt;explosionSpeed = sAICallback-&gt;WeaponDef_getExplosionSpeed(teamId, weaponDefId);
-weaponDef-&gt;onlyTargetCategory = sAICallback-&gt;WeaponDef_getOnlyTargetCategory(teamId, weaponDefId);
-weaponDef-&gt;wobble = sAICallback-&gt;WeaponDef_getWobble(teamId, weaponDefId);
-weaponDef-&gt;dance = sAICallback-&gt;WeaponDef_getDance(teamId, weaponDefId);
-weaponDef-&gt;trajectoryHeight = sAICallback-&gt;WeaponDef_getTrajectoryHeight(teamId, weaponDefId);
-weaponDef-&gt;largeBeamLaser = sAICallback-&gt;WeaponDef_isLargeBeamLaser(teamId, weaponDefId);
-weaponDef-&gt;isShield = sAICallback-&gt;WeaponDef_isShield(teamId, weaponDefId);
-weaponDef-&gt;shieldRepulser = sAICallback-&gt;WeaponDef_isShieldRepulser(teamId, weaponDefId);
-weaponDef-&gt;smartShield = sAICallback-&gt;WeaponDef_isSmartShield(teamId, weaponDefId);
-weaponDef-&gt;exteriorShield = sAICallback-&gt;WeaponDef_isExteriorShield(teamId, weaponDefId);
-weaponDef-&gt;visibleShield = sAICallback-&gt;WeaponDef_isVisibleShield(teamId, weaponDefId);
-weaponDef-&gt;visibleShieldRepulse = sAICallback-&gt;WeaponDef_isVisibleShieldRepulse(teamId, weaponDefId);
-weaponDef-&gt;visibleShieldHitFrames = sAICallback-&gt;WeaponDef_getVisibleShieldHitFrames(teamId, weaponDefId);
-weaponDef-&gt;shieldEnergyUse = sAICallback-&gt;WeaponDef_getShieldEnergyUse(teamId, weaponDefId);
-weaponDef-&gt;shieldRadius = sAICallback-&gt;WeaponDef_getShieldRadius(teamId, weaponDefId);
-weaponDef-&gt;shieldForce = sAICallback-&gt;WeaponDef_getShieldForce(teamId, weaponDefId);
-weaponDef-&gt;shieldMaxSpeed = sAICallback-&gt;WeaponDef_getShieldMaxSpeed(teamId, weaponDefId);
-weaponDef-&gt;shieldPower = sAICallback-&gt;WeaponDef_getShieldPower(teamId, weaponDefId);
-weaponDef-&gt;shieldPowerRegen = sAICallback-&gt;WeaponDef_getShieldPowerRegen(teamId, weaponDefId);
-weaponDef-&gt;shieldPowerRegenEnergy = sAICallback-&gt;WeaponDef_getShieldPowerRegenEnergy(teamId, weaponDefId);
-weaponDef-&gt;shieldStartingPower = sAICallback-&gt;WeaponDef_getShieldStartingPower(teamId, weaponDefId);
-weaponDef-&gt;shieldRechargeDelay = sAICallback-&gt;WeaponDef_getShieldRechargeDelay(teamId, weaponDefId);
-weaponDef-&gt;shieldGoodColor = float3(sAICallback-&gt;WeaponDef_getShieldGoodColor(teamId, weaponDefId));
-weaponDef-&gt;shieldBadColor = float3(sAICallback-&gt;WeaponDef_getShieldBadColor(teamId, weaponDefId));
-weaponDef-&gt;shieldAlpha = sAICallback-&gt;WeaponDef_getShieldAlpha(teamId, weaponDefId);
-weaponDef-&gt;shieldInterceptType = sAICallback-&gt;WeaponDef_getShieldInterceptType(teamId, weaponDefId);
-weaponDef-&gt;interceptedByShieldType = sAICallback-&gt;WeaponDef_getInterceptedByShieldType(teamId, weaponDefId);
-weaponDef-&gt;avoidFriendly = sAICallback-&gt;WeaponDef_isAvoidFriendly(teamId, weaponDefId);
-weaponDef-&gt;avoidFeature = sAICallback-&gt;WeaponDef_isAvoidFeature(teamId, weaponDefId);
-weaponDef-&gt;avoidNeutral = sAICallback-&gt;WeaponDef_isAvoidNeutral(teamId, weaponDefId);
-weaponDef-&gt;targetBorder = sAICallback-&gt;WeaponDef_getTargetBorder(teamId, weaponDefId);
-weaponDef-&gt;cylinderTargetting = sAICallback-&gt;WeaponDef_getCylinderTargetting(teamId, weaponDefId);
-weaponDef-&gt;minIntensity = sAICallback-&gt;WeaponDef_getMinIntensity(teamId, weaponDefId);
-weaponDef-&gt;heightBoostFactor = sAICallback-&gt;WeaponDef_getHeightBoostFactor(teamId, weaponDefId);
-weaponDef-&gt;proximityPriority = sAICallback-&gt;WeaponDef_getProximityPriority(teamId, weaponDefId);
-weaponDef-&gt;collisionFlags = sAICallback-&gt;WeaponDef_getCollisionFlags(teamId, weaponDefId);
-weaponDef-&gt;sweepFire = sAICallback-&gt;WeaponDef_isSweepFire(teamId, weaponDefId);
-weaponDef-&gt;canAttackGround = sAICallback-&gt;WeaponDef_isCanAttackGround(teamId, weaponDefId);
-weaponDef-&gt;cameraShake = sAICallback-&gt;WeaponDef_getCameraShake(teamId, weaponDefId);
-weaponDef-&gt;dynDamageExp = sAICallback-&gt;WeaponDef_getDynDamageExp(teamId, weaponDefId);
-weaponDef-&gt;dynDamageMin = sAICallback-&gt;WeaponDef_getDynDamageMin(teamId, weaponDefId);
-weaponDef-&gt;dynDamageRange = sAICallback-&gt;WeaponDef_getDynDamageRange(teamId, weaponDefId);
-weaponDef-&gt;dynDamageInverted = sAICallback-&gt;WeaponDef_isDynDamageInverted(teamId, weaponDefId);
-//	logT(&quot;GetWeaponDefById 6&quot;);
-//{
-//	SProperties* sProperties = sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId);
-//	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
-//	int i;
-//	for (i=0; i &lt; sProperties-&gt;size; ++i) {
-//		weaponDef-&gt;customParams.insert(sProperties-&gt;map[i][0], sProperties-&gt;map[i][1]);
-//	}
-//	free(sProperties-&gt;map);
-//}
-{
-	int size = sAICallback-&gt;WeaponDef_getNumCustomParams(teamId, weaponDefId);
-	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
-//	logT(&quot;GetWeaponDefById 7&quot;);
-//	logI(&quot;GetWeaponDefById 7 size: %d&quot;, size);
-//	int i;
-//	for (i=0; i &lt; size; ++i) {
-//		const char** entry = sAICallback-&gt;WeaponDef_getCustomParam(teamId, weaponDefId, i);
-////		weaponDef-&gt;customParams.insert(entry[0], entry[1]);
-//		weaponDef-&gt;customParams[entry[0]] = entry[1];
-////		free(entry);
-//	}
-//	const char*** cMap = (const char***) malloc(size*2*sizeof(char*));
-	const char* cKeys[size];
-	const char* cValues[size];
-	sAICallback-&gt;WeaponDef_getCustomParamKeys(teamId, weaponDefId, cKeys);
-	sAICallback-&gt;WeaponDef_getCustomParamValues(teamId, weaponDefId, cValues);
-//	logT(&quot;GetWeaponDefById 8&quot;);
-//	logI(&quot;GetWeaponDefById 8 size: %d&quot;, size);
-	int i;
-	for (i=0; i &lt; size; ++i) {
-//	logI(&quot;GetWeaponDefById 8 i: %d&quot;, i);
-		weaponDef-&gt;customParams[cKeys[i]] = cValues[i];
-	}
-//	free(cMap);
-}
-//	logT(&quot;GetWeaponDefById 9&quot;);
-	if (weaponDefs[weaponDefId] != NULL) {
-		delete weaponDefs[weaponDefId];
-	}
-//	logT(&quot;GetWeaponDefById 10&quot;);
-		weaponDefs[weaponDefId] = weaponDef;
-//	logT(&quot;GetWeaponDefById 11&quot;);
-		weaponDefFrames[weaponDefId] = currentFrame;
-//	logT(&quot;GetWeaponDefById 12&quot;);
-	}
-
-//	logT(&quot;leaving: GetWeaponDefById sAICallback&quot;);
-	return weaponDefs[weaponDefId];
-}
-
-const float3* CAIAICallback::GetStartPos() {
-	return new float3(sAICallback-&gt;Map_getStartPos(teamId));
-}
-
-
-
-
-
-
-
-void CAIAICallback::SendTextMsg(const char* text, int zone) {
-	SSendTextMessageCommand cmd = {text, zone};
-	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_TEXT_MESSAGE, &amp;cmd);
-}
-
-void CAIAICallback::SetLastMsgPos(float3 pos) {
-	SSetLastPosMessageCommand cmd = {pos.toSAIFloat3()}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SET_LAST_POS_MESSAGE, &amp;cmd);
-}
-
-void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
-	SAddNotificationDrawerCommand cmd = {pos.toSAIFloat3(), color.toSAIFloat3(), alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_ADD_NOTIFICATION, &amp;cmd);
-}
-
-bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
-		SSendResourcesCommand cmd = {mAmount, eAmount, receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_RESOURCES, &amp;cmd); return cmd.ret_isExecuted;
-}
-
-int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeam) {
-	int arr_unitIds[unitIds.size()];
-	for (unsigned int i=0; i &lt; unitIds.size(); ++i) {
-		arr_unitIds[i] = unitIds[i];
-	}
-	SSendUnitsCommand cmd = {arr_unitIds, unitIds.size(), receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_UNITS, &amp;cmd); return cmd.ret_sentUnits;
-}
-
-void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
-		SCreateSharedMemAreaCommand cmd = {name, size}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_CREATE, &amp;cmd); return cmd.ret_sharedMemArea;
-}
-
-void CAIAICallback::ReleasedSharedMemArea(char* name) {
-	SReleaseSharedMemAreaCommand cmd = {name}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_RELEASE, &amp;cmd);
-}
-
-int CAIAICallback::CreateGroup(const char* libraryName, unsigned aiNumber) {
-		SCreateGroupCommand cmd = {libraryName, aiNumber}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_CREATE, &amp;cmd); return cmd.ret_groupId;
-}
-
-void CAIAICallback::EraseGroup(int groupId) {
-	SEraseGroupCommand cmd = {groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ERASE, &amp;cmd);
-}
-
-bool CAIAICallback::AddUnitToGroup(int unitId, int groupId) {
-		SAddUnitToGroupCommand cmd = {unitId, groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ADD_UNIT, &amp;cmd); return cmd.ret_isExecuted;
-}
-
-bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
-		SRemoveUnitFromGroupCommand cmd = {unitId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_REMOVE_UNIT, &amp;cmd); return cmd.ret_isExecuted;
-}
-
-int CAIAICallback::GiveGroupOrder(int groupId, Command* c) {
-	return this-&gt;Internal_GiveOrder(-1, groupId, c);
-}
-
-int CAIAICallback::GiveOrder(int unitId, Command* c) {
-	return this-&gt;Internal_GiveOrder(unitId, -1, c);
-}
-
-int CAIAICallback::Internal_GiveOrder(int unitId, int groupId, Command* c) {
-	
-/*
-	int ret = -1;
-	
-	switch (c-&gt;id) {
-        case CMD_STOP:
-		{
-			SStopUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOP, &amp;cmd);
-			break;
-		}
-		case CMD_WAIT:
-		{
-			SWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT, &amp;cmd);
-			break;
-		}
-		case CMD_TIMEWAIT:
-		{
-			STimeWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_TIME, &amp;cmd);
-			break;
-		}
-		case CMD_DEATHWAIT:
-		{
-			SDeathWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_DEATH, &amp;cmd);
-			break;
-		}
-		case CMD_SQUADWAIT:
-		{
-			SSquadWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_SQUAD, &amp;cmd);
-			break;
-		}
-		case CMD_GATHERWAIT:
-		{
-			SGatherWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_GATHER, &amp;cmd);
-			break;
-		}
-		case CMD_MOVE:
-		{
-			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SMoveUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_MOVE, &amp;cmd);
-			break;
-		}
-		case CMD_PATROL:
-		{
-			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SPatrolUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_PATROL, &amp;cmd);
-			break;
-		}
-		case CMD_FIGHT:
-		{
-			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SFightUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_FIGHT, &amp;cmd);
-			break;
-		}
-		case CMD_ATTACK:
-		{
-			if (c-&gt;params.size() &lt; 3) {
-				SAttackUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK, &amp;cmd);
-			} else {
-				SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				float radius = 0.0f;
-				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-				SAttackAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toAttackPos, radius};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK_AREA, &amp;cmd);
-			}
-			break;
-		}
-		case CMD_GUARD:
-		{
-			SGuardUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GUARD, &amp;cmd);
-			break;
-		}
-		case CMD_AISELECT:
-		{
-			SAiSelectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_AI_SELECT, &amp;cmd);
-			break;
-		}
-		case CMD_GROUPADD:
-		{
-			SGroupAddUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_ADD, &amp;cmd);
-			break;
-		}
-		case CMD_GROUPCLEAR:
-		{
-			SGroupClearUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_CLEAR, &amp;cmd);
-			break;
-		}
-		case CMD_REPAIR:
-		{
-			SRepairUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_REPAIR, &amp;cmd);
-			break;
-		}
-		case CMD_FIRE_STATE:
-		{
-			SSetFireStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_FIRE_STATE, &amp;cmd);
-			break;
-		}
-		case CMD_MOVE_STATE:
-		{
-			SSetMoveStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_MOVE_STATE, &amp;cmd);
-			break;
-		}
-		case CMD_SETBASE:
-		{
-			SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SSetBaseUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, basePos};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_BASE, &amp;cmd);
-			break;
-		}
-		case CMD_SELFD:
-		{
-			SSelfDestroyUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SELF_DESTROY, &amp;cmd);
-			break;
-		}
-		case CMD_SET_WANTED_MAX_SPEED:
-		{
-			SSetWantedMaxSpeedUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_WANTED_MAX_SPEED, &amp;cmd);
-			break;
-		}
-		case CMD_LOAD_UNITS:
-		{
-			if (c-&gt;params.size() &lt; 3) {
-				int toLoadUnitId = (int) c-&gt;params[0];
-				SLoadUnitsUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, &amp;toLoadUnitId, 1};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS, &amp;cmd);
-			} else {
-				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				float radius = 0.0f;
-				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-				SLoadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS_AREA, &amp;cmd);
-			}
-			break;
-		}
-		case CMD_LOAD_ONTO:
-		{
-			SLoadOntoUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_ONTO, &amp;cmd);
-			break;
-		}
-		case CMD_UNLOAD_UNIT:
-		{
-			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SUnloadUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, (int) c-&gt;params[3]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNIT, &amp;cmd);
-			break;
-		}
-		case CMD_UNLOAD_UNITS:
-		{
-			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SUnloadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, c-&gt;params[3]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNITS_AREA, &amp;cmd);
-			break;
-		}
-		case CMD_ONOFF:
-		{
-			SSetOnOffUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_ON_OFF, &amp;cmd);
-			break;
-		}
-		case CMD_RECLAIM:
-		{
-			if (c-&gt;params.size() &lt; 3) {
-				SReclaimUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM, &amp;cmd);
-			} else {
-				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				float radius = 0.0f;
-				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-				SReclaimAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM_AREA, &amp;cmd);
-			}
-			break;
-		}
-		case CMD_CLOAK:
-		{
-			SCloakUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CLOAK, &amp;cmd);
-			break;
-		}
-		case CMD_STOCKPILE:
-		{
-			SStockpileUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOCKPILE, &amp;cmd);
-			break;
-		}
-		case CMD_DGUN:
-		{
-			if (c-&gt;params.size() &lt; 3) {
-				SDGunUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN, &amp;cmd);
-			} else {
-				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				SDGunPosUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN_POS, &amp;cmd);
-			}
-			break;
-		}
-		case CMD_RESTORE:
-		{
-			SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-			SRestoreAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, c-&gt;params[3]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESTORE_AREA, &amp;cmd);
-			break;
-		}
-		case CMD_REPEAT:
-		{
-			SSetRepeatUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_REPEAT, &amp;cmd);
-			break;
-		}
-		case CMD_TRAJECTORY:
-		{
-			SSetTrajectoryUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_TRAJECTORY, &amp;cmd);
-			break;
-		}
-		case CMD_RESURRECT:
-		{
-			if (c-&gt;params.size() &lt; 3) {
-				SResurrectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT, &amp;cmd);
-			} else {
-				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				float radius = 0.0f;
-				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-				SResurrectAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT_AREA, &amp;cmd);
-			}
-			break;
-		}
-		case CMD_CAPTURE:
-		{
-			if (c-&gt;params.size() &lt; 3) {
-				SCaptureUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE, &amp;cmd);
-			} else {
-				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				float radius = 0.0f;
-				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
-				SCaptureAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE_AREA, &amp;cmd);
-			}
-			break;
-		}
-		case CMD_AUTOREPAIRLEVEL:
-		{
-			SSetAutoRepairLevelUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL, &amp;cmd);
-			break;
-		}
-		case CMD_IDLEMODE:
-		{
-			SSetIdleModeUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_IDLE_MODE, &amp;cmd);
-			break;
-		}
-		default:
-		{
-			if (c-&gt;id &lt; 0) { // CMD_BUILD
-				int toBuildUnitDefId = -c-&gt;id;
-				SAIFloat3 buildPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
-				int facing = UNIT_COMMAND_BUILD_NO_FACING;
-				if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
-				SBuildUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toBuildUnitDefId, buildPos, facing};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_BUILD, &amp;cmd);
-			} else { // CMD_CUSTOM
-				int cmdId = c-&gt;id;
-				int numParams = c-&gt;params.size();
-				float params[numParams];
-				SCustomUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, cmdId, params, numParams};
-				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CUSTOM, &amp;cmd);
-			}
-			break;
-		}
-
-	}
-	
-	return ret;
-*/
-    int sCommandId;
-    void* sCommandData = mallocSUnitCommand(unitId, groupId, c, &amp;sCommandId);
-    
-    int ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, sCommandId, sCommandData);
-    
-    freeSUnitCommand(sCommandData, sCommandId);
-    
-    return ret;
-}
-
-int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
-		SInitPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_INIT, &amp;cmd); return cmd.ret_pathId;
-}
-
-float3 CAIAICallback::GetNextWaypoint(int pathId) {
-		SGetNextWaypointPathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_NEXT_WAYPOINT, &amp;cmd); return float3(cmd.ret_nextWaypoint);
-}
-
-float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
-		SGetApproximateLengthPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_APPROXIMATE_LENGTH, &amp;cmd); return cmd.ret_approximatePathLength;
-}
-
-void CAIAICallback::FreePath(int pathId) {
-	SFreePathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_FREE, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
-	SAIFloat3 col3 = {color[0], color[1], color[2]};
-	float alpha = color[3];
-	SStartPathDrawerCommand cmd = {pos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_START, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerFinishPath() {
-	SFinishPathDrawerCommand cmd = {}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_FINISH, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
-	SAIFloat3 col3 = {color[0], color[1], color[2]};
-	float alpha = color[3];
-	SDrawLinePathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdId, const float3&amp; endPos, const float* color) {
-	SAIFloat3 col3 = {color[0], color[1], color[2]};
-	float alpha = color[3];
-	SDrawLineAndIconPathDrawerCommand cmd = {cmdId, endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdId) {
-	SDrawIconAtLastPosPathDrawerCommand cmd = {cmdId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
-	SAIFloat3 col3 = {color[0], color[1], color[2]};
-	float alpha = color[3];
-	SBreakPathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_BREAK, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerRestart() {
-	SRestartPathDrawerCommand cmd = {false}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
-}
-
-void CAIAICallback::LineDrawerRestartSameColor() {
-	SRestartPathDrawerCommand cmd = {true}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
-}
-
-int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifeTime, int figureGroupId) {
-		SCreateSplineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), pos3.toSAIFloat3(), pos4.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_SPLINE, &amp;cmd); return cmd.ret_newFigureGroupId;
-}
-
-int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifeTime, int figureGroupId) {
-		SCreateLineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_LINE, &amp;cmd); return cmd.ret_newFigureGroupId;
-}
-
-void CAIAICallback::SetFigureColor(int figureGroupId, float red, float green, float blue, float alpha) {
-	SAIFloat3 col3 = {red, green, blue};
-	SSetColorFigureDrawerCommand cmd = {figureGroupId, col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_SET_COLOR, &amp;cmd);
-}
-
-void CAIAICallback::DeleteFigureGroup(int figureGroupId) {
-	SDeleteFigureDrawerCommand cmd = {figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_DELETE, &amp;cmd);
-}
-
-void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifeTime, int unitTeamId, bool transparent, bool drawBorder, int facing) {
-	SDrawUnitDrawerCommand cmd = {sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, name), pos.toSAIFloat3(), rotation, lifeTime, unitTeamId, transparent, drawBorder, facing}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_DRAW_UNIT, &amp;cmd);
-}
-
-int CAIAICallback::HandleCommand(int commandId, void* data) {
-	
-	int cmdTopicIndex = commandId;
-	int ret = -99;
-	
-	switch (commandId) {
-		case AIHCQuerySubVersionId: {
-//			SQuerySubVersionCommand cmd;
-//			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
-			ret = sAICallback-&gt;Game_getAiInterfaceVersion(teamId);
-			break;
-		}
-		case AIHCAddMapPointId: {
-			AIHCAddMapPoint* myData = (AIHCAddMapPoint*) data;
-			SAddPointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3(), myData-&gt;label};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
-			break;
-		}
-		case AIHCAddMapLineId: {
-			AIHCAddMapLine* myData = (AIHCAddMapLine*) data;
-			SAddLineDrawCommand cmd = {myData-&gt;posfrom.toSAIFloat3(), myData-&gt;posto.toSAIFloat3()};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
-			break;
-		}
-		case AIHCRemoveMapPointId: {
-			AIHCRemoveMapPoint* myData = (AIHCRemoveMapPoint*) data;
-			SRemovePointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3()};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
-			break;
-		}
-		case AIHCSendStartPosId: {
-			AIHCSendStartPos* myData = (AIHCSendStartPos*) data;
-			SSendStartPosCommand cmd = {myData-&gt;ready, myData-&gt;pos.toSAIFloat3()};
-			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
-			break;
-		}
-	}
-	
-	return ret;
-}
-
-bool CAIAICallback::ReadFile(const char* filename, void* buffer, int bufferLen) {
-//		SReadFileCommand cmd = {name, buffer, bufferLen}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_READ_FILE, &amp;cmd); return cmd.ret_isExecuted;
-	return sAICallback-&gt;File_getContent(teamId, filename, buffer, bufferLen);
-}
-
-const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
-		SCallLuaRulesCommand cmd = {data, inSize, outSize}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CALL_LUA_RULES, &amp;cmd); return cmd.ret_outData;
-}
-
-

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp (from rev 7024, branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.cpp)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,2285 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIAICallback.h&quot;
+
+
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;ExternalAI/Interface/AISCommands.h&quot;
+
+#include &quot;creg/creg_cond.h&quot;
+#ifdef USING_CREG
+creg::Class* CCommandQueue::GetClass() { return NULL; }
+#endif
+#include &quot;Sim/Units/UnitDef.h&quot;
+#include &quot;Sim/MoveTypes/MoveInfo.h&quot;
+UnitDef::~UnitDef() {
+	delete movedata;
+}
+CIcon::CIcon() {}
+CIcon::~CIcon() {}
+UnitDef::UnitDefWeapon::UnitDefWeapon() {}
+#include &quot;Sim/Features/FeatureDef.h&quot;
+#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+WeaponDef::~WeaponDef() {}
+
+#include &lt;string&gt;
+
+
+CAIAICallback::CAIAICallback()
+	: IAICallback(), teamId(-1), sAICallback(NULL)/*, aiCallback(NULL)*/ {
+	init();
+}
+
+CAIAICallback::CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/)
+	: IAICallback(), teamId(teamId), sAICallback(sAICallback)/*, aiCallback(aiCallback)*/ {
+	init();
+}
+
+
+void fillWithNULL(void** arr, int size) {
+	for (int i=0; i &lt; size; ++i) {
+		arr[i] = NULL;
+	}
+}
+void fillWithMinusOne(int* arr, int size) {
+	for (int i=0; i &lt; size; ++i) {
+		arr[i] = -1;
+	}
+}
+
+void CAIAICallback::init() {
+
+	// init caches
+	int maxCacheSize = 1024;
+	int maxUnits = 10000;
+	int maxGroups = 100;
+
+	weaponDefs = new WeaponDef*[maxCacheSize]; fillWithNULL((void**)weaponDefs, maxCacheSize);
+	weaponDefFrames = new int[maxCacheSize]; fillWithMinusOne(weaponDefFrames, maxCacheSize);
+
+	unitDefs = new UnitDef*[maxCacheSize]; fillWithNULL((void**)unitDefs, maxCacheSize);
+	unitDefFrames = new int[maxCacheSize]; fillWithMinusOne(unitDefFrames, maxCacheSize);
+	groupPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxGroups]; fillWithNULL((void**)groupPossibleCommands, maxGroups);
+	unitPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxUnits]; fillWithNULL((void**)unitPossibleCommands, maxUnits);
+	unitCurrentCommandQueues = new CCommandQueue*[maxUnits]; fillWithNULL((void**)unitCurrentCommandQueues, maxUnits);
+
+	featureDefs = new FeatureDef*[maxCacheSize]; fillWithNULL((void**)featureDefs, maxCacheSize);
+	featureDefFrames = new int[maxCacheSize]; fillWithMinusOne(featureDefFrames, maxCacheSize);
+}
+
+
+//bool CAIAICallback::PosInCamera(float3 pos, float radius) {
+//	return aiCallback-&gt;PosInCamera(pos, radius);
+//}
+//
+//int CAIAICallback::GetCurrentFrame() {
+//	return aiCallback-&gt;GetCurrentFrame();
+//}
+//
+//int CAIAICallback::GetMyTeam() {
+//	return aiCallback-&gt;GetMyTeam();
+//}
+//
+//int CAIAICallback::GetMyAllyTeam() {
+//	return aiCallback-&gt;GetMyAllyTeam();
+//}
+//
+//int CAIAICallback::GetPlayerTeam(int player) {
+//	return aiCallback-&gt;GetPlayerTeam(player);
+//}
+//
+//const char* CAIAICallback::GetTeamSide(int team) {
+//	return aiCallback-&gt;GetTeamSide(team);
+//}
+//
+//int CAIAICallback::GetUnitGroup(int unitId) {
+//	return aiCallback-&gt;GetUnitGroup(unitId);
+//}
+//
+//int CAIAICallback::GetUnitAiHint(int unitId) {
+//	return aiCallback-&gt;GetUnitAiHint(unitId);
+//}
+//
+//int CAIAICallback::GetUnitTeam(int unitId) {
+//	return aiCallback-&gt;GetUnitTeam(unitId);
+//}
+//
+//int CAIAICallback::GetUnitAllyTeam(int unitId) {
+//	return aiCallback-&gt;GetUnitAllyTeam(unitId);
+//}
+//
+//float CAIAICallback::GetUnitHealth(int unitId) {
+//	return aiCallback-&gt;GetUnitHealth(unitId);
+//}
+//
+//float CAIAICallback::GetUnitMaxHealth(int unitId) {
+//	return aiCallback-&gt;GetUnitMaxHealth(unitId);
+//}
+//
+//float CAIAICallback::GetUnitSpeed(int unitId) {
+//	return aiCallback-&gt;GetUnitSpeed(unitId);
+//}
+//
+//float CAIAICallback::GetUnitPower(int unitId) {
+//	return aiCallback-&gt;GetUnitPower(unitId);
+//}
+//
+//float CAIAICallback::GetUnitExperience(int unitId) {
+//	return aiCallback-&gt;GetUnitExperience(unitId);
+//}
+//
+//float CAIAICallback::GetUnitMaxRange(int unitId) {
+//	return aiCallback-&gt;GetUnitMaxRange(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitActivated(int unitId) {
+//	return aiCallback-&gt;IsUnitActivated(unitId);
+//}
+//
+//bool CAIAICallback::UnitBeingBuilt(int unitId) {
+//	return aiCallback-&gt;UnitBeingBuilt(unitId);
+//}
+//
+//float3 CAIAICallback::GetUnitPos(int unitId) {
+//	return aiCallback-&gt;GetUnitPos(unitId);
+//}
+//
+//int CAIAICallback::GetBuildingFacing(int unitId) {
+//	return aiCallback-&gt;GetBuildingFacing(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitCloaked(int unitId) {
+//	return aiCallback-&gt;IsUnitCloaked(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitParalyzed(int unitId) {
+//	return aiCallback-&gt;IsUnitParalyzed(unitId);
+//}
+//
+//bool CAIAICallback::IsUnitNeutral(int unitId) {
+//	return aiCallback-&gt;IsUnitNeutral(unitId);
+//}
+//
+//bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+//	return aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+//}
+//
+//float3 CAIAICallback::GetNextWaypoint(int pathid) {
+//	return aiCallback-&gt;GetNextWaypoint(pathid);
+//}
+//
+//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;GetPathLength(start, end, pathType);
+//}
+//
+//int CAIAICallback::GetEnemyUnits(int* unitIds) {
+//	return aiCallback-&gt;GetEnemyUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
+//	return aiCallback-&gt;GetEnemyUnitsInRadarAndLos(unitIds);
+//}
+//
+//int CAIAICallback::GetFriendlyUnits(int* unitIds) {
+//	return aiCallback-&gt;GetFriendlyUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetFriendlyUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetNeutralUnits(int* unitIds) {
+//	return aiCallback-&gt;GetNeutralUnits(unitIds);
+//}
+//
+//int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+//}
+//
+//int CAIAICallback::GetMapWidth() {
+//	return aiCallback-&gt;GetMapWidth();
+//}
+//
+//int CAIAICallback::GetMapHeight() {
+//	return aiCallback-&gt;GetMapHeight();
+//}
+//
+//const float* CAIAICallback::GetHeightMap() {
+//	return aiCallback-&gt;GetHeightMap();
+//}
+//
+//float CAIAICallback::GetMinHeight() {
+//	return aiCallback-&gt;GetMinHeight();
+//}
+//
+//float CAIAICallback::GetMaxHeight() {
+//	return aiCallback-&gt;GetMaxHeight();
+//}
+//
+//const float* CAIAICallback::GetSlopeMap() {
+//	return aiCallback-&gt;GetSlopeMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetLosMap() {
+//	return aiCallback-&gt;GetLosMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetRadarMap() {
+//	return aiCallback-&gt;GetRadarMap();
+//}
+//
+//const unsigned short* CAIAICallback::GetJammerMap() {
+//	return aiCallback-&gt;GetJammerMap();
+//}
+//
+//const unsigned char* CAIAICallback::GetMetalMap() {
+//	return aiCallback-&gt;GetMetalMap();
+//}
+//
+//const char* CAIAICallback::GetMapName() {
+//	return aiCallback-&gt;GetMapName();
+//}
+//
+//const char* CAIAICallback::GetModName() {
+//	return aiCallback-&gt;GetModName();
+//}
+//
+//float CAIAICallback::GetElevation(float x, float z) {
+//	return aiCallback-&gt;GetElevation(x, z);
+//}
+//
+//float CAIAICallback::GetMaxMetal() {
+//	return aiCallback-&gt;GetMaxMetal();
+//}
+//
+//float CAIAICallback::GetExtractorRadius() {
+//	return aiCallback-&gt;GetExtractorRadius();
+//}
+//
+//float CAIAICallback::GetMinWind() {
+//	return aiCallback-&gt;GetMinWind();
+//}
+//
+//float CAIAICallback::GetMaxWind() {
+//	return aiCallback-&gt;GetMaxWind();
+//}
+//
+//float CAIAICallback::GetTidalStrength() {
+//	return aiCallback-&gt;GetTidalStrength();
+//}
+//
+//float CAIAICallback::GetGravity() {
+//	return aiCallback-&gt;GetGravity();
+//}
+//
+//bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
+//	return aiCallback-&gt;CanBuildAt(unitDef, pos, facing);
+//}
+//
+//float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
+//	return aiCallback-&gt;ClosestBuildSite(unitDef, pos, searchRadius, minDist, facing);
+//}
+//
+//bool CAIAICallback::GetProperty(int id, int property, void* dst) {
+//	return aiCallback-&gt;GetProperty(id, property, dst);
+//}
+//
+//bool CAIAICallback::GetValue(int id, void* dst) {
+//	return aiCallback-&gt;GetValue(id, dst);
+//}
+//
+//int CAIAICallback::GetFileSize(const char* name) {
+//	return aiCallback-&gt;GetFileSize(name);
+//}
+//
+//int CAIAICallback::GetSelectedUnits(int* unitIds) {
+//	return aiCallback-&gt;GetSelectedUnits(unitIds);
+//}
+//
+//float3 CAIAICallback::GetMousePos() {
+//	return aiCallback-&gt;GetMousePos();
+//}
+//
+//float CAIAICallback::GetMetal() {
+//	return aiCallback-&gt;GetMetal();
+//}
+//
+//float CAIAICallback::GetMetalIncome() {
+//	return aiCallback-&gt;GetMetalIncome();
+//}
+//
+//float CAIAICallback::GetMetalUsage() {
+//	return aiCallback-&gt;GetMetalUsage();
+//}
+//
+//float CAIAICallback::GetMetalStorage() {
+//	return aiCallback-&gt;GetMetalStorage();
+//}
+//
+//float CAIAICallback::GetEnergy() {
+//	return aiCallback-&gt;GetEnergy();
+//}
+//
+//float CAIAICallback::GetEnergyIncome() {
+//	return aiCallback-&gt;GetEnergyIncome();
+//}
+//
+//float CAIAICallback::GetEnergyUsage() {
+//	return aiCallback-&gt;GetEnergyUsage();
+//}
+//
+//float CAIAICallback::GetEnergyStorage() {
+//	return aiCallback-&gt;GetEnergyStorage();
+//}
+//
+//int CAIAICallback::GetFeatures(int *features, int max) {
+//	return aiCallback-&gt;GetFeatures(features, max);
+//}
+//
+//int CAIAICallback::GetFeatures(int *features, int max, const float3&amp; pos, float radius) {
+//	return aiCallback-&gt;GetFeatures(features, max, pos, radius);
+//}
+//
+//const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
+//	return aiCallback-&gt;GetFeatureDef(featureId);
+//}
+//
+//float CAIAICallback::GetFeatureHealth(int featureId) {
+//	return aiCallback-&gt;GetFeatureHealth(featureId);
+//}
+//
+//float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
+//	return aiCallback-&gt;GetFeatureReclaimLeft(featureId);
+//}
+//
+//float3 CAIAICallback::GetFeaturePos(int featureId) {
+//	return aiCallback-&gt;GetFeaturePos(featureId);
+//}
+//
+//int CAIAICallback::GetNumUnitDefs() {
+//	return aiCallback-&gt;GetNumUnitDefs();
+//}
+//
+//void CAIAICallback::GetUnitDefList(const UnitDef** list) {
+//	aiCallback-&gt;GetUnitDefList(list);
+//}
+
+//float CAIAICallback::GetUnitDefHeight(int def) {
+//	return aiCallback-&gt;GetUnitDefHeight(def);
+//}
+//
+//float CAIAICallback::GetUnitDefRadius(int def) {
+//	return aiCallback-&gt;GetUnitDefRadius(def);
+//}
+//
+//const float3* CAIAICallback::GetStartPos() {
+//	return aiCallback-&gt;GetStartPos();
+//}
+//
+//
+//
+//const WeaponDef* CAIAICallback::GetWeapon(const char* weaponname) {
+//	logT(&quot;CAIAICallback::GetWeapon() aiCallback&quot;);
+//	return aiCallback-&gt;GetWeapon(weaponname);
+//}
+//
+//const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
+//	logT(&quot;CAIAICallback::GetWeaponDefById() return NULL&quot;);
+//	return NULL;
+//}
+//
+//const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
+//	logT(&quot;CAIAICallback::GetFeatureDefById() aiCallback&quot;);
+//	return aiCallback-&gt;GetFeatureDefById(featureDefId);
+//}
+//
+//int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+//	return aiCallback-&gt;GetMapPoints(pm, maxPoints);
+//}
+//
+//int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+//	return aiCallback-&gt;GetMapLines(lm, maxLines);
+//}
+//
+//const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
+//	return aiCallback-&gt;GetUnitDef(unitName);
+//}
+
+//const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
+//	return aiCallback-&gt;GetUnitDefById(unitDefId);
+//}
+
+//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int unitId) {
+//	return aiCallback-&gt;GetGroupCommands(unitId);
+//}
+//
+//const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+//	return aiCallback-&gt;GetUnitCommands(unitId);
+//}
+//
+//const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+//	return aiCallback-&gt;GetCurrentUnitCommands(unitId);
+//}
+//
+//const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
+//	return aiCallback-&gt;GetUnitDef(unitId);
+//}
+
+
+
+
+
+
+
+//void CAIAICallback::SendTextMsg(const char* text, int zone) {
+//	aiCallback-&gt;SendTextMsg(text, zone);
+//}
+//
+//void CAIAICallback::SetLastMsgPos(float3 pos) {
+//	aiCallback-&gt;SetLastMsgPos(pos);
+//}
+//
+//void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
+//	aiCallback-&gt;AddNotification(pos, color, alpha);
+//}
+//
+//bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
+//	return aiCallback-&gt;SendResources(mAmount, eAmount, receivingTeam);
+//}
+//
+//int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam) {
+//	return aiCallback-&gt;SendUnits(unitIDs, receivingTeam);
+//}
+//
+//void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
+//	return aiCallback-&gt;CreateSharedMemArea(name, size);
+//}
+//
+//void CAIAICallback::ReleasedSharedMemArea(char* name) {
+//	aiCallback-&gt;ReleasedSharedMemArea(name);
+//}
+//
+//int CAIAICallback::CreateGroup(char* dll, unsigned aiNumber) {
+//	return aiCallback-&gt;CreateGroup(dll, aiNumber);
+//}
+//
+//void CAIAICallback::EraseGroup(int groupid) {
+//	aiCallback-&gt;EraseGroup(groupid);
+//}
+//
+//bool CAIAICallback::AddUnitToGroup(int unitId, int groupid) {
+//	return aiCallback-&gt;AddUnitToGroup(unitId, groupid);
+//}
+//
+//bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
+//	return aiCallback-&gt;RemoveUnitFromGroup(unitId);
+//}
+//
+//int CAIAICallback::GiveGroupOrder(int unitId, Command* c) {
+//	return aiCallback-&gt;GiveGroupOrder(unitId, c);
+//}
+//
+//int CAIAICallback::GiveOrder(int unitId, Command* c) {
+//	return aiCallback-&gt;GiveOrder(unitId, c);
+//}
+//
+//int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;InitPath(start, end, pathType);
+//}
+//
+//float3 CAIAICallback::GetNextWaypoint(int pathId) {
+//	return aiCallback-&gt;GetNextWaypoint(pathId);
+//}
+//
+//float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+//	return aiCallback-&gt;GetPathLength(start, end, pathType);
+//}
+//
+//void CAIAICallback::FreePath(int pathid) {
+//	aiCallback-&gt;FreePath(pathid);
+//}
+//
+//void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
+//	aiCallback-&gt;LineDrawerStartPath(pos, color);
+//}
+//
+//void CAIAICallback::LineDrawerFinishPath() {
+//	aiCallback-&gt;LineDrawerFinishPath();
+//}
+//
+//void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerDrawLine(endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerDrawLineAndIcon(cmdID, endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdID) {
+//	aiCallback-&gt;LineDrawerDrawIconAtLastPos(cmdID);
+//}
+//
+//void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
+//	aiCallback-&gt;LineDrawerBreak(endPos, color);
+//}
+//
+//void CAIAICallback::LineDrawerRestart() {
+//	aiCallback-&gt;LineDrawerRestart();
+//}
+//
+//void CAIAICallback::LineDrawerRestartSameColor() {
+//	aiCallback-&gt;LineDrawerRestartSameColor();
+//}
+//
+//int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group) {
+//	return aiCallback-&gt;CreateSplineFigure(pos1, pos2, pos3, pos4, width, arrow, lifetime, group);
+//}
+//
+//int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group) {
+//	return aiCallback-&gt;CreateLineFigure(pos1, pos2, width, arrow, lifetime, group);
+//}
+//
+//void CAIAICallback::SetFigureColor(int group, float red, float green, float blue, float alpha) {
+//	aiCallback-&gt;SetFigureColor(group, red, green, blue, alpha);
+//}
+//
+//void CAIAICallback::DeleteFigureGroup(int group) {
+//	aiCallback-&gt;DeleteFigureGroup(group);
+//}
+//
+//void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing) {
+//	aiCallback-&gt;DrawUnit(name, pos, rotation, lifetime, team, transparent, drawBorder, facing);
+//}
+//
+//int CAIAICallback::HandleCommand(int commandId, void* data) {
+//	return aiCallback-&gt;HandleCommand(commandId, data);
+//}
+//
+//bool CAIAICallback::ReadFile(const char* name, void* buffer, int bufferLen) {
+//	return aiCallback-&gt;ReadFile(name, buffer, bufferLen);
+//}
+//
+//const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
+//	return aiCallback-&gt;CallLuaRules(data, inSize, outSize);
+//}
+// ################################ &lt;- OLD impl ################################
+
+
+
+
+// ################################ NEW impl -&gt; ################################
+bool CAIAICallback::PosInCamera(float3 pos, float radius) {
+	return sAICallback-&gt;Map_isPosInCamera(teamId, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetCurrentFrame() {
+	return sAICallback-&gt;Game_getCurrentFrame(teamId);
+}
+
+int CAIAICallback::GetMyTeam() {
+	return sAICallback-&gt;Game_getMyTeam(teamId);
+}
+
+int CAIAICallback::GetMyAllyTeam() {
+	return sAICallback-&gt;Game_getMyAllyTeam(teamId);
+}
+
+int CAIAICallback::GetPlayerTeam(int player) {
+	return sAICallback-&gt;Game_getPlayerTeam(teamId, player);
+}
+
+const char* CAIAICallback::GetTeamSide(int team) {
+	return sAICallback-&gt;Game_getTeamSide(teamId, team);
+}
+
+int CAIAICallback::GetUnitGroup(int unitId) {
+	return sAICallback-&gt;Unit_getGroup(teamId, unitId);
+}
+
+
+/*
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
+	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
+	int ids[numCmds];
+	const char* names[numCmds];
+	const char* toolTips[numCmds];
+	bool showUniques[numCmds];
+	bool disableds[numCmds];
+	int numParams[numCmds];
+	const char** params[numCmds];
+	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
+	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
+	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
+	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
+	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
+	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
+	for (int c=0; c &lt; numCmds; c++) {
+		params[c] = new const char*[numParams[c]];
+	}
+	sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, params);
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[c][p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+
+	// to prevent memory wholes
+	if (groupPossibleCommands[groupId] != NULL) {
+		delete groupPossibleCommands[groupId];
+	}
+	groupPossibleCommands[groupId] = cmdDescVec;
+
+	return cmdDescVec;
+}
+*/
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
+
+	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
+
+	int ids[numCmds];
+	const char* names[numCmds];
+	const char* toolTips[numCmds];
+	bool showUniques[numCmds];
+	bool disableds[numCmds];
+	int numParams[numCmds];
+
+	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
+	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
+	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
+	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
+	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
+	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
+
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		const char* params[numParams[c]];
+		sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, c, params);
+
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+
+	// to prevent memory wholes
+	if (groupPossibleCommands[groupId] != NULL) {
+		delete groupPossibleCommands[groupId];
+	}
+	groupPossibleCommands[groupId] = cmdDescVec;
+
+	return cmdDescVec;
+}
+
+
+const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
+
+	int numCmds = sAICallback-&gt;Unit_getNumSupportedCommands(teamId, unitId);
+
+	int* ids = new int[numCmds];
+	const char* names[numCmds];
+	const char* toolTips[numCmds];
+	bool showUniques[numCmds];
+	bool disableds[numCmds];
+	int numParams[numCmds];
+
+	sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
+	sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
+	sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
+	sAICallback-&gt;Unit_SupportedCommands_isShowUnique(teamId, unitId, showUniques);
+	sAICallback-&gt;Unit_SupportedCommands_isDisabled(teamId, unitId, disableds);
+	sAICallback-&gt;Unit_SupportedCommands_getNumParams(teamId, unitId, numParams);
+
+	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
+	for (int c=0; c &lt; numCmds; c++) {
+		const char* params[numParams[c]];
+		sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, c, params);
+
+		CommandDescription commandDescription;
+		commandDescription.id = ids[c];
+		commandDescription.name = names[c];
+		commandDescription.tooltip = toolTips[c];
+		commandDescription.showUnique = showUniques[c];
+		commandDescription.disabled = disableds[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			commandDescription.params.push_back(params[p]);
+		}
+		cmdDescVec-&gt;push_back(commandDescription);
+	}
+
+	// to prevent memory wholes
+	if (unitPossibleCommands[unitId] != NULL) {
+		delete unitPossibleCommands[unitId];
+	}
+	unitPossibleCommands[unitId] = cmdDescVec;
+
+	return cmdDescVec;
+}
+
+const CCommandQueue* CAIAICallback::GetCurrentUnitCommands(int unitId) {
+
+	int numCmds = sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+
+	int ids[numCmds];
+	unsigned char options[numCmds];
+	unsigned int tags[numCmds];
+	int timeOuts[numCmds];
+	int numParams[numCmds];
+
+	sAICallback-&gt;Unit_getNumCurrentCommands(teamId, unitId);
+	sAICallback-&gt;Unit_CurrentCommands_getIds(teamId, unitId, ids);
+	sAICallback-&gt;Unit_CurrentCommands_getOptions(teamId, unitId, options);
+	sAICallback-&gt;Unit_CurrentCommands_getTag(teamId, unitId, tags);
+	sAICallback-&gt;Unit_CurrentCommands_getTimeOut(teamId, unitId, timeOuts);
+	sAICallback-&gt;Unit_CurrentCommands_getNumParams(teamId, unitId, numParams);
+
+	CCommandQueue* cc = new CCommandQueue();
+	for (int c=0; c &lt; numCmds; c++) {
+		float params[numParams[c]];
+		sAICallback-&gt;Unit_CurrentCommands_getParams(teamId, unitId, c, params);
+
+		Command command;
+		command.id = ids[c];
+		command.options = options[c];
+		command.tag = tags[c];
+		command.timeOut = timeOuts[c];
+		for (int p=0; p &lt; numParams[c]; p++) {
+			command.params.push_back(params[p]);
+		}
+		cc-&gt;push_back(command);
+	}
+
+	// to prevent memory wholes
+	if (unitCurrentCommandQueues[unitId] != NULL) {
+		delete unitCurrentCommandQueues[unitId];
+	}
+	unitCurrentCommandQueues[unitId] = cc;
+
+	return cc;
+}
+
+int CAIAICallback::GetUnitAiHint(int unitId) {
+	return sAICallback-&gt;Unit_getAiHint(teamId, unitId);
+}
+
+int CAIAICallback::GetUnitTeam(int unitId) {
+	return sAICallback-&gt;Unit_getTeam(teamId, unitId);
+}
+
+int CAIAICallback::GetUnitAllyTeam(int unitId) {
+	return sAICallback-&gt;Unit_getAllyTeam(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitHealth(int unitId) {
+	return sAICallback-&gt;Unit_getHealth(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitMaxHealth(int unitId) {
+	return sAICallback-&gt;Unit_getMaxHealth(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitSpeed(int unitId) {
+	return sAICallback-&gt;Unit_getSpeed(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitPower(int unitId) {
+	return sAICallback-&gt;Unit_getPower(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitExperience(int unitId) {
+	return sAICallback-&gt;Unit_getExperience(teamId, unitId);
+}
+
+float CAIAICallback::GetUnitMaxRange(int unitId) {
+	return sAICallback-&gt;Unit_getMaxRange(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitActivated(int unitId) {
+	return sAICallback-&gt;Unit_isActivated(teamId, unitId);
+}
+
+bool CAIAICallback::UnitBeingBuilt(int unitId) {
+	return sAICallback-&gt;Unit_isBeingBuilt(teamId, unitId);
+}
+
+const UnitDef* CAIAICallback::GetUnitDef(int unitId) {
+	int unitDefId = sAICallback-&gt;Unit_getDefId(teamId, unitId);
+	return this-&gt;GetUnitDefById(unitDefId);
+}
+
+float3 CAIAICallback::GetUnitPos(int unitId) {
+	return float3(sAICallback-&gt;Unit_getPos(teamId, unitId));
+}
+
+int CAIAICallback::GetBuildingFacing(int unitId) {
+	return sAICallback-&gt;Unit_getBuildingFacing(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitCloaked(int unitId) {
+	return sAICallback-&gt;Unit_isCloaked(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitParalyzed(int unitId) {
+	return sAICallback-&gt;Unit_isParalyzed(teamId, unitId);
+}
+
+bool CAIAICallback::IsUnitNeutral(int unitId) {
+	return sAICallback-&gt;Unit_isNeutral(teamId, unitId);
+}
+
+bool CAIAICallback::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+	resourceInfo-&gt;energyMake = sAICallback-&gt;Unit_ResourceInfo_Energy_getMake(teamId, unitId);
+	if (resourceInfo-&gt;energyMake &lt; 0) return false;
+	resourceInfo-&gt;energyUse = sAICallback-&gt;Unit_ResourceInfo_Energy_getUse(teamId, unitId);
+	resourceInfo-&gt;metalMake = sAICallback-&gt;Unit_ResourceInfo_Metal_getMake(teamId, unitId);
+	resourceInfo-&gt;metalUse = sAICallback-&gt;Unit_ResourceInfo_Metal_getUse(teamId, unitId);
+	return true;
+}
+
+const UnitDef* CAIAICallback::GetUnitDef(const char* unitName) {
+	int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitName);
+	return this-&gt;GetUnitDefById(unitDefId);
+}
+
+
+const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
+	//logT(&quot;entering: GetUnitDefById sAICallback&quot;);
+
+	if (unitDefId &lt; 0) {
+		return NULL;
+	}
+
+	bool doRecreate = unitDefFrames[unitDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+	UnitDef* unitDef = new UnitDef();
+unitDef-&gt;valid = sAICallback-&gt;UnitDef_isValid(teamId, unitDefId);
+unitDef-&gt;name = sAICallback-&gt;UnitDef_getName(teamId, unitDefId);
+unitDef-&gt;humanName = sAICallback-&gt;UnitDef_getHumanName(teamId, unitDefId);
+unitDef-&gt;filename = sAICallback-&gt;UnitDef_getFilename(teamId, unitDefId);
+unitDef-&gt;id = sAICallback-&gt;UnitDef_getId(teamId, unitDefId);
+unitDef-&gt;aihint = sAICallback-&gt;UnitDef_getAiHint(teamId, unitDefId);
+unitDef-&gt;cobID = sAICallback-&gt;UnitDef_getCobID(teamId, unitDefId);
+unitDef-&gt;techLevel = sAICallback-&gt;UnitDef_getTechLevel(teamId, unitDefId);
+unitDef-&gt;gaia = sAICallback-&gt;UnitDef_getGaia(teamId, unitDefId);
+unitDef-&gt;metalUpkeep = sAICallback-&gt;UnitDef_getMetalUpkeep(teamId, unitDefId);
+unitDef-&gt;energyUpkeep = sAICallback-&gt;UnitDef_getEnergyUpkeep(teamId, unitDefId);
+unitDef-&gt;metalMake = sAICallback-&gt;UnitDef_getMetalMake(teamId, unitDefId);
+unitDef-&gt;makesMetal = sAICallback-&gt;UnitDef_getMakesMetal(teamId, unitDefId);
+unitDef-&gt;energyMake = sAICallback-&gt;UnitDef_getEnergyMake(teamId, unitDefId);
+unitDef-&gt;metalCost = sAICallback-&gt;UnitDef_getMetalCost(teamId, unitDefId);
+unitDef-&gt;energyCost = sAICallback-&gt;UnitDef_getEnergyCost(teamId, unitDefId);
+unitDef-&gt;buildTime = sAICallback-&gt;UnitDef_getBuildTime(teamId, unitDefId);
+unitDef-&gt;extractsMetal = sAICallback-&gt;UnitDef_getExtractsMetal(teamId, unitDefId);
+unitDef-&gt;extractRange = sAICallback-&gt;UnitDef_getExtractRange(teamId, unitDefId);
+unitDef-&gt;windGenerator = sAICallback-&gt;UnitDef_getWindGenerator(teamId, unitDefId);
+unitDef-&gt;tidalGenerator = sAICallback-&gt;UnitDef_getTidalGenerator(teamId, unitDefId);
+unitDef-&gt;metalStorage = sAICallback-&gt;UnitDef_getMetalStorage(teamId, unitDefId);
+unitDef-&gt;energyStorage = sAICallback-&gt;UnitDef_getEnergyStorage(teamId, unitDefId);
+unitDef-&gt;autoHeal = sAICallback-&gt;UnitDef_getAutoHeal(teamId, unitDefId);
+unitDef-&gt;idleAutoHeal = sAICallback-&gt;UnitDef_getIdleAutoHeal(teamId, unitDefId);
+unitDef-&gt;idleTime = sAICallback-&gt;UnitDef_getIdleTime(teamId, unitDefId);
+unitDef-&gt;power = sAICallback-&gt;UnitDef_getPower(teamId, unitDefId);
+unitDef-&gt;health = sAICallback-&gt;UnitDef_getHealth(teamId, unitDefId);
+unitDef-&gt;category = sAICallback-&gt;UnitDef_getCategory(teamId, unitDefId);
+unitDef-&gt;speed = sAICallback-&gt;UnitDef_getSpeed(teamId, unitDefId);
+unitDef-&gt;turnRate = sAICallback-&gt;UnitDef_getTurnRate(teamId, unitDefId);
+unitDef-&gt;turnInPlace = sAICallback-&gt;UnitDef_isTurnInPlace(teamId, unitDefId);
+unitDef-&gt;moveType = sAICallback-&gt;UnitDef_getMoveType(teamId, unitDefId);
+unitDef-&gt;upright = sAICallback-&gt;UnitDef_isUpright(teamId, unitDefId);
+unitDef-&gt;collide = sAICallback-&gt;UnitDef_isCollide(teamId, unitDefId);
+unitDef-&gt;controlRadius = sAICallback-&gt;UnitDef_getControlRadius(teamId, unitDefId);
+unitDef-&gt;losRadius = sAICallback-&gt;UnitDef_getLosRadius(teamId, unitDefId);
+unitDef-&gt;airLosRadius = sAICallback-&gt;UnitDef_getAirLosRadius(teamId, unitDefId);
+unitDef-&gt;losHeight = sAICallback-&gt;UnitDef_getLosHeight(teamId, unitDefId);
+unitDef-&gt;radarRadius = sAICallback-&gt;UnitDef_getRadarRadius(teamId, unitDefId);
+unitDef-&gt;sonarRadius = sAICallback-&gt;UnitDef_getSonarRadius(teamId, unitDefId);
+unitDef-&gt;jammerRadius = sAICallback-&gt;UnitDef_getJammerRadius(teamId, unitDefId);
+unitDef-&gt;sonarJamRadius = sAICallback-&gt;UnitDef_getSonarJamRadius(teamId, unitDefId);
+unitDef-&gt;seismicRadius = sAICallback-&gt;UnitDef_getSeismicRadius(teamId, unitDefId);
+unitDef-&gt;seismicSignature = sAICallback-&gt;UnitDef_getSeismicSignature(teamId, unitDefId);
+unitDef-&gt;stealth = sAICallback-&gt;UnitDef_isStealth(teamId, unitDefId);
+unitDef-&gt;sonarStealth = sAICallback-&gt;UnitDef_isSonarStealth(teamId, unitDefId);
+unitDef-&gt;buildRange3D = sAICallback-&gt;UnitDef_isBuildRange3D(teamId, unitDefId);
+unitDef-&gt;buildDistance = sAICallback-&gt;UnitDef_getBuildDistance(teamId, unitDefId);
+unitDef-&gt;buildSpeed = sAICallback-&gt;UnitDef_getBuildSpeed(teamId, unitDefId);
+unitDef-&gt;reclaimSpeed = sAICallback-&gt;UnitDef_getReclaimSpeed(teamId, unitDefId);
+unitDef-&gt;repairSpeed = sAICallback-&gt;UnitDef_getRepairSpeed(teamId, unitDefId);
+unitDef-&gt;maxRepairSpeed = sAICallback-&gt;UnitDef_getMaxRepairSpeed(teamId, unitDefId);
+unitDef-&gt;resurrectSpeed = sAICallback-&gt;UnitDef_getResurrectSpeed(teamId, unitDefId);
+unitDef-&gt;captureSpeed = sAICallback-&gt;UnitDef_getCaptureSpeed(teamId, unitDefId);
+unitDef-&gt;terraformSpeed = sAICallback-&gt;UnitDef_getTerraformSpeed(teamId, unitDefId);
+unitDef-&gt;mass = sAICallback-&gt;UnitDef_getMass(teamId, unitDefId);
+unitDef-&gt;pushResistant = sAICallback-&gt;UnitDef_isPushResistant(teamId, unitDefId);
+unitDef-&gt;strafeToAttack = sAICallback-&gt;UnitDef_isStrafeToAttack(teamId, unitDefId);
+unitDef-&gt;minCollisionSpeed = sAICallback-&gt;UnitDef_getMinCollisionSpeed(teamId, unitDefId);
+unitDef-&gt;slideTolerance = sAICallback-&gt;UnitDef_getSlideTolerance(teamId, unitDefId);
+unitDef-&gt;maxSlope = sAICallback-&gt;UnitDef_getMaxSlope(teamId, unitDefId);
+unitDef-&gt;maxHeightDif = sAICallback-&gt;UnitDef_getMaxHeightDif(teamId, unitDefId);
+unitDef-&gt;minWaterDepth = sAICallback-&gt;UnitDef_getMinWaterDepth(teamId, unitDefId);
+unitDef-&gt;waterline = sAICallback-&gt;UnitDef_getWaterline(teamId, unitDefId);
+unitDef-&gt;maxWaterDepth = sAICallback-&gt;UnitDef_getMaxWaterDepth(teamId, unitDefId);
+unitDef-&gt;armoredMultiple = sAICallback-&gt;UnitDef_getArmoredMultiple(teamId, unitDefId);
+unitDef-&gt;armorType = sAICallback-&gt;UnitDef_getArmorType(teamId, unitDefId);
+unitDef-&gt;flankingBonusMode = sAICallback-&gt;UnitDef_getFlankingBonusMode(teamId, unitDefId);
+unitDef-&gt;flankingBonusDir = float3(sAICallback-&gt;UnitDef_getFlankingBonusDir(teamId, unitDefId));
+unitDef-&gt;flankingBonusMax = sAICallback-&gt;UnitDef_getFlankingBonusMax(teamId, unitDefId);
+unitDef-&gt;flankingBonusMin = sAICallback-&gt;UnitDef_getFlankingBonusMin(teamId, unitDefId);
+unitDef-&gt;flankingBonusMobilityAdd = sAICallback-&gt;UnitDef_getFlankingBonusMobilityAdd(teamId, unitDefId);
+unitDef-&gt;collisionVolumeType = sAICallback-&gt;UnitDef_getCollisionVolumeType(teamId, unitDefId);
+unitDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;UnitDef_getCollisionVolumeScales(teamId, unitDefId));
+unitDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;UnitDef_getCollisionVolumeOffsets(teamId, unitDefId));
+unitDef-&gt;collisionVolumeTest = sAICallback-&gt;UnitDef_getCollisionVolumeTest(teamId, unitDefId);
+unitDef-&gt;maxWeaponRange = sAICallback-&gt;UnitDef_getMaxWeaponRange(teamId, unitDefId);
+unitDef-&gt;type = sAICallback-&gt;UnitDef_getType(teamId, unitDefId);
+unitDef-&gt;tooltip = sAICallback-&gt;UnitDef_getTooltip(teamId, unitDefId);
+unitDef-&gt;wreckName = sAICallback-&gt;UnitDef_getWreckName(teamId, unitDefId);
+unitDef-&gt;deathExplosion = sAICallback-&gt;UnitDef_getDeathExplosion(teamId, unitDefId);
+unitDef-&gt;selfDExplosion = sAICallback-&gt;UnitDef_getSelfDExplosion(teamId, unitDefId);
+unitDef-&gt;TEDClassString = sAICallback-&gt;UnitDef_getTedClassString(teamId, unitDefId);
+unitDef-&gt;categoryString = sAICallback-&gt;UnitDef_getCategoryString(teamId, unitDefId);
+unitDef-&gt;canSelfD = sAICallback-&gt;UnitDef_isCanSelfD(teamId, unitDefId);
+unitDef-&gt;selfDCountdown = sAICallback-&gt;UnitDef_getSelfDCountdown(teamId, unitDefId);
+unitDef-&gt;canSubmerge = sAICallback-&gt;UnitDef_isCanSubmerge(teamId, unitDefId);
+unitDef-&gt;canfly = sAICallback-&gt;UnitDef_isCanFly(teamId, unitDefId);
+unitDef-&gt;canmove = sAICallback-&gt;UnitDef_isCanMove(teamId, unitDefId);
+unitDef-&gt;canhover = sAICallback-&gt;UnitDef_isCanHover(teamId, unitDefId);
+unitDef-&gt;floater = sAICallback-&gt;UnitDef_isFloater(teamId, unitDefId);
+unitDef-&gt;builder = sAICallback-&gt;UnitDef_isBuilder(teamId, unitDefId);
+unitDef-&gt;activateWhenBuilt = sAICallback-&gt;UnitDef_isActivateWhenBuilt(teamId, unitDefId);
+unitDef-&gt;onoffable = sAICallback-&gt;UnitDef_isOnOffable(teamId, unitDefId);
+unitDef-&gt;fullHealthFactory = sAICallback-&gt;UnitDef_isFullHealthFactory(teamId, unitDefId);
+unitDef-&gt;factoryHeadingTakeoff = sAICallback-&gt;UnitDef_isFactoryHeadingTakeoff(teamId, unitDefId);
+unitDef-&gt;reclaimable = sAICallback-&gt;UnitDef_isReclaimable(teamId, unitDefId);
+unitDef-&gt;capturable = sAICallback-&gt;UnitDef_isCapturable(teamId, unitDefId);
+unitDef-&gt;canRestore = sAICallback-&gt;UnitDef_isCanRestore(teamId, unitDefId);
+unitDef-&gt;canRepair = sAICallback-&gt;UnitDef_isCanRepair(teamId, unitDefId);
+unitDef-&gt;canSelfRepair = sAICallback-&gt;UnitDef_isCanSelfRepair(teamId, unitDefId);
+unitDef-&gt;canReclaim = sAICallback-&gt;UnitDef_isCanReclaim(teamId, unitDefId);
+unitDef-&gt;canAttack = sAICallback-&gt;UnitDef_isCanAttack(teamId, unitDefId);
+unitDef-&gt;canPatrol = sAICallback-&gt;UnitDef_isCanPatrol(teamId, unitDefId);
+unitDef-&gt;canFight = sAICallback-&gt;UnitDef_isCanFight(teamId, unitDefId);
+unitDef-&gt;canGuard = sAICallback-&gt;UnitDef_isCanGuard(teamId, unitDefId);
+unitDef-&gt;canBuild = sAICallback-&gt;UnitDef_isCanBuild(teamId, unitDefId);
+unitDef-&gt;canAssist = sAICallback-&gt;UnitDef_isCanAssist(teamId, unitDefId);
+unitDef-&gt;canBeAssisted = sAICallback-&gt;UnitDef_isCanBeAssisted(teamId, unitDefId);
+unitDef-&gt;canRepeat = sAICallback-&gt;UnitDef_isCanRepeat(teamId, unitDefId);
+unitDef-&gt;canFireControl = sAICallback-&gt;UnitDef_isCanFireControl(teamId, unitDefId);
+unitDef-&gt;fireState = sAICallback-&gt;UnitDef_getFireState(teamId, unitDefId);
+unitDef-&gt;moveState = sAICallback-&gt;UnitDef_getMoveState(teamId, unitDefId);
+unitDef-&gt;wingDrag = sAICallback-&gt;UnitDef_getWingDrag(teamId, unitDefId);
+unitDef-&gt;wingAngle = sAICallback-&gt;UnitDef_getWingAngle(teamId, unitDefId);
+unitDef-&gt;drag = sAICallback-&gt;UnitDef_getDrag(teamId, unitDefId);
+unitDef-&gt;frontToSpeed = sAICallback-&gt;UnitDef_getFrontToSpeed(teamId, unitDefId);
+unitDef-&gt;speedToFront = sAICallback-&gt;UnitDef_getSpeedToFront(teamId, unitDefId);
+unitDef-&gt;myGravity = sAICallback-&gt;UnitDef_getMyGravity(teamId, unitDefId);
+unitDef-&gt;maxBank = sAICallback-&gt;UnitDef_getMaxBank(teamId, unitDefId);
+unitDef-&gt;maxPitch = sAICallback-&gt;UnitDef_getMaxPitch(teamId, unitDefId);
+unitDef-&gt;turnRadius = sAICallback-&gt;UnitDef_getTurnRadius(teamId, unitDefId);
+unitDef-&gt;wantedHeight = sAICallback-&gt;UnitDef_getWantedHeight(teamId, unitDefId);
+unitDef-&gt;verticalSpeed = sAICallback-&gt;UnitDef_getVerticalSpeed(teamId, unitDefId);
+unitDef-&gt;canCrash = sAICallback-&gt;UnitDef_isCanCrash(teamId, unitDefId);
+unitDef-&gt;hoverAttack = sAICallback-&gt;UnitDef_isHoverAttack(teamId, unitDefId);
+unitDef-&gt;airStrafe = sAICallback-&gt;UnitDef_isAirStrafe(teamId, unitDefId);
+unitDef-&gt;dlHoverFactor = sAICallback-&gt;UnitDef_getDlHoverFactor(teamId, unitDefId);
+unitDef-&gt;maxAcc = sAICallback-&gt;UnitDef_getMaxAcceleration(teamId, unitDefId);
+unitDef-&gt;maxDec = sAICallback-&gt;UnitDef_getMaxDeceleration(teamId, unitDefId);
+unitDef-&gt;maxAileron = sAICallback-&gt;UnitDef_getMaxAileron(teamId, unitDefId);
+unitDef-&gt;maxElevator = sAICallback-&gt;UnitDef_getMaxElevator(teamId, unitDefId);
+unitDef-&gt;maxRudder = sAICallback-&gt;UnitDef_getMaxRudder(teamId, unitDefId);
+//unitDef-&gt;yardmaps = sAICallback-&gt;UnitDef_getYardMaps(teamId, unitDefId);
+unitDef-&gt;xsize = sAICallback-&gt;UnitDef_getXSize(teamId, unitDefId);
+unitDef-&gt;ysize = sAICallback-&gt;UnitDef_getYSize(teamId, unitDefId);
+unitDef-&gt;buildangle = sAICallback-&gt;UnitDef_getBuildAngle(teamId, unitDefId);
+unitDef-&gt;loadingRadius = sAICallback-&gt;UnitDef_getLoadingRadius(teamId, unitDefId);
+unitDef-&gt;unloadSpread = sAICallback-&gt;UnitDef_getUnloadSpread(teamId, unitDefId);
+unitDef-&gt;transportCapacity = sAICallback-&gt;UnitDef_getTransportCapacity(teamId, unitDefId);
+unitDef-&gt;transportSize = sAICallback-&gt;UnitDef_getTransportSize(teamId, unitDefId);
+unitDef-&gt;minTransportSize = sAICallback-&gt;UnitDef_getMinTransportSize(teamId, unitDefId);
+unitDef-&gt;isAirBase = sAICallback-&gt;UnitDef_isAirBase(teamId, unitDefId);
+unitDef-&gt;transportMass = sAICallback-&gt;UnitDef_getTransportMass(teamId, unitDefId);
+unitDef-&gt;minTransportMass = sAICallback-&gt;UnitDef_getMinTransportMass(teamId, unitDefId);
+unitDef-&gt;holdSteady = sAICallback-&gt;UnitDef_isHoldSteady(teamId, unitDefId);
+unitDef-&gt;releaseHeld = sAICallback-&gt;UnitDef_isReleaseHeld(teamId, unitDefId);
+unitDef-&gt;cantBeTransported = sAICallback-&gt;UnitDef_isCantBeTransported(teamId, unitDefId);
+unitDef-&gt;transportByEnemy = sAICallback-&gt;UnitDef_isTransportByEnemy(teamId, unitDefId);
+unitDef-&gt;transportUnloadMethod = sAICallback-&gt;UnitDef_getTransportUnloadMethod(teamId, unitDefId);
+unitDef-&gt;fallSpeed = sAICallback-&gt;UnitDef_getFallSpeed(teamId, unitDefId);
+unitDef-&gt;unitFallSpeed = sAICallback-&gt;UnitDef_getUnitFallSpeed(teamId, unitDefId);
+unitDef-&gt;canCloak = sAICallback-&gt;UnitDef_isCanCloak(teamId, unitDefId);
+unitDef-&gt;startCloaked = sAICallback-&gt;UnitDef_isStartCloaked(teamId, unitDefId);
+unitDef-&gt;cloakCost = sAICallback-&gt;UnitDef_getCloakCost(teamId, unitDefId);
+unitDef-&gt;cloakCostMoving = sAICallback-&gt;UnitDef_getCloakCostMoving(teamId, unitDefId);
+unitDef-&gt;decloakDistance = sAICallback-&gt;UnitDef_getDecloakDistance(teamId, unitDefId);
+unitDef-&gt;decloakSpherical = sAICallback-&gt;UnitDef_isDecloakSpherical(teamId, unitDefId);
+unitDef-&gt;decloakOnFire = sAICallback-&gt;UnitDef_isDecloakOnFire(teamId, unitDefId);
+unitDef-&gt;canKamikaze = sAICallback-&gt;UnitDef_isCanKamikaze(teamId, unitDefId);
+unitDef-&gt;kamikazeDist = sAICallback-&gt;UnitDef_getKamikazeDist(teamId, unitDefId);
+unitDef-&gt;targfac = sAICallback-&gt;UnitDef_isTargetingFacility(teamId, unitDefId);
+unitDef-&gt;canDGun = sAICallback-&gt;UnitDef_isCanDGun(teamId, unitDefId);
+unitDef-&gt;needGeo = sAICallback-&gt;UnitDef_isNeedGeo(teamId, unitDefId);
+unitDef-&gt;isFeature = sAICallback-&gt;UnitDef_isFeature(teamId, unitDefId);
+unitDef-&gt;hideDamage = sAICallback-&gt;UnitDef_isHideDamage(teamId, unitDefId);
+unitDef-&gt;isCommander = sAICallback-&gt;UnitDef_isCommander(teamId, unitDefId);
+unitDef-&gt;showPlayerName = sAICallback-&gt;UnitDef_isShowPlayerName(teamId, unitDefId);
+unitDef-&gt;canResurrect = sAICallback-&gt;UnitDef_isCanResurrect(teamId, unitDefId);
+unitDef-&gt;canCapture = sAICallback-&gt;UnitDef_isCanCapture(teamId, unitDefId);
+unitDef-&gt;highTrajectoryType = sAICallback-&gt;UnitDef_getHighTrajectoryType(teamId, unitDefId);
+unitDef-&gt;noChaseCategory = sAICallback-&gt;UnitDef_getNoChaseCategory(teamId, unitDefId);
+unitDef-&gt;leaveTracks = sAICallback-&gt;UnitDef_isLeaveTracks(teamId, unitDefId);
+unitDef-&gt;trackWidth = sAICallback-&gt;UnitDef_getTrackWidth(teamId, unitDefId);
+unitDef-&gt;trackOffset = sAICallback-&gt;UnitDef_getTrackOffset(teamId, unitDefId);
+unitDef-&gt;trackStrength = sAICallback-&gt;UnitDef_getTrackStrength(teamId, unitDefId);
+unitDef-&gt;trackStretch = sAICallback-&gt;UnitDef_getTrackStretch(teamId, unitDefId);
+unitDef-&gt;trackType = sAICallback-&gt;UnitDef_getTrackType(teamId, unitDefId);
+unitDef-&gt;canDropFlare = sAICallback-&gt;UnitDef_isCanDropFlare(teamId, unitDefId);
+unitDef-&gt;flareReloadTime = sAICallback-&gt;UnitDef_getFlareReloadTime(teamId, unitDefId);
+unitDef-&gt;flareEfficiency = sAICallback-&gt;UnitDef_getFlareEfficiency(teamId, unitDefId);
+unitDef-&gt;flareDelay = sAICallback-&gt;UnitDef_getFlareDelay(teamId, unitDefId);
+unitDef-&gt;flareDropVector = float3(sAICallback-&gt;UnitDef_getFlareDropVector(teamId, unitDefId));
+unitDef-&gt;flareTime = sAICallback-&gt;UnitDef_getFlareTime(teamId, unitDefId);
+unitDef-&gt;flareSalvoSize = sAICallback-&gt;UnitDef_getFlareSalvoSize(teamId, unitDefId);
+unitDef-&gt;flareSalvoDelay = sAICallback-&gt;UnitDef_getFlareSalvoDelay(teamId, unitDefId);
+unitDef-&gt;smoothAnim = sAICallback-&gt;UnitDef_isSmoothAnim(teamId, unitDefId);
+unitDef-&gt;isMetalMaker = sAICallback-&gt;UnitDef_isMetalMaker(teamId, unitDefId);
+unitDef-&gt;canLoopbackAttack = sAICallback-&gt;UnitDef_isCanLoopbackAttack(teamId, unitDefId);
+unitDef-&gt;levelGround = sAICallback-&gt;UnitDef_isLevelGround(teamId, unitDefId);
+unitDef-&gt;useBuildingGroundDecal = sAICallback-&gt;UnitDef_isUseBuildingGroundDecal(teamId, unitDefId);
+unitDef-&gt;buildingDecalType = sAICallback-&gt;UnitDef_getBuildingDecalType(teamId, unitDefId);
+unitDef-&gt;buildingDecalSizeX = sAICallback-&gt;UnitDef_getBuildingDecalSizeX(teamId, unitDefId);
+unitDef-&gt;buildingDecalSizeY = sAICallback-&gt;UnitDef_getBuildingDecalSizeY(teamId, unitDefId);
+unitDef-&gt;buildingDecalDecaySpeed = sAICallback-&gt;UnitDef_getBuildingDecalDecaySpeed(teamId, unitDefId);
+unitDef-&gt;isFirePlatform = sAICallback-&gt;UnitDef_isFirePlatform(teamId, unitDefId);
+unitDef-&gt;maxFuel = sAICallback-&gt;UnitDef_getMaxFuel(teamId, unitDefId);
+unitDef-&gt;refuelTime = sAICallback-&gt;UnitDef_getRefuelTime(teamId, unitDefId);
+unitDef-&gt;minAirBasePower = sAICallback-&gt;UnitDef_getMinAirBasePower(teamId, unitDefId);
+unitDef-&gt;maxThisUnit = sAICallback-&gt;UnitDef_getMaxThisUnit(teamId, unitDefId);
+//unitDef-&gt;decoyDef = sAICallback-&gt;UnitDef_getDecoyDefId(teamId, unitDefId);
+unitDef-&gt;shieldWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getShieldWeaponDefId(teamId, unitDefId));
+unitDef-&gt;stockpileWeaponDef = this-&gt;GetWeaponDefById(sAICallback-&gt;UnitDef_getStockpileWeaponDefId(teamId, unitDefId));
+{
+	int numBo = sAICallback-&gt;UnitDef_getNumBuildOptions(teamId, unitDefId);
+	int* bo = new int[numBo];
+	sAICallback-&gt;UnitDef_getBuildOptions(teamId, unitDefId, bo);
+	for (int b=0; b &lt; numBo; b++) {
+		unitDef-&gt;buildOptions[b] = sAICallback-&gt;UnitDef_getName(teamId, bo[b]);
+	}
+	delete [] bo;
+}
+{
+	int size = sAICallback-&gt;UnitDef_getNumCustomParams(teamId, unitDefId);
+	const char* cKeys[size];
+	const char* cValues[size];
+	sAICallback-&gt;UnitDef_getCustomParamKeys(teamId, unitDefId, cKeys);
+	sAICallback-&gt;UnitDef_getCustomParamValues(teamId, unitDefId, cValues);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+		unitDef-&gt;customParams[cKeys[i]] = cValues[i];
+	}
+}
+if (sAICallback-&gt;UnitDef_hasMoveData(teamId, unitDefId)) {
+	unitDef-&gt;movedata = new MoveData(NULL, -1);
+		unitDef-&gt;movedata-&gt;moveType = (enum MoveData::MoveType)sAICallback-&gt;UnitDef_MoveData_getMoveType(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;moveFamily = (enum MoveData::MoveFamily) sAICallback-&gt;UnitDef_MoveData_getMoveFamily(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;size = sAICallback-&gt;UnitDef_MoveData_getSize(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;depth = sAICallback-&gt;UnitDef_MoveData_getDepth(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxSlope = sAICallback-&gt;UnitDef_MoveData_getMaxSlope(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;slopeMod = sAICallback-&gt;UnitDef_MoveData_getSlopeMod(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;depthMod = sAICallback-&gt;UnitDef_MoveData_getDepthMod(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;pathType = sAICallback-&gt;UnitDef_MoveData_getPathType(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;crushStrength = sAICallback-&gt;UnitDef_MoveData_getCrushStrength(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxSpeed = sAICallback-&gt;UnitDef_MoveData_getMaxSpeed(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxTurnRate = sAICallback-&gt;UnitDef_MoveData_getMaxTurnRate(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxAcceleration = sAICallback-&gt;UnitDef_MoveData_getMaxAcceleration(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;maxBreaking = sAICallback-&gt;UnitDef_MoveData_getMaxBreaking(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;subMarine = sAICallback-&gt;UnitDef_MoveData_isSubMarine(teamId, unitDefId);
+	} else {
+		unitDef-&gt;movedata = NULL;
+	}
+int numWeapons = sAICallback-&gt;UnitDef_getNumUnitDefWeapons(teamId, unitDefId);
+for (int w=0; w &lt; numWeapons; ++w) {
+	unitDef-&gt;weapons.push_back(UnitDef::UnitDefWeapon());
+	unitDef-&gt;weapons[w].name = sAICallback-&gt;UnitDef_UnitDefWeapon_getName(teamId, unitDefId, w);
+	int weaponDefId = sAICallback-&gt;UnitDef_UnitDefWeapon_getWeaponDefId(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].def = this-&gt;GetWeaponDefById(weaponDefId);
+	unitDef-&gt;weapons[w].slavedTo = sAICallback-&gt;UnitDef_UnitDefWeapon_getSlavedTo(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].mainDir = float3(sAICallback-&gt;UnitDef_UnitDefWeapon_getMainDir(teamId, unitDefId, w));
+	unitDef-&gt;weapons[w].maxAngleDif = sAICallback-&gt;UnitDef_UnitDefWeapon_getMaxAngleDif(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].fuelUsage = sAICallback-&gt;UnitDef_UnitDefWeapon_getFuelUsage(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].badTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getBadTargetCat(teamId, unitDefId, w);
+	unitDef-&gt;weapons[w].onlyTargetCat = sAICallback-&gt;UnitDef_UnitDefWeapon_getOnlyTargetCat(teamId, unitDefId, w);
+}
+	if (unitDefs[unitDefId] != NULL) {
+		delete unitDefs[unitDefId];
+	}
+		unitDefs[unitDefId] = unitDef;
+		unitDefFrames[unitDefId] = currentFrame;
+	}
+
+	return unitDefs[unitDefId];
+}
+
+int CAIAICallback::GetEnemyUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getEnemies(teamId, unitIds);
+}
+
+int CAIAICallback::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getEnemiesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetEnemyUnitsInRadarAndLos(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getEnemiesInRadarAndLos(teamId, unitIds);
+}
+
+int CAIAICallback::GetFriendlyUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getFriendlies(teamId, unitIds);
+}
+
+int CAIAICallback::GetFriendlyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getFriendliesIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetNeutralUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getNeutrals(teamId, unitIds);
+}
+
+int CAIAICallback::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Unit_STATIC_getNeutralsIn(teamId, unitIds, pos.toSAIFloat3(), radius);
+}
+
+int CAIAICallback::GetMapWidth() {
+	return sAICallback-&gt;Map_getWidth(teamId);
+}
+
+int CAIAICallback::GetMapHeight() {
+	return sAICallback-&gt;Map_getHeight(teamId);
+}
+
+const float* CAIAICallback::GetHeightMap() {
+	return sAICallback-&gt;Map_getHeightMap(teamId);
+}
+
+float CAIAICallback::GetMinHeight() {
+	return sAICallback-&gt;Map_getMinHeight(teamId);
+}
+
+float CAIAICallback::GetMaxHeight() {
+	return sAICallback-&gt;Map_getMaxHeight(teamId);
+}
+
+const float* CAIAICallback::GetSlopeMap() {
+	return sAICallback-&gt;Map_getSlopeMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetLosMap() {
+	return sAICallback-&gt;Map_getLosMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetRadarMap() {
+	return sAICallback-&gt;Map_getRadarMap(teamId);
+}
+
+const unsigned short* CAIAICallback::GetJammerMap() {
+	return sAICallback-&gt;Map_getJammerMap(teamId);
+}
+
+const unsigned char* CAIAICallback::GetMetalMap() {
+	return sAICallback-&gt;Map_getMetalMap(teamId);
+}
+
+const char* CAIAICallback::GetMapName() {
+	return sAICallback-&gt;Map_getName(teamId);
+}
+
+const char* CAIAICallback::GetModName() {
+	return sAICallback-&gt;Mod_getName(teamId);
+}
+
+float CAIAICallback::GetElevation(float x, float z) {
+	return sAICallback-&gt;Map_getElevationAt(teamId, x, z);
+}
+
+float CAIAICallback::GetMaxMetal() {
+	return sAICallback-&gt;Map_getMaxMetal(teamId);
+}
+
+float CAIAICallback::GetExtractorRadius() {
+	return sAICallback-&gt;Map_getExtractorRadius(teamId);
+}
+
+float CAIAICallback::GetMinWind() {
+	return sAICallback-&gt;Map_getMinWind(teamId);
+}
+
+float CAIAICallback::GetMaxWind() {
+	return sAICallback-&gt;Map_getMaxWind(teamId);
+}
+
+float CAIAICallback::GetTidalStrength() {
+	return sAICallback-&gt;Map_getTidalStrength(teamId);
+}
+
+float CAIAICallback::GetGravity() {
+	return sAICallback-&gt;Map_getGravity(teamId);
+}
+
+bool CAIAICallback::CanBuildAt(const UnitDef* unitDef, float3 pos, int facing) {
+	return sAICallback-&gt;Map_canBuildAt(teamId, unitDef-&gt;id, pos.toSAIFloat3(), facing);
+}
+
+float3 CAIAICallback::ClosestBuildSite(const UnitDef* unitDef, float3 pos, float searchRadius, int minDist, int facing) {
+	return float3(sAICallback-&gt;Map_findClosestBuildSite(teamId, unitDef-&gt;id, pos.toSAIFloat3(), searchRadius, minDist, facing));
+}
+
+/*
+bool CAIAICallback::GetProperty(int id, int property, void* dst) {
+//	return sAICallback-&gt;getProperty(teamId, id, property, dst);
+	return false;
+}
+*/
+bool CAIAICallback::GetProperty(int unitId, int propertyId, void *data)
+{
+	switch (propertyId) {
+		case AIVAL_UNITDEF: {
+			return false;
+		}
+		case AIVAL_CURRENT_FUEL: {
+			(*(float*)data) = sAICallback-&gt;Unit_getCurrentFuel(teamId, unitId);
+			return (*(float*)data) != -1.0f;
+		}
+		case AIVAL_STOCKPILED: {
+			(*(int*)data) = sAICallback-&gt;Unit_getStockpile(teamId, unitId);
+			return (*(int*)data) != -1;
+		}
+		case AIVAL_STOCKPILE_QUED: {
+			(*(int*)data) = sAICallback-&gt;Unit_getStockpileQueued(teamId, unitId);
+			return (*(int*)data) != -1;
+		}
+		case AIVAL_UNIT_MAXSPEED: {
+			(*(float*) data) = sAICallback-&gt;Unit_getMaxSpeed(teamId, unitId);
+			return (*(float*)data) != -1.0f;
+		}
+		default:
+			return false;
+	}
+	return false;
+}
+
+/*
+bool CAIAICallback::GetValue(int valueId, void* dst) {
+//	return sAICallback-&gt;getValue(teamId, valueId, dst);
+	return false;
+}
+*/
+bool CAIAICallback::GetValue(int valueId, void *data)
+{
+	switch (valueId) {
+		case AIVAL_NUMDAMAGETYPES:{
+			*((int*)data) = sAICallback-&gt;WeaponDef_STATIC_getNumDamageTypes(teamId);
+			return true;
+		}case AIVAL_EXCEPTION_HANDLING:{
+			*(bool*)data = sAICallback-&gt;Game_isExceptionHandlingEnabled(teamId);
+			return true;
+		}case AIVAL_MAP_CHECKSUM:{
+			*(unsigned int*)data = sAICallback-&gt;Map_getChecksum(teamId);
+			return true;
+		}case AIVAL_DEBUG_MODE:{
+			*(bool*)data = sAICallback-&gt;Game_isDebugModeEnabled(teamId);
+			return true;
+		}case AIVAL_GAME_MODE:{
+			*(int*)data = sAICallback-&gt;Game_getMode(teamId);
+			return true;
+		}case AIVAL_GAME_PAUSED:{
+			*(bool*)data = sAICallback-&gt;Game_isPaused(teamId);
+			return true;
+		}case AIVAL_GAME_SPEED_FACTOR:{
+			*(float*)data = sAICallback-&gt;Game_getSpeedFactor(teamId);
+			return true;
+		}case AIVAL_GUI_VIEW_RANGE:{
+			*(float*)data = sAICallback-&gt;Gui_getViewRange(teamId);
+			return true;
+		}case AIVAL_GUI_SCREENX:{
+			*(float*)data = sAICallback-&gt;Gui_getScreenX(teamId);
+			return true;
+		}case AIVAL_GUI_SCREENY:{
+			*(float*)data = sAICallback-&gt;Gui_getScreenY(teamId);
+			return true;
+		}case AIVAL_GUI_CAMERA_DIR:{
+			*(float3*)data = sAICallback-&gt;Gui_Camera_getDirection(teamId);
+			return true;
+		}case AIVAL_GUI_CAMERA_POS:{
+			*(float3*)data = sAICallback-&gt;Gui_Camera_getPosition(teamId);
+			return true;
+		}case AIVAL_LOCATE_FILE_R:{
+			sAICallback-&gt;File_locateForReading(teamId, (char*) data);
+			return true;
+		}case AIVAL_LOCATE_FILE_W:{
+			sAICallback-&gt;File_locateForWriting(teamId, (char*) data);
+			return true;
+		}
+		case AIVAL_UNIT_LIMIT: {
+			*(int*) data = sAICallback-&gt;Unit_STATIC_getLimit(teamId);
+			return true;
+		}
+		case AIVAL_SCRIPT: {
+			*(const char**) data = sAICallback-&gt;Game_getSetupScript(teamId);
+			return true;
+		}
+		default:
+			return false;
+	}
+}
+
+int CAIAICallback::GetFileSize(const char* name) {
+	return sAICallback-&gt;File_getSize(teamId, name);
+}
+
+int CAIAICallback::GetSelectedUnits(int* unitIds) {
+	return sAICallback-&gt;Unit_STATIC_getSelected(teamId, unitIds);
+}
+
+float3 CAIAICallback::GetMousePos() {
+	return float3(sAICallback-&gt;Map_getMousePos(teamId));
+}
+
+int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
+
+	SAIFloat3* positions = new SAIFloat3[maxPoints];
+//	unsigned char** colors = new unsigned char*[maxPoints];
+	SAIFloat3* colors = new SAIFloat3[maxPoints];
+	const char** labels = new const char*[maxPoints];
+
+	int numPoints = sAICallback-&gt;Map_getPoints(teamId, positions, colors, labels, maxPoints);
+	for (int i=0; i &lt; numPoints; ++i) {
+		pm[i].pos = float3(positions[i]);
+		//pm[i].color = colors[i];
+		pm[i].color = (unsigned char*) calloc(3, sizeof(unsigned char));
+		pm[i].color[0] = (unsigned char) colors[i].x;
+		pm[i].color[1] = (unsigned char) colors[i].y;
+		pm[i].color[2] = (unsigned char) colors[i].z;
+		pm[i].label = labels[i];
+	}
+	delete [] positions;
+	delete [] colors;
+	delete [] labels;
+	return numPoints;
+}
+
+int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
+
+	SAIFloat3* firstPositions = new SAIFloat3[maxLines];
+	SAIFloat3* secondPositions = new SAIFloat3[maxLines];
+	SAIFloat3* colors = new SAIFloat3[maxLines];
+
+	int numLines = sAICallback-&gt;Map_getLines(teamId, firstPositions, secondPositions, colors, maxLines);
+	for (int i=0; i &lt; numLines; ++i) {
+		lm[i].pos = float3(firstPositions[i]);
+		lm[i].pos2 = float3(secondPositions[i]);
+		lm[i].color = (unsigned char*) calloc(3, sizeof(unsigned char));
+		lm[i].color[0] = (unsigned char) colors[i].x;
+		lm[i].color[1] = (unsigned char) colors[i].y;
+		lm[i].color[2] = (unsigned char) colors[i].z;
+	}
+	delete [] firstPositions;
+	delete [] secondPositions;
+	delete [] colors;
+	return numLines;
+}
+
+float CAIAICallback::GetMetal() {
+	return sAICallback-&gt;ResourceInfo_Metal_getCurrent(teamId);
+}
+
+float CAIAICallback::GetMetalIncome() {
+	return sAICallback-&gt;ResourceInfo_Metal_getIncome(teamId);
+}
+
+float CAIAICallback::GetMetalUsage() {
+	return sAICallback-&gt;ResourceInfo_Metal_getUsage(teamId);
+}
+
+float CAIAICallback::GetMetalStorage() {
+	return sAICallback-&gt;ResourceInfo_Metal_getStorage(teamId);
+}
+
+float CAIAICallback::GetEnergy() {
+	return sAICallback-&gt;ResourceInfo_Energy_getCurrent(teamId);
+}
+
+float CAIAICallback::GetEnergyIncome() {
+	return sAICallback-&gt;ResourceInfo_Energy_getIncome(teamId);
+}
+
+float CAIAICallback::GetEnergyUsage() {
+	return sAICallback-&gt;ResourceInfo_Energy_getUsage(teamId);
+}
+
+float CAIAICallback::GetEnergyStorage() {
+	return sAICallback-&gt;ResourceInfo_Energy_getStorage(teamId);
+}
+
+int CAIAICallback::GetFeatures(int *featureIds, int max) {
+	return sAICallback-&gt;Feature_STATIC_getIds(teamId, featureIds, max);
+}
+
+int CAIAICallback::GetFeatures(int *featureIds, int max, const float3&amp; pos, float radius) {
+	return sAICallback-&gt;Feature_STATIC_getIdsIn(teamId, featureIds, max, pos.toSAIFloat3(), radius);
+}
+
+const FeatureDef* CAIAICallback::GetFeatureDef(int featureId) {
+	int featureDefId = sAICallback-&gt;Feature_getDefId(teamId, featureId);
+	return this-&gt;GetFeatureDefById(featureDefId);
+}
+
+const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
+
+	if (featureDefId &lt; 0) {
+		return NULL;
+	}
+
+	bool doRecreate = featureDefFrames[featureDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+	FeatureDef* featureDef = new FeatureDef();
+featureDef-&gt;myName = sAICallback-&gt;FeatureDef_getName(teamId, featureDefId);
+featureDef-&gt;description = sAICallback-&gt;FeatureDef_getDescription(teamId, featureDefId);
+featureDef-&gt;filename = sAICallback-&gt;FeatureDef_getFilename(teamId, featureDefId);
+featureDef-&gt;id = sAICallback-&gt;FeatureDef_getId(teamId, featureDefId);
+featureDef-&gt;metal = sAICallback-&gt;FeatureDef_getMetal(teamId, featureDefId);
+featureDef-&gt;energy = sAICallback-&gt;FeatureDef_getEnergy(teamId, featureDefId);
+featureDef-&gt;maxHealth = sAICallback-&gt;FeatureDef_getMaxHealth(teamId, featureDefId);
+featureDef-&gt;reclaimTime = sAICallback-&gt;FeatureDef_getReclaimTime(teamId, featureDefId);
+featureDef-&gt;mass = sAICallback-&gt;FeatureDef_getMass(teamId, featureDefId);
+featureDef-&gt;collisionVolumeType = sAICallback-&gt;FeatureDef_getCollisionVolumeType(teamId, featureDefId);	
+featureDef-&gt;collisionVolumeScales = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeScales(teamId, featureDefId));		
+featureDef-&gt;collisionVolumeOffsets = float3(sAICallback-&gt;FeatureDef_getCollisionVolumeOffsets(teamId, featureDefId));		
+featureDef-&gt;collisionVolumeTest = sAICallback-&gt;FeatureDef_getCollisionVolumeTest(teamId, featureDefId);			
+featureDef-&gt;upright = sAICallback-&gt;FeatureDef_isUpright(teamId, featureDefId);
+featureDef-&gt;drawType = sAICallback-&gt;FeatureDef_getDrawType(teamId, featureDefId);
+featureDef-&gt;modelname = sAICallback-&gt;FeatureDef_getModelName(teamId, featureDefId);
+featureDef-&gt;modelType = sAICallback-&gt;FeatureDef_getModelType(teamId, featureDefId);
+featureDef-&gt;resurrectable = sAICallback-&gt;FeatureDef_getResurrectable(teamId, featureDefId);
+featureDef-&gt;smokeTime = sAICallback-&gt;FeatureDef_getSmokeTime(teamId, featureDefId);
+featureDef-&gt;destructable = sAICallback-&gt;FeatureDef_isDestructable(teamId, featureDefId);
+featureDef-&gt;reclaimable = sAICallback-&gt;FeatureDef_isReclaimable(teamId, featureDefId);
+featureDef-&gt;blocking = sAICallback-&gt;FeatureDef_isBlocking(teamId, featureDefId);
+featureDef-&gt;burnable = sAICallback-&gt;FeatureDef_isBurnable(teamId, featureDefId);
+featureDef-&gt;floating = sAICallback-&gt;FeatureDef_isFloating(teamId, featureDefId);
+featureDef-&gt;noSelect = sAICallback-&gt;FeatureDef_isNoSelect(teamId, featureDefId);
+featureDef-&gt;geoThermal = sAICallback-&gt;FeatureDef_isGeoThermal(teamId, featureDefId);
+featureDef-&gt;deathFeature = sAICallback-&gt;FeatureDef_getDeathFeature(teamId, featureDefId);
+featureDef-&gt;xsize = sAICallback-&gt;FeatureDef_getXsize(teamId, featureDefId);
+featureDef-&gt;ysize = sAICallback-&gt;FeatureDef_getYsize(teamId, featureDefId);
+{
+	int size = sAICallback-&gt;FeatureDef_getNumCustomParams(teamId, featureDefId);
+	featureDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+	const char* cKeys[size];
+	const char* cValues[size];
+	sAICallback-&gt;FeatureDef_getCustomParamKeys(teamId, featureDefId, cKeys);
+	sAICallback-&gt;FeatureDef_getCustomParamValues(teamId, featureDefId, cValues);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+		featureDef-&gt;customParams[cKeys[i]] = cValues[i];
+	}
+}
+	if (featureDefs[featureDefId] != NULL) {
+		delete featureDefs[featureDefId];
+	}
+		featureDefs[featureDefId] = featureDef;
+		featureDefFrames[featureDefId] = currentFrame;
+	}
+
+	return featureDefs[featureDefId];
+}
+
+float CAIAICallback::GetFeatureHealth(int featureId) {
+	return sAICallback-&gt;Feature_getHealth(teamId, featureId);
+}
+
+float CAIAICallback::GetFeatureReclaimLeft(int featureId) {
+	return sAICallback-&gt;Feature_getReclaimLeft(teamId, featureId);
+}
+
+float3 CAIAICallback::GetFeaturePos(int featureId) {
+	return float3(sAICallback-&gt;Feature_getPos(teamId, featureId));
+}
+
+int CAIAICallback::GetNumUnitDefs() {
+	return sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
+}
+
+void CAIAICallback::GetUnitDefList(const UnitDef** list) {
+	int numUnitDefs = sAICallback-&gt;UnitDef_STATIC_getNumIds(teamId);
+	int* unitDefIds = new int[numUnitDefs];
+	sAICallback-&gt;UnitDef_STATIC_getIds(teamId, unitDefIds);
+	for (int i=0; i &lt; numUnitDefs; ++i) {
+		list[i] = this-&gt;GetUnitDefById(unitDefIds[i]);
+	}
+}
+
+float CAIAICallback::GetUnitDefHeight(int def) {
+	return sAICallback-&gt;UnitDef_getHeight(teamId, def);
+}
+
+float CAIAICallback::GetUnitDefRadius(int def) {
+	return sAICallback-&gt;UnitDef_getRadius(teamId, def);
+}
+
+const WeaponDef* CAIAICallback::GetWeapon(const char* weaponName) {
+	int weaponDefId = sAICallback-&gt;WeaponDef_STATIC_getIdByName(teamId, weaponName);
+	return this-&gt;GetWeaponDefById(weaponDefId);
+}
+
+const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
+
+//	logT(&quot;entering: GetWeaponDefById sAICallback&quot;);
+	if (weaponDefId &lt; 0) {
+		return NULL;
+	}
+
+	bool doRecreate = weaponDefFrames[weaponDefId] &lt; 0;
+	if (doRecreate) {
+//		int currentFrame = this-&gt;GetCurrentFrame();
+		int currentFrame = 1;
+//weaponDef-&gt;damages = sAICallback-&gt;WeaponDef_getDamages(teamId, weaponDefId);
+//{
+int numTypes = sAICallback-&gt;WeaponDef_Damages_getNumTypes(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 1&quot;);
+//float* typeDamages = new float[numTypes];
+float typeDamages[numTypes];
+sAICallback-&gt;WeaponDef_Damages_getTypeDamages(teamId, weaponDefId, typeDamages);
+//	logT(&quot;GetWeaponDefById 2&quot;);
+//for(int i=0; i &lt; numTypes; ++i) {
+//	typeDamages[i] = sAICallback-&gt;WeaponDef_Damages_getType(teamId, weaponDefId, i);
+//}
+DamageArray da(numTypes, typeDamages);
+//	logT(&quot;GetWeaponDefById 3&quot;);
+//AIDamageArray tmpDa(numTypes, typeDamages);
+//AIDamageArray tmpDa;
+//weaponDef-&gt;damages = *(reinterpret_cast&lt;DamageArray*&gt;(&amp;tmpDa));
+//tmpDa.numTypes = numTypes;
+//tmpDa.damages = typeDamages;
+//delete tmpDa;
+//da.SetTypes(numTypes, typeDamages);
+//delete [] typeDamages;
+da.paralyzeDamageTime = sAICallback-&gt;WeaponDef_Damages_getParalyzeDamageTime(teamId, weaponDefId);
+da.impulseFactor = sAICallback-&gt;WeaponDef_Damages_getImpulseFactor(teamId, weaponDefId);
+da.impulseBoost = sAICallback-&gt;WeaponDef_Damages_getImpulseBoost(teamId, weaponDefId);
+da.craterMult = sAICallback-&gt;WeaponDef_Damages_getCraterMult(teamId, weaponDefId);
+da.craterBoost = sAICallback-&gt;WeaponDef_Damages_getCraterBoost(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 4&quot;);
+//}
+
+	WeaponDef* weaponDef = new WeaponDef(da);
+//	WeaponDef* weaponDef = new WeaponDef();
+//	logT(&quot;GetWeaponDefById 5&quot;);
+//	logI(&quot;GetWeaponDefById 5 defId: %d&quot;, weaponDefId);
+weaponDef-&gt;name = sAICallback-&gt;WeaponDef_getName(teamId, weaponDefId);
+weaponDef-&gt;type = sAICallback-&gt;WeaponDef_getType(teamId, weaponDefId);
+weaponDef-&gt;description = sAICallback-&gt;WeaponDef_getDescription(teamId, weaponDefId);
+weaponDef-&gt;filename = sAICallback-&gt;WeaponDef_getFilename(teamId, weaponDefId);
+weaponDef-&gt;cegTag = sAICallback-&gt;WeaponDef_getCegTag(teamId, weaponDefId);
+weaponDef-&gt;range = sAICallback-&gt;WeaponDef_getRange(teamId, weaponDefId);
+weaponDef-&gt;heightmod = sAICallback-&gt;WeaponDef_getHeightMod(teamId, weaponDefId);
+weaponDef-&gt;accuracy = sAICallback-&gt;WeaponDef_getAccuracy(teamId, weaponDefId);
+weaponDef-&gt;sprayAngle = sAICallback-&gt;WeaponDef_getSprayAngle(teamId, weaponDefId);
+weaponDef-&gt;movingAccuracy = sAICallback-&gt;WeaponDef_getMovingAccuracy(teamId, weaponDefId);
+weaponDef-&gt;targetMoveError = sAICallback-&gt;WeaponDef_getTargetMoveError(teamId, weaponDefId);
+weaponDef-&gt;leadLimit = sAICallback-&gt;WeaponDef_getLeadLimit(teamId, weaponDefId);
+weaponDef-&gt;leadBonus = sAICallback-&gt;WeaponDef_getLeadBonus(teamId, weaponDefId);
+weaponDef-&gt;predictBoost = sAICallback-&gt;WeaponDef_getPredictBoost(teamId, weaponDefId);
+weaponDef-&gt;areaOfEffect = sAICallback-&gt;WeaponDef_getAreaOfEffect(teamId, weaponDefId);
+weaponDef-&gt;noSelfDamage = sAICallback-&gt;WeaponDef_isNoSelfDamage(teamId, weaponDefId);
+weaponDef-&gt;fireStarter = sAICallback-&gt;WeaponDef_getFireStarter(teamId, weaponDefId);
+weaponDef-&gt;edgeEffectiveness = sAICallback-&gt;WeaponDef_getEdgeEffectiveness(teamId, weaponDefId);
+weaponDef-&gt;size = sAICallback-&gt;WeaponDef_getSize(teamId, weaponDefId);
+weaponDef-&gt;sizeGrowth = sAICallback-&gt;WeaponDef_getSizeGrowth(teamId, weaponDefId);
+weaponDef-&gt;collisionSize = sAICallback-&gt;WeaponDef_getCollisionSize(teamId, weaponDefId);
+weaponDef-&gt;salvosize = sAICallback-&gt;WeaponDef_getSalvoSize(teamId, weaponDefId);
+weaponDef-&gt;salvodelay = sAICallback-&gt;WeaponDef_getSalvoDelay(teamId, weaponDefId);
+weaponDef-&gt;reload = sAICallback-&gt;WeaponDef_getReload(teamId, weaponDefId);
+weaponDef-&gt;beamtime = sAICallback-&gt;WeaponDef_getBeamTime(teamId, weaponDefId);
+weaponDef-&gt;beamburst = sAICallback-&gt;WeaponDef_isBeamBurst(teamId, weaponDefId);
+weaponDef-&gt;waterBounce = sAICallback-&gt;WeaponDef_isWaterBounce(teamId, weaponDefId);
+weaponDef-&gt;groundBounce = sAICallback-&gt;WeaponDef_isGroundBounce(teamId, weaponDefId);
+weaponDef-&gt;bounceRebound = sAICallback-&gt;WeaponDef_getBounceRebound(teamId, weaponDefId);
+weaponDef-&gt;bounceSlip = sAICallback-&gt;WeaponDef_getBounceSlip(teamId, weaponDefId);
+weaponDef-&gt;numBounce = sAICallback-&gt;WeaponDef_getNumBounce(teamId, weaponDefId);
+weaponDef-&gt;maxAngle = sAICallback-&gt;WeaponDef_getMaxAngle(teamId, weaponDefId);
+weaponDef-&gt;restTime = sAICallback-&gt;WeaponDef_getRestTime(teamId, weaponDefId);
+weaponDef-&gt;uptime = sAICallback-&gt;WeaponDef_getUpTime(teamId, weaponDefId);
+weaponDef-&gt;flighttime = sAICallback-&gt;WeaponDef_getFlightTime(teamId, weaponDefId);
+weaponDef-&gt;metalcost = sAICallback-&gt;WeaponDef_getMetalCost(teamId, weaponDefId);
+weaponDef-&gt;energycost = sAICallback-&gt;WeaponDef_getEnergyCost(teamId, weaponDefId);
+weaponDef-&gt;supplycost = sAICallback-&gt;WeaponDef_getSupplyCost(teamId, weaponDefId);
+weaponDef-&gt;projectilespershot = sAICallback-&gt;WeaponDef_getProjectilesPerShot(teamId, weaponDefId);
+weaponDef-&gt;id = sAICallback-&gt;WeaponDef_getId(teamId, weaponDefId);
+weaponDef-&gt;tdfId = sAICallback-&gt;WeaponDef_getTdfId(teamId, weaponDefId);
+weaponDef-&gt;turret = sAICallback-&gt;WeaponDef_isTurret(teamId, weaponDefId);
+weaponDef-&gt;onlyForward = sAICallback-&gt;WeaponDef_isOnlyForward(teamId, weaponDefId);
+weaponDef-&gt;fixedLauncher = sAICallback-&gt;WeaponDef_isFixedLauncher(teamId, weaponDefId);
+weaponDef-&gt;waterweapon = sAICallback-&gt;WeaponDef_isWaterWeapon(teamId, weaponDefId);
+weaponDef-&gt;fireSubmersed = sAICallback-&gt;WeaponDef_isFireSubmersed(teamId, weaponDefId);
+weaponDef-&gt;submissile = sAICallback-&gt;WeaponDef_isSubMissile(teamId, weaponDefId);
+weaponDef-&gt;tracks = sAICallback-&gt;WeaponDef_isTracks(teamId, weaponDefId);
+weaponDef-&gt;dropped = sAICallback-&gt;WeaponDef_isDropped(teamId, weaponDefId);
+weaponDef-&gt;paralyzer = sAICallback-&gt;WeaponDef_isParalyzer(teamId, weaponDefId);
+weaponDef-&gt;impactOnly = sAICallback-&gt;WeaponDef_isImpactOnly(teamId, weaponDefId);
+weaponDef-&gt;noAutoTarget = sAICallback-&gt;WeaponDef_isNoAutoTarget(teamId, weaponDefId);
+weaponDef-&gt;manualfire = sAICallback-&gt;WeaponDef_isManualFire(teamId, weaponDefId);
+weaponDef-&gt;interceptor = sAICallback-&gt;WeaponDef_getInterceptor(teamId, weaponDefId);
+weaponDef-&gt;targetable = sAICallback-&gt;WeaponDef_getTargetable(teamId, weaponDefId);
+weaponDef-&gt;stockpile = sAICallback-&gt;WeaponDef_isStockpileable(teamId, weaponDefId);
+weaponDef-&gt;coverageRange = sAICallback-&gt;WeaponDef_getCoverageRange(teamId, weaponDefId);
+weaponDef-&gt;stockpileTime = sAICallback-&gt;WeaponDef_getStockpileTime(teamId, weaponDefId);
+weaponDef-&gt;intensity = sAICallback-&gt;WeaponDef_getIntensity(teamId, weaponDefId);
+weaponDef-&gt;thickness = sAICallback-&gt;WeaponDef_getThickness(teamId, weaponDefId);
+weaponDef-&gt;laserflaresize = sAICallback-&gt;WeaponDef_getLaserFlareSize(teamId, weaponDefId);
+weaponDef-&gt;corethickness = sAICallback-&gt;WeaponDef_getCoreThickness(teamId, weaponDefId);
+weaponDef-&gt;duration = sAICallback-&gt;WeaponDef_getDuration(teamId, weaponDefId);
+weaponDef-&gt;lodDistance = sAICallback-&gt;WeaponDef_getLodDistance(teamId, weaponDefId);
+weaponDef-&gt;falloffRate = sAICallback-&gt;WeaponDef_getFalloffRate(teamId, weaponDefId);
+weaponDef-&gt;graphicsType = sAICallback-&gt;WeaponDef_getGraphicsType(teamId, weaponDefId);
+weaponDef-&gt;soundTrigger = sAICallback-&gt;WeaponDef_isSoundTrigger(teamId, weaponDefId);
+weaponDef-&gt;selfExplode = sAICallback-&gt;WeaponDef_isSelfExplode(teamId, weaponDefId);
+weaponDef-&gt;gravityAffected = sAICallback-&gt;WeaponDef_isGravityAffected(teamId, weaponDefId);
+weaponDef-&gt;highTrajectory = sAICallback-&gt;WeaponDef_getHighTrajectory(teamId, weaponDefId);
+weaponDef-&gt;myGravity = sAICallback-&gt;WeaponDef_getMyGravity(teamId, weaponDefId);
+weaponDef-&gt;noExplode = sAICallback-&gt;WeaponDef_isNoExplode(teamId, weaponDefId);
+weaponDef-&gt;startvelocity = sAICallback-&gt;WeaponDef_getStartVelocity(teamId, weaponDefId);
+weaponDef-&gt;weaponacceleration = sAICallback-&gt;WeaponDef_getWeaponAcceleration(teamId, weaponDefId);
+weaponDef-&gt;turnrate = sAICallback-&gt;WeaponDef_getTurnRate(teamId, weaponDefId);
+weaponDef-&gt;maxvelocity = sAICallback-&gt;WeaponDef_getMaxVelocity(teamId, weaponDefId);
+weaponDef-&gt;projectilespeed = sAICallback-&gt;WeaponDef_getProjectileSpeed(teamId, weaponDefId);
+weaponDef-&gt;explosionSpeed = sAICallback-&gt;WeaponDef_getExplosionSpeed(teamId, weaponDefId);
+weaponDef-&gt;onlyTargetCategory = sAICallback-&gt;WeaponDef_getOnlyTargetCategory(teamId, weaponDefId);
+weaponDef-&gt;wobble = sAICallback-&gt;WeaponDef_getWobble(teamId, weaponDefId);
+weaponDef-&gt;dance = sAICallback-&gt;WeaponDef_getDance(teamId, weaponDefId);
+weaponDef-&gt;trajectoryHeight = sAICallback-&gt;WeaponDef_getTrajectoryHeight(teamId, weaponDefId);
+weaponDef-&gt;largeBeamLaser = sAICallback-&gt;WeaponDef_isLargeBeamLaser(teamId, weaponDefId);
+weaponDef-&gt;isShield = sAICallback-&gt;WeaponDef_isShield(teamId, weaponDefId);
+weaponDef-&gt;shieldRepulser = sAICallback-&gt;WeaponDef_isShieldRepulser(teamId, weaponDefId);
+weaponDef-&gt;smartShield = sAICallback-&gt;WeaponDef_isSmartShield(teamId, weaponDefId);
+weaponDef-&gt;exteriorShield = sAICallback-&gt;WeaponDef_isExteriorShield(teamId, weaponDefId);
+weaponDef-&gt;visibleShield = sAICallback-&gt;WeaponDef_isVisibleShield(teamId, weaponDefId);
+weaponDef-&gt;visibleShieldRepulse = sAICallback-&gt;WeaponDef_isVisibleShieldRepulse(teamId, weaponDefId);
+weaponDef-&gt;visibleShieldHitFrames = sAICallback-&gt;WeaponDef_getVisibleShieldHitFrames(teamId, weaponDefId);
+weaponDef-&gt;shieldEnergyUse = sAICallback-&gt;WeaponDef_getShieldEnergyUse(teamId, weaponDefId);
+weaponDef-&gt;shieldRadius = sAICallback-&gt;WeaponDef_getShieldRadius(teamId, weaponDefId);
+weaponDef-&gt;shieldForce = sAICallback-&gt;WeaponDef_getShieldForce(teamId, weaponDefId);
+weaponDef-&gt;shieldMaxSpeed = sAICallback-&gt;WeaponDef_getShieldMaxSpeed(teamId, weaponDefId);
+weaponDef-&gt;shieldPower = sAICallback-&gt;WeaponDef_getShieldPower(teamId, weaponDefId);
+weaponDef-&gt;shieldPowerRegen = sAICallback-&gt;WeaponDef_getShieldPowerRegen(teamId, weaponDefId);
+weaponDef-&gt;shieldPowerRegenEnergy = sAICallback-&gt;WeaponDef_getShieldPowerRegenEnergy(teamId, weaponDefId);
+weaponDef-&gt;shieldStartingPower = sAICallback-&gt;WeaponDef_getShieldStartingPower(teamId, weaponDefId);
+weaponDef-&gt;shieldRechargeDelay = sAICallback-&gt;WeaponDef_getShieldRechargeDelay(teamId, weaponDefId);
+weaponDef-&gt;shieldGoodColor = float3(sAICallback-&gt;WeaponDef_getShieldGoodColor(teamId, weaponDefId));
+weaponDef-&gt;shieldBadColor = float3(sAICallback-&gt;WeaponDef_getShieldBadColor(teamId, weaponDefId));
+weaponDef-&gt;shieldAlpha = sAICallback-&gt;WeaponDef_getShieldAlpha(teamId, weaponDefId);
+weaponDef-&gt;shieldInterceptType = sAICallback-&gt;WeaponDef_getShieldInterceptType(teamId, weaponDefId);
+weaponDef-&gt;interceptedByShieldType = sAICallback-&gt;WeaponDef_getInterceptedByShieldType(teamId, weaponDefId);
+weaponDef-&gt;avoidFriendly = sAICallback-&gt;WeaponDef_isAvoidFriendly(teamId, weaponDefId);
+weaponDef-&gt;avoidFeature = sAICallback-&gt;WeaponDef_isAvoidFeature(teamId, weaponDefId);
+weaponDef-&gt;avoidNeutral = sAICallback-&gt;WeaponDef_isAvoidNeutral(teamId, weaponDefId);
+weaponDef-&gt;targetBorder = sAICallback-&gt;WeaponDef_getTargetBorder(teamId, weaponDefId);
+weaponDef-&gt;cylinderTargetting = sAICallback-&gt;WeaponDef_getCylinderTargetting(teamId, weaponDefId);
+weaponDef-&gt;minIntensity = sAICallback-&gt;WeaponDef_getMinIntensity(teamId, weaponDefId);
+weaponDef-&gt;heightBoostFactor = sAICallback-&gt;WeaponDef_getHeightBoostFactor(teamId, weaponDefId);
+weaponDef-&gt;proximityPriority = sAICallback-&gt;WeaponDef_getProximityPriority(teamId, weaponDefId);
+weaponDef-&gt;collisionFlags = sAICallback-&gt;WeaponDef_getCollisionFlags(teamId, weaponDefId);
+weaponDef-&gt;sweepFire = sAICallback-&gt;WeaponDef_isSweepFire(teamId, weaponDefId);
+weaponDef-&gt;canAttackGround = sAICallback-&gt;WeaponDef_isCanAttackGround(teamId, weaponDefId);
+weaponDef-&gt;cameraShake = sAICallback-&gt;WeaponDef_getCameraShake(teamId, weaponDefId);
+weaponDef-&gt;dynDamageExp = sAICallback-&gt;WeaponDef_getDynDamageExp(teamId, weaponDefId);
+weaponDef-&gt;dynDamageMin = sAICallback-&gt;WeaponDef_getDynDamageMin(teamId, weaponDefId);
+weaponDef-&gt;dynDamageRange = sAICallback-&gt;WeaponDef_getDynDamageRange(teamId, weaponDefId);
+weaponDef-&gt;dynDamageInverted = sAICallback-&gt;WeaponDef_isDynDamageInverted(teamId, weaponDefId);
+//	logT(&quot;GetWeaponDefById 6&quot;);
+//{
+//	SProperties* sProperties = sAICallback-&gt;WeaponDef_getCustomParams(teamId, weaponDefId);
+//	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+//	int i;
+//	for (i=0; i &lt; sProperties-&gt;size; ++i) {
+//		weaponDef-&gt;customParams.insert(sProperties-&gt;map[i][0], sProperties-&gt;map[i][1]);
+//	}
+//	free(sProperties-&gt;map);
+//}
+{
+	int size = sAICallback-&gt;WeaponDef_getNumCustomParams(teamId, weaponDefId);
+	weaponDef-&gt;customParams = std::map&lt;std::string,std::string&gt;();
+//	logT(&quot;GetWeaponDefById 7&quot;);
+//	logI(&quot;GetWeaponDefById 7 size: %d&quot;, size);
+//	int i;
+//	for (i=0; i &lt; size; ++i) {
+//		const char** entry = sAICallback-&gt;WeaponDef_getCustomParam(teamId, weaponDefId, i);
+////		weaponDef-&gt;customParams.insert(entry[0], entry[1]);
+//		weaponDef-&gt;customParams[entry[0]] = entry[1];
+////		free(entry);
+//	}
+//	const char*** cMap = (const char***) malloc(size*2*sizeof(char*));
+	const char* cKeys[size];
+	const char* cValues[size];
+	sAICallback-&gt;WeaponDef_getCustomParamKeys(teamId, weaponDefId, cKeys);
+	sAICallback-&gt;WeaponDef_getCustomParamValues(teamId, weaponDefId, cValues);
+//	logT(&quot;GetWeaponDefById 8&quot;);
+//	logI(&quot;GetWeaponDefById 8 size: %d&quot;, size);
+	int i;
+	for (i=0; i &lt; size; ++i) {
+//	logI(&quot;GetWeaponDefById 8 i: %d&quot;, i);
+		weaponDef-&gt;customParams[cKeys[i]] = cValues[i];
+	}
+//	free(cMap);
+}
+//	logT(&quot;GetWeaponDefById 9&quot;);
+	if (weaponDefs[weaponDefId] != NULL) {
+		delete weaponDefs[weaponDefId];
+	}
+//	logT(&quot;GetWeaponDefById 10&quot;);
+		weaponDefs[weaponDefId] = weaponDef;
+//	logT(&quot;GetWeaponDefById 11&quot;);
+		weaponDefFrames[weaponDefId] = currentFrame;
+//	logT(&quot;GetWeaponDefById 12&quot;);
+	}
+
+//	logT(&quot;leaving: GetWeaponDefById sAICallback&quot;);
+	return weaponDefs[weaponDefId];
+}
+
+const float3* CAIAICallback::GetStartPos() {
+	return new float3(sAICallback-&gt;Map_getStartPos(teamId));
+}
+
+
+
+
+
+
+
+void CAIAICallback::SendTextMsg(const char* text, int zone) {
+	SSendTextMessageCommand cmd = {text, zone};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_TEXT_MESSAGE, &amp;cmd);
+}
+
+void CAIAICallback::SetLastMsgPos(float3 pos) {
+	SSetLastPosMessageCommand cmd = {pos.toSAIFloat3()}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SET_LAST_POS_MESSAGE, &amp;cmd);
+}
+
+void CAIAICallback::AddNotification(float3 pos, float3 color, float alpha) {
+	SAddNotificationDrawerCommand cmd = {pos.toSAIFloat3(), color.toSAIFloat3(), alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_ADD_NOTIFICATION, &amp;cmd);
+}
+
+bool CAIAICallback::SendResources(float mAmount, float eAmount, int receivingTeam) {
+		SSendResourcesCommand cmd = {mAmount, eAmount, receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_RESOURCES, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+int CAIAICallback::SendUnits(const std::vector&lt;int&gt;&amp; unitIds, int receivingTeam) {
+	int arr_unitIds[unitIds.size()];
+	for (unsigned int i=0; i &lt; unitIds.size(); ++i) {
+		arr_unitIds[i] = unitIds[i];
+	}
+	SSendUnitsCommand cmd = {arr_unitIds, unitIds.size(), receivingTeam}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SEND_UNITS, &amp;cmd); return cmd.ret_sentUnits;
+}
+
+void* CAIAICallback::CreateSharedMemArea(char* name, int size) {
+		SCreateSharedMemAreaCommand cmd = {name, size}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_CREATE, &amp;cmd); return cmd.ret_sharedMemArea;
+}
+
+void CAIAICallback::ReleasedSharedMemArea(char* name) {
+	SReleaseSharedMemAreaCommand cmd = {name}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_SHARED_MEM_AREA_RELEASE, &amp;cmd);
+}
+
+int CAIAICallback::CreateGroup(const char* libraryName, unsigned aiNumber) {
+		SCreateGroupCommand cmd = {libraryName, aiNumber}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_CREATE, &amp;cmd); return cmd.ret_groupId;
+}
+
+void CAIAICallback::EraseGroup(int groupId) {
+	SEraseGroupCommand cmd = {groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ERASE, &amp;cmd);
+}
+
+bool CAIAICallback::AddUnitToGroup(int unitId, int groupId) {
+		SAddUnitToGroupCommand cmd = {unitId, groupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_ADD_UNIT, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+bool CAIAICallback::RemoveUnitFromGroup(int unitId) {
+		SRemoveUnitFromGroupCommand cmd = {unitId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_GROUP_REMOVE_UNIT, &amp;cmd); return cmd.ret_isExecuted;
+}
+
+int CAIAICallback::GiveGroupOrder(int groupId, Command* c) {
+	return this-&gt;Internal_GiveOrder(-1, groupId, c);
+}
+
+int CAIAICallback::GiveOrder(int unitId, Command* c) {
+	return this-&gt;Internal_GiveOrder(unitId, -1, c);
+}
+
+int CAIAICallback::Internal_GiveOrder(int unitId, int groupId, Command* c) {
+
+/*
+	int ret = -1;
+
+	switch (c-&gt;id) {
+		case CMD_STOP:
+		{
+			SStopUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOP, &amp;cmd);
+			break;
+		}
+		case CMD_WAIT:
+		{
+			SWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT, &amp;cmd);
+			break;
+		}
+		case CMD_TIMEWAIT:
+		{
+			STimeWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_TIME, &amp;cmd);
+			break;
+		}
+		case CMD_DEATHWAIT:
+		{
+			SDeathWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_DEATH, &amp;cmd);
+			break;
+		}
+		case CMD_SQUADWAIT:
+		{
+			SSquadWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_SQUAD, &amp;cmd);
+			break;
+		}
+		case CMD_GATHERWAIT:
+		{
+			SGatherWaitUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_WAIT_GATHER, &amp;cmd);
+			break;
+		}
+		case CMD_MOVE:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SMoveUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_MOVE, &amp;cmd);
+			break;
+		}
+		case CMD_PATROL:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SPatrolUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_PATROL, &amp;cmd);
+			break;
+		}
+		case CMD_FIGHT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SFightUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_FIGHT, &amp;cmd);
+			break;
+		}
+		case CMD_ATTACK:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SAttackUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK, &amp;cmd);
+			} else {
+				SAIFloat3 toAttackPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SAttackAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toAttackPos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_ATTACK_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_GUARD:
+		{
+			SGuardUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GUARD, &amp;cmd);
+			break;
+		}
+		case CMD_AISELECT:
+		{
+			SAiSelectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_AI_SELECT, &amp;cmd);
+			break;
+		}
+		case CMD_GROUPADD:
+		{
+			SGroupAddUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_ADD, &amp;cmd);
+			break;
+		}
+		case CMD_GROUPCLEAR:
+		{
+			SGroupClearUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_GROUP_CLEAR, &amp;cmd);
+			break;
+		}
+		case CMD_REPAIR:
+		{
+			SRepairUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_REPAIR, &amp;cmd);
+			break;
+		}
+		case CMD_FIRE_STATE:
+		{
+			SSetFireStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_FIRE_STATE, &amp;cmd);
+			break;
+		}
+		case CMD_MOVE_STATE:
+		{
+			SSetMoveStateUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_MOVE_STATE, &amp;cmd);
+			break;
+		}
+		case CMD_SETBASE:
+		{
+			SAIFloat3 basePos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SSetBaseUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, basePos};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_BASE, &amp;cmd);
+			break;
+		}
+		case CMD_SELFD:
+		{
+			SSelfDestroyUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SELF_DESTROY, &amp;cmd);
+			break;
+		}
+		case CMD_SET_WANTED_MAX_SPEED:
+		{
+			SSetWantedMaxSpeedUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_WANTED_MAX_SPEED, &amp;cmd);
+			break;
+		}
+		case CMD_LOAD_UNITS:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				int toLoadUnitId = (int) c-&gt;params[0];
+				SLoadUnitsUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, &amp;toLoadUnitId, 1};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SLoadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_UNITS_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_LOAD_ONTO:
+		{
+			SLoadOntoUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_LOAD_ONTO, &amp;cmd);
+			break;
+		}
+		case CMD_UNLOAD_UNIT:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, (int) c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNIT, &amp;cmd);
+			break;
+		}
+		case CMD_UNLOAD_UNITS:
+		{
+			SAIFloat3 toPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SUnloadUnitsAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toPos, c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_UNLOAD_UNITS_AREA, &amp;cmd);
+			break;
+		}
+		case CMD_ONOFF:
+		{
+			SSetOnOffUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_ON_OFF, &amp;cmd);
+			break;
+		}
+		case CMD_RECLAIM:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SReclaimUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SReclaimAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RECLAIM_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_CLOAK:
+		{
+			SCloakUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CLOAK, &amp;cmd);
+			break;
+		}
+		case CMD_STOCKPILE:
+		{
+			SStockpileUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOCKPILE, &amp;cmd);
+			break;
+		}
+		case CMD_DGUN:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SDGunUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				SDGunPosUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_D_GUN_POS, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_RESTORE:
+		{
+			SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+			SRestoreAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, c-&gt;params[3]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESTORE_AREA, &amp;cmd);
+			break;
+		}
+		case CMD_REPEAT:
+		{
+			SSetRepeatUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (bool) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_REPEAT, &amp;cmd);
+			break;
+		}
+		case CMD_TRAJECTORY:
+		{
+			SSetTrajectoryUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_TRAJECTORY, &amp;cmd);
+			break;
+		}
+		case CMD_RESURRECT:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SResurrectUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SResurrectAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_RESURRECT_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_CAPTURE:
+		{
+			if (c-&gt;params.size() &lt; 3) {
+				SCaptureUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE, &amp;cmd);
+			} else {
+				SAIFloat3 pos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				float radius = 0.0f;
+				if (c-&gt;params.size() &gt;= 4) radius = c-&gt;params[3];
+				SCaptureAreaUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, pos, radius};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CAPTURE_AREA, &amp;cmd);
+			}
+			break;
+		}
+		case CMD_AUTOREPAIRLEVEL:
+		{
+			SSetAutoRepairLevelUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL, &amp;cmd);
+			break;
+		}
+		case CMD_IDLEMODE:
+		{
+			SSetIdleModeUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, (int) c-&gt;params[0]};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_SET_IDLE_MODE, &amp;cmd);
+			break;
+		}
+		default:
+		{
+			if (c-&gt;id &lt; 0) { // CMD_BUILD
+				int toBuildUnitDefId = -c-&gt;id;
+				SAIFloat3 buildPos = {c-&gt;params[0], c-&gt;params[1], c-&gt;params[2]};
+				int facing = UNIT_COMMAND_BUILD_NO_FACING;
+				if (c-&gt;params.size() &gt;= 4) facing = c-&gt;params[3];
+				SBuildUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, toBuildUnitDefId, buildPos, facing};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_BUILD, &amp;cmd);
+			} else { // CMD_CUSTOM
+				int cmdId = c-&gt;id;
+				int numParams = c-&gt;params.size();
+				float params[numParams];
+				SCustomUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut, cmdId, params, numParams};
+				ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_CUSTOM, &amp;cmd);
+			}
+			break;
+		}
+
+	}
+
+	return ret;
+*/
+	int sCommandId;
+	void* sCommandData = mallocSUnitCommand(unitId, groupId, c, &amp;sCommandId);
+
+	int ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, sCommandId, sCommandData);
+
+	freeSUnitCommand(sCommandData, sCommandId);
+
+	return ret;
+}
+
+int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
+		SInitPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_INIT, &amp;cmd); return cmd.ret_pathId;
+}
+
+float3 CAIAICallback::GetNextWaypoint(int pathId) {
+		SGetNextWaypointPathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_NEXT_WAYPOINT, &amp;cmd); return float3(cmd.ret_nextWaypoint);
+}
+
+float CAIAICallback::GetPathLength(float3 start, float3 end, int pathType) {
+		SGetApproximateLengthPathCommand cmd = {start.toSAIFloat3(), end.toSAIFloat3(), pathType}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_GET_APPROXIMATE_LENGTH, &amp;cmd); return cmd.ret_approximatePathLength;
+}
+
+void CAIAICallback::FreePath(int pathId) {
+	SFreePathCommand cmd = {pathId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_PATH_FREE, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerStartPath(const float3&amp; pos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SStartPathDrawerCommand cmd = {pos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_START, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerFinishPath() {
+	SFinishPathDrawerCommand cmd = {}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_FINISH, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawLine(const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SDrawLinePathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawLineAndIcon(int cmdId, const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SDrawLineAndIconPathDrawerCommand cmd = {cmdId, endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerDrawIconAtLastPos(int cmdId) {
+	SDrawIconAtLastPosPathDrawerCommand cmd = {cmdId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerBreak(const float3&amp; endPos, const float* color) {
+	SAIFloat3 col3 = {color[0], color[1], color[2]};
+	float alpha = color[3];
+	SBreakPathDrawerCommand cmd = {endPos.toSAIFloat3(), col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_BREAK, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerRestart() {
+	SRestartPathDrawerCommand cmd = {false}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
+}
+
+void CAIAICallback::LineDrawerRestartSameColor() {
+	SRestartPathDrawerCommand cmd = {true}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_PATH_RESTART, &amp;cmd);
+}
+
+int CAIAICallback::CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifeTime, int figureGroupId) {
+		SCreateSplineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), pos3.toSAIFloat3(), pos4.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_SPLINE, &amp;cmd); return cmd.ret_newFigureGroupId;
+}
+
+int CAIAICallback::CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifeTime, int figureGroupId) {
+		SCreateLineFigureDrawerCommand cmd = {pos1.toSAIFloat3(), pos2.toSAIFloat3(), width, arrow, lifeTime, figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_CREATE_LINE, &amp;cmd); return cmd.ret_newFigureGroupId;
+}
+
+void CAIAICallback::SetFigureColor(int figureGroupId, float red, float green, float blue, float alpha) {
+	SAIFloat3 col3 = {red, green, blue};
+	SSetColorFigureDrawerCommand cmd = {figureGroupId, col3, alpha}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_SET_COLOR, &amp;cmd);
+}
+
+void CAIAICallback::DeleteFigureGroup(int figureGroupId) {
+	SDeleteFigureDrawerCommand cmd = {figureGroupId}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_FIGURE_DELETE, &amp;cmd);
+}
+
+void CAIAICallback::DrawUnit(const char* name, float3 pos, float rotation, int lifeTime, int unitTeamId, bool transparent, bool drawBorder, int facing) {
+	SDrawUnitDrawerCommand cmd = {sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, name), pos.toSAIFloat3(), rotation, lifeTime, unitTeamId, transparent, drawBorder, facing}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_DRAWER_DRAW_UNIT, &amp;cmd);
+}
+
+int CAIAICallback::HandleCommand(int commandId, void* data) {
+
+	int cmdTopicIndex = commandId;
+	int ret = -99;
+
+	switch (commandId) {
+		case AIHCQuerySubVersionId: {
+//			SQuerySubVersionCommand cmd;
+//			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			ret = sAICallback-&gt;Game_getAiInterfaceVersion(teamId);
+			break;
+		}
+		case AIHCAddMapPointId: {
+			AIHCAddMapPoint* myData = (AIHCAddMapPoint*) data;
+			SAddPointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3(), myData-&gt;label};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCAddMapLineId: {
+			AIHCAddMapLine* myData = (AIHCAddMapLine*) data;
+			SAddLineDrawCommand cmd = {myData-&gt;posfrom.toSAIFloat3(), myData-&gt;posto.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCRemoveMapPointId: {
+			AIHCRemoveMapPoint* myData = (AIHCRemoveMapPoint*) data;
+			SRemovePointDrawCommand cmd = {myData-&gt;pos.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+		case AIHCSendStartPosId: {
+			AIHCSendStartPos* myData = (AIHCSendStartPos*) data;
+			SSendStartPosCommand cmd = {myData-&gt;ready, myData-&gt;pos.toSAIFloat3()};
+			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, cmdTopicIndex, &amp;cmd);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+bool CAIAICallback::ReadFile(const char* filename, void* buffer, int bufferLen) {
+//		SReadFileCommand cmd = {name, buffer, bufferLen}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_READ_FILE, &amp;cmd); return cmd.ret_isExecuted;
+	return sAICallback-&gt;File_getContent(teamId, filename, buffer, bufferLen);
+}
+
+const char* CAIAICallback::CallLuaRules(const char* data, int inSize, int* outSize) {
+		SCallLuaRulesCommand cmd = {data, inSize, outSize}; sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CALL_LUA_RULES, &amp;cmd); return cmd.ret_outData;
+}
+
+

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.h	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,214 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _AIAICALLBACK_H
-#define	_AIAICALLBACK_H
-
-
-#include &quot;ExternalAI/Interface/SAICallback.h&quot;
-#include &quot;ExternalAI/IAICallback.h&quot;
-
-/**
- * The AI side wrapper over the C AI interface for IAICallback.
- */
-class CAIAICallback : public IAICallback {
-public:
-    CAIAICallback();
-    CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/);
-
-	virtual void SendTextMsg(const char* text, int zone);
-	virtual void SetLastMsgPos(float3 pos);
-	virtual void AddNotification(float3 pos, float3 color, float alpha);
-
-	virtual bool SendResources(float mAmount, float eAmount, int receivingTeam);
-	
-	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam);
-
-	virtual bool PosInCamera(float3 pos, float radius);
-
-	virtual int GetCurrentFrame();
-
-	virtual int GetMyTeam();
-	virtual int GetMyAllyTeam();
-	virtual int GetPlayerTeam(int player);
-	virtual const char* GetTeamSide(int team);
-
-	virtual void* CreateSharedMemArea(char* name, int size);
-	
-	virtual void ReleasedSharedMemArea(char* name);
-
-	virtual int CreateGroup(const char* dll, unsigned aiNumber);							
-																						
-	virtual void EraseGroup(int groupid);											
-	virtual bool AddUnitToGroup(int unitid, int groupid);							
-																						
-	virtual bool RemoveUnitFromGroup(int unitid);									
-	virtual int GetUnitGroup(int unitid);											
-	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);	
-	virtual int GiveGroupOrder(int unitid, Command* c);
-
-	virtual int GiveOrder(int unitid, Command* c);
-
-	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid);
-	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
-
-	virtual int GetUnitAiHint(int unitid);				
-	virtual int GetUnitTeam(int unitid);
-	virtual int GetUnitAllyTeam(int unitid);
-	virtual float GetUnitHealth(int unitid);			
-	virtual float GetUnitMaxHealth(int unitid);			
-	virtual float GetUnitSpeed(int unitid);				
-	virtual float GetUnitPower(int unitid);				
-	virtual float GetUnitExperience(int unitid);		
-	virtual float GetUnitMaxRange(int unitid);			
-	virtual bool IsUnitActivated (int unitid);
-	virtual bool UnitBeingBuilt(int unitid);			
-	virtual const UnitDef* GetUnitDef(int unitid);		
-															
-	virtual float3 GetUnitPos(int unitid);
-	virtual int GetBuildingFacing(int unitid);			
-	virtual bool IsUnitCloaked(int unitid);
-	virtual bool IsUnitParalyzed(int unitid);
-	virtual bool IsUnitNeutral(int unitid);
-	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
-
-	virtual const UnitDef* GetUnitDef(const char* unitName);
-	virtual const UnitDef* GetUnitDefById(int unitDefId);
-
-	virtual int InitPath(float3 start, float3 end, int pathType);
-	virtual float3 GetNextWaypoint(int pathid);
-	virtual void FreePath(int pathid);
-
-	virtual float GetPathLength(float3 start, float3 end, int pathType);
-
-	virtual int GetEnemyUnits(int* units);										
-	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);		
-	virtual int GetEnemyUnitsInRadarAndLos(int* units);							
-	virtual int GetFriendlyUnits(int* units);									
-	virtual int GetFriendlyUnits(int* units, const float3&amp; pos, float radius);	
-	virtual int GetNeutralUnits(int* units);									
-	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);	
-
-	virtual int GetMapWidth();
-	virtual int GetMapHeight();
-	virtual const float* GetHeightMap();			
-	virtual float GetMinHeight();					
-	virtual float GetMaxHeight();					
-	virtual const float* GetSlopeMap();				
-														
-	virtual const unsigned short* GetLosMap();		
-	virtual const unsigned short* GetRadarMap();	
-	virtual const unsigned short* GetJammerMap();	
-	virtual const unsigned char* GetMetalMap();		
-	virtual const char* GetMapName();
-	virtual const char* GetModName();
-
-	virtual float GetElevation(float x, float z);	
-
-	virtual float GetMaxMetal();					
-	virtual float GetExtractorRadius();				
-	virtual float GetMinWind();
-	virtual float GetMaxWind();
-	virtual float GetTidalStrength();
-	virtual float GetGravity();
-
-	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color);
-	virtual void LineDrawerFinishPath();
-	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color);
-	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color);
-	virtual void LineDrawerDrawIconAtLastPos(int cmdID);
-	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color);
-	virtual void LineDrawerRestart();
-	virtual void LineDrawerRestartSameColor();
-
-	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group);
-	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group);
-	virtual void SetFigureColor(int group, float red, float green, float blue, float alpha);
-	virtual void DeleteFigureGroup(int group);
-
-	virtual void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing);
-
-	virtual bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing);
-	
-	virtual float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing);
-
-	virtual bool GetProperty(int id, int property, void* dst);
-	virtual bool GetValue(int id, void* dst);
-	virtual int HandleCommand(int commandId, void* data);
-
-	virtual int GetFileSize(const char* name);								
-	virtual bool ReadFile(const char* name, void* buffer, int bufferLen);	
-
-	virtual int GetSelectedUnits(int* units);
-	virtual float3 GetMousePos();
-	virtual int GetMapPoints(PointMarker* pm, int maxPoints);
-	virtual int GetMapLines(LineMarker* lm, int maxLines);
-
-	virtual float GetMetal();					
-	virtual float GetMetalIncome();				
-	virtual float GetMetalUsage();				
-	virtual float GetMetalStorage();			
-
-	virtual float GetEnergy();					
-	virtual float GetEnergyIncome();			
-	virtual float GetEnergyUsage();				
-	virtual float GetEnergyStorage();			
-
-	virtual int GetFeatures(int *features, int max);
-	virtual int GetFeatures(int *features, int max, const float3&amp; pos, float radius);
-	virtual const FeatureDef* GetFeatureDef(int feature);
-	virtual const FeatureDef* GetFeatureDefById(int featureDefId);
-	virtual float GetFeatureHealth(int feature);
-	virtual float GetFeatureReclaimLeft(int feature);
-	virtual float3 GetFeaturePos(int feature);
-
-	virtual int GetNumUnitDefs();
-	virtual void GetUnitDefList(const UnitDef** list);
-	virtual float GetUnitDefHeight(int def);	
-	virtual float GetUnitDefRadius(int def);	
-
-	virtual const WeaponDef* GetWeapon(const char* weaponName);
-	virtual const WeaponDef* GetWeaponDefById(int weaponDefId);
-
-	virtual const float3* GetStartPos();
-
-	
-	virtual const char* CallLuaRules(const char* data, int inSize = -1, int* outSize = NULL);
-
-private:
-    int teamId;
-    SAICallback* sAICallback;
-//    IAICallback* aiCallback;
-//    int currentFrame;
-    void init();
-//    void setCurrentFrame(int frame) { currentFrame = frame; }
-    int Internal_GiveOrder(int unitId, int groupId, Command* c);
-    
-	// caches
-    WeaponDef** weaponDefs;
-    int* weaponDefFrames;
-    UnitDef** unitDefs;
-    int* unitDefFrames;
-	std::vector&lt;CommandDescription&gt;** groupPossibleCommands; // needed to prevent memory leacks
-	std::vector&lt;CommandDescription&gt;** unitPossibleCommands; // needed to prevent memory leacks
-	CCommandQueue** unitCurrentCommandQueues; // needed to prevent memory leacks
-    FeatureDef** featureDefs;
-    int* featureDefFrames;
-};
-
-#endif	/* _AIAICALLBACK_H */
-

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.h)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICallback.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,214 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _AIAICALLBACK_H
+#define	_AIAICALLBACK_H
+
+#include &quot;ExternalAI/IAICallback.h&quot;
+
+struct SAICallback;
+
+/**
+ * The AI side wrapper over the C AI interface for IAICallback.
+ */
+class CAIAICallback : public IAICallback {
+public:
+	CAIAICallback();
+	CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/);
+
+	virtual void SendTextMsg(const char* text, int zone);
+	virtual void SetLastMsgPos(float3 pos);
+	virtual void AddNotification(float3 pos, float3 color, float alpha);
+
+	virtual bool SendResources(float mAmount, float eAmount, int receivingTeam);
+	
+	virtual int SendUnits(const std::vector&lt;int&gt;&amp; unitIDs, int receivingTeam);
+
+	virtual bool PosInCamera(float3 pos, float radius);
+
+	virtual int GetCurrentFrame();
+
+	virtual int GetMyTeam();
+	virtual int GetMyAllyTeam();
+	virtual int GetPlayerTeam(int player);
+	virtual const char* GetTeamSide(int team);
+
+	virtual void* CreateSharedMemArea(char* name, int size);
+	
+	virtual void ReleasedSharedMemArea(char* name);
+
+	virtual int CreateGroup(const char* dll, unsigned aiNumber);							
+																						
+	virtual void EraseGroup(int groupid);											
+	virtual bool AddUnitToGroup(int unitid, int groupid);							
+																						
+	virtual bool RemoveUnitFromGroup(int unitid);									
+	virtual int GetUnitGroup(int unitid);											
+	virtual const std::vector&lt;CommandDescription&gt;* GetGroupCommands(int unitid);	
+	virtual int GiveGroupOrder(int unitid, Command* c);
+
+	virtual int GiveOrder(int unitid, Command* c);
+
+	virtual const std::vector&lt;CommandDescription&gt;* GetUnitCommands(int unitid);
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+
+	virtual int GetUnitAiHint(int unitid);				
+	virtual int GetUnitTeam(int unitid);
+	virtual int GetUnitAllyTeam(int unitid);
+	virtual float GetUnitHealth(int unitid);			
+	virtual float GetUnitMaxHealth(int unitid);			
+	virtual float GetUnitSpeed(int unitid);				
+	virtual float GetUnitPower(int unitid);				
+	virtual float GetUnitExperience(int unitid);		
+	virtual float GetUnitMaxRange(int unitid);			
+	virtual bool IsUnitActivated (int unitid);
+	virtual bool UnitBeingBuilt(int unitid);			
+	virtual const UnitDef* GetUnitDef(int unitid);		
+															
+	virtual float3 GetUnitPos(int unitid);
+	virtual int GetBuildingFacing(int unitid);			
+	virtual bool IsUnitCloaked(int unitid);
+	virtual bool IsUnitParalyzed(int unitid);
+	virtual bool IsUnitNeutral(int unitid);
+	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+
+	virtual const UnitDef* GetUnitDef(const char* unitName);
+	virtual const UnitDef* GetUnitDefById(int unitDefId);
+
+	virtual int InitPath(float3 start, float3 end, int pathType);
+	virtual float3 GetNextWaypoint(int pathid);
+	virtual void FreePath(int pathid);
+
+	virtual float GetPathLength(float3 start, float3 end, int pathType);
+
+	virtual int GetEnemyUnits(int* units);										
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);		
+	virtual int GetEnemyUnitsInRadarAndLos(int* units);							
+	virtual int GetFriendlyUnits(int* units);									
+	virtual int GetFriendlyUnits(int* units, const float3&amp; pos, float radius);	
+	virtual int GetNeutralUnits(int* units);									
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);	
+
+	virtual int GetMapWidth();
+	virtual int GetMapHeight();
+	virtual const float* GetHeightMap();			
+	virtual float GetMinHeight();					
+	virtual float GetMaxHeight();					
+	virtual const float* GetSlopeMap();				
+														
+	virtual const unsigned short* GetLosMap();		
+	virtual const unsigned short* GetRadarMap();	
+	virtual const unsigned short* GetJammerMap();	
+	virtual const unsigned char* GetMetalMap();		
+	virtual const char* GetMapName();
+	virtual const char* GetModName();
+
+	virtual float GetElevation(float x, float z);	
+
+	virtual float GetMaxMetal();					
+	virtual float GetExtractorRadius();				
+	virtual float GetMinWind();
+	virtual float GetMaxWind();
+	virtual float GetTidalStrength();
+	virtual float GetGravity();
+
+	virtual void LineDrawerStartPath(const float3&amp; pos, const float* color);
+	virtual void LineDrawerFinishPath();
+	virtual void LineDrawerDrawLine(const float3&amp; endPos, const float* color);
+	virtual void LineDrawerDrawLineAndIcon(int cmdID, const float3&amp; endPos, const float* color);
+	virtual void LineDrawerDrawIconAtLastPos(int cmdID);
+	virtual void LineDrawerBreak(const float3&amp; endPos, const float* color);
+	virtual void LineDrawerRestart();
+	virtual void LineDrawerRestartSameColor();
+
+	virtual int CreateSplineFigure(float3 pos1, float3 pos2, float3 pos3, float3 pos4, float width, int arrow, int lifetime, int group);
+	virtual int CreateLineFigure(float3 pos1, float3 pos2, float width, int arrow, int lifetime, int group);
+	virtual void SetFigureColor(int group, float red, float green, float blue, float alpha);
+	virtual void DeleteFigureGroup(int group);
+
+	virtual void DrawUnit(const char* name, float3 pos, float rotation, int lifetime, int team, bool transparent, bool drawBorder, int facing);
+
+	virtual bool CanBuildAt(const UnitDef* unitDef, float3 pos, int facing);
+	
+	virtual float3 ClosestBuildSite(const UnitDef* unitdef, float3 pos, float searchRadius, int minDist, int facing);
+
+	virtual bool GetProperty(int id, int property, void* dst);
+	virtual bool GetValue(int id, void* dst);
+	virtual int HandleCommand(int commandId, void* data);
+
+	virtual int GetFileSize(const char* name);								
+	virtual bool ReadFile(const char* name, void* buffer, int bufferLen);	
+
+	virtual int GetSelectedUnits(int* units);
+	virtual float3 GetMousePos();
+	virtual int GetMapPoints(PointMarker* pm, int maxPoints);
+	virtual int GetMapLines(LineMarker* lm, int maxLines);
+
+	virtual float GetMetal();					
+	virtual float GetMetalIncome();				
+	virtual float GetMetalUsage();				
+	virtual float GetMetalStorage();			
+
+	virtual float GetEnergy();					
+	virtual float GetEnergyIncome();			
+	virtual float GetEnergyUsage();				
+	virtual float GetEnergyStorage();			
+
+	virtual int GetFeatures(int *features, int max);
+	virtual int GetFeatures(int *features, int max, const float3&amp; pos, float radius);
+	virtual const FeatureDef* GetFeatureDef(int feature);
+	virtual const FeatureDef* GetFeatureDefById(int featureDefId);
+	virtual float GetFeatureHealth(int feature);
+	virtual float GetFeatureReclaimLeft(int feature);
+	virtual float3 GetFeaturePos(int feature);
+
+	virtual int GetNumUnitDefs();
+	virtual void GetUnitDefList(const UnitDef** list);
+	virtual float GetUnitDefHeight(int def);	
+	virtual float GetUnitDefRadius(int def);	
+
+	virtual const WeaponDef* GetWeapon(const char* weaponName);
+	virtual const WeaponDef* GetWeaponDefById(int weaponDefId);
+
+	virtual const float3* GetStartPos();
+
+	
+	virtual const char* CallLuaRules(const char* data, int inSize = -1, int* outSize = NULL);
+
+private:
+	int teamId;
+	SAICallback* sAICallback;
+//	IAICallback* aiCallback;
+//	int currentFrame;
+	void init();
+//	void setCurrentFrame(int frame) { currentFrame = frame; }
+	int Internal_GiveOrder(int unitId, int groupId, Command* c);
+
+	// caches
+	WeaponDef** weaponDefs;
+	int* weaponDefFrames;
+	UnitDef** unitDefs;
+	int* unitDefFrames;
+	std::vector&lt;CommandDescription&gt;** groupPossibleCommands; // needed to prevent memory leacks
+	std::vector&lt;CommandDescription&gt;** unitPossibleCommands; // needed to prevent memory leacks
+	CCommandQueue** unitCurrentCommandQueues; // needed to prevent memory leacks
+	FeatureDef** featureDefs;
+	int* featureDefFrames;
+};
+
+#endif	/* _AIAICALLBACK_H */
+

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.cpp	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,219 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;AIAICheats.h&quot;
-
-#include &quot;ExternalAI/Interface/AISCommands.h&quot;
-
-
-CAIAICheats::CAIAICheats()
-    : IAICheats(), teamId(-1), sAICallback(NULL)/*, aiCheatCallback(NULL)*/, aiCallback(NULL) {
-    
-}
-
-CAIAICheats::CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback)
-    : IAICheats(), teamId(teamId), sAICallback(sAICallback)/*, aiCheatCallback(aiCheatCallback)*/, aiCallback(aiCallback) {
-    
-}
-
-void CAIAICheats::setCheatsEnabled(bool enabled) {
-    sAICallback-&gt;Cheats_setEnabled(teamId, enabled);
-}
-
-
-void CAIAICheats::SetMyHandicap(float handicap) {
-    setCheatsEnabled(true);
-    SSetMyHandicapCheatCommand cmd = {handicap};
-    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_SET_MY_HANDICAP, &amp;cmd);
-    setCheatsEnabled(false);
-}
-void CAIAICheats::GiveMeMetal(float amount) {
-    setCheatsEnabled(true);
-    SGiveMeMetalCheatCommand cmd = {amount};
-    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_METAL, &amp;cmd);
-    setCheatsEnabled(false);
-}
-void CAIAICheats::GiveMeEnergy(float amount) {
-    setCheatsEnabled(true);
-    SGiveMeEnergyCheatCommand cmd = {amount};
-    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_ENERGY, &amp;cmd);
-    setCheatsEnabled(false);
-}
-
-int CAIAICheats::CreateUnit(const char* unitDefName, float3 pos) {
-    setCheatsEnabled(true);
-    int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitDefName);
-    SGiveMeNewUnitCheatCommand cmd = {unitDefId, pos.toSAIFloat3()};
-    int unitId = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_NEW_UNIT, &amp;cmd);
-    setCheatsEnabled(false);
-    return unitId;
-}
-
-const UnitDef* CAIAICheats::GetUnitDef(int unitId) {
-    setCheatsEnabled(true);
-    const UnitDef* unitDef = aiCallback-&gt;GetUnitDef(unitId);
-    setCheatsEnabled(false);
-    return unitDef;
-}
-float3 CAIAICheats::GetUnitPos(int unitId) {
-    setCheatsEnabled(true);
-    float3 pos = aiCallback-&gt;GetUnitPos(unitId);
-    setCheatsEnabled(false);
-    return pos;
-}
-int CAIAICheats::GetEnemyUnits(int* unitIds) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds);
-    setCheatsEnabled(false);
-    return numUnits;
-}
-int CAIAICheats::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
-    setCheatsEnabled(false);
-    return numUnits;
-}
-int CAIAICheats::GetNeutralUnits(int* unitIds) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds);
-    setCheatsEnabled(false);
-    return numUnits;
-}
-int CAIAICheats::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
-    setCheatsEnabled(false);
-    return numUnits;
-}
-
-int CAIAICheats::GetUnitTeam(int unitId) {
-    setCheatsEnabled(true);
-    int t = aiCallback-&gt;GetUnitTeam(unitId);
-    setCheatsEnabled(false);
-    return t;
-}
-int CAIAICheats::GetUnitAllyTeam(int unitId) {
-    setCheatsEnabled(true);
-    int t = aiCallback-&gt;GetUnitAllyTeam(unitId);
-    setCheatsEnabled(false);
-    return t;
-}
-float CAIAICheats::GetUnitHealth(int unitId) {
-    setCheatsEnabled(true);
-    float health = aiCallback-&gt;GetUnitHealth(unitId);
-    setCheatsEnabled(false);
-    return health;
-}
-float CAIAICheats::GetUnitMaxHealth(int unitId) {
-    setCheatsEnabled(true);
-    float health = aiCallback-&gt;GetUnitMaxHealth(unitId);
-    setCheatsEnabled(false);
-    return health;
-}
-float CAIAICheats::GetUnitPower(int unitId) {
-    setCheatsEnabled(true);
-    float power = aiCallback-&gt;GetUnitPower(unitId);
-    setCheatsEnabled(false);
-    return power;
-}
-float CAIAICheats::GetUnitExperience(int unitId) {
-    setCheatsEnabled(true);
-    float experience = aiCallback-&gt;GetUnitExperience(unitId);
-    setCheatsEnabled(false);
-    return experience;
-}
-bool CAIAICheats::IsUnitActivated(int unitId) {
-    setCheatsEnabled(true);
-    bool activated = aiCallback-&gt;IsUnitActivated(unitId);
-    setCheatsEnabled(false);
-    return activated;
-}
-bool CAIAICheats::UnitBeingBuilt(int unitId) {
-    setCheatsEnabled(true);
-    bool isBeingBuilt = aiCallback-&gt;UnitBeingBuilt(unitId);
-    setCheatsEnabled(false);
-    return isBeingBuilt;
-}
-bool CAIAICheats::IsUnitNeutral(int unitId) {
-    setCheatsEnabled(true);
-    bool neutral = aiCallback-&gt;IsUnitNeutral(unitId);
-    setCheatsEnabled(false);
-    return neutral;
-}
-bool CAIAICheats::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
-    setCheatsEnabled(true);
-    bool fetchOk = aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
-    setCheatsEnabled(false);
-    return fetchOk;
-}
-const CCommandQueue* CAIAICheats::GetCurrentUnitCommands(int unitId) {
-    setCheatsEnabled(true);
-    const CCommandQueue* cc = aiCallback-&gt;GetCurrentUnitCommands(unitId);
-    setCheatsEnabled(false);
-    return cc;
-}
-
-int CAIAICheats::GetBuildingFacing(int unitId) {
-    setCheatsEnabled(true);
-    int facing = aiCallback-&gt;GetBuildingFacing(unitId);
-    setCheatsEnabled(false);
-    return facing;
-}
-bool CAIAICheats::IsUnitCloaked(int unitId) {
-    setCheatsEnabled(true);
-    bool cloaked = aiCallback-&gt;IsUnitCloaked(unitId);
-    setCheatsEnabled(false);
-    return cloaked;
-}
-bool CAIAICheats::IsUnitParalyzed(int unitId) {
-    setCheatsEnabled(true);
-    bool paralyzed = aiCallback-&gt;IsUnitParalyzed(unitId);
-    setCheatsEnabled(false);
-    return paralyzed;
-}
-
-bool CAIAICheats::OnlyPassiveCheats() {
-    return sAICallback-&gt;Cheats_isOnlyPassive(teamId);
-}
-void CAIAICheats::EnableCheatEvents(bool enable) {
-    sAICallback-&gt;Cheats_setEventsEnabled(teamId, enable);
-}
-
-bool CAIAICheats::GetProperty(int id, int property, void* dst) {
-//    setCheatsEnabled(true);
-//    bool fetchOk = aiCallback-&gt;GetProperty(id, property, dst);
-//    setCheatsEnabled(false);
-//    return fetchOk;
-	// this returns always false, cause these values are now available through
-	// individual callback functions -&gt; this method is deprecated
-	return false;
-}
-bool CAIAICheats::GetValue(int id, void* dst) {
-//    setCheatsEnabled(true);
-//    bool fetchOk = aiCallback-&gt;GetValue(id, dst);
-//    setCheatsEnabled(false);
-//    return fetchOk;
-	// this returns always false, cause these values are now available through
-	// individual callback functions -&gt; this method is deprecated
-	return false;
-}
-int CAIAICheats::HandleCommand(int commandId, void* data) {
-    setCheatsEnabled(true);
-    int ret = aiCallback-&gt;HandleCommand(commandId, data);
-    setCheatsEnabled(false);
-    return ret;
-}

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.cpp)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,221 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIAICheats.h&quot;
+
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
+#include &quot;ExternalAI/Interface/AISCommands.h&quot;
+
+
+CAIAICheats::CAIAICheats()
+	: IAICheats(), teamId(-1), sAICallback(NULL)/*, aiCheatCallback(NULL)*/,
+		aiCallback(NULL) {}
+
+CAIAICheats::CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/,
+		CAIAICallback* aiCallback)
+	: IAICheats(), teamId(teamId), sAICallback(sAICallback)/*, aiCheatCallback(aiCheatCallback)*/,
+		aiCallback(aiCallback) {}
+
+void CAIAICheats::setCheatsEnabled(bool enabled) {
+	sAICallback-&gt;Cheats_setEnabled(teamId, enabled);
+}
+
+
+void CAIAICheats::SetMyHandicap(float handicap) {
+	setCheatsEnabled(true);
+	SSetMyHandicapCheatCommand cmd = {handicap};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1,
+			COMMAND_CHEATS_SET_MY_HANDICAP, &amp;cmd);
+	setCheatsEnabled(false);
+}
+void CAIAICheats::GiveMeMetal(float amount) {
+	setCheatsEnabled(true);
+	SGiveMeMetalCheatCommand cmd = {amount};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_METAL, &amp;cmd);
+	setCheatsEnabled(false);
+}
+void CAIAICheats::GiveMeEnergy(float amount) {
+	setCheatsEnabled(true);
+	SGiveMeEnergyCheatCommand cmd = {amount};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_ENERGY, &amp;cmd);
+	setCheatsEnabled(false);
+}
+
+int CAIAICheats::CreateUnit(const char* unitDefName, float3 pos) {
+	setCheatsEnabled(true);
+	int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitDefName);
+	SGiveMeNewUnitCheatCommand cmd = {unitDefId, pos.toSAIFloat3()};
+	int unitId = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_NEW_UNIT, &amp;cmd);
+	setCheatsEnabled(false);
+	return unitId;
+}
+
+const UnitDef* CAIAICheats::GetUnitDef(int unitId) {
+	setCheatsEnabled(true);
+	const UnitDef* unitDef = aiCallback-&gt;GetUnitDef(unitId);
+	setCheatsEnabled(false);
+	return unitDef;
+}
+float3 CAIAICheats::GetUnitPos(int unitId) {
+	setCheatsEnabled(true);
+	float3 pos = aiCallback-&gt;GetUnitPos(unitId);
+	setCheatsEnabled(false);
+	return pos;
+}
+int CAIAICheats::GetEnemyUnits(int* unitIds) {
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds);
+	setCheatsEnabled(false);
+	return numUnits;
+}
+int CAIAICheats::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+	setCheatsEnabled(false);
+	return numUnits;
+}
+int CAIAICheats::GetNeutralUnits(int* unitIds) {
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds);
+	setCheatsEnabled(false);
+	return numUnits;
+}
+int CAIAICheats::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+	setCheatsEnabled(false);
+	return numUnits;
+}
+
+int CAIAICheats::GetUnitTeam(int unitId) {
+	setCheatsEnabled(true);
+	int t = aiCallback-&gt;GetUnitTeam(unitId);
+	setCheatsEnabled(false);
+	return t;
+}
+int CAIAICheats::GetUnitAllyTeam(int unitId) {
+	setCheatsEnabled(true);
+	int t = aiCallback-&gt;GetUnitAllyTeam(unitId);
+	setCheatsEnabled(false);
+	return t;
+}
+float CAIAICheats::GetUnitHealth(int unitId) {
+	setCheatsEnabled(true);
+	float health = aiCallback-&gt;GetUnitHealth(unitId);
+	setCheatsEnabled(false);
+	return health;
+}
+float CAIAICheats::GetUnitMaxHealth(int unitId) {
+	setCheatsEnabled(true);
+	float health = aiCallback-&gt;GetUnitMaxHealth(unitId);
+	setCheatsEnabled(false);
+	return health;
+}
+float CAIAICheats::GetUnitPower(int unitId) {
+	setCheatsEnabled(true);
+	float power = aiCallback-&gt;GetUnitPower(unitId);
+	setCheatsEnabled(false);
+	return power;
+}
+float CAIAICheats::GetUnitExperience(int unitId) {
+	setCheatsEnabled(true);
+	float experience = aiCallback-&gt;GetUnitExperience(unitId);
+	setCheatsEnabled(false);
+	return experience;
+}
+bool CAIAICheats::IsUnitActivated(int unitId) {
+	setCheatsEnabled(true);
+	bool activated = aiCallback-&gt;IsUnitActivated(unitId);
+	setCheatsEnabled(false);
+	return activated;
+}
+bool CAIAICheats::UnitBeingBuilt(int unitId) {
+	setCheatsEnabled(true);
+	bool isBeingBuilt = aiCallback-&gt;UnitBeingBuilt(unitId);
+	setCheatsEnabled(false);
+	return isBeingBuilt;
+}
+bool CAIAICheats::IsUnitNeutral(int unitId) {
+	setCheatsEnabled(true);
+	bool neutral = aiCallback-&gt;IsUnitNeutral(unitId);
+	setCheatsEnabled(false);
+	return neutral;
+}
+bool CAIAICheats::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
+	setCheatsEnabled(true);
+	bool fetchOk = aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+	setCheatsEnabled(false);
+	return fetchOk;
+}
+const CCommandQueue* CAIAICheats::GetCurrentUnitCommands(int unitId) {
+	setCheatsEnabled(true);
+	const CCommandQueue* cc = aiCallback-&gt;GetCurrentUnitCommands(unitId);
+	setCheatsEnabled(false);
+	return cc;
+}
+
+int CAIAICheats::GetBuildingFacing(int unitId) {
+	setCheatsEnabled(true);
+	int facing = aiCallback-&gt;GetBuildingFacing(unitId);
+	setCheatsEnabled(false);
+	return facing;
+}
+bool CAIAICheats::IsUnitCloaked(int unitId) {
+	setCheatsEnabled(true);
+	bool cloaked = aiCallback-&gt;IsUnitCloaked(unitId);
+	setCheatsEnabled(false);
+	return cloaked;
+}
+bool CAIAICheats::IsUnitParalyzed(int unitId) {
+	setCheatsEnabled(true);
+	bool paralyzed = aiCallback-&gt;IsUnitParalyzed(unitId);
+	setCheatsEnabled(false);
+	return paralyzed;
+}
+
+bool CAIAICheats::OnlyPassiveCheats() {
+	return sAICallback-&gt;Cheats_isOnlyPassive(teamId);
+}
+void CAIAICheats::EnableCheatEvents(bool enable) {
+	sAICallback-&gt;Cheats_setEventsEnabled(teamId, enable);
+}
+
+bool CAIAICheats::GetProperty(int id, int property, void* dst) {
+//	setCheatsEnabled(true);
+//	bool fetchOk = aiCallback-&gt;GetProperty(id, property, dst);
+//	setCheatsEnabled(false);
+//	return fetchOk;
+	// this returns always false, cause these values are now available through
+	// individual callback functions -&gt; this method is deprecated
+	return false;
+}
+bool CAIAICheats::GetValue(int id, void* dst) {
+//	setCheatsEnabled(true);
+//	bool fetchOk = aiCallback-&gt;GetValue(id, dst);
+//	setCheatsEnabled(false);
+//	return fetchOk;
+	// this returns always false, cause these values are now available through
+	// individual callback functions -&gt; this method is deprecated
+	return false;
+}
+int CAIAICheats::HandleCommand(int commandId, void* data) {
+	setCheatsEnabled(true);
+	int ret = aiCallback-&gt;HandleCommand(commandId, data);
+	setCheatsEnabled(false);
+	return ret;
+}

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.h	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,81 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _AIAICHEATS_H
-#define	_AIAICHEATS_H
-
-#include &quot;ExternalAI/IAICheats.h&quot;
-#include &quot;ExternalAI/Interface/SAICallback.h&quot;
-#include &quot;AIAICallback.h&quot;
-
-/**
- * The AI side wrapper over the C AI interface for IAICheats.
- */
-class CAIAICheats : public IAICheats {
-public:
-    CAIAICheats();
-    CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback);
-
-
-    virtual void SetMyHandicap(float handicap);
-
-    virtual void GiveMeMetal(float amount);
-    virtual void GiveMeEnergy(float amount);
-
-    virtual int CreateUnit(const char* name, float3 pos);
-
-    virtual const UnitDef* GetUnitDef(int unitid);
-    virtual float3 GetUnitPos(int unitid);
-    virtual int GetEnemyUnits(int* units);
-    virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
-    virtual int GetNeutralUnits(int* units);
-    virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
-
-    virtual int GetUnitTeam(int unitid);
-    virtual int GetUnitAllyTeam(int unitid);
-    virtual float GetUnitHealth(int unitid);
-    virtual float GetUnitMaxHealth(int unitid);
-    virtual float GetUnitPower(int unitid);
-    virtual float GetUnitExperience(int unitid);
-    virtual bool IsUnitActivated(int unitid);
-    virtual bool UnitBeingBuilt(int unitid);
-    virtual bool IsUnitNeutral(int unitid);
-    virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
-    virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
-
-    virtual int GetBuildingFacing(int unitid);
-    virtual bool IsUnitCloaked(int unitid);
-    virtual bool IsUnitParalyzed(int unitid);
-
-    virtual bool OnlyPassiveCheats();
-    virtual void EnableCheatEvents(bool enable);
-
-    virtual bool GetProperty(int id, int property, void* dst);
-    virtual bool GetValue(int id, void* dst);
-    virtual int HandleCommand(int commandId, void* data);
-    
-private:
-    int teamId;
-    SAICallback* sAICallback;
-//    IAICheats* aiCheatCallback;
-//    IAICallback* aiCallback;
-    CAIAICallback* aiCallback;
-    void setCheatsEnabled(bool enable);
-};
-
-
-#endif	/* _AIAICHEATS_H */

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.h)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIAICheats.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,81 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef	_AIAICHEATS_H
+#define	_AIAICHEATS_H
+
+#include &quot;ExternalAI/IAICheats.h&quot;
+
+class SAICallback;
+class CAIAICallback;
+
+/**
+ * The AI side wrapper over the C AI interface for IAICheats.
+ */
+class CAIAICheats : public IAICheats {
+public:
+	CAIAICheats();
+	CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback);
+
+
+	virtual void SetMyHandicap(float handicap);
+
+	virtual void GiveMeMetal(float amount);
+	virtual void GiveMeEnergy(float amount);
+
+	virtual int CreateUnit(const char* name, float3 pos);
+
+	virtual const UnitDef* GetUnitDef(int unitid);
+	virtual float3 GetUnitPos(int unitid);
+	virtual int GetEnemyUnits(int* units);
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
+	virtual int GetNeutralUnits(int* units);
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
+
+	virtual int GetUnitTeam(int unitid);
+	virtual int GetUnitAllyTeam(int unitid);
+	virtual float GetUnitHealth(int unitid);
+	virtual float GetUnitMaxHealth(int unitid);
+	virtual float GetUnitPower(int unitid);
+	virtual float GetUnitExperience(int unitid);
+	virtual bool IsUnitActivated(int unitid);
+	virtual bool UnitBeingBuilt(int unitid);
+	virtual bool IsUnitNeutral(int unitid);
+	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+
+	virtual int GetBuildingFacing(int unitid);
+	virtual bool IsUnitCloaked(int unitid);
+	virtual bool IsUnitParalyzed(int unitid);
+
+	virtual bool OnlyPassiveCheats();
+	virtual void EnableCheatEvents(bool enable);
+
+	virtual bool GetProperty(int id, int property, void* dst);
+	virtual bool GetValue(int id, void* dst);
+	virtual int HandleCommand(int commandId, void* data);
+
+private:
+	int teamId;
+	SAICallback* sAICallback;
+//	IAICheats* aiCheatCallback;
+//	IAICallback* aiCallback;
+	CAIAICallback* aiCallback;
+	void setCheatsEnabled(bool enable);
+};
+
+#endif	// _AIAICHEATS_H

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.cpp	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,33 +0,0 @@
-/*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;AIGlobalAI.h&quot;
-
-CAIGlobalAI::CAIGlobalAI() : CAI(), gai(0) { 
-    
-}
-
-CAIGlobalAI::CAIGlobalAI(int team, IGlobalAI* gai) : CAI(team, gai), gai(gai) {
-    
-}
-
-CAIGlobalAI::~CAIGlobalAI() {
-    delete gai;
-}
-void CAIGlobalAI::InitAI(IGlobalAICallback* globalAICallback, int team) {
-	gai-&gt;InitAI(globalAICallback, team);
-}

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.cpp)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,36 @@
+/*
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#include &quot;AIGlobalAI.h&quot;
+
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+
+CAIGlobalAI::CAIGlobalAI() : CAI(), gai(NULL) {}
+
+CAIGlobalAI::CAIGlobalAI(int teamId, IGlobalAI* gai) : CAI(teamId, gai), gai(gai) {}
+
+CAIGlobalAI::~CAIGlobalAI() {
+	delete gai;
+}
+
+void CAIGlobalAI::InitAI(IGlobalAICallback* globalAICallback, int teamId) {
+	gai-&gt;InitAI(globalAICallback, teamId);
+}

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.h	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,37 +0,0 @@
-/*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef AIGLOBALAI_H
-#define AIGLOBALAI_H
-
-
-#include &quot;ExternalAI/IGlobalAI.h&quot;
-#include &quot;AI.h&quot;
-#include &quot;ExternalAI/IGlobalAICallback.h&quot; // Remove
-
-class CAIGlobalAI : public CAI {
-public:
-    CAIGlobalAI();
-    CAIGlobalAI(int team, IGlobalAI* gai);
-    ~CAIGlobalAI();
-
-    void InitAI(IGlobalAICallback* globalAICallback, int team);
-    
-    IGlobalAI* gai;
-};
-
-#endif /*AIGLOBALAI_H*/

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.h)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAI.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,40 @@
+/*
+	Copyright 2008  Nicolas Wu
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
+
+#ifndef	AIGLOBALAI_H
+#define	AIGLOBALAI_H
+
+#include &quot;AI.h&quot;
+
+class IGlobalAI;
+class IGlobalAICallback;
+
+class CAIGlobalAI : public CAI {
+public:
+	CAIGlobalAI();
+	CAIGlobalAI(int teamId, IGlobalAI* gai);
+	~CAIGlobalAI();
+
+	void InitAI(IGlobalAICallback* globalAICallback, int teamId);
+
+	IGlobalAI* gai;
+};
+
+#endif	// _AIGLOBALAI_H

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,54 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#include &quot;AIGlobalAICallback.h&quot;
-#include &quot;AIAICallback.h&quot;
-#include &quot;AIAICheats.h&quot;
-
-CAIGlobalAICallback::CAIGlobalAICallback()
-    : IGlobalAICallback(), sAICallback(NULL), teamId(-1),
-        wrappedAICallback(NULL), wrappedAICheats(NULL) {
-    
-}
-
-CAIGlobalAICallback::CAIGlobalAICallback(SAICallback* sAICallback, int teamId)
-    : IGlobalAICallback(), sAICallback(sAICallback), teamId(teamId),
-        wrappedAICallback(NULL), wrappedAICheats(NULL) {
-    
-}
-
-CAIGlobalAICallback::~CAIGlobalAICallback() {
-    
-}
-
-
-IAICallback* CAIGlobalAICallback::GetAICallback() {
-    
-    if (wrappedAICallback == NULL) {
-        wrappedAICallback = new CAIAICallback(teamId, sAICallback);
-    }
-    return wrappedAICallback;
-}
-
-IAICheats* CAIGlobalAICallback::GetCheatInterface() {
-    
-    if (wrappedAICheats == NULL) {
-        this-&gt;GetAICallback(); // to initialize
-        wrappedAICheats = new CAIAICheats(teamId, sAICallback, wrappedAICallback);
-    }
-    return wrappedAICheats;
-}

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,50 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;AIGlobalAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
+#include &quot;AIAICheats.h&quot;
+
+CAIGlobalAICallback::CAIGlobalAICallback()
+	: IGlobalAICallback(), sAICallback(NULL), teamId(-1),
+		wrappedAICallback(NULL), wrappedAICheats(NULL) {}
+
+CAIGlobalAICallback::CAIGlobalAICallback(SAICallback* sAICallback, int teamId)
+	: IGlobalAICallback(), sAICallback(sAICallback), teamId(teamId),
+		wrappedAICallback(NULL), wrappedAICheats(NULL) {}
+
+CAIGlobalAICallback::~CAIGlobalAICallback() {}
+
+
+IAICallback* CAIGlobalAICallback::GetAICallback() {
+
+	if (wrappedAICallback == NULL) {
+		wrappedAICallback = new CAIAICallback(teamId, sAICallback);
+	}
+
+	return wrappedAICallback;
+}
+
+IAICheats* CAIGlobalAICallback::GetCheatInterface() {
+
+	if (wrappedAICheats == NULL) {
+		this-&gt;GetAICallback(); // to initialize
+		wrappedAICheats = new CAIAICheats(teamId, sAICallback, wrappedAICallback);
+	}
+
+	return wrappedAICheats;
+}

Deleted: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.h	2008-11-04 10:46:28 UTC (rev 6976)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -1,47 +0,0 @@
-/*
-	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
-*/
-
-#ifndef _AIGLOBALAICALLBACK_H
-#define	_AIGLOBALAICALLBACK_H
-
-#include &quot;ExternalAI/Interface/SAICallback.h&quot;
-#include &quot;ExternalAI/IGlobalAICallback.h&quot;
-
-#include &quot;AIAICallback.h&quot;
-#include &quot;AIAICheats.h&quot;
-
-/**
- * The AI side wrapper over the C AI interface for IGlobalAICallback.
- */
-class CAIGlobalAICallback : public IGlobalAICallback {
-public:
-    CAIGlobalAICallback();
-    CAIGlobalAICallback(SAICallback* sAICallback, int teamId);
-    ~CAIGlobalAICallback();
-
-    virtual IAICheats* GetCheatInterface();
-    virtual IAICallback* GetAICallback();
-    
-private:
-    SAICallback* sAICallback;
-    int teamId;
-    CAIAICallback* wrappedAICallback;
-    CAIAICheats* wrappedAICheats;
-};
-
-#endif	/* _AIGLOBALAICALLBACK_H */
-

Copied: branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h (from rev 7021, branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.h)
===================================================================
--- branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h	                        (rev 0)
+++ branches/caiinterface/AI/Wrappers/LegacyCpp/AIGlobalAICallback.h	2008-11-13 09:58:08 UTC (rev 7034)
@@ -0,0 +1,50 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef	_AIGLOBALAICALLBACK_H
+#define	_AIGLOBALAICALLBACK_H
+
+//#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
+
+//#include &quot;AIAICallback.h&quot;
+//#include &quot;AIAICheats.h&quot;
+
+struct SAICallback;
+class CAIAICallback;
+class CAIAICheats;
+
+/**
+ * The AI side wrapper over the C AI interface for IGlobalAICallback.
+ */
+class CAIGlobalAICallback : public IGlobalAICallback {
+public:
+	CAIGlobalAICallback();
+	CAIGlobalAICallback(SAICallback* sAICallback, int teamId);
+	~CAIGlobalAICallback();
+
+	virtual IAICheats* GetCheatInterface();
+	virtual IAICallback* GetAICallback();
+
+private:
+	SAICallback* sAICallback;
+	int teamId;
+	CAIAICallback* wrappedAICallback;
+	CAIAICheats* wrappedAICheats;
+};
+
+#endif	// _AIGLOBALAICALLBACK_H

Modified: branches/caiinterface/directories.txt
===================================================================
--- branches/caiinterface/directories.txt	2008-11-13 09:37:35 UTC (rev 7033)
+++ branches/caiinterface/directories.txt	2008-11-13 09:58:08 UTC (rev 7034)
@@ -51,9 +51,9 @@
 
 AI                                AI sourcecode..
 AI/Interfaces                     ..for interfaceing with Skirmish and Group AIs (Interfaces/impls)
-AI/Bindings                       meta AI interfaces (consist only of code that will be integrated into AI binaries)
-AI/Bindings/LegacyCpp             ..for letting Legacy C++ AIs interface with the C AI Interface
-AI/Bindings/LegacyCpp/Event             ..and Event classes needed for that
+AI/Wrappers                       meta AI interfaces (consist only of code that will be integrated into AI binaries)
+AI/Wrappers/LegacyCpp             ..for letting Legacy C++ AIs interface with the C AI Interface
+AI/Wrappers/LegacyCpp/Event             ..and Event classes needed for that
 AI/Skirmish                       ..for SkirmishAIs (Skirmish/impls)
 AI/Group                          ..for GroupAIs (Helper-libs)
 

Modified: branches/caiinterface/rts/build/scons/filelist.py
===================================================================
--- branches/caiinterface/rts/build/scons/filelist.py	2008-11-13 09:37:35 UTC (rev 7033)
+++ branches/caiinterface/rts/build/scons/filelist.py	2008-11-13 09:58:08 UTC (rev 7034)
@@ -180,12 +180,12 @@
 	if env.has_key('builddir') and env['builddir']:
 		result += [os.path.join(env['builddir'], 'rts/System/float3.cpp')]
 		result += [os.path.join(env['builddir'], 'rts/Sim/Misc/DamageArray.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AISCommands.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AIAICallback.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AIAICheats.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AIGlobalAI.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AI.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AISCommands.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AIAICallback.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AIAICheats.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AIGlobalAICallback.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AIGlobalAI.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AI.cpp')]
 	return result
 # list Creg source files (used by some Skirmish AI libraries)
 def get_shared_skirmishAI_source_Creg(env):
@@ -204,7 +204,7 @@
 	if env.has_key('builddir') and env['builddir']:
 		result += [os.path.join(env['builddir'], 'rts/System/float3.cpp')]
 		result += [os.path.join(env['builddir'], 'rts/Sim/Misc/DamageArray.cpp')]
-		result += [os.path.join(env['builddir'], 'AI/Bindings/LegacyCpp/AISCommands.cpp')]
+		result += [os.path.join(env['builddir'], 'AI/Wrappers/LegacyCpp/AISCommands.cpp')]
 	return result
 # list Creg source files (used by some Group AI libraries)
 def get_shared_groupAI_source_Creg(env):


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001802.html">[Taspring-linux-commit] r7033 - in trunk: . AI AI/Global/AAI	AI/Global/JCAI AI/Global/KAI-0.2 AI/Global/KAIK-0.13	AI/Global/NTai/AI/NTai/Agents AI/Global/NTai/AI/NTai/Helpers/Terrain	AI/Global/NTai/AI/NTai/Tasks AI/Global/NTai/AI/NTai/Units	AI/Global/RAI rts tools/DedicatedServer
</A></li>
	<LI>Next message: <A HREF="001804.html">[Taspring-linux-commit] r7035 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1803">[ date ]</a>
              <a href="thread.html#1803">[ thread ]</a>
              <a href="subject.html#1803">[ subject ]</a>
              <a href="author.html#1803">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
