<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7021 - in branches/caiinterface:	AI/Bindings/LegacyCpp rts/ExternalAI rts/ExternalAI/Interface	rts/Game
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-November/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7021%20-%20in%20branches/caiinterface%3A%0A%09AI/Bindings/LegacyCpp%20rts/ExternalAI%20rts/ExternalAI/Interface%0A%09rts/Game&In-Reply-To=%3C20081111160945.A1FB5475F%40progate.clan-sy.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001789.html">
   <LINK REL="Next"  HREF="001791.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7021 - in branches/caiinterface:	AI/Bindings/LegacyCpp rts/ExternalAI rts/ExternalAI/Interface	rts/Game</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7021%20-%20in%20branches/caiinterface%3A%0A%09AI/Bindings/LegacyCpp%20rts/ExternalAI%20rts/ExternalAI/Interface%0A%09rts/Game&In-Reply-To=%3C20081111160945.A1FB5475F%40progate.clan-sy.com%3E"
       TITLE="[Taspring-linux-commit] r7021 - in branches/caiinterface:	AI/Bindings/LegacyCpp rts/ExternalAI rts/ExternalAI/Interface	rts/Game">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Tue Nov 11 17:09:45 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001789.html">[Taspring-linux-commit] r7020 - in Lobby/TASClient: . Interface
</A></li>
        <LI>Next message: <A HREF="001791.html">[Taspring-linux-commit] r7022 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1790">[ date ]</a>
              <a href="thread.html#1790">[ thread ]</a>
              <a href="subject.html#1790">[ subject ]</a>
              <a href="author.html#1790">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: hoijui
Date: 2008-11-11 17:09:44 +0100 (Tue, 11 Nov 2008)
New Revision: 7021

Added:
   branches/caiinterface/rts/ExternalAI/EngineOutHandler.cpp
   branches/caiinterface/rts/ExternalAI/EngineOutHandler.h
   branches/caiinterface/rts/ExternalAI/GroupAI.cpp
   branches/caiinterface/rts/ExternalAI/GroupAI.h
   branches/caiinterface/rts/ExternalAI/GroupAIWrapper.cpp
   branches/caiinterface/rts/ExternalAI/GroupAIWrapper.h
Modified:
   branches/caiinterface/AI/Bindings/LegacyCpp/AI.cpp
   branches/caiinterface/AI/Bindings/LegacyCpp/AI.h
   branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.cpp
   branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.h
   branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.cpp
   branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.h
   branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.cpp
   branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.h
   branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp
   branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.h
   branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp
   branches/caiinterface/rts/ExternalAI/Group.h
   branches/caiinterface/rts/ExternalAI/GroupHandler.cpp
   branches/caiinterface/rts/ExternalAI/GroupHandler.h
   branches/caiinterface/rts/ExternalAI/IGroupAI.h
   branches/caiinterface/rts/ExternalAI/IGroupAiCallback.h
   branches/caiinterface/rts/ExternalAI/ISkirmishAI.h
   branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
   branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h
   branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
   branches/caiinterface/rts/ExternalAI/SAICallback.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAI.h
   branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp
   branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h
   branches/caiinterface/rts/ExternalAI/aikey.h
   branches/caiinterface/rts/Game/Game.cpp
   branches/caiinterface/rts/Game/GlobalConstants.h
Log:
DOES NOT COMPILE, temporary commit (kind of a local backup)

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AI.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AI.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AI.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -20,15 +20,11 @@
 #include &quot;ExternalAI/IGlobalAI.h&quot;
 #include &quot;ExternalAI/Interface/AISEvents.h&quot;
 
-CAI::CAI() : team(0), ai(NULL) {
+CAI::CAI() : team(0), ai(NULL) {}
 
-}
+CAI::CAI(int team, IGlobalAI* ai) : team(team), ai(ai) {}
 
 
-CAI::CAI(int team, IGlobalAI* ai) : team(team), ai(ai) {
-
-}
-
 int CAI::handleEvent(int topic, const void* data) {
 
 	if (ai != NULL) {

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AI.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AI.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AI.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,22 +1,25 @@
 /*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+	Copyright 2008  Nicolas Wu
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
 
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
 */
 
-#ifndef AI_H
-#define AI_H
+#ifndef	AI_H
+#define	AI_H
 
 class IGlobalAI;
 
@@ -24,7 +27,7 @@
 public:
 	CAI();
 	CAI(int team, IGlobalAI* ai);
-	
+
 	/**
 	 * Through this function, the AI receives events from the engine.
 	 * For details about events that may arrive here, see file AISEvents.h.
@@ -42,4 +45,4 @@
 	IGlobalAI* ai;
 };
 
-#endif	// AI_H
+#endif	// _AI_H

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -17,6 +17,8 @@
 
 #include &quot;AIAICallback.h&quot;
 
+
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
 #include &quot;ExternalAI/Interface/AISCommands.h&quot;
 
 #include &quot;creg/creg_cond.h&quot;
@@ -61,21 +63,21 @@
 }
 
 void CAIAICallback::init() {
-	
+
 	// init caches
 	int maxCacheSize = 512;
 	int maxUnits = 10000;
 	int maxGroups = 100;
-	
+
 	weaponDefs = new WeaponDef*[maxCacheSize]; fillWithNULL((void**)weaponDefs, maxCacheSize);
 	weaponDefFrames = new int[maxCacheSize]; fillWithMinusOne(weaponDefFrames, maxCacheSize);
-	
+
 	unitDefs = new UnitDef*[maxCacheSize]; fillWithNULL((void**)unitDefs, maxCacheSize);
 	unitDefFrames = new int[maxCacheSize]; fillWithMinusOne(unitDefFrames, maxCacheSize);
 	groupPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxGroups]; fillWithNULL((void**)groupPossibleCommands, maxGroups);
 	unitPossibleCommands = new std::vector&lt;CommandDescription&gt;*[maxUnits]; fillWithNULL((void**)unitPossibleCommands, maxUnits);
 	unitCurrentCommandQueues = new CCommandQueue*[maxUnits]; fillWithNULL((void**)unitCurrentCommandQueues, maxUnits);
-	
+
 	featureDefs = new FeatureDef*[maxCacheSize]; fillWithNULL((void**)featureDefs, maxCacheSize);
 	featureDefFrames = new int[maxCacheSize]; fillWithMinusOne(featureDefFrames, maxCacheSize);
 }
@@ -647,39 +649,39 @@
 		}
 		cmdDescVec-&gt;push_back(commandDescription);
 	}
-	
+
 	// to prevent memory wholes
 	if (groupPossibleCommands[groupId] != NULL) {
 		delete groupPossibleCommands[groupId];
 	}
 	groupPossibleCommands[groupId] = cmdDescVec;
-	
+
 	return cmdDescVec;
 }
 */
 const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetGroupCommands(int groupId) {
-	
+
 	int numCmds = sAICallback-&gt;Group_getNumSupportedCommands(teamId, groupId);
-	
+
 	int ids[numCmds];
 	const char* names[numCmds];
 	const char* toolTips[numCmds];
 	bool showUniques[numCmds];
 	bool disableds[numCmds];
 	int numParams[numCmds];
-	
+
 	sAICallback-&gt;Group_SupportedCommands_getId(teamId, groupId, ids);
 	sAICallback-&gt;Group_SupportedCommands_getName(teamId, groupId, names);
 	sAICallback-&gt;Group_SupportedCommands_getToolTip(teamId, groupId, toolTips);
 	sAICallback-&gt;Group_SupportedCommands_isShowUnique(teamId, groupId, showUniques);
 	sAICallback-&gt;Group_SupportedCommands_isDisabled(teamId, groupId, disableds);
 	sAICallback-&gt;Group_SupportedCommands_getNumParams(teamId, groupId, numParams);
-	
+
 	std::vector&lt;CommandDescription&gt;* cmdDescVec = new std::vector&lt;CommandDescription&gt;();
 	for (int c=0; c &lt; numCmds; c++) {
 		const char* params[numParams[c]];
 		sAICallback-&gt;Group_SupportedCommands_getParams(teamId, groupId, c, params);
-		
+
 		CommandDescription commandDescription;
 		commandDescription.id = ids[c];
 		commandDescription.name = names[c];
@@ -691,28 +693,28 @@
 		}
 		cmdDescVec-&gt;push_back(commandDescription);
 	}
-	
+
 	// to prevent memory wholes
 	if (groupPossibleCommands[groupId] != NULL) {
 		delete groupPossibleCommands[groupId];
 	}
 	groupPossibleCommands[groupId] = cmdDescVec;
-	
+
 	return cmdDescVec;
 }
 
 
 const std::vector&lt;CommandDescription&gt;* CAIAICallback::GetUnitCommands(int unitId) {
-	
+
 	int numCmds = sAICallback-&gt;Unit_getNumSupportedCommands(teamId, unitId);
-	
+
 	int* ids = new int[numCmds];
 	const char* names[numCmds];
 	const char* toolTips[numCmds];
 	bool showUniques[numCmds];
 	bool disableds[numCmds];
 	int numParams[numCmds];
-	
+
 	sAICallback-&gt;Unit_SupportedCommands_getId(teamId, unitId, ids);
 	sAICallback-&gt;Unit_SupportedCommands_getName(teamId, unitId, names);
 	sAICallback-&gt;Unit_SupportedCommands_getToolTip(teamId, unitId, toolTips);
@@ -724,7 +726,7 @@
 	for (int c=0; c &lt; numCmds; c++) {
 		const char* params[numParams[c]];
 		sAICallback-&gt;Unit_SupportedCommands_getParams(teamId, unitId, c, params);
-		
+
 		CommandDescription commandDescription;
 		commandDescription.id = ids[c];
 		commandDescription.name = names[c];
@@ -736,13 +738,13 @@
 		}
 		cmdDescVec-&gt;push_back(commandDescription);
 	}
-	
+
 	// to prevent memory wholes
 	if (unitPossibleCommands[unitId] != NULL) {
 		delete unitPossibleCommands[unitId];
 	}
 	unitPossibleCommands[unitId] = cmdDescVec;
-	
+
 	return cmdDescVec;
 }
 
@@ -778,13 +780,13 @@
 		}
 		cc-&gt;push_back(command);
 	}
-	
+
 	// to prevent memory wholes
 	if (unitCurrentCommandQueues[unitId] != NULL) {
 		delete unitCurrentCommandQueues[unitId];
 	}
 	unitCurrentCommandQueues[unitId] = cc;
-	
+
 	return cc;
 }
 
@@ -874,11 +876,11 @@
 
 const UnitDef* CAIAICallback::GetUnitDefById(int unitDefId) {
 	//logT(&quot;entering: GetUnitDefById sAICallback&quot;);
-	
+
 	if (unitDefId &lt; 0) {
 		return NULL;
 	}
-	
+
 	bool doRecreate = unitDefFrames[unitDefId] &lt; 0;
 	if (doRecreate) {
 //		int currentFrame = this-&gt;GetCurrentFrame();
@@ -1112,7 +1114,7 @@
 	unitDef-&gt;movedata = new MoveData(NULL, -1);
 		unitDef-&gt;movedata-&gt;moveType = (enum MoveData::MoveType)sAICallback-&gt;UnitDef_MoveData_getMoveType(teamId, unitDefId);
 		unitDef-&gt;movedata-&gt;moveFamily = (enum MoveData::MoveFamily) sAICallback-&gt;UnitDef_MoveData_getMoveFamily(teamId, unitDefId);
-        unitDef-&gt;movedata-&gt;size = sAICallback-&gt;UnitDef_MoveData_getSize(teamId, unitDefId);
+		unitDef-&gt;movedata-&gt;size = sAICallback-&gt;UnitDef_MoveData_getSize(teamId, unitDefId);
 		unitDef-&gt;movedata-&gt;depth = sAICallback-&gt;UnitDef_MoveData_getDepth(teamId, unitDefId);
 		unitDef-&gt;movedata-&gt;maxSlope = sAICallback-&gt;UnitDef_MoveData_getMaxSlope(teamId, unitDefId);
 		unitDef-&gt;movedata-&gt;slopeMod = sAICallback-&gt;UnitDef_MoveData_getSlopeMod(teamId, unitDefId);
@@ -1270,28 +1272,28 @@
 */
 bool CAIAICallback::GetProperty(int unitId, int propertyId, void *data)
 {
-    switch (propertyId) {
-        case AIVAL_UNITDEF: {
-            return false;
-        }
-        case AIVAL_CURRENT_FUEL: {
-            (*(float*)data) = sAICallback-&gt;Unit_getCurrentFuel(teamId, unitId);
-            return (*(float*)data) != -1.0f;
-        }
-        case AIVAL_STOCKPILED: {
-            (*(int*)data) = sAICallback-&gt;Unit_getStockpile(teamId, unitId);
-            return (*(int*)data) != -1;
-        }
-        case AIVAL_STOCKPILE_QUED: {
-            (*(int*)data) = sAICallback-&gt;Unit_getStockpileQueued(teamId, unitId);
-            return (*(int*)data) != -1;
-        }
-        case AIVAL_UNIT_MAXSPEED: {
-            (*(float*) data) = sAICallback-&gt;Unit_getMaxSpeed(teamId, unitId);
-            return (*(float*)data) != -1.0f;
-        }
-        default:
-            return false;
+	switch (propertyId) {
+		case AIVAL_UNITDEF: {
+			return false;
+		}
+		case AIVAL_CURRENT_FUEL: {
+			(*(float*)data) = sAICallback-&gt;Unit_getCurrentFuel(teamId, unitId);
+			return (*(float*)data) != -1.0f;
+		}
+		case AIVAL_STOCKPILED: {
+			(*(int*)data) = sAICallback-&gt;Unit_getStockpile(teamId, unitId);
+			return (*(int*)data) != -1;
+		}
+		case AIVAL_STOCKPILE_QUED: {
+			(*(int*)data) = sAICallback-&gt;Unit_getStockpileQueued(teamId, unitId);
+			return (*(int*)data) != -1;
+		}
+		case AIVAL_UNIT_MAXSPEED: {
+			(*(float*) data) = sAICallback-&gt;Unit_getMaxSpeed(teamId, unitId);
+			return (*(float*)data) != -1.0f;
+		}
+		default:
+			return false;
 	}
 	return false;
 }
@@ -1342,10 +1344,10 @@
 			*(float3*)data = sAICallback-&gt;Gui_Camera_getPosition(teamId);
 			return true;
 		}case AIVAL_LOCATE_FILE_R:{
-            sAICallback-&gt;File_locateForReading(teamId, (char*) data);
+			sAICallback-&gt;File_locateForReading(teamId, (char*) data);
 			return true;
 		}case AIVAL_LOCATE_FILE_W:{
-            sAICallback-&gt;File_locateForWriting(teamId, (char*) data);
+			sAICallback-&gt;File_locateForWriting(teamId, (char*) data);
 			return true;
 		}
 		case AIVAL_UNIT_LIMIT: {
@@ -1374,12 +1376,12 @@
 }
 
 int CAIAICallback::GetMapPoints(PointMarker* pm, int maxPoints) {
-	
+
 	SAIFloat3* positions = new SAIFloat3[maxPoints];
 //	unsigned char** colors = new unsigned char*[maxPoints];
 	SAIFloat3* colors = new SAIFloat3[maxPoints];
 	const char** labels = new const char*[maxPoints];
-	
+
 	int numPoints = sAICallback-&gt;Map_getPoints(teamId, positions, colors, labels, maxPoints);
 	for (int i=0; i &lt; numPoints; ++i) {
 		pm[i].pos = float3(positions[i]);
@@ -1397,11 +1399,11 @@
 }
 
 int CAIAICallback::GetMapLines(LineMarker* lm, int maxLines) {
-	
+
 	SAIFloat3* firstPositions = new SAIFloat3[maxLines];
 	SAIFloat3* secondPositions = new SAIFloat3[maxLines];
 	SAIFloat3* colors = new SAIFloat3[maxLines];
-	
+
 	int numLines = sAICallback-&gt;Map_getLines(teamId, firstPositions, secondPositions, colors, maxLines);
 	for (int i=0; i &lt; numLines; ++i) {
 		lm[i].pos = float3(firstPositions[i]);
@@ -1463,11 +1465,11 @@
 }
 
 const FeatureDef* CAIAICallback::GetFeatureDefById(int featureDefId) {
-	
+
 	if (featureDefId &lt; 0) {
 		return NULL;
 	}
-	
+
 	bool doRecreate = featureDefFrames[featureDefId] &lt; 0;
 	if (doRecreate) {
 //		int currentFrame = this-&gt;GetCurrentFrame();
@@ -1563,12 +1565,12 @@
 }
 
 const WeaponDef* CAIAICallback::GetWeaponDefById(int weaponDefId) {
-	
+
 //	logT(&quot;entering: GetWeaponDefById sAICallback&quot;);
 	if (weaponDefId &lt; 0) {
 		return NULL;
 	}
-	
+
 	bool doRecreate = weaponDefFrames[weaponDefId] &lt; 0;
 	if (doRecreate) {
 //		int currentFrame = this-&gt;GetCurrentFrame();
@@ -1845,12 +1847,12 @@
 }
 
 int CAIAICallback::Internal_GiveOrder(int unitId, int groupId, Command* c) {
-	
+
 /*
 	int ret = -1;
-	
+
 	switch (c-&gt;id) {
-        case CMD_STOP:
+		case CMD_STOP:
 		{
 			SStopUnitCommand cmd = {unitId, groupId, c-&gt;options, c-&gt;timeOut};
 			ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_UNIT_STOP, &amp;cmd);
@@ -2140,17 +2142,17 @@
 		}
 
 	}
-	
+
 	return ret;
 */
-    int sCommandId;
-    void* sCommandData = mallocSUnitCommand(unitId, groupId, c, &amp;sCommandId);
-    
-    int ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, sCommandId, sCommandData);
-    
-    freeSUnitCommand(sCommandData, sCommandId);
-    
-    return ret;
+	int sCommandId;
+	void* sCommandData = mallocSUnitCommand(unitId, groupId, c, &amp;sCommandId);
+
+	int ret = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, sCommandId, sCommandData);
+
+	freeSUnitCommand(sCommandData, sCommandId);
+
+	return ret;
 }
 
 int CAIAICallback::InitPath(float3 start, float3 end, int pathType) {
@@ -2231,10 +2233,10 @@
 }
 
 int CAIAICallback::HandleCommand(int commandId, void* data) {
-	
+
 	int cmdTopicIndex = commandId;
 	int ret = -99;
-	
+
 	switch (commandId) {
 		case AIHCQuerySubVersionId: {
 //			SQuerySubVersionCommand cmd;
@@ -2267,7 +2269,7 @@
 			break;
 		}
 	}
-	
+
 	return ret;
 }
 

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIAICallback.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -18,17 +18,17 @@
 #ifndef _AIAICALLBACK_H
 #define	_AIAICALLBACK_H
 
-
-#include &quot;ExternalAI/Interface/SAICallback.h&quot;
 #include &quot;ExternalAI/IAICallback.h&quot;
 
+struct SAICallback;
+
 /**
  * The AI side wrapper over the C AI interface for IAICallback.
  */
 class CAIAICallback : public IAICallback {
 public:
-    CAIAICallback();
-    CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/);
+	CAIAICallback();
+	CAIAICallback(int teamId, SAICallback* sAICallback/*, IAICallback* aiCallback*/);
 
 	virtual void SendTextMsg(const char* text, int zone);
 	virtual void SetLastMsgPos(float3 pos);
@@ -190,24 +190,24 @@
 	virtual const char* CallLuaRules(const char* data, int inSize = -1, int* outSize = NULL);
 
 private:
-    int teamId;
-    SAICallback* sAICallback;
-//    IAICallback* aiCallback;
-//    int currentFrame;
-    void init();
-//    void setCurrentFrame(int frame) { currentFrame = frame; }
-    int Internal_GiveOrder(int unitId, int groupId, Command* c);
-    
+	int teamId;
+	SAICallback* sAICallback;
+//	IAICallback* aiCallback;
+//	int currentFrame;
+	void init();
+//	void setCurrentFrame(int frame) { currentFrame = frame; }
+	int Internal_GiveOrder(int unitId, int groupId, Command* c);
+
 	// caches
-    WeaponDef** weaponDefs;
-    int* weaponDefFrames;
-    UnitDef** unitDefs;
-    int* unitDefFrames;
+	WeaponDef** weaponDefs;
+	int* weaponDefFrames;
+	UnitDef** unitDefs;
+	int* unitDefFrames;
 	std::vector&lt;CommandDescription&gt;** groupPossibleCommands; // needed to prevent memory leacks
 	std::vector&lt;CommandDescription&gt;** unitPossibleCommands; // needed to prevent memory leacks
 	CCommandQueue** unitCurrentCommandQueues; // needed to prevent memory leacks
-    FeatureDef** featureDefs;
-    int* featureDefFrames;
+	FeatureDef** featureDefs;
+	int* featureDefFrames;
 };
 
 #endif	/* _AIAICALLBACK_H */

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -17,203 +17,205 @@
 
 #include &quot;AIAICheats.h&quot;
 
+#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+#include &quot;AIAICallback.h&quot;
 #include &quot;ExternalAI/Interface/AISCommands.h&quot;
 
 
 CAIAICheats::CAIAICheats()
-    : IAICheats(), teamId(-1), sAICallback(NULL)/*, aiCheatCallback(NULL)*/, aiCallback(NULL) {
-    
-}
+	: IAICheats(), teamId(-1), sAICallback(NULL)/*, aiCheatCallback(NULL)*/,
+		aiCallback(NULL) {}
 
-CAIAICheats::CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback)
-    : IAICheats(), teamId(teamId), sAICallback(sAICallback)/*, aiCheatCallback(aiCheatCallback)*/, aiCallback(aiCallback) {
-    
-}
+CAIAICheats::CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/,
+		CAIAICallback* aiCallback)
+	: IAICheats(), teamId(teamId), sAICallback(sAICallback)/*, aiCheatCallback(aiCheatCallback)*/,
+		aiCallback(aiCallback) {}
 
 void CAIAICheats::setCheatsEnabled(bool enabled) {
-    sAICallback-&gt;Cheats_setEnabled(teamId, enabled);
+	sAICallback-&gt;Cheats_setEnabled(teamId, enabled);
 }
 
 
 void CAIAICheats::SetMyHandicap(float handicap) {
-    setCheatsEnabled(true);
-    SSetMyHandicapCheatCommand cmd = {handicap};
-    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_SET_MY_HANDICAP, &amp;cmd);
-    setCheatsEnabled(false);
+	setCheatsEnabled(true);
+	SSetMyHandicapCheatCommand cmd = {handicap};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1,
+			COMMAND_CHEATS_SET_MY_HANDICAP, &amp;cmd);
+	setCheatsEnabled(false);
 }
 void CAIAICheats::GiveMeMetal(float amount) {
-    setCheatsEnabled(true);
-    SGiveMeMetalCheatCommand cmd = {amount};
-    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_METAL, &amp;cmd);
-    setCheatsEnabled(false);
+	setCheatsEnabled(true);
+	SGiveMeMetalCheatCommand cmd = {amount};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_METAL, &amp;cmd);
+	setCheatsEnabled(false);
 }
 void CAIAICheats::GiveMeEnergy(float amount) {
-    setCheatsEnabled(true);
-    SGiveMeEnergyCheatCommand cmd = {amount};
-    sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_ENERGY, &amp;cmd);
-    setCheatsEnabled(false);
+	setCheatsEnabled(true);
+	SGiveMeEnergyCheatCommand cmd = {amount};
+	sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_ENERGY, &amp;cmd);
+	setCheatsEnabled(false);
 }
 
 int CAIAICheats::CreateUnit(const char* unitDefName, float3 pos) {
-    setCheatsEnabled(true);
-    int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitDefName);
-    SGiveMeNewUnitCheatCommand cmd = {unitDefId, pos.toSAIFloat3()};
-    int unitId = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_NEW_UNIT, &amp;cmd);
-    setCheatsEnabled(false);
-    return unitId;
+	setCheatsEnabled(true);
+	int unitDefId = sAICallback-&gt;UnitDef_STATIC_getIdByName(teamId, unitDefName);
+	SGiveMeNewUnitCheatCommand cmd = {unitDefId, pos.toSAIFloat3()};
+	int unitId = sAICallback-&gt;handleCommand(teamId, COMMAND_TO_ID_ENGINE, -1, COMMAND_CHEATS_GIVE_ME_NEW_UNIT, &amp;cmd);
+	setCheatsEnabled(false);
+	return unitId;
 }
 
 const UnitDef* CAIAICheats::GetUnitDef(int unitId) {
-    setCheatsEnabled(true);
-    const UnitDef* unitDef = aiCallback-&gt;GetUnitDef(unitId);
-    setCheatsEnabled(false);
-    return unitDef;
+	setCheatsEnabled(true);
+	const UnitDef* unitDef = aiCallback-&gt;GetUnitDef(unitId);
+	setCheatsEnabled(false);
+	return unitDef;
 }
 float3 CAIAICheats::GetUnitPos(int unitId) {
-    setCheatsEnabled(true);
-    float3 pos = aiCallback-&gt;GetUnitPos(unitId);
-    setCheatsEnabled(false);
-    return pos;
+	setCheatsEnabled(true);
+	float3 pos = aiCallback-&gt;GetUnitPos(unitId);
+	setCheatsEnabled(false);
+	return pos;
 }
 int CAIAICheats::GetEnemyUnits(int* unitIds) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds);
-    setCheatsEnabled(false);
-    return numUnits;
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds);
+	setCheatsEnabled(false);
+	return numUnits;
 }
 int CAIAICheats::GetEnemyUnits(int* unitIds, const float3&amp; pos, float radius) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
-    setCheatsEnabled(false);
-    return numUnits;
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetEnemyUnits(unitIds, pos, radius);
+	setCheatsEnabled(false);
+	return numUnits;
 }
 int CAIAICheats::GetNeutralUnits(int* unitIds) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds);
-    setCheatsEnabled(false);
-    return numUnits;
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds);
+	setCheatsEnabled(false);
+	return numUnits;
 }
 int CAIAICheats::GetNeutralUnits(int* unitIds, const float3&amp; pos, float radius) {
-    setCheatsEnabled(true);
-    int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
-    setCheatsEnabled(false);
-    return numUnits;
+	setCheatsEnabled(true);
+	int numUnits = aiCallback-&gt;GetNeutralUnits(unitIds, pos, radius);
+	setCheatsEnabled(false);
+	return numUnits;
 }
 
 int CAIAICheats::GetUnitTeam(int unitId) {
-    setCheatsEnabled(true);
-    int t = aiCallback-&gt;GetUnitTeam(unitId);
-    setCheatsEnabled(false);
-    return t;
+	setCheatsEnabled(true);
+	int t = aiCallback-&gt;GetUnitTeam(unitId);
+	setCheatsEnabled(false);
+	return t;
 }
 int CAIAICheats::GetUnitAllyTeam(int unitId) {
-    setCheatsEnabled(true);
-    int t = aiCallback-&gt;GetUnitAllyTeam(unitId);
-    setCheatsEnabled(false);
-    return t;
+	setCheatsEnabled(true);
+	int t = aiCallback-&gt;GetUnitAllyTeam(unitId);
+	setCheatsEnabled(false);
+	return t;
 }
 float CAIAICheats::GetUnitHealth(int unitId) {
-    setCheatsEnabled(true);
-    float health = aiCallback-&gt;GetUnitHealth(unitId);
-    setCheatsEnabled(false);
-    return health;
+	setCheatsEnabled(true);
+	float health = aiCallback-&gt;GetUnitHealth(unitId);
+	setCheatsEnabled(false);
+	return health;
 }
 float CAIAICheats::GetUnitMaxHealth(int unitId) {
-    setCheatsEnabled(true);
-    float health = aiCallback-&gt;GetUnitMaxHealth(unitId);
-    setCheatsEnabled(false);
-    return health;
+	setCheatsEnabled(true);
+	float health = aiCallback-&gt;GetUnitMaxHealth(unitId);
+	setCheatsEnabled(false);
+	return health;
 }
 float CAIAICheats::GetUnitPower(int unitId) {
-    setCheatsEnabled(true);
-    float power = aiCallback-&gt;GetUnitPower(unitId);
-    setCheatsEnabled(false);
-    return power;
+	setCheatsEnabled(true);
+	float power = aiCallback-&gt;GetUnitPower(unitId);
+	setCheatsEnabled(false);
+	return power;
 }
 float CAIAICheats::GetUnitExperience(int unitId) {
-    setCheatsEnabled(true);
-    float experience = aiCallback-&gt;GetUnitExperience(unitId);
-    setCheatsEnabled(false);
-    return experience;
+	setCheatsEnabled(true);
+	float experience = aiCallback-&gt;GetUnitExperience(unitId);
+	setCheatsEnabled(false);
+	return experience;
 }
 bool CAIAICheats::IsUnitActivated(int unitId) {
-    setCheatsEnabled(true);
-    bool activated = aiCallback-&gt;IsUnitActivated(unitId);
-    setCheatsEnabled(false);
-    return activated;
+	setCheatsEnabled(true);
+	bool activated = aiCallback-&gt;IsUnitActivated(unitId);
+	setCheatsEnabled(false);
+	return activated;
 }
 bool CAIAICheats::UnitBeingBuilt(int unitId) {
-    setCheatsEnabled(true);
-    bool isBeingBuilt = aiCallback-&gt;UnitBeingBuilt(unitId);
-    setCheatsEnabled(false);
-    return isBeingBuilt;
+	setCheatsEnabled(true);
+	bool isBeingBuilt = aiCallback-&gt;UnitBeingBuilt(unitId);
+	setCheatsEnabled(false);
+	return isBeingBuilt;
 }
 bool CAIAICheats::IsUnitNeutral(int unitId) {
-    setCheatsEnabled(true);
-    bool neutral = aiCallback-&gt;IsUnitNeutral(unitId);
-    setCheatsEnabled(false);
-    return neutral;
+	setCheatsEnabled(true);
+	bool neutral = aiCallback-&gt;IsUnitNeutral(unitId);
+	setCheatsEnabled(false);
+	return neutral;
 }
 bool CAIAICheats::GetUnitResourceInfo(int unitId, UnitResourceInfo* resourceInfo) {
-    setCheatsEnabled(true);
-    bool fetchOk = aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
-    setCheatsEnabled(false);
-    return fetchOk;
+	setCheatsEnabled(true);
+	bool fetchOk = aiCallback-&gt;GetUnitResourceInfo(unitId, resourceInfo);
+	setCheatsEnabled(false);
+	return fetchOk;
 }
 const CCommandQueue* CAIAICheats::GetCurrentUnitCommands(int unitId) {
-    setCheatsEnabled(true);
-    const CCommandQueue* cc = aiCallback-&gt;GetCurrentUnitCommands(unitId);
-    setCheatsEnabled(false);
-    return cc;
+	setCheatsEnabled(true);
+	const CCommandQueue* cc = aiCallback-&gt;GetCurrentUnitCommands(unitId);
+	setCheatsEnabled(false);
+	return cc;
 }
 
 int CAIAICheats::GetBuildingFacing(int unitId) {
-    setCheatsEnabled(true);
-    int facing = aiCallback-&gt;GetBuildingFacing(unitId);
-    setCheatsEnabled(false);
-    return facing;
+	setCheatsEnabled(true);
+	int facing = aiCallback-&gt;GetBuildingFacing(unitId);
+	setCheatsEnabled(false);
+	return facing;
 }
 bool CAIAICheats::IsUnitCloaked(int unitId) {
-    setCheatsEnabled(true);
-    bool cloaked = aiCallback-&gt;IsUnitCloaked(unitId);
-    setCheatsEnabled(false);
-    return cloaked;
+	setCheatsEnabled(true);
+	bool cloaked = aiCallback-&gt;IsUnitCloaked(unitId);
+	setCheatsEnabled(false);
+	return cloaked;
 }
 bool CAIAICheats::IsUnitParalyzed(int unitId) {
-    setCheatsEnabled(true);
-    bool paralyzed = aiCallback-&gt;IsUnitParalyzed(unitId);
-    setCheatsEnabled(false);
-    return paralyzed;
+	setCheatsEnabled(true);
+	bool paralyzed = aiCallback-&gt;IsUnitParalyzed(unitId);
+	setCheatsEnabled(false);
+	return paralyzed;
 }
 
 bool CAIAICheats::OnlyPassiveCheats() {
-    return sAICallback-&gt;Cheats_isOnlyPassive(teamId);
+	return sAICallback-&gt;Cheats_isOnlyPassive(teamId);
 }
 void CAIAICheats::EnableCheatEvents(bool enable) {
-    sAICallback-&gt;Cheats_setEventsEnabled(teamId, enable);
+	sAICallback-&gt;Cheats_setEventsEnabled(teamId, enable);
 }
 
 bool CAIAICheats::GetProperty(int id, int property, void* dst) {
-//    setCheatsEnabled(true);
-//    bool fetchOk = aiCallback-&gt;GetProperty(id, property, dst);
-//    setCheatsEnabled(false);
-//    return fetchOk;
+//	setCheatsEnabled(true);
+//	bool fetchOk = aiCallback-&gt;GetProperty(id, property, dst);
+//	setCheatsEnabled(false);
+//	return fetchOk;
 	// this returns always false, cause these values are now available through
 	// individual callback functions -&gt; this method is deprecated
 	return false;
 }
 bool CAIAICheats::GetValue(int id, void* dst) {
-//    setCheatsEnabled(true);
-//    bool fetchOk = aiCallback-&gt;GetValue(id, dst);
-//    setCheatsEnabled(false);
-//    return fetchOk;
+//	setCheatsEnabled(true);
+//	bool fetchOk = aiCallback-&gt;GetValue(id, dst);
+//	setCheatsEnabled(false);
+//	return fetchOk;
 	// this returns always false, cause these values are now available through
 	// individual callback functions -&gt; this method is deprecated
 	return false;
 }
 int CAIAICheats::HandleCommand(int commandId, void* data) {
-    setCheatsEnabled(true);
-    int ret = aiCallback-&gt;HandleCommand(commandId, data);
-    setCheatsEnabled(false);
-    return ret;
+	setCheatsEnabled(true);
+	int ret = aiCallback-&gt;HandleCommand(commandId, data);
+	setCheatsEnabled(false);
+	return ret;
 }

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIAICheats.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -15,67 +15,67 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#ifndef _AIAICHEATS_H
+#ifndef	_AIAICHEATS_H
 #define	_AIAICHEATS_H
 
 #include &quot;ExternalAI/IAICheats.h&quot;
-#include &quot;ExternalAI/Interface/SAICallback.h&quot;
-#include &quot;AIAICallback.h&quot;
 
+class SAICallback;
+class CAIAICallback;
+
 /**
  * The AI side wrapper over the C AI interface for IAICheats.
  */
 class CAIAICheats : public IAICheats {
 public:
-    CAIAICheats();
-    CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback);
+	CAIAICheats();
+	CAIAICheats(int teamId, SAICallback* sAICallback/*, IAICheats* aiCheatCallback*/, CAIAICallback* aiCallback);
 
 
-    virtual void SetMyHandicap(float handicap);
+	virtual void SetMyHandicap(float handicap);
 
-    virtual void GiveMeMetal(float amount);
-    virtual void GiveMeEnergy(float amount);
+	virtual void GiveMeMetal(float amount);
+	virtual void GiveMeEnergy(float amount);
 
-    virtual int CreateUnit(const char* name, float3 pos);
+	virtual int CreateUnit(const char* name, float3 pos);
 
-    virtual const UnitDef* GetUnitDef(int unitid);
-    virtual float3 GetUnitPos(int unitid);
-    virtual int GetEnemyUnits(int* units);
-    virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
-    virtual int GetNeutralUnits(int* units);
-    virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
+	virtual const UnitDef* GetUnitDef(int unitid);
+	virtual float3 GetUnitPos(int unitid);
+	virtual int GetEnemyUnits(int* units);
+	virtual int GetEnemyUnits(int* units, const float3&amp; pos, float radius);
+	virtual int GetNeutralUnits(int* units);
+	virtual int GetNeutralUnits(int* units, const float3&amp; pos, float radius);
 
-    virtual int GetUnitTeam(int unitid);
-    virtual int GetUnitAllyTeam(int unitid);
-    virtual float GetUnitHealth(int unitid);
-    virtual float GetUnitMaxHealth(int unitid);
-    virtual float GetUnitPower(int unitid);
-    virtual float GetUnitExperience(int unitid);
-    virtual bool IsUnitActivated(int unitid);
-    virtual bool UnitBeingBuilt(int unitid);
-    virtual bool IsUnitNeutral(int unitid);
-    virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
-    virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
+	virtual int GetUnitTeam(int unitid);
+	virtual int GetUnitAllyTeam(int unitid);
+	virtual float GetUnitHealth(int unitid);
+	virtual float GetUnitMaxHealth(int unitid);
+	virtual float GetUnitPower(int unitid);
+	virtual float GetUnitExperience(int unitid);
+	virtual bool IsUnitActivated(int unitid);
+	virtual bool UnitBeingBuilt(int unitid);
+	virtual bool IsUnitNeutral(int unitid);
+	virtual bool GetUnitResourceInfo(int unitid, UnitResourceInfo* resourceInfo);
+	virtual const CCommandQueue* GetCurrentUnitCommands(int unitid);
 
-    virtual int GetBuildingFacing(int unitid);
-    virtual bool IsUnitCloaked(int unitid);
-    virtual bool IsUnitParalyzed(int unitid);
+	virtual int GetBuildingFacing(int unitid);
+	virtual bool IsUnitCloaked(int unitid);
+	virtual bool IsUnitParalyzed(int unitid);
 
-    virtual bool OnlyPassiveCheats();
-    virtual void EnableCheatEvents(bool enable);
+	virtual bool OnlyPassiveCheats();
+	virtual void EnableCheatEvents(bool enable);
 
-    virtual bool GetProperty(int id, int property, void* dst);
-    virtual bool GetValue(int id, void* dst);
-    virtual int HandleCommand(int commandId, void* data);
-    
+	virtual bool GetProperty(int id, int property, void* dst);
+	virtual bool GetValue(int id, void* dst);
+	virtual int HandleCommand(int commandId, void* data);
+
 private:
-    int teamId;
-    SAICallback* sAICallback;
-//    IAICheats* aiCheatCallback;
-//    IAICallback* aiCallback;
-    CAIAICallback* aiCallback;
-    void setCheatsEnabled(bool enable);
+	int teamId;
+	SAICallback* sAICallback;
+//	IAICheats* aiCheatCallback;
+//	IAICallback* aiCallback;
+	CAIAICallback* aiCallback;
+	void setCheatsEnabled(bool enable);
 };
 
-
-#endif	/* _AIAICHEATS_H */
+#endif	// _AIAICHEATS_H

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,33 +1,36 @@
 /*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+	Copyright 2008  Nicolas Wu
+	
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
 */
 
 #include &quot;AIGlobalAI.h&quot;
 
-CAIGlobalAI::CAIGlobalAI() : CAI(), gai(0) { 
-    
-}
+#include &quot;ExternalAI/IGlobalAI.h&quot;
+#include &quot;ExternalAI/IGlobalAICallback.h&quot;
 
-CAIGlobalAI::CAIGlobalAI(int team, IGlobalAI* gai) : CAI(team, gai), gai(gai) {
-    
-}
+CAIGlobalAI::CAIGlobalAI() : CAI(), gai(NULL) {}
 
+CAIGlobalAI::CAIGlobalAI(int teamId, IGlobalAI* gai) : CAI(teamId, gai), gai(gai) {}
+
 CAIGlobalAI::~CAIGlobalAI() {
-    delete gai;
+	delete gai;
 }
-void CAIGlobalAI::InitAI(IGlobalAICallback* globalAICallback, int team) {
-	gai-&gt;InitAI(globalAICallback, team);
+
+void CAIGlobalAI::InitAI(IGlobalAICallback* globalAICallback, int teamId) {
+	gai-&gt;InitAI(globalAICallback, teamId);
 }

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAI.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,37 +1,40 @@
 /*
-    Copyright 2008  Nicolas Wu
-    
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+	Copyright 2008  Nicolas Wu
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
 
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+
+	@author Nicolas Wu
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
 */
 
-#ifndef AIGLOBALAI_H
-#define AIGLOBALAI_H
+#ifndef	AIGLOBALAI_H
+#define	AIGLOBALAI_H
 
-
-#include &quot;ExternalAI/IGlobalAI.h&quot;
 #include &quot;AI.h&quot;
-#include &quot;ExternalAI/IGlobalAICallback.h&quot; // Remove
 
+class IGlobalAI;
+class IGlobalAICallback;
+
 class CAIGlobalAI : public CAI {
 public:
-    CAIGlobalAI();
-    CAIGlobalAI(int team, IGlobalAI* gai);
-    ~CAIGlobalAI();
+	CAIGlobalAI();
+	CAIGlobalAI(int teamId, IGlobalAI* gai);
+	~CAIGlobalAI();
 
-    void InitAI(IGlobalAICallback* globalAICallback, int team);
-    
-    IGlobalAI* gai;
+	void InitAI(IGlobalAICallback* globalAICallback, int teamId);
+
+	IGlobalAI* gai;
 };
 
-#endif /*AIGLOBALAI_H*/
+#endif	// _AIGLOBALAI_H

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -20,35 +20,31 @@
 #include &quot;AIAICheats.h&quot;
 
 CAIGlobalAICallback::CAIGlobalAICallback()
-    : IGlobalAICallback(), sAICallback(NULL), teamId(-1),
-        wrappedAICallback(NULL), wrappedAICheats(NULL) {
-    
-}
+	: IGlobalAICallback(), sAICallback(NULL), teamId(-1),
+		wrappedAICallback(NULL), wrappedAICheats(NULL) {}
 
 CAIGlobalAICallback::CAIGlobalAICallback(SAICallback* sAICallback, int teamId)
-    : IGlobalAICallback(), sAICallback(sAICallback), teamId(teamId),
-        wrappedAICallback(NULL), wrappedAICheats(NULL) {
-    
-}
+	: IGlobalAICallback(), sAICallback(sAICallback), teamId(teamId),
+		wrappedAICallback(NULL), wrappedAICheats(NULL) {}
 
-CAIGlobalAICallback::~CAIGlobalAICallback() {
-    
-}
+CAIGlobalAICallback::~CAIGlobalAICallback() {}
 
 
 IAICallback* CAIGlobalAICallback::GetAICallback() {
-    
-    if (wrappedAICallback == NULL) {
-        wrappedAICallback = new CAIAICallback(teamId, sAICallback);
-    }
-    return wrappedAICallback;
+
+	if (wrappedAICallback == NULL) {
+		wrappedAICallback = new CAIAICallback(teamId, sAICallback);
+	}
+
+	return wrappedAICallback;
 }
 
 IAICheats* CAIGlobalAICallback::GetCheatInterface() {
-    
-    if (wrappedAICheats == NULL) {
-        this-&gt;GetAICallback(); // to initialize
-        wrappedAICheats = new CAIAICheats(teamId, sAICallback, wrappedAICallback);
-    }
-    return wrappedAICheats;
+
+	if (wrappedAICheats == NULL) {
+		this-&gt;GetAICallback(); // to initialize
+		wrappedAICheats = new CAIAICheats(teamId, sAICallback, wrappedAICallback);
+	}
+
+	return wrappedAICheats;
 }

Modified: branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.h
===================================================================
--- branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/AI/Bindings/LegacyCpp/AIGlobalAICallback.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -15,33 +15,36 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#ifndef _AIGLOBALAICALLBACK_H
+#ifndef	_AIGLOBALAICALLBACK_H
 #define	_AIGLOBALAICALLBACK_H
 
-#include &quot;ExternalAI/Interface/SAICallback.h&quot;
+//#include &quot;ExternalAI/Interface/SAICallback.h&quot;
 #include &quot;ExternalAI/IGlobalAICallback.h&quot;
 
-#include &quot;AIAICallback.h&quot;
-#include &quot;AIAICheats.h&quot;
+//#include &quot;AIAICallback.h&quot;
+//#include &quot;AIAICheats.h&quot;
 
+struct SAICallback;
+class CAIAICallback;
+class CAIAICheats;
+
 /**
  * The AI side wrapper over the C AI interface for IGlobalAICallback.
  */
 class CAIGlobalAICallback : public IGlobalAICallback {
 public:
-    CAIGlobalAICallback();
-    CAIGlobalAICallback(SAICallback* sAICallback, int teamId);
-    ~CAIGlobalAICallback();
+	CAIGlobalAICallback();
+	CAIGlobalAICallback(SAICallback* sAICallback, int teamId);
+	~CAIGlobalAICallback();
 
-    virtual IAICheats* GetCheatInterface();
-    virtual IAICallback* GetAICallback();
-    
+	virtual IAICheats* GetCheatInterface();
+	virtual IAICallback* GetAICallback();
+
 private:
-    SAICallback* sAICallback;
-    int teamId;
-    CAIAICallback* wrappedAICallback;
-    CAIAICheats* wrappedAICheats;
+	SAICallback* sAICallback;
+	int teamId;
+	CAIAICallback* wrappedAICallback;
+	CAIAICheats* wrappedAICheats;
 };
 
-#endif	/* _AIGLOBALAICALLBACK_H */
-
+#endif	// _AIGLOBALAICALLBACK_H

Added: branches/caiinterface/rts/ExternalAI/EngineOutHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/EngineOutHandler.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/EngineOutHandler.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -0,0 +1,653 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;EngineOutHandler.h&quot;
+#include &quot;Group.h&quot;
+#include &quot;GroupHandler.h&quot;
+
+
+CR_BIND_DERIVED(CEngineOutHandler,CObject,)
+
+CR_REG_METADATA(CEngineOutHandler, (
+				CR_MEMBER(skirmishAIs),
+				CR_MEMBER(groupAIs)
+				));
+
+/////////////////////////////
+// BEGIN: Exception Handling
+
+bool CEngineOutHandler::IsCatchExceptions() {
+
+	static bool init = false;
+	static bool isCatchExceptions;
+
+	if (!init) {
+		isCatchExceptions = configHandler.GetInt(&quot;CatchAIExceptions&quot;, 1) != 0;
+		init = true;
+	}
+
+	return isCatchExceptions;
+}
+
+// to switch off the exception handling and have it catched by the debugger.
+#define HANDLE_EXCEPTION  \
+	catch (const std::exception&amp; e) {		\
+		if (IsCatchExceptions()) {			\
+			handleAIException(e.what());	\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (const char *s) {					\
+		if (IsCatchExceptions()) {			\
+			handleAIException(s);			\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (...) {							\
+		if (IsCatchExceptions()) {			\
+			handleAIException(0);			\
+			throw;							\
+		} else throw;						\
+	}
+
+static void handleAIException(const char* description) {
+
+	if (description) {
+		logOutput.Print(&quot;AI Exception: \'%s\'&quot;, description);
+	} else {
+		logOutput.Print(&quot;AI Exception&quot;);
+	}
+//	exit(-1);
+}
+
+// END: Exception Handling
+/////////////////////////////
+
+CEngineOutHandler* CEngineOutHandler::singleton = NULL;
+
+void CEngineOutHandler::Initialize() {
+
+	if (singleton == NULL) {
+		singleton = SAFE_NEW CEngineOutHandler();
+	}
+}
+const CEngineOutHandler* CEngineOutHandler::GetInstance() {
+
+	if (singleton == NULL) {
+		Initialize();
+	}
+
+	return singleton;
+}
+void CEngineOutHandler::Destroy() {
+
+	if (singleton != NULL) {
+		SafeDelete(singleton);
+		singleton = NULL;
+	}
+}
+
+CEngineOutHandler::CEngineOutHandler() {
+
+	activeTeams = gs-&gt;activeTeams;
+
+	for (unsigned int t=0; t &lt; MAX_TEAMS; ++t) {
+		skirmishAIs[t] = NULL;
+	}
+	hasSkirmishAIs = false;
+
+	for (unsigned int t=0; t &lt; MAX_TEAMS; ++t) {
+		for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+			groupAIs[t][g] = NULL;
+		}
+		hasTeamGroupAIs[t] = false;
+	}
+	hasGroupAIs = false;
+}
+
+CEngineOutHandler::~CEngineOutHandler() {
+
+	for (unsigned int t=0; t &lt; MAX_TEAMS; ++t) {
+		delete skirmishAIs[t];
+	}
+
+	for (unsigned int t=0; t &lt; MAX_TEAMS; ++t) {
+		for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+			delete groupAIs[t][g];
+		}
+	}
+}
+
+
+
+
+#define DO_FOR_ALL_SKIRMISH_AIS(FUNC)						\
+		if (hasSkirmishAIs) {								\
+			for (unsigned int t=0; t &lt; activeTeams; ++t) {	\
+				if (skirmishAIs[t]) {						\
+					skirmishAIs[t]-&gt;FUNC;					\
+				}											\
+			}												\
+		}
+
+#define DO_FOR_ALL_GROUP_AIS(FUNC)									\
+		if (hasGroupAIs) {											\
+			for (unsigned int t=0; t &lt; activeTeams; ++t) {			\
+				if (hasTeamGroupAIs[t]) {							\
+					for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {	\
+						if (groupAIs[t][g]) {						\
+							groupAIs[t][g]-&gt;FUNC;					\
+						}											\
+					}												\
+				}													\
+			}														\
+		}
+
+#define DO_FOR_SKIRMISH_AND_GROUP_AIS(FUNC)	\
+		DO_FOR_ALL_SKIRMISH_AIS(FUNC)		\
+		DO_FOR_ALL_GROUP_AIS(FUNC)
+
+
+void CEngineOutHandler::PostLoad() {}
+
+void CEngineOutHandler::PreDestroy() {
+
+	try {
+		DO_FOR_SKIRMISH_AND_GROUP_AIS(PreDestroy())
+	} HANDLE_EXCEPTION;
+}
+
+void CEngineOutHandler::Load(std::istream* s) {
+
+	try {
+		DO_FOR_SKIRMISH_AND_GROUP_AIS(Load(s))
+	} HANDLE_EXCEPTION;
+}
+
+void CEngineOutHandler::Save(std::ostream* s) {
+
+	try {
+		DO_FOR_SKIRMISH_AND_GROUP_AIS(Save(s))
+	} HANDLE_EXCEPTION;
+}
+
+
+
+void CEngineOutHandler::Update() {
+
+	SCOPED_TIMER(&quot;AI&quot;)
+	try {
+		int frame = gs-&gt;frameNum;
+		DO_FOR_SKIRMISH_AND_GROUP_AIS(Update(frame))
+	} HANDLE_EXCEPTION;
+}
+
+
+
+
+
+#define DO_FOR_ALLIED_SKIRMISH_AIS(FUNC, ALLY_TEAM_ID)				\
+	if (hasSkirmishAIs) {											\
+		for (unsigned int t=0; t &lt; activeTeams; ++t) {				\
+			if (skirmishAIs[t] &amp;&amp; gs-&gt;AllyTeam(t) == ALLY_TEAM_ID	\
+					&amp;&amp; !gs-&gt;Ally(ALLY_TEAM_ID, unit-&gt;allyteam)) {	\
+				try {												\
+					skirmishAIs[t]-&gt;FUNC;							\
+				} HANDLE_EXCEPTION;									\
+			}														\
+		}															\
+	}
+
+#define DO_FOR_ALLIED_GROUP_AIS(FUNC, ALLY_TEAM_ID)						\
+	if (hasGroupAIs) {													\
+		for (unsigned int t=0; t &lt; activeTeams; ++t) {					\
+			if (hasTeamGroupAIs[t] &amp;&amp; gs-&gt;AllyTeam(t) == ALLY_TEAM_ID	\
+					&amp;&amp; !gs-&gt;Ally(ALLY_TEAM_ID, unit-&gt;allyteam)) {		\
+				for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {			\
+					if (groupAIs[t][g]) {								\
+						try {											\
+							groupAIs[t][g]-&gt;EnemyEnterLOS(unitId);		\
+						} HANDLE_EXCEPTION;								\
+					}													\
+				}														\
+			}															\
+		}																\
+	}
+
+
+#define DO_FOR_ALLIED_SKIRMISH_AND_GROUP_AIS(FUNC, ALLY_TEAM_ID)	\
+		DO_FOR_ALLIED_SKIRMISH_AIS(FUNC, ALLY_TEAM_ID)				\
+		DO_FOR_ALLIED_GROUP_AIS(FUNC, ALLY_TEAM_ID)
+
+
+void CEngineOutHandler::UnitEnteredLos(const CUnit&amp; unit, int allyTeamId) {
+
+	int unitId = unit-&gt;id;
+	DO_FOR_ALLIED_SKIRMISH_AND_GROUP_AIS(EnemyEnterLOS(unitId), allyTeamId)
+	
+/*
+	if (hasSkirmishAIs) {
+		for (unsigned int t=0; t &lt; activeTeams; ++t) {
+			if (skirmishAIs[t] &amp;&amp; gs-&gt;AllyTeam(t) == allyTeamId &amp;&amp; !gs-&gt;Ally(allyTeamId, unit-&gt;allyteam)) {
+				try {
+					skirmishAIs[t]-&gt;EnemyEnterLOS(unitId);
+				} HANDLE_EXCEPTION;
+			}
+		}
+	}
+	
+	if (hasGroupAIs) {
+		for (unsigned int t=0; t &lt; activeTeams; ++t) {
+			if (hasTeamGroupAIs[t] &amp;&amp; gs-&gt;AllyTeam(t) == allyTeamId &amp;&amp; !gs-&gt;Ally(allyTeamId, unit-&gt;allyteam)) {
+				for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+					if (groupAIs[t][g]) {
+						try {
+							groupAIs[t][g]-&gt;EnemyEnterLOS(unitId);
+						} HANDLE_EXCEPTION;
+					}
+				}
+			}	
+		}
+	}
+*/
+}
+
+void CEngineOutHandler::UnitLeftLos(const CUnit&amp; unit, int allyTeamId) {
+
+	int unitId = unit-&gt;id;
+	DO_FOR_ALLIED_SKIRMISH_AND_GROUP_AIS(EnemyLeaveLOS(unitId), allyTeamId)
+}
+
+void CEngineOutHandler::UnitEnteredRadar(const CUnit&amp; unit, int allyTeamId) {
+
+	int unitId = unit-&gt;id;
+	DO_FOR_ALLIED_SKIRMISH_AND_GROUP_AIS(EnemyEnterRadar(unitId), allyTeamId)
+}
+
+void CEngineOutHandler::UnitLeftRadar(const CUnit&amp; unit, int allyTeamId) {
+
+	int unitId = unit-&gt;id;
+	DO_FOR_ALLIED_SKIRMISH_AND_GROUP_AIS(EnemyLeaveRadar(unitId), allyTeamId)
+}
+
+
+
+
+#define DO_FOR_TEAM_SKIRMISH_AIS(FUNC, TEAM_ID)		\
+	if (skirmishAIs[TEAM_ID]) {						\
+		try {										\
+			skirmishAIs[TEAM_ID]-&gt;FUNC;				\
+		} HANDLE_EXCEPTION;							\
+	}
+
+#define DO_FOR_TEAM_GROUP_AIS(FUNC, TEAM_ID)		\
+	if (hasTeamGroupAIs[TEAM_ID]) {				\
+		for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {	\
+			if (groupAIs[TEAM_ID][g]) {			\
+				try {									\
+					groupAIs[TEAM_ID][g]-&gt;FUNC;	\
+				} HANDLE_EXCEPTION;						\
+			}											\
+		}												\
+	}
+
+
+#define DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(FUNC, TEAM_ID)	\
+		DO_FOR_TEAM_SKIRMISH_AIS(FUNC, TEAM_ID)				\
+		DO_FOR_TEAM_GROUP_AIS(FUNC, TEAM_ID)
+
+void CEngineOutHandler::UnitIdle(const CUnit&amp; unit) {
+
+	int teamId = unit-&gt;team;
+	int unitId = unit-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitIdle(unitId), teamId);
+}
+
+void CEngineOutHandler::UnitCreated(const CUnit&amp; unit) {
+
+	int teamId = unit-&gt;team;
+	int unitId = unit-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitCreated(unitId), teamId);
+}
+
+void CEngineOutHandler::UnitFinished(const CUnit&amp; unit) {
+
+	int teamId = unit-&gt;team;
+	int unitId = unit-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitFinished(unitId), teamId);
+}
+
+
+void CEngineOutHandler::UnitMoveFailed(const CUnit&amp; unit) {
+
+	int teamId = unit-&gt;team;
+	int unitId = unit-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitMoveFailed(unitId), teamId);
+}
+
+void CEngineOutHandler::UnitGiven(const CUnit&amp; unit, int oldTeam) {
+
+	int newTeam = unit-&gt;team;
+	int unitId = unit-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitGiven(unitId, oldTeam, newTeam), newTeam);
+	//DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitGiven(unitId, oldTeam, newTeam), oldTeam);
+}
+
+void CEngineOutHandler::UnitCaptured(const CUnit&amp; unit, int newTeam) {
+
+	int oldTeam = unit-&gt;team;
+	int unitId = unit-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitCaptured(unitId, oldTeam, newTeam), oldTeam);
+	//DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(UnitCaptured(unitId, oldTeam, newTeam), newTeam);
+}
+
+
+void CEngineOutHandler::UnitDestroyed(const CUnit&amp; destroyed,
+		const CUnit* attacker) {
+
+	int destroyedId = destroyed-&gt;id;
+	int attackerId = attacker ? attacker-&gt;id : 0;
+
+	if (hasSkirmishAIs) {
+		try {
+			for (unsigned int t=0; t &lt; activeTeams; ++t) {
+				if (skirmishAIs[t]
+						&amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(t), destroyed-&gt;allyteam)
+						&amp;&amp; (skirmishAIs[t]-&gt;IsCheatEventsEnabled()
+							|| (destroyed-&gt;losStatus[t] &amp; (LOS_INLOS | LOS_INRADAR)))) {
+					skirmishAIs[t]-&gt;EnemyDestroyed(destroyedId, attackerId);
+				}
+			}
+			if (skirmishAIs[destroyed-&gt;team]) {
+				skirmishAIs[destroyed-&gt;team]-&gt;UnitDestroyed(destroyedId, attackerId);
+			}
+		} HANDLE_EXCEPTION;
+	}
+	
+	if (hasGroupAIs) {
+		for (unsigned int t=0; t &lt; activeTeams; ++t) {
+			if (hasTeamGroupAIs[t]
+						&amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(t), destroyed-&gt;allyteam)) {
+				bool isVisible =
+						destroyed-&gt;losStatus[t] &amp; (LOS_INLOS | LOS_INRADAR);
+				for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+					if (groupAIs[t][g]
+							&amp;&amp; (groupAIs[t][g]-&gt;IsCheatEventsEnabled()
+								|| isVisible)) {
+						try {
+							groupAIs[t][g]-&gt;EnemyDestroyed(destroyedId, attackerId);
+						} HANDLE_EXCEPTION;
+					}
+				}
+			}	
+		}
+		if (hasTeamGroupAIs[destroyed-&gt;team]) {
+			for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+				if (groupAIs[destroyed-&gt;team][g]) {
+					try {
+						groupAIs[destroyed-&gt;team][g]-&gt;EnemyDestroyed(destroyedId, attackerId);
+					} HANDLE_EXCEPTION;
+				}
+			}
+		}
+	}
+}
+
+
+void CEngineOutHandler::UnitDamaged(const CUnit&amp; damaged, const CUnit* attacker,
+		float damage) {
+
+	int damagedUnitId = damaged-&gt;id;
+	int attackerUnitId = attacker ? attacker-&gt;id : -1;
+	float3 attackDir_damagedsView;
+	float3 attackDir_attackersView;
+	if (attacker) {
+		attackDir_damagedsView =
+				helper-&gt;GetUnitErrorPos(attacker, damaged-&gt;allyteam)
+				- damaged-&gt;pos;
+		attackDir_damagedsView.ANormalize();
+
+		attackDir_attackersView =
+				attacker-&gt;pos
+				- helper-&gt;GetUnitErrorPos(damaged, attacker-&gt;allyteam);
+		attackDir_attackersView.ANormalize();
+	} else {
+		attackDir_damagedsView = ZeroVector;
+	}
+	int dt = damaged-&gt;team;
+	int at = attacker-&gt;team;
+
+	if (hasSkirmishAIs) {
+		try {
+			if (skirmishAIs[dt]) {
+				skirmishAIs[dt]-&gt;UnitDamaged(damagedUnitId,
+						attackerUnitId, damage, attackDir_damagedsView);
+			}
+
+			if (attacker) {
+				if (skirmishAIs[at]
+						&amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(at), attacked-&gt;allyteam)
+						&amp;&amp; (skirmishAIs[at]-&gt;IsCheatEventsEnabled()
+							|| (attacked-&gt;losStatus[at] &amp; (LOS_INLOS | LOS_INRADAR)))) {
+					skirmishAIs[at]-&gt;EnemyDamaged(damagedUnitId, attackerUnitId,
+							damage, attackDir_attackersView);
+				}
+			}
+		} HANDLE_EXCEPTION;
+	}
+
+	if (hasTeamGroupAIs[dt]) {
+		for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+			if (groupAIs[dt][g]) {
+				try {
+					groupAIs[dt][g]-&gt;UnitDamaged(damagedUnitId,
+							attackerUnitId, damage, attackDir_damagedsView);
+				} HANDLE_EXCEPTION;
+			}
+		}
+	}
+	if (hasTeamGroupAIs[at]
+			&amp;&amp; !gs-&gt;Ally(gs-&gt;AllyTeam(at), attacked-&gt;allyteam)) {
+		bool isVisible = attacked-&gt;losStatus[at] &amp; (LOS_INLOS | LOS_INRADAR);
+		for (unsigned int g=0; g &lt; MAX_GROUPS; ++g) {
+			if (groupAIs[at][g]
+					&amp;&amp; (groupAIs[at][g]-&gt;IsCheatEventsEnabled()
+						|| isVisible)) {
+				try {
+					groupAIs[at][g]-&gt;EnemyDamaged(damagedUnitId, attackerUnitId,
+							damage, attackDir_attackersView);
+				} HANDLE_EXCEPTION;
+			}
+		}
+	}
+}
+
+
+
+
+
+void CEngineOutHandler::SeismicPing(int allyTeamId, const CUnit&amp; unit,
+		const float3&amp; pos, float strength) {
+
+	int unitId = unit-&gt;id;
+	
+	DO_FOR_ALLIED_SKIRMISH_AND_GROUP_AIS(SeismicPing(allyTeamId, unitId, pos, strength), allyTeamId)
+}
+
+void CEngineOutHandler::WeaponFired(const CUnit&amp; unit, const WeaponDef&amp; def) {
+
+	int teamId = unit-&gt;team;
+	int unitId = unit-&gt;id;
+	int defId = def-&gt;id;
+
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(WeaponFired(unitId, defId), teamId);
+}
+
+void CEngineOutHandler::PlayerCommandGiven(
+		const std::vector&lt;int&gt;&amp; selectedUnitIds, const Command&amp; c, int playerId)
+{
+
+	int teamId = gs-&gt;players[playerId]-&gt;team;
+	
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(PlayerCommandGiven(selectedUnitIds, c, playerId), teamId);
+}
+
+void CommandFinished(const CUnit&amp; unit, int commandTopicId) {
+
+	int teamId = unit-&gt;team;
+	int unitId = unit-&gt;id;
+	
+	DO_FOR_TEAM_SKIRMISH_AND_GROUP_AIS(CommandFinished(unitId, commandTopicId), teamId);
+}
+
+void CEngineOutHandler::GotChatMsg(const char* msg, int fromPlayerId) {
+
+	DO_FOR_SKIRMISH_AND_GROUP_AIS(GotChatMsg(msg, fromPlayerId))
+}
+
+
+
+
+
+
+bool CEngineOutHandler::CreateSkirmishAI(int teamId, const SSAIKey&amp; key,
+		const std::map&lt;std::string, std::string&gt;&amp; options) {
+
+	if ((teamId &lt; 0) || (teamId &gt;= gs-&gt;activeTeams)) {
+		return false;
+	}
+
+	try {
+		if (skirmishAIs[teamId]) {
+			delete skirmishAIs[teamId];
+			skirmishAIs[teamId] = NULL;
+		}
+
+		skirmishAIs[teamId] = SAFE_NEW CSkirmishAIWrapper(teamId, key, options);
+		hasSkirmishAIs = true;
+		
+		return true;
+	} HANDLE_EXCEPTION;
+	
+	return false;
+}
+
+bool CEngineOutHandler::IsSkirmishAI(int teamId) {
+	return skirmishAIs[teamId];
+}
+
+void CEngineOutHandler::DestroySkirmishAI(int teamId) {
+	
+	try {
+		delete skirmishAIs[teamId];
+		skirmishAIs[teamId] = NULL;
+	} HANDLE_EXCEPTION;
+}
+
+
+
+
+
+bool CEngineOutHandler::CreateSkirmishAI(int teamId, const SSAIKey&amp; key,
+		const std::map&lt;std::string, std::string&gt;&amp; options) {
+
+	if ((teamId &lt; 0) || (teamId &gt;= gs-&gt;activeTeams)) {
+		return false;
+	}
+
+	try {
+		if (skirmishAIs[teamId]) {
+			delete skirmishAIs[teamId];
+			skirmishAIs[teamId] = NULL;
+		}
+
+		skirmishAIs[teamId] = SAFE_NEW CSkirmishAIWrapper(teamId, key, options);
+		hasSkirmishAIs = true;
+
+		return true;
+	} HANDLE_EXCEPTION;
+
+	return false;
+}
+
+bool CEngineOutHandler::IsSkirmishAI(int teamId) {
+	return skirmishAIs[teamId];
+}
+
+void CEngineOutHandler::DestroySkirmishAI(int teamId) {
+	
+	try {
+		delete skirmishAIs[teamId];
+		skirmishAIs[teamId] = NULL;
+	} HANDLE_EXCEPTION;
+}
+
+
+
+
+
+bool CreateGroupAI(const CGroup&amp; group, const SGAIKey&amp; key,
+			const std::map&lt;std::string, std::string&gt;&amp; options) {
+
+	int teamId = group-&gt;handler-&gt;team;
+	int groupId = group-&gt;id;
+
+	if ((teamId &lt; 0) || (teamId &gt;= gs-&gt;activeTeams)) {
+		return false;
+	}
+
+	try {
+		if (groupAIs[teamId][groupId]) {
+			delete groupAIs[teamId][groupId];
+			groupAIs[teamId][groupId] = NULL;
+		}
+
+		groupAIs[teamId][groupId] = SAFE_NEW CGroupAIWrapper(teamId, groupId, key, options);
+		hasGroupAIs = true;
+		hasTeamGroupAIs[teamId] = true;
+
+		return true;
+	} HANDLE_EXCEPTION;
+
+	return false;
+}
+
+
+bool CEngineOutHandler::IsGroupAI(const CGroup&amp; group) {
+
+	int teamId = group-&gt;handler-&gt;team;
+	int groupId = group-&gt;id;
+
+	return groupAIs[teamId][groupId];
+}
+
+void CEngineOutHandler::DestroyGroupAI(const CGroup&amp; group) {
+
+	int teamId = group-&gt;handler-&gt;team;
+	int groupId = group-&gt;id;
+
+	try {
+		delete groupAIs[teamId][groupId];
+		groupAIs[teamId][groupId] = NULL;
+	} HANDLE_EXCEPTION;
+}


Property changes on: branches/caiinterface/rts/ExternalAI/EngineOutHandler.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/EngineOutHandler.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/EngineOutHandler.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/EngineOutHandler.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -0,0 +1,115 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _ENGINEOUTHANDLER_H
+#define _ENGINEOUTHANDLER_H
+
+#include &quot;Object.h&quot;
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+struct Command;
+class float3;
+class CUnit;
+class CGroup;
+struct SSAIKey;
+class CSkirmishAIWrapper;
+struct SGAIKey;
+class CGroupAIWrapper;
+
+class CEngineOutHandler : public CObject {
+private:
+	CEngineOutHandler();
+	~CEngineOutHandler();
+
+public:
+	CR_DECLARE(CEngineOutHandler);
+
+	/**
+	 * This function initialized a singleton instance,
+	 * if not yet done by a call to GetInstance()
+	 */
+	static void Initialize();
+	static CEngineOutHandler* GetInstance();
+	static void Destroy();
+
+	void PostLoad();
+	void PreDestroy(); // called just before all the units are destroyed
+
+	void Update();
+
+	bool UnitAddedToGroup(const CUnit&amp; unit, const CGroup&amp; group);		//group should return false if it doenst want the unit for some reason
+	void UnitRemovedFromGroup(const CUnit&amp; unit, const CGroup&amp; group);		//no way to refuse giving up a unit
+	void UnitEnteredLos(const CUnit&amp; unit, int allyTeamId);
+	void UnitLeftLos(const CUnit&amp; unit, int allyTeamId);
+	void UnitEnteredRadar(const CUnit&amp; unit, int allyTeamId);
+	void UnitLeftRadar(const CUnit&amp; unit, int allyTeamId);
+	void UnitIdle(const CUnit&amp; unit);
+	void UnitCreated(const CUnit&amp; unit);
+	void UnitFinished(const CUnit&amp; unit);
+	void UnitDestroyed(const CUnit&amp; destroyed, const CUnit* attacker);
+	void UnitDamaged(const CUnit&amp; damaged, const CUnit* attacker, float damage);
+	void UnitMoveFailed(const CUnit&amp; unit);
+	void UnitCaptured(const CUnit&amp; unit, int newTeamId);
+	void UnitGiven(const CUnit&amp; unit, int oldTeamId);
+
+	void SeismicPing(int allyTeamId, const CUnit&amp; unit, const float3&amp; pos, float strength);
+	void WeaponFired(const CUnit&amp; unit, const WeaponDef&amp; def);
+	void PlayerCommandGiven(const std::vector&lt;int&gt;&amp; selectedUnitIds, const Command&amp; c, int playerId);
+	void CommandFinished(const CUnit&amp; unit, int commandTopicId);	//a specific unit has finished a specific command, might be a good idea to give new orders to it
+	void GotChatMsg(const char* msg, int playerId);
+
+
+	// Skirmish AI stuff
+	bool CreateSkirmishAI(int teamId, const SSAIKey&amp; key,
+			const std::map&lt;std::string, std::string&gt;&amp; options);
+	bool IsSkirmishAI(int teamId) const;
+	void DestroySkirmishAI(int teamId);
+	//const CSkirmishAIWrapper* GetSkirmishAI(int teamId);
+
+
+	// Group AI stuff
+	bool CreateGroupAI(const CGroup&amp; group, const SGAIKey&amp; key,
+			const std::map&lt;std::string, std::string&gt;&amp; options);
+	bool IsGroupAI(const CGroup&amp; group) const;
+	void DestroyGroupAI(const CGroup&amp; group);
+
+
+	void SetCheating(bool enable);
+	bool IsCheating() const;
+
+
+	void Load(std::istream* s);
+	void Save(std::ostream* s);
+
+private:
+	static bool IsCatchExceptions();
+
+private:
+	const unsigned int activeTeams;
+
+	CSkirmishAIWrapper* skirmishAIs[MAX_TEAMS];
+	bool hasSkirmishAIs;
+	CGroupAIWrapper* groupAIs[MAX_TEAMS][MAX_GROUPS];
+	bool hasGroupAIs;
+	bool hasTeamGroupAIs[MAX_TEAMS];
+};
+
+#define eoh CEngineOutHandler::GetInstance()
+
+#endif // _ENGINEOUTHANDLER_H


Property changes on: branches/caiinterface/rts/ExternalAI/EngineOutHandler.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/GlobalAIHandler.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -217,49 +217,6 @@
 	}
 }
 
-/*
-void* CGlobalAIHandler::GetAIBuffer(int team, std::string name, int length)
-{
-	if(memBuffers[team].find(name)!=memBuffers[team].end()){
-		memBuffers[team][name].usage++;
-		return memBuffers[team][name].mem;
-	}
-	AIMemBuffer mb;
-	mb.usage=1;
-	mb.mem=SAFE_NEW char[length];
-	memset(mb.mem,0,length);
-
-	memBuffers[team][name]=mb;
-	return mb.mem;
-}
-
-void CGlobalAIHandler::ReleaseAIBuffer(int team, std::string name)
-{
-	if(memBuffers[team].find(name)!=memBuffers[team].end()){
-		memBuffers[team][name].usage--;
-		if(memBuffers[team][name].usage==0){
-			delete memBuffers[team][name].mem;
-			memBuffers[team].erase(name);
-		}
-	}
-}
-*/
-
-void CGlobalAIHandler::GotChatMsg(const char* msg, int fromPlayerId)
-{
-	if(hasAI){
-		for(int a=0;a&lt;gs-&gt;activeTeams;++a)
-		{
-			if(ais[a])
-			{
-				try {
-					ais[a]-&gt;GotChatMsg(msg, fromPlayerId);
-				} HANDLE_EXCEPTION
-			}
-		}
-	}
-}
-
 void CGlobalAIHandler::UnitDamaged(CUnit* attacked, CUnit* attacker, float damage)
 {
 	if(hasAI){
@@ -285,15 +242,6 @@
 	}
 }
 
-void CGlobalAIHandler::WeaponFired(CUnit* unit, const WeaponDef* def)
-{
-	if(ais[unit-&gt;team]){
-		try {
-			ais[unit-&gt;team]-&gt;WeaponFired(unit-&gt;id, def-&gt;id);
-		} HANDLE_EXCEPTION;
-	}
-}
-
 void CGlobalAIHandler::UnitMoveFailed(CUnit* unit)
 {
 	if(ais[unit-&gt;team])
@@ -318,6 +266,56 @@
 		} HANDLE_EXCEPTION;
 }
 
+
+
+
+
+
+
+
+/*
+void* CGlobalAIHandler::GetAIBuffer(int team, std::string name, int length)
+{
+	if(memBuffers[team].find(name)!=memBuffers[team].end()){
+		memBuffers[team][name].usage++;
+		return memBuffers[team][name].mem;
+	}
+	AIMemBuffer mb;
+	mb.usage=1;
+	mb.mem=SAFE_NEW char[length];
+	memset(mb.mem,0,length);
+
+	memBuffers[team][name]=mb;
+	return mb.mem;
+}
+
+void CGlobalAIHandler::ReleaseAIBuffer(int team, std::string name)
+{
+	if(memBuffers[team].find(name)!=memBuffers[team].end()){
+		memBuffers[team][name].usage--;
+		if(memBuffers[team][name].usage==0){
+			delete memBuffers[team][name].mem;
+			memBuffers[team].erase(name);
+		}
+	}
+}
+*/
+
+void CGlobalAIHandler::GotChatMsg(const char* msg, int fromPlayerId)
+{
+	if(hasAI){
+		for(int a=0;a&lt;gs-&gt;activeTeams;++a)
+		{
+			if(ais[a])
+			{
+				try {
+					ais[a]-&gt;GotChatMsg(msg, fromPlayerId);
+				} HANDLE_EXCEPTION
+			}
+		}
+	}
+}
+
 void CGlobalAIHandler::PlayerCommandGiven(std::vector&lt;int&gt;&amp; selectedunits, Command&amp; c, int playerId)
 {
 	if(ais[gs-&gt;players[playerId]-&gt;team]){
@@ -343,7 +341,21 @@
 
 
 
+void CGlobalAIHandler::WeaponFired(CUnit* unit, const WeaponDef* def)
+{
+	if(ais[unit-&gt;team]){
+		try {
+			ais[unit-&gt;team]-&gt;WeaponFired(unit-&gt;id, def-&gt;id);
+		} HANDLE_EXCEPTION;
+	}
+}
 
+
+
+
+
+
+
 bool CGlobalAIHandler::CreateSkirmishAI(
 		int teamId,
 		const SSAIKey&amp; skirmishAIKey,

Modified: branches/caiinterface/rts/ExternalAI/Group.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Group.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/Group.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -8,30 +8,35 @@
 #include &lt;string&gt;
 #include &lt;set&gt;
 #include &quot;Sim/Units/CommandAI/Command.h&quot;
-#include &quot;Platform/SharedLib.h&quot;
+//#include &quot;Platform/SharedLib.h&quot;
 #include &quot;Sim/Units/UnitDef.h&quot;
 #include &quot;Sim/Units/UnitSet.h&quot;
-#include &quot;ExternalAI/aikey.h&quot;
-class IGroupAI;
+//#include &quot;ExternalAI/aikey.h&quot;
+//class IGroupAI;
 class CUnit;
 class CFeature;
-class CGroupAICallback;
+//class CGroupAICallback;
 class CGroupHandler;
+struct SGAIKey;
 
 class CGroup : public CObject
 {
 public:
 	CR_DECLARE(CGroup);
-	void CommandFinished(int unit,int type);
-	CGroup(AIKey aiKey,int id,CGroupHandler* grouphandler);
+	//CGroup(AIKey aiKey, int id, CGroupHandler* groupHandler);
+	CGroup(int id);
 	virtual ~CGroup();
 	void Serialize(creg::ISerializer *s);
 	void PostLoad();
 
-	void Update();
+//	void Update();
 	void DrawCommands();
-	void SetNewAI(AIKey aiKey);
+//	void SetNewAI(AIKey aiKey);
 
+	void SetAI(const SGAIKey* key);
+	void ClearAI();
+
+	void CommandFinished(int unitId, int commandTopicId);
 	void RemoveUnit(CUnit* unit);	//call setgroup(0) instead of calling this directly
 	bool AddUnit(CUnit* unit);		//dont call this directly call unit.SetGroup and let that call this
 	const vector&lt;CommandDescription&gt;&amp; GetPossibleCommands();
@@ -43,25 +48,26 @@
 
 	CUnitSet units;
 
-	vector&lt;CommandDescription&gt; myCommands;
-	SharedLib *lib;
-	typedef int (* GETGROUPAIVERSION)();
-	typedef IGroupAI* (* GETNEWAI)(unsigned aiNumber);
-	typedef void (* RELEASEAI)(unsigned aiNumber,IGroupAI* i);
-	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
+//	vector&lt;CommandDescription&gt; myCommands;
+//	SharedLib *lib;
+//	typedef int (* GETGROUPAIVERSION)();
+//	typedef IGroupAI* (* GETNEWAI)(unsigned aiNumber);
+//	typedef void (* RELEASEAI)(unsigned aiNumber,IGroupAI* i);
+//	typedef bool (* ISUNITSUITED)(unsigned aiNumber,const UnitDef* unitDef);
 
-	GETGROUPAIVERSION GetGroupAiVersion;
-	GETNEWAI GetNewAI;
-	RELEASEAI ReleaseAI;
-	ISUNITSUITED IsUnitSuited;
+//	GETGROUPAIVERSION GetGroupAiVersion;
+//	GETNEWAI GetNewAI;
+//	RELEASEAI ReleaseAI;
+//	ISUNITSUITED IsUnitSuited;
 	int lastCommandPage;
-	int currentAiNum;
-	AIKey currentAiKey;
+//	int currentAiNum;
+//	AIKey currentAiKey;
+	const SGAIKey* currentAIKey;
+//
+//	IGroupAI* ai;
+//	CGroupAICallback* callback;
 
-	IGroupAI* ai;
-	CGroupAICallback* callback;
-
-	CGroupHandler* handler;
+//	CGroupHandler* handler;
 };
 
 #endif /* GROUP_H */

Added: branches/caiinterface/rts/ExternalAI/GroupAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAI.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAI.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -0,0 +1,38 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;GroupAI.h&quot;
+
+#include &quot;IAILibraryManager.h&quot;
+#include &quot;IGroupAILibrary.h&quot;
+
+CGroupAI::CGroupAI(int teamId, int groupId, const SGAIKey&amp; key)
+		: teamId(teamId), groupId(groupId), key(key) {
+
+	library = IAILibraryManager::GetInstance()-&gt;FetchGroupAILibrary(key);
+	library-&gt;Init(teamId);
+}
+
+CGroupAI::~CGroupAI() {
+
+	library-&gt;Release(teamId);
+	IAILibraryManager::GetInstance()-&gt;ReleaseGroupAILibrary(key);
+}
+
+int CGroupAI::HandleEvent(int topic, const void* data) const {
+	return library-&gt;HandleEvent(teamId, groupId, topic, data);
+}


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAI.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/GroupAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAI.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAI.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -0,0 +1,41 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _GROUPAI_H
+#define _GROUPAI_H
+
+#include &quot;IGroupAI.h&quot;
+//#include &quot;IGroupAILibrary.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+
+class IGroupAILibrary;
+
+class CGroupAI : public IGroupAI {
+public:
+	CGroupAI(int teamId, int groupId, const SGAIKey&amp; key);
+	virtual ~CGroupAI();
+
+	virtual int HandleEvent(int topic, const void* data) const;
+
+private:
+	int teamId;
+	int groupId;
+	const SGAIKey key;
+	const IGroupAILibrary* library;
+};
+
+#endif	// _GROUPAI_H


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAI.h
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/GroupAIWrapper.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAIWrapper.cpp	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAIWrapper.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -0,0 +1,359 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;GroupAIWrapper.h&quot;
+
+#include &quot;StdAfx.h&quot;
+#include &quot;Game/GlobalSynced.h&quot;
+#include &quot;IGlobalAI.h&quot;
+#include &quot;GroupAI.h&quot;
+#include &quot;GlobalAICallback.h&quot;
+#include &quot;GlobalAIHandler.h&quot;
+#include &quot;Platform/FileSystem.h&quot;
+#include &quot;Platform/errorhandler.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+#include &quot;LogOutput.h&quot;
+#include &quot;mmgr.h&quot;
+#include &quot;Sim/Units/Unit.h&quot;
+#include &quot;Sim/Units/UnitHandler.h&quot;
+#include &quot;Interface/AISEvents.h&quot;
+#include &quot;Interface/AISCommands.h&quot;
+#include &quot;Interface/SSAILibrary.h&quot;
+
+#include &lt;sstream&gt;
+
+CR_BIND_DERIVED(CGroupAIWrapper, CObject, (0, SSAIKey()))
+CR_REG_METADATA(CGroupAIWrapper, (
+	CR_MEMBER(teamId),
+	CR_MEMBER(groupId),
+	CR_MEMBER(cheatEvents),
+	CR_MEMBER(key),
+	CR_MEMBER(optionKeys),
+	CR_MEMBER(optionValues),
+	CR_SERIALIZER(Serialize),
+	CR_POSTLOAD(PostLoad)
+));
+
+void AIException(const char *what);
+
+#define HANDLE_EXCEPTION					\
+	catch (const std::exception&amp; e) {		\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(e.what());			\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (const char *s) {	\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(s);					\
+			throw;							\
+		} else throw;						\
+	}										\
+	catch (...) {							\
+		if (globalAI-&gt;CatchException()) {	\
+			AIException(0);					\
+			throw;							\
+		} else throw;						\
+	}
+
+
+CGroupAIWrapper::CGroupAIWrapper(int teamId, int groupId, const SSAIKey&amp; key,
+		const std::map&lt;std::string, std::string&gt;&amp; options)
+		: teamId(teamId), groupId(groupId), cheatEvents(false), key(key) {
+
+	std::map&lt;std::string, std::string&gt;::const_iterator op;
+	for (op = options.begin(); op != options.end(); ++op) {
+		optionKeys.push_back(op-&gt;first);
+		optionValues.push_back(op-&gt;second);
+	}
+
+	LoadGroupAI(false);
+
+	Init();
+}
+
+void CGroupAIWrapper::PreDestroy() {
+	callback-&gt;noMessages = true;
+}
+
+CGroupAIWrapper::~CGroupAIWrapper() {
+
+	if (ai) {
+		Release();
+		delete c_callback;
+		delete callback;
+		delete ai;
+	}
+}
+
+void CGroupAIWrapper::Serialize(creg::ISerializer* s) {}
+
+
+void CGroupAIWrapper::PostLoad() {
+	LoadGroupAI(true);
+}
+
+
+void CGroupAIWrapper::LoadGroupAI(bool postLoad) {
+
+	ai = SAFE_NEW CGroupAI(teamId, groupId, key);
+
+	IAILibraryManager* libManager = IAILibraryManager::GetInstance();
+	libManager-&gt;FetchGroupAILibrary(key);
+	const CGroupAILibraryInfo* infos =
+			libManager-&gt;GetGroupAIInfos()-&gt;at(key);
+	bool loadSupported =
+			infos-&gt;GetInfo(GROUP_AI_PROPERTY_LOAD_SUPPORTED) == &quot;yes&quot;;
+	libManager-&gt;ReleaseGroupAILibrary(key);
+
+	if (postLoad &amp;&amp; !loadSupported) {
+		// fallback code to help the AI if it
+		// doesn't implement load/save support
+		for (int a = 0; a &lt; MAX_UNITS; a++) {
+			if (!uh-&gt;units[a])
+				continue;
+
+			if (uh-&gt;units[a]-&gt;team == teamId) {
+				try {
+					AddUnit(a);
+				} HANDLE_EXCEPTION;
+				if (!uh-&gt;units[a]-&gt;beingBuilt)
+					try {
+						UnitFinished(a);
+					} HANDLE_EXCEPTION;
+			} else {
+				if ((uh-&gt;units[a]-&gt;allyteam == gs-&gt;AllyTeam(teamId))
+						|| gs-&gt;Ally(gs-&gt;AllyTeam(teamId), uh-&gt;units[a]-&gt;allyteam)) {
+					// do nothing
+				} else {
+					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(teamId)] &amp; (LOS_INRADAR | LOS_INLOS)) {
+						try {
+							EnemyEnterRadar(a);
+						} HANDLE_EXCEPTION;
+					}
+					if (uh-&gt;units[a]-&gt;losStatus[gs-&gt;AllyTeam(teamId)] &amp; LOS_INLOS) {
+						try {
+							EnemyEnterLOS(a);
+						} HANDLE_EXCEPTION;
+					}
+				}
+			}
+		}
+	}
+}
+
+static const char** allocCStrArray(std::vector&lt;std::string&gt; strVec) {
+
+	const char** strArr = NULL;
+
+	unsigned int size = strVec.size();
+	strArr = (const char**) calloc(size, sizeof(char*));
+	unsigned int i;
+	for (i = 0; i &lt; size; ++i) {
+		strArr[i] = strVec[i].c_str();
+	}
+
+	return strArr;
+}
+
+void CGroupAIWrapper::Init() {
+
+	callback = SAFE_NEW CGroupAICallback(this);
+	c_callback = initSAICallback(teamId, callback);
+	optionKeys_c = allocCStrArray(optionKeys);
+	optionValues_c = allocCStrArray(optionValues);
+
+	SInitEvent evtData = {teamId, c_callback, optionKeys.size(), optionKeys_c, optionValues_c};
+	ai-&gt;HandleEvent(EVENT_INIT, &amp;evtData);
+}
+
+void CGroupAIWrapper::Release() {
+
+	SReleaseEvent evtData = {teamId};
+	ai-&gt;HandleEvent(EVENT_RELEASE, &amp;evtData);
+
+	free(optionKeys_c);
+	free(optionValues_c);
+
+	// further cleanup is done in the destructor
+}
+
+
+void CGroupAIWrapper::Load(std::istream* s) {
+
+/* TODO
+	SLoadAIEvent evtData = {s.TO_FILENAME(TODO), callback};
+	ai-&gt;HandleEvent(EVENT_LOAD_AI, &amp;evtData);
+*/
+}
+
+void CGroupAIWrapper::Save(std::ostream* s) {
+
+/* TODO
+	SSaveAIEvent evtData = {s.TO_FILENAME(TODO)};
+	ai-&gt;HandleEvent(EVENT_SAVE_AI, &amp;evtData);
+*/
+}
+
+void CGroupAIWrapper::UnitIdle(int unitId) {
+
+	SUnitIdleEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_IDLE, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitCreated(int unitId) {
+
+	SUnitCreatedEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_CREATED, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitFinished(int unitId) {
+
+	SUnitFinishedEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_FINISHED, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitDestroyed(int unitId, int attackerUnitId) {
+
+	SUnitDestroyedEvent evtData = {unitId, attackerUnitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_DESTROYED, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitDamaged(int unitId, int attackerUnitId,
+		float damage, const float3&amp; dir) {
+
+	SUnitDamagedEvent evtData = {unitId, attackerUnitId, damage,
+			dir.toSAIFloat3()};
+	ai-&gt;HandleEvent(EVENT_UNIT_DAMAGED, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitMoveFailed(int unitId) {
+
+	SUnitMoveFailedEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_UNIT_MOVE_FAILED, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitGiven(int unitId, int oldTeam, int newTeam) {
+
+	SUnitGivenEvent evtData = {unitId, oldTeam, newTeam};
+	ai-&gt;HandleEvent(EVENT_UNIT_GIVEN, &amp;evtData);
+}
+
+void CGroupAIWrapper::UnitCaptured(int unitId, int oldTeam, int newTeam) {
+
+	SUnitCapturedEvent evtData = {unitId, oldTeam, newTeam};
+	ai-&gt;HandleEvent(EVENT_UNIT_CAPTURED, &amp;evtData);
+}
+
+void CGroupAIWrapper::EnemyEnterLOS(int unitId) {
+
+	SEnemyEnterLOSEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_ENTER_LOS, &amp;evtData);
+}
+
+void CGroupAIWrapper::EnemyLeaveLOS(int unitId) {
+
+	SEnemyLeaveLOSEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_LEAVE_LOS, &amp;evtData);
+}
+
+void CGroupAIWrapper::EnemyEnterRadar(int unitId) {
+
+	SEnemyEnterRadarEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_ENTER_RADAR, &amp;evtData);
+}
+
+void CGroupAIWrapper::EnemyLeaveRadar(int unitId) {
+
+	SEnemyLeaveRadarEvent evtData = {unitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_LEAVE_RADAR, &amp;evtData);
+}
+
+void CGroupAIWrapper::EnemyDestroyed(int enemyUnitId, int attackerUnitId) {
+
+	SEnemyDestroyedEvent evtData = {enemyUnitId, attackerUnitId};
+	ai-&gt;HandleEvent(EVENT_ENEMY_DESTROYED, &amp;evtData);
+}
+
+void CGroupAIWrapper::EnemyDamaged(int enemyUnitId, int attackerUnitId,
+		float damage, const float3&amp; dir) {
+
+	SEnemyDamagedEvent evtData = {enemyUnitId, attackerUnitId, damage,
+			dir.toSAIFloat3()};
+	ai-&gt;HandleEvent(EVENT_ENEMY_DAMAGED, &amp;evtData);
+}
+
+void CGroupAIWrapper::Update(int frame) {
+
+	SUpdateEvent evtData = {frame};
+	ai-&gt;HandleEvent(EVENT_UPDATE, &amp;evtData);
+}
+
+void CGroupAIWrapper::GotChatMsg(const char* msg, int fromPlayerId) {
+
+	SMessageEvent evtData = {fromPlayerId, msg};
+	ai-&gt;HandleEvent(EVENT_MESSAGE, &amp;evtData);
+}
+
+void CGroupAIWrapper::WeaponFired(int unitId, int weaponDefId) {
+
+	SWeaponFiredEvent evtData = {unitId, weaponDefId};
+	ai-&gt;HandleEvent(EVENT_WEAPON_FIRED, &amp;evtData);
+}
+
+void CGroupAIWrapper::PlayerCommandGiven(
+		const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId) {
+
+	unsigned int numUnits = selectedUnits.size();
+	int unitIds[numUnits];
+	for (unsigned int i=0; i &lt; numUnits; ++i) {
+		unitIds[i] = selectedUnits.at(i);
+	}
+	int sCommandId;
+	void* sCommandData = mallocSUnitCommand(-1, -1, &amp;c, &amp;sCommandId);
+
+	SPlayerCommandEvent evtData = {unitIds, numUnits, sCommandId, sCommandData,
+			playerId};
+	ai-&gt;HandleEvent(EVENT_PLAYER_COMMAND, &amp;evtData);
+}
+
+void CGroupAIWrapper::SeismicPing(int allyTeam, int unitId,
+		const float3&amp; pos, float strength) {
+
+	SSeismicPingEvent evtData = {pos.toSAIFloat3(), strength};
+	ai-&gt;HandleEvent(EVENT_SEISMIC_PING, &amp;evtData);
+}
+
+
+int CGroupAIWrapper::GetTeamId() const {
+	return teamId;
+}
+int CGroupAIWrapper::GetGroupId() const {
+	return groupId;
+}
+
+void CGroupAIWrapper::SetCheatEventsEnabled(bool enable) {
+	cheatEvents = enable;
+}
+bool CGroupAIWrapper::IsCheatEventsEnabled() const {
+	return cheatEvents;
+}
+
+int CGroupAIWrapper::HandleEvent(int topic, const void* data) const
+{
+	return ai-&gt;HandleEvent(topic, data);
+}


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAIWrapper.cpp
___________________________________________________________________
Name: svn:eol-style
   + native

Added: branches/caiinterface/rts/ExternalAI/GroupAIWrapper.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupAIWrapper.h	                        (rev 0)
+++ branches/caiinterface/rts/ExternalAI/GroupAIWrapper.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -0,0 +1,122 @@
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#ifndef _GROUPAIWRAPPER_H
+#define _GROUPAIWRAPPER_H
+
+#include &quot;Object.h&quot;
+#include &quot;IGroupAI.h&quot;
+#include &quot;GlobalAICallback.h&quot;
+#include &quot;Interface/SAICallback.h&quot;
+#include &quot;Interface/SAIInterfaceLibrary.h&quot;
+#include &quot;Platform/SharedLib.h&quot;
+
+#include &lt;map&gt;
+#include &lt;string&gt;
+
+class CAICallback;
+struct Command;
+struct float3;
+
+class CGroupAIWrapper : public CObject, public IGroupAI {
+public:
+	CR_DECLARE(CGroupAIWrapper);
+
+	CGroupAIWrapper(int teamId, int groupId, const SGAIKey&amp; key,
+			const std::map&lt;std::string, std::string&gt;&amp; options = (std::map&lt;std::string, std::string&gt;()));
+	~CGroupAIWrapper();
+
+	void Serialize(creg::ISerializer *s);
+	void PostLoad();
+
+	// AI Events
+	virtual void Load(std::istream *s);
+	virtual void Save(std::ostream *s);
+
+	// Events in common with Skirmish AIs
+	virtual void UnitIdle(int unitId);
+	virtual void UnitCreated(int unitId);
+	virtual void UnitFinished(int unitId);
+	virtual void UnitDestroyed(int unitId, int attackerUnitId);
+	virtual void UnitDamaged(int unitId, int attackerUnitId, float damage, const float3&amp; dir);
+	virtual void UnitMoveFailed(int unitId);
+	virtual void UnitGiven(int unitId, int oldTeam, int newTeam);
+	virtual void UnitCaptured(int unitId, int oldTeam, int newTeam);
+	virtual void EnemyEnterLOS(int unitId);
+	virtual void EnemyLeaveLOS(int unitId);
+	virtual void EnemyEnterRadar(int unitId);
+	virtual void EnemyLeaveRadar(int unitId);
+	virtual void EnemyDestroyed(int enemyUnitId, int attackerUnitId);
+	virtual void EnemyDamaged(int enemyUnitId, int attackerUnitId, float damage, const float3&amp; dir);
+	virtual void Update(int frame);
+//	virtual void Update();				//called once a frame (30 times a second)
+	virtual void GotChatMsg(const char* msg, int fromPlayerId);
+	virtual void WeaponFired(int unitId, int weaponDefId);
+	virtual void PlayerCommandGiven(const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId);
+//	virtual void GiveCommand(Command* c);		//the group is given a command by the player
+	virtual void SeismicPing(int allyTeam, int unitId, const float3&amp; pos, float strength);
+
+	// Group AI specific Events
+	virtual bool AddUnit(int unitId);		//group should return false if it doenst want the unit for some reason
+	virtual void RemoveUnit(int unitId);		//no way to refuse giving up a unit
+	//the ai tells the interface what commands it can take (note that it returns a reference so it must keep the vector in memory itself)
+	virtual const std::vector&lt;CommandDescription&gt;&amp; GetPossibleCommands();
+	virtual int GetDefaultCmd(int unitId);	//the default command for the ai given that the mouse pointer hovers above unit unitid (or no unit if unitid=0)
+	virtual void CommandFinished(int unitId, int commandTopic);	//a specific unit has finished a specific command, might be a good idea to give new orders to it
+	virtual void DrawCommands();				//the place to use the LineDrawer interface functions
+
+
+	virtual void PreDestroy(); // called just before all the units are destroyed
+
+	virtual int GetTeamId() const;
+	virtual int GetGroupId() const;
+
+	virtual void SetCheatEventsEnabled(bool enable);
+	virtual bool IsCheatEventsEnabled() const;
+
+
+	/**
+	 * Inherited form IGroupAI.
+	 * CAUTION: takes C AI Interface events, not engine C++ ones!
+	 */
+	virtual int HandleEvent(int topic, const void* data) const;
+
+private:
+	virtual void Init();
+	virtual void Release();
+
+private:
+	int teamId;
+	int groupId;
+	bool cheatEvents;
+
+//	bool loadSupported;
+
+	IGroupAI* ai;
+	CGroupAICallback* callback;
+	SAICallback* c_callback;
+	SGAIKey key;
+	std::vector&lt;std::string&gt; optionKeys;
+	std::vector&lt;std::string&gt; optionValues;
+	const char** optionKeys_c;
+	const char** optionValues_c;
+
+private:
+	void LoadGroupAI(bool postLoad);
+};
+
+#endif // _GROUPAIWRAPPER_H


Property changes on: branches/caiinterface/rts/ExternalAI/GroupAIWrapper.h
___________________________________________________________________
Name: svn:eol-style
   + native

Modified: branches/caiinterface/rts/ExternalAI/GroupHandler.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupHandler.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/GroupHandler.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -63,26 +63,32 @@
 
 void CGroupHandler::Load(std::istream *s)
 {
+/*
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)&amp;&amp;((*ai)-&gt;ai)) {
 			(*ai)-&gt;ai-&gt;Load((IGroupAICallback*)(*ai)-&gt;callback,s);
 		}
+*/
 }
 
 void CGroupHandler::Save(std::ostream *s)
 {
+/*
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)&amp;&amp;((*ai)-&gt;ai)) {
 			(*ai)-&gt;ai-&gt;Save(s);
 		}
+*/
 }
 
 void CGroupHandler::Update()
 {
 	SCOPED_TIMER(&quot;Group AI&quot;);
+/*
 	for(std::vector&lt;CGroup*&gt;::iterator ai=groups.begin();ai!=groups.end();++ai)
 		if((*ai)!=0)
 			(*ai)-&gt;Update();
+*/
 }
 
 void CGroupHandler::DrawCommands()
@@ -119,11 +125,13 @@
 
 	int i=GetGroupAiVersion();
 
+/*
 	if (i!=AI_INTERFACE_VERSION){
 		logOutput.Print(&quot;AI dll %s has incorrect version&quot;, name.c_str());
 		delete lib;
 		return;
 	}
+*/
 
 	IsUnitSuited = (ISUNITSUITED)lib-&gt;FindAddress(&quot;IsUnitSuited&quot;);
 	if (!IsUnitSuited){

Modified: branches/caiinterface/rts/ExternalAI/GroupHandler.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/GroupHandler.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/GroupHandler.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,54 +1,70 @@
-#ifndef GROUPHANDLER_H
-#define GROUPHANDLER_H
-// GroupHandler.h: interface for the CGroupHandler class.
-//
-//////////////////////////////////////////////////////////////////////
+/*
+	@author ???
+	@author Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
+*/
 
+#ifndef	_GROUPHANDLER_H
+#define	_GROUPHANDLER_H
+
 #include &lt;map&gt;
 #include &lt;string&gt;
 #include &lt;vector&gt;
 #include &lt;set&gt;
-#include &quot;ExternalAI/aikey.h&quot;
+//#include &quot;ExternalAI/aikey.h&quot;
 #include &quot;Game/GlobalConstants.h&quot;
 
 class CGroup;
-class CUnitSet;
+//class CUnitSet;
 
-class CGroupHandler
-{
-public:
+/**
+ * Handles All Groups of a single team.
+ * NOTE: Does not handle GroupAIs anymore, this is done by the groups themself.
+ */
+class CGroupHandler {
+private:
 	CR_DECLARE(CGroupHandler);
-	CGroupHandler(int team);
+	CGroupHandler(int teamId);
 	virtual ~CGroupHandler();
+
+public:
+
+	/**
+	 * This function initialized a singleton instance,
+	 * if not yet done by a call to GetInstance()
+	 */
+	static void Initialize(int teamId);
+	static CGroupHandler* GetInstance(int teamId);
+	static void Destroy(int teamId);
+
 	void PostLoad();
 
 	void Update();
 	void DrawCommands();
 	void GroupCommand(int num);
 	void GroupCommand(int num, const std::string&amp; cmd);
-	CGroup* CreateNewGroup(AIKey aiKey);
+//	CGroup* CreateNewGroup(AIKey aiKey);
 	void RemoveGroup(CGroup* group);
 	void Load(std::istream *s);
 	void Save(std::ostream *s);
 
-	std::vector&lt;CGroup*&gt; groups;
-	std::map&lt;AIKey, std::string&gt; availableAI;
+//	std::map&lt;AIKey, std::string&gt; availableAI;
 
-	std::map&lt;AIKey, std::string&gt; GetSuitedAis(const CUnitSet&amp; units);
-	std::map&lt;AIKey, std::string&gt; lastSuitedAis;
+//	std::map&lt;AIKey, std::string&gt; GetSuitedAis(const CUnitSet&amp; units);
+//	std::map&lt;AIKey, std::string&gt; lastSuitedAis;
 
-	int team;
 protected:
-	void FindDlls(void);
-	void TestDll(std::string name);
+	int teamId;
+	std::vector&lt;CGroup*&gt; groups;
+//	void FindDlls(void);
+//	void TestDll(std::string name);
 
 	std::vector&lt;int&gt; freeGroups;
 	int firstUnusedGroup;
 private:
-	AIKey defaultKey;
+//	AIKey defaultKey;
 };
 
 //extern CGroupHandler* grouphandler;
-extern CGroupHandler* grouphandlers[MAX_TEAMS];
+//extern CGroupHandler* grouphandlers[MAX_TEAMS];
 
-#endif /* GROUPHANDLER_H */
+#endif	// _GROUPHANDLER_H

Modified: branches/caiinterface/rts/ExternalAI/IGroupAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/IGroupAI.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/IGroupAI.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,36 +1,30 @@
-#ifndef IGROUPAI_H
-#define IGROUPAI_H
-// IGroupAI.h: interface for the IGroupAI class.
-// Dont modify this file
-//////////////////////////////////////////////////////////////////////
+/*
+	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
 
-#include &quot;aibase.h&quot;
-#include &quot;Sim/Units/CommandAI/Command.h&quot;
+	This program is free software {} you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation {} either version 2 of the License, or
+	(at your option) any later version.
 
-class IGroupAICallback;
-class IAICallback;
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY {} without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
 
-#define AI_INTERFACE_VERSION (14 + AI_INTERFACE_GENERATED_VERSION)
+	You should have received a copy of the GNU General Public License
+	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
 
-class SPRING_API IGroupAI
-{
-public:
-	virtual void InitAi(IGroupAICallback* callback)=0;
-	virtual bool AddUnit(int unit)=0;									//group should return false if it doenst want the unit for some reason
-	virtual void RemoveUnit(int unit)=0;								//no way to refuse giving up a unit
+#ifndef	_IGROUPAI_H
+#define	_IGROUPAI_H
 
-	virtual void GiveCommand(Command* c)=0;								//the group is given a command by the player
-	virtual const std::vector&lt;CommandDescription&gt;&amp; GetPossibleCommands()=0;	//the ai tells the interface what commands it can take (note that it returns a reference so it must keep the vector in memory itself)
-	virtual int GetDefaultCmd(int unitid)=0;							//the default command for the ai given that the mouse pointer hovers above unit unitid (or no unit if unitid=0)
-
-	virtual void CommandFinished(int unit,int type)=0;					//a specific unit has finished a specific command, might be a good idea to give new orders to it
-
-	virtual void Update()=0;											//called once a frame (30 times a second)
-	virtual void DrawCommands()=0;										//the place to use the LineDrawer interface functions
-	virtual void Load(IGroupAICallback* callback,std::istream *s){};	//load ai from file
-	virtual void Save(std::ostream *s){};							//save ai to file
-
-	DECLARE_PURE_VIRTUAL(~IGroupAI())
+class IGroupAI {
+public:
+	/**
+	 * Inherited form IGroupAILibrary.
+	 * CAUTION: takes C AI Interface events, not engine C++ ones!
+	 */
+	virtual int HandleEvent(int topic, const void* data) const = 0;
 };
 
-#endif /* IGROUPAI_H */
+#endif	// _IGROUPAI_H

Modified: branches/caiinterface/rts/ExternalAI/IGroupAiCallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/IGroupAiCallback.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/IGroupAiCallback.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -19,9 +19,9 @@
 public:
 	virtual IAICallback *GetAICallback ()=0;
 
-	virtual void UpdateIcons()=0;														//force gui to update the icons
-	virtual const Command* GetOrderPreview()=0;									//this make the game to try to create an order from the current (unfinished) mouse state, dont count on the command being pointed to being left after you call this again or leave the function
-	virtual bool IsSelected()=0;													//returns true if this group is currently selected
+	virtual void UpdateIcons()=0;					//force gui to update the icons
+	virtual const Command* GetOrderPreview()=0;		//this make the game to try to create an order from the current (unfinished) mouse state, dont count on the command being pointed to being left after you call this again or leave the function
+	virtual bool IsSelected()=0;					//returns true if this group is currently selected
 	virtual int GetGroupId()=0;
 
 	virtual int GetUnitLastUserOrder(int unitid)=0;	//last frame the user gave a direct order to a unit, ai should probably leave it be for some time to avoid irritating user

Modified: branches/caiinterface/rts/ExternalAI/ISkirmishAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/ISkirmishAI.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/ISkirmishAI.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software {} you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation {} either version 2 of the License, or
@@ -15,19 +15,16 @@
 	along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
 */
 
-#ifndef _ISKIRMISHAI_H
+#ifndef	_ISKIRMISHAI_H
 #define	_ISKIRMISHAI_H
 
 class ISkirmishAI {
 public:
-//    virtual ~ISkirmishAI() = 0;
-	
 	/**
-	 * inherited form ISkirmishAI.
+	 * Inherited form ISkirmishAILibrary.
 	 * CAUTION: takes C AI Interface events, not engine C++ ones!
 	 */
-    virtual int HandleEvent(int topic, const void* data) const = 0;
+	virtual int HandleEvent(int topic, const void* data) const = 0;
 };
 
-#endif	/* _ISKIRMISHAI_H */
-
+#endif	// _ISKIRMISHAI_H

Modified: branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/Interface/AISCommands.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -20,7 +20,7 @@
 
 // IMPORTANT NOTE: external systems parse this file,
 // so DO NOT CHANGE the style and format it uses without
-// major thought in advance, and deliberation with hoijui!
+// major though in advance, and deliberation with hoijui!
 
 #ifdef	__cplusplus
 extern &quot;C&quot; {
@@ -110,7 +110,7 @@
 	COMMAND_UNIT_CAPTURE_AREA                     = 75,
 	COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL            = 76,
 	COMMAND_UNIT_SET_IDLE_MODE                    = 77,
-	COMMAND_UNIT_CUSTOM                           = 78,        
+	COMMAND_UNIT_CUSTOM                           = 78,
 	COMMAND_CHEATS_GIVE_ME_ENERGY                 = 79,
 	COMMAND_CHEATS_GIVE_ME_NEW_UNIT               = 80,
 //const int COMMAND_UNIT_ATTACK_POS                     
@@ -119,8 +119,8 @@
 //const int COMMAND_UNIT_ATTACK_AREA                    
 //const int COMMAND_UNIT_ATTACK_LOOPBACK                
 //const int COMMAND_UNIT_GROUP_SELECT                   
-//const int COMMAND_UNIT_INTERNAL               
-};
+//const int COMMAND_UNIT_INTERNAL                       
+}; // 
 const unsigned int NUM_CMD_TOPICS                 = 81;
 
 
@@ -130,7 +130,7 @@
 	UNIT_COMMAND_OPTION_SHIFT_KEY         = (1 &lt;&lt; 5), //  32
 	UNIT_COMMAND_OPTION_CONTROL_KEY       = (1 &lt;&lt; 6), //  64
 	UNIT_COMMAND_OPTION_ALT_KEY           = (1 &lt;&lt; 7), // 128
-};
+}; // 
 
 
 #define UNIT_COMMAND_BUILD_NO_FACING -1
@@ -139,69 +139,69 @@
 
 struct SSetMyHandicapCheatCommand {
 	float handicap;
-};
+}; // COMMAND_CHEATS_SET_MY_HANDICAP
 struct SGiveMeMetalCheatCommand {
 	float amount;
-};
+}; // COMMAND_CHEATS_GIVE_ME_METAL
 struct SGiveMeEnergyCheatCommand {
 	float amount;
-};
+}; // COMMAND_CHEATS_GIVE_ME_ENERGY
 struct SGiveMeNewUnitCheatCommand {
 	int unitDefId;
 	struct SAIFloat3 pos;
 	int ret_newUnitId;
-};
+}; // COMMAND_CHEATS_GIVE_ME_NEW_UNIT
 
 struct SSendTextMessageCommand {
 	const char* text;
 	int zone;
-};
+}; // COMMAND_SEND_TEXT_MESSAGE
 
 struct SSetLastPosMessageCommand {
 	struct SAIFloat3 pos;
-};
+}; // COMMAND_SET_LAST_POS_MESSAGE
 
 struct SSendResourcesCommand {
 	float mAmount;
 	float eAmount;
 	int receivingTeam;
 	bool ret_isExecuted;
-};
+}; // COMMAND_SEND_RESOURCES
 
 struct SSendUnitsCommand {
 	int* unitIds;
 	int numUnitIds;
 	int receivingTeam;
 	int ret_sentUnits;
-};
+}; // COMMAND_SEND_UNITS
 
 struct SCreateSharedMemAreaCommand {
 	char* name;
 	int size;
 	void* ret_sharedMemArea;
-};
+}; // COMMAND_SHARED_MEM_AREA_CREATE
 
 struct SReleaseSharedMemAreaCommand {
 	char* name;
-};
+}; // COMMAND_SHARED_MEM_AREA_RELEASE
 
 struct SCreateGroupCommand {
 	const char* libraryName;
 	unsigned int aiNumber;
 	int ret_groupId;
-};
+}; // COMMAND_GROUP_CREATE
 struct SEraseGroupCommand {
 	int groupId;
-};
+}; // COMMAND_GROUP_ERASE
 struct SAddUnitToGroupCommand {
 	int groupId;
 	int unitId;
 	bool ret_isExecuted;
-};
+}; // COMMAND_GROUP_ADD_UNIT
 struct SRemoveUnitFromGroupCommand {
 	int unitId;
 	bool ret_isExecuted;
-};
+}; // COMMAND_GROUP_REMOVE_UNIT
 
 
 struct SInitPathCommand {
@@ -209,7 +209,7 @@
 	struct SAIFloat3 end;
 	int pathType;
 	int ret_pathId;
-};
+}; // COMMAND_PATH_INIT
 /**
  * Returns the approximate path cost between two points
  * note: needs to calculate the complete path so somewhat expensive
@@ -220,73 +220,73 @@
 	struct SAIFloat3 end;
 	int pathType;
 	int ret_approximatePathLength;
-};
+}; // COMMAND_PATH_GET_APPROXIMATE_LENGTH
 struct SGetNextWaypointPathCommand {
 	int pathId;
 	struct SAIFloat3 ret_nextWaypoint;
-};
+}; // COMMAND_PATH_GET_NEXT_WAYPOINT
 struct SFreePathCommand {
 	int pathId;
-};
+}; // COMMAND_PATH_FREE
 
 struct SCallLuaRulesCommand {
 	const char* data;
 	int inSize;
 	int* outSize;
 	const char* ret_outData;
-};
+}; // COMMAND_CALL_LUA_RULES
 
 struct SSendStartPosCommand {///&lt; result of HandleCommand is 1 - ok supported
 	bool ready;
 	struct SAIFloat3 pos;
-};
+}; // COMMAND_SEND_START_POS
 
 struct SAddNotificationDrawerCommand {
 	struct SAIFloat3 pos;
 	struct SAIFloat3 color;
 	float alpha;
-};
+}; // COMMAND_DRAWER_ADD_NOTIFICATION
 struct SAddPointDrawCommand { // result of HandleCommand is 1 - ok supported
 	struct SAIFloat3 pos; // on this position, only x and z matter
 	const char* label; // create this text on pos in my team color
-};
+}; // COMMAND_DRAWER_POINT_ADD
 struct SRemovePointDrawCommand { // result of HandleCommand is 1 - ok supported
 	struct SAIFloat3 pos; // remove map points and lines near this point (100 distance)
-};
+}; // COMMAND_DRAWER_POINT_REMOVE
 struct SAddLineDrawCommand { // result of HandleCommand is 1 - ok supported
 	struct SAIFloat3 posFrom; // draw line from this pos
 	struct SAIFloat3 posTo; // to this pos, again only x and z matter
-};
+}; // COMMAND_DRAWER_LINE_ADD
 
 struct SStartPathDrawerCommand {
 	struct SAIFloat3 pos;
 	struct SAIFloat3 color;
 	float alpha;
-};
+}; // COMMAND_DRAWER_PATH_START
 struct SFinishPathDrawerCommand {
-};
+}; // COMMAND_DRAWER_PATH_FINISH
 struct SDrawLinePathDrawerCommand {
 	struct SAIFloat3 endPos;
 	struct SAIFloat3 color;
 	float alpha;
-};
+}; // COMMAND_DRAWER_PATH_DRAW_LINE
 struct SDrawLineAndIconPathDrawerCommand {
 	int cmdId;
 	struct SAIFloat3 endPos;
 	struct SAIFloat3 color;
 	float alpha;
-};
+}; // COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON
 struct SDrawIconAtLastPosPathDrawerCommand {
 	int cmdId;
-};
+}; // COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS
 struct SBreakPathDrawerCommand {
 	struct SAIFloat3 endPos;
 	struct SAIFloat3 color;
 	float alpha;
-};
+}; // COMMAND_DRAWER_PATH_BREAK
 struct SRestartPathDrawerCommand {
 	bool sameColor;
-};
+}; // COMMAND_DRAWER_PATH_RESTART
 
 /**
  * Creates a cubic Bezier spline figure (from pos1 to pos4 with control points pos2 and pos3)
@@ -301,7 +301,7 @@
 	int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
 	int figureGroupId; // use 0 to get a new group
 	int ret_newFigureGroupId; // the new group
-};
+}; // COMMAND_DRAWER_FIGURE_CREATE_SPLINE
 struct SCreateLineFigureDrawerCommand {
 	struct SAIFloat3 pos1;
 	struct SAIFloat3 pos2;
@@ -310,15 +310,15 @@
 	int lifeTime; // how many frames a figure should live before being autoremoved, 0 means no removal
 	int figureGroupId; // use 0 to get a new group
 	int ret_newFigureGroupId; // the new group
-};
+}; // COMMAND_DRAWER_FIGURE_CREATE_LINE
 struct SSetColorFigureDrawerCommand {
 	int figureGroupId;
 	struct SAIFloat3 color;
 	float alpha;
-};
+}; // COMMAND_DRAWER_FIGURE_SET_COLOR
 struct SDeleteFigureDrawerCommand {
 	int figureGroupId;
-};
+}; // COMMAND_DRAWER_FIGURE_DELETE
 
 struct SDrawUnitDrawerCommand {
 	int toDrawUnitDefId;
@@ -329,7 +329,7 @@
 	bool transparent;
 	bool drawBorder;
 	int facing;
-};
+}; // COMMAND_DRAWER_DRAW_UNIT
 
 
 
@@ -342,35 +342,35 @@
 	int toBuildUnitDefId;
 	struct SAIFloat3 buildPos;
 	int facing; // set to UNIT_COMMAND_BUILD_NO_FACING if you want to specify no facing
-};
+}; // COMMAND_UNIT_BUILD
 
 struct SStopUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_STOP
 
 //	struct SInsertUnitCommand {
 //		int unitId;
 //		int groupId;
 //		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 //		int timeOut; // command execution-time in ?seconds?
-//	};	
+//	};
 //
 //	struct SRemoveUnitCommand {
 //		int unitId;
 //		int groupId;
 //		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 //		int timeOut; // command execution-time in ?seconds?
-//	};	
+//	};
 
 struct SWaitUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_WAIT
 
 struct STimeWaitUnitCommand {
 	int unitId;
@@ -380,7 +380,7 @@
 
 	// the time in seconds to wait
 	int time;
-};	
+}; // COMMAND_UNIT_WAIT_TIME
 
 struct SDeathWaitUnitCommand {
 	int unitId;
@@ -390,7 +390,7 @@
 
 	// wait until this unit is dead
 	int toDieUnitId;
-};	
+}; // COMMAND_UNIT_WAIT_DEATH
 
 struct SSquadWaitUnitCommand {
 	int unitId;
@@ -399,14 +399,14 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int numUnits;
-};	
+}; // COMMAND_UNIT_WAIT_SQUAD
 
 struct SGatherWaitUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_WAIT_GATHER
 
 struct SMoveUnitCommand {
 	int unitId;
@@ -415,7 +415,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	struct SAIFloat3 toPos;
-};	
+}; // COMMAND_UNIT_MOVE
 
 struct SPatrolUnitCommand {
 	int unitId;
@@ -424,7 +424,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	struct SAIFloat3 toPos;
-};	
+}; // COMMAND_UNIT_PATROL
 
 struct SFightUnitCommand {
 	int unitId;
@@ -433,7 +433,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	struct SAIFloat3 toPos;
-};	
+}; // COMMAND_UNIT_FIGHT
 
 struct SAttackUnitCommand {
 	int unitId;
@@ -442,7 +442,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toAttackUnitId;
-};	
+}; // COMMAND_UNIT_ATTACK
 
 //	struct SAttackPosUnitCommand {
 struct SAttackAreaUnitCommand {
@@ -453,14 +453,14 @@
 
 	struct SAIFloat3 toAttackPos;
 	float radius;
-};	
+}; // COMMAND_UNIT_ATTACK_AREA
 
 //	struct SAttackAreaUnitCommand {
 //		int unitId;
 //		int groupId;
 //		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 //		int timeOut; // command execution-time in ?seconds?
-//	};	
+//	};
 
 struct SGuardUnitCommand {
 	int unitId;
@@ -469,21 +469,21 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toGuardUnitId;
-};	
+}; // COMMAND_UNIT_GUARD
 
 struct SAiSelectUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_AI_SELECT
 
 //	struct SGroupSelectUnitCommand {
 //		int unitId;
 //		int groupId;
 //		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 //		int timeOut; // command execution-time in ?seconds?
-//	};	
+//	};
 
 struct SGroupAddUnitCommand {
 	int unitId;
@@ -492,14 +492,14 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toGroupId;
-};	
+}; // COMMAND_UNIT_GROUP_ADD
 
 struct SGroupClearUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_GROUP_CLEAR
 
 struct SRepairUnitCommand {
 	int unitId;
@@ -508,7 +508,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toRepairUnitId;
-};	
+}; // COMMAND_UNIT_REPAIR
 
 struct SSetFireStateUnitCommand {
 	int unitId;
@@ -518,7 +518,7 @@
 
 	// can be: 0=hold fire, 1=return fire, 2=fire at will
 	int fireState;
-};	
+}; // COMMAND_UNIT_SET_FIRE_STATE
 
 struct SSetMoveStateUnitCommand {
 	int unitId;
@@ -527,7 +527,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int moveState;
-};	
+}; // COMMAND_UNIT_SET_MOVE_STATE
 
 struct SSetBaseUnitCommand {
 	int unitId;
@@ -536,21 +536,21 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	struct SAIFloat3 basePos;
-};	
+}; // COMMAND_UNIT_SET_BASE
 
 //	struct SInternalUnitCommand {
 //		int unitId;
 //		int groupId;
 //		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 //		int timeOut; // command execution-time in ?seconds?
-//	};	
+//	};
 
 struct SSelfDestroyUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_SELF_DESTROY
 
 struct SSetWantedMaxSpeedUnitCommand {
 	int unitId;
@@ -559,7 +559,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	float wantedMaxSpeed;
-};	
+}; // COMMAND_UNIT_SET_WANTED_MAX_SPEED
 
 struct SLoadUnitsUnitCommand {
 	int unitId;
@@ -569,7 +569,7 @@
 
 	int* toLoadUnitIds;
 	int numToLoadUnits;
-};	
+}; // COMMAND_UNIT_LOAD_UNITS
 
 struct SLoadUnitsAreaUnitCommand {
 	int unitId;
@@ -579,7 +579,7 @@
 
 	struct SAIFloat3 pos;
 	float radius;
-};	
+}; // COMMAND_UNIT_LOAD_UNITS_AREA
 
 struct SLoadOntoUnitCommand {
 	int unitId;
@@ -588,7 +588,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int transporterUnitId;
-};	
+}; // COMMAND_UNIT_LOAD_ONTO
 
 struct SUnloadUnitCommand {
 	int unitId;
@@ -598,7 +598,7 @@
 
 	struct SAIFloat3 toPos;
 	int toUnloadUnitId;
-};	
+}; // COMMAND_UNIT_UNLOAD_UNIT
 
 struct SUnloadUnitsAreaUnitCommand {
 	int unitId;
@@ -608,7 +608,7 @@
 
 	struct SAIFloat3 toPos;
 	float radius;
-};	
+}; // COMMAND_UNIT_UNLOAD_UNITS_AREA
 
 struct SSetOnOffUnitCommand {
 	int unitId;
@@ -617,7 +617,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	bool on;
-};	
+}; // COMMAND_UNIT_SET_ON_OFF
 
 struct SReclaimUnitCommand {
 	int unitId;
@@ -626,7 +626,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toReclaimUnitIdOrFeatureId;
-};	
+}; // COMMAND_UNIT_RECLAIM
 
 struct SReclaimAreaUnitCommand {
 	int unitId;
@@ -636,7 +636,7 @@
 
 	struct SAIFloat3 pos;
 	float radius;
-};	
+}; // COMMAND_UNIT_RECLAIM_AREA
 
 struct SCloakUnitCommand {
 	int unitId;
@@ -645,14 +645,14 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	bool cloak;
-};	
+}; // COMMAND_UNIT_CLOAK
 
 struct SStockpileUnitCommand {
 	int unitId;
 	int groupId;
 	unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 	int timeOut; // command execution-time in ?seconds?
-};	
+}; // COMMAND_UNIT_STOCKPILE
 
 struct SDGunUnitCommand {
 	int unitId;
@@ -661,7 +661,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toAttackUnitId;
-};	
+}; // COMMAND_UNIT_D_GUN
 
 struct SDGunPosUnitCommand {
 	int unitId;
@@ -670,7 +670,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	struct SAIFloat3 pos;
-};	
+}; // COMMAND_UNIT_D_GUN_POS
 
 struct SRestoreAreaUnitCommand {
 	int unitId;
@@ -680,7 +680,7 @@
 
 	struct SAIFloat3 pos;
 	float radius;
-};	
+}; // COMMAND_UNIT_RESTORE_AREA
 
 struct SSetRepeatUnitCommand {
 	int unitId;
@@ -689,7 +689,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	bool repeat;
-};	
+}; // COMMAND_UNIT_SET_REPEAT
 
 struct SSetTrajectoryUnitCommand {
 	int unitId;
@@ -698,7 +698,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int trajectory;
-};	
+}; // COMMAND_UNIT_SET_TRAJECTORY
 
 struct SResurrectUnitCommand {
 	int unitId;
@@ -707,7 +707,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toResurrectFeatureId;
-};	
+}; // COMMAND_UNIT_RESURRECT
 
 struct SResurrectAreaUnitCommand {
 	int unitId;
@@ -717,7 +717,7 @@
 
 	struct SAIFloat3 pos;
 	float radius;
-};	
+}; // COMMAND_UNIT_RESURRECT_AREA
 
 struct SCaptureUnitCommand {
 	int unitId;
@@ -726,7 +726,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int toCaptureUnitId;
-};	
+}; // COMMAND_UNIT_CAPTURE
 
 struct SCaptureAreaUnitCommand {
 	int unitId;
@@ -736,7 +736,7 @@
 
 	struct SAIFloat3 pos;
 	float radius;
-};	
+}; // COMMAND_UNIT_CAPTURE_AREA
 
 struct SSetAutoRepairLevelUnitCommand {
 	int unitId;
@@ -745,14 +745,14 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int autoRepairLevel;
-};	
+}; // COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL
 
 //	struct SAttackLoopbackUnitCommand {
 //		int unitId;
 //		int groupId;
 //		unsigned int options; // see UNIT_COMMAND_OPTION_* defines
 //		int timeOut; // command execution-time in ?seconds?
-//	};	
+//	};
 
 struct SSetIdleModeUnitCommand {
 	int unitId;
@@ -761,7 +761,7 @@
 	int timeOut; // command execution-time in ?seconds?
 
 	int idleMode;
-};	
+}; // COMMAND_UNIT_SET_IDLE_MODE
 
 struct SCustomUnitCommand {
 	int unitId;
@@ -772,7 +772,7 @@
 	int cmdId;
 	float* params;
 	int numParams;
-};
+}; // COMMAND_UNIT_CUSTOM
 
 /**
  * @brief Sets default values

Modified: branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/Interface/AISEvents.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -23,7 +23,7 @@
 
 // IMPORTANT NOTE: external systems parse this file,
 // so DO NOT CHANGE the style and format it uses without
-// major thought in advance, and deliberation with hoijui!
+// major though in advance, and deliberation with hoijui!
 
 #ifdef	__cplusplus
 extern &quot;C&quot; {
@@ -65,93 +65,93 @@
 	unsigned int sizeOptions;
 	const char** optionKeys;
 	const char** optionValues;
-};
+}; // EVENT_INIT
 
 struct SReleaseEvent {
 	int team;
-};
+}; // EVENT_RELEASE
 
 struct SUpdateEvent {
 	int frame;
-};
+}; // EVENT_UPDATE
 
 struct SMessageEvent {
 	int player;
 	const char* message;
-};
+}; // EVENT_MESSAGE
 
 struct SUnitCreatedEvent {
 	int unit;
-};
+}; // EVENT_UNIT_CREATED
 
 struct SUnitFinishedEvent {
 	int unit;
-};
+}; // EVENT_UNIT_FINISHED
 
 struct SUnitIdleEvent {
 	int unit;
-};
+}; // EVENT_UNIT_IDLE
 
 struct SUnitMoveFailedEvent {
 	int unit;
-};
+}; // EVENT_UNIT_MOVE_FAILED
 
 struct SUnitDamagedEvent {
 	int unit;
 	int attacker;
 	float damage;
 	struct SAIFloat3 dir;
-};
+}; // EVENT_UNIT_DAMAGED
 
 struct SUnitDestroyedEvent {
 	int unit;
 	int attacker;
-};
+}; // EVENT_UNIT_DESTROYED
 
 struct SUnitGivenEvent {
 	int unitId;
 	int oldTeamId;
 	int newTeamId;
-};
+}; // EVENT_UNIT_GIVEN
 
 struct SUnitCapturedEvent {
 	int unitId;
 	int oldTeamId;
 	int newTeamId;
-};
+}; // EVENT_UNIT_CAPTURED
 
 struct SEnemyEnterLOSEvent {
 	int enemy;
-};
+}; // EVENT_ENEMY_ENTER_LOS
 
 struct SEnemyLeaveLOSEvent {
 	int enemy;
-};
+}; // EVENT_ENEMY_LEAVE_LOS
 
 struct SEnemyEnterRadarEvent {
 	int enemy;
-};
+}; // EVENT_ENEMY_ENTER_RADAR
 
 struct SEnemyLeaveRadarEvent {
 	int enemy;
-};
+}; // EVENT_ENEMY_LEAVE_RADAR
 
 struct SEnemyDamagedEvent {
 	int enemy;
 	int attacker;
 	float damage;
 	struct SAIFloat3 dir;
-};
+}; // EVENT_ENEMY_DAMAGED
 
 struct SEnemyDestroyedEvent {
 	int enemy;
 	int attacker;
-};
+}; // EVENT_ENEMY_DESTROYED
 
 struct SWeaponFiredEvent {
 	int unitId;
 	int weaponDefId;
-};
+}; // EVENT_WEAPON_FIRED
 
 struct SPlayerCommandEvent {
 	int* unitIds;
@@ -159,12 +159,12 @@
 	int commandTopic; // see AISCommands.h COMMAND_* defines
 	void* commandData; // see AISCommands.h S*Command structs
 	int playerId;
-};
+}; // EVENT_PLAYER_COMMAND
 
 struct SSeismicPingEvent {
 	struct SAIFloat3 pos;
 	float strength;
-};
+}; // EVENT_SEISMIC_PING
 
 #ifdef	__cplusplus
 }	// extern &quot;C&quot;

Modified: branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/Interface/SAICallback.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -55,30 +55,24 @@
 int (CALLING_CONV *Game_getMyAllyTeam)(int teamId);
 int (CALLING_CONV *Game_getPlayerTeam)(int teamId, int playerId);
 const char* (CALLING_CONV *Game_getTeamSide)(int teamId, int otherTeamId);
-// END misc callback functions
-
-int (CALLING_CONV *WeaponDef_STATIC_getNumDamageTypes)(int teamId);
-unsigned int (CALLING_CONV *Map_getChecksum)(int teamId);
-
 bool (CALLING_CONV *Game_isExceptionHandlingEnabled)(int teamId);
 bool (CALLING_CONV *Game_isDebugModeEnabled)(int teamId);
 int (CALLING_CONV *Game_getMode)(int teamId);
 bool (CALLING_CONV *Game_isPaused)(int teamId);
 float (CALLING_CONV *Game_getSpeedFactor)(int teamId);
+const char* (CALLING_CONV *Game_getSetupScript)(int teamId);
+// END misc callback functions
 
+
+// BEGINN Visualization related callback functions
 float (CALLING_CONV *Gui_getViewRange)(int teamId);
 float (CALLING_CONV *Gui_getScreenX)(int teamId);
 float (CALLING_CONV *Gui_getScreenY)(int teamId);
 struct SAIFloat3 (CALLING_CONV *Gui_Camera_getDirection)(int teamId);
 struct SAIFloat3 (CALLING_CONV *Gui_Camera_getPosition)(int teamId);
+// END Visualization related callback functions
 
-bool (CALLING_CONV *File_locateForReading)(int teamId, char* filename);
-bool (CALLING_CONV *File_locateForWriting)(int teamId, char* filename);
 
-int (CALLING_CONV *Unit_STATIC_getLimit)(int teamId);
-const char* (CALLING_CONV *Game_getSetupScript)(int teamId);
-
-
 // BEGINN kind of deprecated; it is recommended not to use these
 //bool (CALLING_CONV *getProperty)(int teamId, int id, int property, void* dst);
 //bool (CALLING_CONV *getValue)(int teamId, int id, void* dst);
@@ -108,6 +102,8 @@
 // BEGINN OBJECT File
 int (CALLING_CONV *File_getSize)(int teamId, const char* fileName);
 bool (CALLING_CONV *File_getContent)(int teamId, const char* filename, void* buffer, int bufferLen);
+bool (CALLING_CONV *File_locateForReading)(int teamId, char* filename);
+bool (CALLING_CONV *File_locateForWriting)(int teamId, char* filename);
 // END OBJECT File
 
 
@@ -115,10 +111,8 @@
 int (CALLING_CONV *UnitDef_STATIC_getIds)(int teamId, int unitDefIds[]);
 int (CALLING_CONV *UnitDef_STATIC_getNumIds)(int teamId);
 int (CALLING_CONV *UnitDef_STATIC_getIdByName)(int teamId, const char* unitName);
-
 float (CALLING_CONV *UnitDef_getHeight)(int teamId, int unitDefId);
 float (CALLING_CONV *UnitDef_getRadius)(int teamId, int unitDefId);
-
 bool (CALLING_CONV *UnitDef_isValid)(int teamId, int unitDefId);
 const char* (CALLING_CONV *UnitDef_getName)(int teamId, int unitDefId);
 const char* (CALLING_CONV *UnitDef_getHumanName)(int teamId, int unitDefId);
@@ -362,6 +356,7 @@
 
 
 // BEGINN OBJECT Unit
+int (CALLING_CONV *Unit_STATIC_getLimit)(int teamId);
 int (CALLING_CONV *Unit_STATIC_getEnemies)(int teamId, int unitIds[]);
 int (CALLING_CONV *Unit_STATIC_getEnemiesIn)(int teamId, int unitIds[], struct SAIFloat3 pos, float radius);
 int (CALLING_CONV *Unit_STATIC_getEnemiesInRadarAndLos)(int teamId, int unitIds[]);
@@ -370,12 +365,12 @@
 int (CALLING_CONV *Unit_STATIC_getNeutrals)(int teamId, int unitIds[]);
 int (CALLING_CONV *Unit_STATIC_getNeutralsIn)(int teamId, int unitIds[], struct SAIFloat3 pos, float radius);
 int (CALLING_CONV *Unit_STATIC_getSelected)(int teamId, int unitIds[]);
+int (CALLING_CONV *Unit_STATIC_updateSelectedUnitsIcons)(int teamId);
 
 int (CALLING_CONV *Unit_getDefId)(int teamId, int unitId);
 int (CALLING_CONV *Unit_getAiHint)(int teamId, int unitId);
 int (CALLING_CONV *Unit_getTeam)(int teamId, int unitId);
 int (CALLING_CONV *Unit_getAllyTeam)(int teamId, int unitId);
-
 int (CALLING_CONV *Unit_getStockpile)(int teamId, int unitId);
 int (CALLING_CONV *Unit_getStockpileQueued)(int teamId, int unitId);
 float (CALLING_CONV *Unit_getCurrentFuel)(int teamId, int unitId);
@@ -419,6 +414,7 @@
 bool (CALLING_CONV *Unit_isParalyzed)(int teamId, int unitId);
 bool (CALLING_CONV *Unit_isNeutral)(int teamId, int unitId);
 int (CALLING_CONV *Unit_getBuildingFacing)(int teamId, int unitId);
+int (CALLING_CONV *Unit_getLastUserOrderFrame)(int teamId, int unitId);
 // END OBJECT Unit
 
 
@@ -433,6 +429,13 @@
 int (CALLING_CONV *Group_SupportedCommands_getNumParams)(int teamId, int groupId, int numParams[]);
 //int (CALLING_CONV *Group_SupportedCommands_getParams)(int teamId, int groupId, const char* params[][2]);
 int (CALLING_CONV *Group_SupportedCommands_getParams)(int teamId, int groupId, unsigned int commandIndex, const char* params[]);
+/* for the id, see CMD_xxx codes in Command.h  (custom codes can also be used) */
+int (CALLING_CONV *Group_OrderPreview_getId)(int teamId, int groupId);
+unsigned char (CALLING_CONV *Group_OrderPreview_getOptions)(int teamId, int groupId);
+unsigned int (CALLING_CONV *Group_OrderPreview_getTag)(int teamId, int groupId);
+int (CALLING_CONV *Group_OrderPreview_getTimeOut)(int teamId, int groupId);
+unsigned int (CALLING_CONV *Group_OrderPreview_getParams)(int teamId, int groupId, float params[], unsigned int maxParams);
+bool (CALLING_CONV *Group_isSelected)(int teamId, int groupId);
 // END OBJECT Group
 
 
@@ -444,6 +447,7 @@
 
 
 // BEGINN OBJECT Map
+unsigned int (CALLING_CONV *Map_getChecksum)(int teamId);
 struct SAIFloat3 (CALLING_CONV *Map_getStartPos)(int teamId);
 struct SAIFloat3 (CALLING_CONV *Map_getMousePos)(int teamId);
 bool (CALLING_CONV *Map_isPosInCamera)(int teamId, struct SAIFloat3 pos, float radius);
@@ -528,6 +532,7 @@
 
 // BEGINN OBJECT WeaponDef
 int (CALLING_CONV *WeaponDef_STATIC_getIdByName)(int teamId, const char* weaponDefName);
+int (CALLING_CONV *WeaponDef_STATIC_getNumDamageTypes)(int teamId);
 
 //const SAIWeaponDef* (CALLING_CONV *getWeaponDef)(int teamId, int weaponDefId);
 const char* (CALLING_CONV *WeaponDef_getName)(int teamId, int weaponDefId);

Modified: branches/caiinterface/rts/ExternalAI/SAICallback.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/SAICallback.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software; you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation; either version 2 of the License, or
@@ -24,6 +24,8 @@
 #include &quot;Sim/MoveTypes/MoveInfo.h&quot;
 #include &quot;Sim/Features/FeatureDef.h&quot;
 #include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
+#include &quot;Game/SelectedUnits.h&quot;
+#include &quot;Game/UI/GuiHandler.h&quot;		//TODO: fix some switch for new gui
 #include &quot;Interface/AISCommands.h&quot;
 
 
@@ -33,7 +35,7 @@
 IAICheats* team_cheatCallback[MAX_SKIRMISH_AIS];
 
 /*
-int fillCMap(const std::map&lt;std::string,std::string&gt;* map, const char* cMap[][2]) {
+static int fillCMap(const std::map&lt;std::string,std::string&gt;* map, const char* cMap[][2]) {
 	std::map&lt;std::string,std::string&gt;::const_iterator it;
 	int i;
 	for (i=0, it=map-&gt;begin(); it != map-&gt;end(); ++i, it++) {
@@ -43,7 +45,7 @@
 	return i;
 }
 */
-int fillCMapKeys(const std::map&lt;std::string,std::string&gt;* map, const char* cMapKeys[]) {
+static int fillCMapKeys(const std::map&lt;std::string,std::string&gt;* map, const char* cMapKeys[]) {
 	std::map&lt;std::string,std::string&gt;::const_iterator it;
 	int i;
 	for (i=0, it=map-&gt;begin(); it != map-&gt;end(); ++i, it++) {
@@ -51,7 +53,7 @@
 	}
 	return i;
 }
-int fillCMapValues(const std::map&lt;std::string,std::string&gt;* map, const char* cMapValues[]) {
+static int fillCMapValues(const std::map&lt;std::string,std::string&gt;* map, const char* cMapValues[]) {
 	std::map&lt;std::string,std::string&gt;::const_iterator it;
 	int i;
 	for (i=0, it=map-&gt;begin(); it != map-&gt;end(); ++i, it++) {
@@ -59,19 +61,28 @@
 	}
 	return i;
 }
-void toFloatArr(const SAIFloat3* color, float alpha, float arrColor[4]) {
+static void toFloatArr(const SAIFloat3* color, float alpha, float arrColor[4]) {
 	arrColor[0] = color-&gt;x;
 	arrColor[1] = color-&gt;y;
 	arrColor[2] = color-&gt;z;
 	arrColor[3] = alpha;
 }
-void fillVector(std::vector&lt;int&gt;* vector_unitIds, int* unitIds, int numUnitIds) {
+static void fillVector(std::vector&lt;int&gt;* vector_unitIds, int* unitIds, int numUnitIds) {
 	for (int i=0; i &lt; numUnitIds; ++i) {
 		vector_unitIds-&gt;push_back(unitIds[i]);
 	}
 }
 
-const UnitDef* getUnitDefById(int teamId, int unitDefId) {
+static bool isControlledByLocalPlayer(int teamId) {
+	//TODO
+	???
+		gs-&gt;players[i]-&gt;...;
+	bool gs-&gt;Team(teamId)-&gt;gaia;
+	bool gs-&gt;Team(teamId)-&gt;isAI;
+	bool gs-&gt;players[0]-&gt;;
+}
+
+static const UnitDef* getUnitDefById(int teamId, int unitDefId) {
 	AIHCGetUnitDefById cmd = {unitDefId, NULL};
 	int ret = team_callback[teamId]-&gt;HandleCommand(AIHCGetUnitDefByIdId, &amp;cmd);
 	if (ret == 1) {
@@ -80,7 +91,7 @@
 		return NULL;
 	}
 }
-const WeaponDef* getWeaponDefById(int teamId, int weaponDefId) {
+static const WeaponDef* getWeaponDefById(int teamId, int weaponDefId) {
 	AIHCGetWeaponDefById cmd = {weaponDefId, NULL};
 	int ret = team_callback[teamId]-&gt;HandleCommand(AIHCGetWeaponDefByIdId, &amp;cmd);
 	if (ret == 1) {
@@ -89,7 +100,7 @@
 		return NULL;
 	}
 }
-const FeatureDef* getFeatureDefById(int teamId, int featureDefId) {
+static const FeatureDef* getFeatureDefById(int teamId, int featureDefId) {
 	AIHCGetFeatureDefById cmd = {featureDefId, NULL};
 	int ret = team_callback[teamId]-&gt;HandleCommand(AIHCGetFeatureDefByIdId, &amp;cmd);
 	if (ret == 1) {
@@ -99,7 +110,7 @@
 	}
 }
 
-int wrapper_HandleCommand(IAICallback* clb, IAICheats* clbCheat, int cmdId, void* cmdData) {
+static int wrapper_HandleCommand(IAICallback* clb, IAICheats* clbCheat, int cmdId, void* cmdData) {
 	
 	int ret;
 	
@@ -1377,142 +1388,142 @@
 
 
 Export(int) _WeaponDef_STATIC_getNumDamageTypes(int teamId) {
-    int numDamageTypes;
+	int numDamageTypes;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numDamageTypes);
-    if (!fetchOk) {
-        numDamageTypes = -1;
-    }
-    return numDamageTypes;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_NUMDAMAGETYPES, &amp;numDamageTypes);
+	if (!fetchOk) {
+		numDamageTypes = -1;
+	}
+	return numDamageTypes;
 }
 Export(unsigned int) _Map_getChecksum(int teamId) {
-    unsigned int checksum;
+	unsigned int checksum;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_MAP_CHECKSUM, &amp;checksum);
-    if (!fetchOk) {
-        checksum = -1;
-    }
-    return checksum;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_MAP_CHECKSUM, &amp;checksum);
+	if (!fetchOk) {
+		checksum = -1;
+	}
+	return checksum;
 }
 
 Export(bool) _Game_isExceptionHandlingEnabled(int teamId) {
-    bool exceptionHandlingEnabled;
+	bool exceptionHandlingEnabled;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_EXCEPTION_HANDLING, &amp;exceptionHandlingEnabled);
-    if (!fetchOk) {
-        exceptionHandlingEnabled = false;
-    }
-    return exceptionHandlingEnabled;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_EXCEPTION_HANDLING, &amp;exceptionHandlingEnabled);
+	if (!fetchOk) {
+		exceptionHandlingEnabled = false;
+	}
+	return exceptionHandlingEnabled;
 }
 Export(bool) _Game_isDebugModeEnabled(int teamId) {
-    bool debugModeEnabled;
+	bool debugModeEnabled;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_DEBUG_MODE, &amp;debugModeEnabled);
-    if (!fetchOk) {
-        debugModeEnabled = false;
-    }
-    return debugModeEnabled;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_DEBUG_MODE, &amp;debugModeEnabled);
+	if (!fetchOk) {
+		debugModeEnabled = false;
+	}
+	return debugModeEnabled;
 }
 Export(int) _Game_getMode(int teamId) {
-    int mode;
+	int mode;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_MODE, &amp;mode);
-    if (!fetchOk) {
-        mode = -1;
-    }
-    return mode;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_MODE, &amp;mode);
+	if (!fetchOk) {
+		mode = -1;
+	}
+	return mode;
 }
 Export(bool) _Game_isPaused(int teamId) {
-    bool paused;
+	bool paused;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_PAUSED, &amp;paused);
-    if (!fetchOk) {
-        paused = false;
-    }
-    return paused;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_PAUSED, &amp;paused);
+	if (!fetchOk) {
+		paused = false;
+	}
+	return paused;
 }
 Export(float) _Game_getSpeedFactor(int teamId) {
-    float speedFactor;
+	float speedFactor;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_SPEED_FACTOR, &amp;speedFactor);
-    if (!fetchOk) {
-        speedFactor = false;
-    }
-    return speedFactor;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GAME_SPEED_FACTOR, &amp;speedFactor);
+	if (!fetchOk) {
+		speedFactor = false;
+	}
+	return speedFactor;
 }
 
 Export(float) _Gui_getViewRange(int teamId) {
-    float viewRange;
+	float viewRange;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_VIEW_RANGE, &amp;viewRange);
-    if (!fetchOk) {
-        viewRange = false;
-    }
-    return viewRange;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_VIEW_RANGE, &amp;viewRange);
+	if (!fetchOk) {
+		viewRange = false;
+	}
+	return viewRange;
 }
 Export(float) _Gui_getScreenX(int teamId) {
-    float screenX;
+	float screenX;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENX, &amp;screenX);
-    if (!fetchOk) {
-        screenX = false;
-    }
-    return screenX;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENX, &amp;screenX);
+	if (!fetchOk) {
+		screenX = false;
+	}
+	return screenX;
 }
 Export(float) _Gui_getScreenY(int teamId) {
-    float screenY;
+	float screenY;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENY, &amp;screenY);
-    if (!fetchOk) {
-        screenY = false;
-    }
-    return screenY;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_SCREENY, &amp;screenY);
+	if (!fetchOk) {
+		screenY = false;
+	}
+	return screenY;
 }
 Export(SAIFloat3) _Gui_Camera_getDirection(int teamId) {
-    float3 cameraDir;
+	float3 cameraDir;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_DIR, &amp;cameraDir);
-    if (!fetchOk) {
-        cameraDir = float3(1.0f, 0.0f, 0.0f);
-    }
-    return cameraDir.toSAIFloat3();
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_DIR, &amp;cameraDir);
+	if (!fetchOk) {
+		cameraDir = float3(1.0f, 0.0f, 0.0f);
+	}
+	return cameraDir.toSAIFloat3();
 }
 Export(SAIFloat3) _Gui_Camera_getPosition(int teamId) {
-    float3 cameraPosition;
+	float3 cameraPosition;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_POS, &amp;cameraPosition);
-    if (!fetchOk) {
-        cameraPosition = float3(1.0f, 0.0f, 0.0f);
-    }
-    return cameraPosition.toSAIFloat3();
+	bool fetchOk = clb-&gt;GetValue(AIVAL_GUI_CAMERA_POS, &amp;cameraPosition);
+	if (!fetchOk) {
+		cameraPosition = float3(1.0f, 0.0f, 0.0f);
+	}
+	return cameraPosition.toSAIFloat3();
 }
 
 Export(bool) _File_locateForReading(int teamId, char* filename) {
 	IAICallback* clb = team_callback[teamId];
-    return clb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename);
+	return clb-&gt;GetValue(AIVAL_LOCATE_FILE_R, filename);
 }
 Export(bool) _File_locateForWriting(int teamId, char* filename) {
 	IAICallback* clb = team_callback[teamId];
-    return clb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
+	return clb-&gt;GetValue(AIVAL_LOCATE_FILE_W, filename);
 }
 
 Export(int) _Unit_STATIC_getLimit(int teamId) {
-    int unitLimit;
+	int unitLimit;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_UNIT_LIMIT, &amp;unitLimit);
-    if (!fetchOk) {
-        unitLimit = -1;
-    }
-    return unitLimit;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_UNIT_LIMIT, &amp;unitLimit);
+	if (!fetchOk) {
+		unitLimit = -1;
+	}
+	return unitLimit;
 }
 Export(const char*) _Game_getSetupScript(int teamId) {
-    const char* setupScript;
+	const char* setupScript;
 	IAICallback* clb = team_callback[teamId];
-    bool fetchOk = clb-&gt;GetValue(AIVAL_SCRIPT, &amp;setupScript);
-    if (!fetchOk) {
-        return NULL;
-    }
-    return setupScript;
+	bool fetchOk = clb-&gt;GetValue(AIVAL_SCRIPT, &amp;setupScript);
+	if (!fetchOk) {
+		return NULL;
+	}
+	return setupScript;
 }
 
 
@@ -1965,40 +1976,40 @@
 }
 
 Export(int) _Unit_getStockpile(int teamId, int unitId) {
-    IAICallback* clb = team_callback[teamId];
-    int stockpile;
-    bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILED, unitId, &amp;stockpile);
-    if (!fetchOk) {
-        stockpile = -1;
-    }
-    return stockpile;
+	IAICallback* clb = team_callback[teamId];
+	int stockpile;
+	bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILED, unitId, &amp;stockpile);
+	if (!fetchOk) {
+		stockpile = -1;
+	}
+	return stockpile;
 }
 Export(int) _Unit_getStockpileQueued(int teamId, int unitId) {
-    IAICallback* clb = team_callback[teamId];
-    int stockpileQueue;
-    bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILE_QUED, unitId, &amp;stockpileQueue);
-    if (!fetchOk) {
-        stockpileQueue = -1;
-    }
-    return stockpileQueue;
+	IAICallback* clb = team_callback[teamId];
+	int stockpileQueue;
+	bool fetchOk = clb-&gt;GetProperty(AIVAL_STOCKPILE_QUED, unitId, &amp;stockpileQueue);
+	if (!fetchOk) {
+		stockpileQueue = -1;
+	}
+	return stockpileQueue;
 }
 Export(float) _Unit_getCurrentFuel(int teamId, int unitId) {
-    IAICallback* clb = team_callback[teamId];
-    float currentFuel;
-    bool fetchOk = clb-&gt;GetProperty(AIVAL_CURRENT_FUEL, unitId, &amp;currentFuel);
-    if (!fetchOk) {
-        currentFuel = -1.0f;
-    }
-    return currentFuel;
+	IAICallback* clb = team_callback[teamId];
+	float currentFuel;
+	bool fetchOk = clb-&gt;GetProperty(AIVAL_CURRENT_FUEL, unitId, &amp;currentFuel);
+	if (!fetchOk) {
+		currentFuel = -1.0f;
+	}
+	return currentFuel;
 }
 Export(float) _Unit_getMaxSpeed(int teamId, int unitId) {
-    IAICallback* clb = team_callback[teamId];
-    float maxSpeed;
-    bool fetchOk = clb-&gt;GetProperty(AIVAL_UNIT_MAXSPEED, unitId, &amp;maxSpeed);
-    if (!fetchOk) {
-        maxSpeed = -1.0f;
-    }
-    return maxSpeed;
+	IAICallback* clb = team_callback[teamId];
+	float maxSpeed;
+	bool fetchOk = clb-&gt;GetProperty(AIVAL_UNIT_MAXSPEED, unitId, &amp;maxSpeed);
+	if (!fetchOk) {
+		maxSpeed = -1.0f;
+	}
+	return maxSpeed;
 }
 
 Export(float) _Unit_getMaxRange(int teamId, int unitId) {
@@ -2312,6 +2323,12 @@
 		return team_callback[teamId]-&gt;GetBuildingFacing(unitId);
 	}
 }
+Export(int) _Unit_getLastUserOrderFrame(int teamId, int unitId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return -1;
+	
+	return uh-&gt;units[unitId]-&gt;commandAI-&gt;lastUserCommand;
+}
 //########### END Unit
 
 Export(int) _Unit_STATIC_getEnemies(int teamId, int* unitIds) {
@@ -2353,7 +2370,7 @@
 	}
 }
 
-Export(int) _Unit_STATIC_getNeutralsIn(int teamId, int* unitIds, SAIFloat3 pos, float radius) {
+Export(int) _Unit_STATIC_getNeutralsIn(int teamId, int unitIds[], SAIFloat3 pos, float radius) {
 //	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
 	if (_Cheats_isEnabled(teamId)) {
 		return team_cheatCallback[teamId]-&gt;GetNeutralUnits(unitIds, float3(pos), radius);
@@ -2362,6 +2379,13 @@
 	}
 }
 
+Export(void) _Unit_STATIC_updateSelectedUnitsIcons(int teamId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return;
+
+	selectedUnits.PossibleCommandChange(0);
+}
+
 Export(const char*) _Mod_getName(int teamId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;GetModName();
 }
@@ -2993,6 +3017,66 @@
 	return size;
 }
 
+Export(int) _Group_OrderPreview_getId(int teamId, int groupId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return -1;
+
+	//TODO: need to add support for new gui
+	Command tmpCmd = guihandler-&gt;GetOrderPreview();
+	return tmpCmd.id;
+}
+Export(unsigned char) _Group_OrderPreview_getOptions(int teamId, int groupId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return '\0';
+
+	//TODO: need to add support for new gui
+	Command tmpCmd = guihandler-&gt;GetOrderPreview();
+	return tmpCmd.options;
+}
+Export(unsigned int) _Group_OrderPreview_getTag(int teamId, int groupId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return 0;
+
+	//TODO: need to add support for new gui
+	Command tmpCmd = guihandler-&gt;GetOrderPreview();
+	return tmpCmd.tag;
+}
+Export(int) _Group_OrderPreview_getTimeOut(int teamId, int groupId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return -1;
+
+	//TODO: need to add support for new gui
+	Command tmpCmd = guihandler-&gt;GetOrderPreview();
+	return tmpCmd.timeOut;
+}
+Export(unsigned int) _Group_OrderPreview_getParams(int teamId, int groupId,
+		float params[], unsigned int maxParams) {
+
+	if (!isControlledByLocalPlayer(teamId)) return 0;
+
+	//TODO: need to add support for new gui
+	Command tmpCmd = guihandler-&gt;GetOrderPreview();
+	unsigned int numParams = maxParams &lt; tmpCmd.params.size() ? maxParams
+			: tmpCmd.params.size();
+
+	unsigned int i;
+	for (i = 0; i &lt; numParams; i++) {
+		params[i] = tmpCmd.params[i];
+	}
+
+	return numParams;
+}
+
+Export(bool) _Group_isSelected(int teamId, int groupId) {
+
+	if (!isControlledByLocalPlayer(teamId)) return false;
+
+	return selectedUnits.selectedGroup == groupId;
+}
+
+
+
+
 /*
 Export(bool) _Unit_addToGroup(int teamId, int unitId, int groupId) {
 	IAICallback* clb = team_callback[teamId]; return clb-&gt;AddUnitToGroup(unitId, groupId);
@@ -3626,6 +3710,14 @@
 //	sAICallback-&gt;WeaponDef_getCustomParams = _WeaponDef_getCustomParams;
 	sAICallback-&gt;WeaponDef_getCustomParamKeys = _WeaponDef_getCustomParamKeys;
 	sAICallback-&gt;WeaponDef_getCustomParamValues = _WeaponDef_getCustomParamValues;
+	sAICallback-&gt;Unit_STATIC_updateSelectedUnitsIcons = _Unit_STATIC_updateSelectedUnitsIcons;
+	sAICallback-&gt;Group_OrderPreview_getId = _Group_OrderPreview_getId;
+	sAICallback-&gt;Group_OrderPreview_getOptions = _Group_OrderPreview_getOptions;
+	sAICallback-&gt;Group_OrderPreview_getTag = _Group_OrderPreview_getTag;
+	sAICallback-&gt;Group_OrderPreview_getTimeOut = _Group_OrderPreview_getTimeOut;
+	sAICallback-&gt;Group_OrderPreview_getParams = _Group_OrderPreview_getParams;
+	sAICallback-&gt;Group_isSelected = _Group_isSelected;
+	sAICallback-&gt;Unit_getLastUserOrderFrame = _Unit_getLastUserOrderFrame;
 	
 	team_globalCallback[teamId] = aiGlobalCallback;
 //	team_callback[teamId] = aiCallback;

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAI.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software {} you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation {} either version 2 of the License, or
@@ -18,21 +18,21 @@
 #include &quot;SkirmishAI.h&quot;
 
 #include &quot;IAILibraryManager.h&quot;
+#include &quot;ISkirmishAILibrary.h&quot;
 
-CSkirmishAI::CSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey)
+CSkirmishAI::CSkirmishAI(int teamId, const SSAIKey&amp; key)
 		: teamId(teamId), skirmishAIKey(skirmishAIKey) {
-	
-	skirmishAILibrary = IAILibraryManager::GetInstance()-&gt;FetchSkirmishAILibrary(skirmishAIKey);
-	skirmishAILibrary-&gt;Init(teamId);
+
+	library = IAILibraryManager::GetInstance()-&gt;FetchSkirmishAILibrary(skirmishAIKey);
+	library-&gt;Init(teamId);
 }
 
 CSkirmishAI::~CSkirmishAI() {
-	
-	skirmishAILibrary-&gt;Release(teamId);
-	IAILibraryManager::GetInstance()-&gt;ReleaseSkirmishAILibrary(skirmishAIKey);
+
+	library-&gt;Release(teamId);
+	IAILibraryManager::GetInstance()-&gt;ReleaseSkirmishAILibrary(key);
 }
 
 int CSkirmishAI::HandleEvent(int topic, const void* data) const {
-	return skirmishAILibrary-&gt;HandleEvent(teamId, topic, data);
+	return library-&gt;HandleEvent(teamId, topic, data);
 }
-

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAI.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAI.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAI.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software {} you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation {} either version 2 of the License, or
@@ -16,24 +16,25 @@
 */
 
 #ifndef _SKIRMISHAI_H
-#define	_SKIRMISHAI_H
+#define _SKIRMISHAI_H
 
 #include &quot;ISkirmishAI.h&quot;
-#include &quot;ISkirmishAILibrary.h&quot;
+//#include &quot;ISkirmishAILibrary.h&quot;
 #include &quot;Interface/SAIInterfaceLibrary.h&quot;
 
+class ISkirmishAILibrary;
+
 class CSkirmishAI : public ISkirmishAI {
 public:
-    CSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey);
-    virtual ~CSkirmishAI();
-	
-    virtual int HandleEvent(int topic, const void* data) const;
-	
+	CSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey);
+	virtual ~CSkirmishAI();
+
+	virtual int HandleEvent(int topic, const void* data) const;
+
 private:
 	int teamId;
 	const SSAIKey skirmishAIKey;
 	const ISkirmishAILibrary* skirmishAILibrary;
 };
 
-#endif	/* _SKIRMISHAI_H */
-
+#endif	// _SKIRMISHAI_H

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software {} you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation {} either version 2 of the License, or
@@ -78,14 +78,14 @@
 CSkirmishAIWrapper::CSkirmishAIWrapper(int teamId, const SSAIKey&amp; key,
 		const std::map&lt;std::string, std::string&gt;&amp; options)
 		: teamId(teamId), cheatEvents(false), key(key) {
-	
+
 	std::map&lt;std::string, std::string&gt;::const_iterator op;
-    for (op = options.begin(); op != options.end(); ++op) {
-        optionKeys.push_back(op-&gt;first);
-        optionValues.push_back(op-&gt;second);
-    }
+	for (op = options.begin(); op != options.end(); ++op) {
+		optionKeys.push_back(op-&gt;first);
+		optionValues.push_back(op-&gt;second);
+	}
 
-	LoadSkirmishAI(teamId, key, false);
+	LoadSkirmishAI(false);
 
 	Init();
 }
@@ -95,7 +95,7 @@
 }
 
 CSkirmishAIWrapper::~CSkirmishAIWrapper() {
-	
+
 	if (ai) {
 		Release();
 		delete c_callback;
@@ -108,16 +108,15 @@
 
 
 void CSkirmishAIWrapper::PostLoad() {
-	LoadSkirmishAI(teamId, key, true);
+	LoadSkirmishAI(true);
 }
 
 
 
-void CSkirmishAIWrapper::LoadSkirmishAI(int teamId,
-		const SSAIKey&amp; skirmishAIKey, bool postLoad) {
-	
+void CSkirmishAIWrapper::LoadSkirmishAI(bool postLoad) {
+
 	ai = SAFE_NEW CSkirmishAI(teamId, key);
-	
+
 	IAILibraryManager* libManager = IAILibraryManager::GetInstance();
 	libManager-&gt;FetchSkirmishAILibrary(key);
 	const CSkirmishAILibraryInfo* infos =
@@ -169,9 +168,9 @@
 	unsigned int size = strVec.size();
 	strArr = (const char**) calloc(size, sizeof(char*));
 	unsigned int i;
-    for (i = 0; i &lt; size; ++i) {
-        strArr[i] = strVec[i].c_str();
-    }
+	for (i = 0; i &lt; size; ++i) {
+		strArr[i] = strVec[i].c_str();
+	}
 
 	return strArr;
 }
@@ -188,19 +187,19 @@
 }
 
 void CSkirmishAIWrapper::Release() {
-	
+
 	SReleaseEvent evtData = {teamId};
 	ai-&gt;HandleEvent(EVENT_RELEASE, &amp;evtData);
-	
+
 	free(optionKeys_c);
 	free(optionValues_c);
-	
+
 	// further cleanup is done in the destructor
 }
 
 
 void CSkirmishAIWrapper::Load(std::istream* s) {
-	
+
 /* TODO
 	SLoadAIEvent evtData = {s.TO_FILENAME(TODO), callback};
 	ai-&gt;HandleEvent(EVENT_LOAD_AI, &amp;evtData);
@@ -208,7 +207,7 @@
 }
 
 void CSkirmishAIWrapper::Save(std::ostream* s) {
-	
+
 /* TODO
 	SSaveAIEvent evtData = {s.TO_FILENAME(TODO)};
 	ai-&gt;HandleEvent(EVENT_SAVE_AI, &amp;evtData);
@@ -216,39 +215,39 @@
 }
 
 void CSkirmishAIWrapper::UnitIdle(int unitId) {
-	
+
 	SUnitIdleEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_UNIT_IDLE, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::UnitCreated(int unitId) {
-	
+
 	SUnitCreatedEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_UNIT_CREATED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::UnitFinished(int unitId) {
-	
+
 	SUnitFinishedEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_UNIT_FINISHED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::UnitDestroyed(int unitId, int attackerUnitId) {
-	
+
 	SUnitDestroyedEvent evtData = {unitId, attackerUnitId};
 	ai-&gt;HandleEvent(EVENT_UNIT_DESTROYED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::UnitDamaged(int unitId, int attackerUnitId,
 		float damage, const float3&amp; dir) {
-	
+
 	SUnitDamagedEvent evtData = {unitId, attackerUnitId, damage,
 			dir.toSAIFloat3()};
 	ai-&gt;HandleEvent(EVENT_UNIT_DAMAGED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::UnitMoveFailed(int unitId) {
-	
+
 	SUnitMoveFailedEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_UNIT_MOVE_FAILED, &amp;evtData);
 }
@@ -260,70 +259,70 @@
 }
 
 void CSkirmishAIWrapper::UnitCaptured(int unitId, int oldTeam, int newTeam) {
-	
+
 	SUnitCapturedEvent evtData = {unitId, oldTeam, newTeam};
 	ai-&gt;HandleEvent(EVENT_UNIT_CAPTURED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::EnemyEnterLOS(int unitId) {
-	
+
 	SEnemyEnterLOSEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_ENEMY_ENTER_LOS, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::EnemyLeaveLOS(int unitId) {
-	
+
 	SEnemyLeaveLOSEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_ENEMY_LEAVE_LOS, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::EnemyEnterRadar(int unitId) {
-	
+
 	SEnemyEnterRadarEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_ENEMY_ENTER_RADAR, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::EnemyLeaveRadar(int unitId) {
-	
+
 	SEnemyLeaveRadarEvent evtData = {unitId};
 	ai-&gt;HandleEvent(EVENT_ENEMY_LEAVE_RADAR, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::EnemyDestroyed(int enemyUnitId, int attackerUnitId) {
-	
+
 	SEnemyDestroyedEvent evtData = {enemyUnitId, attackerUnitId};
 	ai-&gt;HandleEvent(EVENT_ENEMY_DESTROYED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::EnemyDamaged(int enemyUnitId, int attackerUnitId,
 		float damage, const float3&amp; dir) {
-	
+
 	SEnemyDamagedEvent evtData = {enemyUnitId, attackerUnitId, damage,
 			dir.toSAIFloat3()};
 	ai-&gt;HandleEvent(EVENT_ENEMY_DAMAGED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::Update(int frame) {
-	
+
 	SUpdateEvent evtData = {frame};
 	ai-&gt;HandleEvent(EVENT_UPDATE, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::GotChatMsg(const char* msg, int fromPlayerId) {
-	
+
 	SMessageEvent evtData = {fromPlayerId, msg};
 	ai-&gt;HandleEvent(EVENT_MESSAGE, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::WeaponFired(int unitId, int weaponDefId) {
-	
+
 	SWeaponFiredEvent evtData = {unitId, weaponDefId};
 	ai-&gt;HandleEvent(EVENT_WEAPON_FIRED, &amp;evtData);
 }
 
 void CSkirmishAIWrapper::PlayerCommandGiven(
 		const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId) {
-	
+
 	unsigned int numUnits = selectedUnits.size();
 	int unitIds[numUnits];
 	for (unsigned int i=0; i &lt; numUnits; ++i) {
@@ -331,7 +330,7 @@
 	}
 	int sCommandId;
 	void* sCommandData = mallocSUnitCommand(-1, -1, &amp;c, &amp;sCommandId);
-	
+
 	SPlayerCommandEvent evtData = {unitIds, numUnits, sCommandId, sCommandData,
 			playerId};
 	ai-&gt;HandleEvent(EVENT_PLAYER_COMMAND, &amp;evtData);
@@ -339,7 +338,7 @@
 
 void CSkirmishAIWrapper::SeismicPing(int allyTeam, int unitId,
 		const float3&amp; pos, float strength) {
-	
+
 	SSeismicPingEvent evtData = {pos.toSAIFloat3(), strength};
 	ai-&gt;HandleEvent(EVENT_SEISMIC_PING, &amp;evtData);
 }
@@ -360,4 +359,3 @@
 {
 	return ai-&gt;HandleEvent(topic, data);
 }
-

Modified: branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/SkirmishAIWrapper.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,6 +1,6 @@
 /*
 	Copyright (c) 2008 Robin Vobruba &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">hoijui.quaero at gmail.com</A>&gt;
-	
+
 	This program is free software {} you can redistribute it and/or modify
 	it under the terms of the GNU General Public License as published by
 	the Free Software Foundation {} either version 2 of the License, or
@@ -42,11 +42,11 @@
 
 	void Serialize(creg::ISerializer *s);
 	void PostLoad();
-	
+
 	// AI Events
 	virtual void Load(std::istream *s);
 	virtual void Save(std::ostream *s);
-	
+
 	virtual void UnitIdle(int unitId);
 	virtual void UnitCreated(int unitId);
 	virtual void UnitFinished(int unitId);
@@ -67,27 +67,25 @@
 	virtual void PlayerCommandGiven(const std::vector&lt;int&gt;&amp; selectedUnits, const Command&amp; c, int playerId);
 	virtual void SeismicPing(int allyTeam, int unitId, const float3&amp; pos, float strength);
 
-	
-	
+
 	virtual void PreDestroy(); // called just before all the units are destroyed
-	
-    virtual int GetTeamId() const;
-	
-    virtual void SetCheatEventsEnabled(bool enable);
-    virtual bool IsCheatEventsEnabled() const;
-	
-	
-	
+
+	virtual int GetTeamId() const;
+
+	virtual void SetCheatEventsEnabled(bool enable);
+	virtual bool IsCheatEventsEnabled() const;
+
+
 	/**
 	 * inherited form ISkirmishAI.
 	 * CAUTION: takes C AI Interface events, not engine C++ ones!
 	 */
-    virtual int HandleEvent(int topic, const void* data) const;
+	virtual int HandleEvent(int topic, const void* data) const;
 
 private:
 	virtual void Init();
 	virtual void Release();
-	
+
 private:
 	int teamId;
 	bool cheatEvents;
@@ -109,7 +107,7 @@
 //	typedef IGlobalAI* (*GETNEWAIBYNAME)(const char*, int);
 //	typedef void (*RELEASEAI)(IGlobalAI* i);
 //	typedef bool (*ISLOADSUPPORTED)();
-	
+
 //	ISCINTERFACE _IsCInterfaceFunc;
 //	GETGLOBALAIVERSION _GetGlobalAiVersionFunc;
 //	GETNEWAI _GetNewAIFunc;
@@ -118,10 +116,7 @@
 //	ISLOADSUPPORTED _IsLoadSupportedFunc;
 
 private:
-	void LoadSkirmishAI(int teamId, const SSAIKey&amp; skirmishAIKey, bool postLoad);
-//	void LoadCPPAI(int, const char*, bool, bool, bool);
-//	void LoadJavaProxyAI();
+	void LoadSkirmishAI(bool postLoad);
 };
 
-#endif /* _SKIRMISHAIWRAPPER_H */
-
+#endif // _SKIRMISHAIWRAPPER_H

Modified: branches/caiinterface/rts/ExternalAI/aikey.h
===================================================================
--- branches/caiinterface/rts/ExternalAI/aikey.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/ExternalAI/aikey.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -1,47 +1,47 @@
-#ifndef AIKEY_H
-#define AIKEY_H
-// aikey.h: defines the AIKey data type, a pair of (dllName, aiNumber)
-// which allows multiple AIs to exist within a single DLL. An instance
-// of AIKey uniquely identifies a particular AI.
-//////////////////////////////////////////////////////////////////////
-
-#include &lt;string&gt;
-
-#include &quot;creg/creg.h&quot;
-
-struct AIKey
-{
-	CR_DECLARE_STRUCT(AIKey);
-	std::string dllName;
-	unsigned aiNumber;
-
-	AIKey(){}
-	AIKey(std::string DllName,unsigned AiNumber)
-	: dllName(DllName), aiNumber(AiNumber)
-	{}
-
-	bool operator&lt;(const AIKey&amp;that) const
-	{
-		if(dllName==that.dllName){
-			return aiNumber&lt;that.aiNumber;
-		} else {
-			return dllName&lt;that.dllName;
-		}
-	};
-
-	bool operator!=(const AIKey&amp;that) const
-	{
-		return ! ((* this) == that);
-	};
-
-	bool operator==(const AIKey&amp;that) const
-	{
-		return (aiNumber==that.aiNumber)
-			&amp;&amp; (dllName==that.dllName);
-	};
-
-};
-
-
-#endif // AIKEY_H
-
+//#ifndef AIKEY_H
+//#define AIKEY_H
+//// aikey.h: defines the AIKey data type, a pair of (dllName, aiNumber)
+//// which allows multiple AIs to exist within a single DLL. An instance
+//// of AIKey uniquely identifies a particular AI.
+////////////////////////////////////////////////////////////////////////
+//
+//#include &lt;string&gt;
+//
+//#include &quot;creg/creg.h&quot;
+//
+//struct AIKey
+//{
+//	CR_DECLARE_STRUCT(AIKey);
+//	std::string dllName;
+//	unsigned aiNumber;
+//
+//	AIKey(){}
+//	AIKey(std::string DllName,unsigned AiNumber)
+//	: dllName(DllName), aiNumber(AiNumber)
+//	{}
+//
+//	bool operator&lt;(const AIKey&amp;that) const
+//	{
+//		if(dllName==that.dllName){
+//			return aiNumber&lt;that.aiNumber;
+//		} else {
+//			return dllName&lt;that.dllName;
+//		}
+//	};
+//
+//	bool operator!=(const AIKey&amp;that) const
+//	{
+//		return ! ((* this) == that);
+//	};
+//
+//	bool operator==(const AIKey&amp;that) const
+//	{
+//		return (aiNumber==that.aiNumber)
+//			&amp;&amp; (dllName==that.dllName);
+//	};
+//
+//};
+//
+//
+//#endif // AIKEY_H
+//

Modified: branches/caiinterface/rts/Game/Game.cpp
===================================================================
--- branches/caiinterface/rts/Game/Game.cpp	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/Game/Game.cpp	2008-11-11 16:09:44 UTC (rev 7021)
@@ -52,7 +52,8 @@
 #ifdef _WIN32
 #  include &quot;winerror.h&quot;
 #endif
-#include &quot;ExternalAI/GlobalAIHandler.h&quot;
+#include &quot;ExternalAI/EngineOutHandler.h&quot;
+//#include &quot;ExternalAI/GlobalAIHandler.h&quot;
 #include &quot;ExternalAI/Group.h&quot;
 #include &quot;ExternalAI/GroupHandler.h&quot;
 #include &quot;FileSystem/ArchiveScanner.h&quot;
@@ -439,10 +440,8 @@
 	keyBindings-&gt;Load(&quot;uikeys.txt&quot;);
 
 	water=CBaseWater::GetWater(NULL);
-	for(int a=0;a&lt;MAX_TEAMS;a++)
-		grouphandlers[a] = SAFE_NEW CGroupHandler(a);
 
-	globalAI = SAFE_NEW CGlobalAIHandler();
+	CEngineOutHandler::Initialize();
 
 	CPlayer* p = gs-&gt;players[gu-&gt;myPlayerNum];
 	GameSetupDrawer::Enable();
@@ -555,13 +554,9 @@
 
 	SafeDelete(gameServer);
 
-	globalAI-&gt;PreDestroy ();
-	SafeDelete(globalAI);
+	eoh-&gt;PreDestroy();
+	CEngineOutHandler::Destroy();
 
-	for(int a=0;a&lt;MAX_TEAMS;a++) {
-		SafeDelete(grouphandlers[a]);
-	}
-
 	SafeDelete(water);
 	SafeDelete(sky);
 	SafeDelete(resourceBar);
@@ -1118,6 +1113,7 @@
 			const int team = (t - '0');
 			do { c++; } while ((c[0] != 0) &amp;&amp; isspace(c[0]));
 			grouphandlers[gu-&gt;myTeam]-&gt;GroupCommand(team, c);
+			eoh-&gt;
 		}
 	}
 	else if (cmd == &quot;group0&quot;) {
@@ -3155,10 +3151,7 @@
 			sound-&gt;Update();
 		sound-&gt;NewFrame();
 		treeDrawer-&gt;Update();
-		globalAI-&gt;Update();
-		for (int a = 0; a &lt; MAX_TEAMS; a++) {
-			grouphandlers[a]-&gt;Update();
-		}
+		eoh-&gt;Update();
 		profiler.Update();
 		unitDrawer-&gt;Update();
 #ifdef DIRECT_CONTROL_ALLOWED
@@ -4579,7 +4572,7 @@
 		}
 	}
 
-	globalAI-&gt;GotChatMsg(msg.msg.c_str(), msg.fromPlayer);
+	eoh-&gt;GotChatMsg(msg.msg.c_str(), msg.fromPlayer);
 }
 
 

Modified: branches/caiinterface/rts/Game/GlobalConstants.h
===================================================================
--- branches/caiinterface/rts/Game/GlobalConstants.h	2008-11-11 13:49:31 UTC (rev 7020)
+++ branches/caiinterface/rts/Game/GlobalConstants.h	2008-11-11 16:09:44 UTC (rev 7021)
@@ -38,6 +38,14 @@
 const int MAX_TEAMS = 17;
 
 /**
+ * @brief max groups
+ *
+ * Defines the maximum number of groups per team.
+ * Normal groups go from 0 - 9, special groups are 10+.
+ */
+const int MAX_GROUPS = 16;
+
+/**
  * @brief max players
  *
  * Defines the maximum number of players as 32


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001789.html">[Taspring-linux-commit] r7020 - in Lobby/TASClient: . Interface
</A></li>
	<LI>Next message: <A HREF="001791.html">[Taspring-linux-commit] r7022 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1790">[ date ]</a>
              <a href="thread.html#1790">[ thread ]</a>
              <a href="subject.html#1790">[ subject ]</a>
              <a href="author.html#1790">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
