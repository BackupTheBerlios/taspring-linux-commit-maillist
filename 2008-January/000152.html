<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5345 - trunk/rts/Sim/MoveTypes
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-January/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5345%20-%20trunk/rts/Sim/MoveTypes&In-Reply-To=%3CE1JFxWZ-0003aH-4g%40proserver.fnord.lan%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000151.html">
   <LINK REL="Next"  HREF="000153.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5345 - trunk/rts/Sim/MoveTypes</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5345%20-%20trunk/rts/Sim/MoveTypes&In-Reply-To=%3CE1JFxWZ-0003aH-4g%40proserver.fnord.lan%3E"
       TITLE="[Taspring-linux-commit] r5345 - trunk/rts/Sim/MoveTypes">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Fri Jan 18 21:09:11 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000151.html">[Taspring-linux-commit] r5344 - in trunk/rts: Lua Sim/MoveTypes	Sim/Units Sim/Units/UnitTypes build/vstudio8
</A></li>
        <LI>Next message: <A HREF="000153.html">[Taspring-linux-commit] r5346 - trunk/tools/ArchiveMover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#152">[ date ]</a>
              <a href="thread.html#152">[ thread ]</a>
              <a href="subject.html#152">[ subject ]</a>
              <a href="author.html#152">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kloot
Date: 2008-01-18 21:09:10 +0100 (Fri, 18 Jan 2008)
New Revision: 5345

Removed:
   trunk/rts/Sim/MoveTypes/groundmovetype.cpp
   trunk/rts/Sim/MoveTypes/groundmovetype.h
Log:


Deleted: trunk/rts/Sim/MoveTypes/groundmovetype.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/groundmovetype.cpp	2008-01-18 20:08:47 UTC (rev 5344)
+++ trunk/rts/Sim/MoveTypes/groundmovetype.cpp	2008-01-18 20:09:10 UTC (rev 5345)
@@ -1,1842 +0,0 @@
-#include &quot;StdAfx.h&quot;
-#include &quot;groundmovetype.h&quot;
-#include &quot;Map/Ground.h&quot;
-#include &quot;Sim/Misc/QuadField.h&quot;
-#include &quot;Map/ReadMap.h&quot;
-#include &quot;Sim/Misc/LosHandler.h&quot;
-#include &quot;Game/GameHelper.h&quot;
-#include &quot;myMath.h&quot;
-#include &quot;LogOutput.h&quot;
-#include &quot;Sim/Units/UnitHandler.h&quot;
-#include &quot;Sync/SyncTracer.h&quot;
-#include &quot;Rendering/UnitModels/3DOParser.h&quot;
-#include &quot;Sim/Units/COB/CobInstance.h&quot;
-#include &quot;Sim/Units/COB/CobFile.h&quot;
-#include &quot;Sim/Misc/Feature.h&quot;
-#include &quot;Sim/Misc/FeatureHandler.h&quot;
-#include &quot;Sim/Units/UnitDef.h&quot;
-#include &quot;Sound.h&quot;
-#include &quot;Sim/Misc/RadarHandler.h&quot;
-#include &quot;Sim/Path/PathManager.h&quot;
-#include &quot;Game/Player.h&quot;
-#include &quot;Game/Camera.h&quot;
-#include &quot;Sim/Units/CommandAI/CommandAI.h&quot;
-#include &quot;Mobility.h&quot;
-#include &quot;MoveMath/MoveMath.h&quot;
-#include &quot;Sim/Misc/GeometricObjects.h&quot;
-#include &quot;Sim/Weapons/Weapon.h&quot;
-#include &quot;Sim/Weapons/WeaponDefHandler.h&quot;
-#include &quot;Game/SelectedUnits.h&quot;
-#include &quot;Rendering/GroundDecalHandler.h&quot;
-#include &quot;ExternalAI/GlobalAIHandler.h&quot;
-#include &quot;mmgr.h&quot;
-
-CR_BIND_DERIVED(CGroundMoveType, CMoveType, (NULL));
-
-CR_REG_METADATA(CGroundMoveType, (
-		CR_MEMBER(baseTurnRate),
-		CR_MEMBER(turnRate),
-		CR_MEMBER(accRate),
-
-		CR_MEMBER(wantedSpeed),
-		CR_MEMBER(currentSpeed),
-		CR_MEMBER(deltaSpeed),
-		CR_MEMBER(deltaHeading),
-
-		CR_MEMBER(oldPos),
-		CR_MEMBER(oldSlowUpdatePos),
-		CR_MEMBER(flatFrontDir),
-
-		CR_MEMBER(pathId),
-		CR_MEMBER(goal),
-		CR_MEMBER(goalRadius),
-
-		CR_MEMBER(waypoint),
-		CR_MEMBER(nextWaypoint),
-		CR_MEMBER(etaWaypoint),
-		CR_MEMBER(etaWaypoint2),
-		CR_MEMBER(atGoal),
-		CR_MEMBER(haveFinalWaypoint),
-		CR_MEMBER(terrainSpeed),
-
-		CR_MEMBER(requestedSpeed),
-		CR_MEMBER(requestedTurnRate),
-
-		CR_MEMBER(currentDistanceToWaypoint),
-
-		CR_MEMBER(avoidanceVec),
-
-		CR_MEMBER(restartDelay),
-		CR_MEMBER(lastGetPathPos),
-
-		CR_MEMBER(pathFailures),
-		CR_MEMBER(etaFailures),
-		CR_MEMBER(nonMovingFailures),
-
-		CR_MEMBER(moveType),
-
-		CR_MEMBER(floatOnWater),
-
-		CR_MEMBER(moveSquareX),
-		CR_MEMBER(moveSquareY),
-
-		CR_MEMBER(nextDeltaSpeedUpdate),
-		CR_MEMBER(nextObstacleAvoidanceUpdate),
-
-		CR_MEMBER(lastTrackUpdate),
-
-		CR_MEMBER(skidding),
-		CR_MEMBER(flying),
-		CR_MEMBER(skidRotSpeed),
-		CR_MEMBER(dropSpeed),
-		CR_MEMBER(dropHeight),
-
-		CR_MEMBER(skidRotVector),
-		CR_MEMBER(skidRotSpeed2),
-		CR_MEMBER(skidRotPos2),
-		CR_ENUM_MEMBER(oldPhysState),
-
-		CR_MEMBER(mainHeadingPos),
-		CR_MEMBER(useMainHeading),
-		CR_RESERVED(64),
-		CR_POSTLOAD(PostLoad)
-		));
-
-
-const unsigned int MAX_REPATH_FREQUENCY = 30;		//The minimum of frames between two full path-requests.
-
-const float ETA_ESTIMATION = 1.5f;					//How much time the unit are given to reach the waypoint.
-const float MAX_WAYPOINT_DISTANCE_FACTOR = 2.0f;		//Used to tune how often new waypoints are requested. Multiplied with MinDistanceToWaypoint().
-const float MAX_OFF_PATH_FACTOR = 20;				//How far away from a waypoint a unit could be before a new path is requested.
-
-const float MINIMUM_SPEED = 0.01f;					//Minimum speed a unit may move in.
-
-static const bool DEBUG_CONTROLLER=false;
-std::vector&lt;int2&gt; (*CGroundMoveType::lineTable)[11] = 0;
-
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
-
-CGroundMoveType::CGroundMoveType(CUnit* owner)
-:	CMoveType(owner),
-	accRate(0.01f),
-	turnRate(0.1f),
-	baseTurnRate(0.1f),
-//	maxSpeed(0.2f),
-	wantedSpeed(0),
-	moveType(0),
-	oldPos(owner?owner-&gt;pos:float3(0,0,0)),
-	oldSlowUpdatePos(oldPos),
-	flatFrontDir(1,0,0),
-	deltaSpeed(0),
-	deltaHeading(0),
-	skidding(false),
-	flying(false),
-	dropHeight(0),
-	skidRotSpeed(0),
-	floatOnWater(false),
-	skidRotVector(UpVector),
-	skidRotSpeed2(0),
-	skidRotPos2(0),
-
-	pathId(0),
-	goal(0,0,0),
-	goalRadius(0),
-	waypoint(0,0,0),
-	nextWaypoint(0,0,0),
-	etaWaypoint(0),
-	etaWaypoint2(0),
-	terrainSpeed(1),
-	atGoal(false),
-	haveFinalWaypoint(false),
-	requestedSpeed(0),
-	requestedTurnRate(0),
-	currentDistanceToWaypoint(0),
-	currentSpeed(0),
-	avoidanceVec(0,0,0),
-	restartDelay(0),
-	lastGetPathPos(0,0,0),
-
-	pathFailures(0),
-	etaFailures(0),
-	nonMovingFailures(0),
-
-	nextDeltaSpeedUpdate(0),
-	nextObstacleAvoidanceUpdate(0),
-	oldPhysState(CSolidObject::OnGround),
-	lastTrackUpdate(0),
-	mainHeadingPos(0,0,0),
-	useMainHeading(false)
-{
-	if (owner){
-		moveSquareX=(int)owner-&gt;pos.x/(SQUARE_SIZE*2);
-		moveSquareY=(int)owner-&gt;pos.z/(SQUARE_SIZE*2);
-	} else {
-		moveSquareX = 0;
-		moveSquareY = 0;
-	}
-}
-
-CGroundMoveType::~CGroundMoveType()
-{
-	if(pathId)
-		pathManager-&gt;DeletePath(pathId);
-
-	if(owner-&gt;myTrack)
-		groundDecals-&gt;RemoveUnit(owner);
-}
-
-void CGroundMoveType::PostLoad()
-{
-	//HACK:Initializing path after load
-	if (pathId) {
-		pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goal, goalRadius,owner);
-	}
-}
-
-void CGroundMoveType::Update()
-{
-	//Update mobility.
-	owner-&gt;mobility-&gt;maxSpeed = maxSpeed;
-
-	if(owner-&gt;transporter) {
-		return;
-	}
-	if(OnSlope()
-		&amp;&amp; (!floatOnWater || ground-&gt;GetHeight(owner-&gt;midPos.x, owner-&gt;midPos.z) &gt; 0))
-	{
-		skidding = true;
-	}
-
-	if(skidding){
-		UpdateSkid();
-		return;
-	}
-
-	//set drop height when we start to drop
-	if(owner-&gt;falling) {
-		UpdateControlledDrop();
-		return;
-	}
-
-	if (owner-&gt;stunned) {
-		owner-&gt;cob-&gt;Call(COBFN_StopMoving);
-		owner-&gt;speed = ZeroVector;
-	}
-
-
-	if (!owner-&gt;stunned) {
-#ifdef DIRECT_CONTROL_ALLOWED
-		if (owner-&gt;directControl) {
-			waypoint = owner-&gt;pos+owner-&gt;frontdir * 100;
-			waypoint.CheckInBounds();
-
-			if (owner-&gt;directControl-&gt;forward) {
-				wantedSpeed = maxSpeed * 2;
-				SetDeltaSpeed();
-				owner-&gt;isMoving = true;
-				owner-&gt;cob-&gt;Call(COBFN_StartMoving);
-			} else {
-				wantedSpeed = 0;
-				SetDeltaSpeed();
-				owner-&gt;isMoving = false;
-				owner-&gt;cob-&gt;Call(COBFN_StopMoving);
-			}
-			short deltaHeading = 0;
-			if (owner-&gt;directControl-&gt;left) {
-				deltaHeading += (short) turnRate;
-			}
-			if (owner-&gt;directControl-&gt;right) {
-				deltaHeading -= (short) turnRate;
-			}
-
-			ENTER_UNSYNCED;
-			if (gu-&gt;directControl == owner)
-				camera-&gt;rot.y += deltaHeading * PI / 32768;
-			ENTER_SYNCED;
-
-			ChangeHeading(owner-&gt;heading + deltaHeading);
-		} else
-#endif
-
-		if (pathId || currentSpeed &gt; 0.0f) {
-			// TODO: Stop the unit from moving as a reaction on collision/explosion physics.
-			// Initial calculations.
-			currentDistanceToWaypoint = owner-&gt;pos.distance2D(waypoint);
-
-			if (pathId &amp;&amp; !atGoal &amp;&amp; gs-&gt;frameNum &gt; etaWaypoint) {
-				etaFailures += 10;
-				etaWaypoint = INT_MAX;
-				if (DEBUG_CONTROLLER)
-					logOutput.Print(&quot;eta failure %i %i %i %i %i&quot;, owner-&gt;id, pathId, !atGoal, currentDistanceToWaypoint &lt; MinDistanceToWaypoint(), gs-&gt;frameNum &gt; etaWaypoint);
-			}
-			if (pathId &amp;&amp; !atGoal &amp;&amp; gs-&gt;frameNum &gt; etaWaypoint2) {
-				if (owner-&gt;pos.distance2D(goal) &gt; 200 || CheckGoalFeasability()) {
-					etaWaypoint2 += 100;
-				} else {
-					if (DEBUG_CONTROLLER)
-						logOutput.Print(&quot;Goal clogged up2 %i&quot;, owner-&gt;id);
-					Fail();
-				}
-			}
-
-			// Set direction to waypoint.
-			float3 waypointDir = waypoint - owner-&gt;pos;
-			waypointDir.y = 0;
-			waypointDir.Normalize();
-
-
-			// Has reached the waypoint? (=&gt; arrived at goal)
-			if (pathId &amp;&amp; !atGoal &amp;&amp; haveFinalWaypoint &amp;&amp; (owner-&gt;pos - waypoint).SqLength2D() &lt; SQUARE_SIZE * SQUARE_SIZE * 2) {
-				Arrived();
-			}
-
-			//-- Steering --//
-			// Apply obstacle avoidance.
-			float3 desiredVelocity = /* waypointDir / */ ObstacleAvoidance(waypointDir);
-
-			if(desiredVelocity != ZeroVector){
-				ChangeHeading(GetHeadingFromVector(desiredVelocity.x, desiredVelocity.z));
-			} else {
-				SetMainHeading();
-			}
-
-			if (nextDeltaSpeedUpdate &lt;= gs-&gt;frameNum) {
-				wantedSpeed = pathId? requestedSpeed: 0;
-				// If arriving at waypoint, then need to slow down, or may pass it.
-				if (!owner-&gt;commandAI-&gt;HasMoreMoveCommands()
-						&amp;&amp; currentDistanceToWaypoint &lt; BreakingDistance(currentSpeed) + SQUARE_SIZE) {
-					wantedSpeed = std::min((float) wantedSpeed, (float) (sqrt(currentDistanceToWaypoint * -owner-&gt;mobility-&gt;maxBreaking)));
-				}
-				wantedSpeed *= max(0.0f, std::min(1.0f, desiredVelocity.dot(owner-&gt;frontdir) + 0.1f));
-				SetDeltaSpeed();
-			}
-		} else {
-			SetMainHeading();
-		}
-
-		if (wantedSpeed &gt; 0 || currentSpeed &gt; 0) {
-			currentSpeed += deltaSpeed;
-			float3 tempSpeed = flatFrontDir * currentSpeed;
-			owner-&gt;pos += tempSpeed;
-
-			float wh;
-			if (floatOnWater) {
-				wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
-				if (wh == 0)
-					wh =- owner-&gt;unitDef-&gt;waterline;
-			} else {
-				wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
-			}
-
-			// need this to stop jitter when falling
-			if (!(owner-&gt;falling || flying)) {
-				owner-&gt;pos.y = wh;
-			}
-		}
-	}
-
-
-	if (owner-&gt;pos != oldPos) {
-		// these checks must be executed even when we are stunned
-		TestNewTerrainSquare();
-		CheckCollision();
-		float wh;
-
-		if (floatOnWater) {
-			wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
-			if (wh == 0)
-				wh=-owner-&gt;unitDef-&gt;waterline;
-		} else {
-			wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
-		}
-
-		if (!(owner-&gt;falling || flying))
-			owner-&gt;pos.y = wh;
-
-		owner-&gt;speed = owner-&gt;pos-oldPos;
-		owner-&gt;midPos = owner-&gt;pos + owner-&gt;frontdir * owner-&gt;relMidPos.z + owner-&gt;updir * owner-&gt;relMidPos.y + owner-&gt;rightdir * owner-&gt;relMidPos.x;
-		oldPos = owner-&gt;pos;
-
-		if (groundDecals &amp;&amp; owner-&gt;unitDef-&gt;leaveTracks &amp;&amp; (lastTrackUpdate &lt; gs-&gt;frameNum - 7) &amp;&amp;
-			((owner-&gt;losStatus[gu-&gt;myAllyTeam] &amp; LOS_INLOS) || gu-&gt;spectatingFullView)) {
-			lastTrackUpdate = gs-&gt;frameNum;
-			groundDecals-&gt;UnitMoved(owner);
-		}
-	} else {
-		owner-&gt;speed = ZeroVector;
-	}
-}
-
-void CGroundMoveType::SlowUpdate()
-{
-	if(owner-&gt;transporter){
-		if(progressState == Active)
-			StopEngine();
-		return;
-	}
-
-	//If got too far away from path, then need to reconsider.
-	if(progressState == Active &amp;&amp; etaFailures&gt;8) {
-		if(owner-&gt;pos.distance2D(goal)&gt;200 || CheckGoalFeasability()){
-			if(DEBUG_CONTROLLER)
-				logOutput.Print(&quot;Unit eta failure %i&quot;,owner-&gt;id);
-			StopEngine();
-			StartEngine();
-		} else {
-			if(DEBUG_CONTROLLER)
-				logOutput.Print(&quot;Goal clogged up %i&quot;,owner-&gt;id);
-			Fail();
-		}
-	}
-
-	//If the action is active, but not the engine and the
-	//re-try-delay has passed, then start the engine.
-	if(progressState == Active &amp;&amp; !pathId &amp;&amp; gs-&gt;frameNum &gt; restartDelay) {
-		if(DEBUG_CONTROLLER)
-			logOutput.Print(&quot;Unit restart %i&quot;,owner-&gt;id);
-		StartEngine();
-	}
-
-	owner-&gt;pos.CheckInBounds();		//just kindly move it into the map again instead of deleteing
-
-	float wh;		//need the following if the ground change height when unit stand still
-	if(floatOnWater){
-		wh = ground-&gt;GetHeight(owner-&gt;pos.x, owner-&gt;pos.z);
-		if(wh==0)
-			wh=-owner-&gt;unitDef-&gt;waterline;
-	} else {
-		wh = ground-&gt;GetHeight2(owner-&gt;pos.x, owner-&gt;pos.z);
-	}
-
-	if (!(owner-&gt;falling || flying))
-		owner-&gt;pos.y=wh;
-
-	if(!(owner-&gt;pos==oldSlowUpdatePos)){
-		oldSlowUpdatePos=owner-&gt;pos;
-
-		int newmapSquare=ground-&gt;GetSquare(owner-&gt;pos);
-		if(newmapSquare!=owner-&gt;mapSquare){
-			owner-&gt;mapSquare=newmapSquare;
-
-			loshandler-&gt;MoveUnit(owner,false);
-			if(owner-&gt;hasRadarCapacity)
-				radarhandler-&gt;MoveUnit(owner);
-
-//			owner-&gt;UnBlock();
-//			owner-&gt;Block();
-		}
-		qf-&gt;MovedUnit(owner);
-		owner-&gt;isUnderWater=owner-&gt;pos.y+owner-&gt;height&lt;1;
-	}
-}
-
-
-/*
-Sets unit to start moving against given position with max speed.
-*/
-void CGroundMoveType::StartMoving(float3 pos, float goalRadius) {
-	StartMoving(pos, goalRadius, maxSpeed*2);
-}
-
-
-/*
-Sets owner unit to start moving against given position with requested speed.
-*/
-void CGroundMoveType::StartMoving(float3 moveGoalPos, float goalRadius,  float speed)
-{
-#ifdef TRACE_SYNC
-	tracefile &lt;&lt; &quot;Start moving called: &quot;;
-	tracefile &lt;&lt; owner-&gt;pos.x &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.y &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.z &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-#endif
-
-	if(progressState == Active) {
-		StopEngine();
-	}
-
-	//Sets the new goal.
-	goal = moveGoalPos;
-	goalRadius = goalRadius;
-	requestedSpeed = min(speed, maxSpeed*2);
-	requestedTurnRate = owner-&gt;mobility-&gt;maxTurnRate;
-	atGoal = false;
-	useMainHeading = false;
-
-	progressState = Active;
-
-	//Starts the engine.
-	if (DEBUG_CONTROLLER)
-		logOutput &lt;&lt; owner-&gt;id &lt;&lt; &quot;: StartMoving() starting engine.\n&quot;;
-	StartEngine();
-
-	ENTER_UNSYNCED;
-	if (owner-&gt;team == gu-&gt;myTeam) {
-		// Play &quot;activate&quot; sound.
-		int soundIdx = owner-&gt;unitDef-&gt;sounds.activate.getRandomIdx();
-		if (soundIdx &gt;= 0) {
-			sound-&gt;PlayUnitActivate(
-				owner-&gt;unitDef-&gt;sounds.activate.getID(soundIdx), owner,
-				owner-&gt;unitDef-&gt;sounds.activate.getVolume(soundIdx));
-		}
-	}
-	ENTER_SYNCED;
-}
-
-void CGroundMoveType::StopMoving() {
-#ifdef TRACE_SYNC
-	tracefile &lt;&lt; &quot;Stop moving called: &quot;;
-	tracefile &lt;&lt; owner-&gt;pos.x &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.y &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.z &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-#endif
-	if(DEBUG_CONTROLLER)
-		logOutput &lt;&lt; &quot;SMove: Action stopped.&quot; &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-
-	StopEngine();
-
-	useMainHeading = false;
-	if(progressState != Done)
-		progressState = Done;
-}
-
-void CGroundMoveType::SetDeltaSpeed(void)
-{
-	//Rounding of low speed.
-	if(wantedSpeed == 0 &amp;&amp; currentSpeed &lt; 0.01f){
-		currentSpeed=0;
-		deltaSpeed=0;
-//		nextDeltaSpeedUpdate=gs-&gt;frameNum+8;
-		return;
-	}
-
-	//Wanted speed and acceleration.
-	float wSpeed = maxSpeed;
-
-	//Limiting speed and acceleration.
-	if(wantedSpeed &gt; 0) {
-		float groundMod = owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, owner-&gt;pos,flatFrontDir);
-		wSpeed *= groundMod;
-
-		float3 goalDif=waypoint-owner-&gt;pos;
-		short turn=owner-&gt;heading-GetHeadingFromVector(goalDif.x,goalDif.z);
-		if(turn!=0){
-			float goalLength=goalDif.Length();
-
-			float turnSpeed=(goalLength+8)/(abs(turn)/turnRate)*0.5f;
-			if(turnSpeed&lt;wSpeed)		//make sure we can turn fast enought to get hit the goal
-				wSpeed=turnSpeed;
-	}
-	if(wSpeed&gt;wantedSpeed)
-		wSpeed=wantedSpeed;
-	} else {
-		wSpeed=0;
-	}
-	//Limit change according to acceleration.
-	float dif = wSpeed - currentSpeed;
-
-	if (!accRate) {
-		logOutput.Print(&quot;Acceleration is zero on unit %s\n&quot;,owner-&gt;unitDef-&gt;name.c_str());
-		accRate=0.01f;
-	}
-
-	if(fabs(dif)&lt;0.05f){		//good speed
-		deltaSpeed=dif/8;
-		nextDeltaSpeedUpdate=gs-&gt;frameNum+8;
-
-	} else if(dif&gt;0){				//accelerate
-		if(dif&lt;accRate){
-			deltaSpeed = dif;
-			nextDeltaSpeedUpdate=gs-&gt;frameNum;
-		} else {
-			deltaSpeed=accRate;
-			nextDeltaSpeedUpdate=(int)(gs-&gt;frameNum+min((float)8,dif/accRate));
-		}
-	}else {		//break, Breakrate = -3*accRate
-		if(dif &gt; -3*accRate){
-			deltaSpeed = dif;
-			nextDeltaSpeedUpdate=gs-&gt;frameNum+1;
-		} else {
-			deltaSpeed = -3*accRate;
-			nextDeltaSpeedUpdate=(int)(gs-&gt;frameNum+min((float)8,dif/(-3*accRate)));
-		}
-	}
-	//float3 temp=UpVector*wSpeed;
-	//temp.CheckInBounds();
-
-#ifdef TRACE_SYNC
-	tracefile &lt;&lt; &quot;Unit delta speed: &quot;;
-	tracefile &lt;&lt; owner-&gt;pos.x &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.y &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;pos.z &lt;&lt; &quot; &quot; &lt;&lt; deltaSpeed &lt;&lt; &quot; &quot; /*&lt;&lt; wSpeed*/ &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-#endif
-
-}
-
-/*
-Changes the heading of the owner.
-*/
-void CGroundMoveType::ChangeHeading(short wantedHeading) {
-	short heading = owner-&gt;heading;
-
-	deltaHeading = wantedHeading - heading;
-
-	if(deltaHeading&gt;0){
-		heading += min(deltaHeading,(short)turnRate);
-	} else {
-		heading += max((short)-turnRate,deltaHeading);
-	}
-
-	owner-&gt;frontdir = GetVectorFromHeading(heading);
-	if (owner-&gt;upright) {
-		owner-&gt;updir=UpVector;
-		owner-&gt;rightdir=owner-&gt;frontdir.cross(owner-&gt;updir);
-	} else {
-		owner-&gt;updir=ground-&gt;GetNormal(owner-&gt;pos.x, owner-&gt;pos.z);
-		owner-&gt;rightdir=owner-&gt;frontdir.cross(owner-&gt;updir);
-		owner-&gt;rightdir.Normalize();
-		owner-&gt;frontdir=owner-&gt;updir.cross(owner-&gt;rightdir);
-	}
-	owner-&gt;heading=heading;
-	flatFrontDir=owner-&gt;frontdir;
-	flatFrontDir.y=0;
-	flatFrontDir.Normalize();
-}
-
-void CGroundMoveType::ImpulseAdded(void)
-{
-	if(owner-&gt;beingBuilt || owner-&gt;unitDef-&gt;movedata-&gt;moveType==MoveData::Ship_Move)
-		return;
-
-	float3&amp; impulse=owner-&gt;residualImpulse;
-	float3&amp; speed=owner-&gt;speed;
-
-	if(skidding){
-		speed+=impulse;
-		impulse=ZeroVector;
-	}
-	float3 groundNormal=ground-&gt;GetNormal(owner-&gt;pos.x,owner-&gt;pos.z);
-
-	if(impulse.dot(groundNormal)&lt;0)
-		impulse-=groundNormal*impulse.dot(groundNormal);
-
-	float strength=impulse.Length();
-//	logOutput.Print(&quot;strength %f&quot;,strength);
-
-	if(strength&gt;3 || impulse.dot(groundNormal)&gt;0.3f){
-		skidding=true;
-		speed+=impulse;
-		impulse=ZeroVector;
-
-		skidRotSpeed+=(gs-&gt;randFloat()-0.5f)*1500;
-		skidRotPos2=0;
-		skidRotSpeed2=0;
-		float3 skidDir(speed);
-		skidDir.y=0;
-		skidDir.Normalize();
-		skidRotVector=skidDir.cross(UpVector);
-		oldPhysState=owner-&gt;physicalState;
-		owner-&gt;physicalState= CSolidObject::Flying;
-		owner-&gt;moveType-&gt;useHeading=false;
-
-		if(speed.dot(groundNormal)&gt;0.2f){
-			flying=true;
-			skidRotSpeed2=(gs-&gt;randFloat()-0.5f)*0.04f;
-		}
-	}
-}
-
-void CGroundMoveType::UpdateSkid(void)
-{
-	float3&amp; speed=owner-&gt;speed;
-	float3&amp; pos=owner-&gt;pos;
-	SyncedFloat3&amp; midPos=owner-&gt;midPos;
-
-	if(flying){
-		speed.y+=gs-&gt;gravity;
-		if(midPos.y &lt; 0)
-			speed*=0.95f;
-
-		float wh;
-		if(floatOnWater)
-			wh = ground-&gt;GetHeight(midPos.x, midPos.z);
-		else
-			wh = ground-&gt;GetHeight2(midPos.x, midPos.z);
-
-		if(wh&gt;midPos.y-owner-&gt;relMidPos.y){
-			flying=false;
-			skidRotSpeed+=(gs-&gt;randFloat()-0.5f)*1500;//*=0.5f+gs-&gt;randFloat();
-			midPos.y=wh+owner-&gt;relMidPos.y-speed.y*0.5f;
-			float impactSpeed=-speed.dot(ground-&gt;GetNormal(midPos.x,midPos.z));
-			if(impactSpeed &gt; owner-&gt;unitDef-&gt;minCollisionSpeed
-				&amp;&amp; owner-&gt;unitDef-&gt;minCollisionSpeed &gt;= 0)
-			{
-				owner-&gt;DoDamage(DamageArray()*impactSpeed*owner-&gt;mass*0.2f,
-					0, ZeroVector);
-			}
-		}
-	} else {
-		float speedf=speed.Length();
-		float speedReduction=0.35f;
-//		if(owner-&gt;unitDef-&gt;movedata-&gt;moveType==MoveData::Hover_Move)
-//			speedReduction=0.1f;
-		// does not use OnSlope() because then it could stop on an invalid path
-		// location, and be teleported back.
-		bool onSlope = (ground-&gt;GetSlope(owner-&gt;midPos.x, owner-&gt;midPos.z) &gt;
-			owner-&gt;unitDef-&gt;movedata-&gt;maxSlope)
-			&amp;&amp; (!floatOnWater || ground-&gt;GetHeight(midPos.x, midPos.z) &gt; 0);
-		if (speedf &lt; speedReduction &amp;&amp; !onSlope) {
-			//stop skidding
-			currentSpeed=0;
-			speed=ZeroVector;
-			skidding=false;
-			skidRotSpeed=0;
-			owner-&gt;physicalState=oldPhysState;
-			owner-&gt;moveType-&gt;useHeading=true;
-			float rp=floor(skidRotPos2+skidRotSpeed2+0.5f);
-			skidRotSpeed2=(rp-skidRotPos2)*0.5f;
-			ChangeHeading(owner-&gt;heading);
-		} else {
-			if (onSlope) {
-				float3 dir = ground-&gt;GetNormal(midPos.x, midPos.z);
-				float3 normalForce = dir*dir.dot(UpVector*gs-&gt;gravity);
-				float3 newForce = UpVector*gs-&gt;gravity - normalForce;
-				speed+=newForce;
-				speedf = speed.Length();
-				speed *= 1 - (.1*dir.y);
-			} else {
-				speed*=(speedf-speedReduction)/speedf;
-			}
-
-			float remTime=speedf/speedReduction-1;
-			float rp=floor(skidRotPos2+skidRotSpeed2*remTime+0.5f);
-			skidRotSpeed2=(remTime+1 == 0 ) ? 0 : (rp-skidRotPos2)/(remTime+1);
-
-			if(floor(skidRotPos2)!=floor(skidRotPos2+skidRotSpeed2)){
-				skidRotPos2=0;
-				skidRotSpeed2=0;
-			}
-		}
-
-		float wh;
-		if(floatOnWater)
-			wh = ground-&gt;GetHeight(pos.x, pos.z);
-		else
-			wh = ground-&gt;GetHeight2(pos.x, pos.z);
-
-		if(wh-pos.y &lt; speed.y + gs-&gt;gravity){
-			speed.y += gs-&gt;gravity;
-			skidding = true; // flying requires skidding
-			flying = true;
-		} else if(wh-pos.y &gt; speed.y){
-			const float3&amp; normal = ground-&gt;GetNormal(pos.x, pos.z);
-			float dot = speed.dot(normal);
-			if(dot &gt; 0){
-				speed*=0.95f;
-			}
-			else {
-				speed += (normal*(fabs(speed.dot(normal)) + .1))*1.9f;
-				speed*=.8;
-			}
-		}
-	}
-	CalcSkidRot();
-
-	midPos += speed;
-	pos = midPos - owner-&gt;frontdir * owner-&gt;relMidPos.z
-			- owner-&gt;updir * owner-&gt;relMidPos.y
-			- owner-&gt;rightdir * owner-&gt;relMidPos.x;
-	CheckCollisionSkid();
-}
-
-void CGroundMoveType::UpdateControlledDrop(void)
-{
-	float3&amp; speed=owner-&gt;speed;
-	float3&amp; pos=owner-&gt;pos;
-	SyncedFloat3&amp; midPos=owner-&gt;midPos;
-
-	if(owner-&gt;falling){
-		//set us upright
-		owner-&gt;cob-&gt;Call(&quot;Falling&quot;); //start/continue parachute animation
-
-		speed.y += gs-&gt;gravity*owner-&gt;fallSpeed;
-
-		if(owner-&gt;speed.y &gt; 0) //sometimes the dropped unit gets an upward force, still unsure where its coming from
-			owner-&gt;speed.y = 0;
-
-		midPos += speed;
-		pos = midPos - owner-&gt;frontdir * owner-&gt;relMidPos.z
-			- owner-&gt;updir * owner-&gt;relMidPos.y
-			- owner-&gt;rightdir * owner-&gt;relMidPos.x;
-
-		owner-&gt;midPos.y = owner-&gt;pos.y + owner-&gt;relMidPos.y;
-
-		if(midPos.y &lt; 0)
-			speed*=0.90;
-
-		float wh;
-
-		if(floatOnWater)
-			wh = ground-&gt;GetHeight(midPos.x, midPos.z);
-		else
-			wh = ground-&gt;GetHeight2(midPos.x, midPos.z);
-
-		if(wh &gt; midPos.y-owner-&gt;relMidPos.y){
-			owner-&gt;falling = false;
-			midPos.y = wh + owner-&gt;relMidPos.y - speed.y*0.8;
-			owner-&gt;cob-&gt;Call(&quot;Landed&quot;); //stop parachute animation
-		}
-
-
-
-	}
-}
-
-void CGroundMoveType::CheckCollisionSkid(void)
-{
-	float3&amp; pos=owner-&gt;pos;
-	SyncedFloat3&amp; midPos=owner-&gt;midPos;
-
-	vector&lt;CUnit*&gt; nearUnits=qf-&gt;GetUnitsExact(midPos,owner-&gt;radius);
-	for(vector&lt;CUnit*&gt;::iterator ui=nearUnits.begin();ui!=nearUnits.end();++ui){
-		CUnit* u=(*ui);
-		float sqDist=(midPos-u-&gt;midPos).SqLength();
-		float totRad=owner-&gt;radius+u-&gt;radius;
-		if(sqDist&lt;totRad*totRad &amp;&amp; sqDist!=0){
-			float dist=sqrt(sqDist);
-			float3 dif=midPos-u-&gt;midPos;
-			dif/=dist;
-			if(u-&gt;mass==100000 || !u-&gt;mobility){
-				float impactSpeed=-owner-&gt;speed.dot(dif);
-				if(impactSpeed &gt; 0) {
-					midPos += dif*impactSpeed;
-					pos=midPos-owner-&gt;frontdir*owner-&gt;relMidPos.z
-						- owner-&gt;updir*owner-&gt;relMidPos.y
-						- owner-&gt;rightdir*owner-&gt;relMidPos.x;
-					owner-&gt;speed += dif*(impactSpeed*1.8f);
-					if(impactSpeed &gt; owner-&gt;unitDef-&gt;minCollisionSpeed
-						&amp;&amp; owner-&gt;unitDef-&gt;minCollisionSpeed &gt;= 0)
-					{
-						owner-&gt;DoDamage(DamageArray()*impactSpeed*owner-&gt;mass*0.2f,
-								0,ZeroVector);
-					}
-					if(impactSpeed &gt; u-&gt;unitDef-&gt;minCollisionSpeed
-						&amp;&amp; u-&gt;unitDef-&gt;minCollisionSpeed &gt;= 0)
-					{
-						u-&gt;DoDamage(DamageArray()*impactSpeed*owner-&gt;mass*0.2f,0,ZeroVector);
-					}
-				}
-			} else {
-				float part=owner-&gt;mass/(owner-&gt;mass+u-&gt;mass);
-				float impactSpeed=(u-&gt;speed - owner-&gt;speed).dot(dif);
-				if(impactSpeed &gt; 0) {
-					midPos += dif * (impactSpeed * (1 - part) * 2);
-					pos = midPos - owner-&gt;frontdir*owner-&gt;relMidPos.z
-						- owner-&gt;updir*owner-&gt;relMidPos.y
-						- owner-&gt;rightdir*owner-&gt;relMidPos.x;
-					owner-&gt;speed += dif*(impactSpeed*(1-part)*2);
-					u-&gt;midPos-=dif*(impactSpeed*part * 2);
-					u-&gt;pos = u-&gt;midPos - u-&gt;frontdir * u-&gt;relMidPos.z
-						- u-&gt;updir*u-&gt;relMidPos.y - u-&gt;rightdir*u-&gt;relMidPos.x;
-					u-&gt;speed -= dif*(impactSpeed*part*2);
-					if(CGroundMoveType* mt
-						= dynamic_cast&lt;CGroundMoveType*&gt;(u-&gt;moveType))
-					{
-						mt-&gt;skidding = true;
-					}
-					if(impactSpeed &gt; owner-&gt;unitDef-&gt;minCollisionSpeed
-						&amp;&amp; owner-&gt;unitDef-&gt;minCollisionSpeed &gt;= 0)
-					{
-						owner-&gt;DoDamage(
-							DamageArray()*impactSpeed*owner-&gt;mass*0.2f*(1-part),
-							0,dif*impactSpeed*(owner-&gt;mass*(1-part)));
-					}
-					if(impactSpeed &gt; u-&gt;unitDef-&gt;minCollisionSpeed
-						&amp;&amp; u-&gt;unitDef-&gt;minCollisionSpeed &gt;= 0)
-					{
-						u-&gt;DoDamage(
-							DamageArray()*impactSpeed*owner-&gt;mass*0.2f*part,
-							0, dif*-impactSpeed*(u-&gt;mass*part));
-					}
-					owner-&gt;speed*=0.9f;
-				}
-			}
-		}
-	}
-	vector&lt;CFeature*&gt; nearFeatures=qf-&gt;GetFeaturesExact(midPos,owner-&gt;radius);
-	for(vector&lt;CFeature*&gt;::iterator fi=nearFeatures.begin();
-		fi!=nearFeatures.end();++fi)
-	{
-		CFeature* u=(*fi);
-		if(!u-&gt;blocking)
-			continue;
-		float sqDist=(midPos-u-&gt;midPos).SqLength();
-		float totRad=owner-&gt;radius+u-&gt;radius;
-		if(sqDist&lt;totRad*totRad &amp;&amp; sqDist!=0){
-			float dist=sqrt(sqDist);
-			float3 dif=midPos-u-&gt;midPos;
-			dif/=dist;
-			float impactSpeed=-owner-&gt;speed.dot(dif);
-			if(impactSpeed &gt; 0){
-				midPos+=dif*(impactSpeed);
-				pos = midPos - owner-&gt;frontdir*owner-&gt;relMidPos.z
-					- owner-&gt;updir*owner-&gt;relMidPos.y
-					- owner-&gt;rightdir*owner-&gt;relMidPos.x;
-				owner-&gt;speed+=dif*(impactSpeed*1.8f);
-				if(impactSpeed &gt; owner-&gt;unitDef-&gt;minCollisionSpeed
-					&amp;&amp; owner-&gt;unitDef-&gt;minCollisionSpeed &gt;= 0)
-				{
-					owner-&gt;DoDamage(DamageArray()*impactSpeed*owner-&gt;mass*0.2f,
-						0, ZeroVector);
-				}
-				u-&gt;DoDamage(DamageArray()*impactSpeed*owner-&gt;mass*0.2f,
-					0, -dif*impactSpeed);
-			}
-		}
-	}
-}
-
-float CGroundMoveType::GetFlyTime(float3 pos, float3 speed)
-{
-	return 0;
-}
-
-void CGroundMoveType::CalcSkidRot(void)
-{
-	owner-&gt;heading+=(short int)skidRotSpeed;
-
-	owner-&gt;frontdir = GetVectorFromHeading(owner-&gt;heading);
-	if(owner-&gt;upright){
-		owner-&gt;updir=UpVector;
-		owner-&gt;rightdir=owner-&gt;frontdir.cross(owner-&gt;updir);
-	} else {
-		owner-&gt;updir=ground-&gt;GetSmoothNormal(owner-&gt;pos.x, owner-&gt;pos.z);
-		owner-&gt;rightdir=owner-&gt;frontdir.cross(owner-&gt;updir);
-		owner-&gt;rightdir.Normalize();
-		owner-&gt;frontdir=owner-&gt;updir.cross(owner-&gt;rightdir);
-	}
-
-	skidRotPos2+=skidRotSpeed2;
-
-	float cosp=cos(skidRotPos2*PI*2);
-	float sinp=sin(skidRotPos2*PI*2);
-
-	float3 f1=skidRotVector*skidRotVector.dot(owner-&gt;frontdir);
-	float3 f2=owner-&gt;frontdir-f1;
-	f2=f2*cosp+f2.cross(skidRotVector)*sinp;
-	owner-&gt;frontdir=f1+f2;
-
-	float3 r1=skidRotVector*skidRotVector.dot(owner-&gt;rightdir);
-	float3 r2=owner-&gt;rightdir-r1;
-	r2=r2*cosp+r2.cross(skidRotVector)*sinp;
-	owner-&gt;rightdir=r1+r2;
-
-	float3 u1=skidRotVector*skidRotVector.dot(owner-&gt;updir);
-	float3 u2=owner-&gt;updir-u1;
-	u2=u2*cosp+u2.cross(skidRotVector)*sinp;
-	owner-&gt;updir=u1+u2;
-}
-
-const float AVOIDANCE_DISTANCE = 1.0f;				//How far away a unit should start avoiding an obstacle. Multiplied with distance to waypoint.
-const float AVOIDANCE_STRENGTH = 2.0f;				//How strongly an object should be avoided. Raise this value to give some more marginal.
-const float FORCE_FIELD_DISTANCE = 50;				//How faar away a unit may be affected by the force-field. Multiplied with speed of the unit.
-const float FORCE_FIELD_STRENGTH = 0.4f;				//Maximum strenght of the force-field.
-
-
-
-/*
-Dynamic obstacle avoidance.
-Helps the unit to follow the path even when it's not perfect.
-*/
-float3 CGroundMoveType::ObstacleAvoidance(float3 desiredDir) {
-	//NOTE: Based on the requirement that all objects has symetrical footprints.
-	//		If this is false, then radius has to be calculated in a different way!
-
-	// Obstacle-avoidance-system only needs to be run if the unit wants to move
-	if (pathId) {
-		float3 avoidanceDir = desiredDir;
-		//Speed-optimizer. Reduces the times this system is runned.
-		if(gs-&gt;frameNum&gt;=nextObstacleAvoidanceUpdate) {
-			nextObstacleAvoidanceUpdate = gs-&gt;frameNum + 4;
-
-			// first check if the current waypoint is reachable
-			int wsx = (int) waypoint.x / (SQUARE_SIZE * 2);
-			int wsy = (int) waypoint.z / (SQUARE_SIZE * 2);
-			int ltx = wsx-moveSquareX + 5;
-			int lty = wsy-moveSquareY + 5;
-
-			if (ltx &gt;= 0 &amp;&amp; ltx &lt; 11 &amp;&amp; lty &gt;= 0 &amp;&amp; lty &lt; 11) {
-				for (std::vector&lt;int2&gt;::iterator li = lineTable[lty][ltx].begin(); li != lineTable[lty][ltx].end(); ++li) {
-					int x = (moveSquareX + li-&gt;x) * 2;
-					int y = (moveSquareY + li-&gt;y) * 2;
-					if ((owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN | CMoveMath::BLOCK_MOBILE_BUSY)) || owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x,y)&lt;=0.01f){
-						++etaFailures;		// not reachable, force a new path to be calculated next slowupdate
-
-						if (DEBUG_CONTROLLER)
-							logOutput.Print(&quot;Waypoint path blocked %i&quot;, owner-&gt;id);
-						break;
-					}
-				}
-			}
-
-			// now we do the obstacle avoidance proper
-			float currentDistanceToGoal = owner-&gt;pos.distance2D(goal);
-			float3 rightOfPath = desiredDir.cross(float3(0,1,0));
-			float3 rightOfAvoid = rightOfPath;
-			float speedf=owner-&gt;speed.Length2D();
-
-			float avoidLeft = 0;
-			float avoidRight = 0;
-
-
-
-			vector&lt;CSolidObject*&gt; nearbyObjects = qf-&gt;GetSolidsExact(owner-&gt;pos, speedf*35 + 30 + owner-&gt;xsize/2);
-			vector&lt;CSolidObject*&gt; objectsOnPath;
-			vector&lt;CSolidObject*&gt;::iterator oi;
-
-			for (oi = nearbyObjects.begin(); oi != nearbyObjects.end(); oi++) {
-				CSolidObject* object = *oi;
-				// Basic blocking-check.
-				MoveData* moveData = owner-&gt;mobility-&gt;moveData;
-
-				if (object != owner &amp;&amp; moveData-&gt;moveMath-&gt;IsBlocking(*moveData, object) &amp;&amp; desiredDir.dot(object-&gt;pos - owner-&gt;pos) &gt; 0) {
-					float3 objectToUnit = (owner-&gt;pos - object-&gt;pos - object-&gt;speed * 30);
-					float distanceToObject = objectToUnit.Length();
-					float radiusSum = (owner-&gt;xsize + object-&gt;xsize) * SQUARE_SIZE / 2;
-
-					// if object is close enough
-					if (distanceToObject &lt; speedf * 35 + 10 + radiusSum &amp;&amp; distanceToObject &lt; currentDistanceToGoal &amp;&amp; distanceToObject &gt; 0.001f) {
-						// Don't divide by zero. TODO figure out why this can actually happen.
-						float objectDistToAvoidDirCenter = objectToUnit.dot(rightOfAvoid);	//Positive value means &quot;to right&quot;.
-						// If object and unit in relative motion are closing in to each other (or not yet fully apart),
-						// the object are in path of the unit and they are not collided.
-
-						if (objectToUnit.dot(avoidanceDir) &lt; radiusSum &amp;&amp; fabs(objectDistToAvoidDirCenter) &lt; radiusSum &amp;&amp; (object-&gt;mobility || Distance2D(owner, object) &gt;= 0)) {
-							// Avoid collision by turning the heading to left or right.
-							// Using the one who need most adjustment.
-							if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end())
-								geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, object-&gt;pos + UpVector * 20, 3, 1, 4);
-
-							if (objectDistToAvoidDirCenter &gt; 0) {
-								avoidRight += (radiusSum - objectDistToAvoidDirCenter) * AVOIDANCE_STRENGTH / distanceToObject;
-								avoidanceDir += (rightOfAvoid * avoidRight);
-								avoidanceDir.Normalize();
-								rightOfAvoid = avoidanceDir.cross(float3(0, 1, 0));
-							} else {
-								avoidLeft += (radiusSum - fabs(objectDistToAvoidDirCenter)) * AVOIDANCE_STRENGTH / distanceToObject;
-								avoidanceDir -= (rightOfAvoid * avoidLeft);
-								avoidanceDir.Normalize();
-								rightOfAvoid = avoidanceDir.cross(float3(0, 1, 0));
-							}
-							objectsOnPath.push_back(object);
-						}
-					}
-
-				}
-			}
-
-
-
-			// Sum up avoidance.
-			avoidanceVec = (desiredDir.cross(float3(0, 1, 0)) * (avoidRight - avoidLeft));
-			if (DEBUG_CONTROLLER &amp;&amp; selectedUnits.selectedUnits.find(owner) != selectedUnits.selectedUnits.end()) {
-				int a = geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + avoidanceVec * 40, 7, 1, 4);
-				geometricObjects-&gt;SetColor(a, 1, 0.3f, 0.3f, 0.6f);
-
-				a=geometricObjects-&gt;AddLine(owner-&gt;pos + UpVector * 20, owner-&gt;pos + UpVector * 20 + desiredDir * 40, 7, 1, 4);
-				geometricObjects-&gt;SetColor(a, 0.3f, 0.3f, 1, 0.6f);
-			}
-		}
-
-		// Return the resulting recommended velocity.
-		avoidanceDir = desiredDir + avoidanceVec;
-		if (avoidanceDir.Length2D() &gt; 1.0f)
-			avoidanceDir.Normalize();
-
-		return avoidanceDir;
-	} else {
-		return ZeroVector;
-	}
-}
-
-
-
-/*
-Calculates an aproximation of the physical 2D-distance
-between given two objects.
-*/
-float CGroundMoveType::Distance2D(CSolidObject *object1, CSolidObject *object2, float marginal)
-{
-	//Calculating the distance in (x,z) depening in the look of the footprint.
-	float dist2D;
-	if(object1-&gt;xsize == object1-&gt;ysize || object2-&gt;xsize == object2-&gt;ysize) {
-		//Using xsize as a cynlindrical radius.
-		float3 distVec = (object1-&gt;midPos - object2-&gt;midPos);
-		dist2D = distVec.Length2D() - (object1-&gt;xsize + object2-&gt;xsize)*SQUARE_SIZE/2 + 2*marginal;
-	} else {
-		//Pytagorean sum of the x and z distance.
-		float3 distVec;
-		distVec.x = fabs(object1-&gt;midPos.x - object2-&gt;midPos.x) - (object1-&gt;xsize + object2-&gt;xsize)*SQUARE_SIZE/2 + 2*marginal;
-		distVec.z = fabs(object1-&gt;midPos.z - object2-&gt;midPos.z) - (object1-&gt;ysize + object2-&gt;ysize)*SQUARE_SIZE/2 + 2*marginal;
-		if(distVec.x &gt; 0.0f &amp;&amp; distVec.z &gt; 0.0f)
-			dist2D = distVec.Length2D();
-		else if(distVec.x &lt; 0.0f &amp;&amp; distVec.z &lt; 0.0f)
-			dist2D = -distVec.Length2D();
-		else if(distVec.x &gt; 0.0f)
-			dist2D = distVec.x;
-		else
-			dist2D = distVec.z;
-	}
-	return dist2D;
-}
-
-/*
-Creates a path to the goal.
-*/
-void CGroundMoveType::GetNewPath()
-{
-	if(owner-&gt;pos.distance2D(lastGetPathPos)&lt;20){
-		if(DEBUG_CONTROLLER)
-			logOutput.Print(&quot;Non moving failure %i %i&quot;,owner-&gt;id,nonMovingFailures);
-		nonMovingFailures++;
-		if(nonMovingFailures&gt;10){
-			nonMovingFailures=0;
-			Fail();
-			pathId=0;
-			return;
-		}
-	}else{
-		lastGetPathPos=owner-&gt;pos;
-		nonMovingFailures=0;
-	}
-
-	pathManager-&gt;DeletePath(pathId);
-
-	pathId = pathManager-&gt;RequestPath(owner-&gt;mobility-&gt;moveData, owner-&gt;pos, goal, goalRadius,owner);
-
-	nextWaypoint=owner-&gt;pos;
-	//With new path recived, can't be at waypoint.
-	if(pathId){
-		atGoal = false;
-		haveFinalWaypoint=false;
-		GetNextWaypoint();
-		GetNextWaypoint();
-	} else {
-
-	}
-
-	//Sets the limit for when next path-request could be done.
-	restartDelay = gs-&gt;frameNum + MAX_REPATH_FREQUENCY;
-}
-
-
-/*
-Sets waypoint to next in path.
-*/
-void CGroundMoveType::GetNextWaypoint()
-{
-	if(pathId) {
-		waypoint=nextWaypoint;
-		nextWaypoint = pathManager-&gt;NextWaypoint(pathId, waypoint, 2);
-
-		if(nextWaypoint.x != -1) {
-//			logOutput.Print(&quot;New waypoint %i %f %f&quot;,owner-&gt;id,owner-&gt;pos.distance2D(newWaypoint),wantedDistanceToWaypoint);
-			etaWaypoint = int(30.0f / (requestedSpeed*terrainSpeed+0.001f)) + gs-&gt;frameNum+50;
-			etaWaypoint2 = int(25.0f / (requestedSpeed*terrainSpeed+0.001f)) + gs-&gt;frameNum+10;
-			atGoal = false;
-		} else {
-			if(DEBUG_CONTROLLER)
-				logOutput.Print(&quot;Path failure %i %i&quot;,owner-&gt;id,pathFailures);
-			pathFailures++;
-			if(pathFailures&gt;0){
-				pathFailures=0;
-				Fail();
-			}
-			etaWaypoint = INT_MAX;
-			etaWaypoint2 =INT_MAX;
-			nextWaypoint=waypoint;
-		}
-		//If the waypoint is very close to the goal, then correct it into the goal.
-		if(waypoint.distance2D(goal) &lt; CPathManager::PATH_RESOLUTION){
-			waypoint = goal;
-			haveFinalWaypoint=true;
-		}
-	}
-}
-
-
-/*
-The distance the unit will move at max breaking before stopping,
-starting from given speed.
-*/
-float CGroundMoveType::BreakingDistance(float speed)
-{
-	if (!owner-&gt;mobility-&gt;maxBreaking) {
-		logOutput &lt;&lt; &quot;maxBreaking is zero for unit &quot; &lt;&lt; owner-&gt;unitDef-&gt;name.c_str();
-		return 0.0f;
-	}
-	return fabs(speed * speed / owner-&gt;mobility-&gt;maxBreaking);
-}
-
-
-/*
-Gives the position this unit will end up at with full breaking
-from current velocity.
-*/
-float3 CGroundMoveType::Here()
-{
-	float3 motionDir = owner-&gt;speed;
-	if(motionDir.SqLength2D() == 0) {
-		return owner-&gt;midPos;
-	} else {
-		motionDir.Normalize();
-		return owner-&gt;midPos + (motionDir * BreakingDistance(owner-&gt;speed.Length2D()));
-	}
-}
-
-
-/*
-Gives the minimum distance to next waypoint that should be used,
-based on current speed.
-*/
-float CGroundMoveType::MinDistanceToWaypoint()
-{
-	return BreakingDistance(owner-&gt;speed.Length2D()) + CPathManager::PATH_RESOLUTION;
-}
-
-
-/*
-Gives the maximum distance from it's waypoint a unit could be
-before a new path is requested.
-*/
-float CGroundMoveType::MaxDistanceToWaypoint()
-{
-	return MinDistanceToWaypoint() * MAX_OFF_PATH_FACTOR;
-}
-
-/*
-Initializes motion.
-*/
-void CGroundMoveType::StartEngine() {
-	//Will be runned only if engine is no path
-	//and the unit is not already at the goal.
-	if(!pathId &amp;&amp; !atGoal) {
-		GetNewPath();
-		//Engine will be activated only if a path could be found.
-		if(pathId) {
-			pathFailures=0;
-			etaFailures=0;
-			owner-&gt;isMoving=true;
-			owner-&gt;cob-&gt;Call(COBFN_StartMoving);
-
-			if(DEBUG_CONTROLLER)
-				logOutput &lt;&lt; &quot;Engine started&quot; &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-		} else {
-			if(DEBUG_CONTROLLER)
-				logOutput &lt;&lt; &quot;Engine start failed: &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-
-			Fail();
-		}
-	}
-	nextObstacleAvoidanceUpdate=gs-&gt;frameNum;
-	//SetDeltaSpeed();
-}
-
-/*
-Stops motion.
-*/
-void CGroundMoveType::StopEngine() {
-	//Will be runned only if engine is active.
-	if(pathId) {
-		//Deactivating engine.
-		pathManager-&gt;DeletePath(pathId);
-		pathId = 0;
-		if(!atGoal)
-			waypoint = Here();
-
-		//Stop animation.
-		owner-&gt;cob-&gt;Call(COBFN_StopMoving);
-
-		if(DEBUG_CONTROLLER)
-			logOutput &lt;&lt; &quot;Engine stopped.&quot; &lt;&lt; &quot; &quot; &lt;&lt; owner-&gt;id &lt;&lt; &quot;\n&quot;;
-	}
-	owner-&gt;isMoving=false;
-	wantedSpeed=0;
-	//SetDeltaSpeed();
-}
-
-
-/*
-Called when the unit arrives at it's waypoint.
-*/
-void CGroundMoveType::Arrived()
-{
-	//Can only &quot;arrive&quot; if the engine is active.
-	if(progressState == Active) {
-		//Have reached waypoint.
-		atGoal = true;
-
-		StopEngine();
-
-		// Play &quot;arrived&quot; sound.
-		ENTER_UNSYNCED;
-		if (owner-&gt;team == gu-&gt;myTeam) {
-			int soundIdx = owner-&gt;unitDef-&gt;sounds.arrived.getRandomIdx();
-			if (soundIdx &gt;= 0) {
-				sound-&gt;PlayUnitReply(
-					owner-&gt;unitDef-&gt;sounds.arrived.getID(soundIdx), owner,
-					owner-&gt;unitDef-&gt;sounds.arrived.getVolume(soundIdx));
-			}
-		}
-		ENTER_SYNCED;
-
-		//And the action is done.
-		progressState = Done;
-		owner-&gt;commandAI-&gt;SlowUpdate();
-
-		if(DEBUG_CONTROLLER)
-			logOutput &lt;&lt; &quot;Unit arrived!\n&quot;;
-	}
-}
-
-/*
-Makes the unit fail this action.
-No more trials will be done before a new goal is given.
-*/
-void CGroundMoveType::Fail()
-{
-	if(DEBUG_CONTROLLER)
-		logOutput.Print(&quot;Unit failed! %i&quot;,owner-&gt;id);
-
-	StopEngine();
-
-	//Failure of finding a path means that this action
-	//has failed to reach it's goal.
-	progressState = Failed;
-
-	globalAI-&gt;UnitMoveFailed(owner);
-
-	//Sends a message to user.
-	ENTER_UNSYNCED;
-	if (owner-&gt;team == gu-&gt;myTeam) {
-		// Playing &quot;can't&quot; sound.
-		int soundIdx = owner-&gt;unitDef-&gt;sounds.cant.getRandomIdx();
-		if (soundIdx &gt;= 0) {
-			sound-&gt;PlayUnitReply(
-				owner-&gt;unitDef-&gt;sounds.cant.getID(soundIdx), owner,
-				owner-&gt;unitDef-&gt;sounds.cant.getVolume(soundIdx));
-		}
-
-		if (!owner-&gt;commandAI-&gt;unimportantMove &amp;&amp; owner-&gt;pos.distance(goal) &gt; goalRadius + 150) {
-			logOutput &lt;&lt; owner-&gt;unitDef-&gt;humanName.c_str() &lt;&lt; &quot;: Can't reach destination!\n&quot;;
-			logOutput.SetLastMsgPos(owner-&gt;pos);
-		}
-	}
-	ENTER_SYNCED;
-}
-
-
-
-void CGroundMoveType::CheckCollision(void)
-{
-	int2 newmp = owner-&gt;GetMapPos();
-
-	if (newmp.x != owner-&gt;mapPos.x || newmp.y != owner-&gt;mapPos.y) {
-		// now make sure we don't overrun any other units
-		bool haveCollided = false;
-		int retest = 0;
-
-		do {
-			const float zmove = (owner-&gt;mapPos.y + owner-&gt;ysize / 2) * SQUARE_SIZE;
-			const float xmove = (owner-&gt;mapPos.x + owner-&gt;xsize / 2) * SQUARE_SIZE;
-
-			if (fabs(owner-&gt;frontdir.x) &gt; fabs(owner-&gt;frontdir.z)) {
-				if (newmp.y &lt; owner-&gt;mapPos.y) {
-					haveCollided |= CheckColV(newmp.y, newmp.x, newmp.x + owner-&gt;xsize - 1,  zmove - 3.99f, owner-&gt;mapPos.y);
-					newmp = owner-&gt;GetMapPos();
-				} else if (newmp.y &gt; owner-&gt;mapPos.y) {
-					haveCollided |= CheckColV(newmp.y + owner-&gt;ysize - 1, newmp.x, newmp.x + owner-&gt;xsize - 1,  zmove + 3.99f, owner-&gt;mapPos.y + owner-&gt;ysize - 1);
-					newmp = owner-&gt;GetMapPos();
-				}
-				if (newmp.x &lt; owner-&gt;mapPos.x) {
-					haveCollided |= CheckColH(newmp.x, newmp.y, newmp.y + owner-&gt;ysize - 1,  xmove - 3.99f, owner-&gt;mapPos.x);
-					newmp = owner-&gt;GetMapPos();
-				} else if (newmp.x &gt; owner-&gt;mapPos.x) {
-					haveCollided |= CheckColH(newmp.x + owner-&gt;xsize - 1, newmp.y, newmp.y + owner-&gt;ysize - 1,  xmove + 3.99f, owner-&gt;mapPos.x + owner-&gt;xsize - 1);
-					newmp = owner-&gt;GetMapPos();
-				}
-			} else {
-				if (newmp.x &lt; owner-&gt;mapPos.x) {
-					haveCollided |= CheckColH(newmp.x, newmp.y, newmp.y + owner-&gt;ysize - 1,  xmove - 3.99f, owner-&gt;mapPos.x);
-					newmp = owner-&gt;GetMapPos();
-				} else if (newmp.x &gt; owner-&gt;mapPos.x) {
-					haveCollided |= CheckColH(newmp.x + owner-&gt;xsize - 1, newmp.y, newmp.y + owner-&gt;ysize - 1,  xmove + 3.99f, owner-&gt;mapPos.x + owner-&gt;xsize - 1);
-					newmp = owner-&gt;GetMapPos();
-				}
-				if (newmp.y &lt; owner-&gt;mapPos.y) {
-					haveCollided |= CheckColV(newmp.y, newmp.x, newmp.x + owner-&gt;xsize - 1,  zmove - 3.99f, owner-&gt;mapPos.y);
-					newmp = owner-&gt;GetMapPos();
-				} else if (newmp.y &gt; owner-&gt;mapPos.y) {
-					haveCollided |= CheckColV(newmp.y + owner-&gt;ysize - 1, newmp.x, newmp.x + owner-&gt;xsize - 1,  zmove + 3.99f, owner-&gt;mapPos.y + owner-&gt;ysize - 1);
-					newmp = owner-&gt;GetMapPos();
-				}
-			}
-			++retest;
-		}
-		while (haveCollided &amp;&amp; retest &lt; 2);
-
-		// owner-&gt;UnBlock();
-		owner-&gt;Block();
-	}
-
-	return;
-}
-
-
-bool CGroundMoveType::CheckColH(int x, int y1, int y2, float xmove, int squareTestX)
-{
-	for (int y = y1; y &lt;= y2; ++y) {
-		CSolidObject* c = readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x];
-
-		if (c) {
-			if (readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + squareTestX] != 0 &amp;&amp;
-				readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + squareTestX] != owner) {
-				continue;
-			}
-			if (c-&gt;mobility) {
-				// if other party is mobile, start to skuff it out of the way
-				float part = owner-&gt;mass / (owner-&gt;mass + c-&gt;mass * 2);
-				float3 dif = c-&gt;pos - owner-&gt;pos;
-				float dl = dif.Length();
-				float colDepth = fabs(owner-&gt;pos.x - xmove);
-				dif *= colDepth / dl;
-
-				// adjust our own position a
-				// bit so we have to turn less
-				// FIXME CAN PLACE US IN BUILDING
-				owner-&gt;pos -= dif * (1 - part);
-				// safe cast (only units can be mobile)
-				CUnit* u = (CUnit*) c;
-
-				if (!u-&gt;unitDef-&gt;pushResistant) {
-					// push the blocking unit out of the way
-					// FIXME CAN PLACE OTHER PARTY IN BUILDING
-					u-&gt;pos += dif * (part);
-					u-&gt;midPos = u-&gt;pos + u-&gt;frontdir * u-&gt;relMidPos.z + u-&gt;updir * u-&gt;relMidPos.y + u-&gt;rightdir * u-&gt;relMidPos.x;
-				}
-
-				if (!(gs-&gt;frameNum + owner-&gt;id &amp; 31) &amp;&amp; !owner-&gt;commandAI-&gt;unimportantMove) {
-					// if we (MT owner) are doing something important, tell units around us to bugger off
-					helper-&gt;BuggerOff(owner-&gt;pos + owner-&gt;frontdir * owner-&gt;radius, owner-&gt;radius, owner);
-				}
-			}
-
-			MoveData* m = owner-&gt;mobility-&gt;moveData;
-
-			// if other party can be overrun then overrun it
-			if (!m-&gt;moveMath-&gt;IsBlocking(*m, c)) {
-				float3 fix = owner-&gt;frontdir * currentSpeed * 200;
-				c-&gt;Kill(fix);
-			}
-
-			// hack to make units find openings easier until the pathfinder can do it itself
-			// FIXME CAN PLACE US IN BUILDING
-			if (readmap-&gt;groundBlockingObjectMap[y1 * gs-&gt;mapx + x] == 0)
-				owner-&gt;pos.z -= fabs(owner-&gt;pos.x - xmove) * 0.5f;
-			if (readmap-&gt;groundBlockingObjectMap[y2 * gs-&gt;mapx + x] == 0)
-				owner-&gt;pos.z += fabs(owner-&gt;pos.x - xmove) * 0.5f;
-
-			owner-&gt;pos.x = xmove;
-			currentSpeed *= 0.97f;
-			return true;
-		}
-	}
-
-	return false;
-}
-
-bool CGroundMoveType::CheckColV(int y, int x1, int x2, float zmove, int squareTestY)
-{
-	for (int x = x1; x &lt;= x2; ++x) {
-		CSolidObject* c = readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x];
-
-		if (c) {
-			if (readmap-&gt;groundBlockingObjectMap[squareTestY * gs-&gt;mapx + x] != 0 &amp;&amp;
-				readmap-&gt;groundBlockingObjectMap[squareTestY * gs-&gt;mapx + x] != owner) {
-				continue;
-			}
-			if (c-&gt;mobility) {
-				// if other party is mobile, start to skuff it out of the way
-				float part = owner-&gt;mass / (owner-&gt;mass + c-&gt;mass * 2);
-				float3 dif = c-&gt;pos - owner-&gt;pos;
-				float dl = dif.Length();
-				float colDepth = fabs(owner-&gt;pos.z - zmove);
-				dif *= colDepth / dl;
-
-				// adjust our own position a
-				// bit so we have to turn less
-				// FIXME CAN PLACE US IN BUILDING
-				owner-&gt;pos -= dif * (1 - part);
-				// safe cast (only units can be mobile)
-				CUnit* u = (CUnit*) c;
-
-				if (!u-&gt;unitDef-&gt;pushResistant) {
-					// push the blocking unit out of the way
-					// FIXME CAN PLACE OTHER PARTY IN BUILDING
-					c-&gt;pos += dif * (part);
-					u-&gt;midPos = u-&gt;pos + u-&gt;frontdir * u-&gt;relMidPos.z + u-&gt;updir * u-&gt;relMidPos.y + u-&gt;rightdir * u-&gt;relMidPos.x;
-				}
-
-				if (!(gs-&gt;frameNum + owner-&gt;id &amp; 31) &amp;&amp; !owner-&gt;commandAI-&gt;unimportantMove) {
-					// if we (MT owner) are doing something important, tell units around us to bugger off
-					helper-&gt;BuggerOff(owner-&gt;pos + owner-&gt;frontdir * owner-&gt;radius, owner-&gt;radius, owner);
-				}
-			}
-
-			MoveData* m = owner-&gt;mobility-&gt;moveData;
-
-			// if other party can be overrun then overrun it
-			if (!m-&gt;moveMath-&gt;IsBlocking(*m, c)) {
-				float3 fix = owner-&gt;frontdir * currentSpeed * 200;
-				c-&gt;Kill(fix);
-			}
-
-			// hack to make units find openings easier until the pathfinder can do it itself
-			// FIXME CAN PLACE US IN BUILDING
-			if (readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x1] == 0)
-				owner-&gt;pos.x -= fabs(owner-&gt;pos.z - zmove) * 0.5f;
-			if (readmap-&gt;groundBlockingObjectMap[y * gs-&gt;mapx + x2] == 0)
-				owner-&gt;pos.x += fabs(owner-&gt;pos.z - zmove) * 0.5f;
-
-			owner-&gt;pos.z = zmove;
-			currentSpeed *= 0.97f;
-			return true;
-		}
-	}
-
-	return false;
-}
-
-
-
-//creates the tables used to see if we should advance to next pathfinding waypoint
-void CGroundMoveType::CreateLineTable(void)
-{
-	lineTable = new std::vector&lt;int2&gt;[11][11];
-
-	for(int yt=0;yt&lt;11;++yt){
-		for(int xt=0;xt&lt;11;++xt){
-			float3 start(0.5f,0,0.5f);
-			float3 to((xt-5)+0.5f,0,(yt-5)+0.5f);
-
-			float dx=to.x-start.x;
-			float dz=to.z-start.z;
-			float xp=start.x;
-			float zp=start.z;
-			float xn,zn;
-
-			if(floor(start.x)==floor(to.x)){
-				if(dz&gt;0)
-					for(int a=1;a&lt;floor(to.z);++a)
-						lineTable[yt][xt].push_back(int2(0,a));
-				else
-					for(int a=-1;a&gt;floor(to.z);--a)
-						lineTable[yt][xt].push_back(int2(0,a));
-			} else if(floor(start.z)==floor(to.z)){
-				if(dx&gt;0)
-					for(int a=1;a&lt;floor(to.x);++a)
-						lineTable[yt][xt].push_back(int2(a,0));
-				else
-					for(int a=-1;a&gt;floor(to.x);--a)
-						lineTable[yt][xt].push_back(int2(a,0));
-			} else {
-				bool keepgoing=true;
-				while(keepgoing){
-					if(dx&gt;0){
-						xn=(floor(xp)+1-xp)/dx;
-					} else {
-						xn=(floor(xp)-xp)/dx;
-					}
-					if(dz&gt;0){
-						zn=(floor(zp)+1-zp)/dz;
-					} else {
-						zn=(floor(zp)-zp)/dz;
-					}
-
-					if(xn&lt;zn){
-						xp+=(xn+0.0001f)*dx;
-						zp+=(xn+0.0001f)*dz;
-					} else {
-						xp+=(zn+0.0001f)*dx;
-						zp+=(zn+0.0001f)*dz;
-					}
-					keepgoing=fabs(xp-start.x)&lt;fabs(to.x-start.x) &amp;&amp; fabs(zp-start.z)&lt;fabs(to.z-start.z);
-
-					lineTable[yt][xt].push_back(int2((int)(floor(xp)),(int)(floor(zp))));
-				}
-				lineTable[yt][xt].pop_back();
-				lineTable[yt][xt].pop_back();
-			}
-		}
-	}
-}
-
-void CGroundMoveType::DeleteLineTable(void)
-{
-	delete [] lineTable;
-	lineTable = 0;
-}
-
-void CGroundMoveType::TestNewTerrainSquare(void)
-{
-	int newMoveSquareX=(int)owner-&gt;pos.x / (SQUARE_SIZE*2);		//first make sure we dont go into any terrain we cant get out of
-	int newMoveSquareY=(int)owner-&gt;pos.z / (SQUARE_SIZE*2);
-
-	if(newMoveSquareX!=moveSquareX || newMoveSquareY!=moveSquareY){
-		float cmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, moveSquareX*2,moveSquareY*2);
-		if(fabs(owner-&gt;frontdir.x)&lt;fabs(owner-&gt;frontdir.z)){
-			if(newMoveSquareX&gt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareX=moveSquareX;
-				}
-			} else if(newMoveSquareX&lt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+0.01f;
-					newMoveSquareX=moveSquareX;
-				}
-			}
-			if(newMoveSquareY&gt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareY=moveSquareY;
-				}
-			} else if(newMoveSquareY&lt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+0.01f;
-					newMoveSquareY=moveSquareY;
-				}
-			}
-		} else {
-			if(newMoveSquareY&gt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareY=moveSquareY;
-				}
-			} else if(newMoveSquareY&lt;moveSquareY){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.z=moveSquareY*SQUARE_SIZE*2+0.01f;
-					newMoveSquareY=moveSquareY;
-				}
-			}
-			if(newMoveSquareX&gt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+(SQUARE_SIZE*2-0.01f);
-					newMoveSquareX=moveSquareX;
-				}
-			} else if(newMoveSquareX&lt;moveSquareX){
-				float nmod=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, newMoveSquareX*2,newMoveSquareY*2);
-				if(cmod&gt;0.01f &amp;&amp; nmod&lt;=0.01f){
-					owner-&gt;pos.x=moveSquareX*SQUARE_SIZE*2+0.01f;
-					newMoveSquareX=moveSquareX;
-				}
-			}
-		}
-		if(newMoveSquareX!=moveSquareX || newMoveSquareY!=moveSquareY){
-			moveSquareX=newMoveSquareX;
-			moveSquareY=newMoveSquareY;
-			terrainSpeed=owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, (moveSquareX)*2,(moveSquareY)*2);
-			etaWaypoint = int(30.0f / (requestedSpeed*terrainSpeed+0.001f)) + gs-&gt;frameNum+50;
-			etaWaypoint2 = int(25.0f / (requestedSpeed*terrainSpeed+0.001f)) + gs-&gt;frameNum+10;
-
-			int nwsx=(int)nextWaypoint.x / (SQUARE_SIZE*2);		//if we have moved check if we can get a new waypoint
-			int nwsy=(int)nextWaypoint.z / (SQUARE_SIZE*2);
-
-			int numIter=0;
-			//lowered the original 6 absolute distance to slightly more than 4.5f euclidian distance
-			//to fix units getting stuck in buildings --tvo
-			//My first fix set it to 21, as the pathfinding was still considered broken by many I reduced it to 11 (arbitrarily)
-			//Does anyone know whether lowering this constant has any adverse side effects? Like e.g. more CPU usage? --tvo
-			while((nwsx-moveSquareX)*(nwsx-moveSquareX)+(nwsy-moveSquareY)*(nwsy-moveSquareY) &lt; 11 &amp;&amp; !haveFinalWaypoint &amp;&amp; pathId){
-				int ltx=nwsx-moveSquareX+5;
-				int lty=nwsy-moveSquareY+5;
-				bool wpOk=true;
-				for(std::vector&lt;int2&gt;::iterator li=lineTable[lty][ltx].begin();li!=lineTable[lty][ltx].end();++li){
-					int x=(moveSquareX+li-&gt;x)*2;
-					int y=(moveSquareY+li-&gt;y)*2;
-					if((owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;IsBlocked(*owner-&gt;unitDef-&gt;movedata, x, y) &amp; (CMoveMath::BLOCK_STRUCTURE | CMoveMath::BLOCK_TERRAIN | CMoveMath::BLOCK_MOBILE | CMoveMath::BLOCK_MOBILE_BUSY)) || owner-&gt;unitDef-&gt;movedata-&gt;moveMath-&gt;SpeedMod(*owner-&gt;unitDef-&gt;movedata, x,y)&lt;=0.01f){
-						wpOk=false;
-						break;
-					}
-				}
-				if(!wpOk || numIter&gt;6)
-					break;
-				GetNextWaypoint();
-				nwsx=(int)nextWaypoint.x / (SQUARE_SIZE*2);
-				nwsy=(int)nextWaypoint.z / (SQUARE_SIZE*2);
-				++numIter;
-			}
-		}
-	}
-}
-
-bool CGroundMoveType::CheckGoalFeasability(void)
-{
-	float goalDist=goal.distance2D(owner-&gt;pos);
-
-	int minx=(int)max(0.f,(goal.x-goalDist)/(SQUARE_SIZE*2));
-	int minz=(int)max(0.f,(goal.z-goalDist)/(SQUARE_SIZE*2));
-
-	int maxx=(int)min(float(gs-&gt;hmapx-1),(goal.x+goalDist)/(SQUARE_SIZE*2));
-	int maxz=(int)min(float(gs-&gt;hmapy-1),(goal.z+goalDist)/(SQUARE_SIZE*2));
-
-	MoveData* md=owner-&gt;unitDef-&gt;movedata;
-	CMoveMath* mm=md-&gt;moveMath;
-
-	float numBlocked=0;
-	float numSquares=0;
-
-	for(int z=minz;z&lt;=maxz;++z){
-		for(int x=minx;x&lt;=maxx;++x){
-			float3 pos(x*SQUARE_SIZE*2,0,z*SQUARE_SIZE*2);
-			if((pos-goal).SqLength2D()&lt;goalDist*goalDist){
-				int blockingType=mm-&gt;SquareIsBlocked(*md,x*2,z*2);
-				if((blockingType &amp; CMoveMath::BLOCK_STRUCTURE) || mm-&gt;SpeedMod(*md,x*2,z*2)&lt;0.01f){
-					numBlocked+=0.3f;
-					numSquares+=0.3f;
-				} else {
-					numSquares+=1.0f;
-					if(blockingType)
-						numBlocked+=1.0f;
-				}
-			}
-		}
-	}
-	if(numSquares&gt;0){
-		float partBlocked=numBlocked/numSquares;
-		if(DEBUG_CONTROLLER)
-			logOutput.Print(&quot;Part blocked %i %.0f%% %.0f&quot;,owner-&gt;id,partBlocked*100,goalDist);
-		if(partBlocked&gt;0.4f)
-			return false;
-	}
-	return true;
-}
-
-void CGroundMoveType::LeaveTransport(void)
-{
-	oldPos=owner-&gt;pos+UpVector*0.001f;
-}
-
-void CGroundMoveType::KeepPointingTo(float3 pos, float distance, bool aggressive){
-	mainHeadingPos = pos;
-	useMainHeading = aggressive;
-	if(useMainHeading &amp;&amp; !owner-&gt;weapons.empty()){
-		if(!owner-&gt;weapons[0]-&gt;weaponDef-&gt;waterweapon &amp;&amp; mainHeadingPos.y &lt;= 1){
-			mainHeadingPos.y = 1;
-		}
-		float3 dir1 = owner-&gt;weapons.front()-&gt;mainDir;
-		dir1.y = 0;
-		dir1.Normalize();
-		float3 dir2 = mainHeadingPos-owner-&gt;pos;
-		dir2.y = 0;
-		dir2.Normalize();
-		if(dir2 != ZeroVector){
-			short heading = GetHeadingFromVector(dir2.x,dir2.z)
-				- GetHeadingFromVector(dir1.x,dir1.z);
-			if(owner-&gt;heading != heading
-					&amp;&amp; !(owner-&gt;weapons.front()-&gt;TryTarget(
-					mainHeadingPos, true, 0))){
-				progressState = Active;
-			}
-		}
-	}
-}
-
-void CGroundMoveType::KeepPointingTo(CUnit* unit, float distance, bool aggressive){
-	mainHeadingPos = unit-&gt;pos;
-	useMainHeading = aggressive;
-	if(useMainHeading
-			&amp;&amp; !owner-&gt;weapons.empty()
-			&amp;&amp; (this-owner-&gt;weapons[0]-&gt;weaponDef-&gt;waterweapon
-			|| mainHeadingPos.y &gt;= 0)){
-		float3 dir1 = owner-&gt;weapons.front()-&gt;mainDir;
-		dir1.y = 0;
-		dir1.Normalize();
-		float3 dir2 = mainHeadingPos-owner-&gt;pos;
-		dir2.y = 0;
-		dir2.Normalize();
-		if(dir2 != ZeroVector){
-			short heading = GetHeadingFromVector(dir2.x,dir2.z)
-				- GetHeadingFromVector(dir1.x,dir1.z);
-			if(owner-&gt;heading != heading
-					&amp;&amp; !(owner-&gt;weapons.front()-&gt;TryTarget(
-					mainHeadingPos, true, 0))){
-				progressState = Active;
-			}
-		}
-	}
-}
-
-/**
-* @brief Orients owner so that weapon[0]'s arc includes mainHeadingPos
-*/
-void CGroundMoveType::SetMainHeading(){
-	if(useMainHeading &amp;&amp; !owner-&gt;weapons.empty()){
-		float3 dir1 = owner-&gt;weapons.front()-&gt;mainDir;
-		dir1.y = 0;
-		dir1.Normalize();
-		float3 dir2 = mainHeadingPos-owner-&gt;pos;
-		dir2.y = 0;
-		dir2.Normalize();
-		if(dir2 != ZeroVector){
-			short heading = GetHeadingFromVector(dir2.x,dir2.z)
-				- GetHeadingFromVector(dir1.x,dir1.z);
-
-			if(progressState == Active &amp;&amp; owner-&gt;heading == heading){
-				//logOutput.Print(&quot;Stop turning&quot;);
-				owner-&gt;cob-&gt;Call(COBFN_StopMoving);
-				progressState = Done;
-			} else if(progressState == Active){
-				ChangeHeading(heading);
-				//logOutput.Print(&quot;Test headding: %d,  Real headding: %d&quot;, heading,
-				//	owner-&gt;heading);
-			} else if(progressState != Active
-			  &amp;&amp; owner-&gt;heading != heading
-			  &amp;&amp; !owner-&gt;weapons.front()-&gt;TryTarget(mainHeadingPos, true,0)){
-				progressState = Active;
-				owner-&gt;cob-&gt;Call(COBFN_StartMoving);
-				ChangeHeading(heading);
-				//logOutput.Print(&quot;Start Moving&quot;);
-			} else {
-				//logOutput.Print(&quot;No set main headding&quot;);
-			}
-		} else {
-			//logOutput.Print(&quot;Zero Vector&quot;);
-		}
-	}
-}
-
-void CGroundMoveType::SetMaxSpeed(float speed)
-{
-	if(requestedSpeed == maxSpeed*2)
-		requestedSpeed = speed*2;	//why the *2 everywhere?
-	maxSpeed=speed;
-}
-
-bool CGroundMoveType::OnSlope(){
-	return owner-&gt;unitDef-&gt;slideTolerance &gt;= 1
-		&amp;&amp; (ground-&gt;GetSlope(owner-&gt;midPos.x, owner-&gt;midPos.z) &gt;
-		owner-&gt;unitDef-&gt;movedata-&gt;maxSlope*owner-&gt;unitDef-&gt;slideTolerance);
-}
-
-void CGroundMoveType::StartSkidding(){
-	skidding = true;
-}
-
-void CGroundMoveType::StartFlying() {
-	skidding = true; // flying requires skidding
-	flying = true;
-}

Deleted: trunk/rts/Sim/MoveTypes/groundmovetype.h
===================================================================
--- trunk/rts/Sim/MoveTypes/groundmovetype.h	2008-01-18 20:08:47 UTC (rev 5344)
+++ trunk/rts/Sim/MoveTypes/groundmovetype.h	2008-01-18 20:09:10 UTC (rev 5345)
@@ -1,149 +0,0 @@
-#ifndef GROUNDMOVETYPE_H
-#define GROUNDMOVETYPE_H
-
-#include &quot;MoveType.h&quot;
-#include &quot;Sim/Objects/SolidObject.h&quot;
-
-struct MoveData;
-
-class CGroundMoveType :
-	public CMoveType
-{
-	CR_DECLARE(CGroundMoveType);
-public:
-	CGroundMoveType(CUnit* owner);
-	~CGroundMoveType(void);
-
-	void PostLoad();
-
-	void Update();
-	void SlowUpdate();
-
-	void SetDeltaSpeed(void);
-	bool TestNewPathGoal(const float3&amp; newgoal);
-
-	void StartMoving(float3 pos, float goalRadius);
-	void StartMoving(float3 pos, float goalRadius, float speed);
-	void StopMoving();
-
-	virtual void SetMaxSpeed(float speed);
-
-	void ImpulseAdded(void);
-	
-	void KeepPointingTo(float3 pos, float distance, bool aggressive);
-	void KeepPointingTo(CUnit* unit, float distance, bool aggressive);
-
-	bool OnSlope(void);
-	
-	float baseTurnRate;
-	float turnRate;
-	float accRate;
-
-	float wantedSpeed;
-	float currentSpeed;
-	float deltaSpeed;
-	short int deltaHeading;
-	
-	float3 oldPos;
-	float3 oldSlowUpdatePos;
-	float3 flatFrontDir;
-
-	unsigned int pathId;
-	float3 goal;
-	float goalRadius;
-
-	float3 waypoint;
-	float3 nextWaypoint;
-	int etaWaypoint;			//by this time it really should have gotten there genereate new path otherwise
-	int etaWaypoint2;			//by this time we get suspicious, check if goal is clogged if we are close
-	bool atGoal;
-	bool haveFinalWaypoint;
-	float terrainSpeed;
-
-	float requestedSpeed;
-	short requestedTurnRate;
-
-	float currentDistanceToWaypoint;
-
-	float3 avoidanceVec;
-
-	unsigned int restartDelay;
-	float3 lastGetPathPos;
-
-	unsigned int pathFailures;
-	unsigned int etaFailures;				//how many times we havent gotten to a waypoint in time
-	unsigned int nonMovingFailures;	//how many times we have requested a path from the same place
-
-	int moveType;
-
-	bool floatOnWater;
-
-	int moveSquareX;
-	int moveSquareY;
-protected:
-	int nextDeltaSpeedUpdate;
-	int nextObstacleAvoidanceUpdate;
-
-	int lastTrackUpdate;
-
-	float3 ObstacleAvoidance(float3 desiredDir);
-	float Distance2D(CSolidObject *object1, CSolidObject *object2, float marginal = 0.0f);
-
-	void GetNewPath();
-	void GetNextWaypoint();
-
-	float BreakingDistance(float speed);
-	float3 Here();
-
-	float MinDistanceToWaypoint();
-	float MaxDistanceToWaypoint();
-
-	void StartEngine();
-	void StopEngine();
-	
-	void Arrived();
-	void Fail();
-	void CheckCollision(void);
-
-	void ChangeHeading(short wantedHeading);
-
-	void UpdateSkid(void);
-	void UpdateControlledDrop(void);
-	void CheckCollisionSkid(void);
-	float GetFlyTime(float3 pos, float3 speed);
-	void CalcSkidRot(void);
-
-	bool skidding;
-	bool flying;
-	float skidRotSpeed;
-	float dropSpeed;
-	float dropHeight;
-
-	float3 skidRotVector;
-	float skidRotSpeed2;
-	float skidRotPos2;
-	CSolidObject::PhysicalState oldPhysState;
-
-	bool CheckColH(int x, int y1, int y2, float xmove, int squareTestX);
-	bool CheckColV(int y, int x1, int x2, float zmove, int squareTestY);
-
-	static std::vector&lt;int2&gt; (*lineTable)[11];
-	
-	float3 mainHeadingPos;
-	bool useMainHeading;
-	void SetMainHeading();
-
-public:
-	static void CreateLineTable(void);
-	static void DeleteLineTable(void);
-	void TestNewTerrainSquare(void);
-	bool CheckGoalFeasability(void);
-	virtual void LeaveTransport(void);
-	
-	void StartSkidding(void);
-	void StartFlying(void);
-};
-
-
-
-#endif /* GROUNDMOVETYPE_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000151.html">[Taspring-linux-commit] r5344 - in trunk/rts: Lua Sim/MoveTypes	Sim/Units Sim/Units/UnitTypes build/vstudio8
</A></li>
	<LI>Next message: <A HREF="000153.html">[Taspring-linux-commit] r5346 - trunk/tools/ArchiveMover
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#152">[ date ]</a>
              <a href="thread.html#152">[ thread ]</a>
              <a href="subject.html#152">[ subject ]</a>
              <a href="author.html#152">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
