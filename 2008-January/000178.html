<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r5371 - in trunk:	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/UI rts/Lua rts/Map rts/Rendering	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/MoveTypes	rts/Sim/Units rts/lib/lua rts/lib/lua/include
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2008-January/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5371%20-%20in%20trunk%3A%0A%09installer/builddata/springcontent/LuaGadgets%0A%09installer/builddata/springcontent/gamedata%20rts/Game%0A%09rts/Game/UI%20rts/Lua%20rts/Map%20rts/Rendering%0A%09rts/Rendering/UnitModels%20rts/Sim/Misc%20rts/Sim/MoveTypes%0A%09rts/Sim/Units%20rts/lib/lua%20rts/lib/lua/include&In-Reply-To=%3CE1JHrxV-0007hr-76%40proserver.fnord.lan%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000177.html">
   <LINK REL="Next"  HREF="000179.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r5371 - in trunk:	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/UI rts/Lua rts/Map rts/Rendering	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/MoveTypes	rts/Sim/Units rts/lib/lua rts/lib/lua/include</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r5371%20-%20in%20trunk%3A%0A%09installer/builddata/springcontent/LuaGadgets%0A%09installer/builddata/springcontent/gamedata%20rts/Game%0A%09rts/Game/UI%20rts/Lua%20rts/Map%20rts/Rendering%0A%09rts/Rendering/UnitModels%20rts/Sim/Misc%20rts/Sim/MoveTypes%0A%09rts/Sim/Units%20rts/lib/lua%20rts/lib/lua/include&In-Reply-To=%3CE1JHrxV-0007hr-76%40proserver.fnord.lan%3E"
       TITLE="[Taspring-linux-commit] r5371 - in trunk:	installer/builddata/springcontent/LuaGadgets	installer/builddata/springcontent/gamedata rts/Game	rts/Game/UI rts/Lua rts/Map rts/Rendering	rts/Rendering/UnitModels rts/Sim/Misc rts/Sim/MoveTypes	rts/Sim/Units rts/lib/lua rts/lib/lua/include">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Jan 24 03:36:53 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="000177.html">[Taspring-linux-commit] r5370 - trunk/AI/Global/KAIK-0.13
</A></li>
        <LI>Next message: <A HREF="000179.html">[Taspring-linux-commit] r5372 - trunk/rts/Lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#178">[ date ]</a>
              <a href="thread.html#178">[ thread ]</a>
              <a href="subject.html#178">[ subject ]</a>
              <a href="author.html#178">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: trepan
Date: 2008-01-24 03:36:52 +0100 (Thu, 24 Jan 2008)
New Revision: 5371

Added:
   trunk/rts/Map/HeightMapTexture.cpp
   trunk/rts/Map/HeightMapTexture.h
Modified:
   trunk/installer/builddata/springcontent/LuaGadgets/callins.lua
   trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua
   trunk/installer/builddata/springcontent/LuaGadgets/system.lua
   trunk/installer/builddata/springcontent/gamedata/modrules.lua
   trunk/rts/Game/Game.cpp
   trunk/rts/Game/GameHelper.cpp
   trunk/rts/Game/Team.cpp
   trunk/rts/Game/UI/LuaUI.cpp
   trunk/rts/Lua/LuaBitOps.cpp
   trunk/rts/Lua/LuaHandleSynced.cpp
   trunk/rts/Lua/LuaHandleSynced.h
   trunk/rts/Lua/LuaHashString.h
   trunk/rts/Lua/LuaOpenGL.cpp
   trunk/rts/Lua/LuaRules.cpp
   trunk/rts/Lua/LuaRules.h
   trunk/rts/Lua/LuaSyncedCall.cpp
   trunk/rts/Lua/LuaSyncedMoveCtrl.cpp
   trunk/rts/Lua/LuaSyncedMoveCtrl.h
   trunk/rts/Lua/LuaSyncedRead.cpp
   trunk/rts/Lua/LuaSyncedRead.h
   trunk/rts/Lua/LuaUnsyncedCall.cpp
   trunk/rts/Lua/LuaUtils.cpp
   trunk/rts/Lua/LuaUtils.h
   trunk/rts/Map/BasicMapDamage.cpp
   trunk/rts/Rendering/FartextureHandler.cpp
   trunk/rts/Rendering/FartextureHandler.h
   trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
   trunk/rts/Sim/Misc/FeatureHandler.cpp
   trunk/rts/Sim/Misc/FeatureHandler.h
   trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
   trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp
   trunk/rts/Sim/MoveTypes/ScriptMoveType.h
   trunk/rts/Sim/Units/Unit.cpp
   trunk/rts/Sim/Units/UnitDefHandler.cpp
   trunk/rts/lib/lua/README_SPRING
   trunk/rts/lib/lua/include/LuaInclude.h
   trunk/rts/lib/lua/include/lauxlib.h
   trunk/rts/lib/lua/include/luaconf.h
Log:
* Added the LuaRules  MoveCtrlNotify(unitID, unitDefID, unitTeam, data)  call-in
  - currently called with data = 1 if the unit hits the ground and stops)
  - return true to disable the unit's MoveCtrl
* Added the dynamic HeightMapTexture
  - FLOAT32/LUMINANCE format, NEAREST/NEAREST filtering
  - can be accessed by lua scripts using '$heightmap'
  - can be disable by clients with 'HeightMapTex=0' (config parameter)
* Reverted the GetPositionLosState() to its original configuration (no air los),
  (and made it faster)
* Added the  IsPosInLos()    call-out
* Added the  IsPosInRadar()  call-out
* Added the  IsPosInAirLos() call-out
* Fixed the SendToUnsynced() stack check bug
* Fixed ScriptMoveType vs. unit pushing
* Removed LUA_COMPAT_GETN
* Simplified the LuaBitOps code
* Fixed it so that units using ScriptMoveType can not be pushed
* Fixed lua_checkrawi()  (inverted polarity, also fixes FBO MRT)


Modified: trunk/installer/builddata/springcontent/LuaGadgets/callins.lua
===================================================================
--- trunk/installer/builddata/springcontent/LuaGadgets/callins.lua	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/installer/builddata/springcontent/LuaGadgets/callins.lua	2008-01-24 02:36:52 UTC (rev 5371)
@@ -65,7 +65,6 @@
   &quot;CobCallback&quot;,
   &quot;AllowCommand&quot;,
   &quot;CommandFallback&quot;,
-  &quot;BuilderTerraformComplete&quot;,
   &quot;AllowUnitCreation&quot;,
   &quot;AllowUnitTransfer&quot;,
   &quot;AllowUnitBuildStep&quot;,
@@ -73,6 +72,8 @@
   &quot;AllowFeatureBuildStep&quot;,
   &quot;AllowResourceLevel&quot;,
   &quot;AllowResourceTransfer&quot;,
+  &quot;MoveCtrlNotify&quot;,
+  &quot;BuilderTerraformComplete&quot;,
 }
 
 

Modified: trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua
===================================================================
--- trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/installer/builddata/springcontent/LuaGadgets/gadgets.lua	2008-01-24 02:36:52 UTC (rev 5371)
@@ -122,7 +122,6 @@
 
   -- LuaRules CallIns
   'CommandFallback',
-  'BuilderTerraformComplete',
   'AllowCommand',
   'AllowUnitCreation',
   'AllowUnitTransfer',
@@ -131,6 +130,8 @@
   'AllowResourceLevel',
   'AllowResourceTransfer',
   'AllowDirectUnitControl',
+  'MoveCtrlNotify',
+  'BuilderTerraformComplete',
 
   -- COB CallIn  (FIXME?)
   'CobCallback',
@@ -984,19 +985,6 @@
 end
 
 
-function gadgetHandler:BuilderTerraformComplete(unitID, unitDefID, unitTeam,
-                                       buildUnitID, buildUnitDefID, buildUnitTeam)
-  for _,g in ipairs(self.BuilderTerraformCompleteList) do
-    local stop = g:BuilderTerraformComplete(unitID, unitDefID, unitTeam,
-                                       buildUnitID, buildUnitDefID, buildUnitTeam)
-    if (stop) then
-      return true
-    end
-  end
-  return false
-end
-
-
 function gadgetHandler:AllowCommand(unitID, unitDefID, unitTeam,
                                     cmdID, cmdParams, cmdOptions, synced)
   for _,g in ipairs(self.AllowCommandList) do
@@ -1087,6 +1075,30 @@
 end
 
 
+function gadgetHandler:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)
+  local state = false
+  for _,g in ipairs(self.MoveCtrlNotifyList) do
+    if (g:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)) then
+      state = true
+    end
+  end
+  return state
+end
+
+
+function gadgetHandler:BuilderTerraformComplete(unitID, unitDefID, unitTeam,
+                                       buildUnitID, buildUnitDefID, buildUnitTeam)
+  for _,g in ipairs(self.BuilderTerraformCompleteList) do
+    local stop = g:BuilderTerraformComplete(unitID, unitDefID, unitTeam,
+                                       buildUnitID, buildUnitDefID, buildUnitTeam)
+    if (stop) then
+      return true
+    end
+  end
+  return false
+end
+
+
 --------------------------------------------------------------------------------
 --
 --  Unit call-ins

Modified: trunk/installer/builddata/springcontent/LuaGadgets/system.lua
===================================================================
--- trunk/installer/builddata/springcontent/LuaGadgets/system.lua	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/installer/builddata/springcontent/LuaGadgets/system.lua	2008-01-24 02:36:52 UTC (rev 5371)
@@ -26,12 +26,12 @@
     CMDTYPE = CMDTYPE,
     VFS = VFS,
 
-    UnitDefs     = UnitDefs,
-    UnitDefNames = UnitDefNames,
-    FeatureDefs  = FeatureDefs,
-    FeatureDefNames  = FeatureDefNames,
-    WeaponDefs   = WeaponDefs,
-    WeaponDefNames   = WeaponDefNames,
+    UnitDefs        = UnitDefs,
+    UnitDefNames    = UnitDefNames,
+    FeatureDefs     = FeatureDefs,
+    FeatureDefNames = FeatureDefNames,
+    WeaponDefs      = WeaponDefs,
+    WeaponDefNames  = WeaponDefNames,
 
     --
     -- Custom Constants

Modified: trunk/installer/builddata/springcontent/gamedata/modrules.lua
===================================================================
--- trunk/installer/builddata/springcontent/gamedata/modrules.lua	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/installer/builddata/springcontent/gamedata/modrules.lua	2008-01-24 02:36:52 UTC (rev 5371)
@@ -14,14 +14,19 @@
 
 local TDF = VFS.Include('gamedata/parse_tdf.lua')
 
+--------------------------------------------------------------------------------
+--------------------------------------------------------------------------------
+
+if (not VFS.FileExists('gamedata/modrules.tdf')) then
+  return false
+end
+
 local modrules, err = TDF.Parse('gamedata/modrules.tdf')
 if (modrules == nil) then
   error('Error parsing modrules.tdf: ' .. err)
 end
 
-
 --------------------------------------------------------------------------------
---------------------------------------------------------------------------------
 
 return modrules
 

Modified: trunk/rts/Game/Game.cpp
===================================================================
--- trunk/rts/Game/Game.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Game/Game.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -51,6 +51,7 @@
 #include &quot;FileSystem/VFSHandler.h&quot;
 #include &quot;Map/BaseGroundDrawer.h&quot;
 #include &quot;Map/Ground.h&quot;
+#include &quot;Map/HeightMapTexture.h&quot;
 #include &quot;Map/MapDamage.h&quot;
 #include &quot;Map/MetalMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
@@ -511,6 +512,7 @@
 	CLuaGaia::FreeHandler();
 	CLuaRules::FreeHandler();
 	LuaOpenGL::Free();
+	heightMapTexture.Kill();
 
 	if (gameServer)delete gameServer;gameServer         = NULL;
 
@@ -2901,8 +2903,8 @@
 					logOutput.Print(&quot;Got invalid player num %i in chat msg&quot;,player);
 				} else  {
 					string s=(char*)(&amp;inbuf[3]);
+					LogNetMsg(s, player);
 					HandleChatMsg(s, player);
-					LogNetMsg(s, player);
 				}
 				AddTraffic(player, packetCode, dataLength);
 				break;

Modified: trunk/rts/Game/GameHelper.cpp
===================================================================
--- trunk/rts/Game/GameHelper.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Game/GameHelper.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -771,7 +771,7 @@
 	for (std::vector&lt;CUnit*&gt;::iterator ui = units.begin(); ui != units.end(); ++ui) {
 		CUnit* u = *ui;
 
-		if (u != exclude &amp;&amp; !u-&gt;unitDef-&gt;pushResistant) {
+		if (u != exclude &amp;&amp; !u-&gt;unitDef-&gt;pushResistant &amp;&amp; !u-&gt;usingScriptMoveType) {
 			u-&gt;commandAI-&gt;BuggerOff(pos, radius + 8);
 		}
 	}

Modified: trunk/rts/Game/Team.cpp
===================================================================
--- trunk/rts/Game/Team.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Game/Team.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -230,29 +230,26 @@
 {
 	CTeam* target = gs-&gt;Team(toTeam);
 
-	if (target)
-	{
-		if (!luaRules || luaRules-&gt;AllowResourceTransfer(teamNum, toTeam, &quot;m&quot;, metal))
-		{
-			target-&gt;metal += metal;
-			metal = 0;
-		}
-		if (!luaRules || luaRules-&gt;AllowResourceTransfer(teamNum, toTeam, &quot;e&quot;, energy))
-		{
-			target-&gt;energy += energy;
-			energy = 0;
-		}
-		
-		for (CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui)
-		{
-			if ((*ui) &amp;&amp; (!luaRules || luaRules-&gt;AllowUnitTransfer(*ui, toTeam, false))){
-				(*ui)-&gt;ChangeTeam(toTeam, CUnit::ChangeGiven);
-			}
-		}
-		Died();
+	if (!target) {
+		logOutput.Print(&quot;Team %i didn't exists, can't give units&quot;, toTeam);
+		return;
 	}
-	else
-		logOutput.Print(&quot;Team %i didn't exists, can't give units&quot;);
+
+	if (!luaRules || luaRules-&gt;AllowResourceTransfer(teamNum, toTeam, &quot;m&quot;, metal)) {
+		target-&gt;metal += metal;
+		metal = 0;
+	}
+	if (!luaRules || luaRules-&gt;AllowResourceTransfer(teamNum, toTeam, &quot;e&quot;, energy)) {
+		target-&gt;energy += energy;
+		energy = 0;
+	}
+	
+	for (CUnitSet::iterator ui = units.begin(); ui != units.end(); ++ui) {
+		// must pass the normal checks, isDead, unit count restrictions, luaRules, etc...
+		(*ui)-&gt;ChangeTeam(toTeam, CUnit::ChangeGiven);
+	}
+
+	Died();
 }
 
 void CTeam::Died()

Modified: trunk/rts/Game/UI/LuaUI.cpp
===================================================================
--- trunk/rts/Game/UI/LuaUI.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Game/UI/LuaUI.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -1346,29 +1346,32 @@
 
 int CLuaUI::UnsyncedXCall(lua_State* srcState, const string&amp; funcName)
 {
-	const bool diffStates = (srcState != L);
-	const int argCount = lua_gettop(srcState);
-	const int top = lua_gettop(L);
-
-	const LuaHashString cmdStr(funcName);
-	if (!cmdStr.GetGlobalFunc(L)) {
+	const LuaHashString funcHash(funcName);
+	if (!funcHash.GetGlobalFunc(L)) {
 		return 0;
 	}
 
+	const int top = lua_gettop(L) - 1; // do not count the function
+
+	const bool diffStates = (srcState != L);
+
 	int retCount;
+
 	if (!diffStates) {
 		lua_insert(L, 1); // move the function to the beginning
 		// call the function
-		if (!RunCallIn(cmdStr, argCount, LUA_MULTRET)) {
+		if (!RunCallIn(funcHash, top, LUA_MULTRET)) {
 			return 0;
 		}
-		retCount = lua_gettop(L) - top;
+		retCount = lua_gettop(L);
 	}
 	else {
-		LuaUtils::CopyData(L, srcState, argCount);
+		const int srcCount = lua_gettop(srcState);
 
+		LuaUtils::CopyData(L, srcState, srcCount);
+
 		// call the function
-		if (!RunCallIn(cmdStr, argCount, LUA_MULTRET)) {
+		if (!RunCallIn(funcHash, srcCount, LUA_MULTRET)) {
 			return 0;
 		}
 		retCount = lua_gettop(L) - top;

Modified: trunk/rts/Lua/LuaBitOps.cpp
===================================================================
--- trunk/rts/Lua/LuaBitOps.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaBitOps.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -30,15 +30,17 @@
 /******************************************************************************/
 /******************************************************************************/
 
+static inline unsigned int luaL_checkuint(lua_State* L, int index)
+{
+	return (unsigned int)luaL_checkint(L, index);
+}
+
+
 int LuaBitOps::bit_or(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
 	unsigned int result = 0x00000000;
-	for (int i = 1; i &lt;= args; i++) {
-		if (!lua_isnumber(L, i)) {
-			break;
-		}
-		result = result | (unsigned int)lua_tonumber(L, i);
+	for (int i = 1; !lua_isnone(L, i); i++) {
+		result = result | luaL_checkuint(L, i);
 	}
 	lua_pushnumber(L, result &amp; mask);
 	return 1;
@@ -47,16 +49,9 @@
 
 int LuaBitOps::bit_and(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to bit_and()&quot;);
-	}
 	unsigned int result = 0xFFFFFFFF;
-	for (int i = 1; i &lt;= args; i++) {
-		if (!lua_isnumber(L, i)) {
-			break;
-		}
-		result = result &amp; (unsigned int)lua_tonumber(L, i);
+	for (int i = 1; !lua_isnone(L, i); i++) {
+		result = result &amp; luaL_checkuint(L, i);
 	}
 	lua_pushnumber(L, result &amp; mask);
 	return 1;
@@ -65,16 +60,9 @@
 
 int LuaBitOps::bit_xor(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 2) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to bit_xor()&quot;);
-	}
 	unsigned int result = 0x00000000;
-	for (int i = 1; i &lt;= args; i++) {
-		if (!lua_isnumber(L, i)) {
-			break;
-		}
-		result = result ^ (unsigned int)lua_tonumber(L, i);
+	for (int i = 1; !lua_isnone(L, i); i++) {
+		result = result ^ luaL_checkuint(L, i);
 	}
 	lua_pushnumber(L, result &amp; mask);
 	return 1;
@@ -83,25 +71,17 @@
 
 int LuaBitOps::bit_inv(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
-	if ((args != 1) || !lua_isnumber(L, 1)) {
-		luaL_error(L, &quot;Incorrect arguments to bit_inv()&quot;);
-	}
-	const unsigned int b1 = (unsigned int)lua_tonumber(L, 1);
-	lua_pushnumber(L, (~b1) &amp; mask);
+	const unsigned int result = ~luaL_checkuint(L, 1);
+	lua_pushnumber(L, result &amp; mask);
 	return 1;
 }
 
 
 int LuaBitOps::bit_bits(lua_State* L)
 {
-	const int args = lua_gettop(L); // number of arguments
 	unsigned int result = 0x00000000;
-	for (int i = 1; i &lt;= args; i++) {
-		if (!lua_isnumber(L, i)) {
-			break;
-		}
-		const int bit = (unsigned int)lua_tonumber(L, i);
+	for (int i = 1; !lua_isnone(L, i); i++) {
+		const int bit = (unsigned int)luaL_checkint(L, i);
 		result = result | (1 &lt;&lt; bit);
 	}
 	lua_pushnumber(L, result &amp; mask);

Modified: trunk/rts/Lua/LuaHandleSynced.cpp
===================================================================
--- trunk/rts/Lua/LuaHandleSynced.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaHandleSynced.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -817,20 +817,17 @@
 }
 
 
-int CLuaHandleSynced::SyncedXCall(lua_State* srcState, const string&amp; funcName)
+int CLuaHandleSynced::XCall(lua_State* srcState, const string&amp; funcName)
 {
-	const bool diffStates = (srcState != L);
-	const int argCount = lua_gettop(srcState);
-	const int top = lua_gettop(L);
-
-	lua_pushvalue(L, LUA_GLOBALSINDEX);
+	// expecting an environment table
 	if (!lua_istable(L, -1)) {
 		lua_pop(L, 1);
 		return 0;
 	}
 
-	const LuaHashString cmdStr(funcName);
-	cmdStr.Push(L);    // push the function name
+	// push the function
+	const LuaHashString funcHash(funcName);
+	funcHash.Push(L);  // push the function name
 	lua_rawget(L, -2); // get the function
 	if (!lua_isfunction(L, -1)) {
 		lua_pop(L, 2);
@@ -838,88 +835,58 @@
 	}
 	lua_remove(L, -2);
 
+	const int top = lua_gettop(L) - 1; // do not count the function
+
+	const bool diffStates = (srcState != L);
+
 	int retCount;
+
 	if (!diffStates) {
 		lua_insert(L, 1); // move the function to the beginning
 		// call the function
-		if (!RunCallIn(cmdStr, argCount, LUA_MULTRET)) {
+		if (!RunCallIn(funcHash, top, LUA_MULTRET)) {
 			return 0;
 		}
-		retCount = lua_gettop(L) - top;
+		retCount = lua_gettop(L);
 	}
 	else {
-		LuaUtils::CopyData(L, srcState, argCount);
+		const int srcCount = lua_gettop(srcState);
 
+		LuaUtils::CopyData(L, srcState, srcCount);
+
 		// call the function
-		if (!RunCallIn(cmdStr, argCount, LUA_MULTRET)) {
+		if (!RunCallIn(funcHash, srcCount, LUA_MULTRET)) {
 			return 0;
 		}
 		retCount = lua_gettop(L) - top;
 
-		lua_settop(srcState, 0); // FIXME -- lua_checkstack() ?
+		lua_settop(srcState, 0);
 		if (retCount &gt; 0) {
 			LuaUtils::CopyData(srcState, L, retCount);
 		}
+		lua_settop(L, top);
 	}
+
 	return retCount;
 }
 
 
-int CLuaHandleSynced::UnsyncedXCall(lua_State* srcState, const string&amp; funcName)
+int CLuaHandleSynced::SyncedXCall(lua_State* srcState, const string&amp; funcName)
 {
-	const bool diffStates = (srcState != L);
-	const int argCount = lua_gettop(srcState);
-	const int top = lua_gettop(L);
+	lua_pushvalue(L, LUA_GLOBALSINDEX);
+	const int retval = XCall(srcState, funcName);
+	return retval;
+}
 
-	unsyncedStr.GetRegistry(L); // push the UNSYNCED table
-	if (!lua_istable(L, -1)) {
-		lua_pop(L, 1);
-		return 0;
-	}
 
-	const LuaHashString cmdStr(funcName);
-	cmdStr.Push(L);    // push the function name
-	lua_rawget(L, -2); // get the function
-	if (!lua_isfunction(L, -1)) {
-		lua_pop(L, 2);
-		return 0;
-	}
-	lua_remove(L, -2); 
-
+int CLuaHandleSynced::UnsyncedXCall(lua_State* srcState, const string&amp; funcName)
+{
 	const bool prevSynced = synced;
 	synced = false;
-
-	int retCount;
-	if (!diffStates) {
-		lua_insert(L, 1); // move the function to the beginning
-		// call the function
-		if (!RunCallIn(cmdStr, argCount, LUA_MULTRET)) {
-			synced = prevSynced;
-			lua_settop(L, top);
-			return 0;
-		}
-		retCount = lua_gettop(L) - top;
-	}
-	else {
-		LuaUtils::CopyData(L, srcState, argCount);
-
-		// call the function
-		if (!RunCallIn(cmdStr, argCount, LUA_MULTRET)) {
-			synced = prevSynced;
-			lua_settop(L, top);
-			return 0;
-		}
-		retCount = lua_gettop(L) - top;
-
-		lua_settop(srcState, 0); // FIXME ? -- lua_checkstack() ?
-		if (retCount &gt; 0) {
-			LuaUtils::CopyData(srcState, L, retCount);
-		}
-	}
-
+	unsyncedStr.GetRegistry(L); // push the UNSYNCED table
+	const int retval = XCall(srcState, funcName);
 	synced = prevSynced;
-
-	return retCount;
+	return retval;
 }
 
 
@@ -989,7 +956,8 @@
 		luaL_error(L, &quot;Incorrect arguments to SendToUnsynced()&quot;);
 	}
 	for (int i = 1; i &lt;= args; i++) {
-		if (!lua_isnumber(L, i) &amp;&amp;
+		if (!lua_isnil(L, i)    &amp;&amp;
+		    !lua_isnumber(L, i) &amp;&amp;
 		    !lua_isstring(L, i) &amp;&amp;
 		    !lua_isboolean(L, i)) {
 			luaL_error(L, &quot;Incorrect data type for SendToUnsynced(), arg %i&quot;, i);

Modified: trunk/rts/Lua/LuaHandleSynced.h
===================================================================
--- trunk/rts/Lua/LuaHandleSynced.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaHandleSynced.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -39,6 +39,7 @@
 	public: // custom call-in
 		bool HasSyncedXCall(const string&amp; funcName);
 		bool HasUnsyncedXCall(const string&amp; funcName);
+		int XCall(lua_State* srcState, const string&amp; funcName);
 		int SyncedXCall(lua_State* srcState, const string&amp; funcName);
 		int UnsyncedXCall(lua_State* srcState, const string&amp; funcName);
 

Modified: trunk/rts/Lua/LuaHashString.h
===================================================================
--- trunk/rts/Lua/LuaHashString.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaHashString.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -81,7 +81,7 @@
 		}
 		inline void PushString(lua_State* L, const string&amp; value) const {
 			Push(L);
-			lua_pushstring(L, value.c_str());
+			lua_pushlstring(L, value.c_str(), value.size());
 			lua_rawset(L, -3);
 		}
 		inline void PushHashString(lua_State* L, const LuaHashString&amp; hs) const {

Modified: trunk/rts/Lua/LuaOpenGL.cpp
===================================================================
--- trunk/rts/Lua/LuaOpenGL.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaOpenGL.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -33,6 +33,7 @@
 #include &quot;Game/UI/CommandColors.h&quot;
 #include &quot;Game/UI/MiniMap.h&quot;
 #include &quot;Map/ReadMap.h&quot;
+#include &quot;Map/HeightMapTexture.h&quot;
 #include &quot;Rendering/glFont.h&quot;
 #include &quot;Rendering/IconHandler.h&quot;
 #include &quot;Rendering/ShadowHandler.h&quot;
@@ -3025,6 +3026,7 @@
 	// $shadow      --  shadowmap
 	// $specular    --  specular cube map
 	// $reflection  --  reflection cube map
+	// $heightmap   --  ground heightmap
 	// ...          --  named textures
 	//
 
@@ -3124,6 +3126,16 @@
 			glBindTexture(GL_TEXTURE_CUBE_MAP_ARB, unitDrawer-&gt;boxtex);
 			lua_pushboolean(L, true);
 		}
+		else if (texture == &quot;$heightmap&quot;) {
+			const GLuint texID = heightMapTexture.CheckTextureID();
+			if (texID == 0) {
+				lua_pushboolean(L, false);
+			} else {
+				glBindTexture(GL_TEXTURE_2D, texID);
+				glEnable(GL_TEXTURE_2D);
+				lua_pushboolean(L, true);
+			}
+		}
 		else {
 			lua_pushboolean(L, false);
 		}
@@ -3345,6 +3357,15 @@
 			HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, unitDrawer-&gt;specTexSize);
 			HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, unitDrawer-&gt;specTexSize);
 		}
+		else if (texture == &quot;$heightmap&quot;) {
+			if (!heightMapTexture.CheckTextureID()) {
+				return 0;
+			} else {
+				lua_newtable(L);
+				HSTR_PUSH_NUMBER(L, &quot;xsize&quot;, heightMapTexture.GetSizeX());
+				HSTR_PUSH_NUMBER(L, &quot;ysize&quot;, heightMapTexture.GetSizeY());
+			}
+		}
 	}
 	else {
 		const CNamedTextures::TexInfo* texInfo;

Modified: trunk/rts/Lua/LuaRules.cpp
===================================================================
--- trunk/rts/Lua/LuaRules.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaRules.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -109,7 +109,6 @@
 	}
 
 	haveCommandFallback          = HasCallIn(&quot;CommandFallback&quot;);
-	haveBuilderTerraformComplete = HasCallIn(&quot;BuilderTerraformComplete&quot;);
 	haveAllowCommand             = HasCallIn(&quot;AllowCommand&quot;);
 	haveAllowUnitCreation        = HasCallIn(&quot;AllowUnitCreation&quot;);
 	haveAllowUnitTransfer        = HasCallIn(&quot;AllowUnitTransfer&quot;);
@@ -119,6 +118,8 @@
 	haveAllowResourceLevel       = HasCallIn(&quot;AllowResourceLevel&quot;);
 	haveAllowResourceTransfer    = HasCallIn(&quot;AllowResourceTransfer&quot;);
 	haveAllowDirectUnitControl   = HasCallIn(&quot;AllowDirectUnitControl&quot;);
+	haveMoveCtrlNotify           = HasCallIn(&quot;MoveCtrlNotify&quot;);
+	haveBuilderTerraformComplete = HasCallIn(&quot;BuilderTerraformComplete&quot;);
 	haveDrawUnit                 = HasCallIn(&quot;DrawUnit&quot;);
 	haveAICallIn                 = HasCallIn(&quot;AICallIn&quot;);
 
@@ -221,27 +222,29 @@
 bool CLuaRules::SyncedUpdateCallIn(const string&amp; name)
 {
 	if (name == &quot;CommandFallback&quot;) {
-		haveCommandFallback       = HasCallIn(&quot;CommandFallback&quot;);
-	} else if (name == &quot;BuilderTerraformComplete&quot;) {
-		haveBuilderTerraformComplete=HasCallIn(&quot;BuilderTerraformComplete&quot;);
+		haveCommandFallback          = HasCallIn(&quot;CommandFallback&quot;);
 	} else if (name == &quot;AllowCommand&quot;) {
-		haveAllowCommand          = HasCallIn(&quot;AllowCommand&quot;);
+		haveAllowCommand             = HasCallIn(&quot;AllowCommand&quot;);
 	} else if (name == &quot;AllowUnitCreation&quot;) {
-		haveAllowUnitCreation     = HasCallIn(&quot;AllowUnitCreation&quot;);
+		haveAllowUnitCreation        = HasCallIn(&quot;AllowUnitCreation&quot;);
 	} else if (name == &quot;AllowUnitTransfer&quot;) {
-		haveAllowUnitTransfer     = HasCallIn(&quot;AllowUnitTransfer&quot;);
+		haveAllowUnitTransfer        = HasCallIn(&quot;AllowUnitTransfer&quot;);
 	} else if (name == &quot;AllowUnitBuildStep&quot;) {
-		haveAllowUnitBuildStep    = HasCallIn(&quot;AllowUnitBuildStep&quot;);
+		haveAllowUnitBuildStep       = HasCallIn(&quot;AllowUnitBuildStep&quot;);
 	} else if (name == &quot;AllowFeatureCreation&quot;) {
-		haveAllowFeatureCreation  = HasCallIn(&quot;AllowFeatureCreation&quot;);
+		haveAllowFeatureCreation     = HasCallIn(&quot;AllowFeatureCreation&quot;);
 	} else if (name == &quot;AllowFeatureBuildStep&quot;) {
-		haveAllowFeatureBuildStep = HasCallIn(&quot;AllowFeatureBuildStep&quot;);
+		haveAllowFeatureBuildStep    = HasCallIn(&quot;AllowFeatureBuildStep&quot;);
 	} else if (name == &quot;AllowResourceLevel&quot;) {
-		haveAllowResourceLevel    = HasCallIn(&quot;AllowResourceLevel&quot;);
+		haveAllowResourceLevel       = HasCallIn(&quot;AllowResourceLevel&quot;);
 	} else if (name == &quot;AllowResourceTransfer&quot;) {
-		haveAllowResourceTransfer = HasCallIn(&quot;AllowResourceTransfer&quot;);
+		haveAllowResourceTransfer    = HasCallIn(&quot;AllowResourceTransfer&quot;);
 	} else if (name == &quot;AllowDirectUnitControl&quot;) {
-		haveAllowDirectUnitControl = HasCallIn(&quot;AllowDirectUnitControl&quot;);
+		haveAllowDirectUnitControl   = HasCallIn(&quot;AllowDirectUnitControl&quot;);
+	} else if (name == &quot;MoveCtrlNotify&quot;) {
+		haveMoveCtrlNotify           = HasCallIn(&quot;MoveCtrlNotify&quot;);
+	} else if (name == &quot;BuilderTerraformComplete&quot;) {
+		haveBuilderTerraformComplete = HasCallIn(&quot;BuilderTerraformComplete&quot;);
 	} else {
 		return CLuaHandleSynced::SyncedUpdateCallIn(name);
 	}
@@ -319,49 +322,6 @@
 }
 
 
-bool CLuaRules::BuilderTerraformComplete(const CUnit* unit, const CUnit* build)
-{
-	if (!haveBuilderTerraformComplete) {
-		return false; // the call is not defined
-	}
-
-	static const LuaHashString cmdStr(&quot;BuilderTerraformComplete&quot;);
-	if (!cmdStr.GetGlobalFunc(L)) {
-		return false; // the call is not defined
-	}
-
-	// push the unit info
-	lua_pushnumber(L, unit-&gt;id);
-	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
-	lua_pushnumber(L, unit-&gt;team);
-
-	// push the construction info
-	lua_pushnumber(L, build-&gt;id);
-	lua_pushnumber(L, build-&gt;unitDef-&gt;id);
-	lua_pushnumber(L, build-&gt;team);
-
-	// call the function
-	if (!RunCallIn(cmdStr, 6, 1)) {
-		return false;
-	}
-
-	// get the results
-	const int args = lua_gettop(L);
-	if (!lua_isboolean(L, -1)) {
-		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
-		                cmdStr.GetString().c_str(), args);
-		lua_pop(L, 1);
-		return false;
-	}
-
-	const bool retval = !!lua_toboolean(L, -1);
-	lua_pop(L, 1);
-
-	// return 'true' to remove the command
-	return retval;
-}
-
-
 bool CLuaRules::AllowCommand(const CUnit* unit, const Command&amp; cmd, bool fromSynced)
 {
 	if (!haveAllowCommand) {
@@ -719,6 +679,87 @@
 }
 
 
+bool CLuaRules::MoveCtrlNotify(const CUnit* unit, int data)
+{
+	if (!haveMoveCtrlNotify) {
+		return false; // the call is not defined
+	}
+
+	static const LuaHashString cmdStr(&quot;MoveCtrlNotify&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return false; // the call is not defined
+	}
+
+	// push the unit info
+	lua_pushnumber(L, unit-&gt;id);
+	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
+	lua_pushnumber(L, unit-&gt;team);
+	lua_pushnumber(L, data);
+
+	// call the function
+	if (!RunCallIn(cmdStr, 4, 1)) {
+		return false;
+	}
+
+	// get the results
+	const int args = lua_gettop(L);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
+		                cmdStr.GetString().c_str(), args);
+		lua_pop(L, 1);
+		return false;
+	}
+
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+
+	return retval;
+}
+
+
+bool CLuaRules::BuilderTerraformComplete(const CUnit* unit, const CUnit* build)
+{
+	if (!haveBuilderTerraformComplete) {
+		return false; // the call is not defined
+	}
+
+	static const LuaHashString cmdStr(&quot;BuilderTerraformComplete&quot;);
+	if (!cmdStr.GetGlobalFunc(L)) {
+		return false; // the call is not defined
+	}
+
+	// push the unit info
+	lua_pushnumber(L, unit-&gt;id);
+	lua_pushnumber(L, unit-&gt;unitDef-&gt;id);
+	lua_pushnumber(L, unit-&gt;team);
+
+	// push the construction info
+	lua_pushnumber(L, build-&gt;id);
+	lua_pushnumber(L, build-&gt;unitDef-&gt;id);
+	lua_pushnumber(L, build-&gt;team);
+
+	// call the function
+	if (!RunCallIn(cmdStr, 6, 1)) {
+		return false;
+	}
+
+	// get the results
+	const int args = lua_gettop(L);
+	if (!lua_isboolean(L, -1)) {
+		logOutput.Print(&quot;%s() bad return value (%i)\n&quot;,
+		                cmdStr.GetString().c_str(), args);
+		lua_pop(L, 1);
+		return false;
+	}
+
+	const bool retval = !!lua_toboolean(L, -1);
+	lua_pop(L, 1);
+
+	// return 'true' to remove the command
+	return retval;
+}
+
+
 /******************************************************************************/
 
 bool CLuaRules::DrawUnit(int unitID)
@@ -835,6 +876,7 @@
 		logOutput.Print(&quot;CLuaRules::Cob2Lua() lua_checkstack() error: %s\n&quot;,
 		                name.GetString().c_str());
 		args[0] = 0; // failure
+		lua_settop(L, top);
 		return;
 	}
 

Modified: trunk/rts/Lua/LuaRules.h
===================================================================
--- trunk/rts/Lua/LuaRules.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaRules.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -59,6 +59,8 @@
 		                           const string&amp; type, float amount);
 		bool AllowDirectUnitControl(int playerID, const CUnit* unit);
 
+		bool MoveCtrlNotify(const CUnit* unit, int data);
+
 		void Cob2Lua(const LuaHashString&amp; funcName, const CUnit* unit,
 		             int&amp; argsCount, int args[MAX_LUA_COB_ARGS]);
 
@@ -104,7 +106,6 @@
 
 	private:
 		bool haveCommandFallback;
-		bool haveBuilderTerraformComplete;
 		bool haveAllowCommand;
 		bool haveAllowUnitCreation;
 		bool haveAllowUnitTransfer;
@@ -114,6 +115,8 @@
 		bool haveAllowResourceLevel;
 		bool haveAllowResourceTransfer;
 		bool haveAllowDirectUnitControl;
+		bool haveMoveCtrlNotify;
+		bool haveBuilderTerraformComplete;
 		bool haveDrawUnit;
 		bool haveAICallIn;
 

Modified: trunk/rts/Lua/LuaSyncedCall.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedCall.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaSyncedCall.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -28,7 +28,7 @@
 	const int addrIndex = lua_upvalueindex(1);
 	const int nameIndex = lua_upvalueindex(2);
 
-	if (!lua_isuserdata(L, addrIndex) || !lua_isstring(L, nameIndex)) {
+	if (!lua_isuserdata(L, addrIndex) || !lua_israwstring(L, nameIndex)) {
 		luaL_error(L, &quot;Bad function name type&quot;);
 	}
 
@@ -47,7 +47,7 @@
 static int IndexHook(lua_State* L)
 {
 	CLuaHandle** addr = (CLuaHandle**) lua_touserdata(L, lua_upvalueindex(1));
-	if (!lua_isstring(L, 2)) {
+	if (!lua_israwstring(L, 2)) {
 		return 0; // missing string name for function
 	}
 	lua_pushlightuserdata(L, addr);
@@ -66,7 +66,7 @@
 		lua_pushboolean(L, (*addr != NULL));
 		return 1;
 	}
-	else if ((args &gt;= 2) &amp;&amp; lua_isstring(L, 2)) {
+	else if ((args &gt;= 2) &amp;&amp; lua_israwstring(L, 2)) {
 		// see if the specified function exists
 		const string funcName = lua_tostring(L, 2);
 		CLuaHandle* lh = *addr;

Modified: trunk/rts/Lua/LuaSyncedMoveCtrl.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedMoveCtrl.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaSyncedMoveCtrl.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -61,6 +61,7 @@
 	REGISTER_LUA_CFUNC(SetTrackGround);
 	REGISTER_LUA_CFUNC(SetGroundOffset);
 	REGISTER_LUA_CFUNC(SetGravity);
+	REGISTER_LUA_CFUNC(SetDrag);
 
 	REGISTER_LUA_CFUNC(SetWindFactor);
 
@@ -443,6 +444,17 @@
 }
 
 
+int LuaSyncedMoveCtrl::SetDrag(lua_State* L)
+{
+	CScriptMoveType* moveType = ParseMoveType(L, __FUNCTION__, 1);
+	if (moveType == NULL) {
+		return 0;
+	}
+	moveType-&gt;drag = (float)luaL_checknumber(L, 2);
+	return 0;
+}
+
+
 int LuaSyncedMoveCtrl::SetWindFactor(lua_State* L)
 {
 	CScriptMoveType* moveType = ParseMoveType(L, __FUNCTION__, 1);

Modified: trunk/rts/Lua/LuaSyncedMoveCtrl.h
===================================================================
--- trunk/rts/Lua/LuaSyncedMoveCtrl.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaSyncedMoveCtrl.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -42,6 +42,7 @@
 		static int SetTrackGround(lua_State* L);
 		static int SetGroundOffset(lua_State* L);
 		static int SetGravity(lua_State* L);
+		static int SetDrag(lua_State* L);
 
 		static int SetWindFactor(lua_State* L);
 

Modified: trunk/rts/Lua/LuaSyncedRead.cpp
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaSyncedRead.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -238,6 +238,9 @@
 	REGISTER_LUA_CFUNC(TestBuildOrder);
 	REGISTER_LUA_CFUNC(Pos2BuildPos);
 	REGISTER_LUA_CFUNC(GetPositionLosState);
+	REGISTER_LUA_CFUNC(IsPosInLos);
+	REGISTER_LUA_CFUNC(IsPosInRadar);
+	REGISTER_LUA_CFUNC(IsPosInAirLos);
 	REGISTER_LUA_CFUNC(GetClosestValidPosition);
 
 	REGISTER_LUA_CFUNC(GetUnitPieceMap);
@@ -3815,65 +3818,146 @@
 /******************************************************************************/
 /******************************************************************************/
 
-int LuaSyncedRead::GetPositionLosState(lua_State* L)
+static int GetEffectiveLosAllyTeam(lua_State* L, int arg)
 {
-	if (!fullRead &amp;&amp; (readAllyTeam &lt; 0)) {
-		return 0;
+	if (lua_isnoneornil(L, arg)) {
+		return readAllyTeam;
 	}
+	const bool isGaia = (readAllyTeam == gs-&gt;gaiaAllyTeamID);
+	if (fullRead || isGaia) {
+		const int at = luaL_checkint(L, arg);
+		if (at &gt;= gs-&gt;activeAllyTeams) {
+			luaL_error(L, &quot;Invalid allyTeam&quot;);
+		}
+		if (isGaia &amp;&amp; (at &gt;= 0) &amp;&amp; (at != gs-&gt;gaiaAllyTeamID)) {
+			luaL_error(L, &quot;Invalid gaia access&quot;);
+		}
+		return at;
+	}
+	else if (readAllyTeam &lt; 0) {
+		luaL_error(L, &quot;Invalid access&quot;);
+	}
+	return readAllyTeam;
+}
 
-	const int args = lua_gettop(L); // number of arguments
-	if ((args &lt; 3) ||
-	    !lua_isnumber(L, 1) || !lua_isnumber(L, 2) || !lua_isnumber(L, 3)) {
-		luaL_error(L, &quot;Incorrect arguments to GetPositionLosState()&quot;);
+
+int LuaSyncedRead::GetPositionLosState(lua_State* L)
+{
+	const float3 pos((float)luaL_checknumber(L, 1),
+	                 (float)luaL_checknumber(L, 2),
+	                 (float)luaL_checknumber(L, 3));
+
+	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
+
+	bool inLos    = false;
+	bool inRadar  = false;
+
+	if (allyTeamID &gt;= 0) {
+		inLos   = loshandler-&gt;InLos(pos, allyTeamID);
+		inRadar = radarhandler-&gt;InRadar(pos, allyTeamID);
 	}
-	const float3 pos((float)lua_tonumber(L, 1),
-	                 (float)lua_tonumber(L, 2),
-	                 (float)lua_tonumber(L, 3));
-
-	int allyTeamID = readAllyTeam;
-	if (args == 3) {
-		if (fullRead) {
-			allyTeamID = -1; // -1 =&gt; check all allyTeams
+	else {
+		for (int at = 0; at &lt; gs-&gt;activeAllyTeams; at++) {
+			if (loshandler-&gt;InLos(pos, at)) {
+				inLos = true;
+				break;
+			}
 		}
+		for (int at = 0; at &lt; gs-&gt;activeAllyTeams; at++) {
+			if (radarhandler-&gt;InRadar(pos, at)) {
+				inRadar = true;
+				break;
+			}
+		}
 	}
-	else if (lua_isnumber(L, 4)) {
-		// special case for LuaGaia
-		if (fullRead || (readAllyTeam == gs-&gt;gaiaAllyTeamID)) {
-			allyTeamID = (int)lua_tonumber(L, 4);
-			if (allyTeamID &gt;= gs-&gt;activeAllyTeams) {
-				luaL_error(L, &quot;Bad allyTeamID in GetPositionLosState()&quot;);
+	lua_pushboolean(L, inLos || inRadar);
+	lua_pushboolean(L, inLos);
+	lua_pushboolean(L, inRadar);
+
+	return 3;
+}
+
+
+int LuaSyncedRead::IsPosInLos(lua_State* L)
+{
+	const float3 pos((float)luaL_checknumber(L, 1),
+	                 (float)luaL_checknumber(L, 2),
+	                 (float)luaL_checknumber(L, 3));
+
+	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
+
+	bool state = false;
+	if (allyTeamID &gt;= 0) {
+		state = loshandler-&gt;InLos(pos, allyTeamID);
+	}
+	else {
+		for (int at = 0; at &lt; gs-&gt;activeAllyTeams; at++) {
+			if (loshandler-&gt;InLos(pos, at)) {
+				state = true;
+				break;
 			}
 		}
 	}
+	lua_pushboolean(L, state);
+
+	return 1;
+}
+
+
+int LuaSyncedRead::IsPosInRadar(lua_State* L)
+{
+	const float3 pos((float)luaL_checknumber(L, 1),
+	                 (float)luaL_checknumber(L, 2),
+	                 (float)luaL_checknumber(L, 3));
+
+	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
+
+	bool state = false;
+	if (allyTeamID &gt;= 0) {
+		state = radarhandler-&gt;InRadar(pos, allyTeamID);
+	}
 	else {
-		luaL_error(L, &quot;Incorrect arguments to GetPositionLosState()&quot;);
+		for (int at = 0; at &lt; gs-&gt;activeAllyTeams; at++) {
+			if (radarhandler-&gt;InRadar(pos, at)) {
+				state = true;
+				break;
+			}
+		}
 	}
+	lua_pushboolean(L, state);
 
-	// send the values
-	bool inLos    = false;
-	bool inAirLos = false;
-	bool radar    = false;
+	return 1;
+}
+
+
+int LuaSyncedRead::IsPosInAirLos(lua_State* L)
+{
+	const float3 pos((float)luaL_checknumber(L, 1),
+	                 (float)luaL_checknumber(L, 2),
+	                 (float)luaL_checknumber(L, 3));
+
+	const int allyTeamID = GetEffectiveLosAllyTeam(L, 4);
+
+	bool state = false;
 	if (allyTeamID &gt;= 0) {
-		inLos    = loshandler-&gt;InLos(pos, allyTeamID);
-		inAirLos = loshandler-&gt;InAirLos(pos, allyTeamID);
-		radar    = radarhandler-&gt;InRadar(pos, allyTeamID);
+		state = loshandler-&gt;InAirLos(pos, allyTeamID);
 	}
 	else {
 		for (int at = 0; at &lt; gs-&gt;activeAllyTeams; at++) {
-			inLos    = inLos    || loshandler-&gt;InLos(pos, at);
-			inAirLos = inAirLos || loshandler-&gt;InAirLos(pos, at);
-			radar    = radar    || radarhandler-&gt;InRadar(pos, at);
+			if (loshandler-&gt;InAirLos(pos, at)) {
+				state = true;
+				break;
+			}
 		}
 	}
-	lua_pushboolean(L, inLos || radar);
-	lua_pushboolean(L, inLos);
-	lua_pushboolean(L, inAirLos);
-	lua_pushboolean(L, radar);
+	lua_pushboolean(L, state);
 
-	return 4;
+	return 1;
 }
 
 
+/******************************************************************************/
+
 int LuaSyncedRead::GetClosestValidPosition(lua_State* L)
 {
 	// FIXME -- finish this
@@ -3922,9 +4006,7 @@
 		lua_pushstring(L, lp.name.c_str());
 		lua_rawset(L, -3);
 	}
-	lua_pushstring(L, &quot;n&quot;);
-	lua_pushnumber(L, localModel-&gt;numpieces);
-	lua_rawset(L, -3);
+	HSTR_PUSH_NUMBER(L, &quot;n&quot;, localModel-&gt;numpieces);
 	return 1;
 }
 
@@ -3957,10 +4039,8 @@
 				lua_pushstring(L, op.childs[c]-&gt;name.c_str());
 				lua_rawset(L, -3);
 			}
-			lua_pushstring(L, &quot;n&quot;);
-			lua_pushnumber(L, op.childs.size());
+			HSTR_PUSH_NUMBER(L, &quot;n&quot;, op.childs.size());
 			lua_rawset(L, -3);
-			lua_rawset(L, -3);
 
 			HSTR_PUSH(L, &quot;isEmpty&quot;);
 			lua_pushboolean(L, op.isEmpty);
@@ -4004,10 +4084,8 @@
 				lua_pushstring(L, op.childs[c]-&gt;name.c_str());
 				lua_rawset(L, -3);
 			}
-			lua_pushstring(L, &quot;n&quot;);
-			lua_pushnumber(L, op.childs.size());
+			HSTR_PUSH_NUMBER(L, &quot;n&quot;, op.childs.size());
 			lua_rawset(L, -3);
-			lua_rawset(L, -3);
 
 			HSTR_PUSH(L, &quot;isEmpty&quot;);
 			lua_pushboolean(L, op.isEmpty);

Modified: trunk/rts/Lua/LuaSyncedRead.h
===================================================================
--- trunk/rts/Lua/LuaSyncedRead.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaSyncedRead.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -158,6 +158,9 @@
 		static int Pos2BuildPos(lua_State* L);
 
 		static int GetPositionLosState(lua_State* L);
+		static int IsPosInLos(lua_State* L);
+		static int IsPosInRadar(lua_State* L);
+		static int IsPosInAirLos(lua_State* L);
 		static int GetClosestValidPosition(lua_State* L);
 
 		static int GetUnitPieceMap(lua_State* L);

Modified: trunk/rts/Lua/LuaUnsyncedCall.cpp
===================================================================
--- trunk/rts/Lua/LuaUnsyncedCall.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaUnsyncedCall.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -28,7 +28,7 @@
 	const int addrIndex = lua_upvalueindex(1);
 	const int nameIndex = lua_upvalueindex(2);
 
-	if (!lua_isuserdata(L, addrIndex) || !lua_isstring(L, nameIndex)) {
+	if (!lua_isuserdata(L, addrIndex) || !lua_israwstring(L, nameIndex)) {
 		luaL_error(L, &quot;Bad function name type&quot;);
 	}
 
@@ -47,7 +47,7 @@
 static int IndexHook(lua_State* L)
 {
 	CLuaHandle** addr = (CLuaHandle**) lua_touserdata(L, lua_upvalueindex(1));
-	if (!lua_isstring(L, 2)) {
+	if (!lua_israwstring(L, 2)) {
 		return 0; // missing string name for function
 	}
 	lua_pushlightuserdata(L, addr);
@@ -66,7 +66,7 @@
 		lua_pushboolean(L, (*addr != NULL));
 		return 1;
 	}
-	else if ((args &gt;= 2) &amp;&amp; lua_isstring(L, 2)) {
+	else if ((args &gt;= 2) &amp;&amp; lua_israwstring(L, 2)) {
 		// see if the specified function exists
 		const string funcName = lua_tostring(L, 2);
 		CLuaHandle* lh = *addr;

Modified: trunk/rts/Lua/LuaUtils.cpp
===================================================================
--- trunk/rts/Lua/LuaUtils.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaUtils.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -10,8 +10,8 @@
 #include &quot;LuaInclude.h&quot;
 
 
-static int depth = 0;
-static int maxDepth = 256;
+static       int depth = 0;
+static const int maxDepth = 256;
 
 
 /******************************************************************************/
@@ -78,9 +78,11 @@
 int LuaUtils::CopyData(lua_State* dst, lua_State* src, int count)
 {
 	const int srcTop = lua_gettop(src);
+	const int dstTop = lua_gettop(dst);
 	if (srcTop &lt; count) {
 		return 0;
 	}
+	lua_checkstack(dst, dstTop + count); // FIXME: not enough for table chains
 
 	depth = 0;
 
@@ -89,6 +91,7 @@
 	for (int i = startIndex; i &lt;= endIndex; i++) {
 		CopyPushData(dst, src, i);
 	}
+	lua_settop(dst, dstTop + count);
 
 	return count;
 }
@@ -161,3 +164,25 @@
 
 /******************************************************************************/
 /******************************************************************************/
+
+void LuaUtils::PrintStack(lua_State* L)
+{
+	const int top = lua_gettop(L);
+	for (int i = 1; i &lt;= top; i++) {
+		printf(&quot;  %i: type = %s (%p)&quot;, i, luaL_typename(L, i), lua_topointer(L, i));
+		const int type = lua_type(L, i);
+		if (type == LUA_TSTRING) {
+			printf(&quot;\t\t%s\n&quot;, lua_tostring(L, i));
+		} else if (type == LUA_TNUMBER) {
+			printf(&quot;\t\t%f\n&quot;, lua_tonumber(L, i));
+		} else if (type == LUA_TBOOLEAN) {
+			printf(&quot;\t\t%s\n&quot;, lua_toboolean(L, i) ? &quot;true&quot; : &quot;false&quot;);
+		} else {
+			printf(&quot;\n&quot;);
+		}
+	}
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Modified: trunk/rts/Lua/LuaUtils.h
===================================================================
--- trunk/rts/Lua/LuaUtils.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Lua/LuaUtils.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -35,6 +35,8 @@
 		                             vector&lt;string&gt;&amp; vec);
 
 		static void* GetUserData(lua_State* L, int index, const string&amp; type);
+
+		static void PrintStack(lua_State* L);
 };
 
 

Modified: trunk/rts/Map/BasicMapDamage.cpp
===================================================================
--- trunk/rts/Map/BasicMapDamage.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Map/BasicMapDamage.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -2,6 +2,7 @@
 #include &quot;BasicMapDamage.h&quot;
 #include &quot;ReadMap.h&quot;
 #include &quot;BaseGroundDrawer.h&quot;
+#include &quot;HeightMapTexture.h&quot;
 #include &quot;Rendering/Env/BaseTreeDrawer.h&quot;
 #include &quot;TimeProfiler.h&quot;
 #include &quot;Sim/Misc/QuadField.h&quot;
@@ -232,8 +233,10 @@
 			relosQue.push_back(rs);
 		}
 	}
+	heightMapTexture.UpdateArea(x1, y1, x2, y2);
 }
 
+
 void CBasicMapDamage::Update(void)
 {
 	SCOPED_TIMER(&quot;Map damage&quot;);

Added: trunk/rts/Map/HeightMapTexture.cpp
===================================================================
--- trunk/rts/Map/HeightMapTexture.cpp	                        (rev 0)
+++ trunk/rts/Map/HeightMapTexture.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -0,0 +1,102 @@
+#include &quot;StdAfx.h&quot;
+// HeightMapTexture.cpp: implementation of the HeightMapTexture class.
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;HeightMapTexture.h&quot;
+
+#include &quot;Map/ReadMap.h&quot;
+#include &quot;Rendering/GL/myGL.h&quot;
+#include &quot;System/Platform/ConfigHandler.h&quot;
+
+/******************************************************************************/
+/******************************************************************************/
+
+
+HeightMapTexture heightMapTexture;
+
+
+HeightMapTexture::HeightMapTexture()
+{
+	init = false;
+
+	texID = 0;
+
+	xSize = 0;
+	ySize = 0;
+}
+
+
+HeightMapTexture::~HeightMapTexture()
+{
+}
+
+
+void HeightMapTexture::Init()
+{
+	if (init || (readmap == NULL)) {
+		return;
+	}
+	init = true;
+
+	if (!configHandler.GetInt(&quot;HeightMapTexture&quot;, 1)) {
+		return;
+	}
+
+	if (!GLEW_ARB_texture_float ||
+	    !GLEW_ARB_texture_non_power_of_two) {
+		return;
+	}
+
+	xSize = (gs-&gt;mapx + 1);
+	ySize = (gs-&gt;mapy + 1);
+	
+	glGenTextures(1, &amp;texID);
+	glBindTexture(GL_TEXTURE_2D, texID);
+
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+	const float* heightMap = readmap-&gt;GetHeightmap();
+
+	glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE32F_ARB,
+	             xSize, ySize, 0,
+	             GL_LUMINANCE, GL_FLOAT, heightMap);
+
+	glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+
+void HeightMapTexture::Kill()
+{
+	glDeleteTextures(1, &amp;texID);
+	texID = 0;
+	xSize = 0;
+	ySize = 0;
+}
+
+
+void HeightMapTexture::UpdateArea(int x0, int z0, int x1, int z1)
+{
+	if (texID == 0) {
+		return;
+	}
+	const float* heightMap = readmap-&gt;GetHeightmap();
+	glBindTexture(GL_TEXTURE_2D, texID);
+
+	for (int z = z0; z &lt;= z1; z++) {
+		glTexSubImage2D(GL_TEXTURE_2D, 0,
+										x0, z, (x1 - x0 + 1), 1,
+										GL_LUMINANCE, GL_FLOAT, heightMap + (x0 + (z * xSize)));
+	}
+	
+
+	glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+
+/******************************************************************************/
+/******************************************************************************/

Added: trunk/rts/Map/HeightMapTexture.h
===================================================================
--- trunk/rts/Map/HeightMapTexture.h	                        (rev 0)
+++ trunk/rts/Map/HeightMapTexture.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -0,0 +1,47 @@
+#ifndef HEIGHT_MAP_TEXTURE_H
+#define HEIGHT_MAP_TEXTURE_H
+// HeightMapTexture.h
+//
+//////////////////////////////////////////////////////////////////////
+
+#include &quot;Rendering/GL/myGL.h&quot;
+
+class HeightMapTexture {
+	public:
+		HeightMapTexture();
+		~HeightMapTexture();
+
+		void Init();
+		void Kill();
+
+		void UpdateArea(int x0, int z0, int x1, int z1);
+		GLuint GetTextureID() const { return texID; }
+		inline GLuint CheckTextureID()
+		{
+			if (texID != 0) {
+				return texID;
+			}
+			else {
+				if (init) {
+					return 0;
+				} else {
+					Init();
+					return texID;
+				}
+			}
+		}
+
+		int GetSizeX() const { return xSize; }
+		int GetSizeY() const { return ySize; }
+
+	private:
+		bool init;
+		GLuint texID;
+		int xSize;
+		int ySize;
+};
+
+extern HeightMapTexture heightMapTexture;
+
+#endif // HEIGHTMAP_TEXTURE_H
+

Modified: trunk/rts/Rendering/FartextureHandler.cpp
===================================================================
--- trunk/rts/Rendering/FartextureHandler.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Rendering/FartextureHandler.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -111,7 +111,6 @@
 	for(int a=0;a&lt;8;++a){
 		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 		texturehandler-&gt;SetTATexture();
-		//glCallList(model.displist);
 		glPushMatrix();
 		glTranslatef(0,-model-&gt;height*0.5f,0);
 		model-&gt;DrawStatic();

Modified: trunk/rts/Rendering/FartextureHandler.h
===================================================================
--- trunk/rts/Rendering/FartextureHandler.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Rendering/FartextureHandler.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -12,16 +12,16 @@
 class CFartextureHandler
 {
 public:
-	GLuint farTexture;
-
 	CFartextureHandler(void);
 	~CFartextureHandler(void);
 	void CreateFarTexture(S3DOModel* model);
 	void CreateFarTextures();
+	GLuint GetTextureID() const { return farTexture; }
 
 private:
 	void ReallyCreateFarTexture(S3DOModel* model);
 
+	GLuint farTexture;
 	unsigned char* farTextureMem;
 	int usedFarTextures;
 	std::vector&lt;S3DOModel*&gt; pending;

Modified: trunk/rts/Rendering/UnitModels/UnitDrawer.cpp
===================================================================
--- trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Rendering/UnitModels/UnitDrawer.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -269,7 +269,7 @@
 	drawCloakedS3O.clear();
 
 	glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
-	glFogfv(GL_FOG_COLOR,FogLand);
+	glFogfv(GL_FOG_COLOR, FogLand);
 
 	vector&lt;CUnit*&gt; drawIcon;
 	vector&lt;CUnit*&gt; drawRadarIcon;
@@ -398,7 +398,7 @@
 	va-&gt;Initialize();
 	glAlphaFunc(GL_GREATER, 0.8f);
 	glEnable(GL_ALPHA_TEST);
-	glBindTexture(GL_TEXTURE_2D, fartextureHandler-&gt;farTexture);
+	glBindTexture(GL_TEXTURE_2D, fartextureHandler-&gt;GetTextureID());
 	camNorm = camera-&gt;forward;
 	camNorm.y = -0.1f;
 	camNorm.Normalize();
@@ -1446,6 +1446,7 @@
 	glLoadIdentity();
 	gluPerspective(90, 1, NEAR_PLANE, gu-&gt;viewRange);
 	glMatrixMode(GL_MODELVIEW);
+	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
 
 	sky-&gt;Draw();

Modified: trunk/rts/Sim/Misc/FeatureHandler.cpp
===================================================================
--- trunk/rts/Sim/Misc/FeatureHandler.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/Misc/FeatureHandler.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -24,6 +24,7 @@
 #include &quot;Sim/Units/UnitHandler.h&quot;
 #include &quot;Sim/Units/CommandAI/BuilderCAI.h&quot;
 #include &quot;System/TimeProfiler.h&quot;
+#include &quot;System/Platform/ConfigHandler.h&quot;
 #include &lt;GL/glu.h&gt; // after myGL.h
 #include &quot;mmgr.h&quot;
 #include &quot;creg/STL_List.h&quot;
@@ -530,10 +531,10 @@
 
 	CVertexArray* va=GetVertexArray();
 	va-&gt;Initialize();
-	glAlphaFunc(GL_GREATER,0.8f);
+	glAlphaFunc(GL_GREATER, 0.8f);
 	glEnable(GL_ALPHA_TEST);
-	glBindTexture(GL_TEXTURE_2D,fartextureHandler-&gt;farTexture);
-	glColor3f(1,1,1);
+	glBindTexture(GL_TEXTURE_2D, fartextureHandler-&gt;GetTextureID());
+	glColor3f(1.0f, 1.0f, 1.0f);
 	glEnable(GL_FOG);
 	for(vector&lt;CFeature*&gt;::iterator usi=drawFar.begin();usi!=drawFar.end();usi++){
 		DrawFar(*usi,va);
@@ -622,9 +623,9 @@
 void CFeatureHandler::DrawRaw(int extraSize, std::vector&lt;CFeature*&gt;* farFeatures)
 {
 	float featureDist=3000;
-	if(!extraSize)
-		featureDist=6000;		//farfeatures wont be drawn for shadowpass anyway
-
+	if (!extraSize) {
+		featureDist=6000; //farfeatures wont be drawn for shadowpass anyway
+	}
 	CFeatureDrawer drawer;
 	drawer.drawQuads = &drawQuads;
 	drawer.fh = this;
@@ -634,7 +635,7 @@
 	drawer.unitDrawDist=unitDrawer-&gt;unitDrawDist;
 	drawer.farFeatures = farFeatures;
 
-	readmap-&gt;GridVisibility (camera, DRAW_QUAD_SIZE, featureDist, &amp;drawer, extraSize);
+	readmap-&gt;GridVisibility(camera, DRAW_QUAD_SIZE, featureDist, &amp;drawer, extraSize);
 }
 
 

Modified: trunk/rts/Sim/Misc/FeatureHandler.h
===================================================================
--- trunk/rts/Sim/Misc/FeatureHandler.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/Misc/FeatureHandler.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -77,6 +77,8 @@
 	int drawQuadsX;
 	int drawQuadsY;
 
+	float farDist;
+
 	void DrawFar(CFeature* feature, CVertexArray* va);
 
 	void Serialize(creg::ISerializer *s);

Modified: trunk/rts/Sim/MoveTypes/GroundMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/MoveTypes/GroundMoveType.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -1416,7 +1416,7 @@
 				// safe cast (only units can be mobile)
 				CUnit* u = (CUnit*) c;
 
-				if (!u-&gt;unitDef-&gt;pushResistant) {
+				if (!u-&gt;unitDef-&gt;pushResistant &amp;&amp; !u-&gt;usingScriptMoveType) {
 					// push the blocking unit out of the way
 					// FIXME CAN PLACE OTHER PARTY IN BUILDING
 					u-&gt;pos += dif * (part);
@@ -1478,7 +1478,7 @@
 				// safe cast (only units can be mobile)
 				CUnit* u = (CUnit*) c;
 
-				if (!u-&gt;unitDef-&gt;pushResistant) {
+				if (!u-&gt;unitDef-&gt;pushResistant &amp;&amp; !u-&gt;usingScriptMoveType) {
 					// push the blocking unit out of the way
 					// FIXME CAN PLACE OTHER PARTY IN BUILDING
 					c-&gt;pos += dif * (part);

Modified: trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp
===================================================================
--- trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/MoveTypes/ScriptMoveType.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -1,6 +1,7 @@
 
 #include &quot;StdAfx.h&quot;
 #include &quot;ScriptMoveType.h&quot;
+#include &quot;Lua/LuaRules.h&quot;
 #include &quot;Map/Ground.h&quot;
 #include &quot;Rendering/GroundDecalHandler.h&quot;
 #include &quot;Sim/Misc/Wind.h&quot;
@@ -19,6 +20,7 @@
 CR_REG_METADATA(CScriptMoveType, (
 	CR_MEMBER(tag),
 	CR_MEMBER(extrapolate),
+	CR_MEMBER(drag),
 	CR_MEMBER(vel),
 	CR_MEMBER(relVel),
 	CR_MEMBER(useRelVel),
@@ -46,6 +48,7 @@
 	CR_MEMBER(lastTrackUpdate),
 	CR_MEMBER(oldPos),
 	CR_MEMBER(oldSlowUpdatePos),
+	CR_MEMBER(scriptNotify),
 	CR_RESERVED(64)
 	));
 
@@ -54,6 +57,7 @@
 : CMoveType(owner),
 	tag(0),
   extrapolate(true),
+	drag(0.0f),
   vel(0.0f, 0.0f, 0.0f),
   relVel(0.0f, 0.0f, 0.0f),
   useRelVel(false),
@@ -78,7 +82,8 @@
   maxs(+1.0e9f, +1.0e9f, +1.0e9f),
   lastTrackUpdate(0),
 	oldPos(owner ? owner-&gt;pos:float3(0,0,0)),
-	oldSlowUpdatePos(oldPos)
+	oldSlowUpdatePos(oldPos),
+	scriptNotify(0)
 {
 	useHeading = false; // use the transformation matrix instead of heading
 
@@ -115,11 +120,11 @@
 inline void CScriptMoveType::CalcDirections()
 {
 	CMatrix44f matrix;
-	matrix.Translate(-rotOffset); // this doesn't work, Rotate is not a full rotate
+	//matrix.Translate(-rotOffset);
 	matrix.RotateY(-rot.y);
 	matrix.RotateX(-rot.x);
 	matrix.RotateZ(-rot.z);
-	matrix.Translate(rotOffset);
+	//matrix.Translate(rotOffset);
 	owner-&gt;rightdir.x = -matrix[ 0];
 	owner-&gt;rightdir.y = -matrix[ 1];
 	owner-&gt;rightdir.z = -matrix[ 2];
@@ -161,6 +166,17 @@
 };
 
 
+void CScriptMoveType::CheckNotify()
+{
+	if (scriptNotify) {
+		if (luaRules &amp;&amp; luaRules-&gt;MoveCtrlNotify(owner, scriptNotify)) {
+			owner-&gt;DisableScriptMoveType();
+		}
+		scriptNotify = 0;
+	}
+}
+
+
 void CScriptMoveType::Update()
 {
 	if (useRotVel) {
@@ -170,6 +186,9 @@
 
 	owner-&gt;speed = vel;
 	if (extrapolate) {
+		if (drag != 0.0f) {
+			vel *= (1.0f - drag); // quadratic drag does not work well here
+		}
 		if (useRelVel) {
 			const float3 rVel = (owner-&gt;frontdir *  relVel.z) +
 			                    (owner-&gt;updir    *  relVel.y) +
@@ -192,6 +211,7 @@
 				vel    = ZeroVector;
 				relVel = ZeroVector;
 				rotVel = ZeroVector;
+				scriptNotify = 1;
 			}
 		}
 	}
@@ -207,8 +227,10 @@
 
 	// don't need the rest if the pos hasn't changed
 	if (oldPos == owner-&gt;pos) {
+		CheckNotify();
 		return;
 	}
+
 	oldPos = owner-&gt;pos;
 
 	if (isBlocking &amp;&amp; !noBlocking) {
@@ -222,6 +244,8 @@
 		lastTrackUpdate = gs-&gt;frameNum;
 		groundDecals-&gt;UnitMoved(owner);
 	}
+
+	CheckNotify();
 };
 
 

Modified: trunk/rts/Sim/MoveTypes/ScriptMoveType.h
===================================================================
--- trunk/rts/Sim/MoveTypes/ScriptMoveType.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/MoveTypes/ScriptMoveType.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -46,12 +46,15 @@
 		void CalcDirections();
 		void TrackSlope();
 		void CheckLimits();
+		void CheckNotify();
 
 	public:
 		int tag;
-
+		
 		bool extrapolate;
 
+		float drag;
+
 		float3 vel;     // velocity
 		float3 relVel;  // relative velocity (to current direction)
 		bool useRelVel;
@@ -89,6 +92,8 @@
 		int lastTrackUpdate;
 		float3 oldPos;
 		float3 oldSlowUpdatePos;
+
+		int scriptNotify;
 };
 
 

Modified: trunk/rts/Sim/Units/Unit.cpp
===================================================================
--- trunk/rts/Sim/Units/Unit.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/Units/Unit.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -229,7 +229,7 @@
 	cegDamage(1)
 {
 #ifdef DIRECT_CONTROL_ALLOWED
-	directControl = 0;
+	directControl = NULL;
 #endif
 	activated = false;
 }
@@ -250,9 +250,9 @@
 #endif
 
 #ifdef DIRECT_CONTROL_ALLOWED
-	if(directControl){
+	if (directControl) {
 		directControl-&gt;myController-&gt;StopControllingUnit();
-		directControl=0;
+		directControl = NULL;
 	}
 #endif
 
@@ -265,13 +265,14 @@
 	SetEnergyStorage(0);
 //	}
 
-	delete commandAI; commandAI = 0;
-	delete moveType; moveType = 0;
-	delete prevMoveType; prevMoveType = 0;
+	delete commandAI;     commandAI    = NULL;
+	delete moveType;      moveType     = NULL;
+	delete prevMoveType;  prevMoveType = NULL;
 
-	if(group)
+	if (group) {
 		group-&gt;RemoveUnit(this);
-	group=0;
+	}
+	group = NULL;
 
 	std::vector&lt;CWeapon*&gt;::iterator wi;
 	for(wi=weapons.begin();wi!=weapons.end();++wi)
@@ -1188,7 +1189,8 @@
 		interPos = pos + (transporter-&gt;speed * gu-&gt;timeOffset);
 	}
 
-	if (!beingBuilt &amp;&amp; (usingScriptMoveType || ((physicalState == Flying) &amp;&amp; unitDef-&gt;canmove))) {
+	if (usingScriptMoveType ||
+	    (!beingBuilt &amp;&amp; (physicalState == Flying) &amp;&amp; unitDef-&gt;canmove)) {
 		// aircraft, skidding ground unit, or active ScriptMoveType
 		// note: (CAirMoveType) aircraft under construction should not
 		// use this matrix, or their nanoframes won't spin on pad
@@ -1409,9 +1411,9 @@
 
 #ifdef DIRECT_CONTROL_ALLOWED
 	// do not allow old player to keep controlling the unit
-	if(directControl){
+	if (directControl) {
 		directControl-&gt;myController-&gt;StopControllingUnit();
-		directControl=0;
+		directControl = NULL;
 	}
 #endif
 

Modified: trunk/rts/Sim/Units/UnitDefHandler.cpp
===================================================================
--- trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/Sim/Units/UnitDefHandler.cpp	2008-01-24 02:36:52 UTC (rev 5371)
@@ -136,14 +136,15 @@
 
 void CUnitDefHandler::CleanBuildOptions()
 {
-	// remove invalid unitDef's from build options
+	// remove invalid build options
 	for (int i = 1; i &lt;= numUnitDefs; i++) {
 		UnitDef&amp; ud = unitDefs[i];
 		map&lt;int, string&gt;&amp; bo = ud.buildOptions;
 		map&lt;int, string&gt;::iterator it = bo.begin();
 		while (it != bo.end()) {
+			bool erase = false;
+
 			const UnitDef* bd = GetUnitByName(it-&gt;second);
-			bool erase = false;
 			if (bd == NULL) {
 				logOutput.Print(&quot;WARNING: removed the \&quot;&quot; + it-&gt;second +
 				                &quot;\&quot; entry from the \&quot;&quot; + ud.name + &quot;\&quot; build menu&quot;);
@@ -152,7 +153,7 @@
 			else if (bd-&gt;maxThisUnit &lt;= 0) {
 				erase = true; // silent removal
 			}
-			
+
 			if (erase) {
 				map&lt;int, string&gt;::iterator tmp = it;
 				it++;
@@ -932,9 +933,9 @@
 	}
 	else {
 		if (!LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.dds&quot;, bitmap) &amp;&amp;
-			!LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.png&quot;, bitmap) &amp;&amp;
-			!LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.pcx&quot;, bitmap) &amp;&amp;
-			!LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.bmp&quot;, bitmap)) {
+		    !LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.png&quot;, bitmap) &amp;&amp;
+		    !LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.pcx&quot;, bitmap) &amp;&amp;
+		    !LoadBuildPic(&quot;unitpics/&quot; + unitdef-&gt;name + &quot;.bmp&quot;, bitmap)) {
 			bitmap.Alloc(1, 1); // last resort
 		}
 	}

Modified: trunk/rts/lib/lua/README_SPRING
===================================================================
--- trunk/rts/lib/lua/README_SPRING	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/lib/lua/README_SPRING	2008-01-24 02:36:52 UTC (rev 5371)
@@ -13,9 +13,6 @@
 
   4. Made the following adjustments in luaconf.h:
 
-     //SPRING#undef LUA_COMPAT_GETN
-     #define LUA_COMPAT_GETN
-
      //SPRING#define LUA_NUMBER_DOUBLE
      #undef LUA_NUMBER_DOUBLE
 

Modified: trunk/rts/lib/lua/include/LuaInclude.h
===================================================================
--- trunk/rts/lib/lua/include/LuaInclude.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/lib/lua/include/LuaInclude.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -24,9 +24,9 @@
   lua_rawgeti(L, idx, n);
   if (lua_isnoneornil(L, -1)) {
     lua_pop(L, 1);
-    return 1;
+    return 0;
   }
-  return 0;
+  return 1;
 }
 
 

Modified: trunk/rts/lib/lua/include/lauxlib.h
===================================================================
--- trunk/rts/lib/lua/include/lauxlib.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/lib/lua/include/lauxlib.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -16,11 +16,11 @@
 
 
 #if defined(LUA_COMPAT_GETN)
-LUALIB_API int (luaL_getn) (lua_State *L, int t);
+LUALIB_API int  (luaL_getn) (lua_State *L, int t);
 LUALIB_API void (luaL_setn) (lua_State *L, int t, int n);
 #else
-#define luaL_getn(L,i)          ((int)lua_objlen(L, i))
-#define luaL_setn(L,i,j)        ((void)0)  /* no op! */
+inline int  luaL_getn(lua_State* L, int t)  { return ((int)lua_objlen(L, t)); }
+inline void luaL_setn(lua_State*, int, int) { return; }
 #endif
 
 #if defined(LUA_COMPAT_OPENLIB)

Modified: trunk/rts/lib/lua/include/luaconf.h
===================================================================
--- trunk/rts/lib/lua/include/luaconf.h	2008-01-23 18:39:09 UTC (rev 5370)
+++ trunk/rts/lib/lua/include/luaconf.h	2008-01-24 02:36:52 UTC (rev 5371)
@@ -319,8 +319,7 @@
 ** CHANGE it (define it) if you want exact compatibility with the
 ** behavior of setn/getn in Lua 5.0.
 */
-//SPRING#undef LUA_COMPAT_GETN
-#define LUA_COMPAT_GETN
+#undef LUA_COMPAT_GETN
 
 /*
 @@ LUA_COMPAT_LOADLIB controls compatibility about global loadlib.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000177.html">[Taspring-linux-commit] r5370 - trunk/AI/Global/KAIK-0.13
</A></li>
	<LI>Next message: <A HREF="000179.html">[Taspring-linux-commit] r5372 - trunk/rts/Lua
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#178">[ date ]</a>
              <a href="thread.html#178">[ thread ]</a>
              <a href="subject.html#178">[ subject ]</a>
              <a href="author.html#178">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
