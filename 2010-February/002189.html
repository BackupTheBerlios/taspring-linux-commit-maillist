<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7419 - in Lobby/TASClient: .	LobbyComponents/DockPanel Python Python/modules Python/scripts
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2010-February/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7419%20-%20in%20Lobby/TASClient%3A%20.%0A%09LobbyComponents/DockPanel%20Python%20Python/modules%20Python/scripts&In-Reply-To=%3C20100225221011.58960236DF%40it-l.eu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002188.html">
   <LINK REL="Next"  HREF="002190.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7419 - in Lobby/TASClient: .	LobbyComponents/DockPanel Python Python/modules Python/scripts</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7419%20-%20in%20Lobby/TASClient%3A%20.%0A%09LobbyComponents/DockPanel%20Python%20Python/modules%20Python/scripts&In-Reply-To=%3C20100225221011.58960236DF%40it-l.eu%3E"
       TITLE="[Taspring-linux-commit] r7419 - in Lobby/TASClient: .	LobbyComponents/DockPanel Python Python/modules Python/scripts">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Thu Feb 25 23:10:11 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="002188.html">[Taspring-linux-commit] r7418 - Lobby/TASClient
</A></li>
        <LI>Next message: <A HREF="002190.html">[Taspring-linux-commit] r7420 - Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2189">[ date ]</a>
              <a href="thread.html#2189">[ thread ]</a>
              <a href="subject.html#2189">[ subject ]</a>
              <a href="author.html#2189">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: satirik
Date: 2010-02-25 23:10:10 +0100 (Thu, 25 Feb 2010)
New Revision: 7419

Added:
   Lobby/TASClient/Python/modules/shlex.py
   Lobby/TASClient/Python/modules/subprocess.py
   Lobby/TASClient/Python/modules/threading.py
   Lobby/TASClient/Python/modules/traceback.py
   Lobby/TASClient/Python/modules/webbrowser.py
   Lobby/TASClient/Python/scripts/googleIt.py
Modified:
   Lobby/TASClient/LobbyComponents/DockPanel/DockPanel.dfm
   Lobby/TASClient/LobbyScriptUnit.pas
   Lobby/TASClient/MainUnit.dfm
   Lobby/TASClient/MainUnit.pas
   Lobby/TASClient/Python/api.txt
   Lobby/TASClient/TASClient.dof
   Lobby/TASClient/TASClient.res
Log:
* PYTHON : added 'Chat' to the list of context menu
* PYTHON : new googleIt script adding 'Google this' and 'Translate to english/french/german/italian/spanish' to chat context menu

Modified: Lobby/TASClient/LobbyComponents/DockPanel/DockPanel.dfm
===================================================================
--- Lobby/TASClient/LobbyComponents/DockPanel/DockPanel.dfm	2010-02-25 15:35:55 UTC (rev 7418)
+++ Lobby/TASClient/LobbyComponents/DockPanel/DockPanel.dfm	2010-02-25 22:10:10 UTC (rev 7419)
@@ -1,6 +1,6 @@
 object PageControlHost: TPageControlHost
-  Left = 636
-  Top = 402
+  Left = 496
+  Top = 506
   Width = 396
   Height = 264
   BorderStyle = bsSizeToolWin

Modified: Lobby/TASClient/LobbyScriptUnit.pas
===================================================================
--- Lobby/TASClient/LobbyScriptUnit.pas	2010-02-25 15:35:55 UTC (rev 7418)
+++ Lobby/TASClient/LobbyScriptUnit.pas	2010-02-25 22:10:10 UTC (rev 7419)
@@ -8,7 +8,7 @@
   WSocket,MainUnit, class_TIntegerList, RichEdit2, ExRichEdit,
   SyncObjs,SpTBXItem, TB2Item, JvDesktopAlert, GR32,
   SpTBXControls, SpTBXTabs,Forms, TBXDkPanels,ComCtrls, pngimage,
-  Jpeg, Math, Dockpanel;
+  Jpeg, Math, Dockpanel, RichEdit;
 
 type
   TScriptForm = class(TDockableForm)
@@ -103,7 +103,7 @@
       FStackLayoutChanges: boolean;
 
       function GetMenu(name: string): TTBCustomItem;
-      function GetMenuSelectedId(menu: TTBCustomItem): string;
+      procedure AddSelectionArgs(m: PScriptMenuItemCallBack);
       procedure MenuItemClick(Sender: TObject);
       function GetFreeMenuId: integer;
       procedure SimpleCallbackEvent(Sender: TObject);
@@ -302,7 +302,7 @@
 
 uses PythonScriptDebugFormUnit, Utility, MapListFormUnit, HostBattleFormUnit,
 BattleFormUnit, ReplaysUnit, PreferencesFormUnit, CustomizeGUIFormUnit,
-TypInfo, SpringDownloaderFormUnit;
+TypInfo, SpringDownloaderFormUnit, StdCtrls;
 
 
 //------------------------------------------------------------------------------------------------------
@@ -1595,6 +1595,8 @@
     Result := BattleForm.LadderPopupMenu.Items
   else if name = 'ReplayItem' then
     Result := ReplaysForm.ReplayListPopupMenu.Items
+  else if name = 'Chat' then
+    Result := MainForm.RichEditPopupMenu.Items
   else
   begin
     id := 0;
@@ -1619,32 +1621,66 @@
   end;
 end;
 
-function TGUI.GetMenuSelectedId(menu: TTBCustomItem): string;
+procedure TGUI.AddSelectionArgs(m: PScriptMenuItemCallBack);
 var
   RealIndex: integer;
   WhatToDraw: TClientNodeType;
   i: integer;
+  menu: TTBCustomItem;
+  pt: TPoint;
+  ci,lix,co: integer;
 begin
-  if menu = MainForm.BattleListPopupMenu.Items then
-    Result := IntToStr(MainUnit.SelectedBattle.ID)
-  else if (menu = MainForm.ClientPopupMenu.LinkSubitems) or (menu = MainForm.ModerationSubmenuItem) then
-    Result := MainUnit.SelectedUserName
-  else if menu = BattleForm.PlayerControlPopupMenu.Items then
+  with GetPythonEngine do
   begin
-    BattleForm.GetNodeClient(BattleForm.VDTBattleClients.FocusedNode.Index,RealIndex,WhatToDraw);
-    Result := TClient(BattleState.Battle.Clients[RealIndex]).Name
-  end
-  else if menu = ReplaysForm.ReplayListPopupMenu.Items then
-    Result := IntToStr(ReplayList.IndexOf(ReplaysForm.GetReplayFromNode(ReplaysForm.VDTReplays.FocusedNode)))
-  else
-  begin
-    for i:=0 to MenuItemList.Count-1 do
-      if PScriptMenuItem(MenuItemList[i]).item = menu then
+    menu := m.menu;
+    while True do
+      if menu = MainForm.BattleListPopupMenu.Items then
       begin
-        Result := GetMenuSelectedId(PScriptMenuItem(MenuItemList[i]).item.Parent);
-        Exit;
-      end;
-    Result := '';
+        PyList_SetItem(m.args,0,PyLong_FromLong(MainUnit.SelectedBattle.ID));
+        break;
+      end
+      else if (menu = MainForm.ClientPopupMenu.LinkSubitems) or (m.menu = MainForm.ModerationSubmenuItem) then
+      begin
+        PyList_SetItem(m.args,0,PyString_FromString(PChar(String(MainUnit.SelectedUserName))));
+        break;
+      end
+      else if menu = BattleForm.PlayerControlPopupMenu.Items then
+      begin
+        BattleForm.GetNodeClient(BattleForm.VDTBattleClients.FocusedNode.Index,RealIndex,WhatToDraw);
+        PyList_SetItem(m.args,0,PyString_FromString(PChar(TClient(BattleState.Battle.Clients[RealIndex]).Name)));
+        break;
+      end
+      else if menu = ReplaysForm.ReplayListPopupMenu.Items then
+      begin
+        PyList_SetItem(m.args,0,PyLong_FromLong(ReplayList.IndexOf(ReplaysForm.GetReplayFromNode(ReplaysForm.VDTReplays.FocusedNode))));
+        break;
+      end
+      else if menu = MainForm.RichEditPopupMenu.Items then
+      begin
+        GetCursorPos(pt);
+        with TExRichEdit(MainForm.lastActiveTab.FindChildControl('RichEdit')) do
+        begin
+          ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@(MainForm.richContextMenuClick))) ;
+          if ci &gt; -1 then
+          begin
+            lix := Perform(EM_EXLINEFROMCHAR, 0, ci) ;
+            if lix &lt; Lines.Count then
+            begin
+              co := ci - Perform(EM_LINEINDEX, lix, 0) ;
+              PyList_SetItem(m.args,0,PyString_FromString(PChar(MainForm.lastActiveTab.Caption)));
+              PyList_SetItem(m.args,1,PyString_FromString(PChar(Lines[lix])));
+              PyList_SetItem(m.args,2,PyLong_FromLong(co));
+            end;
+          end;
+          PyList_SetItem(m.args,3,PyString_FromString(PChar(SelText)));
+        end;
+        break;
+      end
+      else
+        if menu.Parent &lt;&gt; nil then
+          menu := menu.Parent
+        else
+          break;
   end;
 end;
 
@@ -1661,7 +1697,7 @@
     miCb := PScriptMenuItemCallBack(Pointer((Sender as TSpTBXItem).Tag));
     m := FindFunction(miCb.moduleName,miCb.functionName);
 
-    PyList_SetItem(miCb.args,0,PyString_FromString(PChar(GetMenuSelectedId(miCb.menu))));
+    AddSelectionArgs(miCb);
 
     EvalPyFunction(m,PyList_AsTuple(miCb.args));
   end;
@@ -1708,7 +1744,17 @@
       itemCb.moduleName := callbackModuleName;
       itemCb.functionName := callbackFunctionName;
       itemCb.args := VariantAsPyObject(callbackArgs);
-      PyList_Insert(itemCb.args,0,PyString_FromString('')); // adding the returning id as first arg
+
+      // adding the selection empty args
+      if m = MainForm.RichEditPopupMenu.Items then
+      begin
+        PyList_Insert(itemCb.args,0,PyString_FromString('')); // sel text
+        PyList_Insert(itemCb.args,0,PyLong_FromLong(0)); // char pos in line
+        PyList_Insert(itemCb.args,0,PyString_FromString('')); // line text
+        PyList_Insert(itemCb.args,0,PyString_FromString('')); // chat name
+      end
+      else
+        PyList_Insert(itemCb.args,0,PyLong_FromLong(0)); // item id
       itemCb.menu := m;
       Tag := Longint(itemCb);
 

Modified: Lobby/TASClient/MainUnit.dfm
===================================================================
--- Lobby/TASClient/MainUnit.dfm	2010-02-25 15:35:55 UTC (rev 7418)
+++ Lobby/TASClient/MainUnit.dfm	2010-02-25 22:10:10 UTC (rev 7419)
@@ -1,6 +1,6 @@
 object MainForm: TMainForm
-  Left = 608
-  Top = 440
+  Left = 583
+  Top = 234
   Width = 847
   Height = 521
   Caption = '.'
@@ -1163,7 +1163,7 @@
         Images = ConnectionStateImageList
         ParentShowHint = False
         ShowHint = True
-        TabOrder = 5
+        TabOrder = 4
         OnClick = ConnectButtonClick
       end
       object SinglePlayerButton: TSpTBXButton
@@ -5893,7 +5893,7 @@
     Left = 433
     Top = 287
     Bitmap = {
-      494C01010D000E00040010001000FFFFFFFFFF00FFFFFFFFFFFFFFFF424D3600
+      494C01010D000E00040010001000FFFFFFFFFF10FFFFFFFFFFFFFFFF424D3600
       0000000000003600000028000000400000004000000001002000000000000040
       00000000000000000000000000000000000052A5C600398CAD0008738C00108C
       A500006B8C00007B940000849C0000738C00006B8400006B8400007384001073
@@ -6425,7 +6425,8 @@
       FFFF31FFE003FFFFFFFF31FFC001FDFFFFFF01FFC001F9FFFFFF00FF8000F1FF
       FEFF827F8000E003FC7FF93F8000C003F83FFC838000C003FFFFFE018000E003
       FFFFFF01C001F1FFFFFFFF19C001F9FFFFFFFF19E003FDFFFFFFFF07F007FFFF
-      FFFFFF87FC1FFFFFFFFFFFFFFFFFFFFF}
+      FFFFFF87FC1FFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000
+      000000000000}
   end
   object ColorImageList: TImageList
     Left = 465
@@ -6808,7 +6809,7 @@
   object RichEditPopupMenu: TSpTBXPopupMenu
     AutoHotkeys = maManual
     OnPopup = RichEditPopupMenuPopup
-    Left = 180
+    Left = 188
     Top = 166
     object Copy1: TSpTBXItem
       Caption = 'Copy'
@@ -6833,6 +6834,8 @@
       Caption = 'Open logs'
       OnClick = OpenLogs1Click
     end
+    object SpTBXSeparatorItem27: TSpTBXSeparatorItem
+    end
   end
   object ArrowList: TImageList
     Left = 496

Modified: Lobby/TASClient/MainUnit.pas
===================================================================
--- Lobby/TASClient/MainUnit.pas	2010-02-25 15:35:55 UTC (rev 7418)
+++ Lobby/TASClient/MainUnit.pas	2010-02-25 22:10:10 UTC (rev 7419)
@@ -405,7 +405,7 @@
   );
 
 const
-  VERSION_NUMBER = '0.64'; // Must be float value! (with a period as a decimal seperator)
+  VERSION_NUMBER = '0.65'; // Must be float value! (with a period as a decimal seperator)
   AUTOUPDATE_URL = '<A HREF="http://tasclient.no-ip.org/TASClient_update_v3.txt">http://tasclient.no-ip.org/TASClient_update_v3.txt</A>';
   PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER;
   KEEP_ALIVE_INTERVAL = 10000; // in milliseconds. Tells us what should be the maximum &quot;silence&quot; time before we send a ping to the server.
@@ -1216,6 +1216,7 @@
     DeleteLayoutSubmenu: TSpTBXSubmenuItem;
     mnuSpringOptions: TSpTBXItem;
     EnableFilters: TSpTBXCheckBox;
+    SpTBXSeparatorItem27: TSpTBXSeparatorItem;
     procedure mnuOpenPrivateChatClick(Sender: TObject);
     procedure mnuSelectBattleClick(Sender: TObject);
     procedure mnuPlayWithClick(Sender: TObject);
@@ -1412,6 +1413,7 @@
     lastActiveTab: TMyTabSheet;
     ChatTabs: TList;
     autoCompletionHint : THintWindow;
+    richContextMenuClick: TPoint;
     
     procedure CreateParams(var Params: TCreateParams); override;
     procedure WMSysCommand(var Message: TWMSysCommand); message WM_SYSCOMMAND;
@@ -7768,15 +7770,15 @@
    lix, //Line Index
    co, //Character Offset
    k, j: Integer;
-   Pt: TPoint;
    s: string;
    SelectedNick: string;
 begin
    with TExRichEdit(Sender) do
    begin
     try
-     Pt := Point(X, Y) ;
-     ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@Pt)) ;
+     richContextMenuClick := Point(X, Y) ;
+
+     ci := Perform(Messages.EM_CHARFROMPOS, 0, Integer(@richContextMenuClick)) ;
      if ci &lt; 0 then Exit;
      lix := Perform(EM_EXLINEFROMCHAR, 0, ci) ;
      co := ci - Perform(EM_LINEINDEX, lix, 0) ;
@@ -7800,7 +7802,7 @@
        ModerationSubmenuItem.Visible := Status.Me.GetAccess; // only moderators may see moderation menu!
        MuteSubitemMenu.Visible := LeftStr(lastActiveTab.Caption,1) = '#';
        mnuUnmute.Visible := LeftStr(lastActiveTab.Caption,1) = '#';
-       ClientPopupMenu.Popup(TExRichEdit(Sender).ClientToScreen(pt).X,TExRichEdit(Sender).ClientToScreen(pt).Y);
+       ClientPopupMenu.Popup(TExRichEdit(Sender).ClientToScreen(richContextMenuClick).X,TExRichEdit(Sender).ClientToScreen(richContextMenuClick).Y);
       end
       else
       begin

Modified: Lobby/TASClient/Python/api.txt
===================================================================
--- Lobby/TASClient/Python/api.txt	2010-02-25 15:35:55 UTC (rev 7418)
+++ Lobby/TASClient/Python/api.txt	2010-02-25 22:10:10 UTC (rev 7419)
@@ -80,7 +80,7 @@
 GUI Class
 ---------
 
-menuName = [HostBattle, Options, Help, HelpWiki, HelpDownload, BattleItem (returning the BattleId), PlayerItem (Returning the Player Name), PlayerItemModeration (Returning the Player Name), BattlePlayerItem (Returning the Player Name), BattleMinimap, BattleAdmin, BattleAdminBalance, BattleAdminRankLimit, BattleLadder, ReplayItem (Returning the Replay index)] 
+menuName = [Char (returning Channel,line text, char position in the line, selected text), HostBattle, Options, Help, HelpWiki, HelpDownload, BattleItem (returning the BattleId), PlayerItem (Returning the Player Name), PlayerItemModeration (Returning the Player Name), BattlePlayerItem (Returning the Player Name), BattleMinimap, BattleAdmin, BattleAdminBalance, BattleAdminRankLimit, BattleLadder, ReplayItem (Returning the Replay index)] 
 
 - AddItemToMenu(menuName/SubmenuId,caption,callbackModuleName,callbackFunctionName,argsTuple,name) return itemId
 	The selected item id is returned as first argument added to the argsTuple.

Added: Lobby/TASClient/Python/modules/shlex.py
===================================================================
--- Lobby/TASClient/Python/modules/shlex.py	                        (rev 0)
+++ Lobby/TASClient/Python/modules/shlex.py	2010-02-25 22:10:10 UTC (rev 7419)
@@ -0,0 +1,292 @@
+# -*- coding: iso-8859-1 -*-
+&quot;&quot;&quot;A lexical analyzer class for simple shell-like syntaxes.&quot;&quot;&quot;
+
+# Module and documentation by Eric S. Raymond, 21 Dec 1998
+# Input stacking and error message cleanup added by ESR, March 2000
+# push_source() and pop_source() made explicit by ESR, January 2001.
+# Posix compliance, split(), string arguments, and
+# iterator interface by Gustavo Niemeyer, April 2003.
+
+import os.path
+import sys
+from collections import deque
+
+try:
+    from cStringIO import StringIO
+except ImportError:
+    from StringIO import StringIO
+
+__all__ = [&quot;shlex&quot;, &quot;split&quot;]
+
+class shlex:
+    &quot;A lexical analyzer class for simple shell-like syntaxes.&quot;
+    def __init__(self, instream=None, infile=None, posix=False):
+        if isinstance(instream, basestring):
+            instream = StringIO(instream)
+        if instream is not None:
+            self.instream = instream
+            self.infile = infile
+        else:
+            self.instream = sys.stdin
+            self.infile = None
+        self.posix = posix
+        if posix:
+            self.eof = None
+        else:
+            self.eof = ''
+        self.commenters = '#'
+        self.wordchars = ('abcdfeghijklmnopqrstuvwxyz'
+                          'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_')
+        if self.posix:
+            self.wordchars += ('&#223;&#224;&#225;&#226;&#227;&#228;&#229;&#230;&#231;&#232;&#233;&#234;&#235;&#236;&#237;&#238;&#239;&#240;&#241;&#242;&#243;&#244;&#245;&#246;&#248;&#249;&#250;&#251;&#252;&#253;&#254;&#255;'
+                               '&#192;&#193;&#194;&#195;&#196;&#197;&#198;&#199;&#200;&#201;&#202;&#203;&#204;&#205;&#206;&#207;&#208;&#209;&#210;&#211;&#212;&#213;&#214;&#216;&#217;&#218;&#219;&#220;&#221;&#222;')
+        self.whitespace = ' \t\r\n'
+        self.whitespace_split = False
+        self.quotes = '\'&quot;'
+        self.escape = '\\'
+        self.escapedquotes = '&quot;'
+        self.state = ' '
+        self.pushback = deque()
+        self.lineno = 1
+        self.debug = 0
+        self.token = ''
+        self.filestack = deque()
+        self.source = None
+        if self.debug:
+            print 'shlex: reading from %s, line %d' \
+                  % (self.instream, self.lineno)
+
+    def push_token(self, tok):
+        &quot;Push a token onto the stack popped by the get_token method&quot;
+        if self.debug &gt;= 1:
+            print &quot;shlex: pushing token &quot; + repr(tok)
+        self.pushback.appendleft(tok)
+
+    def push_source(self, newstream, newfile=None):
+        &quot;Push an input source onto the lexer's input source stack.&quot;
+        if isinstance(newstream, basestring):
+            newstream = StringIO(newstream)
+        self.filestack.appendleft((self.infile, self.instream, self.lineno))
+        self.infile = newfile
+        self.instream = newstream
+        self.lineno = 1
+        if self.debug:
+            if newfile is not None:
+                print 'shlex: pushing to file %s' % (self.infile,)
+            else:
+                print 'shlex: pushing to stream %s' % (self.instream,)
+
+    def pop_source(self):
+        &quot;Pop the input source stack.&quot;
+        self.instream.close()
+        (self.infile, self.instream, self.lineno) = self.filestack.popleft()
+        if self.debug:
+            print 'shlex: popping to %s, line %d' \
+                  % (self.instream, self.lineno)
+        self.state = ' '
+
+    def get_token(self):
+        &quot;Get a token from the input stream (or from stack if it's nonempty)&quot;
+        if self.pushback:
+            tok = self.pushback.popleft()
+            if self.debug &gt;= 1:
+                print &quot;shlex: popping token &quot; + repr(tok)
+            return tok
+        # No pushback.  Get a token.
+        raw = self.read_token()
+        # Handle inclusions
+        if self.source is not None:
+            while raw == self.source:
+                spec = self.sourcehook(self.read_token())
+                if spec:
+                    (newfile, newstream) = spec
+                    self.push_source(newstream, newfile)
+                raw = self.get_token()
+        # Maybe we got EOF instead?
+        while raw == self.eof:
+            if not self.filestack:
+                return self.eof
+            else:
+                self.pop_source()
+                raw = self.get_token()
+        # Neither inclusion nor EOF
+        if self.debug &gt;= 1:
+            if raw != self.eof:
+                print &quot;shlex: token=&quot; + repr(raw)
+            else:
+                print &quot;shlex: token=EOF&quot;
+        return raw
+
+    def read_token(self):
+        quoted = False
+        escapedstate = ' '
+        while True:
+            nextchar = self.instream.read(1)
+            if nextchar == '\n':
+                self.lineno = self.lineno + 1
+            if self.debug &gt;= 3:
+                print &quot;shlex: in state&quot;, repr(self.state), \
+                      &quot;I see character:&quot;, repr(nextchar)
+            if self.state is None:
+                self.token = ''        # past end of file
+                break
+            elif self.state == ' ':
+                if not nextchar:
+                    self.state = None  # end of file
+                    break
+                elif nextchar in self.whitespace:
+                    if self.debug &gt;= 2:
+                        print &quot;shlex: I see whitespace in whitespace state&quot;
+                    if self.token or (self.posix and quoted):
+                        break   # emit current token
+                    else:
+                        continue
+                elif nextchar in self.commenters:
+                    self.instream.readline()
+                    self.lineno = self.lineno + 1
+                elif self.posix and nextchar in self.escape:
+                    escapedstate = 'a'
+                    self.state = nextchar
+                elif nextchar in self.wordchars:
+                    self.token = nextchar
+                    self.state = 'a'
+                elif nextchar in self.quotes:
+                    if not self.posix:
+                        self.token = nextchar
+                    self.state = nextchar
+                elif self.whitespace_split:
+                    self.token = nextchar
+                    self.state = 'a'
+                else:
+                    self.token = nextchar
+                    if self.token or (self.posix and quoted):
+                        break   # emit current token
+                    else:
+                        continue
+            elif self.state in self.quotes:
+                quoted = True
+                if not nextchar:      # end of file
+                    if self.debug &gt;= 2:
+                        print &quot;shlex: I see EOF in quotes state&quot;
+                    # XXX what error should be raised here?
+                    raise ValueError, &quot;No closing quotation&quot;
+                if nextchar == self.state:
+                    if not self.posix:
+                        self.token = self.token + nextchar
+                        self.state = ' '
+                        break
+                    else:
+                        self.state = 'a'
+                elif self.posix and nextchar in self.escape and \
+                     self.state in self.escapedquotes:
+                    escapedstate = self.state
+                    self.state = nextchar
+                else:
+                    self.token = self.token + nextchar
+            elif self.state in self.escape:
+                if not nextchar:      # end of file
+                    if self.debug &gt;= 2:
+                        print &quot;shlex: I see EOF in escape state&quot;
+                    # XXX what error should be raised here?
+                    raise ValueError, &quot;No escaped character&quot;
+                # In posix shells, only the quote itself or the escape
+                # character may be escaped within quotes.
+                if escapedstate in self.quotes and \
+                   nextchar != self.state and nextchar != escapedstate:
+                    self.token = self.token + self.state
+                self.token = self.token + nextchar
+                self.state = escapedstate
+            elif self.state == 'a':
+                if not nextchar:
+                    self.state = None   # end of file
+                    break
+                elif nextchar in self.whitespace:
+                    if self.debug &gt;= 2:
+                        print &quot;shlex: I see whitespace in word state&quot;
+                    self.state = ' '
+                    if self.token or (self.posix and quoted):
+                        break   # emit current token
+                    else:
+                        continue
+                elif nextchar in self.commenters:
+                    self.instream.readline()
+                    self.lineno = self.lineno + 1
+                    if self.posix:
+                        self.state = ' '
+                        if self.token or (self.posix and quoted):
+                            break   # emit current token
+                        else:
+                            continue
+                elif self.posix and nextchar in self.quotes:
+                    self.state = nextchar
+                elif self.posix and nextchar in self.escape:
+                    escapedstate = 'a'
+                    self.state = nextchar
+                elif nextchar in self.wordchars or nextchar in self.quotes \
+                    or self.whitespace_split:
+                    self.token = self.token + nextchar
+                else:
+                    self.pushback.appendleft(nextchar)
+                    if self.debug &gt;= 2:
+                        print &quot;shlex: I see punctuation in word state&quot;
+                    self.state = ' '
+                    if self.token:
+                        break   # emit current token
+                    else:
+                        continue
+        result = self.token
+        self.token = ''
+        if self.posix and not quoted and result == '':
+            result = None
+        if self.debug &gt; 1:
+            if result:
+                print &quot;shlex: raw token=&quot; + repr(result)
+            else:
+                print &quot;shlex: raw token=EOF&quot;
+        return result
+
+    def sourcehook(self, newfile):
+        &quot;Hook called on a filename to be sourced.&quot;
+        if newfile[0] == '&quot;':
+            newfile = newfile[1:-1]
+        # This implements cpp-like semantics for relative-path inclusion.
+        if isinstance(self.infile, basestring) and not os.path.isabs(newfile):
+            newfile = os.path.join(os.path.dirname(self.infile), newfile)
+        return (newfile, open(newfile, &quot;r&quot;))
+
+    def error_leader(self, infile=None, lineno=None):
+        &quot;Emit a C-compiler-like, Emacs-friendly error-message leader.&quot;
+        if infile is None:
+            infile = self.infile
+        if lineno is None:
+            lineno = self.lineno
+        return &quot;\&quot;%s\&quot;, line %d: &quot; % (infile, lineno)
+
+    def __iter__(self):
+        return self
+
+    def next(self):
+        token = self.get_token()
+        if token == self.eof:
+            raise StopIteration
+        return token
+
+def split(s, comments=False):
+    lex = shlex(s, posix=True)
+    lex.whitespace_split = True
+    if not comments:
+        lex.commenters = ''
+    return list(lex)
+
+if __name__ == '__main__':
+    if len(sys.argv) == 1:
+        lexer = shlex()
+    else:
+        file = sys.argv[1]
+        lexer = shlex(open(file), file)
+    while 1:
+        tt = lexer.get_token()
+        if tt:
+            print &quot;Token: &quot; + repr(tt)
+        else:
+            break

Added: Lobby/TASClient/Python/modules/subprocess.py
===================================================================
--- Lobby/TASClient/Python/modules/subprocess.py	                        (rev 0)
+++ Lobby/TASClient/Python/modules/subprocess.py	2010-02-25 22:10:10 UTC (rev 7419)
@@ -0,0 +1,1258 @@
+# subprocess - Subprocesses with accessible I/O streams
+#
+# For more information about this module, see PEP 324.
+#
+# This module should remain compatible with Python 2.2, see PEP 291.
+#
+# Copyright (c) 2003-2005 by Peter Astrand &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">astrand at lysator.liu.se</A>&gt;
+#
+# Licensed to PSF under a Contributor Agreement.
+# See <A HREF="http://www.python.org/2.4/license">http://www.python.org/2.4/license</A> for licensing details.
+
+r&quot;&quot;&quot;subprocess - Subprocesses with accessible I/O streams
+
+This module allows you to spawn processes, connect to their
+input/output/error pipes, and obtain their return codes.  This module
+intends to replace several other, older modules and functions, like:
+
+os.system
+os.spawn*
+os.popen*
+popen2.*
+commands.*
+
+Information about how the subprocess module can be used to replace these
+modules and functions can be found below.
+
+
+
+Using the subprocess module
+===========================
+This module defines one class called Popen:
+
+class Popen(args, bufsize=0, executable=None,
+            stdin=None, stdout=None, stderr=None,
+            preexec_fn=None, close_fds=False, shell=False,
+            cwd=None, env=None, universal_newlines=False,
+            startupinfo=None, creationflags=0):
+
+
+Arguments are:
+
+args should be a string, or a sequence of program arguments.  The
+program to execute is normally the first item in the args sequence or
+string, but can be explicitly set by using the executable argument.
+
+On UNIX, with shell=False (default): In this case, the Popen class
+uses os.execvp() to execute the child program.  args should normally
+be a sequence.  A string will be treated as a sequence with the string
+as the only item (the program to execute).
+
+On UNIX, with shell=True: If args is a string, it specifies the
+command string to execute through the shell.  If args is a sequence,
+the first item specifies the command string, and any additional items
+will be treated as additional shell arguments.
+
+On Windows: the Popen class uses CreateProcess() to execute the child
+program, which operates on strings.  If args is a sequence, it will be
+converted to a string using the list2cmdline method.  Please note that
+not all MS Windows applications interpret the command line the same
+way: The list2cmdline is designed for applications using the same
+rules as the MS C runtime.
+
+bufsize, if given, has the same meaning as the corresponding argument
+to the built-in open() function: 0 means unbuffered, 1 means line
+buffered, any other positive value means use a buffer of
+(approximately) that size.  A negative bufsize means to use the system
+default, which usually means fully buffered.  The default value for
+bufsize is 0 (unbuffered).
+
+stdin, stdout and stderr specify the executed programs' standard
+input, standard output and standard error file handles, respectively.
+Valid values are PIPE, an existing file descriptor (a positive
+integer), an existing file object, and None.  PIPE indicates that a
+new pipe to the child should be created.  With None, no redirection
+will occur; the child's file handles will be inherited from the
+parent.  Additionally, stderr can be STDOUT, which indicates that the
+stderr data from the applications should be captured into the same
+file handle as for stdout.
+
+If preexec_fn is set to a callable object, this object will be called
+in the child process just before the child is executed.
+
+If close_fds is true, all file descriptors except 0, 1 and 2 will be
+closed before the child process is executed.
+
+if shell is true, the specified command will be executed through the
+shell.
+
+If cwd is not None, the current directory will be changed to cwd
+before the child is executed.
+
+If env is not None, it defines the environment variables for the new
+process.
+
+If universal_newlines is true, the file objects stdout and stderr are
+opened as a text files, but lines may be terminated by any of '\n',
+the Unix end-of-line convention, '\r', the Macintosh convention or
+'\r\n', the Windows convention.  All of these external representations
+are seen as '\n' by the Python program.  Note: This feature is only
+available if Python is built with universal newline support (the
+default).  Also, the newlines attribute of the file objects stdout,
+stdin and stderr are not updated by the communicate() method.
+
+The startupinfo and creationflags, if given, will be passed to the
+underlying CreateProcess() function.  They can specify things such as
+appearance of the main window and priority for the new process.
+(Windows only)
+
+
+This module also defines two shortcut functions:
+
+call(*popenargs, **kwargs):
+    Run command with arguments.  Wait for command to complete, then
+    return the returncode attribute.
+
+    The arguments are the same as for the Popen constructor.  Example:
+
+    retcode = call([&quot;ls&quot;, &quot;-l&quot;])
+
+check_call(*popenargs, **kwargs):
+    Run command with arguments.  Wait for command to complete.  If the
+    exit code was zero then return, otherwise raise
+    CalledProcessError.  The CalledProcessError object will have the
+    return code in the returncode attribute.
+
+    The arguments are the same as for the Popen constructor.  Example:
+
+    check_call([&quot;ls&quot;, &quot;-l&quot;])
+
+Exceptions
+----------
+Exceptions raised in the child process, before the new program has
+started to execute, will be re-raised in the parent.  Additionally,
+the exception object will have one extra attribute called
+'child_traceback', which is a string containing traceback information
+from the childs point of view.
+
+The most common exception raised is OSError.  This occurs, for
+example, when trying to execute a non-existent file.  Applications
+should prepare for OSErrors.
+
+A ValueError will be raised if Popen is called with invalid arguments.
+
+check_call() will raise CalledProcessError, if the called process
+returns a non-zero return code.
+
+
+Security
+--------
+Unlike some other popen functions, this implementation will never call
+/bin/sh implicitly.  This means that all characters, including shell
+metacharacters, can safely be passed to child processes.
+
+
+Popen objects
+=============
+Instances of the Popen class have the following methods:
+
+poll()
+    Check if child process has terminated.  Returns returncode
+    attribute.
+
+wait()
+    Wait for child process to terminate.  Returns returncode attribute.
+
+communicate(input=None)
+    Interact with process: Send data to stdin.  Read data from stdout
+    and stderr, until end-of-file is reached.  Wait for process to
+    terminate.  The optional input argument should be a string to be
+    sent to the child process, or None, if no data should be sent to
+    the child.
+
+    communicate() returns a tuple (stdout, stderr).
+
+    Note: The data read is buffered in memory, so do not use this
+    method if the data size is large or unlimited.
+
+The following attributes are also available:
+
+stdin
+    If the stdin argument is PIPE, this attribute is a file object
+    that provides input to the child process.  Otherwise, it is None.
+
+stdout
+    If the stdout argument is PIPE, this attribute is a file object
+    that provides output from the child process.  Otherwise, it is
+    None.
+
+stderr
+    If the stderr argument is PIPE, this attribute is file object that
+    provides error output from the child process.  Otherwise, it is
+    None.
+
+pid
+    The process ID of the child process.
+
+returncode
+    The child return code.  A None value indicates that the process
+    hasn't terminated yet.  A negative value -N indicates that the
+    child was terminated by signal N (UNIX only).
+
+
+Replacing older functions with the subprocess module
+====================================================
+In this section, &quot;a ==&gt; b&quot; means that b can be used as a replacement
+for a.
+
+Note: All functions in this section fail (more or less) silently if
+the executed program cannot be found; this module raises an OSError
+exception.
+
+In the following examples, we assume that the subprocess module is
+imported with &quot;from subprocess import *&quot;.
+
+
+Replacing /bin/sh shell backquote
+---------------------------------
+output=`mycmd myarg`
+==&gt;
+output = Popen([&quot;mycmd&quot;, &quot;myarg&quot;], stdout=PIPE).communicate()[0]
+
+
+Replacing shell pipe line
+-------------------------
+output=`dmesg | grep hda`
+==&gt;
+p1 = Popen([&quot;dmesg&quot;], stdout=PIPE)
+p2 = Popen([&quot;grep&quot;, &quot;hda&quot;], stdin=p1.stdout, stdout=PIPE)
+output = p2.communicate()[0]
+
+
+Replacing os.system()
+---------------------
+sts = os.system(&quot;mycmd&quot; + &quot; myarg&quot;)
+==&gt;
+p = Popen(&quot;mycmd&quot; + &quot; myarg&quot;, shell=True)
+pid, sts = os.waitpid(p.pid, 0)
+
+Note:
+
+* Calling the program through the shell is usually not required.
+
+* It's easier to look at the returncode attribute than the
+  exitstatus.
+
+A more real-world example would look like this:
+
+try:
+    retcode = call(&quot;mycmd&quot; + &quot; myarg&quot;, shell=True)
+    if retcode &lt; 0:
+        print &gt;&gt;sys.stderr, &quot;Child was terminated by signal&quot;, -retcode
+    else:
+        print &gt;&gt;sys.stderr, &quot;Child returned&quot;, retcode
+except OSError, e:
+    print &gt;&gt;sys.stderr, &quot;Execution failed:&quot;, e
+
+
+Replacing os.spawn*
+-------------------
+P_NOWAIT example:
+
+pid = os.spawnlp(os.P_NOWAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;)
+==&gt;
+pid = Popen([&quot;/bin/mycmd&quot;, &quot;myarg&quot;]).pid
+
+
+P_WAIT example:
+
+retcode = os.spawnlp(os.P_WAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;)
+==&gt;
+retcode = call([&quot;/bin/mycmd&quot;, &quot;myarg&quot;])
+
+
+Vector example:
+
+os.spawnvp(os.P_NOWAIT, path, args)
+==&gt;
+Popen([path] + args[1:])
+
+
+Environment example:
+
+os.spawnlpe(os.P_NOWAIT, &quot;/bin/mycmd&quot;, &quot;mycmd&quot;, &quot;myarg&quot;, env)
+==&gt;
+Popen([&quot;/bin/mycmd&quot;, &quot;myarg&quot;], env={&quot;PATH&quot;: &quot;/usr/bin&quot;})
+
+
+Replacing os.popen*
+-------------------
+pipe = os.popen(cmd, mode='r', bufsize)
+==&gt;
+pipe = Popen(cmd, shell=True, bufsize=bufsize, stdout=PIPE).stdout
+
+pipe = os.popen(cmd, mode='w', bufsize)
+==&gt;
+pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin
+
+
+(child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)
+==&gt;
+p = Popen(cmd, shell=True, bufsize=bufsize,
+          stdin=PIPE, stdout=PIPE, close_fds=True)
+(child_stdin, child_stdout) = (p.stdin, p.stdout)
+
+
+(child_stdin,
+ child_stdout,
+ child_stderr) = os.popen3(cmd, mode, bufsize)
+==&gt;
+p = Popen(cmd, shell=True, bufsize=bufsize,
+          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
+(child_stdin,
+ child_stdout,
+ child_stderr) = (p.stdin, p.stdout, p.stderr)
+
+
+(child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)
+==&gt;
+p = Popen(cmd, shell=True, bufsize=bufsize,
+          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
+(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)
+
+
+Replacing popen2.*
+------------------
+Note: If the cmd argument to popen2 functions is a string, the command
+is executed through /bin/sh.  If it is a list, the command is directly
+executed.
+
+(child_stdout, child_stdin) = popen2.popen2(&quot;somestring&quot;, bufsize, mode)
+==&gt;
+p = Popen([&quot;somestring&quot;], shell=True, bufsize=bufsize
+          stdin=PIPE, stdout=PIPE, close_fds=True)
+(child_stdout, child_stdin) = (p.stdout, p.stdin)
+
+
+(child_stdout, child_stdin) = popen2.popen2([&quot;mycmd&quot;, &quot;myarg&quot;], bufsize, mode)
+==&gt;
+p = Popen([&quot;mycmd&quot;, &quot;myarg&quot;], bufsize=bufsize,
+          stdin=PIPE, stdout=PIPE, close_fds=True)
+(child_stdout, child_stdin) = (p.stdout, p.stdin)
+
+The popen2.Popen3 and popen2.Popen4 basically works as subprocess.Popen,
+except that:
+
+* subprocess.Popen raises an exception if the execution fails
+* the capturestderr argument is replaced with the stderr argument.
+* stdin=PIPE and stdout=PIPE must be specified.
+* popen2 closes all filedescriptors by default, but you have to specify
+  close_fds=True with subprocess.Popen.
+
+
+&quot;&quot;&quot;
+
+import sys
+mswindows = (sys.platform == &quot;win32&quot;)
+
+import os
+import types
+import traceback
+import gc
+
+# Exception classes used by this module.
+class CalledProcessError(Exception):
+    &quot;&quot;&quot;This exception is raised when a process run by check_call() returns
+    a non-zero exit status.  The exit status will be stored in the
+    returncode attribute.&quot;&quot;&quot;
+    def __init__(self, returncode, cmd):
+        self.returncode = returncode
+        self.cmd = cmd
+    def __str__(self):
+        return &quot;Command '%s' returned non-zero exit status %d&quot; % (self.cmd, self.returncode)
+
+
+if mswindows:
+    import threading
+    import msvcrt
+    if 0: # &lt;-- change this to use pywin32 instead of the _subprocess driver
+        import pywintypes
+        from win32api import GetStdHandle, STD_INPUT_HANDLE, \
+                             STD_OUTPUT_HANDLE, STD_ERROR_HANDLE
+        from win32api import GetCurrentProcess, DuplicateHandle, \
+                             GetModuleFileName, GetVersion
+        from win32con import DUPLICATE_SAME_ACCESS, SW_HIDE
+        from win32pipe import CreatePipe
+        from win32process import CreateProcess, STARTUPINFO, \
+                                 GetExitCodeProcess, STARTF_USESTDHANDLES, \
+                                 STARTF_USESHOWWINDOW, CREATE_NEW_CONSOLE
+        from win32event import WaitForSingleObject, INFINITE, WAIT_OBJECT_0
+    else:
+        from _subprocess import *
+        class STARTUPINFO:
+            dwFlags = 0
+            hStdInput = None
+            hStdOutput = None
+            hStdError = None
+            wShowWindow = 0
+        class pywintypes:
+            error = IOError
+else:
+    import select
+    import errno
+    import fcntl
+    import pickle
+
+__all__ = [&quot;Popen&quot;, &quot;PIPE&quot;, &quot;STDOUT&quot;, &quot;call&quot;, &quot;check_call&quot;, &quot;CalledProcessError&quot;]
+
+try:
+    MAXFD = os.sysconf(&quot;SC_OPEN_MAX&quot;)
+except:
+    MAXFD = 256
+
+# True/False does not exist on 2.2.0
+try:
+    False
+except NameError:
+    False = 0
+    True = 1
+
+_active = []
+
+def _cleanup():
+    for inst in _active[:]:
+        if inst.poll(_deadstate=sys.maxint) &gt;= 0:
+            try:
+                _active.remove(inst)
+            except ValueError:
+                # This can happen if two threads create a new Popen instance.
+                # It's harmless that it was already removed, so ignore.
+                pass
+
+PIPE = -1
+STDOUT = -2
+
+
+def call(*popenargs, **kwargs):
+    &quot;&quot;&quot;Run command with arguments.  Wait for command to complete, then
+    return the returncode attribute.
+
+    The arguments are the same as for the Popen constructor.  Example:
+
+    retcode = call([&quot;ls&quot;, &quot;-l&quot;])
+    &quot;&quot;&quot;
+    return Popen(*popenargs, **kwargs).wait()
+
+
+def check_call(*popenargs, **kwargs):
+    &quot;&quot;&quot;Run command with arguments.  Wait for command to complete.  If
+    the exit code was zero then return, otherwise raise
+    CalledProcessError.  The CalledProcessError object will have the
+    return code in the returncode attribute.
+
+    The arguments are the same as for the Popen constructor.  Example:
+
+    check_call([&quot;ls&quot;, &quot;-l&quot;])
+    &quot;&quot;&quot;
+    retcode = call(*popenargs, **kwargs)
+    cmd = kwargs.get(&quot;args&quot;)
+    if cmd is None:
+        cmd = popenargs[0]
+    if retcode:
+        raise CalledProcessError(retcode, cmd)
+    return retcode
+
+
+def list2cmdline(seq):
+    &quot;&quot;&quot;
+    Translate a sequence of arguments into a command line
+    string, using the same rules as the MS C runtime:
+
+    1) Arguments are delimited by white space, which is either a
+       space or a tab.
+
+    2) A string surrounded by double quotation marks is
+       interpreted as a single argument, regardless of white space
+       contained within.  A quoted string can be embedded in an
+       argument.
+
+    3) A double quotation mark preceded by a backslash is
+       interpreted as a literal double quotation mark.
+
+    4) Backslashes are interpreted literally, unless they
+       immediately precede a double quotation mark.
+
+    5) If backslashes immediately precede a double quotation mark,
+       every pair of backslashes is interpreted as a literal
+       backslash.  If the number of backslashes is odd, the last
+       backslash escapes the next double quotation mark as
+       described in rule 3.
+    &quot;&quot;&quot;
+
+    # See
+    # <A HREF="http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.asp">http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.asp</A>
+    result = []
+    needquote = False
+    for arg in seq:
+        bs_buf = []
+
+        # Add a space to separate this argument from the others
+        if result:
+            result.append(' ')
+
+        needquote = (&quot; &quot; in arg) or (&quot;\t&quot; in arg) or arg == &quot;&quot;
+        if needquote:
+            result.append('&quot;')
+
+        for c in arg:
+            if c == '\\':
+                # Don't know if we need to double yet.
+                bs_buf.append(c)
+            elif c == '&quot;':
+                # Double backspaces.
+                result.append('\\' * len(bs_buf)*2)
+                bs_buf = []
+                result.append('\\&quot;')
+            else:
+                # Normal char
+                if bs_buf:
+                    result.extend(bs_buf)
+                    bs_buf = []
+                result.append(c)
+
+        # Add remaining backspaces, if any.
+        if bs_buf:
+            result.extend(bs_buf)
+
+        if needquote:
+            result.extend(bs_buf)
+            result.append('&quot;')
+
+    return ''.join(result)
+
+
+class Popen(object):
+    def __init__(self, args, bufsize=0, executable=None,
+                 stdin=None, stdout=None, stderr=None,
+                 preexec_fn=None, close_fds=False, shell=False,
+                 cwd=None, env=None, universal_newlines=False,
+                 startupinfo=None, creationflags=0):
+        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;
+        _cleanup()
+
+        self._child_created = False
+        if not isinstance(bufsize, (int, long)):
+            raise TypeError(&quot;bufsize must be an integer&quot;)
+
+        if mswindows:
+            if preexec_fn is not None:
+                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;
+                                 &quot;platforms&quot;)
+            if close_fds:
+                raise ValueError(&quot;close_fds is not supported on Windows &quot;
+                                 &quot;platforms&quot;)
+        else:
+            # POSIX
+            if startupinfo is not None:
+                raise ValueError(&quot;startupinfo is only supported on Windows &quot;
+                                 &quot;platforms&quot;)
+            if creationflags != 0:
+                raise ValueError(&quot;creationflags is only supported on Windows &quot;
+                                 &quot;platforms&quot;)
+
+        self.stdin = None
+        self.stdout = None
+        self.stderr = None
+        self.pid = None
+        self.returncode = None
+        self.universal_newlines = universal_newlines
+
+        # Input and output objects. The general principle is like
+        # this:
+        #
+        # Parent                   Child
+        # ------                   -----
+        # p2cwrite   ---stdin---&gt;  p2cread
+        # c2pread    &lt;--stdout---  c2pwrite
+        # errread    &lt;--stderr---  errwrite
+        #
+        # On POSIX, the child objects are file descriptors.  On
+        # Windows, these are Windows file handles.  The parent objects
+        # are file descriptors on both platforms.  The parent objects
+        # are None when not using PIPEs. The child objects are None
+        # when not redirecting.
+
+        (p2cread, p2cwrite,
+         c2pread, c2pwrite,
+         errread, errwrite) = self._get_handles(stdin, stdout, stderr)
+
+        self._execute_child(args, executable, preexec_fn, close_fds,
+                            cwd, env, universal_newlines,
+                            startupinfo, creationflags, shell,
+                            p2cread, p2cwrite,
+                            c2pread, c2pwrite,
+                            errread, errwrite)
+
+        # On Windows, you cannot just redirect one or two handles: You
+        # either have to redirect all three or none. If the subprocess
+        # user has only redirected one or two handles, we are
+        # automatically creating PIPEs for the rest. We should close
+        # these after the process is started. See bug #1124861.
+        if mswindows:
+            if stdin is None and p2cwrite is not None:
+                os.close(p2cwrite)
+                p2cwrite = None
+            if stdout is None and c2pread is not None:
+                os.close(c2pread)
+                c2pread = None
+            if stderr is None and errread is not None:
+                os.close(errread)
+                errread = None
+
+        if p2cwrite:
+            self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)
+        if c2pread:
+            if universal_newlines:
+                self.stdout = os.fdopen(c2pread, 'rU', bufsize)
+            else:
+                self.stdout = os.fdopen(c2pread, 'rb', bufsize)
+        if errread:
+            if universal_newlines:
+                self.stderr = os.fdopen(errread, 'rU', bufsize)
+            else:
+                self.stderr = os.fdopen(errread, 'rb', bufsize)
+
+
+    def _translate_newlines(self, data):
+        data = data.replace(&quot;\r\n&quot;, &quot;\n&quot;)
+        data = data.replace(&quot;\r&quot;, &quot;\n&quot;)
+        return data
+
+
+    def __del__(self, sys=sys):
+        if not self._child_created:
+            # We didn't get to successfully create a child process.
+            return
+        # In case the child hasn't been waited on, check if it's done.
+        self.poll(_deadstate=sys.maxint)
+        if self.returncode is None and _active is not None:
+            # Child is still running, keep us alive until we can wait on it.
+            _active.append(self)
+
+
+    def communicate(self, input=None):
+        &quot;&quot;&quot;Interact with process: Send data to stdin.  Read data from
+        stdout and stderr, until end-of-file is reached.  Wait for
+        process to terminate.  The optional input argument should be a
+        string to be sent to the child process, or None, if no data
+        should be sent to the child.
+
+        communicate() returns a tuple (stdout, stderr).&quot;&quot;&quot;
+
+        # Optimization: If we are only using one pipe, or no pipe at
+        # all, using select() or threads is unnecessary.
+        if [self.stdin, self.stdout, self.stderr].count(None) &gt;= 2:
+            stdout = None
+            stderr = None
+            if self.stdin:
+                if input:
+                    self.stdin.write(input)
+                self.stdin.close()
+            elif self.stdout:
+                stdout = self.stdout.read()
+            elif self.stderr:
+                stderr = self.stderr.read()
+            self.wait()
+            return (stdout, stderr)
+
+        return self._communicate(input)
+
+
+    if mswindows:
+        #
+        # Windows methods
+        #
+        def _get_handles(self, stdin, stdout, stderr):
+            &quot;&quot;&quot;Construct and return tupel with IO objects:
+            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
+            &quot;&quot;&quot;
+            if stdin is None and stdout is None and stderr is None:
+                return (None, None, None, None, None, None)
+
+            p2cread, p2cwrite = None, None
+            c2pread, c2pwrite = None, None
+            errread, errwrite = None, None
+
+            if stdin is None:
+                p2cread = GetStdHandle(STD_INPUT_HANDLE)
+            if p2cread is not None:
+                pass
+            elif stdin is None or stdin == PIPE:
+                p2cread, p2cwrite = CreatePipe(None, 0)
+                # Detach and turn into fd
+                p2cwrite = p2cwrite.Detach()
+                p2cwrite = msvcrt.open_osfhandle(p2cwrite, 0)
+            elif isinstance(stdin, int):
+                p2cread = msvcrt.get_osfhandle(stdin)
+            else:
+                # Assuming file-like object
+                p2cread = msvcrt.get_osfhandle(stdin.fileno())
+            p2cread = self._make_inheritable(p2cread)
+
+            if stdout is None:
+                c2pwrite = GetStdHandle(STD_OUTPUT_HANDLE)
+            if c2pwrite is not None:
+                pass
+            elif stdout is None or stdout == PIPE:
+                c2pread, c2pwrite = CreatePipe(None, 0)
+                # Detach and turn into fd
+                c2pread = c2pread.Detach()
+                c2pread = msvcrt.open_osfhandle(c2pread, 0)
+            elif isinstance(stdout, int):
+                c2pwrite = msvcrt.get_osfhandle(stdout)
+            else:
+                # Assuming file-like object
+                c2pwrite = msvcrt.get_osfhandle(stdout.fileno())
+            c2pwrite = self._make_inheritable(c2pwrite)
+
+            if stderr is None:
+                errwrite = GetStdHandle(STD_ERROR_HANDLE)
+            if errwrite is not None:
+                pass
+            elif stderr is None or stderr == PIPE:
+                errread, errwrite = CreatePipe(None, 0)
+                # Detach and turn into fd
+                errread = errread.Detach()
+                errread = msvcrt.open_osfhandle(errread, 0)
+            elif stderr == STDOUT:
+                errwrite = c2pwrite
+            elif isinstance(stderr, int):
+                errwrite = msvcrt.get_osfhandle(stderr)
+            else:
+                # Assuming file-like object
+                errwrite = msvcrt.get_osfhandle(stderr.fileno())
+            errwrite = self._make_inheritable(errwrite)
+
+            return (p2cread, p2cwrite,
+                    c2pread, c2pwrite,
+                    errread, errwrite)
+
+
+        def _make_inheritable(self, handle):
+            &quot;&quot;&quot;Return a duplicate of handle, which is inheritable&quot;&quot;&quot;
+            return DuplicateHandle(GetCurrentProcess(), handle,
+                                   GetCurrentProcess(), 0, 1,
+                                   DUPLICATE_SAME_ACCESS)
+
+
+        def _find_w9xpopen(self):
+            &quot;&quot;&quot;Find and return absolut path to w9xpopen.exe&quot;&quot;&quot;
+            w9xpopen = os.path.join(os.path.dirname(GetModuleFileName(0)),
+                                    &quot;w9xpopen.exe&quot;)
+            if not os.path.exists(w9xpopen):
+                # Eeek - file-not-found - possibly an embedding
+                # situation - see if we can locate it in sys.exec_prefix
+                w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),
+                                        &quot;w9xpopen.exe&quot;)
+                if not os.path.exists(w9xpopen):
+                    raise RuntimeError(&quot;Cannot locate w9xpopen.exe, which is &quot;
+                                       &quot;needed for Popen to work with your &quot;
+                                       &quot;shell or platform.&quot;)
+            return w9xpopen
+
+
+        def _execute_child(self, args, executable, preexec_fn, close_fds,
+                           cwd, env, universal_newlines,
+                           startupinfo, creationflags, shell,
+                           p2cread, p2cwrite,
+                           c2pread, c2pwrite,
+                           errread, errwrite):
+            &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;
+
+            if not isinstance(args, types.StringTypes):
+                args = list2cmdline(args)
+
+            # Process startup details
+            if startupinfo is None:
+                startupinfo = STARTUPINFO()
+            if None not in (p2cread, c2pwrite, errwrite):
+                startupinfo.dwFlags |= STARTF_USESTDHANDLES
+                startupinfo.hStdInput = p2cread
+                startupinfo.hStdOutput = c2pwrite
+                startupinfo.hStdError = errwrite
+
+            if shell:
+                startupinfo.dwFlags |= STARTF_USESHOWWINDOW
+                startupinfo.wShowWindow = SW_HIDE
+                comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)
+                args = comspec + &quot; /c &quot; + args
+                if (GetVersion() &gt;= 0x80000000L or
+                        os.path.basename(comspec).lower() == &quot;command.com&quot;):
+                    # Win9x, or using command.com on NT. We need to
+                    # use the w9xpopen intermediate program. For more
+                    # information, see KB Q150956
+                    # (<A HREF="http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp">http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp</A>)
+                    w9xpopen = self._find_w9xpopen()
+                    args = '&quot;%s&quot; %s' % (w9xpopen, args)
+                    # Not passing CREATE_NEW_CONSOLE has been known to
+                    # cause random failures on win9x.  Specifically a
+                    # dialog: &quot;Your program accessed mem currently in
+                    # use at xxx&quot; and a hopeful warning about the
+                    # stability of your system.  Cost is Ctrl+C wont
+                    # kill children.
+                    creationflags |= CREATE_NEW_CONSOLE
+
+            # Start the process
+            try:
+                hp, ht, pid, tid = CreateProcess(executable, args,
+                                         # no special security
+                                         None, None,
+                                         # must inherit handles to pass std
+                                         # handles
+                                         1,
+                                         creationflags,
+                                         env,
+                                         cwd,
+                                         startupinfo)
+            except pywintypes.error, e:
+                # Translate pywintypes.error to WindowsError, which is
+                # a subclass of OSError.  FIXME: We should really
+                # translate errno using _sys_errlist (or simliar), but
+                # how can this be done from Python?
+                raise WindowsError(*e.args)
+
+            # Retain the process handle, but close the thread handle
+            self._child_created = True
+            self._handle = hp
+            self.pid = pid
+            ht.Close()
+
+            # Child is launched. Close the parent's copy of those pipe
+            # handles that only the child should have open.  You need
+            # to make sure that no handles to the write end of the
+            # output pipe are maintained in this process or else the
+            # pipe will not close when the child process exits and the
+            # ReadFile will hang.
+            if p2cread is not None:
+                p2cread.Close()
+            if c2pwrite is not None:
+                c2pwrite.Close()
+            if errwrite is not None:
+                errwrite.Close()
+
+
+        def poll(self, _deadstate=None):
+            &quot;&quot;&quot;Check if child process has terminated.  Returns returncode
+            attribute.&quot;&quot;&quot;
+            if self.returncode is None:
+                if WaitForSingleObject(self._handle, 0) == WAIT_OBJECT_0:
+                    self.returncode = GetExitCodeProcess(self._handle)
+            return self.returncode
+
+
+        def wait(self):
+            &quot;&quot;&quot;Wait for child process to terminate.  Returns returncode
+            attribute.&quot;&quot;&quot;
+            if self.returncode is None:
+                obj = WaitForSingleObject(self._handle, INFINITE)
+                self.returncode = GetExitCodeProcess(self._handle)
+            return self.returncode
+
+
+        def _readerthread(self, fh, buffer):
+            buffer.append(fh.read())
+
+
+        def _communicate(self, input):
+            stdout = None # Return
+            stderr = None # Return
+
+            if self.stdout:
+                stdout = []
+                stdout_thread = threading.Thread(target=self._readerthread,
+                                                 args=(self.stdout, stdout))
+                stdout_thread.setDaemon(True)
+                stdout_thread.start()
+            if self.stderr:
+                stderr = []
+                stderr_thread = threading.Thread(target=self._readerthread,
+                                                 args=(self.stderr, stderr))
+                stderr_thread.setDaemon(True)
+                stderr_thread.start()
+
+            if self.stdin:
+                if input is not None:
+                    self.stdin.write(input)
+                self.stdin.close()
+
+            if self.stdout:
+                stdout_thread.join()
+            if self.stderr:
+                stderr_thread.join()
+
+            # All data exchanged.  Translate lists into strings.
+            if stdout is not None:
+                stdout = stdout[0]
+            if stderr is not None:
+                stderr = stderr[0]
+
+            # Translate newlines, if requested.  We cannot let the file
+            # object do the translation: It is based on stdio, which is
+            # impossible to combine with select (unless forcing no
+            # buffering).
+            if self.universal_newlines and hasattr(file, 'newlines'):
+                if stdout:
+                    stdout = self._translate_newlines(stdout)
+                if stderr:
+                    stderr = self._translate_newlines(stderr)
+
+            self.wait()
+            return (stdout, stderr)
+
+    else:
+        #
+        # POSIX methods
+        #
+        def _get_handles(self, stdin, stdout, stderr):
+            &quot;&quot;&quot;Construct and return tupel with IO objects:
+            p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
+            &quot;&quot;&quot;
+            p2cread, p2cwrite = None, None
+            c2pread, c2pwrite = None, None
+            errread, errwrite = None, None
+
+            if stdin is None:
+                pass
+            elif stdin == PIPE:
+                p2cread, p2cwrite = os.pipe()
+            elif isinstance(stdin, int):
+                p2cread = stdin
+            else:
+                # Assuming file-like object
+                p2cread = stdin.fileno()
+
+            if stdout is None:
+                pass
+            elif stdout == PIPE:
+                c2pread, c2pwrite = os.pipe()
+            elif isinstance(stdout, int):
+                c2pwrite = stdout
+            else:
+                # Assuming file-like object
+                c2pwrite = stdout.fileno()
+
+            if stderr is None:
+                pass
+            elif stderr == PIPE:
+                errread, errwrite = os.pipe()
+            elif stderr == STDOUT:
+                errwrite = c2pwrite
+            elif isinstance(stderr, int):
+                errwrite = stderr
+            else:
+                # Assuming file-like object
+                errwrite = stderr.fileno()
+
+            return (p2cread, p2cwrite,
+                    c2pread, c2pwrite,
+                    errread, errwrite)
+
+
+        def _set_cloexec_flag(self, fd):
+            try:
+                cloexec_flag = fcntl.FD_CLOEXEC
+            except AttributeError:
+                cloexec_flag = 1
+
+            old = fcntl.fcntl(fd, fcntl.F_GETFD)
+            fcntl.fcntl(fd, fcntl.F_SETFD, old | cloexec_flag)
+
+
+        def _close_fds(self, but):
+            for i in xrange(3, MAXFD):
+                if i == but:
+                    continue
+                try:
+                    os.close(i)
+                except:
+                    pass
+
+
+        def _execute_child(self, args, executable, preexec_fn, close_fds,
+                           cwd, env, universal_newlines,
+                           startupinfo, creationflags, shell,
+                           p2cread, p2cwrite,
+                           c2pread, c2pwrite,
+                           errread, errwrite):
+            &quot;&quot;&quot;Execute program (POSIX version)&quot;&quot;&quot;
+
+            if isinstance(args, types.StringTypes):
+                args = [args]
+            else:
+                args = list(args)
+
+            if shell:
+                args = [&quot;/bin/sh&quot;, &quot;-c&quot;] + args
+
+            if executable is None:
+                executable = args[0]
+
+            # For transferring possible exec failure from child to parent
+            # The first char specifies the exception type: 0 means
+            # OSError, 1 means some other error.
+            errpipe_read, errpipe_write = os.pipe()
+            self._set_cloexec_flag(errpipe_write)
+
+            gc_was_enabled = gc.isenabled()
+            # Disable gc to avoid bug where gc -&gt; file_dealloc -&gt;
+            # write to stderr -&gt; hang.  <A HREF="http://bugs.python.org/issue1336">http://bugs.python.org/issue1336</A>
+            gc.disable()
+            try:
+                self.pid = os.fork()
+            except:
+                if gc_was_enabled:
+                    gc.enable()
+                raise
+            self._child_created = True
+            if self.pid == 0:
+                # Child
+                try:
+                    # Close parent's pipe ends
+                    if p2cwrite:
+                        os.close(p2cwrite)
+                    if c2pread:
+                        os.close(c2pread)
+                    if errread:
+                        os.close(errread)
+                    os.close(errpipe_read)
+
+                    # Dup fds for child
+                    if p2cread:
+                        os.dup2(p2cread, 0)
+                    if c2pwrite:
+                        os.dup2(c2pwrite, 1)
+                    if errwrite:
+                        os.dup2(errwrite, 2)
+
+                    # Close pipe fds.  Make sure we don't close the same
+                    # fd more than once, or standard fds.
+                    if p2cread and p2cread not in (0,):
+                        os.close(p2cread)
+                    if c2pwrite and c2pwrite not in (p2cread, 1):
+                        os.close(c2pwrite)
+                    if errwrite and errwrite not in (p2cread, c2pwrite, 2):
+                        os.close(errwrite)
+
+                    # Close all other fds, if asked for
+                    if close_fds:
+                        self._close_fds(but=errpipe_write)
+
+                    if cwd is not None:
+                        os.chdir(cwd)
+
+                    if preexec_fn:
+                        apply(preexec_fn)
+
+                    if env is None:
+                        os.execvp(executable, args)
+                    else:
+                        os.execvpe(executable, args, env)
+
+                except:
+                    exc_type, exc_value, tb = sys.exc_info()
+                    # Save the traceback and attach it to the exception object
+                    exc_lines = traceback.format_exception(exc_type,
+                                                           exc_value,
+                                                           tb)
+                    exc_value.child_traceback = ''.join(exc_lines)
+                    os.write(errpipe_write, pickle.dumps(exc_value))
+
+                # This exitcode won't be reported to applications, so it
+                # really doesn't matter what we return.
+                os._exit(255)
+
+            # Parent
+            if gc_was_enabled:
+                gc.enable()
+            os.close(errpipe_write)
+            if p2cread and p2cwrite:
+                os.close(p2cread)
+            if c2pwrite and c2pread:
+                os.close(c2pwrite)
+            if errwrite and errread:
+                os.close(errwrite)
+
+            # Wait for exec to fail or succeed; possibly raising exception
+            data = os.read(errpipe_read, 1048576) # Exceptions limited to 1 MB
+            os.close(errpipe_read)
+            if data != &quot;&quot;:
+                os.waitpid(self.pid, 0)
+                child_exception = pickle.loads(data)
+                raise child_exception
+
+
+        def _handle_exitstatus(self, sts):
+            if os.WIFSIGNALED(sts):
+                self.returncode = -os.WTERMSIG(sts)
+            elif os.WIFEXITED(sts):
+                self.returncode = os.WEXITSTATUS(sts)
+            else:
+                # Should never happen
+                raise RuntimeError(&quot;Unknown child exit status!&quot;)
+
+
+        def poll(self, _deadstate=None):
+            &quot;&quot;&quot;Check if child process has terminated.  Returns returncode
+            attribute.&quot;&quot;&quot;
+            if self.returncode is None:
+                try:
+                    pid, sts = os.waitpid(self.pid, os.WNOHANG)
+                    if pid == self.pid:
+                        self._handle_exitstatus(sts)
+                except os.error:
+                    if _deadstate is not None:
+                        self.returncode = _deadstate
+            return self.returncode
+
+
+        def wait(self):
+            &quot;&quot;&quot;Wait for child process to terminate.  Returns returncode
+            attribute.&quot;&quot;&quot;
+            if self.returncode is None:
+                pid, sts = os.waitpid(self.pid, 0)
+                self._handle_exitstatus(sts)
+            return self.returncode
+
+
+        def _communicate(self, input):
+            read_set = []
+            write_set = []
+            stdout = None # Return
+            stderr = None # Return
+
+            if self.stdin:
+                # Flush stdio buffer.  This might block, if the user has
+                # been writing to .stdin in an uncontrolled fashion.
+                self.stdin.flush()
+                if input:
+                    write_set.append(self.stdin)
+                else:
+                    self.stdin.close()
+            if self.stdout:
+                read_set.append(self.stdout)
+                stdout = []
+            if self.stderr:
+                read_set.append(self.stderr)
+                stderr = []
+
+            input_offset = 0
+            while read_set or write_set:
+                rlist, wlist, xlist = select.select(read_set, write_set, [])
+
+                if self.stdin in wlist:
+                    # When select has indicated that the file is writable,
+                    # we can write up to PIPE_BUF bytes without risk
+                    # blocking.  POSIX defines PIPE_BUF &gt;= 512
+                    bytes_written = os.write(self.stdin.fileno(), buffer(input, input_offset, 512))
+                    input_offset += bytes_written
+                    if input_offset &gt;= len(input):
+                        self.stdin.close()
+                        write_set.remove(self.stdin)
+
+                if self.stdout in rlist:
+                    data = os.read(self.stdout.fileno(), 1024)
+                    if data == &quot;&quot;:
+                        self.stdout.close()
+                        read_set.remove(self.stdout)
+                    stdout.append(data)
+
+                if self.stderr in rlist:
+                    data = os.read(self.stderr.fileno(), 1024)
+                    if data == &quot;&quot;:
+                        self.stderr.close()
+                        read_set.remove(self.stderr)
+                    stderr.append(data)
+
+            # All data exchanged.  Translate lists into strings.
+            if stdout is not None:
+                stdout = ''.join(stdout)
+            if stderr is not None:
+                stderr = ''.join(stderr)
+
+            # Translate newlines, if requested.  We cannot let the file
+            # object do the translation: It is based on stdio, which is
+            # impossible to combine with select (unless forcing no
+            # buffering).
+            if self.universal_newlines and hasattr(file, 'newlines'):
+                if stdout:
+                    stdout = self._translate_newlines(stdout)
+                if stderr:
+                    stderr = self._translate_newlines(stderr)
+
+            self.wait()
+            return (stdout, stderr)
+
+
+def _demo_posix():
+    #
+    # Example 1: Simple redirection: Get process list
+    #
+    plist = Popen([&quot;ps&quot;], stdout=PIPE).communicate()[0]
+    print &quot;Process list:&quot;
+    print plist
+
+    #
+    # Example 2: Change uid before executing child
+    #
+    if os.getuid() == 0:
+        p = Popen([&quot;id&quot;], preexec_fn=lambda: os.setuid(100))
+        p.wait()
+
+    #
+    # Example 3: Connecting several subprocesses
+    #
+    print &quot;Looking for 'hda'...&quot;
+    p1 = Popen([&quot;dmesg&quot;], stdout=PIPE)
+    p2 = Popen([&quot;grep&quot;, &quot;hda&quot;], stdin=p1.stdout, stdout=PIPE)
+    print repr(p2.communicate()[0])
+
+    #
+    # Example 4: Catch execution error
+    #
+    print
+    print &quot;Trying a weird file...&quot;
+    try:
+        print Popen([&quot;/this/path/does/not/exist&quot;]).communicate()
+    except OSError, e:
+        if e.errno == errno.ENOENT:
+            print &quot;The file didn't exist.  I thought so...&quot;
+            print &quot;Child traceback:&quot;
+            print e.child_traceback
+        else:
+            print &quot;Error&quot;, e.errno
+    else:
+        print &gt;&gt;sys.stderr, &quot;Gosh.  No error.&quot;
+
+
+def _demo_windows():
+    #
+    # Example 1: Connecting several subprocesses
+    #
+    print &quot;Looking for 'PROMPT' in set output...&quot;
+    p1 = Popen(&quot;set&quot;, stdout=PIPE, shell=True)
+    p2 = Popen('find &quot;PROMPT&quot;', stdin=p1.stdout, stdout=PIPE)
+    print repr(p2.communicate()[0])
+
+    #
+    # Example 2: Simple execution of program
+    #
+    print &quot;Executing calc...&quot;
+    p = Popen(&quot;calc&quot;)
+    p.wait()
+
+
+if __name__ == &quot;__main__&quot;:
+    if mswindows:
+        _demo_windows()
+    else:
+        _demo_posix()

Added: Lobby/TASClient/Python/modules/threading.py
===================================================================
--- Lobby/TASClient/Python/modules/threading.py	                        (rev 0)
+++ Lobby/TASClient/Python/modules/threading.py	2010-02-25 22:10:10 UTC (rev 7419)
@@ -0,0 +1,854 @@
+&quot;&quot;&quot;Thread module emulating a subset of Java's threading model.&quot;&quot;&quot;
+
+import sys as _sys
+
+try:
+    import thread
+except ImportError:
+    del _sys.modules[__name__]
+    raise
+
+from time import time as _time, sleep as _sleep
+from traceback import format_exc as _format_exc
+from collections import deque
+
+# Rename some stuff so &quot;from threading import *&quot; is safe
+__all__ = ['activeCount', 'Condition', 'currentThread', 'enumerate', 'Event',
+           'Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Thread',
+           'Timer', 'setprofile', 'settrace', 'local', 'stack_size']
+
+_start_new_thread = thread.start_new_thread
+_allocate_lock = thread.allocate_lock
+_get_ident = thread.get_ident
+ThreadError = thread.error
+del thread
+
+
+# Debug support (adapted from ihooks.py).
+# All the major classes here derive from _Verbose.  We force that to
+# be a new-style class so that all the major classes here are new-style.
+# This helps debugging (type(instance) is more revealing for instances
+# of new-style classes).
+
+_VERBOSE = False
+
+if __debug__:
+
+    class _Verbose(object):
+
+        def __init__(self, verbose=None):
+            if verbose is None:
+                verbose = _VERBOSE
+            self.__verbose = verbose
+
+        def _note(self, format, *args):
+            if self.__verbose:
+                format = format % args
+                format = &quot;%s: %s\n&quot; % (
+                    currentThread().getName(), format)
+                _sys.stderr.write(format)
+
+else:
+    # Disable this when using &quot;python -O&quot;
+    class _Verbose(object):
+        def __init__(self, verbose=None):
+            pass
+        def _note(self, *args):
+            pass
+
+# Support for profile and trace hooks
+
+_profile_hook = None
+_trace_hook = None
+
+def setprofile(func):
+    global _profile_hook
+    _profile_hook = func
+
+def settrace(func):
+    global _trace_hook
+    _trace_hook = func
+
+# Synchronization classes
+
+Lock = _allocate_lock
+
+def RLock(*args, **kwargs):
+    return _RLock(*args, **kwargs)
+
+class _RLock(_Verbose):
+
+    def __init__(self, verbose=None):
+        _Verbose.__init__(self, verbose)
+        self.__block = _allocate_lock()
+        self.__owner = None
+        self.__count = 0
+
+    def __repr__(self):
+        owner = self.__owner
+        return &quot;&lt;%s(%s, %d)&gt;&quot; % (
+                self.__class__.__name__,
+                owner and owner.getName(),
+                self.__count)
+
+    def acquire(self, blocking=1):
+        me = currentThread()
+        if self.__owner is me:
+            self.__count = self.__count + 1
+            if __debug__:
+                self._note(&quot;%s.acquire(%s): recursive success&quot;, self, blocking)
+            return 1
+        rc = self.__block.acquire(blocking)
+        if rc:
+            self.__owner = me
+            self.__count = 1
+            if __debug__:
+                self._note(&quot;%s.acquire(%s): initial success&quot;, self, blocking)
+        else:
+            if __debug__:
+                self._note(&quot;%s.acquire(%s): failure&quot;, self, blocking)
+        return rc
+
+    __enter__ = acquire
+
+    def release(self):
+        if self.__owner is not currentThread():
+            raise RuntimeError(&quot;cannot release un-aquired lock&quot;)
+        self.__count = count = self.__count - 1
+        if not count:
+            self.__owner = None
+            self.__block.release()
+            if __debug__:
+                self._note(&quot;%s.release(): final release&quot;, self)
+        else:
+            if __debug__:
+                self._note(&quot;%s.release(): non-final release&quot;, self)
+
+    def __exit__(self, t, v, tb):
+        self.release()
+
+    # Internal methods used by condition variables
+
+    def _acquire_restore(self, (count, owner)):
+        self.__block.acquire()
+        self.__count = count
+        self.__owner = owner
+        if __debug__:
+            self._note(&quot;%s._acquire_restore()&quot;, self)
+
+    def _release_save(self):
+        if __debug__:
+            self._note(&quot;%s._release_save()&quot;, self)
+        count = self.__count
+        self.__count = 0
+        owner = self.__owner
+        self.__owner = None
+        self.__block.release()
+        return (count, owner)
+
+    def _is_owned(self):
+        return self.__owner is currentThread()
+
+
+def Condition(*args, **kwargs):
+    return _Condition(*args, **kwargs)
+
+class _Condition(_Verbose):
+
+    def __init__(self, lock=None, verbose=None):
+        _Verbose.__init__(self, verbose)
+        if lock is None:
+            lock = RLock()
+        self.__lock = lock
+        # Export the lock's acquire() and release() methods
+        self.acquire = lock.acquire
+        self.release = lock.release
+        # If the lock defines _release_save() and/or _acquire_restore(),
+        # these override the default implementations (which just call
+        # release() and acquire() on the lock).  Ditto for _is_owned().
+        try:
+            self._release_save = lock._release_save
+        except AttributeError:
+            pass
+        try:
+            self._acquire_restore = lock._acquire_restore
+        except AttributeError:
+            pass
+        try:
+            self._is_owned = lock._is_owned
+        except AttributeError:
+            pass
+        self.__waiters = []
+
+    def __enter__(self):
+        return self.__lock.__enter__()
+
+    def __exit__(self, *args):
+        return self.__lock.__exit__(*args)
+
+    def __repr__(self):
+        return &quot;&lt;Condition(%s, %d)&gt;&quot; % (self.__lock, len(self.__waiters))
+
+    def _release_save(self):
+        self.__lock.release()           # No state to save
+
+    def _acquire_restore(self, x):
+        self.__lock.acquire()           # Ignore saved state
+
+    def _is_owned(self):
+        # Return True if lock is owned by currentThread.
+        # This method is called only if __lock doesn't have _is_owned().
+        if self.__lock.acquire(0):
+            self.__lock.release()
+            return False
+        else:
+            return True
+
+    def wait(self, timeout=None):
+        if not self._is_owned():
+            raise RuntimeError(&quot;cannot wait on un-aquired lock&quot;)
+        waiter = _allocate_lock()
+        waiter.acquire()
+        self.__waiters.append(waiter)
+        saved_state = self._release_save()
+        try:    # restore state no matter what (e.g., KeyboardInterrupt)
+            if timeout is None:
+                waiter.acquire()
+                if __debug__:
+                    self._note(&quot;%s.wait(): got it&quot;, self)
+            else:
+                # Balancing act:  We can't afford a pure busy loop, so we
+                # have to sleep; but if we sleep the whole timeout time,
+                # we'll be unresponsive.  The scheme here sleeps very
+                # little at first, longer as time goes on, but never longer
+                # than 20 times per second (or the timeout time remaining).
+                endtime = _time() + timeout
+                delay = 0.0005 # 500 us -&gt; initial delay of 1 ms
+                while True:
+                    gotit = waiter.acquire(0)
+                    if gotit:
+                        break
+                    remaining = endtime - _time()
+                    if remaining &lt;= 0:
+                        break
+                    delay = min(delay * 2, remaining, .05)
+                    _sleep(delay)
+                if not gotit:
+                    if __debug__:
+                        self._note(&quot;%s.wait(%s): timed out&quot;, self, timeout)
+                    try:
+                        self.__waiters.remove(waiter)
+                    except ValueError:
+                        pass
+                else:
+                    if __debug__:
+                        self._note(&quot;%s.wait(%s): got it&quot;, self, timeout)
+        finally:
+            self._acquire_restore(saved_state)
+
+    def notify(self, n=1):
+        if not self._is_owned():
+            raise RuntimeError(&quot;cannot notify on un-aquired lock&quot;)
+        __waiters = self.__waiters
+        waiters = __waiters[:n]
+        if not waiters:
+            if __debug__:
+                self._note(&quot;%s.notify(): no waiters&quot;, self)
+            return
+        self._note(&quot;%s.notify(): notifying %d waiter%s&quot;, self, n,
+                   n!=1 and &quot;s&quot; or &quot;&quot;)
+        for waiter in waiters:
+            waiter.release()
+            try:
+                __waiters.remove(waiter)
+            except ValueError:
+                pass
+
+    def notifyAll(self):
+        self.notify(len(self.__waiters))
+
+
+def Semaphore(*args, **kwargs):
+    return _Semaphore(*args, **kwargs)
+
+class _Semaphore(_Verbose):
+
+    # After Tim Peters' semaphore class, but not quite the same (no maximum)
+
+    def __init__(self, value=1, verbose=None):
+        if value &lt; 0:
+            raise ValueError(&quot;semaphore initial value must be &gt;= 0&quot;)
+        _Verbose.__init__(self, verbose)
+        self.__cond = Condition(Lock())
+        self.__value = value
+
+    def acquire(self, blocking=1):
+        rc = False
+        self.__cond.acquire()
+        while self.__value == 0:
+            if not blocking:
+                break
+            if __debug__:
+                self._note(&quot;%s.acquire(%s): blocked waiting, value=%s&quot;,
+                           self, blocking, self.__value)
+            self.__cond.wait()
+        else:
+            self.__value = self.__value - 1
+            if __debug__:
+                self._note(&quot;%s.acquire: success, value=%s&quot;,
+                           self, self.__value)
+            rc = True
+        self.__cond.release()
+        return rc
+
+    __enter__ = acquire
+
+    def release(self):
+        self.__cond.acquire()
+        self.__value = self.__value + 1
+        if __debug__:
+            self._note(&quot;%s.release: success, value=%s&quot;,
+                       self, self.__value)
+        self.__cond.notify()
+        self.__cond.release()
+
+    def __exit__(self, t, v, tb):
+        self.release()
+
+
+def BoundedSemaphore(*args, **kwargs):
+    return _BoundedSemaphore(*args, **kwargs)
+
+class _BoundedSemaphore(_Semaphore):
+    &quot;&quot;&quot;Semaphore that checks that # releases is &lt;= # acquires&quot;&quot;&quot;
+    def __init__(self, value=1, verbose=None):
+        _Semaphore.__init__(self, value, verbose)
+        self._initial_value = value
+
+    def release(self):
+        if self._Semaphore__value &gt;= self._initial_value:
+            raise ValueError, &quot;Semaphore released too many times&quot;
+        return _Semaphore.release(self)
+
+
+def Event(*args, **kwargs):
+    return _Event(*args, **kwargs)
+
+class _Event(_Verbose):
+
+    # After Tim Peters' event class (without is_posted())
+
+    def __init__(self, verbose=None):
+        _Verbose.__init__(self, verbose)
+        self.__cond = Condition(Lock())
+        self.__flag = False
+
+    def isSet(self):
+        return self.__flag
+
+    def set(self):
+        self.__cond.acquire()
+        try:
+            self.__flag = True
+            self.__cond.notifyAll()
+        finally:
+            self.__cond.release()
+
+    def clear(self):
+        self.__cond.acquire()
+        try:
+            self.__flag = False
+        finally:
+            self.__cond.release()
+
+    def wait(self, timeout=None):
+        self.__cond.acquire()
+        try:
+            if not self.__flag:
+                self.__cond.wait(timeout)
+        finally:
+            self.__cond.release()
+
+# Helper to generate new thread names
+_counter = 0
+def _newname(template=&quot;Thread-%d&quot;):
+    global _counter
+    _counter = _counter + 1
+    return template % _counter
+
+# Active thread administration
+_active_limbo_lock = _allocate_lock()
+_active = {}    # maps thread id to Thread object
+_limbo = {}
+
+
+# Main class for threads
+
+class Thread(_Verbose):
+
+    __initialized = False
+    # Need to store a reference to sys.exc_info for printing
+    # out exceptions when a thread tries to use a global var. during interp.
+    # shutdown and thus raises an exception about trying to perform some
+    # operation on/with a NoneType
+    __exc_info = _sys.exc_info
+
+    def __init__(self, group=None, target=None, name=None,
+                 args=(), kwargs=None, verbose=None):
+        assert group is None, &quot;group argument must be None for now&quot;
+        _Verbose.__init__(self, verbose)
+        if kwargs is None:
+            kwargs = {}
+        self.__target = target
+        self.__name = str(name or _newname())
+        self.__args = args
+        self.__kwargs = kwargs
+        self.__daemonic = self._set_daemon()
+        self.__started = False
+        self.__stopped = False
+        self.__block = Condition(Lock())
+        self.__initialized = True
+        # sys.stderr is not stored in the class like
+        # sys.exc_info since it can be changed between instances
+        self.__stderr = _sys.stderr
+
+    def _set_daemon(self):
+        # Overridden in _MainThread and _DummyThread
+        return currentThread().isDaemon()
+
+    def __repr__(self):
+        assert self.__initialized, &quot;Thread.__init__() was not called&quot;
+        status = &quot;initial&quot;
+        if self.__started:
+            status = &quot;started&quot;
+        if self.__stopped:
+            status = &quot;stopped&quot;
+        if self.__daemonic:
+            status = status + &quot; daemon&quot;
+        return &quot;&lt;%s(%s, %s)&gt;&quot; % (self.__class__.__name__, self.__name, status)
+
+    def start(self):
+        if not self.__initialized:
+            raise RuntimeError(&quot;thread.__init__() not called&quot;)
+        if self.__started:
+            raise RuntimeError(&quot;thread already started&quot;)
+        if __debug__:
+            self._note(&quot;%s.start(): starting thread&quot;, self)
+        _active_limbo_lock.acquire()
+        _limbo[self] = self
+        _active_limbo_lock.release()
+        _start_new_thread(self.__bootstrap, ())
+        self.__started = True
+        _sleep(0.000001)    # 1 usec, to let the thread run (Solaris hack)
+
+    def run(self):
+        if self.__target:
+            self.__target(*self.__args, **self.__kwargs)
+
+    def __bootstrap(self):
+        # Wrapper around the real bootstrap code that ignores
+        # exceptions during interpreter cleanup.  Those typically
+        # happen when a daemon thread wakes up at an unfortunate
+        # moment, finds the world around it destroyed, and raises some
+        # random exception *** while trying to report the exception in
+        # __bootstrap_inner() below ***.  Those random exceptions
+        # don't help anybody, and they confuse users, so we suppress
+        # them.  We suppress them only when it appears that the world
+        # indeed has already been destroyed, so that exceptions in
+        # __bootstrap_inner() during normal business hours are properly
+        # reported.  Also, we only suppress them for daemonic threads;
+        # if a non-daemonic encounters this, something else is wrong.
+        try:
+            self.__bootstrap_inner()
+        except:
+            if self.__daemonic and _sys is None:
+                return
+            raise
+
+    def __bootstrap_inner(self):
+        try:
+            self.__started = True
+            _active_limbo_lock.acquire()
+            _active[_get_ident()] = self
+            del _limbo[self]
+            _active_limbo_lock.release()
+            if __debug__:
+                self._note(&quot;%s.__bootstrap(): thread started&quot;, self)
+
+            if _trace_hook:
+                self._note(&quot;%s.__bootstrap(): registering trace hook&quot;, self)
+                _sys.settrace(_trace_hook)
+            if _profile_hook:
+                self._note(&quot;%s.__bootstrap(): registering profile hook&quot;, self)
+                _sys.setprofile(_profile_hook)
+
+            try:
+                self.run()
+            except SystemExit:
+                if __debug__:
+                    self._note(&quot;%s.__bootstrap(): raised SystemExit&quot;, self)
+            except:
+                if __debug__:
+                    self._note(&quot;%s.__bootstrap(): unhandled exception&quot;, self)
+                # If sys.stderr is no more (most likely from interpreter
+                # shutdown) use self.__stderr.  Otherwise still use sys (as in
+                # _sys) in case sys.stderr was redefined since the creation of
+                # self.
+                if _sys:
+                    _sys.stderr.write(&quot;Exception in thread %s:\n%s\n&quot; %
+                                      (self.getName(), _format_exc()))
+                else:
+                    # Do the best job possible w/o a huge amt. of code to
+                    # approximate a traceback (code ideas from
+                    # Lib/traceback.py)
+                    exc_type, exc_value, exc_tb = self.__exc_info()
+                    try:
+                        print&gt;&gt;self.__stderr, (
+                            &quot;Exception in thread &quot; + self.getName() +
+                            &quot; (most likely raised during interpreter shutdown):&quot;)
+                        print&gt;&gt;self.__stderr, (
+                            &quot;Traceback (most recent call last):&quot;)
+                        while exc_tb:
+                            print&gt;&gt;self.__stderr, (
+                                '  File &quot;%s&quot;, line %s, in %s' %
+                                (exc_tb.tb_frame.f_code.co_filename,
+                                    exc_tb.tb_lineno,
+                                    exc_tb.tb_frame.f_code.co_name))
+                            exc_tb = exc_tb.tb_next
+                        print&gt;&gt;self.__stderr, (&quot;%s: %s&quot; % (exc_type, exc_value))
+                    # Make sure that exc_tb gets deleted since it is a memory
+                    # hog; deleting everything else is just for thoroughness
+                    finally:
+                        del exc_type, exc_value, exc_tb
+            else:
+                if __debug__:
+                    self._note(&quot;%s.__bootstrap(): normal return&quot;, self)
+        finally:
+            _active_limbo_lock.acquire()
+            try:
+                self.__stop()
+                try:
+                    # We don't call self.__delete() because it also
+                    # grabs _active_limbo_lock.
+                    del _active[_get_ident()]
+                except:
+                    pass
+            finally:
+                _active_limbo_lock.release()
+
+    def __stop(self):
+        self.__block.acquire()
+        self.__stopped = True
+        self.__block.notifyAll()
+        self.__block.release()
+
+    def __delete(self):
+        &quot;Remove current thread from the dict of currently running threads.&quot;
+
+        # Notes about running with dummy_thread:
+        #
+        # Must take care to not raise an exception if dummy_thread is being
+        # used (and thus this module is being used as an instance of
+        # dummy_threading).  dummy_thread.get_ident() always returns -1 since
+        # there is only one thread if dummy_thread is being used.  Thus
+        # len(_active) is always &lt;= 1 here, and any Thread instance created
+        # overwrites the (if any) thread currently registered in _active.
+        #
+        # An instance of _MainThread is always created by 'threading'.  This
+        # gets overwritten the instant an instance of Thread is created; both
+        # threads return -1 from dummy_thread.get_ident() and thus have the
+        # same key in the dict.  So when the _MainThread instance created by
+        # 'threading' tries to clean itself up when atexit calls this method
+        # it gets a KeyError if another Thread instance was created.
+        #
+        # This all means that KeyError from trying to delete something from
+        # _active if dummy_threading is being used is a red herring.  But
+        # since it isn't if dummy_threading is *not* being used then don't
+        # hide the exception.
+
+        _active_limbo_lock.acquire()
+        try:
+            try:
+                del _active[_get_ident()]
+            except KeyError:
+                if 'dummy_threading' not in _sys.modules:
+                    raise
+        finally:
+            _active_limbo_lock.release()
+
+    def join(self, timeout=None):
+        if not self.__initialized:
+            raise RuntimeError(&quot;Thread.__init__() not called&quot;)
+        if not self.__started:
+            raise RuntimeError(&quot;cannot join thread before it is started&quot;)
+        if self is currentThread():
+            raise RuntimeError(&quot;cannot join current thread&quot;)
+
+        if __debug__:
+            if not self.__stopped:
+                self._note(&quot;%s.join(): waiting until thread stops&quot;, self)
+        self.__block.acquire()
+        try:
+            if timeout is None:
+                while not self.__stopped:
+                    self.__block.wait()
+                if __debug__:
+                    self._note(&quot;%s.join(): thread stopped&quot;, self)
+            else:
+                deadline = _time() + timeout
+                while not self.__stopped:
+                    delay = deadline - _time()
+                    if delay &lt;= 0:
+                        if __debug__:
+                            self._note(&quot;%s.join(): timed out&quot;, self)
+                        break
+                    self.__block.wait(delay)
+                else:
+                    if __debug__:
+                        self._note(&quot;%s.join(): thread stopped&quot;, self)
+        finally:
+            self.__block.release()
+
+    def getName(self):
+        assert self.__initialized, &quot;Thread.__init__() not called&quot;
+        return self.__name
+
+    def setName(self, name):
+        assert self.__initialized, &quot;Thread.__init__() not called&quot;
+        self.__name = str(name)
+
+    def isAlive(self):
+        assert self.__initialized, &quot;Thread.__init__() not called&quot;
+        return self.__started and not self.__stopped
+
+    def isDaemon(self):
+        assert self.__initialized, &quot;Thread.__init__() not called&quot;
+        return self.__daemonic
+
+    def setDaemon(self, daemonic):
+        if not self.__initialized:
+            raise RuntimeError(&quot;Thread.__init__() not called&quot;)
+        if self.__started:
+            raise RuntimeError(&quot;cannot set daemon status of active thread&quot;);
+        self.__daemonic = daemonic
+
+# The timer class was contributed by Itamar Shtull-Trauring
+
+def Timer(*args, **kwargs):
+    return _Timer(*args, **kwargs)
+
+class _Timer(Thread):
+    &quot;&quot;&quot;Call a function after a specified number of seconds:
+
+    t = Timer(30.0, f, args=[], kwargs={})
+    t.start()
+    t.cancel() # stop the timer's action if it's still waiting
+    &quot;&quot;&quot;
+
+    def __init__(self, interval, function, args=[], kwargs={}):
+        Thread.__init__(self)
+        self.interval = interval
+        self.function = function
+        self.args = args
+        self.kwargs = kwargs
+        self.finished = Event()
+
+    def cancel(self):
+        &quot;&quot;&quot;Stop the timer if it hasn't finished yet&quot;&quot;&quot;
+        self.finished.set()
+
+    def run(self):
+        self.finished.wait(self.interval)
+        if not self.finished.isSet():
+            self.function(*self.args, **self.kwargs)
+        self.finished.set()
+
+# Special thread class to represent the main thread
+# This is garbage collected through an exit handler
+
+class _MainThread(Thread):
+
+    def __init__(self):
+        Thread.__init__(self, name=&quot;MainThread&quot;)
+        self._Thread__started = True
+        _active_limbo_lock.acquire()
+        _active[_get_ident()] = self
+        _active_limbo_lock.release()
+
+    def _set_daemon(self):
+        return False
+
+    def _exitfunc(self):
+        self._Thread__stop()
+        t = _pickSomeNonDaemonThread()
+        if t:
+            if __debug__:
+                self._note(&quot;%s: waiting for other threads&quot;, self)
+        while t:
+            t.join()
+            t = _pickSomeNonDaemonThread()
+        if __debug__:
+            self._note(&quot;%s: exiting&quot;, self)
+        self._Thread__delete()
+
+def _pickSomeNonDaemonThread():
+    for t in enumerate():
+        if not t.isDaemon() and t.isAlive():
+            return t
+    return None
+
+
+# Dummy thread class to represent threads not started here.
+# These aren't garbage collected when they die, nor can they be waited for.
+# If they invoke anything in threading.py that calls currentThread(), they
+# leave an entry in the _active dict forever after.
+# Their purpose is to return *something* from currentThread().
+# They are marked as daemon threads so we won't wait for them
+# when we exit (conform previous semantics).
+
+class _DummyThread(Thread):
+
+    def __init__(self):
+        Thread.__init__(self, name=_newname(&quot;Dummy-%d&quot;))
+
+        # Thread.__block consumes an OS-level locking primitive, which
+        # can never be used by a _DummyThread.  Since a _DummyThread
+        # instance is immortal, that's bad, so release this resource.
+        del self._Thread__block
+
+        self._Thread__started = True
+        _active_limbo_lock.acquire()
+        _active[_get_ident()] = self
+        _active_limbo_lock.release()
+
+    def _set_daemon(self):
+        return True
+
+    def join(self, timeout=None):
+        assert False, &quot;cannot join a dummy thread&quot;
+
+
+# Global API functions
+
+def currentThread():
+    try:
+        return _active[_get_ident()]
+    except KeyError:
+        ##print &quot;currentThread(): no current thread for&quot;, _get_ident()
+        return _DummyThread()
+
+def activeCount():
+    _active_limbo_lock.acquire()
+    count = len(_active) + len(_limbo)
+    _active_limbo_lock.release()
+    return count
+
+def enumerate():
+    _active_limbo_lock.acquire()
+    active = _active.values() + _limbo.values()
+    _active_limbo_lock.release()
+    return active
+
+from thread import stack_size
+
+# Create the main thread object,
+# and make it available for the interpreter
+# (Py_Main) as threading._shutdown.
+
+_shutdown = _MainThread()._exitfunc
+
+# get thread-local implementation, either from the thread
+# module, or from the python fallback
+
+try:
+    from thread import _local as local
+except ImportError:
+    from _threading_local import local
+
+
+# Self-test code
+
+def _test():
+
+    class BoundedQueue(_Verbose):
+
+        def __init__(self, limit):
+            _Verbose.__init__(self)
+            self.mon = RLock()
+            self.rc = Condition(self.mon)
+            self.wc = Condition(self.mon)
+            self.limit = limit
+            self.queue = deque()
+
+        def put(self, item):
+            self.mon.acquire()
+            while len(self.queue) &gt;= self.limit:
+                self._note(&quot;put(%s): queue full&quot;, item)
+                self.wc.wait()
+            self.queue.append(item)
+            self._note(&quot;put(%s): appended, length now %d&quot;,
+                       item, len(self.queue))
+            self.rc.notify()
+            self.mon.release()
+
+        def get(self):
+            self.mon.acquire()
+            while not self.queue:
+                self._note(&quot;get(): queue empty&quot;)
+                self.rc.wait()
+            item = self.queue.popleft()
+            self._note(&quot;get(): got %s, %d left&quot;, item, len(self.queue))
+            self.wc.notify()
+            self.mon.release()
+            return item
+
+    class ProducerThread(Thread):
+
+        def __init__(self, queue, quota):
+            Thread.__init__(self, name=&quot;Producer&quot;)
+            self.queue = queue
+            self.quota = quota
+
+        def run(self):
+            from random import random
+            counter = 0
+            while counter &lt; self.quota:
+                counter = counter + 1
+                self.queue.put(&quot;%s.%d&quot; % (self.getName(), counter))
+                _sleep(random() * 0.00001)
+
+
+    class ConsumerThread(Thread):
+
+        def __init__(self, queue, count):
+            Thread.__init__(self, name=&quot;Consumer&quot;)
+            self.queue = queue
+            self.count = count
+
+        def run(self):
+            while self.count &gt; 0:
+                item = self.queue.get()
+                print item
+                self.count = self.count - 1
+
+    NP = 3
+    QL = 4
+    NI = 5
+
+    Q = BoundedQueue(QL)
+    P = []
+    for i in range(NP):
+        t = ProducerThread(Q, NI)
+        t.setName(&quot;Producer-%d&quot; % (i+1))
+        P.append(t)
+    C = ConsumerThread(Q, NI*NP)
+    for t in P:
+        t.start()
+        _sleep(0.000001)
+    C.start()
+    for t in P:
+        t.join()
+    C.join()
+
+if __name__ == '__main__':
+    _test()

Added: Lobby/TASClient/Python/modules/traceback.py
===================================================================
--- Lobby/TASClient/Python/modules/traceback.py	                        (rev 0)
+++ Lobby/TASClient/Python/modules/traceback.py	2010-02-25 22:10:10 UTC (rev 7419)
@@ -0,0 +1,312 @@
+&quot;&quot;&quot;Extract, format and print information about Python stack traces.&quot;&quot;&quot;
+
+import linecache
+import sys
+import types
+
+__all__ = ['extract_stack', 'extract_tb', 'format_exception',
+           'format_exception_only', 'format_list', 'format_stack',
+           'format_tb', 'print_exc', 'format_exc', 'print_exception',
+           'print_last', 'print_stack', 'print_tb', 'tb_lineno']
+
+def _print(file, str='', terminator='\n'):
+    file.write(str+terminator)
+
+
+def print_list(extracted_list, file=None):
+    &quot;&quot;&quot;Print the list of tuples as returned by extract_tb() or
+    extract_stack() as a formatted stack trace to the given file.&quot;&quot;&quot;
+    if file is None:
+        file = sys.stderr
+    for filename, lineno, name, line in extracted_list:
+        _print(file,
+               '  File &quot;%s&quot;, line %d, in %s' % (filename,lineno,name))
+        if line:
+            _print(file, '    %s' % line.strip())
+
+def format_list(extracted_list):
+    &quot;&quot;&quot;Format a list of traceback entry tuples for printing.
+
+    Given a list of tuples as returned by extract_tb() or
+    extract_stack(), return a list of strings ready for printing.
+    Each string in the resulting list corresponds to the item with the
+    same index in the argument list.  Each string ends in a newline;
+    the strings may contain internal newlines as well, for those items
+    whose source text line is not None.
+    &quot;&quot;&quot;
+    list = []
+    for filename, lineno, name, line in extracted_list:
+        item = '  File &quot;%s&quot;, line %d, in %s\n' % (filename,lineno,name)
+        if line:
+            item = item + '    %s\n' % line.strip()
+        list.append(item)
+    return list
+
+
+def print_tb(tb, limit=None, file=None):
+    &quot;&quot;&quot;Print up to 'limit' stack trace entries from the traceback 'tb'.
+
+    If 'limit' is omitted or None, all entries are printed.  If 'file'
+    is omitted or None, the output goes to sys.stderr; otherwise
+    'file' should be an open file or file-like object with a write()
+    method.
+    &quot;&quot;&quot;
+    if file is None:
+        file = sys.stderr
+    if limit is None:
+        if hasattr(sys, 'tracebacklimit'):
+            limit = sys.tracebacklimit
+    n = 0
+    while tb is not None and (limit is None or n &lt; limit):
+        f = tb.tb_frame
+        lineno = tb.tb_lineno
+        co = f.f_code
+        filename = co.co_filename
+        name = co.co_name
+        _print(file,
+               '  File &quot;%s&quot;, line %d, in %s' % (filename,lineno,name))
+        linecache.checkcache(filename)
+        line = linecache.getline(filename, lineno, f.f_globals)
+        if line: _print(file, '    ' + line.strip())
+        tb = tb.tb_next
+        n = n+1
+
+def format_tb(tb, limit = None):
+    &quot;&quot;&quot;A shorthand for 'format_list(extract_stack(f, limit)).&quot;&quot;&quot;
+    return format_list(extract_tb(tb, limit))
+
+def extract_tb(tb, limit = None):
+    &quot;&quot;&quot;Return list of up to limit pre-processed entries from traceback.
+
+    This is useful for alternate formatting of stack traces.  If
+    'limit' is omitted or None, all entries are extracted.  A
+    pre-processed stack trace entry is a quadruple (filename, line
+    number, function name, text) representing the information that is
+    usually printed for a stack trace.  The text is a string with
+    leading and trailing whitespace stripped; if the source is not
+    available it is None.
+    &quot;&quot;&quot;
+    if limit is None:
+        if hasattr(sys, 'tracebacklimit'):
+            limit = sys.tracebacklimit
+    list = []
+    n = 0
+    while tb is not None and (limit is None or n &lt; limit):
+        f = tb.tb_frame
+        lineno = tb.tb_lineno
+        co = f.f_code
+        filename = co.co_filename
+        name = co.co_name
+        linecache.checkcache(filename)
+        line = linecache.getline(filename, lineno, f.f_globals)
+        if line: line = line.strip()
+        else: line = None
+        list.append((filename, lineno, name, line))
+        tb = tb.tb_next
+        n = n+1
+    return list
+
+
+def print_exception(etype, value, tb, limit=None, file=None):
+    &quot;&quot;&quot;Print exception up to 'limit' stack trace entries from 'tb' to 'file'.
+
+    This differs from print_tb() in the following ways: (1) if
+    traceback is not None, it prints a header &quot;Traceback (most recent
+    call last):&quot;; (2) it prints the exception type and value after the
+    stack trace; (3) if type is SyntaxError and value has the
+    appropriate format, it prints the line where the syntax error
+    occurred with a caret on the next line indicating the approximate
+    position of the error.
+    &quot;&quot;&quot;
+    if file is None:
+        file = sys.stderr
+    if tb:
+        _print(file, 'Traceback (most recent call last):')
+        print_tb(tb, limit, file)
+    lines = format_exception_only(etype, value)
+    for line in lines[:-1]:
+        _print(file, line, ' ')
+    _print(file, lines[-1], '')
+
+def format_exception(etype, value, tb, limit = None):
+    &quot;&quot;&quot;Format a stack trace and the exception information.
+
+    The arguments have the same meaning as the corresponding arguments
+    to print_exception().  The return value is a list of strings, each
+    ending in a newline and some containing internal newlines.  When
+    these lines are concatenated and printed, exactly the same text is
+    printed as does print_exception().
+    &quot;&quot;&quot;
+    if tb:
+        list = ['Traceback (most recent call last):\n']
+        list = list + format_tb(tb, limit)
+    else:
+        list = []
+    list = list + format_exception_only(etype, value)
+    return list
+
+def format_exception_only(etype, value):
+    &quot;&quot;&quot;Format the exception part of a traceback.
+
+    The arguments are the exception type and value such as given by
+    sys.last_type and sys.last_value. The return value is a list of
+    strings, each ending in a newline.
+
+    Normally, the list contains a single string; however, for
+    SyntaxError exceptions, it contains several lines that (when
+    printed) display detailed information about where the syntax
+    error occurred.
+
+    The message indicating which exception occurred is always the last
+    string in the list.
+
+    &quot;&quot;&quot;
+
+    # An instance should not have a meaningful value parameter, but
+    # sometimes does, particularly for string exceptions, such as
+    # &gt;&gt;&gt; raise string1, string2  # deprecated
+    #
+    # Clear these out first because issubtype(string1, SyntaxError)
+    # would throw another exception and mask the original problem.
+    if (isinstance(etype, BaseException) or
+        isinstance(etype, types.InstanceType) or
+        etype is None or type(etype) is str):
+        return [_format_final_exc_line(etype, value)]
+
+    stype = etype.__name__
+
+    if not issubclass(etype, SyntaxError):
+        return [_format_final_exc_line(stype, value)]
+
+    # It was a syntax error; show exactly where the problem was found.
+    lines = []
+    try:
+        msg, (filename, lineno, offset, badline) = value
+    except Exception:
+        pass
+    else:
+        filename = filename or &quot;&lt;string&gt;&quot;
+        lines.append('  File &quot;%s&quot;, line %d\n' % (filename, lineno))
+        if badline is not None:
+            lines.append('    %s\n' % badline.strip())
+            if offset is not None:
+                caretspace = badline[:offset].lstrip()
+                # non-space whitespace (likes tabs) must be kept for alignment
+                caretspace = ((c.isspace() and c or ' ') for c in caretspace)
+                # only three spaces to account for offset1 == pos 0
+                lines.append('   %s^\n' % ''.join(caretspace))
+            value = msg
+
+    lines.append(_format_final_exc_line(stype, value))
+    return lines
+
+def _format_final_exc_line(etype, value):
+    &quot;&quot;&quot;Return a list of a single line -- normal case for format_exception_only&quot;&quot;&quot;
+    valuestr = _some_str(value)
+    if value is None or not valuestr:
+        line = &quot;%s\n&quot; % etype
+    else:
+        line = &quot;%s: %s\n&quot; % (etype, valuestr)
+    return line
+
+def _some_str(value):
+    try:
+        return str(value)
+    except:
+        return '&lt;unprintable %s object&gt;' % type(value).__name__
+
+
+def print_exc(limit=None, file=None):
+    &quot;&quot;&quot;Shorthand for 'print_exception(sys.exc_type, sys.exc_value, sys.exc_traceback, limit, file)'.
+    (In fact, it uses sys.exc_info() to retrieve the same information
+    in a thread-safe way.)&quot;&quot;&quot;
+    if file is None:
+        file = sys.stderr
+    try:
+        etype, value, tb = sys.exc_info()
+        print_exception(etype, value, tb, limit, file)
+    finally:
+        etype = value = tb = None
+
+
+def format_exc(limit=None):
+    &quot;&quot;&quot;Like print_exc() but return a string.&quot;&quot;&quot;
+    try:
+        etype, value, tb = sys.exc_info()
+        return ''.join(format_exception(etype, value, tb, limit))
+    finally:
+        etype = value = tb = None
+
+
+def print_last(limit=None, file=None):
+    &quot;&quot;&quot;This is a shorthand for 'print_exception(sys.last_type,
+    sys.last_value, sys.last_traceback, limit, file)'.&quot;&quot;&quot;
+    if file is None:
+        file = sys.stderr
+    print_exception(sys.last_type, sys.last_value, sys.last_traceback,
+                    limit, file)
+
+
+def print_stack(f=None, limit=None, file=None):
+    &quot;&quot;&quot;Print a stack trace from its invocation point.
+
+    The optional 'f' argument can be used to specify an alternate
+    stack frame at which to start. The optional 'limit' and 'file'
+    arguments have the same meaning as for print_exception().
+    &quot;&quot;&quot;
+    if f is None:
+        try:
+            raise ZeroDivisionError
+        except ZeroDivisionError:
+            f = sys.exc_info()[2].tb_frame.f_back
+    print_list(extract_stack(f, limit), file)
+
+def format_stack(f=None, limit=None):
+    &quot;&quot;&quot;Shorthand for 'format_list(extract_stack(f, limit))'.&quot;&quot;&quot;
+    if f is None:
+        try:
+            raise ZeroDivisionError
+        except ZeroDivisionError:
+            f = sys.exc_info()[2].tb_frame.f_back
+    return format_list(extract_stack(f, limit))
+
+def extract_stack(f=None, limit = None):
+    &quot;&quot;&quot;Extract the raw traceback from the current stack frame.
+
+    The return value has the same format as for extract_tb().  The
+    optional 'f' and 'limit' arguments have the same meaning as for
+    print_stack().  Each item in the list is a quadruple (filename,
+    line number, function name, text), and the entries are in order
+    from oldest to newest stack frame.
+    &quot;&quot;&quot;
+    if f is None:
+        try:
+            raise ZeroDivisionError
+        except ZeroDivisionError:
+            f = sys.exc_info()[2].tb_frame.f_back
+    if limit is None:
+        if hasattr(sys, 'tracebacklimit'):
+            limit = sys.tracebacklimit
+    list = []
+    n = 0
+    while f is not None and (limit is None or n &lt; limit):
+        lineno = f.f_lineno
+        co = f.f_code
+        filename = co.co_filename
+        name = co.co_name
+        linecache.checkcache(filename)
+        line = linecache.getline(filename, lineno, f.f_globals)
+        if line: line = line.strip()
+        else: line = None
+        list.append((filename, lineno, name, line))
+        f = f.f_back
+        n = n+1
+    list.reverse()
+    return list
+
+def tb_lineno(tb):
+    &quot;&quot;&quot;Calculate correct line number of traceback given in tb.
+
+    Obsolete in 2.3.
+    &quot;&quot;&quot;
+    return tb.tb_lineno

Added: Lobby/TASClient/Python/modules/webbrowser.py
===================================================================
--- Lobby/TASClient/Python/modules/webbrowser.py	                        (rev 0)
+++ Lobby/TASClient/Python/modules/webbrowser.py	2010-02-25 22:10:10 UTC (rev 7419)
@@ -0,0 +1,653 @@
+#! /usr/bin/env python
+&quot;&quot;&quot;Interfaces for launching and remotely controlling Web browsers.&quot;&quot;&quot;
+# Maintained by Georg Brandl.
+
+import os
+import shlex
+import sys
+import stat
+import subprocess
+import time
+
+__all__ = [&quot;Error&quot;, &quot;open&quot;, &quot;open_new&quot;, &quot;open_new_tab&quot;, &quot;get&quot;, &quot;register&quot;]
+
+class Error(Exception):
+    pass
+
+_browsers = {}          # Dictionary of available browser controllers
+_tryorder = []          # Preference order of available browsers
+
+def register(name, klass, instance=None, update_tryorder=1):
+    &quot;&quot;&quot;Register a browser connector and, optionally, connection.&quot;&quot;&quot;
+    _browsers[name.lower()] = [klass, instance]
+    if update_tryorder &gt; 0:
+        _tryorder.append(name)
+    elif update_tryorder &lt; 0:
+        _tryorder.insert(0, name)
+
+def get(using=None):
+    &quot;&quot;&quot;Return a browser launcher instance appropriate for the environment.&quot;&quot;&quot;
+    if using is not None:
+        alternatives = [using]
+    else:
+        alternatives = _tryorder
+    for browser in alternatives:
+        if '%s' in browser:
+            # User gave us a command line, split it into name and args
+            browser = shlex.split(browser)
+            if browser[-1] == '&amp;':
+                return BackgroundBrowser(browser[:-1])
+            else:
+                return GenericBrowser(browser)
+        else:
+            # User gave us a browser name or path.
+            try:
+                command = _browsers[browser.lower()]
+            except KeyError:
+                command = _synthesize(browser)
+            if command[1] is not None:
+                return command[1]
+            elif command[0] is not None:
+                return command[0]()
+    raise Error(&quot;could not locate runnable browser&quot;)
+
+# Please note: the following definition hides a builtin function.
+# It is recommended one does &quot;import webbrowser&quot; and uses webbrowser.open(url)
+# instead of &quot;from webbrowser import *&quot;.
+
+def open(url, new=0, autoraise=1):
+    for name in _tryorder:
+        browser = get(name)
+        if browser.open(url, new, autoraise):
+            return True
+    return False
+
+def open_new(url):
+    return open(url, 1)
+
+def open_new_tab(url):
+    return open(url, 2)
+
+
+def _synthesize(browser, update_tryorder=1):
+    &quot;&quot;&quot;Attempt to synthesize a controller base on existing controllers.
+
+    This is useful to create a controller when a user specifies a path to
+    an entry in the BROWSER environment variable -- we can copy a general
+    controller to operate using a specific installation of the desired
+    browser in this way.
+
+    If we can't create a controller in this way, or if there is no
+    executable for the requested browser, return [None, None].
+
+    &quot;&quot;&quot;
+    cmd = browser.split()[0]
+    if not _iscommand(cmd):
+        return [None, None]
+    name = os.path.basename(cmd)
+    try:
+        command = _browsers[name.lower()]
+    except KeyError:
+        return [None, None]
+    # now attempt to clone to fit the new name:
+    controller = command[1]
+    if controller and name.lower() == controller.basename:
+        import copy
+        controller = copy.copy(controller)
+        controller.name = browser
+        controller.basename = os.path.basename(browser)
+        register(browser, None, controller, update_tryorder)
+        return [None, controller]
+    return [None, None]
+
+
+if sys.platform[:3] == &quot;win&quot;:
+    def _isexecutable(cmd):
+        cmd = cmd.lower()
+        if os.path.isfile(cmd) and cmd.endswith((&quot;.exe&quot;, &quot;.bat&quot;)):
+            return True
+        for ext in &quot;.exe&quot;, &quot;.bat&quot;:
+            if os.path.isfile(cmd + ext):
+                return True
+        return False
+else:
+    def _isexecutable(cmd):
+        if os.path.isfile(cmd):
+            mode = os.stat(cmd)[stat.ST_MODE]
+            if mode &amp; stat.S_IXUSR or mode &amp; stat.S_IXGRP or mode &amp; stat.S_IXOTH:
+                return True
+        return False
+
+def _iscommand(cmd):
+    &quot;&quot;&quot;Return True if cmd is executable or can be found on the executable
+    search path.&quot;&quot;&quot;
+    if _isexecutable(cmd):
+        return True
+    path = os.environ.get(&quot;PATH&quot;)
+    if not path:
+        return False
+    for d in path.split(os.pathsep):
+        exe = os.path.join(d, cmd)
+        if _isexecutable(exe):
+            return True
+    return False
+
+
+# General parent classes
+
+class BaseBrowser(object):
+    &quot;&quot;&quot;Parent class for all browsers. Do not use directly.&quot;&quot;&quot;
+
+    args = ['%s']
+
+    def __init__(self, name=&quot;&quot;):
+        self.name = name
+        self.basename = name
+
+    def open(self, url, new=0, autoraise=1):
+        raise NotImplementedError
+
+    def open_new(self, url):
+        return self.open(url, 1)
+
+    def open_new_tab(self, url):
+        return self.open(url, 2)
+
+
+class GenericBrowser(BaseBrowser):
+    &quot;&quot;&quot;Class for all browsers started with a command
+       and without remote functionality.&quot;&quot;&quot;
+
+    def __init__(self, name):
+        if isinstance(name, basestring):
+            self.name = name
+            self.args = [&quot;%s&quot;]
+        else:
+            # name should be a list with arguments
+            self.name = name[0]
+            self.args = name[1:]
+        self.basename = os.path.basename(self.name)
+
+    def open(self, url, new=0, autoraise=1):
+        cmdline = [self.name] + [arg.replace(&quot;%s&quot;, url)
+                                 for arg in self.args]
+        try:
+            if sys.platform[:3] == 'win':
+                p = subprocess.Popen(cmdline)
+            else:
+                p = subprocess.Popen(cmdline, close_fds=True)
+            return not p.wait()
+        except OSError:
+            return False
+
+
+class BackgroundBrowser(GenericBrowser):
+    &quot;&quot;&quot;Class for all browsers which are to be started in the
+       background.&quot;&quot;&quot;
+
+    def open(self, url, new=0, autoraise=1):
+        cmdline = [self.name] + [arg.replace(&quot;%s&quot;, url)
+                                 for arg in self.args]
+        try:
+            if sys.platform[:3] == 'win':
+                p = subprocess.Popen(cmdline)
+            else:
+                setsid = getattr(os, 'setsid', None)
+                if not setsid:
+                    setsid = getattr(os, 'setpgrp', None)
+                p = subprocess.Popen(cmdline, close_fds=True, preexec_fn=setsid)
+            return (p.poll() is None)
+        except OSError:
+            return False
+
+
+class UnixBrowser(BaseBrowser):
+    &quot;&quot;&quot;Parent class for all Unix browsers with remote functionality.&quot;&quot;&quot;
+
+    raise_opts = None
+    remote_args = ['%action', '%s']
+    remote_action = None
+    remote_action_newwin = None
+    remote_action_newtab = None
+    background = False
+    redirect_stdout = True
+
+    def _invoke(self, args, remote, autoraise):
+        raise_opt = []
+        if remote and self.raise_opts:
+            # use autoraise argument only for remote invocation
+            autoraise = int(bool(autoraise))
+            opt = self.raise_opts[autoraise]
+            if opt: raise_opt = [opt]
+
+        cmdline = [self.name] + raise_opt + args
+
+        if remote or self.background:
+            inout = file(os.devnull, &quot;r+&quot;)
+        else:
+            # for TTY browsers, we need stdin/out
+            inout = None
+        # if possible, put browser in separate process group, so
+        # keyboard interrupts don't affect browser as well as Python
+        setsid = getattr(os, 'setsid', None)
+        if not setsid:
+            setsid = getattr(os, 'setpgrp', None)
+
+        p = subprocess.Popen(cmdline, close_fds=True, stdin=inout,
+                             stdout=(self.redirect_stdout and inout or None),
+                             stderr=inout, preexec_fn=setsid)
+        if remote:
+            # wait five secons. If the subprocess is not finished, the
+            # remote invocation has (hopefully) started a new instance.
+            time.sleep(1)
+            rc = p.poll()
+            if rc is None:
+                time.sleep(4)
+                rc = p.poll()
+                if rc is None:
+                    return True
+            # if remote call failed, open() will try direct invocation
+            return not rc
+        elif self.background:
+            if p.poll() is None:
+                return True
+            else:
+                return False
+        else:
+            return not p.wait()
+
+    def open(self, url, new=0, autoraise=1):
+        if new == 0:
+            action = self.remote_action
+        elif new == 1:
+            action = self.remote_action_newwin
+        elif new == 2:
+            if self.remote_action_newtab is None:
+                action = self.remote_action_newwin
+            else:
+                action = self.remote_action_newtab
+        else:
+            raise Error(&quot;Bad 'new' parameter to open(); &quot; +
+                        &quot;expected 0, 1, or 2, got %s&quot; % new)
+
+        args = [arg.replace(&quot;%s&quot;, url).replace(&quot;%action&quot;, action)
+                for arg in self.remote_args]
+        success = self._invoke(args, True, autoraise)
+        if not success:
+            # remote invocation failed, try straight way
+            args = [arg.replace(&quot;%s&quot;, url) for arg in self.args]
+            return self._invoke(args, False, False)
+        else:
+            return True
+
+
+class Mozilla(UnixBrowser):
+    &quot;&quot;&quot;Launcher class for Mozilla/Netscape browsers.&quot;&quot;&quot;
+
+    raise_opts = [&quot;-noraise&quot;, &quot;-raise&quot;]
+
+    remote_args = ['-remote', 'openURL(%s%action)']
+    remote_action = &quot;&quot;
+    remote_action_newwin = &quot;,new-window&quot;
+    remote_action_newtab = &quot;,new-tab&quot;
+
+    background = True
+
+Netscape = Mozilla
+
+
+class Galeon(UnixBrowser):
+    &quot;&quot;&quot;Launcher class for Galeon/Epiphany browsers.&quot;&quot;&quot;
+
+    raise_opts = [&quot;-noraise&quot;, &quot;&quot;]
+    remote_args = ['%action', '%s']
+    remote_action = &quot;-n&quot;
+    remote_action_newwin = &quot;-w&quot;
+
+    background = True
+
+
+class Opera(UnixBrowser):
+    &quot;Launcher class for Opera browser.&quot;
+
+    raise_opts = [&quot;&quot;, &quot;-raise&quot;]
+
+    remote_args = ['-remote', 'openURL(%s%action)']
+    remote_action = &quot;&quot;
+    remote_action_newwin = &quot;,new-window&quot;
+    remote_action_newtab = &quot;,new-page&quot;
+    background = True
+
+
+class Elinks(UnixBrowser):
+    &quot;Launcher class for Elinks browsers.&quot;
+
+    remote_args = ['-remote', 'openURL(%s%action)']
+    remote_action = &quot;&quot;
+    remote_action_newwin = &quot;,new-window&quot;
+    remote_action_newtab = &quot;,new-tab&quot;
+    background = False
+
+    # elinks doesn't like its stdout to be redirected -
+    # it uses redirected stdout as a signal to do -dump
+    redirect_stdout = False
+
+
+class Konqueror(BaseBrowser):
+    &quot;&quot;&quot;Controller for the KDE File Manager (kfm, or Konqueror).
+
+    See the output of ``kfmclient --commands``
+    for more information on the Konqueror remote-control interface.
+    &quot;&quot;&quot;
+
+    def open(self, url, new=0, autoraise=1):
+        # XXX Currently I know no way to prevent KFM from opening a new win.
+        if new == 2:
+            action = &quot;newTab&quot;
+        else:
+            action = &quot;openURL&quot;
+
+        devnull = file(os.devnull, &quot;r+&quot;)
+        # if possible, put browser in separate process group, so
+        # keyboard interrupts don't affect browser as well as Python
+        setsid = getattr(os, 'setsid', None)
+        if not setsid:
+            setsid = getattr(os, 'setpgrp', None)
+
+        try:
+            p = subprocess.Popen([&quot;kfmclient&quot;, action, url],
+                                 close_fds=True, stdin=devnull,
+                                 stdout=devnull, stderr=devnull)
+        except OSError:
+            # fall through to next variant
+            pass
+        else:
+            p.wait()
+            # kfmclient's return code unfortunately has no meaning as it seems
+            return True
+
+        try:
+            p = subprocess.Popen([&quot;konqueror&quot;, &quot;--silent&quot;, url],
+                                 close_fds=True, stdin=devnull,
+                                 stdout=devnull, stderr=devnull,
+                                 preexec_fn=setsid)
+        except OSError:
+            # fall through to next variant
+            pass
+        else:
+            if p.poll() is None:
+                # Should be running now.
+                return True
+
+        try:
+            p = subprocess.Popen([&quot;kfm&quot;, &quot;-d&quot;, url],
+                                 close_fds=True, stdin=devnull,
+                                 stdout=devnull, stderr=devnull,
+                                 preexec_fn=setsid)
+        except OSError:
+            return False
+        else:
+            return (p.poll() is None)
+
+
+class Grail(BaseBrowser):
+    # There should be a way to maintain a connection to Grail, but the
+    # Grail remote control protocol doesn't really allow that at this
+    # point.  It probably never will!
+    def _find_grail_rc(self):
+        import glob
+        import pwd
+        import socket
+        import tempfile
+        tempdir = os.path.join(tempfile.gettempdir(),
+                               &quot;.grail-unix&quot;)
+        user = pwd.getpwuid(os.getuid())[0]
+        filename = os.path.join(tempdir, user + &quot;-*&quot;)
+        maybes = glob.glob(filename)
+        if not maybes:
+            return None
+        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+        for fn in maybes:
+            # need to PING each one until we find one that's live
+            try:
+                s.connect(fn)
+            except socket.error:
+                # no good; attempt to clean it out, but don't fail:
+                try:
+                    os.unlink(fn)
+                except IOError:
+                    pass
+            else:
+                return s
+
+    def _remote(self, action):
+        s = self._find_grail_rc()
+        if not s:
+            return 0
+        s.send(action)
+        s.close()
+        return 1
+
+    def open(self, url, new=0, autoraise=1):
+        if new:
+            ok = self._remote(&quot;LOADNEW &quot; + url)
+        else:
+            ok = self._remote(&quot;LOAD &quot; + url)
+        return ok
+
+
+#
+# Platform support for Unix
+#
+
+# These are the right tests because all these Unix browsers require either
+# a console terminal or an X display to run.
+
+def register_X_browsers():
+    # The default Gnome browser
+    if _iscommand(&quot;gconftool-2&quot;):
+        # get the web browser string from gconftool
+        gc = 'gconftool-2 -g /desktop/gnome/url-handlers/http/command 2&gt;/dev/null'
+        out = os.popen(gc)
+        commd = out.read().strip()
+        retncode = out.close()
+
+        # if successful, register it
+        if retncode is None and commd:
+            register(&quot;gnome&quot;, None, BackgroundBrowser(shlex.split(commd)))
+
+    # First, the Mozilla/Netscape browsers
+    for browser in (&quot;mozilla-firefox&quot;, &quot;firefox&quot;,
+                    &quot;mozilla-firebird&quot;, &quot;firebird&quot;,
+                    &quot;seamonkey&quot;, &quot;mozilla&quot;, &quot;netscape&quot;):
+        if _iscommand(browser):
+            register(browser, None, Mozilla(browser))
+
+    # Konqueror/kfm, the KDE browser.
+    if _iscommand(&quot;kfm&quot;):
+        register(&quot;kfm&quot;, Konqueror, Konqueror(&quot;kfm&quot;))
+    elif _iscommand(&quot;konqueror&quot;):
+        register(&quot;konqueror&quot;, Konqueror, Konqueror(&quot;konqueror&quot;))
+
+    # Gnome's Galeon and Epiphany
+    for browser in (&quot;galeon&quot;, &quot;epiphany&quot;):
+        if _iscommand(browser):
+            register(browser, None, Galeon(browser))
+
+    # Skipstone, another Gtk/Mozilla based browser
+    if _iscommand(&quot;skipstone&quot;):
+        register(&quot;skipstone&quot;, None, BackgroundBrowser(&quot;skipstone&quot;))
+
+    # Opera, quite popular
+    if _iscommand(&quot;opera&quot;):
+        register(&quot;opera&quot;, None, Opera(&quot;opera&quot;))
+
+    # Next, Mosaic -- old but still in use.
+    if _iscommand(&quot;mosaic&quot;):
+        register(&quot;mosaic&quot;, None, BackgroundBrowser(&quot;mosaic&quot;))
+
+    # Grail, the Python browser. Does anybody still use it?
+    if _iscommand(&quot;grail&quot;):
+        register(&quot;grail&quot;, Grail, None)
+
+# Prefer X browsers if present
+if os.environ.get(&quot;DISPLAY&quot;):
+    register_X_browsers()
+
+# Also try console browsers
+if os.environ.get(&quot;TERM&quot;):
+    # The Links/elinks browsers &lt;<A HREF="http://artax.karlin.mff.cuni.cz/~mikulas/links/">http://artax.karlin.mff.cuni.cz/~mikulas/links/</A>&gt;
+    if _iscommand(&quot;links&quot;):
+        register(&quot;links&quot;, None, GenericBrowser(&quot;links&quot;))
+    if _iscommand(&quot;elinks&quot;):
+        register(&quot;elinks&quot;, None, Elinks(&quot;elinks&quot;))
+    # The Lynx browser &lt;<A HREF="http://lynx.isc.org/">http://lynx.isc.org/</A>&gt;, &lt;<A HREF="http://lynx.browser.org/">http://lynx.browser.org/</A>&gt;
+    if _iscommand(&quot;lynx&quot;):
+        register(&quot;lynx&quot;, None, GenericBrowser(&quot;lynx&quot;))
+    # The w3m browser &lt;<A HREF="http://w3m.sourceforge.net/">http://w3m.sourceforge.net/</A>&gt;
+    if _iscommand(&quot;w3m&quot;):
+        register(&quot;w3m&quot;, None, GenericBrowser(&quot;w3m&quot;))
+
+#
+# Platform support for Windows
+#
+
+if sys.platform[:3] == &quot;win&quot;:
+    class WindowsDefault(BaseBrowser):
+        def open(self, url, new=0, autoraise=1):
+            os.startfile(url)
+            return True # Oh, my...
+
+    _tryorder = []
+    _browsers = {}
+    # Prefer mozilla/netscape/opera if present
+    for browser in (&quot;firefox&quot;, &quot;firebird&quot;, &quot;seamonkey&quot;, &quot;mozilla&quot;,
+                    &quot;netscape&quot;, &quot;opera&quot;):
+        if _iscommand(browser):
+            register(browser, None, BackgroundBrowser(browser))
+    register(&quot;windows-default&quot;, WindowsDefault)
+
+#
+# Platform support for MacOS
+#
+
+try:
+    import ic
+except ImportError:
+    pass
+else:
+    class InternetConfig(BaseBrowser):
+        def open(self, url, new=0, autoraise=1):
+            ic.launchurl(url)
+            return True # Any way to get status?
+
+    register(&quot;internet-config&quot;, InternetConfig, update_tryorder=-1)
+
+if sys.platform == 'darwin':
+    # Adapted from patch submitted to SourceForge by Steven J. Burr
+    class MacOSX(BaseBrowser):
+        &quot;&quot;&quot;Launcher class for Aqua browsers on Mac OS X
+
+        Optionally specify a browser name on instantiation.  Note that this
+        will not work for Aqua browsers if the user has moved the application
+        package after installation.
+
+        If no browser is specified, the default browser, as specified in the
+        Internet System Preferences panel, will be used.
+        &quot;&quot;&quot;
+        def __init__(self, name):
+            self.name = name
+
+        def open(self, url, new=0, autoraise=1):
+            assert &quot;'&quot; not in url
+            # hack for local urls
+            if not ':' in url:
+                url = 'file:'+url
+
+            # new must be 0 or 1
+            new = int(bool(new))
+            if self.name == &quot;default&quot;:
+                # User called open, open_new or get without a browser parameter
+                script = 'open location &quot;%s&quot;' % url.replace('&quot;', '%22') # opens in default browser
+            else:
+                # User called get and chose a browser
+                if self.name == &quot;OmniWeb&quot;:
+                    toWindow = &quot;&quot;
+                else:
+                    # Include toWindow parameter of OpenURL command for browsers
+                    # that support it.  0 == new window; -1 == existing
+                    toWindow = &quot;toWindow %d&quot; % (new - 1)
+                cmd = 'OpenURL &quot;%s&quot;' % url.replace('&quot;', '%22')
+                script = '''tell application &quot;%s&quot;
+                                activate
+                                %s %s
+                            end tell''' % (self.name, cmd, toWindow)
+            # Open pipe to AppleScript through osascript command
+            osapipe = os.popen(&quot;osascript&quot;, &quot;w&quot;)
+            if osapipe is None:
+                return False
+            # Write script to osascript's stdin
+            osapipe.write(script)
+            rc = osapipe.close()
+            return not rc
+
+    # Don't clear _tryorder or _browsers since OS X can use above Unix support
+    # (but we prefer using the OS X specific stuff)
+    register(&quot;MacOSX&quot;, None, MacOSX('default'), -1)
+
+
+#
+# Platform support for OS/2
+#
+
+if sys.platform[:3] == &quot;os2&quot; and _iscommand(&quot;netscape&quot;):
+    _tryorder = []
+    _browsers = {}
+    register(&quot;os2netscape&quot;, None,
+             GenericBrowser([&quot;start&quot;, &quot;netscape&quot;, &quot;%s&quot;]), -1)
+
+
+# OK, now that we know what the default preference orders for each
+# platform are, allow user to override them with the BROWSER variable.
+if &quot;BROWSER&quot; in os.environ:
+    _userchoices = os.environ[&quot;BROWSER&quot;].split(os.pathsep)
+    _userchoices.reverse()
+
+    # Treat choices in same way as if passed into get() but do register
+    # and prepend to _tryorder
+    for cmdline in _userchoices:
+        if cmdline != '':
+            _synthesize(cmdline, -1)
+    cmdline = None # to make del work if _userchoices was empty
+    del cmdline
+    del _userchoices
+
+# what to do if _tryorder is now empty?
+
+
+def main():
+    import getopt
+    usage = &quot;&quot;&quot;Usage: %s [-n | -t] url
+    -n: open new window
+    -t: open new tab&quot;&quot;&quot; % sys.argv[0]
+    try:
+        opts, args = getopt.getopt(sys.argv[1:], 'ntd')
+    except getopt.error, msg:
+        print &gt;&gt;sys.stderr, msg
+        print &gt;&gt;sys.stderr, usage
+        sys.exit(1)
+    new_win = 0
+    for o, a in opts:
+        if o == '-n': new_win = 1
+        elif o == '-t': new_win = 2
+    if len(args) &lt;&gt; 1:
+        print &gt;&gt;sys.stderr, usage
+        sys.exit(1)
+
+    url = args[0]
+    open(url, new_win)
+
+    print &quot;\a&quot;
+
+if __name__ == &quot;__main__&quot;:
+    main()

Added: Lobby/TASClient/Python/scripts/googleIt.py
===================================================================
--- Lobby/TASClient/Python/scripts/googleIt.py	                        (rev 0)
+++ Lobby/TASClient/Python/scripts/googleIt.py	2010-02-25 22:10:10 UTC (rev 7419)
@@ -0,0 +1,24 @@
+import time,thread
+import lobbyscript
+import webbrowser
+
+api = lobbyscript.Callback()
+gui = lobbyscript.GUI()
+
+def onGoogleItClick(channel,line,charPosInLine,selectedText):
+	webbrowser.open(&quot;<A HREF="http://www.google.com/search?q=">http://www.google.com/search?q=</A>&quot;+selectedText)
+	
+def onTranslateClick(channel,line,charPosInLine,selectedText,lang):
+	if selectedText != '':
+		webbrowser.open(&quot;<A HREF="http://translate.google.com/#auto|">http://translate.google.com/#auto|</A>&quot;+lang+&quot;|&quot;+selectedText)
+    
+
+def _init():
+	gui.AddItemToMenu('Chat','Google this',(),'googleIt','onGoogleItClick')
+	gui.AddItemToMenu('Chat','Translate in english',('en',),'googleIt','onTranslateClick')
+	gui.AddItemToMenu('Chat','Translate in french',('fr',),'googleIt','onTranslateClick')
+	gui.AddItemToMenu('Chat','Translate in german',('de',),'googleIt','onTranslateClick')
+	gui.AddItemToMenu('Chat','Translate in italian',('it',),'googleIt','onTranslateClick')
+	gui.AddItemToMenu('Chat','Translate in spanish',('es',),'googleIt','onTranslateClick')
+
+	
\ No newline at end of file

Modified: Lobby/TASClient/TASClient.dof
===================================================================
--- Lobby/TASClient/TASClient.dof	2010-02-25 15:35:55 UTC (rev 7418)
+++ Lobby/TASClient/TASClient.dof	2010-02-25 22:10:10 UTC (rev 7419)
@@ -100,7 +100,7 @@
 DebugSourceDirs=
 UsePackages=0
 [Parameters]
-RunParams=-menu
+RunParams=
 HostApplication=C:\Program Files\Spring\TASClient.exe
 Launcher=
 UseLauncher=0
@@ -113,9 +113,9 @@
 IncludeVerInfo=1
 AutoIncBuild=1
 MajorVer=0
-MinorVer=64
+MinorVer=65
 Release=0
-Build=800
+Build=803
 Debug=0
 PreRelease=0
 Special=0
@@ -126,7 +126,7 @@
 [Version Info Keys]
 CompanyName=
 FileDescription=Spring RTS Engine lobby client
-FileVersion=0.64.0.800
+FileVersion=0.65.0.803
 InternalName=
 LegalCopyright=
 LegalTrademarks=

Modified: Lobby/TASClient/TASClient.res
===================================================================
(Binary files differ)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002188.html">[Taspring-linux-commit] r7418 - Lobby/TASClient
</A></li>
	<LI>Next message: <A HREF="002190.html">[Taspring-linux-commit] r7420 - Lobby/TASClient
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2189">[ date ]</a>
              <a href="thread.html#2189">[ thread ]</a>
              <a href="subject.html#2189">[ subject ]</a>
              <a href="author.html#2189">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
