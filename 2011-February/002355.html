<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Taspring-linux-commit] r7585 - in Lobby/TASClient: .	LobbyComponents LobbyComponents/delphizlib Python Python/engine
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/taspring-linux-commit/2011-February/index.html" >
   <LINK REL="made" HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7585%20-%20in%20Lobby/TASClient%3A%20.%0A%09LobbyComponents%20LobbyComponents/delphizlib%20Python%20Python/engine&In-Reply-To=%3C20110219185653.010AB31385%40it-l.eu%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002354.html">
   <LINK REL="Next"  HREF="002356.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Taspring-linux-commit] r7585 - in Lobby/TASClient: .	LobbyComponents LobbyComponents/delphizlib Python Python/engine</H1>
    <B>taspring-linux-commit at lists.berlios.de</B> 
    <A HREF="mailto:taspring-linux-commit%40lists.berlios.de?Subject=Re%3A%20%5BTaspring-linux-commit%5D%20r7585%20-%20in%20Lobby/TASClient%3A%20.%0A%09LobbyComponents%20LobbyComponents/delphizlib%20Python%20Python/engine&In-Reply-To=%3C20110219185653.010AB31385%40it-l.eu%3E"
       TITLE="[Taspring-linux-commit] r7585 - in Lobby/TASClient: .	LobbyComponents LobbyComponents/delphizlib Python Python/engine">taspring-linux-commit at lists.berlios.de
       </A><BR>
    <I>Sat Feb 19 19:56:52 CET 2011</I>
    <P><UL>
        <LI>Previous message: <A HREF="002354.html">[Taspring-linux-commit] r7584 - in Lobby/TASClient: . Python/scripts
</A></li>
        <LI>Next message: <A HREF="002356.html">[Taspring-linux-commit] r7586 - in Lobby/TASClient: .	LobbyComponents/delphizlib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2355">[ date ]</a>
              <a href="thread.html#2355">[ thread ]</a>
              <a href="subject.html#2355">[ subject ]</a>
              <a href="author.html#2355">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: satirik
Date: 2011-02-19 19:56:51 +0100 (Sat, 19 Feb 2011)
New Revision: 7585

Added:
   Lobby/TASClient/BitList.pas
   Lobby/TASClient/LobbyComponents/delphizlib/
   Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.bpr
   Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cbproj
   Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cpp
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.dcu
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.inc
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.pas
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.dcu
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.pas
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.dcu
   Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.pas
   Lobby/TASClient/LobbyComponents/delphizlib/adler32.c
   Lobby/TASClient/LobbyComponents/delphizlib/adler32.obj
   Lobby/TASClient/LobbyComponents/delphizlib/compress.c
   Lobby/TASClient/LobbyComponents/delphizlib/compress.obj
   Lobby/TASClient/LobbyComponents/delphizlib/crc32.c
   Lobby/TASClient/LobbyComponents/delphizlib/crc32.h
   Lobby/TASClient/LobbyComponents/delphizlib/crc32.obj
   Lobby/TASClient/LobbyComponents/delphizlib/deflate.c
   Lobby/TASClient/LobbyComponents/delphizlib/deflate.h
   Lobby/TASClient/LobbyComponents/delphizlib/deflate.obj
   Lobby/TASClient/LobbyComponents/delphizlib/infback.c
   Lobby/TASClient/LobbyComponents/delphizlib/infback.obj
   Lobby/TASClient/LobbyComponents/delphizlib/inffast.c
   Lobby/TASClient/LobbyComponents/delphizlib/inffast.h
   Lobby/TASClient/LobbyComponents/delphizlib/inffast.obj
   Lobby/TASClient/LobbyComponents/delphizlib/inffixed.h
   Lobby/TASClient/LobbyComponents/delphizlib/inflate.c
   Lobby/TASClient/LobbyComponents/delphizlib/inflate.h
   Lobby/TASClient/LobbyComponents/delphizlib/inflate.obj
   Lobby/TASClient/LobbyComponents/delphizlib/inftrees.c
   Lobby/TASClient/LobbyComponents/delphizlib/inftrees.h
   Lobby/TASClient/LobbyComponents/delphizlib/inftrees.obj
   Lobby/TASClient/LobbyComponents/delphizlib/readme.txt
   Lobby/TASClient/LobbyComponents/delphizlib/trees.c
   Lobby/TASClient/LobbyComponents/delphizlib/trees.h
   Lobby/TASClient/LobbyComponents/delphizlib/trees.obj
   Lobby/TASClient/LobbyComponents/delphizlib/zconf.h
   Lobby/TASClient/LobbyComponents/delphizlib/zlib.h
   Lobby/TASClient/LobbyComponents/delphizlib/zutil.c
   Lobby/TASClient/LobbyComponents/delphizlib/zutil.h
Modified:
   Lobby/TASClient/LobbyScriptUnit.pas
   Lobby/TASClient/MainUnit.dfm
   Lobby/TASClient/MainUnit.pas
   Lobby/TASClient/Misc.pas
   Lobby/TASClient/Python/api.txt
   Lobby/TASClient/Python/engine/handlers.py
   Lobby/TASClient/SpringDownloaderFormUnit.pas
   Lobby/TASClient/TASClient.dof
   Lobby/TASClient/TASClient.dpr
   Lobby/TASClient/TASClient.res
   Lobby/TASClient/UploadReplayUnit.pas
Log:
* Added Rapid download support
* PYTHON : api.DownloadRapid added
* PYTHON : onDownloadRapidStart added
* /downloadrapid command added
* 3dminimap background fixed to black

Added: Lobby/TASClient/BitList.pas
===================================================================
--- Lobby/TASClient/BitList.pas	                        (rev 0)
+++ Lobby/TASClient/BitList.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,226 @@
+//*****************************************************************//
+//                                                                 //
+//  TBitList Object                                                //
+//  Copyright&#169; BrandsPatch LLC                                     //
+//  <A HREF="http://www.explainth.at">http://www.explainth.at</A>                                        //
+//                                                                 //
+//  All Rights Reserved                                            //
+//                                                                 //
+//  Permission is granted to use, modify and redistribute          //
+//  the code in this Delphi unit on the condition that this        //
+//  notice is retained unchanged.                                  //
+//                                                                 //
+//  BrandsPatch declines all responsibility for any losses,        //
+//  direct or indirect, that may arise  as a result of using       //
+//  this code.                                                     //
+//                                                                 //
+//                                                                 //
+//*****************************************************************//
+unit BitList;
+
+interface
+
+uses Windows,SysUtils,Classes;
+
+type TByteList = array[0..8191] of Byte;
+     PByteList = ^TByteList;
+{This allows for a maximum of 8192*4 = 32768 boolean values to be stored.
+ Increase if required}
+
+type TBitList = class(TObject)
+private
+  FBytes:PByteList;
+  //pointer to memory block used to store booleas
+  FSize:Word;
+  //size of the memory block, in bytes
+  FPosition:Word;
+  //position of the next bit boolean to be written
+  FMaxPos:Integer;
+  //maximum value for FPosition. e.g. if FSize is 4, FMaxPos would be 31
+  function GetBits(Index:Integer):Boolean;
+  procedure SetBits(Index:Integer;Value:Boolean);
+  //an EBitList exception is triggered if Index is bad
+  procedure Expand;
+  //expands the memory block, 4 bytes at a time
+public
+  constructor CreateEx;
+  //create a new instance
+  constructor CreateFromStream(AStream:TStream);
+  //recreate from streamed data
+  destructor Destroy;override;
+  procedure WriteToStream(AStream:TStream);
+  //write bit booleans to a stream
+  procedure WriteDataToStream(AStream:TStream);
+  procedure AddBit(Value:Boolean);
+  //add a fresh bitbool. Memory block is expanded if necessary
+  function FetchBit:Boolean;
+  {Returns the bitbool at FPosition and then increments
+   FPosition. Typically, you would use this to sequentially
+   access bitbools after recreating them from streamed data
+   in the context of other work where you need to make
+   decisions based on a large number of streamed boolean values}
+  procedure ReSet;
+  //discards the memory block and resets it to store 32 bits
+  property Bits[Index:Integer]:Boolean read GetBits write SetBits;default;
+  property Position:Word read FPosition;
+  property Size:Word read FSize;
+end;
+
+type EBitList = class(Exception);
+//exception raised should things go wrong
+
+implementation
+
+constructor TBitList.CreateEx;
+begin
+  inherited Create;
+  FSize:=4;FMaxPos:=31;
+  FBytes:=AllocMem(FSize);//32 bits @ 8 bits per byte
+end;
+
+constructor TBitList.CreateFromStream(AStream:TStream);
+begin
+  with AStream do
+  begin
+    ReadBuffer(FSize,sizeof(FSize));
+    FBytes:=AllocMem(FSize);
+    ReadBuffer(FBytes^,FSize);
+  end;
+  FMaxPos:=(FSize shl 2) - 1;
+  {As things stand this allows for a MAXWORD sized memory
+   block. Change to FSize:Integer if you need more}
+end;
+
+destructor TBitList.Destroy;
+begin
+  ReAllocMem(FBytes,0);//remember to discard the memory block!
+  inherited;
+end;
+
+procedure TBitList.WriteToStream(AStream:TStream);
+var ASize:Word;
+begin
+  ASize:=(FPosition div 8) + ord(FPosition mod 8 &gt; 0);
+  with AStream do
+  begin
+    WriteBuffer(ASize,sizeof(ASize));
+    WriteBuffer(FBytes^,ASize);
+  end;
+  {When streaming out we only take the first FPosition bits
+   that have actually be written. The current memory block
+   may be upto 31 bits larger}
+end;
+
+procedure TBitList.WriteDataToStream(AStream:TStream);
+var ASize:Word;
+begin
+  ASize:=(FPosition div 8) + ord(FPosition mod 8 &gt; 0);
+  with AStream do
+  begin
+    WriteBuffer(FBytes^,ASize);
+  end;
+  {When streaming out we only take the first FPosition bits
+   that have actually be written. The current memory block
+   may be upto 31 bits larger}
+end;
+
+function TBitList.GetBits(Index:Integer):Boolean;
+var AByte,ABit:Integer;
+begin
+  if (Index &lt; 0) or (Index &gt; FMaxPos) then raise EBitList.Create('Bad Index');
+  AByte:=Index div 8;
+  //which byte can the bitbool at position Index be found?
+  ABit:=Index mod 8;
+  //which bit of this byte holds that bitbool value?
+  Result:=(FBytes^[AByte] and (1 shl ABit) &gt; 0);
+  //remember, FBytes is a pointer to an array
+end;
+
+procedure TBitList.SetBits(Index:Integer;Value:Boolean);
+var AByte,ABit:Integer;
+begin
+  if (Index &lt; 0) or (Index &gt; FMaxPos) then raise EBitList.Create('Bad Index');
+  AByte:=Index div 8;
+  //which byte can the bitbool at position Index be found?
+  ABit:=Index mod 8;
+  //which bit of this byte holds that bitbool value?
+  FBytes^[AByte]:=(FBytes^[AByte] and ($FF xor (1 shl ABit))) or (ord(Value) shl ABit);
+  {In the appropriate byte, AByte, we first turn OFF the bit at
+   position ABit - corresponds to the Index'th bitbool - and then
+   turn it on again if Value is TRUE}
+end;
+
+procedure TBitList.AddBit(Value:Boolean);
+var AByte,ABit:Integer;
+begin
+  if (FPosition = FMaxPos) then Expand;
+  AByte:=FPosition div 8;
+  ABit:=FPosition mod 8;
+  FBytes^[AByte]:=(FBytes^[AByte] and ($FF xor (1 shl ABit))) or (ord(Value) shl ABit);
+  inc(FPosition);
+  {First We expand the memory block if necessary.
+   Then we establish the byte to modify and the bit in that bit
+   Then modify as in SetBits
+   Finally, increment FPosition.
+   Use this method to sequentially add bitbools starting from
+   FPosition = 0
+  }
+end;
+
+procedure TBitList.Expand;
+begin
+  inc(FSize,4);//room for another 32 bits
+  ReAllocMem(FBytes,FSize);
+  FBytes[FSize-1] := 0;
+  FBytes[FSize-2] := 0;
+  FBytes[FSize-3] := 0;
+  FBytes[FSize-4] := 0;
+  FMaxPos:=(FSize shl 2) - 1;
+end;
+
+function TBitList.FetchBit:Boolean;
+var AByte,ABit:Integer;
+begin
+  AByte:=FPosition div 8;
+  ABit:=FPosition mod 8;
+  Result:=(FBytes^[AByte] and (1 shl ABit) &gt; 0);
+  inc(FPosition);
+  {Use this method to sequentially retrieve bits starting
+   from FPosition = 0. Typically, this will be after you
+   recreate the bitbools from streamed data.
+
+   This method can be improved - instead of recalculating
+   AByte and ABit each time you could do this
+
+   1. Private FByte and FBit fields replace AByte and ABit
+   2. Both start off at zero.
+   3. At the end of each call to FetchBit you do this
+
+   FBit:=(FBit + 1)*ord(FBit &lt; 8);
+   //this changes FBit from 0 to 7 and then resets it to 0
+   FByte:=FByte + ord(FBit = 0);
+   //moves to a fresh byte if FBit has just been reset
+
+   The benefits are debatable - you are simply replacing one kind
+   of math with another. An option would be to simply replace
+   the local AByte and ABit variables with object fields FByte
+   and FBit and do the same calculations as above.
+
+   You could put in a test here to block attempts to fetch
+   non-existant bits. For example
+
+   if (FPosition &gt; FMaxPos) then raise EBitList.Create(''). If you
+   are sure that this will never occur best leave out this test since
+   it slows things down}
+end;
+
+procedure TBitList.ReSet;
+begin
+  FSize:=4;
+  FPosition:=0;
+  FMaxPos:=31;
+  ReAllocMem(FBytes,4);
+  FillChar(FBytes^,4,0);
+end;
+
+end.

Added: Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.bpr
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.bpr	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.bpr	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,136 @@
+&lt;?xml version='1.0' encoding='utf-8' ?&gt;
+&lt;!-- C++Builder XML Project --&gt;
+&lt;PROJECT&gt;
+  &lt;MACROS&gt;
+    &lt;VERSION value=&quot;BCB.06.00&quot;/&gt;
+    &lt;PROJECT value=&quot;DelphiZLib.lib&quot;/&gt;
+    &lt;OBJFILES value=&quot;DelphiZLib.obj adler32.obj crc32.obj deflate.obj infback.obj inffast.obj 
+      inflate.obj inftrees.obj trees.obj compress.obj&quot;/&gt;
+    &lt;RESFILES value=&quot;&quot;/&gt;
+    &lt;IDLFILES value=&quot;&quot;/&gt;
+    &lt;IDLGENFILES value=&quot;&quot;/&gt;
+    &lt;DEFFILE value=&quot;&quot;/&gt;
+    &lt;RESDEPEN value=&quot;$(RESFILES)&quot;/&gt;
+    &lt;LIBFILES value=&quot;&quot;/&gt;
+    &lt;LIBRARIES value=&quot;vcl.lib rtl.lib&quot;/&gt;
+    &lt;SPARELIBS value=&quot;rtl.lib vcl.lib&quot;/&gt;
+    &lt;PACKAGES value=&quot;vclx.bpi rtl.bpi vcl.bpi dbrtl.bpi vcldb.bpi bdertl.bpi vcldbx.bpi 
+      ibsmp.bpi bcbsmp.bpi dclocx.bpi qrpt.bpi teeui.bpi teedb.bpi tee.bpi 
+      dss.bpi nmfast.bpi inetdb.bpi inet.bpi dsnap.bpi&quot;/&gt;
+    &lt;PATHCPP value=&quot;.;&quot;/&gt;
+    &lt;PATHPAS value=&quot;.;&quot;/&gt;
+    &lt;PATHRC value=&quot;.;&quot;/&gt;
+    &lt;PATHASM value=&quot;.;&quot;/&gt;
+    &lt;DEBUGLIBPATH value=&quot;$(BCB)\lib\debug&quot;/&gt;
+    &lt;RELEASELIBPATH value=&quot;$(BCB)\lib\release&quot;/&gt;
+    &lt;LINKER value=&quot;TLib&quot;/&gt;
+    &lt;USERDEFINES value=&quot;&quot;/&gt;
+    &lt;SYSDEFINES value=&quot;NO_STRICT&quot;/&gt;
+    &lt;MAINSOURCE value=&quot;DelphiZLib.cpp&quot;/&gt;
+    &lt;INCLUDEPATH value=&quot;$(BCB)\include;$(BCB)\include\vcl&quot;/&gt;
+    &lt;LIBPATH value=&quot;&quot;/&gt;
+    &lt;WARNINGS value=&quot;-w-par -w-aus&quot;/&gt;
+    &lt;WARNOPTSTR value=&quot;&quot;/&gt;
+    &lt;LISTFILE value=&quot;&quot;/&gt;
+    &lt;OTHERFILES value=&quot;&quot;/&gt;
+  &lt;/MACROS&gt;
+  &lt;OPTIONS&gt;
+    &lt;IDLCFLAGS value=&quot;-I$(BCB)\include -I$(BCB)\include\vcl -src_suffix cpp -boa&quot;/&gt;
+    &lt;CFLAG1 value=&quot;-O2 -H=c:\cbuilder\lib\vcl60.csm -Ve -X- -pr -a8 -b -d -k- -vi -tWM&quot;/&gt;
+    &lt;CFLAG2 value=&quot;&quot;/&gt;
+    &lt;CFLAG3 value=&quot;&quot;/&gt;
+    &lt;PFLAGS value=&quot;-$Y- -$L- -$I- -$D- -$A8 -v -M -JPHNE&quot;/&gt;
+    &lt;RFLAGS value=&quot;&quot;/&gt;
+    &lt;AFLAGS value=&quot;/mx /w2 /zn&quot;/&gt;
+    &lt;LFLAGS value=&quot;&quot;/&gt;
+    &lt;IFLAGS value=&quot;-g -Gn&quot;/&gt;
+    &lt;OTHERFILES value=&quot;&quot;/&gt;
+  &lt;/OPTIONS&gt;
+  &lt;LINKER&gt;
+    &lt;ALLOBJ value=&quot;&quot;/&gt;
+    &lt;ALLRES value=&quot;&quot;/&gt;
+    &lt;ALLLIB value=&quot;&quot;/&gt;
+    &lt;OTHERFILES value=&quot;&quot;/&gt;
+  &lt;/LINKER&gt;
+  &lt;FILELIST&gt;
+      &lt;FILE FILENAME=&quot;DelphiZLib.cpp&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;DelphiZLib&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;adler32.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;adler32&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;crc32.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;crc32&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;deflate.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;deflate&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;infback.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;infback&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;inffast.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;inffast&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;inflate.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;inflate&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;inftrees.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;inftrees&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;trees.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;trees&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+      &lt;FILE FILENAME=&quot;compress.c&quot; FORMNAME=&quot;&quot; UNITNAME=&quot;compress&quot; CONTAINERID=&quot;CCompiler&quot; DESIGNCLASS=&quot;&quot; LOCALCOMMAND=&quot;&quot;/&gt;
+  &lt;/FILELIST&gt;
+  &lt;BUILDTOOLS&gt;
+  &lt;/BUILDTOOLS&gt;
+
+  &lt;IDEOPTIONS&gt;
+[Version Info]
+IncludeVerInfo=0
+AutoIncBuild=0
+MajorVer=1
+MinorVer=0
+Release=0
+Build=0
+Debug=0
+PreRelease=0
+Special=0
+Private=0
+DLL=0
+Locale=1040
+CodePage=1252
+
+[Version Info Keys]
+CompanyName=
+FileDescription=
+FileVersion=1.0.0.0
+InternalName=
+LegalCopyright=
+LegalTrademarks=
+OriginalFilename=
+ProductName=
+ProductVersion=1.0.0.0
+Comments=
+
+[HistoryLists\hlIncludePath]
+Count=2
+Item0=$(BCB)\include;$(BCB)\include\vcl
+Item1=$(BCB)\include
+
+[HistoryLists\hlLibraryPath]
+Count=1
+Item0=$(BCB)\lib\obj;$(BCB)\lib
+
+[HistoryLists\hlDebugSourcePath]
+Count=1
+Item0=$(BCB)\source\vcl
+
+[Debugging]
+DebugSourceDirs=
+
+[Parameters]
+RunParams=
+Launcher=
+UseLauncher=0
+DebugCWD=
+HostApplication=
+RemoteHost=
+RemotePath=
+RemoteLauncher=
+RemoteCWD=
+RemoteDebug=0
+
+[Compiler]
+ShowInfoMsgs=1
+LinkDebugVcl=1
+LinkCGLIB=0
+
+[Language]
+ActiveLang=
+ProjectLang=
+RootDir=
+  &lt;/IDEOPTIONS&gt;
+&lt;/PROJECT&gt;
\ No newline at end of file

Added: Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cbproj
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cbproj	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cbproj	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,162 @@
+&#239;&#187;&#191;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;Project xmlns=&quot;<A HREF="http://schemas.microsoft.com/developer/msbuild/2003">http://schemas.microsoft.com/developer/msbuild/2003</A>&quot;&gt;
+  &lt;PropertyGroup&gt;
+    &lt;ProjectGuid&gt;{9f84c2f7-d08e-41ba-90b1-37ad2ee57beb}&lt;/ProjectGuid&gt;
+    &lt;ProjectType&gt;CppStaticLibrary&lt;/ProjectType&gt;
+    &lt;Config Condition=&quot;'$(Config)'==''&quot;&gt;Release Build&lt;/Config&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot;'$(Config)'=='Base' or '$(Base)'!=''&quot;&gt;
+    &lt;Base&gt;true&lt;/Base&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot;'$(Config)'=='Debug Build' or '$(Cfg_1)'!=''&quot;&gt;
+    &lt;Base&gt;true&lt;/Base&gt;
+    &lt;Cfg_1&gt;true&lt;/Cfg_1&gt;
+    &lt;CfgParent&gt;Base&lt;/CfgParent&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot;'$(Config)'=='Release Build' or '$(Cfg_2)'!=''&quot;&gt;
+    &lt;Base&gt;true&lt;/Base&gt;
+    &lt;Cfg_2&gt;true&lt;/Cfg_2&gt;
+    &lt;CfgParent&gt;Base&lt;/CfgParent&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot;'$(Base)'!=''&quot;&gt;
+    &lt;BCC_OptimizeForSpeed&gt;true&lt;/BCC_OptimizeForSpeed&gt;
+    &lt;OutputExt&gt;lib&lt;/OutputExt&gt;
+    &lt;DCC_CBuilderOutput&gt;JPHNE&lt;/DCC_CBuilderOutput&gt;
+    &lt;DynamicRTL&gt;true&lt;/DynamicRTL&gt;
+    &lt;DCC_IOChecking&gt;false&lt;/DCC_IOChecking&gt;
+    &lt;BCC_MergeDuplicateStrings&gt;true&lt;/BCC_MergeDuplicateStrings&gt;
+    &lt;DCC_DebugInformation&gt;false&lt;/DCC_DebugInformation&gt;
+    &lt;DCC_MakeModifiedUnits&gt;true&lt;/DCC_MakeModifiedUnits&gt;
+    &lt;FinalOutputDir&gt;.&lt;/FinalOutputDir&gt;
+    &lt;TASM_AdditionalSwitches&gt; /w2&lt;/TASM_AdditionalSwitches&gt;
+    &lt;PackageImports&gt;vclx.bpi;rtl.bpi;vcl.bpi;dbrtl.bpi;vcldb.bpi;bdertl.bpi;vcldbx.bpi;ibsmp.bpi;bcbsmp.bpi;teeui.bpi;teedb.bpi;tee.bpi;dss.bpi;inetdb.bpi;inet.bpi;dsnap.bpi&lt;/PackageImports&gt;
+    &lt;DCC_UnitSearchPath&gt;.\;$(BDS)\lib;$(BDS)\lib\obj&lt;/DCC_UnitSearchPath&gt;
+    &lt;BCC_GenerateMultithreaded&gt;true&lt;/BCC_GenerateMultithreaded&gt;
+    &lt;BCC_waus&gt;false&lt;/BCC_waus&gt;
+    &lt;BRCC_UserSuppliedOptions&gt; -I$(BDS)\include;$(BDS)\include\vcl;$(BDS)\include\dinkumware&lt;/BRCC_UserSuppliedOptions&gt;
+    &lt;BCC_IncludePath&gt;$(BDS)\include;$(BDS)\include\vcl;$(BDS)\include\dinkumware&lt;/BCC_IncludePath&gt;
+    &lt;TASM_IncludePath&gt;$(BDS)\include;$(BDS)\include\vcl;$(BDS)\include\dinkumware&lt;/TASM_IncludePath&gt;
+    &lt;AllPackageLibs&gt;rtl.lib;vcl.lib&lt;/AllPackageLibs&gt;
+    &lt;BRCC_IncludePath&gt;$(BDS)\include;$(BDS)\include\vcl;$(BDS)\include\dinkumware&lt;/BRCC_IncludePath&gt;
+    &lt;DCC_IncludePath&gt;.\;$(BDS)\lib;$(BDS)\lib\obj&lt;/DCC_IncludePath&gt;
+    &lt;BCC_ZeroLengthEmptyBaseClass&gt;true&lt;/BCC_ZeroLengthEmptyBaseClass&gt;
+    &lt;ILINK_LibraryPath&gt;$(BDS)\lib;$(BDS)\lib\obj;$(BDS)\lib\psdk&lt;/ILINK_LibraryPath&gt;
+    &lt;BCC_Defines&gt;NO_STRICT&lt;/BCC_Defines&gt;
+    &lt;BRCC_Defines&gt;NO_STRICT&lt;/BRCC_Defines&gt;
+    &lt;TASM_Defines&gt;NO_STRICT&lt;/TASM_Defines&gt;
+    &lt;Multithreaded&gt;true&lt;/Multithreaded&gt;
+    &lt;DCC_LocalDebugSymbols&gt;false&lt;/DCC_LocalDebugSymbols&gt;
+    &lt;TASM_Debugging&gt;None&lt;/TASM_Debugging&gt;
+    &lt;BCC_CallingConvention&gt;fastcall&lt;/BCC_CallingConvention&gt;
+    &lt;DCC_SymbolReferenceInfo&gt;2&lt;/DCC_SymbolReferenceInfo&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot;'$(Cfg_1)'!=''&quot;&gt;
+    &lt;DCC_Optimize&gt;false&lt;/DCC_Optimize&gt;
+    &lt;DCC_DebugInfoInExe&gt;true&lt;/DCC_DebugInfoInExe&gt;
+    &lt;ILINK_FullDebugInfo&gt;true&lt;/ILINK_FullDebugInfo&gt;
+    &lt;BCC_InlineFunctionExpansion&gt;false&lt;/BCC_InlineFunctionExpansion&gt;
+    &lt;ILINK_DisableIncrementalLinking&gt;true&lt;/ILINK_DisableIncrementalLinking&gt;
+    &lt;DCC_DebugInformation&gt;true&lt;/DCC_DebugInformation&gt;
+    &lt;DCC_Define&gt;DEBUG;$(DCC_Define)&lt;/DCC_Define&gt;
+    &lt;BCC_DebugLineNumbers&gt;true&lt;/BCC_DebugLineNumbers&gt;
+    &lt;IntermediateOutputDir&gt;Debug_Build&lt;/IntermediateOutputDir&gt;
+    &lt;TASM_DisplaySourceLines&gt;true&lt;/TASM_DisplaySourceLines&gt;
+    &lt;BCC_StackFrames&gt;true&lt;/BCC_StackFrames&gt;
+    &lt;BCC_DisableOptimizations&gt;true&lt;/BCC_DisableOptimizations&gt;
+    &lt;ILINK_LibraryPath&gt;$(BDS)\lib\debug;$(ILINK_LibraryPath)&lt;/ILINK_LibraryPath&gt;
+    &lt;BCC_Defines&gt;_DEBUG;$(BCC_Defines)&lt;/BCC_Defines&gt;
+    &lt;TASM_Debugging&gt;Full&lt;/TASM_Debugging&gt;
+    &lt;BCC_SourceDebuggingOn&gt;true&lt;/BCC_SourceDebuggingOn&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;PropertyGroup Condition=&quot;'$(Cfg_2)'!=''&quot;&gt;
+    &lt;BCC_NoAutodependency&gt;true&lt;/BCC_NoAutodependency&gt;
+    &lt;IntermediateOutputDir&gt;Release_Build&lt;/IntermediateOutputDir&gt;
+    &lt;ILINK_LibraryPath&gt;$(BDS)\lib\release;$(ILINK_LibraryPath)&lt;/ILINK_LibraryPath&gt;
+    &lt;BCC_Defines&gt;NDEBUG;$(BCC_Defines)&lt;/BCC_Defines&gt;
+  &lt;/PropertyGroup&gt;
+  &lt;ProjectExtensions&gt;
+    &lt;Borland.Personality&gt;CPlusPlusBuilder.Personality&lt;/Borland.Personality&gt;
+    &lt;Borland.ProjectType&gt;CppStaticLibrary&lt;/Borland.ProjectType&gt;
+    &lt;BorlandProject&gt;
+&lt;BorlandProject&gt;&lt;CPlusPlusBuilder.Personality&gt;&lt;VersionInfo&gt;&lt;VersionInfo Name=&quot;IncludeVerInfo&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;AutoIncBuild&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;MajorVer&quot;&gt;1&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;MinorVer&quot;&gt;0&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Release&quot;&gt;0&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Build&quot;&gt;0&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Debug&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;PreRelease&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Special&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Private&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;DLL&quot;&gt;False&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;Locale&quot;&gt;1040&lt;/VersionInfo&gt;&lt;VersionInfo Name=&quot;CodePage&quot;&gt;1252&lt;/VersionInfo&gt;&lt;/VersionInfo&gt;&lt;VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;CompanyName&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;FileDescription&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;FileVersion&quot;&gt;1.0.0.0&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;InternalName&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;LegalCopyright&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfo
 Keys Name=&quot;LegalTrademarks&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;OriginalFilename&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;ProductName&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;ProductVersion&quot;&gt;1.0.0.0&lt;/VersionInfoKeys&gt;&lt;VersionInfoKeys Name=&quot;Comments&quot;&gt;&lt;/VersionInfoKeys&gt;&lt;/VersionInfoKeys&gt;&lt;HistoryLists_hlIncludePath&gt;&lt;HistoryLists_hlIncludePath Name=&quot;Count&quot;&gt;2&lt;/HistoryLists_hlIncludePath&gt;&lt;HistoryLists_hlIncludePath Name=&quot;Item0&quot;&gt;$(BCB)\include;$(BCB)\include\vcl&lt;/HistoryLists_hlIncludePath&gt;&lt;HistoryLists_hlIncludePath Name=&quot;Item1&quot;&gt;$(BCB)\include&lt;/HistoryLists_hlIncludePath&gt;&lt;/HistoryLists_hlIncludePath&gt;&lt;HistoryLists_hlLibraryPath&gt;&lt;HistoryLists_hlLibraryPath Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlLibraryPath&gt;&lt;HistoryLists_hlLibraryPath Name=&quot;Item0&quot;&gt;$(BCB)\lib\obj;$(BCB)\lib&lt;/HistoryLists_hlLibraryPath&gt;&lt;/HistoryLists_hlLibraryPath&gt;&lt;HistoryLists_hlDebugSourcePath&gt;&lt;HistoryLists_hlDebugSourcePath Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlDebugSourcePath&gt;&lt;HistoryLists_hlDebugSourcePath Name=&quot;Item0&quot;&gt;$(B
 CB)\source\vcl&lt;/HistoryLists_hlDebugSourcePath&gt;&lt;/HistoryLists_hlDebugSourcePath&gt;&lt;Debugging&gt;&lt;Debugging Name=&quot;DebugSourceDirs&quot;&gt;&lt;/Debugging&gt;&lt;/Debugging&gt;&lt;Parameters&gt;&lt;Parameters Name=&quot;RunParams&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;Launcher&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;UseLauncher&quot;&gt;False&lt;/Parameters&gt;&lt;Parameters Name=&quot;DebugCWD&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;HostApplication&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;RemoteHost&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;RemotePath&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;RemoteLauncher&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;RemoteCWD&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;RemoteDebug&quot;&gt;False&lt;/Parameters&gt;&lt;Parameters Name=&quot;RemoteParams&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;UseRemoteLauncher&quot;&gt;False&lt;/Parameters&gt;&lt;Parameters Name=&quot;Debug Symbols Search Path&quot;&gt;&lt;/Parameters&gt;&lt;Parameters Name=&quot;LoadAllSymbols&quot;&gt;True&lt;/Parameters&gt;&lt;Parameters Name=&quot;LoadUnspecifiedSymbols&quot;&gt;False&lt;/Parameters&gt;&lt;/Parameters&gt;&lt;Compiler&gt;&lt;Compiler Name=&quot;ShowInfoMsgs&quot;&gt;1&lt;/Compiler&gt;&lt;Compiler Name=&quot;LinkDebugVcl&quot;&gt;1&lt;/Compiler&gt;&lt;Compil
 er Name=&quot;LinkCGLIB&quot;&gt;0&lt;/Compiler&gt;&lt;/Compiler&gt;&lt;Language&gt;&lt;Language Name=&quot;ActiveLang&quot;&gt;&lt;/Language&gt;&lt;Language Name=&quot;ProjectLang&quot;&gt;&lt;/Language&gt;&lt;Language Name=&quot;RootDir&quot;&gt;&lt;/Language&gt;&lt;/Language&gt;&lt;HistoryLists_hlFinalOutputDir&gt;&lt;HistoryLists_hlFinalOutputDir Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlFinalOutputDir&gt;&lt;HistoryLists_hlFinalOutputDir Name=&quot;Item0&quot;&gt;.&lt;/HistoryLists_hlFinalOutputDir&gt;&lt;/HistoryLists_hlFinalOutputDir&gt;&lt;HistoryLists_hlILINK_LibraryPath&gt;&lt;HistoryLists_hlILINK_LibraryPath Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlILINK_LibraryPath&gt;&lt;HistoryLists_hlILINK_LibraryPath Name=&quot;Item0&quot;&gt;$(BDS)\lib\release;$(BDS)\lib;$(BDS)\lib\obj;$(BDS)\lib\psdk&lt;/HistoryLists_hlILINK_LibraryPath&gt;&lt;/HistoryLists_hlILINK_LibraryPath&gt;&lt;HistoryLists_hlIntermediateOutputDir&gt;&lt;HistoryLists_hlIntermediateOutputDir Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlIntermediateOutputDir&gt;&lt;HistoryLists_hlIntermediateOutputDir Name=&quot;Item0&quot;&gt;Release_Build&lt;/HistoryLists_hlIntermediateOutputDir&gt;&lt;/HistoryLists_hlIntermediateOutputDir&gt;&lt;Linker&gt;&lt;Linker Name=&quot;LibPre
 fix&quot;&gt;&lt;/Linker&gt;&lt;Linker Name=&quot;LibSuffix&quot;&gt;&lt;/Linker&gt;&lt;Linker Name=&quot;LibVersion&quot;&gt;&lt;/Linker&gt;&lt;/Linker&gt;&lt;ProjectProperties&gt;&lt;ProjectProperties Name=&quot;AutoShowDeps&quot;&gt;False&lt;/ProjectProperties&gt;&lt;ProjectProperties Name=&quot;ManagePaths&quot;&gt;True&lt;/ProjectProperties&gt;&lt;ProjectProperties Name=&quot;VerifyPackages&quot;&gt;True&lt;/ProjectProperties&gt;&lt;/ProjectProperties&gt;  &lt;HistoryLists_hlBCC_MaxIdentifierLength&gt;
+      &lt;HistoryLists_hlBCC_MaxIdentifierLength Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlBCC_MaxIdentifierLength&gt;
+      &lt;HistoryLists_hlBCC_MaxIdentifierLength Name=&quot;Item0&quot;&gt;250&lt;/HistoryLists_hlBCC_MaxIdentifierLength&gt;
+    &lt;/HistoryLists_hlBCC_MaxIdentifierLength&gt;
+    &lt;HistoryLists_hlBCC_IncludePath&gt;
+      &lt;HistoryLists_hlBCC_IncludePath Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlBCC_IncludePath&gt;
+      &lt;HistoryLists_hlBCC_IncludePath Name=&quot;Item0&quot;&gt;$(BDS)\include;$(BDS)\include\vcl;$(BDS)\include\dinkumware&lt;/HistoryLists_hlBCC_IncludePath&gt;
+    &lt;/HistoryLists_hlBCC_IncludePath&gt;
+    &lt;HistoryLists_hlBCC_Defines&gt;
+      &lt;HistoryLists_hlBCC_Defines Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlBCC_Defines&gt;
+      &lt;HistoryLists_hlBCC_Defines Name=&quot;Item0&quot;&gt;NDEBUG;NO_STRICT&lt;/HistoryLists_hlBCC_Defines&gt;
+    &lt;/HistoryLists_hlBCC_Defines&gt;
+    &lt;HistoryLists_hlTASM_IncludePath&gt;
+      &lt;HistoryLists_hlTASM_IncludePath Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTASM_IncludePath&gt;
+      &lt;HistoryLists_hlTASM_IncludePath Name=&quot;Item0&quot;&gt;$(BDS)\include;$(BDS)\include\vcl;$(BDS)\include\dinkumware&lt;/HistoryLists_hlTASM_IncludePath&gt;
+    &lt;/HistoryLists_hlTASM_IncludePath&gt;
+    &lt;HistoryLists_hlTASM_Defines&gt;
+      &lt;HistoryLists_hlTASM_Defines Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTASM_Defines&gt;
+      &lt;HistoryLists_hlTASM_Defines Name=&quot;Item0&quot;&gt;NO_STRICT&lt;/HistoryLists_hlTASM_Defines&gt;
+    &lt;/HistoryLists_hlTASM_Defines&gt;
+    &lt;HistoryLists_hlTASM_HashTableCapacity&gt;
+      &lt;HistoryLists_hlTASM_HashTableCapacity Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTASM_HashTableCapacity&gt;
+      &lt;HistoryLists_hlTASM_HashTableCapacity Name=&quot;Item0&quot;&gt;8192&lt;/HistoryLists_hlTASM_HashTableCapacity&gt;
+    &lt;/HistoryLists_hlTASM_HashTableCapacity&gt;
+    &lt;HistoryLists_hlTASM_MaxSymbolLength&gt;
+      &lt;HistoryLists_hlTASM_MaxSymbolLength Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTASM_MaxSymbolLength&gt;
+      &lt;HistoryLists_hlTASM_MaxSymbolLength Name=&quot;Item0&quot;&gt;12&lt;/HistoryLists_hlTASM_MaxSymbolLength&gt;
+    &lt;/HistoryLists_hlTASM_MaxSymbolLength&gt;
+    &lt;HistoryLists_hlTASM_Passes&gt;
+      &lt;HistoryLists_hlTASM_Passes Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTASM_Passes&gt;
+      &lt;HistoryLists_hlTASM_Passes Name=&quot;Item0&quot;&gt;1&lt;/HistoryLists_hlTASM_Passes&gt;
+    &lt;/HistoryLists_hlTASM_Passes&gt;
+    &lt;HistoryLists_hlTASM_VersionId&gt;
+      &lt;HistoryLists_hlTASM_VersionId Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTASM_VersionId&gt;
+      &lt;HistoryLists_hlTASM_VersionId Name=&quot;Item0&quot;&gt;0&lt;/HistoryLists_hlTASM_VersionId&gt;
+    &lt;/HistoryLists_hlTASM_VersionId&gt;
+    &lt;HistoryLists_hlTLIB_PageSize&gt;
+      &lt;HistoryLists_hlTLIB_PageSize Name=&quot;Count&quot;&gt;1&lt;/HistoryLists_hlTLIB_PageSize&gt;
+      &lt;HistoryLists_hlTLIB_PageSize Name=&quot;Item0&quot;&gt;16&lt;/HistoryLists_hlTLIB_PageSize&gt;
+    &lt;/HistoryLists_hlTLIB_PageSize&gt;
+  &lt;/CPlusPlusBuilder.Personality&gt;&lt;/BorlandProject&gt;&lt;/BorlandProject&gt;
+  &lt;/ProjectExtensions&gt;
+  &lt;Import Project=&quot;$(MSBuildBinPath)\Borland.Cpp.Targets&quot; /&gt;
+  &lt;ItemGroup&gt;
+    &lt;CppCompile Include=&quot;adler32.c&quot;&gt;
+      &lt;BuildOrder&gt;1&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;compress.c&quot;&gt;
+      &lt;BuildOrder&gt;9&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;crc32.c&quot;&gt;
+      &lt;BuildOrder&gt;2&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;deflate.c&quot;&gt;
+      &lt;BuildOrder&gt;3&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;DelphiZLib.cpp&quot;&gt;
+      &lt;BuildOrder&gt;0&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;infback.c&quot;&gt;
+      &lt;BuildOrder&gt;4&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;inffast.c&quot;&gt;
+      &lt;BuildOrder&gt;5&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;inflate.c&quot;&gt;
+      &lt;BuildOrder&gt;6&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;inftrees.c&quot;&gt;
+      &lt;BuildOrder&gt;7&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;CppCompile Include=&quot;trees.c&quot;&gt;
+      &lt;BuildOrder&gt;8&lt;/BuildOrder&gt;
+    &lt;/CppCompile&gt;
+    &lt;BuildConfiguration Include=&quot;Debug Build&quot;&gt;
+      &lt;Key&gt;Cfg_1&lt;/Key&gt;
+    &lt;/BuildConfiguration&gt;
+    &lt;BuildConfiguration Include=&quot;Release Build&quot;&gt;
+      &lt;Key&gt;Cfg_2&lt;/Key&gt;
+    &lt;/BuildConfiguration&gt;
+  &lt;/ItemGroup&gt;
+&lt;/Project&gt;
\ No newline at end of file

Added: Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cpp
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cpp	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/DelphiZLib.cpp	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,7 @@
+#include &lt;condefs.h&gt;
+#pragma hdrstop
+//---------------------------------------------------------------------------
+#define Library
+
+// To add a file to the library use the Project menu 'Add to Project'.
+

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.dcu
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.dcu
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.inc
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.inc	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.inc	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,155 @@
+{*****************************************************************************
+*  ZLibEx.inc                                                                *
+*  copyright (c) 2006-2010 base2 technologies                                *
+*                                                                            *
+*  version information for delphi/c++ builder                                *
+*                                                                            *
+*  revision history                                                          *
+*    2010.01.27  updated for delphi 2010                                     *
+*    2009.04.11  updated to use CONDITIONALEXPRESSIONS and CompilerVersion   *
+*    2009.01.28  updated for delphi 2009                                     *
+*    2007.10.01  updated for delphi 2007                                     *
+*    2005.11.29  created                                                     *
+*                                                                            *
+*  acknowledgments                                                           *
+*    iztok kacin                                                             *
+*      2009.04.11  CONDITIONALEXPRESSIONS and CompilerVersion changes        *
+*****************************************************************************}
+
+{$ifndef CONDITIONALEXPRESSIONS}
+
+  {** delphi ****************************************************************}
+
+  {$ifdef VER80}                        // delphi 1
+    {$define Delphi}
+
+    {$define Version1}
+  {$endif}
+
+  {$ifdef VER90}                        // delphi 2
+    {$define Delphi}
+
+    {$define Version2}
+  {$endif}
+
+  {$ifdef VER100}                       // delphi 3
+    {$define Delphi}
+
+    {$define Version3}
+  {$endif}
+
+  {$ifdef VER120}                       // delphi 4
+    {$define Delphi}
+
+    {$define Version4}
+  {$endif}
+
+  {** c++ builder ***********************************************************}
+
+  {$ifdef VER93}                        // c++ builder 1
+    {$define CBuilder}
+
+    {$define Version1}
+  {$endif}
+
+  {$ifdef VER110}                       // c++ builder 3
+    {$define CBuilder}
+
+    {$define Version3}
+  {$endif}
+
+  {$ifdef VER125}                       // c++ builder 4
+    {$define CBuilder}
+
+    {$define Version4}
+  {$endif}
+
+  {** delphi/c++ builder (common) *******************************************}
+
+  {$ifdef VER130}                       // delphi/c++ builder 5
+    {$ifdef BCB}
+      {$define CBuilder}
+    {$ELSE}
+      {$define Delphi}
+    {$endif}
+
+    {$define Version5}
+
+    {$define Version5Plus}
+  {$endif}
+
+{$ELSE}
+
+  {$ifdef BCB}
+    {$define CBuilder}
+  {$ELSE}
+    {$define Delphi}
+  {$endif}
+
+  {$define Version5Plus}
+
+  {$if CompilerVersion &gt;= 14.0}         // delphi 6
+    {$ifdef VER140}
+      {$define Version6}
+    {$endif}
+
+    {$define Version6Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 15.0}         // delphi 7
+    {$ifdef VER150}
+      {$define Version7}
+    {$endif}
+
+    {$define Version7Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 16.0}         // delphi 8 (.net)
+    {$ifdef VER160}
+      {$define Version8}
+    {$endif}
+
+    {$define Version8Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 17.0}         // delphi 2005
+    {$ifdef VER170}
+      {$define Version2005}
+    {$endif}
+
+    {$define Version2005Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 18.0}         // bds 2006
+    {$ifdef VER180}
+      {$define Version2006}
+    {$endif}
+
+    {$define Version2006Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 18.5}         // bds 2007
+    {$ifdef VER185}
+      {$define Version2007}
+    {$endif}
+
+    {$define Version2007Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 20.0}         // bds 2009
+    {$ifdef VER200}
+      {$define Version2009}
+    {$endif}
+
+    {$define Version2009Plus}
+  {$ifend}
+
+  {$if CompilerVersion &gt;= 21.0}         // bds 2010
+    {$ifdef VER210}
+      {$define Version2010}
+    {$endif}
+
+    {$define Version2010Plus}
+  {$ifend}
+
+{$endif}

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.pas
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.pas	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/ZLibEx.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,2168 @@
+{*****************************************************************************
+*  ZLibEx.pas                                                                *
+*                                                                            *
+*  copyright (c) 2000-2010 base2 technologies                                *
+*  copyright (c) 1995-2002 Borland Software Corporation                      *
+*                                                                            *
+*  revision history                                                          *
+*    2010.07.01  hide overloaded Z*String* routines for delphi 5             *
+*    2010.05.02  added ZDelfateEx and ZInflateEx                             *
+*    2010.04.20  added TZ*Buffer classes                                     *
+*    2010.04.15  moved core zlib routines to separate unit (ZLibExApi.pas)   *
+*                added ZDeflate* and ZInflate*                               *
+*    2010.04.14  fixed ZInternalCompress loops                               *
+*                fixed ZInternalDecompress loops                             *
+*                updated ZInternalCompressStream loops                       *
+*                updated ZInternalDecompressStream loops                     *
+*    2010.01.27  updated for delphi 2010                                     *
+*    2009.04.14  added overloaded string routines for AnsiString and         *
+*                  UnicodeString                                             *
+*    2009.01.28  updated for delphi 2009 String (UnicodeString)              *
+*    2008.05.15  added TStreamPos type for Stream.Position variants          *
+*                added TCustomZStream.Stream* methods                        *
+*    2007.08.17  modified TZCompressionStream.Write to use Write instead of  *
+*                  WriteBuffer                                               *
+*    2007.03.15  moved gzip routines to separate unit (ZLibExGZ.pas)         *
+*    2006.10.07  fixed EZLibError constructor for c++ builder compatibility  *
+*    2006.03.28  moved Z_DEFLATED to interface section                       *
+*                added custom compression levels zcLevel1 thru zcLevel9      *
+*    2006.03.27  added ZCompressStreamWeb                                    *
+*    2006.03.24  added ZAdler32 and ZCrc32                                   *
+*    2005.11.29  changed FStreamPos to Int64 for delphi 6+                   *
+*    2005.03.04  modified ZInternalCompressStream loops                      *
+*                modified ZInternalDecompressStream loops                    *
+*    2005.02.07  fixed ZInternalCompressStream loop conditions               *
+*                fixed ZInternalDecompressStream loop conditions             *
+*    2005.01.11  added ZCompressStrWeb                                       *
+*    2003.04.14  added ZCompress2 and ZDecompress2                           *
+*                added ZCompressStr2 and ZDecompressStr2                     *
+*                added ZCompressStream2 and ZDecompressStream2               *
+*                added overloaded T*Stream constructors to support           *
+*                  InflateInit2 and DeflateInit2                             *
+*                fixed ZDecompressStream to use ZDecompressCheck instead of  *
+*                  ZCompressCheck                                            *
+*    2001.11.27  enhanced TZDecompressionStream.Read to adjust source        *
+*                  stream position upon end of compression data              *
+*                fixed endless loop in TZDecompressionStream.Read when       *
+*                  destination count was greater than uncompressed data      *
+*    2001.10.26  renamed unit to integrate &quot;nicely&quot; with delphi 6            *
+*    2000.11.24  added soFromEnd condition to TZDecompressionStream.Seek     *
+*                added ZCompressStream and ZDecompressStream                 *
+*    2000.06.13  optimized, fixed, rewrote, and enhanced the zlib.pas unit   *
+*                  included on the delphi cd (zlib version 1.1.3)            *
+*                                                                            *
+*  acknowledgments                                                           *
+*    erik turner                                                             *
+*      2001.10.26  Z*Stream routines                                         *
+*                                                                            *
+*    david bennion                                                           *
+*      2001.11.27  finding the nasty little endless loop quirk with the      *
+*                    TZDecompressionStream.Read method                       *
+*                                                                            *
+*    luigi sandon                                                            *
+*      2005.02.07  pointing out the missing loop condition (Z_STREAM_END)    *
+*                    in ZInternalCompressStream and                          *
+*                    ZInternalDecompressStream                               *
+*                                                                            *
+*    ferry van genderen                                                      *
+*      2005.03.04  assisting me fine tune and beta test                      *
+*                    ZInternalCompressStream and ZInternalDecompressStream   *
+*                                                                            *
+*    j. rathlev                                                              *
+*      2005.11.28  pointing out the FStreamPos and TStream.Position type     *
+*                    inconsistency                                           *
+*                                                                            *
+*    anders johansen                                                         *
+*      2006.10.07  pointing out the ELibError constructor incompatibility    *
+*                    with c++ builder                                        *
+*                                                                            *
+*    marcin szafranski                                                       *
+*      2009.01.28  beta testing the delphi 2009 changes                      *
+*                                                                            *
+*    iztok kacin                                                             *
+*      2009.04.14  assisting me design and further improve support for       *
+*                    delphi 2009                                             *
+*                                                                            *
+*    oleg matrozov                                                           *
+*      2010.04.14  pointing out the missing loop condition (avail_in &gt; 0)    *
+*                    in ZInternalCompress and ZInternalDecompress            *
+*      2010.04.20  prototyping and assisting with the TZ*Buffer classes      *
+*                                                                            *
+*    edward koo                                                              *
+*      2010.07.01  pointing out the delphi 5 incompatibility with the        *
+*                    overloaded Z*String* routines                           *
+*****************************************************************************}
+
+unit ZLibEx;
+
+interface
+
+{$I ZLibEx.inc}
+
+uses
+  SysUtils, Classes, ZLibExApi;
+
+type
+
+{$ifndef UNICODE}
+
+  RawByteString = AnsiString;
+
+  UnicodeString = WideString;
+  UnicodeChar = WideChar;
+
+{$else ifdef Version2010Plus}
+
+  UnicodeChar = WideChar;
+
+{$endif}
+
+  TStreamPos = {$ifdef Version6Plus} Int64 {$else} Longint {$endif};
+
+  TZCompressionLevel = (
+    zcNone,
+    zcFastest,
+    zcDefault,
+    zcMax,
+    zcLevel1,
+    zcLevel2,
+    zcLevel3,
+    zcLevel4,
+    zcLevel5,
+    zcLevel6,
+    zcLevel7,
+    zcLevel8,
+    zcLevel9
+  );
+
+  TZStrategy = (
+    zsDefault,
+    zsFiltered,
+    zsHuffman,
+    zsRLE,
+    zsFixed
+  );
+
+  TZError = (
+    zeError,
+    zeStreamError,
+    zeDataError,
+    zeMemoryError,
+    zeBufferError,
+    zeVersionError
+  );
+
+  TZFlush = (
+    zfNoFlush,
+    zfPartialFlush,
+    zfSyncFlush,
+    zfFullFlush,
+    zfFinish,
+    zfBlock,
+    zfTrees
+  );
+
+const
+  ZLevels: Array [TZCompressionLevel] of Integer = (
+    Z_NO_COMPRESSION,       // zcNone
+    Z_BEST_SPEED,           // zcFastest
+    Z_DEFAULT_COMPRESSION,  // zcDefault
+    Z_BEST_COMPRESSION,     // zcMax
+    1,                      // zcLevel1
+    2,                      // zcLevel2
+    3,                      // zcLevel3
+    4,                      // zcLevel4
+    5,                      // zcLevel5
+    6,                      // zcLevel6
+    7,                      // zcLevel7
+    8,                      // zcLevel8
+    9                       // zcLevel9
+  );
+
+  ZStrategies: Array [TZStrategy] of Integer = (
+    Z_DEFAULT_STRATEGY,     // zsDefault
+    Z_FILTERED,             // zsFiltered
+    Z_HUFFMAN_ONLY,         // zsHuffman
+    Z_RLE,                  // zsRLE
+    Z_FIXED                 // zsFixed
+  );
+
+  ZErrors: Array [TZError] of Integer = (
+    Z_ERRNO,                // zeError
+    Z_STREAM_ERROR,         // zeStreamError
+    Z_DATA_ERROR,           // zeDataError
+    Z_MEM_ERROR,            // zeMemoryError
+    Z_BUF_ERROR,            // zeBufferError
+    Z_VERSION_ERROR         // zeVersionError
+  );
+
+  ZFlushes: Array [TZFlush] of Integer = (
+    Z_NO_FLUSH,             // zfNoFlush
+    Z_PARTIAL_FLUSH,        // zfPartialFlush
+    Z_SYNC_FLUSH,           // zfSyncFlush
+    Z_FULL_FLUSH,           // zfFullFlush
+    Z_FINISH,               // zfFinish
+    Z_BLOCK,                // zfBlock
+    Z_TREES                 // zfTrees
+  );
+
+type
+  {** TZ*Function ***********************************************************}
+
+  TZReadFunction = function (param: Pointer; var buffer;
+    size: Integer): Integer;
+
+  TZWriteFunction = function (param: Pointer; const buffer;
+    size: Integer): Integer;
+
+  {** TZInformation *********************************************************}
+
+  TZInformation = packed record
+    CompressedFlags  : Longint;
+    CompressedSize   : TStreamPos;
+    CompressedCrc    : Longint;
+    CompressedAdler  : Longint;
+
+    UncompressedFlags: Longint;
+    UncompressedSize : TStreamPos;
+    UncompressedCrc  : Longint;
+    UncompressedAdler: Longint;
+  end;
+
+  {** TCustomZStream ********************************************************}
+
+  TCustomZStream = class(TStream)
+  private
+    FStream    : TStream;
+    FStreamPos : TStreamPos;
+    FOnProgress: TNotifyEvent;
+
+    FZStream   : TZStreamRec;
+    FBuffer    : Array [Word] of Byte;
+
+    function  GetStreamPosition: TStreamPos;
+    procedure SetStreamPosition(value: TStreamPos);
+  protected
+    constructor Create(stream: TStream);
+
+    function  StreamRead(var buffer; count: Longint): Longint;
+    function  StreamWrite(const buffer; count: Longint): Longint;
+    function  StreamSeek(offset: Longint; origin: Word): Longint;
+
+    procedure StreamReadBuffer(var buffer; count: Longint);
+    procedure StreamWriteBuffer(const buffer; count: Longint);
+
+    procedure DoProgress; dynamic;
+
+    property StreamPosition: TStreamPos read GetStreamPosition write SetStreamPosition;
+
+    property OnProgress: TNotifyEvent read FOnProgress write FOnProgress;
+  end;
+
+  {** TZCompressionStream ***************************************************}
+
+  TZCompressionStream = class(TCustomZStream)
+  private
+    function GetCompressionRate: Single;
+  public
+    constructor Create(dest: TStream;
+      compressionLevel: TZCompressionLevel = zcDefault); overload;
+
+    constructor Create(dest: TStream; compressionLevel: TZCompressionLevel;
+      windowBits, memLevel: Integer; strategy: TZStrategy); overload;
+
+    destructor  Destroy; override;
+
+    function  Read(var buffer; count: Longint): Longint; override;
+    function  Write(const buffer; count: Longint): Longint; override;
+    function  Seek(offset: Longint; origin: Word): Longint; override;
+
+    property CompressionRate: Single read GetCompressionRate;
+    property OnProgress;
+  end;
+
+  {** TZDecompressionStream *************************************************}
+
+  TZDecompressionStream = class(TCustomZStream)
+  public
+    constructor Create(source: TStream); overload;
+    constructor Create(source: TStream; windowBits: Integer); overload;
+
+    destructor  Destroy; override;
+
+    function  Read(var buffer; count: Longint): Longint; override;
+    function  Write(const buffer; count: Longint): Longint; override;
+    function  Seek(offset: Longint; origin: Word): Longint; override;
+
+    property OnProgress;
+  end;
+
+  {** TZCustomBuffer ********************************************************}
+
+  TZCustomBuffer = class(TObject)
+  private
+    FBuffer        : Pointer;
+    FBufferCapacity: Integer;
+    FBufferSize    : Integer;
+  protected
+    FZStream: TZStreamRec;
+
+    procedure BufferWrite(const buffer: Pointer; size: Integer);
+    procedure BufferRead(var buffer: Pointer; size: Integer);
+
+    procedure BufferCapacity(capacity: Integer);
+
+    property BufferSize: Integer read FBufferSize;
+  public
+    constructor Create;
+    destructor  Destroy; override;
+
+    procedure Clear; virtual;
+
+    procedure Flush(flush: TZFlush); virtual;
+
+    function  Write(const buffer: Pointer; size: Integer): Integer; overload;
+      virtual; abstract;
+
+    function  Write(const s: AnsiString): Integer; overload;
+
+    function  Read(var buffer: Pointer; size: Integer): Integer; overload;
+    function  Read(var s: AnsiString): Integer; overload;
+  end;
+
+  {** TZCompressionBuffer ***************************************************}
+
+  TZCompressionBuffer = class(TZCustomBuffer)
+  public
+    constructor Create(level: TZCompressionLevel = zcDefault); overload;
+    constructor Create(level: TZCompressionLevel;
+      windowBits, memLevel: Integer; strategy: TZStrategy); overload;
+
+    destructor  Destroy; override;
+
+    procedure Clear; override;
+
+    procedure Flush(flush: TZFlush); override;
+
+    function  Write(const buffer: Pointer; size: Integer): Integer;
+      override;
+  end;
+
+  {** TZDecompressionBuffer *************************************************}
+
+  TZDecompressionBuffer = class(TZCustomBuffer)
+  public
+    constructor Create; overload;
+    constructor Create(windowBits: Integer); overload;
+
+    destructor  Destroy; override;
+
+    procedure Clear; override;
+
+    function  Write(const buffer: Pointer; size: Integer): Integer; override;
+  end;
+
+{** zlib deflate routines ***************************************************}
+
+function  ZDeflateInit(var stream: TZStreamRec;
+  level: TZCompressionLevel): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZDeflateInit2(var stream: TZStreamRec;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZDeflate(var stream: TZStreamRec; flush: TZFlush): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZDeflateEnd(var stream: TZStreamRec): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZDeflateReset(var stream: TZStreamRec): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+{** zlib inflate routines ***************************************************}
+
+function  ZInflateInit(var stream: TZStreamRec): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZInflateInit2(var stream: TZStreamRec;
+  windowBits: Integer): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZInflate(var stream: TZStreamRec; flush: TZFlush): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZInflateEnd(var stream: TZStreamRec): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZInflateReset(var stream: TZStreamRec): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+{** zlib checksum routines **************************************************}
+
+function  ZAdler32(adler: Longint; const buffer; size: Integer): Longint;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function  ZCrc32(crc: Longint; const buffer; size: Integer): Longint;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+{** zlib custom routines ****************************************************}
+
+procedure ZDeflateEx(var stream: TZStreamRec; param: Pointer;
+  read: TZReadFunction; write: TZWriteFunction; flush: TZFlush);
+
+procedure ZInflateEx(var stream: TZStreamRec; param: Pointer;
+  read: TZReadFunction; write: TZWriteFunction; flush: TZFlush);
+
+{*****************************************************************************
+*  ZCompress                                                                 *
+*                                                                            *
+*  pre-conditions                                                            *
+*    inBuffer  = pointer to uncompressed data                                *
+*    inSize    = size of inBuffer (bytes)                                    *
+*    outBuffer = pointer (unallocated)                                       *
+*    level     = compression level                                           *
+*                                                                            *
+*  post-conditions                                                           *
+*    outBuffer = pointer to compressed data (allocated)                      *
+*    outSize   = size of outBuffer (bytes)                                   *
+*****************************************************************************}
+
+procedure ZCompress(const inBuffer: Pointer; inSize: Integer;
+  out outBuffer: Pointer; out outSize: Integer;
+  level: TZCompressionLevel = zcDefault);
+
+{*****************************************************************************
+*  ZCompress2                                                                *
+*                                                                            *
+*  pre-conditions                                                            *
+*    inBuffer   = pointer to uncompressed data                               *
+*    inSize     = size of inBuffer (bytes)                                   *
+*    outBuffer  = pointer (unallocated)                                      *
+*    level      = compression level                                          *
+*    method     = compression method                                         *
+*    windowBits = window bits                                                *
+*    memLevel   = memory level                                               *
+*    strategy   = compression strategy                                       *
+*                                                                            *
+*  post-conditions                                                           *
+*    outBuffer = pointer to compressed data (allocated)                      *
+*    outSize   = size of outBuffer (bytes)                                   *
+*****************************************************************************}
+
+procedure ZCompress2(const inBuffer: Pointer; inSize: Integer;
+  out outBuffer: Pointer; out outSize: Integer; level: TZCompressionLevel;
+  windowBits, memLevel: Integer; strategy: TZStrategy);
+
+{*****************************************************************************
+*  ZDecompress                                                               *
+*                                                                            *
+*  pre-conditions                                                            *
+*    inBuffer    = pointer to compressed data                                *
+*    inSize      = size of inBuffer (bytes)                                  *
+*    outBuffer   = pointer (unallocated)                                     *
+*    outEstimate = estimated size of uncompressed data (bytes)               *
+*                                                                            *
+*  post-conditions                                                           *
+*    outBuffer = pointer to decompressed data (allocated)                    *
+*    outSize   = size of outBuffer (bytes)                                   *
+*****************************************************************************}
+
+procedure ZDecompress(const inBuffer: Pointer; inSize: Integer;
+ out outBuffer: Pointer; out outSize: Integer; outEstimate: Integer = 0);
+
+{*****************************************************************************
+*  ZDecompress2                                                              *
+*                                                                            *
+*  pre-conditions                                                            *
+*    inBuffer    = pointer to compressed data                                *
+*    inSize      = size of inBuffer (bytes)                                  *
+*    outBuffer   = pointer (unallocated)                                     *
+*    windowBits  = window bits                                               *
+*    outEstimate = estimated size of uncompressed data (bytes)               *
+*                                                                            *
+*  post-conditions                                                           *
+*    outBuffer = pointer to decompressed data (allocated)                    *
+*    outSize   = size of outBuffer (bytes)                                   *
+*****************************************************************************}
+
+procedure ZDecompress2(const inBuffer: Pointer; inSize: Integer;
+ out outBuffer: Pointer; out outSize: Integer; windowBits: Integer;
+ outEstimate: Integer = 0);
+
+{** string routines *********************************************************}
+
+{*****************************************************************************
+*  ZCompressStr                                                              *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s     = uncompressed data string                                        *
+*    level = compression level                                               *
+*                                                                            *
+*  return                                                                    *
+*    compressed data string                                                  *
+*****************************************************************************}
+
+function  ZCompressStr(const s: AnsiString;
+  level: TZCompressionLevel = zcDefault): RawByteString;
+
+procedure ZCompressString(var result: RawByteString; const s: AnsiString;
+  level: TZCompressionLevel = zcDefault); overload;
+
+{$ifdef Version6Plus}
+procedure ZCompressString(var result: RawByteString; const s: UnicodeString;
+  level: TZCompressionLevel = zcDefault); overload;
+{$endif}
+
+{*****************************************************************************
+*  ZCompressStrEx                                                            *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s     = uncompressed data string                                        *
+*    level = compression level                                               *
+*                                                                            *
+*  return                                                                    *
+*    compressed data string with 4 byte (integer) header indicating          *
+*    original uncompressed data length                                       *
+*****************************************************************************}
+
+function  ZCompressStrEx(const s: AnsiString;
+  level: TZCompressionLevel = zcDefault): RawByteString;
+
+procedure ZCompressStringEx(var result: RawByteString; const s: AnsiString;
+  level: TZCompressionLevel = zcDefault); overload;
+
+{$ifdef Version6Plus}
+procedure ZCompressStringEx(var result: RawByteString; const s: UnicodeString;
+  level: TZCompressionLevel = zcDefault); overload;
+{$endif}
+
+{*****************************************************************************
+*  ZCompressStr2                                                             *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s          = uncompressed data string                                   *
+*    level      = compression level                                          *
+*    windowBits = window bits                                                *
+*    memLevel   = memory level                                               *
+*    strategy   = compression strategy                                       *
+*                                                                            *
+*  return                                                                    *
+*    compressed data string                                                  *
+*****************************************************************************}
+
+function  ZCompressStr2(const s: AnsiString; level: TZCompressionLevel;
+  windowBits, memLevel: Integer; strategy: TZStrategy): RawByteString;
+
+procedure ZCompressString2(var result: RawByteString; const s: AnsiString;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy); overload;
+
+{$ifdef Version6Plus}
+procedure ZCompressString2(var result: RawByteString; const s: UnicodeString;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy); overload;
+{$endif}
+
+{*****************************************************************************
+*  ZCompressStrWeb                                                           *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s = uncompressed data string                                            *
+*                                                                            *
+*  return                                                                    *
+*    compressed data string                                                  *
+*****************************************************************************}
+
+function  ZCompressStrWeb(const s: AnsiString): RawByteString;
+
+procedure ZCompressStringWeb(var result: RawByteString; const s: AnsiString);
+  overload;
+
+{$ifdef Version6Plus}
+procedure  ZCompressStringWeb(var result: RawByteString;
+  const s: UnicodeString); overload;
+{$endif}
+
+{*****************************************************************************
+*  ZDecompressStr                                                            *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s = compressed data string                                              *
+*                                                                            *
+*  return                                                                    *
+*    uncompressed data string                                                *
+*****************************************************************************}
+
+function  ZDecompressStr(const s: RawByteString): AnsiString;
+
+procedure ZDecompressString(var result: AnsiString; const s: RawByteString);
+  overload;
+
+{$ifdef Version6Plus}
+procedure ZDecompressString(var result: UnicodeString;
+  const s: RawByteString); overload;
+{$endif}
+
+{*****************************************************************************
+*  ZDecompressStrEx                                                          *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s = compressed data string with 4 byte (integer) header indicating      *
+*        original uncompressed data length                                   *
+*                                                                            *
+*  return                                                                    *
+*    uncompressed data string                                                *
+*****************************************************************************}
+
+function  ZDecompressStrEx(const s: RawByteString): AnsiString;
+
+procedure ZDecompressStringEx(var result: AnsiString; const s: RawByteString);
+  overload;
+
+{$ifdef Version6Plus}
+procedure ZDecompressStringEx(var result: UnicodeString;
+  const s: RawByteString); overload;
+{$endif}
+
+{*****************************************************************************
+*  ZDecompressStr2                                                           *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s          = compressed data string                                     *
+*    windowBits = window bits                                                *
+*                                                                            *
+*  return                                                                    *
+*    uncompressed data string                                                *
+*****************************************************************************}
+
+function  ZDecompressStr2(const s: RawByteString;
+  windowBits: Integer): AnsiString;
+
+procedure ZDecompressString2(var result: AnsiString; const s: RawByteString;
+  windowBits: Integer); overload;
+
+{$ifdef Version6Plus}
+procedure ZDecompressString2(var result: UnicodeString;
+  const s: RawByteString; windowBits: Integer); overload;
+{$endif}
+
+{** stream routines *********************************************************}
+
+procedure ZCompressStream(inStream, outStream: TStream;
+  level: TZCompressionLevel = zcDefault);
+
+procedure ZCompressStream2(inStream, outStream: TStream;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy);
+
+procedure ZCompressStreamWeb(inStream, outStream: TStream);
+
+procedure ZDecompressStream(inStream, outStream: TStream);
+
+procedure ZDecompressStream2(inStream, outStream: TStream;
+  windowBits: Integer);
+
+{****************************************************************************}
+
+type
+  EZLibErrorClass = class of EZlibError;
+
+  EZLibError = class(Exception)
+  private
+    FErrorCode: Integer;
+  public
+    constructor Create(code: Integer; const dummy: String = ''); overload;
+    constructor Create(error: TZError; const dummy: String = ''); overload;
+
+    property ErrorCode: Integer read FErrorCode write FErrorCode;
+  end;
+
+  EZCompressionError = class(EZLibError);
+  EZDecompressionError = class(EZLibError);
+
+implementation
+
+const
+  SZInvalid = 'Invalid ZStream operation!';
+
+{****************************************************************************}
+
+function ZCompressCheck(code: Integer): Integer;
+begin
+  result := code;
+
+  if code &lt; 0 then
+  begin
+    raise EZCompressionError.Create(code);
+  end;
+end;
+
+function ZDecompressCheck(code: Integer; raiseBufferError: Boolean = True): Integer;
+begin
+  Result := code;
+
+  if code &lt; 0 then
+  begin
+    if (code &lt;&gt; Z_BUF_ERROR) or raiseBufferError then
+    begin
+      raise EZDecompressionError.Create(code);
+    end;
+  end;
+end;
+
+{** zlib deflate routines ***************************************************}
+
+function ZDeflateInit(var stream: TZStreamRec;
+  level: TZCompressionLevel): Integer;
+begin
+  result := deflateInit_(stream, ZLevels[level], ZLIB_VERSION,
+    SizeOf(TZStreamRec));
+end;
+
+function ZDeflateInit2(var stream: TZStreamRec;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy): Integer;
+begin
+  result := deflateInit2_(stream, ZLevels[level], Z_DEFLATED, windowBits,
+    memLevel, ZStrategies[strategy], ZLIB_VERSION, SizeOf(TZStreamRec));
+end;
+
+function ZDeflate(var stream: TZStreamRec; flush: TZFlush): Integer;
+begin
+  result := deflate(stream, ZFlushes[flush]);
+end;
+
+function ZDeflateEnd(var stream: TZStreamRec): Integer;
+begin
+  result := deflateEnd(stream);
+end;
+
+function ZDeflateReset(var stream: TZStreamRec): Integer;
+begin
+  result := deflateReset(stream);
+end;
+
+{** zlib inflate routines ***************************************************}
+
+function ZInflateInit(var stream: TZStreamRec): Integer;
+begin
+  result := inflateInit_(stream, ZLIB_VERSION, SizeOf(TZStreamRec));
+end;
+
+function ZInflateInit2(var stream: TZStreamRec;
+  windowBits: Integer): Integer;
+begin
+  result := inflateInit2_(stream, windowBits, ZLIB_VERSION,
+    SizeOf(TZStreamRec));
+end;
+
+function ZInflate(var stream: TZStreamRec; flush: TZFlush): Integer;
+begin
+  result := inflate(stream, ZFlushes[flush]);
+end;
+
+function ZInflateEnd(var stream: TZStreamRec): Integer;
+begin
+  result := inflateEnd(stream);
+end;
+
+function ZInflateReset(var stream: TZStreamRec): Integer;
+begin
+  result := inflateReset(stream);
+end;
+
+{** zlib checksum routines **************************************************}
+
+function ZAdler32(adler: Longint; const buffer; size: Integer): Longint;
+begin
+  result := adler32(adler,buffer,size);
+end;
+
+function ZCrc32(crc: Longint; const buffer; size: Integer): Longint;
+begin
+  result := crc32(crc,buffer,size);
+end;
+
+{** zlib extended routines **************************************************}
+
+procedure ZDeflateEx(var stream: TZStreamRec; param: Pointer;
+  read: TZReadFunction; write: TZWriteFunction; flush: TZFlush);
+const
+  bufferSize = 8192;
+var
+  zresult    : Integer;
+  readBuffer : Array [0..bufferSize - 1] of Byte;
+  writeBuffer: Array [0..bufferSize - 1] of Byte;
+  writeSize  : Integer;
+  flushEx    : TZFlush;
+begin
+  if Assigned(read) then
+  begin
+    stream.avail_in := read(param, readBuffer, bufferSize);
+  end
+  else stream.avail_in := 0;
+
+  repeat
+    stream.next_in := @readBuffer;
+
+    repeat
+      stream.avail_out := bufferSize;
+      stream.next_out := @writeBuffer;
+
+      flushEx := flush;
+
+      if (flushEx = zfFinish) and (stream.avail_in = bufferSize) then
+      begin
+        flushEx := zfNoFlush;
+      end;
+
+      zresult := ZCompressCheck(ZDeflate(stream, flushEx));
+
+      writeSize := bufferSize - stream.avail_out;
+
+      write(param, writeBuffer, writeSize);
+    until stream.avail_out &gt; 0;
+
+    //assert: stream.avail_in = 0
+
+    if (zresult &lt;&gt; Z_STREAM_END) and Assigned(read) then
+    begin
+      stream.avail_in := read(param, readBuffer, bufferSize);
+    end;
+  until (stream.avail_in = 0) and (flush = flushEx);
+end;
+
+procedure ZInflateEx(var stream: TZStreamRec; param: Pointer;
+  read: TZReadFunction; write: TZWriteFunction; flush: TZFlush);
+const
+  bufferSize = 8192;
+var
+  zresult    : Integer;
+  readBuffer : Array [0..bufferSize - 1] of Byte;
+  writeBuffer: Array [0..bufferSize - 1] of Byte;
+  writeSize  : Integer;
+begin
+  if Assigned(read) then
+  begin
+    stream.avail_in := read(param, readBuffer, bufferSize);
+  end
+  else stream.avail_in := 0;
+
+  zresult := Z_OK;
+
+  while (zresult &lt;&gt; Z_STREAM_END) and (stream.avail_in &gt; 0) do
+  begin
+    stream.next_in := @readBuffer;
+
+    repeat
+      stream.avail_out := bufferSize;
+      stream.next_out := @writeBuffer;
+
+      zresult := ZDecompressCheck(ZInflate(stream, flush), False);
+
+      writeSize := bufferSize - stream.avail_out;
+
+      write(param, writeBuffer, writeSize);
+    until stream.avail_out &gt; 0;
+
+    if (zresult &lt;&gt; Z_STREAM_END) and Assigned(read) then
+    begin
+      stream.avail_in := read(param, readBuffer, bufferSize);
+    end;
+  end;
+end;
+
+{** private buffer routines *************************************************}
+
+type
+  PZBufferParam = ^TZBufferParam;
+  TZBufferParam = packed record
+    InBuffer   : Pointer;
+    InPosition : Integer;
+    InSize     : Integer;
+    OutBuffer  : Pointer;
+    OutPosition: Integer;
+    OutSize    : Integer;
+  end;
+
+function ZBufferRead(p: Pointer; var buffer; size: Integer): Integer;
+var
+  param: PZBufferParam;
+begin
+  param := PZBufferParam(p);
+
+  result := param^.InSize - param^.InPosition;
+  if result &gt; size then result := size;
+
+  Move(Pointer(Integer(param^.InBuffer) + param^.InPosition)^, buffer, result);
+
+  Inc(param^.InPosition, result);
+end;
+
+function ZBufferWrite(p: Pointer; const buffer; size: Integer): Integer;
+var
+  param: PZBufferParam;
+begin
+  param := PZBufferParam(p);
+
+  if param^.OutPosition + size &gt; param^.OutSize then
+  begin
+    param^.OutSize := param^.OutPosition + size;
+
+    ReallocMem(Pointer(param^.OutBuffer), param^.OutSize);
+  end;
+
+  Move(buffer, Pointer(Integer(param^.OutBuffer) + param^.OutPosition)^, size);
+
+  Inc(param^.OutPosition, size);
+
+  result := size;
+end;
+
+procedure ZInternalCompressEx(var zstream: TZStreamRec; const inBuffer: Pointer;
+  inSize: Integer; out outBuffer: Pointer; out outSize: Integer);
+var
+  param: TZBufferParam;
+begin
+  FillChar(param, SizeOf(TZBufferParam), 0);
+
+  outBuffer := Nil;
+  outSize := 0;
+
+  param.InBuffer := inBuffer;
+  param.InSize := inSize;
+
+  try
+    ZDeflateEx(zstream, @param, @ZBufferRead, @ZBufferWrite, zfFinish);
+
+    ZCompressCheck(ZDeflateEnd(zstream));
+
+    outBuffer := param.OutBuffer;
+    outSize := param.OutSize;
+  except
+    FreeMem(param.OutBuffer);
+
+    raise;
+  end;
+end;
+
+procedure ZInternalDecompressEx(zstream: TZStreamRec; const inBuffer: Pointer;
+  inSize: Integer; out outBuffer: Pointer; out outSize: Integer;
+  outEstimate: Integer);
+var
+  param: TZBufferParam;
+begin
+  FillChar(param, SizeOf(TZBufferParam), 0);
+
+  outBuffer := Nil;
+  outSize := 0;
+
+  param.InBuffer := inBuffer;
+  param.InSize := inSize;
+
+  if outEstimate &gt; 0 then
+  begin
+    GetMem(param.OutBuffer, outEstimate);
+
+    param.OutSize := outEstimate;
+  end;
+
+  try
+    ZInflateEx(zstream, @param, @ZBufferRead, @ZBufferWrite, zfNoFlush);
+
+    ZDecompressCheck(ZInflateEnd(zstream));
+
+    outBuffer := param.OutBuffer;
+    outSize := param.OutSize;
+  except
+    FreeMem(param.OutBuffer);
+
+    raise;
+  end;
+end;
+
+procedure ZInternalCompress(var zstream: TZStreamRec; const inBuffer: Pointer;
+  inSize: Integer; out outBuffer: Pointer; out outSize: Integer);
+const
+  delta = 256;
+var
+  zresult: Integer;
+begin
+  outSize := ((inSize + (inSize div 10) + 12) + 255) and not 255;
+
+  outBuffer := Nil;
+
+  try
+    try
+      zstream.next_in := inBuffer;
+      zstream.avail_in := inSize;
+
+      repeat
+        ReallocMem(outBuffer, outSize);
+
+        zstream.next_out := Pointer(Integer(outBuffer) + zstream.total_out);
+        zstream.avail_out := outSize - zstream.total_out;
+
+        zresult := ZCompressCheck(ZDeflate(zstream, zfNoFlush));
+
+        Inc(outSize, delta);
+      until (zresult = Z_STREAM_END) or (zstream.avail_in = 0);
+
+      while zresult &lt;&gt; Z_STREAM_END do
+      begin
+        ReallocMem(outBuffer, outSize);
+
+        zstream.next_out := Pointer(Integer(outBuffer) + zstream.total_out);
+        zstream.avail_out := outSize - zstream.total_out;
+
+        zresult := ZCompressCheck(ZDeflate(zstream, zfFinish));
+
+        Inc(outSize, delta);
+      end;
+    finally
+      ZCompressCheck(ZDeflateEnd(zstream));
+    end;
+
+    ReallocMem(outBuffer, zstream.total_out);
+
+    outSize := zstream.total_out;
+  except
+    FreeMem(outBuffer);
+    raise;
+  end;
+end;
+
+procedure ZInternalDecompress(zstream: TZStreamRec; const inBuffer: Pointer;
+  inSize: Integer; out outBuffer: Pointer; out outSize: Integer;
+  outEstimate: Integer);
+var
+  zresult: Integer;
+  delta  : Integer;
+begin
+  delta := (inSize + 255) and not 255;
+
+  if outEstimate = 0 then outSize := delta
+  else outSize := outEstimate;
+
+  outBuffer := Nil;
+
+  try
+    try
+      zresult := Z_OK;
+
+      zstream.avail_in := inSize;
+      zstream.next_in := inBuffer;
+
+      while (zresult &lt;&gt; Z_STREAM_END) and (zstream.avail_in &gt; 0) do
+      begin
+        repeat
+          ReallocMem(outBuffer, outSize);
+
+          zstream.next_out := Pointer(Integer(outBuffer) + zstream.total_out);
+          zstream.avail_out := outSize - zstream.total_out;
+
+          zresult := ZDecompressCheck(ZInflate(zstream, zfNoFlush), False);
+
+          Inc(outSize, delta);
+        until (zresult = Z_STREAM_END) or (zstream.avail_out &gt; 0);
+      end;
+    finally
+      ZDecompressCheck(ZInflateEnd(zstream));
+    end;
+
+    ReallocMem(outBuffer, zstream.total_out);
+
+    outSize := zstream.total_out;
+  except
+    if Assigned(outBuffer) then FreeMem(outBuffer);
+
+    raise;
+  end;
+end;
+
+{** buffer routines *********************************************************}
+
+procedure ZCompress(const inBuffer: Pointer; inSize: Integer;
+  out outBuffer: Pointer; out outSize: Integer;
+  level: TZCompressionLevel);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZCompressCheck(ZDeflateInit(zstream, level));
+
+  ZInternalCompress(zstream, inBuffer, inSize, outBuffer, outSize);
+end;
+
+procedure ZCompress2(const inBuffer: Pointer; inSize: Integer;
+  out outBuffer: Pointer; out outSize: Integer; level: TZCompressionLevel;
+  windowBits, memLevel: Integer; strategy: TZStrategy);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZCompressCheck(ZDeflateInit2(zstream, level, windowBits, memLevel,
+    strategy));
+
+  ZInternalCompress(zstream, inBuffer, inSize, outBuffer, outSize);
+end;
+
+procedure ZDecompress(const inBuffer: Pointer; inSize: Integer;
+  out outBuffer: Pointer; out outSize: Integer; outEstimate: Integer);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZDecompressCheck(ZInflateInit(zstream));
+
+  ZInternalDecompress(zstream, inBuffer, inSize, outBuffer, outSize,
+    outEstimate);
+end;
+
+procedure ZDecompress2(const inBuffer: Pointer; inSize: Integer;
+  out outBuffer: Pointer; out outSize: Integer; windowBits: Integer;
+  outEstimate: Integer);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZDecompressCheck(ZInflateInit2(zstream, windowBits));
+
+  ZInternalDecompress(zstream, inBuffer, inSize, outBuffer, outSize,
+    outEstimate);
+end;
+
+{** string routines *********************************************************}
+
+function ZCompressStr(const s: AnsiString;
+  level: TZCompressionLevel): RawByteString;
+begin
+  ZCompressString(result, s, level);
+end;
+
+procedure ZCompressString(var result: RawByteString; const s: AnsiString;
+  level: TZCompressionLevel);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZCompress(Pointer(s), Length(s), buffer, size, level);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+
+{$ifdef Version6Plus}
+procedure ZCompressString(var result: RawByteString; const s: UnicodeString;
+  level: TZCompressionLevel);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZCompress(Pointer(s), Length(s) * SizeOf(UnicodeChar), buffer, size, level);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+{$endif}
+
+function ZCompressStrEx(const s: AnsiString;
+  level: TZCompressionLevel): RawByteString;
+begin
+  ZCompressStringEx(result, s, level);
+end;
+
+procedure ZCompressStringEx(var result: RawByteString; const s: AnsiString;
+  level: TZCompressionLevel);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZCompress(Pointer(s), Length(s), buffer, size, level);
+
+  SetLength(result, size + SizeOf(Integer));
+
+  Move(buffer^, result[5], size);
+
+  size := Length(s);
+
+  Move(size, result[1], SizeOf(Integer));
+
+  FreeMem(buffer);
+end;
+
+{$ifdef Version6Plus}
+procedure ZCompressStringEx(var result: RawByteString; const s: UnicodeString;
+  level: TZCompressionLevel);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZCompress(Pointer(s), Length(s) * SizeOf(UnicodeChar), buffer, size, level);
+
+  SetLength(result, size + SizeOf(Integer));
+
+  Move(buffer^, result[5], size);
+
+  size := Length(s) * SizeOf(UnicodeChar);
+
+  Move(size, result[1], SizeOf(Integer));
+
+  FreeMem(buffer);
+end;
+{$endif}
+
+function ZCompressStr2(const s: AnsiString; level: TZCompressionLevel;
+  windowBits, memLevel: Integer; strategy: TZStrategy): RawByteString;
+begin
+  ZCompressString2(result, s, level, windowBits, memLevel, strategy);
+end;
+
+procedure ZCompressString2(var result: RawByteString; const s: AnsiString;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZCompress2(Pointer(s), Length(s), buffer, size, level, windowBits,
+    memLevel, strategy);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+
+{$ifdef Version6Plus}
+procedure ZCompressString2(var result: RawByteString; const s: UnicodeString;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZCompress2(Pointer(s), Length(s) * SizeOf(UnicodeChar), buffer, size,
+    level, windowBits, memLevel, strategy);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+{$endif}
+
+function ZCompressStrWeb(const s: AnsiString): RawByteString;
+begin
+  ZCompressStringWeb(result, s);
+end;
+
+procedure ZCompressStringWeb(var result: RawByteString; const s: AnsiString);
+begin
+  ZCompressString2(result, s, zcFastest, -15, 9, zsDefault);
+end;
+
+{$ifdef Version6Plus}
+procedure ZCompressStringWeb(var result: RawBytestring;
+  const s: UnicodeString);
+begin
+  ZCompressString2(result, s, zcFastest, -15, 9, zsDefault);
+end;
+{$endif}
+
+function ZDecompressStr(const s: RawByteString): AnsiString;
+begin
+  ZDecompressString(result, s);
+end;
+
+procedure ZDecompressString(var result: AnsiString;
+  const s: RawByteString);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZDecompress(Pointer(s), Length(s), buffer, size);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+
+{$ifdef Version6Plus}
+procedure ZDecompressString(var result: UnicodeString;
+  const s: RawByteString);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZDecompress(Pointer(s), Length(s), buffer, size);
+
+  SetLength(result, size div SizeOf(UnicodeChar));
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+{$endif}
+
+function ZDecompressStrEx(const s: RawByteString): AnsiString;
+begin
+  ZDecompressStringEx(result, s);
+end;
+
+procedure ZDecompressStringEx(var result: AnsiString; const s: RawByteString);
+var
+  buffer  : Pointer;
+  size    : Integer;
+  data    : AnsiString;
+  dataSize: Integer;
+begin
+  Move(s[1], size, SizeOf(Integer));
+
+  dataSize := Length(s) - SizeOf(Integer);
+
+  SetLength(data, dataSize);
+
+  Move(s[5], data[1], dataSize);
+
+  ZDecompress(Pointer(data), dataSize, buffer, size, size);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+
+{$ifdef Version6Plus}
+procedure ZDecompressStringEx(var result: UnicodeString;
+  const s: RawByteString);
+var
+  buffer  : Pointer;
+  size    : Integer;
+  data    : AnsiString;
+  dataSize: Integer;
+begin
+  Move(s[1], size, SizeOf(Integer));
+
+  dataSize := Length(s) - SizeOf(Integer);
+
+  SetLength(data, dataSize);
+
+  Move(s[5], data[1], dataSize);
+
+  ZDecompress(Pointer(data), dataSize, buffer, size, size);
+
+  SetLength(result, size div SizeOf(UnicodeChar));
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+{$endif}
+
+function ZDecompressStr2(const s: RawByteString;
+  windowBits: Integer): AnsiString;
+begin
+  ZDecompressString2(result, s, windowBits);
+end;
+
+procedure ZDecompressString2(var result: AnsiString; const s: RawByteString;
+  windowBits: Integer);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZDecompress2(Pointer(s), Length(s), buffer, size, windowBits);
+
+  SetLength(result, size);
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+
+{$ifdef Version6Plus}
+procedure ZDecompressString2(var result: UnicodeString;
+  const s: RawByteString; windowBits: Integer);
+var
+  buffer: Pointer;
+  size  : Integer;
+begin
+  ZDecompress2(Pointer(s), Length(s), buffer, size, windowBits);
+
+  SetLength(result, size div SizeOf(UnicodeChar));
+
+  Move(buffer^, result[1], size);
+
+  FreeMem(buffer);
+end;
+{$endif}
+
+{** private stream routines *************************************************}
+
+type
+  PZStreamParam = ^TZStreamParam;
+  TZStreamParam = packed record
+    InStream   : TStream;
+    OutStream  : TStream;
+  end;
+
+function ZStreamRead(p: Pointer; var buffer; size: Integer): Integer;
+var
+  param: PZStreamParam;
+begin
+  param := PZStreamParam(p);
+
+  result := param^.InStream.Read(buffer, size);
+end;
+
+function ZStreamWrite(p: Pointer; const buffer; size: Integer): Integer;
+var
+  param: PZStreamParam;
+begin
+  param := PZStreamParam(p);
+
+  result := param^.OutStream.Write(buffer, size);
+end;
+
+procedure ZInternalCompressStreamEx(zstream: TZStreamRec; inStream,
+  outStream: TStream);
+var
+  param: TZStreamParam;
+begin
+  FillChar(param, SizeOf(TZStreamParam), 0);
+
+  param.InStream := inStream;
+  param.OutStream := outStream;
+
+  ZDeflateEx(zstream, @param, @ZBufferRead, @ZBufferWrite, zfFinish);
+
+  ZCompressCheck(ZDeflateEnd(zstream));
+end;
+
+procedure ZInternalDecompressStreamEx(zstream: TZStreamRec; inStream,
+  outStream: TStream);
+var
+  param: TZStreamParam;
+begin
+  FillChar(param, SizeOf(TZStreamParam), 0);
+
+  param.InStream := inStream;
+  param.OutStream := outStream;
+
+  ZInflateEx(zstream, @param, @ZBufferRead, @ZBufferWrite, zfNoFlush);
+
+  ZDecompressCheck(ZInflateEnd(zstream));
+end;
+
+procedure ZInternalCompressStream(zstream: TZStreamRec; inStream,
+  outStream: TStream);
+const
+  bufferSize = 32768;
+var
+  zresult  : Integer;
+  inBuffer : Array [0..bufferSize-1] of Byte;
+  outBuffer: Array [0..bufferSize-1] of Byte;
+  outSize  : Integer;
+begin
+  zresult := Z_STREAM_END;
+
+  zstream.avail_in := inStream.Read(inBuffer, bufferSize);
+
+  while zstream.avail_in &gt; 0 do
+  begin
+    zstream.next_in := @inBuffer;
+
+    repeat
+      zstream.next_out := @outBuffer;
+      zstream.avail_out := bufferSize;
+
+      zresult := ZCompressCheck(ZDeflate(zstream, zfNoFlush));
+
+      outSize := bufferSize - zstream.avail_out;
+
+      outStream.Write(outBuffer, outSize);
+    until (zresult = Z_STREAM_END) or (zstream.avail_in = 0);
+
+    zstream.avail_in := inStream.Read(inBuffer, bufferSize);
+  end;
+
+  while zresult &lt;&gt; Z_STREAM_END do
+  begin
+    zstream.next_out := @outBuffer;
+    zstream.avail_out := bufferSize;
+
+    zresult := ZCompressCheck(ZDeflate(zstream, zfFinish));
+
+    outSize := bufferSize - zstream.avail_out;
+
+    outStream.Write(outBuffer, outSize);
+  end;
+
+  ZCompressCheck(ZDeflateEnd(zstream));
+end;
+
+procedure ZInternalDecompressStream(zstream: TZStreamRec; inStream,
+  outStream: TStream);
+const
+  bufferSize = 32768;
+var
+  zresult  : Integer;
+  inBuffer : Array [0..bufferSize-1] of Byte;
+  outBuffer: Array [0..bufferSize-1] of Byte;
+  outSize  : Integer;
+begin
+  try
+    zresult := Z_OK;
+
+    zstream.avail_in := inStream.Read(inBuffer, bufferSize);
+
+    while (zresult &lt;&gt; Z_STREAM_END) and (zstream.avail_in &gt; 0) do
+    begin
+      zstream.next_in := @inBuffer;
+
+      repeat
+        zstream.next_out := @outBuffer;
+        zstream.avail_out := bufferSize;
+
+        zresult := ZDecompressCheck(ZInflate(zstream, zfNoFlush), False);
+
+        outSize := bufferSize - zstream.avail_out;
+
+        outStream.Write(outBuffer, outSize);
+      until (zresult = Z_STREAM_END) or (zstream.avail_out &gt; 0);
+
+      if zstream.avail_in &gt; 0 then
+      begin
+        inStream.Position := inStream.Position - zstream.avail_in;
+      end;
+
+      if zresult &lt;&gt; Z_STREAM_END then
+      begin
+        zstream.avail_in := inStream.Read(inBuffer, bufferSize);
+      end;
+    end;
+  finally
+    ZDecompressCheck(ZInflateEnd(zstream));
+  end;
+end;
+
+{** stream routines *********************************************************}
+
+procedure ZCompressStream(inStream, outStream: TStream;
+  level: TZCompressionLevel);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZCompressCheck(ZDeflateInit(zstream, level));
+
+  ZInternalCompressStream(zstream, inStream, outStream);
+end;
+
+procedure ZCompressStream2(inStream, outStream: TStream;
+  level: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZCompressCheck(ZDeflateInit2(zstream, level, windowBits, memLevel,
+    strategy));
+
+  ZInternalCompressStream(zstream,inStream,outStream);
+end;
+
+procedure ZCompressStreamWeb(inStream, outStream: TStream);
+begin
+  ZCompressStream2(inStream, outStream, zcFastest, -15, 9, zsDefault);
+end;
+
+procedure ZDecompressStream(inStream, outStream: TStream);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZDecompressCheck(ZInflateInit(zstream));
+
+  ZInternalDecompressStream(zstream, inStream, outStream);
+end;
+
+procedure ZDecompressStream2(inStream, outStream: TStream;
+  windowBits: Integer);
+var
+  zstream: TZStreamRec;
+begin
+  FillChar(zstream, SizeOf(TZStreamRec), 0);
+
+  ZDecompressCheck(ZInflateInit2(zstream, windowBits));
+
+  ZInternalDecompressStream(zstream, inStream, outStream);
+end;
+
+{** TCustomZStream **********************************************************}
+
+constructor TCustomZStream.Create(stream: TStream);
+begin
+  inherited Create;
+
+  FStream := stream;
+  FStreamPos := stream.Position;
+end;
+
+function TCustomZStream.StreamRead(var buffer; count: Longint): Longint;
+begin
+  if FStream.Position &lt;&gt; FStreamPos then FStream.Position := FStreamPos;
+
+  result := FStream.Read(buffer,count);
+
+  FStreamPos := FStreamPos + result;
+end;
+
+function TCustomZStream.StreamWrite(const buffer; count: Longint): Longint;
+begin
+  if FStream.Position &lt;&gt; FStreamPos then FStream.Position := FStreamPos;
+
+  result := FStream.Write(buffer,count);
+
+  FStreamPos := FStreamPos + result;
+end;
+
+function TCustomZStream.StreamSeek(offset: Longint; origin: Word): Longint;
+begin
+  if FStream.Position &lt;&gt; FStreamPos then FStream.Position := FStreamPos;
+
+  result := FStream.Seek(offset,origin);
+
+  FStreamPos := FStream.Position;
+end;
+
+procedure TCustomZStream.StreamReadBuffer(var buffer; count: Longint);
+begin
+  if FStream.Position &lt;&gt; FStreamPos then FStream.Position := FStreamPos;
+
+  FStream.ReadBuffer(buffer,count);
+
+  FStreamPos := FStreamPos + count;
+end;
+
+procedure TCustomZStream.StreamWriteBuffer(const buffer; count: Longint);
+begin
+  if FStream.Position &lt;&gt; FStreamPos then FStream.Position := FStreamPos;
+
+  FStream.WriteBuffer(buffer,count);
+
+  FStreamPos := FStreamPos + count;
+end;
+
+procedure TCustomZStream.DoProgress;
+begin
+  if Assigned(FOnProgress) then FOnProgress(Self);
+end;
+
+function TCustomZStream.GetStreamPosition: TStreamPos;
+begin
+  result := FStream.Position;
+end;
+
+procedure TCustomZStream.SetStreamPosition(value: TStreamPos);
+begin
+  FStream.Position := value;
+  FStreamPos := FStream.Position;
+end;
+
+{** TZCompressionStream *****************************************************}
+
+constructor TZCompressionStream.Create(dest: TStream;
+  compressionLevel: TZCompressionLevel);
+begin
+  inherited Create(dest);
+
+  FZStream.next_out := @FBuffer;
+  FZStream.avail_out := SizeOf(FBuffer);
+
+  ZCompressCheck(ZDeflateInit(FZStream, compressionLevel));
+end;
+
+constructor TZCompressionStream.Create(dest: TStream;
+  compressionLevel: TZCompressionLevel; windowBits, memLevel: Integer;
+  strategy: TZStrategy);
+begin
+  inherited Create(dest);
+
+  FZStream.next_out := @FBuffer;
+  FZStream.avail_out := SizeOf(FBuffer);
+
+  ZCompressCheck(ZDeflateInit2(FZStream, compressionLevel, windowBits,
+    memLevel, strategy));
+end;
+
+destructor TZCompressionStream.Destroy;
+begin
+  FZStream.next_in := Nil;
+  FZStream.avail_in := 0;
+
+  try
+    while ZCompressCheck(ZDeflate(FZStream, zfFinish)) &lt;&gt; Z_STREAM_END do
+    begin
+      StreamWriteBuffer(FBuffer, SizeOf(FBuffer) - FZStream.avail_out);
+
+      FZStream.next_out := @FBuffer;
+      FZStream.avail_out := SizeOf(FBuffer);
+    end;
+
+    if FZStream.avail_out &lt; SizeOf(FBuffer) then
+    begin
+      StreamWriteBuffer(FBuffer, SizeOf(FBuffer) - FZStream.avail_out);
+    end;
+  finally
+    ZDeflateEnd(FZStream);
+  end;
+
+  inherited Destroy;
+end;
+
+function TZCompressionStream.Read(var buffer; count: Longint): Longint;
+begin
+  raise EZCompressionError.Create(SZInvalid);
+end;
+
+function TZCompressionStream.Write(const buffer; count: Longint): Longint;
+var
+  writeCount: Longint;
+begin
+  result := count;
+
+  FZStream.next_in := @buffer;
+  FZStream.avail_in := count;
+
+  while FZStream.avail_in &gt; 0 do
+  begin
+    ZCompressCheck(ZDeflate(FZStream, zfNoFlush));
+
+    if FZStream.avail_out = 0 then
+    begin
+      writeCount := StreamWrite(FBuffer,SizeOf(FBuffer));
+
+      if writeCount = SizeOf(FBuffer) then
+      begin
+        FZStream.next_out := @FBuffer;
+        FZStream.avail_out := SizeOf(FBuffer);
+
+        DoProgress;
+      end
+      else
+      begin
+        StreamPosition := StreamPosition - writeCount;
+
+        result := count - FZStream.avail_in;
+
+        FZStream.avail_in := 0;
+      end;
+    end;
+  end;
+end;
+
+function TZCompressionStream.Seek(offset: Longint; origin: Word): Longint;
+begin
+  if (offset = 0) and (origin = soFromCurrent) then
+  begin
+    result := FZStream.total_in;
+  end
+  else raise EZCompressionError.Create(SZInvalid);
+end;
+
+function TZCompressionStream.GetCompressionRate: Single;
+begin
+  if FZStream.total_in = 0 then result := 0
+  else result := (1.0 - (FZStream.total_out / FZStream.total_in)) * 100.0;
+end;
+
+{** TZDecompressionStream ***************************************************}
+
+constructor TZDecompressionStream.Create(source: TStream);
+begin
+  inherited Create(source);
+
+  FZStream.next_in := @FBuffer;
+  FZStream.avail_in := 0;
+
+  ZDecompressCheck(ZInflateInit(FZStream));
+end;
+
+constructor TZDecompressionStream.Create(source: TStream;
+  windowBits: Integer);
+begin
+  inherited Create(source);
+
+  FZStream.next_in := @FBuffer;
+  FZStream.avail_in := 0;
+
+  ZDecompressCheck(ZInflateInit2(FZStream, windowBits));
+end;
+
+destructor TZDecompressionStream.Destroy;
+begin
+  ZInflateEnd(FZStream);
+
+  inherited Destroy;
+end;
+
+function TZDecompressionStream.Read(var buffer; count: Longint): Longint;
+var
+  zresult: Integer;
+begin
+  FZStream.next_out := @buffer;
+  FZStream.avail_out := count;
+
+  zresult := Z_OK;
+
+  while (FZStream.avail_out &gt; 0) and (zresult &lt;&gt; Z_STREAM_END) do
+  begin
+    if FZStream.avail_in = 0 then
+    begin
+      FZStream.avail_in := StreamRead(FBuffer,SizeOf(FBuffer));
+
+      if FZStream.avail_in = 0 then
+      begin
+        result := count - FZStream.avail_out;
+
+        Exit;
+      end;
+
+      FZStream.next_in := @FBuffer;
+
+      DoProgress;
+    end;
+
+    zresult := ZDecompressCheck(ZInflate(FZStream, zfNoFlush));
+  end;
+
+  if (zresult = Z_STREAM_END) and (FZStream.avail_in &gt; 0) then
+  begin
+    StreamPosition := StreamPosition - FZStream.avail_in;
+
+    FZStream.avail_in := 0;
+  end;
+
+  result := count - FZStream.avail_out;
+end;
+
+function TZDecompressionStream.Write(const Buffer; Count: Longint): Longint;
+begin
+  raise EZDecompressionError.Create(SZInvalid);
+end;
+
+function TZDecompressionStream.Seek(Offset: Longint; Origin: Word): Longint;
+var
+  buf: Array [0..8191] of Byte;
+  i  : Integer;
+begin
+  if (offset = 0) and (origin = soFromBeginning) then
+  begin
+    ZDecompressCheck(ZInflateReset(FZStream));
+
+    FZStream.next_in := @FBuffer;
+    FZStream.avail_in := 0;
+
+    StreamPosition := 0;
+  end
+  else if ((offset &gt;= 0) and (origin = soFromCurrent)) or
+          (((offset - FZStream.total_out) &gt; 0) and (origin = soFromBeginning)) then
+  begin
+    if origin = soFromBeginning then Dec(offset, FZStream.total_out);
+
+    if offset &gt; 0 then
+    begin
+      for i := 1 to offset div SizeOf(buf) do ReadBuffer(buf, SizeOf(buf));
+      ReadBuffer(buf, offset mod SizeOf(buf));
+    end;
+  end
+  else if (offset = 0) and (origin = soFromEnd) then
+  begin
+    while Read(buf, SizeOf(buf)) &gt; 0 do ;
+  end
+  else raise EZDecompressionError.Create(SZInvalid);
+
+  result := FZStream.total_out;
+end;
+
+{** TZCustomBuffer **********************************************************}
+
+constructor TZCustomBuffer.Create;
+begin
+  inherited Create;
+
+  FillChar(FZStream, SizeOf(TZStreamRec), 0);
+
+  FBuffer := Nil;
+  FBufferCapacity := 0;
+
+  FBufferSize := 0;
+end;
+
+destructor TZCustomBuffer.Destroy;
+begin
+  BufferCapacity(0);
+
+  inherited Destroy;
+end;
+
+procedure TZCustomBuffer.Clear;
+begin
+  BufferCapacity(0);
+
+  FBufferSize := 0;
+end;
+
+procedure TZCustomBuffer.Flush(flush: TZFlush);
+begin
+  // to be implemented by descendents as needed
+end;
+
+function TZCustomBuffer.Write(const s: AnsiString): Integer;
+begin
+  result := Write(Pointer(s), Length(s));
+end;
+
+function TZCustomBuffer.Read(var buffer: Pointer; size: Integer): Integer;
+begin
+  result := BufferSize;
+  if size &lt; result then result := size;
+
+  BufferRead(buffer, result);
+end;
+
+function TZCustomBuffer.Read(var s: AnsiString): Integer;
+begin
+  SetLength(s, BufferSize);
+
+  result := Read(Pointer(s), Length(s));
+end;
+
+procedure TZCustomBuffer.BufferWrite(const buffer: Pointer; size: Integer);
+begin
+  if size &gt; 0 then
+  begin
+    BufferCapacity(FBufferSize + size);
+
+    Move(buffer^, Pointer(Integer(FBuffer) + FBufferSize)^, size);
+
+    Inc(FBufferSize, size);
+  end;
+end;
+
+procedure TZCustomBuffer.BufferRead(var buffer: Pointer; size: Integer);
+begin
+  if size &gt; 0 then
+  begin
+    Move(FBuffer^, buffer^, size);
+
+    Move(Pointer(Integer(FBuffer) + size)^, FBuffer^, FBufferSize - size);
+
+    Dec(FBufferSize, size);
+  end;
+end;
+
+procedure TZCustomBuffer.BufferCapacity(capacity: Integer);
+const
+  delta = 8192; // must be a power of 2
+begin
+  if capacity &gt; 0 then
+  begin
+    capacity := (capacity + (delta - 1)) and not (delta - 1);
+  end;
+
+  if FBufferCapacity &lt;&gt; capacity then
+  begin
+    if capacity = 0 then FreeMem(FBuffer)
+    else if FBufferCapacity = 0 then GetMem(FBuffer, capacity)
+    else ReallocMem(FBuffer, capacity);
+
+    FBufferCapacity := capacity;
+  end;
+end;
+
+{** TZCompressionBuffer *****************************************************}
+
+constructor TZCompressionBuffer.Create(level: TZCompressionLevel);
+begin
+  inherited Create;
+
+  ZCompressCheck(ZDeflateInit(FZStream, level));
+end;
+
+constructor TZCompressionBuffer.Create(level: TZCompressionLevel;
+  windowBits, memLevel: Integer; strategy: TZStrategy);
+begin
+  inherited Create;
+
+  ZCompressCheck(ZDeflateInit2(FZStream, level, windowBits, memLevel,
+    strategy));
+end;
+
+destructor TZCompressionBuffer.Destroy;
+begin
+  ZCompressCheck(ZDeflateEnd(FZStream));
+
+  inherited Destroy;
+end;
+
+procedure TZCompressionBuffer.Clear;
+begin
+  inherited Clear;
+
+  ZCompressCheck(ZDeflateReset(FZStream));
+end;
+
+procedure TZCompressionBuffer.Flush(flush: TZFlush);
+const
+  outSize = 32768;
+var
+  zresult  : Integer;
+  outBuffer: Array [0..outSize - 1] of Byte;
+  outCount : Integer;
+begin
+  FZStream.next_in := Nil;
+  FZStream.avail_in := 0;
+
+  repeat
+    FZStream.next_out := @outBuffer;
+    FZStream.avail_out := outSize;
+
+    zresult := ZCompressCheck(ZDeflate(FZStream, flush));
+
+    outCount := outSize - FZStream.avail_out;
+
+    BufferWrite(@outBuffer, outCount);
+  until (zresult = Z_STREAM_END) or (FZStream.avail_out &gt; 0);
+end;
+
+function TZCompressionBuffer.Write(const buffer: Pointer;
+  size: Integer): Integer;
+const
+  outSize = 32768;
+var
+  zresult  : Integer;
+  outBuffer: Array [0..outSize - 1] of Byte;
+  outCount : Integer;
+begin
+  zresult := Z_OK;
+
+  FZStream.next_in := buffer;
+  FZStream.avail_in := size;
+
+  while (zresult &lt;&gt; Z_STREAM_END) and (FZStream.avail_in &gt; 0) do
+  begin
+    repeat
+      FZStream.next_out := @outBuffer;
+      FZStream.avail_out := outSize;
+
+      zresult := ZCompressCheck(ZDeflate(FZStream, zfNoFlush));
+
+      outCount := outSize - FZStream.avail_out;
+
+      BufferWrite(@outBuffer, outCount);
+    until (zresult = Z_STREAM_END) or (FZStream.avail_out &gt; 0);
+  end;
+
+  result := size - FZStream.avail_in;
+end;
+
+{** TZDecompressionBuffer ***************************************************}
+
+constructor TZDecompressionBuffer.Create;
+begin
+  inherited Create;
+
+  ZDecompressCheck(ZInflateInit(FZStream));
+end;
+
+constructor TZDecompressionBuffer.Create(windowBits: Integer);
+begin
+  inherited Create;
+
+  ZDecompressCheck(ZInflateInit2(FZStream, windowBits));
+end;
+
+destructor TZDecompressionBuffer.Destroy;
+begin
+  ZDecompressCheck(ZInflateEnd(FZStream));
+
+  inherited Destroy;
+end;
+
+procedure TZDecompressionBuffer.Clear;
+begin
+  inherited Clear;
+
+  ZDecompressCheck(ZInflateReset(FZStream));
+end;
+
+function TZDecompressionBuffer.Write(const buffer: Pointer;
+  size: Integer): Integer;
+const
+  outSize = 32768;
+var
+  zresult  : Integer;
+  outBuffer: Array [0..outSize - 1] of Byte;
+  outCount : Integer;
+begin
+  zresult := Z_OK;
+
+  FZStream.next_in := buffer;
+  FZStream.avail_in := size;
+
+  while (zresult &lt;&gt; Z_STREAM_END) and (FZStream.avail_in &gt; 0) do
+  begin
+    repeat
+      FZStream.next_out := @outBuffer;
+      FZStream.avail_out := outSize;
+
+      zresult := ZDecompressCheck(ZInflate(FZStream, zfNoFlush), False);
+
+      outCount := outSize - FZStream.avail_out;
+
+      BufferWrite(@outBuffer, outCount);
+    until (zresult = Z_STREAM_END) or (FZStream.avail_out &gt; 0);
+  end;
+
+  result := size - FZStream.avail_in;
+end;
+
+{** EZLibError **************************************************************}
+
+constructor EZLibError.Create(code: Integer; const dummy: String);
+begin
+  inherited Create(_z_errmsg[2 - code]);
+
+  FErrorCode := code;
+end;
+
+constructor EZLibError.Create(error: TZError; const dummy: String);
+begin
+  Create(ZErrors[error], dummy);
+end;
+
+end.

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.dcu
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.dcu
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.pas
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.pas	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/ZLibExApi.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,301 @@
+{*****************************************************************************
+*  ZLibExApi.pas                                                             *
+*                                                                            *
+*  copyright (c) 2000-2010 base2 technologies                                *
+*  copyright (c) 1995-2002 Borland Software Corporation                      *
+*                                                                            *
+*  revision history                                                          *
+*    2010.04.20  updated to zlib version 1.2.5                               *
+*    2010.04.15  updated to zlib version 1.2.4                               *
+*    2005.07.25  updated to zlib version 1.2.3                               *
+*    2005.01.11  updated to zlib version 1.2.2                               *
+*    2004.01.06  updated to zlib version 1.2.1                               *
+*    2002.03.15  updated to zlib version 1.1.4                               *
+*                                                                            *
+*  acknowledgments                                                           *
+*    burak kalayci                                                           *
+*      2002.03.15  informing me about the zlib 1.1.4 update                  *
+*      2004.01.06  informing me about the zlib 1.2.1 update                  *
+*                                                                            *
+*    vicente sanchez-alarcos                                                 *
+*      2005.01.11  informing me about the zlib 1.2.2 update                  *
+*                                                                            *
+*    mathijs van veluw                                                       *
+*      2005.07.25  informing me about the zlib 1.2.3 update                  *
+*****************************************************************************}
+
+unit ZLibExApi;
+
+interface
+
+{$I ZLibEx.inc}
+
+const
+  {** version ids ***********************************************************}
+
+  ZLIB_VERSION         = '1.2.5';
+  ZLIB_VERNUM          = $1250;
+
+  ZLIB_VER_MAJOR       = 1;
+  ZLIB_VER_MINOR       = 2;
+  ZLIB_VER_REVISION    = 5;
+  ZLIB_VER_SUBREVISION = 0;
+
+  {** compression methods ***************************************************}
+
+  Z_DEFLATED = 8;
+
+  {** information flags *****************************************************}
+
+  Z_INFO_FLAG_SIZE  = $1;
+  Z_INFO_FLAG_CRC   = $2;
+  Z_INFO_FLAG_ADLER = $4;
+
+  Z_INFO_NONE       = 0;
+  Z_INFO_DEFAULT    = Z_INFO_FLAG_SIZE or Z_INFO_FLAG_CRC;
+
+  {** flush constants *******************************************************}
+
+  Z_NO_FLUSH      = 0;
+  Z_PARTIAL_FLUSH = 1;
+  Z_SYNC_FLUSH    = 2;
+  Z_FULL_FLUSH    = 3;
+  Z_FINISH        = 4;
+  Z_BLOCK         = 5;
+  Z_TREES         = 6;
+
+  {** return codes **********************************************************}
+
+  Z_OK            = 0;
+  Z_STREAM_END    = 1;
+  Z_NEED_DICT     = 2;
+  Z_ERRNO         = (-1);
+  Z_STREAM_ERROR  = (-2);
+  Z_DATA_ERROR    = (-3);
+  Z_MEM_ERROR     = (-4);
+  Z_BUF_ERROR     = (-5);
+  Z_VERSION_ERROR = (-6);
+
+  {** compression levels ****************************************************}
+
+  Z_NO_COMPRESSION      =   0;
+  Z_BEST_SPEED          =   1;
+  Z_BEST_COMPRESSION    =   9;
+  Z_DEFAULT_COMPRESSION = (-1);
+
+  {** compression strategies ************************************************}
+
+  Z_FILTERED         = 1;
+  Z_HUFFMAN_ONLY     = 2;
+  Z_RLE              = 3;
+  Z_FIXED            = 4;
+  Z_DEFAULT_STRATEGY = 0;
+
+  {** data types ************************************************************}
+
+  Z_BINARY  = 0;
+  Z_ASCII   = 1;
+  Z_TEXT    = Z_ASCII;
+  Z_UNKNOWN = 2;
+
+  {** return code messages **************************************************}
+
+  _z_errmsg: Array [0..9] of String = (
+    'Need dictionary',      // Z_NEED_DICT      (2)
+    'Stream end',           // Z_STREAM_END     (1)
+    'OK',                   // Z_OK             (0)
+    'File error',           // Z_ERRNO          (-1)
+    'Stream error',         // Z_STREAM_ERROR   (-2)
+    'Data error',           // Z_DATA_ERROR     (-3)
+    'Insufficient memory',  // Z_MEM_ERROR      (-4)
+    'Buffer error',         // Z_BUF_ERROR      (-5)
+    'Incompatible version', // Z_VERSION_ERROR  (-6)
+    ''
+  );
+
+type
+  TZAlloc = function (opaque: Pointer; items, size: Integer): Pointer;
+  TZFree  = procedure (opaque, block: Pointer);
+
+  {** TZStreamRec ***********************************************************}
+
+  TZStreamRec = packed record
+    next_in  : Pointer;   // next input byte
+    avail_in : Longint;   // number of bytes available at next_in
+    total_in : Longint;   // total nb of input bytes read so far
+
+    next_out : Pointer;   // next output byte should be put here
+    avail_out: Longint;   // remaining free space at next_out
+    total_out: Longint;   // total nb of bytes output so far
+
+    msg      : Pointer;   // last error message, NULL if no error
+    state    : Pointer;   // not visible by applications
+
+    zalloc   : TZAlloc;   // used to allocate the internal state
+    zfree    : TZFree;    // used to free the internal state
+    opaque   : Pointer;   // private data object passed to zalloc and zfree
+
+    data_type: Integer;   // best guess about the data type: ascii or binary
+    adler    : Longint;   // adler32 value of the uncompressed data
+    reserved : Longint;   // reserved for future use
+  end;
+
+{** macros ******************************************************************}
+
+function deflateInit(var strm: TZStreamRec; level: Integer): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function deflateInit2(var strm: TZStreamRec; level, method, windowBits,
+  memLevel, strategy: Integer): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function inflateInit(var strm: TZStreamRec): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+function inflateInit2(var strm: TZStreamRec; windowBits: Integer): Integer;
+  {$ifdef Version2005Plus} inline; {$endif}
+
+{** external routines *******************************************************}
+
+function deflateInit_(var strm: TZStreamRec; level: Integer;
+  version: PAnsiChar; recsize: Integer): Integer;
+
+function deflateInit2_(var strm: TZStreamRec; level, method, windowBits,
+  memLevel, strategy: Integer; version: PAnsiChar; recsize: Integer): Integer;
+
+function deflate(var strm: TZStreamRec; flush: Integer): Integer;
+
+function deflateEnd(var strm: TZStreamRec): Integer;
+
+function deflateReset(var strm: TZStreamRec): Integer;
+
+function inflateInit_(var strm: TZStreamRec; version: PAnsiChar;
+  recsize: Integer): Integer;
+
+function inflateInit2_(var strm: TZStreamRec; windowBits: Integer;
+  version: PAnsiChar; recsize: Integer): Integer;
+
+function inflate(var strm: TZStreamRec; flush: Integer): Integer;
+
+function inflateEnd(var strm: TZStreamRec): Integer;
+
+function inflateReset(var strm: TZStreamRec): Integer;
+
+function adler32(adler: Longint; const buf; len: Integer): Longint;
+
+function crc32(crc: Longint; const buf; len: Integer): Longint;
+
+implementation
+
+{*****************************************************************************
+*  link zlib code                                                            *
+*                                                                            *
+*  bcc32 flags                                                               *
+*    -c -O2 -Ve -X -pr -a8 -b -d -k- -vi -tWM                                *
+*                                                                            *
+*  note: do not reorder the following -- doing so will result in external    *
+*  functions being undefined                                                 *
+*****************************************************************************}
+
+{$L deflate.obj}
+{$L inflate.obj}
+{$L inftrees.obj}
+{$L infback.obj}
+{$L inffast.obj}
+{$L trees.obj}
+{$L compress.obj}
+{$L adler32.obj}
+{$L crc32.obj}
+
+{** macros ******************************************************************}
+
+function deflateInit(var strm: TZStreamRec; level: Integer): Integer;
+begin
+  result := deflateInit_(strm, level, ZLIB_VERSION, SizeOf(TZStreamRec));
+end;
+
+function deflateInit2(var strm: TZStreamRec; level, method, windowBits,
+  memLevel, strategy: Integer): Integer;
+begin
+  result := deflateInit2_(strm, level, method, windowBits,
+    memLevel, strategy, ZLIB_VERSION, SizeOf(TZStreamRec));
+end;
+
+function inflateInit(var strm: TZStreamRec): Integer;
+begin
+  result := inflateInit_(strm, ZLIB_VERSION, SizeOf(TZStreamRec));
+end;
+
+function inflateInit2(var strm: TZStreamRec; windowBits: Integer): Integer;
+begin
+  result := inflateInit2_(strm, windowBits, ZLIB_VERSION,
+    SizeOf(TZStreamRec));
+end;
+
+{** external routines *******************************************************}
+
+function deflateInit_(var strm: TZStreamRec; level: Integer;
+  version: PAnsiChar; recsize: Integer): Integer;
+  external;
+
+function deflateInit2_(var strm: TZStreamRec; level, method, windowBits,
+  memLevel, strategy: Integer; version: PAnsiChar; recsize: Integer): Integer;
+  external;
+
+function deflate(var strm: TZStreamRec; flush: Integer): Integer;
+  external;
+
+function deflateEnd(var strm: TZStreamRec): Integer;
+  external;
+
+function deflateReset(var strm: TZStreamRec): Integer;
+  external;
+
+function inflateInit_(var strm: TZStreamRec; version: PAnsiChar;
+  recsize: Integer): Integer;
+  external;
+
+function inflateInit2_(var strm: TZStreamRec; windowBits: Integer;
+  version: PAnsiChar; recsize: Integer): Integer;
+  external;
+
+function inflate(var strm: TZStreamRec; flush: Integer): Integer;
+  external;
+
+function inflateEnd(var strm: TZStreamRec): Integer;
+  external;
+
+function inflateReset(var strm: TZStreamRec): Integer;
+  external;
+
+function adler32(adler: Longint; const buf; len: Integer): Longint;
+  external;
+
+function crc32(crc: Longint; const buf; len: Integer): Longint;
+  external;
+
+{** zlib function implementations *******************************************}
+
+function zcalloc(opaque: Pointer; items, size: Integer): Pointer;
+begin
+  GetMem(result,items * size);
+end;
+
+procedure zcfree(opaque, block: Pointer);
+begin
+  FreeMem(block);
+end;
+
+{** c function implementations **********************************************}
+
+procedure _memset(p: Pointer; b: Byte; count: Integer); cdecl;
+begin
+  FillChar(p^,count,b);
+end;
+
+procedure _memcpy(dest, source: Pointer; count: Integer); cdecl;
+begin
+  Move(source^,dest^,count);
+end;
+
+end.

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.dcu
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.dcu
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.pas
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.pas	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/ZLibExGZ.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,1203 @@
+{*****************************************************************************
+*  ZLibExGZ.pas                                                              *
+*                                                                            *
+*  copyright (c) 2000-2009 base2 technologies                                *
+*  copyright (c) 1995-2002 Borland Software Corporation                      *
+*                                                                            *
+*  revision history                                                          *
+*    2010.01.27  updated for delphi 2010                                     *
+*    2009.04.14  added overloaded string routines for AnsiString and         *
+*                  UnicodeString                                             *
+*                removed deprecated Z*G routines                             *
+*    2009.01.28  updated for delphi 2009 String (UnicodeString)              *
+*    2008.05.15  added TGZCompressionStream and TGZDecompressionStream       *
+*    2007.11.06  changed TGZTrailer.Crc from Cardinal to Longint             *
+*    2007.10.01  added GZDecompressStreamSize                                *
+*                fixed GZDecompressStream position handling                  *
+*    2007.08.15  added GZCompressFile                                        *
+*    2007.07.18  fixed GZCompressStr filename and comment processing         *
+*    2007.03.18  modified naming convention for gzip routines GZ*            *
+*                deprecated previous gzip routines Z*G                       *
+*    2007.03.15  created separate unit for gzip routines/objects             *
+*                added ZDecompressStreamG                                    *
+*                added overloaded ZCompressStrG                              *
+*                added overloaded ZCompressStreamG                           *
+*    2007.02.24  added PWord declaration for delphi 5-                       *
+*    2006.08.10  added ZDecompressStrG                                       *
+*    2006.06.02  added DateTimeToUnix for delphi 5-                          *
+*    2006.03.27  added ZCompressStreamG                                      *
+*    2006.03.24  added ZCompressStrG                                         *
+*                                                                            *
+*  acknowledgments                                                           *
+*    ralf wenske                                                             *
+*      2006.03.24  prototyping and assisting with ZCompressStrG and          *
+*                    ZCompressStreamG                                        *
+*                                                                            *
+*    roman krupicka                                                          *
+*      2006.06.02  pointing out the DateUtils unit and the DateTimeToUnix    *
+*                    function wasn't available prior to delphi 6             *                     *
+*                                                                            *
+*    marcin treffler                                                         *
+*      2007.02.24  pointing out the missing PWord declaration for delphi 5   *
+*                                                                            *
+*    jean-jacques esquirol                                                   *
+*      2007.07.18  pointing out the &quot;result&quot; address issue when processing   *
+*                    filename and comment flags/content in GZCompressStr     *
+*      2007.11.06  pointing out the type differences with TGZTrailer.Crc     *
+*                    (Cardinal) and ZCrc32 (Longint)                         *
+*                                                                            *
+*    graham wideman                                                          *
+*      2007.10.01  beta testing GZDecompressStreamSize and pointing out the  *
+*                    position handling issue in GZDecompressStream           *
+*****************************************************************************}
+
+unit ZLibExGZ;
+
+interface
+
+uses
+  ZLibEx, SysUtils, Classes {$IFDEF Version6Plus}, DateUtils {$ENDIF};
+
+type
+  {** TGZHeader *************************************************************}
+
+  PGZHeader = ^TGZHeader;
+  TGZHeader = packed record
+    Id1       : Byte;
+    Id2       : Byte;
+    Method    : Byte;
+    Flags     : Byte;
+    Time      : Cardinal;
+    ExtraFlags: Byte;
+    OS        : Byte;
+  end;
+
+  {** TGZTrailer ************************************************************}
+
+  PGZTrailer = ^TGZTrailer;
+  TGZTrailer = packed record
+    Crc : Longint;
+    Size: Cardinal;
+  end;
+
+  {** TGZCompressionStream **************************************************}
+
+  TGZCompressionStream = class(TZCompressionStream)
+  private
+    FFileName: AnsiString;
+    FComment : AnsiString;
+    FDateTime: TDateTime;
+
+    FTrailer : TGZTrailer;
+  public
+    constructor Create(dest: TStream; const fileName, comment: AnsiString;
+      dateTime: TDateTime); overload;
+
+    constructor Create(dest: TStream); overload;
+
+    destructor  Destroy; override;
+
+    function  Write(const buffer; count: Longint): Longint; override;
+
+    property FileName: AnsiString read FFileName;
+    property Comment : AnsiString read FComment;
+    property DateTime: TDateTime  read FDateTime;
+  end;
+
+  {** TGZDecompressionStream ************************************************}
+
+  TGZDecompressionStream = class(TZDecompressionStream)
+  private
+    FFileName: AnsiString;
+    FComment : AnsiString;
+    FDateTime: TDateTime;
+
+    FCrc     : Longint;
+    FSize    : Cardinal;
+  public
+    constructor Create(source: TStream); reintroduce;
+    destructor  Destroy; override;
+
+    function Read(var buffer; count: Longint): Longint; override;
+
+    property FileName: AnsiString read FFileName;
+    property Comment : AnsiString read FComment;
+    property DateTime: TDateTime  read FDateTime;
+  end;
+
+{** string routines *********************************************************}
+
+{*****************************************************************************
+*  GZCompressStr                                                             *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s          = uncompressed data string                                   *
+*    fileName   = filename                                                   *
+*    comment    = comment                                                    *
+*    dateTime   = date/time                                                  *
+*                                                                            *
+*  return                                                                    *
+*    compressed data string in gzip format                                   *
+*****************************************************************************}
+
+function  GZCompressStr(const s: AnsiString; const fileName,
+  comment: AnsiString; dateTime: TDateTime): RawByteString; overload;
+
+procedure GZCompressString(var result: RawByteString; const s: AnsiString;
+  const fileName, comment: AnsiString; dateTime: TDateTime); overload;
+
+procedure GZCompressString(var result: RawByteString; const s: UnicodeString;
+  const fileName, comment: AnsiString; dateTime: TDateTime); overload;
+
+function  GZCompressStr(const s: AnsiString): RawByteString; overload;
+
+procedure GZCompressString(var result: RawByteString; const s: AnsiString);
+  overload;
+
+procedure GZCompressString(var result: RawByteString; const s: UnicodeString);
+  overload;
+
+{*****************************************************************************
+*  GZDecompressStr                                                           *
+*                                                                            *
+*  pre-conditions                                                            *
+*    s = compressed data string in gzip format                               *
+*                                                                            *
+*  post-conditions                                                           *
+*    fileName   = filename                                                   *
+*    comment    = comment                                                    *
+*    dateTime   = date/time                                                  *
+*                                                                            *
+*  return                                                                    *
+*    uncompressed data string                                                *
+*****************************************************************************}
+
+function  GZDecompressStr(const s: RawByteString; var fileName,
+  comment: AnsiString; var dateTime: TDateTime): AnsiString; overload;
+
+procedure GZDecompressString(var result: AnsiString; const s: RawByteString;
+  var fileName, comment: AnsiString; var dateTime: TDateTime); overload;
+
+procedure GZDecompressString(var result: UnicodeString;
+  const s: RawByteString; var fileName, comment: AnsiString;
+  var dateTime: TDateTime); overload;
+
+function  GZDecompressStr(const s: RawByteString): AnsiString; overload;
+
+procedure GZDecompressString(var result: AnsiString; const s: RawByteString);
+  overload;
+
+procedure GZDecompressString(var result: UnicodeString;
+  const s: RawByteString); overload;
+
+{** stream routines *********************************************************}
+
+procedure GZCompressStream(inStream, outStream: TStream; const fileName,
+  comment: AnsiString; dateTime: TDateTime); overload;
+
+procedure GZCompressStream(inStream, outStream: TStream); overload;
+
+procedure GZDecompressStream(inStream, outStream: TStream; var fileName,
+  comment: AnsiString; var dateTime: TDateTime); overload;
+
+procedure GZDecompressStream(inStream, outStream: TStream); overload;
+
+function  GZDecompressStreamSize(inStream: TStream; var fileName,
+  comment: AnsiString; var dateTime: TDateTime): Longint; overload;
+
+function  GZDecompressStreamSize(inStream: TStream): Longint; overload;
+
+{** file routines ***********************************************************}
+
+procedure GZCompressFile(const inFileName, outFileName,
+  comment: AnsiString); overload;
+
+procedure GZCompressFile(const inFileName, outFileName: AnsiString); overload;
+
+procedure GZDecompressFile(const inFileName, outFolder: AnsiString;
+  var comment: AnsiString); overload;
+
+procedure GZDecompressFile(const inFileName, outFolder: AnsiString); overload;
+
+implementation
+
+uses
+  ZLibExApi;
+
+const
+  GZ_ZLIB_WINDOWBITS = -15;
+  GZ_ZLIB_MEMLEVEL   = 9;
+
+  GZ_ASCII_TEXT  = $01;
+  GZ_HEADER_CRC  = $02;
+  GZ_EXTRA_FIELD = $04;
+  GZ_FILENAME    = $08;
+  GZ_COMMENT     = $10;
+  GZ_RESERVED    = $E0;
+
+  GZ_EXTRA_DEFAULT = 0;
+  GZ_EXTRA_MAX     = 2;
+  GZ_EXTRA_FASTEST = 4;
+
+  SGZInvalid = 'Invalid GZStream operation!';
+
+{$IFNDEF Version6Plus}
+
+type
+  PWord = ^Word;
+
+{$ENDIF}
+
+{** DateTimeToUnix **********************************************************}
+
+{$IFNDEF Version6Plus}
+
+{ Days between TDateTime basis (12/31/1899) and Unix time_t basis (1/1/1970) }
+
+const
+  UnixDateDelta = 25569;
+
+function DateTimeToUnix(const AValue: TDateTime): Cardinal;
+begin
+  Result := Round((AValue - UnixDateDelta) * SecsPerDay);
+end;
+
+function UnixToDateTime(const AValue: Cardinal): TDateTime;
+begin
+  Result := AValue / SecsPerDay + UnixDateDelta;
+end;
+
+{$ENDIF}
+
+{** string routines *********************************************************}
+
+procedure GZInitializeCompressString(var result: RawByteString;
+  const fileName, comment: AnsiString; dateTime: TDateTime);
+var
+  header: PGZHeader;
+begin
+  SetLength(result, SizeOf(TGZHeader));
+
+  header := PGZHeader(@result[1]);
+
+  FillChar(header^, SizeOf(TGZHeader), 0);
+
+  header^.Id1 := $1F;
+  header^.Id2 := $8B;
+  header^.Method := Z_DEFLATED;
+
+  if dateTime &lt;&gt; 0 then header^.Time := DateTimeToUnix(dateTime);
+
+  header^.ExtraFlags := GZ_EXTRA_DEFAULT;
+  header^.OS := 0;
+
+  // build all flags first so &quot;result&quot; address doesn't change
+
+  header^.Flags := 0;
+
+  if Length(fileName) &gt; 0 then
+  begin
+    header^.Flags := header^.Flags or GZ_FILENAME;
+  end;
+
+  if Length(comment) &gt; 0 then
+  begin
+    header^.Flags := header^.Flags or GZ_COMMENT;
+  end;
+
+  // continue with content
+
+  if Length(fileName) &gt; 0 then
+  begin
+    result := result + fileName + #$00;
+  end;
+
+  if Length(comment) &gt; 0 then
+  begin
+    result := result + comment + #$00;
+  end;
+end;
+
+procedure GZFinalizeCompressString(var result: RawByteString; crc: Longint;
+  size: Integer);
+var
+  trailer: PGZTrailer;
+  index  : Integer;
+begin
+  index := Length(result);
+
+  SetLength(result, index + SizeOf(TGZTrailer));
+
+  trailer := PGZTrailer(@result[index + 1]);
+
+  FillChar(trailer^, SizeOf(TGZTrailer), 0);
+
+  trailer^.Crc := crc;
+  trailer^.Size := size;
+end;
+
+procedure GZInitializeDecompressString(const s: RawByteString; var fileName,
+  comment: AnsiString; var dateTime: TDateTime; var index: Integer);
+var
+  header  : PGZHeader;
+  maxIndex: Integer;
+  endIndex: Integer;
+  size    : Integer;
+begin
+  if Length(s) &lt; SizeOf(TGZHeader) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  header := PGZHeader(@s[1]);
+
+  if (header^.Id1 &lt;&gt; $1F) or (header^.Id2 &lt;&gt; $8B)
+    or (header^.Method &lt;&gt; Z_DEFLATED)
+    or ((header^.Flags and GZ_RESERVED) &lt;&gt; 0) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  if header^.Time &lt;&gt; 0 then dateTime := UnixToDateTime(header^.Time)
+  else dateTime := 0;
+
+  maxIndex := Length(s) - SizeOf(TGZTrailer);
+
+  index := SizeOf(TGZHeader) + 1;
+
+  if (header^.Flags and GZ_EXTRA_FIELD) &lt;&gt; 0 then
+  begin
+    if index &lt;= (maxIndex - 1) then
+    begin
+      size := PWord(@s[index])^;
+
+      Inc(index, 2);
+
+      if (size &gt;= 0) and ((index + size) &lt;= maxIndex) then Inc(index, size)
+      else index := maxIndex + 1;
+    end
+    else index := maxIndex + 1;
+  end;
+
+  if (header^.Flags and GZ_FILENAME) &lt;&gt; 0 then
+  begin
+    endIndex := index;
+
+    while (endIndex &lt;= maxIndex) and (s[endIndex] &lt;&gt; #$00) do Inc(endIndex);
+
+    SetLength(fileName, endIndex - index);
+
+    Move(s[index], fileName[1], endIndex - index);
+
+    index := endIndex;
+
+    if index &lt;= maxIndex then Inc(index);
+  end
+  else fileName := '';
+
+  if (header^.Flags and GZ_COMMENT) &lt;&gt; 0 then
+  begin
+    endIndex := index;
+
+    while (endIndex &lt;= maxIndex) and (s[endIndex] &lt;&gt; #$00) do Inc(endIndex);
+
+    SetLength(comment, endIndex - index);
+    Move(s[index], comment[1], endIndex - index);
+
+    index := endIndex;
+
+    if index &lt;= maxIndex then Inc(index);
+  end
+  else comment := '';
+
+  if (header^.Flags and GZ_HEADER_CRC) &lt;&gt; 0 then
+  begin
+    if index &lt;= (maxIndex - 1) then
+    begin
+      // todo: validate header crc
+
+      Inc(index,2);
+    end
+    else index := maxIndex + 1; // force eof
+  end;
+
+  if index &gt; maxIndex then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+end;
+
+procedure GZFinalizeDecompressString(const s: RawByteString; crc: Longint;
+  size: Integer);
+var
+  trailer: PGZTrailer;
+  index  : Integer;
+begin
+  index := Length(s) - SizeOf(TGZTrailer) + 1;
+
+  trailer := PGZTrailer(@s[index]);
+
+  if (trailer^.Crc &lt;&gt; crc)
+    or (trailer^.Size &lt;&gt; Cardinal(size)) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+end;
+
+function GZCompressStr(const s: AnsiString; const fileName,
+  comment: AnsiString; dateTime: TDateTime): RawByteString;
+begin
+  GZCompressString(result, s, fileName, comment, dateTime);
+end;
+
+procedure GZCompressString(var result: RawByteString; const s: AnsiString;
+  const fileName, comment: AnsiString; dateTime: TDateTime);
+var
+  buffer: RawByteString;
+  crc   : Longint;
+  size  : Integer;
+begin
+  GZInitializeCompressString(result, fileName, comment, dateTime);
+
+  ZCompressString2(buffer, s, zcDefault, GZ_ZLIB_WINDOWBITS, GZ_ZLIB_MEMLEVEL,
+    zsDefault);
+
+  result := result + buffer;
+
+  size := Length(s);
+
+  crc := ZCrc32(0, s[1], size);
+
+  GZFinalizeCompressString(result, crc, size);
+end;
+
+procedure GZCompressString(var result: RawByteString; const s: UnicodeString;
+  const fileName, comment: AnsiString; dateTime: TDateTime);
+var
+  buffer: RawByteString;
+  crc   : Longint;
+  size  : Integer;
+begin
+  GZInitializeCompressString(result, fileName, comment, dateTime);
+
+  ZCompressString2(buffer, s, zcDefault, GZ_ZLIB_WINDOWBITS, GZ_ZLIB_MEMLEVEL,
+    zsDefault);
+
+  result := result + buffer;
+
+  size := Length(s) * SizeOf(UnicodeChar);
+
+  crc := ZCrc32(0, s[1], size);
+
+  GZFinalizeCompressString(result, crc, size);
+end;
+
+function GZCompressStr(const s: AnsiString): RawByteString;
+begin
+  GZCompressString(result, s);
+end;
+
+procedure GZCompressString(var result: RawByteString; const s: AnsiString);
+begin
+  GZCompressString(result, s, '', '', 0);
+end;
+
+procedure GZCompressString(var result: RawByteString; const s: UnicodeString);
+begin
+  GZCompressString(result, s, '', '', 0);
+end;
+
+function GZDecompressStr(const s: RawByteString; var fileName,
+  comment: AnsiString; var dateTime: TDateTime): AnsiString;
+begin
+  GZDecompressString(result, s, fileName, comment, dateTime);
+end;
+
+procedure GZDecompressString(var result: AnsiString; const s: RawByteString;
+  var fileName, comment: AnsiString; var dateTime: TDateTime);
+var
+  index: Integer;
+  crc  : Longint;
+  size : Integer;
+begin
+  result := '';
+
+  GZInitializeDecompressString(s, fileName, comment, dateTime, index);
+
+  size := Length(s) - SizeOf(TGZTrailer) - index + 1;
+
+  ZDecompressString2(result, Copy(s, index, size), GZ_ZLIB_WINDOWBITS);
+
+  size := Length(result);
+
+  crc := ZCrc32(0, result[1], size);
+
+  GZFinalizeDecompressString(s, crc, size);
+end;
+
+procedure GZDecompressString(var result: UnicodeString;
+  const s: RawByteString; var fileName, comment: AnsiString;
+  var dateTime: TDateTime);
+var
+  index: Integer;
+  crc  : Longint;
+  size : Integer;
+begin
+  result := '';
+
+  GZInitializeDecompressString(s, fileName, comment, dateTime, index);
+
+  size := Length(s) - SizeOf(TGZTrailer) - index + 1;
+
+  ZDecompressString2(result, Copy(s, index, size), GZ_ZLIB_WINDOWBITS);
+
+  size := Length(result) * SizeOf(UnicodeChar);
+
+  crc := ZCrc32(0, result[1], size);
+
+  GZFinalizeDecompressString(s, crc, size);
+end;
+
+function GZDecompressStr(const s: RawByteString): AnsiString;
+begin
+  GZDecompressString(result, s);
+end;
+
+procedure GZDecompressString(var result: AnsiString; const s: RawByteString);
+var
+  fileName: AnsiString;
+  comment : AnsiString;
+  dateTime: TDateTime;
+begin
+  GZDecompressString(result, s, fileName, comment, dateTime);
+end;
+
+procedure GZDecompressString(var result: UnicodeString;
+  const s: RawByteString);
+var
+  fileName: AnsiString;
+  comment : AnsiString;
+  dateTime: TDateTime;
+begin
+  GZDecompressString(result, s, fileName, comment, dateTime);
+end;
+
+{** stream routines *********************************************************}
+
+procedure GZCompressStream(inStream, outStream: TStream; const fileName,
+  comment: AnsiString; dateTime: TDateTime);
+const
+  bufferSize = 32768;
+var
+  header    : TGZHeader;
+  trailer   : TGZTrailer;
+  buffer    : Array [0..bufferSize-1] of Byte;
+  count     : Integer;
+  position  : TStreamPos;
+  nullString: AnsiString;
+begin
+  FillChar(header,SizeOf(TGZHeader),0);
+
+  header.Id1 := $1F;
+  header.Id2 := $8B;
+  header.Method := Z_DEFLATED;
+
+  if dateTime &lt;&gt; 0 then header.Time := DateTimeToUnix(dateTime);
+
+  header.ExtraFlags := GZ_EXTRA_DEFAULT;
+  header.OS := 0;
+
+  header.Flags := 0;
+
+  if Length(fileName) &gt; 0 then header.Flags := header.Flags or GZ_FILENAME;
+  if Length(comment) &gt; 0 then header.Flags := header.Flags or GZ_COMMENT;
+
+  FillChar(trailer, SizeOf(TGZTrailer), 0);
+
+  trailer.Crc := 0;
+
+  position := inStream.Position;
+
+  while inStream.Position &lt; inStream.Size do
+  begin
+    count := inStream.Read(buffer[0],bufferSize);
+
+    trailer.Crc := ZCrc32(trailer.Crc,buffer[0],count);
+  end;
+
+  inStream.Position := position;
+
+  trailer.Size := inStream.Size - inStream.Position;
+
+  outStream.Write(header, SizeOf(TGZHeader));
+
+  if Length(filename) &gt; 0 then
+  begin
+    nullString := fileName + #$00;
+
+    outStream.Write(nullString[1], Length(nullString));
+  end;
+
+  if Length(comment) &gt; 0 then
+  begin
+    nullString := comment + #$00;
+
+    outStream.Write(nullString[1], Length(nullString));
+  end;
+
+  ZCompressStream2(inStream, outStream, zcDefault, GZ_ZLIB_WINDOWBITS,
+    GZ_ZLIB_MEMLEVEL, zsDefault);
+
+  outStream.Write(trailer, SizeOf(TGZTrailer));
+end;
+
+procedure GZCompressStream(inStream, outStream: TStream);
+begin
+  GZCompressStream(inStream, outStream, '', '', 0);
+end;
+
+procedure GZDecompressStream(inStream, outStream: TStream; var fileName,
+  comment: AnsiString; var dateTime: TDateTime);
+const
+  bufferSize = 32768;
+var
+  header     : TGZHeader;
+  trailer    : TGZTrailer;
+  buffer     : Array [0..bufferSize-1] of Byte;
+  count      : Integer;
+  position   : TStreamPos;
+  endPosition: TStreamPos;
+  size       : Integer;
+  crc        : Longint;
+  c          : AnsiChar;
+begin
+  if inStream.Read(header,SizeOf(TGZHeader)) &lt;&gt; SizeOf(TGZHeader) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  if (header.Id1 &lt;&gt; $1F)
+    or (header.Id2 &lt;&gt; $8B)
+    or (header.Method &lt;&gt; Z_DEFLATED)
+    or ((header.Flags and GZ_RESERVED) &lt;&gt; 0) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  if header.Time &lt;&gt; 0 then dateTime := UnixToDateTime(header.Time)
+  else dateTime := 0;
+
+  if (header.Flags and GZ_EXTRA_FIELD) &lt;&gt; 0 then
+  begin
+    if inStream.Read(size,SizeOf(Word)) &lt;&gt; SizeOf(Word) then
+    begin
+      raise EZDecompressionError.Create(zeDataError);
+    end;
+
+    inStream.Position := inStream.Position + size;
+  end;
+
+  fileName := '';
+
+  if (header.Flags and GZ_FILENAME) &lt;&gt; 0 then
+  begin
+    c := ' ';
+
+    while (inStream.Position &lt; inStream.Size) and (c &lt;&gt; #$00) do
+    begin
+      inStream.Read(c,1);
+
+      if c &lt;&gt; #$00 then fileName := fileName + c;
+    end;
+  end;
+
+  comment := '';
+
+  if (header.Flags and GZ_COMMENT) &lt;&gt; 0 then
+  begin
+    c := ' ';
+
+    while (inStream.Position &lt; inStream.Size) and (c &lt;&gt; #$00) do
+    begin
+      inStream.Read(c, 1);
+
+      if c &lt;&gt; #$00 then comment := comment + c;
+    end;
+  end;
+
+  if (header.Flags and GZ_HEADER_CRC) &lt;&gt; 0 then
+  begin
+    // todo: validate header crc
+
+    inStream.Position := inStream.Position + SizeOf(Word);
+  end;
+
+  if inStream.Position &gt;= inStream.Size then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  position := outStream.Position;
+
+  ZDecompressStream2(inStream,outStream,GZ_ZLIB_WINDOWBITS);
+
+  endPosition := outStream.Position;
+
+  if inStream.Read(trailer,SizeOf(TGZTrailer)) &lt;&gt; SizeOf(TGZTrailer) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  crc := 0;
+
+  outStream.Position := position;
+
+  while outStream.Position &lt; endPosition do
+  begin
+    size := bufferSize;
+
+    if size &gt; (endPosition - outStream.Position) then
+    begin
+      size := endPosition - outStream.Position;
+    end;
+
+    count := outStream.Read(buffer[0], size);
+
+    crc := ZCrc32(crc, buffer[0], count);
+  end;
+
+  if (trailer.Crc &lt;&gt; crc)
+    or (trailer.Size &lt;&gt; Cardinal(endPosition - position)) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+end;
+
+procedure GZDecompressStream(inStream, outStream: TStream);
+var
+  fileName: AnsiString;
+  comment : AnsiString;
+  dateTime: TDateTime;
+begin
+  GZDecompressStream(inStream,outStream,fileName,comment,dateTime);
+end;
+
+type
+  TNullStream = class(TStream)
+  private
+    FSize    : Int64;
+    FPosition: Int64;
+  public
+    function  Read(var buffer; count: Longint): Longint; override;
+    function  Write(const buffer; count: Longint): Longint; override;
+
+    function  Seek(offset: Longint; origin: Word): Longint; override;
+  end;
+
+function TNullStream.Read(var buffer; count: Longint): Longint;
+begin
+  result := 0;
+
+  if (FPosition &gt;= 0) and (FPosition &lt; FSize) and (count &gt;= 0) then
+  begin
+    result := FSize - FPosition;
+    if result &gt; count then result := count;
+
+    Inc(FPosition, result);
+  end;
+end;
+
+function TNullStream.Write(const buffer; count: Longint): Longint;
+begin
+  result := count;
+
+  FPosition := FPosition + count;
+  if FPosition &gt; FSize then FSize := FPosition;
+end;
+
+function TNullStream.Seek(offset: Longint; origin: Word): Longint;
+begin
+  case origin of
+    soFromBeginning: FPosition := offset;
+    soFromCurrent  : Inc(FPosition, offset);
+    soFromEnd      : FPosition := FSize + offset;
+  end;
+
+  result := FPosition;
+end;
+
+function GZDecompressStreamSize(inStream: TStream; var fileName,
+  comment: AnsiString; var dateTime: TDateTime): Longint;
+const
+  bufferSize = 32768;
+var
+  outStream: TNullStream;
+  header   : TGZHeader;
+  trailer  : TGZTrailer;
+  position : TStreamPos;
+  size     : Integer;
+  c        : AnsiChar;
+begin
+  result := 0;
+
+  position := inStream.Position;
+
+  try
+    if inStream.Read(header,SizeOf(TGZHeader)) &lt;&gt; SizeOf(TGZHeader) then
+    begin
+      raise EZDecompressionError.Create(zeDataError);
+    end;
+
+    if (header.Id1 &lt;&gt; $1F)
+      or (header.Id2 &lt;&gt; $8B)
+      or (header.Method &lt;&gt; Z_DEFLATED)
+      or ((header.Flags and GZ_RESERVED) &lt;&gt; 0) then
+    begin
+      raise EZDecompressionError.Create(zeDataError);
+    end;
+
+    if header.Time &lt;&gt; 0 then dateTime := UnixToDateTime(header.Time)
+    else dateTime := 0;
+
+    if (header.Flags and GZ_EXTRA_FIELD) &lt;&gt; 0 then
+    begin
+      if inStream.Read(size,SizeOf(Word)) &lt;&gt; SizeOf(Word) then
+      begin
+        raise EZDecompressionError.Create(zeDataError);
+      end;
+
+      inStream.Position := inStream.Position + size;
+    end;
+
+    fileName := '';
+
+    if (header.Flags and GZ_FILENAME) &lt;&gt; 0 then
+    begin
+      c := ' ';
+
+      while (inStream.Position &lt; inStream.Size) and (c &lt;&gt; #$00) do
+      begin
+        inStream.Read(c,1);
+
+        if c &lt;&gt; #$00 then fileName := fileName + c;
+      end;
+    end;
+
+    comment := '';
+
+    if (header.Flags and GZ_COMMENT) &lt;&gt; 0 then
+    begin
+      c := ' ';
+
+      while (inStream.Position &lt; inStream.Size) and (c &lt;&gt; #$00) do
+      begin
+        inStream.Read(c,1);
+
+        if c &lt;&gt; #$00 then comment := comment + c;
+      end;
+    end;
+
+    if (header.Flags and GZ_HEADER_CRC) &lt;&gt; 0 then
+    begin
+      // todo: validate header crc
+
+      inStream.Position := inStream.Position + SizeOf(Word);
+    end;
+
+    if inStream.Position &gt;= inStream.Size then
+    begin
+      raise EZDecompressionError.Create(zeDataError);
+    end;
+
+    outStream := TNullStream.Create;
+
+    try
+      ZDecompressStream2(inStream,outStream,GZ_ZLIB_WINDOWBITS);
+
+      result := outStream.Size;
+    finally
+      outStream.Free;
+    end;
+
+    if inStream.Read(trailer,SizeOf(TGZTrailer)) &lt;&gt; SizeOf(TGZTrailer) then
+    begin
+      raise EZDecompressionError.Create(zeDataError);
+    end;
+
+    if trailer.Size &lt;&gt; Cardinal(result) then
+    begin
+      raise EZDecompressionError.Create(zeDataError);
+    end;
+  finally
+    inStream.Position := position;
+  end;
+end;
+
+function GZDecompressStreamSize(inStream: TStream): Longint;
+var
+  fileName: AnsiString;
+  comment : AnsiString;
+  dateTime: TDateTime;
+begin
+  result := GZDecompressStreamSize(inStream,fileName,comment,dateTime);
+end;
+
+{** file routines ***********************************************************}
+
+procedure GZCompressFile(const inFileName, outFileName, comment: AnsiString);
+var
+  inStream : TFileStream;
+  outStream: TFileStream;
+  fileName : AnsiString;
+  dateTime : TDateTime;
+begin
+  inStream := TFileStream.Create(inFileName,fmOpenRead or fmShareDenyNone);
+
+  try
+    dateTime := FileDateToDateTime(FileAge(inFileName));
+
+    if outFileName = '' then fileName := inFileName + '.gz'
+    else fileName := outFileName;
+
+    outStream := TFileStream.Create(outFileName,fmCreate);
+
+    try
+      fileName := ExtractFileName(inFileName);
+
+      GZCompressStream(inStream,outStream,fileName,comment,dateTime);
+    finally
+      outStream.Free;
+    end;
+  finally
+    inStream.Free;
+  end;
+end;
+
+procedure GZCompressFile(const inFileName, outFileName: AnsiString);
+begin
+  GZCompressFile(inFileName, outFileName, '');
+end;
+
+procedure GZDecompressFile(const inFileName, outFolder: AnsiString;
+  var comment: AnsiString);
+var
+  inStream   : TFileStream;
+  outStream  : TFileStream;
+  outFileName: AnsiString;
+  fileName   : AnsiString;
+  dateTime   : TDateTime;
+begin
+  inStream := TFileStream.Create(inFileName,fmOpenRead or fmShareDenyNone);
+
+  try
+    if CompareText(ExtractFileExt(inFileName),'.gz') = 0 then
+    begin
+      fileName := IncludeTrailingPathDelimiter(outFolder);
+      fileName := fileName + ChangeFileExt(ExtractFileName(inFileName),'');
+    end
+    else fileName := '_ZLIBEXGZ';
+
+    outStream := TFileStream.Create(fileName,fmCreate);
+
+    try
+      GZDecompressStream(inStream,outStream,outFileName,comment,dateTime);
+    finally
+      outStream.Free;
+    end;
+
+    if outFileName &lt;&gt; '' then
+    begin
+      outFileName := ExtractFilePath(fileName) + ExtractFileName(outFileName);
+
+      RenameFile(fileName,outFileName);
+
+      FileSetDate(outFileName,DateTimeToFileDate(dateTime));
+    end;
+  finally
+    inStream.Free;
+  end;
+end;
+
+procedure GZDecompressFile(const inFileName, outFolder: AnsiString);
+var
+  comment: AnsiString;
+begin
+  GZDecompressFile(inFileName,outFolder,comment);
+end;
+
+{** TGZCompressionStream ****************************************************}
+
+constructor TGZCompressionStream.Create(dest: TStream; const fileName,
+  comment: AnsiString; dateTime: TDateTime);
+var
+  header    : TGZHeader;
+  nullString: AnsiString;
+begin
+  inherited Create(dest, zcDefault, GZ_ZLIB_WINDOWBITS, GZ_ZLIB_MEMLEVEL,
+    zsDefault);
+
+  FFileName := fileName;
+  FComment := comment;
+  FDateTime := dateTime;
+
+  FillChar(header,SizeOf(TGZHeader),0);
+
+  header.Id1 := $1F;
+  header.Id2 := $8B;
+  header.Method := Z_DEFLATED;
+
+  if FDateTime &lt;&gt; 0 then header.Time := DateTimeToUnix(FDateTime);
+
+  header.ExtraFlags := GZ_EXTRA_DEFAULT;
+  header.OS := 0;
+
+  header.Flags := 0;
+
+  if Length(fileName) &gt; 0 then header.Flags := header.Flags or GZ_FILENAME;
+  if Length(comment) &gt; 0 then header.Flags := header.Flags or GZ_COMMENT;
+
+  StreamWriteBuffer(header,SizeOf(TGZHeader));
+
+  if Length(FFilename) &gt; 0 then
+  begin
+    nullString := FFileName + #$00;
+
+    StreamWriteBuffer(nullString[1],Length(nullString));
+  end;
+
+  if Length(FComment) &gt; 0 then
+  begin
+    nullString := FComment + #$00;
+
+    StreamWriteBuffer(nullString[1],Length(nullString));
+  end;
+
+  FillChar(FTrailer,SizeOf(TGZTrailer),0);
+end;
+
+constructor TGZCompressionStream.Create(dest: TStream);
+begin
+  Create(dest,'','',0);
+end;
+
+destructor TGZCompressionStream.Destroy;
+begin
+  inherited Destroy;
+
+  StreamWriteBuffer(FTrailer,SizeOf(TGZTrailer));
+end;
+
+function TGZCompressionStream.Write(const buffer; count: Longint): Longint;
+begin
+  result := inherited Write(buffer,count);
+
+  FTrailer.Crc := ZCrc32(FTrailer.Crc,buffer,result);
+  FTrailer.Size := FTrailer.Size + Cardinal(result);
+end;
+
+{** TGZDecompressionStream **************************************************}
+
+constructor TGZDecompressionStream.Create(source: TStream);
+
+  function ReadNullString: AnsiString;
+  var
+    c: AnsiChar;
+  begin
+    result := '';
+
+    c := ' ';
+
+    while c &lt;&gt; #$00 do
+    begin
+      if StreamRead(c,1) &lt;&gt; 1 then
+      begin
+        raise EZDecompressionError.Create(zeStreamError);
+      end;
+
+      if c &lt;&gt; #$00 then result := result + c;
+    end;
+  end;
+
+var
+  header: TGZHeader;
+  size  : Integer;
+begin
+  inherited Create(source,GZ_ZLIB_WINDOWBITS);
+
+  if StreamRead(header,SizeOf(TGZHeader)) &lt;&gt; SizeOf(TGZHeader) then
+  begin
+    raise EZDecompressionError.Create(zeStreamError);
+  end;
+
+  if (header.Id1 &lt;&gt; $1F)
+    or (header.Id2 &lt;&gt; $8B)
+    or (header.Method &lt;&gt; Z_DEFLATED)
+    or ((header.Flags and GZ_RESERVED) &lt;&gt; 0) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+
+  if header.Time &lt;&gt; 0 then FDateTime := UnixToDateTime(header.Time)
+  else FDateTime := 0;
+
+  if (header.Flags and GZ_EXTRA_FIELD) &lt;&gt; 0 then
+  begin
+    if StreamRead(size,SizeOf(Word)) &lt;&gt; SizeOf(Word) then
+    begin
+      raise EZDecompressionError.Create(zeStreamError);
+    end;
+
+    StreamPosition := StreamPosition + size;
+  end;
+
+  FFileName := '';
+
+  if (header.Flags and GZ_FILENAME) &lt;&gt; 0 then
+  begin
+    FFileName := ReadNullString;
+  end;
+
+  FComment := '';
+
+  if (header.Flags and GZ_COMMENT) &lt;&gt; 0 then
+  begin
+    FComment := ReadNullString;
+  end;
+
+  if (header.Flags and GZ_HEADER_CRC) &lt;&gt; 0 then
+  begin
+    // todo: validate header crc
+
+    StreamPosition := StreamPosition + SizeOf(Word);
+  end;
+
+  FCrc := 0;
+  FSize := 0;
+end;
+
+destructor TGZDecompressionStream.Destroy;
+var
+  trailer: TGZTrailer;
+begin
+  inherited Destroy;
+
+  if StreamRead(trailer,SizeOf(TGZTrailer)) &lt;&gt; SizeOf(TGZTrailer) then
+  begin
+    raise EZDecompressionError.Create(zeStreamError);
+  end;
+
+  if (trailer.Crc &lt;&gt; FCrc) or (trailer.Size &lt;&gt; FSize) then
+  begin
+    raise EZDecompressionError.Create(zeDataError);
+  end;
+end;
+
+function TGZDecompressionStream.Read(var buffer; count: Longint): Longint;
+begin
+  result := inherited Read(buffer,count);
+
+  FCrc := ZCrc32(FCrc,buffer,result);
+  FSize := FSize + Cardinal(result);
+end;
+
+end.

Added: Lobby/TASClient/LobbyComponents/delphizlib/adler32.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/adler32.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/adler32.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,169 @@
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995-2007 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#include &quot;zutil.h&quot;
+
+#define local static
+
+local uLong adler32_combine_(uLong adler1, uLong adler2, z_off64_t len2);
+
+#define BASE 65521UL    /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) &lt;= 2^32-1 */
+
+#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* use NO_DIVIDE if your processor does not do division in hardware */
+#ifdef NO_DIVIDE
+#  define MOD(a) \
+    do { \
+        if (a &gt;= (BASE &lt;&lt; 16)) a -= (BASE &lt;&lt; 16); \
+        if (a &gt;= (BASE &lt;&lt; 15)) a -= (BASE &lt;&lt; 15); \
+        if (a &gt;= (BASE &lt;&lt; 14)) a -= (BASE &lt;&lt; 14); \
+        if (a &gt;= (BASE &lt;&lt; 13)) a -= (BASE &lt;&lt; 13); \
+        if (a &gt;= (BASE &lt;&lt; 12)) a -= (BASE &lt;&lt; 12); \
+        if (a &gt;= (BASE &lt;&lt; 11)) a -= (BASE &lt;&lt; 11); \
+        if (a &gt;= (BASE &lt;&lt; 10)) a -= (BASE &lt;&lt; 10); \
+        if (a &gt;= (BASE &lt;&lt; 9)) a -= (BASE &lt;&lt; 9); \
+        if (a &gt;= (BASE &lt;&lt; 8)) a -= (BASE &lt;&lt; 8); \
+        if (a &gt;= (BASE &lt;&lt; 7)) a -= (BASE &lt;&lt; 7); \
+        if (a &gt;= (BASE &lt;&lt; 6)) a -= (BASE &lt;&lt; 6); \
+        if (a &gt;= (BASE &lt;&lt; 5)) a -= (BASE &lt;&lt; 5); \
+        if (a &gt;= (BASE &lt;&lt; 4)) a -= (BASE &lt;&lt; 4); \
+        if (a &gt;= (BASE &lt;&lt; 3)) a -= (BASE &lt;&lt; 3); \
+        if (a &gt;= (BASE &lt;&lt; 2)) a -= (BASE &lt;&lt; 2); \
+        if (a &gt;= (BASE &lt;&lt; 1)) a -= (BASE &lt;&lt; 1); \
+        if (a &gt;= BASE) a -= BASE; \
+    } while (0)
+#  define MOD4(a) \
+    do { \
+        if (a &gt;= (BASE &lt;&lt; 4)) a -= (BASE &lt;&lt; 4); \
+        if (a &gt;= (BASE &lt;&lt; 3)) a -= (BASE &lt;&lt; 3); \
+        if (a &gt;= (BASE &lt;&lt; 2)) a -= (BASE &lt;&lt; 2); \
+        if (a &gt;= (BASE &lt;&lt; 1)) a -= (BASE &lt;&lt; 1); \
+        if (a &gt;= BASE) a -= BASE; \
+    } while (0)
+#else
+#  define MOD(a) a %= BASE
+#  define MOD4(a) a %= BASE
+#endif
+
+/* ========================================================================= */
+uLong ZEXPORT adler32(adler, buf, len)
+    uLong adler;
+    const Bytef *buf;
+    uInt len;
+{
+    unsigned long sum2;
+    unsigned n;
+
+    /* split Adler-32 into component sums */
+    sum2 = (adler &gt;&gt; 16) &amp; 0xffff;
+    adler &amp;= 0xffff;
+
+    /* in case user likes doing a byte at a time, keep it fast */
+    if (len == 1) {
+        adler += buf[0];
+        if (adler &gt;= BASE)
+            adler -= BASE;
+        sum2 += adler;
+        if (sum2 &gt;= BASE)
+            sum2 -= BASE;
+        return adler | (sum2 &lt;&lt; 16);
+    }
+
+    /* initial Adler-32 value (deferred check for len == 1 speed) */
+    if (buf == Z_NULL)
+        return 1L;
+
+    /* in case short lengths are provided, keep it somewhat fast */
+    if (len &lt; 16) {
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        if (adler &gt;= BASE)
+            adler -= BASE;
+        MOD4(sum2);             /* only added so many BASE's */
+        return adler | (sum2 &lt;&lt; 16);
+    }
+
+    /* do length NMAX blocks -- requires just one modulo operation */
+    while (len &gt;= NMAX) {
+        len -= NMAX;
+        n = NMAX / 16;          /* NMAX is divisible by 16 */
+        do {
+            DO16(buf);          /* 16 sums unrolled */
+            buf += 16;
+        } while (--n);
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* do remaining bytes (less than NMAX, still just one modulo) */
+    if (len) {                  /* avoid modulos if none remaining */
+        while (len &gt;= 16) {
+            len -= 16;
+            DO16(buf);
+            buf += 16;
+        }
+        while (len--) {
+            adler += *buf++;
+            sum2 += adler;
+        }
+        MOD(adler);
+        MOD(sum2);
+    }
+
+    /* return recombined sums */
+    return adler | (sum2 &lt;&lt; 16);
+}
+
+/* ========================================================================= */
+local uLong adler32_combine_(adler1, adler2, len2)
+    uLong adler1;
+    uLong adler2;
+    z_off64_t len2;
+{
+    unsigned long sum1;
+    unsigned long sum2;
+    unsigned rem;
+
+    /* the derivation of this formula is left as an exercise for the reader */
+    rem = (unsigned)(len2 % BASE);
+    sum1 = adler1 &amp; 0xffff;
+    sum2 = rem * sum1;
+    MOD(sum2);
+    sum1 += (adler2 &amp; 0xffff) + BASE - 1;
+    sum2 += ((adler1 &gt;&gt; 16) &amp; 0xffff) + ((adler2 &gt;&gt; 16) &amp; 0xffff) + BASE - rem;
+    if (sum1 &gt;= BASE) sum1 -= BASE;
+    if (sum1 &gt;= BASE) sum1 -= BASE;
+    if (sum2 &gt;= (BASE &lt;&lt; 1)) sum2 -= (BASE &lt;&lt; 1);
+    if (sum2 &gt;= BASE) sum2 -= BASE;
+    return sum1 | (sum2 &lt;&lt; 16);
+}
+
+/* ========================================================================= */
+uLong ZEXPORT adler32_combine(adler1, adler2, len2)
+    uLong adler1;
+    uLong adler2;
+    z_off_t len2;
+{
+    return adler32_combine_(adler1, adler2, len2);
+}
+
+uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
+    uLong adler1;
+    uLong adler2;
+    z_off64_t len2;
+{
+    return adler32_combine_(adler1, adler2, len2);
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/adler32.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/adler32.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/compress.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/compress.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/compress.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,80 @@
+/* compress.c -- compress a memory buffer
+ * Copyright (C) 1995-2005 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#define ZLIB_INTERNAL
+#include &quot;zlib.h&quot;
+
+/* ===========================================================================
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least 0.1% larger than sourceLen plus
+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+    int level;
+{
+    z_stream stream;
+    int err;
+
+    stream.next_in = (Bytef*)source;
+    stream.avail_in = (uInt)sourceLen;
+#ifdef MAXSEG_64K
+    /* Check for source &gt; 64K on 16-bit machine: */
+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+#endif
+    stream.next_out = dest;
+    stream.avail_out = (uInt)*destLen;
+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+
+    stream.zalloc = (alloc_func)0;
+    stream.zfree = (free_func)0;
+    stream.opaque = (voidpf)0;
+
+    err = deflateInit(&amp;stream, level);
+    if (err != Z_OK) return err;
+
+    err = deflate(&amp;stream, Z_FINISH);
+    if (err != Z_STREAM_END) {
+        deflateEnd(&amp;stream);
+        return err == Z_OK ? Z_BUF_ERROR : err;
+    }
+    *destLen = stream.total_out;
+
+    err = deflateEnd(&amp;stream);
+    return err;
+}
+
+/* ===========================================================================
+ */
+int ZEXPORT compress (dest, destLen, source, sourceLen)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+{
+    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
+}
+
+/* ===========================================================================
+     If the default memLevel or windowBits for deflateInit() is changed, then
+   this function needs to be updated.
+ */
+uLong ZEXPORT compressBound (sourceLen)
+    uLong sourceLen;
+{
+    return sourceLen + (sourceLen &gt;&gt; 12) + (sourceLen &gt;&gt; 14) +
+           (sourceLen &gt;&gt; 25) + 13;
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/compress.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/compress.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/crc32.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/crc32.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/crc32.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,442 @@
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-2006, 2010 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ *
+ * Thanks to Rodney Brown &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">rbrown64 at csc.com.au</A>&gt; for his contribution of faster
+ * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
+ * tables for updating the shift register in one step with three exclusive-ors
+ * instead of four steps with four exclusive-ors.  This results in about a
+ * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
+ */
+
+/* @(#) $Id$ */
+
+/*
+  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
+  protection on the static variables used to control the first-use generation
+  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
+  first call get_crc_table() to initialize the tables before allowing more than
+  one thread to use crc32().
+ */
+
+#ifdef MAKECRCH
+#  include &lt;stdio.h&gt;
+#  ifndef DYNAMIC_CRC_TABLE
+#    define DYNAMIC_CRC_TABLE
+#  endif /* !DYNAMIC_CRC_TABLE */
+#endif /* MAKECRCH */
+
+#include &quot;zutil.h&quot;      /* for STDC and FAR definitions */
+
+#define local static
+
+/* Find a four-byte integer type for crc32_little() and crc32_big(). */
+#ifndef NOBYFOUR
+#  ifdef STDC           /* need ANSI C limits.h to determine sizes */
+#    include &lt;limits.h&gt;
+#    define BYFOUR
+#    if (UINT_MAX == 0xffffffffUL)
+       typedef unsigned int u4;
+#    else
+#      if (ULONG_MAX == 0xffffffffUL)
+         typedef unsigned long u4;
+#      else
+#        if (USHRT_MAX == 0xffffffffUL)
+           typedef unsigned short u4;
+#        else
+#          undef BYFOUR     /* can't find a four-byte integer type! */
+#        endif
+#      endif
+#    endif
+#  endif /* STDC */
+#endif /* !NOBYFOUR */
+
+/* Definitions for doing the crc four data bytes at a time. */
+#ifdef BYFOUR
+#  define REV(w) ((((w)&gt;&gt;24)&amp;0xff)+(((w)&gt;&gt;8)&amp;0xff00)+ \
+                (((w)&amp;0xff00)&lt;&lt;8)+(((w)&amp;0xff)&lt;&lt;24))
+   local unsigned long crc32_little OF((unsigned long,
+                        const unsigned char FAR *, unsigned));
+   local unsigned long crc32_big OF((unsigned long,
+                        const unsigned char FAR *, unsigned));
+#  define TBLS 8
+#else
+#  define TBLS 1
+#endif /* BYFOUR */
+
+/* Local functions for crc concatenation */
+local unsigned long gf2_matrix_times OF((unsigned long *mat,
+                                         unsigned long vec));
+local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
+local uLong crc32_combine_(uLong crc1, uLong crc2, z_off64_t len2);
+
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local volatile int crc_table_empty = 1;
+local unsigned long FAR crc_table[TBLS][256];
+local void make_crc_table OF((void));
+#ifdef MAKECRCH
+   local void write_table OF((FILE *, const unsigned long FAR *));
+#endif /* MAKECRCH */
+/*
+  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The first table is simply the CRC of all possible eight bit values.  This is
+  all the information needed to generate CRCs on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.  The remaining tables
+  allow for word-at-a-time CRC calculation for both big-endian and little-
+  endian machines, where a word is four bytes.
+*/
+local void make_crc_table()
+{
+    unsigned long c;
+    int n, k;
+    unsigned long poly;                 /* polynomial exclusive-or pattern */
+    /* terms of polynomial defining this crc (except x^32): */
+    static volatile int first = 1;      /* flag to limit concurrent making */
+    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+    /* See if another task is already doing this (not thread-safe, but better
+       than nothing -- significantly reduces duration of vulnerability in
+       case the advice about DYNAMIC_CRC_TABLE is ignored) */
+    if (first) {
+        first = 0;
+
+        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
+        poly = 0UL;
+        for (n = 0; n &lt; sizeof(p)/sizeof(unsigned char); n++)
+            poly |= 1UL &lt;&lt; (31 - p[n]);
+
+        /* generate a crc for every 8-bit value */
+        for (n = 0; n &lt; 256; n++) {
+            c = (unsigned long)n;
+            for (k = 0; k &lt; 8; k++)
+                c = c &amp; 1 ? poly ^ (c &gt;&gt; 1) : c &gt;&gt; 1;
+            crc_table[0][n] = c;
+        }
+
+#ifdef BYFOUR
+        /* generate crc for each value followed by one, two, and three zeros,
+           and then the byte reversal of those as well as the first table */
+        for (n = 0; n &lt; 256; n++) {
+            c = crc_table[0][n];
+            crc_table[4][n] = REV(c);
+            for (k = 1; k &lt; 4; k++) {
+                c = crc_table[0][c &amp; 0xff] ^ (c &gt;&gt; 8);
+                crc_table[k][n] = c;
+                crc_table[k + 4][n] = REV(c);
+            }
+        }
+#endif /* BYFOUR */
+
+        crc_table_empty = 0;
+    }
+    else {      /* not first */
+        /* wait for the other guy to finish (not efficient, but rare) */
+        while (crc_table_empty)
+            ;
+    }
+
+#ifdef MAKECRCH
+    /* write out CRC tables to crc32.h */
+    {
+        FILE *out;
+
+        out = fopen(&quot;crc32.h&quot;, &quot;w&quot;);
+        if (out == NULL) return;
+        fprintf(out, &quot;/* crc32.h -- tables for rapid CRC calculation\n&quot;);
+        fprintf(out, &quot; * Generated automatically by crc32.c\n */\n\n&quot;);
+        fprintf(out, &quot;local const unsigned long FAR &quot;);
+        fprintf(out, &quot;crc_table[TBLS][256] =\n{\n  {\n&quot;);
+        write_table(out, crc_table[0]);
+#  ifdef BYFOUR
+        fprintf(out, &quot;#ifdef BYFOUR\n&quot;);
+        for (k = 1; k &lt; 8; k++) {
+            fprintf(out, &quot;  },\n  {\n&quot;);
+            write_table(out, crc_table[k]);
+        }
+        fprintf(out, &quot;#endif\n&quot;);
+#  endif /* BYFOUR */
+        fprintf(out, &quot;  }\n};\n&quot;);
+        fclose(out);
+    }
+#endif /* MAKECRCH */
+}
+
+#ifdef MAKECRCH
+local void write_table(out, table)
+    FILE *out;
+    const unsigned long FAR *table;
+{
+    int n;
+
+    for (n = 0; n &lt; 256; n++)
+        fprintf(out, &quot;%s0x%08lxUL%s&quot;, n % 5 ? &quot;&quot; : &quot;    &quot;, table[n],
+                n == 255 ? &quot;\n&quot; : (n % 5 == 4 ? &quot;,\n&quot; : &quot;, &quot;));
+}
+#endif /* MAKECRCH */
+
+#else /* !DYNAMIC_CRC_TABLE */
+/* ========================================================================
+ * Tables of CRC-32s of all single-byte values, made by make_crc_table().
+ */
+#include &quot;crc32.h&quot;
+#endif /* DYNAMIC_CRC_TABLE */
+
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const unsigned long FAR * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+        make_crc_table();
+#endif /* DYNAMIC_CRC_TABLE */
+    return (const unsigned long FAR *)crc_table;
+}
+
+/* ========================================================================= */
+#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) &amp; 0xff] ^ (crc &gt;&gt; 8)
+#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
+
+/* ========================================================================= */
+unsigned long ZEXPORT crc32(crc, buf, len)
+    unsigned long crc;
+    const unsigned char FAR *buf;
+    uInt len;
+{
+    if (buf == Z_NULL) return 0UL;
+
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+        make_crc_table();
+#endif /* DYNAMIC_CRC_TABLE */
+
+#ifdef BYFOUR
+    if (sizeof(void *) == sizeof(ptrdiff_t)) {
+        u4 endian;
+
+        endian = 1;
+        if (*((unsigned char *)(&amp;endian)))
+            return crc32_little(crc, buf, len);
+        else
+            return crc32_big(crc, buf, len);
+    }
+#endif /* BYFOUR */
+    crc = crc ^ 0xffffffffUL;
+    while (len &gt;= 8) {
+        DO8;
+        len -= 8;
+    }
+    if (len) do {
+        DO1;
+    } while (--len);
+    return crc ^ 0xffffffffUL;
+}
+
+#ifdef BYFOUR
+
+/* ========================================================================= */
+#define DOLIT4 c ^= *buf4++; \
+        c = crc_table[3][c &amp; 0xff] ^ crc_table[2][(c &gt;&gt; 8) &amp; 0xff] ^ \
+            crc_table[1][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[0][c &gt;&gt; 24]
+#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
+
+/* ========================================================================= */
+local unsigned long crc32_little(crc, buf, len)
+    unsigned long crc;
+    const unsigned char FAR *buf;
+    unsigned len;
+{
+    register u4 c;
+    register const u4 FAR *buf4;
+
+    c = (u4)crc;
+    c = ~c;
+    while (len &amp;&amp; ((ptrdiff_t)buf &amp; 3)) {
+        c = crc_table[0][(c ^ *buf++) &amp; 0xff] ^ (c &gt;&gt; 8);
+        len--;
+    }
+
+    buf4 = (const u4 FAR *)(const void FAR *)buf;
+    while (len &gt;= 32) {
+        DOLIT32;
+        len -= 32;
+    }
+    while (len &gt;= 4) {
+        DOLIT4;
+        len -= 4;
+    }
+    buf = (const unsigned char FAR *)buf4;
+
+    if (len) do {
+        c = crc_table[0][(c ^ *buf++) &amp; 0xff] ^ (c &gt;&gt; 8);
+    } while (--len);
+    c = ~c;
+    return (unsigned long)c;
+}
+
+/* ========================================================================= */
+#define DOBIG4 c ^= *++buf4; \
+        c = crc_table[4][c &amp; 0xff] ^ crc_table[5][(c &gt;&gt; 8) &amp; 0xff] ^ \
+            crc_table[6][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[7][c &gt;&gt; 24]
+#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
+
+/* ========================================================================= */
+local unsigned long crc32_big(crc, buf, len)
+    unsigned long crc;
+    const unsigned char FAR *buf;
+    unsigned len;
+{
+    register u4 c;
+    register const u4 FAR *buf4;
+
+    c = REV((u4)crc);
+    c = ~c;
+    while (len &amp;&amp; ((ptrdiff_t)buf &amp; 3)) {
+        c = crc_table[4][(c &gt;&gt; 24) ^ *buf++] ^ (c &lt;&lt; 8);
+        len--;
+    }
+
+    buf4 = (const u4 FAR *)(const void FAR *)buf;
+    buf4--;
+    while (len &gt;= 32) {
+        DOBIG32;
+        len -= 32;
+    }
+    while (len &gt;= 4) {
+        DOBIG4;
+        len -= 4;
+    }
+    buf4++;
+    buf = (const unsigned char FAR *)buf4;
+
+    if (len) do {
+        c = crc_table[4][(c &gt;&gt; 24) ^ *buf++] ^ (c &lt;&lt; 8);
+    } while (--len);
+    c = ~c;
+    return (unsigned long)(REV(c));
+}
+
+#endif /* BYFOUR */
+
+#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */
+
+/* ========================================================================= */
+local unsigned long gf2_matrix_times(mat, vec)
+    unsigned long *mat;
+    unsigned long vec;
+{
+    unsigned long sum;
+
+    sum = 0;
+    while (vec) {
+        if (vec &amp; 1)
+            sum ^= *mat;
+        vec &gt;&gt;= 1;
+        mat++;
+    }
+    return sum;
+}
+
+/* ========================================================================= */
+local void gf2_matrix_square(square, mat)
+    unsigned long *square;
+    unsigned long *mat;
+{
+    int n;
+
+    for (n = 0; n &lt; GF2_DIM; n++)
+        square[n] = gf2_matrix_times(mat, mat[n]);
+}
+
+/* ========================================================================= */
+local uLong crc32_combine_(crc1, crc2, len2)
+    uLong crc1;
+    uLong crc2;
+    z_off64_t len2;
+{
+    int n;
+    unsigned long row;
+    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
+    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */
+
+    /* degenerate case (also disallow negative lengths) */
+    if (len2 &lt;= 0)
+        return crc1;
+
+    /* put operator for one zero bit in odd */
+    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
+    row = 1;
+    for (n = 1; n &lt; GF2_DIM; n++) {
+        odd[n] = row;
+        row &lt;&lt;= 1;
+    }
+
+    /* put operator for two zero bits in even */
+    gf2_matrix_square(even, odd);
+
+    /* put operator for four zero bits in odd */
+    gf2_matrix_square(odd, even);
+
+    /* apply len2 zeros to crc1 (first square will put the operator for one
+       zero byte, eight zero bits, in even) */
+    do {
+        /* apply zeros operator for this bit of len2 */
+        gf2_matrix_square(even, odd);
+        if (len2 &amp; 1)
+            crc1 = gf2_matrix_times(even, crc1);
+        len2 &gt;&gt;= 1;
+
+        /* if no more bits set, then done */
+        if (len2 == 0)
+            break;
+
+        /* another iteration of the loop with odd and even swapped */
+        gf2_matrix_square(odd, even);
+        if (len2 &amp; 1)
+            crc1 = gf2_matrix_times(odd, crc1);
+        len2 &gt;&gt;= 1;
+
+        /* if no more bits set, then done */
+    } while (len2 != 0);
+
+    /* return combined crc */
+    crc1 ^= crc2;
+    return crc1;
+}
+
+/* ========================================================================= */
+uLong ZEXPORT crc32_combine(crc1, crc2, len2)
+    uLong crc1;
+    uLong crc2;
+    z_off_t len2;
+{
+    return crc32_combine_(crc1, crc2, len2);
+}
+
+uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
+    uLong crc1;
+    uLong crc2;
+    z_off64_t len2;
+{
+    return crc32_combine_(crc1, crc2, len2);
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/crc32.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/crc32.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/crc32.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,441 @@
+/* crc32.h -- tables for rapid CRC calculation
+ * Generated automatically by crc32.c
+ */
+
+local const unsigned long FAR crc_table[TBLS][256] =
+{
+  {
+    0x00000000UL, 0x77073096UL, 0xee0e612cUL, 0x990951baUL, 0x076dc419UL,
+    0x706af48fUL, 0xe963a535UL, 0x9e6495a3UL, 0x0edb8832UL, 0x79dcb8a4UL,
+    0xe0d5e91eUL, 0x97d2d988UL, 0x09b64c2bUL, 0x7eb17cbdUL, 0xe7b82d07UL,
+    0x90bf1d91UL, 0x1db71064UL, 0x6ab020f2UL, 0xf3b97148UL, 0x84be41deUL,
+    0x1adad47dUL, 0x6ddde4ebUL, 0xf4d4b551UL, 0x83d385c7UL, 0x136c9856UL,
+    0x646ba8c0UL, 0xfd62f97aUL, 0x8a65c9ecUL, 0x14015c4fUL, 0x63066cd9UL,
+    0xfa0f3d63UL, 0x8d080df5UL, 0x3b6e20c8UL, 0x4c69105eUL, 0xd56041e4UL,
+    0xa2677172UL, 0x3c03e4d1UL, 0x4b04d447UL, 0xd20d85fdUL, 0xa50ab56bUL,
+    0x35b5a8faUL, 0x42b2986cUL, 0xdbbbc9d6UL, 0xacbcf940UL, 0x32d86ce3UL,
+    0x45df5c75UL, 0xdcd60dcfUL, 0xabd13d59UL, 0x26d930acUL, 0x51de003aUL,
+    0xc8d75180UL, 0xbfd06116UL, 0x21b4f4b5UL, 0x56b3c423UL, 0xcfba9599UL,
+    0xb8bda50fUL, 0x2802b89eUL, 0x5f058808UL, 0xc60cd9b2UL, 0xb10be924UL,
+    0x2f6f7c87UL, 0x58684c11UL, 0xc1611dabUL, 0xb6662d3dUL, 0x76dc4190UL,
+    0x01db7106UL, 0x98d220bcUL, 0xefd5102aUL, 0x71b18589UL, 0x06b6b51fUL,
+    0x9fbfe4a5UL, 0xe8b8d433UL, 0x7807c9a2UL, 0x0f00f934UL, 0x9609a88eUL,
+    0xe10e9818UL, 0x7f6a0dbbUL, 0x086d3d2dUL, 0x91646c97UL, 0xe6635c01UL,
+    0x6b6b51f4UL, 0x1c6c6162UL, 0x856530d8UL, 0xf262004eUL, 0x6c0695edUL,
+    0x1b01a57bUL, 0x8208f4c1UL, 0xf50fc457UL, 0x65b0d9c6UL, 0x12b7e950UL,
+    0x8bbeb8eaUL, 0xfcb9887cUL, 0x62dd1ddfUL, 0x15da2d49UL, 0x8cd37cf3UL,
+    0xfbd44c65UL, 0x4db26158UL, 0x3ab551ceUL, 0xa3bc0074UL, 0xd4bb30e2UL,
+    0x4adfa541UL, 0x3dd895d7UL, 0xa4d1c46dUL, 0xd3d6f4fbUL, 0x4369e96aUL,
+    0x346ed9fcUL, 0xad678846UL, 0xda60b8d0UL, 0x44042d73UL, 0x33031de5UL,
+    0xaa0a4c5fUL, 0xdd0d7cc9UL, 0x5005713cUL, 0x270241aaUL, 0xbe0b1010UL,
+    0xc90c2086UL, 0x5768b525UL, 0x206f85b3UL, 0xb966d409UL, 0xce61e49fUL,
+    0x5edef90eUL, 0x29d9c998UL, 0xb0d09822UL, 0xc7d7a8b4UL, 0x59b33d17UL,
+    0x2eb40d81UL, 0xb7bd5c3bUL, 0xc0ba6cadUL, 0xedb88320UL, 0x9abfb3b6UL,
+    0x03b6e20cUL, 0x74b1d29aUL, 0xead54739UL, 0x9dd277afUL, 0x04db2615UL,
+    0x73dc1683UL, 0xe3630b12UL, 0x94643b84UL, 0x0d6d6a3eUL, 0x7a6a5aa8UL,
+    0xe40ecf0bUL, 0x9309ff9dUL, 0x0a00ae27UL, 0x7d079eb1UL, 0xf00f9344UL,
+    0x8708a3d2UL, 0x1e01f268UL, 0x6906c2feUL, 0xf762575dUL, 0x806567cbUL,
+    0x196c3671UL, 0x6e6b06e7UL, 0xfed41b76UL, 0x89d32be0UL, 0x10da7a5aUL,
+    0x67dd4accUL, 0xf9b9df6fUL, 0x8ebeeff9UL, 0x17b7be43UL, 0x60b08ed5UL,
+    0xd6d6a3e8UL, 0xa1d1937eUL, 0x38d8c2c4UL, 0x4fdff252UL, 0xd1bb67f1UL,
+    0xa6bc5767UL, 0x3fb506ddUL, 0x48b2364bUL, 0xd80d2bdaUL, 0xaf0a1b4cUL,
+    0x36034af6UL, 0x41047a60UL, 0xdf60efc3UL, 0xa867df55UL, 0x316e8eefUL,
+    0x4669be79UL, 0xcb61b38cUL, 0xbc66831aUL, 0x256fd2a0UL, 0x5268e236UL,
+    0xcc0c7795UL, 0xbb0b4703UL, 0x220216b9UL, 0x5505262fUL, 0xc5ba3bbeUL,
+    0xb2bd0b28UL, 0x2bb45a92UL, 0x5cb36a04UL, 0xc2d7ffa7UL, 0xb5d0cf31UL,
+    0x2cd99e8bUL, 0x5bdeae1dUL, 0x9b64c2b0UL, 0xec63f226UL, 0x756aa39cUL,
+    0x026d930aUL, 0x9c0906a9UL, 0xeb0e363fUL, 0x72076785UL, 0x05005713UL,
+    0x95bf4a82UL, 0xe2b87a14UL, 0x7bb12baeUL, 0x0cb61b38UL, 0x92d28e9bUL,
+    0xe5d5be0dUL, 0x7cdcefb7UL, 0x0bdbdf21UL, 0x86d3d2d4UL, 0xf1d4e242UL,
+    0x68ddb3f8UL, 0x1fda836eUL, 0x81be16cdUL, 0xf6b9265bUL, 0x6fb077e1UL,
+    0x18b74777UL, 0x88085ae6UL, 0xff0f6a70UL, 0x66063bcaUL, 0x11010b5cUL,
+    0x8f659effUL, 0xf862ae69UL, 0x616bffd3UL, 0x166ccf45UL, 0xa00ae278UL,
+    0xd70dd2eeUL, 0x4e048354UL, 0x3903b3c2UL, 0xa7672661UL, 0xd06016f7UL,
+    0x4969474dUL, 0x3e6e77dbUL, 0xaed16a4aUL, 0xd9d65adcUL, 0x40df0b66UL,
+    0x37d83bf0UL, 0xa9bcae53UL, 0xdebb9ec5UL, 0x47b2cf7fUL, 0x30b5ffe9UL,
+    0xbdbdf21cUL, 0xcabac28aUL, 0x53b39330UL, 0x24b4a3a6UL, 0xbad03605UL,
+    0xcdd70693UL, 0x54de5729UL, 0x23d967bfUL, 0xb3667a2eUL, 0xc4614ab8UL,
+    0x5d681b02UL, 0x2a6f2b94UL, 0xb40bbe37UL, 0xc30c8ea1UL, 0x5a05df1bUL,
+    0x2d02ef8dUL
+#ifdef BYFOUR
+  },
+  {
+    0x00000000UL, 0x191b3141UL, 0x32366282UL, 0x2b2d53c3UL, 0x646cc504UL,
+    0x7d77f445UL, 0x565aa786UL, 0x4f4196c7UL, 0xc8d98a08UL, 0xd1c2bb49UL,
+    0xfaefe88aUL, 0xe3f4d9cbUL, 0xacb54f0cUL, 0xb5ae7e4dUL, 0x9e832d8eUL,
+    0x87981ccfUL, 0x4ac21251UL, 0x53d92310UL, 0x78f470d3UL, 0x61ef4192UL,
+    0x2eaed755UL, 0x37b5e614UL, 0x1c98b5d7UL, 0x05838496UL, 0x821b9859UL,
+    0x9b00a918UL, 0xb02dfadbUL, 0xa936cb9aUL, 0xe6775d5dUL, 0xff6c6c1cUL,
+    0xd4413fdfUL, 0xcd5a0e9eUL, 0x958424a2UL, 0x8c9f15e3UL, 0xa7b24620UL,
+    0xbea97761UL, 0xf1e8e1a6UL, 0xe8f3d0e7UL, 0xc3de8324UL, 0xdac5b265UL,
+    0x5d5daeaaUL, 0x44469febUL, 0x6f6bcc28UL, 0x7670fd69UL, 0x39316baeUL,
+    0x202a5aefUL, 0x0b07092cUL, 0x121c386dUL, 0xdf4636f3UL, 0xc65d07b2UL,
+    0xed705471UL, 0xf46b6530UL, 0xbb2af3f7UL, 0xa231c2b6UL, 0x891c9175UL,
+    0x9007a034UL, 0x179fbcfbUL, 0x0e848dbaUL, 0x25a9de79UL, 0x3cb2ef38UL,
+    0x73f379ffUL, 0x6ae848beUL, 0x41c51b7dUL, 0x58de2a3cUL, 0xf0794f05UL,
+    0xe9627e44UL, 0xc24f2d87UL, 0xdb541cc6UL, 0x94158a01UL, 0x8d0ebb40UL,
+    0xa623e883UL, 0xbf38d9c2UL, 0x38a0c50dUL, 0x21bbf44cUL, 0x0a96a78fUL,
+    0x138d96ceUL, 0x5ccc0009UL, 0x45d73148UL, 0x6efa628bUL, 0x77e153caUL,
+    0xbabb5d54UL, 0xa3a06c15UL, 0x888d3fd6UL, 0x91960e97UL, 0xded79850UL,
+    0xc7cca911UL, 0xece1fad2UL, 0xf5facb93UL, 0x7262d75cUL, 0x6b79e61dUL,
+    0x4054b5deUL, 0x594f849fUL, 0x160e1258UL, 0x0f152319UL, 0x243870daUL,
+    0x3d23419bUL, 0x65fd6ba7UL, 0x7ce65ae6UL, 0x57cb0925UL, 0x4ed03864UL,
+    0x0191aea3UL, 0x188a9fe2UL, 0x33a7cc21UL, 0x2abcfd60UL, 0xad24e1afUL,
+    0xb43fd0eeUL, 0x9f12832dUL, 0x8609b26cUL, 0xc94824abUL, 0xd05315eaUL,
+    0xfb7e4629UL, 0xe2657768UL, 0x2f3f79f6UL, 0x362448b7UL, 0x1d091b74UL,
+    0x04122a35UL, 0x4b53bcf2UL, 0x52488db3UL, 0x7965de70UL, 0x607eef31UL,
+    0xe7e6f3feUL, 0xfefdc2bfUL, 0xd5d0917cUL, 0xcccba03dUL, 0x838a36faUL,
+    0x9a9107bbUL, 0xb1bc5478UL, 0xa8a76539UL, 0x3b83984bUL, 0x2298a90aUL,
+    0x09b5fac9UL, 0x10aecb88UL, 0x5fef5d4fUL, 0x46f46c0eUL, 0x6dd93fcdUL,
+    0x74c20e8cUL, 0xf35a1243UL, 0xea412302UL, 0xc16c70c1UL, 0xd8774180UL,
+    0x9736d747UL, 0x8e2de606UL, 0xa500b5c5UL, 0xbc1b8484UL, 0x71418a1aUL,
+    0x685abb5bUL, 0x4377e898UL, 0x5a6cd9d9UL, 0x152d4f1eUL, 0x0c367e5fUL,
+    0x271b2d9cUL, 0x3e001cddUL, 0xb9980012UL, 0xa0833153UL, 0x8bae6290UL,
+    0x92b553d1UL, 0xddf4c516UL, 0xc4eff457UL, 0xefc2a794UL, 0xf6d996d5UL,
+    0xae07bce9UL, 0xb71c8da8UL, 0x9c31de6bUL, 0x852aef2aUL, 0xca6b79edUL,
+    0xd37048acUL, 0xf85d1b6fUL, 0xe1462a2eUL, 0x66de36e1UL, 0x7fc507a0UL,
+    0x54e85463UL, 0x4df36522UL, 0x02b2f3e5UL, 0x1ba9c2a4UL, 0x30849167UL,
+    0x299fa026UL, 0xe4c5aeb8UL, 0xfdde9ff9UL, 0xd6f3cc3aUL, 0xcfe8fd7bUL,
+    0x80a96bbcUL, 0x99b25afdUL, 0xb29f093eUL, 0xab84387fUL, 0x2c1c24b0UL,
+    0x350715f1UL, 0x1e2a4632UL, 0x07317773UL, 0x4870e1b4UL, 0x516bd0f5UL,
+    0x7a468336UL, 0x635db277UL, 0xcbfad74eUL, 0xd2e1e60fUL, 0xf9ccb5ccUL,
+    0xe0d7848dUL, 0xaf96124aUL, 0xb68d230bUL, 0x9da070c8UL, 0x84bb4189UL,
+    0x03235d46UL, 0x1a386c07UL, 0x31153fc4UL, 0x280e0e85UL, 0x674f9842UL,
+    0x7e54a903UL, 0x5579fac0UL, 0x4c62cb81UL, 0x8138c51fUL, 0x9823f45eUL,
+    0xb30ea79dUL, 0xaa1596dcUL, 0xe554001bUL, 0xfc4f315aUL, 0xd7626299UL,
+    0xce7953d8UL, 0x49e14f17UL, 0x50fa7e56UL, 0x7bd72d95UL, 0x62cc1cd4UL,
+    0x2d8d8a13UL, 0x3496bb52UL, 0x1fbbe891UL, 0x06a0d9d0UL, 0x5e7ef3ecUL,
+    0x4765c2adUL, 0x6c48916eUL, 0x7553a02fUL, 0x3a1236e8UL, 0x230907a9UL,
+    0x0824546aUL, 0x113f652bUL, 0x96a779e4UL, 0x8fbc48a5UL, 0xa4911b66UL,
+    0xbd8a2a27UL, 0xf2cbbce0UL, 0xebd08da1UL, 0xc0fdde62UL, 0xd9e6ef23UL,
+    0x14bce1bdUL, 0x0da7d0fcUL, 0x268a833fUL, 0x3f91b27eUL, 0x70d024b9UL,
+    0x69cb15f8UL, 0x42e6463bUL, 0x5bfd777aUL, 0xdc656bb5UL, 0xc57e5af4UL,
+    0xee530937UL, 0xf7483876UL, 0xb809aeb1UL, 0xa1129ff0UL, 0x8a3fcc33UL,
+    0x9324fd72UL
+  },
+  {
+    0x00000000UL, 0x01c26a37UL, 0x0384d46eUL, 0x0246be59UL, 0x0709a8dcUL,
+    0x06cbc2ebUL, 0x048d7cb2UL, 0x054f1685UL, 0x0e1351b8UL, 0x0fd13b8fUL,
+    0x0d9785d6UL, 0x0c55efe1UL, 0x091af964UL, 0x08d89353UL, 0x0a9e2d0aUL,
+    0x0b5c473dUL, 0x1c26a370UL, 0x1de4c947UL, 0x1fa2771eUL, 0x1e601d29UL,
+    0x1b2f0bacUL, 0x1aed619bUL, 0x18abdfc2UL, 0x1969b5f5UL, 0x1235f2c8UL,
+    0x13f798ffUL, 0x11b126a6UL, 0x10734c91UL, 0x153c5a14UL, 0x14fe3023UL,
+    0x16b88e7aUL, 0x177ae44dUL, 0x384d46e0UL, 0x398f2cd7UL, 0x3bc9928eUL,
+    0x3a0bf8b9UL, 0x3f44ee3cUL, 0x3e86840bUL, 0x3cc03a52UL, 0x3d025065UL,
+    0x365e1758UL, 0x379c7d6fUL, 0x35dac336UL, 0x3418a901UL, 0x3157bf84UL,
+    0x3095d5b3UL, 0x32d36beaUL, 0x331101ddUL, 0x246be590UL, 0x25a98fa7UL,
+    0x27ef31feUL, 0x262d5bc9UL, 0x23624d4cUL, 0x22a0277bUL, 0x20e69922UL,
+    0x2124f315UL, 0x2a78b428UL, 0x2bbade1fUL, 0x29fc6046UL, 0x283e0a71UL,
+    0x2d711cf4UL, 0x2cb376c3UL, 0x2ef5c89aUL, 0x2f37a2adUL, 0x709a8dc0UL,
+    0x7158e7f7UL, 0x731e59aeUL, 0x72dc3399UL, 0x7793251cUL, 0x76514f2bUL,
+    0x7417f172UL, 0x75d59b45UL, 0x7e89dc78UL, 0x7f4bb64fUL, 0x7d0d0816UL,
+    0x7ccf6221UL, 0x798074a4UL, 0x78421e93UL, 0x7a04a0caUL, 0x7bc6cafdUL,
+    0x6cbc2eb0UL, 0x6d7e4487UL, 0x6f38fadeUL, 0x6efa90e9UL, 0x6bb5866cUL,
+    0x6a77ec5bUL, 0x68315202UL, 0x69f33835UL, 0x62af7f08UL, 0x636d153fUL,
+    0x612bab66UL, 0x60e9c151UL, 0x65a6d7d4UL, 0x6464bde3UL, 0x662203baUL,
+    0x67e0698dUL, 0x48d7cb20UL, 0x4915a117UL, 0x4b531f4eUL, 0x4a917579UL,
+    0x4fde63fcUL, 0x4e1c09cbUL, 0x4c5ab792UL, 0x4d98dda5UL, 0x46c49a98UL,
+    0x4706f0afUL, 0x45404ef6UL, 0x448224c1UL, 0x41cd3244UL, 0x400f5873UL,
+    0x4249e62aUL, 0x438b8c1dUL, 0x54f16850UL, 0x55330267UL, 0x5775bc3eUL,
+    0x56b7d609UL, 0x53f8c08cUL, 0x523aaabbUL, 0x507c14e2UL, 0x51be7ed5UL,
+    0x5ae239e8UL, 0x5b2053dfUL, 0x5966ed86UL, 0x58a487b1UL, 0x5deb9134UL,
+    0x5c29fb03UL, 0x5e6f455aUL, 0x5fad2f6dUL, 0xe1351b80UL, 0xe0f771b7UL,
+    0xe2b1cfeeUL, 0xe373a5d9UL, 0xe63cb35cUL, 0xe7fed96bUL, 0xe5b86732UL,
+    0xe47a0d05UL, 0xef264a38UL, 0xeee4200fUL, 0xeca29e56UL, 0xed60f461UL,
+    0xe82fe2e4UL, 0xe9ed88d3UL, 0xebab368aUL, 0xea695cbdUL, 0xfd13b8f0UL,
+    0xfcd1d2c7UL, 0xfe976c9eUL, 0xff5506a9UL, 0xfa1a102cUL, 0xfbd87a1bUL,
+    0xf99ec442UL, 0xf85cae75UL, 0xf300e948UL, 0xf2c2837fUL, 0xf0843d26UL,
+    0xf1465711UL, 0xf4094194UL, 0xf5cb2ba3UL, 0xf78d95faUL, 0xf64fffcdUL,
+    0xd9785d60UL, 0xd8ba3757UL, 0xdafc890eUL, 0xdb3ee339UL, 0xde71f5bcUL,
+    0xdfb39f8bUL, 0xddf521d2UL, 0xdc374be5UL, 0xd76b0cd8UL, 0xd6a966efUL,
+    0xd4efd8b6UL, 0xd52db281UL, 0xd062a404UL, 0xd1a0ce33UL, 0xd3e6706aUL,
+    0xd2241a5dUL, 0xc55efe10UL, 0xc49c9427UL, 0xc6da2a7eUL, 0xc7184049UL,
+    0xc25756ccUL, 0xc3953cfbUL, 0xc1d382a2UL, 0xc011e895UL, 0xcb4dafa8UL,
+    0xca8fc59fUL, 0xc8c97bc6UL, 0xc90b11f1UL, 0xcc440774UL, 0xcd866d43UL,
+    0xcfc0d31aUL, 0xce02b92dUL, 0x91af9640UL, 0x906dfc77UL, 0x922b422eUL,
+    0x93e92819UL, 0x96a63e9cUL, 0x976454abUL, 0x9522eaf2UL, 0x94e080c5UL,
+    0x9fbcc7f8UL, 0x9e7eadcfUL, 0x9c381396UL, 0x9dfa79a1UL, 0x98b56f24UL,
+    0x99770513UL, 0x9b31bb4aUL, 0x9af3d17dUL, 0x8d893530UL, 0x8c4b5f07UL,
+    0x8e0de15eUL, 0x8fcf8b69UL, 0x8a809decUL, 0x8b42f7dbUL, 0x89044982UL,
+    0x88c623b5UL, 0x839a6488UL, 0x82580ebfUL, 0x801eb0e6UL, 0x81dcdad1UL,
+    0x8493cc54UL, 0x8551a663UL, 0x8717183aUL, 0x86d5720dUL, 0xa9e2d0a0UL,
+    0xa820ba97UL, 0xaa6604ceUL, 0xaba46ef9UL, 0xaeeb787cUL, 0xaf29124bUL,
+    0xad6fac12UL, 0xacadc625UL, 0xa7f18118UL, 0xa633eb2fUL, 0xa4755576UL,
+    0xa5b73f41UL, 0xa0f829c4UL, 0xa13a43f3UL, 0xa37cfdaaUL, 0xa2be979dUL,
+    0xb5c473d0UL, 0xb40619e7UL, 0xb640a7beUL, 0xb782cd89UL, 0xb2cddb0cUL,
+    0xb30fb13bUL, 0xb1490f62UL, 0xb08b6555UL, 0xbbd72268UL, 0xba15485fUL,
+    0xb853f606UL, 0xb9919c31UL, 0xbcde8ab4UL, 0xbd1ce083UL, 0xbf5a5edaUL,
+    0xbe9834edUL
+  },
+  {
+    0x00000000UL, 0xb8bc6765UL, 0xaa09c88bUL, 0x12b5afeeUL, 0x8f629757UL,
+    0x37def032UL, 0x256b5fdcUL, 0x9dd738b9UL, 0xc5b428efUL, 0x7d084f8aUL,
+    0x6fbde064UL, 0xd7018701UL, 0x4ad6bfb8UL, 0xf26ad8ddUL, 0xe0df7733UL,
+    0x58631056UL, 0x5019579fUL, 0xe8a530faUL, 0xfa109f14UL, 0x42acf871UL,
+    0xdf7bc0c8UL, 0x67c7a7adUL, 0x75720843UL, 0xcdce6f26UL, 0x95ad7f70UL,
+    0x2d111815UL, 0x3fa4b7fbUL, 0x8718d09eUL, 0x1acfe827UL, 0xa2738f42UL,
+    0xb0c620acUL, 0x087a47c9UL, 0xa032af3eUL, 0x188ec85bUL, 0x0a3b67b5UL,
+    0xb28700d0UL, 0x2f503869UL, 0x97ec5f0cUL, 0x8559f0e2UL, 0x3de59787UL,
+    0x658687d1UL, 0xdd3ae0b4UL, 0xcf8f4f5aUL, 0x7733283fUL, 0xeae41086UL,
+    0x525877e3UL, 0x40edd80dUL, 0xf851bf68UL, 0xf02bf8a1UL, 0x48979fc4UL,
+    0x5a22302aUL, 0xe29e574fUL, 0x7f496ff6UL, 0xc7f50893UL, 0xd540a77dUL,
+    0x6dfcc018UL, 0x359fd04eUL, 0x8d23b72bUL, 0x9f9618c5UL, 0x272a7fa0UL,
+    0xbafd4719UL, 0x0241207cUL, 0x10f48f92UL, 0xa848e8f7UL, 0x9b14583dUL,
+    0x23a83f58UL, 0x311d90b6UL, 0x89a1f7d3UL, 0x1476cf6aUL, 0xaccaa80fUL,
+    0xbe7f07e1UL, 0x06c36084UL, 0x5ea070d2UL, 0xe61c17b7UL, 0xf4a9b859UL,
+    0x4c15df3cUL, 0xd1c2e785UL, 0x697e80e0UL, 0x7bcb2f0eUL, 0xc377486bUL,
+    0xcb0d0fa2UL, 0x73b168c7UL, 0x6104c729UL, 0xd9b8a04cUL, 0x446f98f5UL,
+    0xfcd3ff90UL, 0xee66507eUL, 0x56da371bUL, 0x0eb9274dUL, 0xb6054028UL,
+    0xa4b0efc6UL, 0x1c0c88a3UL, 0x81dbb01aUL, 0x3967d77fUL, 0x2bd27891UL,
+    0x936e1ff4UL, 0x3b26f703UL, 0x839a9066UL, 0x912f3f88UL, 0x299358edUL,
+    0xb4446054UL, 0x0cf80731UL, 0x1e4da8dfUL, 0xa6f1cfbaUL, 0xfe92dfecUL,
+    0x462eb889UL, 0x549b1767UL, 0xec277002UL, 0x71f048bbUL, 0xc94c2fdeUL,
+    0xdbf98030UL, 0x6345e755UL, 0x6b3fa09cUL, 0xd383c7f9UL, 0xc1366817UL,
+    0x798a0f72UL, 0xe45d37cbUL, 0x5ce150aeUL, 0x4e54ff40UL, 0xf6e89825UL,
+    0xae8b8873UL, 0x1637ef16UL, 0x048240f8UL, 0xbc3e279dUL, 0x21e91f24UL,
+    0x99557841UL, 0x8be0d7afUL, 0x335cb0caUL, 0xed59b63bUL, 0x55e5d15eUL,
+    0x47507eb0UL, 0xffec19d5UL, 0x623b216cUL, 0xda874609UL, 0xc832e9e7UL,
+    0x708e8e82UL, 0x28ed9ed4UL, 0x9051f9b1UL, 0x82e4565fUL, 0x3a58313aUL,
+    0xa78f0983UL, 0x1f336ee6UL, 0x0d86c108UL, 0xb53aa66dUL, 0xbd40e1a4UL,
+    0x05fc86c1UL, 0x1749292fUL, 0xaff54e4aUL, 0x322276f3UL, 0x8a9e1196UL,
+    0x982bbe78UL, 0x2097d91dUL, 0x78f4c94bUL, 0xc048ae2eUL, 0xd2fd01c0UL,
+    0x6a4166a5UL, 0xf7965e1cUL, 0x4f2a3979UL, 0x5d9f9697UL, 0xe523f1f2UL,
+    0x4d6b1905UL, 0xf5d77e60UL, 0xe762d18eUL, 0x5fdeb6ebUL, 0xc2098e52UL,
+    0x7ab5e937UL, 0x680046d9UL, 0xd0bc21bcUL, 0x88df31eaUL, 0x3063568fUL,
+    0x22d6f961UL, 0x9a6a9e04UL, 0x07bda6bdUL, 0xbf01c1d8UL, 0xadb46e36UL,
+    0x15080953UL, 0x1d724e9aUL, 0xa5ce29ffUL, 0xb77b8611UL, 0x0fc7e174UL,
+    0x9210d9cdUL, 0x2aacbea8UL, 0x38191146UL, 0x80a57623UL, 0xd8c66675UL,
+    0x607a0110UL, 0x72cfaefeUL, 0xca73c99bUL, 0x57a4f122UL, 0xef189647UL,
+    0xfdad39a9UL, 0x45115eccUL, 0x764dee06UL, 0xcef18963UL, 0xdc44268dUL,
+    0x64f841e8UL, 0xf92f7951UL, 0x41931e34UL, 0x5326b1daUL, 0xeb9ad6bfUL,
+    0xb3f9c6e9UL, 0x0b45a18cUL, 0x19f00e62UL, 0xa14c6907UL, 0x3c9b51beUL,
+    0x842736dbUL, 0x96929935UL, 0x2e2efe50UL, 0x2654b999UL, 0x9ee8defcUL,
+    0x8c5d7112UL, 0x34e11677UL, 0xa9362eceUL, 0x118a49abUL, 0x033fe645UL,
+    0xbb838120UL, 0xe3e09176UL, 0x5b5cf613UL, 0x49e959fdUL, 0xf1553e98UL,
+    0x6c820621UL, 0xd43e6144UL, 0xc68bceaaUL, 0x7e37a9cfUL, 0xd67f4138UL,
+    0x6ec3265dUL, 0x7c7689b3UL, 0xc4caeed6UL, 0x591dd66fUL, 0xe1a1b10aUL,
+    0xf3141ee4UL, 0x4ba87981UL, 0x13cb69d7UL, 0xab770eb2UL, 0xb9c2a15cUL,
+    0x017ec639UL, 0x9ca9fe80UL, 0x241599e5UL, 0x36a0360bUL, 0x8e1c516eUL,
+    0x866616a7UL, 0x3eda71c2UL, 0x2c6fde2cUL, 0x94d3b949UL, 0x090481f0UL,
+    0xb1b8e695UL, 0xa30d497bUL, 0x1bb12e1eUL, 0x43d23e48UL, 0xfb6e592dUL,
+    0xe9dbf6c3UL, 0x516791a6UL, 0xccb0a91fUL, 0x740cce7aUL, 0x66b96194UL,
+    0xde0506f1UL
+  },
+  {
+    0x00000000UL, 0x96300777UL, 0x2c610eeeUL, 0xba510999UL, 0x19c46d07UL,
+    0x8ff46a70UL, 0x35a563e9UL, 0xa395649eUL, 0x3288db0eUL, 0xa4b8dc79UL,
+    0x1ee9d5e0UL, 0x88d9d297UL, 0x2b4cb609UL, 0xbd7cb17eUL, 0x072db8e7UL,
+    0x911dbf90UL, 0x6410b71dUL, 0xf220b06aUL, 0x4871b9f3UL, 0xde41be84UL,
+    0x7dd4da1aUL, 0xebe4dd6dUL, 0x51b5d4f4UL, 0xc785d383UL, 0x56986c13UL,
+    0xc0a86b64UL, 0x7af962fdUL, 0xecc9658aUL, 0x4f5c0114UL, 0xd96c0663UL,
+    0x633d0ffaUL, 0xf50d088dUL, 0xc8206e3bUL, 0x5e10694cUL, 0xe44160d5UL,
+    0x727167a2UL, 0xd1e4033cUL, 0x47d4044bUL, 0xfd850dd2UL, 0x6bb50aa5UL,
+    0xfaa8b535UL, 0x6c98b242UL, 0xd6c9bbdbUL, 0x40f9bcacUL, 0xe36cd832UL,
+    0x755cdf45UL, 0xcf0dd6dcUL, 0x593dd1abUL, 0xac30d926UL, 0x3a00de51UL,
+    0x8051d7c8UL, 0x1661d0bfUL, 0xb5f4b421UL, 0x23c4b356UL, 0x9995bacfUL,
+    0x0fa5bdb8UL, 0x9eb80228UL, 0x0888055fUL, 0xb2d90cc6UL, 0x24e90bb1UL,
+    0x877c6f2fUL, 0x114c6858UL, 0xab1d61c1UL, 0x3d2d66b6UL, 0x9041dc76UL,
+    0x0671db01UL, 0xbc20d298UL, 0x2a10d5efUL, 0x8985b171UL, 0x1fb5b606UL,
+    0xa5e4bf9fUL, 0x33d4b8e8UL, 0xa2c90778UL, 0x34f9000fUL, 0x8ea80996UL,
+    0x18980ee1UL, 0xbb0d6a7fUL, 0x2d3d6d08UL, 0x976c6491UL, 0x015c63e6UL,
+    0xf4516b6bUL, 0x62616c1cUL, 0xd8306585UL, 0x4e0062f2UL, 0xed95066cUL,
+    0x7ba5011bUL, 0xc1f40882UL, 0x57c40ff5UL, 0xc6d9b065UL, 0x50e9b712UL,
+    0xeab8be8bUL, 0x7c88b9fcUL, 0xdf1ddd62UL, 0x492dda15UL, 0xf37cd38cUL,
+    0x654cd4fbUL, 0x5861b24dUL, 0xce51b53aUL, 0x7400bca3UL, 0xe230bbd4UL,
+    0x41a5df4aUL, 0xd795d83dUL, 0x6dc4d1a4UL, 0xfbf4d6d3UL, 0x6ae96943UL,
+    0xfcd96e34UL, 0x468867adUL, 0xd0b860daUL, 0x732d0444UL, 0xe51d0333UL,
+    0x5f4c0aaaUL, 0xc97c0dddUL, 0x3c710550UL, 0xaa410227UL, 0x10100bbeUL,
+    0x86200cc9UL, 0x25b56857UL, 0xb3856f20UL, 0x09d466b9UL, 0x9fe461ceUL,
+    0x0ef9de5eUL, 0x98c9d929UL, 0x2298d0b0UL, 0xb4a8d7c7UL, 0x173db359UL,
+    0x810db42eUL, 0x3b5cbdb7UL, 0xad6cbac0UL, 0x2083b8edUL, 0xb6b3bf9aUL,
+    0x0ce2b603UL, 0x9ad2b174UL, 0x3947d5eaUL, 0xaf77d29dUL, 0x1526db04UL,
+    0x8316dc73UL, 0x120b63e3UL, 0x843b6494UL, 0x3e6a6d0dUL, 0xa85a6a7aUL,
+    0x0bcf0ee4UL, 0x9dff0993UL, 0x27ae000aUL, 0xb19e077dUL, 0x44930ff0UL,
+    0xd2a30887UL, 0x68f2011eUL, 0xfec20669UL, 0x5d5762f7UL, 0xcb676580UL,
+    0x71366c19UL, 0xe7066b6eUL, 0x761bd4feUL, 0xe02bd389UL, 0x5a7ada10UL,
+    0xcc4add67UL, 0x6fdfb9f9UL, 0xf9efbe8eUL, 0x43beb717UL, 0xd58eb060UL,
+    0xe8a3d6d6UL, 0x7e93d1a1UL, 0xc4c2d838UL, 0x52f2df4fUL, 0xf167bbd1UL,
+    0x6757bca6UL, 0xdd06b53fUL, 0x4b36b248UL, 0xda2b0dd8UL, 0x4c1b0aafUL,
+    0xf64a0336UL, 0x607a0441UL, 0xc3ef60dfUL, 0x55df67a8UL, 0xef8e6e31UL,
+    0x79be6946UL, 0x8cb361cbUL, 0x1a8366bcUL, 0xa0d26f25UL, 0x36e26852UL,
+    0x95770cccUL, 0x03470bbbUL, 0xb9160222UL, 0x2f260555UL, 0xbe3bbac5UL,
+    0x280bbdb2UL, 0x925ab42bUL, 0x046ab35cUL, 0xa7ffd7c2UL, 0x31cfd0b5UL,
+    0x8b9ed92cUL, 0x1daede5bUL, 0xb0c2649bUL, 0x26f263ecUL, 0x9ca36a75UL,
+    0x0a936d02UL, 0xa906099cUL, 0x3f360eebUL, 0x85670772UL, 0x13570005UL,
+    0x824abf95UL, 0x147ab8e2UL, 0xae2bb17bUL, 0x381bb60cUL, 0x9b8ed292UL,
+    0x0dbed5e5UL, 0xb7efdc7cUL, 0x21dfdb0bUL, 0xd4d2d386UL, 0x42e2d4f1UL,
+    0xf8b3dd68UL, 0x6e83da1fUL, 0xcd16be81UL, 0x5b26b9f6UL, 0xe177b06fUL,
+    0x7747b718UL, 0xe65a0888UL, 0x706a0fffUL, 0xca3b0666UL, 0x5c0b0111UL,
+    0xff9e658fUL, 0x69ae62f8UL, 0xd3ff6b61UL, 0x45cf6c16UL, 0x78e20aa0UL,
+    0xeed20dd7UL, 0x5483044eUL, 0xc2b30339UL, 0x612667a7UL, 0xf71660d0UL,
+    0x4d476949UL, 0xdb776e3eUL, 0x4a6ad1aeUL, 0xdc5ad6d9UL, 0x660bdf40UL,
+    0xf03bd837UL, 0x53aebca9UL, 0xc59ebbdeUL, 0x7fcfb247UL, 0xe9ffb530UL,
+    0x1cf2bdbdUL, 0x8ac2bacaUL, 0x3093b353UL, 0xa6a3b424UL, 0x0536d0baUL,
+    0x9306d7cdUL, 0x2957de54UL, 0xbf67d923UL, 0x2e7a66b3UL, 0xb84a61c4UL,
+    0x021b685dUL, 0x942b6f2aUL, 0x37be0bb4UL, 0xa18e0cc3UL, 0x1bdf055aUL,
+    0x8def022dUL
+  },
+  {
+    0x00000000UL, 0x41311b19UL, 0x82623632UL, 0xc3532d2bUL, 0x04c56c64UL,
+    0x45f4777dUL, 0x86a75a56UL, 0xc796414fUL, 0x088ad9c8UL, 0x49bbc2d1UL,
+    0x8ae8effaUL, 0xcbd9f4e3UL, 0x0c4fb5acUL, 0x4d7eaeb5UL, 0x8e2d839eUL,
+    0xcf1c9887UL, 0x5112c24aUL, 0x1023d953UL, 0xd370f478UL, 0x9241ef61UL,
+    0x55d7ae2eUL, 0x14e6b537UL, 0xd7b5981cUL, 0x96848305UL, 0x59981b82UL,
+    0x18a9009bUL, 0xdbfa2db0UL, 0x9acb36a9UL, 0x5d5d77e6UL, 0x1c6c6cffUL,
+    0xdf3f41d4UL, 0x9e0e5acdUL, 0xa2248495UL, 0xe3159f8cUL, 0x2046b2a7UL,
+    0x6177a9beUL, 0xa6e1e8f1UL, 0xe7d0f3e8UL, 0x2483dec3UL, 0x65b2c5daUL,
+    0xaaae5d5dUL, 0xeb9f4644UL, 0x28cc6b6fUL, 0x69fd7076UL, 0xae6b3139UL,
+    0xef5a2a20UL, 0x2c09070bUL, 0x6d381c12UL, 0xf33646dfUL, 0xb2075dc6UL,
+    0x715470edUL, 0x30656bf4UL, 0xf7f32abbUL, 0xb6c231a2UL, 0x75911c89UL,
+    0x34a00790UL, 0xfbbc9f17UL, 0xba8d840eUL, 0x79dea925UL, 0x38efb23cUL,
+    0xff79f373UL, 0xbe48e86aUL, 0x7d1bc541UL, 0x3c2ade58UL, 0x054f79f0UL,
+    0x447e62e9UL, 0x872d4fc2UL, 0xc61c54dbUL, 0x018a1594UL, 0x40bb0e8dUL,
+    0x83e823a6UL, 0xc2d938bfUL, 0x0dc5a038UL, 0x4cf4bb21UL, 0x8fa7960aUL,
+    0xce968d13UL, 0x0900cc5cUL, 0x4831d745UL, 0x8b62fa6eUL, 0xca53e177UL,
+    0x545dbbbaUL, 0x156ca0a3UL, 0xd63f8d88UL, 0x970e9691UL, 0x5098d7deUL,
+    0x11a9ccc7UL, 0xd2fae1ecUL, 0x93cbfaf5UL, 0x5cd76272UL, 0x1de6796bUL,
+    0xdeb55440UL, 0x9f844f59UL, 0x58120e16UL, 0x1923150fUL, 0xda703824UL,
+    0x9b41233dUL, 0xa76bfd65UL, 0xe65ae67cUL, 0x2509cb57UL, 0x6438d04eUL,
+    0xa3ae9101UL, 0xe29f8a18UL, 0x21cca733UL, 0x60fdbc2aUL, 0xafe124adUL,
+    0xeed03fb4UL, 0x2d83129fUL, 0x6cb20986UL, 0xab2448c9UL, 0xea1553d0UL,
+    0x29467efbUL, 0x687765e2UL, 0xf6793f2fUL, 0xb7482436UL, 0x741b091dUL,
+    0x352a1204UL, 0xf2bc534bUL, 0xb38d4852UL, 0x70de6579UL, 0x31ef7e60UL,
+    0xfef3e6e7UL, 0xbfc2fdfeUL, 0x7c91d0d5UL, 0x3da0cbccUL, 0xfa368a83UL,
+    0xbb07919aUL, 0x7854bcb1UL, 0x3965a7a8UL, 0x4b98833bUL, 0x0aa99822UL,
+    0xc9fab509UL, 0x88cbae10UL, 0x4f5def5fUL, 0x0e6cf446UL, 0xcd3fd96dUL,
+    0x8c0ec274UL, 0x43125af3UL, 0x022341eaUL, 0xc1706cc1UL, 0x804177d8UL,
+    0x47d73697UL, 0x06e62d8eUL, 0xc5b500a5UL, 0x84841bbcUL, 0x1a8a4171UL,
+    0x5bbb5a68UL, 0x98e87743UL, 0xd9d96c5aUL, 0x1e4f2d15UL, 0x5f7e360cUL,
+    0x9c2d1b27UL, 0xdd1c003eUL, 0x120098b9UL, 0x533183a0UL, 0x9062ae8bUL,
+    0xd153b592UL, 0x16c5f4ddUL, 0x57f4efc4UL, 0x94a7c2efUL, 0xd596d9f6UL,
+    0xe9bc07aeUL, 0xa88d1cb7UL, 0x6bde319cUL, 0x2aef2a85UL, 0xed796bcaUL,
+    0xac4870d3UL, 0x6f1b5df8UL, 0x2e2a46e1UL, 0xe136de66UL, 0xa007c57fUL,
+    0x6354e854UL, 0x2265f34dUL, 0xe5f3b202UL, 0xa4c2a91bUL, 0x67918430UL,
+    0x26a09f29UL, 0xb8aec5e4UL, 0xf99fdefdUL, 0x3accf3d6UL, 0x7bfde8cfUL,
+    0xbc6ba980UL, 0xfd5ab299UL, 0x3e099fb2UL, 0x7f3884abUL, 0xb0241c2cUL,
+    0xf1150735UL, 0x32462a1eUL, 0x73773107UL, 0xb4e17048UL, 0xf5d06b51UL,
+    0x3683467aUL, 0x77b25d63UL, 0x4ed7facbUL, 0x0fe6e1d2UL, 0xccb5ccf9UL,
+    0x8d84d7e0UL, 0x4a1296afUL, 0x0b238db6UL, 0xc870a09dUL, 0x8941bb84UL,
+    0x465d2303UL, 0x076c381aUL, 0xc43f1531UL, 0x850e0e28UL, 0x42984f67UL,
+    0x03a9547eUL, 0xc0fa7955UL, 0x81cb624cUL, 0x1fc53881UL, 0x5ef42398UL,
+    0x9da70eb3UL, 0xdc9615aaUL, 0x1b0054e5UL, 0x5a314ffcUL, 0x996262d7UL,
+    0xd85379ceUL, 0x174fe149UL, 0x567efa50UL, 0x952dd77bUL, 0xd41ccc62UL,
+    0x138a8d2dUL, 0x52bb9634UL, 0x91e8bb1fUL, 0xd0d9a006UL, 0xecf37e5eUL,
+    0xadc26547UL, 0x6e91486cUL, 0x2fa05375UL, 0xe836123aUL, 0xa9070923UL,
+    0x6a542408UL, 0x2b653f11UL, 0xe479a796UL, 0xa548bc8fUL, 0x661b91a4UL,
+    0x272a8abdUL, 0xe0bccbf2UL, 0xa18dd0ebUL, 0x62defdc0UL, 0x23efe6d9UL,
+    0xbde1bc14UL, 0xfcd0a70dUL, 0x3f838a26UL, 0x7eb2913fUL, 0xb924d070UL,
+    0xf815cb69UL, 0x3b46e642UL, 0x7a77fd5bUL, 0xb56b65dcUL, 0xf45a7ec5UL,
+    0x370953eeUL, 0x763848f7UL, 0xb1ae09b8UL, 0xf09f12a1UL, 0x33cc3f8aUL,
+    0x72fd2493UL
+  },
+  {
+    0x00000000UL, 0x376ac201UL, 0x6ed48403UL, 0x59be4602UL, 0xdca80907UL,
+    0xebc2cb06UL, 0xb27c8d04UL, 0x85164f05UL, 0xb851130eUL, 0x8f3bd10fUL,
+    0xd685970dUL, 0xe1ef550cUL, 0x64f91a09UL, 0x5393d808UL, 0x0a2d9e0aUL,
+    0x3d475c0bUL, 0x70a3261cUL, 0x47c9e41dUL, 0x1e77a21fUL, 0x291d601eUL,
+    0xac0b2f1bUL, 0x9b61ed1aUL, 0xc2dfab18UL, 0xf5b56919UL, 0xc8f23512UL,
+    0xff98f713UL, 0xa626b111UL, 0x914c7310UL, 0x145a3c15UL, 0x2330fe14UL,
+    0x7a8eb816UL, 0x4de47a17UL, 0xe0464d38UL, 0xd72c8f39UL, 0x8e92c93bUL,
+    0xb9f80b3aUL, 0x3cee443fUL, 0x0b84863eUL, 0x523ac03cUL, 0x6550023dUL,
+    0x58175e36UL, 0x6f7d9c37UL, 0x36c3da35UL, 0x01a91834UL, 0x84bf5731UL,
+    0xb3d59530UL, 0xea6bd332UL, 0xdd011133UL, 0x90e56b24UL, 0xa78fa925UL,
+    0xfe31ef27UL, 0xc95b2d26UL, 0x4c4d6223UL, 0x7b27a022UL, 0x2299e620UL,
+    0x15f32421UL, 0x28b4782aUL, 0x1fdeba2bUL, 0x4660fc29UL, 0x710a3e28UL,
+    0xf41c712dUL, 0xc376b32cUL, 0x9ac8f52eUL, 0xada2372fUL, 0xc08d9a70UL,
+    0xf7e75871UL, 0xae591e73UL, 0x9933dc72UL, 0x1c259377UL, 0x2b4f5176UL,
+    0x72f11774UL, 0x459bd575UL, 0x78dc897eUL, 0x4fb64b7fUL, 0x16080d7dUL,
+    0x2162cf7cUL, 0xa4748079UL, 0x931e4278UL, 0xcaa0047aUL, 0xfdcac67bUL,
+    0xb02ebc6cUL, 0x87447e6dUL, 0xdefa386fUL, 0xe990fa6eUL, 0x6c86b56bUL,
+    0x5bec776aUL, 0x02523168UL, 0x3538f369UL, 0x087faf62UL, 0x3f156d63UL,
+    0x66ab2b61UL, 0x51c1e960UL, 0xd4d7a665UL, 0xe3bd6464UL, 0xba032266UL,
+    0x8d69e067UL, 0x20cbd748UL, 0x17a11549UL, 0x4e1f534bUL, 0x7975914aUL,
+    0xfc63de4fUL, 0xcb091c4eUL, 0x92b75a4cUL, 0xa5dd984dUL, 0x989ac446UL,
+    0xaff00647UL, 0xf64e4045UL, 0xc1248244UL, 0x4432cd41UL, 0x73580f40UL,
+    0x2ae64942UL, 0x1d8c8b43UL, 0x5068f154UL, 0x67023355UL, 0x3ebc7557UL,
+    0x09d6b756UL, 0x8cc0f853UL, 0xbbaa3a52UL, 0xe2147c50UL, 0xd57ebe51UL,
+    0xe839e25aUL, 0xdf53205bUL, 0x86ed6659UL, 0xb187a458UL, 0x3491eb5dUL,
+    0x03fb295cUL, 0x5a456f5eUL, 0x6d2fad5fUL, 0x801b35e1UL, 0xb771f7e0UL,
+    0xeecfb1e2UL, 0xd9a573e3UL, 0x5cb33ce6UL, 0x6bd9fee7UL, 0x3267b8e5UL,
+    0x050d7ae4UL, 0x384a26efUL, 0x0f20e4eeUL, 0x569ea2ecUL, 0x61f460edUL,
+    0xe4e22fe8UL, 0xd388ede9UL, 0x8a36abebUL, 0xbd5c69eaUL, 0xf0b813fdUL,
+    0xc7d2d1fcUL, 0x9e6c97feUL, 0xa90655ffUL, 0x2c101afaUL, 0x1b7ad8fbUL,
+    0x42c49ef9UL, 0x75ae5cf8UL, 0x48e900f3UL, 0x7f83c2f2UL, 0x263d84f0UL,
+    0x115746f1UL, 0x944109f4UL, 0xa32bcbf5UL, 0xfa958df7UL, 0xcdff4ff6UL,
+    0x605d78d9UL, 0x5737bad8UL, 0x0e89fcdaUL, 0x39e33edbUL, 0xbcf571deUL,
+    0x8b9fb3dfUL, 0xd221f5ddUL, 0xe54b37dcUL, 0xd80c6bd7UL, 0xef66a9d6UL,
+    0xb6d8efd4UL, 0x81b22dd5UL, 0x04a462d0UL, 0x33cea0d1UL, 0x6a70e6d3UL,
+    0x5d1a24d2UL, 0x10fe5ec5UL, 0x27949cc4UL, 0x7e2adac6UL, 0x494018c7UL,
+    0xcc5657c2UL, 0xfb3c95c3UL, 0xa282d3c1UL, 0x95e811c0UL, 0xa8af4dcbUL,
+    0x9fc58fcaUL, 0xc67bc9c8UL, 0xf1110bc9UL, 0x740744ccUL, 0x436d86cdUL,
+    0x1ad3c0cfUL, 0x2db902ceUL, 0x4096af91UL, 0x77fc6d90UL, 0x2e422b92UL,
+    0x1928e993UL, 0x9c3ea696UL, 0xab546497UL, 0xf2ea2295UL, 0xc580e094UL,
+    0xf8c7bc9fUL, 0xcfad7e9eUL, 0x9613389cUL, 0xa179fa9dUL, 0x246fb598UL,
+    0x13057799UL, 0x4abb319bUL, 0x7dd1f39aUL, 0x3035898dUL, 0x075f4b8cUL,
+    0x5ee10d8eUL, 0x698bcf8fUL, 0xec9d808aUL, 0xdbf7428bUL, 0x82490489UL,
+    0xb523c688UL, 0x88649a83UL, 0xbf0e5882UL, 0xe6b01e80UL, 0xd1dadc81UL,
+    0x54cc9384UL, 0x63a65185UL, 0x3a181787UL, 0x0d72d586UL, 0xa0d0e2a9UL,
+    0x97ba20a8UL, 0xce0466aaUL, 0xf96ea4abUL, 0x7c78ebaeUL, 0x4b1229afUL,
+    0x12ac6fadUL, 0x25c6adacUL, 0x1881f1a7UL, 0x2feb33a6UL, 0x765575a4UL,
+    0x413fb7a5UL, 0xc429f8a0UL, 0xf3433aa1UL, 0xaafd7ca3UL, 0x9d97bea2UL,
+    0xd073c4b5UL, 0xe71906b4UL, 0xbea740b6UL, 0x89cd82b7UL, 0x0cdbcdb2UL,
+    0x3bb10fb3UL, 0x620f49b1UL, 0x55658bb0UL, 0x6822d7bbUL, 0x5f4815baUL,
+    0x06f653b8UL, 0x319c91b9UL, 0xb48adebcUL, 0x83e01cbdUL, 0xda5e5abfUL,
+    0xed3498beUL
+  },
+  {
+    0x00000000UL, 0x6567bcb8UL, 0x8bc809aaUL, 0xeeafb512UL, 0x5797628fUL,
+    0x32f0de37UL, 0xdc5f6b25UL, 0xb938d79dUL, 0xef28b4c5UL, 0x8a4f087dUL,
+    0x64e0bd6fUL, 0x018701d7UL, 0xb8bfd64aUL, 0xddd86af2UL, 0x3377dfe0UL,
+    0x56106358UL, 0x9f571950UL, 0xfa30a5e8UL, 0x149f10faUL, 0x71f8ac42UL,
+    0xc8c07bdfUL, 0xada7c767UL, 0x43087275UL, 0x266fcecdUL, 0x707fad95UL,
+    0x1518112dUL, 0xfbb7a43fUL, 0x9ed01887UL, 0x27e8cf1aUL, 0x428f73a2UL,
+    0xac20c6b0UL, 0xc9477a08UL, 0x3eaf32a0UL, 0x5bc88e18UL, 0xb5673b0aUL,
+    0xd00087b2UL, 0x6938502fUL, 0x0c5fec97UL, 0xe2f05985UL, 0x8797e53dUL,
+    0xd1878665UL, 0xb4e03addUL, 0x5a4f8fcfUL, 0x3f283377UL, 0x8610e4eaUL,
+    0xe3775852UL, 0x0dd8ed40UL, 0x68bf51f8UL, 0xa1f82bf0UL, 0xc49f9748UL,
+    0x2a30225aUL, 0x4f579ee2UL, 0xf66f497fUL, 0x9308f5c7UL, 0x7da740d5UL,
+    0x18c0fc6dUL, 0x4ed09f35UL, 0x2bb7238dUL, 0xc518969fUL, 0xa07f2a27UL,
+    0x1947fdbaUL, 0x7c204102UL, 0x928ff410UL, 0xf7e848a8UL, 0x3d58149bUL,
+    0x583fa823UL, 0xb6901d31UL, 0xd3f7a189UL, 0x6acf7614UL, 0x0fa8caacUL,
+    0xe1077fbeUL, 0x8460c306UL, 0xd270a05eUL, 0xb7171ce6UL, 0x59b8a9f4UL,
+    0x3cdf154cUL, 0x85e7c2d1UL, 0xe0807e69UL, 0x0e2fcb7bUL, 0x6b4877c3UL,
+    0xa20f0dcbUL, 0xc768b173UL, 0x29c70461UL, 0x4ca0b8d9UL, 0xf5986f44UL,
+    0x90ffd3fcUL, 0x7e5066eeUL, 0x1b37da56UL, 0x4d27b90eUL, 0x284005b6UL,
+    0xc6efb0a4UL, 0xa3880c1cUL, 0x1ab0db81UL, 0x7fd76739UL, 0x9178d22bUL,
+    0xf41f6e93UL, 0x03f7263bUL, 0x66909a83UL, 0x883f2f91UL, 0xed589329UL,
+    0x546044b4UL, 0x3107f80cUL, 0xdfa84d1eUL, 0xbacff1a6UL, 0xecdf92feUL,
+    0x89b82e46UL, 0x67179b54UL, 0x027027ecUL, 0xbb48f071UL, 0xde2f4cc9UL,
+    0x3080f9dbUL, 0x55e74563UL, 0x9ca03f6bUL, 0xf9c783d3UL, 0x176836c1UL,
+    0x720f8a79UL, 0xcb375de4UL, 0xae50e15cUL, 0x40ff544eUL, 0x2598e8f6UL,
+    0x73888baeUL, 0x16ef3716UL, 0xf8408204UL, 0x9d273ebcUL, 0x241fe921UL,
+    0x41785599UL, 0xafd7e08bUL, 0xcab05c33UL, 0x3bb659edUL, 0x5ed1e555UL,
+    0xb07e5047UL, 0xd519ecffUL, 0x6c213b62UL, 0x094687daUL, 0xe7e932c8UL,
+    0x828e8e70UL, 0xd49eed28UL, 0xb1f95190UL, 0x5f56e482UL, 0x3a31583aUL,
+    0x83098fa7UL, 0xe66e331fUL, 0x08c1860dUL, 0x6da63ab5UL, 0xa4e140bdUL,
+    0xc186fc05UL, 0x2f294917UL, 0x4a4ef5afUL, 0xf3762232UL, 0x96119e8aUL,
+    0x78be2b98UL, 0x1dd99720UL, 0x4bc9f478UL, 0x2eae48c0UL, 0xc001fdd2UL,
+    0xa566416aUL, 0x1c5e96f7UL, 0x79392a4fUL, 0x97969f5dUL, 0xf2f123e5UL,
+    0x05196b4dUL, 0x607ed7f5UL, 0x8ed162e7UL, 0xebb6de5fUL, 0x528e09c2UL,
+    0x37e9b57aUL, 0xd9460068UL, 0xbc21bcd0UL, 0xea31df88UL, 0x8f566330UL,
+    0x61f9d622UL, 0x049e6a9aUL, 0xbda6bd07UL, 0xd8c101bfUL, 0x366eb4adUL,
+    0x53090815UL, 0x9a4e721dUL, 0xff29cea5UL, 0x11867bb7UL, 0x74e1c70fUL,
+    0xcdd91092UL, 0xa8beac2aUL, 0x46111938UL, 0x2376a580UL, 0x7566c6d8UL,
+    0x10017a60UL, 0xfeaecf72UL, 0x9bc973caUL, 0x22f1a457UL, 0x479618efUL,
+    0xa939adfdUL, 0xcc5e1145UL, 0x06ee4d76UL, 0x6389f1ceUL, 0x8d2644dcUL,
+    0xe841f864UL, 0x51792ff9UL, 0x341e9341UL, 0xdab12653UL, 0xbfd69aebUL,
+    0xe9c6f9b3UL, 0x8ca1450bUL, 0x620ef019UL, 0x07694ca1UL, 0xbe519b3cUL,
+    0xdb362784UL, 0x35999296UL, 0x50fe2e2eUL, 0x99b95426UL, 0xfcdee89eUL,
+    0x12715d8cUL, 0x7716e134UL, 0xce2e36a9UL, 0xab498a11UL, 0x45e63f03UL,
+    0x208183bbUL, 0x7691e0e3UL, 0x13f65c5bUL, 0xfd59e949UL, 0x983e55f1UL,
+    0x2106826cUL, 0x44613ed4UL, 0xaace8bc6UL, 0xcfa9377eUL, 0x38417fd6UL,
+    0x5d26c36eUL, 0xb389767cUL, 0xd6eecac4UL, 0x6fd61d59UL, 0x0ab1a1e1UL,
+    0xe41e14f3UL, 0x8179a84bUL, 0xd769cb13UL, 0xb20e77abUL, 0x5ca1c2b9UL,
+    0x39c67e01UL, 0x80fea99cUL, 0xe5991524UL, 0x0b36a036UL, 0x6e511c8eUL,
+    0xa7166686UL, 0xc271da3eUL, 0x2cde6f2cUL, 0x49b9d394UL, 0xf0810409UL,
+    0x95e6b8b1UL, 0x7b490da3UL, 0x1e2eb11bUL, 0x483ed243UL, 0x2d596efbUL,
+    0xc3f6dbe9UL, 0xa6916751UL, 0x1fa9b0ccUL, 0x7ace0c74UL, 0x9461b966UL,
+    0xf10605deUL
+#endif
+  }
+};

Added: Lobby/TASClient/LobbyComponents/delphizlib/crc32.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/crc32.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/deflate.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/deflate.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/deflate.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,1834 @@
+/* deflate.c -- compress data using the deflation algorithm
+ * Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The &quot;deflation&quot; process depends on being able to identify portions
+ *      of the input text which are identical to earlier input (within a
+ *      sliding window trailing behind the input currently being processed).
+ *
+ *      The most straightforward technique turns out to be the fastest for
+ *      most input files: try all possible matches and select the longest.
+ *      The key feature of this algorithm is that insertions into the string
+ *      dictionary are very simple and thus fast, and deletions are avoided
+ *      completely. Insertions are performed at each input character, whereas
+ *      string matches are performed only when the previous match ends. So it
+ *      is preferable to spend more time in matches to allow very fast string
+ *      insertions and avoid deletions. The matching algorithm for small
+ *      strings is inspired from that of Rabin &amp; Karp. A brute force approach
+ *      is used to find longer strings when a small match has been found.
+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
+ *      (by Leonid Broukhis).
+ *         A previous version of this file used a more sophisticated algorithm
+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized
+ *      time, but has a larger average cost, uses more memory and is patented.
+ *      However the F&amp;G algorithm may be faster for some highly redundant
+ *      files if the parameter max_chain_length (described below) is too large.
+ *
+ *  ACKNOWLEDGEMENTS
+ *
+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
+ *      I found it in 'freeze' written by Leonid Broukhis.
+ *      Thanks to many people for bug reports and testing.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,&quot;DEFLATE Compressed Data Format Specification&quot;.
+ *      Available in <A HREF="http://www.ietf.org/rfc/rfc1951.txt">http://www.ietf.org/rfc/rfc1951.txt</A>
+ *
+ *      A description of the Rabin and Karp algorithm is given in the book
+ *         &quot;Algorithms&quot; by R. Sedgewick, Addison-Wesley, p252.
+ *
+ *      Fiala,E.R., and Greene,D.H.
+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
+ *
+ */
+
+/* @(#) $Id$ */
+
+#include &quot;deflate.h&quot;
+
+const char deflate_copyright[] =
+   &quot; deflate 1.2.5 Copyright 1995-2010 Jean-loup Gailly and Mark Adler &quot;;
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/* ===========================================================================
+ *  Function prototypes.
+ */
+typedef enum {
+    need_more,      /* block not completed, need more input or more output */
+    block_done,     /* block flush performed */
+    finish_started, /* finish started, need only more output at next deflate */
+    finish_done     /* finish done, accept no more input or output */
+} block_state;
+
+typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+/* Compression function. Returns the block state after the call. */
+
+local void fill_window    OF((deflate_state *s));
+local block_state deflate_stored OF((deflate_state *s, int flush));
+local block_state deflate_fast   OF((deflate_state *s, int flush));
+#ifndef FASTEST
+local block_state deflate_slow   OF((deflate_state *s, int flush));
+#endif
+local block_state deflate_rle    OF((deflate_state *s, int flush));
+local block_state deflate_huff   OF((deflate_state *s, int flush));
+local void lm_init        OF((deflate_state *s));
+local void putShortMSB    OF((deflate_state *s, uInt b));
+local void flush_pending  OF((z_streamp strm));
+local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
+#ifdef ASMV
+      void match_init OF((void)); /* asm code initialization */
+      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#else
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#endif
+
+#ifdef DEBUG
+local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                            int length));
+#endif
+
+/* ===========================================================================
+ * Local data
+ */
+
+#define NIL 0
+/* Tail of hash chains */
+
+#ifndef TOO_FAR
+#  define TOO_FAR 4096
+#endif
+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+typedef struct config_s {
+   ush good_length; /* reduce lazy search above this match length */
+   ush max_lazy;    /* do not perform lazy search above this match length */
+   ush nice_length; /* quit search above this match length */
+   ush max_chain;
+   compress_func func;
+} config;
+
+#ifdef FASTEST
+local const config configuration_table[2] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
+#else
+local const config configuration_table[10] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
+/* 2 */ {4,    5, 16,    8, deflate_fast},
+/* 3 */ {4,    6, 32,   32, deflate_fast},
+
+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+/* 5 */ {8,   16, 32,   32, deflate_slow},
+/* 6 */ {8,   16, 128, 128, deflate_slow},
+/* 7 */ {8,   32, 128, 256, deflate_slow},
+/* 8 */ {32, 128, 258, 1024, deflate_slow},
+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
+#endif
+
+/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4
+ * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different
+ * meaning.
+ */
+
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+#ifndef NO_DUMMY_DECL
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+#endif
+
+/* ===========================================================================
+ * Update a hash value with the given input byte
+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ *    input characters, so that a running hash key can be computed from the
+ *    previous key instead of complete recalculation each time.
+ */
+#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)
+
+
+/* ===========================================================================
+ * Insert string str in the dictionary and set match_head to the previous head
+ * of the hash chain (the most recent string with same hash key). Return
+ * the previous length of the hash chain.
+ * If this file is compiled with -DFASTEST, the compression level is forced
+ * to 1, and no hash chains are maintained.
+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ *    input characters and the first MIN_MATCH bytes of str are valid
+ *    (except for the last MIN_MATCH-1 bytes of the input file).
+ */
+#ifdef FASTEST
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
+    match_head = s-&gt;head[s-&gt;ins_h], \
+    s-&gt;head[s-&gt;ins_h] = (Pos)(str))
+#else
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \
+    match_head = s-&gt;prev[(str) &amp; s-&gt;w_mask] = s-&gt;head[s-&gt;ins_h], \
+    s-&gt;head[s-&gt;ins_h] = (Pos)(str))
+#endif
+
+/* ===========================================================================
+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+ * prev[] will be initialized on the fly.
+ */
+#define CLEAR_HASH(s) \
+    s-&gt;head[s-&gt;hash_size-1] = NIL; \
+    zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));
+
+/* ========================================================================= */
+int ZEXPORT deflateInit_(strm, level, version, stream_size)
+    z_streamp strm;
+    int level;
+    const char *version;
+    int stream_size;
+{
+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+                         Z_DEFAULT_STRATEGY, version, stream_size);
+    /* To do: ignore strm-&gt;next_in if we use it as window */
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+                  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s;
+    int wrap = 1;
+    static const char my_version[] = ZLIB_VERSION;
+
+    ushf *overlay;
+    /* We overlay pending_buf and d_buf+l_buf. This works since the average
+     * output size for (length,distance) codes is &lt;= 24 bits.
+     */
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+        stream_size != sizeof(z_stream)) {
+        return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm-&gt;msg = Z_NULL;
+    if (strm-&gt;zalloc == (alloc_func)0) {
+        strm-&gt;zalloc = zcalloc;
+        strm-&gt;opaque = (voidpf)0;
+    }
+    if (strm-&gt;zfree == (free_func)0) strm-&gt;zfree = zcfree;
+
+#ifdef FASTEST
+    if (level != 0) level = 1;
+#else
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+#endif
+
+    if (windowBits &lt; 0) { /* suppress zlib wrapper */
+        wrap = 0;
+        windowBits = -windowBits;
+    }
+#ifdef GZIP
+    else if (windowBits &gt; 15) {
+        wrap = 2;       /* write gzip wrapper instead */
+        windowBits -= 16;
+    }
+#endif
+    if (memLevel &lt; 1 || memLevel &gt; MAX_MEM_LEVEL || method != Z_DEFLATED ||
+        windowBits &lt; 8 || windowBits &gt; 15 || level &lt; 0 || level &gt; 9 ||
+        strategy &lt; 0 || strategy &gt; Z_FIXED) {
+        return Z_STREAM_ERROR;
+    }
+    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+    strm-&gt;state = (struct internal_state FAR *)s;
+    s-&gt;strm = strm;
+
+    s-&gt;wrap = wrap;
+    s-&gt;gzhead = Z_NULL;
+    s-&gt;w_bits = windowBits;
+    s-&gt;w_size = 1 &lt;&lt; s-&gt;w_bits;
+    s-&gt;w_mask = s-&gt;w_size - 1;
+
+    s-&gt;hash_bits = memLevel + 7;
+    s-&gt;hash_size = 1 &lt;&lt; s-&gt;hash_bits;
+    s-&gt;hash_mask = s-&gt;hash_size - 1;
+    s-&gt;hash_shift =  ((s-&gt;hash_bits+MIN_MATCH-1)/MIN_MATCH);
+
+    s-&gt;window = (Bytef *) ZALLOC(strm, s-&gt;w_size, 2*sizeof(Byte));
+    s-&gt;prev   = (Posf *)  ZALLOC(strm, s-&gt;w_size, sizeof(Pos));
+    s-&gt;head   = (Posf *)  ZALLOC(strm, s-&gt;hash_size, sizeof(Pos));
+
+    s-&gt;high_water = 0;      /* nothing written to s-&gt;window yet */
+
+    s-&gt;lit_bufsize = 1 &lt;&lt; (memLevel + 6); /* 16K elements by default */
+
+    overlay = (ushf *) ZALLOC(strm, s-&gt;lit_bufsize, sizeof(ush)+2);
+    s-&gt;pending_buf = (uchf *) overlay;
+    s-&gt;pending_buf_size = (ulg)s-&gt;lit_bufsize * (sizeof(ush)+2L);
+
+    if (s-&gt;window == Z_NULL || s-&gt;prev == Z_NULL || s-&gt;head == Z_NULL ||
+        s-&gt;pending_buf == Z_NULL) {
+        s-&gt;status = FINISH_STATE;
+        strm-&gt;msg = (char*)ERR_MSG(Z_MEM_ERROR);
+        deflateEnd (strm);
+        return Z_MEM_ERROR;
+    }
+    s-&gt;d_buf = overlay + s-&gt;lit_bufsize/sizeof(ush);
+    s-&gt;l_buf = s-&gt;pending_buf + (1+sizeof(ush))*s-&gt;lit_bufsize;
+
+    s-&gt;level = level;
+    s-&gt;strategy = strategy;
+    s-&gt;method = (Byte)method;
+
+    return deflateReset(strm);
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    deflate_state *s;
+    uInt length = dictLength;
+    uInt n;
+    IPos hash_head = 0;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL || dictionary == Z_NULL ||
+        strm-&gt;state-&gt;wrap == 2 ||
+        (strm-&gt;state-&gt;wrap == 1 &amp;&amp; strm-&gt;state-&gt;status != INIT_STATE))
+        return Z_STREAM_ERROR;
+
+    s = strm-&gt;state;
+    if (s-&gt;wrap)
+        strm-&gt;adler = adler32(strm-&gt;adler, dictionary, dictLength);
+
+    if (length &lt; MIN_MATCH) return Z_OK;
+    if (length &gt; s-&gt;w_size) {
+        length = s-&gt;w_size;
+        dictionary += dictLength - length; /* use the tail of the dictionary */
+    }
+    zmemcpy(s-&gt;window, dictionary, length);
+    s-&gt;strstart = length;
+    s-&gt;block_start = (long)length;
+
+    /* Insert all strings in the hash table (except for the last two bytes).
+     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next
+     * call of fill_window.
+     */
+    s-&gt;ins_h = s-&gt;window[0];
+    UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[1]);
+    for (n = 0; n &lt;= length - MIN_MATCH; n++) {
+        INSERT_STRING(s, n, hash_head);
+    }
+    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateReset (strm)
+    z_streamp strm;
+{
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL ||
+        strm-&gt;zalloc == (alloc_func)0 || strm-&gt;zfree == (free_func)0) {
+        return Z_STREAM_ERROR;
+    }
+
+    strm-&gt;total_in = strm-&gt;total_out = 0;
+    strm-&gt;msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm-&gt;data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm-&gt;state;
+    s-&gt;pending = 0;
+    s-&gt;pending_out = s-&gt;pending_buf;
+
+    if (s-&gt;wrap &lt; 0) {
+        s-&gt;wrap = -s-&gt;wrap; /* was made negative by deflate(..., Z_FINISH); */
+    }
+    s-&gt;status = s-&gt;wrap ? INIT_STATE : BUSY_STATE;
+    strm-&gt;adler =
+#ifdef GZIP
+        s-&gt;wrap == 2 ? crc32(0L, Z_NULL, 0) :
+#endif
+        adler32(0L, Z_NULL, 0);
+    s-&gt;last_flush = Z_NO_FLUSH;
+
+    _tr_init(s);
+    lm_init(s);
+
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateSetHeader (strm, head)
+    z_streamp strm;
+    gz_headerp head;
+{
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    if (strm-&gt;state-&gt;wrap != 2) return Z_STREAM_ERROR;
+    strm-&gt;state-&gt;gzhead = head;
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflatePrime (strm, bits, value)
+    z_streamp strm;
+    int bits;
+    int value;
+{
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    strm-&gt;state-&gt;bi_valid = bits;
+    strm-&gt;state-&gt;bi_buf = (ush)(value &amp; ((1 &lt;&lt; bits) - 1));
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    deflate_state *s;
+    compress_func func;
+    int err = Z_OK;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    s = strm-&gt;state;
+
+#ifdef FASTEST
+    if (level != 0) level = 1;
+#else
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+#endif
+    if (level &lt; 0 || level &gt; 9 || strategy &lt; 0 || strategy &gt; Z_FIXED) {
+        return Z_STREAM_ERROR;
+    }
+    func = configuration_table[s-&gt;level].func;
+
+    if ((strategy != s-&gt;strategy || func != configuration_table[level].func) &amp;&amp;
+        strm-&gt;total_in != 0) {
+        /* Flush the last buffer: */
+        err = deflate(strm, Z_BLOCK);
+    }
+    if (s-&gt;level != level) {
+        s-&gt;level = level;
+        s-&gt;max_lazy_match   = configuration_table[level].max_lazy;
+        s-&gt;good_match       = configuration_table[level].good_length;
+        s-&gt;nice_match       = configuration_table[level].nice_length;
+        s-&gt;max_chain_length = configuration_table[level].max_chain;
+    }
+    s-&gt;strategy = strategy;
+    return err;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
+    z_streamp strm;
+    int good_length;
+    int max_lazy;
+    int nice_length;
+    int max_chain;
+{
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    s = strm-&gt;state;
+    s-&gt;good_match = good_length;
+    s-&gt;max_lazy_match = max_lazy;
+    s-&gt;nice_match = nice_length;
+    s-&gt;max_chain_length = max_chain;
+    return Z_OK;
+}
+
+/* =========================================================================
+ * For the default windowBits of 15 and memLevel of 8, this function returns
+ * a close to exact, as well as small, upper bound on the compressed size.
+ * They are coded as constants here for a reason--if the #define's are
+ * changed, then this function needs to be changed as well.  The return
+ * value for 15 and 8 only works for those exact settings.
+ *
+ * For any setting other than those defaults for windowBits and memLevel,
+ * the value returned is a conservative worst case for the maximum expansion
+ * resulting from using fixed blocks instead of stored blocks, which deflate
+ * can emit on compressed data for some combinations of the parameters.
+ *
+ * This function could be more sophisticated to provide closer upper bounds for
+ * every combination of windowBits and memLevel.  But even the conservative
+ * upper bound of about 14% expansion does not seem onerous for output buffer
+ * allocation.
+ */
+uLong ZEXPORT deflateBound(strm, sourceLen)
+    z_streamp strm;
+    uLong sourceLen;
+{
+    deflate_state *s;
+    uLong complen, wraplen;
+    Bytef *str;
+
+    /* conservative upper bound for compressed data */
+    complen = sourceLen +
+              ((sourceLen + 7) &gt;&gt; 3) + ((sourceLen + 63) &gt;&gt; 6) + 5;
+
+    /* if can't get parameters, return conservative bound plus zlib wrapper */
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL)
+        return complen + 6;
+
+    /* compute wrapper length */
+    s = strm-&gt;state;
+    switch (s-&gt;wrap) {
+    case 0:                                 /* raw deflate */
+        wraplen = 0;
+        break;
+    case 1:                                 /* zlib wrapper */
+        wraplen = 6 + (s-&gt;strstart ? 4 : 0);
+        break;
+    case 2:                                 /* gzip wrapper */
+        wraplen = 18;
+        if (s-&gt;gzhead != Z_NULL) {          /* user-supplied gzip header */
+            if (s-&gt;gzhead-&gt;extra != Z_NULL)
+                wraplen += 2 + s-&gt;gzhead-&gt;extra_len;
+            str = s-&gt;gzhead-&gt;name;
+            if (str != Z_NULL)
+                do {
+                    wraplen++;
+                } while (*str++);
+            str = s-&gt;gzhead-&gt;comment;
+            if (str != Z_NULL)
+                do {
+                    wraplen++;
+                } while (*str++);
+            if (s-&gt;gzhead-&gt;hcrc)
+                wraplen += 2;
+        }
+        break;
+    default:                                /* for compiler happiness */
+        wraplen = 6;
+    }
+
+    /* if not default parameters, return conservative bound */
+    if (s-&gt;w_bits != 15 || s-&gt;hash_bits != 8 + 7)
+        return complen + wraplen;
+
+    /* default settings: return tight bound for that case */
+    return sourceLen + (sourceLen &gt;&gt; 12) + (sourceLen &gt;&gt; 14) +
+           (sourceLen &gt;&gt; 25) + 13 - 6 + wraplen;
+}
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+local void putShortMSB (s, b)
+    deflate_state *s;
+    uInt b;
+{
+    put_byte(s, (Byte)(b &gt;&gt; 8));
+    put_byte(s, (Byte)(b &amp; 0xff));
+}
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm-&gt;next_out buffer and copying into it.
+ * (See also read_buf()).
+ */
+local void flush_pending(strm)
+    z_streamp strm;
+{
+    unsigned len = strm-&gt;state-&gt;pending;
+
+    if (len &gt; strm-&gt;avail_out) len = strm-&gt;avail_out;
+    if (len == 0) return;
+
+    zmemcpy(strm-&gt;next_out, strm-&gt;state-&gt;pending_out, len);
+    strm-&gt;next_out  += len;
+    strm-&gt;state-&gt;pending_out  += len;
+    strm-&gt;total_out += len;
+    strm-&gt;avail_out  -= len;
+    strm-&gt;state-&gt;pending -= len;
+    if (strm-&gt;state-&gt;pending == 0) {
+        strm-&gt;state-&gt;pending_out = strm-&gt;state-&gt;pending_buf;
+    }
+}
+
+/* ========================================================================= */
+int ZEXPORT deflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    int old_flush; /* value of flush param for previous deflate call */
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL ||
+        flush &gt; Z_BLOCK || flush &lt; 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = strm-&gt;state;
+
+    if (strm-&gt;next_out == Z_NULL ||
+        (strm-&gt;next_in == Z_NULL &amp;&amp; strm-&gt;avail_in != 0) ||
+        (s-&gt;status == FINISH_STATE &amp;&amp; flush != Z_FINISH)) {
+        ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+    if (strm-&gt;avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+
+    s-&gt;strm = strm; /* just in case */
+    old_flush = s-&gt;last_flush;
+    s-&gt;last_flush = flush;
+
+    /* Write the header */
+    if (s-&gt;status == INIT_STATE) {
+#ifdef GZIP
+        if (s-&gt;wrap == 2) {
+            strm-&gt;adler = crc32(0L, Z_NULL, 0);
+            put_byte(s, 31);
+            put_byte(s, 139);
+            put_byte(s, 8);
+            if (s-&gt;gzhead == Z_NULL) {
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, 0);
+                put_byte(s, s-&gt;level == 9 ? 2 :
+                            (s-&gt;strategy &gt;= Z_HUFFMAN_ONLY || s-&gt;level &lt; 2 ?
+                             4 : 0));
+                put_byte(s, OS_CODE);
+                s-&gt;status = BUSY_STATE;
+            }
+            else {
+                put_byte(s, (s-&gt;gzhead-&gt;text ? 1 : 0) +
+                            (s-&gt;gzhead-&gt;hcrc ? 2 : 0) +
+                            (s-&gt;gzhead-&gt;extra == Z_NULL ? 0 : 4) +
+                            (s-&gt;gzhead-&gt;name == Z_NULL ? 0 : 8) +
+                            (s-&gt;gzhead-&gt;comment == Z_NULL ? 0 : 16)
+                        );
+                put_byte(s, (Byte)(s-&gt;gzhead-&gt;time &amp; 0xff));
+                put_byte(s, (Byte)((s-&gt;gzhead-&gt;time &gt;&gt; 8) &amp; 0xff));
+                put_byte(s, (Byte)((s-&gt;gzhead-&gt;time &gt;&gt; 16) &amp; 0xff));
+                put_byte(s, (Byte)((s-&gt;gzhead-&gt;time &gt;&gt; 24) &amp; 0xff));
+                put_byte(s, s-&gt;level == 9 ? 2 :
+                            (s-&gt;strategy &gt;= Z_HUFFMAN_ONLY || s-&gt;level &lt; 2 ?
+                             4 : 0));
+                put_byte(s, s-&gt;gzhead-&gt;os &amp; 0xff);
+                if (s-&gt;gzhead-&gt;extra != Z_NULL) {
+                    put_byte(s, s-&gt;gzhead-&gt;extra_len &amp; 0xff);
+                    put_byte(s, (s-&gt;gzhead-&gt;extra_len &gt;&gt; 8) &amp; 0xff);
+                }
+                if (s-&gt;gzhead-&gt;hcrc)
+                    strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf,
+                                        s-&gt;pending);
+                s-&gt;gzindex = 0;
+                s-&gt;status = EXTRA_STATE;
+            }
+        }
+        else
+#endif
+        {
+            uInt header = (Z_DEFLATED + ((s-&gt;w_bits-8)&lt;&lt;4)) &lt;&lt; 8;
+            uInt level_flags;
+
+            if (s-&gt;strategy &gt;= Z_HUFFMAN_ONLY || s-&gt;level &lt; 2)
+                level_flags = 0;
+            else if (s-&gt;level &lt; 6)
+                level_flags = 1;
+            else if (s-&gt;level == 6)
+                level_flags = 2;
+            else
+                level_flags = 3;
+            header |= (level_flags &lt;&lt; 6);
+            if (s-&gt;strstart != 0) header |= PRESET_DICT;
+            header += 31 - (header % 31);
+
+            s-&gt;status = BUSY_STATE;
+            putShortMSB(s, header);
+
+            /* Save the adler32 of the preset dictionary: */
+            if (s-&gt;strstart != 0) {
+                putShortMSB(s, (uInt)(strm-&gt;adler &gt;&gt; 16));
+                putShortMSB(s, (uInt)(strm-&gt;adler &amp; 0xffff));
+            }
+            strm-&gt;adler = adler32(0L, Z_NULL, 0);
+        }
+    }
+#ifdef GZIP
+    if (s-&gt;status == EXTRA_STATE) {
+        if (s-&gt;gzhead-&gt;extra != Z_NULL) {
+            uInt beg = s-&gt;pending;  /* start of bytes to update crc */
+
+            while (s-&gt;gzindex &lt; (s-&gt;gzhead-&gt;extra_len &amp; 0xffff)) {
+                if (s-&gt;pending == s-&gt;pending_buf_size) {
+                    if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; beg)
+                        strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + beg,
+                                            s-&gt;pending - beg);
+                    flush_pending(strm);
+                    beg = s-&gt;pending;
+                    if (s-&gt;pending == s-&gt;pending_buf_size)
+                        break;
+                }
+                put_byte(s, s-&gt;gzhead-&gt;extra[s-&gt;gzindex]);
+                s-&gt;gzindex++;
+            }
+            if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; beg)
+                strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + beg,
+                                    s-&gt;pending - beg);
+            if (s-&gt;gzindex == s-&gt;gzhead-&gt;extra_len) {
+                s-&gt;gzindex = 0;
+                s-&gt;status = NAME_STATE;
+            }
+        }
+        else
+            s-&gt;status = NAME_STATE;
+    }
+    if (s-&gt;status == NAME_STATE) {
+        if (s-&gt;gzhead-&gt;name != Z_NULL) {
+            uInt beg = s-&gt;pending;  /* start of bytes to update crc */
+            int val;
+
+            do {
+                if (s-&gt;pending == s-&gt;pending_buf_size) {
+                    if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; beg)
+                        strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + beg,
+                                            s-&gt;pending - beg);
+                    flush_pending(strm);
+                    beg = s-&gt;pending;
+                    if (s-&gt;pending == s-&gt;pending_buf_size) {
+                        val = 1;
+                        break;
+                    }
+                }
+                val = s-&gt;gzhead-&gt;name[s-&gt;gzindex++];
+                put_byte(s, val);
+            } while (val != 0);
+            if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; beg)
+                strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + beg,
+                                    s-&gt;pending - beg);
+            if (val == 0) {
+                s-&gt;gzindex = 0;
+                s-&gt;status = COMMENT_STATE;
+            }
+        }
+        else
+            s-&gt;status = COMMENT_STATE;
+    }
+    if (s-&gt;status == COMMENT_STATE) {
+        if (s-&gt;gzhead-&gt;comment != Z_NULL) {
+            uInt beg = s-&gt;pending;  /* start of bytes to update crc */
+            int val;
+
+            do {
+                if (s-&gt;pending == s-&gt;pending_buf_size) {
+                    if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; beg)
+                        strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + beg,
+                                            s-&gt;pending - beg);
+                    flush_pending(strm);
+                    beg = s-&gt;pending;
+                    if (s-&gt;pending == s-&gt;pending_buf_size) {
+                        val = 1;
+                        break;
+                    }
+                }
+                val = s-&gt;gzhead-&gt;comment[s-&gt;gzindex++];
+                put_byte(s, val);
+            } while (val != 0);
+            if (s-&gt;gzhead-&gt;hcrc &amp;&amp; s-&gt;pending &gt; beg)
+                strm-&gt;adler = crc32(strm-&gt;adler, s-&gt;pending_buf + beg,
+                                    s-&gt;pending - beg);
+            if (val == 0)
+                s-&gt;status = HCRC_STATE;
+        }
+        else
+            s-&gt;status = HCRC_STATE;
+    }
+    if (s-&gt;status == HCRC_STATE) {
+        if (s-&gt;gzhead-&gt;hcrc) {
+            if (s-&gt;pending + 2 &gt; s-&gt;pending_buf_size)
+                flush_pending(strm);
+            if (s-&gt;pending + 2 &lt;= s-&gt;pending_buf_size) {
+                put_byte(s, (Byte)(strm-&gt;adler &amp; 0xff));
+                put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 8) &amp; 0xff));
+                strm-&gt;adler = crc32(0L, Z_NULL, 0);
+                s-&gt;status = BUSY_STATE;
+            }
+        }
+        else
+            s-&gt;status = BUSY_STATE;
+    }
+#endif
+
+    /* Flush as much pending output as possible */
+    if (s-&gt;pending != 0) {
+        flush_pending(strm);
+        if (strm-&gt;avail_out == 0) {
+            /* Since avail_out is 0, deflate will be called again with
+             * more output space, but possibly with both pending and
+             * avail_in equal to zero. There won't be anything to do,
+             * but this is not an error situation so make sure we
+             * return OK instead of BUF_ERROR at next call of deflate:
+             */
+            s-&gt;last_flush = -1;
+            return Z_OK;
+        }
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUF_ERROR.
+     */
+    } else if (strm-&gt;avail_in == 0 &amp;&amp; flush &lt;= old_flush &amp;&amp;
+               flush != Z_FINISH) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* User must not provide more input after the first FINISH: */
+    if (s-&gt;status == FINISH_STATE &amp;&amp; strm-&gt;avail_in != 0) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* Start a new block or continue the current one.
+     */
+    if (strm-&gt;avail_in != 0 || s-&gt;lookahead != 0 ||
+        (flush != Z_NO_FLUSH &amp;&amp; s-&gt;status != FINISH_STATE)) {
+        block_state bstate;
+
+        bstate = s-&gt;strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
+                    (s-&gt;strategy == Z_RLE ? deflate_rle(s, flush) :
+                        (*(configuration_table[s-&gt;level].func))(s, flush));
+
+        if (bstate == finish_started || bstate == finish_done) {
+            s-&gt;status = FINISH_STATE;
+        }
+        if (bstate == need_more || bstate == finish_started) {
+            if (strm-&gt;avail_out == 0) {
+                s-&gt;last_flush = -1; /* avoid BUF_ERROR next call, see above */
+            }
+            return Z_OK;
+            /* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
+             * of deflate should use the same flush parameter to make sure
+             * that the flush is complete. So we don't have to output an
+             * empty block here, this will be done at next call. This also
+             * ensures that for a very small output buffer, we emit at most
+             * one empty block.
+             */
+        }
+        if (bstate == block_done) {
+            if (flush == Z_PARTIAL_FLUSH) {
+                _tr_align(s);
+            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
+                _tr_stored_block(s, (char*)0, 0L, 0);
+                /* For a full flush, this empty block will be recognized
+                 * as a special marker by inflate_sync().
+                 */
+                if (flush == Z_FULL_FLUSH) {
+                    CLEAR_HASH(s);             /* forget history */
+                    if (s-&gt;lookahead == 0) {
+                        s-&gt;strstart = 0;
+                        s-&gt;block_start = 0L;
+                    }
+                }
+            }
+            flush_pending(strm);
+            if (strm-&gt;avail_out == 0) {
+              s-&gt;last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+              return Z_OK;
+            }
+        }
+    }
+    Assert(strm-&gt;avail_out &gt; 0, &quot;bug2&quot;);
+
+    if (flush != Z_FINISH) return Z_OK;
+    if (s-&gt;wrap &lt;= 0) return Z_STREAM_END;
+
+    /* Write the trailer */
+#ifdef GZIP
+    if (s-&gt;wrap == 2) {
+        put_byte(s, (Byte)(strm-&gt;adler &amp; 0xff));
+        put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 8) &amp; 0xff));
+        put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 16) &amp; 0xff));
+        put_byte(s, (Byte)((strm-&gt;adler &gt;&gt; 24) &amp; 0xff));
+        put_byte(s, (Byte)(strm-&gt;total_in &amp; 0xff));
+        put_byte(s, (Byte)((strm-&gt;total_in &gt;&gt; 8) &amp; 0xff));
+        put_byte(s, (Byte)((strm-&gt;total_in &gt;&gt; 16) &amp; 0xff));
+        put_byte(s, (Byte)((strm-&gt;total_in &gt;&gt; 24) &amp; 0xff));
+    }
+    else
+#endif
+    {
+        putShortMSB(s, (uInt)(strm-&gt;adler &gt;&gt; 16));
+        putShortMSB(s, (uInt)(strm-&gt;adler &amp; 0xffff));
+    }
+    flush_pending(strm);
+    /* If avail_out is zero, the application will call deflate again
+     * to flush the rest.
+     */
+    if (s-&gt;wrap &gt; 0) s-&gt;wrap = -s-&gt;wrap; /* write the trailer only once! */
+    return s-&gt;pending != 0 ? Z_OK : Z_STREAM_END;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateEnd (strm)
+    z_streamp strm;
+{
+    int status;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+
+    status = strm-&gt;state-&gt;status;
+    if (status != INIT_STATE &amp;&amp;
+        status != EXTRA_STATE &amp;&amp;
+        status != NAME_STATE &amp;&amp;
+        status != COMMENT_STATE &amp;&amp;
+        status != HCRC_STATE &amp;&amp;
+        status != BUSY_STATE &amp;&amp;
+        status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
+
+    /* Deallocate in reverse order of allocations: */
+    TRY_FREE(strm, strm-&gt;state-&gt;pending_buf);
+    TRY_FREE(strm, strm-&gt;state-&gt;head);
+    TRY_FREE(strm, strm-&gt;state-&gt;prev);
+    TRY_FREE(strm, strm-&gt;state-&gt;window);
+
+    ZFREE(strm, strm-&gt;state);
+    strm-&gt;state = Z_NULL;
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* =========================================================================
+ * Copy the source state to the destination state.
+ * To simplify the source, this is not supported for 16-bit MSDOS (which
+ * doesn't have enough memory anyway to duplicate compression states).
+ */
+int ZEXPORT deflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+#ifdef MAXSEG_64K
+    return Z_STREAM_ERROR;
+#else
+    deflate_state *ds;
+    deflate_state *ss;
+    ushf *overlay;
+
+
+    if (source == Z_NULL || dest == Z_NULL || source-&gt;state == Z_NULL) {
+        return Z_STREAM_ERROR;
+    }
+
+    ss = source-&gt;state;
+
+    zmemcpy(dest, source, sizeof(z_stream));
+
+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
+    if (ds == Z_NULL) return Z_MEM_ERROR;
+    dest-&gt;state = (struct internal_state FAR *) ds;
+    zmemcpy(ds, ss, sizeof(deflate_state));
+    ds-&gt;strm = dest;
+
+    ds-&gt;window = (Bytef *) ZALLOC(dest, ds-&gt;w_size, 2*sizeof(Byte));
+    ds-&gt;prev   = (Posf *)  ZALLOC(dest, ds-&gt;w_size, sizeof(Pos));
+    ds-&gt;head   = (Posf *)  ZALLOC(dest, ds-&gt;hash_size, sizeof(Pos));
+    overlay = (ushf *) ZALLOC(dest, ds-&gt;lit_bufsize, sizeof(ush)+2);
+    ds-&gt;pending_buf = (uchf *) overlay;
+
+    if (ds-&gt;window == Z_NULL || ds-&gt;prev == Z_NULL || ds-&gt;head == Z_NULL ||
+        ds-&gt;pending_buf == Z_NULL) {
+        deflateEnd (dest);
+        return Z_MEM_ERROR;
+    }
+    /* following zmemcpy do not work for 16-bit MSDOS */
+    zmemcpy(ds-&gt;window, ss-&gt;window, ds-&gt;w_size * 2 * sizeof(Byte));
+    zmemcpy(ds-&gt;prev, ss-&gt;prev, ds-&gt;w_size * sizeof(Pos));
+    zmemcpy(ds-&gt;head, ss-&gt;head, ds-&gt;hash_size * sizeof(Pos));
+    zmemcpy(ds-&gt;pending_buf, ss-&gt;pending_buf, (uInt)ds-&gt;pending_buf_size);
+
+    ds-&gt;pending_out = ds-&gt;pending_buf + (ss-&gt;pending_out - ss-&gt;pending_buf);
+    ds-&gt;d_buf = overlay + ds-&gt;lit_bufsize/sizeof(ush);
+    ds-&gt;l_buf = ds-&gt;pending_buf + (1+sizeof(ush))*ds-&gt;lit_bufsize;
+
+    ds-&gt;l_desc.dyn_tree = ds-&gt;dyn_ltree;
+    ds-&gt;d_desc.dyn_tree = ds-&gt;dyn_dtree;
+    ds-&gt;bl_desc.dyn_tree = ds-&gt;bl_tree;
+
+    return Z_OK;
+#endif /* MAXSEG_64K */
+}
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm-&gt;next_in buffer and copying from it.
+ * (See also flush_pending()).
+ */
+local int read_buf(strm, buf, size)
+    z_streamp strm;
+    Bytef *buf;
+    unsigned size;
+{
+    unsigned len = strm-&gt;avail_in;
+
+    if (len &gt; size) len = size;
+    if (len == 0) return 0;
+
+    strm-&gt;avail_in  -= len;
+
+    if (strm-&gt;state-&gt;wrap == 1) {
+        strm-&gt;adler = adler32(strm-&gt;adler, strm-&gt;next_in, len);
+    }
+#ifdef GZIP
+    else if (strm-&gt;state-&gt;wrap == 2) {
+        strm-&gt;adler = crc32(strm-&gt;adler, strm-&gt;next_in, len);
+    }
+#endif
+    zmemcpy(buf, strm-&gt;next_in, len);
+    strm-&gt;next_in  += len;
+    strm-&gt;total_in += len;
+
+    return (int)len;
+}
+
+/* ===========================================================================
+ * Initialize the &quot;longest match&quot; routines for a new zlib stream
+ */
+local void lm_init (s)
+    deflate_state *s;
+{
+    s-&gt;window_size = (ulg)2L*s-&gt;w_size;
+
+    CLEAR_HASH(s);
+
+    /* Set the default configuration parameters:
+     */
+    s-&gt;max_lazy_match   = configuration_table[s-&gt;level].max_lazy;
+    s-&gt;good_match       = configuration_table[s-&gt;level].good_length;
+    s-&gt;nice_match       = configuration_table[s-&gt;level].nice_length;
+    s-&gt;max_chain_length = configuration_table[s-&gt;level].max_chain;
+
+    s-&gt;strstart = 0;
+    s-&gt;block_start = 0L;
+    s-&gt;lookahead = 0;
+    s-&gt;match_length = s-&gt;prev_length = MIN_MATCH-1;
+    s-&gt;match_available = 0;
+    s-&gt;ins_h = 0;
+#ifndef FASTEST
+#ifdef ASMV
+    match_init(); /* initialize the asm code */
+#endif
+#endif
+}
+
+#ifndef FASTEST
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1
+ * OUT assertion: the match length is not greater than s-&gt;lookahead.
+ */
+#ifndef ASMV
+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
+ * match.S. The code will be functionally equivalent.
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    unsigned chain_length = s-&gt;max_chain_length;/* max hash chain length */
+    register Bytef *scan = s-&gt;window + s-&gt;strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    int best_len = s-&gt;prev_length;              /* best match length so far */
+    int nice_match = s-&gt;nice_match;             /* stop if match long enough */
+    IPos limit = s-&gt;strstart &gt; (IPos)MAX_DIST(s) ?
+        s-&gt;strstart - (IPos)MAX_DIST(s) : NIL;
+    /* Stop when cur_match becomes &lt;= limit. To simplify the code,
+     * we prevent matches with the string of window index 0.
+     */
+    Posf *prev = s-&gt;prev;
+    uInt wmask = s-&gt;w_mask;
+
+#ifdef UNALIGNED_OK
+    /* Compare two bytes at a time. Note: this is not always beneficial.
+     * Try with and without -DUNALIGNED_OK to check.
+     */
+    register Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH - 1;
+    register ush scan_start = *(ushf*)scan;
+    register ush scan_end   = *(ushf*)(scan+best_len-1);
+#else
+    register Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;
+    register Byte scan_end1  = scan[best_len-1];
+    register Byte scan_end   = scan[best_len];
+#endif
+
+    /* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, &quot;Code too clever&quot;);
+
+    /* Do not waste too much time if we already have a good match: */
+    if (s-&gt;prev_length &gt;= s-&gt;good_match) {
+        chain_length &gt;&gt;= 2;
+    }
+    /* Do not look for matches beyond the end of the input. This is necessary
+     * to make deflate deterministic.
+     */
+    if ((uInt)nice_match &gt; s-&gt;lookahead) nice_match = s-&gt;lookahead;
+
+    Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, &quot;need lookahead&quot;);
+
+    do {
+        Assert(cur_match &lt; s-&gt;strstart, &quot;no future&quot;);
+        match = s-&gt;window + cur_match;
+
+        /* Skip to next match if the match length cannot increase
+         * or if the match length is less than 2.  Note that the checks below
+         * for insufficient lookahead only occur occasionally for performance
+         * reasons.  Therefore uninitialized memory will be accessed, and
+         * conditional jumps will be made that depend on those values.
+         * However the length of the match is limited to the lookahead, so
+         * the output of deflate is not affected by the uninitialized values.
+         */
+#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)
+        /* This code assumes sizeof(unsigned short) == 2. Do not use
+         * UNALIGNED_OK if your compiler uses a different size.
+         */
+        if (*(ushf*)(match+best_len-1) != scan_end ||
+            *(ushf*)match != scan_start) continue;
+
+        /* It is not necessary to compare scan[2] and match[2] since they are
+         * always equal when the other bytes match, given that the hash keys
+         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at
+         * strstart+3, +5, ... up to strstart+257. We check for insufficient
+         * lookahead only every 4th comparison; the 128th check will be made
+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
+         * necessary to put more guard bytes at the end of the window, or
+         * to check more often for insufficient lookahead.
+         */
+        Assert(scan[2] == match[2], &quot;scan[2]?&quot;);
+        scan++, match++;
+        do {
+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
+                 scan &lt; strend);
+        /* The funny &quot;do {}&quot; generates better code on most compilers */
+
+        /* Here, scan &lt;= window+strstart+257 */
+        Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);
+        if (*scan == *match) scan++;
+
+        len = (MAX_MATCH - 1) - (int)(strend-scan);
+        scan = strend - (MAX_MATCH-1);
+
+#else /* UNALIGNED_OK */
+
+        if (match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1 ||
+            *match            != *scan     ||
+            *++match          != scan[1])      continue;
+
+        /* The check at best_len-1 can be removed because it will be made
+         * again later. (This heuristic is not always a win.)
+         * It is not necessary to compare scan[2] and match[2] since they
+         * are always equal when the other bytes match, given that
+         * the hash keys are equal and that HASH_BITS &gt;= 8.
+         */
+        scan += 2, match++;
+        Assert(*scan == *match, &quot;match[2]?&quot;);
+
+        /* We check for insufficient lookahead only every 8th comparison;
+         * the 256th check will be made at strstart+258.
+         */
+        do {
+        } while (*++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+                 *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+                 *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+                 *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+                 scan &lt; strend);
+
+        Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);
+
+        len = MAX_MATCH - (int)(strend - scan);
+        scan = strend - MAX_MATCH;
+
+#endif /* UNALIGNED_OK */
+
+        if (len &gt; best_len) {
+            s-&gt;match_start = cur_match;
+            best_len = len;
+            if (len &gt;= nice_match) break;
+#ifdef UNALIGNED_OK
+            scan_end = *(ushf*)(scan+best_len-1);
+#else
+            scan_end1  = scan[best_len-1];
+            scan_end   = scan[best_len];
+#endif
+        }
+    } while ((cur_match = prev[cur_match &amp; wmask]) &gt; limit
+             &amp;&amp; --chain_length != 0);
+
+    if ((uInt)best_len &lt;= s-&gt;lookahead) return (uInt)best_len;
+    return s-&gt;lookahead;
+}
+#endif /* ASMV */
+
+#else /* FASTEST */
+
+/* ---------------------------------------------------------------------------
+ * Optimized version for FASTEST only
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    register Bytef *scan = s-&gt;window + s-&gt;strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    register Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;
+
+    /* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, &quot;Code too clever&quot;);
+
+    Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, &quot;need lookahead&quot;);
+
+    Assert(cur_match &lt; s-&gt;strstart, &quot;no future&quot;);
+
+    match = s-&gt;window + cur_match;
+
+    /* Return failure if the match length is less than 2:
+     */
+    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
+
+    /* The check at best_len-1 can be removed because it will be made
+     * again later. (This heuristic is not always a win.)
+     * It is not necessary to compare scan[2] and match[2] since they
+     * are always equal when the other bytes match, given that
+     * the hash keys are equal and that HASH_BITS &gt;= 8.
+     */
+    scan += 2, match += 2;
+    Assert(*scan == *match, &quot;match[2]?&quot;);
+
+    /* We check for insufficient lookahead only every 8th comparison;
+     * the 256th check will be made at strstart+258.
+     */
+    do {
+    } while (*++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+             *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+             *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+             *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
+             scan &lt; strend);
+
+    Assert(scan &lt;= s-&gt;window+(unsigned)(s-&gt;window_size-1), &quot;wild scan&quot;);
+
+    len = MAX_MATCH - (int)(strend - scan);
+
+    if (len &lt; MIN_MATCH) return MIN_MATCH - 1;
+
+    s-&gt;match_start = cur_match;
+    return (uInt)len &lt;= s-&gt;lookahead ? (uInt)len : s-&gt;lookahead;
+}
+
+#endif /* FASTEST */
+
+#ifdef DEBUG
+/* ===========================================================================
+ * Check that the match at match_start is indeed a match.
+ */
+local void check_match(s, start, match, length)
+    deflate_state *s;
+    IPos start, match;
+    int length;
+{
+    /* check that the match is indeed a match */
+    if (zmemcmp(s-&gt;window + match,
+                s-&gt;window + start, length) != EQUAL) {
+        fprintf(stderr, &quot; start %u, match %u, length %d\n&quot;,
+                start, match, length);
+        do {
+            fprintf(stderr, &quot;%c%c&quot;, s-&gt;window[match++], s-&gt;window[start++]);
+        } while (--length != 0);
+        z_error(&quot;invalid match&quot;);
+    }
+    if (z_verbose &gt; 1) {
+        fprintf(stderr,&quot;\\[%d,%d]&quot;, start-match, length);
+        do { putc(s-&gt;window[start++], stderr); } while (--length != 0);
+    }
+}
+#else
+#  define check_match(s, start, match, length)
+#endif /* DEBUG */
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead &lt; MIN_LOOKAHEAD
+ * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+local void fill_window(s)
+    deflate_state *s;
+{
+    register unsigned n, m;
+    register Posf *p;
+    unsigned more;    /* Amount of free space at the end of the window. */
+    uInt wsize = s-&gt;w_size;
+
+    do {
+        more = (unsigned)(s-&gt;window_size -(ulg)s-&gt;lookahead -(ulg)s-&gt;strstart);
+
+        /* Deal with !@#$% 64K limit: */
+        if (sizeof(int) &lt;= 2) {
+            if (more == 0 &amp;&amp; s-&gt;strstart == 0 &amp;&amp; s-&gt;lookahead == 0) {
+                more = wsize;
+
+            } else if (more == (unsigned)(-1)) {
+                /* Very unlikely, but possible on 16 bit machine if
+                 * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)
+                 */
+                more--;
+            }
+        }
+
+        /* If the window is almost full and there is insufficient lookahead,
+         * move the upper half to the lower one to make room in the upper half.
+         */
+        if (s-&gt;strstart &gt;= wsize+MAX_DIST(s)) {
+
+            zmemcpy(s-&gt;window, s-&gt;window+wsize, (unsigned)wsize);
+            s-&gt;match_start -= wsize;
+            s-&gt;strstart    -= wsize; /* we now have strstart &gt;= MAX_DIST */
+            s-&gt;block_start -= (long) wsize;
+
+            /* Slide the hash table (could be avoided with 32 bit values
+               at the expense of memory usage). We slide even when level == 0
+               to keep the hash table consistent if we switch back to level &gt; 0
+               later. (Using level 0 permanently is not an optimal usage of
+               zlib, so we don't care about this pathological case.)
+             */
+            n = s-&gt;hash_size;
+            p = &amp;s-&gt;head[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m &gt;= wsize ? m-wsize : NIL);
+            } while (--n);
+
+            n = wsize;
+#ifndef FASTEST
+            p = &amp;s-&gt;prev[n];
+            do {
+                m = *--p;
+                *p = (Pos)(m &gt;= wsize ? m-wsize : NIL);
+                /* If n is not on any hash chain, prev[n] is garbage but
+                 * its value will never be used.
+                 */
+            } while (--n);
+#endif
+            more += wsize;
+        }
+        if (s-&gt;strm-&gt;avail_in == 0) return;
+
+        /* If there was no sliding:
+         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
+         *    more == window_size - lookahead - strstart
+         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+         * =&gt; more &gt;= window_size - 2*WSIZE + 2
+         * In the BIG_MEM or MMAP case (not yet supported),
+         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
+         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.
+         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.
+         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.
+         */
+        Assert(more &gt;= 2, &quot;more &lt; 2&quot;);
+
+        n = read_buf(s-&gt;strm, s-&gt;window + s-&gt;strstart + s-&gt;lookahead, more);
+        s-&gt;lookahead += n;
+
+        /* Initialize the hash value now that we have some input: */
+        if (s-&gt;lookahead &gt;= MIN_MATCH) {
+            s-&gt;ins_h = s-&gt;window[s-&gt;strstart];
+            UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[s-&gt;strstart+1]);
+#if MIN_MATCH != 3
+            Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+        }
+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+         * but this is not important since only literal bytes will be emitted.
+         */
+
+    } while (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s-&gt;strm-&gt;avail_in != 0);
+
+    /* If the WIN_INIT bytes after the end of the current data have never been
+     * written, then zero those bytes in order to avoid memory check reports of
+     * the use of uninitialized (or uninitialised as Julian writes) bytes by
+     * the longest match routines.  Update the high water mark for the next
+     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
+     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
+     */
+    if (s-&gt;high_water &lt; s-&gt;window_size) {
+        ulg curr = s-&gt;strstart + (ulg)(s-&gt;lookahead);
+        ulg init;
+
+        if (s-&gt;high_water &lt; curr) {
+            /* Previous high water mark below current data -- zero WIN_INIT
+             * bytes or up to end of window, whichever is less.
+             */
+            init = s-&gt;window_size - curr;
+            if (init &gt; WIN_INIT)
+                init = WIN_INIT;
+            zmemzero(s-&gt;window + curr, (unsigned)init);
+            s-&gt;high_water = curr + init;
+        }
+        else if (s-&gt;high_water &lt; (ulg)curr + WIN_INIT) {
+            /* High water mark at or above current data, but below current data
+             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
+             * to end of window, whichever is less.
+             */
+            init = (ulg)curr + WIN_INIT - s-&gt;high_water;
+            if (init &gt; s-&gt;window_size - s-&gt;high_water)
+                init = s-&gt;window_size - s-&gt;high_water;
+            zmemzero(s-&gt;window + s-&gt;high_water, (unsigned)init);
+            s-&gt;high_water += init;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Flush the current block, with given end-of-file flag.
+ * IN assertion: strstart is set to the end of the current match.
+ */
+#define FLUSH_BLOCK_ONLY(s, last) { \
+   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \
+                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \
+                   (charf *)Z_NULL), \
+                (ulg)((long)s-&gt;strstart - s-&gt;block_start), \
+                (last)); \
+   s-&gt;block_start = s-&gt;strstart; \
+   flush_pending(s-&gt;strm); \
+   Tracev((stderr,&quot;[FLUSH]&quot;)); \
+}
+
+/* Same but force premature exit if necessary. */
+#define FLUSH_BLOCK(s, last) { \
+   FLUSH_BLOCK_ONLY(s, last); \
+   if (s-&gt;strm-&gt;avail_out == 0) return (last) ? finish_started : need_more; \
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+local block_state deflate_stored(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+     * to pending_buf_size, and each stored block has a 5 byte header:
+     */
+    ulg max_block_size = 0xffff;
+    ulg max_start;
+
+    if (max_block_size &gt; s-&gt;pending_buf_size - 5) {
+        max_block_size = s-&gt;pending_buf_size - 5;
+    }
+
+    /* Copy as much as possible from input to output: */
+    for (;;) {
+        /* Fill the window as much as possible: */
+        if (s-&gt;lookahead &lt;= 1) {
+
+            Assert(s-&gt;strstart &lt; s-&gt;w_size+MAX_DIST(s) ||
+                   s-&gt;block_start &gt;= (long)s-&gt;w_size, &quot;slide too late&quot;);
+
+            fill_window(s);
+            if (s-&gt;lookahead == 0 &amp;&amp; flush == Z_NO_FLUSH) return need_more;
+
+            if (s-&gt;lookahead == 0) break; /* flush the current block */
+        }
+        Assert(s-&gt;block_start &gt;= 0L, &quot;block gone&quot;);
+
+        s-&gt;strstart += s-&gt;lookahead;
+        s-&gt;lookahead = 0;
+
+        /* Emit a stored block if pending_buf will be full: */
+        max_start = s-&gt;block_start + max_block_size;
+        if (s-&gt;strstart == 0 || (ulg)s-&gt;strstart &gt;= max_start) {
+            /* strstart == 0 is possible when wraparound on 16-bit machine */
+            s-&gt;lookahead = (uInt)(s-&gt;strstart - max_start);
+            s-&gt;strstart = (uInt)max_start;
+            FLUSH_BLOCK(s, 0);
+        }
+        /* Flush if we may have to slide, otherwise block_start may become
+         * negative and the data will be gone:
+         */
+        if (s-&gt;strstart - (uInt)s-&gt;block_start &gt;= MAX_DIST(s)) {
+            FLUSH_BLOCK(s, 0);
+        }
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+local block_state deflate_fast(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head;       /* head of the hash chain */
+    int bflush;           /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s-&gt;lookahead &lt; MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush == Z_NO_FLUSH) {
+                return need_more;
+            }
+            if (s-&gt;lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        hash_head = NIL;
+        if (s-&gt;lookahead &gt;= MIN_MATCH) {
+            INSERT_STRING(s, s-&gt;strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those &lt;= prev_length.
+         * At this point we have always match_length &lt; MIN_MATCH
+         */
+        if (hash_head != NIL &amp;&amp; s-&gt;strstart - hash_head &lt;= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            s-&gt;match_length = longest_match (s, hash_head);
+            /* longest_match() sets match_start */
+        }
+        if (s-&gt;match_length &gt;= MIN_MATCH) {
+            check_match(s, s-&gt;strstart, s-&gt;match_start, s-&gt;match_length);
+
+            _tr_tally_dist(s, s-&gt;strstart - s-&gt;match_start,
+                           s-&gt;match_length - MIN_MATCH, bflush);
+
+            s-&gt;lookahead -= s-&gt;match_length;
+
+            /* Insert new strings in the hash table only if the match length
+             * is not too large. This saves time but degrades compression.
+             */
+#ifndef FASTEST
+            if (s-&gt;match_length &lt;= s-&gt;max_insert_length &amp;&amp;
+                s-&gt;lookahead &gt;= MIN_MATCH) {
+                s-&gt;match_length--; /* string at strstart already in table */
+                do {
+                    s-&gt;strstart++;
+                    INSERT_STRING(s, s-&gt;strstart, hash_head);
+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                     * always MIN_MATCH bytes ahead.
+                     */
+                } while (--s-&gt;match_length != 0);
+                s-&gt;strstart++;
+            } else
+#endif
+            {
+                s-&gt;strstart += s-&gt;match_length;
+                s-&gt;match_length = 0;
+                s-&gt;ins_h = s-&gt;window[s-&gt;strstart];
+                UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[s-&gt;strstart+1]);
+#if MIN_MATCH != 3
+                Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+                /* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
+                 * matter since it will be recomputed at next deflate call.
+                 */
+            }
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));
+            _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);
+            s-&gt;lookahead--;
+            s-&gt;strstart++;
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+#ifndef FASTEST
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+local block_state deflate_slow(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head;          /* head of hash chain */
+    int bflush;              /* set if current block must be flushed */
+
+    /* Process the input block. */
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s-&gt;lookahead &lt; MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush == Z_NO_FLUSH) {
+                return need_more;
+            }
+            if (s-&gt;lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        hash_head = NIL;
+        if (s-&gt;lookahead &gt;= MIN_MATCH) {
+            INSERT_STRING(s, s-&gt;strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those &lt;= prev_length.
+         */
+        s-&gt;prev_length = s-&gt;match_length, s-&gt;prev_match = s-&gt;match_start;
+        s-&gt;match_length = MIN_MATCH-1;
+
+        if (hash_head != NIL &amp;&amp; s-&gt;prev_length &lt; s-&gt;max_lazy_match &amp;&amp;
+            s-&gt;strstart - hash_head &lt;= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            s-&gt;match_length = longest_match (s, hash_head);
+            /* longest_match() sets match_start */
+
+            if (s-&gt;match_length &lt;= 5 &amp;&amp; (s-&gt;strategy == Z_FILTERED
+#if TOO_FAR &lt;= 32767
+                || (s-&gt;match_length == MIN_MATCH &amp;&amp;
+                    s-&gt;strstart - s-&gt;match_start &gt; TOO_FAR)
+#endif
+                )) {
+
+                /* If prev_match is also MIN_MATCH, match_start is garbage
+                 * but we will ignore the current match anyway.
+                 */
+                s-&gt;match_length = MIN_MATCH-1;
+            }
+        }
+        /* If there was a match at the previous step and the current
+         * match is not better, output the previous match:
+         */
+        if (s-&gt;prev_length &gt;= MIN_MATCH &amp;&amp; s-&gt;match_length &lt;= s-&gt;prev_length) {
+            uInt max_insert = s-&gt;strstart + s-&gt;lookahead - MIN_MATCH;
+            /* Do not insert strings in hash table beyond this. */
+
+            check_match(s, s-&gt;strstart-1, s-&gt;prev_match, s-&gt;prev_length);
+
+            _tr_tally_dist(s, s-&gt;strstart -1 - s-&gt;prev_match,
+                           s-&gt;prev_length - MIN_MATCH, bflush);
+
+            /* Insert in hash table all strings up to the end of the match.
+             * strstart-1 and strstart are already inserted. If there is not
+             * enough lookahead, the last two strings are not inserted in
+             * the hash table.
+             */
+            s-&gt;lookahead -= s-&gt;prev_length-1;
+            s-&gt;prev_length -= 2;
+            do {
+                if (++s-&gt;strstart &lt;= max_insert) {
+                    INSERT_STRING(s, s-&gt;strstart, hash_head);
+                }
+            } while (--s-&gt;prev_length != 0);
+            s-&gt;match_available = 0;
+            s-&gt;match_length = MIN_MATCH-1;
+            s-&gt;strstart++;
+
+            if (bflush) FLUSH_BLOCK(s, 0);
+
+        } else if (s-&gt;match_available) {
+            /* If there was no match at the previous position, output a
+             * single literal. If there was a match but the current match
+             * is longer, truncate the previous match to a single literal.
+             */
+            Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart-1]));
+            _tr_tally_lit(s, s-&gt;window[s-&gt;strstart-1], bflush);
+            if (bflush) {
+                FLUSH_BLOCK_ONLY(s, 0);
+            }
+            s-&gt;strstart++;
+            s-&gt;lookahead--;
+            if (s-&gt;strm-&gt;avail_out == 0) return need_more;
+        } else {
+            /* There is no previous match to compare with, wait for
+             * the next step to decide.
+             */
+            s-&gt;match_available = 1;
+            s-&gt;strstart++;
+            s-&gt;lookahead--;
+        }
+    }
+    Assert (flush != Z_NO_FLUSH, &quot;no flush?&quot;);
+    if (s-&gt;match_available) {
+        Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart-1]));
+        _tr_tally_lit(s, s-&gt;window[s-&gt;strstart-1], bflush);
+        s-&gt;match_available = 0;
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+#endif /* FASTEST */
+
+/* ===========================================================================
+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance
+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of
+ * deflate switches away from Z_RLE.)
+ */
+local block_state deflate_rle(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    int bflush;             /* set if current block must be flushed */
+    uInt prev;              /* byte at distance one to match */
+    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the longest encodable run.
+         */
+        if (s-&gt;lookahead &lt; MAX_MATCH) {
+            fill_window(s);
+            if (s-&gt;lookahead &lt; MAX_MATCH &amp;&amp; flush == Z_NO_FLUSH) {
+                return need_more;
+            }
+            if (s-&gt;lookahead == 0) break; /* flush the current block */
+        }
+
+        /* See how many times the previous byte repeats */
+        s-&gt;match_length = 0;
+        if (s-&gt;lookahead &gt;= MIN_MATCH &amp;&amp; s-&gt;strstart &gt; 0) {
+            scan = s-&gt;window + s-&gt;strstart - 1;
+            prev = *scan;
+            if (prev == *++scan &amp;&amp; prev == *++scan &amp;&amp; prev == *++scan) {
+                strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;
+                do {
+                } while (prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;
+                         prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;
+                         prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;
+                         prev == *++scan &amp;&amp; prev == *++scan &amp;&amp;
+                         scan &lt; strend);
+                s-&gt;match_length = MAX_MATCH - (int)(strend - scan);
+                if (s-&gt;match_length &gt; s-&gt;lookahead)
+                    s-&gt;match_length = s-&gt;lookahead;
+            }
+        }
+
+        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
+        if (s-&gt;match_length &gt;= MIN_MATCH) {
+            check_match(s, s-&gt;strstart, s-&gt;strstart - 1, s-&gt;match_length);
+
+            _tr_tally_dist(s, 1, s-&gt;match_length - MIN_MATCH, bflush);
+
+            s-&gt;lookahead -= s-&gt;match_length;
+            s-&gt;strstart += s-&gt;match_length;
+            s-&gt;match_length = 0;
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));
+            _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);
+            s-&gt;lookahead--;
+            s-&gt;strstart++;
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
+ * (It will be regenerated if this run of deflate switches away from Huffman.)
+ */
+local block_state deflate_huff(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    int bflush;             /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we have a literal to write. */
+        if (s-&gt;lookahead == 0) {
+            fill_window(s);
+            if (s-&gt;lookahead == 0) {
+                if (flush == Z_NO_FLUSH)
+                    return need_more;
+                break;      /* flush the current block */
+            }
+        }
+
+        /* Output a literal byte */
+        s-&gt;match_length = 0;
+        Tracevv((stderr,&quot;%c&quot;, s-&gt;window[s-&gt;strstart]));
+        _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);
+        s-&gt;lookahead--;
+        s-&gt;strstart++;
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/deflate.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/deflate.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/deflate.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,342 @@
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995-2010 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id$ */
+
+#ifndef DEFLATE_H
+#define DEFLATE_H
+
+#include &quot;zutil.h&quot;
+
+/* define NO_GZIP when compiling if you want to disable gzip header and
+   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
+   the crc code when it is not needed.  For shared libraries, gzip encoding
+   should be left enabled. */
+#ifndef NO_GZIP
+#  define GZIP
+#endif
+
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+#define LENGTH_CODES 29
+/* number of length codes, not counting the special END_BLOCK code */
+
+#define LITERALS  256
+/* number of literal bytes 0..255 */
+
+#define L_CODES (LITERALS+1+LENGTH_CODES)
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+#define D_CODES   30
+/* number of distance codes */
+
+#define BL_CODES  19
+/* number of codes used to transfer the bit lengths */
+
+#define HEAP_SIZE (2*L_CODES+1)
+/* maximum heap size */
+
+#define MAX_BITS 15
+/* All codes must not exceed MAX_BITS bits */
+
+#define INIT_STATE    42
+#define EXTRA_STATE   69
+#define NAME_STATE    73
+#define COMMENT_STATE 91
+#define HCRC_STATE   103
+#define BUSY_STATE   113
+#define FINISH_STATE 666
+/* Stream status */
+
+
+/* Data structure describing a single value and its code string. */
+typedef struct ct_data_s {
+    union {
+        ush  freq;       /* frequency count */
+        ush  code;       /* bit string */
+    } fc;
+    union {
+        ush  dad;        /* father node in Huffman tree */
+        ush  len;        /* length of bit string */
+    } dl;
+} FAR ct_data;
+
+#define Freq fc.freq
+#define Code fc.code
+#define Dad  dl.dad
+#define Len  dl.len
+
+typedef struct static_tree_desc_s  static_tree_desc;
+
+typedef struct tree_desc_s {
+    ct_data *dyn_tree;           /* the dynamic tree */
+    int     max_code;            /* largest code with non zero frequency */
+    static_tree_desc *stat_desc; /* the corresponding static tree */
+} FAR tree_desc;
+
+typedef ush Pos;
+typedef Pos FAR Posf;
+typedef unsigned IPos;
+
+/* A Pos is an index in the character window. We use short instead of int to
+ * save space in the various tables. IPos is used only for parameter passing.
+ */
+
+typedef struct internal_state {
+    z_streamp strm;      /* pointer back to this zlib stream */
+    int   status;        /* as the name implies */
+    Bytef *pending_buf;  /* output still pending */
+    ulg   pending_buf_size; /* size of pending_buf */
+    Bytef *pending_out;  /* next pending byte to output to the stream */
+    uInt   pending;      /* nb of bytes in the pending buffer */
+    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
+    gz_headerp  gzhead;  /* gzip header information to write */
+    uInt   gzindex;      /* where in extra, name, or comment */
+    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    int   last_flush;    /* value of flush param for previous deflate call */
+
+                /* used by deflate.c: */
+
+    uInt  w_size;        /* LZ77 window size (32K by default) */
+    uInt  w_bits;        /* log2(w_size)  (8..16) */
+    uInt  w_mask;        /* w_size - 1 */
+
+    Bytef *window;
+    /* Sliding window. Input bytes are read into the second half of the window,
+     * and move to the first half later to keep a dictionary of at least wSize
+     * bytes. With this organization, matches are limited to a distance of
+     * wSize-MAX_MATCH bytes, but this ensures that IO is always
+     * performed with a length multiple of the block size. Also, it limits
+     * the window size to 64K, which is quite useful on MSDOS.
+     * To do: use the user input buffer as sliding window.
+     */
+
+    ulg window_size;
+    /* Actual size of window: 2*wSize, except when the user input buffer
+     * is directly used as sliding window.
+     */
+
+    Posf *prev;
+    /* Link to older string with same hash index. To limit the size of this
+     * array to 64K, this link is maintained only for the last 32K strings.
+     * An index in this array is thus a window index modulo 32K.
+     */
+
+    Posf *head; /* Heads of the hash chains or NIL. */
+
+    uInt  ins_h;          /* hash index of string to be inserted */
+    uInt  hash_size;      /* number of elements in hash table */
+    uInt  hash_bits;      /* log2(hash_size) */
+    uInt  hash_mask;      /* hash_size-1 */
+
+    uInt  hash_shift;
+    /* Number of bits by which ins_h must be shifted at each input
+     * step. It must be such that after MIN_MATCH steps, the oldest
+     * byte no longer takes part in the hash key, that is:
+     *   hash_shift * MIN_MATCH &gt;= hash_bits
+     */
+
+    long block_start;
+    /* Window position at the beginning of the current output block. Gets
+     * negative when the window is moved backwards.
+     */
+
+    uInt match_length;           /* length of best match */
+    IPos prev_match;             /* previous match */
+    int match_available;         /* set if previous match exists */
+    uInt strstart;               /* start of string to insert */
+    uInt match_start;            /* start of matching string */
+    uInt lookahead;              /* number of valid bytes ahead in window */
+
+    uInt prev_length;
+    /* Length of the best match at previous step. Matches not greater than this
+     * are discarded. This is used in the lazy match evaluation.
+     */
+
+    uInt max_chain_length;
+    /* To speed up deflation, hash chains are never searched beyond this
+     * length.  A higher limit improves compression ratio but degrades the
+     * speed.
+     */
+
+    uInt max_lazy_match;
+    /* Attempt to find a better match only when the current match is strictly
+     * smaller than this value. This mechanism is used only for compression
+     * levels &gt;= 4.
+     */
+#   define max_insert_length  max_lazy_match
+    /* Insert new strings in the hash table only if the match length is not
+     * greater than this length. This saves time but degrades compression.
+     * max_insert_length is used only for compression levels &lt;= 3.
+     */
+
+    int level;    /* compression level (1..9) */
+    int strategy; /* favor or force Huffman coding*/
+
+    uInt good_match;
+    /* Use a faster search when the previous match is longer than this */
+
+    int nice_match; /* Stop searching when current match exceeds this */
+
+                /* used by trees.c: */
+    /* Didn't use ct_data typedef below to supress compiler warning */
+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+    struct tree_desc_s l_desc;               /* desc. for literal tree */
+    struct tree_desc_s d_desc;               /* desc. for distance tree */
+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
+
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+    int heap_len;               /* number of elements in the heap */
+    int heap_max;               /* element of largest frequency */
+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+     * The same heap array is used to build all trees.
+     */
+
+    uch depth[2*L_CODES+1];
+    /* Depth of each subtree used as tie breaker for trees of equal frequency
+     */
+
+    uchf *l_buf;          /* buffer for literals or lengths */
+
+    uInt  lit_bufsize;
+    /* Size of match buffer for literals/lengths.  There are 4 reasons for
+     * limiting lit_bufsize to 64K:
+     *   - frequencies can be kept in 16 bit counters
+     *   - if compression is not successful for the first block, all input
+     *     data is still in the window so we can still emit a stored block even
+     *     when input comes from standard input.  (This can also be done for
+     *     all blocks if lit_bufsize is not greater than 32K.)
+     *   - if compression is not successful for a file smaller than 64K, we can
+     *     even emit a stored file instead of a stored block (saving 5 bytes).
+     *     This is applicable only for zip (not gzip or zlib).
+     *   - creating new Huffman trees less frequently may not provide fast
+     *     adaptation to changes in the input data statistics. (Take for
+     *     example a binary file with poorly compressible code followed by
+     *     a highly compressible string table.) Smaller buffer sizes give
+     *     fast adaptation but have of course the overhead of transmitting
+     *     trees more frequently.
+     *   - I can't count above 4
+     */
+
+    uInt last_lit;      /* running index in l_buf */
+
+    ushf *d_buf;
+    /* Buffer for distances. To simplify the code, d_buf and l_buf have
+     * the same number of elements. To use different lengths, an extra flag
+     * array would be necessary.
+     */
+
+    ulg opt_len;        /* bit length of current block with optimal trees */
+    ulg static_len;     /* bit length of current block with static trees */
+    uInt matches;       /* number of string matches in current block */
+    int last_eob_len;   /* bit length of EOB code for last block */
+
+#ifdef DEBUG
+    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
+    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
+#endif
+
+    ush bi_buf;
+    /* Output buffer. bits are inserted starting at the bottom (least
+     * significant bits).
+     */
+    int bi_valid;
+    /* Number of valid bits in bi_buf.  All bits above the last valid bit
+     * are always zero.
+     */
+
+    ulg high_water;
+    /* High water mark offset in window for initialized bytes -- bytes above
+     * this are set to zero in order to avoid memory check warnings when
+     * longest match routines access bytes past the input.  This is then
+     * updated to the new high water mark.
+     */
+
+} FAR deflate_state;
+
+/* Output a byte on the stream.
+ * IN assertion: there is enough room in pending_buf.
+ */
+#define put_byte(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (c);}
+
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+#define MAX_DIST(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)
+/* In order to simplify the code, particularly on 16 bit machines, match
+ * distances are limited to MAX_DIST instead of WSIZE.
+ */
+
+#define WIN_INIT MAX_MATCH
+/* Number of bytes after end of data in window to initialize in order to avoid
+   memory checker errors from longest match routines */
+
+        /* in trees.c */
+void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
+int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
+void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
+                        ulg stored_len, int last));
+void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
+void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
+                        ulg stored_len, int last));
+
+#define d_code(dist) \
+   ((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256+((dist)&gt;&gt;7)])
+/* Mapping from a distance to a distance code. dist is the distance - 1 and
+ * must not have side effects. _dist_code[256] and _dist_code[257] are never
+ * used.
+ */
+
+#ifndef DEBUG
+/* Inline versions of _tr_tally for speed: */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+  extern uch ZLIB_INTERNAL _length_code[];
+  extern uch ZLIB_INTERNAL _dist_code[];
+#else
+  extern const uch ZLIB_INTERNAL _length_code[];
+  extern const uch ZLIB_INTERNAL _dist_code[];
+#endif
+
+# define _tr_tally_lit(s, c, flush) \
+  { uch cc = (c); \
+    s-&gt;d_buf[s-&gt;last_lit] = 0; \
+    s-&gt;l_buf[s-&gt;last_lit++] = cc; \
+    s-&gt;dyn_ltree[cc].Freq++; \
+    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
+   }
+# define _tr_tally_dist(s, distance, length, flush) \
+  { uch len = (length); \
+    ush dist = (distance); \
+    s-&gt;d_buf[s-&gt;last_lit] = dist; \
+    s-&gt;l_buf[s-&gt;last_lit++] = len; \
+    dist--; \
+    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
+    s-&gt;dyn_dtree[d_code(dist)].Freq++; \
+    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \
+  }
+#else
+# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
+# define _tr_tally_dist(s, distance, length, flush) \
+              flush = _tr_tally(s, distance, length)
+#endif
+
+#endif /* DEFLATE_H */

Added: Lobby/TASClient/LobbyComponents/delphizlib/deflate.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/deflate.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/infback.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/infback.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/infback.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,632 @@
+/* infback.c -- inflate using a call-back interface
+ * Copyright (C) 1995-2009 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+   This code is largely copied from inflate.c.  Normally either infback.o or
+   inflate.o would be linked into an application--not both.  The interface
+   with inffast.c is retained so that optimized assembler-coded versions of
+   inflate_fast() can be used with either inflate.c or infback.c.
+ */
+
+#include &quot;zutil.h&quot;
+#include &quot;inftrees.h&quot;
+#include &quot;inflate.h&quot;
+#include &quot;inffast.h&quot;
+
+/* function prototypes */
+local void fixedtables OF((struct inflate_state FAR *state));
+
+/*
+   strm provides memory allocation functions in zalloc and zfree, or
+   Z_NULL to use the library memory allocation functions.
+
+   windowBits is in the range 8..15, and window is a user-supplied
+   window and output buffer that is 2**windowBits bytes.
+ */
+int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
+z_streamp strm;
+int windowBits;
+unsigned char FAR *window;
+const char *version;
+int stream_size;
+{
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL || window == Z_NULL ||
+        windowBits &lt; 8 || windowBits &gt; 15)
+        return Z_STREAM_ERROR;
+    strm-&gt;msg = Z_NULL;                 /* in case we return an error */
+    if (strm-&gt;zalloc == (alloc_func)0) {
+        strm-&gt;zalloc = zcalloc;
+        strm-&gt;opaque = (voidpf)0;
+    }
+    if (strm-&gt;zfree == (free_func)0) strm-&gt;zfree = zcfree;
+    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
+                                               sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, &quot;inflate: allocated\n&quot;));
+    strm-&gt;state = (struct internal_state FAR *)state;
+    state-&gt;dmax = 32768U;
+    state-&gt;wbits = windowBits;
+    state-&gt;wsize = 1U &lt;&lt; windowBits;
+    state-&gt;window = window;
+    state-&gt;wnext = 0;
+    state-&gt;whave = 0;
+    return Z_OK;
+}
+
+/*
+   Return state with length and distance decoding tables and index sizes set to
+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
+   If BUILDFIXED is defined, then instead this routine builds the tables the
+   first time it's called, and returns those tables the first time and
+   thereafter.  This reduces the size of the code by about 2K bytes, in
+   exchange for a little execution time.  However, BUILDFIXED should not be
+   used for threaded applications, since the rewriting of the tables and virgin
+   may not be thread-safe.
+ */
+local void fixedtables(state)
+struct inflate_state FAR *state;
+{
+#ifdef BUILDFIXED
+    static int virgin = 1;
+    static code *lenfix, *distfix;
+    static code fixed[544];
+
+    /* build fixed huffman tables if first call (may not be thread safe) */
+    if (virgin) {
+        unsigned sym, bits;
+        static code *next;
+
+        /* literal/length table */
+        sym = 0;
+        while (sym &lt; 144) state-&gt;lens[sym++] = 8;
+        while (sym &lt; 256) state-&gt;lens[sym++] = 9;
+        while (sym &lt; 280) state-&gt;lens[sym++] = 7;
+        while (sym &lt; 288) state-&gt;lens[sym++] = 8;
+        next = fixed;
+        lenfix = next;
+        bits = 9;
+        inflate_table(LENS, state-&gt;lens, 288, &amp;(next), &amp;(bits), state-&gt;work);
+
+        /* distance table */
+        sym = 0;
+        while (sym &lt; 32) state-&gt;lens[sym++] = 5;
+        distfix = next;
+        bits = 5;
+        inflate_table(DISTS, state-&gt;lens, 32, &amp;(next), &amp;(bits), state-&gt;work);
+
+        /* do this just once */
+        virgin = 0;
+    }
+#else /* !BUILDFIXED */
+#   include &quot;inffixed.h&quot;
+#endif /* BUILDFIXED */
+    state-&gt;lencode = lenfix;
+    state-&gt;lenbits = 9;
+    state-&gt;distcode = distfix;
+    state-&gt;distbits = 5;
+}
+
+/* Macros for inflateBack(): */
+
+/* Load returned state from inflate_fast() */
+#define LOAD() \
+    do { \
+        put = strm-&gt;next_out; \
+        left = strm-&gt;avail_out; \
+        next = strm-&gt;next_in; \
+        have = strm-&gt;avail_in; \
+        hold = state-&gt;hold; \
+        bits = state-&gt;bits; \
+    } while (0)
+
+/* Set state from registers for inflate_fast() */
+#define RESTORE() \
+    do { \
+        strm-&gt;next_out = put; \
+        strm-&gt;avail_out = left; \
+        strm-&gt;next_in = next; \
+        strm-&gt;avail_in = have; \
+        state-&gt;hold = hold; \
+        state-&gt;bits = bits; \
+    } while (0)
+
+/* Clear the input bit accumulator */
+#define INITBITS() \
+    do { \
+        hold = 0; \
+        bits = 0; \
+    } while (0)
+
+/* Assure that some input is available.  If input is requested, but denied,
+   then return a Z_BUF_ERROR from inflateBack(). */
+#define PULL() \
+    do { \
+        if (have == 0) { \
+            have = in(in_desc, &amp;next); \
+            if (have == 0) { \
+                next = Z_NULL; \
+                ret = Z_BUF_ERROR; \
+                goto inf_leave; \
+            } \
+        } \
+    } while (0)
+
+/* Get a byte of input into the bit accumulator, or return from inflateBack()
+   with an error if there is no input available. */
+#define PULLBYTE() \
+    do { \
+        PULL(); \
+        have--; \
+        hold += (unsigned long)(*next++) &lt;&lt; bits; \
+        bits += 8; \
+    } while (0)
+
+/* Assure that there are at least n bits in the bit accumulator.  If there is
+   not enough available input to do that, then return from inflateBack() with
+   an error. */
+#define NEEDBITS(n) \
+    do { \
+        while (bits &lt; (unsigned)(n)) \
+            PULLBYTE(); \
+    } while (0)
+
+/* Return the low n bits of the bit accumulator (n &lt; 16) */
+#define BITS(n) \
+    ((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))
+
+/* Remove n bits from the bit accumulator */
+#define DROPBITS(n) \
+    do { \
+        hold &gt;&gt;= (n); \
+        bits -= (unsigned)(n); \
+    } while (0)
+
+/* Remove zero to seven bits as needed to go to a byte boundary */
+#define BYTEBITS() \
+    do { \
+        hold &gt;&gt;= bits &amp; 7; \
+        bits -= bits &amp; 7; \
+    } while (0)
+
+/* Assure that some output space is available, by writing out the window
+   if it's full.  If the write fails, return from inflateBack() with a
+   Z_BUF_ERROR. */
+#define ROOM() \
+    do { \
+        if (left == 0) { \
+            put = state-&gt;window; \
+            left = state-&gt;wsize; \
+            state-&gt;whave = left; \
+            if (out(out_desc, put, left)) { \
+                ret = Z_BUF_ERROR; \
+                goto inf_leave; \
+            } \
+        } \
+    } while (0)
+
+/*
+   strm provides the memory allocation functions and window buffer on input,
+   and provides information on the unused input on return.  For Z_DATA_ERROR
+   returns, strm will also provide an error message.
+
+   in() and out() are the call-back input and output functions.  When
+   inflateBack() needs more input, it calls in().  When inflateBack() has
+   filled the window with output, or when it completes with data in the
+   window, it calls out() to write out the data.  The application must not
+   change the provided input until in() is called again or inflateBack()
+   returns.  The application must not change the window/output buffer until
+   inflateBack() returns.
+
+   in() and out() are called with a descriptor parameter provided in the
+   inflateBack() call.  This parameter can be a structure that provides the
+   information required to do the read or write, as well as accumulated
+   information on the input and output such as totals and check values.
+
+   in() should return zero on failure.  out() should return non-zero on
+   failure.  If either in() or out() fails, than inflateBack() returns a
+   Z_BUF_ERROR.  strm-&gt;next_in can be checked for Z_NULL to see whether it
+   was in() or out() that caused in the error.  Otherwise,  inflateBack()
+   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
+   error, or Z_MEM_ERROR if it could not allocate memory for the state.
+   inflateBack() can also return Z_STREAM_ERROR if the input parameters
+   are not correct, i.e. strm is Z_NULL or the state was not initialized.
+ */
+int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
+z_streamp strm;
+in_func in;
+void FAR *in_desc;
+out_func out;
+void FAR *out_desc;
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned char FAR *from;    /* where to copy match bytes from */
+    code here;                  /* current decoding table entry */
+    code last;                  /* parent table entry */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+    static const unsigned short order[19] = /* permutation of code lengths */
+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    /* Check that the strm exists and that the state was initialized */
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+
+    /* Reset the state */
+    strm-&gt;msg = Z_NULL;
+    state-&gt;mode = TYPE;
+    state-&gt;last = 0;
+    state-&gt;whave = 0;
+    next = strm-&gt;next_in;
+    have = next != Z_NULL ? strm-&gt;avail_in : 0;
+    hold = 0;
+    bits = 0;
+    put = state-&gt;window;
+    left = state-&gt;wsize;
+
+    /* Inflate until end of block marked as last */
+    for (;;)
+        switch (state-&gt;mode) {
+        case TYPE:
+            /* determine and dispatch block type */
+            if (state-&gt;last) {
+                BYTEBITS();
+                state-&gt;mode = DONE;
+                break;
+            }
+            NEEDBITS(3);
+            state-&gt;last = BITS(1);
+            DROPBITS(1);
+            switch (BITS(2)) {
+            case 0:                             /* stored block */
+                Tracev((stderr, &quot;inflate:     stored block%s\n&quot;,
+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));
+                state-&gt;mode = STORED;
+                break;
+            case 1:                             /* fixed block */
+                fixedtables(state);
+                Tracev((stderr, &quot;inflate:     fixed codes block%s\n&quot;,
+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));
+                state-&gt;mode = LEN;              /* decode codes */
+                break;
+            case 2:                             /* dynamic block */
+                Tracev((stderr, &quot;inflate:     dynamic codes block%s\n&quot;,
+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));
+                state-&gt;mode = TABLE;
+                break;
+            case 3:
+                strm-&gt;msg = (char *)&quot;invalid block type&quot;;
+                state-&gt;mode = BAD;
+            }
+            DROPBITS(2);
+            break;
+
+        case STORED:
+            /* get and verify stored block length */
+            BYTEBITS();                         /* go to byte boundary */
+            NEEDBITS(32);
+            if ((hold &amp; 0xffff) != ((hold &gt;&gt; 16) ^ 0xffff)) {
+                strm-&gt;msg = (char *)&quot;invalid stored block lengths&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;length = (unsigned)hold &amp; 0xffff;
+            Tracev((stderr, &quot;inflate:       stored length %u\n&quot;,
+                    state-&gt;length));
+            INITBITS();
+
+            /* copy stored block from input to output */
+            while (state-&gt;length != 0) {
+                copy = state-&gt;length;
+                PULL();
+                ROOM();
+                if (copy &gt; have) copy = have;
+                if (copy &gt; left) copy = left;
+                zmemcpy(put, next, copy);
+                have -= copy;
+                next += copy;
+                left -= copy;
+                put += copy;
+                state-&gt;length -= copy;
+            }
+            Tracev((stderr, &quot;inflate:       stored end\n&quot;));
+            state-&gt;mode = TYPE;
+            break;
+
+        case TABLE:
+            /* get dynamic table entries descriptor */
+            NEEDBITS(14);
+            state-&gt;nlen = BITS(5) + 257;
+            DROPBITS(5);
+            state-&gt;ndist = BITS(5) + 1;
+            DROPBITS(5);
+            state-&gt;ncode = BITS(4) + 4;
+            DROPBITS(4);
+#ifndef PKZIP_BUG_WORKAROUND
+            if (state-&gt;nlen &gt; 286 || state-&gt;ndist &gt; 30) {
+                strm-&gt;msg = (char *)&quot;too many length or distance symbols&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+#endif
+            Tracev((stderr, &quot;inflate:       table sizes ok\n&quot;));
+
+            /* get code length code lengths (not a typo) */
+            state-&gt;have = 0;
+            while (state-&gt;have &lt; state-&gt;ncode) {
+                NEEDBITS(3);
+                state-&gt;lens[order[state-&gt;have++]] = (unsigned short)BITS(3);
+                DROPBITS(3);
+            }
+            while (state-&gt;have &lt; 19)
+                state-&gt;lens[order[state-&gt;have++]] = 0;
+            state-&gt;next = state-&gt;codes;
+            state-&gt;lencode = (code const FAR *)(state-&gt;next);
+            state-&gt;lenbits = 7;
+            ret = inflate_table(CODES, state-&gt;lens, 19, &amp;(state-&gt;next),
+                                &amp;(state-&gt;lenbits), state-&gt;work);
+            if (ret) {
+                strm-&gt;msg = (char *)&quot;invalid code lengths set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            Tracev((stderr, &quot;inflate:       code lengths ok\n&quot;));
+
+            /* get length and distance code code lengths */
+            state-&gt;have = 0;
+            while (state-&gt;have &lt; state-&gt;nlen + state-&gt;ndist) {
+                for (;;) {
+                    here = state-&gt;lencode[BITS(state-&gt;lenbits)];
+                    if ((unsigned)(here.bits) &lt;= bits) break;
+                    PULLBYTE();
+                }
+                if (here.val &lt; 16) {
+                    NEEDBITS(here.bits);
+                    DROPBITS(here.bits);
+                    state-&gt;lens[state-&gt;have++] = here.val;
+                }
+                else {
+                    if (here.val == 16) {
+                        NEEDBITS(here.bits + 2);
+                        DROPBITS(here.bits);
+                        if (state-&gt;have == 0) {
+                            strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;
+                            state-&gt;mode = BAD;
+                            break;
+                        }
+                        len = (unsigned)(state-&gt;lens[state-&gt;have - 1]);
+                        copy = 3 + BITS(2);
+                        DROPBITS(2);
+                    }
+                    else if (here.val == 17) {
+                        NEEDBITS(here.bits + 3);
+                        DROPBITS(here.bits);
+                        len = 0;
+                        copy = 3 + BITS(3);
+                        DROPBITS(3);
+                    }
+                    else {
+                        NEEDBITS(here.bits + 7);
+                        DROPBITS(here.bits);
+                        len = 0;
+                        copy = 11 + BITS(7);
+                        DROPBITS(7);
+                    }
+                    if (state-&gt;have + copy &gt; state-&gt;nlen + state-&gt;ndist) {
+                        strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;
+                        state-&gt;mode = BAD;
+                        break;
+                    }
+                    while (copy--)
+                        state-&gt;lens[state-&gt;have++] = (unsigned short)len;
+                }
+            }
+
+            /* handle error breaks in while */
+            if (state-&gt;mode == BAD) break;
+
+            /* check for end-of-block code (better have one) */
+            if (state-&gt;lens[256] == 0) {
+                strm-&gt;msg = (char *)&quot;invalid code -- missing end-of-block&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+
+            /* build code tables -- note: do not change the lenbits or distbits
+               values here (9 and 6) without reading the comments in inftrees.h
+               concerning the ENOUGH constants, which depend on those values */
+            state-&gt;next = state-&gt;codes;
+            state-&gt;lencode = (code const FAR *)(state-&gt;next);
+            state-&gt;lenbits = 9;
+            ret = inflate_table(LENS, state-&gt;lens, state-&gt;nlen, &amp;(state-&gt;next),
+                                &amp;(state-&gt;lenbits), state-&gt;work);
+            if (ret) {
+                strm-&gt;msg = (char *)&quot;invalid literal/lengths set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;distcode = (code const FAR *)(state-&gt;next);
+            state-&gt;distbits = 6;
+            ret = inflate_table(DISTS, state-&gt;lens + state-&gt;nlen, state-&gt;ndist,
+                            &amp;(state-&gt;next), &amp;(state-&gt;distbits), state-&gt;work);
+            if (ret) {
+                strm-&gt;msg = (char *)&quot;invalid distances set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            Tracev((stderr, &quot;inflate:       codes ok\n&quot;));
+            state-&gt;mode = LEN;
+
+        case LEN:
+            /* use inflate_fast() if we have enough input and output */
+            if (have &gt;= 6 &amp;&amp; left &gt;= 258) {
+                RESTORE();
+                if (state-&gt;whave &lt; state-&gt;wsize)
+                    state-&gt;whave = state-&gt;wsize - left;
+                inflate_fast(strm, state-&gt;wsize);
+                LOAD();
+                break;
+            }
+
+            /* get a literal, length, or end-of-block code */
+            for (;;) {
+                here = state-&gt;lencode[BITS(state-&gt;lenbits)];
+                if ((unsigned)(here.bits) &lt;= bits) break;
+                PULLBYTE();
+            }
+            if (here.op &amp;&amp; (here.op &amp; 0xf0) == 0) {
+                last = here;
+                for (;;) {
+                    here = state-&gt;lencode[last.val +
+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];
+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(here.bits);
+            state-&gt;length = (unsigned)here.val;
+
+            /* process literal */
+            if (here.op == 0) {
+                Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
+                        &quot;inflate:         literal '%c'\n&quot; :
+                        &quot;inflate:         literal 0x%02x\n&quot;, here.val));
+                ROOM();
+                *put++ = (unsigned char)(state-&gt;length);
+                left--;
+                state-&gt;mode = LEN;
+                break;
+            }
+
+            /* process end of block */
+            if (here.op &amp; 32) {
+                Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
+                state-&gt;mode = TYPE;
+                break;
+            }
+
+            /* invalid code */
+            if (here.op &amp; 64) {
+                strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+
+            /* length code -- get extra bits, if any */
+            state-&gt;extra = (unsigned)(here.op) &amp; 15;
+            if (state-&gt;extra != 0) {
+                NEEDBITS(state-&gt;extra);
+                state-&gt;length += BITS(state-&gt;extra);
+                DROPBITS(state-&gt;extra);
+            }
+            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, state-&gt;length));
+
+            /* get distance code */
+            for (;;) {
+                here = state-&gt;distcode[BITS(state-&gt;distbits)];
+                if ((unsigned)(here.bits) &lt;= bits) break;
+                PULLBYTE();
+            }
+            if ((here.op &amp; 0xf0) == 0) {
+                last = here;
+                for (;;) {
+                    here = state-&gt;distcode[last.val +
+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];
+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+            }
+            DROPBITS(here.bits);
+            if (here.op &amp; 64) {
+                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;offset = (unsigned)here.val;
+
+            /* get distance extra bits, if any */
+            state-&gt;extra = (unsigned)(here.op) &amp; 15;
+            if (state-&gt;extra != 0) {
+                NEEDBITS(state-&gt;extra);
+                state-&gt;offset += BITS(state-&gt;extra);
+                DROPBITS(state-&gt;extra);
+            }
+            if (state-&gt;offset &gt; state-&gt;wsize - (state-&gt;whave &lt; state-&gt;wsize ?
+                                                left : 0)) {
+                strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, state-&gt;offset));
+
+            /* copy match from window to output */
+            do {
+                ROOM();
+                copy = state-&gt;wsize - state-&gt;offset;
+                if (copy &lt; left) {
+                    from = put + copy;
+                    copy = left - copy;
+                }
+                else {
+                    from = put - state-&gt;offset;
+                    copy = left;
+                }
+                if (copy &gt; state-&gt;length) copy = state-&gt;length;
+                state-&gt;length -= copy;
+                left -= copy;
+                do {
+                    *put++ = *from++;
+                } while (--copy);
+            } while (state-&gt;length != 0);
+            break;
+
+        case DONE:
+            /* inflate stream terminated properly -- write leftover output */
+            ret = Z_STREAM_END;
+            if (left &lt; state-&gt;wsize) {
+                if (out(out_desc, state-&gt;window, state-&gt;wsize - left))
+                    ret = Z_BUF_ERROR;
+            }
+            goto inf_leave;
+
+        case BAD:
+            ret = Z_DATA_ERROR;
+            goto inf_leave;
+
+        default:                /* can't happen, but makes compilers happy */
+            ret = Z_STREAM_ERROR;
+            goto inf_leave;
+        }
+
+    /* Return unused input */
+  inf_leave:
+    strm-&gt;next_in = next;
+    strm-&gt;avail_in = have;
+    return ret;
+}
+
+int ZEXPORT inflateBackEnd(strm)
+z_streamp strm;
+{
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL || strm-&gt;zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    ZFREE(strm, strm-&gt;state);
+    strm-&gt;state = Z_NULL;
+    Tracev((stderr, &quot;inflate: end\n&quot;));
+    return Z_OK;
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/infback.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/infback.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/inffast.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inffast.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inffast.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,340 @@
+/* inffast.c -- fast decoding
+ * Copyright (C) 1995-2008, 2010 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#include &quot;zutil.h&quot;
+#include &quot;inftrees.h&quot;
+#include &quot;inflate.h&quot;
+#include &quot;inffast.h&quot;
+
+#ifndef ASMINF
+
+/* Allow machine dependent optimization for post-increment or pre-increment.
+   Based on testing to date,
+   Pre-increment preferred for:
+   - PowerPC G3 (Adler)
+   - MIPS R5000 (Randers-Pehrson)
+   Post-increment preferred for:
+   - none
+   No measurable difference:
+   - Pentium III (Anderson)
+   - M68060 (Nikl)
+ */
+#ifdef POSTINC
+#  define OFF 0
+#  define PUP(a) *(a)++
+#else
+#  define OFF 1
+#  define PUP(a) *++(a)
+#endif
+
+/*
+   Decode literal, length, and distance codes and write out the resulting
+   literal and match bytes until either not enough input or output is
+   available, an end-of-block is encountered, or a data error is encountered.
+   When large enough input and output buffers are supplied to inflate(), for
+   example, a 16K input buffer and a 64K output buffer, more than 95% of the
+   inflate execution time is spent in this routine.
+
+   Entry assumptions:
+
+        state-&gt;mode == LEN
+        strm-&gt;avail_in &gt;= 6
+        strm-&gt;avail_out &gt;= 258
+        start &gt;= strm-&gt;avail_out
+        state-&gt;bits &lt; 8
+
+   On return, state-&gt;mode is one of:
+
+        LEN -- ran out of enough output space or enough available input
+        TYPE -- reached end of block code, inflate() to interpret next block
+        BAD -- error in block data
+
+   Notes:
+
+    - The maximum input bits used by a length/distance pair is 15 bits for the
+      length code, 5 bits for the length extra, 15 bits for the distance code,
+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
+      Therefore if strm-&gt;avail_in &gt;= 6, then there is enough input to avoid
+      checking for available input while decoding.
+
+    - The maximum bytes that a single length/distance pair can output is 258
+      bytes, which is the maximum length that can be coded.  inflate_fast()
+      requires strm-&gt;avail_out &gt;= 258 for each loop to avoid checking for
+      output space.
+ */
+void ZLIB_INTERNAL inflate_fast(strm, start)
+z_streamp strm;
+unsigned start;         /* inflate()'s starting value for strm-&gt;avail_out */
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *in;      /* local strm-&gt;next_in */
+    unsigned char FAR *last;    /* while in &lt; last, enough input available */
+    unsigned char FAR *out;     /* local strm-&gt;next_out */
+    unsigned char FAR *beg;     /* inflate()'s initial strm-&gt;next_out */
+    unsigned char FAR *end;     /* while out &lt; end, enough space available */
+#ifdef INFLATE_STRICT
+    unsigned dmax;              /* maximum distance from zlib header */
+#endif
+    unsigned wsize;             /* window size or zero if not using window */
+    unsigned whave;             /* valid bytes in the window */
+    unsigned wnext;             /* window write index */
+    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
+    unsigned long hold;         /* local strm-&gt;hold */
+    unsigned bits;              /* local strm-&gt;bits */
+    code const FAR *lcode;      /* local strm-&gt;lencode */
+    code const FAR *dcode;      /* local strm-&gt;distcode */
+    unsigned lmask;             /* mask for first level of length codes */
+    unsigned dmask;             /* mask for first level of distance codes */
+    code here;                  /* retrieved table entry */
+    unsigned op;                /* code bits, operation, extra bits, or */
+                                /*  window position, window bytes to copy */
+    unsigned len;               /* match length, unused bytes */
+    unsigned dist;              /* match distance */
+    unsigned char FAR *from;    /* where to copy match from */
+
+    /* copy state to local variables */
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    in = strm-&gt;next_in - OFF;
+    last = in + (strm-&gt;avail_in - 5);
+    out = strm-&gt;next_out - OFF;
+    beg = out - (start - strm-&gt;avail_out);
+    end = out + (strm-&gt;avail_out - 257);
+#ifdef INFLATE_STRICT
+    dmax = state-&gt;dmax;
+#endif
+    wsize = state-&gt;wsize;
+    whave = state-&gt;whave;
+    wnext = state-&gt;wnext;
+    window = state-&gt;window;
+    hold = state-&gt;hold;
+    bits = state-&gt;bits;
+    lcode = state-&gt;lencode;
+    dcode = state-&gt;distcode;
+    lmask = (1U &lt;&lt; state-&gt;lenbits) - 1;
+    dmask = (1U &lt;&lt; state-&gt;distbits) - 1;
+
+    /* decode literals and length/distances until end-of-block or not enough
+       input data or output space */
+    do {
+        if (bits &lt; 15) {
+            hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+            bits += 8;
+            hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+            bits += 8;
+        }
+        here = lcode[hold &amp; lmask];
+      dolen:
+        op = (unsigned)(here.bits);
+        hold &gt;&gt;= op;
+        bits -= op;
+        op = (unsigned)(here.op);
+        if (op == 0) {                          /* literal */
+            Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
+                    &quot;inflate:         literal '%c'\n&quot; :
+                    &quot;inflate:         literal 0x%02x\n&quot;, here.val));
+            PUP(out) = (unsigned char)(here.val);
+        }
+        else if (op &amp; 16) {                     /* length base */
+            len = (unsigned)(here.val);
+            op &amp;= 15;                           /* number of extra bits */
+            if (op) {
+                if (bits &lt; op) {
+                    hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+                    bits += 8;
+                }
+                len += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
+                hold &gt;&gt;= op;
+                bits -= op;
+            }
+            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, len));
+            if (bits &lt; 15) {
+                hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+                bits += 8;
+                hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+                bits += 8;
+            }
+            here = dcode[hold &amp; dmask];
+          dodist:
+            op = (unsigned)(here.bits);
+            hold &gt;&gt;= op;
+            bits -= op;
+            op = (unsigned)(here.op);
+            if (op &amp; 16) {                      /* distance base */
+                dist = (unsigned)(here.val);
+                op &amp;= 15;                       /* number of extra bits */
+                if (bits &lt; op) {
+                    hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+                    bits += 8;
+                    if (bits &lt; op) {
+                        hold += (unsigned long)(PUP(in)) &lt;&lt; bits;
+                        bits += 8;
+                    }
+                }
+                dist += (unsigned)hold &amp; ((1U &lt;&lt; op) - 1);
+#ifdef INFLATE_STRICT
+                if (dist &gt; dmax) {
+                    strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;
+                    state-&gt;mode = BAD;
+                    break;
+                }
+#endif
+                hold &gt;&gt;= op;
+                bits -= op;
+                Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, dist));
+                op = (unsigned)(out - beg);     /* max distance in output */
+                if (dist &gt; op) {                /* see if copy from window */
+                    op = dist - op;             /* distance back in window */
+                    if (op &gt; whave) {
+                        if (state-&gt;sane) {
+                            strm-&gt;msg =
+                                (char *)&quot;invalid distance too far back&quot;;
+                            state-&gt;mode = BAD;
+                            break;
+                        }
+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+                        if (len &lt;= op - whave) {
+                            do {
+                                PUP(out) = 0;
+                            } while (--len);
+                            continue;
+                        }
+                        len -= op - whave;
+                        do {
+                            PUP(out) = 0;
+                        } while (--op &gt; whave);
+                        if (op == 0) {
+                            from = out - dist;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--len);
+                            continue;
+                        }
+#endif
+                    }
+                    from = window - OFF;
+                    if (wnext == 0) {           /* very common case */
+                        from += wsize - op;
+                        if (op &lt; len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    else if (wnext &lt; op) {      /* wrap around window */
+                        from += wsize + wnext - op;
+                        op -= wnext;
+                        if (op &lt; len) {         /* some from end of window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = window - OFF;
+                            if (wnext &lt; len) {  /* some from start of window */
+                                op = wnext;
+                                len -= op;
+                                do {
+                                    PUP(out) = PUP(from);
+                                } while (--op);
+                                from = out - dist;      /* rest from output */
+                            }
+                        }
+                    }
+                    else {                      /* contiguous in window */
+                        from += wnext - op;
+                        if (op &lt; len) {         /* some from window */
+                            len -= op;
+                            do {
+                                PUP(out) = PUP(from);
+                            } while (--op);
+                            from = out - dist;  /* rest from output */
+                        }
+                    }
+                    while (len &gt; 2) {
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    }
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len &gt; 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+                else {
+                    from = out - dist;          /* copy direct from output */
+                    do {                        /* minimum length is three */
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        PUP(out) = PUP(from);
+                        len -= 3;
+                    } while (len &gt; 2);
+                    if (len) {
+                        PUP(out) = PUP(from);
+                        if (len &gt; 1)
+                            PUP(out) = PUP(from);
+                    }
+                }
+            }
+            else if ((op &amp; 64) == 0) {          /* 2nd level distance code */
+                here = dcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
+                goto dodist;
+            }
+            else {
+                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+        }
+        else if ((op &amp; 64) == 0) {              /* 2nd level length code */
+            here = lcode[here.val + (hold &amp; ((1U &lt;&lt; op) - 1))];
+            goto dolen;
+        }
+        else if (op &amp; 32) {                     /* end-of-block */
+            Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
+            state-&gt;mode = TYPE;
+            break;
+        }
+        else {
+            strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;
+            state-&gt;mode = BAD;
+            break;
+        }
+    } while (in &lt; last &amp;&amp; out &lt; end);
+
+    /* return unused bytes (on entry, bits &lt; 8, so in won't go too far back) */
+    len = bits &gt;&gt; 3;
+    in -= len;
+    bits -= len &lt;&lt; 3;
+    hold &amp;= (1U &lt;&lt; bits) - 1;
+
+    /* update state and return */
+    strm-&gt;next_in = in + OFF;
+    strm-&gt;next_out = out + OFF;
+    strm-&gt;avail_in = (unsigned)(in &lt; last ? 5 + (last - in) : 5 - (in - last));
+    strm-&gt;avail_out = (unsigned)(out &lt; end ?
+                                 257 + (end - out) : 257 - (out - end));
+    state-&gt;hold = hold;
+    state-&gt;bits = bits;
+    return;
+}
+
+/*
+   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
+   - Using bit fields for code structure
+   - Different op definition to avoid &amp; for extra bits (do &amp; for table bits)
+   - Three separate decoding do-loops for direct, window, and wnext == 0
+   - Special case for distance &gt; 1 copies to do overlapped load and store copy
+   - Explicit branch predictions (based on measured branch probabilities)
+   - Deferring match copy and interspersed it with decoding subsequent codes
+   - Swapping literal/length else
+   - Swapping window/direct else
+   - Larger unrolled copy loops (three is about right)
+   - Moving len -= 3 statement into middle of loop
+ */
+
+#endif /* !ASMINF */

Added: Lobby/TASClient/LobbyComponents/delphizlib/inffast.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inffast.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inffast.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,11 @@
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-2003, 2010 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+void ZLIB_INTERNAL inflate_fast OF((z_streamp strm, unsigned start));

Added: Lobby/TASClient/LobbyComponents/delphizlib/inffast.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/inffast.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/inffixed.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inffixed.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inffixed.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,94 @@
+    /* inffixed.h -- table for decoding fixed codes
+     * Generated automatically by makefixed().
+     */
+
+    /* WARNING: this file should *not* be used by applications. It
+       is part of the implementation of the compression library and
+       is subject to change. Applications should only use zlib.h.
+     */
+
+    static const code lenfix[512] = {
+        {96,7,0},{0,8,80},{0,8,16},{20,8,115},{18,7,31},{0,8,112},{0,8,48},
+        {0,9,192},{16,7,10},{0,8,96},{0,8,32},{0,9,160},{0,8,0},{0,8,128},
+        {0,8,64},{0,9,224},{16,7,6},{0,8,88},{0,8,24},{0,9,144},{19,7,59},
+        {0,8,120},{0,8,56},{0,9,208},{17,7,17},{0,8,104},{0,8,40},{0,9,176},
+        {0,8,8},{0,8,136},{0,8,72},{0,9,240},{16,7,4},{0,8,84},{0,8,20},
+        {21,8,227},{19,7,43},{0,8,116},{0,8,52},{0,9,200},{17,7,13},{0,8,100},
+        {0,8,36},{0,9,168},{0,8,4},{0,8,132},{0,8,68},{0,9,232},{16,7,8},
+        {0,8,92},{0,8,28},{0,9,152},{20,7,83},{0,8,124},{0,8,60},{0,9,216},
+        {18,7,23},{0,8,108},{0,8,44},{0,9,184},{0,8,12},{0,8,140},{0,8,76},
+        {0,9,248},{16,7,3},{0,8,82},{0,8,18},{21,8,163},{19,7,35},{0,8,114},
+        {0,8,50},{0,9,196},{17,7,11},{0,8,98},{0,8,34},{0,9,164},{0,8,2},
+        {0,8,130},{0,8,66},{0,9,228},{16,7,7},{0,8,90},{0,8,26},{0,9,148},
+        {20,7,67},{0,8,122},{0,8,58},{0,9,212},{18,7,19},{0,8,106},{0,8,42},
+        {0,9,180},{0,8,10},{0,8,138},{0,8,74},{0,9,244},{16,7,5},{0,8,86},
+        {0,8,22},{64,8,0},{19,7,51},{0,8,118},{0,8,54},{0,9,204},{17,7,15},
+        {0,8,102},{0,8,38},{0,9,172},{0,8,6},{0,8,134},{0,8,70},{0,9,236},
+        {16,7,9},{0,8,94},{0,8,30},{0,9,156},{20,7,99},{0,8,126},{0,8,62},
+        {0,9,220},{18,7,27},{0,8,110},{0,8,46},{0,9,188},{0,8,14},{0,8,142},
+        {0,8,78},{0,9,252},{96,7,0},{0,8,81},{0,8,17},{21,8,131},{18,7,31},
+        {0,8,113},{0,8,49},{0,9,194},{16,7,10},{0,8,97},{0,8,33},{0,9,162},
+        {0,8,1},{0,8,129},{0,8,65},{0,9,226},{16,7,6},{0,8,89},{0,8,25},
+        {0,9,146},{19,7,59},{0,8,121},{0,8,57},{0,9,210},{17,7,17},{0,8,105},
+        {0,8,41},{0,9,178},{0,8,9},{0,8,137},{0,8,73},{0,9,242},{16,7,4},
+        {0,8,85},{0,8,21},{16,8,258},{19,7,43},{0,8,117},{0,8,53},{0,9,202},
+        {17,7,13},{0,8,101},{0,8,37},{0,9,170},{0,8,5},{0,8,133},{0,8,69},
+        {0,9,234},{16,7,8},{0,8,93},{0,8,29},{0,9,154},{20,7,83},{0,8,125},
+        {0,8,61},{0,9,218},{18,7,23},{0,8,109},{0,8,45},{0,9,186},{0,8,13},
+        {0,8,141},{0,8,77},{0,9,250},{16,7,3},{0,8,83},{0,8,19},{21,8,195},
+        {19,7,35},{0,8,115},{0,8,51},{0,9,198},{17,7,11},{0,8,99},{0,8,35},
+        {0,9,166},{0,8,3},{0,8,131},{0,8,67},{0,9,230},{16,7,7},{0,8,91},
+        {0,8,27},{0,9,150},{20,7,67},{0,8,123},{0,8,59},{0,9,214},{18,7,19},
+        {0,8,107},{0,8,43},{0,9,182},{0,8,11},{0,8,139},{0,8,75},{0,9,246},
+        {16,7,5},{0,8,87},{0,8,23},{64,8,0},{19,7,51},{0,8,119},{0,8,55},
+        {0,9,206},{17,7,15},{0,8,103},{0,8,39},{0,9,174},{0,8,7},{0,8,135},
+        {0,8,71},{0,9,238},{16,7,9},{0,8,95},{0,8,31},{0,9,158},{20,7,99},
+        {0,8,127},{0,8,63},{0,9,222},{18,7,27},{0,8,111},{0,8,47},{0,9,190},
+        {0,8,15},{0,8,143},{0,8,79},{0,9,254},{96,7,0},{0,8,80},{0,8,16},
+        {20,8,115},{18,7,31},{0,8,112},{0,8,48},{0,9,193},{16,7,10},{0,8,96},
+        {0,8,32},{0,9,161},{0,8,0},{0,8,128},{0,8,64},{0,9,225},{16,7,6},
+        {0,8,88},{0,8,24},{0,9,145},{19,7,59},{0,8,120},{0,8,56},{0,9,209},
+        {17,7,17},{0,8,104},{0,8,40},{0,9,177},{0,8,8},{0,8,136},{0,8,72},
+        {0,9,241},{16,7,4},{0,8,84},{0,8,20},{21,8,227},{19,7,43},{0,8,116},
+        {0,8,52},{0,9,201},{17,7,13},{0,8,100},{0,8,36},{0,9,169},{0,8,4},
+        {0,8,132},{0,8,68},{0,9,233},{16,7,8},{0,8,92},{0,8,28},{0,9,153},
+        {20,7,83},{0,8,124},{0,8,60},{0,9,217},{18,7,23},{0,8,108},{0,8,44},
+        {0,9,185},{0,8,12},{0,8,140},{0,8,76},{0,9,249},{16,7,3},{0,8,82},
+        {0,8,18},{21,8,163},{19,7,35},{0,8,114},{0,8,50},{0,9,197},{17,7,11},
+        {0,8,98},{0,8,34},{0,9,165},{0,8,2},{0,8,130},{0,8,66},{0,9,229},
+        {16,7,7},{0,8,90},{0,8,26},{0,9,149},{20,7,67},{0,8,122},{0,8,58},
+        {0,9,213},{18,7,19},{0,8,106},{0,8,42},{0,9,181},{0,8,10},{0,8,138},
+        {0,8,74},{0,9,245},{16,7,5},{0,8,86},{0,8,22},{64,8,0},{19,7,51},
+        {0,8,118},{0,8,54},{0,9,205},{17,7,15},{0,8,102},{0,8,38},{0,9,173},
+        {0,8,6},{0,8,134},{0,8,70},{0,9,237},{16,7,9},{0,8,94},{0,8,30},
+        {0,9,157},{20,7,99},{0,8,126},{0,8,62},{0,9,221},{18,7,27},{0,8,110},
+        {0,8,46},{0,9,189},{0,8,14},{0,8,142},{0,8,78},{0,9,253},{96,7,0},
+        {0,8,81},{0,8,17},{21,8,131},{18,7,31},{0,8,113},{0,8,49},{0,9,195},
+        {16,7,10},{0,8,97},{0,8,33},{0,9,163},{0,8,1},{0,8,129},{0,8,65},
+        {0,9,227},{16,7,6},{0,8,89},{0,8,25},{0,9,147},{19,7,59},{0,8,121},
+        {0,8,57},{0,9,211},{17,7,17},{0,8,105},{0,8,41},{0,9,179},{0,8,9},
+        {0,8,137},{0,8,73},{0,9,243},{16,7,4},{0,8,85},{0,8,21},{16,8,258},
+        {19,7,43},{0,8,117},{0,8,53},{0,9,203},{17,7,13},{0,8,101},{0,8,37},
+        {0,9,171},{0,8,5},{0,8,133},{0,8,69},{0,9,235},{16,7,8},{0,8,93},
+        {0,8,29},{0,9,155},{20,7,83},{0,8,125},{0,8,61},{0,9,219},{18,7,23},
+        {0,8,109},{0,8,45},{0,9,187},{0,8,13},{0,8,141},{0,8,77},{0,9,251},
+        {16,7,3},{0,8,83},{0,8,19},{21,8,195},{19,7,35},{0,8,115},{0,8,51},
+        {0,9,199},{17,7,11},{0,8,99},{0,8,35},{0,9,167},{0,8,3},{0,8,131},
+        {0,8,67},{0,9,231},{16,7,7},{0,8,91},{0,8,27},{0,9,151},{20,7,67},
+        {0,8,123},{0,8,59},{0,9,215},{18,7,19},{0,8,107},{0,8,43},{0,9,183},
+        {0,8,11},{0,8,139},{0,8,75},{0,9,247},{16,7,5},{0,8,87},{0,8,23},
+        {64,8,0},{19,7,51},{0,8,119},{0,8,55},{0,9,207},{17,7,15},{0,8,103},
+        {0,8,39},{0,9,175},{0,8,7},{0,8,135},{0,8,71},{0,9,239},{16,7,9},
+        {0,8,95},{0,8,31},{0,9,159},{20,7,99},{0,8,127},{0,8,63},{0,9,223},
+        {18,7,27},{0,8,111},{0,8,47},{0,9,191},{0,8,15},{0,8,143},{0,8,79},
+        {0,9,255}
+    };
+
+    static const code distfix[32] = {
+        {16,5,1},{23,5,257},{19,5,17},{27,5,4097},{17,5,5},{25,5,1025},
+        {21,5,65},{29,5,16385},{16,5,3},{24,5,513},{20,5,33},{28,5,8193},
+        {18,5,9},{26,5,2049},{22,5,129},{64,5,0},{16,5,2},{23,5,385},
+        {19,5,25},{27,5,6145},{17,5,7},{25,5,1537},{21,5,97},{29,5,24577},
+        {16,5,4},{24,5,769},{20,5,49},{28,5,12289},{18,5,13},{26,5,3073},
+        {22,5,193},{64,5,0}
+    };

Added: Lobby/TASClient/LobbyComponents/delphizlib/inflate.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inflate.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inflate.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,1480 @@
+/* inflate.c -- zlib decompression
+ * Copyright (C) 1995-2010 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+ * Change history:
+ *
+ * 1.2.beta0    24 Nov 2002
+ * - First version -- complete rewrite of inflate to simplify code, avoid
+ *   creation of window when not needed, minimize use of window when it is
+ *   needed, make inffast.c even faster, implement gzip decoding, and to
+ *   improve code readability and style over the previous zlib inflate code
+ *
+ * 1.2.beta1    25 Nov 2002
+ * - Use pointers for available input and output checking in inffast.c
+ * - Remove input and output counters in inffast.c
+ * - Change inffast.c entry and loop from avail_in &gt;= 7 to &gt;= 6
+ * - Remove unnecessary second byte pull from length extra in inffast.c
+ * - Unroll direct copy to three copies per loop in inffast.c
+ *
+ * 1.2.beta2    4 Dec 2002
+ * - Change external routine names to reduce potential conflicts
+ * - Correct filename to inffixed.h for fixed tables in inflate.c
+ * - Make hbuf[] unsigned char to match parameter type in inflate.c
+ * - Change strm-&gt;next_out[-state-&gt;offset] to *(strm-&gt;next_out - state-&gt;offset)
+ *   to avoid negation problem on Alphas (64 bit) in inflate.c
+ *
+ * 1.2.beta3    22 Dec 2002
+ * - Add comments on state-&gt;bits assertion in inffast.c
+ * - Add comments on op field in inftrees.h
+ * - Fix bug in reuse of allocated window after inflateReset()
+ * - Remove bit fields--back to byte structure for speed
+ * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
+ * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
+ * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
+ * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
+ * - Use local copies of stream next and avail values, as well as local bit
+ *   buffer and bit count in inflate()--for speed when inflate_fast() not used
+ *
+ * 1.2.beta4    1 Jan 2003
+ * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
+ * - Move a comment on output buffer sizes from inffast.c to inflate.c
+ * - Add comments in inffast.c to introduce the inflate_fast() routine
+ * - Rearrange window copies in inflate_fast() for speed and simplification
+ * - Unroll last copy for window match in inflate_fast()
+ * - Use local copies of window variables in inflate_fast() for speed
+ * - Pull out common wnext == 0 case for speed in inflate_fast()
+ * - Make op and len in inflate_fast() unsigned for consistency
+ * - Add FAR to lcode and dcode declarations in inflate_fast()
+ * - Simplified bad distance check in inflate_fast()
+ * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
+ *   source file infback.c to provide a call-back interface to inflate for
+ *   programs like gzip and unzip -- uses window as output buffer to avoid
+ *   window copying
+ *
+ * 1.2.beta5    1 Jan 2003
+ * - Improved inflateBack() interface to allow the caller to provide initial
+ *   input in strm.
+ * - Fixed stored blocks bug in inflateBack()
+ *
+ * 1.2.beta6    4 Jan 2003
+ * - Added comments in inffast.c on effectiveness of POSTINC
+ * - Typecasting all around to reduce compiler warnings
+ * - Changed loops from while (1) or do {} while (1) to for (;;), again to
+ *   make compilers happy
+ * - Changed type of window in inflateBackInit() to unsigned char *
+ *
+ * 1.2.beta7    27 Jan 2003
+ * - Changed many types to unsigned or unsigned short to avoid warnings
+ * - Added inflateCopy() function
+ *
+ * 1.2.0        9 Mar 2003
+ * - Changed inflateBack() interface to provide separate opaque descriptors
+ *   for the in() and out() functions
+ * - Changed inflateBack() argument and in_func typedef to swap the length
+ *   and buffer address return values for the input function
+ * - Check next_in and next_out for Z_NULL on entry to inflate()
+ *
+ * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
+ */
+
+#include &quot;zutil.h&quot;
+#include &quot;inftrees.h&quot;
+#include &quot;inflate.h&quot;
+#include &quot;inffast.h&quot;
+
+#ifdef MAKEFIXED
+#  ifndef BUILDFIXED
+#    define BUILDFIXED
+#  endif
+#endif
+
+/* function prototypes */
+local void fixedtables OF((struct inflate_state FAR *state));
+local int updatewindow OF((z_streamp strm, unsigned out));
+#ifdef BUILDFIXED
+   void makefixed OF((void));
+#endif
+local unsigned syncsearch OF((unsigned FAR *have, unsigned char FAR *buf,
+                              unsigned len));
+
+int ZEXPORT inflateReset(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    strm-&gt;total_in = strm-&gt;total_out = state-&gt;total = 0;
+    strm-&gt;msg = Z_NULL;
+    strm-&gt;adler = 1;        /* to support ill-conceived Java test suite */
+    state-&gt;mode = HEAD;
+    state-&gt;last = 0;
+    state-&gt;havedict = 0;
+    state-&gt;dmax = 32768U;
+    state-&gt;head = Z_NULL;
+    state-&gt;wsize = 0;
+    state-&gt;whave = 0;
+    state-&gt;wnext = 0;
+    state-&gt;hold = 0;
+    state-&gt;bits = 0;
+    state-&gt;lencode = state-&gt;distcode = state-&gt;next = state-&gt;codes;
+    state-&gt;sane = 1;
+    state-&gt;back = -1;
+    Tracev((stderr, &quot;inflate: reset\n&quot;));
+    return Z_OK;
+}
+
+int ZEXPORT inflateReset2(strm, windowBits)
+z_streamp strm;
+int windowBits;
+{
+    int wrap;
+    struct inflate_state FAR *state;
+
+    /* get the state */
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+
+    /* extract wrap request from windowBits parameter */
+    if (windowBits &lt; 0) {
+        wrap = 0;
+        windowBits = -windowBits;
+    }
+    else {
+        wrap = (windowBits &gt;&gt; 4) + 1;
+#ifdef GUNZIP
+        if (windowBits &lt; 48)
+            windowBits &amp;= 15;
+#endif
+    }
+
+    /* set number of window bits, free window if different */
+    if (windowBits &amp;&amp; (windowBits &lt; 8 || windowBits &gt; 15))
+        return Z_STREAM_ERROR;
+    if (state-&gt;window != Z_NULL &amp;&amp; state-&gt;wbits != (unsigned)windowBits) {
+        ZFREE(strm, state-&gt;window);
+        state-&gt;window = Z_NULL;
+    }
+
+    /* update state and reset the rest of it */
+    state-&gt;wrap = wrap;
+    state-&gt;wbits = (unsigned)windowBits;
+    return inflateReset(strm);
+}
+
+int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
+z_streamp strm;
+int windowBits;
+const char *version;
+int stream_size;
+{
+    int ret;
+    struct inflate_state FAR *state;
+
+    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+        stream_size != (int)(sizeof(z_stream)))
+        return Z_VERSION_ERROR;
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+    strm-&gt;msg = Z_NULL;                 /* in case we return an error */
+    if (strm-&gt;zalloc == (alloc_func)0) {
+        strm-&gt;zalloc = zcalloc;
+        strm-&gt;opaque = (voidpf)0;
+    }
+    if (strm-&gt;zfree == (free_func)0) strm-&gt;zfree = zcfree;
+    state = (struct inflate_state FAR *)
+            ZALLOC(strm, 1, sizeof(struct inflate_state));
+    if (state == Z_NULL) return Z_MEM_ERROR;
+    Tracev((stderr, &quot;inflate: allocated\n&quot;));
+    strm-&gt;state = (struct internal_state FAR *)state;
+    state-&gt;window = Z_NULL;
+    ret = inflateReset2(strm, windowBits);
+    if (ret != Z_OK) {
+        ZFREE(strm, state);
+        strm-&gt;state = Z_NULL;
+    }
+    return ret;
+}
+
+int ZEXPORT inflateInit_(strm, version, stream_size)
+z_streamp strm;
+const char *version;
+int stream_size;
+{
+    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
+}
+
+int ZEXPORT inflatePrime(strm, bits, value)
+z_streamp strm;
+int bits;
+int value;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    if (bits &lt; 0) {
+        state-&gt;hold = 0;
+        state-&gt;bits = 0;
+        return Z_OK;
+    }
+    if (bits &gt; 16 || state-&gt;bits + bits &gt; 32) return Z_STREAM_ERROR;
+    value &amp;= (1L &lt;&lt; bits) - 1;
+    state-&gt;hold += value &lt;&lt; state-&gt;bits;
+    state-&gt;bits += bits;
+    return Z_OK;
+}
+
+/*
+   Return state with length and distance decoding tables and index sizes set to
+   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
+   If BUILDFIXED is defined, then instead this routine builds the tables the
+   first time it's called, and returns those tables the first time and
+   thereafter.  This reduces the size of the code by about 2K bytes, in
+   exchange for a little execution time.  However, BUILDFIXED should not be
+   used for threaded applications, since the rewriting of the tables and virgin
+   may not be thread-safe.
+ */
+local void fixedtables(state)
+struct inflate_state FAR *state;
+{
+#ifdef BUILDFIXED
+    static int virgin = 1;
+    static code *lenfix, *distfix;
+    static code fixed[544];
+
+    /* build fixed huffman tables if first call (may not be thread safe) */
+    if (virgin) {
+        unsigned sym, bits;
+        static code *next;
+
+        /* literal/length table */
+        sym = 0;
+        while (sym &lt; 144) state-&gt;lens[sym++] = 8;
+        while (sym &lt; 256) state-&gt;lens[sym++] = 9;
+        while (sym &lt; 280) state-&gt;lens[sym++] = 7;
+        while (sym &lt; 288) state-&gt;lens[sym++] = 8;
+        next = fixed;
+        lenfix = next;
+        bits = 9;
+        inflate_table(LENS, state-&gt;lens, 288, &amp;(next), &amp;(bits), state-&gt;work);
+
+        /* distance table */
+        sym = 0;
+        while (sym &lt; 32) state-&gt;lens[sym++] = 5;
+        distfix = next;
+        bits = 5;
+        inflate_table(DISTS, state-&gt;lens, 32, &amp;(next), &amp;(bits), state-&gt;work);
+
+        /* do this just once */
+        virgin = 0;
+    }
+#else /* !BUILDFIXED */
+#   include &quot;inffixed.h&quot;
+#endif /* BUILDFIXED */
+    state-&gt;lencode = lenfix;
+    state-&gt;lenbits = 9;
+    state-&gt;distcode = distfix;
+    state-&gt;distbits = 5;
+}
+
+#ifdef MAKEFIXED
+#include &lt;stdio.h&gt;
+
+/*
+   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
+   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
+   those tables to stdout, which would be piped to inffixed.h.  A small program
+   can simply call makefixed to do this:
+
+    void makefixed(void);
+
+    int main(void)
+    {
+        makefixed();
+        return 0;
+    }
+
+   Then that can be linked with zlib built with MAKEFIXED defined and run:
+
+    a.out &gt; inffixed.h
+ */
+void makefixed()
+{
+    unsigned low, size;
+    struct inflate_state state;
+
+    fixedtables(&amp;state);
+    puts(&quot;    /* inffixed.h -- table for decoding fixed codes&quot;);
+    puts(&quot;     * Generated automatically by makefixed().&quot;);
+    puts(&quot;     */&quot;);
+    puts(&quot;&quot;);
+    puts(&quot;    /* WARNING: this file should *not* be used by applications.&quot;);
+    puts(&quot;       It is part of the implementation of this library and is&quot;);
+    puts(&quot;       subject to change. Applications should only use zlib.h.&quot;);
+    puts(&quot;     */&quot;);
+    puts(&quot;&quot;);
+    size = 1U &lt;&lt; 9;
+    printf(&quot;    static const code lenfix[%u] = {&quot;, size);
+    low = 0;
+    for (;;) {
+        if ((low % 7) == 0) printf(&quot;\n        &quot;);
+        printf(&quot;{%u,%u,%d}&quot;, state.lencode[low].op, state.lencode[low].bits,
+               state.lencode[low].val);
+        if (++low == size) break;
+        putchar(',');
+    }
+    puts(&quot;\n    };&quot;);
+    size = 1U &lt;&lt; 5;
+    printf(&quot;\n    static const code distfix[%u] = {&quot;, size);
+    low = 0;
+    for (;;) {
+        if ((low % 6) == 0) printf(&quot;\n        &quot;);
+        printf(&quot;{%u,%u,%d}&quot;, state.distcode[low].op, state.distcode[low].bits,
+               state.distcode[low].val);
+        if (++low == size) break;
+        putchar(',');
+    }
+    puts(&quot;\n    };&quot;);
+}
+#endif /* MAKEFIXED */
+
+/*
+   Update the window with the last wsize (normally 32K) bytes written before
+   returning.  If window does not exist yet, create it.  This is only called
+   when a window is already in use, or when output has been written during this
+   inflate call, but the end of the deflate stream has not been reached yet.
+   It is also called to create a window for dictionary data when a dictionary
+   is loaded.
+
+   Providing output buffers larger than 32K to inflate() should provide a speed
+   advantage, since only the last 32K of output is copied to the sliding window
+   upon return from inflate(), and since all distances after the first 32K of
+   output will fall in the output data, making match copies simpler and faster.
+   The advantage may be dependent on the size of the processor's data caches.
+ */
+local int updatewindow(strm, out)
+z_streamp strm;
+unsigned out;
+{
+    struct inflate_state FAR *state;
+    unsigned copy, dist;
+
+    state = (struct inflate_state FAR *)strm-&gt;state;
+
+    /* if it hasn't been done already, allocate space for the window */
+    if (state-&gt;window == Z_NULL) {
+        state-&gt;window = (unsigned char FAR *)
+                        ZALLOC(strm, 1U &lt;&lt; state-&gt;wbits,
+                               sizeof(unsigned char));
+        if (state-&gt;window == Z_NULL) return 1;
+    }
+
+    /* if window not in use yet, initialize */
+    if (state-&gt;wsize == 0) {
+        state-&gt;wsize = 1U &lt;&lt; state-&gt;wbits;
+        state-&gt;wnext = 0;
+        state-&gt;whave = 0;
+    }
+
+    /* copy state-&gt;wsize or less output bytes into the circular window */
+    copy = out - strm-&gt;avail_out;
+    if (copy &gt;= state-&gt;wsize) {
+        zmemcpy(state-&gt;window, strm-&gt;next_out - state-&gt;wsize, state-&gt;wsize);
+        state-&gt;wnext = 0;
+        state-&gt;whave = state-&gt;wsize;
+    }
+    else {
+        dist = state-&gt;wsize - state-&gt;wnext;
+        if (dist &gt; copy) dist = copy;
+        zmemcpy(state-&gt;window + state-&gt;wnext, strm-&gt;next_out - copy, dist);
+        copy -= dist;
+        if (copy) {
+            zmemcpy(state-&gt;window, strm-&gt;next_out - copy, copy);
+            state-&gt;wnext = copy;
+            state-&gt;whave = state-&gt;wsize;
+        }
+        else {
+            state-&gt;wnext += dist;
+            if (state-&gt;wnext == state-&gt;wsize) state-&gt;wnext = 0;
+            if (state-&gt;whave &lt; state-&gt;wsize) state-&gt;whave += dist;
+        }
+    }
+    return 0;
+}
+
+/* Macros for inflate(): */
+
+/* check function to use adler32() for zlib or crc32() for gzip */
+#ifdef GUNZIP
+#  define UPDATE(check, buf, len) \
+    (state-&gt;flags ? crc32(check, buf, len) : adler32(check, buf, len))
+#else
+#  define UPDATE(check, buf, len) adler32(check, buf, len)
+#endif
+
+/* check macros for header crc */
+#ifdef GUNZIP
+#  define CRC2(check, word) \
+    do { \
+        hbuf[0] = (unsigned char)(word); \
+        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \
+        check = crc32(check, hbuf, 2); \
+    } while (0)
+
+#  define CRC4(check, word) \
+    do { \
+        hbuf[0] = (unsigned char)(word); \
+        hbuf[1] = (unsigned char)((word) &gt;&gt; 8); \
+        hbuf[2] = (unsigned char)((word) &gt;&gt; 16); \
+        hbuf[3] = (unsigned char)((word) &gt;&gt; 24); \
+        check = crc32(check, hbuf, 4); \
+    } while (0)
+#endif
+
+/* Load registers with state in inflate() for speed */
+#define LOAD() \
+    do { \
+        put = strm-&gt;next_out; \
+        left = strm-&gt;avail_out; \
+        next = strm-&gt;next_in; \
+        have = strm-&gt;avail_in; \
+        hold = state-&gt;hold; \
+        bits = state-&gt;bits; \
+    } while (0)
+
+/* Restore state from registers in inflate() */
+#define RESTORE() \
+    do { \
+        strm-&gt;next_out = put; \
+        strm-&gt;avail_out = left; \
+        strm-&gt;next_in = next; \
+        strm-&gt;avail_in = have; \
+        state-&gt;hold = hold; \
+        state-&gt;bits = bits; \
+    } while (0)
+
+/* Clear the input bit accumulator */
+#define INITBITS() \
+    do { \
+        hold = 0; \
+        bits = 0; \
+    } while (0)
+
+/* Get a byte of input into the bit accumulator, or return from inflate()
+   if there is no input available. */
+#define PULLBYTE() \
+    do { \
+        if (have == 0) goto inf_leave; \
+        have--; \
+        hold += (unsigned long)(*next++) &lt;&lt; bits; \
+        bits += 8; \
+    } while (0)
+
+/* Assure that there are at least n bits in the bit accumulator.  If there is
+   not enough available input to do that, then return from inflate(). */
+#define NEEDBITS(n) \
+    do { \
+        while (bits &lt; (unsigned)(n)) \
+            PULLBYTE(); \
+    } while (0)
+
+/* Return the low n bits of the bit accumulator (n &lt; 16) */
+#define BITS(n) \
+    ((unsigned)hold &amp; ((1U &lt;&lt; (n)) - 1))
+
+/* Remove n bits from the bit accumulator */
+#define DROPBITS(n) \
+    do { \
+        hold &gt;&gt;= (n); \
+        bits -= (unsigned)(n); \
+    } while (0)
+
+/* Remove zero to seven bits as needed to go to a byte boundary */
+#define BYTEBITS() \
+    do { \
+        hold &gt;&gt;= bits &amp; 7; \
+        bits -= bits &amp; 7; \
+    } while (0)
+
+/* Reverse the bytes in a 32-bit value */
+#define REVERSE(q) \
+    ((((q) &gt;&gt; 24) &amp; 0xff) + (((q) &gt;&gt; 8) &amp; 0xff00) + \
+     (((q) &amp; 0xff00) &lt;&lt; 8) + (((q) &amp; 0xff) &lt;&lt; 24))
+
+/*
+   inflate() uses a state machine to process as much input data and generate as
+   much output data as possible before returning.  The state machine is
+   structured roughly as follows:
+
+    for (;;) switch (state) {
+    ...
+    case STATEn:
+        if (not enough input data or output space to make progress)
+            return;
+        ... make progress ...
+        state = STATEm;
+        break;
+    ...
+    }
+
+   so when inflate() is called again, the same case is attempted again, and
+   if the appropriate resources are provided, the machine proceeds to the
+   next state.  The NEEDBITS() macro is usually the way the state evaluates
+   whether it can proceed or should return.  NEEDBITS() does the return if
+   the requested bits are not available.  The typical use of the BITS macros
+   is:
+
+        NEEDBITS(n);
+        ... do something with BITS(n) ...
+        DROPBITS(n);
+
+   where NEEDBITS(n) either returns from inflate() if there isn't enough
+   input left to load n bits into the accumulator, or it continues.  BITS(n)
+   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
+   the low n bits off the accumulator.  INITBITS() clears the accumulator
+   and sets the number of available bits to zero.  BYTEBITS() discards just
+   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
+   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
+
+   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
+   if there is no input available.  The decoding of variable length codes uses
+   PULLBYTE() directly in order to pull just enough bytes to decode the next
+   code, and no more.
+
+   Some states loop until they get enough input, making sure that enough
+   state information is maintained to continue the loop where it left off
+   if NEEDBITS() returns in the loop.  For example, want, need, and keep
+   would all have to actually be part of the saved state in case NEEDBITS()
+   returns:
+
+    case STATEw:
+        while (want &lt; need) {
+            NEEDBITS(n);
+            keep[want++] = BITS(n);
+            DROPBITS(n);
+        }
+        state = STATEx;
+    case STATEx:
+
+   As shown above, if the next state is also the next case, then the break
+   is omitted.
+
+   A state may also return if there is not enough output space available to
+   complete that state.  Those states are copying stored data, writing a
+   literal byte, and copying a matching string.
+
+   When returning, a &quot;goto inf_leave&quot; is used to update the total counters,
+   update the check value, and determine whether any progress has been made
+   during that inflate() call in order to return the proper return code.
+   Progress is defined as a change in either strm-&gt;avail_in or strm-&gt;avail_out.
+   When there is a window, goto inf_leave will update the window with the last
+   output written.  If a goto inf_leave occurs in the middle of decompression
+   and there is no window currently, goto inf_leave will create one and copy
+   output to the window for the next call of inflate().
+
+   In this implementation, the flush parameter of inflate() only affects the
+   return code (per zlib.h).  inflate() always writes as much as possible to
+   strm-&gt;next_out, given the space available and the provided input--the effect
+   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
+   the allocation of and copying into a sliding window until necessary, which
+   provides the effect documented in zlib.h for Z_FINISH when the entire input
+   stream available.  So the only thing the flush parameter actually does is:
+   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
+   will return Z_BUF_ERROR if it has not reached the end of the stream.
+ */
+
+int ZEXPORT inflate(strm, flush)
+z_streamp strm;
+int flush;
+{
+    struct inflate_state FAR *state;
+    unsigned char FAR *next;    /* next input */
+    unsigned char FAR *put;     /* next output */
+    unsigned have, left;        /* available input and output */
+    unsigned long hold;         /* bit buffer */
+    unsigned bits;              /* bits in bit buffer */
+    unsigned in, out;           /* save starting available input and output */
+    unsigned copy;              /* number of stored or match bytes to copy */
+    unsigned char FAR *from;    /* where to copy match bytes from */
+    code here;                  /* current decoding table entry */
+    code last;                  /* parent table entry */
+    unsigned len;               /* length to copy for repeats, bits to drop */
+    int ret;                    /* return code */
+#ifdef GUNZIP
+    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
+#endif
+    static const unsigned short order[19] = /* permutation of code lengths */
+        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL || strm-&gt;next_out == Z_NULL ||
+        (strm-&gt;next_in == Z_NULL &amp;&amp; strm-&gt;avail_in != 0))
+        return Z_STREAM_ERROR;
+
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    if (state-&gt;mode == TYPE) state-&gt;mode = TYPEDO;      /* skip check */
+    LOAD();
+    in = have;
+    out = left;
+    ret = Z_OK;
+    for (;;)
+        switch (state-&gt;mode) {
+        case HEAD:
+            if (state-&gt;wrap == 0) {
+                state-&gt;mode = TYPEDO;
+                break;
+            }
+            NEEDBITS(16);
+#ifdef GUNZIP
+            if ((state-&gt;wrap &amp; 2) &amp;&amp; hold == 0x8b1f) {  /* gzip header */
+                state-&gt;check = crc32(0L, Z_NULL, 0);
+                CRC2(state-&gt;check, hold);
+                INITBITS();
+                state-&gt;mode = FLAGS;
+                break;
+            }
+            state-&gt;flags = 0;           /* expect zlib header */
+            if (state-&gt;head != Z_NULL)
+                state-&gt;head-&gt;done = -1;
+            if (!(state-&gt;wrap &amp; 1) ||   /* check if zlib header allowed */
+#else
+            if (
+#endif
+                ((BITS(8) &lt;&lt; 8) + (hold &gt;&gt; 8)) % 31) {
+                strm-&gt;msg = (char *)&quot;incorrect header check&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            if (BITS(4) != Z_DEFLATED) {
+                strm-&gt;msg = (char *)&quot;unknown compression method&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            DROPBITS(4);
+            len = BITS(4) + 8;
+            if (state-&gt;wbits == 0)
+                state-&gt;wbits = len;
+            else if (len &gt; state-&gt;wbits) {
+                strm-&gt;msg = (char *)&quot;invalid window size&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;dmax = 1U &lt;&lt; len;
+            Tracev((stderr, &quot;inflate:   zlib header ok\n&quot;));
+            strm-&gt;adler = state-&gt;check = adler32(0L, Z_NULL, 0);
+            state-&gt;mode = hold &amp; 0x200 ? DICTID : TYPE;
+            INITBITS();
+            break;
+#ifdef GUNZIP
+        case FLAGS:
+            NEEDBITS(16);
+            state-&gt;flags = (int)(hold);
+            if ((state-&gt;flags &amp; 0xff) != Z_DEFLATED) {
+                strm-&gt;msg = (char *)&quot;unknown compression method&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            if (state-&gt;flags &amp; 0xe000) {
+                strm-&gt;msg = (char *)&quot;unknown header flags set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            if (state-&gt;head != Z_NULL)
+                state-&gt;head-&gt;text = (int)((hold &gt;&gt; 8) &amp; 1);
+            if (state-&gt;flags &amp; 0x0200) CRC2(state-&gt;check, hold);
+            INITBITS();
+            state-&gt;mode = TIME;
+        case TIME:
+            NEEDBITS(32);
+            if (state-&gt;head != Z_NULL)
+                state-&gt;head-&gt;time = hold;
+            if (state-&gt;flags &amp; 0x0200) CRC4(state-&gt;check, hold);
+            INITBITS();
+            state-&gt;mode = OS;
+        case OS:
+            NEEDBITS(16);
+            if (state-&gt;head != Z_NULL) {
+                state-&gt;head-&gt;xflags = (int)(hold &amp; 0xff);
+                state-&gt;head-&gt;os = (int)(hold &gt;&gt; 8);
+            }
+            if (state-&gt;flags &amp; 0x0200) CRC2(state-&gt;check, hold);
+            INITBITS();
+            state-&gt;mode = EXLEN;
+        case EXLEN:
+            if (state-&gt;flags &amp; 0x0400) {
+                NEEDBITS(16);
+                state-&gt;length = (unsigned)(hold);
+                if (state-&gt;head != Z_NULL)
+                    state-&gt;head-&gt;extra_len = (unsigned)hold;
+                if (state-&gt;flags &amp; 0x0200) CRC2(state-&gt;check, hold);
+                INITBITS();
+            }
+            else if (state-&gt;head != Z_NULL)
+                state-&gt;head-&gt;extra = Z_NULL;
+            state-&gt;mode = EXTRA;
+        case EXTRA:
+            if (state-&gt;flags &amp; 0x0400) {
+                copy = state-&gt;length;
+                if (copy &gt; have) copy = have;
+                if (copy) {
+                    if (state-&gt;head != Z_NULL &amp;&amp;
+                        state-&gt;head-&gt;extra != Z_NULL) {
+                        len = state-&gt;head-&gt;extra_len - state-&gt;length;
+                        zmemcpy(state-&gt;head-&gt;extra + len, next,
+                                len + copy &gt; state-&gt;head-&gt;extra_max ?
+                                state-&gt;head-&gt;extra_max - len : copy);
+                    }
+                    if (state-&gt;flags &amp; 0x0200)
+                        state-&gt;check = crc32(state-&gt;check, next, copy);
+                    have -= copy;
+                    next += copy;
+                    state-&gt;length -= copy;
+                }
+                if (state-&gt;length) goto inf_leave;
+            }
+            state-&gt;length = 0;
+            state-&gt;mode = NAME;
+        case NAME:
+            if (state-&gt;flags &amp; 0x0800) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state-&gt;head != Z_NULL &amp;&amp;
+                            state-&gt;head-&gt;name != Z_NULL &amp;&amp;
+                            state-&gt;length &lt; state-&gt;head-&gt;name_max)
+                        state-&gt;head-&gt;name[state-&gt;length++] = len;
+                } while (len &amp;&amp; copy &lt; have);
+                if (state-&gt;flags &amp; 0x0200)
+                    state-&gt;check = crc32(state-&gt;check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state-&gt;head != Z_NULL)
+                state-&gt;head-&gt;name = Z_NULL;
+            state-&gt;length = 0;
+            state-&gt;mode = COMMENT;
+        case COMMENT:
+            if (state-&gt;flags &amp; 0x1000) {
+                if (have == 0) goto inf_leave;
+                copy = 0;
+                do {
+                    len = (unsigned)(next[copy++]);
+                    if (state-&gt;head != Z_NULL &amp;&amp;
+                            state-&gt;head-&gt;comment != Z_NULL &amp;&amp;
+                            state-&gt;length &lt; state-&gt;head-&gt;comm_max)
+                        state-&gt;head-&gt;comment[state-&gt;length++] = len;
+                } while (len &amp;&amp; copy &lt; have);
+                if (state-&gt;flags &amp; 0x0200)
+                    state-&gt;check = crc32(state-&gt;check, next, copy);
+                have -= copy;
+                next += copy;
+                if (len) goto inf_leave;
+            }
+            else if (state-&gt;head != Z_NULL)
+                state-&gt;head-&gt;comment = Z_NULL;
+            state-&gt;mode = HCRC;
+        case HCRC:
+            if (state-&gt;flags &amp; 0x0200) {
+                NEEDBITS(16);
+                if (hold != (state-&gt;check &amp; 0xffff)) {
+                    strm-&gt;msg = (char *)&quot;header crc mismatch&quot;;
+                    state-&gt;mode = BAD;
+                    break;
+                }
+                INITBITS();
+            }
+            if (state-&gt;head != Z_NULL) {
+                state-&gt;head-&gt;hcrc = (int)((state-&gt;flags &gt;&gt; 9) &amp; 1);
+                state-&gt;head-&gt;done = 1;
+            }
+            strm-&gt;adler = state-&gt;check = crc32(0L, Z_NULL, 0);
+            state-&gt;mode = TYPE;
+            break;
+#endif
+        case DICTID:
+            NEEDBITS(32);
+            strm-&gt;adler = state-&gt;check = REVERSE(hold);
+            INITBITS();
+            state-&gt;mode = DICT;
+        case DICT:
+            if (state-&gt;havedict == 0) {
+                RESTORE();
+                return Z_NEED_DICT;
+            }
+            strm-&gt;adler = state-&gt;check = adler32(0L, Z_NULL, 0);
+            state-&gt;mode = TYPE;
+        case TYPE:
+            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
+        case TYPEDO:
+            if (state-&gt;last) {
+                BYTEBITS();
+                state-&gt;mode = CHECK;
+                break;
+            }
+            NEEDBITS(3);
+            state-&gt;last = BITS(1);
+            DROPBITS(1);
+            switch (BITS(2)) {
+            case 0:                             /* stored block */
+                Tracev((stderr, &quot;inflate:     stored block%s\n&quot;,
+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));
+                state-&gt;mode = STORED;
+                break;
+            case 1:                             /* fixed block */
+                fixedtables(state);
+                Tracev((stderr, &quot;inflate:     fixed codes block%s\n&quot;,
+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));
+                state-&gt;mode = LEN_;             /* decode codes */
+                if (flush == Z_TREES) {
+                    DROPBITS(2);
+                    goto inf_leave;
+                }
+                break;
+            case 2:                             /* dynamic block */
+                Tracev((stderr, &quot;inflate:     dynamic codes block%s\n&quot;,
+                        state-&gt;last ? &quot; (last)&quot; : &quot;&quot;));
+                state-&gt;mode = TABLE;
+                break;
+            case 3:
+                strm-&gt;msg = (char *)&quot;invalid block type&quot;;
+                state-&gt;mode = BAD;
+            }
+            DROPBITS(2);
+            break;
+        case STORED:
+            BYTEBITS();                         /* go to byte boundary */
+            NEEDBITS(32);
+            if ((hold &amp; 0xffff) != ((hold &gt;&gt; 16) ^ 0xffff)) {
+                strm-&gt;msg = (char *)&quot;invalid stored block lengths&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;length = (unsigned)hold &amp; 0xffff;
+            Tracev((stderr, &quot;inflate:       stored length %u\n&quot;,
+                    state-&gt;length));
+            INITBITS();
+            state-&gt;mode = COPY_;
+            if (flush == Z_TREES) goto inf_leave;
+        case COPY_:
+            state-&gt;mode = COPY;
+        case COPY:
+            copy = state-&gt;length;
+            if (copy) {
+                if (copy &gt; have) copy = have;
+                if (copy &gt; left) copy = left;
+                if (copy == 0) goto inf_leave;
+                zmemcpy(put, next, copy);
+                have -= copy;
+                next += copy;
+                left -= copy;
+                put += copy;
+                state-&gt;length -= copy;
+                break;
+            }
+            Tracev((stderr, &quot;inflate:       stored end\n&quot;));
+            state-&gt;mode = TYPE;
+            break;
+        case TABLE:
+            NEEDBITS(14);
+            state-&gt;nlen = BITS(5) + 257;
+            DROPBITS(5);
+            state-&gt;ndist = BITS(5) + 1;
+            DROPBITS(5);
+            state-&gt;ncode = BITS(4) + 4;
+            DROPBITS(4);
+#ifndef PKZIP_BUG_WORKAROUND
+            if (state-&gt;nlen &gt; 286 || state-&gt;ndist &gt; 30) {
+                strm-&gt;msg = (char *)&quot;too many length or distance symbols&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+#endif
+            Tracev((stderr, &quot;inflate:       table sizes ok\n&quot;));
+            state-&gt;have = 0;
+            state-&gt;mode = LENLENS;
+        case LENLENS:
+            while (state-&gt;have &lt; state-&gt;ncode) {
+                NEEDBITS(3);
+                state-&gt;lens[order[state-&gt;have++]] = (unsigned short)BITS(3);
+                DROPBITS(3);
+            }
+            while (state-&gt;have &lt; 19)
+                state-&gt;lens[order[state-&gt;have++]] = 0;
+            state-&gt;next = state-&gt;codes;
+            state-&gt;lencode = (code const FAR *)(state-&gt;next);
+            state-&gt;lenbits = 7;
+            ret = inflate_table(CODES, state-&gt;lens, 19, &amp;(state-&gt;next),
+                                &amp;(state-&gt;lenbits), state-&gt;work);
+            if (ret) {
+                strm-&gt;msg = (char *)&quot;invalid code lengths set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            Tracev((stderr, &quot;inflate:       code lengths ok\n&quot;));
+            state-&gt;have = 0;
+            state-&gt;mode = CODELENS;
+        case CODELENS:
+            while (state-&gt;have &lt; state-&gt;nlen + state-&gt;ndist) {
+                for (;;) {
+                    here = state-&gt;lencode[BITS(state-&gt;lenbits)];
+                    if ((unsigned)(here.bits) &lt;= bits) break;
+                    PULLBYTE();
+                }
+                if (here.val &lt; 16) {
+                    NEEDBITS(here.bits);
+                    DROPBITS(here.bits);
+                    state-&gt;lens[state-&gt;have++] = here.val;
+                }
+                else {
+                    if (here.val == 16) {
+                        NEEDBITS(here.bits + 2);
+                        DROPBITS(here.bits);
+                        if (state-&gt;have == 0) {
+                            strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;
+                            state-&gt;mode = BAD;
+                            break;
+                        }
+                        len = state-&gt;lens[state-&gt;have - 1];
+                        copy = 3 + BITS(2);
+                        DROPBITS(2);
+                    }
+                    else if (here.val == 17) {
+                        NEEDBITS(here.bits + 3);
+                        DROPBITS(here.bits);
+                        len = 0;
+                        copy = 3 + BITS(3);
+                        DROPBITS(3);
+                    }
+                    else {
+                        NEEDBITS(here.bits + 7);
+                        DROPBITS(here.bits);
+                        len = 0;
+                        copy = 11 + BITS(7);
+                        DROPBITS(7);
+                    }
+                    if (state-&gt;have + copy &gt; state-&gt;nlen + state-&gt;ndist) {
+                        strm-&gt;msg = (char *)&quot;invalid bit length repeat&quot;;
+                        state-&gt;mode = BAD;
+                        break;
+                    }
+                    while (copy--)
+                        state-&gt;lens[state-&gt;have++] = (unsigned short)len;
+                }
+            }
+
+            /* handle error breaks in while */
+            if (state-&gt;mode == BAD) break;
+
+            /* check for end-of-block code (better have one) */
+            if (state-&gt;lens[256] == 0) {
+                strm-&gt;msg = (char *)&quot;invalid code -- missing end-of-block&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+
+            /* build code tables -- note: do not change the lenbits or distbits
+               values here (9 and 6) without reading the comments in inftrees.h
+               concerning the ENOUGH constants, which depend on those values */
+            state-&gt;next = state-&gt;codes;
+            state-&gt;lencode = (code const FAR *)(state-&gt;next);
+            state-&gt;lenbits = 9;
+            ret = inflate_table(LENS, state-&gt;lens, state-&gt;nlen, &amp;(state-&gt;next),
+                                &amp;(state-&gt;lenbits), state-&gt;work);
+            if (ret) {
+                strm-&gt;msg = (char *)&quot;invalid literal/lengths set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;distcode = (code const FAR *)(state-&gt;next);
+            state-&gt;distbits = 6;
+            ret = inflate_table(DISTS, state-&gt;lens + state-&gt;nlen, state-&gt;ndist,
+                            &amp;(state-&gt;next), &amp;(state-&gt;distbits), state-&gt;work);
+            if (ret) {
+                strm-&gt;msg = (char *)&quot;invalid distances set&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            Tracev((stderr, &quot;inflate:       codes ok\n&quot;));
+            state-&gt;mode = LEN_;
+            if (flush == Z_TREES) goto inf_leave;
+        case LEN_:
+            state-&gt;mode = LEN;
+        case LEN:
+            if (have &gt;= 6 &amp;&amp; left &gt;= 258) {
+                RESTORE();
+                inflate_fast(strm, out);
+                LOAD();
+                if (state-&gt;mode == TYPE)
+                    state-&gt;back = -1;
+                break;
+            }
+            state-&gt;back = 0;
+            for (;;) {
+                here = state-&gt;lencode[BITS(state-&gt;lenbits)];
+                if ((unsigned)(here.bits) &lt;= bits) break;
+                PULLBYTE();
+            }
+            if (here.op &amp;&amp; (here.op &amp; 0xf0) == 0) {
+                last = here;
+                for (;;) {
+                    here = state-&gt;lencode[last.val +
+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];
+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+                state-&gt;back += last.bits;
+            }
+            DROPBITS(here.bits);
+            state-&gt;back += here.bits;
+            state-&gt;length = (unsigned)here.val;
+            if ((int)(here.op) == 0) {
+                Tracevv((stderr, here.val &gt;= 0x20 &amp;&amp; here.val &lt; 0x7f ?
+                        &quot;inflate:         literal '%c'\n&quot; :
+                        &quot;inflate:         literal 0x%02x\n&quot;, here.val));
+                state-&gt;mode = LIT;
+                break;
+            }
+            if (here.op &amp; 32) {
+                Tracevv((stderr, &quot;inflate:         end of block\n&quot;));
+                state-&gt;back = -1;
+                state-&gt;mode = TYPE;
+                break;
+            }
+            if (here.op &amp; 64) {
+                strm-&gt;msg = (char *)&quot;invalid literal/length code&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;extra = (unsigned)(here.op) &amp; 15;
+            state-&gt;mode = LENEXT;
+        case LENEXT:
+            if (state-&gt;extra) {
+                NEEDBITS(state-&gt;extra);
+                state-&gt;length += BITS(state-&gt;extra);
+                DROPBITS(state-&gt;extra);
+                state-&gt;back += state-&gt;extra;
+            }
+            Tracevv((stderr, &quot;inflate:         length %u\n&quot;, state-&gt;length));
+            state-&gt;was = state-&gt;length;
+            state-&gt;mode = DIST;
+        case DIST:
+            for (;;) {
+                here = state-&gt;distcode[BITS(state-&gt;distbits)];
+                if ((unsigned)(here.bits) &lt;= bits) break;
+                PULLBYTE();
+            }
+            if ((here.op &amp; 0xf0) == 0) {
+                last = here;
+                for (;;) {
+                    here = state-&gt;distcode[last.val +
+                            (BITS(last.bits + last.op) &gt;&gt; last.bits)];
+                    if ((unsigned)(last.bits + here.bits) &lt;= bits) break;
+                    PULLBYTE();
+                }
+                DROPBITS(last.bits);
+                state-&gt;back += last.bits;
+            }
+            DROPBITS(here.bits);
+            state-&gt;back += here.bits;
+            if (here.op &amp; 64) {
+                strm-&gt;msg = (char *)&quot;invalid distance code&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+            state-&gt;offset = (unsigned)here.val;
+            state-&gt;extra = (unsigned)(here.op) &amp; 15;
+            state-&gt;mode = DISTEXT;
+        case DISTEXT:
+            if (state-&gt;extra) {
+                NEEDBITS(state-&gt;extra);
+                state-&gt;offset += BITS(state-&gt;extra);
+                DROPBITS(state-&gt;extra);
+                state-&gt;back += state-&gt;extra;
+            }
+#ifdef INFLATE_STRICT
+            if (state-&gt;offset &gt; state-&gt;dmax) {
+                strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;
+                state-&gt;mode = BAD;
+                break;
+            }
+#endif
+            Tracevv((stderr, &quot;inflate:         distance %u\n&quot;, state-&gt;offset));
+            state-&gt;mode = MATCH;
+        case MATCH:
+            if (left == 0) goto inf_leave;
+            copy = out - left;
+            if (state-&gt;offset &gt; copy) {         /* copy from window */
+                copy = state-&gt;offset - copy;
+                if (copy &gt; state-&gt;whave) {
+                    if (state-&gt;sane) {
+                        strm-&gt;msg = (char *)&quot;invalid distance too far back&quot;;
+                        state-&gt;mode = BAD;
+                        break;
+                    }
+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+                    Trace((stderr, &quot;inflate.c too far\n&quot;));
+                    copy -= state-&gt;whave;
+                    if (copy &gt; state-&gt;length) copy = state-&gt;length;
+                    if (copy &gt; left) copy = left;
+                    left -= copy;
+                    state-&gt;length -= copy;
+                    do {
+                        *put++ = 0;
+                    } while (--copy);
+                    if (state-&gt;length == 0) state-&gt;mode = LEN;
+                    break;
+#endif
+                }
+                if (copy &gt; state-&gt;wnext) {
+                    copy -= state-&gt;wnext;
+                    from = state-&gt;window + (state-&gt;wsize - copy);
+                }
+                else
+                    from = state-&gt;window + (state-&gt;wnext - copy);
+                if (copy &gt; state-&gt;length) copy = state-&gt;length;
+            }
+            else {                              /* copy from output */
+                from = put - state-&gt;offset;
+                copy = state-&gt;length;
+            }
+            if (copy &gt; left) copy = left;
+            left -= copy;
+            state-&gt;length -= copy;
+            do {
+                *put++ = *from++;
+            } while (--copy);
+            if (state-&gt;length == 0) state-&gt;mode = LEN;
+            break;
+        case LIT:
+            if (left == 0) goto inf_leave;
+            *put++ = (unsigned char)(state-&gt;length);
+            left--;
+            state-&gt;mode = LEN;
+            break;
+        case CHECK:
+            if (state-&gt;wrap) {
+                NEEDBITS(32);
+                out -= left;
+                strm-&gt;total_out += out;
+                state-&gt;total += out;
+                if (out)
+                    strm-&gt;adler = state-&gt;check =
+                        UPDATE(state-&gt;check, put - out, out);
+                out = left;
+                if ((
+#ifdef GUNZIP
+                     state-&gt;flags ? hold :
+#endif
+                     REVERSE(hold)) != state-&gt;check) {
+                    strm-&gt;msg = (char *)&quot;incorrect data check&quot;;
+                    state-&gt;mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, &quot;inflate:   check matches trailer\n&quot;));
+            }
+#ifdef GUNZIP
+            state-&gt;mode = LENGTH;
+        case LENGTH:
+            if (state-&gt;wrap &amp;&amp; state-&gt;flags) {
+                NEEDBITS(32);
+                if (hold != (state-&gt;total &amp; 0xffffffffUL)) {
+                    strm-&gt;msg = (char *)&quot;incorrect length check&quot;;
+                    state-&gt;mode = BAD;
+                    break;
+                }
+                INITBITS();
+                Tracev((stderr, &quot;inflate:   length matches trailer\n&quot;));
+            }
+#endif
+            state-&gt;mode = DONE;
+        case DONE:
+            ret = Z_STREAM_END;
+            goto inf_leave;
+        case BAD:
+            ret = Z_DATA_ERROR;
+            goto inf_leave;
+        case MEM:
+            return Z_MEM_ERROR;
+        case SYNC:
+        default:
+            return Z_STREAM_ERROR;
+        }
+
+    /*
+       Return from inflate(), updating the total counts and the check value.
+       If there was no progress during the inflate() call, return a buffer
+       error.  Call updatewindow() to create and/or update the window state.
+       Note: a memory error from inflate() is non-recoverable.
+     */
+  inf_leave:
+    RESTORE();
+    if (state-&gt;wsize || (state-&gt;mode &lt; CHECK &amp;&amp; out != strm-&gt;avail_out))
+        if (updatewindow(strm, out)) {
+            state-&gt;mode = MEM;
+            return Z_MEM_ERROR;
+        }
+    in -= strm-&gt;avail_in;
+    out -= strm-&gt;avail_out;
+    strm-&gt;total_in += in;
+    strm-&gt;total_out += out;
+    state-&gt;total += out;
+    if (state-&gt;wrap &amp;&amp; out)
+        strm-&gt;adler = state-&gt;check =
+            UPDATE(state-&gt;check, strm-&gt;next_out - out, out);
+    strm-&gt;data_type = state-&gt;bits + (state-&gt;last ? 64 : 0) +
+                      (state-&gt;mode == TYPE ? 128 : 0) +
+                      (state-&gt;mode == LEN_ || state-&gt;mode == COPY_ ? 256 : 0);
+    if (((in == 0 &amp;&amp; out == 0) || flush == Z_FINISH) &amp;&amp; ret == Z_OK)
+        ret = Z_BUF_ERROR;
+    return ret;
+}
+
+int ZEXPORT inflateEnd(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL || strm-&gt;zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    if (state-&gt;window != Z_NULL) ZFREE(strm, state-&gt;window);
+    ZFREE(strm, strm-&gt;state);
+    strm-&gt;state = Z_NULL;
+    Tracev((stderr, &quot;inflate: end\n&quot;));
+    return Z_OK;
+}
+
+int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
+z_streamp strm;
+const Bytef *dictionary;
+uInt dictLength;
+{
+    struct inflate_state FAR *state;
+    unsigned long id;
+
+    /* check state */
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    if (state-&gt;wrap != 0 &amp;&amp; state-&gt;mode != DICT)
+        return Z_STREAM_ERROR;
+
+    /* check for correct dictionary id */
+    if (state-&gt;mode == DICT) {
+        id = adler32(0L, Z_NULL, 0);
+        id = adler32(id, dictionary, dictLength);
+        if (id != state-&gt;check)
+            return Z_DATA_ERROR;
+    }
+
+    /* copy dictionary to window */
+    if (updatewindow(strm, strm-&gt;avail_out)) {
+        state-&gt;mode = MEM;
+        return Z_MEM_ERROR;
+    }
+    if (dictLength &gt; state-&gt;wsize) {
+        zmemcpy(state-&gt;window, dictionary + dictLength - state-&gt;wsize,
+                state-&gt;wsize);
+        state-&gt;whave = state-&gt;wsize;
+    }
+    else {
+        zmemcpy(state-&gt;window + state-&gt;wsize - dictLength, dictionary,
+                dictLength);
+        state-&gt;whave = dictLength;
+    }
+    state-&gt;havedict = 1;
+    Tracev((stderr, &quot;inflate:   dictionary set\n&quot;));
+    return Z_OK;
+}
+
+int ZEXPORT inflateGetHeader(strm, head)
+z_streamp strm;
+gz_headerp head;
+{
+    struct inflate_state FAR *state;
+
+    /* check state */
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    if ((state-&gt;wrap &amp; 2) == 0) return Z_STREAM_ERROR;
+
+    /* save header structure */
+    state-&gt;head = head;
+    head-&gt;done = 0;
+    return Z_OK;
+}
+
+/*
+   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
+   or when out of input.  When called, *have is the number of pattern bytes
+   found in order so far, in 0..3.  On return *have is updated to the new
+   state.  If on return *have equals four, then the pattern was found and the
+   return value is how many bytes were read including the last byte of the
+   pattern.  If *have is less than four, then the pattern has not been found
+   yet and the return value is len.  In the latter case, syncsearch() can be
+   called again with more data and the *have state.  *have is initialized to
+   zero for the first call.
+ */
+local unsigned syncsearch(have, buf, len)
+unsigned FAR *have;
+unsigned char FAR *buf;
+unsigned len;
+{
+    unsigned got;
+    unsigned next;
+
+    got = *have;
+    next = 0;
+    while (next &lt; len &amp;&amp; got &lt; 4) {
+        if ((int)(buf[next]) == (got &lt; 2 ? 0 : 0xff))
+            got++;
+        else if (buf[next])
+            got = 0;
+        else
+            got = 4 - got;
+        next++;
+    }
+    *have = got;
+    return next;
+}
+
+int ZEXPORT inflateSync(strm)
+z_streamp strm;
+{
+    unsigned len;               /* number of bytes to look at or looked at */
+    unsigned long in, out;      /* temporary to save total_in and total_out */
+    unsigned char buf[4];       /* to restore bit buffer to byte string */
+    struct inflate_state FAR *state;
+
+    /* check parameters */
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    if (strm-&gt;avail_in == 0 &amp;&amp; state-&gt;bits &lt; 8) return Z_BUF_ERROR;
+
+    /* if first time, start search in bit buffer */
+    if (state-&gt;mode != SYNC) {
+        state-&gt;mode = SYNC;
+        state-&gt;hold &lt;&lt;= state-&gt;bits &amp; 7;
+        state-&gt;bits -= state-&gt;bits &amp; 7;
+        len = 0;
+        while (state-&gt;bits &gt;= 8) {
+            buf[len++] = (unsigned char)(state-&gt;hold);
+            state-&gt;hold &gt;&gt;= 8;
+            state-&gt;bits -= 8;
+        }
+        state-&gt;have = 0;
+        syncsearch(&amp;(state-&gt;have), buf, len);
+    }
+
+    /* search available input */
+    len = syncsearch(&amp;(state-&gt;have), strm-&gt;next_in, strm-&gt;avail_in);
+    strm-&gt;avail_in -= len;
+    strm-&gt;next_in += len;
+    strm-&gt;total_in += len;
+
+    /* return no joy or set up to restart inflate() on a new block */
+    if (state-&gt;have != 4) return Z_DATA_ERROR;
+    in = strm-&gt;total_in;  out = strm-&gt;total_out;
+    inflateReset(strm);
+    strm-&gt;total_in = in;  strm-&gt;total_out = out;
+    state-&gt;mode = TYPE;
+    return Z_OK;
+}
+
+/*
+   Returns true if inflate is currently at the end of a block generated by
+   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
+   implementation to provide an additional safety check. PPP uses
+   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
+   block. When decompressing, PPP checks that at the end of input packet,
+   inflate is waiting for these length bytes.
+ */
+int ZEXPORT inflateSyncPoint(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    return state-&gt;mode == STORED &amp;&amp; state-&gt;bits == 0;
+}
+
+int ZEXPORT inflateCopy(dest, source)
+z_streamp dest;
+z_streamp source;
+{
+    struct inflate_state FAR *state;
+    struct inflate_state FAR *copy;
+    unsigned char FAR *window;
+    unsigned wsize;
+
+    /* check input */
+    if (dest == Z_NULL || source == Z_NULL || source-&gt;state == Z_NULL ||
+        source-&gt;zalloc == (alloc_func)0 || source-&gt;zfree == (free_func)0)
+        return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)source-&gt;state;
+
+    /* allocate space */
+    copy = (struct inflate_state FAR *)
+           ZALLOC(source, 1, sizeof(struct inflate_state));
+    if (copy == Z_NULL) return Z_MEM_ERROR;
+    window = Z_NULL;
+    if (state-&gt;window != Z_NULL) {
+        window = (unsigned char FAR *)
+                 ZALLOC(source, 1U &lt;&lt; state-&gt;wbits, sizeof(unsigned char));
+        if (window == Z_NULL) {
+            ZFREE(source, copy);
+            return Z_MEM_ERROR;
+        }
+    }
+
+    /* copy state */
+    zmemcpy(dest, source, sizeof(z_stream));
+    zmemcpy(copy, state, sizeof(struct inflate_state));
+    if (state-&gt;lencode &gt;= state-&gt;codes &amp;&amp;
+        state-&gt;lencode &lt;= state-&gt;codes + ENOUGH - 1) {
+        copy-&gt;lencode = copy-&gt;codes + (state-&gt;lencode - state-&gt;codes);
+        copy-&gt;distcode = copy-&gt;codes + (state-&gt;distcode - state-&gt;codes);
+    }
+    copy-&gt;next = copy-&gt;codes + (state-&gt;next - state-&gt;codes);
+    if (window != Z_NULL) {
+        wsize = 1U &lt;&lt; state-&gt;wbits;
+        zmemcpy(window, state-&gt;window, wsize);
+    }
+    copy-&gt;window = window;
+    dest-&gt;state = (struct internal_state FAR *)copy;
+    return Z_OK;
+}
+
+int ZEXPORT inflateUndermine(strm, subvert)
+z_streamp strm;
+int subvert;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return Z_STREAM_ERROR;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    state-&gt;sane = !subvert;
+#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
+    return Z_OK;
+#else
+    state-&gt;sane = 1;
+    return Z_DATA_ERROR;
+#endif
+}
+
+long ZEXPORT inflateMark(strm)
+z_streamp strm;
+{
+    struct inflate_state FAR *state;
+
+    if (strm == Z_NULL || strm-&gt;state == Z_NULL) return -1L &lt;&lt; 16;
+    state = (struct inflate_state FAR *)strm-&gt;state;
+    return ((long)(state-&gt;back) &lt;&lt; 16) +
+        (state-&gt;mode == COPY ? state-&gt;length :
+            (state-&gt;mode == MATCH ? state-&gt;was - state-&gt;length : 0));
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/inflate.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inflate.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inflate.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,122 @@
+/* inflate.h -- internal inflate state definition
+ * Copyright (C) 1995-2009 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* define NO_GZIP when compiling if you want to disable gzip header and
+   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
+   the crc code when it is not needed.  For shared libraries, gzip decoding
+   should be left enabled. */
+#ifndef NO_GZIP
+#  define GUNZIP
+#endif
+
+/* Possible inflate modes between inflate() calls */
+typedef enum {
+    HEAD,       /* i: waiting for magic header */
+    FLAGS,      /* i: waiting for method and flags (gzip) */
+    TIME,       /* i: waiting for modification time (gzip) */
+    OS,         /* i: waiting for extra flags and operating system (gzip) */
+    EXLEN,      /* i: waiting for extra length (gzip) */
+    EXTRA,      /* i: waiting for extra bytes (gzip) */
+    NAME,       /* i: waiting for end of file name (gzip) */
+    COMMENT,    /* i: waiting for end of comment (gzip) */
+    HCRC,       /* i: waiting for header crc (gzip) */
+    DICTID,     /* i: waiting for dictionary check value */
+    DICT,       /* waiting for inflateSetDictionary() call */
+        TYPE,       /* i: waiting for type bits, including last-flag bit */
+        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
+        STORED,     /* i: waiting for stored size (length and complement) */
+        COPY_,      /* i/o: same as COPY below, but only first time in */
+        COPY,       /* i/o: waiting for input or output to copy stored block */
+        TABLE,      /* i: waiting for dynamic block table lengths */
+        LENLENS,    /* i: waiting for code length code lengths */
+        CODELENS,   /* i: waiting for length/lit and distance code lengths */
+            LEN_,       /* i: same as LEN below, but only first time in */
+            LEN,        /* i: waiting for length/lit/eob code */
+            LENEXT,     /* i: waiting for length extra bits */
+            DIST,       /* i: waiting for distance code */
+            DISTEXT,    /* i: waiting for distance extra bits */
+            MATCH,      /* o: waiting for output space to copy string */
+            LIT,        /* o: waiting for output space to write literal */
+    CHECK,      /* i: waiting for 32-bit check value */
+    LENGTH,     /* i: waiting for 32-bit length (gzip) */
+    DONE,       /* finished check, done -- remain here until reset */
+    BAD,        /* got a data error -- remain here until reset */
+    MEM,        /* got an inflate() memory error -- remain here until reset */
+    SYNC        /* looking for synchronization bytes to restart inflate() */
+} inflate_mode;
+
+/*
+    State transitions between above modes -
+
+    (most modes can go to BAD or MEM on error -- not shown for clarity)
+
+    Process header:
+        HEAD -&gt; (gzip) or (zlib) or (raw)
+        (gzip) -&gt; FLAGS -&gt; TIME -&gt; OS -&gt; EXLEN -&gt; EXTRA -&gt; NAME -&gt; COMMENT -&gt;
+                  HCRC -&gt; TYPE
+        (zlib) -&gt; DICTID or TYPE
+        DICTID -&gt; DICT -&gt; TYPE
+        (raw) -&gt; TYPEDO
+    Read deflate blocks:
+            TYPE -&gt; TYPEDO -&gt; STORED or TABLE or LEN_ or CHECK
+            STORED -&gt; COPY_ -&gt; COPY -&gt; TYPE
+            TABLE -&gt; LENLENS -&gt; CODELENS -&gt; LEN_
+            LEN_ -&gt; LEN
+    Read deflate codes in fixed or dynamic block:
+                LEN -&gt; LENEXT or LIT or TYPE
+                LENEXT -&gt; DIST -&gt; DISTEXT -&gt; MATCH -&gt; LEN
+                LIT -&gt; LEN
+    Process trailer:
+        CHECK -&gt; LENGTH -&gt; DONE
+ */
+
+/* state maintained between inflate() calls.  Approximately 10K bytes. */
+struct inflate_state {
+    inflate_mode mode;          /* current inflate mode */
+    int last;                   /* true if processing last block */
+    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip */
+    int havedict;               /* true if dictionary provided */
+    int flags;                  /* gzip header method and flags (0 if zlib) */
+    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
+    unsigned long check;        /* protected copy of check value */
+    unsigned long total;        /* protected copy of output count */
+    gz_headerp head;            /* where to save gzip header information */
+        /* sliding window */
+    unsigned wbits;             /* log base 2 of requested window size */
+    unsigned wsize;             /* window size or zero if not using window */
+    unsigned whave;             /* valid bytes in the window */
+    unsigned wnext;             /* window write index */
+    unsigned char FAR *window;  /* allocated sliding window, if needed */
+        /* bit accumulator */
+    unsigned long hold;         /* input bit accumulator */
+    unsigned bits;              /* number of bits in &quot;in&quot; */
+        /* for string and stored block copying */
+    unsigned length;            /* literal or length of data to copy */
+    unsigned offset;            /* distance back to copy string from */
+        /* for table and code decoding */
+    unsigned extra;             /* extra bits needed */
+        /* fixed and dynamic code tables */
+    code const FAR *lencode;    /* starting table for length/literal codes */
+    code const FAR *distcode;   /* starting table for distance codes */
+    unsigned lenbits;           /* index bits for lencode */
+    unsigned distbits;          /* index bits for distcode */
+        /* dynamic table building */
+    unsigned ncode;             /* number of code length code lengths */
+    unsigned nlen;              /* number of length code lengths */
+    unsigned ndist;             /* number of distance code lengths */
+    unsigned have;              /* number of code lengths in lens[] */
+    code FAR *next;             /* next available space in codes[] */
+    unsigned short lens[320];   /* temporary storage for code lengths */
+    unsigned short work[288];   /* work area for code table building */
+    code codes[ENOUGH];         /* space for code tables */
+    int sane;                   /* if false, allow invalid distance too far */
+    int back;                   /* bits back of last unprocessed length/lit */
+    unsigned was;               /* initial length of match */
+};

Added: Lobby/TASClient/LobbyComponents/delphizlib/inflate.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/inflate.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/inftrees.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inftrees.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inftrees.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,330 @@
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-2010 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#include &quot;zutil.h&quot;
+#include &quot;inftrees.h&quot;
+
+#define MAXBITS 15
+
+const char inflate_copyright[] =
+   &quot; inflate 1.2.5 Copyright 1995-2010 Mark Adler &quot;;
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/*
+   Build a set of tables to decode the provided canonical Huffman code.
+   The code lengths are lens[0..codes-1].  The result starts at *table,
+   whose indices are 0..2^bits-1.  work is a writable array of at least
+   lens shorts, which is used as a work area.  type is the type of code
+   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
+   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
+   on return points to the next available entry's address.  bits is the
+   requested root table index bits, and on return it is the actual root
+   table index bits.  It will differ if the request is greater than the
+   longest code or if it is less than the shortest code.
+ */
+int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
+codetype type;
+unsigned short FAR *lens;
+unsigned codes;
+code FAR * FAR *table;
+unsigned FAR *bits;
+unsigned short FAR *work;
+{
+    unsigned len;               /* a code's length in bits */
+    unsigned sym;               /* index of code symbols */
+    unsigned min, max;          /* minimum and maximum code lengths */
+    unsigned root;              /* number of index bits for root table */
+    unsigned curr;              /* number of index bits for current table */
+    unsigned drop;              /* code bits to drop for sub-table */
+    int left;                   /* number of prefix codes available */
+    unsigned used;              /* code entries in table used */
+    unsigned huff;              /* Huffman code */
+    unsigned incr;              /* for incrementing code, index */
+    unsigned fill;              /* index for replicating entries */
+    unsigned low;               /* low bits for current root entry */
+    unsigned mask;              /* mask for low root bits */
+    code here;                  /* table entry for duplication */
+    code FAR *next;             /* next available space in table */
+    const unsigned short FAR *base;     /* base value table to use */
+    const unsigned short FAR *extra;    /* extra bits table to use */
+    int end;                    /* use base and extra for symbol &gt; end */
+    unsigned short count[MAXBITS+1];    /* number of codes of each length */
+    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
+    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
+        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
+    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577, 0, 0};
+    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
+        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
+        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
+        28, 28, 29, 29, 64, 64};
+
+    /*
+       Process a set of code lengths to create a canonical Huffman code.  The
+       code lengths are lens[0..codes-1].  Each length corresponds to the
+       symbols 0..codes-1.  The Huffman code is generated by first sorting the
+       symbols by length from short to long, and retaining the symbol order
+       for codes with equal lengths.  Then the code starts with all zero bits
+       for the first code of the shortest length, and the codes are integer
+       increments for the same length, and zeros are appended as the length
+       increases.  For the deflate format, these bits are stored backwards
+       from their more natural integer increment ordering, and so when the
+       decoding tables are built in the large loop below, the integer codes
+       are incremented backwards.
+
+       This routine assumes, but does not check, that all of the entries in
+       lens[] are in the range 0..MAXBITS.  The caller must assure this.
+       1..MAXBITS is interpreted as that code length.  zero means that that
+       symbol does not occur in this code.
+
+       The codes are sorted by computing a count of codes for each length,
+       creating from that a table of starting indices for each length in the
+       sorted table, and then entering the symbols in order in the sorted
+       table.  The sorted table is work[], with that space being provided by
+       the caller.
+
+       The length counts are used for other purposes as well, i.e. finding
+       the minimum and maximum length codes, determining if there are any
+       codes at all, checking for a valid set of lengths, and looking ahead
+       at length counts to determine sub-table sizes when building the
+       decoding tables.
+     */
+
+    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
+    for (len = 0; len &lt;= MAXBITS; len++)
+        count[len] = 0;
+    for (sym = 0; sym &lt; codes; sym++)
+        count[lens[sym]]++;
+
+    /* bound code lengths, force root to be within code lengths */
+    root = *bits;
+    for (max = MAXBITS; max &gt;= 1; max--)
+        if (count[max] != 0) break;
+    if (root &gt; max) root = max;
+    if (max == 0) {                     /* no symbols to code at all */
+        here.op = (unsigned char)64;    /* invalid code marker */
+        here.bits = (unsigned char)1;
+        here.val = (unsigned short)0;
+        *(*table)++ = here;             /* make a table to force an error */
+        *(*table)++ = here;
+        *bits = 1;
+        return 0;     /* no symbols, but wait for decoding to report error */
+    }
+    for (min = 1; min &lt; max; min++)
+        if (count[min] != 0) break;
+    if (root &lt; min) root = min;
+
+    /* check for an over-subscribed or incomplete set of lengths */
+    left = 1;
+    for (len = 1; len &lt;= MAXBITS; len++) {
+        left &lt;&lt;= 1;
+        left -= count[len];
+        if (left &lt; 0) return -1;        /* over-subscribed */
+    }
+    if (left &gt; 0 &amp;&amp; (type == CODES || max != 1))
+        return -1;                      /* incomplete set */
+
+    /* generate offsets into symbol table for each length for sorting */
+    offs[1] = 0;
+    for (len = 1; len &lt; MAXBITS; len++)
+        offs[len + 1] = offs[len] + count[len];
+
+    /* sort symbols by length, by symbol order within each length */
+    for (sym = 0; sym &lt; codes; sym++)
+        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
+
+    /*
+       Create and fill in decoding tables.  In this loop, the table being
+       filled is at next and has curr index bits.  The code being used is huff
+       with length len.  That code is converted to an index by dropping drop
+       bits off of the bottom.  For codes where len is less than drop + curr,
+       those top drop + curr - len bits are incremented through all values to
+       fill the table with replicated entries.
+
+       root is the number of index bits for the root table.  When len exceeds
+       root, sub-tables are created pointed to by the root entry with an index
+       of the low root bits of huff.  This is saved in low to check for when a
+       new sub-table should be started.  drop is zero when the root table is
+       being filled, and drop is root when sub-tables are being filled.
+
+       When a new sub-table is needed, it is necessary to look ahead in the
+       code lengths to determine what size sub-table is needed.  The length
+       counts are used for this, and so count[] is decremented as codes are
+       entered in the tables.
+
+       used keeps track of how many table entries have been allocated from the
+       provided *table space.  It is checked for LENS and DIST tables against
+       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
+       the initial root table size constants.  See the comments in inftrees.h
+       for more information.
+
+       sym increments through all symbols, and the loop terminates when
+       all codes of length max, i.e. all codes, have been processed.  This
+       routine permits incomplete codes, so another loop after this one fills
+       in the rest of the decoding tables with invalid code markers.
+     */
+
+    /* set up for code type */
+    switch (type) {
+    case CODES:
+        base = extra = work;    /* dummy value--not used */
+        end = 19;
+        break;
+    case LENS:
+        base = lbase;
+        base -= 257;
+        extra = lext;
+        extra -= 257;
+        end = 256;
+        break;
+    default:            /* DISTS */
+        base = dbase;
+        extra = dext;
+        end = -1;
+    }
+
+    /* initialize state for loop */
+    huff = 0;                   /* starting code */
+    sym = 0;                    /* starting code symbol */
+    len = min;                  /* starting code length */
+    next = *table;              /* current table to fill in */
+    curr = root;                /* current table index bits */
+    drop = 0;                   /* current bits to drop from code for index */
+    low = (unsigned)(-1);       /* trigger new sub-table when len &gt; root */
+    used = 1U &lt;&lt; root;          /* use root table entries */
+    mask = used - 1;            /* mask for comparing low */
+
+    /* check available table space */
+    if ((type == LENS &amp;&amp; used &gt;= ENOUGH_LENS) ||
+        (type == DISTS &amp;&amp; used &gt;= ENOUGH_DISTS))
+        return 1;
+
+    /* process all codes and make table entries */
+    for (;;) {
+        /* create table entry */
+        here.bits = (unsigned char)(len - drop);
+        if ((int)(work[sym]) &lt; end) {
+            here.op = (unsigned char)0;
+            here.val = work[sym];
+        }
+        else if ((int)(work[sym]) &gt; end) {
+            here.op = (unsigned char)(extra[work[sym]]);
+            here.val = base[work[sym]];
+        }
+        else {
+            here.op = (unsigned char)(32 + 64);         /* end of block */
+            here.val = 0;
+        }
+
+        /* replicate for those indices with low len bits equal to huff */
+        incr = 1U &lt;&lt; (len - drop);
+        fill = 1U &lt;&lt; curr;
+        min = fill;                 /* save offset to next table */
+        do {
+            fill -= incr;
+            next[(huff &gt;&gt; drop) + fill] = here;
+        } while (fill != 0);
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U &lt;&lt; (len - 1);
+        while (huff &amp; incr)
+            incr &gt;&gt;= 1;
+        if (incr != 0) {
+            huff &amp;= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+
+        /* go to next symbol, update count, len */
+        sym++;
+        if (--(count[len]) == 0) {
+            if (len == max) break;
+            len = lens[work[sym]];
+        }
+
+        /* create new sub-table if needed */
+        if (len &gt; root &amp;&amp; (huff &amp; mask) != low) {
+            /* if first time, transition to sub-tables */
+            if (drop == 0)
+                drop = root;
+
+            /* increment past last table */
+            next += min;            /* here min is 1 &lt;&lt; curr */
+
+            /* determine length of next table */
+            curr = len - drop;
+            left = (int)(1 &lt;&lt; curr);
+            while (curr + drop &lt; max) {
+                left -= count[curr + drop];
+                if (left &lt;= 0) break;
+                curr++;
+                left &lt;&lt;= 1;
+            }
+
+            /* check for enough space */
+            used += 1U &lt;&lt; curr;
+            if ((type == LENS &amp;&amp; used &gt;= ENOUGH_LENS) ||
+                (type == DISTS &amp;&amp; used &gt;= ENOUGH_DISTS))
+                return 1;
+
+            /* point entry in root table to sub-table */
+            low = huff &amp; mask;
+            (*table)[low].op = (unsigned char)curr;
+            (*table)[low].bits = (unsigned char)root;
+            (*table)[low].val = (unsigned short)(next - *table);
+        }
+    }
+
+    /*
+       Fill in rest of table for incomplete codes.  This loop is similar to the
+       loop above in incrementing huff for table indices.  It is assumed that
+       len is equal to curr + drop, so there is no loop needed to increment
+       through high index bits.  When the current sub-table is filled, the loop
+       drops back to the root table to fill in any remaining entries there.
+     */
+    here.op = (unsigned char)64;                /* invalid code marker */
+    here.bits = (unsigned char)(len - drop);
+    here.val = (unsigned short)0;
+    while (huff != 0) {
+        /* when done with sub-table, drop back to root table */
+        if (drop != 0 &amp;&amp; (huff &amp; mask) != low) {
+            drop = 0;
+            len = root;
+            next = *table;
+            here.bits = (unsigned char)len;
+        }
+
+        /* put invalid code marker in table */
+        next[huff &gt;&gt; drop] = here;
+
+        /* backwards increment the len-bit code huff */
+        incr = 1U &lt;&lt; (len - 1);
+        while (huff &amp; incr)
+            incr &gt;&gt;= 1;
+        if (incr != 0) {
+            huff &amp;= incr - 1;
+            huff += incr;
+        }
+        else
+            huff = 0;
+    }
+
+    /* set return parameters */
+    *table += used;
+    *bits = root;
+    return 0;
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/inftrees.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/inftrees.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/inftrees.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,62 @@
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-2005, 2010 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Structure for decoding tables.  Each entry provides either the
+   information needed to do the operation requested by the code that
+   indexed that table entry, or it provides a pointer to another
+   table that indexes more bits of the code.  op indicates whether
+   the entry is a pointer to another table, a literal, a length or
+   distance, an end-of-block, or an invalid code.  For a table
+   pointer, the low four bits of op is the number of index bits of
+   that table.  For a length or distance, the low four bits of op
+   is the number of extra bits to get after the code.  bits is
+   the number of bits in this code or part of the code to drop off
+   of the bit buffer.  val is the actual byte to output in the case
+   of a literal, the base length or distance, or the offset from
+   the current table to the next table.  Each entry is four bytes. */
+typedef struct {
+    unsigned char op;           /* operation, extra bits, table bits */
+    unsigned char bits;         /* bits in this part of the code */
+    unsigned short val;         /* offset in table or code value */
+} code;
+
+/* op values as set by inflate_table():
+    00000000 - literal
+    0000tttt - table link, tttt != 0 is the number of table index bits
+    0001eeee - length or distance, eeee is the number of extra bits
+    01100000 - end of block
+    01000000 - invalid code
+ */
+
+/* Maximum size of the dynamic table.  The maximum number of code structures is
+   1444, which is the sum of 852 for literal/length codes and 592 for distance
+   codes.  These values were found by exhaustive searches using the program
+   examples/enough.c found in the zlib distribtution.  The arguments to that
+   program are the number of symbols, the initial root table size, and the
+   maximum bit length of a code.  &quot;enough 286 9 15&quot; for literal/length codes
+   returns returns 852, and &quot;enough 30 6 15&quot; for distance codes returns 592.
+   The initial root table size (9 or 6) is found in the fifth argument of the
+   inflate_table() calls in inflate.c and infback.c.  If the root table size is
+   changed, then these maximum sizes would be need to be recalculated and
+   updated. */
+#define ENOUGH_LENS 852
+#define ENOUGH_DISTS 592
+#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
+
+/* Type of code to build for inflate_table() */
+typedef enum {
+    CODES,
+    LENS,
+    DISTS
+} codetype;
+
+int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
+                             unsigned codes, code FAR * FAR *table,
+                             unsigned FAR *bits, unsigned short FAR *work));

Added: Lobby/TASClient/LobbyComponents/delphizlib/inftrees.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/inftrees.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/readme.txt
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/readme.txt	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/readme.txt	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,302 @@
+&#239;&#187;&#191;-- notes ---------------------------------------------------------------------
+
+  the units included in this archive should work with delphi 5 through delphi
+  2010.
+
+  please contact me if you find any errors, make any changes, add new
+  functionality, or have any general suggestions so that i may incorporate
+  them into my version.  i can be reached via my website at
+
+    <A HREF="http://www.base2ti.com">http://www.base2ti.com</A>
+
+  thanks.
+  brent sherwood
+
+-- disclaimer ----------------------------------------------------------------
+
+  this software is provided &quot;as-is&quot;, without any express or implied warranty.
+  in no event will the authors be held liable for any damages arising from the
+  use of this software.
+
+  permission is granted to anyone to use this software for any purpose,
+  including commercial applications.  please do not misrepresent the origin of
+  this software.  if you use this software in a product, an acknowledgment in
+  the product documentation (readme, about box, help file, etc.) would be
+  appreciated but is not required.
+
+-- installation --------------------------------------------------------------
+
+  first, copy all of the files into a folder (for example, c:\delphi\zlib).
+  next, include the folder in the library path in the environment options.
+  finally, &quot;use&quot; the zlibex and zlibexgz units as needed.
+
+-- history -------------------------------------------------------------------
+
+  2010.07.01  zlibex.pas
+                hide overloaded Z*String* routines for delphi 5
+
+  2010.05.02  zlibex.pas
+                added ZDeflateEx and ZInflateEx
+
+  2010.04.20  zlibex.pas
+                added TZ*Buffer classes
+
+              zlibexapi.pas
+                updated to zlib version 1.2.5
+
+  2010.04.15  zlibex.pas
+                moved core zlib routines to separate unit (ZLibExApi.pas)
+
+              zlibexapi.pas
+                updated to zlib version 1.2.4
+
+  2010.01.27  zlibex.pas
+                updated for delphi 2010
+
+              zlibexgz.pas
+                updated for delphi 2010
+
+              zlibex.inc
+                updated for delphi 2010
+
+  2009.04.14  zlibex.pas
+                added overloaded string routines for AnsiString and
+                  UnicodeString
+
+              zlibexgz.pas
+                added overloaded string routines for AnsiString and
+                  UnicodeString
+                removed deprecated Z*G routines
+
+  2009.04.11  zlibex.inc
+                updated to use CONDITIONALEXPRESSIONS and CompilerVersion
+
+  2009.01.28  zlibex.pas
+                updated for delphi 2009 String (UnicodeString)
+
+              zlibexgz.pas
+                updated for delphi 2009 String (UnicodeString)
+
+              zlibex.inc
+                updated for delphi 2009
+
+  2008.05.15  zlibex.pas
+                added TStreamPos type Stream.Position variants
+                added TCustomZStream.Stream* methods
+
+              zlibexgz.pas
+                added TGZCompressionStream and TGZDecompressionStream
+
+  2007.11.06  zlibexgz.pas
+                changed TGZTrailer.Crc from Cardinal to Longint
+
+  2007.10.01  zlibexgz.pas
+                added GZDecompressStreamSize
+                fixed GZDecompressStream position handling
+
+              zlibex.inc
+                updated for delphi 2007
+
+  2007.08.17  zlibex.pas
+                modified TZCompressionStream.Write to use Write instead of
+                  WriteBuffer
+
+  2007.07.18  zlibexgz.pas
+                fixed GZCompressStr filename and comment processing
+
+  2007.03.18  zlibexgz.pas
+                modified naming convention for gzip routines GZ*
+                deprecated previous gzip routines Z*G
+
+  2007.03.15  zlibex.pas
+                moved gzip routines to separate unit - zlibexgz.pas
+
+              zlibexgz.pas
+                added ZDecompressStreamG
+                added overloaded ZCompressStrG
+                added overloaded ZCompressStreamG
+
+  2007.02.24  zlibex.pas
+                added PWord declaration for delphi 5-
+
+  2006.10.07  zlibex.pas
+                fixed EZLibError constructor for c++ builder compatibility
+
+  2006.08.10  zlibex.pas
+                added ZDecompressStrG (simple gzip format)
+
+  2006.06.02  zlibex.pas
+                added DateTimeToUnix for delphi 5-
+
+  2006.03.28  zlibex.pas
+                moved Z_DEFLATED to interface section
+                added custom compression levels zcLevel1 thru zcLevel9
+
+  2006.03.27  zlibex.pas
+                added ZCompressStreamWeb
+                added ZCompressStreamG (simple gzip format)
+
+  2006.03.24  zlibex.pas
+                added ZCompressStrG (simple gzip format)
+                added ZAdler32 and ZCrc32
+
+  2005.11.29  zlibex.pas
+                changed FStreamPos to Int64 for delphi 6+
+
+  2005.07.25  zlibex.pas
+                updated to zlib version 1.2.3
+
+  2005.03.04  zlibex.pas
+                modified ZInternalCompressStream loops
+                modified ZInternalDecompressStream loops
+
+  2005.02.07  zlibex.pas
+                fixed ZInternalCompressStream loop conditions
+                fixed ZInternalDecompressStream loop conditions
+
+  2005.01.11  zlibex.pas
+                updated to zlib version 1.2.2
+                added ZCompressStrWeb
+
+  2004.01.06  zlibex.pas
+                updated to zlib version 1.2.1
+
+  2003.04.14  zlibex.pas
+                added ZCompress2 and ZDecompress2
+                added ZCompressStr2 and ZDecompressStr2
+                added ZCompressStream2 and ZDecompressStream2
+                added overloaded T*Stream constructors to support InflateInit2
+                  and DeflateInit2
+                fixed ZDecompressStream to use ZDecompressCheck instead of
+                  ZCompressCheck
+
+  2002.03.15  zlibex.pas
+                updated to zlib version 1.1.4
+
+  2001.11.27  zlibex.pas
+                enhanced TZDecompressionStream.Read to adjust source stream
+                  position upon end of compression data
+                fixed endless loop in TZDecompressionStream.Read when
+                  destination count was greater than uncompressed data
+
+  2001.10.26  zlibex.pas
+                renamed unit to integrate &quot;nicely&quot; with delphi 6
+
+  2000.11.24  zlib.pas
+                added soFromEnd condition to TZDecompressionStream.Seek
+                added ZCompressStream and ZDecompressStream
+
+  2000.06.13  zlib.pas
+                optimized, fixed, rewrote, and enhanced the zlib.pas unit
+                  included on the delphi cd (zlib version 1.1.3)
+
+-- acknowledgments -----------------------------------------------------------
+
+  erik turner - thanks for the enhancements and recommendations.
+    specifically, the ZCompressionStream and ZDecompressionStream routines.
+    my apologies for the delay in getting these in here.
+
+  david bennion - thanks for finding that nasty little endless loop quirk
+    with the TZDecompressionStream.Read method.
+
+  burak kalayci - thanks for emailing to inform me about the zlib 1.1.4
+    update; and again for emailing about 1.2.1.
+
+  vicente s&#195;&#161;nchez-alarcos - thanks for emailing to inform me about the zlib
+    1.2.2 update.
+
+  luigi sandon - thanks for pointing out the missing loop condition
+    (Z_STREAM_END) in ZInternalCompressStream and ZInternalDecompressStream.
+
+  ferry van genderen - thanks for assisting me fine tune and beta test the
+    ZInternalCompressStream and ZInternalDecompressStream routines.
+
+  mathijs van veluw - thanks for emailing to inform me about the zlib 1.2.3
+    update.
+
+  j. rathlev - thanks for pointing out the FStreamPos and TStream.Position
+    type inconsistency.
+
+  ralf wenske - thanks for prototyping and assisting with ZCompressStrG and
+    ZCompressStreamG.
+
+  roman krupicka - thanks for pointing out the DateUtils unit and the
+    DateTimeToUnix function wasn't available prior to delphi 6.
+
+  anders johansen - thanks for pointing out the ELibError constructor
+    incompatibility with c++ builder.
+
+  marcin treffler - thanks for pointing out the missing PWord declaration for
+    delphi 5.
+
+  jean-jacques esquirol - thanks for pointing out the &quot;result&quot; address issue
+    when processing filename and comment flags/content in GZCompressStr; and
+    for pointing out the type differences with TGZTrailer.Crc (Cardinal) and
+    ZCrc32 (Longint).
+
+  graham wideman - thanks for beta testing GZDecompressStreamSize and pointing
+    out the position handling issue in GZDecompressStream.
+
+  marcin szafra&#197;&#132;ski - thanks for beta testing the delphi 2009 changes.
+
+  iztok kacin - thanks for the CONDITIONALEXPRESSIONS, CompilerVersion
+    changes, and assisting me design and further improve support for delphi
+    2009.
+
+  oleg matrozov - thanks for pointing out the missing loop condition
+    (avail_in &gt; 0) in ZInternalCompress and ZInternalDecompress; and for
+    prototyping and assisting with the TZ*Buffer classes.
+
+  edward koo - thanks for pointing out the delphi 5 incompatibility with the
+   overloaded Z*String* routines.
+
+-- contents ------------------------------------------------------------------
+
+  delphi files
+
+    zlibex.inc
+    zlibex.pas
+    zlibexapi.pas
+    zlibexgz.pas
+
+  objects files used by zlibex.pas
+
+    adler32.obj
+    compress.obj
+    crc32.obj
+    deflate.obj
+    infback.obj
+    inffast.obj
+    inflate.obj
+    inftrees.obj
+    trees.obj
+
+  c++ builder 2007 files
+
+    delphizlib.bpr
+    delphizlib.cbproj
+    delphizlib.cpp
+
+  zlib 1.2.4 source files (<A HREF="http://www.zlib.net">http://www.zlib.net</A>)
+
+    adler32.c
+    compress.c
+    crc32.c
+    deflate.c
+    infback.c
+    inffast.c
+    inflate.c
+    inftrees.c
+    trees.c
+    zutil.c
+    crc32.h
+    deflate.h
+    inffast.h
+    inffixed.h
+    inflate.h
+    inftrees.h
+    trees.h
+    zconf.h
+    zlib.h
+    zutil.h
+

Added: Lobby/TASClient/LobbyComponents/delphizlib/trees.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/trees.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/trees.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,1244 @@
+/* trees.c -- output deflated data using Huffman coding
+ * Copyright (C) 1995-2010 Jean-loup Gailly
+ * detect_data_type() function provided freely by Cosmin Truta, 2006
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The &quot;deflation&quot; process uses several Huffman trees. The more
+ *      common source values are represented by shorter bit sequences.
+ *
+ *      Each code tree is stored in a compressed form which is itself
+ * a Huffman encoding of the lengths of all the code strings (in
+ * ascending order by source values).  The actual code strings are
+ * reconstructed from the lengths in the inflate process, as described
+ * in the deflate specification.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,&quot;'Deflate' Compressed Data Format Specification&quot;.
+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
+ *
+ *      Storer, James A.
+ *          Data Compression:  Methods and Theory, pp. 49-50.
+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
+ *
+ *      Sedgewick, R.
+ *          Algorithms, p290.
+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
+ */
+
+/* @(#) $Id$ */
+
+/* #define GEN_TREES_H */
+
+#include &quot;deflate.h&quot;
+
+#ifdef DEBUG
+#  include &lt;ctype.h&gt;
+#endif
+
+/* ===========================================================================
+ * Constants
+ */
+
+#define MAX_BL_BITS 7
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+#define END_BLOCK 256
+/* end of block literal code */
+
+#define REP_3_6      16
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+#define REPZ_3_10    17
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+#define REPZ_11_138  18
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+
+local const int extra_dbits[D_CODES] /* extra bits for each distance code */
+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+
+local const uch bl_order[BL_CODES]
+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+#define Buf_size (8 * 2*sizeof(char))
+/* Number of bits used within bi_buf. (bi_buf might be implemented on
+ * more than 16 bits on some systems.)
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+/* non ANSI compilers may not accept trees.h */
+
+local ct_data static_ltree[L_CODES+2];
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+local ct_data static_dtree[D_CODES];
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+uch _dist_code[DIST_CODE_LEN];
+/* Distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+uch _length_code[MAX_MATCH-MIN_MATCH+1];
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+local int base_length[LENGTH_CODES];
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+local int base_dist[D_CODES];
+/* First normalized distance for each code (0 = distance of 1) */
+
+#else
+#  include &quot;trees.h&quot;
+#endif /* GEN_TREES_H */
+
+struct static_tree_desc_s {
+    const ct_data *static_tree;  /* static tree or NULL */
+    const intf *extra_bits;      /* extra bits for each code or NULL */
+    int     extra_base;          /* base index for extra_bits */
+    int     elems;               /* max number of elements in the tree */
+    int     max_length;          /* max bit length for the codes */
+};
+
+local static_tree_desc  static_l_desc =
+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+
+local static_tree_desc  static_d_desc =
+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+
+local static_tree_desc  static_bl_desc =
+{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
+
+/* ===========================================================================
+ * Local (static) routines in this file.
+ */
+
+local void tr_static_init OF((void));
+local void init_block     OF((deflate_state *s));
+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
+local void build_tree     OF((deflate_state *s, tree_desc *desc));
+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local int  build_bl_tree  OF((deflate_state *s));
+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+                              int blcodes));
+local void compress_block OF((deflate_state *s, ct_data *ltree,
+                              ct_data *dtree));
+local int  detect_data_type OF((deflate_state *s));
+local unsigned bi_reverse OF((unsigned value, int length));
+local void bi_windup      OF((deflate_state *s));
+local void bi_flush       OF((deflate_state *s));
+local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+                              int header));
+
+#ifdef GEN_TREES_H
+local void gen_trees_header OF((void));
+#endif
+
+#ifndef DEBUG
+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+   /* Send a code of the given tree. c and tree must not have side effects */
+
+#else /* DEBUG */
+#  define send_code(s, c, tree) \
+     { if (z_verbose&gt;2) fprintf(stderr,&quot;\ncd %3d &quot;,(c)); \
+       send_bits(s, tree[c].Code, tree[c].Len); }
+#endif
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+#define put_short(s, w) { \
+    put_byte(s, (uch)((w) &amp; 0xff)); \
+    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \
+}
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length &lt;= 16 and value fits in length bits.
+ */
+#ifdef DEBUG
+local void send_bits      OF((deflate_state *s, int value, int length));
+
+local void send_bits(s, value, length)
+    deflate_state *s;
+    int value;  /* value to send */
+    int length; /* number of bits */
+{
+    Tracevv((stderr,&quot; l %2d v %4x &quot;, length, value));
+    Assert(length &gt; 0 &amp;&amp; length &lt;= 15, &quot;invalid length&quot;);
+    s-&gt;bits_sent += (ulg)length;
+
+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
+     * unused bits in value.
+     */
+    if (s-&gt;bi_valid &gt; (int)Buf_size - length) {
+        s-&gt;bi_buf |= (ush)value &lt;&lt; s-&gt;bi_valid;
+        put_short(s, s-&gt;bi_buf);
+        s-&gt;bi_buf = (ush)value &gt;&gt; (Buf_size - s-&gt;bi_valid);
+        s-&gt;bi_valid += length - Buf_size;
+    } else {
+        s-&gt;bi_buf |= (ush)value &lt;&lt; s-&gt;bi_valid;
+        s-&gt;bi_valid += length;
+    }
+}
+#else /* !DEBUG */
+
+#define send_bits(s, value, length) \
+{ int len = length;\
+  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\
+    int val = value;\
+    s-&gt;bi_buf |= (ush)val &lt;&lt; s-&gt;bi_valid;\
+    put_short(s, s-&gt;bi_buf);\
+    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\
+    s-&gt;bi_valid += len - Buf_size;\
+  } else {\
+    s-&gt;bi_buf |= (ush)(value) &lt;&lt; s-&gt;bi_valid;\
+    s-&gt;bi_valid += len;\
+  }\
+}
+#endif /* DEBUG */
+
+
+/* the arguments must not have side effects */
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables.
+ */
+local void tr_static_init()
+{
+#if defined(GEN_TREES_H) || !defined(STDC)
+    static int static_init_done = 0;
+    int n;        /* iterates over tree elements */
+    int bits;     /* bit counter */
+    int length;   /* length value */
+    int code;     /* code value */
+    int dist;     /* distance index */
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    if (static_init_done) return;
+
+    /* For some embedded targets, global variables are not initialized: */
+#ifdef NO_INIT_GLOBAL_POINTERS
+    static_l_desc.static_tree = static_ltree;
+    static_l_desc.extra_bits = extra_lbits;
+    static_d_desc.static_tree = static_dtree;
+    static_d_desc.extra_bits = extra_dbits;
+    static_bl_desc.extra_bits = extra_blbits;
+#endif
+
+    /* Initialize the mapping length (0..255) -&gt; length code (0..28) */
+    length = 0;
+    for (code = 0; code &lt; LENGTH_CODES-1; code++) {
+        base_length[code] = length;
+        for (n = 0; n &lt; (1&lt;&lt;extra_lbits[code]); n++) {
+            _length_code[length++] = (uch)code;
+        }
+    }
+    Assert (length == 256, &quot;tr_static_init: length != 256&quot;);
+    /* Note that the length 255 (match length 258) can be represented
+     * in two different ways: code 284 + 5 bits or code 285, so we
+     * overwrite length_code[255] to use the best encoding:
+     */
+    _length_code[length-1] = (uch)code;
+
+    /* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */
+    dist = 0;
+    for (code = 0 ; code &lt; 16; code++) {
+        base_dist[code] = dist;
+        for (n = 0; n &lt; (1&lt;&lt;extra_dbits[code]); n++) {
+            _dist_code[dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, &quot;tr_static_init: dist != 256&quot;);
+    dist &gt;&gt;= 7; /* from now on, all distances are divided by 128 */
+    for ( ; code &lt; D_CODES; code++) {
+        base_dist[code] = dist &lt;&lt; 7;
+        for (n = 0; n &lt; (1&lt;&lt;(extra_dbits[code]-7)); n++) {
+            _dist_code[256 + dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, &quot;tr_static_init: 256+dist != 512&quot;);
+
+    /* Construct the codes of the static literal tree */
+    for (bits = 0; bits &lt;= MAX_BITS; bits++) bl_count[bits] = 0;
+    n = 0;
+    while (n &lt;= 143) static_ltree[n++].Len = 8, bl_count[8]++;
+    while (n &lt;= 255) static_ltree[n++].Len = 9, bl_count[9]++;
+    while (n &lt;= 279) static_ltree[n++].Len = 7, bl_count[7]++;
+    while (n &lt;= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+    /* Codes 286 and 287 do not exist, but we must include them in the
+     * tree construction to get a canonical Huffman tree (longest code
+     * all ones)
+     */
+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+
+    /* The static distance tree is trivial: */
+    for (n = 0; n &lt; D_CODES; n++) {
+        static_dtree[n].Len = 5;
+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
+    }
+    static_init_done = 1;
+
+#  ifdef GEN_TREES_H
+    gen_trees_header();
+#  endif
+#endif /* defined(GEN_TREES_H) || !defined(STDC) */
+}
+
+/* ===========================================================================
+ * Genererate the file trees.h describing the static trees.
+ */
+#ifdef GEN_TREES_H
+#  ifndef DEBUG
+#    include &lt;stdio.h&gt;
+#  endif
+
+#  define SEPARATOR(i, last, width) \
+      ((i) == (last)? &quot;\n};\n\n&quot; :    \
+       ((i) % (width) == (width)-1 ? &quot;,\n&quot; : &quot;, &quot;))
+
+void gen_trees_header()
+{
+    FILE *header = fopen(&quot;trees.h&quot;, &quot;w&quot;);
+    int i;
+
+    Assert (header != NULL, &quot;Can't open trees.h&quot;);
+    fprintf(header,
+            &quot;/* header created automatically with -DGEN_TREES_H */\n\n&quot;);
+
+    fprintf(header, &quot;local const ct_data static_ltree[L_CODES+2] = {\n&quot;);
+    for (i = 0; i &lt; L_CODES+2; i++) {
+        fprintf(header, &quot;{{%3u},{%3u}}%s&quot;, static_ltree[i].Code,
+                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
+    }
+
+    fprintf(header, &quot;local const ct_data static_dtree[D_CODES] = {\n&quot;);
+    for (i = 0; i &lt; D_CODES; i++) {
+        fprintf(header, &quot;{{%2u},{%2u}}%s&quot;, static_dtree[i].Code,
+                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
+    }
+
+    fprintf(header, &quot;const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n&quot;);
+    for (i = 0; i &lt; DIST_CODE_LEN; i++) {
+        fprintf(header, &quot;%2u%s&quot;, _dist_code[i],
+                SEPARATOR(i, DIST_CODE_LEN-1, 20));
+    }
+
+    fprintf(header,
+        &quot;const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n&quot;);
+    for (i = 0; i &lt; MAX_MATCH-MIN_MATCH+1; i++) {
+        fprintf(header, &quot;%2u%s&quot;, _length_code[i],
+                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
+    }
+
+    fprintf(header, &quot;local const int base_length[LENGTH_CODES] = {\n&quot;);
+    for (i = 0; i &lt; LENGTH_CODES; i++) {
+        fprintf(header, &quot;%1u%s&quot;, base_length[i],
+                SEPARATOR(i, LENGTH_CODES-1, 20));
+    }
+
+    fprintf(header, &quot;local const int base_dist[D_CODES] = {\n&quot;);
+    for (i = 0; i &lt; D_CODES; i++) {
+        fprintf(header, &quot;%5u%s&quot;, base_dist[i],
+                SEPARATOR(i, D_CODES-1, 10));
+    }
+
+    fclose(header);
+}
+#endif /* GEN_TREES_H */
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+void ZLIB_INTERNAL _tr_init(s)
+    deflate_state *s;
+{
+    tr_static_init();
+
+    s-&gt;l_desc.dyn_tree = s-&gt;dyn_ltree;
+    s-&gt;l_desc.stat_desc = &amp;static_l_desc;
+
+    s-&gt;d_desc.dyn_tree = s-&gt;dyn_dtree;
+    s-&gt;d_desc.stat_desc = &amp;static_d_desc;
+
+    s-&gt;bl_desc.dyn_tree = s-&gt;bl_tree;
+    s-&gt;bl_desc.stat_desc = &amp;static_bl_desc;
+
+    s-&gt;bi_buf = 0;
+    s-&gt;bi_valid = 0;
+    s-&gt;last_eob_len = 8; /* enough lookahead for inflate */
+#ifdef DEBUG
+    s-&gt;compressed_len = 0L;
+    s-&gt;bits_sent = 0L;
+#endif
+
+    /* Initialize the first block of the first file: */
+    init_block(s);
+}
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+local void init_block(s)
+    deflate_state *s;
+{
+    int n; /* iterates over tree elements */
+
+    /* Initialize the trees. */
+    for (n = 0; n &lt; L_CODES;  n++) s-&gt;dyn_ltree[n].Freq = 0;
+    for (n = 0; n &lt; D_CODES;  n++) s-&gt;dyn_dtree[n].Freq = 0;
+    for (n = 0; n &lt; BL_CODES; n++) s-&gt;bl_tree[n].Freq = 0;
+
+    s-&gt;dyn_ltree[END_BLOCK].Freq = 1;
+    s-&gt;opt_len = s-&gt;static_len = 0L;
+    s-&gt;last_lit = s-&gt;matches = 0;
+}
+
+#define SMALLEST 1
+/* Index within the heap array of least frequent node in the Huffman tree */
+
+
+/* ===========================================================================
+ * Remove the smallest element from the heap and recreate the heap with
+ * one less element. Updates heap and heap_len.
+ */
+#define pqremove(s, tree, top) \
+{\
+    top = s-&gt;heap[SMALLEST]; \
+    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \
+    pqdownheap(s, tree, SMALLEST); \
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+#define smaller(tree, n, m, depth) \
+   (tree[n].Freq &lt; tree[m].Freq || \
+   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+local void pqdownheap(s, tree, k)
+    deflate_state *s;
+    ct_data *tree;  /* the tree to restore */
+    int k;               /* node to move down */
+{
+    int v = s-&gt;heap[k];
+    int j = k &lt;&lt; 1;  /* left son of k */
+    while (j &lt;= s-&gt;heap_len) {
+        /* Set j to the smallest of the two sons: */
+        if (j &lt; s-&gt;heap_len &amp;&amp;
+            smaller(tree, s-&gt;heap[j+1], s-&gt;heap[j], s-&gt;depth)) {
+            j++;
+        }
+        /* Exit if v is smaller than both sons */
+        if (smaller(tree, v, s-&gt;heap[j], s-&gt;depth)) break;
+
+        /* Exchange v with the smallest son */
+        s-&gt;heap[k] = s-&gt;heap[j];  k = j;
+
+        /* And continue down the tree, setting j to the left son of k */
+        j &lt;&lt;= 1;
+    }
+    s-&gt;heap[k] = v;
+}
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+local void gen_bitlen(s, desc)
+    deflate_state *s;
+    tree_desc *desc;    /* the tree descriptor */
+{
+    ct_data *tree        = desc-&gt;dyn_tree;
+    int max_code         = desc-&gt;max_code;
+    const ct_data *stree = desc-&gt;stat_desc-&gt;static_tree;
+    const intf *extra    = desc-&gt;stat_desc-&gt;extra_bits;
+    int base             = desc-&gt;stat_desc-&gt;extra_base;
+    int max_length       = desc-&gt;stat_desc-&gt;max_length;
+    int h;              /* heap index */
+    int n, m;           /* iterate over the tree elements */
+    int bits;           /* bit length */
+    int xbits;          /* extra bits */
+    ush f;              /* frequency */
+    int overflow = 0;   /* number of elements with bit length too large */
+
+    for (bits = 0; bits &lt;= MAX_BITS; bits++) s-&gt;bl_count[bits] = 0;
+
+    /* In a first pass, compute the optimal bit lengths (which may
+     * overflow in the case of the bit length tree).
+     */
+    tree[s-&gt;heap[s-&gt;heap_max]].Len = 0; /* root of the heap */
+
+    for (h = s-&gt;heap_max+1; h &lt; HEAP_SIZE; h++) {
+        n = s-&gt;heap[h];
+        bits = tree[tree[n].Dad].Len + 1;
+        if (bits &gt; max_length) bits = max_length, overflow++;
+        tree[n].Len = (ush)bits;
+        /* We overwrite tree[n].Dad which is no longer needed */
+
+        if (n &gt; max_code) continue; /* not a leaf node */
+
+        s-&gt;bl_count[bits]++;
+        xbits = 0;
+        if (n &gt;= base) xbits = extra[n-base];
+        f = tree[n].Freq;
+        s-&gt;opt_len += (ulg)f * (bits + xbits);
+        if (stree) s-&gt;static_len += (ulg)f * (stree[n].Len + xbits);
+    }
+    if (overflow == 0) return;
+
+    Trace((stderr,&quot;\nbit length overflow\n&quot;));
+    /* This happens for example on obj2 and pic of the Calgary corpus */
+
+    /* Find the first bit length which could increase: */
+    do {
+        bits = max_length-1;
+        while (s-&gt;bl_count[bits] == 0) bits--;
+        s-&gt;bl_count[bits]--;      /* move one leaf down the tree */
+        s-&gt;bl_count[bits+1] += 2; /* move one overflow item as its brother */
+        s-&gt;bl_count[max_length]--;
+        /* The brother of the overflow item also moves one step up,
+         * but this does not affect bl_count[max_length]
+         */
+        overflow -= 2;
+    } while (overflow &gt; 0);
+
+    /* Now recompute all bit lengths, scanning in increasing frequency.
+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+     * lengths instead of fixing only the wrong ones. This idea is taken
+     * from 'ar' written by Haruhiko Okumura.)
+     */
+    for (bits = max_length; bits != 0; bits--) {
+        n = s-&gt;bl_count[bits];
+        while (n != 0) {
+            m = s-&gt;heap[--h];
+            if (m &gt; max_code) continue;
+            if ((unsigned) tree[m].Len != (unsigned) bits) {
+                Trace((stderr,&quot;code %d bits %d-&gt;%d\n&quot;, m, tree[m].Len, bits));
+                s-&gt;opt_len += ((long)bits - (long)tree[m].Len)
+                              *(long)tree[m].Freq;
+                tree[m].Len = (ush)bits;
+            }
+            n--;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+local void gen_codes (tree, max_code, bl_count)
+    ct_data *tree;             /* the tree to decorate */
+    int max_code;              /* largest code with non zero frequency */
+    ushf *bl_count;            /* number of codes at each bit length */
+{
+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+    ush code = 0;              /* running code value */
+    int bits;                  /* bit index */
+    int n;                     /* code index */
+
+    /* The distribution counts are first used to generate the code values
+     * without bit reversal.
+     */
+    for (bits = 1; bits &lt;= MAX_BITS; bits++) {
+        next_code[bits] = code = (code + bl_count[bits-1]) &lt;&lt; 1;
+    }
+    /* Check that the bit counts in bl_count are consistent. The last code
+     * must be all ones.
+     */
+    Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,
+            &quot;inconsistent bit counts&quot;);
+    Tracev((stderr,&quot;\ngen_codes: max_code %d &quot;, max_code));
+
+    for (n = 0;  n &lt;= max_code; n++) {
+        int len = tree[n].Len;
+        if (len == 0) continue;
+        /* Now reverse the bits */
+        tree[n].Code = bi_reverse(next_code[len]++, len);
+
+        Tracecv(tree != static_ltree, (stderr,&quot;\nn %3d %c l %2d c %4x (%x) &quot;,
+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+    }
+}
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+local void build_tree(s, desc)
+    deflate_state *s;
+    tree_desc *desc; /* the tree descriptor */
+{
+    ct_data *tree         = desc-&gt;dyn_tree;
+    const ct_data *stree  = desc-&gt;stat_desc-&gt;static_tree;
+    int elems             = desc-&gt;stat_desc-&gt;elems;
+    int n, m;          /* iterate over heap elements */
+    int max_code = -1; /* largest code with non zero frequency */
+    int node;          /* new node being created */
+
+    /* Construct the initial heap, with least frequent element in
+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+     * heap[0] is not used.
+     */
+    s-&gt;heap_len = 0, s-&gt;heap_max = HEAP_SIZE;
+
+    for (n = 0; n &lt; elems; n++) {
+        if (tree[n].Freq != 0) {
+            s-&gt;heap[++(s-&gt;heap_len)] = max_code = n;
+            s-&gt;depth[n] = 0;
+        } else {
+            tree[n].Len = 0;
+        }
+    }
+
+    /* The pkzip format requires that at least one distance code exists,
+     * and that at least one bit should be sent even if there is only one
+     * possible code. So to avoid special checks later on we force at least
+     * two codes of non zero frequency.
+     */
+    while (s-&gt;heap_len &lt; 2) {
+        node = s-&gt;heap[++(s-&gt;heap_len)] = (max_code &lt; 2 ? ++max_code : 0);
+        tree[node].Freq = 1;
+        s-&gt;depth[node] = 0;
+        s-&gt;opt_len--; if (stree) s-&gt;static_len -= stree[node].Len;
+        /* node is 0 or 1 so it does not have extra bits */
+    }
+    desc-&gt;max_code = max_code;
+
+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+     * establish sub-heaps of increasing lengths:
+     */
+    for (n = s-&gt;heap_len/2; n &gt;= 1; n--) pqdownheap(s, tree, n);
+
+    /* Construct the Huffman tree by repeatedly combining the least two
+     * frequent nodes.
+     */
+    node = elems;              /* next internal node of the tree */
+    do {
+        pqremove(s, tree, n);  /* n = node of least frequency */
+        m = s-&gt;heap[SMALLEST]; /* m = node of next least frequency */
+
+        s-&gt;heap[--(s-&gt;heap_max)] = n; /* keep the nodes sorted by frequency */
+        s-&gt;heap[--(s-&gt;heap_max)] = m;
+
+        /* Create a new node father of n and m */
+        tree[node].Freq = tree[n].Freq + tree[m].Freq;
+        s-&gt;depth[node] = (uch)((s-&gt;depth[n] &gt;= s-&gt;depth[m] ?
+                                s-&gt;depth[n] : s-&gt;depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (ush)node;
+#ifdef DUMP_BL_TREE
+        if (tree == s-&gt;bl_tree) {
+            fprintf(stderr,&quot;\nnode %d(%d), sons %d(%d) %d(%d)&quot;,
+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+        }
+#endif
+        /* and insert the new node in the heap */
+        s-&gt;heap[SMALLEST] = node++;
+        pqdownheap(s, tree, SMALLEST);
+
+    } while (s-&gt;heap_len &gt;= 2);
+
+    s-&gt;heap[--(s-&gt;heap_max)] = s-&gt;heap[SMALLEST];
+
+    /* At this point, the fields freq and dad are set. We can now
+     * generate the bit lengths.
+     */
+    gen_bitlen(s, (tree_desc *)desc);
+
+    /* The field len is now set, we can generate the bit codes */
+    gen_codes ((ct_data *)tree, max_code, s-&gt;bl_count);
+}
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+local void scan_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree;   /* the tree to be scanned */
+    int max_code;    /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    if (nextlen == 0) max_count = 138, min_count = 3;
+    tree[max_code+1].Len = (ush)0xffff; /* guard */
+
+    for (n = 0; n &lt;= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count &lt; max_count &amp;&amp; curlen == nextlen) {
+            continue;
+        } else if (count &lt; min_count) {
+            s-&gt;bl_tree[curlen].Freq += count;
+        } else if (curlen != 0) {
+            if (curlen != prevlen) s-&gt;bl_tree[curlen].Freq++;
+            s-&gt;bl_tree[REP_3_6].Freq++;
+        } else if (count &lt;= 10) {
+            s-&gt;bl_tree[REPZ_3_10].Freq++;
+        } else {
+            s-&gt;bl_tree[REPZ_11_138].Freq++;
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+local void send_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree; /* the tree to be scanned */
+    int max_code;       /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    /* tree[max_code+1].Len = -1; */  /* guard already set */
+    if (nextlen == 0) max_count = 138, min_count = 3;
+
+    for (n = 0; n &lt;= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count &lt; max_count &amp;&amp; curlen == nextlen) {
+            continue;
+        } else if (count &lt; min_count) {
+            do { send_code(s, curlen, s-&gt;bl_tree); } while (--count != 0);
+
+        } else if (curlen != 0) {
+            if (curlen != prevlen) {
+                send_code(s, curlen, s-&gt;bl_tree); count--;
+            }
+            Assert(count &gt;= 3 &amp;&amp; count &lt;= 6, &quot; 3_6?&quot;);
+            send_code(s, REP_3_6, s-&gt;bl_tree); send_bits(s, count-3, 2);
+
+        } else if (count &lt;= 10) {
+            send_code(s, REPZ_3_10, s-&gt;bl_tree); send_bits(s, count-3, 3);
+
+        } else {
+            send_code(s, REPZ_11_138, s-&gt;bl_tree); send_bits(s, count-11, 7);
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+local int build_bl_tree(s)
+    deflate_state *s;
+{
+    int max_blindex;  /* index of last bit length code of non zero freq */
+
+    /* Determine the bit length frequencies for literal and distance trees */
+    scan_tree(s, (ct_data *)s-&gt;dyn_ltree, s-&gt;l_desc.max_code);
+    scan_tree(s, (ct_data *)s-&gt;dyn_dtree, s-&gt;d_desc.max_code);
+
+    /* Build the bit length tree: */
+    build_tree(s, (tree_desc *)(&amp;(s-&gt;bl_desc)));
+    /* opt_len now includes the length of the tree representations, except
+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+     */
+
+    /* Determine the number of bit length codes to send. The pkzip format
+     * requires that at least 4 bit length codes be sent. (appnote.txt says
+     * 3 but the actual value used is 4.)
+     */
+    for (max_blindex = BL_CODES-1; max_blindex &gt;= 3; max_blindex--) {
+        if (s-&gt;bl_tree[bl_order[max_blindex]].Len != 0) break;
+    }
+    /* Update opt_len to include the bit length tree and counts */
+    s-&gt;opt_len += 3*(max_blindex+1) + 5+5+4;
+    Tracev((stderr, &quot;\ndyn trees: dyn %ld, stat %ld&quot;,
+            s-&gt;opt_len, s-&gt;static_len));
+
+    return max_blindex;
+}
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.
+ */
+local void send_all_trees(s, lcodes, dcodes, blcodes)
+    deflate_state *s;
+    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+    int rank;                    /* index in bl_order */
+
+    Assert (lcodes &gt;= 257 &amp;&amp; dcodes &gt;= 1 &amp;&amp; blcodes &gt;= 4, &quot;not enough codes&quot;);
+    Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,
+            &quot;too many codes&quot;);
+    Tracev((stderr, &quot;\nbl counts: &quot;));
+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
+    send_bits(s, dcodes-1,   5);
+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+    for (rank = 0; rank &lt; blcodes; rank++) {
+        Tracev((stderr, &quot;\nbl code %2d &quot;, bl_order[rank]));
+        send_bits(s, s-&gt;bl_tree[bl_order[rank]].Len, 3);
+    }
+    Tracev((stderr, &quot;\nbl tree: sent %ld&quot;, s-&gt;bits_sent));
+
+    send_tree(s, (ct_data *)s-&gt;dyn_ltree, lcodes-1); /* literal tree */
+    Tracev((stderr, &quot;\nlit tree: sent %ld&quot;, s-&gt;bits_sent));
+
+    send_tree(s, (ct_data *)s-&gt;dyn_dtree, dcodes-1); /* distance tree */
+    Tracev((stderr, &quot;\ndist tree: sent %ld&quot;, s-&gt;bits_sent));
+}
+
+/* ===========================================================================
+ * Send a stored block
+ */
+void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
+    deflate_state *s;
+    charf *buf;       /* input block */
+    ulg stored_len;   /* length of input block */
+    int last;         /* one if this is the last block for a file */
+{
+    send_bits(s, (STORED_BLOCK&lt;&lt;1)+last, 3);    /* send block type */
+#ifdef DEBUG
+    s-&gt;compressed_len = (s-&gt;compressed_len + 3 + 7) &amp; (ulg)~7L;
+    s-&gt;compressed_len += (stored_len + 4) &lt;&lt; 3;
+#endif
+    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+}
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ * The current inflate code requires 9 bits of lookahead. If the
+ * last two codes for the previous block (real code plus EOB) were coded
+ * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
+ * the last real code. In this case we send two empty static blocks instead
+ * of one. (There are no problems if the previous block is stored or fixed.)
+ * To simplify the code, we assume the worst case of last real code encoded
+ * on one bit only.
+ */
+void ZLIB_INTERNAL _tr_align(s)
+    deflate_state *s;
+{
+    send_bits(s, STATIC_TREES&lt;&lt;1, 3);
+    send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+    s-&gt;compressed_len += 10L; /* 3 for block type, 7 for EOB */
+#endif
+    bi_flush(s);
+    /* Of the 10 bits for the empty block, we have already sent
+     * (10 - bi_valid) bits. The lookahead for the last real code (before
+     * the EOB of the previous block) was thus at least one plus the length
+     * of the EOB plus what we have just sent of the empty static block.
+     */
+    if (1 + s-&gt;last_eob_len + 10 - s-&gt;bi_valid &lt; 9) {
+        send_bits(s, STATIC_TREES&lt;&lt;1, 3);
+        send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+        s-&gt;compressed_len += 10L;
+#endif
+        bi_flush(s);
+    }
+    s-&gt;last_eob_len = 7;
+}
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file.
+ */
+void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
+    deflate_state *s;
+    charf *buf;       /* input block, or NULL if too old */
+    ulg stored_len;   /* length of input block */
+    int last;         /* one if this is the last block for a file */
+{
+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    int max_blindex = 0;  /* index of last bit length code of non zero freq */
+
+    /* Build the Huffman trees unless a stored block is forced */
+    if (s-&gt;level &gt; 0) {
+
+        /* Check if the file is binary or text */
+        if (s-&gt;strm-&gt;data_type == Z_UNKNOWN)
+            s-&gt;strm-&gt;data_type = detect_data_type(s);
+
+        /* Construct the literal and distance trees */
+        build_tree(s, (tree_desc *)(&amp;(s-&gt;l_desc)));
+        Tracev((stderr, &quot;\nlit data: dyn %ld, stat %ld&quot;, s-&gt;opt_len,
+                s-&gt;static_len));
+
+        build_tree(s, (tree_desc *)(&amp;(s-&gt;d_desc)));
+        Tracev((stderr, &quot;\ndist data: dyn %ld, stat %ld&quot;, s-&gt;opt_len,
+                s-&gt;static_len));
+        /* At this point, opt_len and static_len are the total bit lengths of
+         * the compressed block data, excluding the tree representations.
+         */
+
+        /* Build the bit length tree for the above two trees, and get the index
+         * in bl_order of the last bit length code to send.
+         */
+        max_blindex = build_bl_tree(s);
+
+        /* Determine the best encoding. Compute the block lengths in bytes. */
+        opt_lenb = (s-&gt;opt_len+3+7)&gt;&gt;3;
+        static_lenb = (s-&gt;static_len+3+7)&gt;&gt;3;
+
+        Tracev((stderr, &quot;\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u &quot;,
+                opt_lenb, s-&gt;opt_len, static_lenb, s-&gt;static_len, stored_len,
+                s-&gt;last_lit));
+
+        if (static_lenb &lt;= opt_lenb) opt_lenb = static_lenb;
+
+    } else {
+        Assert(buf != (char*)0, &quot;lost buf&quot;);
+        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+    }
+
+#ifdef FORCE_STORED
+    if (buf != (char*)0) { /* force stored block */
+#else
+    if (stored_len+4 &lt;= opt_lenb &amp;&amp; buf != (char*)0) {
+                       /* 4: two words for the lengths */
+#endif
+        /* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.
+         * Otherwise we can't have processed more than WSIZE input bytes since
+         * the last block flush, because compression would have been
+         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
+         * transform a block into a stored block.
+         */
+        _tr_stored_block(s, buf, stored_len, last);
+
+#ifdef FORCE_STATIC
+    } else if (static_lenb &gt;= 0) { /* force static trees */
+#else
+    } else if (s-&gt;strategy == Z_FIXED || static_lenb == opt_lenb) {
+#endif
+        send_bits(s, (STATIC_TREES&lt;&lt;1)+last, 3);
+        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+#ifdef DEBUG
+        s-&gt;compressed_len += 3 + s-&gt;static_len;
+#endif
+    } else {
+        send_bits(s, (DYN_TREES&lt;&lt;1)+last, 3);
+        send_all_trees(s, s-&gt;l_desc.max_code+1, s-&gt;d_desc.max_code+1,
+                       max_blindex+1);
+        compress_block(s, (ct_data *)s-&gt;dyn_ltree, (ct_data *)s-&gt;dyn_dtree);
+#ifdef DEBUG
+        s-&gt;compressed_len += 3 + s-&gt;opt_len;
+#endif
+    }
+    Assert (s-&gt;compressed_len == s-&gt;bits_sent, &quot;bad compressed size&quot;);
+    /* The above check is made mod 2^32, for files larger than 512 MB
+     * and uLong implemented on 32 bits.
+     */
+    init_block(s);
+
+    if (last) {
+        bi_windup(s);
+#ifdef DEBUG
+        s-&gt;compressed_len += 7;  /* align on byte boundary */
+#endif
+    }
+    Tracev((stderr,&quot;\ncomprlen %lu(%lu) &quot;, s-&gt;compressed_len&gt;&gt;3,
+           s-&gt;compressed_len-7*last));
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+int ZLIB_INTERNAL _tr_tally (s, dist, lc)
+    deflate_state *s;
+    unsigned dist;  /* distance of matched string */
+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+    s-&gt;d_buf[s-&gt;last_lit] = (ush)dist;
+    s-&gt;l_buf[s-&gt;last_lit++] = (uch)lc;
+    if (dist == 0) {
+        /* lc is the unmatched char */
+        s-&gt;dyn_ltree[lc].Freq++;
+    } else {
+        s-&gt;matches++;
+        /* Here, lc is the match length - MIN_MATCH */
+        dist--;             /* dist = match distance - 1 */
+        Assert((ush)dist &lt; (ush)MAX_DIST(s) &amp;&amp;
+               (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;
+               (ush)d_code(dist) &lt; (ush)D_CODES,  &quot;_tr_tally: bad match&quot;);
+
+        s-&gt;dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
+        s-&gt;dyn_dtree[d_code(dist)].Freq++;
+    }
+
+#ifdef TRUNCATE_BLOCK
+    /* Try to guess if it is profitable to stop the current block here */
+    if ((s-&gt;last_lit &amp; 0x1fff) == 0 &amp;&amp; s-&gt;level &gt; 2) {
+        /* Compute an upper bound for the compressed length */
+        ulg out_length = (ulg)s-&gt;last_lit*8L;
+        ulg in_length = (ulg)((long)s-&gt;strstart - s-&gt;block_start);
+        int dcode;
+        for (dcode = 0; dcode &lt; D_CODES; dcode++) {
+            out_length += (ulg)s-&gt;dyn_dtree[dcode].Freq *
+                (5L+extra_dbits[dcode]);
+        }
+        out_length &gt;&gt;= 3;
+        Tracev((stderr,&quot;\nlast_lit %u, in %ld, out ~%ld(%ld%%) &quot;,
+               s-&gt;last_lit, in_length, out_length,
+               100L - out_length*100L/in_length));
+        if (s-&gt;matches &lt; s-&gt;last_lit/2 &amp;&amp; out_length &lt; in_length/2) return 1;
+    }
+#endif
+    return (s-&gt;last_lit == s-&gt;lit_bufsize-1);
+    /* We avoid equality with lit_bufsize because of wraparound at 64K
+     * on 16 bit machines and because stored blocks are restricted to
+     * 64K-1 bytes.
+     */
+}
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+local void compress_block(s, ltree, dtree)
+    deflate_state *s;
+    ct_data *ltree; /* literal tree */
+    ct_data *dtree; /* distance tree */
+{
+    unsigned dist;      /* distance of matched string */
+    int lc;             /* match length or unmatched char (if dist == 0) */
+    unsigned lx = 0;    /* running index in l_buf */
+    unsigned code;      /* the code to send */
+    int extra;          /* number of extra bits to send */
+
+    if (s-&gt;last_lit != 0) do {
+        dist = s-&gt;d_buf[lx];
+        lc = s-&gt;l_buf[lx++];
+        if (dist == 0) {
+            send_code(s, lc, ltree); /* send a literal byte */
+            Tracecv(isgraph(lc), (stderr,&quot; '%c' &quot;, lc));
+        } else {
+            /* Here, lc is the match length - MIN_MATCH */
+            code = _length_code[lc];
+            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+            extra = extra_lbits[code];
+            if (extra != 0) {
+                lc -= base_length[code];
+                send_bits(s, lc, extra);       /* send the extra length bits */
+            }
+            dist--; /* dist is now the match distance - 1 */
+            code = d_code(dist);
+            Assert (code &lt; D_CODES, &quot;bad d_code&quot;);
+
+            send_code(s, code, dtree);       /* send the distance code */
+            extra = extra_dbits[code];
+            if (extra != 0) {
+                dist -= base_dist[code];
+                send_bits(s, dist, extra);   /* send the extra distance bits */
+            }
+        } /* literal or match pair ? */
+
+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+        Assert((uInt)(s-&gt;pending) &lt; s-&gt;lit_bufsize + 2*lx,
+               &quot;pendingBuf overflow&quot;);
+
+    } while (lx &lt; s-&gt;last_lit);
+
+    send_code(s, END_BLOCK, ltree);
+    s-&gt;last_eob_len = ltree[END_BLOCK].Len;
+}
+
+/* ===========================================================================
+ * Check if the data type is TEXT or BINARY, using the following algorithm:
+ * - TEXT if the two conditions below are satisfied:
+ *    a) There are no non-portable control characters belonging to the
+ *       &quot;black list&quot; (0..6, 14..25, 28..31).
+ *    b) There is at least one printable character belonging to the
+ *       &quot;white list&quot; (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
+ * - BINARY otherwise.
+ * - The following partially-portable control characters form a
+ *   &quot;gray list&quot; that is ignored in this detection algorithm:
+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
+ * IN assertion: the fields Freq of dyn_ltree are set.
+ */
+local int detect_data_type(s)
+    deflate_state *s;
+{
+    /* black_mask is the bit mask of black-listed bytes
+     * set bits 0..6, 14..25, and 28..31
+     * 0xf3ffc07f = binary 11110011111111111100000001111111
+     */
+    unsigned long black_mask = 0xf3ffc07fUL;
+    int n;
+
+    /* Check for non-textual (&quot;black-listed&quot;) bytes. */
+    for (n = 0; n &lt;= 31; n++, black_mask &gt;&gt;= 1)
+        if ((black_mask &amp; 1) &amp;&amp; (s-&gt;dyn_ltree[n].Freq != 0))
+            return Z_BINARY;
+
+    /* Check for textual (&quot;white-listed&quot;) bytes. */
+    if (s-&gt;dyn_ltree[9].Freq != 0 || s-&gt;dyn_ltree[10].Freq != 0
+            || s-&gt;dyn_ltree[13].Freq != 0)
+        return Z_TEXT;
+    for (n = 32; n &lt; LITERALS; n++)
+        if (s-&gt;dyn_ltree[n].Freq != 0)
+            return Z_TEXT;
+
+    /* There are no &quot;black-listed&quot; or &quot;white-listed&quot; bytes:
+     * this stream either is empty or has tolerated (&quot;gray-listed&quot;) bytes only.
+     */
+    return Z_BINARY;
+}
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 &lt;= len &lt;= 15
+ */
+local unsigned bi_reverse(code, len)
+    unsigned code; /* the value to invert */
+    int len;       /* its bit length */
+{
+    register unsigned res = 0;
+    do {
+        res |= code &amp; 1;
+        code &gt;&gt;= 1, res &lt;&lt;= 1;
+    } while (--len &gt; 0);
+    return res &gt;&gt; 1;
+}
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+local void bi_flush(s)
+    deflate_state *s;
+{
+    if (s-&gt;bi_valid == 16) {
+        put_short(s, s-&gt;bi_buf);
+        s-&gt;bi_buf = 0;
+        s-&gt;bi_valid = 0;
+    } else if (s-&gt;bi_valid &gt;= 8) {
+        put_byte(s, (Byte)s-&gt;bi_buf);
+        s-&gt;bi_buf &gt;&gt;= 8;
+        s-&gt;bi_valid -= 8;
+    }
+}
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+local void bi_windup(s)
+    deflate_state *s;
+{
+    if (s-&gt;bi_valid &gt; 8) {
+        put_short(s, s-&gt;bi_buf);
+    } else if (s-&gt;bi_valid &gt; 0) {
+        put_byte(s, (Byte)s-&gt;bi_buf);
+    }
+    s-&gt;bi_buf = 0;
+    s-&gt;bi_valid = 0;
+#ifdef DEBUG
+    s-&gt;bits_sent = (s-&gt;bits_sent+7) &amp; ~7;
+#endif
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+local void copy_block(s, buf, len, header)
+    deflate_state *s;
+    charf    *buf;    /* the input data */
+    unsigned len;     /* its length */
+    int      header;  /* true if block header must be written */
+{
+    bi_windup(s);        /* align on byte boundary */
+    s-&gt;last_eob_len = 8; /* enough lookahead for inflate */
+
+    if (header) {
+        put_short(s, (ush)len);
+        put_short(s, (ush)~len);
+#ifdef DEBUG
+        s-&gt;bits_sent += 2*16;
+#endif
+    }
+#ifdef DEBUG
+    s-&gt;bits_sent += (ulg)len&lt;&lt;3;
+#endif
+    while (len--) {
+        put_byte(s, *buf++);
+    }
+}

Added: Lobby/TASClient/LobbyComponents/delphizlib/trees.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/trees.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/trees.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,128 @@
+/* header created automatically with -DGEN_TREES_H */
+
+local const ct_data static_ltree[L_CODES+2] = {
+{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
+{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
+{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
+{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
+{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
+{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
+{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
+{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
+{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
+{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
+{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
+{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
+{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
+{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
+{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
+{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
+{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
+{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
+{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
+{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
+{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
+{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
+{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
+{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
+{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
+{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
+{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
+{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
+{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
+{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
+{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
+{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
+{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
+{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
+{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
+{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
+{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
+{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
+{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
+{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
+{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
+{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
+{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
+{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
+{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
+{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
+{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
+{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
+{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
+{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
+{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
+{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
+{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
+{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
+{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
+{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
+{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
+{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
+};
+
+local const ct_data static_dtree[D_CODES] = {
+{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
+{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
+{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
+{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
+{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
+{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
+};
+
+const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {
+ 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
+ 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
+10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
+18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
+};
+
+const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {
+ 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
+13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
+17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
+22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
+};
+
+local const int base_length[LENGTH_CODES] = {
+0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
+64, 80, 96, 112, 128, 160, 192, 224, 0
+};
+
+local const int base_dist[D_CODES] = {
+    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
+   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
+ 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
+};
+

Added: Lobby/TASClient/LobbyComponents/delphizlib/trees.obj
===================================================================
(Binary files differ)


Property changes on: Lobby/TASClient/LobbyComponents/delphizlib/trees.obj
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Added: Lobby/TASClient/LobbyComponents/delphizlib/zconf.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/zconf.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/zconf.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,428 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2010 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZCONF_H
+#define ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The &quot;standard&quot; zlib should be compiled without it.
+ * Even better than compiling with -DZ_PREFIX would be to use configure to set
+ * this permanently in zconf.h using &quot;./configure --zprefix&quot;.
+ */
+#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
+
+/* all linked symbols */
+#  define _dist_code            z__dist_code
+#  define _length_code          z__length_code
+#  define _tr_align             z__tr_align
+#  define _tr_flush_block       z__tr_flush_block
+#  define _tr_init              z__tr_init
+#  define _tr_stored_block      z__tr_stored_block
+#  define _tr_tally             z__tr_tally
+#  define adler32               z_adler32
+#  define adler32_combine       z_adler32_combine
+#  define adler32_combine64     z_adler32_combine64
+#  define compress              z_compress
+#  define compress2             z_compress2
+#  define compressBound         z_compressBound
+#  define crc32                 z_crc32
+#  define crc32_combine         z_crc32_combine
+#  define crc32_combine64       z_crc32_combine64
+#  define deflate               z_deflate
+#  define deflateBound          z_deflateBound
+#  define deflateCopy           z_deflateCopy
+#  define deflateEnd            z_deflateEnd
+#  define deflateInit2_         z_deflateInit2_
+#  define deflateInit_          z_deflateInit_
+#  define deflateParams         z_deflateParams
+#  define deflatePrime          z_deflatePrime
+#  define deflateReset          z_deflateReset
+#  define deflateSetDictionary  z_deflateSetDictionary
+#  define deflateSetHeader      z_deflateSetHeader
+#  define deflateTune           z_deflateTune
+#  define deflate_copyright     z_deflate_copyright
+#  define get_crc_table         z_get_crc_table
+#  define gz_error              z_gz_error
+#  define gz_intmax             z_gz_intmax
+#  define gz_strwinerror        z_gz_strwinerror
+#  define gzbuffer              z_gzbuffer
+#  define gzclearerr            z_gzclearerr
+#  define gzclose               z_gzclose
+#  define gzclose_r             z_gzclose_r
+#  define gzclose_w             z_gzclose_w
+#  define gzdirect              z_gzdirect
+#  define gzdopen               z_gzdopen
+#  define gzeof                 z_gzeof
+#  define gzerror               z_gzerror
+#  define gzflush               z_gzflush
+#  define gzgetc                z_gzgetc
+#  define gzgets                z_gzgets
+#  define gzoffset              z_gzoffset
+#  define gzoffset64            z_gzoffset64
+#  define gzopen                z_gzopen
+#  define gzopen64              z_gzopen64
+#  define gzprintf              z_gzprintf
+#  define gzputc                z_gzputc
+#  define gzputs                z_gzputs
+#  define gzread                z_gzread
+#  define gzrewind              z_gzrewind
+#  define gzseek                z_gzseek
+#  define gzseek64              z_gzseek64
+#  define gzsetparams           z_gzsetparams
+#  define gztell                z_gztell
+#  define gztell64              z_gztell64
+#  define gzungetc              z_gzungetc
+#  define gzwrite               z_gzwrite
+#  define inflate               z_inflate
+#  define inflateBack           z_inflateBack
+#  define inflateBackEnd        z_inflateBackEnd
+#  define inflateBackInit_      z_inflateBackInit_
+#  define inflateCopy           z_inflateCopy
+#  define inflateEnd            z_inflateEnd
+#  define inflateGetHeader      z_inflateGetHeader
+#  define inflateInit2_         z_inflateInit2_
+#  define inflateInit_          z_inflateInit_
+#  define inflateMark           z_inflateMark
+#  define inflatePrime          z_inflatePrime
+#  define inflateReset          z_inflateReset
+#  define inflateReset2         z_inflateReset2
+#  define inflateSetDictionary  z_inflateSetDictionary
+#  define inflateSync           z_inflateSync
+#  define inflateSyncPoint      z_inflateSyncPoint
+#  define inflateUndermine      z_inflateUndermine
+#  define inflate_copyright     z_inflate_copyright
+#  define inflate_fast          z_inflate_fast
+#  define inflate_table         z_inflate_table
+#  define uncompress            z_uncompress
+#  define zError                z_zError
+#  define zcalloc               z_zcalloc
+#  define zcfree                z_zcfree
+#  define zlibCompileFlags      z_zlibCompileFlags
+#  define zlibVersion           z_zlibVersion
+
+/* all zlib typedefs in zlib.h and zconf.h */
+#  define Byte                  z_Byte
+#  define Bytef                 z_Bytef
+#  define alloc_func            z_alloc_func
+#  define charf                 z_charf
+#  define free_func             z_free_func
+#  define gzFile                z_gzFile
+#  define gz_header             z_gz_header
+#  define gz_headerp            z_gz_headerp
+#  define in_func               z_in_func
+#  define intf                  z_intf
+#  define out_func              z_out_func
+#  define uInt                  z_uInt
+#  define uIntf                 z_uIntf
+#  define uLong                 z_uLong
+#  define uLongf                z_uLongf
+#  define voidp                 z_voidp
+#  define voidpc                z_voidpc
+#  define voidpf                z_voidpf
+
+/* all zlib structs in zlib.h and zconf.h */
+#  define gz_header_s           z_gz_header_s
+#  define internal_state        z_internal_state
+
+#endif
+
+#if defined(__MSDOS__) &amp;&amp; !defined(MSDOS)
+#  define MSDOS
+#endif
+#if (defined(OS_2) || defined(__OS2__)) &amp;&amp; !defined(OS2)
+#  define OS2
+#endif
+#if defined(_WINDOWS) &amp;&amp; !defined(WINDOWS)
+#  define WINDOWS
+#endif
+#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
+#  ifndef WIN32
+#    define WIN32
+#  endif
+#endif
+#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) &amp;&amp; !defined(WIN32)
+#  if !defined(__GNUC__) &amp;&amp; !defined(__FLAT__) &amp;&amp; !defined(__386__)
+#    ifndef SYS16BIT
+#      define SYS16BIT
+#    endif
+#  endif
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#ifdef SYS16BIT
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#ifdef __STDC_VERSION__
+#  ifndef STDC
+#    define STDC
+#  endif
+#  if __STDC_VERSION__ &gt;= 199901L
+#    ifndef STDC99
+#      define STDC99
+#    endif
+#  endif
+#endif
+#if !defined(STDC) &amp;&amp; (defined(__STDC__) || defined(__cplusplus))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(__GNUC__) || defined(__BORLANDC__))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
+#  define STDC
+#endif
+#if !defined(STDC) &amp;&amp; (defined(OS2) || defined(__HOS_AIX__))
+#  define STDC
+#endif
+
+#if defined(__OS400__) &amp;&amp; !defined(STDC)    /* iSeries (formerly AS/400). */
+#  define STDC
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) &amp;&amp; !defined(const) on Mac */
+#    define const       /* note: need a more gentle solution here */
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS=&quot;-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7&quot;
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 &lt;&lt; windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#ifdef SYS16BIT
+#  if defined(M_I86SM) || defined(M_I86MM)
+     /* MSC small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef _MSC_VER
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#  if (defined(__SMALL__) || defined(__MEDIUM__))
+     /* Turbo C small or medium model */
+#    define SMALL_MEDIUM
+#    ifdef __BORLANDC__
+#      define FAR _far
+#    else
+#      define FAR far
+#    endif
+#  endif
+#endif
+
+#if defined(WINDOWS) || defined(WIN32)
+   /* If building or using zlib as a DLL, define ZLIB_DLL.
+    * This is not mandatory, but it offers a little performance increase.
+    */
+#  ifdef ZLIB_DLL
+#    if defined(WIN32) &amp;&amp; (!defined(__BORLANDC__) || (__BORLANDC__ &gt;= 0x500))
+#      ifdef ZLIB_INTERNAL
+#        define ZEXTERN extern __declspec(dllexport)
+#      else
+#        define ZEXTERN extern __declspec(dllimport)
+#      endif
+#    endif
+#  endif  /* ZLIB_DLL */
+   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
+    * define ZLIB_WINAPI.
+    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
+    */
+#  ifdef ZLIB_WINAPI
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include &lt;windows.h&gt;
+     /* No need for _export, use ZLIB.DEF instead. */
+     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
+#    define ZEXPORT WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA WINAPIV
+#    else
+#      define ZEXPORTVA FAR CDECL
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  ifdef ZLIB_DLL
+#    ifdef ZLIB_INTERNAL
+#      define ZEXPORT   __declspec(dllexport)
+#      define ZEXPORTVA __declspec(dllexport)
+#    else
+#      define ZEXPORT   __declspec(dllimport)
+#      define ZEXPORTVA __declspec(dllimport)
+#    endif
+#  endif
+#endif
+
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+#if !defined(__MACTYPES__)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void const *voidpc;
+   typedef void FAR   *voidpf;
+   typedef void       *voidp;
+#else
+   typedef Byte const *voidpc;
+   typedef Byte FAR   *voidpf;
+   typedef Byte       *voidp;
+#endif
+
+#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
+#  define Z_HAVE_UNISTD_H
+#endif
+
+#ifdef STDC
+#  include &lt;sys/types.h&gt;    /* for off_t */
+#endif
+
+/* a little trick to accommodate both &quot;#define _LARGEFILE64_SOURCE&quot; and
+ * &quot;#define _LARGEFILE64_SOURCE 1&quot; as requesting 64-bit operations, (even
+ * though the former does not conform to the LFS document), but considering
+ * both &quot;#undef _LARGEFILE64_SOURCE&quot; and &quot;#define _LARGEFILE64_SOURCE 0&quot; as
+ * equivalently requesting no 64-bit operations
+ */
+#if -_LARGEFILE64_SOURCE - -1 == 1
+#  undef _LARGEFILE64_SOURCE
+#endif
+
+#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
+#  include &lt;unistd.h&gt;       /* for SEEK_* and off_t */
+#  ifdef VMS
+#    include &lt;unixio.h&gt;     /* for off_t */
+#  endif
+#  ifndef z_off_t
+#    define z_off_t off_t
+#  endif
+#endif
+
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus &quot;offset&quot; */
+#endif
+
+#ifndef z_off_t
+#  define z_off_t long
+#endif
+
+#if defined(_LARGEFILE64_SOURCE) &amp;&amp; _LFS64_LARGEFILE-0
+#  define z_off64_t off64_t
+#else
+#  define z_off64_t z_off_t
+#endif
+
+#if defined(__OS400__)
+#  define NO_vsnprintf
+#endif
+
+#if defined(__MVS__)
+#  define NO_vsnprintf
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+  #pragma map(deflateInit_,&quot;DEIN&quot;)
+  #pragma map(deflateInit2_,&quot;DEIN2&quot;)
+  #pragma map(deflateEnd,&quot;DEEND&quot;)
+  #pragma map(deflateBound,&quot;DEBND&quot;)
+  #pragma map(inflateInit_,&quot;ININ&quot;)
+  #pragma map(inflateInit2_,&quot;ININ2&quot;)
+  #pragma map(inflateEnd,&quot;INEND&quot;)
+  #pragma map(inflateSync,&quot;INSY&quot;)
+  #pragma map(inflateSetDictionary,&quot;INSEDI&quot;)
+  #pragma map(compressBound,&quot;CMBND&quot;)
+  #pragma map(inflate_table,&quot;INTABL&quot;)
+  #pragma map(inflate_fast,&quot;INFA&quot;)
+  #pragma map(inflate_copyright,&quot;INCOPY&quot;)
+#endif
+
+#endif /* ZCONF_H */

Added: Lobby/TASClient/LobbyComponents/delphizlib/zlib.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/zlib.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/zlib.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,1613 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.2.5, April 19th, 2010
+
+  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">jloup at gzip.org</A>          <A HREF="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">madler at alumni.caltech.edu</A>
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files <A HREF="http://www.ietf.org/rfc/rfc1950.txt">http://www.ietf.org/rfc/rfc1950.txt</A>
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef ZLIB_H
+#define ZLIB_H
+
+#include &quot;zconf.h&quot;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define ZLIB_VERSION &quot;1.2.5&quot;
+#define ZLIB_VERNUM 0x1250
+#define ZLIB_VER_MAJOR 1
+#define ZLIB_VER_MINOR 2
+#define ZLIB_VER_REVISION 5
+#define ZLIB_VER_SUBREVISION 0
+
+/*
+    The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed data.
+  This version of the library supports only one compression method (deflation)
+  but other algorithms will be added later and will have the same stream
+  interface.
+
+    Compression can be done in a single step if the buffers are large enough,
+  or can be done by repeated calls of the compression function.  In the latter
+  case, the application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+    The compressed data format used by default by the in-memory functions is
+  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
+  around a deflate stream, which is itself documented in RFC 1951.
+
+    The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio using the functions that start
+  with &quot;gz&quot;.  The gzip format is different from the zlib format.  gzip is a
+  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
+
+    This library can optionally read and write gzip streams in memory as well.
+
+    The zlib format was designed to be compact and fast for use in memory
+  and on communications channels.  The gzip format was designed for single-
+  file compression on file systems, has a larger header than zlib to maintain
+  directory information, and uses a different, slower check method than zlib.
+
+    The library does not install any signal handler.  The decoder checks
+  the consistency of the compressed data, so the library should never crash
+  even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: binary or text */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+     gzip header information passed to and from zlib routines.  See RFC 1952
+  for more details on the meanings of these fields.
+*/
+typedef struct gz_header_s {
+    int     text;       /* true if compressed data believed to be text */
+    uLong   time;       /* modification time */
+    int     xflags;     /* extra flags (not used when writing a gzip file) */
+    int     os;         /* operating system */
+    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
+    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
+    uInt    extra_max;  /* space at extra (only when reading header) */
+    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
+    uInt    name_max;   /* space at name (only when reading header) */
+    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
+    uInt    comm_max;   /* space at comment (only when reading header) */
+    int     hcrc;       /* true if there was or will be a header crc */
+    int     done;       /* true when done reading gzip header (not used
+                           when writing a gzip file) */
+} gz_header;
+
+typedef gz_header FAR *gz_headerp;
+
+/*
+     The application must update next_in and avail_in when avail_in has dropped
+   to zero.  It must update next_out and avail_out when avail_out has dropped
+   to zero.  The application must initialize zalloc, zfree and opaque before
+   calling the init function.  All other fields are set by the compression
+   library and must not be updated by the application.
+
+     The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree.  This can be useful for custom
+   memory management.  The compression library attaches no meaning to the
+   opaque value.
+
+     zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+     On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this if
+   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
+   returned by zalloc for objects of exactly 65536 bytes *must* have their
+   offset normalized to zero.  The default allocation function provided by this
+   library ensures this (see zutil.c).  To reduce memory requirements and avoid
+   any allocation of 64K objects, at the expense of compression ratio, compile
+   the library with -DMAX_WBITS=14 (see zconf.h).
+
+     The fields total_in and total_out can be used for statistics or progress
+   reports.  After compression, total_in holds the total size of the
+   uncompressed data and may be saved for use in the decompressor (particularly
+   if the decompressor wants to decompress everything in a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+#define Z_BLOCK         5
+#define Z_TREES         6
+/* Allowed flush values; see deflate() and inflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative values
+ * are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_RLE                 3
+#define Z_FIXED               4
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_TEXT     1
+#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field (though see inflate()) */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions &lt; 1.0.2 */
+
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is not
+   compatible with the zlib.h header file used by the application.  This check
+   is automatically made by deflateInit and inflateInit.
+ */
+
+/*
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression.  The fields
+   zalloc, zfree and opaque must be initialized before by the caller.  If
+   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
+   allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at all
+   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
+   requests a default compromise between speed and compression (currently
+   equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if level is not a valid compression level, or
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
+   if there is no error message.  deflateInit does not perform any compression:
+   this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full.  It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows.  deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly.  If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).  Some
+    output may be provided even if flush is not set.
+
+    Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming more
+  output, and updating avail_in or avail_out accordingly; avail_out should
+  never be zero before the call.  The application can consume the compressed
+  output when it wants, for example when the output buffer is full (avail_out
+  == 0), or after each call of deflate().  If deflate returns Z_OK and with
+  zero avail_out, it must be called again after making room in the output
+  buffer because there might be more output pending.
+
+    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
+  decide how much data to accumulate before producing output, in order to
+  maximize compression.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far.  (In
+  particular avail_in is zero after the call if enough output space has been
+  provided before the call.) Flushing may degrade compression for some
+  compression algorithms and so it should be used only when necessary.  This
+  completes the current deflate block and follows it with an empty stored block
+  that is three bits plus filler bits to the next byte, followed by four bytes
+  (00 00 ff ff).
+
+    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
+  output buffer, but the output is not aligned to a byte boundary.  All of the
+  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
+  This completes the current deflate block and follows it with an empty fixed
+  codes block that is 10 bits long.  This assures that enough bytes are output
+  in order for the decompressor to finish the block before the empty fixed code
+  block.
+
+    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
+  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
+  seven bits of the current block are held to be written as the next byte after
+  the next deflate block is completed.  In this case, the decompressor may not
+  be provided enough bits at this point in order to complete decompression of
+  the data provided so far to the compressor.  It may need to wait for the next
+  block to be emitted.  This is for advanced applications that need to control
+  the emission of deflate blocks.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
+  compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
+  avail_out is greater than six to avoid repeated flush markers due to
+  avail_out == 0 on return.
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there was
+  enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error.  After
+  deflate has returned Z_STREAM_END, the only possible operations on the stream
+  are deflateReset or deflateEnd.
+
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step.  In this case, avail_out must be at least the
+  value returned by deflateBound (see below).  If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm-&gt;adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update strm-&gt;data_type if it can make a good guess about
+  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
+  binary.  This field is only for information purposes and does not affect the
+  compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
+  fatal, and deflate() can be called again with more input and more output
+  space to continue compressing.
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any pending
+   output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded).  In the error case, msg
+   may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/*
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression.  The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
+   exact value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
+   invalid, such as a null pointer to the structure.  msg is set to null if
+   there is no error message.  inflateInit does not perform any decompression
+   apart from possibly reading the zlib header if present: actual decompression
+   will be done by inflate().  (So next_in and avail_in may be modified, but
+   next_out and avail_out are unused and unchanged.) The current implementation
+   of inflateInit() does not process any header information -- that is deferred
+   until inflate() is called.
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full.  It may introduce
+  some output latency (reading input without producing any output) except when
+  forced to flush.
+
+  The detailed semantics are as follows.  inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly.  If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing will
+    resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there is
+    no more input data or no more space in the output buffer (see below about
+    the flush parameter).
+
+    Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming more
+  output, and updating the next_* and avail_* values accordingly.  The
+  application can consume the uncompressed output when it wants, for example
+  when the output buffer is full (avail_out == 0), or after each call of
+  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
+  called again after making room in the output buffer because there might be
+  more output pending.
+
+    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
+  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
+  output as possible to the output buffer.  Z_BLOCK requests that inflate()
+  stop if and when it gets to the next deflate block boundary.  When decoding
+  the zlib or gzip format, this will cause inflate() to return immediately
+  after the header and before the first block.  When doing a raw inflate,
+  inflate() will go ahead and process the first block, and will return when it
+  gets to the end of that block, or when it runs out of data.
+
+    The Z_BLOCK option assists in appending to or combining deflate streams.
+  Also to assist in this, on return inflate() will set strm-&gt;data_type to the
+  number of unused bits in the last byte taken from strm-&gt;next_in, plus 64 if
+  inflate() is currently decoding the last block in the deflate stream, plus
+  128 if inflate() returned immediately after decoding an end-of-block code or
+  decoding the complete header up to just before the first byte of the deflate
+  stream.  The end-of-block will not be indicated until all of the uncompressed
+  data from that block has been written to strm-&gt;next_out.  The number of
+  unused bits may in general be greater than seven, except when bit 7 of
+  data_type is set, in which case the number of unused bits will be less than
+  eight.  data_type is set as noted here every time inflate() returns for all
+  flush options, and so can be used to determine the amount of currently
+  consumed input in bits.
+
+    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
+  end of each deflate block header is reached, before any actual data in that
+  block is decoded.  This allows the caller to determine the length of the
+  deflate block header for later use in random access within a deflate block.
+  256 is added to the value of strm-&gt;data_type when inflate() returns
+  immediately after reaching the end of the deflate block header.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error.  However if all decompression is to be performed in a single step (a
+  single call of inflate), the parameter flush should be set to Z_FINISH.  In
+  this case all pending input is processed and all pending output is flushed;
+  avail_out must be large enough to hold all the uncompressed data.  (The size
+  of the uncompressed data may have been saved by the compressor for this
+  purpose.) The next operation on this stream must be inflateEnd to deallocate
+  the decompression state.  The use of Z_FINISH is never required, but can be
+  used to inform inflate that a faster approach may be used for the single
+  inflate() call.
+
+     In this implementation, inflate() always flushes as much output as
+  possible to the output buffer, and always uses the faster approach on the
+  first call.  So the only effect of the flush parameter in this implementation
+  is on the return value of inflate(), as noted below, or when it returns early
+  because Z_BLOCK or Z_TREES is used.
+
+     If a preset dictionary is needed after this call (see inflateSetDictionary
+  below), inflate sets strm-&gt;adler to the adler32 checksum of the dictionary
+  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
+  strm-&gt;adler to the adler32 checksum of all output produced so far (that is,
+  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
+  below.  At the end of the stream, inflate() checks that its computed adler32
+  checksum is equal to that saved by the compressor and returns Z_STREAM_END
+  only if the checksum is correct.
+
+    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
+  deflate data.  The header type is detected automatically, if requested when
+  initializing with inflateInit2().  Any information contained in the gzip
+  header is not retained, so applications that need that information should
+  instead use raw inflate, see inflateInit2() below, or inflateBack() and
+  perform their own processing of the gzip header and trailer.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect check
+  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
+  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
+  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
+  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
+  inflate() can be called again with more input and more output space to
+  continue decompressing.  If Z_DATA_ERROR is returned, the application may
+  then call inflateSync() to look for a good compression block if a partial
+  recovery of the data is desired.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any pending
+   output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent.  In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options.  The
+   fields next_in, zalloc, zfree and opaque must be initialized before by the
+   caller.
+
+     The method parameter is the compression method.  It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library.  Larger values of this parameter result in better
+   compression at the expense of memory usage.  The default value is 15 if
+   deflateInit is used instead.
+
+     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
+   determines the window size.  deflate() will then generate raw deflate data
+   with no zlib header or trailer, and will not compute an adler32 check value.
+
+     windowBits can also be greater than 15 for optional gzip encoding.  Add
+   16 to windowBits to write a simple gzip header and trailer around the
+   compressed data instead of a zlib wrapper.  The gzip header will have no
+   file name, no extra data, no comment, no modification time (set to zero), no
+   header crc, and the operating system will be set to 255 (unknown).  If a
+   gzip stream is being written, strm-&gt;adler is a crc32 instead of an adler32.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state.  memLevel=1 uses minimum memory but is
+   slow and reduces compression ratio; memLevel=9 uses maximum memory for
+   optimal speed.  The default value is 8.  See zconf.h for total memory usage
+   as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm.  Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match), or Z_RLE to limit match distances to one (run-length
+   encoding).  Filtered data consists mostly of small values with a somewhat
+   random distribution.  In this case, the compression algorithm is tuned to
+   compress them better.  The effect of Z_FILTERED is to force more Huffman
+   coding and less string matching; it is somewhat intermediate between
+   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
+   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
+   strategy parameter only affects the compression ratio but not the
+   correctness of the compressed output even if it is not set appropriately.
+   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
+   decoder for special applications.
+
+     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
+   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
+   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
+   set to null if there is no error message.  deflateInit2 does not perform any
+   compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output.  This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any call
+   of deflate.  The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary.  Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size
+   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
+   useful should be put at the end of the dictionary, not at the front.  In
+   addition, the current implementation of deflate will use at most the window
+   size minus 262 bytes of the provided dictionary.
+
+     Upon return of this function, strm-&gt;adler is set to the adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor.  (The adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.) If a raw deflate was requested, then the
+   adler32 value is not computed and strm-&gt;adler is not set.
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort).  deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter.  The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and can
+   consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.  The
+   stream will keep the same compression level and any other attributes that
+   may have been set by deflateInit2.
+
+     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being Z_NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+                                      int level,
+                                      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different strategy.
+   If the compression level is changed, the input available so far is
+   compressed with the old level (and may be flushed); the new level will take
+   effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to be
+   compressed and flushed.  In particular, strm-&gt;avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
+   strm-&gt;avail_out was zero.
+*/
+
+ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
+                                    int good_length,
+                                    int max_lazy,
+                                    int nice_length,
+                                    int max_chain));
+/*
+     Fine tune deflate's internal compression parameters.  This should only be
+   used by someone who understands the algorithm used by zlib's deflate for
+   searching for the best matching string, and even then only by the most
+   fanatic optimizer trying to squeeze out the last compressed bit for their
+   specific input data.  Read the deflate.c source code for the meaning of the
+   max_lazy, good_length, nice_length, and max_chain parameters.
+
+     deflateTune() can be called after deflateInit() or deflateInit2(), and
+   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
+ */
+
+ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
+                                       uLong sourceLen));
+/*
+     deflateBound() returns an upper bound on the compressed size after
+   deflation of sourceLen bytes.  It must be called after deflateInit() or
+   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
+   to allocate an output buffer for deflation in a single pass, and so would be
+   called before deflate().
+*/
+
+ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     deflatePrime() inserts bits in the deflate output stream.  The intent
+   is that this function is used to start off the deflate output with the bits
+   leftover from a previous deflate stream when appending to it.  As such, this
+   function can only be used for raw deflate, and must be used before the first
+   deflate() call after a deflateInit2() or deflateReset().  bits must be less
+   than or equal to 16, and that many of the least significant bits of value
+   will be inserted in the output.
+
+     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+     deflateSetHeader() provides gzip header information for when a gzip
+   stream is requested by deflateInit2().  deflateSetHeader() may be called
+   after deflateInit2() or deflateReset() and before the first call of
+   deflate().  The text, time, os, extra field, name, and comment information
+   in the provided gz_header structure are written to the gzip header (xflag is
+   ignored -- the extra flags are set according to the compression level).  The
+   caller must assure that, if not Z_NULL, name and comment are terminated with
+   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
+   available there.  If hcrc is true, a gzip header crc is included.  Note that
+   the current versions of the command-line version of gzip (up through version
+   1.3.x) do not support header crc's, and will report that it is a &quot;multi-part
+   gzip file&quot; and give up.
+
+     If deflateSetHeader is not used, the default gzip header has text false,
+   the time set to zero, and os set to 255, with no extra, name, or comment
+   fields.  The gzip header is returned to the default state by deflateReset().
+
+     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter.  The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library.  The default value is 15 if inflateInit is used
+   instead.  windowBits must be greater than or equal to the windowBits value
+   provided to deflateInit2() while compressing, or it must be equal to 15 if
+   deflateInit2() was not used.  If a compressed stream with a larger window
+   size is given as input, inflate() will return with the error code
+   Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     windowBits can also be zero to request that inflate use the window size in
+   the zlib header of the compressed stream.
+
+     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
+   determines the window size.  inflate() will then process raw deflate data,
+   not looking for a zlib or gzip header, not generating a check value, and not
+   looking for any check values for comparison at the end of the stream.  This
+   is for use with other formats that use the deflate compressed data format
+   such as zip.  Those formats provide their own check values.  If a custom
+   format is developed using the raw deflate format for compressed data, it is
+   recommended that a check value such as an adler32 or a crc32 be applied to
+   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
+   most applications, the zlib format should be used as is.  Note that comments
+   above on the use in deflateInit2() applies to the magnitude of windowBits.
+
+     windowBits can also be greater than 15 for optional gzip decoding.  Add
+   32 to windowBits to enable zlib and gzip decoding with automatic header
+   detection, or add 16 to decode only the gzip format (the zlib format will
+   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm-&gt;adler is a
+   crc32 instead of an adler32.
+
+     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
+   invalid, such as a null pointer to the structure.  msg is set to null if
+   there is no error message.  inflateInit2 does not perform any decompression
+   apart from possibly reading the zlib header if present: actual decompression
+   will be done by inflate().  (So next_in and avail_in may be modified, but
+   next_out and avail_out are unused and unchanged.) The current implementation
+   of inflateInit2() does not process any header information -- that is
+   deferred until inflate() is called.
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence.  This function must be called immediately after a call of inflate,
+   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
+   can be determined from the adler32 value returned by that call of inflate.
+   The compressor and decompressor must use exactly the same dictionary (see
+   deflateSetDictionary).  For raw inflate, this function can be called
+   immediately after inflateInit2() or inflateReset() and before any call of
+   inflate() to set the dictionary.  The application must insure that the
+   dictionary that was used for compression is provided.
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect adler32 value).  inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/*
+     Skips invalid compressed data until a full flush point (see above the
+   description of deflate with Z_FULL_FLUSH) can be found, or until all
+   available input is skipped.  No output is provided.
+
+     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+   if no more input was provided, Z_DATA_ERROR if no flush point has been
+   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the
+   success case, the application may save the current current value of total_in
+   which indicates where valid compressed data was found.  In the error case,
+   the application may repeatedly call inflateSync, providing more input each
+   time, until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when randomly accessing a large stream.  The
+   first pass through the stream can periodically record the inflate state,
+   allowing restarting inflate at those points when randomly accessing the
+   stream.
+
+     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.  The
+   stream will keep attributes that may have been set by inflateInit2.
+
+     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being Z_NULL).
+*/
+
+ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
+                                      int windowBits));
+/*
+     This function is the same as inflateReset, but it also permits changing
+   the wrap and window size requests.  The windowBits parameter is interpreted
+   the same as it is for inflateInit2.
+
+     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
+   the windowBits parameter is invalid.
+*/
+
+ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
+                                     int bits,
+                                     int value));
+/*
+     This function inserts bits in the inflate input stream.  The intent is
+   that this function is used to start inflating at a bit position in the
+   middle of a byte.  The provided bits will be used before any bytes are used
+   from next_in.  This function should only be used with raw inflate, and
+   should be used before the first inflate() call after inflateInit2() or
+   inflateReset().  bits must be less than or equal to 16, and that many of the
+   least significant bits of value will be inserted in the input.
+
+     If bits is negative, then the input stream bit buffer is emptied.  Then
+   inflatePrime() can be called again to put bits in the buffer.  This is used
+   to clear out bits leftover after feeding inflate a block description prior
+   to feeding inflate codes.
+
+     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
+/*
+     This function returns two values, one in the lower 16 bits of the return
+   value, and the other in the remaining upper bits, obtained by shifting the
+   return value down 16 bits.  If the upper value is -1 and the lower value is
+   zero, then inflate() is currently decoding information outside of a block.
+   If the upper value is -1 and the lower value is non-zero, then inflate is in
+   the middle of a stored block, with the lower value equaling the number of
+   bytes from the input remaining to copy.  If the upper value is not -1, then
+   it is the number of bits back from the current bit position in the input of
+   the code (literal or length/distance pair) currently being processed.  In
+   that case the lower value is the number of bytes already emitted for that
+   code.
+
+     A code is being processed if inflate is waiting for more input to complete
+   decoding of the code, or if it has completed decoding but is waiting for
+   more output space to write the literal or match data.
+
+     inflateMark() is used to mark locations in the input data for random
+   access, which may be at bit positions, and to note those cases where the
+   output of a code may span boundaries of random access blocks.  The current
+   location in the input stream can be determined from avail_in and data_type
+   as noted in the description for the Z_BLOCK flush parameter for inflate.
+
+     inflateMark returns the value noted above or -1 &lt;&lt; 16 if the provided
+   source stream state was inconsistent.
+*/
+
+ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
+                                         gz_headerp head));
+/*
+     inflateGetHeader() requests that gzip header information be stored in the
+   provided gz_header structure.  inflateGetHeader() may be called after
+   inflateInit2() or inflateReset(), and before the first call of inflate().
+   As inflate() processes the gzip stream, head-&gt;done is zero until the header
+   is completed, at which time head-&gt;done is set to one.  If a zlib stream is
+   being decoded, then head-&gt;done is set to -1 to indicate that there will be
+   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
+   used to force inflate() to return immediately after header processing is
+   complete and before any actual data is decompressed.
+
+     The text, time, xflags, and os fields are filled in with the gzip header
+   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
+   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
+   contains the maximum number of bytes to write to extra.  Once done is true,
+   extra_len contains the actual extra field length, and extra contains the
+   extra field, or that field truncated if extra_max is less than extra_len.
+   If name is not Z_NULL, then up to name_max characters are written there,
+   terminated with a zero unless the length is greater than name_max.  If
+   comment is not Z_NULL, then up to comm_max characters are written there,
+   terminated with a zero unless the length is greater than comm_max.  When any
+   of extra, name, or comment are not Z_NULL and the respective field is not
+   present in the header, then that field is set to Z_NULL to signal its
+   absence.  This allows the use of deflateSetHeader() with the returned
+   structure to duplicate the header.  However if those fields are set to
+   allocated memory, then the application will need to save those pointers
+   elsewhere so that they can be eventually freed.
+
+     If inflateGetHeader is not used, then the header information is simply
+   discarded.  The header is always checked for validity, including the header
+   CRC if present.  inflateReset() will reset the process to discard the header
+   information.  The application would need to call inflateGetHeader() again to
+   retrieve the header from the next gzip stream.
+
+     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent.
+*/
+
+/*
+ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
+                                        unsigned char FAR *window));
+
+     Initialize the internal stream state for decompression using inflateBack()
+   calls.  The fields zalloc, zfree and opaque in strm must be initialized
+   before the call.  If zalloc and zfree are Z_NULL, then the default library-
+   derived memory allocation routines are used.  windowBits is the base two
+   logarithm of the window size, in the range 8..15.  window is a caller
+   supplied buffer of that size.  Except for special applications where it is
+   assured that deflate was used with small window sizes, windowBits must be 15
+   and a 32K byte window must be supplied to be able to decompress general
+   deflate streams.
+
+     See inflateBack() for the usage of these routines.
+
+     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
+   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be
+   allocated, or Z_VERSION_ERROR if the version of the library does not match
+   the version of the header file.
+*/
+
+typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
+typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
+
+ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
+                                    in_func in, void FAR *in_desc,
+                                    out_func out, void FAR *out_desc));
+/*
+     inflateBack() does a raw inflate with a single call using a call-back
+   interface for input and output.  This is more efficient than inflate() for
+   file i/o applications in that it avoids copying between the output and the
+   sliding window by simply making the window itself the output buffer.  This
+   function trusts the application to not change the output buffer passed by
+   the output function, at least until inflateBack() returns.
+
+     inflateBackInit() must be called first to allocate the internal state
+   and to initialize the state with the user-provided window buffer.
+   inflateBack() may then be used multiple times to inflate a complete, raw
+   deflate stream with each call.  inflateBackEnd() is then called to free the
+   allocated state.
+
+     A raw deflate stream is one with no zlib or gzip header or trailer.
+   This routine would normally be used in a utility that reads zip or gzip
+   files and writes out uncompressed files.  The utility would decode the
+   header and process the trailer on its own, hence this routine expects only
+   the raw deflate stream to decompress.  This is different from the normal
+   behavior of inflate(), which expects either a zlib or gzip header and
+   trailer around the deflate stream.
+
+     inflateBack() uses two subroutines supplied by the caller that are then
+   called by inflateBack() for input and output.  inflateBack() calls those
+   routines until it reads a complete deflate stream and writes out all of the
+   uncompressed data, or until it encounters an error.  The function's
+   parameters and return types are defined above in the in_func and out_func
+   typedefs.  inflateBack() will call in(in_desc, &amp;buf) which should return the
+   number of bytes of provided input, and a pointer to that input in buf.  If
+   there is no input available, in() must return zero--buf is ignored in that
+   case--and inflateBack() will return a buffer error.  inflateBack() will call
+   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
+   should return zero on success, or non-zero on failure.  If out() returns
+   non-zero, inflateBack() will return with an error.  Neither in() nor out()
+   are permitted to change the contents of the window provided to
+   inflateBackInit(), which is also the buffer that out() uses to write from.
+   The length written by out() will be at most the window size.  Any non-zero
+   amount of input may be provided by in().
+
+     For convenience, inflateBack() can be provided input on the first call by
+   setting strm-&gt;next_in and strm-&gt;avail_in.  If that input is exhausted, then
+   in() will be called.  Therefore strm-&gt;next_in must be initialized before
+   calling inflateBack().  If strm-&gt;next_in is Z_NULL, then in() will be called
+   immediately for input.  If strm-&gt;next_in is not Z_NULL, then strm-&gt;avail_in
+   must also be initialized, and then if strm-&gt;avail_in is not zero, input will
+   initially be taken from strm-&gt;next_in[0 ..  strm-&gt;avail_in - 1].
+
+     The in_desc and out_desc parameters of inflateBack() is passed as the
+   first parameter of in() and out() respectively when they are called.  These
+   descriptors can be optionally used to pass any information that the caller-
+   supplied in() and out() functions need to do their job.
+
+     On return, inflateBack() will set strm-&gt;next_in and strm-&gt;avail_in to
+   pass back any unused input that was provided by the last in() call.  The
+   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
+   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
+   in the deflate stream (in which case strm-&gt;msg is set to indicate the nature
+   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
+   In the case of Z_BUF_ERROR, an input or output error can be distinguished
+   using strm-&gt;next_in which will be Z_NULL only if in() returned an error.  If
+   strm-&gt;next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
+   non-zero.  (in() will always be called before out(), so strm-&gt;next_in is
+   assured to be defined if out() returns non-zero.) Note that inflateBack()
+   cannot return Z_OK.
+*/
+
+ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
+/*
+     All memory allocated by inflateBackInit() is freed.
+
+     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
+   state was inconsistent.
+*/
+
+ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
+/* Return flags indicating compile-time options.
+
+    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
+     1.0: size of uInt
+     3.2: size of uLong
+     5.4: size of voidpf (pointer)
+     7.6: size of z_off_t
+
+    Compiler, assembler, and debug options:
+     8: DEBUG
+     9: ASMV or ASMINF -- use ASM code
+     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
+     11: 0 (reserved)
+
+    One-time table building (smaller code, but not thread-safe if true):
+     12: BUILDFIXED -- build static block decoding tables when needed
+     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
+     14,15: 0 (reserved)
+
+    Library content (indicates missing functionality):
+     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
+                          deflate code when not needed)
+     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
+                    and decode gzip streams (to avoid linking crc code)
+     18-19: 0 (reserved)
+
+    Operation variations (changes in library functionality):
+     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
+     21: FASTEST -- deflate algorithm with only one, lowest compression level
+     22,23: 0 (reserved)
+
+    The sprintf variant used by gzprintf (zero is best):
+     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
+     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
+     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
+
+    Remainder:
+     27-31: 0 (reserved)
+ */
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the basic
+   stream-oriented functions.  To simplify the interface, some default options
+   are assumed (compression level and memory usage, standard memory allocation
+   functions).  The source code of these utility functions can be modified if
+   you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer.  Upon entry, destLen is the total size
+   of the destination buffer, which must be at least the value returned by
+   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer.  The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer.  Upon entry, destLen is the total size of the
+   destination buffer, which must be at least the value returned by
+   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
+   compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
+/*
+     compressBound() returns an upper bound on the compressed size after
+   compress() or compress2() on sourceLen bytes.  It would be used before a
+   compress() or compress2() call to allocate the destination buffer.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer.  Upon entry, destLen is the total size
+   of the destination buffer, which must be large enough to hold the entire
+   uncompressed data.  (The size of the uncompressed data must have been saved
+   previously by the compressor and transmitted to the decompressor by some
+   mechanism outside the scope of this compression library.) Upon exit, destLen
+   is the actual size of the uncompressed buffer.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
+*/
+
+
+                        /* gzip file access functions */
+
+/*
+     This library supports reading and writing files in gzip (.gz) format with
+   an interface similar to that of stdio, using the functions that start with
+   &quot;gz&quot;.  The gzip format is different from the zlib format.  gzip is a gzip
+   wrapper, documented in RFC 1952, wrapped around a deflate stream.
+*/
+
+typedef voidp gzFile;       /* opaque gzip file descriptor */
+
+/*
+ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
+
+     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
+   in fopen (&quot;rb&quot; or &quot;wb&quot;) but can also include a compression level (&quot;wb9&quot;) or
+   a strategy: 'f' for filtered data as in &quot;wb6f&quot;, 'h' for Huffman-only
+   compression as in &quot;wb1h&quot;, 'R' for run-length encoding as in &quot;wb1R&quot;, or 'F'
+   for fixed code compression as in &quot;wb9F&quot;.  (See the description of
+   deflateInit2 for more information about the strategy parameter.) Also &quot;a&quot;
+   can be used instead of &quot;w&quot; to request that the gzip stream that will be
+   written be appended to the file.  &quot;+&quot; will result in an error, since reading
+   and writing to the same gzip file is not supported.
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened, if there was
+   insufficient memory to allocate the gzFile state, or if an invalid mode was
+   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
+   errno can be checked to determine if the reason gzopen failed was that the
+   file could not be opened.
+*/
+
+ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
+/*
+     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
+   are obtained from calls like open, dup, creat, pipe or fileno (if the file
+   has been previously opened with fopen).  The mode parameter is as in gzopen.
+
+     The next call of gzclose on the returned gzFile will also close the file
+   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
+   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
+   mode);.  The duplicated descriptor should be saved to avoid a leak, since
+   gzdopen does not close fd if it fails.
+
+     gzdopen returns NULL if there was insufficient memory to allocate the
+   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
+   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
+   used until the next gz* read, write, seek, or close operation, so gzdopen
+   will not detect if fd is invalid (unless fd is -1).
+*/
+
+ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
+/*
+     Set the internal buffer size used by this library's functions.  The
+   default buffer size is 8192 bytes.  This function must be called after
+   gzopen() or gzdopen(), and before any other calls that read or write the
+   file.  The buffer memory allocation is always deferred to the first read or
+   write.  Two buffers are allocated, either both of the specified size when
+   writing, or one of the specified size and the other twice that size when
+   reading.  A larger buffer size of, for example, 64K or 128K bytes will
+   noticeably increase the speed of decompression (reading).
+
+     The new buffer size also affects the maximum length for gzprintf().
+
+     gzbuffer() returns 0 on success, or -1 on failure, such as being called
+   too late.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy.  See the description
+   of deflateInit2 for the meaning of these parameters.
+
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.  If
+   the input file was not in gzip format, gzread copies the given number of
+   bytes into the buffer.
+
+     After reaching the end of a gzip stream in the input, gzread will continue
+   to read, looking for another gzip stream, or failing that, reading the rest
+   of the input file directly without decompression.  The entire input file
+   will be read if gzread is called until it returns less than the requested
+   len.
+
+     gzread returns the number of uncompressed bytes actually read, less than
+   len for end of file, or -1 for error.
+*/
+
+ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
+                                voidpc buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes written or 0 in case of
+   error.
+*/
+
+ZEXTERN int ZEXPORTVA gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the arguments to the compressed file under
+   control of the format string, as in fprintf.  gzprintf returns the number of
+   uncompressed bytes actually written, or 0 in case of error.  The number of
+   uncompressed bytes written is limited to 8191, or one less than the buffer
+   size given to gzbuffer().  The caller should assure that this limit is not
+   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
+   nothing written.  In this case, there may also be a buffer overflow with
+   unpredictable consequences, which is possible only if zlib was compiled with
+   the insecure functions sprintf() or vsprintf() because the secure snprintf()
+   or vsnprintf() functions were not available.  This can be determined using
+   zlibCompileFlags().
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+     Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+
+     gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+     Reads bytes from the compressed file until len-1 characters are read, or a
+   newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  If any characters are read or if len == 1, the
+   string is terminated with a null character.  If no characters are read due
+   to an end-of-file or len &lt; 1, then the buffer is left untouched.
+
+     gzgets returns buf which is a null-terminated string, or it returns NULL
+   for end-of-file or in case of error.  If there was an error, the contents at
+   buf are indeterminate.
+*/
+
+ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
+/*
+     Writes c, converted to an unsigned char, into the compressed file.  gzputc
+   returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
+/*
+     Reads one byte from the compressed file.  gzgetc returns this byte or -1
+   in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
+/*
+     Push one character back onto the stream to be read as the first character
+   on the next read.  At least one character of push-back is allowed.
+   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
+   fail if c is -1, and may fail if a character has been pushed but not read
+   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
+   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
+   The pushed character will be discarded if the stream is repositioned with
+   gzseek() or gzrewind().
+*/
+
+ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file.  The parameter flush
+   is as in the deflate() function.  The return value is the zlib error number
+   (see function gzerror below).  gzflush is only permitted when writing.
+
+     If the flush parameter is Z_FINISH, the remaining data is written and the
+   gzip stream is completed in the output.  If gzwrite() is called again, a new
+   gzip stream will be started in the output.  gzread() is able to read such
+   concatented gzip streams.
+
+     gzflush should be called only when strictly necessary because it will
+   degrade compression if called too often.
+*/
+
+/*
+ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
+                                   z_off_t offset, int whence));
+
+     Sets the starting position for the next gzread or gzwrite on the given
+   compressed file.  The offset represents a number of bytes in the
+   uncompressed data stream.  The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow.  If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+     gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+/*
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+
+     Returns the starting position for the next gzread or gzwrite on the given
+   compressed file.  This position represents a number of bytes in the
+   uncompressed data stream, and is zero when starting, even if appending or
+   reading a gzip stream from the middle of a file using gzdopen().
+
+     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+/*
+ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
+
+     Returns the current offset in the file being read or written.  This offset
+   includes the count of bytes that precede the gzip stream, for example when
+   appending or when using gzdopen() for reading.  When reading, the offset
+   does not include as yet unused buffered input.  This information can be used
+   for a progress indicator.  On error, gzoffset() returns -1.
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns true (1) if the end-of-file indicator has been set while reading,
+   false (0) otherwise.  Note that the end-of-file indicator is set only if the
+   read tried to go past the end of the input, but came up short.  Therefore,
+   just like feof(), gzeof() may return false even if there is no more data to
+   read, in the event that the last read request was for the exact number of
+   bytes remaining in the input file.  This will happen if the input file size
+   is an exact multiple of the buffer size.
+
+     If gzeof() returns true, then the read functions will return no more data,
+   unless the end-of-file indicator is reset by gzclearerr() and the input file
+   has grown since the previous end of file was detected.
+*/
+
+ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
+/*
+     Returns true (1) if file is being copied directly while reading, or false
+   (0) if file is a gzip stream being decompressed.  This state can change from
+   false to true while reading the input file if the end of a gzip stream is
+   reached, but is followed by data that is not another gzip stream.
+
+     If the input file is empty, gzdirect() will return true, since the input
+   does not contain a gzip stream.
+
+     If gzdirect() is used immediately after gzopen() or gzdopen() it will
+   cause buffers to be allocated to allow reading the file to determine if it
+   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
+   gzdirect().
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file and
+   deallocates the (de)compression state.  Note that once file is closed, you
+   cannot call gzerror with file, since its structures have been deallocated.
+   gzclose must not be called more than once on the same file, just as free
+   must not be called more than once on the same allocation.
+
+     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
+   file operation error, or Z_OK on success.
+*/
+
+ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
+ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
+/*
+     Same as gzclose(), but gzclose_r() is only for use when reading, and
+   gzclose_w() is only for use when writing or appending.  The advantage to
+   using these instead of gzclose() is that they avoid linking in zlib
+   compression or decompression code that is not used when only reading or only
+   writing respectively.  If gzclose() is used, then both compression and
+   decompression code will be included the application when linking to a static
+   zlib library.
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the given
+   compressed file.  errnum is set to zlib error number.  If an error occurred
+   in the file system and not in the compression library, errnum is set to
+   Z_ERRNO and the application may consult errno to get the exact error code.
+
+     The application must not modify the returned string.  Future calls to
+   this function may invalidate the previously returned string.  If file is
+   closed, then the string previously returned by gzerror will no longer be
+   available.
+
+     gzerror() should be used to distinguish errors from end-of-file for those
+   functions above that do not distinguish those cases in their return values.
+*/
+
+ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
+/*
+     Clears the error and end-of-file flags for file.  This is analogous to the
+   clearerr() function in stdio.  This is useful for continuing to read a gzip
+   file that is being written concurrently.
+*/
+
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the compression
+   library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum.  If buf is Z_NULL, this function returns the
+   required initial value for the checksum.
+
+     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster.
+
+   Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+/*
+ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
+                                          z_off_t len2));
+
+     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
+   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
+   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
+   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running CRC-32 with the bytes buf[0..len-1] and return the
+   updated CRC-32.  If buf is Z_NULL, this function returns the required
+   initial value for the for the crc.  Pre- and post-conditioning (one's
+   complement) is performed within this function so it shouldn't be done by the
+   application.
+
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+/*
+ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
+
+     Combine two CRC-32 check values into one.  For two sequences of bytes,
+   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
+   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
+   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
+   len2.
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
+                                         unsigned char FAR *window,
+                                         const char *version,
+                                         int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+#define inflateBackInit(strm, windowBits, window) \
+        inflateBackInit_((strm), (windowBits), (window), \
+                                            ZLIB_VERSION, sizeof(z_stream))
+
+/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
+ * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
+ * both are true, the application gets the *64 functions, and the regular
+ * functions are changed to 64 bits) -- in case these are set on systems
+ * without large file support, _LFS64_LARGEFILE must also be true
+ */
+#if defined(_LARGEFILE64_SOURCE) &amp;&amp; _LFS64_LARGEFILE-0
+   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
+   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
+   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
+   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
+   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
+   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
+#endif
+
+#if !defined(ZLIB_INTERNAL) &amp;&amp; _FILE_OFFSET_BITS-0 == 64 &amp;&amp; _LFS64_LARGEFILE-0
+#  define gzopen gzopen64
+#  define gzseek gzseek64
+#  define gztell gztell64
+#  define gzoffset gzoffset64
+#  define adler32_combine adler32_combine64
+#  define crc32_combine crc32_combine64
+#  ifdef _LARGEFILE64_SOURCE
+     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
+     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
+     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
+     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
+     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
+     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
+#  endif
+#else
+   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
+   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
+   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
+   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
+   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
+   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
+#endif
+
+/* hack for buggy compilers */
+#if !defined(ZUTIL_H) &amp;&amp; !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;};
+#endif
+
+/* undocumented functions */
+ZEXTERN const char   * ZEXPORT zError           OF((int));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ZLIB_H */

Added: Lobby/TASClient/LobbyComponents/delphizlib/zutil.c
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/zutil.c	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/zutil.c	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,318 @@
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-2005, 2010 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* @(#) $Id$ */
+
+#include &quot;zutil.h&quot;
+
+#ifndef NO_DUMMY_DECL
+struct internal_state      {int dummy;}; /* for buggy compilers */
+#endif
+
+const char * const z_errmsg[10] = {
+&quot;need dictionary&quot;,     /* Z_NEED_DICT       2  */
+&quot;stream end&quot;,          /* Z_STREAM_END      1  */
+&quot;&quot;,                    /* Z_OK              0  */
+&quot;file error&quot;,          /* Z_ERRNO         (-1) */
+&quot;stream error&quot;,        /* Z_STREAM_ERROR  (-2) */
+&quot;data error&quot;,          /* Z_DATA_ERROR    (-3) */
+&quot;insufficient memory&quot;, /* Z_MEM_ERROR     (-4) */
+&quot;buffer error&quot;,        /* Z_BUF_ERROR     (-5) */
+&quot;incompatible version&quot;,/* Z_VERSION_ERROR (-6) */
+&quot;&quot;};
+
+
+const char * ZEXPORT zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+uLong ZEXPORT zlibCompileFlags()
+{
+    uLong flags;
+
+    flags = 0;
+    switch ((int)(sizeof(uInt))) {
+    case 2:     break;
+    case 4:     flags += 1;     break;
+    case 8:     flags += 2;     break;
+    default:    flags += 3;
+    }
+    switch ((int)(sizeof(uLong))) {
+    case 2:     break;
+    case 4:     flags += 1 &lt;&lt; 2;        break;
+    case 8:     flags += 2 &lt;&lt; 2;        break;
+    default:    flags += 3 &lt;&lt; 2;
+    }
+    switch ((int)(sizeof(voidpf))) {
+    case 2:     break;
+    case 4:     flags += 1 &lt;&lt; 4;        break;
+    case 8:     flags += 2 &lt;&lt; 4;        break;
+    default:    flags += 3 &lt;&lt; 4;
+    }
+    switch ((int)(sizeof(z_off_t))) {
+    case 2:     break;
+    case 4:     flags += 1 &lt;&lt; 6;        break;
+    case 8:     flags += 2 &lt;&lt; 6;        break;
+    default:    flags += 3 &lt;&lt; 6;
+    }
+#ifdef DEBUG
+    flags += 1 &lt;&lt; 8;
+#endif
+#if defined(ASMV) || defined(ASMINF)
+    flags += 1 &lt;&lt; 9;
+#endif
+#ifdef ZLIB_WINAPI
+    flags += 1 &lt;&lt; 10;
+#endif
+#ifdef BUILDFIXED
+    flags += 1 &lt;&lt; 12;
+#endif
+#ifdef DYNAMIC_CRC_TABLE
+    flags += 1 &lt;&lt; 13;
+#endif
+#ifdef NO_GZCOMPRESS
+    flags += 1L &lt;&lt; 16;
+#endif
+#ifdef NO_GZIP
+    flags += 1L &lt;&lt; 17;
+#endif
+#ifdef PKZIP_BUG_WORKAROUND
+    flags += 1L &lt;&lt; 20;
+#endif
+#ifdef FASTEST
+    flags += 1L &lt;&lt; 21;
+#endif
+#ifdef STDC
+#  ifdef NO_vsnprintf
+        flags += 1L &lt;&lt; 25;
+#    ifdef HAS_vsprintf_void
+        flags += 1L &lt;&lt; 26;
+#    endif
+#  else
+#    ifdef HAS_vsnprintf_void
+        flags += 1L &lt;&lt; 26;
+#    endif
+#  endif
+#else
+        flags += 1L &lt;&lt; 24;
+#  ifdef NO_snprintf
+        flags += 1L &lt;&lt; 25;
+#    ifdef HAS_sprintf_void
+        flags += 1L &lt;&lt; 26;
+#    endif
+#  else
+#    ifdef HAS_snprintf_void
+        flags += 1L &lt;&lt; 26;
+#    endif
+#  endif
+#endif
+    return flags;
+}
+
+#ifdef DEBUG
+
+#  ifndef verbose
+#    define verbose 0
+#  endif
+int ZLIB_INTERNAL z_verbose = verbose;
+
+void ZLIB_INTERNAL z_error (m)
+    char *m;
+{
+    fprintf(stderr, &quot;%s\n&quot;, m);
+    exit(1);
+}
+#endif
+
+/* exported to allow conversion of error code to string for compress() and
+ * uncompress()
+ */
+const char * ZEXPORT zError(err)
+    int err;
+{
+    return ERR_MSG(err);
+}
+
+#if defined(_WIN32_WCE)
+    /* The Microsoft C Run-Time Library for Windows CE doesn't have
+     * errno.  We define it as a global variable to simplify porting.
+     * Its value is always 0 and should not be used.
+     */
+    int errno = 0;
+#endif
+
+#ifndef HAVE_MEMCPY
+
+void ZLIB_INTERNAL zmemcpy(dest, source, len)
+    Bytef* dest;
+    const Bytef* source;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = *source++; /* ??? to be unrolled */
+    } while (--len != 0);
+}
+
+int ZLIB_INTERNAL zmemcmp(s1, s2, len)
+    const Bytef* s1;
+    const Bytef* s2;
+    uInt  len;
+{
+    uInt j;
+
+    for (j = 0; j &lt; len; j++) {
+        if (s1[j] != s2[j]) return 2*(s1[j] &gt; s2[j])-1;
+    }
+    return 0;
+}
+
+void ZLIB_INTERNAL zmemzero(dest, len)
+    Bytef* dest;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = 0;  /* ??? to be unrolled */
+    } while (--len != 0);
+}
+#endif
+
+
+#ifdef SYS16BIT
+
+#ifdef __TURBOC__
+/* Turbo C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
+ * and farmalloc(64K) returns a pointer with an offset of 8, so we
+ * must fix the pointer. Warning: the pointer must be put back to its
+ * original form in order to free it, use zcfree().
+ */
+
+#define MAX_PTR 10
+/* 10*64K = 640K */
+
+local int next_ptr = 0;
+
+typedef struct ptr_table_s {
+    voidpf org_ptr;
+    voidpf new_ptr;
+} ptr_table;
+
+local ptr_table table[MAX_PTR];
+/* This table is used to remember the original form of pointers
+ * to large buffers (64K). Such pointers are normalized with a zero offset.
+ * Since MSDOS is not a preemptive multitasking OS, this table is not
+ * protected from concurrent access. This hack doesn't work anyway on
+ * a protected system like OS/2. Use Microsoft C instead.
+ */
+
+voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    voidpf buf = opaque; /* just to make some compilers happy */
+    ulg bsize = (ulg)items*size;
+
+    /* If we allocate less than 65520 bytes, we assume that farmalloc
+     * will return a usable pointer which doesn't have to be normalized.
+     */
+    if (bsize &lt; 65520L) {
+        buf = farmalloc(bsize);
+        if (*(ush*)&amp;buf != 0) return buf;
+    } else {
+        buf = farmalloc(bsize + 16L);
+    }
+    if (buf == NULL || next_ptr &gt;= MAX_PTR) return NULL;
+    table[next_ptr].org_ptr = buf;
+
+    /* Normalize the pointer to seg:0 */
+    *((ush*)&amp;buf+1) += ((ush)((uch*)buf-0) + 15) &gt;&gt; 4;
+    *(ush*)&amp;buf = 0;
+    table[next_ptr++].new_ptr = buf;
+    return buf;
+}
+
+void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
+{
+    int n;
+    if (*(ush*)&amp;ptr != 0) { /* object &lt; 64K */
+        farfree(ptr);
+        return;
+    }
+    /* Find the original pointer */
+    for (n = 0; n &lt; next_ptr; n++) {
+        if (ptr != table[n].new_ptr) continue;
+
+        farfree(table[n].org_ptr);
+        while (++n &lt; next_ptr) {
+            table[n-1] = table[n];
+        }
+        next_ptr--;
+        return;
+    }
+    ptr = opaque; /* just to make some compilers happy */
+    Assert(0, &quot;zcfree: ptr not found&quot;);
+}
+
+#endif /* __TURBOC__ */
+
+
+#ifdef M_I86
+/* Microsoft C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+#if (!defined(_MSC_VER) || (_MSC_VER &lt;= 600))
+#  define _halloc  halloc
+#  define _hfree   hfree
+#endif
+
+voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    return _halloc((long)items, size);
+}
+
+void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    _hfree(ptr);
+}
+
+#endif /* M_I86 */
+
+#endif /* SYS16BIT */
+
+
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp  malloc OF((uInt size));
+extern voidp  calloc OF((uInt items, uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
+    voidpf opaque;
+    unsigned items;
+    unsigned size;
+{
+    if (opaque) items += size - size; /* make compiler happy */
+    return sizeof(uInt) &gt; 2 ? (voidpf)malloc(items * size) :
+                              (voidpf)calloc(items, size);
+}
+
+void ZLIB_INTERNAL zcfree (opaque, ptr)
+    voidpf opaque;
+    voidpf ptr;
+{
+    free(ptr);
+    if (opaque) return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */

Added: Lobby/TASClient/LobbyComponents/delphizlib/zutil.h
===================================================================
--- Lobby/TASClient/LobbyComponents/delphizlib/zutil.h	                        (rev 0)
+++ Lobby/TASClient/LobbyComponents/delphizlib/zutil.h	2011-02-19 18:56:51 UTC (rev 7585)
@@ -0,0 +1,274 @@
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995-2010 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id$ */
+
+#ifndef ZUTIL_H
+#define ZUTIL_H
+
+#if ((__GNUC__-0) * 10 + __GNUC_MINOR__-0 &gt;= 33) &amp;&amp; !defined(NO_VIZ)
+#  define ZLIB_INTERNAL __attribute__((visibility (&quot;hidden&quot;)))
+#else
+#  define ZLIB_INTERNAL
+#endif
+
+#include &quot;zlib.h&quot;
+
+#ifdef STDC
+#  if !(defined(_WIN32_WCE) &amp;&amp; defined(_MSC_VER))
+#    include &lt;stddef.h&gt;
+#  endif
+#  include &lt;string.h&gt;
+#  include &lt;stdlib.h&gt;
+#endif
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
+/* (size given to avoid silly warnings with Visual C++) */
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm-&gt;msg = (char*)ERR_MSG(err), (err))
+/* To be used only when the state is known to be valid */
+
+        /* common constants */
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL &gt;= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
+
+        /* target dependencies */
+
+#if defined(MSDOS) || (defined(WINDOWS) &amp;&amp; !defined(WIN32))
+#  define OS_CODE  0x00
+#  if defined(__TURBOC__) || defined(__BORLANDC__)
+#    if (__STDC__ == 1) &amp;&amp; (defined(__LARGE__) || defined(__COMPACT__))
+       /* Allow compilation with ANSI keywords only enabled */
+       void _Cdecl farfree( void *block );
+       void *_Cdecl farmalloc( unsigned long nbytes );
+#    else
+#      include &lt;alloc.h&gt;
+#    endif
+#  else /* MSC or DJGPP */
+#    include &lt;malloc.h&gt;
+#  endif
+#endif
+
+#ifdef AMIGA
+#  define OS_CODE  0x01
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define OS_CODE  0x02
+#  define F_OPEN(name, mode) \
+     fopen((name), (mode), &quot;mbc=60&quot;, &quot;ctx=stm&quot;, &quot;rfm=fix&quot;, &quot;mrs=512&quot;)
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  define OS_CODE  0x05
+#endif
+
+#ifdef OS2
+#  define OS_CODE  0x06
+#  ifdef M_I86
+#    include &lt;malloc.h&gt;
+#  endif
+#endif
+
+#if defined(MACOS) || defined(TARGET_OS_MAC)
+#  define OS_CODE  0x07
+#  if defined(__MWERKS__) &amp;&amp; __dest_os != __be_os &amp;&amp; __dest_os != __win32_os
+#    include &lt;unix.h&gt; /* for fdopen */
+#  else
+#    ifndef fdopen
+#      define fdopen(fd,mode) NULL /* No fdopen() */
+#    endif
+#  endif
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#ifdef WIN32
+#  ifndef __CYGWIN__  /* Cygwin is Unix, not Win32 */
+#    define OS_CODE  0x0b
+#  endif
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define OS_CODE  0x0f
+#endif
+
+#if defined(_BEOS_) || defined(RISCOS)
+#  define fdopen(fd,mode) NULL /* No fdopen() */
+#endif
+
+#if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 600)) &amp;&amp; !defined __INTERIX
+#  if defined(_WIN32_WCE)
+#    define fdopen(fd,mode) NULL /* No fdopen() */
+#    ifndef _PTRDIFF_T_DEFINED
+       typedef int ptrdiff_t;
+#      define _PTRDIFF_T_DEFINED
+#    endif
+#  else
+#    define fdopen(fd,type)  _fdopen(fd,type)
+#  endif
+#endif
+
+#if defined(__BORLANDC__)
+  #pragma warn -8004
+  #pragma warn -8008
+  #pragma warn -8066
+#endif
+
+/* provide prototypes for these when building zlib without LFS */
+#if !defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0
+    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
+    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
+#endif
+
+        /* common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef F_OPEN
+#  define F_OPEN(name, mode) fopen((name), (mode))
+#endif
+
+         /* functions */
+
+#if defined(STDC99) || (defined(__TURBOC__) &amp;&amp; __TURBOC__ &gt;= 0x550)
+#  ifndef HAVE_VSNPRINTF
+#    define HAVE_VSNPRINTF
+#  endif
+#endif
+#if defined(__CYGWIN__)
+#  ifndef HAVE_VSNPRINTF
+#    define HAVE_VSNPRINTF
+#  endif
+#endif
+#ifndef HAVE_VSNPRINTF
+#  ifdef MSDOS
+     /* vsnprintf may exist on some MS-DOS compilers (DJGPP?),
+        but for now we just assume it doesn't. */
+#    define NO_vsnprintf
+#  endif
+#  ifdef __TURBOC__
+#    define NO_vsnprintf
+#  endif
+#  ifdef WIN32
+     /* In Win32, vsnprintf is available as the &quot;non-ANSI&quot; _vsnprintf. */
+#    if !defined(vsnprintf) &amp;&amp; !defined(NO_vsnprintf)
+#      if !defined(_MSC_VER) || ( defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1500 )
+#         define vsnprintf _vsnprintf
+#      endif
+#    endif
+#  endif
+#  ifdef __SASC
+#    define NO_vsnprintf
+#  endif
+#endif
+#ifdef VMS
+#  define NO_vsnprintf
+#endif
+
+#if defined(pyr)
+#  define NO_MEMCPY
+#endif
+#if defined(SMALL_MEDIUM) &amp;&amp; !defined(_MSC_VER) &amp;&amp; !defined(__SC__)
+ /* Use our own functions for small and medium model with MSC &lt;= 5.0.
+  * You may have to use the same strategy for Borland C (untested).
+  * The __SC__ check is for Symantec.
+  */
+#  define NO_MEMCPY
+#endif
+#if defined(STDC) &amp;&amp; !defined(HAVE_MEMCPY) &amp;&amp; !defined(NO_MEMCPY)
+#  define HAVE_MEMCPY
+#endif
+#ifdef HAVE_MEMCPY
+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
+#    define zmemcpy _fmemcpy
+#    define zmemcmp _fmemcmp
+#    define zmemzero(dest, len) _fmemset(dest, 0, len)
+#  else
+#    define zmemcpy memcpy
+#    define zmemcmp memcmp
+#    define zmemzero(dest, len) memset(dest, 0, len)
+#  endif
+#else
+   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
+   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
+   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
+#endif
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  include &lt;stdio.h&gt;
+   extern int ZLIB_INTERNAL z_verbose;
+   extern void ZLIB_INTERNAL z_error OF((char *m));
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) {if (z_verbose&gt;=0) fprintf x ;}
+#  define Tracev(x) {if (z_verbose&gt;0) fprintf x ;}
+#  define Tracevv(x) {if (z_verbose&gt;1) fprintf x ;}
+#  define Tracec(c,x) {if (z_verbose&gt;0 &amp;&amp; (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (z_verbose&gt;1 &amp;&amp; (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
+                        unsigned size));
+void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)-&gt;zalloc))((strm)-&gt;opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)-&gt;zfree))((strm)-&gt;opaque, (voidpf)(addr))
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+#endif /* ZUTIL_H */

Modified: Lobby/TASClient/LobbyScriptUnit.pas
===================================================================
--- Lobby/TASClient/LobbyScriptUnit.pas	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/LobbyScriptUnit.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -230,6 +230,8 @@
       procedure DownloadMap2(mapName: string; callbackArgs: Variant; callbackFunction: Variant);
       procedure DownloadMod(modName: string; callbackArgs: Variant; callbackModuleName: string; callbackFunctionName: string);
       procedure DownloadMod2(modName: string; callbackArgs: Variant; callbackFunction: Variant);
+      procedure DownloadRapid(rapidName: string; callbackArgs: Variant; callbackModuleName: string; callbackFunctionName: string);
+      procedure DownloadRapid2(rapidName: string; callbackArgs: Variant; callbackFunction: Variant);
 
       procedure DownloadCallbackEvent(snc: PScriptDownloadCallback;progress: integer);
 
@@ -318,6 +320,7 @@
   ChangeMapIndex: integer;
   MapDownloadList: TList;
   ModDownloadList: TList;
+  RapidDownloadList: TList;
   GUICS: TCriticalSection;
   
 
@@ -1503,6 +1506,39 @@
     DownloadMap2(mapName,callbackArgs,PyObjectAsVariant(FindFunction(callbackModuleName,callbackFunctionName)));
 end;
 
+procedure TCallback.DownloadRapid(rapidName: string; callbackArgs: Variant; callbackModuleName: string; callbackFunctionName: string);
+begin
+  with GetPythonEngine do
+    DownloadRapid2(rapidName,callbackArgs,PyObjectAsVariant(FindFunction(callbackModuleName,callbackFunctionName)));
+end;
+
+procedure TCallback.DownloadRapid2(rapidName: string; callbackArgs: Variant; callbackFunction: Variant);
+var
+  snc : PScriptDownloadCallback;
+  params: PFileDownloadInfo;
+begin
+  New(snc);
+  with GetPythonEngine do
+  begin
+    snc.func := VariantAsPyObject(callbackFunction);
+    snc.args := VariantAsPyObject(callbackArgs);
+    PyList_Insert(snc.args,0,PyLong_FromLong(0));
+  end;
+  try
+    New(params);
+    params.name := rapidName;
+    params.params := snc;
+    params.cb := Self;
+
+    RapidDownloadList.Add(params);
+
+    PostMessage(MainForm.Handle,WM_SCRIPT,5,0);
+  except
+    on E:Exception do
+      Print(E.Message);
+  end;
+end;
+
 procedure TCallback.DownloadMod(modName: string; callbackArgs: Variant; callbackModuleName: string; callbackFunctionName: string);
 begin
   with GetPythonEngine do
@@ -3104,6 +3140,13 @@
     FreeMemory(dlInfo);
   end;
   ModDownloadList.Clear;
+  for i:=0 to RapidDownloadList.Count-1 do
+  begin
+    dlInfo := RapidDownloadList[i];
+    SpringDownloaderFormUnit.DownloadRapid(dlInfo.name,dlInfo.params,dlInfo.cb);
+    FreeMemory(dlInfo);
+  end;
+  RapidDownloadList.Clear;
 end;
 
 //------------------------------------------------------------------------------------------------------

Modified: Lobby/TASClient/MainUnit.dfm
===================================================================
--- Lobby/TASClient/MainUnit.dfm	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/MainUnit.dfm	2011-02-19 18:56:51 UTC (rev 7585)
@@ -1,6 +1,6 @@
 object MainForm: TMainForm
-  Left = 420
-  Top = 234
+  Left = 470
+  Top = 99
   Width = 883
   Height = 553
   Caption = 'TASClient'

Modified: Lobby/TASClient/MainUnit.pas
===================================================================
--- Lobby/TASClient/MainUnit.pas	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/MainUnit.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -59,7 +59,7 @@
       'UPDATEBOT',
       'RING'
     );
-  CommandList : array[0..43] of string =
+  CommandList : array[0..44] of string =
    (
       'CONNECT',
       'QUIT',
@@ -104,7 +104,8 @@
       'ISNTAUTOHOST',
       'GETDOWNLOADLINKS',
       'DOWNLOADMAP',
-      'DOWNLOADMOD'
+      'DOWNLOADMOD',
+      'DOWNLOADRAPID'
    ) ;
   CountryNames: array[0..240] of string = (
   'Unknown country xx',
@@ -422,7 +423,7 @@
   );
 
 const
-  VERSION_NUMBER = '0.86'; // Must be float value! (with a period as a decimal seperator)
+  VERSION_NUMBER = '0.87'; // Must be float value! (with a period as a decimal seperator)
   AUTOUPDATE_URL = '<A HREF="http://tasclient.no-ip.org/TASClient_update_v5.txt">http://tasclient.no-ip.org/TASClient_update_v5.txt</A>';
   PROGRAM_VERSION = 'TASClient ' + VERSION_NUMBER;
   KEEP_ALIVE_INTERVAL = 10000; // in milliseconds. Tells us what should be the maximum &quot;silence&quot; time before we send a ping to the server.
@@ -5224,6 +5225,15 @@
       end;
       SpringDownloaderFormUnit.DownloadMod(0,MakeSentenceWS(sl,1));
     end
+    else if sl[0] = 'DOWNLOADRAPID' then
+    begin
+      if sl.Count &lt; 2 then
+      begin
+        AddMainLog(_('Usage: /downloadrapid rapidname(ex: ba:latest)'), Colors.Error);
+        Exit;
+      end;
+      SpringDownloaderFormUnit.DownloadRapid(MakeSentenceWS(sl,1));
+    end
     else if (sl[0] = 'ISSPADSAUTOHOST') and CameFromBattleScreen and (BattleState.Status = Joined) then
     begin
       tmpBool := BattleForm.ChatRichEdit.atBottom;
@@ -13271,6 +13281,7 @@
       LobbyScriptUnit.PlayerIconTypeIconsNames := TList.Create;
       LobbyScriptUnit.MapDownloadList := TList.Create;
       LobbyScriptUnit.ModDownloadList := TList.Create;
+      LobbyScriptUnit.RapidDownloadList := TList.Create;
       LobbyScriptUnit.GUICS := TCriticalSection.Create;
 
       handlers._load;

Modified: Lobby/TASClient/Misc.pas
===================================================================
--- Lobby/TASClient/Misc.pas	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/Misc.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -14,7 +14,7 @@
   Controls, Registry, SysUtils,RichEdit2, ExRichEdit, OverbyteIcsWSocket, Winsock, Mapi ,
   ESBDates, GpTimeZone, JvColorCombo, Forms,StdCtrls,OverbyteIcsHttpProt,TntComCtrls,
   JclUnicode,TntSysUtils,PreferencesFormUnit,Variants,typinfo, OpenIL, DockPanel,
-  IdHashMessageDigest, idHash;
+  IdHashMessageDigest, idHash, shlobj;
 
 type
   TColorData = Array[0..128000] Of TRGBTriple;
@@ -189,6 +189,11 @@
 function CompareBoolean(b1: Boolean;b2: Boolean): Integer;
 function CompareArgs(const Args1: array of const; const Args2: array of const; idx: integer=0): Integer;
 function ComplementaryTextColor(c: TColor):TColor;
+function GetMyDocuments: string;
+function SwapEndian(Value: Cardinal): Cardinal; register; overload;
+function SwapEndian(Value: integer): integer; register; overload;
+function SwapEndian(Value: smallint): smallint; register; overload;
+function SwapEndian(Value : int64) : int64 ; register; overload;
 
 implementation
 
@@ -3418,4 +3423,41 @@
     result := clWhite;
 end;
 
+function GetMyDocuments: string;
+var
+  r: Bool;
+  path: array[0..Max_Path] of Char;
+begin
+  r := ShGetSpecialFolderPath(0, path, CSIDL_Personal, False) ;
+  if not r then
+    raise Exception.Create('Could not find MyDocuments folder location.') ;
+  Result := Path;
+end;
+
+function SwapEndian(Value: Cardinal): Cardinal; register; overload;
+asm
+  bswap eax
+end;
+
+function SwapEndian(Value: integer): integer; register; overload;
+asm
+  bswap eax
+end;
+
+function SwapEndian(Value: smallint): smallint; register; overload;
+asm
+  xchg  al, ah
+end;
+
+function SwapEndian(Value : int64) : int64 ; overload;
+asm
+  mov edx,dword ptr [Value]
+  mov eax,dword ptr [Value+4]
+  bswap edx
+  bswap eax
+end;
+
+
+
+
 end.

Modified: Lobby/TASClient/Python/api.txt
===================================================================
--- Lobby/TASClient/Python/api.txt	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/Python/api.txt	2011-02-19 18:56:51 UTC (rev 7585)
@@ -31,6 +31,7 @@
 - onChatDblClick(channel,charPos,line) return dontLetLobbyHandleIt : boolean
 - onStartSpring(args) return newArgs : string
 - onBackFromGame
+- onDownloadRapidStart(formName,rapidName) return Cancel : boolan
 - onDownloadModStart(formName,modHash,modName) return Cancel : boolean
 - onDownloadMapStart(formName,mapHash,mapName) return Cancel : boolean
 - timer_NBSECONDSINTERVAL()
@@ -85,6 +86,9 @@
 - DownloadMod(modName,callBackArgs,callBackModuleName,callBackFunctionName)
   DownloadMod2(modName,callBackArgs,callBackFunction)
 	Same as DownloadMap
+- DownloadRapid(rapidName,callBackArgs,callBackModuleName,callBackFunctionName)
+  DownloadRapid2(rapidName,callBackArgs,callBackFunction)
+	Same as DownloadMap
 - GetSpringExe 
 	return the full spring exe path
 

Modified: Lobby/TASClient/Python/engine/handlers.py
===================================================================
--- Lobby/TASClient/Python/engine/handlers.py	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/Python/engine/handlers.py	2011-02-19 18:56:51 UTC (rev 7585)
@@ -242,6 +242,9 @@
 def onChatDblClick(channel,charPos,line):
 	return _handle_callin('onChatDblClick',channel+' '+str(charPos)+' '+line)
 	
+def onDownloadRapidStart(formName,rapidName):
+	return _handle_callin('onDownloadModStart',formName+' '+rapidName)
+	
 def onDownloadModStart(formName,modHash,modName):
 	return _handle_callin('onDownloadModStart',formName+' '+str(modHash)+' '+modName)
 	

Modified: Lobby/TASClient/SpringDownloaderFormUnit.pas
===================================================================
--- Lobby/TASClient/SpringDownloaderFormUnit.pas	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/SpringDownloaderFormUnit.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -11,8 +11,20 @@
   OverbyteIcsMultipartHttpDownloader;
 
 type
+  TRapidFileInfo =
+  record
+    Size: Cardinal;
+    Md5: string;
+    crc: Cardinal;
+    realName: string;
+    poolPath: string;
+  end;
+  PRapidFileInfo = ^TRapidFileInfo;
+
   TProgressEvent = procedure(snc: PScriptDownloadCallback;progress: integer) of object;
 
+  TRapidDownloadThread = class;
+
   TSpringDownloaderForm = class(TForm)
     SpTBXTitleBar1: TSpTBXTitleBar;
     tmrProgress: TTimer;
@@ -55,6 +67,14 @@
     parentDownloadForm: TSpringDownloaderForm;
     dependenciesDlForm: TList;
     downloadCanceled: boolean;
+    FNormalDownload: Boolean;
+    FDownloadCurrent: Int64;
+    FDownloadTotal: Int64;
+    FDownloadStartTime: TDateTime;
+    FDownloadCurSpeed: Extended;
+    FDownloadLastSpeedUpdate: TDateTime;
+    FDownloadLastSizeUpdate: Int64;
+    FRapidDownloadThread: TRapidDownloadThread;
 
     downloading: boolean;
     timeOutCounter: integer;
@@ -67,10 +87,41 @@
     cbInfo: PScriptDownloadCallback;
     procedure StartDownload(dlType: string; dlHash : integer; dlName: string; joinBattleWhenDownloadComplete : integer = 0);
     property OnProgress: TProgressEvent read FOnProgress write FOnProgress;
+    procedure NormalDownload;
+    procedure DownloadProgress(current: Int64; total: Int64;done: boolean = False; failed: boolean = False; rapidFailed: boolean = False; failedMsg: string = '');
   end;
 
+  TRapidDownloadThread = class(TThread)
+  private
+    procedure OnTerminateProcedure(Sender : TObject);
+
+  protected
+    FModName: string;
+    FRapidName: string;
+    FExceptionMsg: string;
+    FDlerForm: TSpringDownloaderForm;
+    FhttpGet: THttpCli;
+    FhttpPost: THttpCli;
+    FAbord: Boolean;
+    FDep: string;
+
+    procedure RaiseException;
+    procedure DownloadStart;
+    procedure DownloadDone;
+    procedure DownloadDep;
+    procedure Execute; override;
+    procedure DownloadDocData(Sender: TObject; Buffer: Pointer; Len: Integer);
+
+  procedure ExceptionRaised(msg: string);
+    procedure RapidDownload(modName: string; rapidName: string = '');
+  public
+    constructor Create(Suspended : Boolean; dlerForm: TSpringDownloaderForm; modName: string; rapidName: string = '');
+    procedure Abort;
+  end;
+
   function GetDownloadLinks(name: string; var dependencies: TStringList): TStringList;
   function DownloadMod(modHash : integer; modName: string; joinBattleWhenDownloadComplete : integer = 0; scriptCallBack: PScriptDownloadCallback = nil; cb: TCallback=nil):TSpringDownloaderForm;
+  function DownloadRapid(rapidName: string; scriptCallBack: PScriptDownloadCallback = nil; cb: TCallback=nil):TSpringDownloaderForm;
   function DownloadMap(mapHash : integer; mapName: string; noBrowser : boolean = False; scriptCallBack: PScriptDownloadCallback = nil; cb: TCallback=nil):TSpringDownloaderForm;
   procedure StartSpringDownloader;
   procedure CloseSpringDownloader;
@@ -89,7 +140,7 @@
 implementation
 
 uses  BattleFormUnit,PreferencesFormUnit, MainUnit, StrUtils, Misc, ComObj, gnugettext,
-      Utility;
+      Utility,BitList,ZLibExGZ;
 
 {$R *.dfm}
 
@@ -182,10 +233,7 @@
 procedure TSpringDownloaderForm.StartDownload(dlType: string; dlHash : integer; dlName: string; joinBattleWhenDownloadComplete : integer = 0);
 var
   sl: TStringList;
-  dep: TStringList;
   path : string;
-  i: integer;
-  dlForm: TSpringDownloaderForm;
 begin
   DownloadList.BeginUpdate;
   DownloadList.Add(dlName);
@@ -204,41 +252,48 @@
   Self.Caption := lblInfo.Caption;
 
   ShowAndSetFocus(CancelButton);
-  dep := TStringList.Create;
-  downloadLinks := GetDownloadLinks(dlName,dep);
 
-  for i:=0 to dep.Count-1 do
-    if Utility.ModList.IndexOf(dep[i]) = -1 then
-    begin
-      dlForm := DownloadMod(0,dep[i]);
-      //if joinBattleWhenDownloadComplete &lt;&gt; 0 then
-      begin
-        dependenciesDlForm.Add(dlForm);
-        dlForm.parentDownloadForm := Self;
-      end;
-    end;
+  if dlType = 'MOD' then
+  begin
+    FNormalDownload := False;
+    FRapidDownloadThread := TRapidDownloadThread.Create(false,Self,dlName);
+  end
+  else if dlType = 'RAPID' then
+  begin
+    FNormalDownload := False;
+    FRapidDownloadThread := TRapidDownloadThread.Create(false,Self,'',dlName);
+  end
+  else
+    NormalDownload;
+end;
 
-
-  tmrProgress.Enabled := True;
-
-  TryNextLink;
-
-  Exit;
-
-  // SpringDownloader code
-
-  sl := TStringList.Create;
-  sl.Add(dlType);
-  sl.Add(IntToStr(dlHash));
-  sl.Add(dlName);
-
-  path := StringReplace(ExtractFilePath(Application.ExeName),'\','/',[rfReplaceAll]);
-  path := LeftStr(path,Length(path)-1);
-
-  RegWriteMultiSz(HKCU,'\Software\SpringDownloader\'+path+'\request\',dlName,sl);
-  downloading := False;
-  tmrProgress.Enabled := True;
-  tmrTimeout.Enabled := True;
+function DownloadRapid(rapidName: string; scriptCallBack: PScriptDownloadCallback = nil; cb: TCallback=nil):TSpringDownloaderForm;
+var
+  url: string;
+  cancel: boolean;
+begin
+  CleanUnusedDownloadForms;
+  if DownloadList.IndexOf(rapidName) &lt;&gt; -1 then
+    Exit;
+  Application.CreateForm(TSpringDownloaderForm, Result);
+  if scriptCallBack &lt;&gt; nil then
+  begin
+    Result.cbInfo := scriptCallBack;
+    Result.cbInfo.form := Result;
+    Result.OnProgress := cb.DownloadCallbackEvent;
+  end;
+  cancel := False;
+  if AcquireMainThread then
+  begin
+    try if not Preferences.ScriptsDisabled then cancel := handlers.onDownloadRapidStart(LobbyScriptUnit.GetStringFromComponent(Result),rapidName); except end;
+    ReleaseMainThread;
+  end;
+  if cancel then
+    Result.CancelButtonClick(nil)
+  else
+  begin
+    Result.StartDownload('RAPID',0,rapidName,0);
+  end;
 end;
 
 function DownloadMod(modHash : integer; modName: string; joinBattleWhenDownloadComplete : integer = 0; scriptCallBack: PScriptDownloadCallback = nil; cb: TCallback=nil):TSpringDownloaderForm;
@@ -276,7 +331,6 @@
     Result.StartDownload('MOD',modHash,modName,joinBattleWhenDownloadComplete);
     //Misc.ShowAndSetFocus(Result.CancelButton);
   end;
-
 end;
 
 function GetDownloadLinks(name: string; var dependencies: TStringList): TStringList;
@@ -387,19 +441,36 @@
 procedure TSpringDownloaderForm.tmrProgressTimer(Sender: TObject);
 var
   remainingMS: integer;
+  percentDone: Extended;
 begin
-  remainingMS := Floor(min(86400,(MultisourceHttpDownloader1.ContentLength-MultisourceHttpDownloader1.TotalCount)/(1024*MultisourceHttpDownloader1.TotalCount/((Now-MultisourceHttpDownloader1.StartTime)*86400000))));
-  ProgressBar.Position := Floor(MultisourceHttpDownloader1.PercentDone);
+  if FNormalDownload then
+  begin
+    FDownloadTotal := MultisourceHttpDownloader1.ContentLength;
+    FDownloadCurrent := MultisourceHttpDownloader1.TotalCount;
+    FDownloadStartTime := MultisourceHttpDownloader1.StartTime;
+    FDownloadCurSpeed := MultisourceHttpDownloader1.CurSpeed;
+  end
+  else
+  begin
+    FDownloadCurSpeed := 8*(FDownloadCurrent-FDownloadLastSizeUpdate)/(Now-FDownloadLastSpeedUpdate)/100000000;
+    FDownloadLastSpeedUpdate := Now;
+    FDownloadLastSizeUpdate := FDownloadCurrent;
+  end;
+
+  percentDone := 100*FDownloadCurrent/FDownloadTotal;
+
+  remainingMS := Floor(min(86400,(FDownloadTotal-FDownloadCurrent)/(1024*FDownloadCurrent/((Now-FDownloadStartTime)*86400000))));
+  ProgressBar.Position := Floor(percentDone);
   if Assigned(FOnProgress) then
-    FOnProgress(cbInfo,Floor(MultisourceHttpDownloader1.PercentDone));
+    FOnProgress(cbInfo,Floor(percentDone));
   try
-    lblProgress.Caption := _('Progress : ')+Format(_('Received %s (%d%%)'),[Misc.FormatFileSize3([Integer(MultisourceHttpDownloader1.TotalCount),Integer(MultisourceHttpDownloader1.ContentLength)],'%s/%s %u'),Round(MultisourceHttpDownloader1.PercentDone)])+' '+Format(_(' - %dkB/s'),[Round(MultisourceHttpDownloader1.CurSpeed/8)]);
+    lblProgress.Caption := _('Progress : ')+Format(_('Received %s (%d%%)'),[Misc.FormatFileSize3([Integer(FDownloadCurrent),Integer(FDownloadTotal)],'%s/%s %u'),Round(percentDone)])+' '+Format(_(' - %dkB/s'),[Round(FDownloadCurSpeed/8)]);
     if remainingMS &gt; 60 then
       lblRemainingTime.Caption := _('Remaining time : ')+Format('%d min %d seconds',[remainingMS div 60,remainingMS mod 60])
     else
       lblRemainingTime.Caption := _('Remaining time : ')+Format('%d seconds',[remainingMS]);
   except
-    lblProgress.Caption := 'Progress : '+Format('Received %s (%d%%)',[Misc.FormatFileSize3([Integer(MultisourceHttpDownloader1.TotalCount),Integer(MultisourceHttpDownloader1.ContentLength)],'%s/%s %u'),Round(MultisourceHttpDownloader1.PercentDone)])+' '+Format(' - %dkB/s',[Round(MultisourceHttpDownloader1.CurSpeed/8)]);
+    lblProgress.Caption := 'Progress : '+Format('Received %s (%d%%)',[Misc.FormatFileSize3([Integer(FDownloadCurrent),Integer(FDownloadTotal)],'%s/%s %u'),Round(percentDone)])+' '+Format(' - %dkB/s',[Round(FDownloadCurSpeed/8)]);
   end;
 end;
 
@@ -472,6 +543,8 @@
 begin
   if downloadCanceled then
   begin
+    if FRapidDownloadThread &lt;&gt; nil then
+      FRapidDownloadThread.Abort;
     try
       downloadLinks.Clear;
       HttpCli1.Abort;
@@ -547,32 +620,111 @@
   RegWriteMultiSz(HKCU,'\Software\SpringDownloader\'+path+'\request\','ExitRequest',sl);
 end;
 
-procedure TSpringDownloaderForm.HttpCli1DocData(Sender: TObject;
-  Buffer: Pointer; Len: Integer);
+procedure TSpringDownloaderForm.NormalDownload;
+var
+  dep: TStringList;
+  i: integer;
+  dlForm: TSpringDownloaderForm;
 begin
-  try
-    lblProgress.Caption := _('Progress : ')+Format(_('Received %s kB (%d%%)'),[Misc.FormatFileSize(HttpCli1.RcvdStream.Size),Round(HttpCli1.RcvdStream.Size / HttpCli1.ContentLength * 100)])
-  except
-    lblProgress.Caption := _('Progress : ')+Format('Received %s kB (%d%%)',[Misc.FormatFileSize(HttpCli1.RcvdStream.Size),Round(HttpCli1.RcvdStream.Size / HttpCli1.ContentLength * 100)])
-  end;
-  ProgressBar.Position := Round(HttpCli1.RcvdStream.Size / HttpCli1.ContentLength * 100);
+  FNormalDownload := True;
+
+  dep := TStringList.Create;
+  downloadLinks := GetDownloadLinks(downloadName,dep);
+
+  for i:=0 to dep.Count-1 do
+    if Utility.ModList.IndexOf(dep[i]) = -1 then
+    begin
+      dlForm := DownloadMod(0,dep[i]);
+      dependenciesDlForm.Add(dlForm);
+      dlForm.parentDownloadForm := Self;
+    end;
+
+
+  tmrProgress.Enabled := True;
+
+  TryNextLink;
 end;
 
-procedure TSpringDownloaderForm.HttpCli1DocBegin(Sender: TObject);
+procedure TSpringDownloaderForm.DownloadProgress(current: Int64; total: Int64;done: boolean; failed: boolean; rapidFailed: boolean; failedMsg: string);
 var
-  FileStream: TFileStream;
+  i: integer;
+  battle: TBattle;
 begin
   lblInfo.Caption := Format(_('Downloading %s ...'),[downloadName]);
-
-  if fileName = '' then
+  if done then
   begin
+    tmrProgress.Enabled := False;
+    ProgressBar.Position := ProgressBar.Max;
+    lblInfo.Caption := _('Done.');
+    if parentDownloadForm &lt;&gt; nil then
+      parentDownloadForm.DependencyDownloadComplete(Self);
+    If downloadType = 'MAP' then
+      BattleForm.ReloadMapListButtonClick(nil);
+    if joinBattleCheckBox.Checked and (dependenciesDlForm.Count = 0) then
+    begin
+      for i:=0 to dependenciesDlForm.Count-1 do
+        TSpringDownloaderForm(dependenciesDlForm[i]).parentDownloadForm := nil;
+      dependenciesDlForm.Clear;
+      battle := MainForm.GetBattle(joinBattleId);
+      if battle &lt;&gt; nil then
+        MainForm.JoinBattle(battle);
+    end;
+    if dependenciesDlForm.Count &gt; 0 then
+    begin
+      lblInfo.Caption := _('Downloading dependencies ...');
+    end
+    else
+    begin
+      if Assigned(FOnProgress) then
+        FOnProgress(cbInfo,-1);
+      Close;
+    end;
+  end
+  else if failed then
+  begin
     lblInfo.Caption := _('Download failed (')+downloadName+')';
+    if failedMsg &lt;&gt; '' then
+      lblInfo.Caption := lblInfo.Caption + ' : ' + failedMsg;
     lblInfo.Font.Color := clRed;
     CancelButton.Caption := _('Exit');
     if Assigned(FOnProgress) then
       FOnProgress(cbInfo,-2);
+  end
+  else
+  begin
+    if current = -1 then
+    begin
+      FDownloadCurrent := 0;
+      FDownloadTotal := 1;
+      FDownloadStartTime := Now;
+      FDownloadCurSpeed := 1;
+      tmrProgress.Enabled := True;
+      FDownloadLastSizeUpdate := 0;
+      FDownloadLastSpeedUpdate := Now;
+    end
+    else
+    begin
+      FDownloadCurrent := current;
+      FDownloadTotal := total;
+    end;
   end;
+end;
 
+procedure TSpringDownloaderForm.HttpCli1DocData(Sender: TObject;
+  Buffer: Pointer; Len: Integer);
+begin
+  DownloadProgress(THttpCli(Sender).RcvdStream.Size,THttpCli(Sender).ContentLength);
+end;
+
+procedure TSpringDownloaderForm.HttpCli1DocBegin(Sender: TObject);
+var
+  FileStream: TFileStream;
+begin
+  if fileName = '' then
+  begin
+    DownloadProgress(0,0,true);
+  end;
+
   try
     FileStream := TFileStream.Create(fileName, fmCreate);
     HttpCli1.RcvdStream := FileStream;
@@ -586,9 +738,6 @@
 
 procedure TSpringDownloaderForm.MultisourceHttpDownloader1RequestDone(
   Sender: TObject; ErrorCode: Integer; const Reason: String);
-var
-  battle: TBattle;
-  i: integer;
 begin
   tmrProgress.Enabled := False;
 
@@ -597,11 +746,7 @@
     MultisourceHttpDownloader1.FileStream.Destroy;
     if FileExists(fileName) then
       DeleteFile(fileName);
-    lblInfo.Caption := _('Download failed (')+downloadName+')';
-    lblInfo.Font.Color := clRed;
-    CancelButton.Caption := _('Exit');
-    if Assigned(FOnProgress) then
-      FOnProgress(cbInfo,-2);
+    DownloadProgress(0,0,true);
     Exit;
   end;
 
@@ -610,31 +755,7 @@
   except
   end;
   MultisourceHttpDownloader1.FileStream := nil;
-  ProgressBar.Position := ProgressBar.Max;
-  lblInfo.Caption := _('Done.');
-  if parentDownloadForm &lt;&gt; nil then
-    parentDownloadForm.DependencyDownloadComplete(Self);
-  If downloadType = 'MAP' then
-    BattleForm.ReloadMapListButtonClick(nil);
-  if joinBattleCheckBox.Checked and (dependenciesDlForm.Count = 0) then
-  begin
-    for i:=0 to dependenciesDlForm.Count-1 do
-      TSpringDownloaderForm(dependenciesDlForm[i]).parentDownloadForm := nil;
-    dependenciesDlForm.Clear;
-    battle := MainForm.GetBattle(joinBattleId);
-    if battle &lt;&gt; nil then
-      MainForm.JoinBattle(battle);
-  end;
-  if dependenciesDlForm.Count &gt; 0 then
-  begin
-    lblInfo.Caption := _('Downloading dependencies ...');
-  end
-  else
-  begin
-    if Assigned(FOnProgress) then
-      FOnProgress(cbInfo,-1);
-    Close;
-  end;
+  DownloadProgress(0,0,true);
 end;
 
 procedure TSpringDownloaderForm.MultisourceHttpDownloader1Display(
@@ -658,4 +779,328 @@
   end;
 end;
 
+
+procedure TRapidDownloadThread.OnTerminateProcedure(Sender : TObject);
+begin
+  inherited;
+end;
+
+procedure TRapidDownloadThread.Execute;
+begin
+  RapidDownload(FModName,FRapidName);
+end;
+
+procedure TRapidDownloadThread.DownloadStart;
+begin
+  if FDlerForm &lt;&gt; nil then
+    FDlerForm.DownloadProgress(-1,0);
+end;
+
+procedure TRapidDownloadThread.DownloadDone;
+begin
+  if FDlerForm &lt;&gt; nil then
+    FDlerForm.DownloadProgress(0,0,true);
+end;
+
+procedure TRapidDownloadThread.DownloadDep;
+var
+  dlForm: TSpringDownloaderForm;
+begin
+  dlForm := DownloadRapid(FDep);
+  if FDlerForm &lt;&gt; nil then
+  begin
+    FDlerForm.dependenciesDlForm.Add(dlForm);
+    dlForm.parentDownloadForm := FDlerForm;
+  end;
+end;
+
+procedure TRapidDownloadThread.RapidDownload(modName: string; rapidName: string);
+var
+  decompressedStream: TMemoryStream;
+  tagListStr: string;
+  i: integer;
+  decompressedStreamSize: integer;
+  tagValue: string;
+  tagValues: TStringList;
+  cp: PChar;
+  fileNameLength: Byte;
+  fileRealName: string;
+  fileMd5: array[0..15] of Char;
+  fileMd5Str: string;
+  fileCRC: Cardinal;
+  fileSize: Cardinal;
+  filesBitArray: TBitList;
+  fileMd5Path: string;
+  fileInfo: PRapidFileInfo;
+  bitArrayStream: TMemoryStream;
+  compressedBitArray: TMemoryStream;
+  filesStream: TFileStream;
+  filesList: TList;
+  fileContent: string;
+  fileStream: TFileStream;
+  fileIntSize: integer;
+  sdpMemoryStream: TMemoryStream;
+  sdpFileStream: TFileStream;
+  rcvdStream: TMemoryStream;
+  unknownModName: Boolean;
+begin
+  try
+
+    FhttpGet := THttpCli.Create(MainForm);
+
+    rcvdStream := TMemoryStream.Create;
+    FhttpGet.RcvdStream := rcvdStream;
+    FhttpGet.URL := '<A HREF="http://packages.springrts.com/versions.gz">http://packages.springrts.com/versions.gz</A>';
+    FhttpGet.Get;
+    if FAbord then
+      Raise Exception.Create('Download aborted');
+    decompressedStream := TMemoryStream.Create;
+    FhttpGet.RcvdStream.Seek(0,soFromBeginning);
+    GZDecompressStream(FhttpGet.RcvdStream,decompressedStream);
+    decompressedStream.Seek(0,soFromBeginning);
+    decompressedStreamSize := decompressedStream.Size;
+    SetLength(tagListStr,decompressedStreamSize);
+    decompressedStream.Read(tagListStr[1],decompressedStreamSize);
+    FreeAndNil(decompressedStream);
+    FreeAndNil(rcvdStream);
+    FhttpGet.RcvdStream := nil;
+
+    tagValues := TStringList.Create;
+    cp := @tagListStr[1];
+    while true do
+    begin
+      tagValue := '';
+      tagValues.Clear;
+      while (cp^ &lt;&gt; #10) and (cp^ &lt;&gt; #0) do
+      begin
+        if cp^ = ',' then
+        begin
+          tagValues.Add(tagValue);
+          tagValue := '';
+        end
+        else
+          tagValue := tagValue + cp^;
+        Inc(cp);
+      end;
+      tagValues.Add(tagValue);
+
+      if (tagValues.Count = 4) and (((tagValues[3] = modName) and (rapidName = '')) or (rapidName = tagValues[0])) then
+        break;
+
+      if cp^ = #0 then
+        break;
+      Inc(cp);
+    end;
+
+    SetLength(fileMd5Str,32);
+
+    unknownModName := False;
+    if (tagValues.Count = 4) and (((tagValues[3] = modName) and (rapidName = '')) or (rapidName = tagValues[0])) then
+    begin
+      FDep := tagValues[2];
+      if FDep &lt;&gt; '' then
+        Synchronize(DownloadDep);
+
+      sdpMemoryStream := TMemoryStream.Create;
+      FhttpGet.RcvdStream := sdpMemoryStream;
+      FhttpGet.URL := '<A HREF="http://packages.springrts.com/packages/">http://packages.springrts.com/packages/</A>'+tagValues[1]+'.sdp';
+      FhttpGet.Get;
+      if FAbord then
+        Raise Exception.Create('Download aborted');
+      decompressedStream := TMemoryStream.Create;
+      FhttpGet.RcvdStream.Seek(0,soFromBeginning);
+      GZDecompressStream(FhttpGet.RcvdStream,decompressedStream);
+      FhttpGet.RcvdStream := nil;
+
+      decompressedStream.Seek(0,soFromBeginning);
+      filesBitArray := TBitList.Create;
+      filesList := TList.Create;
+      while decompressedStream.Position &lt; decompressedStream.Size do
+      begin
+        if FAbord then
+          Raise Exception.Create('Download aborted');
+        if decompressedStream.Read(fileNameLength,1) &lt;&gt; 1 then
+          raise Exception.Create('Corrupted sdp');
+        SetLength(fileRealName,fileNameLength);
+        if decompressedStream.Read(fileRealName[1],fileNameLength) &lt;&gt; fileNameLength then
+          raise Exception.Create('Corrupted sdp');
+        if decompressedStream.Read(fileMd5,16) &lt;&gt; 16 then
+          raise Exception.Create('Corrupted sdp');
+        if decompressedStream.Read(fileCRC,4) &lt;&gt; 4 then
+          raise Exception.Create('Corrupted sdp');
+        if decompressedStream.Read(fileSize,4) &lt;&gt; 4 then
+          raise Exception.Create('Corrupted sdp');
+        fileSize := SwapEndian(fileSize);
+
+        BinToHex(@fileMd5[0],PAnsiChar(fileMd5Str),16);
+
+        fileMd5Str := LowerCase(fileMd5Str);
+
+        fileMd5Path :='pool\'+LeftStr(fileMd5Str,2)+'\'+MidStr(fileMd5Str,3,50)+'.gz';
+
+        if not (FileExists(GetMyDocuments+'\My Games\Spring\'+fileMd5Path) or FileExists(ExtractFilePath(Application.ExeName)+fileMd5Path)) then
+        begin
+          New(fileInfo);
+          fileInfo.Size := fileSize;
+          fileInfo.Md5 := fileMd5Str;
+          fileInfo.crc := fileCRC;
+          fileInfo.realName := fileRealName;
+          fileInfo.poolPath := fileMd5Path;
+          filesList.Add(fileInfo);
+          filesBitArray.AddBit(True);
+        end
+        else
+          filesBitArray.AddBit(False);
+      end;
+
+      bitArrayStream := TMemoryStream.Create;
+      filesBitArray.WriteDataToStream(bitArrayStream);
+      FreeAndNil(filesBitArray);
+      bitArrayStream.Seek(0,soFromBeginning);
+      compressedBitArray := TMemoryStream.Create;
+      GZCompressStream(bitArrayStream,compressedBitArray);
+      FreeAndNil(bitArrayStream);
+      compressedBitArray.Seek(0,soFromBeginning);
+
+      FhttpPost := THttpCli.Create(MainForm);
+      filesStream := TFileStream.Create('TASClient_Rapid_Files_Temp.bin',fmOpenWrite or fmCreate);
+      FhttpPost.RcvdStream := filesStream;
+      FhttpPost.SendStream := compressedBitArray;
+      FhttpPost.URL := '<A HREF="http://packages.springrts.com/streamer.cgi?">http://packages.springrts.com/streamer.cgi?</A>'+tagValues[1];
+      FhttpPost.OnDocData := DownloadDocData;
+      Synchronize(DownloadStart);
+      FhttpPost.Post;
+      if FAbord then
+        Raise Exception.Create('Download aborted');
+
+      filesStream.Seek(0,soFromBeginning);
+
+      i := 0;
+      while filesStream.Read(fileSize,4) = 4 do
+      begin
+        if FAbord then
+          Raise Exception.Create('Download aborted');
+        if i &gt;= filesList.Count then
+          raise Exception.Create('Too many files streamed');
+        fileSize := SwapEndian(fileSize);
+        if fileSize &gt; MaxInt then
+          Exception.Create('Incorrect streamed file size');
+        fileIntSize := fileSize;
+
+        SetLength(fileContent,fileIntSize);
+        if filesStream.Read(fileContent[1],fileIntSize) &lt;&gt; fileIntSize then
+          raise Exception.Create('Corrupted streamer data');
+
+        MakePath(ExtractFilePath(ExtractFilePath(Application.ExeName)+PRapidFileInfo(filesList[i]).poolPath));
+        fileStream := TFileStream.Create(ExtractFilePath(Application.ExeName)+PRapidFileInfo(filesList[i]).poolPath,fmOpenWrite or fmCreate);
+        if fileStream.Write(fileContent[1],fileIntSize) &lt;&gt; fileIntSize then
+          raise Exception.Create('Rapid file writing failed');
+        FreeAndNil(fileStream);
+
+        Inc(i);
+      end;
+      if i &lt; filesList.Count then
+        raise Exception.Create('Incorrect number of files received');
+
+      sdpMemoryStream.Seek(0,soFromBeginning);
+      MakePath(ExtractFilePath(Application.ExeName)+'packages');
+      sdpFileStream := TFileStream.Create(ExtractFilePath(Application.ExeName)+'packages\'+tagValues[1]+'.sdp',fmOpenWrite or fmCreate);
+      sdpFileStream.CopyFrom(sdpMemoryStream,sdpMemoryStream.Size);
+      FreeAndNil(sdpMemoryStream);
+      FreeAndNil(sdpFileStream);
+
+      for i:=0 to filesList.Count-1 do
+        FreeMem(PRapidFileInfo(filesList[i]));
+      FreeAndNil(filesList);
+      FreeAndNil(filesStream);
+      FreeAndNil(compressedBitArray);
+      FreeAndNil(FhttpPost);
+      DeleteFile('TASClient_Rapid_Files_Temp.bin');
+    end
+    else
+      unknownModName := True;
+
+    if FAbord then
+      Raise Exception.Create('Download aborted');
+
+    FreeAndNil(tagValues);
+    FreeAndNil(FhttpGet);
+
+    if FDlerForm &lt;&gt; nil then
+      if unknownModName then
+        Synchronize(FDlerForm.NormalDownload)
+      else
+        Synchronize(DownloadDone);
+  except
+    on E:Exception do
+    begin
+      FreeAndNil(rcvdStream);
+      if filesList &lt;&gt; nil then
+        for i:=0 to filesList.Count-1 do
+          FreeMem(PRapidFileInfo(filesList[i]));
+      FreeAndNil(filesList);
+      FreeAndNil(filesStream);
+      FreeAndNil(compressedBitArray);
+      FreeAndNil(decompressedStream);
+      FreeAndNil(FhttpPost);
+      FreeAndNil(tagValues);
+      FreeAndNil(FhttpGet);
+      FreeAndNil(sdpMemoryStream);
+      FreeAndNil(sdpFileStream);
+      FreeAndNil(fileStream);
+      FreeAndNil(bitArrayStream);
+      FreeAndNil(filesBitArray);
+      if FileExists('TASClient_Rapid_Files_Temp.bin') then
+        DeleteFile('TASClient_Rapid_Files_Temp.bin');
+
+      ExceptionRaised(E.Message);
+    end;
+  end;
+end;
+
+constructor TRapidDownloadThread.Create(Suspended : Boolean; dlerForm: TSpringDownloaderForm; modName: string; rapidName: string);
+begin
+   FreeOnTerminate := True;
+   inherited Create(Suspended);
+   OnTerminate := OnTerminateProcedure;
+
+   FModName := modName;
+   FRapidName := rapidName;
+   FDlerForm := dlerForm;
+   FAbord := False;
+end;
+
+procedure TRapidDownloadThread.Abort;
+begin
+  try
+    if FhttpGet &lt;&gt; nil then
+      FhttpGet.Abort;
+  except
+  end;
+  try
+    if FhttpPost &lt;&gt; nil then
+      FhttpPost.Abort;
+  except
+  end;
+  FAbord := True;
+end;
+
+procedure TRapidDownloadThread.RaiseException;
+begin
+  if FDlerForm &lt;&gt; nil then
+    FDlerForm.DownloadProgress(0,0,false,true,true,FExceptionMsg);
+end;
+
+procedure TRapidDownloadThread.ExceptionRaised(msg: string);
+begin
+  FExceptionMsg := msg;
+  Synchronize(RaiseException);
+end;
+
+procedure TRapidDownloadThread.DownloadDocData(Sender: TObject; Buffer: Pointer; Len: Integer);
+begin
+  if FDlerForm &lt;&gt; nil then
+    FDlerForm.DownloadProgress(THttpCli(Sender).RcvdStream.Size,THttpCli(Sender).ContentLength);
+end;
+
 end.

Modified: Lobby/TASClient/TASClient.dof
===================================================================
--- Lobby/TASClient/TASClient.dof	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/TASClient.dof	2011-02-19 18:56:51 UTC (rev 7585)
@@ -113,9 +113,9 @@
 IncludeVerInfo=1
 AutoIncBuild=1
 MajorVer=0
-MinorVer=86
+MinorVer=87
 Release=0
-Build=1243
+Build=1247
 Debug=0
 PreRelease=0
 Special=0
@@ -126,7 +126,7 @@
 [Version Info Keys]
 CompanyName=
 FileDescription=Spring RTS Engine lobby client
-FileVersion=0.86.0.1243
+FileVersion=0.87.0.1247
 InternalName=
 LegalCopyright=
 LegalTrademarks=

Modified: Lobby/TASClient/TASClient.dpr
===================================================================
--- Lobby/TASClient/TASClient.dpr	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/TASClient.dpr	2011-02-19 18:56:51 UTC (rev 7585)
@@ -100,7 +100,8 @@
   WidgetDBFormUnit in 'WidgetDBFormUnit.pas' {WidgetDBForm},
   Controls in 'Controls.pas',
   Windows,
-  Registry;
+  Registry,
+  BitList in 'BitList.pas';
 
 var
   i: Integer;

Modified: Lobby/TASClient/TASClient.res
===================================================================
(Binary files differ)

Modified: Lobby/TASClient/UploadReplayUnit.pas
===================================================================
--- Lobby/TASClient/UploadReplayUnit.pas	2011-02-12 15:23:54 UTC (rev 7584)
+++ Lobby/TASClient/UploadReplayUnit.pas	2011-02-19 18:56:51 UTC (rev 7585)
@@ -102,7 +102,7 @@
     ProgressBarForm.Refresh;
     ProgressBarForm.pb.Max := MultiPartFormDataStream.Size;
     ProgressBarForm.pb.Position := 0;
-    
+
     IdHTTP1.Post('<A HREF="http://replays.adune.nl/?act=upload&amp;do=upload&amp;secretzon=lamafaarao">http://replays.adune.nl/?act=upload&amp;do=upload&amp;secretzon=lamafaarao</A>', MultiPartFormDataStream, ResponseStream);
     ResponseStream.Seek(0,0);
     SetLength(ResponseStr, ResponseStream.Size);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002354.html">[Taspring-linux-commit] r7584 - in Lobby/TASClient: . Python/scripts
</A></li>
	<LI>Next message: <A HREF="002356.html">[Taspring-linux-commit] r7586 - in Lobby/TASClient: .	LobbyComponents/delphizlib
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2355">[ date ]</a>
              <a href="thread.html#2355">[ thread ]</a>
              <a href="subject.html#2355">[ subject ]</a>
              <a href="author.html#2355">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/taspring-linux-commit">More information about the Taspring-linux-commit
mailing list</a><br>
</body></html>
